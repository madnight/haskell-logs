00:02:26 <jgt> dmwit: that's what I think too
00:04:24 <jgt> dmwit: and anyway, I'm glad to be pushed to look for better solutions. That was the idea of using Exercism in the first place.
00:06:14 * day exorcises jgt 
00:07:14 <jgt> I'd recite a line from the film, but I'm sure I'd get banned from the channel
00:09:00 * hackage polysemy-zoo 0.6.0.1 - Experimental, user-contributed effects and interpreters for polysemy  https://hackage.haskell.org/package/polysemy-zoo-0.6.0.1 (isovector)
00:09:02 * ski isn't sure why, as long as it's brief, not too distracting to other conversations, and not in bad taste ..
00:09:19 <jgt> *the* line from that film is in exceptionally bad taste
00:09:43 <ski> ah, i see :)
00:15:39 <MarcelineVQ> a film about bad restaurants
00:17:43 <jgt> …in a way? I guess?
00:20:00 * hackage lzip 0.0.0.0 - Lzip compression / Lzlib bindings  https://hackage.haskell.org/package/lzip-0.0.0.0 (HerbertValerioRiedel)
00:31:51 <iqubic> This GADT definition for Either makes me twitch so much.
00:31:59 <iqubic> "data Either a :: Type -> Type where..."
00:33:44 <iqubic> Actually??!?! I'm not as well versed in GADTs as I would like to be.
00:34:21 <iqubic> Left :: a -> Either a b
00:34:31 <iqubic> Right :: b -> Either a b
00:37:59 <Ariakenom> iqubic: that first line looks odd, why is one parameter applied?
00:38:57 <asheshambasta> Has anyone here been using protobufs at scale especially with Haskell? What's a good library for that; and how has the experience been so far? 
00:39:35 <Ariakenom> Either :: Type -> Type -> Type; Etiher a :: Type -> Type; Either a b :: Type; but why the middle one
00:50:06 <iqubic> Because you can.
00:54:27 <Ariakenom> -.-
00:55:32 <lavalike> you don't use GADT's principal feature of restricting the return type of the constructors in such a definition
00:57:00 <Ariakenom> (which is fine. you can just prefer the syntax)
00:58:27 <merijn> -XGADTSyntax :p
01:21:54 <lavalike> I guess also worth mentioning the 'a' in 'Either a' there has no scope
01:22:24 * ski usualy uses it parametrically, anyway
01:23:20 <ski> (like `data Vec a :: Nat -> * where Nil :: Vec a Zero; Cons :: forall n. a -> Vec a n -> Vec a (Succ n)')
01:25:30 <iqubic> You can give it scope with the ScopedTypeVariables PRAGM.
01:26:26 <iqubic> I think.
01:26:29 <iqubic> Not too sure.
01:27:37 <lavalike> I think not
01:48:37 <pikajude> i think i may be using reifyAnnotations incorrectly
01:48:45 <pikajude> or it doesn't work. let me whip up a test case real quick like
01:51:18 <pikajude> yep i was using it incorrectly, my test case works just fine
02:09:42 <pikajude> oh nooooooooooo, it's a GHC staging restriction
02:10:32 <pikajude> https://gist.github.com/pikajude/93efc3d7714d3811b5b7d0844de6ba20
02:10:41 <pikajude> if i swap the order of the two splices, only one of them shows the annotation
02:10:55 <pikajude> or rather, if I swap the order of the main binding and the top-level splice
02:11:01 <pikajude> is there any way around this? or documentation on how it works?
02:33:34 <bwe> What's the right approach to derive (+) operation for a data constructor Meters Deci? https://repl.it/repls/ZigzagSillyStaff
02:47:11 <merijn> bwe: deriving via, I suppose
02:47:42 <merijn> bwe: DeriveAnyClass just means you can write "deriving (Foo)" to get "instance Foo MyType" (note the lack of implementation!)
02:48:08 <merijn> So if the class doesn't work without explicit implementations (i.e. just the defaults is not enough) then DeriveAnyClass doesn't actually do anything
02:54:27 <jusss> can haskell do backend language like python or java ? to build a web service?
02:54:42 <Taneb> jusss: absolutely
02:55:01 <jusss> like python has tornado, flask, django, and java has spring stuff, what haskell has?
02:55:19 <jusss> Taneb: haskell can work with postgresql?
02:55:20 <Taneb> Yesod, servant, happstack, snap, scotty, warp
02:55:22 <Taneb> jusss: yes
02:55:32 <jgt> jusss: https://lmgtfy.com/?q=haskell+web+framework
02:55:51 <Taneb> jusss: http://hackage.haskell.org/package/postgresql-simple is a commonly used library for working with postgresql in Haskell
02:55:53 <jusss> Taneb: jgt does it need a high tech skills? I'm just a beginner
02:56:25 <jgt> jusss: beginner how exactly? Beginner web developer?
02:56:32 <jgt> jusss: do you know other languages?
02:56:38 <jusss> jgt: beginner on haskell
02:56:57 <jusss> jgt: I know python, kotlin, a little java, scheme, and javascript
02:57:05 <jgt> jusss: I was a beginner Haskeller when I started building websites with Yesod
02:57:30 <jgt> jusss: the documentation doesn't hold your hand as much as documentation for, say, Ruby on Rails
02:57:35 <jusss> jgt: I started building websites with tornado on python
02:57:37 <jgt> but the docuemntation is there
02:59:15 <jusss> jgt: does it need some high techs? like CPS? Cont Monad?
02:59:24 <jgt> jusss: not really
02:59:52 <jusss> jgt: and run-time exceptions?
03:00:16 <jgt> jusss: there's a DSL for routing. You don't really need to know any Haskell to understand how Yesod routing works. It also has a DSL for model definitions (though this is Persistent, not Yesod)
03:00:34 <jgt> jusss: I don't understand your question about run-time exceptions
03:00:45 <jusss> jgt: yeah, I heard hasekll is very good at DSL
03:01:06 <jusss> jgt: can I need to learn how to catch run-time exceptions in haskell?
03:01:38 <jusss> jgt: not the Either stuff
03:01:43 <jgt> if you cause a run-time error in a Handler, the server will serve a 500
03:02:00 <jgt> you don't need to think about it much more than that
03:02:52 <jusss> jgt: what are I should to care?
03:03:20 <jusss> what do I should care
03:03:23 <jgt> I'm starting to feel like a sort of Yesod salesman, so I'm not going to explain this any further. The best thing for you to do is go and read a tutorial, and actually try building something.
03:03:55 <jusss> ok
03:13:30 * hackage dirtree 0.1.0 - A small library for working with directories.  https://hackage.haskell.org/package/dirtree-0.1.0 (kalhauge)
03:15:37 <Bish> how is constant access in Data.Vector possible? is it just unpure code? or can you build something like that with lambda-calculus?
03:15:42 <Bish> i have problems imagining that
03:16:24 <Bish> impure*
03:16:25 <Bish> i guess
03:18:45 <[exa]> Bish: by constant-access you mean "writing that doesn't copy the whole vector"? b/c Data.Vector has const-time element read
03:19:56 <Bish> i mean O(1)
03:20:00 <Bish> constant-time-access
03:20:33 <Bish> and i wonder how you can write something like that with only recursive expressions
03:21:27 <Bish> is it required to wrap impure C(++)/asm code to get that or is there some magic
03:23:31 <[exa]> yeah, data.vector access is O(1); internally it uses arrays that are in GHC modeled basically as finite-domain functions with some minor implementation tricks that allow the O(1)
03:24:42 <Bish> so it's magic, and not just wrapped unsafe code?
03:24:54 <[exa]> if you disallow the implementation trick, the stuff gets a bit harder but not that much (see e.g. Data.Seq)
03:25:32 <[exa]> not totally magic but an extra primitive indeed.. there shold be some reading in ghc manual about that
03:25:58 <Bish> that is sad
03:27:15 <[exa]> why?
03:27:17 <[exa]> (it works! :D )
03:27:44 <Bish> hm, it basicially means it's not possible to have a performant haskell only machine
03:28:09 <Bish> it's just an idealistic approach, but it would cool if haskell would be able to bootstrap itself
03:28:34 <Bish> i mean it can.. but not with constant-time-access data structures
03:28:43 <Bish> am i wrong?
03:28:54 <[exa]> it's a pragmatic approach.
03:29:24 <Bish> yeah, but you will never get around that with only haskell, i think that's sad somehow
03:30:08 <Bish> what does the required primitive do?
03:38:34 <Ariakenom> Bish: what is "only haskell"?
03:39:16 <[exa]> Bish: there is no point in doing a haskell-only system btw; there are various languages for various stuff, and at some point you will need assembly to do syscalls and similar. Which is impure by design.
03:42:52 <Ariakenom> yes. in that sense you can't write to a file in only C or only Java.
03:45:25 <__monty__> C can only do O(1) array indexing because the hardware supports it. I don't see why a hypothetical haskell-machine wouldn't be allowed a similar primitive.
03:48:25 <Logio> I was thinking about a hypothetical Haskell machine at one point, though mostly in terms of having very granularly typed IO exposed from it
03:49:25 <Logio> I got to wondering whether you could model a hardware system at the type level in such a way that a compiler could prevent rowhammer attacks etc.
04:02:44 * ski . o O ( "The Myth of RAM, part I" by Emil Ernerfeldt in 2014-04-21 at <http://www.ilikebigbits.com/2014_04_21_myth_of_ram_1.html> )
04:08:29 <[exa]> ski: that is a lovable article, thank you
04:09:23 <ski> yw :)
04:10:27 <trcc> Anyone where capable of assisting with ghcide? It fails to load in vscode: "Launching server using command ghcide failed". Running it in terminal gives me an error in one file, which can be left out. Anyone know how to do this?
04:16:30 <trcc> Anyways, if anyone has some clues, then you are very welcome to write in https://github.com/digital-asset/ghcide/issues/44
04:21:10 <WilliamHamilton> Hi, I have a problem with beam, similar to https://github.com/tathougies/beam/issues/346 and I was hoping to find some suggestions
04:21:35 <WilliamHamilton> the structure of the code is something like:
04:22:15 <WilliamHamilton> runSelectReturningList $ select $ dol <- all_ (db^.leads)
04:22:26 <WilliamHamilton> sorry
04:22:35 <trcc> Probably just a command-line argument.
04:22:35 <WilliamHamilton> runSelectReturningList $ select $ do
04:22:53 <WilliamHamilton> l <- all_ (db^.leads)
04:24:25 <WilliamHamilton> nub_ $ union_  (somethingContaining1 l)  (somethingContaining2 l)
04:24:40 <orzo> Regarding the type  http://hackage.haskell.org/package/ghc-8.6.5/docs/CoreSyn.html#t:Bind , is (Rec [(b,x)]) treated equivelently to (NonRec b x) or does the latter disallow use of b within the expression x?
04:24:58 <WilliamHamilton> but it seems I cannot use l inside the nested context. I'd like to know a workaround for this
04:27:23 <orzo> So far, the best documentation I could find for this question is a blog http://www.stephendiehl.com/posts/ghc_03.html which says only "Bindings that are mutually recursive are encoded as a list of binders." which leaves it ambiguous what the proper way is to represent a binder to a recursive function that refers only to itself and is not "mutually recursive" with another function.
04:31:00 * hackage some 1 - Existential type: Some  https://hackage.haskell.org/package/some-1 (phadej)
04:41:57 <orzo> Another blog http://neilmitchell.blogspot.com/2007/03/let-vs-letrec.html defines (let) and (letrec) and implies that (let x = x) is not neccessarily _|_ where (letrec x = x) is.  So if NonRec and Rec correspond, then a recursive function must use the Rec form with a singleton list and not the NonRec form.
04:43:13 <orzo> I'm leaning toward this interpretation, because otherwise NonRec seems kind of pointless.
04:43:40 <orzo> stil would appreciate confirmation if anybody can give me that
04:56:00 * hackage optparse-applicative 0.15.1.0 - Utilities and combinators for parsing command line options  https://hackage.haskell.org/package/optparse-applicative-0.15.1.0 (huw)
05:00:19 <Bish> [exa]: yeah but most languages are able to bootstrap that themselves.. i mean you can write O(1) arrays in C and put it into glibc
05:00:26 <Bish> you can't do that with haskell
05:00:55 <Bish> Ariakenom: well, exactly that, you won't be able to express something like a O(1) array in haskell without tricks
05:01:07 <merijn> christ...someone implemented type-level regexes...
05:01:21 <[exa]> Bish: "most languages"? in fact haskell is pretty high on the self-bootstrapping ladder
05:01:22 <merijn> Bish: Wut? How so?
05:01:22 <Bish> merijn: why is that a bad idea?
05:01:31 <Ariakenom> sounds scary
05:01:37 <merijn> Bish: I didn't say it was *bad*, it's just insane
05:01:46 <Ariakenom> here are some lens-regexes as eye bleach (1000)**2 / (2*2**32)
05:01:58 <Ariakenom> that python code was not the link I meant. https://hackage.haskell.org/package/lens-regex-pcre
05:02:09 <Bish> merijn: well, imagine you have to write RTS in haskell
05:02:25 <merijn> Bish: ok
05:02:41 <Bish> how do you write constant-time-acess vectors without primitives
05:02:48 <Ariakenom> Bish: were you responding to my first or 2nd msg?
05:03:10 <Bish> Ariakenom: "what is "only haskell""
05:03:20 <merijn> Bish: How do you write constant time vectors in C without primitives?
05:03:38 <Bish> what is a c primitive?
05:03:41 <Ariakenom> Bish: ok. I still dont know what that means
05:04:05 <Ariakenom> IO is clearly a primitive, no?
05:04:10 <merijn> Bish: I mean, pointers and dereferencing logic are all implemented inside the C compiler. The same applies to GHC
05:04:13 <Ariakenom> (the haskell type)
05:04:14 <nshepperd2> What do type level regexes match on
05:04:21 <merijn> Ariakenom: Don't even need IO for mutable vectors in GHC
05:04:44 <Ariakenom> merijn: I wasn't getting at that. Just meant that primitives are everywhere
05:05:00 <Bish> merijn: well you have a point there, but you are able to write a compiler in C that does that
05:05:06 <Bish> there i no need to have assembler in there
05:05:43 <nshepperd2> You can't do anything in any language without primitives
05:06:03 <merijn> Bish: You can do the same in a Haskell compiler, I mean, GHC itself is already pure Haskell. Only the runtime isn't, but there isn't a lot that stops you from implementing a compiler with a Haskell only RTS (I mean, besides the effort)
05:06:30 <Bish> merijn: yeah but would that haskell-only-rts havea  constant time vector access
05:06:36 <Bish> without having inline assembler
05:06:37 <merijn> Bish: Sure, why not
05:06:43 <merijn> Anyway, can't argue now, got a meeting
05:07:02 <Bish> merijn: well, because i feel like something like that isn't expressable in lambda calculus
05:07:05 <Bish> good luck
05:07:25 <Bish> that's the question i wanted to have solved
05:07:42 <Ariakenom> but haskell isn't just lambda calculus. I return to what you mean by "just haskell"
05:07:59 <nshepperd2> Opening files isn't expressible in lambda calculus either
05:11:45 <Bish> well, my assumption is that the abstraction that haskell adds to the substrate it's running on so hard, that you cannot express random acess datatypes that are accessible with constant  speed
05:11:53 <mniip> nshepperd2, debatable
05:12:43 <Ariakenom> Ill try to argue for merijn. Just like you would use C's [] primitive to implement arrays in the C compiler you'd use Haskell primitives for haskell. (These compiler don't make sense. But I )
05:13:14 <Ariakenom> ... But the parallels are clear
05:13:46 <Bish> yeah it's a very 1:1 connection between [eax] and *ptr
05:13:55 <Bish> or rax ax ah al whatever
05:14:01 <Bish> that doesn't exist in hask
05:15:14 <Bish> that's what i mean with "abstraction added"
05:15:34 <Ariakenom> Bish: the parallel was between C's int[] and haskell's Vector Int both being "primitive"
05:15:56 <Bish> but one of them links with the cpu, the other one links with the RTS
05:16:43 <Bish> and you cannot express a RTS that does that with haskell
05:16:59 <Bish> hence my original assumption, you cannot do that with haskell alone :o
05:17:07 <nshepperd2> They're both implemented by the compiler
05:17:18 <Bish> by 2 compilers
05:17:26 <Bish> one having a language that is not haskell
05:17:28 <nshepperd2> Which emits appropriate machine code
05:18:19 <nshepperd2> It doesn't really matter what language the compiler is written in
05:18:19 <Ariakenom> Vector doesn't touch the RTS (afaik). It's all the compiler
05:18:52 <Bish> sure it doesn't matter, but it does for my question
05:19:01 <Bish> you are not able to express something like that with haskell, right?
05:19:01 <nshepperd2> No, it doesn't
05:19:10 <nshepperd2> Yes, you can
05:19:26 <Bish> are you going to argue "the primitives are part of haskell" again?
05:19:30 <nshepperd2> The compiler is just a program which outputs a file with machine code
05:23:29 <Ariakenom> Bish: I still don't know what "just haskell" is but the report includes Array https://www.haskell.org/definition/haskell2010.pdf#chapter.14
05:24:45 <Ariakenom> as well as pointers https://www.haskell.org/definition/haskell2010.pdf#chapter.29
05:26:30 * hackage some 1.0.0.1 - Existential type: Some  https://hackage.haskell.org/package/some-1.0.0.1 (phadej)
05:27:08 <Bish> but those things will be written in C, don't they?
05:27:16 <Bish> atleast primitives that use those
05:27:22 <orzo> a compiler should probably be written in a language that is very well represented for many cpus and platforms.  That way you lessen the bootsrapping pain.
05:27:29 <Bish> but i get your point.. even if you cannot express things like that in haskell
05:27:38 <Bish> you can write a compiler, that outputs code that does that
05:27:46 <Bish> which would be somewhat equivalent to a C-RTS
05:27:53 <Ariakenom> Bish: no they will be amitted as assembler from the compiler
05:27:59 <ski> (if they're in the report, how can you say "you cannot express things like that in haskell" ?)
05:28:00 <Bish> that's what i meant
05:28:05 <Ariakenom> just like C
05:28:08 <Ariakenom> no difference
05:30:04 <Ariakenom> ski: yes hence why I keep asking Bish to define what their just Haskell is. They did mention lambda calulus but haskell is clearly not lambda calculus
05:30:45 <Bish> not just calculus, or is there something in lambda calculus that is not in haskell
05:37:42 <exarkun> How do I get stack to stop rebuilding stripe-core 25 times a day?
05:45:12 <trcc> is there a database of compiled haskell packages?
05:50:10 <dminuoso> trcc: You mean nix cache? ;)
05:50:42 <trcc> dminuoso: something like it yes. Does one have to use nix to use nix cache? :P
05:51:58 <fendor> isnt there also cabal-cache?
05:52:10 <fendor> https://github.com/haskell-works/cabal-cache
05:55:32 <merijn> Bish: What makes you think a Haskell compiler is restricted to lambda calculus, though?
05:57:52 <trcc> thank you, will look through it
05:58:58 <merijn> Bish: In the end compilers are just tools that (semantics preservingly!) map and input language to an output language. In case of compilers that compile to machine code that output language is "assembly", there is no rules about what kind of assembly a compiler is or isn't allowed to output. The only rules are "the end result should have the same semantics as the input", even stuff like a garbage 
05:59:04 <merijn> collector could just be "assembly output by the compiler" (I mean, generally people don't want to write that sorta stuff in assembly/in the compiler code generator, but nothing's stopping you)
06:23:30 * hackage replace-megaparsec 1.1.3.0 - Stream edit, find-and-replace with Megaparsec parsers  https://hackage.haskell.org/package/replace-megaparsec-1.1.3.0 (JamesBrock)
06:26:00 * hackage replace-attoparsec 1.0.1.0 - Stream edit, find-and-replace with Attoparsec parsers  https://hackage.haskell.org/package/replace-attoparsec-1.0.1.0 (JamesBrock)
06:29:45 <homebeach[m]> I should investigate whether a given number is a sum of two odd numbers. What is the best way to do this?
06:31:00 <jgt> > even 4
06:31:03 <lambdabot>  True
06:31:08 <jgt> homebeach[m]: like that?
06:32:39 <homebeach[m]> But if I need to degine x belongs to odds, y belongs to odds is x+y==a
06:32:41 <homebeach[m]> if i give a
06:32:51 <jgt> > even 0
06:32:53 <lambdabot>  True
06:32:56 <homebeach[m]>  * But if I need to define x belongs to odds, y belongs to odds is x+y==a
06:33:44 <jgt> I don't understand your question now
06:34:12 <Taneb> homebeach[m]: I'm not sure this is a Haskell question (if it is, the Haskell part is the easier part of it)
06:35:00 <homebeach[m]> well I need to make a function isSumOfOdds a
06:35:03 <sshine> homebeach[m], all even numbers are the sum of two odd numbers. no odd numbers are the sum of two odd numbers. so `even` does this.
06:35:19 <sshine> homebeach[m], isSumOfOdds = even
06:35:34 <jgt> homebeach[m]: in your `isSumOfOdds a`, where do the odd numbers come from?
06:35:59 <homebeach[m]> yes but, if I need to define equation x+y==a where x is even and y is even
06:36:27 <Taneb> homebeach[m]: what's your favourite odd number
06:36:27 <homebeach[m]> The program needs to investigate the possible sums of x+y that are odd
06:36:33 <sshine> homebeach[m], but isn't isSumOfOdds :: Int -> Bool? where do x and y come in?
06:37:00 * hackage universe-some 1.2 - Universe instances for Some from some  https://hackage.haskell.org/package/universe-some-1.2 (phadej)
06:37:29 <jgt> homebeach[m]: as sshine already pointed out, if `x` and `y` are both even, then `a` will always be even
06:37:48 <sshine> homebeach[m], but there are infinitely many solutions. if your program needs to investigate, but not return them, how will the infinitely many odd numbers 'x', 'y' that add up to 'a' come into the equation?
06:38:00 * hackage universe-dependent-sum 1.2 - Universe instances for types from dependent-sum  https://hackage.haskell.org/package/universe-dependent-sum-1.2 (phadej)
06:39:00 * hackage universe 1.2 - A class for finite and recursively enumerable types.  https://hackage.haskell.org/package/universe-1.2 (phadej)
06:39:31 <sshine> homebeach[m], 'isSumOfOdds x = even x'. or if you want, 'isSumOfOdds x = not (even (x - 1))', since then (x - 1) and 1 add up to x.
06:40:41 <sshine> homebeach[m], or... generate infinite sequences of of all odd (x,y) and ask if `any (\(x, y) -> even (x+y))` on that sequence.
06:41:59 * homebeach[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/JSsnwpzdtpaNSVFLDAYniUFJ >
06:42:11 <homebeach[m]> I was thinking something like this but seems not to work
06:43:10 <sshine> homebeach[m], 'where' is used for declaring things, you seem to be using them for something like guards, but you never define x and y.
06:44:49 <sshine> homebeach[m], I can get progressively more silly. :) the answer to the question is looking at a diagram of the combinations of (x+y) where x and y are odd/even: odd+odd -> even, even+even -> even, even+odd -> odd, odd+even -> odd. since your question is "is this number a sum of two odd numbers?" the way you test it is you find some property of numbers that are the sum of two odd numbers, that isn't a prope
06:44:55 <sshine> rty of numbers that aren't the sum of two odd numbers, and test that property.
06:44:58 <sshine> that property is called "is the number even?"
06:46:01 <sshine> you know that the sum of two odd numbers is always even  <=>  you know that even numbers are the sum of two odd numbers.  <=>  you know that a number is the sum of two odd numbers when it is even.
06:46:38 <jgt> homebeach[m]: what is compelling you to over-complicate the solution?
06:46:51 <sshine> you can pick any odd number and find its odd complement. but you don't need to.
06:48:19 <sshine> if, for x + y = z, you feel that you must generate solutions for these two odd numbers, you could pick x = 1 and y = z - 1. but since `isSumOfOdds :: Int -> Bool', you'd throw the x, y you picked away anyways.
06:49:11 <jgt> homebeach[m]: why is `isSumOfOdds = even` not satisfactory?
06:50:16 <sshine> homebeach[m], if this is homework, you're not cheating if you go with 'even'. you may be cheating a little by asking here, though. ;-)
06:53:54 <Bish> merijn: never said it's restricted the opposite is the case
06:54:03 <Bish> last question: what is the primitive Data.Vector needs?
06:57:34 <dminuoso> Bish: What do you mean by primitive?
07:02:20 <Bish> something that enables random access with constant speed
07:02:57 <dminuoso> I do not understand the question.
07:05:07 <laudecay> hey can i ask some obscure questions about haskell's GC
07:05:38 <maralorn> Are there any datatypes for describing e-mails (and parsing them ideally)? I found libraries for the headers but nothing for the body.
07:05:45 <merijn> Bish: Data.Vector is just built on top of https://hackage.haskell.org/package/primitive
07:05:54 <Ariakenom> laudecay: you can certainly ask :)
07:05:58 <merijn> laudecay: Yes, no, maybe, we won't know until you ask :p
07:06:27 <dminuoso> Bish: At its core the idea is that it needs IO or ST.
07:06:30 <laudecay> if i decide to write c bindings for a crypto library 1. how painful is that gonna be and 2. if i decide to only work with haskell-land-allocated memory instead of futzing with malloc/free, and i have key material in this memory, should i be worried about the GC moving it around? ocaml has this major/minor heap situation and you can't go zero memory when it copies (only attach finalizers for when it frees) so
07:06:32 <laudecay> it's kinda smearing secrets all over the heap
07:06:34 <merijn> maralorn: Email bodies don't really have a format, besides maybe "MIME"
07:06:43 <merijn> dminuoso: That's not true, that's just for mutable arrays
07:07:02 <merijn> dminuoso: Why would you need IO/ST for O(1) random access of an immutable array?
07:07:17 <laudecay> ig i could just do something that points to c memory and has zeroing/freeing the c memory attached as a finalizer, but that's sorta fucky/painful
07:07:36 <merijn> laudecay: There's already an FFI type for "pointer + finalizer" :)
07:07:40 <dminuoso> merijn: Oh right.
07:07:47 <laudecay> merijn: <3 wow gorgeous
07:08:06 <merijn> laudecay: Also, as long as you don't want to pass/return structs by value, nor mutate structs within Haskell writing FFI bindins is trivial
07:08:33 <laudecay> ok more questions! how's the cryptography libraries? are siphash/ed25519/blake2s/chacha20poly1305/xchachapoly1305 all stable?
07:08:38 <merijn> If you do want to mutate structs from within Haskell it's a bit more painful, but not that much
07:08:49 <merijn> @hackage cryptonite
07:08:49 <lambdabot> http://hackage.haskell.org/package/cryptonite
07:08:51 <maralorn> merijn: Yeah, I was thinking about MIME.
07:09:17 <merijn> laudecay: Not sure how stable cryptonite is, but it certainly seems to cover a lot implementations :)
07:09:56 <merijn> laudecay: I would recommend looking up Chapter 8 of the Haskell Report (chapter on FFI) and the GHC user guide on the FFI to get started. But assuming you're comfortable with C it should be fairly painless
07:10:06 <laudecay> ohhhhh my god this is incredible merijn the crypto support
07:10:12 <laudecay> i had to roll it myself in ocaml and
07:10:21 <laudecay> 3 libraries so many bugs found endless tears
07:10:35 <laudecay> they straight up weren't implement HMAC in digestif it was just something else entirely like a keyed mac
07:10:35 <merijn> laudecay: C bindings can be as simple and painless as: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/src/SQLiteExts.hs#L41-L73
07:10:51 <laudecay> i dont think id even need the c bindings cryptonite is so shiny and nice
07:11:22 <maralorn> merijn: I mean there should be a way to deal with e.g. attachments, right?
07:11:37 <maralorn> Besides is there something to read Maildirs?
07:11:52 <merijn> laudecay: I mean, those foreign imports are literally the entire FFI wrapping, there's just a .c and .h file with the implementation whose objects I link directly
07:12:18 <laudecay> ok um how /fast/ is cryptonite and how optimizable?
07:12:18 <merijn> maralorn: MIME supports multiple chunks in different formats, but tbh it's been awhile since I looked into email
07:12:36 <laudecay> like ed25519 point multiplication is super slow, in the C implementation of what i'm doing they throw it into another thread
07:12:38 <merijn> That I don't know, I just use it for a bunch of hashes and it's "fast enough for me" :)
07:12:43 <laudecay> fair
07:12:58 <laudecay> ok how's parallelism? like i assume there's some kind of analogue to ocaml's async?
07:13:14 <merijn> laudecay: Parallelism or concurrency?
07:13:21 <laudecay> also how are endian integers/building mutable c struct-like types?
07:13:23 <laudecay> both
07:13:59 <laudecay> ocaml is single core with concurrency with these weird fake threads and it's ://///
07:14:13 <merijn> base has a bunch of stuff for concurrency under Control.Concurrency, there's also Simon Marlow's "Parallel & Concurrent Haskell" (free online) that covers basically everything
07:14:35 <laudecay> shiny shiny shiny
07:14:50 <laudecay> promises? throttles/sequencers? schedulers?
07:15:16 <merijn> laudecay: It's basically N:M multiplexing (i.e. N lightweight threads multiplexed over M OS threads)
07:15:23 <laudecay> oh wonderful
07:15:30 <laudecay> can i control what gets an OS thread at all?
07:15:50 <laudecay> like gluing something to its own core?
07:15:57 <c_wraith> those are two different things
07:16:04 <merijn> laudecay: You can *pin* a thread to a specific OS thread, (and I suppose via FFI pin that thread to a core)
07:16:31 <laudecay> lit that's awesome
07:16:50 <laudecay> hmmm ok how's endian ints and cstruct-like memory management?
07:16:57 <merijn> laudecay: Althought that doesn't prevent other haskell threads from *also* being scheduled on that OS thread
07:17:02 <c_wraith> pretty good, actually.
07:17:12 <laudecay> like cstructs are not as type system integrated as i'd like which has been causing me /hell/ in ocaml
07:17:25 <c_wraith> Though it feels like writing C code in haskell.  All the pain comes back
07:17:27 <merijn> laudecay: I'd check the aforementioned Chapter 8 of the report and GHC user guide on FFI, for details on that
07:17:30 <laudecay> awesome
07:17:54 <laudecay> ok i think im gonna move my project over to haskell
07:18:13 <merijn> laudecay: You can roll your own mapping between Haskell types and "pointers to bytes", but that means you do need to figure out how your C implementation lays out structs (there's some tools for that, but it's a little annoying/painful)
07:18:39 <laudecay> for reference i'm reimplementing wireguard in ocaml at my internship, but it's ending in 2 weeks, and i've literally spent >75% of my time on this handling ocaml library/language shortcomings
07:19:03 <laudecay> and i'm gonna probably be joining the WG project as a maintainer so i'll have much more freedom very soon
07:19:11 <laudecay> and i think haskell might be the way to go
07:20:30 <c_wraith> Just a warning: memory use in Haskell is an entirely different skill than anything else you've ever learned.  It's not harder, but it's new and will take you a while to figure out.
07:21:04 <merijn> To be fair, coming from ocaml should make it fairly easy
07:21:31 <c_wraith> really?  I was under the impression that laziness was not used pervasively in ocaml
07:21:53 <merijn> It isn't, but I think people tend to struggle much more with the typing and writing recursive code than they do with laziness
07:22:22 <merijn> oh, wait, you were only referring to memory use
07:22:37 <c_wraith> Eh.  I'm thinking of projects like combinatorrent that got sunk by writing a huge amount of code with no regards to memory use caused by laziness.
07:23:06 <merijn> laudecay: Coming from ocaml you may wanna skip the usual texts and use the old school tutorial (since that was written as tutorial from people coming to haskell from (S)ML
07:23:11 <merijn> @where tutorial
07:23:11 <lambdabot> http://www.haskell.org/tutorial/
07:25:34 <Ariakenom> laudecay: Interesting, why are you porting it? I'm confused what situation where you are porting to ocaml but it's ok to switch to haskell.
07:26:40 <niko> /10/22
07:33:38 <laudecay> merijn: i know haskell already but ty!
07:33:58 <laudecay> Ariakenom: i'm porting to ocaml bc we want a functional one, maybe to integrate with mirage, and i am an intern at jane street rn and this is my intern project
07:34:11 <Ariakenom> c_wraith: I hadn't heard of combinatorrent. It seems it had issues with that but is currently fine. why "sunk"?
07:34:22 <laudecay> wg wants a functional implementation in userspace, so ocaml fills that need... but once my internship ends, so does haskell, and it probably does a better job
07:35:04 <c_wraith> Ariakenom: well, it caused the author to switch his development work to Erlang instead.  Maybe someone else has picked it up since then, but the guy originally driving it is gone.
07:35:08 <Ariakenom> Huh, a requirement of being FP. Interesting! :p
07:35:43 <Ariakenom> c_wraith: I found this https://github.com/jlouis/combinatorrent/blob/master/doc/haskell-vs-erlang.mkd It says the first version was erlang
07:36:25 <laudecay> c_wraith: what do you mean about memory usage from laziness?
07:36:30 <laudecay> could you link me to something about that?
07:37:04 <laudecay> like ik about thunks i just don't know the gory details especially about mutables
07:37:11 <laudecay> and it'd be good to know going into this ya feel
07:37:51 <c_wraith> Ariakenom: huh.  Guess I'm misremembering the history there
07:38:21 <Ariakenom> laudecay: the example from the post i linked was that statistics about downloads piled up as thunks if they werent displayed
07:39:53 <Ariakenom> "Furthermore, I should have focused on laziness earlier in the process. The first combinatorrent releases leak memory because of lazy thunk buildup. The latter versions, after I understood it intuitively, does not leak."
07:40:58 <c_wraith> The big problem with laziness and memory use is that no one has really characterized how to do it correctly so far.  Which I find frustrating, as everyone gets a feel for how to control memory use as they get experience, but it seems really hard to articulate what the rules are.
07:41:00 * hackage elynx-tools 0.0.1 - Tools for ELynx  https://hackage.haskell.org/package/elynx-tools-0.0.1 (dschrempf)
07:42:00 * hackage tlynx 0.0.1, slynx 0.0.1, elynx-tree 0.0.1, elynx-seq 0.0.1 (dschrempf)
07:44:35 <laudecay> the github? Ariakenom 
07:45:45 <Ariakenom> laudecay: yes
07:45:54 <laudecay> cool reading it now
07:46:03 <Ariakenom> it didnt have that much on laziness though
07:47:10 <c_wraith> laudecay: https://apfelmus.nfshost.com/blog/2013/08/21-space-invariants.html is the best attempt I've seen so far at explaining how to think about memory use in Haskell - but it's kind of abstract-sounding until you've run into those problems yourself.
07:48:17 <laudecay> oh cool yeah
07:48:23 <laudecay> coming from ocaml cant be that bad right
07:49:31 <c_wraith> it's just a completely new skill.  It's not really that hard, but you need to build up a bunch of base experience.
07:51:24 <jumper149> Hi, what is the recommended way to implement an (n x m) grid?
07:52:43 <c_wraith> with what properties?
07:52:53 <c_wraith> what operations do you want to be fast?
07:53:24 <asheshambasta> whats the best way to go from `[ m (Either a b ) ] -> m [ Either a [b] ]
07:53:37 <jumper149> Obviously it's possible to use something like `Vector a` and access elements with index `n*m + m`
07:54:27 <Ariakenom> jumper149: I like a Map from index to element. Map (nindex,mindex) element
07:55:02 <c_wraith> asheshambasta: that's a bit opaque of a transformation - I'm not sure when you want [Right [1], Right [2]] vs [Right [1, 2]]
07:55:03 <jumper149> Oups, I meant to ask a different question: How would I implement the coordinates to this board
07:55:19 <jumper149> s/board/grid
07:55:45 <c_wraith> if it's always going to be rectangular, your indexing method is right on
07:56:09 <sm[m]> c_wraith: thanks for that link, added to my contemplation list
07:56:25 <jumper149> But what if I want the coordinate to be more sophisticated than just an Int?
07:56:47 <jumper149> Does it make sense to use something like `data Coord = Coord Int Int`
07:57:06 <jumper149> and then define instances for Enum and or Bounded?
07:57:25 <c_wraith> jumper149: have you considered using https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Ix.html  ?
07:57:27 <geekosaur> have you looked at Array? which among otger things lets you use (Int,Int) directly
07:57:43 <geekosaur> via that Ix typeclass
07:57:44 <c_wraith> Array works by using Data.Ix.  :P
07:58:00 <geekosaur> which you can also define your own instances of, if you prefer some other indexing scheme
07:58:28 <jumper149> c_wraith: I think that's exactly what I'm looking for
07:58:44 <asheshambasta> c_wraith: the latter 
07:59:20 <c_wraith> asheshambasta: sure, but what's the rule?  You want to combine contiguous runs of Right constructors together?
08:00:10 <laudecay> how is like
08:00:11 <laudecay> logginc
08:00:14 <laudecay> logging *
08:00:32 <laudecay> Ariakenom: your blog post had the guy complaining a little about erlang logging being superior
08:02:08 <c_wraith> asheshambasta: in any case...  you probably want to combine sequence with fmap of whatever way you want to do [Either a b] -> [Either a [b]].
08:02:21 <geekosaur> erlang and such have the "advantage" that you can pop IO anywhere, because the whole program is secretly in IO. but this is also a disadvantage
08:03:08 <laudecay> geekosaur: yeah wrap that in a monad and hide it where nobody can see it
08:03:46 <Ariakenom> laudecay: that bit sounded more like erlang having a nice feature with logging and the process tree
08:04:09 <laudecay> yeah
08:04:11 <Ariakenom> I don't know about haskell logging, sry
08:05:31 <asheshambasta> c_wraith: yeah, my question was kind of incomplete as I'm seeing this problem
08:06:08 <c_wraith> asheshambasta: in any case, sequence gets you to m [Either a b], which is a decent starting point.
08:09:50 <laudecay> okie cool thanks
08:09:55 <laudecay> these blog posts r super
08:11:00 * hackage array-chunks 0.1.1.0 - Lists of chunks  https://hackage.haskell.org/package/array-chunks-0.1.1.0 (andrewthad)
08:12:53 <dminuoso> What's the simplest http library around for making just a single http request type? HTTP?
08:13:36 <srid> `req`?
08:14:30 <dminuoso> srid: Mmm, that's still got quite a bit of dependency overhead
08:15:00 <dminuoso> (I dont care about ergonomics really, just want something that ideally doesn't introduce any dependencies I already have)
08:15:06 <dminuoso> *I dont have
08:15:25 <jumper149> > minBound :: Double
08:15:29 <lambdabot>  error:
08:15:29 <lambdabot>      • No instance for (Bounded Double) arising from a use of ‘minBound’
08:15:29 <lambdabot>      • In the expression: minBound :: Double
08:15:33 <jumper149> Why is that?
08:15:50 <merijn> > (-1/0) :: Double
08:15:52 <lambdabot>  -Infinity
08:16:05 <merijn> Infinity is kinda the opposite of a bound :p
08:16:09 <jumper149> alrighty then :p
08:16:14 <c_wraith> well, it's not even a lower bound
08:16:31 <c_wraith> > (0/0 :: Double) < (-1/0)
08:16:33 <lambdabot>  False
08:16:41 <c_wraith> > (0/0 :: Double) > (-1/0)
08:16:43 <lambdabot>  False
08:16:43 <srid> > (1/0) :: Double 
08:16:45 <Ariakenom> heh
08:16:45 <lambdabot>  Infinity
08:16:57 <merijn> c_wraith: Value nan is an abomination that's got to go anyway
08:17:03 <merijn> c_wraith: It wrecks everything
08:17:10 <c_wraith> NaN is the real problem with declaring Double to be bounded
08:17:12 <merijn> Double isn't even Ord or Eq with it around
08:17:23 <merijn> c_wraith: NaN isn't the problem, value NaN is
08:18:16 <c_wraith> -Infinity would be a fine lower bound.  You'd just consider Double to be an approximation of a two-point compactification of the real numbers, and then -Infinity is fine.  but NaN breaks everything.
08:18:21 * ski . o O ( let's do `NaN' signalling )
08:18:44 <merijn> ski: carter is working on the ground work for that
08:18:51 <merijn> I'm the PR team :p
08:18:54 <ski> oh, cool ! :)
08:19:11 <Ariakenom> Here's parallel and concurrent programming in haskell. The concurrency part seems most relevant to your project. And is most interesting imo :) https://simonmar.github.io/pages/pcph.html
08:19:20 <Ariakenom> laudecay: ^
08:19:22 <merijn> ski: trapping NaN will probably have to be opt-in, especially fo FFI, but it would fix a lot :)
08:19:27 <ski> (is there any chance `Infinity' will be a bidi pattern synonym, soon ?)
08:19:42 <merijn> ski: "Be the change you wanna see in the world" and submit a PR? ;)
08:19:56 <Ariakenom> merijn: does the PR team accept new members? :p
08:20:02 <ski> perhaps :)
08:20:02 <merijn> Ariakenom: Sure :p
08:20:09 <dminuoso> srid: Ah fine, turns out `req` it is. Cheers for that! :)
08:21:08 <c_wraith> turns out, just about anyone can be an unpaid member of the PR team.  It's getting paid that's tricky.
08:22:31 <Ariakenom> Fighting the horrors of NaN is payment enough.
08:23:22 <laudecay> shiny thx Ariakenom 
08:23:27 <Ariakenom> although I will probably forget that someone was working on that again. because im quite sure ive heard it before
08:27:40 <Ariakenom> laudecay: oh right. asynchronous exceptions are a thing you may not know about. but pcph will cover that I think
08:27:56 <laudecay> Ariakenom: we use monitors in ocaml, same here?
08:28:03 <laudecay> is there a free version of this book
08:28:08 <merijn> Yes
08:28:34 <Ariakenom> laudecay: "Read the book online" link on that page
08:28:38 <laudecay> oh 
08:28:40 <laudecay> i cant read
08:29:37 <Ariakenom> o'reilly doesn't really want it to be found, methinks. they did break some old links
08:31:04 <Ariakenom> laudecay: from my brief glance at monitors there is no such thing in haskell
08:31:17 <laudecay> Ariakenom: like not the concurrency thing
08:31:19 <laudecay> async monitors?
08:31:22 <laudecay> ill look around
08:31:26 <dminuoso> % newtype F = forall f. Num f => T { unT :: f }
08:31:27 <yahb> dminuoso: ; <interactive>:45:13: error:; * A newtype constructor cannot have a context in its type; T :: forall f. Num f => f -> F; * In the definition of data constructor `T'; In the newtype declaration for `F'
08:31:48 <dminuoso> This no longer compiles since 8.6.4, is this intended and Im not seeing it?
08:32:03 <dminuoso> (I guess I need a GADT now?)
08:32:29 <laudecay> can someone give me a goofy tldr of what GADTs are
08:32:29 <dminuoso> Or maybe Im wrong, I might have screwed somethnig up.
08:32:52 <dminuoso> laudecay: So say you have `data Foo a = Foo a`
08:33:05 <laudecay> what's the meaning of the first foo versus second foo
08:33:14 <laudecay> sorry this is a thing i've been fuzzy on and using for a while
08:33:26 <dminuoso> laudecay: The first is a type constructor (type level construct!) and the second is a data constructor (data level construct!)
08:33:33 <laudecay> okie cool
08:33:34 <Ariakenom> laudecay: eh maybe monitors are a bit like Async. you will know that better than me after a few pages :D
08:33:39 <dminuoso> We confusingly like to reuse the same name because we mentally know they exist in differnet name spaces.
08:33:53 <laudecay> yeah ocaml's similar but has a thing with capitalization
08:33:56 <dminuoso> Sometimes in beginner settings its convention to prefix data constructors with Mk.
08:34:01 <laudecay> oh okay
08:34:06 <dminuoso> So you might see this as `data Foo a = MkFoo a`
08:34:13 <laudecay> yeah ive seen those
08:34:25 <laudecay> (btw does haskell have first class modules i <3 functors)
08:34:26 <dminuoso> laudecay: So there's an alternative way of writing it, that is a bit more explicit: data Foo where MkFoo :: a -> Foo a`
08:34:35 <dminuoso> laudecay: (nope)
08:34:35 <laudecay> yeah that makes sense
08:34:42 <laudecay> (tears and sadness, any plans?)
08:35:02 <dminuoso> laudecay: (Not that Im aware of)
08:35:21 <laudecay> (:/ ppx time) (but anyway back to gadts)
08:35:29 <dminuoso> laudecay: Sorry wait, I wrote this wrongly. It should read:  data Foo a where MkFoo :: a -> Foo a
08:35:42 <laudecay> oh yeah
08:35:46 <laudecay> so is that a module or 
08:35:56 <laudecay> like why's the "where" there, what's that doing with scopes
08:36:20 <dminuoso> laudecay: No, its just a different syntax, same meaning.
08:36:34 <dminuoso> laudecay: Its just a bit more explicit about "MkFoo being a value level thing, and showing you its tye"
08:36:39 <laudecay> ok cool sgtm
08:37:08 <dminuoso> laudecay: GADTs let you do something slightly more fancy: data Foo a where MkFoo :: Int -> Foo Int
08:37:24 <laudecay> so mkfoo is like a specialized constructor
08:38:01 * hackage array-builder 0.1.0.0 - Builders for arrays  https://hackage.haskell.org/package/array-builder-0.1.0.0 (andrewthad)
08:38:07 <dminuoso> laudecay: And if you had multiple constructors: `data Foo a where FooA :: Int -> Foo Int; FooB :: Char -> Foo Char` for example.
08:38:12 <laudecay> oh 
08:38:26 <laudecay> and that's not a thing you could do without GADTs? like those are just functions?
08:39:20 <dminuoso> laudecay: Well let's go one step further and see what you can do with this, and then to your question.
08:39:25 <laudecay> okie
08:42:32 <dminuoso> laudecay: Conceptually we could pretend, GADTs lets you write something like `data Foo Int = FooI Int; Foo Char = Single; Foo a = MkList [a]`
08:42:50 <laudecay> oh huh
08:44:10 <dminuoso> laudecay: So here comes the cool thing, you could write a function `f :: Foo a -> a` now, and this function can sort of return different types..
08:44:48 <laudecay> that's very polymorphism
08:44:50 <laudecay> i like
08:47:36 <dminuoso> laudecay: Because you could write `f (Foo i) = i * 2; f Single = 'c'; f (MkList xs) = head xs` (this was sadly splattered a bit with non-total functions because I didn't pick my example carefully)
08:47:50 <dminuoso> laudecay: And that's the magic feature of GADTs.
08:47:52 <laudecay> oh you just have to pattern match
08:47:54 <laudecay> i love it
08:47:56 <laudecay> wow!
08:48:05 <dminuoso> laudecay: Right! And when you pattern match the type of your GADT is refined!
08:48:28 <dminuoso> laudecay: Because once we know that it was constructed with `FooI`, then its type must be `Foo Int`
08:48:40 <dminuoso> (So returning an Int is perfectly legit)
08:48:56 <laudecay> and ghc checks that you're getting all the possible types that could be under the hood?
08:49:12 <laudecay> and those are defined by which constructors u have?
08:49:19 <dminuoso> laudecay: Right.
08:49:26 <dminuoso> 17:42:10        dminuoso | laudecay: Conceptually we could pretend, GADTs lets you write something like `data Foo Int = FooI Int; Foo Char = Single; Foo a = MkList [a]`
08:50:26 <laudecay> shinyshinyshiny i love it
08:50:34 <dminuoso> laudecay: So a specific GADT declaration would have been `data Foo a where FooI :: Int -> Foo Int; Single :: Foo Char; MkList :: [a] -> Foo a`
08:50:59 <laudecay> ok yeah that makes sense
08:51:35 <dminuoso> laudecay: https://en.wikibooks.org/wiki/Haskell/GADT this contains a real-world example of how GADTs can be useful.
08:51:48 <dminuoso> They are a special tool though, you can get by without ever touching them.
08:52:18 <laudecay> awesome thanks
08:52:32 <laudecay> i think this will be really actually useful for my key management stuff
08:54:31 * hackage javascript-bridge 0.2.0 - Remote Monad for JavaScript on the browser  https://hackage.haskell.org/package/javascript-bridge-0.2.0 (AndyGill)
09:04:25 <hololeap> is it possible to define a functor instance for this data type?
09:04:28 <hololeap> http://dpaste.com/2ZTKSXA
09:05:30 <hololeap> defining fmap for my Cofree seems to require (Functor (f n), Functor (f (n-1)), Functor (f (n-1-1))...)
09:08:39 <hololeap> i would like to tighten the constraint so that f must be a Functor for ALL values of n
09:12:30 <lyxia> (forall n. Functor (f n)) with QuantifiedConstraints?
09:24:43 <dmwit> Should f really take the Nat as an argument?
09:24:51 <dmwit> Seems like that gives it too much power.
09:26:00 * hackage hdiff 0.0.0 - Pattern-Expression-based differencing of arbitrary types.  https://hackage.haskell.org/package/hdiff-0.0.0 (vcmiraldo)
09:28:14 <dmwit> I would bet that for any f that actually uses its n argument you won't be able to satisfy a `forall n. Functor (f n)` constraint.
09:31:28 <hololeap> lyxia: thank you. i didn't know about that
09:33:42 <hololeap> dmwit: the idea was that f has a terminating constructor and that by tying the two Nats, i can ensure that a terminating constructor is used when n~0
09:34:14 <dmwit> "terminating constructor"?
09:34:50 <hololeap> for instance, Nothing
09:34:52 <dmwit> If the only thing you care about is 0/non-0, why not just have an `f` and a `g` parameter?
09:35:18 <hololeap> well, my motivating problem also needs to keep track of what level it's on
09:35:47 <dmwit> CofreeBottom :: a -> x -> Cofree 0 f x a; Cofree :: ... -> a -> f (Cofree (n-1) f x a) -> Cofree n f a
09:36:29 <dmwit> Well, anyway. Good luck. I hold to my prediction.
09:36:32 <hololeap> originally i had this: http://dpaste.com/2GK892M
09:37:04 <hololeap> and i thought, why not abstract the recursion out?
09:38:49 <hololeap> and use Control.Comonad.Representable.Store.StoreT
09:39:01 <dmwit> data Foo n u v a where Zero :: u a -> Foo 0 u v a; Succ :: v (Foo n u v a) -> Foo (n+1) u v a
09:39:58 <dmwit> Then MinLevel n is Foo n (\a -> (Start, Minimum, UVector a)) (\a -> (Start, Minimum, Vector a)) Gran
09:40:47 <dmwit> And you don't need a quantified constraint to get Functor, just `(Functor u, Functor v)`.
09:42:02 <dmwit> Heck, you can simplify even further. data Foo n f a where Zero :: a -> Foo 0 f a; Succ :: f (Foo n f a) -> Foo (n+1) f a
09:42:46 <dmwit> Then MinLevel n is Foo n (\a -> (Start, Minimum, Vector Gran a)) (Start, Minimum, UVector Gran)
09:43:10 <dmwit> And you can write instance Functor f => Functor (Foo n f)
09:44:29 <hololeap> dmwit: that seems like a good idea, although i'm having a bit of a hard time wrapping my head around it
09:47:29 <dmwit> Well. It's clear to *me*. =P
09:47:48 <dmwit> I'm happy to try to make it clear to you, too, but you have to tell me which bit is least clear so I have a launching point for my explanations.
09:48:06 <hololeap> i can see how starting at zero would simplify things for natural numbers
09:48:33 <dmwit> I was just copying what you did. Start wherever you want.
09:51:20 <hololeap> well, one thing is that your latest definition of Zero doesn't allow the 
09:51:43 <hololeap> "terminating" constructor of f to return any extra data
09:52:01 <hololeap> for instance, if the terminating constructor was Left instead of Nothing
09:52:43 <hololeap> eh, i guess that's not the best example
09:55:24 <hololeap> but, yeah, i'd like to somehow squeeze this into a Cofree as its f  : http://dpaste.com/2QGEYGT
09:55:37 <jgt> j
09:55:44 <jgt> sorry; finger slipped
09:56:37 <hololeap> even if it's not the same definition of Cofree from the free package
10:02:23 <exarkun> are there any handy patterns for dealing with Ptr without constantly accidentally dereferencing null points?  wrapping stuff with Either or something?
10:03:27 <lyxia> can you really end up with null pointers of type `Ptr a`?
10:04:06 <exarkun> yes
10:04:15 <lyxia> hm, there is a nullPtr
10:04:34 <hololeap> using QuantifiedConstraints actually worked, so i'll just proceed with that for now
10:12:39 * ski . o O ( "Marshalling of Maybe values" ("nullPtr is used to represent Nothing","using nullPtr to represent Nothing","returning Nothing if applied to a nullPtr") <https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.13.0.0/Foreign-Marshal-Utils.html#g:4> )
10:12:58 <c_wraith> exarkun: the best you can really do is get out of ffi-land and types like Ptr as fast as possible. 
10:13:15 <exarkun> darn.
10:13:41 <exarkun> this function's only job is to call 12 other functions in ffi-land
10:14:25 * ski idly wonders whether exarkun tried any of those combinators
10:14:44 * exarkun looks
10:15:05 <pikajude> is QuantifiedConstraints new?
10:15:16 <pikajude> oh yes it is
10:15:39 <exarkun> Hm, haven't tried those.  It looks kind of like what I was imagining w/ Either.  But I'm having trouble seeing how to tie together a lot of them.  Guess I should try with just one for starters..
10:18:11 <dsal> I solved all my STM problems by thinking harder.
10:19:16 <exarkun> I hear STM problems are all easily solved by giving up and starting over
10:19:16 <pikajude> what GHC option can I use in order to think harder?
10:19:18 <dsal> Just have to check state in more places to make sure all the things are still valid.  Now I should get useful errors most of the time.  I'm sure I'll occasionally get an indefinite STM thingy with the right race, but easy things give really useful errors now.
10:21:10 <exarkun> ski: hm on closer inspection those don't seem quite as useful.  The Maybe is on the input side but I think I mostly want it on the output side.  I don't have a lot of peeking.  Instead I have a lot of allocation/construction that may return a nullPtr I'd rather have as something safer..
10:24:17 <dsal> I don't exactly understand monad fail.  fail takes a string and then something about mzero...  How can I think about what happens here?
10:25:16 <ski> exarkun : output, for `maybePeek'
10:25:24 <ski> mhm
10:25:39 <c_wraith> dsal: was this the conduit-related stuff? 
10:25:50 <exarkun> yea but I only have 1 peek and 10x as many other things.  so maybePeek might help slightly but mostly the problem remains.
10:26:31 <exarkun> allocate a string, maybe that fails.  if not, decode it into another Ptr, maybe that fails.  if not, pass that in to another function, maybe that fails.  if not, pass that result into another function, maybe that fails, etc.
10:26:34 <dsal> c_wraith: Yeah, but it ends up not being a conduit related problem, really.  I had a thread that was reading and one that was writing.  There were a few STM things in the write path and I could write while disconnecting.  I cleaned that up and it seems to work well.
10:26:52 <exarkun> but I think I see how to extend the maybe* idea to these other apis, trying that now
10:27:09 <ski> instead of `marshall =<< construct', can you so `maybePeek marshall =<< construct' ?
10:27:50 <dmwit> hololeap: In my solution, you can put anything you want in the 0 branch.
10:27:53 <ski> where `construct :: IO (Ptr CFoo)' and `marshall :: Ptr CFoo -> IO Foo'
10:27:59 <dmwit> Including extra information of any kind you like.
10:28:23 <ski> exarkun : also sounds like `MaybeT IO' could be useful
10:28:47 <dsal> This is my monad fail question, though.  I stuck a     "checkConnected c >>"  in front of a few things.  That reads the current connection state and if it's broken, fails.  The connection might not be started yet, or it may have just been disconnected for an unknown reason.  Or the server gave me a good reason, which turns into a string like: "DisconnectRequest DiscoTopicAliasInvalid [PropReasonString "Topic alias invalid"
10:29:33 <dsal> fail feels like an exception, but not exactly.  I'm not sure how to think about this.
10:30:14 <exarkun> ski: it kinda does but I don't really understand monad transformers yet
10:31:16 <ski> exarkun : what about using `maybePeek' as i suggested, when constructing/allocating things, that may fail with `nullPtr' ?
10:33:27 <exarkun> ski: I'm having trouble seeing how to use maybePeek.  The pointers are all opaque and I'm just shoveling them between ffi calls.  I'm not sure I have a sensible peek function to use with maybePeek.
10:33:47 <exarkun> id, I guess
10:34:06 <exarkun> I wrote a `maybeNull` function that is maybe exactly the same as `maybePeek id`
10:34:31 * hackage astar-monad 0.3.0.0 -   https://hackage.haskell.org/package/astar-monad-0.3.0.0 (ChrisPenner)
10:34:38 <exarkun> except it's not in IO
10:36:30 * hackage dl-fedora 0.7 - Fedora image download tool  https://hackage.haskell.org/package/dl-fedora-0.7 (JensPetersen)
10:40:15 <ski> exarkun : the "peek" function could be one that marshalls into Haskell data structures, no ?
10:40:36 <exarkun> ski: I don't have that function in all cases
10:40:46 <ski> exarkun : yea, it could possibly be `return' or `return . MkFoo'
10:41:02 <exarkun> ski: A bunch of the pointers come from some ffi call and then go back into another ffi call without ever changing from `Ptr a`
10:41:08 <ski> (with `newtype Foo = MkFoo (Ptr CFoo)')
10:41:19 * ski nods
10:47:01 * hackage some 1.0.0.2 - Existential type: Some  https://hackage.haskell.org/package/some-1.0.0.2 (phadej)
10:54:54 <fizbin> Has anyone been using stack 2.1.3 with profiling? I’ve found recently that I need to add --profile to stack exec after I build with --profile or else it gets the versions from my most recent non-profiled build.
10:55:27 <fizbin> OTOH, this may mean that stack has finally addressed the "rebuild the universe each time you switch doing --profile or not" issue
10:59:11 <dmwit> fizbin: Although I don't use stack, that change was mentioned a few days ago in the channel here, so I believe it is not just you.
11:01:04 <fizbin> I'd feel better if I could find a statement in the stack changelog that worked out to this.
11:13:26 <exarkun> hrmph so why is the very first newCString call returning nullPtr :/
11:14:27 <exarkun> oops can't pattern match on nullPtr :/
11:15:19 <laudecay> are monad transformers to monads as functors are to modules in haskell
11:15:36 <laudecay> they're just functions that modify return and bind in the new monad?
11:34:32 <Guest66> Is there a way to go from `Refined p x` to `Refined p y` for x and y isomorphic?
11:36:39 <geekosaur> if they actually have the same representation then Data.Coerce.coerce might be of interest
11:37:06 <geekosaur> if they are merely isomorphic, probably not
11:37:17 <lyxia> I don't think so, because that's unsound if Predicate p x and Predicate p y don't agree.
11:38:06 <geekosaur> (are they isomorphic if they don't?)
11:38:19 <Guest66> Yeah, thats my question. heh
11:38:34 <Guest66> They should (?)
11:40:11 <lyxia> then you run into the trouble of expressing that constraint in Haskell
11:40:36 <lyxia> might as well cast it unsafely and call it a day
11:42:43 <Guest66> lyxia, geekosaur: thanks!
11:42:57 <Guest66> I'll try and come up with a solution.
11:43:27 <hyperisco> Guest66, the evens and odds are isomorphic, but a predicate such as "is even" is always true for one and always false for the other.
11:44:18 <Guest66> That makes sense.
11:46:28 <exarkun> what does http://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Marshal-Array.html#v:withArray do if allocation of the array fails
11:46:28 <pavonia> This might be a bit off-topic, but how would you implement parser combinators like parsec in languages that don't have first class functions? The Haskell implementations heavily rely on passing around and modifying several coninuations in form of functions. I'm wondering if/how that could be implemented with only simple, array-like data structures
11:47:05 <merijn> pavonia: Defuntionalisation
11:47:08 <jle`> hm, maybe with some sort of defunctionalization
11:47:12 <EvanR> you can emulate a closure with a data structure containing the closed over values and a pointer to function
11:47:14 <jle`> aw darn
11:47:14 <merijn> jle`: igh-five!
11:47:20 <jle`> ^5
11:47:47 <EvanR> "defunctionalization" seems to be a new buzz word these days
11:47:49 <jle`> it'd still be hell without types though
11:47:53 <merijn> exarkun: Without looking at docs/source I'd guess it throws an exception
11:47:54 <EvanR> i'm seeing in every language
11:48:05 <merijn> EvanR: It's a very old non-buzzword, though :)
11:48:16 <geekosaur> exarkun, probably the heap-exhausted exception
11:48:24 <madwizzard> Hi! is there a pattern for a list consisting out of two items (something like [x, a])
11:48:34 <merijn> EvanR: But it's usually restricted to compiler literature, so what you're really seeing is more people reading up on compilers \o/
11:48:42 <geekosaur> madwizzard, did you try it?
11:48:58 <madwizzard> geekosaur: no... good point.
11:49:01 <geekosaur> as it turns out, there's at least two ways to phrase that pattern
11:49:02 <jle`> > case [1,2] of [x,y] -> x + y
11:49:05 <lambdabot>  3
11:49:11 <geekosaur> [x, y] and (x:y:[])
11:49:32 * exarkun follows the source to http://hackage.haskell.org/package/base-4.12.0.0/docs/src/Foreign.Marshal.Alloc.html#allocaBytesAligned
11:49:37 <madwizzard> geekosaur: thanks, figured it out!
11:49:47 <pavonia> EvanR: Is that possible to do when you can't create functions on-the-fly, like with lambda expressions?
11:49:48 <jle`> hm, it might be fun to do a gadt-based defunctionalization of parser combinators
11:50:06 <jle`> madwizzard: welcome back :)
11:50:08 <jle`> aw
11:50:30 * hackage grafana 0.2 - API for creating grafana dashboards represented as json  https://hackage.haskell.org/package/grafana-0.2 (chessai)
11:50:47 <EvanR> pavonia: a lambda expression is a static thing which refers to dynamic things
11:51:06 <jle`> pavonia: you never 'need' lambdas to create functions
11:51:12 <jle`> you can just give them names
11:51:17 <geekosaur> you can do this stuf in C. you just toss function pointers around.
11:51:17 <EvanR> you put the dynamic things in the closure, the rest is a regular procedure (a pointer to which is paired with that closure)
11:51:54 <geekosaur> lambdas are more about binding/closures, which is admittedly harder but can be done with data structures.
11:52:06 <jle`> hm actually i think my regexp alternative blog post is actually a defunctionalization method for parsers
11:52:11 <jle`> *parser combinators
11:52:48 <jle`> ah yeah i'm literally doing defunctionalization on traditional parser combinators. i wonder if it's worth mentioning in the body of the post
11:53:04 <merijn> geekosaur: Just look at std::function in C++ :)
11:53:13 <pavonia> jle`: What's you blog?
11:53:17 <pavonia> *your
11:53:26 <jle`> the post is here https://blog.jle.im/entry/free-alternative-regexp.html
11:54:37 <jle`> one caveat is that this defunc scheme relies on infinite data structures/laziness, so it wouldn't work without implementing lazy data types. but this scheme could be modified slightly to avoid the use of infinite data types
11:54:42 <EvanR> pavonia: also partial-ing is equivalent to closuring
11:54:53 <EvanR> so that's taken care of at the same time
11:55:01 * hackage zxcvbn-hs 0.2.0.0 - Password strength estimation based on zxcvbn.  https://hackage.haskell.org/package/zxcvbn-hs-0.2.0.0 (PeterJones)
11:55:30 <pavonia> Okay thanks, I must read about defunctionalization first
11:56:06 <jle`> the post doesn't explicitly ever mention it
11:56:24 <jle`> but basically the idea is that you replace functions with a data type that can be interpreted as a function
11:57:04 <merijn> pavonia: This blog did a pretty ok quick intro: http://www.pathsensitive.com/2019/07/the-best-refactoring-youve-never-heard.html
11:57:19 <jle`> i remember a nice talk at ComposeConf this year too
11:57:29 <lyxia> that's the one
11:57:33 <jle`> oh wait, that's the one
11:58:00 <merijn> jle`: Man, you're slow today ;)
11:58:17 <jle`> i blame thursdays
11:59:16 <pavonia> merijn: Thanks
11:59:18 <merijn> Man, how do people get anything done in language that are not Haskell? >.>
12:00:10 <EvanR> how to do something in not haskell: first write yourself a haskell in it
12:00:11 <dmj`> stack overflow
12:00:16 <merijn> I couldn't refactor things this aggressively without Haskell
12:00:23 <parsnip> how do haskell coders write to disk on android?
12:00:25 <EvanR> how to do something in haskell: first write yourself a better language in it
12:00:33 <merijn> Speaking of which, is there's like "concatMapM" or something?
12:00:55 <merijn> parsnip: Same way as everyone else? >.>
12:00:56 <jle`> foldMapM ?
12:01:18 <merijn> jle`: That doesn't exist, afaik?
12:01:48 <parsnip> bit handwavy
12:01:51 <merijn> Hence my question :p
12:02:11 <merijn> parsnip: Well, I don't do android, so I wouldn't know >.>
12:02:12 <jle`> foldMapM f = foldMap (Ap . f)
12:02:16 <jle`> so...
12:02:20 <jle`> foldMapM = coerce foldMap
12:02:44 <merijn> Missing a sequence there, then :p
12:03:11 <merijn> But Ideallyuiiiiiiiiii7788888888888888888888888888888888                                           i
12:03:22 <merijn> priority cat interrupt...
12:03:36 <EvanR> oope merijn disconnected from the matrix
12:03:59 <merijn> shortest way across my desk is somehow *always* over my laptop keyboard >.>
12:04:28 <jle`> % :t \f -> getAp . foldMap (Ap @_ @[_] . f)
12:04:29 <yahb> jle`: (Foldable t, Applicative f) => (a -> f [w]) -> t a -> f [w]
12:04:45 <jle`> % :t \f -> getAp . foldMap @[] (Ap @_ @[_] . f)
12:04:45 <yahb> jle`: Applicative f => (a -> f [w]) -> [a] -> f [w]
12:04:50 <merijn> I think I'll just fmap concat over mapM >.>
12:05:15 <jle`> if only there was a clean way to write it using coerce without all the annotations
12:05:22 <jle`> maybe coercible-utils has some helpers
12:05:37 <jle`> it'd be cool if you could just write `coerce foldMap` and it'd do what you want
12:05:56 <jle`> s/cool/awful
12:06:00 * hackage zxcvbn-dvorak 0.1.0.0 - Password strength estimation based on zxcvbn.  https://hackage.haskell.org/package/zxcvbn-dvorak-0.1.0.0 (PeterJones)
12:11:44 <Ralf1> what book i shall read first?
12:11:52 <lavalike> :t (/6) . genericLength . filter id . zipWith (==) "zxcvbn" -- the above module
12:11:53 <lambdabot> Fractional c => [Char] -> c
12:13:00 * hackage simple-cmd-args 0.1.3 - Simple command args parsing and execution  https://hackage.haskell.org/package/simple-cmd-args-0.1.3 (JensPetersen)
12:37:46 <pikajude> can I get cabal to save my username/pw for hackage?
12:38:09 <merijn> pikajude: ~/.cabal/config has fields for that
12:38:13 <pikajude> neat
12:38:31 <merijn> pikajude: Even better, if you have a password manager with a CLI tool you can tell it to use that, rather than storing plain text password
12:38:50 <pikajude> yeah, such a thing is possible
12:38:56 <pikajude> this is WSL so it might have one that's built into the windows keychain
12:39:02 <pikajude> how do i make it use a password manager?
12:39:26 <merijn> pikajude: Instead of using the password config field set "password-command:" to a command that will write the password to stdout
12:39:31 <pikajude> ok
12:39:45 <merijn> I use it to have cabal query my from the macOS keychain :)
12:40:05 <merijn> Underrated/-advertised feature \o/
12:40:21 <pikajude> "Windows doesn't have any secure Keyring/Password storage that I know of that you can hook into to emulate some Linux/Mac interface."
12:40:23 <pikajude> oh dear
12:41:22 <pikajude> git-credential-manager does do this for windows, but i don't think there's any general-purpose solution :(
12:42:03 <EvanR> "I think it's safe to say we know the most about security at this point" --steve ballmer
12:42:19 <EvanR> i guess he's ancient now though
12:42:27 <SethFogarty> I am looking to write non-functional tests for code (for a class). For instance, "is the definition of Foo recursive?" or "is Bar called within this module." I've looked at Language.Haskell, but traversing the AST seems quite painful for those kinds of questions. Are there any tools build on top of the parser for those kinds of questions, or other
12:42:28 <SethFogarty> frameworks for non-functional tests?
12:42:43 <merijn> EvanR: To be fair, windows' mitigation tech is far ahead of linux, more on par with OpenBSD than anything
12:43:01 <mdunnio> I'm having some issues with exception handling using async. For example, if there is an exception in the child thread, I can't seem to catch it in the child thread process, only the thread that spawned the async can catch the exception. Does that make sense?
12:43:23 <merijn> mdunnio: That doesn't sound right
12:43:39 <merijn> mdunnio: Oh, 10 dollar says I know!
12:43:47 <merijn> mdunnio: Are you using "throw" or "error"?
12:43:57 <mdunnio> merijn: Thanks for the sanity check.
12:44:30 <merijn> mdunnio: Because if so the answer is: Those two make it near impossible to reliably catch exceptions
12:44:30 * hackage th-printf 0.7 - Quasiquoters for printf  https://hackage.haskell.org/package/th-printf-0.7 (JudeTaylor)
12:44:44 <mdunnio> I think I've eradicated all "throw", and I'm just using "throwIO"
12:45:03 <merijn> mdunnio: Do you have a minimal reproducing example?
12:45:29 <mdunnio> unfortunately, no. I should put one together.
12:47:41 <mdunnio> What's interesting is that I'm able to trigger the exception handling with "bracketOnError"
12:47:59 <mdunnio> but I need to know the type of exception, and "bracketOnError" doesn't give me that
12:48:34 <merijn> mdunnio: bracketOnError doesn't catch, though? How are you (trying to) catch it?
12:50:02 <merijn> There's a relatively easy trick to figure the exceptions type, if you solemnly swear you will never leave this in "production" code :p
12:50:19 <mdunnio> I'm mostly using the following form (I'm really just trying to catch anything at this poitn) "functionThatThrowsException `catch` (\(e :: SomeException) -> ...)"
12:51:20 <merijn> mdunnio: If that isn't catching things, then the problem isn't in functionThatThrowsException.
12:51:52 <merijn> mdunnio: Anyway, all exceptions must be instance of Typeable, so if you *can* catch if via SomeException than you can unwrap it and use:
12:51:59 <merijn> > show $ typeOf 'c'
12:52:01 <lambdabot>  "Char"
12:52:05 <merijn> > show $ typeOf True
12:52:07 <lambdabot>  "Bool"
12:52:53 <mdunnio> Yeah, good to know.
12:52:53 <geekosaur> mdunnio, note that if you don't force the value of functionThatThrowsException *within* the catch, it can remain unevaluated until some other part of yor program does so. that may well be the main thread
12:53:06 <geekosaur> this is a common source of issues with exceptions
12:53:09 <merijn> geekosaur: He already said he replaced all his throws with throwIO
12:53:26 <merijn> Of course some library function might be using throw still, I suppose
12:53:38 <geekosaur> throwIO doesn't help there if it isn't evaluated because of some earlier laziness?
12:53:51 <merijn> geekosaur: throwIO isn't affected by laziness
12:54:10 <merijn> geekosaur: The entire point of throwIO is that it's in IO so it can force the throw
12:54:43 <mdunnio> merijn: That's my understanding.
12:55:20 <merijn> Otherwise exceptions would be completely unusable
12:59:00 <exarkun> When I `stack repl` I'm not able to load the library I am ffi'ing against.  Is there a way to make stack run ghci with the right flags or do I just have to do it myself?
13:03:37 <mdunnio> merijn: https://pastebin.com/LurtfsSE
13:04:17 <mdunnio> So my code looks similar to that paste. And when I run it, is that the exception printing in the "waitEitherCatchCancel" prints, but not "Caught EXCEPTION"
13:06:15 <mdunnio> My initial guess was that "waitEitherCatchCancel" was cancelling "a1" before the IO could finish, but I don't think that is the case.
13:06:17 <merijn> mdunnio: And you're sure the exception is from 'f' and not 'h'?
13:06:42 <merijn> mdunnio: If 'h' or 'l' throw it seems like you'd get exactly the behaviour you describe?
13:08:03 <mdunnio> merijn: I don't see how that is possible, but I should consider that possibility if I cannot explain it any other way.
13:08:18 <merijn> Trust no one! ;)
13:11:02 <mdunnio> merijn: https://pastebin.com/FVdvRuBX
13:11:30 <mdunnio> that is "bracketOnError" case for reference...and in that case "On Error" prints.
13:12:09 <dogui> I'm trying to define this instance just for fun ` instance (Enum a, Enum b, Bounded b) => Enum (a, b) where
13:12:33 <dogui> `, but I'm running into an issue since I think I can't mention the type variable `b` in the body, is that a known limitation? See https://pastebin.com/2hTX2JYC
13:12:46 <merijn> mdunnio: hmm, too late and too tired to understand what's going wrong
13:12:55 <ryan2215> LIST #java* -min 2
13:13:03 <mdunnio> merijn: I feel the same way. Haha. I appreciate the help.
13:13:43 <merijn> dogui: Sounds like you want ScopedTypeVariables, alternatively you could use asTypeOf
13:13:46 <merijn> :t asTypeOf
13:13:47 <lambdabot> a -> a -> a
13:13:52 <trcc> Anyone familiar with a stack command that shows where the latest build binary is stored?
13:13:57 <merijn> > minBound `asTypeOf` 'c'
13:13:58 <exarkun> I have an input, `Either a b`, a processor `b -> IO c`, and a kind of filter, `c -> d`.  How do I succinctly compose them (getting presumably `IO (Either a d)`)?
13:13:59 <lambdabot>  '\NUL'
13:14:24 <merijn> dogui: So you could do "maxBound `asTypeOf` y" in your example
13:14:34 <exarkun> trcc: Why "latest"?  My experience of stack is that it doesn't keep more than one.
13:14:41 <trcc> exarkun: just the one then
13:14:59 <trcc> just need a path to it
13:15:03 <exarkun> trcc: Does `stack path --local-bin-path` get you there?
13:15:26 <dogui> merijn: ah, thanks! ScopedTypeVariables did it. And thanks for the pointer to asTypeOf, but I think it doesn't help in `toEnum`. I had a similar trick in `fromEnum` by doing `head [maxBound, y]` :)
13:15:39 <exarkun> trcc: oops that's the wrong flag.  but there's other flags, maybe one of them does the right thing.
13:15:47 <dogui> in `toEnum` there's no `y : b`, I should probably call them `(m, n)`
13:15:54 <trcc> exarkun: nope, that is not the bin of the project that I build
13:16:08 <merijn> dogui: Oh, you're right, I'm blind :)
13:16:44 <merijn> dogui: anyway "asTypeOf" would be a good replacement for "head [maxBound, y]" as that sets of many alarm bells ;)
13:17:01 <dogui> merijn: ha, yeah, agreed :)
13:17:21 <merijn> And it's the entire reason it was invented ;)
13:19:35 <trcc> exarkun: close to distdir when executing stack path
13:21:29 <trcc> seems like there is no clever way to retrieve the bin
13:23:09 <mdunnio> merijn: if you're still interested, I added a "catch" outside of "bracketOnError", and now it's catching a re-thrown "SomeException"
13:23:14 <mdunnio> like...what?
13:24:16 <mdunnio> hmm, actually this has given me some insight.
13:29:36 <mdunnio> merijn: in my example, it turns out "g" was throwing the exception.
13:29:50 <merijn> mdunnio: :)
13:30:27 <mdunnio> merijn: in this particular case, "f" and "g" are io-streams interacting with each other...so this is fairly complex
13:31:09 <merijn> mdunnio: Incidentally, don't you want to use withAsync? As it is your example can leak threads on async exceptions
13:32:02 <mdunnio> merijn: shouldn't "waitEitherCatchCancel" handle that?
13:32:18 <mdunnio> as in, if there is an exception raised, that function will kill both asyncs
13:32:31 <merijn> mdunnio: if you get an exception *after* async runs, but before waitEither you won't free them
13:32:57 <merijn> mdunnio: Async exceptions are ones that are thrown *to* your thread from others, so they can happen "at any time"
13:33:24 <dsal> stack --resolver=lts-13.11 fails for me because I don't have ghc-8.6.4.  Allegedly, it's supposed to require 8.6.3.  I'm not sure whose bug that is.
13:33:35 <dsal> I blame ghc for not giving me all the compilers all the time.  :)
13:34:04 <trcc> getting there. Just need a command to extract the project name using stack...
13:34:45 <mdunnio> merijn: Hm, I see. You may be right
13:34:51 <mdunnio> merijn: I'd have to think about it more
13:35:09 <merijn> mdunnio: withAsync (and other bracket constructions) will prevent this
13:39:17 <exarkun> Why is EitherT deprecated
13:39:29 <merijn> Which one?
13:40:22 <geekosaur> dsal, are you sure you don't have something that requires 8.6.4 and therefore can't be satisfied with that LTS?
13:40:25 <exarkun> https://hackage.haskell.org/package/EitherT
13:40:38 <exarkun> Which one isn't deprecated?
13:40:52 <dsal> 13.10 works fine with 8.6.3.  13.11 seems want 8.6.4 for me.  I just tried on another platform and observed what was building.
13:40:57 <merijn> exarkun: You want either ExceptT from transformers, or the "either" package
13:41:01 <EvanR> exarkun: ExceptT  er ^
13:42:43 <exarkun> Hrm ok I see.
13:43:20 <koz_> 'import Data.Data (Data)' <-- yo dawg?
13:45:57 <dsal> I filed https://github.com/commercialhaskell/stackage/issues/4826 -- *shrug*
13:52:00 <EvanR> i wonder what a haskell commercial would look like
13:52:36 <[exa]> EvanR: did you hear the haskell joke?
13:52:40 <EvanR> steve ballmer sells windows 1.0 with ballmer replaced with SPJ
13:53:09 <wroathe> Philip Wadler, Simon Peyton Jones, and Simon Marlow dressed up like the Beastie Boys, probably
13:53:17 <EvanR> hhahahaa
13:53:41 <dsal> Listen all of y'all it's a semigroup
13:56:20 <koz_> dsal: No neutral element?
13:56:54 <dsal> Scansion issue.
13:57:01 <koz_> dsal: Scansion?
13:57:47 <dsal> Sabotage -> Semigroup vs. Monoid.  Doens't fit the song used in the Haskell commercial.
13:58:02 <koz_> Ah.
14:00:44 <sshine> for a package, I just removed the line 'import Data.Monoid' because it's redundant in current Prelude, but then some Travis CI builds for older GHC versions break because of that. and I wonder: how long back do package maintainers generally prefer to keep their code working, and am I in #if land if the code should cover before/after (<>) was available without imports without producing warnings?
14:01:44 <merijn> sshine: The library committee/GHC maintain a "3 version, CPP free" support window
14:01:54 <koz_> sshine: The answers are 'depends on the project' and 'yes'.
14:02:09 <koz_> vector-sized and finitary (both of which I am involved with) ended up having to CPP up stuff like this.
14:02:12 <merijn> sshine: So you should be able to support *at least* the last 3 GHCs cleanly
14:02:31 <koz_> (the Data.Monoid thing is an issue specifically afflicting vector-sized)
14:02:40 <koz_> (I was possibly even the person who raised it)
14:02:42 <tdammers> the "3 releases policy" is really more about bootstrapping the compiler itself though
14:03:02 <merijn> tdammers: No, also for stuff like MonadFail, etc.
14:04:12 <sshine> and "3 releases" = 8.8.1, 8.6.5, 8.6.4? or is it 8.8.1, 8.6.5 and 8.4.x for some x?
14:04:28 <merijn> sshine: 8.8, 8.6, 8.4
14:04:56 <koz_> merijn: It means I'm currently failing due to missing 8.8 support in my dependencies. :(
14:05:28 <merijn> koz_: 8.8 is barely out yet, though
14:05:41 <koz_> merijn: This is true.
14:05:55 <koz_> I guess the bigger libraries will take a while - Hedgehog is probably my biggest blocker.
14:06:47 <sshine> koz_, oh, your lib can't support 8.8 because your deps can't, and they in turn can't... is that correct?
14:11:40 <sshine> merijn, btw, what did you mean by "3 version, CPP free"; that you're free from CPP after 3 versions?
14:11:57 <merijn> sshine: No, that you should not need CPP to support the last 3 versions
14:12:16 <merijn> i.e. there should be some way to do imports/define instances/etc. that CPP isn't needed
14:13:12 <merijn> sshine: https://prime.haskell.org/wiki/Libraries/Proposals/SemigroupMonoid#Writingcompatiblecode
14:15:35 <sshine> merijn, thanks!!!
14:16:38 <dmwit> And when they find a situation where they can only support the last two versions, they quick make another release without changing anything.
14:20:31 <sshine> merijn, oh, haha, I was actually on that exact page, but hadn't scrolled down to that section yet. :-P
15:12:33 <sshine> hrm. I thought I'd try and add GHC 8.8.1 as a target in Travis, but it seems that Cabal 2.4 can't target GHC 8.8: Warning: Unknown/unsupported 'ghc' version detected (Cabal 2.4.1.0 supports 'ghc' version < 8.7)
15:25:08 <kiwi_31> hello
15:28:07 <Guillaum> I don't understand at all why this type check: https://gist.github.com/guibou/a094245b9d465eba67dd7785f0dec76a I'm having a type familly with an unresolved case (e.g. Bar Float Float does not exists) and yet it typecheck.
15:33:16 <dmwit> Welcome to the ugly world of type families.
15:34:01 <dmwit> It is true that `Bar Float Float` does not reduce.
15:34:06 <dmwit> But the typechecker doesn't care.
15:34:20 <dmwit> It must deal with type families that do not reduce all the time.
15:35:00 <dmwit> (Usually, this is because they do not reduce *yet* -- because they mention a variable that, when instantiated, will let them reduce. But there's not a huge technical difference between "doesn't reduce yet" and "doesn't reduce ever".)
15:37:22 <dmwit> (For example, the `Bar k k'` in the type signature of `frob` doesn't reduce; should that mean that even the definition of `frob` should not typecheck?)
15:39:58 <SegFaultAX> Is there a general pattern for doing non-greedy backtracking in parsec? I want to match a grammar like `a*a` for all parsers a. Example: `liftA2 (,) (many a) a` on "aaa" should return ("aa", "a"), but instead fails because many consumes the entire input.
15:40:00 <Guillaum> dmwit: for `frob` I assume that as long as there is variable, the typechecker cannot conclude anything. But for `v`, there is no more variable. Well, I guess that's like that. Is there any solution / trick I should know if I want to use a type familly to accept certain configuration of phantom type and refuse some others?
15:41:51 <Guillaum> dmwit: well, actually I have my solution, I can use TypeError in the last case of my type family. I just need to think about it each time, that's surprising.
15:42:44 <Guillaum> dmwit: thank you for your answer.
15:54:38 <sshine> hmm, I'm running hlint on some code that says I might rewrite '(\v -> pure $ Node x v)' as '(pure . Node x)'. well, good. but it was right next to '(\v -> pure $ Node v t)', and I think 'pure . (`Node` x)' looks a little messy.
15:58:35 * justsomeguy finds that hlint suggest a lot of rephrasing that would make his code unreadable, at least to newcomers like him
16:00:21 <MarcelineVQ> hlint is just suggestions, if it doesn't make code more redable don't do it :>
16:05:31 * hackage builder 0.1 - bounded ByteArray builder type  https://hackage.haskell.org/package/builder-0.1 (chessai)
16:28:47 <dsal> hlint suggested the "do" was redundant here, so I removed it.  With the do removed, the code doesn't work correctly.  This surprises me. https://www.irccloud.com/pastebin/5Gov0QLZ/parseProperty.hs
16:29:47 <dsal> Oh.  It does if I parenthesize the first line.
16:30:08 <dsal> Operators.  How do they work?
16:30:29 <iqubic> with fixity
16:31:43 <dsal> More like breakity
16:31:45 * dsal high fives
16:41:56 <dmwit> SegFaultAX: Why not `some a`?
16:48:45 <duncan> dsal: “Why can’t there just be one operator that is really reliable?”
16:53:01 * hackage vega-view 0.3.0.5 - Easily view Vega or Vega-Lite visualizations.  https://hackage.haskell.org/package/vega-view-0.3.0.5 (DouglasBurke)
16:53:04 <jackdk> there is. It's space, for function application :)
16:59:07 <EvanR> jackdk: and even that one sometimes fails :(
17:00:48 <dsal> I had a function that didn't work well once.  It was probably the space.
17:04:26 <EvanR> that is why operators are less reliable, each use requires 2 spaces
17:04:39 <EvanR> more moving parts
17:06:07 <int-e> > 1+2*3--spaces?!
17:06:09 <lambdabot>  7
17:06:29 <EvanR> you have to zoom in to see them
17:06:45 <hpc> > "this has a... "           ++     "space leak"
17:06:47 <lambdabot>  "this has a... space leak"
17:07:27 <EvanR> but i am wrong about needing 2... + is sharing one of the spaces with * there
17:07:43 <int-e> > unwords["If","you","need","spaces","there's","always","this."]
17:07:44 <lambdabot>  "If you need spaces there's always this."
17:07:58 <EvanR> > let f x = x + 1 in f5
17:08:00 <lambdabot>  error:
17:08:00 <lambdabot>      • Variable not in scope: f5
17:08:00 <lambdabot>      • Perhaps you meant one of these:
17:08:14 <int-e> EvanR: that's what $ is for, obviously.
17:08:14 <MarcelineVQ> > unwords . words $ "this        has        a...        space     leak"
17:08:16 <lambdabot>  "this has a... space leak"
17:08:32 <EvanR> > let 5 x = x + 1; y = 3 in 5y
17:08:34 <lambdabot>  <hint>:1:5: error: Parse error in pattern: 5
17:08:53 <EvanR> > let 5 = \x -> x + 1; y = 3 in 5y
17:08:55 <lambdabot>  error:
17:08:55 <lambdabot>      • Could not deduce (Eq (Integer -> Integer))
17:08:55 <lambdabot>          arising from the literal ‘5’
17:09:01 <hpc> fun fact: on the apollo missions, both the hardware and software teams were worried about space leaks
17:09:19 <int-e> EvanR: the expression 5 is for "fromInteger 5" where the second 5 is an integer literal
17:09:28 <int-e> EvanR: so this can't work without a custom Num instance
17:09:58 <EvanR> not sure if this counts as "application with no space" or not ($ not allowed)
17:10:10 <int-e> EvanR: I think it would count
17:10:21 <int-e> EvanR: you can do the more boring  f(x)  as well
17:10:48 <int-e> or (f)x if you want to have it look less like an ordinary programming language
17:11:12 <int-e> @quote style
17:11:12 <lambdabot> MatthiasFelleisen says: we have come to the conclusion that programs in less expressive languages exhibit repeated occurrences of programming patterns, and that this pattern-oriented style is
17:11:12 <lambdabot> detrimental to the programming process [1991, On the Expressive Power of Programming Languages]
17:13:14 <EvanR> (f)x seems useful is making the audience hate haskell even more than they already do for other reasons
17:13:45 <EvanR> (reason being the only thing they know about haskell is it uses <$> and <*> operators)
17:14:08 <hpc> how about a nice middle ground - f(x)y
17:14:28 <monochrom> hpc: Wait, is that "space leak" a pun?
17:14:39 <hpc> yep
17:14:42 <monochrom> haha
17:15:00 <iqubic> Doesn't that evaluate x first, then f x y?
17:15:58 <EvanR> iqubic r u serious
17:16:09 <iqubic> No.
17:16:13 <EvanR> ok good
17:16:19 <iqubic> Also, I just found the space leak joke.
17:16:21 <iqubic> I love it.
17:16:26 <EvanR> (grouping is not related to evaluation order in haskell)
17:17:09 <monochrom> Grouping (parsing) is supposed to be independent of evaluation order, always.
17:17:26 <iqubic> EvanR: On the contrary. 'f x y z' vs 'f (x y) z'
17:17:47 <EvanR> wrong... f x y z  is sugar
17:17:52 <EvanR> for a different grouping
17:17:52 <iqubic> For what?
17:18:04 <EvanR> ((f x) y) z
17:18:12 <iqubic> Right.
17:18:14 <monochrom> For example even in C, "p != NULL && (p->x == 0)" does not mean that you evaluate "p->x == 0" first.
17:18:21 <iqubic> No.
17:19:02 <EvanR> yeah, well it does affect order in C in general, in complicated ways
17:19:21 <monochrom> The only reason you thought parsing implies evaluation order is that highschool told you so, and highschool operators were all strict, so may as well merge the two notions.
17:19:34 <iqubic> let p = False && (x == undefined::Bool) You don't get an error there.
17:19:36 <EvanR> <-- 4th grade
17:19:54 <iqubic> > False && (x == (undefined::Bool))
17:19:56 <lambdabot>  error:
17:19:56 <lambdabot>      • Couldn't match expected type ‘Expr’ with actual type ‘Bool’
17:19:56 <lambdabot>      • In the second argument of ‘(==)’, namely ‘(undefined :: Bool)’
17:20:00 <shachaf> Uh oh.
17:20:02 <iqubic> What?!?!
17:20:06 <shachaf> Sounds like you do get an error there.
17:20:17 <shachaf> Everything you knew has been turned on its face.
17:20:23 <Axman6> :t x
17:20:25 <lambdabot> Expr
17:20:32 <EvanR> you don't get an error, iqubic does
17:20:39 <shachaf> There is no more meaning in the world, only chaos.
17:20:52 <iqubic> > False && (True == undefined::Bool)
17:20:54 <lambdabot>  False
17:21:05 <iqubic> See, you don't evaluate the second bit first.
17:21:22 <iqubic> monochrom: You c example also works in Haskell
17:21:29 <iqubic> Laziness is great
17:21:38 * dmwit squints
17:23:06 <iqubic> dmwit: I'm just proving that Monochrom's statement of "in C, 'p != NULL && (p->x == 0)' does not mean that you evaluate 'p->x == 0' first." can be translated into haskell via the example "False && (True == undefined::Bool)"
17:23:33 <monochrom> And even despite how highschool tells you about parsing = evaluation order, you don't actually believe it.
17:23:41 <monochrom> @quote monochrom 0\*
17:23:41 <lambdabot> monochrom says: some kind of lazy evaluation is already known to highschool kids. teachers tell you that in a*(b+c), "evaluate b+c first", right? well, I challenge you to take 0*(389238493+97283748)
17:23:41 <lambdabot> and find one single student who faithfully evaluate 389238493+97283748 first.
17:24:52 <EvanR> good one
17:25:40 <EvanR> "parentheses first" was the first rule in that rule set... now it makes absolutely no sense in retrospect
17:30:14 <literall1Crevice> Is there a way using parsec to "map" inputs to parse results? What I mean is, currently I parse `oneOf "ab"` and then return either an Alpha or a Beta using a case of on that. Is there a simpler way?
17:31:41 <literall1Crevice> (example here http://ix.io/1UXh)
17:32:03 <EvanR> Alpha <$> char 'a' <|> Beta <$> char 'b' 
17:32:29 <EvanR> er
17:33:31 <EvanR> Alpha <$ char 'a' <|> Beta <$ char 'b' 
17:34:05 <literall1Crevice> EvanR: Thanks!
17:38:45 <literall1Crevice> Oh, another thing. Say I have a function (parseFromLibrary :: Text -> Maybe Thing) and I want to make it into a Parser Thing, is there an easy way to do so?
17:40:27 <jle`> literall1Crevice: it's sort of tricky because it isn't clear from that type alone 'how much' Text it is supposed to consume
17:40:35 <jle`> unless it's lazy maybe
17:40:59 <jle`> literall1Crevice: however if you know how much it should expect to consume, then it might make sense
17:40:59 <dmwit> literall1Crevice: Definitely not in a black-box way.
17:41:14 <literall1Crevice> jle`: I do know the exact character count
17:41:17 <jle`> alternatively you can try it "every" possible string of text remaining, but that wouldn't be too great
17:41:41 <jle`> literall1Crevice: ah if you do, then you can get that many cahracters, then you can use parseFromLibrary and match on teh 'maybe'
17:41:50 <jle`> Nothing -> fail/empty/mzero/etc., Just x -> pure x
17:45:18 <literall1Crevice> jle`: I'm confused on how to do the "get that many characters" part
17:48:13 <EvanR> there is a Int -> Parser Text which returns whatever comes next and consumes it, up to that many characters
17:48:39 <EvanR> then you run your function on the result text
17:52:53 <jle`> literall1Crevice: it depends on the library you want, but you can a combinator it provides to get Parser Text
17:53:04 <jle`> literall1Crevice: it should be a part of the parser combinator library you are using
17:53:12 <jle`> or at least, if you can get a Parser Char, you can replicateM n it
17:53:24 <jle`> replicateM :: Int -> Parser a -> Parser [a]
17:55:01 <dmwit> ?src replicateM
17:55:01 <lambdabot> replicateM n x = sequence (replicate n x)
17:55:06 <EvanR> yeesh
17:55:31 <dmwit> Oh. It's called replicateM, but it actually has the replicateA type. ^_^
17:55:44 <EvanR> when the underlying stream is Text, you almost certainly have an API call to get an n-character Text
17:55:48 <dmwit> Why couldn't we have just done that with liftM*?
17:57:02 <jle`> you need some combinator to at least get the text
17:57:06 <jle`> or char
17:57:07 <shachaf> Hmm. Because people wanted to define instance Functor F where fmap = liftM?
17:57:42 <EvanR> (hopefully you don't drop to the level of Char yet)
18:03:00 <literall1Crevice> I got it working, thanks everyone
18:08:01 * hackage lazy-priority-queue 0.1 - Lazy-Spined Monadic Priority Queues  https://hackage.haskell.org/package/lazy-priority-queue-0.1 (MarioBlazevic)
19:14:31 <literall1Crevice> Parsec question: since (<?>) only changes the label when the parser hasn't parsed anything, I changed (parser <?> "a thing") with (try parser <?> "a thing") to get it to work as I want it. Are there any potential errors I'm missing here?
19:22:31 * hackage binsm 0.1.1 - binary files splitter and merger  https://hackage.haskell.org/package/binsm-0.1.1 (SergeyAlirzaev)
19:35:00 * hackage posplyu 0.1.0 - Sleep tracker for X11, using XScreenSaver extension and manual input.  https://hackage.haskell.org/package/posplyu-0.1.0 (SergeyAlirzaev)
19:56:06 <erisco> conal <3 your latest talk
19:56:19 <conal> erisco: :) thanks!
19:58:05 <dmwit> shachaf: IDGI
19:58:30 * hackage vega-view 0.3.1.0 - Easily view Vega or Vega-Lite visualizations.  https://hackage.haskell.org/package/vega-view-0.3.1.0 (DouglasBurke)
20:29:54 <shachaf> dmwit: Which part?
20:30:08 <shachaf> dmwit: I mean that presumably liftM is the fmapDefault of Monad.
20:30:49 <iqubic> :t fmapDefault
20:30:50 <lambdabot> Traversable t => (a -> b) -> t a -> t b
21:16:05 <iqubic> ?src fmapDefault
21:16:05 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
21:16:55 <pikajude> that seems unnecessarily confrontational, lambdabot
21:17:36 <dmwit> shachaf: Why does that mean we can't make it have an Applicative constraint instead of a Monad one?
21:19:25 <shachaf> dmwit: I think the argument I remember is that you could write "instance Monad M where ...; instance Applicative M where { pure = return; (<*>) = ap }; instance Functor M where { fmap = liftM }"
21:19:51 <shachaf> I don't have much of an opinion about this.
21:20:12 <dmwit> But why does that mean we can't make liftM have an Applicative constraint instead of a Monad one??
21:21:16 <shachaf> Because it's defined in terms of (>>=)?
21:21:25 <dmwit> liftM f x = pure f <*> x
21:21:31 <shachaf> Oh. Well then.
21:22:37 <EvanR> that's a bit surprising
21:22:49 <dmwit> It should surprise you. It's not true.
21:23:06 <EvanR> :t liftA
21:23:08 <lambdabot> Applicative f => (a -> b) -> f a -> f b
21:23:16 <EvanR> let's call the whole thing off
21:23:26 <EvanR> liftOff
21:24:07 <shachaf> What should surprise me?
21:24:48 <dmwit> that
21:24:56 <dmwit> hth
21:25:34 <dmwit> (Personally, I am operating under the assumption that "that" in this case means "it's surprising that liftM is defined in terms of Applicative methods, but given a type that mentions Monad instead".)
21:26:16 <shachaf> I can no longer tell truth from fantasy.
21:27:00 <MarcelineVQ> heck, why stop at applicative? liftM = fmap
21:27:06 <dmwit> Perhaps your point of confusion is this: "It should surprise you" is a response to EvanR, not a response to shachaf.
21:27:15 <shachaf> Aha.
21:27:33 <dmwit> MarcelineVQ: Sure. But I want liftM2 :: Applicative m => ... and etc.
21:28:05 <dmwit> Well. "want" is too strong. I am musing about...
21:29:37 <nshepperd> the problem with liftM = fmap is it'll make all of the 'instance Functor M where fmap = liftM' definitions circular. not sure if liftM = liftA has a similar problem
21:30:12 <shachaf> ap = (<*>) has the same problem for Applicative.
21:30:53 <sshine> at least 'ap' sounds like Applicative.
21:32:16 <sshine> dmwit, does it ever make sense to liftM2 when you can liftA2?
21:33:17 * sshine finally made his first Haskell package PR work for 7.10.2--8.6.5!
21:34:31 <jle`> shachaf: congrats :D
21:34:37 <jle`> * sshine 
21:34:42 <shachaf> Aw.
21:34:52 <jle`> but not withholding any congratulations due to shachaf as well
21:35:33 <shachaf> I was kind of excited about the entirely undue congratulations.
21:36:04 <jle`> i can congratulate you on experiencing excitement
21:36:26 <sshine> jle`, thanks! :) now I only have to make it work for 8.8.1, which requires bumping another package upstream.
21:36:35 <MarcelineVQ> shachaf: https://www.youtube.com/watch?v=wDajqW561KM
21:37:05 <sshine> most of the work is figuring out how Docker works and modernizing the packages' .travis.yml so I can understand them.
21:39:18 <sshine> https://travis-ci.org/sshine/aeson-diff-generic -- I don't know if this coverage is even necessary. but now I've at least got the experience.
21:46:27 <_deepfire> Is there a way to employ GHC's instance resolution machinery using just a SomeTypeRep?
21:46:58 <Axman6> possibly using the constraints library?
21:48:08 <_deepfire> I.e. sth like:  forall (c :: Type -> Constraint). c a => SomeTypeRep -> Maybe (Proxy a)
21:48:41 * _deepfire looks into 'constraints'..
21:50:32 <popo[m]> What's the use of Haskell
21:50:42 <c_wraith> writing software
21:50:59 <popo[m]> Thanks
21:51:48 <dmwit> That... went better than expected.
21:52:06 <jle`> i've seen people just go down freenode channels asking about their topics before
21:52:15 <jle`> as far as freenode channels, #haskell is one of the biggest i think?
21:52:38 <dmwit> _deepfire: err
21:52:39 <c_wraith> usually the second largest
21:52:59 <dmwit> _deepfire: Can you not just write `foo :: {- that -}; foo _ = Just Proxy`?
21:53:07 <c_wraith> wow, it's at #5 now
21:53:15 <dmwit> _deepfire: (What do you actually want that to do?)
21:53:19 <jle`> :O
21:53:27 <pikajude> oh wow, ipfs is up there too
21:53:29 <pikajude> i didn't even know people used that
21:54:07 <jle`> well now i want to go to #ipfs and ask what ipfs is used for
21:54:10 <MarcelineVQ> pikajude: oh you sweet summer child :>
21:54:30 <c_wraith> ipfs is used for files. :)
21:54:30 <EvanR> ipfs is clearly used to transfer files to mars rovers and space probes
21:54:40 <c_wraith> right.  interplanetary files!
21:55:03 <pikajude> i messed with ipfs like 3 years ago for about a day
21:55:06 <pikajude> thought it was neat, had no reason to use it
21:55:33 <_deepfire> dmwit: wouldn't that imply that such a Proxy always exists, no matter the SomeTypeRep?
21:55:56 <jle`> _deepfire: are you trying to check if a SomeTypeRep is a certain 'a' ?
21:56:11 <jle`> in that case you can pattern match on the result of eqTypeRep
21:57:06 <_deepfire> Ok, full disclosure -- I get a SomeTypeRep over the wire (Codec.Serialise), so I don't know beforehand if it has a dictionary I want.
21:57:22 <jle`> SomeTypeRep will not contain a dictionary of the type it contains
21:57:53 <jle`> you want a constructor that can come with dictionaries, like vinyl's DictC
21:57:59 <_deepfire> Of course it won't, which is why I phrased my question as I did.
21:58:37 <jle`> you might be able to just roll your own, but ... you might have a hard time serializing it
21:58:49 <_deepfire> SomeTypeRep has a certain amount of type structure inside it, though.
21:58:55 <jle`> usually ghc can't match up instances 'at runtime' like that
21:59:15 <jle`> sort of, it's basically just the normalized type
21:59:26 <jle`> if it stores 'Maybe Int', it stores Apply Maybe Int, essentially
21:59:47 <jle`> but you can't get a type, and then ask ghc "does this type have an instance of c?"
21:59:50 <_deepfire> And I was hoping that GHC would expose its instance lookup machinery in some neat kind of API, so it could consume SomeTypeRep and _maybe_ give me an instance of some class.
22:00:10 <jle`> yeah, i thiiink would be some serious issues with consistency/coherence if it was possible
22:00:27 <jle`> since the importing of modules will change the behavior
22:00:50 <_deepfire> Well, sometimes we have no other choice but to take the dangerous way.
22:00:52 <jle`> but, there is a typechecker plugin that lets you do this in an unsafe way, i believe
22:01:06 <jle`> dangerous as in, your program's behavior can become undefined
22:01:15 <jle`> which might be bad in the case where you want to use your program for anything reliable
22:01:46 <dmwit> _deepfire: Yes, such a Proxy always exists... which is why I'm confused by your request.
22:01:57 <_deepfire> Well, 'reflection' exists, and allows you to play with type class dictionaries.
22:02:05 <jle`> i think the idea is that, you get a TypeRep a, and you want to use GHC to look up to see if 'a' has an instance of, say, Show
22:02:16 <jle`> at runtiem
22:02:21 <_deepfire> exactly!
22:02:26 <jle`> _deepfire: yes, but it does it in a type-safe and consistent way
22:02:39 <dmwit> You can't do that at all, with TypeRep or otherwise.
22:02:51 <jle`> it doesn't let you pull instances at runtime like that
22:02:52 <dmwit> You can barely even do it at compile time.
22:03:27 <jle`> this is just a big red flag that you might want to restructure your program
22:03:39 <dmwit> On the other hand, you can easily build a closed (but not necessarily finite) universe of types you support.
22:03:52 <_deepfire> RIght, that's exactly what I do now.
22:04:20 <_deepfire> But it is a maintenance burden to maintain a map from SomeTypeRep's to dictionaries.
22:04:27 <jle`> yeah, and that's something that doesn't have any problems with global typeclass instances popping up from upstream or downstream
22:04:51 <dmwit> No choice, I'm afraid.
22:04:59 <jle`> alternatively, you can send the dictionary alongside it
22:05:00 <_deepfire> I was afraid so, indeed..
22:05:02 <jle`> and reify the instance
22:05:08 <dmwit> Unless you really want the maintenance burden of modifying GHC instead. ;-)
22:05:11 <iqubic> TypeRep confuses me.
22:05:17 <_deepfire> well, that would amount to remote code execution ; -)
22:05:57 <_deepfire> (accepting the tycl dict across the wire, I mean)
22:06:01 <jle`> indeed
22:06:12 <_deepfire> ..also not terribly portable
22:06:32 <_deepfire> so different architectures won't be able to talk this language
22:06:43 <jle`> well, you can't send an actual lambda -- you'd send a defunctionalization of it
22:06:45 <_deepfire> or even GHC versions
22:06:52 <jle`> so a data type that describes the instance
22:07:25 <dmwit> oof
22:07:26 <jle`> still i think the most principled way is to have a universe of types to support
22:07:34 <jle`> that's basically the same as sending a big Either, instead
22:07:43 <_deepfire> well, I think this is wasted work -- if GHC has the dictionary I need 99% of the time
22:07:51 <_deepfire> I just want to ask it to nicely give it to me
22:08:00 <iqubic> I do not understand TypeReps.
22:08:03 <dmwit> GHC doesn't exist at runtime, to a first approximation.
22:08:05 <jle`> those instances don't really necessarily exist at runtime
22:08:13 <jle`> they might all be inlined
22:08:34 <jle`> so there might never be any actual Read Int at runtime; it just inlines calls to 'read' as read @Int's definition
22:08:52 <iqubic> Yeah. That makes sense.
22:09:26 <jle`> iqubic: i think we went over this earlier, but it's basically like assigning a string to each type using a typeclass
22:09:26 <dmwit> How big of a maintenance burden is this map, really?
22:09:34 <iqubic> How?!?!
22:09:43 <jle`> class MyTypeable a where typeOf :: p a -> String
22:09:45 <dmwit> It seems like the kind of thing you do once and then never think about again.
22:09:49 <jle`> instance MyTypeable Int where typeOf _ = "Int"
22:09:58 <jle`> instance MyTypeable Bool where typeOf _ = "Bool"
22:10:00 <jle`> etc.
22:10:00 * hackage GLFW-b 3.2.1.1 - Bindings to GLFW OpenGL library  https://hackage.haskell.org/package/GLFW-b-3.2.1.1 (Mokosha)
22:10:02 <jle`> nothing too magical
22:10:10 <iqubic> is 'p a' just a proxy?
22:10:14 <dmwit> You spend a full day thinking about all the types in all the libraries, and then move on with your life.
22:10:15 <_deepfire> dmwit, for a generic application that is supposed to be extensible beyond the author's conception -- it is
22:10:17 <jle`> it can be whatever you want :)
22:10:46 <dmwit> Presumably it's the job of the extension writer to extend the map, as well, if they need that.
22:10:49 <_deepfire> Imagine a business application where the user can create their own record types.
22:11:06 <_deepfire> then this business application has a frontend and a backend
22:11:15 <jle`> are you actually doing this, or are we imagining a potential future abstraction?
22:11:23 <_deepfire> I am actually doing this.
22:11:39 <_deepfire> looking up class dictionaries keyed by SomeTypeRep
22:11:42 <jle`> hm. yeah, it's just not possible, because ghc doesn't really have instance information at runtime
22:11:54 <popo[m]> What is the point of Haskell
22:12:01 <jle`> at compilation, you cna think of typeclasses associated with types as mostly not existing anymore
22:12:15 <jle`> popo[m]: it's a general purpose programming language :) so you can use it to write programs and software
22:12:28 <_deepfire> popo[m]: refactoring safety and large-scale program reasoning in general
22:12:29 <jle`> _deepfire: ghc doesn't have that information you are looking for, basically
22:12:34 <dmwit> popo[m]: I encourage you to think about a less inflammatory way to proceed. (Consider this a gentle warning.)
22:12:43 <popo[m]> Cool
22:12:59 <popo[m]> Oh
22:13:33 <jle`> _deepfire: for the most part, the association of a type with its tcl dictionary happens at compiletime, and after that, there is no meaningful linkage at runtime
22:14:02 <dmwit> It's not clear to me why user-extensibility actually makes this that much harder.
22:15:10 <jle`> also, if i am receiving a Dynamic type via an untyped channel...it's very rarely that i would want to handle an open universe of types
22:15:22 <jle`> it'd probably be "awaiting" an Int, or a String, or a certain Rec
22:15:24 <jle`> *Record
22:15:36 <jle`> or at best a closed universe of things i might be expecting to handle (Either String Bool)
22:16:45 * dmwit . o O ( just use Data.Aeson.Value for all your data )
22:17:30 <jle`> yeah, that's an example of a 'recursive' closed universe that accounts for a lot of potential situations
22:18:17 <_deepfire> that might be a solution, indeed..
22:19:44 <jle`> but yeah i can't really imagine a situation where i would really want to take *any* type
22:19:53 <jle`> s/take/await
22:20:22 <sshine> https://github.com/kuribas/aeson-diff-generic/blob/master/Data/Aeson/Diff/Generic/Instances.hs#L206 -- HLint complains here because I could write '(\v -> pure $ Node x v)' shorter, but I think then I should write '(\v -> pure $ Node v t)', and it doesn't look nearly as nice shortened. so if I should want to enable HLint in CI, what would be a good course of action be here?
22:20:49 <sshine> sorry, I could write '(\v -> pure $ Node v t)' shorter, too.
22:21:54 <_deepfire> dmwit: jle`: thank you for the discussion, gentlemen!
22:22:16 <_deepfire> I need to think this further..
22:22:34 <jle`> best of luck :)
22:26:15 <dmwit> I'm sure hlint has some way to disable specific suggestions. Have you taken a look at the documentation?
22:27:21 <sshine> dmwit, yes, it does. but I think that I can only disable specific instructions per file?
22:27:31 <sshine> dmwit, I don't mind this kind of hint, just not on this line.
22:28:28 <dmwit> Seems to offer binding-level granularity according to the docs I'm looking at.
22:28:31 * hackage antiope-swf 7.3.3 - Please see the README on Github at <https://github.com/arbor/antiope#readme>  https://hackage.haskell.org/package/antiope-swf-7.3.3 (arbornetworks)
22:28:45 <sshine> OK, I'll look.
22:28:49 <sshine> thanks.
22:29:31 * hackage antiope-sns 7.3.3, antiope-s3 7.3.3, antiope-sqs 7.3.3, antiope-optparse-applicative 7.3.3, antiope-contract 7.3.3, antiope-athena 7.3.3, antiope-messages 7.3.3, antiope-dynamodb 7.3.3, antiope-core 7.3.3 (arbornetworks)
22:54:28 <sshine> how does a package end up in stackage? by being released on hackage with a stack.yaml with a 'resolver: ...'? or by resolving package constraints?
22:54:50 <jgt> I _think_ it's the latter
22:55:05 <MarcelineVQ> https://www.stackage.org/ link at the bottom
22:55:12 <jgt> given that most of the packages on stackage predate stack
22:55:43 <sshine> MarcelineVQ, thanks!
22:55:45 <sshine> https://github.com/commercialhaskell/stackage/blob/master/MAINTAINERS.md#adding-a-package
22:55:51 <Axman6> you have to submit packages to stackage
22:56:01 <MarcelineVQ> too late nerds!
22:56:35 <jgt> foiled again!
22:56:38 <dminuoso> MarcelineVQ: The link at the bottom points to https://www.fpcomplete.com/server_software_development_and_devops_engineers
22:56:47 <dminuoso> Wasn't nerdy enough.
22:56:48 <MarcelineVQ> dminuoso: how dare you
22:56:58 <jgt> :D
23:02:56 <jle`> sshine: just as a note if you are planning on uploading, it's usually the case to not include a stack.yaml in your package on hackage
23:03:20 <jle`> remember that when you sdist your packages, every file that isn't a source file or in extra-source-files is ignored
23:03:29 <jle`> with some exceptions
23:26:31 * hackage elm-street 0.1.0.2 - Crossing the road between Haskell and Elm  https://hackage.haskell.org/package/elm-street-0.1.0.2 (vrom911)
23:37:10 <koz_> :t quotRem
23:37:12 <lambdabot> Integral a => a -> a -> (a, a)
23:38:15 <MarcelineVQ> :t quoteRem
23:38:17 <lambdabot> [Char]
23:38:45 <koz_> MarcelineVQ: Wat.
23:38:59 <Axman6> > quoteRem
23:39:01 <lambdabot>  "The ticket to your future is always blank."
23:39:07 <koz_> Uhh.
23:41:38 <MarcelineVQ> I'm sure it means nothing.
23:41:56 <lavalike> ominous
23:42:04 <int-e> @undef
23:42:04 <lambdabot> Undefined.
23:42:09 <int-e> :t quoteRem
23:42:10 <lambdabot> error:
23:42:10 <lambdabot>     • Variable not in scope: quoteRem
23:42:10 <lambdabot>     • Perhaps you meant ‘quotRem’ (imported from Prelude)
23:42:16 <int-e> Thought so.
23:43:07 <koz_> Hi int-e!
23:45:39 <koz_> Can I have some advice on rewriting something with an unfoldr? https://gist.github.com/kozross/fbf9da189e6460aa4596c1f17797cddf
23:46:02 <koz_> Wait, never mind, I wrote it wrong.
23:46:18 <koz_> https://gist.github.com/kozross/fbf9da189e6460aa4596c1f17797cddf <-- fixed
23:52:33 <int-e> > (unfoldr (\x -> case x of Nothing -> Nothing; Just 0 -> Just (minBound, Nothing); Just n | (q, r) <- quotRem n (fromIntegral (maxBound :: Word8)) -> Just (r, Just q)) . Just $ 10000) :: [Int] -- you need a value that produces the empty list... and most of the time using unfoldr makes code less readable, IME.
23:52:35 <lambdabot>  [55,39,-9223372036854775808]
23:53:23 <int-e> (I used Int mainly because that way the minBound stands out)
23:53:48 <koz_> int-e: Yeah, I thought I'd need something hideous like that.
23:54:07 <koz_> Thanks for that though - I've also never had unfoldr make things _clearer_.
23:54:33 <int-e> I use 'iterate' a lot. But never unfoldr.
23:54:38 <koz_> :t iterate
23:54:39 <lambdabot> (a -> a) -> a -> [a]
23:54:47 <koz_> Hmm, iterate might be just the ticket.
23:55:30 * hackage hw-uri 0.1.1.1 - Supports IO on URIs  https://hackage.haskell.org/package/hw-uri-0.1.1.1 (haskellworks)
23:55:32 <int-e> > map (`rem` 10) . takeWhile (/= 0) . iterate (`div` 10) $ 1000
23:55:35 <lambdabot>  [0,0,0,1]
23:55:41 <int-e> > map (`rem` 10) . takeWhile (/= 0) . iterate (`div` 10) $ 0
23:55:42 <lambdabot>  []
23:56:33 <int-e> It's not quite what you want, and it spoils the opportunity to use `quotRem`, but at least this is code I can reason about :)
23:56:47 <koz_> int-e: Yeah, I see what you mean.
23:57:47 <int-e> > iterate (\xs -> zipWith (+) ([0] ++ xs) (xs ++ [0])) [1] -- have some binomial coefficients
23:57:49 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
23:59:08 <int-e> koz_: and of course there's "apply f to x, n times": iterate f x !! n.
