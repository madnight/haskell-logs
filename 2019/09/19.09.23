00:00:10 <jle`> > join $ writer (Sum 3) (writer (Sum 4) "hi")
00:00:12 <lambdabot>  error:
00:00:12 <lambdabot>      • Couldn't match expected type ‘(m (m a), w0)’
00:00:12 <lambdabot>                    with actual type ‘Sum Integer’
00:00:39 <jle`> > runWriter . join $ writer (writer ("hi", Sum 3), Sum 4)
00:00:41 <lambdabot>  ("hi",Sum {getSum = 7})
00:00:46 <jle`> note that we get 7 as a result
00:01:02 <jle`> this throws away information about the original structure: did we have 0 and 7? did we have 1 and 6? did we have 2 and 5? etc.
00:01:25 <jle`> whadevah: do you mean, a monoid in a category of endofunctors?
00:01:50 <jle`> also remember that monoidal actions don't have to be invertible...that's not a property of monoids
00:02:08 <jle`> you seem to associate invertibility here somehow, maybe from some previous experiences you've had with an unrelated structure?
00:02:15 <jle`> > [1,2] <> [3,4,5]
00:02:17 <lambdabot>  [1,2,3,4,5]
00:02:31 <jle`> this is not invertible --- we can't undo <> into the lists that made it up. we lose information on where the split was
00:02:39 <whadevah> Yes, to define it we need a monoid. So we should have objects T, T^2, ... T^n .. ad infinitum and also unique morphisms between them 
00:02:49 <whadevah> but what exactly are these morphisms
00:03:29 <whadevah> it can't be eta, because it only goes from Id to T 
00:03:36 <whadevah> Not from T to T^2 
00:03:46 <svipal> Thank you Axman
00:04:27 <jle`> i think you might be mixing up different definitions -- a 'monoid in a category' is different from the concept of monoid specifically
00:05:34 <Axman6> svipal: what options do you need to pass btw?
00:05:34 <whadevah> We should have a way of combining objects (bifunctors), we should have a 1-object (in our case identity) and that's pretty much it, no? 
00:06:39 <jle`> if C is a monoidal category under x, then you need mu : M x M -> M, and unit : 1 -> M
00:06:45 <svipal> I'm trying to make fmod "bindings" for haskell (using inline-c) , so I need -lfmod and -lfmodstudio as well as changing the include directories 
00:06:49 <jle`> the object M, specifically, is the "monoid in C"
00:07:14 <jle`> it doesn't say that mu and eta have to be isomorphisms, just that mu has to be associative
00:07:54 <jle`> so if you ever collapse (M x M x M) -> M, then it doesn't matter if you collapse the forst M x M, then the second ... or if you collapse the second, then the first
00:08:02 <svipal> I... think ? I'm really new to C 
00:08:10 <whadevah> So we only need two objects to define it - 1 and M 
00:08:35 <jle`> whadevah: well, you need the entire monoidal category to define it
00:08:44 <whadevah> But what about all those other objects in a category of endofunctors? M^2 as an example
00:08:57 <jle`> those are all a part of your category
00:09:06 <jle`> a "monoid in C" refers to *one specific object* in C
00:10:17 <jle`> "monoid in C" is not the same as a traditional monoid in abstract algebra/group theory; it's a generalization
00:10:45 <jle`> under specific categories C, you get back the original idea of a monoid from AA/group theory
00:11:13 <jle`> but this notion of a monoid as a set equipped with a binary operation is only a specific form of 'monoid in C'
00:12:12 <jle`> and isn't relevant for all "monoid in C" concepts in general
00:13:08 <whadevah> But I thought it was a part of a definition. Unit, binary operation and associativity
00:13:44 <jle`> whadevah: are you going off of the deifnition: "A monoid is a set equipped with a binary operation that is associative, and a unit with respect to that operation"?
00:14:16 <jle`> if so, this is the definition of group theory/abstract algebra monoids ... which is a *different* concept from the concept of a monoid in a monoidal category
00:14:28 <jle`> the two things have different definitions
00:14:48 <jle`> so when we say that "blah blah is a monoid in the category of endofunctors", we aren't using that group theory/abstract algebra definition of monoid
00:15:09 <whadevah> No, I'm trying to get it from categorical terms: bifunctor (tensor product) and unit
00:15:47 <jle`> so, what is your definition of a monoid in a monoidal category?
00:16:33 <jle`> whadevah: you ask "what about those other objects in a category" -- those other objects aren't a part of that specific monoid in a monoidal category
00:16:42 <jle`> a monoid in a monoidal category is specifically one single object
00:16:48 <whadevah> an "assortment" of objects all of which have a tensor product, plus unit 
00:17:13 <dminuoso> whadevah: the tensor product is defined on the entire category.
00:17:23 <jle`> that isn't quite what it is; it looks like you're going back to the idea of a monoid being some "assortment of things", with an operation on those things
00:17:32 <jle`> this is true for group theory/abstract algebra monoids
00:17:42 <jle`> it's not true for the idea of a monoid in a monoidal category
00:18:15 <whadevah> You want to say that T^2 is not a part of a monoid T? 
00:18:28 <jle`> yes
00:18:46 <jle`> it is not a part of the idea of a monoid in a monoidal category
00:19:02 <dminuoso> whadevah: The tuple (M, μ, η) in some monoidal category is what you would call a monoid. It's that single object with two natural transformations. Nothing more.
00:19:31 <whadevah> But to define mu we still need T^2 just to go return to T 
00:19:35 <jle`> i think one issue here is that you looking at properties of a *specific* monoid in a monoidal category (namely, group theory/abstract algebra monoids) and trying to apply those properties to other monoids in monoidal categories
00:19:37 <ski> iqubic : "Is it fixed point recursion?" -- it's recursive. not sure what you mean by "fixed point recursion"
00:19:55 <jle`> but this is like trying to look at properties of Integer, and generalizing it to all groups.
00:20:45 <jle`> whadevah: T^2 exists already, because we're in a monoidal category
00:21:15 <jle`> T^2 exists, T^3 exists, etc. forever, for all objects T in a monoidal category
00:21:21 <jle`> even those that aren't monoids in a monoidal category
00:21:39 <dminuoso> ^- iow: a monoidal category could have no monoids at all.
00:22:26 <whadevah> Yes, I was thinking exactly about that, there are some objects which a part of our "monoid" (now I see where I'm wrong) like T^2 etc., and some are not, say, D 
00:22:46 <jle`> whadevah: the idea of "being a part of our monoid" only exists for AA/group theory monoids
00:22:53 <jle`> it doesn't apply to monoids in monoidal categories in general
00:23:17 <jle`> admittedly they maybe could have picked less confusing names
00:23:58 <whadevah> Are they not defined because they are guaranteed to exist?
00:24:00 <jle`> the idea that a monoid consists of a set of 'things'/'objects' is only true for AA/group theory monoids
00:24:05 <dminuoso> whadevah: objects are not *part* of a monoid, they *constitute* the monoid. Say in a monoidal category C you might have some object `s`. That object s might be a monoid. No other object is part of the definition of that object.
00:24:32 <jle`> whadevah: what isn't defined, do you mean?
00:25:12 <whadevah> Like you said, T^2, T^3 are all already there, so we can generalize and remove them from our definition 
00:25:27 <whadevah> We only need one object and two morphisms
00:26:25 <dminuoso> Two natural transformations.
00:27:03 <jle`> well, our definition only refers to one object and two morphisms, yeah.
00:27:06 <whadevah> And then, if we go back to sets, by just having these three things, we can define a set which would correspond to a definition in terms of sets
00:27:17 <jle`> natural transformations if your morphisms are natural transformations, like in the category of endofunctors
00:27:51 <jle`> if you want, we can recover the definition of AA/group theory monoids, from the idea of a monoid in a monoidal category
00:27:58 <jle`> but i feel at this point we've already gone pretty far off-topic
00:28:12 <jle`> so we can take this into #haskell-overflow or ##categorytheory maybe
00:30:37 * ski . o O ( "AA/group theory monoids" ? )
00:30:54 <jle`> the idea of monoids as typically encountered in abstract algebra
00:31:22 <jle`> ie, a set equipped with an associative binary operation and a unit
00:32:07 <ski> ("AA" is "Abstract Algebra" ?)
00:32:13 <jle`> the terminology is a bit confusing i think. "monoid in a monoidal category" *sounds* like it is a specialization/specific Abstract Algebra monoid
00:32:15 <jle`> 🎿 heh, yeah
00:32:21 <jle`> * ski: heh, yeah
00:32:25 <ski> ty
00:32:49 <jle`> but in reality it's the other way around -- abstract algebra monoid is a specialization/specific monoid in a monoidal category.
00:33:22 <svipal> Axman6 : it works fine, thanks
00:33:24 <ski> (or "monoid in a monoidal category" is a generalization of "monoid")
00:33:54 <svipal> CUrious : has anyone here ever built contexts for inline-c ? it looks so arcane Hahaha
00:33:55 <whadevah> Sure, thank you very much! I now see one more way how ideas can be abstracted in category theory. We defined monoidal category and then by just specifying one object from that category and two natural transformation we can define an entire monoid with all those infinite elements and morphisms
00:34:22 <Axman6> I have once... making a binding to wolfFFL
00:34:25 <whadevah> but we abstracted them all
00:34:31 <jle`> hm, you're still thinking of a monoid as "having" those infinite elements, but ... i think you get the basic picture
00:34:34 * ski would say "two morphisms" .. in this case, since the objects in the category are functors, the morphisms will be natural transformations
00:34:56 <jle`> the category theoretical monoid doesn't 'have' any elements
00:35:03 <svipal> Axman6 : Where did you look for examples or inspiration >
00:35:42 <Axman6> I can't remember. I also don't think I put it on github :| I should do that
00:36:28 <whadevah> yes, we abstracted everything and now we are left with minimal structure specifying all kinds of monoids by just picking one element
00:36:34 <jle`> whadevah: i think you're still holding on to the idea that a monoid is defined over a some set of elements
00:37:07 <jle`> hm, the usage of the word element here is somewhat suspect
00:37:11 <svipal> Haha, sure, do it ;D
00:38:12 <whadevah> I think it's mostly because we defined monoidal category as a generalization of a category with a bifunctor and unit (product and terminal object)
00:39:43 <ski> whadevah : the bifunctor with neutral object doesn't have to be categorical product with terminal object
00:39:47 <jle`> hm. okay we can compare this to the AA monoid to see why T^2, T^3 etc. aren't related to this monoid definition. it's not just because they're redundant, it's that they are unrelated completely
00:40:09 <jle`> so we can look at the category Set, equipped with the cartesian product as its monoidal structure
00:40:33 <jle`> in this case, a traditional monoid is a monoid in the category Set
00:41:05 <jle`> for example, Z is such a monoid, because we have morphisms (Z x Z) -> Z, and () -> Z
00:41:25 <jle`> Z being an object in Set
00:41:41 <jle`> and those morphisms obeying the rules of associativity and identity
00:42:24 <jle`> do you see how Z x Z x Z, Z x Z, etc., aren't really a part of this monoid?
00:42:43 <jle`> sure we have morphisms Z^2 -> Z, and Z^0 -> Z.
00:43:05 <jle`> but the monoid itself, we don't really care about (1,2,3). we only care about combining two integers
00:43:38 <jle`> that's why when we talk about group theory monoids, we don't say "a group theory monoid is a set equipped with a binary, trinary, quadrenary, qintary, etc. function, such that ..."
00:44:04 <ski> (⌜ℤ × ℤ⌝ isn't part of the definition of this monoid ⌜⟨ℤ,0,(+)⟩⌝. it's just that ⌜ℤ × ℤ⌝, aka ⌜ℤ²⌝, occurs in the "type signature" of the binary operation ⌜(+) : ℤ × ℤ ⟶ ℤ⌝. but it's not a "part of" the monoid ⌜⟨ℤ,0,(+)⟩⌝)
00:44:44 <jle`> a group theory monoid has a binary operation, and not necessarily a triple/quadrenary/quintary/etc. operation.
00:45:19 <jle`> and also the 'elements' of this monoid here are elements *of Z*
00:45:22 <whadevah> Because these operations can be defined in terms of one single binary operation
00:45:24 <jle`> they're 0, 1, 2, 3, -3, etc.
00:45:32 <jle`> the 'element' of this monoid isn't Z
00:45:54 <ski> (alternatively, you could say that the ⌜n⌝-ary operation, for each ⌜n⌝, can be automatically derived from the nullary and the binary operations)
00:45:56 <jle`> saying that "the element of my monoid in a category of endofunctors is T" is wrong, in the same way that saying "the element in my abstract algebra monoid is Z"
00:46:10 <jle`> the *elements* in your AA monoid are *elements* of Z
00:46:25 <jle`> the *elements* in your monoidal category monoid? ... there is no analogy
00:47:18 <jle`> so when you say that "T is the single element of the monoid", it's not quite correct --- that's like saying that an element of my group theory monoid is Z
00:47:32 <jle`> it isn't Z -- the elements are 0, 1, 2, -2, -50, etc.
00:48:09 <jle`> Z isn't an element of the monoid. it *is* the monoid (along with the operations)
00:48:13 <svipal> Axman6 : before I get in too deep would you say using inline-c is the right approach to make FMOD usable from haskell ? I have been looking at hsc2hs as well
00:48:14 <jle`> T isn't an element of the monoid. it *is* the monoid
00:49:26 <jle`> when we say that we could define AA monoid as "an n-ary operation for each n", we aren't saying that these operations are different elements in the monoid.
00:49:34 <ski> (it would also be possibly to specify "monoid" in terms of having an ⌜n⌝-ary operation, for each ⌜n⌝, satisfying "associative" laws relating them. or, if preferred, having a single operation taking an (ordered, finite) list of elements, and producing an element. but the traditional way is with a nullary operation, and a binary operation)
00:49:49 * ski nods to jle`
00:49:55 <jle`> yeah, perhaps that line of thinking that i went down was counter-productive to my point
00:50:54 <ski> (and, regardless of the way you want to present the concept "monoid", you get the same concept in the end, anyway)
00:51:06 <jle`> it's this quote here: "we can define an entire monoid with those infinite elements and morphisms", implies that you are thinking of the elements as T, T^2, T^3, T^4, etc.  but that's like saying that the elements of monoid Z are Z, Z^2, Z^3, Z^4, etc.; which is clearly not true.  the elements of the monoid in Z are the integers, not Z^2,Z^3,Z^4,etc.
00:51:15 <merijn> svipal: Depends, do you need to mutate structs from within Haskell, or just call C APIs from Haskell?
00:53:32 <svipal> Basically I just need constant references through the whole app to a few things ( if you know how FMOD works, overall system, event descriptions, also local references to event instances) the rest are just calls and switches on error results 
00:54:34 <svipal> I have -never- done any C FFI of any sort before
00:55:26 <whadevah> But we may have an object Z, we know nothing about its elements, and yet we may have morphisms [Z, Z] which by themselves are m, m^2, m^3 etc. And then we can build a category of these endomorphisms. And after that we can pick up just one morphism (which is an object) and two morphisms in that category to define this monoid again
00:55:47 <merijn> svipal: If you don't have to mutate structs from Haskell, but only need to store pointers and call C functions you probably don't need inline-C or hsc2hs at all, tbh
00:55:52 <jle`> whadevah: right, the key is one/two/etc. morphisms, not one/two/etc. elements
00:56:08 <jle`> the morphisms do not correspond to the elements
00:56:30 <merijn> svipal: I assume you're already at home in C, in which case I'd say: 1) read chapter 8 of the Haskell Report (which describes the FFI) and 2) read the GHC user's guide section on FFI, which has some more info
00:56:34 <merijn> @where report
00:56:34 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
00:56:36 <merijn> @where userguide
00:56:36 <lambdabot> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/
00:57:06 <whadevah> but they are elements in our new category, and we still need all these morphisms to define our monoid 
00:57:07 <svipal> thanks for the help. 
00:57:08 <merijn> svipal: The C FFI is pretty straightforward if you know any amount of C
00:57:15 <jle`> whadevah: categories do not have elements
00:57:25 <whadevah> objects
00:58:08 <jle`> the problem with using the word 'elements' here is that the AA monoid does have the concept of elements. and this is *not* related to objects in the category
00:58:18 <merijn> svipal: inline-c is more for "I want to write C code which is supposed to be called from Haskell, but it's small enought that I'd like to do it inline, rather then in a separately compiled C file"
00:59:18 <merijn> svipal: And hsc2hs's usecase is more for "I want to mutate C structs from Haskell, so I need to determine all the relevant field offsets of the struct's members to generate a correct Storable instance"
01:01:35 <jle`> whadevah: the *elements* of monoid Z are *not* Z, Z^2, Z^3, Z^4, etc.  just like the *elements* of a CT monoid are *not* T, T^2, T^3, etc.; so you can't call them elements.
01:05:35 <whadevah88> BSoD ensued ^^
01:06:12 <jle`> ah, my last message after yours was:
01:06:14 <jle`> whadevah: the *elements* of monoid Z are *not* Z, Z^2, Z^3, Z^4, etc.  just like the *elements* of a CT monoid are *not* T, T^2, T^3, etc.; so you can't call them elements.
01:10:40 <whadevah88> Let's say we now are in Set category, we have a bunch of endomorphisms from on type into the same type. A typical monoid in terms of a set. We can then create another category in which every object would correspond to a function, (+1), (+23), etc.. These objects are not elements of Z! And to define a monoid we actually need two things. A morphism
01:10:40 <whadevah88> between Id(+0) object and our (+1) object and another morphism from, say, +2 to +1. And that would give us a monoid
01:11:00 <whadevah88> We can do the same in terms of endofunctors and natural transformations between them 
01:14:00 * hackage genvalidity-property 0.5.0.0 - Standard properties for functions on `Validity` types  https://hackage.haskell.org/package/genvalidity-property-0.5.0.0 (Norfair)
01:15:28 <libertyprime> Hey guys. I'm trying to run "runhaskell Setup.hs configure --ghc" but getting "GHC_PACKAGE_PATH is incompatible". Could I please get some help with this: http://ix.io/1Wwy
01:15:30 * hackage genvalidity-hspec 0.7.0.1 - Standard spec's for GenValidity instances  https://hackage.haskell.org/package/genvalidity-hspec-0.7.0.1 (Norfair)
01:16:00 <whadevah88> And here is one more thing. Our bifunctor here is just a composition! (we can compose (+1) and (+2) and get another "object" +3 and that's all there is too it)
01:21:59 <Guest66> Hey
01:22:22 <Guest66> Is there any way to scan haskell packages for License compliance?
01:23:06 <ski> whadevah88 : would all the objects be of the form `(+ n)' for some `n' in `|Z', in this example ?
01:24:33 <merijn> Guest66: I recall there was a tool for this, but I don't remember the name >.>
01:26:20 <Guest66> Hehe. I'll try and look for that, merijn
01:27:10 <whadevah88> @ski It depends on which morphisms we choose, we can define many different monoids by just specifying one function and two transformations. We can pick (+0) -> (+2) -> (+4) and here is a monoid of all even numbers, or can choose something else. It's just that we only need three specific things (which are not even elements of a set) to define a
01:27:10 <lambdabot> Maybe you meant: wiki src ask
01:27:11 <whadevah88> whole monoid 
01:28:10 <ski> whadevah88 : i would like to know what the objects are, before starting talking about the morphisms ? what the morphism are would be the next question
01:30:04 <whadevah88> ski we have no way of knowing what objects are. There only thing we have are morphisms and combinations between them. If we start looking at elements then we are already talking in terms of set
01:31:03 <ski> you already started talking about `Set', so i don't see why "If we start looking at elements then we are already talking in terms of set" would be a problem
01:31:28 <jle`> whadevah88: er hm, just in case you weren't aware, all categories must have well defined objects
01:31:29 <ski> (and i don't understand what you mean by "we have no way of knowing what objects are.")
01:33:18 <whadevah88> oh, I mean we can't look inside of objects. We may now that an object represents Z, or N. But we can't look inside and say "hey! There are numbers from zero to infinity!", we can only look at morphisms and define everything in terms of them
01:33:20 <jle`> the first thing you establish when you are defining a category is the objects; the second thing is the morphisms
01:33:32 <jle`> right, so what are the objects of this category you are talking about?
01:33:34 <karlos39b> hola
01:33:36 <karlos39b> gi
01:33:38 <karlos39b> hi
01:33:42 <karlos39b> ion fron
01:33:42 <whadevah88> know*
01:34:19 <ski> "we can't look inside of objects" -- from the POV of category theory. when you're defining a category, where the objects are structured sets, then there's no problem with looking inside those sets
01:34:57 <whadevah88> morphsims of Cat, i.e. functors, more specifically - endofunctors 
01:35:21 <ski> is that ^ an answer to a question (which ?) ?
01:35:43 <ski> (hm, i suppose maybe jle`s latest question, maybe ??)
01:35:53 <whadevah88> Yes 
01:36:56 <jle`> hm, maybe answer the question with your (+1) (+23) etc. example
01:37:01 * ski thought whadevah88 was talking about taking some endomorphisms on ⌜ℤ⌝ in ⌜Set⌝ (or ⌜Ab⌝ ?), and picking those to be the objects of a new category
01:37:04 <jle`> what are the objects of that category?
01:37:25 <whadevah88> functions
01:37:34 <ski> (but now you're talking about morphisms in ⌜Cat⌝, so i don't see how this can be the same category)
01:37:40 <ski> which functions ?
01:38:12 <sshine> (+1), (+23)?
01:38:44 <ski> only those two ?
01:38:59 <sshine> ski, no, they were examples of a form you gave earlier.
01:39:01 <ski> so, a category with two objects
01:39:13 <whadevah88> I was talking about Cat and Set at the same time. (How we can define monoids in terms of functions in Set and functors in Cat)
01:39:21 <ski> i asked
01:39:22 <ski> <ski> whadevah88 : would all the objects be of the form `(+ n)' for some `n' in `|Z', in this example ?
01:39:32 <ski> but whadevah88 didn't answer that (that i could see, at least)
01:39:38 <jle`> we're talking about this category: "We can then create another category in which every object would correspond to a function"
01:40:26 <ski> whadevah88 : you were also talking about some other category, unclear to me which. that's the one i was asking you about, asking you to clarify how it was defined
01:40:47 <whadevah88> They won't be in Z, they are endomorphisms from Z to Z 
01:40:58 <jle`> so the objects are all endomorphisms from Z to Z ?
01:41:03 <ski> or only some of them ?
01:41:10 <whadevah88> all of them 
01:41:15 <ski> ok, thank you
01:41:26 <ski> next, what are the morphisms ?
01:42:07 <whadevah88> Here they are curried functions (+0) (+1) (+2) .. etc 
01:42:27 <jle`> didn't you just say those were the objects?
01:43:09 <whadevah88> yes, endomorphisms in Set are objects in our new category 
01:43:31 <whadevah88> they can be composed, and they have an identity, so we can construct it 
01:43:55 <jle`> ok, they are the objects. so what are the morphisms?
01:43:57 <ski> given two objects ⌜f,g : ℤ ⟶ ℤ⌝, what is a morphism ⌜m : f ⟶ g⌝, in this category ?
01:46:51 <whadevah88> Hm, in terms of Cat these would be natural transformations, but we don't have those here. Now it looks like the same functions are not only objects but are also morphisms 
01:47:10 <whadevah88> But I remember that sets are discreet categories and don't have any structure (morphisms)
01:49:11 * ski doesn't see what ⌜Cat⌝ would have to do with this category
01:51:34 <whadevah88> In Cat there are endofunctors which can be represented as object in a category [C, C] in which morphisms are natural transformations. And to define a monoid we need two natural transformations from that category (mu and eta) and one endofunctor
01:52:10 <ski> whadevah88 : perhaps you don't want objects in this category to be morphisms ⌜f⌝ in ⌜Set⌝ with ⌜f : ℤ ⟶ ℤ⌝, but rather perhaps objects should be, say triples ⌜⟨A,f,B⟩⌝, with ⌜f : A ⟶ B⌝ in ⌜Set⌝ ?
01:52:30 * hackage validity-containers 0.4.0.0 - Validity instances for containers  https://hackage.haskell.org/package/validity-containers-0.4.0.0 (Norfair)
01:53:31 * hackage genvalidity-containers 0.7.0.0, validity-containers 0.5.0.0 (Norfair): https://qbin.io/salon-ranch-ksm1
01:54:31 * hackage genvalidity-property 0.5.0.1, genvalidity-hspec 0.7.0.2 (Norfair): https://qbin.io/pastor-trains-8ucu
01:54:38 <ski> in that case, a morphism from ⌜⟨A₀,f₀,B₀⟩⌝ to ⌜⟨A₁,f₁,B₁⟩⌝ could be a pair ⌜⟨g,h⟩⌝ with ⌜g : A₀ ⟶ A₁⌝ and ⌜h : B₀ ⟶ B₁⌝, where ⌜h ∘ f₀ = f₁ ∘ g⌝ holds
01:55:38 <ski> (this is just a wild guess .. though perhaps you still want to have endomorphisms. so objects maybe should be pairs ⌜⟨A,f⟩⌝ with ⌜f : A ⟶ A⌝ in ⌜Set⌝ ?)
01:58:09 <ski> whadevah88 : by "monoid" there, you mean "monoid in the monoidal category ⌜[𝒞,𝒞]⌝" ?
01:58:39 <whadevah88> I tried to reproduce the same steps in Set we did in Cat, to define monoids. But there we had natural transformations between endofunctors, here we don't have anything (morphisms)
01:58:40 <whadevah88> yes
01:59:31 <ski> ⌜Set⌝ is not a ⌜2⌝-category (in any non-trivial way)
02:01:12 <whadevah88> But we still have monoids in Set, and if there exists a universal way to construct them, so we should be able to somehow apply it here 
02:01:30 * hackage genvalidity-containers 0.8.0.0 - GenValidity support for containers  https://hackage.haskell.org/package/genvalidity-containers-0.8.0.0 (Norfair)
02:01:37 <ski> monoids in the monoidal category ⌜Set⌝ are just ordinary monoids
02:04:36 <whadevah88> So how can they be constructed by having one endofunctor and two natural transformations?
02:13:39 <Synthetica> Is there a way to programmatically get the location of a definition of a function (or the definition itself)
02:13:52 <EvanR> whadevah88: also you have "generalized elements"
02:14:12 <syd> Synthetica: only at compile-time. TH can do that. What are you trying to do?
02:15:07 <Synthetica> syd: I want to include haskell snippets in a document, but I want to keep them in sync with my source code
02:15:34 <Synthetica> So I was thinking of writing either a sphinx plugin or pandoc filter similar to sphinx's :pyobject:
02:16:06 <ski> whadevah88 : "So how can they be constructed by having one endofunctor and two natural transformations?" -- "they" being what, now ?
02:16:37 <syd> Synthetica: Chris allen has done this for his book, I think. You may want to ask him.
02:16:51 <whadevah88> ski ordinary monoids
02:17:14 <ski> whadevah88 : you can't be referring to "monoids in the monoidal category ⌜Set⌝ are just ordinary monoids", by that "they", since that doesn't make any sense (the monoidal category ⌜Set⌝ doesn't have endofunctors as objects) .. so you must be referring to something else again, i don't know what
02:19:48 <whadevah88> ski It was said that the monoid in categorical terms is just an endofunctor and two natural transformation. And it was also said that this is as abstract as you can get. If it's so then how can I construct an "ordinary set monoid" out of categorical abstraction of monoids
02:20:35 <Synthetica> syd: Thanks for the reference!
02:21:52 <ski> whadevah88 : "the monoid in categorical terms is just an endofunctor and two natural transformation" -- that was only in the situation when the monoidal category in question was a category where the objects were endofunctors (and the morphisms were natural transformations between those endofunctors)
02:22:20 <ski> whadevah88 : in general, in a monoidal category, a monoid object there doesn't have to have anything to do with endofunctors and natural transformations
02:23:22 <EvanR> a monoid in the category of monoids is the best
02:25:40 <Taneb> EvanR: I like that example :)
02:27:06 <EvanR> fix (monoid in the category of _)
02:27:30 <ski> whadevah88 : in general, in a monoidal category ⌜⟨𝒞,𝕀,(⊗)⟩⌝, a monoid object is a triple ⌜⟨A,η,μ⟩⌝, where ⌜A⌝ is an object in ⌜𝒞⌝, and where ⌜η : 𝕀 ⟶ A⌝ and ⌜μ : A ⊗ A ⟶ A⌝ are morphisms in ⌜𝒞⌝, satisfying some laws (neutral element and associativity laws)
02:28:05 <EvanR> i get unicode snowmen here but not half of ski's characters just now
02:28:16 <ski> whadevah88 : it's just that when this monoidal category is a category where the objects are endofunctors (on some given category), then those two morphisms are actually natural transformations
02:29:25 <ski> whadevah88 : in general, in a monoidal category `<C,I,(*)⟩', a monoid object is a triple `<A,eta,me>', where `A' is an object in `C', and where `eta : I >---> A' and `mu : A * A >---> A' are morphisms in `C', satisfying some laws (neutral element and associativity laws)
02:29:30 <ski> EvanR : better ?
02:29:54 <ski> (s/me/mu/)
02:30:09 <EvanR> yes
02:30:25 <kuribas> is haskell really so difficult?  Once you get used to the patterns of functional programming, it seems to me haskell is easier than other languages.
02:30:58 <jle`> i don't think it's really so difficult, and a lot of people learning haskell often agree. but it's hard to separate out effects of survivorship bias
02:31:02 <kuribas> You do have to deal with a lot of layers, like stacks of monads.
02:31:12 * EvanR looks out the window across the landscape and the universe at all the patterns of functional programming still to learn
02:31:15 <libertyprime> i think the problem with haskell is the tooling. i can get like 1% of things on github to compile
02:31:20 <jle`> so i don't have the confidence to make a real statement on the matter.
02:31:38 <kuribas> libertyprime: tooling leaves a lot to be desired
02:31:56 <kuribas> I find the having a lot of layers is only superfically complex, but seems to turn of a lot of people.
02:31:59 <boxscape> asking in the #haskell IRC channel *might* give you a slightly biased view ;-P
02:32:30 <kuribas> and it is made easier with types and a decent editor that shows you the types.
02:32:33 <libertyprime> i think its just tough for people to pick up haskell when its difficult to get the ball moving
02:33:10 <whadevah88> ski and that's the most general concept, I see. But then how we can define our "simple set monoid" in these terms. What is a monoidal category? Eta? Me? 
02:33:15 <kuribas> I find myself often dealing with a lot of complexity in other languages that you have much less in haskell
02:33:46 <kuribas> EvanR: a lot of those patterns aren't necessary to use haskell (like recursion schemes)
02:34:24 <ski> boxscape : heh :)
02:35:04 <jle`> whadevah88: we sort of went over this earlier, but our simple group theory monoid because just that definition applied to Set, where the monoidal structure is cartesian product
02:35:15 <jle`> *becomes just
02:35:35 <boxscape> I think some people when learning haskell are upset that it doesn't just let them put printfs everywhere
02:36:28 <ski> whadevah88 : a "simple set monoid", an ordinary monoid, is just a monoid object in the monoidal catgory ⌜<Set,1,(×)>⌝, iow using the terminal object (singleton set. set containing only empty tuple) and the categorical product (being cartesian product, for ⌜Set⌝) being the monoidal structure
02:36:46 <kuribas> boxscape: it does!
02:36:54 <maerwald> libertyprime: absolutely true
02:37:05 <ski> whadevah88 : and `eta' picks out the neutral element in the monoid (iow is the nullary operation), and `mu' is the binary operation of the monoid
02:37:07 <kuribas> boxscape: but the order may be a bit strange
02:37:24 <kuribas> boxscape: (Debug.Trace.traceShow)
02:37:38 <boxscape> yeah, but that's not typically something you learn about when learning haskell
02:37:53 <ski> (it's not ?)
02:37:59 <boxscape> I didn't
02:38:14 <boxscape> I learned by reading LYAH and some real world haskell
02:38:19 <ski> hm, i think it gets mentioned reasonably often, in here ?
02:38:21 <maerwald> boxscape: because most haskell tutorials don't really get in-depth about how evaluation works and that you can actually nicely see how it does, when you use Debug.Trace
02:39:25 <tdammers> I think a bigger reason is that under normal circumstances, you don't even need to know
02:39:35 <whadevah88> ski thanks for sticking with me for so long, I think I mostly understood everything, at least compared to as it had been before. Thank you one more time, yep!
02:40:00 * hackage eventstore 1.3.2 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-1.3.2 (YorickLaupa)
02:40:19 <lortabac> boxscape: the problem is that Debug.Trace is not as reliable as a simple print in other languages
02:40:25 <maerwald> I think for any reasonably sized project, you need to know. Which is also the point where accidential complexity starts growing similar to any other language (with different distribution)
02:40:42 <lortabac> boxscape: sometimes it can give you unexpected results
02:41:08 <ski> whadevah88 : np :)
02:41:21 <lortabac> boxscape: even though to be fair beginners are unlikely to hit those corner cases
02:42:44 <maerwald> lortabac: what do you mean with unexpected results?
02:42:49 <tdammers> maerwald: I didn't mean that you never need to know, or that there are codebases where you need to know in 0% of the cases. Just that when working on any given project, you can afford to not think about evaluation order most of the time, and just apply equational reasoning (i.e., assume incorrectly that bottoms do not exist)
02:43:01 <jle`> debug.trace is definitely very different than print in other languages
02:43:14 <jle`> you have to understand how haskell's/ghc's evaluation model works
02:43:15 <tdammers> it's technically wrong, but you can usually get away with it for large parts of any given codebase
02:43:37 <maerwald> jle`: yes and that is expected, it has nothing to do with the debug.trace implementation
02:44:10 <maerwald> tdammers: maybe that's why most haskell tooling blows up memory? ;)
02:44:30 <tdammers> maerwald: it's definitely a factor.
02:44:50 <Synthetica> syn: I looked at the sample of the book, but what they seem to do is include full files in their pdf, including module headers and all. I was looking for a granular approach, where I can extract single function or data definitions from a file
02:45:04 <tdammers> maerwald: another factor is that we have lots and lots of canned abstractions under our fingertips, so the "effective complexity / lines of code we wrote ourselves" ratio is often massive
02:45:22 <Synthetica> syd: sorry, wrong ping
02:45:30 <lortabac> maerwald: for example sometimes because of inlining you see no output, even though the code is executed
02:46:34 <lortabac> maerwald: s/inlining/sharing
02:46:57 <lortabac> maerwald: inlining can give you the opposite problem, even though it's never happened to me in practice
02:47:12 <syd> Synthetica, not sure then. You _could_ try to use the ghc api or haskell-src-exts to retrieve the line numbers (or the entire implementation, but without comments) and then get those 
02:48:38 <dansho> is there a library that provides read :: Text -> a?
02:48:56 <maerwald> lortabac: if it is shared, it isn't executed twice?
02:49:14 <EvanR> also can it provide readMaybe :: Text -> Maybe a
02:49:59 <lavalike> @index readMaybe
02:49:59 <lambdabot> Text.Read
02:50:00 <dansho> EvanR: i guess, i'm just trying to stay away from String, currently using ClassyPrelude which has tshow for text
02:50:15 <EvanR> nice
02:50:40 <EvanR> :t Text.Read.readMaybe
02:50:41 <lambdabot> Read a => String -> Maybe a
02:50:47 <EvanR> whatta
02:50:52 <maerwald> tdammers: so writing zero-cost abstraction is basically hard (which is another set of accidential complexity)
02:50:54 <jle`> Text.Read is from base
02:51:16 <lortabac> maerwald: if it's inlined it can be executed twice
02:51:33 <maerwald> lortabac: I was referring to your sharing remark
02:51:38 <lortabac> maerwald: ah ok I see
02:51:50 <boxscape> dansho: classy-prelude has readMay
02:52:16 <lortabac> maerwald: I was confused the first time I ran into this behavior
02:52:24 <boxscape> https://hackage.haskell.org/package/classy-prelude-1.5.0/docs/ClassyPrelude.html#v:readMay
02:52:36 <jsomedon> novum: yes weechat is my irc client and I guess the plugin you mentioned auto"correct" username mention into emoji
02:52:51 <dansho> boxscape: thanks! that worked
02:54:05 <maerwald> lortabac: I would say if you are confused only once, then it doesn't qualify as "unexpected behavior" ;)
02:55:15 <lortabac> maerwald: :) it's still a little harder to use than a print statement in Python
03:09:13 <tdammers> maerwald: yes
03:21:12 <syd> Does anyone here know any of the details in `text`?I'm having the weirdest problem:Data.Text.split (== \n) "\55810"["\65533"]
03:21:24 <syd> that copy-pasting went wrong
03:21:40 <syd> Data.Text.split (== '\n') "\55810"
03:21:44 <syd> ["\65533"]
03:24:32 <tdammers> syd: '\55810' takes more than one code point, and Text can only handle individual code points
03:24:42 <syd> WAT
03:24:44 <tdammers> @let import Data.Text.Encoding
03:24:45 <lambdabot>  Defined.
03:24:47 <tdammers> @let import Data.Text
03:24:48 <lambdabot>  Defined.
03:24:59 <tdammers> encodeUtf8 (pack "\55810")
03:25:04 <tdammers> > encodeUtf8 (pack "\55810")
03:25:06 <lambdabot>  "\239\191\189"
03:25:18 <phadej> "\55810" i.e. DA02 is high surrogate
03:25:26 <phadej> it's not valid utf8 character
03:26:07 <phadej> > "\55810" :: Text
03:26:08 <lambdabot>  error:
03:26:08 <lambdabot>      • Couldn't match expected type ‘Text’ with actual type ‘[Char]’
03:26:08 <lambdabot>      • In the expression: "\55810" :: Text
03:26:13 <phadej> > pack "\55810" :: Text
03:26:14 <lambdabot>  "\65533"
03:26:15 <tdammers> > pack "\55810"
03:26:17 <lambdabot>  "\65533"
03:26:25 <phadej> so it's replaced already in fromString
03:26:33 <syd> > "\55810" :: Text
03:26:35 <lambdabot>  error:
03:26:35 <lambdabot>      • Couldn't match expected type ‘Text’ with actual type ‘[Char]’
03:26:35 <lambdabot>      • In the expression: "\55810" :: Text
03:26:36 <tdammers> right, haha
03:27:12 <tdammers> so basically what happens is you're passing an invalid value, but the way Text.pack is implemented, it puts a placeholder instead of erroring out
03:27:24 <tdammers> (and btw., UTF8 actually doesn't have anything to do with it)
03:27:49 <phadej> (i'm sloppy with terms, except that it's high surrogate)
03:28:04 <tdammers> String is a list of encoding-agnostic 32-bit code points ("Char"), Text uses UTF-16 internally and exposes an encoding-agnostic API externally
03:28:31 <tdammers> if you squint a lot, you could call String "UTF-32", but it's a linked list, so it's really not
03:28:50 <phadej> there was a debate to remove surrogates from Char range as well, but IIRC something will break
03:29:01 <syd> so wait
03:29:01 <phadej> > '\55810'
03:29:03 <lambdabot>  '\55810'
03:29:06 <syd> `T.pack` and `T.unpack` are not inverses
03:29:08 <phadej> morally shouldn't work
03:29:18 <EvanR> "remove" surrogates?
03:29:22 <EvanR> sounds expensive
03:29:31 <tdammers> Char is morally a unicode code point, but technically it's just a redressed Int
03:29:38 <syd> > T.unpack $ T.pack "\55810""\65533"
03:29:39 <tdammers> (or Word32, more like)
03:29:40 <lambdabot>  error:
03:29:40 <lambdabot>      Not in scope: ‘T.unpack’
03:29:40 <lambdabot>      Perhaps you meant ‘BS.unpack’ (imported from Data.ByteString)
03:29:42 <syd> > T.unpack $ T.pack "\55810"
03:29:44 <lambdabot>  error:
03:29:44 <lambdabot>      Not in scope: ‘T.unpack’
03:29:44 <lambdabot>      Perhaps you meant ‘BS.unpack’ (imported from Data.ByteString)
03:29:49 <syd> "\65533"
03:29:51 <syd> fun
03:29:57 <syd> T.unpack and `T.pack` are not inverses
03:30:04 <EvanR> yes
03:30:13 <EvanR> thanks to the utf16
03:30:14 <phadej> https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates
03:30:18 <phadej> well, to UCS
03:30:19 <tdammers> unpack . pack $ "\55810"
03:30:23 <tdammers> > unpack . pack $ "\55810"
03:30:26 <lambdabot>  "\65533"
03:30:28 <tdammers> see
03:30:36 <tdammers> oh you just did that
03:30:40 * tdammers will see himself out
03:30:55 <EvanR> so if text switches to utf in the future, that part will likely change behavior
03:30:58 <EvanR> to ????
03:31:04 <EvanR> utf8
03:31:25 <EvanR> but no one relies on it right? :)
03:31:32 <phadej> no, that won't change
03:31:36 <phadej> it will still work the same
03:31:51 <EvanR> that'll be annoying to implement
03:32:04 <phadej> implement what?
03:32:14 <syd> is there no `safePack` 
03:32:15 <syd> ?
03:32:24 <syd> https://github.com/haskell/text/issues/266, for reference
03:32:25 <EvanR> what's the right way to respond to surrogates
03:32:51 <phadej> the problem is that surrogates are not valid Char values
03:33:03 <phadej> so [Char] is not the same as "Text"
03:33:09 <phadej> very very strictly speaking
03:33:20 <EvanR> yeah, for some value of valid
03:34:02 <phadej> as Unicode defines them. "Isolated surrogate code points have no general interpretation; consequently, no character code charts or names lists are provided for this range. "
03:34:02 <EvanR> yet most string implementations allow it
03:34:18 <phadej> well, that's the problem, due compatibility neither Haskell can do the right thing
03:34:20 <EvanR> unless they are based on utf8 
03:34:43 <EvanR> or utf16
03:35:12 <phadej> Surrogates can be forbidden from being Char value
03:35:13 <phadej> s
03:35:29 <phadej> it's just too big hill for a single person to climb
03:35:40 <EvanR> by placing checkpoints and filters everywhere?
03:36:08 <EvanR> seems better to leave them semantically invalid and steer clear like division by zero
03:36:17 <phadej> one could start by making a compile-time error on '\55810'
03:36:38 <phadej> (or start with a warning)
03:36:47 <EvanR> theres no compile time error for chr (expression computing to that number)
03:36:58 <phadej> > chr maxBound
03:37:00 <lambdabot>  *Exception: Prelude.chr: bad argument: 9223372036854775807
03:37:06 <phadej> no difference
03:37:14 <EvanR> yeah extra checks
03:37:18 <dminuoso> Or in the spirit of OverloadedStrings simply ignore it, give you bottom or perhaps just convert it into some other value?
03:37:29 <EvanR> bottom please
03:37:31 <phadej> dminuoso: if you  have read the conversation, Text already converts them
03:37:52 <EvanR> secretly swapping chars out from under you sucks
03:37:53 <phadej> bottoming would break things (not 100% sure though)
03:38:01 <phadej> well, the point is, it's not a char
03:38:03 <phadej> :)
03:38:08 <dminuoso> phadej: Well Im simply hinting at some IsString instances being particularly broken.
03:38:11 <EvanR> to me Char is an Int
03:38:21 <EvanR> with a smart ctor
03:38:26 <syd> Even more fun
03:38:30 <syd> if you try to print that character
03:38:32 <phadej> EvanR: it's not a full range.
03:38:34 <syd> <stdout>: commitBuffer: invalid argumen     
03:39:01 <phadej> > ord maxBound
03:39:03 <lambdabot>  1114111
03:39:06 <dminuoso> phadej: Ah interesting. I was actually thinking about bytestring doing similar things, but didn't realize text did the same.
03:39:12 <EvanR> who invented the character set, have them fired immediately
03:39:20 <phadej> EvanR: :)
03:39:38 <syd> also fun:
03:39:47 <syd>        expected: "\535552"
03:39:47 <syd>         but got: "\541211"
03:39:52 <syd> huh what
03:40:04 <syd>        expected: "\541211"
03:40:08 <syd>         but got: "\541211"
03:40:12 <syd> there you go
03:40:19 <EvanR> we worship these technologies out of fear that something else may attempt to replace them and make it even worse
03:41:15 <syd> fun stuff
03:41:20 <syd> this is the new `NaN` in my life
03:41:24 <syd> I'm gonna have some fun with this
03:41:35 <EvanR> NaC
03:41:59 <syd> he he he he
03:46:46 <syd> thanks peeps!
03:52:26 <syd> wait a second
03:52:32 <syd> that means that you can't serialise a string via JSON
03:52:54 <EvanR> js has the same issues
03:53:33 <dminuoso> syd: "a string", depending on what you exactly mean by the word string.
03:53:37 <dminuoso> That word is highly ambiguous..
03:53:55 <EvanR> esp in haskell
03:54:03 <EvanR> but i wish it were not
03:54:47 <syd> I mean `String` :)
03:54:48 <dminuoso> syd: Also fun fact, the way JSON is specified, `deserialize . serialize` is not `id/pure` because of the way numbers are serialized.
03:55:17 <syd> Yes I already opened an issue about that: https://github.com/bos/aeson/issues/679
03:56:11 <syd> man, this breaks so much of my stuff
03:56:27 <syd> (I feel sorry for whomever has the username "so" :p)
03:58:20 <syd> https://github.com/bos/aeson/issues/731 for reference
03:58:24 <boxscape> Thinking about whether Text would be a category theoretical functor, but it looks like they have to map *every* X in the original category to an F(X). Would it work if you looked at the subcategory of Hask that only contains Char?
03:59:03 <EvanR> i.e. it maps Char to Char
03:59:08 <ski> (and which morphisms on `Char' ?)
03:59:14 <mniip> so its a monoid homomorphism
03:59:19 <mniip> from End(Char) to End(Text)
03:59:40 <boxscape> ski all the Char -> Char morphisms?
03:59:54 <ski> mhm, full subcategory
04:01:00 * hackage constraints-deriving 1.1.1.0 - Manipulating constraints and deriving class instances programmatically.  https://hackage.haskell.org/package/constraints-deriving-1.1.1.0 (achirkin)
04:38:44 <EvanR> haskell's desiners chose purity as a consequence of laziness, if side effects were allowed in arbitrarily lazy code the result would be chaos. <--- Who is responsible for letting this esoteric programming language idea go to waste
04:39:25 <EvanR> lazy unlambda or something
04:46:49 * ski . o O ( <https://tromp.github.io/cl/lazy-k.html> )
04:53:41 <maerwald> EvanR: an indication that reasoning about evaluation in lazy programs is hard ;)
04:53:42 <jsomedon> is indention in haskell purely for look or it's part of the grammar?
04:54:38 <syd> jsomedon, indentation can change scope and semantics. Does that answer your question?
04:54:41 <merijn> jsomedon: If you don't use ; and {} then it's important for semantics, yes
04:54:46 <jsomedon> oh
04:55:12 <merijn> syd: Not technically, as layout isn't indentation based, but column based
04:55:33 <jsomedon> I guess that's why, I typed some multiline code in ghci and if I messup with indention it throws me error
04:55:34 <syd> if you allow for name shadowing (yes by default), then two extra spaces can change the resul
04:55:56 <syd> merijn: Why does that matter for what I said?
04:55:58 <merijn> jsomedon: ghci doesn't really handle multiline code anyway, unless you do a bunch of stuff
04:56:21 <syd> jsomedon you can use `{:` to open and `:}` to close multiline things
04:56:35 <merijn> syd: I meant that code that is valid Haskell layout isn't necessarily valid if you assumed indentation based syntax
04:57:05 <syd> oh you mean because of tabs?
04:57:50 <jsomedon> merijn: syd: so heres what I did, :set +m, then first line is function = do var <- action, second line starts right from the beginning of the line without indenting to the collumn after where do is on first line
04:58:08 <merijn> syd: Well, also because layout rules are only concerned with "is this indented, less or equal than the previous token", so you are free to add redundant spacing when line breaking continuations of long lines
04:58:26 <syd> merijn: got it, thanks
04:58:40 <syd> jsomedon: ah, yeah that can be messed up in ghci
04:58:46 <syd> use tests for testing, not ghci :)
04:58:55 <jsomedon> what is tests?
04:59:17 <syd> I mean, write a test suite to test your code
04:59:20 <syd> don't use ghci to test your code
04:59:21 <jsomedon> ah
04:59:27 <jsomedon> got you
05:00:13 <jsomedon> I am still trying to learn the langauge so I spend most time on ghci trying some code haha
05:00:44 <syd> jsomedon, if you want to learn about testing, you can always ask me questons
05:00:48 <ski> to write more substantive tests, you can write them in a file. simple tests are fine in the interactor
05:01:11 <syd> ski: I definitely disagree. tests shouldn't be a manual interaction
05:01:25 <syd> but if you're learning, that's not testing code I guess
05:01:26 <ski> it depends on whether it's tests you want to keep or not
05:01:56 <jsomedon> what library do you usually use when doing test in haskell?
05:02:15 <jsomedon> ski hello 🎿
05:02:37 <ski> jsomedon : i usually would write `let function x = do var <- action; ..x..var..', in the interactor, using `;' (and sometimes `{',`}'), rather than linebreaks
05:02:47 <syd> jsomedon: `hspec`, `QuickCheck` and the validity packages
05:03:04 <syd> https://github.com/hspec/hspec
05:03:14 <syd> https://github.com/nick8325/quickcheck
05:03:21 <syd> https://github.com/NorfairKing/validity
05:03:34 <syd> the last two are for property tests
05:03:40 <sshine> hey syd. I like your work. :)
05:03:52 <syd> See https://www.fpcomplete.com/blog/quickcheck-hedgehog-validity for an overview of property testing
05:03:56 <syd> sshine: Thanks :D
05:04:05 <jsomedon> ski : by { and } you mean the :{ and :} that enables me to write multiple line in ghci?
05:04:06 <ski> (by "tests" i mean any evaluation of any expression (or execution of I/O action), that isn't part of the `main' program. including simple things to try out in the interactor, and also test cases, property testing, &c.)
05:04:10 <ski> jsomedon : no
05:05:13 <sshine> syd, I've been looking forward to use 'validity' for a while, and now it's finally in a roadmap for one pet project.
05:05:23 <syd> cool, let me know if I can help ^^
05:05:42 <syd> I'm not usually on IRC, so feel free to send emails
05:06:00 <sshine> sure. I think it's pretty well-documented, though. :)
05:06:07 <jsomedon> thanks syd I am slowly reading them now
05:06:23 <ski> syd : so by "tests" i was explicitly referring also to "manual interaction" things. using that reading of "test", your "tests shouldn't be a manual interaction" becomes "you should never do manual interaction" ..
05:06:41 <syd> yeah and I mostly agree with that last statement too
05:06:57 * ski guesses syd never fires up the interactor, then
05:07:36 <syd> yeah I use `stack test --file-watch` as my feedback loop
05:07:52 * ski nods
05:08:09 <syd> I've tried using `ghcid` but that doesn't usually work well with TH, which I need for yesod templates
05:10:51 <__monty__> If I'm not mistaken you can specify cabal test as the interpreter for ghcid.
05:16:42 <svipal> is there any way I can just keep a pointer to an undefined type in haskell and just do C Stuff on it without ever needing to clarify what it is haskell wise ?
05:16:58 <svipal> I'm no C expert at all.
05:17:02 <merijn> svipal: Sure, see Ptr/ForeignPtr
05:17:54 <merijn> svipal: "data MyFMODHandle" (note: no constructors to make them) and then just use "Ptr MyFMODHandle" inside Haskell
05:32:22 <jsomedon> syd: still reading the post but looks like the main difference between doing property test and unit test is that property test setup rules that cover cases as much as it can on higher level while unit test simply setup each case individually?
05:32:47 <ski> syd's gone
05:32:51 <jsomedon> oh
05:33:49 <ski> but basically, yes. property testing generate random inputs, and check some property involving operations on those inputs
05:34:49 <tdammers> IMO, "property test" and "unit test" are orthogonal
05:35:25 <__monty__> Then what would you call a test where you have to prescribe every step and check?
05:36:35 <tdammers> an automated test
05:36:42 <maerwald> property tests are unit tests
05:37:18 <tdammers> point is, "unit test" says something about the thing you're testing, its granularity and isolation level, but not about the specific testing strategy you employ
05:37:26 <tdammers> just that the thing you're testing is a unit
05:37:46 <tdammers> you can do that with quickcheck-style property checks, or with traditional test cases
05:38:09 <__monty__> But unit's too vague a term to be useful to describe the what because you can consider almost anything a unit.
05:38:17 <tdammers> of course
05:38:56 <tdammers> the point of calling it "unit test" is not to tell people the exact scope though, just that you intend to test a particular subset of the codebase in isolation, along some kind of API boundary
05:39:14 <__monty__> As opposed to integration tests?
05:39:26 <tdammers> integration tests, and simulation tests
05:39:28 <maerwald> yeah, which is why anything QuickCheck related is basically a unit test
05:39:54 <tdammers> although personally I have never really bought into the idea of integration tests, especially not in a language like Haskell
05:40:24 <tdammers> because the purpose of an integration test is to verify that certain ways of gluing things together are valid, but the type system already does that for you 99.9% of the time
05:40:43 <maerwald> tdammers: not if you have frontend-backend architecture
05:41:03 <dibblego> integration test ~ "I didn't use functions, oh well"
05:41:19 <boxscape> you can also have integration tests between multiple separate projects that aren't necessarily written in the same language(s)
05:41:31 <__monty__> So you unit test each part of an API, then integration test the boundary or is it just testing a bigger "unit" or is it a "unit" where the bounds go past your own code? And what's a simulation test? Mocking some users of your API? What's the difference with an integration test?
05:43:30 * hackage streamly-cassava 0.1.1.0 - CSV streaming support via cassava for the streamly ecosystem  https://hackage.haskell.org/package/streamly-cassava-0.1.1.0 (rwarfield)
05:45:43 <cpressey> __monty__: I agree that the word "unit" itself is not specific, but I think when people use it in the phrase "unit test", it has an identifiable meaning close to "smallest reasonably testable unit".
05:48:28 <cpressey> integration test -> test that the loosely-coupled modules of your system function do what you expect when they're put together.  simulation test -> test that the system does what you expect under a simulation of the conditions you expect it to run under.
05:50:06 <cpressey> s/function//
06:01:54 <tdammers> well, the whole unit / integration / simulation system suggests exactly three levels - you have self-contained "units", which you combine into components, and then those components together form the entire program
06:02:48 <tdammers> but the reality is that you usually have way more layers than that, and to each layer, the moving parts from the layer below it are the "units", the way the layer combines them are "integration", and the layer's API that gets exposed to layers up the abstraction tower are "simulation"
06:03:09 <tdammers> it doesn't even matter whether you use modules or services or whatever to draw your boundaries here
06:34:30 * hackage units 2.4.1.2 - A domain-specific type system for dimensional analysis  https://hackage.haskell.org/package/units-2.4.1.2 (RichardEisenberg)
06:51:37 <chintan> can anyone explain what does this sentence means about curried function "Doing max 4 5 first creates a function that takes a parameter and returns either 4 or that parameter, depending on which is bigger."
06:51:51 <chintan> what does it mean when it says it returns 4  or that parameter
06:52:04 <chintan> how can you compare between a parameter and a number?
06:52:20 <jsomedon> I think that means max 4 is a function
06:52:33 <jsomedon> (max 4) is a function that takes another param
06:52:35 <boxscape> @src max
06:52:35 <lambdabot> max x y = if x <= y then y else x
06:52:40 <jsomedon> which is 5 in your case
06:53:12 <boxscape> `max 4` produces a function that you could define as if 4 <= y then y else 4
06:53:33 <boxscape> and it takes y as parameter
06:53:51 <jgt1> :t max
06:53:52 <lambdabot> Ord a => a -> a -> a
06:53:56 <jgt1> :t max 4
06:53:57 <lambdabot> (Ord a, Num a) => a -> a
06:54:03 <jgt1> :t max 4 5
06:54:05 <lambdabot> (Ord a, Num a) => a
06:54:26 <jgt> chintan: notice how the type changes when you apply the arguments?
06:55:31 <chintan> so max 4 5 doesn't take any argument, its the max 4 which takes an argument?
06:55:36 <hyperisco> I'll make the pedantic point about arguments versus parameters, and say that quote should have been reworded with "argument" rather than "parameter"
06:56:14 <jgt> chintan: well yeah. And why does (max 4) take one argument?
06:56:20 <hyperisco> Functions *have* parameters and they *take* arguments.
06:57:49 <jgt> chintan: answer: because `max` takes two arguments. When you so `max 4`, it's `max` applied to one argument
06:57:52 <boxscape> maybe easier to understand if you say that they have parameters in their definition, but you call them with arguments?
06:57:56 <boxscape> hyperisco
06:57:59 <jgt> so there's just one more argument to apply it to
06:58:23 <jsomedon> chintan: right, if its in javascript, function max(x) { return function (y) {return max_between_x_and_y}}
06:58:26 <jgt> I'm not sure the confusion is around whether we use the term 'parameter' or 'argument'
06:59:10 <jsomedon> chintan: so haskell code `max 4 5` is like js code `max(4)(5)`
06:59:18 <Ariakenom> hyperisco: They're used differently I think. I've heard formal parameters and actual parameters too.
06:59:43 <hyperisco> The difference between "return parameter" and "return argument" I think is an intentional versus extensional difference
07:00:02 <jsomedon> guys I have another question.. is main function always main::IO ()
07:00:08 <jgt> jsomedon: yes
07:00:14 <Ariakenom> that's what I was told in some class at some point
07:00:15 <merijn> Well, technically no
07:00:29 <merijn> main has type "IO a" for any 'a' you choose
07:00:39 <merijn> But practically, yes it'll almost always be "IO ()"
07:00:50 <boxscape> Oh is that so you're not reliant on Prelude?
07:01:14 <merijn> boxscape: It so that other compiler are free to, potentially allow smarter exit codes
07:01:24 <boxscape> I see
07:01:32 <merijn> boxscape: Also means you can reuse existing "IO Foo" actions as "main"
07:01:34 <jsomedon> jgt: merijn: alright good to know thanks
07:01:47 <merijn> jsomedon: Also, pedantic sidenote: "IO ()" is not a function :)
07:01:58 <jsomedon> ...
07:02:05 <LPTK> anyone knows why this is rejected as a parse error by ghci?: `do { let x = 1; return x }`
07:02:08 <hyperisco> Ariakenom, professors are time capsules ;)
07:02:09 <jsomedon> merijn: so, main is not a funciton you mean?
07:02:17 <boxscape> merijn you mean it's not a function type?
07:02:30 <merijn> jsomedon: I'd normally say "main action", but yes, it's not a function
07:02:34 <jsomedon> oh
07:02:41 <jgt> merijn: I had an argument recently with someone who *insisted* that it *is* a pure function, and that the fact that it becomes an effectful action later is just some irrelevant implementation detail
07:02:43 <Ariakenom> hyperisco: indeed. I didn't put any credibility in that terminology :p
07:02:45 <merijn> boxscape: Well yes, that's kinda the definition of what a function is :)
07:02:50 <ski> if you can't pass an argument, it's not a function
07:02:58 <merijn> jgt: That someone is fairly objectively wrong :)
07:03:28 <merijn> jsomedon, jgt: Fairly relevant (and hopefully enlightening) blogpost: http://conal.net/blog/posts/everything-is-a-function-in-haskell
07:03:53 <boxscape> merijn I'd say a function is a value of a function type, i.e. main is not a function and IO () is not a function type.
07:04:32 <hyperisco> merijn, what is the objective wrongness of that claim?
07:04:33 <merijn> boxscape: yeah, that's basically what I meant (albeit somewhat sloppily formulated, because language is messy :p)
07:04:41 <boxscape> fair
07:05:12 <merijn> hyperisco: That functions are "things with function types", so things that don't have function types (like main) are pretty unambiguously "not functions"
07:05:41 <hyperisco> I thought you might be objecting to the more bold claim about purity.
07:06:05 <merijn> hyperisco: I mean, I suppose you can insist on "my definition of functions is very different from those used by everyone writing haskell or doing type theory", but if your usage contradicts common usage of most of the world that's a pretty pointless argument :)
07:07:16 <hyperisco> A context can spontaneously be assumed where "IO A" is some function semantically
07:07:31 <merijn> hyperisco: Well, "main :: IO ()" where "main" is the name that refers to a pure *expression* that gets evaluated to an effectul action is something I could agree to, but that is a rather more nuanced formulation
07:07:37 <boxscape> if there were functions with 1,2,3 and so on arguments I'd say it'd be weird to not have functions of 0 arguments as well, but since haskell only has functions of 1 argument, it's fine
07:08:20 <hyperisco> Maybe the new rule is everyone must say -> instead of "function" when they mean ->
07:09:01 <jgt> merijn: I don't think that description is constructive though
07:09:13 <boxscape> I wish I lived in a ->ing society
07:09:15 <merijn> jgt: Which one?
07:09:15 <jsomedon> so... it's imposisble to write a function with 0 arg in haskell?
07:09:17 <dminuoso> jsomedon: It is useful to note that Haskell differtiates between "function" and "procedure". It's languages like JavaScript that have abused the term "function" to refer to something that is most definitely not a function in the traditional sense.
07:09:21 <dminuoso> jsomedon: Correct.
07:09:21 <merijn> jsomedon: Yes
07:09:25 <jsomedon> ok
07:09:28 <dminuoso> jsomedon: A function is a mapping of values, nothing more.
07:09:39 <dminuoso> jsomedon: It's a way of asking "whats the corresponding value at"
07:09:40 <ski> jsomedon : all Haskell functions take exactly one argument
07:09:50 <e> you could make a reasonable case that values are nullary functions
07:09:53 <jgt> merijn: that all IO in Haskell is pure, and the fact that it turns into something effectful at the end is irrelevant
07:10:09 <merijn> e: See the blogpost I linked slightly earlier :)
07:10:27 <merijn> jgt: IO is effectful, but not *side-effectful*
07:10:29 <jsomedon> dminuoso: mappinf of values hmm that's very math-y I like that
07:10:36 <hyperisco> jgt, that also has to be true though, else you're breaking rules
07:11:02 <merijn> jsomedon: Consider this: Let's assume a hypothetical function of 0 arguments that returns 5. Why bother having that, you can just write 5
07:11:06 <ski> it's possible to encode "multiple-argument" functions in Haskell. in fact there's two different common encodings, sometimes called "curried style" vs. "tupled style"
07:11:07 <hyperisco> Maybe it is not constructive insofar as it goes without saying. Except, I don't think it does go without saying :P
07:11:17 <Ariakenom> e: did you look at the link? http://conal.net/blog/posts/everything-is-a-function-in-haskell
07:11:24 <e> i am reading it now
07:11:35 <Ariakenom> sry I am slow
07:11:39 <merijn> jsomedon: If your response is: "Well, what if it doesn't always return 5?" then the next question is: well, how would it return something different while still being pure?
07:12:25 <jgt> merijn: hyperisco: context: https://lobste.rs/s/xt0p2l/how_i_decide_between_many_programming#c_fd5in8
07:12:31 <merijn> jsomedon: Essentially, a 0 argument *pure* function is kinda pointless, because you can (by definition) just use it's result instead :)
07:12:45 <e> i think this article is a bit silly, but i don't have much energy to argue about it
07:12:56 <dminuoso> jsomedon: Formally you could do something close to a 0-argument function, namely a function from unit.
07:13:07 <hyperisco> jgt, I am having a hard time controlling my emotions to read much of that.
07:13:18 <jsomedon> merijn: so in other lang, I do things like that to defer execution, but then I guess in haskell it's lazy evaluated? so I don't need to defer execution by wrapping code into a function?
07:13:28 <Ariakenom> would it make sense to say that being pure and being effectful (as opposed to side-effectful) isn't in any way an issue.
07:13:30 <merijn> jsomedon: Right
07:13:37 <dminuoso> jsomedon: A value of type unit is information-less because it can have only one single value. So a function mapping the unit type to something else, could be used to mimic a 0-argument function.
07:14:16 <dminuoso> jsomedon: Note that when you say "function" there, be sure not to mix up the word "function" and "procedure/routine"
07:14:35 <jsomedon> dminuoso: yeah right
07:14:42 <dminuoso> Most popular languages use the word "function" when they really should be saying "procedure" instead.
07:15:04 <jsomedon> dminuoso: the side effect
07:15:08 <dminuoso> And they use the term "pure function" to refer to what is originally called "functoins"
07:15:33 <dminuoso> So while JavaScript folks differentiate between "pure functions" and "functions", we'd rather talk about "procedures/actions" and "functions"
07:16:22 <merijn> The abstraction that captures how you'd normally use procedures is what IO describes/implements
07:16:45 <hyperisco> If people are saying things like "pure functions heat up my CPU" I don't even know where to begin
07:16:57 <hyperisco> This is like saying math wears down my pencil
07:17:28 <chintan> can anyone explain what is partially applied functions mean in haskell?
07:17:40 <merijn> i.e. "foo :: IO Int" is "some IO that (eventually) produces an 'Int'", but repeated uses of that value are allowed to produce different results at different uses
07:17:51 <dminuoso> chintan: The notion of partially applied function requires the concept of multi-argument functions, where some arguments have been applied already but not all.
07:18:26 <jsomedon> is partially applied even a valid saying in the sense of haskell functions really are single arg?
07:18:28 <dminuoso> chintan: Since we don't have multi-argument functions, we don't have partial applications directly. However, because we can encode multi-argument functions in currying style, you get the same behavior by simply applying one argument at a type.
07:18:31 <chintan> dminuoso can you explain it with example?
07:18:39 <hyperisco> chintan, first you need a sloppy understanding of functions, then you can post hoc fix it by talking about "partially applied"
07:18:48 <merijn> jsomedon: I think you can make a very strong case that the notion of "partially applied" is nonsense in Haskell
07:18:57 <jgt> chintan: why didn't you like my example earlier?
07:19:03 <jgt> :t max
07:19:04 <lambdabot> Ord a => a -> a -> a
07:19:08 <jgt> :t max 5
07:19:09 <lambdabot> (Ord a, Num a) => a -> a
07:19:19 <hyperisco> chintan, simpler is to just start with the correct understanding, which is that -> is a function which takes one argument and returns one result. Simple as that.
07:19:26 * dminuoso thinks that such a polymorphic example might create unnecessary confusion
07:19:27 <jgt> let maximumOfFiveAndSomeOtherNumber = max 5
07:19:50 <jsomedon> merijn: uhm so you mean the saying is nonsense?
07:19:56 <dminuoso> jsomedon: I suppose it depends on your mind model you are employing.
07:20:04 <chintan> jgt i thought curried and partially applied functions are different 
07:20:23 <merijn> jsomedon: I mean, people often use the term "partially applied" to mean that the result of a function is itself a function. But consider "(\x -> (\y -> 5)) True" <- would this count as "partially applied" (because the result is a function) or as "fully applied" since the outer lambda takes one argument
07:20:26 <dminuoso> jsomedon: For example I frequently think in terms of "how many arguments does this function have" in Haskell, despite knowing very well that we don't have multi-argument functions.
07:20:43 <dminuoso> jsomedon: But I frequently switch mind models to fit my needs..
07:20:51 <jsomedon> dminuoso: haha
07:20:57 <merijn> jsomedon: So the term has some valid usage in sloppy human communication, but fundamentally I think it's meaningless
07:21:07 <jsomedon> merijn: got you
07:22:02 <dminuoso> jsomedon: For example:
07:22:28 <dminuoso> jsomedon: (1 + 5) could be thought of creating an adder function and immediately consuming that adder function... but I think its easier to think of (+) as a binary operating acting on two numbers..
07:22:38 <dminuoso> But ymmv.
07:23:35 <dminuoso> I mean Haskell even allows us to write `f x y z = ...`, so arguing too strongly that "all functions take one argument" is not so helpful, because the language goes a long way of baking multi-argument syntax in.
07:25:26 <tdammers> the handwaive argument is that "f x y z" is syntax for repeated function application
07:25:47 <tdammers> "f applied to x applied to y applied to z"
07:26:21 <Ariakenom> it's analoguous to pattern matching
07:26:56 <hyperisco> dminuoso, it prepares for languages where  f x y z = …  is not the same as  f = \x -> \y -> \z -> …  anyhow
07:27:14 <tdammers> I do agree though that reasoning in terms of n-ary functions is often useful and somewhat valid
07:27:36 <tdammers> similar to how we can sometimes handwaive do-desugaring and reason about monadic code in a pseudo-imperative fashion
07:28:11 <dminuoso> Plus, the Haskell report itself mentions "having multiple arguments" all over the place, and even gives us semantic difference between `f x y = ...` and `f = \x -> \y` if x is a suitable pattern..
07:28:21 <Ariakenom> It seems the sloppiness can be resolved maybe. A 2-argument function is a->b->c. But a->(b->c) is a single argument function too.
07:28:39 <boxscape> dminuoso what makes a pattern suitable?
07:28:46 <dminuoso> boxscape: If its a refutable pattern.
07:28:51 <Ariakenom> So functions with several arguments works fine as precise terminology.
07:28:51 <boxscape> I see
07:29:27 <boxscape> Ah right because `f x = ...` kind of has a case expression built into it
07:29:28 <maerwald> I would also argue that the "all functions take one argument" is an implementation detail.
07:29:41 <dminuoso> boxscape: No
07:29:44 <boxscape> oh
07:29:52 <boxscape> but doesn't that also make it semantically different?
07:29:53 <dminuoso> boxscape: The relevant reason is that WHNF stops at.. what? ;)
07:30:06 <boxscape> at constructors?
07:30:07 <Ariakenom> You just have to see that a n-ary function is also a k argument function where k<=n.
07:30:15 <dminuoso> boxscape: be more specific.
07:30:19 <boxscape> uhm
07:30:39 <boxscape> I'm not sure tbh
07:30:51 <dminuoso> boxscape: data constructor, builtin functions and lambda abstractions
07:30:59 <boxscape> ah, okay
07:31:06 <dminuoso> (by builtin functions I mean partially applied ones)
07:31:37 <dminuoso> % let f = \() -> \x -> () in f undefined `seq` ()
07:31:37 <yahb> dminuoso: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:268:30 in interactive:Ghci86
07:31:46 <dminuoso> % let f () x = () in f undefined `seq` ()
07:31:46 <yahb> dminuoso: ()
07:32:52 <boxscape> okay I still can't really see why that's happening to be honest
07:34:19 <boxscape> or..
07:34:22 <boxscape> kind of I guess
07:34:42 <boxscape> in the first case it tries to match on () to produce the function \x -> ()
07:34:57 <boxscape> but in the second one it waits with trying to match until all arguments are given?
07:35:02 <dminuoso> boxscape: Right.
07:35:05 <boxscape> okay
07:35:17 <dminuoso> boxscape: Did you notice how you have to talk about "all arguments"? ;)
07:35:23 <boxscape> yeah
07:35:40 <maerwald> doesn't that, btw, violate the standard?
07:35:56 <merijn> maerwald: What does?
07:36:35 <maerwald> hmm, I remembered this https://github.com/quchen/articles/blob/master/fbut.md#f-x---is-not-f--x---
07:36:50 <jsomedon> any benefit would real n-ary brings me as a programmer rather than look-like-n-ary-on-surface-but-really-unary?
07:37:25 <jsomedon> is unary correct term? I mean single arg function
07:38:02 <jsomedon> except I can write less parens yes that's good
07:38:42 <tdammers> yes, unary is the right word
07:39:07 <tdammers> real n-ary may be easier to implement on the compiler side of things
07:39:36 <merijn> jsomedon: Basically "zero", because you can always implement "n-ary functions" as functions that take a tuple of N arguments
07:39:39 <tdammers> (and parens are just a cosmetic issue)
07:39:58 <merijn> jsomedon: Which is usually how theoretical CS works models functions in, say, C/python-like languages
07:40:15 <jsomedon> ok
07:40:42 <jsomedon> and I can always consider a tuple is a single value which happens to contain n args
07:40:44 <tdammers> it is also how I implemented Python-style procedure calls in Ginger (except I use lists, not tuples, in order to also model variadic procedures)
07:40:45 <jsomedon> ?
07:40:51 <merijn> jsomedon: At least, over the past 10 or so years of Haskell I've never had a reason to miss N-ary functions, and *lots* of reasons to love the "everything takes one argument" approach :)
07:40:55 <tdammers> a tuple is a single value, yes
07:41:07 <Ariakenom> jsomedon: less parens with or without non-unary dunctions?
07:41:42 <syd> If you just look at the kind of mess you have to wade through to make it happen, you'll quickly see why you don't want to do it: https://cs-syd.eu/posts/2016-04-09-typesafe-polyvariadic-functions-in-haskell
07:41:54 <jsomedon> tdammers: at least it was how i made peace between math definiton: function is a mapping of single value to single value and the real world example of n-ary functions I saw in C python etc
07:42:16 <dminuoso> jsomedon: again. in C or python you do not have functions. you have procedures
07:42:19 <jsomedon> tdammers: always imagined deep inside the machine, there is a magical () value grouping them
07:42:20 <ski> <jsomedon> syd: still reading the post but looks like the main difference between doing property test and unit test is that property test setup rules that cover cases as much as it can on higher level while unit test simply setup each case individually?
07:42:34 <tdammers> jsomedon: if you want a math metaphor, consider how you can have mathematical functions whose arguments aren't scalars but, say, vectors, or even matrices
07:42:48 <syd> ski: In effect, yes
07:42:57 <syd> in theory the difference is that a property test takes an argument and a unit test doesn't
07:43:00 <jsomedon> syd: ah youre back
07:43:16 <dminuoso> 16:41:57  jsomedon | tdammers: always imagined deep inside the machine, there is a magical () value grouping them
07:43:18 <syd> but there are many more benefits to property tests
07:43:23 <dminuoso> jsomedon: By the way, we can do the same in Haskell too!
07:43:35 <jsomedon> dminuoso: ah yeah 
07:43:42 <dminuoso> jsomedon: `f (1,'c', foo)` looks not much different from `f(1,'c', foo)`, does it? :)
07:43:44 <syd> ski: property tests allow you to find unknown unknowns.
07:43:54 <ski> syd : you should answer jsomedon, not me
07:44:00 <syd> oh, whoops
07:44:04 <dminuoso> jsomedon: Except in currying style we get to write even less, namely `f 1 'c' foo`
07:44:10 <tdammers> it's a bit unfortunate that in the Haskell ecosystem, "unit test" is linked to libraries like HUnit, which aren't really so much about unit testing per se, but rather just about classic automated fixture-based tests
07:44:15 <dminuoso> jsomedon: And we can "stop prematurely" and not apply the rest.
07:44:26 <dminuoso> And obtain a function taking the remainig arguments.
07:44:44 <dminuoso> So we get less clutter, and the behavior partial application for free.
07:44:56 <tdammers> HUnit works absolutely fine for all sorts of tests - unit, integration, simulation, regression, you can probably even coerce it into doing user acceptance tests by taking CLI input or something
07:45:29 <jsomedon> dminuoso: which i think why chintan was confused with currying and partial app in haskell
07:45:44 <dm9> Is there a best practices guide somewhere on what belongs in a `cabal.project` file and what in the individual `xyz.cabal` files (e.g. ghc-options)
07:45:50 <Zemyla> So let's say I have the following type:
07:46:32 <jsomedon> dminuoso: so basically unary in haskell makes it more flexible, free currying, looks like partial app syntax
07:46:36 <jsomedon> dminuoso:/
07:46:41 <jsomedon> ?
07:46:45 <merijn> dm9: cabal files are what you distribute and should contain everything needed to build/use a package
07:47:00 <Zemyla> @let newtype TraversingF a = TraversingF { runTraversingF :: forall f b. Applicative f => (a -> f b) -> f (a -> b) }
07:47:02 <lambdabot>  Defined.
07:47:25 <merijn> dm9: cabal.project is mostly for *developing* packages, so it allows you to specify overrides and depend on unreleased code (which is convenient while working on new versions/bug fixes/etc.)
07:48:00 <merijn> dm9: So the answer is: cabal.project should contain the bare minimum you can get away with and/or things that are only sensible for local development
07:48:06 <dminuoso> jsomedon: Yup. You get all these niceties for free - the only downside is increased implementation complexity.
07:48:16 <dminuoso> jsomedon: But luckily thats something you dont need to concern yourself with.
07:48:33 <Zemyla> Having a value of type "TraversingF a" basically means you know all the possible values in type "a" as well as the order they go in.
07:48:36 <maerwald> merijn: for local development there is cabal.project.local
07:48:37 <boxscape> possibly another downside might be harder to understand error messages?
07:48:51 <boxscape> also harder to do java-like overloading of functions
07:49:03 <dminuoso> boxscape: Indeed, though GHC has good heuristics for detecting "not applied to enough arguments"
07:49:08 <maerwald> I don't see cabal.project primarily as a development file
07:49:09 <merijn> maerwald: cabal.project is "everyone that clones this repo to work on needs this" "cabal.project.local" is "I need this"
07:49:24 <merijn> maerwald: Well, for code that you don't plan to release on Hackage, sure
07:49:31 <maerwald> But I guess the scope is not well defined
07:49:59 <Zemyla> It kind of seems to me like if you have a TraversingF a and a TraversingF b, you should be able to construct a TraversingF (a -> b), but I'm not sure how.
07:50:18 <boxscape> though Idris does overloading IIRC, so there's that
07:50:26 <dminuoso> jsomedon: Also you get improved domain thinking. For instance, it things like `filter (>5) xs` become more expressie than `filter (\x -> x > 5) xs`
07:50:52 <dminuoso> jsomedon: Though thats actually a case of partial application because with sections you can apply to the right argument!
07:51:02 <dminuoso> (by right I mean second)
07:51:08 <dm9> merijn: maerwald so something like -threaded would go into `xyz.cabal` and `-Werror` into `cabal.project`?
07:51:21 <merijn> dm9: Right
07:51:45 <dm9> merijn: okay, thanks!
07:52:08 <boxscape> it would be kind of interesting if you could choose which arguments to partially apply by doing something like `functionOf4Args _ arg2 _ arg3` (and then you get a function of two arguments out)
07:52:26 <boxscape> s/arg3/arg4
07:52:40 <merijn> maerwald is right that there's no hard definition/scope, but the intended usage of cabal files is "completely describe package for distribution" whereas "cabal.project" is "completely describe a repository for use" (and the usual use-case would be "for development")
07:54:19 <maerwald> I guess for -Werror you could also create a cabal flag and put it into .cabal file
07:54:40 <merijn> I suppose, but I think putting it in cabal.project is nicer
07:55:32 <maerwald> does v1 actually read .project files?
07:55:37 <merijn> No
07:55:55 <maerwald> I guess it's a minor use case
07:59:07 <jsomedon> can I write some function f, so `f(g)` gives me whatever message `:t g` prints?
07:59:56 <jsomedon> because :t looks like ghci exclusive, wanna know if I can do that too
08:00:02 <jsomedon> by writting code
08:00:16 <merijn> jsomedon: Kinda, maybe, sometimes
08:00:19 <merijn> :t typeOf
08:00:20 <lambdabot> Typeable a => a -> TypeRep
08:00:29 <merijn> > typeOf 'c'
08:00:31 <lambdabot>  Char
08:00:42 <merijn> But that only works if you have a Typeable instances in scope
08:00:58 <jsomedon> typeable instance
08:01:04 <jsomedon> what is that..
08:01:15 <geekosaur> and I think still has some issues with polymorphism?
08:01:29 <merijn> jsomedon: Typeable is a typeclass that, well, implements the ability to query something's type at runtime
08:01:31 <geekosaur> the "Typeable a =>" in that type
08:01:37 <jsomedon> oh
08:02:07 <geekosaur> haskell normally erases type information after the typechecking phase, you need something to carry type information around if you want to be able to get it at runtiime
08:02:14 <jsomedon> oh
08:02:16 <geekosaur> ghci compiles stuff on the fly to get type information
08:02:25 <boxscape> % :i Typeable
08:02:27 <yahb> boxscape: class Typeable (a :: k) where; base-4.12.0.0:Data.Typeable.Internal.typeRep# :: base-4.12.0.0:Data.Typeable.Internal.TypeRep a; {-# MINIMAL typeRep# #-}; -- Defined in `base-4.12.0.0:Data.Typeable.Internal'
08:02:38 <boxscape> why does that not show any Instances?
08:02:44 <dminuoso> geekosaur: Does it actually erase that information? Is it not used at all in optimization or code generation?
08:02:59 <merijn> boxscape: Instances can no longer be defined by hand and are automatically derived by the compiler
08:03:04 <jsomedon> geekosaur: you mean, ghci doesn't erase type info that's why :t works?
08:03:19 <boxscape> merijn can you have a type without a Typeable instance?
08:03:21 <geekosaur> it's not used or necessary after the typechecker stage. there's still RuntimeRep which is used
08:03:23 <merijn> jsomedon: ":t" compiles the code you give it and during that compilation figures out the type
08:03:30 <jsomedon> merijn: oh
08:04:05 <jsomedon> I see, then it's not always possible to check type on everything
08:04:06 <geekosaur> boxscape, the compiler always generates such an instance. it may not write it to a compiled object if you don't use it
08:04:14 <merijn> jsomedon: Correct
08:04:18 <boxscape> ok
08:04:56 <geekosaur> (for those types that can have instances, at least, the compiler uses it internally)
08:05:46 <boxscape> what types can't have instances?
08:06:38 <Zemyla> Depends on what you mean by "have".
08:06:56 <geekosaur> > typeOf (+)
08:06:58 <lambdabot>  Integer -> Integer -> Integer
08:07:06 <merijn> geekosaur: 0wn by extended defaulting ;)
08:07:12 <geekosaur> it gets defaulted instead of using the proper polymorphic type
08:07:26 <Zemyla> > typeOf show
08:07:27 <merijn> > typeOf id -- maybe?
08:07:28 <lambdabot>  () -> [Char]
08:07:29 <lambdabot>  error:
08:07:29 <lambdabot>      • No instance for (Typeable a0) arising from a use of ‘typeOf’
08:07:29 <lambdabot>      • In the expression: typeOf id
08:07:36 <boxscape> Zemyla I guess my question is "Is there any expression x with a lifted type for which `typeOf x` won't work"
08:07:37 <merijn> Ha! I win!
08:07:44 <boxscape> oh nice
08:07:49 <merijn> boxscape: Anything polymorphic
08:07:55 <boxscape> ok
08:08:08 <geekosaur> here it should be able to do so, I dont think extended defaulting matters, it's that it has to monomorphize. so 'a' can't work and it invokes defaulting for (+)
08:08:37 <jsomedon> i am trying to catching up you guys boxscape and merijn , so not every type is instance of Typeable?
08:09:04 <geekosaur> "typeOf id" fails because (a -> a) for unknown a is too polymorphic
08:09:11 <merijn> jsomedon: Every monomorphic type of kind * has an isntance (afaik), but polymorphic types and types with different kinds possibly don't
08:09:48 <Zemyla> Pretty sure every value lifted into a type with DataKinds does as well.
08:12:36 <c_wraith> yeah, Typeable is fine with any kind these days, but the type needs to be monomorphic 
08:13:10 <boxscape> % > typeOf (Proxy @True)
08:13:10 <yahb> boxscape: ; <interactive>:272:1: error: parse error on input `>'
08:13:15 <boxscape> % typeOf (Proxy @True)
08:13:15 <yahb> boxscape: Proxy Bool 'True
08:13:17 <boxscape> nice
08:13:37 <boxscape> bit of a weird output though
08:13:37 <jsomedon> so monomorphic means it's like String, Int, unlike [a]/
08:13:49 <boxscape> seems to imply that Proxy has two visible arguments
08:13:52 <jsomedon> ?
08:13:59 <tabaqui2> it has no type variables and has kind *
08:14:23 <c_wraith> boxscape: that's just the way ghc prints polykinded types. first it lists all the kinds of polykinded type variables. 
08:14:26 <jsomedon> I don know what "it has kind *" mean
08:14:48 <tabaqui2> You can deal with lists of Ints, Strings, etc
08:14:48 <boxscape> c_wraith I see
08:14:51 <c_wraith> that's OK, it's not actually true here anyway. :) 
08:14:56 <tabaqui2> but not with some abstract List
08:15:00 * hackage abides 0.0.1 - Simple boolean tests to see if a value abides by certain properties  https://hackage.haskell.org/package/abides-0.0.1 (athanclark)
08:15:20 <tabaqui2> so List Int containts Ints, List a contains some a's, but List contains nothing
08:15:30 <jsomedon> yeah
08:15:34 <tabaqui2> List is incomplete as type, you need to apply it to something
08:15:38 <tabaqui2> it has kind * -> *
08:15:38 <jsomedon> right
08:15:44 <c_wraith> % > typeOf (Proxy @[]) -- tabaqui2
08:15:44 <yahb> c_wraith: ; <interactive>:274:1: error: parse error on input `>'
08:16:12 <boxscape> % typeOf (Proxy @[])
08:16:12 <yahb> boxscape: Proxy (* -> *) []
08:16:24 <c_wraith> thanks 
08:16:53 <c_wraith> tabaqui2: kind is irrelevant to typeOf. it just needs to be monomorphic 
08:17:18 <tabaqui2> I don't think that "List" is a "monorphic type"
08:17:35 <tabaqui2> *monomorphic
08:17:56 <boxscape> % :k (Proxy [])
08:17:56 <yahb> boxscape: (Proxy []) :: Type
08:18:07 <boxscape> that looks like the kind is still just * c_wraith
08:18:07 <jsomedon> just googled, so monomorephic means it works on one type?
08:18:14 <tabaqui2> and type constructors don't necessary apply to types
08:18:50 <merijn> jsomedon: polymorphic comes from "poly-" (many) and "morphic" (shaped)
08:18:57 <boxscape> I don't think you can really have a value of a type of kind (* -> *)?
08:19:08 <boxscape> so you wouldn't be able to use typeOf on one anyway?
08:19:15 <merijn> jsomedon: So the logical opposite would be "monomorphic", i.e. "mono-" (single/one)
08:19:55 <ski> @kind Proxy
08:19:56 <lambdabot> k -> *
08:20:05 <ski> `Proxy' is a polymorphic type
08:20:24 <boxscape> but not (Proxy [])
08:20:27 <boxscape> or is it?
08:20:47 <ski> @kind Proxy []
08:20:48 <lambdabot> *
08:20:53 <tabaqui2> Proxy is not a type
08:20:56 <ski> not anymore than
08:21:00 <ski> @type length ""
08:21:01 <lambdabot> Int
08:21:06 <ski> is polymorphic (it isn't)
08:21:40 <ski> (the type `[]' isn't polymorphic, though, nor is `[a]' polymorphic)
08:22:03 <ski> tabaqui2 : it has a kind
08:22:19 <tabaqui2> indeed
08:22:24 <ski> (ergo : it's a type)
08:23:05 <ski> (just as `Maybe' is a (monomorphic) type)
08:23:08 <tabaqui2> nope
08:23:23 <ski> there's two schools of terminology here
08:23:28 <tabaqui2> "it" has a kind doesn't imply "it" is a type
08:23:29 <dminuoso> tabaqui2: If by "polymorphic" we mean "universal quantification in the universe above..."
08:23:37 <tabaqui2> yeah, probably it is amout terminology
08:23:40 <dminuoso> tabaqui2: Then a polymorphic type would be one with a universally quantified kind
08:23:47 <nika> ls
08:23:48 <ski> in one, `Integer',`Maybe Integer' are "types", but `Maybe',`Either String' are "type constructors"
08:24:36 <ski> in the other (which i subscribe to), `Integer',`Maybe Integer',`Maybe',`Either String' are all "types". but only `Integer',`Maybe',`Either' are "type constructors", `Either String' isn't
08:25:22 <LPTK> hi, does anyone know why this is rejected as a parse error by ghci?: `do { let x = 1; return x }` the spec seems to say it should be accepted: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
08:26:02 <dminuoso> % do { let x = 1; return x }
08:26:02 <yahb> dminuoso: ; <interactive>:277:26: error: parse error on input `}'
08:26:36 <merijn> You're not delimiting the let block
08:26:51 <merijn> > do { let { x = 1 }; return x }
08:26:53 <lambdabot>  error:
08:26:53 <lambdabot>      • Ambiguous type variable ‘m0’ arising from a use of ‘show_M540135051773...
08:26:53 <lambdabot>        prevents the constraint ‘(Show (m0 Integer))’ from being solved.
08:26:56 <tabaqui2> % do { let x = 1; return x; }
08:26:56 <yahb> tabaqui2: ; <interactive>:278:25: error: parse error on input `;'
08:26:57 <merijn> > do { let { x = 1 }; return x } :: Maybe Int
08:27:01 <lambdabot>  Just 1
08:27:21 <merijn> The ; is delimiting the let line, not the do line
08:27:31 <LPTK> oh
08:27:33 <ski> (ok, and regardless, imho, `Maybe',`[]' respectively `Maybe a',`[a]' are not polymorphic. their kinds are `* -> *' resp. `*'. otoh, `Proxy' is polymorphic, since its kind if `forall k. k -> *')
08:28:08 <LPTK> I thought a let block on a single line with `;` delimiters would have needed `{ }` brackets
08:28:23 <ski> (polymorphic values has types of shape `forall a. ..a..'. polymorphic types have kinds of shape `forall k. ..k..'. the type `forall a. [a] -> Int', e.g., is however monomorphic, its kind is `*')
08:29:07 <ski> > do let { x = 1 }; return x :: Maybe Int
08:29:09 <lambdabot>  Just 1
08:29:28 <LPTK> it's odd to me that the same code works if we put `let x = 1` on its own line; I was working under the assumption that a multiline expression could be put on the same line by wrapping into `{ }` and separating the lines with `;`:
08:29:47 <ski> LPTK : the problem is that it doesn't realize `return x' doesn't belong inside the `let'
08:31:05 <ski> `do { let {x = 1; return x} }' is how your `do { let x = 1; return x }' was attempted to be parsed. and that's a parse error, the last command in a `do' can't be `let'
08:32:09 <ski> (that's why it was complaining about "parse error on input `}'", it was expecting some last command in the `do', which was neither a `let {...}', nor a `... <- ...'. waiting for a plain expression)
08:32:38 <LPTK> yes, I understand what the parser does; I'm just mildly surprised it parses like that
08:34:15 * ski is used to typing things like `do let { x = 1 }; return x' into the interactor
08:36:01 <LPTK> I guess the source of my confusion was that I did not know the parser accepted `let a = 1; b = 2 in a + b` as well as `let { a = 1; b = 2 } in a + b`
08:36:42 <ski> well, with `in', it knows to insert an invisible `}' just before that
08:37:21 <ski> however, with `let' in `do', there's no `in'
08:38:03 <LPTK> thanks for the clarification
08:38:05 <dminuoso> ski: Do you know whether there's a generic term for "type of" that works for any universe level?
08:38:06 <ski> (interestingly enough, this is not a problem with `let' in list comprehensions (or pattern guards), since there the separator is `,', not `;')
08:38:22 <dminuoso> ski: Say a generic term for "type of/kind of/box of/..."
08:39:25 <ski> dminuoso : in a dep. typed language, i believe one'd commonly just say "type of" (in case there's just one syntactic category in which both terms and types are lumped, at least. this is not the case in LF, i think)
08:39:42 <ski> dminuoso : i think i may have seen "sort" used in the sense you're looking for
08:40:25 <dminuoso> ski: Would you accept this definition: a polymorphic s is one whose sort (or type) is universally quantified. ?
08:41:54 <heatsink> I think you'd call it a polymorphic object, to refer generally to a value/type/etc.
08:44:46 <dminuoso> ski: And it would also beg the question, what do you call an object whose type is existentially quantified? Is `f :: exists a. a` polymorphic?
08:44:56 <ski> dminuoso : more or less. though i might want that to be a consequence, rather than the definition
08:45:05 <dminuoso> What do you mean by that?
08:45:28 <ski> (just like it might be nicer to define "function" as "something that can be applied to an argument", rather than "something that has a type of shape `.. -> ..'")
08:45:46 <heatsink> dminuoso: Object-oriented programmers call existential types polymorphic.  They also don't know what existential types are.  :(
08:46:00 <dminuoso> ski: How would you define a polymorphic type then? I dont think we have KindApplications unless we enable TypeInType, do we?
08:46:12 <dminuoso> Oh wait, even with TypeInType it wouldnt help
08:46:12 <ski> dminuoso : that `f' i have sometimes called an "abstract value"
08:46:26 <ski> it's definitely not polymorphic
08:46:59 <EvanR> it can only be handled by a polymorphic 
08:47:05 <ski> yes
08:47:13 <dminuoso> what do you call it then?
08:47:16 <dminuoso> negative polymorphic?
08:47:21 <ski> <ski> dminuoso : that `f' i have sometimes called an "abstract value"
08:47:31 <dminuoso> Oh, I understood that wrongly.
08:47:31 <EvanR> copolymorphic :)
08:47:42 <ski> (because `exists' is closely related to abstract data types)
08:48:10 <ski> hm, or maybe "abstracted value" would be better ?
08:49:01 <dminuoso> ski: So a polymorphic type would be one that can be applied to a kind?
08:49:02 * ski idly wonders how this jibes with calling an expression like `\<pat> -> <expr>' a "function abstraction" ..
08:49:20 <ski> dminuoso : implicitly, yes
08:49:51 <dminuoso> ski: I suppose it fits nicely with "dependent types are ones that can be applied to a term(-level value)"
08:50:04 <dminuoso> Mmm
08:50:05 <heatsink> They're parametric
08:50:20 <ski> % :k Proxy @(* -> *)
08:50:20 <yahb> ski: ; <interactive>:1:7: error: parse error on input `@'
08:50:23 <heatsink> or parameterized
08:50:23 <ski> bah !
08:51:04 <heatsink> What's the difference between evaluation in yahb and lambdabot?
08:51:25 <ski> yahb is more like GHCi
08:51:39 <heatsink> ok
08:52:00 <ski> also, lambdabot has other commands than the evaluation, type, and kind ones
08:52:08 <dminuoso> ski: I guess they are equivalent. I mean when we talk about `/\t. \(s^t). s : ∀x. x -> x` we could either talk about "the left hand side can be applied to a type" or "the right hand side has a universal quantification"
08:52:50 <ski> there's two traditions, "terms before types", and "types before terms"
08:53:15 <ski> (Girard's "Proofs and Types" <http://paultaylor.eu/stable/prot.pdf> mentions this, iirc)
08:53:54 <ski> in the former, you first specify terms, then assign types to them. in the latter you first specify types, and then specify which terms belong to each type
08:54:58 <ski> i suppose me wanting a definition that was not along the lines of "its type has a shape like : ...", was a concession to the first tradition
08:56:25 <ski> in any case, "its type/kind has a shape like : ..." is a handy shorthand, if you can ask about (or infer in your head, perhaps) the type/kind of something
09:07:07 <jsomedon> how did functor get named as functor, does funcor mean a function, an operator?
09:10:57 <geekosaur> it's a mathematical functor as reflected in the world of Haskell types (sometimes referred to as the category Hask)
09:11:37 <geekosaur> the term "functor" tends to be overloaded in computing, though; Haskell, SML, and C++ all mean different things by the term.
09:13:18 <jsomedon> I see on wiki page it says functor maps category to category, and by quickly scanning wiki page of category it looks like category in math is like what type is in haskell?
09:13:47 <Taneb> jsomedon: that's an inaccurate assessment
09:13:51 <geekosaur> more complex than that. a category is a generalization of a set, and you can think of Hask as the "set" of all Haskell types
09:14:15 <jsomedon> ok
09:14:28 <mycroftiv> jsomedon: the easiest to way to understand what haskell means by 'functor' is just looking at what it means in practice - functors are things that you can apply an operation to each element of, aka 'mapping over' them
09:14:34 <geekosaur> I recommend not trying to figure out categories at this point; it'll only be con fusing, because they're *very* abstract
09:15:05 <mycroftiv> for instance a collection of integers is a 'functor' because you can say 'lets add 1 to each integer' aka you map +1 across the collection
09:16:32 <Athas> mycroftiv: wait, is that true?  Isn't a functor necessarily a type constructor?
09:16:44 <jsomedon> mycroftiv: geekosaur: haha alright I just found it difficult to make sense of the meaning of word 'functor', I think I get what haskell functor class actually do though. It looks like any collection like type that I can implement map like funciton can be instance of functor class
09:16:59 <mycroftiv> athas: im just trying to build the basic intuition
09:17:13 <geekosaur> yes. note that it doesn't necessarily have to be a collection, though
09:17:16 <kuribas> is there a lazy mapM for IO?
09:17:27 <jsomedon> geekosaur: for example?
09:17:55 <geekosaur> if you treat a value of type IO Integer as a program that can produce an Integer when run, then its functor appends an instruction to modify the integer in some way
09:18:02 <Athas> jsomedon: your intuition of Functor is correct, but try to remember that ultimately it is governed by the actual type rules (and some laws), but the intuition.
09:18:22 <jsomedon> laws?
09:18:25 <geekosaur> so mapping (+1) over an IO Integer makes sense, but IO is not a container or collection, it's best understood as a program that can be run
09:18:25 <Athas> E.g you can have a Functor that contains no values, or a Functor that is a function.
09:18:33 <EvanR> Functor amounts to the fmap operation
09:19:07 <jsomedon> geekosaur: ah ok
09:19:12 <EvanR> fmap generalizes map (the thing for lists)
09:19:13 <Athas> jsomedon: 'fmap id == id', and 'fmap (f . g) == fmap f . fmap g'.  Haskell doesn't check this for you, but every Functor is supposed to obey these laws.
09:19:18 <geekosaur> similaraly a function is a functor and its map operation is function composition, in effect combining two functions to make a new one
09:19:39 <Athas> They are what you expect, and unless you go out of your way to break them, most functors will follow the laws.
09:19:48 <kuribas> I suppose I can use unsafeInterleaveIO 
09:20:07 <geekosaur> this kind of thing is where we start getting pretty abstract, because they're all "mapping" in some sense and yet they're different actions
09:20:21 <geekosaur> kuribas, I think that's more or less your only option
09:21:57 <jsomedon> geekosaur: trying to following your example of function as a functor, so you mean the . operator is fmap in funciton's case
09:22:09 <geekosaur> yes
09:22:45 <Cale> It is possible to think of IO as a really weird sort of container whose structure describes the actions to be performed (conditionally on results of other actions usually). For example, you can represent terminal I/O like this:
09:23:02 <geekosaur> for lists, fmap is map. various other types have their own fmap operations, all of which obey the rules Athas pointed out
09:23:36 <Cale> data TermIO a = Done a | PutChar Char (TermIO a) | GetChar (Char -> TermIO a)
09:24:29 <mniip> ah yes, enslaved (Free monad)
09:24:34 <Cale> The function Char -> TermIO a might make this a little less container-like, but you can imagine that function as being a sort of container which has a place for each Char value
09:24:41 <Cale> yeah, exactly
09:25:49 <EvanR> ah stretching the container metaphor to its theoretical limits again
09:26:17 <Cale> The idea is that every TermIO a action is either already complete, with some result of type a, or it starts off by printing a character to the terminal (followed by some other TermIO a action), or it starts off by reading a character from the terminal, and deciding which TermIO a action to take following that based on it.
09:27:01 <Cale> But yeah, fmap f is just going to apply the given function f to all the values in the Done constructors throughout this weird tree-like structure
09:27:06 <EvanR> TermIO a is a dialog, it is talking, listening, or ended with result a
09:27:09 <monochrom> At this point I speak of computational tree or game tree.
09:27:10 <geekosaur> that's why I described it as a program
09:27:49 <geekosaur> with the various constructors as possible actions.
09:28:03 <jzyamateur> how does one check laziness, WHNF etc? is there a common utility/command to check ? I think, one way is to put undefined somewhere in the expression and see if it crashes?
09:28:37 <jzyamateur> e.g. `length [1, undefined]` does not crash means elements are not evaluated.
09:28:43 <geekosaur> you can't check it in any other way, and even that is unreliable if it doesn't happen to evaluate the part containing the undefined
09:28:49 <geekosaur> (see: halting problem)
09:29:02 <novum> hello! I got an error running `stack test`. I added `- hspec` to the "dependencies:" section in file:///./package.yaml and re-ran `stack build`. Is that the right thing to do? I would have expected stack test to be more mature than that, and it seems weird to include "hspec" in dependencies if, eg, you were producing an actual package
09:29:38 <geekosaur> generally there's a separate part for test dependencies and for running the tests
09:29:53 <monochrom> Also note that the "elements" "contained therein" are the exact opposite of what most people think.  Most people think getChar :: TermIO Char "contains the char read". NO. Look at "Char -> TermIO a", it contains what the program does next, indexed by the char read.
09:30:32 <monochrom> And look at "PutChar Char (TermIO a)". It means putChar :: TermIO () contains the char written.
09:30:39 <EvanR> depending on what it does, it could contain those read chars in some way. Or ignore them
09:30:45 <novum> you're correct. I woke up at 3 am ts morning, but thanks geekosaur. I am just being silly per usual. aren't we all. cheers.
09:30:48 <monochrom> TermIO is a container but it is all backwards.
09:31:38 <EvanR> it could contain read chars in the same way /dev/null contains bytes written
09:32:07 <monochrom> This is why TermIO is a game tree.
09:32:38 <mycroftiv> you just gave me a great idea for a tiny computer sci-fi short story, "the day /dev/null filled up" - worldwide, suddenly /dev/null stops working because the dimension weve flushed all our bits into has filled up and cant take any more
09:32:39 <monochrom> A tree is a container but a game tree contains the game not the events.
09:33:08 <EvanR> the null dimension filled up with all the unwanted bytes
09:33:09 <monochrom> Instead, you use the events to look up the game.
09:33:49 <jzyamateur> I do not understand why `[1, undefined]` crashes but `length [1, undefined]` runs fine?
09:34:18 <jzyamateur> in order for length to run, wasn't the list constructed in the first place?
09:34:21 <monochrom> length doesn't care the content, only the shape.
09:34:43 <monochrom> Also have fun with take 0 [1, undefined] and take 1 [1, undefined]
09:34:54 <jzyamateur> so if i am printing `[1, undefined` am I forcing list evaluation ?
09:35:16 <monochrom> You have an undefined element but the shape is completely defined.
09:35:17 <EvanR> that is funny, by modeling functions as a set of all the elements in the domain paired with all the function results, it ends up not containing anything from the domain after all (in the computational sense)
09:35:30 <monochrom> 1 : (undefined : [])
09:35:42 <monochrom> length counts the : and the ending [].
09:35:47 <EvanR> if you have everything you have nothing (in an information sense, maybe)
09:35:49 <jsomedon> Athas: I can't imagin what a funcgtor of no values look like in Haskell?
09:36:05 <Athas> jsomedon: data Vacuous a = Vacuous
09:36:27 <jsomedon> ok..
09:36:37 <Athas> I didn't say it was useful!
09:36:57 <jsomedon> lol yeah totally, I just didn't realize it would be like this
09:37:18 <heatsink> It's useful for all the times you need a functor that's both covariant and contravariant
09:37:22 <Athas> And the EmptyDataDecls option: data VacuousVoid a
09:37:35 <monochrom> You probably need a reminder that data constructors such as : are lazy too.
09:38:52 <monochrom> If you have "isJust Nothing = False; isJust (Just _) = True" then isJust (Just undefined) = True.  length is just that on steroid.
09:39:07 <jsomedon> Athas: then fmap of Vacuous wouldbe like: fmap f v = v ?
09:39:30 * hackage gitlab-haskell 0.1.1 - A Haskell library for the GitLab web API  https://hackage.haskell.org/package/gitlab-haskell-0.1.1 (RobStewart)
09:39:32 <heatsink> The type can change, so you need to write fmap f _ = Vacuous
09:39:55 <heatsink> or fmap f v = cast v if you're feeling perverse
09:40:09 <heatsink> *fmap f v = unsafeCoerce# v
09:40:25 <geekosaur> Athas, EmptyDataDecls is only needed in Haskell98, not Haskell2010
09:41:22 <jsomedon> heatsink: uh I dont get how type gets changed, looks like (fmap f v) essentially does nothign but returns v back untouched?
09:41:39 <oz5> Hi all, does anyone here have experience with the safe-money package?
09:41:46 <jle`> :t chr
09:41:48 <lambdabot> Int -> Char
09:41:53 <geekosaur> jsomedon, not with this specific type, but llook at the type of fmap
09:41:55 <jle`> jsomedon: fmap chr :: Vacuous Int -> Vacuous Char
09:42:01 <geekosaur> it allows the type to change, so you must honor that
09:42:07 <jle`> jsomedon: the type does literally change :)
09:42:19 <geekosaur> even though the type is never actually used for a value
09:42:19 <jsomedon> ohhh
09:42:21 <jsomedon> ok
09:42:29 <jle`> you can think of it like Maybe without Just
09:42:36 <jsomedon> ah because the type of v is Vacuous something
09:42:40 <jle`> even for maybe, you'd have to write fmap _ Nothing = Nothing
09:42:52 <jle`> becasue it goes from, say, Maybe Int to Maybe Char
09:43:00 <jle`> the Nothing you return has a different type than the Nothing you get
09:43:15 <monochrom> jsomedon: Suppose I am writing a function "foo :: Either String Int -> Either String Bool".  "foo (Right n) = Right (even n)" so far so good.  "foo s@(Left _) = s" this will be rejected.
09:43:16 <jsomedon> right didnt' realize that
09:43:27 <geekosaur> this is actually useful, we call them phantom types and they're useful as ways to "tag" values so they can't be mied inappropriately or etc.
09:43:31 <Athas> jsomedon: You need to deconstruct and reconstruct to get the right type.
09:43:35 <jsomedon> ok
09:43:42 <geekosaur> *mixed
09:44:13 <jle`> so have you ever thought "I want a Maybe, but with no Just"?
09:44:21 <jsomedon> ?
09:44:39 <jle`> if you were looking for a type, and you were like "man Maybe would be perfect for this situation, except for that pesky Just."
09:44:49 <jle`> "hasn't anyone ever defined a type that's like Maybe but without the Just constructor"
09:44:57 <monochrom> like "data M a = Ctor0" done
09:45:07 <jle`> if that'st he case, Vacuous (or as it's defined in base, Proxy) is just the candidate :)
09:45:15 <jsomedon> so data Maybe = Nohting
09:45:23 <monochrom> No no, with the parameter.
09:45:29 <jsomedon> so data Maybe a = Nohting
09:45:29 <monochrom> But don't use the parameter.
09:45:34 <monochrom> yeah
09:45:37 <jle`> data MaybeWithNoJust a = NothingWithNoJust
09:45:40 <jle`> aka data Proxy a = Proxy
09:46:17 <jle`> now to go off of that have you ever asked "i want a type just like Maybe, but with no Nothing"?
09:46:41 <jle`> and last finally "i want a type just like Maybe, but with no Nothing AND no Just. they're both not going to work here."
09:46:49 <jsomedon> ..
09:46:54 <jle`> all three of these are useful types :)
09:47:09 <jsomedon> data Maybe a = what-comes-here-?
09:47:18 <jle`> over the course of your haskelling career you'll run into a need for both
09:47:19 <monochrom> "data Maybe a" done
09:47:23 <jle`> jsomedon: which one are you talking about?
09:47:31 <jle`> data MaybeWithNoNothing a = JustWithNoNothing a
09:47:35 <jsomedon> jle`:the no nohting and no just
09:47:42 <jle`> or as we like to call it, newtype Identity a = Identity { runIdentity :: a }
09:48:09 <jle`> ah yeah, you'd write it as just `data Maybe a`, or `data MaybeWithNoJustAndNoNothing a`
09:48:20 <jsomedon> is that valid haskell code..
09:48:24 <monochrom> Yes.
09:48:25 <jle`> indeed
09:48:29 <jle`> @let data VoidF a
09:48:31 <lambdabot>  Defined.
09:48:32 <monochrom> For a decade now.
09:48:54 <jsomedon> so what is possible value of such type?
09:49:02 <jle`> no possible values
09:49:02 <jsomedon> no such value?
09:49:07 <jsomedon> hm
09:49:18 <Athas> undefined
09:49:21 <jsomedon> lol
09:49:34 <jsomedon> ok didn't know haskell has this much freedom
09:49:41 <geekosaur> it's a way to represent impossible situations in the type system, so the compiler knows it can never reach that point
09:49:43 <Cale> Yeah, since we have general recursion, you can always write an infinite loop
09:49:47 <Cale> x = x
09:50:00 <Cale> and that can have any type
09:50:08 <Athas> I think the most common use of empty datatypes is when using phantom types.
09:50:29 <geekosaur> ^ but also that, as I mentioned earlier. there it's just a tag with no other meaning
09:50:35 <Cale> But other than that (and things which throw errors, which are thought of as "the same"), you won't find any values of such empty datatypes
09:51:00 <Athas> Incidentally, phantom types are probably my favourite type trickery technique.  Does what it says on the tin, gives good errors, easy to understand.
09:51:01 <Cale> Empty datatypes are also sometimes useful as arguments of other datatypes
09:51:18 <jsomedon> well at least it amuse new comer like me
09:51:54 <Cale> Like, if you have some more general construction, and you don't need part of it, plugging in an empty datatype might be a good way of saying that.
09:53:55 <ski> geekosaur : don't forget Prolog .. :/
09:55:18 <jle`> jsomedon: yeah i definitely found this amusing when i started haskell too. i found out it was related to this sort of 'type algebra'
09:55:53 <jle`> for functors here you can think of them as functions taking types to types, so you can also start thinking about the number of inhabitants of the result types
09:56:28 <jle`> for example for Maybe a, Maybe(a) = 1 + a, it adds one extra member to 'a'
09:56:43 <jle`> and in the cases we have here, Proxy(a) = 1, and Identity(a) = a
09:56:52 <jle`> so you can think of Maybe(a) = Proxy(a) + Identity(A)
09:57:24 <Athas> Taking laziness into account, Maybe adds two values, right?  'Nothing' and 'Just bottom'?
09:57:50 <jle`> from this you get to do useful things like refactoring your data types based on algebra laws, like multiplication distribution and stuff like that
09:58:02 <ski> i remember i had some monad `SystemM', and i had a bunch of `undefined's which were making me uneasy. changing from `SystemM ()' to `SystemM Void' allowed me to remove all of those, giving me confidence that i hadn't overlooked something
09:58:20 <jsomedon> jle`: uhm this code `Maybe(a)` is this haskell code?
09:58:27 <jle`> Athas: if we take into account non-strictness, it adds Nothing and bottom
09:58:35 <jle`> jsomedon: this is like, a math function
09:58:40 <jle`> maybe using the same name was a bad idea
09:58:41 <jsomedon> jle`: ah ok
09:58:44 <jle`> f(x) = 1 + x
09:58:49 <jle`> and Maybe corresponds to that function x
09:58:52 <jle`> *that function f
09:58:53 * ski would just write `Maybe a', anyway ..
10:00:13 <jsomedon> jle`: uhm so in your Maybe(a) example above, Maybe(a) is a function that does 1 +a
10:00:22 <jle`> yeah
10:00:29 <jle`> if we consider the "size" of each type
10:00:34 * ski . o O ( `d [a] / d a  =  ([a],[a])' )
10:00:41 <jle`> if Bool has two inhabitants, then Maybe Bool has three
10:00:52 <jle`> if Ordering has three inhabitants, Maybe Ordering has four
10:00:53 <jle`> etc.
10:01:00 <jle`> if () has 1 element, Maybe () has two
10:01:12 <jle`> s/element/inhabitant
10:02:06 <jle`> one neat advantage is that sometimes i have a really complex types or bunch of types, sometimes they can be refactored by looking at them this way and just taking some simple algebra simplifications, like x*y+x*z = x*(y+z)
10:02:22 <ski> (`Either a b' corresponds to `a + b',`(a,b)' to `a * b',`Void' to `0',`()' to `1',`Bool' to `2',`Ordering' to `3',`a -> b' to `b^a' )
10:03:50 <ski> (currying, that `(a,b) -> c' is equivalent to `a -> b -> c', corresponds to `c^(a*b)  =  (c^b)^a'. and that `Either a b -> c' is equivalent to `(a -> c,b -> c)' corresponds to `c^(a + b)  =  c^a * c^b' .. and so on)
10:04:08 <mycroftiv> this seems really cool, is there an example of code before and after showing this kind of refactoring? i kind of get what you guys are saying but doing the transformations in my head isnt quite working
10:04:20 <jsomedon> 🎿 so you are corresponding type to type size
10:04:23 <jsomedon> uh
10:04:26 <jsomedon> ski :
10:04:53 <mycroftiv> yeah that was directed at ski
10:04:57 <mycroftiv> err jle
10:05:08 <mycroftiv> i was asking jle about algebraic refactorings of types
10:05:24 <ski> well, `[a]' corresponds (at least in some sense) to `1 + a + a^2 + a^3 + ...', or to `1 / (1 - a)'
10:05:47 <ski> (geometric series formula)
10:06:03 <jsomedon> ski : Void to 0 because Void might be like `data Void -- that's it no = no data constructor`
10:06:23 <ski> by `a * b' i really mean the cartesian product of the sets/types `a',`b'
10:06:28 <ski> yes, jsomedon
10:06:51 <ski> and by `a + b', i mean the "disjoint union" of the sets/types `a',`b'
10:07:16 <ski> and `b^a' is traditional math notation for the set (/type) of all functions from `a' to `b'
10:07:25 <jle`> mycroftiv: some simple example of what i mentioned earlier is say i had a type data Pet = Dog String Int | Cat String Int, with name and age
10:07:41 <jle`> that corresponds to Pet = (string*int) + (string*int)
10:07:51 <jle`> you can refactor this into Pet = 2 * (stirng*int)
10:07:53 <mycroftiv> aha
10:08:01 <ski> (if `2' is the set `{0,1}', and `a' has `n' inhabitants (elements), then how many does `a^2' have ? how many does `a * a' have ?)
10:08:03 <jle`> so we can have, say, data PetType = Dog | Cat
10:08:18 <jle`> and now data Pet = Pet { petType :: PetType, petName :: String, petAge :: Int }
10:08:27 <jle`> and this version will also scale with more pet types
10:08:50 <jle`> this is a simple example, but sometimes things can get even more hairy, so we get even more benefit in the end
10:09:40 <jsomedon> wow
10:09:41 <mycroftiv> i have done similar transformations but i hadnt thought of it in the abstract mathematical sense of a type algebra, this is really powerful, thanks
10:10:07 <jle`> no problem :)
10:11:14 <ski> sometimes you have something like `data Blah = Barf [String] Integer | Frob [String] (Map String Integer)', iow `Blah = [String] * Integer + [String] * Map String Integer', so you can only factor out the common factor `[String]', getting `Blah = [String] * (Integer + Map String Integer)', or `data Blah = MkBlah [String] BlahBody; data BlahBody = Barf Integer | Frob (Map String Integer)'
10:11:14 <jsomedon> type algebra is this how it's called in academia? I tried to search but all I see is algebraic data type
10:11:19 <jle`> but going back to what i think was supposed to be my original point, asking questions like "i can't imagine what a functor of no values would look like" leads to a lot of interesting results that can be pretty useful
10:12:18 <geekosaur> the problem with search engines for this kind of thing is they give you the most common nearby concept, not necessarily what you searched for
10:12:24 <jsomedon> jle`: yes very interestign to see all these
10:12:31 <jle`> the next time i teach a haskell class i'm going to plant a student to ask this question
10:13:35 <jsomedon> so you mean the term "type algebra" itself is correct?
10:14:13 <jsomedon> or maybe any book or any link on this topic
10:14:21 <jsomedon> that I can take a look at it
10:14:50 <jle`> it's the 'algebra of types', although i don't think it has that formal name
10:14:59 <jle`> but if you search algebra of types you should get a few blog posts i think
10:15:11 <jsomedon> ok
10:15:28 <geekosaur> ^ and what I said is even trickier because you might otherwise get the right name for it --- but "algebraic data type" is common enough to override that :/
10:16:14 <geekosaur> search engines ain't smart, they look at what's common not what's conceptually nearer (they have no clue about "conceptually nearer")
10:18:13 <mycroftiv> in math the fact that some things may be 'an algebra' is so ubiquitous and type theory studies so many relationships like this that that you will find a lot of things which overlap this concept
10:18:50 <mycroftiv> i hadnt seen things framed exactly like jle had before, but once he expressed it, i could see how it sort of jigsaw-piece fit in with everything
10:19:29 <ski> "Seven trees in one" by Andreas R. Blass in 1995 at <http://www.math.lsa.umich.edu/~ablass/cat.html> (also cf. "This Week's Finds in Mathematical Physics (Week 202)" by John Baez in 2004-02-21 at <http://math.ucr.edu/home/baez/week202.html>, and perhaps "Searching for a Video Proof of “Seven Trees in One”" <https://golem.ph.utexas.edu/category/2009/07/searching_for_a_video_proof_of.html>) might be interesting ..
10:19:35 <ski> .. also you might like "Objects of Categories as Complex Numbers" by Marcelo Fiore,Tom Leinster in 2002-12-30 at <https://arxiv.org/abs/math/0212377>
10:22:55 <jsomedon> so size of f :: a -> b would be sizeof(b)^sizeof(a) ?
10:24:42 <EvanR> yes
10:25:53 <ski> s/f :: //
10:32:11 <jsomedon> sizeof(Either a b) I thought it's sizeof(a)*sizeof(b), but the post I am reading says it's s(a) + s(b)
10:32:54 <jsomedon> ah nvm
10:38:50 <jsomedon> this stuff is pretty interesting, like how Bool -> a and (a,a) are similar, their sizes are same, and if I consider f::Bool->a and first of tuple as f(True) and second of tuple as f(False) then the tuple is another way to represent f::Bool->a
10:43:55 <EvanR> after reading through that paper, is type algebra really just polynomials with natural number coefficients 
10:44:19 <ski> well, not quite, since we'd also like to be able to use at least (infinite) inductive types
10:44:44 <ski> (and then, also, `forall'-types, and `exists'-types)
10:45:15 <EvanR> and GADTs, and constraints, but i wasn't sure if those were being considered
10:49:34 <ski> (hm, i'm sure Baez had a week where he discussed counting inhabitants of types like e.g. `forall a. (a * a * a) + (a * a) -> a' .. but i can't seem to find it, atm)
10:50:19 <rotty> hi! any users of propellor (https://propellor.branchable.com/) around? I'm wondering if it would be possible to use it without requiring a full haskell dev stack on the target machines.
10:52:21 <rotty> I'd love to use it, and brush up my haskell skills a bit, but that dev stack requirement makes it too heavyweight for my taste
10:52:54 <nil> ski: i was reading https://byorgey.wordpress.com/2011/01/26/counting-linear-lambda-terms/ earlier, might be related
10:58:00 * hackage Frames-map-reduce 0.2.0.0 - Frames wrapper for map-reduce-folds and some extra folds helpers.  https://hackage.haskell.org/package/Frames-map-reduce-0.2.0.0 (adamCS)
11:02:06 <iqubic> ski: Are you around?
11:02:10 <iqubic> I think I figured out your challenge from yesterday.
11:02:27 <iqubic> frobnicate ::(a -> Expr a) -> Expr a -> Expr b
11:02:44 <iqubic> I feel like this is fixed point recursion.
11:03:10 <ski> i still don't know what you mean by "fixed point recursion"
11:03:17 <ski> (but, as i said, it is recursive, yes)
11:03:20 <iqubic> ski: Look at this: http://dpaste.com/0C5989J
11:03:42 <iqubic> Well, the definition I have there is similar to fix.
11:03:53 <iqubic> :t mfix
11:03:55 <lambdabot> MonadFix m => (a -> m a) -> m a
11:04:00 * hackage cpkg 0.2.3.3 - Build tool for C  https://hackage.haskell.org/package/cpkg-0.2.3.3 (vmchale)
11:04:16 <ski> iqubic : exactly right !
11:04:36 <iqubic> The function frobnicate actually has a very similar type signature to mfix.
11:04:44 <iqubic> is that what you wanted me to see?
11:05:11 <ski> well, it also takes an `Expr a' input
11:05:19 <ski> now, two things
11:05:31 <ski> (a) note how it looks like "an infinite recursion"
11:05:37 <iqubic> It does indeed.
11:06:00 <ski> (in fact, you can generalize to `Monad m => (var -> m var) -> var -> m otherVar')
11:06:13 <ski> (if this was `IO', then it would never terminate (barring exception))
11:06:35 <ski> however, if you run it on some expression, and some given substitution, it can often terminate just fine
11:06:54 <iqubic> How so?
11:07:04 <ski> (and even when it doesn't "terminate", that just means that it'll give you an infinite expression tree back, which you can explore a finite part of, with no problem)
11:07:25 <iqubic> Huh? That has me confused now.
11:07:30 <ski> (b) what does `forbnicate' do, actually ?
11:07:33 <ski> (for `Expr')
11:07:42 <iqubic> It does something.
11:07:46 <iqubic> Not sure.
11:07:49 <ski> (perhaps you should answer (b), before considering (a) further)
11:08:18 <ski> you could define `data MyVar = X | Y | Z', and dream up some expression and substitution
11:08:21 <iqubic> Can you give me some pointers on what this function does?
11:10:00 <iqubic> wait... It just keep doing free variable substitution around and around and around until all the variables have concrete Lit values.
11:10:19 <ski> until all variables have been substituted away, yes
11:10:50 <ski> it replaces variables with their corresponding expressions in the substitution. then replaces the variables in those expressions again, and so on
11:11:03 <ski> so, one might s/frobnicate/fullSubst/
11:11:27 <ski> note that `Expr' is a kind of non-determinism monad, just like `[]' is
11:12:08 <ski> `Add', and `Mult', introduce multiple "solutions/alternative" (multiple subtrees, in which more than one variable may lurk)
11:12:30 <ski> `Lit n' is failure (failing with failure indicator `m')
11:13:13 <ski> `x <- expr' in `do' means : "non-deterministically select a variable `x' from `expr', and then continue with the remainder of the `do'"
11:14:21 <ski> and the "non-deterministically select" means that that effect will be part of the over-all effect. iow, the tre branches in `expr' will be kept, and each leaf with variable `x' will be replaced by what follows that command in the `do'
11:14:39 <iqubic> http://dpaste.com/059VK4Y
11:14:44 <iqubic> I see.
11:14:49 <iqubic> That's cool.
11:15:14 <ski> (with lists, you "concatenate" multiple solutions, in an associative way. here, however, we keep the "tree grouping" around)
11:15:48 <ski> yea, when i first saw this, it was pretty mind-blowing :}
11:17:24 <iqubic> So is this similar to the list monad?
11:18:35 <iqubic> Writing the Functor, Applicative, and Monad instances for this data type was really really enlightening.
11:18:57 <iqubic> I got a much richer understanding of what each type class is supposed to do.
11:21:18 <iqubic> In order to figure out what frobnicate was actually doing, I had to desugar the do notation and expand out the recursive call a few times.
11:21:25 <iqubic> That was rather enlightening.
11:22:57 <iqubic> When you write 'do x <- m; ...' You are saying 'x' is one part of the monadic structure 'm'
11:23:45 <EvanR> desugaring = mental floss
11:23:59 <iqubic> Hehe.
11:24:55 <iqubic> now I need to figure out how Excptions and Exception handling work in Haskell
11:26:29 <EvanR> shameless dynamic typing
11:28:53 <iqubic> I have a function 'move :: Int -> Int -> GameState m n -> Maybe (GameState m n)' But move can fail in many different ways. I want to be able to capture the different ways move can fail, instead of just returning Nothing.
11:30:03 <iqubic> It's better to say "'move' failed in this particular way" than it is to say "'move' failed in an unspecified way"
11:30:19 <EvanR> -> Either Reason (GameState m n)
11:31:08 <iqubic> No fancy ExceptT, or MonadThrow, or MonadError?
11:31:38 <EvanR> um... 
11:31:46 <iqubic> Just make a Reason data type with nullary costructors and return that?
11:31:58 <EvanR> Reason can be as descriptive as you want
11:32:10 <iqubic> I thought I'd need to be more creative.
11:32:38 <EvanR> the Applicative behavior of Either is basically the essence of exceptions
11:32:50 <ski> iqubic : "So is this similar to the list monad?" -- yes. it's a non-determinism monad, but it's not "associative in solutions", like the list monad
11:33:11 <iqubic> Well, I'm going to be using the Monad verion in my code.
11:33:18 <EvanR> unless you are trying to combine monads with transformers you don't need more than Either
11:34:01 <iqubic> ski: the expression monad keeps much of the same structre as what you started with.
11:34:25 <iqubic> I don't have any Monad Transformers in my move code.
11:34:43 <ski> iqubic : `Add (Add (Var X) (Var Y)) (Var Z)' is not the same expression as `Add (Var X) (Add (Var Y) (Var Y))' (though, with reasonable semantics, they would evaluatate to the same. but you can imagine `Sub' instead of `Add'). otoh `([X] ++ [Y]) ++ [Z]' is the same as `[X] ++ ([Y] ++ [Z])'
11:34:54 <iqubic> Oh, right.
11:34:59 <iqubic> That's right.
11:35:52 <ski> iqubic : "Writing the Functor, Applicative, and Monad instances for this data type was really really enlightening.","I got a much richer understanding of what each type class is supposed to do." -- happy to have been able to provide a, not only (hopefully) fun example, but also one which was more worthwhile, yielded better general understanding of those type classes
11:37:10 <iqubic> I had never thought of these type classes as providing structure transformations ever before, but that's totally what they do.
11:37:26 <ski> @hackage validation
11:37:26 <lambdabot> http://hackage.haskell.org/package/validation
11:37:43 <ski> iqubic : you might want to check out that ^ at some point, after `Either' and `ExceptT'
11:38:28 <jsomedon> data Nat = Zero | Succ Nat
11:38:40 <ski> iqubic : what do you mean by "(providing) structure transformations" ?
11:39:35 <jsomedon> data Nat = Zero | Succ Nat, what would be size of this, nat = 1 + 1 + ... + 1 + nat, or nat = 1 + 1 +.... + 1
11:43:01 <iqubic> ski: a given Functor f knows how to transfor 'f a' into 'f b' provided give it a function of type 'a -> b'
11:43:34 <iqubic> So it's really a structure presearving operation.
11:44:03 <iqubic> And in fact, to modify the structure at all would break the Functor law of: 'fmap id = id.
11:45:49 <iqubic> It would be unlawful for a functor over Binary trees to remove nodes.
11:45:57 <iqubic> data Tree a = Leaf a | Node (Tree a) (Tree a)
11:46:02 <iqubic> mirror :: Tree a -> Tree a
11:46:06 <iqubic> mirror (Leaf a) = Leaf a
11:46:10 <iqubic> mirror (Node l r) = Node (mirror r) (mirror l)
11:46:53 <iqubic> it would also be unlawful to change the structure by applying the (a -> b) function all the leaves, and THEN call mirror.
11:47:02 <iqubic> As that changes the structure of the tree.
11:47:44 <EvanR> unlawful makes us feel like we're doing something naughty
11:47:58 <iqubic> Which we are.
11:48:06 <EvanR> another way to look at it is, it's impossible for a functor to do these kinds of things, technically impossible
11:48:14 <iqubic> We don't like ListT because it is unlawful.
11:48:38 <EvanR> it shouldn't have this kind of access, it is limited in the kind of observations it can make
11:48:44 <iqubic> Right.
11:49:09 <iqubic> Applicative and Monad lift some of the restrictions, but certainly not all.
11:49:30 <EvanR> so it's like, breaking into fort knox vs not breaking in because you can't
11:49:50 <iqubic> One of those is unlawful.
11:50:02 <EvanR> no, Applicative and Monad don't let you break functor laws
11:50:17 <iqubic> Right.
11:50:29 <iqubic> But they do provide more things you can do with the structure.
11:50:46 <EvanR> a super functor
11:51:26 <iqubic> Everyone loves to talk about Monads and how they are so great, but there's a lot you can do with just bare functors.
11:51:56 <EvanR> yeah. fmap.
11:52:04 <EvanR> and you don't even have to program it yourself
11:52:29 <iqubic> DerivingFunctor is a wonderful language pragma
11:52:48 <EvanR> i want DerivingFreeMonads
11:52:49 <ski> jsomedon : `nat  =  1 + nat  =  1 + 1 + nat  =  1 + 1 + 1 + nat  =  ...  =  1 + 1 + 1 + 1 + ...'
11:52:57 <iqubic> Can anyone create a data type that is a valid functor, but not a valid Applicative?
11:53:03 <EvanR> sure
11:53:04 <iqubic> Wait... Wait...
11:53:49 <iqubic> data Store s a = Store (s -> a) s.
11:53:58 <iqubic> I was working with that all week.
11:54:05 <iqubic> I isn't an Applicative.
11:54:12 <ski> iqubic : `Coyoneda IORef'
11:54:16 <EvanR> are you sure
11:54:24 <iqubic> EvanR: I'm fairly sure.
11:54:33 <EvanR> s -> a is applicative
11:55:00 <iqubic> But which initial 's' do you use for pure?
11:55:12 <EvanR> you don't, it will be given later
11:55:19 <iqubic> pure = Store id
11:55:24 <ski>   data CoyonedaIORef b = forall a. FMapIncl (a -> b) (IORef a)
11:55:43 <jsomedon> ski : so you mean: expanded fixed times we still should see nat on right hand side but expanded enough times we should see no nat but more 1s
11:55:44 <ski>   data Coyoneda f b = forall a. FMapIncl (a -> b) (f a)
11:55:58 <ski> jsomedon : (countably) infinitely many `1'
11:56:02 <iqubic> Is that right? 'pure = Store id'?
11:56:13 <EvanR> no
11:56:18 <ski> iqubic : ok (re "structure presearving operation")
11:56:28 <iqubic> yes.
11:57:03 <EvanR> yeah, your type has no s to pair with the function
11:57:03 <jle`> the typical example of a Functor that is not an Applicative is Map k from Data.Map/containers
11:57:26 <jle`> iqubic: try checking with ghc
11:57:29 * ski idly wonders whether iqubic is thinking of `exists s. (s -> a) * s', aka `Coyoneda Identity a'
11:57:31 <jle`> to see if it allows that definition
11:58:53 <iqubic> ski: I have no idea what Yoneda is, let alone Coyenda.
11:59:13 <iqubic> I assume one is the dual of the other.
11:59:21 <jle`> try pure x = Store _ _
11:59:30 <jle`> and seeing what should go in the holes
11:59:43 <dmwit> Perhaps we can `instance Monoid s => Applicative (Store s)`.
11:59:55 <iqubic> Yes, that works
12:00:21 <iqubic> But is that useful?
12:00:31 <jle`> dmwit: i'm not super convinced
12:00:37 <dmwit> I think you said "that works" too quickly to have checked the laws.
12:00:46 <dmwit> jle`: Me neither.
12:01:22 <dmwit> jle`: Well, it's just Compose (Writer s) (s -> a), so what could go wrong?
12:01:25 <jle`> hm. it's `Reader s :*: Const s`, which has a valid Applicative instance
12:01:37 <jle`> and there is only one possible Functor instance
12:01:42 <dmwit> So yeah, this seems sensible.
12:01:51 <dmwit> Now useful is a completely different question.
12:02:31 <jle`> i think it'd be useful in different situations than you'd want Store s in general
12:02:53 <jle`> basically RWST without the S
12:03:53 <jle`> i can see why there wouldn't be an Applicative instance defined.  you can always just use RWS s s ()
12:04:21 <jle`> oh wait, it's not RWS...it's different
12:04:34 <iqubic> https://hackage.haskell.org/package/comonad-5.0.5/docs/src/Control.Comonad.Trans.Store.html#line-140
12:04:48 <iqubic> https://hackage.haskell.org/package/comonad-5.0.5/docs/Control-Comonad-Store.html
12:04:52 <jle`> i think yeah probably just a situation where you would want Reader + Const abilities, not necesarily situations where you would use Store normally
12:04:57 <iqubic> See it for yourself.
12:05:11 <iqubic> It exists, and is a thing.
12:06:50 <jle`> iqubic:  i mean, i'm saying that i can see why the maintainer of that library would choose not to export an Applicative instance
12:07:02 <iqubic> yeah. I know.
12:07:23 <jle`> oh, then what are you trying to say?
12:07:45 <iqubic> Store is actually really cool when you see how it can be used to construct lenses.
12:09:40 <ski> iqubic : i defined `Coyoneda' for you
12:10:14 <iqubic> where/
12:10:21 <iqubic> I must have missed it.
12:10:27 <iqubic> Looking at the logs.
12:11:56 <iqubic> ski: I can't find it.
12:12:12 <ski> sixteen minutes ago
12:12:33 <jle`> it starts with "...idly wonders whether iqubic is thinking of ..."
12:12:42 <iqubic> ski: I can't find it.
12:12:59 <ski> (actually starts slightly before that)
12:13:21 <jle`> oh yeah
12:13:32 <iqubic> exists s. (s -> a) * s
12:13:40 <iqubic> How is that different from Store?
12:13:45 <jle`> you actually defined it three times so it threw me off, sorry
12:14:30 <jle`> iqubic: it hides the 's' existentially
12:14:46 <ski> <iqubic> Can anyone create a data type that is a valid functor, but not a valid Applicative?
12:14:50 <ski> <ski> iqubic : `Coyoneda IORef'
12:14:55 <ski> <ski>   data CoyonedaIORef b = forall a. FMapIncl (a -> b) (IORef a)
12:15:00 <ski> <ski>   data Coyoneda f b = forall a. FMapIncl (a -> b) (f a)
12:15:05 <ski> * ski idly wonders whether iqubic is thinking of `exists s. (s -> a) * s', aka `Coyoneda Identity a'
12:15:11 <ski> <iqubic> ski: I have no idea what Yoneda is, let alone Coyenda.
12:15:11 <ski> <iqubic> I assume one is the dual of the other.
12:15:23 <ski> iqubic : what jle` said
12:16:49 <jsomedon> if functions are instance of Functor class, then can I say `fmap f g = g . f`
12:17:00 <jle`> Coyoneda Identity, aka Store hiding the s, can have an Applicative instance. but not Store exposing the s
12:17:17 <jle`> jsomedon: yes, fmap for ((->) r) is function composition in that way
12:17:23 <jle`> > fmap (+2) (*3) 10
12:17:26 <lambdabot>  32
12:17:46 <jle`> hm, actually it's f . g
12:18:32 <ski>   newtype Yoneda f a = PamFPilFJorp {ProjFlipFMap :: forall b. (a -> b) -> f b}
12:19:08 <ski>   incl :: f a -> Coyoneda f a
12:19:09 <ski> incl fa = FMapIncl id fa
12:19:40 <ski>   proj :: Yoneda f a -> f a
12:19:40 <ski>   proj yfa = projFlipFMap yfa id
12:19:56 <jle`> that nobuo at it again
12:20:07 <iqubic> why did you name in PamfPilfJorp?
12:20:11 <ski> iqubic : exercise : write `Functor' instances for `Coyoneda f' and `Yoneda f'
12:20:32 <iqubic> > reverse "PamfPilfJorp"
12:20:34 <lambdabot>  "proJfliPfmaP"
12:20:34 <jle`> iqubic: it's the inverse of ProjFlipFMap
12:20:36 <iqubic> Oh I see.
12:22:16 <iqubic> Well, I would do that. But I have to go to my University Class in a few moments.
12:22:27 <jsomedon> jle`: so here is how I got `g . f` and  I don't know where I did wrong:
12:22:32 <ski> jle` : "functions are instance of Functor class" is inaccurate. it's not functions, but function types. however, that's also inaccurate since you can't say `instance Functor (a -> b)', it must be `instance Functor (a ->)' (or `instance Functor ((->) a)'). so, it's the partially applied function type, which is an instance
12:22:33 <iqubic> Where I get the joy of programming in Jave. /s
12:22:58 <jsomedon> fmap operation function arg = function (operation arg)
12:23:04 <jsomedon> fmap operation function arg = function . operation arg
12:23:10 <jsomedon> fmap operation function = function . operation
12:23:14 <ski> er ..
12:23:17 <jle`> (i believe ski's message was addressed to jsomedon)
12:23:20 <ski> yes
12:23:22 <iqubic> Java sucks. If you want to hear me rant about it, I can give you an earful.
12:23:26 <ski> jsomedon : see longish message above
12:23:33 <iqubic> But now is not the time or place.
12:23:35 <jle`> jsomedon: hm, you might have mixed up the arguments of fmap. fmap f thething
12:23:50 <jle`> jsomedon: so thething is the thing you want to fmap over
12:24:00 <jle`> fmap f thething = \x -> f (thething x)
12:24:33 <jle`> note that `fmap f` has to leave the input type unchanged. `fmap f` will post-process the result of whatever thing you are fmapping
12:24:40 <jsomedon> ski : uh
12:24:57 <jle`> fmap :: (a -> b) -> (r -> a) -> (r -> b)
12:25:12 <jle`> fmapping with (a -> b) will turn an (r -> a) into an (r -> b)
12:25:20 <jle`> it'll process the result type, not the input type
12:25:41 <monochrom> ski: But sometimes we forgive ourselves for similar inaccurate casual wording, e.g., "the list monad". No one says the more accurate "the listness monad".
12:25:50 <jsomedon> jle`: the_thing::Functor_Instance_Type   --- you mean this?
12:26:19 <jle`> in general theThing :: f a
12:26:23 <jle`> in this case it's (r -> a)
12:26:30 <jle`> since our Functor, f, is (->) r
12:27:27 <jsomedon> jle`: what is r after (->), and also what is (->) is that like turning an infix operator into prefix which has name ->?
12:27:34 <jle`> yes
12:27:45 <jle`> jsomedon: the r is a type variable
12:27:55 <jle`> for example, for the (->) Int functor, theThing :: Int -> a
12:28:12 <jle`> fmap :: (a -> b) -> f a -> f b
12:28:13 <jsomedon> ah
12:28:18 <geekosaur> you can't partially apply the function arrow ("(r ->)" is illegal), so we write it in prefix form
12:28:24 <jle`> so if we choose `(->) Int` for f, we get:
12:28:30 <jle`> fmap :: (a -> b) -> (Int -> a) -> (Int -> b)
12:28:39 <jle`> > fmap show even 10
12:28:42 <lambdabot>  "True"
12:28:53 <jle`> in that case it's fmap :: (Bool -> String) -> (Int -> Bool) -> (Int -> String)
12:29:05 <jle`> it turns an (Int -> Bool) (like 'even') into an (Int -> String) (like 'even, then show the result')
12:29:25 <jsomedon> hmm let me re-read these all..
12:29:54 <jle`> this is why it's somewhat misleading to say 'functions are functors'
12:30:40 <jle`> the (->) isn't the functor, it's (->) Int, (->) Bool, (->) String, etc.; "functions from Int", etc.
12:36:18 <ski> monochrom : i would also react if someone said "lists are instance of Functor class" :)
12:36:41 <jsomedon> jle`: in your type notation: fmap :: (a->b) -> (r->a) -> (r->b)
12:37:24 <jsomedon> jle`: (a->b) is the operator that works on Functor, (r->a) is the original functor, (r->b) is the modified functor I get ?
12:37:38 <jle`> (r -> a) isn't quite "the functor", but rather the 'f a'-typed value
12:37:41 <jle`> i like to call it the fote
12:37:56 <ski> geekosaur, unfortunately not yet
12:38:04 <jle`> some people call it a functorial value or something
12:38:16 <jle`> but it's analogous to the [a] in map :: (a -> b) -> [a] -> [b]
12:38:18 <jsomedon> jle`: uh ok I should say a vvalue whose type is instance of Functor class?
12:38:31 <jle`> well, [a] and (r -> b) aren't instances of the Functor class
12:38:37 <jle`> it's tricky :)
12:38:47 <jle`> functor-value is often good enough that people know what you are talkinga bout
12:38:49 <ski> jsomedon : `r -> a' is not a functor, `(r ->)' is
12:38:59 <jsomedon> huh
12:39:02 <jle`> but i'm still trying to make fote happen
12:39:20 <jle`> jsomedon: yeah, remember [] is the Functor, Maybe is the Functor, IO is the Functor
12:39:24 <jle`> not [a], Maybe a, or IO a
12:39:39 <ski> (`r -> a' also isn't a "functorial value". it's a type, not a value ..)
12:39:52 <jsomedon> huh so the incomplete type notation is functor
12:40:00 <jsomedon> waht was the term for that,
12:40:05 <jsomedon> type fucntion?
12:40:08 <jle`> yeah :) i like to call it a parameterized type
12:40:11 <jle`> or indexed type
12:40:12 <geekosaur> partially applied type function, if you will
12:40:22 <ski> in `fmap :: (a -> b) -> f a -> f b', `f' is the functor, `f a' is not a functor
12:40:37 <jle`> technically speaking, its kind is * - *, or Type -> Type
12:40:56 <jle`> * -> *
12:40:57 <ski> in our case, `f a' is `r -> a' (or `(r ->) a', or `(->) r a'), so the functor is `(r ->)' (or `(->) r')
12:41:08 <jsomedon> ah
12:41:29 <jle`> it has to be some * -> *; where * is the kind of a fully saturated type constructor
12:41:59 <jle`> Functor is what we call a 'higher-kinded abstraction'. the instances of this abstraction are themselves parameterized on other types
12:42:14 <jle`> er, s/paramerized/expecting parameteriaztion ?
12:42:19 * ski dislikes the term "higher-kinded"
12:43:36 <jsomedon> so, when you guys say, paramed type is functor, you mean a paramed type is an instance of functor typeclass right?
12:43:42 <jsomedon> tyring to make sure I get it right
12:43:47 <ski> yes
12:43:52 <jsomedon> ok great
12:43:55 <jle`> yeah, we have instance Functor Maybe, instance Functor IO, instance Funcotr ((->) r)
12:44:08 <jle`> and if you look at the type of fmap it's also a big hint:
12:44:10 <jle`> :t fmap
12:44:12 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:44:18 <jle`> it's 'Functor f', not 'Functor (f a)'
12:44:29 <ski> `Maybe' is a parameterized type (is a function type). `Maybe' is an instance of `Functor'. `Maybe Integer' (not parameterized) isn't
12:44:52 <ski> `Either Integer' is also an instance of `Functor'
12:45:09 <ski> in face, for any type `e', `Either e' is an instane of `Functor'
12:45:15 <ski> s/face/fact/
12:45:30 <jsomedon> 1. Functor f => (a->b) -> f a -> f b
12:45:33 <ski> however, `Either' itself isn't an instance, despite also being parameterized
12:45:40 <ski> @kind Maybe
12:45:41 <lambdabot> * -> *
12:45:47 <ski> @kind Maybe Integer
12:45:49 <lambdabot> *
12:45:50 <ski> @kind Maybe String
12:45:52 <lambdabot> *
12:45:56 <ski> @kind Either Integer
12:45:57 <lambdabot> * -> *
12:45:59 <ski> @kind Either Integer String
12:46:00 <lambdabot> *
12:46:02 <ski> @kind Either
12:46:03 <lambdabot> * -> * -> *
12:46:35 <ski> only types that have kind `* -> *', that takes a single (concrete) type as parameter, before giving back a concrete type, can be instances of `Functor'
12:46:46 <jsomedon> 2. fmap operator (->) arg = (->) (operator arg) ?
12:47:01 <jsomedon> 2. fmap operator ((->) arg) = (->) (operator arg) ?
12:47:08 <ski> `Either' itself will "return" a new type function (not a concrete type), after having been passed a first type as argument
12:48:20 <ski> i think you're asking, is `fmap operator blah' of type `(->) resultType', if `operator' is of type `argType -> resultType', and `blah' is of type `(->) argType' ?
12:48:28 <toblorone> Hi, I'm doing a simple terminal file browser as a learning project and I have a question regarding Zippers. I build a tree representation of file system and I indicate the currently selected inode with a zipper like structure:
12:48:29 <toblorone> https://bpaste.net/show/7N7R
12:49:18 <toblorone> My question is, using this structure, how do I render it? Do I have to "rebuild" the tree from the zipper on each render call? That seems inefficient
12:49:48 <jsomedon> ski yes exactly
12:51:57 <jsomedon> so the way I thought is it should be like `map f [a] = [(f a)...]`
12:53:19 <jsomedon> `map f [1,2,3] = [(f 1),(f 2),(f 3)]`
12:53:29 <jsomedon> then
12:54:40 <ski> jsomedon : well
12:54:56 <CptCaptain> Hello, can someone recommend me a good low-level HTTP server library? Something that makes as few assumptions about the application one is writting and sits as close as possible to the RFCs
12:55:03 <ski> it's rather that `fmap operator blah' is of type `(r ->) resultType', if `operator' is of type `argType -> resultType', and `blah' is of type `(r ->) argType'
12:55:05 <jle`> toblorone: are you rendering it as like, a graphiz dot file maybe?
12:55:08 <ski> jsomedon : see the `r', there ?
12:55:38 * ski isn't sure what toblorone means by "render"
12:56:24 <jle`> maybe to a gui?
12:57:16 * ski was thinking, maybe some kind of tree pretty-printing
12:57:23 <toblorone> jle`: at the moment I'm simply rendering it to a string and printing it. What I mean by "render" is given the inode tree data structure I print a view of the filesystem like so: https://bpaste.net/show/9lQ0
12:57:23 <ski> (or, maybe, writing to disk ?)
12:57:45 <toblorone> ski, just tree pretty printing. Its meant to be an ascii interactive file browser
12:57:53 <ski> toblorone : anyway, you could use `guard' in `nodeDownSafe'
12:58:09 <ski> (and `replaceAt' isn't in that paste)
12:58:56 <toblorone> not using curses or anything like that. Also, my question is. given a zipper that is focusing on an aribitrary node in the tree, I'll have to move the zipper to the root node every time I want to render the whole tree, correct?
12:58:57 <jle`> toblorone: one way you can approach it is to write a pretty-printing function that takes the current indentation level as input
12:58:57 <ski> what is the interpretation of `inodeChildren :: [INode]', in case `inodeType = File' ?
12:59:38 <toblorone> ski: Yeah, that's potentially problematic. It's just an empty list at the moment
12:59:43 <ski> toblorone : not necessarily. you could probably render it directly from where you are, too (you'll still need to traverse the whole thing, if you want to print it all)
13:00:16 <toblorone> one sec I'll make an example
13:00:46 <ski> (but the "Do I have to \"rebuild\" the tree from the zipper on each render call?" is a good question)
13:01:58 <iqubic> What is a zipper?
13:02:10 <Clint> it's a thing that zips
13:02:11 <iqubic> I've seen the term float around.
13:02:30 <tabaqui2> what drawbacks will I get if I enabled library profiling but not executable profiling?
13:02:41 <iqubic> data ListZipper a = Zip [a] a [a]
13:02:45 <tabaqui2> Will my binary be slower?
13:02:45 <iqubic> Something like that?
13:02:55 <toblorone> ski: https://bpaste.net/show/mJlC
13:03:08 <iqubic> Is that a ListZipper where I can shift the focus left and right?
13:04:33 <ski> yes
13:04:58 <CptCaptain> If nobody can answer the question I had previously asked. Could someone point me into a direction where I might find an answer?
13:05:28 <tabaqui2> CptCaptain: http-client on hackage is pretty fine and simple
13:05:41 <tabaqui2> oh, sorry, you've asked about a server one
13:05:49 <ski> <ski> toblorone : not necessarily. you could probably render it directly from where you are, too (you'll still need to traverse the whole thing, if you want to print it all)
13:05:53 <iqubic> https://hackage.haskell.org/package/zippo-0.3/docs/Data-Lens-Zipper.html What even is this?
13:06:00 <tabaqui2> I guess there were a plugin for servant somewhere
13:06:26 <toblorone> ski: I'm confused. Wouldn't that ignore the parent directory in my example?
13:06:28 <iqubic> Oh it's this thing: http://brandon.si/code/zippo/
13:06:29 <CptCaptain> tabaqui2: Is the name a misnomer?
13:07:01 <toblorone> ski: like, let's say I change the name of the currently pointed to file. The values in the parent node wouldn't reflect this change
13:07:14 <tabaqui2> CptCaptain: what do you mean? 
13:08:02 <tabaqui2> CptCaptain: you could try this one http://hackage.haskell.org/package/servant-server
13:08:15 <tabaqui2> But I didn't use servant as much, actually
13:10:14 <iqubic> Of course when I look for something on Hackage, I find an edwardk package.
13:10:34 <toblorone> ski: also, what do you meant by using "guard" in that function? You mean guard :: MonadPlus m => Bool -> m ()?
13:10:38 <ski> yes
13:10:40 <orzo> Is it possible to make a pattern synonym that binds a value that is computed from the type rather than the runtime value?
13:11:14 <orzo> so, for example, the type includes a type-literal Nat, and i want to bind an Integer value to a variable in the pattern
13:11:14 <maerwald> servant isn't really that low-level, is it
13:11:17 <ski> toblorone : "I'm confused. Wouldn't that ignore the parent directory in my example?" -- not if you don't ignore the parent directory
13:11:23 <CptCaptain> maerwald:Doesn't seem so
13:11:42 <tabaqui2> Then I can only advise to inspect servant's dependencies
13:11:47 <c_wraith> orzo: seems like a thing you could do with an appropriate class constraint and extensions. 
13:11:47 <maerwald> probably check out wai and warp
13:12:14 <toblorone> ski: oh I can replace the if expression with guard? ok
13:12:25 <toblorone> err wait
13:12:27 <toblorone> can i?
13:12:30 * hackage ttl-hashtables 1.4.1.0 - Extends hashtables so that entries added can be expired after a TTL  https://hackage.haskell.org/package/ttl-hashtables-1.4.1.0 (erick)
13:12:55 <ski> toblorone : "The values in the parent node wouldn't reflect this change" -- quite possibly, they wouldn't even contain references to the current file/directory
13:13:05 <CptCaptain> maerwald: I've looked at wai. It makes quite a heavy assumption that you want to write a webserver. And leaves out large parts of the standard
13:13:44 <orzo> c_wraith: i don't know what you have in mind
13:14:07 <ski> toblorone : yes
13:14:27 <toblorone> oh I see how to use it. Nice
13:15:17 <ski> toblorone : currently, both those `do's are useless (the latter one has `in'-less `let's, which can be replaced by `in'-ful `let's)
13:15:31 <ski> toblorone : also, you could say
13:15:57 <ski>   let newStack = stackPush stack (n,idx)
13:15:57 <ski>       newNode = inodeChildren n !! idx
13:16:05 <ski> (no need for two `let's)
13:16:10 <c_wraith> orzo: view patterns extension to call the function and bind the result
13:16:30 * ski was suspecting something with view patterns
13:16:43 <c_wraith> and then all the correct pattern synonym stuff to enable/hide it. 
13:17:47 <orzo> hm, i think pattern guards are forbidden with pattenr synonyms, but maybe view patterns are allowed
13:17:54 <orzo> that seems an inconsistency
13:18:10 <orzo> i usually use pattern guards and not viewpatterns
13:19:15 <c_wraith> view patterns are a mess. I wouldn't use them without pattern synonyms. 
13:21:34 <c_wraith> pattern synonyms let you contain the mess and not have to think about it. 
13:24:09 <orzo> Well, i tried your suggestion and it compiles
13:24:18 <orzo> ViewPattern + PatternSynonym
13:24:49 <orzo> Is there no way to accomplish the same thing with PatternGuards?
13:25:11 <jle`> what is the code you are looking at
13:25:16 <jle`> that you are trying to replace with PatternGuards ?
13:25:27 <orzo> pattern CapturedNat x <- (natVal -> x)
13:25:30 * hackage poly 0.3.2.0 - Polynomials  https://hackage.haskell.org/package/poly-0.3.2.0 (Bodigrim)
13:26:24 <jle`> hm yeah, the syntax for pattern synonyms is sort of restrictive
13:26:43 <jle`> but honestly that looks as clean as it's going to get
13:29:32 <jle`> CptCaptain: : i think if you want the loooowest level, maybe look at network?
13:29:54 <CptCaptain> jle`: Network is just tcp. I want what's in between
13:30:15 <jle`> ah, you want HTTP
13:30:39 <CptCaptain> Sometimes I have trouble experssing myself 😓
13:30:59 <jle`> i think the de facto "low level building block" of haskell servers is wai
13:31:14 <jsomedon> 🎿 fmap::(a->b) -> f a -> f b, in case of function type, `a` of `f a` and `b` of `f b`, do they both refer to arg or return value?
13:31:17 <jle`> CptCaptain: no sorry, you said HTTP specifically, but i was thinking a bit lower than that
13:31:24 <jsomedon> ski :
13:31:30 <jsomedon> ski : fmap::(a->b) -> f a -> f b, in case of function type, `a` of `f a` and `b` of `f b`, do they both refer to arg or return value?
13:31:49 <jle`> CptCaptain: i think afaik almost all haskell server libraries are built on wai
13:32:10 <jle`> jsomedon: it depends on the instance of f
13:32:17 <jsomedon> huh
13:32:21 <jle`> but for f ~ (->) r, it's the return type
13:32:27 <jle`> for fmap :: (a -> b) -> (r -> a) -> (r -> b)
13:33:11 <jle`> CptCaptain: if you're looking for slightly higher level than wai, there's warp
13:33:18 <jsomedon> jle`: what does ~ mean in the code `f ~ (->) r`
13:33:36 <jle`> ah i mean it to say "is", like it can be substituted in for f
13:33:52 <jle`> it's a statement of type equality
13:35:06 <CptCaptain> jle`: Frankly wai was a bit too high level. For example it doesn't support absolute-form http requests
13:35:37 <jsomedon> jle`: `(->) a b` is same as `a -> b`? then here be is type of return value right?
13:35:44 <jle`> yeah
13:35:46 <iqubic> It is.
13:36:07 <roconnor> are there any known issue with Backpack on GHC 8.6.5 (versus GHC8.6.4)?  I'm having trouble using values from such modules.
13:36:07 <jle`> CptCaptain: ah, unfortunate :|
13:36:15 <CptCaptain> https://github.com/yesodweb/wai/issues/85
13:36:25 <CptCaptain> and the author does not seem to be inclined to implement them
13:36:39 <jle`> CptCaptain: in that case yeah, i think wai is the closest to what you want. note wai itself is implemented on top of network directly
13:37:05 <jle`> but it just isn't feature-complete
13:37:20 <CptCaptain> Ok, I just can't seem to find the part of wai that parses HTTP. It builds on network directly so it needs to do that
13:38:05 <jle`> that's a good question
13:38:34 <jsomedon> jle`: uhm does r in your code (r->a) (r->b) mean something? I mean when I read that I autocomplete r as returnedValue..
13:39:00 <geekosaur> some people use e instead, for "environment"
13:39:12 <geekosaur> "r" comes from the fact that the wrapped version of this is the Reader monad
13:39:20 <maerwald> CptCaptain: I belive some of the parsing might be done via http-types library
13:39:35 <jsomedon> huh k
13:39:36 <geekosaur> where the "r" is something to be "read"
13:39:41 <jsomedon> oh
13:39:53 <jle`> CptCaptain: it looks like it comes from https://hackage.haskell.org/package/http-types
13:42:20 <jle`> hm, but that doesn't contain the full picture
13:42:30 * hackage niv 0.2.0 - Easy dependency management for Nix projects  https://hackage.haskell.org/package/niv-0.2.0 (nmattia)
13:46:00 <CptCaptain> jle`: I'm about to write an E-Mail to someone
13:49:04 <iqubic> I've never really understood the point of the Reader(T) Monad.
13:50:03 <maerwald> iqubic: hiding a function argument
13:50:42 <jle`> mostly clean up clutter/line noise, i suppose
13:50:59 <maerwald> iqubic: and I agree, it's mostly pointless imo
13:51:07 <jle`> also make it easier to accidentally pass the wrong value downstream
13:51:24 <jle`> er sorry, make it harder to accidentally pass the wrong value downstream
13:51:37 <jle`> if you have multiple r values you might accidentally pass the wrong one if you're passing things down explicitly
13:51:47 <maerwald> jle`: why would you pass down the wrong value?
13:51:51 <jle`> ReaderT makes the space of possible bugs slightly smaller
13:52:02 <jle`> maerwald: well, you might have more than one value of type r
13:52:03 <maerwald> I think that's a clinical example 
13:52:05 <jle`> and you could pas down the wrong one
13:52:12 <jle`> and GHC wouldn't yell at you
13:52:33 <maerwald> if you're randomly passing down values down your call stacks, you have bigger problems than not using ReaderT
13:52:54 <jle`> it's not random; you have to pick one value to pass down, but you might pick the wrong one
13:52:58 <jle`> just by mistake
13:53:08 <jle`> this is a very common class of bugs...it happens all the time, heh
13:53:18 <jle`> doing x - y instead of y - x for instance
13:53:38 <jle`> or x + y instead of x + z, even
13:54:16 <jle`> ReaderT is one tool to take that choice out of your hands, to prevent a certain potential class of wrong-value-given bugs
13:54:31 <maerwald> ReaderT doesn't save you from ambiguous types like Int, String, etc
13:54:32 <jle`> how often have you accidentally swapped the values in a tuple like (Int, Int)?
13:54:50 <jle`> maerwald: it doesn't, but if you have more than one String or Int at play, you could accidentally pass the wrong one downstream
13:54:57 <maerwald> And I believe that isn't the reason anyone picks ReaderT
13:55:23 <jle`> ReaderT handles the passing-downstream process for you, so you don't have to do it explicitly
13:55:24 <geekosaur> generally I use it just to not have to explicitly pass something
13:55:35 <maerwald> geekosaur: exactly, it's laziness
13:56:07 <jle`> ok, i wouldn't say it is a major people reason people choose to use it, but i do think it is a concrete advantage
13:56:22 <geekosaur> it does avoid typoes. and in any case, isn't the point of haskell laziness? :p
13:57:25 <maerwald> now you want two ReaderTs with the same type
13:57:42 <jle`> a lot of times i have 'modified configurations' laying around in a where-clause of a function somewhere, and if i were to use explicit passing, i have to remember to pass the correct one downstream 
13:58:00 <jle`> ReaderT removes that decision; by default it always uses the one global configuration
13:58:16 <jle`> so yet another bug that would otherwise not be caught by the type checker
13:58:51 <jle`> it's even more common if you have ReaderT Int or ReaderT String; having stray Int's and String's lying around is very common
13:59:00 * hackage niv 0.2.1 - Easy dependency management for Nix projects  https://hackage.haskell.org/package/niv-0.2.1 (nmattia)
13:59:28 <maerwald> you can just newtype it then
13:59:55 <jle`> that is definitely an option that works for Int/String case
14:00:05 <jle`> but...they're all just valid options
14:00:26 <dmj`> yo dog, heard you like newtypes
14:00:36 <maerwald> what you got for me?
14:00:37 <jle`> different ways of solving the same problem
14:01:08 <maerwald> jle`: there's not much of a problem in the first place ;D
14:02:00 * hackage liquid-fixpoint 0.8.0.2 - Predicate Abstraction-based Horn-Clause/Implication Constraint Solver  https://hackage.haskell.org/package/liquid-fixpoint-0.8.0.2 (niki)
14:05:52 <maerwald> https://hackage.haskell.org/package/rio-0.1.12.0/docs/RIO.html the first step to realising that we don't need transformers... except we also don't need Reader ;)
14:06:03 <maerwald> guess what is left then :>
14:09:31 <iqubic> Yo dog, I heard you liked newtypes. I put them all in a zoo for you.
14:12:55 <jsomedon> jle`: `fmap :: Functor f => (a -> b) -> f a -> f b` given this code, `f a` are types like [a]? and in function's case, is it (a->x) or (x->a) or could be both depending on how I implement fmap?
14:13:57 <jle`> jsomedon: it'd be (r -> a), the a would have to be in the result type
14:14:14 <geekosaur> partial application of types works like partial appliation of functions, only the rightmost one is available
14:14:17 <jsomedon> jle`: ah so it never can be arg type
14:14:33 <geekosaur> type level flip sort-of exists but is not particularly convenient
14:14:59 <jsomedon> ok
14:15:01 <iqubic> In the function's case it is "instance Functor ((->) x)" which means that the 'f' of 'f a' is of type '(->) x' so f a is then '(-> ) x a' which can be seen as 'x -> a'
14:15:36 <jsomedon> jle`: then I don't get waht you mean it depends above..
14:15:50 <iqubic> The 'f a' for 'Functor ((->) x)' is (x -> a)
14:17:00 * hackage liquidhaskell 0.8.6.0 - Liquid Types for Haskell  https://hackage.haskell.org/package/liquidhaskell-0.8.6.0 (niki)
14:17:48 <jsomedon> so, here, a really means the return type
14:17:50 <jsomedon> then
14:18:02 <jsomedon> I think fmap = .
14:18:35 <jsomedon> well I mean fmap = (.)
14:18:48 <jsomedon> for function case
14:23:00 <jle`> yes :)
14:25:23 <jsomedon> jle`: so.. if magic happens and a actually can be arg type
14:25:57 <jsomedon> jle`: then fmap f g = g . f right/
14:26:03 <jle`> let's think about that
14:26:10 <jle`> we can write a function, let's not call it fmap
14:26:22 <jle`> notFmap :: (a -> b) -> (a -> r) -> (b -> r)
14:26:29 <jle`> does your thing typecheck?
14:27:08 <jsomedon> ...
14:27:25 <jsomedon> well at least I converted arg type from a to b but..
14:27:33 <jsomedon> looks like g is not defind to work with b tyep
14:27:45 <jsomedon> i need this g that work for b type
14:28:28 <jsomedon> anyway i should convert a type to b type using f first that's correct right?
14:29:20 <jle`> try writing it out
14:29:24 <jle`> notFmap f g x = _
14:30:12 <jsomedon> nfmap f g x = something :: type r
14:30:26 <jle`> indeed
14:30:58 <jsomedon> nfmap f g x = g some_type_b_value
14:31:08 <jle`> g takes an 'a'
14:31:09 <jsomedon> well but g is 
14:31:11 <jsomedon> yeah
14:31:15 <jsomedon> so it's not g
14:31:21 <jsomedon> but I only g
14:31:31 <jle`> indeed
14:31:33 <jle`> it's not possible :)
14:33:35 <iqubic> jle`: you'd need to make that a contravariant functor.
14:35:08 <A3mr> I want to define my own linked list datatype
14:35:31 <iqubic> data List a = Nil | Cons a (List a)
14:35:41 <iqubic> And that's actually how lists are defined in Haskell
14:36:24 <A3mr> and write a function to that checks for equality between two list values
14:36:25 <A3mr> data List a = None | Node a (List a) deriving (Show)
14:36:46 <A3mr> function to take these types and return a Bool 
14:36:46 <A3mr>  listEq :: Eq a => List a -> List a -> Bool
14:37:28 <iqubic> doesn't do it that way.
14:38:03 <iqubic> Write 'instance (Eq a) => List a where' instead.
14:39:34 <ski>   instance Eq a => Eq (list a)
14:40:25 <iqubic> Yeah.
14:40:27 <jle`> there's nothing wrong with writing listEq as a function...
14:40:30 <jle`> it's definitely a good learning exercise
14:41:24 <jle`> writing it only as a typeclass instance method introduces a bunch of issues as well that are irrelevant to the actual point of the exercise
14:41:43 <jle`> assuming this is a learning exercise :)
14:42:22 <A3mr> yes it is a learning exercise 
14:42:37 <A3mr> you guys are writing it as an instance of List a
14:42:56 <jle`> i would recommend writing listEq :: Eq a => List a -> List a -> Bool, if you're practicing how to write equality functions on it
14:43:06 <A3mr> but I wanted to write my own type and write a function that checks for equality 
14:43:31 <jle`> right :) is there an issue you're having while writing it?
14:45:04 <jsomedon> I would write normal function first to double check I am clear on the basic then move onto making it instance of Eq class :-p
14:45:49 <jsomedon> given `data List a = Nil | Cons a List`
14:46:37 <jsomedon> listEq :: Eq a => List a -> List a -> Bool
14:47:26 <jsomedon> listEq l1 l2 = (is there some function called all that I can use?)
14:47:48 <monochrom> Write your own recursion.
14:47:52 <jsomedon> lol ok
14:48:09 <jle`> jsomedon: if you're deifning your own type from scratch, you aren't going to be able to use functions other people use on it
14:48:15 <jle`> that's the 'point' :)
14:48:30 <jsomedon> yeeeah :-p
14:48:49 <jsomedon> so gotta check base case
14:49:04 <jsomedon> listEq [] [] = True
14:49:08 <monochrom> Or else you are looking at the XY problem of "let me convert List a to standard [a] then use [a]'s Eq"
14:49:54 <ski> @type all  -- jsomedon ?
14:49:55 <jsomedon> listEq x:xs [] = False
14:49:56 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
14:50:08 <jsomedon> ski : yes
14:50:15 <ski>   all :: (a -> Bool) -> [a] -> Bool  -- in the list case
14:50:23 <jsomedon> listEq [] y:ys = False
14:50:26 <ski> (not sure whether you could gainfully use it, though)
14:50:54 <jsomedon> listEq x:xs y:ys = x == y and listEq xs ys
14:51:01 <jsomedon> something liek that ^
14:51:24 <jsomedon> listEq x:xs y:ys = (x == y) && (listEq xs ys) -- this?
14:51:30 <ski> monochrom : or just (a) implement `allList :: (a -> Bool) -> List a -> Bool'; (b) ???; (c) profit !
14:52:12 <ski> jsomedon is missing some brackets (and is writing some redundant brackets, too)
14:52:22 <jsomedon> ..
14:52:50 <monochrom> That would be the XAF problem of "let me make my List an Applicative instance in the ziplist way so I have liftA2 (==) :: List a -> List a -> List Bool" followed by "I also make my List a Foldable instance so I have List Bool -> Bool by conjunction".
14:53:38 <monochrom> In short "I have problem X, I think I can solve it by solving 'subproblems' A (Applicative) and F (Foldable)"
14:53:46 <monochrom> XAF problem.
14:54:00 * hackage genvalidity 0.9.0.0 - Testing utilities for the validity library  https://hackage.haskell.org/package/genvalidity-0.9.0.0 (Norfair)
14:55:43 <monochrom> Next someone is going to suggest writing a Kan extension...
14:56:16 <monochrom> No that's too quaint. Someone is going to "reduce" list equality to HoTT path equivalence.
14:56:37 <jsomedon> so, [] is functor, (a ->) is a functor, is there other functor that doesn't look so obvious as functor?
14:57:04 <jsomedon> trying to write some fmap so that I get them right
14:57:06 <monochrom> newtype C a = C ((a -> r) -> r)
14:58:02 <monochrom> Err typo
14:58:19 <monochrom> newtype C r a = C ((a -> r) -> r).  instance Functor (C r) where ...
14:58:25 <jsomedon> newtype is like data with single data ctor?
14:58:41 <monochrom> Yes. Perhaps use "data" for now.
14:59:01 <jle`> how about data Proxy a = Proxy
14:59:18 <monochrom> I think they already did that 5 hours ago.
14:59:25 <jle`> oh :O that was the same person
14:59:57 <jsomedon> the type of no value?
15:00:02 <jle`> the type of one single value
15:00:11 <jle`> instance Functor Proxy where
15:00:29 <monochrom> and doesn't actually use the type parameter "a". The "Maybe but no Just".
15:00:39 <jsomedon> so no value wouldbe jsut "data Proxy a"
15:00:49 <jsomedon> ok I ll do them all
15:00:50 <jle`> yeah. that's also a Functor too :)
15:00:55 <jle`> data VoidF a
15:00:58 <monochrom> No no no, the value is "Proxy"
15:01:08 <jsomedon> monochrom:?
15:01:11 <jle`> VoidF is also a functor, i mean
15:01:23 <jle`> but Proxy is a well-established type from base, and it has one constructor Proxy
15:01:26 <monochrom> "data Proxy a = Proxy" you have a data constructor on the RHS called "Proxy".
15:01:31 <jsomedon> ah yes
15:01:44 <jle`> `data VoidF a` is also a Functor, instance Functor VoidF where ...
15:02:02 <jsomedon> so for data Proxy a = proxy
15:02:08 <jsomedon> so for data Proxy a = Proxy
15:02:44 <jsomedon> fmap f p = Proxy
15:02:57 <monochrom> Yeah.
15:02:58 <jle`> does it typecheck? and does it follow the laws?
15:03:16 <jle`> actually one neat thing in Haskell, you just need to check if `fmap id = id` to verify that it follows the laws
15:03:32 <jsomedon> i forgot to ask what do you mean by law?
15:03:33 <jle`> or fmap id x = x, for all possible x
15:03:36 <jle`> the Functor laws
15:03:47 <jsomedon> hmm I don't know such law..
15:03:49 <jle`> `fmap id = id`: fmapping 'id' should leave the input unchanged
15:04:00 <jle`> there are two of them: `fmap id = id`, and `fmap f . fmap g = fmap (f . g`)
15:04:11 <jle`> basically it's verifying that the functor instance is well-behaved and does what you want it to do
15:04:21 <jle`> for example, we could implement fmap "incorrectly" for lists:
15:04:24 <jle`> instance Functor [] where
15:04:27 <jle`>   fmap _ _ = []
15:04:31 <jsomedon> oh so my fmap should stick to this two laws
15:04:37 <jle`> this would typecheck and compile correctly.  but, it breaks the law `fmap id = id`
15:04:45 <jle`> because fmap id [1,2,3] is not [1,2,3]
15:04:56 <jle`> jsomedon: yeah, you should check that your fmap implementat follows the laws
15:05:08 <jsomedon> huh didn't know that, good to know
15:05:09 <jle`> typically this means just checking that `fmap id x = x`, for all possible constructors of x
15:05:26 <jle`> actually one neat consequence is that fmap id = id actually ensures that every type has exactly one 'legal' Functor instance
15:05:47 <jle`> as in, the only possible legal FUnctor instance for [] is fmap = map.  nothing else would be pass
15:05:49 <jle`> ing
15:06:10 <jle`> jsomedon: hm, you might not have seen these sorts of proofs before so i can walk you through proving your instance for Proxy
15:06:24 <jsomedon> jle`: please!
15:06:25 <jle`> you want to prove fmap id x = x, for all x. so we can go through all possible values of x :: Proxy a
15:06:30 * hackage liquidhaskell 0.8.6.2 - Liquid Types for Haskell  https://hackage.haskell.org/package/liquidhaskell-0.8.6.2 (niki)
15:06:33 <jle`> the only one we have is x = Proxy, so it's just one case to check
15:06:44 <jle`> and in your case, fmap f Proxy = Proxy
15:06:53 <jle`> er, in your case, fmap id Proxy = Proy
15:06:55 <jle`> *Proxy
15:07:00 <jle`> so indeed, your implementaiton follows the laws
15:07:39 <jle`> (usually for proving it for an ADT we would have to check more than one candidate for x, it's just really short in this case because there's only one constructor heh)
15:07:55 <jsomedon> so first law checked
15:08:12 <jle`> and the nice thing in Haskell is that you only need to verify the first law
15:08:13 <jsomedon> second is famp f. famp g = famp (f .g)?
15:08:54 <jle`> that's the second law yeah :) you can verify it too for fun if you want
15:09:27 <jsomedon> fmap f p = Proxy given this
15:10:13 <jsomedon> fmap g someP = Proxy, no matter what someP is, well someP is always Proxy
15:10:23 <jsomedon> so fmap g Proxy = Proxy
15:10:49 <jsomedon> then (fmap f) . (fmap g) Proxy is Proxy
15:10:56 <jsomedon> that's left handside
15:11:01 * hackage network 3.1.1.0 - Low-level networking interface  https://hackage.haskell.org/package/network-3.1.1.0 (dukerutledge)
15:11:28 <jsomedon> well right hand side, whatever f.g is, `fmap f.g p` is gonna return Proxy anyway
15:11:36 <jsomedon> so both handside are Proxy
15:12:37 <jsomedon> but, is there reason why proving first law is sufficient? is that because second law is kind True if first law is True?
15:13:29 <jle`> it's somewhat subtle. but it's that the second law can be proven in terms of the first law if you have parametric prolymorphism
15:13:49 <jsomedon> sound too clever stuff for me
15:13:51 <jsomedon> ..
15:14:03 <jle`> that is, if you state that your fmap function has to work for all (a -> b), then there is no way to construct an fmap that breaks the second law and not the firs tlaw
15:14:08 <jle`> for all a and for all b, that is
15:14:14 <jle`> it's what we call a 'free theorem'
15:14:27 <jle`> it's along the same lines as, say, seeing that there is only one possible function of type `a -> b -> a`
15:14:45 <jle`> and one possible function of type (a -> a), etc.
15:15:38 <syd> In practice you still need some testing because `error "not implemented yet"` is a valid implementation of all of these :D
15:15:44 <jsomedon> tbh my head now is not ready for that kind of stuff
15:16:24 <jsomedon> I have no clue what fmap looks liek fro VoidF 
15:16:30 * hackage cursor 0.2.0.0 - Purely Functional Cursors  https://hackage.haskell.org/package/cursor-0.2.0.0 (Norfair)
15:16:50 <jsomedon> it has no value at all
15:16:56 <syd> Wohoo, that's the new version of cursor and cursor-gen with fixes for the surrogate codepoints problem
15:17:06 <jle`> jsomedon: let's set it up
15:17:10 <jle`> fmap f x = case x of
15:17:16 <jle`> so, what cases do we have to handle?
15:17:20 <jsomedon> nothign
15:17:24 <jsomedon> no case at all
15:17:24 <jle`> yay
15:17:26 <jle`> we're done :D
15:17:28 <jsomedon> ?
15:17:30 * hackage cursor-gen 0.2.0.0 - Generators for Purely Functional Cursors  https://hackage.haskell.org/package/cursor-gen-0.2.0.0 (Norfair)
15:17:35 <jle`> we're done as soon as we handle all the cases. and so, we just handled all the cases.
15:17:37 <monochrom> Think of it as "case x of {}".
15:17:43 <jsomedon> ah so
15:17:49 <jsomedon> it's any function?
15:17:58 <jle`> not sure what you mean by any function
15:18:02 <jle`> it's one specific function
15:18:31 <jle`> now, verify the laws :)
15:18:46 <jsomedon> I mean, VoidF has no x in it
15:18:48 <jsomedon> so
15:19:02 <jsomedon> fmap f x = can literally do whatever it wants with x
15:19:06 <jsomedon> ?
15:19:07 <monochrom> "case x of {}" is conceivable because "case foo of {Nothing -> Nothing; Just x -> Just (f x)}" and "case bar of {_ -> Proxy}" are conceivable, and then you extrapolate along the line of "2 cases, 1 case, 0 cases".
15:19:09 <toblorone> how can i idiomatically execute a series of "Maybe a" functions and return the first one that succeeds, ignoring the rest? Something like [Maybe a] -> Maybe a. I can't find anything on hoogle
15:19:16 <jle`> toblorone: asum
15:19:20 <jle`> but also Maybe a's aren't functions
15:19:33 <toblorone> sure, but they aren't evaluated until needed, right?
15:19:39 <monochrom> If you have n data constructors then you expect "case x of { n clauses here }". Now let n=0.
15:19:58 <jle`> toblorone: yeah
15:20:25 <jle`> why do you say 'but', though?
15:21:38 <jsomedon> but the type still has tobe `fmap::(a->b) -> f a -> f b` right?
15:21:45 <jsomedon> well
15:21:50 <jle`> yes, here the type is fmap :: (a -> b) -> VoidF a -> VoidF b
15:22:07 <jsomedon> right was just about to write that..
15:22:24 <jsomedon> so x here is a VoidF
15:22:31 <jle`> `VoidF a`
15:22:37 <jsomedon> ah
15:22:50 <toblorone> jle': well I agree that they aren't "functions" but if I have a list of [Maybe a] expressions, they won't all be evaluated until needed. I say "but" because while they aren't technically functions they sort of behave how a function would in other languages
15:23:08 <jsomedon> :t fmap
15:23:10 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:24:39 <jsomedon> I really feel like I still need to return this VoidF b..
15:24:43 <jsomedon> and
15:24:49 <jsomedon> I don't have that
15:27:08 <jle`> you only have to return a VoidF b for every VoidF a that the user gives you
15:27:12 <jle`> that's the agreement
15:27:28 <syd> and if you enumerate every `VoidF a` that you could get
15:27:33 <jle`> same for Proxy, Maybe, List, etc. -- you return a Proxy b, Maybe b, LIst b, etc. that correpsonds to every List a/Proxy a/Maybe a that the caller gives you
15:27:34 <syd> you'd have a list of 0 posssibilities
15:27:37 <syd> that's what the case is for
15:27:56 <jle`> and in this case, this is what you just did. you gave a VoidF b, for every VoidF a that the user could give you
15:28:30 <jsomedon> ok in that sense I can make peace with this type notation
15:34:00 <jsomedon> jle`: btw, in function's case, should I say the functor as "partial function type that's missing return value type"? seems too long to say
15:47:17 <EvanR> jsomedon: "Reader"
15:47:34 <EvanR> computations done with a read-only context
15:47:48 <jsomedon> f g = some-function-code-comes-here -- can I somehow deconstruct g based on g's type?
15:48:02 <jsomedon> so say g::a->b
15:48:13 <EvanR> not possible
15:48:16 <jsomedon> ok
15:48:19 <EvanR> a and b could be anything
15:48:26 <hpc> you need a type class
15:48:36 <hpc> or something along those lines
15:49:00 <hpc> that kind of thing is exactly what parametricity disallows
15:49:22 <jsomedon> so the context is, I have this type:  newtype C r a = C ((a -> r) -> r)
15:49:30 <jsomedon> I am trying to write fmap for this..
15:50:42 <hpc> jsomedon: try this
15:50:43 <hpc> :t fmap
15:50:44 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:50:51 <hpc> jsomedon: take that type, let f = (C r)
15:51:05 <hpc> jsomedon: then translate from (C r a) to ((a -> r) -> r) in the type
15:51:27 <hpc> you'll have some big thing like (a -> b) -> ((a -> r) -> r) -> ...
15:51:33 <hpc> and then just try writing that function
15:52:12 <hpc> once you have that, work out the data constructor-ing that needs to be done to make it operate on your C type
15:53:44 <Kaiepi> i'm trying out haskell a second time after finding it too hard the first time and i'm finding it much easier this time around
15:53:45 <EvanR> (a -> b) -> ((a -> r) -> r) -> (b -> r) -> r
15:53:56 <dsal> Does anyone work with websockets?  I know ~nothing about ws, but I can't readily find a client.
15:54:08 <EvanR> it's a box of 3 puzzle pieces
15:54:28 <monochrom> >:)
15:54:31 <EvanR> and whoever gave it to you assures you there's a solution
15:54:41 <monochrom> That's me
15:54:41 <EvanR> 1) do you trust them
15:54:50 <jsomedon> ..
15:54:50 <EvanR> 2) ???
15:54:52 <EvanR> 3) profit
15:55:32 <jsomedon> well I was asking if there is some no-so-obvious functor I can try write some fmap and this fine man gave this puzzle
15:55:59 <monochrom> You could trust me. But you could also look up "the Cont monad" and find that it's true. For all r, "C r" (or "Cont r") is a functor, applicative, monad.
15:56:20 <jsomedon> uh, didn't learn applicative and monad yet
15:56:34 <dsal> Ugh.  https://linkerd.io/2018/07/06/conduit-0-5-and-the-future/ <- conduit 0.5.0 supports websockets.  Except it's a new, dumb thing unrelated to haskell.
15:56:42 <monochrom> Sure, no worries, but if "foo is a monad" then "f is a functor" too.
15:57:02 <EvanR> people regularly do 1000 piece puzzles. Come on this has only 3
15:57:36 <EvanR> (if programming involved tangible parts... maybe more people would do it, and do it right?)
15:58:06 <jsomedon> are you guys tricking me to do something impossible on my knowledge level or is it really feasible to figure out
15:58:13 <hpc> it's 100% possible
15:58:16 <jsomedon> alright
15:58:37 <EvanR> it's possible in this case, sometimes no
15:58:46 <EvanR> there are types that can't be Functor
15:59:00 <EvanR> sometimes they are contravariant functors instead, which are backwards
15:59:16 <hpc> you'll have to think a bit, but the type has nothing but type variables and (->)
15:59:34 <hpc> so the same kind of things you do to figure out that (a -> b -> a) is const will apply
15:59:47 <monochrom> This is actually not entirely abstract for those people who dabble in linear algebra. You can instantiate "a" and "b" to vector spaces over a field F, and instantiate "r" to that field F, then "(a -> F) -> F" is the dual-dual-space of a, "(b -> F) -> F" is the dual-dual-space of b, and we are saying that converting a vector space to its dual-dual-space is a functor.
16:00:39 <EvanR> if only math class told me that "linear functionals" and such things were really higher-order functions
16:00:59 <EvanR> and differential operators
16:01:23 <EvanR> are higher order funtions
16:01:33 <Kaiepi> sorry if i'm interrupting, but what do people typically use to write unit tests in haskell?
16:01:36 <hpc> so much of my college math life would have been better with a few type signatures thrown in there
16:02:11 <monochrom> I threw in my own type sigs. It's how I survived. :)
16:02:31 <EvanR> i'm still waiting on someone to figure out the type signatures for QFT
16:02:43 <monochrom> When I learned Lisp I wrote type sigs in my comments.
16:03:07 <EvanR> monochrom: but that's impossible. Lisp cannot be statically typed11111
16:03:25 <EvanR> (which proves that static typing is wrong)
16:03:33 <hpc> lisp is dynamic and non-linear, like a train wreck :D
16:03:49 <monochrom> Ah but I was not writing arbitrary Lisp. I was writing basically "myfunc xs = map foo xs".
16:04:13 <hpc> i wrote lisp the same way i wrote haskell, when i had to for a class
16:04:20 <monochrom> Except "map" in Lisp was annoying to use so I wrote my own recursion.
16:04:27 <hpc> minus the type signatures, more about... that
16:04:31 <hpc> and folds
16:04:34 <jsomedon> (a -> b) -> C ((a->r)->r) -> C ((b -> r) -> r)   -- this ? the type of fmap?
16:04:40 <jackdk> Kaiepi: I usually use tasty to structure my tests
16:04:49 <hpc> jsomedon: no
16:05:15 <hpc> jsomedon: so, the type of fmap when operating on C stuff is
16:05:23 <hpc> (a -> b) -> C r a -> C r b
16:05:36 <Kaiepi> aight, i'll take a look at tasty
16:05:45 <hpc> jsomedon: but since you have the definition of C, you can expand it to
16:05:55 <monochrom> This is why when someone says "Lisp is functional" I'm like "you haven't used Lisp for real".
16:05:56 <hpc> (a -> b) -> ((a -> r) -> r) -> ((b -> r) -> r)
16:06:25 <EvanR> if you can implement (a -> b) -> ((a -> r) -> r) -> (b -> r) -> r, then I claim you are done by first removing C, then putting it back
16:06:38 <hpc> jsomedon: you can consider this, which is an easier sub-problem
16:06:44 <jsomedon> ok
16:06:47 <hpc> jsomedon: and then the other half of the problem is adding back C
16:07:00 <monochrom> The bar for "functional" is at least Scheme in which "(map foo xs)" is just that, no hoops to jump through.
16:07:13 <jsomedon> I need some food first, my brain is starving-crying
16:07:14 <EvanR> which lisp were you using
16:07:22 <monochrom> Common Lisp.
16:07:26 <EvanR> ah
16:07:32 <EvanR> the big kahuna
16:07:57 <monochrom> I didn't use the full power to be sure. It was just a "play Chess" assignment.
16:08:47 <monochrom> So call it "Common Lisp for beginners".
16:10:00 <monochrom> " (a -> b) -> ((a -> r) -> r) -> (b -> r) -> r" is understandably overwhelming. This is why people insist on "explain in plain English like I'm 5".
16:11:05 <monochrom> With "explain in plain English like I'm 5" a lot of difficult things are inexpressible therefore by Sapir-Worf you don't have to learn the difficult things therefore everything is easy to learn.  IOW head in sand.
16:14:40 <monochrom> Formal logic is the only way to express and learn the more difficult things.
16:16:02 <monochrom> With formal logic, "(a -> b) -> ((a -> r) -> r) -> (b -> r) -> r" can be managed by saying: this function takes 3 parameters, 1st parameter has type a->b, 2nd parameter has type (a->r)->r, 3rd parameter has type b->r.  I have to map them to a value of type r.
16:16:55 <monochrom> The hard part is how to use the 2nd parameter.
16:17:24 <freusque> hello. can someone provide an example of using HasConstraints from http://hackage.haskell.org/package/generic-lens-1.2.0.0/docs/Data-Generics-Product-Constraints.html ?
16:17:40 <freusque> The readme for that package provides an example of usage of constraints'
16:18:10 <freusque> But I fail to understand how to make the class with *-> *-> Constraints work
16:18:20 <freusque> anyone used this?
16:22:06 <Nevoic> I can seem to figure out how to shorten this line of code: ```text ([i|Hey #{person}!|] :: Data.Text.Internal.Lazy.Text)```
16:22:49 <Nevoic> Right now I'm doing `import Data.Text.Internal.Lazy` at the top. When I do `import qualified Data.Text.Internal.Lazy as L` and then `:: L.Text` it doesn't compile because of ambiguous type classes.
16:23:14 <Nevoic> my bad, overlapping instances actually.
16:23:40 <Nevoic> I thought `qualified & as` was just renaming a module, but it's introducing a new compile time error, so it must be doing something on top of that that I fail to understand.
16:23:42 <glguy> Nevoic: Don't import the Internal modules
16:24:08 <Nevoic> Alright. When I just do `:: Text` it fails to compile due to a type mismatch.
16:24:12 <glguy> delete the ".Internal" portion
16:24:26 <glguy> so: import Data.Text.Lazy and not import Data.Text.Internal.Lazy
16:24:46 <Nevoic> It Alright, did that. Still having the same issue.
16:25:01 <Nevoic> I can do `:: Data.Text.Lazy.Text`, but I still can't do `import qualified Data.Text.Lazy as L`
16:25:12 <Nevoic> and then `:: L.Text`
16:25:18 <glguy> Then you just have multiple problems in your file
16:26:07 <Nevoic> lit
16:27:28 <glguy> If you want to put the file and error messages on a pastebin website (not pastebin.com) someone could probably take a look
16:32:02 <Nevoic> I'll play around with it a bit more, sounds like it's more involved than a simple fix, was just hoping I was overlooking something simple and stupid.
16:37:59 <jellostahps> https://pastebin.com/QgsCv7Ca
16:38:15 <jellostahps> what 'function' parameter is lin 11 sfMap taking in?
16:38:24 <jellostahps> *line 11
16:39:04 <jellostahps> I see (*) and n, but what is n multiplying?
16:40:08 <ski> that is a type error
16:40:30 <jellostahps> which part of it?
16:40:36 <ski> line 11
16:40:50 <jellostahps> a type error on (*)>
16:40:52 <ski> `sfMap(*) n' is a type error
16:41:20 <ski> `n' is of type `Int', doesn't match the `SF a' that `sgMap' expects
16:42:19 <jsomedon> hpc: monochrom: I am trying to figure out how can I make use of f, so if I have `fmap f cra_value = ...` on left hand side, how can I write right hand side so that it contains cra_value and f?
16:42:24 <jellostahps> it gets SF a is from the line 11 recursive call
16:42:41 <ski> (and then, even it'd work, `sfMap(*) n' would be of type `SF b', for some type `b', and that doesn't match `x -> y' (`sfMap(*) n' is not a function), hence can't be applied to `safeFact (n-1)''
16:43:02 <ski> jellostahps : i know
16:43:24 <ski> jellostahps : you should pass two things to `sfMap', not three
16:44:25 * ski idly wonders which type jsomedon is defining `fmap' for, now
16:44:51 <jsomedon> ski : so monochrom gave this puzzle:
16:45:02 * ski is puzzled
16:45:10 <jsomedon> newtype C r a = C ((a -> r) -> r)
16:45:19 <ski> ah, ok
16:46:53 <jsomedon> I found that's difficult to figureout fmap's type, so people suggest me figuring out fmap's code first, and gave me the type
16:47:05 <jsomedon> (a -> b) -> ((a -> r) -> r) -> ((b -> r) -> r)
16:47:32 * ski . o O ( "Follow the types where they lead. Follow the types where they lead. Follow, follow, follow, follow -- follow the types where they lead !" )
16:47:48 <ski> yeap
16:47:53 <jsomedon> hmmm
16:48:19 <monochrom> No, I thought everyone said use the type to get code.
16:48:42 <monochrom> And everyone wrote down fmap's type already.
16:48:48 <ski> so, what's the type of `f' and `cra_value' and `...' ?
16:48:54 <jsomedon> ah
16:49:13 <jsomedon> cra_value:: C r a
16:49:36 <jsomedon> just made up some varibale name
16:49:52 <ski> good
16:50:12 <laudecay> hello my loves
16:50:32 <laudecay> ugh my nick colors are not working i crie everytiem brb
16:50:45 * ski blinks
16:51:30 <ski> hello again, laudecay
16:51:32 <laudecay> much prettier
16:51:34 <laudecay> <3
16:51:46 <laudecay> my jane street internship finally ended and i am free 
16:51:48 <laudecay> to use haskell
16:51:50 <laudecay> and not ocaml
16:51:56 <ski> cool ! :)
16:52:07 <laudecay> and not get fussed at by my manager for complaining about lack of features in ocaml
16:52:09 <laudecay> i missed this
16:52:24 <EvanR> complaining about complaining
16:52:35 <EvanR> meta level complaint
16:52:36 <laudecay> literally actually got fussed at by my manager for making too many jokes about how sad i was i couldn't make everything horrifically pointfree
16:52:40 <laudecay> terrible
16:53:13 <ski> discourse deconstruction
16:53:13 <jellostahps> ski: Does line 11 work in the context of being a partial function? https://wiki.haskell.org/Partial_application
16:53:16 <jellostahps> https://pastebin.com/QgsCv7Ca
16:53:24 <laudecay> i just want . and $ tbh
16:53:26 <laudecay> all a girl needs
16:53:40 <ski> laudecay : itym s/pointfree/pointless/
16:53:44 <laudecay> rawr
16:53:53 * ski is fond of pointless things ..
16:53:58 <laudecay> me toooooooo
16:54:02 <EvanR> I kind of hate $
16:54:23 <ski> EvanR, there's still hope for you
16:54:26 <EvanR> unless its used somewhere in this form ($)
16:54:40 <EvanR> then at least it looks like a coin
16:54:58 <Axman6> laudecay: how was Jane Street?
16:55:08 <ski> jellostahps : "partial function" has nothing to do with "partial application"
16:55:33 <jellostahps> oh
16:56:10 <ski> EvanR : `($ blah)' can be okay
16:57:09 <laudecay> Axman6: it was like good in some ways not good in others
16:57:23 <laudecay> i was not a good culture fit at all but i could see how some people could really enjoy it
16:58:13 <EvanR> what is the equivalent of $ in ocaml
16:58:23 <laudecay> if you have a problem with capitalism and finance, or you think you potentially could, you should read marx before you interview
16:58:30 <laudecay> EvanR: a lot of parens and sadness
16:58:40 <laudecay> fuckery
16:58:45 <laudecay> new function definitiona
16:58:47 <laudecay> lambdas
16:58:49 <laudecay> hell
16:59:23 * ski . o O ( Ayn Rand )
16:59:35 <laudecay> oh boy
16:59:44 <laudecay> but
16:59:54 <laudecay> yeah they are all really on the capitalism train there and it was exhausting for me
17:00:04 <int-e> ski: https://xkcd.com/1049/
17:00:11 <laudecay> like "we don't need to do anything about climate change the market will take care of it!!" kind of shit
17:00:24 <monochrom> What if I have the opposite problem: I have problems with Marx?
17:00:27 <laudecay> "poverty is not a problem because a rising tide something something reaganomics"
17:00:40 <laudecay> then you'll probably be okay at jane street 
17:01:04 <EvanR> sounds like a healthy forum for debate
17:01:08 <laudecay> it's just really really really capitalist and that makes me personally highly uncomfortable
17:01:08 <EvanR> NOT
17:01:17 <laudecay> yeah that was pretty much it
17:01:29 <ski> int-e : heh :)
17:01:31 <int-e> laudecay: sounds predictable though..
17:01:36 <laudecay> also some of my coworkers were like weirdly nonconfrontational in a way that ended up causing more problems
17:01:48 <laudecay> but i think that's just nerds and their social skills
17:02:16 <EvanR> next time i have a job, that'll be me
17:02:20 <EvanR> head down, no opinion
17:02:27 <laudecay> but id never had an issue @ work where a manager or HR was ever involved, at multiple workplaces over like many years, but it happened multiple times here
17:02:44 <MarcelineVQ> jsomedon: making progress on your haskell related topic? :>
17:02:47 <laudecay> no they'd have a problem with something really minor and escalate it to a manager or HR in a really dramatic way
17:02:59 <laudecay> see: my haskell jokes, if you're annoyed by it just tell me and i'll stop?
17:03:04 <boj> laudecay: sounds cool, but very not Haskell related
17:03:06 <laudecay> yeah
17:03:07 <jsomedon> MarcelineVQ: ah still trying to figure out
17:03:08 <laudecay> lets talk about pl
17:03:31 <monochrom> There is #haskell-offtopic that could use some traffic I actually understand.
17:03:42 <ski> MarcelineVQ : probably too busy thinking about how yo make `Atlas' into a `Functor'
17:04:34 <MarcelineVQ> ski: You would just write your code in a way that a single function drags on for 13 pages.
17:04:53 * ski idly wonders how Haskell jokes are not Haskell-related ..
17:06:06 <ski> MarcelineVQ : hm, can i make it thirteen `where'-levels deep, as well ?
17:06:43 <MarcelineVQ> But it's not deep...
17:07:02 <ski> well, let's make it deep, then !
17:07:04 <laudecay> everything is haskell related
17:07:08 <laudecay> just only talk about haskell 
17:07:17 <laudecay> (im sorry @ anyone who follows me on twitter)
17:07:31 <ski> you're ok
17:07:37 <ski> (i don't follow anyone there)
17:07:40 <MarcelineVQ> laudecay: It's their own fault for using it.
17:07:43 <laudecay> how do i get stack ghci to be colorful and pretty
17:08:21 <laudecay> i just want pretty colors
17:08:24 <EvanR> use idris
17:08:28 <laudecay> rawr
17:08:29 <MarcelineVQ> stack ghci uses color just fine on my terminal
17:08:36 <laudecay> hmmmmmm
17:08:38 <ski> you might set prompt to include SGR codes for setting background to orange, and foreground to dark blue ?
17:08:39 <laudecay> echo $TERM ?
17:08:41 <monochrom> And I, just one single pretty colour. >:)
17:08:43 <MarcelineVQ> maybe you need an update, not sure
17:09:00 * hackage tskiplist 1.0.1 - A Skip List Implementation in Software Transactional Memory (STM)  https://hackage.haskell.org/package/tskiplist-1.0.1 (PeterRobinson)
17:09:01 <MarcelineVQ> laudecay: xterm-256color it says
17:09:04 <laudecay> okie
17:09:05 <laudecay> hmmm
17:09:30 * ski hopes MarcelineVQ's terminal isn't lying, for their sake ..
17:09:38 <laudecay> same $TERM
17:09:40 <laudecay> but
17:09:50 <laudecay> imma stack update and hope for the best im not in a tmux or anything
17:09:56 <laudecay> regardless my tmux colors are ok
17:10:19 <jsomedon> monochrom: some hint please, it's prettty difficult to figureout the code..
17:10:30 <monochrom> Actually mine also says "xterm-256color" I think it's an ubuntu default.
17:10:42 <laudecay> im not ubuntu
17:10:49 <laudecay> but
17:11:00 <MarcelineVQ> jsomedon: it is fairly difficult, keep at it even if you don't get any hints
17:11:02 <laudecay> that would just be like terminal color modes being weird w ansi color codes
17:11:02 <ski> @hackage ansi-terminal
17:11:02 <lambdabot> http://hackage.haskell.org/package/ansi-terminal
17:11:13 <laudecay> who knows whats happening in the prelude
17:11:26 <ski> jsomedon : what is the type of `...' ?
17:12:09 <jsomedon> ski you mean in my code above? fmap f cra_value = ...
17:12:33 <jsomedon> ski ::C r b
17:12:46 <monochrom> fmap f (C g) = C (\k -> ...).  Now you have received f::a->b, g::(b->r)->r, k::a->r.  In the "...", you write an expression of type r.  You know nothing about a,b,r, so your hands look tied.  But since for example f::a->b, you have a bunch of functions, you can always use function application, function composition, and moar lambdas.
17:13:13 <ski> jsomedon : how can you construct a value of type `C r b'
17:13:26 <laudecay> https://ibb.co/gjDNd6v
17:13:26 <ski> ?
17:13:29 <laudecay> eeeeeeEEEEEEEEEEE
17:13:33 <laudecay> .ghci is my FRIEND
17:13:57 <EvanR> bright green and brighter green should be enough for anyone
17:14:09 <laudecay> but pretty purple :///
17:14:37 <laudecay> my weechat's gorg too :) base16-embers theme off terminal.sexy on everything
17:15:16 <jsomedon> ski : C \function_that_takes_btype_returns_rtype -> after_some_code_return_some_rtype_value ...
17:15:30 <monochrom> No, 540nm should be enough for everyone :)
17:15:47 <ski> jsomedon : sounds good. now write / fill in some code for `after_some_code_return_some_rtype_value'
17:15:56 <monochrom> (wavelength of somewhere in the green band)
17:16:05 <monochrom> <-- monochromatic :)
17:16:19 <laudecay> <--- colorful
17:16:45 <laudecay> my outfit is all greyscale but my terminal and eyeliner are GLORIOUS
17:17:10 <laudecay> anyway
17:17:13 * ski refrains from mentioning music associations
17:17:20 <laudecay> what's good haskell autocomplete/syntax highlighting in atom?
17:18:06 <monochrom> Actually make it 532nm because it's the typical green laser pointer. (I have one.)
17:19:02 <ski> jsomedon : you might also use some pattern-matching ..
17:26:42 <koz_> Can someone help me with some runST-related confusion? https://gist.github.com/kozross/aab5030c5680a0a704add27682b9cb17
17:27:12 <jsomedon> monochrom: in your hint code, you mean g::(a->r)->r and k::b->r right?
17:27:49 <monochrom> Oh oops, yeah.
17:28:23 <c_wraith> koz_, I've run into that before. pattern matching has an unexpected side effect - it makes type variables rigid. 
17:28:43 <koz_> c_wraith: So basically I _can't_ do this?
17:28:57 <c_wraith> koz_, or at least, pattern-matching with a case does. 
17:29:08 <ski> laudecay : never tried, no idea. sorry ..
17:29:10 <koz_> c_wraith: Unwrapping a newtype counts as pattern-matching with a case?
17:29:40 <c_wraith> koz_, doing so on the lhs of a function definition does. 
17:29:52 <c_wraith> try unwrapping it in a let/where
17:29:59 <koz_> c_wraith: OK, thanks, will try.
17:30:48 <koz_> c_wraith: Weirdly, that actually works.
17:30:54 <c_wraith> yep! 
17:30:59 <koz_> Chalk that up to 'ST is weird, lol'.
17:31:13 <c_wraith> really it's "higher rank types are weird" 
17:31:20 <c_wraith> but... close enough. 
17:31:39 <koz_> Well, that gets me where I wanna be, and the user won't see it, so I guess it's fine.
17:31:41 <koz_> Thanks!
17:31:58 <koz_> So only pattern-matching with a case creates this rigidity?
17:32:21 <c_wraith> yeah. sometimes it's what you really want. 
17:33:34 <koz_> Just not here.
17:33:59 <c_wraith> like, if you use the same type variable in multiple spots, matching them all at once in a case (or function parameters) lets you know that the things with the same type are all the same type. 
17:34:46 <c_wraith> but sometimes it means you need to move a pattern match out of the lhs because it restricts the type too much. 
17:38:40 <c_wraith> so... as usual, ghc gives you tools to do the two different things you might want to do, but it isn't totally obvious up front that in this case they'll behave that differently. 
17:39:00 <jsomedon> monochrom: so I lego-built a code with matching type with zero clue if it's correct or not: g (k.f) :: r
17:39:11 <monochrom> Yes.
17:40:13 <jsomedon> monochrom: what does this even mean, I need soemtime to make some sense of it
17:41:53 <c_wraith> you could online the definition of (.). that's often a useful step when you're still getting used to it. 
17:42:05 <c_wraith> *inline
17:42:46 <monochrom> I have an integer in mind. I will keep it secret and not tell you. But you can query me with various predicates (Integer -> Bool), and I am happy to tell you the answer of using your predicate on my secret integer (my answer has type Bool).
17:43:47 <monochrom> For example you can ask "is your number even?". That means you give me the predicate "even :: Integer -> Bool".  I'll answer "True :: Bool".
17:44:01 <MarcelineVQ> jsomedon: wow nicely done
17:44:31 <monochrom> For example you can then ask "is your number bigger than 7?". That means the your predicate is "\x -> x > 7". I'll answer "False".
17:44:33 <monochrom> etc. etc.
17:44:53 <jsomedon> MarcelineVQ: thanks man, but have no clue what it means..
17:44:56 <monochrom> So I'm acting like some blackbox function of the type (Integer -> Bool) -> Bool.
17:45:24 <monochrom> Now generalize from Integer to "a", Bool to "r".  That's the meaning of (a->r)->r.
17:46:17 <monochrom> Now suppose someone gives you a function f::Integer->Char.  Can you convert me to (Char->Bool)->Bool?  That's fmap.
17:47:18 <monochrom> (if you also generalize from Char to "b")
17:50:18 <jsomedon> sounds very vector-space-y..
17:50:37 <monochrom> For clarity maybe don't convert me, but rather have another person being the new game host but they secretly use me as their backend.
17:53:00 <monochrom> In other words say Charmine is a new game host who has a secret character in mind and won't tell you what it is.  (Actually, the secret character is just my secret number converted to character by the ord :: Int -> Char function. Oh, also pretend my secret number is Int instead and within range.)
17:53:31 <monochrom> How does Charmine play the (Char->Bool)->Bool game with you, by ripping me off in the back?
17:53:59 <jsomedon> that idea may work bloody well
17:54:34 <monochrom> You submit a Char->Bool predicate, call it k.
17:57:08 <monochrom> She doesn't know my secret number. But she knows she can submit this query to me: k.ord, i.e., (\n -> k (ord n))
17:58:09 <monochrom> IOW she can ask me: "if you convert your secret number to a character by ord, like unicode, will the character satisfy predicate k?"
17:58:49 <monochrom> That will be "g (k . ord)", where g is me, i.e., of type (Int->Bool)->Bool
17:59:20 <monochrom> I will answer "True" or "False". She plagiarizes that as her answer to you.
18:00:00 <monochrom> So that's the meaning of "g (k . f)" you wrote there.  (If you also generalize from "ord" to arbitrary conversion "f")
18:00:09 <jsomedon> hmm
18:01:21 <monochrom> If I am a website hosting this game, you can build your own website ripping me off by this and superficially present a different type of secret.  This is the bane of "web service". >:)
18:02:46 <monochrom> In fact maybe I should exactly build that website
18:03:12 <jsomedon> but don rip urself
18:03:38 <jsomedon> this explanation is really helpful thanks man
18:08:27 <jsomedon> so this ord function
18:08:46 <jsomedon> I don't really see what it's doing?
18:08:47 <jackdk> monochrom: I recall reading somewhere about people breaking captchas in exactly this way - by proxying them to some other service people wanted to use and relaying visitor responses
18:09:32 <monochrom> Charmine is doing "fmap ord monochrom"
18:09:34 <jsomedon> ah nvm, it's Int -> Char
18:10:13 <jsomedon> oh
18:11:19 * monochrom writes new pedagy paper "anthropomorphization of gamification"
18:20:27 <jsomedon> hmm still trying to wrap my mind over it but it's much much more clear
18:20:40 <jsomedon> so k really can be anything
18:20:58 <jsomedon> in fact that's a varibale 
18:21:45 <monochrom> In the game story, you can ask Charmine "is your character an upper case letter?".  That will be using "isUpper" for k.
18:22:27 <monochrom> She is going to ask me "hey mono, if you covert your secret number to a character by ascii/unicode, will it be an uppercase letter?"
18:22:54 <monochrom> That will be using "isUpper . ord" as the predicate she submit to me.
18:23:11 <monochrom> I'm going to answer "no". She's going to answer "no" to you too.
18:23:39 <monochrom> (My secret number is 4. That's why it's even, not bigger than 7, and not an uppercase letter if converted by ascii.)
18:25:43 <iqubic> what are we talking about here?
18:25:59 <monochrom> Cont
18:25:59 <jsomedon> lol it's just some puzzle monochrom gave me hours ago
18:26:17 <iqubic> Cont is cool.
18:26:24 <iqubic> monochrom: What's the puzzle?
18:26:32 <monochrom> how to implement "instance Functor (Cont r)" and more importantly what does it mean.
18:26:48 <iqubic> How does that relate to the Game Story?
18:27:01 <monochrom> It's a game-theoretic semantics.
18:27:26 <iqubic> Also, what is the definition of Cont here? Are we using "Cont r a = (a -> r) -> r"?
18:27:31 <monochrom> Yes.
18:27:48 <jsomedon> so this stuff is called Cont?
18:27:52 <monochrom> Yes.
18:27:53 <iqubic> Yes.
18:28:14 <jsomedon> I wonder if searching Cont gives me something ..
18:28:45 <jsomedon> Cont haskell gives me somethign called Cont monad
18:28:46 <monochrom> If you say "cont haskell" it may work greatly
18:28:52 <monochrom> Yes, that one.
18:29:01 <jsomedon> ...
18:29:09 <jsomedon> didn't even learn monad yet
18:29:11 <monochrom> Like I said it's a monad therefore we are sure it's a functor.
18:29:19 <jsomedon> fine
18:29:34 <monochrom> But definitely get functor to work first.
18:29:49 <jsomedon> yeah I didn't finish learning functor yet
18:30:05 <jsomedon> but still, good stuff to know
18:30:09 <Axman6> jackdk: it was porn sites, they were proxies to porn sites - probably the lowest latency way to solve them, people want their satisfaction
18:30:14 <iqubic> Honestly, neither have it
18:30:16 <Axman6> proxied*
18:31:37 <monochrom> Someone needs to tie the knot and have two porn sites proxy each other and complete the cycle.
18:31:48 <iqubic> Cont is just like a function waiting for an argument.
18:31:53 <iqubic> :t flip ($)
18:31:55 <lambdabot> a -> (a -> c) -> c
18:32:49 <Axman6> Cont is just fancy people callbacks, change my mind
18:33:27 <monochrom> I will change your mind but only on the wording. I agree with what you have in mind.
18:34:08 <monochrom> The (a->r) part is the continuation. The whole (a->r)->r is "uses the continuation-passing style".
18:34:41 <monochrom> And the (a->r) part is just fancy people callbacks. Hell I would even delete "fancy people" there. It's a callback, period.
18:34:58 <monochrom> The whole (a->r)->r is then "callback-passing style".
18:35:44 <monochrom> But I like anthropomorphizing of gamification more. :)
18:36:27 <EvanR> ificationization... izationization
18:36:47 <EvanR> you just got ificationized
18:36:57 <monochrom> Yeah don't you love more-than-26-lettesization?
18:37:23 <monochrom> > length "anthropomorphizing"
18:37:25 <lambdabot>  18
18:37:32 <monochrom> Aww too short.
18:38:09 <Axman6> yous are using zed wrong
18:38:22 <Axman6> youse* apologies
18:38:29 <monochrom> > length "anthropomorphogamification"
18:38:31 <lambdabot>  26
18:38:43 <monochrom> OK success!
18:39:45 <Axman6> "Change my mind" memes are just anthropomorphogamification, change my mind
18:40:08 <jackdk> expanding brain is a better meme than change my mind, change my mind
18:40:18 <EvanR> high energy greek root collision experiment
18:40:50 <EvanR> new elements are formed but are sure to last only a zeptosecond before being forgotten
18:42:15 <monochrom> (a -> ChangeMyMind) -> ChangeMyMind
18:44:38 <iqubic> I hava no idea how any of this works: http://dpaste.com/2WWKAMN
18:45:14 <Axman6> DrakeMeme ChangeMyMindMeme ExpandingBrainMeme :: Meme
18:45:52 <iqubic> I looked at Control.Monad.Trans.Cont for a list of functions that people commonly use with continuations, an implemented them based solely on type signatures.
18:46:04 <iqubic> I have no idea what any of that stuff is supposed to actually do.
18:46:07 <EvanR> don't cross the memes!
18:46:24 <iqubic> And I also, don't know why those work.
18:46:31 <iqubic> Cont screws with my brain.
18:46:32 <Axman6> meta-memes are best memes
18:47:14 <EvanR> drake is a two argument metameme, find some others, then can we form a "bottomless meme" or comeme
18:47:36 <iqubic> Can someone explain these Cont functions to me?
18:47:38 <iqubic> http://dpaste.com/2WWKAMN
18:48:23 <monochrom> Oh I know what story to tell about mapCont.
18:49:13 <monochrom> So you already know of monochrom :: (Int -> Bool) -> Bool, the game host who has a secret number in mind and will gladly answer true/false questions about that number.
18:49:30 <iqubic> Sure.
18:49:48 <iqubic> monochrom :: Cont Bool Int
18:49:53 <mycroftiv> does this game host like to hide envelopes with answers?
18:50:26 <monochrom> Now there is also the enemy of monochrom, multichrom :: (Int -> Bool) -> Bool, who has the same secret number as monochrom, but his answers are always the negation of monochrom's answer.
18:50:40 <monochrom> multichrom = mapCont not.
18:50:40 <iqubic> Oh? Seems weird.
18:50:46 <iqubic> What!?!?!
18:51:15 <jackdk> Axman6: https://imgur.com/evLp1ak
18:51:21 <iqubic> Oh. I see.
18:51:46 <iqubic> monochrom: Is there more to the story/
18:51:52 <monochrom> Now you are at a crossroad, in front of you is one way to heaven and the other way to hell. The tour guide at the crossroad is either monochrom or multichrom, you know he's one of us but not sure which.
18:52:17 <monochrom> What question or questions do you ask him so as to figure out which way is to heaven?
18:52:35 <iqubic> Well, monochrom always tells the truth, and multichrom always lies, I think.
18:52:47 <mycroftiv> Raymond Smullyan is smiling down a this irc now from wherever logicians go when they die
18:53:03 <iqubic> I have no idea what question to ask this tour guide.
18:53:57 <iqubic> I don't recall the answer to this riddle.
18:54:27 <iqubic> And even if I did, I don't see how this relates to the Cont stuff.
18:55:26 <Axman6> jackdk: my head hurts
18:56:37 <monochrom> err, multichrom = mapCont not monochrom
18:57:08 <iqubic> So, how do I get an answer out of this?
18:57:41 <iqubic> I don't even know if the tour guide is telling the truth or not.
18:59:44 <iqubic> I need to construct a scenario where I learn if this person speaks the truth or not. Because if this tour guide is lying, then I need to take the opposite result.
19:00:52 <iqubic> So either Monochrom or Multichrom tells the truth, and the other lies. I don't know which is which, and I don't which my tour guide is..
19:01:23 <iqubic> Of course, I am assuming that this scenario abides by the law of the excluded middle.
19:01:27 <EvanR> it's simple, if they say "I'm always lying", you can file a "logical paradox" form and be honorably released from the game
19:02:45 <iqubic> monochrom: Is there any hint you can give me?
19:02:52 <monochrom> No.
19:03:00 <iqubic> Why not?
19:03:05 <iqubic> Is this a hard puzzle?
19:07:14 <iqubic> monchrome: I think I have the answer. I walk up to the tour guide and ask: "If you were multichrom, would you say the left path goes to heaven?" And I know that this answer, whatever it is, is 100% for sure the wrong answer.
19:07:23 <iqubic> monochrom: ^^
19:08:45 <shachaf> The answer is a Haskell program, not an English sentence.
19:08:53 <iqubic> Oh, is it?
19:09:23 <iqubic> I think this is something to do with 'withCont' but I'm not sure.
19:10:05 <shachaf> It doesn't have anything to do with any Cont functions, only with thinking.
19:10:40 <shachaf> monochrom, multichrom :: (Int -> Bool) -> Bool
19:11:43 <iqubic> Well, yes. But monochrom, multichrom :: Cont Bool Int
19:12:14 <shachaf> But you don't understand Cont, so why are you making it more complicated with a thing you don't understand?
19:12:22 <iqubic> I know. I know.
19:13:16 <iqubic> How do I translate from (Int -> Bool) -> Bool into a binary choice of left path or right path?
19:14:28 <iqubic> Because currently, what I have is a tour guide, standing at a cross road, and two paths. One to heaven and one to hell. I don't know if this guy is Monocrom or multichrom.
19:15:13 <iqubic> monochrom: Any help here on just simply translating the logic puzzle to haskell/
19:15:14 <iqubic> ???
19:17:57 <shachaf> You already sent him a bunch of messages, he'll see them and respond if he wants. You don't need to keep doing it.
19:18:05 <iqubic> Alright than.
19:18:11 <iqubic> I'll just wait.
19:18:24 <shachaf> I don't know what puzzle monochrom meant, but a simple puzzle is, distinguish monochrom from multichrom.
19:19:38 <iqubic> yeah, I think that's the first task.
19:19:56 <iqubic> I know that they give opposite answers. And that's it.
19:20:34 <shmokey> >
19:20:46 <shmokey> lol sry
19:28:32 <nshepperd> iqubic: you also know that the answers monochrom gives are answers about a specific number
19:28:34 <nshepperd> iqubic: they
19:28:44 <nshepperd> iqubic: they're not just arbitrary opposite answers
19:29:13 <iqubic> Oh, right.
19:29:29 <iqubic> So I should try to figure out that number?
19:31:05 <iqubic> runCont f monochrom != runCont f multichrom for all possible 'f :: (Int -> Bool)'
19:31:25 <nshepperd> suppose that you knew the number
19:31:36 <nshepperd> could you tell which one was monochrom?
19:31:58 <iqubic> Not sure.
19:32:02 <iqubic> I don't know.
19:32:52 <iqubic> 'runCont (== 4) monchrom' Even if that returns true, it still won't tell me who I'm talking too.
19:33:24 <nshepperd> but it does tell you something
19:34:01 <iqubic> Does it?
19:34:53 <iqubic> nshepperd: Either 4 is the number and I'm talking to one of them, or 4 is not the number and I'm talking to other of them.
19:35:22 <nshepperd> either 4 is the number and you're talking to monochrom, or 4 is not the number and you're talking to multichrom
19:35:58 <iqubic> Right.
19:36:17 <iqubic> But that doesn't help me figure out either the number, or who I'm talking to.
19:37:02 <nshepperd> you'll need to ask a second question
19:37:17 <jusss> if ` f s = g 3 s ` so ` f = \s -> g 3 s = g 3 ` based on eta-conversion?
19:37:42 <iqubic> Yes.
19:37:49 <jusss> wonderful
19:37:52 <DigitalKiwi> https://www.xkcd.com/246/
19:38:07 <iqubic> nshepperd: I don't know what to ask.
19:38:34 <nshepperd> iqubic: a useful fact that might help is that 4 and 5 can't both be the number
19:39:34 <iqubic> I don't see how that helps.
19:39:43 <DigitalKiwi> "is the number 5?"
19:40:55 <iqubic> Well, on of them is going to answer yes, and the other no.
19:42:05 <DigitalKiwi> if they answer yes they are lying
19:42:31 <iqubic> Well, but only if the number isn't 5.
19:42:38 <iqubic> I have no idea what the number is.
19:43:07 <iqubic> Also, why did we assume that monochrom tells the truth?
19:43:50 <nshepperd> because monochrom said so
19:44:01 <DigitalKiwi> what if he's lying
19:44:04 <nshepperd> (and monochrom always tells the truth ;)
19:44:33 <iqubic> I see.
19:46:05 <iqubic> I have no idea how to approach this.
19:46:06 <nshepperd> if I tell you that there are 4 lights, and also that there are 5 lights, i'm probably lying
19:46:15 <jusss> except Yesod, are there others web frames?
19:46:26 <iqubic> Yes.
19:46:28 <iqubic> Correct.
19:46:39 <DigitalKiwi> https://wiki.haskell.org/Web/Frameworks
19:46:55 <iqubic> How does any of this relate to Contiunations?
19:47:53 <MarcelineVQ> nshepperd: You may just be under duress.
19:48:51 <nshepperd> hah
19:49:38 * DigitalKiwi files that under excuses to use at a later date "i wasn't lying, i was under duress!"
19:50:15 <iqubic> Me too.
19:51:06 <iqubic> What is mapCont supposed to do?
19:51:17 <iqubic> Or sorry: withCont.
19:51:20 <iqubic> withCont :: ((b -> r) -> a -> r) -> Cont r a -> Cont r b
19:51:23 <iqubic> withCont f c = Cont $ runCont c . f
19:58:49 <jsomedon> ha that bloddy story now has multichrom? 
20:00:42 <koz_> I'm reading/rewriting this: https://github.com/kozross/stt/blob/master/src/Control/Monad/Trans/ST/Internal.hs#L37 Why exactly _must_ we have Monad m here - why won't Applicative m do?
20:04:28 <iqubic> The hell is the hash doing on line 38?
20:04:35 <iqubic> I've never seen that before.
20:05:13 <MarcelineVQ> it's an extention called MagicHash
20:08:10 <koz_> Like, I can see that the definition uses do-notation, but that's just syntax sugar which could desugar to Applicative stuff. What _exactly_ forces us into Monad?
20:08:12 <MarcelineVQ> koz_: because do syntax is nice and ApplicativeDo is new perhaps, at the same time I'd ask why Functor m is there as well, so maybe it's just weird code you're looking at?
20:08:20 <koz_> MarcelineVQ: It's old af.
20:08:37 <koz_> I'm having some trouble rewriting it to be a bit more modern, which is why I'm questioning the Monad constraint.
20:09:06 <MarcelineVQ> Why not look at modern ST as your guide?
20:09:25 <koz_> MarcelineVQ: Because this isn't ST - this is an ST _transformer_.
20:09:56 <koz_> It's a bit confusing because it 'bounces' between STT and STRet.
20:10:22 <MarcelineVQ> if it's really old then consider instead that when Appicative is brand new and you already have Monad then using Monad to write Applicative is a path of least resistance
20:10:29 <MarcelineVQ> but idk as well
20:11:16 <koz_> Hmm.
20:11:24 <MarcelineVQ> If it's intended to be a Monad transformer than requring m to be Monad isn't unreasonable, though it doesn't do so for Functor
20:11:47 <koz_> Interestingly, modern ST _did_ prove useful, thanks!
20:14:14 <dansho> is there a way to make the tag of an aeson sum type be the constructor itself? https://hatebin.com/diaewunvng
20:14:26 <dansho> i get "X", but i want {"B": "X"}
20:16:43 <dansho> i guess i don't want to use UntaggedValue, but i'm not sure if the other options could be used to do this
20:18:13 <iqubic> tagSelf :: a -> Tagged a a
20:18:34 <iqubic> From Data.Tagged.
20:18:40 <iqubic> https://hackage.haskell.org/package/tagged-0.8.6
20:19:15 <iqubic> Though that might not be what you want.
20:22:16 <iqubic> I have no idea how Aeson works, so I can't help you.
20:26:15 <dansho> figured it out, just had to use ObjectWithSingleField
20:26:42 <dmwit> dansho: Presumably you want ObjectWithSingleField.
20:27:29 <dmwit> https://hackage.haskell.org/package/aeson-1.4.5.0/docs/Data-Aeson.html#t:SumEncoding
20:31:08 <dmwit> koz_: What's your plan for threading the right s to the right place with Applicative-only-and-not-Monad?
20:31:17 <dmwit> koz_: It's not clear to me that it can be done.
20:31:21 <koz_> dmwit: Yeah, I realized that.
20:31:29 <koz_> (after reading modern ST)
20:31:38 <iqubic> I have no idea what ST is.
20:32:41 <EvanR> new rule, you have to learn everything you state not to know
20:32:45 <dmwit> ^
20:33:05 <iqubic> Is that right?
20:33:09 <koz_> iqubic: https://www.microsoft.com/en-us/research/wp-content/uploads/1994/06/lazy-functional-state-threads.pdf
20:33:18 <koz_> Very readable paper.
20:50:00 * hackage string-qq 0.0.4 - QuasiQuoter for non-interpolated strings, texts and bytestrings.  https://hackage.haskell.org/package/string-qq-0.0.4 (AudreyTang)
20:56:36 <shachaf> Preferably learn first, state later.
20:57:20 <shachaf> I propose that telling everyone that you don't know things isn't a good way to interact with this channel.
20:57:25 <slack1256> Hi, I am new to web-development and scotty. Should the html itself be on CAF or should it live as a file somewhere and be read at runtime.
20:57:40 <slack1256> I feel the tutorials push me in the first direction embeding blaze.
20:57:46 <iqubic> What is CAF?
20:58:10 <heatsink> A constant applicative form, I guess
20:58:16 <slack1256> Constant Applicative Form (a fancy way to call top-level bindings)
20:59:46 <heatsink> If you're just starting out, it doesn't matter much
21:00:47 <slack1256> Yeah, probably.
21:00:53 <slack1256> Overthinking I guess.
21:02:26 <heatsink> Generally the reason for putting the website in files is that it's easier to change.
21:02:48 <heatsink> Replacing a file is easier than stopping the old server program and starting the new one.
21:06:21 <jle`> also there is some conceptual benefit to separating code from data
21:12:24 <iqubic> Lisp doesn't think that way.
21:16:08 <Axman6> Can all Haskell data types be represented as church/scott encodings? (probably being a little lax with terminology)
21:18:23 <iqubic> maybe
21:18:26 <Axman6> thinking of GADTs
21:20:20 <iqubic> What's the encoding of Maybe a?
21:20:28 <Axman6> :t maybe
21:20:29 <lambdabot> b -> (a -> b) -> Maybe a -> b
21:20:35 <Axman6> :t either
21:20:36 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
21:20:39 <Axman6> :t foldl
21:20:40 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
21:20:41 <Axman6> uh
21:20:45 <Axman6> :t foldr
21:20:46 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
21:20:56 <Axman6> :t foldr @[]
21:20:57 <lambdabot> error:
21:20:57 <lambdabot>     Pattern syntax in expression context: foldr@[]
21:20:57 <lambdabot>     Did you mean to enable TypeApplications?
21:21:06 <Axman6> you know I did lambdabot
21:21:11 <Axman6> % :t foldr @[]
21:21:12 <yahb> Axman6: (a -> b -> b) -> b -> [a] -> b
21:21:57 <EvanR> in so far as these are the eliminators for respective data types... what would Void look like (eliminator corresponds to ex falso)
21:22:54 <EvanR> ? : Void -> a
21:23:22 <ski> yes
21:23:32 <ski> @djinn Void -> a
21:23:32 <lambdabot> f = void
21:23:44 <EvanR> :t void
21:23:46 <lambdabot> Functor f => f a -> f ()
21:23:49 <ski> not that one
21:24:10 <EvanR> how do you implement that
21:24:18 <ski> (which ought to be renamed, say to `ignore' or something, imho)
21:24:27 <jle`> :t absurd
21:24:27 <ski>   void v = case v of {}
21:24:28 <lambdabot> Void -> a
21:24:54 <EvanR> got it
21:25:30 <iqubic> needs empty case to allow.
21:25:47 <ski> (i don't care if it's called `void' in one of the `Foreign' modules dealing with the C interface. but, imho, it should not be exported under the name `void' from `Data.Functor' or `Control.Monad')
21:26:18 <ski> in Agda it's
21:26:19 <Axman6> % data MyGADT (c :: Constraint) where Constrained :: forall a. c a => a -> MyGADT c
21:26:19 <yahb> Axman6: ; <interactive>:287:62: error: Not in scope: type variable `c'; <interactive>:287:81: error: Not in scope: type variable `c'
21:26:34 <ski>   void :: {A : Set} -> Void -> A
21:26:35 <Axman6> % data MyGADT (c :: Constraint) where Constrained :: forall c a. c a => a -> MyGADT c
21:26:35 <yahb> Axman6: ; <interactive>:288:83: error:; * Expecting one more argument to `c'; Expected a constraint, but `c' has kind `Type -> Constraint'; * In the first argument of `MyGADT', namely `c'; In the type `MyGADT c'; In the definition of data constructor `Constrained'
21:26:36 <ski>   void ()
21:26:36 <jle`> going along the pattern of Maybe a ~ (forall r. (a -> r) -> r -> r), Identity a ~ (forall r. (a -> r) -> r), etc., i would say that the church/scott encoding of Void is (forall r. r)
21:26:40 <EvanR> for GADTs seems like you would need a sort of dependently typed eliminator?
21:26:56 <Axman6> % data MyGADT (c :: Constraint) where Constrained :: forall (c :: Type -> Constraint) a. c a => a -> MyGADT c
21:26:56 <yahb> Axman6: ; <interactive>:289:65: error:; Ambiguous occurrence `Type'; It could refer to either `Language.Haskell.TH.Type', imported from `Language.Haskell.TH' (and originally defined in `Language.Haskell.TH.Syntax'); or `Data.Kind.Type', imported from `Data.Kind' (and originally defined in `GHC.Types')
21:27:06 <Axman6> % data MyGADT (c :: Constraint) where Constrained :: forall (c :: * -> Constraint) a. c a => a -> MyGADT c
21:27:06 <yahb> Axman6: ; <interactive>:290:65: error:; Operator applied to too few arguments: *; With NoStarIsType (implied by TypeOperators), `*' is treated as a regular type operator. ; Did you mean to use `Type' from Data.Kind instead?
21:27:11 <Axman6> -________________-
21:27:17 <ski> (where `()' is an "absurd" pattern)
21:27:25 <MarcelineVQ> It makes you look really cool if you do all that in pm and them get it in one shot in public :>
21:27:39 <jle`> you look cool to others, but not yourself
21:27:43 <Axman6> I was pretty confident I'd get it right the first time
21:27:57 <jle`> if you get it right the first time in public trying it out, then you look cool to others AND to yourself
21:28:03 <Axman6> also there's value in others in the channel know you're mortal
21:28:05 <MarcelineVQ> jle`: pshh you don't need to look cool to yourself, you know you're cool.
21:28:17 * jle` laughs in imposter syndrome
21:28:49 * Axman6 used to work at NICTA, which was the definition of institutionalised imposter syndrome - everyone was brilliant
21:29:30 <EvanR> whoever runs lambdabot is looking at you mess up in PM and laughing 
21:29:38 <iqubic> Yeah.
21:29:42 <MarcelineVQ> it's okay, he doesn't peek
21:29:42 <EvanR> like the priest in the confessional
21:30:01 <iqubic> My PMs are like so full of me doing very silly @pl commands.
21:30:36 <EvanR> forgive me father for i have syntax errored
21:31:06 <Axman6> that should definitely just be called "synd"
21:31:30 <EvanR> ikr
21:32:35 <Axman6> and why isn't the final call in a TCP handshake called SNACKED
21:32:51 <Axman6> or jujst SNACK
21:33:07 <Axman6> man, typing is hard - that's why I use Haskell
21:36:02 <jzyamateur> Is this true?
21:36:13 <jzyamateur> Patterns appear in lambda abstractions, function definitions, pattern bindings, list comprehensions, do expressions, and case expressions. However, the first five of these ultimately translate into case expressions, so defining the semantics of pattern matching for case expressions is sufficient
21:36:45 <Axman6> why wouldn't it be true?
21:36:55 <jle`> hm, are you asking if patterns appear in other situations?
21:37:30 <jle`> hm, i'm not sure if the semantics are quite the same; does let polymorphism work with pattern bindings?
21:37:54 <jle`> > let (x,y) = (3,4) in round x + x
21:37:57 <lambdabot>  6
21:38:01 <jzyamateur> No I mean case Expr seemed to have more syntax than let's say function definition etc.
21:38:04 <jle`> > case (3,4) of (x,y) -> round x + x
21:38:06 <lambdabot>  error:
21:38:06 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M632732358448...
21:38:06 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
21:38:13 <jle`> jzyamateur: oh, are we talking about Haskell?
21:38:23 <Axman6> ... I hope so
21:38:31 <jzyamateur> Yes haskell
21:38:49 <Axman6>  f (Just x) = ... just becomes f x = case x of Just c -> ...
21:39:03 <jle`> hm yeah we can see that pattern bindings in let seem to have different semantics than case statements
21:39:14 <ski> (or `f = \case Just x -> ...')
21:39:35 <Axman6> LAmbdaCase just becomes case too :P
21:39:57 <jle`> jzyamateur: but yeah, map _ [] = []; map f (x:xs) = f x : map f xs is "sugar" for map = \f -> \ys -> case ys of [] -> []; x:xs -> f x : map f xs
21:40:03 <Axman6> (I assume, since basically everything just becomes case statements)
21:40:16 <jle`> function definitions are all just sugar for the most part for myFunction = (some lambdas)
21:40:23 <jzyamateur> Hmm, interesting 
21:40:26 <jle`> (some lets)
21:40:37 <ski> in SML, `case <expr> of <match> | ...' is defined to mean `(fn <match> | ...) <expr>'
21:40:44 <Axman6> well, sort of, there are difference in the compiler between f x y z = ...  and f x y = \z -> ...
21:40:53 <ski> (where `fn' corresponds to `\case')
21:40:55 <jle`> indeedio
21:41:00 <Axman6> semantically they're the same but they can perform differently
21:45:44 <EvanR> case analysis all the way down
21:46:16 <Axman6> case rules everything around me
21:46:52 <laudecay> match match matchity match
21:47:25 <Axman6> I used to work with a team whose job was to take scientists code and make it fast on superomputers. The poster on their wall was "Cache rules everything aronud me"
21:47:37 <Axman6> supercomputers*
21:47:53 <jle`> you've moved from rule of cache to rule of case
21:48:38 <ski> (not sure whether something similar's the case for `match <expr> with <match> | ...' vs. `(function <match> | ...) <expr>', in O'Caml)
21:49:15 <laudecay> yooooo Axman6 that's literally my job at school
21:49:33 <Axman6> noice
21:49:36 * ski . o O ( Upper and lower case <https://pbs.twimg.com/media/Dbo0pbiWkAErHPD?format=jpg&name=4096x4096> )
21:49:43 <laudecay> during the year
21:50:00 <EvanR> whoa
21:50:44 <Axman6> I thought that was well known
21:51:42 <Axman6> if you want to have your mind blown, look into how linotype works: https://www.youtube.com/watch?v=EzilaRwoMus
21:52:24 <Axman6> It involves a typewqriter keyboard and molten lead
21:53:53 <EvanR> seems legit
21:54:55 <laudecay> ok i have questions about the best way to do a thing in haskell
21:55:04 <Axman6> molten lead
21:55:16 * ski votes for CPS
21:55:49 * Axman6 fancy callbacks
21:56:18 <laudecay> i have these message things that are going to come in over the wire in IP packets and they're just gonna be big chunks of bytes
21:56:29 <laudecay> like defined field sizes
21:56:40 <laudecay> and i need to both read them and construct them easily
21:56:54 <EvanR> Yes! Haskell can do that!
21:56:57 <laudecay> what would be the best way to integrate this with the type system and limit the amount of overhead going from like
21:57:06 <Axman6> `binary` isn't a terrible place to start with that
21:57:16 <laudecay> nice type system stuff like "these bytes are a crypto key and those bytes are this numerical identifier" 
21:57:28 <laudecay> to yeeting a bunch of bytes into a tun 
21:57:34 <Axman6> are these bytes in a standard format?
21:57:40 <laudecay> theyre wireguard messages
21:57:43 <laudecay> wdym standard format
21:57:54 <laudecay> like think IP packet structure
21:58:10 <Axman6> do they have an encoding, like JSON, CBOR, protocol buffers etc.
21:58:27 * ski . o O ( "What's in a name? That which we call a callback / By any other name would function as well;" -- Simone Arrowshoote )
21:58:32 <EvanR> if you know the full size ahead of time you can preallocate the vector, mutate the bytes, then freeze without incurring more copy costs
21:58:52 <laudecay> EvanR: i do for 3/4 of the message types, the fourth is a standard size header then a body
21:59:08 <laudecay> Axman6: like see the box on page 11 here https://www.wireguard.com/papers/wireguard.pdf
21:59:13 <laudecay> it's gonna be reading and writing one of these
21:59:36 <laudecay> but it'd be nice to like have types for the "sender" and "receiver" identifiers, then the "ephemeral" could be some kind of public key type
21:59:37 <laudecay> etc
21:59:49 <laudecay> i just had like a horror show doing this in ocaml with bytes -> whateverthefuck type conversion
21:59:58 <laudecay> so i wanna do it right from the start in haskell
22:00:24 <ski> something like Erlang's binary patterns would perhaps be nice to have
22:00:24 <laudecay> can i control the byte level representation of a record type tho? like specify endianness and such? EvanR 
22:00:47 <EvanR> yes to endianness, no to record types themselves
22:00:57 <EvanR> if you mean the result of serializing a record yes
22:01:16 <Axman6> laudecay: yes, binary and most other binary serialisation libraries let you specify endianess when parsing and serialising
22:01:18 <laudecay> so i cant just like
22:01:51 <EvanR> the binary library has good abstractions for to and from bytes
22:01:54 <laudecay> ok cool
22:01:58 <laudecay> ill take a look
22:02:13 <laudecay> thanks yall!
22:02:18 <Axman6> if you want to be super sure though, you can do things like use newtypes: newtype BE64 = BE64 Word64 with appropriate instances for parding and serialising
22:02:29 <laudecay> whats parding
22:02:37 <laudecay> wdym super sure?
22:02:45 <EvanR> it's such sweet sorrow
22:02:54 <laudecay> i just wanna like reduce the number of times these bytes get copied around
22:02:57 <laudecay> Need for Speed
22:02:58 <Axman6> parsing with a syn
22:03:02 <laudecay> lmao
22:03:21 <EvanR> the rule of fast
22:03:40 <Axman6> just use Ed's structs package
22:03:47 <laudecay> Ed's structs?
22:03:52 <ski> @hackage structs
22:03:53 <lambdabot> http://hackage.haskell.org/package/structs
22:03:53 <Axman6> all the clarity of C with the safety of C
22:03:53 <ski> ?
22:04:04 <laudecay> wait /with/ the safety of c?
22:04:11 <laudecay> dislike
22:04:13 <laudecay> shudder
22:04:16 <Axman6> (Don't actually do this until you _know_ you have performance issues)
22:04:20 <laudecay> okay yeah
22:04:24 <laudecay> ill add like a comment or something
22:04:28 <laudecay> "if shit
22:04:31 <laudecay> is slow use this"
22:05:04 <Axman6> don't use it though, you won't need it
22:05:37 <laudecay> yeah cstruct was like that in ocaml except it was MY ONLY OPTION
22:05:39 <laudecay> I WAS IN HELL
22:05:46 <laudecay> and i found bugs in the ppx
22:05:50 <laudecay> aaaaAAAAAAAAAA
22:06:16 <EvanR> first use binary and prove the marshalling code is correct. When you're ready rewrite it all in a different lib that provides no guarantees
22:06:41 <EvanR> i call it "code erasure"
22:06:46 <ski> heh
22:06:57 <laudecay> yeah 
22:07:03 <laudecay> im gonna start w binary this looks nice!
22:07:58 <Axman6> for the message on page 11, you can use somethjing like data MEssage = MEssage {mType :: !Word8, {- reserved needs to be ignored in the parser -} mSender :: !Word32, mReceiver :: !Word32, mEphemeral :: !Word32, {- empty -} mMAC1 :: Word16, mMAC2 :: Word16 }
22:08:34 <Axman6> and add {-# OPTIONS_GHC -funbox-strict-fields #-} to the top of the file
22:09:12 <Axman6> then you're essentially dealing with a struct which has the words inlined, instead of a record pointing to a bunch of words
22:11:39 <Axman6> your parser will look somelike: Message <$> (getWord16BE >>= \t -> guard (t == 2) $> t) <*> (replicateM 3 getWord8 >>= \l -> guard (l == [0,0,0])) *> getWord32BE <*> getWord32BE <*> getWord32BE <*> getWord16 <*> getWord16
22:13:58 * ski . o O ( `l == [0,0,0]' is ignoring ? )
22:14:52 <Axman6> yeah, it'd defined to be three zeros, so checking that's correct but then ignoring it
22:16:08 <laudecay> oh hi sorry locked my computer
22:16:21 <Axman6> I can't believe you left us
22:16:39 <laudecay> yo Axman6 that's awesome
22:16:54 <laudecay> what's that guard thing doing sorry
22:17:14 <laudecay> the "empty" bit is just encrypting 0 bytes with a certain derived key so it's actually 16 bytes long
22:17:28 <laudecay> the hat on top of the number means add 16 bytes for the poly1305 tag
22:17:44 <laudecay> but otherwise yeah that makes a lot of sense
22:18:33 <ski> % let l = [0,0,0] in maybe empty pure [() | [0,0,0] <- pure l] *> pure "blah"
22:18:33 <yahb> ski: "blah"
22:20:10 * ski looks for the hat, can't find it
22:31:46 <iqubic> What does this function do?
22:31:51 <iqubic> withCont :: ((b -> r) -> a -> r) -> Cont r a -> Cont r b
22:31:56 <iqubic> withCont f c = Cont $ runCont c . f
22:34:25 <ski> "backwards transform the continuation"
22:34:51 <ski> @djinn-add type NotNot a = Not (Not a)
22:35:09 <ski> @djinn (Not b -> Not a) -> (NotNot a -> NotNot b)
22:35:09 <lambdabot> f a b c = void (b (a c))
22:35:40 <iqubic> What does it mean to backwards transform?
22:35:54 <ski> (btw, that `void' can be removed. `djinn' is sometimes a bit overeager to insert `void', where it's not needed)
22:36:31 <iqubic> I still don't get it.
22:38:45 <ski> you want to produce an action of type `NotNot b' / `Cont r b'. you wait for the future to send you a continuation of type `Not b'/`b -> Void' / `b -> r', telling you what it wants to do with the `b' you're supposed to compute. you transform this continuation into one of type `Not a'/`a -> Void' / `a -> r', and use that as continuation for the argument action of type `NotNot a' / `Cont r a' (and the final answer/result from that, of type `Void' / `r', is the
22:39:02 <ski> (hrm, cut off near ".. (and the final answer/result from that, of type `Void' / `r', is the final answer/result of the whole call)")
22:39:05 <ski> that's all
22:40:15 <ski> @type let withCont f cra kb = cra (f kb) in withCont
22:40:16 <lambdabot> (t1 -> t2) -> (t2 -> t3) -> t1 -> t3
22:40:35 <iqubic> Not the same type.
22:40:42 <iqubic> withCont :: ((b -> r) -> a -> r) -> Cont r a -> Cont r b
22:40:53 <iqubic> Not by a long shot.
22:41:01 <ski> @type let withCont :: (b -> a) -> ((a -> r) -> (b -> r)) ; withCont f cra kb = cra (f kb) in withCont
22:41:03 <lambdabot> (b -> a) -> (a -> r) -> b -> r
22:41:43 <ski> just set my `a',`b' to `Not a'/`a -> r',`Not b'/`b -> r', and you get your type signature
22:42:19 <ski> (`NotNot a' is `(a -> Void) -> Void'. `Cont r a' is `(a -> r) -> r')
22:42:47 <ski> so, in fact, this is just a special case of
22:43:00 <ski> @djinn (b -> a) -> (Not a -> Not b)
22:43:01 <lambdabot> f a b c = b (a c)
22:43:03 <ski> contraposition
22:43:52 <iqubic> Is it really?
22:43:59 <ski> (so `NotNot' is `Cont Void')
22:44:01 <ski> yes
22:44:29 <iqubic> It's contravariant?
22:44:43 <ski> `Not' is contravariant for sure, yes
22:45:12 <iqubic> :t Not
22:45:13 <lambdabot> error:
22:45:13 <lambdabot>     • Data constructor not in scope: Not
22:45:13 <lambdabot>     • Perhaps you meant variable ‘not’ (imported from Data.Bool)
22:45:19 <ski> @djinn-env
22:45:19 <lambdabot> data () = ()
22:45:19 <lambdabot> data Either a b = Left a | Right b
22:45:19 <lambdabot> data Maybe a = Nothing | Just a
22:45:19 <lambdabot> data Bool = False | True
22:45:19 <lambdabot> data Void
22:45:21 <lambdabot> [4 @more lines]
22:45:23 <ski> @more
22:45:23 <lambdabot> type Not x = x -> Void
22:45:25 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
22:45:27 <lambdabot> class Eq a where (==) :: a -> a -> Bool
22:45:29 <lambdabot> type NotNot a = Not (Not a)
22:45:33 <iqubic> I see.
22:45:52 <iqubic> (a -> Void) -> Void. I see.
22:46:20 <ski> to be able to get anything useful out of it, we use `r' in place of `Void'
22:46:34 <iqubic> correct.
22:46:45 <iqubic> Why is withCont ever useful in the first place?
22:46:45 <ski> (this corresponds to using minimal logic, rather than intuitionistic logic. hence why i didn't want to use `void', which isn't in minimal logic)
22:47:07 <ski> i dunno, where did you find it ?
22:47:28 <ski> i'm sure it could occasionally come in handy .. though probably not too often
22:48:15 <iqubic> Found it in here: https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Cont.html
22:48:39 <ski> (btw, `djinn's use of `void' above had type `Void -> Void', was equal to `id'. that's why it was redundant)
22:49:20 <ski> @type withReader
22:49:22 <lambdabot> (r' -> r) -> Reader r a -> Reader r' a
22:49:23 <ski> @type withWriter
22:49:25 <lambdabot> error: Variable not in scope: withWriter
22:49:30 <ski> @type withStat
22:49:31 <ski> @type withState
22:49:32 <lambdabot> error:
22:49:32 <lambdabot>     • Variable not in scope: withStat
22:49:32 <lambdabot>     • Perhaps you meant one of these:
22:49:33 <lambdabot> (s -> s) -> State s a -> State s a
22:49:39 <ski> @type withCont
22:49:40 <lambdabot> ((b -> r) -> a -> r) -> Cont r a -> Cont r b
22:49:55 <iqubic> What does withState do?
22:50:04 <ski> these are just some general "look under the covers and transform what you see"-type of combinators
22:50:49 <ski> not sure, but i suspect it transforms the output state (rather than the input state) (?)
22:51:18 <iqubic> I see.
22:51:28 <iqubic> @type mapState
22:51:29 <lambdabot> ((a, s) -> (b, s)) -> State s a -> State s b
22:51:52 <iqubic> What does the Functor instance for Cont even do?
22:52:08 <iqubic> instance Functor (Cont r) where
22:52:13 <ski> hm .. actually, maybe it's `mapState' which transforms the output, and the `withX' things which transforms the input things
22:52:21 <iqubic> fmap f c = Cont $ \g -> runCont c (g . f)
22:52:25 <ski> (and that would explain why there's no `withWriter')
22:52:36 <iqubic> yes. mapCont transforms the output.
22:52:50 <ski> @type mapCont
22:52:52 <lambdabot> (r -> r) -> Cont r a -> Cont r a
22:52:55 <ski> yea
22:53:00 <ski> makes sense, to me
22:53:23 <iqubic> What does the functor instance of Cont do?
22:54:03 <iqubic> Wait... I think it just transforms the input.
22:54:07 <Axman6> try implementing it yourself
22:54:16 <Axman6> @unmtl Cont r a
22:54:16 <lambdabot> (a -> r) -> r
22:54:17 <iqubic> fmap f c = Cont $ \g -> runCont c (g . f)
22:54:17 <agohoth> hey whos using haskell for big data
22:54:25 <ski> attach a post-processing step to the eventual value(s) of type `a' produced by `Cont o a', before being fed to the (future) continuation of type `a -> o'
22:54:33 <Axman6> we're using it for medium data
22:54:35 <iqubic> I've already implemented it myself.
22:54:57 <iqubic> Yeah. Seems cool.
22:55:09 <iqubic> Continuations are very very weird.
22:55:42 <iqubic> I don't understand how the Cont Monad works.
22:56:02 <iqubic> I don't even get what do notation does for a Cont.
22:56:07 <ski> you could compare with an asynch/future thing `Future a', which will eventually resolve to an `a'. you could imagine attach a post-processing step `a -> b', so that you get a `Future b', which will transform the `a' to a `b', as soon as it arrives
22:56:28 <iqubic> That makes sense.
22:56:32 <iqubic> I understand that.
22:56:48 <MarcelineVQ> http://www.vex.net/~trebla/haskell/cont.xhtml
22:56:59 <ski> iqubic : see monochrom's "Introduction to Cont" <http://www.vex.net/~trebla/haskell/cont.xhtml#quantifiers>
22:57:06 * ski low fours MarcelineVQ :)
22:57:30 <MarcelineVQ> never repeat yourself, unless someone's paying you to :>
22:57:53 * ski . o O ( how about repeating someone else ? )
22:57:56 <MarcelineVQ> That is to say, if someone else already said it, let them
22:57:58 <ski> "Continuations are very very weird." -- word
22:58:01 <iqubic> Who even uses Cont and CPS in real code?
22:58:13 <ski> you use them when you need them
22:58:21 <iqubic> I have never needed them.
22:58:28 <ski> that's fine
22:58:29 <dminuoso> iqubic: CPS itself is somewhat common actually.
22:58:55 <iqubic> I know what CPS is.
22:58:59 <dminuoso> iqubic: Every time you have some withXXX, say withConnection, then at least in part the interface is using CPS style.
22:59:22 <agohoth> where do haskellers keep thier data
22:59:24 <jle`> iqubic: we aren't saying that you don't know what they are, we are saying that it is commonly used in real code
22:59:27 <agohoth> psotgresql?
22:59:32 <agohoth> or use acidstate
22:59:49 <dminuoso> agohoth: sqlite-simple is a great interface for maintaining stateful data.
22:59:59 <dminuoso> agohoth: acidstate is very misleading and not a database.
23:00:00 <jle`> agohoth: in practice it's mostly the same as for other languages and ecosystems
23:00:51 <ski> % :t \argv -> runContT $ traverse (ContT . BS.useAsCString) argv >>= ContT . Foreign.Marshal.Array.withArray0 Foreign.Ptr.nullPtr  -- courtesy of mniip, <http://tunes.org/~nef/logs/haskell/19.09.15>
23:00:51 <yahb> ski: [BS.ByteString] -> (Ptr (Ptr Foreign.C.Types.CChar) -> IO r) -> IO r
23:00:55 <ski> iqubic ^
23:01:12 <dminuoso> ski: That use of ContT is making my head spin. :-)
23:01:30 <iqubic> I just don't understand how the Cont monad is used to do crazy stuff.
23:02:26 <dminuoso> "ContT is not a functor on the category of monads, and many operations cannot be lifted through it."
23:02:33 <dminuoso> Does that not imply ContT is not a MonadTrans?
23:03:17 <ski> @type lift :: Monad m => m a -> ContT o m a
23:03:18 <lambdabot> Monad m => m a -> ContT o m a
23:04:00 <dminuoso> ski: Well I see the instance, but the text somehow suggests it's not a lawful instance.
23:04:22 <jle`> functor on monads means that you can't "change" the underlying monad
23:04:33 <jle`> so you can't write a (forall x. m x -> n x) -> Cont o m a -> Cont o n a
23:04:37 <jle`> *not a functor
23:04:40 <dminuoso> Ahh
23:05:11 <dminuoso> jle`: So its not MFunctor, so hoist doesn't exist in general
23:05:16 <dminuoso> Gotcha.
23:05:31 <jle`> yeah, i was going to post a link to MFunctor
23:05:51 <dminuoso> jle`: A link to hackage or some article?
23:05:59 <jle`> just the hackage link :)
23:06:18 <jle`> you'll know if you need ContT
23:06:26 <jle`> s/need/could use
23:06:34 <jle`> and it's usually not for crazy stuff
23:06:45 <jle`> just to help manage a bunch of nested indentations that seem to go on forever
23:06:53 <jle`> withFile f1 $ \x ->
23:06:59 <jle`>   withFile f2 $ \y ->
23:07:06 <jle`>     withFile f3 $ \z ->
23:07:32 <jle`> you can instead replace it with do
23:07:35 <agohoth> so is hakell better than say tcl is msot fo the action in is psotgressql?
23:07:37 <jle`>   x <- ContT (withFile f1)
23:07:45 <jle`>   y <- ContT (withFile f2)
23:07:47 <MarcelineVQ> the ghost of Codensity clangs its chains
23:07:50 <jle`>   z <- ContT (withFile f3)
23:07:59 <ski> dminuoso : i believe `MFunctor (ContT o)' doesn't hold
23:08:19 <dminuoso> MarcelineVQ: If only I understood kan extensions. :<
23:08:31 <Rembane> jle`: Is there a runContT in the beginning somewhere? 
23:08:31 <jle`> if you ever find yourself in a continuation hell, Cont/ContT can be useful for cleaning up your code
23:08:42 <agohoth> I mean I got idea recently that nicely aranged tables and short dumb ocde is way to go?
23:08:45 <jle`> Rembane: i'm talking about how you can structure your code instead, yeah
23:08:50 <ski> (ah, jle` said :)
23:08:52 <Rembane> jle`: Sweet! 
23:08:55 <agohoth> dumb code and smart tables
23:09:02 <MarcelineVQ> dminuoso: you just use do :O
23:09:22 <jle`> agohoth: as a "connecting layer", haskell can be pretty useful
23:09:38 <jle`> can be used to check to make sure your program interfaces with everything correctly
23:09:40 <monochrom> Only PHP is worse than Tcl.
23:09:51 <jle`> with its expressive type system
23:09:58 <dminuoso> "Codensity f is the Monad generated by taking the right Kan extension of any Functor f along itself (Ran f f)."
23:10:27 <ski> occasionally, `ContT2 m' (indexed monad) can also be useful
23:10:31 <dminuoso> Perhaps I should just read that paper "Asymptotic Improvement ofComputations over Free Monads"
23:10:46 <jle`> dminuoso: that's an 'identity', but it's not necessarily the only way to understand it
23:11:07 <jle`> that's like saying "integers are a ring ..."; sure it's true, but that's not the only way to understand them
23:11:26 <agohoth> but if you are jsut parsing string to then add to tables
23:11:33 <agohoth> isnt tcl good with strings
23:11:46 <jle`> dminuoso: `Codensity f a` is basically (>>=) partially applied to an 'f a'
23:11:47 <agohoth> then write awesome queries
23:11:52 <agohoth> or am I totally off?
23:11:57 <ski> you can understand `Codensity' before understanding `Ran'
23:12:07 <monochrom> Tcl is bad at everything except string.
23:12:11 <agohoth> lol
23:12:24 <ski> @quote stark
23:12:24 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
23:12:26 <dminuoso> jle`: Curious. Similar to how Coyoneda is fmap partially applied to some `f a`?
23:12:31 <monochrom> And unless you're writing a shell script, almost nothing is string.
23:12:31 <ski> yes, dminuoso
23:12:33 <jle`> agohoth: rarely are you going to have a program that is best expressed as just strings
23:12:33 <agohoth> say you are writing and OLTP system
23:12:40 <agohoth> how made ffast in haskell?
23:12:40 <jle`> dminuoso: yeah, pretty much
23:12:49 <agohoth> hmm
23:12:51 <monochrom> Even a list of strings is not a string, it's a list.
23:13:04 <jle`> dminuoso: hm, or maybe Yoneda
23:13:15 <agohoth> ok so to be honest I only know shell and a tiny bit of tcl lisp pharo smalltalk 
23:13:15 <Rembane> Sting is the ultimate ninja! 
23:13:25 <agohoth> can a dumy liek me pick up haskell?
23:13:33 <monochrom> No.
23:13:34 <agohoth> and make kick ass websites?
23:13:48 <agohoth> :(
23:13:49 <jle`> i think haskell is best for 'dummies', because it's meant to be able to let you be as dumb as possible and still write correct code
23:13:58 <ski> dminuoso,jle` : yea, compare `Yoneda' to `Codensity', and `Coyoneda' to `Density'
23:14:04 <MarcelineVQ> dminuoso: what that should say is: Codensity is a thing you can use just like ContT for avoiding dangling resources like file handles and db connections
23:14:17 <jle`> haskell is most effective for those who aren't smart enough to think of a million things at once while coding
23:14:24 <MarcelineVQ> which can be further specialized into things like this https://hackage.haskell.org/package/managed-1.0.6/docs/Control-Monad-Managed.html
23:14:37 <jle`> so technically the less clever you are, the more haskell would help you
23:14:48 <koz_> I agree with jle`.
23:14:58 <koz_> GHC has frequently proven itself smarter than me. :P
23:15:32 * ski manages the continuations
23:15:44 <jle`> haskell is basically a language that will hold your hand when writing your programs, tell you what parts go where ... to the point where it feels like you're on training wheels yet still getting so much done
23:15:48 <monochrom> OK, you don't need to be smart, but you need to be wise.
23:16:01 <agohoth> ok but say I try to keep data
23:16:11 <agohoth> do I need a postgresql AND haskell
23:16:14 <dminuoso> ski: Im positively confused now. Are you sure you didn't mix up Coyoneda and Yoneda?
23:16:17 <agohoth> or can I do it all in haskell.....
23:16:32 <jle`> dminuoso: look at the definition of Yoneda vs the definition of Codensity
23:16:40 <jle`> you'll see that they are pretty mucht he same thing except for one difference
23:16:43 <iqubic> monochrom: What was the point of your monocrom and multicrom game from earlier?
23:16:44 <monochrom> Look at most people's difficult at (a->b) -> ((a->r)->r) -> ((b->r)->r) for example. Recent example.
23:16:58 <jle`> agohoth: postgresql is a technology that you can use with haskell
23:17:08 <jle`> agohoth: so it's like asking if you need to have both a bow and an arrow
23:17:10 <jle`> oh they left :'(
23:17:47 <ski> dminuoso : `Yoneda' is all about `flip fmap fa :: forall b. (a -> b) -> f b', given `fa :: f a'. cf. how `Codensity' is all about `flip (=<<) ma :: forall b. (a -> m b) -> m b', given `ma :: m a'
23:17:52 <jle`> monochrom: yes, but hopefully they are struggling thorugh it knowing that it won't be something that they'd ever really use to write programs
23:17:58 <jle`> and it's just for their own personal enrichment
23:18:32 <iqubic> See, I get that monochrom :: Cont Bool Int and multichrom = mapCont not monochrom.
23:18:40 <iqubic> Was there anything else to that story?
23:18:44 <jle`> monochrom: maybe that's what you meant by wise
23:18:56 <monochrom> If you say you pulled it off by just supposing f::a->b, m::(a->r)->r, k::b->r, then blindly mechanically combine them in the obvious way to get something of type r...
23:19:16 <monochrom> sure that doesn't require you to be smart.
23:19:37 <jle`> well, there are pointless uncharacteristically difficult things you can do in any language
23:19:41 <dminuoso> ski: Ahh I see.
23:20:08 <monochrom> But the decision to "supposing f::a->b, m::(a->r)->r, k::b->r", as opposed to stare at " (a->b) -> ((a->r)->r) -> ((b->r)->r)" and wait for divine intuition, requires you to be wise.
23:20:11 <jle`> Monad ((->) r) is one of them. you might have to be clever to write/understand it, but you don't need to write/understand it in order to use haskell to its  full effectiveness
23:20:30 <jle`> working it out is just pure self-indulgence
23:20:47 <jle`> of the most grotesque kind
23:20:49 <monochrom> Whenever people look for "intuition", you know they are unwise.  And that covers like 99% of programmers.
23:20:49 <ski> dminuoso : while `Coyoneda' is all about, given `cfb :: exists a. (a -> b,f a)', going to `uncurry fmap cfb :: f b'. cf. how `Density' is all about, given `dwb :: exists a. (w a -> b,w a)', going to `uncurry (<<=) dwb :: w b'
23:22:02 <iqubic> Continuations are something that I'm not going to understand any time soon.
23:22:05 <jle`> Codensity f a = forall r. (a -> f r) -> f r
23:22:15 <jle`>   Yoneda f a = forall r. (a ->   r) -> f r
23:22:20 <dminuoso> iqubic: Do you understand how to use withFile?
23:22:22 <jle`> aw man, just barely missed the indentation
23:22:35 <iqubic> dminuoso: No. No I don't.
23:22:41 <iqubic> :t withFile
23:22:43 <lambdabot> error:
23:22:43 <lambdabot>     • Variable not in scope: withFile
23:22:43 <lambdabot>     • Perhaps you meant one of these:
23:22:46 <jle`> dminuoso: if you look at those two, it's basically the same distinction as between fmap and (=<<)
23:22:49 <dminuoso> % import System.IO
23:22:50 <yahb> dminuoso: 
23:22:52 <dminuoso> % :t withFile
23:22:52 <yahb> dminuoso: FilePath -> IOMode -> (Handle -> IO r) -> IO r
23:22:53 <ski> dminuoso : so, yes, i should have at first been more clear that it's `Yoneda', not `Coyoneda', that's "fmap partially applied to some `f a`"
23:23:02 <iqubic> Oh, that's a continuation.
23:23:13 <jle`> iqubic: mwc-random has a nice continuation thing that i always use
23:23:35 <ski> @type (ContT .) . System.IO.withFile
23:23:36 <lambdabot> FilePath -> GHC.IO.IOMode.IOMode -> ContT r IO GHC.IO.Handle.Types.Handle
23:23:41 <dminuoso> jle`: Right I see. 
23:24:00 <jle`> its random generator is something like uniform :: GenIO -> IO Double
23:24:03 <iqubic> What does '(ContT .) . f' even mean.
23:24:17 <iqubic> uniform :: PrimMonad m => Gen (PrimState m) -> m a
23:24:24 <iqubic> Well, it's that.
23:24:26 <dminuoso> iqubic: Its just a fancy trick to perform composition into later arguments.
23:24:30 <jle`> normally you have to use createSystemRandom :: IO GenIO
23:24:34 <jle`> so like:
23:24:36 <iqubic> https://hackage.haskell.org/package/mwc-random-0.14.0.0/docs/System-Random-MWC.html
23:24:37 <jle`> main = do
23:24:41 <jle`>   g <- createSystemRandom
23:24:52 <jle`>   d <- uniform g
23:24:55 <jle`>   print (d :: Double)
23:24:59 <jle`> to generate a random double
23:25:01 <iqubic> Correct.
23:25:16 <jle`> but you could also use the convenient withSYstemRandom :: (GenIO -> IO a) -> IO a
23:25:18 <dminuoso> iqubic: So the trick there is to turn `(Handle -> IO r) -> IO r` into `ContT r IO Handle`
23:25:24 <jle`> main = withSystemRandom $ \g ->
23:25:26 <jle`>   d <- uniform g
23:25:26 <dminuoso> iqubic: By means of just a newtype wrapper.
23:25:28 <jle`>   print (d :: Double)
23:25:31 <jle`> which is the same program
23:25:31 <iqubic> Sure.
23:25:38 <jle`> do you understand withSystemRandom?
23:25:40 <iqubic> I agree.
23:25:42 <jle`> then you understand continuations 
23:25:43 <iqubic> I understand it.
23:25:45 <jle`> that's all there is to it
23:25:55 <iqubic> dminuoso: What do you have to tell me?
23:26:05 <jle`> withSystemRandom takes a contiuation (what to do with a GenIO if you had it, a GenIO -> IO a), and then returns that IO a
23:26:06 <iqubic> :t (ContT .) . f
23:26:08 <lambdabot> forall k a1 a2 (r :: k) (m :: k -> *) a3. (Show a1, Show a2, Typeable r, Typeable m, Typeable a3, FromExpr (m r)) => a1 -> a2 -> ContT r m a3
23:26:21 <iqubic> WHAT THE BLOODY HELL?!?!
23:26:32 <jle`> that's because f :: Expr
23:26:36 <iqubic> Oh.
23:26:38 <jle`> er, some form of Expr
23:26:41 <jle`> :t f
23:26:42 <lambdabot> FromExpr a => a
23:26:46 <jle`> > f x
23:26:47 <dminuoso> % :T \f -> (ContT .) . f
23:26:47 <yahb> dminuoso: unknown command ':T'; use :? for help.
23:26:48 <lambdabot>  error:
23:26:49 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M821665813245...
23:26:49 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
23:26:50 <dminuoso> % :t \f -> (ContT .) . f
23:26:50 <yahb> dminuoso: forall k a1 a2 a3 (m :: k -> Type) (r :: k). (a1 -> a2 -> (a3 -> m r) -> m r) -> a1 -> a2 -> ContT r m a3
23:26:57 <dminuoso> ^- this is more honest
23:27:16 <iqubic> I see.
23:27:17 <dminuoso> iqubic: If you set `m ~ IO` then everything might fall into place. :)
23:27:29 <iqubic> It does.
23:27:31 <iqubic> I see.
23:27:39 <iqubic> So withFile is a continuation.
23:27:48 <jle`> withFile is written in CPS
23:27:54 <iqubic> Shift and Reset are other mind boggling things.
23:28:01 <iqubic> I understand neither of those.
23:28:09 <jle`> sure maybe, but at least you understand continuations :)
23:28:19 <iqubic> I do understand contiuations.
23:28:26 <dminuoso> iqubic: Everytime you have something of the shape `(s -> t) -> t`, or perhaps `(s -> m t) -> m t` you are looking ta CPS.
23:28:31 <iqubic> The core concept is simple.
23:29:00 <jle`> so "Continuations are something that I'm not going to understand any time soon." => "any time soon" = within six minutes :)
23:29:03 <jle`> so technically true
23:29:04 <iqubic> What blows my mind is that 'return = flip ($)'
23:29:14 <dminuoso> iqubic: That's justified by:
23:29:22 <iqubic> I know how it works.
23:29:23 <dminuoso> % :t ($ "foobar")
23:29:23 <yahb> dminuoso: ([Char] -> b) -> b
23:29:34 <iqubic> I know I know that.
23:29:57 <iqubic> ($ "foobar") is a result in want of a function to handle it.
23:30:09 <iqubic> Which is what a continuation is, to be honest.
23:30:12 <Yucheng> `callCC` isn't that simple to understand imo
23:30:24 <iqubic> No. callCC is some black magic.
23:30:43 <dminuoso> It's not black magic
23:30:52 <iqubic> I think it is.
23:30:54 <monochrom> I have basically abandoned callCC.  It is problematic both theoretically and practically.
23:31:44 <monochrom> Plus it's ugly.
23:32:23 <ski> iqubic : "you don't understand continuations, you just get (more) used to them"
23:32:27 <ski>     Density f a = exists s. (f s -> a,f s)
23:32:28 <ski>   Coyoneda  f a = exists s. (  s -> a,f s)
23:32:45 <ski> (continuing jle`s `Codensity' and `Yoneda' comparision)
23:32:47 <iqubic> monochrom: Care to tell me where you were going with the game host puzzle from earlier?
23:32:53 <monochrom> No.
23:32:55 <ski> jle` : where's the continuations in `mwc-random' ?
23:33:16 <dminuoso> iqubic: The trick to callCC is very simple, if you compare these two lined up:
23:33:19 <dminuoso> Cont   :: ((a -> r)        -> r)        -> Cont r a
23:33:21 <dminuoso> callCC :: ((a -> Cont r b) -> Cont r a) -> Cont r a
23:33:46 * ski . o O ( In Soviet Russia, you understand continuations ? )
23:33:53 <monochrom> Naw.
23:33:58 <monochrom> @quote monochrom CCCP
23:33:58 <lambdabot> monochrom says: in Soviet Russia, you have current-continuation-calls-procedure (CCCP)
23:34:11 <ski> (elsewhere, continuations understands you !)
23:34:31 <jle`> 🎿 ContT MWC.withSystemRandom :: ContT r IO GenIO
23:34:35 <ski> heh, monochrom :)
23:35:01 <jle`> one of these days i'll get around to turning off this extension
23:35:38 <jle`> monochrom: lol
23:35:46 <dminuoso> iqubic: The implementation is a bit mind bending mostly because you have continuations inside continuations going on, but the usage is very simple actually.
23:36:10 <dminuoso> iqubic: https://gist.github.com/dminuoso/6ad9fe0e6efebd333e82aa1d3208116c
23:36:30 <iqubic> Right. k is used as an escape.
23:36:33 <ski> jle` : ok, ty (i just did a quick search for `Cont'/`ContT', assumed you meant that it was already expressed with something like those (or `Codensity',`Managed',&c.))
23:36:41 <dminuoso> callCC gives you a sort of goto, basically.
23:36:48 <jle`> ah yeah, it's a "lowercase-c" continuation
23:37:06 <dminuoso> Do we have Ntinuations by the way?
23:37:17 <jle`> cocontinuations?
23:37:21 <dminuoso> Yes.
23:37:31 <dminuoso> This is a somewhat honest question, actually.
23:37:32 <jle`> co*co = co
23:37:36 <jle`> er, co*co=id
23:38:28 * jle` . o ( Codensity MWC.withSystemRandom :: Codensity IO GenIO )
23:38:49 <dminuoso> iqubic: So with callCC you can effectively declare labels and goto these labels. 
23:38:56 <dminuoso> iqubic: Just like you could in say C. :-)
23:39:27 <jle`> hm now suddenly i feel like Codensity is what i always wanted ContT to be
23:39:53 <monochrom> setjmp-longjmp aspired to be call/cc, but then failed half of the cases.
23:40:32 <dminuoso> monochrom: Haha, when I was writing my own kernel I was quite proud of how "ingenuis" non-local jumps were until I started using them and made a huge mess of things, making it almost impossible to reason about control flow.
23:40:58 <jle`> % :t Codensity (withFile "hello.txt" ReadMode)
23:40:58 <yahb> jle`: Codensity IO Handle
23:41:00 <jle`> 4
23:41:11 <dminuoso> Ended up using them as the mechanism behind exceptions.
23:41:32 <jle`> hm next time i need to clean up continuation hell with nested indents i might just use Codensity instead of Cont
23:41:54 <monochrom> (setjmp-longjmp is intended for only jumping from deeper to shallower in the call chain; other directions are UB. call/cc supports arbitrary directions, and its slower, more complicated implementation shows.)
23:41:57 <dminuoso> % :t ContT
23:41:57 <yahb> dminuoso: forall k a (m :: k -> Type) (r :: k). ((a -> m r) -> m r) -> ContT r m a
23:41:59 <dminuoso> % :t Codensity
23:41:59 <yahb> dminuoso: forall k a (m :: k -> Type). (forall (b :: k). (a -> m b) -> m b) -> Codensity m a
23:42:13 <jle`> Codensity f a = forall r. ContT r f a
23:42:23 <jle`> basically just ContT but you have to be agnostic on the final continuation type
23:42:32 <dminuoso> Okay my head is spinning now.
23:42:45 <jle`> it's like ContT r m a but you can't care about the r, you have to leave it alone
23:42:50 <monochrom> Hey setjmp-longjmp was intended for exceptions when there was only Unix signals!
23:43:01 <jle`> so this works for withFile, withSystemRandom, etc.
23:43:12 <dminuoso> monochrom: They are absolutely great for breaking language semantics. :-)
23:43:30 <dminuoso> monochrom: Somehow I feel like Rusts decision not to include exceptions might not be so bad after all.
23:43:46 <jle`> this basically means ContT is way too powerful to be used just as an indentation cleaner-upper like i was thinking
23:43:58 <jle`> D:
23:44:11 <jle`> meme with bill gates using a giant ping pong paddle
23:45:40 <iqubic> jle`: What works?
23:45:44 <jle`> Codensity
23:45:51 <jle`> it literally works as a drop-in replacement
23:46:10 <iqubic> Oh? And that's good because why?!?!
23:46:24 <jle`> instead of do x <- ContT (withFile ...); y <- ContT (withFile ...); z <- ContT (withFile ...)
23:46:45 <jle`> you can just write do x <- Codensity (withFile ..); y <- Codensity (withFile ...); z <- Codensity (withFile ...)
23:46:54 <jle`> iqubic: what is good? the fact that you can use it as a drop-in replacement?
23:47:02 <iqubic> Yeah.
23:47:09 <jle`> well, it's less powerful, so you don't have to worry about any weird things like callCC, reset, shift
23:47:15 <iqubic> Oh.
23:47:17 <iqubic> I see.
23:47:28 <jle`> basically all i wanted to use it for was to make indentation look prettier
23:47:36 <jle`> so Codensity does the job without all the mess of ContT
23:47:59 <iqubic> But what is the type of the top level function that contains these Codensity constructors?
23:48:09 <jle`> Codensity IO a
23:48:16 <jle`> vs. ContT r IO a
23:48:20 <iqubic> I see.
23:48:43 <iqubic> And what packages export/use Codensity?
23:48:50 <jle`> kan-extensions
23:49:01 <iqubic> And is there a way to convert to and from Codensity and ContT as needed?
23:49:49 <ski>   ContT . flip foldMapA :: (Foldable t,Applicative i,Monoid m) => t a -> ContT m i a  -- can't be done with `Codensity', jle`
23:49:53 <jle`> you can go from Codensity to ContT, but not th eother way around
23:50:22 <ysangkok> how do i tell stack when i build a package, to build a required dependency with a certain build flag?
23:50:40 <jle`>  ski: yea i'm saying that Codensity is less powerful, and sufficiently powerful for my indentation management needs
23:50:44 <ski> (because `foldMapA' is nqCPS, not plain CPS)
23:50:51 <jle`> ysangkok: the easiest way would be probably in your stack.yaml
23:50:56 * ski nods to jle`
23:51:11 <MarcelineVQ> jle`: In fact I thought it was you that told me about this use of Codensity so I was surprised at your surprise.
23:51:29 <MarcelineVQ> Turns out it was ertes and ski :>
23:52:09 <jle`> :>
23:52:30 <ski> iqubic : you can go inbetween `Codensity m a' and `forall o. ContT o m a'
23:52:41 <ski> (backwards direction is rank-2)
23:53:33 <ski> MarcelineVQ : heh, i don't remember that .. how long ago was it ? :)
23:54:17 <MarcelineVQ> awhile, my timstamps don't track the year
23:54:38 <monochrom> ski: I have simpler examples like "multichrom :: (Int -> Bool) -> Bool" cannot be done with Codensity Identity Int.  Even with monochrom, you have to trust me that I don't troll you with "if your predicate is true for 10, I'll do a different thing".
23:55:23 <monochrom> whereas "forall r. (Int -> r) -> r" really requires me to have one single secret number in mind and use it, no more no less, no funny tricks.
23:56:07 <ski> monochrom : yea, stuff like
23:56:16 <MarcelineVQ> ski: certainly at least 2 years, but probably more
23:56:17 <ski> @type cont . flip all
23:56:18 <lambdabot> Foldable t => t a -> Cont Bool a
23:56:19 <ski> @type cont . flip any
23:56:20 <lambdabot> Foldable t => t a -> Cont Bool a
23:57:41 <ski> (which are simpler than `foldMapA' .. i had those in mind as well, but for some reason went with `foldMapA', presumably because `ContT' was more in the vogue, currently, than `Cont' ?)
23:57:53 * ski nods to MarcelineVQ, fair enough
23:58:47 <ski> @let forAll :: Foldable t => t a -> Cont Bool a; forAll = cont . flip any; forSome :: Foldable t => t a -> Cont Bool a; forSome = cont . flip any
23:58:48 <lambdabot>  Defined.
23:58:52 <iqubic> monochrom: Is there a way to tell the two apart and take the path to Heaven?
23:59:32 <ski> @let evalCont :: Cont o o -> o; evalCont = (`runCont` id); evalContT :: Applicative i => ContT o i o -> i o; evalContT = (`runContT` pure)
23:59:34 <lambdabot>  Defined.
