00:40:00 <iqubic> They are back.
01:45:01 * hackage hsimport 0.11.0 - Extend the import list of a Haskell source file  https://hackage.haskell.org/package/hsimport-0.11.0 (DanielTrstenjak)
02:16:30 * hackage joint 0.1.2 - Trying to compose non-composable  https://hackage.haskell.org/package/joint-0.1.2 (iokasimovmt)
02:34:22 <CenturyCoder> hi, i'm new, what's the header line for haskell?
02:35:21 <jgt> CenturyCoder: I'm not sure what you mean by "header line"
02:37:19 <ski> perhaps they mean something like "killer app", or main intended problem domain area
02:38:01 <koz_> Or maybe the #! to run 'scripts'?
02:38:06 <CenturyCoder> lol, I just meant what's the equivalent to #include<iostream> here
02:38:26 <CenturyCoder> and also the #!usr/bin/env haskell line
02:38:46 <koz_> Haskell doesn't work that way. This isn't C++ or Python.
02:38:47 <ski> heh, there's `import' lines
02:39:05 <jgt> CenturyCoder: Haskell isn't typically used for scripting. You _can_ do that with Stack, but that's not normally how you write Haskell programs.
02:39:11 <ski> like `import System.IO'
02:39:19 <CenturyCoder> sounds like Java
02:39:55 <ski> if you want to do Input/Output things, then `System.IO' would be the most common module to import, probably
02:40:03 <jgt> as far as I'm aware, Haskell is relatively dissimilar to Java
02:40:34 <ski> (but the most basic I/O operations are already imported implicitly for you, from the `Prelude' module)
02:41:08 <CenturyCoder> yeah, I just got Prelude in ghci
02:41:16 <ski> @hoogle getLine
02:41:16 <lambdabot> Prelude getLine :: IO String
02:41:16 <lambdabot> System.IO getLine :: IO String
02:41:16 <lambdabot> Data.ByteString getLine :: IO ByteString
02:41:27 <ski> @hoogle putStrLn
02:41:28 <lambdabot> Prelude putStrLn :: String -> IO ()
02:41:28 <lambdabot> System.IO putStrLn :: String -> IO ()
02:41:28 <lambdabot> Data.ByteString putStrLn :: ByteString -> IO ()
02:41:52 <ski> CenturyCoder : try entering, in the interactor :
02:41:57 <CenturyCoder> yay, getLine is cin and putStrLn is cout
02:42:33 <jgt> more or less
02:42:56 <jgt> but if you're new to Haskell, don't expect everything to just be syntax swaps
02:42:56 <ski>   do putStrLn "Hello, what's your name ?"; name <- getLine; putStrLn ("! " ++ reverse name ++ " olleH")
02:43:11 <ski> (then enter a name)
02:43:30 * hackage githash 0.1.3.3 - Compile git revision info into Haskell projects  https://hackage.haskell.org/package/githash-0.1.3.3 (MichaelSnoyman)
02:44:27 <CenturyCoder> ski that works perfectly
02:46:02 <ski> CenturyCoder : now, do the same thing, but in a source file. make a new file, `Hello.hs', and enter into it :
02:46:08 <ski>   main :: IO ()
02:46:11 <ski>   main = do
02:46:16 <ski>     putStrLn "Hello, what's your name ?"
02:46:20 <ski>     name <- getLine
02:46:24 <ski>     putStrLn ("! " ++ reverse name ++ " olleH")
02:46:54 <ski> save the file, then do `:load Hello.hs' in the interactor (`:load' can be abbreviated as just `:l')
02:47:38 <ski> then you can enter `:main' into the interactor, to start off executing `main'
02:48:02 <CenturyCoder> how do I quit prelude??
02:48:29 <jgt> CenturyCoder: Prelude is the name of a standard library. It's not a program you can quit.
02:48:31 <CenturyCoder> ctrl+c doesn't work to exit ghci
02:48:41 <no-n> :quit to exit ghci
02:48:44 <no-n> or :q
02:48:51 <jgt> or ctrl+d
02:48:52 <CenturyCoder> oh, like vim
02:50:33 <ski> (you don't have to quit the interactor, everytime you want to (re)load a source file (a new one, or an updated one). however, it may be nice to start the interactor in the same directory as the source file. you can also use `:cd' to change the current directory, in the interactor)
02:51:20 <lavalike> the word interactor is gonna haunt my dreams now
02:51:34 * ski grins
02:52:22 <jgt> the interactor is the thing you use before you run the whole program through the compilerator
02:53:01 <no-n> and the interpretato
02:53:06 <CenturyCoder> lol
02:53:19 <ski> an interactor is where you interact, you know, interactively, with a system
02:54:02 <ski> (an interactor may be using compilation, or interpretation, to evaluate, to exectute, code)
02:55:10 <ski> (opposite is batch processing. which may also be employing either compilation, or interpretaton)
02:56:08 <CenturyCoder> wow, tab is rejected in favor of spaces
02:56:31 <lavalike> the fine grained control makes for nicer code anyway
02:56:35 <jgt> like a Makefile, but opposite
02:58:15 <CenturyCoder> wow, I get a .exe output file
02:58:23 <ski> CenturyCoder : tabs tend to interact ficklish with layout. they can be used, but it's probably easier for a beginner to only use spaces
02:58:31 <lavalike> haskell seems full of surprises today!
02:58:38 * ski supposes CenturyCoder is on Windows
02:59:05 <CenturyCoder> yeah, I got kafka on vm though
02:59:24 <CenturyCoder> but right now I'm just using win 10 like a n00b
03:00:42 <ski> CenturyCoder : do you have some text or tutorial to start reading ?
03:01:05 <ski> if you have questions, don't hesitate to ask
03:04:18 <ski> @where CIS194
03:04:18 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
03:04:30 <ski> has exercises you can try, if you'd like to
03:06:02 <CenturyCoder> thanks, i'll check it out
03:07:24 <ski> (also has some more material, iirc)
03:19:34 * ski idly wonders what this Kafka, CenturyCoder mentioned, is
03:21:43 <typetetris> How can I create a Handle for a file descriptor on linux? How can I get the file descriptor underlying a file handle on linux?
03:21:57 <merijn> typetetris: You want the unix package
03:22:20 <merijn> @hackage unix
03:22:20 <lambdabot> http://hackage.haskell.org/package/unix
03:22:53 <merijn> Although you generally don't need those
03:23:01 * jgt is beginning to think that YAML for Yesod settings is a mistake
03:23:10 <merijn> jgt: YAML is a mistake :p
03:23:11 <typetetris> merijn: thanks tried to find by looking at the implementation of hPutStrLn and the like.
03:23:20 <jgt> merijn: yeah I agree
03:23:25 <merijn> typetetris: Yeah, that's going to be several layers of indirection :p
03:24:58 <merijn> typetetris: If you want anything posix-y that's missing unix is generally the answer :p Of course that will cost you windows portability
03:25:56 <typetetris> merijn: I want to write a test, wether a file descriptor was closed on exec or not. I don't even know the words for that kind of thing on windows, so that has to be provided by someone else.
03:51:33 <oo_miguel> Not sure if this is the right place to ask. Reading "Category for Programmers by Bartosz Milewski". I do not understand how every category has an opposite category with just the morphisms inverted. E.g. In the "category of sets" I have exactly one function from each object to the singleton set: "unit :: a -> ()" which is something I believe to understand. But inverting this does not make any sense to me:
03:51:35 <oo_miguel> having exactly ONE "unit_inv :: () -> a" for each a? what am I missing? 
03:53:21 <oo_miguel> (This also obviously contradicts my understanding that i can use () to pick every single object from every set as e.g having an : "f22 :: () -> Int" "f22 _ = 22"
03:56:36 <lavalike> oo_miguel: when you reverse the arrows the character of the objects changes
03:56:38 <nil> oo_miguel: unit_inv is not a function
03:57:00 <merijn> Man...I really wish there was an easy way to write an existential list or something
03:57:25 <merijn> Like "[exists a . Read a => a -> Foo]"
03:58:05 <lavalike> whereas you have to hide the first part inside Foo's definition?
03:58:15 <oo_miguel> nil: my unit_inv in the example above is not a function? or the inverted morphism?
03:58:29 <nil> both
03:58:47 <merijn> lavalike: It means I have to wrap all the existing functions creating Foo, since they all take different input types and that wrapping is very verbose
03:59:10 <oo_miguel> "something :: () -> a" looks like a function to me ;)
03:59:35 <oo_miguel> however there is not much it can do, I agree
04:01:26 <nil> oo_miguel: if a morphism from a to b in Set is a function, that is, a relation between elements of a and elements of b such that every element of a is in relation to exactly one element of b, then you can think of a morphism from b to a in Set^op as a relation between elements of b and elements of a such that every element of a is in relation to exactly one element of b (which is not a function)
04:02:24 <nil> so you might describe unit_inv as a relation R such that  () R x  holds for all x in a
04:02:45 <nil> (please, somebody correct me if i'm wrong)
04:06:35 <nil> oo_miguel: i like this answer too https://math.stackexchange.com/a/981498
04:07:51 <nil> the idea is that a *morphism* a -> b in Set^op corresponds to a *function* from b to a. so unit and unit_inv are really describing the same function
04:09:25 <oo_miguel> hhmmm
04:15:30 <oo_miguel> ok got it! in SET^OP wer are reversing the arrows and just changing their "meaning" to the opposite
04:15:55 <nil> yep. in any opposite category, really
04:15:57 <oo_miguel> "arrow" a->b changes to b->a but represents exactly the same morphism
04:16:21 <oo_miguel> ah ok good to know it applies to each ^OP thank you
04:17:38 <asheshambasta> is this a bug in this auto-update package or usually a sign of something I've missed? https://gist.github.com/asheshambasta/c090b27fde05ae2c055146318187e5a9 
04:19:30 * hackage servant-pipes 0.15.1 - Servant Stream support for pipes  https://hackage.haskell.org/package/servant-pipes-0.15.1 (phadej)
04:22:26 <maralorn> Is there an autoformater for cabal files?
04:25:37 <jgt> maralorn: there is
04:25:49 <jgt> maralorn: http://hackage.haskell.org/package/cabal-fmt
04:34:19 <maralorn> @karma+ jgt
04:34:19 <lambdabot> jgt's karma raised to 2.
04:45:30 * hackage gloss 1.13.1.1 - Painless 2D vector graphics, animations and simulations.  https://hackage.haskell.org/package/gloss-1.13.1.1 (BenLippmeier)
04:50:25 <asheshambasta> is there a way other than text-replace to 'unescape' a Text in Haskell? I have a large JSON blob that has been rendered to text with escape chars. 
05:45:06 <maerwald> oh, why not base64?
06:06:35 <homebeach[m]1> listOfStringsForDistanceRecursion :: Float -> [[Char]] -> [[Char]] -> [[Char]]
06:06:36 <homebeach[m]1> listOfStringsForDistanceRecursion d ss [] = []
06:06:37 <homebeach[m]1> listOfStringsForDistanceRecursion d ss (w:ws) = [ x | x <- ss, (distance x w) <= d] ++ listOfStringsForDistanceRecursion d ss ws
06:07:31 * hackage path-io 1.5.0 - Interface to ‘directory’ package for users of ‘path’  https://hackage.haskell.org/package/path-io-1.5.0 (mrkkrp)
06:08:22 * homebeach[m]1 sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/IgMVkkpGCIXpyAOGloufSoTx >
06:09:59 <homebeach[m]1> If I set it like this: listOfStringsForDistanceRecursion d ss (w:ws) = [[ x | x <- ss, (distance x w) <= d]] ++ listOfStringsForDistanceRecursion d ss ws
06:10:10 * homebeach[m]1 sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/CovjrIMusPKcjGmFBLzINFge >
06:13:00 * hackage first-class-families 0.6.0.0 - First class type families  https://hackage.haskell.org/package/first-class-families-0.6.0.0 (lyxia)
06:18:27 <maralorn> So: I am in cabal hell. I looked at it and understand that my dependencys cannot be resolved. Now I am very sure I know a solution which will compile but don‘t wanna edit all packages involved. Can I override it somehow?
06:20:47 <maerwald> Override what?
06:23:17 <maralorn> maerwald: My reflex-dom-core requires lens 4.17 I want it to use lens 4.17.1.
06:23:31 <maralorn> maerwald: But it‘s just a dependency.
06:24:41 <maralorn> So I would like to write in my cabal file: "Use lens 4.17.1 no matter what the dependencys say"
06:24:56 <maerwald> maralorn: did you check out https://www.haskell.org/cabal/users-guide/installing-packages.html#cmdoption-setup-configure-allow-newer
06:25:12 <higherorder> Hi! Quick question: is the type `Either` suitable for when you want a sum type with two options, but without the added semantics that Left and Right have special meaning?
06:25:23 <maralorn> @karma+ maerwald
06:25:24 <lambdabot> maerwald's karma raised to 7.
06:25:29 <maerwald> maybe: cabal new-install --allow-newer=lens --constraint="lens==4.17.1"
06:29:08 <maralorn> Uh, apparently
06:29:32 <maralorn> rejecting: lens-4.17.1 (conflict: reflex-dom-core => lens==4.17/installed-AoH...)
06:30:14 <maralorn> reflex-platform specifys dependencys different than I understand. And 4.17.1 is not newer than 4.17/installed-AoH...
06:35:43 <jgt> higherorder: is there any reason for you not to write your own type?
06:38:07 <higherorder> jgt: no, just curious if there is a built in type for that!
06:39:24 <jgt> higherorder: Either doesn't really have special meaning, if you're referring to it commonly being used as either an error or successful result
06:39:57 <jgt> higherorder: and of course it isn't the only sum type with two constructors — Bool is another, for example
06:57:08 <jzyamateur> How come one can use '=='  for defining Eq instance for a given data type? e.g. "data Trial = TT" followed by "instance Eq Trial where TT == TT = True" is a perfect definition to specify Trial to be an Eq instance.
06:58:20 <glguy> jzyamateur: You're not using == in that instance, you're defining it
06:58:54 <jzyamateur> aaah.. got it.
06:59:56 <jzyamateur> The infix operation had confused me as a usage
07:06:28 <obliga> Hey! Wondering if anyone could help me with a pretty simple problem?
07:06:45 <jgt> obliga: just ask your question. If someone is able and willing to help, they will
07:07:56 <obliga> I'm trying to add a list recursively and check for each step that it doesn't go bellow zero
07:08:41 <jgt> obliga: when you say "add", do you mean "sum"?
07:09:02 <jgt> and I'm guessing this is summing a list of integers
07:09:07 <obliga> well not the whole list, just the first two values
07:09:24 <glguy> What's the question?
07:10:09 <obliga> I get Couldn't match expected type `Int' with actual type `[Integer]' on the recursive bit
07:10:22 <obliga> should I maybe just paste what I've written?
07:10:28 <glguy> You can put your code and any error messages on a pastebin like gist.github.com
07:10:32 <Ariakenom> ah the dreaded monomorphism restriction
07:10:50 <glguy> Ariakenom: probably not in this case
07:11:09 <Ariakenom> obliga: do you have type signatures on your top level definitions?
07:11:35 <obliga> here's the code https://pastebin.com/Cx3Jv0jU
07:12:52 <glguy> obliga: That code loads in GHCi, no error message
07:13:00 <glguy> Try saving the file
07:13:12 <obliga> it loads, but it doesn't run
07:13:27 <glguy> Try:  testfunc 0 [1,2,3]
07:13:51 <glguy> Err, no use an even-lengthed list since you forgot the case with a single element
07:14:08 <glguy> Like: *Help> testfunc 0 [1..4]
07:14:08 <glguy> "Success"
07:15:34 <Ariakenom> (oh yeah true one was a list)
07:15:48 <obliga> hmm.. that shouldn't be a success though
07:17:59 <obliga> I got it working. Added a line testfunc x [] = "Failed"
07:18:04 <obliga> Thanks guys!
07:24:00 * hackage vega-view 0.3.1.2 - Easily view Vega or Vega-Lite visualizations.  https://hackage.haskell.org/package/vega-view-0.3.1.2 (DouglasBurke)
07:32:00 * hackage byteslice 0.1.3.0 - Slicing managed and unmanaged memory  https://hackage.haskell.org/package/byteslice-0.1.3.0 (andrewthad)
07:55:14 <Zemyla> Is there a length tagged Vec whose concatenation operation is faster than O(n)?
07:55:25 <ski> obliga : instead of `String's, consider using `Bool'eans
07:55:40 <ski> @quote stark
07:55:41 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
07:56:28 <glguy> ski: In that case there ended up being no success case, so () would be an even tighter fit :)
07:56:33 <lyxia> Zemyla: "difference Vec"
07:57:49 <ski> obliga : you should also write that addition only once, instead of twice. give the sum a name, in a `where' or `let'-`in'
07:58:31 <ski> glguy : depends on whether we're to take their last comment above at face value
07:59:04 <glguy> I think there was enough confusion on the algorithm itself that other improvements were premature
08:00:15 <ski> possibly
08:01:09 <dmwit> Zemyla: http://hackage.haskell.org/package/parameterized-utils-2.0/docs/Data-Parameterized-Context-Unsafe.html
08:10:00 * hackage marshal-contt 0.2.0.0 - A ContT-based wrapper for Haskell-to-C marshalling functions.  https://hackage.haskell.org/package/marshal-contt-0.2.0.0 (typedrat)
08:46:08 <palo> is there a way to access the version number from my cabal file in the main function? I want to print the version number of my binary at the start.
08:46:25 <maralorn> Hmpf: unordered-containers-0.2.10.0 contains Data.HashMap.Strict.alterF with the comment "Since 0.2.9". But 0.2.9 doesn't have alterF.
08:47:13 <merijn> palo: You want: https://cabal.readthedocs.io/en/latest/developing-packages.html?highlight=getSysconfDir#accessing-data-files-from-package-code
08:47:25 <merijn> palo: Which also exposes the version
08:47:25 <argent0> hi, how can I install ghcid using cabal? I'm getting this after follobing ghcid's git-repo instrunctions. https://bpaste.net/show/3Q-q
08:48:12 <phadej> merijn, palo: https://cabal.readthedocs.io/en/latest/developing-packages.html?#accessing-the-package-version is a better link
08:48:32 <palo> thanks merijn and phadej will check it out
08:49:03 <merijn> phadej: That part is literally half a screen down, but doesn't contain any of the "how do I generate the Paths_ module" bits :)
08:50:46 <phadej> merijn: well, no, but it says "before mentioned Paths_..."
08:53:35 <palo> I had no problem to understand and using it. 
08:53:41 <palo> Thanks again.
08:55:15 <argent0> ghcid's cabal file has the `executable: ghcid` line. Why is cabal install saying it doesn't?
09:05:02 <jzyamateur> Is there a way to check if a given term/type obeys a given typeclass using ghci?
09:06:02 <glguy> > :t (id :: Num a => a -> a) "test"
09:06:04 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
09:06:06 <glguy> :t (id :: Num a => a -> a) "test"
09:06:07 <lambdabot> error:
09:06:07 <lambdabot>     • No instance for (Num [Char])
09:06:08 <lambdabot>         arising from an expression type signature
09:06:19 <glguy> jzyamateur: At a minimum you can do that
09:08:00 <jzyamateur> glguy, you put the expected type with constraint before the term?
09:08:30 <glguy> I specialized the type of `id` to require a constraint I was interested in
09:08:41 <jzyamateur> Interesting
09:08:44 <glguy> and then I tried to apply that specialized id function to a term of interest
09:09:00 * hackage servant-docs 0.11.4 - generate API docs for your servant webservice  https://hackage.haskell.org/package/servant-docs-0.11.4 (phadej)
09:10:01 * hackage servant-http-streams 0.16.0.1, servant-client 0.16.0.1 (phadej): https://qbin.io/flying-pledge-oam1
09:32:00 * hackage pinboard-notes-backup 1.0.5 - Back up the notes you've saved to Pinboard  https://hackage.haskell.org/package/pinboard-notes-backup-1.0.5 (bdesham)
10:09:11 <megatr0nz> hello there, anyone that could help me with this code? https://codeshare.io/anmevV
10:10:21 <shapr> megatr0nz: does it work?
10:10:37 <megatr0nz> no, i am getting stack overflow
10:10:41 <tamme> Can someone explain to me what is the meaning of class inheritance in Haskell?
10:11:13 <megatr0nz> but i dont have enough experience w/ haskell neither w/ Text.Read to find what;s wrong
10:11:43 <shapr> megatr0nz: I don't either, I'd use a parser
10:12:06 <shapr> tamme: What's your definition of class inheritance?
10:12:20 <cocreature> megatr0nz: on which input do you get a stack overflow?
10:12:40 <cocreature> but yeah a proper parser combinator library is usually a beter choice than Text.Read
10:12:47 <tamme> eg : class  (Eq a) => Ord a  where … 
10:12:50 <shapr> tamme: there aren't classes in the context of "objects". The only related thing I can think of is ...
10:12:51 <shapr> oh that
10:13:03 <geekosaur> I'd less call that inheritance than prerequisite
10:13:17 <Rembane> tamme: There is none, but one type class can state that it needs all elements that are a member of that class to also be member of another class.
10:13:19 <geekosaur> to have a valid Ord instance, you must also have a valid Eq instance somewhere
10:13:30 <shapr> tamme: that means "you can only define Ord-related operations on a type if it already has Eq defined for that type"
10:13:37 <shapr> right, what geekosaur said
10:14:31 <megatr0nz> shapr: well I am trying to write a parser for a basic calculator. the input is a string like this "1 + 4 / 2 + 7"
10:14:55 <geekosaur> (I wouldn't say "already" either, because you can sometimes define the prerequisite in terms of the class that requires it. such as deriving Applicative's <*> from Monad's ap. but that's getting somewhat advanced)
10:15:03 <tamme>  Kann es beim Nutzen von 
10:15:09 <shapr> was?
10:15:20 <tamme> ok, and what is the purpose behind creating such conditions?
10:15:50 <megatr0nz> i didn't get you, rephrase please
10:16:04 <geekosaur> megatr0nz, one thing I notice is it ends up invoking itself recursively because it's effectively: expr = expr '+' expr | expr '-' expr | ...
10:16:30 <geekosaur> left recursion in this kind of grammar is usually a problem
10:18:08 <megatr0nz> okay and how can I solve the problem w/o changing the grammar?
10:18:36 <geekosaur> tamme, in the case of Ord, if you have Eq (that is, (==)) then that and (<=) give you all the comparison operators.
10:20:27 <geekosaur> rather than having to define all of them yourself (that said, we usually derive Ord so it doesn't come up anyway)
10:21:45 <geekosaur> usually its that kind of idea though, you need the operations from one typeclass to define another one that's more specific in some sense
10:23:30 <tamme> mh ok. So the advantage is that you can do several things within a type class, but without having to actually implement all functionalities, if you do not necessarily need them
10:23:54 <monochrom> No. The implementer has to implement all functionalities.
10:24:47 <geekosaur> that sounds like you read the first thing I wrote and ignored all the rest
10:24:54 <monochrom> Instead, it is the user who doesn't have to keep writing "foo :: (Eq a, Ord a) => ..." all the time.  They just have to write "foo :: Ord a => ..." and they get Eq for free.
10:25:10 <maralorn> I am looking for parseMaybe :: (a -> Parser b) -> Maybe a -> Parser Maybe b
10:25:31 <Rembane> maralorn: Have you tried fmap? 
10:25:45 <Rembane> maralorn: ...almost fmap, that almost looks like bind. 
10:25:48 <Rembane> :t (>>=)
10:25:49 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:26:07 <Rembane> :t traverse 
10:26:07 <maralorn> well almost …
10:26:08 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
10:26:14 <maralorn> aah
10:26:21 <Rembane> That's also almost
10:26:41 <maralorn> No, that looks perfect.
10:26:42 <tamme> ok, I mean, if I only need (==), I do not have to implement (<=) for instance.
10:26:54 <Rembane> maralorn: Sweet! 
10:26:59 <monochrom> If you only need (==), you only incur Eq.
10:28:28 <tamme> Yes . but you could just as well have put everything into one type class called "Rel" or something like that.
10:29:10 <maralorn> Rembane: I don‘t really get it … But the type is right.^^
10:29:17 <geekosaur> there are types for which comparisons other than equal/not-equal have no meaning
10:29:30 <maralorn> @karma+ Rembane
10:29:31 <lambdabot> Rembane's karma raised to 2.
10:29:31 <geekosaur> is (4,3) greater or less than (3,4)?
10:30:09 <geekosaur> (answer: the question is meaningless, because you need to know what the tuple represents to know the answer.)
10:30:09 <Rembane> maralorn: Getting the type is a very good start. :)
10:30:17 <Rembane> maralorn: Thank you for the karma! 
10:30:26 <Rembane> geekosaur: I was going to answer yes! :(
10:30:30 * hackage net-mqtt 0.5.0.2 - An MQTT Protocol Implementation.  https://hackage.haskell.org/package/net-mqtt-0.5.0.2 (dustin)
10:30:50 <geekosaur> Rembane, in some uses they're equal
10:31:19 <Rembane> geekosaur: that's true. 
10:31:26 <monochrom> Actually the sentence " if I only need (==), I do not have to implement (<=) for instance" is very confused.
10:31:34 <geekosaur> Eq is more fundamental than Ord, and there's reason to treat it separately from the other comparison operators
10:32:02 <geekosaur> it was wrong and I don't know how they pulled that from what I said, which is the minimal definition of Ord (unless you go the compare route)
10:32:26 <monochrom> "I only need (==)" this is spoken by the user.  "I do not have to implement (<=)" this is spoken by the implementer.
10:32:39 <monochrom> The user and the implementer always have opposite stakes.
10:36:19 <EvanR> hmmm... preorder is in some sense more fundamental than ==
10:36:37 <monochrom> But Ord is not preorder.
10:36:49 <EvanR> why the hell not
10:37:16 <EvanR> we should have preorders on stuff
10:37:46 <EvanR> if semigroup is invited...
10:38:08 * Clint groans.
10:39:40 <monochrom> You can always propose a preorder class.
10:40:53 <monochrom> But then it would be a sibling, not parent, of Eq. Instead they would be common parents of Ord.
10:41:10 <EvanR> cute
10:42:56 <maralorn> I have a new one^^ maybePrio = (a -> P Maybe a) -> Maybe a -> P Maybe a
10:44:31 <maralorn> Looks kinda like bind, but isn‘t …
10:45:35 <monochrom> Sorry what is P again? Is it a monad transformer?
10:46:10 <monochrom> If so, maybePrio is probably two binds and a lift.
10:48:04 <maralorn> monochrom: Now it‘s Aeson.Parser in my case.
10:49:01 <maralorn> :t flip (>>=) . return
10:49:02 <lambdabot> Monad m => m b -> m a -> m b
10:49:28 <maralorn> :t flip (>>=)
10:49:29 <lambdabot> Monad m => (a -> m b) -> m a -> m b
10:49:45 <maralorn> :t flip ((>>=) . return)
10:49:46 <lambdabot> Monad m => (a -> m b) -> a -> m b
10:50:09 <maralorn> Now I only need a Monad instance for Parser Maybe?
10:56:53 <maralorn> :t (fmap join .) . traverse
10:56:55 <lambdabot> (Monad m, Traversable m, Applicative f) => (a1 -> f (m a2)) -> m a1 -> f (m a2)
11:57:38 <dmwit> % :m + Data.Aeson
11:57:38 <yahb> dmwit: ; <no location info>: error:; Could not find module `Data.Aeson'; Perhaps you meant Data.Version (from base-4.12.0.0)
11:57:45 <dmwit> maralorn: MaybeT Parser
11:59:35 <fresheyeball> how can I compose 2 prisms
12:05:30 * hackage Win32-errors 0.2.2.5 - Alternative error handling for Win32 foreign calls  https://hackage.haskell.org/package/Win32-errors-0.2.2.5 (gussen)
12:07:41 <dmwit> fresheyeball: The usual answer for other optics is (.). I would be pretty surprised if it weren't the right answer for prisms, too. If you tried that and it isn't working, I propose that you show us a minimal example.
12:25:28 <shapr> Is there a way to do a join in persistent against a foreign key that's not *Id?
12:25:48 <merijn> shapr: You can't do joins in persistent at all?
12:25:58 <merijn> Are you thinking of esqueleto, maybe?
12:26:07 <shapr> never tried esqueleto, maybe I should
12:26:24 <merijn> shapr: tbh, I looked at the API and thought it was *way* to complicated
12:26:36 <merijn> shapr: It doesn't even guarantee all your queries are typesafe, just "most"
12:26:43 <shapr> which? esqueleto?
12:26:47 <merijn> shapr: In the end I ended up just combining raw SQL with persistent
12:26:52 <merijn> shapr: Yeah, esqueleto
12:27:36 <shapr> I have a one to many datatype, and I want the many to refer to a different column that's not OneId. Is that possible?
12:27:52 <merijn> shapr: Oh, you just want a different Foreign key?
12:28:17 <merijn> shapr: It's possible, just poorly documented (in that the docs point at the tests): https://github.com/yesodweb/persistent/blob/master/persistent-test/src/CompositeTest.hs#L14-L51
12:28:33 <shapr> this fails to compile: https://gist.github.com/shapr/4615f7751dbf12102599b20c8b07c655
12:28:39 * shapr reads the link
12:32:27 <shapr> merijn: mostly I want to be able to use this in scotty: post "/annotate" $ do (a :: Annotation) <- jsonData
12:32:55 <shapr> Is there a better/easier way to convert a POST into a value that's the many side of a one to many?
12:39:30 * hackage lzlib 0.2.0.0 - lzlib bindings  https://hackage.haskell.org/package/lzlib-0.2.0.0 (vmchale)
12:45:29 <shapr> merijn: are you easily able to convert POST data to a value for esqueleto?
12:47:00 * hackage polysemy 1.2.1.0 - Higher-order, low-boilerplate, zero-cost free monads.  https://hackage.haskell.org/package/polysemy-1.2.1.0 (isovector)
12:52:04 <shapr> ah, this is my problem: https://stackoverflow.com/questions/46901164/persistent-tosqlkey-for-custom-primary-key
12:52:13 <shapr> but that does not include a fix
12:52:27 <merijn> shapr: I don't really do web, so I've never had to convert POST data and I didn't really try esqueleto beyond just looking at the docs and deciding I'd rather just write SQL
12:52:53 <shapr> hm
12:54:18 <shapr> I'd really rather not figure out how to explicitly pass around the ID of the record when that value is implicit.
12:57:26 <buhman> is there a shorter way to express: foldr (\(a, b) (c, d) -> (a + c, b + d)) (0, 0)
12:57:57 <shapr> @pl foldr (\(a, b) (c, d) -> (a + c, b + d)) (0, 0)
12:57:57 <lambdabot> foldr (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))) (0, 0)
12:58:01 <shapr> wow, that was not shorter
12:58:02 <monochrom> haha
12:58:13 <merijn> buhman: Sum monoid!
12:58:44 <merijn> :t getSum . foldMap (bimap Sum Sum)
12:58:45 <lambdabot> error:
12:58:45 <lambdabot>     • Couldn't match type ‘p (Sum a)’ with ‘Sum’
12:58:45 <lambdabot>       Expected type: t (p a a1) -> Sum (Sum a1)
12:58:50 <merijn> eh...whoops :)
12:58:58 <merijn> :t bimap getSum getSum . foldMap (bimap Sum Sum)
12:59:00 <lambdabot> (Bifunctor p, Foldable t, Monoid (p (Sum b) (Sum d))) => t (p b d) -> p b d
12:59:14 <merijn> Not shorter like that, but you can probably avoid the bimap
12:59:20 <merijn> Depending on context
13:00:30 <merijn> Especially if you can modify the code producing the tuples
13:00:49 <buhman> sure, I can
13:01:08 <buhman> I've never seen foldMap before
13:01:10 <merijn> In the extreme you can reduce it to mconcat :p
13:01:14 <merijn> :t foldMap
13:01:16 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
13:01:40 <merijn> > foldMap Sum [1..10]
13:01:42 <lambdabot>  Sum {getSum = 55}
13:01:54 <merijn> buhman: foldMap is amazing, like top 5 function for sure :p
13:01:57 <shapr> I thought using sqlite+persistent would be a shortcut to getting this working, perhaps I should be saving a dir of json as a database.
13:02:18 <monochrom> foldMap is the theory behind MapReduce.
13:02:29 <merijn> > foldMap Product [1..10]
13:02:31 <lambdabot>  Product {getProduct = 3628800}
13:02:34 <monochrom> Although, the Haskell version doesn't do parallelism.
13:02:54 <buhman> oh, I vaguely remember reading about this ages ago
13:03:59 <merijn> > mconcat $ ((,) <$> [Sum 1..5] <*> [Sum 6..10]
13:04:01 <lambdabot>  <hint>:1:46: error:
13:04:02 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
13:04:04 <monochrom> the "map" part refers to the a->m function, the "reduce" part refers to having a monoid (m is the monoid) so you can have mconcat.
13:04:05 <merijn> aww...
13:04:18 <merijn> > mconcat $ (,) <$> [Sum 1..5] <*> [Sum 6..10]
13:04:20 <lambdabot>  error:
13:04:21 <lambdabot>      • No instance for (Enum (Sum Integer))
13:04:21 <lambdabot>          arising from a use of ‘e_115610’
13:04:28 <merijn> Really?
13:04:35 <monochrom> (In Haskellland we say "fold" instead of "reduce".)
13:04:41 <merijn> This is a travesy!
13:05:11 <merijn> I'm gonna open a PR immediately
13:05:21 <monochrom> @type (,) <$> [Sum 1..5] <*> [Sum 6..10]
13:05:22 <lambdabot> (Num a1, Num a2, Enum (Sum a1), Enum (Sum a2)) => [(Sum a1, Sum a2)]
13:05:26 <shapr> traversesy!
13:05:35 <merijn> monochrom: No Enum instance for Sum and Product :O
13:05:45 <monochrom> Oh, that.
13:06:21 <monochrom> > Sum 1 + 5
13:06:23 <lambdabot>  Sum {getSum = 6}
13:06:29 <monochrom> OK, at least we have that.
13:06:40 <merijn> monochrom: It has almost all the other instance you can imagine, yes
13:07:04 <monochrom> Yeah, Enum a => Enum (Sum a) should be pretty natural.
13:08:47 <buhman> https://gist.github.com/buhman/92dcc629a499f3cdee5798ba1e3d9e1c that's ultra cool
13:10:21 <merijn> buhman: You can push the sum further forward just make count insert "Sum 1" and then you can even elimiante the bimap
13:11:06 <merijn> As monochrom demonstrated Sum Int is still a Num instance so the (+) will keep working too :)
13:11:14 <buhman> Wow
13:11:33 <merijn> buhman: Also, note:
13:11:37 <merijn> > 5 :: Sum Int
13:11:39 <lambdabot>  Sum {getSum = 5}
13:12:25 <merijn> buhman: Since we have "instance Num a => Num (Sum a)" literals will "just" work as will all standard arithmetic :)
13:14:00 <merijn> So I think it might just work with only changing the type and not even require you to modify the code :p
13:15:10 <buhman> indeed
13:15:13 <buhman> almost
13:15:33 <buhman> https://gist.github.com/buhman/af1955f35be9ab3d441d89e7f1821d2c (line 10)
13:16:23 <buhman> > uncurry (*) (Sum 2, 3)
13:16:25 <lambdabot>  Sum {getSum = 6}
13:16:30 <buhman> oh
13:17:06 <buhman> no bimap needed at all
13:18:50 <fresheyeball> can I compose `at` with itself to make a bigger prism?
13:18:57 <fresheyeball> I need to access a value in nested maps
13:19:01 <fresheyeball> and want to learn to do it with lens
13:19:14 <fresheyeball> myMay ^? at x . at y
13:19:21 <fresheyeball> does not work
13:19:42 <shachaf> There are no prisms involved in that expression.
13:19:57 <fresheyeball> shachaf: then I just don't know lens well enough
13:20:12 <shachaf> What's the thing you actually want to do?
13:20:24 <fresheyeball> access a value in a nested map
13:20:46 <shachaf> Read-only?
13:21:03 <buhman> merijn: that's awesome that I can just change my declared type and all of my constants magically become that type
13:21:16 <fresheyeball> yes just read 
13:21:20 <shachaf> The short answer is "use ix instead of at".
13:21:53 <fresheyeball> ok cool, I just was using the wrong one
13:22:02 <fresheyeball> I assume ix is type safe and not going to fromJust on me
13:22:39 <shachaf> I feel like you need the long answer here.
13:22:56 <shachaf> But you can test that specific question easily enough.
13:23:28 <shachaf> It's not just a matter of not knowing the right thing exists, though. You can do it with "at" as well. ix k = at k . _Just
14:01:30 * hackage cpkg 0.2.3.2 - Build tool for C  https://hackage.haskell.org/package/cpkg-0.2.3.2 (vmchale)
14:19:04 <glittershark> If I have non-.hs source files that I include via template-haskell, how do I tell cabal that changes to those files should trigger a recompilation on the dependent modules?
14:19:24 <glittershark> I'm getting kinda tired of running cabal clean all the time
14:21:10 <freeman42x> anyone know what the name for GPLv2 is that can be used in the cabal file? too lazy to create new project to check lol
14:21:44 <sarahzrf> fresheyeball: ix is an affine traversal—it has no targets if the index does not exist
14:22:17 <sarahzrf> > toListOf (ix 3) "hello"
14:22:19 <lambdabot>  "l"
14:22:24 <sarahzrf> > toListOf (ix 20) "hello"
14:22:26 <lambdabot>  ""
14:22:58 <sarahzrf> otoh, "at" is a /Lens/ which always has exactly 1 target, and that target is a Maybe
14:23:12 <sarahzrf> it's a sort of virtual target representing the presence or absence of the index
14:23:34 <sarahzrf> so you can use it to add or remove something, whereas assigning using ix does nothing if the index is not already there since there are no targets to affect
14:23:51 <glittershark> the difference is that lenses can be set, whereas traversals can only be changed
14:24:00 <sarahzrf> no, traversals can be set
14:24:12 <sarahzrf> > set (ix 3) 'c' "hello"
14:24:12 <glittershark> understanding why "at" is a Lens was like the biggest lightbulb in understanding lens in general
14:24:14 <lambdabot>  "helco"
14:24:17 <glittershark> sorry I meant like
14:24:19 <sarahzrf> > set traverse 'c' "hello"
14:24:20 <glittershark> written to?
14:24:21 <lambdabot>  "ccccc"
14:24:29 <glittershark> I meant set the idea not set the function :P
14:24:37 <sarahzrf> hrm
14:24:56 <glittershark> sorry I'm just confusing things
14:25:01 <glittershark> your explanation was better than mine, sorry
14:25:06 <sarahzrf> heh
14:25:21 <glittershark> another cool "brain-breaking" lens is contains
14:25:37 <glittershark> which is a lens on set membership that targets a Boolean
14:26:33 <sarahzrf> here's the key point: accessing something in a Map k v will generally give you a Maybe v regardless of whether you use ix or at, but: with ix, the Maybe is because you're using preview, whereas ix itself will possibly preduce a v, whereas with at, the Maybe is because at itself produces a Maybe, and you use view
14:27:00 <freeman42x> ah, it was `GPL-2.0-only`
14:27:00 <sarahzrf> *produce
14:28:06 <sarahzrf> indeed, trying to use view with ix will give you a type error (unless v is a monoid, in which case you'll get mempty if the index doesn't exist)
14:29:21 <nshepperd_> > M.empty & at 3 .~ Just "hello"
14:29:23 <lambdabot>  fromList [(3,"hello")]
14:31:34 <iqubic> What's going on here?
14:31:43 <iqubic> How does that?!
14:32:27 <iqubic> :t (.~)
14:32:28 <lambdabot> ASetter s t a b -> b -> s -> t
14:32:37 <iqubic> :t at
14:32:38 <lambdabot> (At m, Functor f) => Index m -> (Maybe (IxValue m) -> f (Maybe (IxValue m))) -> m -> f m
14:36:10 <nshepperd_> > set (at 3) (Just "hello") M.empty
14:36:12 <lambdabot>  fromList [(3,"hello")]
14:37:00 * hackage thumbnail-polish 0.0.1.0 - Image thumbnail creation  https://hackage.haskell.org/package/thumbnail-polish-0.0.1.0 (DanielCampoverde)
14:46:47 <dmj`> template haskell really sucks
14:50:01 <josiah_sama> Why do the Monoid instances of Max and Min require the type parameter to be in the Bounded class?
14:51:01 <EvanR> so there is a minimum and maximum respectively
14:51:30 <EvanR> mempty is the least or greatest element
14:51:55 <josiah_sama> oh ,right, because Monoid requires <> and mempty...
14:52:49 <josiah_sama> is there a bounded floating type in Haskell?
14:53:24 <EvanR> you can add a Bounded instance if you want but the semantics of it would be a bit weird
14:53:33 <EvanR> like everything else about floats
14:54:10 <EvanR> its supposed to "smoothly" transition to less and less precision as you get into the 10^100, 10^200, etc range
14:54:26 <dmwit> josiah_sama: http://hackage.haskell.org/package/monoid-extras-0.5/docs/Data-Monoid-Inf.html ?
14:54:33 <EvanR> 10^308 or whatever isn't really a notional upper bound, though Infinity would be
14:54:55 <EvanR> oh duh
14:55:19 <josiah_sama> well, that's kinda where I was at, there
14:55:55 <josiah_sama> infinity and -infinity should be intrinsically understood as the upper and lower bonds for all infinite numeric types I would have though
14:56:06 <josiah_sama>  * infinity and -infinity should be intrinsically understood as the upper and lower bonds for all infinite numeric types I would have thought
14:57:00 <josiah_sama> Maybe with the exception of something like Nat which would go from 0 to infinity
14:57:13 <EvanR> in the compactified sense maybe
14:57:26 <EvanR> otherwise infinity kind of conflicts with the notion of bounded
14:58:10 <josiah_sama> But it's still useful inasmuch as it provides a way to have a Min and Max Monoid instance for Double and Float
14:59:36 <EvanR> sort of, though NaN probably mucks it up
15:00:00 <EvanR> what about a Min and Max semigroup?
15:02:20 <josiah_sama> Well, the problem is I'm wanting the fold over the values in a Vinyl.Rec, but the fold function requires the data returned by the fold function to be a recognized Monoid
15:02:45 <josiah_sama> in other words, the library's implementation of fold uses `mappend` to perform the fold operation
15:03:35 <josiah_sama> and I'm stuck with it because that's the only good way I can get out of the Rec instance since the data in the record is a heterogeneous collection and I'm stuck on an earlier version that doesn't define `mapFields` yet
15:08:47 <dmwit> (It's probably not *just* that it uses mappend. I would bet it uses mempty, too.)
15:09:20 <EvanR> yeah in case it folds over nothing
15:09:42 <EvanR> in which case a sneaky -Inf appears
15:13:34 * josiah_sama sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/DTQgHcXLnwbjFHdIEefPSvxN >
15:15:32 <josiah_sama> Really, though, `Int` is `Bounded`, so does it really actually make sense to assume  `9223372036854775807` in that case?
15:15:57 <josiah_sama> because that's what the fold operation will likely return since that would be the Identity element for Min
15:16:23 <josiah_sama> might as well either throw an Error or return Infinity in that case
15:16:29 <alx741> hello everyone, I'm trying to upload a nix-style cabal package to hackage but it seems that hackage is trying to use v1 commands as the build fails and it mentions: "Warning: The install command is a part of the legacy v1 style of cabal usage"
15:16:39 <alx741> how can I tell it that I should use v2-* ?
15:16:40 <dmwit> It does not make sense to assume maxBound = 9223372036854775807. Instead, use maxBound.
15:17:03 <josiah_sama> @dmwit
15:17:04 <lambdabot> Unknown command, try @list
15:18:03 <dmwit> alx741: Maybe check out #hackage or #haskell-infrastructure; you'll be more likely to catch the attention of somebody who can do something about that.
15:18:08 <dmwit> And it does seem worth doing something about.
15:18:22 <josiah_sama> That's exactly my argument dmwit
15:18:34 <dmwit> I don't know what you're arguing for or against.
15:18:41 <josiah_sama> 9223372036854775807 doesn't make sense to assume, but it's assumed
15:18:53 <alx741> dmwit: will try there, thanks
15:19:05 <josiah_sama> did you read the rest of the conversation?
15:19:31 <dmwit> Bits of it. I don't know what you mean by "assumed".
15:20:03 <dmwit> You, the consumer of Haskell, may not assume any particular value is maxBound for Int. The writer of the compiler, who defines what Int is, of course knows the correct answer.
15:20:23 <josiah_sama> dmwit:  We're discussing the Vinyl fold operation on Rec
15:20:23 <dmwit> For your compiler, the answer is 9223372036854775807. It is not an assumption; it is an observation about the representation chosen for Int.
15:20:56 <josiah_sama> it assumes a Monoid, `Min Int` has a Monoid instance which assumes its maxBound is 9223372036854775807
15:21:50 <dmwit> Again, I don't know what you mean by "assume".
15:21:58 <dmwit> That maxBound definition was written by the compiler writers.
15:22:02 <dmwit> For them it is not an assumption.
15:22:24 <josiah_sama> I would argue, though, that this creates surprising behavior in the Rec fold function.  Now I'll never know if I got 9223372036854775807 because my Rec was empty, or I got it because 9223372036854775807 was really the smallest value returned by the fold operation when the operation returns Ints
15:22:27 <dmwit> If you go get a 32-bit compiler, you will find that maxBound has a different value.
15:22:43 <dmwit> And if you get a compiler designed to be maximally maliciously compliant, it will have still a different value.
15:23:10 <dmwit> But the Bounded a => Monoid (Min a) instance will adapt correctly to all those situations. It is not assuming anything.
15:23:16 <josiah_sama> well then, why not define the max value for Double and Float as Infinity?
15:23:33 <dmwit> I suspect the answer there is because of NaN.
15:23:49 <josiah_sama> what about NaN?
15:24:02 <dmwit> Anyway this whole discussion should have been over half an hour ago with my suggested alternative, as far as I'm concerned.
15:24:09 <josiah_sama> that can be neither max nor min for Double or Float
15:24:39 <dmwit> Yes. But my point is that Infinity is also not a good max, because it doesn't have Infinity > NaN.
15:24:45 <josiah_sama> is your suggested alternative going to enable me to fold over a Rec where the operation returns a Double/Float?
15:24:55 <dmwit> Yes.
15:26:13 <josiah_sama> dmwit: I can't find your suggestion, what was it?
15:26:22 <dmwit> http://hackage.haskell.org/package/monoid-extras-0.5/docs/Data-Monoid-Inf.html
15:27:15 <josiah_sama> dmwit: Ah, I totally missed why you posted that
15:27:17 <josiah_sama> thanks
15:34:48 <EvanR> or just add a Bounded instance to Double
15:35:13 <EvanR> i guess, orphan
15:45:00 <freeman42x> can someone tell me what HIdent does in simple terms?
15:53:55 <freeman42x> ah, HIdent is just another code formatter like brittany
15:55:26 <freeman42x> are there any alternatives to HLint?
15:57:13 <pikajude> hindent
15:57:18 <pikajude> and no, not that i know of
16:13:17 <freeman42x> is there a list of static code quality analyzers for Haskell anywhere? 
16:16:05 <sm[m]> yes, right here: 1. hlint  :)
16:16:28 <dmwit> oof
16:16:30 <freeman42x> roflmao, such a comprehensive list, better blog about it :p
16:16:41 <dmwit> I mean, it *is* comprehensive.
16:16:58 <sm[m]> the Dash doc browser is pretty great, does anyone know if it's built with haskell ?
16:17:49 <sm[m]> I think it is, because of "hdocset" using all my memory
16:18:50 <sm[m]> also, anyone here using it for browsing haskell docs, I would be interested in your setup
16:19:42 <iqubic> :t (\x -> x < 5)
16:19:43 <lambdabot> (Ord a, Num a) => a -> Bool
16:20:02 <iqubic> @pl (\x -> x < 5)
16:20:02 <lambdabot> (< 5)
16:25:37 <iqubic> So, I have a sized vector. I want to replace element n with a given value. Is there a way to do that?
16:31:08 <iqubic> Oh, actually, I can use update for that.
16:53:19 <iqubic> What's a good way to make sure that all members of a list are unique?
16:54:52 <shachaf> @google What's a good way to make sure that all members of a list are unique? haskell
16:54:54 <lambdabot> https://stackoverflow.com/questions/3098391/unique-elements-in-a-haskell-list
16:55:08 <iqubic> :t undefined
16:55:09 <lambdabot> a
16:58:17 <koz_> iqubic: There's a function for that in Data.Vector.Sized. Read it in detail, it'll help.
17:00:52 <freeman42x> I created a list of Haskell static code analysis software: https://t.co/9nJTcEW0hR
17:04:23 <sm[m]> nice. SourceGraph is another
17:09:03 <freeman42x> sm[m], got a link to SourceGraph? I found it at some point and then I run into something that was actually a site and not what I was looking for
17:09:35 <iqubic> I just learned that statements in a where block are only evaluated when needed.
17:10:33 <dmwit> freeman42x: Neil Mitchell has a couple of tools, too, though they may be bit-rotted by now.
17:10:39 <sm[m]> http://hackage.haskell.org/package/SourceGraph
17:11:02 <freeman42x> sm[m], cheers
17:11:17 <sm[m]> my list was a bit off
17:12:18 <dmwit> freeman42x: Oh, ignore me, you've already got them. I just didn't pay close enough attention.
17:13:24 <freeman42x> ah yeah, dmwit I did end up going through Neil Mitchell's list
17:40:01 <iqubic> Debugging is the hardest part about writting code.
17:52:22 <iqubic> So, I just spent like 20 minutes trying to get this to work. Turns out I mixed up greater than and less than.
17:53:37 <koz_> iqubic: Those kind of errors are the best.
18:02:54 <iqubic> koz_: I was comparing the size of the disk at the top of the 'from' tower to the size of the disk at the top of the 'to' tower the wrong way.
18:03:09 <iqubic> for my towers of hanoi.
18:03:34 <iqubic> I finally finished my implementation of the move function.
18:04:39 <iqubic> And I can really easily expand the game to allow for more than three positions for where a given disk can be.
18:06:58 <iqubic> move :: forall n m. Finite m -> Finite m -> GameState n m -> Maybe (GameState n m)
18:07:14 <iqubic> n is the number of disks, and m is the number of towers.
18:07:56 <iqubic> Changing from 'Finite 3' to 'Finite m' was the only change to my move function I needed to make.
18:57:00 * hackage shh 0.7.0.6 - Simple shell scripting from Haskell  https://hackage.haskell.org/package/shh-0.7.0.6 (lukec)
19:08:00 * hackage gloss-raster 1.13.1.1 - Parallel rendering of raster images.  https://hackage.haskell.org/package/gloss-raster-1.13.1.1 (BenLippmeier)
19:20:11 <jusss> what CPS is used for?
19:21:16 <shachaf> Being explicit about what happens next.
19:22:13 <jusss> people always say it can do control, how?
19:24:00 <mniip> jusss, because at every point you have access to the rest of the code that follows
19:24:07 <mniip> you can invoke said code in a funky way
19:24:12 <mniip> e.g. multiple times or not at all
19:25:47 <jusss> mniip: it's related to Cont Monad?
19:27:15 <mniip> er sorry, I was explaining the Cont monad yes
19:27:17 <c_wraith> Cont packages up CPS a type designed to simplify bookkeeping for common patterns
19:27:33 <mniip> CPS is just continuation passing in general
19:28:34 <EvanR> myCPSFunc k r x = if x then k 9 else r "foo"
19:32:53 <alhirzel> I am new to Stack. I used `stack new` and want to add a Hackagep package (say htoml) to my project. what is the proper config file to edit? I am a little unclear from Google whether it should be package.yaml or stack.yaml, and also nothing I have tried has worked (putting it in extra-deps, dependencies)
19:44:16 <alhirzel> I had another issue entirely; question resolved. Goodnight all!
20:17:36 <slack1256> Hi, I was reading the haskell version of regex-redux on the language benchmark shootout page https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/regexredux-ghc-3.html .
20:18:43 <slack1256> I was wonder what other haskeller thought of importing pcre2.h via FFI on that benchmark. I feel it is a kind of cheating but somehow I think if those binding were done on a separate library and then imported I wouldn't have mind.
20:18:53 <slack1256> s/wonder/wondering/
20:19:18 <Axman6> the benchmark only has some packages available to use IIRC
20:19:33 <Axman6> so you can't just use arbitrary Haskell packages
20:21:02 <slack1256> I see.
20:21:16 <slack1256> But I wonder if using a C library is fair.
20:22:14 <Axman6> you should see the sorts of crap other languages do to compete - they removed the requirement to use the language's native threading stuff after the Haskell stuff was so much faster. All the C implementations just use coroutine libraries now IIRC
20:22:14 <slack1256> I really can't put my finger on it, but to me the objective was to compare the same algorithm implemented on different languages, this kinds of sidesteps the objective.
20:25:07 <Axman6> it seems they're much more willing to change the rules to make Haskell look bad than to make it look good. The reason the binary trees benchmark requires the tree be manifest in memory is because GHC wascompletely deforresting the production and consumption of the trees and smashing everything else
20:25:08 <koz_> slack1256: Goodhart's Law applies _hard_ here.
20:26:09 <slack1256> Axman6: Jesus. Making a fair benchmark seems difficult.
20:26:24 <Axman6> yes
20:26:54 <Axman6> Haskell used to do very well on a lot of the benchmarks but not so much any more because the rules kept changing to make it more "fair"
20:26:58 <Axman6> (You'
20:27:21 <Axman6> (You'll probably see my name of a few of the benchmarks)
20:27:43 <slack1256> Oh you're Jaro?
20:27:45 <slack1256> nice
20:28:01 <Axman6> no
20:28:19 <Axman6> (II guess a lot of my stuff has been replaced over the years
20:29:39 <iqubic> uncons is a great function.
20:29:57 <iqubic> :t uncons
20:29:58 <lambdabot> [a] -> Maybe (a, [a])
20:30:04 <iqubic> I just used that earlier today.
20:30:27 <slack1256> Are there implementation difficulties documented somewhere? I guess haskell isn't alone in their plight
20:37:07 <iqubic> Is there a way to convert from a type level Nat to an integer?
20:41:36 <koz_> iqubic: natVal a Proxy.
20:41:44 <koz_> Then fromIntegral.
20:42:05 <iqubic> I didn't know that. Thanks.
20:47:19 <mniip> there's also a way to go the other way
20:47:31 <mniip> % :t someNatVal
20:47:31 <yahb> mniip: Integer -> Maybe SomeNat
21:03:50 <iqubic> test :: forall n. KnownNat n. Integer
21:03:55 <iqubic> test = fromIntegral (natVal (Proxy @n))
21:13:05 <maerwald> slack1256: there isn't, that's the problem. The knowledge is scattered, not consolidated
21:13:49 <maerwald> and often times it is very very implementation specific (specific to the libraries you use) and very GHC specific (which makes it even harder)
22:07:30 * hackage hw-uri 0.1.1.2 - Supports IO on URIs  https://hackage.haskell.org/package/hw-uri-0.1.1.2 (haskellworks)
22:43:58 <masaeedu[m]> edwardk: I was reading this comment of yours from a while ago on reddit: https://www.reddit.com/r/haskell/comments/3v6zs6/folds_are_are_closed_corepresentable_profunctors/cxkvwtu/ and am a bit confused about some things. Is it that a corepresentable functor is isomorphic to the covariant hom functor and corepresentable isomorphic to the contravariant hom? Or is it the other way around?
22:45:23 <masaeedu[m]> The wikipedia article on representable functors and your representable functors library suggest that representable functors are the ones that are isomorphic to the covariant hom functor, but the comment suggests the reverse. It's possible I'm misreading one or the other though.
22:46:42 <masaeedu[m]>  * @freenode_edwardk:matrix.org: I was reading this comment of yours from a while ago on reddit: https://www.reddit.com/r/haskell/comments/3v6zs6/folds_are_are_closed_corepresentable_profunctors/cxkvwtu/ and am a bit confused about some things. Is it that a corepresentable functor is isomorphic to the covariant hom functor and representable isomorphic to the contravariant hom? Or is it the other way around?
22:55:33 <mniip> masaeedu[m], representable is isomorphic to Hom(X, -) for some X
22:56:22 <mniip> wait huh
22:56:33 <mniip> nope, Hom(-, X)
22:57:30 <mniip> I guess it's obvious whether we mean representation or corepresentation if we know the F
22:57:53 <mniip> it's just that in math contravariant functors are commonplace in form of presheaves
23:02:07 <masaeedu[m]> mniip: hmm. well the first thing you said coincides with what the Wikipedia article and the `Representable` class say I think
23:03:34 <Silk86> Does anyone know where I can find a reasonably precise definition of composition, composability, and/or related terms? I'm talking about the terms as they're used colloquially in FP (as opposed to in OOP or category theory, and broader than just function composition).
23:04:06 <masaeedu[m]> i.e. `F :: C -> Set` is representable if there is a natural isomorphism to `X -> _` for some `X`. do you know where i can read more about it being isomorphic to `Hom (-, X)`?
23:04:58 <mniip> well unless C is discrete I don't think F can be isomorphic to both Hom(X, -) and Hom(-, Y)
23:05:02 <mniip> so it's usually clear from context
23:05:20 <mniip> of all sources I would trust nlab the most: https://ncatlab.org/nlab/show/representable+functor
23:05:35 <mniip> "representable presheaf"
23:06:52 <mniip> Silk86, what makes you think colloquial composability is not categorical composability
23:07:13 <masaeedu[m]> hmmmm. so is it correct to say there's actually no difference between the "corepresentable" and "representable" concepts? because we can always take the dual of a category and then talk about functors from that to Set
23:07:47 <dminuoso> masaeedu[m]: Right. That's the basic idea of anything co-, really. :)
23:08:38 <Silk86> I suspect at a base level they probably are the same thing, but when people refer to something as being composable they're probably not going and doing the maths to show that their thing is a category.
23:09:01 <Silk86> Also I'm looking for something I can give to people who aren't familiar with, and aren't interested in category theory.
23:09:46 <shachaf> "core presentable" things are things that can be finitely presented in System Fω with type coercions.
23:10:03 <dminuoso> Haha
23:13:20 <dminuoso> mniip: Are you sure you didn't mix those two up? "representable is isomorphic to Hom(-, X)" (I spliced your correction in there). Maybe Im just still very tired.. *shrugs*
23:14:01 <mniip> Silk86, it's probably not a category
23:14:04 <mniip> a mere semigroupoid
23:16:45 <masaeedu[m]> so given a fixed category `C` it seems like there would be two distinct families of functors:
23:16:46 <masaeedu[m]> 1 - functors `F :: C -> Set` from which we can expect a natural isomorphism to `Hom(X, -)` for some `X`
23:16:47 <masaeedu[m]> 2 - functors `F :: C^op -> Set` from which we expect a natural isomorphism to `Hom(-, X)` for some `X`
23:17:35 <masaeedu[m]> generally, when people talk about "representable functors" from some category `C`, they're talking about the latter group?
23:17:57 <masaeedu[m]> this gets extra confusing because what i'm actually trying to understand is "[co]representable profunctors"
23:18:28 <masaeedu[m]> so i'm just trying to get my head on straight wrt what's up and down
23:18:35 <dminuoso> masaeedu[m]: 1) describes representable functors, 2) describes copresentable ones.
23:19:43 <dminuoso> Oh wait. Heh it really depends.
23:19:57 <dminuoso> I guess we really do call them both representable functors in Haskell..
23:20:30 * hackage mssql-simple 0.6.0.0 - SQL Server client library implemented in Haskell  https://hackage.haskell.org/package/mssql-simple-0.6.0.0 (tkmsm)
23:21:13 <dminuoso> class Distributive f => Representable f where type Rep f :: *; tabulate :: (Rep f -> a) -> f a; index :: f a -> Rep f -> a;
23:21:29 <dminuoso> class Contravariant f => Representable f where type Rep f :: *; tabulate :: (a -> Rep f) -> f a; index :: f a -> a -> Rep f;
23:21:41 <masaeedu[m]> what the heck
23:21:46 <masaeedu[m]> are those two different classes?
23:22:14 <dminuoso> masaeedu[m]: Yes. The former is from Data.Functor.Contravariant.Rep (in edwards adjunctions package) and the latter is from Data.Functor.Rep
23:23:42 <dminuoso> Or.. I mixed them up. Sorry. The first is from Data.Functor.Rep
23:23:53 <dminuoso> A bit hard to not get confused with the ordering. :)
23:25:32 <dminuoso> masaeedu[m]: Note how the two methods form the isomorphism you mentioned.
23:25:43 <jusss> do most languages support continuation?
23:25:53 <jusss> full continuation and delimited continuation
23:26:39 <masaeedu[m]> yeah, i get the natural isomorphism bit. still not 100% sure which thing to call representable vs corepresentable, but i guess it's sort of fluid
23:27:21 <dminuoso> Ah I guess I got really mixed up and mniip said it right.
23:27:24 <masaeedu[m]> i was originally looking at the first one, that's why i was confused with the other convention in the comment
23:28:16 <jusss> do the CPS get similar with the bind chain about Monad?
23:28:16 <dminuoso> masaeedu[m]: A functor F : C^op -> Set that is isomorphic to hom_C(-, X) for some X is representable.
23:28:25 <dminuoso> (that is, naturally isomorphic)
23:29:10 <dminuoso> jusss: The Cont monad is one particular style of CPS. But any language that has first-class functions can implement continuations.
23:30:11 <jusss> dminuoso: and why they don't implemnet it?
23:30:20 <dminuoso> jusss: What do you mean by "why dont they implement it"?
23:30:40 <dminuoso> jusss: In any language that has first class functions you are very likely to find libraries that offer a continuation based approach.
23:30:42 <jusss> dminuoso: if they can, why they don't to implement continuation?
23:30:53 <ggole> Manually passing continuations is pretty common.
23:31:10 <ski> btw, first-class continuation( side-effect)s is something else
23:31:35 <ski> (as in Schemw, SML/NJ, and in some other languages / implementations)
23:31:55 <ski> (er, s/Schemw/Scheme/)
23:32:12 <jusss> ski: do JS and Python have call/cc ?
23:32:26 <dminuoso> jusss: dont conflate call/cc with continuations.
23:32:34 <dminuoso> jusss: CPS is a general concept.
23:32:38 <ggole> Full first-class continuations in the guise of call/cc are probably a mistake though
23:32:40 <jusss> dminuoso: ok
23:32:47 <jusss> dminuoso: just like closure/
23:32:49 <jusss> ?
23:33:00 * hackage servant-elm 0.6.1 - Automatically derive Elm functions to query servant webservices.  https://hackage.haskell.org/package/servant-elm-0.6.1 (k_bx)
23:33:09 <dminuoso> jusss: The general concept is about passing a "continuation", a sort of "here's how you can resume"
23:33:26 <dminuoso> jusss: If we squint a bit, functions like `withConnection :: (Connection -> IO a) -> IO a` accept a continuation.
23:33:53 <dminuoso> (It does slightly more than that though)
23:33:55 <masaeedu[m]> it's pretty easy to implement the continuation monad in JS
23:34:10 <jusss> masaeedu[m]: and delimited continuation?
23:34:45 <jusss> masaeedu[m]: do you have a link to implement the continuation monad in JS/
23:35:22 <jusss> I found that JS is more like a common language in program as English in nature languages
23:35:31 * masaeedu[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/HOeXBPhzfAZJxjmBTRONCVph >
23:36:13 <masaeedu[m]> that's it. if you curry most node js and browser apis and whatnot a tiny bit they all turn into continuations that you can sequence using those operations
23:36:22 <masaeedu[m]> and traverse/monad transform etc.
23:36:41 <dminuoso> jusss: In general CPS is about returning some kind of object/value/thing that requires the consumer to specify how to resume, rather than the result itself.
23:38:21 <dminuoso> % :t ($ "foobar)
23:38:21 <yahb> dminuoso: ; <interactive>:1:12: error: lexical error in string/character literal at end of input
23:38:34 <dminuoso> % :t ($ "foobar")
23:38:34 <yahb> dminuoso: ([Char] -> b) -> b
23:38:54 <dminuoso> This could be thought of as a continuation.
23:39:16 <dminuoso> It's some value, but you don't see it as String/[Char], instead you are being asked to specify some function how to resume this computation.
23:39:31 <dminuoso> It's a programming style, sort of.
23:39:50 <jusss> dminuoso: and it's useful?
23:40:01 <jusss> for a great purpose?
23:40:34 * masaeedu[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/zOWOEUeNstPfxhaAnreSXmMF >
23:40:38 <ski> jusss : `call/cc' (in the form it's present in Scheme, and SML/NJ), is a means to express continuation side-effects
23:41:30 <dminuoso> jusss: They allow you to alter control flow in your program differently.
23:41:32 <ski> (`callCC' in `Control.Monad.Cont' is not)
23:42:18 <jusss> dminuoso: instead of if-else?
23:42:48 <dminuoso> jusss: It's much more wide ranging than that.
23:42:54 <dminuoso> jusss: The entire program structure becomes different.
23:43:12 <ski> (however, several people think that composable / delimited / sub- / partial continuations, say using `shift' & `reset' (there are some alternatives), are better, than using ordinary (undelimited) continuations (as with `call-with-current-continuation'))
23:43:56 <jusss> dminuoso: it sounds wonderful! do people use it usually?
23:44:20 <dminuoso> jusss: Yes, sometimes.
23:45:22 <mniip> heh, we were just talking about ContT in another place
23:45:33 <jusss> ski: 'cause delimited continuation can do just part of it?
23:46:03 <dminuoso> jusss: There's essentially two main reasons: CPS gives you much higher control about how to do control flow/exception handling, and with CPS you can do things like suspend computations.
23:46:22 * ski . o O ( "Web Programming" by Eli Barzilay at <http://tmp.barzilay.org/cont.txt> )
23:46:25 <ski> jusss ^
23:46:29 <mniip> here's a library that uses CPS to safely handle allocation of foreign types http://hackage.haskell.org/package/marshal-contt-0.2.0.0/docs/Foreign-Marshal-ContT.html
23:46:35 <dminuoso> But we dont need CPS to implement either, they might just be a useful technique for some problem domains. :)
23:46:50 <masaeedu[m]> isn't it also more efficient to CPS "decision making" instead of matching on things?
23:47:11 <jusss> dminuoso: I have a question, people say that CPS can do async, but if the operation itself is blocked, what it can help?
23:47:41 <mniip> I mean when I see
23:47:42 <jusss> dminuoso: I heard that compilers use CPS
23:47:48 <mniip> % :t Foreign.Marshal.alloca
23:47:49 <yahb> mniip: Storable a => (Ptr a -> IO b) -> IO b
23:47:57 <mniip> it's just screaming to be wrapped in a ContT
23:47:59 <mniip> :P
23:48:06 <dminuoso> o.o
23:48:18 <masaeedu[m]> are there any effectful arrow types in haskell?
23:48:25 <mniip> masaeedu[m], Kleisli
23:48:30 * ski . o O ( <https://en.wikipedia.org/wiki/Inversion_of_control> )
23:48:39 <dminuoso> And (->) with unsafePerformIO sprinkled over it!
23:48:40 <masaeedu[m]> like, instead of `a -> IO b`, something like `IOArrow a b`
23:48:45 <mniip> Kleisli IO
23:48:47 <dminuoso> masaeedu[m]: Kleisli
23:48:53 <masaeedu[m]> more similarly to other languages
23:49:01 <masaeedu[m]> right, i'm familiar with Kleisli, that's not what i'm talking about
23:49:17 <mniip> Kleisli IO a b ~ (a -> IO b)
23:49:21 <mniip> what else are you talking about
23:49:23 <ski> % :t ContT Foreign.Marshal.alloca
23:49:23 <yahb> ski: Storable a => ContT r IO (Ptr a)
23:49:36 <Ariakenom> jusss: some do. ghc does not
23:49:39 <ski> @type cont . flip all
23:49:41 <lambdabot> Foldable t => t a -> Cont Bool a
23:49:41 <ski> @type cont . flip any
23:49:43 <lambdabot> Foldable t => t a -> Cont Bool a
23:50:23 <mniip> ski, someone was doing some yucky marshalling of lists of strings
23:50:27 <mniip> and I came up with this gem
23:50:31 <masaeedu[m]> in impure languages you can have pure functions, but you can also have impure subroutines that peform other effects directly (e.g. mutating things, or doing IO, or accessing mutable references, etc.)
23:50:49 <mniip> % :t \argv -> runContT $ traverse (ContT . BS.useAsCString) argv >>= ContT . Foreign.Marshal.Array.withArray0 Foreign.Ptr.nullPtr
23:50:49 <yahb> mniip: [BS.ByteString] -> (Ptr (Ptr Foreign.C.Types.CChar) -> IO r) -> IO r
23:50:56 <masaeedu[m]> you can just compose those so called "functions" (which aren't really functions). they form a category directly
23:51:04 * ski . o O ( "Compiling without Continuations" by Luke Maurer,Paul Downen,Simon Peyton Jones in 2017 at <https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/join-points-pldi17.pdf> )
23:51:05 <mniip> and thus the marshal-contt library was born
23:51:08 <Ariakenom> MasseR: so ... IO?
23:51:32 <ski> s/MasseR/masaeedu[m]/
23:51:33 <Ariakenom> argh, wrong nickname
23:52:05 <masaeedu[m]> in haskell as far as i'm aware there's no such "effectful arrow" type, instead all computations need to happen in pure functions, including computation of a deferred representation of your effects
23:52:11 <mniip> masaeedu[m], Kleisli forms a category directly as well
23:52:37 <ski> mniip : nice :)
23:52:55 <masaeedu[m]> yes, but the effects aren't represented in the arrow; they're represented in what the arrow produces
23:53:15 <mniip> what
23:53:31 <Ariakenom> what
23:54:01 <masaeedu[m]> that
23:54:26 <mniip> you're not making a whole lot of sense there
23:55:11 <ski> masaeedu[m] : that's just a special case
23:56:53 <masaeedu[m]> in haskell, effects are represented using an IO value that the program computes. there is no such thing as an effectful subroutine, only pure functions that may compute (among other things) IO values
23:58:04 <mniip> that's not correct
23:58:19 <mniip> what do you think `getLine >>= reverse` does
23:58:37 <mniip> it does computation on a value that is obtained by executing an action
23:58:54 <masaeedu[m]> sorry, what's the type of `reverse` here?
23:58:57 <mniip> oops, not >>=
23:59:00 <Ariakenom> :t reverse
23:59:02 <lambdabot> [a] -> [a]
23:59:07 <mniip> `getLine >>= print . reverse`
23:59:08 <mniip> or whatever
23:59:13 <masaeedu[m]> ok
23:59:43 <masaeedu[m]> that computes an IO String representing first getting some input from stdin, then printing it
23:59:49 <masaeedu[m]> (after reversing it)
23:59:57 <mniip> reversing is computation
