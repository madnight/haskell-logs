00:19:30 * hackage hw-uri 0.1.1.9 - Supports IO on URIs  https://hackage.haskell.org/package/hw-uri-0.1.1.9 (haskellworks)
00:40:44 <Zer0xp> fmap (10/) (4,5) = (4,2.0) --Can some explain to me why it doesn't divide 4 like it does 5 ?
00:41:17 <dminuoso> % :t fmap (10/) (4,5) 
00:41:17 <yahb> dminuoso: (Fractional b, Num a) => (a, b)
00:41:53 <Nolrai> fmap f (a,b) = (f a, b)
00:41:58 <dminuoso> Zer0xp: the fmap instance doesnt do what you think it does
00:42:08 <Nolrai> Or is it (a, f b)?
00:42:22 <dminuoso> Nolrai: ^- that.
00:42:23 <Zer0xp> Oh, I thought it applied the division on both elements in the tuple
00:42:27 <lavalike> > join bimap (/10) (4,5)
00:42:29 <lambdabot>  (0.4,0.5)
00:42:34 <dminuoso> Zer0xp: No. 
00:42:44 <dminuoso> Zer0xp: A tuple can vary in its types for each element, so it wouldn't work.
00:42:57 <dminuoso> Zer0xp: `fmap (/10) ('c', 10)`
00:43:05 <dminuoso> Zer0xp: What would that do, if fmap behaved like you suggested?
00:43:56 <dminuoso> Zer0xp: Another important part, is to understand that Functor works on types of kind * -> *
00:50:24 <Zer0xp> If fmap applies an operation on entire list, then why not on both elements of a tuple ? It would make sense to only apply it on operands that allowed only operators that were compatible.
00:51:00 <Nolrai> So I am writing an Arbitrary (from QuickCheck) instance for an expression type, and wanted names to have more variaty when generating larger expresions, but I realized that as I generate larger expresions from smaller ones, the arbitrary method at my Name type is going to always be called with a "size" of 1. Is there an easy way to work around
00:51:00 <Nolrai> this?
00:51:26 <lavalike> Zer0xp: the two types have a fundamental difference, [a] has 1 type parameter, (a,b) has 2; as dminuoso suggested fmap works on things that give a type, return a type (a,_) i.e. the type of tuples where the first element's type is fixed is such a type, so it doesn't look at that.
00:51:27 <Zer0xp> dminuoso: I get that a tuple can vary in types but why did it perform the operation on the second element and not the first even though both were of the same types ?
00:51:50 <Nolrai> Because it always performs it on the second.
00:53:33 <Nolrai> For example fmap also applies f only to the Right constructor of Either. Because Either isn't a Functor. 'Either a' is a Functor for all a.
00:53:56 <dminuoso> ^- this is actually a family of instances.
00:54:13 <lavalike> (a,b) is basically ((,) a) b and ((,) a) fits the kind of a Functor "* -> *" whereas (,) :: * -> * -> * does not; you could argue there could be a way to flip the type constructor, but there isn't
00:54:21 <dminuoso> So for example you have an `instance Functor (Either Int)`, you have an `instance Functor (Either Bool)`, etc..
01:02:18 <tdammers> it helps to think of (a, b) as Pair a b
01:03:00 <Nolrai> I mean 'newtype Flip f a b = Flip (f b a)' is a valid newtype, but I've never seen it used.
01:03:26 <dminuoso> Nolrai: https://hackage.haskell.org/package/bifunctors-5.5.5/docs/Data-Bifunctor-Flip.html#t:Flip
01:04:01 <dminuoso> Nolrai: Such tricks are somewhat common in more advanced type shenanigans.
01:06:46 <Nolrai> Must have missed it somehow. I mean Flip (->) seems like it would be useful for example.
01:08:13 <Nolrai> tdammers: (a warning: people sometimes define a type constructor 'Pair a' as isomorphic to '(a, a)' )
01:08:41 <tdammers> Nolrai: sure, yes. IME, Pair a b is more common though.
01:09:12 <dminuoso> I think tdammers point was to hint at (,) being just a syntactical weirdness. At the end it's a type constructor just like Pair with a mixfix notation.
01:09:28 <tdammers> indeed
01:09:59 <tdammers> and when you write it as Pair a b, it becomes isomorphic to Either a b and similar types
01:10:08 <dminuoso> Err what?
01:10:16 <dminuoso> tdammers: You need some coffee I think.
01:10:18 <cocreature> How does Text.putStrLn actually end up writing to stdout? I don’t see "write" syscalls in the strace output so presumably it uses something else but I’m not seeing anything in strace
01:10:49 <dminuoso> tdammers: I think you meant to write "visually comparable" rather than "isomorphic"
01:11:28 <cocreature> oh nvm, I just forgot -f
01:11:46 <tdammers> it's more than just visual similarity
01:12:14 <tdammers> if you disregard the term level and associated semantics, they work exactly the same from a typeclass mechanics point of view
01:12:40 <tdammers> data Bar a b = ...; instance Foo (Bar a) where ...
01:12:55 <tdammers> the instance attaches to the last type arg
01:13:28 <Nolrai> Isomorphic at the kind level you mean?
01:13:38 <tdammers> something like that
01:13:48 <tdammers> or maybe at the syntax level
01:14:10 <tdammers> oh well, maybe "isomorphic" wasn't such a great word choice here
01:14:29 <Nolrai> Probably not, but eh.
02:00:25 <Nolrai> I don't understand what's happening here: https://gist.github.com/Nolrai/1fce081ec785b240cf4a32d4a7cd4059 I would think that this would be exactly what TypeFamilies' associated types are for.
02:01:40 <merijn> Nolrai: TypeFamilies aren't unique
02:01:55 <merijn> Nolrai: So two different Piece implementation can both map "Piece v" to (for example) Int
02:02:26 <merijn> Nolrai: So suppose you now call "exprCons :: [Piece v] -> v" on [Int]
02:02:37 <merijn> Nolrai: Which 'v' corresponds to that? There's no way to know
02:03:38 <int-e> Heh it even says "NB: ‘Piece’ is a non-injective type family"
02:04:14 <Nolrai> Yeah, just the 'Piece v0' was confusing me.
02:04:55 <Nolrai> So is there a way to do what I want with TypeFamilies or should I use Functional Dependencies instead?
02:07:31 <lortabac> Nolrai: in general this kind of problems is solved by adding a Proxy argument or enabling AllowAmbiguousTypes
02:08:33 <lortabac> Nolrai: probably adding a 'Proxy v' argument to foldNames' should be enough
02:11:30 * hackage ghc-heap-view 0.5.11 - Extract the heap representation of Haskell values and thunks  https://hackage.haskell.org/package/ghc-heap-view-0.5.11 (JoachimBreitner)
02:15:14 <Zer0xp> Okay so from my understanding of what you guys said, functor takes an argument of type * and returns a value of type *, ie. "* -> *" whereas in case of a tuple it would be "* -> * -> *" ? Am I making sense ?
02:16:31 <Nevoic> Random question, what does "catMaybe" stand for? I know what it does because of the type, but I cannot figure out what `cat` stands for.
02:16:33 <merijn> Zer0xp: Functor's return *a type* of kind *
02:16:44 <merijn> Nevoic: cat is a traditional abbreviation for concat
02:16:47 <[exa]> Nevoic: conCATenate
02:16:59 <merijn> Nevoic: See also the 'cat' commandline program
02:17:02 <Nevoic> That was my guess actually, but like what's being concatenated?
02:17:02 <boxscape> merijn concat is also an abbreviation :P
02:17:16 <Nevoic> yeah we're abbreviated abbreviations now. I think we've gone too farl ol
02:17:39 <Nevoic> `concatMaybes` isn't that much worse lol
02:17:51 <Nevoic> What's being concatenated here though? It's just [Maybe a] -> [a]
02:18:05 <Nevoic> like wouldn't `filterOutNothing` make more sense? or `filterJust`?
02:18:06 <boxscape> > concat . map (\Just x -> [x]) $ [Just 4, Just 5, Just 6]
02:18:08 <lambdabot>  error:
02:18:08 <lambdabot>      • The constructor ‘Just’ should have 1 argument, but has been given none
02:18:08 <lambdabot>      • In the pattern: Just
02:18:15 <boxscape> > concat . map (\(Just x) -> [x]) $ [Just 4, Just 5, Just 6]
02:18:17 <lambdabot>  [4,5,6]
02:18:34 <boxscape> the intuition is something like this, although of course the actual function handles Nothing as well
02:18:35 <Nevoic> is that what's being done? 
02:18:45 <boxscape> @src catMaybes
02:18:45 <lambdabot> catMaybes ls = [x | Just x <- ls]
02:18:55 <Nevoic> > concat . map (\(Just x) -> [x]) $ [Just 4, Just 5, Nothing, Just 6]
02:18:57 <lambdabot>  [4,5*Exception: <interactive>:3:15-30: Non-exhaustive patterns in lambda
02:19:21 <Nevoic> > [x | Just x <- [Just 4, Just 5, Nothing, Just 6]]
02:19:23 <lambdabot>  [4,5,6]
02:19:32 <merijn> :t concat
02:19:33 <lambdabot> Foldable t => t [a] -> [a]
02:19:41 <merijn> Concatenate a bunch of lists into one list
02:19:41 <boxscape> > concat . map (\mx -> case mx of (Just x) -> [x]; Nothing -> []) $ [Just 4, Just 5, Nothing, Just 6]
02:19:43 <lambdabot>  [4,5,6]
02:20:03 <merijn> If you consider "Maybe a" as "a list of 0 or 1 elements" it's just doing concat
02:20:07 <[exa]> Nevoic: if you look at maybes like lists with 0 or 1 element, it's the same
02:20:10 <Nevoic> It doesn't concatenate a bunch of lists though. It's not `[[Maybe a]] -> [a]`
02:20:22 <Nevoic> It's just filter out `Nothing` and having the type reflect that.
02:20:27 <Nevoic> filtering*
02:20:28 <dminuoso> Nevoic: It does.
02:20:42 <dminuoso> Nevoic: Think of `Maybe a` as a list of `a` that can, at most, be 1 element long.
02:20:46 <Zer0xp> merijn: Okay what does that mean ? *a type*
02:20:47 <dminuoso> then `[Maybe a]` is a list of lists.
02:21:01 <boxscape> > concat . map maybeToList $ [Just 4, Just 5, Nothing, Just 6]
02:21:03 <lambdabot>  [4,5,6]
02:21:06 <dminuoso> Zer0xp: In Haskell we can have functions not only operating on values, but on types too.
02:21:29 <merijn> Zer0xp: "Maybe" is a type with kind "* -> *", it is also functor
02:21:38 <merijn> Zer0xp: "Int" is a type with kind *
02:21:43 <dminuoso> Zer0xp: `Maybe` for example is a type-level function that, if you appied to some type, computes a new type back. 
02:21:49 <Nevoic> dminuoso wut. Maybe isn't a list, it's a type with an arity of 1. Isn't that like saying every Monad is a list because it wraps a type (or value at runtime)?
02:21:53 <merijn> Zer0xp: So "Maybe" applied to "Int" produces a new type "Maybe Int" with kind *
02:21:59 <boxscape> Nevoicfiltering or literally concatting is an implementation detail
02:22:09 <boxscape> that doesn't need to relevant for naming
02:22:28 <Nevoic> boxscape I mean that's a fair point, but wouldn't `catMaybes` be a bad name then?
02:22:37 <Nevoic> Because it references an abbreviation of an abbreviation of an implementation detail?
02:22:41 <dminuoso> Nevoic: No, `Maybe a` itself can be thought of as [a] but limited to a length of 1 at most.
02:22:47 <dminuoso> Nevoic: It's at least one possible way to think of it.
02:23:03 <boxscape> Nevoic the name doesn't refer to the implementation, it refers to the concept of thinking of Maybe as a List
02:23:10 <Zer0xp> Okay I think I should first try to understand more about kinds.
02:23:22 <dminuoso> Zer0xp: Kinds classify types, just like types classify values.
02:23:29 <merijn> Zer0xp: kinds are to types as types are to values
02:23:49 <Nevoic> kinds are sort of a dated concept though, right? Or at least they'll be obsoleted by a fully dependent system?
02:23:56 <Nevoic> i.e Idris doesn't have kinds iirc.
02:23:58 <merijn> Zer0xp: 'f :: Int -> Bool' means 'f' is a value (a function, even) that can be applied to a value of type 'Int'
02:24:09 <dminuoso> Nevoic: As I have learned yesterday, GHC in fact has lost the notion of Kind since version 8...
02:24:09 <merijn> Nevoic: Disagree
02:24:21 <boxscape> Nevoic types and kinds are unified in Haskell since 8.something
02:24:25 <dminuoso> Nevoic: But they are still a good vehicle to explain things, because the current state of things is more complicated.
02:24:47 <dminuoso> Nevoic: Plus some GHC diagnostics still use the term "kind"
02:24:54 <merijn> Nevoic: Any dependent system based on (extended) Calculus of Constructions has a hierarchy of universes (where level 0 corresponds to values, level 1 to types, level 2 to kinds, etc.)
02:24:56 <noumenon> what are to kinds what kinds are to types?
02:25:03 <merijn> noumenon: "sorts"
02:25:03 <dminuoso> noumenon: sorts
02:25:09 <noumenon> and further?
02:25:10 <dminuoso> noumenon: and that's the end of things, there's nothing above.
02:25:12 <Zer0xp> dminuoso: Thank you for that.
02:25:15 <noumenon> where do the turtles stop?
02:25:22 <boxscape> was it the case that BOX :: BOX in 7.x?
02:25:24 <dminuoso> noumenon: the reason is that there's only a single sort called "BOX"
02:25:26 <merijn> noumenon: If you go further into Calculus of Constructions it's an infinite hierarchy
02:25:40 <Nevoic> merijn that's interesting, so I suppose it's really just that the "hierarchy of universes" in a dependent system allow for things to jump between levels more easily?
02:25:40 <dminuoso> noumenon: Other languages like Idris give you an infinite tower of types.
02:25:42 <noumenon> fractal type theory
02:25:46 <Nevoic> I.E you can use a value as a type or a type as a value or a kind as a value etc.
02:25:51 <dminuoso> Nevoic: Ours is rather small since its "types : kinds : sorts"
02:25:52 <merijn> noumenon: But only the first 3 or 4 levels have common names, the rest get identified with a subscript index usually
02:26:04 <merijn> (i.e. types, kinds, and sorts)
02:26:24 <noumenon> it's sort of a kind of type of value
02:26:39 <dminuoso> Zer0xp: So consider this: You have some value called `f` - how can you tell whether its a function?
02:26:44 <merijn> Nevoic: Well you just say that Universe_n is a superset of Universe_(n-1)
02:26:54 <Nevoic> Is it right to say Java has an even small universe? i.e just values and types?
02:27:00 <Nevoic> smaller* damn I'm tired I think
02:27:06 <merijn> Nevoic: And anything that describes combinations of Universe_n things is in Universe_(n+1)
02:27:07 <dminuoso> Nevoic: Right.
02:27:31 <dminuoso> Nevoic: Or rather, Java stops being very principled after types.
02:27:32 <Zer0xp> dminuoso: Well I don't think I could be able to tell
02:27:43 <dminuoso> Zer0xp: so the way to do it, is to check its type!
02:27:44 <Nevoic> Is it necessary to be able to express an infinite amount of universes in a dependent language?
02:27:56 <Zer0xp> :t f
02:27:57 <lambdabot> FromExpr a => a
02:27:58 <Zer0xp> ?
02:28:06 <dminuoso> Zer0xp: Sure! Tell me.
02:28:06 <merijn> Nevoic: Well, you have two options: You do that or you do "TypeInType"
02:28:06 <Nevoic> or could we say get dependent haskell with just values : types : kinds : sorts?
02:28:07 <dminuoso> % :t 5
02:28:08 <yahb> dminuoso: Num p => p
02:28:12 <dminuoso> Zer0xp: ^- is this a function?
02:28:20 <merijn> Nevoic: The latter sacrifices soundness, though
02:28:26 <Nevoic> type in type?
02:28:30 <Nevoic> I'm unfamiliar with the concept.
02:28:31 <merijn> Nevoic: And I personally find it *much* more confusing
02:28:49 <merijn> Nevoic: You define "* :: *"
02:28:50 <Zer0xp> It's the exponent operator which is also a function, right ? 
02:29:06 <merijn> Zer0xp: He meant "5"
02:29:07 <lortabac> Nevoic: I think Cedille (a dependently-typed language) has just types and kinds
02:29:07 <dminuoso> Zer0xp: Oh that was supposed to be an arrow, pointing upwards to what yahb said.
02:29:08 <Zer0xp> :t ^
02:29:09 <lambdabot> error: parse error on input ‘^’
02:29:18 <lortabac> Nevoic: but I have no idea how it works
02:29:31 <dminuoso> Zer0xp: My point was, look at the type of 5 and tell me if its a function.
02:29:34 <Nevoic> merijn how does * :: * differ from * -> * ?
02:29:51 <Zer0xp> :t 5
02:29:52 <lambdabot> Num p => p
02:30:03 <Zer0xp> It's of type Num
02:30:07 <Zer0xp> ?
02:30:31 <merijn> Nevoic: Well, what is the "type" * -> *? That is (or at least, used to be) the sort named BOX, because all Haskell kinds where in BOX
02:30:58 <merijn> Nevoic: With TypeInType the "type" of * is * and the tyep of "* -> *" is also *
02:31:10 <Zer0xp> What's the difference between lamdabot and yahb here ?
02:31:14 <merijn> Nevoic: In fact, everything single kind is itself kind *
02:31:18 <Zer0xp> Why 2 bots ?
02:31:25 <dminuoso> Zer0xp: Im just asking: Is that thing a function? Yes or no?
02:31:38 <Nevoic> I mean I have a pretty primitive understanding of this, where I just understand * -> * to be a type whose arity is 1 (that is you need to give a type to get the type you're constructing)
02:31:38 <Zer0xp> 5 is not a function
02:31:42 <dminuoso> Zer0xp: Okay! Why not?
02:32:12 <Zer0xp> Because I checked it's type and it mentioned that it was of Type Num
02:32:32 <boxscape> Zer0xp both have pros and cons, lambdabot is older and has a lot of custom commands and is quite unlike ghci in some way, yahb uses ghci directly as well as bash and a lua interpreter I think
02:32:42 <dminuoso> Zer0xp: My point is, the type does not mention any (->)
02:32:57 <dminuoso> Zer0xp: So using the type you can tell whether some value can be applied to some argument (i.e. whether its a function)
02:33:03 <Zer0xp> dminuoso: Oh yea, it doesn't
02:33:18 <Zer0xp> Okay so if => is mentioned, it means it's a function
02:33:20 <Zer0xp> ?
02:33:32 <dminuoso> Zer0xp: No, thats just part of polymorphism.
02:33:35 <dminuoso> % :t 'c'
02:33:35 <yahb> dminuoso: Char
02:33:38 <dminuoso> May be a better example.
02:33:51 <dminuoso> % :t toUpper
02:33:51 <yahb> dminuoso: Char -> Char
02:34:00 <dminuoso> This however has a -> in there, so you can apply it to an argument.
02:34:30 <Zer0xp> % :t fmap
02:34:30 <yahb> Zer0xp: Functor f => (a -> b) -> f a -> f b
02:34:56 <Zer0xp> % :t +
02:34:57 <yahb> Zer0xp: ; <interactive>:1:1: error: parse error on input `+'
02:35:03 <Zer0xp> % :t '+'
02:35:03 <yahb> Zer0xp: Char
02:35:07 <boxscape> % :t (+)
02:35:07 <yahb> boxscape: Num a => a -> a -> a
02:35:11 <Zer0xp> Oh
02:35:29 <dminuoso> Zer0xp: So the reason I brought this up, kinds is what lets us tell whether a "type function has been fully applied" or not.
02:35:42 <dminuoso> Zer0xp: But instead of "asking its type", we ask the kind of the type.
02:35:46 <dminuoso> % :k Maybe
02:35:46 <yahb> dminuoso: Maybe :: * -> *
02:36:00 <dminuoso> So Maybe is a type-level function taking a type, and returning a type.
02:36:01 <Zer0xp> % :k Num
02:36:01 <yahb> Zer0xp: Num :: * -> Constraint
02:36:11 <dminuoso> Zer0xp: Num is a fancy bit, its best to glance over that part for now. :)
02:36:32 <Zer0xp> Lol I was gonna ask what constraint is 
02:36:53 <dminuoso> Zer0xp: A constraint is something that puts a limit on something.
02:37:15 <freeman42x> any suggestions for an idea DB access library? https://www.reddit.com/r/haskell/comments/d9ha89/list_of_haskell_database_access_libraries_could/?ref=share&ref_source=link
02:37:18 <dminuoso> Zer0xp: When you see a type variable, it means "the caller has the freedom to pick whatever they want for it". A constraint limits that choice.
02:37:46 <Zer0xp> % :k Char
02:37:46 <yahb> Zer0xp: Char :: *
02:38:00 <dminuoso> Zer0xp: So in case of `(+) ::  Num a => a -> a -> a` it means you can pick whatever you want for type `a`, but with the constraint/limit that there has to be an `instance Num a` for whatever your choice of `a` is going to be.
02:39:42 <Zer0xp> What do you mean by 'instance Num a' ? Does that mean a value of type 'Num' ?
02:39:53 <dminuoso> Zer0xp: Do you know what a typeclass is?
02:40:32 <dminuoso> Zer0xp: Perhaps you shouldn't be exploring kinds and functor if you dont understand what a typeclass is in principle. :-)
02:40:45 <Zer0xp> I thought I knew what it was but now I realise that I probably know nothing.
02:44:22 <dminuoso> Zer0xp: What, in your mind, is a typeclass?
02:45:00 <Zer0xp> Things like Eq and Order ?
02:45:14 <Zer0xp> But I never really got the point of them existing
02:45:51 <dminuoso> Zer0xp: typeclasses are, at first glance, similar to Java's interfaces or Elixir's protocols.
02:52:46 <arahael> And swift's protocols.
02:53:38 <dminuoso> Zer0xp: So `class Eq a where (==) :: a -> a -> Bool` is an interface about being able to compare two things. Not everything is comparable, in order to be comparable you need to define what it means for values of some type to be comparable
02:54:19 <dminuoso> Zer0xp: So by writing `instance Eq YourType` you define what it means for two values of YourType to be comparable for equality. This works by supplying implementations for all methods of that interface.
02:54:32 <dminuoso> Zer0xp: The usefulness is that code can be written to work with "any comparable thing
02:54:34 <dminuoso> For example
02:54:41 <dminuoso> :t elem
02:54:43 <lambdabot> (Foldable t, Eq a) => a -> t a -> Bool
02:55:04 <dminuoso> It doesn't really care what `a` is going to be, as long as you can compare two elements for equality.
03:00:06 <Zer0xp> And Foldable is another typeclass ?
03:01:40 <dminuoso> Zer0xp: Right!
03:01:40 <Zer0xp> :t Eq
03:01:42 <lambdabot> error:
03:01:42 <lambdabot>     • Data constructor not in scope: Eq
03:01:42 <lambdabot>     • Perhaps you meant one of these:
03:01:54 <Zer0xp> :k Eq
03:01:55 <dminuoso> Zer0xp: Foldable is the typeclass of all things that can be "folded together" or "transformed into a list"
03:01:56 <lambdabot> * -> Constraint
03:02:14 <dminuoso> Zer0xp: And Functor is the typeclass of all things that can be "mapped over"
03:02:55 <Zer0xp> When you say folded together you mean some sort of cyclic list ?
03:03:42 <Zer0xp> Oh so Functor is a typeclass ?
03:03:59 <Zer0xp> :k Functor
03:04:00 <lambdabot> (* -> *) -> Constraint
03:04:19 <Zer0xp> :k Ord
03:04:20 <lambdabot> * -> Constraint
03:04:23 <dminuoso> Zer0xp: The "folding" is an imaginary term here.
03:04:33 <dminuoso> Zer0xp: We could pretend that Foldable is about all things that can be transformed into a list.
03:04:41 <Zer0xp> Oh okay.
03:05:09 <dminuoso> Its not entirely correct, but its a good approximation.
03:05:10 <Zer0xp> That is a very misleading term then
03:05:21 <dminuoso> Zer0xp: Well its not because its really rather about "folding data structure together"
03:05:34 <dminuoso> Zer0xp: It's just that "transformable into a list" is a natural consequence. 
03:05:51 <dminuoso> Zer0xp: If you can fold your data structure together, you can most certainly fold it into a list... :p
03:06:31 <Zer0xp> But a list is a data structure, right ? Are you trying to transform one data structure into another ?
03:06:43 <Zer0xp> Hence the term fold ?
03:08:01 <Zer0xp>  I apologize for asking so many silly questions.
03:08:47 <dminuoso> Zer0xp: Its not as much about folding data structure into another.. its rather about folding data structure together.
03:09:03 <dminuoso> It could be that the resulting thing is some other elaborate data structure... or maybe not...
03:09:06 <dminuoso> it doesn't really matter.
03:09:23 <dminuoso> For example it might be natural to take a tree of numbers, and want to "add them all together".
03:10:27 <tdammers> :t fold
03:10:28 <lambdabot> (Foldable t, Monoid m) => t m -> m
03:10:36 <int-e> . o O ( so you cut down the tree, process the wood to paper, and write the sum of the leaf values on that )
03:10:41 <tdammers> :t foldl
03:10:42 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
03:11:09 <int-e> . o O ( And then you make an origami crane out of it. Hence "fold". )
03:11:56 <tdammers> :t (:)
03:11:57 <lambdabot> a -> [a] -> [a]
03:12:11 <tdammers> :t foldr
03:12:13 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
03:12:25 <tdammers> now substitute [a] for b
03:12:31 <tdammers> :t foldr (:)
03:12:34 <lambdabot> Foldable t => [a] -> t a -> [a]
03:12:47 <tdammers> or even:
03:12:51 <tdammers> :t foldr (:) []
03:12:52 <lambdabot> Foldable t => t a -> [a]
03:13:32 <tdammers> so this essentially means that no matter which a and t you pick, as long as t is Foldable, you can gain a list of a's
03:13:56 <int-e> Zer0xp: The real picture is probably closer to that of a flyer with several pages... which looks like a single page when folded.
03:14:23 <tdammers> so that's how "foldable" and "can be turned into a list" relate
03:24:31 <dminuoso> Zer0xp: Are you perhaps familiar with .reduce or .collect from other languages like perhaps JavaScript or Ruby?
03:39:51 <Zer0xp> dminuoso: The only language I'm actually familiar with is C.
03:40:55 <Zer0xp> Should I start learning other languages before I do Haskell or should I learn them in parallel along with Haskell ?
03:40:59 <dminuoso> Nah.
03:41:12 <dminuoso> Its fine
03:41:58 <dminuoso> Zer0xp: Anyway, the point is a typeclass represents some interface. The Foldable interface captures being able to fold data together. Functor captures being able to "map over your thing with a mapping function"
03:42:31 <dminuoso> Zer0xp: And constraints are the mechanism by which you can some constrained polymorphism. For example
03:42:43 <dminuoso> `quickSort :: Ord a => [a] -> [a]`
03:43:14 <dminuoso> quickSort works lists of any element, as long as it can compare elements for GT/LT/EQ.
03:43:33 <dminuoso> You could squint a bit and imagine that `Ord a` is a dictionary of methods, and then => is sort of like a function arrow.
03:43:59 <dminuoso> So that would read "If you can give me a dictionary `Ord a` and a list of `as`, I can sort your list"
03:44:21 <Zer0xp> Okay so GT/LT/EQ are methods of the typeclass 'Ord' ?
03:44:53 <dminuoso> Zer0xp: No. You can use hoogle/hackage to quickly find out what methods a typeclas entails.
03:53:00 <Zer0xp> What's the difference between Eq and Ord though since both deal with comparison ? I'm assuming the former only deals with equality though.
03:53:31 <dminuoso> Zer0xp: Equality is just about asking "are these two the same", whatever "same" means to you.
03:53:45 <dminuoso> Zer0xp: Ord is about an ordering, where you could ask "is this less, the same, or more", whatever that means.
03:53:59 <int-e> :t (==)
03:54:00 <lambdabot> Eq a => a -> a -> Bool
03:54:02 <int-e> :t (<)
03:54:04 <lambdabot> Ord a => a -> a -> Bool
03:54:13 <Zer0xp> :t (=)
03:54:14 <lambdabot> error:
03:54:15 <lambdabot>     parse error on input ‘=’
03:54:15 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
03:54:37 <dminuoso> Zer0xp: It turns out that Ord includes Eq already, which is why Eq is a superclass of Ord.
03:54:48 <Zer0xp> Ohhhh
03:54:58 <int-e> Yeah, = is syntax, not an infix operator.
03:55:01 <dminuoso> Zer0xp: that is, if you can ask about "is the left thing less, the same, or more, tha nthe right", then that already implies you can satisfy the question of "are these two the same" :)
03:55:08 <dminuoso> But not the other way.
03:55:24 <Zer0xp> You mean Eq is subclass of Ord ?
03:55:34 <dminuoso> Zer0xp: No, Eq is a superclass of Ord
03:56:01 <Zer0xp> So Ord is a subclass of Eq ?
03:56:06 <dminuoso> Yes.
03:56:36 <dminuoso> Zer0xp: Take note that our choices of words "class", "superclass" and "subclass" are very different from the same terms used in some objet oriented languages.
03:56:58 <dminuoso> But since you only know C... :)
03:57:03 <Zer0xp> But Ord contains Eq then shouldn't Eq be the subclass of Ord ?
03:57:23 <dminuoso> Zer0xp: It's just the way we use the word
03:57:58 <dminuoso> Zer0xp: If you think of a class as a "bag" that contains all types that conform to that interface, then a "subclass" is a smaller bag inside that outer bag.
03:58:20 <dminuoso> Zer0xp: The `Ord` bag is certainly smaller than the `Eq` bag, its a subclass of Eq.
03:59:58 <Zer0xp> I understand what a subclass is but when you said Ord contains Eq, I thought you meant Eq was entirely within Ord but I ger what you're saying now
04:00:07 <dminuoso> Zer0xp: Its not that "Ord contains Eq", its rather that "Ord entails Eq"
04:00:40 <dminuoso> (So Eq contains Ord)
04:01:13 <dminuoso> iow "If your type T has an instance Ord, then it has an instance Eq as well"
04:01:31 <boxscape> (never used the language, but the part where they use `class Eq a <= Ord a` with the arrow the other way around to signify implication seems nice)
04:02:12 <boxscape> (although actually now that I've types it I realize that my font ligatures make that look like "less than or equal"
04:02:13 <boxscape> )
04:02:20 <boxscape> oh 
04:02:23 <sshine> in QuickCheck I'm writing a sized Int -> Gen (Tree PostId) that represents a forum thread where type PostId = Int. I'd like PostIds to be incremented, but it seems that Gen doesn't have an internal state. I then looked at QuickCheck-GenT so I can have a GenT (State PostId), but then QuickCheck combinators like 'shuffle :: [a] -> Gen [a]' bug out:
04:02:23 <boxscape> I should menion
04:02:29 <boxscape> I was talking about purescript
04:02:39 <sshine> • Couldn't match type ‘Test.QuickCheck.Gen.Gen [Int]’ with ‘GenT (State ThreadId) [Int]’
04:03:07 <Zer0xp> Oh I started trying to learn Purescript first but everyone told me that the material was limited and that Haskell was the way to go.
04:03:37 <sshine> it seems that QuickCheck-GenT is kind of old (I also needed to add it to extra-deps in my stack.yaml), so it doesn't look like it uses mtl-style transformers, meaning I can't just derive MonadGen.
04:03:39 <boxscape> that sounds like it's probably true
04:04:05 <boxscape> ( Zer0xp )
04:04:13 <sshine> how would it look like if I 'lift' 'shuffle'?
04:04:39 <lyxia> sshine: pick?
04:04:40 <sshine> >_< I just had to ask and go look myself. there's something called 'liftGen'.
04:05:28 <ski> boxscape : yes. i think it's a mistake to use `<=' for "less-than-or-equal"/"is at most". Prolog (and Erlang with it) writes `=<' instead
04:05:29 <Zer0xp> Is Beta Reduction used a lot while writing Haskell code ?
04:05:48 <sshine> lyxia, pick what? between Gen and GenT?
04:05:57 <dminuoso> Zer0xp: Oh beta reduction is just a fancy term.
04:06:38 <dminuoso> Zer0xp: Where did you stumble over that term?
04:06:39 <lyxia> sshine: wait, GenT, that's not QuickCheck
04:06:41 <ski> Zer0xp : beta-reduction happens when the program is running, but perhaps not so much when you're writing a program, except insofar as you use it, inside your head, to reason about, or refactor, some code
04:06:50 <sshine> lyxia, no, it's in the extended package QuickCheck-GenT.
04:07:06 <Zer0xp> dminuoso: Haskell From First Principles
04:07:07 <boxscape> ski interesting, I've never seen that notation anywhere
04:07:10 <sshine> lyxia, it's kinda old. like QuickCheck. I'd go with Hedgehog nowadays, but for some reason, I'm bound to QuickCheck right now.
04:07:30 <lyxia> ok
04:07:32 <Zer0xp> dminuoso: It's a good book to learn Haskell from apparently.
04:07:43 <sshine> I figured I'd leverage my understanding of QuickCheck to build a stateful Gen, and then see how it's done in Hedgehog afterwards.
04:07:47 <dminuoso> Zer0xp: It's supposedly a fine book. Where does it mention beta reduction?
04:07:51 <lyxia> sshine: I was thinking of PropertyM in QuickCheck, which has a pick function playing a similar role
04:07:59 <Zer0xp> dminuoso: Chapter 1
04:08:01 <sshine> lyxia, ah.
04:08:19 <dminuoso> Zer0xp: Interesting, can you quote the book perhaps for reference?
04:08:24 <Zer0xp> dminuoso: Chapter 1 is all about understanding lambda
04:08:35 <Zer0xp> dminuoso: Sure, give me a minute.
04:09:12 <boxscape> dminuoso the introductory chapter is purely about lambda calculus without really mentioning haskell
04:09:25 <Zer0xp> When we apply a function to an argument, we substitute the input
04:09:27 <Zer0xp> expression for all instances of bound variables within the body of
04:09:29 <Zer0xp> the abstraction. You also eliminate the head of the abstraction, since
04:09:30 <dminuoso> Strange
04:09:31 <Zer0xp> its only purpose was to bind a variable. This process is called beta
04:09:33 <Zer0xp> reduction.
04:11:16 <Zer0xp> https://github.com/RomaniukVadim/knowledge-base/blob/master/Hacking%20Books/Christopher%20Allen%2C%20Julie%20Moronuki%20-%20Haskell%20programming%20from%20first%20principles%20-%202016.pdf
04:11:22 <dminuoso> Zer0xp: Ah I guess the sample starts at chapter 2 instead. Not sure why there's a lambda calculus chapter this early in th ebook
04:15:37 <sshine> now I do: newtype ThreadGen a = ThreadGen { unThreadGen :: GenT (State ThreadId) a } deriving (Functor, Applicative, Monad, MonadState ThreadId), and it gives me the error: No instance for (MonadState ThreadId (GenT (State ThreadId))).
04:16:10 <yushyin> why is a copy of the book on github? afaik it is not a free book so this is copyright violation?
04:17:24 <sshine> I'd say so.
04:29:19 <sshine> I sent a DMCA takedown to GitHub.
04:29:39 <sshine> bitemyapp, ^
04:34:39 <boxscape> can you do that on behalf of someone else?
04:35:00 <merijn> boxscape: If you've been authorised by the copyright holder, sure
04:35:09 <boxscape> hm, okay
04:35:14 <merijn> boxscape: Consider lawyers sending notices on behalf of an author
04:35:19 <boxscape> yeah that makes sense
04:42:04 <sshine> I don't mind that people distribute copies of books with their friends. and I don't mind that individuals download copies they didn't pay for if they can't afford them. and I don't mind copying dead authors. but I think it's too big of a "fuck you" to distribute something freely that's actively being sold by the author. :)
04:50:26 <arahael> The grey area is when those dead authors signed their rights away.
04:54:17 <tdammers> legal or moral grey area? and also, #-{offtopic,blah}
05:07:38 <arahael> tdammers: Both, I guess.
05:07:51 <arahael> And ahh, yes. :(
05:13:30 * hackage mini-egison 0.1.0 - Template Haskell Implementation of Egison Pattern Matching  https://hackage.haskell.org/package/mini-egison-0.1.0 (SatoshiEgi)
05:48:30 * hackage hw-bits 0.7.0.7 - Bit manipulation  https://hackage.haskell.org/package/hw-bits-0.7.0.7 (haskellworks)
05:50:00 * hackage hw-balancedparens 0.3.0.1 - Balanced parentheses  https://hackage.haskell.org/package/hw-balancedparens-0.3.0.1 (haskellworks)
06:37:30 * hackage hierarchical-spectral-clustering 0.5.0.1 - Hierarchical spectral clustering of a graph.  https://hackage.haskell.org/package/hierarchical-spectral-clustering-0.5.0.1 (GregorySchwartz)
07:15:53 <dmwit> What does hw-balancedparens... DO?
07:17:01 <shapr> am I able to put a particular git repo hash into a cabal.project.local ?
07:23:23 <merijn> shapr: Yes
07:23:25 <Zemyla> traverse (fmap f . g) === fmap (fmap f) . traverse g, right?
07:25:29 <merijn> shapr: https://github.com/merijn/GPU-benchmarks/blob/54e652e3c9e7ba87337b1da4bbfa96251a8d41fb/cabal.project#L3-L7
07:26:59 <dminuoso> Zemyla: looks right to me
07:29:42 <shapr> merijn: ah, thanks!
07:32:06 <Zemyla> Like, by Parametricity, I can't see how it couldn't be.
07:35:39 <dminuoso> Zemyla: t . traverse f = traverse (t . f)
07:37:15 <ski> needs more `fmap' ?
07:39:04 <dmwit> That's only if t is an "applicative transformation".
07:39:15 <dmwit> I don't see how fmap f could possibly have a polymorphic-enough type to be one.
07:39:55 <dminuoso> Zemyla: My point is, I think that second fmap is off.
07:40:01 <dmwit> (Sorry, let me say that a different way: I believe there are many choices of f for which fmap f does not have a polymorphic-enough type to be one.)
07:40:23 <dminuoso> dmwit: Ahh.
07:40:26 <dminuoso> I see.
07:40:26 <Zemyla> :t \f g -> traverse (fmap f . g)
07:40:28 <lambdabot> (Traversable t, Applicative f) => (a1 -> b) -> (a2 -> f a1) -> t a2 -> f (t b)
07:40:40 <Zemyla> :t \f g -> fmap (fmap f) . traverse g
07:40:42 <lambdabot> (Traversable f2, Applicative f1) => (a1 -> b) -> (a2 -> f1 a1) -> f2 a2 -> f1 (f2 b)
07:41:21 <kuribas> Why is unsafeInterleaveIO unsafe?
07:41:27 <kuribas> it's type is IO a -> IO a, so it is just transforming an IO expression into another one
07:41:36 <merijn> kuribas: Because it changes *when* IO happens
07:41:51 <kuribas> merijn: why is that a problem?  IO can do whatever it wants
07:42:00 <ski> imho, arguably, it's not unsafe in quite the same way as the other `unsafeX' operations
07:42:11 <ski> (cf. `forkIO')
07:42:11 <merijn> kuribas: I mean that the IO *happens* when you evaluate 'a' (inside pure code)
07:42:45 <merijn> kuribas: So, for example if the IO triggers an IOException, it'll be triggered by the evaluation of 'a' inside some pure code, as opposed to triggering in the IO (where you can sanely catch it)
07:42:50 <ski> (otoh, `unsafeInterleaveST' is another thing ..)
07:43:01 <merijn> kuribas: It's by far the safest of the unsafe functions, but still not completely safe
07:43:05 <dmwit> kuribas: In the value returned by `y <- unsafeInterleaveIO x`, the execution of IO is driven by the evaluation of `y`. Which means pure code has control over when IO happens.
07:43:07 <kuribas> merijn: that's not different from error or undefined
07:43:18 <kuribas> merijn: then error should be called unsafeError
07:43:27 <merijn> kuribas: It really should, tbh
07:44:10 <dminuoso> kuribas: Here is a demonstration how lazy IO breaks referential transparency: https://mail.haskell.org/pipermail/haskell/2009-March/021064.html
07:44:11 <kuribas> still evaluating a pure expression (say infinite list) could also trigger an exception (out of memory)
07:44:13 <merijn> kuribas: Lazy IO also has resource management implications that non-lazy IO doesn't
07:44:31 <kuribas> merijn: yeah it can hard to reason about
07:44:57 <kuribas> If I would use it to break up a large database query into small queries, wouldn't that be fine?
07:45:10 <merijn> kuribas: Yes, no, maybe :)
07:45:26 <merijn> kuribas: Can't you use something like conduit instead?
07:45:31 <dmwit> dminuoso: err
07:45:37 <dmwit> dminuoso: I don't think that breaks referential transparency.
07:45:45 <dmwit> I don't think the email claims it does, either.
07:45:58 <kuribas> merijn: well, I need to do something like groupBy
07:46:09 <merijn> dmwit: The behaviour depends on the evaluation order, so I'd say it doe
07:46:09 <kuribas> merijn: I didn't find it in conduit
07:46:23 <merijn> kuribas: You can implement your own
07:46:30 <dmwit> merijn: But that's not what referential transparency means.
07:46:31 <kuribas> it's... tricky
07:46:31 <dminuoso> dmwit: Did you check the code at the bottom?
07:46:34 <merijn> kuribas: In fact, I already did and I considered trying to get it accepted upstream
07:46:42 <dmwit> merijn: Referential transparency means you can replace a variable by its definition.
07:46:44 <dminuoso> dmwit: Oh I can see where this is heading.
07:46:56 <dmwit> merijn: Which you can, indeed, do and still get the same behavior in this program.
07:47:33 <merijn> kuribas: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/model-src/Evaluate.hs#L106-L116
07:48:07 <dmwit> merijn: Referential transparency does *not* say "you can replace one definition with a different definition and get the same behavior", and it would be absurd to assert that property.
07:48:26 <kuribas> merijn: nice
07:48:31 <kuribas> merijn: would that work with streamly?
07:49:27 <merijn> kuribas: As long as there's a "peek :: Stream a b m (Maybe a)" like primitive, it should
07:49:53 <dmwit> (unsafeInterleaveIO *does* break an important property, just not referential transparency.)
07:50:22 <merijn> dmwit: My point is that whether that specific single piece of code computes 1 or -1 depends on the evaluation order of s1 and s2
07:50:42 <merijn> Which is definitely not pure
07:51:00 <dmwit> I can agree with all of that.
07:51:13 <kuribas> dmwit: which property?
07:52:55 <dmwit> Lazy evaluation makes it really hard to predict when a thing will be evaluated. If you toss computations that do IO into the mix, your programs become very confusing and difficult to reason about. For example, which order do the prints happen in [print 1, (), print 2, ()]? You can't know without knowing *the entire rest of the program*.
07:52:58 <dminuoso> kuribas: pure code can drive IO.
07:53:15 <dmwit> Folks spent a long time trying to figure out different ways of dealing with this problem when Haskell was first booting up.
07:53:32 <kuribas> dminuoso: it can do that?
07:53:37 <dmwit> The eventual solution was the IO monad, which was recognized as a way to add a data dependency that enforced IO actions to happen in program-text order.
07:53:40 <dminuoso> kuribas: That's the entire point of unsafeInterleaveIO.
07:53:43 <kuribas> dminuoso: it already does that
07:53:50 <kuribas> dminuoso: but the order is different
07:54:04 <dminuoso> kuribas: No, it already does not.
07:54:13 <dmwit> So the important property of the IO monad is that in m >>= f, the IO effects of m happen before the effects of f.
07:54:14 <kuribas> for example "doSomething pure_expression"
07:54:25 <kuribas> doSOmething is driven by the pure expression.
07:54:27 <dmwit> As far as I know, we don't have a pithy *name* for this property.
07:54:32 <dmwit> But unsafeInterleaveIO breaks it.
07:54:37 <dminuoso> kuribas: Ask you this. When I force a value `f :: Int`, should that launch a missile?
07:54:48 <dminuoso> Just by virtue of forcing that value.
07:54:58 <ski> dmwit : also `forkIO'
07:55:05 <kuribas> dminuoso: it might
07:55:14 <dminuoso> kuribas: Why?
07:55:25 <dmwit> ski: Good point!
07:55:50 <dmwit> ski: Let me think about why I'm okay with forkIO but less okay with unsafeInterleaveIO. Just off the cuff it seems like a tricky one. Might require a shower.
07:55:55 <kuribas> dminuoso: if it wasn't interleaved, the missile would have already launched, so there isn't much difference
07:56:01 * ski still thinks there's some kind of reasonable comparision between lazy I/O, and concurrency
07:56:04 <kuribas> dminuoso: except it's harder to reason about
07:56:20 <dmwit> ski: (Or whether I should change my stance on that, of course!)
07:56:25 <dminuoso> kuribas: It's definitely not pure if evaluating it causes side effects.
07:56:37 <dminuoso> kuribas: It sort of defeats the entire attempt of controlling side effects with IO
07:56:37 <ski> (at least as long as you're prepared to give up guarantees about exactly when `unsafeInterleaveIO'd effects will happen)
07:56:40 <kuribas> dminuoso: I had a problem like that in python with lazy loading from the database.
07:57:06 <kuribas> dminuoso: but I can see it to be useful in some cases
07:58:05 <dminuoso> kuribas: https://mail.haskell.org/pipermail/haskell/2009-March/021064.html consider this example. You can twist it so far, to make a pure function `Int -> Int -> Int` return different answers, depending on the order of evaluation.
08:00:46 <kuribas> dminuoso: I don't see how, it still returns e1 - e2 right?
08:01:07 <kuribas> dminuoso: e1 and e2 may be changed, but they come from IO
08:01:21 <merijn> kuribas: Which one is the first line and which the second?
08:01:23 <kuribas> I don't see that as breaking referential transparency
08:01:34 <merijn> kuribas: OR does one of them read all the lines leaving nothing for the other
08:01:37 <dminuoso> kuribas: Well we just talked about it. Its strictly speaking breaking purity.
08:01:51 <dminuoso> kuribas: If a function doesn't always return the same value given the same arguments, things get strange.
08:02:11 <dminuoso> kuribas: If you apply a function to two values, and the answer depends on nothing but the order of evaluation, that's basically purity disappearing entirely.
08:03:00 <geekosaur> ghc's runtime can replace a computation with its result to avoid recomputing it later, this can lead to weirdness if I/O is quietly happening in the background
08:03:05 <kuribas> dminuoso: it doesn't
08:03:20 <kuribas> dminuoso: f1 and f2 are referentially transparent
08:03:54 <dminuoso> kuribas: Are you just ignoring that mail entirely? :)
08:04:37 <kuribas> well, perhaps not quite referentially transparent :)
08:04:57 <kuribas> but if you use seq, you are already changing the behaviour
08:05:05 <dmwit> ski: I guess I sort of feel like, if I don't care about memory usage or runtime, I ought to be able to treat pure functions as though I only need to know what they compute, and not their implementation.
08:05:05 <dminuoso> kuribas: That's not the point.
08:05:21 <dmwit> ski: forkIO allows me to continue acting in that way, but unsafeInterleaveIO does not.
08:05:33 <dminuoso> kuribas: The point is that, in the presence of unsafeInterleaveIO the order of evaluation can alter an expression.
08:05:52 <Zemyla> Hmm, if UnsafeInterleaveIO were of type IO a -> IO (Either SomeException a) and were implemented with forkIO under the hood, would that be better?
08:06:05 <dmwit> ski: It feels... *okay*ish to add a few extra things to the list [memory usage, runtime], but adding all of the effects that can possibly happen in IO seems a bit extreme.
08:06:25 <dminuoso> kuribas: Sort of like `given two expressions x and y, a third expression will depend on nothing but the evaluatoin order of x and y`. The `seq` usage is just used to make the evaluation order explicit and not up to chance.
08:06:42 <dmwit> Zemyla: No, it would have to be IO a -> IO (IO a).
08:07:03 <kuribas> dminuoso: so then, do you consider concurrency to be unsafe?
08:07:04 <dmwit> Zemyla: (Or IO a -> IO (IO (Either SomeException a)) would be fine, too, it's just the extra layer of IO that's needed.)
08:07:18 <dminuoso> kuribas: Im really not sure what you are getting at.
08:07:29 <dmwit> kuribas: I think my comments starting 2 minutes ago, and directed at ski, are addressing that question.
08:08:54 <ski> dmwit : doesn't it depend on what you consider the speced behaviour of `unsafeInterleaveIO' is .. what if it were allowed to spawn off a thread doing the computation, anytime, and forcing the value waits for the result of that thread ?
08:09:21 <dmwit> ski: That still violates the property that I don't need to know the implementation of pure functions to use them correctly.
08:09:34 <ski> i don't see why
08:09:43 <dmwit> ski: Because if forcing a value waits for a result, then the order that things get forced can affect what result I get.
08:09:54 <ski> how ?
08:10:04 <dmwit> ski: (And the order things get forced is intimately tied to the implementation of pure functions.)
08:10:29 <dmwit> Sorry, let me pause.
08:11:00 <ski> if they can already happen in any order, because of concurrency, i don't see how differences in choices in how the implementation forces can make that any worse
08:11:05 <dmwit> ski: Okay, maybe that would not be too terrible.
08:11:20 <kuribas> dminuoso: I did read the email, and I disagree with: "Thus a pure function (-) of the pure type gives different results depending on the order of evaluating its arguments."
08:11:29 <dmwit> ski: But... this is not what the documentation of unsafeInterleaveIO says. ^_^
08:11:32 <kuribas> dminuoso: the pure function does no give different results
08:11:40 <ski> (perhaps `unsafeInterleaveIO' ought to be explicitly allowed to do this ..)
08:11:42 <merijn> kuribas: 1 and -1 are the same?
08:11:43 <dmwit> ski: "the
08:11:43 <dmwit> IO will only be performed when the value of the a is
08:11:45 <dmwit> demanded."
08:11:53 <dmwit> Whoops, accidental multiline. Sorry about that.
08:11:54 <ski> see above
08:12:01 <kuribas> merijn: the inputs are different
08:12:18 <merijn> kuribas: No, you can get different results with the exact same input
08:12:29 <dmwit> ski: Yes, perhaps. But I think that would very much be a breaking change vs. how people currently use it.
08:12:43 <dminuoso> print $ f1 (read_int s1) (read_int s2) -- kuribas
08:12:45 <dminuoso> print $ f2 (read_int s1) (read_int s2)
08:12:53 <dminuoso> kuribas: ^- do you agree that the arguments are the same?
08:12:55 <dmwit> ski: e.g. people would probably be upset if getContents started filling memory instead of blocking whoever was producing input.
08:12:56 <merijn> kuribas: The point is given that code you cannot *ever* predict what the result is *unless* you know the order in which GHC evaluated the arguments of (-)
08:13:04 <dmwit> Well... maybe not many people. ^_^
08:13:19 <merijn> dmwit: Doubt it, lots of commonly used libraries have weirdly broken stuff
08:13:20 <dmwit> ski: We could have a `interleaveIO` that does what you say, perhaps. ;-)
08:13:24 <kuribas> dminuoso: I don't
08:13:39 <dminuoso> kuribas: So `read_int s1` is different from `read_int s1` ?
08:13:43 <dminuoso> How?
08:13:44 <merijn> dmwit: For example: ansi-terminal blocks indefinitely on getTerminalSize when stdout is redirected. Fun times! Guess how I know!
08:13:56 <dmwit> merijn: ^_^
08:14:20 <kuribas> dminuoso: in two invocations, yes
08:14:29 <dminuoso> kuribas: No you misunderstand. Not two invocations.
08:14:44 <dmwit> Zemyla: So it seems I owe you an apology. I agree that would be better.
08:14:45 <dminuoso> kuribas: You pick one invocation, run the program. Then you uncomment one and use the other.
08:14:53 <dminuoso> kuribas: You will notice they behave differently.
08:15:05 <dminuoso> kuribas: Both f1 and f2 just subtract one argument from the other.
08:15:24 <dminuoso> kuribas: If you dont see this as a complete grotesk violation of purity, I dont think you care much about purity at all.
08:15:37 <dmwit> yuck
08:15:40 <kuribas> dminuoso: it changes the values of s1 and s2, but they aren't pure, as they come from IO
08:15:41 <dmwit> dminuoso: That argument sucks.
08:15:49 <kuribas> dminuoso: so no violation of purity at all
08:15:55 * ski thinks you couldn't predict the result with `forkIO' (and say `ivar-simple'), either
08:16:28 <dmwit> (The "if you don't agree with me you're part of the outgroup" argument sucks, I mean.)
08:16:43 <dminuoso> dmwit: Fair enough.
08:16:45 <kuribas> dminuoso: they are pure after you read them from IO, but you cannot predict what they are.  You are just assuming they have to be the same, but there is no such law in IO.
08:16:58 <dminuoso> kuribas: They are not in IO.
08:17:05 <Zemyla> Also, a weird thought I had: Why does the async package use STM rather than making a free Applicative from something like data Thread a = Thread !ThreadId !(MVar (Either SomeException a))?
08:17:21 <dminuoso> kuribas: read_int s1 :: Int
08:17:25 <dminuoso> kuribas: It's a pure value.
08:17:42 <dminuoso> kuribas: And of course they are not pure, that's the entire point. You have impurity in your pure world going on.
08:17:45 <dminuoso> That's the problem.
08:18:43 * ski doesn't agree with "it changes the values of s1 and s2, but they aren't pure, as they come from IO","so no violation of purity at all" but more or less agrees with "they are pure after you read them from IO, but you cannot predict what they are.  You are just assuming they have to be the same, but there is no such law in IO."
08:18:46 <kuribas> dminuoso: s1 doesn't have to be the same from two invocations.  The same way as x in "do x <- getLine" doesn't have to be the same value of x
08:19:06 <dminuoso> kuribas: Did you actually read the mail in its entirety?
08:19:08 <kuribas> each run of the program
08:19:18 <dminuoso> kuribas: I mean this is an honest question.
08:19:35 <dminuoso> kuribas: Because it says to run this program and put 1 and 2 as inputs each time.
08:19:45 <dminuoso> So clearly they will be the same.
08:19:48 <ski> dmwit : i suppose. this appears the best way to save it, to me, though
08:19:52 <kuribas> dminuoso: in standard input
08:19:55 <dminuoso> kuribas: Yes
08:20:04 <kuribas> dminuoso: standard input is the input of a pure function
08:20:19 <dminuoso> kuribas: I dont know how to explain this to you, sorry.
08:20:36 <dmwit> ski: I'm not sure it needs saving. It's already labeled "unsafe", we allow all sorts of sins under that label.
08:21:08 <ski> dmwit : i never liked the label "unsafe", anyway. too vague. too many different kind of things lumped under it
08:21:23 <dmwit> Absolutely agreed.
08:21:45 <dmwit> Whenever I label something unsafe, I always leave a few lines in the haddocks saying exactly why, for this exact reason.
08:21:53 <ski> (e.g. i'd prefer it if `unsafePerformIO' was renamed to `promisePureIO', along with the "promise" convention in Mercury)
08:21:54 <dminuoso> kuribas: The IO action is not the problem. Because you are expected to supply the same arguments, it's not about "the input could differ between invocations", because it doesn't. And there's no IO here, because you are in the `(a -> IO b)` part of it, where `a` is a pure value.
08:22:24 <kuribas> dminuoso: so?  a doesn't need to be constant because the inputs are the same.
08:22:59 <dminuoso> kuribas: So getLine should return different results each time, regardless of whether you supply the same input? Sorry I dont see what you are getting at.
08:23:07 <ski> (and the "different ballpark" is the core of my complaint about `unsafeInterleaveIO' (but not `unsafeInterleaveST') being named that way)
08:23:20 <dminuoso> kuribas: Would you agree that if you run getLine and specify some string "foobar", and you repeat that excercise, that getLine should produce the same result each time?
08:23:34 <kuribas> dminuoso: it could without breaking any laws of purity
08:23:35 <dminuoso> Or do you believe that getLine generates random strings?
08:23:39 <dmwit> dminuoso: I think what they're getting at is: maybe getLine shouldn't return different results. But it's okay for unsafeInterleaveIO getLine to return different results.
08:24:13 <kuribas> dminuoso: it could generate random strings without breaking purity
08:24:32 <dminuoso> kuribas: That's completely besides the point.
08:24:50 <dmwit> Is it?
08:25:00 <dminuoso> Well it seems like a straw man argument to me.
08:25:13 <dminuoso> To state like "Its fine that this misbehaves strange, because IO actions dont need to be pure"
08:25:50 <ski> (s/dont need to be pure/doesn't need to have deterministic effects/)
08:25:52 <kuribas> dminuoso: no, that's the whole point
08:26:15 <dminuoso> kuribas: If you just expect the world to be random and chaotic anyway, why care about any program properties?
08:26:41 <dminuoso> kuribas: I for one would like to assume that getLine will give be deterministic behavior, as specified by my operating systems semantic.
08:26:50 <dmwit> But we're *not executing getLine*.
08:27:10 <dmwit> Precision: the action we're executing is not getLine.
08:27:43 <dminuoso> Well fine, its hGetContents 
08:27:49 <kuribas> dminuoso: so a function that would randomize the return value of getLine would be breaking purity?
08:27:52 <dmwit> There's no law that says `f getLine = getLine`. So certainly we don't need to expect that `unsafeInterleaveIO getLine = getLine`.
08:27:59 <dminuoso> kuribas: hGetContents is not randomized.
08:28:07 <dminuoso> kuribas: hGetContents behaves very predictably.
08:28:08 <dmwit> dminuoso: Nah, I'm not even quibbling about getLine vs. hGetContents.
08:28:14 <kuribas> dminuoso: apparently not
08:28:30 <dminuoso> kuribas: And the reason why its not, that's the core issue.
08:28:46 <kuribas> dminuoso: indeed, but it has nothing to do with purity
08:29:24 <dminuoso> f1 e1 e2 = e1 `seq` e2 `seq` e1 - e2
08:29:26 <dminuoso> f2 e1 e2 = e2 `seq` e1 `seq` e1 - e2
08:29:36 <dminuoso> kuribas: ^- assuming their arguments are never bottom, would you agree that they should always agree on the result?
08:29:40 <dminuoso> In a pure world.
08:29:59 <kuribas> yes
08:30:00 * hackage servant-errors 0.1.0.0 - Servant Errors wai-middlware  https://hackage.haskell.org/package/servant-errors-0.1.0.0 (epicallan)
08:30:09 <kuribas> dminuoso: for the same e1 and e2
08:30:12 <dminuoso> Yup!
08:30:30 <dminuoso> kuribas: There we go. In the presence of unsafeInterleaveIO they dont.
08:30:30 <kuribas> dminuoso: but (1, 2) and (2, 1) aren't the same
08:30:37 <dminuoso> kuribas: But that's not what we supply.
08:30:44 <dminuoso> We supply (read_int s1) (read_int s2)
08:30:47 <dminuoso> Each time.
08:30:51 <dminuoso> It's the same arguments.
08:31:20 <dminuoso> Give them names x and y if you prefer, then you get `f1 x y` and `f2 x y` will produce different results.
08:32:12 <ski> `liftA2 (,) (unsafeInterleaveIO getLine) (unsafeInterleaveIO getLine)' isn't guaranteed to be equal to `liftA2 (,) getLine getLine'
08:32:15 <kuribas> dminuoso: unless I miss something important, the arguments in both runs are *not* the same
08:32:21 <dminuoso> kuribas: they are the same!
08:32:33 <dminuoso> kuribas: And thats the crux of it.
08:32:56 <kuribas> dminuoso: you are mistaken
08:33:00 * hackage generics-mrsop 2.2.0 - Generic Programming with Mutually Recursive Sums of Products.  https://hackage.haskell.org/package/generics-mrsop-2.2.0 (vcmiraldo)
08:33:00 <ski> (the former is allowed to give different pairs, on different runs, assuming same `stdIn')
08:34:02 <dminuoso> kuribas: If Im mistaken, then this program will consistently give you the same output. Run it.
08:34:17 <dminuoso> kuribas: If Im right, then f1 and f2 will behave differently. Their arguments *are* the same
08:34:28 * ski thinks kuribas is simply attributing the "blame" in a different place
08:34:38 <dminuoso> kuribas: https://gist.github.com/dminuoso/223f6a92a5a810da01097c71f77e17da I lined them up for you
08:34:43 <dminuoso> The arguments are *the* *same*
08:35:28 <ski> i think kuribas is arguing that the values of `s1' and `s2' aren't the same, in the two runs
08:36:59 <dminuoso> kuribas: The only modification you make, is changing f1 to f2. You run the, otherwise, exact same program and supply the exact same input. :-)
08:37:11 <dminuoso> kuribas: iow, refactoring f1 to f2 alters the programs behavior.
08:37:23 <dminuoso> while you agreed that f1 and f2 would agree on their result
08:37:30 <dminuoso> but you can demonstrate they dont agree on their result.
08:39:18 <kuribas> dminuoso: I cannot even run that code, as fdToHandle doesn't exist
08:39:38 <texasmynsted> Anybody compile with ghc but use hugs in their development workflow?
08:40:12 <dminuoso> kuribas: https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-IO-Handle-FD.html#v:fdToHandle
08:40:38 <dminuoso> kuribas: You could supply stdin directly, its possibly some vintage thing.
08:41:11 <kuribas> dminuoso: no, I get an error
08:42:13 <kuribas> hGetContents: illegal operation (handle is semi-closed)
08:45:24 <kuribas> dminuoso: try running this with Debug.Trace, and you'll see that the arguments are different
08:45:28 <kuribas> anyway, I have to go now
08:53:25 <dmwit> dminuoso: The text `read_int s1` in the first one is the same as the text `read_int s1` in the second one. But the value stored in `s1` in the first one is not the same as the value stored in `s1` in the second one.
08:53:30 <dmwit> So the arguments are not the same.
08:53:53 <dminuoso> dmwit: Isnt that getting into referential transparency territory though?
08:53:59 <dmwit> ski: A thought occurred to me in the shower about a feature unsafeInterleaveIO has that interleaveIO doesn't.
08:54:01 <dminuoso> dmwit: I mean I can't just replace `read_int s1` with `1`
08:54:15 <dmwit> dminuoso: So? Referential transparency doesn't promise that you can.
08:54:31 <dmwit> dminuoso: It only promises that you can replace `read_int` with `\e1 e2 -> ...`.
08:54:59 <dminuoso> dmwit: well fine, but the arguments are still the same as far as a haskell user can tell.
08:55:00 <dmwit> ski: In a single-threaded world, unsafeInterleaveIO requires less synchronization.
08:55:10 <dminuoso> if `x` is not the same as `x`, then this is a silly discussion
08:55:37 <dmwit> ski: In replicateM 2 (unsafeInterleaveIO getLine), you'll definitely get the contents of two different lines.
08:55:53 <dmwit> ski: But in replicateM 2 (interleaveIO getLine), you might get characters from one line mixed with characters from another line.
08:56:17 <dmwit> dminuoso: If I run the program `s1 <- readFile "/dev/random"` twice, I don't expect the contents of s1 to be the same in the two runs.
08:56:40 <dmwit> dminuoso: Do you object that it's silly that s1 is not the same as s1?
08:57:22 <dminuoso> dmwit: Surely not. But if I do `s1 <- readFile "/home/dminuoso/myFile"` and guarantee that myFile doesn't change, ignoring possible bugs, I expect `s1` to remain the same.
08:57:47 <dmwit> dminuoso: But you don't object that this is a problem re: purity?
08:58:05 <dmwit> dminuoso: We shouldn't name it "unsafeReadFile" because of this?
08:58:43 <ski> dmwit : mhm
08:59:48 <dminuoso> dmwit: If I refactor a pure function with one that is extensionally equal to the former function, this should not alter my program. Should it?
09:00:00 <dminuoso> (Apart from runtime characteristics, which we shall ignore for the sake of discussion)
09:00:29 <dmwit> Now *that* is a much better argument. One I myself made. But it's not the argument kuribas was (rightly) objecting to.
09:01:25 <dminuoso> dmwit: Perhaps I didn't fully understand their core objection. Why would you say "rightly" in that?
09:01:59 <dmwit> Because the property under attack here is not what most people refer to as "purity".
09:02:00 * hackage servant-errors 0.1.0.1 - Servant Errors wai-middlware  https://hackage.haskell.org/package/servant-errors-0.1.0.1 (epicallan)
09:08:38 <Zemyla> Hmm, a fingertree could be a free applicative.
09:09:48 <Zemyla> @let data FNode v f a where { FNode2 :: !v -> (x -> y -> a) -> f x -> f y -> FNode v f a; FNode3 :: !v -> (x -> y -> z -> a) -> f x -> f y -> f z -> FNode v f a }
09:09:50 <lambdabot>  Defined.
09:10:45 <Zemyla> @let data FDigit f a where { FOne :: f a -> FDigit f a; FTwo :: f a -> f b -> FDigit f (a, b); FThree :: f a -> f b -> f c -> FDigit f (a, b, c); FFour :: f a -> f b -> f c -> f d -> FDigit f (a, b, c, d) }
09:10:48 <lambdabot>  Defined.
09:12:24 <d0liver> So, I keep running into situations where I need to traverse some stuff and then find or filter based on those results. I've started doing this kind of thing: `either (Just . doStuff) Nothing <$> for xs \x -> do ... return if isTheCorrectX x then Left x else Right ()` which lets me "say" if I found the thing and also hand it back, but I'm not sure if that's cool since `Left` is usually an error. amidoinitrite?
09:12:53 <Zemyla> @let data FTree v f a where { FEmpty :: a -> FTree v f a; FSingle :: (x -> a) -> f x -> FTree v f a; FDeep :: !v -> (x -> y -> z -> a) -> !(FDigit f x) -> FTree v (FNode v f) y -> !(FDigit f z) -> FTree v f a }
09:12:55 <lambdabot>  Defined.
09:13:30 <Zemyla> @let class Monoid v => MeasuredF f v | f -> v where measureF :: f a -> v
09:13:31 <lambdabot>  Defined.
09:14:17 <Zemyla> @let instance Monoid v => MeasuredF (FNode v f) v where { measureF (FNode2 v _ _) = v; measureF (FNode3 v _ _ _) = v }
09:14:18 <lambdabot>  .L.hs:254:19: error:
09:14:18 <lambdabot>      • The constructor ‘FNode2’ should have 4 arguments, but has been given 3
09:14:18 <lambdabot>      • In the pattern: FNode2 v _ _
09:15:03 <Zemyla> But yeah, could a fingertree in this style be a free applicative with O(lg n) liftA2?
09:16:29 <dminuoso> dmwit: Is there a better term for it?
09:17:18 <dminuoso> Isn't one handwaving way to define purity the ability to refactor with extensionally equivalent code?
09:17:59 <EvanR> i think there's a sliding scale on purity where you decide how much of the differences of your circumstances "don't matter"
09:19:07 <EvanR> resource usage, termination, probability of termination based on the machine, whether two different actual values can be considered equal for your purposes
09:19:21 <dmwit> d0liver: Seems fine to me.
09:19:28 <dmwit> dminuoso: I don't know of a better term for it.
09:19:55 <EvanR> whether the side effects it causes "matter"
09:20:34 <EvanR> computing a pure function at least causes the machine to detectably heat up
09:21:25 <dminuoso> EvanR: Well you could constrain yourself from what you can realistically measure. Since Haskell doesn't give you access to measuring heat of your computer itself..
09:21:44 <EvanR> haskell doesn't give you a way to detect if an email arrives at a destination either
09:21:45 <dminuoso> But sure, there's definitely such a slider.
09:22:23 <EvanR> but if the client was instead of waiting for email they could be at the CPU with a thermometer
09:22:37 <EvanR> (CPU does give you access to these temperature readings)
09:23:52 <EvanR> the question isn't whether you can somehow detect effects, but whether you choose to ignore them. Dumping of logs onto a disk, you could potentially ignore this
09:24:08 <dminuoso> EvanR: Well let's take the CPU case then still. As long as you remain outside of IO, the fact that your CPU heats up has no influence on whether your pure computations remain deterministic.
09:24:29 <dminuoso> For the sake of discussion I have to assume I have infinite memory though. :p
09:24:34 <EvanR> that's is exactly the kind of statement that requires "ignoring things"
09:24:45 <EvanR> too much heat and the CPU shuts off
09:24:57 <EvanR> if it didn't no more deterministic computation
09:25:45 <EvanR> you might even get unlucky at you see a wrong answer right before it emergency shuts off
09:27:06 <EvanR> "ignoring things" = "operating at a certain level of abstraction" (sounds better at a conference)
09:29:04 <nshepperd2> Isn't purity the reason hGetContents semi-closes its handle?
09:29:30 * hackage birch-beer 0.2.0.0 - Plot a colorful tree.  https://hackage.haskell.org/package/birch-beer-0.2.0.0 (GregorySchwartz)
09:29:42 <nshepperd2> To prevent you from foolishly running it twice on the same handle
09:31:43 <nshepperd2> Within hGetContents itself it enforces an order of execution so it doesn't matter your evaluation order as long as nothing else is messing with the same fd
09:32:44 <dminuoso> nshepperd2: Well sure, so hGetContents has additional bits to try and hide that the underlying unsafeInterleaveIO can have nasty effects.
09:32:51 <EvanR> yeah, this is where purity must survive a flame test
09:33:21 <EvanR> values that do IO 'later' can still be pure
09:33:52 <EvanR> or values whose value depends on IO later
09:34:01 <dminuoso> Is it fair to say that if its safe to unsafePerformIO, then its definitely safe to unsafeInterleaveIO?
09:34:32 <nshepperd2> Seems likely
09:36:01 <nshepperd2> I wouldn't consider unsafePerformIO 'safe' if it was unsafe to write return . unsafePerformIO
09:37:55 <dminuoso> nshepperd2: s/ unsafe / safe / ?
09:38:57 <glguy> dmj`: When I try and nix-build the config-app it dies trying to build happy-1.19.12. Did that happen to you, too?
09:40:35 <nshepperd2> These bits in hGetContents strike me as a similar sort of care as that required to make sure using unsafePerformIO is safe
09:41:04 <nshepperd2> dminuoso: no i think i got the double negative the right away around there
09:41:38 <dminuoso> nshepperd2: I think you lost me there.
09:41:54 <dminuoso> nshepperd2: You mean *unsafeInterleaveIO
09:42:15 <dminuoso> nshepperd2: https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.IO.Handle.Text.html#lazyRead
09:42:58 <nshepperd2> In terms of safeness in any given situation, it seems to me that unsafePerformIO <= return . unsafePerformIO <= unsafeInterleaveIO
09:53:22 <dminuoso> nshepperd2: what does <= denote there?
09:53:40 <dminuoso> Is that a "equal-or-less"
09:54:00 <nshepperd2> 'a <= b' a is less safe than b
09:54:17 <nshepperd2> less or equal, rather
09:54:38 <dminuoso> nshepperd2: In what sense is `return . unsafePerformIO` any safer than just unsafePerformIO?
09:54:58 <nshepperd2> Or, safeness of a entails safeness of b
09:56:26 <nshepperd2> You can write unsafeCoerce using unsafePerformIO, but not using return . unsafePerformIO
10:00:46 <solonarv> is that return @IO, or a polymorphic return?
10:00:54 <nshepperd2> unsafeCoerce a = unsafePerformIO (let ref = unsafePerformIO newEmptyMVar in putMvar ref a >> takeMVar ref)
10:01:15 <nshepperd2> I meant return @IO, yeah
10:05:30 * hackage servant-errors 0.1.0.2 - Servant Errors wai-middlware  https://hackage.haskell.org/package/servant-errors-0.1.0.2 (epicallan)
10:11:30 * hackage too-many-cells 0.2.0.0 - Cluster single cells and analyze cell clade relationships.  https://hackage.haskell.org/package/too-many-cells-0.2.0.0 (GregorySchwartz)
10:23:30 * hackage primitive-convenience 0.1 - convenience class for PrimMonad m/PrimState m  https://hackage.haskell.org/package/primitive-convenience-0.1 (chessai)
11:01:08 <dmwit> (or, another way: "safe" means "safe in any context". `return _` is a context. Therefore if `unsafePerformIO foo` is safe, then surely `return (unsafePerformIO foo)` is safe.)
11:01:58 <dmwit> (in b4 niggles about contexts needing to be well-typed or something)
11:02:00 * hackage ihaskell 0.10.0.2 - A Haskell backend kernel for the IPython project.  https://hackage.haskell.org/package/ihaskell-0.10.0.2 (VaibhavSagar)
11:06:43 <EvanR> safe is defined as safe in any context, i can by this using theory of fixed points
11:06:57 <EvanR> safe begins as undefined
11:07:22 <EvanR> undefined in any context, (undefined in any context) in any context, ...
11:08:00 <EvanR> this is your brain on haskell
11:11:13 <dmwit> I do not take "safe in any context" as a definition. It is only a property of safety.
11:11:45 <dmwit> (x + y) + z = x + (y + z) is not a definition of addition.
11:13:48 <EvanR> Safe x -> (ctx:Context) -> SafeInContext x ctx
11:17:01 <rsoeldner_> Hi, I struggle using `hxt` for parsing XML files. https://gist.github.com/rsoeldner/4291874a72325b7d6f81d516e3fe9e56 when commenting out the second entry `isElem >>> hasName "DisplayName"` I get a result, otherwise the empty list. When I use `deep (isElem ...)` it will traverse the entire document not just the block ...
11:24:14 <anirban> Hi, I am getting non-exhaustive patterns in substring
11:24:16 <anirban> https://gist.github.com/anirban-metal/3480a54232b7e94f039742f591e61e38
11:24:46 <dmwit> anirban: you lost a b
11:24:48 <dmwit> sustring
11:24:56 <dmwit> -Wall will catch this
11:25:20 <anirban> Okay, I will try that
11:25:45 <anirban> -Wall sometimes is saying I missed _ (_:_)
11:25:56 <anirban> Or says nothing sometimes but complains at runtime
11:29:13 <anirban> Okay, thanks
11:29:15 <anirban> solved now
11:29:39 <toblorone> Is it just me or can pattern matching get pretty annoying sometimes? If I have a data type with more than say 5 fields, adding or reordering the fields in the definition requires me to make changes through out my entire codebase to reflect this
11:32:24 <NemesisD> is there a good heuristic as to when to use Data.HashMap.Strict over Data.Map.Strict? I've been under the impression that Data.Map.Strict has better lookup performance when you're sure the map size is pretty small, but for larger or possibly unbounded maps, Data.HashMap.Strict's O(1) lookup tends to be faster.
11:32:40 <tdammers> toblorone: true. that's when you use record syntax.
11:33:32 <toblorone> tdammers: which is also severely lacking :(
11:33:37 <merijn> NemesisD: The heuristic is Data.Map until proven insufficient
11:45:02 <tdammers> toblorone: it does solve this particular problem though
11:48:11 <toblorone> tdammers: sometimes, even when using record syntax, you need to pattern match on the constructor. Is there a way to do that while avoiding the problems with modifying the definition later on? eg: I have two constructors, both takes 20 arguments. I suppose i could write a helper function isFoo and if there is a change, only have to modify that...
11:49:23 <merijn> toblorone: You can use record syntax to match constructors without caring about the arguments
11:49:34 <monochrom> The problem with anticipating change is you always risk having the wrong anticipation.
11:49:37 <merijn> toblorone: In fact, this even works for non-record datatypes!
11:49:54 <toblorone> merijn: could i see an example?
11:50:04 <ski> > case Node () [] of Node {} -> ()
11:50:06 <merijn> > [x | x@Left{} <- [Left 'c', Right True, Left 'a', Right False]]
11:50:06 <lambdabot>  ()
11:50:08 <lambdabot>  [Left 'c',Left 'a']
11:50:50 <ski> % case Node () [] of Node {..} -> ()
11:50:50 <yahb> ski: ()
11:51:01 * ski likes that better
11:51:06 <syd> Does anyone have any pointers for an openapi3 library?
11:51:39 <monochrom> "{..}" requires an extension
11:51:54 <toblorone> ah, so "foo x@MyComplicatedType{} = ..."
11:52:13 <merijn> toblorone: Yeah
11:52:25 <merijn> monochrom: Also brittler, since .. may bring new names in scope if you refactor
11:52:38 <monochrom> yeah
12:13:08 <whadevah> Good day! if I get it correctly any hom-functor `C(a, -)` wholly defines the category in Set, and what's more - every other functor is determined by our `C(a, -)`. As was shown here https://youtu.be/BiWqNdtptDI?t=422 .But I don't buy it, and the Yoneda lemma didn't show this at all. It just specified that if there exists a natural transformation
12:13:08 <whadevah> between hom-functor and some other functor and there is a morphism from `a` to any other object in our initial category, then there should also exist a unique object in our functor which represents our morphism. But what if we had some big-big category with a terminal object, and our terminal object didn't have any morhisms except an identity? I
12:13:09 <whadevah> don't see how such a small hom-functor with just one object in it can define all functors which may exist from our whole big-big category into Set.  Where am I wrong? Or did I miss something?
12:15:09 <monochrom> I thought the premise was locally small, not big big.
12:16:06 <whadevah> By that I just meant that there also exist other morphisms which our terminal object does not cover 
12:25:02 <whadevah> If we had a category like `a -> b -> c` then hom-set C(b, -) would only cover half of our morphisms. But totality implies all of them, no? 
12:27:36 <higherorder> https://www.irccloud.com/pastebin/iDY3L7sd/
12:28:30 <higherorder> the second instance is wrong; it should just be `unwrap (MkB x) = x`
12:28:38 <monochrom> What is the error message?
12:29:40 <higherorder> monochrom: something about having to turn on IncoherentInstances
12:30:19 <higherorder> and if I do turn them on, ` Reduction stack overflow; size = 201`
12:30:27 <monochrom> Maybe it is really incoherent.
12:30:31 <higherorder> monochrom: https://repl.it/@HenriMaurer/ScornfulAlivePercent
12:30:35 <higherorder> this is the repl.it 
12:37:50 <tabaqui2> data SomeType (k :: Int)
12:38:12 <tabaqui2> can I express on type level a function that take a number and returns SomeType "number"?
12:38:30 <tabaqui2> like "f :: *; f 1 -> SomeType 1; f 2 -> SomeType 2..."
12:39:35 <tabaqui2> f :: (n :: Int) => n -> SomeType n, I dunno
12:42:09 <monochrom> Maybe take a look at what's available in GHC.TypeNats?
12:44:53 <tabaqui2> I would like to do it without Data.Type.Equality
12:45:13 <tabaqui2> I see that this modules uses TypeFamilies, but cannot understand where are type instances
12:45:40 <monochrom> The compiler coughs up instances.
12:47:32 <tabaqui2> it looks like I'm trying to add dependent types in my code
12:47:34 <tabaqui2> I'm not sure
12:48:42 <tabaqui2> Actually I want [Char] to be the kind of SomeTypes
12:55:19 <jle`> tabaqui2: taken at the most literal level, you want some sort of reification, which can be done in haskell with some form of existential type
12:55:31 <jle`> tabaqui2: but at the higher level i want to ask 'why do you want to do this' heh
12:56:17 <tabaqui2> well, I could tell you a long story
12:56:19 <jle`> but yeah this function is `someNatVal` literally
12:56:30 <jle`> it lifts a Natural to the type level in an existential type
12:56:50 <jle`> the thing is that your type signature can't have the type nakedly, but you essentially want Natural -> (exists n. SomeType n)
12:57:04 <jle`> the best we can do is hide the exists in a data type, or with some sort of rankn continutionat
12:57:59 <tabaqui2> I have some State wrapper to work with filesystem
12:58:30 <tabaqui2> it has some root directory and a bunch of homogeneous subdirecties
12:58:59 <tabaqui2> and I want to allow some file operations only with root directory, some only with nested ones
12:59:25 <tabaqui2> like newtype FileSystemT (p :: Maybe FilePath) m a = FS (StateT ...)
13:00:26 <tabaqui2> and requested function is actually some "goNested :: FilePath -> FileSystemT 'Nothing m a -> FileSystemT (Just p) m a"
13:01:36 <tabaqui2> I understand that I cannot write function with exactly behavior, but "withNested :: (a -> b) -> FilePath -> Fi..." would be ok, too
13:01:52 <crestfallen> hello I believe lukewarmly that my trace is correct. please confirm or deny http://termbin.com/7q9c
13:04:33 <tabaqui2> crestfallen: why do you think that "(ff . gg) () => ff (gg (\_ _ -> ()) ()"?
13:05:03 <tabaqui2> and the next implication is doubtful too
13:06:20 <tabaqui2> (ff . gg) () = ff (gg ()) = (1. (), because of f _ = ()) OR (2. ff (\_ -> ()))
13:07:19 <crestfallen> tabaqui2: thanks working on that ..
13:08:20 <tabaqui2> np
13:09:22 <crestfallen> I'm a bit confused tabaqui2. I was substituting (\_ _ -> ()) 
13:09:27 <tabaqui2> np
13:09:30 <tabaqui2> oh, sry
13:09:50 <dmj`> merijn: ping
13:10:01 <tabaqui2> crestfallen: on which string?
13:10:24 <iqubic> delimited continuations are cool
13:10:34 <iqubic> http://dpaste.com/33YC4NW
13:10:55 <crestfallen> like ff (\_ _ -> ()) ()  was what I still have in mind
13:11:21 <iqubic> The output of that function testResetShift is not what you think it is.
13:12:03 <iqubic> If you can explain why the output is what it is, then you have a strong handle on delimited continuations
13:13:07 <tabaqui2> crestfallen: it's legal, ok
13:13:24 <tabaqui2> but I don't see this line in your code
13:13:50 <crestfallen> you mean in the trace commented?
13:13:55 <tabaqui2> yeah
13:14:09 <crestfallen> ok one moment pls
13:18:05 <glguy> iqubic: You don't need the resetT, either. There's implicitly a reset at the evalContT
13:18:32 <crestfallen> tabaqui2: I was trying to follow a similar evaluation to this https://termbin.com/fttu
13:20:01 <tabaqui2> crestfallen: looks fine
13:20:31 <tabaqui2> at least, I see no fails now
13:21:31 <crestfallen> but I tried to emulate that evaluation with the first one we looked at
13:21:41 <crestfallen> the myconvertt
13:23:27 <tabaqui2> I still cannot understand your third implication
13:23:43 <shapr> dmwit: do you have org-mode babel code that lets me run a Main module from org-mode? or is ghci my only option?
13:23:51 <tabaqui2> replace the nested lambda function with gg and you'll get "ff (gg gg) ()"
13:23:59 * shapr finds credits to dmwit at https://emacs.stackexchange.com/questions/48446/haskell-code-execution-in-org-mode-give-error-but-in-hs-file-the-code-is-good-a
13:24:26 <crestfallen> I added line numbers  https://paste.ee/p/AF45D tabaqui2
13:24:31 <tabaqui2> I'm not even sure that "ff (gg (\_ _ -> ()) ()" will pass the typechecker with your signatures
13:24:55 <iqubic> glguy: Thanks.
13:25:14 <tabaqui2> just try to eval the string on line 17 inside of ghci
13:25:31 <crestfallen> ok 
13:25:45 <dmwit> shapr: I don't use emacs. I also don't know what I did to be worth giving credit. I could look through my logs if it really seemed important to you.
13:27:08 <shapr> dmwit: no worries
13:27:12 <dmwit> shapr: Just googling, perhaps https://stackoverflow.com/q/42081379/791604 or one of the things it links to is helpful to you?
13:27:26 <shapr> dmwit: ooh, thanks!
13:31:12 <merijn> dmj`: pong?
13:32:32 <dmj`> merijn: remember that memory leak I had
13:32:47 <crestfallen> tabaqui2: well it looks like the evaluation is much different from the other one I showed you..
13:32:55 <crestfallen> but I don't know what it looks like
13:32:57 <merijn> dmj`: Vaguely :p
13:33:27 <tabaqui2> crestfallen: (f . g) x = f (g x)
13:33:54 <tabaqui2> and go on
13:34:25 <crestfallen> so that's ff (gg ()) 
13:37:00 <lavalike> @src (.)
13:37:00 <lambdabot> (f . g) x = f (g x)
13:38:30 * hackage servant-errors 0.1.0.3 - Servant Errors wai-middlware  https://hackage.haskell.org/package/servant-errors-0.1.0.3 (epicallan)
13:39:39 <dmj`> merijn: so, I thought the haskell process was causing the entire machine to run out of memory
13:39:54 <dmj`> merijn: I ran with -M1G expecting it to OOM, but it never did.
13:40:07 <dmj`> merijn: yet the entire machine ended up running out of memory
13:40:15 <shapr> conal: really enjoying reading Compiling to Categories, but my mind is repeatedly blown. I'll tell you how the talk goes in an hour or so!
13:40:57 <dmj`> merijn: the haskell process eventually died, but due to the OS killing it (as shown in dmesg), or the GHC RTS would complain it couldn't commit more memory (malloc failed) since the machine ran out of memory.
13:41:53 <glguy> dmj`: When I try and nix-build the config-app it dies trying to build happy-1.19.12. Did that happen to you, too?
13:41:56 <merijn> dmj`: But it was something else running the machine out of memory? ;)
13:44:51 <crestfallen> termbin.com/rqpo    but this could nt be the entire eval right lavalike  tabaqui2
13:45:30 <tabaqui2> why not?
13:46:13 <tabaqui2> ff _ = (), so the last implication is legal
13:46:43 <crestfallen> because of the second wildcard in gg which is the a in     () -> a -> ()
13:47:32 <crestfallen> that parameter is left without an argument then? tabaqui2
13:47:34 <dmj`> glguy: yea, it did. I need to fix that. I can make a new PR for this. \
13:47:44 <geekosaur> it's unused, so it's never evaluated
13:47:51 <glguy> dmj`: I loosened the happy version constraint on config-value
13:48:00 <dmj`> glguy: that might just fix it
13:48:39 <tabaqui2> crestfallen: geekosaur is right, if you have "f _ = ()" then "f (some monstrous, probably looped inifinite expression) = ()" still
13:48:56 <dmj`> glguy: bumping the `rev = ` on the `config-value` source might cause the derivation to build, if not I can fix it after work
13:49:00 <tabaqui2> in lazy language, ofc
13:49:38 <glguy> dmj`: how do you compute new revs?
13:49:43 <geekosaur> > let f _ = () in f (error "boo!")
13:49:46 <lambdabot>  ()
13:51:03 <crestfallen> geekosaur: thanks I see. that is surprising tabaqui2 actually. so that is laziness . so there is yet another fundamental item I didn't understand. the a in the type signature can go unused.
13:51:04 <glguy> OH, it's a git commit hash
13:51:50 <crestfallen> meaning () -> a -> ()
13:53:03 <dmj`> glguy: I just change the existing rev, re-run `nix-build`, then it will fail with the wrong hash, but tell you the right one
13:53:10 <tabaqui2> sort of, you force the evaluation when asking the ghci to print the result, but the argument of 'f' doesn't affect the answer so ghci has no need to evaluate it too
13:53:32 <tabaqui2> > let f = error "boo"
13:53:35 <lambdabot>  <no location info>: error: not an expression: ‘let f = error "boo"’
13:53:40 <glguy> dmj`: It looks like ghcjs+nix just can't build happy 1.19.12
13:53:45 <glguy> but I don't know why its trying to
13:53:46 <tabaqui2> % let f = error "boo"
13:53:46 <yahb> tabaqui2: 
13:53:52 <tabaqui2> it's ok, not problem
13:54:11 <tabaqui2> but if you try to print the 'f', then ghci will fail here
13:54:13 <tabaqui2> % print f
13:54:13 <yahb> tabaqui2: *** Exception: boo; CallStack (from HasCallStack):; error, called at <interactive>:45:9 in interactive:Ghci12
13:55:16 <tabaqui2> (of course, there are more ways to force evaluation)
13:55:35 <tabaqui2> you can read about Normal Form, Weak Normal Form and others
13:55:56 <dmj`> glguy: hmm, you might have to use the haskellPackages.happy version, it might be trying to add haskell.packages.ghcjs86.happy, I think you might be able to compile happy with ghcjs though ... but sounds like a bad idea
13:56:17 <crestfallen> tabaqui2:   ...
13:57:43 <dmj`> glguy: you can definitely compile happy with ghcjs, I def. have run alex + happy on the client
13:57:52 <dmj`> but the derivation for it on ghcjs86 might be broken
13:58:07 <glguy> How am I supposed to build this? `nix-build` ?
13:58:10 <glguy> any arguments?
13:59:25 * dmj` checks repo
13:59:41 <crestfallen> tbh I don't understand the point of this exercise tabaqui2 and why gg is written (\_ _ -> ())
14:00:10 <tabaqui2> because of currying
14:00:13 <dmj`> glguy: yea, `nix-build` will build both client and server and combine the artifacts into a resultant derivation
14:01:06 <tabaqui2> I need to go now
14:01:08 * tabaqui2 is out
14:01:12 <crestfallen> thanks!
14:02:51 <iqubic> How does one compile and test a Brick application with Nix?
14:05:45 <iqubic> Actually, that's not what I want to know. The Brick docs say this: "Brick applications must be compiled with the threaded RTS using the GHC '-threaded' option." How do I set compiler flags in a *.cabal file?
14:06:20 <dmj`> iqubic: ghc-options: -threaded -rtsopts
14:06:49 <iqubic> It was an xy problem, but I quickly realized that and switched to stating the real question.
14:06:53 <glguy> dmj`: When I change the revisions nix-build doesn't appear to notice. Is there a command that refreshes a github clone cache?
14:07:58 <dmj`> glguy: ah, this is because nix is dumb and if you have source cached locally at a hash, it will always fetch from that sha256, even if the rev has changed. The solution for this is to change the sha256 by one character
14:08:12 <dmj`> then nix will complain and give you the correct hash
14:10:53 <iqubic> Where does 'cabal build' place the output executable?
14:11:24 <dmj`> glguy: there's also a lot of helper functions that let you do things like jailbreak the version bounds on a package if it doesn't build, especially useful for ghcjs packages, since stackage curation process doesn't cover them. 
14:11:28 <dmj`> https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/haskell-modules/lib.nix
14:11:35 <merijn> iqubic: Depends whether you have cabal-install 2.x or 3.0
14:11:58 <iqubic> I see.
14:15:07 <iqubic> Looks like I have 3.0
14:16:24 <merijn> iqubic: Then the answer is "somewhere nested deeply under dist-newstyle"
14:16:38 <merijn> iqubic: But also, the real answer is: Do you maybe want "cabal run"?
14:16:56 <chesscipher> any of you tried to install stack on openbsd? I get this result: https://github.com/commercialhaskell/stack/issues/3313#issuecomment-534982429
14:17:56 <merijn> chesscipher: Looks like broken version bounds
14:18:32 <merijn> Which, given that most of stack users doesn't believe in upperbounds seems unsurprising
14:18:40 <chesscipher> merijn: so how should I do it? compile the new ghc version first and then compile stack?
14:20:24 <merijn> chesscipher: The problem is that you're trying to use cabal-install to build stack (which has a solver that tries to find compatible dependencies) unfortunately, large parts of the stack ecosystem don't believe in setting upperbounds, so cabal-install will find build plans that don't actually work if a new version changed compatibility
14:21:04 <merijn> chesscipher: For example, Text now defines it's own Lift instance, but mustache defines one to, the lack of upperbound means it tries to build mustache against a version of Text that's not compatible
14:21:40 <merijn> So the only solution is "fix the wrong version bounds so cabal finds an *actual* build plan"
14:22:05 <glguy> or avoid the unmaintained package
14:23:03 <Squarism> anyone worked with proto-lens (the google protobuf library for haskell). I wonder if theres some way of accessing the metadata of the defined .proto types?
14:23:16 <merijn> glguy: Well, packages in stackage may not be unmaintained, but just have broken bounds for ideological reasons...
14:23:19 <iqubic> merijn: Looking at the docs, I can tell that I do want cabal run instead.
14:23:20 <chesscipher> merijn, merijn:urr, I got a friend who suggested me stack, tho what are sane alternavitves?
14:23:38 <glguy> merijn: not maintaining your package for ideological reasons is still not maintaining it
14:23:39 <Squarism> Like "what fields does my XYZ message have"
14:23:53 <merijn> chesscipher: Well, since you seem to have a working GHC and working cabal-install, seems like you already have all you need? :)
14:24:55 <chesscipher> merijn: uhm, I should learn them
14:25:51 <monochrom> What benefit would stack bring you, and at what cost?
14:31:00 * hackage haskseg 0.1.0.3 - Simple unsupervised segmentation model  https://hackage.haskell.org/package/haskseg-0.1.0.3 (TomLippincott)
14:31:17 <conal> shapr: good luck!
14:33:16 <dmj`> merijn: because they refuse to adhere to PVP ?
14:33:41 <merijn> dmj`: Yes
14:37:47 <dmj`> we should just share functions and data types
14:40:39 <monochrom> I also want to share classes and instances. Is that OK?
14:43:20 <dmj`> yea, that's fine
14:51:26 <freeman42x> does Miso have any EDSL / preprocessor / transpiler for Haskell to CSS / HTML ?
14:52:09 <Squarism> Is there some nice way of listing all fields of a field record constructor?
14:52:40 <merijn> Squarism: What price are you willing to pay? ;)
14:52:50 <glguy> You can use Template Haskell or GHC.Generics or Data.Generics
14:52:57 <Squarism> 2h?
14:53:11 <Squarism> thanks!
14:53:14 <merijn> Squarism: I meant wrt your eternal soul ;)
14:53:36 <merijn> blood sacrifices, loss of sanity, that sorta thing
14:53:55 <Squarism> You allways end up there anyway =D
14:54:05 <Squarism> Or I..
14:54:10 <glguy> dmj`: Success! https://glguy.net/config-demo/
14:54:49 <dmj`> glguy: Woa :)
14:55:06 <dmj`> glguy: coming to you now for all my nix questions hah
14:55:18 <dmj`> Looks great !
14:58:01 <monochrom> glguy: I saw a typo in the config-schema description: "This package makes it possible to defined schemas for"
14:59:05 <glguy> patched
14:59:48 <monochrom> there is also something in the 2nd sentence "can be used to be process a configuration file"
16:05:30 * hackage mini-egison 0.1.1 - Template Haskell Implementation of Egison Pattern Matching  https://hackage.haskell.org/package/mini-egison-0.1.1 (SatoshiEgi)
16:15:54 <shapr> conal: it went well! I showed the shiny pictures from the slides you made, and I went over the paper intro in more detail. Got about ten people excited about learning CT superpowers!
16:16:23 <conal> shapr: :D ! Thanks for the report. 
16:16:33 <conal> shapr: and congrats on the presentation.
16:18:14 <conal> shapr: it was a huge revelation to me that functional programming is about much more than computable functions, in a powerful and practical sense. 
16:18:48 <EvanR> i want to see slides :(
16:19:14 <shapr> EvanR: https://github.com/conal/2017-talk-teaching-new-tricks-to-old-programs/blob/master/README.md
16:19:17 <EvanR> nice
16:19:19 <shapr> and also http://conal.net/papers/compiling-to-categories/
16:19:47 <conal> shapr: i learned of the equivalence between the simply typed lambda calculus and cartesian closed categories in the early 80s, but it took me about 20 years to realize how useful that equivalence is.
16:20:11 <conal> oops -- make that 30 years!
16:20:31 <shapr> conal: we're getting older
16:20:50 <conal> shapr: yeah --- weird!
16:20:55 <shapr> conal: I met you thirteen years ago! *shock*
16:22:03 <conal> shapr: not longer ago, like paris icfp 1999?
16:22:30 * hackage email-validate 2.3.2.12 - Email address validation  https://hackage.haskell.org/package/email-validate-2.3.2.12 (GeorgePollard)
16:22:59 <shapr> conal: I got into Haskell in late 1999, my first conference was ICFP 2006 (if you don't count EuroHaskell 2003 or AngloHaskell 2005 )
16:23:44 <shapr> conal: how'd you get started with category theory?
16:23:47 <conal> shapr: oh. hm. scrambled memories i guess.
16:24:46 <shapr> We have a Learn Category Theory twice a week meeting at recurse center right now, but we haven't settled on which book(s) we might want to use or any of that stuff.
16:25:16 <shapr> after what I've heard from topos I want to try emily riehl's book
16:25:31 <conal> shapr: i guess i got into category theory when i realized that one can describe circuits in the language of CT, which led to compiling haskell to hardware, which was my job. i knew the answer was much bigger than the specific question i'd been trying to answer.
16:27:10 <shapr> conal: do you have a particular text you'd suggest for learning CT?
16:28:20 <conal> shapr: i've been haphazard about my CT learning. i have a few unfinished sources, including Awodey. 
16:30:47 <shapr> I shall look up Awodey
16:31:38 <conal> shapr: besides Awodey's book, there's a video series of his lectures at the Oregon summer school.
16:34:04 * shapr discovers the series on youtube
16:35:48 <shapr> conal: thanks, I may send you a bunch of CT questions at some point, but I'll do my best to ask good questions and not waste your time :-)
16:36:35 <conal> shapr: you bet. there's also a lot of CT chat in the functionalprogramming slack.
16:37:00 <conal> shapr: have fun! maybe you'll get interested in playing with and helping with compiling-to-categories
16:38:49 <cal[m]> very quick question: is there a way to display a function's parameters with perhaps a small description of what it does in ghci?
16:41:00 <shapr> cal[m]: I use hoogle -il to do that
16:41:55 <shapr> cal[m]: cabal install hoogle && hoogle generate && hoogle -i unfoldr
16:51:37 <cal[m]> shapr: ah it is a platform, i should have guessed
16:51:38 <cal[m]> you're the bomb, thank you
16:52:30 * shapr explodes
16:52:57 <cal[m]> :>
16:53:02 <cal[m]> have you been doing this for long?
16:53:28 <shapr> cal[m]: not as long as many other people on this channel!
16:53:47 <cal[m]> ahh don't sell yourself short
16:54:07 <cal[m]> if you don't mind my asking: what was your motivation for learning about haskell?
16:54:55 <shapr> cal[m]: I'd learned Python and elisp, and I was trying to find something closer to my favorite parts of both.
16:55:12 <shapr> cal[m]: what was your motivation for learning about Haskell?
16:55:14 <iqubic> Those are great languages.
16:55:29 <shapr> iqubic: I agree!
16:55:40 <iqubic> shapr: Do you use emacs for Haskell code editor?
16:56:03 <rotaerk> but ... python is dynamically typed D-:
16:56:17 <iqubic> So is Elisp?
16:56:32 <rotaerk> oh no!
16:57:23 <cal[m]> !
16:57:35 <shapr> iqubic: I do use emacs for my Haskell code editor.
16:58:11 <iqubic> What emacs packages do you use for editing Haskell code?
16:58:45 <cal[m]> shapr: uh, that's a good question.. i'm actually just getting into it. i started because a friend that i really admire was doing it for his university, but i've since planned some projects around it. i take it you enjoy the language then?
16:59:31 <shapr> yup, I'm building a research paper annotation tool in Haskell, as a local web app.
17:01:52 <shapr> If nobody else uses my annotation tool, that's fine by me, but I will use it!
17:02:31 <shapr> cal[m]: are you building a cool thing?
17:04:01 <iqubic> shapr: Can you tell me what emacs packages you are using to edit Haskell code in emacs?
17:04:04 <iqubic> I'd love that.
17:04:05 <topos> conal elliott?
17:04:23 <shapr> likely
17:04:42 <cal[m]> that's amazing
17:04:44 <cal[m]> you're amazing thanks
17:04:45 <topos> shapr btw I'd be happy to come continue my current CT group @ recurse if you want someone to lead
17:04:49 <conal> topos: howdy
17:04:56 <topos> hola we met at ICFP! how are you
17:05:21 <cal[m]> shapr: when do i get to star your project :^)
17:05:51 <shapr> cal[m]: before halloween or never!
17:06:47 <conal> topos: great. nice to run into you again!
17:07:00 * hackage debug-me 1.20190926 - secure remote debugging  https://hackage.haskell.org/package/debug-me-1.20190926 (JoeyHess)
17:07:47 <conal> topos: remind me what we talked about? (trying to connect face/name/alias)
17:08:21 <topos> emily, 6' tall, random bs
17:08:41 <topos> it wasn't for very long, I don't blame you LOL
17:09:04 <topos> used to go by emilypi
17:10:39 <conal> topos: :)
17:11:22 <koz_> topos: Are you _this_ former emilypi? https://twitter.com/emi1ypi
17:11:47 <shapr> the amazing, the humorous, EMILY PI!
17:11:51 * shapr throws lambda boomerangs
17:11:57 <topos> yes
17:12:02 <koz_> topos: Oh, cool.
17:12:15 <koz_> I thought your name/handle/online designator looked familiar.
17:16:07 <topos> I'm slowly moving away from that nick and fading into oblivion :)
17:21:06 <shapr> cal
17:21:12 <shapr> whoops, meant to tab complete that
17:21:28 <jackdk> shapr:  https://www.irccloud.com/pastebin/n3JfimOX/
17:21:29 <cal[m]> :>
17:22:01 <shapr> jackdk: I'm confused, is my birthday in there?
17:22:23 <jackdk> shapr: I have no idea when that is :?
17:22:28 <jackdk> :>
17:22:39 * shapr checks
17:22:44 <shapr> my birthday IS in there!
17:22:52 * shapr gets a birthday cake
17:26:05 <shapr> jackdk: september in emacs?
17:26:22 <shapr> iqubic: do you already have use-package in your emacs config?
17:26:29 <iqubic> I do.
17:28:01 <int-e> shapr: wee, 3.6 bits of information...
17:28:14 <shapr> iqubic: here's most of my config: https://gist.github.com/shapr/586fb27ec7b0c1e05c6413693af99626
17:28:31 <int-e> > (log 365 - log 30)/log 2
17:28:34 <lambdabot>  3.604862058158861
17:28:57 <int-e> > (log 365.25 - log 30)/log 2 -- or maybe this
17:29:00 <lambdabot>  3.60584986719498
17:31:23 <shapr> int-e: ohh
17:42:57 <jle`> wow we have a celebrity in #haskell :O
17:55:15 <MarcelineVQ> jle`: I'm emabrassed.
18:00:39 <pavonia> jle`: Who is that?
18:08:19 <shapr> pavonia: I'm gonna say emilypi
18:24:10 <dmj`> merijn: ping
18:24:30 <dmj`> jle`: oh stop, you're too kind
18:52:37 <jusss> how I can return the function itself in the function?
18:52:50 <jusss> like def f(x): print(x); return f
18:53:00 <jusss> then I can do f(1)(2)(3)
18:53:10 <Axman6> that sounds like an infinite type to me
18:53:25 <Axman6> what is supposed to happen you don't provide any more artguments?
18:53:59 <jusss> Axman6: then it just returns itself well
18:54:16 <jusss> Axman6: f(1) will return f itself, also f(1)(2)
18:54:18 <Axman6> but what happens to it then?
18:55:20 <jusss> Axman6: what you return another function happpens ？
18:55:45 <Axman6> maybe a better questions is: what should the type of f be?
18:55:58 <jusss> Axman6: it's like if you pass arguments to a function, then it's a function call, otherwise it's just a function waiting its arguments
18:56:11 <Axman6> :t let f x = print x >> pure f in f
18:56:12 <lambdabot> error:
18:56:12 <lambdabot>     • Occurs check: cannot construct the infinite type:
18:56:12 <lambdabot>         b1 ~ () -> IO b1
18:56:17 <jusss> Axman6: yeah, so what it's the function type?
18:56:27 <Axman6> You tell me
18:57:12 <jusss> Axman6: what if id function doesn't return x, and return id itself, so what id function type woulnd be? I don't know
18:57:40 <jusss> id :: a->a, id :: a -> id?
18:57:50 <iqubic> No.
18:58:04 <Axman6> id isn't a type
18:58:20 <jusss> Axman6: but a->a is a type,
18:58:28 <jusss> Axman6: id :: a-> (a->a)
18:58:36 <Axman6> (I mean, it could be, but id :: a -> id is equivalent to id :: a -> b, b and id are just type variables)
18:59:37 <jusss> Axman6: wait a sec, is there any strong type languages can return function itself?
18:59:37 <iqubic> How do imports and exports work in Haskell?
19:00:22 <jusss> Axman6: in the dynamic type languges like python or javascript, they can return itself in the function
19:00:24 <Axman6> @google How do imports and exports work in Haskell?
19:00:25 <lambdabot> https://www.haskell.org/tutorial/modules.html
19:02:00 * hackage reqcatcher 0.2.1.0 - A local http server to catch the HTTP redirect  https://hackage.haskell.org/package/reqcatcher-0.2.1.0 (hiratara)
19:03:54 <jusss> Axman6: in js, we can do `f = x => {console.log(x); return f}`
19:04:20 <jusss> Axman6: we really can't return function itself in haskell?
19:04:43 <iqubic> jusss: What does that JS code snippet do in JS?
19:05:50 <jusss> iqubic: you can run it with `f(1)(2)(3)` , it just prints 1 2 3
19:05:56 <Axman6> js doesn't really have a meaningful type system though
19:06:18 <Axman6> we can do similar things, but ti takes more effort. look at the Text.Printf module
19:06:51 <Axman6> > printf "%s is %d years old" "Steve" 7 :: String
19:06:52 <lambdabot>  "Steve is 7 years old"
19:07:03 <iqubic> Text.Printf is wonderful.
19:07:13 <iqubic> :t printf "%s is %d years old"
19:07:14 <Axman6> > printf "%s is %d years old, is that %s?" "Steve" 7 (show True) :: String
19:07:15 <lambdabot> PrintfType r => r
19:07:17 <lambdabot>  "Steve is 7 years old, is that True?"
19:07:30 <iqubic> what is that type there?
19:07:41 <Axman6> PrintfType r => r
19:08:18 <iqubic> But how does that work?
19:08:35 <dmj`> I'm getting a shocking increase in productivity for large values of -A w/ the rtsopts
19:08:47 <dminuoso> dmj`: What is -A ?
19:08:55 <dmj`> dminuoso: the allocation area
19:09:33 <jusss> Axman6: if we return a lambda, what it's type will be?
19:09:49 <jusss> return a lambda in a lambda
19:09:57 <dmj`> dminuoso: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#rts-flag--A%20⟨size⟩
19:10:16 <dmj`> "a bigger allocation area means worse cache behaviour but fewer garbage collections and less promotion"
19:12:43 <EvanR> > join ["a","b","c"] 
19:12:45 <lambdabot>  "abc"
19:14:58 <EvanR> to do this, you have to import Control.Monad, proving to the audience you need Monads to do anything in haskell
19:16:29 <dminuoso> EvanR: To some degree the confusion is understandable.
19:16:54 <dminuoso> Perhaps join is not the best of all names.
19:17:07 <EvanR> it's name is great in this case :)
19:17:50 <Axman6>  > join ["a","b","cd"]
19:17:58 <Axman6> > join ["a","b","cd"]
19:18:00 <lambdabot>  "abcd"
19:19:16 <Axman6> uh, yeah, not requence
19:19:29 <monochrom> I thought https://youtu.be/BvECNQRrjCY proves that you need IO to do anything in Python 5. >:)
19:19:33 <Axman6> sequence*
19:19:56 <Axman6> > sequence ["a","b","cd"]
19:19:58 <lambdabot>  ["abc","abd"]
19:22:51 <iqubic> :t first
19:22:53 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
19:25:05 <Axman6> > sequence $  sequence ["a","b","cd"]
19:25:08 <lambdabot>  ["aa","ab","ad","ba","bb","bd","ca","cb","cd"]
19:25:55 <Axman6> > concat $ iterate sequence ["01","01"]
19:25:57 <lambdabot>  ["01","01","00","01","10","11","0011","0011","0001","0001","0111","0111","01...
19:26:20 <Axman6> > concat $ iterate sequence ["0","1"]
19:26:22 <lambdabot>  ["0","1","01","0","1","01","0","1","01","0","1","01","0","1","01","0","1","0...
19:34:03 <iqubic> What is this???!?!
19:44:56 <jusss> but in a language like java, their class is their type, can we return the instance itself in the class?
19:45:16 <jusss> that would produce an infinite type?
19:45:30 <iqubic> A function is not a class.
19:47:26 <EvanR> otoh in some interpretations an OOP class is "just a function" (that returns objects)
19:47:51 <monochrom> That means you go through a wrapper type in Java. And you can use a wrapper type in Haskell too.
19:48:25 <monochrom> Java: public class C { public C f() { return this; } }
19:49:37 <monochrom> Haskell: data/newtype C = MkC{f :: C}
19:50:19 <EvanR> MkC, McK, KmEtt, ...
19:51:59 <EvanR> I'm finding it non trivial to write a small-step evaluator for a datatype with recursive bindings
19:52:41 <EvanR> would be cool if you could observe intermediate steps in haskell evaluation
19:53:18 <n3on10> hey there! I've started learning haskell a week or so ago and I heard this was the best place to learn more and get involved. I understand I should go to #haskell-beginners if I need some help, right?
19:54:42 <dminuoso> n3on10: Either channel is fine.
19:56:03 <n3on10> that's nice, thanks!
19:57:11 <dminuoso> n3on10: This channel sometimes has a tendency to get carried away in advanced discussions, so at worst it might intimidate you, but people are welcome to ask beginner questions in here. :)
19:57:44 <EvanR> this should definitely be an acceptable channel for beginners
20:01:30 * hackage boolector 0.0.0.9 - Haskell bindings for the Boolector SMT solver  https://hackage.haskell.org/package/boolector-0.0.0.9 (DeianStefan)
20:04:00 * hackage hw-xml 0.4.0.1 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-xml-0.4.0.1 (haskellworks)
20:15:22 <jackdk> I didn't even know that #haskell-beginners was a thing. I see beginner questions here all the time, and they're treated sensibly.
20:15:30 * hackage aeson-schemas 1.0.3 - Easily consume JSON data on-demand with type-safety  https://hackage.haskell.org/package/aeson-schemas-1.0.3 (leapyear)
20:18:51 <MarcelineVQ> jackdk: #haskell-beginners isn't specifically for #haskell begginners hehe, begginner questions are welcome and encouraged here. its usefulness lies more in that things are often too welcome here, so a begginner is overwhelmed with people clamoring to help, too many cooks in a sense
20:19:23 <MarcelineVQ> Put another way it's simply a quieter haskell help channel
20:19:41 <EvanR> is it?
20:20:24 <MarcelineVQ> Yeesss? :>
20:20:27 <EvanR> ok
20:21:23 <iqubic> I've never been there.
20:28:32 <EvanR> > nub ([1,1,2,2,3,3] ++ repeat 4)
20:28:41 <lambdabot>  mueval: ExitFailure 1
20:29:01 <EvanR> come on lambdabot 
20:29:09 <EvanR> % nub ([1,1,2,2,3,3] ++ repeat 4)
20:29:15 <yahb> EvanR: [1,2,3,4[Timed out]
20:29:18 <MarcelineVQ> yeha lambdabot, can't even do infinite things
20:29:19 <EvanR> yesss
20:29:59 <EvanR> nubs cool
20:39:57 <turab> Could someone help me understand why the following parser doesn't work the way I expect it to? Details are in the gist
20:40:01 <turab> https://gist.github.com/trajafri/ce744dc59ea7b979b123bf41689b7847
20:40:45 <turab> I am aware it's not the best implementation but I am currently not sure why it fails the tests mentioned at the end
20:40:51 <dansho> is there an encodeStrict for Aeson?
20:41:39 <dansho> aeson-extra i guess
20:47:08 <dmj`> encodeStrict = LBS.toStrict . encode
20:47:15 <dmj`> probably don't need an extra package for this though
20:50:59 <MarcelineVQ> turab: Your tests fail for me, perhaps there's an issue with your test setup or parseInstr? I've used dummies for testing, data ParsedInstr = Pk T.Text deriving (Eq, Ord, Show) , parseInstr = Pk , parseTest collectInstrs "#"
20:51:49 <turab> I just check if the parser returns a Left
20:51:53 <MarcelineVQ> fail in that parseTest collectInstrs "#" or parseTest collectInstrs " # " are []
20:52:25 <turab> Ah so I don't want that :/
20:53:50 <turab> From my newbie understanding, I think `many` just returns [] when the parser fails
20:54:55 <turab> But in this case I do want it to produce an error instead of []
20:56:49 <MarcelineVQ> sounds like you want to use some again :>
20:57:20 <turab> That does solve the issue in this case but then 
20:57:24 <turab> "" should pass the test
20:57:49 <MarcelineVQ> Why do you want your instruction parser to accept empty input?
20:58:31 <turab> I am trying to implement the following: http://rrose1.github.io/jsonesharp/
20:59:12 <turab> Details: http://www.indiana.edu/~iulg/trm/
20:59:47 <turab> According to all the description, empty input halts properly
21:03:38 <MarcelineVQ> Is empty input an instruction though? If not you might want to separate it from your instruction parser, it's best to let parsers do a specific job and combine them as needed
21:04:26 <MarcelineVQ> Not that I've written a ton of these, other people might have better options
21:04:29 <MarcelineVQ> opinions :>
21:05:34 <turab> It is indeed not an instruction
21:06:00 * hackage quickcheck-string-random 0.1.3.0 - Helper to build generators with Text.StringRandom  https://hackage.haskell.org/package/quickcheck-string-random-0.1.3.0 (hiratara)
21:06:25 <turab> My intuition was that `many takeInstr` will parse all the available instructions but sadly that doesn't seem to work
21:09:49 <sshine> I'm trying to write a Hedgehog 'Gen (Tree Int)': genTree = Gen.recursive Gen.choice [ pure (Node 0 []) ] [ Gen.subtermM (Gen.list (Range.???) genTree) ] -- I'm not sure how to apply a range that avoids explosions.
21:13:01 <javier_> @pl \x -> length . (flip filter) x . (==)
21:13:01 <lambdabot> (length .) . (. (==)) . flip filter
21:13:28 <Axman6> @unpl (length .) . (. (==)) . flip filter
21:13:29 <lambdabot> (\ x x0 -> length (filter ((==) x0) x))
21:15:20 <iqubic> What's the best way to add an element to the end of a list?
21:15:43 <iqubic> is it just "\x -> list ++ x"?
21:15:45 <sshine> iqubic, (++ [e])?
21:16:14 <iqubic> Right, yes. that.
21:16:26 <iqubic> :t (++)
21:16:27 <lambdabot> [a] -> [a] -> [a]
21:16:49 <iqubic> Is that the best way to do it?
21:16:57 <sshine> how might it be better, you think?
21:17:16 <Axman6> if you're doing it a lot that's not a good way to do it
21:17:18 <iqubic> No idea. That's why I asked in here.
21:17:20 <Axman6> use DLists
21:17:28 <iqubic> Axman6: I'm really only doing it once.
21:17:31 <MarcelineVQ> it can depend how often you're doing it, how often you need the final list, how long the list is etc. dlist for example can be a better choice
21:17:43 <iqubic> I only need it once.
21:17:44 <Axman6> if you're just doing it once it's probably fine
21:18:15 <iqubic> I think I can get away with only doing it once.
21:20:49 <crestfallen> sorry this is another construct I don't get https://paste.ee/p/k4UhR  what's going on
21:21:02 <iqubic> I love that hlint notices you have exported a few functions, and gives a warning saying that you have a top level binding that is niether exported nor called.
21:21:36 <crestfallen> we define f but cannot run g. what happens to g?
21:23:41 <MarcelineVQ> crestfallen: What do you mean you cannot run g? f runs g, so can you
21:23:58 <MarcelineVQ> e.g. g (*) 2 3
21:24:33 <c_wraith> iqubic: doesn't ghc also tell you about that one, as long as you have -Wall on?
21:25:53 <iqubic> I think that might actually be what's triggering it.
21:26:04 <c_wraith> ah, right, that could be it
21:26:13 <c_wraith> definitely a nice warning to have
21:26:29 <iqubic> Yeah. Removing the -Wall, and one function from my list of exports removes that warning.
21:26:38 <iqubic> It's not an HLint thing.
21:27:42 <crestfallen> MarcelineVQ, thing is, we define f on line 3, so I expected g f 10 to run..
21:28:17 <sshine> in my attempt to generate a tree using hedgehog, I've managed to get code that compiles: genThread = Gen.recursive Gen.choice [ pure (thread 0 []) ] [ thread 0 <$> Gen.list (Range.linear 0 10) genThread ] -- but it only ever produces leaf trees.
21:28:59 <MarcelineVQ> That's ill typed, g takes a first argument that's (a -> b -> c), f is Num a => a -> a
21:29:32 <crestfallen> sorry what exactly is ill-typed? 
21:29:56 <sshine> I can see in the sparse examples I've found that the recursive generator should have some Gen.subterm* part prefixed, but I'm unsure how to apply this for lists; it seems that e.g. Gen.subterm2 works for binary constructors, not n-ary, and so on.
21:30:05 <EvanR> crestfallen: type error, types don't match
21:30:36 <crestfallen> this example is riddled with other errors I think, in the text explanation
21:30:36 <EvanR> square peg round hole
21:31:02 <crestfallen> EvanR, please explain
21:31:33 <EvanR> in the position you wrote the expression, one type is expected while the expression has some other type
21:32:02 <crestfallen> line 3?
21:32:39 <iqubic> I don't see how this is ill typed.
21:32:40 <MarcelineVQ> in g f 10
21:32:59 <crestfallen> sorry I don't follow
21:33:10 <MarcelineVQ> g takes a first argument that's (a -> b -> c), a 2 argument function. f is Num a => a -> a, which is a one argument function. These types will not match.
21:33:39 <EvanR> :t let g f n = (\m -> m `f` n) in g
21:33:41 <lambdabot> (t1 -> t2 -> t3) -> t2 -> t1 -> t3
21:35:14 <iqubic> What code is ill-typed.
21:35:16 <EvanR> > let g f n = (\m -> m `f` n) in g (+) 2 10
21:35:16 <iqubic> ?
21:35:18 <lambdabot>  12
21:35:39 <MarcelineVQ> iqubic: writing g f 10 as an expression itself given these definitions, https://paste.ee/p/k4UhR
21:35:46 <iqubic> Oh, 'g f 10' is the ill typed expression.
21:36:20 <crestfallen> but line 3 in the paste is wrong, correct?
21:36:21 <iqubic> I see.
21:36:36 <iqubic> crestfallen: What do right and wrong mean here?
21:36:40 <iqubic> What are you trying to do.
21:36:42 <iqubic> ?
21:37:00 <iqubic> We can't tell if line 3 is wrong or not until we learn what the end goal is.
21:38:26 <crestfallen> well g (*) 2 3 I understand. I think the tutorial is just to show the idea of a higher order function.
21:38:50 <EvanR> what is the question again
21:40:23 <crestfallen> why would you define g, then define f = g (+) 2, and start showing examples such as > f 10 -- returns 12
21:41:00 <EvanR> to demonstrate partial application
21:41:05 <MarcelineVQ> That's something to ask of the exercise maker but what it shows to me is how you can use partial application
21:42:04 <crestfallen> ok thanks all
21:42:34 <MarcelineVQ> Which is the act of supplying only some of the arguments a function requires and getting back a new function to use with those arguments already baked in
21:43:23 <crestfallen> yeah I see how line 3 demonstrates partial application
21:44:10 <crestfallen> its interesting but seems convoluted
21:44:47 <EvanR> not a very motivating example
21:44:51 <javier_> What's the equivalent of (+2) but for (-2) ?
21:45:01 <EvanR> you might as well just do 10 + 2 and be done with it
21:45:04 <c_wraith> (subtract 2)
21:45:06 <MarcelineVQ> javier_: commonly people use subtract
21:45:18 <crestfallen> EvanR, what would be more motivating if you have time?
21:45:19 <javier_> thanks
21:45:31 <MarcelineVQ> or flip (-) 2 if you like parens
21:45:46 <EvanR> crestfallen: well, look at the function map
21:45:54 <c_wraith> If you want to really abuse the parser (-2 +)
21:46:04 <MarcelineVQ> c_wraith: you monster
21:46:53 <EvanR> :t map
21:46:54 <lambdabot> (a -> b) -> [a] -> [b]
21:47:18 <EvanR> pretend you want to use map with a function f k1 k2 x = something
21:47:22 <EvanR> it has 3 args, not 1
21:47:39 <EvanR> well, that's ok because ... map (f 2 10) [1,2,3] works
21:47:50 <EvanR> passed f two arguments, left the third one for map
21:51:13 <EvanR> this comes up like.. ALL the time. Use the first few arguments to a function as a sort of "function configurator"
21:51:24 <crestfallen> > map ((*) 2 10) [1,2,3]
21:51:26 <lambdabot>  error:
21:51:26 <lambdabot>      • Could not deduce (Num a0)
21:51:26 <lambdabot>        from the context: (Num a, Num (a -> b))
21:51:31 <EvanR> or function factory if you will
21:51:45 <crestfallen> nope thats embarrassing
21:51:47 <EvanR> (*) is a 2 arg function
21:52:01 <EvanR> > map ((*) 2) [1,2,3]
21:52:03 <iqubic> crestfallen: That's like trying to run: "map (2 * 10) [1,2,3]"
21:52:03 <lambdabot>  [2,4,6]
21:52:10 <MarcelineVQ> You've supplied both the arguments (*) needs there, partial application is about supplying just some of them, in the case of map which takes (a -> b) you want to have just one left over
21:54:25 <crestfallen> function configurator?
21:55:18 <EvanR> sometimes you need a function but want it's behavior to be configurable (with a parameter)
21:55:50 <EvanR> this is exactly solved by adding a new parameter and partial applying 
21:56:03 <iqubic> ah. I see.
21:56:30 <crestfallen> so where you wrote map (f 2 10) [1,2,3] works    above, what did you intend?
21:57:01 <EvanR> note f k1 k2 x = something
21:57:01 <Axman6> :t foldl
21:57:03 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
21:57:21 <EvanR> so the result is [f 2 10 1, f 2 10 2, f 2 10 3]
21:57:26 <Axman6> :t foldl (\x y -> x + show y)
21:57:27 <lambdabot> error:
21:57:27 <lambdabot>     • Could not deduce (Num String) arising from a use of ‘+’
21:57:27 <lambdabot>       from the context: (Foldable t, Show a)
21:57:33 <Axman6> :t foldl (\x y -> x ++ show y)
21:57:34 <lambdabot> (Foldable t, Show a) => [Char] -> t a -> [Char]
21:57:40 <Axman6> :t foldl (\x y -> x ++ show y) ""
21:57:41 <lambdabot> (Foldable t, Show a) => t a -> [Char]
21:57:49 <crestfallen> lord help me
21:57:51 <Axman6> :t foldl (\x y -> x ++ show y) "" [1,2,3]
21:57:52 <lambdabot> [Char]
21:58:00 <Axman6> > foldl (\x y -> x ++ show y) "" [1,2,3]
21:58:03 <lambdabot>  "123"
21:58:10 <EvanR> crestfallen: f was a 3 arg function
21:58:17 <EvanR> let g k1 k2 k3 x = something
21:58:33 <EvanR> now you can do map (g 'a' 1 False) [1,2,3]
21:58:52 <EvanR> (g has 4 args)
21:59:32 <sshine> wat. I made my hybrid bastard genTree :: (MonadGen m, MonadState Int m) => m (Tree String) compile. since I mixed a MonadState into it, Gen.sample won't work now. can I somehow mix some runState/runStateT into this to get back something that's just a Gen (Tree String)?
22:06:57 <crestfallen> EvanR, how would you write this fully ? let g k1 k2 k3 x = something
22:07:19 <Axman6> what do you mean by "fully" 
22:07:39 <EvanR> > let g k1 k2 k3 x = k1*x + k3/k2 in g 1 2 3 4
22:07:41 <lambdabot>  5.5
22:07:53 <EvanR> > let g k1 k2 k3 x = k1*x + k3/k2 in map (g 1 2 3) [1, 2, 3, 4]
22:07:55 <lambdabot>  [2.5,3.5,4.5,5.5]
22:08:45 <crestfallen> thanks! EvanR Axman6 I'll study that maNana
22:08:51 <EvanR> "fully baked" probably
22:09:59 <crestfallen> I don't understand how you people learn this stuff so well
22:10:06 <Axman6> time
22:10:16 <EvanR> luck
22:10:19 <Axman6> I've been doing it for about 11 years
22:10:22 <EvanR> ^
22:10:29 <Axman6> and definitely don't feel like an expert
22:10:37 <crestfallen> bloody hell
22:10:49 <Axman6> but only because there's an infinite universe of things you can learn
22:11:19 <crestfallen> what about if I wanted to learn haskell for gainful employment ? 
22:11:42 <Axman6> well, I'm being paid, you can too! This is technically my fifth job using Haskell
22:12:00 <crestfallen> that's awesome
22:13:16 <iqubic> I just recently learned about delimeted continuations. So wacky and bizarre.
22:13:17 <sshine> I've known Haskell since 2012, but it's only now that I've started looking into type-level programming.
22:14:22 <iqubic> type-level programming is super awesome.
22:14:42 <dsal> I think haskell has become my go-to language.  I don't get paid for it, but I'm a better programmer than I was before I knew haskell.
22:14:47 <sshine> there's still lots of basic stuff I don't understand well enough yet. for example, I'm stuck with a fairly basic monad transformer stack problem right now.
22:15:12 * dsal goto language?   >>= language?
22:15:42 <turab> Axman6: It's late right now but I would love to have a chat with you about your haskell jobs if you are okay with that!
22:15:55 <EvanR> 10 Haskell
22:15:58 <EvanR> 20 goto 10
22:16:11 <Axman6> 11 Haskell!
22:16:24 <turab> Ha
22:16:29 <Axman6> turab: happy to chat chat in here
22:16:33 <dsal> I like how haskell can compute infinite loops so fast.
22:16:45 <EvanR> > let x = x in x
22:16:48 <lambdabot>  *Exception: <<loop>>
22:16:52 <EvanR> that took forever
22:17:09 <Axman6> so many universes were destroyed to get you that answer
22:17:12 <iqubic> let x = x in x
22:17:13 <sshine> looks like it took 3 seconds minus network latency. that's still quite finite.
22:17:13 <turab> My first pl was BASIC and I basically switched to engineering lol. Next time I tried programming I started with Racket here I am :)
22:17:29 <iqubic> > let x = x in x
22:17:32 <lambdabot>  *Exception: <<loop>>
22:17:33 <iqubic> Yeah it takes a while.
22:17:38 <crestfallen> I always feel like eventually I'll understand a core where everything starts making sense. but it seems like an endlessly open-ended prospect.
22:18:06 <EvanR> crestfallen: agreed, i think there is a core of "basic haskell"
22:18:12 <turab> crestfallen: That's why I like it :>
22:18:14 <dsal> crestfallen: haskellbook is pretty useful for understanding the core.
22:18:14 <crestfallen> a core system for lack of a better term
22:18:15 <Axman6> any language where you can know everything is limiting you and holding you back
22:18:45 <Axman6> This is why C++ is also a great language =)
22:18:54 * Axman6 ducks
22:19:06 <EvanR> yeesh
22:19:56 <dsal> C++ is interesting, but their primary expressiveness goals seem to be in finding new ways to express things incorrectly.
22:20:02 <crestfallen> I wouldn't know, but to give vent I'm using a textbook so terse and dry. anything to be said about the richard bird book on haskell?
22:21:07 <crestfallen> the only book I've ever read over a thousand pages is Ayn Rand
22:21:09 <dsal> crestfallen: http://haskellbook.com/ is worth a look.  It's very slow, but you basically end up building all the fundamentals.
22:21:21 <crestfallen> ^
22:21:47 <crestfallen> Atlas Shrugged, what a doorstop
22:22:02 <crestfallen> richard bird votes?
22:22:10 <EvanR> she keeps coming up lately
22:22:22 <crestfallen> really?
22:23:13 <crestfallen> dsal could I get through it in a year with a bit more effort?
22:23:16 <MarcelineVQ> "<crestfallen> I don't understand how you people learn this stuff so well" really understanding the basics that lead to the complex
22:23:49 <iqubic> That's my opinion too.
22:24:00 <dsal> crestfallen: I went through about half the book and then wrote a bunch of programs to do things I wanted... then eventually got back into it and finished the book to do so.
22:24:01 <EvanR> that's what i call the scientific approach
22:24:04 <crestfallen> MarcelineVQ, have you ever had anyone in person teach you, or are you self taught from books, web etc?
22:24:16 <EvanR> not everyone can do it like that
22:24:34 <MarcelineVQ> a little bit of everywhere, people here, sporadic tutorials, most of a book
22:25:04 <crestfallen> would love to have in person instruction
22:25:08 <MarcelineVQ> p. sure I also quit once and came back later iirc
22:25:10 <iqubic> Me too.
22:25:27 <iqubic> But tech conferences are super expensive.
22:25:43 <dsal> Tech conferences == youtube
22:25:46 <MarcelineVQ> There are haskell meetups in some places
22:25:47 <dsal> In-person instruction == irc
22:26:01 <crestfallen> I deeply appreciate all your help but a chatroom is a brutal medium to learn imho
22:26:18 <EvanR> IRC is showing it's age
22:26:22 <dsal> It's where you go to answer ask questions you can't figure out answers to, or to get your code reviewed.
22:26:29 <EvanR> but I owe pretty much everything to it
22:26:40 <crestfallen> showing its age?
22:26:48 <EvanR> IRC is ancient tech
22:26:58 <iqubic> I live in Seattle, so I'm hoping to go to Lambda World Seattle in the spring of 2020
22:27:05 <EvanR> commercial replacements have more features
22:27:21 <iqubic> Too bad the student prices are $335 USD.
22:27:26 <dsal> commercial replacements seem worse to me.
22:27:31 <EvanR> me too
22:27:35 <MarcelineVQ> 'features' :>
22:27:42 <crestfallen> but having said that, I learn more here than from the book. I need interaction
22:27:46 <dsal> my irc client has all the features I need.
22:27:55 <turab> iqubic: Story of my life. It's either too expensive or too fair :(
22:27:55 <iqubic> Mine too.
22:27:58 <dsal> crestfallen: do you have programs you need written?
22:28:08 <turab> far*
22:28:14 <MarcelineVQ> I don't really see the percentage in going to a live conference, especially one you pay to enter, if you're not looking for a job
22:28:18 <iqubic> turab: Well, for me it's in my home city.
22:28:46 <iqubic> MarcelineVQ: Are you saying I shouldn't go to this conference as a student?
22:29:03 <EvanR> conferences are big business, for whoever organized it
22:29:07 <crestfallen> no I can barely understand a lot of stuff that is completely written out in front of my nose. dsal
22:29:16 <MarcelineVQ> I'm saying how I approach things, this isn't neccesarily how you should, that's a hell of a chunk of change though
22:29:17 <EvanR> the only good reason to go is if your employer sent you
22:29:23 <crestfallen> meaning a full solution
22:29:51 <turab> Luckily P Wadler was at my uni today and I got to listen to him in person. Such a great talker!
22:29:54 <crestfallen> too much hype and neurosis I just want a personal tutor
22:29:57 <MarcelineVQ> I wouldn't go to a place for that price unless the $335 included air-faire ^^;
22:30:00 <iqubic> EvanR: So I shouldn't go? Even if it is in my hme town?
22:30:02 <dsal> crestfallen: Oh.  Well, for me, that's the biggest learning tool -- a thing I need written.  Even something like https://adventofcode.com/ was really great when I didn't have my own needs.
22:30:25 <EvanR> i mean...
22:30:34 <EvanR> if you're loaded 
22:30:45 <EvanR> but i don't expect a big return
22:31:36 <crestfallen> dsal thanks I'll check it out. I own haskellbook but the length just crushed me. plus I never really got the lambda calculus at the beginning
22:31:40 <Axman6> I usually loearna lot oat conferences, and get to catch up with lots of people I don't see often - this by itself is possibly worth the price of admission if it gets you a new/better job =)
22:32:24 <dsal> crestfallen: You could start on chapter 2 if you wanted.  It walks you through all the basics and has you build the fundamentals.  With the exercises, you end up knowing quite a bit.
22:32:43 <dsal> But without programs I need written, I'd have a hard time learning anything.
22:32:56 * dsal signed up for an agda class next week. hopefully I can need that.
22:33:32 <crestfallen> I think I got to chapter 3 or 6 I don't remember
22:33:37 <crestfallen> 3 or 4
22:33:39 <Axman6> I rarely write programs to solve a problem of mine, more often I'll write an algorithms that's interesting, and then make it fats
22:33:42 <Axman6> fast*
22:33:57 <dsal> fats -> fast
22:34:54 <iqubic> EvanR: I'm just going to wait for the YouTube videos
22:34:58 <turab> dsal: Have you checked plfa?
22:35:02 <dsal> My most recent thing was an MQTT stack (3.1.1 and then I found out 5.0 came out).  I used my 5.0 code/tests to generate a pile of C++ tests for a C implementation of the protocol and then a bunch of other junk.
22:35:32 <dsal> turab: Not sure what you're talking about, so I'm going to go with no.  :)
22:35:41 <crestfallen> I was thinking about the richard bird book and the emphasis on equational reasoning
22:36:28 <dsal> More than one viewpoint is pretty helpful.  I also liked the concurrent/parallel book.  Concurrency in haskell is really nice.
22:36:31 <turab> It's an online book that uses Agda for theorem proving
22:36:34 * dsal needs to go to bed
22:36:41 <turab> I liked it more than Software Foundations
22:36:42 <Axman6> that is a fantastic book
22:36:46 <dsal> turab: Oooh.  Yeah, I almost know what agda is.  Gonna be a while.
22:36:55 <crestfallen> Axman6, which one
22:36:58 <Axman6> (Parallel and Concurrent Programming in HAskell by Simon Marlow)
22:37:12 <iqubic> I know nothing about Haskell Concurency, or Parallelism.
22:37:21 <MarcelineVQ> dsal: join ##dependent if you're gonna work with agda :>
22:37:23 <ski> @where PCPH
22:37:23 <lambdabot> "Parallel and Concurrent Programming in Haskell" by Simon Marlow in 2013 at <http://community.haskell.org/~simonmar/pcph/>,<http://chimera.labs.oreilly.com/books/1230000000929/>,<https://web.archive.
22:37:24 <lambdabot> org/web/20180117194842/http://chimera.labs.oreilly.com/books/1230000000929>,<https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/>
22:37:24 <dsal> iqubic: it's really nice
22:37:33 <dsal> MarcelineVQ: thanks... I guess I'll be there next week.
22:37:59 <ski> @where PLFA
22:37:59 <lambdabot> "Programming Language Foundations in Agda" (formal methods book) by Wen Kokke,Philip Wadler in 2018-(01-06) at <https://homepages.inf.ed.ac.uk/wadler/topics/agda.html>,<https://plfa.github.io/>
22:38:21 <crestfallen> any yeahs for the graham hutton book?
22:38:23 <ski> crestfallen : "Algebra of Programming" ?
22:38:40 <ski> i've heard people laud Hutton
22:38:59 <crestfallen> oh bird wrote that as well.
22:39:12 <ski> which Bird book were you thinking about ?
22:39:14 <ski> @where PiH
22:39:15 <lambdabot> "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
22:39:31 <Axman6> that's the book we used in the course I learnt Haskell in
22:39:42 <ski> @where PFAD
22:39:42 <lambdabot> "Pearls of Functional Algorithm Design" by Richard Bird in in 2010-09 at <https://www.cs.ox.ac.uk/news/237-full.html>
22:39:45 <ski> that one ?
22:39:48 <crestfallen> thinking Functionally in Haskell
22:39:55 <crestfallen> with*
22:39:56 <ski> hm, not seen it
22:40:15 <ski> @where FoP
22:40:15 <lambdabot> "The Fun of Programming" edited by Jeremy Gibbons,Oege de Moor in 2003-03-27 at <https://www.cs.ox.ac.uk/publications/books/fop/>
22:41:45 <crestfallen> ski I got stopped cold at the state monad in the hutton book. It barely is more than a diagram. but I don't know how to even gauge a book on haskell as good or bad
22:42:25 <crestfallen> I haven't looked at it in nearly a month
22:42:29 * ski has not read PiH
22:42:35 <iqubic> Thinking with Types by Sandy is a super difficult book to understand, but I understand most of it.
22:42:49 <ski> @where TwT
22:42:50 <lambdabot> "Thinking with Types: Type-Level Programming in Haskell" by Sandy Maguire in 2019-01-10 at <https://leanpub.com/thinking-with-types>
22:43:50 <iqubic> Like some of the later stuff in the book confuses me, but it's quite good on the whole.
22:44:08 <crestfallen> ski did you read AoP by bird?
22:44:28 <ski> i'm not sure i finished, but i've read quite some in it, yes
22:44:37 <iqubic> What is AoP?
22:44:40 <ski> (not recently, though)
22:44:44 <ski> @where AoP
22:44:45 <lambdabot> "Algebra of Programming" by Richard Bird,Oege de Moor in 1996 at <https://www.cs.ox.ac.uk/publications/books/algebra/>,<http://lambda-the-ultimate.org/node/1117>,<http://wiki.c2.com/?AlgebraOfProgramm
22:44:45 <lambdabot> ing>,<https://www.goodreads.com/book/show/2727190-algebra-of-programming>,&c.
22:44:49 <iqubic> ah.
22:44:54 <crestfallen> did you like it
22:45:29 <ski> i thought it was nice. but then i have an interest in CT, and in deriving programs from specifications
22:46:21 <iqubic> That sounds like my cup of tea.
22:46:23 <ski> it uses relations (expressed as morphisms in a relation category) to specify possible output behaviour of functions, then refines the specification into a function with a particular selection of the possible results
22:46:48 <crestfallen> I think I'm going to buy this one https://www.amazon.com/Thinking-Functionally-Haskell-Richard-Bird/dp/1107452643 
22:47:07 <crestfallen> for the cover
22:47:09 <ski> FoP and PFAD may perhaps be easier to get into
22:48:26 <crestfallen> apparently there are full solutions in above bird book
22:52:45 <crestfallen> @where FoP
22:52:45 <lambdabot> "The Fun of Programming" edited by Jeremy Gibbons,Oege de Moor in 2003-03-27 at <https://www.cs.ox.ac.uk/publications/books/fop/>
22:54:41 <MarcelineVQ> Solutions are good for teachers but not so good for students. Does any student have the willpower to not use a crutch sitting in plain sight after stumbling for 4 hours on a single exercise?
22:55:49 <iqubic> No. Not at all.
22:57:25 <crestfallen> but on the other hand, learning by reading the masters never hurt an aspiring writer who cannot write a lick MarcelineVQ 
22:57:42 <cdepillabout> MarcelineVQ, the fastest way to learn doesn't necessarily mean figuring everything out for yourself.  Intelligentally using solutions when you can't figure something out can make for a more efficient learning experience.
22:58:48 <Axman6> often not as effective thogh
22:58:53 <MarcelineVQ> but when you've already used the crutch once, what's the harm in using it again, and sooner than last time, until you're not really learning
22:59:05 <MarcelineVQ> Reading an answer tells you how to solve that exercise. Completing an exercise tells you how to solve every exercise similar to that one. Or to quote someone else, "In the long run spoonfeeding teaches us only the shape of the spoon."
23:00:02 <EvanR> it's a solutions epidemic
23:00:11 <Axman6> my advice is, if you end up looking at the answers for something, try a few hours later to implement the solution from scratch. if you can't do it you didn't learn anything
23:00:12 <MarcelineVQ> Not that I'm an extremist, I'm not against peeking time to time, but it probably shouldn't be easy :>
23:00:18 <crestfallen> I don't know how I feel about that. I'm at the stage where I can only study other's work and try to enjoy the brilliance of it
23:00:22 <EvanR> i blame the solutions industry, keeping us hooked
23:00:58 <cdepillabout> Learning how to solve a problem is what is important.  It doesn't matter if you learned through figuring out solutions on your own, or internalizing solutions you've been presented with.
23:01:32 <crestfallen> I think its really brilliant, but it was the fruit of formal training in many cases, I believe
23:02:03 <MarcelineVQ> cdepillabout: I agree, when that first thing is achieved the method isn't important.
23:02:44 <MarcelineVQ> *the first sentance
23:03:28 <crestfallen> like my friend who went to MIT and went through the entire sicp book in the 80's. I could barely get through the 1st chapter
23:03:54 <EvanR> SICP is great
23:04:12 <EvanR> as a first book. There is so much more
23:04:58 <cdepillabout> MarcelineVQ, I guess my argument is that a good mix of figuring out things on your own, and internalizing other people's answers is always going to be the most efficient method to learning.  Of course, you'd have to adopt this if you can't help but look for a solution before you've tried to solve the problem yourself.
23:05:03 <nshepperd2> the ideal super-AI powered learning "book" would let you see the solution if you get stuck on a problem, and then immediately present a related new problem to make sure that you internalized the solution
23:05:50 <cdepillabout> @nshepperd2, constantly presenting you problems that are slightly above you're currently level of ability :-)
23:05:51 <lambdabot> Unknown command, try @list
23:06:40 <crestfallen> tbh I just can't keep all of it in my head. Stuff I've studied diligently looks foreign after a time
23:07:18 <Axman6> it takes practice, you have to use it, not just know it
23:07:21 <EvanR> use it or lose it
23:07:25 <nshepperd2>  ime getting stuck on an exercise means you missed something in the main text (the trouble is, you can't always tell what you missed. unknown unknowns, you know)
23:07:40 <Axman6> those damn WMDs
23:07:46 <MarcelineVQ> cdepillabout: I agree. My position is just that a drowning man will immediately grope for the liferaft. I would place it farther away so he has time to learn to swim.
23:08:00 <EvanR> you got your known unknowns, unknown unknowns, suspected unknowns, probable unknowns...
23:09:20 <nshepperd2> all unknowns are equivalent in denotational semantics
23:09:30 <monochrom> haha
23:09:37 <nshepperd2> because you see, the differences between them are unknowable
23:10:53 <MarcelineVQ> Would want to get bogged down in implementation details anyway.
23:11:32 <crestfallen> drowning, groping, spoonfeeding. I don't see my learning process as a negative thing.
23:12:26 <MarcelineVQ> I'm speaking of a hypothetical person, a generalized student, this applies to anyone learning something :>
23:13:28 <crestfallen> I think studying the evaluation steps - the trace - is the only way I'm going to learn this. but the steps are always surprising me
23:13:43 <monochrom> To prolong the metaphor, Natural Selection implies that it's a sink-or-swim world >:)
23:13:44 <MarcelineVQ> crestfallen: Not every person is suited to every task, humans are limited and wildly different from each other. Do you have a goal in mind when learning haskell? It's come up before but I've forgotten
23:15:12 <MarcelineVQ> Or, shortly, why do you want to learn haskell?
23:16:14 <crestfallen> thanks for asking. well, I'm 58, part of it is to keep my mind healthy. but actually I would like to work if I could be around smart people and learn a lot. I picked up haskell after someone on the scheme channel said haskell was where its at. I've never programmed for a living obviously
23:20:54 <Axman6> That's a big leap, well done =)
23:21:47 <crestfallen> I'm trying to process the post on natural selection
23:22:17 * ski . o O ( "unprovable","provably unprovable","unprovably unprovable" )
23:22:27 <EvanR> nice
23:22:54 <crestfallen> ski said they would be my private tutor.  :)
23:22:58 <MarcelineVQ> He's just kidding, mixing metaphors, people in glass houses sink with the ship.
23:23:19 <ski> i don't think i did :)
23:24:46 <crestfallen> ok well I need to rest up; tomorrow I'll start reading haskellbook again
23:24:56 * ski nods
23:25:01 <EvanR> I don't need a compass to tell which way the wind shines
23:26:28 <crestfallen> EvanR, best all time book for learning - internalizing - the core of haskell
23:26:33 <crestfallen> ?
23:26:50 <EvanR> I mean, I could never do a book
23:26:59 * ski . o O ( probably depends on the person )
23:27:13 <EvanR> I used A Gentle Introduction and haddocks
23:27:17 <EvanR> and IRC
23:27:25 <crestfallen> what's haddocks
23:27:29 <EvanR> LYAH was useless to me
23:27:39 <EvanR> library documentation
23:27:53 <crestfallen> LYAH hate those drawings with a vengeance
23:28:09 <EvanR> lol
23:29:12 <ski> interesting reaction to "friendly, cuddly, non-scary pics"
23:29:16 <EvanR> i got a lot of (maybe bad) intuition by just trying stuff in GHCI
23:29:52 <monochrom> That's the scientific way and is the best way.
23:29:53 <EvanR> poke ghci until i could explain what was happening, though my theories were not all right
23:30:58 <monochrom> Imagine physicists asking "where is God's book so I can just read how quantum mechanics and gravity could fit together?"
23:31:06 <monochrom> No, that's not how it works.
23:31:35 <crestfallen> yeah I need to learn more about. I can't read error messages worth a damn and the way it writes types as t1 -> t2 etc   just don't understand it yet
23:31:40 <crestfallen> more about ghci
23:38:22 <cdepillabout> crestfallen, learning Haskell can take a lot of time.  Even for professional programmers, it can take one or two years to really feel comfortable in Haskell.
23:38:36 <cdepillabout> It is a really nice language once you start to feel comfortable though.
23:40:56 <crestfallen> cdepillabout, thanks. I really like it. aesthetically I really disliked scheme. I really like discovering the evaluation order of functions. also unifying types
23:41:16 * ski likes Scheme :)
23:41:36 <crestfallen> ((((((((((((ski))))))))))))
23:42:01 <EvanR> fix (\x -> (x))
23:45:08 <ski> thank you, crestfallen :)
23:45:59 <crestfallen> you know the little schemer? I was following that book perfectly fine, then just completely lost my way
23:46:05 * ski . o O ( "Imagine" by Shriram Krishnamurthi in 1996-01-17 at <https://schemers.org/Miscellaneous/imagine.txt> )
23:46:16 <ski> (also <https://schemers.org/Miscellaneous/> has links to some poems)
23:46:27 <ski> i've looks at it, a bit
23:46:35 <ski> it seems cute
23:51:18 <monochrom> Hey what's wrong with SML?!
23:51:28 <ski> i dunno
23:51:50 <monochrom> OK maybe because Y is not so straightforward in SML.
23:51:53 <ski> i think Scheme48 admired it enough to copy its module system, at least ?
23:52:04 <monochrom> But Y is not so straightforward in Scheme either.
23:52:08 <ski> yes
23:52:12 <EvanR> or Haskell
23:53:17 <monochrom> I have abandoned Y actually. I have switched to diagonal (\x -> x x) instead. Simpler and agnostic to evaluation order.
23:53:29 <monochrom> err maybe s/agnostic/robust/ ?
23:53:40 <ski> just CPS it ?
23:53:53 <EvanR> :t (\x -> x x)
23:53:55 <lambdabot> error:
23:53:55 <lambdabot>     • Occurs check: cannot construct the infinite type: t ~ t -> t1
23:53:55 <lambdabot>     • In the first argument of ‘x’, namely ‘x’
23:54:13 <EvanR> "Buckle up I'm disabling the occurs check"
23:54:35 <monochrom> Oh in Haskell and SML you still need a wrapper type.
23:56:53 <monochrom> But (\x -> x x) (\f n -> if n==0 or n==1 then 1 else f f (n-1) + f f (n-2)) 10 works fine whether you use lazy or non-lazy.  Y breaks.
23:58:08 * ski hands EvanR `-rectypes'
