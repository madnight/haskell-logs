00:15:30 <thunderseethe> Is there a way to instance `MonadError` from mtl for `InputT` from Haskeline?
00:49:57 <hadxu> hi
00:53:12 * jgt waves
00:53:49 <sm[m]> Hey all. The Either type has an extensive haddock containing the information I was looking for, which you can see in the source for https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Either.html , but it’s not rendered by Hackage - any idea why ?
00:58:17 <sm[m]> Argh.. got to click the little + beside the small Examples heading. That’s easy to miss
01:00:41 <Rembane> To get all the instance docs? 
01:04:25 <sm[m]> No, you click the little triangle for that. You click the plus sign to open content under the “Examples” heading
01:04:59 <sm[m]> Usually that’s doctests, and in this case it was also valuable docs
01:06:26 <Rembane> Today I learned something new. I haven't seen them before. Thank you! 
01:08:09 <sm[m]> np
01:29:41 <orzo> How do i construct a Type value that represents the Kind [*] -> * using the ghc api for a plugin?
01:30:18 <orzo> i've managed [*] and * and I tried to apply the arrow constructor to those but it doesn't seem to work
01:30:44 <orzo> Last thing i tried was: mkTyConApp funTyCon [liftedListKind,liftedTypeKind]
01:36:34 <gonz_> jkachmar: Have you ever considered that your outward relationship to "the Haskell community" is part of making it feel like garbage?
01:36:52 <gonz_> All I ever see you do is whine, I swear to god.
01:37:17 <gonz_> And the things you whine about you never seem to lift a finger to do anything about at all.
01:37:50 <gonz_> I've even brought this up to you directly on the FP slack but you just keep doing it, as if you never once self-reflected after that.
01:38:40 <gonz_> There's nothing quite like trying to engage in a community only to have one of its most vocal people complain all the time about everything; even things he could himself actually put effort into fixing.
01:38:45 <gonz_> You're part of the problem.
01:47:27 <VaNilLa[m]> gonz_: I'm missing something. Who are you talking to? I can't find the user you're referring to in the last 5 days of logs. Sorry if it's a stupid question
01:47:50 <gonz_> His nick is auto-completed for me, which I took to mean he's in the channel.
01:48:24 <gonz_> And the user list has him, so I think that's the case.
01:48:58 <gonz_> It's definitely not a stupid question. I don't think he likes interacting with the community in any real fashion that much, so I don't imagine he's very active here.
01:49:25 <VaNilLa[m]> Yeah, it doesn't seem like it
01:50:15 <gonz_> To his credit, he does interact on the FP slack, but I didn't feel like opening up this can of worms there.
01:51:29 <VaNilLa[m]> I see. So your message is in response to a post or message somewhere else, then?
01:54:27 <gonz_> https://twitter.com/jkachmar/status/1172568306768842752
01:56:26 <VaNilLa[m]> I see. Well, that's not something I want to get into before bed. Thanks a lot for clarifying!
01:56:50 <gonz_> Sorry for taking it to the channel. GN. :)
01:57:48 <VaNilLa[m]> Goodnight :)
01:58:28 <maerwald> that was kinda random :o
02:24:12 <sicklork1n> where there any major changes made to the GHC runtime system between 8.4.4 and 8.6.5? Iv'e got this issue in production that occures every now and then where some process stops, strace shows futex(0x625f484, FUTEX_WAIT_PRIVATE
02:24:19 <sicklork1n> *were*
02:25:48 <sicklork1n> i'm down to about 200lines now and it still happening - never had an issue before upgrading..
02:35:17 <orzo> I have a type for which I don't have access to the constructors but it implements Data.Data.  I would like to create something like a derived instance for Show using the Data.Data instance.  Anyone know if that exists somewhere on hackage?
02:38:27 <iqubic> orzo: Can't you just use Standalone Deriving in this case?
02:39:20 <orzo> I don't have the internals from my module
02:39:30 <orzo> i want this for debug print reasons
02:39:38 <orzo> and to learn about the library
02:39:43 <orzo> it's poorly documented
02:39:55 <sicklork1n> does true-name work for this?
02:41:16 <orzo> "The data constructors are not all in scope" when try deriving
02:43:56 <sm[m]> sicklork1n: not sure.. check release notes, error web search, #ghc ?
02:48:31 * hackage reanimate 0.1.6.0 - Animation library based on SVGs.  https://hackage.haskell.org/package/reanimate-0.1.6.0 (DavidHimmelstrup)
03:06:36 <jgt> gonz_: I think you're barking up the wrong tree tbh. People who participate in outrage culture (strong correlation here with people who explicitly define their pronouns) naturally enjoy complaining
03:09:06 <jgt> gonz_: this explains their political ideas too, which are quite predictable, like in the case of that guy saying Rust isn't just a language, it's a "movement"
03:09:27 <jgt> gonz_: I could talk about this at length, but not as eloquently and comprehensively as Wittens http://acko.net/blog/falling-into-faith/
03:10:33 <gonz_> I'm not interested in campaigning against anything other than toxic whining, to be honest.
03:11:02 <maerwald> not sure that really helps, except creating more toxicity :o
03:12:05 <jgt> gonz_: I think you actually said it very well in that Twitter thread, when you said "Cults feel great from the inside"
03:12:37 <jgt> gonz_: but that should spell it out for you too — they _are_ a religion/cult, so for the sake of your own sanity it's best to mostly ignore them
03:13:33 <gonz_> maerwald: I agree. Some of this is going to create a worse atmosphere and if it doesn't shut up the original toxic whining it's a net loss.
03:14:13 <maerwald> Well, since it didn't happen in this channel, I believe giving a response in this channel didn't create a net gain
03:14:30 <jgt> gonz_: here's a rhetorical question: do you think if Haskell weren't around, they'd stop whining?
03:14:39 <maerwald> Except distributing his message to a wider audience
03:16:00 <gonz_> You're right; I should've sent this in private.
03:28:34 <sshine> is it customary to check that 'cabal sdist' or 'stack sdist' will work out in CI? can't you assume that they will when 'cabal build' and 'stack build' work?
03:32:44 <lemmih> sshine: I never check. 'cabal sdist' is usually kind enough to tell me about any overlooked problems.
03:33:10 <sshine> hi lemmih :)
03:34:05 <sshine> lemmih, you mean, when you run 'cabal sdist' manually before releasing a package?
03:38:02 <maerwald> doesn't cabal sdist fail when there is no base upper bound?
03:40:26 <sshine> ah, so that might build but not sidst.
03:40:39 <sshine> s/id/di/
03:45:13 <maerwald> hm, seems not
03:45:26 <maerwald> thought it invokes cabal check
03:46:59 <sshine> does it make sense to have 'cabal check' in CI?
03:48:19 <sm[m]> I suppose it’s cheap, and there’s a slim chance you might break it
03:49:01 <maerwald> sshine: really only if you intend to upload to hackage 
03:49:53 <sshine> maerwald, I'm improving on a library that's already on hackage.
03:50:28 <sshine> maerwald, and I did some cleaning up of .travis.yml because 'language: haskell' has come around since.
03:53:20 <maerwald> sshine: yeah, makes sense then
03:53:58 <maerwald> hopefully you are not using hpack, because it doesn't guarantee a valid .cabal file
03:54:39 <sshine> I am using hpack, but this library isn't.
04:12:50 <sm[m]> You just need to remember to regenerate the cabal file, then cabal will check it
04:13:29 <sm[m]> But I’m surprised to think that hpack could generate an invalid one
04:18:53 <maerwald> sm[m]: hackage-valid
04:19:04 <maerwald> it obviously does not guarantee it, because that would be an unnecessary restriction
04:19:37 <maerwald> e.g. you can leave half of the fields that are "required" by hackage empty and it will still be a valid project file, but rejected by hackage
04:20:37 <sm[m]> maerwald: isn’t that the same without hpack ?
04:20:40 <sshine> so... one thing is that hpack might generate invalid .cabal files, and another is that they might generate .cabal unsuitable for hackage, right?
04:20:57 <maerwald> sm[m]: yes
04:21:14 <sm[m]> I’m not quite seeing why “hopefully not using hpack”
04:21:41 <sshine> maerwald, do you think it would be a worthy feature of hpack to ensure that hackage-required fields are set? maybe it's a feature that you can leave those fields out, maybe it's a bad feature. I don't really know.
04:22:04 <maerwald> sshine: I don't know, I don't use hpack anymore
04:22:28 <maerwald> sm[m]: I find it's more difficult to maintain a valid .cabal file when it's autogenerated
04:22:47 <maerwald> since there is nothing in the code that would be able to force compliance
04:23:00 <sshine> maerwald, force compliance with hackage?
04:23:01 <maerwald> but yeah, depending on your workflow it might be fine
04:23:15 <maerwald> especially if you make cabal check part of ci
04:23:22 <sm[m]> sshine: I think it more often generates a valid cabal file than humans do.. then there’s cabal check for the extra hackage compliance testing
04:23:59 <sshine> maerwald, sounds like a feature request. but yeah, I see what you mean. if the feature isn't there, you have less control of the outcome than if you just made the .cabal yourself. but you'd have to specify the exact same things in package.yaml as you would in the .cabal, no?
04:24:12 <maerwald> yeah
04:24:26 <sshine> maerwald, have you experienced that you placed the required fields in package.yaml and that the generated .cabal file was unsuitable for hackage?
04:24:51 <maerwald> not specifically
04:24:55 <sshine> maerwald, or have you experienced that hpack generates messy .cabal files?
04:26:05 <sshine> I've used hpack for a while now, and before that, I wasn't doing a lot of intelligent stuff in .cabal. so in my latest sprint of fixing dependencies in various packages I don't own, I realize that for at least library maintainers, you do want some level of control that I haven't tried to achieve with hpack... like 'if impl(...)'s?
04:26:40 <sm[m]> I think maybe maerwald is talking about when only package.yaml is committed. Then you might commit and tag a package.yaml file that generates a cabal file that isn’
04:26:55 <sshine> sm[m], oh.
04:26:59 <sshine> sm[m], that seems mean.
04:27:03 <sm[m]> t hackage-ready. If you always commit the generated cabal file, this isn’t really an issue
04:27:43 <sshine> sm[m], even meaner than refusing to have a stack.yaml when it doesn't hurt you specifically. :)
04:27:50 <sm[m]> You can do conditionals with hpack
04:27:54 <sshine> sm[m], ok.
04:28:22 <__monty__> But why would you hpack?
04:28:38 <__monty__> It can do everything cabal can isn't exactly a strong reason.
04:28:40 <sm[m]> argh, such a FAQ
04:29:01 <sshine> I know there are things you can't do. the Kowainik guys refuse hpack because of some of those things.
04:29:29 <sshine> __monty__, I like hpack because I can have 'dependencies:' on the top level.
04:29:43 <sm[m]> Mainly, it reduces duplication and human error/effort. Latest cabal has caught up to it in some respects.
04:29:45 <__monty__> I simply don't get it. It's not like cabal's some arcane and complicated format.
04:30:02 <sshine> __monty__, so basically: I don't need the control that I might lose. I can just write less.
04:30:35 <sm[m]> You’ll find it more valuable if your cabal file is complex
04:30:40 <sshine> __monty__, but surely it's just a matter of preference. I haven't had any "god, why don't they use hpack!" moments in the past few days of not having it.
04:31:05 <sshine> __monty__, but I have had "god, why don't they use stack!" ;-)
04:33:32 <__monty__> Because cabal v2 is great : )
04:33:46 <maerwald> sm[m]: oh, yeah, you should always commit your .cabal file regardless of whether you use hpack
04:33:59 <maerwald> so if you view hpack as a dev tool, then I think it's reasonable
04:37:36 <sshine> __monty__, so great that I have to apply "v2" in every command to remind myself how great it is. ;-P
04:38:31 <sshine> maerwald, is it at all common that people only commit package.yaml and not their .cabal file?
04:38:43 <__monty__> sshine: Not in cabal 3.0, though I'd still recommend it in scripts. But I don't see what gradual UI transition has to do with it?
04:39:08 <__monty__> Probably because people cargo-cult "Don't check in generated files."
04:41:31 <sshine> __monty__, today Travis will let me write 'language: haskell', 'cabal: 3.0', 'ghc: 8.6.5'. I'm pretty happy with that. I kinda just followed the Kowainik "Dead Simple Haskell Travis" tutorial and assumed they had a point about testing different GHC versions with cabal, and testing that it compiles once with stack.
04:42:01 <sm[m]> sshine: I don’t think so, I’ve never seen it. Maybe within some private ecosystems
04:46:44 <__monty__> sshine: That's travis' yaml config. What does that have to do with hpack?
04:47:40 <sshine> __monty__, I was just saying that cabal 3.0 is easily accessible in CI environments, so the thing I said about 'v2' being littered in the command-line arguments was mostly me being frustrated when I installed cabal 2.4 a couple of days ago. :)
04:48:19 <maralorn> Does ghcide support hover information?
04:48:30 <maralorn> *already
04:50:31 <sshine> s/mostly //
04:52:54 <jzyamateur> Hi, Is there a list of stuff that behaves differently in GHCi vs compiled modules by default? For e.g. monomorphism restriction was off in GHCi...and on in module.
05:01:34 <cocreature> jzyamateur: run ":showi language" in ghci
05:03:33 <jzyamateur> cool, thanks
06:18:55 <elvishjerricco> What's everyone's favorite extensible records approach these days?
06:34:46 <sshine> elvishjerricco, I don't use extensible records. but I've recently read about vinyl.
06:53:50 <sshine> non-haskell question: is anyone aware of a framework that parses many programming languages? I imagine it might be used for syntax highlighters, but my use-case is different.
06:55:02 <sshine> I think what I had in mind was actually ANTLR.
06:56:05 <karl55> Hi! I'm looking for a way to compile a statically linked GHC. Anybody done that or have a link?
06:56:45 <__monty__> karl55: https://github.com/nh2/static-haskell-nix
06:57:25 <karl55> Looked at this today already. Is there a way to compile GHC using static-haskell-nix?
06:57:54 <merijn> sshine: ANTLR is not a framework for parsing languages
06:57:59 <karl55> There is a download for a statically compiled stack binary at the link. But did not find yet a statically linked GHC.
06:58:04 <merijn> sshine: ANTLR is a parser generator framework
06:58:20 <merijn> karl55: Just this week I saw someone tweet a link to static GHC
06:58:38 <merijn> Vanessa McHale, I think?
06:58:43 <karl55> Relly??? 
06:59:03 <merijn> karl55: https://twitter.com/vamchale/status/1171165048032677888
06:59:34 <IRC-Source_94> Hi everyone
06:59:46 <APic> Hi
07:00:09 <IRC-Source_94> please help me understanding this ```*StateMachineTest> :t Gen.filter odd (Gen.int Range.constantBounded )Gen.filter odd (Gen.int Range.constantBounded )  :: (MonadGen m, GenBase m ~ Data.Functor.Identity.Identity) =>     m Int```
07:01:11 <merijn> Let me guess, NULL /= NULL in SQL? That would explain my naive migration code's breakage >.>
07:01:22 <karl55> merijn: you seem like a hero, wasted already 2-3 without progress
07:01:25 <lavalike> that probably evaluates to NULL merijn 
07:01:28 <karl55> thanks
07:01:41 <IRC-Source_94> I have a monad g with (MonadGen g) but in this monad I'm unable to use Hedgehog's filter function
07:01:58 <merijn> lavalike: I was doing an INNER JOIN with Table1.col = Table2.col" and I just realised that column may be NULL >.>
07:02:18 <lavalike> woe you
07:03:08 <IRC-Source_94> from the docs its look like Gen.filter is the substitute for Quickcheck's `suchThat` but I don't know why using it is quite messy, can someone help me ? it looks naive.
07:04:51 <IRC-Source_94> basically this constraint ```Gen.filter odd (Gen.int Range.constantBounded )  :: (MonadGen m, GenBase m ~ Data.Functor.Identity.Identity) =>```
07:08:46 <sshine> merijn, shoosh, you're right. I'd only get the parser, not the syntax tree.
07:09:13 <lyxia> IRC-Source_94: It doesn't look like filter can be used with anything other than Gen really
07:10:00 <merijn> lavalike: Seems like my problem is trivially solved by simply use IS instead of =, so that's good :)
07:10:14 <lavalike> (:
07:10:51 <lavalike> (fwiw in my tests sqlite does interpret NULL as falsey in INNER JOIN ON ….c1 = ….c2)
07:11:30 <lavalike> (but if both are NULL they *do* match so there's that)
07:13:50 <c_wraith> wait. in sqlite, an inner join matches if the expression is NULL? That makes no sense.
07:14:00 <merijn> c_wraith: It doesn't
07:14:06 <c_wraith> oh good
07:14:11 <merijn> c_wraith: Because that was the exact failure I just ran into :p
07:14:13 <lavalike> maybe I just confused myself
07:14:24 <lavalike> (I did)
07:14:40 <c_wraith> because an inner join definitely shouldn't match when the "on" condition is null. :)
07:15:39 <merijn> c_wraith: I did want that in this case, but IS works :)
07:15:58 <c_wraith> ah, yes, that'd work fine
07:16:03 <lavalike> SELECT NULL IS NULL; => 1
07:16:40 <lavalike> SELECT NULL IS (NOT NULL); => 1    (^:
07:17:01 * hackage viewprof 0.0.0.31 - Text-based interactive GHC .prof viewer  https://hackage.haskell.org/package/viewprof-0.0.0.31 (MitsutoshiAoe)
07:17:10 <c_wraith> congratulations, parentheses change meaning! :P
07:19:35 <EvanR> i was going to posit a general law where that is illegal, but then i remembered about lisp
07:20:14 <__monty__> Even in haskell parentheses change meaning.
07:20:21 <EvanR> x vs (x) vs ((x)).... oh yeah and haskell
07:20:26 <c_wraith> > 1 + 2 * 3
07:20:28 <lambdabot>  7
07:20:32 <c_wraith> > (1 + 2) * 3
07:20:34 <lambdabot>  9
07:20:34 <EvanR> (f x) y vs f (x y)
07:20:35 <c_wraith> oh no!
07:20:48 <c_wraith> even in math, they change meaning!!!!
07:20:50 <Aquazi> hey in jest, suppose I have a try catch, and in the catch I want the test to fail
07:20:55 <EvanR> screw parentheses then
07:21:14 <int-e> EvanR: funny I've once read a paper whose most important flaw was that they assumed that function application was associative
07:21:16 <Aquazi> for now I have a dummy expect(true).toBe(false), but is there another way to make it more idiomatic the test has failed in the catch?
07:21:46 <lavalike> 7 = 9, haskell must do arithmetic mod 2
07:21:57 <Aquazi> oops wrong chan I'd say
07:22:14 <int-e> > let 7 = 9 in 42
07:22:16 <lambdabot>  42
07:23:17 <EvanR> i can't believe haskell would just let 7 = 9 and leave it that way
07:23:28 <olligobber> wait what
07:23:28 <EvanR> it's irresponsible
07:23:43 <merijn> Why wouldn't that work?
07:23:58 <merijn> olligobber: It's just a lazy pattern match (that fails when forced, except you can't force it)
07:23:59 <__monty__> Such a lazy language. : >
07:24:14 <olligobber> > let [] = 1 in 42
07:24:16 <lambdabot>  error:
07:24:16 <lambdabot>      • Could not deduce (Num [a0]) arising from the literal ‘1’
07:24:16 <lambdabot>        from the context: Num p
07:24:18 <merijn> > let x@7 = 9 in x
07:24:20 <ski> > let !7 = 9 in 42
07:24:20 <lambdabot>  *Exception: <interactive>:3:5-11: Non-exhaustive patterns in x@7
07:24:22 <lambdabot>  *Exception: <interactive>:3:5-10: Non-exhaustive patterns in 7
07:24:35 <merijn> olligobber: That one doesn't typecheck, but both 7 and 9 are the same type
07:24:47 <merijn> olligobber: It's more like "let [] = [1,2,3] in 42"
07:24:58 <maerwald> haskell isn't that *static* after all ;)
07:25:09 <olligobber> weird
07:25:22 <merijn> Related fun fact that many people don't know, you can just write pattern matches at module top level
07:25:30 <olligobber> > let 7=9 in (7,9)
07:25:33 <lambdabot>  (7,9)
07:25:51 <merijn> olligobber: 7 isn't a name, it's a constructor (sorta)
07:25:54 <__monty__> merijn: Does it have to be the same type or can it simply be unifiable types?
07:26:08 <ski> merijn : one can use that, sometimes, to work around the annoying absence of `local'-`in'-`end'
07:26:26 <merijn> ski: It can be super useful at times
07:26:34 <ski> > let [] = [0,1,2] in []
07:26:37 <lambdabot>  []
07:26:48 * ski nods
07:27:02 <olligobber> > let [7,a] = [9,1] in a
07:27:04 <lambdabot>  *Exception: <interactive>:3:5-17: Non-exhaustive patterns in [7, a]
07:27:16 <ski> __monty__ : "unifiable" is a meta-concept. it means that it is possible for them to be the same type
07:27:29 <olligobber> > let [a,7] = [1,9] in a
07:27:31 <lambdabot>  *Exception: <interactive>:3:5-17: Non-exhaustive patterns in [a, 7]
07:27:34 <olligobber> weird
07:27:39 <ski> __monty__ : so, yes. it has to be the same type. and yes, unifiable is enough
07:27:44 <int-e> > let f xs = let [x] = xs in if length xs == 1 then x else error "expected singleton list"
07:27:46 <lambdabot>  <no location info>: error:
07:27:46 <lambdabot>      not an expression: ‘let f xs = let [x] = xs in if length xs == 1 then x ...
07:27:55 <merijn> Legal Haskell: "module Foo where a,b,c :: Int; [a,b,c] = [1,2,3]"
07:27:58 <olligobber> > let (a:7:_) = [1,9] in a
07:28:00 <lambdabot>  *Exception: <interactive>:3:5-19: Non-exhaustive patterns in a : 7 : _
07:28:14 <int-e> > let f xs = let [x] = xs in if length xs == 1 then x else error "expected singleton list" in (f [1], f [2,3])
07:28:16 <lambdabot>  (1,*Exception: expected singleton list
07:28:20 <ski> merijn : yea, i've used that, sometimes. but with `map' or something in the definiens
07:28:41 <merijn> ski: I've used it for unpacking constructors into names I want
07:28:59 <int-e> (there's a justification for evaluating such patterns only when some of the bound variables are actually used)
07:29:00 <ski> that's occasionally useful, as well
07:29:05 <__monty__> ski: I was thinking of something like `(Num a) => a` vs `(Real a) => a`, not the *same* type but could be?
07:29:22 <ski> though i tend to do that more, inside a local `let' or `where', than directly inside a `module'
07:29:49 <int-e> olligobber: if you made the actual pattern amtch [a,7] lazy, then function definitions like  f [x,7] = x; f [x,9] = x+42  would stop working
07:30:19 <ski> @type [1 :: Num a => a,2.3 :: Fractional a => a]
07:30:20 <olligobber> I guess so
07:30:21 <lambdabot> Fractional a => [a]
07:30:34 <ski> @src Real
07:30:34 <lambdabot> class (Num a, Ord a) => Real a where
07:30:34 <lambdabot>     toRational :: a -> Rational
07:30:57 <ski> __monty__ : so, they would be of the same type, there, yes
07:31:03 <int-e> olligobber: so unless you make a subpattern irrefutable/nonfailing/lazy using ~, a pattern will always be matched as a whole or not at all.
07:31:49 <ski> > let a:7:_ = [1,9] in a  -- olligobber, no need for brackets in the pattern there, redundant
07:31:52 <lambdabot>  *Exception: <interactive>:3:5-17: Non-exhaustive patterns in a : 7 : _
07:32:06 <olligobber> I'll put as many brackets as I like!
07:32:07 <int-e> (which of those three terms is the least confusing?)
07:32:39 <int-e> I guess "nonfailing" is bad because it means something else now.
07:32:43 * ski is allergic to extraneous brackets .. unless there's a point, a conscious decision, to adding them
07:33:04 <int-e> And "irrefutable" only makes sense to people reading the Haskell report? But "lazy" is so overloaded.
07:33:51 <olligobber> I was told to give someone full marks for writing (((a)·b)·c) instead of ((a·b)·c)
07:35:03 <int-e> olligobber: so what if they wrote (((a)*(b))*(c))?
07:35:21 <EvanR> it would probably cause an error in lisp... you'd hope
07:35:25 <int-e> (bracketing just a is so inconsistent...)
07:48:07 <rotaerk> is there some way to get cabal new-* to rebuild just one of the packages I depend upon?
07:48:15 <rotaerk> I can do new-clean, but that makes it rebuild *everything*
07:48:58 <merijn> rotaerk: What'd the point of that be?
07:49:13 <rotaerk> I want to run LD_DEBUG while it's running to see where it finds a library
07:49:26 <rotaerk> because it's working before I upgrade nixos, but not after
07:49:58 <merijn> rotaerk: Is this a local package in your cabal.project, or?
07:50:31 <rotaerk> no, it's coming from hackage
07:51:02 <geekosaur> you might configure nixos to not clean up old configurations. or just force a rebuild after upgrading nixos, since nixos can't know you have a non-nix-controlled thing with a library dependency
07:51:03 <merijn> rotaerk: Then it should just be under ~/.cabal/store/ghc-x.y/package-name?
07:51:08 <rotaerk> particularly, it's GLFW-b, and when I build in my upgraded NixOS environment, it can't find libGL.so
07:51:29 <rotaerk> and I'm curious what changed, so I wanted to see the LD_DEBUG output while it's building pre-upgrade
07:52:25 <merijn> rotaerk: Does your pkg-config know about libGL?
07:52:48 <merijn> bindings-GLFW (dependency of GLFW-b) seems to just pkg-config to find it
07:54:18 <rotaerk> I'm not really familiar with pkg-config.  prior to the OS upgrade, it was sufficient to have my shell.nix ensure that LD_LIBRARY_PATH contained the libGL lib folder
07:54:33 <rotaerk> and somehow that's no longer sufficient; I looked at LD_DEBUG output and it's not even looking there
07:55:07 <rotaerk> I'll try deleting the GLFW-b folder from my cabal store and rebuilding
08:04:05 <rotaerk> worked; thanks
08:23:42 <merijn> If I'm in MaybeT/MonadPlus, is there a cleaner way to do something like: https://paste.debian.net/1100752/ ?
08:24:01 <merijn> I thought "guard", but that doesn't work with logging a message
08:25:35 <merijn> But the "end in mzero" do block also feels kinda awkward
08:26:27 <monochrom> do {guard cond; return foo} `mplus` do {logErrorN msg; mzero}
08:28:12 <monochrom> Strangely it resembles shell scripting idiom [ -d xyz ] || die "no xyz"
08:28:44 <monochrom> Perhaps you just need a similar "die" function :)
08:36:50 <maralorn> The feedback loop of ghcide is amazingly fast!
08:37:36 <sarahzrf> :)
08:37:39 <merijn> monochrom: Sure, I was just hoping it already existed, since it seems fairly common :p
08:46:32 <monochrom> OK something is wrong with the "ghcide" name.  Consider: insecticide, pesticide, regicide, ghcide...
08:47:36 <sm[m]> that's true, too. Hard to find a perfect name
08:47:52 * ski . o O ( "Pestic-IDE" )
08:53:14 <sm[m]> it's catchy (IDE!) but it's also a lie (aww.. where's the UI ?)
08:53:23 <erisco> Is ACID state about databasing or about recoverable computations or what
08:54:20 <merijn> erisco: I think it's mostly about false advertising >.>
08:55:00 <merijn> erisco: As, in its current state, it's not actually ACID...
08:55:21 <erisco> I am looking for a databasing solution that works closely with ADTs. Some might say "ORM".
08:56:31 <merijn> erisco: acid-state is definitely not a database (imo anyway)
08:56:59 <erisco> I'm just interested in the front-end design of it
08:57:05 <merijn> erisco: I don't think any database really has good direct support for ADTs
08:57:31 <pikajude> most DBs have json field support which is probably the closest you can get
08:57:54 <merijn> I'd just map the ADTs to the database yourself
08:58:05 * ski . o O ( `( \+ cond -> write(Msg),nl,fail ; blah )' )
08:58:12 <pikajude> ekmett wrote a library that allows you to query a list of ADTs like a relational database
08:58:21 <pikajude> but unfortunately it's deprecated now bc there was some insurmountable implementation problem
08:58:32 <pikajude> although it did work fine for my simple usecase :)
08:59:24 <pikajude> http://hackage.haskell.org/package/tables
08:59:32 <pikajude> maybe you could use that as reference
09:02:44 <erisco> Okay, how about some persistence solution that doesn't seem offensive
09:03:03 <merijn> erisco: SQLite!
09:03:27 <maerwald> erisco: ixset-typed :P
09:03:30 <maerwald> if you fancy in-memory DB
09:05:45 <merijn> monochrom: I guess I just need to do like "foo b act = unless b (act >> mzero)". The hardest part, of course, being inventing a name for "foo"
09:07:05 <sm[m]> wow there's a lot of stuff at http://hackage.haskell.org/packages/tag/database
09:08:59 <maerwald> we basically use ixset-typed with event sourcing to build and in-memory view of the current state, which you could think of as a database with fast lookups. But there are lot of problems with that approach
09:09:26 <maerwald> that allows you to use the full power of haskell ADTs for that state
09:12:02 <sm[m]> what about http://hackage.haskell.org/package/perdure ?
09:13:32 <rotaerk> seems odd that before the NixOS upgrade, when I build GLFW-b, LD_DEBUG indicates it's not even *looking* for libGL.so
09:13:56 <rotaerk> but after the upgrade, it looks for libGL.so and fails to find it ... and when it searches for it, it ignores LD_LIBRARY_PATH
09:14:00 <rotaerk> I think it's just using RUNPATH
09:14:34 <rotaerk> it's the same version of cabal, same version of GHC, and same version of GLFW-b
09:23:55 <rotaerk> how would I get the linker options used during a cabal build
09:24:25 <rotaerk> I see ways to pass them, but nott display the actual ones used
09:25:03 <merijn> rotaerk: Have you tried -v3
09:25:16 <rotaerk> oh, no; I just did --verbose
09:25:42 <merijn> rotaerk: It has multiple verbosity levels ;)
09:31:38 <srid> How does `ghcide` relate to `ghcid` (which I already use)?
09:32:39 <rotaerk> hmm nope, doesn't seem to show the linker options when I use -v3
09:32:51 <fendor> srid, it is kind of a replacement for haskell-ide-engine
09:33:48 <pikajude> wot, there's an even newer ide engine now?
09:34:02 <fendor> well, yes and no :)
09:34:11 <pikajude> that's the kind of answer i like
09:34:15 <fendor> haskell-ide-engine still exists and is actively developed
09:34:20 <pikajude> yes, i use it
09:34:21 <pikajude> it's very good
09:34:29 <pikajude> oh. "ghcide was previous called hie-core"
09:34:33 <pikajude> well that explains that
09:34:44 <fendor> does it? ^^
09:35:40 <merijn> srid: ghcide is written by (amongst others) the same guy who wrote ghcid and based on much of ghcid's code
09:35:53 <srid> ^ good to know!
09:36:08 <srid> i see that is is pulling iohk's haskell.nix ... which is interesting.
09:36:17 <EvanR> next one will be called ghcaid, as in what we are all sipping
09:36:29 <merijn> srid: So they were brainstorming alternative names for hie-core on twitter and someone pointed out that ghci -> ghcid -> ghcide was the only logical progression ;)
09:36:45 <srid> :)
09:37:24 * srid installing ghcide on his chromebook crostini (pixel slate)
09:37:38 <fendor> didnt know it was based on ghcid. does it use it as a diagnostic provider?
09:37:58 <merijn> fendor: Based on ghcid's *code*, not build on top of ghcid
09:39:55 <cocreature> merijn: no it is based on none of ghcid’s code
09:40:04 <maerwald> well, will ghcide scale?
09:40:27 <merijn> cocreature: I recall Neil saying that in a blogpost? I may have misread
09:40:47 <merijn> Of course I can't find said blogpost to check >.>
09:40:56 <cocreature> merijn: I’m part of the team that build ghcide so I’m fairly sure about this :)
09:41:25 <merijn> cocreature: I know, I'm just curious what he wrote that got misparsed :)
09:41:39 <merijn> "inspired by", maybe
09:43:50 <Nefratsu> any news about haskell 2020 ? 
09:43:51 <srid> Hmm, does ghcide *require* stack? I never use that.
09:44:31 <merijn> srid: That's the main reason I haven't tried yet
09:44:33 <cocreature> it doesn’t require stack. hie-bios which we use to setup the ghc session works with cabal, stack and others
09:45:10 <merijn> Nefratsu: Pray for divine intervention for it to happen at all >.>
09:45:17 <srid> How do I tell it to not use stack? I'm using it on https://github.com/kowainik/summoner (which has both stack.yaml and default.nix), but it is borking because stack executable is not found.
09:45:20 <srid> cocreature: 
09:45:50 <cocreature> srid: see https://github.com/mpickering/hie-bios for configuration
09:47:11 <srid> obelisk is supported! w00t
09:50:59 <srid> mpickering: any thoughts on opening a PR to get this changed merged to mainline? https://github.com/obsidiansystems/obelisk/issues/363#issuecomment-468267291
09:51:04 <maerwald> I think none of the toolings will really improve unless there is a major performance improvement. And I don't see that happening
09:51:25 <maerwald> Main focus is still different stuff, not performance
09:52:06 <fendor> maerwald, what about hiedb and hie files? cant those bring major performance boosts?
09:52:38 <maerwald> I don't know yet
09:52:38 <merijn> fendor: How would those boost performance?
09:53:11 <merijn> The performance bottleneck I see isn't in cabal/the tooling to interact with it, it's just that GHC quickly gets pretty slow for bigger codebases
09:53:32 <fendor> merijn, you dont have to reparse all information but can obtain them directly from ghc? 
09:54:03 <merijn> fendor: Parsing info from cabal is negligible time when it comes to reporting errors
09:54:43 <mpickering> srid: sure
09:54:58 <fendor> true, but once you compiled the whole project, isnt the overall performance better?
09:55:20 <merijn> fendor: Once I change a file at the bottom of my import DAG I need to recompile the whole project again
09:55:20 <mpickering> I tried to rebase it recently but got stuck because of obelisk not supporting 8.6
09:55:30 <merijn> fendor: That's the main bottleneck in highlighting errors
09:55:55 <mpickering> maerwald: Have you actually investigated any performance issues? 
09:56:24 <mpickering> srid: So if you rebase it and get it merged that would be good
09:57:19 <fendor> merijn, makes sense I suppose
09:57:23 <mpickering> And also if you can think of another way to setup a project then I am happy to merge a cradle for that
09:57:31 <srid> mpickering: obelisk `develop` branch is using 8.6
09:58:22 <mpickering> srid: this was just a self imposed issue really because my branch of hie only supported 8.6 for complicated reasons
09:58:50 <mpickering> And I wanted to test obelisk with it, after I couldn't I lost interest a bit
09:59:07 <dm9> Does anyone have an example of a non-trivial shake setup for web development?
09:59:13 <maerwald> mpickering: with?
09:59:28 <mpickering> You made this brash claim about performance of ides
09:59:35 <maerwald> the only tool that remotely worked for our codebase was hie, but it just times out
09:59:42 <maerwald> intero just triggers OOM
09:59:57 <maerwald> so yes, it was investigated you could say
10:00:09 <rotaerk> is there some reason GHC would be ignoring LD_LIBRARY_PATH during `cabal new-build`, and only searching for a library in the directories specified by GHC's RUNPATH
10:00:10 <mpickering> Yeah I have fixed some of these issues in hie
10:00:23 <mpickering> But still need to do more
10:00:30 * hackage slick 1.0.0.0 - A quick & easy static site builder built with shake and pandoc.  https://hackage.haskell.org/package/slick-1.0.0.0 (ChrisPenner)
10:00:32 <merijn> rotaerk: Well, yes
10:00:35 <mpickering> I can comfortably use it on GHC's code base
10:00:42 <merijn> rotaerk: That reason is: LD_LIBRARY_PATH isn't used during linking
10:01:15 <merijn> rotaerk: And any tool that *does* look there, is objectively wrong and disregarding POSIX :)
10:01:15 <rotaerk> I found an SO post suggesting I use "LIBRARY_PATH" instead of "LD_LIBRARY_PATH" during building
10:01:28 <mpickering> fendor also helped fix a bad syb traversal last week
10:01:29 <rotaerk> though it seemed to ignore that too
10:01:38 <mpickering> So we are actually fixing this stuff..
10:01:40 <merijn> rotaerk: LIBRARY_PATH is for where to look during linking, LD_LIBRARY_PATH is for where to look *at runtime*
10:01:54 <rotaerk> I have LIBRARY_PATH set, and it ignored it
10:03:47 <rotaerk> merijn, is there, then, some reason why it would ignore LIBRARY_PATH at link time?
10:04:26 <merijn> rotaerk: Is LIBRARY_PATH exported?
10:05:32 <freeman42x> which license options can be chosen for a commercial open source Haskell SAAS solution? eg. a cross-platform social network. I basically desire protection so that no-one else can monetize the product except the creators of it
10:06:13 <dmj`> freeman42x: why make it open source at all then
10:06:36 <freeman42x> dmj`, because I think that not making it open source would be a bad idea...
10:07:09 <merijn> freeman42x: Free software licenses (in the FSF sense) don't allow usage restrictions, so any "can't monetize this" restriction is in violation of any of those
10:07:21 <freeman42x> I basically want anyone who sees a flaw in the product to be able to submit a PR to fix the issue 
10:07:39 <maerwald> AGPL sounds good, but yes, you cannot prohibit people from monetizing
10:07:46 <freeman42x> merijn, it is not a FREE software licence, it is a COMMERCIAL licence
10:07:48 <merijn> None of the "open source" licenses (in the OSI sense) allow this either, so you'd have to define your own license and I doubt anyone would contribute to a project like that
10:08:26 <maerwald> well, you should consult a lawyer then :)
10:08:32 <freeman42x> maerwald, "you cannot prohibit people from monetizing" that is false, there are licenses with prohibit other people from monetizing your software
10:08:50 <maerwald> freeman42x: no, it isn't false, because I was referring to AGPL and free software licenses
10:08:59 <freeman42x> merijn, "and I doubt anyone would contribute to a project like that" you are wrong, they would for sure
10:09:08 <maerwald> I wouldn't :P
10:09:28 <monochrom> merijn: "do and die".
10:09:37 <merijn> freeman42x: Anyway, none of the existing licenses would do this, so you'll have to create your own (and probably consult a lawyer if you wanna go this way and not fuck up)
10:09:39 <maerwald> But you are really looking for advanced legal advice, so not sure you'll find it here
10:09:42 <freeman42x> maerwald, really? is there no such license already existing? I am 100% certain I encountered software which had licenses like that...
10:09:52 <Clint> there are millions of bad licenses out there
10:09:57 <freeman42x> heh
10:10:32 <monochrom> Yes, for a commercial license someone ought to be able to cough up money for a commercial lawyer.
10:10:36 <maerwald> from my time as a distro developer and my exposure with common licenses: haven't seen such specific one. I've seen semi-open source licenses, but even those don't really have clauses for "don't monetize"
10:10:48 <monochrom> If your employer wants to cut corner on this, you should quit.
10:11:25 <maerwald> haha
10:11:33 <maerwald> monochrom: where will he go then
10:11:42 <freeman42x> monochrom, "to cut corner on this" what does this expression mean?
10:12:10 <monochrom> cut corners on getting real legal advice on commercial license
10:12:17 <sm[m]> dm9: there’s a shake file in the hledger repo for building docs (and until recently, website)
10:12:45 <rotaerk> merijn, thanks; adding an "export" before LIBRARY_PATH=... fixed it
10:13:08 <rotaerk> I forgot there was a difference between setting an environment variable and actually exporting it
10:13:13 <maerwald> I mean, if you want to protect your product... and if there is actual business value... seriously get proper legal advice
10:13:26 <monochrom> Yeah "devop" is not enough, the exploitative employers now want you to be "paralegaldevop" too.
10:13:34 <maerwald> xD
10:13:35 <rotaerk> odd thing is I didn't have to export LD_LIBRARY_PATH before
10:13:58 <maerwald> monochrom: well, they can employ us with triple salary, no problem
10:14:19 <monochrom> I think the idea is they just give you a "dev" salary!
10:15:47 <monochrom> oh maybe you haven't heard of "cut corners". Save money by compromising integrity.
10:16:58 <monochrom> Example: In Canada we have this Wendy's hamburger franchise that advertises "why are our burger patties square shaped? because we don't cut corners!"
10:17:17 <monochrom> OK that one is their pun rather than a real example.
10:18:31 <EvanR> in america, Wendy's can only do this good: "Spicy Nuggs are Back"
10:18:58 <monochrom> rotaerk: If you don't export, it is not an environment variable, only a shell variable.
10:19:13 <rotaerk> I see
10:19:36 <rotaerk> well, the way it is *now* makes sense.  I just wonder why it worked fine before I upgraded NixOS 
10:20:11 <rotaerk> like, what could've been broken about NixOS before that would cause it to actually find libGL.so without having LIBRARY_PATH set
10:21:51 <monochrom> I don't know what happened but shell's export command acts like a flag, i.e., suppose at time 0 you say "export FOO=x", then subsequently at time 100 you can just say "FOO=y" and it is still exported.
10:21:53 <maerwald> monochrom: well, how are the burgers?
10:22:03 <monochrom> They're OK.
10:22:45 <geekosaur> there's also thr possibility that there was a libGL.so in the standard location for some reason, which isn't now
10:23:01 <monochrom> Oh, that too.
10:23:37 <geekosaur> or that the library path had been set by something else for whatever reason and "leaked" into your environment
10:24:00 <geekosaur> NixOS is just a bit evil in how it abuses things to accomplish its goals
10:24:00 <monochrom> Frankly an OS+filesystem is a bloody stateful mutating thing, you simply can't reason about it functionally.
10:24:38 <geekosaur> ^
10:24:53 <monochrom> Nix is "functional" in the same sense that Scheme and SML are "functional".
10:25:24 <hpc> nix being untyped doesn't help things imo
10:25:50 <rotaerk> I just rebooted into my pre-upgrade version of NixOS, and confirmed that LIBRARY_PATH does not get exported in that context
10:26:06 <rotaerk> (was thinking maybe something in NixOS changed that caused it to stop being exported, so I have to do it manually)
10:26:30 <rotaerk> whatever.  it works now...
10:26:35 <monochrom> I can sympathesize with "but nothing has changed except the clock" but really the human brain cannot be trusted to faithfully remember these things.  In fact psychology discovers that we have every reason to believe the brain deliberately forgets the most important things.
10:27:02 <rotaerk> I could probably find what changed, with enough effort; but it's probably not worth it
10:27:25 <geekosaur> changelog dumpster-diving
10:27:28 <rotaerk> someone probably "fixed" something to be more compliant, and that broke my non-compliant usage
10:27:37 <dm9> sm[m]: Thanks, I will look into that
10:30:47 <sm[m]> dm9 also there are some “shake helpers” things on hackage, like slick that was just announced
10:37:13 <dm9> sm[m]: cool, thanks!
11:10:00 * hackage net-mqtt 0.5.0.0 - An MQTT Protocol Implementation.  https://hackage.haskell.org/package/net-mqtt-0.5.0.0 (dustin)
11:10:24 <dsal> OK, that's weird.  I tried to sign that, and it failed.  Oh well.
11:14:55 <iqubic> I'm trying to test Singletons functions in GHCi and I'm getting strange errors.
11:14:56 <iqubic> http://dpaste.com/3GSE119
11:15:48 <iqubic> I figured it out.
11:15:59 <iqubic> I needed to use 'NotSym0' there.
11:28:57 <iqubic> Is it possible for me to use singletons to enforce that two specific arguments to my function are different?
11:30:10 <erisco> iqubic, yes, but in some interpretations, singletons is unnecessary.
11:30:42 <iqubic> Why do you say that?
11:31:30 <iqubic> Also, how would you go about doing this with Singletons? I have no idea.
11:32:04 <erisco> There are various ways to interpret "binary function defined only on distinct values"
11:32:18 <erisco> Do you have an example in mind?
11:32:19 <iqubic> Ah. I see. Yes. Yes there are.
11:32:44 <iqubic> No. Not right now.
11:32:56 <iqubic> I'm just exploring the Singletons library.
11:33:55 <erisco> Uppercase "Singletons" involves lowercase "singletons", plus a lot of other machinery. Just avoiding potential confusion.
11:34:37 <iqubic> But it's actually a 3 argument function of the form a -> a -> b -> c.
11:35:04 <iqubic> I want to enforce that all valid calls to this function have different values for the 'a's
11:36:04 <erisco> So then you be looking at something like   f :: NotEqual a1 a2 -> Sing a1 -> Sing a2 -> b -> c
11:36:09 <dsal> Oh hey, people had been paying more attention to my github repo than I had.  Guess I had a couple bugs.  Annoyingly, I found one myself and went through a lot of effort to fix it only to find much later that someone else had done the same thing.
11:36:14 <iqubic> Sure. That's right.
11:36:27 <iqubic> How do I implement the NotEqual type class?
11:36:51 <erisco> In that example it would be likely implemented as a GADT
11:37:07 <iqubic> And how would I construct such a thing?
11:37:16 <erisco> You have to figure that out.
11:37:42 <iqubic> Why?
11:37:49 <iqubic> Do you not know?
11:38:13 <erisco> A constraint could be used instead, which is particularly attractive if the constraint solver can automatically prove the inequality
11:38:43 <duncan> Surely the implementation of the NotEqual typeclass for a1 and a2 is specific to the datatype of a1 and a2?
11:39:22 <erisco> Yes, so NotEqual itself would be a data family, and you would give particular definitions for each type
11:39:35 <iqubic> Well, yes. But in this case I'm just deriving Eq.
11:39:56 <erisco> You have to figure it out yourself iqubic because it changes by type and changes by equality.
11:41:21 <iqubic> Ah I see.
11:41:39 <iqubic> What's the difference between a type family and a data family?
11:42:45 <erisco> A type family is a type function, and a data family is more like a type class, but for data.
11:43:28 <erisco> ... knowing you can do some of the work of type families with type classes as well.
11:45:00 <erisco> In this case, you'd have a kind-indexed data family, meaning that for each kind there is a different data type
11:47:08 <iqubic> I see.
11:53:20 <iqubic> Actually, I think I can just enable ConstraintKinds and do this: http://dpaste.com/3G4M8VF
11:54:00 <merijn> iqubic: You can just use closed type families: https://gist.github.com/merijn/6130082
11:56:41 <erisco> If all you want is type equality then that certainly simplifies :)
11:57:14 <erisco> Then you just say   f :: a -> a -> b -> c   like you did originally
11:57:49 <iqubic> What did you think I wanted?
11:58:16 <erisco> Oh right, NOT equals, fair :)
12:01:30 <iqubic> What I have does in fact work.
12:02:14 <erisco> That is some abominable operator from Singletons. Should have guessed!
12:02:43 <iqubic> I know.
12:02:52 <iqubic> And it isn't working in the way I want it too.
12:03:35 <erisco> If you want my opinion, I wouldn't bother with Singletons. I see it as an academic exploration into the possibility of lifting value programs to type programs.
12:03:51 <erisco> I do not see it as a learning tool or a practical library to build programs with.
12:03:59 <iqubic> Do you like Dependent Types at all?
12:04:33 <erisco> I'd like to think my opinion of dependent types is not relevant to my assessment of Singletons.
12:05:24 <erisco> Case in point, you can follow merijn's example which is just a few lines of Haskell, or even more simply...
12:05:41 <erisco> type family NotEqual a b where NotEqual a a = False; NotEqual _ _ = True
12:05:46 <merijn> My thing-a-majig doesn't use dependent stuff, though :)
12:06:02 <merijn> I just checked, apparently that works since 2013 >.>
12:06:08 <merijn> I feel old now
12:06:15 <erisco> If we're not talking about lifting values to types or vice versa then we're not really talking about singletons
12:06:39 <erisco> Here we are just talking about type equality, no values harmed in the process
12:07:16 <iqubic> merijn: This does't work at all. http://dpaste.com/371MBJ6
12:08:12 <iqubic> I just changed the both of the "k"s to "Type" and it still fails to compile, for the exact same reason.
12:08:23 <erisco> NotEqual a a  is always unsatisfiable
12:08:38 <erisco> It is like you wrote  x ≠ x
12:09:01 <iqubic> Oh. I see.
12:10:05 <erisco> Also you're really just aliasing /=@#@$$$
12:10:16 <iqubic> Changing the type to "(NotEqual a b) => a -> b -> ()" causes this to still fail.
12:10:25 <geekosaur> you want values not equal at type level, sounds like you're doing types not equal at type level? these are different things
12:11:06 <EvanR> wait... there's a way to do not-equals at the type level?
12:11:21 <erisco> iqubic, because  differentArgs True False  is giving two Bools to differentArgs, which is the same, so it fails
12:11:36 <erisco> Computers just do what you tell them to, after all ;)
12:11:45 <erisco> … on a nominal day.
12:12:17 <geekosaur> EvanR, with a type family, yes. it requires a runtime witness though, whereas type equality is just an alias in the typechecker
12:12:33 <iqubic> Yes... But this still fails: http://dpaste.com/1RY15FZ
12:12:43 <merijn> iqubic: I have no idea what "/=@#@$$$" is :)
12:12:52 <iqubic> It's a thing from Singletons.
12:13:00 <merijn> erisco: Sorta
12:13:05 <merijn> s/erisco/EvanR
12:13:18 <erisco> Well, read the Singletons docs and you can teach us how to use it XD
12:13:21 <geekosaur> not-equals value at the type level should also be possible, but I'm not sure it
12:13:24 <geekosaur> s worth doing
12:13:33 <EvanR> seems like it only has a chance of working if you are operating over a closed subset of types
12:13:39 <merijn> erisco: https://gist.github.com/merijn/6130082
12:13:42 <merijn> dammit
12:13:43 <merijn> irssi
12:13:45 <merijn> work with me here
12:13:51 <merijn> EvanR: ^^
12:14:12 <merijn> EvanR: It breaks horribly when used with polymorphic values (such as numbers)
12:14:26 <EvanR> cool, you can make Constraints with type famiies
12:14:58 <erisco> That's how I train type inference :P
12:15:15 <iqubic> All I'm trying to assert here is that a call to the function "differentArgs :: a -> a -> ()" will only compile if the to arguments have different values.
12:15:32 <EvanR> merijn: whoa... is that a non-linear pattern
12:15:59 <erisco> iqubic, okay, then you are talking about singletons because you will have to lift the values to types.
12:16:26 <iqubic> I know that.
12:16:39 <iqubic> I'm just not sure how to express this constraint properly in Haskell.
12:17:06 <erisco> First you need to create a 1-to-1 correspondence between values and types
12:17:20 <iqubic> I have that.
12:17:28 <erisco> Which is?
12:17:37 <iqubic> I have the singletons library.
12:19:18 <erisco> differentArgs (sing :: Sing 'True) (sing :: Sing "Hello")  is the place to start
12:19:43 <geekosaur> I think they;re expected to be the same type, oitherwise they can't be the same value
12:19:43 <erisco> Can't remember if that is the notation for type strings
12:19:59 <geekosaur> and yes, that's a type level Symbol
12:20:03 <iqubic> They are going to be the same type.
12:20:14 <erisco> If they are the same type then your constraint fails
12:20:23 <erisco> Your whole shtick here is that they cannot be the same type
12:21:37 * geekosaur tried to say that earlier
12:22:03 <iqubic> No. My whole shtick is that they CANNOT BE THE SAME VALUE
12:22:12 <iqubic> They will be the same type.
12:22:17 <erisco> Types and values are interchangeable now because of the 1-to-1 correspondence; unequal values are unequal types and vice versa.
12:22:28 <iqubic> Oh. Right. I see.
12:23:11 <erisco> Now the notion of type equality is lifted to kind equality.
12:23:33 <erisco> You're going to pass two values of different types but with the same kind (being Type)
12:24:02 <erisco> And because these are singletons, passing two different values is the same as passing two different types, and vice versa
12:24:09 <iqubic> I see.
12:25:03 <iqubic> but how do I make sure that both of the values are Singletons of Bools, or both of Singletons of Chars or what have you?
12:25:36 <ggVGc> man I'm having some kind of brain damage, and being out of haskell practice...
12:25:46 <ggVGc> what's the right way to write this?
12:25:54 <ggVGc> inputUIConfs <- (InputSectionPushUI.new push) >>= (return . (: pageInputUIConfs))
12:26:23 <erisco> You're talking about the kind
12:26:34 <erisco> 'True :: Bool, "Hello" :: Symbol
12:27:08 <EvanR> ggVGc: yeesh... try using do notation for the whole thing, no >>= tricks
12:27:24 <erisco> type family NotEqual (a :: k) (b :: k) :: Constraint where …
12:27:30 <erisco> This says both types must have kind k
12:27:35 <iqubic> I have that so far.
12:27:40 <geekosaur> ggVGc, that return stuff looks like it wants to be fmap to me
12:27:55 <EvanR> do x <- y z; return (x:w)
12:28:03 <ggVGc> geekosaur: fuck, I just realised, I did (:) instead if : in the function when I used fmap...
12:28:05 <ggVGc> sorry
12:28:08 <ggVGc> thought I was going crazy
12:28:10 <erisco> Okay, that's all then
12:28:33 <iqubic> What is the body of the type family? What follows the where?
12:28:34 <EvanR> or, fmap (:w) y z
12:28:55 <ggVGc> EvanR: yeah, I did that at fist, but I accidentally did fmap ((:) w)
12:28:59 <ggVGc> hence no deal
12:29:02 <ggVGc> and I'm tired
12:29:05 <erisco> iqubic, both merijn and I have given answers to that above
12:29:09 <EvanR> or, fmap (:w) (y z)
12:29:09 <ggVGc> anyway, ignore me :(
12:29:40 <ggVGc> I often accidentally put parenthesis around operators when fmap:ing
12:29:45 <ggVGc> not sure how to train myself better
12:30:05 <erisco> practice 40 hours a day
12:30:07 <EvanR> "parentheses matter" :(
12:30:18 <EvanR> (: w) vs ((:) w)... what is this lisp
12:30:29 <iqubic> Lisp is good.
12:30:44 <EvanR> drop and give me 40
12:30:56 * ggVGc spanks EvanR with a... Racket
12:32:03 <juri_> If anyone needs me, i'll be in my bunk.
12:32:27 <erisco> I think parentheses have mostly mattered since the beginning of Haskell and theretofore
12:33:15 <erisco> That "precedence" thing
12:35:36 <erisco> But now you suggest to avoid parentheses at all cost!
12:36:21 <EvanR> if each parentheses had a cost... you might
12:38:12 <erisco> What is this? JavaScript?
12:38:28 <merijn> It is if you use enough unsafeCoerce
12:39:13 <erisco> We need a more powerful unsafeCoerce. How so? One that discharges arbitrary constraints.
12:39:37 <EvanR> type level unsafeCoerce
12:39:56 <erisco> Maybe if I just feed unsafeCoerce into Singletons it will figure that out for me.
12:40:54 <merijn> You, a pleb imperative programmer: Haskell is a nice idea, but a language so focussed on safety makes it impossible to do anything...
12:41:22 <merijn> Me, an enlightened Haskeller: Lemme just reallyUnsafePtrEquality# this thing before I decide to YOLO unsafeCoerce it...
12:41:44 <geekosaur> accursedUnutterableCoerce
12:41:58 <merijn> geekosaur: PRs welcome :)
12:42:42 <erisco> I've commented recently that my real job is turning into the finding of new ways to use unsafeCoerce safely.
12:43:18 <merijn> erisco: Comparatively simple compared to using accursedUnutterablePerformIO and reallyUnsafePtrEquality# :p
12:43:42 <EvanR> these names are great
12:43:49 <koz_> Such unsafe.
12:44:01 <erisco> Much power.
12:44:03 <EvanR> java cannot compete on these names
12:44:16 <merijn> EvanR: The first one is from bytestring, the second from ghc-prim
12:44:31 * hackage fakedata 0.3.0 - Library for producing fake data  https://hackage.haskell.org/package/fakedata-0.3.0 (psibi)
12:44:36 <merijn> EvanR: Have you not seen the comment that goes with accursedUnutterablePerformIO?
12:44:37 <erisco> merijn, I am but an apprentice to the dark arts.
12:45:06 <EvanR> i have seen all the things
12:45:31 <merijn> erisco: Baby steps ;)
12:45:42 * EvanR says while wearing dark glasses and staring off into the distance from his chair
12:46:21 <merijn> erisco: You can start by things like ripping pointers out of the guts of ByteString ;)
12:47:02 <EvanR> yes an age old sport, efficiently converting bytestring's bytes into a storable vector of Word8
12:47:09 <EvanR> or vice versa
12:47:18 <merijn> EvanR: Why limit yourself to Word8?
12:47:38 <merijn> EvanR: Just convert to any Storable! https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/src/Utils/Vector.hs#L17-L28
12:47:48 <EvanR> because in C land you can only count on bytes making any damn sense
12:47:56 <EvanR> (assuming 8-bit byte)
12:48:34 <EvanR> who knows what a 2-byte thing is
12:48:45 <merijn> EvanR: Posix mandates 8bit byte and function pointers fitting in void*, so we're good!
12:49:07 <EvanR> who mandates whatever is in 2-bytes makes it from one thing to the other
12:49:17 <merijn> EvanR: But what C wants/thinks is irrelevant for Haskell code :p
12:51:19 <EvanR> hmm... how many different "record" configurations can you make out of a Word8...
12:51:22 <erisco> merijn, laziness is no help to this venture
12:52:04 <EvanR> 127
12:52:35 <EvanR> 128
12:53:59 <erisco> Some might think you're just talking about ORMs. I adored a particular conversation. Apparently, side effects in object constructors is blasphemy, but side effects in property accessors is perfectly cromulent.
12:54:32 <iqubic> How is it that "Sing 'True" and "Sing 'False" have the same types?
12:54:39 <erisco> They don't!
12:54:53 <erisco> Or are you talking about their kinds?
13:07:10 <iqubic> test = differentArgs STrue SNothing
13:07:20 <iqubic> test = differentArgs STrue STrue
13:07:26 <iqubic> Both of those fail to compile.
13:07:32 <iqubic> Which is exactly what I want.
13:07:46 <iqubic> Now, the Singletons need the same kind, but different types.
13:08:39 <EvanR> how does something have a type and a kind at the same time...
13:10:13 <iqubic> It's easy.
13:10:57 <iqubic> :t Just
13:10:58 <lambdabot> a -> Maybe a
13:11:03 <iqubic> :kind Just
13:11:12 <EvanR> :k Just
13:11:14 <lambdabot> a -> Maybe a
13:11:22 <iqubic> How are those the same?
13:11:28 <EvanR> two different Just
13:11:29 <iqubic> :k Maybe Int
13:11:30 <lambdabot> *
13:11:37 <iqubic> EvanR: I see.
13:12:00 <iqubic> So my thing works, even though I don't really understand how.
13:12:14 <EvanR> "that's the beauty of it"
13:21:01 * hackage statistics 0.15.1.0 - A library of statistical types, data, and functions  https://hackage.haskell.org/package/statistics-0.15.1.0 (AlexeyKhudyakov)
13:36:47 <freeman42x> what does the bench cabal-install command do?
13:36:51 <iqubic> @pl \x y -> negate x
13:36:51 <lambdabot> const . negate
13:38:01 <iqubic> That confuses me so much.
13:38:29 <merijn> freeman42x: Run benchmarks
13:39:45 <freeman42x> merijn, what does "run benchmarks" do?
13:39:52 <freeman42x> how do you define benchmarks? and what do they do?
13:42:49 <merijn> freeman42x: You can define benchmark components in your cabal file the same way you define tests
13:42:57 <merijn> but...you know, benchmarks
13:43:20 <freeman42x> merijn, but what do they do? run some of your code and check how much time or space or something they took?
13:43:55 <merijn> freeman42x: They run whatever you put into said benchmarks...
13:44:24 <freeman42x> merijn, that tells me nothing lol
13:46:25 <iqubic> @pl \x y -> negate x
13:46:25 <lambdabot> const . negate
13:46:32 <iqubic> Why does that work like that?!?!
13:47:02 <lavalike> because it takes the x, then ignores the y
13:47:03 <[exa]> why not tho?
13:47:43 <lavalike> @src const
13:47:43 <lambdabot> const x _ = x
13:47:48 <merijn> freeman42x: I mean, "what do tests do?"
13:47:51 <monochrom> freeman42x: It probably is just another executable of your choice that does whatever you want, but you signify that its intention is benchmarking.
13:47:57 <[exa]> iqubic: pointfree conversion is straightforward, all you need is a few primitives (flip, (.), const and S aka <*>)
13:48:08 <freeman42x> shruggs
13:48:39 <monochrom> It is a human social vague open-ended notion not a formal mathematical definition.
13:49:11 <monochrom> Even "test" is a bit more formal than that because at least cabal will take a look at the exit code.
13:49:57 <erisco> Formal semantics one exit code at a time.
13:50:30 <monochrom> OTOH cabal is not going to check that your test program is non-trivial.
13:51:59 <erisco> Why not just <*> and pure [exa]
13:54:20 <int-e> erisco: because that would produce longer code. (also @pl predates applicative, so it uses `const` (shorter than `return`) for K and `ap` for S)
13:54:53 <erisco> But, you can always shorten the code by adding more combinators.
13:55:05 <sm[m]> freeman42x it’s a good question, cabal allows you to define “benchmark suites”, similar to test suites but different, but nothing really makes use of them
13:55:11 <sm[m]> I just disabled mine today
13:55:24 <dminuoso> @nil Monoidal admits instances for invariant functors that Applicative does not.
13:55:24 <lambdabot> Maybe you meant: url unpl pl id bid
13:55:25 <erisco> I thought @pl was a little more free-form than that.
13:55:26 <dminuoso> @tell nil Monoidal admits instances for invariant functors that Applicative does not.
13:55:26 <lambdabot> Consider it noted.
13:55:42 <freeman42x> sm[m], do you happen to know of any place where someone explains what exactly this benchmarks are doing?
13:55:47 <erisco> @pl \f g x -> (f x, g x)
13:55:47 <lambdabot> liftM2 (,)
13:56:15 <int-e> @pl f x = 1+x
13:56:16 <lambdabot> f = (1 +)
13:56:24 <int-e> @pl f x = 1+f x
13:56:24 <lambdabot> f = fix ((1 +) .)
13:56:31 <sm[m]> Now if you make your benchmarks a test (performance test), that would be more useful to run as part of CI etc. Benchmarks that just measure, are something you run yourself when optimizing
13:56:37 <nil> dminuoso: what is this in reaction to?
13:56:38 <erisco> Well obviously doesn't know &&& but does know the lifts
13:57:04 <erisco> I thought it might have worked more arbitrarily from a database of known definitions
13:57:24 <dminuoso> 14:09:28   dminuoso | d12frosted: If you want to do this *very* easily, you could implement it in terms of `class Functor f => Monoidal f where plus :: f a -> f a -> f (a, a), unit :: f ()` (which is nearly isomorphic to Applicative)
13:57:26 <dminuoso> 15:15:33        nil | [12:38:23] dminuoso: why "nearly"?
13:57:29 <sm[m]> freeman42x I can point you to my own small benchmark suite and answer questions
13:57:32 <Clint> freeman42x: typically people use criterion
13:57:43 <int-e> erisco: I'm pretty sure it's all hard-coded rewrite rules that attempt to simplify expressions.
13:57:49 <sm[m]> Otherwise no, I don’t know of any discussion of it. Maybe in the cabal manual
13:58:00 <freeman42x> sm[m], that would be great. Could you link that please?
13:58:23 <int-e> erisco: I don't know... is it possible that you're mixing this up with djinn? That has /some/ extensible database attached...
13:58:57 <dminuoso> nil: So if we just consider covariant functors, they are isomorphic.
13:59:09 <nil> ah
13:59:20 <nil> what's an example of an invariant functor?
13:59:23 <erisco> I just never heard someone talk about the implementation of @pl in particular before
13:59:55 <dminuoso> nil: Check https://hackage.haskell.org/package/invariant
14:01:04 <erisco> So then there is room for a new point… remover(?) that is backed by the wealth of Hoogle knowledge.
14:01:12 <sclv> freeman42x: https://cabal.readthedocs.io/en/latest/developing-packages.html?highlight=benchmark#benchmarks
14:01:21 <dminuoso> % :t flip (const fmap) -- nil: essentially this.
14:01:22 <yahb> dminuoso: Functor f => (a -> b1) -> b2 -> f a -> f b1
14:01:35 <erisco> You might need to install 50 seemingly unrelated dependencies, but think of the possibilities!
14:01:47 <sm[m]> freeman42x: https://github.com/simonmichael/hledger/blob/master/hledger/package.yaml#L215 defines one benchmark suite, whose code is in https://github.com/simonmichael/hledger/blob/master/hledger/bench/bench.hs . It just runs a few time-consuming operations and prints the times to stdout. Nobody uses that output.
14:01:57 <dminuoso> nil: Is an example of how every covariant functor is also invariant.
14:02:25 <dminuoso> nil: (It's more obvious if you think of `b2` as `b1 -> a`)
14:02:35 <nil> i get this
14:02:48 <nil> i don't see how Applicative and Monoidal are different yet
14:02:50 <sm[m]> https://github.com/simonmichael/hledger/blob/master/hledger/hledger.cabal#L299 is the longer cabal file definition, that the package.yaml generates
14:03:09 <nil> what's a Monoidal instance for an Invariant funtcor
14:03:11 <nil> functor*
14:03:15 <dminuoso> nil: I dont recall the specific example actually. I just know that some invariant functors can give valid Monoidal instances but not Applicative instances.
14:04:03 <nil> that sounds very dubious to me :/
14:04:04 <sm[m]> For actual benchmarking, I use https://hackage.haskell.org/package/timeit (in GHCI), and https://hackage.haskell.org/package/quickbench (with compiled executables)
14:04:16 <nil> i mean, can't you always get an Applicative instance from a Monoidal one?
14:04:24 <nil> why would the usual conversion stop working for certain functors?
14:04:52 <nil> oooh, pure requires fmap
14:05:14 <nil> pure x = fmap x unit
14:05:48 <dminuoso> nil: I think it was all invariant functors that are not covariant? But indeed that looks like the reason.
14:06:17 <dminuoso> nil: You are missing a const by th eway.
14:06:25 <dminuoso> nil: It should be `pure x = x <$ unit`
14:06:32 <nil> er, yeah
14:06:39 <merijn> sm[m]: You should use criterion for benchmarking, tbh :p
14:06:48 <merijn> sm[m]: timeit currently just returns CPU time
14:07:10 <sm[m]> Not always the best for me.. the others are useful
14:07:11 <dminuoso> nil: Im still debating whether thats a fact I should ignore. Its probably not as relevant in regular Haskell discussions..
14:07:13 <merijn> sm[m]: If I ever get around to it, I'm extending it with wallclock time too, since I need that
14:07:25 <sm[m]> +1
14:07:50 <freeman42x> sm[m], thank you
14:08:00 <merijn> sm[m]: PRs welcome ;) (I adopted it from Lennart to add some stuff for myself, but I'm open to suggestions ;))
14:09:05 <erisco> CPU time being clock cycles? So just multiply by a cycle duration? Assume fixed frequency cores? Hm.
14:09:11 <sm[m]> Great, thanks for maintaining. It has been getting better
14:10:17 <merijn> erisco: It means "time actually running"
14:10:23 <merijn> erisco: i.e. "time not blocked on IO"
14:10:26 <sshine> I wonder how you can reliably compare CI'ed benchmark suites.
14:10:36 <erisco> Oh, so it refers to scheduler queues
14:10:59 <merijn> That too
14:12:31 <sm[m]> even better, perhaps I should say. freeman42x https://hackage.haskell.org/package/bench is another for your toolbox
14:12:48 <nil> dminuoso: it seems to me like Monoidal and Applicative could each be "cut" into two typeclasses: Monoidal m is (Unit m, Combine m), where Unit defines unit and Combine defines (>*<), and Applicative f is (Pure f, Apply f), where Pure defines pure and Apply defines (<*>)
14:13:10 <iqubic> nil: Monoid is cut into Unit and Combine.
14:13:36 <sclv> applicative is a sort of "higher monoid" so they're very similar
14:13:36 <iqubic> We call them Combine is Semigroup and Monoid adds Unit
14:13:46 <sm[m]> sshine: probably not reliably unless you control the hardware.. but in practice, it would probably be consistent enough to be useful
14:14:10 <nil> then we could say Combine and Apply are entirely equivalent, but Pure is not equivalent to Unit (instead, Functor and Unit imply Pure)
14:14:18 <sm[m]> GHC has automated performance tests, I think
14:15:00 <freeman42x> sm[m], cheers man. how do I give you Karma?
14:15:11 <iqubic> nil: Look at the types. I don't Combine and Apply are equivalent
14:15:15 <iqubic> :t (<*>)
14:15:17 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:15:20 <iqubic> :t <>
14:15:22 <lambdabot> error: parse error on input ‘<>’
14:15:26 <freeman42x> @karma+ sm[m]
14:15:26 <lambdabot> sm[m]'s karma raised to 1.
14:15:27 <sm[m]> sm++ ? I will try :)
14:15:30 <iqubic> :t (<>)
14:15:31 <nil> iqubic: i'm talking about (>*<), not (<>)
14:15:31 <lambdabot> Semigroup a => a -> a -> a
14:15:33 <sm[m]> Woot!
14:15:43 <iqubic> :t (>*<)
14:15:45 <lambdabot> error:
14:15:45 <lambdabot>     • Variable not in scope: >*<
14:15:45 <lambdabot>     • Perhaps you meant one of these:
14:15:50 <iqubic> I don't know that.
14:15:59 <nil> https://hackage.haskell.org/package/invertible-0.2.0.5/docs/Control-Invertible-Monoidal.html#v:-62--42--60-
14:16:30 <erisco> @karma- erisco
14:16:30 <lambdabot> You can't change your own karma, silly.
14:16:42 <iqubic> @karma+ iqubic
14:16:42 <lambdabot> You can't change your own karma, silly.
14:16:51 <erisco> They told me I was the chosen one! I was the one to balance the karma!
14:16:54 <nil> third time's the charm?
14:17:00 <iqubic> @karma- erisco
14:17:00 <lambdabot> erisco's karma lowered to 5.
14:17:07 <iqubic> WHAT?!?!
14:17:08 <erisco> Phew!
14:17:45 <erisco> Yeah, when someone displeases me I remove their karma and force them to give me it.
14:18:15 <iqubic> @karma- erisco
14:18:15 <lambdabot> erisco's karma lowered to 4.
14:18:40 <nil> dminuoso: actually, that's not even true
14:18:56 <erisco> Stop causing cosmic imbalances iqubic.
14:18:59 <nil> Apply and Combine aren't equivalent: the map from Combine to Apply requires fmap too
14:20:04 <iqubic> @karma+ erisco
14:20:04 <lambdabot> erisco's karma raised to 5.
14:20:05 <EvanR> whenever you decrement someone's karma, it decrements your own (not reflected in lambdabot). I sense a deflationary spiral coming on
14:20:14 <iqubic> Balence restored.
14:28:33 <zfnmxt> @karma+ zfnmxt
14:28:34 <lambdabot> You can't change your own karma, silly.
14:28:41 <zfnmxt> :)
14:37:14 <koz_> lambdabot is smart.
14:38:07 <erisco> @tell lambdabot @karma+ lambdabot
14:38:07 <lambdabot> Nice try ;)
14:38:32 <erisco> I agree.
14:39:09 <koz_> :t iterate
14:39:09 <quiet_laika[m]> anyone using ghcide? i got an error: `ghcide: target ‘(Control.Applicative,’ is not a module name or a source file` on running the bare command, so i imagine i need to do some closer looking at whats going on with hie-bios, but i was curious if anyone had seen this specifically already
14:39:11 <lambdabot> (a -> a) -> a -> [a]
14:39:58 <quiet_laika[m]> @src iterate
14:39:58 <lambdabot> iterate f x = x : iterate f (f x)
14:46:32 <argent0> GHC works in mysterious ways some times. Apprently I lack a symbol on a library but I check for my self and the symbol seems to be there. Worst part is that such problem is `un-searchable`.
14:46:56 <argent0> https://bpaste.net/show/Cizi
14:49:23 * argent0 pkg-config --cflags SDL2_gfx # works
14:55:11 <argent0> and then there is the `base distribution -> nix -> (cabal, pkg-config, lib, ghc)` stack.
14:56:27 * argent0 is not complaining. Just commenting on the issue.
15:04:30 * hackage statistics 0.15.1.1 - A library of statistical types, data, and functions  https://hackage.haskell.org/package/statistics-0.15.1.1 (AlexeyKhudyakov)
15:20:31 * hackage streaming-events 1.0.0 - Client-side consumption of a ServerEvent.  https://hackage.haskell.org/package/streaming-events-1.0.0 (fosskers)
15:49:45 <iqubic> Depedent Types are cool, but you shouldn't reach for them for every single task you do.
15:51:44 <iqubic> I just spent like 3 hours trying to do something, and ultimately decided that it would be easier to just do this without dependent types.
15:52:03 <beka> whatd you try to do?
15:55:00 * hackage net-mqtt 0.5.0.1 - An MQTT Protocol Implementation.  https://hackage.haskell.org/package/net-mqtt-0.5.0.1 (dustin)
15:55:01 <dsal> hi
15:55:19 <dsal> Man.  I was hoping that'd come through after I said hi so I could talk to the hackage bot.
15:55:57 <iqubic> beka: I spent quite some time trying to create a proof that two given Singletons were different types.
15:56:10 <koz_> iqubic: Yeah, that's not going to be easy.
15:56:15 <koz_> What did you need that for?
15:56:39 <beka> i'm confused by ok
15:56:50 <beka> i mean what did you want to use dependent types for
15:56:55 <beka> not what convinced you to stop
15:57:13 <beka> dsal: you can probably just message `hackage`???
15:57:38 <dsal> /msg hackage thank you for hosting my packages
15:58:28 <iqubic> koz_: I'm not sure?
15:59:19 <koz_> iqubic: Well, if you dunno why you're doing something, it's not a good sign. 'Practice' or 'learning' or 'seeing what will happen' however, _are_ valid answers.
16:00:23 <iqubic> I was trying to learn about Dependent types.
16:00:53 <koz_> iqubic: I would say that it's probably a bit too hard a jump.
16:01:04 <koz_> As with anything, you wanna start off small and simple.
16:01:10 <koz_> That's... neither of those things. :P
16:01:32 <iqubic> I know.
16:01:40 <iqubic> Type inequality is a pain.
16:02:23 <koz_> If you wanna improve your dependent-type-fu, I would suggest doing the Introduction to Singletons exercises.
16:02:29 <koz_> They'll help you see how these things tick.
16:03:50 <iqubic> I have done those.
16:16:02 <EvanR> "type inequality" doesn't sounds like a very interesting avenue...
16:16:18 <iqubic> I know.
16:19:32 <basic> why is having datatypes that have constraints a bad idea?
16:22:05 <hpc> if you do it the typical way, it's not knowledge you gain by using the data type
16:22:15 <hpc> it's something you're forced to deal with at every use site
16:22:42 <hpc> so for example if you had data Ord a => Set a = ...
16:23:10 <hpc> you don't get to just say difference :: Set a -> Set a -> Set a
16:23:43 <hpc> if you really want a datatype with a constraint attached to it, check out GADTs
16:24:42 <basic> i don't understand how GADTs help me with that
16:24:45 <basic> the thought i had was
16:25:09 <basic> if i was about to define a Graph Type, like i learned in university, i would have 2 lists, one for vertices and one for edges
16:25:39 <basic> how would i make sure there would be no "illegal" states like edges to vertices that doesn't exist?
16:26:05 <EvanR> if you want a typed graph, you might want to try associated types
16:26:10 <EvanR> of a type class
16:26:22 <basic> well it is an example, for a problem i think about more often
16:26:35 <EvanR> oh, if you want to ensure a graph is well formed, then you will need something more sophisticated
16:26:36 <basic> i could make sure that doesn't work in functions that manipulate that datatype
16:28:04 <EvanR> there's something called inductive graphs which are built piece by piece in a way that is well formed
16:28:34 <basic> im not really trying to create graphs, im rather interested in the constraint thingie
16:28:41 <EvanR> hum...
16:28:44 <basic> because i keep stumbling upon it over and over
16:28:56 <basic> imagine i have the constructor "Test Integer"
16:28:59 <iqubic> I'm now using finite type nats here.
16:29:16 <basic> and i want only odd integers, how would i define that
16:29:19 <basic> stuff like that
16:29:36 <EvanR> value constraints eh
16:29:43 <basic> sure i can abstract that problem away, but that's what i did in all the other programming languages too
16:30:00 <basic> it's something i expected haskell to have
16:30:05 <EvanR> there are different ways, with varying levels of "omg please make it stop"
16:30:29 <basic> how do the 2 extremes of that spectrum sound :D
16:30:32 <EvanR> a middling such way would be to check out liquid haskell
16:31:05 <EvanR> it's a language with these value constraints built in
16:31:42 <basic> and what we're using is solid haskell?
16:31:55 <EvanR> yeah
16:31:57 <EvanR> lol
16:32:34 <EvanR> a basic way to do what youre saying in haskell is to define an abstract data type, hide the raw constructors, and export an API that guarantees correct usage
16:33:01 <EvanR> the module where the API is implemented would stand as the "kernel of trust" that you can only have even numbers 
16:33:38 <EvanR> for instance there would be no +1 function in the API
16:33:48 <basic> yeah you're describing what i meant by saying "abstract it away"
16:33:51 <EvanR> but there would be a multiplication
16:34:22 <EvanR> this pattern is nicer in haskell than more mainstream languages, imo
16:34:44 <EvanR> it has the benefit of being very easy to understand
16:35:59 <EvanR> turning up the complexity knob, you can use type classes to put constraints on runtime values that can technically be checked at compile time
16:36:26 <EvanR> which leads to sometimes having to do type level programming to form proofs that constraints are satisfied
16:37:20 <EvanR> be prepared for "is even" constraint to result in doing number theory, but with a really weird syntax
16:38:35 <EvanR> another way is to use dependent types, but they aren't in haskell yet
16:43:48 <basic> thanks for the hints into the right direction
16:44:03 <basic> that's i wanted to hear, thanks alot and goodnight!
16:45:02 <EvanR> personally this seems simplest... newtype Even = MkEven Integer; double i = MkEven (2 * i); fromEven (MkEven i) = i; and do not export MkEven
16:45:09 <EvanR> :'(
16:49:28 * dmwit . o O ( data Odd = One | TwoPlus Odd )
16:49:45 <iqubic> How does one use 'natVal' from GHC.TypeLits to convert from a type level Nat to a value level Natural?
16:49:46 <EvanR> and Negate
16:49:55 <dmwit> Nah. Positive numbers ought to be enough for anybody.
16:50:16 <dmwit> % natVal @32 Proxy
16:50:17 <yahb> dmwit: ; <interactive>:65:1: error: Variable not in scope: natVal; <interactive>:65:1: error:; * Cannot apply expression of type `t1'; to a visible type argument `32'; * In the expression: natVal @32 Proxy; In an equation for `it': it = natVal @32 Proxy
16:50:23 <EvanR> (now what algebra is there to express primes)
16:50:24 <dmwit> % import GHC.TypeLits
16:50:24 <yahb> dmwit: 
16:50:34 <dmwit> % import Data.Proxy
16:50:35 <yahb> dmwit: 
16:50:39 <dmwit> % natVal @32 Proxy
16:50:39 <yahb> dmwit: 32
16:50:52 <dmwit> % natVal (Proxy :: Proxy 32) -- or the way it's meant to be used
16:50:52 <yahb> dmwit: 32
16:51:06 <iqubic> % natVal (Proxy @32)
16:51:06 <yahb> iqubic: 32
16:51:10 <iqubic> Huh???
16:51:22 <dmwit> What did you expect?
16:51:59 <dmwit> (...and "Why did you expect that?", I guess.)
16:52:15 <iqubic> I don't know.
16:53:12 <dmwit> If you had no expectations, why did you express surprise?
16:53:38 <iqubic> Now, is it possible to convert a Natural into an Int?
16:53:53 <iqubic> % :t natVal (Proxy @32)
16:53:53 <yahb> iqubic: Integer
16:54:03 <iqubic> Why is that an integer?
16:55:12 <iqubic> yahb: is giving me different results than here than I am getting in GHCi.
16:56:04 <iqubic> I have no idea why that is an integer.
16:59:55 <iqubic> http://dpaste.com/02MJBTX
17:00:05 <iqubic> Yeah. I have no idea what's going on there.
17:04:35 <dmwit> The type was changed in a recent release of base.
17:04:45 <dmwit> It's not a big deal. Just look at the documentation of Natural and you'll see why.
17:09:14 <iqubic> So what should I do here?
17:09:42 <koz_> iqubic: If you use GHC.TypeLits, you get Integers from 'singing down' Nats.
17:09:50 <koz_> If you use GHC.TypeNats, you get Naturals.
17:09:54 <iqubic> Oh. I see.
17:10:51 * koz_ uses GHC.TypeNats pretty much everywhere.
17:10:57 <koz_> Other folks' mileage may, and does, vary.
17:12:02 <iqubic> upperBound :: Int
17:12:18 <iqubic> So how do I convert from a Natural to an Int?
17:12:54 <koz_> :t fromIntegral
17:12:55 <lambdabot> (Integral a, Num b) => a -> b
17:13:13 <koz_> This munges anything with an instance of Integral into anything with an instance of Num.
17:13:22 <koz_> Unsurprisingly, Natural is an instance of Integral.
17:13:28 <koz_> And Int is an instance of Num.
17:13:54 <koz_> (it must be noted that this munging is possibly lossy - Natural can store values much larger than any Int could fit)
17:14:48 <iqubic> koz_: I know.
17:15:43 <iqubic> Why are there no instance for (Show Nat) and (Eq Nat)?!?
17:15:48 <iqubic> This is an outrage.
17:16:11 <koz_> iqubic: Because Nats exist at the type level.
17:16:15 <koz_> What on earth are you gonna show?
17:17:13 <iqubic> I'm not sure.
17:17:26 <koz_> Nobody else either.
17:17:38 <koz_> If you wanna show it as a number, sing it down into something at the value level, then Show that.
17:17:44 <koz_> You have an embarassment of options. :P
17:19:05 <iqubic> How come the library finite-typelits has a Show instance for it's Finite datatype?
17:20:16 <iqubic> Oh, that's because 'Finite (n :: Nat)' has n inhabitants. And you can show each inhabitant.
17:20:21 <koz_> iqubic: Because Finite n has values at the value level.
17:20:50 <iqubic> I just stated that.
17:21:27 <koz_> I didn't see it till I hit 'Enter'.
17:21:39 <koz_> The whole 'distributed systems only have a relative notion of time' problem strikes again! :P
17:21:46 <iqubic> I know.
17:21:54 <iqubic> Now, time to see if my code works.
17:22:31 <pinecamp> is there an equivalent of Control.Monad's `when` function that is conditional on the type of an expression?
17:22:40 <Clint> what?
17:23:34 <pinecamp> I'm checking for an environment variable with System.Environment.lookupEnv, which returns (Maybe String). If it returns Nothing, I want to exit the program. Otherwise I don't want to do anything
17:23:59 <pinecamp> I could do a case expression, but was hoping there's something more like `when`
17:24:46 <iqubic> There is.
17:24:49 <jle`> hm, the analogy of 'when' for Maybe is probably forM_
17:24:57 <iqubic> :t isJust
17:24:59 <lambdabot> Maybe a -> Bool
17:25:15 <iqubic> :t when
17:25:16 <lambdabot> Applicative f => Bool -> f () -> f ()
17:25:24 <iqubic> when (isJust maybe) f
17:25:33 <iqubic> I think that should work.
17:25:58 <jle`> similarly  forM_ would let you pass in the value 'inside' the Maybe if it's a Just, if you want to use it
17:26:03 <iqubic> :t isNothing
17:26:04 <lambdabot> Maybe a -> Bool
17:26:09 <iqubic> right.
17:26:11 <jle`> forM_ :: Maybe a -> (a -> IO ()) -> IO ()
17:26:42 <jle`> but if you want to actually specify behavior on the case of Nothing (like 'program exiting'), pattern matching wouldn't be too bad
17:26:49 <iqubic> forM_ maybe (\just -> whatever) -- maybe and just are just variables here.
17:28:51 <pinecamp> when (isNothing maybe) totally works here, thanks!
17:29:32 <pinecamp> I do end up using the value when it's a Just, but I'm not quite following the use of forM_ in this cse
17:30:19 <jle`> % forM_ Nothing (\x -> putStrLn x)
17:30:19 <yahb> jle`: 
17:30:30 <jle`> % forM_ (Just "hi") $ \x -> putStrLn x
17:30:30 <yahb> jle`: hi
17:30:45 <Clint> :t maybe
17:30:46 <lambdabot> b -> (a -> b) -> Maybe a -> b
17:30:47 <jle`> so you can use the "hi" inside the Just
17:30:54 <iqubic> What's the line I put at the top of my to get warnings on incomplete pattern matches?
17:31:19 <jle`> the flag is -Wwarn=incomplete-patterns, but i recommed -Werror=incomplete-patterns
17:31:37 <jle`> pinecamp: so when you do `forM_ myMaybe $ \x -> .....`, you are back inside IO in the ...
17:31:37 <iqubic> How do I enable that on a per file basis?
17:31:49 <jle`> pinecamp: so you can use 'x', the value in the Just
17:31:57 <iqubic> Or do you recommend adding that flag to my *.cabal file?
17:32:19 <jle`> {-# OPTIONS-GHC -Wwarn=... #-}, i think? i usually tab-complete it, heh
17:32:20 <koz_> :t evalState
17:32:21 <lambdabot> State s a -> s -> a
17:33:10 <dmwit> :t maybe (die "eek") pure
17:33:11 <lambdabot> error:
17:33:11 <lambdabot>     • Variable not in scope: die :: [Char] -> f a
17:33:11 <lambdabot>     • Perhaps you meant ‘div’ (imported from Prelude)
17:33:16 <pinecamp> jle`: so with this approach, I would use forM_ in a pattern-matched function of type Maybe String -> IO ()
17:33:17 <dmwit> :t maybe (System.Exit.die "eek") pure
17:33:18 <lambdabot> Maybe a -> IO a
17:33:20 <pinecamp> ?
17:33:47 <jle`> pinecamp: i'm not sure what you mean by a pattern-matched function
17:33:57 <jle`> pinecamp: but it looks like you already have your 'maybevalue' named and bound, right?
17:34:03 <dmwit> :t \f v -> do { Just x <- v; f x }
17:34:03 <jle`> so in the same situation where you would do:
17:34:04 <lambdabot> Control.Monad.Fail.MonadFail m => (t -> m b) -> m (Maybe t) -> m b
17:34:09 <jle`> when myMaybe $ ....
17:34:11 <jle`> instead do:
17:34:14 <jle`> forM_ myMaybe $ \x -> ...
17:34:24 <iqubic> Right... Well. GHC doesn't understand the Finite-Typelits package.
17:34:41 <pinecamp> jle`: right, it's named and bound. I'm all in a do block in IO here. let me just do a pastebin real quick, I think it will help show usage
17:34:51 <pinecamp> what I have works, I just want to understand what you mean with forM_ :)
17:35:16 <jle`> it looks like you already know how to use 'when', right?
17:35:30 <pinecamp> https://pastebin.com/ceXcyWXx
17:35:41 <pinecamp> yes, I'm pretty clear on 'when'
17:35:59 <jle`> ah, you want to do something when it's Nothing
17:36:06 <jle`> it looks like you don't actually ever do anyhting with the value inside
17:36:25 <jle`> why is getPoliceIncidents expecting a Maybe Text, instead of just a Text?
17:37:08 <pinecamp> jle`: I do end up using the value inside though, in the next line after the when
17:37:27 <jle`> you just have the whole Maybe value used
17:37:28 <pinecamp> and that's a fair question; it should probably just expect Text
17:37:40 <pinecamp> ahh true
17:37:40 <jle`> so you never really need the value inside the Just
17:38:31 <pinecamp> I see what you're saying. so if I changed the signature of getPoliceIncidents to expect Text, I would want the value
17:38:37 <pinecamp> (inner value)
17:38:48 <iqubic> Yeah... GHC doesn't really understand pattern matching on a finite in this manner: http://dpaste.com/368QY0T
17:39:17 <dmwit> pinecamp: You may like https://stackoverflow.com/q/33005903/791604
17:39:58 <dmwit> pinecamp: tl;dr convert your IO (Maybe a)'s and IO (Either Error a)'s all into ExcepT Error IO a's. Then just use plain do syntax and a single top-level error-handler.
17:40:23 <pinecamp> thanks dmwit, I'll read through
17:40:24 <jle`> iqubic: indeed the 0 pattern is just sugar for n | n == 0 -> ..
17:40:32 <iqubic> I know.
17:40:58 <jle`> pinecamp: yeah, if getPoliceIncidents expects Text, then you would need the inner value
17:41:13 <jle`> pinecamp: but as your program is structured, you want to do something separate for Nothing, and also for Just
17:41:17 <iqubic> But it is impossible for getFinite to return anything outside the range 0 <= x < 3
17:41:28 <iqubic> Because that's what it means to be finite.
17:41:35 <jle`> pinecamp: so the best way (besides using MaybeT/etc. to change >>='s behavior) is just to case match 
17:41:46 <jle`> iqubic: that is also true, but GHC doesn't know that
17:41:50 <jle`> look at the type:
17:41:57 <iqubic> I know. I know.
17:41:57 <jle`> getFinite :: Finite n -> Integer
17:42:14 <jle`> ah, did you have a question then?
17:42:21 <iqubic> So in this case, I'm just going to switch off the error there.
17:42:41 <jle`> alternatively if you're "sure" you handle all of the cases, you can add a wildcard case at the end
17:42:45 <pinecamp> thanks for the informative advice jle` (and iqubic!) I'll look into MaybeT / ExceptT for sure
17:43:01 <jle`> iqubic: this is nice because you document the fact that you are proving the case 'in your head' 
17:43:05 <jle`>  1 -> ..
17:43:13 <jle`>  _ -> error "this should never happen"
17:43:18 <iqubic> Well, I was just wondering if there was another way of dealing with this, besides just ignoring the fact that GHC can't determine that I have a complete pattern match.
17:43:25 <jle`> then also if you ever accidentally throw the error off, you'll get a nicer error message
17:43:38 <jle`> and it'll help you re-assess your assumptions
17:43:45 <dmwit> iqubic: Consider `{-# COMPLETE 0, 1, 2 :: Finite 3 #-}`.
17:44:02 <dmwit> ...and then don't call getFinite.
17:44:17 <iqubic> dmwit: I'd have to do that for every single Finite n, though.
17:44:24 <jle`> iqubic: if you disable warnings now, when you read your code again in six months, you might not necessarily know immediately what's going on when you see an incomplete pattern
17:44:33 <iqubic> Also, what does that COMPLETE line do?
17:44:37 <jle`> iqubic: but if you leave warnings/errors on, and then add the _ -> error "should not happen because Finite 3"
17:44:48 <jle`> then you will know yourself when you look back on it in six months :)
17:45:27 <dmwit> iqubic: Throws an error, because I was lazy about reading the documentation. =)
17:46:11 <iqubic> I wish that we could teach GHC to understand Finites in the same way that it understands Nats.
17:46:45 <shachaf> Speaking of pragmas, has someone proposed line pragmas, like "--# INLINE foo"?
17:47:18 <iqubic> Why can't you use the current syntax?
17:47:29 <dmwit> > let x --# y = "no" in "is shachaf being" --# "careful"
17:47:31 <lambdabot>  "no"
17:48:09 <dmwit> But perhaps -- # would be okay.
17:48:16 <shachaf> dmwit: Are you suggesting I didn't consider that?
17:48:19 <dmwit> Still a little bit scary in the back-compat sense.
17:48:27 <iqubic> Most things are.
17:48:56 <shachaf> I'd be OK with -- # too. Though in GHC {-# #-} is syntactically not a comment.
17:48:56 <dmwit> I am suggesting that if you considered it, you did not assign the correct weight to the outcome that GHC folks reject it for not being back-compatible.
17:49:18 <shachaf> "-- #" is also not back-compatible.
17:49:27 <dmwit> ...as I noted.
17:49:37 <shachaf> True.
17:50:15 <shachaf> But I'd be OK with, for example, requiring {-# LANGUAGE LinePragmas #-} at the top of the file to enable it.
17:50:17 <dmwit> There's really very little reason to want it in the first place, I think.
17:50:29 <shachaf> (That was the thing I was imagining in the first place.)
17:50:54 <shachaf> (Like {-# LANGUAGE CPP #-}.)
18:27:09 <iqubic> I'm so tired of having this litter my code: (fromIntegral $ getFinite n)
18:27:26 <iqubic> Can't getFinite just please return an Int?
18:28:31 <jle`> why not just fromIntegral n
18:29:07 <iqubic> Does that work?
18:29:22 <iqubic> Oh. Yes it does.
18:31:05 <jle`> one drawback is that it requires KnownNat n
18:31:58 <iqubic> How is that a drawback?
18:32:21 <jle`> sometimes you might not have KnownNat n
18:32:28 <iqubic> Why not?
18:32:41 <jle`> foo :: Finite n -> IO ()
18:33:09 <iqubic> foo :: KnownNat n => Finite n -> IO ()
18:33:23 <iqubic> won't that work?
18:33:30 <jle`> if you can control the type signature yes
18:35:30 <dmj`> so hard to control types these days, they got minds of their own.
18:35:33 <dmj`> "when the types take over"
18:36:18 <iqubic> Is there a function that takes an input list, an index, and an element, and replaces the element at that location?
18:36:36 <iqubic> Like a function in base?
18:36:43 <jle`> for [a] lists? not by default, since it's somewhat of a misuse of the list data type
18:37:07 <iqubic> Why do you say it's a misuse?
18:37:09 <jle`> lists aren't really meant for random access
18:37:22 <iqubic> And what do you recommend instead?
18:37:24 <jle`> they're really bad at it, and needing it is a good sign to look for a different data type
18:37:44 <jle`> there's Vector, Seq, Array, etc.
18:38:02 <iqubic> I see. Thank you for your help.
18:38:21 <jle`> so the lack of such a function in base is meant to gently 'persuade' you to pick another type
18:38:27 <jle`> even though it's possible to write, technically
18:39:18 <iqubic> why do both vector-sized and sized-vector exist?
18:39:49 <jle`> they are different packages offering different types
18:40:00 <jle`> but also one is deprecated
18:40:06 <jle`> so i wouldn't really say it 'exists' anymore necessarily
18:40:06 <iqubic> Ah. I see.
18:40:29 <iqubic> What do you recommend for length indexed random access structures?
18:40:49 <dmj`> Vector
18:41:22 <iqubic> https://hackage.haskell.org/package/vector-sized
18:41:24 <iqubic> this?
18:41:27 <jle`> vector-sized is probably the only option for total length-indexed random access 
18:41:32 <jle`> alternatively Map (Finite n)
18:41:39 <iqubic> Ewww...
18:41:42 <jle`> for potentially empty values
18:41:46 <jle`> what's wrong with Map?
18:41:47 <iqubic> That looks awful.
18:42:15 <jle`> Map is one of the most well-engineered and useful types in the haskell ecosystem :)
18:42:56 <jle`> it's a work of art D:
18:43:02 <iqubic> The only time I ever used Map was when I was making a toy inteperter for some esoteric programming language and I needed a map from Text (names) to Types (values)
18:43:20 <iqubic> I found that really really clumsy to use.
18:43:21 <jle`> Map is...one of the most used types in Haskell
18:43:48 <iqubic> Maybe I'm misremembering that, because I was still fairly new to Haskell at the time.
18:44:21 <iqubic> And I might be conflating my lack of haskell skills at that time with my lack of knowledge of how to use Map.
18:47:30 * hackage lzlib 0.1.1.0 - lzlib bindings  https://hackage.haskell.org/package/lzlib-0.1.1.0 (vmchale)
18:54:15 <weilawei> Couple weeks ago I had the question put to me that, if guards were *like* the different portions of a domain of a piecewise function, what's the theoretical underpinning (in the simplest terms possible) that allows them to have an ordering that changes the function's value at runtime (we were discussing it using FizzBuzz as our pinata)?
18:54:30 <weilawei> I couldn't answer it well, so I figured I'd better be learning myself
18:55:24 <iqubic> I'm surprised that the @ pattern works like this: http://dpaste.com/0EG0TKS
18:56:10 <iqubic> I do get warnings for incomplete pattern matches, but that's fine.
18:57:00 * hackage lzlib 0.1.1.1 - lzlib bindings  https://hackage.haskell.org/package/lzlib-0.1.1.1 (vmchale)
18:58:45 <weilawei> I should say, I couldn't answer it at all; the best I could do was find a very technical paper by SPJ. So I'm hoping to learn
19:05:08 <koz_> weilawei: The ordering creates implicit conjunctions of negations of previous matches.
19:05:41 <koz_> So a given match means 'this AND NOT [the one prior] AND NOT [the one prior prior] ...'
19:06:13 <koz_> It's the same as an if-else ladder.
19:08:34 <iqubic> I'm basically writing an if-else ladder here.
19:08:39 <iqubic> It feels really bad.
19:08:52 <koz_> iqubic: What are you trying to do?
19:09:36 <iqubic> Encode Towers Of Hanoi into haskell.
19:09:54 <iqubic> I know it only has 2 rules, but I've been stuck on this all day.
19:10:12 <koz_> iqubic: If you want some assistance, paste what you have and we can go from there.
19:10:26 <iqubic> My big if-else ladder is in the move function.
19:11:06 <iqubic> move :: Finite 3 -> Finite 3 -> GameState -> GameState
19:11:27 <iqubic> where GameState is a type I made myself.
19:12:03 <koz_> So what's your goal here? Emit a sequence of moves which forms a solution?
19:12:12 <iqubic> No.
19:12:44 <iqubic> I'm eventually going to create a CLI interface which lets the user make which ever moves they want.
19:12:49 <koz_> Ah.
19:12:59 <iqubic> But I'm only going to let them make valid moves.
19:13:02 <koz_> So basically, you get a position to move 'from' and 'to'?
19:13:12 <koz_> Then surely you should be returning Maybe GameState?
19:13:40 <iqubic> Yes. I shoul.
19:13:46 <iqubic> koz_: That's right.
19:13:48 <koz_> Or, perhaps more preciently, (MonadError e m) => m GameState?
19:14:01 <rajivr___> I am new to and learning  Haskell.  I was wondering how I can write a `Functor` instance for `WhoCares a`, where  `a` has a `Num a` constraint? https://gist.github.com/rajivr/a5ffa8efb962f0480c2706f7c06ec92e
19:14:28 <koz_> rajivr___: No - Functor has to be able to fmap _any_ a to _any_ b. If you require a constraint like that, you can't define a valid fmap.
19:14:39 <iqubic> I can't tell if this is a good way to model the state or not: http://dpaste.com/2HXABJR
19:15:02 <koz_> iqubic: Why a _list_ of Finite ns for a tower?
19:15:27 <iqubic> Because I wanted to constrain the game to N disks.
19:15:37 <koz_> Note where my emphasis was.
19:15:44 <koz_> I have absolutely no issue with your use of Finite ns.
19:16:00 * hackage marshal-contt 0.1.0.0 - A ContT-based wrapper for Haskell-to-C marshalling functions.  https://hackage.haskell.org/package/marshal-contt-0.1.0.0 (typedrat)
19:16:16 <shachaf> rajivr___: You cannot. Functor instances need to work for any type.
19:16:47 <iqubic> Well, there can be any number of disks on a single tower, and the only constraint is that they are in descending order of size.
19:17:12 <koz_> Your representation has no such constraint. [2, 2, 2, 2, 2] is a totally valid Tower.
19:17:25 <iqubic> Yeah. And I'm not sure what to do about that.
19:17:35 <koz_> You want an ordered collection of some kind which enforces this.
19:17:43 <koz_> Some kind of ordered Set appears appropriate.
19:17:46 <iqubic> It also lets [3, 1] be a tower too.
19:18:02 <koz_> '3, 1' is a fine tower, assuming position 1 is the 'bottom'.
19:18:06 <shachaf> No, what you want is [Int] [Int] [Int] and not to stuff everything into the type system.
19:18:12 <iqubic> Right.
19:18:19 <shachaf> You said you've been working on this all day. Make a simple thing that works and then you can worry about that.
19:18:22 <iqubic> shachaf: That's another way to d it.
19:18:29 <iqubic> s/d/do/
19:18:44 <iqubic> koz_: Does such a thing as an order-set exist?
19:18:49 <koz_> Data.Set
19:18:55 <koz_> Is an order_ed_ set.
19:18:59 <iqubic> also, [3, 1, 2] is not valid.
19:19:25 <iqubic> Data.Set from containers?
19:19:27 <shachaf> This should take 5 minutes so if you've been working on it all day something is seriously wrong. The solution is to make things simpler, not more complicated.
19:19:29 <koz_> Yup.
19:19:34 <rajivr___> To further cement my understanding - If we assume that its not a `Functor` but a some typeclass `Xxx`, then, with `xmap`,  where `x a` which has kind `* -> *`. Now if I want  `a` to have `Num a` constraint, I would have to specify that in the class definition of `xmap`?
19:19:41 <iqubic> Cool. I'll work on it.
19:20:25 <shachaf> rajivr___: Yes. The type of fmap is "fmap :: Functor f => (a -> b) -> f a -> f b", and people can use that type without knowing about the specific instance.
19:20:55 <shachaf> So your fmap should satisfy that type. If you wanted a different type -- constraining a and b to be Num or something -- you'd need a different fmap.
19:21:16 <weilawei> koz_, thank you! perfect answer :)
19:21:28 <rajivr___> shachaf: Thanks a lot for the help! :-) 
19:21:58 <koz_> weilawei: No problem - it's a little informal, but hopefully gets the idea across.
19:22:01 <rajivr___> koz_:  Thanks to you too! :-)
19:23:16 <shachaf> rajivr___: In general it's fine to just put Num constraints on the functions that actually use your type, rather than requiring it for fmap.
19:23:52 <shachaf> I guess it depends on what you're doing in fmap. But you should probably just be doing the normal thing.
19:24:46 <rajivr___> I was trying to develop an understanding of Haskell syntax by trying to push the boundaries and seeing where I trip.
19:25:17 <shachaf> Makes sense.
19:25:34 <shachaf> You might be interested in the fact that there's nothing GADT syntax lets you represent that the regular ADT syntax doesn't.
19:25:51 <shachaf> (The regular syntax including existential quantification and type equality constraints, which are extensions.)
19:27:46 <iqubic> Now, time to write the move function.
19:27:53 <iqubic> move :: Finite 3 -> Finite 3 -> GameState n -> Maybe (GameState n)
19:28:07 <iqubic> Where 'GameState n' has n disks
19:29:03 <iqubic> koz_: I'm not sure how to do this now.
19:30:58 <weilawei> koz_, it's more than adequate for our level of understanding. I'm sure we can revisit it later when we're up to the rigorous underpinning (what a nice problem that'd be to have)
19:33:11 <iqubic> http://dpaste.com/3FGBJJ5
19:33:20 <iqubic> I have no idea how to continue from here.
19:34:01 <iqubic> Also, I have to handle the case where (from == to)
19:34:33 <shachaf> Then I suggest either (a) don't use Data.Set or (b) read the Data.Set documentation.
19:34:42 <EvanR> soon you will be playing doom e1m1 in the type system
19:35:05 <iqubic> Me?
19:35:09 <shachaf> This problem is very solvable with nothing but the Prelude.
19:35:35 <iqubic> I know.
19:35:40 <iqubic> I just like being fancy.
19:37:52 <shachaf> I see. I thought you were stuck.
19:38:09 <iqubic> I like working on hard problems, alright?
19:39:37 <koz_> iqubic: Yeah, read Data.Set. It'll help if you know what you can actually do with your towers.
19:39:41 <dmj`> there's solving hard problems, then there's making problems harder to solve
19:40:02 <iqubic> dmj`: I know.
19:43:55 <laudecay> cabal or stack and why: go
19:44:28 <dmj`> runghc
19:45:03 <iqubic> NOT RUNGHC
19:45:14 <iqubic> BURN THAT WITH FIRE!!!
19:45:15 <laudecay> oh no
19:45:27 <laudecay> can i have a real answer tho i gotta install one
19:45:30 <laudecay> or the other
19:45:52 <laudecay> i just want non-breakiness, im gonna be writing a big old executable with a ton of files and dependencies
19:46:18 <dmj`> iqubic: I use runghc exclusively on some projects
19:47:15 <dmj`> iqubic: it's fantastic
19:47:27 <dmj`> iqubic: just wrap it in a bash function
19:49:15 <iqubic> koz_: Say that "move" is called with 'finite 0' and 'finite 1' I then need to get those two towers, inspect their state, and then either build up a new GameState with the new state of those two towers, or return Nothing.
19:49:27 <iqubic> I'm not sure how to do that right now.
19:49:43 <koz_> What do you mean by 'inspect their state'? What information are you seeking?
19:49:53 <koz_> Or rather, what do you need to know about them?
19:50:14 <shachaf> What are you hoping to get out of typing that question into this channel?
19:50:43 <iqubic> I need to know if the top disk of the 'from' stack is smaller than the top disk of the 'to' stak
19:50:47 <shachaf> Are you looking for detailed instructions, or motivation, or what?
19:51:03 <iqubic> shachaf: Why do you actually care?
19:51:47 <koz_> iqubic: https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Set.html#v:lookupMin and https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Set.html#v:lookupMax appear useful here.
19:51:49 <shachaf> I'm mystified by all these questions, mostly.
19:54:46 <iqubic> http://dpaste.com/2BY8M6S so I have that.
19:55:08 <iqubic> Do I really need to create 9 different case statements for the 9 different possibilities of from and to?
19:55:20 <iqubic> That seems like a large amount of duplicate code.
19:55:35 <koz_> Since you're using Finite 3s already, why not make your GameState a wrapper around Vector 3 Tower?
19:55:46 <koz_> Then you can just index to get the ones you want.
19:55:57 <iqubic> Oh, right...
19:56:09 <koz_> Does Hedgehog have something equivalent to QuickCheck's ==> ?
19:56:13 <iqubic> And I can index to put them back too?
19:56:24 <koz_> iqubic: Yes, you can modify through indices.
19:56:34 <weilawei> laudecay, I think stack might be more appropriate if you're looking to manage a lot of dependencies. also, it's not an either/or. stack is built on cabal
19:56:34 <koz_> (as you'd expect with vectors of any sort, really)
19:57:18 <laudecay> ok cool
19:57:18 <iqubic> Cool.
19:59:11 <iqubic> koz_: Do you think I want mutable vectors here?
19:59:21 <koz_> iqubic: I doubt that.
19:59:27 <koz_> Anyhow, one problem at a time.
19:59:39 <koz_> Anything you can do with mutable vectors can be done with immutable ones too - just less efficiently.
20:00:06 <iqubic> Cool.
20:02:42 <iqubic> type Tower n = S.Set (Finite n)
20:02:45 <iqubic> type GameState n = GameState (V.Vector (Finite n))
20:02:57 <koz_> iqubic: You're using the wrong type of vector.
20:03:01 <koz_> You want the ones from vector-sized.
20:03:09 <iqubic> Oh? Why?
20:03:11 <koz_> Since they take Finites as indices.
20:03:12 <koz_> Not Ints.
20:03:14 <iqubic> Ah.
20:03:16 <iqubic> I see.
20:03:22 <koz_> And you don't want to store Finite ns in it.
20:03:27 <koz_> You want to store _Tower_ ns.
20:03:30 <iqubic> I know.
20:03:36 <iqubic> I caught that already.
20:05:07 <iqubic> Looks like vector-sized doesn't offer immutable vectors.
20:05:20 <koz_> iqubic: Are you reading the same package I am?
20:05:20 <iqubic> I want this, right? https://hackage.haskell.org/package/vector-sized
20:05:31 <koz_> https://hackage.haskell.org/package/vector-sized-1.2.0.1/docs/Data-Vector-Generic-Sized.html <-- is immutable
20:05:40 <koz_> https://hackage.haskell.org/package/vector-sized-1.2.0.1/docs/Data-Vector-Sized.html <-- is also immutable
20:05:51 <koz_> There's also a Storable and Unboxed one.
20:06:07 <iqubic> I don't know what Storable and Unboxed things are.
20:06:22 <iqubic> I assume Unboxed is like things with #.
20:06:34 <iqubic> But beyond the syntax, I know nothing about them.
20:06:40 <koz_> iqubic: OK, vector has four kinds of vectors.
20:06:44 <koz_> Boxed ones, which can hold anything.
20:06:54 <koz_> Prim ones, which can hold only things with Prim instances.
20:07:03 <koz_> Unboxed ones, which can hold only things with Unbox instances.
20:07:06 <woffordrk> join clojure
20:07:13 <koz_> And Storable ones, which can hold only things with Storable instances.
20:07:34 <koz_> There are also mutable versions of all those four.
20:08:04 <koz_> vector-sized mirrors that, minus Prim, because for basically any use you'd likely want a typelevel-sized Vector, Unboxed > Prim.
20:08:18 <koz_> There's also generic Vectors, but those are more like an API to write libraries against.
20:08:43 <koz_> In your case, you want boxed vectors, which vector-sized provides under Data.Vector.Sized.
20:08:48 <koz_> (import it qualified)
20:08:58 <pikajude> > (5.8 :: Centi) / 100
20:09:01 <lambdabot>  0.05
20:09:15 <pikajude> Fixed just truncates the result after dividing, right?
20:10:14 <iqubic> type GameState n = GameState (V.Vector @3 (Tower n))
20:10:48 <koz_> iqubic: I'd recommend a newtype instead of a synonym there.
20:10:49 <iqubic> that gives me a "parse error on '@'" And yes, I do have the relevent pragmas enabled.
20:10:55 <koz_> Something like
20:10:57 <iqubic> Oh, why is that?
20:11:07 <koz_> newtype GameState n = GameState (V.Vector 3 (Tower n))
20:11:10 <koz_> Several reasons.
20:11:33 <koz_> 1) You probably want instances of type classes on GameState with different semantics to the ones on sized vectors.
20:11:44 <koz_> 2) What you're proposing doesn't parse - it's a hybrid of newtype syntax and type syntax.
20:11:55 <iqubic> I see.
20:12:25 <koz_> The corresponding type would be 'type GameState n = V.Vector 3 (Tower n)'
20:12:35 <koz_> @ is a type application - it doesn't belong in a type signature.
20:13:54 <iqubic> Why does vector use V.! and vector-sized uses V.Index?
20:14:01 <iqubic> s/I/i/
20:14:22 <dmwit> pikajude: You might like https://github.com/dmwit/mcmario/blob/4d22679119b921fe9db3c41c2705e030b2a771f9/src/MCMario/Model.hs#L56-L67
20:14:38 <dmwit> pikajude: I should really get around to making this a proposal to libraries@, but I am just So. Lazy.
20:14:41 <koz_> V.index, and because (at least in my experience) infix ! is much more annoying to work with.
20:15:18 <pikajude> oh that is nice, thanks dmwit
20:15:42 <iqubic> I see.
20:16:29 <dmwit> (To be clear: I'd propose fixing (*) and (/), not adding (%*) and (%/).)
20:16:45 <koz_> dmwit: I definitely think it's a proposal worth making. It sounds like a helluva nasty surprise.
20:16:51 <iqubic> Alright... Dealing with empty sets is a pain.
20:17:56 <iqubic> I can either use lookupMin and get a Maybe, or use findMin and get an error.
20:18:08 <koz_> Well, if the set is empty, so's the peg.
20:18:12 <koz_> Hence, you can put whatever there.
20:18:25 <koz_> The fact you're _returning_ in Maybe makes this even more ideal.
20:18:30 <iqubic> I know.
20:18:58 <iqubic> But if I try to pick up a disk from an empty peg, it fails.
20:19:06 <koz_> Yeah... and it should?
20:19:10 <koz_> I'm not seeing the problem here.
20:19:26 <koz_> If you can't pick up a disk, you get Nothing, and chuck it back at your user.
20:19:31 <koz_> (or caller, but who cares)
20:19:40 <koz_> Nothing is a Maybe _whatever the heck you want_.
20:35:32 <iqubic> :t fmap `asAppliedTo` Maybe
20:35:33 <lambdabot> error:
20:35:33 <lambdabot>     • Data constructor not in scope: Maybe :: a -> b
20:35:33 <lambdabot>     • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
20:35:44 <iqubic> Gosh darn it.
20:36:21 <koz_> :t fmap
20:36:22 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:36:26 <koz_> :t fmap @Maybe
20:36:27 <lambdabot> error:
20:36:27 <lambdabot>     Pattern syntax in expression context: fmap@Maybe
20:36:27 <lambdabot>     Did you mean to enable TypeApplications?
20:36:34 <koz_> % :t fmap @Maybe
20:36:34 <yahb> koz_: (a -> b) -> Maybe a -> Maybe b
20:37:17 <iqubic> Thanks.
20:37:41 <thunderseethe> Are there alternatives to haskeline for CLI repls?
20:37:45 <iqubic> Functional Programming is hard to wrap your mind around.
20:38:37 <koz_> iqubic: It gets easier.
20:38:40 <iqubic> I know.
20:38:45 <iqubic> I know it does.
20:40:35 <Zemyla> @let don't :: Applicative m => m a -> m (); don't _ = pure ()
20:40:36 <lambdabot>  Defined.
20:40:58 <iqubic> haskell is fast when you you replace haskell with something actually fast.
20:41:19 <koz_> Zemyla: https://hackage.haskell.org/package/monad-extras-0.6.0/docs/Control-Monad-Extra.html#v:discard
20:41:51 <iqubic> I love that next function "obvious = pure"
20:42:41 <iqubic> :t (<$>)
20:42:42 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:43:15 <iqubic> Is there an infix operator for 'flip fmap'?
20:43:42 <iqubic> So I can put the functor first?
20:43:52 <dmwit> Hoogle it.
20:43:57 <koz_> :5 (<&>)
20:44:03 <koz_> :t (<&>)
20:44:04 <lambdabot> Functor f => f a -> (a -> b) -> f b
20:44:15 <koz_> :t (<**>)
20:44:16 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
20:44:59 <dmwit> And stop asking questions so simple that an automated tool can answer it, while you're at it. >:|
20:46:14 <iqubic> I will.
20:56:02 <iqubic> fmap and join are useful here.
20:56:10 <koz_> Bind also.
20:56:21 <koz_> If you find yourself combining fmap and join, you _probably_ want bind.
20:56:30 <iqubic> that might be helpful here.
20:56:54 <iqubic> join $ fromMinView <&> (\(fromTopDiskSize, restOfFrom) -> ...)
20:57:11 <koz_> Yeah, definitely bind.
20:57:12 <iqubic> fromMinView = S.minView fromTower
20:57:15 <iqubic> Oh. I see.
20:57:19 <koz_> :t (>>=)
20:57:20 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:57:30 <koz_> % :t (>>= @Maybe)
20:57:30 <yahb> koz_: ; <interactive>:1:6: error: parse error on input `@'
20:57:36 <koz_> % :t (>>=) @Maybe
20:57:36 <yahb> koz_: Maybe a -> (a -> Maybe b) -> Maybe b
20:57:49 <iqubic> minView is nice, because it attempts to 'pick up' the disk at the starting tower, but might fail to do so.
20:58:20 <iqubic> It saves me the step of manually decomposing that set myself.
21:20:02 <haasn> oof, GHC using 5-10 GB to compile some things
21:20:04 <haasn> that's insane
21:21:08 <haasn> the downward trend of GHC performance and memory usage has gotten quite severe, hasn't it..
21:33:01 * hackage marshal-contt 0.1.1.0 - A ContT-based wrapper for Haskell-to-C marshalling functions.  https://hackage.haskell.org/package/marshal-contt-0.1.1.0 (typedrat)
21:37:31 <koz_> :t foldM
21:37:32 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
22:51:05 <jzyamateur> so what happens when I declare "data WhatWhat" inside Ghci, It compiles fine but I cannot use it in anyway? What does it mean? Doing ":i WhatWhat" works, doing ":t WhatWhat" throws error.
22:51:48 <iqubic> What error does it throw?
22:52:10 <EvanR> try :k WhatWhat
22:52:43 <c_wraith> jzyamateur: if you literally typed in only "data WhatWhat", you created an empty data type with no constructors.  There is nothing with a type for :t to work with
22:53:08 <c_wraith> jzyamateur: more likely, you forgot to provide a constructor and so the type's constructor is actually named something like String or Int
22:54:16 <jzyamateur> ":k WhatWhat" returns "*" , also, is there any use case where there are no constructors defined? Shouldn't it throw error?
22:54:45 <EvanR> Void is an example "empty type" with no ctors. It has its uses
22:55:02 <EvanR> see the pipes library
22:55:04 <c_wraith> Yeah, it's useful when you're using the types as tags, and they don't need any runtime representation
22:56:34 <jzyamateur> I cannot directly refer/use Void inside code, right?
22:57:16 <EvanR> you can use it but it has no values
22:58:43 <jzyamateur> undefined has type void?
22:59:23 <c_wraith> yes, Void is lifted so it's more accurate to say there are no evaluated expressions of type Void
23:00:40 <EvanR> undefined unfortunately inhabits (haunts?) every type
23:03:29 <c_wraith> ...  that's a bit of an oversimplification.  undefined doesn't inhabit a lot of types.  For instance, anything with a kind other than Type.  And probably also unlifted types, now that whether a type is lifted or not is actually part of the kind.
23:04:42 <EvanR> by unlifted you mean unboxed? 
23:05:13 <EvanR> or stuff like unboxed
23:05:14 <c_wraith> technically they're separate, and can be used separately.  But unboxed types are definitely unlifted
23:05:40 <EvanR> so you really can't put an undefined in code which computes an unboxed int?
23:06:31 <EvanR> that sounds bad ass
23:09:05 <c_wraith> Ah, shoot, you can.
23:09:13 <c_wraith> I guess it doesn't consider levity
23:09:27 <EvanR> too bad ass to be true :(
23:10:00 <c_wraith> huh.  Sometimes it can't?  odder
23:10:06 <c_wraith> oh!
23:10:27 <c_wraith> I messed up.  I eta-contracted, but functions are lifted.
23:10:58 <c_wraith> hmm, that wasn't it.
23:11:47 <jzyamateur> Another question: Some of the data type definition name the type constructors and data constructors have the same name e.g."()", and in some cases different name, e.g.(Maybe) What is considered good practice, and what should one watch out for?
23:12:13 <c_wraith> notably, Maybe has two constructors.  They can't both be the name of the type
23:12:51 <c_wraith> that's the most common heuristic.  If it has only one constructor, the name of the type is fine.  If it has more, try to give them names that make it clear what each constructor means
23:13:16 <jzyamateur> I know. For data types with single data constructors, do people tend to name same as type constructor name?
23:13:24 <EvanR> outside haskell, i've been using a distinct name for the constructors. Less confusing
23:13:39 <EvanR> data MyFoo = MkMyFoo _ _ _ _
23:13:41 <c_wraith> tend to, but it varies
23:14:14 <jzyamateur> having same name at term level and type level makes it more confusing.
23:14:24 <EvanR> that's just the beginning
23:15:17 <jackdk> I almost always use the type name for the ctor if that type has only one
23:15:37 <maerwald> I also do MkFoo, but I find it weird when used in pattern matching. I'm deconstructing a value, not creating one.
23:15:52 <iqubic> yeah
23:15:54 <maerwald> But that's really bikeshedding :P
23:16:03 <EvanR> Identity the type constructor... Identity the value constructor... Identity the DataKind constructor... Identity the constructor that goes with the previous datakind
23:16:39 <EvanR> data Foo a = MkFoo { getFoo :: a }; -- :)
23:17:01 <maerwald> data Foo a = Foo { foo :: a }
23:17:06 <EvanR> or unFoo
23:17:16 <EvanR> or in the case of transformers... runFoo
23:17:33 <EvanR> data Foo foo = Foo { foo :: foo }
23:17:38 <maerwald> nice
23:20:45 <koz_> getFoo also possible.
23:22:30 * hackage marshal-contt 0.1.2.0 - A ContT-based wrapper for Haskell-to-C marshalling functions.  https://hackage.haskell.org/package/marshal-contt-0.1.2.0 (typedrat)
23:23:20 <jzyamateur> So, In GHCi, ":t" only accepts terms/values, and ":k" only accepts types/type-exprs?
23:24:18 <EvanR> yeah
23:26:03 <jzyamateur> cool
23:26:33 <koz_> EvanR: Somewhat related: having to write 'import Data.Data (Data)' is hilarious.
23:27:19 <iqubic> Why would you need that?
23:28:06 <koz_> Deriving instances of Data.
23:30:46 <iqubic> I don't know what Data does.
23:30:57 <koz_> iqubic: It's what we had to use before GHC.Generics.
23:31:10 <koz_> (and still have to if you're stuck in Haskell2010/98-land)
23:31:32 <iqubic> Ah.
23:34:44 <iqubic> So who here still uses Hugs?
23:41:08 <jle`> jzyamateur: i think a lot of times for learning purposes people discourage using teh same name for the constructor and the type
23:41:32 <jle`> oh they just left after i typed that message
23:41:47 <jle`> or my tab completion is being weird
23:54:00 * hackage marshal-contt 0.1.2.1 - A ContT-based wrapper for Haskell-to-C marshalling functions.  https://hackage.haskell.org/package/marshal-contt-0.1.2.1 (typedrat)
