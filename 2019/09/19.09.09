00:01:56 <cheater> hmm... if i have a Yesod Value like this here, how can i add a new field to it? https://hackage.haskell.org/package/yesod-core-1.6.0/docs/Yesod-Core-Json.html#t:Value
00:09:28 <tdammers> those are just re-exported aeson Values, no?
00:10:01 <tdammers> if so, then it depends how you want to handle the cases where the Value is not an Object
00:10:44 <tdammers> you could, for example, pattern-match on the Object constructor, insert your field into its HashMap, and wrap it back in an Object, while handling the non-Object cases with a wildcard pattern match
00:11:26 <tdammers> something like addField :: Text -> Value -> Value -> Value; addField key val (Object items) = Object $ HashMap.insert key val items; addField _ _ x = x
00:29:06 <cheater> it looks like it's just a Hashmap
00:29:25 <cheater> Object is just a type alias on Hashmap 
00:29:28 <cheater> HashMap
00:29:56 <cheater> i'm trying to show something, but i get an ambiguous instance error. how does one resolve this? i've never run into this. https://pastebin.com/qeQKkSDj
00:35:53 <cheater> wow this place is so quiet today :)
00:37:57 <Ferdirand> you're trying to show something that has a polymorphic type
00:38:00 <tomjaguarpaw> cheater: Give the thing you're trying to show a type signature, I guess
00:43:58 <tdammers> cheater: Object-the-type is an alias for HashMap Text Value, but I was talking about Object-the-constructor (of the Value type)
00:48:27 <jgt> cheater: it's Monday morning
00:48:33 <jgt> cheater: we're all still in bed
00:50:11 <dminuoso> tdammers: Object-the-constructor is ambiguous, isnt it? :p
00:50:27 <tdammers> dminuoso: hence "of the Value type"
00:50:29 <tdammers> but yes
00:51:11 <tdammers> re quiet: on top of it being Monday, a significant part of the Haskell community has spent the weekend at munihac, and many are still traveling
00:54:30 <jgt> wow, the MuniHac keynote videos are already online. That's awesome.
00:54:59 <tdammers> yeah, they have a pretty good setup figured out at the venue
00:56:35 <koz_> tdammers: Oh, that's why my Twitter's been ablaze.
01:05:39 <cheater> yay, i made everything work.
01:06:02 <cheater> tdammers: yeah, i wasn't unwrapping the constructor properly. that was the issue.
01:06:32 <cheater> so the typechecker ran into ambiguity regarding show before it ran into the fact that you can't use hashmap's "insert" on an Object constructor based value.
01:10:19 <tdammers> that sounds wrong
01:11:09 <tdammers> if it runs into an ambiguity check, then it's probably because you get yourself into a situation where you have a value in the middle of ToJSON and FromJSON, and the compiler can't know which type you want in between
01:11:44 <tdammers> this will frequently happen with things like, for example, (.=)
01:12:24 <koz_> :t (.=)
01:12:26 <lambdabot> MonadState s m => ASetter s s a b -> b -> m ()
01:12:32 <koz_> Ah, right, those.
01:15:45 <tdammers> koz_: no, not that one. the one from aeson
01:15:53 <tdammers> :t Data.Aeson.(.=)
01:15:54 <lambdabot> error:
01:15:54 <lambdabot>     Not in scope: data constructor ‘Data.Aeson’
01:15:54 <lambdabot>     No module named ‘Data’ is imported.
01:15:57 <tdammers> aww
01:16:14 <tdammers> or rather, wat
01:16:33 <boxscape> :t Prelude.(==)
01:16:34 <lambdabot> error:
01:16:34 <lambdabot>     Data constructor not in scope: Prelude :: (a -> Bool) -> c
01:17:16 <tdammers> looks like lambdabot's understanding of Haskell syntax isn't quite perfect yet
01:17:28 <tdammers> anyway: https://hackage.haskell.org/package/aeson-1.4.4.0/docs/Data-Aeson.html#v:.-61-
01:18:58 <boxscape> tdammers: it's not lambdabot, ghci does the same thing
01:20:41 <boxscape> :t (Prelude.==)
01:20:42 <lambdabot> Eq a => a -> a -> Bool
01:20:45 <boxscape> ^ tdammers
01:21:09 <boxscape> :t (Data.Aeson..=)
01:21:10 <lambdabot> (aeson-1.4.4.0:Data.Aeson.Types.ToJSON.KeyValue kv, aeson-1.4.4.0:Data.Aeson.Types.ToJSON.ToJSON v) => Data.Text.Internal.Text -> v -> kv
01:21:19 <boxscape> looks weird with two dots but there you go
01:23:15 <merijn> tdammers: That's not valid haskell syntax, so... ;)
01:24:39 <merijn> Unrelatedly: Suppose I want to grep the latest versions of all packages on hackage (or a subset of them) for certain code patterns...I know some people have done this before, I'm curious what their workflow was...
01:38:46 <tdammers> oh right, crap
01:38:55 <tdammers> I think I need to reboot my brain
01:40:29 * Rembane hands tdammers a brain reset button
01:41:06 <merijn> Rembane: Weird name for a hammer...
01:41:31 <Ariakenom> I prefer the pillow method
01:41:50 <Rembane> merijn: I was more thinking of a walk and an orange
01:45:00 <tdammers> I think what I need is sleep
01:49:08 <maerwald> don't forget to update your bios when rebooting
01:50:41 <merijn> My life has almost never *improved* after attempting a bios upgrade >.>
01:58:08 <dminuoso> So I have an authentication service that needs to synchronize its internal sqlite database with a csv file made available to us via FTP. Other than having a continuous job that polls said FTP server every 5 minutes, is there a more sane way to deal with this?
01:58:56 <dminuoso> (The why would get us into discussions about how SAP teams are unable to do meaningful integration with other services other than "CSV export into FTP")
01:59:10 <dminuoso> (Because apparently that's something SAP can do quite well)
01:59:57 <merijn> dminuoso: Short answer: "No" :p
02:00:09 <[exa]> dminuoso: if you only have FTP access, the continuous polls are 5star solution
02:00:46 <[exa]> dminuoso: btw make sure you don't read a partial file
02:00:47 <merijn> dminuoso: Just because SAP exports to FTP doesn't mean your stuck accessing via FTP, no?
02:03:13 <[exa]> merijn: do not underestimate SAP; they might supply their own 100% compatible SAPFTP
02:03:45 <[exa]> ( :] )
02:04:42 <Rembane> dminuoso: Can you run something on that machine? Or only reach it by FTP? 
02:06:30 * hackage hspec-wai 0.10.1 - Experimental Hspec support for testing WAI applications  https://hackage.haskell.org/package/hspec-wai-0.10.1 (SimonHengel)
02:22:24 <dminuoso> Well, strictly speaking the FTP server is ours, so..
02:22:36 <dminuoso>  I guess an inotify hook could possibly work?
02:22:49 <dminuoso> 11:00:24            [exa] | dminuoso: btw make sure you don't read a partial file
02:22:57 <dminuoso> Gah you are right. :<
02:23:39 <[exa]> if the server is yours, best put there a python script that submits the file to your database transactionally
02:23:52 <[exa]> there's a possibility to get inotify on file close I guess
02:23:54 <dminuoso> [exa]: Wouldnt that require special support form the FTP server?
02:24:26 <[exa]> no, FTP server simply closes the file after writing it, done.
02:24:35 <Ferdirand> inotify on close_write, works reasonably enough, i'd say
02:24:54 <dminuoso> How reliable is inotify?
02:25:11 <[exa]> if in doubt, you can always re-poll
02:25:27 <dminuoso> [exa]: But re-poll has the risk of potentially fetching partial files.
02:25:47 <dminuoso> (Though I suppose I could flock the file?)
02:25:55 <[exa]> you'd need the server to flock it too
02:26:14 <Ferdirand> it really depends on how the upstream process is implemented
02:26:16 <[exa]> (not sure if flock really works if only one party uses the locking api)
02:26:20 <dminuoso> [exa]: Do I? I mean lets say I dont fetch the file via FTP, but via the file system locally.
02:26:22 <dminuoso> Ah
02:26:51 <Ferdirand> if you are lucky, maybe it writes into a temporary location and moves the file at the proper location once it is done, and the problem is moot ?
02:28:25 <[exa]> dminuoso: filesystem is not a transactional database, but you can always have a "snapshot" of the file (using cp) and see if it's still stable say after 5 seconds (or compare to previous ones)
02:28:54 <[exa]> Ferdirand: I wouldn't bet on that (afaik neither vsftpd nor proftpd do that, and others will probably follow)
02:29:07 <Ferdirand> oh wait
02:29:13 <Ferdirand> you mean they push a file to your ftp ?
02:29:18 <[exa]> dminuoso: also, lsof
02:29:29 <Ferdirand> i tought they drop it on some server that you read from via ftp
02:30:28 <[exa]> anyway
02:30:34 <Ariakenom> t0 <- readModifiedTime file; content <- readFile file; wait sufficientlyLong; t1 <- readModifiedTime file; assert (t0 == t1)
02:31:06 <[exa]> there is FTP server implementation in Python and Haskell, if the FTP is write-only you can just fake it with something simple that handles the database file right
02:32:00 * hackage math-functions 0.3.2.1 - Collection of tools for numeric computations  https://hackage.haskell.org/package/math-functions-0.3.2.1 (AlexeyKhudyakov)
02:47:53 <kuribas> I wonder about the perceived "complexity" of haskell.  In my opinion this complexity is only on the surface.  Like dealing with layers in monad transformers, understanding composition and currying etc...
02:47:56 <dminuoso> Ariakenom: I'd feel so ashamed to write such code.
02:48:35 <merijn> kuribas: Well, if you use a lot of type level "dependent" haskell it gets insanely complex quick
02:48:42 <merijn> kuribas: Not to mentio lens is pretty complex too
02:48:51 <[exa]> dminuoso: always remember the code is 5x worse on the SAP side.
02:48:56 <kuribas> Compare that with the complexity of management state in an imperative language, which is deep complexity, as you have to mentally picture the way state flows.
02:49:01 <merijn> kuribas: If you stick to mostly Haskell2010 and avoid too much polymorphism it's mostly fine
02:49:12 <kuribas> merijn: yeah, if you don't get lost in type extensions
02:49:24 <kuribas> merijn: lens isn't too bad, if you stick to basic lenses
02:49:35 <merijn> kuribas: Until you accidentally run into an error... :p
02:49:42 <kuribas> merijn: IMO the problem with lens is the error messages and type signatures...
02:49:46 <kuribas> right :)
02:50:12 <kuribas> the basic concept of a lens is quite simple
02:50:43 <kuribas> what's scary is "choice", and "profunctor", etc, in the signatures
02:50:53 <Rembane> dminuoso: I propose a shell script using entr! http://eradman.com/entrproject/
02:51:00 * hackage strict-list 0.1.5 - Strict linked list  https://hackage.haskell.org/package/strict-list-0.1.5 (NikitaVolkov)
02:52:00 * hackage deque 0.4.3 - Double-ended queues  https://hackage.haskell.org/package/deque-0.4.3 (NikitaVolkov)
02:52:31 <kuribas> I am translating a piece of haskell into Java, and the code is twice as big, not so readable, and lost the ability to stream (due to lack of lazyness and immutable lists).
02:53:01 <kuribas> while the haskell code (almost) reads as a specification
02:53:05 <Rembane> Only twice? How do you manage to get it so terse? 
02:53:18 <kuribas> Rembane: yeah, thrice more likely :)
02:53:27 <Rembane> kuribas: :)
02:53:41 <kuribas> or worse
02:53:47 <Rembane> > pi 
02:53:49 <lambdabot>  3.141592653589793
02:53:52 <Rembane> :D
02:54:00 <Entroacceptor> > tau
02:54:02 <lambdabot>  error:
02:54:02 <lambdabot>      • Variable not in scope: tau
02:54:02 <lambdabot>      • Perhaps you meant one of these:
02:54:05 <Entroacceptor> :(
02:54:10 <Rembane> > pi * 2.0
02:54:12 <lambdabot>  6.283185307179586
02:54:18 <Rembane> There you go 
02:54:34 <kuribas> I should show both to my coworkers, so they stopt thinking I am a haskell "evangelist", and there is actual merit to my arguments.
02:55:02 <kuribas> Of course clojure can be (almost) as terse.
02:55:05 <merijn> kuribas: Relevant: https://blogs.dropbox.com/tech/2019/09/our-journey-to-type-checking-4-million-lines-of-python/ ;)
02:55:30 <ski> @quote in.the.type.system
02:55:30 <lambdabot> OlegFacts says: Oleg's latest project is re-writing Emacs... in the type system.
02:55:36 <kuribas> merijn: that's just madness.  At least Java is semi decent for such a project.
02:55:47 <kuribas> merijn: why you would use Python is beyond me.
02:55:58 <MarcelineVQ> Probably because everyone else does
02:56:39 <merijn> kuribas: Because they already had python and rewriting everything now is a no go :p
02:57:17 <kuribas> merijn: yeah, but you never should let it grow to 4 million lines...
02:57:39 <merijn> kuribas: Move fast and break things! :p
02:57:43 <merijn> Anyway, lunch
02:57:49 <kuribas> merijn: agreed!
03:00:06 <kuribas> at least I thought the java version would allow me to be efficient and join two linked lists in constant time, but no, it doesn't allow you!
03:07:08 <__monty__> It needs to traverse to find the final node? Maybe you want a doubly-linked list?
03:07:45 <kuribas> __monty__: java's list is doubly linked, but it doesn't allow you to modify the second list to join them.
03:07:56 <kuribas> __monty__: you can only copy the elements in the first one.
03:11:21 <kuribas> So I can neither use the ellegance of immutability and higher order functions, nor the dirty tricks of imperative programming./
03:14:18 <tdammers> whenever you find yourself saying "rewriting it is a no-go", then usually not rewriting is also a no-go
03:14:48 <tdammers> iow., you're already deep in the maintainability tarpit, where every change you could possibly make is cumbersome, difficult, and dangerous
03:14:49 <kuribas> tdammers: so, gradual rewriting?
03:14:57 <Rembane> And then you're stuck in Schrödinger's rewrite 
03:15:01 <tdammers> kuribas: same problems
03:15:46 <tdammers> kuribas: except that of course a gradual rewrite has the advantage that you deal with all the fallout in a gradual fashion, at the expense of doing a lot more work
03:16:00 <kuribas> the problem is that management often sees code as an asset, where it's a liability
03:16:19 <tdammers> it's both
03:16:47 <tdammers> code that does something you want is an asset, in that its existence means you don't have to write it anymore
03:16:58 <kuribas> the value is more in the business logic and the lessons learns
03:17:11 <tdammers> that too; but code that does something you positively need or want is an asset too
03:17:23 <tdammers> the problem is just that most code is not really like that
03:17:35 <tdammers> most of the code in the average codebase exists by historical accident
03:17:59 <tdammers> so the goal is to remove all those accidents, and keep only the stuff that is an actual asset
03:18:05 <tdammers> there's a name for that process: "refactoring"
03:18:23 <kuribas> I am lucky that at my works everybody is an agressive refactorer  :-)
03:18:55 * jgt is an aggressive refucktorer
03:18:57 <kuribas> it was the opposite in my previous job
03:19:29 <kuribas> jgt: you keep swearing at code?
03:19:55 <jgt> kuribas: there was literally a popup on my terminal yesterday that said "You seem frustrated"
03:20:05 <jgt> it must have landed in the most recent iTerm2 update
03:20:05 <tdammers> I would interpret that as "whenever anyone made the code any better, I swiftly returned it to a properly fucked-up state"
03:22:56 <kuribas> well, someone needs to think about job security :)
03:23:21 <kuribas> which is why when I came up with improvements in my previous job I was promptly fired
03:24:42 * ski . o O ( "job insecurity" )
03:26:37 <maerwald> there are some domains where refactoring makes little sense
03:26:52 <maerwald> but if the product is an on-going software system... you better do it
03:27:29 <kuribas> The response of management was that you had to pick a direction and stick with it.
03:29:13 <maerwald> sometimes time-to-market is more important than technical debt, but once they understand they can push you with the time-to-market argument, they tend to overuse it
03:30:15 <maerwald> It's a difficult balance. Programmers don't understand the importance of time-to-market, mangers don't understand technical debt. Where to meet?
03:30:33 <jgt> maerwald: run your own product business as a programmer
03:30:37 <maerwald> :)
03:31:02 <kuribas> maerwald: you can build up a small amount of technical debt to meet a deadline, but you have to pay for it later.
03:31:37 <jgt> often the best refactoring is to rm -rf the whole feature because it didn't find product/market fit
03:31:38 <maerwald> kuribas: sure, but later you have more investors...
03:32:21 <maerwald> well, basically, if you don't like such trade-offs, don't work in start-ups (or things like game dev companies)
03:32:51 <tdammers> one valid way of building "technical debt" that won't kill you eventually is to just not build the thing, or to start with a radically simplified model
03:46:31 * hackage reanimate-svg 0.9.1.1 - SVG file loader and serializer  https://hackage.haskell.org/package/reanimate-svg-0.9.1.1 (DavidHimmelstrup)
03:59:23 <Ariakenom> tdammers: yeah scope is a useful knob to tweak
04:01:49 <Ariakenom> ex in the FTP example. how often do we need to update the DB.?
04:15:17 <Darwin226> Hey guys. I'm looking for a haskell talk from a while back. It was about a collection of useful tips for working with haskell in general. For example, a bit emphasis was put on adding type parameters to your data types, deriving everything you can
04:15:52 <jgt> Darwin226: https://www.youtube.com/watch?v=S3WGPuqfBLg
04:15:56 <jgt> maybe that one
04:16:25 <Darwin226> hmm, that's not it
04:16:27 <Darwin226> I know one of the jokes was that if you don't derive the instances then ed will come and steal your package
04:16:46 <jgt> doesn't ring a bell I'm afraid
04:53:16 <dminuoso> Darwin226: If its worth naming, its worth annotating.
04:53:33 <dminuoso> Darwin226: That's one of my rules I go by. :-p
05:03:55 <magicman> Hey, quick question about the async library. From what I understand, `withAsync stuff (\a -> moreStuff >> wait a)` and `async stuff >>= \a -> moreStuff >> wait a` are operationally the same?
05:04:56 <dminuoso> magicman: Not quite
05:05:32 <magicman> Hrm. Something exceptions-related?
05:05:39 <dminuoso> magicman: Did you read the haddoc documentation?
05:06:32 <dminuoso> magicman: https://hackage.haskell.org/package/async-2.2.2/docs/Control-Concurrent-Async.html#v:withAsync
05:06:41 <magicman> From the way I read it, the main extra nicety is that `withAsync` auto-cancels `stuff` when the `(\a -> ...)` finishes.
05:06:46 <dminuoso> Right. :)
05:06:59 <magicman> But if `(\a -> ...)` ends in `wait a`, then there's no need to cancel?
05:07:07 <merijn> magicman: Or when the function gets interrupted by an async exception
05:07:19 <dminuoso> magicman: Specifically, it throws an asynchronous exception uninterruptableCancel to the async if an exception is thrown.
05:08:18 <magicman> Oh, right. Yes. `(\a -> ...)` can throw an exception, or have an exception thrown at it. `withAsync` will still cancel `stuff`, while the other won't.
05:08:56 <dminuoso> magicman: The point is, that withAsync with fork a thread and give you a handle for that thread. It will send uninterruptableCancel to that spawned thread if an exception is thrown, to assure that no thread is left running
05:09:19 <dminuoso> If you manually do `async stuff >> ...` and encounter an exception, that thread will be left alive.
05:09:31 <magicman> *nod*, gotcha.
05:09:52 <magicman> Still need to get used to all the nasty ways exceptions interact with other parts of code >_<
05:10:59 <merijn> magicman: Basically you just always want to use a bracket-like resource management, then you don't have to think about it
05:11:11 <dminuoso> Except thats not really true.
05:11:20 <Darwin226> dminuoso: is that the name of the talk or just general advice?
05:11:27 <dminuoso> Darwin226: General advice. :)
05:12:21 <merijn> dminuoso: How so?
05:12:40 <dminuoso> merijn: Depending on the situation you may have to mask exceptions.
05:12:51 <merijn> dminuoso: bracket already masks exceptions
05:13:22 <merijn> Depending on the situation you *might* need to uninterruptible mask the cleanup, but that's not true in most cases
05:13:57 <Ariakenom> magicman: have you read concurrent and parallel haskell's chapter on async?
05:13:59 <dminuoso> merijn: Well I still think that its not so obvious to just "use bracket", because async exceptions could happen everywhere.
05:14:15 <dminuoso> merijn: Its definitely not obvious when to do.
05:14:19 <merijn> dminuoso: async exceptions are masked during the allocation and cleanup from bracket
05:14:23 <dminuoso> merijn: Yes.
05:14:34 <merijn> anyway, meeting time
05:14:37 <dminuoso> merijn: But not everything is about resource allocation and release.
05:15:23 <dminuoso> Ive had to use asyncWithUnmask a few times already, but that required foresight.
05:15:39 <magicman> Ariakenom: It's on my perennial to-read queue, but I'll bump its priority.
05:17:41 <Ariakenom> magicman: I definitely recommend it.
05:18:00 * hackage massiv-io 0.1.7.0 - Import/export of Image files into massiv Arrays  https://hackage.haskell.org/package/massiv-io-0.1.7.0 (lehins)
06:03:00 * hackage releaser 0.1.0.0 - Automation of Haskell package release process  https://hackage.haskell.org/package/releaser-0.1.0.0 (domenkozar)
06:09:52 <dminuoso> Is there a way to have cabal use multiple hackage sources, such that I could operate one with our packages but without mirroring the rest of the world?
06:17:30 * hackage ghc-lib-parser 0.20190909 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-0.20190909 (shayne_fletcher)
06:17:45 <MarcelineVQ> there's at least optional-packages: idk what all the nuances of that are, fwiw I can't even find where to specify a custom hackage in the docs so grain of salt
06:18:31 * hackage ghc-lib 0.20190909 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-0.20190909 (shayne_fletcher)
06:20:10 <dminuoso> MarcelineVQ: But optional-packages is for vendored packages, is it not?
06:22:09 <dminuoso> This is interesting, the option appears to have been --remote-repo, but that no longer appears to exist?
06:22:55 <MarcelineVQ> "vendored ... "That's what it says, though I don't actually know what that means beyond the line below this: https://cabal.readthedocs.io/en/latest/nix-local-build.html#cfg-field-extra-packages
06:23:54 <dminuoso> MarcelineVQ: Well by that its meant, if you have local packages, say via packages: ./*.cabal, then these will be preferred over hackage packages.
06:24:31 <MarcelineVQ> vendored is a word I'd never think to use for that but now I know
06:25:50 <MarcelineVQ> cabal does have this now, dunno how useful that is for your case https://cabal.readthedocs.io/en/latest/developing-packages.html#source-repositories
06:26:03 <dminuoso> https://cabal.readthedocs.io/en/latest/installing-packages.html?highlight=legacy%20repositories#legacy-repositories
06:26:07 <dminuoso> Ah this appears to be it
06:26:27 <MarcelineVQ> oh and something similar for the project file https://cabal.readthedocs.io/en/latest/nix-local-build.html#specifying-packages-from-remote-version-control-locations
06:26:56 <dminuoso> So it seems there's really no support for multiple hackage servers.
06:27:41 <dminuoso> Im starting to be annoyed by using source-repository-package stanzas in cabal.project files..
06:28:12 <dminuoso> MarcelineVQ: Yeah that's what I have been using for a while now, and its sort of an okayish middle ground.
06:28:29 <dminuoso> Perhaps I should really just use nix all the way.
06:31:32 <MarcelineVQ> but now, they are all nix
06:32:13 <saml> how did you do italics?
06:32:44 <saml> > 'x' < 'x'
06:32:46 <sclv> dminuoso: no you can specify multiple hackage servers
06:32:46 <lambdabot>  False
06:33:07 <sclv> just put them in order in your cabal config
06:33:15 <sclv> That’s how head.hackage works
06:33:26 <sclv> Its referred to as an “overlay”
06:33:33 <MarcelineVQ> saml: Fabulous secret powers were revealed to me the day I held aloft my magic sword and said... By the power of Greyskull!
06:33:50 <MarcelineVQ> But in this case my client has shortcut keys for some of the fancy things
06:34:00 <sclv> i think the precedence order is last specified repo “wins”
06:34:00 <dminuoso> sclv: Ah! That'd be wonderful. Did I not catch this in the documentation or is it really a secret feature?
06:34:05 <sclv> In name conflict
06:34:36 <sclv> On phone so can’t browse docs to tell you :-)
06:34:54 <sclv> It certainly is underarvertised
06:36:08 <dminuoso> sclv: Thanks a bunch! :)
06:36:08 <sclv> Oh wait its in section 2.1.2 “you can configure multiple repositories”
06:36:39 <dminuoso> sclv: Ah, I actually understood this as "you can have a local and a remote repo"
06:36:59 <MarcelineVQ> Considering that the cabal docs are so comprehensive I really have an awful time finding the specific information I need from them pretty much every time, not sure what to do about that
06:37:23 <saml> 03o09k 04t08ha14nks
06:37:35 <sclv> yeah the sentence is pretty ambiguous. once you get something working, feel free to make a PR to improve the docs
06:44:00 * hackage secp256k1-legacy 0.5.4 - fork of secp256k1  https://hackage.haskell.org/package/secp256k1-legacy-0.5.4 (fommil)
06:59:49 <srid> One novel thing about Category Theory is that it abstracts function composition itself (imagine doing that in other languages!). Which allows us to tweak the semantics of (aka. "embellish") what would otherwise be 'normal' functions. And so the Writer monad was born. Is this an accurate description?
07:00:06 <srid> Bartosz put it simply: "we have to abstract function composition itself". Also, this comment for context: https://bartoszmilewski.com/2014/12/23/kleisli-categories/#comment-39402
07:01:15 <merijn> srid: I'm pretty sure the Writer monad was invented before CT started heavily influencing Haskell
07:02:35 <srid> merijn: Sure. I just thought it is neat - how I am able to better 'intuit' the Writer monad (among things) only after learning the CT behind it. I'm reading Bartosz's book, by the way. Writer seemed more 'arcane' before.
07:02:37 <merijn> I also take issue with the description that "CT abstract function composition itself" as in CT there isn't even a notion of functions. Sure you can describe functions un sets *using* category theory, but I don't really think "abstracting" is the right term for that
07:03:35 <dminuoso> Well you can think of CT as abstracting function composition when you consider merely Set/Hask, since most of the knowledge transfers to arbitrary categories.
07:04:30 <dminuoso> srid: Bartosz has a lot of creative mind models that are all good in their own rights, but they are fitted to the discussion at hand, helping to visualize some line of thinking.
07:05:03 <srid> In CT, there is arrows and composition of arrows. But yea, when looking at Hask category, that becomes functions and function composition ... *however* function composition traditionally has been seen as `b -> c . a -> b`, which is *limiting*. So we 'go one step back' in abstraction, land in CT's arrows, which allowed has to 'embellish' the return type, doing some fun stuff. 
07:05:40 <dminuoso> srid: Its a subtle hint at the Kleisli category.
07:06:31 <srid> Yea, he mentiones Kleisli category in that chapter, and the relation to monads (to be discussed in later chapters). I agree with your comment re: Bartosz and mind models ... he explains concepts very well.
07:06:58 <dminuoso> In Hask a morphism from a to b is a function `a -> b`, whereas Kleisli gives you a family of categories, in which a morphism from a to b is a function `a -> m b` for some m.
07:07:11 <srid> I think Bartosz should write "volume 2" (beginner Haskell) and "volume 3" (intermediate haskell), building on top of his CT book :-) 
07:07:26 <dminuoso> srid: I think Bartosz is mostly occupied with homotopy type theory at the moment.
07:07:56 <merijn> I like Bartosz' writing, but I hope he doesn't write haskell books on top of his CT book >.>
07:08:21 <dminuoso> Heh. I think his articles are hard to follow, his lectures feel much more comprehensive if you want to learn CT.
07:08:29 <merijn> Because that'd further strengthen the whole "Haskell is based on CT" misconception that's been going around social media the past years
07:08:41 <merijn> Which is a meme that needs to die
07:09:30 <MarcelineVQ> but merijn, it's morphisms all the way down
07:09:45 <srid> dminuoso: His book is easier to follow though. But yea, individual articles -- take https://bartoszmilewski.com/2017/02/09/monoids-on-steroids/ for example -- are indeed ... tricky.
07:09:58 <MarcelineVQ> allthough, adjuctions all the way down sounds better
07:10:31 <srid> merijn: I don't think CT is *required* to learn Haskell; but (from what I've been finding out) it seems to help with the *intuition* of pure FP concepts
07:11:05 <dminuoso> srid: I think this is actually one of his better readable articles.
07:11:17 <dminuoso> srid: It just requires some good knowledge and intuition.
07:11:21 <srid> During my first Haskell job, I learned a lot and was writing production Haskell code ... yet I felt like something was missing. 
07:13:10 <merijn> srid: Perhaps, on the other hand, I'd consider myself quite advanced/expert level in Haskell, and repeated CT dives have mostly resulted in confusion and failure :p I don't really think you need CT to understand the idea of Kleisli arrows and "enriched" functions :) But if it works for you, good :)
07:15:02 <ski> i think "CT abstracts away from function composition" could be a reasonable way to introduce it (CT)
07:18:00 * hackage orderly-workers 0.1.0.0 - Fork concurrent worker threads and produce ordered results  https://hackage.haskell.org/package/orderly-workers-0.1.0.0 (TomMurphy)
07:19:01 * hackage orderly-workers 0.1.0.1 - Fork concurrent worker threads and produce ordered results  https://hackage.haskell.org/package/orderly-workers-0.1.0.1 (TomMurphy)
07:20:30 * hackage aeson 1.4.5.0 - Fast JSON parsing and encoding  https://hackage.haskell.org/package/aeson-1.4.5.0 (AdamBergmark)
07:22:03 <styledash> i think the way FP knowledge takes the way you view programming to a higher level than imperative... CT does the same to FP
07:22:18 <styledash> understanding a higher level of abstraction always makes the lower levels easier and more intuitive
07:23:24 <dminuoso> styledash: I dont think this necessarily holds true for CT.
07:24:45 <merijn> Yeah, I disagree with that
07:24:54 <dminuoso> styledash: Category theory is best described by "mathematics of mathematics" - and there's some connections between programming and mathematics, but CT definitely does not simply allow you to zoom out of Haskell and see everything more clearly.
07:25:03 <styledash> understanding how the tools really work under the hood makes you moe powerful than just knowing how to use the tools imo
07:25:19 <merijn> styledash: Except CT has no relation to hows the tools work under the hood
07:25:23 <dminuoso> styledash: Except Haskell is not built or designed on CT.
07:25:23 <styledash> the best driver is a great mechanic as they say
07:25:44 <merijn> styledash: This is exactly the "Haskell is based on CT"-meme I mentioned that has to go
07:25:48 <dminuoso> Im fairly confident thats a flawed argument.
07:25:50 <domenkozar[m]> what is the best way to debug a stuck program (which hasn't been compiled with dwarf)?
07:26:03 <merijn> I don't even understand how that idea spread, since it's quite easy to check that it's objectively false
07:26:15 <merijn> domenkozar[m]: Pray? :)
07:26:22 <dminuoso> domenkozar[m]: Can you reproduce it?
07:26:29 <merijn> domenkozar[m]: And/or recompile with DWARF? ;)
07:26:44 <styledash> would you rather use a framework made by someone who can rigrourously verify its correctness or not?
07:26:59 <dminuoso> styledash: Haskell is *not* built/designed on CT.
07:27:04 <dminuoso> styledash: Your argument is flawed in its beginning.
07:27:05 <merijn> styledash: I don't really see how that relates to Haskell and CT
07:27:25 <domenkozar[m]> well I'm not sure I can reproduce, so I'd like to debug it in stuck state
07:27:28 <dminuoso> styledash: Haskell was made. Then some math folks came, and said "Hey look, this looks like a category".
07:27:33 <dminuoso> styledash: They started toying around.
07:27:47 <merijn> To be fair, Haskell certainly has a clear underpinning in math, it's just not CT
07:27:58 <styledash> difference between a scientific and engineering mindset I guess
07:28:11 <merijn> But somehow no one wants to talk about type theory and System F_omega on social media >.>
07:28:14 <cpressey> If CT studies composition in the abstract, then it should be possible to apply CT to things other than functions that software developers compose. Middleware, for example. And I'm sure it is possible, but it seems you rarely see it.
07:28:18 <dminuoso> styledash: Haskell is still not fundamentally built ontop of Category Theory. Here's the simple proof:
07:28:29 <dminuoso> styledash: Category theorists like to talk about Hask right?
07:28:31 <tejok[m]> I'm trying to build a haskell project that have the following cabal file: https://pastebin.com/L7PBY16D .. so I'm building using cabal2nix, which generate a proper `shell.nix` file... but once I get in that shell and do `cabal configure` it tells me that `postgresql-simple` is not found :-( ... does anyone have an idea what could be the reason? thanks
07:28:47 <MarcelineVQ> merijn: sure they do, people link that kind of stuff all the time in ##dependent
07:29:01 <merijn> MarcelineVQ: Freenode IRC channels aren't social media :)
07:29:10 <MarcelineVQ> links to social media :>
07:29:14 <dminuoso> styledash: Show me the paper formally defining Hask. Show me any paper formally researching Hask. ;)
07:29:17 <merijn> MarcelineVQ: I mean the "pro-CT" misinformation campaign on twitter/reddit/HN/etc.
07:29:41 <dminuoso> styledash: Hask is not even a real cartesian closed category like everybody pretends it is.
07:29:58 <dminuoso> It requires actively imagining reality away, pretending things like seq and _|_ are not a thing.
07:29:59 <styledash> im not arguing haskell is built on CT... im saying an understanding of CT concepts will make you a better functional programmer ultimately
07:30:02 <MarcelineVQ> Then let's take this over the edge, haskell is based on HoTT
07:30:18 <dminuoso> Haskell is based on quantum mechanics
07:30:22 <merijn> styledash: Understanding of lambda calculus, type theory and some basic algebra has a MUCH bigger impact than CT ever will
07:30:22 <styledash> ^
07:30:30 <styledash> quantum mechanics >
07:30:38 <dminuoso> So understanding quantum mechanics will make you a better programmer, is that what you are suggesting?
07:30:39 <srid> I totally agree with styledash. At least, in my experience I can relate.
07:30:54 <MarcelineVQ> untyped lambda calc was a pretty good primer for haskell
07:31:18 <dminuoso> srid: Ive been studying category theory rather deeply, considering the average Haskeller. Ive tried to apply it, and I found there's only very few actual *applications*
07:31:23 <dminuoso> making connections to CT is one thing
07:31:25 <magicman> Semirelated, I also really dislike when people go "I'm learning all these category theory concepts like monoids, catamorphisms, algebras, etc.". No, dammit, that's various flavours of algebra.
07:31:29 <dminuoso> But actually drawing useful conclusions, making statements is another.,
07:31:39 <merijn> magicman: :)
07:31:55 <merijn> magicman: Fight the good fight!
07:31:59 <styledash> any added mathematical maturity helps your reasoning processes... so yeah, learning the hilbert space algebras of quantum mechanics will make your general algebraic reasoning skills stronger
07:32:03 <dminuoso> srid: How many actual proofs have you done in Hask? How many times did you actually invoke Yoneda to make a statement about your program?
07:32:48 <merijn> dminuoso: That's why I think we should stop saying yoneda at everything and just call it "generalised DList" >.>
07:33:13 <srid> Well, the only thing I'm saying is that CT helps with an *intuition* behind some Haskell concepts. I gave a concrete example of the `Writer` monad, where morphisms are embellished and then function composition is abstracted away. It took a bunch of 'magic' out of the Writter monad for me.
07:33:16 <dminuoso> Last week I finally made my first claim leveraging category theory. But that a claim that has no relevant impact.
07:33:45 <dminuoso> srid: Im willing to argue if you spent your time actually using monad instances, you gain much more useful intuition.
07:33:50 <cpressey> srid: But what helps with the intuition behind CT? I've never found it particularly easy to get into.
07:34:00 <styledash> srid: yup "demystifying" FP by going deeper will never hurt you in the long run
07:34:07 <merijn> cpressey: Algebraic geometry, I've heard
07:34:08 <styledash> not necessary... but def helpful
07:34:15 <dminuoso> Understanding how (a,) and (a ->) are adjoints is certainly fun, but you gain absolutely 0 information that helps you write better code
07:34:17 <dminuoso> Whateverso.
07:34:17 <Taneb> I think learning category theory is a good idea because it's enjoyable in its own right
07:34:21 <dminuoso> Indeed!
07:34:32 <magicman> I'm convinced that taking any group theory/abstract algebra/whatevs intro course will make you a better programmer/designer than CT.
07:34:37 <merijn> styledash: Sure, but I'd say "demystify" it by learning Core, STG, type theory, what makes GHC tick, etc. that will teach you much more, tbh
07:34:46 <magicman> I mean, if you want more math >_>
07:34:58 <styledash> fair
07:35:07 <dminuoso> Taneb: By the way, did you ponder about what I said about Yoneda the other day?
07:35:10 <merijn> Taneb: Oh, I wholly think people should learn CT if they think it's fun. I just wish they'd stop using Haskell as handwave reason why :\
07:35:24 <magicman> But only *after* the lambda calculus and type theory courses, of course.
07:35:28 <Taneb> dminuoso: no, it completely slipped my mind...
07:35:32 <Taneb> Can you tell me again?
07:36:12 <srid> dminuoso: Regarding your "gain much more useful intuition" - not sure if you missed my prior message: "During my first Haskell job, I learned a lot and was writing production Haskell code ... yet I felt like something was missing. "
07:36:18 <dminuoso> Taneb: So the question was, whether you could have two different monad instances sharing the same coherent applicative instance, right?
07:36:45 <Taneb> Yes
07:36:55 <srid> cpressey: Every CT book I tried to read turned out to be dry and boring ... until I came across Bartosz's book (it is written for programmers specifically)
07:39:03 <cpressey> srid: I liked the first few chapters of that book, but at some point the motivation evaporated. It felt like after a point he started assuming that the reader was inherently interested in CT, which I'm not.
07:39:54 <ski> (merijn : of course IRC is a social medium :) .. so are mailing lists, and usenet)
07:40:47 <ski> srid : things tend to be boring, if you can't relate to them. most CT books aren't written with a programming audience in mind
07:43:00 <dminuoso> Taneb: So in short, the Monad induced Applicative instance can be written to use `join` and `return`. 
07:43:38 <dminuoso> Taneb: I dont have any concrete proof, but I think its obvious that it should be a free theorem that if the applicative instance is the same, then the monad instance should be too
07:46:27 <Taneb> :t \fs xs -> join (fmap (\f -> fmap f xs) fs)
07:46:30 <lambdabot> Monad m => m (a1 -> a2) -> m a1 -> m a2
07:47:28 <Taneb> dminuoso: I'm not yet convinced
07:48:21 <Taneb> Hmm, given in my definition of "ap" there, join is only used once, and we know fmap agrees
07:48:28 <shapr> GOOD MORNING #haskell !
07:48:45 <Taneb> We therefore know that in a large portion of cases, join and join' must agree
07:48:57 <MarcelineVQ> shapr: Bah-weep-Graaaaagnah wheep ni ni bong!
07:50:18 <Taneb> Is it all cases?
07:50:56 <Taneb> I don't think so, just all "sufficiently regular" cases
07:50:58 <mniip> what would be a good way to do NonEmpty a -> [a] -> NonEmpty a
07:51:23 <dminuoso> mniip: I did an `mappendish` with a typeclass and shenanigans
07:51:29 <dminuoso> *tyfam!
07:51:41 <mniip> would prefer a stock solution
07:52:23 <dminuoso> mniip: You could use `fromList . mappend f . toList`
07:52:40 <mniip> well I'm trying to factor out a fromList
07:52:42 <lyxia> if GHC were dumber it might have been unsafeCoerce (++)
07:52:42 <dmj`> shapr: top o' the morning to yer
07:53:32 <ski> good mourning, shapr :)
07:53:56 <brschkv> Is anyone else building a haskell projekt via gitlab?
07:53:57 <dmj`> mniip: are you trying to add the elements of [a] into NonEmpty a ?
07:54:05 <MarcelineVQ> stock? foo (x :| xs) ys = x :| (xs ++ ys) :X
07:54:21 <brschkv> currently my build takes about 20 minutes or so.... which is kind of annyoing
07:54:22 <dminuoso> brschkv: Yes
07:54:29 <Taneb> dminuoso: so, I can convince myself that the two join definitions have to agree for things like [[1,2],[3,4]], where the structure is regular (things that can be created by fmap (\x -> fmap (f x) ys) xs )
07:54:33 <brschkv> any best best practices for that?
07:54:46 <Taneb> But not for things not of that form, like [[1], [2,3]]
07:54:58 <dminuoso> brschkv: I dont think "best practices" makes much sense. Do you use stack or cabal v2-*?
07:55:07 <mniip> dmj`, yes
07:55:12 <Taneb> (not necessarily lists but they're easy to illustrate what I mean)
07:55:56 <mniip> foo (x :| xs) ys = x :| xs ++ ys, indeed
07:56:06 <mniip> was wondering if this function is available anywhere
07:56:18 <brschkv> stack 2.1.1
07:56:37 <brschkv> Running a simple "stack test" from baseimage haskell8
07:56:38 <dminuoso> brschkv: So I use cabal v2- but the basic idea shouldnt be much different.
07:56:56 <brschkv> and later stack build
07:57:03 <merijn> brschkv: Do you have -O or -O2 enabled?
07:57:07 <dmj`> mniip: does order matter ?
07:57:15 <brschkv> no, no -O
07:57:15 <dminuoso> brschkv: Do you build using a shell executor?
07:57:40 <mniip> yes
07:57:46 * shapr hops cheerfully
07:58:12 <brschkv> I build using gitlab with a kubernetes runner and the "script: ..." inside the build step
07:58:35 <dminuoso> brschkv: If you were using cabal I would have a few tips for drastically speeding up the build... :-P
07:58:39 <dminuoso> cabal v2-* that is
07:58:55 <brschkv> maybe they can be applied to stack also?
07:59:01 <MarcelineVQ> huh, why doesn't NonEmpty have ++
07:59:20 <brschkv> I think the major bottleneck is the huge haskell8 image as well as downloading all the depencies every time
07:59:29 <MarcelineVQ> oh derp
07:59:43 <dminuoso> brschkv: I gotta blaze to catch the train, but if you are around in 10 minutes Ill share some details.
07:59:51 <c_wraith> MarcelineVQ: <>  :P
07:59:56 <MarcelineVQ> :>
08:00:16 <opqdonut> it's not a monoid >:(
08:00:24 <c_wraith> Semigroup defines <>
08:00:27 <c_wraith> and it is a semigroup
08:00:45 <opqdonut> oh right
08:00:59 <opqdonut> wasn't there a <>=mappend thing going on before?
08:01:09 <c_wraith> yes
08:01:35 <c_wraith> Then Semigroup was made a parent of Monoid, and <> was moved to Semigroup
08:09:44 <dminuoso> brschkv: Right now Im running a haskell docker image on my ci nodes (though Ill shortly switch to just shell executors with ghcup for faster performance). In there, I run cabal v2-builds. I specify cache paths for `/app/dist-newstyle` and `/app/.cabal-store` as well as `/app/.cabal-packages`
08:10:39 <dminuoso> This gives me very short (under a minute roughly) build times including the time of deploying it. Im not certain how stack caches build artifacts at all.
08:12:39 <brschkv> yeah, caching sound like the way to go
08:13:10 <brschkv> I think with stack you can just stack .stack-work etc.
08:13:43 <dminuoso> brschkv: Part of the reason why I want to use shell executor, is because I dont have to cache the global cache store anymore.
08:13:46 <mniip> is there some kind of an initial encoding of a one-hole context of a Traversable1?
08:14:13 <mniip> kmett has a package where he goes with indexing slots in a Traversable1 with an Int
08:14:20 <mniip> but that's unideal
08:16:15 <brschkv> thanks for the input, gotta run myself!
08:16:16 * ski . o O ( "uni‧deal" )
08:30:34 <c_wraith> for when multideal is too complex
08:44:44 <jumper149> Hi, I'm trying to simply build a function to calculate the product of a list, but with the Continuation Monad.
08:44:54 <tabaqui1> Unmortal Joe
08:45:25 <dminuoso> When has ever come something good out of "... with Cont" ?
08:46:18 <tabaqui1> I guess, never. But every week someone is asking "how to build with Cont..."
08:46:19 <jumper149> dminuoso: It's just for fun and understanding, I know that most code with continuations is spaghetto
08:46:29 <monochrom> dminuoso: this? http://www.vex.net/~trebla/haskell/cont.xhtml#yield
08:46:38 <jumper149> http://ix.io/1UFN this is how far ive gotten but its not even compiling ^^
08:46:39 <tabaqui1> I think it is some sort of necessary lesson
08:47:33 <tabaqui1> I mean, I tried Cont on work, but hopefuly nobody knows
08:49:04 <monochrom> and this: http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html
08:49:21 <dminuoso> monochrom: Oh you mean blog posts!
08:49:43 <monochrom> har har har
08:50:22 <monochrom> Also take a look at my Quantifier section.
08:50:49 <monochrom> Actually also exercise 5 in the Yield section
09:26:49 <pigmej[m]> Hmm, given that I have servant app, how can I pass some let's say "clients" down to the handlers. Only custom monad? It seems to be awkward frankly speaking. Anyone aware of some thingy like "config" or whatever?
09:29:27 <jgt> pigmej[m]: welcome back :)
09:29:47 <pigmej[m]> ;-)
09:30:20 <jgt> I'm afraid I can't help; I've only done Yesod and I've never tried Servant
09:30:30 <jgt> but I'm glad to see you're still here
09:30:53 <pigmej[m]> I'm still trying, I gave myself and Haskell one another week to try to do something usefull
09:36:15 <fendor> pigmej[m], you want a monad stack on top of handler?
09:36:47 <pigmej[m]> I'm not sure if I want to add monad
09:36:47 <pigmej[m]> :D
09:37:28 <pigmej[m]> I'm using concurrent-containers to store inmemory data
09:37:37 <pigmej[m]> I have no idea where to store it/how to pass it around in Servant app
09:38:02 <fendor> you could add a Reader Monad to pass it around in handler functions
09:38:10 <pigmej[m]> I have one thingy with: https://haskell-servant.readthedocs.io/en/stable/cookbook/using-custom-monad/UsingCustomMonad.html
09:38:17 <pigmej[m]> but ... it feels awkward
09:39:27 <pigmej[m]> ok, so basically you're suggesting what I already have, right? To use that "custom monad" example and modify / alter it for my needs
09:39:29 <pigmej[m]> and that's the recommended way?
09:39:59 <fendor> yeah, I would recommend that, however, I am not sure if that is the recommended way and I agree, especially at the beginning, this looks very awkward
09:40:29 <pigmej[m]> I'm asking because I saw that pg connection pool is  passed in different way
09:41:04 <fendor> what are they using?
09:41:29 <pigmej[m]> I forgot now :D
09:41:53 <pigmej[m]> ok but following the handler and readerT thingy,
09:42:08 <pigmej[m]> so I have then to `<- ask`  for it?
09:42:30 <fendor> yeah
10:04:25 <dmj`> ask and you shall receive
10:04:30 <dmj`> seq, and ye shall find
10:05:00 * hackage varying 0.7.1.1 - FRP through value streams and monadic splines.  https://hackage.haskell.org/package/varying-0.7.1.1 (SchellScivally)
10:05:17 <dmj`> snoc, and the door shall be open to you
10:07:56 <lyxia> Is there a library/executable that shows the step-by-step evaluation of Haskell programs
10:08:09 <lyxia> I think I saw one recently but I don't remember
10:15:10 <dmj`> lyxia: https://www.well-typed.com/blog/2017/09/visualize-cbn/
10:15:31 * hackage safe-json 1.0.0 - Automatic JSON format versioning  https://hackage.haskell.org/package/safe-json-1.0.0 (nideco)
10:22:16 <lyxia> thanks!
10:29:03 <ski> @remember dmj` ask and you shall receive / seq, and ye shall find / snoc, and the door shall be open to you
10:29:04 <lambdabot> Okay.
10:35:01 * hackage equivalence 0.3.5 - Maintaining an equivalence relation implemented as union-find using STT.  https://hackage.haskell.org/package/equivalence-0.3.5 (PatrickBahr)
10:36:48 <dmj`> ski: :)
10:38:55 <ski> @quote without.complaint
10:38:55 <lambdabot> sm[m] says: <sm[m]> Every task involves constraint, / Solve the thing without complaint; / There are magic links and chains / Forged to loose our rigid brains. / Structures, strictures, though they
10:38:55 <lambdabot> bind, / Strangely liberate the mind.  <MarcelineVQ> or in one line, Art from adversity.
10:41:10 <codedmart> Is there an option to tell stack only to use so much memory for building?
10:43:40 <MarcelineVQ> codedmart: probably not specifically but you can -j1 to keep it to one dependency at a time
10:44:25 <MarcelineVQ> there is rts heap limit you can pass to ghc but idk exactly how it works
11:09:09 <sm[m]> codedmart: as well as -j1 which is easiest, you can try something like —ghc-options=‘+RTS -M500M’ to influence ghc’s heap usage
11:16:55 <Athas> The absolutely most infuriating thing is to have stack unregister large dependencies on every build.
11:18:09 <sm[m]> Athas: because you switched between build, test, profile or haddock mode ?
11:20:58 <Athas> sm[m]: no, nothing like that.
11:21:17 <Athas> After rebuilding those dependencies, Stack even agrees that they are sufficiently unchanged that it does not have to rebuild all my own modules.
11:23:08 <sm[m]> Huh, wonder what’s causing it then
11:24:56 <MarcelineVQ> Athas: do you have git dependencies? that used to be a thing that happened with those
11:25:33 <Athas> MarcelineVQ: nope, everything is quite simple, except for two extra-deps (but those are not the ones that get rebuilt).
11:27:36 <sm[m]> Stack/cabal update ? New revision on hackage ?
11:27:42 <sm[m]> Stack/cabal upgrade ?
11:30:49 <Athas> Now something is completely wrong, and stack thinks the lts-14.4 snapshot does not contain 'text'.
11:31:24 <ski> @forget sm[m] <sm[m]> Every task involves constraint, / Solve the thing without complaint; / There are magic links and chains / Forged to loose our rigid brains. / Structures, strictures, though they bind, / Strangely liberate the mind.  <MarcelineVQ> or in one line, Art from adversity.
11:31:24 <lambdabot> Done.
11:31:50 <ski> @remember James_Falen <someone> Every task involves constraint, / Solve the thing without complaint; / There are magic links and chains / Forged to loose our rigid brains. / Structures, strictures, though they bind, / Strangely liberate the mind.  <MarcelineVQ> or in one line, Art from adversity.
11:31:50 <lambdabot> Good to know.
11:34:58 <sm[m]> Thanks for saving that ski. As I was saying, personally I think the poem deserves to stand alone without MarcelineVQ’s summary. My 2c.
11:38:25 <ski> perhaps
11:38:53 <sm[m]> So whatever you like. No offense Marceline.
11:39:16 <MarcelineVQ> I've no particular opinion on the matter, I say a lot of things so whether the robut stores some of that as platinum cobweb in the storeroom of antiquity or not isn't much of a such
11:39:38 <sm[m]> If anyone’s curious, this seems to be the source: http://stephenfrug.blogspot.com/2008/07/james-falen-odelet-in-praise-of.html
11:40:17 <MarcelineVQ> There's something rather forlorn about being remembered by this robot who'll probaly outlive me anyway, and as if in reflection, how temporary its remembering is.
11:42:36 <sm[m]> Indeed. (Hello our future descendants reading this, possibly. Best wishes to you. Sorry about everything.)
11:43:44 * ski . o O ( SOMA )
11:43:52 <pigmej[m]> after deeper thinking I think that Custom Monad in Servant for some config options makes ~0 sense
11:44:10 <pigmej[m]> because if I have multiple servers in one app then all of them will have to deconstruct that custom monad on every request
11:47:42 <EvanR> custom monads, per se, will involve a performance hit. However you can get a boost by implement the type with church encoding
11:48:00 <EvanR> once you never want to modify that type again... go for it
11:48:05 <merijn> "performance hit" is relative, I would first see if it even matters
11:49:02 <EvanR> yeah it might not be anywhere close to the largest performance hits you have globally
11:49:24 <EvanR> such as... "using web technology"
11:49:36 <pigmej[m]> so the question is what's the best way to do let's say inmemory "cache" in servant
11:50:13 <dmwit> Toss a TVar in your ReaderT, I guess.
11:50:14 <EvanR> can't you forkIO a special cache thread that delivers cached data to request handlers
11:50:20 <EvanR> or that
11:50:38 <EvanR> was thinking like elixir
11:50:52 <dmwit> There's probably a package out there for finer-grained updates if that turns out to be important.
11:51:18 <pigmej[m]> ok so essentially the way that I have it now that's the answer
11:51:26 <pigmej[m]> I was kinda following https://haskell-servant.readthedocs.io/en/stable/cookbook/using-custom-monad/UsingCustomMonad.html
11:52:16 <dmwit> Do you have a reason to mistrust the Servant documentation on this?
11:52:35 <pigmej[m]> most of these examples are kinda "one off"
11:52:50 <pigmej[m]> without explaining how to glue them together or how to design 'bigger' thingy
11:52:57 <pigmej[m]> all examples there usually use one type
11:53:39 <pigmej[m]> and if I'm not mistaken runReaderT is one per whole App
11:53:57 <Rembane> What happens if you mash them together and massage the types until the typechecker becomes happy? 
11:54:04 <dmwit> What does "one per whole App" mean to you?
11:54:19 <dmwit> (one what?)
11:54:44 <pigmej[m]> dmwit https://gist.github.com/pigmej/db300480486a7f4a1cd7f510922a321c
11:55:00 <pigmej[m]> or maybe https://gist.github.com/pigmej/b04b2a7176728fc80ef1330942d4c5d1 better
11:55:20 <pikajude> so i was reading the lens source code and every definition including class methods has {-# INLINE #-} marked
11:55:31 <pikajude> i thought class methods were already inlined by default?
11:55:48 <pigmej[m]> and if I'm not mistaken Application is the top most thingy in servant and you cant `:<:>` Applications
11:56:01 <pigmej[m]> I meant `:<|>` obviously
11:56:31 <merijn> pikajude: What do you mean "by default"?
11:57:22 <pikajude> merijn: as in, an inline pragma would be redundant? i'm actually not sure how ghc does inlining
11:57:38 <pikajude> i may not have sufficient knowledge to ask this question properly
11:58:26 <merijn> pikajude: GHC has a bunch of heuristics on how likely inlining is to allow further optimisations (i.e. small functions are more likely to be inlined, because they cost less so have less chance to have negative impact
11:58:43 <merijn> pikajude: It's definitely not the case that typeclass methods are "always" inlined
11:58:46 <pikajude> okay
11:58:56 <shapr> Can cabal add library version constraints for me? That is, can I ask cabal which versions are being used, maybe even cabal can spit out a project.cabal that includes the libraries and version numbers?
11:59:05 <geekosaur> cabal freeze
11:59:06 <merijn> pikajude: OTOH, if you have monomorphic applications of a typeclass it's very likely that they will be specialised and inlined
11:59:08 <geekosaur> ?
11:59:12 <shapr> geekosaur: oh, lemme try that!
11:59:24 <pikajude> cool, thanks merijn 
11:59:33 <merijn> shapr: That doesn't actually add them to your cabal file, but it will output a file with exact (transitive) versions
12:00:14 <merijn> pikajude: Note that "{-# INLINE #-}" is "Inline this, I'm not joking!" (which can be dangerous, because it can blow up code size and hurt performance
12:00:19 <dmwit> pigmej[m]: Okay. At this point I think you're getting to servant-specific stuff that I might not be able to help with as much. But the question as asked at the moment seems like a kind mismatch is going on somewhere. 
12:00:37 <merijn> pikajude: But lens has quite some effort put into making sure inline melts most of the intermediate code away
12:00:42 <shapr> geekosaur: oh this is nice, thanks!
12:00:55 <dmj`> pigmej[m]: seems like you did it right
12:00:56 <shapr> merijn: this is what I wanted, so I'm fine with it
12:01:04 <pigmej[m]> to simplyfy the stuff. Given https://haskell-servant.readthedocs.io/en/stable/cookbook/using-custom-monad/UsingCustomMonad.html and to modify that to store Books and FooBar
12:01:14 <pigmej[m]> I'm assuming that I have to have custom monad that handles both Books and FooBars
12:01:17 <merijn> shapr: Yeah, it's what I use for my research code to ensure others will build the exact same versions I use :)
12:01:36 <pigmej[m]> and "deconstruct" it on any request (`_` the not needed part though) and pass down the needed part only, right?
12:02:22 <dmwit> I don't think that should be necessary, no.
12:02:29 <pigmej[m]> I'm also asking because I saw servant-persistent is doing some magic like: https://github.com/parsonsmatt/servant-persistent/blob/master/src/Config.hs#L64
12:02:41 <dmj`> pigmej[m]: you never have to have a custom monad per se, you can always pass your state into the function app = \config -> foo config :<|> bar config, the natural transformation should simplify it.
12:02:46 <dmwit> That would certainly be one implementation choice you could make, though.
12:03:29 <dmj`> pigmej[m]: if you're using a ReaderT, then you can take advantage of MonadBaseControl IO instances, and use lifted-base / lifted-async, which lets you fork threads without escaping into IO forever.
12:03:31 <merijn> hmm, does anyone know if there's some easy way to do tabulation with prettyprinter or should I just pre-compute column widths and do it myself?
12:03:35 <dmwit> e.g. you could `app booksConfig fooConfig = books booksConfig :<|> foo fooConfig` and I don't see any destructuring there.
12:03:38 <pigmej[m]> so which one is better / more haskelish ?
12:03:50 <merijn> dmwit: Why MonadBaseControl over MonadUnliftIO?
12:04:02 <pigmej[m]> dmwit yeah but then I don't need a monad at all
12:04:11 <dmwit> You never need a monad.
12:04:14 <dmwit> You may use a monad if you like.
12:04:22 <pigmej[m]> and that's where the discussion started :)
12:04:22 <merijn> I don't think any beginners (or even experts) live ever improved by using MonadBaseControl :)
12:04:23 <pigmej[m]> what's better
12:04:28 <dmwit> Indeed, `books` might be `books x = runReaderT realBooks x` or whatever.
12:04:52 <dmwit> merijn: Why do you believe I think you should use MonadBaseControl over MonadUnliftIO?
12:05:19 <dmwit> merijn: For tabulation: I have wished for this also. If you want to do a lot of it, you could consider the boxes package as an alternate pretty-printer.
12:05:23 <merijn> dmwit: Because you recommended/mentioned one and not the other :)
12:05:29 <dmwit> merijn: When?
12:05:39 <dmj`> if you want the cadillac... The ability to call `use <your-lens-goes-here>`, and fork threads that can still call 'use', then lifted-async + lens is very nice.  
12:05:42 <dmj`> merijn: that was me
12:06:04 <pigmej[m]> dmwit so basically the question that I started with is, what's more Haskellish solution
12:06:13 <pigmej[m]> or what's just better in any terms
12:06:20 <dmj`> srrry :P I'll stay out of this
12:06:22 <merijn> dmwit: oh, I think I failed to tab complete :)
12:06:46 <merijn> s/dmwit/dmj`/ ;)
12:07:09 <dmwit> pigmej[m]: For just one TVar, I'd just pass it around. If I started adding any more effects than that, I'd make a transformer stack.
12:07:22 <dmwit> I see no reason to expect the transformer stack to be exactly the same on both sides of your :<|>.
12:08:42 <pigmej[m]> hmmm
12:09:12 <merijn> dmwit: I'm already using prettyprinter for a bunch of stuff, and boxes seems rather limited, tbh
12:09:40 <merijn> Relatedly: persistent doesn't expose aggregate queries, I guess?
12:09:57 <pigmej[m]> dmwit ok, that's the answer / suggestion that I wanted to hear :) Thanks
12:16:43 <dmj`> the transfomer stack unfortunately has to be the same for each handler in foo :<|> bar :<|> baz, if you're using the nat function. Otherwise you'd need something like \config -> runReaderT (bar :: ReaderT IO Handler a) config :: Handler a :<|> baz :: Handler a 
12:17:01 <dmj`> ReaderT Config Handler a *
12:23:01 * hackage tree-sitter-php 0.1.0.1 - Tree-sitter grammar/parser for PHP  https://hackage.haskell.org/package/tree-sitter-php-0.1.0.1 (patrick_thomson)
12:24:44 <dmj`>  which is kind of like applying a bunch of little nats to each handler
12:24:58 <dmwit> ("nat"?)
12:25:26 <dmj`> dmwit: yea, short for natural transformation I guess :/ 
12:25:38 <dmj`> per the haddocks
12:25:41 <dmj`> >>> let mainServer = hoistServer readerApi nt readerServer :: Server ReaderAP
12:25:49 <dmj`> oh, just "nt" here
12:26:13 <dmj`> let nt x = return (runReader x "hi")
12:26:26 <dmj`> http://hackage.haskell.org/package/servant-server-0.16.2/docs/Servant-Server.html#v:hoistServer
12:26:49 <dmwit> Why is running each argument to :<|> a problem?
12:33:24 <dmj`> It's not, but if you have a lot of handlers, it just gets repetitive.
12:35:59 <pigmej[m]> ok guys really that's more thatn I wanted ;)
12:42:03 <pigmej[m]> I do have tthat nt in my stack too but I'm not sure if I understand it for now fully
12:43:19 <cheater> when using yesod and persistent, if i have a model called Foo and a model called Bar with a foreign key into Foo,  and I have a value that's a FooKey, how do i get the related Foo record?
12:44:12 <merijn> cheater: Via one of persistent's various functions for querying based on keys? :)
12:45:20 <dmj`> pigmej[m]: servant has a typeclass named HasServer, it has an associated type family defined inside of it that performs typeclass induction over your application's API type. The base case of that recursion is always Handler a.
12:45:47 <dmj`> pigmej[m]: you'll see the HasServer constraint on serveWithContext
12:45:52 <argent0> hi, I've `forall s m . (HasFoo s Bool, MonadState s m) => m ()` to descrive a function that only modifies the Foo field of s. Is there another, possibly prefered, way to state that?
12:46:46 <pigmej[m]> dmj` so to modify that recursion hoistServer and nt have been introduced to allow to change that behaviour?
12:47:21 <dmj`> pigmej[m]: servant requires all your handlers (the things in a :<|> b :<|> c :<|> d), to all be of type Handler a.
12:47:42 <pigmej[m]> yeah
12:48:14 <dmj`> pigmej[m]: the nt function is like a preprocessing step that allows you to convert your custom monad back into Handler a, so everything will typecheck
12:48:36 <pigmej[m]> ok, and then "ask" to retrieve my custom stuff again
12:48:39 <dmj`> pigmej[m]: so it will let you define a :<|> b :<|> c :<|> d, where they are all of type YourMonad a
12:49:01 <shapr> Is there a more sensible choice than ini file format for config in Haskell?
12:49:04 <pigmej[m]> yeah
12:49:08 <dmj`> pigmej[m]: yea, the nice part is you don't have to do runReaderT a config :<|> runReaderT b config :<|> ...
12:49:40 <merijn> shapr: Dhall!
12:49:44 <dmj`> because nt is doing that for you behind the scenes
12:49:48 <shapr> merijn: tempting
12:49:51 <merijn> shapr: Depends on how complex you need to get :)
12:50:01 <merijn> shapr: I've been looking for an excuse to use Dhall for ages :p
12:50:05 <koz_> When I put a release candidate up, I can't see any generated Haddocks. Do I just have to wait a while, or do release candidates just not do that?
12:50:19 <pigmej[m]> dmj` but the cost is that I have to deconstruct my "state"
12:50:20 <merijn> koz_: Just upload docs yourself
12:50:30 <merijn> koz_: Hell, do that for non candidates too
12:50:38 <merijn> koz_: Saves everyone waiting for them to get built
12:50:42 <dmj`> pigmej[m]: yea, but speed isn't a problem, is it ?
12:50:58 <koz_> merijn: Will cabal new-sdist do this?
12:51:05 <pigmej[m]> it may be but I'm pretty sure that there is shitload of other "speed" issues
12:51:08 <MarcelineVQ> shapr: depends how invested you are. glguy did a thing https://hackage.haskell.org/package/config-value
12:51:09 <pigmej[m]> than deconstruct one type
12:51:11 <shapr> merijn: I have three or four values
12:51:14 <merijn> koz_: "cabal v2-haddock --haddock-for-hackage" should
12:51:16 <shapr> MarcelineVQ: yeah, I think I'll try that
12:51:19 <dmj`> pigmej[m]: if you are accessing a database then network + disk I/O will be your bottleneck.
12:51:33 <merijn> koz_: Maybe "cabal v2-haddock --haddock-for-hackage all" if you have multiple packages
12:51:33 <dmj`> pigmej[m]: the database is always the bottleneck, or you're doing something weird I'd say
12:51:37 <pigmej[m]> no DB :D
12:51:41 <koz_> merijn: Just the one.
12:51:42 <merijn> koz_: That should build docs tarballs for you
12:51:49 <pigmej[m]> dmj` I know I know ;)
12:51:57 <koz_> merijn: OK, I will attempt this.
12:52:04 <merijn> koz_: You can just upload them via cabal upload like you do with candidates
12:52:11 <dmj`> pigmej[m]: no DB sounds nice
12:52:15 <dmj`> no data no problems
12:52:25 <koz_> merijn: I used the web UI of Hackage.
12:52:39 <merijn> koz_: Well, now you know you can use cabal upload too ;)
12:53:08 <merijn> koz_: You can even integrate it with your password manager for authentication (assuming your password manager has a commandline tool)
12:53:33 <EvanR> why isn't NoDB a thing
12:53:54 <EvanR> as in, someone convinced a throng of designers to make countless cool looking 1 page sites about it
12:55:01 <EvanR> it sounds even more marketable than NoSQL
12:56:40 <dmwit> shapr: https://hackage.haskell.org/package/config-value ?
12:57:05 <koz_> merijn: Yay it worked!
12:57:24 <koz_> Also - I have some missing links for external stuff. What do I need to do to have those available in my documentation? 
12:57:28 <dmwit> shapr: See also config-schema and config-value-getopt.
12:57:35 <koz_> 'External stuff' means 'packages I did not write and that aren't in base'.
12:58:53 <merijn> koz_: Probably the problem is that there were no local docs for those. I generally set "documentation: True" in ~/.cabal/config to always build documentation so that things "just work"
12:59:05 <koz_> merijn: OK, shall do that.
12:59:21 <merijn> koz_: Maybe with v2-build it just works if you toggle it on now and then rebuild
13:00:43 <koz_> merijn: Seems to, yeah.
13:00:58 <dmwit> EvanR: ("Is /dev/null web scale?")
13:01:00 <koz_> (since it's rebuilding a tonne of stuff, and there's Haddock invocations in there)
13:01:15 <dmj`> EvanR: someone had a joke repo of it a while ago iirc
13:01:22 <EvanR> ok good
13:05:48 <koz_> merijn: I tried that, rebuild, regenerated docs, and reuploaded, but I still don't have links to, say, Data.Vector.Sized.Vector where appropriate.
13:05:54 <koz_> s/rebuild/rebuit/
13:06:00 <koz_> s/rebuit/rebuilt/ argh
13:06:08 <merijn> koz_: Can you link the candidate?
13:06:16 <koz_> https://hackage.haskell.org/package/finitary-0.1.0.0/candidate/docs/Data-Finitary.html
13:07:57 <merijn> Which link isn't work, because for me the one in the instance lists works
13:08:42 <koz_> Vector, Bit (either one) - they don't even come up.
13:09:04 <koz_> The instance for 'Finitary Bit' (either one) has no link for 'Bit', for example.
13:09:15 <koz_> Is Firefox caching doing funny things to me again?
13:09:21 <merijn> koz_: They work for me? Try force refreshing your page? :)
13:09:40 <koz_> merijn: Yep, I see them now. Firefox argh.
13:09:42 <koz_> Thanks!
13:12:12 <koz_> OK, I think I will go make and eat breakfast, take one last look at the candidate, and then publish.
13:12:29 <koz_> Something something first ever library on Hackage.
13:16:35 <monochrom> breakfast? are you in Hawaii? :)
13:18:09 <MarcelineVQ> koz_: is a being outside of time that exists within a rather large double-walled lightbulb
13:18:51 <merijn> pffft
13:18:56 <geekosaur> nz? :p
13:19:11 <merijn> Why do none of the prettyprinters have a leftpad, only rightpad :\
13:19:39 <koz_> geekosaur has it right.
13:19:57 <merijn> At least JavaScript had a leftpad... >.>
13:23:00 * hackage linnet 0.4.0.0 - Lightweight library for building HTTP API  https://hackage.haskell.org/package/linnet-0.4.0.0 (sergeykolbasov)
13:24:00 * hackage linnet-aeson 0.4.0.0 - Aeson JSON support for Linnet  https://hackage.haskell.org/package/linnet-aeson-0.4.0.0 (sergeykolbasov)
13:25:00 * hackage linnet-conduit 0.4.0.0 - Conduit-backed support for streaming in Linnet  https://hackage.haskell.org/package/linnet-conduit-0.4.0.0 (sergeykolbasov)
13:25:46 <remexre> are there any strongly typed miniKanren implementations I've missed in a quick glance over minikanren.org?
13:25:48 <freeman42x> where can I find a solution for the equivalent of a stopwatch? Basically start counting from some point and to be able to get the time passed since that starting point later.
13:26:42 <Rembane> freeman42x: Does this package solve your problem? http://hackage.haskell.org/package/clock
13:27:00 <freeman42x> Rembane, how would I use it:?
13:27:39 <Rembane> freeman42x: By running getTime twice and then diffTimeSpec 
13:28:19 <freeman42x> Rembane, I do not follow. The idea would be to start a timer. And then later be able to get the time passed since the timer started
13:28:32 <freeman42x> how would getTime getTime and diffTimeSpec work like that?
13:28:42 <merijn> freeman42x: How is that different from getting the time difference between two times?
13:29:17 <freeman42x> merijn, it is a much easier API, that is how
13:29:32 <merijn> freeman42x: What would the API look like?
13:30:06 <freeman42x> you would call some function startStopWatch and then later a call to getTimePassed would return the time passed since the stopWatch started
13:31:13 <merijn> I mean, if it makes you happy you can do "newtype Start = Start TimeSpec; newtype Stop = Stop TimeSpec; start :: IO Start; start = Star <$> getTime; stop :: IO Stop; stop = Stop <$> getTime; timeDiff :: Start -> Stop -> TimeSpec; timeDiff (Start ts1) (Stop ts2) = diffTimeSpec ts1 ts2", I suppose
13:31:16 <Rembane> freeman42x: If you give getTime those names you almost have that api. 
13:31:59 <freeman42x> merijn, I'll try to see if I can understand your example
13:32:03 <merijn> Alternatively "stop :: Start -> IO TimeSpec; stop (Start ts) = diffTimeSpec ts <$> getTime" *boom*
13:32:20 <merijn> Or rename "Start" as StopWatch, I suppose
13:35:26 <shapr> yeah, config-value is nice, though confusing at first glance
13:46:31 * hackage sequenceTools 1.4.0.1 - A package with tools for processing next generation sequencing data, in particular for processing data from ancient DNA sequencing libraries.  https://hackage.haskell.org/package/sequenceTools-1.4.0.1 (stephan_schiffels)
13:47:19 <jle`> tired: sequenceA
13:47:21 <jle`> wired: sequenceDNA
13:47:30 * hackage sequenceTools 1.4.0.2 - A package with tools for processing DNA sequencing data  https://hackage.haskell.org/package/sequenceTools-1.4.0.2 (stephan_schiffels)
13:48:36 <MarcelineVQ> fired: sequenceDINODNA
13:48:49 <monochrom> I think more people are interested in how to get hired. >:)
13:49:40 <monochrom> Does an emperor get sired? >:)
14:00:53 <Guest66> Hey. Is there a type-level utility for me to specify that a kind is one of some possible kinds?
14:01:23 <Guest66> Like `x :: '[ThisKind, OrThisKind, OrThisOtherKind]`
14:05:51 <geekosaur> I don't know if you can do "kind classes" yet but that's about the only way you'd be able to do it
14:06:07 <Guest66> geekosaur: I thought about encoding it with either.
14:06:33 <Guest66> Like: `type family Bla (k :: Either A B) where Bla (Left AD) = ...`
14:06:46 <Guest66> But its verbose, cumbersome.
14:08:00 * hackage finitary 0.1.0.0 - A better, more type-safe Enum.  https://hackage.haskell.org/package/finitary-0.1.0.0 (koz_ross)
14:12:06 <koz_> I took the plunge folks.
14:15:34 <hololeap> is there a way to get ghc to dump all available modules?
14:17:56 <c_wraith> hololeap: you can use ghc-pkg to list all available packages, and to list the modules in each package.  I don't think there's any combination of those operations
14:18:35 <jle`> Guest66: honesty it's the same thing for the value-level as well
14:18:37 <jle`> koz_: congrats :D
14:19:43 <Guest66> jle`: I've been reading your introduction to singletons.
14:19:47 <Guest66> Great material!!!!
14:19:50 <Guest66> Thank you very much!
14:20:24 <hololeap> sadly, i don't have access to ghc-pkg. i'm working with one of those coding challenge websites, and they do list which packages are available, but they don't list all their dependencies, so it's hard to know what modules are available
14:20:28 <jle`> Guest66: ah, thank you :)
14:20:57 <hololeap> i can use the OPTIONS_GHC pragma to pass options to GHC and the website shows the output of the compilation
14:21:10 <jle`> Guest66: yeah, the problem you have exists for values and types as well, so i don't think there's necessarily anything special you'd do for kinds
14:21:16 <hololeap> but that's all i have at my disposal
14:21:16 <jle`> other than the normal term-level solutions
14:22:19 <jle`> the simplest one being to make your own sum type, data IntOrStringOrBool = I Int | S String | B Bool
14:22:26 <jle`> and some more complicated ones with open sums
14:22:43 <Guest66> Got it.
14:22:48 <Guest66> .-.
14:22:50 <Guest66> Thanks.
14:23:21 <Guest66> What I'm actually trying to do is encode: `data Foo = Bar Nat` as a singleton.
14:23:24 <Guest66> And use that in a vinyl record.
14:23:44 <Guest66> https://github.com/goldfirere/singletons/issues/76
14:23:49 <Guest66> I used this trick to do it.
14:24:31 <jle`> how do you want to use it in a vinyl record?
14:24:37 <Guest66> But this trick is not so good if you have a big datatype like `Foo = Bar Nat | Ble | Bli | Blo ...`
14:25:03 <jle`> Rec Identity '[Foo] ?
14:26:32 <Guest66> More like ... `type family Something ... Something (Bla 1) = sometype`
14:26:48 <jle`> hm, i'm just not sure how this relates to vinyl records
14:27:07 <Guest66> `Rec SomethingAttr ...`
14:27:15 <jle`> like Rec Something '[ 'Bar 3, 'Ble, 'Bli ] ?
14:27:23 <Guest66> Yes.
14:27:55 <jle`> ah. hm, the issue you used doesn't have this trick, but i think there's another one that covers the way i'd do it
14:28:00 <jle`> is to parmaeterize Foo based on the Nat type
14:28:08 <jle`> data Foo nat = Bar nat | Ble | Bli | ...
14:28:21 <Guest66> I have multiple nats.
14:28:22 <jle`> that way genSingletons will do the "right thing", and singlize Foo Nat to demote to Foo Natural
14:28:30 <Guest66> `Bar 1, Bar 2, Bar 3`
14:28:38 <jle`> nat is a type variable here
14:28:51 <jle`> so Bar 1 :: Foo Nat
14:29:21 <jle`> so now `Foo Nat` is your original Foo type, and `Foo Natural` is your term-level type
14:29:57 <jle`> so you would have `'Bar 1`, `'Bar 2`, etc. the type have kind Foo Nat
14:30:10 <Guest66> And there's no problem with it?
14:30:12 <jle`> so '[ 'Bar 1, 'Bar 3, 'Ble ] :: [Foo Nat]
14:30:22 <jle`> i mean, i'm proposing this for you
14:30:27 <jle`> so you tell me if you have a problem :)
14:30:36 <Guest66> I liked your solution.
14:30:44 <jle`> i'm still not 100% sure if this is what you want
14:31:08 <Guest66> Didn't think in it because the `Nat` in `Foo` is meaningless.
14:31:53 <Guest66> I basically wan't a vinyl record where I can have `Bar 1, ..., Bar n` without having to write `Bar1, Bar2, BarN...`
14:32:00 * hackage interactive-plot 0.1.0.0 - Interactive quick time series plotting  https://hackage.haskell.org/package/interactive-plot-0.1.0.0 (jle)
14:32:25 <jle`> ah yeah, you can do that in this case, your values would have kind Foo Nat
14:32:45 <jle`> so Rec :: (Foo Nat -> Type) -> [Foo Nat] -> Type
14:33:08 <jle`> it's common to call that parameterized Foo Foo', and then maybe do `type FOo = Foo' Nat`
14:33:19 <jle`> but i like leaving it with the type parameter, it makes me think of it as a functor
14:33:39 <Guest66> As a functor? Now I'm confused. xd
14:33:59 <jle`> well, notice the parmaeterized Foo is now a Functor
14:34:10 <jle`> if you DeriveFunctor it, you can fmap over it and everyhting
14:34:22 <jle`> fmap :: (a -> b) -> Foo a -> Foo b
14:34:47 <jle`> even if you only ever use it wiht Nat as an argument
14:36:38 <Guest66> I liked it.
14:37:01 <Zer000> Has anyone here used Squeal for sql? How did it go?
14:38:54 <Guest66> jle`: Thanks.
14:39:39 <jle`> Guest66: np :)
14:43:47 <dmj`> using ghcid is really like bowling with bumpers when you think about it
14:45:50 <EvanR> humiliating and ultimately pointless?
14:50:33 <dmj`> very helpful and fun
14:50:41 <dmj`> =D
14:50:50 <EvanR> oh. right
14:54:32 <jle`> it's like a tube that runs from the golf tee to the hole
14:55:43 <EvanR> i guess that might be fun once
14:57:29 <jle`> it will be fun once i win golf tournaments with huge payouts ez pz
14:58:31 <jle`> the fun part is spending the money of course
15:07:50 <dmj`> wonder if we could make an ML model to automatically detect and fix type errors.
15:08:09 <dmj`> if we all hooked up our ghcid's and source code to some server
15:08:29 <dmj`> it could provide recommendations as to how to fix the error
15:41:43 <pikajude> is there a compiler flag that can disable warnings that come from qReport?
16:04:07 <__monty__> dmj`: MLonCode was a big topic at fosdem this year, the presentations are all available online if you're interested.
16:23:57 <dmj`> wild
16:25:00 * hackage orderly-workers 0.1.0.2 - Fork concurrent worker threads and produce ordered results  https://hackage.haskell.org/package/orderly-workers-0.1.0.2 (TomMurphy)
16:45:15 <hpc> aw, that package could have been called orderlies
16:48:01 <koz_> hpc: Lawl.
17:10:00 * hackage split-morphism 0.1.0.1 - Split Epimorphisms and Monomorphisms  https://hackage.haskell.org/package/split-morphism-0.1.0.1 (gvolpe)
17:22:46 <koz_> What is the kind of https://hackage.haskell.org/package/hedgehog-1.0/docs/Hedgehog.html#t:MonadGen ?
17:22:57 <koz_> I assume Type -> Type, but wanted to make sure.
17:37:36 <hpc> Monad m determines the argument's type
17:37:40 <hpc> :k Monad
17:37:41 <lambdabot> (* -> *) -> Constraint
17:38:01 <hpc> so m :: (Type -> Type)
17:38:09 <hpc> and it's a class, so it results in a Constraint
17:38:13 <hpc> so it's the same kind as Monad
17:38:46 <hpc> koz_: ^
17:39:13 <koz_> hpc: Thanks - good to know I was right.
18:10:29 <jusss> instance (Monad m) => Monad (MaybeT m) where    
18:10:38 <jusss> x >> f = MaybeT $ do ...
18:10:56 <jusss> where we put MaybeT here? I thought return will add MaybeT
18:11:36 <hpc> return has a different type from the MaybeT data constructor
18:11:51 <iqubic> It does?
18:11:59 <iqubic> :t MaybeT
18:12:01 <lambdabot> m (Maybe a) -> MaybeT m a
18:12:02 <jusss> no, there's return = lift . return
18:12:18 <hpc> :t return
18:12:20 <lambdabot> Monad m => a -> m a
18:12:25 <hpc> return :: a -> MaybeT m a
18:12:42 <jusss> and I tried lift (Just 3) :: MaybeT Maybe Int, and the return value has MaybeT constructor
18:12:44 <iqubic> return = lift . Just
18:13:10 <jusss> so I think return in Monad (MaybeT m) can return MaybeT value constructor
18:13:35 <jusss> so why x >>= f = MaybeT $ do ... ? 
18:14:07 <iqubic> It's just a stylistic choice there.
18:14:45 <jusss> iqubic: so can we remove it?   x >>= f = do .... ?
18:15:41 <hpc> i don't know that you can define it with lift either
18:15:51 <hpc> lift gets you m a -> MaybeT m a
18:16:09 <hpc> but then you can only use that to express the (Just _) case
18:16:39 <jusss> :t lift (Just 3)
18:16:40 <lambdabot> (MonadTrans t, Num a) => t Maybe a
18:16:52 <hpc> that's backwards
18:17:14 <hpc> you can have MaybeT IO Int
18:17:34 <hpc> but trying to do that lift similarly would be IOT Maybe Int
18:17:46 <hpc> and IOT can't be safely defined
18:18:34 <jusss> yeah, I know that, the question here is I thought return = lift . return in Monad (MaybeT m) already has the ability to return value with the value construtor MaybeT, we shouldn't put MaybeT in the x >>= f =MaybeT $
18:29:09 <dmwit> Why would the definition of return or lift have any impact at all on the definition of (>>=)?
18:30:16 <jusss> dmwit: sorry, I don't parse you sentence
18:30:51 <dmwit> You say "return uses the MaybeT constructor, therefore (>>=) should not use the MaybeT constructor". Why?
18:32:57 <dmwit> I just don't understand why the first fact should imply anything about the second fact one way or another.
18:34:11 <jusss> dmwit: lift (Just 3) :: MaybeT Maybe Int, it will return a value MaybeT (Just (Just 3))
18:34:25 <jusss> dmwit: lift can return the value with MaybeT value constructor
18:34:37 <dmwit> jusss: Let's make this very hypothetical.
18:34:50 <dmwit> jusss: Suppose I tell you that I have implemented two functions, frobnosticate and wambazzle.
18:35:13 <dmwit> jusss: I also tell you that frobnosticate calls grabdicate.
18:35:20 <dmwit> jusss: Does wambazzle call grabdicate?
18:36:07 <jusss> dmwit: so you mean lift in return = lift . return has the ability to return value constructor and the final return hasn't?
18:36:31 <dmwit> I don't mean anything of the sort. In fact, I haven't mentioned lift or return at all in my hypothetical.
18:36:52 <dmwit> And I eagerly await your answer to whether wambazzle calls grabdicate.
18:36:58 <jusss> dmwit: no
18:37:02 <dmwit> How do you know?
18:37:11 <jusss> dmwit: I don't know
18:37:16 <dmwit> So why did you say no?
18:37:41 <dmwit> "I don't know" is the correct answer.
18:37:56 <dmwit> It is also the correct answer to "return calls MaybeT. Does (>>=) call MaybeT?".
18:38:22 <dmwit> There is no reason to think that "return calls MaybeT" means "(>>=) calls MaybeT". There is no reason to think that "return calls MaybeT" means "(>>=) does not call MaybeT".
18:38:26 <jusss> dmwit: wait, MaybeT should be the context?
18:38:39 <jusss> dmwit: MaybeT m is the monad,
18:39:03 <dmwit> (For completeness: there is no reason to think that "return does not call MaybeT" means "(>>=) does not call MaybeT". There is no reason to think that "return does not call MaybeT" means "(>>=) calls MaybeT".)
18:43:18 <iqubic> return and (>>=) are two separate functions.
18:44:22 <jusss> dmwit: if there's no return, and that MaybeT should be given by f in x >>= f
18:45:18 <jusss> dmwit: do we put Just in the x >>= f = Just $ ... when Maybe is the monad?
18:45:37 <dmwit> Okay, this question is much better.
18:45:53 <dmwit> The trick is that we want to use the (>>=) of the transformed monad.
18:46:01 <dmwit> To do that, we must unwrap the MaybeT wrapper that f provides.
18:46:11 <dmwit> But then, to be type-correct, we must rewrap eventually.
18:46:26 <mozzarella> what's a monad?
18:46:50 <dmwit> oh dear
18:47:27 <dmwit> mozzarella: You may like http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html or
18:47:29 <dmwit> ?where aam
18:47:30 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
18:47:46 <dmwit> There are many other resources available if you search for them, but those two are my personal favorites.
18:47:56 <Guest_64> hi may i ask why it appears
18:47:57 <Guest_64> Failed to install, consider updating this script via: ghcup upgrade"ghcup --cache install" failed!
18:53:01 <dmj`> mozzarella: a monad is anything that obeys the monad laws
18:53:31 * dmj` *drops mic*
19:03:30 <koz_> I'd like to add the Typeclassopedia to dmwit's recommendations.
19:06:15 <laika___> hi cocreature, i was told you might have some thoughts about how ghcide stacks up against the current state of hie?
19:20:03 <ysangkok> when i see "<<loop>>" thrown as an error, where could i come from? it is hard to google
19:22:23 <iqubic> I think that means you have created an infinte loop somewhere.
19:22:52 <lyxia> "haskell loop exception" returns quite a few relevant results.
19:26:43 <ysangkok> ah thanks!
19:29:03 <pavonia> Internally attoparsec's Parser type is defined based on an error and a success continuation, while parsec and megaparsec further distinguishes those for consumed and empty inputs. What is the advantage of having four such continuations over only two? Is this related to error reporting?
19:30:03 <lyxia> it's a way to have more fine-grained backtracking
19:30:19 <lyxia> for (mega)parsec
19:30:54 <pavonia> Do you have an example?
19:38:42 <lyxia> Imagine a parser like     (keyword "if" *> ... {- parse if expresion -}) <|> (keyword "case" *> ...) <|> (keyword "fun" *> ...) <|> ...
19:39:11 <lyxia> then the parsec way makes it so that if you successfully parse one keyword, but fail afterwards, then you won't try any other alternative.
19:39:40 <lyxia> (It's not a particularly motivating example though.)
19:40:45 <lyxia> It really adds up when you have multiple branches with overlapping prefixes
19:43:50 <pavonia> Hhm, I don't immediately see the relation to those continuations, tbh
19:44:31 * hackage warp 3.3.1 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.3.1 (KazuYamamoto)
19:49:31 * hackage warp-tls 3.2.8 - HTTP over TLS support for Warp via the TLS package  https://hackage.haskell.org/package/warp-tls-3.2.8 (KazuYamamoto)
19:52:00 <dogonthehorizon> Hi all, I'm trying to write some property tests for exercises in Invitation to Applied Category Theory. I'm trying to abstract the suite of tests that are "foo preserving" in the first exercise into a function, but I'm having trouble expressing the right signature. I can't seem to keep the function signature very general without getting an error about concrete types. I've tried adding type hints for Int at
19:52:02 <dogonthehorizon> various places between the "suite" and my attempt at passing `id` to no avail. Here is a minimal example with the error I'm seeing: https://gist.github.com/dogonthehorizon/6284facebda5c4e578d90b6058a09623 Any pointers on what I might try next to get this to compile?
19:54:39 <lyxia> you want the function `fn` to be polymorphic in the body of the test?
19:55:20 <argent0> ((Eq x) => x -> x) should handle every possible Eq x. Not just Int
19:55:38 <dogonthehorizon> That would be ideal, I put the Int constraints on the assumption that _somewhere_ I have to bind x/y to something. I suppose I haven't tried leaving the hints off the property inputs and binding them to `id` instead, for example.
19:56:51 <lyxia> you can do `String -> (Int -> Int) -> TestTree` (specializing the function before passing it to the test) or `String -> (forall x. Eq x => x -> x) -> TestTree` (if you are passing polymorphic functions around, you will need explicit foralls in the right places)
19:59:27 <lyxia> note that forall x. Eq x => x -> x   is  forall x. (Eq x => (x -> x))   which is different from   (forall x. Eq x) => x -> x   (in the last one, the last two x are not the same as the first two x).
19:59:48 <Guest_85nart> trying to install Haskell. nothing happens when I type ghci
20:00:10 <argent0> Guest_85nart: type `which ghci`
20:00:40 <Guest_85nart> still nothing
20:00:55 <argent0> dogonthehorizon: also give your example you might want con consider `(forall x . Ord x => x -> x)`
20:00:56 <maerwald> Guest_85nart: did you use ghcup?
20:01:29 <Guest_85nart> yes
20:01:41 <maerwald> Did you follow the instructions at the end of the installation process wrt PATH?
20:01:59 <iqubic> Is ghcup still being supported?
20:02:09 <maerwald> iqubic: supported?
20:02:59 <Guest_85nart> I don't think so, how do create the environment file /Users/natealbers/.ghcup/env
20:03:12 <maerwald> Guest_85nart: are you using bash with ~/.bashrc?
20:03:22 <iqubic> When I said 'supported', I meant: "Are the members of #haskell still going to give help to those who have installed GHC via ghcup"?
20:03:37 <maerwald> iqubic: yes
20:03:58 <dogonthehorizon> `String -> (Int -> Int) -> TestTree` does work, though it isn't very satisfaying :/ I've tried both forall x . Eq x => x -> x and forall x . Ord x => x -> x but GHCI still insists on asking for `x -> x` instead of `Int -> Int` https://gist.github.com/dogonthehorizon/6284facebda5c4e578d90b6058a09623 (I've updated the gist)
20:04:08 <Guest_85nart> not sure
20:04:35 <Guest_85nart> actually yes
20:04:57 <maerwald> Guest_85nart: then add 'source /Users/natealbers/.ghcup/env' to the end of your ~/.bashrc (without the quotes)
20:05:08 <lyxia> dogonthehorizon: you're putting the type annotation in the wrong place.
20:05:13 <dmwit> dogonthehorizon: I don't think `forall x. Ord x => x -> x` means what you think it means.
20:05:55 <dmwit> dogonthehorizon: Specifically: it means that the function you are passing must be able to work with all types that implement `Ord`. Not that the caller of `fooPreservingSuite` gets to pick some `Ord` type and pass in a function that works for that type.
20:06:15 <dmwit> dogonthehorizon: The latter would be `fooPreservingSuite :: forall x. Ord x => String -> (x -> x) -> TestTree`.
20:06:41 <dmwit> dogonthehorizon: Then you may call `fooPreservingSuite "id" (id :: Int -> Int)` no problem.
20:07:11 <Guest_85nart> permission denied?
20:07:41 <lyxia> ah, so dogonthehorizon does not actually want to pass a polymorphic function to the test. that makes more sense.
20:07:56 <maerwald> Guest_85nart: ? what command did you run
20:08:40 <Guest_85nart> what do you mean by adding that phrase to the end of ~/.bashrc?
20:09:12 <dmwit> Guest_85nart: Is it possible that you mistakenly ran ghcup as root (perhaps with sudo)?
20:09:14 <maerwald> ~/.bashrc is a file, you open that file and add that line to the end of it
20:09:34 <dmwit> Guest_85nart: Then it might be the case that .ghcup/env is owned by root and has permissions that only allow root to read it.
20:09:42 <dmwit> Guest_85nart: This could explain your permission denied error.
20:10:04 <dmwit> You could check this hypothesis with ls -ld .ghcup .ghcup/env
20:10:19 <maerwald> dmwit: ghcup installs into $HOME
20:10:24 <dmwit> maerwald: And?
20:10:30 <maerwald> /Users/natealbers doesn't appear to be the root account
20:10:41 <dmwit> maerwald: sudo helpfully sets $HOME to your user's $HOME, not root's
20:11:13 <maerwald> dmwit: I don't sudo was used, because the ghcup homepage doesn't mention it 
20:11:18 <dmwit> (Or can, if so configured. Not all configurations do this.)
20:11:56 <dmwit> That's a lot of trust you place in this person following instructions very precisely.
20:12:31 <buhman> I have been playing with an  ExceptT e1 (ReaderT e2 IO) a  stack. I created different e1 and e2 types for different parts of my application, but I've found it quite awkward to have a mess of  liftFoo . liftBar . liftTheOtherWay $ action  . At the same time, it seems like a ton of boilerplate to define each liftX composition separately. Is there a more magical/implicit way to describe how I want my types to
20:12:32 <buhman> compose? Or am I doing this entirely wrong?
20:12:40 <maerwald> seems he gave up or made it work :o
20:12:56 <dmwit> buhman: Yes, this is why the mtl was created.
20:13:21 <dmwit> err
20:13:21 <maerwald> I don't really know how to make the instructions clearer than they already are. Some people don't seem to be familiar with the concept of PATH...
20:13:22 <buhman> hmm, I am using mtl though
20:13:26 <dmwit> Maybe. Maybe I don't understand the question.
20:13:28 <buhman> what else do I need?
20:13:37 <dogonthehorizon> lyxia: Apologies for the confusion! dmwit: This explanation only dimly makes sense, but applying your suggestion and adding a few more constraints that SmallCheck wants seems to have me at a green test suite. So if I have this right, what I wanted to express was that we accept some function x -> x and we will test it for foo-preserving properties. In order to generate values that satisfy x -> x we need to
20:13:39 <dogonthehorizon> add a quantified constraint to the _entire_ function signature to express properties that we want (in this particular case Ord), rather than on specific values of x in the function under test.
20:14:06 <dmwit> uh?
20:14:24 <dmwit> Ord was never applied to specific values, neither in your original nor in the fixed version.
20:14:59 <dmwit> Ord lives at the type level, and (to a first approximation) values never appear at the type level.
20:15:27 <sm[m]> maerwald: of course not. PATH is pretty confusing to a non hacker
20:16:04 <maerwald> sm[m]: the installation process even suggests doing that for you (if it finds ~/.bashrc), but it requires you to enter YES into the terminal. I guess that's where a lot of people fail? :P
20:16:36 <dmwit> dogonthehorizon: The proper way to think of the distinction is as whether the implementer of `fooPreservingSuite` gets to choose the type `x`, or whether the caller of `fooPreservingSuite` gets to choose the type `x`.
20:16:57 <dogonthehorizon> aha, that makes sense to me
20:18:08 <dmwit> `foo :: forall x. (...)` says the caller of foo gets to choose `x`.
20:18:15 <buhman> dmwit: so, to start, I have this https://gist.github.com/buhman/438b4e6d6c89110ed12932d1d0d3deb5 for the outer ExceptT layer, then it gets uglier when I want to compose ReaderT environments as well. Can I do both of these things with less code?
20:18:22 <dmwit> `foo :: (forall x. ...) -> ...` says the implementer of foo gets to choose `x`.
20:18:53 <sm[m]> maerwald: it’s hard to make something that’s robust for non-techies
20:19:47 <dmwit> buhman: Aha, now I understand the question clearly.
20:19:52 <dmwit> mtl does not help with this.
20:20:00 <sm[m]> PATH seems to be the main hurdle for them installing haskell stuff
20:20:32 <dogonthehorizon> I see, thanks dmwit ! I'll have to do some more reading on quantified constraints, I haven't had reason to encounter it yet. Thanks also to lyxia and argent0 !
20:20:58 <dmwit> dogonthehorizon: Be careful. "Quantified constraints" is a technical term, and does not describe what you are using here.
20:21:14 <dmwit> dogonthehorizon: If you had to turn on the QuantifiedConstraints extension to get your code to compile, I suspect you have made a mistake.
20:21:52 <buhman> I was thinking it would be nice to only have one "lift" function that magically translates both types, maybe
20:22:05 <maerwald> sm[m]: my opinion is that tidal (pretty sure that was a tidal user), should use ghcup in its build system in a way that doesn't expose them to the compiler at all
20:22:33 <noumenon> hmm, I think it's time to uninstall my system-wide haskell packages, updates getting a bit ridiculous; anyone know the fastest way of doing so on arch?
20:22:55 <buhman> noumenon: pacman -Rc ghc ?
20:23:28 <sm[m]> maerwald: sounds good.. like stack
20:23:32 <noumenon> what does -Rc do?
20:23:34 <maerwald> sm[m]: exactly
20:23:49 <sm[m]> so maybe it should use stack
20:23:49 <noumenon> also, seems like that only removes ghc and ghc-static, not the myriad haskell-* packages
20:23:49 <buhman> remove the package and the things that depend on it
20:23:53 <dogonthehorizon> dmwit: ...hm, well you're right there. I've removed it and it still compiles. I tried removing ScopedTypeVariables as well since I'm no longer using it, but that seemed to remove the ability to use the `forall` syntax. I'm comfortable with that particular extension, but the error message I got back from GHC is that I needed to enable RankNTypes or similar. I imagine RankNTypes is more powerful, in this
20:23:55 <dogonthehorizon> example is there a reason to choose it over ScopedTypeVariables?
20:24:00 <maerwald> sm[m]: that's another option
20:24:13 <sm[m]> maerwald: could ghcup use stack ? Pardon my ignorance, but could that help ?
20:24:18 <buhman> noumenon: some pacman -Q | pacman -R then
20:24:26 * sm[m] hasn’t used ghcup
20:24:27 <buhman> with additional flags
20:24:32 <dmwit> dogonthehorizon: You may use ExplicitForAll to simply enable the forall syntax.
20:24:44 <dmwit> dogonthehorizon: Or you may omit the foralls, since you are using simple rank-1 types here.
20:25:23 <dmwit> dogonthehorizon: `fooPreservingSuite :: Ord x => String -> (x -> x) -> TestTree` will work just fine with no extensions.
20:25:42 <maerwald> sm[m]: The point of it is to install and manage multiple GHC versions transparently, not automagically. Stacks scope is totally different. There have been requests that ghcup should be able to install stack though, but I think that's out of scope too
20:26:10 <dmwit> dogonthehorizon: To answer the exact question you asked: neither ScopedTypeVariables nor RankNTypes is more powerful than the other.
20:26:35 <maerwald> if you want something automagic depending on e.g. your 'base' version, you can use https://github.com/vabal/vabal (which uses ghcup under the hood... and which proves that following unix principles is good and makes tools composable)
20:26:38 <dogonthehorizon> Yes that does seem to work fine. I'm not quite sure where I found the `forall` then, perhaps a suggestion from GHC? Appreciate the confirmation on the extensions question :)
20:26:58 <sm[m]> in any case, I guess we still need a “setup doctor” kind of thing that sorts out all this PATH nonsense
20:27:24 <noumenon> hmm, pacman -Qq?
20:27:39 <sm[m]> or - our tools could install in /usr/local/bin. How bad would that be, really :)
20:28:00 <maerwald> sm[m]: https://gitlab.haskell.org/haskell/ghcup/blob/master/bootstrap-haskell#L89-122
20:28:13 <noumenon> Qqs seems to work
20:28:21 <maerwald> sm[m]: very bad, because it requires non-user permissions :)
20:28:36 <sm[m]> Ah yes
20:28:52 <sm[m]> maerwald: that looks nice. Can they rerun your tool idempotently and converge on a working setup ?
20:28:56 <dmwit> buhman: I don't have any really great suggestions. One possibility would be to introduce a non-fd-constrained analog of MonadError.
20:29:10 <noumenon> I don't understand pacman commands at all apparently
20:29:22 <maerwald> You don't want confused users to run stuff as sudo/root, it's already dangerous enough to run random scripts from the internet, I think it's outright wrong to make them do anything more than creating a new directory and putting stuff into it
20:29:28 <maerwald> sm[m]: yes
20:29:45 <noumenon> pacman -Qqs haskell gives me all the haskell-* packages, as well as stack, but when I pipe it to pacman -R nothing happens
20:29:47 <sm[m]> one issue with what I see there, the messages are too obscure & scary for a non-techie (“risk”)
20:30:05 <dmwit> buhman: Then make instances like `instance MonadBuhman Github.ApiException (ExceptT Github.ApiException m)` and `instance MonadBuhman Github.ApiException (ExceptT MT.Exception.Exception m)`.
20:30:35 <maerwald> sm[m]: you think we should remove that part?
20:31:29 * VaNilLa[m] uploaded an image: 2019-09-09-203016_3840x2160_scrot.png < https://matrix.org/_matrix/media/v1/download/riot.danilafe.com/jbipFKlsIZqdWQfmtiaBUaRW >
20:31:48 <VaNilLa[m]> uh oh. excuse me. if you got a message from me, wrong channel
20:32:00 <dmwit> buhman: ...OOOOR you could pick your top-level monad once and for all and make a `class MHasError e where throwIt :: e -> M a`, with `instance MHasError Github.APIException`, `instance MHasError Artifactory.APIException`, etc.
20:32:05 <quiet_laika[m]> <laika___ "hi cocreature, i was told you mi"> cc cocreature changed clients
20:32:31 <sm[m]> maerwald: but maybe things like snap/appimage/flatpak are the way to do easy installs ?
20:32:50 <maerwald> sm[m]: uh, yet another concept of installing packages :>
20:33:20 <dmwit> buhman: (...and then instead of lifting, you make whatever's currently throwing into `ExceptT Github.ApiException` throw into `M` instead.)
20:33:20 <sm[m]> That part could be tuned for non-techies, for sure. That’s probably not your focus, I’m just interested in how to support them
20:33:42 <maerwald> I think curl | sh method is the quickest, even for non-techies
20:33:55 <sm[m]> Not to mention, how to make computers just do stuff for me, too, with less fiddling
20:34:08 <sm[m]> And with a shred of security :)
20:34:25 <sm[m]> Yes curl | sh is certainly the easiest
20:34:40 <sm[m]> Well, I mean apart from what mobile and windows and Mac users do
20:34:57 <maerwald> People should use their package manager whenever possible
20:35:17 <maerwald> But often time GHC is either improperly packaged, not packaged at all or outdated
20:38:41 <buhman> dmwit: hmm. so in the second case, how does the type variable M become a Github.ApiException?
20:39:52 <buhman> I think the first idea sounds cool too. How does lifting work there?
20:43:10 <dmwit> buhman: M is not a type variable, it is the top-level monad you chose.
20:43:25 <dmwit> buhman: e is the type variable that becomes Github.ApiException.
20:44:45 <dmwit> buhman: As for the first one, lifting does not happen: you rewrite your github actions to be polymorphic over all `MonadBuhman Github.ApiException` instances. Then as the caller, you can choose either the `ExceptT Github.ApiException` instance or the `ExceptT MT.Exception.Exception` instance at your preference.
20:47:12 <buhman> ooh. sorry for being dense, but what do I define in the instance?
20:49:06 <dmwit> throwError for the first; throwError . GithubException for the second
20:58:30 <dmwit> So I'm using ✓ to indicate a job which was requested and finished successfully. I'd like a one-character thing to put for a job which was requested, but skipped because a previous run already did it.
20:58:34 <dmwit> Suggestions?
20:58:59 <MarcelineVQ> some sort of dash, since x is for fail
20:59:49 <dmwit> - isn't bad
21:00:02 <dmwit> I was also considering ⏩ but... it just seems too cute.
21:00:15 <MarcelineVQ> –
21:00:17 <jle`> ⟲
21:00:31 <dmwit> (and also might be double-width? ick)
21:01:02 <dmwit> MarcelineVQ: Thanks! I think I'll run with that for now.
21:01:06 <iqubic> The fast forward symbol there is double-width.
21:01:42 <jle`> ►
21:02:19 <dmwit> My terminal can't even handle ⏭️, heh
21:02:51 <dmwit> jle`: I'm using ▶ for jobs that are currently executing.
21:02:58 <turab> @pl \x -> (x, x)
21:02:58 <lambdabot> join (,)
21:03:52 <turab> :t join
21:03:54 <lambdabot> Monad m => m (m a) -> m a
21:04:47 <turab> :t (,)
21:04:49 <lambdabot> a -> b -> (a, b)
21:05:13 <dmwit> join :: ((->) e ((->) e a)) -> ((->) e a), or in more conventional notation, join :: (e -> e -> a) -> (e -> a)
21:05:37 <cheater> hi
21:05:44 * dmwit waves congenially
21:05:55 <iqubic> :t join `asAppliedTo` (->)
21:05:57 <lambdabot> error: parse error on input ‘->’
21:06:01 <iqubic> Damn it to hell.
21:06:12 <cheater> what is the \( in the definition of blogSrc here? https://www.yesodweb.com/book/sql-joins
21:06:17 <cheater> it's part of Esqueleto syntax.
21:06:36 <dmwit> :t join `asAppliedTo` (,)
21:06:38 <lambdabot> (b -> b -> (b, b)) -> b -> (b, b)
21:06:54 <cheater> $ E.from $ \(blog `E.InnerJoin` author) -> do
21:07:06 <cheater> is this pattern matching?
21:07:11 <cheater> iside a lambda?
21:07:11 <dmwit> It's just lambda syntax?
21:07:19 <dmwit> Yes, lambdas may pattern match on their arguments.
21:07:30 <cheater> ok, so the whole parens is a single argument to a lambda?
21:07:34 <dmwit> > (\(Just x) -> x) (Just 3)
21:07:36 <lambdabot>  3
21:07:38 <dmwit> yes
21:07:40 <cheater> thanks.
21:09:09 <iqubic> I did not know you could use a Data Constructor as an infix function.
21:09:18 <iqubic> I guess it is just a function like all the rest.
21:12:58 <dmwit> The committee really did think of everything.
21:16:28 <iqubic> What makes (,) special?
21:19:04 <dmwit> The grammar.
21:19:25 <iqubic> Huh??
21:20:33 <dmwit> The grammar has special rules for (,). Otherwise, semantically, it is a completely bog-standard data type. You could define your own replacement yourself and it would have all the same behavior and enjoy all the same compiler optimizations.
21:21:16 <argent0> hi, how to lazily consume a (Monad m => m [a]) ?
21:21:48 <dmwit> If you mean "how can I only make the monad's effects happen as they are needed to discover the next list element", the answer is that can't be done.
21:22:04 <jle`> argent0: there is no general answer for all monads
21:22:06 <dmwit> And indeed preventing that is the bulk of the motivation for having the monad abstraction in the first place.
21:22:10 <jle`> there is only a solution for monads in specific
21:22:29 <dmwit> On the other hand, you might like http://hackage.haskell.org/package/list-t-1.0.3.1/docs/ListT.html
21:22:56 <dmwit> which exactly captures the interleaving of effects and list element production.
21:23:19 <argent0> jle`: dmwit: Ok, thanks for the pointers
21:23:36 <jle`> in general there is actually not thaaat much you can do for all monads in general, since all monads are so different
21:23:51 <jle`> so in your case the best bet is to try to narrow the scope of your abstraction
21:23:58 <jle`> all the way to the exact m if possible
21:25:02 <dmwit> jle`: Okay, I'm interested to hear your plan. I've narrowed it down to m ~ Maybe. What now?
21:25:34 <dmwit> (Or... which m would you choose that you *can* make a plan for?)
21:25:59 <argent0> I can do `take 5 . lines <$> readContents` and that runs lazily as I input lines.
21:26:21 * argent0 scratch that
21:26:52 <buhman> I've never made a non-toy typeclass before, and I don't understand these exceptions https://gist.github.com/buhman/f7267d92d4efad22556167b83c64d2d0
21:27:28 <c_wraith> buhman: the possible fix suggested should solve it
21:27:37 <c_wraith> that's not always true, but it is in this case.
21:27:41 <dmwit> argent0: Sort of. But you're being tricked. e.g. `take 5 . lines <$> (readContents <* putStrLn "hi")` doesn't delay the `putStrLn "hi"` effects, even though they're not needed to know what's read from the contents.
21:27:50 <iqubic> The two instance declarations need constraints that the m must be a monad.
21:28:17 <dmwit> buhman: You definitely should not make `MonadError e m` a superclass.
21:28:22 <buhman> oh 
21:28:37 <dmwit> buhman: Since that one is fd-constrained, yours will be too by association.
21:29:03 <iqubic> c_wraith: Why is that? Isn't a constraint on the class definition enought? Why do you have to put the monad constraint on the instnaces too?
21:29:09 <dmwit> buhman: (That's your third error there. The other two are addressed by c_wraith and iqubic.)
21:29:37 <c_wraith> iqubic: You could put it on the class, I guess, but it's unnecessarily restrictive.
21:30:01 <buhman> ahh, so that's what that spooky  | m -> e  sytax is
21:30:10 <c_wraith> iqubic: putting the constraint on the instance allows slightly more general instances sometimes.
21:30:21 <iqubic> he did put it on the class, and GHC tells him he needs to put a constraint on the instance too.
21:30:35 <dmwit> buhman: Oh, yep. Search for "functional dependency" (or maybe "functional dependencies"?) in the GHC docs to read more about it.
21:30:36 <iqubic> "class (Monad m, MonadError e m) => MonadException e m where"
21:30:49 <c_wraith> iqubic: that's a different m than in the instance
21:31:02 <iqubic> He has the monad constraint there, but also needs it on the instance declaration.
21:31:15 <c_wraith> iqubic: ...  which is what the "possible fix" says.
21:31:22 <c_wraith> iqubic: also, that's for a different type
21:31:23 <iqubic> c_wraith: Is that m there the same as the m in MonadError?
21:31:52 <dmwit> c_wraith++ for predicting iqubic's question a full minute ahead
21:31:56 <c_wraith> iqubic: in the class definition, m matches with (ExceptT APIException m) in the instance.
21:32:21 <c_wraith> iqubic: or at least in the first instance
21:32:41 <EvanR> welcome to #haskell where we answer questions in acausal fashion
21:32:46 <dmwit> It's like witnessing time travel. "<A> That's a different m than in the instance. <B> Is that m there the same as the m in MonadError?"
21:33:16 <EvanR> outer wilds
21:33:46 <c_wraith> For (ExceptT APIException m) to have a Monad instance, m must have a Monad instance.  That's the missing constraint that ghc is asking for.
21:40:12 <jle`> argent0: sorry for replying a little late, but yeah it looks like you don't want a general Monad situation after all
21:40:18 <jle`> what is the type of readContents ? is it IO ?
21:40:35 <c_wraith> :t readContents
21:40:36 <lambdabot> error:
21:40:37 <lambdabot>     • Variable not in scope: readContents
21:40:37 <lambdabot>     • Perhaps you meant one of these:
21:40:46 <c_wraith> oh, I'm thinking of getContents
21:40:50 <jle`> in haskell there is this really strong temptation to ask questions about generic types when often you want just a specific type, and it can often obscure the nature of your problem
21:41:24 <jle`> so you get weird questions like "how do i get the first item in Monad m => m a?" when really all you wanted was to get the first item in [a]
21:42:06 <jle`> i'm not sure why but i feel like i've noticed this abstraction-escalation happening more in haskell than in other languages
21:42:57 <jle`> dmwit: 'Identity' :)
21:43:24 <jle`> maybe Writer
21:43:29 <jle`> Reader
21:43:43 <jle`> definitely not Maybe, no
21:43:59 <jle`> Maybe is probably a good example of a situation where it is definitely 100% impossible
21:44:18 <jle`> it might be a good example for illustration
21:44:51 <jle`> Writer would work only if you don't ever decide to inspect the log ... so maybe Writer is not a good example.
21:44:56 <EvanR> solve a concrete problem first and then see if some parts could be parameterized, abstracted
21:45:03 <buhman> https://gist.github.com/buhman/b436ea4061456d83dd864a5fb0876959 how do I declare createPullRequest properly?
21:45:58 <jle`> yeah, i'd use Maybe as a counter-example to anyone who says this can be done polymorphically for all MOnad m
21:46:22 <c_wraith> :t Proxy >>= \Proxy -> Proxy
21:46:24 <lambdabot> Proxy b
21:46:40 <jle`> because we can just imagine `sequenceA (repeat (Just ()) ++ [Nothing])`
21:47:00 <jle`> or `sequenceA [Just 1, Just 2, Just 3, Nothing]` even
21:48:04 <iqubic> buhman: The issue here is with Main. Not sure quite what's wrong, but I think Main is the issue.
22:02:19 <buhman> hmm, I think I need to constrain e somehow?
22:03:37 <buhman> https://gist.github.com/buhman/797fc0566d331d352d656dfac935d624
22:08:59 <dmwit> buhman: uh
22:09:14 <dmwit> buhman: What is the `m` you're constraining in `createPullRequest`'s type?
22:09:20 <dmwit> It's not mentioned to the right of `=>`.
22:09:43 <dmwit> buhman: Just `createPullRequest :: ExceptT e IO String` should be fine...?
22:11:13 <dmwit> buhman: Wait. You've posted two things. This commentary was about the first.
22:12:26 <dmwit> buhman: About the second: `createPullRequest :: MonadException ApiException (ExceptT e IO) => ExceptT e IO String`.
22:13:40 <dmwit> jle`: I'm interested to hear your plan for Reader.
22:14:23 <dmwit> jle`: An example of an action I think it will be hard to make the effects lazy for with reader:
22:15:19 <dmwit> sequence [\x -> seq (fst x) 'a', \x -> seq (snd x) 'b']
22:15:31 <dmwit> Hm. Actually, now that I say it, I wonder if that's hard.
22:15:50 <dmwit> > sequence [\x -> seq (fst x) 'a', \x -> seq (snd x) 'b'] ((), undefined)
22:15:53 <lambdabot>  "a*Exception: Prelude.undefined
22:15:57 <dmwit> Hey, neat!
22:17:01 <jle`> i hadn't considered evaluation of the argument to be an explicit effect of Reader 
22:17:18 <jle`> but i guess even if you consider it as so, it's still lazily streamable?
22:17:22 <dmwit> What *did* you consider to be the effect of reader?
22:17:36 <jle`> access to an environment
22:18:03 <dmwit> Uh huh. And how do you observe which effects have been done, for the purposes of this question about laziness?
22:18:30 <jle`> ,hm, Reader is not a situation where you can observe which effects have happened
22:18:37 <jle`> i believe
22:18:48 <jle`> but i guess this question is about laziness, so we are getting a bit fuzzy huh
22:18:50 <iqubic> I have no idea how Reader or Writer work.
22:18:57 <dmwit> I think if you ponder a bit longer, you will arrive where I did: you can observe which effects have happened by looking at what exception that you stuffed into the environment gets thrown.
22:19:29 <jle`> but this goes against what i like to consider is an advantage of monads -- first-class effects
22:19:45 <jle`> if evaluation is an effect then the effect becomes magical builtins to the language
22:19:57 <dmwit> Okay, brick question: I want to have two layers, so I have my `appDraw` callback return a list with two widgets in it.
22:20:19 <dmwit> I want the top one to be centered, but not to obscure the entire bottom one. What do?
22:20:59 <dmwit> If I just return two widgets, the bottom one is not obscured but the top one is at the top-left of the screen. If I call `center` on the top one, the bottom one is obscured.
22:21:52 <iqubic> I know nothing about brick. Sorry.
22:22:37 <EvanR> evaluation as an effect could save you from non terminating computations
22:22:51 <EvanR> partiality monad...
22:24:18 <thunderseethe> Hello, does anyone know how to include a State monad during in an anamorphism. I've been trying and failing to wrap my head around it using gana
22:25:03 <jle`> i don't think it's possible, given the return type of ana
22:26:10 <thunderseethe> Tight then is there a way I can maintain some state during my anamorphism and update it as each level unfolds
22:26:41 <jle`> yes, you can write a "monadic anamorphism" of sorts
22:27:00 <jle`> but the difference between an and cata is that you can write a "monadic catamorphism" in terms of cata
22:27:04 <jle`> but you can't for ana
22:27:47 <jle`> the data-fix package provides one for specific fixed point Fix
22:27:51 <jle`> ttps://hackage.haskell.org/package/data-fix-0.2.0/docs/Data-Fix.html#v:anaM
22:30:59 <thunderseethe> So it can be done with a generalized anamorphism and some distributive law for State?
22:31:39 <thunderseethe> can't* 
22:32:34 <jle`> no, it cannot; look at the return type of gana
22:33:07 <jle`> it has to return a value of the fixed-point type
22:33:18 <jle`> so it cannot return, say, State s MyFixedPointType
22:33:49 <dmwit> (For posterity: I found centerLayer, which does what I want to brick layers.)
22:34:40 <thunderseethe> Yea :/  I'll have to come to terms with that, then I guess in the general case what is the idiomatic way to accomplish such an unfold with "state"? It seems like a monadic anamorphism might be barking up the wrong tree
22:35:51 <jle`> i mean, what you do with it is up to you as long as it works :) the main end-goal is to abstract away explicit recursion
22:36:14 <jle`> so if a monadic anamorphism does the job, i don't think it matters too much if it's not mathematically nice
22:36:58 <c_wraith> Have you considered just using sequence + ana?
22:37:24 <c_wraith> Build your structure with the actions everywhere, then sequence to combine them all
22:37:52 <jle`> ^ that only works if your final type is a Traversable instance, or otherwise parameterized on what it "contains"
22:38:02 <thunderseethe> So I would unfold into like a MyFixPoint (s -> (a, s)) and then sequence over that?
22:38:06 <jle`> but, this may be the case here. it's the problem of abstraction :)
22:38:22 <jle`> the problem of trying to ask a question about something more abstract than what you are actually trying to do, i mean
22:38:48 <c_wraith> I mean, most Corecursive types are Traversable.
22:39:05 <thunderseethe> Ah, concretely I'm trying to write a debruijn substitution function
22:39:36 <jle`> consider the example everyone uses for recursion-schemes, data Exp = Lit Int | Add Exp Exp | Mul Exp Exp
22:40:25 <jle`> hm. actually maybe there's a way to do it.  if you take your pre-fix-point functor, maybe compose it with State s
22:40:53 <jle`> so if MyType = Fix MyFunctor, do ana into Fix (State X :.: MyFunctor)
22:40:57 <jle`> i wonder if this works ...
22:44:16 <jle`> oh hey it just might work, heh
22:44:23 <jle`> i'm not sure why i decided long ago that it wouldn't
22:47:39 <thunderseethe> I don't know if you can do it as an ana, but you can almost certainly do it as a cata
22:51:28 <jle`> ok, tried it out on a concrete example and yeah, if you can ana into Fix (State s :.: MyTypeF), then you can later cata it back down into State s MyType
22:51:44 <jle`> so, it looks like you can do it as a hylomorphism?
22:56:01 <thunderseethe> I ended foregoing the State monad entirely to build a (s -> a) from a catamorphism and then feed it my initial state to produce my resulting fixpoint
22:56:25 <thunderseethe> Thanks for the help jle` and c_wraith
22:56:43 <jle`> np :)
22:59:07 <iqubic> How is ana supposed to work even?
22:59:50 <thunderseethe> Can you clarify your confusion for me?
23:00:14 <thunderseethe> A canonical example is you would use an ana to unfold an `Int` into a Peano numeral
23:00:19 <dminuoso> ana f = Fix . fmap (ana f) . f
23:02:02 <dminuoso> iqubic: It's basically just a generalization of unfold
23:08:25 <ski> @type unfoldr
23:08:26 <jle`> (note that that implementation is specifically for Fix)
23:08:26 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
23:08:30 * hackage opaleye 0.6.7004.1 - An SQL-generating DSL targeting PostgreSQL  https://hackage.haskell.org/package/opaleye-0.6.7004.1 (tomjaguarpaw)
23:15:05 <dminuoso> iqubic: I think the cata example is easier to get at first glance
23:15:18 <dminuoso> iqubic: https://wiki.haskell.org/Catamorphisms lists a few. 
23:24:31 * hackage universe-instances-extended 1.1.1, universe 1.1.1 (phadej): https://qbin.io/three-monday-xg1t
23:30:23 <mniip> traversables are roughly like polynomial functors right?
23:30:42 <mniip> except sometimes we allow infinite lists which result in infinite power series
23:31:29 <ski> (even `1 / (1 - a)' isn't polynomial)
23:31:38 <mniip> analytic functors?
23:31:59 * ski isn't sure whether that's thing
23:32:41 <mniip> F A naturally isomorphic to Coprod_n c_n * A^n
23:32:55 <mniip> where {c_n} is a sequence of naturals, and * is copower
23:33:36 <ski> `F A' being ?
23:33:42 <mniip> F is the functor
23:33:57 <mniip> though, are naturals enough
23:34:50 <ski> any traversable functor ?
23:34:56 <c_wraith> for most monads, sequence needs the data structure to be finite
23:34:57 <mniip> Free Identity is Traversable but has c_1 = ifninity
23:35:09 <mniip> for most but not for all
23:35:13 <mniip> much like [] is not the free monoid
23:35:48 <dminuoso> c_wraith: Does it?
23:35:50 <dminuoso> c_wraith: I think this "finiteness" is only to make it a useful instance, they'd still be lawful.
23:36:09 <mniip> also sequence only needs an Applicative
23:36:22 <c_wraith> that only makes it broader..
23:36:41 <mniip> you could use Const with a monoid that supports infinite reassociations
23:37:12 <c_wraith> Identity, though that just turns into fmap
23:37:20 <c_wraith> but it's lazy!
23:37:28 <mniip> anywya, the reasons I'm thinking about this,
23:37:38 <mniip> is there an "initial" encoding of zippers over traversals
23:37:51 <mniip> over traversables*
23:38:51 <mniip> I mean one that avoids a data family/associated type/... that manually maps to each functor its zipper
23:39:13 <dminuoso> mniip: Why is [] not the the free monoid by the way? I didn't fully understand that.
23:40:20 <mniip> dminuoso, if I make up a type of reverse lists  data Tisl a = Lin | Snoc (Tisl a) a
23:41:01 <mniip> then a (morphism in Set) function  f :: X -> Tisl X; f x = Snoc Lin x
23:41:20 <mniip> does not extend to a (morphism in Mon) monoid homomorphism  [X] -> Tisl X
23:41:26 <koz_> dminuoso: http://comonad.com/reader/2015/free-monoids-in-haskell/ <-- may be of interest
23:41:32 <mniip> it does if we only concern ourselves with finite terms
23:41:35 <mniip> but not otherwise
23:41:37 <dminuoso> mniip: Ahh I see.
23:42:23 <c_wraith> mniip: have you looked at the zippers package?  It may be of some inspiration
23:45:04 <mniip> hmm
23:45:53 <mniip> really just wish comonad-extras were in stack...
23:48:58 <c_wraith> having just scanned through zippers again - I have *no clue* how it works :)
