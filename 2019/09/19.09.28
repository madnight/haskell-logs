00:17:43 <piyush-k`> I am being rather stupid here but can anyone tell me if there is a easy to check whether a particular ticket  which is marked closed (https://gitlab.haskell.org/ghc/ghc/issues/12994 in my case) has been merged into a given ghc release ?
00:37:10 <int-e> piyush-k`: hmm, you can click on the commit in question, https://gitlab.haskell.org/ghc/ghc/commit/5f9c6d2a91ac710e7b75cfe50a7a8e84cc9ae796 and then on the "..." under "parent" to see a list of branches that contain the commit... ghc-8.2.1 is the first such release branch. Of course this doesn't tell us whether the commit has been backported to earlier releases... but it may be a reasonable...
00:37:16 <int-e> ...starting point
00:38:25 <int-e> piyush-k`: err, sorry. ghc-8.2 is the release branch. ghc-8.2.1-release is a tag.
00:38:53 <piyush-k`> int-e:  great, thanks
00:39:55 <piyush-k`> I was trying the include-signatures field mentioned in the message with cabal-3.0 and it was saying something like unknown field  
00:40:39 <piyush-k`> I mean cabal-install-3.0
01:10:46 <asheshambasta> I've  been going through this module:
01:10:46 <asheshambasta> https://github.com/bitnomial/opaleye-trans/blob/master/src/Opaleye/Trans.hs
01:10:46 <asheshambasta> and it seems to make an effort to avoid IO  within a
01:10:46 <asheshambasta> Transaction. Why? 
01:11:02 <asheshambasta> (sorry about the formatting)
01:11:48 <asheshambasta> In my use case, it seems overly limiting to avoid IO within a transaction. For example, how would one generate an arbitrary number of random IDs etc. for inserted rows? 
01:14:26 <c_wraith> let the database do it?
01:15:42 <asheshambasta> that is one option, but we have a bunch of service instances writing to the database concurrently, and we'd like to be able to generate custom ids on our side. 
01:15:48 <asheshambasta> eg. Snowflake ids. 
01:16:39 <c_wraith> you can always use the traditional approach of passing around an infinite list of generated ids
01:17:53 <asheshambasta> correct, but this quite cumbersome no? Also, IDs are just one of the things we need to generate during the transaction. Sometimes we also prefer generating the timestamps on the Haskell side. 
01:19:01 <asheshambasta> mainly, I'd like to understand the motivation/risks behind being able to do 'safe' IO whilst a DB transaction is ongoing 
01:19:35 <asheshambasta> I can think of timeouts: you may end up in an arbitrarily long IO operation while the transaction is open, or you might raise an unhandled exception 
01:19:37 <c_wraith> There's no technical prohibition.  The underlying library it delegates to allows it.
01:20:02 <c_wraith> And it's not like Opaleye automatically retries transactions that fail
01:20:12 <asheshambasta> yeah 
01:20:44 <c_wraith> still, fast transactions that consist only of DB updates are much more likely to commit successfully.
01:21:44 <c_wraith> I think that's the motivation - you get much better behavior out of a database if you treat transactions as pure functions of the input and the database state.
01:22:10 <asheshambasta> correct, however, I find that this is overly restricting. For example, generating random Snowflake ids is a relatively safe IO operation 
01:22:41 <asheshambasta> but at the same time, I agree that one shouldn't start making API calls etc. (also in IO) during an open transaction. 
01:25:32 <c_wraith> Note that the current design doesn't prevent using timeout, either, though it does prevent using it with save points in the transaction.
01:25:48 <c_wraith> You just have to use timeout at the outer level
01:29:09 <asheshambasta> hm, yeah. 
02:43:56 <aveltras> using lucid, any idea why the lines 45-46 would not render the title correctly ? i have an empty h1
02:44:04 <aveltras> https://www.irccloud.com/pastebin/jfYbfgty/
02:52:01 <Slaus> While going through tutorial, trying to define a function which adds two 2d vectors like this:
02:52:04 <Slaus> add_v x y = ( fst x + fst y, snd x + snd y )
02:52:13 <Slaus> but get an error: Variable not in scope
02:52:22 <Slaus> when trying to invoke it like this:
02:52:28 <Slaus> add_v ( 1, 2 ) ( 3, 4 )
02:53:46 <Slaus> precisely:
02:53:47 <Slaus> !!
02:53:49 <Slaus>     Variable not in scope:      add_v :: (Integer, Integer) -> (Integer, Integer) -> t
02:54:20 <pavonia> aveltras: How does the result look like?
02:55:08 <aveltras> https://www.irccloud.com/pastebin/ClPUnJ92/
02:55:13 <pavonia> Slaus: Where/how did you define that function?
02:55:18 <Slaus> result? The error is all I get - no result ... :(
02:55:43 <Slaus> I defined in in a file which I load into GHCI with :l
02:56:23 <pavonia> Do you export that function?
02:56:43 <Slaus> oh, I need to export it? How I do it?
02:57:51 <pavonia> aveltras: Does it work without the "pure"?
02:57:59 <aveltras> pavonia: no
02:58:26 <aveltras> i got the following error without it, wait
02:58:47 <pavonia> That's weird because your other <h1> seems to work
02:58:59 <aveltras> https://www.irccloud.com/pastebin/ampzXWz5/
02:59:06 <merijn> pavonia: load shouldn't care about exports
02:59:14 <aveltras> the other one is done directly without a variable
02:59:22 <merijn> Slaus: Can you pastebin the exact code and error?
02:59:33 <aveltras> the problem is not with that tag, because it doesn't work with p_ or something else either
03:00:30 <Slaus> Actually, I restarted GHCI and loaded my file again and it worked ^^. Sorry for bothering and thanks
03:01:25 <Slaus> couldn't figure out that "variable not in scope" meant that function is actually a variable ... still getting used to FP
03:02:20 <pavonia> aveltras: I guess you need to explicitly do the conversion that other uses of literal strings do through the overloaded strings conversion. Not sure what function lucid provides for this
03:03:04 <pavonia> aveltras: "fromString title" perhaps
03:04:05 <merijn> Slaus: Yeah, generally there's not much difference between "add_v x y = ..." and "add_v = \x -> \y -> ..." names are just names, regardless of what they refer too :)
03:04:07 <aveltras> pavonia: ok looking for it, i'll report if i find sth, thx
03:05:16 <aveltras> pavonia: ok, didn't take too long :p, there's a function toHtml in lucid to get : a -> Html ()
03:05:22 <aveltras> works now
03:05:31 <aveltras> no more "pure wrapping"
03:05:57 <pavonia> Okay, make sure this does escaping correctly
03:07:01 <aveltras> pavonia: you mean like xss escaping ?
03:07:28 <aveltras> if so then yes it does
03:07:32 <pavonia> '&' -> "&amp;" and such
03:08:20 <aveltras> just tried with a script tag and it's escaped so all is well
03:11:57 <nil> bit of a vague question: what's an example of a term in system F for which a "naive" type inference algorithm would not terminate?
03:13:11 <nil> i'm trying to grasp the motivation for Hindley-Milner and let-polymorphism, but the paper about the undecidability of type inference in system F is a bit too technical for me ("Typability and type checking in the second-order lambda-calculus are equivalent and undecidable")
03:15:34 <nil> (well, let-polymorphism as opposed to lambda-polymorphism i guess)
03:41:18 * haskelllisp[m] uploaded an image: image.png (83KB) < https://matrix.org/_matrix/media/v1/download/matrix.org/dlrvGQkwrJKmZTsNnRxQCxNp >
03:41:59 <haskelllisp[m]> Evaluation of a lambda term ((λx.e)a) proceeds by substitution of all free occurrences of the variable x in e with the argument  a
03:42:08 <haskelllisp[m]> How can I understand this sentence?
03:44:32 <merijn> haskelllisp[m]: Well, can you explain what part you don't understand?
03:48:53 <haskelllisp[m]> I don't understand `Substitution`, especially the formula..(λx.e)a→[x/a]e... Is there a simple example?
03:49:34 <merijn> "[x/a]e" is a (confusing) way to say "all 'x' in 'e' are replaced with 'a'"
03:49:40 <ski>   (λx. x) y  =  y
03:49:48 <higherorder> Hello! Quick q: why is the return type of `toJSVal :: a -> IO JSVal` in `IO`? (GHCJS)
03:49:50 <ski>   (λx. f x x) y  =  f y y
03:49:54 <higherorder> c.f. http://hackage.haskell.org/package/ghcjs-base-stub-0.2.0.0/docs/GHCJS-Marshal.html
03:50:07 <ski>   (λx. f x x) (g y)  =  f (g y) (g y)
03:50:28 <ski>   (λx. λz. f x z) (g y)  =  λz. f (g y) z
03:50:57 <ski>   (λx. λz. f (λx. g x) z) (g y)  =  λz. f (λx. g x) z
03:51:36 <ski> haskelllisp[m] : does those ^ examples of subtitution make sense, to you ?
03:53:10 <haskelllisp[m]> "all 'x' in 'e' are replaced with 'a'"
03:53:11 <haskelllisp[m]> merijn Thank you for this answer, very useful to me.
03:54:05 <ski> "all free occurances of 'x' in 'x' are replaced with 'a'"
03:54:29 <ski> (my last example above was about the "free occurance" thing)
03:54:37 <haskelllisp[m]> ski: Thank you, I will read the example you gave me now, I need to digest it.
03:55:48 <haskelllisp[m]> ok
03:56:37 <ski>   (λx. λz. f (λy. f x y) x) (g y)  =  (λx. λz. f (λt. f x t) x) (g y)  =  λz. f (λt. f (g y) t) (g y)
03:57:17 <ski> that's an even tricker example, which requires "alpha-conversion" (renaming of bound variable), before performing the (capture-avoiding) substitution
03:57:53 <ski> (the answer `λz. f (λy. f (g y) y) (g y)' would be wrong, since the `y' in `λy. f ..y..' there is not the same `y' as the one in `g y')
04:03:30 <Slaus> I have program design question, maybe you can suggest something. I have JavaScript game implemented in FRP style which I want to rewrite to Haskell. Game is considered as a huge interconnection of streams of messages (network,input,updates...) and is pretty much incomprehensible for a single developer. Different levels are implemented by
04:03:31 <Slaus> introducing tiny modifications to streams interconnections (level developer can cut any connections and push events into any streams at any moment). For example, Pack-Man dies when collides with enemy, but at level 151 he's immune when ate >= 100 things which makes the whole level 151 implementation being just this:{    //make collisions do nothing
04:03:31 <Slaus> in this level:    stream( "collide" ).cut();    //take collision:    stream( "collide" )        //with current amount of things eaten:        .with( stream( "things_eaten" ), ( _, things_eaten ) => things_eaten )        //take collisions only when eated < 100 things:        .filter( things_eaten => things_eaten < 100 )        //... causes death:
04:03:32 <Slaus> .to( stream( "death" ) )}How can I implement such "interconnections altering" design pattern in Haskell? Maybe there is something better and I don't even need it?
04:04:00 <Slaus> oops, my formattings got killed D: 
04:05:53 <Slaus> I guess it's too broad for a question though ... X) 
04:08:11 <Slaus> if you don't mind, I'll restate the code sample part being formatted line-by-line:
04:08:16 <Slaus>     //make collisions do nothing in this level:
04:08:19 <Slaus>     stream( "collide" ).cut();
04:08:23 <Slaus>     //take collision:
04:08:26 <Slaus>     stream( "collide" )
04:08:29 <Slaus>         //with current amount of things eaten:
04:08:34 <Slaus>         .with( stream( "things_eaten" ), ( _, things_eaten ) => things_eaten )
04:08:37 <Slaus>         //take collisions only when eate < 100 things:
04:08:40 <Slaus>         .filter( things_eaten => things_eaten < 100 )
04:08:43 <Slaus>         //... causes death:
04:08:46 <Slaus>         .to( stream( "death" ) )
04:08:55 <Slaus> How can I implement such "interconnections altering" design pattern in Haskell? Maybe there is something better and I don't even need it?
04:11:35 <Slaus> I guess the answer is lurking somewhere in a type system, but I can't figure out yet. The Game must be something as functions Category where events are objects and functions between them are arrows.
04:12:13 <Slaus> And so level developer should utilize type system with implementing Functors on that Game Category I guess? Hm..
04:12:16 <haskelllisp[m]> ski: I have already understood the example you just gave.  thanks again
04:14:23 <__monty__> Slaus: Please use a pastebin (gist.github.com, bpaste.net, ix.io...) for code next time, it's really not clear nor useful inline.
04:14:51 <dansho> are there any fixed precision numeric libraries using Int64? Data.Fixed and the ones i looked at on hackage use Integer internally
04:18:39 <ski> haskelllisp[m] : okay
04:19:46 <Slaus> __monty__ : I will, thank you. I didn't know. (not sure if I do nicknames reference correctly though ^^ )
04:19:57 <Slaus> seems I did
04:36:29 <merijn> dansho: Why do you want fixed precision with Int64?
04:55:00 * hackage shellmet 0.0.3.0 - Out of the shell solution for scripting in Haskell  https://hackage.haskell.org/package/shellmet-0.0.3.0 (shersh)
04:56:37 <dansho> merijn: i want fixed size
04:56:52 <dansho> i'll probably just use Int64 directly and choose the precision later
04:57:02 <merijn> dansho: Why is fixed size important?
05:07:13 <dansho> they are going to be written out to ByteStrings
05:07:27 <merijn> I don't see how that's related?
05:08:05 <dansho> each Int64 is 8 bytes
05:08:09 <dansho> each Integers is ???
05:08:24 <merijn> So? How does that relate to serialisation as ByteString?
05:08:45 <dansho> it needs to be deserialized
05:25:40 <maerwald> dansho: https://hackage.haskell.org/package/cereal-0.5.8.1/docs/src/Data.Serialize.html#line-246
05:30:02 <dansho> well bottom line is Integers are not Storable so i couldn't use https://hackage.haskell.org/package/bytestring-to-vector-0.3.0.1/docs/Data-Vector-Storable-ByteString.html
06:26:34 <higherorder> Hello! Quick q: why is the return type of `toJSVal :: a -> IO JSVal` in `IO`? (GHCJS)
06:26:34 <higherorder> c.f. http://hackage.haskell.org/package/ghcjs-base-stub-0.2.0.0/docs/GHCJS-Marshal.html
06:29:16 <__monty__> higherorder: I presume it creates an JS object?
06:40:00 * hackage reanimate 0.1.7.0 - Animation library based on SVGs.  https://hackage.haskell.org/package/reanimate-0.1.7.0 (DavidHimmelstrup)
06:49:31 <higherorder> __monty__: yep, but why is that an IO operation?
06:49:44 <higherorder> since ghcjs compiles to jS
06:49:56 <__monty__> Because it changes the state the program runs in?
06:50:24 <higherorder> __monty__: hmm but it's not just about objects; a JSVal can simply be a string
06:50:40 <__monty__> It *can* be an object is the problem though.
06:50:40 <higherorder> why is converting a "haskell string" to a "js string" an IO operation?
06:51:04 <higherorder> well even if it's an object; does it change any state? the object is not assigned to anything; it's just allocated
06:51:21 <hpc> constructors can be effectful
06:55:45 <higherorder> hpc: how so?
07:00:58 <hpc> it's a function
07:01:08 <hpc> when you use new, it gets called
07:01:17 <hpc> and you can make that function do stuff
07:09:00 * hackage th-orphans 0.13.9 - Orphan instances for TH datatypes  https://hackage.haskell.org/package/th-orphans-0.13.9 (ryanglscott)
07:14:30 * hackage llvm-hs 9.0.1 - General purpose LLVM bindings  https://hackage.haskell.org/package/llvm-hs-9.0.1 (cocreature)
07:23:36 <Slaus> does "!!" have a special meaning?
07:25:35 <Slaus> from an example:
07:25:51 <Slaus> ghci> let listOfFuns = map (*) [0..]
07:25:57 <Slaus> ghci> (listOfFuns !! 4) 5
07:26:11 <Slaus> where the result is 20
07:27:05 <Clint> Slaus: are you asking what that operator does in that example?
07:27:45 <c_wraith> Prelude does export an operator of that name
07:27:49 <c_wraith> :t (!!)
07:27:50 <lambdabot> [a] -> Int -> a
07:28:32 <c_wraith> as to whether it *means* anything....  usually it means that you're using the wrong algorithm or the wrong data structure.
07:29:28 * Clint chuckles.
07:30:24 <merijn> Slaus: "l !! n" just returns the n'th element of the list l
07:30:33 <c_wraith> 0-indexed
07:30:53 <isBEKaml> map (*) [0..]? 0?
07:31:06 <c_wraith> which is important, because I always manage to think (!! 1) should return the first element of a list
07:32:23 <higherorder> hackage: ah; ty!
07:33:15 <isBEKaml> Ah yeah, (*) is a binary operator. 
07:33:34 <Slaus> thank you
07:35:35 <ski> c_wraith : heathen
07:35:47 <c_wraith> For what it's worth, I wasn't really kidding with "wrong algorithm or wrong data structure".  If you see (!!) outside of toy code, it probably means that code needs a rethink.
07:37:34 <c_wraith> The [] data structure is a linked list.   Using it to simulate random access creates performance problems, and that's most of how (!!) gets used.
07:39:57 <c_wraith> ski: I've been called worse in here.  I got called a monster a couple days ago for suggesting (-3 +) as the second doing the opposite of (+ 3)
07:40:07 <c_wraith> *section
08:09:50 <ski> c_wraith : yea :)
08:10:06 <ski> (it was a joke, in case it wasn't that clear)
08:10:33 <c_wraith> it was, all is good. :(
08:10:35 <c_wraith> err. :)
08:10:50 <c_wraith> worst typo possible there
08:13:06 <ski> it's irritating when you write "did" instead of "didn't", or "now" instead of "not"
08:13:10 <ski> (or vice versa)
08:25:11 <jgt> you think that's bad — I once wrote to guy "hey your dad was supposed to call me back but then he didn't". At least, that's what I thought I wrote. He wrote back "Ok. That was a bit weird." It wasn't until a few hours later that I had written "Your dad was supposed to call me back, but then he died."
08:25:31 <jgt> that I had realised* that I had written
08:30:31 <maerwald> strings are weakly typed...
08:32:30 * hackage microlens-process 0.2.0.1 - Micro-optics for the process library  https://hackage.haskell.org/package/microlens-process-0.2.0.1 (topos)
08:38:46 <ski> jgt :/
08:38:58 <orzo> does ghc recognize the idiom of looping over [0..n] and turn it into something closer to for(i=0;i<=n;i++) ?
08:39:49 <hololeap> :t map
08:39:50 <lambdabot> (a -> b) -> [a] -> [b]
08:40:32 <hololeap> :t map (\i -> "This element is: " ++ show i)
08:40:34 <lambdabot> Show a => [a] -> [[Char]]
08:40:42 <hololeap> orzo: is that what you mean?
08:40:43 <lyxia> orzo: only if you use functions from Foldable so the rewrite rules fire
08:41:04 <c_wraith> orzo: list comprehensions like that desuger to enumFromTo, which will participate in list fusion
08:41:09 <orzo> typically i'd be mapM_ or mapM
08:41:31 <c_wraith> You just need to make sure the things you do all participate in fusion
08:44:05 <orzo> i recently benchmarked something and decided to revert my fusion-friendly code, but i didn't realize that the isolated benchmark changed everything because it did not have MonolocalBinds
08:44:10 <orzo> and had to revert my revert
08:46:33 <orzo> it'd be nice if there was a simpler for(i=0;i<=n;i++) idiom that didn't impose the burden of verifying fusion
08:47:13 <orzo> the compiler/langauge is getting in the way a bit in this case
08:48:47 <EvanR> .oO( for(i=0; i<n; i++){  won't map over "11" (n+1) things
08:49:03 <c_wraith> There is an idiom for that.  It's called writing direct recursion by hand, being careful of strictness
08:49:11 <EvanR> forM_ [0..n-1] (\i -> do seems pretty idiomatic to me
08:49:18 <c_wraith> it's more work than just letting fusion work
08:51:53 <orzo> it's not more work in principle.  It's more work in haskell.
08:52:46 <orzo> and "letting fusion work" is a little different than "verifying fusion worked"
08:52:49 <EvanR> is verifying optimizations done by a C compiler easier?
08:53:33 <orzo> not a relevent question
08:54:39 <EvanR> a priori a for loop and forM_ with a list don't seem obviously "optimizable". Like I think my hopes and dreams for optimization without worrying about it would seem about the same
08:55:23 <c_wraith> I don't see how forM_ + enumFromTo would ever fail to fuse...
08:55:42 <mozzarella> wtf is fusion?
08:55:48 <c_wraith> It's a good producer + a good consumer.
08:56:26 <EvanR> non a priori, i think a lot of work goes into compiling for loops specifically, and lazy lists in haskell often fuse. So non a priori my hopes and dreams go up a little
08:56:27 <c_wraith> mozzarella: an optimization technique that removes creating the data structure in memory
08:56:52 <EvanR> in real life i probably have to do some work to verify optimizations
08:57:17 <orzo> fusion is an optimization that removes intermediate allocations when processing lists in waves.  It's a little like turning multiple loops over a list into a single loop over the list performing all the operations in one pass
08:58:25 <orzo> list functions in the prelude will typically fuse, like (map f (map g) xss) will likely be the same as map (f . g) xss
08:59:00 <c_wraith> it is worth note that fusion only happens when the compiler will use rewrite rules, which means -O1 or -O2
09:05:58 <ski> orzo : yea, i'd like a way to have type-checking fail, in case you'd not get the expected fusion
09:06:44 <ski> (that would not be optimization, meaning something which might or might not happen, depending on the phase of the moon
09:10:02 <orzo> probably that will involve making the rewrite rules system something fancier
09:10:54 <orzo> ski: are you aware of the inspection-testing plugin?
09:11:11 <orzo> that gets us some of the way there
09:29:52 <lyxia> a type system for fusion sounds exciting
09:42:30 * hackage poseidon 0.1.0.0 - Simple extensible library to run SQL file against PostgreSQL database.  https://hackage.haskell.org/package/poseidon-0.1.0.0 (FlogFR)
09:50:24 <ski> lyxia : i think it could be done
09:53:00 * hackage schemas 0.1.1.0 - schema guided serialization  https://hackage.haskell.org/package/schemas-0.1.1.0 (PepeIborra)
10:06:00 * hackage vector-builder 0.3.8 - Vector builder  https://hackage.haskell.org/package/vector-builder-0.3.8 (NikitaVolkov)
10:26:00 * hackage HaTeX 3.22.0.0 - The Haskell LaTeX library.  https://hackage.haskell.org/package/HaTeX-3.22.0.0 (DanielDiaz)
10:29:16 <nshepperd> how would MonoLocalBinds affect whether something fuses or not?
11:27:38 <ggVGc> trying to get into DataKinds and type families, with a specific use case in mind. But before I go deeper, is it possible to encode a range of values in a type? E.g the interval [a,b], and write functions that only work for values with a type level number in this interval?
11:28:02 <ggVGc> does Haskell's simulation of dependent types allow this?
11:28:08 <ggVGc> and is there some library that already does it?
11:29:29 <ggVGc> also, followup, is it possible to encode a list of values in a type, and check that a type level number is in this list, rather than an interval? 
11:34:12 <EvanR> ggVGc: you can define "between a b" as a pair of >=a and <=b 
11:35:17 <EvanR> you can also define "is an element of xs"
11:35:25 <EvanR> at the type level. Prepare for many proofs
11:36:34 <ggVGc> EvanR: currently I have a DSL that checks signal ranges (e.g lists of valid values for my components that I connect), and I do all these checks at runtime (of the haskell program), which generates C++ (my real program output)
11:36:43 <ggVGc> I am wonderingf how much of this I could move into haskell
11:36:47 <ggVGc> without too much pain
11:36:52 <ggVGc> but my impression is it will be a lot of pain
11:36:57 <EvanR> verifying interface hookups can probably be done with GADTs
11:37:46 <ggVGc> yeah, but that's not the main thing I want. The main thing is "This component has an input accepting values [1,2,5,7,9] and I want to connect this one which outputs [3,4,5] to it. Is it valid?"
11:38:14 <EvanR> so youre doing a runtime check, but you don't trust it?
11:38:25 <ggVGc> it all works fine
11:38:32 <ggVGc> I just want to know if I could move it to the type level
11:38:37 <ggVGc> because I'd get better error reporting
11:38:39 <ggVGc> and to learn
11:38:43 <ggVGc> but it seems like too much effort
11:38:48 <EvanR> so you want to catch it at compile time
11:39:12 <ggVGc> technically it's at compile time now since my compiler is "compile haskell program + run haskell program"
11:39:13 <ggVGc> but yeah
11:39:17 <ggVGc> my error reporting sucks
11:39:26 <ggVGc> so if I could get GHC to give me the errors that'd be nicer
11:40:02 <EvanR> well... depending on how you do it, error messages might get WORSE the more you do at type level
11:40:09 <ggVGc> basically, because I do this in runtime, I don't really have line numbers of where anything happened
11:40:14 <ggVGc> yeah, fair
11:40:31 <ggVGc> currently I often end up in the situation where it says what is wrong, but not where it is caused
11:40:42 <EvanR> you can embed debug info into your output, perhaps using TH if you need source line numbers?
11:40:43 <ggVGc> and sometimes I literally have to just git diff
11:40:49 <ggVGc> I have done that
11:40:50 <ggVGc> to some degree
11:40:54 <ggVGc> but it's all hacky as shit
11:41:13 <ggVGc> but yeah, I guess doing this with some kind of attempt at dependent typing is gonna be way more work, and not necessarily better result..
11:41:23 <ggVGc> my future idea is to actually port this to racket
11:41:25 <EvanR> it's a wild ride nonetheless
11:41:37 <ggVGc> yeah, sure. just not sure I have time for the ride
11:45:26 <ggVGc> EvanR: I never tried TH. How much of a fuckery is it?
11:46:22 <hpc> you might not even need TH if it's just inserting line numbers
11:46:24 <ggVGc> if I just want to generate a line number argument for certain functions and store it in the resulting value, is that fairly simple?
11:46:30 <ggVGc> hpc: what can I do?
11:46:31 <hpc> but it's pretty easy regardless
11:46:47 <geekosaur> all the mixing of levels of macros, plus the intermediate form being different from the source form
11:46:58 <geekosaur> it's not hard, just annoying
11:47:01 <ggVGc> basically I have a `connect` function. So a `connect` b, and I'd like the resulting value of that function to have a line number attached
11:47:25 <ggVGc> how could I do that without TH?
11:47:27 * geekosaur suddenly wonders if HasCallStack is enough
11:47:37 <ggVGc> hm, maybe?
11:47:40 <ggVGc> haven't explored it
11:47:41 <ph88> i was looking at an article about tagless final .. not even sure if it's the right tool for the job, but anyway .. If i make my own monad is there any way i can control which function is valid after another function ?
11:48:31 <gobby> I keep on getting `HandshakeFailed Error_Misc "no keys found` when using `warp-tls`. The keys are on my server, is this likely to be a key format issue?
11:49:31 <geekosaur> gobby, maybe, maybe just looking in the wrong place (common on OS X and some Linuxes, plus freebsd if you use ports-based cert management and don't tweak some knobs)
11:49:33 <ph88> gobby, do you have a call stack with that ?
11:49:51 <gobby> ph88 yes I do have a stack call with it
11:49:57 <hpc> ggVGc: https://hackage.haskell.org/package/loch-th
11:50:13 <gobby> ```HandshakeFailed (Error_Misc "no keys found\nCallStack (from HasCallStack):\n  error, called at ./Network/Wai/Handler/WarpTLS.hs:265:20 in warp-tls-3.2.5-2FsWeMf1nNvA0nztofVYMj:Network.Wai.Handler.WarpTLS")```
11:50:29 <ggVGc> hm hm, this is pretty interesting hpc 
11:50:31 <ggVGc> thanks!
11:50:54 <ph88> about my question .. i mean if the monad changes some state .. so now it becomes invalid to call some function within the monad instance .. is that possible to make ? it would need some notation of which functions are valid to call after being in the state of some function already have been called
11:51:00 <gobby> geekosaur I'm using the absolute path 
11:51:32 <geekosaur> for the key store? then format seems more likely. but also check permissions
11:52:33 <geekosaur> ph88, >>= doesn't let you do that unless you can make it part of the type. possibly this works better in an effects system?
11:53:01 <gobby> geekosaur file permissions? I.e use `chmod`
11:53:04 <ph88> geekosaur, where can i read about what is an effects system ?
11:53:17 <geekosaur> gobby, that's what I was wondering, yes
11:53:29 <geekosaur> remember to also check permissions on directories leading to the file!
11:53:58 <geekosaur> ph88, see https://www.schoolofhaskell.com/user/fumieval/extensible/named-extensible-effects
11:54:15 <geekosaur> for one, there are others. "extensible effects" is the general term
11:56:00 * hackage swish 0.10.0.2 - A semantic web toolkit.  https://hackage.haskell.org/package/swish-0.10.0.2 (DouglasBurke)
11:56:01 <geekosaur> although maybe this si going backwards. possibly you want those tags after all :)
11:56:32 <geekosaur> mmm, type level tagging to control the a and b in m a -> (a -> m b) -> m b
11:57:14 <geekosaur> but I don't know any detail about what you're doing, so I'm just kinda firing out random ideas
11:57:40 <ph88> geekosaur, it's about D3.js i'm not sure if you know this library ..
11:57:54 <geekosaur> I don't
11:58:20 <ph88> it's a javascript library in which you can select things in the browser document, then do transitions and then change values and so on
11:58:55 <ph88> there is a lot of manipulation of the Document Object Model going on ... just that some functions may not be called before "setup" of other functions
11:59:08 <ph88> like you must at least select something before you change a value on it
11:59:36 <ph88> how does type level tagging work then ?
11:59:59 <ggVGc> EvanR: haha... I pasted our conversation to my gf... and she made a poem out of the words in it: https://gist.github.com/5854622dcd04ada374422cb79fdc1328
12:02:01 <geekosaur> turn on DataKinds extension, declare a tag type like: data FuncSetup = NotYet | SetUp
12:02:48 <geekosaur> you cn now have things of type e.g. Foo SetUp, and setUpFoo :: Foo NotYet -> Foo SetUp
12:03:05 <geekosaur> this said, setup functions sounds to me like a place to use bracket pattern instead
12:03:29 <geekosaur> (bracket setUp doWork tearDown)
12:04:51 <EvanR> ggVGc: thats... hilarious
12:04:59 <EvanR> now i have to watch what i say
12:06:02 <geekosaur> wonder if lwall felt this way first time :p
12:07:32 <geekosaur> ph88, also note you can if necessary use a type for doWork that is only present in the bracket; see runST for how that can work
12:13:24 <EvanR> hmm... where is the haskell poetry made from prelude 
12:13:26 <ggVGc> EvanR: I was responding to her sending me stuff in polish to "read"
12:13:39 <ggVGc> figured our convo was the closest to unreadable gibberish for her that I had
12:13:52 <EvanR> really... 
12:14:09 <EvanR> i should try to pay more attention to how incomprehensible this channel is
12:16:05 <monochrom> It's incomprehensible to me every time there is lens, Kan extensions, Yoneda's lemma, HoTT, stack, nix, or webapps.
12:16:37 <EvanR> for the most part agree
12:16:42 <crestfallen> hi real quick what's happening with this list comprehension and the wildcard? :
12:16:53 <crestfallen> > [ 1  | _ <- [4,5]]
12:16:55 <lambdabot>  [1,1]
12:16:58 <heatsink> How did Haskell get related to nix?
12:17:12 <crestfallen> > sum [ 1  | _ <- [4,5]]
12:17:13 <ggVGc> crestfallen: it generates a list of two values, and outputs 1 for each of them
12:17:15 <lambdabot>  2
12:17:18 <monochrom> Like [ 1 | v <- [4,5] ]
12:17:19 <geekosaur> it's easier to build some packages via nix than trying to get all the pieces together yourself
12:17:31 <geekosaur> reflex and ghcjs come to mind
12:17:51 <heatsink> Hm.  So nix was kind of an alternative to cabal/stack?
12:18:06 <heatsink> I guess nix predates stack
12:18:07 <hololeap> crestfallen: it could be rewritten as  map (\_ -> 1) [4,5]
12:18:17 <geekosaur> sort of. except it's not just about haskell stuff, it tries to "sandbox" an entire OS
12:18:21 <ggVGc> crestfallen: [ 1  | _ <- [4,5]] is saying "Iterate over the list [4,5], and for each iteration put the value in _ (e.g ignore the value). And for each value, output 1
12:18:21 <geekosaur> userspace, at least
12:18:25 <ggVGc> so you get [1,1]
12:18:49 <geekosaur> this can be useful when there are non-Haskell components to whatever you're building
12:19:06 <ggVGc> geekosaur: or when have to run npm but refuse to have any node on your system...
12:19:47 <heatsink> That makes sense
12:19:48 <ggVGc> or when you have to format your code with exact compiler version x.y.z to make it go through CI 
12:19:58 <ggVGc> but your system compiler version is a.b
12:20:16 <crestfallen> ggVGc, but in this case: 
12:20:24 <crestfallen> > sum [ 1  | _ <- [4,5]]
12:20:25 <geekosaur> stack handles that. cabal doesn't but you can use ghcup or hvr's repo or etc. to get multiple versions
12:20:26 <lambdabot>  2
12:20:35 <ggVGc> crestfallen: yes, you are summing [1, 1]
12:20:38 <ggVGc> e.g 1 + 1
12:20:43 <ggVGc> which is 2
12:21:16 <crestfallen> but wouldn't [4,5] be 2 iterations to be added to 1?
12:21:49 <ggVGc> you already saw the result of [ 1  | _ <- [4,5]]  is [1,1]
12:21:50 <ggVGc> right?
12:21:56 <ggVGc> so you're just calling sum on [1,1]
12:22:41 <ggVGc> also, this is a very strange construction, and you'd never see it in normal haskell code
12:23:03 <crestfallen> but wait sorry..
12:23:24 <crestfallen> is it only sending 1 to the left of the pipe?
12:23:52 <crestfallen> to be cons to the 1 like 1:[1] ?
12:23:52 <ggVGc> crestfallen: the left part of a list comprehension is the expression outputted for each iteration. It has access to the variables you define in the right part of the expression
12:24:03 <ggVGc> the right part is how you populate the values for each iteration
12:24:22 <EvanR> [ 1 | _ <- [p, not p] ]
12:24:24 <ggVGc> you are outputting a constant 1 for any iteration
12:24:43 <crestfallen> oh so its not a seed, it's like a quantifier?
12:24:45 <monochrom> You get [1,1], as opposed to [1,1,1,1,1], precisely because there are two iterations.
12:25:53 <crestfallen> so [1 | ... ] is like a quantifier so to speak 
12:25:54 <ggVGc> btw, ignoring the value in the right part of the list comprehension is very strange, and defeats the whole purpose of using one
12:26:10 <ggVGc> I'd almost argue what you're writing should be an error or at least a warning from the compiler
12:26:21 <EvanR> crestfallen: it corresponds to set-builder notation, it stands for a method of building a lit
12:26:28 <EvanR> list
12:26:57 <ggVGc> crestfallen: what you are writing is exactly equivalent to:
12:26:59 <ggVGc> replicate 2 1
12:27:02 <ggVGc> > replicate 2 1
12:27:04 <lambdabot>  [1,1]
12:27:15 <crestfallen> so a quatifier or interval or what would you call it?
12:27:18 <ggVGc> or rather
12:27:19 <monochrom> These "like" analogies make you comfortable and at the same time are precisely the reason why you aren't learning.
12:27:29 <ggVGc> > replicate (length [4,5]) 1
12:27:31 <lambdabot>  [1,1]
12:27:40 <ggVGc> ^ crestfallen  this is what you are expressing
12:27:54 <hololeap> crestfallen, have you seen a useful example of the list comprehension notation so you can see what it's used for?
12:27:56 <crestfallen> no I get it .. it's not a seed, or the first element of a list to be summed
12:28:19 <ggVGc> > [a + b | a <- [1,2], b <- [3,4]]
12:28:22 <lambdabot>  [4,5,5,6]
12:28:33 <crestfallen> yeah it's just in a little tutorial I found that has this example
12:28:40 <ggVGc> it's a very strange example
12:28:57 <ggVGc> if you're ignoring the values of the right side of a list comprehension, you're basically doing a replicate
12:29:30 * hackage poseidon 0.1.1.0 - Simple extensible library to run SQL file against PostgreSQL database.  https://hackage.haskell.org/package/poseidon-0.1.1.0 (FlogFR)
12:29:40 <crestfallen> no the replicate comparison cleared it up thanks ALL
12:30:14 <ggVGc> cool :)
12:30:20 <ggVGc> btw, list comprehensions are very useful
12:30:25 <ggVGc> if used when they are suitable
12:30:49 <crestfallen> I've seen a bunch I just didn't get what the 1 | .. stood for
12:32:00 <crestfallen> having [1 | _ <- ..] actually afforded some insight, since normally it's [x | x <- ..]
12:32:55 <ggVGc> crestfallen: list comprehensions are the most useful when the expression in the left part isn't just a simple "x"
12:33:01 <ggVGc> but an actual useful expression
12:33:11 <ggVGc> e.g an arithmetic one, or a function application
12:33:26 <ggVGc> or a data constructor
12:33:33 <hololeap> > [(x,y) | x <- [1..4], y <- [1..4], x /= y]
12:33:35 <lambdabot>  [(1,2),(1,3),(1,4),(2,1),(2,3),(2,4),(3,1),(3,2),(3,4),(4,1),(4,2),(4,3)]
12:33:44 <hololeap> just a random example
12:34:10 <crestfallen> yeah thanks I've seen those sorts, but not a data constructor I don't believe
12:34:34 <ggVGc> creating a tuple is a data constructor
12:34:39 <ggVGc> but
12:34:57 <ggVGc> [Grid x y | x <- [1,2], y <- [1,2], x /= y]
12:35:09 <ggVGc> for example
12:35:31 <crestfallen> > [Grid x y | x <- [1,2], y <- [1,2], x /= y]
12:35:33 <lambdabot>  error:
12:35:33 <lambdabot>      Data constructor not in scope: Grid :: Integer -> Integer -> a
12:35:34 <EvanR> a tuple is a data constructed
12:35:56 <ggVGc> crestfallen: that's why I didn't use the bot :)
12:36:09 <crestfallen> jumped the gun :)
12:36:44 <ggVGc> the point is, list comprehensions are a concise way of creating a sequence of values based on some rules and lists of input values
12:36:50 <ggVGc> rather than combining fmaps and folds
12:38:00 * hackage poseidon-postgis 0.1.1.0 - Extension of Poseidon library for Postgis (Spatial and Geographic objects for PostgreSQL)  https://hackage.haskell.org/package/poseidon-postgis-0.1.1.0 (FlogFR)
12:40:30 * hackage basen 0.1.0.0 -   https://hackage.haskell.org/package/basen-0.1.0.0 (fabianhjr)
12:43:32 <crestfallen> ggVGc, that's interesting thanks, I need to contemplate that
12:49:31 <EvanR> well, comprehensions kind of can't fold can they. They can map, concat, and filter
12:50:21 <EvanR> (i think the basic list processing operations don't get much attention in this channel)
12:50:43 <dsal> I forgot how to lens again...  I've got an aeson blob in the form of   {"response": [{"id": "x"}]}   --how do I get a list of response.x ?
12:51:00 <monochrom> comprehensions are exactly MonadPlus
12:51:18 <monochrom> So, right, can't fold.
12:51:33 <monochrom> We know think of fold as a separate Foldable.
12:51:48 <fabianhjr[m]> I fucked up and followed a help link from the preview page to the real upload page and ending up publishing my first package sooner (before I wrote the readme) than planned. :/
12:51:49 <fabianhjr[m]> Oh well
12:52:23 <monochrom> You can always push a new bug-fix release very quickly.
12:52:29 <fabianhjr[m]> Good thing is that the tests of the few functions are green. xD
12:53:27 <fabianhjr[m]> Thing is that I wanted to polish it way more before-hand. Dx
12:54:01 * hackage mmsyn2 0.1.5.0 - The library that can be used for multiple (Ord a) => a -> b transformations  https://hackage.haskell.org/package/mmsyn2-0.1.5.0 (OleksandrZhabenko)
12:56:08 <lyxia> what a strange package name
12:58:54 <fabianhjr[m]> mmsyn2 or BaseN?
13:00:11 <lyxia> mmsyn2
13:02:08 <crestfallen> oh thanks for the additional input everyone
13:05:29 <lyxia> dsal:   key "response" . values . key "id"
13:06:15 <dsal> lyxia: oh nice!  thanks.  That's it.
13:13:16 <fresheyeball> why does logBase require floating point?
13:13:27 <fresheyeball> is there an implimentation of logBase that works on Rationals?
13:14:27 <geekosaur> isn't log kind of the prototypical irrational operation?
13:15:02 <geekosaur> well, I guess sqrt is
13:15:20 <fresheyeball> I feel like I should be able to get accuracy beyond floating point though
13:15:46 <fresheyeball> deterministic atleast
13:15:52 <monochrom> Sure, use CReal or someting.
13:16:07 <monochrom> The class name "Floating" does not have to be taken seriously.
13:16:11 <geekosaur> Rational's possibly the worst possible choice for that, you'd need to pass some epsilon to avoid infinite-length denominators
13:16:38 <fresheyeball> geekosaur: that is what I expect yeah
13:17:02 <fresheyeball> monochrom: I don't see a Floating instance for CReal
13:17:42 <geekosaur> I do
13:17:56 <monochrom> > logBase 3 2 :: CReal
13:17:59 <lambdabot>  0.6309297535714574370995271143427608542996
13:18:08 <fresheyeball> oh nice
13:18:32 <fresheyeball> so I guess I should convert my Rational to a CReal and back?
13:18:57 <fabianhjr[m]> > logBase 3 2 :: Double
13:18:59 <lambdabot>  0.6309297535714574
13:19:32 <shachaf> You can do much better than CReal, I'm sure, if you a particular fixed precision.
13:19:33 <monochrom> Is this a sequel to Rational Trig?
13:20:05 <geekosaur> (gives new meaning to "transcendental meditation"…)
13:20:08 <fresheyeball> electric booglaloo
13:23:18 <boxscape> With CDouble and CFloat you'd expect CReal should be the C equivalent of Haskell's Real type
13:24:04 <geekosaur> Real isn't a type, it's a typeclass
13:24:30 <shachaf> That's barely relevant to the joke.
13:24:33 <geekosaur> and both are in some sense modeling in their own distinct ways the same thing: mathematical real numbers
13:24:44 <shachaf> Also Real is such a terrible name for that class.
13:24:47 <shachaf> @src Real
13:24:47 <lambdabot> class (Num a, Ord a) => Real a where
13:24:48 <lambdabot>     toRational :: a -> Rational
13:25:12 <shachaf> If you're modeling the reals as things that can be converted to rationals, you're not doing a great job.
13:25:24 <geekosaur> that describes all of Num…
13:25:34 <geekosaur> well, characterizes
13:25:35 <monochrom> OK, Haskell is a sequel to Rational Trig.
13:26:43 <monochrom> No, Real is a great name, toRational is not a great method for it.
13:27:32 <boxscape> great method or great method name?
13:27:33 <monochrom> Something like a -> Rational -> Rational or a -> Natural -> Rational would be right, as discussed yesterday.
13:27:38 <boxscape> okay
13:27:58 <monochrom> The extra parameter specifies how close you want the answer to be.
13:28:24 <monochrom> (Yesterday I asked how to define the computable reals.)
13:29:19 <shachaf> The class means "real" in the sense of "a subset of R", as opposed to complex numbers, for example.
13:29:35 <shachaf> But it actually means "a subset of Q".
13:29:47 <hpc> technically it's a subset of all three
13:30:46 <boxscape> but only types that are only subsets of Q and not of R and C can have reasonable Real instances defined for them
13:31:07 <shachaf> What's a subset of all three?
13:31:32 <boxscape> shachaf any subset of Q is also a subset of R and of C
13:31:45 <hpc> Q itself is a subset of R
13:31:49 <hpc> R is a subset of C
13:32:06 <fresheyeball> well that kicked off some conversation
13:34:10 <shachaf> Yes, but that's not relevant to what I said.
13:42:16 <ggVGc> well, I sorted my DSL issue by simply using ImplicitParams and Callstack
13:42:21 <ggVGc> which is useful
13:42:24 <ggVGc> but also, quite strange
13:42:29 <ggVGc> not sure I understand implicit params yet
13:42:44 <hpc> it's an odd one, for sure
13:43:03 <heatsink> They work like typeclasses, but they're values
13:43:17 <ggVGc> for now, all I care about is that I can have line numbers in my DSL
13:43:35 <ggVGc> which was problematic, because I always got the errors while evaluating the state monad (which is what my DSL evaluates to)
13:43:41 <hpc> they're values that are dynamic-scoped
13:43:50 <ggVGc> which obviously gives me the call to error when the callstack isn't available anymore
13:43:58 <ggVGc> but now I store the callstack when building the state
13:44:00 <ggVGc> and it's fine
13:44:19 <hpc> but without lexical scoping, you need a way to say what the dynamic-scoped values are supposed to be like, which fits for a constraint
13:46:02 <ggVGc> either way, this improves the quality of my DSL my billions of %
13:46:19 <ggVGc> it's been quite crappy until now whenever I get errors... essentially useless often, since I had no idea what made a connection invalid
13:46:26 <ggVGc> just that something was wrong
13:47:18 <ggVGc> guess it's a result of using State 
13:50:00 * hackage X11 1.9.1 - A binding to the X11 graphics library  https://hackage.haskell.org/package/X11-1.9.1 (DanielWagner)
13:50:31 <ggVGc> :(
13:50:33 <ggVGc> when will X11 die
13:50:48 <hpc> when cobol dies
13:51:07 <ggVGc> oh dear
13:56:59 <aveltras> anyone using ghcide with cabal mixins ? does it work ?
13:58:03 <shachaf> X11 is not great but is there a good alternative?
13:58:40 <monochrom> "good" has too much burden and runs against too much inertia
13:59:24 <shachaf> I agree.
13:59:41 <shachaf> Nevertheless I'll continue writing my program for X11.
13:59:57 <monochrom> hee hee
14:26:33 <dsal> Is there a way to partially parse something in aeson?  i.e., I've got lazy bytestring `{"response": thing}` and I just want to get rid of the outer wrapper and have a lazy bytestring of whatever `thing` is
14:26:57 <dsal> I'm porting a program from go where I do this.  Most of my program is just tossing around raw blobs.
14:28:30 <dsal> BL.stripPrefix is a fine hack, though.
14:31:56 <jle`> dsal: you can probably use one of the runners of attoparsec
14:32:05 <jle`> that provide leftovers
14:32:55 <jle`> unless the parsers expect eof's or something; might be worth testing
14:33:39 <dsal> Hmm...  Would that still leave me with a }?
14:33:49 <xocolatl> would it be possible to write something like sqlite in haskell?  I don't see how without pretty much all of it being in IO.  perhaps someone has already done something like this?  (the access language need not be sql)
14:34:44 <dsal> xocolatl: Sure.  Not all of sqlite is IO
14:34:58 <iqubic> Creating a well typed query isn't IO.
14:35:08 <dmwit> dsal: I have a cunning plan.
14:35:13 <fabianhjr[m]> Yes, it is possible but a rewritte would take a lot of effort.
14:35:16 <xocolatl> it's also single user, so perhaps my example of sqlite is a poor one
14:35:17 <dmwit> dsal: You're not going to like it.
14:35:22 <dsal> dmwit: I like it already.
14:35:40 <iqubic> dmwit: What is cunning plan you have?
14:35:41 <dmwit> dsal: Parse to Value, pick out response field, re-encode.
14:35:59 <dsal> dmwit: Yeah, I thought about doing that.
14:36:02 <iqubic> Oh. I'm not writing that code, but I know I don't like it.
14:36:10 <xocolatl> if you know of a database written in haskell, I would be interested.  my searches only tell me how to access other databases from haskell
14:36:11 <dsal> dmwit: I'm going with something dumber, though. h eh
14:36:37 <dsal> sqlite is the best database I've used.
14:37:09 <dsal> I don't see what would be particularly hard about making a database in haskell, though.
14:37:22 <dsal> Most of my struggles in haskell are just in APIs I've not used in a while (e.g., lens and aeson right now)
14:37:40 <xocolatl> probably just that most of it would be in IO
14:37:41 <iqubic> lens is great. Learning lens is a good thing to do.
14:38:49 <dmwit> xocolatl: I guess people don't talk about acid-state much any more, but that used to be one of the go-to native-Haskell DB replacements.
14:39:21 <c_wraith> It just was less ACID than expected, and rather slow...
14:39:28 <dsal> iqubic: several times, I've learned enough lens to be slightly proficient, and then give up.
14:39:57 <dsal> It's just hard to do better than sqlite, and there are good sqlite interfaces in haskell.
14:40:30 <dsal> If you replaced sqlite with hasqlite, it'd be a huge effort and not significantly better in any way.
14:40:41 <xocolatl> my interest is more academic.  I'm not trying to replace sqlite (that would be a fool's errand)
14:40:56 <monochrom> :)
14:41:05 <dsal> I could imagine a distributed system that would be a pretty good thing to build.
14:41:35 <dmwit> Presumably the selling point, if one were going to do this, would be more idiomatic tie-in to the way Haskell thinks about data types.
14:41:35 <monochrom> Well, academics don't really do futile things all that much either...
14:41:50 <dmwit> The way SQL thinks about data types is... not very close to the way Haskell does.
14:42:15 <monochrom> In the case of Haskell academics, they're more interested in moar dependent types than a better theory of databases.
14:42:52 <xocolatl> okay, so haskell and its community is not a good fit for exploring things.  bummer
14:42:59 <monochrom> OK that may actually contradict what I said about "they don't really do futile things" haha. Consider it sarcasm then!
14:43:19 <dmwit> Huh.
14:43:34 <dmwit> Guess I don't really understand that reaction. But you do you, I guess. See ya.
14:43:57 <dsal> Can't wait to read that blog post.
14:44:23 <monochrom> I thought the young ones no longer do blogs, they tweet.
14:44:44 <monochrom> Or capture a picture and do memes.
14:45:33 <dsal> OK.  I'm out of practice.    I want to compose two functions that are    a -> Maybe a    Why isn't my brain helping me do this?
14:45:52 <monochrom> Try the "fish operator" >=>
14:45:52 <c_wraith> :t (<=<)
14:45:53 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
14:46:01 <iqubic> Yes. That.
14:46:03 <monochrom> Or that, in the other direction.
14:46:10 <iqubic> I was just going to suggest kleisli arrows.
14:46:17 <dsal> Ooh.  Yeah, I  think I never knew that one.
14:46:17 <iqubic> Which is the same thing actually.
14:47:51 <thunderseethe> When working with a cofree fixpoint is there a way to ignore the annotation and work with the cofree like a Fix fixpoint?
14:48:52 <dsal> Yay, terrible hack works:   BL.stripPrefix "{\"response\":" <=< BL.stripSuffix "}"
14:48:55 <dmwit> dsal: If you aren't feeling fancy, boring old do notation works fine, too. do { x <- f y; g x }
14:48:57 * dsal parses JSON profesionally
14:49:18 <dsal> dmwit: That's better than what I was doing before.  I don't think about do notation much.
14:49:28 <dsal> I had working code, I just knew there was a composition thing.
14:49:48 * dmwit sends dsal `{ "response": "haha, I broke your code" }`.
14:50:18 <dsal> I'm writing a hacky tesla API consumer for myself.  Tesla keeps breaking my old hacky thing by renumbering my car regularly.
14:50:48 * dmwit sends dsal `{"response": "haha, I broke your code", "foo": "in another way"}`
14:50:52 <dsal> They're breaking their own apps doing that, too...  I keep having to do stuff to the app to get it to realize my car isn't where I thought it'd be.
14:51:29 <dsal> Yeah, the way I did this in go is a little better.  It has a type I can use when unmarshaling that maintains the original serialized form.  Super handy.
14:51:58 <dsal> Once I'm done with this, it won't break again until I completely forget what all this does, though.
14:52:29 * monochrom writes reddit post "Haskell is used for Tesla cars"
14:52:30 * hackage asset-bundle 0.1.0.2 - A build-time Cabal library that bundles executables with assets  https://hackage.haskell.org/package/asset-bundle-0.1.0.2 (deech)
14:53:07 <dmwit> Can you explain *why* you do not want to correctly parse the JSON?
14:53:40 <dmwit> I mean, you don't owe me anything, obviously, but... it just seems weird.
14:53:43 <dsal> This program mostly doesn't deal with any of the data inside.  It grabs a couple fields out of it just to know how fast to loop, but for the most part, it just dumps the blobs into mqtt and sqlite.
14:54:09 <dsal> So I want to keep it mostly as clean as I can...  except I also want it to be backwards compatible.  The older code just pulled that field out as a blob.
14:54:25 <dsal> I'm also hoping to get to the important parts sooner.  :)
14:54:28 <monochrom> laziness and hubris and all the supposed fabled virtues of programmers
14:55:48 <ph88> is it possible to make some monad that has some state and depending on the current state allow some functions to be called or not to be called ? maybe to encode this in the types somehow ?
14:56:31 <dsal> There are guards in Control.Monad
14:56:51 <dmwit> ph88: The search term you want is "indexed monad".
14:57:18 <ph88> dmwit, thx i'll have a look
14:57:22 <ph88> dsal, what about the guards ?
14:57:31 <dsal> I'm not familiar with indexed monad.
14:58:02 <dsal> ph88: this stuff:  http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#g:6
14:59:15 <ph88> dsal, ok i've seen guards before .. but i need something to prevent a function to be called
15:00:00 <dsal> when itIsOKToCallTheFunction callTheFunction
15:01:01 <ph88> ok but then the consumer of the library has to put the check in his code when i want the compiler to do it
15:01:21 <dsal> Oh, you want this at compile time.
15:01:40 <ph88> yes i want to make a library where it's impossible to call some functions if you have not called some other functions before ..
15:02:19 <thunderseethe> That sounds like something Session Types could help with
15:02:54 <ph88> ya possibly .. just that i don't know at the moment how many states there will be and how many state transitions
15:03:13 <ph88> state being "function A has been called so it's ok to call B now"-state
15:03:56 <ph88> if i would put that graphically ... maybe the states could be drawn with nodes and edges and you get a graph.
15:04:04 <ph88> dunno if sessions types can encode such things
15:04:43 <thunderseethe> That's more or less what they are designed to encode, granted over a net connection
15:04:58 <ph88> net connection ?
15:05:24 <thunderseethe> Though it's also quite possible you don't need full session types and just need some witness types
15:06:01 <thunderseethe> Yea session types are to help type request and responses between a client and server, so they help to encode the kind of client sends this request server must response with this response
15:06:16 <AFridgeTooFar> have a question about vectors... would it be possible to have a function like this? MVector s a -> (Vector a -> r) -> St s r
15:06:43 <AFridgeTooFar> where the continuation doesnt need to copy the vector
15:07:07 <thunderseethe> If you have your function A return some token `CompletedA` and B takes that token `B :: CompletedA -> ... -> r` you can enforce that any body uses the functions had to have called A before B
15:08:47 <ph88> thunderseethe, how's that ? can one not simply created a static "CompletedA" ?
15:09:01 * hackage regex-tdfa 1.2.3.3 - Replaces/Enhances Text.Regex  https://hackage.haskell.org/package/regex-tdfa-1.2.3.3 (Artyom)
15:10:06 <thunderseethe> You as the library maintainer can make `CompletedA`'s constructor private/unexported so only the module it's defined in can construct it. Then A is the only public function that produces a CompletedA
15:11:11 <ph88> thunderseethe, if you have different types they can not make a monad as far as i know. But to have my own monad so i can write some DSL like code with do-notation would be great
15:12:42 <ph88> this is a nice talk about tagless final style https://www.youtube.com/watch?v=8DdyWgRYEeI  
15:13:16 <ph88> i think session types in haskell are not implemented yet
15:13:46 <ph88> witness types seem to be for dynamic casts ..
15:15:05 <thunderseethe> There are some libraries for it but it is probably over kill here, I do not know of witness types being used for dynamic casts
15:16:09 <thunderseethe> You should be able to wrap up the `CompletedA` concept and I'm pretty sure that's what dmwit was referring to earlier with the indexed monads
15:16:31 <perrier-jouet> hi all
15:16:31 <ph88> i didn't know witness types .. just something i just read here https://wiki.haskell.org/Type_witness
15:16:38 <perrier-jouet> anyone on archlinux here ?
15:16:52 <perrier-jouet> what is the preferred way of installing haskell ?
15:17:08 <ph88> perrier-jouet, my prefered way is to use stack
15:17:15 <nil> see https://wiki.archlinux.org/index.php/Haskell
15:18:40 <hexagoxel> AFridgeTooFar: seems unsafe due to laziness. I think it might be safe with  NFData r => ..  though. No promises :p
15:19:02 <perrier-jouet> ph88:are you on archlinux ?
15:19:07 <ph88> perrier-jouet, no
15:19:26 <perrier-jouet> nil from https://www.reddit.com/r/haskell/comments/8vu73f/haskell_on_arch/ 
15:19:51 <perrier-jouet> The main issue in Arch is that the maintainers configured GHC to use dynamic libraries and that messes up everything
15:20:32 <hexagoxel> AFridgeTooFar: but even with NFData, what if you pass `id` as continuation? I revert my answer to "no, cannot be done safely"
15:21:26 <halogenandtoast> Is there a good way to clean up what I am doing in processQueue/dequeue (I feel slightly uncortable with the lambda case) in: https://gist.github.com/halogenandtoast/a0a91285eda3b8503374febb6a35c2c9
15:22:05 <AFridgeTooFar> hexagoxel: ah damn think i see what you're getting at, thanks for the response
15:25:06 <ph88> perrier-jouet, try stack, if you don't like it you didn't waste much time
15:26:00 * hackage gtk2hs-buildtools 0.13.5.1 - Tools to build the Gtk2Hs suite of User Interface libraries.  https://hackage.haskell.org/package/gtk2hs-buildtools-0.13.5.1 (HamishMackenzie)
15:45:19 <lyxia> halogenandtoast: you could get the whole queue to traverse_ it rather than get one element at a time in an awkward stateful loop
15:45:49 <lyxia> ah, unless `eval` does things to the queue too?
15:46:20 <halogenandtoast> eval does things to the queue
15:46:24 <halogenandtoast> lyxia: ^^
15:46:51 <lyxia> :(
15:51:28 <lyxia> I can't see any obvious improvements
15:55:38 <halogenandtoast> lyxia: Okay thanks
15:59:54 <dmwit> AFridgeTooFar: No, but it's possible to write `MVector s a -> (Vector a -> r) -> ST s (MVector s a, r)` without copying.
16:00:21 <dmwit> AFridgeTooFar: You'll have to promise not to use the MVector you pass in (but the one you get out will have the same contents and may be used).
16:01:33 <AFridgeTooFar> dmwit: yeah, makes sense, hexagoxel 's example really illuminated this for me
16:02:14 <dmwit> Oh, yeah, the thing I'm proposing would have some caveats akin to what hexagoxel talked about, too.
16:03:08 <shapr> first time I've ever wanted a debugger in haskell
16:03:09 * shapr grumbles
16:03:24 <shapr> dmwit: oh, I tried to figure out how to contact you on twitter, but I don't think you have a twitter account.
16:03:44 <shapr> I was looking for surprise coder friends on the DC red line today.
16:04:14 <dmwit> I am dmwit13 on twitter, but I visit that site very infrequently.
16:04:56 <dmwit> I offered to buy dmwit from the person who has it. Two days later I was blocked, and I figured that was as clear an answer as I could possibly hope for.
16:05:20 <dmwit> Still, I'm sad I missed you. How long will you be in town?
16:05:21 <shapr> dmwit: I'm in town until tomorrow evening, I may see if you have time for code/coffee during the day tomorrow.
16:05:37 <dmwit> Nice!
16:05:46 <shapr> though today's frustration is mostly trying to figure out exactly where scotty is calling an unexpected urlDecode
16:06:21 <shapr> dmwit: I'm explicitly free from 12:00 to 14:00 tomorrow, want to meet up on the red line and write some code?
16:10:04 <dmwit> "on the red line"?
16:10:21 <shapr> dc metro red line?
16:10:44 <dmwit> It's a bit... nonspecific.
16:11:26 <shapr> well, I have an unlimited three day pass, and I enjoy walking, so vaguely close to a red line stop would be convenient, but not necessary? :-)
16:12:18 <dmwit> There's a Shake Shack a block from the Dupont Circle station. Want to do lunch?
16:13:35 <shapr> dmwit: sure! sounds good!
16:17:00 <iqubic> do you two live close by?
16:17:34 <hpc> is this an open meetup?
16:17:52 <iqubic> It depends on where you live.
16:19:20 <maralorn> I am implementing a record type for a library it now has (Eq,Show,ToJSON,FromJSON) any other instances which users of my library will be annoyed about if I forget them?
16:20:22 <dmwit> Might as well toss Ord and Read in there.
16:21:06 <shapr> iqubic, hpc: want to show up? Shake Shack @ Dupont Circle at noon?
16:21:20 <shapr> I'll wear my Chaotic Good t-shirt so I'm easy to recognize.
16:21:27 <hpc> nice
16:22:14 <hpc> ill have to re-figure-out the metro since i generally stick to fairfax, but yeah
16:22:15 <iqubic> I'm not anywhere near there.
16:22:25 <shapr> iqubic: attendance is optional :-)
16:22:38 <shapr> I mostly live in brooklyn, so I get it
16:22:39 <iqubic> I'm in California right now. Opposite side of the country.
16:22:57 <shapr> probably inconvenient for you then
16:23:01 <iqubic> It is.
16:23:07 <Rembane> You need seven league boots! 
16:23:22 <shapr> Next time I'm in California I'll ping you. California is such a small cozy state ...
16:24:12 <maralorn> dmwit: Ord does not really work, the type is to complex.
16:24:24 <maralorn> Does Read need to be the inverse of Show?
16:24:55 <dmwit> The intention is that Show produces valid Haskell syntax, and Read consumes valid Haskell syntax.
16:25:27 <maralorn> Uh
16:25:35 <dmwit> If you want other formats (e.g. to be more human-friendly) you should use a different class.
16:26:11 <monochrom> I was learning Rust and it divides our Show into two separate traits: Debug and Display, precisely because of this.
16:26:18 <shapr> Anyone else in the DC Metro area wants to show up for Haskell chat? Dupont Circle Shake Shack, tomorrow at noon!
16:26:47 <maralorn> dmwit: Thanks.
16:27:10 <monochrom> And Debug is the derivable one which is always programmer-friendly format, Display is underivable and must be handcoded for end-users.
16:27:22 <thunderseethe> Are there standard alternatives to Show?
16:27:28 <monochrom> No.
16:27:31 <maralorn> Is there somewhere a list of Typeclasses on should consider implementing?
16:27:49 <monochrom> Haskell 2010 Report has most of them.
16:28:25 <monochrom> The other ones are Typeable and Data and you request to derive them.
16:28:58 <iqubic> What are Typeable and Data good for?
16:29:09 <hpc> HUH, absolutely nothing!
16:29:09 <thunderseethe> Woah is Applicative not in prelude?
16:29:15 <iqubic> It is.
16:29:16 <hpc> but also for generic introspection of types
16:29:33 <iqubic> you need to import Control.Applicative
16:29:37 <monochrom> If you don't know then don't worry about them. Just that they're de-facto standards.
16:29:37 <iqubic> But it's in base.
16:30:07 <monochrom> Oh and Foldable and Traversable. They haven't made it into Haskell 2010 either.
16:30:16 <iqubic> Can't be too much of a standard if they aren't on my radar.
16:30:20 <hpc> maralorn: generally once you get beyond Show, which is best used for debugging, you are dealing with some specific format and that might have its own type class
16:30:29 <hpc> maralorn: like if you're dealing with JSON, or SQL
16:32:03 <iqubic> hpc: He's got ToJSON and FromJSON already.
16:41:56 <shapr> Time for Haskell 2020 to include Foldable and Traversable?
16:42:06 <shapr> I also want to switch to GADTSyntax by default
16:42:09 <shapr> just cause I'm difficult
16:42:15 <dmwit> It would be nice if the pretty-printing libraries shipped with a class.
16:42:26 * shapr joins the Haskell 2020 committee
16:42:26 <dmwit> As it is everybody makes their own, and that means nobody interoperates.
16:43:23 <dmwit> ?where typeclassopedia
16:43:23 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
16:43:59 <dmwit> maralorn: ^ That's more of an intro to using typeclasses than an encyclopedic list, I think, but might be interesting to glance through. It captures the most popular ones.
16:44:44 <dmwit> Probably Semigroup/Monoid/Foldable/Traversable are the most likely ones mentioned there for a new record type to be able to sensibly implement.
16:49:53 <shapr> I think I have a webdev question, but it might be a Haskell question.
16:50:23 <shapr> I want to serve images from a directory that has an url encoded forward slash, and I'm unable to do this with scotty
16:50:55 <shapr> further testing shows that anything url encoded is url *decoded* before it gets through scotty
16:51:02 <shapr> and yet, the scotty codebase doesn't have any urlDecode call that I can find
16:56:10 <shapr> I created two directories, one named foo%2Cbar and one named foo,bar both hold different test.txt files with contents telling me which one I've reached.
16:56:21 <shapr> I'm unable to reach the file inside foo%2Cbar, only the one inside foo,bar
16:56:25 <shapr> I am confused.
16:58:58 <thunderseethe> Are you looking for the string "urlDecode" in the scotty codebase?
16:59:05 <shapr> yeah, couldn't find it
16:59:15 <shapr> thunderseethe: did you find it?
16:59:19 <thunderseethe> I did not
16:59:32 <thunderseethe> but that doesn't mean they aren't doing url decoding does it?
16:59:48 <shapr> agreed, but I was hoping it'd be that easy
17:00:30 <thunderseethe> Ah, why do you want to serve images from a url encoded directory?
17:00:34 <shapr> I have a much smaller test compiling: https://gist.github.com/shapr/32af6f21ca0c299826325088598d9326
17:00:49 <shapr> thunderseethe: because doi.org has forward slashes in their unique IDs for research papers
17:01:15 <shapr> and I want to put each paper in a dir named for its unique ID
17:01:45 <thunderseethe> is this a filesystem directory? 
17:01:53 <shapr> yup
17:03:14 <shapr> thunderseethe: I want to turn research papers into a bunch of page images for web based annotation, and I'd like to save the annotations in json, and share them on github separately from the paper itself
17:03:39 <shapr> so I figured, use the DOI ( https://en.wikipedia.org/wiki/Digital_object_identifier ) and put the info inside a dir named by the unique id
17:04:07 <shapr> but the DOI seems to always have a forward slash, so I figured I could url encode and use that for the dir name
17:04:30 <shapr> but I cannot seem to reach url encoded names, they're url *decoded* somewhere
17:04:54 * shapr blames doi.org
17:05:17 <thunderseethe> If that's your end game can you choose a different encoding that's independent of URLs?
17:05:26 <shapr> hm, any ideas?
17:05:30 <thunderseethe> and hopefully not automatically done by scotty somewhere in the nether
17:05:50 * shapr reports a bug in scotty
17:06:00 <thunderseethe> I'm not familiar with DOI, does it use all of unicode?
17:06:10 <shapr> don't think so
17:06:21 <thunderseethe> a trivial encoding would be pick some obscure unicode character and swap '/
17:06:29 <dmwit> shapr: What is the URL you are visiting to try to see the contents of foo%2Cbar?
17:06:31 <thunderseethe> '  for that in your directory and when you take a doi
17:07:10 <shapr> dmwit: http://localhost:3000/foo%2C for this small test: https://gist.github.com/shapr/32af6f21ca0c299826325088598d9326
17:07:37 <dmwit> shapr: Surely it would be localhost:3000/foo%252C, no?
17:07:44 <shapr> er
17:07:59 <shapr> well shit
17:08:04 <shapr> dmwit: point to you
17:09:06 <dmwit> ^_^
17:09:29 <shapr> dmwit: wait, explain this to me
17:09:47 <shapr> oh I get it.
17:09:54 <dmwit> ^_^
17:10:05 <shapr> url encoding is exactly the equivalent to the string itself
17:10:31 <dmwit> wait, what?
17:10:50 <dmwit> I can't even parse that sentence.
17:10:55 <shapr> that is, to a webserver/browser "foo%2C" == "foo,"
17:11:10 <dmwit> Yeah, the server itself never sees the URL-encoded version.
17:11:40 <dmwit> Or, well... it does. But it doesn't. Depends what level of "it" you are talking about.
17:12:20 <shapr> in short, I need to come up with some other way to escape the forward slashes in the DOI unique id values.
17:12:21 <dmwit> Anyway I recommend just making directories and using real slashes, both in the URL and on the filesystem.
17:12:31 <shapr> you can't use forward slashes on the filesystem.
17:12:43 <dmwit> Sure you can. They are just directory separators.
17:12:45 <dmwit> So make a directory.
17:13:30 <shapr> hrm, perhaps you're right
17:13:32 <dmwit> If your DOI is foo/bar, make a directory named foo with a file named bar in it.
17:13:35 <EvanR> how i learned to stop worrying and treat forward slash as a valid character in "filenames"
17:14:01 <EvanR> Dr StrangeFS
17:14:32 <shapr> since my backend storage is json on the filesystem, this gonna make other stuff complicated
18:36:13 <dmj`> hot take, ghc's default garbage collector settings are a garbage fire... pun intended
18:48:00 * hackage reanimate-svg 0.9.3.0 - SVG file loader and serializer  https://hackage.haskell.org/package/reanimate-svg-0.9.3.0 (DavidHimmelstrup)
18:49:41 <dmj`> should be something like this +RTS -N -A100M -s -c  -qg -RTS
18:53:22 <isBEKaml> Hi, I'm thinking of working through WYAS: https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/ for some haskell practice. Last I checked, there were issues with outdated API, has that been updated since?
18:53:56 <isBEKaml> No problem if not, I'd still appreciate a heads up :-)
19:23:26 <EvanR> dmj`: are you testing these settings with a "default program" too
19:23:52 <dmj`> EvanR: a concurrent program
19:59:13 <jsomedon> so the intuition of functor law is to make sure fmpa preservers the structure?
19:59:18 <jsomedon> preserves
20:02:04 <jsomedon> by preserving the structure I mean like f::a->b should help change each individual elements of a structure but it should not change the ordering of how elements are placed in the structure
20:02:33 <jsomedon> is this the intuition of functor law
20:12:42 <dmwit> jsomedon: Seems like a pretty decent intuition.
20:17:40 <jsomedon> dmwit: alright thanks; just trying to make sure I really get it
20:23:53 <jsomedon> can haskell function have no argument? I mean say we have a value f, its type is f::something, not f::something->anotherthing, then can f still be a function?
20:23:57 <jsomedon> in haskell I mean
20:25:46 <heatsink> Because Haskell has lazy evaluation, there is no difference between "a function taking no arguments" and "a value that's not a function"
20:26:38 <dmwit> jsomedon: Yes, a suitably polymorphic type can be specialized to be an arrow type even if it currently isn't an arrow type.
20:26:47 <dmwit> For example:
20:26:49 <dmwit> :t pure ()
20:26:51 <lambdabot> Applicative f => f ()
20:27:18 <dmwit> There is no function arrow in the text of that type. But:
20:27:21 <dmwit> > pure () ()
20:27:23 <lambdabot>  ()
20:27:38 <dmwit> ...it can be applied to an argument, meaning it can be specialized to have an arrow in its type.
20:27:56 <dmwit> :t pure () :: () -> () -- or, if you like the more explicit specialization
20:27:57 <lambdabot> () -> ()
20:28:59 <jsomedon> so I am reading about Applicatives, the text says to understand Applicatives try imagin bunch of fmaps, fmap1::(a->b) -> f a -> f b, fmap2::(a->b->c) -> f a -> f b -> f c and so on, and fmap0 is fmap0::a-> f a
20:29:29 <jsomedon> and this fmap0 thing confuses me, hence the question I asked above..
20:29:56 <jsomedon> I wodner if I should consider this a as a function or just a non-function value
20:31:16 <dmwit> Well, its type has an arrow in it. So it's *definitely* a function, no two ways about it.
20:31:34 <dmwit> Ah. Precision: fmap0's type has an arrow in it.
20:31:48 <dmwit> I see now that your actual question was whether the a in a -> f a is a function.
20:32:00 <jsomedon> right yes exactly that
20:32:06 <dmwit> And there the answer is: the person who calls fmap0 gets to choose any type they like. They may choose to use a function or not at their pleasure.
20:32:11 <iqubic> jsomedon: fmap0 is like pure, except you don't need an applicative constraint.
20:32:27 <jsomedon> oh
20:32:32 <iqubic> At least I assume that's what the semantics are.
20:32:40 <jsomedon> hm
20:32:45 <iqubic> I'd implement it as 'fmap0 = fmap id'
20:32:51 <iqubic> Or wait... Not that.
20:32:54 <dmwit> No, you wouldn't.
20:32:59 <iqubic> that doesn't type check.
20:33:05 <dmwit> It cannot be implemented in terms of normal fmap.
20:33:13 <iqubic> Yeah. fmap0 is functor dependent.
20:34:06 <iqubic> Because it's basically just pure/return but with a functor constraint instead of something else.
20:34:49 <dmwit> I am confident that, in the context of the thing jsomedon is reading, there is an Applicative constraint, not just Functor.
20:35:23 <iqubic> For fmap0?
20:35:26 <dmwit> Yes.
20:35:28 <iqubic> :t liftA2
20:35:29 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
20:35:49 <iqubic> That's basically fmap2
20:35:59 <dmwit> Yes. And it has an Applicative constraint.
20:36:07 <iqubic> Why does that need an Applicative contraint?
20:36:19 <jsomedon> so the context here is, the textsbook I am reading just finished introducing functors, and now it starts talking about what is Applicatives
20:36:44 <iqubic> So dmwit was right.
20:37:00 <dmwit> iqubic: I encourage you to make your best attempt at implementing it in a way that does not require Applicative. Then, after you've tried, we can probably have a more enlightening conversation about it.
20:37:06 <jsomedon> and I guess the author is trying to make some senes about why we need this Applicative thing, what functor cannot do and how Applicatives contirbutes
20:37:12 <heatsink> Applicative [a] could be zip-like or sequence-like, right?
20:37:35 <heatsink> My intuition is that for zip-like Applicative, fmap0 should give an infinite list; for sequence-like, it should give a list with 1 element
20:37:35 <iqubic> dmwit: I have tried it in the past.
20:38:02 <dmwit> heatsink: Yes. See also https://stackoverflow.com/q/37627513/791604
20:38:53 <dmwit> heatsink: There are other instances, too.
20:39:11 <dmwit> iqubic: Nice! Which parts did you find easiest/most difficult?
20:40:33 <jsomedon> so, function application operator, is that a thing? I mean does that really exist in haskell and programmers can actually use that?
20:40:55 <heatsink> Do you mean the $ operator?
20:41:25 <iqubic> dmwit: liftA2 f x y = _ (fmap f x)
20:41:41 <jsomedon> uh, the context is "if we view fmap of type (a -> b) -> f a -> f b as being a generalisation of the built-in function application operator of type (a -> b) -> a -> b, we might expect that some form of currying can be used to achieve the desired behaviour."
20:41:43 <iqubic> liftF2 :: Functor f => (a -> b -> c) -> f a -> f b -> f c
20:41:48 <iqubic> liftA2 f x y = _ (fmap f x)
20:42:04 <dmwit> heatsink: You might like https://stackoverflow.com/q/50701827/791604 for some discussion of how to generate a large family of other Applicative instances for lists.
20:42:24 <dmwit> jsomedon: Yes, it's a real thing.
20:42:26 <dmwit> :t ($)
20:42:27 <lambdabot> (a -> b) -> a -> b
20:42:37 <iqubic> So y :: f b and the hole is of type 'f (b -> c) -> f c'
20:42:39 <heatsink> I think jsomedon's quote is talking about the built-in feature that lets you write "f x" to apply a function
20:43:08 <dmwit> iqubic: Yeah, and there you sort of get stuck, right? Because there's no function which lets you apply the functions in an `f (b -> c)` to the values in an `f b`.
20:43:13 <heatsink> thanks dmwit
20:43:15 <iqubic> Right.
20:43:29 <dmwit> iqubic: Applicative gives you a way to do that application. (And this motivates the name Applicative.)
20:43:36 <jsomedon> heatsink: dmwit: the problem is I am not sure if it really is $ or the builtin ones(which I imagin we cannot call it) in the context(pasted above)
20:43:36 <iqubic> I mean, there is (<*>) but hat requires applicative.
20:43:59 <dmwit> jsomedon: What do you mean by "the builtin ones"?
20:44:18 <iqubic> dmwit: You can do this: liftA2 f x y = fmap f x <*> y
20:44:24 <iqubic> And it type checks.
20:44:24 <jsomedon> dmwit: something I imagin exist and yet I didn't learn yet because it's so advanced?
20:44:34 <dmwit> iqubic: Right. And it is in fact one correct implementation of liftA2.
20:44:51 <dmwit> jsomedon: Okay. I am confident that the thing you quoted is referring to ($).
20:44:51 <iqubic> one correct implementation? What are others?
20:45:10 <dmwit> iqubic: pure f <*> x <*> y is my preferred spelling. The Applicative laws says it must behave in the same way.
20:45:19 <iqubic> How does that work/
20:45:20 <iqubic> ??
20:45:22 <jsomedon> dmwit: haha ok, thanks a lot, just so many random questions popping on top of my head
20:46:00 <iqubic> Oh, right.
20:46:17 <eacameron> Does QauntifiedConstraints let me do things like convert `instance Filterable Func where` (where `Func` is a Functor) into something like `instance (Func a => Monoid a) => Filterable Func`? I've not used this extension myself yet... I sort of what a `Filterable Func` that only works on monoids...
20:46:41 <iqubic> liftA2 f x y = fmap f x <*> y == f <$> x <*> y == pure f <*> x <*> y
20:46:46 <iqubic> That's how that works.
20:47:17 <eacameron> Er I should say, Functors of monoids...
20:47:43 <iqubic> In fact, when I typed "pure f <*> x ..." HLint told me I could rewrite it as "f <$> x"
20:47:58 <iqubic> :t (<$>)
20:48:00 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:48:03 <dmwit> eacameron: I'm not sure I understand your example. In `instance Filterable Func`, it seems like `Func` should probably not be a constraint. But then in `instance (Func a => Monoid a) => ...` it looks like you *are* using it as a constraint.
20:48:12 <iqubic> :t (<*>)
20:48:13 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
20:48:26 <eacameron> dmwit: no it's not... I'm not even sure I can write this... but I'm hoping I can :/
20:48:48 <iqubic> :t \f x pure f <*> x
20:48:49 <lambdabot> error: parse error on input ‘<*>’
20:48:59 <iqubic> :t \f x -> pure f <*> x
20:49:00 <lambdabot> Applicative f => (a -> b) -> f a -> f b
20:49:03 <eacameron> `instance Filterable Func` doesn't let me talk about the things `Func` is a functor over. I want to talk about them :P
20:50:02 <dmwit> Am I supposed to know what Filterable is?
20:50:09 <dmwit> (To do a good job of answering this question, I mean.)
20:50:22 <jsomedon> is $ left associative? is there any convinient way to check if something is left or right associative? like we check type by :t in repl
20:50:24 <eacameron> dmwit: Hahah well trying this `instance (forall a. Monoid (Func a) => Monoid a) => Filterable Func where` causes GHC to give me `Reduction stack overflow`
20:50:24 <eacameron> It's from witherable.
20:50:35 <unyu> jsomedon: it is right associative
20:50:40 <unyu> jsomedon: and you can check it using :i
20:50:44 <dmwit> Okay. You cannot write an instance of Filterable which only works on some element types.
20:50:45 <iqubic> jsomedon: it is right associative.
20:50:56 <dmwit> (Not even with QuantifiedConstraints turned on.)
20:50:58 <jsomedon> ah nice
20:51:00 <iqubic> Also, it has a very very low precedence, which is how it works.
20:51:03 <eacameron> dmwit: That's what I suspected.
20:51:19 <eacameron> Is there some way of constructing this class such that I could?
20:51:44 <iqubic> I don't think so.
20:52:03 <dmwit> eacameron: Yes. You could just copy the current source and put `a` as an argument to the class.
20:52:16 <unyu> wait, you can define constraints on quantified types?
20:52:16 <dmwit> eacameron: `class Functor f => Filterable f a where {- all the same as before -}`
20:52:38 <dmwit> unyu: No. You can write constraints that include quantification.
20:52:42 <iqubic> What does that allow you to do that you couldn't before?
20:53:06 <iqubic> I'm referring to abstracting out the 'a' as a type variable.
20:53:09 <dmwit> iqubic: It lets you write `instance Monoid a => Filterable MyFancyThing a where ...`, and say that you only work if the contained type is a `Monoid`.
20:53:15 <dmwit> For example.
20:53:21 <eacameron> dmwit: Oh I see. Yes that makes sense. Just make it a MPTC
20:54:20 <unyu> oh i was commenting on `instance (forall a. Monoid (Func a) => Monoid a) => Filterable Func where`
20:54:50 <eacameron> unyu: That causes GHC to crash so I think that means it's not supposed to work :P
20:54:54 <unyu> ah
20:54:57 <unyu> i'm not sure i ever understood any polymorphism that requires you to explicitly write your foralls
20:55:17 <dmwit> unyu: That syntax is cromulent (with the right extensions). It just doesn't mean what eacameron wanted it to mean.
20:55:23 <unyu> ah
20:55:36 <iqubic> Can you write: "instance (a ~ Int) => Filterable [a]"? Is that sort of constraint allowed, or not?
20:55:49 <eacameron> dmwit: well it means *more* than I wanted it to mean, I *think*. but it happens to work in my case since `Func a` is a monoid.
20:55:52 <dmwit> [a] has the wrong kind to be an instance of Filterable.
20:55:57 <iqubic> Actually, that the same as "Filterable [Int]"
20:56:01 <iqubic> dmwit: How so?
20:56:24 <dmwit> I... don't really know how to answer that. Filterable expects something of kind Type -> Type, but [a] has kind Type.
20:57:16 <eacameron> dmwit: Right I guess what I meant and what is possible with the definition of filterable are sort of two axes...
20:57:17 <dmwit> eacameron: I seriously doubt it means more than what you wanted it to mean.
20:57:39 <iqubic> Oh. So you can have "Filterable Maybe" or "Filterable (Either a)" or "Filterable ((->) r)"
20:57:45 <eacameron> yes
20:57:49 <iqubic> Right. Cool.
20:57:51 <iqubic> I see.
20:58:09 <eacameron> dmwit: Oh you mean for some *different* definition of `Filterable` it would have cromulent meaning.
20:58:23 <dmwit> I mean what I said: the *syntax* is cromulent.
20:58:29 <eacameron> Ah
20:58:59 <eacameron> In your proposed change to Filterable we don't even need quantified constraints.
20:59:04 <dmwit> correct
20:59:14 <isBEKaml> who uses the word 'cromulent' these days? :-)
20:59:25 <eacameron> cromulent folk
20:59:31 <dmwit> ...but you also get many fewer guarantees from parametricity.
20:59:35 <iqubic> cromulent is a weird word. Why not just say adequate or acceptable instead.
20:59:41 <eacameron> dmwit: yes I see....
21:00:10 <eacameron> iqubic: Neither of those words is nearly as cromulent
21:00:13 <eacameron> :P
21:00:45 <iqubic> eacameron: LOL.
21:02:09 <iqubic> :t ()
21:02:10 <lambdabot> ()
21:02:15 <iqubic> :t Proxy
21:02:16 <lambdabot> forall k (t :: k). Proxy t
21:02:24 <iqubic> Why is there a forall there?
21:02:46 <iqubic> Is that saying that the 't' in 'Proxy t' can have any kind at all?
21:03:19 <iqubic> So you can have a 'Proxy Maybe' or a 'Proxy Either' or a 'Proxy (Maybe Int)'?
21:04:20 <dmwit> Yes.
21:05:04 <iqubic> I see. I have no idea why 'Proxy Maybe' or 'Proxy Either' are useful ever.
21:05:27 <dmwit> Why is Proxy Int useful?
21:05:45 <iqubic> In fact, I barely know what Proxy is for, other than the way it's used in finite-typelits.
21:06:06 <iqubic> dmwit: I have no idea why Proxy Int is useful.
21:06:31 <iqubic> I think it's for stuff like Storeable, where you need to have a sizeof function.
21:06:47 <jsomedon> I am trying to make some sense of this code: `pure g <*> x1 <*> x2 <*> ... <*> xn`. Questions: 1. so `g` should be some function g::what-ever-in-x1 -> some-new-valu? 2. and this some-new-value :: whatever-in-x2 -> some-other-new-value, hence this some-new-value actually is a function??
21:07:10 <iqubic> Correct.
21:07:17 <iqubic> All of that is correct.
21:07:37 <jsomedon> thanks, this Applicative thing is certainly really interesting..
21:07:46 <iqubic> 'a -> (b -> c)' is the exact same as 'a -> b -> c'
21:08:11 <iqubic> 'a -> (b -> (c -> d))' is the exact same as 'a -> b -> c -> d'
21:08:58 <iqubic> That is how all of Haskell works. Nothing about function application changes when Applicative is introduced.
21:10:43 <jsomedon> so `pure` takes some value and returns a contaiend version, and `<*>` is essentially applying contained function over a contained function input and returns a contained function output
21:10:54 <jsomedon> ?
21:11:31 <iqubic> Yes. All of that is correct.
21:11:55 <jsomedon> thanks, now I really have to see why need such two new things..
21:13:07 <iqubic> What does 'pure' do for IO?
21:13:40 <iqubic> Does it just create an IO action that does no actual IO and just returns the input to pure?
21:14:26 <iqubic> That would be my guess at what it should do.
21:15:45 <c_wraith> that's what it does
21:16:32 <iqubic> I am good at using intuition and logic.
21:17:59 <c_wraith> it follows pretty directly from the laws, as long as you consider having different IO effects to mean that two IO values are different
21:21:41 <jsomedon> so looks like, using `pure` and `<*>` I can compose fmap-N on the fly
21:22:07 <c_wraith> yes.  That's basically the goal of Applicative.
21:22:14 <jsomedon> very cool stuff
21:22:18 <jsomedon> interesting
21:24:02 <jsomedon> the naming of <*> is kinda odd though. looks like I can not name my own function startign with character '<'
21:24:23 <HHaSKell> Hi, I am trying to implement the Writer monad as an exercise in a book and I'm getting stuck can someone help: https://pastebin.com/d4axrvF8
21:24:54 <c_wraith> jsomedon: you can, but it has to be defined using the infix operator syntax.
21:25:19 <c_wraith> > let a <<>>< b = a * b in 3 <<>>< 7
21:25:21 <lambdabot>  21
21:25:45 <jsomedon> uh
21:27:28 <jsomedon> this is odd, I tried this `l <<<<< r = "return value"` and it works, I tried this `l <a_infix_op> r = "return value of infix"` and it throws error
21:27:46 <c_wraith> infix operators can't contain letters or numbers
21:27:51 <jsomedon> oh
21:28:12 <c_wraith> or underscores or '  for what it's worth
21:28:56 <jsomedon> ok well * in <*> is not a letter or number neither so I can deal with that rule I guess :-/
21:29:16 <EvanR> but affirmative on unicode snowmen
21:29:25 <hoxtrop[m]> Enderton or Van Dalen?
21:31:28 <EvanR> > map isSymbol "!@#$%"
21:31:30 <lambdabot>  [False,False,False,True,False]
21:31:38 <EvanR> got it
21:32:59 <iqubic> Only $ is a symbol?
21:33:09 <iqubic> I did not know this.
21:33:56 <c_wraith> All of those can be used in operators
21:34:11 <c_wraith> The unicode Symbol class is not the haskell operator character class
21:34:36 <EvanR> it seems @ can't be used alone
21:35:08 <c_wraith> Yeah, it's syntax when used alone.  There are several other things like that.  like <- and -> aren't valid operators, even though they consist of only operator characters
21:36:13 <EvanR> custom operators are a critical aspect of haskell avoiding success at all costs. Many people hate custom operators
21:37:13 <EvanR> but i think the real problem is multi-character operators, those don't feel as cuddly as the kind you see on IQ test. Like diamond, heart, club
21:37:46 <EvanR> This wacky symbol on the `monus' page ∸
21:39:57 <iqubic> EvanR: Have you seen the hell that are the singletons infix defuctionalization symbols
21:39:59 <iqubic> ??
21:40:12 <iqubic> That shit is whack.
21:40:42 <EvanR> there better be single symbols for something called "defunctionalization"
21:41:15 <iqubic> No.
21:42:54 <iqubic> I'm talking about infix operators like this "&&@#@$" from the singletons library
21:43:56 <EvanR> well, APL does have fans
21:44:42 <EvanR> also i haven't heard a perl joke in a while
21:44:46 <iqubic> But that's in an actual Haskell library.
21:45:06 <iqubic> perl has so many features.
21:45:30 <EvanR> such as being implemented in haskell... almost
21:45:52 <iqubic> Wait... Is that true?
21:46:26 <c_wraith> Pugs (the first Perl 6 interpreter) was written in Haskell
21:46:59 <iqubic> Oh. Totally didn't know that.
21:58:38 <slack1256> Defunctionlization is a funny name for "command pattern"
22:09:43 <iqubic> It the command pattern?
22:41:34 <slack1256> Basically.
22:42:35 <slack1256> Instead of describing how to apply a generic function via a higher order function, you pass a "tag" which says which function to apply, and the higher order selects it and applies it.
22:43:39 <EvanR> it seems so basic why does it need a name. Like "dependency injection"
22:48:28 <slack1256> I still don't know what "dependency injection" is.
22:52:23 <EvanR> it's where your code depends on something, so you pass it in as a parameter
22:58:39 <slack1256> I guess in OOP further configuration via config functions can be called a pattern.
23:02:05 <iqubic> Correct
23:21:30 * hackage regex-tdfa 1.3.0 - Replaces/Enhances Text.Regex  https://hackage.haskell.org/package/regex-tdfa-1.3.0 (Artyom)
