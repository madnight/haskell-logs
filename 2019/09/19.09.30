00:29:00 * hackage traction 0.4.0 - Tools for postgresql-simple.  https://hackage.haskell.org/package/traction-0.4.0 (MarkHibberd)
01:44:53 <dminuoso> optparse-applicative, is there a way to have global flags and then subcommands? i.e. something like `foo -vv command command_args...`
01:46:19 <merijn> dminuoso: Eh, sure, you just do that?
01:47:08 <merijn> dminuoso: They just don't get listed in the help of the subcommand atm (sadly): https://github.com/pcapriotti/optparse-applicative/issues/294
01:47:55 <dminuoso> merijn: Ah
01:58:00 * hackage regex-pcre-builtin 0.94.6.8.8.35 - Replaces/Enhances Text.Regex  https://hackage.haskell.org/package/regex-pcre-builtin-0.94.6.8.8.35 (AudreyTang)
01:59:13 <merijn> So anyone with vim got ghcide working? I've got it working in the sense that it marks errors/warnings, but it doesn't actually update/set a quickfix list so I can't actually check what the error/warning is... >.>
02:00:28 <boxscape> maybe it's in the location list merijn?
02:02:19 <merijn> boxscape: No, both seem empty. There's a LSP command for opening a quickfix list, but it doesn't seem to persist them, which is a bit useless
02:07:30 * hackage mmsyn2 0.1.6.0 - The library that can be used for multiple (Ord a) => a -> b transformations  https://hackage.haskell.org/package/mmsyn2-0.1.6.0 (OleksandrZhabenko)
02:10:18 <cocreature> merijn: lsp takes care of shipping the diagnostics to your client. it’s up to whatever vim integration you’re using to display them in a reasonable way
02:17:18 <merijn> cocreature: I know that, hence my question who is using it so they can tell me whatever vim integration their using that does something sensible :p
02:19:34 <sshine> merijn, nope, I only tried the VSCode plugin.
02:21:26 <merijn> vim-lsp doesn't even seem to have a "jump to next warning", only "jump to next error" so that's doubly useless >.>
02:41:36 <boxscape> merijn coc.nvim as LSP client worked well for me when I tried it with haskell-ide-engine, though I haven't used it very much
02:42:23 <boxscape> Given the intention behind LSP you'd hope it would also work well with ghcide
02:43:05 <merijn> boxscape: I saw coc.vim, but it requires me to install a whole bunch of JS and node.js tooling just to be able to use it, so I immediately discarded it as a serious option
02:43:18 <boxscape> hm, I don't remember doing that. Maybe I did.
02:43:36 <merijn> boxscape: coc.vim is pretty explicitly all in JS
02:44:04 <boxscape> Oh yeah just looked at the readme, I did do that
02:44:04 <merijn> vim-lsp seems very lightweight, but also useless because it doesn't actually do anything I care about >.>
02:44:42 <merijn> Supposedly ALE functions as LSP client, so I'm trying if I can get that to work and if so I'll just ditch neomake
02:46:02 <sshine> merijn, maybe VSCode has some good vim bindings :P
02:46:29 <sshine> (I have to admit that VSCode and indentation is not as good as Emacs and haskell-mode, big sigh.)
02:46:32 <merijn> sshine: Nothing has good vim bindings, besides vim. More importantly, VSCode doesn't run in a terminal, so it's already disqualified on that
02:48:36 <maerwald> catchSTM cannot catch ErrorCall?
02:48:40 <boxscape> merijn LanguageClient-neovim also exists, in case you haven't seen it
02:49:17 <merijn> boxscape: Yeah, that requires me to install several neovim compat plugins and build via Rust, so that's my option of last resort :p
02:49:23 <boxscape> okay
02:58:30 * hackage hedn 0.3.0.0 - EDN parsing and encoding  https://hackage.haskell.org/package/hedn-0.3.0.0 (AlexanderBondarenko)
03:01:18 <hoppfull> is there a function for doing (if pred then (x :) else id) ?
03:02:04 <hoppfull> (if pred then (x : ) else id) without the space between the concat function and the bracket... ;)
03:02:23 <merijn> hoppfull: Looks you want to define my favourite helper function ever :p
03:02:38 <merijn> hoppfull: And as soon as I find a good name for it, I'll campaign for it to be added to base...
03:02:44 <hoppfull> merijn: hehe lol
03:02:45 <tdammers> hoppfull: protip: disable automatic emoji in your IRC client, most people can read (x :) just fine
03:02:50 <merijn> hoppfull: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/src/Core.hs#L129-L132
03:02:51 <int-e> ([x | pred] ++)
03:03:05 <hoppfull> int-e: cool beans!
03:03:09 <merijn> hoppfull: Then it becomes "mIf pred [x]"
03:03:26 <merijn> Well, not quite, but that approach is far more generic
03:04:28 <merijn> boxscape: ALE seems to be working after some prodding, so \o/
03:41:03 <boxscape> ah, good to know. Maybe I'll take a look at the next time I'm using LSP
03:41:55 <boxscape> (actually merijn just quit so never mind)
03:42:30 * hackage simple-cabal 0.1.0 - Cabal file wrapper library  https://hackage.haskell.org/package/simple-cabal-0.1.0 (JensPetersen)
03:46:43 <Ariakenom> % atomically $ catchSTM (error "slipped") ((\_ -> pure "caught") ::  ErrorCall -> STM String)
03:46:44 <yahb> Ariakenom: "caught"
03:47:15 <Ariakenom> maerwald: Hm. What do you mean?
03:49:48 <maerwald> Ariakenom: issues with laziness...
03:50:49 <Ariakenom> allright
04:32:22 <boxscape> Does the current implementation of Rank2Types also admit rank 3 types etc? Manual says it's a synonym for RankNTypes
04:32:38 <boxscape> s/synonym/alias
04:33:49 <lyxia> yeah it's just RankNTypes
04:33:56 <boxscape> okay
04:33:56 <Ariakenom> boxscape: iirc you can implement rank n if you have rank 2
04:34:07 <boxscape> ah, interesting
04:34:26 <Ariakenom> so it's implied 
04:34:46 <merijn> Not really
04:35:03 <Ariakenom> merijn: clearly mIf should be called whenM :p
04:35:20 <merijn> Rank2Types exists as a separate extension because (theoretically) GHC could implement type inference for Rank2
04:35:22 <boxscape> someone (might have been merijn) said a while ago that rank 2 type inference is in principle possible but not rank n type inference
04:35:28 <boxscape> ah there we go :)
04:35:37 <merijn> At the moment Rank2 inference is not a thing, so Rank2Types simply enables RankNTypes
04:35:44 <Ariakenom> I see
04:36:28 <Ariakenom> I will correct my recollection
04:36:46 <merijn> Ariakenom: whenM seems to imply something monadic, so I think it's a poor name
04:37:05 <merijn> Ariakenom: mwhen would be better/more consistent with mconcat/mappend/mempty (or mif, I suppose)
04:37:53 <Ariakenom> merijn: yes M is monadic and when is already monadic. which I found funny for some reason
04:52:36 * jgt begins flooding source with mifs
04:53:01 * hackage unpacked-maybe-numeric 0.1.1.0 - maybes of numeric values with fewer indirections  https://hackage.haskell.org/package/unpacked-maybe-numeric-0.1.1.0 (andrewthad)
04:54:08 <merijn> jgt: I keep finding more and more uses for that function :)
04:54:30 * hackage regex-pcre 0.95.0.0 - PCRE Backend for "Text.Regex" (regex-base)  https://hackage.haskell.org/package/regex-pcre-0.95.0.0 (HerbertValerioRiedel)
04:54:53 <Ariakenom> oo I want examples
04:55:31 * hackage mergeful 0.1.0.0 -   https://hackage.haskell.org/package/mergeful-0.1.0.0 (Norfair)
04:56:30 * hackage genvalidity-mergeful 0.1.0.0 -   https://hackage.haskell.org/package/genvalidity-mergeful-0.1.0.0 (Norfair)
04:56:53 <boxscape> I've wanted that function so many times
04:58:12 <merijn> Ariakenom: from/to here are specialisations of it: https://github.com/haskell/cabal/blob/master/Cabal/Distribution/Simple/Program/GHC.hs#L54-L286
04:58:58 <merijn> Ariakenom: It's very convenient for "specify a bunch of things in one place, but make an element easy to filter out"
04:59:52 <merijn> Ariakenom: I use it a lot for pretty printing (https://github.com/merijn/GPU-benchmarks/blob/ddcaf39fa5bf06104c7c04fef892522fc03855a1/benchmark-analysis/src/OptionParsers.hs#L99, https://github.com/merijn/GPU-benchmarks/blob/d79ee962a0206fd41895dcdcd14c8047d9203d59/benchmark-analysis/model-src/Evaluate.hs#L395)
05:01:31 <boxscape> hm, since it has two parameters it might possibly make sense to define an operator for it
05:01:42 <boxscape> something like (?>) alluding to (<>)
05:02:33 <boxscape> although actually I don't like that
05:02:48 <boxscape> makes it look too much like there's supposed to be Monoid-like arguments on both sides
05:14:22 <Ariakenom> merijn: nice. from was an interesting Endo example
05:27:30 * hackage bytesmith 0.3.0.0 - Nonresumable byte parser  https://hackage.haskell.org/package/bytesmith-0.3.0.0 (andrewthad)
05:28:19 <wen> does anyone here know how to make emacs' haskell-mode work with cabal's new-build?
05:31:30 * hackage scientific-notation 0.1.0.1 - Scientific notation intended for tokenization  https://hackage.haskell.org/package/scientific-notation-0.1.0.1 (andrewthad)
05:34:00 * hackage json-tokens 0.1.0.1 - Tokenize JSON  https://hackage.haskell.org/package/json-tokens-0.1.0.1 (andrewthad)
05:37:30 * hackage socks 0.6.1 - Socks proxy (ver 5)  https://hackage.haskell.org/package/socks-0.6.1 (VincentHanquez)
05:41:00 * hackage massiv-test 0.1.1 - Library that contains generators, properties and tests for Massiv Array Library.  https://hackage.haskell.org/package/massiv-test-0.1.1 (lehins)
05:48:00 * hackage bulletproofs 1.1.0 -   https://hackage.haskell.org/package/bulletproofs-1.1.0 (sdiehl)
05:55:00 * hackage ip 1.6.0 - Library for IP and MAC addresses  https://hackage.haskell.org/package/ip-1.6.0 (andrewthad)
06:18:16 <boxscape> given that ghc is the only haskell compiler that's widely used, is there any pragmatic consequence to defining a new haskell standard?
06:18:29 <boxscape> (aside from having to write fewer LANGUAGE pragmas)
06:18:58 <voyons_osti> it would affect anybody else writing a haskell implementation
06:19:29 <__monty__> I think the problem's mostly a single implementation doesn't need a standard.
06:19:41 <tdammers> __monty__: it does.
06:19:47 <tdammers> __monty__: cf PHP
06:20:18 <__monty__> What do you mean? A single implementation defines it's de facto standard operationally.
06:20:19 <tdammers> the problem with not having a specification is that you can't tell bugs from features, and you don't really know whether any given behavior is supposed to be stable
06:20:39 <tdammers> point is, "single implementation" becomes a lie the moment you release the second version
06:20:57 <dminuoso> Also the lack of a standard widens the gap of other implementations than GHC arising.
06:21:03 <__monty__> I'm not saying a spec wouldn't be good. I'm saying no one wants to bother and the incentive's pretty low if there's only one implementation.
06:21:22 <tdammers> yes, but that doesn't mean it's not needed. just that we can make do without one
06:21:30 * hackage unpacked-maybe-text 0.1.0.0 - optional text that unpacks well  https://hackage.haskell.org/package/unpacked-maybe-text-0.1.0.0 (andrewthad)
06:23:22 <sshine> I guess it's like backups.
06:23:36 <sshine> and health insurance. you don't need it until you do. :)
06:24:58 <mycroftiv> i think there are huge benefits to not having the in practice definition of the language be 'whatever version x.x.x of GHC does
06:26:37 <boxscape> such as?
06:26:41 <mycroftiv> to some extent it seems fundamentally incompatible with a lot of the motivations of using a functional language and strong types to pursue software correctness. in practice i want a given piece of source code to be bugfree relative to a defined standard
06:27:05 <boxscape> that does sound reasonable
06:27:12 <mycroftiv> rather than 'works only with a specific version of the compiler and toolchain'
06:30:00 * hackage smith 0.1.0.0 - Parse arrays of tokens  https://hackage.haskell.org/package/smith-0.1.0.0 (andrewthad)
06:33:35 <maerwald> mycroftiv: I think correctness was never the main goal of haskell, it was functional programming and laziness. F* has "correctness" as main goal, Idris maybe.
06:34:19 <maerwald> And there isn't that much community drive towards "clean up the standard already"
06:37:50 <mycroftiv> maerwald: well, i guess i take the view that 'correctness' is inherently a goal of writing any software. how you achieve 'software that works' has a lot of options, but i dont think anyone likes it when a program doesnt run/compile and just returns an error message
06:40:15 <maerwald> well, with unspecified evaluation order, you already don't know what exceptions you get :>
06:40:58 <maerwald> I would argue laziness and correctness contradict at a sufficiently detailed level of view
06:41:29 <mycroftiv> well, i didnt mean 'formally proved correctness' - i just meant well-behaved and usable in practice
06:42:27 <mycroftiv> i want to download code and compile it and have it do the thing it says it does, and i want to write code that works for other people this way, and that they can download in 5 years and it still works the same way
06:43:41 <Ariakenom> unspecified doesn't get in the way of correct
06:43:56 <mycroftiv> for all the problems with C, the ansi c 89 standard as described in k&r 2nd ed is an amazing example of how a relatively consistent and stable base provides tremendous practical benefit of portability and long term use. i regularly grab random 90s code and it compiles and runs fine
06:44:27 <maerwald> last time C standard was discussed here I remember that it doesn't even specify what a pointer is :>
06:44:47 <mycroftiv> this is agreeing with your overall point that practical value doesnt depend on formally proved guarantees necessarily
06:44:48 <maerwald> so not sure you want to pick that as a good example
06:45:06 <mycroftiv> my point was not that the standard is well written or that c is a great language necessarily
06:45:33 <mycroftiv> i was pointing out that DESPITE the problems with c and the ansi standard, the fact of HAVING any kind of common standard provided practical benefits that we can still reap right now
06:45:44 <maerwald> and, in e.g. automative industry, you don't compile code that is 5 years old with an old C compiler, because you have no idea what it will do at runtime =)
06:47:00 <maerwald> My point is: better no standard than a poor one. And I like to believe the haskell people have high "standards"
06:47:39 <mycroftiv> people did a great job with haskell 98 overall i think
06:49:19 <mycroftiv> and due to this i often have good luck using hugs 2006 and haskell 2000x vintage code, its much simpler to deal with than managing stack-cabal-ghc versions
06:51:39 <tdammers> stack is a train wreck that way... IME, whatever stack snapshot you pick at first is what you will be using through the project's lifecycle, at least until the next major rewrite
06:52:29 <maerwald> so, just use cabal freeze and update every month :)
06:53:29 <maerwald> sad we don't really have visibility on security vulnerability patches, but theoretically, every bug could be one
06:53:41 <tdammers> yes
06:54:04 <tdammers> equally sadly, we don't have anywhere near the manpower to really distinguish security patch releases from feature releases on hackage
06:54:26 <tdammers> for almost all packages, it's either "take all the patches, security and feature, or take none of them"
06:57:10 <merijn> Man...why do tools like ghcide always have such a confusing/convoluted control flow :(
06:57:52 <merijn> I'm trying to figure out where I can patch/experiment with some trivial thing, but I can't figure out where >.>
07:03:57 <__monty__> tdammers: I think that's another reason for a lack of standard. The number of people knowledgeable enough about GHC is small enough that writing up a standard would be to the detriment of many developments.
07:04:37 <tdammers> yes, that too
07:04:56 <tdammers> essentially, we all have better things to do than publish a Haskell Report
07:06:02 <[exa]> standards cost serious amounts of money and effort. you can reimagine writing of standards as an investment
07:06:06 <__monty__> I'm not sure I do so the obvious conclusion is I should write up a Report and then everyone else should work towards implementation the standard set by that report >: )
07:06:16 <__monty__> *implementing
07:09:58 <tdammers> it's also not obvious whether a standard should reflect the de facto reality, or whether it should set goals for future implementations
07:12:26 <__monty__> I think Haskell' kinda takes both approaches simultaneously?
07:12:31 <maerwald> standards that evolve based on implementations usually end up poor imo. The implementation should follow the standard
07:14:48 <__monty__> maerwald: GHC does stand out as being pretty backwards compatible though. At least in my limited experience.
07:15:10 <tdammers> problem is, standards that try to set the goals usually end up unrealistic, without a single correct implementation ever being written
07:15:20 <tdammers> even the Haskell Report suffers from that
07:15:43 <tdammers> not even GHC implements Haskell 2010 completely and correctly
07:15:46 <__monty__> Because of Layout?
07:15:52 <tdammers> many things, actually
07:15:53 <merijn> __monty__: Because of a bunch of things
07:16:02 <merijn> __monty__: No Eq/Show superclasses on Num
07:16:11 <merijn> __monty__: Incorrect handling of some unicode edge cases
07:16:44 <tdammers> also, only one module per file allowed D:
07:17:25 <maerwald> well, standards don't need to be published in 10 years step only and can have smaller adjustments. I think it's more problematic to wait too long and then have huge expectations to include all sorts of implementation-specific features
07:17:56 <merijn> cocreature: ping?
07:19:57 <Ariakenom> tdammers: those issues don't sound unrealistic. But there are other standards with that issue. Like C99
07:20:06 <cocreature> merijn: pong
07:21:59 <tdammers>  Ariakenom: sure, Haskell is definitely not alone.
07:22:00 <merijn> cocreature: I've been digging through the ghcide source to solve an issue I'm running into, but I'm getting *horribly* lost trying, I was wondering if you've got some pointers where I should be
07:22:36 <merijn> cocreature: Specifically, I'm not happy with the diagnostic output it produces, but I can't for the live of me figure out where those are produced and turned into LSP messages...
07:23:23 <merijn> I tried tracing the control flow, but as soon as I hit Shake I'm completely lost wrt what's going on
07:23:29 <cocreature> merijn: sounds like you probably want to look at `typecheckModule`
07:28:24 <merijn> cocreature: hmm, maybe, the warnings seem to already have been created elsewhere by then, perhaps withWarnings is what I want
07:28:41 <kqr> I'm looking for basically this: case ma of { Just x -> JNothing;  Nothing -> Just d } does this function exist/is it easy to conjure combinatorically or am I left with the pattern match as the best option?
07:29:03 <merijn> cocreature: Do you know if there's any specific reason why the choice was made to keep the filepath, line no and severity inside the diagnostic?
07:29:05 <kqr> sorry about the formatting burp. JNothing should be Nothing
07:29:23 <cocreature> merijn: no that keeps annoying me as well but so far not enough to fix it :)
07:29:36 <cocreature> merijn: I’m not sure if GHC exposes the error without that
07:29:42 <cocreature> it’s been ages since I’ve looked at that code
07:30:04 <merijn> cocreature: Sure, but is should be trivial to strip off, no?
07:30:28 <merijn> I said in all my naivety >.>
07:30:34 <fpnewbie404> Hi there. How do you unpack a list of tuples consisting of a string and another list of tuples? I am interested in the inner list of tuples.
07:30:48 <cocreature> merijn: dunno? I’m not quite sure how consistent GHC is here
07:31:21 <dmwit> fpnewbie404: map snd?
07:31:45 <merijn> cocreature: I suppose worst case scenario it breaks for people who have colons in their paths >.>
07:32:23 <fpnewbie404> dmwit: Forgot to mention that it should be done without using map or higher order list functions
07:32:39 * jgt smells fresh homework
07:35:48 <fpnewbie404> jgt: Yup, that's what it is :)
07:36:35 <heatsink> Can you show a specific example of a 2-element list and the result the algorithm should produce for that example?
07:37:00 <jgt> fpnewbie404: I suspect given that it's homework, and that you're meant to try it yourself so you can learn properly, I think you won't get much more from people here than "try using pattern matching and recursion"
07:37:02 <merijn> cocreature: I'll go mess around with this, if I figure out how to filter it out I'll tag you on the github issue on how to figure out how to connect that back into the ghcide code (presumably this would/should be behind a commandline flag)
07:37:47 <cocreature> if it’s not too hacky I’d be fine with turning it on by default and not exposing a flag to change it
07:38:49 <maerwald> haskell as homework? gross
07:38:51 <merijn> cocreature: Knowing these kinds of tools, I suspect things might not be so clean >.>
07:39:24 <maerwald> homework kills the fun of whatever you're doing :P
07:39:26 <merijn> cocreature: I doubt anyone remembered to include a "don't report line numbers or columns in error messages" flag in GHC >.>
07:40:36 <cocreature> merijn: there will soon be a proposal (not from me) for structured error messages in the GHC API which should help with this
07:43:59 <merijn> The main problem is that I have no idea how you'd even test how consistent GHC is in terms of warning output >.>
07:44:55 <merijn> OTOH the "upgradeWarningToError" code is also pretty...hacky >.>
07:49:02 * shapr hops cheerfully
07:50:32 <trcc> How does not create a field in a record called id? I get ambiguous due to Prelude.id and other stuff. What's the trick_
07:51:19 <dminuoso> Any tips how I can restructure this chunk of ugly code? https://gist.github.com/dminuoso/14d9e3ed5fcf131b45e9b345bf3a7b86
07:51:39 <merijn> trcc: "import Prelude hiding (id)", but then you can't use the regular "id" anymore
07:51:51 <trcc> merijn: okay thanks
07:51:59 <trcc> Will choose different name ;)
07:52:40 <merijn> trcc: Well, actually, you can define and use both, but you'll have to do so qualified
07:52:50 <merijn> trcc: i.e. "Prelude.id" and "MyModule.id" everywhere
07:53:06 <trcc> Might due in a future update. For now, renaming is easier
07:53:24 <[exa]> dminuoso: can you sink the 'if verbosity>1' a bit inside the code to avoid repeating Pool.withResource part?
07:54:00 * hackage QuickCheck-GenT 0.2.1 - A GenT monad transformer for QuickCheck library.  https://hackage.haskell.org/package/QuickCheck-GenT-0.2.1 (NikitaVolkov)
07:54:11 <dminuoso> [exa]: Well sure. It's rather that the rest is convoluted and hard to read.
07:54:18 <[exa]> dminuoso: also I think there was a shortcut for 'accessor <$> ask', perhaps lens-ish
07:54:45 <dminuoso> [exa]: well sure, if I had lenses I could just do `pool <- envConnPoolL`
07:55:00 * hackage monad-resumption 0.1.4.0 - Resumption and reactive resumption monads for Haskell.  https://hackage.haskell.org/package/monad-resumption-0.1.4.0 (IanGraves)
07:55:07 <dminuoso> (Where envConnPoolL is an appropriate `Lens' Env (Pool Connection)`)
07:55:13 <[exa]> dminuoso: the 'setTrace ... >>' can be converted to  do { when ... setTrace ...; the rest }
07:55:42 <[exa]> dminuoso: also \conn -> getTransaction conn ... is flip getTransaction $ do ...
07:56:00 <[exa]> (oh, s/get/with/ )
07:56:01 <dminuoso> [exa]: Nope, because I need to feed the conn into the action
07:56:08 <dminuoso> (And the setTrace needs it too)
07:56:47 <dminuoso> [exa]: The thing is, Ive tried moving it with `when` inside, but that turned it all even more unreadable.
07:56:53 <dminuoso> Perhaps I need to decompose more into continuations.
07:56:54 <[exa]> it seems reader-able
07:57:53 <dminuoso> Know what, I think I have an idea. I could rig my own withResource wrapped inside withRunInIO, that would get rid of at least one continuation.
08:01:00 * hackage dimensions 2.1.0.0 - Safe type-level dimensionality for multidimensional data.  https://hackage.haskell.org/package/dimensions-2.1.0.0 (achirkin)
08:02:01 * hackage easytensor-vulkan 2.0.2.0, easytensor 2.1.0.0 (achirkin): https://qbin.io/indie-swim-xehw
08:15:29 <merijn> cocreature: btw, I was trying to see if I could turn your and Neil's advice here https://github.com/digital-asset/ghcide/issues/113 into some workable setup, but tbh I still don't understand what hie-bios/ghcide expect me to provide to be able to function
08:16:19 <cocreature> merijn: add a direct-style cradle and generate a .ghc.environment file and things should work
08:17:53 <merijn> cocreature: Yeah, but I don't understand what "adding direct-style cradle" entails. I mean, I see there's a "direct" key in this hie.yaml thing, but no clue what's supposed to go in there...
08:24:16 <cocreature> merijn: the list of arguments required to load your project, i.e., mostly include dirs
08:34:06 <merijn> hmmm, apparently not that straightforward as I mostly get A LOT of crashes from within ghc/ghci >.>
08:34:32 <merijn> Anyway, I have to go home, I'll try and figure out where it's dying later tonight
08:36:53 <leela> can anyone help to solve below problem.
08:37:19 <leela> 1. Define a function dropOdds :: Int -> Int with the following behaviour.
08:37:41 <maerwald> it's homework time again?
08:38:20 <leela> maerwald can you try?.
08:38:31 <maerwald> too hard, what have you tried so far? ;)
08:39:52 <leela> my question is how to ignore a number with doing nothing.
08:40:12 <maerwald> "with the following behavior"
08:40:56 <leela> can i put my code here?. i am new to  freenode.
08:41:01 <maerwald> use a pastebin
08:41:13 <maerwald> @where pastebin
08:41:13 <lambdabot> http://rafb.net/paste
08:41:20 <maerwald> great
08:41:50 <maerwald> https://paste.ubuntu.com/
08:43:36 <fresheyeball> hey out there
08:43:52 <fresheyeball> so I would like to model things like image sliders
08:44:03 <fresheyeball> they have a "next" and "prev" operation
08:44:25 <fresheyeball> and sometimes that means looping and sometimes it doesnt
08:48:39 <dmj`> sounds like a state machine
08:48:53 <jgt> anyone know how to run an AuthHandler from a Handler in a Yesod app?
08:49:32 <jgt> or, what I *actually* want to do is use a URL like /login instead of /auth/page/simple/login
08:50:51 <leela> 1. Define a function dropOdds :: Int -> Int with the following behaviour.
08:52:00 <jgt> leela: the first thing here is that the name "dropOdds" would suggest there's more than one odd
08:52:17 <jgt> leela: this is at odds (haha!) with the type signature you have provided
08:52:26 * shapr grins
08:53:04 <jgt> leela: your type signature says `dropOdds` takes one Int, and produces one Int.
08:53:40 <nil> we're still waiting for the part after "the following behaviour"
08:55:02 * jgt patiently waits for the following behaviour
09:17:30 * hackage haddock 2.23.0 - A documentation-generation tool for Haskell libraries  https://hackage.haskell.org/package/haddock-2.23.0 (harpocrates)
09:19:00 * hackage haddock-library 1.8.0, haddock-api 2.23.0 (harpocrates): https://qbin.io/alike-charts-anib
09:22:45 * jgt is investigating Network.Wai.Middleware.Rewrite
09:44:30 * hackage vinyl 0.12.0 - Extensible Records  https://hackage.haskell.org/package/vinyl-0.12.0 (AnthonyCowley)
10:00:30 * hackage hkgr 0.2.3 - Simple Hackage release workflow for package maintainers  https://hackage.haskell.org/package/hkgr-0.2.3 (JensPetersen)
10:16:30 * hackage hkgr 0.2.3.1 - Simple Hackage release workflow for package maintainers  https://hackage.haskell.org/package/hkgr-0.2.3.1 (JensPetersen)
10:30:00 * hackage string-fromto 1.0.0.0 - Conversions between common string types, as well as Base16/Base32/Base64.  https://hackage.haskell.org/package/string-fromto-1.0.0.0 (patrick)
10:44:00 * hackage hkgr 0.2.3.2 - Simple Hackage release workflow for package maintainers  https://hackage.haskell.org/package/hkgr-0.2.3.2 (JensPetersen)
10:46:30 * hackage hkgr 0.2.3.3 - Simple Hackage release workflow for package maintainers  https://hackage.haskell.org/package/hkgr-0.2.3.3 (JensPetersen)
11:27:00 * hackage servant-errors 0.1.3.0 - Servant Errors wai-middlware  https://hackage.haskell.org/package/servant-errors-0.1.3.0 (epicallan)
11:31:30 * hackage regex-pcre-builtin 0.95.0.8.8.35 - Replaces/Enhances Text.Regex  https://hackage.haskell.org/package/regex-pcre-builtin-0.95.0.8.8.35 (AudreyTang)
12:28:51 <Guest_33> how to i download the ghcup on map
12:29:08 <Guest_33> https://get-ghcup.haskell.org
12:29:15 <Guest_33> what do i do with this link?
12:32:29 <dmwit> Guest_33: https://www.haskell.org/ghcup/ has instructions
12:33:06 <Guest_33> it says run the following on your terminal
12:33:12 <Guest_33> i didnt understand what to do
12:33:31 <dmwit> Open your terminal first.
12:33:56 <Guest_33> done that
12:33:58 <dmwit> Mac has like an "Apps" folder or something, right? I think under "Utilities" or so is the terminal.
12:34:13 <Guest_33> and paste this https://get-ghcup.haskell.org ?
12:34:19 <dmwit> Then type (or copy and paste) the text into your terminal and press enter.
12:34:22 <merijn> dmwit: Or just "command + space" -> type "terminal"
12:35:03 <dmwit> No, don't paste https://get-ghcup.haskell.org; instead paste the text shown on haskell.org/ghcup.
12:35:11 <Guest_33> found it now thaanks
12:35:23 <dmwit> ...ok
13:11:00 * hackage brittany 0.12.1.0 - Haskell source code formatter  https://hackage.haskell.org/package/brittany-0.12.1.0 (lspitzner)
14:03:17 <trcc> I am looking for a behaviour such as case params of [(pack "n", n), (pack "l",l)] :: [(Text,Text)] -> ...
14:03:22 <trcc> is there any way to achieve this behaviour?
14:05:07 <merijn> trcc: You mean besides writing it out?
14:05:12 <merijn> Not really, tbh
14:05:21 <trcc> merijn: what do you mean writing it out?
14:05:45 <trcc> I was hoping that it was allowed to write [(pack "n", n), (pack "l",l)] in the pattern match clause, but it does not seem to be the case
14:05:46 <merijn> trcc: Well, what exactly is wrong about your example?
14:06:03 <merijn> trcc: pack is not a constructor
14:06:21 <trcc> TL.pack then
14:06:26 <merijn> trcc: But if you enable OverloadedStrings and get rid of the pack it should just work
14:06:32 <trcc> import qualified Data.Text.Lazy as TL
14:06:34 <merijn> trcc: TL.pack is not a constructor either
14:06:45 <trcc> ah no, it is a function form string to text
14:06:59 <trcc> I have overloaded strings already
14:07:15 <trcc> oh woaw
14:07:18 <trcc> I fucked up somewhere
14:07:19 <trcc> works now
14:07:20 <merijn> trcc: :)
14:07:24 <trcc> sorry thank you :)
14:08:30 * hackage regex-posix-clib 2.7 - "Regex for Windows" C library  https://hackage.haskell.org/package/regex-posix-clib-2.7 (HerbertValerioRiedel)
14:34:44 <vaibhavsagar> is there a MonadCatch implementation for writert-cps-mtl?
14:55:29 <alephu5[m]> Does anyone have any experience using the resource pool package or any of its forks?
14:55:30 <alephu5[m]> http://hackage.haskell.org/package/resource-pool
14:55:30 <alephu5[m]> I've noticed that a lot of libraries use it even though it's not maintained any more.
14:58:51 <dminuoso> [exa]: Turns out the solution was to address the underlying issue, namely that sqlite-simple isn't MonadUnliftIO polymorphic: https://gist.github.com/dminuoso/8e849f5ec84c21a7622a00142ec0fd8c
14:59:00 * hackage ghc-events 0.10.0 - Library and tool for parsing .eventlog files from GHC  https://hackage.haskell.org/package/ghc-events-0.10.0 (MitsutoshiAoe)
15:01:59 <[exa]> dminuoso: `instrumented' is my new favorite wrapper word :]
15:02:12 <[exa]> dminuoso: anyway the code looks great
15:17:00 * hackage regex-posix 0.96.0.0 - POSIX Backend for "Text.Regex" (regex-base)  https://hackage.haskell.org/package/regex-posix-0.96.0.0 (HerbertValerioRiedel)
15:24:15 <dminuoso> Mmm, Im using sqlite-simple and calls into executeNamed just appear to hang inside sqlite whenever there's an apparent error inside sqlite.
15:24:30 <dminuoso> The code is compiled with fno-omit-yield
15:24:31 * hackage hw-prim 0.6.2.34 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.6.2.34 (haskellworks)
15:59:30 * hackage regex-compat 0.95.2.0 - Replaces/Enhances "Text.Regex"  https://hackage.haskell.org/package/regex-compat-0.95.2.0 (HerbertValerioRiedel)
17:54:00 * hackage serverless-haskell 0.9.0 - Deploying Haskell code onto AWS Lambda using Serverless  https://hackage.haskell.org/package/serverless-haskell-0.9.0 (AlexeyKotlyarov)
18:08:30 * hackage hz3 96.0.0.0 - Bindings for the Z3 Theorem Prover  https://hackage.haskell.org/package/hz3-96.0.0.0 (MatthewFarkasDyck)
18:25:18 <kirill> hi all, is this the right place to ask questions about Stack?
18:26:30 * hackage asif 6.0.3 - Library for creating and querying segmented feeds  https://hackage.haskell.org/package/asif-6.0.3 (arbornetworks)
19:18:30 * hackage stripe-concepts 1.0.2.0 - Types for the Stripe API  https://hackage.haskell.org/package/stripe-concepts-1.0.2.0 (chris_martin)
19:19:30 * hackage stripe-wreq 1.0.1.0 - Use the Stripe API via Wreq  https://hackage.haskell.org/package/stripe-wreq-1.0.1.0 (chris_martin)
19:34:30 * hackage constraints-extras 0.3.0.2 - Utility package for constraints  https://hackage.haskell.org/package/constraints-extras-0.3.0.2 (abrar)
19:57:09 <Squarism> whats the language extension that lets you define a typeparameterized datatype but dont include the argument in its type but only constructor?
19:58:08 <monochrom> ExistentialQuantification
19:58:49 <Squarism> thanks
19:59:34 <maerwald> dark path :P
20:01:11 <monochrom> Yeah, gives you a feeling of the trailer of The Rise of Skywalker in which Rey wears a Sith hoodie and wields a Sith double-blade weapon...
20:02:56 <hoxtrop[m]> I suck at first order logic. How do I get a feel for the operations? I get it when one uses the existential quantifier. But convert all of those into ¬∀¬ and I'll be scratching my head.
20:03:32 <monochrom> I like the two-person-game semantics for this. Works for both logic and types.
20:04:01 <monochrom> Like this: http://vex.net/~trebla/weblog/any-all-some.html
20:05:39 <maerwald> monochrom: that's a very... specific analogy
20:05:48 * maerwald goes watching the trailer
20:07:05 <monochrom> We need to cap that picture and add the text "when Rey learns ExistentialQuantification" and it will become a meme.
20:07:52 <monochrom> Bonus points if the text is "when Rey learns DataKinds PolyKind TypeInType"
20:09:26 <EvanR> i missed the part where this analog like... needs to be made
20:09:42 <monochrom> Anyway, suppose I give you a value of type "forall a. a -> a".  You get to choose what to plug into "a".  I don't.  In general, with "forall", the receiver chooses, the giver doesn't.
20:09:43 <EvanR> existential quantification is dark? 
20:09:58 <monochrom> <monochrom> Yeah, gives you a feeling of the trailer of The Rise of Skywalker in which Rey wears a Sith hoodie and wields a Sith double-blade weapon...
20:10:06 <EvanR> like -XForceChoke
20:10:19 <EvanR> yeah, why
20:10:57 <EvanR> WHY IS THIS THE DARK PATH
20:11:04 <monochrom> "exists" is opposite.  If I give you a value of type "exists a. (a, a->Int)", I get to choose what "a" I use, you don't.
20:11:16 <Squarism> maerwald, yeah I guess. But say you have DSL for a deep nested form and want users of the DSL to be able to atleast provide their own sets of enums. I cannot see any other way than Ex.Qu to achive that
20:11:50 <Squarism> or, enums = alternatives
20:13:04 <EvanR> there's nothing ExistentialQuantification can do that GADTs can't also do
20:15:43 <Squarism> Well I see typesignatures that are pages long. Ill atleast try this path for POCing
20:17:18 <EvanR> Um I think I meant to say GADT syntax + RankN types
20:17:26 <monochrom> Now let's use this to unravel what happens to "(forall a. (a, a->Int)) -> Int".  I give you a value of that type.  You receive it, and you use it by giving me a value of type "forall a. (a, a->Int)".  I receive that, I receive a "forall", so I the receiver chooses "a".
20:17:50 <monochrom> So overall it works as an existential because I end up being the one to choose "a".
20:19:34 <monochrom> The overarching theme is that "->" flips the giver-receiver roles in the domain.
20:21:46 <Squarism> thanks. ill add some type constraints to it for now - but i promise ill check out if GADT and RankN does the work better
20:22:25 <EvanR> it's basically equivalent
20:39:00 * hackage serverless-haskell 0.9.1 - Deploying Haskell code onto AWS Lambda using Serverless  https://hackage.haskell.org/package/serverless-haskell-0.9.1 (AlexeyKotlyarov)
21:05:20 <monty> quit
21:05:30 <Axman6> never!
21:07:21 <EvanR> continue
21:07:38 <Axman6> Hello, World!
21:09:55 <heatsink> goto 10
21:10:50 <Axman6> this reminds me of a 4chan thread, trying to write a Java program collectively. started with class Main {
21:10:51 * EvanR looks very far with a telescope to try and see where 10 is in this channel
21:10:59 <Axman6> ended with immediately with }
21:11:12 <heatsink> haha
21:11:29 <EvanR> wasn't this one of the first channels on freenode
21:12:10 <Axman6> not sure about first, certainly one of the largest for a very long time though
21:12:13 <jle`> this channel predates freenode
21:12:23 <jle`> they actually built freenode on the site of this channel in hyperspace
21:12:45 <Axman6> they really needed that fourth dimension, quite impressive with the technology of the day
21:13:17 <Axman6> I just realised I've probably been in this channel for something like 10 years, that's crazy
21:13:35 <jle`> i think i've been here for like seven?
21:14:10 <EvanR> i'm pretty sure you both lost track of time
21:16:00 <EvanR> (you were both est here when i showed up prob 10 years ago)
21:16:31 <Axman6> I would've joined in the first half of 2008 when I was in first year uni learning Haskell
21:17:33 <nshepperd2> Whenever i see the word 'predates' i think of something devouring prey
21:17:34 <heatsink> That's around when I joined, I think
21:17:54 <nshepperd2> This channel devours freenode
21:18:16 <jle`> i lost my initial logs from when i first joined because i changed irc clients and wiped the logs for some reason, but checking my haskell projects records i've been here since 2013
21:18:24 <jle`> so actually 6 years :O
21:18:47 <Axman6> Someone at work shared this with me (in russian but google translate does a great job): https://habr.com/ru/post/469441/ jesus Go is crazy. I thought concurrency was supposed toi be easy
21:19:01 <heatsink> I started in the python channel before I came to haskell
21:19:10 <heatsink> and a python is a predator
21:19:16 * Axman6 is now depressed at how much more influence jle`has had on the comunity in less time -_-
21:19:31 <heatsink> so it makes sense that my presence there predates my presence here
21:19:45 <mycroftiv> its like a black hole, i started on freenode in 2005 and gradually over time the gravitational field of the #haskell channel warped my orbit until it finally pulled me in a few months ago
21:20:00 <Axman6> ha
21:20:18 <Axman6> yeah I've been on freenode for at least 5 years lonmger than I was in here, mostly in #macosx
21:20:25 <MarcelineVQ> mycroftiv: but, you've always been here
21:21:01 <jle`> i don't have any actual influence
21:21:05 <jle`> ._.
21:21:26 <EvanR> i could have sworn jle` was already here back in 2009
21:21:29 <MarcelineVQ> jle`: keep working hard, you'll be like me one day
21:21:44 <Axman6> mate, you've written some of my favourite Haskell posts of all time, quit being moddest
21:22:01 <jle`> in 2009 i was still in my ruby phase
21:22:18 <jle`> actually i was just starting it ...
21:22:37 <jle`> that's back when i thought programming in ruby made me a functional programmer
21:22:43 <Axman6> my firs Haskell job was replacing Ruby with Haskell. Thanks Tsuru!
21:22:48 <Axman6> heh
21:23:17 <jle`> to be fair ruby idioms vs python idioms are probably what prepared me to have a somewhat smoother transition into haskell
21:25:54 <EvanR> i think it was the PHP. PHP at work drove me so bonkers that i spontaneously started writing in this weird ass language haskell
21:26:06 <EvanR> luckily haskell rocks
21:26:57 <MarcelineVQ> I saw a haskell meme on 4chan while looking at desktop customizations.
21:27:21 <EvanR> oh man, the 5x5 grid of languages
21:27:30 <MarcelineVQ> Feel like that's a fairly inauspicious start.
21:39:44 <coldpress> MarcelineVQ: care to share the meme?
21:40:56 <MarcelineVQ> I'm not sure now, it was the haskell logo and somene talking about how it's for genius bigbrains, and that sounded a lot like me so I went looking
21:41:39 <coldpress> ah yes, the engorged heads
21:42:50 <jle`> i at least hope that the stereotype of haskell being the big brain language has gone away over the past ten years
21:42:51 <heatsink> Is the galaxy brain meme really that old
21:43:16 <MarcelineVQ> it wasn't galaxybrain, just something minor, innocuous, that lead here
21:43:28 <jle`> the community has put a lot of work into trying to fight against the big brain stereotype
21:43:33 <jle`> but it's still there somehow i think
21:43:36 <MarcelineVQ> And now after all this journey I know less than I've ever known before, but I'm pretty sure that's how it's supposed to work, you need to know things to know what you don't know so the more you know the more you recognise what you don't know and the ratio just won't stop increasing.
21:44:03 <heatsink> yes
21:45:40 <EvanR> kind of like the accelerated expansion of the universe *head explode*
21:54:54 <coldpress> the dunning-krueger curve
22:14:50 <Axman6> Did anyone take a look at that article I posted about concurrency in Haskell in Go?
22:15:10 <iqubic> If you link it again, I'll read it now.
22:15:30 <EvanR> i didn't realize it had anything to do with haskell
22:15:39 <Axman6> https://habr.com/ru/post/469441/ - (will need google translate if you don't speak russian)
22:16:12 <iqubic> I don't think firefox translates langauges automatically.
22:17:48 <Axman6> translate.google.com
22:19:30 * hackage skylighting-core 0.8.2.2 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-core-0.8.2.2 (JohnMacFarlane)
22:20:30 * hackage skylighting 0.8.2.2 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-0.8.2.2 (JohnMacFarlane)
22:23:42 <EvanR> Axman6: curious the table at the bottom... the translation may be off but... time to write the single threaded version 30 minutes. time to write the concurrent version 15 minutes
22:23:46 <EvanR> (in haskell)
22:24:06 <Axman6> well it was literally s/mapM/mapConcurrently/
22:25:34 <Axman6> Traversable really is a superpower of Haskell's
22:26:12 <dmwit> EvanR: I assume it is "time to write the concurrent version given that you have already written the single threaded version".
22:27:33 <EvanR> it looks like they got banned from go chat for asking about stack data structure or lack there of
22:27:41 <Axman6> I was pretty impressed they managed to figure out the Haskell version so quickly, it felt like a bit of a fluke. but theGo version is astounding in how non-obvious the code got
22:30:02 <EvanR> there is 1 sentence about the help they got from haskell community
22:31:06 <Axman6> well done team (Well, team Russia Haskell)
22:42:23 <jgt> team Russia Haskell is amazing
22:43:07 <monochrom> In Soviet Russia, the computer benchmarks programmer speed. >:)
22:47:34 <remexre> Are there any "fully-featured" libraries for logic programming in Haskell?
22:48:07 <remexre> I saw https://arxiv.org/abs/1805.11006 for OCaml but don't understand it well enough from a quick skim to tell what's going on
22:49:09 <remexre> other than that it looks like the equivalent of Template Haskell generating a type using explicit type recursion
22:51:45 <Axman6> you should talk to edwardk
22:52:02 <Axman6> (Don't worry, that has probably summoned him, he'll be here soon)
22:53:19 <remexre> okay, thanks
22:54:39 <nshepperd> remexre: 'ersatz' is a pretty good library for solving logic problems by translating them to SAT
22:54:46 * MarcelineVQ whispers one of the secret words of power that summons edwardk, "adjunction"
22:55:37 <remexre> nshepperd: that wouldn't work (well) if I wanted to implement something like http://lambda-the-ultimate.org/node/5470 though, right?
22:55:42 <remexre> MarcelineVQ: lol
22:56:14 <jgt> I don't know why "fully-featured" means in this context, but the first thing I would have looked into would be miniKanren
22:56:56 <remexre> jgt: yup, I'm coming from a common lisp miniKanren implementation
22:57:27 <remexre> I guess by fully featured, I'm complaining that every library I've seen so far defines a Term type and only supports unification over that
22:58:54 <remexre> rather than doing something tricky with SYB, or TH and the above OCaml paper, or even just doing unification over Data.Aeson.Value
22:59:39 <heatsink> I've seen a generic unification library somewhere
22:59:53 <remexre> unification-fd?
23:00:20 <heatsink> I think that's it
23:01:09 <remexre> it's in my history so apparently I've seen it, though I don't remember doing so
23:01:23 <nshepperd> implementing a lisp interpreter in SAT sounds like an interesting challenge
23:01:37 <heatsink> Well, I'm glad I had this opportunity to introduce you to it
23:02:26 <nshepperd> with limited evaluation depth and expression size, presumably, since SAT supports only fixed circuits
23:03:18 <Axman6> One of my biggest programming embarassments was when I was tutoriing a uni course, one of the assignments was to write a sudoku solver. I first wrote one which solved it using Z3 (I think with sbt), and then never managed to write the pure Haskell version
23:03:31 <Axman6> Z3 did a great job, and encoding the constraints was trivial
23:06:09 <remexre> heatsink: okay, looking at it, this is what I want! now to find a minikanren on top of it, heh
23:17:30 <cole-k> monad stack noob here: any way to lift a value to the top of the stack? do i just need to define `liftTop = lift . lift ...` as many times as needed? i swear i've seen code that just used `pure` to promote things to the top...
23:18:16 <Axman6> can you elaborate a little? I don't understand what you're after
23:19:26 <Axman6> pure in any monst stack will go from a to m a, no matter what monad m is
23:19:34 <Axman6> monad*
23:19:52 <EvanR> monsta stack
23:19:57 <cole-k> I have a stack `type ExceptState a = Except String (State MyState a)` and i have some function `foo :: Int -> ExceptState Int`
23:20:08 <cole-k> i tried `foo = pure`, but got a compiler error - maybe i'm just being foolish
23:20:40 <Axman6> I think you want ExceptT no?
23:20:55 <Axman6> @hoogle Except
23:20:55 <lambdabot> module Control.Monad.Trans.Except
23:20:55 <lambdabot> Control.Monad.Trans.Except type Except e = ExceptT e Identity
23:20:55 <lambdabot> module Control.Monad.Except
23:21:12 <cole-k> ah lol
23:21:18 <cole-k> thank you, Axman6 
23:21:29 <Axman6> you want  ExceptT String (State MyState) a
23:23:44 <cole-k> also, i seem to recall seeing code that used `gets` in the underlying state without lifting, am i imagining things again or is this possible?
23:24:13 <Axman6> if you're using gets from MonadState yes
23:24:22 <cole-k> e.g. if i wanted a function `bar :: ExceptState Int` `bar = gets myBar`
23:24:42 <Axman6> there should be an instance for MonadState m s m => MonadState (ExcepT e m)
23:25:01 <Axman6> hu, m s m -> s m
23:25:43 <cole-k> oh, do i have the order of my stack inverted?
23:26:01 <Axman6> depends which semanitcs you want =)
23:26:12 <Axman6> do you want to know what the state was when you failed or not?
23:26:30 <Axman6> @unmtl ErrorT e (State s) a
23:26:30 <lambdabot> s -> (Either e a, s)
23:26:50 <Axman6> @unmtl StateT s (Either e) a
23:26:50 <lambdabot> s -> Either e (a, s)
23:28:01 <cole-k> that's very helpful, let me think on that, thank you
23:28:40 <Axman6> so what you have will give you an opportunity to see what the state is if you fail. if you switch the order, you only see the state if the computation succeeds
23:31:06 <cole-k> makes sense - it would be nice to be able to introspect into the state in the case of an exception - is there something i need to change to my type synonym presently to allow it to make use of that MonadState definition?
23:32:34 <Axman6> if you're importing gets from Control.Monad.State then it should be ok
23:33:21 <cole-k> ah, i was taking it from Control.Monad.Trans.State.Lazy
23:33:29 <cole-k> thank you again, Axman6 
23:33:53 <cole-k> i'll try using Control.Monad.State
23:45:29 <Axman6> remexre: since summoning Ed didn't work, you should look for his talks in guanxi (I think that's what it's called)
23:45:56 <remexre> that's ed kmett, right?
23:46:01 <Axman6> https://www.youtube.com/watch?v=D7rlJWc3474
23:46:02 <Axman6> yeah
23:46:25 <remexre> oh, sweet!
23:46:28 <Axman6> gmm, 45mins is nowhere near enough to cover that topic, I'll see if there's abetter video (There's also https://github.com/ekmett/guanxi)
23:46:38 <remexre> yeah, just saw the repo
23:47:35 <remexre> I'm probably gonna go to sleep within an hour or two, but I'll definitely take a gander tomorrow
23:51:07 <MarcelineVQ> Axman6: it says 1 of 4 :>
23:51:45 <Axman6> ah yes
23:52:35 <Axman6> 4*45mins is probably enough time for a brief introdution
