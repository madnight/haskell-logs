00:04:00 <Axman6> I believe so, roughly
00:04:37 <Axman6> though it would probably be: main = print $ get "https://www.thecolorapi.com/id?hex=1ABC9C" <&> view (key "name" . key "value")
00:04:56 <Axman6> possibly with something to access the response body inside that call to view
00:05:59 <Axman6> (view is the prefix version of (^.) - many lens operators have both an infix and prefix version because it's nicer to use it one way sometimes and the other others)
00:20:14 <Nevoic> :t (<&>)
00:20:15 <lambdabot> Functor f => f a -> (a -> b) -> f b
00:20:29 <Axman6> itâ€™s flip <$>
00:20:33 <Nevoic> :t (<$>)
00:20:35 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:20:41 <Nevoic> I feel.
00:20:45 <Nevoic> And that's fmap
00:20:52 <Nevoic> which is map with a crappy name
00:20:53 <Nevoic> lol
00:21:07 <iqubic> it's not a crappy name.
00:21:11 <Nevoic> functor map
00:21:15 <iqubic> Yes.
00:21:18 <iqubic> Correct.
00:21:18 <Nevoic> iirc it used to just be map.
00:21:25 <iqubic> Nope. Never.
00:21:30 <iqubic> I was never just map.
00:21:35 <suppi> in purescript it's map
00:22:07 <Nevoic> https://stackoverflow.com/questions/6824255/whats-the-point-of-map-in-haskell-when-there-is-fmap
00:22:20 <Nevoic> in Haskell 1.3 it was `fmap` was `map`.
00:22:30 <Nevoic> So "never" is off.
00:22:44 <int-e> purescript isn't 29 years old either
00:22:59 <int-e> (mmm)
00:23:15 <Nevoic> The main reasoning for `fmap` was because the error messages were hard for beginners.
00:23:30 <Nevoic> And making `map` less general was helpful to narrow down the normal use case (with lists).
00:23:38 <Nevoic> so the type error was more specific.
00:24:48 <dminuoso> int-e: it is a weird name.
00:24:51 <dminuoso> Err I meant iqubic. :)
00:25:36 <int-e> "functorial map"
00:26:32 <[exa]> feneric map.
00:27:07 <Nevoic> It's like calling "scream" "ascream" for "animal scream" and then making "scream" specific to humans because most of the time when we code we have the human scream.
00:27:08 <koz_> fun map.
00:27:11 <acdimalev> fancy map
00:27:28 <[exa]> :]
00:27:28 <Nevoic> Seems like a really bad solution to an actual problem.
00:28:00 <ski> `map' is a weird name
00:28:05 <int-e> How is it "really bad".
00:28:22 <merijn> At worst it's "mildly annoying"
00:28:39 <Nevoic> Well really bad in terms of the potential solutions.
00:28:46 <Nevoic> Like probably bottom of the list out of all the options they had.
00:28:51 <Nevoic> Or were considering.
00:29:17 <int-e> Nevoic: you lack imagination
00:29:48 <hololeap> they should have named it qaarflog
00:29:55 <[exa]> ListMapFactory.DoMap
00:29:59 <Axman6> possibleInternalValueTransformerUnlessThereAreNoInternalValuesThenIt'sSomethingElse
00:30:08 <int-e> For example they didn't name `fmap` it `beisa` (whatever that is, I took a random line from my /usr/share/dict/words)
00:30:38 <Nevoic> Also fmap is bad because flatmap is extremely common in other languages. When I came into the FP world I came because I liked how "functional" things made my code better in Kotlin, Swift, Ruby, etc.
00:30:45 <Nevoic> so map/flatmap/filter/reduce/fold etc.
00:30:47 <Axman6> I rarely buse "fmap" anyway, I'm always using <$>
00:31:02 <koz_> Axman6: Yeah, me also.
00:31:11 <Nevoic> So when you see similar functions in Haskell (map/filter/foldl/foldr/fmap) you're like "well fmap is obviously flatMap because there's no way it does what map does"
00:31:17 <Axman6> flatMap is an awful name IMO
00:31:19 <Nevoic> Like it didn't even cross my mind that fmap was not flatMap
00:31:29 <int-e> It's a name that makes sense, it's easy enough to remember (it's associated with Functor, which starts with f... see also `msum` which is the sum associated with... oops, MonadPlus, not Monoid)
00:31:34 <Nevoic> Either way, the point of `map` vs `fmap` is to make it easier for beginners, and it made it harder for me.
00:31:36 <Nevoic> It's not hard now.
00:31:37 <Axman6> it implies some data is being slattened, which is not what bind is
00:31:39 <Nevoic> But it's ironic.
00:31:41 <Axman6> (in general)
00:31:47 <[exa]> Nevoic: flatMap is concatMap?
00:31:57 <koz_> Or join. :P
00:32:00 <merijn> [exa]: flatMap is bind
00:32:04 <koz_> Wait, no, never mind. :P
00:32:13 <[exa]> oh so
00:32:14 <koz_> merijn has it right.
00:32:33 <Nevoic> flatMap in Ruby, Kotlin, Java, Swift, and Scala is like Haskell's `bind`.
00:32:38 <jusss> stack update get Connection Timeout
00:32:42 <merijn> Nevoic: fmap is older than most of those languages (except maybe Ruby), so that's kind of weird to blame Haskell for
00:33:02 <Axman6> Nevoic: it was called bind long before those languages existed
00:33:09 <Nevoic> the change from `map` -> `fmap` happened in Haskell 98.
00:33:21 <jusss> stack install yesod stuck in "can not download index"
00:33:23 <int-e> Now if Haskell98 had embraced a) qualified imports and b) the idea that there might be more than one Prelude for different audiences... maybe `fmap` would not exist.
00:33:34 <merijn> Nevoic: In Haskell 1.4 iirc, which was 1997, which is certainly before Kotlin, Scala, and Swift existed
00:33:35 <Axman6> jusss: what does stacj update do?
00:33:37 <jusss> why stack use amazonaws?
00:33:40 <int-e> But as far as I can make out, it did neither.
00:33:47 <merijn> Nevoic: And Java/Ruby had only been out for one or two years
00:33:53 <[exa]> jusss: because it's stack-level cool
00:34:01 <Axman6> jusss: it just uses S3 to store static files
00:34:19 <Axman6> Isn't Haskell older than Java?
00:34:24 <jusss> Axman6: [exa] but amazonaws is not available on my country
00:34:52 <merijn> Axman6: Yes
00:34:53 <Nevoic> merijn yeah that's a fair point, maybe `fmap` in 1997/8 wouldn't have been confused with flatMap.
00:34:54 <Axman6> how does your internet even function D:
00:35:15 <Nevoic> but since like 2009 Haskell beginners often come from OO where they tried out functional like methods and liked them.
00:35:22 <int-e> doesn't flatMap originate in the ML languages?
00:35:22 <Nevoic> Where `flatMap` is a very, very common idiom.
00:35:22 <jusss> Axman6: https://paste.ubuntu.com/p/7xh2ms2Dgv/
00:35:24 <merijn> Axman6: I think the report was finished in 1989 and the first compiler in 1990?
00:35:37 <[exa]> jusss: like they have an outage?
00:35:41 <Nevoic> So it's now counterproductive for it's original stated purpose.
00:35:42 * Axman6 is the same age as Haskell
00:36:12 <merijn> Nevoic: Sure, but almost all of those languages copied flatMap from bind and changed the name to flatMap because, apparently, bind and Monad are too scary
00:36:22 <Axman6> Nevoic: we're not going to change oour languages established names and conventions to meet the needs of users of other languages, particularly when the choices in those languages are so bad
00:36:32 <[exa]> Nevoic: maybe you might write a slightly modified prelude which may draw enough attention and eventually become standard, if the naming is better
00:36:38 <jusss> [exa]: is there other repo or mirror? I don't want amazon
00:36:45 <int-e> merijn: tbf "bind" is a terrible name too
00:36:53 <merijn> Anyway, I think this discussion is kinda moot, since we're not going to do a massively breaking change like that so discussion if the name is good is kinda pointless
00:36:54 <hololeap> there are so many things that have to be unlearned when switching to haskell from another language. i really donfeel like learning the meaning of map is that big of a deal
00:36:57 <[exa]> jusss: no idea in fact, I'm avoiding stack and this is one of the reasons :]
00:36:58 <int-e> merijn: It doesn't bind anything... the binding is done by the lambda in the second argument
00:37:01 <jusss> like other pacakge managers, pacman , apt, pip, they all are good
00:37:02 <acdimalev> `bind` is kinda a weird name for `join $ map f x`... .
00:37:10 <Axman6> languages which have used the name flatMap have done their users a disservice by constraining their thinking of what's possible with monads
00:37:16 <jusss> [exa]: and why stack sucks?...
00:37:20 <hololeap> *fmap -- typo =) 
00:37:38 <merijn> jusss: Because those other tools have approximately 1000x more man-hours poured into fixing tiny bugs
00:38:30 <Axman6> jusss: to be honest, it's not stack's fault that youy can't access the world's biggest cloud provider in your country, the internet runs on AWS
00:38:36 <Nevoic> [exa] there are already a crap ton of other preludes
00:38:46 <[exa]> Nevoic: the other preludes already went in a similar direction (classy prelude, rio, ...), why not just use one of them?
00:39:05 <Nevoic> I've tried, you can't integrate a custom prelude as seamlessly as the normal Prelude.
00:39:11 <[exa]> Nevoic: (obviously you're not a beginner anymore so you can probably choose freely)
00:39:12 <Nevoic> Even with noimplicitprelude and other options set.
00:39:19 <jusss> Axman6: but the stack the tool should provide other way, if one day AWS is down, so stack should be down too?
00:39:27 <merijn> jusss: Because those other tools have approximately 1000x more man-hours poured into fixing tiny bugs
00:39:29 <jusss> and all the project on stakc should be down too?
00:39:30 <Nevoic> you pretty much always need to import the custom prelude
00:39:30 <merijn> jusss: Because those other tools have approximately 1000x more man-hours poured into fixing tiny bugs
00:39:33 <merijn> whoops
00:39:43 <Axman6> if AWS is down, most of the internet goes down with it
00:39:43 <merijn> what the hell are you doing, irssi...
00:39:44 <Nevoic> I don't believe there's any way to implicitly import something in every haskell file in a stack project
00:40:02 <[exa]> merijn: now that's a way to put a stress on the hard bugfixing work :]
00:40:09 <merijn> [exa]: ;)
00:40:25 <Axman6> jusss: the thing which is failing for you is sometrhing whouch is only updated occasionally by the tool, if you can find the file then everytrhing else should work fine
00:40:32 <[exa]> Nevoic: not sure with stack but it's perfectly doable with plain cabal
00:40:54 <jusss> Axman6: I don't agree with you, AWS is not in China, and the internet is still very good in China
00:40:56 <Axman6> I don't know where you'd find it though. try asking in #haskell-stack (it's usually pretty quiet in there though)
00:40:59 <Nevoic> You can have a haskell project with multiple files where a custom prelude is automatically imported into every file without a manual import?
00:41:16 <Nevoic> I tried to figure out how to do that and couldn't figure it out even after spending dozens of minutes on it.
00:41:34 <Axman6> AWS  have regions in Beijing :\
00:41:51 <Axman6> Nevoic: yes, but I don't remember how
00:41:53 <jusss> Axman6: hehe, but no one use it
00:42:37 <jusss> Axman6: there're Tencent Alibaba and lots of other clound service providers in China
00:42:55 <jusss> and really no one use AWS
00:43:32 <Axman6> "You need to understand one thing about AWS China: it is totally separated from AWS global. " ew
00:45:06 <jusss> I wonder if I don't use stack, can I use yesod?
00:45:20 <Axman6> sure, you can just use cabal
00:45:21 <jusss> or can I use haskell plugin in IntelliIDEA?
00:46:43 <hololeap> does stack really depend on some aws service?
00:46:55 <Axman6> it depends on files stored in S3
00:47:11 <Axman6> which is a pretty standard way to provide access to static files
00:47:16 <lelf> jusss: maybe open an issue on stack's github. Plain cabal will work (it'd try several mirrors)
00:48:09 <hoppfull> How come Set is not a monoid?
00:48:20 <[exa]> Nevoic: cabal mixins?
00:48:24 <hololeap> hoppfull: the Ord constraint
00:48:43 <hololeap> oh, sorry, that's monad =)
00:48:57 <c_wraith> no, it's also why it doesn't have a Monoid instance
00:49:07 <c_wraith> mempty can be defined just fine, but mappend can't
00:49:31 <c_wraith> Oh, wait.  It can because you can actually add the necessary context.  whoops.
00:49:36 <c_wraith> Ok, no good reason :)
00:49:40 <hoppfull> hehe
00:49:44 <hoppfull> :)
00:50:01 <jusss> lelf: I don't think they will care, if they do, they should did it before, I wouldn't be the first guy met this
00:50:02 <Axman6> instance Ord a => Monoid (Set a)
00:50:40 <Axman6> They definitely won't fix it if yoyu don't tell them, but they _might fix it if you do
00:50:53 <hoppfull> So there is no good reason?
00:51:08 <Axman6> Is it a Semigroup?
00:51:18 <int-e> instance Ord a => Monoid (Set a) -- Defined in â€˜Data.Set.Internalâ€™
00:51:20 <int-e> instance Ord a => Semigroup (Set a)
00:51:33 <int-e> (same module)
00:51:36 <hoppfull> int-e: Thank you
00:51:49 <lelf> jusss: well...just use cabal then
00:52:10 <hoppfull> int-e: Yep, there it is, staring at me. Thanks!
00:52:11 <hololeap> i would think that (<>) = S.union
00:52:55 <hoppfull> I understand Semigroup is new. Is this why we're missing things like "Reductive Semigroup"?
00:53:12 <[exa]> Nevoic: see here: https://hackage.haskell.org/package/Prelude
00:53:56 <merijn> hoppfull: Semigroup isn't really new, just "new in base" and "new as superclass of Monoid"
00:54:14 <hoppfull> merijn: thanks
00:55:01 <hololeap> hoppfull: i don't know that a "reductive semigroup" can be expressed in haskell
00:55:03 <jgt> merijn: do you mean that in the sense that it's newly discovered by us, but has existed forever?
00:56:19 <merijn> jgt: Well, in math is has been around for literal centuries, but also in that it's been around in Haskell in the semigroup package for years
00:56:42 <merijn> eh, semigroup*s* package
00:56:42 <hoppfull> hololeap: There is a Reductive Monoid but it returns a maybe in case you try to remove something that can't be removed.
00:57:21 <merijn> jgt: But being an extra dependency meant that not many supported it, so the decision was made to move the class from semigroups into base so it'd be less overhead and so it could be made a superclass of Monoid
00:57:24 <hoppfull> merijn: I didn't mean that it was newly discovered. I have no idea when it was discovered. But it seemed new in Haskell.
00:57:56 <hoppfull> merijn: sorry, misread jgt's message as a message to me, nvm
00:58:34 <merijn> I just checked, semigroups copyright notice goes back to 2004 :)
00:59:10 <jusss> ghc-pkg check give me lots of warning, lots of files don't exist
00:59:24 <jusss> and cabal install yesod get lots of error, same error
00:59:56 <jusss> what the pacakage maintainer did on archlinux?
01:02:47 <jusss> https://paste.ubuntu.com/p/KX5stXxN7K/
01:03:24 <jusss> https://paste.ubuntu.com/p/kkqDnkwrxy/
01:06:55 <sicklork1n> that just means they ddint' bundle the src dirs when they build the inital ghc package
01:07:47 <jusss> sicklork1n: why they did that?
01:07:47 <sicklork1n> it's pretty common to forget to do this..
01:08:23 <sicklork1n> i wouldnt' say it was intentional.. 'cause on their machine ghc-pkg check would pass w/o fail
01:08:42 <c_wraith> it's intentional
01:09:03 <c_wraith> arch just doesn't want to package ghc correctly
01:09:06 <lelf> jusss: you don't need to globally install yesod (if you really want to, "cabal v2-install"), you can just do v2-build in your src dir
01:09:16 <sicklork1n> well then.. that's no good
01:10:13 <jusss> c_wraith: arch hate ghc?
01:10:41 <sicklork1n> jusss: I don't think many people use their OS' ghc - and for good reasion.. you're always going to be far behind..
01:10:59 <sicklork1n> i would suggest using something else if that's an option
01:11:13 <int-e> the only thing arch's ghc is good for is bootstrapping your own
01:11:18 <jusss> sicklork1n: so compile it by youself?
01:11:29 <sicklork1n> stack?
01:11:30 <lelf> jusss: the missing stuff ghc-pkg complaining about is the docs, maybe there's some -doc package?
01:11:43 <sicklork1n> there's some other bootstrap now
01:12:03 <Axman6> ghcup
01:12:27 <jusss> sicklork1n: all ghc stuff
01:13:48 <sicklork1n> yes, i wouldn't depend on the OS at all for ghc, ghc packages etdc.
01:14:06 <sicklork1n> when I say OS i mean whatever pkg manager you have
01:14:50 <sicklork1n> jusss: Axman6 pointed out the newest method is ghcup, i'd try that
01:16:45 <Nevoic> completely random, does anyone know if it's possible to make the following method compile in Haskell `transpose :: Matrix n m a -> Matrix m n a`?
01:17:04 <Nevoic> I can give more details if necessary, a Matrix is a 2D Vect where Vect is pretty much Vect Nat a
01:17:21 <Nevoic> I have vect defined and working, with some methods that function (map, length, etc.)
01:17:43 <Nevoic> So it's pretty much like `[[a]]` but with known lengths at compile time.
01:17:54 <Nevoic> it seems like Haskell's type system might not be powerful enough to do this.
01:18:41 <koz_> Nevoic: Not only is it possible, but someone's written something like it already.
01:18:46 * koz_ rings the jle` bell.
01:19:36 <Nevoic> Oh that's interesting.
01:19:38 <Nevoic> I'm stuck on this https://pastebin.com/v8SBE5fQ
01:19:54 <Nevoic> I can link to what `Matrix` is and `Vect` etc.
01:20:01 <Nevoic> But pretty much `:- ` is like `:` for lists.
01:20:03 <Nevoic> But for vects
01:20:07 <Nevoic> and `Matrix` is a 2D vect.
01:20:47 <Nevoic> the above code but written for lists works and properly transposes a matrix, but the above fails on `map tail x` and `map head x` because the lengths can't line up for some reason.
01:21:03 <Nevoic> `tail` and `head` are both methods that require `Vect ('S n) a` (or in other words non-empty vectors)
01:24:15 <boxscape> hmm how is it supposed to know that the elements of x are non-empty?
01:24:55 <Nevoic> Because the length of the vector is a successor to n.
01:24:58 <merijn> :t all null
01:25:00 <lambdabot> (Foldable t1, Foldable t2) => t1 (t2 a) -> Bool
01:25:06 <merijn> boxscape: ^^ ?
01:25:07 <Nevoic> Successor (S) is the other non-Z constructor.
01:25:07 <boxscape> I mean in transpose
01:25:08 <Nevoic> for Nat.
01:25:13 <Nevoic> oh
01:25:27 <Nevoic> Well, ideally, it would figure it out from the first case existing.
01:25:31 <Nevoic> (Nil :- _)
01:26:00 <Nevoic> because that says that it excepts a list of any length where the first element is of length 0, so it's a vect of n size containing empty vectors.
01:26:10 <Nevoic> so the second case (x) must contain non-empty lists.
01:26:38 <Nevoic> The second case might simply be `Nil`, which is something I have to overcome, but I've also tried changing `x` to `x :- xs` to verify that it's definitely non-empty.
01:26:55 <Nevoic> With the same errors (when I recombine x:- xs and pass those into where I was passing `x` before)
01:27:02 <Nevoic> `transpose Nil = Nil` doesn't compile
01:27:09 <Nevoic> Because `m ~ n` cannot be proven for the sublists.
01:27:34 <Nevoic> but I *think* that case should never happen.
01:27:50 <Nevoic> even if it does, it shouldn't be a compile time error, it should be a runtime error.
01:28:07 <Nevoic> and even when I do `transpose Nil = error "blegh"` the same compilation errors happen on the `x` case.
01:28:23 <Nevoic> it accepts * I'm getting tired.
01:54:26 <o1lo01ol1o> Nevoic:  you might look at easytensor and it's dimensions package for one approach to this.  There's a few staticlly checked linear-algebra parts floating around but I think we're still lacking a unified package
01:55:02 <o1lo01ol1o> Nevoic:  Also, hasktorch has some work on a statically checked api in progress.
01:56:34 <boxscape> +
01:56:35 <boxscape> +
01:56:40 <boxscape> oops
01:56:41 <boxscape> sorry
01:59:26 <asheshambasta> So I had a project that 'used to' work with intero and stack. All of a sudden, I'm seeing errors like these suggesting me to add things to the extra-deps. Under what circumstance can this happen? https://gist.github.com/asheshambasta/fdccdd041790d30218824ca966a6a2ec
02:00:09 <asheshambasta> Is it because the stackage resolved 'mutated' its package list somehow? 
02:01:43 <asheshambasta> resolver* 
02:06:09 <sicklorkin> asheshambasta: did this happen after update stack?
02:07:02 <sicklorkin> asheshambasta: def. moving things to extra-deps will work..I've tried
02:07:59 <asheshambasta> sicklorkin: it does work; it did work on my colleague's machine and it seems to be on my machine (still building); however, this kind of 'sudden' error messages are perplexing. 
02:08:30 * hackage fast-builder 0.1.2.0 - Fast ByteString Builder  https://hackage.haskell.org/package/fast-builder-0.1.2.0 (AkioTakano)
02:09:08 <asheshambasta> there are multiple things that are also not properly put in context with the error message: a newcomer would wonder why we're building Cabal-2.2.0.1 at all when its not mentioned in the dependencies of the project. 
02:12:21 <asheshambasta> (understandably, thats needed by Stack)
02:12:53 <asheshambasta> but then again, why do I need to add extra-deps in my project's stack.yaml for my 'build tool' to work 
02:13:50 <jgt> asheshambasta: is your build pinned to a specific resolver?
02:14:02 <asheshambasta> I'm also totally lost on why this error 'suddenly' appeared when no changes were made to the dependencies or extra-deps at all (intero was not complaining about this just yesterday)
02:14:24 <sicklorkin> asheshambasta: it's 'cause stack was no longer able to find the libs
02:14:42 <sicklorkin> you can confirm this by typing stack paths
02:15:04 <sicklorkin> *path
02:15:23 <asheshambasta> jgt: yes 
02:15:53 <asheshambasta> sicklorkin: why was stack not complaining yesterday>
02:16:35 <asheshambasta> sicklorkin: and no, I didn't update stack; I did run a stack update though. 
02:17:00 * hackage hw-json 1.3.1.0 - Memory efficient JSON parser  https://hackage.haskell.org/package/hw-json-1.3.1.0 (haskellworks)
02:18:18 <asheshambasta> in my very limited understanding of Stack; I can only assume that running `stack update` somehow reindexed the resolver, which means the resolver's state is no longer compatible with the state of the project; and hence I need to add extra-deps. Which would mean that the package list in a resolver are mutable; which I hope is incorrect.
02:50:59 <__monty__> asheshambasta: Did the GHC version change or something? I think these are all part of base? So the resolver shouldn't affect it unless GHC or the included base changed, right?
02:52:12 <asheshambasta> __monty__: isn't the ghc version locally installed for the project based on the resolver? 
02:52:51 <asheshambasta> absolutely nothing changed on my side; as far as I can tell, and the thing I did that caused this was `stack update`.
02:54:29 <__monty__> Afaiu stack (which isn't very far), yes the GHC version is linked to the resolver. But maybe only the major or major-minor version is fixed?
02:55:34 <jusss> how to pronouce "yesod"?
02:55:45 <jusss> pronounce
02:55:57 <sicklorkin> is it yiddish?
02:56:07 <__monty__> yeh-zod is what I say.
02:56:46 <jusss> "By the way, the word Yesod (×™×¡×•×“) means foundation in Hebrew."
03:08:20 <asheshambasta> __monty__: yeah, that could explain it.
03:08:38 <nshepperd2> Nevoic: the type checker doesn't do proof by contradiction between cases like that. Ie. it doesn't know that because x is not Nil that means it must be _ :- _
03:09:09 <asheshambasta> __monty__: I'm quite sure that it has been and currently also is GHC 8.4.4 for the LTS-12.26 
03:09:28 <asheshambasta> so no, the GHC version didn't change whatsoever.
03:09:53 <__monty__> asheshambasta: Did the stack version change? Maybe it got stricter about declaring deps?
03:10:26 <nshepperd2> Nevoic: so you need to prove that by pattern matching: transpose (x@(_ :- _) :- xs) = ...
03:10:30 <asheshambasta> __monty__: also no; at least not the one globally installed on my machine. 
03:11:16 <asheshambasta> the issue is that these extra-deps are required to build cabal. 
03:11:42 <__monty__> asheshambasta: Did the version of the editor plugin change? Maybe it didn't report errors/warnings properly before?
03:11:46 <asheshambasta> there are a few problems I see here: why does my build tool want me to change my deps. in the project? 
03:11:52 <asheshambasta> secondly; what exactly changed? 
03:12:29 <asheshambasta> __monty__: also no, I explicitly upgrade emacs pacakges once in a while and  I've not done it in the past few weeks. 
03:14:42 <__monty__> asheshambasta: So, stack didn't change, neither did the plugin/editor, nor the resolver/project? I've run out of variables : )
03:19:06 <asheshambasta> __monty__: to the best of my knowledge, nothing changed
03:23:44 <__monty__> asheshambasta: Maybe stack's not a pure function : >
03:23:59 <__monty__> If only it were written in haskell.
03:24:02 <__monty__> ... wait.
03:28:12 <andreap> hi all, i was wondering where do i find the public keys used to sign ghc distributions (by ben gamari i guess), could anyone help?
03:31:59 <__monty__> andreap: `gpg --recv-keys KEY_ID` should be enough but it seems like the keyserver is down.
03:37:44 <andreap> __monty__ thanks, do you mean gpg has some default keyservers to contact? i have not yet set any option in this regard. bonus: what to do when the keyservers are down? :D  
03:38:58 <__monty__> Hmm, I'm not sure gpg comes with them by default. Might be up to the packagers. But my gpgs have always kinda worked out of the box.
03:39:43 <__monty__> I'm not sure there's a good solution, I'd just look up some common keyservers and specify them with `--keyserver` in the hope that these keyservers happen to have synced the keys you want : )
03:40:32 * hackage llvm-ffi 3.8.1.2 - FFI bindings to the LLVM compiler toolkit.  https://hackage.haskell.org/package/llvm-ffi-3.8.1.2 (HenningThielemann)
03:56:23 <andreap> __monty__ thanks, do you mean gpg has some default keyservers to contact? i have not yet set any option in this regard. bonus: what to do when the keyservers are down? :D  
04:09:24 <__monty__> andreap: I assume that was sent again by accident?
04:10:57 <jgt> __monty__: /jÉª'sod/ ×™×¡×•×“. yi as in yip, sod as in soda, stress on sod.
04:11:03 <jgt> it's right there on the homepage
04:12:26 <__monty__> jgt: Thanks. I've never cared enough to look it up.
04:12:46 <bwe> >>> sqrt $ 1.4444 :: Centi -- what do I need to take the root of a Data.Fixed number?
04:17:12 <andreap> __monty__ excuse me it was sent again because i inadvertently disconnected and i didn't know if you already answered
04:18:02 <andreap> i managed to find a working keyserver at keys.openpgp.org meanwhile :)
04:19:00 <__monty__> andreap: Ah, my answer was to just try other keyservers in the hope they had the key synced : )
04:19:31 <andreap> eheh yes thx
04:20:53 <__monty__> Does anyone have experience running 32bit stack builds? i386 GHC is giving me an error about it targetting a word size of 4 but my target toolchain producing binaries with word size 8. I'm trying to build a 32bit binary on a 64bit platform so everything but the "target" having word size 8 makes sense.
04:20:53 <andreap> it's a few days anyway i'm having this kind of difficulty finding keys, i remember it being easier some time go
04:21:16 <__monty__> andreap: Probably just the pgp.mit.edu outage interfering.
04:23:35 <andreap> aha.. no signs of getting it back working i understand
04:30:33 <merijn> bwe: A custom implementation of sqrt, I think
04:30:45 <merijn> bwe: And/or realToFrac
04:31:22 <merijn> realToFrac, for when the fromIntegral hammer isn't big enough!
04:31:26 <bwe> merijn: okay, I'll check that.
04:34:00 * hackage tuple-ops 0.0.0.3 - various operations on n-ary tuples via GHC.Generics  https://hackage.haskell.org/package/tuple-ops-0.0.0.3 (JiasenWu)
04:39:31 * hackage logging-effect 1.3.5 - A mtl-style monad transformer for general purpose & compositional logging  https://hackage.haskell.org/package/logging-effect-1.3.5 (OliverCharles)
05:36:00 * hackage harg 0.4.0.0 - Haskell program configuration using higher kinded data  https://hackage.haskell.org/package/harg-0.4.0.0 (alexpeits)
05:43:19 <ridofself> how does haskell compare to Ocaml?  Is it worth learning?
05:50:39 <maralorn> ridofself: The answer is obviously "it depends" on what you wanna do/learn/achieve.
05:51:01 <maralorn> I think itâ€™s totally worth it.
05:52:55 <maralorn> On a more serious note my USP for Haskell is purity/referential transparency/side-effect-tracking which ocaml does not provide as far as I can tell.
05:53:53 <maralorn> The rest of the answer I'll leave to someone who actually knows something about Ocaml.^^
06:00:57 <Kartha> maralorn, what's a USP?
06:01:34 <Kartha> can I make plot visualizations in Haskell like I do in Python using matplotlib
06:03:11 <[exa]> Kartha: what about this? https://github.com/timbod7/haskell-chart/wiki
06:05:00 * hackage sparse-tensor 0.2.1.2 - typesafe tensor algebra library  https://hackage.haskell.org/package/sparse-tensor-0.2.1.2 (nalex)
06:05:34 <maralorn> Kartha: Unique selling point
06:08:30 * hackage antiope-swf 7.3.4 - Please see the README on Github at <https://github.com/arbor/antiope#readme>  https://hackage.haskell.org/package/antiope-swf-7.3.4 (arbornetworks)
06:09:31 * hackage antiope-contract 7.3.4, antiope-sns 7.3.4, antiope-s3 7.3.4, antiope-sqs 7.3.4, antiope-core 7.3.4, antiope-messages 7.3.4, antiope-athena 7.3.4, antiope-dynamodb 7.3.4, antiope-optparse-applicative 7.3.4 (arbornetworks)
06:14:29 <tabaqui2> I've asked about stack yesterday
06:14:46 <tabaqui2> it rebuilds all dependencies even if I've installed them globally before
06:15:33 <tabaqui2> it turned out it's because of ghc-option flags in local stack.yaml
06:16:00 * hackage tree-sitter 0.3.0.0 - Unstable bindings for the tree-sitter parsing library.  https://hackage.haskell.org/package/tree-sitter-0.3.0.0 (patrick_thomson)
06:16:15 <tabaqui2> I've declared something like "$targets": -pedantic, "$locals": -pedantic, "$everything": -O
06:16:30 <tabaqui2> I was expecting that this options affect only new build targets
06:17:21 <tabaqui2> hmm, but it doesn't explain why everthing was fine on my workstation
06:17:23 <tabaqui2> dunno
06:27:00 * hackage tree-sitter-python 0.4.0.0 - Tree-sitter grammar/parser for Python  https://hackage.haskell.org/package/tree-sitter-python-0.4.0.0 (patrick_thomson)
06:36:14 <raichoo> Hi, are there any auditing tools that keep me informed about security problems with certain libraries?
06:36:35 <raichoo> something like cabal/stack audit?
06:39:16 <adamCS> Kartha: you could also look at hvega (https://hackage.haskell.org/package/hvega) for charts.  It's a vega-lite wrapper and produces JSON you can insert into an html doc. And there's IHaskell (https://www.tweag.io/posts/2019-01-23-jupyterlab-ihaskell.html).
06:39:44 <justsomeguy> How can I verify that my download of stack is really fpcomplete? The public key at https://docs.haskellstack.org/en/stable/SIGNING_KEY/ differs from the one in the *.asc file distributed with the binaries on the stack github release page, and the checksums for the binaries aren't signed. They just distribute the checksum and asc, but you can't use the asc to verify the checksum. Am I missing something?
06:40:00 <justsomeguy> s/really fpcomplete/really from fpcomplete/
06:40:16 <orzo> So I am trying to write a compiler plugin that solves a type-function generated constraint tuple.  To my mind, the EvTerm for a constraint tuple is a CoreExpr made with the constraint tuple data constructors (%,%).  These are apparently known-key symbols but when I try to use tcLookupDataCon to acquire them, it triggers an error:
06:40:21 <orzo> Can't find interface-file declaration for data constructor GHC.Classes.(%,%)
06:40:40 <orzo> How are constraint tuple data constructors used by ghc if they are used at all and if they are not, then why do they exist?
06:41:16 <Guest_4> hi 
06:41:54 <Guest_4> i'm trying to install haskell via ghcup on a mac osx:10.9
06:42:16 <merijn> Guest_4: 10.9 is pretty ancient
06:43:22 <Guest_4> yep i've an old mac and i tried more recent osx but they're slwing down everything too much...
06:43:47 <Guest_4> anywyas.. this is what terminal says when trying to install ghc:
06:43:49 <merijn> Guest_4: ghcup relies on pre-built binaries and I doubt anyone is building those for 10.9
06:43:50 <Guest_4> Installing GHC-8.6.5 for Darwin on architecture x86_64usage: mktemp [-d] [-q] [-t prefix] [-u] template ...       mktemp [-d] [-q] [-u] -t prefix Failed to create temporary directory"ghcup --cache install" failed!
06:44:06 <Guest_4> oh ok i see..
06:44:39 <merijn> Guest_4: hmm, that looks like it's calling mktemp with a flag that doesn't exist in your version
06:48:43 <Guest_4> btw i'm doing this as I'm trying to install tydalcycles. is haskell necessary to run this?
06:50:57 <Athas> Man, I forgot how horrible the regex-base stuff is to work with...
06:51:07 <Athas> It's almost like a parody of over-engineering.
06:51:19 <Athas> The lens of the 2000s!
07:02:04 <tabaqui2> what's better?
07:10:30 * hackage jvm-binary 0.6.1 - A library for reading Java class-files  https://hackage.haskell.org/package/jvm-binary-0.6.1 (kalhauge)
07:22:16 <komasa> I have a general question about type theory (in the context of typing Python, specifically the networkx library) and got the advice to ask here (despite it not being about haskell specifically): What is a sensible signature for Graph composition? I am currently using `def compose(G: GT[X], H: GT[Y]) -> GT[Union[X,Y]]` where GT is a type variable for anything that inherits from Graph, and X,Y being unbounded
07:22:18 <komasa> type variables. Is there some haskell library that implements graphs generic over some type I could look at as a reference? 
07:23:20 <laudecay> >type theory
07:23:24 <laudecay> >"go to #haskell"
07:23:26 <laudecay> love it
07:23:36 <sm[m]> Athas: http://hackage.haskell.org/package/regex any help ?
07:23:41 <lyxia> komasa: fgl, algebraic-graphs
07:27:50 <komasa> lyxia: thanks, that looks good (especially the paper)
07:29:20 <sedeki> hehe
07:30:47 <Zemyla> I'm thinkibg for some reason about Seqs, and potentially having their Digits be Array#s.. Like, that way there isn't a four-way branch when you use cons/snoc or uncons/unsnoc.
07:32:00 * hackage tree-sitter-go 0.2.0.0 - Tree-sitter grammar/parser for Go  https://hackage.haskell.org/package/tree-sitter-go-0.2.0.0 (patrick_thomson)
07:36:30 * hackage pointfree 1.1.1.6 - Tool for refactoring expressions into pointfree form  https://hackage.haskell.org/package/pointfree-1.1.1.6 (BenMillwood)
07:38:00 * hackage tree-sitter-php 0.2.0.0 - Tree-sitter grammar/parser for PHP  https://hackage.haskell.org/package/tree-sitter-php-0.2.0.0 (patrick_thomson)
07:39:00 * hackage tree-sitter-ruby 0.2.0.0 - Tree-sitter grammar/parser for Ruby  https://hackage.haskell.org/package/tree-sitter-ruby-0.2.0.0 (patrick_thomson)
07:41:30 * hackage tree-sitter-haskell 0.2.0.0 - Tree-sitter grammar/parser for Haskell (with GHC extensions)  https://hackage.haskell.org/package/tree-sitter-haskell-0.2.0.0 (patrick_thomson)
07:41:53 <Ariakenom> a regex library: https://hackage.haskell.org/package/lens-regex-pcre
07:42:30 * hackage tree-sitter-json 0.2.0.0 - Tree-sitter grammar/parser for JSON  https://hackage.haskell.org/package/tree-sitter-json-0.2.0.0 (patrick_thomson)
07:44:42 <sm[m]> Ariakenom: great, now you have three problems :)
07:45:30 * hackage tree-sitter-java 0.2.0.0 - Tree-sitter grammar/parser for Java  https://hackage.haskell.org/package/tree-sitter-java-0.2.0.0 (patrick_thomson)
07:46:30 * hackage tree-sitter-tsx 0.2.0.0 - Tree-sitter grammar/parser for TSX  https://hackage.haskell.org/package/tree-sitter-tsx-0.2.0.0 (patrick_thomson)
07:51:24 <Ariakenom> sm[m]: :)
07:52:26 <c_wraith> only 3?  maybe it should somehow involve xml too
08:02:15 <sshine> can I, inside a megaparsec parser, temporarily hand control over to an attoparsec parser?
08:02:55 <merijn> sshine: Possibly
08:03:08 <merijn> sshine: Do you know ahead of time the size of the thing to be parser by attoparsec?
08:03:17 <merijn> Or do you know a delimiter where it ends?
08:03:31 <sshine> merijn, no.
08:03:59 <merijn> sshine: Then I don't know any easy ways, might still be possible, but will probably be annoying
08:04:31 <sshine> arf. I actually want them to be mutually recursive. I'll have to think of either using attoparsec or use an existing megaparsec JSON parser instead of Aeson's attoparsec parser.
08:06:31 <sshine> I'm parsing a superset of JSON, where the (superset \\ json) is unambiguous on the first character, and I thought a funny thing could be to separate the JSON parsing by parameterizing it like: json :: Parser a -> Parser a, where jsonPlain = json json, and myLang = json superset.
08:06:53 <sshine> where 'json' used its parameters on sub-expressions.
08:07:13 <geekosaur> that just sounds painful to me
08:07:16 <sshine> but since I'm using Megaparsec for now, and since Aeson doesn't have such a parameterized parser, I'm left with the same problem.
08:07:32 <sshine> geekosaur, you think so? I just thought it might be useful to actually separate the JSON part out.
08:07:38 <geekosaur> way too clever fr the next person who has to maintain it (including you 6 months down the road)
08:07:52 <geekosaur> depends on how entangled the superset is
08:08:03 <geekosaur> but mutually recursive sounds fairly entangled
08:09:00 * hackage tree-sitter-typescript 0.2.0.0 - Tree-sitter grammar/parser for TypeScript  https://hackage.haskell.org/package/tree-sitter-typescript-0.2.0.0 (patrick_thomson)
08:13:16 <sshine> so if the superset should eventually not be unambiguous, I'm left with a mess I'd be better off with if the parsers were combined.
08:14:46 <sshine> for example, if the superset included list comprehensions using a syntax where it's not obvious that it's not a plain JSON list until a while into the expression.
08:14:52 <geekosaur> tbh if it's unambiguous then t should be possible to pull the json out as a blob and pass it to another parser. if it's not unambiguous then (a) you can't sanely do that (b) and entangled parsers will be even worse than (a)
08:15:37 <geekosaur> or the other way around if the extension is embedded in the JSON
08:16:00 <sshine> geekosaur, well, the JSON can be interleaved with superset syntax anywhere where a sub-expression is possible. so that's why I figured I'd parameterize the sub-expression combinator.
08:17:36 <geekosaur> I think that's irrelevant. where it starts is not so much the question as where it ends; either you can easily tell where it ends and can extract it and feed it to a different parser, or you can't and you will go insane without a single parser for the whole thing
08:17:49 <sshine> actually, this is a bad idea. the superset supports an alternative syntax { foo, bar } to mean { "foo": .foo, "bar": .bar }, where .foo and .bar would be sub-expressions, but { foo, bar } is not close to JSON.
08:18:01 <sshine> right.
08:18:10 <geekosaur> (or the parser will go insane, as it were; it too has to be able to tell when to switch languages reliably, if you want separate parsers)
08:18:12 <sshine> this would have been a bad path to go down.
08:19:04 <sshine> doing this would mean a whole lot of 'try'ing and getting lost in the process.
08:19:21 <sshine> thanks.
08:21:49 <sshine> I'll have to wait doing something like this for when an embedded DSL is clearly delimited. :)
08:23:43 <ubuntunux> #haskell-kr
08:24:08 <ubuntunux> hi
08:24:29 <merijn> Clearly the solution is to replace it with Dhall ;)
08:24:34 <merijn> Anyway, gym time
08:26:15 <dminuoso> @tell iqubic start with this easy warm up (this is going to be the foundation for the next part) https://gist.github.com/dminuoso/a7568bd30407d7d3eb07d7c5770c29e0
08:26:15 <lambdabot> Consider it noted.
08:32:20 <infandum> With lens, how can I set a value in a list like: over (ix 3) (flip Map.lookup m) xs, so index 3 will be the value in the map m, but if it's not found then the entire thing returns Nothing?
08:32:59 <infandum> so the type would be f :: [a] -> Maybe [a]
08:33:48 <infandum> If possible
08:35:41 <infandum> I guess, is there something like preview for over?
08:36:31 <infandum> Well, maybe not a fold
08:37:30 * hackage require 0.4.3 - Scrap your qualified import clutter  https://hackage.haskell.org/package/require-0.4.3 (NickSeagull)
08:42:26 <lyxia> infandum: %%~
08:53:00 * hackage refined 0.4.3 - Refinement types with static and runtime checking  https://hackage.haskell.org/package/refined-0.4.3 (chessai)
09:04:58 <tom__> Has anyone set up SSL/TLS with Warp?
09:05:13 <tom__> I am passing the filepath to warp-tls as   tlsOpts  = tlsSettings "fullchain.pem" "privkey.pem"
09:05:37 <tom__> However despite these files existing in the root of the project when I do stack run I get
09:06:17 <tom__> server-exe: certificate.pem: openBinaryFile: does not exist (No such file or directory)
09:06:30 * hackage fei-base 0.2.0.0 - FFI to MXNet  https://hackage.haskell.org/package/fei-base-0.2.0.0 (JiasenWu)
09:07:30 * hackage fei-nn 0.2.0 - Train a neural network with MXNet in Haskell.  https://hackage.haskell.org/package/fei-nn-0.2.0 (JiasenWu)
09:09:00 * hackage fei-dataiter 0.2.0.0 - mxnet dataiters  https://hackage.haskell.org/package/fei-dataiter-0.2.0.0 (JiasenWu)
09:11:30 * hackage fei-cocoapi 0.2.0 - Cocodataset with cocoapi  https://hackage.haskell.org/package/fei-cocoapi-0.2.0 (JiasenWu)
09:12:30 * hackage fei-examples 0.3.0 - fei examples  https://hackage.haskell.org/package/fei-examples-0.3.0 (JiasenWu)
09:14:27 <infandum> lyxia: Perfect, thank you! It's hard to find these kinds of questions in the documentation...
10:11:16 <haskellbeginner> is there a Char function that returns true for spaces and punctuation marks but false for letter and "" characters
10:12:27 <haskellbeginner> similar to isSpace but broader
10:14:45 <aisn> can a record data type be an instance of functor?
10:16:01 <lyxia> aisn: https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Functor.Identity.html#Identity that's a record which is a functor
10:16:45 <srid> > uncurry . isSpace &&& isPunctuation $ 'a'
10:16:47 <lambdabot>  error:
10:16:48 <lambdabot>      â€¢ Couldn't match type â€˜Boolâ€™ with â€˜a -> b -> câ€™
10:16:48 <lambdabot>        Expected type: Char -> a -> b -> c
10:17:20 <srid> > (&&) . uncurry . isSpace &&& isPunctuation $ ';'
10:17:22 <lambdabot>  error:
10:17:22 <lambdabot>      â€¢ Couldn't match type â€˜(a0, b0) -> c0â€™ with â€˜Boolâ€™
10:17:22 <lambdabot>        Expected type: Char -> Bool
10:17:23 <aisn> thanks lyxia
10:18:47 <dmwit> > liftA2 (||) isSpace isPunctuation ';'
10:18:49 <lambdabot>  True
10:18:53 <dmwit> haskellbeginner: ^
10:19:13 <dmwit> Or you can spell it the easily-readable way: \c -> isSpace c || isPunctuation c
10:19:20 <srid> nice; too bad I missed the Applicative intuitive. not good for someone who is learning Category Theory :P
10:20:37 <srid> +1 for easily readable way. no need to complicate it (but it can be fun to understand how some things work)
10:23:07 <srid> > uncurry (||) . (isSpace &&& isPunctuation) $ ';'
10:23:10 <lambdabot>  True
10:24:38 <shapr> Is there some way to ask for all the instances of a typeclass on hackage?
10:24:47 <srid> > or . (isSpace &&& isPunctuation) ';'
10:24:49 <lambdabot>  error:
10:24:49 <lambdabot>      â€¢ Couldn't match type â€˜(Bool, Bool)â€™ with â€˜a -> [Bool]â€™
10:24:49 <lambdabot>        Expected type: Char -> a -> [Bool]
10:24:59 <srid> > or . (isSpace &&& isPunctuation) $ ';'
10:25:02 <lambdabot>  True
10:25:12 <shapr> I realized I want a Foldable instance for filesystems, then I wondered what other interesting instances I might find
10:25:32 <shapr> @help instances
10:25:32 <lambdabot> instances <typeclass>. Fetch the instances of a typeclass.
10:25:35 <shapr> oh
10:27:20 <shapr> nah, that's not exactly what I want. Can hoogle somehow list all the typeclass instances it found in a hoogle generate?
10:28:21 <shapr> oh it can!
10:28:35 <shapr> hoogle -l Foldable
10:31:30 <haskellbeginner> dmwit + srid thank you
10:31:40 <dmwit> ?instances Foldable
10:31:42 <lambdabot> Alt f, Ap f, Complex, Down, Dual, First, IM.IntMap, Identity, Last, Maybe, Product, Proxy, S.Set, Seq.Seq, Seq.ViewL, Seq.ViewR, Sum, Tree, ZipList, []
10:31:54 <haskellbeginner> guess that was so obvious i couldnt get it
10:31:57 <dmwit> shapr: Are you sure that ?instances isn't what you want?
10:32:06 <haskellbeginner> seems to be a pattern with learning haskell so far
10:33:33 <shapr> dmwit: I was hoping to find a Foldable for something filesystem related
10:36:48 <geekosaur> I'd argue the probllem there is filesystems aren't transactional so things can change, sometimes violently, in the middle
10:37:00 <geekosaur> what does your fold do if someonee removes a directory out from under you?
10:37:59 <shapr> it's a fair point, but I'm making up a hacky database using a dir of dirs holding json files
11:15:44 <alireza> hey guys
11:15:59 <alireza> I'm super new to haskell
11:16:06 <alireza> Do you have any idea how to run this on Docker?
11:16:07 <alireza> https://github.com/scslab/gitstar
11:16:46 <alireza> https://gist.github.com/azbshiri/6a9da0065c0abf6f181fe9e4d0916de2
11:17:01 <alireza> I cannot install dependencies
11:20:38 <catchme> alireza: so you want to install things from github?
11:22:45 <alireza> I want to run hails framework and its dependencies
11:22:57 <alireza> But I get errors that deps. don't exit on hackage
11:23:09 <alireza> I know it's pretty old but is there a way around this?
11:25:08 <catchme> https://stackoverflow.com/questions/38377521/haskell-stack-install-package-dependency-from-github
11:26:07 <jzyamateur> wanted to know that one cannot assert "f1::Float" followed by "f1::Num a => a",  where as the reverse is possible, why so?
11:27:29 <catchme> alireza: https://hackage.haskell.org/package/hails 
11:27:29 <catchme> deps exist!!
11:28:19 <dmwit> > let f1 :: Num a => a; f1 :: Float; f1 = 3 in f1
11:28:20 <lambdabot>  error:
11:28:21 <lambdabot>      Duplicate type signatures for â€˜f1â€™
11:28:21 <lambdabot>      at <interactive>:1:5-6
11:28:33 <dmwit> jzyamateur: I challenge your assumption that one can assert that in either order. ;-)
11:28:38 <dmwit> But I understand the question as it was intended.
11:28:59 <dmwit> And the answer is the usual one with polymorphism: the whole point of polymorphism is that you can specialize a polymorphic value to any monomorphic type (that satisfies the constraints).
11:29:33 <alireza> catchme
11:29:54 <dmwit> But it would be odd to go the other way; e.g. suppose I had a complex number, and I could generalize it to be of any Num type. Then since I can specialize again, I should be able to turn that into an integer. That doesn't make sense as a thing to allow.
11:30:19 <alireza> catchme how do I change build-depends with github?
11:30:20 <alireza> https://gist.github.com/azbshiri/0996d1298810ed81f93bbf60226a9b08
11:30:20 <dmwit> (Which integer does 3*i correspond to??)
11:30:34 <jzyamateur> Assume first one in the file and the following assertion in GHci. What I thought is that since Float has num instance, it should have been ok to do "f1::Num a=>a"
11:32:14 <jzyamateur> dmwit I got your point, you could arbitrarily switch between types if both ways are allowed.
11:38:21 <jzyamateur> Also what is the correct term for this syntax "expr :: AType" e.g. "read :: Int" ? Is it type assertion, is it coercion? Or has some other name?
11:38:42 <jzyamateur> *correct name to refer to above syntax
11:39:32 <jzyamateur> It kind of feels like casting values.
11:41:17 <catchme> alireza: I don't know to automate it
11:41:17 <catchme> you can use manual install `cabal install foo/foo.cabal` 
11:41:56 <koz_> jzyamateur: 'Type signature'.
11:42:38 <jzyamateur> Even as part of an expression, usually typesignature is written as a line of its own right?
11:43:20 <jzyamateur> e.g. "let x = (read input1 :: Int)
11:43:33 <lyxia> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003 "expression type signature"
11:44:00 <jzyamateur> cool, I'll take a look.
11:55:57 <koz_> For vector (the library), is it true that Prim a implies Unbox a?
12:12:00 * hackage finitary-derive 1.0.0.0 - Easy and efficient Unbox, Storable, Binary and Hashableinstances for Finitary types.  https://hackage.haskell.org/package/finitary-derive-1.0.0.0 (koz_ross)
12:16:51 <koz_> Argh, that line break hid the lack of space.
12:27:36 <maralorn> Huh, Hackage has a new design for freshly uploaded packages? koz_ did you do anything to make it look different?
12:27:53 <koz_> maralorn: Nope - that's with the Haddock from GHC 8.8.
12:28:43 <maralorn> koz_: So from know on all uploaded packages will look like that?
12:28:46 <maralorn> Cool!
12:28:57 <koz_> maralorn: I guess.
12:32:00 * hackage control-monad-omega 0.3.2 - A breadth-first list monad.  https://hackage.haskell.org/package/control-monad-omega-0.3.2 (LukePalmer)
12:51:07 <lyxia> uploaded packages still use the old look, but locally you probably have haddock with the new style by default
12:52:42 <lyxia> I mean when hackage builds the docs you still get the old look. You can still upload whatever docs you want.
12:53:38 <maralorn> Aaah, I didnâ€˜t know that the haddock is build locally.
13:10:57 <hyperisco> Is there a known version of Allen's interval algebra for cyclic orders?
13:13:02 <hyperisco> There are in fact ways several ways an interval can relate to itself
13:18:57 <rmeis> Hey, any ideas where to find the repository of DSP? The source repo linked on hackage is not available.
13:20:59 <rmeis> And any alternatives that don't work with [Double] but something more performant. I am still pretty new, but i woulde guess Data.Vector.Unboxed should be much faster.
13:21:18 <koz_> rmeis: Yeah, that should be better than a list.
13:21:29 <koz_> (depending on what you need, _much_ better)
13:23:06 <jle`> Nevoic: not sure if you've already solved your problem, but such a type signature is perfectly fine in Haskell :)
13:24:03 <jle`> that type signature even compiles haskell98
13:24:29 <rmeis> koz_: alright. This would require a complete rewrite of dsp, wouldn't it? 
13:25:20 <koz_> rmeis: I suspect so.
13:25:28 <koz_> DSP deals with like, fast Fourier transforms and such?
13:26:16 <rmeis> koz_: yes
13:26:31 <koz_> rmeis: Then yeah, likely.
13:26:45 <koz_> It wouldn't be a difficult rewrite, provided you actually understand this stuff (which I don't).
13:27:08 <maralorn> Can I get cabal to print me a buildplane while ignoring all the packages already installed by nix in the environment?
13:27:27 <maralorn> *build plan
13:27:37 <maralorn> no planes involved
13:27:50 <koz_> cabal build-plane :P
13:27:59 <koz_> (or should that be 'new-build-plane')
13:28:39 <rmeis> koz_: I do, but i should probably start with something smaller for my first package :)
13:29:04 <koz_> rmeis: As someone who's released _two_ for the first time recently - better to start with something you understand, and care about.
13:29:27 <koz_> If you have issues with specifics (like how to use Vector or w/e), you can always ask for help - we're pretty friendly here.
13:31:08 <o1lo01ol1o> rmeis:  also look at massiv and accelerate
13:32:38 <rmeis> o1lo01ol1o: oh thanks
13:57:11 <koz_> I second the massiv suggestion - it's a pretty mighty array library.
14:11:44 <merijn> Anyone know where I can find a copy of SPJ's graph on "language adoption/lifetimes"? I've seen it in a bunch of talks, but there's no copies of that image online where I manage to find it...
14:14:51 <koz_> merijn: It might be easier to just email SPJ and ask him for it.
14:16:04 <merijn> koz_: That's actually something that occurred to me as I was writing that, but I figured asking around before bothering him couldn't hurt :)
14:16:14 <koz_> merijn: Fair enough.
14:19:06 <merijn> In other news, if I hadn't been dumb and used Haskell for this code (and by extension optparse), I wouldn't be debugging dumb ass mistakes in a hand-rolled option parser at 23 at night >.>
14:21:37 <koz_> merijn: LOL.
14:22:38 <EvanR> something about counterfactual determinacy 
14:22:48 <koz_> EvanR: Counterfactual determinacy?
14:23:16 <EvanR> i dunno nevermind, late for work
14:23:17 <merijn> koz_: "counterfactual" is the fancy-pants way of saying "hypothetical situation" or ELI5 "what if?"
14:23:37 <koz_> merijn: I am aware of what a 'counterfactual' is. I'm not familiar with the term 'counterfactual determinacy', however.
14:24:04 <jle`> i wonder if an archive of lpaste exists anywhere
14:24:27 <merijn> jle`: Perhaps Chris has the data still?
14:24:55 <jle`> yeah i just realized that one of my posts references an lpaste as a 'historical document'
14:24:59 <merijn> I mean, I wouldn't have nuked that data for no reason
14:25:01 <jle`> but now the link is broken
14:25:35 <jle`> hm, storage is potentially expensive
14:25:43 <jle`> but i might ask
14:26:07 <merijn> jle`: It's plain text, how much storage could it possibly be
14:30:20 <jle`> maybe it was stored with 1000x redundancies
14:30:30 <jle`> because chris was a responsible data technician
14:31:05 <jle`> you know, the 1000000-mirror option for zfs
14:41:20 <koz_> jle`: With a cold-storage backup on platinum disks.
14:41:25 <koz_> In a bunker.
14:41:26 <koz_> In Iceland.
14:41:33 <jle`> it's only responsible
14:42:52 <koz_> Much responsible. Very security. Amaze.
15:18:00 * hackage print-console-colors 0.1.0.0 - Print all ANSI console colors  https://hackage.haskell.org/package/print-console-colors-0.1.0.0 (cdepillabout)
15:31:03 <merijn> Why do I sometimes get a .ghc.environment an other times I don't?
15:32:08 <Guest_99> hi
15:32:12 <Guest_99> I have a problem
15:32:22 <Guest_99> In order to run ghc and cabal, you need to adjust your PATH variable.You may want to source '/Users/phonemyataung/.ghcup/env' in your shellconfiguration to do so (e.g. ~/.bashrc).
15:32:26 <Guest_99> how do I do this?
15:34:09 <merijn> Guest_99: you literally add the line "source /Users/phonemyataung/.ghcup/env" to the end of $HOME/.bashrc or $HOME/.bash_profile (or equivalent for the shell you use)
15:48:47 <merijn> hmm, anyone got any suggestions why :info wouldn't list a typeclass that *is* defined?
15:49:11 <merijn> (and the module where it is defined in is imported...)
15:50:42 <hpc> is it exported?
15:53:57 <merijn> hpc: There is no export list limiting what's exported
15:54:41 <hpc> can you :info other things from the module?
15:54:59 <merijn> yeah
15:55:13 <hpc> can you use the class even if you can't :info it?
15:55:20 <merijn> yup
15:55:22 <hpc> omg
15:55:30 <merijn> *handwave* magic
15:55:57 <merijn> I guess I'll have to resort to -ddump-splices or whatever to see the code TH is generating, but I don't wanna >.>
15:58:00 * hackage vega-view 0.3.1.4 - Easily view Vega or Vega-Lite visualizations.  https://hackage.haskell.org/package/vega-view-0.3.1.4 (DouglasBurke)
15:58:02 <merijn> Definitely a problem for anoter day >.>
16:14:25 <iqubic> I love that Haddocks usually always give a minimal complete definition.
16:23:30 * hackage discord-haskell 1.1.1 - Write bots for Discord in Haskell  https://hackage.haskell.org/package/discord-haskell-1.1.1 (Aquarial)
17:11:34 <iqubic> dminuoso: Are you around?
17:20:40 <iqubic> Because the code you gave me has: "data Store s a = Store { runStore :: (s -> a) -> s }"
17:21:28 <iqubic> That seems wrong, because the 'a' is in a negative position, and therefore you can't create a functor for a 'Store s'
17:22:26 <dmwit> The normal definition for Store is to have (s -> a, s).
17:22:37 <dmwit> (Or something isomorphic.)
17:23:11 <iqubic> Right. But that's not what dminuoso gave me here: https://gist.github.com/dminuoso/a7568bd30407d7d3eb07d7c5770c29e0
17:23:43 <iqubic> In fact, dminuoso's code doesn't compile because of this: http://dpaste.com/1J19X95
17:23:59 <dmwit> So fix it.
17:24:16 <iqubic> I'm going to assume that it should be 'data Store s a = (s -> a, s)'
17:25:13 <dmwit> Good idea.
17:27:27 <iqubic> I have no idea how to make return.
17:27:33 <iqubic> return = \x -> Store (const x) _
17:27:44 <iqubic> I need to generate an s out of nowhere.
17:28:10 <dibblego> you can't make return
17:28:16 <dibblego> it's not a monad, it's a comonad
17:30:17 <iqubic> I'm not sure what dminuoso wants me to do here than.
17:39:55 <c_wraith> that just looks confused to me. 
17:40:16 <dibblego> what was the original question?
17:40:55 <c_wraith> https://gist.github.com/dminuoso/a7568bd30407d7d3eb07d7c5770c29e0
17:42:16 <dibblego> yeah even if that were (s -> a, s) you still can't do some of those
17:42:16 <iqubic> c_wraith: I know.
17:42:33 <iqubic> I'll have to ask dminuoso when they get back.
17:43:05 <dibblego> https://gist.github.com/tonymorris/148ddf3f569fa3bb856d64ca83b939d7
17:43:49 <c_wraith> that doesn't need any of those extensions anymore
17:44:11 <iqubic> I know. I know.
17:44:16 <turab> Hello, I tried to do something which obviously doesn't work so I am curious if someone here has a good insight/advice for solving this problem in the most ideal way.
17:44:30 * hackage hakyll 4.13.0.1 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.13.0.1 (JasperVanDerJeugt)
17:45:13 <turab> I found this problem while working on one of my assignment and found a solution that works better than what was suggested by the teachers, but I feel like I can solve this problem somehow using monads
17:45:27 <turab> My two attempts can be found here: https://gist.github.com/trajafri/df6131ad211f08a0c360ec50026d37c9
17:46:13 <turab> The problem is: Given an expression, bind all sub-operand calls to variables, therefore, there are no complex calls in any expression
17:46:18 <lyxia> what doesn't work
17:46:25 <turab> The monadic version
17:47:02 <turab> I think that's because I am trying to use the Cont monad in an improper way (or for something it is not fit to do)
17:47:05 <c_wraith> turab: could you include the definition of Exp? 
17:47:13 <turab> Sure, one sec
17:48:00 <lyxia> what is the error?
17:48:33 <turab> There isn't an error but it produces incorrect outputs. I can post one test case on the gist
17:50:16 <turab> I think that's because in my non-monadic version, I do not apply the continuation to the Let binding that I make. However, in Cont, return will apply the continuation.
17:52:00 <c_wraith> you're not using any Cont functionality there - it's not going to do anything, like that. 
17:52:21 <lyxia> oh yeah that's kind of tricky
17:55:00 * hackage hw-uri 0.1.1.4 - Supports IO on URIs  https://hackage.haskell.org/package/hw-uri-0.1.1.4 (haskellworks)
17:56:11 <turab> c_wraith: Correct, I merely used Cont to blindly mimic the non-monadic version. Cont definitely should not be used there.
17:59:24 <turab> No worries if this is a headache to read :) I was mostly curious if I can make the solution look more readable
18:00:59 <lyxia> it looks nice, and pretty close to a solution
18:01:33 <turab> lyxia: The monadic version?
18:02:12 <lyxia> yeah
18:02:50 <turab> Yea it looks super pretty but I got pretty sad once I realized I was calling return on the final expression :(
18:02:56 <c_wraith> I'm suspicious of the order of modify' and get in wrapWithLet
18:04:56 <c_wraith> oh, that's not the problem, exactly anyway. 
18:05:40 <c_wraith> the problem is the recursive calls to flatten take place before wrapWithLet within flatten 
18:06:13 <lyxia> is that a problem
18:07:03 <c_wraith> meaning you get the names set after the recursive calls have modified the state. yay, we're back into all the sane bugs mutability gives youv
18:07:12 <c_wraith> ... same bugs 
18:08:27 <lyxia> no that's not a problem because you only care about freshness here
18:08:44 <turab> Isn't that what's also done in the non-monadic version? Regardless of that, I would still get fresh vars
18:09:23 <turab> Didn't mention but the non-monadic version works perfectly
18:12:57 <lyxia> in the resulting program can you have nested lets,  let ... = ... let ... = ... in ... in ...
18:13:08 <lyxia> as opposed to let ... in let ... in
18:14:18 <turab> Nope
18:14:47 <turab> The idea is to make it similar to a C like language so it can be compiled easily
18:15:53 <lyxia> Ok then I think the continuation-passing is actually a distraction and all you're really doing is building up a stack of "let"s
18:17:09 <turab> Back when I wrote this, I couldn't think of an easy way to achieve this without passing around a continuation
18:18:27 <lyxia> a stack of Let is equivalent to a list [(Var, Exp)]  (where Var = Text in your code)
18:19:01 <turab> Ah so get a assoc list and then convert it to a let?
18:19:38 <turab> an assoc*
18:20:38 <lyxia> Yeah. you can also represent it as a (Exp -> Exp), that's a bit simpler to fold back to an Exp at the end.
18:21:39 <lyxia> but the point is to move away from Cont and instead put the stack in the state.
18:22:07 <lyxia> does that make sense
18:22:23 <turab> I will definitely try to write more solutions when I have more time.
18:22:31 <turab> I thought about that too I think
18:23:02 <turab> Unless I am misunderstanding you. What exactly do you mean by "represent it" when you mentioned (Exp -> Exp)
18:24:19 <lyxia> I mean a function like   (\e -> Let (x,e1) $ Let (y,e2) $ Let (z,e3) $ e)
18:25:00 <turab> Isn't that what I am doing currently?
18:25:57 <lyxia> kind of but in a roundabout way.
18:27:50 <turab> Could you show a non-roundabout way?
18:28:03 <lyxia> It's quite subjective, but to me it seems to mix concerns
18:30:15 <lyxia> one sec
18:30:51 <c_wraith> I feel like doing dumb GADT tricks to prevent illegal nesting of expressions in the output format, and then letting the type checker force you to get it right. 
18:32:07 <c_wraith> this is not actually a useful way to solve the problem in production code, but it sure forces you to get it right once. 
18:33:31 <iqubic> dumb GADT tricks are the best.
18:35:03 <lyxia> turab: https://gist.github.com/Lysxia/07e70b382adc3f295c36dee96f2060c9
18:35:59 <masaeedu[m]> how do i model functor composition for generalized functors?
18:36:36 <masaeedu[m]> by generalized functors i mean
18:37:00 <turab> lyxia: This is spicy! Thanks a lot
18:37:24 * masaeedu[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/NpSmnTNfwZBlbtasogaJyKlx >
18:38:14 <iqubic> That looks like similar to bifunctor.
18:38:37 <masaeedu[m]> it can be
18:38:49 <masaeedu[m]> it can also just be your standard `Functor`
18:39:13 <masaeedu[m]> it all depends on what the kinds `c` and `d` are
18:40:23 <lyxia> with this definition the problem is that you can't write (f (g x)) as some (fg x)
18:40:30 * masaeedu[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/BsoBQCoAzPUJnekvEGCrzBDd >
18:40:50 <lyxia> defunctionalize!
18:40:53 <masaeedu[m]> i.e. there's that `*` in there
18:41:04 <masaeedu[m]> i knew you'd say that
18:41:09 <masaeedu[m]> but it's so inconvenient
18:41:47 <masaeedu[m]> all the existing structures you'd want to witness become barely recognizable by the time you're finished wrapping and unwrapping them
18:42:13 <masaeedu[m]> i managed to do the thing from yesterday with GFix btw, but it's really ugly
18:43:32 <lyxia> that's the price for doing category theory in Haskell...
18:43:47 <masaeedu[m]> i should just go back to doing category theory in JS
18:44:37 <lyxia> how ugly does it actually get in this case though
18:45:26 * masaeedu[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/GFmcpFscxzZcNaSAIqOVoPMG >
18:45:45 <masaeedu[m]> the common things from haskell just unify straightforwardly with the general versions
18:46:37 <masaeedu[m]> in the case of the compose thing i'm trying to witness compositions of adjoint functors that various monads are representationally equivalent to
18:46:57 <masaeedu[m]> and to write the general purpose monad and comonad instance for those adjunctions
18:47:57 <masaeedu[m]> i'm already only barely grasping this stuff by the skin of my teeth, it gets really hard to manage when there's so many layers of wrapping and unwrapping that writing code is like swimming through molasses
18:49:03 <lyxia> https://gist.github.com/Lysxia/96c9dd35601f41bf385309dffb1bbfec
18:50:19 <masaeedu[m]> see i don't really get what's going on there
18:50:25 <masaeedu[m]> what is `@@`
18:50:53 <lyxia> it's fcf application
18:51:36 <lyxia> If you know first-class-families, you can guess what @@ does from the kinds of f, x and q.
18:51:49 * dsal is making orphans
18:52:18 <masaeedu[m]> what is the general pattern for defunctionalizing appropriately? should i be doing `Exp (c -> d)` or `c -> Exp d`
18:52:39 <lyxia> c -> Exp d
18:53:47 <masaeedu[m]> in general, should i be replacing all kind level `->`s with `-> Exp`s?
18:54:39 <lyxia> if you have more than one argument it's a tougher call between c -> d -> Exp e  or  c -> Exp (d -> Exp e)
18:55:02 <lyxia> if you have any reason to believe you are going to need partial application go for the latter, i.e., replace all -> with -> Exp
18:57:41 <masaeedu[m]> aggghhhhhh
18:57:43 <masaeedu[m]> ok, fine
18:57:44 <masaeedu[m]> thanks
18:57:57 <masaeedu[m]> why can't it just work the nice way
18:59:19 <lyxia> if you don't want to defunctionalize, then I suspect there is a way by wrapping p and q somehow in the "Compose" instance (where you won't be using Compose because that's the wrong kind)
18:59:31 <masaeedu[m]> i actually don't get what feature would even be needed in the language to be able to define something like `Compose` without defunctionalization
18:59:48 <lyxia> but you are going to need wrapping because (c -> d) is more structured than "functions from c to d"
19:03:23 <lyxia> proper type-level functions would be a good start, though it's probably a bit more than required
19:04:17 <lyxia> and also not sufficient if you care about type class resolution
19:04:47 <masaeedu[m]> does the matchable families stuff get us any of the way towards that?
19:04:56 <sicklorkin> what does `default` do? e.g. `import qualified Data.Text as T; default (T.Text)`
19:05:21 <masaeedu[m]> in particular, could i declare things like instances with respect to `Compose f g` if `Compose` was a type famiy (with the new stuff)?
19:05:24 <lyxia> masaeedu[m]: it does, but I haven't played with it yet
19:06:10 <iqubic> We don't yet have unsaturated type families, but I hear they are coming soon.
19:06:51 <masaeedu[m]> there's a branch with an implementation of the proposal
19:07:16 <sicklorkin> ahh default is giving a hint that all default constrains need to use Test
19:07:28 <sicklorkin> *Text
19:08:57 <lyxia> sicklorkin: ExtendedDefaultRules https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#extension-ExtendedDefaultRules
19:09:00 * hackage hs-ix 0.1.0.0 - Indexed monads  https://hackage.haskell.org/package/hs-ix-0.1.0.0 (MatthewFarkasDyck)
19:09:40 <sicklorkin> lyxia: ty
19:10:00 * hackage ix 0.1.0.0 - Indexed monads  https://hackage.haskell.org/package/ix-0.1.0.0 (MatthewFarkasDyck)
19:52:24 <dsal> I'm generating a bunch of C++ code.  Being pretty hacky, but I'm wondering if there's something that might make this slightly easier without a lot of overhead.
19:56:40 <dibblego> dsal: I know someone else who has been doing this, for quite some time, but they are not on this channel
19:57:08 <dsal> I'm just gonna keep hacking.  This is still far easier than writing the actual C++ code.
19:57:28 <iqubic> I feel the same way about Java
20:24:24 <Nevoic> Can wreq not do patch requests?
20:24:36 <Nevoic> I see get/post/put/delete.
20:25:16 <Nevoic> I tried doing a put instead of a patch but I'm getting an error back from the server "METHOD NOT ALLOWED" so it seems I need to send it as a patch.
20:25:48 <Nevoic> oh actually found "customMethod"
20:44:38 <rajivr___> I am new to Haskell. In `fmap` composition, `(fmap . fmap) :: (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)`, would I be right in understanding the kind of  `f1 (f2 a)` is `(* -> *) -> *` ?
20:44:58 <shachaf> The kind of f1 (f2 a) is *
20:46:16 <rajivr___> When fully inhabited, but in order to inhabit it, it would need `(* -> *) -> *`, I cannot for example inhabit it `*`
20:46:50 <shachaf> I don't know what you mean by "fully inhabited", but that's just always the kind of f1 (f2 a).
20:47:14 <shachaf> Maybe it would be easier to see if you used concrete f1 and f2. fmap . fmap :: (a -> b) -> Maybe [a] -> Maybe [b]
20:49:01 <rajivr___> Yes, that's a better way to think about it. Thanks for the example. What I was trying to get at is that I cannot construct a mapping `(a -> b) -> Maybe [a] -> Char`. That would not be a `fmap . fmap`
20:49:45 <rajivr___> The return value has to be something like `Maybe( [] x)`
20:49:51 <shachaf> Yes, because Char isn't f1 (f2 b)
20:50:45 <rajivr___> Thanks. That's want I wanted to confirm.
20:55:35 <rajivr___> Is it correct to say `f1 (f2 a)` has the structure `(* -> *) -> *`?
20:56:45 <slack1256> rajivr___: I don't think so, `f2 a :: *` ie is fully saturated, so `f1 :: * -> *`
20:56:52 <shachaf> I don't think it means anything, so it's probably not correct.
20:57:02 <shachaf> It's certainly not correct to say it has that kind, which I said above.
20:58:19 <rotaerk> hmm why aren't false asserts triggering?
20:58:42 <rotaerk> well, wait maybe I'm not checking all the appropriate places for flags...
21:00:05 <rotaerk> I don't have -O or -fignore-asserts in my .cabal file, nor in my cabal.project file
21:03:56 <rotaerk> meh, maybe the defaults have changed; I'll just add -fno-ignore-asserts
21:04:56 <turab> lyxia: Thanks again, I tried to use the idea you showed and it looks really cool!
21:08:47 <rajivr___> Thanks shachaf  slack1256 . Is my use of the terminology correct? A Type is inhabited by values. A Kind is saturated by types?
21:10:25 <shachaf> No, just say "inhabited".
21:10:53 <shachaf> Presumably "saturated" means "fully applied" here, but it's not very important.
21:11:18 <shachaf> You probably don't need to worry about kinds at all, but if you do, you should be fine with saying things like "a :: *" if you want to be explicit.
21:14:46 <rajivr___> Thanks again. shachaf . :-) 
21:48:13 <iqubic> A type is inhabited by values. A kind is inhabited by types
22:00:46 <mozzarella> iqubic: what's a higher kinded type?
22:01:19 <iqubic> Not sure.
22:01:26 <iqubic> I'd have to look that up.
22:01:46 * Lycurgus guesses kinds of kinds
22:02:09 <iqubic> Lycurgus:ly
22:02:21 <iqubic> Actually, that would be a sort.
22:02:32 <Lycurgus> i c
22:04:57 <heatsink_> A higher kinded type is like a higher order function
22:05:27 <heatsink_> It takes type constructors as arguments
22:05:52 <heatsink_> For example, Fix :: (* -> *) -> * is a higher kinded type
22:09:01 <c_wraith> it's a bit more liberal.  Maybe :: * -> * is usually called higher-kinded.
22:10:01 <shachaf> Hm, I don't think so?
22:10:08 <shachaf> But really words like these don't matter very much.
22:10:46 <shachaf> Seems the past half hour has been mostly people using complicated words. It's better to communicate clearly.
22:11:12 <jle`> hm, i don't think people would normally consider Maybe higher-kinded, but abstractions over Maybe wouild be considered higher-kinded
22:11:14 <jle`> like Functor
22:13:10 <jle`> but i suppose there is some ambiguity
22:15:48 <EvanR> simple english haskell, or xkcd haskell
22:16:48 <heatsink_> higher kinds are ways in which types of things can be made using ways of making types of things
22:19:04 <jle`> bring me a higher-kinded love
22:24:50 <monochrom> newtype Love m a = MkLove{beloved :: m (Either (a -> Void) a)}
22:26:37 <monochrom> higher-kinded Love that models wondering about "he loves me; he loves me not".
22:29:33 <iqubic> I love it
22:34:24 <jlamothe> I'm having a brain failure.  Is there a function in base that checks if some string is contained in another.  This feels like the soft of thing that should exist, but I"m not finding it.
22:35:07 <monochrom> isInfixOf
22:35:15 <monochrom> in Data.List
22:35:35 <jlamothe> Riiiiiiiiight.
22:35:47 <jlamothe> I was expecing it to be in Data.String, but that makes sense.
22:35:50 <jlamothe> Thanks.
22:47:38 <dminuoso> iqubic: Heh, it was actually a GADT style definition in my code that I unplugged and didn't modify correctly.
22:48:25 <dminuoso> iqubic: Anyway, the point was to convince yourself that this is indeed not Applicative or Monad.
22:48:50 <dminuoso> iqubic: Let's just focus on the Comonad instance.
22:49:47 <iqubic> http://dpaste.com/1PE7F8B
22:49:51 <iqubic> This is what I have.
22:50:37 <dminuoso> iqubic: Now the interesting part is the `experiment` implementation. It can be shown, that experiment fully characterizes Store.
22:50:45 <dminuoso> iqubic: Drop the Applicative/Monad instances.
22:50:58 <iqubic> I will.
22:51:24 <dminuoso> iqubic: To do that, enable RankNTypes, and rewrite `Functor, Comonad and ComonadStore` for this new data type
22:51:40 <dminuoso> iqubic: newtype Pretext s a = Pretext { runPretext :: forall f. Functor f => (s -> f s) -> f a }
22:52:29 <dminuoso> (This can be thought of as `experiment partially applied to some store`)
22:52:58 <iqubic> So I should create Functor, Comonad and ComonadStore for this?
22:53:01 <dminuoso> iqubic: Right.
22:53:11 <iqubic> I'll be back in a bit.
22:56:32 <iqubic> Pretext only takes one argument?
22:56:49 <iqubic> dminuoso: Is that right?
22:57:33 <dminuoso> iqubic: Yes.
22:57:54 <iqubic> Weird.
22:58:20 <iqubic> Writing fmap is stumping me.
22:58:34 <iqubic> I have this: "fmap f (Pretext g) = Pretext _ "
22:59:01 <jle`> remember the mechanical construction of a Functor instance
22:59:19 <jle`> if your type has form Blah (f a), and f is a Functor, then you can write fmap by fmapping over f
22:59:27 <iqubic> Right. Right.
23:00:17 <jle`> it might help to look at `(s -> f s) -> f a` as a specific functor on a
23:00:27 <iqubic> Right.
23:01:00 <jle`> which unfortunately requires some point-free trickery maybe to do it mechanically
23:01:05 <iqubic> Right.
23:01:10 <jle`> or maybe not. the -> being infix obscures it
23:03:03 <iqubic> I'm a bit lost here.
23:03:13 <dminuoso> iqubic: Sit back, relax, and look at what you have.
23:03:25 <dminuoso> iqubic: Look at what you need to produce, and consider that you have a very very limited amount of things in your hands.
23:04:28 <iqubic> I have an 'a -> b' and an '(s -> f s) -> f a'
23:04:33 <jle`> spoilers don't read: (s -> f s) -> f a is ReaderT (s -> f s) f a
23:05:12 <dminuoso> iqubic: not quite!
23:05:17 <iqubic> Why not?
23:05:23 <dminuoso> iqubic: There's additional quantificatoin in there.
23:05:44 <iqubic> I know that f is a functor.
23:05:49 <dminuoso> iqubic: You have something of type `forall f. Functor f => (s -> f s) -> f a`
23:06:03 <dminuoso> This is important.
23:06:10 <iqubic> So if I can get access to that f a, then I can fmap over it and get the f b.
23:06:25 <jle`> you also have something else
23:06:31 <iqubic> What do I have?
23:06:42 <jle`> fmap f (Pretext g) = Pretect $ \h -> ...
23:06:45 <jle`> *Pretext
23:06:50 <jle`> you have h :)
23:06:56 <iqubic> Oh.
23:07:51 <iqubic> I got it.
23:07:57 <iqubic> "fmap f (Pretext g) = Pretext (\h -> f <$> g h)"
23:08:06 <dminuoso> iqubic: Does it type check?
23:08:11 <iqubic> Yes.
23:08:28 <jle`> my other hint was that because (s -> f s) -> f a is ReaderT (s -> f s) f a, you can also write fmap f (Pretext g) = Pretext $ (fmap . fmap) f g
23:08:36 <iqubic> And hlint tells me I can rewrite it as:   "fmap f (Pretext g) = Pretext $ fmap f . g"
23:08:48 <dminuoso> iqubic: ^- look at jle`s hint, this strick can be useful later on.
23:09:50 <jle`> or rather ((->) (s -> f s) :.: f) a, not necessarily reader
23:09:50 <iqubic> How does the "Pretext $ (fmap . fmap) f g" work?
23:10:03 <jle`> iqubic: note (s -> f s) -> f a is taking f through "two layers" of functors
23:10:04 <dminuoso> iqubic: `(->) a` is a Functor.
23:10:08 <jle`> first a is applied to the 'f' Functor
23:10:15 <jle`> then it is applied to the (->) (s -> f s) Functor
23:10:21 <iqubic> I see.
23:10:27 <jle`> so (fmap . fmap): first lift through (->) (s -> f s) functor
23:10:36 <jle`> then lift through 'f' Functor
23:10:43 <iqubic> I see.
23:10:52 <iqubic> Time to make a comonad for this.
23:10:53 <jle`> although i think the first way you wrote it is the most readable
23:10:58 <dminuoso> iqubic: So. Now the Comonad and ComonadStore instances are the really tricky ones.
23:11:06 <dminuoso> iqubic: Take your time on these. :)
23:12:09 <iqubic> I will.
23:13:04 <iqubic> extract :: Pretext s a -> a
23:13:47 <iqubic> I have a function of type 'forall f. Functor f => (s -> f s) -> f a' And I need to extract an 'a'?!?!
23:13:53 <iqubic> I don't think that is possible.
23:13:53 <dminuoso> iqubic: Yes.
23:14:07 <dminuoso> iqubic: I guarantee: You can write these instances and they will be lawful.
23:14:15 <iqubic> How do I extract the a?
23:14:16 <dminuoso> iqubic: And I furthermore guarantee that Pretext is isomorphic to Store.
23:14:28 <dminuoso> iqubic: Well that's the challenge..
23:14:59 <iqubic> I don't even know where to begin.
23:15:10 <jle`> iqubic: here's a hint -- this thing works for all Functors
23:15:21 <jle`> so the trick is picking exactly a Functor that will give you exactly what you want
23:15:30 <jle`> usually you can even make one "from scratch" contrived to do exactly that
23:15:45 <iqubic> How?
23:15:58 <dminuoso> iqubic: Ponder about it for a while.
23:15:58 <jle`> my strategy usually is: look at the reuslt, 'f a'
23:16:03 <jle`> and the thing you want is 'a'
23:16:12 <dminuoso> iqubic: If something is in a negative position, you need to supply something.
23:16:17 <iqubic> Right. And it works forall f.
23:16:20 <jle`> so you have to pick some 'f' you want to use (maybe even make it from scratch) so that 'f a' is exactly f
23:16:28 <jle`> er sorry, that 'f a' is exactly 'a'
23:16:38 <iqubic> Isn't that just Identity?
23:16:44 <dminuoso> iqubic: I dont know, is it?
23:16:55 <jle`> if you suspect Identity, then try using it with f ~ Identity
23:17:09 <iqubic> Will I need to import Identity?
23:17:20 <jle`> that would be very convenient, because the 'f a' you get from the function is 'Identity a', which is just 'a'
23:17:21 <dminuoso> iqubic: Sure, or write it on the spot. Whatever you prefer.
23:17:41 <jle`> very convenient indeed
23:19:21 <jle`> this strategy works in general: "i need to get X", so you need to find a functor F where 'F a' is X
23:20:02 <jle`> and usually the easiest way is `data MyFunctor a = MyFunctor X`, just make it up on-the-spot
23:20:07 <dminuoso> iqubic: So here's two lines of thought. The forall quantification lets *you* pick the functor, that's the weight of that `forall`
23:20:18 <iqubic> I didn't realize that.
23:20:19 <dminuoso> iqubic: And if something is in negative position, you can/have to supply it.
23:20:20 <jle`> if sometimes you recognize it as a common functor that already exists, you can use that too if you are super clever
23:20:56 <dminuoso> iqubic: So if you hold something of type `Pretext s a`, it means you can pry it open, supply some function `s -> f s` for whatever functor you like, and you get some `f a` back
23:21:25 <dminuoso> iqubic: so the only way to obtain something back, is by supplying such a function. recall how I said that Pretext is just experiment partially applied to a store? You have to supply the experiment function now to get anything out of it.
23:21:39 <iqubic> Alright: (s -> f s) is going to be (\x -> Identity x), I think.
23:21:57 <iqubic> Or literally just Identity.
23:22:00 <dminuoso> :-)
23:22:31 <atralheaven> Hi, I'm not a haskell programmer, but I'm trying to understand functional programming. 
23:22:37 <dminuoso> Hi atralheaven. :)
23:23:50 <dminuoso> iqubic: Or in other words: the only thing you can do with your Pretext, is run some experiment on the (internal) Store.
23:24:03 <atralheaven> In haskell, everything is not a function, right? it's imperative programming + functions?
23:24:07 <dminuoso> atralheaven: Nope.
23:24:28 <dminuoso> atralheaven: Or.. well. Yes. Not sure how one would correctly answer this in English heh.
23:24:34 <dminuoso> atralheaven: Not everything is a Function, correct.
23:25:06 <dminuoso> atralheaven: Haskell is foremost declarative, rather than imperative. But we can model imperative programming using function tricks.
23:25:16 <atralheaven> dminuoso: I guess it would be no, and yes!
23:25:35 <no-n> True
23:25:47 <monochrom> "xyz" is a string not a function.
23:26:15 <dminuoso> atralheaven: One important part is that when we talk about functions, we mean it in the original mathematical sense.
23:26:37 <iqubic> I can't make this work.
23:26:50 <dminuoso> iqubic: It took me an evening to wrap my head around it.
23:26:52 <atralheaven> and functions cannot have side effects, by design, or they can but programmers avoid it?
23:27:01 <dminuoso> atralheaven: they cannot
23:27:42 <jle`> atralheaven: in haskell, eveything is a value
23:27:49 <iqubic> "extract (Pretext g) = getIdentity $ (fmap . fmap) _ _"
23:27:52 <atralheaven> dminuoso: I almost know nothing about math, I see functions as input >> do something to input >> output
23:28:00 <jle`> atralheaven: in traditional imperative languages, you have values and statements
23:28:15 <dminuoso> iqubic: Start by implementing the `experiment` method of ComonadStore.
23:28:16 <jle`> atralheaven: so what haskell does is eliminate statements (at least, those built into the language/syntax)
23:28:29 <dminuoso> iqubic: This is just for added elegance, it avoids some of the unnecessary unwrapping.
23:28:39 <dminuoso> iqubic: And then write the rest in terms of `experiment`
23:28:40 <iqubic> dminuoso: Is that easier than this?
23:28:56 <jle`> iqubic: try going about extract (Pretext g) = _ $ g Identity
23:29:09 <jle`> since you know you want to give g 'Identity', the s -> f s
23:29:17 <dminuoso> atralheaven: We dont "do something"
23:29:44 <dminuoso> atralheaven: That is, a function is a mapping of values, not a sequence of commands to be executed. Its sadly a term some imperative programming languages have used wrongly.
23:29:52 <atralheaven> jle`: how can it not have any statements? may you tell me what an statement is here?
23:30:17 <jle`> atralheaven: sure; a statement is something that, when control reaches it, executes some effect
23:30:35 <jle`> atralheaven: in other languages, statements are things like x = 3 (assign 3 to the box x), print "hello", read a file, etc.
23:30:49 <jle`> atralheaven: so how control flow works is: proceed from statement to statement
23:30:59 <jle`> and execute the effect that each statement represents
23:31:02 <atralheaven> jle`: right
23:31:21 <iqubic> What the hell???
23:31:23 <jle`> contrast that to values: values are things that represent ... well, values
23:31:23 <dminuoso> iqubic: I'd say say.
23:31:28 <iqubic> "experiment f (Pretext g) = g f"
23:31:44 <dminuoso> iqubic: I told you. Pretext is just experiment partially applied to a Store.
23:31:46 <dminuoso> :-)
23:31:50 <jle`> atralheaven: they represent concepts and things you can manipulate within the language, like 3, True, "hello", etc.
23:32:20 <jle`> atralheaven: so in other languages, the concept of a statement and of a value are sort of muddled together, but there is a rough distinction between the two, conceptually
23:32:40 <jle`> atralheaven: in Haskell we only have values, no statements (at least not built into the syntax)
23:33:16 <dminuoso> iqubic: (What experiment buys you, is just avoiding pattern matching on Pretext)
23:33:22 <dminuoso> It gets a bit cleaner.
23:33:46 <dminuoso> And it emphasizes that all you do here, is running experiments on some Store
23:33:48 <iqubic> "extract g = getIdentity $ fmap _ _"
23:34:00 <jle`> iqubic: well, you don't know you need getIdentity, and you don't know you need fmap
23:34:10 <jle`> iqubic: all you know is that you want to apply your (s -> f s) to g, right?
23:34:17 <jle`> so start there
23:34:24 <jle`> extract (Pretext g) = _ $ g Identity
23:34:35 <jle`> since Identity is your s -> f s that you decided on
23:34:51 <jle`> the only thing you *know* you have to have is `g Identity`
23:35:12 <dminuoso> atralheaven: The important bit here though is to understand that the lack of statements built into the language is not limiting, it's actually a liberating factor.
23:35:21 <shachaf> I suggest taking the Pretext conversation to #haskell-overflow.
23:35:23 <jle`> so no use adding getIdentity/fmap _ _/etc. just because you 'feel' like it
23:35:35 <shachaf> It's been going on for almost an hour and it's drowning out other conversations.
23:35:39 <iqubic> "extract g = getIdentity $ experiment Identity g"
23:35:49 <atralheaven> jle`: so, there are values, and functions. can values be functions too? like giving a function as input to another function?
23:35:57 <dminuoso> atralheaven: Yes. Functions are just values.
23:36:00 <dminuoso> atralheaven: And indeed.
23:36:10 <jle`> atralheaven: yup :)
23:36:15 <jle`> that is what is meant by "everything is a value"
23:36:21 <dminuoso> atralheaven: We can pass functions as arguments, or produce functions as result values.
23:36:29 <jle`> in particular, it's a way of saying that functions are values, as well 
23:36:38 <iqubic> dminuoso: I have made extract.
23:36:51 <dminuoso> iqubic: Let's follow shachaf's suggestion and take it to #haskell-overflow
23:37:28 <atralheaven> sorry I don't know why but I can't scroll to old messages, you said functions map what to vales?
23:37:36 <dminuoso> atralheaven: values to values.
23:37:49 <dminuoso> atralheaven: A function is just something where you ask "what's the corresponding value to x"
23:38:02 <dminuoso> That's what I meant by "we have functions in the mathematical sense"
23:38:39 <atralheaven> I remembered something from school, like f(x) = y or something...
23:38:59 <dminuoso> atralheaven: Yes, and we write functions pretty much like that.
23:39:11 <dminuoso> We just dont bother writing the parens.
23:39:18 <atralheaven> so where the manipulation happens?
23:39:25 <dminuoso> atralheaven: Manipulation of what? :)
23:39:30 <atralheaven> values?
23:39:45 <atralheaven> like, you want to remove a character from string
23:39:49 <jle`> that's what haskell-the-language gives you: a way to specify how your outputs relate to your inputs
23:39:57 <jle`> for example: addTwo x = x + 2
23:40:15 <jle`> atralheaven: for that you would refer to the API of the string type you are using
23:40:41 <jle`> it might provide a function to remove a given cahracter from your string, like Char -> StringType -> StringType, and you can use that with `removerCharacter 'a'` or something
23:40:48 <jle`> it's probably not as magical as you might think it is :)
23:41:06 <dminuoso> atralheaven: The point is, a function cannot *manipulate* a value.
23:41:23 <jle`> ah yeah, your function would take a string and return a new string, with that character removed
23:41:34 <atralheaven> I mean, how can you remove the character only with mapping values to each other?
23:41:53 <jle`> atralheaven: think of the map conceptually
23:42:05 <jle`> removing all a's would map "hello" to "hello"
23:42:11 <jle`> it would map "ball" to "bll"
23:42:19 <jle`> "backpack" to "bckpck"
23:42:23 <atralheaven> yes
23:42:46 <jle`> are you asking how you would *define* such a function, maybe?
23:42:51 <atralheaven> but how do you write it? how you tell the program to do so?
23:42:56 <atralheaven> yes
23:42:57 <jle`> if that's what you are asking, the answer depends on what your string type is
23:43:04 <jle`> the structure of your type determines how you write functions on it
23:43:06 <dminuoso> _ashbreeze_: you could write this as:
23:43:12 <dminuoso> dropFirstElem (x:xs) = xs
23:43:16 <dminuoso> err atralheaven ^- :)
23:43:26 <jle`> with 'String' for example, you would write:
23:43:31 <jle`> removeAllAs = filter (/= 'a')
23:43:47 <jle`> where filter is the function that takes a predicate and removes all matching items from a list
23:43:54 <atralheaven> well, how many string types do we have? we only have one in python :D
23:43:55 <jle`> > filter (/= 'a') "backpack"
23:43:58 <lambdabot>  "bckpck"
23:44:04 <jle`> > filter (/= 'b') "backpack"
23:44:07 <lambdabot>  "ackpack"
23:44:20 <jle`> atralheaven: well, my point is that how you define the function depends on the type you are working with, and its API
23:44:22 <jle`> and its structure
23:44:34 <jle`> atralheaven: it isn't something that is universal that we can talk about while ignoring the structure/specific type :)
23:44:54 <jle`> but yeah, for String in the base libraries, we have the 'filter' function which allows us to filter out characters matching or not matching a given condition
23:45:12 <jle`> filter is actually one of the functions you were thinking about earlier --- it's a function that takes a function as input 
23:45:35 <jle`> > filter isAlpha "hello world"
23:45:37 <lambdabot>  "helloworld"
23:45:38 <jusss> :t amb
23:45:40 <lambdabot> error: Variable not in scope: amb
23:46:01 <jle`> > filter isDigit "h3ll0 w0rld"
23:46:02 <jusss> is there an amb function in haskell?
23:46:03 <lambdabot>  "300"
23:46:36 <jle`> atralheaven: so if i wanted to write a function to remove all a's from my string, i'd write `filter (/= 'a')`
23:46:45 <atralheaven> I understand what you mean by function and map here, but I still don't understand what you mean by not having manipulation 
23:46:46 <jle`> or "filter for only items that aren't 'a'"
23:47:09 <jle`> i think maybe the intent was to say that functions cannot mutate values
23:47:34 <jle`> i'm not really sure what it would mean to say 'functions cannot manipulate values' either
23:47:49 <atralheaven> well, they return new values, it's fine
23:48:19 <jle`> indeed :) it's a relationship. filter (/= 'a') takes a string and returns a string that has all a's removed
23:50:05 <jgt1> jusss: https://www.rosettacode.org/wiki/Amb#Haskell
23:50:26 <atralheaven> That's actually intresting, but it's a little hard to understand how would you do what we're used to do in languages like python
23:51:08 <atralheaven> imperative languages
23:51:11 <jle`> atralheaven: yeah, a lot of times it involves looking at the problem in a new way, and focusing on the goal instead of the specific solution
23:51:12 <dminuoso> atralheaven: Note here too, that memory manipulation still exists in Haskell.
23:51:33 <jle`> atralheaven: so for example people might experience a vertigo when they see that there are no "for loops" in the python sense
23:51:40 <dminuoso> atralheaven: We have an entire toolset for writing highly imperative code, for writing mutable state, manipulating memory and all. So these restrictions are not limiting to how we write code.
23:51:52 <jle`> atralheaven: "but then how will i write for loops?" is a common question
23:52:05 <atralheaven> with map?
23:52:07 <jle`> atralheaven: but in the end the thing is that the things you would use for loops for in python are things that you would use different things for in haskell
23:52:22 <jle`> yeah, higher-order functions like map are one way
23:52:33 <atralheaven> what about conditions?
23:52:50 <jle`> > if 3 > 5 then "hi" else "bye"
23:52:52 <lambdabot>  "bye"
23:53:17 <atralheaven> so we do have ifs here
23:53:29 <jle`> yeah, except if is also just an expression representing a value
23:53:38 <jle`> and not a statement for conditional execution/control flow
23:54:04 <jle`> `if True then x else y` can be replaced with x, and `if False then x else y` can be replaced with y
23:54:10 <jle`> s/can be replaced with/evaluates to
23:54:30 <jle`> but again, the things you would use conditionals for in python are pretty wide
23:54:40 <jle`> and the exact thing you would replace them with in haskell might not necessarily "exist"
23:55:00 <atralheaven> what does an expression mean here?
23:55:01 <jle`> but in the end you might end up approaching the problem from another angle
23:55:11 <jle`> an expression is syntax for denoting a value
23:55:22 <jle`> so `if True then x else y` is an expression that denotes the value x
23:55:35 <jle`> or well, `if True then 1 else 2` is an expression that denotes the value representing the number one
23:55:58 <jle`> similarly `filter (/= 'a')` is an expression that denotes the function filtering out a from a string
23:56:18 <jle`> other languages have a similar notion of expression vs. statement as well
23:56:49 <jle`> but i guess the important thing is that expressions are syntax
23:57:31 <jle`> `if x then y else z` is in the same syntactical "group" of things as True, [1,2,3], "hello", etc.
23:57:58 <jle`> in fact `if True then "hello" else "goodbye"` can be replaced in a program with "hello" and it would be fine, syntactically and semantically
23:58:31 <jle`> that's what i meant to convey --- it exists on the same "level" as other expressions like True/"hello"/[1,2,3]/etc.
23:58:43 <jle`> contrast this to in python where if/then/else is a statement for control flow
23:59:01 <atralheaven> yes, but only when the condition doesn't change, but it does change, that's why we use ifs
23:59:39 <jle`> in python, if/then/else is a statement: it controls what effects are executed, not what values are being denoted
23:59:50 <atralheaven> yes
