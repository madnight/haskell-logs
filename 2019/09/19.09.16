00:00:06 <masaeedu[m]> sure
00:00:07 <mniip> and it's contained within this effectful subroutine
00:01:25 <masaeedu[m]> yes, pure computation is a special case of effectful computation that doesn't perform any effects
00:01:30 * hackage cabal-plan 0.6.0.0 - Library and utility for processing cabal's plan.json file  https://hackage.haskell.org/package/cabal-plan-0.6.0.0 (phadej)
00:02:03 <masaeedu[m]> my point is you don't have stuff like in the frank language
00:02:21 <Ariakenom> ski: I've read it before but I'm reminded that SPJ's papers are so nice to read
00:02:58 <koz_> Ariakenom: Which paper?
00:03:03 <masaeedu[m]> where your side effects are associated with the language's constructs for abstraction and application
00:03:08 <jgt> SPJ is the only person who can make Comic Sans acceptable
00:03:43 <Ariakenom> koz_: /ski . o O ( "Compiling without Continuations" by Luke Maurer,Paul Downen,Simon Peyton Jones in 2017 at <https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/join-points-pldi17.pdf> )
00:04:01 <koz_> Ariakenom: Thanks!
00:04:01 <mniip> so you're asking for a language where the typing rules for abstraction and applications account for effectful arrows?
00:04:20 <masaeedu[m]> right, exactly
00:04:26 <masaeedu[m]> i mean i'm not asking for that
00:04:37 <masaeedu[m]> i was just wondering if someone's already hacked something like that into ghc somehow
00:04:40 <mniip> that can be achieved with a layer of sugar over haskell
00:04:48 <masaeedu[m]> e.g. by overloading application syntax somehow
00:05:05 <mniip> ah nah, too much stuff already hinges on application syntax
00:05:10 <ski> masaeedu[m] : i wouldn't want that .. at least not in the form i suspect you envisage it
00:05:36 <ski> (rather, i wouldd not want that)
00:05:59 <mniip> I wouldn't dare to imagine what kind of bizzare type errors you would get if you lost at least one direction of type inference in application
00:06:05 <mniip> and you will lose at least one
00:06:17 <mniip> e.g. in `undefined x` you don't know which arrow the undefined is
00:07:05 <ski> part of the point of Haskell is to be able to rely on "equational reasoning" when refactoring and otherwise reasoning about code. not having side-effects
00:07:18 <mniip> that's somewhat beside the point
00:07:35 <masaeedu[m]> that's alright. i just think it'd make for an interesting point in the space of modeling effects. right now the only languages that associate effects with arrows are impure languages without good type systems
00:07:48 <masaeedu[m]> well, non-academic/niche languages
00:08:16 <Ariakenom> masaeedu[m]: what do you want from that design?
00:08:29 <Ariakenom> (what advantage)
00:09:26 <masaeedu[m]> well, i'd maybe want the ability to model "coeffects"
00:09:47 <ski> (i've been pondering a way to have "lexical side-effects", which i think could be reasonable. but if any application could be a side-effectful application, then i'd not want that, tyvm)
00:10:02 <ski> mhm, masaeedu[m]
00:10:09 <mniip> coeffects as in cokleisli arrows?
00:11:19 <masaeedu[m]> i haven't tried using cokleislis to model coeffects. the "coeffects as in x" being as in the Tomas Petricek stuff
00:11:39 <masaeedu[m]> can you newtype the same thing as a kleisli and a cokleisli?
00:12:11 <mniip> ?
00:13:50 <pagoda_5b[m]> masaeedu: do you have any learning material on coeffects as you're mentioning, the Petricek stuff?
00:14:19 <masaeedu[m]> there's a really nice approachable blog/interactive whitepaper/idk what thing that Tomas Petricek has on his site
00:14:30 <masaeedu[m]> http://tomasp.net/coeffects/
00:14:31 * hackage servant-elm 0.7.0 - Automatically derive Elm functions to query servant webservices.  https://hackage.haskell.org/package/servant-elm-0.7.0 (k_bx)
00:14:58 <masaeedu[m]> you can even zoom in and out to the level of detail you want to read at
00:15:57 <masaeedu[m]> i haven't found any other stuff (like blog posts or whatever), but i want someone to explain some practical use cases too
00:16:09 <masaeedu[m]> e.g. how to use them in haskell
00:27:17 <pagoda_5b[m]> thanks for the precious references masaeedu 
00:27:24 <ski>   Kleisli (Reader ρ) α β  ≅  α → Reader ρ β  ≅  α → (ρ → β)  ≅  ρ × α → β  ≅  Env ρ α → β  ≅  Cokleisli (Env ρ) α β
00:28:32 <Ariakenom> masaeedu[m]: that notion of requirements seem common in haskell. STM: requires us to be in a stm-transaction. I believe there are DB types that require DB connections or transactions. optparse-applicative is within the context of parsing CLI arguments.
00:38:07 <mniip> ski, Cokleisli w = Kleisli (Co w)
00:46:39 <ski> that's a type family, right ?
00:46:50 <ski> does it go the other way, as well ?
00:46:58 <ski> is it involutive ?
00:49:29 <masaeedu[m]> ski: are you asking about `Co`?
00:50:31 <masaeedu[m]> i might be wrong, but i think that's the "monad sandwich" thing from an Ed Kmett blog post
00:51:40 * ski didn't see it
00:52:03 <ski> (well, i probably saw people refer to `Co'. but i didn't look into it)
00:53:38 <masaeedu[m]> http://comonad.com/reader/2011/monads-from-comonads/
00:55:10 <masaeedu[m]> the basic idea is that whenever you have a composition of adjunctions, there's a monad "sandwiched" inside the monad it gives rise to (there's also a comonad sandwiched inside the comonad it gives rise to, but we don't care about that for a sec)
00:55:58 <masaeedu[m]> also `Cont` is made out of a self adjunction of the contravariant functor `_ -> r`
00:56:58 <masaeedu[m]> (i.e. the functor goes from Hask^op to Hask)
00:57:50 <masaeedu[m]> so if you compose the adjunction underlying any comonad with the adjunction underlying `Cont`, you end up getting a "sandwiched" comonad in Hask^op, which is actually a monad in Hask
00:58:23 <masaeedu[m]> sorry, forgot to mention the "sandwiched" thing is always in the target category of the adjunction
00:58:53 <masaeedu[m]> or the "outer" adjunction of the composition rather
00:59:10 <masaeedu[m]> lol, sorry i'm probably butchering this. ignore everything above and just read the article
00:59:44 <shachaf> If you mean "Co w a = forall r. w (a -> r) -> r", the "basic idea" is appealing but it doesn't really work.
00:59:52 <shachaf> Because of the forall.
01:00:23 <masaeedu[m]> shachaf: sorry, were you responding to me?
01:00:45 <shachaf> I guess so?
01:01:06 <shachaf> Cont isn't "Cont a = forall r. (a -> r) -> r", it's "Cont r a = (a -> r) -> r"
01:01:18 <shachaf> The adjunction is (-> r) -| (-> r)^op
01:01:39 <shachaf> It doesn't really work anymore (at least not the same way) when you quantify over r like that.
01:03:47 <masaeedu[m]> hmm. but wouldn't `Co r w a = w (a -> r) -> r` be a monad even without quantifying?
01:05:44 <shachaf> I'm not sure! It would be a different once, certainly.
01:05:49 <masaeedu[m]> also surely `type BasicallyIdentity a = forall r. (a -> r) -> r` is a monad too?
01:06:22 <masaeedu[m]> with an underlying self adjunction from Hask_op to Hask
01:06:39 <shachaf> Certainly Identity is a monad.
01:06:42 <masaeedu[m]> *self adjunction of a functor from ...
01:07:14 <shachaf> But it's not one that you get from this kind of adjunction, is it?
01:07:49 <masaeedu[m]> hmm, sorry. don't quite grok the question
01:08:19 <shachaf> Well, it's not one you get from (-> r) -| (-> r)^op like Cont.
01:08:29 <shachaf> Maybe an end or something.
01:11:36 <shachaf> Maybe I just missed the thrust of this conversation.
01:12:29 <masaeedu[m]> i was just sharing the `Co` article from ed kmett's blog, i don't think you missed anything
01:12:41 <masaeedu[m]> i had some notes a while ago where i (thought i had) worked out why it works
01:13:02 <masaeedu[m]> https://gist.github.com/masaeedu/5892050bbbbef8d7601a96750b455724
01:13:21 <masaeedu[m]> i guess i need to confirm whether everything still works without quantifying
01:15:59 <masaeedu[m]> well, it all typechecks if i just copy paste everything from his blog post and dequantify it
01:16:46 * masaeedu[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/dhHPIcjzOfEQyRrudaTgdfCT >
01:17:23 <masaeedu[m]> maybe i'm being overly optimistic, but i don't think removing the quantification breaks correctness in any way
01:17:35 <shachaf> What is correctness?
01:18:14 <masaeedu[m]> i mean all the laws still holdl
01:18:33 <masaeedu[m]> and the `type OriginalCo w a = forall r. Co r w a` is the same as the `Co` defined in his blog post
01:19:15 <shachaf> That statement is certainly true.
01:19:49 <masaeedu[m]> ok. so looking at it as arising from a composition of the adjunctions underlying `Cont` and some comonad makes sense i think
01:19:55 <masaeedu[m]> the quantification is mostly irrelevant
01:31:01 <ski> masaeedu[m] : hm, okay. ty
01:32:22 <hoppfull> Hello, a ring represents the maths of multiplication and addition and other similair things, string appending too I suppose. Is there something representing operations that annihilate each other? Like x + y - y = x or head (x : y) = y
01:32:38 <merijn> hoppfull: Group?
01:33:00 * hackage vector-sized 1.4.0.0 - Size tagged vectors  https://hackage.haskell.org/package/vector-sized-1.4.0.0 (jophish)
01:33:01 <hoppfull> merijn: Interesting, thank you.
01:33:04 <merijn> hoppfull: In groups operations have inverses
01:33:13 <Taneb> Cancellative monoid, I think, for the first one. The second is a little different
01:33:29 <koz_> Taneb: Wait, that's a thing?
01:33:52 <merijn> More importantly: That's the first thing you come up with instead of groups? >.>
01:34:00 <ski> there's no multiplication of lists, in the sense of rings, if addition would be concatenation
01:35:07 <Taneb> merijn: it's more general, and works for Natural
01:35:36 <Taneb> ...actually, it works for [a] as well, looking at the definition
01:36:26 <hoppfull> I've also heard of pairings. But it's not related to this is it? + is not the dual of -, right? You don't have to explain it to me, I could just as well read about it. Just checking if I'm in the ballpark.
01:36:47 <Taneb> hoppfull: I don't know what you mean by pairings
01:37:43 <dminuoso> Is `entropy` the suitable way to generate cryptographically secure bytes every now and then?
01:38:28 <shachaf> masaeedu[m]: The fact that you can get a monad from the adjunction of two functors is neat, but I don't think that's the only thing that's going on here, is my point, I think.
01:38:57 <shachaf> At least, I don't know F and G that go between Hask and Hask^op that give you this Co monad.
01:39:13 <masaeedu[m]> it's not just about getting a monad from an adjunction of functors
01:39:15 <ski> in a cancellative monoid (written additively, say. but not requiring abelianess/commutativity. think lists, if you will), you have ⌜∀ m,n. m₀ + n = m₁ + o ⇒ m₀ = m₁⌝, so ⌜mn − n⌝ can mean at most one thing, and ⌜(m + n) − n⌝ converges to ⌜m⌝
01:40:07 <masaeedu[m]> it's about the fact that when you have a *composition* of adjunctions, you get a "nested" monad/comonad in the target category of the precomposed adjunction
01:40:29 <masaeedu[m]> so when you compose the adjunctions underlying Cont and some arbitrary comonad, you get a "nested" comonad in Hask^op
01:40:37 <masaeedu[m]> which of course is a monad in Hask
01:41:27 <masaeedu[m]> the `F` and `G` are both `_ -> r`
01:41:50 <masaeedu[m]> you precompose the adjunction formed by those two with the adjunction underlying any comonad
01:41:55 <hoppfull> Taneb: I've only glanced at this article https://blog.functorial.com/posts/2016-08-07-Comonads-As-Spaces.html and the subject of "Functor pairings" so I wanted to check if any bells rang.
01:42:21 <masaeedu[m]> i've written out what i'm talking about more precisely here: https://gist.github.com/masaeedu/5892050bbbbef8d7601a96750b455724. if there's anything you disagree with there i'd appreciate comments
01:44:17 <shachaf> A composition of adjunctions is still an adjunction.
01:44:40 <ski> (hm, if one has an ordering, one can consider an always-defined ⌜mn ∸ n⌝, such that ⌜(m + n) ∸ n = m⌝, but merely ⌜(mn ∸ n) + n ≥ mn⌝)
01:44:53 <shachaf> I guess it's admittedly not one going to Hask^op.
01:45:17 <ski> (hmm, i suppose with ⌜mn ≥ n  ⇔  ∃ m. mn = m + n⌝, one'd like abelianess ?)
01:45:21 <hoppfull> Taneb: It seems to be called "Adjunctions" in category theory.
01:45:40 <shachaf> I think you must agree that "Cont r a = (a -> r) -> r" is a very different type from "Id a = forall r. (a -> r) -> r"
01:46:01 <shachaf> What adjunction or composition of adjunctions are you saying the latter comes from?
01:46:47 <hoppfull> Are we all discussing the same thing here?
01:47:02 <masaeedu[m]> sorry, there's two conversations going on here
01:47:23 <hoppfull> masaeedu[m]: Yeah, but they seem to be about the same thing.
01:47:25 <masaeedu[m]> the adjunctions stuff probably has nothing to do with the cancellative monoid stuff you're talking about
01:47:29 <Taneb> hoppfull: I don't think that's related to cancellative monoids, at least in an obvious way
01:47:43 <hoppfull> Okay, never mind.
01:47:53 <ski> (s/Hask_op/Hask^op/)
01:48:01 <ski> hoppfull : "Are we all discussing the same thing here?" -- not really
01:48:30 <hoppfull> You're right.
01:48:39 <ski> masaeedu[m] : "- an arbitrary Haskell comonad `W = UV`   - is formed by an adjunction `U -| (V : Hask -> Hask)`" -- i don't see this
01:48:57 <Taneb> Hmm, a cancellative monoid is a category with one object where all morphisms are monic and epic
01:49:35 <masaeedu[m]> ski: ok. which part do you disagree with?
01:49:52 <shachaf> That part seems pretty reasonable to me.
01:50:02 <ski> hm, oh, perhaps you're saying "assuming `W = UV`, where `V : Hask -> Hask`, then ..."
01:50:27 <shachaf> No, for any adjunction U -| V, for V : Hask -> Hask, UV is a comonad.
01:50:43 <shachaf> Unfortunately there's only one such adjunction so it's not very interesting.
01:50:47 <ski> (it first looked to me you were saying every comond on `Hask' must arise from an adjunction of endofunctors on `Hask')
01:50:55 <masaeedu[m]> i think i see your objection. It should be `C -> Hask` or `Hask -> C` or something
01:51:04 <shachaf> Oh, now I see the way you were reading the sentence.
01:51:05 <masaeedu[m]> but i don't thinkt hat's material to the rest of the reasoning
01:51:11 <shachaf> You're right.
01:52:31 <masaeedu[m]> ```
01:52:31 <masaeedu[m]>  - is formed by an adjunction `U -| (V : C -> Hask)` for some category `C`
01:52:32 <masaeedu[m]> ```
01:52:33 <masaeedu[m]> how's that
01:53:05 <shachaf> I think there is a dual to Co, but it looks something like the Store comonad (or Density comonad).
01:56:38 <shachaf> Maybe "Oc m a = exists x. (x, m x -> a)"?
01:56:53 <iqubic> I don't know enough catagory theory to follow this conversation.
01:56:56 <shachaf> Or something. I feel like I figured out a thing that worked a while ago.
01:57:26 <masaeedu[m]> i have a note at the bottom that i got too tired to follow up on
01:57:29 <iqubic> What the heck is 'exist'?
01:57:58 <masaeedu[m]> but i think if you look at the `Cont` comonad in the opposite category and try to do the same recipe with the adjunction underlying a monad, you're going to get a comonad
01:58:00 * hackage generics-mrsop-gdiff 0.0.0 - Reimplementation of the `gdiff` algorithm for `generics-mrsop`  https://hackage.haskell.org/package/generics-mrsop-gdiff-0.0.0 (vcmiraldo)
02:00:28 <iqubic> I also don't know what an adjunction is.
02:01:52 <iqubic> I should probably learn about that sometime soon.
02:03:29 <hoppfull> https://bartoszmilewski.com/2016/04/18/adjunctions/
02:03:35 <masaeedu[m]> ski: i've patched it with a generalization from `Hask -> Hask` to `Hask -> C`, thanks. it still all works though, as far as i can tell
02:03:45 <shachaf> masaeedu[m]: If (->r) : Hask -> Hask^op and (->r)^op : Hask^op -> Hask, (->r) . (->r)^op is a comonad in Hask^op (monad in Hask), and (->r)^op . (->r) is a monad in Hask.
02:04:00 * hackage hw-uri 0.1.1.3 - Supports IO on URIs  https://hackage.haskell.org/package/hw-uri-0.1.1.3 (haskellworks)
02:04:04 <shachaf> You get the same thing either way you compose them (of course, because they're the same functor).
02:04:55 <masaeedu[m]> the difference would be in what you're sandwiching between them
02:05:13 <masaeedu[m]> it would be the adjunction underlying a monad (in Hask) instead of the adjunction underlying a comonad
02:07:21 <masaeedu[m]> in the comonad version the comonad's adjunction gets postcomposed (i.e. it goes on the "outside"), i think it'd be the other way around for the monad
02:08:26 <shachaf> I don't think you should say "the" adjunction underlying a monad. Any monad can be made from many adjunctions.
02:09:00 <masaeedu[m]> ok. "an" adjunction underlying a monad then
02:09:01 <shachaf> But I don't follow what you mean. Surely composing the adjunction with other things won't make it give you a comonad instead of a monad.
02:09:05 <ski> iqubic : `exists' is existential quantification. like if you want a collection of widgets, all being of types being instances of the type class `Widget', but not necessarily all of the same type
02:09:57 <iqubic> Ah. Right.
02:10:25 <iqubic> data Showable s where
02:10:30 <masaeedu[m]> ok, maybe before i speculate about the monad thing, i should confirm you agree all the reasoning about how to get a monad from a comonad by composing *an* adjunction underlying the comonad with  the adjunction underlying `Cont`
02:10:46 <iqubic> Right. I've seen that in haskell.
02:10:58 <masaeedu[m]> *agree with
02:11:08 <shachaf> I agree that you can compose an adjunction "inside" (-> r) -| (-> r), and get a monad.
02:11:29 <ski> that would be, say `[exists a. Widget a *> a]', or `Map Blah (exists a. Widget a *> a)' perhaps
02:11:36 <shachaf> Or a monad, I guess.
02:11:37 <ski> or, maybe you want a list of `Map's, where within each map, the value type is an instance of `Widget'. and all values within a map has the same type. however, different maps in the list can employ different value types (still being instances of `Widget')
02:11:42 <masaeedu[m]> hmm. but i think i'm composing an adjunction "outside" (_ -> r)
02:11:44 <shachaf> The monad is "Foo m r a = m (a -> r) -> r"
02:11:46 <masaeedu[m]> but maybe this is just semantics
02:12:07 <ski> that would be `[exists v. Widget v *> Map Blah v]'
02:12:14 <shachaf> ...Where I meant to say comonad, and m is a comonad.
02:12:20 <ski> iqubic : makes sense ?
02:12:23 <shachaf> "Foo w r a = w (a -> r) -> r"
02:12:40 <shachaf> This monad is "(-> r) . w . (-> r)", which I would call "inside".
02:12:43 <iqubic> data ShowBox = forall s. Show s => SB s -- I think that's a way to declare that.
02:13:05 <iqubic> data ShowBox where
02:13:21 <iqubic> SB :: Show s => ShowBox s
02:13:26 <iqubic> If you want a GADT
02:13:31 * hackage hedgehog 1.0.1 - Release with confidence.  https://hackage.haskell.org/package/hedgehog-1.0.1 (moodmosaic)
02:14:04 <ski> iqubic : that's one current way to encode it. iow, that `ShowBox' is an encoding of `exists s. Show s *> s'
02:14:19 <masaeedu[m]> ok, right. yeah i was talking about "outside" from the perspective of the comonad's adjunction being postcomposed onto the `-> r` adjunction, but i think we're on the same page
02:14:23 <iqubic> Right.
02:14:27 <iqubic> And it's actually
02:14:30 <dminuoso> iqubic: You could also use a CPS style encoding of existential quantification.
02:14:41 <iqubic> data ShowBox where
02:14:53 <iqubic> SB :: Show s => s -> ShowBox
02:15:00 <iqubic> For the GADT style.
02:15:12 <iqubic> I don't know the CPS way of doing it.
02:15:23 <ski> iqubic : another encoding is `forall o. (forall s. Show s => s -> o) -> o'. this is the CPS (Continuation-Passing Style), or "Church" encoding. used with some `withBlah :: ... -> (... -> o) -> o' operations
02:15:41 <iqubic> Ah, that's it.
02:15:54 <ski>      exists a. C a *> ..a..
02:16:00 <dminuoso> In Haskell, the chuch encoding works in more situations. :)
02:16:10 <iqubic> I've seen these in Sandy's book 'Thinking with Types'
02:16:10 <ski>   =  forall o. ((exists a. C a *> ..a..) -> o) -> o
02:16:20 <ski>   =  forall o. (forall a. (C a *> ..a..) -> o) -> o
02:16:21 <iqubic> I just can't recall the syntax
02:16:33 <ski>   =  forall o. (forall a. C a => (..a.. -> o)) -> o
02:16:33 <dminuoso> iqubic: Dont think of it as syntax, try to extract the core idea
02:16:38 <iqubic> What is (*>)?
02:16:44 <dminuoso> iqubic: Its => for existentials
02:16:51 <iqubic> Is it some sort of type operator?
02:16:56 <ski> bundling a value with evidence for a constraint
02:17:00 <shachaf> #haskell-overflow would be better for the existentials conversation.
02:17:01 <dminuoso> iqubic: *> is to => as exists is to forall
02:17:17 <ski> and as `(,)' is to `(->)'
02:17:26 <iqubic> Right. Because (=>) is for universal qualifications.
02:17:36 <ski> it's imagined syntax (just like `exists'). pseudo-Haskell
02:17:49 <iqubic> this function works for all s, provided that s can be Shown.
02:18:00 * hackage buffon-machines 1.1.1.1 - Perfect simulation of discrete random variables  https://hackage.haskell.org/package/buffon-machines-1.1.1.1 (mbendkowski)
02:18:01 <iqubic> forall s. Show s => .....
02:18:24 <dminuoso> iqubic: The relevant thing is to remember that `forall` indicates that the consumer of that thing can pick a type.
02:18:43 <ski> (though some other Haskell implementations actually did allow `exists' in code .. however, only to the left of `->', i think (perhaps also in type synonyms, and data constructor argument type specifications ?), which is the uninteresting case, in general)
02:19:07 <iqubic> Right. Which I use forall quite a bit when doing type level programming.
02:19:43 <jgt> is there a common library function for extracting the host from a URI? I want to turn "https://foo.com/bar/baz?spam=eggs" into "https://foo.com"
02:20:00 <jgt> (which could also work with a trailing slash)
02:20:19 <iqubic> usually in the form of: 'forall n. KnownNat n => .....'
02:20:41 <sim590> https://en.wikibooks.org/wiki/Haskell/do_notation#The_fail_method says I should be able to write this: https://paste.debian.net/1101011/, but the code fails with https://paste.debian.net/1101012/.
02:20:43 <iqubic> And then I use type applications and scoped type variables to later refer to the n in the function body.
02:21:51 <dminuoso> iqubic: Think of a simpler version:
02:21:58 <iqubic> I will.
02:21:58 <dminuoso> iqubic: `(Int -> Char) -> Char`
02:22:18 <dminuoso> iqubic: And consider who gets to pick what.
02:22:46 <dminuoso> Who has control/knowledge over the Int? And who has to be ready for any value?
02:23:27 <dminuoso> If I hand you this entire function it means I have some Int stashed away, but you cant tell which.
02:23:40 <iqubic> Well, in that case the caller gets to decide which function f :: Int -> Char is used, but the callee gets to decide what Int that function f will be called with.
02:23:56 <dminuoso> iqubic: Right! So the implementor of that functor has some Int hidden. 
02:24:00 <dminuoso> *function
02:24:03 <iqubic> Right.
02:24:49 <iqubic> What is your point with this/
02:24:50 <dminuoso> iqubic: If we consider `∀o. (∀s. s -> o) -> o` its conceptually not much different.
02:25:09 <dminuoso> iqubic: except its not just the value, but the actual *choice* of a type for `s`
02:25:33 <iqubic> Who gets to decide what type `s` is?
02:25:50 <iqubic> I assume it's the caller.
02:25:53 <dminuoso> Nope!
02:25:59 <dminuoso> iqubic: Go back to the previous example.
02:26:03 * merijn sighs
02:26:22 <iqubic> Oh. Right.
02:26:24 <merijn> Looks like it's "if I want this to work sanely I need to patch persistent"-o'clock >.>
02:26:47 <dminuoso> iqubic: So its the implementor that makes a (hidden) choice for `s`. And you as the caller have to provide something that is ready for *any* choice
02:26:51 <merijn> Because apparently I'm not allowed to define constraints on the auto-generated primary key :\
02:26:56 <iqubic> Right.
02:27:04 <dminuoso> iqubic: Just like in the `(Int -> Char) -> Int` example.
02:27:11 <iqubic> But in this case that's highly useless.
02:27:37 <iqubic> There's not much you can do with an `s` that can have any type at all.
02:27:48 <dminuoso> iqubic: Sure. So just add a constraint like Show.
02:27:54 <iqubic> Alright.
02:28:08 <iqubic> Then you can call Show in the `s`. And nothing else.
02:28:09 <koz_> iqubic: vector-sized uses this to convert unsized to sized vectors.
02:28:27 <dminuoso> iqubic: right. so its some hidden choice for which you only know it satisfies Show.
02:28:37 <koz_> http://hackage.haskell.org/package/vector-sized-1.4.0.0/docs/Data-Vector-Sized.html#v:withSized
02:28:41 <iqubic> koz_: I saw that earlier.
02:29:24 <iqubic> forall n. (n ~ Int) => (n -> Char) -> Char
02:29:30 <dminuoso> iqubic: So if we assume `f :: ∀o. (∀s. Show s => s -> o) -> o`, then the implementor of `f` has made some secret/hidden choice for some type `s`. You cant know which choice, but you know it satisfies at least Show. So you have to provide a function that is ready for *any* choice of some type Show s.
02:29:30 <iqubic> Is that useful at all?
02:30:10 <iqubic> `forall n. (n ~ Int) => (n -> Char) -> Char` is basically the same as `(Int -> Char) -> Char now that I think about it.
02:31:47 <dminuoso> iqubic: Note how my last sentence matches nicely with existential quantification
02:31:49 <dminuoso> % data Showable = forall s. Show s => Showable s
02:31:49 <yahb> dminuoso: 
02:31:55 <iqubic> Yes I do.
02:33:11 <iqubic> % toString (Showable x) = show x
02:33:11 <yahb> iqubic: 
02:33:24 <iqubic> % toString (Showable 1)
02:33:24 <yahb> iqubic: "1"
02:33:32 <masaeedu[m]> shachaf: so i mechanically followed things through and it looks like `Co` itself would just give you a comonad when `w` is a monad
02:33:39 <iqubic> % toString (Showable False)
02:33:40 <yahb> iqubic: "False"
02:33:43 <masaeedu[m]> i.e. it's involutive like ski said
02:33:45 <dminuoso> iqubic: interesting part here:
02:33:47 <dminuoso> % :t show
02:33:47 <yahb> dminuoso: Show a => a -> String
02:34:06 <dminuoso> iqubic: Note how this function is a valid argument for `f :: ∀o. (∀s. Show s => s -> o) -> o`~
02:34:12 <shachaf> masaeedu[m]: I'm pretty skeptical of that claim.
02:34:19 <dminuoso> So you'd write `f show` to consume that existential.
02:34:21 <shachaf> Can you write the comonad instance?
02:34:40 * masaeedu[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/MlZgNxjFSmEuJjGXydNUsLBH >
02:34:45 <masaeedu[m]> i'm going to try writing it now
02:35:10 <iqubic> Interesting part is that we don't know the type of the `x` after patter matching like `(Showable x)`, yet we still get the right implementation of show being chosen.
02:35:23 <iqubic> Which is also weird.
02:35:27 <dminuoso> iqubic: Is it?
02:35:39 <iqubic> Not really.
02:35:42 <dminuoso> iqubic: It's as weird as `(Int -> Char) -> Char` having to an Int.
02:35:48 <iqubic> Yeah.
02:35:56 <iqubic> It's not that weird.
02:36:24 <iqubic> f :: Show s => s -> String
02:36:33 <adadelta> There is a Haskel course starting today at futurelearn.com, 6 week course for free.
02:36:42 <dminuoso> iqubic: Its basically saying "I have something that has a Show instance (but I wont tell you what!). Give me a continuation that works over *any* choice of something Show'able, and Ill feed it to you"
02:36:44 <adadelta> Haskell ;)
02:37:02 <ski> masaeedu[m] : hm, that would be interesting ..
02:37:29 <iqubic> I don't know the type of `s` in `f :: Show s => s -> String, but I do know that calling show will use the right show instance.
02:37:30 <dminuoso> iqubic: Of course in case of `(Int -> Char) -> Char` there might happen more because the implementor knows that it returns a Char. But `(Int -> a) -> a` otoh is equivalent to just `Int`
02:37:36 <masaeedu[m]> i have yet to write any code though, so i wouldn't hold my breath
02:37:55 <dminuoso> iqubic: The type of `s` will be picked by *its* user
02:38:01 <masaeedu[m]> the reasoning seems pretty enticing though
02:38:04 <dminuoso> iqubic: In case of our `f` function above, it's `f` that will make that decision.
02:38:16 <iqubic> Oh. I see. That's really interesting.
02:38:54 <dminuoso> iqubic: I repeat again! If you have some `bar :: forall s. ...` it means that the *consumer* of `bar` will make a decision/pick/choice for `s`
02:39:44 <dminuoso> iqubic: So if you have `q :: (forall s . ...) -> ...` it means that the implementor of `q` can (depending on the types it might not be forced to though) make that choice, not the consumer of q.
02:39:57 <dminuoso> `f :: ∀o. (∀s. Show s => s -> o) -> o`
02:39:58 <dminuoso> Here is two choices.
02:40:03 <dminuoso> The consumer of `f` picks the o
02:40:08 <dminuoso> And the implementor of `f` picks the s
02:40:27 <iqubic> In the case of `f :: Show s => s -> a` the caller gets state, "I want to use this particular s." In the case of `f :: ∀o. (∀s. Show s => s -> o) -> o` the implementor says, "you must be prepared to handle any s at all. You can't chose what you handle"
02:40:33 <iqubic> I think that sums it up.
02:40:48 <iqubic> Existential vs Universal qualifications.
02:41:46 <dminuoso> iqubic: `f :: Show s => s -> a` is a sort of weird example.
02:41:53 <iqubic> Why?
02:42:03 <iqubic> Oh, right.
02:42:18 <iqubic> it should be `f :: Show s => s -> String`
02:42:37 <iqubic> let's nail down the `a` to a concrete type to make this simpler
02:42:56 <dminuoso> iqubic: I tend to think of forall as sort of a lambda abstraction (in the value level)
02:43:13 <dminuoso> iqubic: Which makes this whole "who has to pick something for it" and "who has to be ready for anything" easier to understand
02:43:25 <ski>   f ∷ ∀ ω. (∀ s. Show s ⇒ s → ω) → ω
02:43:26 <ski>   f ∷ ∀ ω. ((∃ s. Show s ×› s) → ω) → ω
02:43:37 <dminuoso> Its just like functions where some `\x -> ...` has the outer perspective where the consumer must decide what `x` should be, and the internal perspective where you have to be ready for anything handed to you
02:44:05 <iqubic> ski: I don't know what the difference between those two statements is.
02:44:26 <iqubic> I see the syntactic differences, but i don't know the semantic differences.
02:44:44 <dminuoso> iqubic: So something like `f :: forall s. Show s => s -> String` is, under the hood, some `/\s -> \(x :: s) -> ...` so two kind of lambdas intertwined.
02:45:17 <dminuoso> (Though that analogy is a bit weird with typeclasses in the mix)
02:45:25 <iqubic> I'm not sure I understand that.
02:45:26 <dminuoso> iqubic: There is none, that's the point.
02:45:39 <iqubic> but I get the the difference between forall and exists.
02:45:44 <dminuoso> iqubic: Do you know about TypeApplications?
02:46:46 <dminuoso> iqubic: every forall quantification implies that, on the value level, there is a lambda-like abstraction over a type parameter. So calling something like `f :: Show s => s -> Int` requires specifying what that s is. That specification can be made explicit with TypeApplications, e.g. `f @String "foo"`
02:47:05 <iqubic> I know about TypeApplications.
02:47:06 <ski> iqubic : the point is that there's no semantic difference, really
02:47:21 <iqubic> I've been working with TypeApplications all day.
02:47:38 <iqubic> Mainly trying to debug my code and figure out why it wasn't working.
02:47:51 <dminuoso> iqubic: So the point is this:
02:48:00 <dminuoso> iqubic: `forall s. ...` means that there's a sort of extra argument `s`
02:48:06 <iqubic> Correct.
02:48:19 <iqubic> And currently it's an invisible argument.
02:48:34 <dminuoso> iqubic: Right, we could however pretend for the sake of argument that it was explicit and you always had to do manual type applications.
02:49:12 <iqubic> You can pass it in if you want, with a type application. But until we get visible dependent qualifiers, it will remain optional. Well, at least in the cases where GHC can infer the type.
02:49:52 <iqubic> If GHC complains that something or other is ambiguous, then you need a type application.
02:50:19 <dminuoso> iqubic: My point is, once you realize that you *have* to do type applications to get access to the inner thing, it shows you about who controls (and thus knows!) type arguments
02:50:29 <dminuoso> (by type arguments I mean the ones applied to forall things)
02:50:37 <dminuoso> In case of
02:50:43 <dminuoso> f :: ∀o. (∀s. Show s => s -> o) -> o
02:50:58 <dminuoso> We could think of `f` taking a function that requires 1 type argument and one value argument.
02:51:20 <iqubic> Sure.
02:51:41 <dminuoso> If we think of `\x -> x + 1` then a caller must/can decide what the argument is, he knows - but the implementor does not, he has to be ready for anything to come.
02:52:18 <iqubic> but it's the caller that gets to decided the type and value of s. The inside function has to be able to handle any `s` at all.
02:52:25 <dminuoso> iqubic: So if we used /\ to denote these type arguments, then some `/\s. \x -> ...` too suggests that the caller decides what `s` is going to be, its not under our control.
02:52:33 <iqubic> At this point I feel like we're going in circles.
02:53:02 <iqubic> I understand fully your point. No need to keep belaboring the message.
02:54:27 <iqubic> If you have something else you feel you need to add, by all means carry on.
02:55:46 <iqubic> Now, if you don't mind, I'm going to spend some time reading this Bartosz blog post on Adjunctions.
02:55:49 <dminuoso> iqubic: My point is just that thinking about forall quantification in terms of System F can help understand this model of "not under your control" and "you must pick/get to decide"
02:55:56 <iqubic> https://bartoszmilewski.com/2016/04/18/adjunctions/
02:56:19 <iqubic> I have no idea what System F is
02:57:13 <dminuoso> iqubic: System F is an extension of simply typed lambda calculus to include terms that can bind types. Roughly, this is what we have with this `forall` and type applications.
02:58:03 <iqubic> Ah. I see.
02:58:15 <dminuoso> So instead of `\x. x` as the identity function, you'd write an additional binder `/\` for a type, so you'd write: /\a. \(s :: a). s
02:58:26 <dminuoso> And that has the type `forall a. a -> a`
02:59:09 <dminuoso> iqubic: Type applications are about the applications to that /\ binder.
02:59:34 <iqubic> I know that with Idris you often have to add that binder explicitly. I wonder what makes Idris different from Haskell in this regard.
03:00:21 <iqubic> I think this is because Idris goes one step further and extends System F to allow for dependent types.
03:01:16 <dminuoso> iqubic: Idris adds another dimension.
03:01:22 <dminuoso> iqubic: Idris adds types that can bind terms.
03:01:44 <dminuoso> (Whereas polymorphism gives terms that can bind types - so this forall business and type application - that's on the type level)
03:02:08 <iqubic> Right. Like I said. Idris adds dependent types.
03:02:33 <iqubic> A dependently typed system has types that can bind terms
03:04:04 <iqubic> select :: Bool -> Type
03:04:19 <iqubic> select b = if b then Int else Char
03:04:43 <iqubic> f :: (b :: Bool) -> (select b)
03:05:01 <iqubic> Or something like that. I don't know the proper syntax.
03:05:46 <iqubic> I know that the example I have just given be easily translated into Haskell by writting `select` as a Type Family.
03:06:45 <dminuoso> iqubic: If we consider the forall quantification, you
03:06:51 <dminuoso> you'd then have a different quantifier named Pi
03:07:07 <dminuoso> So `f :: Pi (a :: K). B(a)` where `B` is some function akin to select.
03:07:18 <iqubic> What does Pi mean?
03:07:36 <dminuoso> iqubic: Its the type binder for terms.
03:08:00 <iqubic> How does Pi differ from Forall?
03:08:13 <dminuoso> iqubic: Well Pi compares to /\ rather.
03:08:29 <dminuoso> iqubic: So while /\ is a value level thing that binds types, Pi is a type level thing that binds values.
03:08:44 <iqubic> I don't understand.
03:09:36 <iqubic> I'm not understanding the differences.
03:11:16 <dminuoso> Or actually.. I think I mixed up things.
03:13:08 <iqubic> Is /\ just a symbol you made up?
03:13:34 <dminuoso> 11:57:53    dminuoso | So instead of `\x. x` as the identity function, you'd write an additional binder `/\` for a type, so you'd write: /\a. \(s :: a). s
03:13:35 <iqubic> Or is it an ASCII version of a harder to type unicode symbol?
03:13:44 <iqubic> Ah. I see.
03:14:08 <Taneb> iqubic: it's a capital Lambda
03:14:30 <iqubic> I am so stupid.
03:14:36 <iqubic> Λ
03:14:42 <iqubic> Oh. So it is.
03:15:47 <iqubic> And yes. I did add an XKB setting so that I could hit both L and R shifts to switch Greek input just so I could type lambda quicker.
03:17:23 <iqubic> I even got it to turn on the Caps Lock light to indicate that I'm in Greek mode.
03:17:37 <iqubic> I have Caps Lock bound to Escape for Vim.
03:18:42 <dminuoso> iqubic: (Note that in System F you'd usually write ^ instead of ::, so that becomes: /\a. \(s ^ a). s
03:18:48 <dminuoso> And, with a full type annotation:
03:19:03 <dminuoso>  /\a. \(s ^ a). s : ∀f. f -> f
03:19:50 <iqubic> I see.
03:21:48 <Guest_16> dose somebody know how I can get the graphical interface for stack?
03:22:19 <iqubic> I don't think there is one.
03:22:24 <iqubic> I might be wrong.
03:22:31 <Guest_16> for OS X
03:30:15 <mniip> is there a non-empty set package that is not written by thielemann
03:30:32 <iqubic> Why do you hate thielemann?
03:31:10 <merijn> iqubic: Clearly you have not seen his...excentric naming convention before
03:33:03 <ski> @quote henning
03:33:03 <lambdabot> shachaf says: Henning should call all his modules M
03:33:59 <iqubic> merijn: Correct.
03:34:07 <iqubic> I don't even know who he is.
03:34:27 <iqubic> I know he has create at least one hackage package.
03:35:33 <merijn> iqubic: He believes everything should always be imported qualified, so every definition in his code has one letter names indicating their "class" (typeclass, datatype, etc.)
03:35:59 <ski> <https://hackage.haskell.org/user/HenningThielemann>
03:36:29 <merijn> iqubic: Just look at how nice and understandable the types in these docs are: https://www.stackage.org/haddock/nightly-2019-09-16/data-accessor-0.2.2.8/Data-Accessor-Basic.html
03:36:47 <ski> (e.g. check <https://hackage.haskell.org/package/audacity> .. every "main type" in a module is called `T')
03:37:08 <iqubic> What is T?
03:37:24 <merijn> iqubic: Exactly
03:37:49 <ski> (it would be nice if Haddock could disambiguate better, though)
03:37:50 <iqubic> T is just short hand for Type.
03:38:02 <merijn> iqubic: YOu're "supposed" to import stuff like "import qualified Data.Accessor as Accessor" and use "Accessor.T" everywhere
03:38:14 <iqubic> Oh my god.
03:38:23 <merijn> iqubic: Understandably, this does not make people happy
03:38:31 <iqubic> Stop polluting your own namespace with duplicate names.
03:38:37 <merijn> iqubic: Hence, why lots of people hate his packages
03:38:53 <ski> imagine if you always read `f :: (C a,C a) => T T a T -> [T a] -> T T', and all of those `T's referred to different types, in different modules (oh and the two `C's are also different)
03:38:54 <merijn> I'm sure he's perfectly nice as a person, but screw that...
03:39:01 <iqubic> Espescially if the names are meaningless in the first place.
03:40:51 * ski . o O ( "Now you're thinking with module qualification." )
03:41:27 <iqubic> I think that this naming convention is bullshit
03:41:50 * ski points to Haddock comment
04:06:52 <piyush-kurur> sorry if this is a bit off topic, I am thinking of buying a desktop and my workload is generally cabal, ghc, coq etc. Does it make sense to get a Solid state drive machine. 
04:07:42 * piyush-kurur dreams of hacking on ghc once in a while
04:08:00 <tabaqui2> it doesn't matter
04:08:28 <merijn> piyush-kurur: Wait, is there a workload where it *doesn't* make sense to get an SSD?
04:08:35 <tabaqui2> anyway, you would compile on ramfs
04:08:43 <merijn> SSD all the things in everything
04:09:06 <tabaqui2> merijn: some people are perfectly fine with coding/hacking on remote server
04:09:15 <merijn> tabaqui2: Even then
04:09:17 <sm[m]> for speed, certainly. for space, it will cost. for lifetime durability.. who knows
04:09:32 <merijn> sm[m]: Consumer SSD lifetime is fine
04:09:32 <piyush-kurur> SSDs are typically smaller/costlier  than the corresponding disks
04:09:41 <piyush-kurur> so if that is a point
04:09:49 <merijn> sm[m]: https://techreport.com/review/27909/the-ssd-endurance-experiment-theyre-all-dead/
04:10:22 <merijn> sm[m]: The first casualties in that benchmark started happening at 900 Terabytes worth of writes...
04:10:33 <merijn> Ah, no, a "mere" 800
04:12:14 <piyush-kurur> merijn: I am thinking of desktop (not laptop). If it helps reduce cost I am for it (may be spend that on the RAM)
04:12:38 <merijn> piyush-kurur: I would never in a million years consider buying a new machine without an SSD
04:12:45 <tabaqui2> my previous ssd has died because of controller
04:12:56 <tabaqui2> consider this factor too
04:13:36 <merijn> tabaqui2: I've had a ton of hard disks fail too, so
04:14:06 <tabaqui2> another profits of ssd is quiet work, tolerance to hits and crushes
04:14:35 <tabaqui2> but on desktop that is online 24/7 it is not a big deal
04:14:42 <merijn> piyush-kurur: At this point in time, SSDs are probably the single biggest impact you can have on machine performance
04:15:36 <merijn> piyush-kurur: I'd get less RAM or a slower CPU before I'd drop the SSD :p My girlfriend is currently using my desktop from 2009, only thing we changed was put an SSD in and it's perfectly fine for light desktop use :p
04:15:39 <hoppfull> Hello, However monoid have cancellative monoid but semigroup don't seem to have cancellative semigroup. Is it called something else in Haskell or does it not exist?
04:16:12 <hoppfull> *-However
04:16:18 <mniip> I wonder if I should move my crypt-swap to my SSD
04:16:58 <mniip> 800TB sure is a lot but is it really that much
04:17:51 <piyush-kurur> merijn: then SSD it is.
04:17:56 <merijn> mniip: Sample size of 1, of course, but if you read through the entire review (and previous editions) you'll see that they're pretty reliable
04:18:10 <merijn> mniip: IIRC none of the disks failed without giving SMART errors *way* before dying
04:18:34 <merijn> mniip: The best disk in their benchmark lasted freaking 2.4 Petabytes of writes
04:19:23 <piyush-kurur> The disk failure was never a criteria for me. I do not think I would be "writing" so much
04:19:25 <mniip> I remember being able to write through crypt at a rate of about 350MB/s
04:19:30 <mniip> hmm, that's 26 days of writes
04:20:29 <sm[m]> merijn: that was interesting, though not a large scale test (only one of each type). i’d like to know what level of lifetime writes we are all at - not sure how to even estimate that
04:22:09 <merijn> sm[m]: Sure, they didn't really claim to be a proper scientific evaluation, it was more of a "should regular consumers worry about this?" question, which seems to be a pretty clear "naah"
04:22:35 <mniip> is Total_LBAs_Written measured in physical or logical blocks
05:29:30 * hackage cachix 0.3.1 - Command line client for Nix binary cache hosting https://cachix.org  https://hackage.haskell.org/package/cachix-0.3.1 (domenkozar)
05:41:00 <asheshambasta> I have a project that has an arrow do block inside another do block; and compilation fails only with `stack build` but not with `stack ghci`. 
05:41:39 <asheshambasta> how and why could that be? 
05:42:46 <asheshambasta> https://gist.github.com/asheshambasta/64496f5f2c55f9b78293ff2eba72f884 
05:44:14 <asheshambasta> and this works: https://gist.github.com/asheshambasta/64496f5f2c55f9b78293ff2eba72f884#file-thisworks-hsvc
05:44:23 <asheshambasta> sorry, link: https://gist.github.com/asheshambasta/64496f5f2c55f9b78293ff2eba72f884#file-thisworks-hs
05:46:34 <dminuoso> asheshambasta: can you include the full error message you are getting?
05:48:00 * hackage harg 0.3.0.0 - Haskell program configuration using higher kinded data  https://hackage.haskell.org/package/harg-0.3.0.0 (alexpeits)
05:48:03 <sshine> it makes sense to commit stack.yaml.lock to git, right? I mean, if I, say, add another extra-dep, having the lock file will ensure that I address that change in reproducibility; that I'm essentially trying to reproduce something else. is that correctly understood?
05:49:27 <asheshambasta> dminuoso: https://gist.github.com/asheshambasta/64496f5f2c55f9b78293ff2eba72f884#file-errors-txt
05:50:25 <dminuoso> asheshambasta: What happens if you feed it directly to GHC manually?
05:51:53 <dminuoso> asheshambasta: Also, does indenting lines 4-6 make a difference?
05:52:50 <asheshambasta> dminuoso: yeah I just tried indenting it a level deeper and that seems to 'fix' this 
05:53:13 <asheshambasta> I'll try pasting this in ghci and see if that works; it is the indentation that is the issue here. 
05:53:24 <asheshambasta> what is perplexing is why this doesn't happen in ghci 
06:09:03 <fr33domlover> o/ is there a monad transformer for early finishing a computation, like ExceptT but where the early finishing isn't an error? It would work just like ExceptT a m a, and I suppose have throwE named something else. Before I write my little wrapper of ExceptT for this, is there an existing such thing?
06:10:46 <dminuoso> asheshambasta: That is curious indeed. It could be a GHCi bug.
06:11:13 <dminuoso> asheshambasta: The GHC error messages are obvious and appear to be correct.
06:12:42 <dminuoso> fr33domlover: What do you mean by "isn't an error" ?
06:13:23 <dminuoso> fr33domlover: ExceptT is that thing, it's a somewhat poorly named primitive for adding short-circuiting semantics to a monad.
06:14:35 <maralorn> Depending on the return value you want you can even do this with Maybe, can‘t you?
06:15:06 <dminuoso> Indeed, MaybeT is the variant where you cant communicate information in the short-circuiting channel.
06:15:39 <dminuoso> Things like `runMaybeT (MaybeT foo <|> MaybeT bar)` can be useful tools.
06:15:57 <maralorn> Then at least it doesn‘t sound like an exception.
06:16:03 <dminuoso> maralorn: Its still an exception.
06:16:19 <dminuoso> It'd be silly to avoid it just because it *sounds* like exception.
06:17:23 <maralorn> data ComputationSuccesfulException = ComputationSuccesfulException^^
06:20:23 <fr33domlover> dminuoso, yeah I mean I want ExceptT but where the "error" and "success" types are the same and the runTheTransformerT function returns that type and not an Either. I've been needing this often in my code (often together with ExceptT already used for short circuiting on actual errors) so just wondering if that little convenience wrapper existed ^_^
06:21:50 <dminuoso> fr33domlover: Well there's always ContT...
06:22:05 <dminuoso> fr33domlover: or continuations in general.
06:26:50 <domenkozar[m]> phadej: do you know how to writeGenericPackageDescription with common stanzas?
06:27:32 <phadej> you cannot. GPD doesn't have that information anymore
06:27:42 <phadej> that = common stanzas
06:29:18 <dminuoso> merijn: You use prettyprinter a lot afaik, how would you deal with ByteString? I regularly have the need to pretty print random bits and bytes.
06:30:24 <merijn> dminuoso: What specifically do you mean?
06:30:35 <merijn> You can just write a "ByteString -> Doc", no?
06:31:01 <domenkozar[m]> phadej: is there a way to write only one field?
06:31:43 <dminuoso> merijn: Mmm would you write out a custom instance for Pretty ByteString?
06:32:02 <dminuoso> Ah screw it. Ill just depend on pretty-hex, its such a miniature library..
06:32:08 <merijn> Probably not, I dislike orphans, etc.
06:32:14 <phadej> domenkozar[m]: i don't understand the question
06:32:51 <dminuoso> merijn: heh after dmwit talked about it, I realized that orphan instances are probably not even half as bad as many make them out to be.
06:32:53 <domenkozar[m]> phadej: I'd like to just write 'version' field while ignoring the rest of the cabal file
06:33:18 <dminuoso> It might be an issue if its part of a library you ship, but if its some final package, then it doesn't really matter much.
06:34:04 <phadej> cabal-fmt kind of allows tou to do refactoeings like that, but it destroys the existing formatting (and it's GPL)
06:35:10 <cheater> is the slide seen at 1:07:14 in CPS? https://www.youtube.com/watch?v=bmKYiUOEo2A
06:35:19 <cheater> it's a slide by conal 
06:37:29 <domenkozar[m]> phadej: okeeey
06:38:30 * hackage replace-attoparsec 1.0.2.0 - Stream edit, find-and-replace with Attoparsec parsers  https://hackage.haskell.org/package/replace-attoparsec-1.0.2.0 (JamesBrock)
06:39:36 <michalrus> • Found hole: _ :: (RoleId, RoleName, Int, D.RoleId) -> (D.RoleId, RoleName)
06:39:45 <michalrus> Hmmmm… if this could be filled automatically one day… =)
06:41:30 * hackage replace-megaparsec 1.1.4.0 - Stream edit, find-and-replace with Megaparsec parsers  https://hackage.haskell.org/package/replace-megaparsec-1.1.4.0 (JamesBrock)
06:42:54 <Ariakenom> if you add some parametricity you can use djinn https://www.hedonisticlearning.com/djinn/
06:43:14 <Ariakenom> michalrus^
06:43:44 <Ariakenom> as in "f :: (id, name, int) -> (id, name)" where those are variables instead of specific types
06:44:03 <domenkozar[m]> phadej: thanks, regex it is
06:44:22 <michalrus> Ariakenom: nice, thanks =) I’ll read about that
06:52:57 <infandum> How do I have stack build with dependencies from the global project? Running "stack exec ghc -- ~/.xmonad/xmonad -o ~/.local/bin/xmonad" will result in "Could not find module 'XMonad'"
06:53:20 <infandum> It doesn't seem to think it's not in a project, as it doesn't say anything about not being in a project and using the global config.
06:53:22 <infandum> yaml
06:54:44 <dmwit> cheater: Not really.
06:56:19 <fr33domlover> infandum, https://github.com/pbrisbin/dotfiles/blob/master/xmonad/build
07:02:02 <asheshambasta> dminuoso: I'm not sure if the GHC error messages are obvious; it complains of an empty do block and then complains of arrow messages found where none were expected. 
07:02:41 <asheshambasta> if a do block, with the arrow notation; has been found, it probably should assume the following lines to be the body of the do block; until the returnA is found. 
07:03:10 <asheshambasta> however, indentation 'fixes' this issue, but I'm not sure how to feel about the error messages or the requirement of the indentation to begin with. 
07:03:45 <asheshambasta> in the case where nested do blocks in general need extra indentation; then it does make more sense. 
07:06:28 <infandum> fr33domlover: Yes, that is the idea and similar to my normal build file, but stack (recently) stopped treating it as a global project and so the dependencies aren't found.
07:06:33 <infandum> So it won't build.
07:11:46 <infandum> There are no cabal or yaml files in the folder with xmonad.hs
07:12:27 <dminuoso> asheshambasta: Well if you understand how GHC interprets your code, it makes perfect sense.
07:13:22 <dminuoso> asheshambasta: From its perspective, you have an empty arrow-do-block that is instantly terminated (which is why you get the error about the empty-do-block). So the next line is back in the outer monad-do-block, and that produces the other error messages
07:13:34 <dminuoso> asheshambasta: Honestly I dont know how the GHC diagnostic could be better at this point, its pretty good.
07:13:44 <dminuoso> Do you have any suggestions?
07:28:24 <maralorn> How does this situation happen (on nixpkgs unstable) haskellPackages.polysemy -> 1.0.0.0, haskellPackages.polysemy_1_2_0_0 -> 1.2.0.0, If the auto import from hackage knows about 1.2.0.0 why doesn‘t it bump the default package to that version?
07:30:01 <merijn> ugh
07:30:31 * merijn resets sign: "It's been 0 days since I regretted using persistent 4 years ago.."
07:31:15 <merijn> It "helpfully" checks that your foreign references refer to a primary key, except...that's not necessary or required >.<
07:31:21 <heatsink> Sounds like you have a persistent problem
07:33:32 <heatsink> It's an orm?
07:34:54 <merijn> Not really, because classical ORM notions don't reall map to Haskell to begin with
07:36:25 <merijn> goddammit, I had a super elegant idea on how to work around persistent's inability to define unique constraints on it auto-generated primary keys and it has to go and screw it up by limiting foreign keys to primary keys >.<
07:41:44 <dminuoso> Im willing to argue that ORMs in general do a very poor job, and that a fair amount of discipline and handcrafting code will yield better results than any ORM can.
07:42:16 <dminuoso> ORMs tend to behave crazy once you have non-trivial queries or anything that exceeds "give me nothing but users"
07:42:57 <dminuoso> While at the same time adding so many layers of code that you can't even pretend to understand what happens in your ORM when you write some code.
07:43:31 <merijn> dminuoso: I'd just manually patch in the constraint I want/need, but SQLite can't do "ALTER TABLE" with new constraints, so I'd have to painfully manually create them >.<
07:44:09 <dminuoso> merijn: Ahh, so you'd have to sort of create a new table and copy over data?
07:44:55 <merijn> dminuoso: Right
07:45:12 <merijn> Which is super verbose :\
07:45:41 <merijn> dminuoso: And I need to perform that logic for *each* version of my schema, because persistent can't detect them being missing >.>
07:47:57 <merijn> Fuck...this is annoying
07:48:42 <dminuoso> merijn: Im quite liking my minimalistic `[Connection -> IO ()]` style of migrations.
07:49:41 <merijn> dminuoso: Sure, but rewriting everything to get rid of persistent is a huge amount of work :\
07:50:01 <dminuoso> merijn: So the question is how long you want to suffer from technical debt..
07:50:13 <merijn> Alternatively, I just give up on having foreign keys enforce correctness
07:50:16 <dminuoso> merijn: There comes a point where the pain and effort sustaining persistence outweighs the efforst of rewriting..
07:50:36 <merijn> dminuoso: I'm betting on the point lying behind the completion of my thesis, and therefore me caring
07:52:12 <dminuoso> What thesis is that?
07:52:25 <dminuoso> PhD? M?
07:52:28 <merijn> dminuoso: phd
07:52:31 * hackage pointful 1.1.0.0 - Pointful refactoring tool  https://hackage.haskell.org/package/pointful-1.1.0.0 (MikhailGlushenkov)
07:52:46 <dminuoso> merijn: I dont think I ever asked, what's the subject of your thesis?
07:52:56 <dminuoso> Err. Topic I mean.
07:53:21 <merijn> dminuoso: Basically, I have a sort of diamon foreign key scenario, that can't be enforced directly, so I figured out a nice encoding, but persistent is making that impossible (or at least, needlessly hard)
07:53:34 <merijn> dminuoso: graph algorithms on GPUs
07:54:53 <merijn> dminuoso: Basically my problem is, given: https://paste.debian.net/1101057/ how do you enforce that "each row in Quux has a Bar and Baz that refer to the same Foo"
07:55:03 <merijn> dminuoso: The brilliant solution I came up with is: https://paste.debian.net/1100885/
07:55:20 <dminuoso> Your brilliant solution is non-existant.
07:55:24 <asheshambasta> dminuoso: no, and I see your point. However, as a human reading the code, it seemed obvious to me that GHC would understand that an arrow do block starting point followed by a bunch of arrow commands until the returnA would be an arrow do block. 
07:55:41 <merijn> dminuoso: Much like reality, then ;)
07:55:54 <asheshambasta> and ofc. in my case, this problem seemed bigger than it looked since neither my syntax checker (intero) nor GHCi complained. 
07:55:59 <merijn> dminuoso: https://paste.debian.net/1101059/
07:56:30 * hackage cachix 0.3.2 - Command line client for Nix binary cache hosting https://cachix.org  https://hackage.haskell.org/package/cachix-0.3.2 (domenkozar)
07:56:38 <dminuoso> asheshambasta: That would require a context sensitive grammar.
07:56:39 <merijn> dminuoso: Of course, persistent doesn't let you define those unique constraints (since they involve the automatic Id) but you can work around that, it also works if you instead define an external unique index (whoo!)
07:56:59 <dminuoso> asheshambasta: Either way GHC has to decide whether that entire block is an arrow block or a monad block.
07:57:07 <merijn> dminuoso: Unfortunately, now I'm still hosed because you can't define those foreign references in Quux either!
07:57:18 <asheshambasta> dminuoso: correct 
07:57:31 <merijn> dminuoso: Or rather, you can in terms of syntax, but the TH insists your foreign references match the primary key, because screw you!
07:57:44 <dminuoso> merijn: Ah I see.
07:58:19 <cheater> dmwit: why not?
07:59:17 <merijn> dminuoso: I could manually migrate the table to one with manual foreign constraints like that, but as I said that means I need to manually create and migrate those tables for each future change
07:59:36 <dminuoso> asheshambasta: But either way. Generating diagnostics tailored to what the user *possibly* meant is rather hard in general. Your issue was expecting that `... $ proc () -> do` would consider everything following that to be in the arrow block.
08:00:07 <asheshambasta> dminuoso: yeah, until it saw the `returnA` 
08:00:27 <dminuoso> asheshambasta: The `returnA` is irrelevant actually
08:00:50 <asheshambasta> dminuoso: how so?
08:00:59 <dminuoso> asheshambasta: Because its just a regular identifier and not syntax.
08:01:15 <dminuoso> asheshambasta: If at all the -< might be a signal since thats from arrow commands.
08:01:33 <dminuoso> asheshambasta: But the indention rules is what matters.
08:03:07 <dminuoso> asheshambasta: Though it could be argued, that perhaps an empty-do block could provide a hint suggesting that perhaps you forgot to indent the do-block.
08:04:57 <asheshambasta> dminuoso: makes sense; I agree that in this case the error was misleading since only the build command failed.
08:10:01 * hackage releaser 0.2.0.0 - Automation of Haskell package release process  https://hackage.haskell.org/package/releaser-0.2.0.0 (domenkozar)
08:20:04 <dminuoso> asheshambasta: Either way. The fact that GHCi does not choke on this suggests a bug report is in order.
08:28:03 <asheshambasta> dminuoso: does that go on ghc gitlab? Or is there a separate issue board for ghci? 
08:28:56 <dminuoso> asheshambasta: ghc gitlab is fine
08:31:00 <asheshambasta> dminuoso: okay, I see that this is just the GHC gitlab page.
08:38:00 * hackage withdependencies 0.2.5 - Run computations that depend on one or more elements in a stream.  https://hackage.haskell.org/package/withdependencies-0.2.5 (SimonMarechal)
08:39:30 * hackage essence-of-live-coding 0.1.0.2 - General purpose live coding framework  https://hackage.haskell.org/package/essence-of-live-coding-0.1.0.2 (turion)
08:39:35 <asheshambasta> dminuoso: https://gitlab.haskell.org/ghc/ghc/issues/17197
08:41:17 <catchme> What is the difference of `newArray` in `Data.Array.ST` and `Data.Array.MArray`?
08:42:20 <Taneb> catchme: MArray.newArray is generalised. It works also for IOArray, IOUArray, and STUArray
08:42:33 <sm[m]> catchme: their types should tell you.. I expect they each make their respective kind of Array
08:42:40 <ski> catchme : none, it's the same method of `MArray' being exported from two places
08:42:41 <sm[m]> aha
08:42:54 <ski> @type Data.Array.ST.newArray
08:42:56 <lambdabot> (Data.Array.Base.MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
08:42:59 <ski> @type Data.Array.MArray.newArray
08:43:01 <lambdabot> (Data.Array.Base.MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
08:43:02 <Taneb> ski: oh, so it is
08:43:08 <sm[m]> aHA
08:43:08 <dminuoso> catchme: Data.Array.ST just re-exports Data.Array.MArray (and thus transitively newArray)
08:44:23 * ski glances at catchme
08:45:15 <catchme> Aha, 
08:45:15 <catchme> Thanks a bunch guys
08:45:18 <ski> np
08:45:49 <dminuoso> Mmm, is hackage receiving new looks?
08:45:59 <dminuoso> https://hackage.haskell.org/package/array-0.5.4.0/docs/Data-Array-ST.html this looks... different.
08:46:26 <dminuoso> Or rather, this is just haddoc isnt it?
08:46:42 * ski sees no difference ..
08:47:08 <dminuoso> ski: Mmm, try bypassing your browsers cache perhaps?
08:48:11 <dminuoso> ski: This is what it looks like for me http://imgur.com/3MCGSZ4l.png
08:48:12 <ski> (.. white text on black background, blue links, as always. relative placement of things appear to be the same (including "Source" links))
08:48:46 <dminuoso> The entire layout of the haddoc documentation is.. different.
08:49:28 <catchme> What is the usage of the first line? https://www.irccloud.com/pastebin/4QdXby7I/
08:52:01 * hackage rhine 0.5.1.1 - Functional Reactive Programming with type-level clocks  https://hackage.haskell.org/package/rhine-0.5.1.1 (turion)
08:55:26 <lavalike> dminuoso: yeah, for example this is centered, it usually is left-aligned (or 100% width maybe)
08:56:11 <ski> dminuoso : <https://prnt.sc/p6v8aq>
08:57:01 <ski> catchme : so that you don't have to type `M.Map', can just type `Map', in types
08:57:21 <lavalike> @slap ski 
08:57:21 * lambdabot karate-chops ski  into two equally sized halves
08:58:42 <dminuoso> ski: Heh!
08:58:48 <dminuoso> ski: Touche.
08:58:57 <lavalike> https://hackage.haskell.org/package/lens-4.18.1/docs/Control-Lens-Combinators.html for an example of the other older layout
09:04:03 <catchme> ski: Thanks :)
09:11:01 * hackage polysemy-RandomFu 0.4.0.0 - Experimental, RandomFu effect and interpreters for polysemy  https://hackage.haskell.org/package/polysemy-RandomFu-0.4.0.0 (adamCS)
10:01:01 * hackage tree-sitter-python 0.3.0.0 - Tree-sitter grammar/parser for Python  https://hackage.haskell.org/package/tree-sitter-python-0.3.0.0 (patrick_thomson)
10:29:01 <catchme> How to change global variable value? https://www.irccloud.com/pastebin/O2QQ9H7D/
10:30:59 <glguy> No, you can't change y
10:32:26 <catchme> So I should make `runST $` in the top level function 
10:33:21 <glguy> Yes, you can wrap runST around the whole of the computation that needs a mutable reference
10:34:40 <catchme> Thanks, I will do so.
10:43:03 <ChrisPenner[m]> Anyone know of there's a successor or better maintained version of "lvish" anywhere? It hasn't been updated since 2014 and isn't building for me. http://hackage.haskell.org/package/lvish
10:43:41 <ChrisPenner[m]> I know kmett is working on this, but last I checked it's not ready yet :)
11:03:00 * hackage knit-haskell 0.7.0.0 - a minimal Rmarkdown sort-of-thing for haskell, by way of Pandoc  https://hackage.haskell.org/package/knit-haskell-0.7.0.0 (adamCS)
11:09:51 <maralorn> Is there a way to import some fields in .cabal-file from a different file?
11:27:13 <dmj`> maralorn: you mean like dynamically generate your cabal file ?
11:29:43 <maralorn> dmj`: If you phrase it that way I could do it with dhall-to-cabal couldn‘t I?
11:32:45 <dmj`> maralorn: maybe, if dhall-to-cabal lets you do IO
11:32:53 <dmj`> maralorn: what are you trying to do exactly
11:34:48 <sm[m]> Or with m4
11:36:24 <dmj`> maralorn: you can just use nix too
11:37:33 <maralorn> dmj`: dhall has includes.
11:39:22 <maralorn> dmj`: Well I think I’ll stay with cabal for the moment and copy the ghc-options by hand.
11:41:17 <dmj`> maralorn: yea, introducing another level of indirection always makes things difficult
11:42:55 <koz_> How do I resole this particular issue? I had 'cabal new-test' working before, but now I'm trying with GHC 8.8 and it's refusing. http://paste.debian.net/1101106/
11:43:01 <koz_> s/resole/resolve/
11:44:49 <catchme> Why didn't this code compile? https://www.irccloud.com/pastebin/qLWxg9AI/
11:45:58 <dsal> catchme: I'd expect the compiler to tell you that.
11:47:24 <dmj`> catchme: you can't print inside of ST
11:47:38 <geekosaur> for one, runST is not IO (what dmj` said)
11:47:56 <dmj`> yea, what geekosaur said
11:48:02 <geekosaur> if you'e doing I/O, work in IO
11:48:39 <catchme> OK, Thanks a  bunch.
11:48:44 <dsal> Is that the error you got?
11:49:57 <catchme> I was trying to dump function  info inside a top level varaible, so I put the code inside runST
11:50:31 <tabaqui2> why stack doesn't reuse globally installed libraries?
11:50:31 <catchme> **variable**
11:51:09 <tabaqui2> I set same resolver, and allow-different-user flags
11:51:33 <geekosaur> becuase ghc generally doesn't; they need exact ABI compatibility, which is often difficult
11:52:10 <tabaqui2> I mean globally installed haskell libraries
11:52:31 <tabaqui2> like, I've run "stack install Cabal" somewhere outside of any stack project
11:52:49 <tabaqui2> and now I expect that it will not rebuild Cabal in any local project
11:53:28 <geekosaur> what I would expect, stack being stack, is it'd cache the build and copy it in whenever it can reuse it
11:53:38 <geekosaur> regardless of "installed"
11:53:52 <geekosaur> which implies it can't reuse it, again possibly because of ABI hash mismatch
11:54:32 <tabaqui2> docker related issue, probably?
11:55:08 <dmwit> Are you sure your "install"ed using the same resolver as your project is using?
11:55:21 <tabaqui2> I do
11:55:27 <geekosaur> "I set saame resolver" earlir
11:55:43 <geekosaur> can't quote properly in this webirc thingy
11:55:58 <tabaqui2> as I said it is running inside a docker image
11:56:06 <tabaqui2> what can cause such behavior?
11:56:36 <tabaqui2> both scripts are started under root account
11:57:11 <tabaqui2> but the source files of the local project don't belong to the root
12:01:37 <catchme> why can't I use <$> in `readSTRef` the same as in `read`?
12:01:37 <catchme> `readSTRef <$> (newSTRef lst)`
12:01:37 <catchme> `read <$> getLine`
12:02:54 <fendor> @type read
12:02:55 <lambdabot> Read a => String -> a
12:02:58 <fendor> @type readSTRef
12:03:00 <lambdabot> STRef s a -> ST s a
12:03:16 <fendor> @type (<$>)
12:03:18 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:03:34 <maralorn> dmj`: I am fine with using nix. But I plan to at least factor parts of my project out and push it to hackage. For that I will need the cabal file anyways.
12:04:24 <dmj`> maralorn: Nice, good choice
12:04:46 <fendor> catchme, short explanation, readSTRef is a monadic action while read is not, so you cant just replace one with another.
12:05:13 <fendor> @type newSTRef
12:05:14 <lambdabot> a -> ST s (STRef s a)
12:05:46 <fendor> @type readSTRef <$> (newSTRef undefined)
12:05:47 <lambdabot> ST s (ST s a)
12:05:50 <catchme> fendor: Is there any other operator that work with `readSTRef`? instead of  `u <- newSTRef lst
12:05:50 <catchme>         readSTRef u`
12:06:14 <fendor> I think, you may use join on the result, e.g.  
12:06:20 <fendor> @type join (readSTRef <$> (newSTRef undefined))
12:06:22 <lambdabot> ST s a
12:07:17 <fendor> or
12:07:31 <fendor> @type newSTRef undefined >>= readSTRef
12:07:33 <lambdabot> ST s b
12:07:46 <fendor> @type readSTRef =<< newSTRef undefined
12:07:47 <lambdabot> ST s b
12:08:16 <fendor> which is just `u <- newSTRef lst` without binding it to u.
12:09:50 <catchme> fendor: Thanks alot.
12:09:50 <catchme> I took time as I didn't know that join is in control.monad
12:09:59 <lavalike> @index join
12:10:00 <lambdabot> Control.Monad
12:11:11 <catchme> `@type` = :t
12:11:11 <catchme> `join` = ??
12:11:26 <catchme> I mean `@index`
12:11:49 <lavalike> @help index
12:11:49 <lambdabot> index <ident>. Returns the Haskell modules in which <ident> is defined
12:11:56 <fendor> lambdabot can do more than just ghci
12:12:05 <fendor> @djinn (a, b) -> a
12:12:05 <lambdabot> f (a, _) = a
12:12:22 <lavalike> oh I see, yeah, it's a lambdabot plugin not a ghci function
12:13:28 <jneira> maralorn: afaik you cant do it directly with cabal but you could use dhall lang, which can import files, and compile it to cabal
12:13:36 <jneira> https://github.com/dhall-lang/dhall-to-cabal
12:14:03 <catchme> Thanks guys, you are really helpful 
12:14:06 <iqubic> Today is a sad day.
12:14:14 <catchme> why?
12:14:29 <iqubic> Today is the day I have to start programming in Java.
12:14:38 <koz_> iqubic: :( :( :(
12:14:44 <tabaqui2> switch on Clojure while it is not too late
12:14:47 <[exa]> iqubic: quit now
12:14:49 <iqubic> I have an hour and 15 minutes to kill before the first meeting of my new CS class.
12:15:01 * hackage finitary 1.0.0.0 - A better, more type-safe Enum.  https://hackage.haskell.org/package/finitary-1.0.0.0 (koz_ross)
12:15:08 <koz_> On that note: today I turned 0x20 and published finitary 1.0.
12:15:14 <[exa]> iqubic: are you a student or a lecturer?
12:15:21 <iqubic> Student.
12:15:28 <[exa]> man, that's good
12:15:38 <[exa]> I was supposed to teach XML last year
12:15:45 <[exa]> quit in last minute
12:15:50 <iqubic> This is a prerequisite for some of the more advanced CS course I want to take.
12:16:05 <iqubic> It's XML just HTML, but for configs?
12:16:17 <[exa]> OTOH, you can learn a lot from other's failures there. :]
12:16:35 <[exa]> XML as sax/dom/xslt/xmlrdf/whatever technologies
12:16:49 <[exa]> kindof java-style databases
12:17:16 <iqubic> [exa]: The hardest part for me will be switching my brain from a FP style of thinking to an OOP style of thinking.
12:17:58 <iqubic> And besides, this is CS 211, so it is expected that one knows the basics of the Java language.
12:18:42 <[exa]> btw the jvm assembly is probably worth looking at, it explains 99% of stuff you see in the actual language
12:18:59 <iqubic> Is that available online anywhere?
12:19:54 <[exa]> oracle has its docs on that, there's just around a hundred instructions
12:21:08 <iqubic> https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html
12:21:12 <iqubic> Here it is.
12:21:41 <iqubic> I know next to nothing about Assembly programming
12:22:20 <[exa]> it's kindof beneficial to know how the computer actually sees your program
12:23:27 <iqubic> I can see that.
12:23:44 <iqubic> I'll be using this as a guide during my time working with Java.
12:27:46 <tabaqui2> there were a great introduction on stack machines, but it is on russian
12:28:08 <tabaqui2> some guy wrote an assembly example with Haskell Monoids
12:28:13 <tabaqui2> https://github.com/samsergey/monopig
12:29:05 <tabaqui2> s/were/was (and many others)
12:30:03 <martijnV2> don't forger the /g
12:30:42 <tdammers> wait what? recommending studying the JVM bytecode spec in order to learn the basics of Java? That's like telling someone to study Old Norse and medieval French in order to learn English
12:31:07 <energizer> is there a name for: a type in a signature, i.e. a parameter *or* return value?
12:31:15 <tabaqui2> true badass starts learning CS from D.Knuth, ofc
12:31:40 <tabaqui2> erasure[m]: type variable?
12:32:01 <martijnV2> idk if the type is not a variable it's just a type
12:32:21 <tabaqui2> monomorphic vs polymorphic type
12:38:00 * hackage finitary 1.0.0.1 - A better, more type-safe Enum.  https://hackage.haskell.org/package/finitary-1.0.0.1 (koz_ross)
12:38:18 <tabaqui2> hehe, haddock update?
12:39:02 <tabaqui2> ah, nope
12:39:05 <tabaqui2> nevermind
12:41:24 <NemesisD> say i have `toFast :: Slow -> Fast` and i have a function `aToB :: Slow -> A -> B; aToB slow = aToB' (toFast slow)`, i would prefer to keep the `Fast` to be an internal implementation detail, but if  the user has to apply `aToB` a bunch of times for the same value of `Slow`, the runtime will have to do the `toFast` conversion every single time right? there's no caching involved?
12:43:29 <dmwit> As stated, that will be cached. But I suspect you have not stated it carefully.
12:44:00 * hackage axel 0.0.11 - The Axel programming language.  https://hackage.haskell.org/package/axel-0.0.11 (jgrosso256)
12:44:05 <lyxia> To add to that point, to me it sounds like it won't be cached.
12:44:12 <NemesisD> the user might have `as :: [A]` and will do something like `bs = aToB slow <$> as`
12:44:26 <dmwit> NemesisD: That will be a type error.
12:44:39 <dmwit> (Which is kind of my point about you not having stated it carefully... yet.)
12:44:56 <NemesisD> how would that be a type error?
12:45:10 <dmwit> Sorry. I am wrong.
12:45:29 <dmwit> But the call to `toFast slow` will be shared across all elements of `as`, as you desire.
12:46:01 <dmwit> (N.B. if you had written `aToB slow a = aToB' (toFast slow) a` this probably would *not* be the case!)
12:47:09 <dmwit> On the other hand, if you do `aToB slow a` in one place, and `aToB slow a'` in another, where `slow` and `slow` actually turn out to be the same thing that you just passed around, the calls to `toFast slow` will not be shared.
12:47:51 <maralorn> Can I deactivate a Warning just for one line with ghc?
12:48:01 <dmwit> So this optimization is quite fragile, and it won't really be feasible to have this just be an implementation detail -- callers will need to know and be careful how they make their calls.
12:48:13 <merijn> maralorn: Depends on the warning?
12:48:15 <dmwit> maralorn: I don't know a way, and have looked for it in the past. =(
12:48:15 <NemesisD> `bs = [aToB slow a1, aToB slow a2, ...]`, thus `bs = [aToB' (toFast slow) a1, aToB' (toFast slow) a2, ...]`, so at some point the compiler (?) is smart enough to compute that `toFast slow` and share it because of what? the proximity of the uses of `toFast` to eachother?
12:48:50 <merijn> dmwit: There is a wishlist feature for pragma based warning control (which is why my ADOPT pragma for orphan instances got shot down :( )
12:48:51 <dmwit> NemesisD: No, `map (aToB slow) [a1, a2]` is not the same as `[aToB slow a1, aToB slow a2]`.
12:48:59 <merijn> I was proud of that name too...
12:49:23 <maralorn> merijn: I want to have -Wmissing-import-lists for everything but the Prelude.
12:49:32 <dmwit> NemesisD: `map (aToB slow) [a1, a2]` is the same as `let f = aToB slow in [f a1, f a2]`.
12:49:45 <dmwit> NemesisD: And that `let` binding is where the sharing is done.
12:49:56 <NemesisD> ah ok. that makes sense to me
12:50:06 <martijnV2> its modulo lazy evaluation
12:50:08 <maralorn> And I want to import the Prelude explicit because I need to hide something from it.
12:50:10 <NemesisD> it seems like i should avoid tempting fate and just expose Fast
12:50:11 <martijnV2> semantically it is equivalent
12:50:40 <dmwit> I think that is one reasonable solution.
12:51:44 <martijnV2> NemesisD: Is it not an idea to put it in the types? toFast :: (Slow a, Fast b) => a -> b
12:52:22 <maralorn> Nevermind found a better solution.
12:52:38 <martijnV2> Or in a multi-parameter type class with toFast :: SlowToFast a b => a -> b
12:52:47 <NemesisD> slow and fast are different than a and b, IRL they are a schema. slow is a sort of a list of fields, fast will be a hashmap or something for fast field lookup
12:52:49 <dmwit> NemesisD: For comparison, the standard regex library has a regex compilation step, which depending on the backend may be slow and should be shared across multiple invocations of matching.
12:53:08 <dmwit> NemesisD: So it has a similar pattern to what you describe: its match takes a "slow" version, compiles to a "fast" representation, then uses that.
12:53:24 <masaeedu[m]> Anyone know how I can take a fixpoint of a polykinded type?
12:53:30 <dmwit> NemesisD: The regex library's solution is to simply document this fact; callers are responsible for doing sharing of the fast thing if they want that.
12:53:36 <NemesisD> dmwit: i've used that before. makes sense
12:53:38 <masaeedu[m]> without ending up in *
12:54:00 <dmwit> NemesisD: e.g. if you want the "fast" version of the regex "foo bar baz", you don't pass around `"foo bar baz"`, you pass around `match "foo bar baz"`.
12:54:25 <maralorn> Can I have submodules in a Haskell file? I really don‘t want those record fields in my global scope.
12:54:51 <c_wraith> masaeedu[m]: it might not be possible. it depends on the kind of the type you're starting with 
12:54:56 <lyxia> masaeedu[m]: type family FixF :: k where FixF = F FixF  -- where F :: k -> k  ?
12:55:09 <dmwit> NemesisD: I don't remember if it's actually called "match", but you get the idea. The analog for you would be that folks should not pass around a particular value slow of type Slow, preferring to pass around the closure `aToB slow` instead.
12:55:18 <lyxia> it probably diverges actually...
12:55:18 <merijn> maralorn: Nope
12:55:30 <merijn> maralorn: You can simply "not export" the record fields, though
12:55:31 <masaeedu[m]> well, here's the pseudocode of what i want to do
12:55:35 * masaeedu[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/tpYrFytnrHFbVjmNGUAJKNdq >
12:56:00 <masaeedu[m]> i feel like i need some kind of type level isomorphism from `c` to `*`
12:57:03 <masaeedu[m]> the `SRFreeF` constructor kind checks, but that's only because i like in the `SRFreeF` type constructor definition and say the output kind is `c`
12:58:00 <masaeedu[m]> the thing i want a fixpoint of is `add '(one, mul '(a, _))`, where those have the kinds annotated above
12:58:13 <c_wraith> that :: c at the end of the data declaration is confusing me
12:58:16 <masaeedu[m]> *i lie
12:58:24 <masaeedu[m]> yeah, it's a lie
12:58:38 <masaeedu[m]> that's what i would need in order to get the data constructor below to kind check
12:59:24 <c_wraith> because data always creates type constructors that produce * when fully applied. 
12:59:59 <masaeedu[m]> that's right. so what actually happens is that where i do `mul '(a, SRFreeF add one mul a)`, I get a kind error
13:00:15 <lyxia> there's no way you are going to get an equality  c = (1 + a * c)  at the type-level. Maybe you can have an "isomorphism"   c <-> (1 + a * c)   but what that means depends on the kind of c.
13:00:59 <lyxia> it also depends on what you need that thing for
13:01:49 <masaeedu[m]> lyxia: i can get that for a concrete `c`, can't i?
13:02:32 <masaeedu[m]> i mean if i pick `mul = (,)`, `one = ()`, `add = Either`, it would work fine
13:03:32 <lyxia> if c :: Type there's indeed a pretty natural notion of "isomorphism".
13:04:03 <masaeedu[m]> the problem is i also want to represent things like `* -> *`, for which there are analogous definitions of `mul`, `one` and `add`
13:05:26 <masaeedu[m]> so the "fixpoint" in that case should give you a type constructor * -> *
13:07:30 <masaeedu[m]> i'm fine with using some other thing to wrap and unwrap if i have to to get this to work, but using a separate fixpoint combinator seems to be no better
13:07:52 <masaeedu[m]> i'm wondering if something clever with a promoted data constructor is necesssary
13:09:36 <c_wraith> I mean, you're still stuck with the fact that data types aren't flexible in the number of type arguments they take. 
13:10:06 <c_wraith> to get this to work at all, you need some sort of type family. 
13:10:08 <masaeedu[m]> hmm, but why is that an issue?
13:10:24 <lyxia> masaeedu[m]: have you read the first part of https://blog.poisson.chat/posts/2019-06-09-free-monads-free-monads.html
13:10:24 <c_wraith> because type constructors are curried. 
13:11:03 <lyxia> and by "first" I mean the one that starts at "Indexed types"
13:11:09 <masaeedu[m]> you can uncurry your type constructors so they take a tuple
13:11:14 <masaeedu[m]> lyxia: no
13:11:45 <lyxia> basically every   a -> b -> c -> ... -> z -> Type   is equivalent to    (a, b, c, ..., z) -> Type
13:11:52 <merijn> c_wraith: Out of curiosity: What makes you say that? ("they're curried") I'm generally of the opinion that talking about currying has never reduced confusion, but I'm open to arguments in favour :)
13:12:02 <lyxia> so you only need a notion of fixed points for    (k -> Type)   types
13:12:08 <masaeedu[m]> yeah, i've already tried something like that
13:12:17 <masaeedu[m]> specifically: `data GFix (f :: (k -> *) -> (k -> *)) (a :: k) = GFix { unGFix :: f (GFix f) a }`
13:12:42 <masaeedu[m]> and i'm already tupling up all my parameters so they unify with that
13:12:55 <lyxia> so what's wrong with that
13:13:07 <masaeedu[m]> but i couldn't really make it work. i'll read through that section
13:13:48 <c_wraith> merijn: because they are? (Either String) :: Type -> Type
13:15:19 <merijn> c_wraith: So, I always see people do the same for functions too, but the "application happens on argument at a time" doesn't really require the term currying to explain and I think adding new terminology just for the sake of it is very useful either?
13:16:20 <c_wraith> merijn: technically I suppose that's the dual to currying, partial application. but partial application only works when the definition is already curried. 
13:16:41 <merijn> c_wraith: I dislike people talking about partial application too :p
13:16:52 <masaeedu[m]> i couldn't figure out how to tuple up `SRFreeF` so i'd be able to plug it into `GFix`
13:17:17 <SoundLogic> I've been playing around with the plugin interface, and it seems... weird and not very strictly typed? Is there better documentation or explanations for some of the design choices?
13:17:43 <c_wraith> merijn: what's wrong with using the same terms as everyone else? 
13:18:11 <c_wraith> merijn: there is a very specific feature being described. it has a name. might as well use the name. 
13:18:13 <lyxia> masaeedu[m]: ping me later if you're still stuck!
13:18:24 <masaeedu[m]> will do, thank you
13:19:01 <merijn> c_wraith: "partially applied" implies there's such a thing as "full applied" which, is at best a fuzzy notion, unless you consider only "non-function" values fully applied.
13:20:32 <c_wraith> merijn: it's completely fine to say "if the top level type constructor isn't know to be (->) it's fully applied." 
13:20:38 <c_wraith> *known
13:21:36 <merijn> c_wraith: Anyway, this is a longer discussion I should probably write out in a blog or something
13:43:56 <geekosaur> SoundLogic, that might be better asked on the haskell-cafe mailing list. or even on the ghc-users mailing list
13:44:24 <SoundLogic> All right. Thank you
13:58:44 <merijn> Christ..
13:58:56 <monochrom> Haha kunningdruger
13:59:11 <merijn> You ever spend 2 hours debugging why your new feature isn't working and then find out "oh, I was calling the old codepath..."?
13:59:32 <merijn> After which it works straight away, of course...
13:59:35 <monochrom> I think yes. But not as bad as 2 hours. Maybe 0.5 hours.
14:00:07 <monochrom> Also sometimes forgot to deploy the new exe at all.
14:00:22 <merijn> See, I just don't have a production :p
14:00:30 <merijn> Can't forget to deploy if there's nothing to deploy too!
14:00:33 <ChrisPenner[m]> Hey folks! I'm super excited to announce that I launched Early Access for Optics by Example today! This aims to be a comprehensive book on getting stuff done with optics taking folks through from beginners to advanced levels. I think optics are an incredible breakthrough which have a TON of untapped power, this book is a means towards making optics a bit more approachable and mainstream.
14:00:35 <ChrisPenner[m]> https://www.patreon.com/ChrisPenner
14:00:54 <monochrom> Oh I just mean doing "cabal build" and forgetting either "cabal copy" or "cabal install"
14:01:33 <merijn> monochrom: I just use shell scripts calling v2-run during development now, so that's become impossible
14:01:53 <monochrom> Eww
14:01:58 <merijn> monochrom: Hmm?
14:02:24 <monochrom> Perpetual beta.
14:02:37 <merijn> Dogfooding :p
14:04:46 <dmwit> ChrisPenner[m]: Nice!
14:05:38 <ChrisPenner[m]> dmwit: thanks! It's been a lot of work! Still lots to do :)
14:09:48 <hololeap> is there any reason there isn't an instance like this in the free package?
14:09:51 <hololeap> instance (ComonadTraced m w, Functor f) => ComonadTraced m (CofreeT f w)
14:11:11 <dmj`> if only there was an easy way to migrate from persistent to beam ...
14:12:23 <hololeap> this seems like the obvious implementation, but i don't know if it would break the semantics for ComonadTraced
14:12:25 <hololeap> trace m = (\(a :< _) -> a) . trace m . runCofreeT
14:16:22 <hololeap> FreeT has instances for both MonadWriter and MonadReader (not sure what the dual of ComonadTraced is)
14:16:27 <merijn> dmj`: From persistent to anything... >.>
14:16:36 <merijn> dmj`: beam looks terifying to me, tbh
14:16:38 <palo> I have a data structure data Baz = Foo{ a :: Int } | Bar{ b :: Int } and I want to write an update function update :: Baz -> Int -> Baz with something like update baz number = baz{ a = number} || baz{ b = number } (I know this is not proper haskell) what is the best way to do this. the REAL update function is quite complex so I perfer not to doublicate code.
14:16:41 <dmj`> merijn: yea :/ am noticing that
14:16:50 <dmj`> merijn: I think everything postgreSQL library kind of sucks
14:16:57 <merijn> Selda looked fairly promising last I looked
14:17:08 <merijn> Kinda opaleye inspired, but less postgres specific
14:17:26 <merijn> dmj`: postgres-simple ;)
14:17:35 <dmj`> merijn: yea, has potential. We need something that can preserve vanilla data types, but also uses Generics correctly
14:17:40 <merijn> dmj`: In hindsight I should've just written everything by hand :)
14:17:52 <hololeap> dmj`: have you seen this? i haven't used beam _too_ much but it was helpful for me: https://github.com/jacobono/beam-postgres-tutorial
14:17:53 <dmj`> merijn: that's been my approach, postgresql-simple, with your own generics-fu
14:18:22 <dmj`> merijn: hah, honestly. A wise old man once told me, "Lean heavily on the database, son"
14:18:40 <dmj`> hololeap: looks interesting
14:18:45 <dmwit> palo: Two options: 1. `data Baz = Foo { a :: Int } | Bar { a :: Int }; update baz n = baz { a = n }` 2. `update baz@(Foo{}) n = baz { a = n }; update baz@(Bar{}) n = baz { b = n }`
14:19:14 <dmj`> merijn: the problem with postgresql-simple is no type safe query DSL
14:19:30 <dmj`> merijn: but everybody who attempts a query DSL requires end users to bastardize their haskell data types
14:20:40 <dmwit> palo: (I strongly prefer plan 1 if you absolutely must have two constructors and record syntax. But I prefer even more to refactor so that all records have just one constructor.)
14:21:04 <dmj`> merijn: the selda monad is nice, the query monad is like a state monad that builds up some IR that gets turned into a valid query. It'd be nice if we had something similar, but that only operated on generics metadata. It would require an invalid monad instance though, only valid via a type indexed-monad
14:21:38 <palo> dmwit: I thought having 2 constructors is cleaner, because the final object is not creatable in one go. I have an InitalFoo and a Foo 
14:22:24 <palo> Setting default variables or using maybe clutters the code later quite a lot
14:23:27 <dmwit> You could consider the standard functor parameterization approach, or simply having two types.
14:24:23 <palo> dmwit: Two types might work, when I use Either in the data structures this Baz Data type is used, so baz = Either InitialFoo Foo
14:24:37 <palo> dmwit: thanks for your input. 
14:26:20 <dmwit> I would expect that at most program points, you will know whether you have/want an InitialFoo or a Foo.
14:26:38 <dmwit> And so Either InitialFoo Foo will basically never appear as a type in a well-designed program.
14:27:44 <palo> well the problem is that the I have quite compex data structures. And they are iteratively enriched over time. and not always successful. 
14:40:38 <zeta_0> i was just wondering what is the progress haskell being used with web assembly?
14:42:53 <merijn> dmj`: Not only do they require you to bastardise your haskell datatypes, they also tend to limit you to a subset of SQL >.>
14:43:44 <dmj`> merijn: yea, let's not let correctness get in the way of type safety :P 
14:44:07 <merijn> zeta_0: Last I heard the compilation stuff was working quite well, the biggest limitation is porting enough of the RTS's syscalls to be able to run useful code
14:44:24 <merijn> dmj`: Like persistent's "pssh, who needs joins?"
14:44:49 <dmj`> merijn: yea, ick
14:44:58 <merijn> oh bollocks, don't tell me profiling doesn't work with TH?
14:45:50 <dmj`> merijn: but honestly, the subset of SQL isn't what disturbs me the most. It's moreso the game of jenga that is played with the type extensions in every library implementation, such that if you can get it to compile, it's still just a tower waiting to fall over.
14:46:18 <zeta_0> so is web assembly with haskell still experimental, by when will it be stable?
14:47:11 <merijn> zeta_0: "when enough people put in the testing and development effort to make it so"
14:47:25 <merijn> But yes, definitely experimental
14:49:13 <zeta_0> that would be great, i heart the web programming languages can be a nightmare
14:50:27 <zeta_0> is it just that other programming languages have way more man power to get their language to work with web assembly?
14:51:17 <merijn> zeta_0: That and/or easier to implement in webassembly
14:52:04 <zeta_0> merijn: thanks for the heads up
14:52:13 <zeta_0> merijn++
14:52:27 <zeta_0> i don't know if there is karma on this channel
14:53:01 <merijn> So, does anyone know if profiling + TH is indeed not supposed to work?
14:53:34 <monochrom> Yes there is karma counted by lambdabot 
14:53:42 <monochrom> @karma merijn
14:53:42 <lambdabot> merijn has a karma of 70
14:55:24 <merijn> And if yes, then how the hell do I trace exception callstacks in code with TH? :\
14:58:32 <monochrom> Oh hrm, HasCallStack is independent of profiling, maybe it helps.
14:59:03 <monochrom> The price is you have to annotate many levels of your code manually.
14:59:55 <merijn> monochrom: Right, which kinda defeats the purpose
15:02:18 <merijn> Oooh...I've got a terrible idea that just might work
15:02:57 <merijn> I've got a couple of Constraint synonyms for operations that happen in many place anyway, I can just extend it with HasCallStack and propagate it to most places for free
15:04:11 <merijn> Just seems insanely limiting if you can't profile application that have TH anywhere in their code...
15:05:00 * hackage lingo 0.2.0.0 - File extension based programming language detection  https://hackage.haskell.org/package/lingo-0.2.0.0 (tclem)
15:08:06 <merijn> This looks like my issue, but that also seems to imply it should be fixed: https://gitlab.haskell.org/ghc/ghc/issues/14931
15:08:26 <merijn> Which is odd, since I'm using 8.6.5 and it's very definitely not working
15:12:18 <hololeap> is the Traced comonad considered dual to Reader or Writer?
15:19:16 <lyxia> hololeap: https://hackage.haskell.org/package/adjunctions-4.4/docs/Data-Functor-Adjunction.html#t:Adjunction writer is left adjoint to traced
15:22:50 <hololeap> right... thanks lyxia 
15:31:30 * hackage network-manager-tui 0.1.0.0 - network-manager tui  https://hackage.haskell.org/package/network-manager-tui-0.1.0.0 (andys8)
15:38:35 <dsal> Looking at some forks of one of my projects to see what people are doing with it...  someone backported it to like, ghc 8.0.1.  Strange world.
15:39:00 * hackage network-manager-tui 1.0.0.0 - network-manager tui  https://hackage.haskell.org/package/network-manager-tui-1.0.0.0 (andys8)
15:39:13 <dsal> That escalated quickly.
15:39:29 <merijn> dsal: Why's that weird, 8.0 isn't that old?
15:40:58 <dsal> Sounds old.  I don't really process time like some people, I think.  It mostly just has three states... but the diff shows things like ByteString not being a monoid, so lots of updates for that.  I don't know where it's being used, but I'd try to go the other direction.
15:42:28 <int-e> merijn: debian stable is on 8.4 so 8.0 must be old ;-)
15:42:36 <merijn> ByteString not being a Monoid sounds wrong
15:42:47 <merijn> Are you sure it wasn't just Monoid not being in Prelude?
15:42:49 <pikajude> bytestring is a monoid
15:43:05 <merijn> int-e: I was looking at HasCallStack which in my mind was a really new addition
15:43:07 <dsal> I don't know.  I was just looking at the diff.  I didn't actually try the code.
15:43:17 <dsal> <> was replaced with `BL.append` in a bunch of places.
15:43:44 <merijn> Turns out it is 3 years old
15:43:53 <merijn> dsal: <> wasn't in Prelude until recently
15:44:10 <merijn> dsal: So I suspect the change was not that ByteString isn't a Monoid, but that
15:44:21 <dsal> I remember semigroup and monoid splitting as well.  Yeah, might not have been necessary.
15:44:47 <merijn> ByteString has been a Monoid since the very first version on Hackage :p
15:44:49 <dsal> I don't know much of the differences in various GHC releases.
15:45:02 <merijn> Which dates to 2007 ;)
15:46:53 <merijn> anyhoo, bedtime
15:54:13 <pikajude> monoids had been invented by 2007? :o
15:58:26 <EvanR> at least since 1930
15:59:22 <pikajude> neat
15:59:46 <pikajude> category theorist in 1930: "hmm, someday people will want to append strings in their IRC bot"
16:00:35 <EvanR> category theory was invented later
16:00:39 <hpc> "hmm, someday people will want this in their cateogories of endofunctors"
16:01:02 <EvanR> actually monoids is either 1 or 2 decades back from 1930
16:02:35 <pikajude> people in the 1930s tended to have a lot of endofunctors lying around
16:03:22 <Rembane> It was very chaotic back in the day
16:04:16 <palo> dmwit: yea I just checked, having two constructors is a bad idea, if I want to use Aeson, do serialize and deserialize every now and tan. 
16:04:26 <dmj`> who is igfoo 
16:04:32 <dmj`> on the GHC commit list
16:05:05 <dmj`> https://github.com/igfoo
16:05:35 <dmj`> who has the most commits on ghc
16:06:36 <boj> probably Ben Gamari
16:10:50 <boj> oh wow, if i had read one line up...
16:11:00 <boj> too tired today, sorry :p
16:55:01 <dycan> Hi, I have a yesod project that have a lot of packages. it keep "stack: internal error: Unable to commit 2091909120 bytes of memory" when compiling. I have no clue of what to do. I have 11G free memory.
17:00:15 <ScaredySquirrel> hey guys how would I code low level ala C in Haskell?
17:00:28 <ScaredySquirrel> if I wanted to make an OS in Haskell, that is
17:02:18 <iqubic> Well, I did my first ever bit of Java programming today.
17:02:24 <iqubic> Well, not first ever.
17:02:36 <iqubic> But first in over 2 years.
17:03:19 <ScaredySquirrel> lol lol jnode.org
17:03:27 <ScaredySquirrel> a Java operating system
17:04:01 <iqubic> And I was so so accustomed to Haskell that I forgot my curly braces, and I forgot my semicolons and I forgot my parens around parameters to function calls, and I often tried to partially apply my functions.
17:05:13 <iqubic> It was a painful day.
17:05:29 <iqubic> I think this is going to be a good class for me to be in.
17:07:03 <hpc> i have something similar with python
17:07:30 <hpc> i constantly think it's going to tell me when i combine things of the wrong type
17:07:33 <hpc> like strings and ints
17:07:54 <hpc> or when i am looking for a package i keep thinking i can just go to pypi and have the documentation there in a standard format
17:08:34 <iqubic> I also tried to add a Show contraint to a function where I knew I was going have 'System.out.println' call. I spent 10 minutes in class trying to figure out what the hell was going wrong.
17:09:02 <iqubic> I called the professor over, and he told me that 'Show' wasn't a thing in Java.
17:09:11 <iqubic> I felt really dumb.
17:09:48 <hpc> wait until you try to write read and find out that sort of polymorphism isn't even possible in java
17:10:26 <iqubic> I also got screwed over by trying to append strings with '++'
17:10:50 <iqubic> And also I called toString on everything, because I thought that you could only append one string to another.
17:11:18 <iqubic> toString is the show of Java. Well, sorta kinda, maybe not.
17:12:54 <iqubic> hpc: Why do you say that the kind of polymorphism needed for Read isn't possible in Java?
17:14:30 <hpc> iirc, it doesn't know how to pick an implementation without a lot of help
17:14:40 <iqubic> I don't think you can.
17:14:51 <hpc> it has trouble with return type polymorphism where there isn't a pre-existing object to start from
17:15:09 <iqubic> That's right.
17:17:38 <iqubic> You can define 'public static <T extends Foo> T (T bar) { ... }'
17:18:06 <iqubic> where bar is something that is either a Foo, or a subclass of Foo.
17:19:00 <iqubic> And that just works. I think. Not sure.
17:21:02 <iqubic> 'if (foo.compareTo(bar) > 0)' in Java is the same as '(foo > bar)' in Haskell.
17:21:23 <iqubic> Java... Please just let me define my own overloaded operators please.
17:25:22 <shachaf> This is not the Java channel, so this all seems pretty offtopic.
17:26:28 <iqubic> I'm going to stop my rant
17:29:34 <iqubic> hpc: What term would you give to the kind of polymorphism that Java has?
17:33:36 <dibblego> can we take the java elsewhere please?
17:34:39 <iqubic> Alright. I can do that.
17:34:58 <dibblego> thanks mate
17:36:09 <ScaredySquirrel> erm...any Haskell books?
17:36:38 <dmwit> ?where books
17:36:38 <lambdabot> See `LYAH',`RWH',`YAHT',`SOE',`HR',`PIH',`wikibook',`PCPH',`HPFFP',`HTAC',`TwT',`FoP',`PFAD',`WYAH',`non-haskell-books'
17:37:04 <dmwit> You can play with those in privmsg.
17:37:06 <dmwit> Like this:
17:37:08 <dmwit> ?where PIH
17:37:09 <lambdabot> "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
18:11:23 <dansho> i don't get this, why can't the type checker figure out this is a scalar multiplied by a matrix here? https://paste.ee/p/ruAs2
18:16:09 <EvanR> that's annoying, "line 54" is not line 54 
18:16:25 <ClaudiusMaximus> :t (*)
18:16:26 <lambdabot> Num a => a -> a -> a
18:16:49 <ClaudiusMaximus> maybe you meant (^^*) or something to multiply scalar by matrix
18:17:42 <dansho> EvanR: i took out some code to make it more concise
18:18:37 <dansho> ClaudiusMaximus: it "just works" when i try in the REPL
18:19:29 <ClaudiusMaximus> example code?  if you use a numeric literal, then note:
18:19:31 <ClaudiusMaximus> :t 5
18:19:32 <lambdabot> Num p => p
18:20:03 <dansho> https://paste.ee/p/Fe1vy
18:21:11 <c_wraith> dansho: it's because you told it rate is a Double 
18:21:30 * hackage symbiote 0.0.0.1 - Data serialization, communication, and operation verification implementation  https://hackage.haskell.org/package/symbiote-0.0.0.1 (athanclark)
18:21:41 <c_wraith> dansho: and the type of (*) requires both args to be the same type. 
18:22:11 <ClaudiusMaximus> if you put (2.0 :: Double) you would probably get a similar error
18:22:19 <ClaudiusMaximus> :t 2.0
18:22:20 <lambdabot> Fractional p => p
18:22:38 <ClaudiusMaximus> there is probably an instance Fractional Matrix or so
18:22:51 <ClaudiusMaximus> so it works in the repl
18:27:09 <dansho> so somehow 2.0 is being used to implicitly create an L 1 3 in the repl?
18:29:19 <dansho> what the... https://paste.ee/p/HihwU
18:29:24 <c_wraith> yes, but not "somehow". it's part of the Fractional class
18:29:49 <c_wraith> :t fromRational
18:29:51 <lambdabot> Fractional a => Rational -> a
18:30:20 <c_wraith> all numeric literals with a decimal point in them are compiled as calls to fromRational
18:31:25 <c_wraith> and numeric literals without a decimal point are compiled as calls to fromInteger
18:31:50 <dansho> i guess my question is, how to do scalar multiplication with hmatrix static?
18:32:10 <dansho> the num instance only covers matrix x matrix product
18:37:12 <dansho> :t toRational
18:37:14 <lambdabot> Real a => a -> Rational
18:39:20 <c_wraith> it looks like scaling was accidentally left out of the .Static module as much as anything. 
18:39:59 <c_wraith> the Matrix type has a scale operation. 
18:40:35 <dansho> i guess this works for now > ((fromRational . toRational) (2.0 :: Double)) * (matrix [1.0, 2.0, 3.0] :: L 1 3)
18:41:07 <c_wraith> that has a name. I wish I could remember it... 
18:42:44 <shachaf> realToFrac
18:43:03 <c_wraith> thank you
18:44:46 <dansho> ty
18:48:47 <c_wraith> dansho: BTW, you could lean a bit more heavily on lens in the body of learn, something like:  ... = net &~ do { weights1 -= delta1 ; weights2 -= delta2 } 
18:49:59 <nshepperd> :t (&~)
18:50:00 <lambdabot> s -> State s a -> s
18:50:05 <nshepperd> neat
19:28:47 <maralorn> Wow … mdo does not help with type inference …
19:30:16 <dmj`> @def data Person = Person { personName :: String, personAge :: Int } deriving (Show, Eq)
19:30:17 <lambdabot>  Defined.
19:32:07 <dmj`> @def showPerson :: Person -> String; showPerson = { name <- personName; age <- personAge; return (name ++ " " ++ show age) }
19:32:08 <lambdabot>  Parse failed: Parse error: {
19:32:29 <dmj`> @def showPerson :: Person -> String; showPerson = do { name <- personName; age <- personAge; return (name ++ " " ++ show age) }
19:32:30 <lambdabot>  Defined.
19:32:42 <dmj`> > showPerson (Person "foo" 12)
19:32:44 <lambdabot>  "foo 12"
19:49:30 * hackage hw-prim 0.6.2.32 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.6.2.32 (haskellworks)
19:58:30 * hackage vega-view 0.3.1.3 - Easily view Vega or Vega-Lite visualizations.  https://hackage.haskell.org/package/vega-view-0.3.1.3 (DouglasBurke)
21:01:07 <dmwit> :t liftA2 (\name age -> unwords [name, show age]) personName personAge
21:01:08 <lambdabot> Person -> String
21:01:51 <dmwit> :t unwords . sequence [personName, show . personAge]
21:01:52 <lambdabot> Person -> String
22:41:11 <sicklork1n> Is anyone familar with persistent? I'm trying to understand why the migrations look for column `Id` when using foreign_key references on tables and how I can configure it not to do this.  https://pastebin.com/J7Qf0LiR
22:52:16 <dminuoso> Mmm, is having a polymorphic MonadReader that can alter the environments type possible/sensible?
22:53:23 <Axman6> which types do you want?
22:53:45 <dminuoso> Oh mmm. I just realized not even ReaderT's local allows you to do tihs.
22:54:09 <jle`> what is a polymorphic MonadReader
22:55:30 <Axman6> you could have something like local using lenses: within :: Lens r s -> ReaderT s m a -> ReaderT r m a
22:55:35 <dminuoso> Well I was thinking about something like `local :: (r -> s) -> ReaderT r m a -> ReaderT s m a`
22:55:37 <Axman6> @hoogle  Lens r s -> ReaderT s m a -> ReaderT r m a 
22:55:38 <lambdabot> Data.Lens.Light zoom :: (MonadStateT stateT, MonadState s (stateT s m), MonadTrans (stateT s), Monad m) => Lens s s' -> stateT s' m a -> stateT s m a
22:56:13 <Axman6> only needs to be a Getting actually, since it's not written back
22:56:28 <Axman6> @hoogle  Getting r s -> ReaderT s m a -> ReaderT r m a 
22:56:29 <lambdabot> No results found
22:57:14 <cocreature> :t magnify
22:57:16 <lambdabot> Magnify m n b a => LensLike' (Magnified m c) a b -> m c -> n c
22:57:51 <cocreature> but zoom/magnify don’t really work in MonadState/MonadReader since they change the "m"
22:58:02 <jle`> dminuoso: that's a polymorphic Reader, yeah
22:58:11 <jle`> but MonadReader itself cannot be polymorphic because of the fundep
22:58:33 <dminuoso> And I suppose the ReaderT local cant either because it would invalidate its use within do/>>=
22:59:08 <dminuoso> Can something like this exist at all? 
23:01:22 <Axman6> dminuoso: I assume you want local :: (r -> s) -> ReaderT s m a -> ReaderT r m a?
23:02:36 <Axman6> "If you can read an s from an r, and have areader of s, then youy can embed that within a reader of r"
23:04:27 <dminuoso> % :t withReaderT
23:04:27 <yahb> dminuoso: forall k r' r (m :: k -> *) (a :: k). (r' -> r) -> ReaderT r m a -> ReaderT r' m a
23:04:42 <dminuoso> Oh wow.
23:06:07 <dminuoso> This actually makes sense.
23:12:47 <Nevoic> What is the simplest HTTP client library in Haskell, in your opinion?
23:13:00 <dminuoso> Nevoic: wreq ?
23:14:20 <Nevoic> From very preliminary looks, they use some unconventional operators, like .~ and ^.
23:14:30 <Nevoic> Are those seldom used? Or do you just get used to them?
23:15:28 <dminuoso> Nevoic: Those are just from lens.
23:16:14 <Nevoic> Yeah I see that, I've been consciously avoiding lens because it seems intense. Is that a mistake?
23:16:42 <Nevoic> I understand about 50% of the first two paragraphs that describe the library.
23:16:59 <cocreature> I tend to go with the "req" library these days
23:17:13 <dminuoso> Nevoic: lens is a novel way to deal with deeply nested data, and providing accessors to nested fields as first-class values. 
23:17:30 <dminuoso> Nevoic: I think basic lens competency is useful and really easy to attain.
23:17:47 <Nevoic> Dealing with nested data? You mean like `response["thing"]["other_thing"]["here"]`?
23:17:57 <sicklork1n> cocreature: nice 
23:17:59 <dminuoso> Nevoic: Yes.
23:18:30 <Nevoic> I don't know what you mean by providing accessors to nested fields "as first-class values".
23:18:40 <dminuoso> Nevoic: So with lens you might write something like `response ^. thing . other_thing . here` to do the same.
23:18:49 <dminuoso> (Where thing, other_thing and here are suitable lenses)
23:18:52 <Axman6> lens is like the single most useful Haskell library
23:19:01 <jle`> Nevoic: in the case of repsonse["thing"]["other_thing"]["here"], the bracketing syntax ["thing"] is a built-in part of the language
23:19:18 <jle`> Nevoic: "first-class" means that we can implement it using normal values, without any language built-in syntax
23:19:57 <Nevoic> jle` that's cool, I definitely like that extensibility about Haskell. I appreciate how simple operators like `+` etc. can be defined as just functions instead of special syntax.
23:20:00 <dminuoso> Nevoic: Well I can take `thing . other_thing . here`, which is a composition of multiple lenses into a single lens. That lens can be imagined as an optical construction with glass lenses that, if pointed at some structure, will focus on some particular part. And you can use that thing to read or write. :)
23:20:13 <Nevoic> At a usability level though, there's a distinction drawn with lens that isn't with the original.
23:20:23 <dminuoso> Nevoic: So the ability to hold that lens in your hand as a value (and manipulate it, pass it around, compose it) is very useful.
23:20:33 <Axman6> say you have a function which modifies URLS, turns them afrom HTTP to HTTPS. if you have a deeply nested URL in your type, you can say: myNEsterData & fooField . barField . theURL %~ makeSecure
23:20:37 <Nevoic> i.e all the nested values are "the same" (they're all accessed with []). In Haskell there's ^. & . there
23:20:37 <jusss> stack can not update index (no local copy) , this is supposed ?
23:20:41 <jusss> for everyone?
23:20:42 <Nevoic> I know `.` is function composition.
23:20:57 <dminuoso> Nevoic: (&) is just a flipped around ($) with some fixity.
23:21:14 <jle`> Nevoic: ^. ^? & etc. are more closer parallels with different types of access
23:21:15 <Axman6> but you can also apply that function to _all_ URLs, with the same syntax: listOfMyData & each . fooField . barField . theURL %~ makeSecure
23:21:20 <jle`> Nevoic: but . is the same at every level
23:21:32 <jle`> or in some libraries they use % instead of . for visual distinction
23:21:34 <dminuoso> Nevoic: For what its worth, the truly mind boggling thing is `.`
23:21:48 <Nevoic> Wait, you're referring to "lens". In my original, they were just strings. Is there some new data structure I have to define called a "lens" to access fields?
23:22:00 <dminuoso> Nevoic: Right. 
23:22:01 <jle`> Nevoic: yeah, lenses are a type
23:22:15 <jle`> `Lens' s a` represents a field of type 'a' inside an 's'
23:22:17 <dminuoso> Nevoic: So for each field you would create a value representing a lens that can point at that field.
23:22:31 <jle`> Nevoic: so ["thing"] here would be replaced by a lens of type Lens' BigThing LittleThing
23:22:34 <dminuoso> Nevoic: lens offers template-haskell helpers to automatically generate them for data. :)
23:22:48 <dminuoso> And there's a few utilities to easily create them from a pair of a "setter" and "getter" function
23:23:21 <Nevoic> I'm a bit lost as to what a lens actually is. It's a type that represents a field `a` inside an `s`.
23:23:23 <jle`> Nevoic: alternatively there are generics-based ways to automatically generate a lens based on a symbol string
23:23:34 <dminuoso> Nevoic: Yees, sort of.
23:23:44 <jle`> Nevoic: well, that's the type. the information inside gives you a way to get and set that 'a' int he 's'
23:23:48 <jle`> and that's it :)
23:24:11 <jle`> a `Lens' s a` is essentially a (s -> a) (get the 'a') and a (a -> s -> s) (set the 'a')
23:24:20 <Nevoic> When you say "in the s" do you mean `s` is of kind * -> * ?
23:24:23 <dminuoso> Nevoic: A lens is just some object that can be thought of "a first-class path from some object into some smaller part/field of ot"
23:24:37 <jle`> Nevoic: not necessarily
23:24:41 <dminuoso> Nevoic: By first-class I merely mean that you can bind it to a variable, pass it to functions, etc.
23:24:48 <jle`> say i have data Person = P { pName :: String, pAge :: Int }
23:24:54 <jle`> then a lens into the name would have type Lens' Person String
23:25:03 <jle`> a lens into the age would have type Lens' Person Int
23:25:09 <Nevoic> diminuoso I see, so you can capture some repetitive nested retrieval action.
23:25:18 <Nevoic> If I'm understanding correctly.
23:25:30 <dminuoso> Nevoic: Well you can separate the "retrieval" from the "how do I get there"
23:25:36 <Nevoic> Yeah, I feel.
23:25:41 <dminuoso> Nevoic: and that "how do I get there" is composable, so if you have two "paths" you can compose them together.
23:25:55 <jle`> dminuoso's description is accurate, but i think it's a really fancy way of just saying it's an (s -> a) and an (a -> s -> s)
23:26:11 <jle`> all of these magical composibility properties come from the fact that these are just functions
23:26:20 <jle`> (s -> a)'s are composable, and (a -> s -> s)'s are composable
23:26:23 <jle`> because they're just...normal functions
23:26:28 <dminuoso> % (1, "foo", 'c') ^. _2
23:26:29 <yahb> dminuoso: "foo"
23:26:36 <Nevoic> Yeah, I know . is just standard function composition.
23:26:40 <dminuoso> Nevoic: Here `_2` is an optic that points at the second field of something.
23:26:44 <jle`> well, i don't mean standard function composition
23:26:58 <dminuoso> % (1, ("quux", 1.23,) 'c') ^. (_2 . _1)
23:26:59 <yahb> dminuoso: "quux"
23:27:07 <Nevoic> But you're just throwing polymorphic functions at me. `s -> a` doesn't really have any meaning to me.
23:27:09 <dminuoso> Nevoic: here I construct a path "First go into the second thing, then into the first thing"
23:27:20 <Nevoic> It doesn't clear up the purpose of `lens` is all, I understand it's going to be extremely generic and because of that it's going to be helpful.
23:27:30 <jle`> Nevoic: sure, so a lens into the name field, a `Lens' Person String`, is a Person -> String
23:27:35 <jle`> and a String -> Person -> Person
23:27:55 <jle`> in the type above, a lens into the age field, an Lens' Person Int, contains a Person -> Int, and an Int -> Person -> Person
23:27:57 <Axman6> i.e. a getter and a setter
23:28:07 <jle`> you can see that the Person -> String is a function to "get" the name from a person record
23:28:19 <jle`> and the String -> Person -> Person is a function to "set" the name in a person record
23:28:32 <dminuoso> Nevoic: So the point is that I can take these optics like `_1` and `_2`, compose them together to gain a path, and then I can use `^.` to use that optic and sort of "zoom" into some complex data. With %~ I can zoom in and *modify* the data.
23:28:49 <Nevoic> dminuoso I also don't know what an optic is.
23:29:24 <dminuoso> Nevoic: optic is just a more general term than lens.
23:29:57 <Nevoic> I see jle` so the s -> a -> a is a setter and an a -> s is a getter.
23:30:09 <jle`> Nevoic: yeah, that's really all a lens is
23:30:27 <jle`> you can imagine basically `data Lens' s a = Lens' { get :: s -> a, set :: a -> s -> s }
23:30:58 <jle`> if you define this type, you can start to imagine interesting ways you can assemble such a value
23:31:26 <dminuoso> Nevoic: The reason I called them optics is because there's other things than Lens. For example there's also Prism, which is like a Lens but for product types. For example say you have some `(Char, Maybe Int)` and you want to focus on the Int if its there. then you could do something like `_2 . _Just`
23:31:30 <jle`> for example, if you have a `Lens' a b` and a `Lens' b c`, then you can actually construct a `Lens' a c`
23:31:38 <jle`> this fact isn't super obvious
23:31:50 <dminuoso> *sum types, pardon e.
23:31:55 <jle`> but it means that if i have a `Lens World Person` and a `Lens Person String`, i can 'compose' them to get a `Lens World String`
23:32:30 <iqubic> dminuoso: Lenses embody Products, Prisms embody Sums.
23:32:32 <jle`> Nevoic: i recommend actually trying to implement this composition on your own actually, it'll give you some insight on how this lifting anc omposition actually works
23:32:36 <iqubic> Not what you said.
23:32:44 <dminuoso> iqubic: I corrected myself.
23:32:56 <iqubic> jle`: Isn't that composition just the same as:
23:33:00 <iqubic> :t (.)
23:33:02 <lambdabot> (b -> c) -> (a -> b) -> a -> c
23:33:04 <Nevoic> dminuoso so you're saying instead of constructing a function that pattern matches on (Char, Maybe Int), like `a Just n` and `a Nothing`, you'd instead use an optic (Prism more specifically) to retrieve the nested value.
23:33:20 <Nevoic> What would be the return type of using the "prism" on `(Char, Maybe, Int)`?
23:33:23 <jle`> iqubic: i mean for the Lens type that I wrote earlier, data Lens' s a = Lens' { get :: s -> a, set :: a -> s -> s }
23:33:30 <iqubic> Ah. I see.
23:33:36 <iqubic> That would be enlightening.
23:33:40 <Nevoic> A `Maybe Int`? Because sometimes the Int doesn't exist. Or does it just return the bottom type on Nothing and crash?
23:33:46 <dminuoso> Nevoic: Right! And you can keep on going. So say if you had some (Char, Maybe (String, Int))` you could focus on the String (if its there) by using `_2 . _Just . _1`
23:33:47 <Nevoic> Because that'd be terrible IMO
23:33:53 <Nevoic> But I assume it doesn't crash
23:33:55 <iqubic> No.
23:34:05 <iqubic> it just returns a "Maybe String"
23:34:14 <Nevoic> Okay, that's cooler.
23:34:36 <Nevoic> Is it doing binds under the hood?
23:34:41 <Nevoic> Seems like I'd be using >>= here.
23:34:43 <Nevoic> I could be wrong
23:34:43 <iqubic> Nope.
23:34:52 <dminuoso> Nevoic: It is doing deep and black magic behind the scenes.
23:34:59 <jle`> Nevoic: the basic "idea" of working with lenses (not considering any other optics) is that you need some sort of (a -> s -> s) setter, maybe. but you don't want to write it directly from scratch
23:35:00 <iqubic> It's literally just function composition.
23:35:09 <dminuoso> Nevoic: Jokes aside, there's a cool idea to learn lenses. The basic idea you could have come up with yourself.
23:35:19 <jle`> Nevoic: maybe you have setters for each level. but it isn't obvious how to combine them together
23:35:25 <Nevoic> I mean to retrieve `Int` from `Maybe (Maybe Int)` you'd do `x >>= \i` right?
23:35:28 <Nevoic> i would be the int
23:35:35 <iqubic> You could do that.
23:35:41 <dminuoso> Nevoic: If at some point you want, I have a series of simple excercises building up to how lens works internally from my mentor in this channel. 
23:35:51 <jle`> Nevoic: for example, if i have a `World` that contains a `Person`, and a `Person` that contains a `Name`, then and i want a setter for `Name` in `World` ... i could write it from scratch
23:36:05 <iqubic> dminuoso: That set of exercises is really cool.
23:36:09 <jle`> Nevoic: but what if i told you that there was a way to combine a setter for a Person in a World, and a setter for a Name in a Person .... and turn it into a setter for a Name in a World?
23:36:11 <dminuoso> Nevoic: I'd recommend not to ask how it works internally, because there's a lot of deep theory.
23:36:28 <iqubic> I still have my code and solutions to those exercises save on my computer.
23:36:39 <jle`> note that the implementation of lens isn't necessarily deep theory or a lot of magic 
23:36:43 <dminuoso> iqubic: You want some other fun excercise?
23:36:50 <jle`> it can actually be very simple
23:37:03 <Nevoic> Alright, well I may have a very preliminary & basic understanding of what a lens is now.
23:37:06 <iqubic> Not at midnight. But I'd love to do something at a later time.
23:37:07 <jle`> i think characterizing lenses as deep magic sort of does it some disservice
23:37:18 <dminuoso> Perhaps you are right.
23:37:26 <jle`> if you think of a Lens as a pair (s -> a) and (a -> s -> s), then composing lens is just ... combining functions
23:37:35 <dminuoso> iqubic: Ill hand it to you and you can have some fun with it when you want.
23:37:46 <iqubic> (makeLenses ''Person) is the real black magic.
23:37:47 <dminuoso> iqubic: Did we ever talk about Pretext ?
23:37:50 <iqubic> No.
23:37:53 <iqubic> Never.
23:37:54 <iqubic> Sorry.
23:38:10 <dminuoso> iqubic: Comonad? ComonadReader?
23:38:11 <iqubic> It sounds like a snoc list of Chars.
23:38:16 <Nevoic> I feel like this is going to be more complex than retrieving nested data structures in other languages though, why isn't the idiom in Haskell just to replace `response["test"]["potato"]` with `response !! test !! potato`?
23:38:33 <jle`> Nevoic: if you think of a lens as just a getter and setter pair, then their implementation can be 'dead simple', in that they can be addressed in an early haskell course
23:38:36 <iqubic> I know about comonads.
23:38:38 <jle`> Nevoic: no, it can be that simple
23:38:38 <iqubic> Yes.
23:38:41 <Nevoic> I recognize the inherent lack of safety usually present in those types of checks (they error out in Python, Kotlin, and Haskell), but not in say Ruby.
23:38:56 <Nevoic> Well the example above was to do `response ^. test . potato`.
23:39:00 <jle`> Nevoic: well, combining getters is simple, but combining setters is the not-as-clean thing
23:39:06 <pikajude> those error out in python?
23:39:07 <dminuoso> iqubic: Ever studied the Store comonad?
23:39:09 <pikajude> wot
23:39:14 <iqubic> dminuoso: I think the comonad read is the Store comonad.
23:39:20 <Nevoic> The thing is it's different though. If it was `resposne ^. test ^. potato` I'd see the consistency.
23:39:20 <iqubic> But I have no idea what it is.
23:39:23 <jle`> Nevoic: you can just do getPotato (getTest response), if you're just concerned about getters
23:39:28 <dminuoso> iqubic: Not quite, ComonadReader is a more general interface.
23:39:32 <jle`> Nevoic: actually, that works :)
23:39:35 <Nevoic> pikajude it errors out if the values don't exist.
23:39:41 <pikajude> ruby does too though
23:39:42 <jle`> Nevoic: it's just associating differently than you might think
23:39:55 <Nevoic> ruby returns nil, although you're right actually doing nested searches would throw a nil class error.
23:39:55 <jle`> Nevoic: response ^. test ^. potato is equivalent to response ^. test . potato
23:39:57 <dminuoso> iqubic: ComonadReader is basically an mtl-style (or cmtl if you want) typeclass/interface.
23:39:58 <iqubic> I once uses a Stream of Streams to implement a comonadic version of the Game of Life. It was way cool.
23:40:05 <Nevoic> You have to modify NilClass to not error out on nested searches.
23:40:06 <jle`> Nevoic: in the same way that f . g $ x is the same as f $ g $ x
23:40:07 <iqubic> Oh. That's really cool.
23:40:10 <Nevoic> Which I've done, just forgot it's not default behavior in Ruby.
23:40:28 <jle`> Nevoic: what you're doing in response ^. (test . potato) is building up a potato-in-test lens, and running it using ^.
23:40:31 <iqubic> dminuoso: It's a shame we don't have codo notation.
23:40:53 <iqubic> We have rebindable syntax, but that's messy and unclean.
23:40:54 <jle`> Nevoic: what you're doing in (response ^. test) ^. potato is running the test lens with ^. on response to get the test field, then running the potato lens again on that result to get the potato field
23:40:59 <dminuoso> iqubic: But we do...
23:41:03 <iqubic> Oh?!?!
23:41:13 <dminuoso> iqubic: http://hackage.haskell.org/package/codo-notation
23:41:20 <Nevoic> jle` I see. Is there an actual runtime disadvantage to this?
23:41:32 <jle`> Nevoic: so the difference between (response ^. test) ^. potato and response ^. (test . potato) is the same as the difference between f $ g $ x and f . g $ x
23:41:45 <jle`> Nevoic: the advantage is the same as the advantage of function composition: you start shifting the things you give meaning to
23:41:47 <Nevoic> because IIRC f $ g $ x will have exactly the same runtime as f . g $ x
23:41:57 <jle`> Nevoic: now the *accessor* is something that you can think about building up
23:42:01 <jle`> instead of the intermediate values
23:42:03 <iqubic> dminuoso: Ah. So it's just using template haskell to desugar the syntax for you. Nice.
23:42:13 <dminuoso> iqubic: QuasiQuoters actually.
23:42:16 <Nevoic> I see what you mean I think. I've experienced that in other things in Haskell too, I start to realize I can build abstractions where I normally wouldn't.
23:42:16 <jle`> Nevoic: right, the advantage isn't in performance, it's in the shift in conceptual focus
23:42:28 <jle`> between f . g $ x and f $ g $ x
23:42:38 <jle`> in f . g $ x, (f . g) is now given a semantic meaning
23:42:44 <jle`> detached from whatever value you might eventually apply it to
23:42:50 <Nevoic> Yeah I feel that.
23:42:53 <Nevoic> Alright, that's pretty interesting.
23:43:05 <iqubic> dminiuoso: So what is it you want to tell me about ComonadReader, other than "It's a great online publication"?
23:43:05 <jle`> so you *can* write response ^. test ^. potato every time
23:43:09 <jle`> *or*, you can say
23:43:13 <jle`> testPotato = test . potato
23:43:21 <jle`> and then write response ^. testPotato
23:43:24 <dminuoso> iqubic: Gotta run to the office. Ill post the excercise in 10 minutes if you are still there.
23:43:32 <iqubic> I should still be here.
23:43:38 <jle`> Nevoic: do you see how this idea of 'first-class' field gives you a new way to think about fields?
23:43:38 <Nevoic> yeah I think I got all that when it clicked for me a second ago, that's for the clarification though, cool to know we're on the same page there :)
23:43:49 <jle`> now you can think of 'testPotato' as a field
23:43:59 <jle`> this is something that you can't do with ["test"]["potato"] accessing
23:44:02 <Nevoic> I've done the same kind of thing with say `map`.
23:44:20 <jle`> in response["test"]["potato"], ["test"]["potato"] doesn't make sense on its own
23:44:20 <Nevoic> building up functions in a similar kind of fashion (either with currying or function composition)
23:44:34 <iqubic> Wait... I was thinking of the Monad Reader.
23:44:45 <jle`> yeah, and i think that's the big picture of lenses in specific: instead of just one-offing or writing from scratch your getters/setters, you think of them as values in and of themselves
23:44:48 <jle`> and you can construct them first-class
23:45:03 <jle`> in the end, you use them by "running" them, with get/set/^./%~/.etc
23:45:12 <jle`> but the fun part is in the journey, not the eventual running of them
23:45:13 <Nevoic> jle` but there is a downside in the `lens` version of this, if I'm not mistaken, since it's impossible to write `response ^. "test" . "potato"`.
23:45:15 <Nevoic> Unless it's not impossible.
23:45:38 <jle`> it's possible, you can get response ^. field #test . field #potato
23:45:52 <jle`> if you're talking about using symbols as accessors
23:45:52 <Nevoic> wut
23:46:07 <iqubic> Haskell doesn't support that.
23:46:08 <jle`> yeah, in this case 'field #test' is a lens
23:46:13 <iqubic> Oh. Right.
23:46:21 <iqubic> :t (#)
23:46:23 <lambdabot> error: parse error on input ‘)’
23:46:36 <jle`> Nevoic: the important thing here isn't "how" you get the lens, it's the fact that you can get them somehow :)
23:46:43 <jle`> it's -XOverloadedLabels
23:46:47 <Nevoic> But no matter what you do you have to construct some additional data structure, right? The downside I'm talking about is that you don't have to do that in every other language I've worked in.
23:46:53 <iqubic> jle`: That's right.
23:47:07 <jle`> Nevoic: 'data structure' is a loose word here
23:47:08 <Nevoic> I can see how lens can be interesting and useful, but being forced to do them seems like it could be verbose or extraneous if you can't find some abstraction to build with the lens.
23:47:18 <thunderseethe> Nevoic: What do you mean by additional data structure?
23:47:21 <jle`> Nevoic: when you do f $ g $ x vs. f . g $ x, is it "constructing some additional data structure" ?
23:47:32 <Nevoic> No I don't.
23:47:42 <jle`> becuase you're construcing a function (f . g) first before applying it
23:47:45 <Nevoic> My understanding is that I have to make a `test` lens.
23:47:49 <iqubic> jle`: Isn't that the the same exact outcome either way?
23:48:03 <jle`> Nevoic: well, you can make it, in the same way that you have to 'make' a (f . g)
23:48:11 <jle`> Nevoic: but f $ g $ x is, in the end, the same as (f . g) $ x
23:48:18 <iqubic> Right.
23:48:19 <Nevoic> But from what I'm gathering `response ^. "test" . "potato"` isn't valid.
23:48:24 <Nevoic> `response ^. test . potato` is.
23:48:33 <pikajude> yea cause "test" isn't a function
23:48:36 <Nevoic> where `test` and `potato` are defined not by literals, but by some additional code.
23:48:40 <jle`> Nevoic: that's like saying ("f" . "g") $ x is valid but "f" . "g" $ x is
23:48:41 <Nevoic> i.e other functions.
23:48:47 <jle`> er, ( f . g) $ x is
23:48:52 <jle`> Nevoic: function construction is cheap in Haskell
23:48:58 <iqubic> Nevoic: do you know what TemplateHaskell is?
23:48:59 <jle`> that's why you don't complain about ( f . g ) x, right?
23:49:02 <Nevoic> I'm not concerned about the function composition at all.
23:49:10 <Nevoic> I think I am most likely misunderstanding something.
23:49:16 <Axman6> if you just care about working with JSON, you can use the lens-aeson package, and use response ^. resposeBody . key "test" . key "potato"
23:49:22 <jle`> Nevoic: do you understand why f $ g $ x is the same as (f . g) $ x?
23:49:26 <jle`> Nevoic: if so, then it's the same situation here
23:49:35 <jle`> the actual lens might not ever exist at runtime
23:49:42 <iqubic> I think Nevoic should be told about the MakeLens TH thing.
23:49:48 <jle`> (f . g) $ x is compiled directly to f (g x)
23:50:06 <Nevoic> I think my concern is definitely not coming across, you guys are focusing on something else.
23:50:06 <jle`> Nevoic: so this 'data structure' you are worried about...doesn't even necessarily exist when you actually run it
23:50:11 <Nevoic> I'm definitely doing a poor job conveying my actual concern.
23:50:12 <jle`> it gets inlined, so there is no performance cost
23:50:22 <iqubic> I think I understand it well enough.
23:50:39 <jle`> Nevoic: i think your concern is that constructing a lens takes 'work', and so it's more expensive than just direct function application
23:50:42 <Nevoic> I think Axman6 responded to my actual concern.
23:50:52 <jle`> Nevoic: but when you actually run the lens, the 'data structure' disappears
23:51:00 <Nevoic> No.
23:51:00 <iqubic> I think we should talk about how MakeLenses can be used to automate the process of making lenses.
23:51:07 <Nevoic> I don't think so, at least.
23:51:32 <jle`> Nevoic: oh, you mean that lenses must take up namespaces ?
23:51:38 <jle`> extra namespace in the module export
23:51:56 <iqubic> That's why most lenses are prefixed with an underscore.
23:52:04 <Nevoic> I was simply under the impression that doing `response ^. "test" . "potato"` was impossible in Haskell, and instead you'd have to have a line like
23:52:04 <Nevoic> test = some code to construct a lens here
23:52:06 <jle`> you aren't concerned about runtime costs or anything, ah.
23:52:10 <Nevoic> an then same with potato
23:52:17 <Nevoic> like potato = some other code to construct a lens with the previously defined test
23:52:25 <jle`> Nevoic: ah yeah, if your field is actually a field, then you can have a function String -> Lens blah blah
23:52:28 <Axman6> Nevoic: take a look at https://conscientiousprogrammer.com/blog/2015/12/04/24-days-of-hackage-2015-day-4-wreq-web-client-programming-with-notes-on-lens-and-operator-syntax/
23:52:38 <jle`> so response ^. field "potato" . field 'test"
23:52:46 <jle`> Nevoic: remember, first-class accessors
23:52:54 <jle`> so String -> Lens' Blah Thing is perfectly valid :)
23:52:58 <jle`> that's one advantage of first-classness
23:53:25 <iqubic> I've never had to use Lens s t a b ever.
23:53:35 <Axman6> if you're just working with JSON, potato = key "potato" is something you can do. if you want to use proper types, then you can derive lenses for the fields of that type and define a FromJSON instance for your type 
23:53:36 <jle`> you can have a function that takes a string, like "test" or "potato", and return a lens into the field corresponding to that string
23:53:43 <iqubic> I can always get by with Lens' t a
23:53:46 <jle`> so it doesn't encessarily require defining any actual lenses *directly*
23:56:03 <thunderseethe> `scheme :: (Corecursive t)      => (a -> Either (Base t t) (Base t a))      -> (a -> Base t t)
23:56:15 <thunderseethe> Is there a name for a scheme that does this?
23:56:32 <thunderseethe> it's kind of like apo but I couldn't figure out if it was a standard recursion scheme
23:57:08 <Axman6> is this a recursion-schemes thing?
23:57:14 <thunderseethe> Yea
23:57:16 <iqubic> Looks like it.
23:58:23 <Axman6> Nevoic: did you have alook at that blog post?
23:58:54 <Nevoic> I'll take a look at it now, I just wanted to get some clarification. I am under the impression that these two pieces of code are roughly equivalent: https://pastebin.com/dwgNNNCV https://pastebin.com/mCuSDJZr
