00:02:38 <MechanicalError> Axman6: What about a simple object oriented backend? would haskell'sFFI help then?
00:04:45 <[exa]> "simple" and "object oriented" don't quite go together well
00:05:25 <[exa]> but generally yes, whatever you can convert to FFI-compatible data will work
00:08:51 <MechanicalError> [exa]: Terrific, thanks for the clarification.
00:10:48 <[exa]> MechanicalError: there are some counter-examples, for example the C++ objects can be "held" by pointers but the name mangling complicates any C++-style FFI
00:11:01 <[exa]> but there might have been improvements since the last time I looked
00:11:19 <[exa]> MechanicalError: do you have any specific usecase?
00:19:05 <MechanicalError> I just wanted to make a something with rust and haskell nothing specific yet
00:23:04 <homebeach[m]> this seems to do what I want: [[ x | x <- xs, head xs == y || last xs == y]| xs <- xxs]
00:23:31 <homebeach[m]> but how should I make it a function? This does not work: headtail xxs y = [[ x | x <- xs, head xs == y || last xs == y]| xs <- xxs]
00:25:57 <[exa]> MechanicalError: this should probably work for you https://mgattozzi.github.io/2016/10/01/haskell-rust.html
00:34:03 <[exa]> homebeach[m]: what is the code supposed to do?
00:43:30 * hackage ghc-boot-th 8.8.1 - Shared functionality between GHC and the `template-haskell`library  https://hackage.haskell.org/package/ghc-boot-th-8.8.1 (HerbertValerioRiedel)
00:56:00 * hackage ghc-boot 8.8.1 - Shared functionality between GHC and its boot libraries  https://hackage.haskell.org/package/ghc-boot-8.8.1 (HerbertValerioRiedel)
01:29:30 * hackage template-haskell 2.15.0.0 - Support library for Template Haskell  https://hackage.haskell.org/package/template-haskell-2.15.0.0 (HerbertValerioRiedel)
01:34:48 <maralorn> jle`: You took the "irc is like ships on an ocean" metaphor from numb3rs didn‘t you? (At least that‘s where I know it from. And because it seems so useless to me I thought they made it up.)
01:35:26 <maralorn> (oh, no I read the whole back log. sorry)
01:35:33 <maralorn> *know
01:36:48 <jle`> maralorn: ah yes, it was one of the few times i felt the quote would actually be relevant :)
01:39:28 <purelazy> I'm trying to understand "pointfree" style from a youtube video.
01:41:06 <purelazy> I'm not sure how "( . ) f . g" is parsed 
01:42:43 <ski> @pointless \xss -> concat (map (map sum) (filter (not . null . length . drop 2) (reverse xss)))
01:42:43 <lambdabot> join . map (map sum) . filter (not . null . length . drop 2) . reverse
01:43:01 <ski> purelazy : `((.) f) . g'
01:43:40 <ski> (application binds tighter than (normal) infix operators)
01:46:10 <purelazy> ski: Somehow, in the video, the guy ends up at (f .) . g      -
01:46:34 <cheater> dmwit: so if i try to do f x = f, ghc complains about infinite types. why does it not complain using your type T?
01:46:40 <cheater> *when using, sorry
01:47:24 <purelazy> I get the ((.) . g
01:47:56 <purelazy> ski: I mean ((.) f) . g
01:49:39 <ski> purelazy : `(+) 2 3' is the same as `2 + 3'
01:49:48 <ski> purelazy : `(+) 2' is the same as `(2 +)'
01:50:13 <ski> purelazy : `(.) f h' is the same as `f . h'
01:50:20 <ski> purelazy : `(.) f' is the same as `(f .)'
01:51:23 <ski> cheater : because it's a `newtype', which can be recursive. `type' synonyms are not allowed to be cyclic/recursive
01:52:35 <cheater> but i wasn't making a type synonym
01:52:53 <ski> the same applies
01:53:12 <cheater> so what do you call the type that ghc was trying to construct?
01:53:15 <ski> you're not allowed to form a type like `[[[[[...]]]]]', e.g.
01:53:20 <cheater> yes, i'm not
01:53:30 <ski> nor `X -> (X -> (X -> (X -> (...))))'
01:53:51 <cheater> but what's that called? i know data types, and newtypes, but both data and newtypes are allowed to be infinite. so if this is not allowed to be infinite, what form of type is it?
01:54:02 <ski> nor `forall a0. a0 -> (forall a1. a1 -> (forall a2. a2 -> (forall a3. a3 -> (...))))'
01:54:24 <ski> it's not a type at all, it's a type error
01:57:43 <lavalike> makes me think of how mandelbrot took errors, "pathological" cases, and turned them into key pieces of a beautiful theory
02:04:08 <ski> `ocaml -rectypes' allow cyclic (aka equi-recursive, as opposed to iso-recursive) types, like the above examples
02:08:19 <fooey> Hello, I have a question about an assignment from a course that just wrapped up. I'm revisiting the course, and feel like I could write it much-much-much better. Is this the right place to ask?
02:08:30 * hackage red-black-record 2.1.0.2 - Extensible records and variants indexed by a type-level Red-Black tree.  https://hackage.haskell.org/package/red-black-record-2.1.0.2 (DanielDiazCarrete)
02:15:57 <ski> fooey : ask
02:17:02 <fooey> I have a data type that is very list-like. I was hoping to give it list syntax
02:17:17 <fooey> things like `++`, `head`, etc.
02:17:23 <fooey> https://pastebin.com/cyAPbKsD
02:17:31 <fooey> that's a pastebin as an example
02:17:37 <purelazy> ski: Thanks.
02:17:55 <fooey> (also, thanks :)
02:19:02 <nil> fooey: why not  data Foo = Bar BarData | Baz BazData | Bif BifData | Bam  , and then use lists of Foo?
02:19:22 <fooey> is it possible to do something like make it an instance of a list? I tried to find an e.g. but my google-foo is bad
02:19:44 <ski> fooey : what nil said, which is factoring out the common part from the recursive data constructors
02:20:20 <fooey> @nil that's what I would like to have done, but `Foo` is given to us, and we have to work with that.
02:20:20 <lambdabot> Maybe you meant: url unpl pl id bid
02:20:54 <nil> (please don't use @ to address people)
02:21:10 <nil> well, there is no List typeclass, you'd have to define your own list-like functions
02:21:30 <fooey> bummer.
02:22:22 <nil> it's not clear what your "head" function should return either. you'd have to make another data type (essentially my Foo above) for the return type of head
02:23:47 <ski> yes
02:24:54 <fooey> at the moment, i have `getHead :: Foo -> (Foo -> Foo)`, I then implement for each of the first types in `Foo` constructor
02:25:38 <ski> oh, default argument
02:26:02 <ski> but that doesn't make that much sense anyway, since it's a `head' variant, not a `tail' variant
02:28:07 <fooey> e.g. `getHead (Baz a _) = Baz a`
02:28:32 <nil> interesting
02:28:50 <nil> sounds like dlists
02:28:59 <ski> ah
02:29:23 <ski> there's nothing hindering
02:29:30 <ski>   getHead (Baz a _) = Baz a . Baz a
02:29:31 <ski> e.g.
02:47:16 <rosalux> I am making a website with Yesod. I used the development server up to now. I tried to deploy it by compiling and running the executable, but I get an error static: getDirectoryContents:openDirStream: does not exist (No such file or directory)
02:47:36 <rosalux> Does anyone know why this happens? I can't find anything online
02:52:39 <homebeach[m]> How can I have and or or in guards? This does not work: cards (a,b)(c,d)
02:52:40 <homebeach[m]>     | (a == 's') && (b == 14) = 14
02:52:49 <rosalux> I needed a config and static file that is in the stack directory but does not compile into the executable
02:56:13 <rosalux> homebeach[m]: I think you could use a 'where' statement. cards (a,b) (c,d) | mybool == True = 14 where mybool = (a == 's') && (b == 14)
02:57:14 <nil> > let cards (a, b) (c, d) | a == 's' && b == 14 = 14 in cards ('b', 14) ((), ())
02:57:16 <lambdabot>  *Exception: <interactive>:3:5-50: Non-exhaustive patterns in function cards
02:57:22 <nil> er
02:57:27 <nil> > let cards (a, b) (c, d) | a == 's' && b == 14 = 14 in cards ('s', 14) ((), ())
02:57:30 <lambdabot>  14
02:57:40 <nil> homebeach[m]: do you have a specific error?
02:59:29 <purelazy> homebeach[m]  Did you put in an "otherwise"?
03:00:18 <purelazy> Then you will have "exhausted" the patterns
03:02:35 <nil> (for literals, you could also do  cards ('s', 14) (_, _) = 14
03:02:39 <nil> )
03:03:30 * hackage linnet 0.2.0.0 - Lightweight library for building HTTP API  https://hackage.haskell.org/package/linnet-0.2.0.0 (sergeykolbasov)
03:04:30 * hackage linnet-conduit 0.2.0.0, linnet-aeson 0.2.0.0 (sergeykolbasov): https://qbin.io/ha-drive-lgcr
03:06:06 <homebeach[m]> the problem was that otherwise was string and the other one integer
03:11:20 <Axman6> homebeach[m]: al always helps if you share the error GHC gives you, otherwise we're just guessing what could be wrong
03:18:33 <purelazy> homebeach[m] You can paste code/errors here: https://gist.github.com/
03:19:20 <purelazy> And then copy the link to this chatroom 
04:12:35 <Peter_Storm> Is there anything automatic that can derive instances for my custom monads in mtl?
04:57:39 <deagle> Hello
04:57:50 <deagle> Want to start learning haskell
04:57:54 <deagle> any good resources?
04:58:15 <deagle> http://learnyouahaskell.com/introduction#about-this-tutorial this book recommended me here
04:59:04 <nil> @where wikibook
04:59:04 <lambdabot> http://en.wikibooks.org/wiki/Haskell
05:01:44 <ski> deagle : a textbook might be nicce
05:25:43 <sm[m]> deagle: hi. Many of them, try Haskell.org/documentation or fpcomplete.com/haskell
05:26:16 <deagle> thanks guys
05:26:25 <deagle> I heard the community was super helpful :)
05:26:42 * ski blinks
05:26:57 <sm[m]> It’s true, we’re awesome.
05:27:20 <mycroftiv> i heard that rumor and consider it verified after my few weeks here
05:32:30 * hackage cassava 0.5.2.0 - A CSV parsing and encoding library  https://hackage.haskell.org/package/cassava-0.5.2.0 (HerbertValerioRiedel)
05:34:42 * Axman6 notes that the vast majority of the community did not try to help
05:35:14 <sm[m]> Well yes, there is that 95% of lazy asses
05:36:09 <sm[m]> Just kidding friends. We are 100% awesome, no problems here in #haskell land
05:36:28 <sm[m]> Just don’t mention install tools
05:37:07 <Fendor_> hahaha, or tooling ;D 
05:37:33 <sm[m]> Or try to explain monads
05:42:18 <olligobber> is there a standard implementation of unionfind in haskell? if not, I think I'll implement it myself
05:42:53 <sjhfeke> I have a question. How do Haskell programmers implement caching?
05:42:59 <sm[m]> What else.. there would be no need to mention mobile development, or compile times, or language standards
05:43:38 <sjhfeke> ugh i got into your discussion sorry
05:43:45 <sm[m]> sjhfeke: memoization is probably a good word to search for. There’s a wiki page and some package on hackage
05:44:05 <sm[m]> I like uglymemo, it’s very simple
05:45:22 <Fendor_> caching is not memoization, afaik.
05:45:40 <sjhfeke> I was thinking about stuff like fibonacci or 3n+1
05:45:51 <sjhfeke> maybe i am confusing caching with memoization, sorry
05:45:59 <Fendor_> alright, yeah, that is a good case for memoization
05:46:41 <sm[m]> It can be tricky, it requires understanding Haskell’s evaluation behavior
05:48:16 <sjhfeke> I was thinking how to do this and 3 options came to my mind: (a) passing a dict with memoized values to each function call, but this is cumbersome and AFAIK monads are made to abstract such a pattern away; so (b) make a monad for this, but we'd essentially reimplement the State monad; (c) use the State monad, but I suppose this is a massive overkil
05:48:16 <sm[m]> And also analysing costs, eg the space cost of the memo cache, and the time cost of comparing the key
05:48:17 <sjhfeke> l and very unidiomatic...
05:48:44 <sjhfeke> sorry im kind of new to haskell
05:49:31 <sjhfeke> trying to understand the basics pretty much
05:49:42 <sm[m]> sjhfeke: uglymemo keeps that state hidden behind the scenes
05:49:47 <Fendor_> sjhfeke, wiki for memoization: https://wiki.haskell.org/Memoization
05:50:25 <Fendor_> some examples and explanations how memoization works in haskell
05:50:38 <sjhfeke> ok thanks for links
05:51:32 <Fendor_> actually, if you are new, this may be too advanced, definetley ignore memoizing fix point operator. 
05:53:40 <Fendor_> fix regurarly melts my brain
05:56:25 <sjhfeke> Here's my experience: Had to write an interpreter for a language of my own design in Haskell; did this but I suppose my code was very unidiomatic (almost everything was inside StateT with IO) and I don't feel like I understand the basics. Too fast course, too many concepts introduced in a too short  time ;/
05:56:51 <sjhfeke> I felt like a monkey when I was using monad transformes and I don't even know how to properly implement fibonacci
05:57:12 <merijn> olligobber: What do you mean by unionfind?
05:58:44 <olligobber> merijn, there's a data structure which represents a set of disjoint sets and allows you to query co-membership and merge those sets efficiently
05:58:57 <olligobber> merijn, https://en.wikipedia.org/wiki/Disjoint-set_data_structure
05:59:02 <sjhfeke> but since everyone says how awesome haskell is i guess i should take a closer look on this
06:05:25 <merijn> olligobber: Ah, never heard of that before :)
06:44:19 <srid> has `diagrams` become inactive? its website apparently has been archived? (cf. https://archives.haskell.org/projects.haskell.org/diagrams/ )
06:46:02 <Cale> I hope not, it's an amazing library
06:47:56 <merijn> projects.haskell.org has been archived
06:48:11 <merijn> afaik that process has been ongoing for years
06:52:00 * hackage replace-megaparsec 1.1.0.0 - Stream editing with parsers  https://hackage.haskell.org/package/replace-megaparsec-1.1.0.0 (JamesBrock)
06:56:23 <srid> Cale: i'm playing with it to create some sort of artwork to map out psychological notions :-D ... one day will play with reflex-diagrams too (not sure how mature/complete that is)
08:47:30 * hackage hledger-lib 1.15 - Core data types, parsers and functionality for the hledger accounting tools  https://hackage.haskell.org/package/hledger-lib-1.15 (SimonMichael)
08:48:30 * hackage hledger-web 1.15, hledger-ui 1.15, hledger 1.15 (SimonMichael): https://qbin.io/group-fu-uftw
08:57:30 <pinecamp> if I have a value of type `Functor F => F b`, what's the best way to feed the inner `b` value to a function with type `b -> Either c d` ?
08:58:25 <pinecamp> I think I could fmap the function, but I don't really want to work with a `F (Either c d)` value in this case
08:59:01 <dmwit> What *do* you want to work with?
08:59:12 <maralorn> pinecamp: Well, if you really only know about F that it is a functor you don‘t really have a choice.
08:59:16 <dmwit> (If all you know is `Functor F` and no other constraints, you sort of have no choice.)
08:59:34 <dmwit> (But e.g. perhaps you also have `Traversable F` or similar, in which case possibilities open up.)
08:59:51 <pinecamp> dmwit and maralorn: F in this case is a Network.Wreq.Response, which is also Traversable and Foldable
09:00:20 <dmwit> Okay. Then the question of interest at this point is my first one: what result type would you rather have?
09:02:21 <pinecamp> I'm not sure I understand... I would like to convert the Response ByteString in this case to another basic data type, which so far only has instances of Data, Read, Show, and Binary
09:02:53 <dmwit> You say you don't want `F (Either c d)`. What do you want instead?
09:03:09 <dmwit> e.g. `Either c (F d)` should be doable without too much trouble; is that better? worse? incomparable?
09:03:17 <pinecamp> the function I have that I'd like to feed the Response ByteString into has type ByteString -> Either String MyType. so I'd like to have Either String MyType
09:03:59 <dmwit> Well... you can use `(^. responseBody) :: Response ByteString -> ByteString`.
09:05:20 <pinecamp> dmwit: that's a great point! I don't need the headers or other metadata of the response, I only really need the body
09:06:00 <dmwit> You might want to at least check the response code or whatever wreq calls it. I mean the one that tells whether it's a 200 or a 404 or whatever.
09:07:17 <pinecamp> good idea--I'll be sure to do that before pulling out the body for further processing. thank you for your help! :)
09:20:10 <hexagoxel> "Legacy commands are now only accessible with the `v1-` prefixes, and the `v2-` commands are the new default." -- cabal-install-3.0.0.0 changelog
09:20:22 * Clint sighs.
09:20:57 <hexagoxel> haha, a breaking change, thrown somewhere in the middle of the changelog, with no PSA, no release announcement
09:21:18 <hexagoxel> that breaks probably every second install instructions out there, or is that pessimistic?
09:21:29 * hexagoxel switches to stack
09:21:48 <Clint> to be fair, there was plenty of warning that this would happen eventually
09:21:51 <hexagoxel> on that note, does stack have anything like head.haskell.org repo?
09:22:14 <hexagoxel> so I can prepare stuff for 8.8 before my deps are updated
09:23:03 <hexagoxel> yeah, there was plenty of warning that the cabal maintainers are stubborn and borderline incompetent
09:23:43 <sclv> that’s uncalled for
09:23:52 <maralorn> Are the cabal maintainers in this room and can read that they are called incompetent?
09:24:13 <sclv> Literally any v1 command in the last two cabal releases warned about deprecation
09:24:50 * hexagoxel shrugs
09:24:56 <sclv> this was one of the most signaled changes ti any haskell related tooling in years
09:25:04 <sclv> If you missed it, that’s on you
09:26:17 <sclv> plz don’t be gross and abusive towards open source software maintainers
09:26:59 <hexagoxel> the breaking change was unnecessary. I don't care how much you "signal" it beforehand. And if you don't properly send out very prominent announcement when you do the actual release, I refuse to even view this as "properly signalled".
09:27:13 <sclv> people were begging for this
09:27:28 <hexagoxel> citation needed
09:27:30 <cocreature> it doesn’t matter how much you disagree with the technical decision. insulting maintainers is not acceptible behavior
09:27:53 <sclv> right. That’s the main point :-)
09:28:02 <hexagoxel> and calling me gross and abusive is not gross and abusive?
09:29:08 <sclv> knock it off
09:29:12 <cocreature> I don’t agree with the way sclv phrased things but I very much agree with calling out bad behavior here.
09:31:02 <maerwald> hexagoxel: there were plenty of warnings
09:31:14 <maerwald> basically every time you ran 'cabal install' etc
09:32:01 * hexagoxel does not feel safe continuing this discussion
09:32:42 <maerwald> Maybe they didn't announce it in a big reddit thread, but you know... they are busy as well. It's not like people are lining up for cabal maintenance ;)
09:35:26 <maerwald> I'm also not sure why it would break installation instructions. Might just work
09:37:08 <Clint> v2-* does not "just work" if you're expecting v1-* behavior
09:38:03 <maerwald> if the instructions just say "cabal install" and "run foo", then it might
09:38:45 <Clint> well, okay
10:06:12 <dmj`> hexagoxel: I'd recommend bash aliases when invoking cabal, like alias cb="cabal build", then you can treat them as combinators and only change to add "v1" in a single place.
10:06:42 <dmj`> hexagoxel: runghc is also comes *highly* recommended, a little bit of bash function wrapping goes a long way to making things nice
10:06:49 <Heffalump> out of interest is there any reason to use the v1 commands nowadays, apart from maintaining compatibility with old workflows/scripts?
10:08:22 <maerwald> they are cleaner
10:09:19 <sclv> cleaner?
10:09:28 <maerwald> if you use sandboxes ofc
10:09:29 <Clint> Heffalump: if you want to use a global package db for everything and you never want cabal to download anything off the internet except when you do a cabal (v1-)update
10:09:46 <maerwald> it's hard to break your sandbox, it isn't that hard to break the global cache
10:10:29 <sclv> how does one break the global store? it seems hard to me...
10:10:44 <maerwald> interrupting builds
10:10:46 <sclv> i guess yeah, the nix usecase is the one that's still stuck on v1 for now
10:11:03 <sclv> oh good point -- we have some open tickets for fixing the interrupted build thing further, right?
10:11:05 <maerwald> ghc and cabal are not particularly atomic wrt file operations
10:11:09 <maerwald> basically... not atomic at all
10:11:38 <maerwald> and once your global cache is broken, you usually rm -rf all of it
10:11:45 <maerwald> you can't maintain it
10:12:14 <maerwald> you can maintain your sandbox though
10:12:30 <maerwald> that's the only advantage I can think of.
10:12:38 <dmj`> nix-shell -p 'haskellPackages.ghcWithPackages (p: [ aeson ])' <-- global immutable ghc-pkg list. Can't be broken.
10:12:52 <maerwald> no one asked about nix :P
10:13:01 <dmj`> nix is just a DSL on bash
10:13:11 <maerwald> it's a turing complete configuration language
10:13:21 <dmj`> that's lazily evaluated
10:13:28 <dmj`> and solves all the worlds problems
10:13:30 <maerwald> and turing complete config languages are usually a bad idea
10:13:43 <maerwald> ymmv
10:14:44 <sclv> under the hood the nix derivation uses cabal v1 iirc?
10:14:56 <dmj`> Builds are hella complex these days, R, C++, Haskell, Python, a single YAML won't do it no more. You really do need a turing complete language to wrangle the complexity.
10:15:19 <maerwald> dmj`: not at all
10:15:51 <maerwald> at least not for building haskell packages reproducibly
10:16:25 <sclv> i'm less sold on turing complexity mattering because after all, turing-incomplete still gives you e.g. martin lof type theory
10:16:29 <rsoeldner> Hey, I want to use `pipes` to find "blocks of time". Currently have https://gist.github.com/rsoeldner/5728f24aa35414df2405b843b0033bdc which works except for the last element. I want to check it against the current time and yield a "ongoing frame". Is there a way to check for termination ?
10:16:30 <maerwald> you need it if your domain is unclear and keeps evolving, which is the case for *packaging*, not configuration of a defined domain 
10:16:33 <dmj`> maerwald: yea, but Haskell isn't good for everything yet. Until then you'll need to reach into other package ecosystems and tell the build guys to eat the cost.
10:16:46 <maerwald> yes, packaging != build configuration :)
10:17:00 <sclv> so whatever your complexity problem is, saying "don't worry, its not turing complete" doesn't solve it if you can still write expressions in mltt :-)
10:17:05 <maerwald> nix just gives you all the packagers tools and pretends to be a config language
10:17:25 <maerwald> which I find highly unreasonable
10:17:47 <dmj`> sclv: I think nix uses whatever Cabal that ghc gets distributed with, I don't think the binary cabal is actually used when derivations evaluated.
10:18:02 <dmj`> but I've been known to be wrong about many things
10:18:25 <maerwald> I don't mind *using* nix if someone writes the expressions for me.
10:18:27 <sclv> oh, good point.
10:19:02 <maerwald> that's usually how it ends up... one guy in your company knows nix, the rest are just users ;)
10:19:05 <maerwald> bad bus factor
10:19:10 <sclv> i guess the issue is once you're working in an env, you mainly have the global package store, and you need to have a specially tweaked cabal config to use v2 commands with it reliably
10:19:20 <sclv> (i.e. to only use the local stuff)
10:19:34 <sclv> i keep figuring out and then forgetting the details about getting the v2- interactions right with nix
10:20:06 <sclv> need to get gabriel on board with writing the new "how to nix and haskell with v2 definitive guide" otherwise we'll never all be on the same page
10:20:52 <dmj`> maerwald: people can learn nix, plus once its building it will always work as long as your hash is pinned. It's learn nix, or hire many dev ops people.
10:21:10 <rsoeldner> sclv, whats wrong with nix and v2 ?
10:21:19 <maerwald> dmj`: so now you have all your devs learn nix instead of working on features?
10:21:25 <sclv> its both at once -- nix _and_ devops people who know nix :-)
10:21:29 <sclv> still a good plan tho
10:21:35 <maerwald> it isn't something you learn in a week
10:21:40 <sclv> rsoeldner: see above, iirc
10:21:42 <maerwald> it is packaging
10:22:06 <monochrom> I still want v1 because I still want global.
10:22:09 <sclv> v2 fetches stuff into the store. but you want to actually manage stuff via only having it in the global env
10:22:18 <dmj`> maerwald: as you said, one person blazes a trail, the rest can copy and paste where need be, adjusting hashes, adding new derivations. You can even build tools to do this for you (ala cabal2nix). This is how a lot of dev works too. Sr. devs architect the system, junior devs learn via mimicry 
10:22:18 <sclv> or the "nix-provided global env" rather
10:22:30 <maerwald> dmj`: yes, so you still have only one guy understanding it
10:22:33 <maerwald> which is dangerous
10:22:56 <sclv> and there's ways to tune the config for v2 so it doesn't auto-fetch but its still a bit complicated
10:23:01 <maerwald> imagine the guy quits :)
10:23:01 <sclv> and i think there's some tickets to simplify things
10:23:07 <sclv> then you hire another guy
10:23:15 <sclv> people said the same thing about haskell some years ago
10:23:24 <maerwald> sclv: well, now your devops is basically broken for at least 3 months
10:23:28 <maerwald> that's pretty bad
10:24:38 <dmj`> maerwald: documentation is extremely important. All the nix I've written has come with a README.md explaining wtf happened, even linking to the official docs. Building up your own package namespace is very reasonable and understandable. Along with using nixops. Not everybody is a clever (#nixos reference), but people can understand what a derivation is, and how to override packages, hook into phases.
10:24:47 <maerwald> dmj`: nix is barely documented!
10:25:05 <dmj`> maerwald: disagree, nixpkgs, nixos, nix all have manuals
10:25:11 <maerwald> You end up reading code
10:25:19 <maerwald> Because what people do with the language is not documented
10:25:22 <maerwald> The language itself is
10:25:22 <dmj`> it would be no different in haskell world
10:25:35 <maerwald> Yes, which is why you should never choose turing complete configuration languages :)
10:26:09 <dmj`> I don't get why haskell people don't just bite the bullet, they love functional lazy languages, and are already reading source on hackage all day. Seems like the same principles apply. Nix also solves haskell's biggest pain point, builds. 
10:26:23 <maerwald> dmj`: because it is complexity
10:26:31 <monochrom> Does nix have lens? >:)
10:26:37 <dmj`> maerwald: it's also abstraction
10:26:44 <dmj`> abstraction eats complexity
10:26:51 <dmj`> complexity is growing, abstraction needs to grow
10:26:58 <maerwald> uh-oh
10:27:09 <maerwald> dmj`: complexity is the biggest enemy of all computer science
10:27:33 <dmj`> correct, the definition of software engineering is "managing complexity"
10:27:34 <maerwald> should be careful where you introduce it ;)
10:27:45 <dmj`> I wouldn't introduce it if the job didn't call for it
10:27:50 <maerwald> don't hit a nail with a rocket
10:27:59 <maerwald> it might blow up
10:28:18 <dmj`> you're the last person I should have to explain the benefits of purity and immutability too. The same principles apply to build complexity. 
10:28:50 <maerwald> dmj`: well, I've done distro packaging for years and I know how complex it is, which is why I do not like nix. Because it exposes me to that complexity for something that should be simple.
10:28:51 <hexagoxel> Does nix have traceShow(Id) ?
10:28:55 <monochrom> Complexity is also in the eyes of the beholder.
10:29:01 <dmj`> fiddling with makefiles feels like managing mutable state to me.
10:29:17 <maerwald> dmj`: which means they did not manage to create proper abstraction. You just get EXPRESSIVITY
10:29:22 <maerwald> Which isn't the same
10:30:43 <hexagoxel> dmj`: and thanks for the earlier suggestion on bash aliases. At this time, it seems that would be another brittle layer to an unstable UI, so I am not very motivated. Or rather: I have been doing something along those lines already, and how it breaks right now is exactly what frustrates me.
10:33:26 <monochrom> I said that because I saw scenerios that went like --- let me tell it as a parable --- if I hit a nail with my iPhone, someone would say "yes that's unnecessary complexity because the iPhone is Turing-complete and you don't need Turing-complete to hit a nail, go get a hammer properly", and someone would counter that with "but I already have the iPhone in my hand, I don't already have a hammer anywhere near, going out to buy/borrow a hammer is more 
10:33:26 <monochrom> complex and takes more time".
10:33:28 <dmj`> maerwald: builds *should* be simple, I agree. The turing complete nature of nix isn't a problem imo, people pick up new dynamic langs all the time, feels like python anyways (strong + dynamically typed). Agree that it can do more than might be necessary (again not a con). The discoverability of nix + nix API is not good, nix repl helps, but its no ghci / hackage.
10:34:13 <maerwald> dmj`: oh no, it isn't just about the language. Now that it's turing complete, the ecosystem randomly grows without direction (also because low QA). Which means you also have to keep up with all the weird stuff people do
10:34:28 <maerwald> and suddenly it's a full-time job ;)
10:34:41 <maerwald> while I just wanted to...err... build my project
10:36:10 <monochrom> Hire more people. Builds project for you and solves unemployment. >:)
10:36:52 <maerwald> monochrom: I have a better idea: writing haskell ;)
10:36:54 <dmj`> maerwald: yea there is a lot of weird stuff, but you don't have to use it all. It's a full time job regardless. Nobody *just* wants to build their project, they want to put it on an EC2 instance. Letting all the developers deploy is a powerful, taking the "deploys are my job not yours" out of the equation feels good for the dev team.
10:37:58 <monochrom> "devop" should be two persons to begin with.
10:38:01 <maerwald> dmj`: EC2 isn't hard, neither is terraform, ansible or even docker :)
10:38:05 <monochrom> It was two persons.
10:39:03 <dmj`> This is the title of my new book "Rise of the devopsloper", the hybrid dev and ops person.
10:39:52 <dmj`> Devs are expected to write documentation, but documentation is way harder than writing code imo.
10:40:14 <maerwald> monochrom: maybe, but it's an odd situation when a developer cannot change anything that involves CI or CD... and has to send someone an email to help him. Broken workflow.
10:42:02 <iqubic> I use nix. Nix is good.
10:42:27 <monochrom> It's ironic and oddly satisfying. Corporate greed tried to pay one salary for two jobs by creating "devop" and making the programmer do one more job.  Ah but now that the programmer is involved, they of course have to introduce a home-made Turing-complete build/config language!  Turing-complete is all the programmer knew.  Now it is so out-of-hand it needs two salaries again.
10:43:53 <maerwald> Not the corporations fault. We made the money system and the surrounding global economy :)
10:44:07 <maerwald> I think we're OT though
10:44:54 <maerwald> (but yes... I think what is ultimately wrong with software is a reflection of our market dynamics)
10:45:27 <Clint> did something change with QQ behavior around GHC 8.6?
10:46:22 <dmj`> at least nix isn't javascript
10:46:48 <maerwald> dmj`: it's quite bearable with types
10:46:57 <dmj`> javascript or nix :)
10:46:58 <maerwald> (aka typescript)
10:47:15 <maerwald> structural typing is nice
10:47:58 <dmj`> I feel like a turing complete build language should be dynamic because the nature of the job is a dirty one, so it seems to fit the bill.
10:49:05 <iqubic> nix is good. Nix is great. I have had no issue with nix ever.
10:49:07 <__monty__> Clint: Hmm, there's definitely been talk about TH in #ghc, nothing in the changelog?
10:50:30 <iqubic> I noticed a few things have changed.
10:50:32 <iqubic> I think.
10:50:34 <maerwald> dmj`: why not make it not turing complete? Define a well-designed and small API surface, then design a plugin-system that allows people to add things that the current system cannot express. There's no reason to go full turing-complete
10:50:36 <dmj`> I've def. had issues with nix, haskell suffers the same actually. For example "with pkgs; " introduces all fields from that set into scope, if you have a variable named the same as a package, it can get used instead and produce very unreadable error messages. With record wild cards usage you sometimes run into this
10:50:46 <maerwald> and btw, that's basically what terraform did (and they did it well)
10:51:00 <iqubic> I think there's a note about TH in the latest changelog.
10:51:31 <Clint> __monty__: i don't really know what i'm looking for, but a use of quoteFile is giving a parse error now
10:52:57 <dmj`> maerwald: because then you couldn't express the y combinator when writing build scripts :P </joke> 
10:53:15 <maerwald> people get too easily excited by power
10:53:45 <iqubic> You can express the Y combinator in Nix. Quite easily actually.
10:54:20 <maerwald> I want less power. I don't even want to use high-level languages. It's too complicated. Please write a DSL for me or something where I can plug pictures and logic together.
10:54:30 <hexagoxel> Is there any automation available to make building a project with stack and the upcoming ghc version easier? (in this case upcoming = ghc-8.8)
10:55:31 <hexagoxel> Is there a snapshot that contains packages that are already-compatible?
10:55:33 <iqubic> is GHC-8.8 going change stuff and break stack?
10:55:44 <dmj`> maerwald: tbh, the turing complete nature isn't what sold me, it was the first class integration with ghc / haskell packages, purity model, the the crowd source build recipes, and a provisioning + deployment tool. From farm to table to cloud.
10:55:52 <dmj`> then the*
10:56:02 <maerwald> dmj`: yeah, scope is too wide
10:56:06 <hexagoxel> iqubic: nah, just the usual breakage due to MonadFail in this case
10:56:26 <iqubic> What changed with MonadFail?
10:56:40 <iqubic> I know that fail was removed from Monad.
10:56:41 <hexagoxel> i.e. a lot of packages in the current snapshot don't compile on ghc-8.8
10:57:18 <dmj`> maerwald: probably, but it does accomplish its intended purpose and actually exists.
10:58:09 <hexagoxel> I merely want to test with ghc-8.8 before the nightlies (or even the lts) roll over
10:59:09 <maerwald> dmj`: it was a smart piece of engineering (the PM and the language, not the ecosystem)
11:00:21 <phadej> hexagoxel: you found a weak spot of stack approach
11:00:24 <Clint> hexagoxel: people will be updating upper bounds for ghc-bundled libraries for months and months
11:00:53 <Clint> phadej: any reason to not put topograph into stackage?
11:01:08 <phadej> Clint: if someone want it there, feel free to add
11:01:24 <Clint> hmm, okay
11:03:54 <phadej> Clint: I don't think it will take that long, e.g. my gut feeling is that servant + GHC-8.8 is only blocked on aeson
11:04:11 <phadej> so (i hope) it will take maybe few weeks
11:04:40 * Clint nods.
11:06:04 <dmj`> maerwald: the ecosystem is coming up, rust support is pretty good now.
11:07:19 <phadej> iqubic: "fail removed from Monad" is 'What changed with MonadFail", no more fail in Monad :)
11:07:23 <phadej> (only in MonadFail)
11:07:38 <maerwald> dmj`: I use cargo.
11:09:45 <dmj`> maerwald: I use rustPlatform.buildRustPackage
11:10:19 <dmj`> maerwald: https://github.com/dmjio/hello-rust-haskell-nix
11:12:08 <hyperisco> rcpietro, yes
11:17:31 <p53> why command line arguments are monads in haskell (IO)? since the arguments are already fixed in the program call and do not change, it would not be functionally "pure" to use them as a constant (eg as a parameter of a main function, or as in OCaml)?
11:19:47 <geekosaur> they're still from outside the program itself
11:19:56 <hyperisco> p53, the way you are using certain terms doesn't make sense to me. Do you have an example?
11:20:20 <phadej> p53: in fact, you an change what getArgs return: https://hackage.haskell.org/package/base-4.12.0.0/docs/System-Environment.html#v:withArgs
11:20:36 <phadej> s/an/can/
11:22:21 <lavalike> oh cool didn't know that one, did they add it recently? someone had been asking about main :: IO a vs main(int argc, char **argv) some time ago in here, that'd been a nice pointer
11:22:48 <hyperisco> or two
11:23:01 <cocreature> withArgs has been there for ages afaik
11:23:10 <lavalike> fascinating
11:24:42 <p53> eg: " ./program ARG ARG ... "; The values are already known before the program starts, and are actually just constants. So why can not these just be called as constants in Haskell? eg: "a = argv"  instead of going over monads 
11:25:14 <geekosaur> did I not answer that?
11:25:40 <geekosaur> if it's a constant, it's *inside the program* in some sense. program parameters are not.
11:26:06 <Rembane> p53: Don't you need to ask the OS for them? 
11:26:26 <cocreature> if withArgs was not a thing, I don’t see why you couldn’t implement it as a constant.
11:27:05 <geekosaur> Rembane, actually no. they're on the initial stack when the process is created (unix) or the system program block or whatever it's called these days (windows)
11:27:13 <nshepperd2> It's different each time you run the program, which means it's not a constant
11:27:15 <lavalike> it does a peek so it doesn't want to hide the IO from you
11:27:37 <geekosaur> but they come from the environment outside the program source, so they are not constants
11:27:40 <phadej> nshepperd2: good one
11:28:57 <hexagoxel> phadej: I don't understand your comment. Are you saying I won't be able to use ghc-8.8 with stack?
11:29:02 <cocreature> I think there are two questions here: 1. could you conceivably implement it on a technical level as a constant (ignoring withArgs) without running into issues? afaict the answer to that is yes. 2. is it a good idea to implement it that way. imho no.
11:29:06 <geekosaur> granted you can do things ike imports, but those are still fixed when the program is compiled. which may not be a con cept you're familiar with if you normally work with javascript, but most other languages have distinctions (granting with python you need to evoke a special mode to get .pyc / .pyo files)
11:29:31 <phadej> hexagoxel: stack is very bad tool for "tracking the bleeding edge"
11:30:30 <hexagoxel> that is non-constructive
11:30:45 <geekosaur> what's that supposed to mean?
11:31:25 <p53> mh, ok; that's true; that is not "pure" (in the sense of referential transparency). I was mentally too limited to the fact of the constancy of a value. Ok, question is unnecessary. XD
11:31:25 <p53> Thank you.
11:31:29 <phadej> hexagoxel: the (big) snapshot approach is simply difficult to get moving fast
11:31:54 <hexagoxel> geekosaur: who are you asking?
11:32:17 <phadej> hexagoxel: with say ~300 package "stackage lite", stack could have one during September, for sure
11:34:32 <hexagoxel> I was merely asking if there is a snapshot of all packages that work with ghc-8.8 already. I don't see what would be particularly difficult about that.
11:34:45 <hexagoxel> Of course that snapshot might be rather small..
11:36:20 <phadej> there's `resolver: ghc-8.8.1` :)
11:37:14 <hexagoxel> which contains boot packages only, right?
11:37:30 <phadej> yes
11:38:18 <geekosaur> I was wondering if head.hackage had been mentioned but it sounds like it's CI is broken currently :/
11:38:31 <geekosaur> and as the namehints, it's more about HEAD than releases.
11:38:43 <geekosaur> * its CI
11:41:21 <hexagoxel> I know and use head.hackage already, but thanks for the pointer
11:44:27 <hexagoxel> (I don't see how head.hackage is inherently more compatible with the "cabal approach" than the "stack approach". In both cases you need to maintain a patch-set. And really, because the patches need to be based on specific versions to avoid conflicts, this really seems closer to a stackage approach.)
11:45:47 * hexagoxel successfully built the package with stack and ghc-8.8. Thanks to a ton of extra-deps.
11:46:21 <phadej> hexagoxel: head.hackage has only patches for things which needs patches
11:46:28 <phadej> it's not closed "package-set"
11:47:18 <hexagoxel> so what? I want to test if my package builds with ghc-8.8. I don't care if the deps come from a closed package set or not, as long as they build with ghc-8.8.
11:47:37 <phadej> hexagoxel: stack requires closed package-set
11:49:34 <hexagoxel> phadej: so what?
11:50:43 <phadej> hexagoxel: you need to to do "a ton of extra-deps"
11:56:50 <hexagoxel> hence my initial question: As this seems to be easily automated, does this automation exist?
11:57:00 <phadej> hexagoxel: cabal solver ;)
11:57:28 <phadej> i'm really try to hint, that the automation is built into other tool.
11:57:36 <phadej> stack might be good for something, but not for that use-case
11:58:19 <phadej> (and in fact, stack solver used cabal, when such command existed)
11:59:22 <hexagoxel> I am sorry for wasting your time, but I really do know all that, and I am really interested in the question that I asked.
11:59:55 <phadej> hexagoxel: well, then the naswer is "no, there aren't such tool (as stack developers aren't interested enough in that use case)"
12:00:41 <phadej> (which got me thinking, maybe you may be able to run `stackage-curator` yourself)
12:09:42 <hyperisco> hexagoxel, not sure how or if this factors into your considerations, but packages may be mutually incompatible even if they both compile successfully independently.
12:12:10 <hexagoxel> so head.hackage really _must_ be a closed package set :)
12:15:41 <hexagoxel> (because otherwise it would not serve its purpose, or be overly complex to maintain)
12:16:11 <hexagoxel> (if there were any such incompatibilities, that is)
12:17:00 * hackage hasbolt 0.1.3.5 - Haskell driver for Neo4j 3+ (BOLT protocol)  https://hackage.haskell.org/package/hasbolt-0.1.3.5 (zmactep)
12:18:24 <aisn> I pass a callback function to a midi listener (function from a library) and i want to keep the state that i get from that callback function (update a midi note list on every key press). Is it possible to do that with the State monad?
12:26:42 <hexagoxel> phadej: thanks for pointing out stackage-curator. I am not sure yet if it would be useful, but it is an interesting idea.
12:42:28 <buhman> I am a beginner; I was playing with this simple string parsing function, and it seems to have the exact behavior I want. Any suggestions on how I could do this more cleverly? https://gist.github.com/buhman/6644ac4b4134c5be6c8996764d1a6d4b
12:44:47 <merijn> the more clever way would be using one of the parser combinator libraries to write a parser instead of manually pattern matching on String :)
12:44:53 <purelazy> buhman: Why cleverly?
12:45:28 <purelazy> It should be easy to understand
12:46:17 <hyperisco> So as to not lose "clever" as a pejorative, I prefer to align it with "simplify".
12:46:32 <purelazy> Hard to know what is supposed to do without comments
12:46:51 <buhman> are the comments at the end insufficient ?
12:47:19 <purelazy> I don't read backwards
12:48:05 <suppi> if you want to know about more ways to parse a string, have a look at: https://two-wrongs.com/parser-combinators-parsing-for-haskell-beginners
12:49:02 <buhman> purelazy: I have now moved the comments to the top
12:49:11 <purelazy> I don't do parsing for a living - so I am at a disadvantage
12:49:25 <purelazy> I just know what it is
12:49:27 <suppi> also I'd suggest using Either instead of Maybe so you can also say what went wrong
12:50:00 <buhman> good idea
12:50:20 <purelazy> That is good advice
12:50:38 <purelazy> We all want to know what goes wrong
12:54:06 <parsnip> what is the graphic of languages starting and dying?
12:54:11 <buhman> I didn't know about ReadP either! definitely going to try rewriting this to see what it looks like
12:57:43 <purelazy> Does one get ghci with the Minimal installer
12:58:32 <purelazy> "Minimal installers: Just GHC (the compiler), and build tools (primarily Cabal and Stack) are installed globally on your system, using your system’s package manager."
12:58:45 <merijn> purelazy: ghci is part of ghc, so yes
12:59:49 <purelazy> merijn: As a noob, on Linux, is it OK to start with Minimal Install
13:00:45 <purelazy> (a Haskell noob)
13:01:21 <hyperisco> parsnip, what?
13:01:51 <purelazy> As a noob, on Linux, is it OK to start with Minimal Install
13:02:09 <purelazy> (to parsnip)
13:03:16 <purelazy> sorry, I think I made a mistake
13:03:21 <int-e> I suspect having neither cabal(-install) or stack will be inconvenient very soon.
13:05:21 <parsnip> hyperisco: maybe it was in a talk, where Simon showed the usual life expectancy of new languages
13:05:27 <parsnip> research languages, maybe
13:05:32 <purelazy> As a Haskell newbie, what is the best Linux install option to choose? It says "There are three widely used ways to install the Haskell toolchain on supported platforms"
13:05:45 <int-e> It's precisely this (the plain ghc package isn't convenient) why we have the Haskell Platform; it is meant as a starting point for everybody.
13:06:11 <purelazy> Minimal, Stack and Platform
13:07:16 <purelazy> Am I missing some helpful hint somewhere?
13:08:26 <buhman> pur
13:09:14 <purelazy> Can someone please advise
13:09:18 <int-e> I'd say go with the Haskell Platform.
13:09:38 <purelazy> int-e : OK Thank you
13:10:18 <buhman> purelazy: I did https://www.haskell.org/ghcup/ , and enjoy it. I love how cabal and haskell-mode work so well together
13:10:51 <purelazy> I will try "sudo apt-get install haskell-platform"
13:11:01 <purelazy> And see how it goes
13:11:03 <int-e> meh, another curl | sh
13:11:42 <buhman> well, preferred over archlinux's broken packaging, certainly
13:12:51 <sclv> int-e: i was initially resistant to the curl | sh thing, but i came around when it was pointed out that there's no "su" involved
13:13:03 <hyperisco> parsnip, I did not see it. However, I can imagine what it looked like.
13:13:08 <sclv> and also that its just a thin wrapper around just installing the ghcup script on your system directly
13:14:10 <purelazy>  haskell-platform is installed - and ghci works
13:14:35 <purelazy> thanks int-e
13:16:11 <int-e> sclv: I know this is irrational really, but it feels wrong. (It's irrational because I don't balk at "cabal install foo" the same way, even though that also downloads stuff from the internet and then potentially executes arbitrary code.)
13:16:48 <sclv> yeah, i went through the same process of denial, bargaining acceptance etc :-)
13:16:52 <int-e> (a configure script, a custom setup, or template haskell)
13:17:38 <purelazy> What are you talking about?
13:18:28 <int-e> Hmm. Security, trust, and habits? I don't know.
13:19:34 <purelazy> I don't know about Security, trust, and habits
13:19:53 <purelazy> Do you need to know about these things
13:20:23 <int-e> Not if you want to sleep at night.
13:20:24 <purelazy> (when writing Haskell specifically?)
13:22:01 <purelazy> int-e: I like to sleep.
13:23:12 <purelazy> I don't understand
13:26:06 <int-e> It's a general statement on trusting software. Read Thompson's Turing Award Lecture (Reflections on Trusting Trust) for a reason why this is fundamentally hard. But the Haskell ecosystem has two package repositories where we download software and isntall it, usually without looking too closely at the sources first. There is some security built into that but it's still an immense amount of trust...
13:26:12 <int-e> ...that we put in package maintainers to be well behaved. And that's just Haskell... it gets worse if you look at a computer and its software as a whole.
13:27:26 <purelazy> int-e: I see your point
13:29:30 <purelazy> int-e: Do you have a link for Thompson's Turing Award Lecture (Reflections on Trusting Trust)
13:29:55 <int-e> https://www.ece.cmu.edu/~ganger/712.fall02/papers/p761-thompson.pdf
13:30:10 <int-e> (first duckduckgo result for Reflections in Trusting Trust)
13:30:15 <int-e> s/in/on/
13:34:26 <purelazy> int-e: I will read it
13:34:51 <purelazy> int-e: What is it saying?
13:35:23 <purelazy> in general
13:36:37 <purelazy> To what extent should one trust a statement that a program is free of Trojanhorses? Perhaps it is more important to trust the people who wrote thesoftware?
13:36:43 <int-e> hmm, in a slogan, you can't trust compilers even if their source code is completely sound
13:37:59 <purelazy> I read somewhere that security is a myth
13:38:30 <purelazy> Something of that ilk
13:38:53 <int-e> Sadly we have now reached the level where we can't even trust software based on its machine code... at which point things become unreal, the stuff of nightmares. Probably also off topic here :)
13:39:04 <hyperisco> You can't define security without also defining the system and the threat.
13:39:39 <purelazy> If you can't trust compilers, why trust CPUs
13:40:16 <purelazy> Why trust people who design logic circuits
13:40:27 <hyperisco> "X is secure" is a meaningless statement. "X is secured against Y" has meaning.
13:40:31 <monochrom> In fact Intel CPUs are less trustworthy than most compilers.
13:40:56 <int-e> In former times? Because it would be prohibitively expensive to put in interesting backdoors. Nowadays? You can't.
13:41:13 <purelazy> Why trust people who make FPGAs
13:41:30 <purelazy> They are everywhere
13:42:04 <int-e> Anyway. All this is why I brought up sleeping at night as an issue :)
13:42:04 <purelazy> And ASICs
13:42:08 <monochrom> But overall yeah there is no "absolute perfect trust". There is only either relativized or Bayesian-probabilistic.
13:42:47 <purelazy> Why trust Physics
13:43:00 <int-e> https://www.xkcd.com/1132/ :)
13:43:21 <purelazy> TLDR
13:43:50 <monochrom> Forget computers. Why trust your food sources? Be like Goedel.
13:44:18 <purelazy> Security is a myth, and we hope
13:45:08 <purelazy> Who knows Goedel
13:45:13 <monochrom> I do.
13:45:23 <monochrom> Ah but do you believe me? Bwhahshaha
13:45:24 <purelazy> Cool
13:45:58 <purelazy> Do you really know a Goedel
13:46:19 <monochrom> On this the "#haskell" "IRC" "channel" you don't even know who I am or whether it is the #haskell IRC channel.
13:46:51 <purelazy> so true
13:46:56 <monochrom> Why isn't it true that a deeply embedded secret system in your CPU is making this all up?
13:47:33 <purelazy> or shallowly embedded
13:47:35 <monochrom> Watch the movie Shutter Island some time.
13:48:02 <monochrom> You don't even need a computer to run into things you shouldn't believe. (You just need your brain.)
13:48:31 <monochrom> Why even trust your brain?  Cognito ergo absurdum.
13:48:52 <purelazy> I think therefore I add
13:48:59 <mycroftiv> i might not realize that i was created by a future evil AI and sent back in time and maybe i need to secure the world from my own code
13:49:20 <monochrom> @quote monochrom product
13:49:21 <lambdabot> monochrom says: In an imperative curriculum you're like chapter 2 for-loops and chapter 10 binary search trees.  In a functional curriculum you're like chapter 2 binary search trees and chapter 10
13:49:21 <lambdabot> XML processing using arrows.  The difference in productivity is incredible
13:49:35 <monochrom> Err let me find it.
13:50:00 <monochrom> Ah not in lambdabot.  Co-product ergo sum.
13:50:29 <purelazy> Imagine life with perfect security
13:50:30 <ziman> that's a good one :)
13:50:38 <monochrom> Actually the full thing is: co Carte says: coproduct ergo sum.
13:50:48 <purelazy> Nothing goes wrong
13:51:13 <monochrom> maybe s/co Cartes/Cocartes/
13:51:30 <purelazy> Imagine life with perfect security and Nothing goes wrong
13:51:58 <hyperisco> It is probably incoherent.
13:51:58 <purelazy> Is there a film about that?
13:52:23 <monochrom> Also, have you considered ghcup? I mean besides platform and stack.
13:53:20 <int-e> monochrom: tbh I don't remember hearing of ghcup before today.
13:53:29 <int-e> monochrom: but it was mentioned above :)
13:53:35 <monochrom> Ah OK!
13:53:51 <purelazy> What the ghcup!!
13:54:43 <int-e> In practice I have my own homebrew solution for working with several ghc installations, which I can't recommend to anybody else :)
13:54:54 <lavalike> another notion of trust is: it doesn't matter, clip the downside, manage the payoff not the probability of the event
13:55:42 <purelazy> int-e: What are you worried about?
13:56:02 <purelazy> int-e: The end of the World as we know it?
13:56:04 <sclv> the problem is that you're running a bunch of other people's code on your computer
13:56:20 <monochrom> int-e: Isn't it as simply as "./configure --prefix=<a prefix reserved for this verion>"?
13:56:23 <mycroftiv> is there a term we use for the gap between what we have expressed in the type system and the code requirements/spec that cant be (or just isnt) expressed at type-level?
13:56:32 <sclv> and you have to trust that their code isn't malicious, or that you've cordoned off the environment in which it runs enough so that malicious code can't be too harmful
13:56:37 <int-e> monochrom: that and http://paste.debian.net/1098317/
13:56:57 <int-e> purelazy: that people will call me crazy for manually installing all that software :P
13:56:57 <sclv> or you have to read all their code to verify it
13:57:19 <monochrom> Oh that's really pretty long yeah.  I have a much shorter PATH-editing function.
13:57:48 <purelazy> read the code, read the chips
13:57:53 <int-e> monochrom: well I went over board with it by tacking on all relevant PATH-ish things I could think of
13:58:06 <monochrom> http://www.vex.net/~trebla/tmp/playpath.txt
13:58:34 <int-e> (ironically setting ACLOCAL_AMFLAGS used to break ghc builds, or more precisely, the build of the bundled libffi)
13:58:54 <purelazy> code can turn chips into evil chips
13:59:13 <monochrom> Oh yours also do other languages, nevermind.
13:59:30 <monochrom> purelazy: Are you done?
13:59:44 <purelazy> Nope
13:59:53 <int-e> monochrom: yeah I'd actually use add_prefix for things like custom-built C libraries as well
13:59:55 <monochrom> Why are you so worked up on this?
14:00:50 <purelazy> monochrom: Its just another level
14:01:07 <purelazy> I;m not worked up about anything
14:01:39 <purelazy> Seems this is a talk about security
14:02:08 <purelazy> And paranoia can be directed at any level
14:02:30 <monochrom> I want to believe you when you say you aren't worked up about this, but you need to stop to prove it.
14:02:56 <purelazy> To stop what specifically?
14:03:15 <monochrom> Stop pressing <enter>? That would be a good start.
14:04:14 <purelazy> How can I type without pressing enter
14:04:29 <monochrom> OK I tried. <shrug>
14:04:42 --- mode: ChanServ set +o monochrom
14:05:00 * hyperisco genuflects
14:05:14 <nshepperd> first type in your message, then press backspace until it is gone, then get up from your seat and get a delicious mug of hot chocolate
14:05:30 <monochrom> Too late
14:07:57 <int-e> sorry for starting down that road
14:14:59 <nil> wait, what was that? "purelazy has left #haskell (requested by monochrom (purelazy))"
14:16:50 <hyperisco> Mercy.
14:18:20 <fendor_> does that mean purelazy was kicked? I am a bit confused
14:19:09 <nil> it's /remove apparently
14:19:47 <int-e> non-violent kicking... where is this world going
14:24:41 <boxscape> Just to make sure I'm understanding this error correctly - even with {-# OVERLAP #-} pragmas, I can't have instances `Class f a` and `Class f (a -> b)` because they count as identical instance heads?
14:25:00 <boxscape> or actually does this have something to do with the class having multiple paramaters?
14:25:08 <boxscape> because it does seem to work if `f` isn't part of the class
14:26:55 <boxscape> or hold on
14:27:13 <boxscape> it works if I remove the associated type, so I'll have to experiment with this some more before I can figure out what the issue is
14:30:21 <boxscape> https://gist.github.com/JakobBruenker/8f74d1dd146b1eec0f307de905a41861
14:30:26 <boxscape> can you do this sort of thing only with closed type families?
14:31:18 <shapr> boxscape: do you have the same nick on twitter?
14:31:25 <boxscape> no
14:31:44 <dminuoso> boxscape: To your first question: `instance C T f a` means "for every type `f` and every type `a`, there exists an `instance C T f a`
14:31:56 <dminuoso> boxscape: Notice the weight of the word "every"
14:32:08 <boxscape> okay
14:32:57 <dminuoso> boxscape: You can think of typeclass instances as pattern matching, really.
14:33:16 <boxscape> that makes sense
14:33:18 <dminuoso> boxscape: You can either bind type fragments to type variables (giving you irrefutable pattern matches), or you can pattern match on type constructors.
14:33:36 <dminuoso> Note that in case of functions, (->) is a 2-arity type constructor, which is why you can pattern match on it.
14:33:42 <boxscape> yeah, okay
14:36:02 <dminuoso> boxscape: So in principle there is no well defined ordering in which one should take preference over the other. Using OVERLAPPING and OVERLAPPABLE you can however define a relative ordering between some instances.
14:37:21 <boxscape> is using Overlapping instances bad practice by the way? Or is that totally fine?
14:38:36 <dminuoso> boxscape: It depends on who you ask.
14:38:43 <boxscape> I see
14:39:03 <dminuoso> boxscape: There's a large fraction in the Haskell community that is deadly scared by them because they can lead to incoherent programs, and they are somewhat difficult to steer.
14:39:15 <boxscape> okay
14:39:18 <dminuoso> But of course there's more pragmatic oriented folks..
14:39:35 <hyperisco> A few overlapping orphans never hurt anybody.
14:40:04 <int-e> hyperisco: ...
14:40:34 <dminuoso> boxscape: Ultimately it sort of depends on why you want to use them. If for example you just want to have instances for `[a]` and then special case `String`, its probably a better idea to use a newtype.
14:41:00 <dminuoso> boxscape: But considering what you are doing, feel free to abuse whatever dirty extension you find. ;)
14:41:05 <boxscape> okay :)
14:41:57 <hyperisco> I am trying to discern what is being attempted. I know a few arcane spells.
14:42:46 <hyperisco> If you just want to special-case functions then that is easy.
14:43:04 <boxscape> hyperisco: dminuoso challanged me a few days ago to write a generalized liftA function and I've invested a few hours and so far haven't come far, but I have discovered a bug in ghc in the process
14:43:19 <hyperisco> :t liftA
14:43:21 <lambdabot> Applicative f => (a -> b) -> f a -> f b
14:43:24 <hyperisco> generalised how?
14:43:31 <boxscape> f should have any arity
14:43:35 <dminuoso> hyperisco: Remember it's a challenge, dont spoil the fun. :p
14:43:38 <boxscape> h
14:43:40 <boxscape> not f
14:43:42 <boxscape> but (a -> b)
14:43:48 <boxscape> should also be allowed to be (a -> b -> c) and so on
14:43:51 <hyperisco> Okay, then I definitely won't spoil the fun, because I've implemented this exact thing XD
14:44:11 <hyperisco> You were asking about closed type families. Yes, that is how I'd do it.
14:44:40 <boxscape> I first tried to use closed type families, then switched to classes because of a problem, but I guess the next step is to combine both
14:44:44 <dminuoso> There is, some other techniques you could do too. :)
14:44:56 <hyperisco> I like your plan boxscape.
14:55:35 <topos> hexagoxel LOL 
14:56:47 <hexagoxel> topos: you are welcome
15:17:17 <boxscape> Well I thought I had an implementation that *would* work if I could just convince the type checker, but using unsafeCoerce causes an internal error, so maybe not :(
15:20:45 <orzo> boxscape: I wouldn't be too sure that you can conclude your implementation is wrong from that
15:20:56 <M2en[m]> When is it necessary to define a Semigroup instance before you can define a Monoid instance?
15:21:23 <boxscape> orzo okay, I'll keep that in mind
15:22:01 <merijn> M2en[m]: whenever you use ghc 8.6 or later (or maybe it was 8.4 or later...)
15:23:10 <M2en[m]> merijn: Do you know what change was introduced in that GHC version that made it a requirement? I have a feeling that Semigroup was made a superclass of Monoid.
15:23:43 <merijn> M2en[m]: it was
15:23:43 <Cale> Note that you can always define  instance Semigroup S where (<>) = mappend
15:23:54 <Cale> if you have a Monoid instance already
15:26:52 <M2en[m]> I realized today that Haskell is an older language than Python and Java.
15:27:14 <M2en[m]> It seems newer somehow.
15:28:26 <Cale> That's because it uses ideas that happened after the 1980s
15:29:33 <monochrom> and Python and Java, the 1960s.
15:29:47 <M2en[m]> Hilarious :)
15:29:55 <monochrom> Yes even OOP started with 1960s Simula. It's that old.
15:30:41 <M2en[m]> Does it feel to you that all that has changed is better compilers and interpreters?
15:32:30 <monochrom> No. Also worse and worse semantics.
15:40:30 * hackage pg-transact 0.2.0.0 - Another postgresql-simple transaction monad  https://hackage.haskell.org/package/pg-transact-0.2.0.0 (JonathanFischoff)
15:41:25 <M2en[m]> I think what's wrong with this is that I am creating an open set somehow. https://imgur.com/a/RlsRcPb
15:42:30 <jumper149> How do can I find a substring in a bytestring and split it there? In Data.ByteString I'm only finding functions that access single Word8.
15:42:49 <M2en[m]> `Only $ (<>) a b` doesn't really make sense.
15:42:58 <boxscape> I don't suppose there's some way I can just tell ghc to ignore conflicting type family instance declarations, akin to unsafeCoerce?
15:44:52 <boxscape> M2en[m] seems like it'd make sense if a is a Semigroup
15:45:21 * shapr grumbles
15:45:31 <shapr> I need a simple atom feed parser.
15:54:43 <boxscape> dminuoso: well, I'm not quite there, but I do have something now that works as long as I define an instance for every type that I want to use https://gist.github.com/JakobBruenker/63c9ac6a5b475c9ab33322f383f1844e
16:05:06 <M2en[m]> I see the light. https://imgur.com/a/lxHdtzX
16:05:51 <boxscape> nice
16:11:53 <buhman> which of these is more readable/better? https://gist.github.com/buhman/32f5f0b8adc90299bc0c849803aab94b
16:12:01 <M2en[m]> What makes it so that some Monoid instances have an implicit `mappend` definition and some don't?
16:12:35 <buhman> I think each implementation has acceptably-similar, but not identical behavior
16:15:27 <M2en[m]> buhman: readp.hs
16:22:35 <boxscape> dminuoso: I did it! https://gist.github.com/JakobBruenker/340ba57bc0e57cdd3a7467d24fada184
16:24:16 <mac10688> boxscape: where did you get that exercise from?
16:24:22 <boxscape> from dminuoso
16:25:03 <mac10688> ah ok
16:30:35 <buhman> M2en[m]: thanks!
16:40:51 <buhman> I was looking at the reader monad. Do people use it with environment variables (System.Environment)? 
16:41:12 <buhman> (and other purposes of course)
16:56:56 <dmj`> buhman: yes
17:20:43 <boxscape> isn't any instance of (->) technically an orphan instance?
17:27:00 * hackage servant-rawm 0.3.2.0 - Embed a raw 'Application' in a Servant API  https://hackage.haskell.org/package/servant-rawm-0.3.2.0 (cdepillabout)
17:41:56 <ski> % :i (->)
17:41:56 <yahb> ski: data (->) (a :: TYPE q) (b :: TYPE r) -- Defined in `GHC.Prim'; infixr 0 ->; instance Applicative ((->) a) -- Defined in `GHC.Base'; instance Functor ((->) r) -- Defined in `GHC.Base'; instance Monad ((->) r) -- Defined in `GHC.Base'; instance Monoid b => Monoid (a -> b) -- Defined in `GHC.Base'; instance Semigroup b => Semigroup (a -> b) -- Defined in `GHC.Base'; instance [safe] (PrintfArg a, HPrintfTy
17:57:09 <lyxia> boxscape: how's that different from any other type
17:57:37 <boxscape> lyxia usually GHC warns you about orphan instances but it doesn't seem to with (->)
18:00:02 <lyxia> it does warn
18:00:37 <boxscape> hm I must be doing something wrong then
18:01:01 <boxscape> I just wrote "class Test a where" and "instance Test ((->) e) where" and it doesn't seem to, with -Wal
18:01:04 <boxscape> -Wall*
18:01:20 <lyxia> it's not an orphan if it's in the same module as the class
18:01:27 <boxscape> oh oops
18:01:30 <boxscape> thanks :)
18:19:44 <jle`> boxscape: orphan instances are instances that are not defined with either the type definition or the class definition
18:20:15 <jle`> boxscape: for example you will get the same behavior if you try to define an instance of Test for Maybe
18:20:19 <boxscape> I know that, in principle. I just ignored half of it, for some reason.
18:20:37 <jle`> so in that sense Maybe isn't any different from ((->) e)
19:24:23 <sim590> Could this https://paste.debian.net/1098344/ be written in a more straightforward way? Without needing to play with isJust or I don't know.
19:24:47 <buhman> is (runMaybeT $ C.pack <$> (MaybeT $ lookupEnv "FOO")) an idiomatic-looking expression?
19:25:42 <buhman> seems a bit roundabout when I'm just wanting to fmap into nested monads
19:26:07 <jle`> buhman: i'd write (fmap . fmap) C.pack instead
19:26:12 <buhman> oooh
19:26:18 <jle`> or even fmap C.pack <$> lookupEnv "FOO"
19:26:37 <jle`> you can fmap into nested functors by just fmapping more than once
19:26:39 <jle`> :t fmap
19:26:42 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:26:42 <jle`> :t fmap . fmap
19:26:44 <lambdabot> (Functor f1, Functor f2) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
19:26:46 <jle`> :t fmap . fmap . fmap
19:26:48 <lambdabot> (Functor f1, Functor f2, Functor f3) => (a -> b) -> f1 (f2 (f3 a)) -> f1 (f2 (f3 b))
19:26:59 <jle`> see how you can go down as many layers as you need just by doing more fmaps
19:27:06 <buhman> wow, I saw that with lift, it just never occured to me..
19:27:15 <buhman> nice, thanks!
19:27:47 <jle`> np :)
19:28:01 <jle`> also if you do want to do a newtypey way (maybe you are using a functor-polymoephic function), you can use Compose instead of MaybeT
19:28:20 <jle`> it's a little more general so it can work for any two compositions of functors
19:28:29 <jle`> but if you're just directly fmapping then yeah, fmapping twice is probably the most clear way
19:28:51 <jle`> sim590: you can use mapMaybe
19:28:58 <jle`> sim590: or catMaybes
19:30:05 <jle`> sim590: treeFromBTree (BNode n t1 t2) = Node n <$> mapMaybe treeFromBTree [t1, t1], for a direct translation of what you wrote
19:30:26 <jle`> er sorry, Just (Node n (mapMaybe treeFromBTree [t1, t2]))
19:31:20 <sim590> Oh yeah. That's better.
19:31:33 <jle`> but for me it's a little odd to map over a list litera, so you could do Just . Node n . catMaybes $ [ treeFromBTree t1, treeFromBTree t2 ]
19:31:37 <jle`> *literal
19:31:59 <jle`> just personal style
19:32:28 <jle`> i find [f x, f y] more readable than map f [x, y] if you have the literal right there
19:32:46 <jle`> and also there are cases where [f x, f y] would work where map f [x, y] won't
19:33:05 <sim590> Indeed. Thanks for those ideas. Is there some infix operator associated to mapMaybe?
19:33:40 <jle`> hm, not that i know of.  you'd probably be able to use `mapMaybe`
19:34:28 <sim590> Alright!
19:34:49 <ski> @type zipWith . zipwith . zipWith
19:34:51 <lambdabot> error:
19:34:51 <lambdabot>     • Variable not in scope:
19:34:51 <lambdabot>         zipwith :: ([a] -> [b] -> [c]) -> a1 -> b1 -> c1
19:34:59 <ski> @type zipWith . zipWith . zipWith
19:35:01 <lambdabot> (a -> b -> c) -> [[[a]]] -> [[[b]]] -> [[[c]]]
19:37:43 <jle`> :t map . map . map
19:37:45 <lambdabot> (a -> b) -> [[[a]]] -> [[[b]]]
19:37:48 <jle`> :t zipWith3 . zipWith3 . zipWith3
19:37:50 <lambdabot> (a -> b -> c -> d) -> [[[a]]] -> [[[b]]] -> [[[c]]] -> [[[d]]]
19:37:56 <dmj`> :t mapMaybe . mapMaybe . mapMaybe
19:37:58 <lambdabot> error:
19:37:58 <lambdabot>     • Couldn't match type ‘[b0]’ with ‘Maybe b1’
19:37:58 <lambdabot>       Expected type: (a -> Maybe b) -> [[a]] -> Maybe b1
19:38:12 <dmj`> :(
19:38:37 <dmj`> :t fmap `fmap` fmap `fmap` fmap
19:38:39 <jle`> :(
19:38:39 <lambdabot> (Functor f1, Functor f2, Functor f3) => (a -> b) -> f1 (f2 (f3 a)) -> f1 (f2 (f3 b))
19:38:52 <jle`> you can use mapMaybe on the last layer only because its type is not 'symmetrical'
19:38:56 <jle`> :t map . map . map . mapMaybe
19:38:57 <lambdabot> (a -> Maybe b) -> [[[[a]]]] -> [[[[b]]]]
19:39:07 <dmj`> ghc should make sad face emoji when no typecheck
19:42:42 <monochrom> Submit a PR! >:)
21:26:40 * ski . o O ( "NO EMOJI !" )
21:30:57 <jle`> 🎿
21:33:30 * hackage emd 0.1.5.0 - Empirical Mode Decomposition and Hilbert-Huang Transform  https://hackage.haskell.org/package/emd-0.1.5.0 (jle)
21:35:00 * hackage connection 0.3.1 - Simple and easy network connections API  https://hackage.haskell.org/package/connection-0.3.1 (VincentHanquez)
21:40:34 <HaskellNoob> Hi, I can someone look at my question about type inference and annotations in let statements? https://pastebin.com/raw/tLf6G406
21:42:50 <Lears> HaskellNoob: The type variable `a` is not in scope; if you want it to be, you need to turn on ScopedTypeVariables and introduce `a` with an explicit forall.
21:46:18 <Lears> Foralls are normally introduced implicitly, meaning `f :: X a -> a; f (X v) = v :: a` is interpreted as `f :: forall a. X a -> a; f (X v) = v :: forall a. a`, shadowing the type variable. What you want is instead `f :: forall a. X a -> a; f (X v) = v :: a`.
21:46:24 <HaskellNoob> Is there a way to figure out the inferred type of 'v'??
21:51:01 <AviD> I was reading https://vincenthz.github.io/compilation-cstruct/. The only thing making this not zero cost would seem to be natVal producing Integer instead of Int? Why is that? Is it a fundamental limitation?
21:59:20 <jle`> AviD: the API that GHC exposes for Nat produces Integer (or Natural, which is more or less the same problem)
21:59:46 <jle`> AviD: it might be possible to circumvent this with a typechecker plugin
22:00:54 <jle`> HaskellNoob: if you have -XScopedTypeVariables on you can do f (X (v :: _)), and i think it gives you the type where _ is
22:01:33 <jle`> HaskellNoob: but actually -XScopedTypeVariables does some extra things as well that 'fixes' the problem
22:01:46 <jle`> hm, actually i guess it doesn't unless you add the forall a. to scope it
22:02:06 <jle`> % data X a = X a deriving Show
22:02:07 <yahb> jle`: 
22:02:23 <jle`> % let f :: X a -> a; f (X (v :: _)) = undefined
22:02:23 <yahb> jle`: ; <interactive>:31:31: error:; * Found type wildcard `_' standing for `a'; Where: `a' is a rigid type variable bound by; the type signature for:; f :: forall a. X a -> a; at <interactive>:31:5-17; To use the inferred type, enable PartialTypeSignatures; * In a pattern type signature: _; In the pattern: v :: _; In the pattern: X (v
22:02:36 <jle`> HaskellNoob: there it tells you the type it expects for 'v'
22:03:00 <jle`> it's the 'a', but unfortunately without explicitly bringing the 'a' into scope, it's not possible to refer to that same 'a' in a type annotation
22:04:08 <jle`> that's because by default in Haskell, all type variables are "self-contained" within a type signature; the 'a' in your sig for f isn't the same as the 'a' in your sig for v.  you have to explicitly bring the 'a' into scope for it to apply to all the 'a's in the body
22:04:30 <AviD> jle`:  Could the GHC API be ever expanded? Why were variable size types chosen over the fixed size equivalents? 
22:09:16 <HaskellNoob> ok thanks
22:14:13 <jle`> AviD: it's nicer from a usability standpoint
22:14:30 <jle`> and it matches the semantics of Nat (the type/kind) better
22:14:38 <jle`> for how people normally use it
22:14:46 <jle`> AviD: yes, it can be expanded using type checker plugins
22:14:57 <jle`> effectively
22:19:30 <jle`> essentially: the main thing going on is that GHC provides reflection of types of kind Nat via a typeclass, similar to Storable or Typeable
22:20:08 <jle`> so there's basically a typeclass `class KnownNat n where natVal :: p n -> Natural`, which can be used like any other normal typeclass -- in the same way as Storable/Typeable, if you are familiar with those
22:20:42 <jle`> the 'magic' is that we cannot write any instances of KnownNat by hand, unlike for Storable.  instead GHC provides these instances for us whenever it can
22:21:29 <jle`> usually it happens when you give an actual Nat literal type or some known application of literals to functions like +/*/etc.
22:22:00 <jle`> so having Nat work with Int would be a matter of defining a class like `class KnownNatInt n where natValInt :: p n -> Int`
22:22:36 <jle`> it isn't really possible to write instances for this directly by hand (without going through GHC's KnownNat)
22:23:10 <jle`> so to make this work, you would have to write a typechecker plugin that does what GHC does: provide instances on-the-fly whenever you can, from literals and applications of functions to literals
22:25:21 <jle`> keep in mind though most of the Haskell ecosystem that uses Nat is built in terms of KnownNat and GHC's native interface for it, so you'd have to do some conversions/plumbings if you want to mix the two styles together
22:38:00 * hackage conferer 0.1.0.1 - Configuration management library  https://hackage.haskell.org/package/conferer-0.1.0.1 (ludat)
22:47:43 <dminuoso> http://mail.openjdk.java.net/pipermail/lambda-dev/2013-February/008314.html
22:47:55 <dminuoso> Oh yes. I love this "You dont get to choose whether something is a monad or not"
22:51:23 <jusss> about the abstract reader monad... I still don't get it...
22:51:43 <dminuoso> jusss: Did you write the implementation yourself?
22:52:21 <jusss> dminuoso: I don't know what you mean, what implementation? 
22:52:26 <jusss> specific?
22:52:32 <dminuoso> jusss: The Monad instance for `(->) e`
22:53:15 <jusss> dminuoso: I can get f >>= g = \x-> g (f x) x through type inference, does this count?
22:53:30 <dminuoso> jusss: Sure. And `return` ?
22:53:43 <dminuoso> jusss: And I think you meant "type tetris" rather than "type inference" :)
22:53:44 <jusss> return x = \_ -> x
22:53:48 <dminuoso> jusss: Very nice.
22:53:57 <jusss> dminuoso: yes, my English is not good
22:54:08 <dminuoso> jusss: That's fine, it's why Im giving you feedback.
22:54:14 <dminuoso> Your English is mostly good.
22:54:43 <jusss> dminuoso: now, I know the type, even the function definition, but what I really don't know is how to thinking about it
22:54:45 <jusss> think
22:54:51 <dminuoso> jusss: *use* it in some code.
22:54:54 <jusss> think it as what?
22:55:05 <dminuoso> jusss: Dont think of it as anything, just use it.
22:55:12 <dminuoso> Build up intuition on your own.
22:55:35 <dminuoso> jusss: Ill give you a sample:
22:55:38 <jusss> dminuoso: f . g = \x -> f (g x) , you see this one, . change f's output 
22:56:01 <jusss> :t (.)
22:56:03 <lambdabot> (b -> c) -> (a -> b) -> a -> c
22:56:10 <jusss> sorry, g's output
22:56:14 * nshepperd . o O (type inference: getting types from code. type tetris: getting code from types. or, co-type inference?)
22:56:28 <jusss> fmap use f to change g's output
22:56:33 <dminuoso> nshepperd: type coinference?
22:56:36 <jusss> and a-> is functor
22:56:42 <dminuoso> jusss: Hold on
22:58:28 <jusss> :t (>>=)
22:58:30 <lambdabot> Monad m => m a -> (a -> m b) -> m b
22:58:36 <dminuoso> jusss: https://gist.github.com/dminuoso/04843dd72145d3edfb094dbb313de534
22:58:39 <ski> @. djinn type (.)
22:58:41 <lambdabot> f a b c = a (b c)
22:58:56 <dminuoso> jusss: Start with that implementation, perhaps. It's a naive excercise, don't use Monad yet. :)
22:59:18 <jusss> (e->a) -> (a->(e->b)) -> (e->b),  this one, we can think >>= use (a->e->b) changed e->a's output to b
22:59:35 <jusss> and e-> is the context
22:59:35 <dminuoso> jusss: Implement all the functions in that gist.
23:18:09 <jusss> dminuoso: "if it is even doubles the value" this mean if it's even then double the value or check if it's double?
23:18:22 <jusss> double the value, I mean x2
23:18:30 <dminuoso> jusss: You check if its even, then double or - otherwise half it.
23:18:47 <jusss> sorry I don't know what double means here
23:18:57 <dminuoso> jusss: It means multiplying a number by two.
23:19:09 <dminuoso> jusss: Using the `double` function
23:19:19 <jusss> dminuoso: wait, double :: Int -> Bool
23:19:25 <dminuoso> Oh heh
23:19:31 <dminuoso> jusss: Should be `Int -> Int` :)
23:19:56 <jusss> dminuoso: ... I though you want to check a number if it's double or not...
23:20:09 <jusss> double I mean like 1.23
23:20:33 <dminuoso> jusss: Nope, just write the code such that `algo` uses `isEven` to test whether its argument is even. If it is even, multiply the argument by two, otherwise divide it by two.
23:20:35 <dminuoso> Is that clear?
23:21:06 <dminuoso> jusss: The function to "multiply a number by two" is the `double` function that you must implement, and the function to "divide by two" is the `half` function.
23:21:09 <jackdk> I have found myself wanting the following function, does anyone have a better name for it? `alignMapMaybe :: (Filterable f, Semialign f) => (These a b -> Maybe c) -> f a -> f b -> f c`
23:22:17 <jusss> dminuoso: https://paste.ubuntu.com/p/w6pyrxyMsW/
23:22:48 <dminuoso> jusss: Alright! Do you see how, in algo, there's this repeating pattern of applying y to all the things?
23:23:12 <jusss> dminuoso: yeah
23:24:50 <dminuoso> jusss: With the monad instance you'd write: do { i <- isEven; if i then double else half } y
23:25:11 <dminuoso> Or, using >>= explicitly: (isEven >>= \i -> if i then double else half) y
23:25:31 <dminuoso> It's still the same code, except the monad instance makes argument passing implicit.
23:27:32 <jusss> dminuoso: you see, isEven's (e->a), its a is its result, 
23:28:20 <jusss> dminuoso: isEven is the function (->), ok, a is the result, ok, but e as the input, if the e is in the context?
23:28:25 <dminuoso> jusss: Right. With the monad instance we can pretend that we're giving the same argument to every thing.
23:28:41 <dminuoso> jusss: It's that argument that every thing is applied to.
23:28:41 <jusss> dminuoso: is the input argument is in the context?
23:28:52 <dminuoso> jusss: The input argument is the context
23:29:29 <jusss> dminuoso: so it means we can pass the input arguments to other functions,right?
23:29:58 <dminuoso> jusss: The monad instance does this!
23:30:13 <dminuoso>  f >>= g = \x-> g (f x) x 
23:30:49 <jusss> dminuoso: but you see, Maybe, we know the context has Just and Nothing,  but e->a, what e is ? a type? it's concret type? or concret value?
23:31:30 <jusss> Maybe is a concret type, but what e is?
23:31:40 <dminuoso> jusss: It's an arbitrary type. Pick whatever you like.
23:32:00 <jle`> jusss: it looks like you already understand everything about the technical aspects/mechanics of (->) r. but you just don't feel an intuition about it
23:32:09 <jle`> jusss: maybe have you tried writing a program taking advantage of the Monad instance of it?
23:32:18 <jusss> dminuoso: then what's the meaning we put an aribitrary type and a function (->) into the context
23:32:52 <jusss> jle`: yeah, the intuition
23:33:11 <jusss> jle`: I don't know think it as what
23:34:28 <jusss> dminuoso: what if g is a unary function, what f >>= g would like to be?
23:34:51 <jle`> jusss: my point is that if you try writing programs with it, you will start to learn what it as what
23:34:59 <jle`> in a way that cannot just be told to you
23:36:25 <jusss> I know the type tetris, I know the function definition, I don't know how to think it, the intuition
23:36:54 <jle`> right, that's what i am saying.  the intuition can come from using it
23:37:10 <jle`> in a way that cannot come from just being told
23:37:35 <jle`> we can give you a manual on how to swim and you can memorize every word
23:37:44 <jle`> but you won't 'feel' how to swim until you try swimming
23:39:52 <jusss> jle`: "what if g is a unary function, what f >>= g would like to be? "
23:46:55 <jusss> sorry, the network is down
23:46:59 <jusss> was
23:55:32 <jusss> (f >>= \y -> g y) x
