00:00:16 * ski would write either `Foo a (mkBar (b c))', or maybe `(Foo a . mkBar . b) c', there, for sure
00:01:03 <ski> (`(Foo a . mkBar) (b c)' is also a possibility, but then `c' above could also be an application)
00:01:17 * ski . o O ( `)
00:01:33 * ski . o O ( `(f . b . c . d) e' )
00:08:35 <sicklorkin> I wonder what sort of performance impact Flow would have? none of those functions are inlineable. or does that matter?
00:09:26 <sicklorkin> are infix operators always inlineable?
00:44:06 <c_wraith> being infix has nothing to do with whether it can be inlined
00:47:45 <sicklorkin> c_wraith: I see
01:26:26 <Welkin> whoever thought it was a good idea to require the user to type "YES" before hitting <Enter> at the end of the ghcup install process to actually make it work needs 40 lashes
01:26:35 <Welkin> make it the god damn default
01:26:52 <Welkin> of course I didn't see it and just hit enter, resulting in nothing happening
01:26:59 <Welkin> and it looked like the install was broken/failed
02:33:42 <dansho> it doesn't say to type 'no' otherwise, so i ended up typing 'no' just to be sure
02:34:22 <dansho> it doesn't really tell you what the default is
02:50:30 * hackage xmonad-contrib 0.16 - Third party extensions for xmonad  https://hackage.haskell.org/package/xmonad-contrib-0.16 (PeterSimons)
03:21:45 <masaeedu[m]> is there a way i can get quantified class members where the quantified type is not `*` to unify with other quantified expressions?
03:22:18 * masaeedu[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/vhwUUKCSJJYmSeazxdZIjraK >
03:22:22 <masaeedu[m]> and the errors don't make any sense to me
03:22:41 * masaeedu[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/joZMmKdYyTKGHuxoFyeAFJey >
03:23:05 <masaeedu[m]> i've tried various explicit instance signatures, also tried explicitly carrying `o` as a class parameter through the whole hierarchy
03:23:08 <masaeedu[m]> nothing seems to work
03:23:37 * masaeedu[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/FxpSRkrFiUqdVdMuGhISmpPQ >
03:32:20 <masaeedu[m]> i have a perhaps simpler example
03:32:22 * masaeedu[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/MqGiMqAjewJkgdfkXcolXfKp >
03:32:54 <masaeedu[m]> i can't assign `proxyId` to `proxId'`
04:01:30 * hackage fvars 1.0.0.0 - Fast Mutable Vars  https://hackage.haskell.org/package/fvars-1.0.0.0 (erick)
04:19:05 <ski> masaeedu[m] :  m1  m2  mi  mo  ?
04:23:31 <ski> masaeedu[m] : yea, the problem seems to be one of generalization. that if  p '(s,t)  holds for every `s',`t', of kinds `k',`l', then  p st  holds for every `st', of kind `(k,l)'
04:24:11 <ski> (one might call this an "induction" principle, for that product kind)
04:26:00 * hackage flatbuffers 0.1.0.0 - Haskell implementation of the FlatBuffers protocol.  https://hackage.haskell.org/package/flatbuffers-0.1.0.0 (dcastro)
04:28:27 <ski> masaeedu[m] : btw, i was briefly wondering why `Tensoid' and `Tensor', rather than say `Semigroupoidal' (category) and `Monoidal' (category)
04:30:21 <ski> masaeedu[m] : one might also wonder whether there ought to be a category `BraidedTensor' in between `Tensor' and `SymmetricTensor' (the last one having no methods)
04:31:24 <ski> masaeedu[m] : finally, i was thinking that `SymmetricTensor' (and also `BraidedTensor', if you want to consider it) ought to be type classes, and not just constraint synonyms
04:33:06 <ski> (masaeedu[m] : hm, actually, i suppose you could also want a `BraidedTensoid', if you wanted a `BraidedTensor')
04:37:09 <masaeedu[m]> less letters is why primarily :)
04:37:54 <masaeedu[m]> i'm skipping a bunch of stuff in the hierarchy that i don't actually care about, e.g. just going straight to `Category`
04:38:00 <ski> masaeedu[m] : by defining `SymmetricTensor p t i' as a synonym for `(SymmetricTensoid p t,Tensor p t i)', you're basicallly claiming that as soon as you have a symmetric semigroupoidal category, which is also monoidal category, then you have a symmetric monoidal category .. which i think is not the case. you also want coherence laws like `swap <<< lunit = runit' and `lunit = swap <<< runit'
04:38:04 <masaeedu[m]> you can stick stuff like `Braided` in the middle, but i don't really care about that
04:38:22 <ski> ("less letters" is ok, i just wanted to remark on it :)
04:38:26 <masaeedu[m]> the laws themselves have no evidence associated with them
04:38:43 <ski> ("skipping a bunch of stuff in the hierarchy that i don't actually care about" is also ok :)
04:40:11 <masaeedu[m]> regarding the induction principle thing you're talking about
04:40:18 <masaeedu[m]> is there a way to teach ghc this induction principle?
04:41:03 <ski> by having `class (SymmetricTensoid p t,Tensor p t i) => SymmetricTensor p t i', rather than merely `type SymmetricTensor p t i = (SymmetricTensoid p t,Tensor p t i)', you're forcing the user to declare `instance SymmetricTensor P T I' explicitly, and thereby to promise that the coherencce laws holds for `P',`T',`I'
04:42:02 <ski> masaeedu[m] : yea, that's the main problem, the other things i mentioned are just things on the side. i'm not sure whether it is. it seems like this is something that it ought to know about, for product kinds
04:42:42 <ski> (or at least there ought to be a blessed / standard way of making it do this inference)
04:42:47 <masaeedu[m]> can you think of a `Tensor p t i` (keeping in mind `| t -> p i`), that's simultaneously a `SymmetricTensoid p t`, but for which the laws don't hold?
04:43:25 <ski> it's a similar issue (in a way) to whether say `(x,y) <- act' should invoke a `MonadFail
04:43:31 <ski> ' constaint or not
04:43:37 <masaeedu[m]> it turns out that using type families to pull out the `Fst` and `Snd` makes it happy, so i'm going to do that
04:44:00 <masaeedu[m]> but i'd still like to know if there's a way to teach it to unify those things
04:44:07 <ski> (point being that the only possibly shape of a pair `(x,y)', and so that pattern-match can't possibly fail (it could still bottom out))
04:44:53 <ski> in your case, a skolem `st' of kind `(k,l)' can only possibly be of shape  '(s,t)  for skolem `s',`t' of kinds `k',`l'
04:45:13 * ski would also like to know
04:46:45 <ski> (i wonder whether asking about this issue in #ghc would perhaps yield a more informative answer)
04:47:34 <masaeedu[m]> til there is a #ghc
04:48:33 <ski> masaeedu[m] : anyway, re `ProxyArrow', i think you have a typo/thinko (not that fixing it would solve the problem)
04:49:44 <masaeedu[m]> what is the typo/thinko?
04:49:51 <ski> <ski> masaeedu[m] :  m1  m2  mi  mo  ?
04:50:04 <masaeedu[m]> oh, right
04:50:09 <masaeedu[m]> yeah, i fixed that a while ago, sorry
04:50:10 <masaeedu[m]> lol
04:50:17 <ski> ok :)
04:50:22 <masaeedu[m]> but you're right, fixing that didn't fix the problem
04:51:16 <masaeedu[m]> i've posted the question in #ghc
04:51:18 <masaeedu[m]> let's see
04:51:32 <ski> btw, what would the `o' you mentioned be ?
04:52:27 * ski doesn't see masaeedu[m] in #ghc, nor the question
04:52:58 <masaeedu[m]> you mean in the instance for `Optic c m`?
04:53:38 <masaeedu[m]> it would be `(k, k)` for all kinds `k`, given `c :: Hom k` in `Optic c m`
04:53:50 <masaeedu[m]> you could also get really specialized and go with `(*, *)`
04:54:04 <masaeedu[m]> whoops, i guess the matrix room doesn't work
04:54:07 <masaeedu[m]> let me try again
04:54:22 <ski> you said "i've tried various explicit instance signatures, also tried explicitly carrying `o` as a class parameter through the whole hierarchy", and i wondered what that `o' would stand for, then
04:54:37 <masaeedu[m]> it would be the kind
04:54:56 <ski> oh .. ight
04:55:08 <ski> sorry, i think i actually realized that, at first, but then i forgot
04:55:14 <masaeedu[m]> i just started by changing `class GCategory (p :: Hom o)` to `class GCategory o (p :: Hom o)`, and then had to prefix that to every subsequent class
04:55:22 <ski> right
04:55:26 <masaeedu[m]> but it didn't help
04:55:36 * ski nods
04:56:30 <masaeedu[m]> sorry, am i in the right room now?
04:56:35 <masaeedu[m]> re #ghc
04:59:06 <ski> yes
04:59:59 * ski has no idea how <matrix.org> works, where you were before. but now you're in the #ghc IRC channel, and asked in there
05:02:05 <masaeedu[m]> that makes two of us
05:02:11 <masaeedu[m]> still a little easier than irc for a noob
07:03:56 <jzyamateur> One cannot use existing binding/variable name in pattern parts of a case expression?
07:05:24 <jzyamateur> https://gist.github.com/chetnashah/519f97a0f9ff5d77e959579b3e48205f
07:07:40 <jzyamateur> Only guard cases seem to be able to handle variables? Not case expression cases?
07:13:04 <Ferdirand> jzyamateur: correct, if you use a variable name in a binding it shadows the previous binding
07:13:26 <jzyamateur> Is there an idiom about what to do in such cases?
07:16:11 <Ferdirand> you can use guards in case expressions
07:17:48 <lyxia> case ... of   sep' : rest | sep == sep' -> ...    is this what you were trying to write
07:30:21 <jzyamateur> What is the correct way to write the guard at the end of https://gist.github.com/chetnashah/519f97a0f9ff5d77e959579b3e48205f ? Cannot seem to get it working.
07:30:28 <jzyamateur> lyxia
07:31:29 <geekosaur> don't reuse hd, for one; it's not doing what you think
07:32:21 <jzyamateur> yeah I mean I have always seen guards with a function definition, I just want to use guard without the let thing, how to get it working then?
07:32:57 <geekosaur> in fact, what I think you want is to just remove the " -> let hd" part
07:33:04 <lyxia> put the guard on the left of the arrow      hd : rest | hd == sep -> ...
07:33:48 <geekosaur> yeh, and replace the =s with ->s in the guards
07:35:22 <ski> jzyamateur : you can use `where fft = ...' at the end, instead of `let fft = ... in' at the beginning
07:35:50 <ski> jzyamateur : you can use `break' (or `span', if you prefer), instead of `takeWhile' and `dropWhile'
07:35:50 <jzyamateur> Ok, I got it working after the refactor you mentioned. I am confused about the one thing, `->` are still part of case expressions right?
07:35:57 <ski> yes
07:37:55 <geekosaur> jzyamateur, yes.
07:38:01 <geekosaur> guards are part of pattern syntax
07:38:30 <geekosaur> the = or -> is not part of the guard but of the case or function. and the function form you know becomes the case form inside the compiler
07:43:09 <ski> jzyamateur : btw, perhaps you don't need to match on `hd : rest', if you use takeWhile'&`dropWhile' (or `break', or `span') ?
07:43:59 <jsomedon> if I have `data Boolean = True | False`, does `True` here mean the built in `True :: Bool` or a new, irrelevant `True` that will become `True :: Boolean`?
07:44:13 <jzyamateur> ski Right now I am grappling/trying out different syntax constructs and getting familiar.
07:45:21 <ski> jsomedon : the latter
07:46:03 <ski> jzyamateur : that's good
07:46:56 <ski> jzyamateur : as someone already hinted, instead of `(hd : rest)', you can just say `hd : rest' there. similarly, in place of `fft : (getAllWords sep lst)', `fft : getAllWords sep lst'. redundant brackets are redundant :)
07:47:43 <ski> jzyamateur : btw, if you want to, you could try defining `getAllWords', without using `takeWhile'&`dropWhile' (or `break', or `span')
07:49:39 <ski> jsomedon : a `data' (or `newtype') declaration always declares new data constructors
07:52:44 <jsomedon> ðŸŽ¿ so.. after declaring Boolean like that, I get error if I try to use True::Bool. It looks like ghci only remembers latest defined `True`
07:53:08 <jzyamateur> yeah ski, it was a practice problem. Also I found a definitive reference for syntax constructs which is the haskell report: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html
07:53:45 <jsomedon> ðŸŽ¿ anyway I can use both True::Bool and True::Boolean?
07:55:51 <ski> jsomedon : yes, if you use module qualification, preferably by defining things in a module, in a source file, rather than directly in the interactor (GHCi)
07:56:29 <ski> jsomedon : "only remembers latest defined `True`" -- previous ones are shadowed, yes. hence why it's better to write more extensive things into a source file
07:56:47 <jsomedon> ah
07:56:56 * ski nods to jzyamateur
07:57:57 <jsomedon> i see, so maybe Bool is in some ModuleBool and I just need to import Bool from there
07:58:00 * hackage http-mock 0.1.0.0 - HTTP mocking and expectations library for Haskell  https://hackage.haskell.org/package/http-mock-0.1.0.0 (frincon)
07:58:35 * ski would also go `False | True', rather than `True | False' ..
07:58:43 <jsomedon> ?
07:59:15 <ski> (because, traditionally, `False < True', but you'll only get that `Ord' instance with `deriving Ord', if you write them in that order)
07:59:24 <jsomedon> ah
07:59:46 <jsomedon> didn't know that, thanks!
08:00:06 <ski> np :)
08:02:30 <jsomedon> so I see that `False` and `True` are referred as value and constructors here and there..
08:02:59 <EvanR> ski: what exactly is P(exists x:A . X = x)
08:07:13 <jsomedon> So are they like function essentially(so they are callable) or are they just simple non function values like numer 123 or string "123"(so you can't call them)
08:13:28 <ski> EvanR : the probability that there exists some value in the range of the stochastic variable, that it will assume
08:14:03 <ski> jsomedon : data constructors are values
08:15:14 <ski> jsomedon : yes, `False' and `True' are like numerals / numeric literals like `123' or `123.45', or string literals like `"123"'. they're "constants", "standing for themselves"
08:15:26 <jsomedon> oh
08:16:02 <ski> jsomedon : have you seen `Nothing',`Just';`Left',`Right';`Node' ?
08:16:42 <jsomedon> ðŸŽ¿ in some other books yes but I kinda forgot what they do haha
08:16:48 <ski> okay
08:17:06 <jsomedon> uhm so you mean
08:17:17 <ski> hm, consider this
08:18:37 <ski>   solveQuadraticEquation :: (Double,Double,Double) -> AtMostTwoDoubles
08:19:03 <EvanR> ski: so this is a probability regarding the model X we have written down on paper, about which we know everything
08:19:07 <ski>   solveQuadraticEquation (a,b,c) = ...  -- solve the equation `a * x^2 + b * x + c = 0', for `x'
08:19:22 <EvanR> sort of like, probability that this sentence contains letter t = 1
08:19:45 <EvanR> instead of being the usual probability associated with an abstract sample space
08:19:45 <ski> EvanR : we can know that a stochastic variable will certainly assume *some* value
08:20:24 <ski> jsomedon : here `AtMostTwoDoubles' is a data type whose values record the fact that there can be zero, one, or two (real) solutions of a quadratic equation :
08:20:27 <ski>   data AtMostTwoDoubles = None
08:20:30 <ski>                         | One Double
08:20:31 <ski>                         | Two Double Double
08:20:45 <jsomedon> so far so good
08:20:58 <ski> (the details of `solveQuadraticEquation' doesn't matter here. my point is just to motivate this `AtMostTwoDoubles' type)
08:21:08 <jsomedon> yeah
08:21:34 <ski> here `AtMostTwoDoubles' is a type constructor. while `None',`One',`Two' are all data constructors
08:21:43 <ski> type constructors are types. data constructors are values
08:22:22 <jsomedon> ok
08:22:26 <ski> some data constructors are functions, like `One' and `Two'. some are not functions, but "constants", like `None' (or `False',`True' from before)
08:22:32 <EvanR> probability of a fair coin flip resulting in heads = 1/2. Probability that we used a coin for the example, 1
08:22:55 <jsomedon> ah
08:23:31 <EvanR> seems like two modes of reasoning, maybe that is what the de dicto de re was about
08:23:38 <ski> (some type constructors are (type) functions, some are not (e.g. `AtMostTwoDoubles'). i might show an example of a type constructors that is a type function, a function on types, a function on "the type level" (rather than on "the value level", which is where ordinary functions like `length',`not',`reverse' "live"))
08:25:30 <ski> EvanR : "de re" vs. "de dicto" is about relative placement of quantifiers and modal operators. "there exists a dog such that it is possible that .." is "de re", the dog actually exists. "it is possible that there exists a dog such that .." is "de dicto", the dog is only taken to exist in a possible/imaginary world, not necessarily "the real one"
08:26:11 <ski> EvanR : it seemed to me that the placement of quantifiers inside our outside the "probability of ... is ..." construction was something similar to this "de re" vs. "de dicto" distinction
08:26:26 <ski> (also see "Barcan formula" for more on "de re" vs. "de dicto")
08:26:32 <jsomedon> so type also can be function.. I tried things like `:t Bool` and I got error so I thought a type is neither a fuction nor a non-function-value
08:27:14 <ski> jsomedon : the "type of a type" is called a "kind". instead of `:type Bool' (or `:t Bool' for short), in the interactor, you should say `:kind Bool' (or `:k Bool' for short)
08:27:26 <jsomedon> oh
08:27:56 <ski> figuatively, you can think of values as living on the ground floor, and types living on the next floor up. then kinds live yet another floor up
08:28:23 <ski> types describe values. kinds describe types
08:28:42 <jsomedon> so can I somehow define this "kind" thing in Haskell?
08:28:47 <jsomedon> is that class?
08:29:04 <jsomedon> class is set of relatd type I think?
08:29:04 <ski> no, it's not type classes, that's something else
08:29:11 <ski> (type classes also live on the type level)
08:30:16 <ski> (type classes are properties/predicates on, or relations between, types. just as some things on the type level can be type functions, some things (type classes) can also be type relations)
08:30:42 <ski> anyway, going back to the declaration of `AtMostTwoDoubles'
08:30:49 <ski>   data AtMostTwoDoubles = None
08:30:50 <ski>                         | One Double
08:30:53 <ski>                         | Two Double Double
08:31:08 <ski> this really means that we're declaring `AtMostTwoDoubles' to be a new ("concrete") type
08:31:34 <jsomedon> you say concrete
08:31:41 <jsomedon> so there is non conrete as well
08:31:49 <ski> and also that, values of this new type can be of three possible shapes, namely `None', or `One x' (where `x' is a `Double'), or `Two x y' (where `x' and `y' are `Double's)
08:32:21 <ski> jsomedon : yes, that ("non concrete") would be the "type function" stuff, which i haven't mentioned yet
08:32:30 <jsomedon> ok haha
08:33:22 <ski> it's important to note that, in the declaration of `AtMostTwoDoubles', `None',`One',`Two' live on the value level, while `Double', and `Double',`Double' after them (and also `AtMostTwoDoubles' to the left of `=') all live on the type level
08:34:16 <ski> the `=' does not mean "equals" here (perhaps a different symbol should have been used ..). we're not claiming that `AtMostTwoDoubles' is somehow "equal" to `None | One Double | Two Double Double'
08:35:12 <ski> the notation is merely a short-hand description (inspired by BNF, Backus-Naur / Backus Normal Form, from grammars, describing syntax of languages), for the long-hand explanation (with `x' and `y') i said above
08:36:13 <ski> if you enable the extension `GADTSyntax' (by writing `{-# LANGUAGE GADTSyntax #-}' at the top of your source file, e.g.), then you can define the *same* type `AtMostTwoDoubles' in an alternative way :
08:36:17 <ski>   data AtMostTwoDoubles
08:36:19 <ski>     where
08:37:32 <ski>     None ::                     AtMostTwoDoubles
08:37:37 <ski>     One  :: Double ->           AtMostTwoDoubles
08:37:38 <ski>     Two  :: Double -> Double -> AtMostTwoDoubles
08:38:07 <ski> in this alternative syntax, you just write the type signatures, of your data constructors, just like you do when you define functions, and other values
08:38:13 <jsomedon> (wow your formatting so good)
08:38:47 <ski> (but there's no corresponding "definition". `None',`One',`Two' are "themselves", they don't "compute" anything. they just store some data, for later retrieval)
08:39:53 <ski> (however, as you see, we had to repeat the "result type", `AtMostTwoDoubles' for each constructor, here (and also write the `->' after each data constructor argument type). so the previous syntax is more concise)
08:40:04 <jsomedon> you mean they are like themselves like primitve values like numric literals
08:40:09 <ski> yes
08:40:23 <ski> they don't "do anything"
08:40:56 <jsomedon> I find that amazing because in other language, the langauge gives you fixed kind of such values-themselves but in haskell you define such thing
08:41:01 <ski> if you write `One 3.4', or `Two 5 2.1', or `None', then those doesn't "compute" anything. they just give you back values of type `AtMostTwoDoubles'
08:41:18 <ski> values which you later can "look inside", to retrieve the `3.4',`5',`2.1' parts
08:41:52 <jsomedon> I see
08:41:57 <ski> a value of type `AtMostTwoDoubles' here is like a "container" that can contain at most two `Double's
08:42:11 <ski> it can (only) be of one of these three forms
08:42:47 <ski> and you detect which form it is, by "pattern-matching" (either to the left of `=', in argument patterns (formal parameters), in function definitions. or in a `case'-`of' expression)
08:43:27 <ski> (and, in the end, that's the only way to actually do something interesting with a value of type `AtMostTwoDoubles')
08:44:00 <ski> now, what if we wanted to be able to store `Integer's, instead of `Double's ?
08:44:07 <ski> or, perhaps, `String's ?
08:44:43 <ski> well, we could define a new data type, `AtMostTwoInteger's (and probably name its three data constructors differently, at least if it's defined in the same module as `AtMostTwoDoubles'), and so on ..
08:44:50 <ski> but this is tedious and silly
08:45:14 <jsomedon> so we `data AtMostTwoA = None|One a | Two a a`?
08:45:19 <ski> we'd like to be able to define a single type, that allows us to choose, when we use it, which type the "component type" should be
08:45:51 <ski> yes
08:45:53 <ski>   data AtMostTwo a = None
08:45:55 <ski>                    | One a
08:45:56 <ski>                    | Two a a
08:46:13 <jsomedon> a I am missign a behind type AtMostTwo
08:46:18 <ski> where `a' is a parameter of the type `AtMostTwo a'
08:46:24 <ski> so, we can say `AtMostTwo a' [Act: 5,6,7,8,9,11,16,17,18,19,20,26,27,28,29,30,31,33,35
08:46:27 <ski> er
08:46:47 <ski> so, we can say `AtMostTwo Double', and `AtMostTwo Integer', and `AtMostTwo String', and so on
08:47:24 <ski> (we have to pick a single type, in each case, a value of type `AtMostTwo Integer' can only contain `Integer's, not `Double's nor `String's)
08:48:09 <ski> now, `AtMostTwo a' is a (concrete) type, but `AtMostTwo' itself is a type function (one kind of non-concrete type)
08:48:15 <jsomedon> ah
08:48:20 <ski> you can't say
08:48:21 <jsomedon> that is type function
08:48:32 <ski>   mySolutions :: AtMostTwo  -- this is nonsense !
08:48:35 <ski> you have to say e.g.
08:48:41 <ski>   mySolutions :: AtMostTwo Double  -- this is okay
08:49:11 <ski> saying `mySolutions :: AtMostTwo' would be like saying "`xs' is a list of". a list of what ?
08:49:39 <ski> `AtMostTwo' is an "incomplete" type, a "template", you have to say what type you want to fill in the parameter (`a' above) with
08:49:44 <Ferdirand> q
08:50:06 <jsomedon> I see
08:50:22 <ski> now, since, `AtMostTwo' is a (type) function (a function living on the type level), you can "call" it, with `Integer' as input, like `AtMostTwo Integer'
08:50:45 <ski> so, one could ask : what (type) does this (type) function they output, given this type as input ?
08:50:54 <ski> however, the answer to that is : no
08:52:14 <ski> just like calling `One' (a data constructor) on `3.4', like `One 3.4' doesn't "compute" any value, calling `AtMostTwo' (a type constructor) on `Integer', like `AtMostTwo Integer', doesn't "compute" any type. `AtMostTwo Integer' just "is itself", you don't get "another type as answer"
08:53:16 <ski> (however, there *are* things, called typ families, which does compute new types for you. type families are also type functions. but they are not data constructors, they don't just "are themselves", they actually compute to other types)
08:54:07 <ski> (if `Foo' is a type family, then `Foo Bool' could be defined to compute `Integer', while `Foo Integer' computes to `Double' (this is a silly example, but possible))
08:54:38 <jsomedon> (but in this example AtMostTwo is not a type family but it's still a type funciton)
08:55:36 <ski> jsomedon : also, i should say that, just as all of `None',`One',`Two' are data constructors (which are values, while only the latter two are functions); similarly all of `Integer',`Double',`AtMostTwo' are type constructors (but only the last one is a type function)
08:55:42 <ski> jsomedon : yes
08:56:04 <ski> a type function is any type thing you can apply to type things, and get a type back
08:56:15 <jsomedon> ok
08:57:02 <ski> anyway, `AtMostTwo' is sometimes said to be a parameterized type. `a', in the definition of it, being the parameter
08:57:12 <ski> that's just another term for "type function"
08:57:26 <jsomedon> that term makes sense haha
08:57:53 <ski> any parameterized types lead very soon to polymorphic values
08:57:58 <ski> e.g. you can define
08:58:08 <ski>   rev :: AtMostTwo a -> AtMostTwo a
08:58:24 <ski>   rev  None     = None
08:58:41 <ski>   rev (One x)   = One x
08:58:53 <ski>   rev (Two x y) = Two y x
08:59:35 <ski> this definition doesn't care about what "component" type we use, doesn't care about the types of `x' and `y' : it just shuffles them around, anyway, never looking "inside" those values
09:00:18 <ski> and so, this definition works for any specific type (like `Integer',`Double', even `AtMostTwo Integer') being used in place of `a' in the type signature of `rev'
09:00:32 <ski> does that make sense, jsomedon ?
09:00:56 <ski> exercise : figure out what possible shapes the values of type `AtMostTwo (AtMostTwo Integer)' can be of
09:01:33 <jsomedon> so, by "component" type you mean that "a" right?
09:01:52 <jsomedon> and those "x" adn "y"
09:01:56 <ski> by "component type" of a value of type `AtMostTwo a' here, i mean the type `a', yes
09:02:05 <jsomedon> ok
09:02:10 <ski> (the type of `x' and `y', above)
09:02:20 <jsomedon> yeah
09:02:29 <ski> have you seen lists ?
09:02:55 <jsomedon> so the rev code, yes makes sense; list u mean, things like x:xs?
09:02:59 <ski> yes
09:03:07 <jsomedon> yes seen that before
09:03:17 <ski> you could define your own (parameterized, say) type of lists, as
09:03:36 <ski>   data List a = Nil
09:03:37 <ski>               | Cons a (List a)
09:04:05 <ski> again, recall that `Nil',`Cons' here are data constructors (so values), while `a' and `List a' (after `Cons') are types
09:04:13 <ski> this is the same as
09:04:17 <ski>   data List a
09:04:19 <ski>     where
09:04:39 <ski>     Nil  ::                List a
09:04:39 <ski>     Cons :: a -> List a -> List a
09:05:04 <ski> this is a recursive type, since the type we're defining, `List', itself occurs in the argument types of the data constructors
09:05:52 <ski> values of this type, `List a', looks like `Nil',`Cons x0 Nil',`Cons x0 (Cons x1 Nil)',`Cons x0 (Cons x1 (Cons x2 Nil))',&c.
09:06:35 <jsomedon> yes
09:06:44 <ski> (one can even have infinite values (lists), like `Cons x0 (Cons x1 (Cons x2 (Cons x3 (Cons x4 (...)))))', that never ends with `Nil' .. however, depending on what one's doing, one may want to disregard those infinite values)
09:07:12 <ski> `Nil' is both the empty list, and serves as the "end of list marker"
09:07:46 <ski> the only way to reach all the elements of a list, is to step inside each `Cons', until one finally reaches the `Nil' at the end
09:08:02 <ski> (one "steps inside" it, by pattern-matching)
09:08:04 <ski> we can define
09:08:10 <ski>   last :: List a -> a
09:09:05 <ski>   last  Nil         = error "last : no last element in empty list"
09:09:09 <ski>   last (Cons x Nil) = x
09:09:10 <ski>   last (Cons _ xs ) = last xs
09:09:56 <jsomedon> uhm, sorry if i am interrrupting u, if the real list type in haskell is defined like this, than I assume the ":" operator is essentilaly an alias of "Cons" I guess? but : is like a function but Cons here is a non function value..?
09:10:30 <ski> (here `_' means "don't care", or "ignore" or "anything goes". it's called a "wildcard", it's a pattern which matches anything, always succeeding, doing nothing. otoh, `x' and `xs' are patterns which also always succeeds matching, but which also bind `x' respectively `xs' to the matched value, so that one may refer to it, later, after the `=')
09:10:51 <ski> jsomedon : yes, `(:)' is just like another spelling of this `Cons'
09:10:53 <ski> @src []
09:10:53 <lambdabot> data [] a = [] | a : [a]
09:11:09 <jsomedon> huh
09:11:21 <jsomedon> [] is a valid variable name??
09:11:40 <jsomedon> i mean identifier I think that's how PL people call it?
09:11:59 <ski> the only difference is that `:' is an infix operator, an infix data constructor (one can define such on one's own, as long as they start with a `:'). however the data constructor `[]' (empty list) is special syntax, as is the type syntax `[] a' (which is the same as `[a]')
09:12:41 <ski> so, no, the data constructor `[]', and the type constructor `[]' (usaulyl written "mixfix", like `[a]', rather than "prefix", like `[] a') are special cases in the syntax
09:12:54 <jsomedon> ok
09:13:06 <jsomedon> mixfix ha nice term
09:13:11 <ski> but it's only the syntax that is special. it still behaves just like my custom definition of `List' above
09:15:31 <ski> jsomedon : another exercise, define a type of binary trees (elements in leaves, no elements in internal nodes), then write a function that given any tree computes a list of all its leaf elements (in order from left to right)
09:15:51 <ski> (each leaf contains a single element, if that wasn't clear)
09:16:44 <ski> you could also define a function `mirror' that "mirrors" a tree, leftmost leaf in input is now rightmost in the output, and so on
09:17:29 <iqubic> That sounds like a fold over a tree.
09:17:50 <jsomedon> data BT a = Nil | (Node a, Left, Right)?
09:18:06 <jsomedon> But Left Right should also be BT type..
09:18:07 <ski> (yet another function : given a "tree of trees" (leaves in the tree themselves contain (simple) trees), return the "same" tree, but with the leaf trees "grafted" in place)
09:18:22 <ski> "elements in leaves, no elements in internal nodes"
09:18:26 <ski> (you did the opposite)
09:20:10 <ski> (you could also define a function that counts all the leaves in a tree, a function that sums all `Double' leaves in a tree, and a function that computes the mean/average of all `Double's in a tree)
09:21:04 <ski> jsomedon : btw, did you consider the previous exercise, yet ?
09:21:10 <ski> <ski> and so, this definition works for any specific type (like `Integer',`Double', even `AtMostTwo Integer') being used in place of `a' in the type signature of `rev'
09:21:15 <ski> <ski> exercise : figure out what possible shapes the values of type `AtMostTwo (AtMostTwo Integer)' can be of
09:21:30 * hackage dialogflow-fulfillment 0.1.0.0 - A Dialogflow Fulfillment library for Haskell.  https://hackage.haskell.org/package/dialogflow-fulfillment-0.1.0.0 (mauriciofierrom)
09:21:43 <coddinkn> is there a way to make a type alias for a class constrained type?
09:22:15 <ski> coddinkn : depends on what you want, but i suspect the answer is no
09:22:56 <coddinkn> I'm trying to define a monad in "final tagless endcoding" like described at the end of free monads considered harmful
09:23:00 <ski> jsomedon : of course, the exercises are only suggestions, which you might find interesting to consider ..
09:23:20 * ski doesn't recall details of that
09:23:31 <jsomedon> ah that one: None,    One None, One One Int, One Two Int Int,    Two None None, Two One Int One Int, Two Tow Int Int Two Int Int
09:23:35 <coddinkn> https://markkarpov.com/post/free-monad-considered-harmful.html
09:23:56 <jsomedon> But do I need to wrap those type with ()?
09:24:08 <coddinkn> basically define a type class with a monad constraint which exposes all of your desired actions
09:24:27 <coddinkn> then by whatever means implement the internals of that monad as desired
09:25:13 <coddinkn> my question is mainly ergonomic as writing all of my logic with MyMonad m => m () type signatures is pretty annoying
09:25:36 <ski> jsomedon : yes, except of `Int' you should say something like `x0',`x1',`x2',... -- also, you need brackets
09:25:46 <ski> jsomedon : and you're missing six cases
09:26:15 <EvanR> type MySynonym m a = MyMonad m => m a ?
09:26:19 <ski> "But do I need to wrap those type with ()?" -- yes
09:26:58 <coddinkn> EvanR: that sounds like it might be what I want
09:27:18 <ski> coddinkn : i still haven't seen any example(s) where you'd want to abbreviate stuff
09:27:30 * hackage chiphunk 0.1.1.0 - Haskell bindings for Chipmunk2D physics engine  https://hackage.haskell.org/package/chiphunk-0.1.1.0 (CthulhuDen)
09:27:54 <coddinkn> ski: under A better solution myProgram :: MonadTerm m => m () -- TerminalM ()
09:27:58 <ski> coddinkn : i'm wondering where exactly `m' (if that's the identifier you use) will appear in the type signature .. only once (not counting constraints), or more than once ? in return type ? in argument type(s) ?
09:28:03 <coddinkn> the comment is the type signature I'd like
09:28:59 <coddinkn> ski: I think in most cases only once in the return type, though I hesitate to say that definitively
09:28:59 <ski> coddinkn : if it's just that, then you can use what EvanR suggested
09:29:20 <ski> (possibly also with an explicit `forall m', in the type synonym definition)
09:29:29 <coddinkn> alright let me play around and see what that looks like, thanks EvanR ski 
09:29:38 <monochrom> IIRC you need an extension, but lens does that too.
09:29:59 <ski> (yes, extension is probably needed)
09:30:49 <iqubic> ski: So, I have a binary tree with data in the leaves only. I'm trying to write a traversable instance for it.
09:31:06 <iqubic> http://dpaste.com/139Q7SW
09:31:42 <ski> iqubic : `Node <$> ...'
09:31:46 <iqubic> I know.
09:32:11 <ski> then what's the problem ?
09:32:58 <EvanR> the AtMostTwo examples leads me to wonder how easy it would be to parameterize the "two" away
09:32:59 <iqubic> traverse f (Node left right) = liftA2 Node (traverse f left) (traverse f right)
09:33:13 <iqubic> I don't think there is a problem.
09:33:25 <iqubic> data Tree a = Leaf a | Node (Tree a) (Tree a)
09:34:00 <iqubic> And I could write fmap myself, but I think I like just using fmapDefault.
09:34:24 <iqubic> I've already defined how to walk over the data myself once.
09:34:44 <jsomedon> ðŸŽ¿ ahha, so, I am missing cases of Two value1 value2, that value1 and 2 can be different as long as they both are the AtMostTwo Integer 
09:35:07 <jsomedon> ðŸŽ¿ I only wrote cases where value1 and value2 are same
09:35:26 <jsomedon> ðŸŽ¿ I need those combinations that value1 and 2 are different, right?
09:36:10 <iqubic> ski: To count the number of nodes, I'd use my foldable instance and 'numNodes = foldr (+) 0'
09:36:33 <lavalike> @src sum
09:36:33 <lambdabot> sum = foldl (+) 0
09:37:08 <monochrom> I turned "how many shapes does AtMostTwo (AtMostTwo Int) have" into "how many values does AtMostTwo (AtMostTwo ()) have".
09:37:26 <iqubic> :t sum
09:37:28 <lambdabot> (Foldable t, Num a) => t a -> a
09:37:52 <iqubic> Wait... That doesn't work.
09:38:12 <iqubic> That's not the number of nodes, that's the sum of all the values in the nodes.
09:38:35 <EvanR> you want the sum of all values in the type of formula "1"
09:38:45 <EvanR> sum over
09:39:02 <EvanR> quantifying over all values in a type is not often seen... i think
09:39:08 <EvanR> i mean, at runtime
09:39:15 <heatsink> jsomedon, is your irc client autocorrecting "ski:" to ðŸŽ¿?
09:39:41 <lavalike> :t getSum . fold . fmap (const $ Sum 1)
09:39:42 <lambdabot> (Foldable t, Num c, Functor t) => t b -> c
09:39:56 <iqubic> Here's how to count the nodes: 'numNodes = sum . fmap (const 1)'
09:40:14 <iqubic> :t sum . fmap (const 1)
09:40:15 <lambdabot> (Foldable t, Num c, Functor t) => t b -> c
09:40:25 <EvanR> that's still not "how many possible values"
09:40:26 <ski> iqubic : i'd possibly use `liftA' with `liftA2', or else `<$>',`<*>' in both cases
09:40:51 <iqubic> http://dpaste.com/1MADKF3
09:41:01 <iqubic> I also added a mirror function there.
09:41:02 <ski> jsomedon : yes
09:41:07 <iqubic> Not sure it works correctly.
09:41:31 <ski> jsomedon : that's why i said you should write variable names, instead of `Int'. they you'd more likely have realized this
09:41:52 <ski> monochrom : yea, that's fine :)
09:42:14 <ski> (next, someone will consider "how many values does `AtMostTwo (AtMostTwo Void)' have")
09:43:17 <iqubic> ski: Does my mirror function work properly?
09:43:18 <ski> heatsink : what is that unicode glyph that looks like "ï¿½" to me ?
09:44:01 <ski> iqubic : sure. now you're missing `join'
09:44:08 <iqubic> I don't know. I don't know what glyph that is because my font displays it as a rectangle with a hex number in it.
09:44:16 <iqubic> ski: What would join do?
09:44:39 <iqubic> join :: Tree (Tree a) -> Tree a?
09:44:50 <heatsink> It's U+1F3BF, unicode ski and ski boot
09:45:15 <iqubic> ski: How would join work for this data type?
09:45:30 <ski> iqubic : you could search for that rectangle in a character map (or look up the hex numeral manually) ? if i search for "ï¿½", i only find "U+FFFD REPLACEMENT CHARACTER", which doesn't tell me what it originally was ..
09:46:21 <ski> heatsink : oic, ty
09:47:07 <ski> <ski> (yet another function : given a "tree of trees" (leaves in the tree themselves contain (simple) trees), return the "same" tree, but with the leaf trees "grafted" in place)
09:47:10 <ski> iqubic ^
09:47:22 <jsomedon> heatsink: yeah, uh so you guys all see that ski emoji instead of ski":"?
09:47:38 <ski> yes, jsomedon
09:47:42 <jsomedon> uh..
09:47:47 <ski> (or rather, i only saw "ï¿½")
09:47:52 <jsomedon> hm
09:48:08 <jsomedon> and I still can mention you with that weird symbol?
09:48:30 <geekosaur> well, people will see it, whether ski gets highlighted is another question
09:48:41 <jsomedon> right that's what I am curious
09:48:43 * ski doesn't understand jsomedon's last question
09:48:54 <ski> geekosaur : i didn't
09:48:58 <geekosaur> is your client beeping or etc. to tell you you were specifically mentioned
09:48:59 <jsomedon> so, if this gets sent out ski:
09:49:10 <jsomedon> no I mean if this gets sent out
09:49:12 <ski> that one worked fine
09:49:27 <ski> perhaps it's only being replaced, if it's at the start of a message (strangely enough) ?
09:49:28 <jsomedon> ðŸŽ¿ trying to mention you
09:49:43 <ski> (there i only see "<jsomedon> ï¿½ trying to mention you")
09:49:47 <jsomedon> I don't knwo my last message actually mentioned you or not
09:49:58 <geekosaur> it's the skiing emoji. sheesh
09:49:59 <ski> (but just before, i saw "<jsomedon> so, if this gets sent out ski:")
09:50:21 <jsomedon> so it looks like, if I type ski: in the middle of message
09:50:30 <jsomedon> it doesn't get replaced with emoji
09:50:33 <ski> right
09:50:39 <jsomedon> hence it should mention you
09:50:42 <jsomedon> but if I do
09:50:53 <jsomedon> ðŸŽ¿ not mentioning you I guess?
09:51:00 <ski> not mentioning me
09:51:04 <jsomedon> it's not mentioning you I guess
09:51:05 <iqubic> Trees are applicative: http://dpaste.com/1G2CT71
09:51:13 <ski> (have we sorted out this topic satisfactorily, now ?)
09:51:45 <iqubic> ski: Does that look like a valid applicative instance for: "data Tree a = Leaf a | Node (Tree a) (Tree a)"?
09:52:05 <ski> iqubic : should say `Leaf f   <*> x = ...' and `Node l r <*> x = ...'
09:52:24 <iqubic> It does.
09:52:36 <ski> nope, you had extra (redundant) brackets
09:52:58 <iqubic> Oh. But aside from that, does it look fine?
09:53:43 <jsomedon> ski so I am still confused that, is (:) a function or not? In ghci, :t (:) looks like it's a function, but it should not be a function because it's a data constructor?
09:54:03 <iqubic> jsomedon: It is both a function and a data constructor.
09:54:08 <iqubic> :t (:)
09:54:09 <lambdabot> a -> [a] -> [a]
09:54:24 <ski> iqubic : i think it's a fine idiomatic instance, yes. i even think it's coherent with the monadic instance
09:54:36 <ski> jsomedon : it's both a data constructor and a function
09:54:40 <iqubic> You can make a monad out of trees?
09:55:39 <ski> jsomedon : all data constructors are values. some values are functions. even some data constructors are function, like this `(:)', but also `Cons',`One',`Two' (but not `Nil',`None', those are not functions)
09:55:46 <ski> iqubic : try ? :)
09:56:56 <iqubic> How would I write 'join' for trees.
09:57:01 <iqubic> What does that even mean?
09:57:06 <ski> jsomedon : a (value) function is any value which can be applied to an input argument, yielding an output result (and any such value is a (value) function). a (value) function is a value having a type that looks like `... -> ...'
09:57:24 <ski> iqubic : i already pointed you to where i explained what it should do
09:57:47 <ski> (shall i repeat it again ?)
09:57:56 <iqubic> What does "grafted" mean?
09:58:00 * hackage coinbase-pro 0.5.0.0 - Client for Coinbase Pro  https://hackage.haskell.org/package/coinbase-pro-0.5.0.0 (mdunnio)
09:58:07 <ski> iqubic : "glued", if you prefer ?
09:58:31 <iqubic> Ah. I see.
09:59:21 <ski> iqubic : imagine a tree, with fruits at the leaves. the fruits are in this case mini-trees. cut off each fruit/tree, and attach it directly to the "mother tree", at the place where the leaf was (removing that leaf, replacing it with the "mini tree")
10:01:01 <ski> iqubic : <https://en.wikipedia.org/wiki/Grafting>,<https://en.wikipedia.org/wiki/Graft_(surgery)>
10:01:38 <iqubic> http://dpaste.com/3C2ADQ8
10:02:07 <ski> good, but it can be simplified
10:02:38 <iqubic> How?
10:02:56 <ski> look for repetition
10:03:05 <iqubic> Like this, I guess: http://dpaste.com/01HKW5P
10:03:06 * ski . o O ( "DRY" )
10:03:15 <ski> yep :)
10:03:17 <ski> that's it
10:03:24 <iqubic> Cool.
10:03:25 <ski> next, define `(>>=)'
10:03:32 <jsomedon> ski : so as a constructor, I just need `(:) 1 [2,3]` to store a value like 1:[2,3] but not to actually compute it right?
10:03:33 <iqubic> x >>= f = glue $ f <$> x
10:03:34 <ski> (directly, i mean)
10:03:38 * ski grins
10:03:41 <iqubic> Oh. Hehe.
10:04:10 <ski> jsomedon : yes. `(:) x xs' is just another syntax for `x : xs'
10:04:24 <ski> jsomedon : "compute" in this case only means "store"
10:04:33 <jsomedon> uh..
10:04:44 <ski> (so, you do actually "compute it", but also, yes "nothing happens")
10:05:24 <ski> `[2,3]' is syntactic sugar for `2 : 3 : []' (or `2 : (3 : [])', if you're unsure about the bracketing)
10:05:25 <iqubic> http://dpaste.com/3MKJ7EK
10:05:29 <iqubic> There it is.
10:05:33 <ski> `[1,2,3]' is syntactic sugar for `1 : 2 : 3 : []'
10:05:53 <iqubic> ski: I did it!!!
10:05:58 <iqubic> I did a useful thing here.
10:06:07 <ski> hence, `1 : [2,3]' is syntactic sugar for `1 : (2 : 3 : [])', iow `1 : 2 : 3 : []', which has `[1,2,3]' as syntactic sugar
10:06:23 <ski> iqubic : redundant brackets
10:06:36 <ski> iqubic : otherwise, it's fine
10:06:41 <iqubic> Thanks.
10:07:09 <ski> iqubic : next, perhaps try to figure out what a `Tree'-effect, for this monad (and idiom), might be ?
10:07:25 <iqubic> 'glue (Leaf a) = a' needs brackets, but 'Leaf a >>= f = f a' doesn't.
10:07:53 <iqubic> I'll think about that later. I have things to do now.
10:07:53 <ski> iqubic : you can also consider `data Expr var = Var var | Lit Integer | Add (Expr var) (Expr var) | Mul (Expr var) (Expr var)', and make that into an idiom and a monad, and then consider the same question again
10:08:12 <ski> "'glue (Leaf a) = a' needs brackets, but 'Leaf a >>= f = f a' doesn't." -- right
10:08:40 <ski> iqubic : "I'll think about that later. I have things to do now." -- sure :) just giving you something hopefully curious to think about
10:08:53 <iqubic> Is this a monad for ASTs?
10:08:58 <ski> jsomedon : okay (re syntactic sugaring) ?
10:09:29 <ski> iqubic : it's an "expression monad" (parameterized over variable type) .. what does `(>>=)' mean, for this monad ?
10:10:12 <ski> (s/variable type/type of variable identifiers/)
10:10:24 <jsomedon> ski : I still feel like I am confused but I don't know hwo to phrase my question..
10:10:32 <ski> jsomedon : okay
10:10:44 <ski> try, and we'll see if we can refine it ?
10:11:00 <jsomedon> ski : but that 1 : 2 : [] part makes sense
10:11:36 <jsomedon> ski : so when you explained, in the AtMostTWo example
10:11:55 <jsomedon> ski : None, One, Two they all are not really computing anything
10:11:56 <ski> (iqubic : but yes, you could say "ASTs", if you like to. however, it doesn't handle bound variables, only free ones)
10:12:08 <jsomedon> ski : They just store some values
10:12:11 <ski> right, jsomedon
10:12:30 <ski> or, they "compute trivially, without doing anything", if you want
10:13:30 <iqubic> I have no idea what (>>=) does for this monad.
10:14:14 <ski> ("computation" in this case only means "storing some things together, in a single value, for later retrieval". `None' stores no (zero) things, `One x' stores one thing (`x'), while `Two y z' stores two things (`y' and `z'). each of them also record "who they are", whether they're a `None', a `One' or a `Two', so that you can later detect which alternative "shape" the value had)
10:14:28 <ski> iqubic : right, that's part of the fun of it, figuring that out :)
10:14:33 <iqubic> I know.
10:14:43 <ski> (but that's for later, i assume)
10:15:02 <iqubic> What we have here is similar to ($ x). It's a bunch of values awaiting a function to be applied to them.
10:15:18 <iqubic> Specifically a function of type (a -> a -> b).
10:15:41 <iqubic> It's like a fold, except we don't know which function to apply.
10:15:51 <ski> (you could also write a (useful) function of type `(var -> Expr var) -> Expr var -> Expr otherVar', and contemplate its definition, e.g. in terms of `do')
10:16:18 <iqubic> Remember that only the leaves have data here.
10:17:11 * ski isn't sure whether iqubic, by "data" is referring to the `var' parts, or to the `Integer' parts, or perhaps (not likely) to the data constructor parts
10:17:49 * ski looks at jsomedon
10:18:35 <jsomedon> ski : so the way I undrstood is, like how java defines primitve value types int, boolean for users, in Haskell, the user gets to define their own primitive value types with `data Primitive = PossibleValue1 |PossibleValue2 |...` so  Ithought storing value means it's just making up some primitive values, some of them happens to be shape of containing nothing, liek None, some has shape of containing
10:18:38 <jsomedon> one value like One, and so on
10:19:00 * hackage crdt 10.5 - Conflict-free replicated data types  https://hackage.haskell.org/package/crdt-10.5 (cblp)
10:19:03 <jsomedon> ski : is my understanding correct so far?
10:20:11 <ski> jsomedon : well we don't call these "primitive" types. they're just "user-defined types" (sort of like how definition of interfaces and classes in Java gives rise to user-defined object types .. except that these types really don't behave much at all like the types that `data' declarations in Haskell behave)
10:20:12 <jsomedon> ski : I mean `data A = B Bool | C` is making up new primitve value type A, where like in java I am not allowed to do that, in haskell I can
10:20:35 <jsomedon> oh ok
10:20:58 <jsomedon> ski : I guess by primitive I mean
10:21:04 <ski> jsomedon : `data' in Haskell declares (more or less) so called variant types, or sum types. the particular flavor we have (allowing multiple arguments to data constructors) is called "algebraic data types"
10:21:49 <ski> jsomedon : while, `interface' and `class' in Java declares (more or less) so called record types, or sum types. the particular flavor might be called "object types"
10:22:26 <ski> variant/sum types are very different from record/product types (but both are very important sorts of types)
10:24:12 <ski> (in some sense, they are the "opposite", or "dual", of each other. are "mirror images", or the "reverse" of each other. they give rise to different trade-offs in code organization. depending on what kind of thing you think will more likely, or less likely, change in the future, wrt your type, you might select one or the other of sum vs. product types as implementation)
10:25:00 <ski> jsomedon : "Ithought storing value means it's just making up some primitive values, some of them happens to be shape of containing nothing, liek None, some has shape of containing one value like One, and so on","is my understanding correct so far?" -- yes (except i'd not call it "primitive value types")
10:26:42 <jsomedon> ski : so after writing code `data A = B Bool | C`, B and C are like 123. I mean 123 is just 123 it doesn't gets evaluated into somethign more a primitve? unlike lets say `(+) 123 1` this gets computed into 124 because 124 is the most primitive thing I can get
10:26:45 <jsomedon> ?
10:26:56 <ski> (by a "primitive type", in Haskell, i'd mean a type which cannot be (or at least isn't being) defined in Haskell, which has to be taken as a type supplied by the language, by the implementation (e.g. via standard library))
10:27:30 <jsomedon> ah
10:27:34 <jsomedon> uhm
10:27:51 <jsomedon> in that sense anyting `data` gives me is not primitive at all
10:28:56 <jsomedon> but `B True` still is `B True`, just like 124 is still 124 right? unlike (+) 123 1 is evaluated into 124
10:29:54 <ski> (examples of this : the types `(->)' (function types),`IO' (Input/Output interaction),`IORef' (references to mutable boxes),`Array' (immutable arrays),`IOArray' (references to mutable arrays) can't be defined in the language. `[]' could be (if renamed to `List', say), but isn't (syntactic sugar) (also `String'). `Int',`Integer',`Float',`Double',`Char' have special syntax, and also wouldn't be practical to define in the language using `data')
10:30:28 <ski> > [minBound,maxBound] :: [Int]
10:30:31 <lambdabot>  [-9223372036854775808,9223372036854775807]
10:30:32 <EvanR> i was about to say exercise what is a type that CANNOT be defined in haskell, but currently isn't
10:30:36 <ski> you could imagine
10:31:03 <EvanR> er, and currently isn't, i guess that's redundant
10:31:17 <EvanR> answer i guess, function type
10:31:23 <ski>   data Int = Neg9223372036854775808 | Neg9223372036854775807 | Neg9223372036854775806 | ... | Neg2 | Neg1 | Zero | Pos1 | Pos2 | ... | Pos9223372036854775807
10:31:32 <ski> but it'd be awkward, a very long source file
10:31:48 <EvanR> Int could be defined in terms of Integer, with a smart ctor
10:31:51 <ski> (and probably not as efficient, without some advanced gymnastics magic in the implementation)
10:31:57 <EvanR> Integer in terms of Nat
10:32:00 <ski> yea, EvanR
10:32:09 <ski> > [minBound,maxBound] :: [Char]
10:32:10 <lambdabot>  "\NUL\1114111"
10:32:27 <ski> > [minBound .. maxBound] :: [Char]
10:32:29 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
10:32:46 <ski> > [' ' .. maxBound] :: [Char]
10:32:48 <lambdabot>  " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefgh...
10:33:35 <ski>   data Char = NUL | SOH | STX | ... | SP | ExclamationMark | DoubleQuote | Hash | Dollar | Percent | ... | Uni1114111
10:33:47 <ski> would also be possible to consider, at least as a thought experiment ..
10:33:54 <EvanR> Char in terms of Int, with smart ctor
10:34:08 <ski> jsomedon : makes sense ?
10:34:08 <EvanR> or Integer
10:34:14 <EvanR> or Nat
10:34:48 <EvanR> > chr 1114111
10:34:50 <lambdabot>  '\1114111'
10:34:52 <EvanR> > chr 1114112
10:34:54 <lambdabot>  *Exception: Prelude.chr: bad argument: 1114112
10:34:54 <jsomedon> ski : uh yeah it's impossible to write all individual values in type defintion
10:35:01 <EvanR> smart ctor
10:35:19 <EvanR> perhaps not so smart
10:35:24 <ski> jsomedon : "in that sense anyting `data` gives me is not primitive at all" -- `data's is for making your own user-defined (variant / sum / algebraic data) types, yes
10:35:34 <ski> jsomedon : "but `B True` still is `B True`, just like 124 is still 124 right? unlike (+) 123 1 is evaluated into 124" -- yes
10:36:45 <ski> jsomedon : well, as long as there's a finite number of them, at least in theory it would be possible
10:37:05 <ski> (even for `Float' and `Double')
10:37:22 <EvanR> float and double in terms of mantissa and exponent...
10:37:30 <EvanR> with weird special cases
10:37:30 * hackage doctemplates 0.6.1 - Pandoc-style document templates  https://hackage.haskell.org/package/doctemplates-0.6.1 (JohnMacFarlane)
10:37:32 <jsomedon> ski : ah yeah instead of impossible I should say too anoying to write them all
10:37:39 <ski> EvanR : that'd also work (and be more reasonable) :)
10:37:55 <ski> jsomedon : "impractical","intractable" ;)
10:38:02 <EvanR> i think Data.Half does this for 16 bit float
10:38:05 <jsomedon> haha
10:38:24 <ski> (a disctinction that often doesn't matter much, but which can be nice to know about)
10:39:07 <ski> jsomedon : btw, have you seen tuples, and tuple types ?
10:40:33 <jsomedon> ski : so these functions(or constructors) One, Two, (:) they all store value for me , then the result is I have this constructor-value-combined-value-that's-like-124 
10:40:58 <ski> okay
10:41:14 <jsomedon> ski : typle you mean (1,"a string")
10:41:17 <jsomedon> ?
10:41:29 <ski> data-constructor-combined-with-a-bunch-of-argument-values (possibly zero)
10:41:35 <ski> yes, jsomedon
10:41:39 <jsomedon> haha ok
10:41:58 <EvanR> i am kind of suspicious about the indistinguishability of constructor function applied to argument, and ... the constructed value (looks identical)
10:42:06 <ski> jsomedon : can you imagine how one might use `data' to define a pair types, e.g. ?
10:42:25 <EvanR> it has definitely confused a lot of people i tried to explain it to
10:42:28 <jsomedon> pair type? you mean values like (a,b)
10:42:31 <ski> EvanR : implementation details
10:42:46 <EvanR> Just 5 is a value. What's Just 5? ... it's Just 5.
10:42:55 <EvanR> what happens when you apply Just to 5... it's Just 5
10:42:55 <ski> jsomedon : if `a' and `b' are values, like e.g. `1' and `"a string"', yes
10:43:05 * ski grins at EvanR
10:43:10 <jsomedon> ski : ah yeah that's what I eman
10:43:32 <jsomedon> ski : so data Pair a b = (a,b) ?
10:43:44 <jsomedon> no
10:43:59 <ski> (however, commonly succssive lower case letters from the start of the alphabet are used as type variables, rather than value variables .. so)
10:44:01 <jsomedon> ski : data Pair a b = First a Second b?
10:44:04 <EvanR> in my mind i pretend there is a different form, Just = \x -> JustK[x], Just 5 is "really" JustK[5] heap object
10:44:12 <EvanR> now Just really is a function
10:44:24 <ski> jsomedon : not `data Pair a b = First a Second b', that's nonsense
10:44:34 <jsomedon> ski : data Pair a b = ((First a), (Second b))
10:44:41 <ski> still nonsense
10:44:52 <ski> jsomedon : `data Pair a b = (a,b)' is okay, as would `data Pair a b = MkPair a b' be
10:45:03 <ski> i was thinking about something like
10:45:08 <ski>   data (a,b) = (a,b)
10:45:09 <ski> or
10:45:18 <ski>   data (,) a b = (,) a b
10:45:31 <ski> > (,) 1 "a string" :: (,) Integer String
10:45:33 <lambdabot>  (1,"a string")
10:46:03 <ski> (note that one `(,)' is a data constructor, while the other is a type constructor. both are written the same, in Haskell. i find this confusing)
10:46:22 <ski> and then also
10:46:28 <ski>   data () = ()
10:46:36 <ski>   data (a,b,c) = (a,b,c)
10:46:37 <jsomedon> so (,) is like Cons for a tuple?
10:46:41 <ski>   data (a,b,c,d) = (a,b,c,d)
10:46:43 <ski> or
10:46:54 <ski>   data (,,) a b c = (,,) a b c
10:46:59 <ski>   data (,,,) a b c d = (,,,) a b c d
10:47:01 <ski> and so on
10:47:31 <ski> jsomedon : yea, `(,)' is the (single) data constructor for the pair type constructor `(,)'
10:47:56 <ski> (and similarly for tuples of other "lengths", like `()',`(,,)',`(,,,)',&c.)
10:48:32 <ski> (the type constructor) `List' had two data constructors, `Nil' and `Cons'
10:49:19 <jsomedon> So the type con Tuple should have Nil and ConsTuple, and I don't need First and Second, I just need Cons a b
10:49:19 <ski> (the type constructor) `(,)' (or `()', or `(,,)', or `(,,,)', &c.) has only one data constructor, written the same :`(,)' (or `()', or `(,,)', or `(,,,)', &c.)
10:49:25 <jsomedon> ConsTuple a b
10:49:42 <ski> `(1,"a string")' is syntactic sugar for `(,) 1 "a string"'
10:50:00 <jsomedon> ConsTuple 1 "astring"
10:50:01 <ski> `(Integer,String)' is syntactic sugar for `(,) Integer String'
10:50:24 <ski> jsomedon : no, no `Nil' for `Pair'
10:50:35 <ski>   data Pair a b = ConsPair a b
10:50:45 <ski>   data Unit = ConsUnit
10:50:58 <ski>   data Triple a b c = ConsTriple a b c
10:51:06 <jsomedon> because a pair is never allowed to be empty tuple/
10:51:09 <jsomedon> ?
10:51:14 <ski>   data Quadruple a b c d = ConsQuadruple a b c d
10:51:56 <ski> (instead of `Cons', i'd probably say `Make', or `Mk' for short. some people would reuse the same name, as in `data Pair a b = Pair a b', but i find that confusing)
10:52:16 <jsomedon> ah I see you are tyring to define types for each possible length of tuple
10:52:30 <ski> "I don't need First and Second" -- yes, `First' and `Second' (as you used them, at least) were nonsense ..
10:52:34 <ski> right
10:52:55 <ski> each tuple type (of some specific "length") is its own type, unrelated to the other tuple types
10:52:57 <jsomedon> ok lets use Mk then
10:53:15 <ski> (it might be nicer if it weren't, but that's how it (currently) works in Haskell)
10:53:25 <ski> (and, most likely, that won't change. too late for that)
10:53:56 <ski> there is something called "record syntax" (related to record/product types, mentioned above), where you could say
10:54:13 <ski>   data Pair a b = MkPair {first :: a,second :: b}
10:54:44 <ski> then the value `MkPair {first = 1,second = "a string"}' can have type `Pair Integer String'
10:54:57 <ski> (and, you can mention the fields of the record in whichever order you like)
10:55:20 <ski> you could write
10:55:31 <ski>   addPair :: Pair Integer Integer -> Integer
10:55:47 <ski>   addPair (MkPair {first = x,second = y}) = x + y
10:55:58 <ski> or, you could define it as
10:56:09 <ski>   addPair p = first p + second p
10:56:39 <ski> because the above `data' declaration automatically defines two "field accessor/selector/projection" functions for you
10:56:44 <ski>   first :: Pair a b -> a
10:56:58 <ski>   first (MkPair {first = x,second = _}) = x
10:57:04 <ski> (and similarly for `second')
10:57:24 <ski> you can also write
10:57:36 <ski>   incrementFirst :: Pair Integer b -> Pair Integer b
10:57:53 <ski>   incrementFirst p = p {first = first p + 1}
10:57:55 <ski> instead of
10:58:12 <ski>   incrementFirst (MkPair {first = x,second = y}) = MkPair {first = x + 1,second = y}
10:59:03 <ski> `p {first = first p + 1}' computes a copy of the record `p', but with the field `first' in the copy being `first p + 1', all other fields (here only `second') being copied over unchanged
10:59:44 * ski idly wonders whether jsomedon managed to follow this quick dive into record syntax
10:59:53 <jsomedon> when you say that each tuple are of different types, I realized that I ve seen that in the book but I never realized that means I am gonna define types for each possible length of tuples.. this sounds like writing individual Int values for Int type...
11:00:10 <jsomedon> ski : uh it looks like class definition in those language like java haha
11:00:11 <ski> yes, it does, jsomedon
11:00:31 <jsomedon> ski : so that first essentially is a function?
11:00:32 <ski> <ski> each tuple type (of some specific "length") is its own type, unrelated to the other tuple types  <ski> (it might be nicer if it weren't, but that's how it (currently) works in Haskell)  <ski> (and, most likely, that won't change. too late for that)
11:01:16 <ski> jsomedon : `first', when used inside `MkPair {...}' (to the left of the `='s) is a field name. used elsewhere, it's a selector function for that field
11:01:32 <ski> as a field, we have `first :: a' (given the type `Pair a b')
11:01:43 <jsomedon> ski :  that sounds like we have two `first` for completely different things
11:01:46 <ski> as a field selector function, we have `first :: Pair a b -> a'
11:01:54 <ski> and yes, i also think this is very confusing
11:02:47 <ski> they ought not to have written the field selector function just as `first'. instead of `first p', one should say something like `#first p' (as in SML) or like `p .first' (as in C,Java,OCaml,&c.) ..
11:02:52 <jsomedon> ski : then does the (:) in data [] definition and (:) in a code like (:) 1 [2,3] are also compeletely two different things?
11:03:27 <EvanR> back to constructor function vs constructed value
11:03:29 <ski> jsomedon : "that sounds like we have two `first` for completely different things" -- yes. imho, this is confusing :/
11:03:35 <jsomedon> EvanR: lol
11:03:50 <ski> "then does the (:) in data [] definition and (:) in a code like (:) 1 [2,3] are also compeletely two different things?" -- no
11:03:56 <jsomedon> ok
11:03:58 <EvanR> application of ctor function, vs ct-ed value
11:03:59 <ski> that's the same single thing
11:04:05 <EvanR> look identical
11:04:11 <jsomedon> EvanR: what is ct?
11:04:16 <EvanR> construct
11:04:19 <jsomedon> aha
11:04:22 <EvanR> sorry, terrible lingo
11:04:40 <jsomedon> it maskes sense once you explain it
11:04:52 <ski> EvanR : "in my mind i pretend there is a different form, Just = \x -> JustK[x], Just 5 is \"really\" JustK[5] heap object","now Just really is a function" -- in OCaml, you can't write `map Some xs', you must spell out `map (fun x -> Some x) xs'
11:04:53 <jsomedon> ct ctor
11:05:12 <ski> "ctor" is short for "constructor"
11:05:32 <jsomedon> ski : makese sense
11:05:32 <ski> ("tyvar" is short for "type variable")
11:05:38 <jsomedon> oh
11:06:04 <jsomedon> let me quickly re read your record part
11:06:15 <ski> ("ADT" is sometimes short for "Algebraic Data Type" (in Haskell), but is also sometimes short for "Abstract Data Type" (in programming in general, including in Haskell))
11:06:33 <EvanR> so ocaml did it even worse than haskell :)
11:06:53 <jsomedon> so here `MkPair {...}` this {...} is a single value
11:07:05 <ski> EvanR : oh, i thought you were arguing that it was better, that way ?
11:07:33 <ski> jsomedon : there is no `{...}' (value) on its own, in Haskell. there is only `CTor {...}'
11:07:36 <EvanR> ocaml seems to still only have 1 form and you can't tell the difference between application and already-constructed
11:07:42 <jsomedon> oh wait it's not a value, it's a type constructor?
11:07:53 <EvanR> i don't really think two forms would be better, but it would aid in explanation
11:08:04 <ski> jsomedon : `CTor {fieldName = expression,...}' is special "record construction" syntax
11:08:15 <ski> jsomedon : `recordExpression {fieldName = expression,...}' is special "record update" syntax
11:08:39 <jsomedon> oh it's its own new syntax..
11:08:40 <EvanR> in javascript, people know that [5] is not a function application. But there would be a revolt is [5] was written cons(5,[])
11:08:48 <EvanR> if*
11:08:57 <EvanR> and could not reduce
11:09:58 <ski> jsomedon : `CTor' here is a data constructor (not a type constructor). when using record syntax, it's always followed by `{...}' (and this `{...}' never occurs, not following either a data constructor, being declared with record syntax, like `MkPair' above, or after an expression of a data type defined using record syntax (like `Pair'))
11:10:37 <jsomedon> `data Pair a b = MkPair {first::a, second::b}` so you mean here {first::a, second::b} is not(or does not evaluate into) a type constructor?
11:11:14 <ski> EvanR : in Prolog, all "function applications", like `cons(2,nil)' or `add(2,3)' "does not compute", are inert, cons/2 and add/2 acting like our data constructors
11:12:18 <ski> (the only way to compute something nontrivially is to use relations/predicates (well, sometimes, one can do some things which are at least a bit useful, only with equality (unification, "bidirectional pattern-matching")))
11:12:57 <ski> EvanR : "ocaml seems to still only have 1 form and you can't tell the difference between application and already-constructed" -- point,"i don't really think two forms would be better, but it would aid in explanation" -- nod
11:14:39 <jellostahps> :t concat
11:14:40 <lambdabot> Foldable t => t [a] -> [a]
11:14:45 <jellostahps> what does t [a] mean
11:15:12 <jellostahps> [a] is  a list, what is the input parameter if there is a 't' in front of it
11:15:36 <EvanR> ski: interesting... about prolog
11:16:39 <EvanR> t is applied to [a], t takes a type and returns a type
11:16:50 <EvanR> for example t could be Maybe
11:16:56 <ski> jsomedon : `t' could be `[]' (which is an instance of `Foldable'), and `[Blah]' is syntactic sugar for `[] Blah', so we then get `concat :: [] [a] -> [a]', which is the same as `concat :: [[a]] -> [a]' (or, if you prefer `concat :: [] ([] a) -> [] a')
11:17:02 <ski> er
11:17:08 <ski> jellostahps ^
11:17:34 <ski> yeah, with `Maybe' you get `concat :: Maybe [a] -> [a]'
11:18:51 <ski> EvanR : of course, `2 + 3' also does not compute, in Prolog, since that's just syntactic sugar (user-declared infix operator) for `+(2,3)', (+)/2 is just another "functor", just like cons/2,add/2
11:18:55 <ski> @where on-functors
11:18:55 <lambdabot> "On Functors" (in C++,Standard ML,Haskell,Prolog) by Peteris Krumins in 2010-05-17 at <http://www.catonmat.net/blog/on-functors/>
11:18:55 <jellostahps> to my understanding, concat is supposed to flatten a list of lists of the same type
11:19:10 <ski> (not the same meaning of "functor" as in those other languages)
11:19:18 <jellostahps> in my context, what would t need to be
11:19:32 <jsomedon> `data T a b = Mk {fst::a, snd::b}`, then I can pattern match a `T a b` value like `f (Mk {fst=1,snd="2"}) = print-fst-and-snd` or I can just access with `t = Mk {fst=1,snd="2"}; t fst`
11:19:59 <jsomedon> I think I got it, the record part
11:20:03 <ski> EvanR : there is a relation (is)/2, so you can state `X is 2 + 3', and that will relate `X' (a number) to the numeric expression (tree) `2 + 3', actually computing something, performing arithmeticc
11:20:30 <jellostahps> EvanR: ^
11:20:30 <ski> jellostahps : no idea where you're trying to use `concat' ..
11:20:54 <EvanR> jellostahps: what is your context again?
11:20:57 <ski> jellostahps : oh, missed "concat is supposed to flatten a list of lists of the same type" -- in that case, `t' is `[]', as i said
11:21:10 <ski> jsomedon : good
11:21:56 <jellostahps> concat in the context of flattening a list. I have this code, and I was told that prelude concat does the exact same thing : https://pastebin.com/RCFMZwuF
11:22:06 <EvanR> ski: um... and the result is X? as opposed to 5
11:22:29 <jellostahps> and looking at the type of concat, i cant discern how concat would do that
11:22:44 <ski> jsomedon : you can declare multiple data constructors, using record syntax for all (or even just some) of them .. however, i don't really recommend it, unless you do it for all data constructors, and mention exactly the same fields in each case. otherwise you'll get field extraction functions which will be partial (read "abort" / "crash and burn") on some inputs
11:22:58 <ski> EvanR : the result is the instantiation ("binding") `X = 5'
11:23:20 <EvanR> binding results in computation
11:24:04 <jellostahps> ski: ty
11:24:22 <ski> EvanR : in the Prolog interactor, you don't type in expressions (called "terms", since they don't compute). you type in logical formulae, involving relation/predicate calls. it's like typing in an equation (or equation system), and getting back out a solution (possibly involving multiple variables), or sometimes you get multiple alternative solutions (or no solution at all)
11:24:48 <ski> EvanR : no, "binding"/instantiation is the result of computation, in Prolog
11:24:50 <jellostahps> ski: u can apply Maybe to [a], but how can you apply [] to [a] using concat. [] is't a function is it?
11:25:00 <ski> EvanR : it's how you "output a return value"
11:25:06 <EvanR> oh
11:25:18 <ski> (since there are no (computational) functions in Prolog, there are no return values, either)
11:25:37 <EvanR> so a relationship involving a variable will result in a binding
11:26:00 <ski> jellostahps : i said "`[Blah]' is syntactic sugar for `[] Blah'" above, read that line including that, again ?
11:26:43 <ski> EvanR : yes (though it's usually called "instantiation" (or sometimes "constraint"))
11:27:33 <jsomedon> ski : so how did () types of those all possible length are defined? Surely no one is gonna define a (a) then (a,b) then (a,b,c) and so on, there is gonna be some clever trick to define those types right?
11:27:45 <ski> EvanR : there are three different aspects (a) introduction of a new variable, in a scope; (b) association of that variable with some value computation; (c) actually performing that computation
11:28:57 <Chin> I am new to haskell. I tried to understand typeclasses, but I am confused. Can anyone explain me in a simple way?
11:29:32 <ski> EvanR : in Haskell, (a) and (b) happens together, for definitions, (c) happens when things are forces. (but (a) and (b) are separated for function abstractions, `\x -> ..x..' binds `x', but `myFun (3^2)' will associate `x' to `3^2' in `..x..', if `myFun' refers to that function abstraction)
11:29:37 <ski> hello Chin
11:29:41 <jsomedon> Chin : to put it vaguely a bunch of related types? ski : I am also interested in this topic
11:30:42 <ski> EvanR : in Prolog, (a) is separated from (b) and (c) (which are the same thing, since there are no expressions, expressing non-trivial computations)
11:31:21 <jellostahps> ski: that is just syntactical sugar in prelude right, not in a .hs file?
11:31:53 <jellostahps> cuz [] [a] would be two parameters of an expression
11:31:59 <Chin> jsomedon So basically for Enum typeclasses, everything related to Enumeration is in the typeclass right?
11:32:42 <jellostahps> ^in a .hs file
11:32:58 <ski> EvanR : calling `append([0,1],[2],Xs)' will result in `Xs = [0,1,2]'. calling `append([0,1],Suffix,[0,1,2])' will result in `Suffix = [2]'. calling `append([1,0],Suffix,[0,1,2])' will result in `false'/"No" (no solution)
11:33:20 <jsomedon> Chin: as far as I know, yes, so
11:33:56 <ski> EvanR : calling `append(Pre,Suff,[0,1,2])' will result in `Pre = [],Suff = [0,1,2] ; Pre = [0],Suff = [1,2] ; Pre = [0,1],Suff = [2] ; Pre = [0,1,2],Suff = []' (four alternative solutions)
11:34:04 <Chin> jsomedon: cool make sense. Thanks
11:35:03 <ski> jsomedon : "so how did () types of those all possible length are defined?" -- they use syntactic sugar, and so are built-in to the language. the `data' definitions i showed however explains their behaviour
11:35:04 <jsomedon> Chin: Enumeration has some functions like f1 f2 and if a type T belongs to Enumeration class, then a value V of such type T should work for  functions f1 f2, so f1 V and f2 V should work
11:35:46 <ski> jellostahps : "that is just syntactical sugar in prelude right, not in a .hs file?","cuz [] [a] would be two parameters of an expression","^in a .hs file" -- you can write `[] Blah' yourself, just fine. not just in `Prelude'
11:35:51 <jsomedon> Chin: but I am sure someone else can give better explanations ( looking at ski
11:36:14 * ski stares at jsomedon
11:36:35 <Chin> jsomedon: I think I am in the right direction to understand it
11:36:52 <ski> Chin : for `Enum', the type class contains methods for "the most basic things to do with enumeration", out of which other enumeration-related things could be defined
11:37:06 <ski> Chin : consider instead `Eq' or `Ord'
11:37:11 <ski> @src Eq
11:37:12 <lambdabot> class Eq a where
11:37:12 <lambdabot>     (==), (/=) :: a -> a -> Bool
11:37:26 <ski> `Eq' is a type class for "types supporting equality (checking)"
11:37:38 <EvanR> i see
11:38:09 <ski> (not all types can meaningfully support that. especially not (in general) function types, and I/O actions)
11:38:36 <jsomedon> ðŸŽ¿ so you mean I cannot defien such types in clever way using just haskell?
11:38:49 <jsomedon> uh ski :
11:38:55 <ski> Chin : you might want to write a function that checks whether all elements of a list are distinct from each other. that is also an operation "relating to equality"
11:39:48 <ski> Chin : but you don't see it, as a method, of the `Eq' type class. it doesn't need to be in there. it can be defined in terms of the methods `(==)' (equality checking) and `(/=)' (disequality/apartness checking)
11:40:28 <ski> jsomedon : you can define `data Pair a b = MkPair a b' (or using record syntax, if you prefer). but you can't get the syntactic sugar, that way
11:40:57 <ski> Chin : exercise, define `allDistinct :: Eq a => [a] -> Bool'
11:43:05 <jsomedon> allDistinct [] = True
11:43:21 <jsomedon> allDistinct x:xs = ...
11:43:30 <jsomedon> doesn't look good
11:43:34 <ski> (missing brackets)
11:43:50 * ski thinks it looks like a good start
11:43:54 <EvanR> yeah you can define it recursively
11:43:57 <jsomedon> you mean (x:xs)?
11:44:03 * ski idly wonders whether Chin would like to try, though
11:44:04 <EvanR> you got the base case
11:44:09 <ski> yes, jsomedon
11:44:26 <ski> jsomedon : `allDistinct x:xs' means `(allDistinct x):xs', which is not what you intended
11:44:39 <jsomedon> ohh
11:45:00 <jsomedon> ha just tried in repl and right it throws error
11:45:00 <ski> jsomedon : function application can be thought of as an invisible infix operator that binds more tightly that all other (normal) infix operators
11:45:10 <jsomedon> oh ok
11:45:20 <jsomedon> the space operator I guess
11:45:44 <ski> (some special things like `@' still binds tighter than function application. `foo xs0@(x:xs) = ...' means `foo (xs0@(x:xs)) = ...', not `(foo xs0)@(x:xs) = ...')
11:46:20 <ski> jsomedon : i suppose, but in `length[0,1,2]' or in `(not)(False||True)' there's no spaces
11:46:37 <ski> so, the "juxtaposition operator"
11:47:23 <Chin> so does that mean allDistinct [1,2,3,3] = False?
11:47:35 <ski> yes
11:47:49 <Chin> And it checked the Eq class 
11:48:00 <Chin> Where 3 and 3 are not distinct
11:48:11 <ski> (btw, the functions `elem' and `notElem' might be useful. you could define one of them, yourself, if you want to)
11:48:26 <ski> @type elem
11:48:27 <lambdabot> (Foldable t, Eq a) => a -> t a -> Bool
11:48:33 <ski> bah !
11:48:37 <jsomedon> like check if a list contains a value
11:48:43 <ski>   elem :: a -> [a] -> Bool  -- imagine it has said this
11:48:56 <ski> (and ditto for `notElem')
11:49:16 <ski> (hm, i forgot to say the `Eq a => ', as in
11:49:29 <ski>   notElem :: Eq a => a -> [a] -> Bool
11:49:30 <ski> )
11:49:44 <jsomedon> my eye autocompleted that missing constraint
11:49:53 * ski grins
11:51:14 <jsomedon> so say I have that elem already, then it's: `aD x:xs = (notElem x xs) and (aD xs)
11:51:17 <jsomedon> `
11:52:09 <jsomedon> uh
11:52:27 <jsomedon> aD (x:xs) = (notElem x xs) and (aD xs)
11:52:40 <jsomedon> btw how to right logic operation?
11:52:44 <jsomedon> write
11:53:32 <ski> @type (&&)
11:53:33 <lambdabot> Bool -> Bool -> Bool
11:53:34 <ski> @type (||)
11:53:35 <lambdabot> Bool -> Bool -> Bool
11:53:38 <ski> @src (&&)
11:53:38 <lambdabot> True  && x = x
11:53:38 <lambdabot> False && _ = False
11:53:57 <ski> (can you imagine how `(||)' is defined ? `not' ?)
11:54:39 <ski> (neither of these are built-in to the language, no. they're just ordinary functions, defined in the library)
11:54:48 <ski> @type not
11:54:49 <lambdabot> Bool -> Bool
11:54:50 <jsomedon> || left right = if left True else right --- this?
11:55:14 <ski> try without `if' (it's not needed)
11:55:34 <ski> you can try defining `not', first
11:55:37 <jsomedon> ok
11:55:43 <jsomedon> then 
11:56:09 <jsomedon> not True = False; not False = True; -- this/
11:56:12 <jsomedon> ?
11:56:13 <ski> yes
11:56:24 <ski> and `(||)' ?
11:56:33 <jsomedon> || True _ = True ?
11:56:41 <jsomedon> || False right = right?
11:56:53 <ski> yes, apart from some trivial syntactic matters
11:56:57 <ski> you have to say
11:57:05 <jsomedon> (||)
11:57:05 <ski>   (||) True  _     = True
11:57:15 <ski>   (||) False right = right
11:57:21 <ski> or (imho, nicer)
11:57:27 <ski>   True  || _     =  True
11:57:32 <ski>   False || right = right
11:57:33 <jsomedon> ah
11:58:36 <ski> now, you can imagine `if'-`then`-`else' (special syntax), as being defined as
11:58:52 <ski>   if True then left else _     = left
11:59:04 <ski>   if False then _    else right = right
11:59:10 <ski> (dang !)
11:59:24 <jsomedon> you mean if if is a function
11:59:29 <jsomedon> is if a function in haskell
12:00:02 <ski> if `if ... then ... else ...' were mixfix syntactic sugar for a function, yes (which is how it behaves, anyway)
12:00:05 <jsomedon> actually is there anyway i can check if something is a function, other than typing :t value and guess from its type
12:00:55 <ski> however, actually, `if condition then consequent else alternate' is defined to mean `case condition of True -> consequent; False -> alternate' .. but it turns out to behave the same way as the hypothetical definition above
12:01:15 <ski> a function is a value whose type looks like `... -> ...'
12:01:43 <ski> so, either `:type' or `:info' (`:i' for short) would be how you check whether something is a function
12:01:52 <jsomedon> then does that imply that all the expressions are evaluated no matter the condition evalues to true or false?
12:02:20 <jsomedon> maybe my question is, in haskell, do all args get evaluatd before computation takes place?
12:02:32 <dmj`> jsomedon: no
12:02:35 <jsomedon> oh
12:02:38 <jsomedon> ok
12:02:38 <ski> (`:i' can also tell you fixity and precedence of infix operators, can tell you more about data constructors, can tell you about types, and also type classes. however, can only be used with identifiers, while `:type' can be used with arbitrary expressions)
12:03:00 <jsomedon> so I still can write if True some-safe-code else some-dangerous-code
12:03:04 <dmj`> jsomedon: evaluation occurs on an as-needed basis, if computation is defined, but never used, it never gets evaluated
12:03:09 <jsomedon> ok
12:03:35 <ski> > 1 > 2 || 1 `div` 0 < 10
12:03:36 <lambdabot>  *Exception: divide by zero
12:03:38 <ski> > 1 < 2 || 1 `div` 0 < 10
12:03:40 <lambdabot>  True
12:03:44 <jsomedon> I thought it's like how function works in other language
12:03:45 <ski> jsomedon : see ^
12:03:52 <jsomedon> ski ok
12:04:10 <dmj`> jsomedon: def thing (x,y): return x, if you did ... thing (10, calculateTrillionPiDigits()), then your python would actually evaluate it
12:04:23 <ski> jsomedon : in case left operand of `||' is `True', the right one is never computed. this follows from
12:04:26 <ski>   True  || _     = True
12:04:27 <dmj`> jsomedon: haskell is a little smarter
12:04:34 <ski> being the first defining equation of `(||)'
12:04:45 <jsomedon> dmj` I see
12:04:55 <slack1256> Is there any known "gotcha" to keep in mind when profiling a haskell program that uses the FFI (gi-gtk)?
12:05:34 <jsomedon> so haskell only evaluates them when it's necessary
12:05:41 <ski> (`/' is exact (or at least approximate) division of numbers. `div' is integral division, where you get a remainder/modulus)
12:06:02 <ski> yes, jsomedon, that's what implementations usually do
12:06:22 <ski> (an implementation is allowed to evaluate more, if it wants to, as long as the behaviour of the program is still the same)
12:07:41 <ski> (e.g., an implementation is allowed to try computing something on an idle core, that it thinks might be needed soon, as long as it makes sure that it timeouts eventually (in case of infinite loops), and makes sure any exception/partiality/abort is trapped and ignored (well, cached, actually))
12:08:04 <jsomedon> oh btw, about that notElem function:    notElem elem list = list.filter(/x->x!=elem).length != 0 // mixed soem js and haskell lol
12:08:12 <dmj`> slack1256: if you're malloc'ing in the C code, haskell profiling won't report it
12:08:23 <ski> (the language doesn't specify in which order things should be evaluated. it only talks about what the answer (if any) should be)
12:09:13 <slack1256> dmj`: !!! That's good to know!
12:09:15 <jsomedon> > :t filter
12:09:17 <lambdabot>  <hint>:1:1: error: parse error on input â€˜:â€™
12:09:26 <jsomedon> huh?
12:09:28 <ski> jsomedon : that approach would work, yea (but then begs the question of how `filter',`length' are defined)
12:09:33 <ski> @type filter
12:09:34 <lambdabot> (a -> Bool) -> [a] -> [a]
12:09:38 <ski> is how you do it, with lambdabot
12:09:42 <jsomedon> ah
12:09:51 <nopenope> @type const
12:09:53 <lambdabot> a -> b -> a
12:10:02 <nopenope> @type id
12:10:03 <lambdabot> a -> a
12:10:03 <ski> (lambdabot doesn't behave exactly the same as the interactor)
12:10:11 <ski> % :t filter
12:10:11 <yahb> ski: (a -> Bool) -> [a] -> [a]
12:10:18 <ski> yahb behaves more like lambdabot
12:10:25 <jsomedon> oh
12:10:28 <nopenope> % :t const
12:10:28 <yahb> nopenope: a -> b -> a
12:10:32 <nopenope> % :t id
12:10:32 <yahb> nopenope: a -> a
12:10:34 <dmj`> slack1256: probably best to do all the malloc'ing in Haskell, so it will show up as PINNED
12:10:41 <nopenope> % :i id
12:10:41 <yahb> nopenope: id :: a -> a -- Defined in `GHC.Base'
12:11:00 <dmj`> slack1256: that's what all the ByteString stuff shows up as
12:11:23 <ski> jsomedon : you can define `elem',`notElem', directly on lists, without calling out to other operations on lists .. it's not that hard
12:12:18 <jsomedon> elem e [] = False
12:13:02 <jsomedon> elem e (x:xs) = (x == e) || (elem e xs)
12:13:04 <jsomedon> ?
12:13:26 <jsomedon> and notElem would be negation of elem
12:13:59 <nshepperd> ifThenElse is a function if you use -XRebindableSyntax
12:14:55 <geekosaur> :t bool
12:14:56 <lambdabot> a -> a -> Bool -> a
12:15:08 <jsomedon> huh
12:15:11 <jsomedon> :t bool
12:15:12 <lambdabot> a -> a -> Bool -> a
12:15:22 <jsomedon> so I dont need > or %
12:15:42 <nshepperd> then 'if b then x else y' is syntactic sugar for 'ifThenElse b x y'
12:15:49 <geekosaur> only for :t and :k
12:16:00 <jsomedon> oh good to know
12:26:48 <dmj`> slack1256: use alloca, it's good
12:28:30 * hackage hw-prim 0.6.2.33 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.6.2.33 (haskellworks)
12:33:05 <jsomedon> so `newtype` and `data` works differently? it's not like newtype expression is syntatic sugar of data expression?
12:33:58 <ski> jsomedon : ues, that `elem' definition looks fine (though you csn say `x == e || elem e xs')
12:34:04 <ski> you can even define it as
12:34:13 <ski>   e `elem` [    ] = False
12:34:28 <ski>   e `elem` (x:xs) = x == e
12:34:39 <ski>                  || e `elem` xs
12:34:49 <jsomedon> ah
12:35:11 <ski> oh, even
12:35:17 <ski>   e `elem` [  ] = False
12:35:23 <ski>   e `elem` x:xs = x == e
12:35:25 <ski>                || e `elem` xs
12:35:40 <ski> at least if you declare
12:35:42 <ski>   infix 4 `elem`
12:35:56 <jsomedon> oh so () isnt necessary then
12:35:58 <ski> as precedence and (non-)fixity for this infix operator
12:36:07 <ski> well, because `:' is
12:36:13 <ski>   infixr 5 :
12:36:25 <ski> so  :  binds tighter than  `elem`
12:36:50 <ski> since `5' is a higher precedence level (meaning binds tighter) than `4'
12:37:37 <ski> (if you use `:info :' and `:info elem', it should tell you the fixity and precedence)
12:38:24 <jsomedon> oh
12:58:51 <quiet_laika[m]> if i have `data Name = Name String`, is there a difference between 
12:59:27 <quiet_laika[m]> an instance with `fromString = Name` vs `fromString = Name . fromString`?
13:00:24 <quiet_laika[m]>  * an `instance IsString Name` with `fromString = Name` vs `fromString = Name . fromString`?
13:04:36 <nil> the latter is the same as `Name . id` (which is the same as `Name`), since you're using the trivial IsString String instance
13:05:52 <quiet_laika[m]> that makes sense!
13:06:02 <quiet_laika[m]> i love when things make sense
13:29:00 * hackage aeson-optics 1.1.0.1 - Law-abiding optics for aeson  https://hackage.haskell.org/package/aeson-optics-1.1.0.1 (phadej)
13:49:18 <nopenope> when should I use an applicative instead of a monad?
13:50:09 <nopenope> can I write any program using only applicatives?
13:55:17 <jle`> nopenope: there are a couple of layers to interpret that question as
13:55:39 <jle`> nopenope: typically the types you use will have the instances, and you will program to those types
13:55:42 <ski> nopenope : idioms afford only "static sequencing", while monads allow also "dynamic sequencing". in the latter, you can make run-time decisions about "what to do next", depending on intermediate run-time results. in the former, the "structure" of the actions to perform is "fixed" so to speak (even if it can still involve trying multiple alternatives)
13:55:59 <jle`> nopenope: for example, it doesn't make sense to write a program "using only Applicatives", because all Haskell programs have to have type IO
13:56:32 <jle`> so the best you could do is something like `main = pure main`, which technically typechecks
13:56:44 <jle`> if we're asking "can you write a program using only functions from the Applicative typeclass"
13:57:06 <jle`> note that this question isn't much better with "can you write a program using only functions from the Monad typeclass" either -- you can do `main = return main`, which is similarly useless
13:57:13 <ski> nopenope : <https://en.wikipedia.org/wiki/Principle_of_Least_Power> can apply. if some operation (like `sequence',`mapM') doesn't need the full power of monads, then it's usually better to only require the lesser power, only what's needed
13:57:58 * ski thinks `main = pure main' is a strange recursive program
13:58:14 <jle`> nopenope: so one way to answer "when should I use an applicative instead of a monad?" is the same as asking "when should i use a [a] instead of a String?
13:58:30 <jle`> er hm, maybe it's more like "when should i use a String instead of an Int?"
13:58:41 <jle`> it's on that level --- you don't care if the type is Applicative or Monad
13:58:46 <jle`> you only care about what you can do with that type
13:59:31 <jle`> so "when should an Applicative instead of a Monad?" is basically "it doesn't matter because it only usually matters the specific type you use, and not Applicative vs. Monad"
14:00:11 <jle`> hm, maybe the relevant analogy is "when should i use a tool something that comes in a red box, vs. a tool that comes in a blue box?"
14:00:18 <jle`> it's not the color of the box that you care about, it's the tool you want to use
14:01:03 <jle`> the utility of a list doesn't come from the fact that it's an Applicative or Monad instance, but rather because of the things you can do with lists.
14:09:19 <dsal> Use the tools that come in a red box when you're at a pay phone, and the tools in the blue box when you're at your friend's house.
14:10:30 * hackage HsYAML-aeson 0.2.0.0 - JSON to YAML Adapter  https://hackage.haskell.org/package/HsYAML-aeson-0.2.0.0 (HerbertValerioRiedel)
14:11:17 <jle`> there's another layer to interpret this question at: If you're writing polymorphic functions that work for *all* Applicatives, or for *all* Monads, then it can be useful to write a function myFunc :: Applicative f => .., vs. myFunc :: Monad m => ..., if possible. this means that it can work for more types. the second one would for for less types than the first one.
14:15:13 <ski> yes
14:17:07 <ski> (sometimes the specific type you use may be `forall i. Applicative i => ..i..' .. as in `foo :: (forall i. Applicative i => ..i..) -> ...')
15:41:21 <iqubic> ski: Are you still around?
15:47:20 <iqubic> Is anyone here?
15:48:38 <Clint> no
15:50:19 <ski> iqubic is here
15:54:07 <iqubic> I have no idea what (>>=) does for the expr data type.
15:54:45 <iqubic> http://dpaste.com/26VRTRJ
15:55:05 <iqubic> I have no idea what the monad instance of Expr is doing.
15:56:49 <jle`> iqubic: what do you think  join :: Expr (Expr a) -> Expr a does
15:57:23 <jle`> hint, look at the only time 'a' shoes up as a field in Expr
15:57:27 <iqubic> I don't know.
15:57:38 <iqubic> 'a' is the type of the variable.
15:57:44 <jle`> i mean, in the constructors
15:57:48 <jle`> which constructors have 'a' in it
15:58:27 <iqubic> Var does.
15:58:37 <iqubic> As well as Add and Mul.
15:58:52 <jle`> i don't think Add or Mul have it
15:58:54 <jle`> it just has (Expr a)
15:58:57 <ski> iqubic : code looks fine
15:58:57 <iqubic> But really Add and Mul have 'Expr a' and not a
15:58:57 <d34df00d> Hi!
15:59:06 <iqubic> So it's just Var that has 'a'
15:59:06 <jle`> so if 'a' was Int, only Var would have an Int in it
15:59:07 <ski> (although i don't like `$' there, of course)
15:59:40 <jle`> iqubic: so what do you think an Expr (Expr a) -> Expr a would do?
16:00:23 <ski> <ski> (you could also write a (useful) function of type `(var -> Expr var) -> Expr var -> Expr otherVar', and contemplate its definition, e.g. in terms of `do')
16:00:26 <ski> <iqubic> Remember that only the leaves have data here.
16:00:31 <ski> * ski isn't sure whether iqubic, by "data" is referring to the `var' parts, or to the `Integer' parts, or perhaps (not likely) to the data constructor parts
16:01:01 <iqubic> ski: I was refering to the Var constructor when I said 'Only the leaves have data'
16:01:19 <iqubic> jle`: Expr (Expr a) is like a higher order function.
16:01:24 <d34df00d> Suppose I have `data ConfigItem = ConfigItem { name :: String, typ :: ConfigType }` â€” a record describing some external tool's configuration item that only gets really known at runtime, where `data ConfigType = CTInt |  CTUnsigned  | CTBool` for simplicity.
16:01:41 * ski thinks `(>>=)' is probably simpler to contemplate, for `Expr', than `join'
16:01:52 <d34df00d> Suppose I now want to write a config generator for that tool, so it feels natural to reuse `ConfigItem` for this purpose.
16:02:22 <jle`> hm, maybe it's a different perspective kind of thing, but join feels a lot more self-evident to me personally
16:02:38 <d34df00d> Is it the right thing to parametrize ConfigItem and ConfigType with a dummy tag `f :: ConfigItemType` where `ConfigItemType = Info | Instance`, and turn `ConfigType` into `data ConfigType f = CTInt (CTData f Int) | CTUnsigned (CTData f Natural) | CTBool (CTData f Bool)`, where `CTData` is the corresponding type family?
16:02:38 <jle`> it's just flattening out the Expr
16:02:58 <ski> it's easy to see what it *does*, but not what it's *good* for, in terms of what `Expr' would tend to be used for
16:03:07 <iqubic> jle`: That's correct.
16:03:15 <jle`> ðŸŽ¿ that's a good point 
16:03:15 <iqubic> It flattens an expression.
16:03:25 <d34df00d> And basically CTData Info _ = (), CTData Instance ty =  ty
16:03:27 <ski> jle` : .. not you too
16:03:41 <iqubic> jle`: What is going on there?
16:03:49 <jle`> i think i'm the only one who emojis here
16:03:53 <iqubic> No.
16:03:57 <ski> (having a "variable type" where "variabble identifiers" are actually whole expressions, doesn't feel that natural ..)
16:04:12 <iqubic> We had someone earlier who was doing that same thing, with that same emoji.
16:04:33 <jle`> ah. yeah i installed a plugin in my client that auto-replaces emoji codes with the eomjis
16:04:51 * d34df00d happy there's no emoji for dead food.
16:04:54 <jle`> d34df00d: what is a config generator?
16:05:10 <MarcelineVQ> d34df00d: what does form allow you to do more easily?
16:05:25 <ski> jle`,iqubic : namely jsomedon, see five and a half hour ago
16:05:29 <iqubic> ski: What does (>>=) do for Expr?
16:05:35 <iqubic> ski: I know. I know that.
16:05:50 <ski> (i mainly mentioned that for jle`)
16:06:00 <iqubic> I feel like the term free variable is applicable here.
16:06:14 <d34df00d> jle`: I basically want to generate configs for clang-format, but I don't know the list of options a particular version supports, so I'm parsing the HTML page with the options descriptions into [ConfigItem] and then I'll generate config files based on those descriptions. Hope that somewhat clarifies what I'm trying to do.
16:06:14 * ski is not an emoji ! :(
16:06:17 <jle`> so many questions here that seem to make 'oh i'll just use atype family' feels funny, heh
16:06:34 <jle`> in a 'that escalated quickly' kind of way
16:06:36 <d34df00d> MarcelineVQ: reduce duplication. I'm really not into having a mirror (but richer) data type for configuration variables instances.
16:06:49 <d34df00d> MarcelineVQ: but, of course, that's mainly to show myself off.
16:07:01 <ski> (if i had my way, they'd be eradicated from unicode, and, preferably, from the face of the earth ..)
16:07:21 <iqubic> ski: Does (>>=) for Expr have anything at all to do with free variables?
16:07:22 <jle`> iqubic: try thinking of a fixed instanation of Expr, like `Expr String`, a type where the variables are string identifiers
16:07:26 <ski> iqubic : yes
16:07:39 <jle`> then you can think of what (>>=) does fro that type
16:07:55 <jle`> (>>=) :: Expr String -> (String -> Expr String) -> Expr String
16:08:13 <jle`> or erm (>>=) :: Expr' -> (String -> Expr') -> Expr'
16:08:23 <jle`> where  type Expr' = Expr' String
16:08:31 <iqubic> Right. Well, I don't know what (>>=) does there. Can you just ell me?
16:08:43 <jle`> try to think about what such a functio would do
16:08:49 <ski> iqubic : also consider the first message of mine that i quoted above
16:08:49 <jle`> Expr' -> (String -> Expr') -> Expr'
16:09:09 <jle`> the point was to make it clearer what such a function would do, by using this statement of the type
16:09:24 <jle`> if Expr' is an expression with string variable names, what would a function like (String -> Expr') be?
16:09:30 <jle`> Expr' -> (VariableName -> Expr') -> Expr'
16:09:31 <iqubic> Wait... It's alpha conversion.
16:09:33 <iqubic> I see.
16:09:38 <jle`> not an alpha conversion
16:09:43 <iqubic> I think it's alpha conversion.
16:09:49 <iqubic> https://wiki.haskell.org/Alpha_conversion
16:09:50 <jle`> alpha conversion would be (VariableName -> VariableName)
16:09:57 <ski> <iqubic> I have no idea what (>>=) does for this monad.  <ski> iqubic : right, that's part of the fun of it, figuring that out :)
16:10:00 <jle`> you would transform the variable names
16:10:23 <iqubic> Oh, wait... It's similar to a let statement.
16:10:40 <jle`> hm, answer at least: what would a (VariableName -> Expr') function do?
16:10:44 <ski> (alpha-conversion also applies to bound variables, not free ones. at least in usual formulations)
16:11:38 <iqubic> It would replace a free variable with an Expr it is bound to.
16:11:52 <ski> now we're getting somewhere :)
16:12:01 <ski> replace which free variable ?
16:12:03 <iqubic> let a = 1 in 1 + a
16:12:06 <jle`> so, what do you think Expr' -> (VariableName -> Expr') -> Expr' would do?
16:12:08 <iqubic> ski: All of them.
16:12:11 <ski> yes !
16:12:19 <iqubic> It would replace all the free variables.
16:12:32 <jle`> with what?
16:12:39 <iqubic> VariableName -> Expr' is like a look up table.
16:12:44 <ski> yes
16:13:02 <jle`> yeah, it would replace all of the Var's with the resulting Expr' from the (VariableName -> Expr') function
16:13:07 <ski> aka "(expression) environment"
16:13:09 <iqubic> jle`: It would replace each free variable with the value returned from the "VariableName -> Expr"
16:13:21 <ski> so, what is `(>>=)', then, in a word ?
16:13:40 <iqubic> Free variable substitution.
16:13:45 <ski> correct :)
16:13:50 <ski> now, how about
16:13:51 <ski> <ski> (you could also write a (useful) function of type `(var -> Expr var) -> Expr var -> Expr otherVar', and contemplate its definition, e.g. in terms of `do')
16:13:54 <ski> ?
16:14:24 <iqubic> I'm not sure what that function is supposed to do?
16:14:34 <ski> ("Free variable substitution", or "substitution" for short)
16:14:45 <ski> well, it can only really do one sensible thing ..
16:14:52 <iqubic> But isn't that already covered by (>>=)?
16:15:10 <ski> the type differs from that of `(=<<)'
16:15:13 <ski> (how does it differ ?)
16:15:35 <jle`> maybe change Expr otherVar with Expr Void
16:15:53 <iqubic> Expr Void?
16:15:55 <ski> that would also work (since `Expr' is a functor. you can Yoneda stuff)
16:15:55 <jle`> or did i give away too much
16:16:35 <iqubic> Wait... Than this is function application, using the "(var -> Expr var)" as a lookup table for free vars.
16:16:53 <ski> how does it differ from `(=<<)' ?
16:17:11 <ski> (and what do you mean by "this is function application" ?)
16:17:19 <iqubic> I'm not sure.
16:17:26 <iqubic> I'm so confused right now.
16:17:39 <ski> what is the corresponding type of `(=<<)' (for `Expr') ?
16:18:03 <iqubic> (a -> Expr b) -> Expr a -> Expr b
16:18:32 * _deepfire wishes GHC was more helpful when erring with infinite type accusations..
16:18:53 <iqubic> but we have: (a -> Expr a) -> Expr a -> Expr b
16:18:57 <ski> what if you alpha-convert, to make it more comparable to the type i gave ?
16:19:00 <ski> yea
16:19:05 <ski> so, the difference, is ?
16:19:38 <iqubic> (=<<) :: (var -> Expr otherVar) -> Expr var -> Expr otherVar
16:19:44 <ski> yep
16:19:58 <ski>   frobnicate :: (var -> Expr var) -> Expr var -> Expr otherVar
16:20:05 <iqubic> mysteryFunction :: (var -> Expr var) -> Expr var -> Expr otherVar
16:20:06 <ski> can you define `frobnicate' ?
16:20:17 <iqubic> why is it called frobnicate?
16:20:21 <ski> why not ?
16:20:31 <d34df00d> Speaking of Expr Void, ghc 8.8 will not warn me on not pattern-matching on an alternative having a Void field will it?
16:20:52 <jle`> d34df00d: only for strict fields
16:20:56 <iqubic> I can define it, but first I have attend a family dinner.
16:21:00 * ski . o O ( <http://catb.org/jargon/html/F/frobnicate.html> )
16:21:04 <iqubic> Be back later. Sorry.
16:21:04 <d34df00d> Well, sure.
16:21:08 <d34df00d> Thanks!
16:21:14 <ski> iqubic : sure, take your time :)
16:21:15 <jle`> so for the data type in question, it isn't the case
16:21:19 <ski> iqubic : and have fun !
16:21:19 <jle`> (defined in the paste)
16:21:23 <d34df00d> In this case... stack lts with ghc 8.8 when?
16:21:39 <zfnmxt> Can anyone recommend a nice interactive cli library to build a simple cli app? 
16:21:51 <d34df00d> jle`: I'm playing around with my own stuff in the meanwhile and I decided to mark unsupported config option types that I cannot know how to handle with Void.
16:22:20 <jle`> d34df00d: yeah, for now (and for lazy fields) you'll have to be happy with absurd or emptycase
16:22:30 * hackage pg-transact 0.2.1.0 - Another postgresql-simple transaction monad  https://hackage.haskell.org/package/pg-transact-0.2.1.0 (JonathanFischoff)
16:22:32 <jle`> zfnmxt: CLI as in graphical, or just like text inputs?
16:23:11 <zfnmxt> jle`: Just simple text inputs.
16:23:28 <jle`> so, more like useradd than htop
16:23:35 <zfnmxt> Exactly.
16:23:58 <jle`> i'm not sure how much exactly you'd want a library to handle, but you can use haskeline to get a nice readline environment for users to enter text
16:24:00 <jle`> and ask for passwords, etc.
16:24:12 <zfnmxt> I want to do as little as possible :^)
16:24:44 <jle`> for most of my interactive cli stuff that isn't graphical just i use haskeline for the most part
16:24:52 <zfnmxt> I saw Haskeline, though. Just a bunch of options on Hackage, so hard to choose =/
16:24:53 <jle`> do you want to delete? [y]/n
16:25:01 <jle`> enter password:
16:25:05 <jle`> etc.
16:25:20 <jle`> haskeline is the main one for user input, and an advantage is that it comes with ghc in a way
16:25:41 <zfnmxt> What about structured-cli?
16:25:45 <jle`> it's the one that ghc uses for everything, so you have a trusted vouch-ee
16:26:11 <jle`> oh you want something to actually do all of the menu and stuff for you, as well maybe
16:26:19 <jle`> haskeline won't do that, it just handles the input parts
16:26:29 <zfnmxt> Yeah, I know. I'm trying to be lazy here :D
16:27:22 <jle`> hm...yeah, i've never done anything too deep in this that uses a library. structured-cli seems 'fine', but i do'nt think that there is any sort of community consensus on a best one because i don't think it's an issue that most of the community spends too much time on
16:27:34 <jle`> so, follow your gut :)
16:28:23 <zfnmxt> Yeah, makes sense. I'll try structured-cli for now.
16:31:51 <jsomedon> back from breakfast, looks like we need some emoji?
16:32:02 <jsomedon> ðŸŽ¿
16:32:11 <jsomedon> ðŸŽ¿
16:36:15 <pavonia> Are parser combinators just a specific, continuation-based implementation of backtracking LL parsers?
16:38:14 <jle`> hm, i don't think parser combinators are necessarily continuation-based
16:38:20 <heatsink> By LL parsers, people generally mean parsers for a context-free grammar.  Parser combinators allow context-sensitive parsing.
16:38:42 <jle`> to me the only thing that defines parser combinators is the fact that parsers are first-class values
16:38:47 <jle`> so they cna be defunctionalized too
16:42:17 <_deepfire> I'm still sad GHC dropped implication from instance resolution rules..
16:43:04 <ski> @hackage parsek
16:43:04 <lambdabot> http://hackage.haskell.org/package/parsek
16:44:00 <heatsink> Not parsec?
16:44:08 <ski> that's something else
16:44:17 <ski> _deepfire ?
16:45:44 <pavonia> Hhm, I still have problems with finding a non-continuation-based eqivalent of parser combinators
16:46:48 <pavonia> Or non-first-class-object-based
16:47:13 <pavonia> *first-class-function-based
16:47:39 <_deepfire> ski, consider Generics.SOP.And, which is class (f x, g x) => (f `And` g) x
16:49:46 <pavonia> The closest I came across are PEGs, which are usually implemented as in a recursive decent manner with a backtracking stack
16:54:02 <ski> _deepfire : and implication ?
17:06:00 <jle`> pavonia: you can rig one up with the Free Alternative
17:06:12 <jle`> if you have data Prim a = Prim Char a
17:06:21 <jle`> then Parser = Ap Prim
17:06:49 <jle`> you get parser combinators without choice
17:06:59 <jle`> and if you upgrade to free Alterantive, Parser = Alt Prim, you get parser combinators with choice and sequencing
17:11:45 <pavonia> jle`: What are free Alternatives?
17:12:19 <jle`> er, just thinking of it as enahancing Prim to support <|>/empty/<*>/pure
17:12:27 <jle`> the basic skeletal structure
17:13:26 <pavonia> Okay, one step back. What is Ap? :p
17:13:29 <jle`> just wrapping Prim in a list of lists basically
17:13:41 <jle`> pavonia: Ap is a way to just give Prim support for <*>/pure
17:14:09 <jle`> it's somewhat similar to [Prim a], where each item is the "next primitiave to parse"
17:14:43 <jle`> in any case my point is that we just have a list of lists of Prim
17:14:53 <jle`> and you can implement all oft he parser API with them
17:14:59 <jle`> they are'nt continuations, but rather just normal data types
17:16:34 <pavonia> So Prim a is a token of type a?
17:16:49 <pavonia> or result type a
17:17:21 <jle`> a token of result type 'a', a single Char
17:17:38 <jle`> hm, if you're unfamiliar with the free construction, we can do it 'by hand' too
17:18:30 <pavonia> I'm confused about how a parser can be described as lists of input chars
17:18:40 <jle`> data Parser a = Satisfies (Char -> Maybe a) | forall b. Seq (Parser b) (Parser (b -> a) | Choice (Parser a) (Parser a)
17:19:58 <jle`> although maybe you could consider b -> a the continuation there
17:21:45 <jle`> whoops :|
17:21:52 <pavonia> I see, so you just lift the combinator primitives to values here
17:22:19 <jle`> yeah. free ap/alt were just wrapping the extra Seq/Choice combinators for us but we can just inline them too
17:22:43 <jle`> but i suppose you can't escape something like a (b -> a) continuation without complete defunctionalization
17:23:13 <jle`> hm, i'm not sure i would qualify this as a continuation, becuase it doesn't continue a new *parser*
17:23:19 <jle`> it's just a pure mapping on the result of a parser that is already run
17:25:22 <pavonia> Thinking about it, that closely corresponds to the PEG implementation mentioned earlier, which maps the grammar to a series of "virtual machine" commands to be executed in conjunction with a backtracking stack
17:25:57 <jle`> ah, that does sound similar too actually
17:26:16 <jle`> well, one thing here is that this can't encode context-sensitive parsers, so it doesn't have the full rnage of monadic parser combinators
17:26:47 <jle`> but you could do it by adding an extra | Closure (Parser a) constructor
17:27:46 <pavonia> What would that represent?
17:28:18 <jle`> context sensitivity, the ability to return a parser based on another parser
17:28:30 <jle`> er, a parser based on the result of a previous parse
17:28:42 <jle`> hm, maybe i meant CLosure (Parser (Prser a))
17:29:33 <jle`> yeah that sounds right. Closure :: Parser (Parser a) -> Parser a 
17:30:28 <pavonia> I think that's equivalent to "jump" in a list of those VM commands
17:32:05 <jle`> ah the whole thing is also missing a `| NoConsume a` branch that consumes nothing and returns a
17:32:06 <pavonia> hhm, that doesn't depend on the result of the previously parsed token, though
17:32:49 <jle`> i'm just talking about the implementation details; you'll have problems implementing it without that component
17:33:43 <jle`> with that...you should be able to write Functor/Applicative/Alternative/Monad/MonadPlus instances...which satisfy the laws under some quotient
17:33:57 <pavonia> Yeah
17:34:12 <pavonia> Can a parser combinator without a Monad instance also parse anything that's not context-free?
17:34:50 <jle`> parser combinators w/o Monad are similar to regular languages
17:35:48 <jle`> if you implement them correctly you can even compile them to ndfa's
17:36:35 <pavonia> And adding Monad gives you more than context-free?
17:36:43 <jle`> it allows you to be context-sensitive
17:38:31 <pavonia> That's interesting. You can also implement (at least some) context-sensitive laguages using PEGs, so there actually seems be a relationship
17:39:24 <pavonia> Thanks for the input so far
17:40:16 <jle`> no problem :) it sometimes can feel too easy that these categories can corespond cleanly with the typeclasses in haskell. sometimes it's interesting to draw the links, but in practice (with recursion and laziness) the correspondence becomes a little muddled too
17:41:46 <heatsink> In ANTLR4, you can do context-sensitive parsing by writing backtracking decision code outside of the grammar
17:42:30 * hackage net-spider-rpl 0.2.2.0 - NetSpider data model and utility for RPL networks  https://hackage.haskell.org/package/net-spider-rpl-0.2.2.0 (debugito)
17:43:21 <heatsink> You can think of that approach as a context-free ambiguous grammar plus arbitrary code for rejecting potential parses
17:47:26 <pavonia> Parser combinators can't be ambiguous, because ambiguties are resolved by the ordering of choices, right?
17:47:46 <sshine> pavonia, non-deterministic parser combinators can be.
17:48:17 <sshine> pavonia, e.g. ReadP.
17:48:21 <pavonia> Those return all possible results?
17:48:25 <sshine> yes.
17:49:30 * hackage net-spider-rpl-cli 0.1.1.0 - CLI executable of NetSpider.RPL.  https://hackage.haskell.org/package/net-spider-rpl-cli-0.1.1.0 (debugito)
17:51:57 <nyc> Hmm. If I wanted n digits of, say, J_0(2) or bigGamma((3/5)+(4/5)*i), which package would I go to to get it?
18:06:30 * hackage bioinformatics-toolkit 0.9.0 - A collection of bioinformatics tools  https://hackage.haskell.org/package/bioinformatics-toolkit-0.9.0 (kaizhang)
18:11:45 <monochrom> nyc: Perhaps http://hackage.haskell.org/packages/search?terms=gamma helps?
18:12:44 <jusss> about eta-expand, I have a little confused  https://paste.ubuntu.com/p/939wT9QFKT/
18:13:09 <jusss> this line \f xss -> map (\xs -> map f xs) xss   , I don't understand
18:14:16 <nyc> I'm just fishing through the multiple precision and arbitrary precision packages and seeing what functions they've got.
18:14:27 <jusss> \f -> g f  will equl to \f x -> (g f) x ?
18:14:34 <monochrom> foo = \xss -> foo xss, if you are sure foo is a function.  Now use "map (blah blah)" for foo.
18:15:11 <jusss> monochrom: I understand this f = \x -> f x
18:15:44 <jusss> monochrom: in the post, "eta expand outer 'map' call" is what I dont understand
18:15:45 <monochrom> So use "map (blah blah)" for f.
18:15:55 <nyc> Various things seem to not have implementations of special functions that capture the full precisions of the types the results they're returning their results in.
18:18:10 <EvanR> (blah blah) = ((blah blah) (blah blah)) = ...
18:18:21 <monochrom> haha
18:18:47 <monochrom> Use "map (\xs -> map f xs)" for my foo.
18:19:37 <jusss> oh, wait a sec, 
18:19:57 <jusss> \f -> map (\xs -> map f xs)
18:20:24 <jusss> \f -> (\xss -> map (\xs -> map f xs) \xss)
18:20:32 <monochrom> Yes, like that.
18:21:08 <jusss> \f xss -> map (\xs -> map f xs) \xss
18:21:57 <jusss> monochrom: and they always say something about variable is free or something about this, what it is?
19:37:30 * hackage streamly-cassava 0.1.0.0 - CSV streaming support via cassava for the streamly ecosystem  https://hackage.haskell.org/package/streamly-cassava-0.1.0.0 (rwarfield)
19:38:35 <novum> ðŸŽ¿ testing
19:39:45 <novum> heatsink, huh. re: earlier. it's a weechat plugin called emoji.lua that converts things like : ski : without the spaces to unicode symbols, and because IRC syntax is like  PRIVMSG #haskell :the message  the initial colon is used in the conversion
19:40:16 <novum> I left right after you asked  <heatsink> jsomedon, is your irc client autocorrecting "ski:" to ðŸŽ¿? 
19:41:25 <Axman6> ... that doesn't seem like a very well written plugin
19:41:42 <Axman6> novum: how'd you go with beginning your Monad journey?
19:41:46 <novum> agreed but it's pretty decent despite the short coming
19:42:15 <novum> Axman6, I realized that I had written monad-esque stuff whilst creating an irc bot in python 2-3 years ago. Then I got busy with school.
19:43:22 <novum> I am no expert in monads, but I feel like I have a quazi-grasp of them. thanks for asking. I have been doing th ercism.io things when I get the chance, and I figured out how to operate stack effectively, and how modules and testing works with Spec.Testing or whatever. So, I am happy about that.
19:43:34 <novum> exercism.io exercises *
19:43:58 <Axman6> great
19:44:23 <novum> in off-topic news, I rediscovered graphviz's dot, and it has been very helpful in creating entity-relationship models for a dbms class.
19:45:18 <novum> and also, I have been using pandoc, which I believe was written mostly using haskell, which I find to be rather impressive.
19:47:16 <novum> Axman6, how are your passions and studies coming along?
19:48:22 <Axman6> They stop becoming both when they're your job =)
19:50:15 <heatsink> novum: Thanks for the explanation
19:51:14 <heatsink> Do you get paid to use haskell, Axman6?
19:52:27 <mouse008[m]> A stack/cabal question. My global config for either of them (e.g., `~/.stack/config.yaml`) tells the tool to use dynamic linking, because that's what I need/want in general. I do it via adding `-dynamic` to the `ghc-options:` for Stack, and `shared` etc. for Cabal. It works fine. 
19:52:28 <mouse008[m]> However, there are some packages (like `Haskell-ide-engine`) that apparently cannot be built with dynamic linking. 
19:52:29 <mouse008[m]> My question is: how do I override those globally set options for individual projects/packages? And if a project pulls a ton of dependencies from Hackage and/or Stackage - would the options I set in the "main" project override what's on those dependent packages, or not? If not - how can I force the downloaded dependencies to abide by the options I need?
19:52:53 <Axman6> heatsink: yes
19:53:06 <heatsink> cool.  May I ask where?
19:53:14 <dmj`> haskell gets paid to use me
19:53:18 <Axman6> seek.com.au
19:53:51 <dmj`> Axman6: you guys use haskell on the front end?
19:54:19 <koz_> dmj`: Are you in Soviet Russia?
19:54:35 <jusss> I heard that ANU use hasekll to teach people as the first programming language
19:54:40 <Axman6> no
19:54:42 <dmj`> koz_: Ð´Ð¾ ÐºÐ¾Ð½ÐµÑ‡Ð½Ð¾ 
19:54:51 <Axman6> jusss: I used to be a tutor for that course
19:55:17 <Axman6> They've been using Haskell since before I was a student 10 years ago (it's where I learn Haskell)
19:55:20 <jusss> Axman6: there must be lots of complains, rightï¼Ÿ
19:55:20 <dmj`> koz_: Ñ‚Ð¾Ð²Ð°Ñ€Ð¸Ñˆ ?
19:56:19 <EvanR> I tutored computer science where the first language was C. There were a lot of complaints
19:57:51 <dmj`> I've never known a computer scientist not to complain
19:58:21 <Axman6> I find that offensive, where may I register my complaint
19:58:34 <EvanR> here /dev/null
19:59:10 <heatsink> First you must solve a captcha.  It's a random problem from project euler
20:01:09 <monochrom> I have a cunning plan. First you must find a security vulnerability in the device driver behind /dev/null and use it to gain root access. >:)
20:04:02 <jusss> is that y combinator is important to programming?
20:04:41 <jusss> I never know what is a combinator 
20:07:38 <rotaerk> jusss, https://wiki.haskell.org/Combinator
20:16:56 <koz_> dmj`: Nearly on both. :P
20:20:46 <rowannas> Hello, if you don't mind I have one question about monads in terms of category theory (i.e. monoid in a category of endofunctors). I don't really understand which objects (endofunctors) and morphisms (natural transformations) exactly create a monoid there. Generally, to be monoidal our category should have a bifunctor (product, coproduct, is there
20:20:46 <rowannas> something else?) for every pair of objects, in other words there must exist a unique morphism between, say, functors F x G and F' x G' if there are morphisms [C, C](F, F') and [C, C](G, G').I think I haven't missed anything yet. Here our bifunctors are natural transformations. We can always define a unique one in terms of mu and  decomposition.And
20:20:47 <rowannas> what I don't understand is how exactly we can have the same morphism mu between T and T^2 and between any other two functors T^n and T^(n+1). How do we even define equality of morphisms? Up to unique isomorphism? So it's enough for us to have corner cases defined (mu :: T^2 -> T, n :: Id -> T and T^2 * T == T * T^2 <- this one because of
20:20:47 <rowannas> bifunctoriality) and, as if by induction, every other natural transformation T^n -> T^(n-1) just follows?By now I don't even know what I still want to ask. Sorry. But does all that at least make sense? 
20:21:06 <Axman6> ... that's a lot of question
20:24:03 <rowannas> That just shows how confused I am with these things. I've been trying to understand Bartosz's lectures as of late .. It was difficult and I'm not even sure it's useful in any meaningful way. Though it's quite fun
20:24:16 <EvanR> I do see at least two question marks
20:24:24 <EvanR> ok four
20:24:55 <Axman6> You might also try stackoverflow (moslty because if you're stuck others might also be stuck and might find your question when searching for answers)
20:25:21 <EvanR> I think the easy way to define equality of morphisms in a category is to not define it, instead rely on an intuitive notion of "sameness". Two morphisms are equal when they are the same morphism.
20:25:52 <EvanR> Otherwise you will become sucked into a parallel subspace of semantics
20:26:39 <Axman6> Bartosz gave a keynote at LambdaJam this year which was mostly about what equality means
20:27:39 <rowannas> So we can have the same morphism between many different objects. And that would mean that these objects are also the same. That's a monad for you.. I think
20:27:55 <EvanR> wait no... 1 morphism is always between 2 specific objects
20:27:56 <rowannas> Ohh, I'll check it, thanks
20:28:15 <EvanR> it's part of what it is to be a morphism
20:28:26 <rowannas> identity is between just one
20:28:40 <EvanR> heh. it's still two objects, not more
20:28:41 <rowannas> And identity is almost like equality (but identity)
20:29:26 <EvanR> no.....
20:30:21 <rowannas> But if two objects are indistinguishable (there is an isomorphism between them) then why we can't say that this is just a single object
20:30:32 <EvanR> that would be evil (tm)
20:31:01 <EvanR> dihedral groups are 1 thing, and symmetric group that may end up being isomorphic as groups are another
20:31:01 <heatsink> Think of Boolean logic
20:31:20 <rowannas> In which way?
20:31:29 <heatsink> if you swap the names "True" and "False", and swap the operators around, then everything is the same
20:32:35 <rowannas> Oh, I think I follow (even if a little). Thank you
20:32:59 <heatsink> When you do that, you still have to be careful to avoid assuming that True and False are the same
20:34:14 <heatsink> The original and renamed Boolean logic are isomorphic, but you still want to tell them apart so you don't think True = False
20:34:16 <EvanR> in the category of sets, all sets of size n are isomorphic. But you would not say there is literally only 1 set of size n
20:34:56 <EvanR> (you may instead use the annoying phrase, there is 1 set of size n up to isomorphism)
20:37:30 <rowannas> Yep, then back to the original question. To define a monad we need Id, T, T^2, ... T^n, ..  endofunctors and unique morphisms between them
20:38:44 <EvanR> the monad i know doesn't require an infinite arity T
20:39:38 <rowannas> But mu should be able to unwrap any T^(n+1) endofunctor into T^n
20:42:11 <EvanR> no, mu is literally T^2 -> T
20:42:26 <EvanR> it's not polymorphic in n or anything
20:46:23 <rowannas> But I even saw those graphs unwrap T^3 into T in two ways (mu . Id) . mu == (Id . mu) . mu
20:46:31 <EvanR> to define a monad you only need a category, an endofunctor, natural transformations eta and mu, and the evidence they all satisfy the monad laws
20:47:12 <EvanR> well, you can use mu multiple times, and you can compose T with itself as many times as you want, it's got the same domain and codomain
20:48:24 <rowannas> But they are different objects in a category of endofunctors, are they not? 
20:48:40 <EvanR> which objects?
20:48:59 <rowannas> T and T composed with itself n times
20:49:02 <EvanR> oh were talking about monoids in a category of endofunctors... lol. Yeah that is beyond my understand of monads
20:49:14 <EvanR> understanding
20:49:28 <koz_> EvanR: Such category.
20:49:57 <EvanR> sure T T^2 T^3 etc are all different
20:51:34 <rowannas> Thank you any way, I think I get it now. We may have Just (Just ... (Just a)) and Just a. They are obviously different, but not up to unique isomorphism! And that's even why we have these monadic laws 
20:51:48 <EvanR> Maybe (Maybe (Maybe a))
20:51:56 <rowannas> Yep, oops
20:52:55 <EvanR> i don't see how they would be not different, even considering isomorphism
20:55:32 <rowannas> There is no additional information attached to them. It's like (a, ()) ~ a. We can always construct one from another. That is exactly what it means for them to be unique up to isomorphism
20:55:40 <EvanR> ex. Maybe () has 2 values, Maybe (Maybe ()) has 3 values (ignoring bottom)
20:56:43 <EvanR> (a,()) is isomorphic to a but, iterated Maybes... not so much
20:57:34 <rowannas> Just Nothing ~ Nothing
20:57:54 <EvanR> no?
20:58:00 <Axman6> those are not the same
20:58:44 <rowannas> But why? Can't you construct each one from the other one? 
20:58:54 <EvanR> try to write the isomorphism
20:58:57 <jle`> the isomorphisms we're talking about here are between types
20:58:58 <Axman6> they have diffferent semantics
20:58:59 <jle`> not between valueds
20:59:22 <jle`> hm, i was thrown off by your usage of ~
20:59:32 <EvanR> () has 1 value, Maybe () has 2
20:59:41 <Axman6> "I failed to produe a value of tyoe Maybe a" vs "The value of type Maybe a I produced was Nothing"
20:59:48 <EvanR> it's like saying a set of 1 thing is isomorphic to a set of 2 things
20:59:48 <rotaerk> you can have a Maybe (Maybe x) where the outer maybe communicates the presence/absence of one thing, and then the inner communicates the presence/absence of another (but dependent upon the presence of the former)
21:00:00 <jle`> rotaerk: Maybe (Maybe a) is not isomorphic to Maybe a. if you map Just Nothing to Nothing like you suggest, that's not injective
21:00:16 * rotaerk redirects that to rowannas.
21:00:23 <jle`> er yes, sorry; rowannas ^ :)
21:00:27 <jle`> ro<tab>
21:02:09 <EvanR> another way to look at Maybe _ is that it's _ + 1, where 1 is () and + is Either. Each application of Maybe adds 1 new element
21:04:01 * koz_ nods.
21:05:03 <koz_> Maybe is the succ of finite-cardinality types. :P
21:06:27 <rowannas> Actually my argument still holds. eta should not be isomorphic, mu should. And with that we can simply say that Just Nothing ~ Nothing and Just (Just a) ~ Just a 
21:06:49 <rowannas> So T is isomorphic to T^2 
21:08:43 <rowannas> And that's exactly what monad is about, no? We can mush things inside however we want, yet if we applied eta to an element, we can't go back (not injective)
21:09:22 <EvanR> no
21:09:36 <EvanR> what do you mean "mu should be isomorphic"
21:10:06 <rowannas> There is 1 to 1 correspondence between Maybe (Maybe a) and Maybe a
21:10:30 <EvanR> you are saying mu is an isomorphism, i.e. there's a inverse natural transformation from T -> T^2
21:10:57 <EvanR> which undoes what mu does
21:11:07 <rowannas> and that's eta 
21:11:33 <rowannas> There are even laws about that
21:11:35 <EvanR> no... eta : Id -> T
21:12:32 <rowannas> but we can always decompose T into T x Id and apply Id x eta 
21:12:46 <EvanR> just saying, this inverse natural transformation doesn't exist, at least in haskell
21:12:47 <rowannas> That's a bifunctor for you
21:14:06 <quiet_laika[m]> are there any minimal haskell-like-language compilers in haskell that one could use as a reference for implementing basic things like ADTS and such?
21:14:40 <EvanR> monoids bioperation isn't necessarily reversible
21:15:10 <dmj`> quiet_laika[m]: purescript, daml
21:15:23 <dmj`> quiet_laika[m]: elm
21:15:31 <quiet_laika[m]> ooh duh
21:15:36 <quiet_laika[m]> idk why i didnt think of elm
21:15:43 <quiet_laika[m]> dmj`++
21:15:48 <quiet_laika[m]> oh my
21:15:52 <EvanR> warning elm doesn't have type classes and the pain is real :)
21:16:16 <EvanR> but you might not want to implement them
21:16:23 <quiet_laika[m]> <EvanR "warning elm doesn't have type cl"> oh yes, have you read sandys maguires post about this?
21:16:30 <EvanR> probably
21:17:11 <quiet_laika[m]> https://reasonablypolymorphic.com/blog/elm-is-wrong/
21:17:25 <EvanR> right...
21:17:28 <rowannas> No, it isn't. But it's not the case here. And eta is a nice inverse function, because it takes any polymorphic type, so we can have T^2 -> T^3 and so on
21:17:56 <quiet_laika[m]> what a strong title, but, ultimately i have to agree
21:18:40 <EvanR> eta is in no way an inverse to mu
21:19:21 <EvanR> they both "go the same direction", toward T
21:19:43 <EvanR> two entry ways into T
21:19:48 <EvanR> no way out
21:20:06 <rowannas> Even with list of lists. If we do it we sure will get a singleton list, containing a list with all T^2 lists concatenated. But they are still unique up to isomorphism, no additional elements were presented
21:20:39 <EvanR> nah... you must be confused
21:21:48 <quiet_laika[m]> https://github.com/elm/compiler/blob/master/compiler/src/AST could someone guess as to whether one of these modules corresponds to elm's "core"?
21:25:07 <quiet_laika[m]> honestly, all three of those languages are a bit "larger" than what i was hoping to look at
21:26:47 <quiet_laika[m]> but i think elm is probably the best bet
21:32:24 <sim590> I can't understand how the type "State" is be used in this example https://en.wikibooks.org/wiki/Haskell/Understanding_monads/State#Introducing_State. Why is it that given "newtype State s a = State { runState :: s -> (a, s) }", the function `runState` then have signature `State s a -> s -> (a, s)` ????? The signature I gave above doesn't have `State s a` in it...
21:33:29 <EvanR> because runState is a field accessor
21:33:52 <EvanR> they "cleverly" used record syntax to defined the newtype
21:34:10 <EvanR> a State s a is a record with 1 field
21:34:11 <sim590> How should that be written so that I can understand it?
21:34:40 <sim590> What's a record?
21:34:51 <EvanR> maybe look into record types first
21:35:10 <EvanR> a record is just like a tuple but with field names
21:37:18 <sim590> I have looked at this, but never there was a field that was a function in the exercies.
21:37:44 <EvanR> each field defines an accessor function
21:37:52 <EvanR> of the same name as the field
21:38:15 <EvanR> in this case "runState"
21:39:41 <rowannas> You always need a structure to take a value from it. Here this value just happens to be a function
21:41:35 <sim590> OK. Yes. I remember that, but then I don't understand what is the "s" type.
21:41:38 <EvanR> yes, you can see runState having the signature State s a -> (s -> (a,s)). See the target is the type of the field's payload
21:41:53 <EvanR> oh. s is the type of state
21:42:15 <EvanR> that is what you can update
21:43:50 <sim590> OK, may be I can formulate a more useful question: What am I doing wrong here: https://paste.debian.net/1102123/ ? I can't understand how to write `fmap` for `State s`. I just don't get what I can pass to `runState st` (which is the function I just accessed).
21:44:13 <EvanR> you pass the initial state
21:44:35 <EvanR> you get back the result of the computation and the updated state
21:45:02 <EvanR> fmap will need to modify the result, but not the state
21:45:14 <sim590> That's what I thought that I wrote.
21:46:21 <sim590> Is there an argument missing in my list of args for fmap?
21:46:22 <EvanR> you definitely have a problem here
21:46:31 <EvanR> no
21:47:12 <EvanR> so your variable names indicate you may not understand the types involved
21:47:32 <sim590> That's a possible enventuality.
21:47:33 <EvanR> st' is a state value, st is a state program
21:48:01 <EvanR> st' is the initial state, and you are dropping the updated state of st after running it
21:48:43 <sim590> I just don't know what fmap should be doing with a `State s a`
21:48:43 <EvanR> and you are missing and argument to runState st
21:48:58 <sim590> Yes. I just don't know what I can feed to it.
21:49:04 <EvanR> it should modify the result like you are doing
21:49:28 <sim590> Alright. That I got fine.
21:49:33 <EvanR> you need to feed the initial state, st' (so i would call it st0 or something)
21:50:16 <EvanR> or s
21:50:49 <EvanR> the result of runState st s would be (x, s')
21:51:12 <EvanR> s' is the updated state
21:51:19 <EvanR> don't lose it
21:52:19 <sim590> I just fixed that, but I'm still puzzled about how I feed something to `runState st0`. It's not inside the structure. I can't get it.
21:52:48 <sim590> I have this  fmap f st0 = State (\ st0 -> (f x, s'))
21:52:51 <sim590>     where (x, s') = runState st0
21:53:09 <EvanR> you called two different things st0
21:53:37 <Axman6> :t runState
21:53:38 <lambdabot> State s a -> s -> (a, s)
21:53:38 <EvanR> they have different types too
21:53:58 <Axman6> given something of type State s a, and an s, produce a tuple of a and s
21:54:11 <EvanR> if i use your variable names, it'd be runState st0 st0, obviously nonsense...
21:54:20 <EvanR> please fix them
21:54:53 <sim590> I have that now:   fmap f stp = State (\ st0 -> (f x, s'))
21:54:55 <sim590>     where (x, s') = runState stp
21:55:10 <sim590> stp is a "state program" as you said.
21:55:12 <EvanR> well theres one variable you haven't used :)
21:55:29 <sim590> Yeah, but I don't get how I can use it. It's in a lambda.
21:55:37 <sim590> It's inside some scope I can't access, no?
21:56:01 <EvanR> true, you put this definition outside the lambda entirely
21:56:07 <EvanR> no reason to do that
21:57:10 <EvanR> there's a few ways to write this. For instance State (\st0 -> let (x,s')=runState stp st0 in (f x, s'))
21:58:04 <EvanR> but you could also put a named function in a where, then use State on it
21:58:17 <EvanR> State f where
21:58:21 <EvanR>   f st0 = ...
22:01:06 <sim590> I'm just forced to put the call to runstate inside the function. Otherwise, I can't have access to st0. So, I'm foreced to use a let inside the def of `f` even if it's in a where clause.
22:01:29 <EvanR> you can use a nested where
22:01:33 <EvanR> if you really want to
22:03:01 <EvanR> https://paste.debian.net/1102125/
22:06:48 <sim590> I'm trying to wrap my head around all of this.
22:07:35 <EvanR> first of all, does the idea of a "state action" make sense
22:08:40 <EvanR> it's a computation you can run that returns a result, and may or may not use state. Including may or may not change the state
22:08:52 <EvanR> This is all summed up in the type of runState
22:08:57 <EvanR> :t runState
22:08:58 <lambdabot> State s a -> s -> (a, s)
22:09:12 <EvanR> ignore for the moment that newtype definition and just consider that type
22:09:30 <EvanR> it's a two argument function
22:09:48 <sim590> THe transition from a state to another, yes. The thing that was bugging me is that everything is wrapped inside the lambda.
22:10:29 <EvanR> yeah, it necessarily is. The lambda is the only way you can know what the state is
22:10:49 <EvanR> because the user decides what it is, later
22:10:56 <EvanR> when they use runState
22:11:21 <sim590> Yes. I was not able to make sense of this. I was searching for an initial state but it's in the lambda that we are creating.
22:11:31 <EvanR> indeed
22:12:23 <EvanR> you can think of lambda as being a "hypothetical"
22:12:33 <EvanR> if i had a state... what would i do
22:12:36 <sim590> My mind was going crazy just before and that is not an euphimism. I owe you a big thanks.
22:12:57 <sim590> Yes. It's more clear now.
22:21:30 * hackage hw-xml 0.4.0.0 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-xml-0.4.0.0 (haskellworks)
22:38:25 <jle`> rowannas: there is no one-to-one correspondence between Maybe (Maybe a) and Maybe a
22:38:46 <jle`> remember, monoid actions are not necessarily invertible.  that's not one of the conditions of monoidness.
22:39:40 <jle`> rowannas: if you believe there is a one-to-one correspondence between Maybe (Maybe a) and Maybe a, try to prove it :) write a function Maybe (Maybe a) -> Maybe a, and a function Maybe a -> Maybe (Maybe a), in a way that f . g = id, and g . f = id
22:40:22 <jle`> you don't have to take our word for it -- you can try it yourself
22:40:26 <EvanR> the thing is, if you believe that Nothing = Just Nothing = Just (Just Whatever)... you can do it
22:40:44 <jle`> rowannas: mu is the monoid action, and you seem to be implying that mu and eta are inverses of each other.  this is not true.
22:41:48 <EvanR> when everything looks like a nail, all you have is a hammer
22:42:02 <EvanR> *smokebomb*
22:42:26 <mathyouguy[m]> .
22:43:26 <EvanR> basically they were doing a contraction of a connected type, reducing everything to a point. To ()
22:47:56 <EvanR> which is wrong even then because you can think of all haskell types as being totally disconnected, discrete types
22:57:02 <Guest41> Hi, I've been trying to use TH to generate a sum type given a list of types. The intention is to allow for State to have multiple variables of different types.
22:57:24 <Guest41> https://gist.github.com/CornCobs/f1fe452576e5400289fa45a875bb5f98
22:58:03 <Guest41> but when I try to splice it in, i.e. $(makeEnv [''String, ''Int])
22:58:25 <Guest41> I get an error "Multiple declarations of `Env'"
22:59:19 <Guest41> It works fine if I manually create the new names, i.e. (map (\i -> mkName $ "Env" ++ show i) [0..]) instead of using newName "Env"
23:02:07 <EvanR> Guest41: there is a fundamental difference between mapping that function over the list and using newName
23:03:40 <Guest41> Yes, when calling newName I call it from within the function with forM, but with the list of manually created names I use zipWith with the list of types and the list of names
23:03:54 <EvanR> ok then nevermind
23:04:07 <EvanR> so do you need a source of numbers? or what
23:04:50 <Guest41> I'm just creating names for the constructors.
23:05:32 <Guest41> with my first version, if I use runQ instead of splicing, I see that the generated constructor names are Env_0 and Env_1
23:05:58 <Guest41> and if I copy the output and splice that it actually works
23:06:06 <Guest41> but splicing directly doesnt
23:13:14 <iqubic> ski: '(a -> Expr a) -> Expr a -> Expr b' is confusing.
23:13:20 <iqubic> But I think I figured it out.
23:13:48 <iqubic> Is it fixed point recursion?
23:19:49 <Z87> hey, I'm new to Haskell but want to implement a project to learn it well. Any ideas/suggestions?
23:20:52 <Axman6> have you done any programming before?
23:21:02 <maerwald> Z87: something simple which you can scale in complexity and features: pastebin service
23:22:52 * Axman6 thought this was apt https://www.reddit.com/r/ProgrammerHumor/comments/d7zeu9/real_men_dont_read_the_manual/?utm_source=ifttt
23:34:50 <sim590> Is it fine to always use `let` instead of assignment-like statements in a do blocks?
23:36:37 <jle`> sim590: what do you mean by 'assignment-like statements'?
23:36:44 <jle`> can you show me an example of something you can replace with let?
23:37:43 <sim590> https://paste.debian.net/1102133/. All of my let statements were assignment-like before, i.e. `s0 <- return $ pure ...`
23:38:11 <jle`> oh yeah, x <- pure 4 is the same as let x = 4, you should probably do that instead
23:38:23 <jle`> i believe most linters should catch that actually
23:38:31 <jle`> but you can't always replace a <- with a let, otherwise do blocks wouldn't exist
23:38:45 <jle`> it's just `x <- return 4` etc. specifically that can be replaced with a let
23:38:49 <jle`> but for example:
23:38:54 <jle`> echo = do x <- getLine; putStrLn x
23:39:00 <Axman6> (and `x <- pure 4`)
23:39:07 <jle`> is not something you can do with let; that's actually the reason that do blocks exist
23:42:16 <jle`> sim590: x <- return 4 being the same as let x = 4 is actually something from the monad laws, having to do with return/pure in specific
23:42:23 <jle`> but it isn't necessarily a law for anything else
23:42:24 <whadevah> jle` I understand, you want to say that Maybe (Maybe a) has 3 values where Maybe a just two. But look closer at those two values. We can always go from Nothing to Just Nothing without loosing nor gaining any information, so these are pretty much equal (up to unique isomorphism, which is mu and eta)
23:42:49 <jle`> whadevah: "pretty much" equal, or equal?
23:43:05 <whadevah> up to unique isomorphism
23:43:14 <jle`> what is the isomorphism?
23:43:27 <whadevah> 1 to 1 correspondence 
23:43:36 <Axman6> whadevah: that's not true, Just Nothing has more information than Nothing
23:43:40 <jle`> that is what an isomorphism is
23:43:46 <jle`> but i'm asking, what is the bijection?
23:44:05 <jle`> Just (Just x) <-> Just x
23:44:09 <jle`> Just Nothing <-> Nothing
23:44:13 <jle`> Nothing <-> ... Nothing?
23:44:15 <jle`> that's not a bijection
23:44:24 <jle`> so it cannot be an isomorphism
23:45:46 <jle`> when you say that there is an isomorphism, that means that there is a bijection. but no such bijection exists, so there cannot be an isomorphism
23:45:48 <whadevah> but you just said that Just Nothing <-> Nothing and we have an identity Nothing <-> Nothing
23:46:01 <jle`> i'm trying to write out what i think you are suggesting
23:46:11 <jle`> but do you see that last line would make it not a bijection?
23:46:23 <jle`> it would make your mapping non-injective
23:46:45 <whadevah> as long as Nothing /= Nothing and that's what I don't understand 
23:47:04 <whadevah> Just  Nothing /= Nothing
23:47:13 <Axman6> if two values map to the same value, there cannot possibly be a bijection
23:47:40 <jle`> whadevah: an isomorphism is when you can map each value in one set to a unique value in another set
23:47:50 <jle`> *a bijection
23:48:00 <jle`> but there is no possible way to write a bijection between Maybe (Maybe a) and Maybe a
23:48:10 <jle`> *if* you decide to map Just (Just x) to Just x
23:48:15 <jle`> and you decide to map Just Nothing to Nothing
23:48:19 <jle`> then...there is nothing you can map Nothing to
23:48:38 <jle`> so either your mapping is non-total, or it's non-injective
23:48:49 <iqubic> Maybe a is not isomorphic to Maybe (Maybe a)
23:48:51 <jle`> in both cases, it means it isn't an isomorphism
23:49:07 <parsnip> or just count the elements?
23:49:24 <parsnip> oh, a is general
23:49:27 <jle`> parsnip: whadevah is arguing that sets can have different sizes and still be isomorphic, so we're working around that
23:49:33 <parsnip> ah
23:49:39 <Axman6> 1 + (1 + a) /= 1 + a
23:50:20 <whadevah> I understand that, but as I see it. Maybe (Maybe a) has only two elements. And yes, Just Nothing is the same as Nothing
23:50:20 <iqubic> Maybe () is not isomorphic to Maybe (Maybe ())
23:50:31 <jle`> whadevah: to go from your original 'losing information' intuition: say you do map Just (Just x) -> Just x, Just Nothing -> Nothing, and Nothing -> Nothing.  in that case, you do lose information
23:50:43 <jle`> whadevah: let's say that i told you that f myValue :: Maybe a, is Nothing
23:50:45 <Axman6> whadevah: how does it have only two elements?
23:51:04 <Axman6> it clkearly has at least three
23:51:12 <iqubic> jle`: is that of type 'Maybe a' or of type 'Maybe (Maybe a)'?
23:51:16 <jle`> whadevah: so if i have your mapping, f :: Maybe (Maybe a) -> Maybe a, and i told you that `f myValue` is Nothing ...
23:51:22 <jle`> whadevah: what can you tell me about myValue?
23:51:29 <iqubic> Nothing.
23:52:02 <iqubic> you have no idea if you started with 'Just Nothing' or 'Nothing'
23:52:09 <koz_> iqubic: wow, such pun. :P
23:52:13 <jle`> please no spoilers :)
23:52:20 <iqubic> Sorry.
23:53:11 <jle`> whadevah: hm, do you at least agree: if type X and type Y are isomorphic, then that means that there has to exist a function X -> Y, and a function Y -> X, such that their composition leaves their input unchanged?
23:53:19 <whadevah> Let's go from the other direction. Is it true that eta doesn't add any additional information? 
23:54:21 <whadevah> I agree with that, but I don't agree that Nothing and Just Nothing are different 
23:54:23 <jle`> hm, eta is an embedding. so it adds information in terms of where in the codomain you are
23:56:07 <svipal> hello
23:56:10 <jle`> on their own, Nothing and Just Nothing are different
23:56:20 <jle`> for example, let's say i had a map `Map Int (Maybe String)`
23:56:21 <svipal> Does anyone know how to pass options to gcc from stack ?
23:56:21 <Axman6> I'm still confused where the idea that Maybe (Maybe a) only has two values comes from
23:56:27 <jle`> which maps an Int to a Maybe String
23:56:35 <jle`> so we can have a lookup function:
23:56:50 <jle`> lookup :: Int -> Map Int (Maybe String) -> Maybe (Maybe String)
23:56:53 <Axman6> svipal: probably via --ghc-options and then it's -optc (I think) flag
23:57:04 <jle`> there are three ways this could turn out:
23:57:16 <jle`> 1. Just (Just str) -> the key exists, and the value at that key is Just str
23:57:25 <jle`> 2. Just Nothing -> the key exists, and the value at that key is Nothing
23:57:31 <jle`> 3. Nothing -> the key doesn't exist in that map
23:57:56 <Axman6> I'll note that we have exactly this type in the app I'm working on at the moment, Map FooLocationId (Maybe MappedLocation)
23:58:34 <Axman6> because we need to know the difference between if we know we don't have a mapped location and if we don't know anything about the id
23:58:48 <jle`> whadevah: note that mu is in general going to throw away information. that is the nature of mu
23:59:00 <Axman6> "The id is known but we can';t do anything with it" vs "I've never seen this id before, this is bad"
23:59:12 <jle`> Maybe might be a bad example, but let's look at something like `Const (Sum Int)`
23:59:22 <jle`> er, Writer (Sum Int)
23:59:32 <whadevah> Thank you, I think I get the difference between them now, though I still don't know what we need to define a monad in a category of enodfuctors 
23:59:39 <jle`> join :: Writer (Writer (Sum Int) a) -> Writer (Sum Int) a
