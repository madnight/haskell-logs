00:02:36 <iqubic> I have no idea why comonads are even useful.
00:02:53 <iqubic> Should I learn about Readers and Writers now, or comonads?
00:03:48 <iqubic> :t foldMap
00:03:50 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
00:03:51 <iqubic> :t traverse
00:03:54 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
00:06:39 <dminuoso> iqubic: Comonads are useful for the same reason Monads are useful.
00:06:41 <dminuoso> iqubic: They are an abstract interface.
00:06:43 <dminuoso> They capture a rather abstract pattern.
00:09:31 <Ferdirand> what's a polynomial functor ?
00:10:01 <Ferdirand> the wikipedia definition is... not very helpful
00:14:34 <iqubic> I have seen far too many people claim that list is the free monoid.
00:15:10 <iqubic> All I want is to know why the free monad is useful. I don't want comparisons to monoids, and I don't want false information.
00:15:36 <dminuoso> iqubic: Lets pretend that list is indeed the free monoid.
00:15:42 <dminuoso> iqubic: Would you agree that you can manipulate lists?>
00:16:57 <dminuoso> If we think of `[a,b,c]` as `a <> b <> c` but represented as a data structure, such that you can analyze the monoidal structure and transform it. You can analyze it, because you can for example count "how many times are we mappending here?", You can transform it because you can reorder lists. You can also remove operations (by removing elements), you can add operations (by adding elements)
00:18:39 <iqubic> Right. But I just read a blog post explaining how list is not the free monoid.
00:18:46 <dminuoso> iqubic: Ignore that, honestly.
00:18:54 <iqubic> http://comonad.com/reader/2015/free-monoids-in-haskell/
00:18:57 <iqubic> Why?
00:18:58 <dminuoso> iqubic: That blog posts is about getting pedantic about the actual subtle mathematic meaning of freeness.
00:19:03 <iqubic> Oh. I see.
00:19:19 <iqubic> So what exactly is the free monad?
00:19:28 <dminuoso> iqubic: Stick to the free monoid for a second.
00:19:36 <dminuoso> iqubic: Does what I just wrote make any sense?
00:19:41 <iqubic> Yes.
00:20:01 <dminuoso> iqubic: Okay. So lists give you the ability to inspect/transform the monoidal structure, and then run it with any monoid you like.
00:20:17 <iqubic> I'm not sure how you run it with any monoid?
00:20:25 <dminuoso> iqubic: use foldMap
00:20:36 <iqubic> :t foldMap
00:20:39 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
00:20:43 <dminuoso> iqubic: foldMap picks the actual monoid you want, and then sort of "executes" that stuck/hung/delayed monoid.
00:20:47 <iqubic> Ah. That makes sense.
00:21:22 <iqubic> And here we're saying t ~ [] because that's just the simplest thing.
00:21:52 <dminuoso> iqubic: Or we could pretend that Foldable is about free monoids.
00:21:57 <dminuoso> And list is just a special case.
00:21:57 <iqubic> Is it?
00:22:42 <iqubic> Sure.
00:22:52 <dminuoso> iqubic: Or rather, Foldable lets you transform any Foldable into a list.
00:22:54 <dminuoso> So..
00:22:59 <iqubic> So what is your point with all this?
00:23:45 <dminuoso> iqubic: My point is: When we say "list is a free monoid" we mean that we represent the monoidal actions, namely the <>, as *data* structure, without picking which exact monoid we want. We gain the ability to pattern match on this in order to inspect which things should be "mappended", we can transform it, change it, reorder it.
00:25:37 <iqubic> Ah. So we can manipulate the structure of the monoid without actually applying and monoidal effects.
00:26:24 <iqubic> And we can use foldMap to pick a monoid and apply the effects of that monoid.
00:26:45 <dminuoso> iqubic: When we say a foo is a free bar, we mean that foo satisties only the bare minimum requirements for bar, but nothing extra.
00:26:52 <iqubic> Right. I see.
00:27:02 <iqubic> So why isn't list also the free monad?
00:27:33 <dminuoso> data Free f a = Pure a | Roll (f (Free f a))
00:27:36 <dminuoso> iqubic: This is the free monad.
00:27:44 * ski . o O ( free over what ? )
00:28:04 <iqubic> That looks quite a bit like a list.
00:28:09 <dminuoso> iqubic: It does, doesnt it.
00:28:31 <iqubic> It does.
00:28:38 <dminuoso> iqubic: In fact we can write something similar to foldMap for it.
00:29:05 <iqubic> We can?
00:29:35 <dminuoso> foldFree :: Monad m => (forall x. f x -> m x) -> Free f a -> m a 
00:29:49 <dminuoso> Or, if I use ~> to clean this mess up
00:29:57 <dminuoso> foldFree :: Monad m => (f ~> m) -> Free f a -> m a 
00:30:05 <iqubic> What does ~> do?
00:30:22 <dminuoso> iqubic: `f ~> g` is just `f x -> g x`
00:30:47 <iqubic> type f ~> g = forall x. f x ~> g x
00:30:54 <iqubic> Or something like that.
00:30:58 <dminuoso>  type f ~> g = forall x. f x -> g x
00:31:14 <dminuoso> iqubic: Its just visual nicety to get rid off extra type variables we dont care about.
00:31:14 <iqubic> I just said that.
00:31:18 <iqubic> Nice.
00:31:25 <dminuoso> iqubic: Not quite. You used the squirly arrow on the RHS too
00:31:32 <iqubic> Oh, right.
00:31:35 <ski> (you had `~>' in the definiens)
00:31:59 <dminuoso> iqubic: So lets get a bit more subtle
00:32:04 <dminuoso> % :t foldMap
00:32:04 <yahb> dminuoso: (Foldable t, Monoid m) => (a -> m) -> t a -> m
00:32:18 <dminuoso> iqubic: If we set t ~ [] for a moment, and then consider that all functions take just one argument
00:32:20 <dminuoso> WE get:
00:32:25 <iqubic> Looks similar to the foldFree you proposed.
00:32:33 <dminuoso> foldMap :: Monoid m => (a -> m) -> [a] -> m
00:32:39 <dminuoso> iqubic: Do you agree that this is a function transformation?
00:32:49 <dminuoso> It transforms some `a -> m` into `[a] -> m`
00:32:59 <iqubic> Sure. I agree with that.
00:33:15 <cant_be_helped> are there any good ui toolkits for haskell?
00:34:08 <mimi_vx> gtk ?
00:34:08 <iqubic> foldFree :: Monad m => (f ~> m) -> Free f a -> m a
00:34:16 <iqubic> That's also a function transformer.
00:34:32 <ski>   foldFree :: Monad m => (f ~> m) -> (Free f ~> m)
00:34:39 <cant_be_helped> isn't gtk a pain on windows
00:34:39 <iqubic> Sure.
00:35:04 <ski> (converting a natural transformation into another)
00:35:19 <dminuoso> (These squirly arrows are called natural transformations. its just a name, dont think too much of it)
00:35:31 <mimi_vx> cant_be_helped:  https://haskell-at-work.com/episodes/2018-11-13-gtk-programming-with-haskell.html
00:35:32 <dminuoso> (That is `f ~> g` is called a natural transformation from f to g)
00:35:58 * ski . o O ( "a" )
00:36:11 <iqubic> I know enough catagory theory to know what a natural transfomation is.
00:36:11 <dminuoso> Oh.
00:36:32 <dminuoso> iqubic: Great. Turns out that in Haskell it comes from a free theorem that `forall x. f x -> g x` is always a natural transformation from f to g.
00:36:37 <dminuoso> So naturality comes for free.
00:36:43 <dminuoso> Just a sidenote. :)
00:36:49 <iqubic> I've read the first half of Bartoz's book on catagory theory.
00:37:12 <dminuoso> iqubic: So the core definition of a free monad is that we can transform any natural transformation into whats called a monad homomorphism.
00:37:14 <phadej> dminuoso: as far as f isn't GADT
00:37:16 <cant_be_helped> ill check it out, thanks
00:37:20 <dminuoso> phadej: Right. :)
00:37:36 <dminuoso> iqubic: Or at least, thats one way to define it.
00:38:11 <iqubic> What is a monad homomorphism?
00:38:20 <phadej> (or type-family)
00:38:34 <ski> phadej : an NT is between two functors. such an `f' wouldn't be a functor, no ?
00:38:51 * ski braces for Wadler being invoked
00:38:53 <phadej> ski: yes
00:39:12 <phadej> but the type isn't 'Functor f, Functor g) => forall x. f x -> g x
00:39:21 <ski> of course not
00:39:29 <dminuoso> iqubic: They are natural transformations between monads that preserve return and join.
00:39:35 <iqubic> Ah. Nice.
00:39:58 <ski> (presupposition vs. assumed constraint)
00:40:04 <iqubic> But what makes 'Free f a' useful?
00:40:30 <dminuoso> iqubic: The same reason free monoids are useful. You can manipulate the monadic structure, inspect it..
00:40:30 <ski> (so no need to pick out GADTs in particular. it's the non-functorness which was relevant)
00:40:37 <iqubic> Ah. I see.
00:40:44 <iqubic> Makes a whole lot of sense.
00:40:52 <dminuoso> iqubic: And you can separate the code building up the monadic structure from the code running it.
00:41:04 <iqubic> Ah. I see.
00:41:04 <dminuoso> iqubic: Because you can, when you run it, pick any monad to actually "unravel" that monadic structure.
00:41:12 <phadej> ski: in that type `f` could be type family as well :)
00:41:16 <phadej> (or `g`)
00:41:24 <dminuoso> iqubic: So its sort of an improved way to writing monad polymorphic code.
00:41:29 <phadej> but yes, that's nitpicking
00:41:33 <iqubic> I see. Makes a whole lot of sense.
00:42:43 <ski> phadej : i'm just saying you could have said "as far as f is a functor"
00:42:49 <dminuoso> iqubic: Now free monads offer you much more still. It allows you to turn any functor into a monad basically. :)
00:43:03 <phadej> ski: yes
00:43:10 <iqubic> How do we know that this data structure is the simplest possible monad?
00:43:25 <dminuoso> iqubic: That takes you into category theory.
00:43:44 <ski> s/simplest/least constrained/
00:43:53 <iqubic> Yes. I know.
00:43:55 <merijn> simplest is a fuzzy term for people :p
00:44:04 <merijn> I would argue Identity is the simplest monad :p
00:44:47 <dminuoso> iqubic: Interesting to note that the word "free" is not meant in the sense of "no costs", but rather "unconstrained" like "freedom".
00:45:02 <ski> (is `(Bool,False,(||))' a simpler monoid than `(Nat,0,(+))' ?)
00:45:35 <iqubic> No. But they are equally constrained.
00:45:51 <koz_> dminuoso: Something something libre monads. :P
00:45:54 <ski> it's a relative thing
00:46:49 <opqdonut> hmm, you can embed the Bool monoid into Nat (just take the Z/2 quotient), but not vice versa
00:46:55 <ski> (it's not "least constrained", taken absolutely. it's "least constrained, wrt blahblah")
00:47:13 <dminuoso> iqubic: How good are you with adjunctions?
00:47:32 <ski> opqdonut : not a monoid morphism
00:47:45 <iqubic> I don't know what the word adjunction means.
00:47:46 * ski . o O ( free commutative monad, over a monad )
00:47:49 <opqdonut> yeah not an embedding
00:47:50 <dminuoso> iqubic: Then dont mind me. :)
00:47:54 <opqdonut> looking for the right word
00:47:56 <merijn> iqubic: It's okay, neither do I :)
00:48:04 <dminuoso> iqubic: The actual definitions take you into adjunctions, a very interesting concept.
00:48:07 <ski> opqdonut : projection ?
00:48:19 <dminuoso> iqubic: Fun teaser for an unrelated matter: Every monad arises from an adjunction!
00:48:39 <opqdonut> ski: the function even :: Nat -> Bool would be a projection that is also a morphism
00:48:44 <ski> yes
00:48:45 <opqdonut> but that "loses information"
00:48:49 <iqubic> I know that left and right adjunctions exist.
00:48:57 <iqubic> But nothing beyond that.
00:49:05 <dminuoso> iqubic: So I could give you a handwaving intuition about freeness.
00:49:30 <ski> opqdonut : there is no monoid morphism from `(Bool,False,(||))' to `(Nat,0,(+))', except the empty one
00:49:34 <opqdonut> yes
00:49:37 <dminuoso> iqubic: Functors transform categories. So at some point you might ask the question "are these two functors equal", but that starts a question of "what does it mean for two functors to be equal"
00:50:01 <opqdonut> maybe there is no word, you just say "(Bool,False,(||)) is isomorphic to a quotient monoid of (Nat,0,(+))"
00:50:15 * ski idly wonders what structure to put on this hom-class, to be able to say it is "empty" .. presumably pointwise monoid ?
00:50:45 <opqdonut> anyway, this is one way of formalizing the "simpler than" relationship
00:50:48 <opqdonut> submonoid would be another
00:50:55 <merijn> So this interactive-plot thing is looking cool, but no bar charts it seems. Anyone know if there's a similar terminal plotter that does support barcharts?
00:58:29 <dminuoso> iqubic: Here's an alternative way to define a list by the way: `newtype List a = List (forall b. Monoid b => (a -> b) -> b)` and equivalently for Monad you could say `newtype Free f a = Free (forall x. Algebra f x => (a -> x) -> x)` given some `class Algebra f x where  phi :: f x -> x` (copied straight from edwards answer from stackoverflow)
01:03:44 <lavalike> merijn: things like this? https://github.com/gizak/termui go has a bunch
01:04:56 <merijn> lavalike: That's not haskell, so no, not looking for that :)
01:05:11 <lavalike> (:
01:05:50 <merijn> In other news: How do I only now learn about this? https://github.com/redneb/ghc-alt-libc I need more static executables in my life
01:06:10 <koz_> dminuoso: Does this alternate list allow a similar API to the lists we're used to?
01:11:15 <boxscape> koz_: Seems like it to me - trivially, you could define the API by always converting to a normal list first, use the regular list API, and convert back to this kind of list
01:11:48 <koz_> boxscape: I guess I asked my question badly.
01:12:38 <koz_> I meant it more in the sense of 'without munging between representations constantly'.
01:13:51 <Rembane> koz_: You could also write a function that takes a "new list" and a function f :: [a] -> [a] and applies f on the new list. 
01:14:51 <koz_> OK, let me try a more focused question then. Is NewList a Functor?
01:16:17 <merijn> koz_: I think so
01:20:40 <koz_> I'm not sure I see it.
01:25:29 <merijn> koz_: https://paste.debian.net/1099803/
01:28:00 * hackage yesod-form 1.6.7 - Form handling support for Yesod Web Framework  https://hackage.haskell.org/package/yesod-form-1.6.7 (MichaelSnoyman)
01:29:24 <ski> koz_ : `a' (only) occurs positively in `forall m. Monoid m => (a -> m) -> m'
01:30:10 <merijn> <- clearly a constructivist ;)
01:31:57 <ski> (the "only occurs positively" is something like "`Cat' is a category", hmm)
01:35:01 * hackage graphql 0.5.0.1 - Haskell GraphQL implementation  https://hackage.haskell.org/package/graphql-0.5.0.1 (belka)
01:49:37 <noumenon> > sum [1..]
01:49:44 <lambdabot>  mueval-core: Time limit exceeded
01:49:49 <koz_> ski: I can never figure out the 'occurs positively or negatively' thing.
01:50:10 <dminuoso> koz_: Its sort of the "contains" vs "requires" perspective.
01:50:21 <Taneb> koz_: being on the left hand side of an arrow switches the parity
01:50:22 <noumenon> hmm
01:50:32 <noumenon> shouldn't lambdabot evaluate that to -1/12
01:50:47 <Taneb> koz_: a is positive, a in (a -> x) is negative, (a -> x) in ((a -> x) -> x) is negative so a is positive
01:52:17 <koz_> I guess that's one way to see it. I'll eventually have this concept sink into my brain, lol.
01:52:33 <koz_> So I guess NewList is also an Applicative?
01:52:37 <Taneb> koz_: well, it's an algorithm to compute it rather than the idea
01:52:57 <koz_> Taneb: I'll take an algorithm as a start.
01:53:05 <koz_> At least I can do it correctly - intuition can come later.
01:53:07 <dminuoso> koz_: Well it *is* just a list..
01:53:30 <dminuoso> koz_: But indeed, finding the implementations using that representation are some interesting challenges.
01:53:38 <Taneb> dminuoso: not quite, NewList can be left-infinite but well defined
01:53:51 <dminuoso> Ah right.
01:54:03 <koz_> Taneb: Could you elaborate on that?
01:55:28 <Taneb> let leftinf x = NewList $ \f -> runNewList (leftinf x) <> f x
01:55:37 <Taneb> Convert that to a list in the obvious way and you get bottom
01:55:53 <koz_> Yeah, because you 'can't start'.
01:56:03 <Taneb> But if you pass "\x -> Dual [x]", you get a well defined infinite list
01:56:16 <koz_> (in which case you 'can't finish')
01:56:29 <Taneb> (not being able to finish is OK in my book)
01:56:32 <boxscape> noumenon who knows maybe ghci would if you wait long enough for it to finish
01:57:28 <koz_> Taneb or dminuoso: Are there some things NewList can do more efficiently than []?
01:57:34 <koz_> (and/or vice versa)
01:58:16 <Taneb> koz_: it can be slow (or even undefined) to inspect the beginning of a NewList, which is constant time for []
01:58:45 * ski . o O ( left-recursion )
01:58:56 <koz_> Taneb: I guess it's because you either have a 'can't start' NewList or because you have to 'materialize' the whole thing to inspect it?
01:59:52 <Taneb> Something like that, yeah
02:00:56 <koz_> Is there anything a NewList can do faster?
02:01:55 <Taneb> koz_: you can reverse a NewList in constant time, I think
02:02:00 * hackage visualize-cbn 0.1.0.2 - Visualize CBN reduction  https://hackage.haskell.org/package/visualize-cbn-0.1.0.2 (EdskoDeVries)
02:02:39 <koz_> Taneb: Wait, NewList has a concept of element positioning?
02:02:43 <koz_> How though?
02:03:21 <Taneb> rev (NewList k) = NewList (\f -> getDual (k (Dual . f))) I think
02:03:23 <boxscape> Am I right in thinking that fmapping multiple times would be automatically fused?
02:04:31 <koz_> boxscape: Judging by the implementation of fmap given there, yes, since it'd just be one big function composition.
02:05:28 <boxscape> that seems convenient, especially if you ever find yourself, for some reason, using compiler without rewrite rules
02:07:31 * hackage postgresql-simple-named 0.0.2.0 - Implementation of named parameters for `postgresql-simple` library  https://hackage.haskell.org/package/postgresql-simple-named-0.0.2.0 (shersh)
02:38:00 * hackage hspec-wai-json 0.10.1 - Testing JSON APIs with hspec-wai  https://hackage.haskell.org/package/hspec-wai-json-0.10.1 (SimonHengel)
02:39:07 <dminuoso> koz_: Coyoneda fuses for similar reasons by the way.
02:50:47 <dminuoso> koz_: instance Functor (Coyoneda f) where fmap f (Coyoneda g b) = Coyoneda (f . g) b
02:52:52 <koz_> Yeah, I knew about Coyoneda (thanks Sandy's book!).
03:00:07 <dminuoso> So Ive been struggling to figure out the right way to write `hoist :: LoggingT IO a -> Agnar a` for some `newtype Agnar a = Agnar { runAgnar :: LoggingT (ReaderT Env IO) a }`. This should be possible right?
03:01:46 <dminuoso> Originally I thought about just using askUnliftIO, but that won't help since the types dont line up
03:02:51 <dminuoso> Obviously I could just do something along the lines of `hoist smth = do { logger <- askLoggerIO; runLoggingT smth logger }` but I feel like Im missing the right tool.
03:03:07 <dminuoso> (Or well, missing an additional liftIO there)
03:03:29 <ski>   Agnar . hoist liftIO . runAgnar  -- ?
03:03:52 <dminuoso> ski: Is that hoist from mmorph?
03:03:54 <ski> yes
03:05:07 <pigmej[m]> I'm going to hit my head into the wall I think
03:05:14 <ski> how so ?
03:05:46 <dminuoso> ski: Mmm, I'd have to write some instance MFunctor LoggingT though, wouldnt I?
03:06:00 <ski> dminuoso : sorry, no `runAgnar', of course
03:06:13 <ski> yes, dminuoso
03:06:26 <pigmej[m]> ski: because https://gist.github.com/pigmej/4b4de00f5c218d4845af4d81eff965b1
03:06:27 <ski> (assuming it can be done)
03:07:30 <ski> pigmej[m]> :t processItem symbolState
03:07:54 <ski> pigmej[m]> :t dataItems
03:08:02 <pigmej[m]> processItem :: SymbolState -> MarketSymbol -> STM Integer
03:08:29 <pigmej[m]> https://gist.github.com/pigmej/c39f02a803f9d40872a72cefc231fa78
03:08:35 <pigmej[m]> that's most interesting part I think
03:08:37 <ski> you probably don't want to call `(+)' on `STM'-actions
03:09:04 <ski> try using `foldM' ?
03:09:09 <pigmej[m]> StmMap.insert forces me to do it
03:09:21 <pigmej[m]> StmMap is from StmContainers.Map
03:11:54 <pigmej[m]> ski all that started with issues with StmMap.insert it forced me to change the types from Integer to STM Integer
03:12:20 <ski> i see no mention of `StmMap' in those pastes. perhaps it's inside the type `SymbolState' ?
03:12:33 <ski> mhm
03:13:20 <pigmej[m]> https://gist.github.com/pigmej/cf4c475a86d65b747d99f98607d91842
03:13:27 <pigmej[m]> that's simplified version
03:13:38 <ski> return type of `processItems' should probably be `STM Integer', i presume
03:14:56 <ski> why `return 1', rather than put the `1' inside the fold ?
03:15:00 <pigmej[m]> yeah but that just moves the stuff up in the stack ;D
03:15:35 <dminuoso> ski: Ah in that case I could get away with: hoistL nat m = LoggingT (\i -> nat (runLoggingT m i))
03:15:47 <ski> `StmMap' is presumably an ephemeral, mutable, data structure
03:16:02 <pigmej[m]> its http://hackage.haskell.org/package/stm-containers-1.1.0.4/docs/StmContainers-Map.html
03:16:52 <ski> dminuoso : if `LoggingT m a' is implemented as `Whatever -> m (..a..)', yes
03:17:06 <dminuoso> ski: LoggingT is basically just ReaderT under the hood.
03:17:10 <ski> yes
03:18:41 <ski> pigmej[m] : if you're going to use a mutable datastructure, you're going the return types of the operations managing it with some effectful type "annotation", like `STM' in this case. no way around that, really
03:19:15 <ski> s/going the/goint to infect the/
03:20:08 <ski> pigmej[m] : did you try `foldM', yet ?
03:20:22 <pigmej[m]> no not yet ;-)
03:20:29 <pigmej[m]> I was trying to stop that STM to spreading down....
03:21:32 <ski> why did you want to use `STM' ?
03:22:13 <ski> i assume you do have multiple concurrent threads of execution ?
03:23:18 <pigmej[m]> yes
03:23:47 <ski> ok
03:38:01 * hackage kuifje 0.1.2.0 - A Quantitative Information Flow aware programming language.  https://hackage.haskell.org/package/kuifje-0.1.2.0 (martonbognar)
04:19:46 <r00tadmin> libertyprime
04:19:57 <r00tadmin> what's up
04:20:12 <juri_> haskell.
04:33:06 <michalrus> Whoa
04:33:07 <michalrus> proxyToLog :: (forall a. (ToLog a) => a -> p) -> BusEvent -> p
04:33:12 <michalrus> You can have such signatures :o
04:33:23 <michalrus> What’s the name for that?
04:33:32 <merijn> michalrus: The forall you mean?
04:33:40 <michalrus> I just wrote it, didn’t think it would work
04:33:44 <michalrus> Yes, but in the inner function
04:33:51 <michalrus> Plus a constraint
04:33:59 <merijn> michalrus: Rank2Types/RankNTypes, depending on how you nest the foralls :)
04:34:00 <michalrus> I thought you can only do that in top level
04:34:07 <michalrus> OK =)
04:34:19 <merijn> michalrus: Well, it requires an extension to do that, but yes, you can
04:34:26 <michalrus> Nice =)
04:34:36 <merijn> Consult GHC user guide for details :)
04:34:55 <merijn> michalrus: Also, RankNTypes can't be inferred, so you'll always have to write type signatures
04:35:11 <michalrus> Mhmmmm :)
04:35:17 <merijn> (Rank2Types technically *can* be inferred, but the algorithm is so insanely hard GHC doesn't implement it)
04:36:09 <boxscape> what about Rank3Types
04:36:25 <merijn> boxscape: Rank 2 is the highest that can be inferred
04:36:29 <boxscape> ok
04:36:31 <merijn> boxscape: There's a proof showing this
04:37:13 <merijn> boxscape: This is also why GHC has a separate Rank2 and RankN extension (currently they do the exact same thing), that in the future someone *may* implement Rank2 inference (since it was proven possible)
04:38:02 <boxscape> that makes sense, I thought it was just because people figured out uses for Rank2Types before they figured out uses for higher rank types
04:38:56 <juri_> arianvp: y0. :)
04:39:25 <sshine> I "ran into" this guy online who thought that you could "fix" stack builds with package constraint errors by automating the "Recommended actions". I don't have much experience working with packages outside an LTS distro, but I just ran into one case of 'aeson-diff-generic' being a little stale by referring to 'aeson >=1.2.4.0 && <1.3' when aeson in the latest LTS is 1.4.4.0. in this case, I guess the only 
04:39:31 <sshine> intelligent choices I have is either downgrade the LTS to when the two packages worked together, or submit a patch to aeson-diff-generic that moves it into the present day.
04:40:09 <merijn> That's the only solution for stack, yes
04:41:13 <sshine> I learned this by applying one level of "Recommended actions", but the cascade of "Recommended actions" that came from this forced me to think. and thinking about this, I realize that I can't automate beyond this, except if I want to downgrade the LTS. and then I'd have to hope that all the packages I use also work in combination on that older LTS.
04:41:50 <sshine> merijn, surely without stack I'd have to do something similar? either pick an older version of aeson, or update aeson-diff-generic so it works with a newer version of aeson.
04:42:30 <merijn> sshine: I mean, in the end yes, but if newer aeson doesn't have anything that's crucial for you downgrading aeson isn't really an issue
04:42:59 <sshine> merijn, ah. but the only way I can downgrade aeson using stack is to entirely downgrade the LTS version, right?
04:43:07 <merijn> sshine: Right
04:44:13 <sshine> I... I don't know if that's bad. I guess some people run into this kind of dependency problem so often with custom packages that they're forced to not use Stackage-like package distros?
04:45:57 <merijn> sshine: Well, I don't think it so much "forced to not use Stackage" and more like "a considerable number of people just don't feel like such a workflow makes sense in the first place" :)
04:48:57 <sshine> merijn, you mean, deviating from a curated package distro like Stackage LTS has a much higher cost than working with older LTS versions or porting deps of individual packages into the present?
04:49:51 <sshine> merijn, I'd assume this.
04:50:10 <merijn> sshine: I mean that I don't use stack, but not because large numbers of external dependency problems, but simply because it doesn't fit my mental model/workflow. I would assume this applies for lots of people who never bothered to switch to stack
04:50:59 <sshine> merijn, trying to filter the loud voices of "this person doesn't like stack", "this person likes stack, but doesn't like hpack". I'll just say my hobby Haskell life improved significantly with sandboxes, the commands I need to run improved significantly with stack, and the configging improved significantly for me with hpack. and in my limited hobby life, I never run into edge cases that madden me.
04:51:58 <merijn> sshine: Sure, I don't really care what people use if it works for them (as long as they keep a committed .cabal file around in the repo!) :)
04:55:05 <merijn> sshine: I mean, in the end there's no solution to "I need an unmaintained package" other than "maintain the package". The only difference is how these problems manifest and to what extend you can work around them
05:12:40 <Guest13343> ciao
05:22:30 * hackage newtype-generics 0.5.4 - A typeclass and set of functions for working with newtypes  https://hackage.haskell.org/package/newtype-generics-0.5.4 (sjakobi)
05:23:47 <sshine> merijn, thanks for the insight. :) it's nice to have an unopinionated summary.
05:25:12 <sshine> all serious software development I've done until now has all been low-dep proprietary code bases. for example, we only upgrade packages at work when we upgrade between stable (even) releases of Perl, and then one or two guys resolve those conflicts, so the average developer is entirely unconcerned about dependency hell.
05:25:42 <merijn> sshine: I also wrote this to clarify things for people: https://gist.github.com/merijn/8152d561fb8b011f9313c48d876ceb07 and have tried to keep it (mostly) free from value judgement (aside from hpack :p)
05:35:05 <dminuoso> ski: Okay mmorph is still somewhat scary and non-obvious. :)
05:35:29 <dminuoso> It didn't occur to me to think of liftIO as a natural transformation
05:35:56 <unsymbol> i no longer have time to maintain codeclimate-shellcheck (wrapper around shellcheck for use with codeclimate). it's relatively small project so probably a good one for someone with a little bit of spare time, an interest in docker and static analysis (hello, is this mic on?). anyway, here's the issue: https://github.com/mcfilib/codeclimate-shellcheck/issues/66 chime in.
05:36:00 * hackage coercible-utils 0.1.0 - Utility functions for Coercible types  https://hackage.haskell.org/package/coercible-utils-0.1.0 (sjakobi)
05:36:58 <ski> dminuoso : working ?
05:38:15 <dminuoso> ski: Well yes, I just dont fully comprehend mmorph. What line of thinking leads you to come up with `hoist liftIO`?
05:41:01 <dminuoso> Is it to express the idea of turning "LoggingT IO" into "LoggingT (ReaderT Env IO)" by hoisting "IO ~> ReaderT Env IO" into "LoggingT IO ~> LoggingT (ReaderT Env IO)"
05:41:11 <ski> `Agnar' gets us to `Agnar a' from `LoggingT (ReaderT Env IO) a', to which we want to get from `LoggingT IO a'
05:41:59 <ski> `hoist' on `LoggingT' will take us to `LoggingT (ReaderT Env IO) a <---< LoggingT IO a', from `ReaderT Env IO a <---< IO a', which is just `lift' / `liftIO'
05:43:03 <ski> dminuoso, yes
05:44:04 <dmwit> Interesting. Perhaps this would be a nice additional feature for effect-stack.
05:44:08 <dminuoso> ski: Ohh. Okay, now I see how MFunctor is a functor on the category of monads with monad morphisms as morphisms.
05:44:23 * ski nods
05:44:32 <dmwit> In addition to PopFoo to go under the top-level Foo, it might be nice to have an OnFoo to go down to the top-level Foo, for use with mmorph.
05:44:54 * ski hasn't checked `effect-stack'
05:46:00 <dminuoso> Is monad morphisms something from monad homomorphisms?
05:46:12 <dminuoso> Or is the former just short for the latter?
05:46:21 <dminuoso> *something different :o
05:47:03 <Taneb> dminuoso: same thing, I think
05:47:43 <ski> a "homomorphism" is just a morphism in an algebraic category (like `Mon',`AbMon',`Group',`Ab',`Ring',`Vect_K',`Mod-R',`R-Mod',`R-BiMod-S',&c.)
05:48:19 <ski> (and it's called `Hom_C(A,B)', even if `C' isn't an algebraic category, because raisins)
05:48:45 <dminuoso> Is "because raisins" some English idiom Im not aware of?
05:48:54 <ski> hysterical raisins
05:49:03 <dmwit> "hysterical raisins" sounds hilarious and a lot like the "historical reasons" from which it comes
05:50:02 <dminuoso> ski: I see. I suppose the "homo-" part to suggest structure preservation is implied already by the fact that its a category.
05:50:26 <ski> <http://catb.org/jargon/html/H/hysterical-reasons.html>
05:50:34 <dminuoso> Cheers.
05:54:00 * hackage replace-megaparsec 1.1.2.0 - Stream editing with parsers  https://hackage.haskell.org/package/replace-megaparsec-1.1.2.0 (JamesBrock)
05:58:31 * hackage replace-attoparsec 1.0.0.0 - Stream editing with Attoparsec  https://hackage.haskell.org/package/replace-attoparsec-1.0.0.0 (JamesBrock)
06:01:34 <merijn> dminuoso: It's hacker idiom, not English, I think the average English speaker would be utterly baffled ;)
06:01:50 <sshine> merijn, nice guide.
06:02:18 <dminuoso> merijn: Cant recall hearing this before, so it cant be that common. :)
06:09:01 * hackage symbols 0.3.0.0 - Symbol manipulation  https://hackage.haskell.org/package/symbols-0.3.0.0 (kcsongor)
06:29:01 * hackage overloaded 0.1 - Overloaded pragmas as a plugin  https://hackage.haskell.org/package/overloaded-0.1 (phadej)
06:41:33 <jumper149> but beware: I source .xprofile in my .xinitrc ^^
06:41:45 <jumper149> oups
07:05:05 <fr33domlover> Hey people! Is anyone doing ASN1 encoding in Haskell? I'm generating an ed25519 key using cryptonite and asn1-encoding but OpenSSL and GnuTLS fail to parse it (OpenSSL fails with unrecognized key type, but maybe it's because the overall format of the ASN1 encoding isn't right, maybe I missed something)
07:06:01 <fr33domlover> THe code is trivial: https://dev.angeley.es/s/fr33domlover/r/vervis/s/src/Crypto/PubKey/Encoding.hs
07:06:37 <fr33domlover> (I compared with the cryptostore library, looked at the code, they seem nearly identical, idk)
07:51:58 <srid> Do category theory's `product` and `coproduct` map only to Sum and Product types in Haskell ... or are there more applications of it?
07:52:28 <dminuoso> srid: What do you mean by "are there more applications of it"?
07:52:43 <dminuoso> srid: The connection is not "category theory's product/coproduct" in general
07:53:17 <dminuoso> srid: The connection is that there is a particular category, namely the category of types in which morphisms are functions between those types, in which you can construct the product and coproduct objects.
07:53:48 <srid> For some context, I'm reading the part of Bartosz's book which explains products/ coproducts - which part I find to be a bit confusing, so I'm trying to read other materials (currently watching the lecture), preferably approaching it from different angles. 
07:54:21 <dminuoso> srid: Or more specifically, if you consider that above category, frequently called Hask, then there's a lot of objects, each representing a type.
07:54:38 <dminuoso> srid: Some of these objects are special (because they match categorical constructions)
07:55:42 <srid> Yea, I'm familiar with `Hask` and how Sum and Product types represent this CT notions. 
07:55:59 <dminuoso> srid: Product and Coproduct exist in other categories too. :)
07:56:07 <srid> Right!
07:56:09 <dminuoso> But they might not map to types directly.
07:56:32 <dminuoso> srid: What do you mean by your question then?
07:57:32 <srid> dminuoso: Okay, taking a step back (to clarify my original question), and ask a different question: would you say some Haskell libraries use CT concepts? Does `lens` use any? `profunctors`, etc... ? (This might be a stupid question, but worth asking anyway ...)
07:59:07 <dminuoso> srid: Some of very advanced users try to use category theory to reason about their code.
07:59:32 <jumper149> Idk if it's a bit too philosophical, but you can use basic category theory in every reasoning in life.
07:59:41 <srid> And would it accurate to say that any apps that use `Data.Profunctor.Adjunction` is an application of the ... adjunction notion from CT? If so, my original question is in the similar lines (but for product/coproduct outside of Sum/Product types)
07:59:47 <srid> s/would it/would it be/
08:00:28 <dminuoso> srid: So here's an example of how you can employ CT to reason about coe.
08:00:36 <dminuoso> srid: Using CT you can reason that `Either a Void` is isomorphic to `a`
08:00:42 <srid> jumper149: Actually, I have been wanting to see if CT is relevant to model psychological or sociological concepts, but that's an aside ...
08:01:01 <maerwald> don't tell me you are applying CT in dating now :o
08:01:11 <dminuoso> srid: Its a trivial excercise to show that the initial object acts as an identity to the coproduct
08:01:18 <merijn> dminuoso: You just need algebra for that reasoning, though
08:01:21 <dminuoso> srid: Or equivalently, the terminal object acts as an identity to the product.
08:01:32 <dminuoso> merijn: Sure, Im just offering an alternative vehicle.
08:01:34 <merijn> dminuoso: "Either Void a = a" is just the whole "algebra of types" thing
08:01:52 <dminuoso> merijn: Yes sure, my point is not that you need CT to argue about that, but that you can *use* it to achieve the same effect.
08:02:18 <Taneb> merijn: it's also the whole "different mathematical structures sometimes have similar substructure" which is, like, what category theory is all about
08:02:42 <dminuoso> srid: Its probably the best example I can come up with if you are still meddling with basic category theory. :)
08:02:59 <srid> Thanks :)
08:03:22 <dminuoso> srid: Like, you dont need to reason about this in your head. You can merely show that (,) is indeed the product (via any construction you like) in Hask, and () is indeed the terminal object - and then you have your proof.
08:12:27 <dminuoso> srid: Though there's folks like edward who go out and beyond and do it from the other way around. They use category theory to formulate their problems and programs in terms of categorical terms.
08:13:40 <dminuoso> And then they use that vehicle to discover things and constructions by using CT constructions, and then thinking about what they just discovered.
08:16:55 <steve-chavez> Is there a way to make guards work inside a field of a constructor that uses record syntax?
08:17:10 <steve-chavez> Basically:
08:17:12 <steve-chavez> data AB = AB { a :: Int, b :: Int }
08:17:19 <steve-chavez> I can do this:
08:17:20 <steve-chavez> AB { a = if smth then 3 else 4, b = 5 }
08:17:22 <steve-chavez> y
08:17:27 <steve-chavez> But not:
08:17:29 <steve-chavez> AB { a | smth = 3 .. , b = 5 }
08:17:56 <merijn> steve-chavez: I mean you could move the definition out of the record and then use it
08:18:05 <merijn> But no, there's no way to make that work as-is
08:19:51 <steve-chavez> merijin: I see. Thank you. I'll just move the logic to a variable.
08:20:14 <geekosaur> AB { a } | a ... -- not sure what's actually being asked here tbh
08:20:40 <merijn> geekosaur: No, you're reading it wrong
08:20:41 <geekosaur> the record stuff is pattern syntax
08:20:51 <merijn> geekosaur: He wants a guard on the field
08:21:00 <merijn> geekosaur: For constructing them
08:21:33 <geekosaur> that sounds confused...
08:22:40 <ski> srid : hm .. in a partial order, "product" means "greatest lower bound", and "coproduct" means "least upper bound". e.g. "intersection" and "union" of subsets (with inclusion ordering)
08:24:02 <ski> > (sort . map S.fromList) [[],[0],[1],[0,1]]
08:24:04 <lambdabot>  [fromList [],fromList [0],fromList [0,1],fromList [1]]
08:28:55 <dmwit> > (S.fromList . map S.fromList) [[],[0],[1],[0,1]]
08:28:57 <lambdabot>  fromList [fromList [],fromList [0],fromList [0,1],fromList [1]]
08:29:01 <steve-chavez> merijn: I managed to do what I wanted by using MultiWayIf. That lets me avoid an extra variable.
08:35:17 * ski was pondering whether it possibly used one of Hoare,Smyth,Egli-Milner ordering ..
08:35:34 <ski> .. turns out it's just using lexicographical
08:36:07 <ski> (i suppose, in hindsight, it makes sense, since it should be a total order)
08:44:09 <entel> Has anyone tried raskell on iOS?
08:45:43 <pigmej[m]> So guys, I have to ditch my Haskell attempts :( Not enough time to dig into details, I have too many basic issues that I have no time to dig into / understand
08:45:43 <pigmej[m]> You've been awesome here :) Maybe I'll be back one day :)
08:46:34 <srid> maerwald: more along these lines: https://blogs.ams.org/blogonmathblogs/2013/08/14/this-is-your-brain-this-is-your-brain-on-category-theory/
08:46:48 <voyons_osti> pigmej[m],  didn't you post the same thing yesterday
08:47:11 <pigmej[m]> 2d ago ;)
08:47:15 <pigmej[m]> but this time fro good sadly
08:47:15 <ski> pigmej[m] : okay
08:48:01 <pigmej[m]> Too many STM / IO issues
08:49:00 * hackage vega-view 0.3.0.0 - Easily view Vega or Vega-Lite visualizations.  https://hackage.haskell.org/package/vega-view-0.3.0.0 (DouglasBurke)
08:50:51 <voyons_osti> yeah, you have to be really smart to understand STM / IO
08:51:03 <mycroftiv> on the flip side: ive been teaching myself the real foundations of logic, computation, and types the past few months in haskell and now agda, and you guys are stuck with me for life now, im a convert to 'we meed type level proofs of the spec'
08:51:38 <pigmej[m]> I basically don't have enough time to master the internals to be able to write something that I need
08:51:51 <pigmej[m]> so I have to switch that side project to other lang because seems that I'd not finish it in Haskell soon :D
08:52:10 <tdammers> I don't think understanding IO (from the perspective of a GHC user, that is - the internals are a bit trickier) isn't too difficult
08:53:10 <dminuoso> tdammers: In all fairness, thats an easy thing to say if you are the advanced user with deep intuition about Haskell as well as preexisting knowledge of GHC internals.
08:53:24 <dminuoso> You are, after all, not just a GHC *user* ;)
08:54:57 <pigmej[m]> Don't get me wrong but I have a feeling that Haskell is really poor for "prototyping" because once you change something then you need to change and propagate your types down / up the stack and alter shitload of stuff.
08:55:21 <dminuoso> pigmej[m]: This is why its *great* for it.
08:55:21 <pigmej[m]> And when you do it as n00b you endup shooting yourself in a foot multiple times
08:55:24 <tdammers> pigmej[m]: and I'd argue that that's exactly what makes it so useful
08:55:24 <dminuoso> pigmej[m]: Prototyping buggy and broken software just yields very poor models.
08:55:25 <pigmej[m]> dminuoso: depends what you want to achieve :) 
08:55:34 <dminuoso> pigmej[m]: Im fairly confident that it doesnt depend on it.
08:55:35 <tdammers> when you prototype in, say, Python, you can just go ahead and do stuff, but all the constraints you discover must be remembered, by you, simultaneously
08:55:42 <tdammers> whereas in Haskell you can just write them down
08:55:51 <dminuoso> pigmej[m]: The type system takes burdens off your shoulders, it doesn't add to them.
08:55:58 <monochrom> I use -fdefer-type-errors to get by.
08:56:10 <jgt> pigmej[m]: you know you are allowed to just not like Haskell, right?
08:56:12 <pigmej[m]> Well... usually yes
08:56:22 <dminuoso> pigmej[m]: There's enough tools to actually model "nothing here yet" ranging from undefined, typed holes, etc
08:56:36 <pigmej[m]> it's neat for "matching types" I'd say.
08:56:38 <dminuoso> pigmej[m]: As for mismatching types, there's really no reason to want this to work. 
08:57:02 <tdammers> indeed
08:57:18 <pigmej[m]> Any new added behaviour (STM) then all beauty of haskell vanishes
08:57:19 <pigmej[m]> dminuoso In my opinion it just adds shitload of issues
08:57:20 <pigmej[m]> as I'
08:57:20 <tdammers> instead of writing code that has mismatching types, write code that has overly generic types, and then try to refine them
08:57:26 <voyons_osti> monochrom, that's neat, i didn't know about -fdefer-type-errors
08:57:26 <dminuoso> pigmej[m]: what issues is that?
08:57:36 <dminuoso> pigmej[m]: Being forced to write code that *actually works* ?
08:57:56 <dminuoso> pigmej[m]: Instead of constantly running your software just to discover "this is wrong", "you are treating a list as a function here" and so on?
08:58:07 <dminuoso> pigmej[m]: The type system is precisely what makes refactoring so easy and charming.
08:58:20 <dminuoso> It tells you exactly *where* you havent matched your code to the new interface yet.
08:58:25 <pigmej[m]> as I'm a n00b
08:58:26 <pigmej[m]> jgt I'm not sure if its about liking or not liking
08:58:26 <tdammers> I like "compiler-error-driven development"
08:58:33 <dminuoso> pigmej[m]: That's even *more* reason then.
08:58:38 <pigmej[m]> I have a feeling that it's still cool but the entry level is super high
08:58:41 <dminuoso> pigmej[m]: It takes an *expert* to intuitively know all the places to fix.
08:58:52 <pigmej[m]> well, guys there are multiple languages that are static typed
08:58:53 <tdammers> 1. just make the fucking change 2. fix compiler errors until there are none left 3. verify that it works (it usually does)
08:58:57 <dminuoso> Im not smart enough to know this. Im dumb and rely on my compiler to tell me where my code is obviously wrong.
08:59:31 <pigmej[m]> tdammers there are many languages with that behaviour, it's haskell exclusive feature
08:59:37 <dminuoso> Plus this is much faster, because I dont need to go into an "execute, discover bug, fix" loop because usually "executing and finding bugs is tricky and you dont find them all"
09:00:01 <pigmej[m]> dminuoso same there, it's not haskell exclusive to make compiler to tell what's wrong in a code :)
09:00:04 <tdammers> pigmej[m]: I have never met a language where I can actually pull that off to the degree I can in Haskell. Well, Purescript maybe, but that's almost the same language.
09:00:19 <pigmej[m]> what is haskell exclusive though is IO, STM "burden"
09:00:31 <pigmej[m]> basically purity vs impurity
09:00:36 <dminuoso> tdammers: Well there's a fair degree of languages where this might still work. PureScript, Elm, Haskell, Idris, Agda, Clean, Rust, OCaml...
09:01:26 <tdammers> dminuoso: right, sure. I haven't tried Rust yet, I have no practical use for Idris, Agda or Clean at this moment, I ran away screaming from Elm for entirely unrelated reasons, and I'm not convinced OCaml is going to buy me anything that neither Haskell nor Rust could deliver
09:01:28 <tdammers> but yes
09:01:38 <tdammers> it probably works to a similar degree in any of those
09:02:20 <tdammers> pigmej[m]: the whole point of having an IO type is to make effectfulness possible and manageable without giving up on purity.
09:02:43 <tdammers> pigmej[m]: the secret sauce is that IO is just another type, from the perspective of the language itself, there isn't really anything special about it
09:02:52 <dminuoso> pigmej[m]: It's mostly just strange. But if you grok IO, you'll actually notice its a really simple idea and makes it easier for beginners to understand where stuff happens.
09:02:59 <tdammers> String -> Integer -- a function that takes a String and gives an Integer
09:03:20 <tdammers> String -> IO Integer -- a function that takes a String and gives an IO action of Integer
09:03:20 <pigmej[m]> weeeelll
09:03:22 <pigmej[m]> it's different
09:03:39 <dminuoso> pigmej[m]: For example: If you look at some code `f :: Int -> Int`, it might be doing all sorts of math inside - but you can tell with certainty that this wont do a) database calls, b) depend on contents of files, c) send radio waves to the moon.
09:03:39 <tdammers> String -> Beefcake Integer -- a function that takes a String and gives a beefcake of Integer
09:03:42 <pigmej[m]> why If I want to use StmMap.insert (stm-containers) I have to change my function to have ruturn type of STM a
09:03:44 <pigmej[m]> instead of a
09:03:56 <dminuoso> pigmej[m]: Yes, because effects shouldnt be hidden.
09:04:09 <pigmej[m]> ok, but then I have to pass that STM all down the stack
09:04:10 <dminuoso> pigmej[m]: Either any effects are allowed everywhere, but at that point you cant say for certain whether some region is effect-free.
09:04:17 <dminuoso> pigmej[m]: Well yes, because your entire stack *IS* STM.
09:04:27 <pigmej[m]> yeah
09:04:45 <pigmej[m]> and when I add IO there then I have STM IO :P
09:04:47 <pigmej[m]> or whatever
09:04:47 <dminuoso> pigmej[m]: Take an IO analogy. If you call a function `f` which calls a function `g` which calls a functoin `h` which calls a function `i` which does a database call. *EVERY* thing in the chain is suddenly doing IO.
09:04:49 <tdammers> so the whole point of STM is to perform memory mutations in a transactional way, yes?
09:05:00 <dminuoso> pigmej[m]: Its not just `i`. Its everything.
09:05:11 <pigmej[m]> tdammers yes, but only in the point where it's used
09:05:17 <pigmej[m]> not for whole stack, because why for whole stack
09:05:17 <tdammers> no
09:05:26 <pigmej[m]> that's my "issue" ;-)
09:05:38 <tdammers> the STM value *is* the transaction. constructing it doesn't run it, it just constructs it
09:05:44 <tdammers> you can't actually run it from within Haskell
09:05:51 <dminuoso> You can.
09:05:55 <dminuoso> By feeding it into main.
09:06:00 <tdammers> all you can do is a) combine it with other STM values, or convert it into an IO action
09:06:08 <pigmej[m]> by atomically
09:06:08 <dminuoso> Well oh I see what you are getting at.
09:06:14 <tdammers> (there's a b) missing there, but yeah)
09:06:17 <pigmej[m]> yeah and then I have IO everywhere :)
09:06:23 <dminuoso> pigmej[m]: Yes, but consider my example
09:06:25 <dminuoso> 18:04:25         dminuoso | pigmej[m]: Take an IO analogy. If you call a function `f` which calls a function `g` which calls a functoin `h` which calls a function `i` which does a database call. *EVERY* thing in the chain is suddenly doing IO.
09:06:33 <tdammers> and with IO, again, we can only a) combine it with other IO values, or b) pass it up the chain
09:06:33 <dminuoso> pigmej[m]: You cant just lie about `f` doesnt do IO.
09:06:37 <dminuoso> It'd be a blatant lie.
09:06:43 <tdammers> in the case of b), we eventually end up in main
09:06:48 <pigmej[m]> I had a working code that was doing some math and doing stuff, (working fine), then I wanted to add stm-containers, and then everything is broken :)
09:06:54 <tdammers> which is an IO action
09:07:19 <tdammers> we still haven't "run" ("executed", in Haskell terminology) anything, we have just created an IO action and given it the name `Main.main`
09:07:31 <pigmej[m]> dminuoso yeah I understnad that analogy, but that's exactly what's PITA for me now
09:07:44 <tdammers> the actual execution is deferred to the RTS, which is an impure interpreter for a language whose programs we can represent as IO values in Haskell
09:08:00 <dminuoso> pigmej[m]: If this causes much refactoring, your design is probably off.
09:08:20 <tdammers> so this indirection is a bit difficult to wrap your head around, because you have to abandon the paradigm where the evaluation of the code you write is deeply intertwined with execution
09:08:26 <pigmej[m]> if you're n00b in haskell your design is definitely off ;)
09:08:32 <dminuoso> pigmej[m]: It might be helpful to not put IO everywhere, but think about if you can parametrize your computation about extra input, which you obtain via an IO action near the top and feed it through.
09:08:36 <pigmej[m]> that's why I said prototyping and experimenting :)
09:08:49 <dminuoso> pigmej[m]: This frequently keeps code clean (and more easily testabe), and doesnt force you to sprinkle IO everywhere.
09:08:59 <tdammers> but there's huge wins to be had: the way this all works means that you can isolate effects and keep them contained in a smaller subset of your codebase
09:09:02 <pigmej[m]> dminuoso I don't understand
09:09:12 <dminuoso> I gotta run off for a haircut, but tdammers has you covered. :)
09:09:33 <pigmej[m]> enjoy it :)
09:09:43 <tdammers> so let me ask you this: what is easier to reason about, code that has effects, or code that doesn't?
09:10:12 <tdammers> (rhetorical question, so I'll just keep going)
09:10:20 <pigmej[m]> ;D
09:10:35 <EvanR> haskell heavy handedly suggests you write most of your code to be more flexible, take parameters as arguments instead of get them from I/O when run
09:11:04 <tdammers> so given a piece of code to reason about, you will probably 1) want to know whether it may have any effects, and 2) prefer for it not to
09:11:12 <tdammers> well, the IO type does that
09:11:40 <tdammers> it tells you where effects might be, and ensures that when it's absent, effects will not have to be considered
09:12:11 <EvanR> i think the reason was accidental, because if lazy code could do I/O anywhere, then result would be utter chaos
09:13:21 <EvanR> happy accident in a way because pure code has a better chance of being optimized
09:13:44 <pigmej[m]> I have to agree that "pure" code looks and works neat
09:13:46 <pigmej[m]> and changing it is a pleasure
09:14:00 <pigmej[m]> but any impure thingy in a stack and all Haskell magic and beauty gone forever
09:14:05 <pigmej[m]> that's my feeling currently
09:14:10 <EvanR> pretty much
09:14:17 <EvanR> but there are tricks
09:14:33 <EvanR> well, there are things that can use I/O but are technically pure
09:14:54 <EvanR> and there are times when the impure effect is "Stuff I don't care about(TM)"
09:15:18 <maerwald> IO is pure
09:15:42 <maerwald> purity isn't that great for reasoning about your code, but is useful for evaluation semantics
09:15:53 <EvanR> i beg your pardon
09:16:00 <pigmej[m]> ok but look. https://gist.github.com/pigmej/63b5914630e5a06da4394cac00352216 that's a sample and stripped down code
09:16:18 <pigmej[m]> if I want to use STM in addItem then I'm screwed
09:16:38 <pigmej[m]> same for IO (which I need)
09:17:02 <EvanR> STM is just a nice limited form of IO
09:17:10 <EvanR> same animal kingdom
09:17:38 <geekosaur> you have to start out in IO anyway
09:17:51 <geekosaur> the beauty of IO is you know where it is and where it isn't
09:17:59 <EvanR> you can't arrange for STM to basically do everything IO can do if you want, by having a thread interpret the I/O needs
09:18:10 <EvanR> you CAN arrange....
09:19:48 <EvanR> pigmej[m]: probably other people said this already but... just make addItem an STM action
09:20:07 <pigmej[m]> what do you mean? :)
09:20:10 <pigmej[m]> `<-` ?
09:20:16 <EvanR> change the type
09:20:58 <EvanR> addItem :: SymbolStore -> MarketSymbol -> STM ()
09:21:01 <NemesisD> what's a good way to tag multiple type-level values onto a value with Tagged? i'm looking to do something like `Tagged ("str", 'Foo, 42) Int`
09:22:16 <pigmej[m]> EvanR tha's what I'm saying about,
09:22:23 <pigmej[m]> then I'll have to change all my stuff to STM a from a
09:22:27 <pigmej[m]> and pass it down the stack
09:22:57 <pigmej[m]> not to mention that adding STM Integers sounds at least awkward so probably other pieces of code have to be modified etc
09:23:05 <pigmej[m]> and that's exactly what I meant :)
09:23:21 <EvanR> what is with the Integer
09:23:44 <maerwald> this sounds like "I want to use STM, but I don't want to use STM" :P
09:24:07 <geekosaur> sounds to me like hasn't figured out <- yet
09:24:47 <pigmej[m]> geekosaur if I'm not mistaken <- will not change the type
09:24:47 <EvanR> i agree this program would be much simpler if it had absolutely no effects at all
09:24:58 <pigmej[m]> EvanR ;-)
09:25:27 <geekosaur> pigmej[m], the point of <- is you can take a value "out of" IO or STM, as long as the ultimate result is back in it.
09:25:45 <pigmej[m]> yeah
09:25:46 <pigmej[m]> but it still requires a return type to be IO afaiu
09:25:51 <pigmej[m]> at least compiler says me so
09:25:55 <geekosaur> so you have an operation that produces STM Integer, you use <- to get the vauet;s an Integer. but you need to finish with an operation in STM
09:26:01 <geekosaur> same with IO, yes
09:26:14 <EvanR> that's just the way it goes
09:26:16 <geekosaur> but you end up there anyway most of the time so what is the problem?
09:26:52 <pigmej[m]> a constant refactor
09:27:04 <pigmej[m]> that's what I've pointed at the beginning
09:27:12 <geekosaur> do x <- someOpInIO; y <- someOtherOpInIO; print (x + y) -- you're extracting the result from the program somewhere...
09:27:37 <pigmej[m]> haskell by design forces me to first think then work on code, but when my understnading of topic is too weak then it's mess
09:27:49 <pigmej[m]> that's probably why you all here can't understand my frustration now ;)
09:27:58 <tdammers> we can
09:28:06 <tdammers> we're just telling you that that's not the entire reason
09:28:18 <EvanR> if you havent successfully written any I/O code yet, then the reason for frustration is obvious. 
09:28:27 <tdammers> haskell forces you to think before you write, but it doesn't force you to think through your entire design upfront
09:28:35 <tdammers> only the part you are about to write
09:28:39 <EvanR> it's your first day on the job
09:29:43 <pigmej[m]> https://gist.github.com/pigmej/ea72ca90e3aec9ab18423b5927aecaaa
09:29:46 <pigmej[m]> that's stripped down code
09:29:56 <pigmej[m]> (it's probably shitty)
09:30:13 <EvanR> what is the role of this Integer
09:30:18 <pigmej[m]> and it doesn't make sense because of empinees in addItem
09:30:38 <pigmej[m]> imagine line 9 to return `0`
09:31:24 <pigmej[m]> or let's say the code is: https://gist.github.com/pigmej/a6eb33f85fb7d60a23e46777a00d0684
09:31:50 <pigmej[m]> and my frustartion is that I have to do IO and STM in `addItem` and `addItemBad`
09:32:08 <EvanR> if you just want to modify a store, then everything past getPOSIXTime can be pure code
09:32:14 <EvanR> just take the store and return the modified store
09:32:17 <pigmej[m]> (probably some forkIO or async stuff)
09:32:28 <pigmej[m]> ?
09:33:01 <EvanR> addItem :: MarketSymbol -> SymbolStore -> SymbolStore
09:33:22 <EvanR> not sure where you are using IO after getPOSIXTime
09:34:17 <EvanR> then to avoid error prone threading versions of the store around, you could use a State monad
09:34:47 <pigmej[m]> that store will be rather huge
09:35:19 <EvanR> so?
09:37:12 <sshine> I just did 'stack install cabal-install'. it feels like wearing a hat upside down.
09:37:35 <shapr> sshine: that's a great mental image
09:38:05 <sshine> I think it makes sense in my case. but it just feels weird. :)
09:38:13 <sshine> I wasn't even sure it was going to work.
09:38:15 <shapr> oh hey, does cabal 3 re-enable options like --test-pattern? I 
09:38:37 <shapr> I gotta see if I can run a subset of tasty tests in the fp-course
09:38:39 * shapr is excited
09:39:46 <sshine> what fp-course?
09:40:05 <shapr> this one https://github.com/data61/fp-course/
09:41:18 <shapr> yay! I can run a subset of the tests again! > cabal test tasty --test-option=--pattern="List"
09:41:34 <sm[m]> sshine: why wouldn't it work ? Next you can cabal install stack and turn your hat right way up :)
09:42:20 <shapr> now I want a Haskell hat
09:43:13 <geekosaur> is that a hat with a >>= on it or a hat that looks like a >>= ?
09:43:28 <shapr> I don't know!
09:45:10 <shapr> so the original fp-course tests were > cabal test tasty --show-detail=direct --test-option=--pattern="List.headOr"
09:45:28 <shapr> Any idea what --show-detail=direct used to do?
09:55:53 <sshine> do I need two copies of GHC if I'm going to compile separate projects via cabal-install and stack?
09:56:21 <geekosaur> generally yes; stack really wants to manage its own playground
09:56:35 <geekosaur> including ghc
09:56:52 <sshine> I just forked some project without a package.yaml, and I did 'stack install cabal-install', and doing 'cabal build' gives me 1) a legacy v1 warning, and 2) "cabal: The program 'ghc' version >=7.0.1 is required but it could not be found."
09:58:37 <fendor> sshine, if there is a stack.yaml, you still can use stack
09:59:41 <fendor> sshine, if you want to use cabal, upgrade cabal-install with cabal v2-update; cabal v2-install cabal-install and install ghc with ghcup or your package manager
10:00:13 <sshine> there isn't. but you know what, I just learned about `hpack --convert`!
10:00:51 <fendor> sshine, without stack.yaml, stack wont work
10:00:57 <kezimo> hello
10:01:14 <sshine> fendor, I'll see how much it takes to get it running on the latest Stackage LTS.
10:01:16 <kezimo> anyone here
10:01:23 <kezimo> sshine, what are you up to today
10:01:34 <fendor> sshine, depends on your project. 
10:01:56 <fendor> just try `stack init --resolver lts-14.5`
10:02:01 <fendor> or stack init
10:02:02 <ski> @where Data61
10:02:03 <lambdabot> Data61 Functional Programming Course <https://github.com/data61/fp-course>,<https://qfpl.io/links/2017-october-fp-course/> by Tony Morris,Mark Hibberd. Also see the channel #qfpl
10:03:02 <sshine> fendor, oh! good idea. `stack init` won't call `hpack --convert`, will it?
10:03:11 * shapr starts to complain about open source Haskell libraries, decides to send in fixes instead
10:03:15 <fendor> no, but you dont need a package.yaml
10:03:47 <shapr> glguy: I really like config-schema and friends
10:03:50 <sshine> fendor, oh, right. good point. I'll wait with trying that out, then. :) seemed interesting.
10:04:08 <sshine> kezimo, I am trying to port an old package into the present day so that I don't get dependency errors.
10:04:32 <shapr> what's the cabbage?
10:04:45 <shapr> I'm still trying to rename "cabal package" to cabbage, but I think it'll never work.
10:06:03 <EvanR> i'm on board
10:06:12 <sshine> shapr, aeson-diff-generic! if you're asking me :)
10:08:08 * shapr looks at aeson-diff-generic
10:08:40 <shapr> oh that's neat
10:10:05 <ski> ("cabbage" sounds cute)
10:10:11 <sshine> I've adopted it.
10:10:47 <dotKuro_> Is it possible to have a custom install process for your stack project? I can't find documentation on that
10:13:35 <sshine> shapr, yes, it looks super neat. so I'm going to write an editor for a specific JSON format, rather than update a file directly. and if the format of the file is extended, my editor will still be compatible with the subset it recognizes.
10:14:05 <shapr> neato
10:17:15 <sm[m]> dotKuro_: i assume the olde Setup.hs still works, as with cabal
10:17:59 <dotKuro_> But there is no way i can modify what stack install will do?
10:18:00 * hackage servant-static-th 0.2.2.1 - Embed a directory of static files in your Servant server  https://hackage.haskell.org/package/servant-static-th-0.2.2.1 (cdepillabout)
10:25:38 <sm[m]> Probably not, aside from adjusting its paths or changing stack
10:36:00 * hackage astar-monad 0.1.0.0 -   https://hackage.haskell.org/package/astar-monad-0.1.0.0 (ChrisPenner)
10:45:58 <shapr> sshine: you might like the fp-course if you haven't already tried it, it's fun!
11:08:19 <pigmej[m]> EvanR: i’m afraid of making huge copies of data. I could potentially use some standard map and lock or wherever but you get the point
11:08:27 <pigmej[m]> (sorry I had to make my toddler to sleep)
11:12:32 <EvanR> well, haskell has persistent data structures that can be modified without copying the entire thing
11:12:52 <EvanR> i assumed you were already using one
11:15:04 <pigmej[m]> I wanted to use stm contaiers and previously I have used hashmap from unordered containers
11:16:49 <EvanR> stm container?
11:17:06 <EvanR> hashmap is actually one of the persistent structures i was refering to
11:17:14 <EvanR> you can update it without incurring a full copy
11:17:14 <geekosaur> stm isn't so much about containers as about communication channels
11:45:35 <pigmej[m]> There is a lib called stmcontainers ;)
11:45:42 <pigmej[m]> that’s why I was reffering to it.
11:46:13 <pigmej[m]> http://hackage.haskell.org/package/stm-containers
11:46:41 <gentauro> anybody heard of "Holland & Hart"?
11:46:46 <gentauro> https://functional.works-hub.com/jobs/remote-software-engineer-3cb
11:47:08 <fizbin_> Rough opinion: Should stack.yaml.lock files get committed to version control or not?
11:47:19 <gentauro> fizbin_: yeah
11:47:34 <gentauro> the lock is local iirc
11:58:00 * hackage newtype 0.2.2.0 - A typeclass and set of functions for working with newtypes.  https://hackage.haskell.org/package/newtype-0.2.2.0 (HerbertValerioRiedel)
12:38:03 <mupf> https://twitter.com/mupfelofen/status/1171506940901392384
12:40:24 <merijn> mupf: Nice! I thought about doing that for a while, but it kept slipping due to business
12:41:37 <mupf> merijn: nice. I
12:41:44 <mupf> I'm glad I made a backup in time
12:42:43 <mupf> Maybe I upload some of his older sites later on.
12:43:39 <zincy_> What http request library do you recommend?
12:44:11 <merijn> zincy_: For what purpose?
12:44:18 <merijn> zincy_: Just dumbly fetching single pages?
12:44:34 <zincy_> For querying the Stripe API
12:44:47 <zincy_> Json
12:44:50 <merijn> I've used http-conduit in the past and that was nice and simple
12:45:02 <merijn> I think there's a https version/wrapper
12:45:04 <zincy_> Thanks will have a look
12:51:27 <nshepperd2> wreq is quite nice imo
12:54:41 <koz_> nshepperd2: I know it's meant to be short for 'web request', but when I read that, I could only think 'wreck' and I found that funny.
12:55:52 <nshepperd2> For wrecking those json APIs :)
12:58:31 * geekosaur thinks the web is mostly a wreck these days…
12:59:17 * koz_ agrees with geekosaur.
13:01:00 * hackage kind-generics-th 0.2.1.0 - Template Haskell support for generating `GenericK` instances  https://hackage.haskell.org/package/kind-generics-th-0.2.1.0 (AlejandroSerrano)
13:21:35 <Fimmind> @pl \h t -> h : return t
13:21:35 <lambdabot> (. return) . (:)
13:26:45 <dmwit> ?pl \h t -> [h,t]
13:26:45 <lambdabot> (. return) . (:)
13:27:11 <dmwit> > (length "\\h t -> [h,t]", length "(. return) . (:)")
13:27:13 <lambdabot>  (13,16)
13:27:27 <dmwit> The pointful version is shorter *and* more readable. =P
13:28:01 <Fimmind> I agree
13:28:22 <dmwit> > (length "\\h t->[h,t]", length "(.pure).(:)")
13:28:24 <lambdabot>  (11,11)
13:28:52 <Fimmind> But pintfull version is still more readable
13:29:12 <dmwit> ^_^
13:40:54 <exarkun> Some good way to predict or discover the path ".stack-work/install/x86_64-linux-nix/lts-14.1/8.6.5/hpc/"?  eg, so it can be captured on CI and stored as a build artifact?
13:43:06 <rndd> hi everyone. Excuse me for the silly qustion. But I really dont understand the definition of "=>" in haskell. Please, give me any kind of reference =|
13:43:25 <sm[m]> zincy_: https://github.com/mrkkrp/req#motivation-and-req-vs-other-libraries may be of interest
13:44:02 <sm[m]> exarkun: stack path command
13:45:56 <exarkun> sm[m]: thanks
13:48:08 <dmwit> rndd: Turn to the typeclass section of whichever tutorial you favor, I guess.
13:48:36 <dmwit> If you are not currently following along with any particular tutorial, you might check the wiki page for some suggestions.
13:48:39 <dmwit> ?where tutorials
13:48:39 <lambdabot> http://haskell.org/haskellwiki/Tutorials
13:49:22 <sm[m]> I was looking for a nice beginner explanation of this, and it wasn't that easy - how about https://en.wikibooks.org/wiki/Haskell/Type_basics_II
13:49:56 <lavalike> exarkun: did you end up untangling the Hspec/QuickCheck/Servant/Wai/... kerfuffle
13:50:38 <rndd> dmwit: thank you
13:56:46 <exarkun> lavalike: no
13:57:04 <exarkun> lavalike: I got sick, haven't worked on it since last week
14:16:31 * hackage unbound-kind-generics 0.2.1.0 - Support for programming with names and binders using kind-generics  https://hackage.haskell.org/package/unbound-kind-generics-0.2.1.0 (AlejandroSerrano)
14:16:46 * shapr takes off his binders
14:17:26 <Rembane> Only purity left?
14:20:33 <shapr> Rembane: everything is pointless now
14:23:38 <Rembane> shapr: It is 
15:21:29 <sshine> From the PVP guide: "Note that modifying imports or depending on a newer version of another package may cause extra orphan instances to be exported and thus force a major version change." -- but how do I know this?
15:27:02 <lyxia> I'm not sure there's an easy way
15:40:10 <sshine> :(
15:43:28 <t7> what would the world look like if full type inference was possible for system F
15:44:08 <t7> and subtyping etc 
15:44:27 <sshine> lyxia, maybe I can trust that since none of the packages I'm bumping have major version upgrades, they are not doing it, and in turn, I am not doing it.
15:44:38 <t7> i guess rust type inference would not have to get into a loop
16:03:00 * hackage vega-view 0.3.0.1 - Easily view Vega or Vega-Lite visualizations.  https://hackage.haskell.org/package/vega-view-0.3.0.1 (DouglasBurke)
16:03:34 <iqubic> I just found a use for `on` that wasn't anything related to sorting.
16:16:14 <iqubic> @pl (\x y -> not (x == y))
16:16:14 <lambdabot> (/=)
16:16:39 <iqubic> @pl (\x y -> not (compare x y))
16:16:39 <lambdabot> (not .) . compare
16:17:08 <iqubic> :t (\x y -> not (compare x y))
16:17:09 <lambdabot> error:
16:17:09 <lambdabot>     • Couldn't match expected type ‘Bool’ with actual type ‘Ordering’
16:17:09 <lambdabot>     • In the first argument of ‘not’, namely ‘(compare x y)’
16:32:23 <merijn> iqubic: on is actually bad for sorting, btw :)
16:34:51 <merijn> Since it runs the conversion function multiple times per element (again on each comparison), comparing avoided that, iirc
16:38:22 <nil> can anyone point me to a non-trivial MonadPlus instance? that is, one that doesn't use the default Alternative-based definitions
16:42:01 <nil> i'm considering using (Monad m, Alternative m) instead of MonadPlus m, considering how useless MonadPlus seems to be
16:42:03 <jle`> nil: MonadPlus is supposed to be equivalent to Alternative i believe
16:42:07 <scaredysquirrel> would you guys please show me to an award winning book
16:42:23 <jle`> nil: for the most part i think you can treat type MonadPlus m = (Monad m, Alternative m)
16:42:39 <jle`> nil: except, there are some extra laws associated with an instance of MonadPlus that aren't associated with Alternative
16:43:05 <jle`> so you can think of MonadPlus as Alternative + extra laws that can't be in Alternative
16:43:29 <nil> yeah, that's my question. is there any known case of those laws not being respected by the default Alternative instance, and therefore require different definitions for mzero (and possible mplus)
16:43:36 <nil> requiring*
16:43:41 <nil> possibly*
16:43:55 <jle`> no, that wouldn't be a valid MonadPlus instance, because mzero = empty is one of the laws I believe
16:44:09 <nil> no, that's just the default definition http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#v:mzero
16:44:19 <jle`> hm, yeah it looks like it isn't an officially documented law
16:44:29 <jle`> but i think it is a clear expectation that instances shouldn't break
16:44:47 <jle`> i would treat it as a law in the same way as return = pure, mappend = (<>)
16:45:23 <jle`> i'd say any instance that breaks this expectation is Bad
16:46:24 <nil> instance BadMonadPlus m where mzero /= empty
16:47:23 <nil> i'll stop using MonadPlus then, and hope it gets removed from the language eventually
16:48:03 <jle`> it deserves a space in the language I believe, because there are laws associated with it
16:48:16 <jle`> giving your type an instance of MonadPlus means that it satisfies the MonadPlus laws/expectations
16:48:31 <jle`> but having just (Monad m, Alterantive m) doesn't guarantee it
16:48:38 <nil> i think those laws should be moved somewhere else
16:48:45 <jle`> where would they be moved to?
16:48:50 <nil> more generally i don't think laws should be tied to one typeclass
16:49:10 <nil> there should be laws of the form "if m is both a Monad and an Alternative, then it should satisfy these laws"
16:49:14 <jle`> what if you wanted to make an instance of Alternative that doesn't satisfy MonadPlus laws
16:49:22 <jle`> that should be allowed, I think
16:49:33 <nil> i can't see the point of that
16:49:39 <nil> maybe i haven't thought about it hard enough
16:49:46 <jle`> well, you might not have a choice ...
16:49:51 <jle`> if your instance doesn't satisfy MOnadPLus rules
16:49:56 <jle`> it's not like you can magically make them obey it :)
16:50:56 <nil> i can't think of any sensible Monad/Alternative instance in which binding something to empty doesn't result in empty
16:52:39 <nil> but i guess this is almost philosophical and requires careful thought
16:53:24 <jle`> either way (theoretically possible or not), it plays an important role in documentation
16:57:01 <nshepperd> the absence of laws saying that empty = mzero and (<|>) = mplus seems odd, given that Alternative is a superclass
16:57:58 <nil> those laws would make MonadPlus entirely useless
16:58:14 <jle`> well, it would make mzero and mplus useless
16:58:30 <jle`> but MonadPlus as an methodless typeclass would still be useful
16:58:38 <nil> how so?
16:58:57 <nil> seems like just syntactic sugar for avoiding to write (Monad m, Alternative m)
16:58:57 <jle`> (Monad m, Alterantive m) => ... wouldn't allow you to make reductions like empty >>= ... = empty
16:59:10 <jle`> but MonadPlus m => .... would allow you to make that program substitution
16:59:13 <nil> why not?
16:59:28 <jle`> because given (Monad m, Alternative m), empty >>= x = empty is not a valid program substitution
16:59:38 <jle`> no laws of Monad or Alternative can justify it
17:00:00 <nil> but you can move the laws
17:00:06 <jle`> to where?
17:01:02 <jle`> it would be nice to have a typeclass specifically to indicate that a type's instances follow that law
17:01:34 <jle`> i don't see another reasonable alternative
17:01:51 <jle`> fwiw a similar situation occurs in 'finer-grained' abstract algebra libraries, which offer a class like
17:01:54 <nil> much like Applicative has a paragraph that goes "If f is also a Monad, it should satisfy: [...]", Alternative could have one saying "If f is also a Monad, it should satisfy: empty >>= f = empty, v >> empty = empty"
17:02:23 <jle`> nil: but what if i wanted to write an Alternative instance for Monad that *doesn't* satisfy empty >>= f = empty ?
17:02:30 <nil> and Monad could even have the corresponding "If f is also an Alternative, it should satisfy: [...]" for extra clarity
17:02:31 <jle`> it would be a perfectly valid Alternative instance
17:02:40 <nil> jle`: you couldn't
17:02:47 <nil> that would violate the laws
17:02:54 <jle`> only these new laws you are talking about
17:03:04 <nil> yes
17:03:25 <jle`> right, but now what if I wanted to write a type that has a valid and useful Alternative instance and also a valid Monad instance, but doesn't satisfy the laws
17:03:33 <jle`> now those instances would be needlessly disallowed
17:04:06 <jle`> doesn't satisfy empty >>= f = empty, i mean 
17:04:24 <nshepperd> and code that uses Monad and Alternative but doesn't depend on these new laws would have no way to say 'no, i don't care about empty >>= f = empty'
17:04:26 <jle`> there should be the ability to define an Alternative instance where empty >>= f is not empty
17:04:26 <nil> you can apply the same logic to Applicative and Monad
17:04:40 <jle`> nil: how?
17:04:56 <nshepperd> The "If f is also a Monad" paragraph in Applicative is just a relic from when Applicative wasn't a superclass of Monad
17:04:57 <nil> there are currently laws that prevent you from writing an Applicative and a Monad instance that don't match, even if each instance is perfectly valid
17:04:59 <pikajude> what's the type of the first argument to f?
17:05:15 <nil> nshepperd: ?
17:05:43 <nshepperd> that paragraph should be deleted since it's redundant now
17:05:49 <nil> it's not
17:05:54 <nil> every Applicative isn't a Monad
17:06:01 <nil> wrong way around?
17:06:09 <nshepperd> no, but every Monad is an Applicative
17:06:11 <jle`> nil: in that case, the type of instances that it outlaws would be confusing
17:06:15 <nshepperd> and Monad has those laws https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#t:Monad
17:06:28 <nil> right
17:06:42 <jle`> but not having empty >>= f = empty is not necessarily confusing behavior
17:06:46 <nshepperd> the laws relating Monad and Applicative rightly belong in Monad, not Applicative
17:06:50 <jle`> if you aren't MonadPlus
17:07:09 <nil> nshepperd: i can agree with that
17:07:15 <jle`> there's an analogous situation that a lot of abstract algebra typeclass hierarchies have
17:07:28 <jle`> if we have class Monoid a => Group a where inverse :: a -> a
17:07:39 <jle`> then, we can have a class for Abelian groups, groups that are also commutative
17:07:47 <jle`> instance Group a => Abelian a where {}
17:08:04 <jle`> so here Abelian is an empty typeclass -- it's Group, with laws
17:08:29 <jle`> and writing (Group a => ...) is different than writing (Abelian a => ...)
17:08:37 <iqubic> But then you'd need a Group law like: "mappend x (inverse x) = mempty" I think.
17:08:47 <jle`> writing (Group a => ...) conveys that "no, you cannot rewrite x <> y as y <> x"
17:08:50 <jle`> necessarily
17:09:02 <jle`> and writing (Abelian a => ...) conveys "feel free to rewrite x <> y as y <> x"
17:09:24 <iqubic> Am I right about that potential Group law? Or am I just wrong?
17:09:28 <jle`> similarly, writing ((Monad m, Alternative m) => ...) conveys "please do not rewrite empty >>= f as empty"
17:09:29 <nil> i understand how an "empty" typeclass is useful in that context
17:09:41 <nshepperd> iqubic: yes, that's right
17:09:42 <jle`> and writing (MonadPlus m => ...) conveys "feel free to rewrite"
17:10:11 <nil> but to push the "philosophical" argument further, it seems to me that empty is/should be tied to a notion of failure, which in turn induces the >>= unit laws
17:11:15 <iqubic> I don't see how empty being tied to failure should induce the >>= unit laws.
17:11:29 <nil> see the MonadFail laws
17:11:42 <jle`> iqubic: it basically says "you cannot continue from a failure"
17:12:05 <jle`> at this moment empty is not tied to any notion of failure
17:12:17 <iqubic> Correct.
17:12:48 <nshepperd> it's just morally wrong to have laws relating to more than one constraint, imo
17:13:05 <jle`> empty is right now freed to take on any meaning, more than just failure
17:13:15 <nshepperd> (Monad m, Alternative m) shouldn't mean more than the sum of its parts, that's confusing
17:20:13 <nil> so, to rephrase it, my point is empty should convey the idea of computational failure, as (Applicative) functors are widely thought of as "computations with effects" already, and Alternative is a subclass of Applicative. this requires having laws that are "shared" between Monad and Alternative (and could be documented in both classes), which i don't find that awkward, given that these laws are really tied to
17:20:13 <nil> the computational view of functors
17:20:19 <nshepperd> 'v >> mzero   =  mzero' come to think of it, IO doesn't obey this monadplus law
17:20:54 <nil> hmm
17:21:00 <nshepperd> % forever (putStrLn "hello world") >> mzero
17:21:03 <yahb> nshepperd: hello world; hello world; hello world; hello world; hello world; hello world; hello world; hello world; hello world; hello world; hello world; hello world; hello world; hello world; hello world; hello world; hello world; hello world; hello world; hello world; hello world; hello world; hello world; hello world; hello world; hello world; hello world; hello world; hello world; hello world; hello world; hello world; hello world; hell
17:21:52 <nshepperd> % mzero :: IO ()
17:21:52 <iqubic> Huh?!?! What the heck?
17:21:55 <nil> % putStrLn "hello world" >> mzero
17:21:57 <yahb> nshepperd: *** Exception: user error (mzero)
17:21:57 <yahb> nil: hello world; *** Exception: user error (mzero)
17:23:34 <iqubic> nil: Functors and Monads don't have to be about effects.
17:24:32 <iqubic> Data Free f a = Pure a | Roll (f (Free f a))
17:24:46 <iqubic> That is a monad, but has 0 effects at all.
17:28:26 <pikajude> my question about mzero >>= f is what f does with its input
17:29:06 <iqubic> There is no input there.
17:29:43 <pikajude> right
17:30:54 <nshepperd> :t mzero >>= absurd
17:30:55 <lambdabot> MonadPlus m => m b
17:31:20 <pikajude> so what's an example of a case where you would want mzero on the LHS of bind
17:32:02 <nshepperd> (if condition then ... else mzero) >>= f
17:32:08 <mozzarella> should I learn haskell?
17:32:10 <pikajude> oh neat
17:32:17 <nshepperd> @src guard
17:32:17 <lambdabot> guard True  = pure ()
17:32:17 <lambdabot> guard False = empty
17:32:43 <pikajude> hmm so obvious answer in hindsight
17:33:24 <quiet_laika[m]> <mozzarella "should I learn haskell?"> yes!
17:33:29 <pikajude> it's a fun language
17:34:15 <quiet_laika[m]> im not most productive in haskell, personally, but the things ive learned while practicing haskell are all things i sorely miss when im writing python for work
17:34:50 <mozzarella> not a fan of python
17:35:09 <quiet_laika[m]> im not either, after learning haskell :p
17:35:59 <iqubic> I thought Java was the best language ever. Then I learned Haskell.
17:36:44 <nil> <lambdabot> guard False = empty 
17:36:54 <nil> if that doesn't tell you `empty` is about failure... :P
17:37:21 <pikajude> well that's the thing that confuses me about the earlier discussion
17:37:29 <pikajude> in what case would you want to proceed after failure
17:37:46 <nil> never, but that's not what's being discussed
17:38:02 <iqubic> Perhaps you have some sort of error handling you want to do in the case of failure.
17:38:03 <nil> we were discussing whether empty should *mean* failure
17:38:14 <pikajude> oh ok
17:38:44 <pikajude> iqubic: yeah but if i understood correctly that's the case where you'd use <|> or mplus or whatever
17:39:16 <pinecamp> using the Data.Time.Format library, is it possible to parse a "YYYY-mm-ddTHH:MM:SS" string (format string is "%FT%T") directly to a properly localized LocalTime or ZonedTime?
17:40:13 <pinecamp> the issue I think I'm having is that a time offset or time zone is not included in the string itself, and I'm not sure how to add it at parse time
17:42:46 <pikajude> can't you parse it as UTCTime and then convert it to zonedtime with the library functions
17:43:14 <nshepperd> you should parse that as a LocalTime (which doesn't have a timezone)
17:43:23 <pinecamp> pikajude: I can definitely do that. it just feels wrong to put it in a UTCTime typedrat 
17:43:27 <pinecamp> type, sorry
17:43:34 <pikajude> localtime would work too
17:43:38 <pikajude> if you wish
17:44:31 <scaredysquirrel> what book do I use to learn haskell?
17:45:06 <pinecamp> ahh, I think I get the structure now... LocalTime is an unspecified local time, and the localTimeToUTC function allows you to add TimeZone information
17:46:07 <pikajude> no it converts it to UTC given a timezone
17:46:12 <pikajude> so it adds or subtracts whatever hours
17:46:38 <pinecamp> pikajude: that's exactly what I'm looking for! :) sorry if I didn't explain it clearly
17:46:46 <pikajude> oh ok
17:47:39 <pinecamp> I guess the idea is that to process time values, you should typically go through UTC anyway
17:47:47 <nshepperd> you can think of a UTCTime as being a particular point in earth's physical history
17:47:54 <scaredysquirrel> what might use to learn haskell?
17:47:58 <pikajude> well a formatted time string without a zone attached doesn't give you sufficient information
17:48:06 <pikajude> that would be true for any language
17:48:44 <pinecamp> true. unfortunately that's how the API hands it to me, but I know the time zone, so I can accurately convert it to UTCTime
17:48:47 <nshepperd> and a LocalTime as being legal time in some unspecified locale (what you see when you look at your calendar and/or clock)
17:54:12 <scaredysquirrel> guys
17:54:14 <scaredysquirrel> what might use to learn haskell?
17:57:58 <nshepperd> @where learnhaskell
17:57:58 <lambdabot> https://wiki.haskell.org/Learning_Haskell
17:59:24 <no-n> scaredysquirrel: haskellbook.com
17:59:38 <no-n> also #haskell-beginners 
18:17:13 <dsal> Hi:  hackage question.  I'm working on a new version of a package I've got and it's not like, *completely* done.  I'm thinking about uploading a version before it's completely ready.  Is there a way to have a lower version as the "default" version?
18:17:27 <dsal> I'm breaking the API to add a bunch of new protocol features to MQTT.
18:21:37 <argent0_> dsal: https://hackage.haskell.org/upload#candidates there are candidates
18:22:37 <dsal> Can I reference candidates in normal projects?  That doesn't seem like *exactly* what I'm thinking, but it might make it easier for me to try things.
18:25:04 <argent0> dsal: idk
18:25:37 <dsal> I might just publish it and document that it's still got primer all over it.
18:27:46 <iqubic> Alright... I've gotten my Emacs + Haskell editing set-up to the point where where I'm getting auto-complete suggestions for modules that can be imported.
18:28:33 <iqubic> The coolest thing about my set-up is that it is suggesting modules that come from Hackage libraries defined in my Cabal file.
18:29:17 * argent0 strugles with vim while iqubic is living the dream.
18:30:00 <EvanR> same
18:30:09 <EvanR> who is this guy
18:30:32 <iqubic> And I have keybindings that let me get the type of the thing my cursor is on. It doesn't matter if the fuction is in prelude or from an external library.
18:30:50 <VaNilLa[m]> seems like this can be done using haskell ide engine and language servers / clients
18:30:59 <iqubic> I think a large part of this set-up is Nix + Dante.
18:33:02 <VaNilLa[m]> I'm 99% sure HIE can do this too, but I really haven't been writing much haskell recently
18:33:42 <VaNilLa[m]> I even have to turn off live auto-linting Haskell because it confuses my coworkers
18:33:53 <iqubic> I don't have auto-linting.
18:34:07 <dsal> I failed to get HIE working last time I tried.
18:34:13 <VaNilLa[m]> is that a choice? I quite enjoy using it
18:34:32 <iqubic> I just have HLint suggestions show up as wornings. I can then either chose to apply the suggestion, or not.
18:34:54 <iqubic> VaNilLa[m]: I don't use HIE.
18:35:16 <VaNilLa[m]> I know, but I'm sure Emacs can do it
18:36:02 <VaNilLa[m]> dsal: I have written up my steps to get HIE working here: https://danilafe.com/blog/haskell_language_server/
18:36:09 <iqubic> I don't care if Emacs can or can't do auto-linting. I don't want it.
18:36:10 <sm[m]> evening all. Where are docs for the cabal package description markup that hackage will render on the package page ?
18:36:31 <VaNilLa[m]> iqubic: that's what I was asking :)
18:36:55 <dsal> Argh, I keep tripping over GHC not being released for ARM.
18:37:08 <dsal> I guess I should build one.
18:37:36 <VaNilLa[m]> dsal: it can't be bad, I managed to get it working on ARM when I had a crappy chromebook
18:37:53 <VaNilLa[m]> if you run Arch, AUR might even have a GHC-from-source package
18:38:12 <dsal> I end up building my own GHC distributions for ARM and ARM64.
18:39:15 <VaNilLa[m]> it sucks that arm requires the most building from source, since arm processors tend to be optimized for low energy usage rather than performance. 
18:40:12 <dsal> Takes me like, a day.  Hopefully I'll remember why I was doing it when it's done.  :)
18:40:46 <VaNilLa[m]> at least you have a nice little space heater for that day :)
18:51:12 <dsal> My builder isn't ready to build an 8.6, so I have to remember how to do all these things, too.
18:52:18 <dsal> Oh, I've built 8.6.3 before.  So close.
18:57:15 <jusss> about Cont Monad, is there any difference with others?
18:58:00 <VaNilLa[m]> 8.6.3 is the last one I've built, too
19:03:31 <VaNilLa[m]> dsal: what OS do you run, and what's the builder you're referring to? I'm just curious
19:07:28 <dsal> VaNilLa[m]: armbian. I have a docker image I use for building.
19:17:27 <suzu> you can cross-compile for ARM
19:17:39 <suzu> that is, build a ghc that'll run on ARM, on a platform that is not ARM
19:18:50 <suzu> that said i have 0 clue how to do it and building ghc looks like a hellish experience
19:55:11 <turab> Is it correct to refer to effects like State, IO etc as first class citizens?
19:56:04 <turab> I was talking to a friend and realized this while explaining how side effects work in Haskell but I am not sure if correct
19:59:37 <VaNilLa[m]> cross compling is no easy task from what I know; I tried it with crystal lang, and that was a bit of an adventure
20:11:37 <ysangkok> turab: what does "first class" mean? i guess they are "first class" according to this definition https://softwareengineering.stackexchange.com/a/39854/24856
20:11:50 <maerwald> turab: yes
20:12:09 <maerwald> turab: there are no side effects during evaluation
20:12:24 <maerwald> > putStrLn "abc" `seq` 3
20:12:26 <lambdabot>  3
20:13:25 <dmj`> VaNilLa[m]: it's pretty easy with nix, there are prebuilt GHC to ARM compilers
20:13:27 <maerwald> Call them *effects*, not side-effects. And effects can be passed around like any other thing.
20:14:43 <dmj`> turab: IO was added later to Haskell, its second class
20:16:30 <maerwald> dmj`: how is that relevant? It's mentioned in the report
20:18:05 <dmj`> you could Haskell before there was IO
20:18:14 <dmj`> checkmate.
20:19:28 <maerwald> That isn't even relevant to the definition of first-class.
20:20:57 <dmj`> well maybe your definition of first-class isn't first-class
20:21:37 <maerwald> so you are saying the chronological order of which concepts appear determines whether something is first-class in a language or not?
20:21:49 <maerwald> so anything that was added ever is not first-class?
20:21:57 <VaNilLa[m]> dmj': I should get into nix :)
20:22:13 <maerwald> VaNilLa[m]: it's a time sink ;)
20:22:24 <dmj`> maerwald: ok fine, it's correct to say IO is a first-class thing in Haskell... but it wasn't always
20:22:43 <dmj`> VaNilLa[m]: you really should, it's much more powerful than haskell
20:23:50 <turab> Thanks all! The idea of "passing around effects" made me think of this and I really like the idea of reasoning about effects the same way I reason about anythin else :)
20:23:53 <VaNilLa[m]> I don't even use the full power of Haskell :P
20:24:39 <maerwald> turab: well, you cannot reason much about effects in IO, but you know there *are* effects
20:25:55 <turab> maerwald: Ah yes. Is my statement correct for effects like State, Writer etc?
20:26:00 <dmj`> VaNilLa[m]: that's a good thing, the type stuff in Haskell is half-baked
20:27:35 <maerwald> turab: also depends. Even if you have "well-defined" huge monad transformers with no IO, in practice people fail to reason about what is actually happening, because multiple behaviors are hidden behind one giant type
20:28:03 <turab> dmj`: What exactly is Nix? I have heard the term NixOs and Nix but not sure if they are the same thing. Any thing I can read to learn about this?
20:28:25 <VaNilLa[m]> nix is the functional language and package manager, NixOS uses it
20:28:35 <dmj`> ^
20:28:52 <turab> maerwald: I see
20:29:08 <dmj`> Nixpkgs is a set of nix expressions ( crowd sourced build recipes, with *first class* haskell support ) </jab at maerwald>
20:29:09 <maerwald> Just because something is well and strongly typed, doesn't mean it's easy to reason about it
20:29:44 <maerwald> dmj`: it doesn't have first class haskell support, because it depends on stackage :)
20:29:45 <VaNilLa[m]> could you elaborate on the first class support?
20:30:04 <maerwald> so if you need packages/versions outside of stackage, you'll have a fun time
20:30:58 <dmj`> It's had everything I've ever needed, and when it doesn't, I just callCabal2nix "pkg" (pkgs.fetchFromGitHub {..}) {} and you're good to go
20:31:05 <maerwald> dmj`: haha
20:31:15 <maerwald> good if your use case is simple ;)
20:31:29 <dmj`> maerwald: I've been at 3 companies that were fully on nix, nixpkgs and NixOS, I never want to go back.
20:31:46 <dmj`> and nixops
20:31:48 <dmj`> nixops is fantastic
20:31:52 <maerwald> uh-oh
20:31:54 <VaNilLa[m]> hmm.... how should I get started with nixos? I've been meaning to either way
20:32:24 <dmj`> VaNilLa[m]: can use virtual box quick, or make a bootable ISO
20:32:45 <dmj`> https://nixos.org/nixos/download.html
20:33:02 <VaNilLa[m]> thanks :)
20:33:12 <dmj`> maerwald: have you hit a use case that nix couldn't handle well ?
20:33:45 <maerwald> dmj`: yes, complexity
20:34:23 <maerwald> nix is a lot of expressive power with no attempt to maintain low complexity
20:34:43 <dmj`> that's the programmer's job
20:35:00 <maerwald> And I prefer to pick tools that have low complexity :)
20:35:12 <maerwald> Unless I need something I cannot express
20:35:16 <dmj`> maerwald: I have a nice tree structure package namespace thing that works great
20:35:33 <VaNilLa[m]> Interesting, I wouldn't associate Haskell with low complexity either
20:35:40 <dmj`> maerwald: well picking Haskell was the wrong choice then lol
20:35:48 <maerwald> dmj`: absolutely
20:35:51 <dmj`> since you've already come this far, might as well keep going
20:35:59 <maerwald> dmj`: no
20:36:08 <VaNilLa[m]> ^ that sounds like the sunk cost fallacy
20:36:12 <dmj`> maerwald: resistance is futile
20:36:22 <maerwald> dmj`: not caring about complexity is
20:36:40 <maerwald> if you need something complex to solve something, then well, if you don't... then you don't
20:36:48 <dmj`> using weak tools also brings complexity
20:36:55 <maerwald> picking tools just based on expressivity is a dangerous attitude imo
20:37:10 <dmj`> nix isn't complex imo. 
20:37:13 <VaNilLa[m]> things are getting heated :S
20:37:34 <dmj`> no more complex than say python
20:37:35 <maerwald> not at all, just morning routine ;)
20:37:52 <maerwald> dmj`: I totally I agree. I think most of the time we should not be doing programming in turing complete high level languages
20:38:14 <maerwald> The fact that we do already indicates that we failed in programming as an engineering science
20:38:32 <VaNilLa[m]> maerwald: so you say, use weakest language possible?
20:38:37 <maerwald> absolutely
20:38:56 <maerwald> that is also the conclucion in security and safety
20:38:59 <VaNilLa[m]> what's your reasoning for that?
20:39:18 <maerwald> complexity is your enemy and grows exponentially
20:39:25 <VaNilLa[m]> (C is a less complex language than Rust; arguably, Rust is safer and more secure)
20:39:56 <maerwald> VaNilLa[m]: hmm, that's a long discussion about how to define complexity of course
20:40:16 <maerwald> I would say both are similarly complex with programs written in C usually having higher accidential complexity
20:41:14 <maerwald> https://blog.ploeh.dk/2019/07/01/yes-silver-bullet/ is also interesting
20:41:22 <maerwald> although I disagree with the conclusion
20:41:58 <EvanR> i'm starting to see all code complexity as accidental
20:42:01 <maerwald> I think most of the time we should be writing DSLs
20:42:08 <maerwald> Not programs
20:42:49 <VaNilLa[m]> hmmm. I agree that C probably has a more complex notional machine, so you're probably right there
20:43:25 <maerwald> VaNilLa[m]: I'm not sure if the same would be true if you were to write a kernel in rust though, because you might lose some low-level reasoning that is easy in C
20:43:29 <maerwald> so it's hard to define
20:43:50 <VaNilLa[m]> unfortunately, I need to get back to working on a project, and thus, I will postpone reading the blog you linked in fear of getting sucked back into a certainly interesting discussion
20:48:50 <rajivr___> I am new to Haksell, I was wondering why I cannot define `instance Sumthin (Char)` here? https://gist.github.com/rajivr/2b13fe360296fea064cecd4b4719c2c9
20:49:34 <rajivr___> It give an error `‘a’ is a rigid type variable bound by`, which is an error message I am unable to understand.
20:55:00 <jle`> rajivr___: hm, try defining class Sumthin a where s :: a -> a, instead
20:55:12 <jle`> you might be shadowing the 'a' if you use forall there on line 17
20:56:30 <rajivr___> jle`:  Thanks! Let me try that! :-)
20:58:51 <rajivr___> jle`:  Thanks again! :-) It seems to have worked at least for the compiler.  I now need to understand why it worked! :-)
20:59:32 <ski> yea, you didn't want `s' to be a polymorphic method
21:00:40 <ski> in `instance Sumthin Char where ...' you want to define (monomorphic) `s :: Char -> Char', not (polymorphic) `s :: forall a. Sumthin a => a -> a'
21:01:22 <ski> saying `class Sumthin a where s :: forall a. Sumthin a => a -> a' is the same as saying  `class Sumthin a where s :: forall b. Sumthin b => b -> b'
21:01:53 <ski> so, when `a' becomes `Char' in the above `instance Sumthin Char where ...', `b' will not become `Char'
21:01:58 <ski> rajivr___ : makes sense ?
21:03:28 <rajivr___> ski: Thanks. Yes, its making sense. I still need to internalize it.
21:04:24 <ski> consider e.g.
21:04:27 <ski> @src Eq
21:04:27 <lambdabot> class Eq a where
21:04:27 <lambdabot>     (==), (/=) :: a -> a -> Bool
21:04:39 <ski> the two methods here are *monomorphic* methods
21:05:59 <ski> iow, when making an instance for a type, say a completely specified one, like `Ordering' (as opposed to say `Maybe a', given an `Eq a' constraint), we will have to define `(==)' ior `(/=)' as *monomorphic* operations (operating on specifically `Ordering')
21:06:08 <ski> otoh, if you consider
21:06:12 <ski> @src Functor
21:06:12 <lambdabot> class Functor f where
21:06:12 <lambdabot>     fmap :: (a -> b) -> f a -> f b
21:06:30 <ski> then, this method signature is really short for
21:06:41 <ski>   fmap :: forall a b. (a -> b) -> f a -> f b
21:07:12 <ski> (but not binding the `f' in the `forall'. `f' is bound in the `class' head)
21:07:34 <ski> so, the method `fmap' *is* polymorphic (in `a' and `b', not in `f')
21:07:38 <ski> however
21:07:55 <rajivr___> Yes, I was reading Haskell book chapter on Functors when this example came up! :-)
21:08:23 <ski> if we just consider (say) `(==)' as "just another operation", not as a method of the type class, iow we consider it as separate from the type class, we'd had to assign it the signature
21:08:33 <ski>   (==) :: forall a. Eq a => a -> a -> Bool
21:09:02 <ski> so, considered as an ordinary operation, `(==)' is polymorphic !
21:09:30 <ski> it's only really when you define a method in an instance that this distinction is important
21:14:56 <rajivr___> ski: https://gist.github.com/rajivr/fa2b4451cfa91ec8a91b5223b2228bd2 
21:15:48 <rajivr___> So, `s :: forall {a}` is a _different_ `a` than `Sumthin a`?
21:24:34 <ski> yes, you were shadowing the `a' from the `class' head, as jle` said
21:25:27 <ski> in that paste, you're not shadowing, though
21:26:35 <ski> (with `:t' you'll ask for the type, it being considered as "any old operation". with `:i', you'll get the method signature, for methods)
21:27:37 <rajivr___> Does haskell have a syntax such as https://gist.github.com/rajivr/d1d93f956b01096b4ec954b21ada5323
21:28:02 <rajivr___>  this is what it really means right?
21:28:33 <jle`> rajivr___: yeah, the forall there is actually 'implied' and scoped in class declarations
21:29:12 <jle`> rajivr___: "shadowing" is what we call when you bring something into scope that has the same name as something that was already defined outside
21:29:49 <jle`> for example, if you write (\x -> (\y -> (\x -> x + y))), then inside the triple-lambda, the 'x' refers to the inner-most x
21:30:18 <jle`> so if you ever refer to an 'x' inside, it can only ever refer to the inner-most x, the last x that was introduced into scope
21:30:43 <rajivr___> jle`:  Thanks a lot to you and Stefan. Now it makes sense! :-)
21:30:52 <jle`> 'forall' in a function signature is essentially bringing in a type variable into scope, so if you bring a variable into scope with the same name as something outside of the scope, 'a' can only ever refer to the innermost scoping
21:30:57 <jle`> you're 'trapped', so to speak
21:31:13 <jle`> there isn't any way to refer to the outside 'a', or the outside 'x' in the case of the triple lambda above
21:32:21 <jle`> actually this is one thing i think is neat about languages like dhall, where there is a way to escape shadowing like this. you can write \x -> \y -> \x -> x@0 + x@1 + y@0, to pick which layer of x you want to refer to
21:32:30 <jle`> and just 'x' alone is sugar for x@0
21:32:51 <jle`> but probably the better thing to do is to just, as a programmer, avoid shadowing names
21:33:02 <jle`> if you enable -Wall, GHC might warn you about name shadowing in this situation
21:33:25 <rajivr___> jle`:  Haven't gotten to Dhall yet. Its is on my todo list after Haskell! :-) 
22:17:32 <ysangkok> i am wondering what the best practise is when having imperative code. i would like to reuse a binding name in my do-blocks so that i can be sure i won't accidentally use an old state. but if i do that, ghc complains. should i just disable that warning?
22:18:45 <ski> i suppose
22:19:18 <ski> (perhaps there should a a warning specifically for `<-'s, which one can then disable in particular)
22:19:36 * ski assumes ysangkok is talking about `<-', rather than `let'
22:19:39 <EvanR> now why have i always though redefining variable names in ruby or php was bad...
22:20:13 <EvanR> the way ysangkok says it, makes sense
22:20:34 <ski> i think it's not that uncommon, in the MLs
22:20:58 <ysangkok> ski: why is there a difference between monadic assignment (or whatever it is called) and let's?
22:21:55 <ysangkok> my issue is actually with let assignments though
22:23:03 <ski> `let' is recursive
22:23:05 <ski> `<-' isn't
22:23:28 <ski> `let x = x + 1' is not shadowing, `x <- pure (x + 1)' is
22:23:57 <ysangkok> ah yeah. so it is actually an even harder issue with let ... hmm
22:24:07 <ski> also, they're not `let'-assignments, they're `let'-bindings :)
22:25:02 <ski> state variable notation, in Mercury, <https://www.mercurylang.org/information/doc-latest/mercury_ref/State-variables.html>, is actually an interesting idea
22:28:22 <EvanR> let x = x + 1 is "just" binding a name (recursively in this case), and x <- pure (x+1) is doing an action, x is the result
22:28:48 <EvanR> but i just realized these examples are side stepping that distinction entirely
22:29:34 <iqubic> After reading a whole lot about Singletons, I must say... I somewhat understand them.
22:29:45 <iqubic> but only like 65%
22:29:47 <ski> > let x | x <- () = x in x
22:29:48 <lambdabot>  ()
22:30:19 <iqubic> Singletons are really really cool.
22:30:38 * ski misread iqubic as saying s/understand/underestimated/
22:30:53 <ysangkok> ah so i could just change all my let bindings to this monadic form with pure, and then i wouldn't have to worry about infinite loops...
22:31:00 <iqubic> ski: That too actually.
22:31:17 <iqubic> ysangkok: You'd still have to worry about infinite loops I feel.
22:31:41 <EvanR> you would not have to worry about THOSE infinite loops, but that is a really funny way to go about it
22:35:57 <ysangkok> well, seems to work. i'll ship it
22:36:02 <ysangkok> :P
22:36:25 <dmwit> ski: wow, gross
22:37:52 <dmwit> ysangkok: Perhaps you can arrange to use a state monad to manage your state for you, so that you don't need to use name shadowing.
22:39:13 * ski . o O ( here, here )
22:39:40 <ysangkok> hear hear. that is the proper solution
22:39:42 <ski> dmwit : i was curious whether it'd work with that kind of `<-'
22:41:48 <ski> > let ((1 +) -> x) | ((1 +) -> x) <- 0 = 1 + x in 1 + x
22:41:50 <lambdabot>  4
22:42:44 * dmwit snorts
22:49:30 * hackage antiope-athena 7.3.1 - Please see the README on Github at <https://github.com/arbor/antiope#readme>  https://hackage.haskell.org/package/antiope-athena-7.3.1 (arbornetworks)
22:50:31 * hackage antiope-sns 7.3.1, antiope-optparse-applicative 7.3.1, antiope-messages 7.3.1, antiope-contract 7.3.1, antiope-dynamodb 7.3.1, antiope-core 7.3.1, antiope-swf 7.3.1, antiope-sqs 7.3.1, antiope-s3 7.3.1 (arbornetworks)
22:58:48 <rsoeldner> When using `pipes`, how can I get a notification if the stream terminates or how can I handle the last element?
23:09:30 <dminuoso> rsoeldner: Its not possible if you use Pipe
23:10:17 <dminuoso> rsoeldner: If you have some kind of token to recognize end-of-input, akin to EOF, then that would work. Or perhaps its something that can be parsed, then you could use pipes-parse
23:11:11 <rsoeldner> dminuoso, what is the preferred alternative ? I need to handle the last element of the stream
23:12:15 <dminuoso> rsoeldner: well if feeding an EOF token is an option, I'd go for that.
23:35:09 <jusss> do I need to understand what is CPS before I learn Cont Monad?
23:36:57 <dminuoso> jusss: Well knowing CPS beforehand is probably useful, but there's really not much to say about it. :)
23:37:48 <jusss> dminuoso: is it useful? Cont
23:37:59 <dminuoso> jusss: No.
23:38:17 <mniip> occasionally
23:38:36 <mniip> you can definitely do some clever tricks with it
23:39:53 <dminuoso> Though in general Cont leads to very confusing code that is very hard to make sense of.
23:40:06 <mniip> on the contrary
23:40:24 <dminuoso> That being said, CPS itself is a useful technique.
23:40:35 <jusss> dminuoso: mniip is it related to concurrency?
23:40:40 <mniip> no
23:40:51 <mniip> most recent example of mine has been managing functions in Foreign.Marshall
23:41:19 <dminuoso> mniip: Well sure, there are occasions when Cont can make for quite concise code. But that's a subject for advanced users. :)
23:41:37 <dminuoso> I've had my share of "What did I just write?" experiences with Cont. :)
23:41:39 <jusss> dminuoso: is CPS related to Y-combinator?
23:42:01 <dminuoso> jusss: Not really.
23:44:18 <jusss> dminuoso: I remember CPS show up with anonymous function recursion in lisp
23:44:29 <jusss> and Y-combinator
23:44:35 <mniip> % :t ContT . Foreign.Marshal.withArray
23:44:35 <yahb> mniip: Foreign.Storable.Storable a => [a] -> ContT r IO (Ptr a)
23:44:38 <mniip> % :t ContT . BS.useAsCString
23:44:38 <yahb> mniip: BS.ByteString -> ContT r IO Foreign.C.String.CString
23:45:11 <mniip> % :t traverse (ContT . BS.useAsCString) >=> ContT . Foreign.Marshal.withArray
23:45:11 <yahb> mniip: [BS.ByteString] -> ContT r IO (Ptr Foreign.C.String.CString)
23:47:11 <mniip> it is, literally, interpreting continuation passing as an effect
23:47:16 <mniip> that you can monadically sequence
23:47:20 <dminuoso> jusss: They are not really related. CPS in general is about inversion of control.
23:47:27 <mniip> instead of manually nesting as you would do in a normal language
23:48:04 <jusss> dminuoso: so what is inversion of control, and dependency injection?
23:55:17 <EvanR> dependency injection ...
23:55:30 <MarcelineVQ> mniip: Cont not Codensity?
23:56:52 <MarcelineVQ> https://hackage.haskell.org/package/managed-1.0.6/docs/Control-Monad-Managed.html is Codensity with a nicer name if you're wondering what I'm asking
23:58:35 <mniip> MarcelineVQ, very little difference for our purposes
