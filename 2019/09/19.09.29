01:15:30 * hackage language-javascript 0.6.0.14 - Parser for JavaScript  https://hackage.haskell.org/package/language-javascript-0.6.0.14 (ErikDeCastroLopo)
02:22:25 <haskelllisp[m]> They describe each step that an expression may take during evaluation which may or may not terminate and converge on a value.
02:22:25 <haskelllisp[m]> `which may or may not terminate and converge on a value`
02:22:26 <haskelllisp[m]> how should i understand this sentence?   (may terminate || may not terminate || may also converge with a value) Does it express these three meanings?
02:23:19 <Rembane> If it doesn't terminate it can still terminate on a value. 
02:27:59 <haskelllisp[m]> So awkward...
02:32:19 <haskelllisp[m]> (may or may not terminate) and converge on a value.
02:32:20 <haskelllisp[m]> may or may not (terminate and converge on a value).
02:34:35 <Rembane> That is the curse of natural language. 
02:37:20 <haskelllisp[m]> I use google translation, saying: may terminate or converge with a certain value.
02:37:21 <haskelllisp[m]> I use youdao translation, saying: may terminate, or may not converge with a certain value.
02:37:21 <haskelllisp[m]> I don't know who to trust.
02:38:24 <vamshi> haskell
02:38:45 <vamshi> wtf
02:38:58 <lavalike> I know right
02:40:33 <vamshi> what are the uses of haskell like in production?, i want to do something with haskell, what is it good for? 
02:41:42 <Rembane> vamshi: Highly concurrent systems where you need things to not go wrong.
02:43:05 <vamshi> can you list things using haskell currently, that are in production?
02:44:59 <Rembane> vamshi: Facebook's antispam system.
02:45:33 <Rembane> vamshi: Here's another list: https://wiki.haskell.org/Haskell_in_industry
02:46:06 <vamshi> Yeah i looked into it, it's called sigma, the facebook's antispam engine. Thanks for the help!
02:46:30 * hackage lentil 1.3.1.0 - frugal issue tracker  https://hackage.haskell.org/package/lentil-1.3.1.0 (fffaaa)
02:46:48 <vamshi> What are you currently working on in haskell?
02:48:36 <vamshi> How good is haskell for data science and machine learning?
02:49:22 <Rembane> vamshi: not very good, use Python instead.
02:49:42 <Rembane> vamshi: I am currently working on generating programs for testing compilers. 
02:50:39 <vamshi> why not type out programs yourself?
02:52:18 <Rembane> Because generative testing can find many more bugs than I can, in much shorter time.
02:53:16 <vamshi> Oh, are you testing it on your own programmed compiler?
02:54:22 <trucy> "Who testes the tester?"
02:55:20 <vamshi> The tester tester
02:56:39 <Rembane> vamshi: Bingo! 
02:57:02 <vamshi> wow
02:57:33 <vamshi> do you have a github account?
02:59:05 <Rembane> It's not on Github yet, but will be there when we're done, it's part of a master thesis so it's a bit hush-hush. 
03:00:41 <vamshi> Oh thanks for responding to my annoying messages, Now i found a reason  to learn haskell, have fun coding, bye!
03:00:58 <Rembane> No worries. ^^
03:57:36 <jsomedon> https://i.redd.it/dbdshzzflgd31.jpg
04:25:25 <guest_18> Installing ghcup from https://www.haskell.org/ghcup/ with macports /opt/local/libexec/gnubin//tar, there seems to be a glitch.
04:26:57 <guest_18> (Sorry, newb at IRC). The problem is that the tar command uses -xzf flags, which complains that the archive is not in gzip format. I had to edit the flags to be just -xf.
04:29:37 <phadej> ghcup on macos probably assumes that you have default `tar`
04:29:53 <phadej> which is somewhat weird version, and definitely not gnu-tar
04:52:59 <int-e> phadej: you're right, https://gitlab.haskell.org/haskell/ghcup/blob/master/ghcup#L1040
05:05:29 <__monty__> Still, tar doesn't need the compression format flag anymore afaik?
05:05:39 <__monty__> So xf should be fine for all tars.
05:06:14 <__monty__> Also, iirc they're not actually -x -f flags, they're just xf arguments to tar so the dash isn't proper either.
05:07:59 <enikar> tar -xf or tar xf are both valid syntax
05:08:29 <enikar> in gnu tar, anyway.
05:08:39 <phadej> __monty__: tars' command line parsing is complicated. also "anymore" doesn't work with use case like ghcup, it should work on various different systems. Yet, reinstalling tar via macports breaks too much
05:09:13 <phadej> maybe ghcup should try to detect gnu-tar, but for that one need to open issue and discuss it there
05:10:13 <__monty__> I guess I just take the compatibilty section of the bsdtar manpage to heart: http://ix.io/1XkW
05:11:41 <merijn> The no flag usage of tar is much older than flags, yes
05:12:06 <merijn> I've used system where "tar -xf" fails (granted, this was a while ago)
05:12:44 <__monty__> I suppose my reasoning for maximum compatibility *is* at odds with my reasoning for dropping the compression format though : )
05:13:03 <merijn> "tar xzf" is probably the most backwards compatible invocation possible
05:13:29 <merijn> Easy to remember too, just go "Xtract Ze Files" in a German accent ;)
05:13:39 <int-e> Not really... noting that this is done for .xz files...
05:14:20 <int-e> The script uses  xz -cd <file.tar.xz> | tar -xf -  for other systems than Darwin.
05:15:05 <__monty__> My hypothesis is that all tars that support xz decompression support automatic compression detection so I'd suggest simplifying that to `tar xf file.tar.xz` for all systems.
05:15:08 <int-e> So... does Darwin not ship xz by default or is the -f -  not supported?
05:15:42 <__monty__> My bsdtar on 10.13 has both xz support and flag support.
05:15:52 <__monty__> But no xz.
05:16:15 <merijn> __monty__: Are you sure, my 10.12 tar does list xz
05:16:31 <int-e> There are two "xz" in scope.
05:16:47 <__monty__> Ok, so you've hit at the core of the problem. Piping's more compatible. But the darwin line should be `tar xJf or simply tar xf`.
05:17:08 <__monty__> merijn: Yep, don't have an xz in my PATH.
05:17:29 <Jadellah> Guys I have a question, is switching careers from accounting to data science a good thing to do?
05:17:32 <int-e> Oh there were three "xz" in scope :)
05:17:37 <merijn> Yeah, there's no xz application by default
05:17:53 <merijn> The only xz I have is from macports
05:18:20 <int-e> (xz the program. xz file format support in tar. xz as a command+flafgg for tar)
05:18:31 <int-e> flafgg -> flag
05:26:08 <Slaus> Why you cannot just use "minBound Bool", but have to type it as "minBound :: Bool"?
05:26:35 <merijn> Slaus: Well, why do you think the former should work?
05:27:16 <enikar> :t minBound
05:27:17 <lambdabot> Bounded a => a
05:28:04 <Slaus> I think of it as Bool being a type which has different values in it (like an array?) and you ask (with minBound) what's the least value in that array and it should return the least value
05:28:54 <merijn> Slaus: Types aren't values and thus cannot be used inside expressions
05:29:03 <merijn> Slaus: You can't "apply" something to a type
05:30:12 <merijn> "minBound :: Bounded a => a" says "I can be any type 'a' that has an instance of 'Bounded'" so a type annotation like ":: Bool" just says you want specifically want it to have type 'Bool'
05:30:47 <boxscape> > minBound || maxBound
05:30:48 <lambdabot>  True
05:30:48 <Slaus> merijn: hm, didn't thought of types as being values, but thought of certain functions being able to operate on types (as other function can operate on values)
05:31:50 <Slaus> minBound True
05:32:14 <merijn> Slaus: minBound isn't a function at all, though
05:32:38 <Slaus> merijn: oh
05:32:55 <Slaus> merijn I thought everything is a function , hm ...
05:33:11 <merijn> Slaus: http://conal.net/blog/posts/everything-is-a-function-in-haskell
05:37:46 <f-a> merijn: what is undefined?
05:38:49 <merijn> f-a: hmm?
05:38:49 <enikar> a value?
05:39:01 <merijn> enikar: Functions are values too :p
05:39:08 <enikar> yes
05:39:52 <f-a> enikar: merijn : because the report states it is a function
05:40:11 <merijn> f-a: Where?
05:40:21 <f-a> 3.1 Errors
05:40:42 <f-a> "The Prelude provides two functions to directly cause such errors:"
05:40:47 <f-a> error
05:40:48 <f-a> and
05:40:49 <f-a> undefined
05:41:33 <no-n> I thought everything was an expression and some expressions are functions
05:41:51 <merijn> f-a: I would say that's a typo/mistake in the Report
05:43:30 <merijn> no-n: expressions and values are used in different contexts. An expression is a (syntactic) piece of code describing a computation, the result of the computation is a value. But in day to day use people use "value" interchangeably with "the expression that computes said value"
05:43:59 <enikar> why undefined could not be a function ?
05:44:14 <merijn> enikar: undefined can be a function, mostly because it can be anything
05:44:23 <merijn> :t undefined :: Int -> Bool
05:44:24 <lambdabot> Int -> Bool
05:48:48 <Slaus> merijn: awesome blog post, thank you. Especially about "blame Church" since I happened to go through λ-calculus first and thought Haskell lines up with it. Anyway, since minBound is just "whatever construct", is there any reason we need to specify "::" before type's name?
05:49:13 <boxscape> Seems like anything polymorphic could be considered a function if you allow invisible type parameters to count
05:49:23 <merijn> Slaus: :: is just the syntax for annotating expressions with types
05:49:59 <boxscape> > 4 :: Double + 5
05:50:01 <lambdabot>  error:
05:50:01 <lambdabot>      Not in scope: type constructor or class ‘+’
05:50:08 <boxscape> > (4 :: Double) + 5
05:50:10 <lambdabot>  9.0
05:50:48 <f-a> merijn: checking another piece of the Report -- Many of the features of Haskell are defined in Haskell itself as a library of standard datatypes, classes, and functions, called the “Standard Prelude.” -- I am inclined to say that was not a typo. I don't have an opinion (or any kind of knowledge) on the matter.
05:50:49 <Slaus> merijn: so it's just ensure consistency with other types expressions and doesn't serve any practical value, right?
05:51:35 <boxscape> f-a it could just be that there's so few non-function values defined in the prelude that they're not worth explicitly mentioning here
05:51:38 <merijn> Slaus: I don't understand what "any practical value" means here.
05:52:00 <boxscape> I can only think of (sometimes) undefined and otherwise off the top of my head
05:52:14 <merijn> Slaus: You can (and people have) imagine languages where you can use types inside expressions, but those languages are very different from Haskell
05:52:42 <merijn> Slaus: Your question seems to boil down to "why isn't haskell defined differently from the way that it is?" which doesn't really have any sensible single answer
05:52:47 <enikar> I think it's not a typo, they say, undefined is a function: undefined :: a
05:52:52 <f-a> boxscape: pi
05:52:54 <merijn> boxscape: Stuff like pi
05:53:00 <boxscape> but that's part of a class
05:53:08 <merijn> f-a: But I consider pi to be pretty niche anyway
05:54:17 <merijn> In general the prelude doesn't really define many non-function names and I'm pretty confident and willing to bet not a single person in the original committee objects to "functions always have (->) as outer type constructor"
05:54:43 <f-a> merijn: what about, say, getChar
05:54:54 <merijn> f-a: Not a function
05:55:07 <f-a> "These functions read input from the standard input device (normally the user’s terminal)."
05:55:31 <Slaus> merijn: I mean, "minBount x" expression can only have x being a string literal (something you can't evaluate (apply conversion or reduction to) since it's a type - not a function/variable), so I can't see any possible ambiguation to introduce "::" symbol besides just to stay consistent with other types expressions
05:55:53 <boxscape> :: isn't just for minBound
05:56:02 <boxscape> it's for giving a type to any expression
05:56:20 <merijn> Slaus: The problem is that minBound *can be* a function
05:56:28 <enikar> and `main :: IO ()` won't be a function?
05:56:33 <boxscape> nope
05:56:36 <Slaus> merijn: how is that? O_o
05:57:02 <merijn> Slaus: There is nothing illegal about defining Bounded for a function type, so if you define "instance Bounded (Bool -> Int)" then "minBound True" would work as a function
05:57:31 <boxscape> % instance Bonuded (Bool -> Int) where
05:57:31 <yahb> boxscape: ; <interactive>:46:10: error:; Not in scope: type constructor or class `Bonuded'; Perhaps you meant `Bounded' (imported from Prelude)
05:57:37 <boxscape> whoops
05:57:43 <boxscape> I also didn't actually mean to press enter just then
05:58:39 <enikar> notice, ghc wraps a function around integer values, for example.
05:59:07 <merijn> Does lambdabot still have function instances for Num?
05:59:19 <merijn> > (sin ^ 2) 4
05:59:20 <boxscape> > (+) + (+)
05:59:22 <lambdabot>  error:
05:59:22 <lambdabot>      • No instance for (Num (Double -> Double))
05:59:22 <lambdabot>          arising from a use of ‘e_124’
05:59:22 <lambdabot>  error:
05:59:22 <lambdabot>      • No instance for (Num (Integer -> Integer -> Integer))
05:59:24 <lambdabot>          arising from a use of ‘e_1’
05:59:31 <merijn> Apparently not
06:00:56 <Slaus> merijn: hm, can't comprehend your last statement yet. Is there something about "function type" being in some way different from ^regular^ type?
06:01:17 <merijn> Slaus: types that represent functions are a subset of all types
06:01:28 <Slaus> types can be of different "types"? Pun intended ^^
06:01:36 <merijn> :t even
06:01:37 <lambdabot> Integral a => a -> Bool
06:01:51 <merijn> Slaus: "a -> Bool" is the type of a value that's a function
06:02:11 <merijn> "Bool" is the type of a value that's *not* a function
06:04:19 <Slaus> Hm, I think I mess it with λ-calculus ... I mean, "a -> Bool", if provided a value, can be reduced to "Bool" (which can't be reduced, thus just goes into your screen terminal or eyes, whatever)
06:05:42 <Slaus> I mean, didn't thought of "a -> Bool" and "Bool" having any specific difference. For example, if someone will ever provide a function from "Bool" to something what can be reduced further, we will have to call that function too (before displaying the result)
06:05:59 <merijn> Slaus: How can they *not* have a difference?
06:06:29 <merijn> Slaus: "can be reduced to a Bool when applied to a value" is not the same thing as "is a Bool"
06:07:17 <merijn> If we have "f :: Bool -> Int" and "g :: Bool" then we can apply 'f' (like 'f True') if we do 'g True', that's a type error
06:07:27 <Slaus> I think I see it now, yes.
06:08:03 <boxscape> > show undefined
06:08:05 <lambdabot>  "*Exception: Prelude.undefined
06:08:16 <boxscape> which Show instance does haskell choose here while doing type checking?
06:08:25 <boxscape> or... later I guess
06:08:35 <boxscape> seems like it needs to provide *some* kind of dictionary during runtime
06:08:42 <merijn> boxscape: lambdabot has extended defaulting (like ghci), so ()
06:08:48 <boxscape> ah
06:08:48 <merijn> See also
06:08:58 <merijn> @check \l -> l == reverse l
06:09:00 <lambdabot>  +++ OK, passed 100 tests.
06:09:08 <boxscape> ok
06:09:11 <merijn> Turns out [()] is always the same if you flip it ;)
06:09:19 <merijn> @check \l -> l == reverse (l :: [Int])
06:09:20 <enikar> merijn: with your function defintion, main is not a function.
06:09:21 <lambdabot>  *** Failed! Falsifiable (after 5 tests and 2 shrinks):
06:09:21 <lambdabot>  [-2,-1,0]
06:09:29 <merijn> enikar: Main *isn't* a function
06:09:53 <enikar> and i disagree with that.
06:10:21 <boxscape> What is the domain and codomain of main?
06:10:50 <merijn> enikar: Can you clarify 1) what a function is according to you and 2) how main fits that definition
06:11:25 <merijn> I mean, why would main be a function (other than historical legacy of poor decision in other languages...)
06:11:53 <enikar> merijn: I don't need to clarify. In many documents about haskell, they say main is a function.
06:13:52 <merijn> This just in, people use sloppy terminology everywhere. People also talk about "partial application" in Haskell. I'm pretty confident anyone involved with the creation of the report will agree with me
06:14:04 <enikar> i feel, this debate, what is function or not, is unproductive.
06:14:17 <merijn> Also, historically main *used to be* a function until Haskell 1.4 (I think) where we switched to monadic IO
06:14:23 <f-a> merijn: how pernicious is this mislabeling?
06:14:30 <boxscape> interesting, in the 98 report, they say "these functions read input [...]", then list, among other things, getChar, and then proceed to call getChar and co. "operations" and only refer to actual functions as "function"
06:14:56 <f-a> if the answer is: big, the Report needs to be patches
06:15:10 <f-a> boxscape: yes, by a simple grep I found that, some in the FFI and undefined
06:15:13 <merijn> boxscape: Sure, because anyone involved with the definition of Haskell agrees with the definition I'm using, because literally anyone involved in type theory and programming languages agrees
06:15:27 <merijn> f-a: The impact depends
06:15:33 <boxscape> merijn, well, what I'm saying is they're being inconsistent within one paragraph
06:15:38 <merijn> f-a: For people who already know Haskell it's basically 0
06:16:27 <merijn> f-a: Pendatism is useful to avoid beginners forming wrong ideas. Which is why I will never use "partially applied" when explaining to beginners, but will sometimes use it when talking with experts
06:16:45 <merijn> *Pedantism
06:17:52 <merijn> Is the fact that getChar isn't a function but doesn't get correctly labelled in a summarising paragraph critical? No. Is it important for people new to learning Haskell to understand the difference between "Bool" and "a -> Bool" critical? Hell, yes.
06:17:53 <Slaus> merijn: by "partially applied" you mean "curried"?
06:17:56 <f-a> partially applied seems all over the report too
06:18:34 <merijn> f-a: Because the report was written by/for experts coming from (S)ML and various functional language, so there was no point in being pedantic when this is shorter and understood
06:19:08 <merijn> Slaus: Yes, no, maybe. I don't actually remember the difference between "curried" and "uncurried" because it's an unhelpful and mostly useless distinction in Haskell
06:19:54 <merijn> f-a: Anyway, the report won't get patched, because the last 2 major attempts to create a new report have failed and there's little to no incentive to getting things done. Which is a shame, but that's how things are.
06:20:32 <merijn> f-a: "Simple" question: Is "const f ()" "partially" applied, yes or no?
06:21:11 <f-a> I would say, "no"
06:21:40 <merijn> f-a: So what if we have "const f () :: Int -> Char"
06:22:13 <boxscape> what about `(const :: (Int -> Char) -> () -> Int -> Char) f ()`? const takes 3 arguments here
06:22:20 <boxscape> (up to three arguments)
06:22:32 <kaba0> Hi! I have some trouble with the last part of my homework exercise. I should create a total function, with a given type and in the definition I should use some given functions and only those (not even constants are allowed).I have a type signature of `Floating b => Int -> b -> Bool`, and the functions I have to use are (==), sqrt, replicate,
06:22:32 <kaba0> fromEnum, abs, head. Starting from backwords, only (==) gives a Bool as a result, so it must be the last function. And my problem actually is with Enum a and Eq a constraints, since only concrete types like Int and Float/Double seem to be instances of them, but I have a Floating constraint, which I don't seem to be able to convert to anything I can
06:22:32 <kaba0> use later on.
06:23:12 <f-a> kaba0: you can have multiple constraints
06:23:35 <merijn> You don't actually need multiple constraints
06:23:40 <kaba0> f-a: I can't change the type of the function, it's given.  
06:23:54 <merijn> kaba0: Hint: Int is an instance of Eq :)
06:24:39 <merijn> kaba0: You *have* to use all of them or is just some of them fine?
06:25:51 <kaba0> merijin: Have to use all :/  That's why I'm in problem.. I got that Int == Int will be good, but if I put sqrt somewhere I will have a Floating (I don't need to use both arguments), about which I can't seem to do anything
06:30:21 <merijn> kaba0: Sure you can :)
06:30:50 <merijn> hmm, actually I guess abs has a different type from what I thought
06:31:36 <merijn> I have to say this seems like a rather pointless exercise, though >.>
06:38:02 <boxscape> I think keeping that type might only be possible if you use fromEnum on something that's already an int, but then I'm not sure what to do with the result of the other functions
06:39:26 <boxscape> whereas if you allow an Enum constraint on b it's fairly easy
06:43:07 <boxscape> kaba0 tbh I do think it's impossible if you don't have an Enum constraint on b
06:43:41 <kaba0> boxscape: Should I write an email to my teacher that it doesn't seem to be possible? I've been struggling with it for quite some time now.. 
06:44:18 <boxscape> kaba0 sounds like an idea
06:45:50 <kaba0> boxscape merijn Thanks for the help!
07:12:33 <dmwit> :t \m n -> [head [sqrt (abs n), sqrt (abs n)] == sqrt (abs n)] == replicate m (m == m)
07:12:35 <lambdabot> (Eq a, Floating a) => Int -> a -> Bool
07:12:51 <dmwit> ouch
07:13:45 <dmwit> Oh, and I hadn't used fromEnum, but that's easy to fix by just changing the `m == m` to `m == fromEnum m`.
07:16:05 <dmwit> :t \m n -> let x = head [sqrt (abs n)] in replicate m (fromEnum m) == replicate m m
07:16:07 <lambdabot> Floating a => Int -> a -> Bool
07:16:31 <dmwit> What do I win for answering the impossible question?
07:16:53 <Slaus> praise
07:16:55 <merijn> dmwit: The ire of the instructor that assigned it as homework? ;)
07:17:13 <dmwit> Ah, we can even remove the cheating [] brackets by replacing [sqrt (abs n)] by replicate m (sqrt (abs n))!
07:17:27 <dmwit> (At first you may say: but that's not total! But you'd be wrong, because laziness and x not being mentioned.)
07:18:54 <Guest_1> Hello, how do i edit the path at the last step of the install?
07:19:14 <dmwit> In your current shell, PATH=/a/b/c/d:$PATH
07:19:27 <dmwit> For future shells, modify the startup script for whichever shell is your default.
07:19:47 <dmwit> If you don't know, edit ~/.bashrc. Add the same line (PATH=/a/b/c/d:$PATH) somewhere to it.
07:22:34 <Guest_1> thanks
07:24:17 <sm[m]> Does that work ?
07:25:11 <sm[m]> I have: echo "export PATH=~/.local/bin:~/.cabal/bin:$PATH" >> ~/.bashrc 
07:25:11 <sm[m]> source ~/.bashrc
07:27:04 <hoxtrop[m]> I think you should specify the actual path (sans the tilde)
07:27:25 <hoxtrop[m]> Wait, what happened to /usr/bin
07:27:41 <merijn> hoxtrop[m]: Presumably that's already in the old $PATH
07:27:49 <merijn> Anyway, you're right should be $HOME instead of ~
07:28:05 <hoxtrop[m]> He overwrote it?
07:28:30 <merijn> hoxtrop[m]: No, prepended
07:29:44 <hoxtrop[m]> Oh sorry. Gotcha. Didn't see that extended to the next line
07:36:56 <Guest_1> sorry i need a more "begginers guide" answer pls. I can't seem to be able to edit the path
07:41:19 <__monty__> merijn: ~ should work just fine in PATH?
07:41:46 <hoxtrop[m]> What does "echo $PATH" give?
07:42:03 <geekosaur> __monty__, as written there t was double quoted. also ~ works in $PATH only if bash is using it; C programs do not expand ~
07:42:03 <hoxtrop[m]> I didn't know. Thanks __monty__
07:42:05 <merijn> __monty__: I don't think ~ expands correctly in environment variables
07:42:19 <hoxtrop[m]> Oh.
07:42:22 <geekosaur> nor do Haskell, Python, etc.
07:42:37 <__monty__> How do we know Guest_1 is trying to change their PATH, btw? What install are they talking about?
07:43:02 <__monty__> geekosaur: Yeah but "export whatever" as-is double-quoted doesn't execute as a command either?
07:43:24 <geekosaur> the one I saw was: echo "PATH=..."
07:43:34 <geekosaur> >> ~/.bashrc
07:43:43 <geekosaur> the quoting defeats ~ expansion
07:43:56 <__monty__> Also, your shell expands the ~ on export, no? So languages not understanding it doesn't matter because the environment variable has the expanded paths?
07:44:01 <geekosaur> bash itself will see the unexpanded tilde later and expand it, but other things won't
07:44:11 <merijn> __monty__: ~ doesn't get expanded within quotes
07:44:33 <merijn> __monty__: $HOME does, hence why you should use $HOME for defining PATH
07:44:46 <__monty__> I don't see ~ in ""'s anywhere, hence my confusion.
07:45:04 <hoxtrop[m]> Doesn't exapnd. Verified
07:45:07 <merijn> __monty__: sm[m]'s command had it quotes
07:45:11 <merijn> *quoted
07:45:37 <__monty__> merijn: No it didn't. It's only quoted for echo, wouldn't be quoted in .bashrc.
07:49:45 <Guest_1> when i enter the comand, bash says permission denied
07:51:07 <hoxtrop[m]> chmod +x or somethin?
08:00:03 <Arlo> hi
08:00:27 <elpiton> Hi!
08:00:33 <Arlo> May I ask is that right use cabal update$ cabal install QuickCheck  to install quickCheck on Haskell on Mac
08:00:46 <Arlo> cabal update 
08:00:55 <Arlo> $ cabal install QuickCheck
08:01:14 <Arlo> these two indexes
08:02:50 <Arlo> I tried thee tow codes
08:03:01 <Arlo> but it shows "Downloading the latest package list from hackage.haskell.orgTo revert to previous state run:    cabal v2-update 'hackage.haskell.org,2019-09-29T11:46:56Z'"
08:04:28 <Arlo> and when I type the second code ,which is "$ cabal install QuickCheck"
08:04:49 <Arlo> it shows "Warning: You asked to install executables, but there are no executables intarget: QuickCheck. Perhaps you want to use --lib to install librariesinstead."
08:05:20 <Arlo> may I know what is the matter?
08:05:29 <Arlo> about this situation?
08:07:26 <f-a> Arlo: what are you trying to do?
08:07:45 <Arlo> I am trying to install the quickcheck on terminal
08:08:24 <f-a> generally speaking, I would suggest to create a new folder, `cd` into it and cabalise it (cabal init)
08:08:47 <f-a> I am not sure QuickCheck is useful `globally` (i.e. without a project)
08:09:22 <f-a> are you trying to set up some testing for a program of yours, Arlo ?
08:09:55 <Arlo> yeah 
08:10:19 <f-a> is that program cabalised? do you have a .cabal file in your folder?
08:10:26 <Arlo> But I thin I need to install quick check before I use it 
08:10:48 <Arlo> it actually have a .hs in my folder 
08:11:47 <Arlo> Once you have installed “ghci” install the QuickCheck package by running in your terminal: $ cabal update$ cabal install QuickCheck
08:11:59 <f-a> oh an assignment
08:12:07 <f-a> well then follow what they say
08:12:14 <Arlo> yeah
08:12:24 <f-a> does "cabal update" work? 
08:12:27 <Arlo> but I failed 
08:12:48 <f-a> how so, can you paste the error somewhere?
08:12:53 <novum> why does stack exec and running a program built with stack not show any stdout until the program has finished running?
08:12:56 <Arlo> To revert to previous state run:    cabal v2-update 'hackage.haskell.org,2019-09-29T11:46:56Z'
08:13:08 <f-a> Arlo: that is not an error
08:13:26 <f-a> also are you sure you are using update and not new-update?
08:13:47 <Arlo> ok :)
08:13:48 <f-a> novum: not a stack user, but maybe the computation ain't ready till the end?
08:13:58 <Arlo> but when I type next code
08:14:08 <Arlo> cabal install QuickCheck
08:14:11 <f-a> ok
08:14:15 <f-a> what does it say?
08:14:23 <merijn> novum: Probably wrong buffering
08:14:31 <Arlo> is shows "Warning: You asked to install executables, but there are no executables intarget: QuickCheck. Perhaps you want to use --lib to install librariesinstead
08:14:52 <geekosaur> that would be corrrect, QuickCheck is a library not an executable
08:15:07 <geekosaur> you seem to be looking for cabal v1, which didn't distinguish
08:15:17 <f-a> yep
08:15:31 <f-a> you are using the latest cabal
08:15:56 <geekosaur> so you'll have to prepend all commands with "v1-", for example "cabal v1-install QuickCheck", if you want the old behavior
08:16:03 <novum> the program is literally  main = do .. year <- getLine :: IO Integer .. putStrLn ((show year) ++ (if isLeapYear year then " is a leap year" else " is not a leap year"))
08:16:28 <novum> I don't know what "wrong buffering" means
08:16:44 <novum> sorry and there is a putStrLn before the getLine
08:16:50 <merijn> novum: files have buffers in the OS so you don't end up writing a single character at a time
08:16:59 <Arlo> so you mean QuickCheck is works right?
08:17:20 <f-a> Arlo: prepend v1- to each cabal command
08:17:27 <f-a> "cabal v1-update"
08:17:28 <f-a> etc.
08:17:33 <f-a> *to each cabal command
08:17:34 <merijn> novum: Interactive programs are normally set to line-buffered (i.e. flush after every new line), but when run non-interactively block-buffering is used (i.e. flush after every block of several kilobyte)
08:17:49 <Arlo> ok I will the it :)
08:17:53 <Arlo> try
08:18:11 <merijn> novum: If stack is calling your program in a way that the RTS thinks it's not connected to a terminal the buffering might be set to block which means you don't see anything until you produce enough output or the program exits
08:18:20 <novum> merijn, ok that is weird since stdin and stdout are special instances and most things use line buffering. so why is this the default, and how do I fix it?
08:18:31 <geekosaur> doesn't matter, there's also the prompt before the getLine which needs to be flushed
08:18:37 <merijn> novum: I'm not saying it is, I'm just guessing
08:19:15 <Arlo> Resolving dependencies...cabal: Could not resolve dependencies:[__0] unknown package: v1-QuickCheck (user goal)[__0] fail (backjumping, conflict set: v1-QuickCheck)After searching the rest of the dependency tree exhaustively, these were thegoals I've had most trouble fulfilling: v1-QuickCheck
08:19:19 <novum> is not this something that you have experienced, too. When I do stack install then TheProject-exe then I get the same issue. This doesn't make any sense, and I don't know how to fix it
08:19:46 <Arlo> seem it donesn't work
08:19:50 <geekosaur> Arlo, did you read what I wrote? it is not "v1-QuickCheck"
08:19:51 <f-a> Arlo: no
08:19:55 <merijn> novum: I don't use stack, so no idea
08:20:05 <f-a> cabal v1-install QuickCheck <---- Arlo 
08:20:17 <merijn> @hoogle hSetBuffering
08:20:17 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
08:20:17 <lambdabot> GHC.IO.Handle hSetBuffering :: Handle -> BufferMode -> IO ()
08:20:17 <lambdabot> UnliftIO.IO hSetBuffering :: MonadIO m => Handle -> BufferMode -> m ()
08:20:33 <merijn> novum: You can explicitly set the buffering mode on stdin/stdout using that function
08:21:09 <novum> how can I compile something with the layout  app/main.hs  src/lib.hs  using glasgow ghc
08:21:36 <novum> main.hs import lib.hs functions
08:21:52 <Arlo> wow , it works ,that's amazing,:) thank you very much f-a 
08:22:10 <f-a> geekosaur was the one who diagnosed the problem!
08:22:10 <dmwit> novum: ghc app/main.hs -isrc
08:22:14 <novum> whoop. ghc app/main.hs src/lib.hs worked but it plopped the executable .. into the void?
08:22:18 <dmwit> novum: You will need to name lib.hs after the module it contains.
08:22:28 <novum> ah sweet. it's very gnulike thanks.
08:22:30 <f-a> Arlo: remember to prepend v1- to each cabal command!
08:22:53 <dmwit> novum: Probably the executable went into app/main
08:22:57 <geekosaur> novum, the executable is probably called main and may be under app/
08:23:28 <dmwit> novum: Before long, you'll want to learn how to use cabal to manage these flags for you. Let us know when you're ready for the quick-start primer.
08:23:29 <Arlo> both of you are great :)
08:24:47 <Arlo> I will remember it
08:25:25 <novum> the module is called Lib lmao I was just lazy and stack new gave me that
08:25:25 <novum> gosh. I used ghc src.main.hs -isrc  then ran  app/Main
08:25:25 <novum> I still get this buffering issue. Ok merijn can you point me to some reference material/docs for setting buffering mode for, eg, main.
08:25:26 <novum> src/main.hs
08:25:49 <f-a> novum: import System.IO
08:26:39 <novum> f-a, that did not seem to help .. but I did not have it like I should
08:26:50 <f-a> =D that was just part of it
08:27:08 <f-a> and place
08:27:09 <f-a> hSetBuffering stdout NoBuffering
08:27:25 <f-a> at the top of your do block (add >> if you do not use "do notation")
08:27:29 <f-a> that should fix it
08:27:57 <f-a> I suspect an alternative is to call hFlush stdout at appropriate places
08:28:15 <fresheyeball> hey smart haskellers
08:28:24 <fresheyeball> I am trying to impliment this spec, and it just says "log"
08:28:28 <merijn> fresheyeball: That seems rude to the unsmart ones ;)
08:28:29 <novum> f-a, merijn, you brilliant bananas. thank you for your assistance and helping to further my understanding
08:28:38 <fresheyeball> the base is not specified 
08:28:44 <fresheyeball> I don't no shit about log
08:28:59 <fresheyeball> if the base is not specified, what should I expect
08:29:01 <fresheyeball> base 2?
08:29:03 <f-a> are you the fresheyeball of non-empty-zippers? :P
08:29:05 <merijn> fresheyeball: e
08:29:12 <fresheyeball> f-a: yeah that is mine
08:29:19 <fresheyeball> merijn: boo
08:29:23 <Arlo> Arlo, did you read what I wrote? it is not "v1-QuickCheck".   geekosaur   ,my fault '=D 
08:29:35 <merijn> fresheyeball: You can reconstruct any base from log e
08:29:47 <f-a> novum: I stumbled on it and found it annoying too
08:29:47 <fresheyeball> what is e?
08:29:53 <f-a> napier number
08:30:03 <geekosaur> approximately 2.71828. "natural logarithm"
08:30:11 <f-a> (1+1/x)^x for x -> inf.
08:30:33 <f-a> fresheyeball: it is a *very* convenient logarithm
08:30:38 <merijn> fresheyeball: e is euler's number
08:30:40 <fresheyeball> oic
08:30:40 <geekosaur> which is so called for a reason you are encouraged to look up (it occurs quite often)
08:30:45 <fresheyeball> oh that e
08:30:57 <fresheyeball> damn euler, sneeking up on me on the dark and the night
08:31:27 <merijn> fresheyeball: You can compute log N of xby doing "ln(x)/ln(N)" where ln = log with base e
08:31:35 <geekosaur> curses, eulered again
08:32:06 <novum> euler's number: `e`. it is a constant that appears in Euler's identity theorem - aka "the most beautiful theorem in mathematics"
08:32:44 <fresheyeball> alright, that works
08:32:58 <e> merijn: well, the same works for any other logarithm
08:33:01 <fresheyeball> I wrote it as a literal though
08:33:10 <fresheyeball> is e provided by prelude somewheres
08:33:12 <fresheyeball> ?
08:33:26 <f-a> exp 1 ?
08:33:27 <geekosaur> (why are we doing this? is there not logBase?)
08:33:31 <f-a> > exp 1
08:33:33 <lambdabot>  2.718281828459045
08:33:44 <novum> e, how does it feel to be so highly valued by the maths community? you must be spoiled rotten. I envy your nick ^u^
08:34:20 <EvanR> e is one of an elite 26 users
08:34:27 <e> well, currently it feels as if it's filling up my highlight window
08:34:48 <f-a> big smile, hope you never join an italian channel then, e 
08:35:38 <f-a> or a nethack one, the players might be wary
08:35:47 <merijn> What?
08:35:50 <merijn> I'd eat him
08:35:59 <merijn> ESP rules
08:36:13 <merijn> Just make sure to always carry a blindfold
08:37:19 <f-a> hehe
08:38:24 <defstryker> q
08:38:26 <nshepperd> You feel a strange mental acuity...
08:39:33 <nshepperd> sometimes 'log' means base 10, and 'ln' means base e
08:42:15 <hoxtrop[m]> And lg means base 2
08:42:33 <c_wraith> and when it's used in big-O notation, the base is actually irrelevant!
08:43:23 <hoxtrop[m]> That was cute
08:48:25 <fresheyeball> nshepperd: well that really makes me think base 3
08:48:29 <fresheyeball> base e
08:48:34 <fresheyeball> since its written ln in the spec
08:49:45 <monochrom> Not if it's O(10^(lg n))
08:51:34 <Slaus> If I want to derive an existing class, how can I see what interface I'll have to implement?
08:52:02 <f-a> Slaus: open ghci and type, say, :i RealFrac
08:52:05 <merijn> Slaus: The documentation on Hackage lists the functions of classes (and usually the minimal complete definition)
08:52:14 <f-a> @i RealFrac
08:52:14 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect irc-password irc-persist-connect v @ ? .
08:52:16 <geekosaur> that question doesn't make a lot of sense, if you are deriving then the compiler provies the implementation
08:52:22 <f-a> doh
08:52:31 <f-a> @info RealFrac
08:52:31 <lambdabot> RealFrac
08:52:41 <geekosaur> (by wrapping/unwrapping, usually)
08:52:41 <merijn> f-a: There is no info command
08:52:51 <f-a> thanks
08:52:51 <geekosaur> %% :i RealFrac
08:52:51 <yahb> geekosaur: http://qp.mniip.com/y/13
08:53:07 <monochrom>  @info gets spell-corrected to @undo
08:53:23 <monochrom> @info do { x <- m; return (f x) }
08:53:23 <lambdabot> m >>= \ x -> return (f x)
08:53:47 <monochrom> Also, in the wake of Thanos memes...
08:53:52 <monochrom> @snap monochrom
08:53:52 * lambdabot hits monochrom with an assortment of kitchen utensils
08:54:21 <geekosaur> whisked away…
08:57:35 <monochrom> One day if there is a dragon-slaying or vampire-slaying or whatever-slaying movie that gets popular, you can also try:
08:57:38 <monochrom> @slay monochrom
08:57:38 * lambdabot secretly deletes monochrom's source code
08:59:26 <Slaus> @help Slaus
08:59:26 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:04:03 <shachaf> monochrom: That sounds more like a monochrom-slaying movie.
09:26:15 <unfixpoint> How would you create a secure connection via https in Haskell to a service that uses a self-signed certificate (I have the X509 certificate at compile time)?
09:28:05 <[exa]> unfixpoint: what library do you use for https?
09:28:34 <unfixpoint> Currently I'm trying it with http-conduit `setRequestManager manager "https://localhost:4443/"` where I use a custom `Manager` created by using `readCertificateStore` to read the certificate.
09:28:51 <unfixpoint> I'm open to suggestions, but smaller footprint would be nice.
09:30:01 <unfixpoint> (I'm already importing stuff from `tls`, `iproute` , `dns`, `wai`, `warp` for server-side reasons)
09:32:09 <unfixpoint> I posted the complete code (incl. scripts/cmds for testing) on reddit, is it fine to share here or should I use some other channel?
09:32:30 * hackage hlint 2.2.3 - Source code suggestions  https://hackage.haskell.org/package/hlint-2.2.3 (NeilMitchell)
09:32:31 <[exa]> no problem with that probably
09:32:47 <unfixpoint> (https://www.reddit.com/r/haskell/comments/dawyuo/httpconduit_with_tls_and_a_custom_certificate/)
09:33:53 <[exa]> I'm not quite fluent in conduit stuff but from what I see in the documentation this is probably the easiest way to go
09:34:26 <[exa]> if you don't like the code that combines that amount of stuff, name it a 'mkSingleLocalCertManager' and put it in a separate file :]
09:35:26 <unfixpoint> Combining that amount of stuff?
09:36:05 <[exa]> it's not "much" but you seemed to want to avoid extra complexity
09:36:39 <c_wraith> saying "allow this certificate for only this domain" is actually kind of a lot of work to most ssl libraries.
09:37:21 <c_wraith> They don't have interfaces designed for authenticating the channel, so much.
09:38:17 <c_wraith> ...  which is part of why so many things just don't validate the certificate.  Security?  What's that?
09:39:46 <unfixpoint> But is just adding the certificate to certificate store not enough? With curl it's just that?
09:40:58 <unfixpoint> [exa]: The code is a minimal example squeezed into a file, but I'd probably keep these both in a separate file.
09:46:48 <unfixpoint> Hm, got it to work. Didn't know I should look at tcp-streams
09:47:14 <unfixpoint> c_wraith: What was your point about security though?
09:48:09 <c_wraith> oh, just that libraries tend to make it so hard to do correctly that people don't bother. it was sympathy for your complaint. 
09:52:24 <unfixpoint> (I cant click that [so] link)
10:11:00 * hackage schemas 0.2.0 - schema guided serialization  https://hackage.haskell.org/package/schemas-0.2.0 (PepeIborra)
10:15:00 * hackage hvega 0.4.1.1 - Create Vega-Lite visualizations (version 3) in Haskell.  https://hackage.haskell.org/package/hvega-0.4.1.1 (DouglasBurke)
10:20:20 <nshepperd> transport layer security libraries that don't support security
10:22:30 <geekosaur> well, they "support" it. painfully.
10:23:05 <geekosaur> usually they're designed around the low level specification and make it difficult to use at a high level, you need to eb too aware of e.g. low level network issues
10:23:26 <Rembane> Are there not high level specs? 
10:24:13 <geekosaur> so you want a spec that was written for e.g. Haskell application programmers, as opposed to one that will interoperate?
10:24:42 <geekosaur> the spec should be low level. the implementation should consider its users.
10:25:35 <Rembane> Got it. I was thinking of having two layers of specs, but maybe that won't solve anything except giving us more RFCs.
10:26:42 <geekosaur> right, and is the wrong solution anyway. the spec is not the problem. the implementation ignoring everything other than the spec is the problem. openssl is a terribly designed library, in short
10:27:27 <Rembane> I agree. 
10:27:59 <geekosaur> we really need a competitor to it, except nobody wants to take on the job of writing a new security-critical library that needs to be battle-tested before anyone will trust it
10:28:30 <geekosaur> (libressl doesn't count, it's trying to be a drop-in replacement)
10:28:47 <Clint> there are plenty of competitors, all bad
10:29:40 <c_wraith> Yeah, that's certainly not a library I want to write.
10:33:55 <aisn> is this a reasonable way to write a test: https://paste.ubuntu.com/p/Spdnpdtd3y/?
10:34:18 <aisn> or should a test case have no logic itself
10:36:35 <Slaus> Is it possible to implement a Functor for Map's keys? Does it make any sense?
10:36:56 <monochrom> No.
10:37:09 <geekosaur> Slaus, the problem there is you can't expose the Ord constraint on Map keys "through" fmap
10:37:42 <Slaus> so it WOULD make some sense, but it's not possible, right?
10:38:21 <geekosaur> not as Haskell currently does things
10:38:21 <Slaus> but I can't find any possible practical meaning in that though ...
10:38:31 <Slaus> okey, thank you, as I expected
10:38:46 <geekosaur> there's this notion of indexed types, which would enable it. this can be emulated with some pain
10:41:27 <Slaus> so many new things seems to get coming into Haskell soon ... (none of which I understand though ^^). People talking about dependent types, indexed types, etc...
10:41:55 <monochrom> Suppose you had a conceptual functor instance for Map (or really any dictionary type you like) at the keys, unrestricted by Haskell because it's all in your head.
10:42:21 <monochrom> I have a dictionary { 0 |-> "hello", 1 |-> "hi" }
10:42:47 <monochrom> What would be your answer to fmap (\_ -> 2) { 0 |-> "hello", 1 |-> "hi" } ?
10:44:27 <Slaus> well, there should/would be a requirement for f of "fmap f" to instantiate the same class as Map.key does (Ord I guess?)
10:45:11 <monochrom> I don't think I have violated that?
10:45:50 <monochrom> I haven't even changed the key type. I started with Int I ended with Int.
10:46:10 <monochrom> My f doesn't even break monotonicity.
10:46:21 <Rembane> I want: {2 |-> "hellohi" }
10:46:53 <monochrom> (in the off chance that you're very worked up with Ord and require f to respect it)
10:47:27 <monochrom> (because I don't insist on Map I'm talking dictionaries in general)
10:48:40 <Slaus> how so that it doesn't break it? I mean, (\_ -> 2) does kill isomorphisms
10:49:08 <Slaus> values will map to the same 2
10:49:14 <monochrom> Does fmap require isomorphisms? Does functor require isomorphisms?
10:49:30 <Slaus> oh, I see, "2" does implement Ord, that's what you mean
10:50:07 <Slaus> well, it should, as I see it :] 
10:50:20 <monochrom> You're making it up.
10:50:23 <Slaus> is there a way to require it?
10:51:58 <monochrom> No.
10:51:58 <Slaus> oh, I figured out my problem. I'm restating my answer to your question "What would be your answer to fmap (\_ -> 2) { 0 |-> "hello", 1 |-> "hi" } ?" this way: it will collapse to Map { 2 |-> "hi" }
10:52:38 <Slaus> because it will map 0 to 2 and then will try map 1 to 2, but maps can't have similar keys (they can't, right?) and will have to drop
10:52:47 <Slaus> it doesn't make much sense though
10:52:51 <Rembane> Slaus: You can get your functionality by turning the Map into a list, do your transformation and then create a new Map. 
10:54:59 <monochrom> Then you have broken the functor law: fmap g . fmap f = fmap (g . f)
10:55:09 <Slaus> It's my second day learning Haskell and I'm constantly trying to draw parallels between Haskell's types/values/functions and Category Theory and it was good so far, until I met Functors on Maps. Maps are objects in Map category, while Functor maps it's objects to other categories
10:55:35 <Slaus> and I can't properly grasp such mappings since Functor performs it only PARTIALLY
10:55:37 <Slaus> hmm
10:55:39 <monochrom> Err I want to rename my variables.  fmap f . fmap g = fmap (f . g)
10:56:06 <monochrom> Here is my g: g n = 1-n
10:57:41 <monochrom> My trick is f.g=f so you're running into fmap f . fmap g = fmap f
10:58:45 <monochrom> Unfortunately, fmap f (fmap g { 0 |-> "hello", 1 |-> "hi" }) = fmap f { 0 |-> "hi", 1 |-> "hello" } = { 2 |-> "hello" } != { 2 |- "hi" }
11:00:11 <Slaus> yes, that's true. Thank you
11:01:07 <Slaus> so, underlying it, it wouldn't make any sense indeed (not just Haskell's limitation) ...
11:02:16 <geekosaur> guess I didn't undertand the question right
11:05:29 <Slaus> me neither, but monochrom clarified the question for me and did it with MATH ^^ how nice
11:06:04 <EvanR> debunked by deconstruction
11:19:15 <enikar> you can map for updating only values, not keys.
11:36:36 <dsal> Is there a variant of bracket or finally or something that lets me do different things depending on whether there was an exception?
11:37:24 <dsal> I guess I could combine onException with... something.
11:37:33 <monochrom> Yes, everyone does that.
11:55:39 <dsal> I don't think I understand `fail` very well.
11:56:17 <dsal> Mostly, it just does what I want, but I don't quite know what it does.
11:57:36 <f-a> there are very few reasons to use fail dsal 
11:57:38 <Rembane> dsal: When does it not do what you want?
11:57:59 <f-a> mostly there for historical reasons
11:58:03 <dsal> It does  what I want, but I don't know how to think about what happens when I want to know if it fails.
11:58:11 <dsal> f-a: how should I do things?
11:59:09 <dsal> e.g., in an STM (), I can fail when I don't like the state and that's an easy action to apply at the top of a bunch of functions.
11:59:40 <merijn> dsal: Don't use fail for that
11:59:55 <merijn> dsal: In STM fail just maps to retry (which is the thing you really want)
12:00:46 <merijn> dsal: Fail almost never does what you want, tbh :p MonadFail makes it slightly less terrible, but only slightly so >.>
12:01:03 <dsal> sendPacket c@MQTTClient{..} p = checkConnected c >> writeTChan _ch p
12:01:36 <dsal> So, I have a bunch of this kind of thing.  They seem to do what I want...  checkConnected fails with a useful message telling me what went wrong if I'm not in the right state.
12:01:45 <merijn> dsal: checkConnected should use retry or mzero, tbh
12:01:59 <dsal> Neither of those communicates the reason for the failure, though.
12:02:41 <merijn> dsal: In stm you never see the reason, though?
12:02:54 <hpc> retries are a normal part of the operation of STM
12:03:00 * hackage hakyll-typescript 0.0.1.0 - Typescript and javascript hakyll compilers.  https://hackage.haskell.org/package/hakyll-typescript-0.0.1.0 (jhmcstanton)
12:03:03 <hpc> it's the whole reason to use transactions over locks
12:03:34 <dsal> I understand stm to a degree.  It's fail I don't understand.  If the failure reason doesn't come out anywhere, then that's probably why I don't understand it.  I thought it did.
12:03:58 <hpc> fail exists to handle pattern match failures in do notation
12:04:03 <merijn> dsal: fail exists to handle partial pattern matches in do notation
12:04:06 <hpc> when you write "some pattern <- some expression"
12:04:09 <merijn> dsal: And is an ugly historical wart
12:04:26 <hpc> the string that gets passed to fail is something like "foo.hs 123:45 pattern match failure blahblahblah"
12:04:30 <dsal> Interesting.  I should get rid of it and see what happens.
12:04:40 <hpc> and by default, gets passed through to error
12:04:57 <dsal> mzero would be less work than fail for me by far, as long as I still get my reason bubbled up, which can come elsewhere.
12:05:38 <merijn> dsal: THe entire point of STM transactions is that you don't see the "error" at all...
12:05:48 <merijn> dsal: It keeps retrying until there is no error
12:06:55 <dsal> What does mzero mean in   m () ?
12:07:43 <merijn> "mzero >> foo = mzero"
12:08:00 * hackage asn1-encoding 0.9.6 - ASN1 data reader and writer in RAW, BER and DER forms  https://hackage.haskell.org/package/asn1-encoding-0.9.6 (VincentHanquez)
12:08:00 <dsal> OK.  That sounds good.
12:09:00 * hackage asn1-parse 0.9.5 - Simple monadic parser for ASN1 stream types.  https://hackage.haskell.org/package/asn1-parse-0.9.5 (VincentHanquez)
12:09:36 <merijn> dsal: Although you still won't "see" errors in STM...
12:10:24 <dsal> Yeah.  I don't think I necessarily need to.  I may need to think about the flows a bit, but I don't know that's an issue for me.
12:25:31 <dsal> I see I am using fail in a pattern matching kind of way... a sort of bad user input.  What does fail do in IO?  Should I just use exceptions everywhere?
12:25:46 <dsal> I kind of don't like exceptions in haskell, but I'm starting to accept them.
12:25:51 <hpc> in IO, fail = error
12:25:51 <merijn> dsal: fail in IO literally just throws an exception
12:25:56 <merijn> hpc: Really?
12:26:03 <merijn> I thought it was UserError?
12:26:06 <hpc> oh, maybe it's that
12:26:07 <merijn> That's even grosser
12:26:33 <hpc> all exceptions are the same to me, if i care about what something is i put it in the program's control flow
12:26:35 <merijn> Yeah, it throws user error
12:26:36 <dsal> OK.  I think I understand fail now.   I've been using it as magic I don't want to think about.
12:26:39 <Rembane> Aren't there some typeclasees that handle this in a nice way? 
12:26:53 <merijn> Rembane: MonadFail + -XMonadFailDesugaring
12:27:00 * hackage symbiote 0.0.1 - Data serialization, communication, and operation verification implementation  https://hackage.haskell.org/package/symbiote-0.0.1 (athanclark)
12:27:02 <Rembane> merijn: Sweet! 
12:27:04 <geekosaur> ExceptT?
12:27:26 <merijn> Rembane: With MonadFailDesugaring (I think it's default as of 8.8?) partial patterns in do notation incur a MonadFail constraint
12:27:42 <merijn> Of course then there's morons implementing "instance MonadFail Foo where fail = error"
12:27:50 <Rembane> merijn: that's very nice. Is this related? https://wiki.haskell.org/MonadFail_Proposal
12:27:51 <merijn> A pox upon those morons
12:28:07 <Rembane> They will soon see the errors of their ways. 
12:28:16 <merijn> Rembane: That proposal is the reason, yes
12:28:31 <Rembane> merijn: Good. Then I have some nice background to read. 
12:29:11 <dsal> Is userError bad?
12:29:15 <merijn> Rembane: It was already accepted, but the GHC (tries) to provide a "3 release window" which can be supported without CPP, so MonadFail has already been in GHC as of several versions, just not enabled by default
12:29:40 <merijn> dsal: It literally just throws a Control.Exception style exception, so if you're avoiding those, as you said, then yes :p
12:29:42 <dsal> I guess it doesn't even help me here.     fail s = ioError (userError s)
12:30:26 <dsal> It's fine for this.  I want the user to know what to feel bad about.
12:30:26 <Rembane> merijn: I've apparently been living under a rock for some releases now, because I haven't heard anything about it. 
12:30:53 <Rembane> dsal: You might want to check out ExceptT too, as geekosaur said. 
12:31:45 <dsal> Yeah, my code is written by someone who doesn't keep up with trends well.
12:33:36 <petrus> How can I specify global configuration options in a cabal file?
12:33:52 <merijn> petrus: What do you mean by global?
12:34:28 <hpc> like stuff you would otherwise put in ~/.cabal?
12:35:11 <petrus> merijn: from the cabal manual: "The following top-level configuration options are not specific to any package, and thus apply globally"
12:37:31 <petrus> hpc: so where should I put it, give me a working example please
12:38:57 <hpc> can you link to the documentation you are looking at?
12:39:10 <hpc> or what specifically you are trying to accomplish?
12:39:24 <petrus> hpc: the latest cabal manual
12:39:30 * hackage hint 0.9.0.2 - Runtime Haskell interpreter (GHC API wrapper)  https://hackage.haskell.org/package/hint-0.9.0.2 (gelisam)
12:40:25 <hpc> i mean a specific link, so i know i am reading the same section as you
12:41:15 <petrus> hpc: show me a complete very simple cabal file with global config option say "verbose" which is accepted by cabal (3.0)
12:41:39 <hpc> ah
12:42:16 <hpc> so speaking generally, the only things that belong in a package's .cabal file are things that define that package
12:42:57 <hpc> there's a distinction between the definition of a package and a specific build or installation of that package
12:43:20 <hpc> things like "verbose" define how it's built, so it doesn't belong in the package itself
12:43:42 <hpc> and can't be in the package itself
12:44:23 <petrus> https://www.haskell.org/cabal/users-guide/nix-local-build.html#global-configuration-options
12:44:38 <merijn> petrus: Those are cabal.project options, not .cabal file options
12:44:51 <petrus> hpc: I don't see your point
12:45:42 <petrus> merijn: Oops, I see.
12:46:02 <petrus> let's see if that works.
12:51:15 <geekosaur> .cabal is for stuff that's needed to build the package at all, and comes from the package maintainer. cabal.project specifies your local settings to build such packages for your use
12:51:35 <geekosaur> somepackage.cabal, that is
12:52:00 * hackage dunai 0.5.2 - Generalised reactive framework supporting classic, arrowized and monadic FRP.  https://hackage.haskell.org/package/dunai-0.5.2 (IvanPerez)
12:52:50 <geekosaur> something like verbose is not something the maintainer should decide for you, so goes in cabal.project.
12:53:32 <geekosaur> in short, you as installer of a package shouldn't need to tweak its cabal file, but you should be able to specify settings in your cabal.project for whatever you're using it in
12:56:10 <petrus> okay, I got it. what I am after is to get cabal to create a minimal .ghc.environment file for my xmonad xonfig.
12:58:18 <hexagoxel> cabal.project.local is for your local settings. cabal.project should be in the repo for any multiple-package projects.
13:00:30 * hackage bearriver 0.10.4.5 - A replacement of Yampa based on Monadic Stream Functions.  https://hackage.haskell.org/package/bearriver-0.10.4.5 (IvanPerez)
13:01:33 <hexagoxel> (but that is nitpicking, of course. we agree at least on the first part of  x.cabal -> cabal.project -> cabal.project.local for "how environment-specific is the config")
13:02:42 <petrus> hexagoxel: Noted. That can be even simpler, just containing the single line: write-ghc-environment-files: always
13:06:41 <petrus> While playing around with this I noticed that the produced ghc-environment file is not always the same and definitely not minimal.
13:07:44 <petrus> I cannot pinpoint the reason for that variability.
13:09:30 <geekosaur> one possibility is that if you load your xmonad.hs into ghci (cabal repl, or equivalent) you'll get all its dependencies too
13:11:42 <geekosaur> if you loaded xmonad into cabal repl, you'll get its main module's dependencies
13:12:00 <petrus> I don't do that intentionally.
13:14:24 <petrus> But if I create the .ghc-env file from command line it is different from when it was created by the project file or when I assembly it from cabal store conf files for xmonad.
13:15:21 <petrus> any of them is okay for the xmonad recompile and/or loading to ghci.
13:17:06 <petrus> My minimal ghc-env file found by trimming the other ones works too! Although it is much smaller.
13:33:41 <Athas> I'm trying to 'cabal build' my program.  I get this error: '[__0] rejecting: futhark-0.13.0, futhark-0.12.1 (constraint from user target requires ==0.12.0)'.  The version I actually have in the directory is 0.13.0.  I have no idea why it would even talk about 0.12.1 or 0.12.0.
13:34:20 <merijn> Athas: cabal-instal 2.x or 3.0?
13:34:23 <Athas> 3.0.
13:34:34 <merijn> Do you have a cabal.project?
13:34:52 <Athas> No, and I also nuked any .ghc.environment booby traps.
13:35:09 <merijn> cabal doesn't pay attention to those, it's ghc/ghci that do
13:35:29 <merijn> Athas: Is the program part of the futhark package or a separate package?
13:35:42 <geekosaur> check the deps on your program? it's not enough that you have 0.13.0 in your project
13:35:48 <Athas> It's the futhark package.  It's defined in the common way with a library and an executable that depends on that library.
13:36:06 <merijn> Athas: pastebin you cabal file?
13:36:07 <Athas> I am not doing anything complex, project-wise.  It is a single package and all of its dependencies are on Hackage.
13:37:15 <Athas> https://gist.github.com/athas/42a8c15fd76182313b6f48e351f6b787
13:37:28 <Athas> It used to work fine, and I don't do anything fancy either.
13:38:08 <merijn> Athas: Unrelated, but you need an autogen-modules for Paths_futhark
13:38:54 <merijn> Actually, maybe not with 1.12 version that file lists...
13:39:02 <merijn> Athas: What's -v3 report?
13:41:03 <Athas> https://gist.github.com/athas/4e3f3ececcbc70f1e35b1b63d32960a7
13:41:03 <Athas> Perhaps important detail: I am running NixOS.
13:41:13 <Athas> I'm not doing anything Nix-ish here, though.
13:41:29 <Athas> And I am pretty sure I used to be able to 'cabal build' other things just fine.
13:42:26 <merijn> Athas: I have a vague spark of an idea
13:42:55 <merijn> Athas: Can you create a cabal.project file with just "packages: futhark.cabal" (in the same dir as the cabal file)
13:43:23 <Athas> Now it seems to build.  Why would this have any impact?
13:43:38 <merijn> Alternatively, can you try what happens with "cabal build all" (with the cabal.project file missing)
13:44:27 <Athas> Are cabal.project files mandatory now?
13:44:33 <merijn> Athas: I have a suspicion that something related to multi-component builds slipped through the cracks
13:45:21 <merijn> Athas: If you can invest a bit of time to debug I'd try if the "build all" fails or works (without the project file) *and* try and see if cabal-install 2.4 works with v2-build
13:45:40 <geekosaur> the v2 commands expect cabal.project, yes. cabal 3.x defaults to the v2-* commands
13:45:53 <geekosaur> cabal 2.x defaults to the v1-* commands
13:45:55 <merijn> geekosaur: v2 doesn't expect a cabal.project
13:46:04 <merijn> IF there is none, there is an implicit one
13:46:08 <Athas> I'm pretty sure I've managed to do v2-builds before 3.0 (and maybe with 3.0).
13:46:20 <Athas> I've certainly built other packages with 3.0 that did not have .project files.
13:46:26 <merijn> Athas: Right, so my suspicion is this:
13:47:23 <merijn> Athas: There's ongoing work for multi-component packages (i.e. allowing multiple libraries that can be dependent on independently), which means the solver solves them indepently, this is all still very WIP and *shouldn't* affect normal things.
13:47:59 <merijn> Athas: If I look throught the v3 output it insist on both futhark 0.13 and 0.12, 0.13 doesn't seem released yet
13:48:13 <Athas> Right, 0.13.0 is what I have in my directory.
13:48:24 <Athas> And there has never been a 0.12.0 release.
13:49:02 <merijn> So I'm wondering: Is it somehow solving both components independently and tying the exe to the hackage version. That's wrong and it shouldn't, but bugs happen...
13:49:17 <merijn> Although, now you point out that there's no 0.12.0 on hackage, that seems unlikely...
13:49:58 <merijn> Athas: oh, new crazy idea: What happens if you nuke cabal.project and dist-newstyle and just try "cabal build" again (without a project file)
13:50:26 <merijn> hmm, actually no, that theory also doesn't work.
13:50:29 <merijn> I'm stumped
13:53:00 * hackage hoppy-generator 0.6.0 - C++ FFI generator - Code generator  https://hackage.haskell.org/package/hoppy-generator-0.6.0 (khumba)
13:54:00 * hackage hoppy-docs 0.6.0, hoppy-std 0.6.0, hoppy-runtime 0.6.0 (khumba)
14:22:00 * hackage dunai 0.5.2.1 - Generalised reactive framework supporting classic, arrowized and monadic FRP.  https://hackage.haskell.org/package/dunai-0.5.2.1 (IvanPerez)
14:24:52 <sshine> hmm, in testing Hedgehog's exponential resizing, I think I'm not evoking 'sample' correctly: replicateM 100 (Hedgehog.sample (Gen.integral (Range.exponentialFrom 0 (-128) 128) :: Gen Integer)) ~> [3,-3,-1,-3,0,-1,3,2,2,...] -- don't look very exponential to me. is this because 'sample' starts from a low size and never advances the size?
14:26:50 <sshine> I wonder if there's a neat way to mimic QuickCheck's 'sample' that shows ten samples in different sizes.
14:27:11 <sshine> I mean, there is, but it's not part of the library, it seems?
14:39:22 <ebutleriv> What's the best way of representing an integer in binary form in Haskell? (sequence of bits, a string of ones and zeros, or any other option likely works. I just want a thing I can traverse over, probably)
14:40:56 <merijn> ebutleriv: Do you need to interleave operating on the integer and the bits?
14:41:08 <ebutleriv> I don't, I think
14:41:21 <EvanR> it depends on what you want to do with the bits
14:41:29 <merijn> I mean, there's the Bits typeclass
14:42:07 <EvanR> decide bit by bit how to do a fold... take them in 8 bit chunks...
14:42:17 <EvanR> only operate on runs of length n
14:42:30 <EvanR> different data structures
14:44:02 <sshine> ebutleriv, probably with 'Int' or 'Word' or whatever integer type most appropriately models the size and signedness of your data, and then Data.Bits for bitwise traversal?
14:45:03 <EvanR> yeah also depends on where the original data comes from
14:46:43 <sshine> ebutleriv, "best" is probably subjective. for educational purposes, data Bit = O | I and [Bit] is probably very helpful but not something you'd put in production. :P
14:49:50 <ebutleriv> Sure. I was just wondering if there was any specific/obvious/idiomatic way of turning an Int/Integer into a list-like container of ones and zeros. (I want to take the least significant n bits and use them to represent the path down a binary tree to a leaf at index i)
14:51:48 <EvanR> there's probably a lens for that
14:52:06 <EvanR> but you can use Data.Bits to do it yourself
14:55:32 <ebutleriv> Ah, alright. Thanks
15:07:36 <dmwit> ebutleriv: Can you just reuse IntMap?
15:07:41 <dmwit> Which... basically does that?
15:14:00 * hackage bearriver 0.10.4.6 - A replacement of Yampa based on Monadic Stream Functions.  https://hackage.haskell.org/package/bearriver-0.10.4.6 (IvanPerez)
15:38:44 <fresheyeball> is there a flag to turn off warnings on missing synonym signatures?
15:39:38 <fresheyeball> -fno-warn-missing-pattern-synonym-signatures
15:39:40 <fresheyeball> does not work
15:42:00 <fresheyeball> -fno-warn-missing-pat-syn-sigs
16:13:10 <jle`> hm, usually if the warnings are disablable, it'll mention it in the warning i think
16:13:40 <iqubic> Really?
16:14:00 * hackage can-i-haz 0.2.0.0 - Generic implementation of the Has and CoHas patterns  https://hackage.haskell.org/package/can-i-haz-0.2.0.0 (0xd34df00d)
16:14:12 <iqubic> But if you disable all warnings, then you should be disabling ALL of them. Including the one that tells you that warnings are disabled.
16:14:52 <jle`> i meant the specific warning
16:15:16 <jle`> so if you want to disable warnings for, say, redundant imports, then the redundant imports warning will tell you the name of the warning to disable
16:15:29 <jle`> oh i suppose i should have pinged fresheyeball 
16:17:52 <iqubic> Oh, I see.
16:45:02 <iqubic> I wish more langauges had a QuickCheck library.
16:45:29 <iqubic> Because trying to do property testing in Java is a pain.
16:48:51 <sshine> iqubic, Hedgehog exists in many languages: https://github.com/hedgehogqa counting: Scala, Haskell, F#, R.
16:54:00 * hackage regex-pcre-builtin 0.94.5.8.8.35 - Replaces/Enhances Text.Regex  https://hackage.haskell.org/package/regex-pcre-builtin-0.94.5.8.8.35 (AudreyTang)
16:54:11 <iqubic> but not Java I see.
17:05:37 <lyxia> iqubic: https://github.com/pholser/junit-quickcheck ?
17:26:34 <dibblego> https://github.com/hedgehogqa/scala-hedgehog
17:32:30 * hackage postgresql-simple-opts 0.5.0.0 - An optparse-applicative and envy parser for postgresql-simple's connection options  https://hackage.haskell.org/package/postgresql-simple-opts-0.5.0.0 (JonathanFischoff)
17:43:30 * hackage scheduler 1.4.2.1 - Work stealing scheduler.  https://hackage.haskell.org/package/scheduler-1.4.2.1 (lehins)
17:49:51 <d34df00d> Let's say I have a `type family CTData (f :: Stage) ty where ...`, and then I have `data Foo f = MkFoo (CTData f Int)`. Is it possible to (standalone-)derive Eq or Show for all `f` at once?
17:50:00 * hackage massiv 0.4.2.0 - Massiv (Массив) is an Array Library.  https://hackage.haskell.org/package/massiv-0.4.2.0 (lehins)
17:50:34 <lyxia> d34df00d: what happens if you try
17:51:40 <d34df00d> I'm surely able to do `deriving instance Show (Foo 'FirstStage)` and so on for other elements of `Stage`, but if I try `deriving instance (Show (CTData f ty)) => Foo f`, then the type checker complains it has no instance for `Show (CTData f ty0)`
17:53:29 <d34df00d> I'm also able to do `deriving instance (Show (CTData f Int)) => Foo f `, but the problem is that in reality I have a bunch of different fields in MkFoo with different types, so that doesn't scale either.
17:53:45 <heatsink> You could fix that by giving the type family only one parameter.  Is it really indexed by both parameters?
17:53:56 <d34df00d> heatsink: yep.
17:53:57 <heatsink> I mean to change it to type family CTData (f :: Stage) :: * -> *
17:54:10 <d34df00d> Sort of.
17:54:13 <d34df00d> I think.
17:54:28 <lyxia> deriving instance (forall ty. Show (CTData f ty)) => Show (Foo f)     with {-# LANGUAGE QuantifiedConstraints #-} ?
17:54:39 <d34df00d> I have instances like `CTData 'Parsed _ = ()`, `CTData 'Supported Void = Void`, `CTData 'Value ty = ty`. Does it fit your approach?
17:55:13 <lyxia> no because there are instances matching on the second parameter...
17:55:13 <heatsink> no, it doesn't
17:55:38 <d34df00d> lyxia: nope :(
17:55:54 <d34df00d> lyxia: Could not deduce (Show (CTData f ty)) from the context: forall ty. Show (CTData f ty)
17:56:12 <lyxia> ah... that's yet another issue in the way :/
17:57:19 <d34df00d> This error puzzles me a bit btw. Isn't, like, the whole point of that `forall` to express what we need here?
17:57:44 <heatsink> You don't have a single polymorphic instance, which is what the 'forall' needs to match
17:57:55 <heatsink> Which Show instances do you have for CTData?  Maybe you could encode the constraint differently
17:58:48 <d34df00d> That depends on `ty`. All of CTData instances map `ty` either to itself or to (). So if `ty` can be shown, then `CTData f ty` can be shown for all `f`s I hvae.
17:59:41 <heatsink> ok.  Then you should be able to have just a Show ty constraint
17:59:44 <d34df00d> Also I think I fail to understand your explanation of the error message.
18:00:08 <d34df00d> heatsink: but, if I understand correctly, ghc won't reduce CTData f ty to ty will it?
18:01:06 <d34df00d> So I'm basically having `Could not deduce (Show ty0) from the context: Show ty \\ bound by an instance declaration: forall ty (f :: Stage). Show ty => Show (Foo f)`
18:01:43 <d34df00d> Hmm.
18:01:44 <d34df00d> Hold on.
18:01:50 <d34df00d> The quantified constraint works now. 
18:02:06 <d34df00d> So `deriving instance (forall ty. Show ty) => Show (Foo f)` seems to work, yes.
18:02:10 <d34df00d> heatsink: thanks!
18:02:25 <d34df00d> But why didn't `deriving instance (forall ty. Show (CTData f ty)) => Show (Foo f) ` work?
18:02:39 <lyxia> that instance is unusable
18:02:41 <d34df00d> Is it because of injectivity or smth?
18:03:06 <lyxia> it's basically discharging all your Show (CTData f ty0) with the (forall ty. Show ty) by instantiating ty with (CTData f ty0)
18:03:58 <d34df00d> And what's the problem with that? I'm having effectively CTData f ty0 (along with infinitely many other ty's) to the left of =>, am I?
18:04:11 <lyxia> but then to satisfy (Show ty) you need a universal instance "instance Show ty" which doesn't exist.
18:04:27 <lyxia> to satisfy "forall ty. Show ty"
18:06:26 <d34df00d> Ah right, so I've just hit that `deriving instance (forall ty. Show ty) => Show (Foo f)` doesn't work either..
18:06:56 <d34df00d> (it just deferred the error from the instance declaration point to the point of using that instance.
18:06:59 <d34df00d> ()
18:07:06 <d34df00d> That sucks.
18:07:38 <heatsink> It should be possible to make it work with a Show ty constraint (not quantified)
18:07:48 <heatsink> Did you understand why the quantified constraint is unusable?
18:07:53 <d34df00d> But `ty` isn't mentioned on the RHS of =>
18:07:54 <lyxia> If you didn't have "CTData 'Supported Void = Void" there might have been a way
18:08:44 <d34df00d> heatsink: because I'm claiming that for all ty : Type, Eq ty?
18:08:59 <d34df00d> And ty has nothing to do with the RHS either.
18:09:00 <heatsink> not that
18:09:18 <d34df00d> You mean the one involving type families? That one I don't understand.
18:09:21 <lyxia> unless you happen to not care about showing trees indexed by Supported or similar phases which do different things depending on the second argument.
18:09:31 <heatsink> it's claiming that you can provide an `instance Show ty where ...` to satisfy the constraint
18:09:46 <heatsink> That is a single instance that works forall ty
18:10:14 <d34df00d> Ah, right, that's different.
18:10:18 <heatsink> That's what lyxia was pointing out
18:10:50 <d34df00d> lyxia: unfortunately those are precisely the ones I care about the most at the moment.
18:14:31 <heatsink> You could reflect the parameter f to a value, and then pattern match on the value in your instance Show (Foo f)
18:14:40 <lyxia> the next thing you can do is use Generics or TH to list out a Show constraint for every field, but at that point, you might as well generate the boilerplate instances you already have.
18:18:19 <d34df00d> https://gitlab.haskell.org/ghc/ghc/issues/14860 lol.
18:18:22 <d34df00d> That's exactly my case.
18:19:26 <d34df00d> I guess you folks were about to propose what SPJ seems to propose there.
18:21:27 <lyxia> I vaguely remember that is a known issue but not which one exactly
18:26:42 <fresheyeball> jle`: It says "unrecognized warning flag"
19:43:12 <dsal> For some reason I thought   Right x <> Left x   was Left.
19:44:10 <iqubic> No.
19:45:14 <iqubic> Left _ <> b = b
19:45:23 <iqubic> a <> _ = a
19:45:37 * EvanR squints carefully at these equations
19:46:14 <iqubic> Those are in 'instance Monoid (Either a b) where ...'
19:47:06 <iqubic> Those are weird equations.
19:47:08 <EvanR> yep
19:47:27 <EvanR> what exactly is "the identity" element for this monoid
19:48:24 <dsal> EvanR: Right mempty
19:48:30 <EvanR> (there's supposed to be only one)
19:48:34 <iqubic> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Either.html#line-138
19:48:38 <dsal> I thought.
19:48:51 <EvanR> dsal: well, iqubic says theres no monoid assumed for the b type
19:49:14 <iqubic> EvanR: Semigroup doesn't have to need an identity.
19:49:25 <dsal> oh.  Well, the semigroup is obvious anyway.  Just not exactly what I wanted right here in this line of code.
19:49:49 <EvanR> instance Monoid...
19:50:04 <iqubic> There is no Monoid instance for either in Base.
19:50:12 <EvanR> i've been had
19:50:47 <iqubic> See, I'm just reading the Haddocks from Hackage's website.
19:50:57 <iqubic> It's freely accessible information.
19:50:57 <dsal> Weird.  Iw as sure there was a monoid.
19:51:42 <iqubic> Appears not.
19:52:05 <EvanR> the identity element must be unique
19:52:37 <EvanR> with no monoid support from a or b you can't get one
19:53:21 <dsal> > mempty :: Maybe String
19:53:23 <lambdabot>  Nothing
19:53:33 <dsal> Seems like    Left ""   would work.
19:53:47 <dsal> Oh wait, no...  I see.
19:54:07 <dsal> Anyway... this isn't the thing I'm doing.  I'm trying to figure out if all this code I wrote is actually better.
20:06:55 <Guest56239> hi guys
20:07:04 <Guest56239> need some help
20:07:19 <Guest56239> how to implement map using foldl??
20:07:30 <c_wraith> only very badly.
20:07:39 <Axman6> that sounds like home work - have you tried to do it yourself?
20:07:39 <c_wraith> does it have to be foldl?  it's much easier with foldr
20:08:13 <Guest56239> no,,its not home work
20:08:15 <c_wraith> map with foldl is O(n^2)
20:08:17 <Guest56239> i was studying for midterm
20:08:26 <Guest56239> done with foldr
20:08:31 <Guest56239> now going to foldl
20:08:51 <c_wraith> the correct answer is "don't, it's incorrect for performance and laziness reasons"
20:09:07 <Guest56239> what?
20:09:32 <Guest56239> just studying fold l and its working
20:09:36 <c_wraith> implementing map with foldl loses the important laziness properties of map, and it makes it O(n^2) instead of O(n) to do the whole list
20:09:48 <dibblego> map cannot be written with foldl
20:10:14 <c_wraith> > take 10 (map (*2) [1..])
20:10:16 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
20:10:18 <dibblego> https://www.youtube.com/watch?v=GPwtT31zKRY
20:10:21 <c_wraith> You can't do that with foldl
20:10:38 <c_wraith> So it's incorrect to implement map with foldl
20:11:19 <Guest56239> ok..
20:11:52 <Guest56239> c_wraith..can u explain why its O(n^2)
20:12:04 <dibblego> because foldl does a loop
20:12:14 <c_wraith> You need to add each element to the end of the list accumulated so far.
20:12:28 <c_wraith> since lists are immutable linked lists, that means copying the whole thing
20:12:32 <Guest56239> ?
20:13:09 <dibblego> it can be done in O(n), ignoring the fact that it cannot be done for all list inputs
20:13:29 <c_wraith> If you add extra processing steps outside the fold, anyway
20:14:06 <dibblego> \f -> foldl (flip (:)) [] . foldl (\b a -> f a : b) []
20:14:18 <c_wraith> yes, that's adding an extra processing step outside the fold
20:14:35 <c_wraith> it happens to be an entire other fold :)
20:15:18 <Lears> A little more sneakily, there's \f l -> foldl (\dl x -> dl . (f x :)) id l []
20:15:46 <c_wraith> yeah, I considered that one too.  Less processing outside the fold, but it's still there. :)
20:16:00 <EvanR> you could semi reasonably do a map + reverse
20:16:25 <c_wraith> that's what dibblego did!  He just spelled reverse the long way :)
20:16:50 <EvanR> the first step in doing any foldl is a reversal
20:17:00 <EvanR> basically
20:17:25 <dibblego> foldl f z list does this loop: { var r = z; foreach(el in list) { r = f(r, el); } return r; }
20:17:33 <EvanR> oh god
20:17:43 <dibblego> foldr replaces constructors
20:18:08 <Guest56239> great,....thank you
20:18:22 <Guest56239> is there any haskell deevloper here?
20:18:27 <dibblego> "why do we need foldl?" because Can we be Liberated from von Neumann style? Not entirely.
20:18:34 <Guest56239> typo
20:18:38 <Guest56239> developer
20:19:26 <c_wraith> you mean people who work on the implementation?
20:22:19 <EvanR> dibblego: i think that's more foldl'
20:22:40 <dibblego> ya
20:22:42 <EvanR> the for loop
20:24:29 <nshepperd> foldl only really exists to have something to compare foldl' to
20:25:59 <EvanR> foldl makes the rest of us look good
20:27:51 <isBEKaml> can foldr ever blow the stack? 
20:27:56 <dibblego> Yes.
20:28:15 <EvanR> if you set the stack limit low enough
20:28:31 <EvanR> but so can foldr
20:28:40 <c_wraith> foldr (+) is pretty bad for stack space use
20:30:04 <EvanR> lightning round: what happened to foldr' ?
20:30:29 <c_wraith> it exists in Data.Foldable.  It's just really bad for [].  It's really useful for snoc-lists, though!
20:30:34 <isBEKaml> it turned into foldr1, i think
20:31:07 <dibblego> foldr1 works on non-empty lists
20:31:47 <EvanR> it's really bad for []? Or it just does nothing like I would have thought?
20:32:18 <c_wraith> There's no way to use foldr' for [] without using stack space proportional to the length of the list
20:34:18 <c_wraith> so, you know, the same problem as foldr (+), except on all input functions
20:34:37 <EvanR> i see foldr's "base case" is the thing you normally only use at the end
20:34:48 <EvanR> but priming makes you use this base case now
20:35:23 <EvanR> which is good for foldl because, "the end" is "now"
20:51:30 * hackage aeson-yaml 1.0.0.0 - Output any Aeson value as YAML (pure Haskell library)  https://hackage.haskell.org/package/aeson-yaml-1.0.0.0 (patrick)
21:44:26 <pikajude> for foldl, the end is now
21:44:30 <pikajude> uh-oh
21:56:51 <MarcelineVQ> But Marduk prophesised that one day, many millenia in the future when the word was in grave danger foldr' would once again be found and the power it could unlock would save the world from descrution.
21:58:09 <EvanR> foldr' used at the end of the universe reverses entropy and causes the big bang
21:58:26 <EvanR> don't forget
22:01:42 <MarcelineVQ> there's a giant post-it in the universal core that says: remember to reverse entropy when finished
22:03:07 <EvanR> like a self cleaning oven
22:04:47 <MarcelineVQ> Yes, exactly like when an oven cleans itself by applying reverse-heat
22:05:21 <EvanR> hey negative temperature is hotter than infinite
22:05:35 <EvanR> it cleans up
22:21:47 <iqubic> What does "foldr'" do?
22:22:23 <EvanR> we can only answer this with some source code
22:28:22 <jle`> fresheyeball: what warning flag are you using?
22:28:53 <jle`> fresheyeball: what i mean to say is, when you get a warning about missing synonym signatures, it should display the name of the missing synonym signatures warning
23:12:00 * hackage list-t 1.0.4 - ListT done right  https://hackage.haskell.org/package/list-t-1.0.4 (NikitaVolkov)
23:47:00 * hackage bech32 1.0.0 - Implementation of the Bech32 cryptocurrency address format (BIP 0173).  https://hackage.haskell.org/package/bech32-1.0.0 (ErikDeCastroLopo)
