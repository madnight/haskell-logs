00:04:16 <EvanR> -recypies
00:30:28 <Axman6> recy pies feels like the name of an Australian food but I can't think what it'd be
00:51:12 <tdammers> isn't that a general pattern with Australian things?
00:53:20 <Axman6> oi, watch it
00:59:30 * hackage validity 0.9.0.2 - Validity typeclass  https://hackage.haskell.org/package/validity-0.9.0.2 (Norfair)
01:00:31 * hackage genvalidity 0.9.0.1, validity-path 0.4.0.0 (Norfair): https://qbin.io/mice-endif-ge79
01:02:35 <chesscipher> merijn: there is also to say that in OpenBSD you have to allow W^X (I'm newbie in OpenBSD so I may be doing it wrong)
01:03:14 <merijn> chesscipher: That might be true, yes
01:08:30 * hackage generics-mrsop-gdiff 0.0.1 - Reimplementation of the `gdiff` algorithm for `generics-mrsop`  https://hackage.haskell.org/package/generics-mrsop-gdiff-0.0.1 (vcmiraldo)
01:09:53 * ski idly wonders what the topology on `W^X' is
01:14:45 <rsoeldner_> Is there any reason why I cant find `hxt-xmlschema` https://github.com/UweSchmidt/hxt/tree/master/hxt-xmlschema on hackage ? :-/
01:17:13 <merijn> rsoeldner_: Well, maybe the author never released it in hackage?
01:22:04 <rsoeldner_> merijn, :-)
01:32:49 <merijn> hmm, so if I've opened an issue with a question/suggestion without response for 3 weeks (despite activity on the repo), what's the best ettiquette? Tag the maintainer in the issue? Mail them?
01:45:23 <cdepillabout> merijn, In my opinion, three weeks is a pretty long time.  I'd say that it would be reasonable to ping the maintainer on GitHub again.
01:46:15 <cdepillabout> Of course, as a maintainer, it's much easier to reply when the person posting an issue has come up with a good solution and is asking permission to send a PR.
01:52:06 <merijn> cdepillabout: Well, that's exactly what I was waiting for :p
01:52:20 <merijn> cdepillabout: I don't wanna bother implementing something if it's not going in
02:01:36 <tdammers> implementing is cheap and easy, talking about it is the hard part
02:03:41 <cdepillabout> merijn, hope you get a response this time!
02:06:10 <Guest_25> Failed to install, consider updating this script via: ghcup upgrade"ghcup --cache install" failed!
02:06:25 <Guest_25> I wonder why it is when I was installing haskell
02:32:37 <sshine> in QuickCheck, can I pass a test without failing? 'discard' seems to cause Hspec's 'configFailFast = True' to halt testing.
02:34:22 <sshine> hmm, that's weird.
02:34:54 <sshine> since 'discard' does the same as (==>), I would have imagined, at least, that ==> doesn't halt when its LHS is False. >_>
02:43:33 <dminuoso> sshine: At first glance discard seems to be different.
02:44:43 <dminuoso> sshine: discard appears to be an exception being flung around.
02:45:00 <dminuoso> (A pure one ontop of that)
02:45:12 <sshine> yes.l
02:45:25 <dminuoso> Where as ==> constructs a property
02:45:50 <sshine> in Hspec there is 'pending'
02:45:57 <sshine> but it has type HasCallStack -> Expectation.
02:46:12 <sshine> it doesn't seem like I can mix Expectation and Property.
02:53:47 <sshine> dminuoso, ==> still discards, which causes Hspec to print "Gave up after 0 tests!" in red and halt when configFailFast = True.
02:56:21 <dminuoso> sshine: Well the halting mechanism is different. can you gist your code?
03:01:44 <sh0t> hello guys, I am looking for a library to parse arguments and parameters from stadin, because I want to write a small program able to parse arguments like this: ./prog -t 4 -s "string" . Is optparse-applicative the way to go? (I am pretty new to haskell)
03:03:06 <Rembane> sh0t: optparse-applicative is very good at it, I recommend it. 
03:03:26 <sh0t> thank you Rembane.
03:04:41 <Rembane> sh0t: No worries, we're here if you get stuck. 
03:12:22 <tsahyt> I'm trying to bind to a part of a C++ codebase, and I can't get it to link properly, I keep getting undefined references. my approach is to use inline-c-cpp to write thin wrappers around the methods in the class I'm trying to bind to. this should probably work, but linking doesn't. the C++ code does compile to a static library, but I've also tried just pulling the entire thing in and telling cabal about it
03:12:24 <tsahyt> in cxx-sources. does anyone know how to get this to work?
03:17:30 * hackage hdiff 0.0.1 - Pattern-Expression-based differencing of arbitrary types.  https://hackage.haskell.org/package/hdiff-0.0.1 (vcmiraldo)
03:18:37 <sh0t> Rembane, hi. I am trying to compile the simple Hello.hs file in https://github.com/pcapriotti/optparse-applicative/tree/master/tests/Examples . But ghc says it cannot find Options.Applicative. I run cabal install options --lib (it seems succesfully), i still get the same error.
03:22:05 <Rembane> sh0t: What happens if you furst run cabal install optparse-applicative ? 
03:23:06 <sh0t> Rembane, that it works :), sorry for the dumb question
03:24:01 <sh0t> i mean it compiles
03:28:22 <Rembane> sh0t: No worries. :)
03:28:30 * hackage servant-errors 0.1.1.0 - Servant Errors wai-middlware  https://hackage.haskell.org/package/servant-errors-0.1.1.0 (epicallan)
03:34:15 <bolver> i have list [[(1,4),(2,4),(3,4),(4,4)],[(5,7),(6,7),(7,7)],[(8,12),(9,12),(10,12),(11,12),(12,12)],[(13,15),(14,15),(15,15)]]
03:39:36 <bolver> i have a list -- [[(1,4),(2,4),(3,4),(4,4)],[(5,7),(6,7),(7,7)],[(8,12),(9,12),(10,12),(11,12),(12,12)],[(13,15),(14,15),(15,15)]]
03:39:59 <bolver> and i want to get [(4,5,7), (7,8,12), (12,13,15)]
03:40:22 <bolver> is there a neat way to do this using higher order functions?
03:43:54 <bolver> appreciate any help
03:45:24 <Rembane> bolver: I don't see what you want to do, can you explain using english? 
03:45:54 <Rembane> bolver: I see the initial data, and the final data, but what are the steps in between?
03:46:17 <noumenon> he wants to combine the second element of the last pair of one list and the entire first pair of the following list into a triplet
03:46:35 <noumenon> and do that for every consequent pair of lists
03:46:47 <bolver> actually, if you look at the list i posted, what i want to do is take the last one from the preceeding list and join it with the first one of the next list
03:47:13 <bolver> exactly
03:47:39 <bolver> noumenon: you're right
03:55:30 * hackage servant-errors 0.1.1.1 - Servant Errors wai-middlware  https://hackage.haskell.org/package/servant-errors-0.1.1.1 (epicallan)
03:58:17 <Rembane> bolver: I think I would use a recursive function to do it. 
03:58:30 <bolver> Rama[m]: i see
03:59:12 <bolver> Rembane: i see
04:00:04 <bolver> no other easy way to do it using any of the built-in functions, i suppose
04:03:41 <bolver> thanks 
04:05:42 <Rembane> Meh. There was another way. https://gist.github.com/Rembane/14273990cb3b25d53d022de42ccc364d
04:11:30 * hackage ghc-syntax-highlighter 0.0.4.1 - Syntax highlighter for Haskell using lexer of GHC itself  https://hackage.haskell.org/package/ghc-syntax-highlighter-0.0.4.1 (mrkkrp)
04:13:20 <boxscape> ^ hm I wonder if there's some way to use an external tool like this for syntax highlighting in vim
04:13:56 <merijn> boxscape: If you truly want it, sure
04:14:43 <merijn> boxscape: I've looked into this in the past so I know two things: 1) vimscript supports foreign calls to C code, and 2) calling Haskell via C ABI is fairly easy
04:14:55 <boxscape> that's interesting
04:15:04 <merijn> boxscape: So you could even call Haskell code directly from vim
04:15:08 <boxscape> neat
04:15:41 <Rembane> Here, have a rabbit hole! :D
04:17:18 <merijn> (I considered using parsec to parse Haskell code to to indenting >.>)
04:32:00 * hackage servant-errors 0.1.2.0 - Servant Errors wai-middlware  https://hackage.haskell.org/package/servant-errors-0.1.2.0 (epicallan)
04:32:31 <whaaaaaa> Good day! I've got a question about limits and co-limits. What's the difference between push-outs and pull-backs? They look exactly the same
04:35:37 <crvs[m]> The pull back is a subset of a product
04:35:51 <crvs[m]> The pushout ID a quotient of a disjoint union
04:35:56 <crvs[m]> Is
04:36:41 <crvs[m]> Essentially the pushout is a union
04:37:23 <Taneb> whaaaaaa: the two are dual to each other, if you compare the diagrams for them the arrows are all reversed
04:37:42 <crvs[m]> And if you know databases, the pullback is a join
04:43:28 <miguel123> hello
04:43:59 <ski> hello miguel123
04:46:36 <miguel123> I want to write some "integration?" tests that call a remote API and than have to wait for callbacks from a server. If the correct callbacks arrive within a timeframe the test pass, otherweise fail. Is there any library that can support me with this? Or should I just put something together by myself (some complex multithreaded IO actions) and wrap
04:46:37 <miguel123> them inside Hspec tests for instance?
05:07:28 <dminuoso> miguel123: It seems you could rig something trivial with timers.
05:07:34 <dminuoso> That is, the package named timers.
05:08:48 <miguel123> I'll have a look at this package thanks 
05:09:40 <boxscape> https://wiki.haskell.org/Calling_Haskell_from_C says that `ghc -c -O Safe.hs` produces Safe_stub.c, but with `stack ghc -- -c -O Safe.hs` I'm only getting Safe_stub.h. How can I get Safe_stub.c?
05:10:48 <merijn> I don't think _stub.c is still a thing
05:10:52 <boxscape> I see
05:11:21 <boxscape> (not that I need it for anything to work - I just wanted to have a look at the C code)
05:11:48 <dminuoso> merijn: Ah perhaps not actually
05:12:18 <merijn> I wrote an example of calling Haskell from C (apparently 5 years ago...) and didn't need a _stub.c then
05:12:34 <merijn> boxscape: https://gist.github.com/merijn/4a0fee2b3a5ef3476aa4
05:12:35 <dminuoso> miguel123: http://hackage.haskell.org/package/timeit-2.0/docs/System-TimeIt.html is a package by a secret author, whose name I will not utter in here
05:13:10 <merijn> dminuoso: What, augustss? ;)
05:13:12 <boxscape> merijn and _stub.o?
05:13:28 <dminuoso> merijn: Spot on!
05:13:47 <dminuoso> merijn: Ah I see you just adopted it.
05:13:54 <merijn> Mind you, timeit only tracks CPU time, because I haven't gotten around to making it to wallclock and CPU time yet
05:14:05 <merijn> dminuoso: Yeah, I want to MonadIO-ify it
05:14:11 <merijn> s/want/wanted
05:14:13 <dminuoso> Mmm, for remote interaction it's probably better to measure wallclock time
05:14:22 <dminuoso> Otherwise it would skew the tests
05:15:04 <dminuoso> miguel123: Do you want preemption if the duration is too low?
05:15:14 <dminuoso> merijn: It might be easier actually to just protect your computation with a timeout.
05:15:21 <merijn> boxscape: All the symbols are just in the Haskell objects
05:15:26 <dminuoso> Gah, why is tab completion so weird.
05:16:25 <boxscape> okay, thanks merijn
05:16:41 <crvsf> ^X^O
05:37:11 <miguel123> dminuoso: I HAVE TO preempt it, since there is no guarantee that the condition will be EVER met (if I got your question correctly)
05:37:11 <miguel123> dminuoso
05:37:55 <miguel123> ah, and there is only a maximum timeout. I do not have a minimum time required
05:38:02 <dminuoso> miguel123: Then perhaps just System.Timeout.timeout ?
05:38:38 <dminuoso> miguel123: You can use an MVar for synchronization.
05:39:17 <dminuoso> miguel123: That is, set it up such that you timeout on trying to read from an MVar, and your callback ends up filling that mvar.
05:39:18 <miguel123> dminuoso: yeah I was considering using an MVar. and System.Timeout.timeout seems sufficient for my requirements, I just had a look. Thank you
05:40:06 <miguel123> now I will try to put all the pieces together, thank you everybody
05:45:30 * hackage mmsyn2 0.1.3.0 - The library that can be used for multiple (Ord a) => a -> b transformations  https://hackage.haskell.org/package/mmsyn2-0.1.3.0 (OleksandrZhabenko)
06:05:30 * hackage galois-field 1.0.0 - Galois field library  https://hackage.haskell.org/package/galois-field-1.0.0 (sdiehl)
07:03:00 * hackage publicsuffix 0.20190927 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20190927 (wereHamster)
07:40:30 * hackage folds 0.7.5 - Beautiful Folding  https://hackage.haskell.org/package/folds-0.7.5 (ryanglscott)
07:54:00 * hackage criterion 1.5.6.1 - Robust, reliable performance measurement and analysis  https://hackage.haskell.org/package/criterion-1.5.6.1 (ryanglscott)
07:55:00 * hackage base62 0.1.0.0 - Base62 encoding and decoding  https://hackage.haskell.org/package/base62-0.1.0.0 (andrewthad)
08:01:50 <higherorder> Hey! Is there anyone here familiar with GHCJS who could tell me whether there is a more up to date setup guide than https://github.com/ghcjs/ghcjs/wiki/GHCJS-User-Guide (2016)
08:13:10 <dmj`> higherorder: it's easier to get ghcjs if you're using nix
08:13:31 <dmj`> higherorder: nix-shell -p haskell.compiler.ghcjs86 --run 'ghcjs --version'
08:23:00 * hackage elliptic-curve 0.3.0 - Elliptic curve library  https://hackage.haskell.org/package/elliptic-curve-0.3.0 (sdiehl)
08:23:35 <dmj`> higherorder: it should be cached
08:24:00 <higherorder> dmj`: ah; is there any tutorial on how to get started with GHCJS on nix though? configuring the build, etc
08:24:04 <higherorder> I've never used nix before
08:24:23 <Taneb> Installing nix just for GHCJS is probably a little overkill
08:24:57 <dmj`> higherorder: miso has some stuff on it, doesn't go too deep though, but will get you a working application to boot
08:25:03 <dmj`> higherorder: https://github.com/dmjio/miso#nix
08:25:25 <dmj`> Taneb: the things we do for type sharing ...
08:25:31 <higherorder> dmj`: brilliant, ty. All I want is to compile a haskell project to use as a library from a JS project
08:26:00 <dmj`> higherorder: the GHCJS FFI is great for calling into existing javascript libraries
08:26:08 <higherorder> Taneb: I'm quite keen on learning Nix either way, so if it's good for GHCJs then happy to try it out
08:26:28 <higherorder> dmj`: I kind of want to do the opposite here. Expose a nice API from Haskell that a JS project can call
08:26:31 <Taneb> higherorder: in that case, I encourage you to use nix! :D
08:27:15 <dmj`> higherorder: that works too
08:27:47 <higherorder> dmj`: do you have much experience with GHCJS? One thing I am wondering about is how good the minimisation/dead code elimination is
08:27:55 <higherorder> can I except fairly small js bundles?
08:28:00 <higherorder> expect*
08:29:06 <Tristan91> Hi, I'm just starting out; what text editors would you recommend?
08:29:48 <monochrom> What you're already using.
08:29:56 <Tristan91> Alright, is geany fine?
08:30:12 <monochrom> I haven't heard of it.
08:30:57 <dmj`> higherorder: yea, I've compiled a 300 module Haskell project to GHCJS that created a 20MB payload and closure compiled it down to 4MB, gzipped sent over the wire at 2MB
08:31:11 <higherorder> I am using VSCode with GHCIDE; pretty great I would say (except that it doesn't currently support template haskell well)
08:31:25 <dmj`> higherorder: facebook the website sends like 20MB to users, so people just whine about js size
08:31:41 <higherorder> dmj`: Facebook sends 20MB of JS, really?!
08:31:48 <higherorder> I guess 2MB is more than fine then
08:31:56 <dmj`> higherorder: something ridiculous, if you take into account like all the js from advertisers
08:32:00 <higherorder> does GHCJS provide type annotations for Closure? 
08:32:18 <dmj`> higherorder: I'm not sure what you mean by type annotations
08:34:15 <higherorder> dmj`: https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler
08:34:26 <higherorder> I think Closure uses those to guide minification
08:37:04 <dmj`> higherorder: I don't really use that tbh
08:38:23 <dmj`> higherorder: I just export js top level so it doesn't get closure compiled
08:38:38 <dmj`> higherorder: window['foo'] = function foo () { /* js goes here */ }
08:38:47 <higherorder> dmj`: ah ok, thanks. I'll try that
08:38:57 <higherorder> dmj`: can you pipe the output of GHCJS directly in Closure?
08:39:06 <higherorder> and get a bundle out that has your lib/moduels at the top level?
08:39:18 <dmj`> higherorder: foreign import javascript unsafe "foo" :: Callback -> IO ()
08:39:33 <dmj`> higherorder: yes, ghcjs was written in such a way to be used with closure compilation
08:39:54 <dmj`> higherorder: yea, there is a function you can call to run your ghcjs app
08:40:13 <dmj`> in js
08:40:33 <dmj`> higherorder: instead of embedding ghcjs in a js app, why not go the other way
08:43:41 <higherorder> dmj`: I have a limited amount of time for this project and I am familiar with the tooling & APIs around UI development in JS, so I thought a good compromise would be to write the core of my application (whcih is entirely pure) in Haskell, and write the shell in JS
08:45:02 <dmj`> higherorder: what does the shell in js do
08:45:21 <dmj`> higherorder: is it responsible for drawing?
08:45:56 <higherorder> dmj`: no; it would be responsible for rendering the interface (React) and for all IO
08:46:43 <dmj`> higherorder: is the user interface sophisticated ? because you can do the drawing and IO in haskell as well 
08:49:24 <higherorder> dmj`: fairly sophisticated yes. I know I could do it in Haskell, but considering the time I have for this project and my lack of familiarity with Haskell UI librairies and structuring IO, I think I'll opt for writing only the pure, core logic in Haskell
08:49:36 <higherorder> it's the part where I think I'll really benefit from using Haskell anyway
08:50:24 <dmj`> higherorder: sounds reasonable
08:50:57 <higherorder> dmj`: how has your experience been with GHCJS in general? Any pitfalls I should be aware of? 
08:51:11 <higherorder> As in, does it work with the big librairies (lenses, etc) and with all GHC extensions? 
08:51:15 <higherorder> (including templte haskell)
08:51:32 <boj> it works fine in all of those cases
08:51:52 <dmj`> higherorder: it's great, use it at work, other companies use it too for public facing websites https://www.polimorphic.com/
08:52:14 <dmj`> higherorder: run chrome's audit tool on that website ^
08:53:26 <higherorder> dmj` trying that now! and out of curiosity do you have an opinion on it v.s. using purescript?
08:53:51 <dmj`> higherorder: I use ghcjs because I want to share my haskell types on the client, and access the haskell ecosystem of packages on the client.
08:54:56 <dmj`> higherorder: sharing types also helps me to not worry about serialization and crossing the network boundary as much, which is like 100% of web dev work. "adjusting the json"
08:55:17 <higherorder> dmj`: makes sense
08:55:25 <boj> higherorder: my team would echo every point dmj` has made here
08:55:54 <dmj`> higherorder: all lens libraries work great and are encouraged. One thing that kind of sucks though right now is template haskell w/ ghcjs, but you don't have to use it for most things
08:56:27 <higherorder> dmj`: what's the problem with template haskell w/ Ghcjs?
08:56:34 <higherorder> and does that impede automatic generation of lenses?
08:56:34 <dmj`> higherorder: its as silver bullet as it gets, the singularity is near
08:56:57 <dmj`> higherorder: it's just slow to compile
08:57:10 <dmj`> have to compile the splices w/ node.js iirc
08:57:15 <boj> yep
08:58:07 <higherorder> Ah; so it works, it's just slow
08:58:19 <higherorder> dmj`: are all extensions supported? e.g. generics
08:58:35 <dmj`> higherorder: yes, generics is the main thing. But yea, DerivingStrategies, use all that on the client
08:58:44 <merijn> higherorder: ghcjs uses GHC as a front-end, so it supports anything GHC supports
08:59:24 <dmj`> higherorder: slow TH usually just means doing someLens = lens field $ \p r -> p { _field = r } instead of $(makeLenses 'SomeRecord)
08:59:26 <dmj`> in practice
08:59:48 <dmj`> higherorder: linking in ghcjs is just js file concatenation
08:59:58 <higherorder> fair; what about using generic lens? 
09:00:14 <dmj`> higherorder: very well supported
09:00:36 <dmj`> higherorder: ghcjs 8.6 is supported
09:00:48 <dmj`> higherorder: but there is a bug where putStrLn doesn't work on ghcjs 8.6
09:00:54 <monochrom> oops
09:01:10 <dmj`> so just use foreign import javascript unsafe "console.log($1)" consoleLog :: MisoString -> IO ()
09:01:13 <monochrom> But wait, what is putStrLn doing in a web browser? :)
09:01:21 <monochrom> Oh, that.
09:04:12 <dmj`> :P
09:04:19 <dmj`> browser is the new OS haven't you heard
09:04:46 <dmj`> https://bellard.org/jslinux/
09:05:17 <dmj`> this one can do gui https://copy.sh/v86/
09:08:06 <higherorder> haha
09:08:11 <higherorder> dmj`: do you use React with GHCJS?
09:08:45 <monochrom> How do I install ghcjs?  Do I just go to their github and build from source?
09:08:48 <dmj`> higherorder: I just use miso for all the drawing, miso is basically react (has its own diffing algorithm which is faster than react's and simpler to understand).
09:09:02 <merijn> monochrom: I think the answer is "nix"?
09:09:13 <monochrom> :S
09:09:24 <EvanR> the answer is a question
09:09:26 <dmj`> higherorder: it looks like Elm though, but gives you typeclasses, type sharing, you don't have to write DOM manipulation manually, and a global state to manage via lenses, and its extensible.
09:10:11 <dmj`> monochrom: it's painful to do it any other way, stack used to be the easiest way, but snoyman and chris allen dropped support for installing ghcjs w/ stack since they didn't want to maintain that part of the code base.
09:10:59 <shapr> does anyone use -split-sections or -split-objs in production?
09:11:13 <shapr> cal[m]: you writing any code today?
09:11:21 <monochrom> I am not in production, but I always use -split-sections
09:11:41 <monochrom> I turn it on in $HOME/cabal.config
09:12:05 <shapr> does it increase compilation time?
09:12:23 <monochrom> I think no.
09:12:29 <shapr> ya know, I don't really care if it takes longer... I mostly want to combine it with musl and see if I can make really small static binaries
09:12:37 <merijn> shapr: Oh!
09:12:40 <shapr> but I'll start with -split-sections
09:12:46 <monochrom> Not really small, but smaller.
09:12:55 <merijn> shapr: Please write down your experience, this has been on my todo list for a while now
09:13:05 <monochrom> split-objects is the slow one.
09:13:09 <shapr> merijn: sure, assuming I don't get distracted
09:13:45 <shapr> monochrom: according to ghc docs, -split-sections is more efficient and produces smaller files, why would anyone use -split-objs?
09:13:47 <dmj`> shapr: nix enables -split-objects by default now for its builds
09:13:54 <dmj`> to decrease the binary size
09:14:00 <monochrom> split-objs was there first
09:14:07 <shapr> oh, the incumbent
09:14:13 <shapr> hysterical raisins
09:14:16 <shapr> yeah, that's a good reason
09:14:40 <dmj`> shapr: i meant split-sections :P
09:14:47 <shapr> oh good
09:15:17 <shapr> I'm gonna resist switching my life to nix until this project is done, but it's next on the list
09:15:28 <dmj`> shapr: best thing I ever did
09:15:43 <shapr> still resisting until :-P
09:15:44 <merijn> dmj`: Why's that?
09:16:00 <shapr> monochrom: you put it into ghc-options?
09:16:17 <shapr> I currently have   ghc-options: -O2 -j12 +RTS -A128m -n4m -RTS
09:16:46 <shapr> does dons' rts options optimizer still work?
09:16:47 <dmj`> merijn: the years of my life I've wasted installing dependecies that I could have just fetched from a binary cache. The ruined relationships over "works on my machine" conversations, now solved via reproducible builds.
09:17:00 * hackage pairing 1.0.0 - Bilinear pairings  https://hackage.haskell.org/package/pairing-1.0.0 (sdiehl)
09:17:11 <monochrom> No, I put it in $HOME/.cabal/config, "split-sections: True"
09:17:18 <merijn> dmj`: ah, so you're deploying to a bunch of different machines?
09:17:54 <dmj`> merijn: just to aWS
09:17:56 <dmj`> AWS*
09:18:07 <shapr> monochrom: thanks, I'll use that
09:18:25 <merijn> dmj`: (I'm just curious whether the reason everyone loves Nix is just because they have different workflows, since I've so far had little incentive to switch)
09:19:19 <monochrom> If you like -O2, consider also "optimization: 2".  http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#O2
09:19:48 <dmj`> merijn: the solution imo to the cabal vs. stack drama was to innovate by going back in time and using runghc for everything, which I believe nix does.
09:19:48 <merijn> Unrelatedly, reddit tells me rumours that 8.8 is much faster at compiling than 8.6, anyone know if this is true?
09:20:11 <dmj`> merijn: since nobody agrees on how to version haskell packages, using doJailbreak in nix is super nice too.
09:20:40 <Taneb> merijn: I believe it's true that reddit has rumours to that effect, but I've not investigated further
09:20:52 <dmj`> nix just constructs an immutable ghc-pkg list for you. The years of my life I've wasted poking at ghc-pkg list.
09:21:06 <merijn> dmj`: I don't think "nobody" agrees, the vast majority seems to follow PVP, even most FPComplete stuff
09:21:29 <merijn> dmj`: So far I'm just using v2-build + v2-freeze
09:21:49 <shapr> I wish hoogle would include last updated or something. I'm trying to figure out which urlEncode / urlDecode I want
09:21:50 <dmj`> merijn: yea but there's always an issue when you use a lot of dependencies, and that can take hours to resolve, doJailbreak is a nice way to not break the flow.
09:23:07 <devalot> merijn: Adding to dmj': I can depend on any version of any package.  Sometimes I need to pull in unreleased changes to a package via the latest Git commit.  Nix makes that very easy to do.
09:24:36 <merijn> devalot: v2-build can do that too, though :)
09:26:21 <jzyamateur> What is meaning of parentheses in an expression? Is it just for grouping or implies strict execution as well? e.g. f (1 + 3) is a fn application expression, but f always returns a constant value, is (+) ever evaluated?
09:26:53 <merijn> jzyamateur: "maybe"
09:27:01 <EvanR> in let x = foo x in bar x, is x a free variable or a bound variable
09:27:03 <jzyamateur> I was under assumption that (1+3) executes followed by f 
09:27:05 <dmj`> merijn: plus nix is a single abstraction over a lot of tedious things that are important and annoying, and it handles them well.
09:27:17 <Ariakenom> jzyamateur: it's just grouping
09:27:34 <jzyamateur> ok, got it
09:27:41 <merijn> dmj`: Yeah, but Nix itself is rather tedious to install, so I need that tediousness to be outweighed by the benefits, which so far doesn't seem the case :)
09:27:59 <EvanR> didn't mean to use x recursively. let x = foo a b in bar x
09:28:16 <EvanR> x is bound? x is free?
09:28:30 <merijn> EvanR: free in "bar x" but bound in "let ... in bar x"
09:28:37 <dmj`> merijn: whenever I need to install nix I just run that curl one-liner, very easy imo
09:28:46 <merijn> dmj`: Sure, if you've got root
09:29:07 <merijn> dmj`: If you don't, you have to build it + dependencies from source :p
09:29:07 <dmj`> merijn: why wouldn't you have root
09:29:10 <monochrom> The whole sentence is "x is free in that expression"
09:29:25 <dmj`> merijn: the solution seems to have root :)
09:29:32 <monochrom> there is no independent "x is free".
09:29:39 <merijn> dmj`: Because nobody gets root on university/supercomputer clusters? :)
09:29:45 <monochrom> s/independent/standalone/
09:29:58 <EvanR> monochrom: and then there's implementation details :)
09:30:57 <merijn> dmj`: Same thing every single time you wanna install something *googles "how to install X"* 'oh, just run apt-get install!', as if I'd google that if I could just do that >.>
09:31:04 <monochrom> Blame it on Bill Gates for popularizing PCs.
09:31:48 <dmj`> merijn: yea, but I bet your laptop would let you have root
09:31:48 <monochrom> If PCs were not popular, most people who be using non-root accounts, therefore most software would not assume you have root.
09:32:11 <merijn> dmj`: Sure, but that doesn't help me if I need to run it on "not my laptop" :p
09:32:34 <dmj`> merijn: don't use computers that you can't control, problem solved :) 
09:32:35 <merijn> monochrom: I still don't understand how literallye very package manager requires root to install thing....
09:32:49 <merijn> dmj`: I can't afford my own supercomputer, though >.>
09:33:06 <monochrom> See, I was going to say "put virtualbox in your university account, then you have emulated root" but then wait, maybe installing virtualbox requires root too.
09:33:13 <dmj`> merijn: nixOS can be put on raspberry pis :)
09:33:32 <merijn> monochrom: I mean, Nix supposedly can work without root, but irony of ironies the default Nix build doesn't support that because it assumes the store is in /nix >.>
09:33:46 <merijn> And you need to build from source to change that
09:33:49 <dmj`> merijn: I'm just lazy and like to do services.nginx.enable = true, instead of actually configuring things properly
09:36:14 <EvanR> expr is let x='a':y; y='b':x in f x. You still say x is bound in expr ?
09:38:44 <EvanR> so in a system of linear equations, all the variables are bound?
09:38:49 <EvanR> what about 1 equation
09:40:27 <EvanR> basically it's not clear to me if "let" is a "variable binding operator"
09:41:57 <EvanR> seems kind of ridiculous if i read what i said
09:42:57 <vilpan> it happens, you just need to speak to your rubber duck more often
09:43:25 <EvanR> i guess the rule of thumb is, i can rename let bound variables with impunity. If I change free variables "bad things could happen"
09:43:25 <halogenandtoast> How adverse are people to using Data.Data, for example, I have an ADT of factions in a game, over time I know I will be adding more factions to this list, but I want a way to get a list of all of them. How "bad" is it to do something like allFactions = map fromConstr $ dataTypeConstrs $ dataTypeOf (undefined :: Faction)
09:43:51 <halogenandtoast> Or is there a more "acceptable" way to achieve this?
09:44:03 <EvanR> you can substitute free variables, but not bound variables. It wouldn't make sense
09:44:34 <jzyamateur> Is it possible to trace expression execution in haskell?
09:44:47 <hyperisco> halogenandtoast, why is there a data constructor per faction if the number changes?
09:45:21 <halogenandtoast> To pattern match on factions to decide game decisions
09:45:47 <hyperisco> How are you going to pattern match on a changing number of things? Then the number of branches changes
09:46:29 <halogenandtoast> hyperisco: -fwarn-incomplete-patterns will handle that, but for instance, as I add factions I want the user to be able to choose one, so I want to show all choices
09:46:45 <halogenandtoast> data Faction = GreatCthulhu | CrawlingChaos | BlackGoat | YellowSign deriving (Show, Eq, Data)
09:47:16 <EvanR> ok, it's basically an Enum
09:47:28 <EvanR> if you put deriving(Enum,Bounded) you could listen them all
09:47:30 <hyperisco> Are you talking about, like, code generation?
09:47:47 <higherorder> dmj`: ah sweet; I'lll try miso then :)
09:47:48 <EvanR> > [minBound .. maxBound] :: [Bool]
09:47:50 <lambdabot>  [False,True]
09:47:54 <EvanR> all the Bools
09:47:55 <Ariakenom> jzyamateur: look at the Debug.Trace module https://hoogle.haskell.org/?hoogle=Debug.Trace&scope=set%3Astackage
09:48:05 <halogenandtoast> EvanR: basically, but it's not ordered, and I don't want to impose the idea that it is.
09:48:16 <EvanR> halogenandtoast: ... then sort the liste?
09:48:32 <EvanR> a list must appear in some order
09:48:54 <halogenandtoast> Sure, so my read of this is that people are a bit adverse to Data.Data
09:48:56 <dmj`> higherorder: we have a slack. If you join and need help you can ping me. We have a script for everything.
09:49:21 * dmj` slowly opens coat jacket
09:49:21 <higherorder> dmj`: oh that would be brilliant; thank you
09:49:24 <EvanR> i'm adverse to "it could work, so let's use it"
09:49:38 <EvanR> rather than do something that makes more sense
09:49:44 <dmj`> higherorder: perfect
09:50:04 <halogenandtoast> EvanR: sure, but conceptually Faction doesn't have a minBound or maxBound, so it feels weird to add it.
09:50:09 <EvanR> i don't understand how Data.Data is superiod over Enum Bounded
09:50:13 <higherorder> dmj`: ah I didn't realise you are actually the author of miso?
09:50:14 <halogenandtoast> That solution will work of course
09:50:28 <EvanR> it's not bounded?
09:50:36 <EvanR> you have infinite factions?
09:50:50 <hyperisco> halogenandtoast, do you mean you are going to edit the source code to add and remove factions?
09:51:07 <halogenandtoast> hyperisco: yes
09:51:23 <EvanR> you could also implement a different class or use a library that lists all enum values
09:51:32 <EvanR> but this is built in
09:51:34 <halogenandtoast> EvanR: it is a finite set, but what does it mean for it to be minBound in this case?
09:51:42 <hyperisco> halogenandtoast, so you are talking about code generation then. Well, try TH I guess.
09:51:45 <EvanR> minBound is just the first one
09:51:56 <EvanR> when you implement Enum you map to Int
09:52:17 <EvanR> when you derive Ord you get an implicit ordering
09:52:44 <hyperisco> halogenandtoast, if factions are so variable that you're worried like this then usually one just says they're dynamically changing
09:52:45 <EvanR> > map fromEnum ([minBound .. maxBound] :: [Bool])
09:52:48 <lambdabot>  [0,1]
09:53:36 <hyperisco> halogenandtoast, so you would instead have, say, a Set of factions, and factions might be identified by a Text, or something.
09:53:38 <halogenandtoast> EvanR: So for clarification, I'm just discussing the implication, I don't disagree with your solution, I am just interesting in understanding how others read this problem a bit more. My conceptual road block is that there is not such thing as a first or last faction without an arbitrary definition of order (lets say the order they appear in the rulebook)
09:53:57 <EvanR> as i understood it, you want "list the faction enums"
09:54:01 <EvanR> i.e. in some order
09:54:12 <ski> hm, no `Enum Void' instance ?
09:54:22 <hyperisco> halogenandtoast, you can do operations such as folds and lookups on the Set (or Map) rather than case analysis
09:54:46 <hyperisco> halogenandtoast, "all the factions" is just toList on the Set or keys of the Map.
09:54:51 <EvanR> and yeah i wasn't going to bring it up, but using a list of strings for this would make even more sense
09:55:05 * ski supposes there's no `(Enum a,Enum b) => Enum (Either a b)', either ..
09:55:09 <EvanR> than relying on any given type system bang or whistle
09:56:48 <dmj`> higherorder: yea
09:57:01 * hackage tree-sitter 0.4.0.0 - Unstable bindings for the tree-sitter parsing library.  https://hackage.haskell.org/package/tree-sitter-0.4.0.0 (robrix)
09:57:01 <dmj`> higherorder: I have a conflict of interest
09:57:14 <halogenandtoast> Okay, understood. Not sure how I feel about using Text matchers, I'll have lots of functions that will depend on implementing a choice for each faction and using a String/Text based representation will mean I won't always catch where I've missed a case for it.
09:57:25 <higherorder> dmj`: haha
09:57:27 <dmj`> higherorder: I'll "make you a deal" if you can "look into" miso.
09:57:29 <halogenandtoast> EvanR: I think your Bounded solution is probably the best way to think about it.
09:58:05 <higherorder> dmj`: fresh
09:59:00 * hackage tree-sitter-typescript 0.2.1.1 - Tree-sitter grammar/parser for TypeScript  https://hackage.haskell.org/package/tree-sitter-typescript-0.2.1.1 (robrix)
09:59:04 <ski> EvanR : "expr is let x='a':y; y='b':x in f x. You still say x is bound in expr ?" -- yes (but free in  x='a':y; y='b':x  )
10:00:01 <halogenandtoast> Thanks for the feedback EvanR and hyperisco 
10:00:30 * hackage tree-sitter-tsx 0.2.1.1 - Tree-sitter grammar/parser for TSX  https://hackage.haskell.org/package/tree-sitter-tsx-0.2.1.1 (robrix)
10:00:42 <Quenty> Hi, I'm looking for a term for a function where the output of the function is a state that can be used as the input for the initial conditions of that function, and it results in the same output.
10:00:42 <Quenty> So for example, if you have a differential equation for the model for a spring, and which has the state of initial position/velocity, you can put in the time elapsed and output the current position/velocity of the spring. If you saved that state into a new spring, it would output the same value for time 5 seconds later as the time elapsed for the initial model. 
10:00:42 <Quenty> I think this is some subset of a pure function, and I'm looking for a vocabulary term to better describe this problem/solution space. Anyone know if this has a name? 
10:01:29 <EvanR> ski: really....
10:02:16 <EvanR> because at that point it's ok to substitute for x or y
10:02:59 <EvanR> Quenty: are you talking about a periodic function, or
10:03:30 * hackage tree-sitter-ruby 0.2.0.1 - Tree-sitter grammar/parser for Ruby  https://hackage.haskell.org/package/tree-sitter-ruby-0.2.0.1 (robrix)
10:03:31 <EvanR> x = timeShift period x
10:04:42 <EvanR> timeShift x . timeShift y = timeShift (x+y)
10:05:08 <EvanR> homomorphism
10:06:39 <tokopolopolo[m]> Wow, I'm gonna learn some real math here
10:06:44 <EvanR> or if you just mean timeShift dt x always has the same result... that's just a pure function
10:07:00 <Quenty> I think this is a subset of a pure function.
10:07:22 <EvanR> yeah, if you can state a new law your function follows, it may have a fancy name
10:08:35 <Quenty> So the function is pure in the functional sense
10:08:45 <Quenty> but also this: model = spring(initPos)(initVel); spring(0) = initPos, initVel
10:08:51 <Quenty> (sry, not haskell syntax)
10:09:06 <hyperisco> Quenty, you mean  f(x) = x  ?
10:09:08 <Quenty> model = spring(initPos)(initVel); model(0) = initPos, initVel
10:09:44 <Quenty> Ohh uh, yeah, can probably write it in that f(x, 0) = x
10:09:56 <EvanR> timeShift 0 x = x
10:09:59 <Quenty> so f(f(x)(1)) = f(1)
10:10:14 <Quenty> so f(f(x)(1))(0) = f(1)
10:10:24 <EvanR> timeShift dt (timeShift dt' x) = timeShift (dt+dt') x
10:10:34 <Quenty> From your definition of timeShift, yeah, I think that's right
10:10:43 <hyperisco> Quenty, I think you may be talking about an identity
10:11:06 <tokopolopolo[m]> What's the function for?
10:11:21 <EvanR> (x stands for your state here)
10:11:22 <hyperisco> Quenty, if there exists an  e  such that forall x,  f e x = x  then it is said that  e  is a left-identity of  f
10:11:25 <EvanR> could be many numbers
10:11:42 <Quenty> it's an animation function for a vector of length N, such that acceleration is maximized
10:11:57 <Quenty> inputs are position, target, velocity, and maxAcceleration (scalar)
10:12:30 <Quenty> output is for given dt passed (position, velocity)
10:12:37 <EvanR> well, fancy names aren't everything. At least you can write down some equational laws
10:13:04 <Quenty> I have a 1D solution from a friend (not in haskell) :p
10:13:05 <EvanR> implementing timeShift follow these laws efficiently seems tough at first glance
10:13:14 <Quenty> we were just discussing the overall implementation for a vector of size N
10:13:22 <Quenty> and I figured maybe someone had a name for it
10:13:33 <EvanR> "a physics engine" :)
10:14:15 <tokopolopolo[m]> I'm dumb with math
10:15:00 <Quenty> here's the 1D implementation in Lua if you're interested https://github.com/Quenty/NevermoreEngine/blob/version2/Modules/Shared/Physics/AccelTween.lua
10:15:13 <Quenty> lol
10:16:01 <EvanR> (space and) time shifting operators following the above laws has the same form as the rules for exponentials
10:16:16 <hyperisco> maybe homomorphism was spot on
10:16:28 <EvanR> e^dx e^dx' = e^(dx+dx')
10:16:30 <EvanR> e^0 = 1
10:17:02 <hyperisco> the question is… "homomorphism"… so now what? :)
10:17:02 <EvanR> exponentials are a group homomorphism between addition of numbers and multiplication of positive numbers
10:17:30 * hackage tree-sitter-go 0.2.0.1 - Tree-sitter grammar/parser for Go  https://hackage.haskell.org/package/tree-sitter-go-0.2.0.1 (robrix)
10:19:00 * hackage tree-sitter-haskell 0.2.0.1 - Tree-sitter grammar/parser for Haskell (with GHC extensions)  https://hackage.haskell.org/package/tree-sitter-haskell-0.2.0.1 (robrix)
10:19:23 <EvanR> if you interpret e^ as timeshift, it's a homomorphism between addition of numbers and composition of time shifts
10:20:00 * hackage tree-sitter-java 0.2.0.1 - Tree-sitter grammar/parser for Java  https://hackage.haskell.org/package/tree-sitter-java-0.2.0.1 (robrix)
10:21:00 * hackage tree-sitter-json 0.2.0.1 - Tree-sitter grammar/parser for JSON  https://hackage.haskell.org/package/tree-sitter-json-0.2.0.1 (robrix)
10:21:00 <hyperisco> discrete physics simulations don't have this property, lol
10:21:15 <EvanR> not unless youre very careful
10:22:23 <Quenty> the careful part of is you take the state for current dt and add some number to it (i.e. add velocity, or change the target), and then generate a new function that will continue on a smooth path
10:22:30 * hackage tree-sitter-php 0.2.0.1 - Tree-sitter grammar/parser for PHP  https://hackage.haskell.org/package/tree-sitter-php-0.2.0.1 (robrix)
10:22:46 <hyperisco> I mean, by "discrete", there are simulations that are deliberately not careful, for sake of speed
10:23:02 <Quenty> in a normal physics engine this doesn't work too well, because A) it's expensive and B) you end up recalculating state every frame anyway
10:23:18 <Quenty> so yeah, the idea here is to solve a non-discrete physics simulator for animations
10:23:26 <hyperisco> continuous
10:23:27 <Quenty> well, it's barely a physics simulation
10:23:53 <EvanR> homomorphisms are an instance of continuity in a generalized sense, i think
10:23:57 <Quenty> yeah, that's the right term. it's really useful to have a solved state because you can A) project remaining time B) throttle/ignore animation framerate as desired
10:24:08 <hyperisco> if it is a closed system, with a valid initial state, it is much less a bother
10:24:33 <hyperisco> it is when you have to deal with invalid states and spontaneous changes (typically user input) that it goes haywire
10:24:47 <Quenty> yeah
10:25:11 <Quenty> since group operation is preserved, I think it just inherits continuity or lack-there-of from the grouop
10:25:30 * hackage tree-sitter-python 0.5.0.0 - Tree-sitter grammar/parser for Python  https://hackage.haskell.org/package/tree-sitter-python-0.5.0.0 (robrix)
10:25:56 <Quenty> probably the wrong terms there, but I think a homomorphism doesn't directly have a property of continuity? From my limited understanding. :p 
10:26:21 <hyperisco> the homomorphism EvanR suggested necessitates it
10:26:31 <EvanR> talking about a generalized kind of continuity
10:26:42 <EvanR> not one specific from metric space analysis
10:26:57 <EvanR> see also the similarity to the functor laws
10:27:27 <EvanR> fmap id = id.  fmap (f . g) = fmap f . fmap g.   I don't exactly know how it's related though.
10:27:33 <hyperisco> it says that the progression of states is independent of the time steps taken
10:27:53 <hyperisco> so, taking 5ms steps has to be the same as taking 10ms steps, or random steps, etc
10:27:57 <EvanR> yeah that's a good concrete conclusion
10:28:09 <hyperisco> which is exactly what discrete simulations don't guarantee
10:28:14 <EvanR> usually
10:28:22 <EvanR> but they can
10:28:38 <EvanR> i had an idea for an algorithm that does it, for FRP
10:28:57 <hyperisco> instead, the idea is that you can vary the accuracy by varying the time step, trading for compute time
10:29:20 <EvanR> that's how they justify it but I don't think thats the best way
10:29:27 <Quenty> most physics simulations actually just slow down simulation time because varying time-steps causes instability in most simulations
10:29:29 <hyperisco> there are hybridised approaches
10:30:00 <Quenty> in this case, the goal is to have the ability to pop-out the current state of the system without having to solve for all the previous states
10:30:12 <Quenty> which is not something a discrete model can easily do
10:30:27 <EvanR> another way is, for non-real-time simulation, you choose steps so that the final error is below your threshold 
10:30:57 <EvanR> but having it be exact by a careful arrangement would be better
10:33:14 <hyperisco> Quenty, that is true but with even with continuous methods you cannot necessarily just jump to a time t from an initial state
10:33:38 <EvanR> if your timeShift function follows the law, then it effectively does
10:33:39 <hyperisco> Quenty, particularly if you're solving for collisions
10:34:05 <hyperisco> it does but not without the cost of computing something similar to intermediate states
10:34:12 <Quenty> right, in this case, we're not. that is, the only interaction possible is when we dictate it. 
10:34:14 <EvanR> it depends on how you do it
10:34:22 <hyperisco> there are various partitioning methods
10:34:25 <EvanR> but having that law even helps you with the intermediate states
10:34:46 <hyperisco> but basically speaking, you figure out when the next collision occurs in a partition, then you resolve that collision and repeat
10:35:25 <hyperisco> so if you have bodies colliding every second, and you want to jump ahead one thousand years, that is going to take a lot of compute time
10:35:32 <EvanR> i think the difficulty in getting physics simulations to follow laws is due to semantics (or lack there of)
10:36:39 <EvanR> hyperisco: here's one for you, if your system is decomposable into periodic orthogonal systems, you could jump ahead to any point in time you want by factoring the jump into the periods...
10:36:44 <Quenty> in this case, the base rules we discussed for this simulation are:
10:36:44 <Quenty> 1: it should take the least amount of time.
10:36:44 <Quenty> 2: It should be accelerating at max acceleration magnitude at all times.
10:36:44 <Quenty> 3: any state it outputs can be input as an initial state, which will result in the same output
10:36:44 <hyperisco> and if you then want to figure out what it looks like after 900 years, you're going to redo a lot of work
10:36:52 <hyperisco> So maybe some memoisation is in order. I don't know.
10:37:13 <EvanR> (or jump back)
10:37:24 <EvanR> timeShifts mentioned above work in reverse
10:38:08 <hyperisco> EvanR, if you could solve the period of the system, yes. I don't know if that is even computable and my spidey sense is saying "no" :P
10:38:18 <EvanR> you don't need the period of the whole system
10:38:26 <EvanR> only the components
10:38:34 <hyperisco> okay, take one of the components
10:38:36 <EvanR> because they are orthogonal (by assumption)
10:38:42 <hyperisco> how do you solve the period of the component
10:38:57 <hyperisco> that probably is not computable
10:39:16 <EvanR> as an example, the microwave oven contains 3N known-period harmonic modes
10:39:24 <hyperisco> even assuming the system doesn't diverge
10:39:25 <EvanR> so you don't solve that, it's by construction
10:39:40 <EvanR> and the system doesn't diverge
10:40:02 <hyperisco> okay, sure, if you do it by construction
10:40:06 <EvanR> yep :)
10:40:15 <hyperisco> periodic physical systems by construction… yikes?
10:40:24 <EvanR> yeah this dude fourier invented it
10:41:25 <EvanR> (real physics simulators sometimes use a decomposition like this as the basis for the simulation)
10:41:47 <saml> how many hours do you sleep
10:41:48 <EvanR> fourier himself invented this technology to solve heat equations
10:42:18 <hyperisco> saml, also incomputable
10:42:49 <saml> if you quantize it, it's countable
10:43:03 <EvanR> i have a feeling that continuity is your ticket to *being* computable
10:44:14 <hyperisco> wasn't being serious
10:44:17 <EvanR> when a perfect point particle supposedly collides with the edge of a perfectly flat plane, these are precisely the situations where exact real arithmetic will freeze up, or the possibility of computing the result gives you the unconstructive limited principle of omniscience
10:44:30 <saml> to be able to compute, you need to convert to 0 and 1. so you lose continuity 
10:44:52 <EvanR> saml: haha... no! 
10:45:39 <EvanR> for instance if you want to compute the min or max of two infinite streams of 0s and 1s, you can do it because min and max are continuous
10:45:58 <EvanR> (for reals between 0 and 10
10:46:02 <EvanR> (for reals between 0 and 1)
10:46:44 <hyperisco> digitisation isn't a necessity for computation, so I fundamentally disagree
10:48:36 <EvanR> sure you can have analog computers with some error margin. But i hope you are referring to some even more generalized notion of computation
10:49:38 <hyperisco> I don't know what "convert" means unless we're talking about analogue vs digital
10:49:57 <hyperisco> DACs and ADCs
10:50:30 <hyperisco> computation isn't just what takes place after the ADC and before the DAC
10:50:34 <EvanR> you could also convert torque with a gear train
10:51:09 <hyperisco> Maybe a CVT is more apt, because gears have teeth :P
10:51:25 <tokopolopolo[m]> Does information require the system to be countable?
10:51:32 <EvanR> they have teeth, but a digression reveals that they have special shapes that make the contact continuous
10:52:19 <EvanR> you could say that euclid would compute diagrams without converting 0 and 1
10:52:30 <tokopolopolo[m]> I never get infinities
10:54:01 <hyperisco> tokopolopolo[m], I think you're asking an information theory question, and the answer is that continuous variables also have entropy
10:54:54 <EvanR> countable and uncountable can be a red herring unless you're very careful with what you're counting, what you define as a system
10:55:07 <tokopolopolo[m]> For example?
10:55:12 <nshepperd2> A sufficiently sophisticated computer program can do anything a mathematician can do with pen and paper, including "continuous" calculations
10:55:18 * tokopolopolo[m] uploaded an image: Screenshot_20190927-232311.png (105KB) < https://matrix.org/_matrix/media/v1/download/matrix.org/LWgXAnqnYMQJaEUBImgHJsgx >
10:55:33 <tokopolopolo[m]> I don't get that
10:55:50 <nshepperd2> Mathematics on paper uses discrete symbols, after all
10:55:58 <hyperisco> nshepperd2, wait, you're saying there is no advantage to my graphite-parchment computation machine?
10:56:33 <EvanR> tokopolopolo[m]: is haskell uncountable? More precisely, are there types with an uncountable number of inhabitants? Even this question still requires some fleshing out to get a good result
10:56:40 <hyperisco> And I was just beginning to sort out the overheating issues that caused the parchment to spontaneously combust…
10:57:12 <EvanR> and as I've been saying, even if it doesn't, you can still get the same benefits of continuity without having uncountability
10:57:22 <hyperisco> tokopolopolo[m], my knowledge of information theory is limited. This is relevant though https://en.wikipedia.org/wiki/Entropy_(information_theory)#Extending_discrete_entropy_to_the_continuous_case
10:58:23 <tokopolopolo[m]> About that stackexchange, how is the intersection 0?
10:58:25 <EvanR> because continuity is about laws and not number
10:58:44 <hyperisco> Are 64 bit machines more continuous than 32 bit machines?
10:59:43 <dmwit> tokopolopolo[m]: Do you agree that 0 is in the intersection?
11:00:14 <tokopolopolo[m]> Uh... no? How?
11:00:23 <dmwit> tokopolopolo[m]: Because 0 is in every interval being intersected.
11:00:37 <dmwit> (...and "being in the intersection" means exactly "being in all the sets being intersected".)
11:00:59 <dmwit> tokopolopolo[m]: If you do not agree that 0 is in every interval being intersected, then my next question is: which interval is it not in?
11:01:17 <tokopolopolo[m]> I can agree that each set involved has elements on the neighborhood of 0, but how 0?
11:01:21 <hyperisco> dmwit, that is devilish
11:01:35 <masaeedu[m]> is it possible to have a comonad instance for `Free f` in terms of a comonad instance for `f`?
11:01:46 <dmwit> tokopolopolo[m]: Do you agree that the interval (-1, 1) includes 0?
11:02:01 <tokopolopolo[m]> Sure?
11:02:11 <dmwit> tokopolopolo[m]: Do you agree that the interval (-1/2, 1/2) includes 0?
11:02:35 * masaeedu[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/aJSkgEmvrWwSSIpQouvKHjAm >
11:02:35 <tokopolopolo[m]> Ah, gotcha.
11:03:04 <tokopolopolo[m]> Sorry, misunderstood semantics. I get you now.
11:03:23 <dmwit> tokopolopolo[m]: Okay. I think now you believe that 0 is in the intersection, which is progress.
11:03:28 <tokopolopolo[m]> Man I'm worse than a drunk guy
11:03:32 <dmwit> The next step is to show that everything that isn't 0 isn't in the intersection.
11:03:59 <tokopolopolo[m]> I get it till the end.
11:04:02 <dmwit> cool
11:04:08 <japer> *laughs in Zorn lemma*
11:04:09 <hyperisco> I'll rule out the elephants, because n is a real
11:06:04 <tokopolopolo[m]> (Still don't regret asking. After all, I'm but an interaction of particles)
11:07:56 <japer> masaeedu[m]: do you mean that suspending functor has `Comonad` instance?
11:08:43 <masaeedu[m]> `instance Comonad f => Comonad (Free f)`
11:08:45 <masaeedu[m]> @japer
11:08:45 <lambdabot> Unknown command, try @list
11:10:13 <tokopolopolo[m]> I misintepreted the intersection for a union of sets of -1/n to 1/n with n in N. I probably should see a doctor.
11:11:33 <dmwit> ...but 0 is in the union, too.
11:11:53 <dmwit> So there must have been a second confusion!
11:13:36 <tokopolopolo[m]> That one I don't get
11:14:16 <tokopolopolo[m]> That's why I talked of the neighborhood.
11:14:17 <higherorder> dmj`: if I want to use GHCJS only, without miso, what would be the minimal Nix config?
11:14:20 <dmwit> "being in the union" means "being in any of the sets being unioned".
11:14:24 <dmwit> 0 is in (-1, 1).
11:14:37 <dmwit> (-1, 1) is one of the sets being unioned.
11:14:41 <dmwit> So 0 is in the union.
11:14:57 <tokopolopolo[m]> Yes? And where does 0 fit?
11:15:03 <dmwit> "fit"?
11:16:02 <dmwit> (To make that a complete question: What do you mean by "fit"?)
11:16:17 <tokopolopolo[m]> Lol I misinterpreted the whole thing to be a union of the sets {1/n,-1/n} n being a natural.
11:16:23 <japer> masaeedu[m]: https://repl.it/@repaj/free-comonad it works, I think
11:16:33 <dmwit> Oh. Well, that is indeed a very different thing. =)
11:16:56 <tokopolopolo[m]> That's why I probably should see a doctor.
11:17:11 <tokopolopolo[m]> Kek
11:19:07 <tokopolopolo[m]> > I misintepreted the intersection for a union of sets of -1/n to 1/n with n in N. I probably should see a doctor.
11:19:08 <tokopolopolo[m]> I also fucked up this description
11:19:09 <lambdabot>  <hint>:1:46: error: parse error on input ‘of’
11:19:14 <dmwit> japer: How do you show that fmap extract . duplicate = id? I get fmap extract (duplicate f) = Done (extract f) /= f.
11:19:17 <dmj`> higherorder: just call cabal2nix . --ghcjs on your cabal file
11:19:26 <dmj`> higherorder: nix-env -iA cabal2nix -f '<nixpkgs>'
11:19:30 * hackage HDBC 2.4.0.3 - Haskell Database Connectivity  https://hackage.haskell.org/package/HDBC-2.4.0.3 (rsoeldner)
11:20:15 <dmj`> higherorder: then make a default.nix with '{ pkgs ? import <nixpkgs> {} }: pkgs.haskell.packages.ghcjs86.callCabal2nix "app" ./. {}
11:20:19 <dmj`> then call "nix-build"
11:20:29 <dmj`> you actually don't need cabal2nix if you use the above script
11:20:31 <dmj`> will do it for you
11:20:41 <japer> dmwit: umm yeah I see this
11:22:08 <dmj`> higherorder: although I would highly encourage you to use miso :P 
11:22:40 <exarkun> link to miso?
11:22:54 <tokopolopolo[m]> What's miso?
11:23:40 <tokopolopolo[m]> The only miso I've seen is in SPI
11:24:42 <tokopolopolo[m]> So a Haskell frontent
11:25:07 <dmj`> exarkun: haskell-miso.org
11:25:15 <dmj`> tokopolopolo[m]: it's a ghcjs framework
11:25:28 <dmj`> embedded DSL
11:25:51 <tokopolopolo[m]> I'm going through the Github page right now
11:26:47 <dmj`> sweet
11:28:28 <orzo> I'm really frustrated with cabal.  I have a project that is not rebuilding crap i need it to rebuild.  Explain how this happens: rm -rf dist-newstyle/; cabal v2-build; And then it says "Up to date"
11:28:30 * hackage HDBC-postgresql 2.3.2.7 - PostgreSQL driver for HDBC  https://hackage.haskell.org/package/HDBC-postgresql-2.3.2.7 (rsoeldner)
11:28:40 <orzo> without building anything
11:28:56 <merijn> orzo: It tracks whether your source files actually changed and only rebuilds if they have
11:29:16 <orzo> tracks it where?  I just blew away the build folder
11:29:34 <merijn> Wait, it still does that after you nuke dist-newstyle?
11:29:37 <orzo> yes
11:29:44 <exarkun> dmj`: thanks
11:29:58 <sclv> is it a project with multiple sub-projects?
11:29:59 <merijn> orzo: Is this within a project or stand alone cabal package?
11:30:16 <tokopolopolo[m]> Haven't done anything with Haskell nor web apps. It'll take some searching.
11:31:32 <orzo> it found a .project file in .. and was using another build folder.  This cost me hours.  I didn't see the issue until --verbose
11:31:40 <orzo> i'm now officially hateful toward cabal
11:31:44 <dmj`> exarkun: np
11:32:11 <sclv> i mean.. behavior seems reasonable to me
11:32:31 <sclv> the lesson here is when things get confusing... reach for --verbose early
11:33:30 * hackage newtype-zoo 1.2.0.0 - Newtype Wrapper Zoo  https://hackage.haskell.org/package/newtype-zoo-1.2.0.0 (SvenHeyll)
11:33:34 <sclv> also instead of manually munging dirs, v2-clean might do the right thing
11:33:35 <orzo> it's not even obvious from --verbose because it prints full paths and you have to read the whole thing to notice that a single path ellement is missing
11:33:54 <orzo> it looks mostly like the correct path
11:36:55 <orzo> why do we nee dit to hutning all over the disk for a .project file?
11:37:01 <orzo> that doesn't seem reasonable to me
11:37:18 <merijn> orzo: It just looks for the first project file up from the current directory
11:37:45 <merijn> orzo: Because else "cabal build" wouldn't work in multi-package repositories
11:38:30 * hackage th-test-utils 1.0.1 - Utility functions for testing Template Haskell code  https://hackage.haskell.org/package/th-test-utils-1.0.1 (leapyear)
11:38:56 <monochrom> Oh hey, is ghcup inspired by rustup?
11:39:28 <orzo> so my code works but is littered with debug prints all over the place that wren't neccessary
11:39:34 <orzo> cause cabal was making me think it was broken
11:40:12 <higherorder> dmj`: haha thanks but if I am not doing my frontend in Haskell I guess there is no point having miso as a dep?
11:40:30 <sclv> monochrom: yes
11:40:41 <monochrom> haha neat
11:40:50 <ski> EvanR : "because at that point it's ok to substitute for x or y" -- yeah, but then it's no longer a definition, can't be put inside `let'
11:41:07 <EvanR> sure
11:41:23 <dmj`> higherorder: that's true, but you should reconsider :)
11:43:11 <higherorder> dmj`: haha; small steps :)
11:43:49 <higherorder> dmj`: what does calling `cabal2nix . --ghcjs` before creating the default.nix do?
11:44:06 <dmj`> higherorder: you technically don't need that step anymore, since callCabal2nix will do it for you
11:44:18 <dmj`> this way you don't have to manually keep your cabal file and nix in synch
11:44:27 <higherorder> dmj`: ah; and `nix-env -iA cabal2nix -f '<nixpkgs>'`?
11:45:07 <dmj`> yea, you don't need to download manually anymore, it will be fetched for you
11:46:42 <higherorder> dmj`: nix has been installing the world for about 45min
11:46:55 <dmj`> higherorder: are you on osx
11:47:00 <higherorder> yes
11:47:14 <dmj`> higherorder: nixpkgs is cached better on linux
11:47:33 <higherorder> dmj`: ah
11:47:47 <dmj`> higherorder: miso has a cache via cachix, but you'd need to use my hash of nixpkgs to get it
11:47:59 <dmj`> if you install cachix, cachix use haskell-miso, then nix-build
11:48:14 <higherorder> dmj`: I'm currently running nix-build with the default.nix you give for Miso
11:48:33 <dmj`> higherorder: cool, just install cachix then
11:48:56 <iqubic> is the Miso framework worth learning?
11:49:11 <dmj`> iqubic: there's really not much to learn, you don't have to think at all, that's why its great
11:49:22 <dmj`> iqubic: thinking is very expensive
11:49:39 <higherorder> dmj`: install cachix then re-run nix-build?
11:49:45 <dmj`> higherorder: yup
11:49:52 <dmj`> higherorder: and do "cachix use haskell-miso"
11:49:58 <iqubic> How hard is it get started with Miso? I'm running Nixos, so it might be quite easy.
11:50:11 <dmj`> iqubic: it's a seamless experience imo
11:50:38 <iqubic> How could I go about getting a simple demo program running?
11:50:58 <dmj`> iqubic: https://github.com/dmjio/miso/blob/master/README.md#nix
11:52:13 <higherorder> dmj`: so from what I gather Miso has a story for client-server interactions as well? (data loading and mutations)
11:52:52 <dmj`> higherorder: yea, it can use servant-client-ghcjs for AJAX, websockets and server-sent events (SSE)
11:56:36 <iqubic> dmj`: Is there a way to add cabal-install to the build inputs pulled in by the default.nix?
11:56:57 <iqubic> I don't want to have cabal-install pollute my global namespace.
11:56:58 <dmj`> iqubic: you can put that in your shell.nix, or install it globally
11:57:26 <iqubic> I thought the default.nix was used to launch the shell.
11:57:29 <dmj`> iqubic: what I like to do is write a bash function in my shell.nix that builds the project for me, then I can just do nix-shell --run build
11:57:53 <iqubic> I see.
11:57:55 <dmj`> iqubic: by default nix-shell looks for nix-shell
11:58:00 <dmj`> nix-shell looks for shell.nix *
11:59:13 <iqubic> I see. So what does the default.nix do here?
12:00:28 <dmj`> iqubic: it builds the project
12:00:56 <dmj`> iqubic: on most haskell projects there is a .env attribute that should be used with nix-shell, so (import ./default.nix).env is usually the contents of shell.nix
12:01:05 <dmj`> (import ./default.nix {}).env
12:02:39 <koz_> @pl \x -> x >>= f
12:02:39 <lambdabot> (f =<<)
12:04:33 <iqubic> dmj`: Right. I want that in my nix-shell, as well as cabal-install.
12:05:28 <dmj`> iqubic: echo '(import ./default.nix {}).env' >> shell.nix
12:05:36 <dmj`> iqubic: nix-env -iA cabal-install -f '<nixpkgs>'
12:06:21 <iqubic> dmj`: I only want cabal-install to usable when I'm in my nix-shell.
12:08:31 <dmj`> { pkgs ? import <nixpkgs> {} }: (import ./default.nix {}).env.overrideAttrs (drv: { shellHook = ''export PATH=$PATH:/${pkgs.cabal-install}/bin"; })
12:09:55 <dmj`> higherorder: did it work
12:10:10 <higherorder> dmj`: it's still going...
12:10:34 <higherorder> dmj`: I have a pretty recent machine as well and I'm on fiber 
12:10:34 <dmj`> higherorder: can you paste your default.nix into a gist, it should be using the cache
12:10:54 <dmj`> higherorder: It will have to build 8GB worth of dependencies
12:11:10 <dmj`> including multiple versions of ghc (bootstrap  compilers) and ghcjs
12:11:17 <higherorder> dmj`: https://gist.github.com/hmaurer/1060435968269c7848bf66d5081d1716
12:11:29 <higherorder> dmj`: how do you work with nix if you don't have a 2TB harddrive then? :D
12:11:31 <dmj`> higherorder: did you call cachix use haskell-miso
12:11:37 <higherorder> yes I did
12:12:28 <dmj`> higherorder: oh you know what, I had domenkozar[m] clear the cache, we're working on bringing it back up, I did something stupid. The build will pass if you wait, I can ping you when its ready
12:12:50 <higherorder> dmj`: ah! haha. Ok, I'll just wait; I'm not in much of a hurry
12:12:58 <dmj`> higherorder: sounds good
12:13:09 <higherorder> dmj`: in how many weeks will the build be done, you think?
12:13:17 <dmj`> 3-4
12:13:20 <dmj`> ;)
12:13:22 <higherorder> perfect
12:13:36 <dmj`> shouldn't take longer than 5 hours I think
12:13:42 <dmj`> but once you do it, you're good
12:13:50 <tasrev[m]> Hi
12:14:01 <higherorder> dmj`: 5 hours?! jesus christ
12:14:06 <iqubic> dmj`: what's going to take 3-4 weeks/
12:14:36 <dmj`> higherorder: yea, I mean, you can call "time" on nix-build :) and see
12:14:48 <dmj`> if its your first time its a doozie
12:14:53 <higherorder> dmj`: how do I do that while it's building?
12:14:56 <higherorder> in a new shell?
12:15:00 <iqubic> What are we building here?
12:15:04 <dmj`> but good things come to those who wait
12:15:32 <dmj`> higherorder: if you've started, you'd have to cancel the build first, and if you're compiling ghc already you don't want to do that, or you'll have to restart the whole thing
12:15:38 <higherorder> dmj`: oh you meant `time nix-build`
12:15:39 <higherorder> neermind
12:15:43 <higherorder> I'll just leave it running
12:15:45 <ski> EvanR : i'd say there's an implicit "quantifier", of the locally defined variables, in a `let'
12:16:08 <higherorder> iqubic: I am building a Miso hello world app (GHCJS) for the first time with Nix
12:16:21 <higherorder> iqubic: it's taking about 50,000years to download & compile all dependencies
12:16:23 <iqubic> Why does it take forever?
12:16:27 <EvanR> ski: to account for like let (x,y) = (y,x) in x
12:16:38 <dmj`> iqubic: my cache is down, that's why
12:16:43 <higherorder> iqubic: apparently it downloads a lot of dependencies (multiple versions of GHC, etc) and has to build them all
12:16:55 <iqubic> dmj`: do you own Miso?
12:16:59 <higherorder> dmj`: how long would it take with the cache up? 
12:17:05 <dmj`> higherorder:  2 seconds
12:17:06 <dmj`> :P
12:17:09 <higherorder> ::(
12:17:26 <dmj`> higherorder: wait, I might be able to help you out
12:17:28 <dmj`> give me one sec
12:17:29 <higherorder> aren't tehre other caches available that contain most of those dependencies?
12:17:33 <higherorder> why do I have to use your cache?
12:18:12 <dmj`> yea I can make a new cache and push to it real quick
12:18:23 <iqubic> How long is the cache going to take to be rebuilt?
12:19:04 <higherorder> dmj`: wohoo
12:19:07 <higherorder> dmj`: thank you
12:22:42 <dmj`> iqubic: shouldn't  need to be rebuilt, I just need to push the binaries from my mac book pro to the new cache
12:23:02 <koz_> Is Either () not an Alternative?
12:23:21 <cal[m]> shapr: some hopefully haha. a friend of mine is taking an entry compsci class, and i am helping him with some of the projects; so i think i'll try to do those projects myself in haskell today. what about you? are you working on anything in particular today? 
12:23:45 <dmj`> > Left () <|> Left ()
12:23:47 <lambdabot>  error:
12:23:47 <lambdabot>      • No instance for (Control.Monad.Trans.Error.Error ())
12:23:47 <lambdabot>          arising from a use of ‘<|>’
12:24:13 <koz_> dmj`: This is the _exact_ error I'm hitting, hence my question.
12:24:49 <higherorder> dmj`: I hope you are on a good internet connection :)
12:26:42 <higherorder> koz_: https://stackoverflow.com/questions/44472008/why-is-there-no-alternative-instance-for-either-but-a-semigroup-that-behaves-sim maybe?
12:26:53 <dmj`> higherorder: cachix use miso-haskell
12:26:56 <dmj`> higherorder: try that one
12:27:55 <koz_> higherorder: Yeah, I get why _Either_ can't be Alternative. But surely something like (Monoid e) => Alternative (Either e) is fine?
12:28:04 <koz_> And () is a totally valid (if utterly boring) Monoid.
12:28:29 <higherorder> dmj`: aaand the build finished
12:28:41 <higherorder> dmj`: I am getting `    Could not find module ‘Miso’` though, weirdly; I'll check if I forgot any steps
12:29:30 <dmj`> higherorder: you can remove the import Miso line if you're not using it
12:29:39 <dmj`> if miso isn't in your cabal file
12:29:59 <dmj`> iqubic: you should do what higherorder did with the cache
12:30:31 <higherorder> dmj`: I am using it; for now I just followed your instructions and copied the example code
12:30:38 <MarcelineVQ> koz_: they exist elsewhere https://hackage.haskell.org/package/either-5.0.1.1/docs/Data-Either-Validation.html https://hackage.haskell.org/package/validation-1.1/docs/Data-Validation.html
12:30:54 <higherorder> dmj`: oh shit, I did remove miso from the cabal file
12:31:00 * hackage aeson-pretty 0.8.8 - JSON pretty-printing library and command-line tool.  https://hackage.haskell.org/package/aeson-pretty-0.8.8 (FalkoPeters)
12:31:07 <koz_> MarcelineVQ: Thanks, that's exactly what I needed!
12:32:34 <dmj`> higherorder: glad its working now :) 
12:33:25 <higherorder> dmj`: this cache is awesome. isn't there some sort of public cache for a wide variety of haskell packages? 
12:33:44 <dmj`> higherorder: cache.nixos.org, but it doesn't cache that much for Darwin
12:34:48 <higherorder> dmj`: ah, and there is no Darwin-specific cache of this kind?
12:35:01 <higherorder> (and so I assume if I was running NixOS everything would be super fast since everythign would be cached?)
12:35:42 <iqubic> only after the first build.
12:37:44 <ski> EvanR : hm ?
12:37:50 <ski> EvanR : that's cyclic
12:39:20 <koz_> @pl \x -> (x, next x)
12:39:20 <lambdabot> ap (,) next
12:39:35 <koz_> ap is just <*> right?
12:39:50 <MarcelineVQ> for lawful instances ye
12:41:40 <sh0t> Hello guys, what are the standard libraries to sample from distributions which are not uniform, say, Poisson or Laplace?
12:44:33 <sh0t> im looking into Statistics.Distribution
12:53:06 <EvanR> ski: to account for defining equations of forms other than x = ...
12:54:28 <EvanR> . ("an implicit quantifier of some sort would be necessary " ++)
12:54:33 <ski> yes
12:57:26 <EvanR> which means now I'm using de bruijn indexes to implement letrec
13:02:22 <EvanR> w 1 page left in my notebook heh
13:05:06 <pikajude> is there an equivalent of qReport from TH that allows you to specify the location you want to use?
13:05:39 <pikajude> i'm writing a quasiquoter for printf and i'd like to report errors at the site of the actual format specifier (like gcc/clang do) vs just at the beginning of the splice
13:11:23 <nil> damn, de Bruijn indices are brilliant
13:12:21 <EvanR> debruinjas. damn.
13:14:57 <pikajude> i looked at the source for Q but it just like
13:15:00 <pikajude> i don't even understand what it's doing
13:15:16 <pikajude> newtype Q a = Q { unQ :: forall m. Quasi m => m a } ??
13:15:32 <pikajude> anyway i'm gonna guess this is impossible
13:22:46 <c_wraith> Q doesn't do anything by itself. all it does is relay your operations to another instance of Quasi
13:24:27 <c_wraith> and eventually that means IO 
13:26:00 * hackage retry 0.8.0.2 - Retry combinators for monadic actions that may fail  https://hackage.haskell.org/package/retry-0.8.0.2 (MichaelXavier)
13:38:00 * hackage pusher-http-haskell 1.5.1.11 - Haskell client library for the Pusher HTTP API  https://hackage.haskell.org/package/pusher-http-haskell-1.5.1.11 (willsewell)
13:39:25 <dsal> megaparsec question.  How can I parse   "a=b c=d something" and get [(a,b),(c,d)]  ?    I want to sepBy space, but only while I'm getting things.  I guess I can just use some... but is there a way to do this with something like sepBy?
13:40:27 <LarryTheCow> Hello everyone. I have a quick question. Does ghcup support raspberry pi?
13:44:54 <Cale> dsal: sepBy already should get you as many as it can
13:45:03 <dsal> Yeah, I think I'm doing something else dumb.
13:52:06 <dsal> dooooh.   I decided # was a comment character.
13:54:03 * ski . o O ( "deBrujas" )
13:54:59 <pikajude> c_wraith: yeah, but then all the methods for Quasi IO just use `error`
13:55:04 <pikajude> so i guess it's compiler magic again
13:55:08 <EvanR> what's with all deBrujaja
13:55:21 <MarcelineVQ> dsal: be sure you don't meant space1, space could accept "a=bc=d"
13:56:33 <dsal> sepBy doesn't seem to do what I want.  some ((try props) <* sc)    does
13:56:58 <dsal> sepBy fails at the next thing when it doesn't find a =
13:57:32 <dsal> is `L.space space1 empty empty` the same as `space1` ?
13:59:14 <MarcelineVQ> it seems equivalent
13:59:59 <MarcelineVQ> Is this at all helpful?: parseTest ((sepBy (liftA2 (,) letterChar (char '=' *> letterChar)) space1) :: Parsec Void String [(Char, Char)]) "a=b c=d"
14:02:37 <dsal> Yeah, thanks.  It's not exactly what my stuff is, but it gives me ideas.  :)
14:02:47 <dsal> I'm doing a few things in a dumb way that could probably be done better, but they're happening.
14:04:01 <dsal> In particular, I do this kind of thing a lot:      Waiting . pack <$> ("WAITING " *> between "(" ")" (some $ noneOf [')']))
14:04:10 <dsal> That feels dumb.  I want to find characters between parens.
14:06:30 * hackage json-tokens 0.1.0.0 - Tokenize JSON  https://hackage.haskell.org/package/json-tokens-0.1.0.0 (andrewthad)
14:10:13 <nshepperd2> sh0t: random-fu has sampling code for a lot of common distributions
14:14:49 <MarcelineVQ> dsal: hmm, this requires further consideration, such a thing would accept multiple ( which might not be what you want
14:17:10 <MarcelineVQ> That is to ask, what are some example input/outputs for your Waiting parser?
14:21:07 <dsal> Just simple stuff like     (some text)
14:26:40 <MarcelineVQ> and if you have ((((some te)) as input what Waiting would you want to create?
14:27:20 <dsal> Yeah...  I guess that's an error.  For this case, it's safe to assume the parens are balanced and the inner stuff doesn't have anything.
14:27:47 <MarcelineVQ> safe to assume are scary words hehe
14:27:57 <dsal> heh
14:28:06 <dsal> The thing that's really eluding me right now is how to parse indented stuff.
14:28:13 <dsal> The above is just a little ugly.
14:28:19 <MarcelineVQ> But hey, whatever works for you, just want to check you're considering the forms things might take
14:28:43 <dsal> But the stuff I'm parsing is "a\n b\n  c\n  d"  (where b is indented a little and c and d are even, but a little below)
14:28:58 <MarcelineVQ> There should an an indented tutorial around as Lexer has indentation support
14:29:12 <dsal> Doing cookie-cutter indentation where I try to start parsing at b, it tells me the indentation level is unexpected.
14:29:45 <MarcelineVQ> this one https://markkarpov.com/megaparsec/indentation-sensitive-parsing.html
14:30:04 <dsal> Yeah, I think I used that to get a basic thing done.  I'm doing a little fancier stuff now.
14:30:24 <dsal> Oh, this mentions the thing I just found.  Maybe I should read it with my current problem instead of my old one.
14:33:22 <dsal> Heh.  That's gross, but it works.
14:50:24 <dmj`> if I use timeout on a thread performing network IO, is it possible for a space leak to occur
14:59:25 <masaeedu[m]> japer: that's not actually what i was looking for. there's cofree comonad, i'm looking for a comonad for free
14:59:54 <shachaf> What does "for free" mean?
15:00:37 <dmj`> shachaf: depends who you ask
15:01:02 <MarcelineVQ> I'm guess he's asking masaeedu[m] :3
15:01:32 <dmj`> :P
15:02:25 <shachaf> It sounds like they don't mean "left adjoint" here.
15:08:13 <jle`> it looks like they mean for capital-F Free
15:08:21 <jle`> instance Comonad f => Comonad (Free f)
15:08:34 <jle`> (based on scrollback)
15:09:22 <rocket_man> is there a way to rebind a variable in a `let` expression? I don't need to use the old value of the variable: https://repl.it/repls/VerticalShoddyTranslation
15:12:22 <jle`> rocket_man: let bindings are recursive
15:12:47 <jle`> so (n = n + 1), the LHS 'n' would refer to the n you are defining
15:13:10 <jle`> so if we rename the variables to be more clear, you are writing `f n = let m = m + 1 in m * 2
15:13:46 <jle`> within the body of a definition, the name of the thing you are defining is in scope
15:13:52 <jle`> in this case it shadows any outside bindings
15:14:13 <rocket_man> so I need to name them different things? :/
15:14:24 <rocket_man>  `f n = let m = n + 1 in m * 2`
15:14:36 <EvanR> shadowing = not naming them different things (even though they are different)
15:14:44 <jle`> it depends on what you mean by 'need'; the two things are different things
15:14:54 <jle`> m is different than n
15:15:15 <jle`> so it would be confusing if you gave them the same name
15:15:17 <glguy> rocket_man: Yes, you pick different names. Shadowing is generally discouraged even when you don't want to use the outer name when defining the new thing
15:15:23 <masaeedu[m]> shachaf: it means i want to implement `instance Comonad f => Comonad (Free f)`
15:15:24 <jle`> if you gave n the same name as n + 1, that gets confusing fast
15:15:36 * masaeedu[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/qpkUenDXkmXYioauSpeLvWuG >
15:15:40 <shachaf> masaeedu[m]: What is "Free"?
15:15:42 <rocket_man> right, in my original code it made more sense because they were interchangable but one was more efficient
15:15:44 <EvanR> let n' = n+1 in... is possible
15:15:56 <rocket_man> ^ n' would work, I'll do that
15:16:03 <jle`> alternatively if you never want to name 'n' in the first place, you can use -XViewPatterns, `f ((+1)->m) = m * 2`
15:16:16 <masaeedu[m]> are you asking some kind of metaphysical question about the nature of freedom here?
15:16:28 <masaeedu[m]> Free as in the type Free
15:16:28 <jle`> masaeedu[m]: presumably we are asking about what package Free is from
15:16:36 <jle`> "Free as in the type Free" doesn't help, heh
15:16:43 <jle`> because there are a lot of types called Free
15:16:44 <masaeedu[m]> ```
15:16:44 <masaeedu[m]> data Free = Pure a | Done f (Free f a)
15:16:45 <masaeedu[m]> ```
15:17:07 <shachaf> I gues you mean "Done (f (Free f a))", as in the free monad on a functor?
15:17:14 <masaeedu[m]> *`data Free f a = ...`
15:17:15 <shachaf> ("Done" is an odd name for that.)
15:17:16 <jle`> masaeedu[m]: ah yeah, that definition of Free is definitely not very standard
15:17:22 <jle`> so good thing we asked :)
15:17:24 <masaeedu[m]> yes
15:17:46 <masaeedu[m]> it's in the one in the `free` package
15:17:49 <shachaf> Anyway maybe that's a comonad sometimes, but I doubt it's a very interesting one.
15:18:16 <jle`> rocket_man: yeah, the fundamental thing here is that it doesn't really make sense to give two different things the same name
15:18:27 <jle`> rocket_man: so it makes sense to give them different names
15:18:37 <masaeedu[m]> it's pretty interesting to me
15:18:56 <jle`> rocket_man: that's kind of like, why 3.141.. and 2.17... are given different names, normally pi and e
15:19:03 <jle`> rocket_man: it would be confusing if we called them both pi
15:19:30 <rocket_man> they're not different things though ... I'm calculating C(n, r) and that's exactly the same as C(n, n-r), so I want to call r `min r (n-r)`
15:19:51 <jle`> well, n is different than n + 1
15:20:36 <jle`> at least in the code snippet you gave
15:21:31 * hackage mmsyn2 0.1.4.0 - The library that can be used for multiple (Ord a) => a -> b transformations  https://hackage.haskell.org/package/mmsyn2-0.1.4.0 (OleksandrZhabenko)
15:22:16 <rocket_man> maybe code will explain better than words lol: https://repl.it/repls/DevotedMonstrousStartup
15:22:18 <masaeedu[m]> at any rate, the question is whether it is a comonad
15:23:24 * masaeedu[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/qUeUnpgiMenRNFHXzwlBVnEu >
15:23:33 <masaeedu[m]> which have an obvious comonad
15:23:49 <jle`> rocket_man: ah yeah. so r is not going to always be the same as min r (n - r), which i think would cause a lot of confusion
15:24:09 <jle`> oh actually in this case, is it always the same?
15:24:20 <rocket_man> yeah maybe not the best practice, I was just surprised it looped forever 
15:24:28 <rocket_man> in this particular case, but in general no
15:24:33 <jle`> yeah, the looping forever happens because bindings are recursive
15:24:49 <jle`> that's the only way really to make it behave in a non-confusing way in general
15:25:04 <rocket_man> what other cases does that help with?
15:25:14 <EvanR> x = x + 1, the only solution is infinity!
15:25:17 <jle`> rocket_man: it means you don't have to think abotu what else is in scope
15:25:31 <jle`> for example if i write `fib n = fib (n - 1) + fib (n - 2)`
15:25:36 <jle`> (with the fib 0/ fib 1 case)
15:25:41 <jle`> rocket_man: now...what does each 'fib' refer to?
15:25:46 <shachaf> masaeedu[m]: I think you'll just confuse people saying this is "for free" unles you have a specific meaning for that phrase.
15:25:47 * masaeedu[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/QpJnJFniQMtRcvzfHBQKROSb >
15:25:48 <jle`> does it refer to the definition it is being defined in?
15:26:00 <jle`> rocket_man: if it was non-recursive...then the meaning of that function would change based on any other fibs in scope
15:26:15 <masaeedu[m]> it's not "for free", it's "(the instance for) Free"
15:26:16 <rocket_man> ahh that makes more sense, it's the same in let bindings as in global scope
15:26:23 <masaeedu[m]> Free-as-in-thetype
15:26:38 <masaeedu[m]>  * Free-as-in-the-type
15:26:39 <jle`> rocket_man: so if let bindings were non-recursive, then the 'thing' you are binding to would change depending on what else is in scope
15:26:41 <rocket_man> so you could use let to define a named temporary function
15:26:42 <jle`> rocket_man: which is really confusing
15:26:49 <shachaf> Ah, I just saw the phrase "a comonad for free" above.
15:27:02 <EvanR> rocket_man: other languages distinguish between let and letrec, recursive or non-recursive. Haskell has no non-recursive version
15:27:18 <shachaf> In that case it's confusing to call this type Free unqualified, then. It's clear in the context Control.Monad.Free.
15:27:25 <nshepperd2> comonads for free, get em' while they're hot
15:27:41 <jle`> rocket_man: if i wrote a simple function like `fac 0 = 1; fac n = n * fac (n - 1)`, then it's assumed that the 'fac' in the LHS of the second line refers to the function you are defining
15:27:51 <jle`> rocket_man: otherwise like...it could change its meaning magically depending on what else is in scope
15:27:55 <nshepperd2> masaeedu[m]: that instance seems plausible. maybe you should try proving the laws
15:28:06 <jle`> rocket_man: that's why a binding like `let n = n + 1`, it is assumed that the 'n' in the LHS refers to the n you are defining
15:28:07 <rocket_man> gotcha, the use case is something like this: `let f n = n in f 3`
15:28:14 <jle`> rocket_man: otherwise the meaning of it would change depending on what else is in scope
15:29:04 <masaeedu[m]> i wish i knew how :)
15:29:10 <masaeedu[m]> i'm going to try quickchecking it though
15:29:48 <jle`> masaeedu[m]: do you know the laws?
15:32:28 <jle`> rocket_man: it looks like you were expecting to have the semantics of let-non-rec, like from languages like ocaml.  in those languages, you have different lets where the 'n' on the LHS *always* refers to the n outside of the scope no matter what
15:32:59 <jle`> er, i mean, that the n in the definition doesn't get included in the scope
15:33:08 <rocket_man> right
15:33:16 <jle`> i suppose unforunately haskell doesn't have that option
15:33:25 <jle`> i wonder why
15:33:46 <jle`> maybe just for a simpler language?
15:34:17 <rocket_man> > haskell
15:34:19 <lambdabot>  error: Variable not in scope: haskell
15:34:19 <EvanR> you don't lose much ime
15:34:19 <rocket_man> > simple
15:34:22 <lambdabot>  error:
15:34:22 <lambdabot>      • No instance for (Typeable a0)
15:34:22 <lambdabot>          arising from a use of ‘show_M4659491549515319050728’
15:34:27 <masaeedu[m]> i do know the laws
15:34:41 <masaeedu[m]> i don't know the general principle of proving things
15:34:42 <jle`> heh. well, it makes it at least definitely more simple than the alternative
15:34:46 <masaeedu[m]> except to just randomly fart around
15:35:17 <jle`> if know how to do that at least, then you know enough
15:35:35 <masaeedu[m]> i'd have to somehow derive the comonad laws for `Free f` from the comonad laws for `f`
15:36:03 <masaeedu[m]> but i don't know a way of doing this systematically/mechanically
15:36:14 <jle`> there isn't
15:36:17 <jle`> you just have to fart around :)
15:36:57 <jle`> just lay out the laws and try to think of their logical consequences
15:37:10 <jle`> it might help to develop your intuition by proving it for specific comonads
15:37:52 <jle`> like say `(,) w`
15:38:28 <jle`> * like say `(,) Int`
15:44:45 <nshepperd2> Normally i write out the laws and try to symbolically evaluates both sides of the equation until they become equal
15:48:32 * masaeedu[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/jlbmCEjwYyUbWlNmQtdoHJaG >
15:50:14 <masaeedu[m]> well actually i started out by reifying `f` to `(->) Int`. and at least pictorially it seems that the laws would hold for those nested spaces. so then i handwaved and reasoned that in so far as any other comonad is similar to a pointed space, the laws would hold for it too
15:50:54 <pikajude> Are there infix versions of shiftL and shiftR?
15:51:31 <shachaf> Only `shiftL` and `shiftR`
15:51:38 <pikajude> hmm
15:53:22 <jle`> masaeedu[m]: it might be easier to look at an instance with values you can pattern match on
15:53:27 <jle`> like (,) Int
15:53:42 <jle`> so you can feed it a concrete matchable value and then get one back
16:06:32 <rocket_man> anyone know what this parses as? it nearly crashed my computer by eating memory, so clearly it's not `gcd d (n `mod` d)`: `gcd n d = gcd d n `mod` d`
16:06:54 <rocket_man> I tried -ddump-parsed but it didn't add any parentheses lol
16:07:49 <hpc> (gcd d n) `mod` d
16:08:06 <hpc> you probably want gcd d (n `mod` d)
16:08:20 <rocket_man> ^ that did it, thanks
16:16:48 <rocket_man> how do you normally document functions? with -- or {- -}?
16:18:37 <hpc> take a look at what kind of comments you should use with haddock
16:18:43 <hpc> generally -- | blahblah
16:19:07 <hpc> (or -- ^ blahblah for comments below identifiers)
16:26:49 <juliagoda_> ##c++
16:27:38 <EvanR> --c##
16:28:06 <juliagoda_> sorry, my mistake :P
16:28:52 <EvanR> #-c-#
16:33:11 <cobreadmonster> does anyone have experience with RPC in Haskell?
16:33:36 <cobreadmonster> I'm not even sure that RPC is a concept that's meaningful with Haskell, but I can't think of other ways of doing distributed systems.
16:37:48 <EvanR> there's cloud haskell
16:38:25 <cobreadmonster> EvanR: hmm, okay
16:38:46 <cobreadmonster> I've been having difficulties wrapping my head around those libraries.
16:38:50 <cobreadmonster> but I should spend more time with the code.
16:52:20 <EvanR> so... peano nats right. For doing arithmetic machine int is faster. But machine int can't be lazy. Is there a way to accelerate lazy Nat with machine ints?
16:52:51 <rocket_man> is there a way to annotate the type of a function declared with `let`? https://repl.it/repls/ConstantDoubleAfkgaming
16:53:14 <rocket_man> I want to have a semi-complicated function that's only visible within the scope of another function
16:53:24 <EvanR> yes
16:53:37 <EvanR> let f :: A -> B; f x = y in ...
16:54:00 <glguy> rocket_man: Do the changes show up if you refresh that?
16:54:24 <rocket_man> glguy: when you edit it it makes a copy, sort of like haskell :P
16:54:40 <glguy> https://repl.it/repls/FrailOrchidAnalysis
16:54:51 <rocket_man> EvanR: that works great, thanks!
16:55:00 * hackage dirtree 0.1.1 - A small library for working with directories.  https://hackage.haskell.org/package/dirtree-0.1.1 (kalhauge)
16:56:38 <rocket_man> ah and that helped me find my bug, 1.0 is a Real, not a Rational
16:57:22 <dmwit> 1.0 is a fine Rational
16:57:25 <dmwit> > 1.0 :: Rational
16:57:27 <lambdabot>  1 % 1
16:57:29 <rocket_man> wait no ignore me let me debug some more lol
16:57:36 <glguy> Real is a typeclass and Rational is an instance of it
16:58:08 <dmwit> :t 1.0
16:58:09 <lambdabot> Fractional p => p
16:58:10 <glguy> > (id :: Real a => a -> a) (1.0 :: Rational)
16:58:10 <nshepperd2> That's really rational
16:58:12 <lambdabot>  1 % 1
17:00:19 <EvanR> the annoyingly named Data.Ratio is offset by the relative unpopularity of rationals
17:01:11 <rocket_man> as usual, I was missing parentheses
17:01:30 <rocket_man> I had `fromIntegral factorial n` instead of `fromIntegral (factorial n)`
17:01:45 <rocket_man> haskell was complaining that you can't turn a function into a number
17:02:58 <EvanR> didn't Godel famously do that
17:03:04 <EvanR> or was that Turing
17:03:18 <rocket_man> Church, right? Church numerals?
17:03:39 <EvanR> church numerals are the turning of numbers into functions
17:04:30 <EvanR> you can also encode any lambda term as a number (but the proof of this is too small for this msg)
17:05:11 <EvanR> too bi
17:05:19 * EvanR leaves
17:05:58 <rocket_man> you mean that in a way different than the obvious 'the code lives somewhere in memory', right?
17:07:27 <EvanR> that's a funny way to prove it
17:07:42 <rocket_man> lol
17:08:02 <rocket_man> hey is there a way to perform lossy numeric conversions? I want to turn 1.5 into an `Int`
17:08:23 <EvanR> floor, ceiling, truncate, round...
17:08:41 <rocket_man> thanks
17:09:33 <iqubic> What's the difference between floor and truncate.
17:09:34 <iqubic> ??
17:09:40 <EvanR> negatives
17:10:08 <iqubic> Ah.
17:10:37 <EvanR> > round 0.5
17:10:39 <lambdabot>  0
17:10:42 <EvanR> > round 1.5
17:10:45 <lambdabot>  2
17:11:06 <EvanR> i'm not sure if the rounding mode is configurable but that's the default it seems
17:11:30 <rocket_man> I finally fixed all the compile errors to find that my function gives completely the wrong answer lol
17:11:41 <iqubic> Want some help?
17:11:53 <rocket_man> not sure how readable my code is, but sure
17:11:54 <EvanR> rocket_man: not correct by construction eh
17:12:25 <boxscape> % :t Proxy :: Proxy 'Proxy
17:12:25 <yahb> boxscape: forall k (t :: k). Proxy 'Proxy
17:12:38 <boxscape> kinda weird that there's a forall for variables that don't even appear anywhere
17:12:59 <iqubic> % :kind Proxy
17:12:59 <yahb> iqubic: Proxy :: k -> *
17:13:09 <iqubic> That's where the k comes from.
17:13:26 <rocket_man> iqubic: https://repl.it/repls/GroundedWetPhysics
17:13:32 <boxscape> yeah, but it just feels a little odd that :t shows it
17:13:40 <boxscape> it's clearly not actually necessarily to explicitly give it
17:13:45 <boxscape> since it didn't complain about my type signature
17:13:46 <EvanR> i think the type sig is only showing some stuff there
17:14:17 <rocket_man> I have the working algorithm in python if that helps at all
17:14:22 <EvanR> implicit application of t
17:14:59 <iqubic> We don't know what the other argument is to the 'Proxy part is. So we need a forall.
17:15:21 <boxscape> how is it possible that we need the forall if ghci doesn't complain about the type signature in "Proxy :: Proxy 'Proxy"
17:15:34 <EvanR> you don't need it
17:16:03 <EvanR> polykinds sometimes has the effect of showing extra details
17:16:08 <boxscape> I see
17:16:32 <EvanR> but you should know all variables are implicitly quantified with a forall
17:16:41 <boxscape> yeah, I'm aware
17:16:42 <EvanR> unless explicitly quantified some other way
17:17:23 <iqubic> What other quantifiers exist in Haskell?
17:17:57 <EvanR> Rank2 forall :)
17:18:43 <rocket_man> does haskell have arbitrary precision rationals by default? or IEEE float/double precision?
17:19:01 <EvanR> Rational is a ratio of two integers
17:19:01 <boxscape> Richard Eisenbergs foreach proposal also calls -> and => quantifiers
17:19:18 <EvanR> Float and Double are ieee
17:19:38 <nshepperd2> boxscape: i think the full type there is secretly forall k (t :: k). Proxy ('Proxy :: Proxy t)
17:19:49 <boxscape> ah, I see
17:20:25 <nshepperd2> but :t doesn't print the type sig on the 'Proxy, for whatever reason
17:22:07 <boxscape> % :t Proxy :: forall k (t :: k). Proxy ('Proxy :: Proxy t)
17:22:07 <yahb> boxscape: forall k (t :: k). Proxy 'Proxy
17:24:43 <EvanR> > (1 % 3) :: Ratio Double
17:24:45 <lambdabot>  error:
17:24:45 <lambdabot>      • No instance for (Integral Double) arising from a use of ‘%’
17:24:45 <lambdabot>      • In the expression: (1 % 3) :: Ratio Double
17:24:56 <EvanR> aw man
17:25:44 <rocket_man> so after about 10 minutes I have a much simpler function that gives the same wrong answer xD
17:30:09 <rocket_man> I had an off-by-one error
17:30:35 <rocket_man> in case anyone's curious: https://repl.it/repls/GroundedWetPhysics
17:32:31 <EvanR> is the python code using rationals
17:33:17 <rocket_man> whatever the float class is in python, I think IEEE doubles?
17:33:47 <EvanR> interesting
17:34:50 <EvanR> if you wanted the haskell version to get the same answer, then I'd assume you want doubles then
17:35:24 <rocket_man> well ideally it shouldn't make a difference because it should always be an integer
17:35:34 <EvanR> reeeeallly now
17:35:36 <rocket_man> both crash on large numbers though: https://pastebin.com/LHugTd3P
17:36:23 <rocket_man> yeah, derangements count the number of possible functions from a set to itself with some limitations, you can't have a fractional number of functions
17:36:54 <EvanR> i'm curious why any fractional things are involved at all
17:37:33 <rocket_man> I can send a picture of my Discrete notes if you're really interested lol
17:37:52 <EvanR> i suspect you could do this using Integer math
17:38:56 <rocket_man> wikipedia has a pretty good summary actually: https://en.wikipedia.org/wiki/Derangement#Counting_derangements
17:40:33 <rocket_man> I guess I could do sum n!/i! instead of n! * sum 1/i!
17:41:56 <EvanR> my interpretation of the python code https://paste.ofcode.org/iLe7QNNesCnBu3ffLvgVk2
17:42:05 <EvanR> no idea if it runs 
17:43:30 <rocket_man> remarkably, it ran as soon as I added a main function lol
17:43:53 <EvanR> i wouldn't tried ghci first
17:43:56 <EvanR> woulda*
17:44:01 <rocket_man> ghci doesn't like indentation
17:44:20 <EvanR> it shouldn't crash on large numbers with the second version
17:44:34 <EvanR> though it may be slow as *
17:49:19 <rocket_man> the first one works great on 10000
17:49:22 <rocket_man> the second is still running
17:49:39 <EvanR> does the second one work at all
17:49:46 <rocket_man> why is the second so much slower? the only difference I see is you changed `/` to `div`
17:50:09 <rocket_man> oh wait no it doesn't wokr
17:50:30 <rocket_man> it outputs -14515200 for 10, it should output 1334961
17:50:43 <EvanR> maybe an operator precedence issue
17:50:53 <rocket_man> no it's because you took the floor during the loop
17:51:02 <EvanR> eh?
17:51:17 <rocket_man> that inner loop is going to be less than 1 whenever i != 1
17:51:22 <rocket_man> so you're adding 0 over and over
17:51:39 <EvanR> so you really do need fractional numbers
17:51:58 <rocket_man> yeah, or to divide n! by i! factorial within the loop so it's always an integer
17:52:27 <rocket_man> but that ends up doing a lot more computation I think
17:52:31 <EvanR> that definitely would be the way of the integers
17:52:43 <EvanR> always stay an integer
17:53:22 <EvanR> btw when you're running a sum over something with factorials, you can save a lot of work by not recomputing the whole factorial each time
17:53:40 <EvanR> times a "factorial accumulator" by the i you're on
17:53:53 <rocket_man> yeah this is just a toy program, I'd memoize it in real code
17:54:07 <rocket_man> oh that's nice too
17:54:33 <EvanR> exponentiation to flip a sign is not great either
17:55:01 <EvanR> just negate the "sign accumulator" each step
17:55:55 <EvanR> in fact instead of a sign factor... do a branch that just uses the term as is or uses the negative of it
17:56:14 <EvanR> you could switch between branches using mutual recursion
18:01:10 <rocket_man> you don't even need mutual recursion, make it a branch of the guard clause
18:01:53 <EvanR> sure, but if the decision to negate or not is baked into two procedures, no test would be done
18:02:04 <EvanR> that's probably minor compared to the other issues
18:12:30 * hackage jvm-binary 0.8.0 - A library for reading Java class-files  https://hackage.haskell.org/package/jvm-binary-0.8.0 (kalhauge)
18:30:30 * hackage perceptual-hash 0.1.3.1 - Find duplicate images  https://hackage.haskell.org/package/perceptual-hash-0.1.3.1 (vmchale)
18:45:14 <rocket_man> hmm if I change the factorial to use an accumulator I can't calculate `factorial n` up front, I have to switch back to fractions
18:46:41 <rocket_man> honestly since haskell has arbitrary precision fractions I don't mind that much
18:47:00 * hackage perceptual-hash 0.1.3.2 - Find duplicate images  https://hackage.haskell.org/package/perceptual-hash-0.1.3.2 (vmchale)
18:49:55 <EvanR> rocket_man: fact n used at the end is just fact (i-1)
18:50:15 <rocket_man> right, but it's used at the end, to use it in the loop it has to be calculated eagerly
18:50:24 <rocket_man> and if it's not in the loop I have to use fractions
18:50:39 <EvanR> oh you're trying to use integers only
18:51:29 <rocket_man> well I was and I decided I'm ok not doing that lol
18:51:38 <EvanR> it wouldn't be interesting if you can beat Integer using Rational 
18:51:47 <EvanR> ... it WOULD be interesting
18:52:09 <EvanR> if your algorithm using rationals comes out faster
18:54:54 <jollygood2> asdf
18:57:44 <enikar> if n > p, then fact n / fact p = product [n..p+1], no ?
18:58:32 <EvanR> n > p, [n..p+1] ought to be []
18:58:55 <iqubic> That's right actually.
18:58:59 <rocket_man> sure, but the loop starts at 1 so you still have to calculate `product [n..1]`
18:59:02 <enikar> oh! Yes.
18:59:19 <rocket_man> *starts at 0
18:59:31 <enikar> so, use product [p+1..n] :)
18:59:46 <rocket_man> ? how does that help?
19:00:07 <EvanR> faster than fact n / fact p
19:00:12 <enikar> fact n = product [2..n]
19:01:17 <EvanR> > product [2..1]
19:01:19 <lambdabot>  1
19:01:26 <EvanR> > product [2..0]
19:01:28 <lambdabot>  1
19:01:32 <EvanR> whatta
19:01:39 <EvanR> sneaky
19:01:46 <rocket_man> that looks reasonable actually, because you're giving it an empty list
19:01:56 <rocket_man> so `foldl (*) 1 [] = 1`
19:02:16 <EvanR> also make sure it's compiling to foldl'
19:02:31 <EvanR> or use foldl' in your own fact function
19:02:34 <rocket_man> look I'd be happy if my code compiled lol
19:02:58 <rocket_man> any idea which of these types is wrong? https://pastebin.com/JgrycSK7
19:03:21 <rocket_man> `fact_acc'` has type `Int`
19:03:45 <EvanR> well, that can't be right
19:03:59 <EvanR> why are you using Int
19:04:11 <rocket_man> because factorials are always integers
19:04:25 <enikar> without the code, it's difficult to say.
19:04:32 <EvanR> :t \n -> product [1..n]
19:04:34 <lambdabot> (Num a, Enum a) => a -> a
19:04:45 <EvanR> uses whatever has a multiplication op
19:05:29 <EvanR> you gotta make up your mind which numbers you are using
19:05:32 <rocket_man> code: https://repl.it/repls/HalfRobustAdware
19:05:45 <EvanR> waiting for repl.it to load again :)
19:05:45 <enikar> anyway, (-1)^^ n = 1 when n `mod` 2 == 0, and (-1) ^^ n = -1 when n  `mod` 2 == 1
19:06:00 <jollygood2> fact will overflow Int pretty fast 
19:06:03 <jollygood2> :t fromIntegral
19:06:05 <lambdabot> (Integral a, Num b) => a -> b
19:06:18 <rocket_man> oh `Int` isn't arbitrary precision
19:06:19 <rocket_man> ?
19:06:29 <EvanR> > maxBound :: Int
19:06:31 <lambdabot>  9223372036854775807
19:06:39 <EvanR> (it's machine dependent)
19:06:49 <jollygood2> Integer has arbitrary precision
19:06:53 <rocket_man> would never have caught that, thanks
19:07:22 <EvanR> another thing
19:07:58 <EvanR> the python code used a loop, the code i posted is basically a direction translation using recursion. But really, you can probably compute this using a sum over a (lazy) list
19:07:58 <iqubic> is there a function of type "Int -> Integer"?
19:08:13 <iqubic> Oh, right... It's just fromIntegral.
19:08:15 <EvanR> direct translation*
19:08:26 <iqubic> :t fromIntegral
19:08:28 <lambdabot> (Integral a, Num b) => a -> b
19:08:32 <iqubic> Yeh.
19:08:37 <enikar> :t (^^)
19:08:38 <lambdabot> (Fractional a, Integral b) => a -> b -> a
19:11:33 <rocket_man> gahhh the problem was that fact_acc was an integer and you need a float for float division
19:12:22 <EvanR> or you need a rational for rational division
19:13:03 <rocket_man> ^ right, I keep forgetting there's another type between integers and floats
19:14:01 <EvanR> it's more of a numeric type salad bowl than a numeric tower of types
19:14:55 <rocket_man> well I finally got it working using a factorial accumulator, it's running on big numbers now
19:15:05 <EvanR> nice
19:15:19 <EvanR> using rationals?
19:15:24 <rocket_man> (by running I don't mean working, I mean it's currently running with no sign of stopping)
19:15:29 <rocket_man> with rationals, yeah
19:16:08 <rocket_man> https://repl.it/repls/HalfRobustAdware
19:16:10 <hoxtrop[m]> Aren't floats just rationals in paractice?
19:16:13 <EvanR> every time you do a Rational operation, it takes the liberty of normalizing the numerator and denomenator, which involves an LCM
19:16:15 <hoxtrop[m]> *practice
19:16:27 <rocket_man> the numerator should always be 1 though
19:16:37 <rocket_man> so the LCM should be really cheap
19:17:03 <EvanR> aren't you adding 1/large number to an accumulator?
19:17:07 <rocket_man> right
19:17:29 <suzu> hoxtrop[m] | Aren't floats just rationals in paractice? 
19:17:30 <rocket_man> oh I see what you're saying, it has to find LCM(a, b) for 1/a + 1/b
19:17:31 <EvanR> numerator can't always be 1, our CPU doesnt have eyptian fraction support
19:17:34 <suzu> sqrt(2) isn't
19:17:38 <hoxtrop[m]> How do I ge started with Haskell?
19:17:41 <enikar> usualy, it's a bad idea to use float to finally round the result to an integer. The result is unpredictable, because floats are not real numbers.
19:17:54 <suzu> hoxtrop[m]: start by installing the tools on your computer
19:18:23 <EvanR> yeah you use floats as if they were reals, rather than rationals
19:18:25 <EvanR> > sqrt 2
19:18:27 <lambdabot>  1.4142135623730951
19:18:44 <rocket_man> I know I keep saying floats, but I really mean rationals lol
19:18:45 <EvanR> and they aren't even proper rationals
19:19:32 <EvanR> > (1/3)*3
19:19:34 <lambdabot>  1.0
19:19:39 <EvanR> ignore that
19:19:57 <suzu> > 1/3
19:19:59 <lambdabot>  0.3333333333333333
19:20:05 <hoxtrop[m]> I did install GHC. I can't seem to be able to program functionally.
19:20:07 <suzu> > let x = 1/3 in x * 3
19:20:10 <lambdabot>  1.0
19:20:12 <suzu> hm
19:20:36 <EvanR> i think it does add up to exactly 1 in this case
19:20:38 <rocket_man> :t /
19:20:39 <lambdabot> error: parse error on input ‘/’
19:20:43 <rocket_man> :t (/)
19:20:44 <lambdabot> Fractional a => a -> a -> a
19:20:47 <suzu> > let x = 1/7 in x * 7
19:20:49 <lambdabot>  1.0
19:20:58 <suzu> > let x = 1/71 in x * 71
19:21:01 <lambdabot>  1.0
19:21:07 <suzu> i have a feeling something is being optimized here
19:21:12 <rocket_man> it's still running lol
19:21:14 <EvanR> > sum (replicate 7 (1/7))
19:21:16 <lambdabot>  0.9999999999999998
19:21:31 <suzu> ah yes there we go
19:22:35 <EvanR> floats act like integers (with a scale) over certain ranges, so it can be tricky to observe actual errors. Not to mention the rendering strategy displays "closest base 10" numbers 
19:23:01 <enikar> hoxtrop[m]: you can start with: http://learnyouahaskell.com/chapters
19:23:07 <EvanR> > decodeFloat (1/3)
19:23:10 <lambdabot>  (6004799503160661,-54)
19:23:18 <EvanR> > decodeFloat (3 * (1/3))
19:23:20 <lambdabot>  (4503599627370496,-52)
19:23:30 <EvanR> > decodeFloat 1.0
19:23:32 <lambdabot>  (4503599627370496,-52)
19:24:18 <hoxtrop[m]> > hoxtrop: you can start with: http://learnyouahaskell.com/chapters
19:24:19 <hoxtrop[m]> Thanks. The page looks cool.
19:24:20 <lambdabot>  error: Variable not in scope: hoxtroperror:
19:24:21 <lambdabot>      Variable not in scope: you :: t0 -> t1 -> t2 -> a0error:
19:24:21 <lambdabot>      • Variable not in scope: can
19:25:34 <EvanR> > encodeFloat 4503599627370495 (-52)
19:25:36 <lambdabot>  0.9999999999999998
19:25:43 <EvanR> > encodeFloat 4503599627370497 (-52)
19:25:45 <lambdabot>  1.0000000000000002
19:25:49 <enikar> hoxtrop[m]: it's a good introduction to haskell.
19:26:11 <EvanR> k the rendering thing may not be a thing
19:26:12 <ysangkok> here is a simple one:
19:26:14 <ysangkok> > 0.1 + 0.2
19:26:16 <lambdabot>  0.30000000000000004
19:26:47 <rocket_man> replaced (-1)^i with a conditional, I feel like I'm making progress lol
19:26:58 <EvanR> thank god
19:29:46 <hoxtrop[m]> And just for the record, I'm what was Tokopolopolo yesterday. That's my community ranking account.
19:31:13 <iqubic> dmj`: did you update the cache yet?
19:33:35 <rocket_man> not sure if this is worth optimizing more tbh: https://repl.it/repls/HalfRobustAdware
19:34:34 <EvanR> not reloading that page but until you open up the core output you can probably make it faster :)
19:34:38 <dmj`> iqubic: yes
19:34:47 <dmj`> iqubic: on linux or darwin?
19:34:54 <iqubic> NixOS.
19:34:56 <dmj`> iqubic: if darwin, cachix use miso-haskell && nix-build
19:34:59 <dmj`> iqubic: one second
19:35:06 <iqubic> Do I need to change my default.nix?
19:35:14 <rocket_man> here's a pastebin if that's easier: https://pastebin.com/7EyAg52a
19:35:43 <rocket_man> what do you mean by > open up the core output ?
19:36:05 <EvanR> there's a flag to dump simplified core
19:36:15 <EvanR> the underlying representation before being compiled
19:36:34 <EvanR> then you add -O2 and stare in awe... then try to improve it
19:36:44 <dmj`> iqubic: no
19:36:56 <rocket_man> lmao I forgot to add -O2 brb
19:37:03 <dmj`> iqubic: just call cachix use miso-haskell
19:37:12 <dmj`> I'm pushing right now
19:37:35 <iqubic> Do I have to launch a nix-shell first with 'nix-shell -A env'?
19:38:13 <iqubic> Also, what directory do I want to be in to run this?
19:38:13 <rocket_man> huh, it made basically no difference
19:38:36 <EvanR> for rationals, not surprising
19:38:48 <EvanR> but there may be something big you missed prevent optimizations
19:38:58 <enikar> rocket_man: I propose this: http://ix.io/1Xcz/haskell
19:39:41 <enikar> at least, it compiles, but the result may be false.
19:40:06 <EvanR> enikar i had the suggestion to alternate signs using mutual recursion, to avoid a check there
19:40:16 <iqubic> dmj`: Can you help me?
19:40:22 <EvanR> but only after you improve the big stuff
19:40:40 <rocket_man> `derangements 10` should be 1334961, that's my goto test
19:40:40 <dmj`> iqubic: if you don't have a shell.nix yes
19:40:41 <enikar> EvanR: it's a good idea.
19:41:08 <dmj`> iqubic: join the haskell-miso slack, lots of people there can answer anything, including me, this way we don't spam #haskell
19:41:49 <iqubic> dmj`: I don't have a slack account.
19:42:04 <EvanR> i cuter way is to apply a function from this zipped list: cycle [id, negate]
19:42:13 <EvanR> also, you should rewrite this whole thing to sum over a list :)
19:42:19 <dmj`> iqubic: you can make one, https://haskell-miso-slack.herokuapp.com
19:42:38 <rocket_man> not sure what you mean by sum over a list, wouldn't the list be generated by a function too?
19:42:52 <EvanR> lists are like the loops of haskell
19:43:14 <EvanR> they are generated (or optimized away) on the fly
19:43:23 <dmj`> iqubic: I'd just copy the example code
19:43:28 <dmj`> iqubic: it works well
19:44:04 <enikar> rocket_man: that doesn't work, as I expected…
19:44:07 <EvanR> rocket_man: you're basically summing terms, perhaps doing a final fixup on the sum. So if you had a (lazy) list of the terms, you just use sum
19:44:39 <EvanR> the list itself can be generated from (lazy) list operations
19:45:22 <EvanR> > sum (map (\i -> 1/i) [1..100])
19:45:25 <lambdabot>  5.187377517639621
19:45:47 <enikar> list is the good way for doing this work, i think
19:46:00 <iqubic> dmj`: I just joined the slack, and asked a question in #general.
19:46:30 <rocket_man> ah I see I'll try that
19:46:33 <EvanR> a straight up mapping of the formula to i won't let you exploit the redundancy of factorial(i), but you can generate a list of factorials lazily that does
19:47:17 <EvanR> > scanl (*) 1 [1..10]
19:47:19 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800]
19:48:01 <iqubic> What is that?
19:48:16 <iqubic> Oh I see. It's n! for 0-9 inclusive.
19:48:24 <enikar> rocket_man: anyway, in your code there is an issue;  in the first loop. i == 0, then facto_acc' == 0, and we cannot divide by zero.
19:48:27 <EvanR> it's just the log of iterating (*)
19:48:53 <iqubic> Yes. But the list generated is the same as factorial.
19:49:01 <rocket_man> I updating it locally, I may have forgot to change it on pastebin - it should read `derangementsN 1 1 1 n` 
19:49:08 <iqubic> @let fact n = product [1..n]
19:49:10 <lambdabot>  Defined.
19:49:29 <iqubic> > scanl (*) 1 [1..10] == map fact [0..9]
19:49:31 <EvanR> it gives the factorials but doesn't recompute it for each i
19:49:32 <lambdabot>  False
19:50:04 <iqubic> Right. And my fact function fails to account for fact 0.
19:50:33 <enikar> >scanl (*) 1 [1..10] == map fact [0..10]
19:50:53 <enikar> > scanl (*) 1 [1..10] == map fact [0..10]
19:50:56 <lambdabot>  True
19:51:02 <iqubic> Oh. I see.
19:51:11 <iqubic> > [1..0]
19:51:13 <lambdabot>  []
19:51:22 <iqubic> Wait?!?!
19:51:29 <iqubic> > product []
19:51:31 <lambdabot>  1
19:51:34 <EvanR> > take 10 (scanl (*) 1 [1..]) == take 10 (map fact [0..9])
19:51:37 <lambdabot>  True
19:51:40 <EvanR> > take 10 (scanl (*) 1 [1..]) == take 10 (map fact [0..])
19:51:42 <lambdabot>  True
19:51:45 <EvanR> to infinity and beyond
19:51:51 <iqubic> Oh, that makes sense.
19:52:12 <iqubic> product [] == 1 That's just the multiplicative identity.
19:52:25 <EvanR> @src product
19:52:25 <lambdabot> product = foldl (*) 1
19:53:38 <iqubic> I figured it was something like that once I saw what was happening with [].
19:54:23 <enikar> well, I need some rest, see you later ;)
19:54:27 <iqubic> compiling the entirety of lens is eating up my ram super fast.
19:54:57 <EvanR> no one ever gained anything from unutilized ram
19:57:33 <iqubic> Oh. I'm also building ghcjs.
20:02:17 <jollygood2> I'm still using 8.0.2. what are the greatest new features that I'm missing out?
20:05:08 <rocket_man> I made a prototype using lists, haven't tested it for large numbers but it works for small ones: https://pastebin.com/31wnAC7r
20:05:50 <EvanR> so you mapped the formula over i
20:05:54 <rocket_man> it's actually a lot slower, I think because I'm calculating the factorial every time. Going to try using `scanl` like you suggested
20:06:12 <rocket_man> yes exactly
20:06:17 <EvanR> the two parts to each term are an alternating +1 and -1, and the factorial
20:06:26 <EvanR> > cycle [1,-1]
20:06:28 <lambdabot>  [1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,...
20:07:10 <laudecay> wait
20:07:11 <dmwit> There's no way Rational is the fast way to do this.
20:07:14 <laudecay> > [1..]
20:07:16 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
20:07:17 <EvanR> yeah
20:07:19 <laudecay> i forgot about lambdabot
20:07:21 <dmwit> Why are you not using just `div` or whatever?
20:07:23 <laudecay> my long-lost friend
20:07:33 <rocket_man> can't use div inside the loop, you always get 0
20:07:47 <EvanR> you probably want to exploit the cancelled factors of the factorials in each term
20:08:04 <EvanR> dmwit means multiply in the n!
20:08:13 <dmwit> dmwit does mean that
20:09:00 <EvanR> add a bunch of 1/n is pretty fun though
20:09:14 <dmwit> It's not bad. The gcd is n!
20:09:30 <dmwit> Sorry, I mean the lcm is n!.
20:10:28 <dmwit> So scanl (*) n [n-1, n-2..1] gets you the numerators (modulo sign).
20:10:37 <rocket_man> something like this: https://pastebin.com/uWRN5e8d
20:12:32 <rocket_man> and you're suggesting something like this for factorial? `factorial n = (scanl (*) n [n-1, n-2..1]) !! n`
20:13:18 <rocket_man> (should be `!! (n-1)`)
20:13:37 <daredevil08> hi everyone
20:13:49 <EvanR> !! n is bad
20:14:02 <daredevil08> do everybody know how i can download pc games?
20:14:16 <EvanR> that would be using a list literally backwards
20:14:17 <laudecay> > !! n
20:14:19 <lambdabot>  <hint>:1:1: error: parse error on input ‘!!’
20:14:21 <laudecay> lmao
20:14:25 <laudecay> he angery
20:14:38 <iqubic> daredevil08: This it really not the right place to ask about that.
20:14:57 <EvanR> don't download games, write games in haskell
20:14:57 <daredevil08> where place i can ask that question?
20:15:14 <iqubic> This is a Haskell chatroom on the Freenode IRC network.
20:15:44 <dmwit> rocket_man: I'm suggesting something like this: https://gist.github.com/dmwit/a899b1cda8901bc7afe3a51e20dcee8b
20:16:04 <dmwit> rocket_man: If you just want the list of derangement numbers, it can probably be improved from there.
20:16:11 <daredevil08> git clone?
20:16:44 <dmwit> daredevil08: This also isn't the right place to ask where you can ask.
20:16:52 <iqubic> daredevil08: you seem to a be a troll.
20:17:08 <EvanR> now now
20:17:14 <iqubic> Yes?!
20:17:20 <daredevil08> yes i know...but please help me
20:17:24 <dmwit> No.
20:17:42 <daredevil08> that my question..where channel i can find my solution?
20:17:46 <daredevil08> urgent
20:17:50 <daredevil08> a.s.a.p
20:17:50 --- mode: ChanServ set +o dmwit
20:18:03 --- mode: dmwit set +b *!*u0_a298@115.164.52.*
20:18:03 --- kick: daredevil08 was kicked by dmwit (Your emergency is not our emergency.)
20:18:11 --- mode: dmwit set -o dmwit
20:18:28 <iqubic> dmwit: Thank you for that.
20:19:01 <EvanR> they really should have had a point, writing games in haskell
20:20:05 <dmwit> Hm. Maybe there *isn't* an obvious way to improve that if you just want the list of derangement numbers.
20:21:01 <dmwit> EvanR: I am open to suggestions if you have any. ^_^
20:21:10 <Orfos> hi
20:21:20 <Orfos> what is the channel for downloads
20:21:34 <EvanR> honestly the earlier discussion about law-abiding time shift operators seems to have the most relevance
20:21:36 <rocket_man> holy cow that's at least 100x times speed up from my other code lol
20:21:51 <rocket_man> now I just have to understand it xD
20:22:12 <EvanR> another day when Rational gets beaten by Integer :(
20:22:42 <rocket_man> to be fair, my old code was not very good
20:23:08 <EvanR> to be honest i can't believe the python code worked
20:23:14 <EvanR> using doubles
20:23:47 <rocket_man> well it only worked on small numbers 
20:24:09 <rocket_man> originally I was just using this to compute numbers < 100, but then you sort of challenged me to make it fast and I figured why not
20:24:38 <EvanR> yes live up to your IRC nick for pete's sake
20:27:09 <dmwit> rocket_man: So the formula on Wikipedia is sum_i=0^n (-1)^i/i!, right?
20:27:23 <rocket_man> all that times n!
20:27:31 * dmwit nods
20:27:48 <dmwit> rocket_man: To add up fractions, the stuff they taught us in grade school was figure out a shared denominator, convert them all to that, then add the numerators.
20:28:24 <dmwit> rocket_man: Well, i! divides n! for all the i's we're looking at, so n! is a fine shared denominator.
20:28:49 <dmwit> rocket_man: Try to work out what the numerators are in that case. And then just cancel the n! factor out front and the n! denominator. ;-)
20:29:35 <dmwit> (I don't know why they don't write the formula that way -- as a simple sum, with no fractions/divisions -- on wikipedia.)
20:30:04 <rocket_man> it's because of the way the formula is derived I think
20:31:00 <dmwit> Oh, hey, that recurrence just below looks very amenable to cooking up in infinite list form.
20:31:23 <EvanR> stuff factorial divided by other stuff factorial always crops up, it's simpler than talking about "factorials missing stuff"
20:31:58 <dmwit> Maybe. Not faster to compute, though.
20:32:21 <rocket_man> of course, the fast way to do this is just `round (factorial n / e)`
20:32:52 <dmwit> That probably isn't as fast as you think, if you write the code in the way you need to to make sure you actually get the right answer.
20:34:55 <rocket_man> hmm, because e needs to have lots of precision, yeah
20:34:56 <monochrom> consider sum_i=0^n  n!/(n-1)!
20:35:39 <rocket_man> that's the same as n^n, right?
20:35:57 <EvanR> e, really
20:36:08 <dmwit> > scanl (\a (b,c) -> a*b+c) 1 . zip [1..] $ cycle [-1,1]
20:36:11 <lambdabot>  [1,0,1,2,9,44,265,1854,14833,133496,1334961,14684570,176214841,2290792932,32...
20:36:44 <EvanR> another thing, correct rounding of real numbers is undecidable
20:36:50 <dmwit> monochrom: Yes, that one has an especially efficient algorithm. =)
20:37:02 <EvanR> i.e. table makers dilemma
20:37:09 <dmwit> EvanR: e does not sit in the part of the real numbers that makes rounding hard.
20:37:21 <EvanR> oh right, you're dividing integers
20:37:31 <EvanR> carry on with your bad self
20:37:33 <rocket_man> EvanR: e = sum_i=0^infinity 1/i!
20:37:52 <EvanR> i support the round(n! / e) plan
20:38:12 <dmwit> rocket_man: See my scanl above if what you really want is the list of derangements. It'll be faster still than my gist for that (though probably slower if you want a specific derangement number).
20:38:42 <dmwit> > round (product [1..10000] / exp 1 :: CReal) :: Integer
20:38:48 <lambdabot>  mueval-core: Time limit exceeded
20:38:53 <dmwit> > round (product [1..100] / exp 1 :: CReal) :: Integer
20:38:55 <lambdabot>  3433279598416380476519597752677614203236578380537578498354340028268518079332...
20:39:36 <rocket_man> I'm not sure how your last scanl works
20:39:55 <rocket_man> did you cancel the telescoping sums? I haven't worked through it yet
20:40:26 <dmwit> I just copied the recurrence on the Wikipedia page verbatim. The first 14 terms match, so I think it works.
20:40:43 <EvanR> > round ((product [1..10] / exp 1) :: CReal) 
20:40:45 <lambdabot>  1334961
20:40:49 <EvanR> is this right
20:41:00 * rocket_man nods
20:41:04 <dmwit> Yes, you can see that term in the scanl above. ^_^
20:41:05 <EvanR> also... wth
20:41:45 <EvanR> does it choose an arbitrary precision
20:42:03 <dmwit> No, it chooses unitary precision in the call to round.
20:42:14 <EvanR> oh, cute
20:42:26 <EvanR> let me break it
20:42:30 <dmwit> Until the call to round, it is a function from precision to answer.
20:42:39 <dmwit> Well, it offers Eq, so it's easy to break.
20:42:44 <EvanR> > round (1/3 + 1/3 + 1/3 :: CReal)
20:42:46 <lambdabot>  1
20:42:47 <dmwit> The Eq instance uses 10^-50 precision. ^_^
20:43:04 <monochrom> Last time I heard it was 40 rather than 50.
20:43:13 <EvanR> > round ((sqrt 2)**2 :: CReal)
20:43:14 <dmwit> Okay, I believe you.
20:43:15 <lambdabot>  2
20:43:35 <dmwit> EvanR: You won't get anywhere with round, it's too favorable. If you want to hit edge cases, you want to try both floor and ceiling.
20:43:36 <EvanR> is it just bullshitting or
20:43:37 <monochrom> It's hearsay and unreliable memory anyway.
20:43:41 <dmwit> (Spoilers: they both work correctly.)
20:43:45 <dmwit> No, it is not bullshitting.
20:44:03 <dmwit> I'm not even sure what bullshit you have in mind that would work so well.
20:44:05 <monochrom> It trades speed for accuracy.
20:44:28 <monochrom> And yeah it uses functions not simple numbers.
20:44:34 <EvanR> choosing an arbitrary precision that happens to give the right answer in the examples i picked
20:44:45 <monochrom> If necessary you can think of it as laziness.
20:45:07 <monochrom> Um you do "round" at the end so it knows how much to compute.
20:45:12 <EvanR> > round ((sqrt 2.5)**2.5 :: CReal)
20:45:15 <lambdabot>  3
20:45:21 <EvanR> > round ((sqrt 1.5)**1.5 :: CReal)
20:45:24 <lambdabot>  1
20:45:25 <dmwit> uh
20:45:30 <dmwit> surely you want (sqrt 1.5)**2
20:45:35 <dmwit> and (sqrt 2.5)**2
20:45:38 <EvanR> > round ((sqrt 2.5)**2 :: CReal)
20:45:41 <lambdabot>  2
20:45:44 <EvanR> > round ((sqrt 1.5)**2 :: CReal)
20:45:47 <lambdabot>  2
20:45:52 <dmwit> Banker's rounding.
20:45:58 <EvanR> i demand to see who is behind the curtain
20:46:00 <monochrom> Really, any direct observation is going to involve rounding.
20:46:11 <EvanR> yes, but rounding is a discontinuous function on reals
20:46:13 <monochrom> You can read the source code.
20:46:18 <EvanR> i've read it
20:46:29 <monochrom> OK, then problem solved.
20:46:34 <EvanR> i think i just need to come up with a better input
20:46:39 * dmwit too
20:47:26 <EvanR> sqrt(2.5)**2 lands exactly where a discontinuity happens
20:47:33 <monochrom> One single discontinuous rounding is not chaotic enough.
20:48:18 <dmwit> > all (\n -> round (n :: CReal) == round (sqrt n**2)) [-10.5,-9.5..10.5]
20:48:24 <lambdabot>  mueval-core: Time limit exceeded
20:48:40 <EvanR> equality... ?
20:48:47 <EvanR> no one thought that would work
20:48:48 <dmwit> Equality on Integer, though.
20:48:53 <EvanR> ah
20:49:19 <EvanR> you took sqrt of a negative?
20:49:20 <monochrom> > length ([-10.5,-9.5..10.5] :: [CReal])
20:49:22 <lambdabot>  22
20:49:49 <rocket_man> > sqrt (-1)
20:49:51 <lambdabot>  NaN
20:50:08 <dmwit> Yes, it's true, I'm an idiot.
20:50:34 <dmwit> > all (\n -> round (n :: CReal) == round (sqrt n**2)) [0.5..10.5]
20:50:35 <rocket_man> says the guy who just sped up my program by about 1000x 
20:50:36 <lambdabot>  True
20:50:48 <pikajude> mmm, cereal
20:50:55 <EvanR> and also can split the continuum
20:51:09 <dmwit> all in a day's work
20:51:27 <monochrom> Perhaps you need to try (x**(1/n))**n
20:51:55 <monochrom> I have a feeling that squarerooting and squaring are too easy.
20:52:00 <shachaf> CReal has round? How does it work? Does it use a fixed precision or something?
20:52:08 <EvanR> that is what i was asking
20:52:58 <EvanR> it has to do a "close enough" thingie
20:53:23 <EvanR> that magically does bankers rounding right (??)
20:54:44 <monochrom> Or perhaps don't use 2, use a complicated formula that should compute to 2.
20:54:47 <dmwit> > round (1.5 + 10**(-51) :: CReal)
20:54:49 <lambdabot>  2
20:55:17 <dmwit> > round (1.5 - 10**(-50) :: CReal)
20:55:20 <lambdabot>  2
20:55:22 <dmwit> ^_^
20:55:47 <shachaf> > 0 < 0
20:55:49 <dmwit> Turns out you can learn a lot if you actually read the code instead of just claiming you read the code.
20:55:49 <lambdabot>  False
20:55:49 <shachaf> Uh.
20:55:55 <shachaf> > 0 < (0 :: CReal)
20:55:58 <lambdabot>  False
20:56:08 <shachaf> > 0 < (10**(-51) :: CReal)
20:56:10 <lambdabot>  False
20:56:29 <EvanR> Ord does use a finite tolerance interval
20:56:40 <dmwit> Yes. And round uses Ord.
20:56:45 <EvanR> ah
20:56:53 <shachaf> Some `r̀eal numberś´ these are.
20:57:14 <dmwit> I can't believe you've done this.
20:57:16 <EvanR> arbitrary precision, cool
20:57:19 <Welkin> no more cold soup
20:57:30 <shachaf> It's kind of a hack how the Ord and Eq instances use a fixed precision.
20:57:45 <rocket_man> is there something like python's `f(*my_tuple)` for haskell?
20:57:54 <Welkin> f *your* tupled!
20:58:13 <shachaf> I think the best answer to that question is probably "no".
20:58:30 <dmwit> rocket_man: https://stackoverflow.com/q/6168880/791604
20:59:33 <monochrom> 2 = sqrt 2 * sqrt 2 = sin(pi/4) * cos(pi/4)  where pi/4 = 4 atan (1/5) - atan (1/239).  (Machin's formula)
20:59:42 <EvanR> yeah my programs need to freeze up on certain computations so i can construct a perfect circle by negation
20:59:46 <EvanR> semidecidably
21:00:41 <monochrom> > let {p4 = 4*atan(1/5) - atan(1/239); two = sin p4 * cos p4} in [ sqrt n ** two | n <- [1.5, 2.5] }
21:00:44 <lambdabot>  <hint>:1:98: error: parse error on input ‘}’
21:00:58 <monochrom> Oh haha
21:01:26 <Welkin> this place is full is sin and atan!
21:01:27 <monochrom> > let {p4 = 4*atan(1/5) - atan(1/239); two = sin p4 * cos p4} in [ round (sqrt n ** two :: CReal) | n <- [1.5, 2.5] ]
21:01:29 <lambdabot>  [1,1]
21:01:35 <monochrom> There
21:02:06 <EvanR> get these miserable round results out my sight
21:02:12 <monochrom> > let {p4 = 4*atan(1/5) - atan(1/239); two = sin p4 * cos p4} in [ (sqrt n ** two :: Double) | n <- [1.5, 2.5] ]
21:02:14 <lambdabot>  [1.1066819197003215,1.2574334296829355]
21:02:33 <monochrom> Hrm, maybe my code is wrong
21:03:17 <dmwit> I already showed a wrong rounding result that's much simpler, didn't I?
21:03:36 <monochrom> Oh haha 1/2 = sin p4 * cos p4.
21:03:43 <monochrom> Err which one?
21:03:54 <dmwit> > round (1.5 - 10**(-50) :: CReal)
21:03:57 <lambdabot>  2
21:04:07 <monochrom> Oh, that.
21:04:13 <EvanR> > 1.5 - 10**(-50) :: CReal
21:04:15 <lambdabot>  1.5
21:04:24 <EvanR> might as well use doubles!
21:04:35 <dmwit> > showCReal (1.5 - 10**(-50)) 100
21:04:37 <lambdabot>  error:
21:04:37 <lambdabot>      • No instance for (Fractional Int) arising from the literal ‘1.5’
21:04:37 <lambdabot>      • In the first argument of ‘(-)’, namely ‘1.5’
21:04:43 <dmwit> :t showCReal
21:04:45 <lambdabot> Int -> CReal -> String
21:04:48 <dmwit> Oops, got it backwards.
21:04:59 <dmwit> > drop 40 $ showCReal 100 (1.5 - 10**(-50))
21:05:01 <lambdabot>  "999999999999"
21:05:25 <EvanR> don't mince words
21:05:29 <EvanR> > showCReal 100 (1.5 - 10**(-50))
21:05:31 <lambdabot>  "1.49999999999999999999999999999999999999999999999999"
21:05:39 <monochrom> 3*(1/3) = 0.99999...999
21:06:10 <shachaf> That's accurate until the ...
21:06:23 <monochrom> It's a joke!
21:06:42 <daredevil90> @_@
21:06:58 <dmwit> Are there any computable irrationals which suffer from the tablemaker's dilemma?
21:07:49 <shachaf> What's the dilemma?
21:07:53 <monochrom> If you don't have repeating 9's do you have a tablemarker's dilemma?
21:08:26 <EvanR> yes, the dilemma is someone asked you to put the correctly rounded result in a table, but the value is exp(some pesky rational)
21:08:34 <monochrom> pi does have a long string of 9's somewhere if you go for an impatient-tablemaker's dilemma...
21:08:36 <shachaf> Hmm, I'm not sure I understand the question, but R\Q is totally disconnected, if that's the answer.
21:09:31 <dmwit> shachaf: The dilemma is: I may need to compute for an infinitely long time to be sure about whether the next digit I should print is a 0 or a 9.
21:09:39 <EvanR> for irrational values, you can show a correctly rounded result exists, but the question is how much precision do you need to compute it
21:09:51 <dmwit> shachaf: (Or whatever: a 7 or an 8.)
21:10:20 <EvanR> the amount of precision you need varies wildly as you scan across your rational input domain
21:10:23 <dmwit> I think under the assumption that my CReal is irrational, I may *always* know.
21:10:34 <dmwit> The trick is knowing whether my CReal is irrational or not, of course.
21:10:37 <shachaf> Yes, I think that's the same thing I said.
21:10:40 <EvanR> the dilemma is deriving that precision
21:10:43 <dmwit> shachaf: I think so, too.
21:10:51 <monochrom> And for an undecisive-tablemaker dilemma: what if you don't even know whether the number is rational or irrational? >:)
21:10:58 <shachaf> In particular you can represent all irrationals as infinite continued fractions.
21:11:06 <shachaf> And that representation is unique.
21:11:21 <EvanR> exp sin and cos of a rational are always irrational except for at x=0
21:12:00 <shachaf> It's funny that the space of rationals and the space of irrationals are topologically so similar, whereas the reals are pretty different.
21:12:11 <monochrom> err, indecisive!
21:12:42 <monochrom> "the whole is bigger than the disjoint union"
21:13:05 <shachaf> Wait, not the rationals, what am I saying?
21:13:13 <EvanR> dmwit: getting frozen is one thing, but the table maker has to round somewhere and go home. They need an analysis for each input to know how much precision to use. I don't think this is solved for all functions in ieee754
21:13:18 <shachaf> I was talking about the Cantor set and somehow I said the rationals.
21:13:34 <monochrom> I have one more: "the tensor product is bigger than the cartesian product" >:)
21:13:39 <shachaf> Lesson: Don't listen to shachaf.
21:13:55 <shachaf> Sometimes the tensor product is smaller than the caresian product.
21:14:43 <shachaf> Oh, man.
21:14:55 <shachaf> I'm still totally saying nonsense right now.
21:15:20 <monochrom> Did you have wine? :)
21:15:41 <shachaf> Yes, but I didn't drink it.
21:15:59 <dmwit> EvanR: I'm not sure if you're riffing on topics nearby my question or trying to answer my question. If the latter, I don't understand your answer.
21:17:05 <EvanR> the actual table maker's dilemma has to do with correctly rounding irrational results, not deciding if a value is above or below an integer (which could freeze)
21:17:17 <Welkin> it doesn't involve real tables?
21:17:32 <Welkin> the real dilemma should be, round or squared?
21:17:34 <Welkin> what type of wood?
21:17:48 <EvanR> there's a correct rounding, but a priori the amount of precision to use is unknown
21:18:08 <EvanR> and varies. It could be a lot of precision for certain problem inputs
21:18:54 <dmwit> EvanR: I think the actual table maker's dilemma has to do with correctly rounding arbitrary reals. I'm claiming that rounding irrationals is easier than rounding arbitrary reals.
21:19:08 <dmwit> (s/reals/computable reals/ if you prefer)
21:19:49 <EvanR> in the application to ieee754, they only need to worry about rational inputs to transcendental functions
21:19:51 <shachaf> If you quotient the Cantor set by the equivalence x111... = (x+1)000..., you get the reals. Right?
21:19:53 <monochrom> Wait, what is the definition of computable reals again?
21:19:58 <EvanR> and i don't think it's solved yet for all functions
21:20:10 <EvanR> these people are literally the table makers
21:21:30 <shachaf> I would say: If r is a real number, it's computable if a computable representation of it exists. A computable representation is a function that takes a rational precision and approximates r within that precision.
21:21:54 <dmwit> Okay. I asked the wrong question, because I had not recently reviewed the definition of the table-maker's dilemma. My apologies.
21:21:55 <shachaf> So f : Q -> Q such that |f(p) - r| < p
21:22:13 <shachaf> I should say it's a computable function, of course.
21:22:35 <shachaf> You can also define computable reals directly probably.
21:23:45 <EvanR> shachaf's definition of approximation requires a definition of subtraction on computable reasl
21:23:51 <EvanR> that is tricky
21:24:10 <mycroftiv> i spend way too much time arguing with myself about whether or not im capable of thinking about arbitrary real numbers. the problem is that even if my brain maximized the state space of its physical region by being a black hole, i still only have a finite # of brain states
21:24:11 <dmwit> monochrom: There's a bunch of different ways of defining it. One way is to say: a computable real is a function that takes as input a number n of digits and outputs a number that is within 10^-n of the True Answer.
21:24:58 <EvanR> you need a sort of notion of closeness that doesn't literally do real subtraction
21:24:59 <dmwit> monochrom: Oh, shachaf's version is more canonical but captures the same set.
21:25:08 <dmwit> I just hadn't noticed that he'd already written an answer.
21:25:25 <EvanR> i'm not sure if monochrom wanted a non-hand wavy answer :)
21:25:45 <shachaf> Note that dmwit's answer is a Cauchy sequence, which is closer to a standard construction of the reals.
21:26:14 <monochrom> Actually I don't see why |f(p) - r| is a subtraction of computable reals rather than a subtraction of reals.
21:26:23 <EvanR> because r is a real by assumption
21:26:26 <EvanR> a real real
21:26:31 <shachaf> But it's not just Cauchy, it's a "quickly-converging Cauchy sequence", i.e. you can get a required precision within a finite number of steps, which is very useful for computation.
21:26:34 <EvanR> oh  , well yes
21:26:38 <shachaf> monochrom: That's a subtraction of reals.
21:27:06 <dmwit> shachaf: Isn't my definition just feeding particular rationals into your definition?
21:27:14 <shachaf> dmwit: Sure, they're very similar.
21:27:19 <monochrom> Subtraction of reals is not tricky.
21:27:25 <shachaf> It's just that it's obviously a sequence whereas mine isn't.
21:27:35 <dmwit> Oh, sure.
21:27:48 <dmwit> Demanding that sequences be indexed by integers is scow anyhow.
21:27:51 <EvanR> if you're trying to define computable reals, i think you might want to be able to verify you have what you say you have
21:28:35 <shachaf> I think it's pretty good? Simple things are nice.
21:28:55 <shachaf> How would you do it the other way?
21:29:02 <monochrom> IMO only religiously zeolotly constructivists avoid starting with continuum real's substraction.
21:29:06 <dmwit> I'm only half serious.
21:29:22 <EvanR> i don't resemble that remark
21:29:23 <dmwit> But functions on ordered domains as generalized sequences seems p. sensible to me.
21:29:24 <shachaf> In particular what's nice is that you have the one-point compactification of the naturals.
21:29:42 <shachaf> Hmm, sure, but in this case you want the limit as p approaches 0, or something.
21:29:53 <dmwit> uh?
21:29:57 <shachaf> I guess that's still pretty easy to define.
21:30:22 <shachaf> Maybe not?
21:30:26 <dmwit> Oh, I see. My sequence and your sequence go in opposite directions. Bigger inputs are more precise for mine; smaller inputs are more precise for you.
21:30:29 <shachaf> I guess you just care about the ordering of the absolute values.
21:31:58 <EvanR> you don't need real reals to define computable reals any more than real reals needed a priori some even more real reals to be defined in the first place
21:32:27 <EvanR> for instance the real real cauchy sequences are defined in terms of their own convergence criteria
21:32:53 <EvanR> now all you need to have a computable version of cauchy is to say the sequence in question is computable
21:32:56 <shachaf> How would you define the computable reals directly, rather than as a special subset of the reals which you've already constructed?
21:33:10 <shachaf> You can probably just use the same mechanism with a different constraint.
21:33:14 <EvanR> right
21:33:44 <EvanR> and it turns out that if you do it all constructively, that the computable cauchy version is a subset of the computable dedekind version
21:33:57 <EvanR> neither need real reals to work 
21:34:40 <mycroftiv> subset? what are the 'extra' dedekind-computables like?
21:34:43 <rajivr___> I am new to Haksell. I was wondering what I am doing wrong in terms of writing the `Functor` instance for `Pair`? https://gist.github.com/rajivr/9dad45ea3effc3c2a56ec71f380b6560
21:34:56 <shachaf> What do you mean?
21:35:10 <EvanR> a subset in the sense that they are the same if you use LEM
21:35:13 <monochrom> Pair (f x) (f y)
21:35:33 <EvanR> the inclusion the other way doesn't go
21:35:47 <mycroftiv> interesting, thanks EvanR
21:35:58 <Welkin> rajivr___: first, you are using GADT syntax, which is weird for a newcomer, and second, you don't need parens around your instance line
21:36:34 <Welkin> `data Pair a = Pair a a`
21:36:43 <monochrom> I like Dedekind more. It generalizes to completing a lattice. :)
21:36:52 <MarcelineVQ> I'm a fan of GADT syntax
21:37:15 <MarcelineVQ> for people new and old
21:37:33 <Welkin> it is harder to read and understand
21:37:37 <shachaf> Hmm, instead of saying |f(p) - r| < p, can you just say something like forall p,q. p < q --> |f(p) - f(q)| < q ?
21:37:37 <Welkin> don't use it if you don't need it
21:37:39 <Welkin> it's noise
21:37:45 <shachaf> That doesn't seem right.
21:37:56 <nshepperd> would a computable dedekinde real be a program :: Rational -> Ordering which divides the rational numbers into smaller, larger and equal?
21:38:14 <monochrom> With normal ADT syntax my students don't understand "Pair :: a -> a -> Pair a a"
21:38:27 <rajivr___> Personally I found GADT syntax very helpful. So I tend to write both and use ghci to confirm my understanding.
21:38:29 <MarcelineVQ> looks clearer (read: more explicit) to me
21:38:51 <monochrom> I conclude that both are hard to understand.
21:39:30 <monochrom> I postulate that anyone who believe otherwise has never marked exams.
21:40:07 <nshepperd> understanding things is hard
21:40:08 <Welkin> communication is a bitch
21:40:11 <Welkin> too contextual
21:40:21 <Welkin> understanding is not hard
21:40:33 <Welkin> communicating is the part where people fail
21:40:49 <monochrom> What's the difference?
21:41:10 <Welkin> the information doesn't get through
21:41:22 <rajivr___> Infact I recently learned about `MultiParamTypeClasses` which pretty much allows me to develop right intuition between Rust (my primary development language) and Haskell.
21:41:26 <monochrom> Even if you don't talk to anyone and you're like figuring out Nature on your own, you are communicating with Nature.
21:41:52 <Welkin> both parties have a different model of how the world works, and that isn't communicated either, causes more miscommunication
21:42:29 <mycroftiv> i spoke to the trees, and the trees said "in a formal sense, each branch is actually a sub-tree", and I Understood
21:42:33 <EvanR> shachaf: something like that, for all eps,delta > 0  |f(eps) - f(delta)| < eps+delta
21:42:40 <rajivr___> monochrom:  Thanks again! :-) I really appreciate the help that I am getting here.
21:43:34 <sm[m]> mycroftiv++
21:44:01 <iqubic> Bifunctor seems like the more natural way of expressing the transformations that can be applied to pairs.
21:44:04 <rajivr___> Also I am learning Haskell primarily for my own personal development and not for any exams! :-)
21:44:47 <monochrom> Bifunctor is not even of the right kind.
21:44:54 <iqubic> It isn't?
21:44:58 <iqubic> Why not?
21:45:05 <monochrom> Or rather, this "Pair" isn't even the right kind for Bifunctor.
21:45:12 <monochrom> Reading comprehension. That's why.
21:45:44 <iqubic> Oh. This pair forces the two values to have the same type.
21:46:15 <iqubic> Because of that, I feel like the functor instance should apply the function f to both arguments.
21:46:47 <monochrom> rajivr___: The fun begins when you try to make it a Monad.
21:47:06 <monochrom> I learned it the hard way. Literally.
21:47:20 <iqubic> Why does the fun start there? Don't you have to make applicative first?
21:47:43 <Welkin> what did it fall on Mohs mineral hardness scale then>
21:47:43 <Welkin> ?
21:47:48 <Welkin> where did it*
21:47:51 <rajivr___> I am one chapter away before Monad starts. Next chapter is Applicative.
21:48:06 <Welkin> or did you use the Rockwell scale?
21:48:20 <nshepperd> the fun starts whenever you want it to
21:48:23 <iqubic> Trying to make this an applicative is going to be hard, because you can't magic up a value for pure.
21:48:33 <MarcelineVQ> eveyone sane uses rockwell Welkin
21:48:46 <monochrom> It was 10/10 on the "a monad is a composition of two adjoint functors" scale.
21:48:48 <iqubic> You can write <*> easily.
21:49:14 <dmwit> iqubic: I don't find it hard.
21:49:21 <dmwit> But then, I've done it a couple times before.
21:49:24 <iqubic> Pair f g <*> Pair x y = Pair (f x) (g x)
21:49:37 <Welkin> that looks like a BiApplicative
21:49:38 <Welkin> right?
21:49:44 <dmwit> (g y), not (g x).
21:49:57 <nshepperd> biapplicative would be (,)
21:49:58 <shachaf> dmwit: Did you magic up the value for pure, though?
21:49:59 <dmwit> No, it has the wrong kind for BiApplicative, for the exact same reason it has the wrong kind for Bifunctor.
21:50:02 <monochrom> Seriously, pure is the "nothing else better to do anyway" one, what are you smoking?
21:50:04 <shachaf> I bet you just used the argument.
21:50:04 <iqubic> Welkin: 'data Pair a = Pair a a
21:50:13 <shachaf> No magic there.
21:50:20 <iqubic> pure a = Pair a a
21:50:22 <iqubic> I see.
21:50:58 <qualiaqq> rajivr___: what book are you reading?
21:51:11 <rajivr___> Haksell Book
21:51:11 <Welkin> The Necronomicon
21:51:19 <Welkin> which one?
21:51:22 <dmwit> iqubic: You may enjoy this observation: Pair a ~= Bool -> a, and you already know the Functor/Monad/Applicative instance for Bool -> a.
21:51:38 <shachaf> Oh no, that's a terrible book based on all the excerpts I read of it.
21:51:46 <shachaf> I wish they wouldn't market themselves as canonical somehow.
21:51:51 <Welkin> I hate when people say "I'm reading the haskell book"
21:51:58 <MarcelineVQ> they don't <_< it's just the website name, not the books name
21:51:59 <Welkin> there are dozens of them
21:52:12 <Welkin> well, their website is "haskellbook.com" or something
21:52:21 <Welkin> that is not okay
21:52:31 <Welkin> the title of the book is *not* "haskell book"
21:52:34 <iqubic> dmwit: I don't actually know what the Functor/Applicative/Monad instances are for "Bool -> a"
21:52:34 <Welkin> it is some long ass title
21:52:35 <MarcelineVQ> well that's on you to read it as "the haskell book", instead of "a haskell book"
21:52:57 <monochrom> We need someone to snatch up "besthaskellbook.com" real quick. >:)
21:53:06 <MarcelineVQ> canonicalhaskellbook.ai
21:53:08 <Welkin> "haskell from first principles" or something
21:53:11 <Welkin> egt the title right at least
21:53:15 <Welkin> damn
21:53:17 <EvanR> microsoft has been naming their things like "word processor" (or something) for decades
21:53:27 <shachaf> All you need to know is that (r ->) is a monad for any r.
21:53:28 <EvanR> "windowing system" 
21:53:28 <iqubic> Wait.. That's just 'instance Functor ((->) r) where ...' specialized to r ~ Bool
21:53:34 <monochrom> And "SQL server" like there is only one.
21:53:34 <shachaf> (As long as r is a comonoid, anyway.)
21:53:35 <iqubic> Yeah. I just figured that out.
21:53:43 <iqubic> shachaf: What's a comonoid?
21:53:56 <rajivr___> Personally I really like it. This is perhaps my 10th attempt at learning Haskell, and I think I am finally getting it. What worked for me was a combination of Rust and exercise driven approach of the book. 
21:53:59 <monochrom> Yes I hate it when people say "I use Office" or "I use The SQL Server"
21:54:12 <EvanR> can't hurt for some chump to try that shit on his own
21:54:12 <nshepperd> i assume it was originally called thehaskellbook.com, then someone told them to drop the 'the'
21:54:15 <iqubic> I use Libre Offic.
21:54:35 <dmwit> iqubic: Ignore the comonoid comment. It was a joke, and almost certainly intended to be confusing.
21:54:36 <monochrom> IIUC facebook was thefacebook, too.
21:54:54 <qualiaqq> rajivr___: I'm in the same boat. And reading the same book.
21:54:56 <dmwit> iqubic: (Not incorrect or a lie, though. Just... not really relevant to anything.)
21:55:01 <monochrom> If the movie is to be believed, the Napter guy suggested "drop 'the'"
21:55:19 <EvanR> right. like theres only one The Napster Guy
21:55:29 <iqubic> Is saying I use "libre office" better than just stating "I use office"?
21:55:32 <rajivr___> Though the detour into Stack pretty much wasted a month of my time. Right now I am using Nix + Dante.
21:55:44 <iqubic> Nix + Dante is great.
21:55:52 <Welkin> stack sucks
21:55:56 <Welkin> use cabal
21:56:04 <Welkin> especially now that cabal 3 is out
21:56:05 <shachaf> dmwit: More relevant than LibreOffice, though!
21:56:05 <iqubic> I use cabal.
21:56:21 <iqubic> I do actually use LibreOffice.
21:56:24 <rajivr___> Basically nix + cabal + dante.
21:56:31 <shachaf> Yes, it's just not relevant to this channel at all.
21:56:33 <EvanR> does LibreOffice now support Haskell
21:56:38 <iqubic> no.
21:56:49 <qualiaqq> funny I do the same. I didn't think so many people use dante.
21:56:51 <monochrom> "stack" is another obnoxious name.
21:56:52 <Welkin> libreoffice is my haskell IDE
21:57:01 <iqubic> I love dante.
21:57:12 <EvanR> stack is great, if you know how to use it you can tell people you're a full stack engineer
21:57:29 <monochrom> Almost every language has its tool stack.  No one has the right to claim "I am that stack".
21:57:33 <qualiaqq> I've tried HIE, but I keep running into perf issues in emacs.
21:57:39 <iqubic> Bloody hell that was a good joke.
21:57:42 <Welkin> monochrom: this is probably from the javascript trends of naming your libraries/software common dictionary words that are unsearchable online
21:57:55 <rajivr___> I tried HIE + Nix, but could not make it work.
21:58:02 <monochrom> Even hackage had the decency to not call itself "the repo"
21:58:28 <iqubic> EvanR: Do you think the people who maintain "Stack" call themselves "Full stack stack devlopers"?
21:58:43 <EvanR> i'm not a betting man
21:58:57 <qualiaqq> another tool to keep your eyes on is: https://github.com/digital-asset/ghcide
21:58:59 <monochrom> full stack stack devop and paralegal (soon paramedic too)
21:59:09 <rajivr___> Which is why I said I wasted about a month. (Though I spend only  about an hour or two  a day working the book)
21:59:39 <iqubic> monochrom: are you describing yourself?
21:59:59 <monochrom> ghcide is an unfortunate name.  insectide.  regicide.  ghcide.
22:00:11 <EvanR> ghcicide
22:00:14 <nshepperd> xenocide
22:00:17 <qualiaqq> they were calling it hie-core
22:00:46 <Welkin> why not call it SHIME?
22:00:47 <Welkin> after SLIME
22:00:48 <qualiaqq> I got it working but ran into perf issues with autocompletion. Might be something I'm doing wrong.
22:00:53 <monochrom> Crusader King V: GHCide.
22:01:04 <Welkin> or hime
22:01:06 <Welkin> like a princess
22:01:20 <nshepperd> i'll make an tool that maintains two installations of stack, and call it queue
22:01:29 <monochrom> hahaha
22:01:33 <monochrom> nshepperd++
22:01:49 <iqubic> Alright. I just laughed so hard, I fell out of my chair.
22:01:59 <monochrom> @remember nshepperd i'll make an tool that maintains two installations of stack, and call it queue
22:02:00 <lambdabot> It is stored.
22:02:01 <iqubic> Err.. Sorry.
22:03:14 <iqubic> I'm sorry for what I did.
22:22:06 <MarcelineVQ> I don't see anything to apologize for
22:22:31 <Welkin> for existing
22:22:43 <MarcelineVQ> you're full of beans tonight
22:26:53 <iqubic> I'm sorry.
22:27:09 <EvanR> what are you apologizing about
22:32:50 <iqubic> Nothing, I guess.
22:37:03 <EvanR> damn right
22:38:26 <sm[m]> Just stop It iqubic
23:15:30 * hackage lens-process 0.3.0.1 - Optics for system processes  https://hackage.haskell.org/package/lens-process-0.3.0.1 (topos)
23:49:11 <hoxtrop[m]> > Is saying I use "libre office" better than just stating "I use office"?
23:49:11 <hoxtrop[m]> Never went beyond Vim and LaTeX
23:49:13 <lambdabot>  <hint>:1:72: error:
23:49:13 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
