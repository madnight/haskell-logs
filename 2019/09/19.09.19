00:12:30 * hackage conferer-hspec 0.1.0.1 - conferer's FromConfig instances for hspec Config  https://hackage.haskell.org/package/conferer-hspec-0.1.0.1 (ludat)
00:13:31 * hackage conferer 0.1.0.3 - Configuration management library  https://hackage.haskell.org/package/conferer-0.1.0.3 (ludat)
00:13:56 <sshine> I took a Haskell course in 2011, so that must've been 7.0.4.
00:15:25 <sshine> wait, I remember wrong. it was 2012, 7.4.1.
00:22:36 <olligobber> > data Never
00:22:37 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
00:23:02 <olligobber> hmm
00:25:00 * hackage purebred-email 0.3.0.0 - types and parser for email messages (including MIME)  https://hackage.haskell.org/package/purebred-email-0.3.0.0 (frasertweedale)
00:39:30 * hackage hasbolt-extras 0.0.0.22 - Extras for hasbolt library  https://hackage.haskell.org/package/hasbolt-extras-0.0.0.22 (ozzzzz)
01:06:31 <boxscape> Hm, I was slightly annoyed that haskell's enumFromTo's upper bound is inclusive after reading Dijsktra's piece on why upper bounds should be exclusive, but actually I suppose you couldn't do that since enumFromTo works with finite Enums as well
01:07:39 <boxscape> although then again
01:07:54 <boxscape> you could just use enumFrom if you wanted to go to maxBound
01:07:57 <boxscape> does that work?
01:08:14 <boxscape> % [False ..]
01:08:14 <yahb> boxscape: [False,True]
01:08:16 <boxscape> yes
01:09:20 <boxscape> Okay I'm back to being slightly annoyed then
01:26:31 <phadej> then one would have a hack, "if n == maxBound then [m ..] else [m .. succ n]" when needing an inclusive range?
01:30:33 <boxscape> Hm I suppose that part is kind of awkward
01:31:26 <phadej> (were the inverse is easier, if one wants exclusive-inclusive range, it's [m .. succ n]
01:32:04 <[exa]> well if you write [1..5] and get [1,2,3,4] it gets really weird
01:32:11 <phadej> yet, that syntax is really not used as much as say for loops in C, so it's not so important
01:32:14 <[exa]> boxscape: why not write your own range?
01:32:51 <boxscape> [exa] It's more of a theoretical annoyance than something I would actually be concerned about in practice
01:33:27 <[exa]> there are so many annoyances around numbers. Did you see the trick with Double vs. enumFromTo ?
01:33:28 <boxscape> I think there's some inherent value in using using library functions and common idioms, as well
01:33:35 <boxscape> I saw something like that
01:34:20 <[exa]> % [1.0, 1.1 .. 2]   --IIRC
01:34:20 <yahb> [exa]: [1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004,1.5000000000000004,1.6000000000000005,1.7000000000000006,1.8000000000000007,1.9000000000000008,2.000000000000001]
01:34:21 <boxscape> phadej do you mean [m .. pred n] for the exclusive-inclusive range? Or am I misunderstanding?
01:34:30 <boxscape> nice
01:35:03 <boxscape> % [1.0..0.9]
01:35:03 <yahb> boxscape: [1.0]
01:35:22 <phadej> hmm, looking at the current project, we have [June .. August] -- which would be super confusing with not inclusive range
01:35:33 <phadej> or [minBound .. maxBound]
01:36:14 <phadej> or [1..31] -- (for days which don't start with zero!)
01:36:15 <boxscape> the syntax haskell has adopted admittedly lends itself better to inclusive ranges
01:36:52 <phadej> I only remember wanting 0 <= x < n range when writing some _loops_ in ST s
01:36:53 <boxscape> or maybe that's just because I'm used to this syntax working that way, I'm not sure
01:37:13 <[exa]> maybe there could be some extra syntax extension for [0 ..< 5]
01:38:07 <boxscape> yeah that's not bad syntax, although it kind of suggests that you need an Ord instance
01:38:16 <[exa]> one extra syntax extension never hurt nobody
01:38:59 <phadej> Enum has warts, but IMHO that's not the one
01:47:52 <Ariakenom> enumFromAlmostTo
01:48:29 <boxscape> enumFromToAlmost seems less ambiguous
01:59:24 <dminuoso> Mmm, does GHC have any heuristic for detecting bottoms?
02:00:05 <Taneb> dminuoso: in some cases. If it tries to evaluate a thunk it's already evaluating, it will fail with a <<loop>> exception
02:00:05 <dminuoso> Or at least warn me everytime something using `error` is being used even in a (transitive) dependency?
02:00:14 <dminuoso> Taneb: Mmm.
02:00:21 <Taneb> But that doesn't apply with error
03:00:30 * hackage colour-space 0.1.5.0 - Instances of the manifold-classes for colour types  https://hackage.haskell.org/package/colour-space-0.1.5.0 (leftaroundabout)
05:03:42 <nil> how do i survive in a french university where the standard teaching language is OCaml
05:06:27 <Maxdamantus> Just keep telling yourself "at least it's not Java"
05:12:01 * hackage logging-effect 1.3.6 - A mtl-style monad transformer for general purpose & compositional logging  https://hackage.haskell.org/package/logging-effect-1.3.6 (OliverCharles)
05:17:30 * hackage hie-bios 0.2.1 - Set up a GHC API session  https://hackage.haskell.org/package/hie-bios-0.2.1 (mpickering)
05:26:01 <dminuoso> Mmm. Im using prettyprinter's renderIO into stderr, but its not correctly layouted. As long as I dont redirect stderr, the messages start off with `n-1` (where n is the page width) empty character. If I redirect stderr into a file, there's no spaces in either stdout or the file.
05:26:40 <dminuoso> So basically the output is like: "                 E\nrror while parsing", whereas if I redirect stderr to a file, then I get no output and the file contains just "Error while parsing"
05:26:58 <dminuoso> (This happens on multiple terminal emulators, so its not a bug there)
05:46:58 <pacak> Did anyone managed to get haskell-ide-engine working with ghc 8.8?
05:49:29 <arne_> can i has all values of bounded datatype inside a list?
05:49:39 <arne_> oh.. is it iterate succ 
05:50:16 <lavalike> :t enumFromTo minBound maxBound ++ [maxBound]
05:50:17 <lambdabot> (Enum a, Bounded a) => [a]
05:52:08 <arne_> thanks
05:55:10 <tomsen> i have a stack project and want to add haskell-ide-engine local to project so versions don't mismatch. do i still clone hie and build it somewhere else or can i just add it to stack.yml ?
05:56:06 <tomsen> i never really understood the toolchain honestly
05:59:05 <arne_> what's the haskell equivalent of find? 
05:59:37 <arne_> i have [("LALALA",something),...] and want to find every item with "L" inside the wirst string
06:01:55 <tabaqui2> % :t filter
06:01:55 <yahb> tabaqui2: (a -> Bool) -> [a] -> [a]
06:02:10 <arne_> well that would give me a list, what if i want the first elem?
06:02:14 <arne_> inb4 !!0
06:02:50 <tabaqui2> % :t member
06:02:50 <yahb> tabaqui2: ; <interactive>:1:1: error:; * Variable not in scope: member; * Perhaps you meant one of these: `S.member' (imported from Data.Set), `IS.member' (imported from Data.IntSet), `IM.member' (imported from Data.IntMap)
06:02:53 <tabaqui2> % :t elem
06:02:53 <yahb> tabaqui2: (Foldable t, Eq a) => a -> t a -> Bool
06:03:13 <arne_> how would that look in my example?
06:03:27 <tabaqui2> filter (elem 'L' . fst) [("LALA", 1), ("AB", 2), ("ALA", 3)]
06:03:29 <tabaqui2> % filter (elem 'L' . fst) [("LALA", 1), ("AB", 2), ("ALA", 3)]
06:03:29 <yahb> tabaqui2: [("LALA",1),("ALA",3)]
06:03:47 <arne_> and if i want the first without errors?
06:03:53 <tabaqui2> % find (elem 'L' . fst) [("LALA", 1), ("AB", 2), ("ALA", 3)]
06:03:53 <yahb> tabaqui2: Just ("LALA",1)
06:04:00 <tabaqui2> % find (elem 'L' . fst) []
06:04:00 <yahb> tabaqui2: Nothing
06:04:02 <arne_> oh. there is find
06:04:22 <arne_> where is find from Data.List?
06:04:35 <tabaqui2> sometimes, if you can imagine the signature, you can hoogle it
06:05:42 <yushyin> arne_: Data.Foldable
06:05:55 <lavalike> @index find
06:05:55 <lambdabot> Data.Foldable, Data.List, GHC.OldList, Data.ByteString.Lazy.Char8, Data.ByteString.Lazy, Data.ByteString.Char8, Data.ByteString
06:05:59 <lavalike> found!
06:06:04 <tabaqui2> https://www.stackage.org/lts-12.8/hoogle?q=Foldable+f+%3D%3E+%28a+-%3E+Bool%29+-%3E+f+a+-%3E+Maybe+a&exact=on
06:12:31 <arne_> can that bot search signaturesh
06:25:06 <absence> when using scoped type variables, is there a way to only have some variables scoped, or is it all or nothing?
06:25:30 * hackage exhaustive 1.1.8 - Compile time checks that a computation considers producing data through all possible constructors  https://hackage.haskell.org/package/exhaustive-1.1.8 (OliverCharles)
06:26:30 <tabaqui2> absence: iirc, only variables marked with "forall" keyword are shared
06:26:38 <sm[m]> Morning all. How do you override buildable:false (in cabal file) with command line options ?
06:28:01 <tabaqui2> nope, I'm wrong. Then I've no idea
06:32:43 <ocramz> henlo
06:33:41 <ocramz> what are the best practices for serializing `time` and `scientific` values?
06:37:30 * hackage turtle 1.5.15 - Shell programming, Haskell-style  https://hackage.haskell.org/package/turtle-1.5.15 (GabrielGonzalez)
06:37:31 <absence> tabaqui2: right, i don't think it's possible to forall only some variables
06:37:58 <absence> at least i get errors if i leave some out
06:54:50 <yushyin> absence: because it is a toplevel definition?
06:57:39 * nshepperd2 notes that the dijkstra piece about number ranges starts by expressing the intended sequence the same way haskell does
06:58:24 <nshepperd2> That is, the mathematical way, with the inclusive start and end separated by dots
07:10:03 <Ariakenom> nshepperd: do you have a link?
07:10:35 <nshepperd2> Oh, this one https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html
07:14:01 <absence> yushyin: yes, is that the reason? can you specify that only some variables are scoped if it's not at toplevel?
07:14:52 <yushyin> absence: exactly that, yes.
07:15:17 <Ariakenom> nshepperd2: becasue when I searched I found this :D https://www.cs.utexas.edu/users/EWD/transcriptions/EWD10xx/EWD1019.html
07:16:25 <ben8> I just did a fresh haskell platform install on macOS 10.14.4. Compiling a hello world program with ghc produces a pile of warnings from the rts. Am I doing something wrong? A quick google search didn't turn up anything obvious
07:17:55 <Ariakenom> nshepperd2: Interpretation of the infallible holy scripture can be hard :p 
07:20:12 <nshepperd2> Heh
07:21:43 <exarkun> is there a standard/common `f` like `f [g, h] [i, j] == [g i, h j]`?
07:22:51 <nshepperd2> zipWith id?
07:24:35 <exarkun> hmm looks like yea
07:27:03 <Ariakenom> ap for ZipList
07:28:21 <exarkun> I don
07:28:30 <exarkun> 't understand how `zipWith id` works
07:28:49 <exarkun> zipWith takes an (a -> b -> c) but id is (a -> a)
07:30:38 <geekosaur> (a -> b -> c) is (a -> (b -> c)), now take a ~ (b -> c) and get ((b -> c) -> (b -> c))
07:32:16 <geekosaur> (id :: a -> a) places no constraints on what a is, so (b -> c) is a perfectly sensible "value" for a
07:32:27 <boxscape> % :t id @(_ -> _)
07:32:27 <yahb> boxscape: (w1 -> w2) -> w1 -> w2
07:32:38 <exarkun> thinking about a ~ (b -> c) helped, thanks
07:33:47 <nshepperd> zipWith ($) is the same if you want to emphasize the function application
07:43:30 * hackage conduit-algorithms 0.0.11.0 - Conduit-based algorithms  https://hackage.haskell.org/package/conduit-algorithms-0.0.11.0 (luispedro)
07:52:54 <lavalike> > id succ 3
07:52:56 <lambdabot>  4
07:53:06 <[df]> +
07:53:33 <lavalike> > id id id id id id id id id id id id id id succ 3
07:53:35 <lambdabot>  4
07:55:37 <heatsink> > foldr ($) (succ 3) (replicate 1000 id)
07:55:40 <lambdabot>  4
07:56:00 * hackage newtype-zoo 1.0.0.0 - Newtype Wrapper Zoo  https://hackage.haskell.org/package/newtype-zoo-1.0.0.0 (SvenHeyll)
07:56:02 <geekosaur> and ($) is secretly id :p
07:57:50 <lyxia> > na na na na na na na (....)
07:57:52 <lambdabot>  "Batman!"
07:58:33 <geekosaur> > foldr id succ (replicate 1000 id) 3
07:58:35 <lambdabot>  4
08:01:12 <fendor> @type na
08:01:13 <lambdabot> a -> a
08:01:22 <fendor> @type (....)
08:01:23 <lambdabot> [Char]
08:01:29 <fendor> (....)
08:01:32 <fendor> > (....)
08:01:35 <lambdabot>  "Batman!"
08:06:39 <hackerman> How to correctly read the declaration of the type of composition of functions?
08:06:41 <hackerman> (.) :: (b -> c) -> (a -> b) -> a -> c
08:07:53 <heatsink> It's easier to read as (b -> c) -> (a -> b) -> (a -> c)
08:08:09 <heatsink> It takes a function with type b -> c and a function with type a -> b
08:08:33 <EvanR> even easier as (a -> b) -> (b -> c) -> (a -> c), but to a haskeller that is backwards
08:09:06 <EvanR> see also F a b -> F b c -> F a c   where F = (->)
08:09:44 <EvanR> see also the transitive property
08:10:29 <heatsink> It returns a function with type a -> c.  Because you have functions for converting a -> b and b -> c, you can make the conversion a -> c.
08:11:46 <hackerman> thank you
08:30:20 <tabaqui2> % :i na
08:30:21 <yahb> tabaqui2: ; <interactive>:1:1: error: Not in scope: `na'
08:30:28 <tabaqui2> > :i na
08:30:31 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
08:30:36 <zxtx> Hey I'm trying to write a program transformation with a GADT, but the transformation changes the type of the output program
08:30:39 <tabaqui2> @where na
08:30:40 <lambdabot> I know nothing about na.
08:30:49 <zxtx> What's the best way to encode that change
08:31:06 <zxtx> the program transformation is CPS for the STLC
08:31:21 <zxtx> so I know precisely how the types change as function of the input type
08:33:00 * hackage newtype-zoo 1.0.0.1 - Newtype Wrapper Zoo  https://hackage.haskell.org/package/newtype-zoo-1.0.0.1 (SvenHeyll)
08:45:47 <EvanR> zxtx: if there are a fixed number of cases you could try to use a type family
08:46:28 <EvanR> if the output type is a known formula of the input type, then you might be able to just use ordinary polymorphism
08:48:02 <zxtx> EvanR, one issue I have is that there is some recursion in this function
08:48:34 <zxtx> and the base case is CPS a = (a -> r) -> r which is hard to use specify with a type family
08:49:51 <EvanR> there's no r introduced so i assume CPS is a GADT
08:50:25 <EvanR> and i'm not sure how that could be used
08:50:31 <EvanR> (unknown r)
08:50:57 <EvanR> maybe paste your code
08:53:21 <zxtx> sure
09:02:24 <zxtx> EvanR, https://pastebin.com/W6X8x5JR
09:10:22 <t7> Has anyone here built ghcide with stack?
09:35:41 <tomjaguarpaw> How can I, if at all, in `cabal v2-repl` choose on the command line which module I want to have loaded?  That is, what I'd do in ghci as `ghci src/Blah.hs`
09:38:05 * argent0 it loads the first module on the other modules list
09:44:58 <tomjaguarpaw> argent0: Yes, it does.  Is that behaviour configurable somehow?
09:45:02 <tomjaguarpaw> It seems rather arbitrary.
10:07:41 <iqubic`> @src na
10:07:41 <lambdabot> Source not found. My mind is going. I can feel it.
10:11:59 <glittershark> is there a combinator in lens that can turn a [(a, b)] into an indexed [b]?
10:12:13 <glittershark> sorta a backwards `withIndex`
10:12:39 <glittershark> I specifically want to filter that `b` via a Fold but retain the `a`
10:13:00 <glittershark> eg I have a Fold b b' and an [(a, b)] and I want to get an [(a, b')]
10:16:42 <dmj`> glittershark: you might have better luck in #haskell-lens 
10:16:51 <glittershark> oh hey dmj` how's it going
10:17:12 <glittershark> ty tho
10:17:17 <dmj`> glittershark: yw
10:20:54 <FabianW> Is there an up to date cheat-sheet on Haskell syntax out there somewhere? I'm gonna be a teaching assistant next semester and the one the prof gave out last year was kinda outdated iirc.
10:22:20 <dmj`> FabianW: this one is kind of cute https://learnxinyminutes.com/docs/haskell/
10:24:36 <FabianW> dmj`: Thanks, saved that one. It really is kinda cute.
10:25:03 <dmj`> :)
10:35:21 <FabianW> Oh wow, while looking for resources to recommend I found out that Real World Haskell is actually free to read online, didn't know that. 
10:36:23 <dmj`> FabianW: This one is real good, but it's more of a reference, yet very comprehensive (inclusive of more than just Haskell, ghc too). http://dev.stephendiehl.com/hask/
10:37:30 <FabianW> dmj`: I knew that one, but thank you still, it really is a gold mine. It's the next Haskell-related thing I'm planning to work through after the book I'm currently chewing on.
10:39:20 <dmj`> FabianW: which book are you currently chewing on ?
10:39:50 <FabianW> Practical Haskell, by Alejandro Serrano Mena
10:40:10 <FabianW> Though I'm still unsure about whether I like it or not
10:43:10 <dmj`> that's cool
10:43:13 <FabianW> dmj`: I like the topics it talks about but I stumbled on a few slight errors and the "exercises" are shoehorned in a bit.
10:43:33 <hyperisco> There should be a service where you tick boxes for properties and it then tells you the name of the thing
10:44:18 <FabianW> hyperisco: Like Akinator for everything else as well as names?
10:44:58 <hyperisco> I think Akinator may be roundabout but it could work too
10:45:32 <FabianW> hyperisco: If we're talking about Haskell related stuff, isn't that basically what hoogle is?
10:46:12 <geekosaur> type theory twenty questions
10:46:43 <hyperisco> I want to say something like: "a reflexive, transitive, symmetric relation" and have it tell me "equivalence relation"
10:47:10 <hyperisco> "An associative binary operator"; "A semigroup"
10:47:47 <FabianW> hyperisco: Sounds like a set of algebra flash cards
10:48:37 <hyperisco> it would make identifying certain things less painful
10:49:07 <EvanR> knowing the names of things is having power of them, like rumplestiltskin
10:49:34 <EvanR> having power over them...
10:52:52 <higherorder> Hello! How would you go about writing a generic Aeson FromJSON instance for Data.Fix.Fix?
10:56:10 <lyxia> instance FromJSON (f (Fix f)) => FromJSON (Fix f) where parseJSON v = Fix <$> parseJSON v
10:59:01 <higherorder> lyxia: that doesn't compile :(
11:00:09 <higherorder> lyxia: oh wait; it does. I tried this earlier and it didn't; what the hell
11:00:39 <higherorder> lyxia: oh I needed UndecidableInstances
11:07:37 <dmwit> You might be able to `instance (forall a. FromJSON a => FromJSON (f a)) => FromJSON (Fix f)` with QuantifiedConstraints but not UndecidableInstances.
11:07:40 <dmwit> higherorder: ^
11:08:13 <higherorder> dmwit: thanks! do you think this is preferable to UndecidableInstances? I'm not aware of the tradeoffs
11:09:29 <dmwit> QC is only available in newer GHCs, so less of a back-compat story than UI. On the other hand, it seems nice to have the compiler guarantee of decidability when you can.
11:10:28 <dmwit> Both pressures seem very light to me. Upgrading GHC is usually easy, and it's pretty rare to actually have trouble with blowing the instance stack.
11:11:11 <higherorder> dmwit: alright; thanks!
11:20:16 <dsal> Is OverloadedLists considered bad?
11:23:53 <habbah> > getCurrentTime
11:23:55 <lambdabot>  error: Variable not in scope: getCurrentTime
11:26:54 <hyperisco> What is a repository of information on ternary relations? Are they studied much?
11:28:53 <jle`> dsal: not particularly, if you keep a consistent style maybe
11:29:10 <jle`> if you're asking about readability
11:30:05 <habbah> maybe this is useful? https://math.stackexchange.com/questions/279831/categories-of-n-ary-relations?rq=1
11:44:06 <dsal> jle`: just looking at our internal style guide. It's not listed as "generally uncontroversial" or whatever
11:44:47 <jle`> i don't think it's super common, but it can be useful if you keep a consistent style with it
11:45:06 <jle`> it might cause some issues with type inference in some situations, the same as OverloadedStrings does
11:45:18 <jle`> but it's not an unsound/ghc-breaking extension, if that is what you are asking about
11:46:30 * hackage perceptual-hash 0.1.3.0 - Find duplicate images  https://hackage.haskell.org/package/perceptual-hash-0.1.3.0 (vmchale)
11:47:32 <jle`> dsal: it's not on the level of -XTupleSections or -XLambdaCase (the "why isn't this in default Haskell?" category) but more on -XOverloadedStrings (it can make certain domains much more readable/easy to work with)
11:49:42 <dsal> Hmm... I'm not sure I understand your categories.  TupleSections should be on by default because it's so obvious it seems missing and does no harm?
11:50:25 <dsal> Whereas OverloadedStrings makes error messages worse and may confuse things?
11:50:33 <jle`> er yeah, i meant "why isn't this a part of the Haskell standard already?"
11:50:40 <dsal> At yes
11:50:51 <jle`> whereas OverloadedStrings is clearly helpful but not necessarily "obviously should be in the standard" levels of helpful
11:51:01 <jle`> it feels more like an augmentation than a missing hole
11:51:06 <dsal> I've only used LambdaCase once, so I don't quite remember what it does.
11:51:19 <dsal> I see
11:51:44 <dsal> OL is a lesser OS as far as usefulness goes.
11:52:01 <jle`> it can be useful if you're, say, writing a lot of Map literals
11:52:16 <dsal> Right, or sets or something.
11:53:40 <jle`> yeah. it can be a useful feature but it's not like GHC-breaking avoid-at-all-costs or avoid-usually like some other extensions can be
11:59:55 <Nolrai> Hey, so I wan't a sort of bidirectional dictionary, that I can quarry either all the A's that correspond to a given B, or all the B's that correspond to a given A.
12:00:07 <Nolrai> * want
12:00:50 <hyperisco> (Map a (Set b), Map b (Set a))
12:01:19 <Rembane> Nolrai: What hyperisco said and if you want it extra pretty, put it in a module and only export the operations on it you want to expose. 
12:01:35 <Nolrai> Okay. That works.
12:01:53 <jle`> yeah you'd just need to make sure to preserve the invariants when you insert and stuff
12:03:14 <jle`> if you just want a single a to single b relationship it looks like the bimap library (disclaimer, it was last updated 11 years ago) has that
12:03:37 <jle`> oh wait google gave me an old version, the last version is up to date as of 2019 :)
12:03:57 <jle`> silly google.
12:04:57 <Nolrai> So something like "newtype OpSpace s = OpSpace {resultsIn :: Map (Int, Int) (Set Int), comesFrom :: Map Int (Set (Int, Int)}"?
12:12:30 * hackage monoid-statistics 1.0.1.0 - Monoids for calculation of statistics of sample  https://hackage.haskell.org/package/monoid-statistics-1.0.1.0 (AlexeyKhudyakov)
12:27:30 * hackage aeson-schemas 1.0.0 - Easily consume JSON data on-demand with type-safety  https://hackage.haskell.org/package/aeson-schemas-1.0.0 (leapyear)
12:38:11 <f-a> http://paste.debian.net/plain/1101647
12:43:22 <lyxia> there's no memoization going on and you can check it by just running the program.
12:44:06 <f-a> lyxia: how so? (checking it by just running the programm)
12:45:12 <lyxia> you try running it with different values of f and see that it takes exponentially longer
12:45:23 <lyxia> as f grows
12:46:50 <f-a> thanks
12:53:13 <Guest_37> HI
12:53:44 <Guest_37> I am trying to install the Haskell now
12:54:05 <Guest_37> through my terminal
12:54:29 <Guest_37> my system is OS
12:55:17 <Guest_37> when the download is finish ,it shows In order to run ghc and cabal, you need to adjust your PATH variable.You may want to source '/Users/zhangzaibin/.ghcup/env' in your shellconfiguration to do so (e.g. ~/.bashrc).
12:56:05 <arlo> hi
12:56:07 <arlo> I am trying to install the Haskell nowthrough my terminalmy system is OSwhen the download is finish ,it shows In order to run ghc and cabal, you need to adjust your PATH variable.You may want to source '/Users/zhangzaibin/.ghcup/env' in your shellconfiguration to do so (e.g. ~/.bashrc).
12:56:23 <f-a> arlo: it means something like export PATH=~/.cabal/bin:$PATH
12:56:36 <arlo> so
12:56:51 <arlo> I need to type the code in my terminal?
12:56:58 <f-a> are you on unix?
12:57:11 <arlo> no
12:57:12 <f-a> if so you most likely have a file ~/.bashrc
12:57:15 <f-a> oh
12:57:16 <arlo> I am on os
12:57:22 <arlo> I mean mac
12:57:49 <f-a> I am sorry I do- oh a Mac, I believe it is unix. I don't own one, but you should have a ~/.bashrc file, can you check? 
12:58:15 <arlo> ok
12:58:30 <arlo> thank you
12:59:20 <novum> do you know what I just realized. I wrote a bot in python, and I freakin created monads
12:59:32 <sclv> arlo: https://stackoverflow.com/questions/4952177/include-additional-files-in-bashrc
12:59:41 * novum new to haskell and functional programming so forgive me for being excited
13:00:21 <arlo> I am checking your web ,solve ,thank you
13:00:28 <arlo> sclv
13:04:31 <arlo> I think I am still confused , I only type curl https://get-ghcup.haskell.org -sSf | sh   on my terminal , and when download is done ,it does work when I type like "3+4" only terminal
13:05:25 <f-a> did you start ghci?
13:06:13 <arlo> no
13:06:27 <arlo> is it just like a app
13:06:50 <arlo> or I need to start it from my terminal?
13:06:52 <monochrom> No, not in the "see icon, click icon" sense.
13:07:26 <f-a> arlo: type "ghci" and see if something happens
13:07:35 <arlo> ok
13:08:11 <arlo> it shows GHCi, version 8.6.5: http://www.haskell.org/ghc/  :? for helpPrelude>
13:08:15 <f-a> good
13:08:20 <f-a> type 34 + 2
13:08:37 <arlo> wow
13:08:41 <arlo> it works
13:08:41 <f-a> and experiment, remember you can close it with :quit
13:09:04 <arlo> : quit
13:09:22 <arlo> is that mens close ghci?
13:10:01 <f-a> yep
13:10:16 <f-a> but ":quit", not ": quit'
13:10:23 <f-a> *"
13:11:31 <arlo> ok
13:11:38 <arlo> thank you very much
13:11:41 <arlo> f-a
13:11:57 <f-a> you're welcome, happy learning!
13:20:30 * hackage aeson-schemas 1.0.1 - Easily consume JSON data on-demand with type-safety  https://hackage.haskell.org/package/aeson-schemas-1.0.1 (leapyear)
13:38:48 <hseg> Hi. Has anybody used shh? Couldn't find any announce thread
13:42:25 <gatosalchicha> ssh for what?
13:42:45 <hseg> not ssh. shh: https://github.com/luke-clifton/shh
13:42:46 <gatosalchicha> oh sorry i read ssh
13:44:18 <monochrom> I googled and found "sonic hedgehog signaling molecule".
13:44:30 <hseg> :-)
13:45:12 <gatosalchicha> @hseg i haven't but it sounds cool! might as well try it
13:45:12 <lambdabot> Not enough privileges
13:47:14 <hseg> stumbled on it while looking into bash stuff
14:02:00 * hackage lazy-priority-queue 0.1.0.1 - Lazy-Spined Monadic Priority Queues  https://hackage.haskell.org/package/lazy-priority-queue-0.1.0.1 (MarioBlazevic)
14:09:09 <jgt> is there a reason everyone suggests using :quit to get out of GHCi instead of <C-d>?
14:09:41 <Tuplanolla> Perhaps platform compatibility.
14:09:44 <f-a> jgt: no idea if C-d works on Win
14:09:54 <jgt> oh yeah, good point
14:10:00 * hackage secp256k1-haskell 0.1.5 - Bindings for secp256k1 library from Bitcoin Core  https://hackage.haskell.org/package/secp256k1-haskell-0.1.5 (xenog)
14:10:46 <jgt> reminds me of an old online gaming prank. "Hey guys, how do I switch teams?" "Oh, you need to hit alt+F4"
14:10:58 <f-a> hehe
14:11:34 <EvanR> alt+f4 makes the map download faster
14:12:11 <jgt> I vaguely remember seeing some kid fall for that 10 times in a row
14:12:15 <jgt> poor guy
14:12:53 <maralorn> hseg: I did. It was real fun.
14:13:26 <maralorn> I mean it is not as quick as writing a bash script admitedly. But it is much more stable.
14:13:56 <hseg> maralorn: nice. usable as a bash replacement, at least for scripts?
14:14:46 <maralorn> hseg: The setup overhead is a bit high for twoliners. But for tenliners it’s really nice in my opinion.
14:14:51 <maralorn> It shines together with nixos.
14:15:13 <hseg> All the more reason to check out nix as well.
14:15:30 * hackage tree-sitter-typescript 0.2.1.0 - Tree-sitter grammar/parser for TypeScript  https://hackage.haskell.org/package/tree-sitter-typescript-0.2.1.0 (tclem)
14:15:42 <hseg> Also, most of my scripts are tenliners -- can't bring myself to write twoliners
14:16:23 <tabaqui2> do you know some monad combining ExceptT and defer like in go
14:16:30 <tabaqui2> so I want to do somewhat
14:17:13 <tabaqui2> "h <- ExceptT connectSocket; defer (close h); ctx <- ExceptT makeTLSContext; defer (shutdown ctx); ..."
14:17:16 <maralorn> hseg: I am not saying this is the best idea to do, but I did something like this to play around and it‘s really usable: https://git.darmstadt.ccc.de/maralorn/nixos-config/blob/master/lib/test.nix
14:17:30 * hackage tree-sitter-tsx 0.2.1.0 - Tree-sitter grammar/parser for TSX  https://hackage.haskell.org/package/tree-sitter-tsx-0.2.1.0 (tclem)
14:18:04 <maralorn> hseg: One real cool thing is the bracket-pattern. Can‘t do that in bash.
14:18:40 <hseg> yep. or actually having structured data you can manipulate
14:19:04 <tabaqui2> well, it is not about IO actions, really
14:19:30 <tabaqui2> I just want to mix Either transformer with some "release" actions
14:29:06 <tabaqui2> ah, I can combine it with writer monad
14:29:18 <tabaqui2> write release actions and call them reversed
14:29:22 <tabaqui2> right
14:36:30 * hackage newtype-zoo 1.1.0.0 - Newtype Wrapper Zoo  https://hackage.haskell.org/package/newtype-zoo-1.1.0.0 (SvenHeyll)
15:31:01 * hackage aeson-schemas 1.0.2 - Easily consume JSON data on-demand with type-safety  https://hackage.haskell.org/package/aeson-schemas-1.0.2 (leapyear)
15:58:19 <Nefisto> Good day friends
17:11:30 * hackage webby 0.1.2 - A super-simple web server framework  https://hackage.haskell.org/package/webby-0.1.2 (AdityaManthramurthy)
17:19:27 <jle`> newtype-zoo is interesting. but at that point why not just use Tagged
17:21:01 <dmwit> The readme addresses that.
17:21:21 <dmwit> Of course you might not agree with what the readme says.
17:22:39 <iqubic> What is the newtype-zoo even for?
17:23:36 <monochrom> I have a cunning plan! Reimplement newtype-zoo (with minimum change to its API, e.g., type names) such that each newtype-zoo type is a newtype wrapper over a tagged type. >:)
17:24:28 <iqubic> I love it.
17:25:11 <iqubic> What is Tagged?
17:29:45 <dmwit> If only there were some automated tool which could answer that.
17:30:53 <monochrom> There is no tool automating reading comprehension. At least not in the sense of doing the reading comprehension for a human.
17:31:05 <monochrom> If there were, we would no longer need the human.
17:31:32 <monochrom> (Reductio ad human-centricism >:) )
17:34:12 <drt> any default functions that take a string and a filter and return a string with some character added when the filter applies?
17:34:38 <monochrom> No.
17:35:03 <monochrom> Also I wouldn't call it "filter" if it adds, not bans, things.
17:36:12 <monochrom> Like wouldn't it be nice if I could buy a coffee filter paper that adds whiskey to the coffee that passes through >:)
17:37:30 * hackage webby 0.1.3 - A super-simple web server framework  https://hackage.haskell.org/package/webby-0.1.3 (AdityaManthramurthy)
17:38:29 <monochrom> (reductio ad alcoholism >:) )
17:39:14 <hpc> alcohol is only reduced if it's in a sauce ;)
17:40:27 <jle`> dmwit: ah, i didn't read that far
17:41:10 <johnw> I think drt wants a string-like object that holds a string, but if a filter changes its content, some other data gets added to it automatically; not sure why he'd want it, but I don't think he means "a filter that adds something", but rather "an addition that occurs if a filter had an impact"
17:41:18 <jle`> hm, i'm not sure i understand the reasoning. is it that Active is shorter than Tagged "Active" ?
17:41:28 <drt> yes filter was the wrong word
17:41:30 <jle`> in which case can't you just do `type Active = Tagged "Active"`
17:42:01 <jle`> i suppose that extra line is the "requires more code" part
17:42:30 * hackage antiope-optparse-applicative 7.4.1 - Please see the README on Github at <https://github.com/arbor/antiope#readme>  https://hackage.haskell.org/package/antiope-optparse-applicative-7.4.1 (arbornetworks)
17:42:31 <jle`> that's fair
17:43:30 * hackage antiope-shell 7.4.1, antiope-contract 7.4.1, antiope-swf 7.4.1, antiope-athena 7.4.1, antiope-dynamodb 7.4.1, antiope-core 7.4.1, antiope-s3 7.4.1, antiope-sns 7.4.1, antiope-sqs 7.4.1, antiope-messages 7.4.1 (arbornetworks)
17:43:34 <turab> @pl \ma mb -> do {a <- ma; b <- mb ; return $ a : b}
17:43:35 <lambdabot> (line 1, column 14):
17:43:35 <lambdabot> unexpected '{'
17:43:35 <lambdabot> expecting variable, "(", operator or end of input
17:43:53 <Axman6> (:) <$> ma <*> mb
17:44:00 <turab> Ha thanks!
17:44:10 <Axman6> or liftA2 (:)
17:44:21 <turab> Man I need to remember about lifts
17:44:24 <turab> Thanks again
17:45:16 <monochrom> Or rather, Applicative.
17:52:25 <M2en[m]> I got in trouble at work today for writing Haskell. We had to make example interview questions and write solutions. My problem was to print the first 10,000 integers then print their average. My manager asked me if I should be asking interview candidates to write Haskell when we are only using TypeScript. xD He made me write the TypeScript solution before I left.
18:00:35 * M2en[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/THPgfIIwEhoBJTQRxAOHUrjn >
18:02:26 <EvanR> average, the tricky haskell interview question
18:04:51 <f-a> don't you just need a average :: Fractional a ... constraint?
18:09:02 <monochrom> realToFrac waives that and imposes Real instead.
18:09:50 <monochrom> To be sure Real is more restrictive.
18:11:25 <f-a> I mean average xs = sum xs / genericLength xs does it in this case, right?
18:12:08 <monochrom> maybe you should s/need/suffice/
18:12:38 <f-a> fair enough
18:12:42 <monochrom> There is a difference between "here is how I would do it" and "everyone must do it this way".
18:13:20 <monochrom> Somehow I feel that programmers have a higher tendency than average to mix them up.
18:14:58 <f-a> glad I am not one then
18:15:01 <Clint> is genericLength better than (fromIntegral . length)?
18:15:05 <monochrom> No, Real is not more restrictive.
18:15:50 <monochrom> If you go with Real, you allow Integer but not Complex Double. If you go with Fractional, you allow Complex Double but not Integer. None of them wins.
18:16:34 <monochrom> But since the manager cannot possibly imagine (pun!) complex numbers, it is safer to bet on allowing Integer.
18:18:13 <EvanR> sum xs / genericLength xs would be a killer when xs is long
18:18:20 <EvanR> and not a priori materialized
18:19:43 <EvanR> i am the douchebag hiring manager and decide your lack of respect for performance is not up to snuf
18:20:30 <EvanR> also you took too long to solve the rubik's cube
18:21:11 <monochrom> The default implementation of genericLength is so lazy it defeats all supporting arguments about "what if xs is a lazy list but very very long once you unravel it".
18:22:06 <dmj`> length xs would keep the cons cells from getting GC'd, it will blow the heap for large xs's
18:22:06 <EvanR> how
18:22:06 <monochrom> Because lazy genericLength is just going to start by building up a thunk proportional to that very very long length. If you envision a lazy list that would not fit in memory, well the thunk will not fit in memory either.
18:22:43 <EvanR> yeah the "right" interview answer doesn't involve sum or length or genericLength
18:22:45 <monochrom> "genericLength (_:l) = 1 + genericLenth l" what does it look like to you? Efficient code?
18:24:05 <monochrom> However, the default implementation doesn't always get used. There are rewrite rules that replace it by a non-lazy accumulator algorithm if the codomain is Int or Integer.
18:24:28 <monochrom> But only Int or Integer! Woe to you if you even try Natural!
18:29:48 <monochrom> I am pretty sure the original inventors of genericLength did not have "what if the answer would overflow Int" in mind, unlike popular opinion (which is self-defeating as I pointed out). Instead the original inventors much more likely had in mind "what if you have your own lazy number type like 'data MyNat = Zero | Succ MyNat'"
18:35:35 <dmwit> f-a: The standard complaint about that solution is that it forces the entirety of xs to remain in memory.
18:35:48 <dmwit> f-a: (Whereas it is possible to implement in a way that does not have that problem.)
18:37:16 <f-a> dmwit: it is uhhh a clever way to let the recruiter lead with a second question
18:41:41 <dmwit> Somehow nobody ever bothers to complain about numerical stability, though.
18:42:23 <monochrom> [1..10000] is a lot of small integers that remain exact in Double, and their sum too.
18:43:24 <dmwit> If we are specializing to specific lists, then perhaps we should just print the answer directly without going to all the trouble of computing it first.
18:43:33 <monochrom> The manager is probably also completely ignorant and incompetent on numerical stability to start with.
18:44:03 <dmwit> > (10000+1)/2
18:44:05 <lambdabot>  5000.5
18:44:11 <monochrom> Yeah I agree, I would just "print 5000.5" for the average.
18:44:38 <monochrom> To be sure I wouldn't hand-code 10000 lines of "print 1; print 2; print 3" etc
18:47:05 <monochrom> Does any interviewer/interview make you write test cases and/or test drivers?
18:47:38 <fosterite> Hello, I implemented this (named for desugaring ASTs) and I'm sure it's a named recursion scheme desugarNeater2 :: (Functor i, Functor o) => Free i a -> (i (Free o a) -> Free o a) -> Free o a 
18:47:40 <monochrom> IMO a much more important and needed skill.
18:48:54 <fosterite> I'm an idiot it's juts catamorphism isn't it
18:50:52 <dmwit> it sure is
18:51:13 <dmwit> Well, under some pretty weak assumptions about how you implemented it, anyway.
18:51:28 <dmwit> Bet you don't need that Functor o constraint!
18:51:48 <fosterite> yeah, I don't
18:52:15 <fosterite> I did the usual fmap (cata fmap) implementation
18:52:34 <fosterite> AKA "how does this function do anything?"
18:53:21 <fosterite> well, thanks
18:53:38 <fosterite> it really makes treewalking slick
18:55:00 * hackage antiope-shell 7.4.2 - Please see the README on Github at <https://github.com/arbor/antiope#readme>  https://hackage.haskell.org/package/antiope-shell-7.4.2 (arbornetworks)
18:56:00 * hackage antiope-athena 7.4.2, antiope-core 7.4.2, antiope-optparse-applicative 7.4.2, antiope-swf 7.4.2, antiope-contract 7.4.2, antiope-sns 7.4.2, antiope-s3 7.4.2, antiope-messages 7.4.2, antiope-sqs 7.4.2, antiope-dynamodb 7.4.2 (arbornetworks)
18:58:39 <monochrom> fmap does a lot.
19:00:15 <dmwit> While not technically Haskell related, Richard Guy's Strong Law of Small Numbers was just brought to my attention and I thought many people here might also enjoy it. https://www.maa.org/sites/default/files/pdf/upload_library/22/Ford/Guy697-712.pdf
19:01:02 <fosterite> @pl \x f -> cata f (fmap pure x)
19:01:02 <lambdabot> flip cata . fmap pure
19:01:11 <fosterite> that's my desugar function
19:01:14 <monochrom> fmap is the one that does a case analysis and decides "this is the base case, I won't recurse" vs "this is not the base case, I need to recurse, and here are what to recurse on".
19:03:38 <monochrom> Haha "it will be proved by intimidation"
19:03:50 <fosterite> I understand, but looking at the functor instance for Free is not any more illuminating.
19:03:57 <fosterite>   fmap f (Free v) = Free $ fmap (fmap f) v  OK sure I guess
19:04:47 <dmwit> The Functor instance for v's type will likely be more enlightening. ;-)
19:05:01 <monochrom> OK that one is deceptive because some "fmap"s are of your functor and some others are for Free.
19:06:27 <fosterite> I couldn't write that function without the type system. Which is great, but not great.
19:06:50 <monochrom> Also you're forgetting "fmap f (Pure x) = Pure (f x)"
19:07:25 <fosterite> I wrote it, but I actually understand that part
19:09:46 <monochrom> "fmap f (Pure x) = Pure (f x)" is a concious decision to declare "base case, no further recursive calls".  "fmap f (Free v) = ... (fmap f) ..." is a concious decision to declare "need recursion here".
19:10:25 <fosterite> Oh, I see what you mean
19:10:53 <monochrom> At this level of generality the only work you need is when not to recurse and when to recurse on what. If you get that done you're 100% done.
19:13:03 <monochrom> cata is not meant to know much. all the useful work is supplied by the user-supplied function (the "algebra"). cata just supplies the skeleton, and the skeleton just says what to recurse on. The whole point why it's called "a recursion scheme".
19:16:07 <dansho> how can i get ghc to know about the packages cabal installs in .cabal/packages?
19:16:45 <monochrom> When I teach this stuff I don't start with the general Free (not even if I supplied my own specific functor).  I start with a handcoded free monad like "data M a = P a | W Char (M a) | R (Char -> M a)".  I get the audience to implement fmap and (>>=) for it directly, by hand.
19:17:53 <monochrom> Only after it does it make sense to refactor 3 times to discover you just need to say "fmap" 10 times.
19:18:18 <monochrom> (and that saying "fmap" 10 times works generally for all other free monads)
19:18:29 <fosterite> let me give that a try
19:30:12 <fosterite> yeah, that was very mechanical 
19:30:14 <fosterite> good example
19:34:13 <dmj`> dansho: call ghc-pkg list
19:34:16 <dmj`> dansho: what path does it show
19:35:29 <dansho> : /opt/haskell/.ghcup/ghc/8.6.5/lib/ghc-8.6.5/package.conf.d
19:36:10 <dansho> i found the conf files, they are in ~/.cabal/store/ghc-8.6.5/packages.db/
19:36:27 <dansho> *package.db/
19:37:31 <dansho> i'm not sure how to register the entire directory, if it's even possible, ghc-pkg register didn't work
19:38:46 <dansho> this ghcup thing is new to me, last time i installed haskell it was download a tar and run a shell script and everything installed to /usr/local
19:48:14 <dansho> exporting a custom GHC_PACKAGE_PATH with both directories seems to have worked
20:06:17 <maralorn> Can someone explain me how cabal finds the packages installed by nix-shell. (It works perfectly, I’m just curious.)
20:13:59 <Chintan> So hey all, how does this freenode works. I am new to this and how do you ask for help?
20:15:14 <Axman6> Chintan: well, you are in the #haskell channel, a place for discussing the Haskell programming language. Is that what you would like help with?
20:16:12 <Chintan> Yeah. I am taking a Programming Language 
20:16:24 <Chintan> Translator course at university
20:16:44 <Chintan> And we are learning Haskell to build a compiler
20:17:54 <Axman6> Great! do you have any specific questions for us?
20:19:09 <Chintan> Not right now. I just started reading a learn you a haskell book. And the author talked about joining this channel.
20:24:05 <Axman6> well let us know if you get stuck with anything, there's plenty of people around to help
20:24:40 <Chintan> Cool. 
20:29:25 <jle`> monochrom: what do you think you would call that data type? would you call it a free monad?
20:34:14 <wrunt[m]> maralom: The nix expression in your shell.nix installs GHC with the packages you specify, and cabal knows how to find those packages. You can find them too using ghc-pkg from within your nix-shell. E.g. `ghc-pkg list`.
20:39:59 <Chintan> So I am confused between purely functional language. What does it mean to be a functional language here? I looked on stackoverflow, but they say that, in haskell, functions are first class? what doews that mean?
20:40:43 <koz_> Chintan: It means functions can be treated as any other kind of data: you can make new ones at runtime, store them in data structures, pass them as arguments, and return them from other functions.
20:41:06 <Axman6> it means you can pass function to other functions, and you can return them - functions are not special values like in some other languages
20:41:20 <Axman6> :t show
20:41:22 <lambdabot> Show a => a -> String
20:41:34 <Axman6> :t [show] -- A function inside a list
20:41:36 <lambdabot> Show a => [a -> String]
20:41:52 <Axman6> > map show [1,2,3] -- show is an argument to map
20:41:54 <lambdabot>  ["1","2","3"]
20:41:59 <EvanR> "purely" in purely function language is refering to "no side effects" rather than emphasizing the "functional"
20:42:02 <Axman6> > map (*10) [1,2,3] -- show is an argument to map
20:42:04 <lambdabot>  [10,20,30]
20:42:16 <Axman6> uh, ignore the comment on that last one =)
20:42:47 <EvanR> or perhaps purely functional language really is saying "take functions seriously, our functions act like functions in math class"
20:43:16 <Chintan> Got it thanks.
20:43:17 <iqubic> dminuoso: Are you around?
20:43:35 <EvanR> they map values in the domain to values in the range, they won't also send email or mutate global variables
20:44:15 <Axman6> show doesn't launch missiles or update a database, the types tell us this
20:44:42 <iqubic> :t unsafePerformIO
20:44:44 <lambdabot> error: Variable not in scope: unsafePerformIO
20:44:53 <iqubic> :t unsafePreformIO
20:44:53 <EvanR> oh hell no
20:44:54 <lambdabot> error: Variable not in scope: unsafePreformIO
20:45:10 <iqubic> % :t unsafePerformIO
20:45:10 <yahb> iqubic: IO a -> a
20:45:40 <EvanR> probably the worst thing to show someone on the first day :)
20:46:12 <maralorn> wrunt[m]: Thanks. "and cabal knows how to find those packages" I am curious about that magic. Is it an environment variable? Is it a well known directory compiled into GHC?
20:47:50 <iqubic> EvanR: I agree.
20:48:30 <Axman6> then don't do it iqubic
20:48:47 <iqubic> I didn't know it was his first day.
21:03:35 <rlin> does that type unsafePreformIO give that result because it applies the type function to unsafePreformIO
21:04:05 <rlin> like in reverse from how --:t usually works
21:05:09 <EvanR> :t [False,True]
21:05:10 <lambdabot> [Bool]
21:05:16 <EvanR> : \x -> x
21:05:19 <EvanR> :t \x -> x
21:05:21 <lambdabot> p -> p
21:05:33 <EvanR> it tells you the type of an expression
21:06:24 <EvanR> (these particular types might be a bit confusing at first... since they look very similar to the expression)
21:07:28 <wrunt[m]> maralorn: Looks like there is a GHC_PACKAGE_PATH environment variable, and some concept of package databases. See https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/packages.html
21:12:31 * hackage reanimate-svg 0.9.2.1 - SVG file loader and serializer  https://hackage.haskell.org/package/reanimate-svg-0.9.2.1 (DavidHimmelstrup)
21:17:48 <rlin> EvanR i know what :t does, im wondering how it interacts with unsafePreformIO, which doesnt really read as a function to me
21:17:59 <EvanR> it is a function
21:25:05 <Axman6> it's a function from IO a to a
21:25:15 <Axman6> oh they left
21:25:44 <EvanR> it's a function that is impossible, depending on what IO a means
21:32:00 * hackage fcm-client 0.2.0.0 - Admin API for Firebase Cloud Messaging  https://hackage.haskell.org/package/fcm-client-0.2.0.0 (shersh)
21:35:24 <jle`> it's a fake function but it still has a fake type signature
21:41:24 <Axman6> "This doesn't exist" "But I have it" "No"
21:45:18 <nshepperd> it may not exist but it's still good to know how it works
21:56:36 <test666> hello, is there a suitable way to traverse an AST which has Data instance defined for it's nodes
21:57:06 <Axman6> define "suitable"
21:57:41 <test666> like only writing transforms/folds for node types i am interested in
21:57:51 <test666> instead of recursively walking 
21:59:11 <test666> i am using language-javascript https://hackage.haskell.org/package/language-javascript-0.6.0.13/docs/Language-JavaScript-Parser.html#t:JSAST which has Data derived but not sure how i would use this 
21:59:46 <Axman6> there's some nice stuff in lens to do that IIRC
22:01:35 <jellostahps> Quick question, I am trying to convert this into guard form but I am having trouble with how to syntax the second guard. How do I syntax the second guard:
22:01:48 <jellostahps> invFac :: Int -> Int invFac x = if (product[1..x] <= x) then x else invFac (x-1)
22:01:58 <jellostahps> f
22:02:04 <jellostahps> sorry bad formatting let me fix that
22:02:12 <jellostahps> invFac :: Int -> Int invFac x = if (product[1..x] <= x) then x else invFac (x-1)
22:02:27 <jellostahps> nvm idk how to fix that ill post it somewhere else
22:03:01 <jellostahps> Okay here is the 2 line program:
22:03:09 <jellostahps> invFac :: Int -> Int
22:03:16 <jellostahps> invFac x = if (product[1..x] <= x) then x else invFac (x-1)
22:03:40 <jellostahps> How do I properly write the second guard of the second line (the recursion guard)
22:04:18 <iqubic> http://dpaste.com/1CYP4QQ
22:04:22 <Axman6> invFac x | product [1..x] <= x = x | otherwise = invFac (x-1)
22:04:37 <Axman6> not much shorter or clearer though
22:04:43 <iqubic> My past has the same thing, just formatted better.
22:04:59 <Axman6> differently*
22:05:09 <iqubic> But I'd prefer to write that in the if ... then ... else ... style
22:05:27 <jellostahps> thanks for the quick replies people
22:05:49 <iqubic> jellostahps: Prelude defines this:
22:05:55 <iqubic> otherwise :: Bool
22:06:02 <iqubic> otherwise = True
22:06:24 <iqubic> But most people prefer to use otherwise for readability's sake.
22:07:08 <jellostahps> The 'True part is a bit confusing'
22:07:17 <iqubic> Why?
22:07:37 <jellostahps> Why would Fctn(x-1) having a value True have anything to do with its recursion executing
22:07:46 <jellostahps> since otherwise = Fctn(x-1)
22:08:05 <EvanR> you're totally right
22:08:14 <iqubic> it doesn't does.
22:08:18 <EvanR> guard syntax is bonkers
22:08:38 <jellostahps> iqubic: huh?
22:08:43 <iqubic> Ignore me.
22:08:50 <iqubic> it's late and I can't think straight.
22:08:59 <EvanR> nonetheless that's what it looks like
22:09:17 <jellostahps> EvanR: What looks like what?
22:09:21 <iqubic> EvanR: Can you explain guard syntax? I'm too tired to do it.
22:09:29 <EvanR> what Axman6 posted
22:09:34 <Axman6>  invFac x | product [1..x] <= x = x | otherwise = invFac (x-1) is the same as  invFac x | product [1..x] <= x = x | True = invFac (x-1)
22:09:35 <iqubic> jellostahps: guard syntax looks like this: http://dpaste.com/1CYP4QQ
22:09:39 <jellostahps> yeah it worked out
22:10:01 <EvanR> by the same token product [1..x] <= x does not equal x
22:10:24 <iqubic> No. You can't compare a Bool to an Int.
22:10:36 <EvanR> the = is supposed to be a continuation of the equation for invFac x
22:10:41 <jellostahps> oh thats right, <= is a relational operator
22:11:18 <jellostahps> My question was answered thanks all
22:11:40 <EvanR> i wish we could put the guards all the way on the right
22:12:00 <EvanR> but then the ascii grid will devour our souls
22:12:17 <iqubic> \x y -> x <= y is a Bool. x is defined to be an Int by the function signature. You can't compare those for equallity in Haskell. Even if you could, = is not the check for equality operator in Haskell. It's == for that.
22:12:35 <EvanR> they aren't saying it checks for equality
22:12:49 <EvanR> they we saying that "them being equal" was confusing
22:13:03 <EvanR> because it is, because they aren't
22:13:16 <EvanR> even if the types made sense
22:13:56 <iqubic> <jellostahps>: Why would Fctn(x-1) having a value True have anything to do with its recursion executing?
22:14:09 <iqubic> That seems to imply a check for equality.
22:14:44 <iqubic> Or rather, imply that they thought the quards were checking for equality.
22:15:07 <Axman6> jellostahps has left...
22:15:17 <iqubic> I know.
22:15:33 <iqubic> I noticed that when ERC refused to tab complete the user name.
22:15:57 <iqubic> Time to learn about comonads and day convolution.
22:15:58 <iqubic> https://blog.functorial.com/posts/2016-08-07-Comonads-As-Spaces.html
22:16:03 <iqubic> https://blog.functorial.com/posts/2016-08-08-Comonad-And-Day-Convolution.html
22:16:10 <EvanR> i've been doing so much dependent types, i almost forgot about bool testing
22:16:21 <iqubic> Is Phil Freeman a good source to learn from?
22:16:42 <iqubic> EvanR: What do you do with dependent types?
22:17:10 <EvanR> drive myself insane mostly
22:17:37 <iqubic> What tasks are you trying to complete?
22:17:40 <EvanR> it has good support for this
22:17:50 <iqubic> I agree.
22:18:03 <EvanR> prove theorems
22:19:55 <iqubic> Stuff like this: (forall (n :: Nat) (m :: Nat). succ(n) > succ(m) ~ n > m)?
22:20:23 <iqubic> the ~ should be an implies operator.
22:20:56 <iqubic> ((forall (n :: Nat) (m :: Nat).) => succ(n) > succ(m) -> n > m)
22:21:03 <iqubic> Something more like that.
22:21:09 <EvanR> S m < S n -> m < n
22:21:13 <EvanR> agreed
22:21:56 <iqubic> But can prove that to GHC?
22:22:03 <EvanR> probably
22:22:27 <heatsink> You can't exactly prove things using functions in GHC because functions are partial
22:22:45 <heatsink> a -> b could fail to return
22:23:06 <heatsink> Rather, a function could fail to return, which lets you "prove" forall a b, a -> b
22:23:15 <EvanR> still iqubic's constraint would be nice to have
22:24:02 <iqubic> How hard is it to prove this: if (Succ n ~ Succ m) then (n ~ m)?
22:24:29 <heatsink> GHC has builtin knowledge that that's true for type constructors
22:24:34 <iqubic> Cool.
22:24:36 <slack1256> That depends on how difficult is to prove via induction with GHC
22:24:40 <EvanR> injectivity of type constructors
22:24:59 <EvanR> and value constructors for that matter
22:25:01 <iqubic> data Nat where
22:25:13 <iqubic> Z :: Nat
22:25:21 <iqubic> Succ :: Nat -> Nat
22:25:53 <iqubic> Would that be good enough to teach GHC that "if (Succ n ~ Succ m) then (n ~ m)?"
22:27:05 <iqubic> Well, what I wrote is a data type with values, so you'd compare them with ==.
22:27:22 <iqubic> But I think you understand the point I'm driving at.
22:29:23 <heatsink> Although constraints aren't first-class values in Haskell, you can capture them in data constructors
22:29:45 <heatsink> data Cst c where Cst :: c => Cst c
22:29:48 <iqubic> I know. ConstraintKinds are quite cool.
22:30:13 <heatsink> I think you could write a function with type Cst (Succ n ~ Succ m) -> Cst (n ~ m)
22:31:03 <iqubic> Yes. I believe so.
22:34:21 <jle`> GHC should already be able to infer n ~ m from 'Succ n ~ 'Succ m I believe
22:34:34 <jle`> for that type
22:34:57 <jle`> just like how it can infer a ~ b from Maybe a ~ Maybe b
22:39:40 <Axman6> assuming Succ isn't a type family
22:40:51 <jle`> just referring to the specific type posted earlier, yeah. if it's a type family that isn't injective then good luck
22:41:31 <iqubic> What does the word "injective" mean when refering to type families?
22:42:24 <slack1256> Exactly the same as in real mathematics
22:42:47 <EvanR> f x = f y -> x = y
22:42:48 <iqubic> I don't know what it means in real mathematics.
22:42:56 <Axman6> I wonder if Google does
22:42:58 <slack1256> forall (f :: A -> B), (f(a) == f(b)) => (a == b)
22:43:01 <Axman6> @google injective
22:43:02 <lambdabot> https://en.wikipedia.org/wiki/Injective_function
22:43:13 <iqubic> How do you make a non-injective type family in haskell?
22:43:34 <slack1256> iqubic: map two different arguments to the same result
22:43:43 <EvanR> I can tell you thought about that question a long time before you asked it :)
22:43:43 <iqubic> How would you do that?
22:43:54 <heatsink> slack1256, I think you mean forall a b :: A, f(a) == f(b) -> a == b
22:44:26 <slack1256> ^ right
22:44:35 <iqubic> EvanR: Sure did, if you consider 30 seconds a long time.
22:44:54 <EvanR> you pick whatever you want for the cases of a type family
22:45:11 <EvanR> if they collide, no injectivity for you
22:45:19 <iqubic> F Int = Char
22:45:31 <iqubic> F Bool = Char
22:45:39 <Axman6> F
22:45:43 <EvanR> now F can't be reversed
22:45:53 <iqubic> Yeah. That's no longer injective.
22:46:29 <nshepperd> the question is really how you make an injective type family
22:46:31 <slack1256> type familiy NonId (a :: Type) :: Type where { NonId Int = () ; NonId a = a }
22:46:48 <EvanR> first of all, you'd have to have a closed type family
22:46:59 <nshepperd> and the answer is by adding an injectivity annotation, which is basically fundeps for type families
22:47:00 <EvanR> beyond that, no idea
22:48:15 <dminuoso> iqubic: yes.
22:50:08 <nshepperd> i think the syntax is something like 'type family F (a :: *) = (b :: *) | b -> a'
22:50:30 <nshepperd> then ghc enforces that you can't write both 'F Int = Char' and 'F Bool = Char'
22:51:08 <slack1256> Those fundep on type families, are valid only on closed type families?
22:51:10 <iqubic> dminuoso: I completed the Pretext Comonad and ComonadStore instances.
22:51:15 <iqubic> https://gist.github.com/IQubic/5c4c62f99dbf10cc9be41a1e8ccfa055
22:52:11 <nshepperd> slack1256: no, they're valid on open ones too
22:53:46 <slack1256> Now I am thinking on the order GHC see open type family instances, the effect on injectivity and how code that worked well doesn't now we imported an extra module...
22:54:14 <dminuoso> iqubic: Okay so there's some oddnesses. Your duplicate looks wrong at first glance.
22:54:34 <iqubic> Oh?
22:54:43 <iqubic> It type checks though.
22:55:35 <iqubic> I'm not sure why my duplicate is wrong though.
22:55:43 <nshepperd> slack1256: well, it's kinda the same as a type class. you have no issues as long as you don't have orphan instances
22:58:26 <iqubic> dminuoso: I'm not sure how I should change duplicate, or why it is wrong.
22:59:19 <dminuoso> iqubic: Let's first change the name of createWith to the canonical name "store"
22:59:27 <iqubic> Sure.
23:00:04 <iqubic> I'm not sure I need both store and storeWith.
23:00:11 <dminuoso> iqubic: Secondly while I look at this, modify pretextToStore to use experiment rather than seek.
23:00:35 <iqubic> Sure.
23:01:24 <dminuoso> iqubic: And equivalently the same with storeToPretext - the idea is to focus on using this experiment interface. :)
23:01:40 <iqubic> Also, I don't use seek. I use peek and pos.
23:01:53 <dminuoso> iqubic: My err yeah. Instead of those.
23:02:43 <iqubic> So rewrite both storeToPretext, and pretextToStore to use experiment?
23:02:46 <dminuoso> iqubic: Yes.
23:03:18 <dminuoso> iqubic: The storeToPretext should be utterly trivialy if you recall what I have been repeating over and over.
23:03:35 <dminuoso> (Hint, dont even pattern match on the Store)
23:04:05 <iqubic> WHAT?!?!
23:04:26 <iqubic> storeToPretext g = experiment _ _
23:04:38 <iqubic> With some newtype wrapping and unwrapping as needed.
23:05:06 <iqubic> But how do I do that without pattern matching on the Store?
23:05:28 <dminuoso> iqubic: Do you recall what I have been repeating like a mantra about "Pretext is just.."
23:05:54 <iqubic> Oh. I see.
23:08:32 <dminuoso> iqubic: Oh and ignore my earlier note about "createWith" should be called store, I was confusing Pretext with Store for a moment, heh. :)
23:08:49 <iqubic> http://dpaste.com/1EE1ZWJ
23:08:54 <iqubic> Oh.
23:09:12 <iqubic> I should rename the createWith function.
23:09:22 <iqubic> I'm not sure what to.
23:09:29 <iqubic> I renamed it to store.
23:09:38 <iqubic> But that might not be right.
23:11:37 <iqubic> but that isomorphism looks a lot simpler now.
23:12:14 <dminuoso> iqubic: Well both functions dont look right.. :)
23:12:32 <dminuoso> (Or the pretextToStore might, depending on the order of the arguments to Store.
23:12:45 <iqubic> What order should I use?
23:13:14 <iqubic> what order of arguments would you like me to use?
23:13:37 <dminuoso> iqubic: It doesnt matter. If that function type checks, then its right. But your storeToPretext suggests you havent run the typechecker yet.
23:15:13 <iqubic> Here's my full source file.
23:15:14 <iqubic> http://dpaste.com/3JQDD6R
23:15:40 <iqubic> And I have run the type checker on this file. The whole thing typecheks.
23:15:58 <dminuoso> iqubic: Ahh I see now. Okay so you wouldn't write such a function pretext.
23:16:11 <dminuoso> iqubic: storeToPretext s = Pretext (`experiment` s)
23:16:20 <dminuoso> Pretext is just experiment partially applied to store.
23:16:22 <dminuoso> :-)
23:16:37 <dminuoso> iqubic: But your duplicate actually looks correct, its just an unusual way to write it I guess.
23:16:59 <dminuoso> The conventional way is to have: sell :: a -> Pretext a a; Pretext a = Pretext ($ a)
23:17:01 <iqubic> Ah.
23:17:09 <iqubic> I'll do that.
23:17:14 <dminuoso> iqubic: Try and figure out how to write duplicate using that.
23:17:53 <iqubic> Let me rewrite all my functions using se.
23:18:08 <iqubic> sell :: a -> Pretext a a; Pretext a = Pretext ($ a)
23:18:20 <iqubic> The second Pretext should be sell.
23:18:45 <iqubic> Or something. It doesn't quite look right.
23:21:34 <dminuoso> iqubic: By the way, feel free to dig up these lens excercises you did a while ago, and compare them to Pretext. :-)
23:21:47 <dminuoso> You'll notice that you have already used this interface before.
23:21:59 <iqubic> I will.
23:22:05 <iqubic> duplicate = getCompose . experiment (Compose . _)
23:22:31 <iqubic> I have a whole of type "s -> Pretext s (Pretext s s)"
23:23:58 <iqubic> Here's the lens exercise I did before: http://dpaste.com/2FV7VMQ
23:25:22 <iqubic> I don't see the relationship quite yet.
23:25:49 <dminuoso> iqubic: By the way, for symmetry you could rewrite `peek s = runIdentity . experiment (Identity . const s)` which emphasises this "and at least wrap this into some functor" bit more :)
23:26:12 <dminuoso> iqubic: Take a look at traverseZ, which is really some kind of _3 type of lens.
23:27:15 <dminuoso> *at last wrap this
23:27:31 <iqubic> traverseZ :: (Functor f) => (a -> f a) -> V3 a -> f (V3 a)
23:27:35 <iqubic> or
23:27:59 <iqubic> Yes.
23:28:02 <iqubic> I see it.
23:28:37 <iqubic> But I don't see how that relates to Pretexts.
23:29:17 <iqubic> Also, I still can't seem to write duplicat with sell.
23:29:51 <iqubic> duplicate = getCompose . experiment (Compose . _)
23:30:09 <dminuoso> iqubic: The tricky is to understand how the Pretext encoding works.
23:30:14 <dminuoso> iqubic: And remember that you just have a Store in your hand.
23:30:23 <dminuoso> It's just Store. Think about what the duplicate instance would do with just store.
23:30:33 <dminuoso> And then try and translate that into the Pretext encoding.
23:30:35 <iqubic> I have a hole of type 's -> Pretext s (Pretext s s)'
23:31:11 <brisad> Hi, I'm doing https://www.cis.upenn.edu/~cis194/spring13/lectures.html on my spare time in order to learn Haskell. And now I got stuck on Exercise 3 part 3 (the optional one) in https://www.cis.upenn.edu/~cis194/spring13/hw/04-higher-order.pdf It wants me to implement foldl using foldr. I'm stuck on that one, and wonder if someone could give me a small hint to nudge me in the right direction? :)
23:31:22 <dminuoso> iqubic: so the connection is very simple
23:31:26 <dminuoso> iqubic: (wrt to lenses)
23:31:42 <dminuoso> iqubic: Ever heard that fancy joke about "lenses are just coalgebras for the costate comonad"?
23:31:45 <iqubic> Is this right: "duplicate (Store g s) = Store (Store g) s"
23:31:53 <iqubic> dminuoso: No. Never.
23:32:03 <brisad> I really don't see how I can reverse the function application, when I'm just being given the accumulator and the current value "from the wrong direction"
23:32:12 <dminuoso> iqubic: Well you have now. Edward has been telling it, not sure whether it was originally by him.
23:32:32 <iqubic> Also, I didn't have an implementation of duplicate for a Store instance, so I wrote it myself.
23:32:35 <iqubic> Is that right?
23:32:48 <dminuoso> iqubic: I meant, think about what Store does operationally in the duplicate instance.
23:33:00 <dminuoso> iqubic: A Store is just a container with the notion of "current positoin"
23:33:29 <iqubic> Right.
23:34:09 <iqubic> To duplicate, you just leave the current position alone.
23:34:56 <dminuoso> So what does `duplicate :: Store s a -> Store s (Store s a)` do exactly?
23:35:35 <dminuoso> That's not enough.
23:35:35 <dminuoso> That would violate comonad laws.
23:36:00 <dminuoso> Essentially duplicate takes a container, and it replaces every element with the entire original container but zoomed to the location of the element we are replacing.
23:36:16 <iqubic> Sure. That makes sense.
23:36:28 <dminuoso> Which gives us some sort of coherence laws. Such that if we duplicate, and then read out each nested container at their current position, we get the original container back
23:36:37 <iqubic> Makes sense.
23:36:51 <iqubic> duplicate . extract = id
23:36:59 <dminuoso> Right
23:37:48 <iqubic> So what are we going to do to duplicate a Pretext?
23:38:34 <iqubic> I'm going to be using Compose as my functor, because that makes the most sense.
23:39:31 <dminuoso> iqubic: Think about what sell does
23:39:50 <dminuoso> (And remember that `Pretext s a` is just `Store s a` semantically)
23:44:41 <iqubic> I'm back.
23:44:45 <iqubic> Still no idea what I need to do here.
23:50:17 <iqubic> dminuoso: Now with sell.
23:50:18 <iqubic> http://dpaste.com/02ZGQVZ
23:52:49 <iqubic> dminuoso: Does that look right?
23:56:08 <iqubic> dminuoso: More complete code: http://dpaste.com/1CZK5Y2
