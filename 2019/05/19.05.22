00:36:58 <unsymbol> just got this from stack: base-4.10.1.0 from stack configuration does not match (>=2 && <6) && <0
00:37:38 <unsymbol> does this mean it expects base to be greater or equal to 2 and less than 6 AND less than 0?
00:38:13 <Axman6> can you share the text around that line?
00:38:28 <Axman6> usually that happens when someone's intentionally made a package not work
00:40:01 <unsymbol> Axman6: i thought that might've been the case. here's the surrounding text: https://pastebin.com/CUs0Ybzc
00:42:07 <merijn> hvr published a revision that did that, so presumably something was broken with transformers 0.5.5.0
00:42:26 <unsymbol> ah, yes, i can see it. http://hackage.haskell.org/package/transformers-0.5.5.0/revisions/
00:43:25 <unsymbol> it would be much less grumpy if this wasn't one of the last packages i was building on a raspberry pi XD
00:45:33 <Axman6> :'(
00:46:09 <merijn> Looks like that was to work around breakage due to MonadFail
00:47:00 <cocreature> disabling the build completely seems a bit cruel. Surely it wasn’t broken on all versions was it?
00:48:30 <merijn> cocreature: I'm extrapolated from closed issues, there's no real note
00:48:44 <merijn> Which is actually kinda annoying, we should probably have a motivation field for revisions
00:49:29 <unsymbol> annoyingly i was rebuilding a docker base image with all the packages i needed pre-installed, which previously used that version without issue. having it yanked like that with no additional information is pretty frustrating.
00:50:18 <merijn> unsymbol: I'm a bit confused why you're affected, though. If you're using stack why do you even noticed the revision? I think it should only affect the cabal-install solver
00:52:50 <unsymbol> i'm doing an explicit `stack -j4 install transformers-0.5.5.0`. would you expect it to behave as above?
00:53:40 <merijn> I wouldn't expect anything, as I don't use stack :)
00:53:52 <unsymbol> expect the unexpected
00:53:56 <unsymbol> XD
00:54:05 <merijn> Although I've eavesdropped enough stack conversations to know that "stack install" is generally not recommended
00:54:17 <merijn> At least for libraries
00:54:40 <merijn> Which leads to the question: Why are you trying to stack install a specific version of transformers?
00:56:08 <unsymbol> typically i wouldn't do this but it's a bit of a constraint i imposed to make building on the rpi easier. though, if there's another way to achieve it, i'd be interested to know. here goes...
00:56:40 * sm uses stack install all the time
00:58:18 <unsymbol> if i stack install in the project directory, building on the rpi will sometimes fail or hang (it's unclear to me why). this is especially problematic when building a docker image because it'll have to start from scratch every time. so what i did was split all the packages into different layers, so it doesn't have to start from scratch if it fails.
00:58:42 <sm> I seem to remember stack can be affected by revisions, eg there's a @rev:N syntax after version numbers, and in stackage some packages are configured to ignore revisions
00:59:24 <unsymbol> sm: don't suppose you know if there's a way to tell stack to explicitly ignore revisions?
00:59:31 <sm> unsymbol: hang probably means you've useed too much memory, quite likely on a pi
00:59:38 <sm> there are techniques for using less
01:00:16 <sm> unsymbol: maybe stack -j4 install transformers-0.5.5.0@rev:0 ?
01:00:50 <delYsid``> unsymbol: rpi's can be unreliable when used with high load, at least that is my experience.  They are just not very good at being used as build hosts.
01:01:11 <unsymbol> sm: thanks, i'll give that a try.
01:02:15 <merijn> tbh, my solution to this issue would just be to get an ARM VPS for a few bucks, build the code on the VPS, then copy the results to the RPi, rather than attempting to build on the RPi
01:02:48 <merijn> I mean, a VPS goes for like a handful of bugs a month, so running one for a day to build an executable will cost you literal cents
01:02:50 <sm> also, I wouldn't use -j4 on a pi
01:02:51 <zincy_> I am not sure whether I want quickcheck or smallcheck for testing my program :/
01:03:29 <zincy_> When do you decide if you need your generated test cases to be at a smaller depth and therefore more exhaustive?
01:03:57 <unsymbol> merijn: yes, that's something i looked into. unfortunately, when i started this project, the iot platform i looked into restricted me to 32bit, which no sufficiently arm cloud provider supports. scaleway have cpus which support 32bit but they are less performant that rpis.
01:04:20 <unsymbol> thankfully this provider recently added 64bit support, so it's something i'm going to revisit.
01:04:42 <unsymbol> * sufficiently performant
01:46:54 <quchen> phadej: Why did you name that macro »NO_FAIL_IN_MONAD_MONAD_FAIL«? Does base 4.13 remove fail from Monad? I’m a bit out of the loop :-s
01:48:04 <quchen> phadej: My horizon stops at »no return ain’t gonna happen« two years ago
01:48:47 <Taneb> quchen: yes, that's what's happened. In GHC 8.8 Monad will not have a fail method
01:48:56 <quchen> Oh wow.
01:48:59 <merijn> Whoo!
01:49:06 <quchen> I did not expect that to happen.
01:49:08 <Taneb> Source: https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail
01:49:11 <merijn> Then I can't accidentally forget to enable MonadFailDesugaring
01:49:17 <quchen> Taneb: I know that proposal, I wrote it.
01:49:23 <quchen> :-)
01:49:30 <Taneb> quchen: it has a timeline at the bottom
01:49:48 <quchen> OOohh. I wrote that too, but it was full of wishful thinking back then :-D
01:50:12 <merijn> quchen: ;)
01:50:28 <quchen> Did hvr push the sudo button or something?
01:53:21 <Taneb> quchen: wishfull thinking can be fantastically powerful if no-one has a strong argument against
01:54:32 <quchen> Oh I remember the discussions. People were *passionate* against this.
02:12:26 <merijn> unsymbol: Here's the reason for your issue: https://github.com/haskell-infra/hackage-trustees/issues/209
02:14:09 <unsymbol> merijn: thanks so much for going to the bother of finding that.
02:15:54 <merijn> unsymbol: I didn't, I just got the link from the person that made the revision :p
02:18:34 <unsymbol> ok, i take it all back then :P
02:47:50 <absence> with [Either e a] i can do something like filter isRight or takeWhile isRight, but then i get stuck with an unsatisfying fmap (fromRight (error "this shouldn't happen")). is there a concept that combines filtering and mapping in a way that avoids this scenario?
02:48:28 <merijn> :t rights -- ?
02:48:30 <lambdabot> [Either a b] -> [b]
02:48:44 <lavalike> :t \xs -> [ x | x@(Right _) <- xs ]
02:48:44 <merijn> And, correspondingly,
02:48:46 <lambdabot> [Either a b] -> [Either a b]
02:48:48 <merijn> :t lefts
02:48:49 <lambdabot> [Either a b] -> [a]
02:51:27 <absence> merijn: looking for something more general. what if it's another sum type than Either, etc
02:51:56 <merijn> Then lavalike's example with a little modification
02:52:07 <merijn> :t \xs -> [x | Right x <- xs]
02:52:09 <lambdabot> [Either a1 a2] -> [a2]
02:52:28 <merijn> > [x | Right x <- [Left 1, Right True, Left 2, Right False, Left 3]]
02:52:31 <lambdabot>  [True,False]
02:52:32 <lavalike> neither filter nor takeWhile extract values from the items tho
02:52:48 <merijn> lavalike: He mentioned "fmap fromRight" afterwards, though :)
02:53:15 <dminuoso> :t \xs -> [ x | x@(Right _) <- xs ]
02:53:16 <lambdabot> [Either a b] -> [Either a b]
02:53:22 <dminuoso> Is how I'd do it too :)
02:53:31 <merijn> dminuoso: That does something very different, though
02:53:37 <Solonarv> "filter but you can extract a value" is mapMaybe
02:53:40 <dminuoso> Oh
02:53:49 <absence> what if it's a Tree, not a list
02:54:09 <merijn> absence: Do you want it to stay a Tree?
02:54:14 <Solonarv> well you first need to define what it means to keep only parts of the tree
02:54:23 <Solonarv> you can do this by writing a mapMaybe for it
02:54:33 <merijn> Sounds like Selective Functor or Witherable
02:55:20 <absence> hmm witherable sounds interesting
02:55:27 <Solonarv> only Filterable is needed, that's where fmapMaybe is; Witherable gives you traverseMaybe or mapMaybeM (though the actual name is different IIRC)
02:55:30 <Solonarv> same package though
02:59:21 <absence> i'll poke around with selective and witherable to see if i can get a better idea of what i actually need. i know it's not exactly list of either, but more the idea of container with sum types. thanks!
04:03:37 <J_Arcane> I am trying to parse a JSON field where the value is a number but it's given wrapped as a string (ie. "1970"). How can I get Aeson to try to parse that string as an Int instead of a String?
04:06:32 <hvr> J_Arcane: what I sometimes do for that is to define myself a `newtype StringyInt = StringInt Int` and define the appropriate FromJSON instance for it
04:08:02 <zincy_> J_Arcane: Are you handwriting your FromJSON instance?
04:08:27 <zincy_> J_Arcan: Remember you can derive it automatically even though being able to handwrite it is a good thing to know indeed
04:08:43 <J_Arcane> Yes. I have to already do some manipulation to nap a much larger payload to a smaller type
04:09:02 <zincy_> Fair enough
04:17:55 <fendor> how can I change the import line in `stack ghci`? I dont want to see every module that is in my project...
04:18:50 <Solonarv> fendor: :set prompt-function <stuff>
04:18:58 <fendor> thanks
04:19:28 <fendor> i suppose the same works for cabal new-repl?
04:20:36 <Solonarv> yes, it's just something you enter into ghci
04:20:38 <georg> Hello, if I'd like to chain foo :: State Type1 Int and bar :: State Type1 String, do I have to use StateT in some way? I'd like to use it in the following fashion: runState ( bar =<< foo ), but the two types are incompatible. Thanks!
04:21:11 <merijn> georg: You just need >>
04:21:31 <Solonarv> fendor: here's mine:
04:21:31 <Solonarv> :set prompt "\ESC[1;34m%s\n\ESC[0;34mλ> \ESC[m"
04:21:31 <Solonarv> :set prompt-cont "\ESC[0;34mλ| \ESC[m"
04:21:36 <merijn> georg: Your problem is that >>= and =<< expect a function
04:21:51 <merijn> georg: And bar is not a function
04:22:10 <Solonarv> fendor: that's in ~/.ghci
04:22:27 <merijn> :t (>>=) `asAppliedTo` (undefined :: State Bool Int)
04:22:28 <lambdabot> StateT Bool Identity Int -> (Int -> StateT Bool Identity b) -> StateT Bool Identity b
04:22:33 <merijn> :t (>>) `asAppliedTo` (undefined :: State Bool Int)
04:22:34 <fendor> Solonarv, stack and cabal repls honour this config?
04:22:35 <lambdabot> StateT Bool Identity Int -> StateT Bool Identity b -> StateT Bool Identity b
04:22:36 <Solonarv> so no matter how I start ghci (stack, cabal, standalone, whatever) it will pick that up
04:23:25 <fendor> Solonarv, that is really pretty, thanks!
04:23:50 <Solonarv> yeah!
04:24:03 <Solonarv> you can change the colors by tweaking the escape codes
04:24:12 <Solonarv> but I don't know how, I just copy-pasted this from somewhere
04:24:34 <fendor> good enough for me, since the blue fits nicely with my theme
04:24:36 <merijn> Solonarv: Those are just ansi escape codes for terminals
04:24:45 <Solonarv> yeah, but I don't know those :>
04:26:35 <georg> merijn: you're right, silly me ... thanks!
04:40:01 <absence> does stuff like "Either Void a -> a" live somewhere in a common library?
04:40:28 <merijn> absence: "either absurd id"
04:40:57 <merijn> :t either absurd id
04:40:58 <lambdabot> Either Void c -> c
04:42:26 <fendor> :t either
04:42:27 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
04:42:35 <int-e> :t maybe () absurd
04:42:35 <fendor> :t absurd
04:42:36 <lambdabot> Maybe Void -> ()
04:42:37 <lambdabot> Void -> a
04:45:00 <absence> merijn: already had the local implementation, just wanted to check if there was a common place for it. guess it's too small. thanks!
05:03:54 <dminuoso> absence: absurd is a lovely function, it found a nice spot after some `blockForever :: Server -> IOL (Either SomeException Void)`
05:04:01 <dminuoso> =)
05:04:50 <opqdonut> nice
05:05:05 <Solonarv> I've used 'Async Void' a while ago
05:05:18 <Solonarv> can't remember if I bothered to use 'absurd' though
05:06:04 <dminuoso> absence: Curious, how did you implement absurd?
05:08:00 <opqdonut> heh if you enable LambdaCase and EmptyCase, you can use `\case` instead of `absurd`, which is one character shorter :)
05:08:12 <opqdonut> :t \case `asTypeOf` absurd
05:08:13 <lambdabot> Void -> p
05:08:26 <Solonarv> in this case you can just write: '\(Right x) -> x' instead of 'absurd either id'
05:08:39 <opqdonut> but then you'll get a warning :(
05:08:40 <Solonarv> (and this *isn't* an incomplete pattern error)
05:08:47 <dminuoso> Solonarv: That triggers incomplete match diagnostics.
05:08:58 <Solonarv> it does? huh, doesn't seem right
05:09:12 <dminuoso> Solonarv: Im pretty sure that's the point of EmptyCase.
05:09:14 <hpc> because (Left _) is still a valid match
05:09:28 <Solonarv> ah, right
05:09:38 <Solonarv> if the field were strict it would work I suppose
05:09:47 <int-e> Solonarv: well, Left undefined is different from undefined.
05:09:49 <hpc> :t absurd \case id
05:09:50 <hpc> er
05:09:50 <int-e> yeah
05:09:51 <lambdabot> error: parse error on input ‘\’
05:09:55 <hpc> :t either \case id
05:09:56 <lambdabot> error: parse error on input ‘\’
05:10:02 <dminuoso> :t either (\case) id
05:10:04 <lambdabot> Either a c -> c
05:10:09 <Solonarv> int-e: yeah, it wouldn't be different if the field were strict though
05:10:25 <Solonarv> % :t either \case{} id
05:10:25 <yahb> Solonarv: ; <interactive>:1:8: error:; Unexpected lambda-case expression in function application:; \case; You could write it with parentheses; Or perhaps you meant to enable BlockArguments?
05:10:26 <hpc> not quite as short in practice ;)
05:10:33 <Solonarv> % :set -XBlockArguments
05:10:33 <yahb> Solonarv: 
05:10:38 <Solonarv> % :t either \case{} id
05:10:38 <yahb> Solonarv: forall {a} {c}. Either a c -> c
05:10:39 <opqdonut> hpc: fair enough
05:11:00 <hpc> still pretty neat
05:11:21 <dminuoso> Solonarv: Ryan held a talk in Munich last year about the whole topic. Its pretty complicated.
05:11:55 <Solonarv> dminuoso: I just had a brain fart and forgot that Left ⊥ ≠ ⊥
05:12:25 <Solonarv> % data SEither a b = SL !a | SR !b deriving (Show, Eq, Ord)
05:12:26 <yahb> Solonarv: 
05:13:18 <Solonarv> % :set -Wincomplete-patterns
05:13:19 <yahb> Solonarv: 
05:13:44 <opqdonut> I would've guessed the incomplete patter checker isn't smart enough to handle a nested Void
05:14:34 <Solonarv> % foo :: SEither Void a -> a; foo (Right a) = a
05:14:34 <yahb> Solonarv: ; <interactive>:146:34: error:; * Couldn't match expected type `SEither Void a' with actual type `Either a0 a'; * In the pattern: Right a; In an equation for `foo': foo (Right a) = a; * Relevant bindings include foo :: SEither Void a -> a (bound at <interactive>:146:29)
05:14:40 <Solonarv> % foo :: SEither Void a -> a; foo (SR a) = a
05:14:41 <yahb> Solonarv: ; <interactive>:147:29: warning: [-Wincomplete-patterns]; Pattern match(es) are non-exhaustive; In an equation for `foo': Patterns not matched: (SL _)
05:14:45 <Solonarv> aww :/
05:14:52 <opqdonut> yeah, it just checks that you handle all cases of the data definition
05:15:01 <opqdonut> it doesn't try to prove which cases are inhabited
05:15:29 <dminuoso> :t (\case)
05:15:31 <lambdabot> p1 -> p2
05:15:46 <dminuoso> Oh yeah. Coercion time.
05:15:50 <opqdonut> :)
05:15:55 <Solonarv> well, it does, but it's conservative and doesn't look at whether the field types are inhabited
05:15:58 <absence> dminuoso: oh, i didn't implement absurd itself, i just had "either absurd id" in my code and wondered if it existed with a common name somewhere :)
05:16:04 <Solonarv> dminuoso: that's just bottom every time
05:17:07 <Solonarv> (\case) is more or less the same as (\x -> x `pseq` undefined)
05:17:29 <Solonarv> (pseq works like seq but guarantees that the first argument is evaluated first)
05:18:03 <dminuoso> Solonarv: Amusingly seq is the same in GHC too, otherwise things like foldl' couldn't work:p
05:18:16 <Solonarv> dminuoso: it makes no guarantees though
05:18:53 <Solonarv> GHC is free to reorder evaluation involving seq and I'd be surprised to learn that that never happens
05:20:07 <dminuoso> Solonarv: https://mail.haskell.org/pipermail/glasgow-haskell-users/2006-November/011480.html
05:21:33 <Solonarv> dminuoso: that was pretty much my understanding
05:22:07 <dminuoso> Solonarv: How do bangs desugar?
05:22:23 <Solonarv> to uses of seq, IIRC
05:22:26 <dminuoso> Solonarv: https://hackage.haskell.org/package/base-4.11.1.0/docs/src/Data.Foldable.html#foldl%27 :-)
05:23:35 <Solonarv> ⟦f !a = <body>⟧ ⇒ f a = a `seq` <body>
05:24:05 <absence> :t fmap swap . sequenceA . swap -- is there a clever way to shorten this?
05:24:06 <lambdabot> Applicative f => (f b, a) -> f (b, a)
05:24:15 <dminuoso> Solonarv: My point is: foldl' is implemented using bangs, which in turn produce seq. So GHC cant reorder seq without surprising a lot of people.
05:25:01 <Solonarv> dminuoso: yes indeed, as mentioned in the email you linked. I'm aware of that. In the case of foldl' it is better to evaluate the left argument first
05:25:24 <dminuoso> Solonarv: Well you said you'd be surprised to learn that that never happens..
05:25:50 <dminuoso> But perhaps Im wrong, and GHC does do this. But it seems unlikely to me, seeing as how liberal GHC makes use of bangs/seq.
05:26:14 <dminuoso> % strength a fb = fmap ((,) a) fb
05:26:15 <yahb> dminuoso: 
05:26:18 <dminuoso> % :t curry strength
05:26:18 <yahb> dminuoso: forall {f :: * -> *} {a} {b1} {b2}. Functor f => a -> b1 -> f b2 -> f ((a, b1), b2)
05:26:23 <int-e> otoh, ghc has `pseq` for a reason
05:26:30 <Solonarv> *never* is a strong word
05:26:37 <dminuoso> int-e: Why doesnt ghc use pseq itself then?
05:26:47 <int-e> because bottoms are bottoms?
05:26:51 <tty1> If i have a simple enumeration how do I make it hashable, for example: data Direction = In | Out | Both | None 
05:27:02 <dminuoso> % uncurry strength
05:27:02 <yahb> dminuoso: ; <interactive>:150:1: error:; * No instance for (Show ((a0, f0 b0) -> f0 (a0, b0))) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
05:27:06 <dminuoso> % :t uncurry strength
05:27:06 <yahb> dminuoso: forall {f :: * -> *} {a} {b}. Functor f => (a, f b) -> f (a, b)
05:27:10 <dminuoso> absence: ^-
05:27:14 <Solonarv> perhaps sometimes it's better to evaluate the right argument first; the fact that the spec doesn't mandate anything means GHC can actually do that in those cases
05:27:18 <int-e> I seem to recall that the Haskell report gives compilers the liberty to return any bottom they like.
05:27:32 <merijn> int-e: No, just any of the possible ones
05:27:42 <Solonarv> tty1: add 'deriving (Generic)' to the declaration, and write 'instance Hashable Direction' somewhere
05:27:43 <int-e> hmm close enough :)
05:28:10 <merijn> int-e: So if an expression can throw 3 different exception, the compiler can choose an arbitrary one of the 3, but not one that doesn't occur in the code at all
05:28:12 <tty1> Solonarv: ahh i tried derriving straight from Hashable, thanks
05:28:39 <dminuoso> absence: And if you want the other parameter order, it would of course be:
05:28:44 <dminuoso> % :t uncurry (flip strength)
05:28:44 <yahb> dminuoso: forall {f :: * -> *} {b} {a}. Functor f => (f b, a) -> f (a, b)
05:28:50 <merijn> int-e: Actually, that's the Semantics of Imprecise Exceptions, not sure how much of that is in the report directly
05:29:02 <Solonarv> tty1: to write 'deriving' for non-builtin classes you need one of the fancy deriving strategies - in this case, DeriveAnyClass
05:29:11 <Solonarv> which just generates an empty instance declaration
05:29:12 <tty1> Solonarv: generic isnt in scope, do i need to import something?
05:29:19 <Solonarv> tty1: yes, from GHC.Generics
05:30:35 <tty1> Solonarv: after import still gives an error says i need "DeriveGeneric" whatever that means
05:30:43 <Solonarv> that's a language extension
05:31:02 <tty1> ohhh
05:31:09 <Solonarv> to enable FooExtension you add a {-# LANGUAGE FooExtension #-} line to the top of your source file
05:31:16 <int-e> merijn: I'm not in the mood to reread the whole thing, but it does say: "", which I think cuts both ways.
05:31:25 <Solonarv> (*above* the 'module Foo where...' line)
05:31:25 <int-e> "Errors in Haskell are semantically equivalent to ⊥ (“bottom”)."
05:31:31 <tty1> Solonarv: woot compiles now, thanks
05:31:33 <absence> dminuoso: nice, which package is that?
05:31:51 <Solonarv> %% :i strength
05:31:51 <yahb> Solonarv: http://qp.mniip.com/y/11
05:31:54 <int-e> (Why does firefox have to add spurious newlines when pasting from the beginning of a paragraph... grr.)
05:32:31 <merijn> bleh...I hate having to inline definitions from libraries because they're not sufficiently flexible as-is :\
05:33:22 <int-e> merijn: But I guess the report is pretty useless for this discussion anyway because it doesn't specify much about the semantics in the first place.
05:34:06 <merijn> int-e: Yeah, I don't think the report allows distinguishing bottoms (thus exceptions) at all
05:34:14 <merijn> Which would of course render them rather useless
05:34:59 <merijn> The paper introduces the notion of distinguishing them, but is careful to not specify an evaluation order, which is why they're imprecise exceptions and it can throw any of a set of exceptions
05:35:22 <absence> Solonarv: "defined at <interactive>"?
05:36:09 <Solonarv> absence: <interactive> means it was defined directly in ghci
05:36:43 <Solonarv> and indeed: 14:25:54 <dminuoso> % strength a fb = fmap ((,) a) fb
05:37:12 <absence> hah :)
05:52:22 <dminuoso> absence: Well I'd just define it on the spot, really.
05:56:42 <dminuoso> absence: Such combinators are not really common, they dont pass the Fairnbarn threshold for most mortals.
05:57:04 <dminuoso> *Fairbairn
05:57:35 <dminuoso> And pulling in some exotic package like category-extras is probably not worth it.
05:58:07 <dminuoso> Its even obsolete, heh.
06:06:22 <tty1> Is there an easier way to write something like this: (++) <$> ((++) <$> Foo <*> Bar) <*> Foobar
06:07:09 <ski> i suppose you could use idiom brackets
06:07:32 <dminuoso> % :t \f b fb (++) <$> ((++) <$> f <*> b) <*> fb
06:07:33 <yahb> dminuoso: ; <interactive>:1:14: error: parse error on input `<$>'
06:07:38 <dminuoso> % :t \f b fb -> (++) <$> ((++) <$> f <*> b) <*> fb
06:07:38 <yahb> dminuoso: forall {f :: * -> *} {a}. Applicative f => f [a] -> f [a] -> f [a] -> f [a]
06:08:14 <tty1> hmmm
06:08:26 <dminuoso> tty1: but (++) <$> Foo <*> Bar into a separate binding?
06:08:32 <ski>   [i| (++) [i| (++) Foo Bar |] Foobar |]
06:08:35 <ski> or possibly even
06:08:46 <ski>   [i| [i| Foo ++ Bar |] ++ Foobar |]
06:09:19 <ski> hm, but i'm not sure whether the package
06:09:29 <ski> @hackage applicative-quoters
06:09:29 <lambdabot> http://hackage.haskell.org/package/applicative-quoters
06:09:36 <ski> have bitrotted yet
06:10:59 <tty1> hmm might be better then for me to use a where clause i guess, cleaner to read
06:11:12 <ski> perhaps there's some other package which implements as well, dunno
06:12:01 <dminuoso> Mmm, are there good looking combinators to put do infix applicative?
06:12:16 <dminuoso> Something like: Foo <&&> (++) <**> Bar
06:12:45 <dminuoso> Though I guess you could do:
06:12:53 <dminuoso> % (+.+) = liftA2 (++)
06:12:53 <yahb> dminuoso: 
06:13:01 <ski> (and this is the kind of thing that my "reflective syntax" is meant to handle (better than idiom brackets) ..)
06:13:17 <tty1> I decided to just write this function then use it: a <++> b = (++) <$> a <*> b
06:13:17 <dminuoso> % :t \f b fb -> (f +.+ b) +.+ fb
06:13:17 <yahb> dminuoso: forall {f :: * -> *} {a}. Applicative f => f [a] -> f [a] -> f [a] -> f [a]
06:13:23 <dminuoso> tty1: ^- how about this?
06:13:29 * ski misses mmorrow
06:13:31 <tty1> Now i can do Foo <++> bar <++> Foobar
06:13:44 <dminuoso> tty1: Yup, had the same idea. :)
06:13:46 <tty1> seems the most elegant of the choices
06:13:53 <tty1> dminuoso: :)
06:14:12 <dminuoso> ski: what is idiom brackts?
06:14:25 <dminuoso> Ah, Conor Mcbride once again.
06:14:28 <ski> see the `[i| ... |]' examples above
06:14:53 <ski> yes, in some of the early (earliest ?) papers about idioms / applicative functors, by McBride and Paterson
06:28:26 <quchen> tty1: (<++>) = liftA2 (++)
06:28:55 <tty1> quchen: hmm that function is new to me ill check it out
06:28:55 <quchen> <<>> = liftA2 (<>) -- perly ಠ_ಠ 
06:29:05 <quchen> ?src liftA2
06:29:05 <lambdabot> liftA2 f a b = f <$> a <*> b
06:29:11 <tty1> ahhh
06:29:40 <ski> (dminuoso already mentioned `liftA2 (++)', fwiw)
06:30:04 <dminuoso> Oh hiya quchen! Long time.
06:30:09 <quchen> :-)
06:30:22 <quchen> o/
06:31:46 <Solonarv> liftA2 is actually an Applicative method; when you write an Applicative instance you can define liftA2 instead of <*>
06:39:30 <quchen> Historically it wasn’t part of Applicative though, I guess that’s why the ?src does not mention it
06:39:57 <Solonarv> yes, indeed
06:40:06 <Solonarv> but it is now! which is very nice
06:49:59 <Axman6> @zdec _distributedzmclosurezm0zi4zi1zi1zm7vB7kHb3Wls1BwtayWciUf_ControlziDistributedziClosureziInternal_zdfBinaryClosure_closure
06:50:00 <lambdabot> Unknown command, try @list
06:52:24 <Solonarv> oh my!
06:52:39 <Axman6> hmm, anyone remember how to zdecode things? I was sure lambdabot had something for it\
06:53:22 <Solonarv> it came up yesterday(?), let me look at logs
06:54:59 <dminuoso> Encoding module from ghc.
06:55:27 <dminuoso> https://hackage.haskell.org/package/ghc-8.6.5/docs/Encoding.html#v:zDecodeString
06:55:35 <Solonarv> > the Encoding module in the ghc package has a zDecodeString function: zDecodeString "base_GHCziEventziEPoll_new10_info" = "base_GHC.Event.EPoll_new10_info"
06:55:36 <Solonarv> > there was a bot that had a zdec command... maybe lambdabot should steal that feature
06:55:39 <lambdabot>  <hint>:1:14: error: parse error on input ‘module’
06:55:39 <lambdabot>  error:
06:55:40 <lambdabot>      Variable not in scope:
06:55:40 <lambdabot>        there
06:55:48 * dminuoso was faster than Solonarv
06:55:52 <Solonarv> dangit!
06:56:11 <ski> Axman6 : i think it was preflex
06:56:35 <Axman6> hmm, possibly
06:56:45 <dminuoso> Solonarv: So I think you should use ripgrep instead of ack or grep!
06:56:51 <dminuoso> Solonarv: Clearly gives me an edge.
06:57:12 <Solonarv> actually I scrolled up in my client to load old messages and then pressed Ctrl-F
06:57:22 <Solonarv> took me a bit to notice I had to scroll up
06:57:45 <Solonarv> I use quassel, which stores messages in an sql database - in my case, sqlite
06:57:53 <Axman6> For anyone playing at home, tne answer is "_distributed-closure-0.4.1.1-7vB7kHb3Wls1BwtayWciUf_Control.Distributed.Closure.Internal_$fBinaryClosure_closure"
07:16:03 <georg> Hello, I've got State [Int] (); is it possible to pop and return just the 1st element of the state? I've been using elems <- get w/ subsequent modify(tail), but that seems just soo suboptimal. Can I do it better?
07:17:34 <f-a> georg: write pop yourself and reuse it?
07:17:58 <f-a> pop :: State [Int] Int
07:18:08 <f-a> or better
07:18:13 <f-a> pop :: State [Int] (Maybe Int)
07:18:21 <lyxia> pop = state (\(h : t) -> (h, t))
07:18:21 <f-a> so you can do: x <- pop
07:18:26 <ski> @type state (\(n:ns) -> (n,ns)) :: State [Int] Int
07:18:28 <lambdabot> State [Int] Int
07:19:39 <ski> @type state (\case [] -> (Nothing,[]); n:ns -> (Just n,ns)) :: State [Int] (Maybe Int)
07:19:41 <lambdabot> State [Int] (Maybe Int)
07:19:41 <dycan> hi all: How to use symbolVal' (with a prime symbol)? I can use (Proxy :: Proxy a). But I don't understand Proxy# and the way to use it.
07:20:39 <ski> @type StateT (\case [] -> mzero; n:ns -> return (n,ns)) :: MonadPlus m => StateT [Int] m Int
07:20:40 <lambdabot> MonadPlus m => StateT [Int] m Int
07:20:56 <ski> georg ^
07:20:57 <dycan> I was trying the HTML example on https://www.reddit.com/r/haskell/comments/4x8tk8/overloadedlabels_considered_awesome/ and can't type check.
07:21:16 <lyxia> it's best to not use it
07:21:40 <lyxia> what is the error
07:22:39 <dycan> lyxia: Couldn't match type ‘[Html] -> Html’ with ‘Html’       Expected type: [inner] -> Html         Actual type: [String] -> [Html] -> Html
07:23:16 <dycan> lyxia: fromLabel p = _____Html (symbolVal' p)____
07:25:58 <lyxia> dycan: what's the line above
07:26:50 <dycan> lyxia: the line below "IsLabel symbol ([attr] -> [inner] -> Html)"
07:27:12 <dycan> lyxia: maybe I should offer the whole code I type. wait a sec...
07:28:29 <dycan> lyxia: https://gist.github.com/YuMingLiao/34b05f74ffae5a389a5cb5d4dcebcc8e
07:28:49 <ski> % symbolVal' (proxy# :: Proxy# "foo")
07:28:50 <yahb> ski: "foo"
07:28:54 <ski> % symbolVal (Proxy :: Proxy "foo")
07:28:54 <yahb> ski: "foo"
07:28:57 <ski> % symbolVal (Const () :: Const () "foo")
07:28:57 <yahb> ski: "foo"
07:29:10 <dycan> lyxia: now I use (Proxy :: Proxy a) now. But the error is still the same.
07:29:39 <dycan> ski: oh, that's the usage. let me try again.
07:31:24 <lyxia> dycan: https://gist.github.com/Lysxia/ff4a2fba45eb51ec0db1bda01c48ccbf with modern features
07:34:35 <ski> % #foo :: String
07:34:35 <yahb> ski: "foo"
07:35:59 <dycan> lyxia: It compiles. Thank you very much!
07:37:12 <f-a> I have a pure computation that I am testing with quickcheck (via hspec); unfortunately it hangs. Is there a way to have qc show me the offending input?
07:38:00 <dycan> ski: I can't symbolVal' (proxy# :: Proxy# "foo").   parse error on input ‘::’  ....still thanks for the support!
07:38:26 <lyxia> dycan: that needs the MagicHash extension
07:38:50 <ski> % symbolVal' (proxy# @Symbol @"foo")
07:38:50 <yahb> ski: "foo"
07:38:52 <ski> % symbolVal (Proxy @"foo")
07:38:53 <yahb> ski: "foo"
07:38:54 <ski> % symbolVal (Const @() @"foo" ())
07:38:54 <yahb> ski: "foo"
07:39:40 <dycan> lyxia: oh! That's why! Thx!
07:40:45 <lyxia> but anyway Proxy# was necessary a long time ago because it actually gets compiled away, while Proxy meant function had an extra argument. But since GHC 8.0 we have TypeApplications that does a better job most of the time.
07:41:09 <dycan> ski: It seems proxy# can have boarder type definition. from sky's example.
07:42:22 <dycan> lyxia: I see. So I can just use TypeApplication now. That's great.
07:47:23 <dminuoso> lyxia: Ive been debating with myself whether TypeApplications is genuinely better. It forces type parameters (their position specifically) to become part of API.
07:47:24 <ski> dycan : "boarder type definition" ?
07:47:53 * ski isn't quite happy about that, either ..
07:47:58 <dycan> ski: forget about what I said. I misunderstood..
07:48:23 <dminuoso> And until such a time, where we can do applications of the kind `Foo @{x := Int}`, Im no longer convinced TypeApplications really do a better job most of the time
07:48:38 <dycan> ski: I thought @Symbol means I can assign types that Proxy can't.
07:48:51 <dminuoso> (And I think something along those lines in the pipeline, at least Ive seen some work done for it)
07:49:14 <dminuoso> dycan: anything you an do with TypeApplications you can probably also do with Proxy.
07:49:47 <dycan> dminuoso: what's Foo @{x := Int}`   assign a type to a field?
07:50:34 <dminuoso> dycan: Some sort of pseudo syntax, where `Foo :: forall w x y. ...`, so the type application tells you which parameter you want applied.
07:50:38 <Solonarv> no, it means "instantiate the type variable x at type Int'
07:50:47 <dminuoso> ^- that phrases it better :)
07:50:58 <Solonarv> but really this is an exact analogue of value-level positional vs. keyword arguments
07:51:16 <Solonarv> and I'm not at all convinced that keyword arguments are always better
07:51:51 <ski> dminuoso : heh .. i think i wouldn't be quite happy with `Foo @{x := Int}', either ;)
07:52:10 <Solonarv> yeah, now the *names* of the type variables are part of the API
07:52:18 <ski> it would mean that we can't alpha-convert types, any longer
07:52:19 <Solonarv> so you can't alpha rename anymore!
07:52:23 <dminuoso> Solonarv: Well, at least you cant accidentally reorder them anymore.
07:52:25 <lyxia> dminuoso: I think TypeApplications is still better than littering functions with Proxy arguments
07:52:25 * ski low fours Solonarv
07:52:58 <lyxia> not ideal, but still better
07:53:02 <Solonarv> lyxia: well, Proxy arguments are still positional, so really they don't buy us anything compare to TypeApplications
07:53:12 <dminuoso> Solonarv: They buy us stability.
07:53:13 <ski> it's an interesting .. conflict, i suppose you'd say
07:53:21 <lyxia> they do buy us that it doesn't take up a slot for arguments
07:53:23 <Solonarv> ideally we could just pass types directly like any other argument
07:53:25 <ski> dminuoso : and inflexibility
07:53:39 <dminuoso> Solonarv: If I provide you with `f :: f a -> f b` of some kind, and I decide to randomly drop in `C b => ...` I suddenly move the `b` to the front.
07:53:42 <lyxia> I mean, a run time argument.
07:54:06 <Solonarv> dminuoso: TypeApplications don't work if there isn't an explicit forall on the function definition, IIRC
07:54:16 <dminuoso> Solonarv: Of course they do.
07:54:22 <ski> dminuoso : yea .. arguably `@<type>' things ought to match from the inside, outwards ! :)
07:54:23 <lyxia> they do (though I agree that's fishy)
07:54:25 <dminuoso> Solonarv: explicit forall just lets you pick the order explicitly.
07:54:48 <Solonarv> huh, somehow I was under the impression that was forbidden for reasons of ambiguity
07:54:53 <ski> (i have the same complaint with implicit parameters in Agda, when you make them explicit with `{...}')
07:55:57 <Solonarv> what I want is:
07:55:57 <Solonarv> replicateV :: (n :: Nat) -> a -> Vec n a
07:56:09 <lyxia> I still don't understand the problem with ordering type variables.
07:56:18 <Solonarv> usages would just look like 'replicateV 5 foo'
07:56:43 <Solonarv> lyxia: there is no problem if you bind them explicitly
07:56:53 <lyxia> then do that.
07:57:03 <Solonarv> yes
07:57:25 <Ariakenom> ski: but in agda the writer needs to chose the order, right?
07:58:41 <dminuoso> % fun :: forall x. Typeable x => String; fun = show (typeRep (Proxy :: Proxy x))
07:58:41 <yahb> dminuoso: 
07:58:46 <dminuoso> % fun @Int -- Solonarv 
07:58:47 <yahb> dminuoso: "Int"
07:58:53 <isovector1> my rule: if i have an ambiguous type, i put an explicit forall on it, with the most useful-to-apply types first
07:59:07 <ski> Ariakenom : yes, but consider `foo : {A : Type} -> {a : A} -> ..a..'. i want to be able to write `foo {False}' (given `data Bool : Set where False : Bool ; True : Bool'), inferring that `A' should be `Bool'. i don't want to have to write `foo {_} {False}'
07:59:11 <isovector1> sure it "makes the types part of the API" but it doesn't really _in practice_
07:59:19 <isovector1> because nobody applies more than the first one anyway
07:59:23 <kuribas> Solonarv: then the n wouldn't be known at compile time?
07:59:37 <lyxia> I still disagree that making the types part of the API is a problem
07:59:42 <dminuoso> Solonarv: In fact with AllowAmbiguousTypes/ExplicitForAll/TypeApplications/ScopedTypeVariables you can allow for type variables to become regular arguments themselves..
07:59:46 <ski> Ariakenom : so, match "more specific" (later) implicit parameters, before "less specific" (earlier) ones
08:00:08 <Solonarv> oh yes, that is what I do currently
08:00:38 <kuribas> why not replicateV :: KnownNat n => a -> Vec n a
08:00:39 <Ariakenom> ski: that seems like far nicer problem to have than the haskell one :D
08:00:40 <lyxia> It's pretty easy to tell whether a library was written with TypeApplications in mind
08:00:41 <ski> Ariakenom : if you want, you could say that the problem is that one can't express something like `foo : {a : A} -> {A : Set} -> ..a..' (or rather, it's not the same `A' in the two places)
08:00:42 <Solonarv> but the annoying thing here is that we can't say "you *must* provide this argument", and so GHC quite reasonably complains about ambiguity
08:00:45 <lyxia> when in doubt, assume it's not
08:00:51 <Solonarv> and we must tell it to shut up
08:01:02 <dminuoso> lyxia: If you do it internally its probably not an issue. But when you start relying on positional order of external libraries, and people bump patch versions after reordering type variables, breaking public api...
08:01:03 <ski> (s/Type/Set/)
08:01:05 <Solonarv> kuribas: because the KnownNat constraint isn't needed
08:01:09 <siraben> Has anyone read "The Implementation of Functional Languages" by SPJ? Is it worth reading and are there similar books?
08:01:11 <dminuoso> lyxia: It'd weaken PvP
08:01:30 <kuribas> Solonarv: how would ghc know the value at compile time without it?
08:01:49 <dminuoso> 17:00:19      lyxia | It's pretty easy to tell whether a library was written with TypeApplications in mind
08:01:51 <dminuoso> lyxia: How?
08:02:00 <ski> isovector1 : "because nobody applies more than the first one anyway" -- if you need to specify one which happens to not be the first one ..
08:02:02 <dminuoso> I mean seeing TypeApplications in haddock is a good hint of course...
08:02:09 <Axman6> siraben: I usually find that Written by SPJ => Should be read
08:02:22 <ski> siraben : i think i've seen people suggest it, on here
08:02:32 <Solonarv> kuribas: a KnownNat constraint represents "the value of this Nat is known at runtime"
08:03:17 <Solonarv> ...which you do need for replicateV
08:03:20 <Solonarv> whoops! you're right
08:04:05 <lyxia> dminuoso: Hm, actually maybe it's not so easy.
08:04:06 <kuribas> Solonarv: doesn't it mean known at compile time?
08:04:35 <kuribas> and SomeNat is known at runtime
08:04:36 <lyxia> but my point still stands that it can be made explicit
08:05:16 <Solonarv> kuribas: well, n happens to be known at compile time already GHC can of course insert that knowledge into the program and solve the KnownNat constraint
08:05:48 <isovector1> ski: how often does that happen? like zero times
08:06:16 <Solonarv> and even then you just write @_
08:06:16 <isovector1> we can argue until the cows come home about "IS THIS A GOOD IDEA" but without actually trying it in practice it's a waste of time
08:06:46 <Solonarv> foo @_ @<argument I care about>
08:07:16 <kuribas> Solonarv: if the n is not known at compile time, for example it comes from an unknown source, the KnownNat constraint cannot be solved
08:07:35 <Solonarv> kuribas: incorrect, that's what SomeNat and the machinery around it is for
08:07:47 <ski> isovector1 : it has happened to me. so not zero times
08:07:50 <Solonarv> it magics up a KnownNat dictionary from runtime information
08:08:11 <ski> Solonarv : granted
08:08:12 <Solonarv> btw, in dependent-Haskell-as-currently-envisioned we would write
08:08:12 <Solonarv> replicateV :: forall a. foreach (n :: Nat) -> a -> Vec n a
08:08:12 <Solonarv> 'foreach' indicates that we need this value at run time
08:08:23 <Lycurgus> what if a stupid intolerant culture arose on IRC?
08:08:24 <kuribas> Solonarv: it's the other way around
08:08:43 <Solonarv> kuribas: what? no
08:08:51 <kuribas> KnownNat = known at compile time, SomeNat = not known at compile time
08:09:04 <Solonarv> no
08:09:30 <Solonarv> consider the dictionary-passing translation of type classes
08:09:36 <ski> % :i SomeNat
08:09:37 <yahb> ski: data SomeNat = forall (n :: Nat). KnownNat n => SomeNat (Proxy n) -- Defined in `GHC.TypeNats'; instance Eq SomeNat -- Defined in `GHC.TypeNats'; instance Ord SomeNat -- Defined in `GHC.TypeNats'; instance Show SomeNat -- Defined in `GHC.TypeNats'; instance Read SomeNat -- Defined in `GHC.TypeNats'
08:09:48 <Solonarv> so 'KnownNat n =>' really just means 'Natural ->'
08:09:55 <ski> a `SomeNat' contains evidence for `KnownNat n', for some `n'
08:10:04 <kuribas> data SomeNat This type represents unknown type-level natural numbers.
08:10:13 <ski> so you can't have both of "KnownNat = known at compile time" and "SomeNat = not known at compile time"
08:10:32 <Solonarv> yes, the documentation should be clearer and say "unknown at compile time"
08:10:40 <dminuoso> Solonarv: Is `foreach` Pi?
08:10:44 <Solonarv> dminuoso: yes
08:10:57 <Solonarv> but it is a name that makes some amount of sense if you don't know type theory
08:11:10 <Solonarv> so people don't ask "why is there a greek letter in my types"
08:11:17 <dminuoso> Solonarv: I hope I can get unicode syntax for that :-p
08:11:25 <dminuoso> (Which I know I cant)
08:11:35 <Solonarv> dminuoso: I believe that is planned, actually
08:11:36 <Solonarv> ∀ already works after all
08:11:57 <Solonarv> so it makes sense to add ∏ for the new keyword
08:11:59 <dminuoso> Solonarv: I doubt it because Π is part of the greek alphabet
08:12:13 <Solonarv> ah, but Π ≠ ∏
08:12:17 <dminuoso> Oh
08:12:32 <c_wraith> unicode has too much pi
08:12:38 <dminuoso> And needs more λ
08:12:54 <Solonarv> ∏ = N-Ary Product
08:12:54 <Solonarv> Π = Uppercase Greek Letter Pi
08:12:54 <Solonarv> not the same thing!
08:13:03 <Solonarv> they are distinct in my font, but perhaps not in yours
08:13:13 <dminuoso> Solonarv: They are distinct too.
08:13:25 <tdammers> .oO( Σ and Π for algebraic data types... )
08:13:35 <monochrom> λ, Λ, ∧, ^
08:13:40 <tdammers> monochrom: \
08:13:50 <tdammers> \ is the minimalist's lambda symbol
08:14:03 <dminuoso> Solonarv: Well I guess its fair, Ive seen product/sum characters been used so..
08:14:11 <tdammers> and then there's ↑, the clueless lambda symbol
08:14:21 <dminuoso> tdammers: If we ever want to get those Agda people back, we need more unicode.
08:14:24 <monochrom> λ_λ,  Λ_Λ , ∧_∧ , ^_^
08:14:44 <tdammers> don't get me started on the baroque amount of horizontal lines in unicode
08:14:55 <monochrom> If you don't mind two codepoints, slashdotter's lambda: .\
08:15:10 <tdammers> is it a hyphen? a minus? a hyphen-minus? a dash? if so, which one? or maybe it's a line-draw character, but which one?
08:15:11 <dminuoso> monochrom: but thats dotslash.
08:15:21 <tdammers> dminuoso: it's a colambda
08:15:28 <Solonarv> .\x..\y.x -- ew
08:15:35 <tdammers> ahem, slashdot is a colambda
08:15:37 <dminuoso> tdammers: A what... ?
08:15:45 <dminuoso> Oh that makes sense now.
08:15:49 <monochrom> haha
08:16:13 <kuribas> ski: so KnownNat means possibly known at compile-time, and SomeNat not possibly known at compile-time?
08:16:22 <siraben> ski: Axman6: thanks, will read
08:17:39 <ski> kuribas : `KnownNat n' is a constraint whose run-time evidence will tell you what `n' is. that `n' may already have been known at compile-time, or may have been provided only at run-time
08:18:12 <Solonarv> iow 'KnownNat n' means precisely "n is known at run-time" – it doesn't matter how we know it
08:18:34 <kuribas> so it only proof equality?
08:18:38 <ski> kuribas : `SomeNat' is just `exists n. KnownNat n *> Proxy n', iow it's a type whose values which encapsulate the evidence of `KnownNat n' holding for some `n'
08:19:05 <ski> kuribas : that `n' might have been known at compile-time, just before wrapping the evidence inside `SomeNat' .. or not
08:19:26 <ski> kuribas : the main difference between `KnownNat n' and `SomeNat' is the existential quantification of `n' in the latter
08:19:41 <ski> (and, obviously, that the former is a constraint, but the latter is a concrete type)
08:20:20 <Solonarv> (but we can wave our hands furiously and shout "dictionary passing!" to shoo that distinction away)
08:20:37 <monochrom> SomeNat is useful if the number is only determined dynamically (e.g., depends on user input).
08:21:12 <ski> siraben : if you read it, perhaps you could report back your sentiments (and perhaps some greater insights from it, ior criticisms) about it to this channel
08:21:41 <monochrom> Oh, nevermind, your question is different.
08:21:41 <ski> is determined dynamically, or *may* be determined dynamically, in the general case
08:22:26 <dminuoso> kuribas: Perhaps its helpful to consider consuming something that demands a KnownNat, like: showNat :: forall n. KnownNat n => String
08:23:18 <kuribas> ah, so that would need to fix the n
08:23:31 * ski idly wonders what a reasonable example of something consuming `showNat' could be
08:24:00 * dminuoso starts to smile
08:25:08 <Solonarv> ski: perhaps a Show instance for length-indexed vectors
08:25:31 <Solonarv> that wants the output to look like "fromList @3 [x, y, z]"
08:25:56 <dminuoso> kuribas: So the idea is, you somehow have to provide proof of `KnownNat n`
08:26:00 <dminuoso> One way or another.
08:26:21 <dminuoso> SomeNat has that proof embedded, and you bring it into scope by pattern matching on its constructor
08:26:41 <kuribas> dminuoso: and SomeNat provides proof for numbers coming from runtime
08:26:43 <monochrom> You receive two vectors from two external sources.  So their type-level lengths have to be type variables m and n, but they have the KnownNat constraint.
08:26:56 <kuribas> dminuoso: while compile time Nat's don't need more proof
08:29:30 <monochrom> You conditional-branch on this: Does sameNat say they are equal?  You will get Nothing or Just Refl, but Refl comes with a type-level statement that m~n.
08:29:31 <ski> dminuoso :)
08:30:28 <dminuoso> % showSomeNat :: SomeNat -> String; showSomeNat (SomeNat p) = show (natVal p)
08:30:29 <yahb> dminuoso: 
08:30:38 <monochrom> In the Just Refl case, now you can safely add those two vectors, e.g., you can pass them to an adder of type "Vec k -> Vec k -> Vec k".
08:31:12 <Solonarv> monochrom: did you mean "add pointwise" and 'Vec k Int -> Vec k Int -> Vec k Int' ?
08:31:17 <Solonarv> (or some other numeric type)
08:31:27 <monochrom> So the lengths are dynamic, but after a dynamic check you get a static "they are the same type" and that's all you need for your safe core.
08:31:41 <monochrom> s/Vec/IntVec/ OK?
08:32:07 <Solonarv> sure!
08:32:27 * ski idly wonders whether monochrom has seen that "Calculational Mathematics" article collection before
08:32:35 <monochrom> No.
08:33:23 * ski . o O ( "Calculational Mathematics - Writings on the predicate, relational, and other calculi" by Edsger W. Dijkstra,Wim Feijen,Netty van Gasteren in 1990-11-08 (?) - 1996 summer (?) at <http://www.mathmeth.com/files/calc_collection.pdf>,(cf. <http://www.mathmeth.com/>) )
08:33:45 <ski> (which i mentioned a few hours ago in here)
08:33:55 <monochrom> Then some of them.
08:36:18 <kuribas> is there a way to compare runtime naturals, and get type level equality proof?
08:36:41 <ski> seeing that made me think of "a Practical Theory of Programming" by Eric C. R. Hehner in (?)2014-01-19 - 2015-09-19 at <http://www.cs.toronto.edu/~hehner/aPToP/>, and his course "Formal Methods of Software Design" at <http://www.cs.utoronto.ca/~hehner/FMSD>, which i think you've mentioned before
08:37:50 <ski> % :t sameNat  -- kuribas, mentioned by monochrom above
08:37:50 <yahb> ski: forall {a :: Nat} {b :: Nat}. (KnownNat a, KnownNat b) => Proxy a -> Proxy b -> Maybe (a :~: b)
08:38:17 <kuribas> ski: that doesn't do a runtime check?
08:38:23 <ski> it does
08:38:40 <ski> that's what determines whether you'll get `Nothing' or `Just Refl'
08:38:46 <kuribas> it compares dictionaries?
08:39:04 <ski> it compares the evidence for `KnownNat a' and `KnownNat b', yes
08:40:09 <monochrom> It compares something carried in the dictionary, I don't know what, but it seems the singleton technique is involved.
08:40:37 <ski> of course, if `a' and `b' are already known at compile-time, then the compiler can just emit code that always computes `Nothing', or code that always computes `Just Refl'
08:40:44 <monochrom> Because conspicuously the unexported but leaked-by-haddock method is called natSing.
08:41:07 <ski> however, if those `a' and `b', and the corresponding `KnownNat' constraints on them, come from e.g. `SomeNat's, which were computed dynamically, then it can't do that, in general
08:43:24 <hyperisco> @pl \f -> foo (\r -> bar f (qux r)) baz
08:43:24 <lambdabot> flip foo baz . (. qux) . bar
08:45:52 <Solonarv> you could write it yourself using unsafeCoerce:
08:45:52 <Solonarv> sameNat p q = unsafeCoerce Refl <$ guard (natVal p == natVal q)
08:53:28 <Axman6> Is there a common convention for safer versions of a function, say ones which return NonEmpty a - an example would be group' :: Eq a => [a] -> [NonEmpty a]
08:54:06 <Axman6> if you had both in a module what would you call the [[a]] and [NonEmpty a] versions I guess
08:55:57 <Solonarv> you can add pre- or suffixes like 'unsafe', 'safe', 'Maybe'/'May', 'Either', '1', 'NE' (short for NonEmpty), ...
08:56:10 <Axman6> we use ' often for more strict versions of something, M for a monadic version, do we have any conventions for Semigroup versions of things (where the m prefix is often used for Monoid)
08:56:25 <Axman6> yeah I was looking at NE. Feels clunky
08:56:40 <kuribas> ski: if it comes from a SomeNat, there would be a dictionary inside?
08:56:45 <ski> the prime thing is not really that good a convention
08:56:52 <ski> (also there's `_' suffix)
08:57:11 <ski> kuribas : yes, since `SomeNat' is basically `exists n. KnownNat n *> Proxy n'
08:57:13 <monochrom> Yeah SomeNat is an existential type packing up the KnownNat constraint.
08:57:13 <Solonarv> ski: yeah, there are other conventions for other potential variations
08:57:35 <Solonarv> Axman6: there are some s-prefixed functions in Data.Semigroup
08:58:00 <Solonarv> well really just stimes and a handful of default implementations for it
08:58:45 <monochrom> ' is now both a convention for strictness (FSVO strictness, to ironicalize the iron) and a convention for DataKinds
08:59:31 <ski> % :t symbolVal'  -- as in this case ?
08:59:31 <yahb> ski: forall {n :: Symbol}. KnownSymbol n => Proxy# n -> String
08:59:52 <Solonarv> perhaps that should've been named symbolVal#
08:59:59 <Solonarv> you need MagicHash to use it anyway
09:00:15 * ski irons out the ironic
09:07:28 <Blar> I am looking for a groupBy function that works like the one in Clojure.
09:07:33 <Blar> In Clojure there is something like:   groupBy :: Traversable t => (a -> b) -> t a -> t (b, [a])
09:07:38 <Blar> So that    groupBy length ["a", "b", "ab", "abc", "c", "xyz"]   =>   [(1, ["a", "b", "c"]),  (2, ["ab"]),  (3, ["abc", "xyz"])]
09:09:25 <Cale> > M.fromListWith (++) . map (\x -> (length x, [x])) $ ["a", "b", "ab", "abc", "c", "xyz"]
09:09:28 <lambdabot>  fromList [(1,["c","b","a"]),(2,["ab"]),(3,["xyz","abc"])]
09:09:50 <Cale> > M.toList . M.fromListWith (++) . map (\x -> (length x, [x])) $ ["a", "b", "ab", "abc", "c", "xyz"]
09:09:52 <lambdabot>  [(1,["c","b","a"]),(2,["ab"]),(3,["xyz","abc"])]
09:11:30 <Blar> Cale: yes, that looks good, thank you
09:11:50 <Cale> (You may even want to leave the results as a Map, depending on what you're trying to do)
09:12:41 <Blar> Cale: yes, I even prefer the results as Map.
09:12:57 <Blar> Cale: Actually in Clojure `group-by` does return a Map.
09:13:17 <Cale> also, if we'd made singleton sets, we can combine them with Set.union
09:13:31 <Cale> > M.fromListWith (S.union) . map (\x -> (length x, S.singleton x)) $ ["a", "b", "ab", "abc", "c", "xyz"]
09:13:34 <lambdabot>  fromList [(1,fromList ["a","b","c"]),(2,fromList ["ab"]),(3,fromList ["abc",...
09:14:19 <Cale> which keeps things sorted, rather than putting them in the reverse order that they occurred in the original list
09:14:20 <infinisil> That could use an arrow!
09:14:34 <Cale> hm?
09:14:47 <Cale> You're talking about using length &&& S.singleton?
09:14:49 <jusss> what is Kleisli?
09:14:53 <infinisil> :t length &&& S.singleton
09:14:55 <lambdabot> Foldable t => t a -> (Int, S.Set (t a))
09:15:02 <infinisil> Yeah
09:15:03 <Cale> Sure, you can do that if you like
09:15:44 <jusss> first, I saw this word, I thought it has to do with Game of Thrones, and the answser is no
09:15:47 <Cale> These days I tend to use more lambdas :)
09:16:08 <infinisil> Yeah, I feel like arrow is mostly just used to write confusing code xD
09:16:09 <strangeglyph> hey, I'm having issues with literate haskell. for some reason this gives a syntax error at the second import statement: https://pastebin.com/8SR8ZvaW
09:16:09 <Cale> jusss: Are you already familiar with monads?
09:16:42 <strangeglyph> while this, for some reason, compiles: https://pastebin.com/gLDrdpD4
09:16:53 <Cale> strangeglyph: Is there a reason you're combining both styles of Literate Haskell in the same file?
09:17:14 <strangeglyph> Cale: inherited a project using bird style and slowly converting it to latex style
09:17:19 <Cale> That is weird, but also would probably never realistically arise :)
09:17:48 <Cale> I would sort of expect GHC to desugar all the LHS first, but maybe it does it in chunks
09:18:17 <Cale> I'm not sure
09:18:34 <jusss> Cale: I don't know, even I stuck here almost a month
09:19:02 <Cale> strangeglyph: Just finish converting the whole file, I guess -- it won't be a valid LaTeX file until you're done anyway.
09:19:15 <jusss> Cale: do I really need to learn Category Theory?
09:19:18 <Cale> jusss: no
09:19:40 <Cale> jusss: But you will need to know what monads are *in Haskell*
09:20:22 <Cale> Learning category theory is only useful if you're interested in how these ideas are meaningful beyond Haskell in other parts of mathematics.
09:20:24 <jusss> Cale: List Monad, Maybe Monad and Reader Monad I assume,
09:20:35 <Cale> Well, those are a good start
09:20:37 <jusss> the last one I'm really confused
09:21:02 <hyperisco> it is also smart to just talk of Monad, without any particular instance in mind
09:21:37 <jusss> I saw many people use monad on other languages, like js or python
09:21:40 <jusss> or java
09:22:02 <Cale> jusss: The translations to other programming languages are usually not quite right
09:22:09 <jusss> that's so cool they can understand what monad is and use it anywhere
09:22:24 <Cale> Very few other programming languages have the necessary features to really make the abstraction work
09:22:36 <hyperisco> in principle, no reason they couldn't, even though none of those languages can really define Monad like Haskell does
09:23:07 <Cale> return :: (Monad m) => a -> m a
09:23:21 <jusss> Cale: they have abstract method, java's interface and python's @abstract
09:23:35 <hyperisco> first one needs to recreate some resemblance of type classes, which is never quite right, but is based on some version of dict passing
09:23:52 <ski> @type \f -> map (f . head &&& id) . GHC.Exts.groupWith f
09:23:54 <lambdabot> Ord c => (b -> c) -> [b] -> [(c, [b])]
09:23:58 <ski> @type \f -> map (fst . head &&& map snd) . GHC.Exts.groupWith fst . fmap (f &&& id)
09:24:00 <lambdabot> Ord b => (a -> b) -> [a] -> [(b, [a])]
09:24:02 <ski> @type \f -> map (f . Data.List.NonEmpty.head &&& id) . Data.List.NonEmpty.groupWith f
09:24:03 <Cale> The type of this function has two difficulties for many languages: one is that it abstracts over a type-level function -- i.e. it has higher-kinded polymorphism
09:24:04 <lambdabot> (Eq c, Foldable f) => (b -> c) -> f b -> [(c, Data.List.NonEmpty.NonEmpty b)]
09:24:06 <ski> @type \f -> map (fst . Data.List.NonEmpty.head &&& fmap snd) . Data.List.NonEmpty.groupWith fst . fmap (f &&& id)
09:24:08 <lambdabot> (Functor f, Eq b, Foldable f) => (a -> b) -> f a -> [(b, Data.List.NonEmpty.NonEmpty a)]
09:24:14 <jusss> Cale: after all, everything is just functions, right?
09:24:32 <Cale> The second is that it's picking an instance of Monad based on the result type which is being requested in context
09:24:41 <ski> Blar : i suppose something like that ^ could be used, as well
09:24:54 <hyperisco> and then one needs accept the type system does not have higher-kinded polymorphism, so you can never *really* talk about  m  as a Monad… dynamic languages make this less of an obvious problem
09:24:55 <Cale> In many other languages, polymorphism depends only on the argument types, and not on the result type
09:25:15 <Cale> and this tends to be what catches dynamically typed languages
09:25:34 <Cale> (not having types at compile time at all makes that really difficult)
09:26:10 <ski> jusss : overloading on result type (only) isn't something many languages have
09:26:19 <Cale> To make monads worth talking about at all, we need to be able to write code once which will work in any monad
09:26:22 <ski> (istr Ada has (ad-hoc) overloading of this sort ?)
09:26:38 <hyperisco> my experience has been that no useful reincarnation of Monad exists, but there are some useful reincarnations of Monad instances
09:26:47 <ski> Cale : "everything is just functions" -- what do you mean by that ?
09:26:56 <Cale> I didn't say that
09:26:57 <hyperisco> and the good news is that many programs only need an instance or two of a particular class to work
09:27:00 <jusss> ski: I don't get it, what is this result type special? 
09:27:20 <hyperisco> and don't need the abstraction
09:27:23 <jusss> special to parameter type
09:27:55 <ski> jusss : try having `int foo(void);' and `String foo(void);' in the same class, in Java
09:28:18 <Cale> If we can't write functions like 'sequence' and 'forM' and more complex things like the monad transformer library, the abstraction isn't gaining us any real traction, we're just using additional words to describe our programs when those distinctions don't really have any impact on what we're doing
09:28:23 <jusss> ski: I don't know java yet...
09:28:51 <hyperisco> I never understood why you cannot overload on return types
09:28:54 <jusss> ski: you mean same paramter type with different return types?
09:29:07 <Cale> jusss: right, exactly
09:29:29 <hyperisco> but dollars to donuts it is to do with compile time
09:29:48 <jusss> Cale: examples in haskell?
09:29:49 <Cale> jusss: The return function needs to be polymorphic in its result type in a way that can't be determined by the types of its parameters
09:29:53 <Cale> :t return
09:29:55 <lambdabot> Monad m => a -> m a
09:30:05 <hyperisco> it is actually a constraint for language designers / compiler writers to guarantee certain compile times
09:30:07 <Cale> There's that 'm' in the result type which we can't determine from the type 'a'
09:30:21 <Cale> I might use return to build a list:
09:30:26 <Cale> > return 5 :: [Int]
09:30:29 <lambdabot>  [5]
09:30:33 <Cale> Or a Maybe:
09:30:36 <Cale> > return 5 :: Maybe Int
09:30:39 <lambdabot>  Just 5
09:30:45 <hyperisco> I don't really understand the general utility myself, but that's how it is
09:30:45 <Cale> or an action of any other monad
09:31:04 <jusss> Cale: but this return's type is your definition,
09:31:17 <Cale> Well, it's part of the definition of what a monad is
09:31:21 <ski> oh, sorry, s/void//
09:31:39 <hyperisco> > minBound :: Int
09:31:40 <jusss> Cale:  in instance, Maybe ,return Just, [], return [a]
09:31:41 <lambdabot>  -9223372036854775808
09:31:42 <hyperisco> I dunno if that is more compelling
09:32:05 <Cale> jusss: Right, in each monad, we define return differently, and its implementation is selected based on its type
09:32:42 <Cale> jusss: In languages that are not Haskell, this tends to be difficult, because which implementation to choose depends on the type of result, and it depends on the choice of a parametric type.
09:32:44 <jusss> Cale: and I really don't know what this is useful?
09:33:00 <Cale> Well, this isn't really getting at why monad is useful at all.
09:33:18 <ski> hyperisco : "I never understood why you cannot overload on return types" -- it's similar to how few languages does type inference (which can propagate information also "backwards", from expected types of expressions, into required types of parts of that expression)
09:33:22 <Cale> Just why it's hard to implement accurately in other programming languages
09:33:24 <jusss> polymorphism is useful?
09:33:52 <Cale> The reason Monad is useful as an abstraction is that it saves us from writing a lot of similar code all the time.
09:34:07 <hyperisco> ski, sure, but just propagate the information backwards then
09:34:08 <Cale> For example, there are whole libraries of things which will work in an arbitrary choice of monad
09:34:15 <Cale> which we don't have to write again for each new monad
09:34:26 <ski> hyperisco : yes, but i think many language implementations don't do that
09:34:30 <jusss> Cale: I think it can, if we implement Monad with class, and each class has its each return 
09:34:31 <hyperisco> why?
09:34:32 <Cale> The simplest examples are the things in the Prelude and Control.Monad
09:34:40 <Cale> jusss: You mean OO class?
09:34:47 <jusss> Cale: yeah
09:35:01 <ski> hyperisco : perhaps because type inference (how to implement it), isn't that widespread knowledge, among language implementation writers in general ?
09:35:07 <Cale> jusss: The tricky part is that return doesn't get to have an object of the appropriate type as an argument
09:35:10 <jusss> type class is really not like a class
09:35:20 <Cale> jusss: So how will it know which class to use?
09:35:32 <hyperisco> nah, maybe in some cases, but I wouldn't assume that
09:35:52 <hyperisco> I read how the Go designers talk and it is pretty clear what the motivations are
09:35:55 <hyperisco> or Rust, or w/e
09:36:20 <c_wraith> the jvm actually does let you overload on return type. but Java doesn't. fun disconnect there!
09:36:22 <ski> hyperisco : okay ?
09:36:28 <hyperisco> for Type Script (in a different sort of overloading issue) it was because they literally couldn't, because they had to guarantee a compile complexity
09:36:42 <ski> c_wraith : oh, that's interesting
09:36:58 <Cale> jusss: it may be possible if we make the type parameter explicit -- Java after all has generics like the <T> things which show up
09:37:13 <ski> hyperisco : they literally couldn't do what ?
09:37:17 <hyperisco> and a language like Go they are just arbitrating features from a certain design concept of simplicity + fast compile
09:37:24 <Cale> jusss: I'm not sure whether modern Java will let you parametrise over things which themselves take other type arguments though
09:37:26 <hyperisco> ski, they literally couldn't have better inference
09:37:42 <ski> hyperisco : better than what ?
09:37:50 * ski isn't really familiar with TypeScript
09:37:51 <hyperisco> not because it was computationally impossible but because they were not allowed to introduced exponential complexity inference
09:38:08 <jusss> Cale: in >>=, return depends the type of first and second parameter I think that can identify the class
09:38:12 <hyperisco> better than what they have
09:38:54 <delYsid``> How do I merge a list of Trees into a Forest?
09:39:05 <Cale> jusss: Like, can we write...  public static <M> <A> M<A> pure (A val) ?
09:39:30 <hyperisco> a language like Rust, community members (and I assume some language devs, I didn't figure it out), are worried whether the complications of HKP is actually worth enough
09:39:46 <ski> Cale : i think tyvars in Java must be concrete ?
09:39:51 <jusss> Cale: sorry, I haven't learn java yet...
09:40:04 <Cale> ski: I thought so as well, but I haven't kept up with Java in many years
09:40:17 <hyperisco> so I wouldn't think or at least assume that the designers merely don't know of what is possible
09:40:28 <Cale> jusss: Well, in any case, it's tricky! :)
09:40:49 <ski> (and you'd either need to constraint `M' there, or pass some extra input whose type depends on `M'. or quantify `M' further out. i think)
09:40:49 <boj> hyperisco: there is an in depth RFC in which they discuss that
09:41:08 <ski> Cale : otoh, in C++, a template can take other templates as parameters
09:41:12 <Cale> ski: Yeah, I was thinking this would be in some sort of interface definition, but I don't know
09:41:24 <jusss> Cale: ok, now there're three languages I could learn, java, kotlin and scala, any suggestion?
09:41:33 <c_wraith> ski, actually, that was a bit misleading of a statement. the jvm doesn't overload at all. methods are identified by strings that contain the argument and return types. so as far as the jvm is concerned, they're just two different methods, and overloading is irrelevant.
09:41:38 <ski> (since otherwise you're basically saying `pure :: forall m a. a -> m a', which is clearly incorrect)
09:42:12 <Cale> jusss: I probably wouldn't bother with any of those without having a project that I wanted to work on that happened to be written in one of them.
09:42:15 <ski> (hm, and i think to quantify multiple tyvars, you'd do `<M,A>', not `<M> <A>' ?)
09:42:20 <Cale> ski: Yeah, of course
09:42:51 <hyperisco> practically speaking I haven't even been bothered by nonterminating inference, so… to me, more automation is more betterer
09:43:24 <jusss> it takes me two months on haskell, and I still can't use it to do something... there're so many concepts I don't understand
09:43:29 <ski> (i would suggest something like `<M extends Monad,A>', except that that `Monad' would presumably be concrete, so that wouldn't work .. perpaps one could imagine a concrete `Monad' which has an (parameterized) associated type inside, or something ?)
09:43:54 <Cale> jusss: Well, it's easier to understand all these things within the context of Haskell, rather than trying to translate them
09:43:58 <ski> jusss : i suspect learning Java before Scala will be easier
09:44:11 <Cale> ski: Monad could be an interface?
09:44:20 <ski> c_wraith : i see
09:44:35 <hyperisco> translating is really complicated… to be attempted once you can understand both languages clearly
09:44:48 <hyperisco> it is all round pegs and square holes
09:44:51 <jusss> ski: is this type signature special?
09:45:14 <ski> Cale : perhaps
09:45:16 <Cale> jusss: which one?
09:45:20 <hyperisco> the only thing you can port is the concepts hidden beneath the syntax
09:45:25 <jusss> Cale: id::a->a
09:45:43 <ski> jusss : "special" in what sense ?
09:46:09 <hyperisco> much like how you cannot translate words, only meanings
09:46:35 <jusss> ski: type inference? I don't know, haskell is the first language with type system I learn, (if we forget C)
09:46:50 <hyperisco> I try
09:47:04 <jusss> or haskell's type system is special?
09:47:08 <Cale> jusss: A lot of type systems don't have parametric polymorphism in quite the same way that Haskell does.
09:47:20 <Cale> i.e. type variables are not always a thing
09:47:40 <Cale> and then even if you do have type variables, they might not be able to stand for types that have parameters
09:47:42 <jusss> Cale: java has generic
09:47:45 <Cale> yes, it does
09:47:56 <Cale> but I don't *think* its type variables can stand for generic things
09:48:28 <Cale> i.e. Integer would be fine, but you can't parametrise over List, if my old understanding of Java is still true
09:48:42 <jusss> sorry, this ADTs has to do with type system?
09:48:56 <jusss> or can we say java c# have ADTs?
09:49:06 <Cale> I don't quite understand the question
09:49:07 <hyperisco> Cale, that's right, no higher-kinded polymorphism, as I insist it be called
09:49:12 <Cale> Of course types have to do with the type system
09:49:32 <Cale> hyperisco: Yeah, it's just I'm not sure if jusss understands kinds yet
09:50:00 <Cale> hyperisco: But good to know
09:50:07 <Cale> hyperisco: Do you know about C#?
09:50:11 <hyperisco> same as C# and every other generics-bearing language I know o
09:50:14 <hyperisco> f
09:50:18 <Cale> ah, interesting
09:50:29 <Cale> It seems like a completely arbitrary and pointless restriction to me
09:50:43 <Cale> but there must be something that's making it hard for these guys :)
09:50:52 <ski> jusss : "ADT" meaning "Abstract Data Type" or "Algebraic Data Type" ?
09:50:53 <hyperisco> and if you peel the layers of the onion you find out this is a limitation of .NET
09:51:04 <Cale> ahhh
09:51:14 <jusss> Cale: err... I don't undertand those rank-n types yet
09:51:29 <jusss> ski: the last one
09:51:49 <Cale> jusss: Not higher-rank stuff, just higher *kinded* stuff
09:51:58 <ski> hyperisco : no higher-order types (and also no higher-rank types, and also no polymorphic types)
09:52:03 <nshepperd_> Scala and c++ support it
09:52:03 <Cale> jusss: Just like terms have types
09:52:07 <Cale> Types have kinds
09:52:26 <Cale> The kind of any type which has ordinary values in it is called *
09:52:30 <Cale> :k Int
09:52:32 <lambdabot> *
09:52:34 <jusss> Cale: is this https://en.wikipedia.org/wiki/Higher-order_logic ?
09:52:41 <Cale> :k [String]
09:52:42 <lambdabot> *
09:52:48 <Cale> Nothing to do with higher-order logic
09:52:50 <hyperisco> ski, in what language?
09:52:59 <ski> jusss : Java and C# does not have algebraic data types (or variant/sum types in general)
09:53:11 <Cale> (well, something to do with higher order logic, but any relationship with it would be complicated to explain...)
09:53:22 <ski> jusss : i don't think Cale talked about, or even was referring to, higher-rank types
09:53:45 <hyperisco> also I do not know higher-rank vs higher-order
09:53:49 <Cale> jusss: Types which have a parameter which is an ordinary type have kind * -> *
09:53:56 <Cale> :k Maybe
09:53:57 <lambdabot> * -> *
09:54:07 <Cale> :k [] -- the list type constructor, not the empty list
09:54:09 <lambdabot> * -> *
09:54:13 * ski idly wonders whether anyone calls higher-order functions, "higher-typed functions"
09:54:14 <Cale> :k IO
09:54:16 <lambdabot> * -> *
09:54:27 <ski> @kind Either String Integer
09:54:29 <lambdabot> *
09:54:29 <ski> @kind Either String
09:54:31 <lambdabot> * -> *
09:54:31 <ski> @kind Either
09:54:33 <Cale> ski: I can imagine that maybe happening in very early literature
09:54:33 <lambdabot> * -> * -> *
09:55:00 <Cale> Yeah, this Either example is good
09:55:05 <ski> nshepperd_ : C++ supports Algebraic Data Types ?
09:55:08 <Cale> jusss: ^^ does all that make sense so far?
09:55:23 <jusss> ski: what this ADTs is special to other type system in java?
09:55:30 <jusss> Cale: kind of,
09:55:42 <jusss> Cale: every type is *
09:55:46 <jusss> has
09:55:54 <Cale> Every type which has values in it has kind *
09:55:59 <ski> hyperisco : that "no higher-order types (and also ...)" was a comment on your "that's right, no higher-kinded polymorphism, as I insist it be called"
09:56:09 <hyperisco> ski, if you squint enough I think C++ supports everything
09:56:22 <jusss> Cale: and we can't use that now in ghci, right?
09:56:31 <Cale> jusss: You can use :k in ghci
09:56:57 <jusss> Cale: except this :k, anythin else? :-?
09:57:25 <hyperisco> ski, well I don't really like this "higher" language, but that's what people like to say, so I am compromising. What I don't like is people saying "no HKTs!" when List is clearly such. What they mean is no polymorphism!
09:57:25 <Cale> jusss: I just want this notion of kinds so that I can clearly explain what Haskell is letting us do which most other languages can't
09:57:33 <ski> hyperisco : `(forall a. [a] -> [a]) -> [String] -> [String]' is a higher-rank type. `MaybeT' (having kind `(* -> *) -> *') is a higher-order type (compare with how `interact :: (String -> String) -> IO ()' is a higher-order value (function))
09:57:40 <Cale> jusss: Specifically, Haskell allows us to have type variables of any kind
09:57:44 <Cale> jusss: Not just kind *
09:57:56 <Cale> But kind * -> * (and any other)
09:58:03 <Cale> :t return
09:58:04 <lambdabot> Monad m => a -> m a
09:58:09 <Cale> Here, m :: * -> *
09:58:09 <ski> jusss : i don't understand the question "what this ADTs is special to other type system in java?"
09:58:11 <lyxia> hyperisco: how is list higher kinded
09:58:33 <jusss> Cale: yeah, that's really wonderful, I like those a->b , 
09:58:39 <Cale> jusss: In Java, C#, etc. they let you have type variables of kind *
09:58:43 <dminuoso> ski: I suppose the notion of "higher-..." works in different dimensions.
09:58:44 <Cale> but not of kind * -> *
09:58:50 <Cale> which makes Monad really hard
09:58:58 <hyperisco> lyxia, you're drawing me into a senseless debate :P
09:59:09 <ski> hyperisco : speaking of `List :: * -> *' ?
09:59:17 <lyxia> Well my point is it's not higher-kinded
09:59:21 <hyperisco> step 1) introduce inconsistently defined terms, 2) argue for hours
09:59:58 <lyxia> When people say there's no HKT in rust or whatever, I think that's a pretty accurate statement
10:00:17 <Cale> jusss: Not to mention the things we get on to a little way down the road, which have quite fancy kinds:
10:00:19 <jusss> Cale: you mean they can't implement (Just 'whatever') as a value?
10:00:20 <Cale> :t lift
10:00:21 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
10:00:31 <Cale> Here, t :: (* -> *) -> * -> *
10:00:56 <Cale> jusss: No...
10:01:02 <nshepperd_> ski: it supports higher kinded generics, iirc
10:01:02 <ski> dminuoso : yes, which is why i don't like "higher-kinded (type (function))", because it doesn't exhibit a clear analogy to "higher-order (value (function))"
10:01:15 <nshepperd_> (but it didn't really have kinds, i guess)
10:01:24 <Cale> jusss: I mean that... you know how Java has things like List<A> where A is a variable type?
10:01:32 <dminuoso> ski: Interesting, that instantly clicks.
10:01:52 <dminuoso> ski: And I wholeheartedly agree with your decision to prefer "higher order types" over "higher kinded types"
10:01:53 <ski> nshepperd_ : ok, i thought you were talking about algebraic data types
10:01:59 <hyperisco> lyxia, if what you mean is there are no  (* -> *) -> *  types, or similar, then yes. If what you mean is there are no type variables of kind  * -> *  then also yes.
10:02:03 <jusss> Cale: sorry I don't 
10:02:09 <Cale> jusss: ah, okay
10:02:37 <dminuoso> ski: Though if we look deep enough, then functions themselves are higher order values, no?
10:02:58 <jusss> I really should learn java at some time I think
10:03:14 <ski> dminuoso : somehow i tend to think most of this is obvious, so i'm surprised that people don't already see what i'm complaining about, and perhaps more surprised that, sometimes, when i try to explain, they're actually convinced (rather than already understanding what i mean, but having a different opinion re the terminology) ..
10:03:15 <dminuoso> jusss: You probably should yes, especially after having dived into Haskell.
10:04:09 <dminuoso> jusss: Or rather, if you have the desire to do so, you should. :)
10:04:19 <ski> (nshepperd_ : yes, i mentioned earlier that templates can have template parameters)
10:04:51 <dminuoso> ski: Dont know how much that is worth without parametricity though.
10:05:13 <jusss> dminuoso: yeah, but there're so many other optional languages 
10:05:38 <jusss> dminuoso: like kotlin or scala, 
10:06:05 <ski> dminuoso : "higher-order" here means something like "takes functions as parameters (or return them as results, but that's not emphasized as much in Haskell due to prevalence of currying)". so we're basically talking about values/types whose types/kinds look like `(... -> ...) -> ...'
10:06:51 <ski> dminuoso : we could say that such values/types (which must be functions) are second-order functions. so "higher" here means "of greater order than `1'"
10:06:52 <jusss> I wonder how many languages you guys learn?
10:07:09 <dminuoso> ski: But isn't the tower of "values are order 0, functions taking values are order 1, functions taking functoins are order 2" similar to the one we construct with RankNType?
10:07:20 <jusss> I learn scheme, js, python and haskell now
10:07:21 <dminuoso> (By "construct" I mean "think about")
10:07:52 <ski> dminuoso : "Dont know how much that is worth without parametricity though." -- "that" being what ?
10:07:56 <dminuoso> ski: Monad
10:08:09 <dminuoso> ski: I mean a Monad template template in C++.
10:08:21 <ski> dminuoso : yes, i was going to mention higher-rank
10:08:30 <ski> ah, ok
10:09:08 * dminuoso idly wonders whether we should prefix our messages with a sort of discussion ID, since at times we have a habit to diverge into several topics at the same time
10:09:23 <ski> dminuoso : a polymorphic value is of rank `1'. a function taking (requiring) a polymorphic value as input has rank `2'. a function taking such a function as input has rank `3', and so on
10:09:28 <hyperisco> lyxia, if I talked about a higher-typed value, I must be talking about a higher type, so I must be talking about something like Maybe, but Maybe has no inhabitants, so I must be talking about nonsense
10:09:49 <dminuoso> ski: Ah so I have an off-by-one error in my tower of orders then.
10:09:50 <ski> (and then, if there's no `forall' involved in the type at all, we'd say "rank `0'" .. but that's really disconnected from the above)
10:10:20 <ski> dminuoso : not with the order of functions, at least
10:10:46 <ski> a function like `not' is of first order, `interact' is second order, and so on
10:10:51 <hyperisco> lyxia, but if you can decode the lexicon for me I'd be pleased to be straightened out
10:10:55 <ski> `False' could be said to be zeroth order
10:11:08 <dminuoso> Ah right.
10:11:15 <dminuoso> ski: I was a bit too hasty with that.
10:13:04 <hyperisco> many times I was instructed that "higher kind" meant * -> * or * -> * -> * or something like this, but definitely not *
10:13:12 <dminuoso> ski: Does any similar ranking exist with dependent types? That is, can a dependent type be parametrized over another dependent type?
10:13:34 <hyperisco> therefore when one says HKT they would be referring to some type of kind * -> *, say, and that obviously exists, such as List
10:13:43 <dminuoso> That is, can you have: Pi (x :: (Pi (y :: D). C(d))). B(x) in dependent languages?
10:13:45 <hyperisco> what doesn't exist are type variables with kind * -> *
10:13:47 <lyxia> hyperisco: well the definitions you gave earlier look good to me.
10:14:02 <dminuoso> Or wait.. no I got that wrong.
10:14:05 * ski ought to remember `interact' as an example of a second order function, which is not polymorphic
10:14:31 <ski> dminuoso : sure
10:15:04 <ski> it's just the dependent version of higher-order functions (and their respective types with left-nested `->'s)
10:15:39 <lyxia> hyperisco: the confusion you mention is common though
10:15:47 <ski> hyperisco : hm. at least for "higher order", that typically means "of order greater than one"
10:15:48 <dminuoso> ski: Ah so something like  (Pi (x :: D). B(x) -> D) -> C  would be a DependendRank2Type?
10:15:57 <dminuoso> *DependentRank2Type
10:16:05 <hyperisco> ski, well we
10:16:23 <hyperisco> 're not blessed with "order", it is just "higher"
10:16:54 <hyperisco> a "higher order X" takes or returns an X, that must seems straight-forward to me
10:17:28 <hyperisco> a "higher X" seems to be some Y that takes or returns an X, in certain parlance
10:17:40 <dminuoso> ski: Is there a name for the kind of forall/exists that Haskell gives us? Is that a type-dependent type system (as opposed to a value-dependent type system)? Is there a different word for it?
10:17:57 <ski> dminuoso : ".. would be a DependendRank2Type?" -- i suppose
10:17:59 <hyperisco> so, * -> * is a "higher kind" where Y = -> and X = *
10:18:39 <lyxia> To me, "higher-kinded" is a contraction of "of higher-order kind"
10:18:59 <ski> lyxia : .. that makes no sense to me
10:19:15 <lyxia> hmm ok maybe I goofed that
10:19:25 <lyxia> ski: do you have the right translation :)
10:19:34 <hyperisco> so, id is a higher value
10:19:49 <hyperisco> it is also a higher order value because it is also a value
10:19:51 <ski> lyxia : i consider `interact' to be a higher-order (value) function. but its type, `(String -> String) -> IO ()' is not a higher-order type (function). it's not a type function at all. it's the type of a higher-order value (function)
10:20:03 <hyperisco> but not all languages with higher values have higher order values
10:20:15 <dminuoso> higher-kinded would be something like `Box -> Box` or `(Box -> Box) -> Box`
10:20:23 <lyxia> higher-order type constructor, a type constructor parameterized by a type constructor.
10:20:24 <hyperisco> this just sounds silly but… with the right definitions it makes sense :P
10:20:35 <ski> lyxia : a higher-order type (function) is e.g. `MaybeT', having kind `(* -> *) -> *' .. and a higher-order kind would be yet another storey up in the tower, compared to `MaybeT'
10:21:17 <lyxia> well anyway, my mnemonic is HKT = can you write Functor in it
10:21:47 <ski> hyperisco : it seems to me that the terminology you're sketching doesn't conform that well with existing (less generic) terminology for "higher ..."
10:22:13 <ski> hmm
10:22:39 <hyperisco> I'm not sketching… I am just reporting :P
10:22:43 <ski> so you're distinguishing "higher values" (in this particular context) from "higher order values" .. hmm
10:22:45 <dminuoso> hyperisco: Well (->) itself would be a higher-order kind (of order 1).
10:22:51 <dminuoso> That is, (->) the kind.
10:23:17 <dminuoso> (->) :: Box -> Box -> Box
10:23:55 <hyperisco> dminuoso, yeah I agree
10:24:01 <ski> dminuoso : "higher-kinded would be something like `Box -> Box` or `(Box -> Box) -> Box`" -- rather, it would be a kind whose .. "sort" ? .. is something like `(Box -> Box) -> Box', no ? .. that "sort" itself wouldn't be higher-kinded
10:24:40 <dminuoso> ski: Oh yeah, that was poorly phrased.
10:24:44 <ski> lyxia : except you can't define a type constructor which can only be parameterized by type constructors
10:24:46 <dminuoso> ski: I should have said "kinds of ..." :)
10:25:44 <ski> dminuoso,others : .. i'm sorry if i'm being overly pedantic about things like this, but in this sort of discussion, i think it can help
10:25:45 <dminuoso> ski: That is "higher-kinded would be kinds of sort `Box -> Box` or `(Box -> Box) -> Box`..
10:25:59 <hyperisco> well I agree with dminuoso's misstatement in its misstated form :P
10:26:45 <ski> i think, traditionally, "higher order" implies order (strictly) greater than one
10:27:29 <ski> perhaps one ought to distinguish between "proper higher order" and "(possibly) improper higher order", and allow the latter to have order `1' as well ?
10:27:45 <hyperisco> or we should do what is also traditional
10:27:51 <ski> (and then, by convention, an unqualified "higher order" means "proper higher order")
10:28:00 <hyperisco> and that is to precede proper technically discussion with a definition of terms
10:28:48 <hyperisco> Because traditionally, standards are hard to come by. Also in modernity.
10:28:59 <ski> well .. we're sortof trying to sort out what would be sensible definitions of terms (or different sets of such definitions)
10:29:26 <dminuoso> ski: Looking back, I had some serious problems understanding what "HKTs" referred to. I think it was in part because of the poor choice of the word "kind" there.
10:29:48 <ski> attempting to cover traditional convention as much as reasonably, but still perhaps sometimes deviating from that, in case it makes things simpler in the long run (aka scalable)
10:30:28 <ski> dminuoso : i've had a problem with the term, ever since i heard/read it
10:30:47 <ski> s/i /i first/
10:31:26 <ski> also, i have a problem with `PolyKinds' and `ExistentialQuantification'
10:31:52 <dminuoso> ski: Curious, why ExistentialQuantification? Because you'd expect an `exists` rather than a `forall` that sort of acts as an exists after you construct a value?
10:32:28 <dminuoso> data Foo = Foo (exists a. Maybe a)
10:33:20 <lyxia> ski: Fix :: (* -> *) -> *  is that not an example of type constructor only parameterized by a type constructor
10:34:26 <dminuoso> ski: I suppose PolyKinds for looking as if it meant 
10:34:29 <dminuoso> "polymorphic kinds"
10:34:41 <dminuoso> (And we had the discussion on this topic a few days ago)
10:36:13 <dminuoso> ski: While we are at it, we should rename Semigroup into Semimonoid. :o)
10:36:42 <lyxia> ski: pedantism is why I entered this discussion so I don't blame you for that :)
10:39:12 <hyperisco> if we're clever enough, Rust might even have HKTs by the end!
10:41:51 <tabaqui> what is semimonoid?
10:43:21 <hyperisco> tabaqui, not a clue, but it means less properties than a whole Monoid
10:43:41 <hyperisco> a left semimonoid has a left identity and a right semimonoid has a right identity… I dunno :)
10:44:45 <Solonarv> hyperisco: that actually sounds so plausible it might be in a published text
10:46:42 <tabaqui> err, https://en.wikipedia.org/wiki/Semigroup#Identity_and_zero
10:46:53 <tabaqui> at least wiki know nothing about semigroups with left-identity
10:47:04 <tabaqui> I mean doesn't know special term
10:47:07 <georg> Hello, when I am getting Exception: stack overflow, is there a way to find out which function does that? To get smth like a stackstace perhaps? Thanks!
10:47:16 <georg> (in ghci)
10:47:19 <tabaqui> btw, I think that "base" has a lack of Magma
10:49:26 <tabaqui> georg: https://www.reddit.com/r/haskell/comments/5s5khf/how_to_get_a_proper_stack_trace/
10:49:44 <tabaqui> shortly: ghc foo.hs -prof
10:49:50 <tabaqui> ./foo +RTS -xc
10:50:19 <tabaqui> it's a better link probably https://wiki.haskell.org/Debugging
10:50:41 <Solonarv> don't you also need -fprof-auto or something?
10:50:53 <Solonarv> anyway, check the GHC manual for details
10:51:31 <hyperisco> Solonarv, I am sure I studied something similar to this a couple years ago… hrm. There were identities sort of… like look here
10:51:51 <hyperisco> Solonarv, assuming just left identity, (mempty <> x) <> x = x <> x = x <> (mempty <> x) = (x <> mempty) <> x
10:52:03 <hyperisco> Solonarv, so we get  (mempty <> x) <> x = (x <> mempty) <> x
10:52:51 <bachibuzuk> hi
10:52:53 <hyperisco> second x could be a y but w/e
10:52:55 <georg> tabaqui: thanks! how do you use it w/ cabal run? -prof is unknown it says
10:53:01 <tabaqui> well, you definetly can define left XOR right identity, and everything will be fine
10:53:19 <tabaqui> georg: uh, I use stack actually
10:53:33 <tabaqui> it has special flags in build section
10:53:53 <tabaqui> like enable-library-profiling/enable-executables-profiling
10:54:05 <hyperisco> it is on the tip of my tongue… hrm
10:54:33 <georg> ah apparently there is    ghc-options: in .cabal
10:54:37 <tabaqui> georg: try to add flags in your "ghc-options:"
10:55:51 <Solonarv> please don't
10:55:54 <Solonarv> there is a cabal option for this
10:56:18 <Solonarv> ah, --enable-profiling
10:56:38 <tabaqui> Solonarv: how one can store it in .cabal file?
10:56:40 <hyperisco> pretty sure they called them normals, or something
10:57:02 <Solonarv> tabaqui: you don't store that in your .cabal file
10:57:15 <Solonarv> and really, unless you want to build with profiling *every time* you should not store it at all
10:58:05 <hyperisco> oh, I think I was actually studying regular semigroups, which are different
10:58:22 <hyperisco> those have sort-of inverses rather than sort-of identities
10:58:31 <tabaqui> Solonarv: I see no issues to store it under cabal debug flag
10:58:50 <tabaqui> s/issues/troubles/
10:58:51 <Solonarv> if you must
10:59:19 <Solonarv> but passing 'enable this flag' doesn't seem more convenient than passing --enable-profiling to me
10:59:56 <monochrom> Oh abusing ghc-options for profiling?!
11:00:09 <hyperisco> it is your calling monochrom!
11:00:20 <monochrom> Look, if this is an in-house private super-secret package, then sure, who care.
11:00:29 * Solonarv cheers
11:00:47 <tabaqui> monochrom just invaded our reality
11:00:50 <Solonarv> I knew there was someone in here who'd explain it better than me!
11:00:55 <hyperisco> humans are creatures of habit though
11:01:17 <monochrom> But if there are going to be other users, then putting it in ghc-options means it will be super-annoying to a user who want to disable profiling.
11:01:26 <dmwit> tabaqui: The trouble with putting it under a flag is then you won't get your dependencies rebuilt with profiling.
11:01:40 <monochrom> Profiling should be a user choice not an author choice.
11:02:42 <tabaqui> well, for me personally it's convenient to have "release" and "development" flags in projects
11:03:14 <monochrom> Sure. I'm done reminding you of the trade-off.
11:03:14 <tabaqui> split-objects, haddock is for release and profiling is for development
11:03:25 <tabaqui> all of these flags requires fresh rebuilding
11:03:47 <tabaqui> (except of haddock)
11:03:55 <monochrom> Afterall, who am I?  I am the person who just yesterday said it's OK to upload an acme package that won't build.
11:04:34 <Solonarv> to be fair it is an acme package
11:04:42 <monochrom> >:)
11:04:55 <Solonarv> those are only built by hackage's CI bots
11:05:00 <Solonarv> at least I hope so!
11:05:14 <Solonarv> one might even say an acme package that doesn't build is a good thing :P
11:05:31 <monochrom> A meta joke of sorts.
11:27:22 <ski> dminuoso : `ExistentialQuantification' -- because it doesn't introduce an existential quantifier. it introduces one way to *encode* existential quantifiers (which is something different)
11:27:42 <ski> lyxia : no, i can say `Fix (Either String)', and `Either String' is not a type constructor
11:28:38 <ski> `Semimonoid' .. hmm
11:30:11 <ski> dminuoso : iirc LHC and UHC had *actual* existential quantifier `exists' (but only to the left of an `->' (and in argument types of data constructors in `data' and `newtype' declarations, i imagine), which is the "easy" case)
11:31:01 <lyxia> ski: okay I had another definition of type constructor in mind
11:31:13 <ski> i suppose i'm still sortof hoping we'll get actual `exists' in GHC some day (possibly with restrictions and so on, but still). and then the name `ExistentialQuantification' by rights would belong to such an extension
11:31:22 <ski> lyxia : *nod*, the other, older one
11:31:27 <ski> (i was suspecting so)
11:32:21 <ski> what's currently called `ExistentialQuantification' could perhaps better be called `ExistentialDataConstructors' (or just `ExistentialConstructors', perhaps)
11:35:22 <tty1> So there is one thing about haskell im not totally digging but wanted to chat about it here in case it is the result of my noobness
11:37:07 <tty1> I find i often have to hide redundat data for the purposes of performance in my data types. Stuff like maps that index on certain data for speed. Normally in oo you can hide these elements as private but in haskell it seems you just need to let the user deal with the internal structure and hope they keep consistency if they manipulate it...
11:37:27 <tty1> am i missing something?
11:37:56 <boj> tty1: perhaps create controlled function accessors instead of giving direct access to the data structure?
11:38:14 <ski> possibly combined with pattern synonyms
11:39:24 <ski> it would sometimes be nice to be able to request caching the result of some particular functions, on a `data' type
11:39:30 <tty1> boj: well thats what im doing but i still need to pass them the data object so they can feed it into the functions i provide. It also means they cant write their own functions that deal with the object directly, which may itself cause ineffiencies if it needs to be converted back and forth
11:39:38 <ski> like if you have
11:39:46 <ski>   data Tree a = Tip
11:39:59 <ski>               | Node a (Tree a) (Tree a)
11:40:12 <ski>   depth :: Tree a -> Int
11:40:27 <ski>   depth  Tip         = 0
11:40:36 <ski>   depth (Node a l r) = 1 + max (depth l) (depth r)
11:41:09 <ski> you'd like to be able to request `Tree a' caching `depth', effectively giving you
11:41:55 <boj> tty1: it is hard to comment without knowing your use case, but why would you want a user to directly manipulate your data structure? you are providing the API, right?
11:41:59 <ski>   data Tree a = CachedTree {depth :: Int,treeCell :: TreeCell a}
11:42:16 <ski>   data TreeCell a = TipCell
11:42:37 <ski>                   | NodeCell a (Tree a) (Tree a)
11:43:21 <boj> tty1: if there are sub-sets of it that you want a user to directly manipulate, maybe offer a function which takes their custom manipulation function as a parameter?
11:43:41 <tty1> boj: well im writing a graph theory library. So they might want to manipulate the structure of a graph for example. Like if they wanted to delete all nodes/edges with an odd weight or something arbitrary
11:43:51 <ski>   pattern Tip :: Tree a
11:44:12 <ski>   pattern Tip <- CachedTree _ Tip
11:44:14 <tty1> boj: hmmm yea i forgot you can pass functions as arguments... yea that may be useful, hmmm
11:44:14 <ski>     where
11:44:17 <fizbin> Does anyone know how to build a program with a profiling version of the base library? It seems that when I use stack it always pulls in a binary build of ghc and so I end up with non-profiling versions of all the libraries ghc ships with.
11:44:27 <ski>     Tip = CachedTree 0 TipCell
11:44:41 <ski>   pattern Node :: a -> Tree a -> Tree a -> Tree a
11:45:14 <ski>  pattern Node a l r <- CachedTree _ (NodeCell a l r)
11:45:16 <ski>     where
11:46:07 <ski>     Node a l@(CachedTree ld _) r@(CachedTree rd _) = CachedTree (1 + max ld rd) (NodeCell a l r)
11:46:17 <ski> .. something along those lines
11:46:22 <tty1> hmmm
11:47:42 <ski> (`treeCell' wouldn't be a visible identifier, of course. nor would `CachedTree',`TreeCell'. and record construction and update with `depth' would be disallowed, only allowing it to be used as a function)
11:48:23 <ski> tty1 : perhaps you can, manually, do something along the lines of the above ?
11:48:55 <tty1> ski: i have to copy and paste it first, a little unreadable here, give me a minute to grok
11:49:32 <ski> tty1 : you may want to peruse <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pattern-synonyms>, for the pattern synonym parts
11:51:13 <ski> tty1 : but even just "smart constructors" (being operations that you export instead of your data constructors, but which may do extra precondition checking, converting to an equivalent, but more handy, form, and perhaps other processing, like computing cached info like the depth above) can be nice
11:51:48 <tty1> ski: smart constructors are the current approach im taking
11:52:46 <tty1> ski: just seems limiting because it means the user is expected not to look inside or modify the data structure on their own in any way. So they must rely on my API to be complete for every possible use case
11:53:24 <tty1> ski: so "pattern" is a haskell keyword?
11:54:14 <ski> in case you enable `PatternSynonyms', yes
11:54:16 <tty1> I wonder why i havent seen this covered in the books i read. Clearly im still missing a lot of knowledge
11:54:29 <ski> this is a relatively new language extension
11:54:37 <c_wraith> tty1, it's sometimes worth exporting an interface for "everything here is safe" and a second one for "this can break all your invariants, but it's available if you need it"
11:54:37 <tty1> ohh its a languae extension... probably why it wasnt covered
11:55:07 <c_wraith> tty1, by "interface", I mean "set of modules" there.
11:55:26 * ski . o O ( `Blah.Internal' )
11:55:47 <c_wraith> tty1, libraries like ByteString are an example of that approach.
11:56:48 <tty1> hmmm
11:58:01 <tty1> man haskell is taking me longer than most languages to learn
11:58:25 <tty1> i usually pick up a new language the first day enoough to be useful
11:58:30 <zincy_> How can I randomly generate Nat singletons within a range?
11:58:39 <sarahzrf> tty1: probably most of the languages you've learned have enough in common that you can carry over a lot of your knowledge
11:58:49 <boj> tty1: that is quite common. it turns out you have to *unlearn* a bunch first, if you have prior experience
11:59:03 <sarahzrf> if you haven't used something in haskell's family of languages before, you can't bring so much over
11:59:12 <tty1> sarahzrf: yes thats it for the most part
11:59:15 <sarahzrf> think of it as learning your first language
11:59:19 <sarahzrf> that probably took a while :)
11:59:36 <zincy_> sarahzrf: Or your last :P
11:59:44 <boj> indeed
11:59:46 <tty1> this is my first functional language aside from maybe javascript which. barely see as functional
11:59:51 <zincy_> It is hard to go back
11:59:57 <sarahzrf> ehh
12:00:03 <boj> i cannot willingly use anything else these days
12:00:07 <sarahzrf> i wouldnt oversell it :v
12:00:25 <zincy_> I kid, it isn't a panacea
12:00:34 <tty1> haskell is fun, whether its powerful and useful im not sure yet... im not good enough to judge that
12:01:03 <zincy_> tty1: You will feel really unproductive for the first stages
12:01:07 <boj> you definitely don't want to be writing hard real time systems in it
12:01:21 <sarahzrf> the thing about haskell, for better or for worse, is that it does a lot less compromising than the vast majority of practical-for-writing-programs-in languages
12:01:27 <boj> or embedded systems
12:01:41 <zincy_> Rust and Haskell seem like a good combo
12:01:51 <dmwit> zincy_: Can't. Make a SomeNat instead.
12:01:55 <sarahzrf> i used to be a huge zealot about that, but lately ive been thinking a bit more about the downsides
12:02:23 <zincy_> dmwit: How would I randomly generate my singleton constructors for SomeNat?
12:02:45 <dmwit> someNatVal :: Integer -> Maybe SomeNat ought to be enough.
12:02:50 <dmwit> There are other ways.
12:03:04 <sarahzrf> i tend to get pissy at people who reflexively go like "having types is restrictive!", but ive started to come around to some of the more nuanced relatives of that take
12:03:56 <zincy_> you can simulate dynamic types though with type families right
12:04:01 <sarahzrf> lol
12:04:10 <sarahzrf> im not sure
12:04:13 <boj> sarahzrf: it's worth considering. a lot of devops tooling is written in dynamic languages. i feel like forcing it to be typed ould be awkward
12:04:13 <sarahzrf> but i wouldnt want to
12:04:15 <dmwit> You don't even need type families. Just GADTs.
12:04:29 <dmwit> If you don't mind not being able to make any observations, even regular ADTs will do.
12:04:30 <sarahzrf> boj: oh certainly there's plenty of things i vastly prefer to use ruby for than haskell
12:04:33 <zincy_> hehe :D
12:04:34 <sarahzrf> ruby is my guilty pleasure :]
12:04:45 <zincy_> sarahzrf: elixir?
12:04:51 <sarahzrf> never really worked with it
12:05:19 <sarahzrf> ruby is where i go to get the primordial desire to write something really hacky and excessively clever out of my system
12:05:29 <sarahzrf> actually no i still do that in haskell sometimes :>
12:05:41 <jle`> you can simulate dynamic types with just normal haskell types, heh
12:05:46 <jle`> that's what Data.Tynamic is for :)
12:05:53 <dmwit> newtype D = D (D -> D) -- the untyped lambda calculus, embedded in Haskell (but no good observations are possible)
12:06:16 <boj> ooo, Tynamics! type safe dynamic stuff
12:06:16 <zincy_> See nearly a panacea
12:06:28 <sarahzrf> but idk im not just thinking about use cases where dynamic languages are more convenient
12:06:29 <dmwit> Data.Dynamic is already type-safe
12:06:53 <sarahzrf> im thinking about things like Building A Whole System, places where haskell really does have a lot of advantages and where id probably prefer to use it over, eg, python
12:06:57 <zincy_> dmwit: Why the Maybe, how could it fail if it takes an Integer, < 0 ?
12:07:05 <dmwit> zincy_: I believe yes.
12:08:56 <zincy_> dmwit: Do you have any clues on how to go from the Int to the SomeNat data constructor?
12:09:22 <zincy_> hmm typelits
12:09:28 <Solonarv> dmwit: I think there's a variant of that where you can actually make observations
12:10:06 <ski> @type GHC.TypeNats.someNatVal
12:10:07 <lambdabot> GHC.Natural.Natural -> SomeNat
12:10:15 <ski> zincy_ ^
12:10:22 <zincy_> Thanks
12:10:29 <dminuoso> ski: Curious, shouldn't that be Natural -> Maybe SomeNat?
12:10:30 <zincy_> Not seen ghc.Natural before
12:10:44 <dminuoso> ski: https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-TypeLits.html#v:someNatVal
12:10:45 <ski> dminuoso : it's `Natural' ?
12:10:48 <dmwit> Solonarv: data DO = O Int | D (DO -> DO) -- ;-)
12:10:56 <dminuoso> Oh wait, that's a different one. Huh
12:11:07 <tty1> zincy_: i feel pretty damn inefficient for sure. I'm lucky to write a line a day right now... Though my small markov chain library in haskell was a lot faster.
12:11:13 <sarahzrf> this is definitely not a revolutionary take, but i think ive started to /believe/ it more: the arguments in favor of type safety and uncompromisingness in design *are right* (imo) when applied in cases when the thing you're building is itself principled, and many of the arguments given for dynlangs *are* spurious (imo) when they are broadly applied as being about programming in general (as they sometimes
12:11:13 <tty1> to write
12:11:14 <dmwit> dminuoso: Natural -> SomeNat would be fine.
12:11:15 <dminuoso> Ah GHC.TypeNats is a different module
12:11:15 <sarahzrf> are), *but* unfortunately the real world is not exactly principled ;_;
12:11:26 <dmwit> dminuoso: In fact it is internally implemented in terms of a Natural -> SomeNat.
12:11:31 <zincy_> tty1: yep been there
12:11:31 <dminuoso> dmwit: No its alright, I was mixing up TypeLits and TypeNats there. :)
12:12:10 <sarahzrf> i suppose this is why there are more excellent haskell libraries than there are excellent written-in-haskell applications
12:12:11 <ski> @type GHC.Natural.naturalFromInteger
12:12:12 <lambdabot> Integer -> GHC.Natural.Natural
12:12:15 <ski> @type fromInteger :: Integer -> GHC.Natural.Natural
12:12:15 <dminuoso> sarahzrf: Which is why the average software quality on npm is incredibly low.
12:12:16 <lambdabot> Integer -> GHC.Natural.Natural
12:12:16 <Solonarv> dmwit: nah, it was still some kind of newtype over functions
12:12:22 <Solonarv> can't remember it though :/
12:12:26 <dmwit> Oh, I was also mixed up. I thought you were objecting to the Integer part of a different someNatVal, not the non-Maybe part of that one.
12:12:29 <Cale> sarahzrf: It seems to me that in very unprincipled settings with lots of changing requirements all the time, types are especially helpful.
12:12:33 <sarahzrf> dminuoso: hmm, not sure how that follows
12:12:48 <sarahzrf> Cale: oh i dont disagree
12:12:52 <boj> Cale: amen
12:12:54 <sarahzrf> i just mean like
12:13:19 <dminuoso> sarahzrf: The JS world is filled with people who believe that an unprincipled language with unprincipled design gets more problems done in less time.
12:13:21 <Cale> sarahzrf: In settings where the requirements are principled and don't change, you stand a chance of being able to hold all that in your head, and so dynamically typed languages can be okay
12:13:34 <sarahzrf> dminuoso: lol
12:13:49 <sarahzrf> dminuoso: it does get more problems done in less time, fsmo "get a problem done"
12:14:15 <sarahzrf> Cale: yeah i dont know if what im saying is necessarily at odds with what youre saying
12:14:15 <ski>   data OD = MkOD { o :: Int , d :: OD -> OD }  -- ?
12:14:22 <Cale> It's important to realise that dynamically typed languages do not free you from thinking about types even a little bit
12:14:26 <dminuoso> sarahzrf: I produce more code with much higher stability and less maintenance in Haskell than with JavaScript.
12:14:27 <sarahzrf> agreed!!
12:14:37 <zincy_> Cale: That is a fantastic insight!
12:14:53 <sarahzrf> dminuoso: oh, the implication was that i was interpreting "get a problem done" as meaning "get the task of creating a problem done" ;)
12:15:00 <zincy_> The types are still there whether you like them or not
12:15:39 <dminuoso> sarahzrf: Oh heh. I misunderstood. :)
12:15:43 <zincy_> A friend of mine said Elm's type system is amazingly powerful :)
12:15:47 <sarahzrf> ow
12:15:58 <zincy_> oh boy does he have a treat in store
12:15:58 <zincy_> one day
12:16:11 <sarahzrf> Cale: first-draft take: what you're saying is true for a reason something like "working in a principled setting forces you to convert a lot of your unprincipled work into someting principled, which is effective"
12:16:30 <dminuoso> zincy_: And I hear Agda or Idris people belittling Haskellers for not having dependent types... :-p
12:16:40 <sarahzrf> Cale: but what i'm saying comes from something like "but ultimately there is going to be coloring outside the lines"
12:17:00 <ski> @remember Cale It's important to realise that dynamically typed languages do not free you from thinking about types even a little bit
12:17:00 <lambdabot> Done.
12:17:08 <Cale> sarahzrf: Partly? But it's not exactly that. It's that even if you have a bunch of ugly structure, having a compiler that helps you navigate that ugly mess is better than having a compiler that doesn't.
12:17:08 <ski> (it's been said before, but ..)
12:17:26 <sarahzrf> ski: ive for sure felt that one when writing python before ;-)
12:17:34 <Cale> You can just define messy horrible types, if that's what's called for.
12:17:39 <zincy_> dminuoso: for now ...
12:17:42 <Cale> and it's *still* better than nothing
12:18:04 <Cale> You'll still get more done almost immediately thereafter :)
12:18:15 <dminuoso> Cale: Indeed. In a language where you have no compiler assistance, you have the burden of keeping track of all your mess and whether all your assumptions actually hold. So at some point you start building up piles of silly unit tests to test properties that any sane type system would check for you exhaustively.
12:18:22 <Cale> It'll pay for itself the moment that you have one new feature to implement
12:18:38 <Cale> Like, yeah, you paid to define an extra type
12:18:41 <sarahzrf> Cale: perhaps, but maybe having a fairly nice principled system occupying 95% of your code but with a trapdoor that the other 5% can work with, is better than having your whole thing more principled but uglier
12:19:01 <sarahzrf> what do you do in cases where you have a small feature you need to add that just doesnt fit neatly into what youve built?
12:19:12 <zincy_> The problems with trapdoors is that people use them
12:19:17 <sarahzrf> yeah =
12:19:19 <sarahzrf> =(
12:19:20 <Cale> sarahzrf: Change types, let the compiler tell me what to do
12:19:30 <sarahzrf> thats why im not really an advocate for trapdoors
12:19:47 <dminuoso> sarahzrf: Or how about a type system that is flexible enough so you dont need a trapdoor?
12:19:58 <tdammers> dminuoso: you mean instance Num String?
12:20:00 <zincy_> You will have someone on your team that is dying to do a tiny little thing for this once of edge case
12:20:02 <Cale> Like, the point is not to use types that are sufficiently flexible
12:20:07 <sarahzrf> yeah
12:20:09 <Cale> You don't even try to do that
12:20:11 <sarahzrf> flexibility is exactly what you *dont* want
12:20:24 <sarahzrf> Cale: well, i'm thinking about cases like -
12:20:25 <tdammers> but seriously, if you need trapdoors, then your types were wrong to begin with, and you should change them
12:20:27 <Cale> You make inflexible types that capture exactly what messy thing you're doing
12:20:32 <tdammers> IME trapdoors are infectious
12:20:36 <monochrom> Perhaps there are two opposite meanings of "flexible".
12:20:37 <Cale> then you change those when there's some new thing that doesn't fit
12:20:42 <zincy_> hehe
12:20:42 <zincy_> Viral disease yes
12:20:50 <Cale> and the compiler helps you change everything else in response to that
12:21:27 <monochrom> Where is maerwald when we need someone to "remind" us "Haskell has a trapdoor already, you can give up now".
12:21:37 <dminuoso> Types are an upgraded form of tests. To work in a language without tests is the same as willingly giving up on tests. *shrugs*
12:21:57 <sarahzrf> Cale: well, i'm thinking about cases like - suppose you develop a bunch of code that's all pure, and then suddenly you need a minor feature that necessitates causing an effect in a way that would be utterly horrible to try to do from outside your pure system?
12:22:07 <zincy_> So we are all doing TDD
12:22:08 <zincy_> All the time
12:22:11 <sarahzrf> you could certainly redesign all of the code to allow effects!
12:22:15 * ski . o O ( "Sacrificing the calf of flexibility on the altar of reliability" by Peter J. Denning in 1976 at <http://dl.acm.org/ft_gateway.cfm?id=807704&type=pdf> )
12:22:32 <sarahzrf> and there's a lot to be said for creep once you start adding effects into random places!
12:22:44 <zincy_> yes
12:22:49 <sarahzrf> but like
12:23:02 <Cale> sarahzrf: Somehow I just haven't done that a whole lot, except in trivially small cases.
12:23:06 <tdammers> it's actually not just the types
12:23:17 <tdammers> it's structure and abstractions in general
12:23:22 <boj> you can certainly make terrible design decisions, but at least the type system will guide you towards a working implementation
12:23:27 <tdammers> you code something up, you see patterns, you abstract over them
12:23:36 <tdammers> and then the code needs to change, and your abstractions no longer work out
12:23:41 <sarahzrf> either you do a bunch of redesigning now, to make the system accomodate effects, in ignorance of what other requirements you might need in the future - or you bolt on some hacks, and once you have a stronger sense of what requirements youre drifting towards, *then* you can turn the hacks into something reasonable
12:23:46 <Cale> But in any case, it's important to realise that the pure code got away with not expressing a lot of things that the effectful code might depend on, so it makes a little sense that the refactor might be slightly involved.
12:24:00 <tdammers> you have two choices now - continue with the now incorrect abstractions and build trapdoors, or tear the abstractions down and build new ones
12:24:08 <Cale> It depends on the situation...
12:24:20 <tdammers> the sooner you notice the incorrectness, the easier it is to choose the "tear down" route
12:24:27 <sarahzrf> tdammers: i am absolutely in favor of replacing trapdoors with abstractions
12:24:42 <Cale> Often it just comes down to breaking the pure thing into smaller parts, so that effects can be appropriately interleaved between those parts
12:24:48 <sarahzrf> what ive become more uncertain about lately is what the right methodology is for that process
12:24:50 <ski> sarahzrf : "suppose you develop a bunch of code that's all pure, and then suddenly you need a minor feature that necessitates causing an effect" -- CTM mentions this problem
12:24:55 <Cale> (and which is better for testing etc. anyhow)
12:24:56 <sarahzrf> CTM?
12:25:00 <ski> @where CTM
12:25:00 <lambdabot> "Concepts, Techniques, and Models of Computer Programming", by Peter Van Roy,Seif Haridi, at <http://www.info.ucl.ac.be/~pvr/book.html>
12:25:08 <tdammers> yes, but the economics are often such that you notice the trapdoors too late, and then rebuilding the abstractions amounts to rewriting the whole damn thing
12:25:15 <sarahzrf> but that's the thing -
12:25:20 <sarahzrf> you have to rewrite the whole damn thing anyway :(
12:25:36 <Cale> Well, when has that ever been such a large amount of code?
12:25:37 <sarahzrf> the question is whether you do it *before* or *after* you've met face to face with the requirements
12:25:38 <tdammers> sure, but I prefer to do it one bit at a time
12:26:06 * ski . o O ( "leaky abstractions" )
12:26:19 <tdammers> and types help with the "noticing incorrect abstractions" part, because more often than not, an incorrect abstraction first manifests in difficulties capturing your intent in types
12:26:26 <boj> sarahzrf: as someone how has done what you describe, it's not that bad in practice, and my team's code base is even easier to work with :)
12:26:27 <sarahzrf> i absolutely agree!
12:26:31 <Cale> I don't know, I've only very rarely run into cases where the amount of pure code was so substantial that the thought of reworking it to involve effects was in any way daunting.
12:26:47 <Cale> Well, I should say, I've basically never run into such a case.
12:26:56 <Cale> Depending on what we mean by "daunting", I suppose.
12:27:05 <tdammers> not to mention that "add effects" isn't an all-or-nothing thing
12:27:10 <Cale> Yeah
12:27:13 <sarahzrf> hmm, well, i'm not a professional programmer, so a lot of my thoughts have been based on a fairly narrow scope of experience - maybe im making incorrect extrapolations about what happens in practice :0
12:27:32 <tdammers> you can, for example, express the behavior of your formerly-pure code in a very restricted EDSL that can only model a selected handful of desirable effects
12:27:48 <Cale> sarahzrf: Most of our code is already in some monad anyway :P
12:27:55 <tdammers> monad transformers and free monads are mainly about this
12:27:59 <monochrom> ski: I suddenly have the evil idea that this is consistent with transitioning from the richer unix shell (e.g., "rm *.o") to the poorer Windows file explorer (e.g., now you have to ctrl-click a hundred icons to specify what to delete). >:)
12:28:03 <sarahzrf> cards on the table: one major non-firsthand source of the impressions ive had which have led to me making the arguments ive just been making was this post https://programmingisterrible.com/post/176657481103/repeat-yourself-do-more-than-one-thing-and
12:28:05 <sarahzrf> ;p
12:28:18 <ystael> Cale: that's right, it literally all starts with :: (SomeMonad m) => ..., right?
12:28:39 <monochrom> In particular the transition is both towards less flexible and more marketable bwhahahaha
12:28:49 <ski> monochrom : "this" being ?
12:29:01 <tdammers> sarahzrf: "DRY" is an unfortunate name for the underlying principle
12:29:02 <monochrom> The Peter Denning paper!
12:29:25 <ski> ah
12:29:33 <Cale> ystael: Haha, yeah, it's not even in a particular monad, it's in a monad which satisfies some properties
12:29:53 <tdammers> sarahzrf: the principle being "single source of truth". every truth about the problem / problem domain should be expressed in exactly one canonical location, and that location should express only that particular truth and nothing else
12:29:58 * ystael checks hackage for some-monad and monad-with-some-properties 0.0.0.1
12:30:04 <tdammers> sarahzrf: or, if you prefer, call it "orthogonality"
12:30:42 <Cale> ystael: I believe you misspelled "reflex-dom"
12:30:51 <sarahzrf> idk, i feel like what youre saying is part of a broader ideology which is being overall critiqued/examined by that post
12:31:02 <dminuoso> monochrom: The Peter Denning paper seems hard to obtain, sadly.
12:31:08 <ystael> Cale: hah
12:31:12 <sarahzrf> and to be clear: the ideology in question is one which i naturally gravitate toward and have been a major partisan of
12:31:17 <Cale> https://github.com/reflex-frp/reflex-dom/blob/develop/reflex-dom-core/src/Reflex/Dom/Prerender.hs#L56
12:31:22 <dminuoso> Not even the websites for one-eyed sailors have it in stock.
12:31:33 <sarahzrf> im just trying to weigh what might be worth criticizing about it :)
12:31:49 <ystael> Cale: that's ... definitely some properties there
12:31:50 <dminuoso> sarahzrf: I dont think its an idiology question, really.
12:31:57 <monochrom> dminuoso: Oh! I happen to be on campus today, so implicitly using campus network, and campus has a campus-wide license to ACM paywall (and many other paywalls).
12:31:58 <sarahzrf> it is absolutely an ideology
12:32:10 <sarahzrf> I don't mean that derogatorily to be clear
12:32:19 <monochrom> So I just clicked and "it worked" and I didn't even notice. :)
12:32:25 <dminuoso> monochrom: Heh. :S
12:32:33 <monochrom> You want a smuggled-out copy?
12:32:34 <Cale> ahaha, I hadn't even noticed: Client (Client m) ~ Client m
12:32:45 <tdammers> sarahzrf: as far as I can tell, the only real downside is that there is a real danger of enjoying the process of refining your abstractions so much that you don't know when to stop; sometimes the results are mind-blowingly beautiful and elegant, sometimes they just end up being insanely useful, and sometimes you just end up nerd-sniping yourself
12:32:57 <sarahzrf> read that post, it's interesting :P
12:33:28 <tdammers> oh, and also, IME there is a bit of a schism wrt programming philosophy, between the "principled" and the "pragmatic" camps
12:33:32 <Cale> The constraints are pretty fun in some of this stuff -- but hey, you have the same code running on the backend and frontend to render static HTML and then take it over with dynamic widgets after JS loads.
12:33:38 <sarahzrf> even if you disagree with it, i think it's worth chewing on
12:33:54 <Cale> and honestly, you mostly don't even worry about all this most of the time somehow
12:34:01 <dminuoso> sarahzrf: Trap doors are usually the vehicle if your type system constrains you so much, that you cant express your idea in the type system. So either you give up on type guaratees, try to simplify/change your problem, or you extend the type system to be more flexible.
12:34:06 <monochrom> dminuoso: http://www.cs.utoronto.ca/~trebla/tmp/p384-denning.pdf
12:34:57 <sarahzrf> dminuoso: well, again, the problem is that in many settings you cannot get away with always having a particular idea
12:35:18 <Cale> sarahzrf: I definitely agree with the notion that we ought to rewrite and refactor things agressively. I don't feel comfortable doing that without a type system to help, personally.
12:35:39 <sarahzrf> well, that's why i still prefer typed languages to untyped languages :-)
12:35:46 <Cale> aggressively*
12:36:12 <tdammers> sarahzrf: oh, and one more note - IMO that article you linked suffers from OOP tunnel vision. many of the problems it describes are inherent to the OOP paradigm, and even to its practical incarnations, but as long as OOP (and primitive procedural coding) is all you know, you won't see it
12:36:13 <sarahzrf> at this point i think whatever devil i'm advocating for is less opposed to typed programming than it is to the ideology of typed programming
12:36:33 <Cale> In a lot of dynamically typed settings, it's *way* more important to get your foundations right from the beginning, because you get locked into a design very quickly.
12:37:05 <tdammers> Cale: my biggest beef with dynamic languages is how they inevitably form a turing tarpit sooner or later
12:37:06 <Cale> It becomes very hard to change things and have any confidence that the program will ever work again
12:37:26 <sarahzrf> tdammers: hahahaha
12:38:15 <tdammers> on paper, you have a maximally malleable language, you can change anything you want, at any time - but the problem is you need to take responsibility for your changes, and as the codebase grows, the complexity of gaining sufficient certainty to actually know what the consequences of an intended change might be makes changing things practically impossible
12:38:20 <monochrom> Hrm, I would think that strongly static typing is still a turing tarpit as soon as you support "data D a = MkD (D -> a)"
12:38:22 <sarahzrf> a long time ago, before i had much experience (...not that i have much now, depending on what kind of experience you mean) i was a big fan of that fact
12:38:36 <boj> i refactored one of our code bases, something like +5k/-5k changes. One of my former Python engineers just stared at the PR and said, "damn, that would have been a rewrite in my previous life..."
12:39:03 <sarahzrf> er, s/that fact/the notion of a maximally malleable turing tarpit
12:39:05 <ski> monochrom : santa is missing his cap
12:39:20 <monochrom> ???
12:39:24 <tdammers> well, it is exactly the malleability that creates the tarpit
12:39:45 <tdammers> you can change anything anywhere at any time, but so can anyone else, including your past and future selves
12:39:45 <ski> monochrom : kind check it
12:39:52 <tdammers> so how do you negotiate the consequences?
12:39:55 <monochrom> Oh!
12:39:57 <Cale> One of my favourite moments in recent history was when we needed to change a client's application from being single-tenant to having a multi-tenant architecture (i.e. single backend processes using multiple separate database schemas per subdomain and securely serving different companies' data)
12:39:59 <monochrom> D a -> a
12:40:00 <tdammers> you have to do that manually, and that is a huge burden
12:40:37 <Cale> This kind of thing easily eats up months of time in other settings
12:42:01 <Cale> But it took a coworker and me just 2-3 days. For the most part, we changed a datatype having to do with the connection to the database such that it could also include a schema to be used for queries, and propagated the consequences of that change through the code.
12:42:10 <sarahzrf> yeah, this conversation *is* starting to make me think that maybe my takes on this topic are influenced negatively by never having really worked on a large codebase
12:42:16 <Cale> There were like 2 or 3 times where we had to make an actual decision
12:42:24 <Cale> all the rest was just following the compiler's instructions
12:42:51 <Cale> and the damn thing worked when we finished!
12:43:27 <sarahzrf> 🎉
12:46:47 <monochrom> There is a flip side I heard from other people that I don't like but I guess is true.  Dynamic typing is less discouraging during learning.  A dumb example from me (but I bet other people have better examples) is "if x>0 then 45 else "hello"", dynamic typing allows you to run it and get some preliminary results, static typing makes you fix it first and possibly a million other things before getting any result.
12:47:11 <boj> hmm, yeah
12:47:19 <boj> instant gratification
12:47:20 <monochrom> Psychologically speaking it is true that usually getting early results helps learning.
12:47:24 <tdammers> dynamic languages tend to be better at providing instant gratification
12:47:37 <Cale> Yeah, that's absolutely true -- for complete beginners, it is *really* encouraging to run something and have it do *anything* at all
12:47:48 <monochrom> I am a logician and I have always learned absolutely logically so I don't buy it. But I guess other people are different.
12:47:56 <tdammers> the disheartening stuff happens later
12:48:19 <tdammers> but at that point, the learner doesn't know any better :D
12:48:36 <boj> "refactor this 100k line project" - "... impossible. i will write v2 instead and fix my prior mistakes!"
12:48:40 <ski> monochrom : "Re: Mercury in academic teaching?" by Richard A. O'Keefe in 2006-10-(09-10) at <http://www.mercurylang.org/list-archives/users/2006-October/004000.html>,<http://www.mercurylang.org/list-archives/users/2006-October/004011.html> goes a bit into that
12:48:54 <monochrom> In Haskell, there is always "undefined" when you are still prototyping.
12:49:16 <monochrom> Speaking of which, I still need to tell my student the undefined or error "TODO" trick.
12:49:33 * ski . o O ( `-fdefer-type-errors' )
12:49:37 <dminuoso> monochrom: There's not in my code. :-p
12:49:46 <dminuoso> monochrom: I've trained myself over the past few months to stop using undefined for prototyping.
12:49:50 <monochrom> No, -fdefer-type-errors does not defer even my dumb example.
12:49:51 <dminuoso> At least whenever possible. :)
12:50:06 <merijn> -fdefer-typed-holes
12:50:21 <monochrom> ski yes that's basically where I heard that position from.
12:50:44 <merijn> Why would you ever used undefined and/or -fdefer-type-errors when we have typed holes and -fdefer-typed-holes? :)
12:50:47 <monochrom> I think he also posted this in haskell-cafe? Because I read haskell-cafe but not mercury lists.
12:51:01 <cocreature> merijn: because I’m too lazy to enable -fdefer-typed-holes
12:51:02 <ski> yea, i've mentioned these posts before, in here :)
12:51:11 <monochrom> Wait there is -fdefer-typed-holes?
12:51:21 <merijn> monochrom: Yes, I added that like 4-5 years ago
12:51:23 <Solonarv> o_O I did not know that was a thing
12:51:27 <merijn> It was my first GHC contribution
12:52:01 <merijn> Because I thought -fdefer-type-errors was dumb, I liked typed holes, but sometimes you just wanna run stuff without actually writing it like you can with undefined :p
12:52:13 <ski> dminuoso : what do you do instead, ooc ?
12:53:32 <monochrom> Oh w00t -fdefer-typed-holes rocks.
12:55:00 <monochrom> OK wait this is strange. I have "x = if 1>0 then 4 else _ ; main = print x"
12:55:45 <monochrom> Then I use -fdefer-type-errors but not -fdefer-typed-holes.  It runs fine, just with a warning that would be more consistent with -fdefer-typed-holes.
12:56:06 <monochrom> So is there an implication relation there?
12:56:23 <monochrom> Oh darn yes.
12:57:03 <monochrom> OK new advice is -fdefer-type-errors but use _
12:57:11 <merijn> Yeah, iirc -fdefer-type-erros implies -fdefer-typed-holes, but you can disable it
12:57:51 <monochrom> Yeah I was reading it in the GHC user's guide, turns out I just had to scroll up a bit to see the implies clause.
12:57:58 <merijn> monochrom: -fdefer-typed-holes warns with 0Wall
12:58:25 <merijn> I thought it always warned unless explicitly silenced, but looks like someone changed that (intentionally or not)
12:58:32 <merijn> Wouldn't be the first time someone broke it
12:58:34 <monochrom> Actually I never use -Wall.  It's OK, I still get "warning: [-Wtyped-holes]" etc
12:59:18 <merijn> Ah, wait, yeah it was something else that was not recompiling, good.
12:59:30 <monochrom> The mother of belay-that-order: -Ewarn = turn all errors into warnings  >:)
13:00:30 <monochrom> I really have that scene from Pirates of Carribean 3 in mind.  In which <A> Belay that order! <B> Belay that belay! Belay! Belay!
13:00:46 <oatmealraisin> Anyone running on arch linux? How am I supposed to use cabal with pacman packages on the system?
13:01:22 <merijn> oatmealraisin: Short answer: "You're not"
13:01:38 <sclv> oatmealraisin: arch's haskell setup is terrible
13:01:41 <monochrom> OK tea time! Belay all work.
13:01:59 <sclv> there's a wiki page detailing the mess https://wiki.archlinux.org/index.php/Haskell
13:02:04 <merijn> oatmealraisin: Arch maintainers have made some (questionable) choices that make almost any Haskell development superpainful if you try to use pacman installed things
13:02:21 <sclv> i highly recommend not going through the "dynamic" path there
13:02:34 <merijn> oatmealraisin: And they refuse to change this, my recommendation would be to just install GHC and cabal yourself and ignore pacman
13:02:36 <sclv> and instead just getting ghc static and nothing else, and using static linking
13:02:53 <sclv> oatmealraisin: or these days perhaps just using ghcup to get a ghc and cabal that's not packaged by arch at all
13:03:22 <merijn> ghcup and/or just the GHC bindists is probably the most portable/robust/reliable/predictable way to install GHC on *nix
13:07:04 <oatmealraisin> merijn: sclv That's unfortunate, because I have some packages with haskell dependencies. Thanks for the info
13:07:34 <sclv> you can use arch to manage packages with haskell deps
13:07:44 <sclv> if you decide to just use ghcup or a bindist to install your _development_ ghc elsewhere
13:07:48 <sclv> and independent
13:10:19 <jle`> um is there a MonadWriter without the Monad
13:10:25 <jle`> just like FunctorWriter or ApplicativeWriter or something
13:10:43 <merijn> jle`: What would that even do?
13:10:51 <merijn> jle`: That just sounds like a tuple, tbh
13:11:03 <monochrom> ApplicativeWriter may make sense.
13:11:45 <jle`> some sort of generic applicative context with an accumulating effect
13:11:51 <jle`> w.r.t sequencing
13:12:08 <c_wraith> doesn't Validations do that?
13:12:13 <jle`> class ApplicativeWriter w m | m -> w where tell :: w -> m (), etc.
13:12:18 <jle`> right but i'm looking for a polymorphic typeclass
13:12:24 <jle`> a unifying abstraction
13:12:47 * ski . o O ( s/polymorphic/parameterized/ ? )
13:13:11 <c_wraith> I think all the potentially-relevant abstractions were developed pre-AMP
13:13:29 <jle`> um basically i'm looking for something like how lens uses Profunctor, Strong, Functor, Applicative, etc.
13:13:55 <jle`> passing around constrained RankN functions
13:14:09 <jle`> MonadWriter would be perfect if it weren't for the Monad constraint
13:14:13 <merijn> Unrelated question: I have a "withFoo" style bracket that I want to wrap with another bracket, the tricky bit is: Part of my new bracket's allocation should happen outside the withFoo, but the 2nd part should be (the first thing) executed inside the withFoo
13:14:36 <jle`> that is, like how we have type Traversal' a b = forall f. Applicative f => (a -> f b) -> s -> f t
13:14:49 <jle`> i have a useful thing type Blah' a b = forall f. APplicativeWriter f => (a -> f b) -> s -> f t
13:15:27 <sclv> jle`: applicatives compose by Compose so its just any pair
13:15:40 <sclv> I think for that reason there isn't a typeclass for it :-)
13:15:42 <merijn> Writing a single layer like that is pretty simple, since I can just write a lambda that runs my effect and then the original code within withFoo. But I actually need to nest my own bracket a couple of times, and then it becomes non-obvious to me
13:15:54 <jle`> sclv: hm, fair enough
13:19:41 <orzo_> WHat's the memory-behavior of this code?  If I push often and read rarely, will it leak? https://lpaste.com/mtMWRWBBbG
13:22:22 <Solonarv> hm, I'd guess yes
13:22:33 <Solonarv> but this is something you should answer by profiling
13:24:22 <dmwit> jle`: Fight back! It may be any pair, but that doesn't give you the power to lift through the right number of compositions that ApplicativeWriter would give you.
13:24:22 <orzo_> I think I'll change line 14 to: pushFront a (Give3 f) = Give3 (\g -> f (\b c d -> d `seq` g a b c))
13:24:31 <Solonarv> that won't help
13:24:36 <Solonarv> the problem isn't strictness
13:24:43 <Solonarv> (or laziness)
13:24:59 <jle`> dmwit: that is also fair! :O
13:25:08 <jle`> i ended up making a throaway typeclass
13:25:10 <Solonarv> the problem is that (\g -> f (\b c _ -> g a b c)) retains 'f'
13:25:24 <Solonarv> and f retains all the previously-pushed elements
13:25:58 <MarcelineVQ> jle`: you might want to hang onto it, just in case
13:26:06 <Solonarv> so basically you keep holding on to the elements that were pushed off the back, even though you don't need them anymore
13:27:25 <orzo_> Solonov, but wont evaluating the back node when cause a lot of that to have an opportunity to be freed?  It can't free f, but it can free the f of f of f
13:28:12 <Solonarv> again, the problem is not laziness
13:28:15 <gentauro> why does the compiled version not print out the text "Password"? (but the script does?) -> https://gitlab.com/spisemisu/cleanse-facebook/blob/master/src/CFB.hs#L66-68
13:28:23 <Solonarv> the problem is that the GC doesn't know you don't need the back nodes anymore
13:28:24 <gentauro> kind of "spooky" at least ...
13:29:12 <Solonarv> the solution is to, instead of building up ever-larger closures, actually call them at some point
13:29:39 <merijn> hmm, I think this looks like a job for ContT...I'm sure this time my brain won't leak out my ears...
13:30:01 <Solonarv> change the last case to:
13:30:01 <Solonarv> pushFront a (Give3 f) = f $ \b c _ -> Give3 $ \k -> k a b c
13:30:10 <orzo_> okay
13:30:13 <ski> merijn : could you elaborate ?
13:30:20 <Solonarv> note how we're immediately calling 'f', which allows unneeded references to be dropped
13:30:47 <merijn> ski: On ContT leaking my brains or the initial bracket question? :p
13:31:01 <orzo_> yes, i see
13:31:06 <ski> merijn : are they related ?
13:31:13 <merijn> ski: Pretty much :p
13:31:21 <ski> merijn : but i was thinking re the first question, yes
13:34:34 <merijn> ski: Basically, I'm using "withCreateProcess" (well, not exactly, but similar. It spawns a subprocess in a bracket and runs a bunch of stuff). Now, I just stdin/stdout/stderr isn't sufficient for my communication needs, so I'm creating additional pipes to communicate over, which I'd like to make a new bracketing function for. Now the problem is that I need to close the end of the pipe that I'm not using, 
13:34:40 <merijn> but I can only do that *after* the subprocess has been created (else the pipe is useless), so that needs to happen inside the withCreateProcess
13:36:19 <MarcelineVQ> was it coyondena people use to manage resources? can't recall just now. that doesn't sound quite right, it was cosomething..
13:36:28 <merijn> ski: So, for nesting a bunch of these bracket Cont/ContT is useful, and I realised I can probably use mapContT to "prepend" the closing action to the actual stuff inside withCreateProcess
13:37:34 <MarcelineVQ> mentioning it in case it applies to merijn's problem and someone knows what I'm trying to refer to hehe
13:40:18 <rthenko> Hello.
13:40:23 <merijn> I just gotta make sure I don't think too much what the ContT stuff is doing :p
13:40:23 <gentauro> rthenko: Yellow
13:40:27 <ski> @hoogle withCreateProcess
13:40:27 <lambdabot> System.Process withCreateProcess :: CreateProcess -> (Maybe Handle -> Maybe Handle -> Maybe Handle -> ProcessHandle -> IO a) -> IO a
13:40:27 <lambdabot> UnliftIO.Process withCreateProcess :: MonadUnliftIO m => CreateProcess -> (Maybe Handle -> Maybe Handle -> Maybe Handle -> ProcessHandle -> m a) -> m a
13:40:28 <MarcelineVQ> Codensity maybe
13:41:04 * MarcelineVQ is surprise to not see a "you could have invented cont" blog post when searched. Though there's some good ones on it by other names.
13:41:22 <ski> merijn : `Coyoneda' ?
13:41:41 <ski> @type mapContT
13:41:42 <lambdabot> forall k (m :: k -> *) (r :: k) a. (m r -> m r) -> ContT r m a -> ContT r m a
13:42:22 <ski> hm, that doesn't tell me whether it precomposes or postcomposes or both
13:43:06 <merijn> ski: Neither, right?
13:43:39 <merijn> It's (m r -> m r) so if you just pass in (myaction >>)" then it runs myaction before the original
13:43:43 <zincy> @type mapContT . mapContT
13:43:44 <lambdabot> forall k (m :: k -> *) (r1 :: k) r2 a. (m r1 -> m r1) -> ContT r2 (ContT r1 m) a -> ContT r2 (ContT r1 m) a
13:44:23 <rthenko> I'm a reasonably good Java programmer, I'm learning functional programming with Haskell and let me tell you that "using" recursion for problem solving is so hard for me. I know "what" recursion is, I know about the base case, the recursive case etc. But problem is I don't know "how" to actually do stuff with it. Any suggestions?
13:44:38 <ski> "Apply a function to transform the result of a continuation-passing computation." -- ok, so post-compose
13:44:48 <merijn> rthenko: The only real suggestion is *lots* of practice
13:44:57 <MarcelineVQ> yeah pretty sure I'm thinking of Codensity, dunno if that's useful for you merijn
13:45:01 <merijn> ski: I don't think that matters, though?
13:45:23 <merijn> ski: Like I said, if I look at the source then simply passing in "(foo >>)" should have the desired result
13:45:24 <ski> merijn : yes (to `(myaction >>)' thing)
13:47:18 <merijn> rthenko: I remember when I was taught FP in class and had to do a lot of recursive manipulation of lists I understood jack all of what I was doing and why, but at some point between then and now, my brain switched and now I find it far easier to think in recursion than loops
13:47:24 <Cale> rthenko: Start by practicing writing functions that manipulate lists using pattern matching
13:48:41 <Cale> rthenko: Lists are basically loops that are waiting to happen: just as a loop either has no iterations (because its precondition isn't met), or consists of an iteration followed by another loop, a list is either empty, or consists of a single element followed by another list
13:49:26 <Cale> Once you get used to that, recursion involving other data types becomes a bit easier.
13:49:45 <gentauro> Cale: I like your analogy of "recursion = while loop with termination condition"
13:49:48 <gentauro> :)
13:50:10 <gentauro> rthenko: just recurse until you reach a condition and return your data
13:50:17 <rthenko> merijn so we can do anything a loop ('for' loop in Java for example) does using recursion? I don't know why I think recursion is used only in a few places.
13:50:28 <Cale> rthenko: But another thing to note is that we don't really want to be writing everything recursively either. The goal is to write higher order functions, and use those.
13:50:44 <gentauro> rthenko: at the begining, try to add accumulators, it will easy the understanding. Once you get a grip, try to do recursion without accumulators ;)
13:50:48 <ski> merijn : so, what does your current source for this extended version of `withCreateProcess' look like ?
13:50:51 <Cale> rthenko: A loop is just a special case of recursion.
13:50:54 <Solonarv> rthenko: in most languages, writing recursive code will explode your call stack and generally lead to Bad Things along the same lines
13:51:13 <ski> MarcelineVQ : `Codensity' for managing resources, in which way ?
13:51:35 <ski> (`Codensity' is related to `ContT' and to `Cont', yes)
13:51:54 <merijn> Right now it's just a regular bracket
13:51:55 <gentauro> Solonarv: if you do bad code, but imperative (thx to mutability) can actually make some "decent" recursive implementations (sequential-wise)
13:51:56 <Solonarv> Codensity is basically ContT's well-behaved sibline
13:52:17 <rthenko> Cale thanks :)
13:52:21 <gentauro> Solonarv: I mean, quicksort for example
13:52:34 <Solonarv> gentauro: no, I mean if you write recursive functions and try to traverse a 500-element list you will get a StackOverflowException
13:52:36 <merijn> gentauro: quicksort is an awful sort, though :p
13:52:45 <gentauro> which, btw, is a really bad algo to try to implement with Haskell
13:52:55 <merijn> gentauro: It's a bad algo in any language
13:53:09 <merijn> I'm 100% convinced the only reason quicksort is popular is because it's named "quick"
13:53:14 <Cale> rthenko: One thing which is sort of unrelated, but might help you is that you can translate imperative programs into functional ones in a bit of a funny way which is nonetheless worth knowing
13:53:17 <gentauro> merijn: time complexities says otherwise :P
13:53:18 <merijn> It has, essentially, nothing going for it
13:53:28 <rthenko> gentauro thanks :)
13:53:28 <merijn> gentauro: Quicksort is O(n^2) worst case
13:53:39 <Cale> rthenko: What you do is to turn each point of control in the imperative program (each place where the program counter can be) into a function
13:53:44 <merijn> gentauro: It's complexity is pretty bad
13:53:45 <ski> @quote are.waiting.to.happen
13:53:45 <lambdabot> Cale says: You should think of lists as being like loops which are waiting to happen.
13:53:48 <ski> @quote combination.with.laziness
13:53:48 <lambdabot> Solonarv says: simple linked lists are not a particularly great *data* structure, but in combination with laziness they make a pretty good *control* structure
13:53:52 <gentauro> merijn: by choosing your pivot randomly, we can get it down to O(n lg n) :P
13:54:02 <gentauro> didn't you study CS (CRLS book for the win) :D
13:54:04 <Cale> rthenko: You turn all the mutable variables in scope into function parameters
13:54:14 <merijn> gentauro: Right, but there are other sorts that are ALSO O(n log n) that have n log n worst case complexity
13:54:24 <Cale> rthenko: and then you have the functions apply each other to new arguments based on how the control flow goes, and how the variables are changing
13:54:25 <merijn> gentauro: i.e. mergesort is ALWAYS O(n log n)
13:54:46 <merijn> gentauro: Actually, I suppose it could be faster, but it's never slower, unlike quicksort
13:54:51 <gentauro> merijn: but with twice the space
13:55:00 <merijn> gentauro: Not to mention quicksort is notoriously tricky to implement correctly
13:55:01 <gentauro> unless you implement an "in-place" merger
13:55:22 <merijn> gentauro: in-place mergesorts exist and as a bonus they have better cache/memory access patterns too!
13:55:23 <Cale> rthenko: So if there's a loop, this will result in mutual recursion between all these different functions that represent the places where your program might currently be
13:55:56 <gentauro> merijn: you want to go heapsort 
13:56:06 <gentauro> in-place + O (n lg n)
13:56:09 <gentauro> ;-)
13:56:09 <Cale> i.e. each function computes the final result of the imperative program from its current state starting from some point in the program
13:56:20 <Cale> does that make sense? I suppose I could make up an example..
13:56:35 <merijn> gentauro: So basically: Quicksort is bad as a "simple example sort" (since merge sort is both MUCH easier to remember/implement and has better complexities), quicksort is also bad as high performance sort (poor memory access patterns, hard/impossible to parallelise, and hard to do "out of memory" on large data)
13:56:56 <merijn> gentauro: So the main real "quality" is that the name implies that it is quick
13:57:17 <gentauro> merijn: you know it isn't quick if it's part of the name :P
13:57:31 <gentauro> I remember from my thesis having to study C/C++ insertion sort
13:57:45 <ski> @where C/C++
13:57:45 <lambdabot> "C/C++ : A new language for the new Millennium" by Richard Heathfield in 2005-02 at <http://web.archive.org/web/20090421080714/http://www.cpax.org.uk/prg/portable/c/c++/rfe00000.html>
13:58:27 <gentauro> @where lambda
13:58:28 <lambdabot> I know nothing about lambda.
13:58:32 <rthenko> Cale actually this is why I've started learning Haskell, I don't know why but I've done this from day 1 of writing Java. I don't know why other people programs seemed like "dirty and all over the place" so that's why I started turning everything into functions. I didn't know about Haskell but even my Java code had a lot of little functions. A friend told me to take a look at Haskell and I really liked it.
13:58:35 <gentauro> @where SKK
13:58:35 <lambdabot> I know nothing about skk.
13:58:48 <gentauro> @where horse
13:58:48 <lambdabot> I know nothing about horse.
13:58:56 <gentauro> lambdabot: you are pretty useless :(
13:59:39 <rthenko> Cale I have no problem in understanding Monads etc, but this recursion . . .
13:59:41 <gentauro> merijn: but time complexities isn't everything
13:59:51 <gentauro> otherwise we would all be suing `bitonicsort` :P
14:00:01 <merijn> gentauro: Right, see: quicksort has a terrible access pattern :p
14:00:13 <Cale> rthenko: Sometimes in order to understand obfuscated imperative programs, my first step was using this kind of strategy to turn them into pure functional ones, and then because I have a bunch of *equations* I can start to simplify the expressions until I hopefully approach something easier to understand
14:00:53 <Cale> You can usually immediately start to make many simplifications, because many of the functions you introduced will only be used in one place
14:01:22 <Cale> and so it just becomes like highschool algebra, substituting things according to what they're equal to
14:02:09 <rthenko> Cale You're right, thanks :)
14:03:27 * ski constructed a flow-chart in head, turned it into C code with `goto's (into and out of a `for' loop). it was a solution for a backtracking problem
14:04:42 <ski> Cale : yea .. when you started writing that, i was thinking ".. but why make every sequence point into a function, rather than just the ones with multiple in-edges ?"
14:05:57 <gentauro> ski: speaking of C. Ken Friis (at http://osd2019.compute.dtu.dk/program.htm) showed today that if you use C to generate your WASM, you can do all kind of nasty crap. He said: "We just went 30 years back with regard of buggy code" 
14:06:04 <gentauro> :|
14:06:28 <Solonarv> ski: could've done the exact same thing with a rat's nest of functions tail-calling each other
14:06:40 <Solonarv> oh wait, into and out of a for loop
14:06:41 <Solonarv> ew!
14:07:03 <Cale> ski: yeah
14:07:14 <ski> Solonarv : that was the fun part of it ! ;)
14:11:06 <MarcelineVQ> ski: I'm not sure exactly, I haven't gotten around to using it myself, has been reccomended to me by others here
14:12:09 <ski> Solonarv : basically, i implemented something similar to section "Power Loops" (p. 49) in chapter 2 "Control Structures" in the book "Advanced Programming Language Design" by Raphael A. Finkel in 1996 at <https://web.archive.org/web/20150522052725/http:/www.nondot.org/sabre/Mirrored/AdvProgLangDesign/finkel02.pdf>
14:12:34 <ski> MarcelineVQ, ok
14:12:42 <MarcelineVQ> ski: related, though I've not read yet https://www.fpcomplete.com/blog/2014/08/iap-speeding-up-conduit
14:13:34 <MarcelineVQ> important bullet and reason it came to mind "Efficient usage of scarce resources, such as closing file descriptors as early as possible."
14:14:14 <ski> MarcelineVQ : `Codensity' can be used for similar efficiency concerns as introducing an accumulator rather that right-appending repeatedly to a list
14:14:58 <z0> ive created an operator `a >== b = either Left (Roght . b) . a` but ive a feeling I can use <$> instead
14:14:59 <ski> (the latter can be done as "difference lists", if you want to. perhaps one could call `Codensity', "difference monad" ??)
14:15:30 <ski>   a >== b = fmap b . a
14:15:38 <ski> or `(b <$>) . a', if you prefer
14:15:50 <ski> @type \a b -> fmap b . a
14:15:51 <lambdabot> Functor f => (a1 -> f a2) -> (a2 -> b) -> a1 -> f b
14:16:38 <Solonarv> % :t \a b -> fmap @(Either w) b . a
14:16:39 <yahb> Solonarv: ; <interactive>:1:23: error: Not in scope: type variable `w'
14:16:45 <Solonarv> % :t \a b -> fmap @(Either _) b . a
14:16:45 <yahb> Solonarv: forall {a1} {w} {a2} {b}. (a1 -> Either w a2) -> (a2 -> b) -> a1 -> Either w b
14:17:23 <z0> oh thanks
14:17:28 <z0> dont know how i missed that
15:32:17 <tty1> is it possible to do pattern matching on elements of a map as I would an array?
15:44:46 <argent0> tty1: nop
15:45:17 <argent0> also: and by array, do you mean `List`?
15:46:15 <tty1> yes List
15:46:26 <tty1> oops
15:46:30 <tty1> misread
15:46:57 <tty1> yes I meant List
15:47:37 <argent0> tty1: you could use Map.lookup and pattern match on its result
15:48:47 <argent0> @hoogle Map.lookup
15:48:47 <lambdabot> Data.Map.Internal lookup :: Ord k => k -> Map k a -> Maybe a
15:48:48 <lambdabot> Data.Map.Lazy lookup :: Ord k => k -> Map k a -> Maybe a
15:48:48 <lambdabot> Data.Map.Strict lookup :: Ord k => k -> Map k a -> Maybe a
15:59:27 <shapr> Is there some way I can build a Haskell *script* ? Maybe like runhaskell but the package names are discovered for me?
16:00:30 <jackdk> both stack and nix can be used as shebangs, I think?
16:00:45 <sm> shapr: there's stack scripts, and I dimly remember they can auto-discover packages from your imports
16:01:26 <shapr> so maybe I want something like runcabal?
16:01:27 <shapr> hmm
16:03:16 <Cale> shapr: Well, do you have a .cabal file?
16:04:44 <shapr> Cale: nah, I want to convert a python script into a Haskell script
16:05:28 <shapr> is there some trick where I can put build-depends in the #! line at the top? perhaps runghc -package containers ?
16:06:02 <hpc> stack exec?
16:06:04 <hpc> :P
16:06:09 <hpc> maximum overhead
16:06:36 <shapr> so, let's say I don't want to use stack ...
16:07:14 <MarcelineVQ> https://www.haskell.org/cabal/users-guide/nix-local-build.html#cabal-new-run
16:07:55 <shapr> MarcelineVQ: aha, thanks!
16:09:39 <shapr> I know cabal has some auto-discover package logic, now I just have to figure out how to plug that in too
16:11:06 <shapr> I want to deduplicate imports and build-depends
16:13:56 <dmwit> The only such logic I know of requires you to already have the packages installed.
16:14:09 <shapr> I'd be okay with that
16:14:19 <sm> I know you are looking for non-stack, but here's the doc saying stack script infers packages from imports: https://haskell.fpcomplete.com/tutorial/stack-script#script-interpreter (it's not in the manual)
16:14:23 <shapr> dmwit: is cabal building an index from the .hi files or something?
16:14:59 <shapr> sm: neat, it picks them up as params?
16:15:04 <dmwit> ...no?
16:15:06 <sm> I assume so
16:15:28 <dmwit> It's shipping out to ghc-pkg.
16:15:43 * shapr reads docs for ghc-pkg
16:16:50 <dmwit> Try ghc-pkg find-module Data.List, e.g.
16:17:17 <dmwit> Um. It occurs to me that because there were two conversations going on, we may have crossed wires.
16:17:36 <shapr> dmwit: that's awesome, I love it!
16:17:37 <dmwit> I am saying that cabal's package discovery logic ships out to ghc-pkg. Stack's probably doesn't (and cabal's probably *shouldn't*.)
16:17:58 <shapr> I had no idea find-module existed!
16:18:06 <shapr> dmwit: what's a better way?
16:18:19 <dmwit> Look in the index it has of all packages available on Hackage.
16:18:35 <shapr> hm, sensible
16:18:45 <dmwit> (This index includes all the .cabal files, and so has access to all the exposed-modules stanzas.)
16:19:53 <shapr> so if I can parse the import lines of a Haskell script, I could fill out the -package foo part of a cabal v2-run script automagically
16:20:25 <dmwit> Sounds like a fair bit of work. But in principle possible, yes.
16:20:56 <shapr> I just want Haskell scripts that work like Python scripts
16:22:12 <dmwit> But, like... you're not going to be able to sensibly infer version bounds unless you have a *much* bigger appetite for this work than I'm imagining.
16:29:51 <shapr> dmwit: I'm fine only choosing from installed packages, but would ghc-pkg see what's in cabal new-update? it wouldn't?
17:03:23 <zeta_wolf> hello guys, a couple of weeks a ago someone pasted a job posting(if i can remeber correctly the company was called luna), if you could pastebin a web link to the logs, i can't seem to find the companies website
17:04:08 <zeta_wolf> do any of you guys remember?
17:05:37 <shapr> zeta_wolf: if you google "haskell luna jobs" does that find it?
17:10:44 <zeta_wolf> shapr: thanks
17:13:25 <jle`> zeta_wolf: the logs are also in the /topic :)
17:13:41 <jle`> for future reference
17:14:55 <zeta_wolf> ok, good to know
17:18:43 <zeta_wolf> also, i am getting into freelancing and want to know, is the demand for functional programming languages like haskell growing? i have been learning haskell for a while and want to start using it for freelancing.
17:19:45 <boj> unlikely
17:20:38 <zeta_wolf> boj: unlikely?
17:22:36 <boj> zeta_wolf: it's hard to find good full time developers, so looking towards freelancers isn't even on my radar
17:24:58 <boj> of course, you could find clients who don't particularly care what you build their product in
17:27:02 <zeta_wolf> boj: well i am looking to work remotely full time, whether it be freelancing or with a company, in terms of haskell i am a junior developer.
17:30:01 <boj> zeta_wolf: there have been a lot of hiring posts on r/haskell lately, might be worth looking at
17:30:51 <zeta_wolf> boj: ok, i'll take a look at that, thanks for the heads up
17:33:08 <jle`> zeta_wolf: also keep an eye out for listings on Haskell Weekly News :)
17:33:53 <zeta_wolf> jle`: thanks
17:47:08 <sm> shapr: python scripts don't auto-fetch packages, do they ?
18:11:06 <vpei[m]> 😉
18:20:06 <argent0> let's say have a project with the folder structure of: "project/lib" , "project/frontend1", "project/frontend2". Where forntend* have different dependencies but both depend on lib. The question is how would I set up a build system for such project.
18:21:37 <argent0> Or how do I tell cabal that frontend1 has a dependency in "project/lib"? Or Should I make one big project with all the dependencies of frontend 1 and 2?
18:21:37 <maerwald> argent0: check cabal: https://github.com/haskell/cabal/
18:21:49 <maerwald> https://github.com/haskell/cabal/blob/master/cabal.project
18:22:50 <maerwald> so when you install cabal-install it looks up the cabal.project and knows that Cabal (the library) is part of the "project" and builds it from that folder
18:24:12 <argent0> maerwald: Ok, I'll check that up. Thanks
18:25:31 <sm> is cabal.project equivalent to a stack.yaml ?
18:26:36 <maerwald> sm: kinda
18:27:07 <maerwald> you can also overwrite dependencies with scm versions of git etc
18:27:25 <sm> cool
18:40:56 <orzo_> Is there a way to copy a thunk so that it is not evaluated when the copy is?  Like, say I have an infinite list at the top-level, and some code evaluates a bunch of that list and hangs on to an end tail of it.  Later, some other code wants to use the list.  I want to be sure this later code has to regenerate the list from the start.
18:42:13 <orzo_> Maybe that's the default behavior for top-level infinite lists.
18:42:25 <orzo_> otherwise, they'd be hard to use without leaking.
18:53:47 <cjay-> orzo_: afaik that can be done by using (abusing?) https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Exts.html#v:oneShot
18:55:22 <cjay-> do some memory profiling to see if it's successful
18:55:57 <cjay-> the "right" way is probably using explicit streaming instead of a list
19:07:08 <orzo_> cjay-: experimenting with debug.trace seems to indicate that my list is being re-evaluated anyway.
19:09:05 <cjay-> orzo_: interesting. Now the question is if you can rely on it always being that way though.
19:11:35 <cjay-> iirc the term for top-level values that are not functions is CAF, maybe that will help when searching for answers
19:18:41 <dmwit> orzo_: Top-level lists are not re-evaluated. However, if it is typeclass-polymorphic, then "evaluation" is a slippery topic; it will be "evaluated" down to a function that accepts a typeclass dictionary, but each time you provide that dictionary the body of the function will be restarted as is the case for all functions (no automatic memoization).
19:20:11 <dmwit> orzo_: Also, as far as I know, the direct answer to your question is "no, there is no way to copy a thunk". It would indeed sometimes be useful, and I think some folks have done a bit of work on it, but didn't push it all the way through to inclusion in GHC proper.
19:21:55 <dmwit> (oneShot doesn't appear to be sufficient for this task; for one thing it doesn't promise that things get reevaluated, only says maybe that happens, and for another, its type restricts it to functions only.)
20:37:50 <habbah> I have serversession-backend-persistent-1.0 and serversession-frontend-yesod-1.0 in the extra-deps section of stack.yaml. In package.yaml, I have a dependency for yesod-core >=1.6 && <1.7 and persistent >=2.9 && <2.10. when I add those two libraries to my dependencies within package.yaml and attempt to build I receive an error
20:38:48 <habbah> Error: While constructing the build plan, the following exceptions were encountered: In the dependencies for serversession-backend-persistent-1.0: persistent-2.9.2 from stack configuration does not match ==2.1.*  (latest matching version is 2.1.6)   as wel as   In the dependencies for serversession-frontend-yesod-1.0: yesod-core-1.6.14 from stack configuration does not match ==1.4.*  (latest matching 
20:38:54 <habbah> version is 1.4.37.3)
20:41:18 <habbah> It recommends adding persistent-2.1.6@sha256:a692679eeb7ee7ea3772fc1a57d47a6a4be71412478d6361ed9e5a9ec79388f6 and yesod-core-1.4.37.3@sha256:574bcc8079527a5caae88a76f877b09bae7b4bce96ee3537955aff3122baf941 to extra-deps
20:42:46 <habbah> If I do that though, I will have to change base, conduit, exceptions, resourcet, and probably others. what is the recommended course of action in situations like this?
20:46:09 <jackdk> I don't use stack, but maybe you can bump your snapshot version to get more recent versions of those libraries?
21:11:21 <jusss> I don't know why there's Maybe type, what it's used for? why use Just to combine that 3 or "3" to generate a new value Just 3? the purpose is to describe Just 3 or Just "3" with the same Maybe a ?
21:13:03 <jusss> use Maybe a to describe Just 3, Just "3", Nothing?
21:13:56 <ski> the purpose is to allow for the possibility of `Nothing'
21:14:42 <jusss> safeLog x | x > 0 = Just (log x)   | otherwise = Nothing,   why not just if x>0 then log x else Nothing?
21:14:42 <ski> let's say you want to associate some `String's with `Integer's
21:14:52 <ski> okay
21:14:57 <ski> that doesn't work
21:15:04 <ski> `Nothing' is not a number
21:15:29 <jusss> ski: can I think Nothing is like None in python or nil in scheme?
21:15:43 <ski> if you call `safeLog x + 1', then the `+ 1' part is going to expect a number, and so can't handle a `Nothing', if `safeLog x' computes that
21:15:46 <jusss> None, null, nil, blablabla
21:17:31 <ski> jusss : yes and no
21:17:31 <jusss> ski: what's the good if we return Just x to +1?
21:17:41 <ski> we can't do that
21:18:16 <ski> we can do `case safeLog x of Nothing -> "sorry"; Just y -> "answer is : " ++ show (y + 1)'
21:19:42 <ski> jusss : have you seen Riastradh's "Option types, optional parameters" blag entry in 2006-02-03 at <https://mumble.net/~campbell/blag.txt> ?
21:20:11 <jusss> ski: not yet
21:20:23 <ski> that explains part of what `Maybe' is for, from the POV of a Schemer
21:20:38 <ski> since you mentioned Scheme, perhaps that'd help you get a better understanding
21:20:56 <jusss> this stuff just came to my mind a few hours ago
21:21:03 <ski> search for "Option types, optional parameters" or "2006-02-03", in that long blag document
21:21:08 <jusss> ok
21:21:35 <ski> if you really want to, i suppose you could also ask Riastradh himself, in #scheme
21:26:10 <ski> > lookup 5 [(2,1),(3,1),(5,2),(6,2),(11,4),(13,4),(17,8),(19,6)]
21:26:13 <lambdabot>  Just 2
21:26:18 <ski> > lookup 9 [(2,1),(3,1),(5,2),(6,2),(11,4),(13,4),(17,8),(19,6)]
21:26:20 <lambdabot>  Nothing
21:27:24 <ski> in this case, we could have the first case instead compute `2', and the second case compute a dummy value, like `0' or `-1', that indicates failure to lookup the key in the association list (expressing a finite map, a funite partial function, from integers to integers in this case)
21:28:00 <ski> however, what if we'd also like to use `0', or `-1', as possible value in a key-value pair in the association list ?
21:28:45 <ski> in Python, i think one'd compute `None', and in Scheme, usually `#f'. in Java (in case the value type is an object type), one'd use `null'
21:29:03 <ski> but this has the same "domain contagion" problem Riastradh is talking about
21:29:27 <ski> also, allowing `null' as a potential value of any expression of object type (in Java) is its own can of worms
21:30:31 <ski> we'd really like to be able to say "look, in these cases, there should never be a `null' here. i shouldn't have to check for it possibly being `null', it should simply be impossible for a `null' to come here"
21:31:12 <ski> one way of doing that would be to say that an expression of type `String' (an object type in Java), say, can never be `null'
21:31:37 <ski> however, an expression of type `String?' (a "`null'able `String' type") could possibly be `null'
21:32:00 <ski> Java doesn't do this, but istr people having experimented with this idea
21:32:32 <ski> this is better than the situation in Java, because now we can distinguish between the case "may be `null'" from "can't ever be `null'", in the types
21:33:03 <ski> however, what if we'd like or values in out finite map not to be `String's, but `String?'s ?
21:33:34 <ski> so, a succesful lookup could then compute a `null', since that's then a valid value in an association (pair) in the association list / finite map
21:34:00 <ski> if we have the result type of the lookup still be `String?', we're back at the domain contagion problem
21:34:41 <ski> what we'd like here is to have the result type be `String??', which is to be distinct from a plain `String?'
21:36:19 <ski> iow, in a Java-like syntax, we'd like something like `<K,V> V? lookup(Map<K,V>,K);'. for any key and value types `K' and `V', given a finite map associating `K'eys to `V'alues, and a `K'ey, we'll get back a `V?', iow either a `V'alue, or `null'
21:37:04 <ski> however, what if `V' here is `String?' (assuming that's a first-class type that we can use anywhere a type can be used, and not just as a result type of a method) ?
21:37:41 <ski> then what we get as result type would be this `String??', which i mentioned. which ought not to be the same as a plain `String?', because otherwise we'll run into the "domain contagion" problem
21:37:41 <iqubic> Can't we just create the Maybe data type in an OOP language?
21:37:58 <ski> however, how can this be ?
21:38:02 <ski> iqubic : coming towards that
21:38:56 <ski> if the possible values of type `String?' are (a) the value `null'; and (B) the values `s' of type `String'
21:39:08 <ski> then what are the possible values of type `String??' ?
21:40:06 <iqubic> Well, a Haskell coder would say: [Char].
21:40:12 <ski> we'd get something like (a) the value `null' (e.g. representing failure of lookup); (b) the value `null' of type `String?' (e.g. a valid lookup result); (c) the values `s' of type `String' (also valid lookup result)
21:40:27 <ski> we'd really want to distinguish cases (a) and (b) here, to avoid domain contagion
21:40:37 <ski> but how can we distinguish them, if they're spelled the same ?
21:41:09 <iqubic> how do you do that?
21:41:46 <ski> the genius of `Maybe'/`Option' is to realize that we not only need (a) a "failure / missing" value; but also (b) need to realize that we shouldn't treat the values `s' of type `String' as also *being* values of type `Maybe String'/`String?'
21:41:58 <ski> `String' should not be a subtype of `Maybe String'/`String?'
21:42:47 <ski> so, when we want to express a `String' `s' as a "successful result" of a lookup like above, we can't just return `s', but we have to "wrap it", saying `Just s', which then has type `Maybe String'
21:43:35 <ski> (and then `String??' corresponds to `Maybe (Maybe String)'. so the three cases above have values (a) `Nothing'; (b) `Just Nothing'; and (c) `Just (Just s)', for all `String's `s')
21:44:25 <ski> this way, in lookup, we don't care whether the value type is itself `Maybe String'/`String?' (a "nullable type"), or some other type
21:44:35 <ski> we treat all cases uniformly, which is what we want
21:45:12 <ski> so, `<K,V> V? lookup(Map<K,V>,K);' in pseudo-Java would correspond in Haskell then to
21:45:28 <ski>   lookup :: forall k v. Map k v -> k -> Maybe v
21:45:55 <ski> @type Data.Map.lookup  -- this takes the arguments in the opposite order, but is otherwise the same
21:45:57 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
21:47:00 <ski> @type lookup  -- this is the same, except uses a plain association list, rather than the more efficient finite map implementation. otoh, it only needs equality support, rather than ordering support, on the keys
21:47:01 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
21:48:07 <ski> (btw, the initial `<K,V>' in the Java method signature corresponds exactly to the `forall k v.' in the Haskell version. although that `forall' part can be omitted, in which case it's implicitly inserted by the implementation)
21:49:18 <ski> anyway, even in a language without a static type system, like Python or Scheme, the same kind of issue with domain contagion can arise
21:49:34 <iqubic> It can?
21:50:45 <ski> it's just that, because there's no static type system, you can't control what things can *not* appears as values in your finite map. any valid value can go there (unless you explicitly forbid it to go there .. which would not be uniform, and would prohibit legitimate cases where one could, for various reasons, want to have `None' or `#f' as values)
21:51:46 <ski> and so, you *always* have the potential for this domain contagion. in the pseudo-Java case where the value type was the ("non nullable") type `String', `null's were not permitted as values
21:53:00 <ski> (of course, if you know what's to be in your finite maps, you may know you'll never put a `None'/`#f' there. but perhaps you're writing a library. or perhaps later you'll discover that you'd want to, somewhere in your program, allow `None'/`#f' as valid values in a finite map ..)
21:54:14 <ski> and so, you can use the same solution : which is to wrap "successful results" from `lookup', in something like `Just'. that way, if a valud can validly be `Nothing' (in Haskell terms), you'll get the successful result `Just Nothing', which is still distinct from the failure result `Nothing', as desired
21:54:23 <ski> <iqubic> Can't we just create the Maybe data type in an OOP language?
21:55:21 <ski> yes, you can create a `Maybe<A>' class (parameterized on the type `A'), in Java. possibly an abstract class. or, maybe it would be better to have this be an interface
21:55:32 <ricky_clarkson> ski: It's there already, named Optional.
21:55:43 <ski> then you could have a `Just<A>' subclass of this (or a class `Just<A> implementing this interface)
21:56:06 <ski> and also a `Nothing<A>' subclass (or class implementing the interface)
21:56:15 <ricky_clarkson> Its implementation probably doesn't resemble the Haskell version but there are implementations that do (functionaljava, iirc)
21:56:28 <iqubic> ski: Optional<A> exists in Java.
21:56:48 <ski> ricky_clarkson : ty. i haven't used Java much recently. just sketching out how you could implement this in Java
21:57:13 <ski> (i'm not surprised by them having added it, though. because it can really be useful)
21:57:29 <iqubic> https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html
21:57:52 <iqubic> That's the official documentation for Optional<A> from Java
21:58:12 <ski> (oh, and btw, instead of returning `null' in the failure case, another option is to raise an exception. and (for better or worse), you can't have an exception (a raised exception) as a value, e.g. in a finite map)
21:58:21 <ski> ty
21:59:32 <iqubic> ski: If you look at the documentation for Optional<A>, you see that the value accessor `get` throws an exception.
21:59:35 <ski> btw, the name `option' for this type comes from the ML world (SML,O'Caml)
22:00:14 <ski> iqubic : yes, that's because Java doesn't have pattern-matching, and they didn't feel like using the VisitorPattern for this simple case
22:00:57 <ricky_clarkson> iqubic: It feels strange mentioning this on #haskell but that get method isn't what you'd normally use, you'd use something like .map(x -> x * 2).orElse(-1)
22:01:43 <ski> the other way to do this would be to use `instanceof' to check whether your `Optional<A>' is actually a `Some<A>' (what i called `Just<A>' above), and then use a `A get()' method (which can't raise an exception) on the `Some<A>' to access the value of type `A'
22:01:51 <ricky_clarkson> It has enough higher order functions on it that you don't often miss pattern matching. Some kind of pattern matching is on the way, TBD.
22:02:15 <ski> @type fromMaybe
22:02:17 <lambdabot> a -> Maybe a -> a
22:02:25 <ski> that `orElse' is basically `fromMaybe' in Haskell
22:02:34 <jusss> ski: suddenly, I know what this maybe is used for, like in python or javascript, those dynamic type languages, one function can return Int or None, the type of return value is not sure, but in static type language, the type is specific type, it only has one type, right?
22:03:11 <ski> basically yes
22:03:28 <ski> "in python or javascript, those dynamic type languages, one function can return Int or None" -- this is not a problem
22:03:42 <ricky_clarkson> That's an informal Maybe.
22:03:50 <jusss> ski: so we use Just to wrap value, turn it to a Mabye type, so Just 3 and Nothing both are Maybe, so we can return Nothing or Just 3 as return value
22:04:06 <ski> the problem is when you start replacing that "can return `Int'" part with : can return something which can validly by `None' (as a successful result)
22:04:45 <jusss> ski: this is related we talked about something with Cale a few hours ago, 
22:04:51 <jusss> 12 hours maybe
22:04:55 <ski> jusss : yes. and importantly `Just Nothing' (of type `Maybe (Maybe T)' is not the same as `Nothing' (of type `Maybe (Maybe T)')
22:05:56 <ski> (or more generally, `Just x' is not the same as `x'. in Haskell, the latter has type `T' say, and then the former has type `Maybe T', so since they have different types, you can't even ask the question of whether these two values are the same (are equal). the question is ill-typed !)
22:07:12 <ski> so, as possible result values of the lookup we can have (a) `Nothing', of type `Maybe V'; or `Just v', of type `Maybe V', for some `v' of type `V'
22:08:30 <ski> and it's important that we write `Just v', not just `v', in the successful case. otherwise we couldn't distinguish between `Just Nothing' and `Nothing'
22:08:49 <ski> jusss : okay ?
22:10:18 <jusss> ski: "<ski> jusss : yes. and importantly `Just Nothing' (of type `Maybe (Maybe T)'      is not the same as `Nothing' (of type `Maybe (Maybe T)')"   Nothing shoudn't be Maybe T ?
22:10:31 <ski> @type Nothing
22:10:32 <lambdabot> Maybe a
22:10:43 <ski> `Nothing' has type `Maybe a', for any type `a'
22:11:07 <ski> e.g. `Nothing' can be used as having type `Maybe Integer', but also `Maybe String', `Maybe (Maybe String)', &c.
22:12:21 <ski> > let x,y,z :: Maybe (Maybe String); [x,y,z] = [Nothing,Just Nothing,Just (Just "Something")] in x == y
22:12:23 <lambdabot>  False
22:13:23 <ski> @let allDistinct :: Eq a => [a] -> Bool; allDistinct [] = True; allDistinct (x:xs) = x `notElem` xs && allDistinct xs
22:13:25 <lambdabot>  Defined.
22:13:33 <ski> > let x,y,z :: Maybe (Maybe String); [x,y,z] = [Nothing,Just Nothing,Just (Just "Something")] in allDistinct [x,y,z]
22:13:35 <lambdabot>  True
22:14:13 <ski> jusss : did you want to bring up something from that earlier conversation you mentioned ?
22:14:14 <jusss> ski: oh, I see, May (Maybe a) and Maybe a or Maybe (Maybe (Maybe a)), they all can be Nothing, right? 
22:14:20 <ski> yes
22:15:01 <ski> but `Maybe (Maybe a)' also has the value `Just Nothing'. and `Maybe (Maybe (Maybe a))' also has the value `Just (Just Nothing)'
22:15:13 <ski> (and these three values are distinct)
22:15:43 <ski> jusss : do you know any C ?
22:15:58 <jusss> ski: which part? I just remember the last part is " <Cale> jusss: I mean that... you know how Java has things like List<A> where A  is a variable type? "
22:16:02 <jusss> ski: just C,
22:16:10 <jusss> no C++ or C#
22:16:23 <ski> in `C', a value of type `int' can't be `NULL', it can just be an integer
22:16:35 <jusss> ski: haskell is the first static type language I learn (if we forget about C)
22:16:45 <ski> but a value of type `int *' can either be `NULL', or a pointer, that (currently) points to some integer
22:17:28 <jusss> yes
22:17:40 <ski> and a value of type `int **' can either be (a) `NULL'; or (b) a pointer pointing to a `NULL'; or it can be (c) a pointer pointing to a pointer pointing to an integer
22:18:16 <ski> this case is a bit similar to how a `Maybe (Maybe Integer)' can either be `Nothing', `Just Nothing', or `Just (Just n)' for an `Integer' `n'
22:18:17 <jusss> it seems same like Maybe (Maybe a)
22:18:24 <ski> `Just' corresponding here to "pointer pointing to"
22:18:42 <ski> of course, in C, what a pointer points to can be changed over timr. that's not happening with `Maybe' in Haskell
22:18:59 <jusss> ski: wait a sec, the value `Nothing` has multipy types?
22:19:24 <jusss> Maybe a and Maybe (Maybe a) are not same type, right?
22:20:02 <ski> (and, it's also common to use a pointer to point to the first element of an array, so that if `p' is such a pointer, you can use `p[i]' to access the `i'th element of that array. or you can use `p + 1' to get a pointer to the next element in that array. this is also specific to C, and doesn't correspond to the `Maybe' situation in Haskell
22:20:08 <ski> )
22:20:09 <ski> but otherwise, the picture is pretty similar
22:20:30 <ski> jusss : for *all* types `a', `Nothing' has type `Maybe a'
22:20:59 <jusss> ski: actually, I just ignore that Maybe a, I think (Maybe a) as a in Maybe a, so of course there's a Nothing
22:20:59 <ski> so `Nothing' has e.g. types `Maybe Integer',`Maybe (Maybe Integer)',`Maybe (Maybe (Maybe Integer))',&c.
22:21:42 <ski> so, if `b' is any type, then we can let `a', in `Maybe a', itself be `Maybe b'. therefore `Nothing' also has type `Maybe (Maybe b)' for any type `b'
22:22:01 <ski> and then `Nothing' also has type `Maybe (Maybe (Maybe c))', for any type `c'. and so on
22:22:29 <jusss> ski: and can we say Nothing has multipy types?
22:22:42 <ski> of course `Nothing' also has type `Maybe [(String,Integer)]' and type `Maybe (Integer -> Bool)', and so on. you can put other things "in there" than `Maybe (...)'
22:22:46 <ski> yes
22:22:55 <ski> we say that `Nothing' is a polymorphic value
22:23:08 <ski> similarly, `length' has type `[a] -> Int', for any type `a'
22:23:53 <ski> this means that `length' can be used as having type `[Integer] -> Int', but also as having type `[Maybe Integer] -> Int',`[(String,Integer)] -> Int',`[Integer -> Integer] -> Int', and so on
22:24:14 <ski> `length' doesn't care about the type of elements in your list, it only checks the length of the list
22:25:05 <jusss> ski: and now I think that Maybe type is just used for a polymorphic value Nothing, in case some results are Nothing and we can retur that like other values
22:25:12 <ski> similarly, `reverse' has type `[a] -> [a]' for any type `a'. so in particular, it e.g. has types `[Integer] -> [Integer]',`[Maybe Integer] -> [Maybe Integer]',`[[Integer]] -> [[Integer]]',`[(String,Integer)] -> [(String,Integer)]',&c.
22:25:14 <jusss> for the same type
22:25:39 <jusss> 'cause Nothing is not Int, or String
22:25:40 <ski> and, `take' has type `Int -> [a] -> [a]' for any type `a'. so in particular, it e.g. has types `Int -> [Integer] -> [Integer]',`Int -> [Maybe Integer] -> [Maybe Integer]',`Int -> [[Integer]] -> [[Integer]]',`Int -> [(String,Integer)] -> [(String,Integer)]',&c.
22:27:07 <ski> (however, `reverse' can't be used as having type `[Integer] -> [String]'. when you replace the `a' in `[a] -> [a]' with a specific type (when you "specialize" the polymorphic value (function) `reverse'), you have to consistently replace all `a's in the type signature with the *same* type, e.g. `Integer' or `String' or `(String,Integer)'. you can't replace some of the `a's with one type, and others with another type)
22:28:12 <jusss> ski: you mean a can be Maybe a?
22:28:56 <ski> (if you give `reverse' a list of elements, `reverse' doesn't care about the element type, it only reverse the list, moving around the elements, but not looking at them. but it is going to produce a list with elements of the same type as in the input list. and similarly with `take', and `(++)', list concatenation ..
22:29:02 <ski>  .. with `(++)', which has type `[a] -> [a] -> [a]', for any type `a', both input lists has to have elements of the same type, and then the result list will also have elements of this type)
22:29:19 <ski> jusss : i'd rather say `a' can be `Maybe b', in order to not confuse myself (and you) with different types `a'
22:29:34 <jusss> ski: ok
22:29:50 <ski> <jusss> ski: and now I think that Maybe type is just used for a polymorphic value Nothing, in case some results are Nothing and we can retur that like other values
22:29:57 <ski> <jusss> for the same type
22:30:02 <ski> <jusss> 'cause Nothing is not Int, or String
22:30:18 <ski> i'm not sure what you mean by "for the same type" there
22:30:53 <ski> and, i assume you mean that `Nothing' doesn't have *type* `Int', nor has *type* `String'
22:31:54 <jusss> ski: the return value's type is a specific type, 3 and Nothing are not same type, but Just 3 and Nothing are same type we can retur
22:32:10 <ski> (saying "Nothing is not Int, or String" sounds like you're comparing `Nothing' itself with `Int' or `String' itself. the first is a value, the latter two are types. you can't compare them directly, can't say that they're equal, or that they're not equal. what you can say is that the former is, or is not, of type, one of the two latter. in this case, `Nothing' neither has type `Int', nor has type `String')
22:32:35 <ski> "3 and Nothing are not same type" -- better say : `3' and `Nothing' doesn't *have* the same type
22:33:01 <ski> `3' and `Nothing' are not types, but saying they "are not same type" seems to hint that they are types, which they're not
22:33:35 <jusss> ski: values have types is better than values are types or types have values?
22:33:37 <ski> similarly, `Just 3' and `Nothing' *have* (not "are") the same type
22:34:34 <jusss> ski: wait a sec, Maybe a is a type? Just Int is a type?
22:34:48 <ski> (i'm sorry if i'm perhaps seeming a bit overly pedantic. however, experience has convinced me that being strict with terminology, as a beginner, can really help you straighten up the "conceptual landscape", help weed out remaining misunderstandings, help see important distinctions)
22:34:51 <jusss> Just 3 have Maybe Int
22:35:13 <ski> `Just Int' is neither a value nor a type. generally speaking, it's nonsense
22:35:20 <ski> `Maybe a' is a type for any type `a'
22:35:30 <ski> since `Int' is a type, therefore `Maybe Int' is also a type
22:35:32 <jusss> ski: and Maybe a is a concret type?
22:35:48 <ski> `Just 3' is a value, of type `Maybe Int' (because `3' is a value of type `Int')
22:36:04 <ski> if `x' is a value of type `a', then `Just x' is a value of type `Maybe a'
22:36:10 <jusss> ski: can we say Just 3 has Maybe a type?
22:36:14 <ski> further, `Nothing' is always a value of type `Maybe a'
22:36:27 <ski> yes `Just 3' has `Maybe a' as type
22:36:39 <ski> *if* `a' is the type of `3'
22:36:47 <jusss> ok
22:36:59 <ski> `3' in Haskell is also polymorphic, it can be used as having many types
22:37:17 <ski> `3' can have type `Int',`Integer',`Rational',`Float',`Double',`Complex Double',&c.
22:37:17 <jusss> so `Just 3' and `Just "3"' have the same type Maybe a?
22:37:28 <ski> roughly speaking, `3' has all "numeric types"
22:37:33 <ski> no
22:37:58 <ski> `"3"' is a value of type `String' (which btw is not a numeric type. `String' is not an instance of the type class `Num')
22:38:07 <ski> so `Just "3"' has type `Maybe String'
22:38:08 <jusss> Just 3 has Maybe a, Just "3" has Maybe a, why not?
22:38:35 <ski> but `Just 3' has type `Maybe a' for any *numeric* type `a' that you like. since `String' is not a numeric type, `Just 3' can't have type `Maybe String'
22:38:45 <jusss> ok
22:38:49 <ski> `Just 3' has type `Maybe a', *if* `a' is a numeric type
22:38:58 <ski> `Just "3"' has type `Maybe a', *if* `a' is the type `String'
22:39:04 <ski> these are mutually exclusive cases
22:39:34 <ski> (technically, it *is* possibly to declare `String' an instance of `Num', which would make `String' a "numeric type". however, don't do that. it's only confusing)
22:40:37 <jusss> ski: so NumToString :: Maybe a -> Maybe a are ok? NumToString take Just 3 and return Just "3",  or NumToString::Maybe a -> Maybe b
22:42:50 <ski>   numToString :: Show a => Maybe a -> Maybe String
22:42:52 <ski> it could be
22:43:33 <ski> if you return `Just "3"' for ìnput `Just 3' here, then the result type is `Maybe b', where `b' is always the type `String'. so the result type is then really `Maybe String'
22:44:39 <ski> also, to "convert" the number to a `String' in this way, presumably you'd use the `show' function. and that actually works on values of all types `a' that are instances of the type class `Show' (not merely types are that are instances of `Num', iow which are "numeric types")
22:44:42 <jusss> and should Maybe a be Maybe Int?
22:44:49 <ski> it could be, if you wanted to
22:45:09 <ski> or it could be `Maybe Integer', or `Maybe Rational' or `Maybe Double', or `Maybe (Complex Double)', &c.
22:45:58 <ski> or it could be `Maybe Bool' or `Maybe [[Integer]]', since values of type `Bool' or `[[Integer]]' can also be "converted" to values of type `String', using `show'
22:46:41 <jusss> ok...
22:47:29 <ski> however, since `show' works for all input types `a' ("is polymorphic in `a'"), as long as `a' is a "showable type" (a type that's an instance of `Show'), your `numToString' *could* also be polymorphic, and work for all types `a', as long as `Show a' holds, as long as the input type `a' is an instance of `Show'
22:47:44 <ski> so, instead of any of the particular
22:47:56 <ski>   numToString :: Maybe Integer -> Maybe String
22:48:03 <ski>   numToString :: Maybe Double -> Maybe String
22:48:09 <ski>   numToString :: Maybe Bool -> Maybe String
22:48:19 <ski> and so on, all of which are mutually exclusive
22:48:23 <ski> you could have the more general
22:48:28 <ski>   numToString :: Show a => Maybe a -> Maybe String
22:48:43 <ski> which encompasses all these cases
22:49:01 <ski> @type show
22:49:03 <lambdabot> Show a => a -> String
22:49:39 <ski> this says that `show' converts an input of type `a', to an output of type `String', as long as `Show a' holds, iow as long as `a' is a "showable type", as long as `a' is an instance of the type class `Show'
22:50:26 <ski> `Show' is like a "bag" that contains all the *types* (not values), whose values are "showable" (iow, whose values can be "converted to a `String'" .. e.g. with `show', or related functions)
22:51:56 <ski> similarly, `Num' is like a "bag", or a "class" that contains all the *types* (hence the term "type class". `Num' is a type class), whose values are "numeric" (iow, whose values you can operate on using the arithmetic operations like `(+)',`(-)',`(*)' (but not `(/)'), and a few more. also you can use numeric literals / numerals like `3', as having the type in question)
22:52:14 <ski> if you said
22:52:27 <ski>   sum :: [a] -> a
22:52:49 <ski> then that'd claim that you could sum a list of values of *any* type `a', getting back a result of the same type `a'
22:54:10 <ski> but that doesn't work, e.g. if `a' would be `String', or `[(String,Bool)]' -- how would you add, or subtract, or multiply, values of these types (such that familiar rules of arithmetic still hold, e.g. `x + y = y + x' and `x * (y + z) = x * y + x * z') ?
22:54:39 <jusss> yeah
22:54:59 <ski> we want to say that `sum' works for any type `a', is *polymorphic* in `a', as long as `a' is a *numeric* type (a type which supports `(+)',`(-)',`(*)', and so on. supports the operations of the type class `Num')
22:55:03 <ski> @src Num
22:55:04 <lambdabot> class Num a where
22:55:04 <lambdabot>     (+), (-), (*)       :: a -> a -> a
22:55:04 <lambdabot>     negate, abs, signum :: a -> a
22:55:04 <lambdabot>     fromInteger         :: Integer -> a
22:55:47 <dminuoso> There's really a lot of great intuition to come from thinking of classes as "sets/collections/bags/families" containing types. :)
22:56:07 <ski> (note that that doesn't include `(/)'. you can't use `(/)' on `Int' or `Integer', e.g. .. `(/)' is supposed to be exact division. if you want a rounding division, with remainder, then that's `div' and `mod' (or alternatively `quot' and `rem', if you want a different rounding policy))
22:56:15 <ski> and so, we don't want to say
22:56:17 <ski>   sum :: [a] -> a
22:56:21 <ski> instead we say
22:56:26 <ski>   sum :: Num a => [a] -> a
22:56:35 <ski> the part before the `=>' is called a (type class) constraint
22:56:53 <ski> we're *constraining* which types `a' could possibly be here. from allowing any type, to only allowing "numeric types"
22:57:44 <ski> the constraint `Num a', read "`Num a' holds" or "`a' is an instance of `Num'" or simply "`a' is in `Num'", or, if you want, "the property/predicate `Num' holds for `a'"
22:59:58 <ski> whenever you type a numeral, a numeric literal, like `3', e.g. of type `Rational', or `Double', or whatever numeric type you're using, the implementation is "secretly" changing that into `fromInteger 3', where *this* `3' is always an `Integer' (and doesn't get expanded again with another call of `fromInteger', obviously. otherwise we'd never stop the expansion)
23:00:49 <ski> this means that when you use say `3' as a value of your numeric type, say `Double', it will call the corresponding `fromInteger' function of type `Integer -> Double', to convert the `Integer' `3' to the `Double' `3.0'
23:00:59 <ski> > [3,pi]
23:01:01 <lambdabot>  [3.0,3.141592653589793]
23:01:07 <ski> note how `3' here got changed into `3.0'
23:01:33 <ski> but if we use `3' as having type `Rational', it will display it as a rational instead
23:01:33 <dminuoso> ⌜sum :: [a] -> [a]⌝ can be read as: For every choice of some type ⌜a⌝, for which an ⌜instance Num a⌝ exists, sum has/is allowed to have type ⌜[a] -> a⌝
23:01:49 <jackdk> I think you forgot the context
23:01:58 <ski> > [3,21 % 60]
23:02:00 <lambdabot>  [3 % 1,7 % 20]
23:02:04 * dminuoso really enjoys those top left/right corners
23:02:05 <jackdk> `sum :: Num a => [a] -> a`, I think?
23:02:25 <ski> `3 % 1' means the rational number `3 / 1', which is of course just `3'
23:02:30 <dminuoso> Oh wait shoot!
23:02:30 <dminuoso> ⌜sum :: Num a => [a] -> [a]⌝ can be read as: For every choice of some type ⌜a⌝, for which an ⌜instance Num a⌝ exists, sum has/is allowed to have type ⌜[a] -> a⌝
23:02:33 <dminuoso> I missed the class constraint there. :)
23:02:47 <ski> and `7 % 20' means the rational number `7 / 20', which is the same as the rational number `21 / 60'
23:03:26 <jackdk> and the return type shouldn't be a list?
23:03:30 <ski> > [21 / 60,10 % 15]
23:03:33 <lambdabot>  [7 % 20,2 % 3]
23:03:40 <dminuoso> jackdk: Oh I give up. Its too early in the morning indeed.
23:03:46 <dminuoso> ⌜sum :: Num a => [a] -> a⌝ can be read as: For every choice of some type ⌜a⌝, for which an ⌜instance Num a⌝ exists, sum has/is allowed to have type ⌜[a] -> a⌝
23:03:51 <dminuoso> There! It should be right now. :|
23:04:13 <ski> dminuoso : i'm glad you enjoy them :)
23:04:29 <dminuoso> ski: Now I just need to figure out a comfortable way to type them. ;)
23:04:49 <dminuoso> AltGr is free here.. :)
23:04:53 <ski> perhaps i should look into something like that, as well ..
23:05:13 <dminuoso> ski: I recall a pretty good Windows software, but I cannot remember what it was. :|
23:05:17 * ski is a bit lazy with making changes like that, though
23:05:50 <ski> (or perhaps one should say, overly tolerant of small annoyances like that)
23:06:17 <ski> (e.g. i haven't used `/ignore' yet, in more than eighteen years of IRCing ..)
23:06:38 <ski> jusss : the above making any sense ? or did we lose you ?
23:07:47 <jusss> ski: sorry, I wasn't here a few moments ago
23:08:34 <dminuoso> ski: What operating system do you usually use?
23:09:08 <ski> GNU/Linux
23:09:37 * ski is looking into `xmodmap' (again) atm
23:09:39 <dminuoso> ski: Do you use X or Wayland?
23:09:44 <ski> the former
23:09:54 <dminuoso> Oh yeah, xmodmap is probably your best bet then.
23:09:59 <jusss> ski: I think you suggest to use specific type to instead of polymorphic type, right?
23:10:04 <ski> (i dislike Wayland not supporting network transparency (at least last i heard))
23:10:21 <dminuoso> ski: I dislike Wayland for not being able to run Xmonad on it. :)
23:10:22 <ski> jusss : in the case of `numToString' ?
23:10:28 <jusss> ski: yeah
23:10:43 <ski> jusss : it depends on what you want. sometimes you want more specific. sometimes you want more general
23:10:56 <jusss> ski: I really like that a->b than Int->String
23:11:27 <jusss> ski: and of course a->b is polymorphic stuff, and I really can't pronouce this word 'polymorphic'
23:11:36 <ski> jusss : if it doesn't matter much, then i'd suggest opting for the more general one. despite possibly being useful in more contexts, it will also, in several cases, make it easier to understand the operation, and what it could possibly do, just by looking at its type signature
23:11:52 <dminuoso> ski: Ah actually .XCompose might be preferrable.
23:11:56 <ski>   foo :: [a] -> [[a]] -> [[a]]
23:12:10 <ski> promises way more about what `foo' can and *cannot* do, than
23:12:14 <dminuoso> ski: That way you can reuse any AltGr/Compose/Win/Capslock key you might have but not use.
23:12:17 <ski>   foo :: [String] -> [[String]] -> [[String]]
23:12:17 <ski> or
23:12:19 <jusss> this word is weird in English  i think, there're lots of weird words in math
23:12:26 <ski>   foo :: [Integer] -> [[Integer]] -> [[Integer]]
23:12:27 <ski> does
23:12:47 <ski> in the first `foo', we *know* that `foo' can't look at the elements of type `a'. it can only manipulate the lists themselves
23:13:27 <ski> in the two latter cases, perhaps `foo' will also look at the `String's or the `Integer's, and decide what to do, depending on them. possibly even changing them to some other `Integer's / `String's in the result
23:13:40 <dminuoso> jusss: You would pronounce it as: Po-leeh-more-fic
23:13:41 <dminuoso> (Where `fic` is pronounced the same as in terrific)
23:13:59 <jusss> dminuoso: ok
23:14:01 <ski> in the first `foo' case, we know that the `a's occuring in the output list-of-lists can only come from one of the two input arguments
23:14:17 <ski> it can't combine the `a's with each other in any way
23:14:54 <ski> it can just make a selection of some `a's to use, perhaps multiple times, in the result. and it can't look at the `a's, when making this decision. it can only look at the *lengths* of the input lists
23:15:34 <jusss> and monad is more general
23:16:13 <ski> jusss : `a -> b' itself isn't a polymorphic type. if you have a value `f' (a function, say), with a signature like `f :: a -> b' (or something like that, the important part is that the type involves type variables like `a' and `b'), then `f' is a *polymorphic* value (function in this case)
23:16:41 <iqubic> I really need to wire up my compose key to actually do things.
23:17:11 <ski> dminuoso : which tool reads `.XCompose' ? alternatively, where do i read about the format of this file ? is there a `man' page for this ?
23:17:29 <iqubic> I also want to know that.
23:17:47 <ski> jusss : "polymorphic" means roughly "many shapes". the opposite is "monomorphic", meaning "one shape"
23:17:52 <iqubic> I mean... I use emacs so M-x insert-char is a thing I can do.
23:18:06 <dminuoso> ski: Compose(5)
23:18:32 <ski> jusss : `Nothing' is polymorphic, since it has many shapes (types) : `Maybe Integer',`Maybe (String,Integer)', `Maybe [Integer]',`Maybe (Maybe Bool)',`Maybe (Integer -> Integer)', &c.
23:18:55 <iqubic> ski: does `monad' come from the root `mono', meaning one?
23:19:24 <ski> jusss : `take' is polymorphic, since it has many shapes (types) : `Int -> [Maybe Integer] -> [Maybe Integer]',`Int -> [Int] -> [Int]',`Int -> [[String]] -> [[String]]',`Int -> [Int -> Int] -> [Int -> Int]',&c.
23:20:30 <ski> jusss : `sum' is polymorhic, since it has many shapes (types) : `[Int] -> Int',`[Rational] -> Rational',`[Double] -> Double',`[Complex Double] -> Complex Double' .. but not e.g. `[String] -> String', since `String' is not a numeric type (is not an instance of `Num')
23:20:50 <ski> jusss : otoh, `not' is monomorphic, since it has just one shape (type) : `Bool -> Bool'
23:20:50 <camelCaseLogin> iqubic: for all the Category Theory related stuff (Functors, Monads, Monic morphisms etc) I highly recommend Bartosz Milewski's YouTube series on CT for Programmers
23:21:04 <ski> jusss : and, `lines' is monomorphic, since it has just one shape (type) : `String -> [String]'
23:21:40 <ski> jusss : and `[Nothing,Just False]' is also monomorphic. it has the single shape/type `[Maybe Bool]'
23:22:01 <ski> jusss : otoh, `[Nothing,Just Nothing]' is polymorphic, since it has type `[Maybe (Maybe a)]', for any type `a'
23:22:19 <ski> jusss : there's no type variables in the types of monomorphic values. there are type variables in the types of polymorphic values
23:22:53 <ski> jusss : that's a basic understanding of monomorphic and polymorphic that you can use, for now. later, the story will become a little bit more complicated, and more interesting
23:24:36 <ski> iqubic : i think "monad" is a word play on "monoid", and a shameless theft of the philosophical term "monad" (as used by Leibniz to describe "the smallest possible units of existence, being both matter and conscious". see his "Monadology", <https://en.wikipedia.org/wiki/Monadology>)
23:24:54 <ski> dminuoso : ty
23:25:59 <ski> iqubic : in Emacs, i use `C-x 8 ...', or `C-x RET C-\' followed by `Agda' or `TeX'
23:26:24 <ski> iqubic : however, i think "monoid" comes from the root "mono", yes
23:27:04 <ski> and you must have heard
23:27:05 <ski> @quote wadler what's.the.problem
23:27:06 <lambdabot> wadler says: A monad is a monoid in the category of endofunctors, what's the problem?
23:27:27 <jusss> ...
23:27:41 <dminuoso> jusss: I recommend you do not try and understand monad yet. Try to build intuition with what you have learned, absord this information first. :)
23:28:29 <dminuoso> *absorb, even.
23:28:54 <jusss> dminuoso: there's always a word come with monad, 'context'
23:29:11 <ski> which is why the term "monad" was based on the term "monoid" (apart from the stealing of terms from the philosophers. note that the term "category" itself is also a theft from philosophy, like e.g. Aristotle,Kant,Hegel,Peirce)
23:29:28 <jusss> which I don't understand,
23:29:44 <dminuoso> jusss: Its part of a mental model you need to obtain first.
23:29:59 <ski> (stealing terms from philosophers appear to be a favorite pastime of category terrorists ..)
23:30:01 <jusss> a namespace or context in closure, that's what I can image, but monad context? no
23:30:18 <dminuoso> jusss: No, and its incredibly difficult to explain to a beginner like yourself what some people mean by "context".
23:30:32 <dminuoso> jusss: The best way I can describe Monad is "its an abstract interface following some set of rules for no specific purpose"
23:31:12 <ski> (i think "functor" was stolen from Carnap ? .. otoh "natural transformation" (which is arguably the whole reason category theory was invented in the first place) is/was an informal term in (some) math, that Eilenberg and McLane wanted to capture more exactly)
23:31:34 <jusss> for me, it's just like a tool can construct some different form to one same form
23:32:11 <dminuoso> jusss: To build good intuition on Monad, its best to start with basic polymorphism to get the idea of why one might want to abstract using Num.
23:32:30 <dminuoso> jusss: And then perhaps progress to understanding Monoid as a stepping stone for abstraction.
23:32:31 <ski> (to describe "natural transformations" exactly, they had to first define "functors". but to describe "functors" exactly, they first had to define "categories". and so, at least initially, the whole point of categories was as a means to describe functors, and the whole point of functors was as a means to describe natural transformations, which is what they were really after)
23:33:03 <ski> jusss : imho, the term "context", re monads, doesn't really help that much
23:33:33 <jusss> dminuoso: but that monoid has nothing to do with monad in haskell, 
23:33:40 <dminuoso> jusss: No it doesnt!
23:33:48 <dminuoso> jusss: But Monoid is an abstraction on a rather general level.
23:34:12 <ski> using the term "context" when trying to explain monads is similar to using the terms "computation" or "action", or "container" when trying to explain monads
23:34:16 <jusss> ski: yeah, but that word comes with every artical about monad
23:34:36 <ski> they might help slightly, but only in conjunction with lots of examples of what you really mean by them in this .. context
23:34:50 <Solonarv> there are so many not-exactly-helpful articles trying to explain what a monad is that we have a word for it: the monad tutorial fallacy
23:34:55 <ski> jusss : i disagree, i practically never use the term "context", when i try to explain monads
23:35:13 <ski> (i can't speak for others)
23:35:22 <ski> @where burrito
23:35:23 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
23:35:35 * ski seconds Solonarv : there's a lot of bad monad tutorials out there
23:35:45 <jusss> ski: yeah, I saw that, monad is a burrito
23:35:49 <c_wraith> I might use it if I'm focusing on Kleisli arrows instead of a more direct approach
23:36:17 <c_wraith> But Kleisli arrows aren't a great way to teach monads, either.
23:36:19 <ski> jusss : "a monad is a burrito" is travesty, a joke, meant to ridicule such bad monad tutorials
23:37:15 <c_wraith> He should have taken a page from James Iry's approach and added "What's the problem?" afterwards.
23:37:17 <jusss> ski: that reader monad is most difficult for me, (I havn't meet Cont yet)
23:37:18 <ski> "What the hell are Monads?" by Noel Winstanley in 1999-02 at <http://www-users.mat.uni.torun.pl/~fly/materialy/fp/haskell-doc/Monads.html> (arguably the first monad tutorial, which is not in a paper ?) is one of the few monad tutorials which i think is actually good (as far as it goes)
23:37:31 <dminuoso> jusss: So building intuition for Monoid can help you accept abstraction.
23:37:41 <jusss> I know function monad is improper, so reader monad, 
23:37:49 <dminuoso> jusss: So writing Monoid polymorphic code can be an incredibly helpful stepping stone to later understand monad. )
23:37:51 <dminuoso> :)
23:38:07 <ski> that tutorial focuses on "what good does monads buy me ?" and the answer is a practical answer : they can help with avoiding repetitive boiler-plate code
23:38:15 <dminuoso> (The polymorphic part is what justifies Monoid and Monad, really)
23:38:46 <ski> jusss : do you know what e.g. a priority queue is ?
23:38:52 <jusss> that join :: (e-> (e-> a)) -> (e->a)
23:39:01 <ski> jusss : or just a queue (or dequeue), if you prefer
23:39:45 <jusss> ski: a queue, yes
23:40:39 <jusss> maybe I can image monad like a snake, so I can understand it
23:41:06 <jusss> actually I image Promise in js as a snake
23:41:07 <ski> jusss : anyway, i second dminuoso on that it's best to first understand all of (a) data types; (b) polymorphism; (c) type classes (including instances, and constrained types); (d) parameterized types, before tackling monads
23:41:23 <Solonarv> oooh, that's an analogy I hadn't heard before
23:41:53 <dminuoso> I went the category theory route, ski. I understood the joke about "a monad is just a monoid...", the turned to Haskell and realized "I have no idea how to use IO at all." 
23:41:54 <jusss> Solonarv: and you can try it :)
23:42:12 <dminuoso> It was an amusing revelation to turn back to Haskell and have no clue how to write the simplest of programs. :-)
23:42:41 <dminuoso> So I fell victim to the "CT first" fallacy.
23:42:58 <ski> jusss : also, people seems to make monads something more important/special than it is. it's just a particular kind of "data type interface", that happens to be useful in some situations. people tend to be confused by it, partly because they haven't seen anything similar in other languages, and so don't initially have experience to connect to
23:43:03 <ski> jusss : you really need to take you time building that experience, by looking at *specific* monad types, before you can tackle the general idea of a monad
23:43:35 <dminuoso> Using the specific monad instances is very simple for all of them. Any language beginner can write IO programs on their first day. :)
23:43:41 <ski> jusss : oh, yes. you also don't need to know category theory (a part of mathematics), in order to understand functors, monads, in programming
23:43:47 <c_wraith> I didn't really get it until I started just using more libraries and suddenly realized I was writing code that worked.
23:44:10 <ski> c_wraith : "James Iry's approach" being ?
23:44:12 <jusss> ski: maybe you're right
23:45:06 <c_wraith> ski: http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html  see the Haskell section.  Note that the exact phrasing which has plagued people trying to teach this seems to have come from this joke article.
23:45:40 <jusss> ski: actually I read lots of articls about monad that they use js to describe it, not haskell :)
23:46:04 <ski> jusss : ok, so you know you can have multiple different implementations of the same abstract queue interface. the abstract queue interface corresponds to the general idea of a monad. the concrete/specific implementations of queues correspond to specific monads
23:46:52 <ski> jusss : so, you could implement a queue as a linked list. or you could have an array (which might be dynamically resizable). or you could use a "heap" (a kind of binary tree, perhaps stored in an array)
23:48:09 <ski> jusss : similarly, `Reader r' is one "implementation" of `Monad', `Writer w',`State s',`Either e',`Maybe',`[]',`Parser tok',`Cont o',`IO',`ST s',`STM' are some other implementations of the abstract idea of a monad
23:49:14 <jusss> ski: yeah, but e-> monad is not like Maybe monad or List monad
23:49:29 <iqubic> I need to learn how Writer works. But not now, because it is midnight here where I am.
23:49:31 <jusss> intutive
23:49:48 <iqubic> jusss: `e -> ` is the reader monad.
23:49:56 <ski> jusss : however, to use a queue, you *almost* don't need to know anything about the concrete implementation you're using. you (almost) only need to use the operations supported by the abstract queue interface. ("almost", because when you create your initial queue, you must pick an implementation. also, if the implementation is bounded in size, you may get an exception/failure, if you try to add too many items to it)
23:51:34 <iqubic> right, but you can write most of your functions with a Queue q => constraint provided there's a Queue typeclass.
23:51:40 <ski> jusss : otoh, to use a monad, it generally is not of much use to only use the operations supported by the abstract monad interface (the `Monad' type class). (you can do some useful general traversal operations on data structures, but) in the end you really need to pick a monad, and you need to use some operations *specific* to that monad, in order to do anything useful
23:52:10 <iqubic> Like for the reader monad you end up using ask/asks.
23:52:36 <ski> (or, you could pick a more restricted/specific monad interface, like `MonadState', which supports a few more operations. then it would be enough to only pick the concrete monad "implementation" in the end, not picking any extra operations specific to that monad)
23:52:46 <iqubic> and writer has tell.
23:52:54 <iqubic> state has get and put.
23:53:25 <jusss> and list and maybe have?
23:53:33 <ski> c_wraith : ah, i knew i'd seen the name "James Iry" before. i ought to have recalled from where
23:53:59 <iqubic> list and maybe don't really have anything.
23:54:08 <ski> dminuoso : re "CT first", that's interesting
23:54:17 <iqubic> I did CT second.
23:54:23 <iqubic> Haskell first
23:54:24 <ski> dminuoso : did you study CT, coming from math ? or hearing about it in a Haskell context ?
23:54:53 <Ariakenom> clearly Writer should have show, not tell
23:55:38 <ski> jusss : unfortunately, it appears lots of articles that tries to explain monads in terms of other languages, either gets some parts subtly wrong, or at least doesn't really show the full power of them (partly because of lacking features in said languages)
23:55:47 <Solonarv> iqubic: they have MonadFail and Alternative/MonadPlus
23:56:22 <iqubic> Ariakenom: Except show is taken: see `Class Show a where...'
23:57:10 <Ariakenom> iqubic: it was an attempt at a joke. show not tell is a writer's tip
23:57:38 <ski> jusss : anyway. e.g. `IO' is much more than being a monad. being a monad is only a small (but still important) part of `IO'. in fact, before the utility of using monads in programming was recognized, I/O in Haskell was done in other ways (dialogue I/O, and then continuation-passing style (CPS) I/O). so you don't necessarily *need* the "monad" part of `IO' either. it just turns out to be (a bit) handy. but again `IO' is much more than being a monad
23:58:40 <ski> jusss : and being a monad isn't something that's magically supported by the implementation. it's "just another abstract data type interface", like queues. however, the implementation of the basic `IO' operations (including, but not limited to, its monad implementation) *is* "magic" in this sense
23:59:21 <iqubic> I tend to think of an (IO a) as a State a World.
23:59:35 <ski> jusss : but monads are so much more than `IO' (or even `State s',`ST s'). so you're limiting yourself to a restricted, perhaps "crippled" understanding, if you try to understand monads (only) in terms of `IO' (and similar things)
