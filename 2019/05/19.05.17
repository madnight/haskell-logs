00:03:41 <bahamas> Axman6: yes. I found them in Language.Java
00:15:19 <bahamas> Axman6: if I add Reify and Reflect to deriving, I get "Couldn't match type ‘Interp Session’ with ‘Ty Session’". If also add the 
00:15:40 <bahamas> "Interpretation" typeclass, I get "No instance for (singletons-2.3.1:Data.Singletons.SingI
00:15:44 <bahamas>                          (Interp Session))
00:16:15 <bahamas> I see that "Interp" is a type family
00:17:10 <bahamas> there has to be an easier way to make a type available in the closure. I think this is a common use case
00:37:13 <quchen> @phadej: pong :-)
00:37:13 <lambdabot> Unknown command, try @list
00:37:26 <quchen> Oh hello Lambdabot, long time no see
00:39:21 <maerwald> how to convert Fold to Fold1
00:39:25 <maerwald> I'm getting lost in the docs
00:46:03 <maerwald> ended up at Tambara...
00:46:23 <maerwald> that's when you know you have to stop reading docs
00:47:25 <maerwald> "Tambara cofreely makes any Profunctor Strong." -- y..e..s
00:50:01 <MarcelineVQ> maerwald: Fold1 seems to use Apply instead of Applicative, so maybe WrappedApplicative
00:50:59 * pong quchen
00:51:31 <maerwald> I have no idea what that means
00:54:17 <phadej> maerwald: you cannot convert fold to fold1
00:54:26 <phadej> the conversion goes other way
00:54:32 <phadej> fold1 can be relaxed to fold
00:54:43 <maerwald> well, I was hoping to have it "fail" and then use preview or something
00:55:05 <maerwald> e.g. I use sumOf with a Fold, but when the Fold is empty, I don't want it to return nonsense like 0
00:56:03 <maerwald> like a _nonempty prism?
01:01:04 <quchen> phadej: Merged your PR. I’ll prepare a release.
01:01:31 <quchen> And I should look into this Travis issue.
01:02:55 <phadej> quchen: i'd like to support GHC-7.0; I think doing that is "less work" than trying to convince optparse-applicative maintainer to drop support for ghc-7.0 and ghc-7.2
01:03:14 <quchen> phadej: Do you know what’s necessary to do so?
01:03:21 <quchen> I’m open to it
01:03:51 <quchen> Haven’t worked with GHC 7 for quite some time, and prettyprinter isn’t doing anything particularly fancy, so I think it should be possible
01:04:20 <phadej> quchen: ~about
01:13:54 <maerwald> how do you build a Fold1 manually?
01:18:27 <gentauro> maerwald: by using ! 
01:19:21 <maerwald> What does that mean
01:24:36 <iqubic> I want dependant haskell right now.
01:25:39 <MarcelineVQ> If you say that three times into a mirror with the lights off and the door cracked just a little it comes true
01:26:24 <maerwald> I can't believe there is nothing to make a Fold fail if it's empty
01:26:32 <maerwald> I mean how are you supposed to work with it
01:30:10 <phadej> :t yahb 
01:30:12 <lambdabot> error: Variable not in scope: yahb
01:31:01 <phadej> % Just (Data.Semigroup.Min 'x') <> Just (Data.Semigroup.Min 'z')
01:31:01 <yahb> phadej: Just (Min {getMin = 'x'})
01:31:07 <phadej> mermosa[m]: using Maybe
01:31:11 <phadej> maerwald: ^
01:31:15 <phadej> sorry mermosa[m] 
01:32:37 <bahamas> I'm trying to make a type I defined (Session) available in Spark. I tried deriving the Reify and Reflect type classes from here https://github.com/tweag/inline-java/blob/master/jvm/src/Language/Java.hs, but I'm getting this error "Couldn't match type ‘Interp Session’ with ‘Ty Session’" am I on the right track or is there a better way to do this?
01:34:24 <bahamas> I also tried adding the Interpretation type class, but I get a different error "(singletons-2.3.1:Data.Singletons.SingI (Interp Session))". do I need to define an instance for this "SingI" class as well?
01:35:33 <maerwald> phadej: cannot really follow :>
01:49:25 <phadej> % foldMap Sum [1,2,3]
01:49:25 <yahb> phadej: Sum {getSum = 6}
01:49:32 <phadej> % foldMap (Just . Sum) [1,2,3]
01:49:33 <yahb> phadej: Just (Sum {getSum = 6})
01:49:39 <phadej> % foldMap (Just . Sum) []
01:49:40 <yahb> phadej: Nothing
01:49:45 <phadej> % foldMap (Just . Data.Semigroup.Min) []
01:49:45 <yahb> phadej: Nothing
01:49:50 <phadej> % foldMap (Just . Data.Semigroup.Min) [1,2,3]
01:49:51 <yahb> phadej: Just (Min {getMin = 1})
01:49:56 <phadej> % foldMap Data.Semigroup.Min [1,2,3]
01:49:57 <yahb> phadej: ; <interactive>:49:1: error:; * Ambiguous type variable `a0' arising from a use of `print'; prevents the constraint `(Show a0)' from being solved.; Probable fix: use a type annotation to specify what `a0' should be.; These potential instances exist:; instance Show a => Show (ZipList a) -- Defined in `Control.Applicative'; instance Show a => Show (Complex a) -- Define
01:50:05 <phadej> % foldMap Data.Semigroup.Min [1,2,3 :: Int]
01:50:05 <yahb> phadej: Min {getMin = 1}
01:50:21 <phadej> % foldMap Data.Semigroup.Min ([] :: Int)
01:50:22 <yahb> phadej: ; <interactive>:51:29: error:; * Couldn't match expected type `Int' with actual type `[a0]'; * In the second argument of `foldMap', namely `([] :: Int)'; In the expression: foldMap Data.Semigroup.Min ([] :: Int); In an equation for `it': it = foldMap Data.Semigroup.Min ([] :: Int); <interactive>:51:29: error:; * Couldn't match expected type `[a]' with actual type `Int'; * In t
01:50:26 <phadej> % foldMap Data.Semigroup.Min ([] :: [Int])
01:50:27 <yahb> phadej: Min {getMin = 9223372036854775807}
01:50:30 <phadej> ah
01:50:33 <phadej> % foldMap Data.Semigroup.Min ([] :: [Integer])
01:50:33 <yahb> phadej: ; <interactive>:53:1: error:; * No instance for (Bounded Integer) arising from a use of `foldMap'; * In the expression: foldMap Data.Semigroup.Min ([] :: [Integer]); In an equation for `it': it = foldMap Data.Semigroup.Min ([] :: [Integer])
01:59:48 <tty1> Hey guys for learning purposes I'm trying to define my own class but i cant really figure out the format for what im trying to do
02:02:46 <tty1> I want to create a class called Id. The class itself should derrive from 4 other classes (Hashable, eq, ord, functor). I also want it to define two functions one called identify takes in an Id and returns a type of (Hashable, eq, ord), the other function called obj takes in an Id and returns a functor.
02:03:38 <ski> s/derrive from/subclass/
02:05:28 <tty1> ski: sure
02:05:32 <ski> if `Id' is to be a type class, then having a function that "takes in an Id" doesn't make sense. `Id' is not a (concrete) type. however, you could have your function be polymorphic, so that you can take in an `a', as long as `a' is an instance of your type class `Id'
02:05:52 <ski> similarly, "returns a functor" doesn't make sense
02:06:06 <ski> and "returns a type of (Hashable, eq, ord)" sounds even stranger to me
02:06:46 <tty1> cant imagine why
02:06:53 <ski> in the "returns a functor", you can't even have `f' as return type, provided `f' is an instance of `Functor'. because `f' then would not be a concrete type, but a type function
02:07:14 <ski> e.g., `Maybe' is an instance of `Functor'. however you can't write a function `foo :: Int -> Maybe', that doesn't make any sense
02:07:23 <ski> you have to say, `Maybe' of *what* ?
02:07:50 <ski> similarly, `foo :: Functor f => Int -> f' also doesn't make any sense
02:08:00 <ski> you can say something like `foo :: Int -> Maybe String'
02:08:10 <ski> or `foo :: Functor f => Int -> f String'
02:08:15 <ski> tty1 : making any sense ?
02:08:33 <tty1> hmm maybe
02:09:12 <tty1> ski: so in the example of Maybe i would want "A maybe of anything"
02:09:18 <ski> anyway, "takes in an Id" is really nonsense. but sometimes people use sloppy terminology, and really mean "takes in an `a', where we know `Id a'"
02:09:19 <tty1> So "Maybe a"?
02:09:27 <ski> and that could be written as `bar :: Id a => a -> ...'
02:09:43 <ski> tty1 : that would work, yes. also in the `f' case
02:10:16 <ski> so .. perhaps you want something like
02:10:27 <tty1> ski: my main issue is i cant seem to figure out how to derrive a class from all 4 of those other classes
02:10:34 <ski>   obj :: (Id a,Functor f) => a -> f b
02:10:47 <ski> you don't derive classes from other classes
02:10:50 <ski> that's not a thing
02:11:06 <tty1> hmm
02:11:07 <ski> deriving is something that you do, when you declare a `data' type (or `newtype')
02:11:35 <ski> and it means that you're asking the system to generate instances of that type, for the specified type classes
02:11:51 <ski> and it only works for a few built-in type classes
02:12:21 <ski> like `Eq',`Ord',`Enum',`Bounded',`Ix',`Show',`Read'
02:12:32 <ski> @src Bool
02:12:32 <lambdabot> data Bool = False | True deriving (Eq, Ord)
02:12:55 <ski> the `deriving (Eq,Ord)' there means that it'll generate the following two instances for you :
02:13:00 <ski>   instance Eq Bool
02:13:01 <ski>     where
02:13:12 <ski>     True  == True  = True
02:13:17 <ski>     False == False = True
02:13:26 <ski>     _     == _     = False
02:13:32 <ski>   instance Ord Bool
02:13:33 <ski>     where
02:13:57 <ski>     True  `compare` True  = EQ
02:14:05 <ski>     True  `compare` False = GT
02:14:13 <ski>     False `compare` True  = LT
02:14:17 <ski>     False `compare` False = EQ
02:14:29 <ski> tty1 : so, that's what `deriving' does
02:14:54 <ski> otoh, when you declare/define a type class, like
02:14:59 <ski>   class Eq a => Ord a
02:15:02 <ski>     where
02:15:09 <ski>     compare :: a -> a -> Ordering
02:15:12 <ski>     ...
02:15:35 <ski> then this defines the type class `Ord', and specifies `Eq' as a super class of this new class `Ord'
02:15:39 <tty1> hmmm
02:15:54 <ski> so, we don't say that `Ord' derives from `Eq', we say that `Ord' is a subclass of `Eq'
02:16:32 <ski> so, it sounds like you want something like
02:17:06 <ski>   class (Hashable ...,Eq ...,Ord ...,Functor ...) => Id ...
02:17:08 <ski>     where
02:17:16 <ski>     ...
02:17:31 <ski> did you mean for `identity' and `obj' to be methods of this class, or not ?
02:17:55 <tty1> ski: yes but i know how to implement those its the first line i cant get right
02:18:05 <ski> perhaps we should go back to trying to make sense of what you want the types of `identity' and `obj' to be ?
02:18:28 <ski> well, can you tell me the signatures of `identity' and `obj', then ?
02:18:48 <tty1> ski: yea I think so... hmm
02:19:48 <tty1> identity :: (Hashable i, Ord i, Eq i) => a -> i
02:19:56 <tty1> where a is a type of Id
02:20:10 <tty1> or any type that implements Id class
02:20:12 <ski> `a' is a type which is an instance of `Id'
02:20:15 <ski> right
02:20:18 <tty1> or however you want to word it
02:20:25 <tty1> yea
02:20:28 <ski> and, `identity' and `obj' are to be methods of `Id' ?
02:20:34 <tty1> correct
02:20:37 <ski> okay
02:20:45 <jusss> $ and id are not same?
02:21:06 <jusss> id::a->a    $::(a->b)->a->b
02:21:08 <tty1> obj is... obj :: (Functor f) => a -> f b .. where a is an Id again
02:21:40 <ski> jusss : they have the same implementation, but the type is not quite the same. you can use `id' where you used `($)', but not necessarily vice versa. the type of `id' is more general than the type of `($)'. `id' is more polymorphic than `($)'
02:21:55 <tty1> oh yea i forgot id is a special keyword in haskell so not the best name choice
02:22:12 <ski> tty1 : oh, i thought you said it was to be called `identity'
02:22:31 <ski> er, sorry
02:22:37 <ski> you actually said `identify'
02:22:40 <tty1> ski: the class im calling Id the function identity, sorry brain fart there
02:22:57 <ski> which is it, `identity' or `identify' ?
02:23:05 <jusss> ski: yeah, id is related with monoid?
02:23:07 <tty1> either one doesnt matter
02:23:11 <ski> jusss : not really
02:23:33 <jusss> ski: but id return what it takes
02:23:34 <ski> tty1 : ok, going with `identity' atm, since i already typed that a lot of times
02:23:40 <tty1> ok :)
02:23:59 <ski> jusss : yes ?
02:24:10 <ski> tty1 : anyway, what's `b' ?
02:24:16 <jusss> + 0 value,  * 1 value
02:24:37 <tty1> ski: i just used it to mean "any concreate type"
02:24:47 <jusss> they return what they are given
02:24:59 <ski> jusss : yes, `0' is the neutral element for `(+)'. `1' is the neutral element for `(*)'. `[]' is the neutral element for `(++)'. and `id' is the neutral element for `(.)'
02:26:01 <ski> jusss : so, yes, you can *form* four monoids here. that doesn't mean that the elements and binary operations that we start with have to be associated with monoids. we can use these without thinking about monoids at all. but we *can* make use of these forming monoids, if we want to
02:26:13 <ski> tty1 : yes, but the problem is in the "any"
02:26:23 <jusss> ski: ok
02:27:07 <ski> tty1 : more specifically *who* is to pick the specific type `b' that is to be used. is it the *caller* of `obj' who will pick `b' ? or is it the *callee*, iow `obj' itself (more specifically, its implementation), which will pick `b' ?
02:27:33 <ski> tty1 : those are *very* different behaviours, you have to say which of them you want. (or perhaps you want neither)
02:27:48 <tty1> ski: it would be whoever implements an instance of the class I suppose
02:27:52 <ski> (one might say they are *opposite* behaviours)
02:28:14 <ski> tty1 : so `b' is also to be a parameter of the type class, not only `a' ?
02:28:34 <ski> tty1 : is the type class to be a relation between two types, `a' and `b', and not just a property of a single type, `a' ?
02:28:41 <tty1> ski: maybe im trying to wrestle this into a class but its really meant to be done another way,, maybe im seeing classes the wrong way
02:29:09 <tty1> ski: let me try to explain what an Id is actually meant to do
02:29:27 <ski> tty1 : .. it *would* probably help here, if i had an inkling of an idea of what you're attempting to express
02:29:31 <ski> (but i don't)
02:29:40 <tty1> ski: yea... 
02:29:58 <ski> yes, one shouldn't define new type classes without good reason to
02:30:20 <ski> normally one should have at least two, preferably more, instances of it in mind, already
02:30:46 <tty1> ski: so not relevant too much right now but for background im creating a Grah data structure (think of it like a set but with an added component of edges that act as pairings between the elements, this graph-theory sort of graph)
02:31:26 <ski> and, arguably, one should want to be polymorphic (or abstract ?) over instances of the type class somewhere. otherwise one's merely using the type class as an abbreviation, to write a single name, instead of one for each type which is an instance
02:31:47 * ski nods re graphs
02:32:08 <tty1> ski: elements of the set of course need to be Eq, Ord, and Hashable to be able to be added to a set. An end user will do one of two things.. have an object that satisfies this and thus adds directly, or has an object that doesnt satisfy this thus they need to wrap it in something that does.. that is where Id comes in
02:33:12 <ski> "an object that satisfies this" meaning ?
02:33:42 <tty1> ski: I want Id to be the class ill use to implment some sort of Data type.. it will contain two objects.. an UUID, and a "content" or payload (object).. it will be a functor so you can operate on the object inside, but the UUID will handle the eq, ord, and hashable parts
02:33:43 <ski> is "an object" intended to mean "a type" here ? or "a value" ?
02:34:10 <ski> and i don't know what "this" in "satisfies this" refers to
02:34:13 <tty1> ski: I wasnt using object in such a technical way i dont think
02:34:20 <tty1> hmm
02:34:27 <ski> i still don't know whether you're talking about value level or type level
02:34:46 <tty1> ski: by satisfies this i mean it implements those classes as instances i guess
02:35:03 <ski> ok, then it sounds like "an object" means a type
02:35:31 <ski> e.g. `MyVertexType' could be an instance of `Eq',`Ord',`Hashable'
02:35:46 <ski> so "an object" could refer to this `MyVertexType', then
02:36:06 <tty1> yea the earlier attempt i made looked like this: data Node i o = Node { id :: i, content :: o} deriving (Show)
02:36:18 <ski> okay
02:36:18 <tty1> Then i made Node an instance of a few things
02:36:32 <ski> (btw, in that case, you could say just `deriving Show' at the end)
02:38:32 <tty1> ski: i basically was just thinking to start i wanted a class which can let you extract the Id and the content seperately.. basically anything that is an Id is something that has an identifier and some content
02:38:58 <tty1> ski: im thinking of classes a bit like interfaces in other languages
02:39:49 <ski> "I want Id to be the class ill use to implment some sort of Data type.. it will contain two objects.." already sounds strange to me
02:40:20 <ski> tty1 : that's really a good analogy
02:40:30 <ski> er
02:40:37 <ski> that's *not* really a good analogy :)
02:40:47 <tty1> yea im starting to see that
02:41:17 <ski> if you want something like a Java interface, you can often do nicely with just a record type
02:41:45 <ski> iow, your `Node i o', which is a record type
02:42:08 <tty1> hmmm
03:13:13 <Phyx-> cocreature: ah forgot about those. If I remember correctly the bindist was built without optimization and was missing a haddock symlink, but the compiler itself shouldn't have a correctness issue
03:55:21 <maerwald> who knows how to write a prism from Fold to Fold1
04:35:00 <phadej> maerwald: you cannot do that conversion, if you have Fold, you cannot "upcast" it.
04:42:36 <phadej> you ask for something like `fromJust :: Maybe a -> a`
05:09:52 <Putonlalla> This could do with a ten-year update: https://en.wikipedia.org/wiki/Clean_(programming_language)#Versus_Haskell
05:14:09 <zincy> Do people recommend actually using Heteregenous lists or are they unwieldy? I am writing a type to encapsulate one or more players. data Player a = Player String; data PlayerState = Folded | InHand | SatOut. 
05:14:31 <zincy> The type parameter in player is for a promoted PlayerState constructor
05:16:38 <infinisil> zincy: Can you elaborate some more? I don't see a reason to use heterogenous lists for that
05:16:46 <infinisil> For that usecase
05:17:17 <zincy> :k [Maybe a]
05:17:19 <lambdabot> error: Not in scope: type variable ‘a’
05:17:35 <zincy> If that is * then I can just have a list of Player a
05:18:17 <zincy> My thought was that if you had a list of Players the `a` would have to be the same type for each element in the list. Therefore you would need hetero lists
05:18:45 <MarcelineVQ> Why does the 'a' vary?
05:20:09 <zincy> Because each players will have a different state
05:20:53 <zincy> For example if the player is inactive then that would be encoded in the type  Player 'SatOut
05:25:26 <zincy> Singletons would get around this I think.
05:55:11 <tabaqui> you can encapsulate types with GADTs btw
05:55:56 <tabaqui> I mean if you don't have different classes for different "Player a" types
05:56:24 <tabaqui> probably, you could avoid this "Wrapper (con :: Constraint)"
06:02:15 <zincy> Are GADTs a better approach than singletons for this?
06:06:54 <tabaqui> They don't exclude each other
06:07:03 <tabaqui> I used GADTs with singletons before
06:07:18 <tabaqui> but minimize a code later with extensions
06:07:32 <tabaqui> like SingletonSpace = SatOut | SatIn | SatMid
06:07:56 <tabaqui> data Player (a :: SingletonSpace) where...
06:08:17 <tabaqui> or f.e. data WrapPlayer where Wrap :: Player a -> WrapPlayer
06:08:22 <tabaqui> some sort of
06:13:06 <zmoo> hello Haskell channel
06:13:24 <tabaqui> hi
06:13:26 <Putonlalla> Hello, zmoo person.
06:13:51 <tabaqui> did you just assume its kind? :)
06:13:52 <zmoo> question would it be allright to install the Haskell Stack on a different drive than the rest of the Haskell install?
06:14:20 <tabaqui> I see no problems here
06:14:40 <tabaqui> It's common to separate home haskell packages with development on Stack
06:15:12 <zmoo> I dont know if I have ever used Haskell before, unless some enterprise applications utilize it, but I am installing it now because windows 10 broke msys2
06:15:17 <zmoo> I see thank you
06:15:59 <tabaqui> uh, so it's about Windows
06:16:08 <tabaqui> how do you install "rest of the Haskell"?
06:16:32 <zmoo> using the provided installer with Haskell
06:16:47 <zmoo> just ones on W: and the stack is on C:
06:17:26 <zmoo> i suppose it may not matter to msys since they mount
06:18:18 <zmoo> but your right windows programs may not like it, but as you say the common practice is to seperate the stack and the stack is allright with tthat?
06:19:36 <Solonarv> stack doesn't really care where you put stack.exe
06:20:31 <Solonarv> its data lives in $APPDATA by default, but you should be able to change that if you want to
06:25:24 <ski> zincy : the kind of `[Maybe a]' is `*', yes, under the assumption that `a' has kind `*'
06:28:37 <tabaqui> ski: how can it be valid without the assumption?
06:29:38 <ski> it can't
06:30:49 <ski> > not boolean
06:30:51 <lambdabot>  error: Variable not in scope: boolean :: Bool
06:30:55 <ski> @type not boolean
06:30:56 <lambdabot> error: Variable not in scope: boolean :: Bool
06:32:02 <tabaqui> "*" always means "Hask", right?
06:32:33 <Solonarv> no
06:32:37 <ski> if you have variables that not have been brought into scope, but which are mentioned in your expression (be it a type expression, or an ordinary value expression), then obviously that (value/type) expression is not "complete", so that you e.g. can't figure out the type/kind of it
06:32:44 <Solonarv> Hask is a type synonym for (->)
06:32:53 <Solonarv> (defined in Control.Category)
06:33:15 <Solonarv> * means Type (exported from Data.Kind these days)
06:33:32 <Solonarv> (and that meaning is slowly being deprecated)
06:33:40 <kuribas> isn't * the kind of inhabited types?
06:33:49 <Solonarv> yes, it is
06:33:49 <tabaqui> Hask is a category? Don't objects in Hask are just ADT of Haskell?
06:34:02 <Solonarv> not just ADTs
06:34:09 <tabaqui> ADT plus extensions
06:34:21 <Solonarv> no, all inhabited types
06:34:37 <Solonarv> including e.g. function types (which are not ADTs)
06:34:44 <tabaqui> (->) Int Int?
06:34:59 <Solonarv> yes, (Int -> Int) is an object in Hask
06:35:08 <ski> hm, i see no type synonym `Hask' in <https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.12.0.0/src/Control-Category.html>
06:35:35 <Solonarv> oh, I must have misremembered where it's defined
06:35:36 <tabaqui> Why did you say, that (->) Int Int is not an ADT?
06:36:06 <Solonarv> ...because it isn't?
06:36:24 <Solonarv> ADTs are algebraic data types, defined using products and sums
06:36:36 <ski> regarding the type class `Category', with parameter `cat'. that `cat' corresponds to to the `Hom'-class of morphisms between any two objects in the category
06:36:43 <tabaqui> data Function a b = (->) a b?
06:36:52 <Solonarv> well, that's not valid Haskell
06:37:01 <Solonarv> and also isn't how (->) is defined
06:37:14 <Solonarv> the definition would have to look something like: data a -> b = ???
06:37:28 <Solonarv> but there is nothing you can write in place of ???
06:38:05 <kuribas> you can write type Function a b = (->) a b
06:38:22 <ski> a category consists both of a class of objects, and for each pair of objects, a class of morphisms, and then also of operations specifying identity morphism, and composition of morphism, and finally three laws expressing that composition is associative, and that identity morphisms are neutral elements of compositions
06:39:15 <ski> in math, usually a category would be named after its class of objects, perhaps with some qualifier to give a hint of which classes of morphisms to use, if it's not evident
06:39:18 <tabaqui> right, but why morphism are not objects in Hask?
06:39:35 <tabaqui> you still have arrows between them as between any objects
06:39:43 <ski> morphisms in a category are not objects in that same category
06:39:57 <tabaqui> it's not an axiom
06:40:13 <tabaqui> I mean that *can* be objects
06:40:17 <kuribas> ski: but they could refer to the same thing?
06:40:58 <Solonarv> tabaqui: "sets"(really types) of morphisms are objects
06:41:00 <ski> (well, maybe they could be, in strange cases. but they're not required to, and normally wouldn't be. i don't think it helps to confuse them)
06:41:40 <ski> anyway, when talking about instances of the `Category' type class, unlike the usual naming situation in math, the instances *would* be named after the classes of morphisms
06:41:58 <ski> so e.g. `instance Category (->) where ...'
06:42:18 <kuribas> ski: I mean, if in haskell an object is a type, and a morphism a function between types, then that function would be also a type, so a morphism, right?
06:42:36 <kuribas> ski: in hask
06:42:39 <ski> this describes the category of objects of kind `*', with morphism class between two objects (being concrete types) `a' and `b' being `a -> b'
06:42:49 <ski> this category is sometimes called `Hask'
06:43:06 <Solonarv> kuribas: no, the type of *all* morphisms between two objects (types) is an object (type) again
06:43:11 <ski> (but i wouldn't refer to the `Hom'-class operation, here `(->)', as `Hask')
06:44:11 <Solonarv> if A, B are types (objects in Hask), then any individual function A -> B is a morphism from A to B, and 'A -> B' itself is a type (object in Hask) again
06:44:14 <kuribas> Solonarv: is a morphism in hask a function, or the type of a function?
06:44:26 <Solonarv> the former: a morphism is a function
06:44:35 <kuribas> right
06:44:59 <ski> <kuribas> ski: I mean, if in haskell an object is a type, and a morphism a function between types, then that function would be also a type, so a morphism, right?
06:45:02 <ski> no
06:45:53 <kuribas> ski: Solonarv already answered my question
06:46:05 <Solonarv> as an example, let's consider the objects (types) Int and Bool
06:46:26 <Solonarv> then 'even' is one particular morphism from Int to Bool
06:46:30 <ski> kuribas : (a) using that `Category' type class, an object doesn't need to be a concrete type (a type of kind `*'); and (b) even if we consider the instance i mentioned above, where objects *are* concrete types, and morphisms *are* functions between such types, then still, *certainly*, such functions would *not* also be types
06:46:57 <tabaqui> so back to my question
06:47:12 <tabaqui> in mathematical sense Hask = Cat(*, ->)
06:47:36 <ski> (i would not say "any individual function A -> B". `A -> B' is not a function. i could say "any individual function of type `A -> B'")
06:47:52 <Solonarv> (yes, I was abbreviating)
06:47:53 <ski> tabaqui : basically, yes
06:48:40 <ski> (or "in" instead of "of type", if you want it shorter)
07:44:56 <tty1> Is "Maybe" a sort of class or a sort of Data? Im trying to understand classes better and im starting to think their something entierly different than a type or a kind .. in fact when i investigate them with `:k` they appear to be of kind "constraint"...
07:45:36 <Solonarv> well..
07:45:37 <Solonarv> % :k Maybe
07:45:37 <yahb> Solonarv: Maybe :: * -> *
07:45:56 <Solonarv> this should tell you that is isn't a typeclass; instead it's a (parameterized) type
07:46:31 <Solonarv> you can even look at its definition:
07:46:31 <Solonarv> @src Maybe
07:46:32 <lambdabot> data Maybe a = Nothing | Just a
07:46:39 <tty1> why what would a typeclass look like?
07:46:45 <tty1> % :k Eq
07:46:45 <yahb> tty1: Eq :: * -> Constraint
07:47:25 <Solonarv> you can also use :info (or :i for short):
07:47:25 <Solonarv> % :i Maybe
07:47:25 <Solonarv> % :i Eq
07:47:27 <yahb> Solonarv: data Maybe a = Nothing | Just a -- Defined in `GHC.Maybe'; instance Alternative Maybe -- Defined in `GHC.Base'; instance Applicative Maybe -- Defined in `GHC.Base'; instance Eq a => Eq (Maybe a) -- Defined in `GHC.Maybe'; instance Functor Maybe -- Defined in `GHC.Base'; instance Monad Maybe -- Defined in `GHC.Base'; instance MonadPlus Maybe -- Defined in `GHC.Base'; instance Semigroup a => Monoid (Maybe
07:47:27 <yahb> Solonarv: class Eq a where; (==) :: a -> a -> Bool; (/=) :: a -> a -> Bool; {-# MINIMAL (==) | (/=) #-}; -- Defined in `GHC.Classes'; instance Eq BS.ByteString -- Defined in `Data.ByteString.Internal'; instance Eq BSL.ByteString -- Defined in `Data.ByteString.Lazy.Internal'; instance [safe] (Eq w, Data.Functor.Classes.Eq1 m, Eq a) => Eq (WriterT w m a) -- Defined in `Control.Monad.Trans.Writer.Lazy'; insta
07:47:49 <Solonarv> (a bit noisy here, looks better if you do it in your local GHCi)
07:48:00 <tty1> hmmm
07:49:05 <Solonarv> if you're familiar with generics/templates in other languages (say Java, or C++, or...), Maybe is similar
07:57:15 <tty1> Solonarv: yea maybe is less confusing to me than classes right now.
07:59:44 <Blar> Servant’s `serveDirectoryWebApp` is not working as expected: https://pastecode.xyz/view/88284d44
07:59:59 <Blar> I would like to have multiple paths under which I want to serve static files.
08:00:32 <unyu> tty1: If you are familiar with concepts in C++, a first approximation to classes in Haskell is “concepts that the type checker actually understands”.
08:00:55 <tty1> unyu: hmmm
08:04:08 <earnestjfk> I'm running into "Process exited with code: ExitFailure 1" with Stack 1.9.3 and GHC 8.6.5 on Windows 10 (inside Parallels) after "stack clean --full", any suggestions? The Cabal configure step works and it's unclear from the output what command is actually failing: https://gist.githubusercontent.com/earnestjfk/d10fa0a8362353b5dd13b40aa66975c2/raw/6582eb9577c9db891aca13876a13161775d1f0d3/parrot-stack-build-powershell-parallels-v
08:05:23 <reygoch> Is there some kind of utility to convert generic record to touple?
08:08:32 <aveltras> is there a known pattern to group different data types together in a "sum type" (without it being directly an adt, types could come from different modules) so that i can then have a function taking as input that sum type and pattern matching on the components to produce a specific result for each type ?
08:09:00 <aveltras> what i have in mind is some kind of "total handler" for diverse request types
08:09:16 <lyxia> reygoch:    gcoerce :: forall a b. (Coercible (Rep a) (Rep b), Generic a, Generic b) => a -> b ; gcoerce = to . (coerce :: Rep a () -> Rep b ()) . from
08:09:31 <Solonarv> you can use Either, or define a custom sum type like: data Thing = FooThing Foo | BarThing Bar | ...
08:10:28 <Solonarv> or if you don't want to define a custom type you can use some sort of anonymous sum type based on type-level wizardry
08:10:44 <unyu> Doesn't that kind of code get disgusting quickly?
08:10:46 <reygoch> lyxia: is this a standard function?
08:12:04 <aveltras> Solonarv: by anonymous sum type, you 're refering to sth like servant's :<|> ?
08:12:17 <lyxia> reygoch: no it's not in the standard library
08:12:39 <reygoch> lyxia: ah, I just found it in generic-data package
08:12:48 <Solonarv> I actually don't know what exactly servant's :<|> is; I'm cooking up an example, give me a minute
08:12:58 <aveltras> Solonarv: ok thanks
08:13:10 <reygoch> Solonarv: type family if I remember correctly?
08:13:19 <lyxia> reygoch: yeah I wrote it
08:13:30 <reygoch> lyxia, :D
08:16:06 <Solonarv> aveltras: example using the vinyl library: https://gist.github.com/Solonarv/4eecb1d809d410f71cea643731f55bd3
08:19:26 <aveltras> Solonarv: in this, can the Result type vary depending on Foo or Bar ?
08:19:51 <aveltras> im thinking about one to one correspondance between a request and a response
08:19:56 <aveltras> request being grouped in this sum type
08:20:35 <Solonarv> oh, I see
08:28:02 <Blar> How does Servant know which handler to use? https://docs.servant.dev/en/stable/tutorial/Server.html#more-endpoints
08:28:35 <dmwit> aveltras: Perhaps a data family would suit your needs.
08:28:38 <Blar> How can it know that it has to call the `albert` function when a user visits the corresponding web address?
08:28:54 <dmwit> aveltras: Each module can define its own data instance, but you get a nice uniform way to refer to all of them.
08:29:17 <Blar> Is it because `server2` has to keep the same order?
08:30:11 <dmwit> aveltras: e.g. in your library, you write `data family ReqResp a`; your client module would write something like `data Foo; data instance ReqResp Foo = ReqRespFoo { request :: Int, response :: Bool }`.
08:31:14 <dmwit> aveltras: You would then probably also include a class for doing things with these, as in perhaps `class Log a where log :: ReqResp a -> IO ()` or similar in your library and `instance Log Foo where log (ReqRespFoo req resp) = return ()` in your client.
08:32:31 <dmwit> If you need to be able to distinguish which parts are the request and which the response, you can split `ReqResp` into two data families, one for `Req` and one for `Resp`, and write `type ReqResp a = (Req a, Resp a)` or whatever.
08:35:06 <aveltras> dmwit: ok thanks for the examples, i'll see if i manage to code sth with this :)
08:35:13 <aveltras> Solonarv: thanks for your gist too
08:45:45 <noipmusp> Hi, I'm looking for the function `(m a, m b) -> m (a, b)`. Is there any?
08:46:03 <Taneb> :t uncurry $ liftA2 (,)
08:46:05 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
08:46:11 <noipmusp> Thanks!
08:46:29 <Taneb> :)
08:51:50 <noipmusp> Taneb: Is there any other, more obvious way, to turn two monadic function into one?
08:52:06 <Taneb> :t (<*>)
08:52:08 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:52:25 <Taneb> noipmusp: what exactly are you trying to achieve?
08:54:32 <noipmusp> I wanna match parts of state from state monad – like `(get fieldA, get fieldB) >>= \(a, b) -> ...`
08:56:18 <Taneb> Right, you can skip the uncurry with something like "(,) <$> get fieldA <*> get fieldB" or "liftA2 (,) getFieldA getFieldB"
08:56:26 <ocharles> You could also `gets (\x -> (fieldA x, fieldB x))`
08:56:48 <noipmusp> That's it. Thank you again.
08:57:14 <Taneb> :) happy haskelling!
09:09:05 <ski> noipmusp : not "monadic functions", but "monadic actions"
09:09:28 <unyu> ski: But it's like a function in any other language isn't it? :-p
09:09:29 <noipmusp> ski: why they are called "actions"?
09:10:00 <ski> noipmusp : they express some "effect" that may result, when "executing" them (in order)
09:10:21 <ski> unyu : no. functions take parameters
09:10:36 <lyxia> actions are things that "do"
09:11:31 <ski> unyu : you can of course have zero parameters, if you allow multiple-parameters. but the general concept of function (and also procedure) explicitly is about a chunk of computation (an expression, or a command), parameterized over some free variables
09:11:33 <Shockk> for example, the result of putStrLn "hello world" is a value that encapsulates the act of printing that string followed by a new line
09:11:53 <unyu> ski: I was joking, but Kleisli arrows are really like functions in any other language, right?
09:12:28 <jkachmar> If I have an API generated by `servant`, and client functions generated by `servant-client` from this API definition, is there any way for me to inject an HTTP header into the request _without_ modifying the API type or the generated functions?
09:12:36 <jkachmar> I know of one way, but it is quite unpleasant and I'd rather not do that
09:12:54 <ski> unyu : and, since *Haskell* doesn't have multi-parameter functions, saying "monadic functions" when you mean "monadic actions" is incorrect. it's not that it's more general, less specific, than it needs to be. it's that a function in Haskell always takes exactly one parameter
09:13:38 <ski> unyu : (re Kleisli), basically, yes (well, if you have call-by-value. i think one of the Algol versions also had call-by-name which would correspond to `m a -> m b', rather)
09:17:07 <jkachmar> actually I'm incorrect, the way I can think of to do this would necessarily involve me regenerating client functions which makes it more unpleasant but at least possible
09:18:30 <tabaqui> implementation of (Monad m => Category (Kleisli m)) can be eta-reduced
09:18:56 <tabaqui> Kleisli (\b -> g b >>= f) == Kleisli (g >=> f)
09:19:15 <tabaqui> (not exactly eta-reduced, but somewhat)
09:45:53 <shapr> good afternoon #haskell !
09:46:26 <tabaqui> East Europe? Asia?
09:46:28 <tabaqui> Hey
09:47:15 <jle`> instance Monad m => Category (Kleisli m) where (.) = coerce (<=<)
09:47:59 <tabaqui> even better
09:48:20 <Solonarv> I think that needs a few more type annotations/applications unfortunately
09:48:37 <jle`> it does, but i like to pretend
09:49:09 <Solonarv> fair enough
09:49:43 <tabaqui> the reason, why I even mentioned this - sometimes short idiomatic code gives you needed insight
09:50:13 <ocharles> Anyone know how I can force all elements of a Data.Set.Set to be in WHNF?
09:50:51 <Solonarv> ocharles: foldl' seq () ?
09:50:57 <ocharles> Hmm hang on, to construct that `Set` `f x` would have to be evaluated for each element anyway
09:51:07 <jle`> maybe foldr
09:51:09 <ocharles> I think it's enough to just make sure that the `Set` itself is in WHNF
09:51:13 <Solonarv> well no, not necessarily
09:51:16 <jle`> ocharles: not necessarily true, for like S.singleton
09:51:29 <ocharles> Hm
09:51:32 <Solonarv> also depends on how strict the Ord instance for the element type is
09:51:39 <tabaqui> nope
09:51:51 <tabaqui> seq (IM.singleton 0 [1..]) doesn't hang
09:52:04 <jle`> IM is different from Set
09:52:06 <Solonarv> well no, of course it doesn't
09:52:12 <jle`> the seq there applies to the key, not to the values
09:52:24 <Solonarv> the WHNF of [1..] is (1 : [2..])
09:52:26 <tabaqui> hmm, right
09:52:30 <Solonarv> it doesn't go any further than that
09:52:40 <Solonarv> > [1..] `seq` ()
09:52:42 <lambdabot>  ()
09:52:46 <jle`> ocharles: but actually WHNF-ing might do it, since Set is bang-patterned on its fields
09:52:47 <Solonarv> see, doesn't hang
09:52:59 <tabaqui> Set is search tree, right?
09:53:09 <jle`> ocharles: it's strict on its values and its spline
09:53:18 <ocharles> Oh yea, that's somewhat surprising
09:53:26 <ocharles> But what I want :)
09:53:28 <jle`> looking at https://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Set-Internal.html#t:Set
09:53:28 <Solonarv> oh, so it is
09:53:38 <Solonarv> just need to WHF the set itself then
09:53:40 <jle`> @let data MyType = MT !Int !Bool !String
09:53:43 <lambdabot>  Defined.
09:53:54 <jle`> > seq () (MT undefined undefined undefined)
09:53:54 <tabaqui> jle`: nope, try S.size (S.singleton [1..])
09:53:56 <lambdabot>  error:
09:53:56 <lambdabot>      • No instance for (Show MyType)
09:53:56 <lambdabot>          arising from a use of ‘show_M38641499021811328612086’
09:54:00 <tabaqui> it will not hangs too
09:54:00 <ocharles> Cool, so a bang pattern on the recursive function that uses the `Set` should be sufficient here then
09:54:01 <jle`> @undefine
09:54:01 <lambdabot> Undefined.
09:54:23 <jle`> tabaqui: that shouldn't hang because [1..] in WHNF doesn't hang
09:54:29 <jle`> that is desired behavior
09:54:36 <tabaqui> oh, Weak form
09:54:44 <ocharles> For context, I have `go (Set.fromList (map f xs))` where `xs` is a `[ByteString]` that is biiiig - about 800mb. But `f` is a hashing function. So I want to make sure I am just recursing with a set of hashes and not retaining these bytestrings any longer than necessary
09:54:46 <jle`> @let data MyType = MT !Int !Bool !String deriving Show
09:54:46 <tabaqui> stupid non-mathematical Weak form
09:54:47 <lambdabot>  Defined.
09:54:53 <jle`> > seq () (MT undefined undefined undefined)
09:54:54 <ocharles> So I think `go !lastSeen` should be sufficient, will try
09:54:56 <lambdabot>  *Exception: Prelude.undefined
09:54:58 <ocharles> Thanks for entertaining these thoughts
09:55:12 <jle`> so yeah, all the fields are strict, so seq-ing the main set should seq all the sub fields
09:55:31 <ocharles> > Data.Set.fromList [1]
09:55:34 <lambdabot>  fromList [1]
09:55:41 <ocharles> > seq (Data.Set.fromList [undefined]) ()
09:55:43 <lambdabot>  *Exception: Prelude.undefined
09:55:46 <jle`> ocharles: if you use Set.fromList then you are going to be forcing evaluation already
09:55:48 <ocharles> Looks reasonable
09:56:01 <jle`> > Set.length (Set.fromList [undefined])
09:56:04 <lambdabot>  error:
09:56:04 <lambdabot>      Not in scope: ‘Set.length’
09:56:04 <lambdabot>      Perhaps you meant one of these:
09:56:10 <jle`> > length (Set.fromList [undefined])
09:56:13 <lambdabot>  error:
09:56:13 <lambdabot>      Not in scope: ‘Set.fromList’
09:56:13 <lambdabot>      Perhaps you meant one of these:
09:56:20 <jle`> > length (Data.Set.fromList [undefined])
09:56:22 <ocharles> jle`: Sure, if you *use* the `Set`
09:56:22 <lambdabot>  *Exception: Prelude.undefined
09:56:28 <Solonarv> @let import qualified Data.Set as Set
09:56:30 <lambdabot>  Defined.
09:56:33 <tabaqui> hehe
09:56:44 <ocharles> `go (Set.fromList (map f xs))` will retain `xs` until the `Set` is used.
09:56:45 <tabaqui> S.size (S.fromList [[1..], [1..]])
09:56:49 <jle`> ocharles: good caveat :)
09:57:10 <tabaqui> because it is a search tree
09:57:20 <tabaqui> and it cannot compare [1..] with [1..]
09:57:51 <Solonarv> yes, it isn't possible to decide that two infinite lists are equal
09:58:16 <Solonarv> however this works:
09:58:16 <Solonarv> > Set.size (Set.fromList [[1..], [2..]])
09:58:18 <lambdabot>  2
10:58:01 <talqu> hi, im following this example https://github.com/haskell-servant/servant-auth#readme and getting the same error as here https://github.com/haskell-servant/servant-auth/issues/29. In the issue they talk about version 0.2.2.0, im using 0.4.4.0. Any ideas how can I fix this? If not, which else library for servant could i use for browser authentication? This seemed the most used, unfortunatly, i get that error :/
11:00:09 <IsProp> jle`: I appreciated our discussion the other day. Indeed, I began thinking about lazy evaluation and their relationship to things like generators and co-routines.
11:00:58 <IsProp> jle`: On the surface, it may not seem like lazy eval has anything to do with those things, but they do. In Python, for example, a generator does not run when it is created. That's a 'thunk' like the redexes in a lazy term evaluation.
11:01:15 <IsProp> jle`: So thank ya for that.
11:02:01 <IsProp> As for the reason I have returned: I need help with finding a corpus of regular expression test data. It would need to have the regex pattern and one or more positive subject strings known to match with it.
11:03:54 <IsProp> The only other way I know about going about this problem is to generate regex patterns programmatically, which would have to be precise and not generate incorrect patterns, and then the hard part would be permutating it.
11:04:31 <IsProp> So if anyone here knows of any such tools it would be most helpful.
11:10:05 <zachk> IsProp, do you have to use regular expressions? why not parser combinators?
11:10:29 <IsProp> zachk: It is to test a regex engine, so it has to be those patterns.
11:10:40 <zachk> oh
11:10:51 <IsProp> zachk: Trying to 'fuzz' test a custom engine.
11:11:42 <IsProp> zachk: And it's a bit of a circular problem because how do I know my test case generator is correct. I suppose I could verify it using a pre-existing regex implementation.
11:12:21 <IsProp> I also thought about creating triples of the form (<pattern>, <positive-subject>, <negative-subject>)
11:12:31 <IsProp> To test for false positives, etc.
11:15:01 <IsProp> I think the practical route now is to find a library of known good regex patterns. Like some repository of non-trivial ones used in practice. I think what I can do is then select a sufficiently large corpus and run them all against it using a known good regex engine and record all matches. Then, I will do the same for my engine and see if they are identical.
11:16:37 <IsProp> Ah hah, here is an entire database of them: http://regexlib.com/?AspxAutoDetectCookieSupport=1
11:34:49 <dmwit> talqu: You are getting an error when using the exact code in the readme?
11:34:51 <talqu> https://pastebin.com/BmsqSTLm I got rid of the error before moving the static file serving to unprotected api. However, now I only the first path works (line 15). The following paths stoped working.
11:36:19 <talqu> However I could serve multiple static path with that same code before I was servant.Auth.Server. weird 
12:06:57 <talqu> I found the exact same issue. https://github.com/haskell-servant/servant/issues/934#issuecomment-377193118 Why did it stop serving multiple paths when I added servant.Auth.Server, I'm confused
12:27:06 <shadow147> ?
12:27:30 <dmwit> !
12:27:57 <Solonarv> ‽
12:28:28 <dminuoso> % :t flip ($)
12:28:28 <yahb> dminuoso: a -> (a -> c) -> c
12:29:06 <dmwit> .̧
12:31:14 <dminuoso> ski: Something disturbs me with viewing ⌜∀x. B(x)⌝ as a type in itself. It's that I've learned and repeated the mantra that ⌜f :: ∀x. C(x) => B(x)⌝ reads "forall choices of a type x, where C(x) is satisfied, f has type B(x)"
12:32:14 <dminuoso> Perhaps it's a great vessel for teaching type schemas to beginners, but the more you think about values and types, the less it seems to work.
12:35:18 <MarcelineVQ> dminuoso: getting your Π on?
12:37:06 <Solonarv> that is the generalization, yes :D
12:37:09 <dminuoso> MarcelineVQ: Heh, indeed I've started diving into dependent typing.
12:37:29 <ski> dminuoso : how about ⌜f ∷ σ → τ⌝ reading "for all ⌜x⌝ of type ⌜σ⌝, ⌜f x⌝ has type ⌜τ⌝ ?
12:40:16 <ski> dminuoso : recall that in System F, you have ⌜p ∷ ∀ α ∷ κ. ⋯α⋯⌝ reading as "for all ⌜α⌝ of kind ⌜κ⌝, ⌜p α⌝ has type ⌜⋯α⋯⌝"
12:41:18 <ski> iow, the step from "forall choices of a type x, where C(x) is satisfied, f has type B(x)" to "f has type : forall choices of a type x, where C(x) is satisfied, B(x)" isn't that large
12:44:32 <ski> (also ⌜p : τ₀ × τ₁⌝ reading as "⌜π₀ p⌝ has type ⌜τ₀⌝ and ⌜π₁ p⌝ has type ⌜τ₁⌝")
12:53:20 <tty1> Hi, im trying to understand how to write subclassed typeclass definitions. I'm just done reading my first haskell book so im uber noob. Can someone look at my code snippet and error and suggest how I could fix it? https://hastebin.com/ucehegahih.hs
12:53:42 <dminuoso> ski: But ⌜∀ α. f α : B(α)⌝ and ⌜f : ∀ α. B(α)⌝ seem like different statements.
12:53:55 <dminuoso> ski: I mean it seems almost as if they are related by a typing jugement like:
12:54:05 <dminuoso> ⌜∀ α. f α : B(α)⌝ :- ⌜f : ∀ α. B(α)⌝
12:54:25 <tty1> ski: this is a continuation of our earlier convo btw (my new attempt)
12:57:22 <dmwit> tty1: The type you've written for `ident` says that the *caller* of `ident` (not the person writing the `Identified` instance) gets to choose a type `i` which satisfies the given constraints.
12:57:38 <dmwit> tty1: And the person writing the `Identified` instance then has to produce a value of that type.
12:58:25 <dmwit> tty1: If you want the instance writer to get to choose `i`, then you might look at either MultiParamTypeClasses+FunctionalDependencies or TypeFamilies.
12:58:54 <dmwit> tty1: e.g. you might write `class Identified t where type I t; ident :: t -> Ident t`.
12:59:00 <dmwit> (Similar comments apply to `obj`.)
12:59:16 <dmwit> However, I have some serious misgivings about this setup. It's not clear to me you should be making a typeclass at all.
12:59:41 <dmwit> e.g. why not just `data Identified i o = Identified { ident :: i, obj :: o }` and be done?
12:59:41 <tty1> dmwit: i have been trying various iterations of multiparam type classes for over a day now.. no matter how i try to rewrite it i cant get it to work. Im probably too new at al this to see what the answer would be. Which is why im asking for what the actual solution would look like so i can see it and try to understand it, since im not sure i can come up with it on my own yet
13:00:47 <tty1> dmwit: im not clear if i should make a typeclass either.. i really am just trying to play with it to understand it, not sure its a good design at all.. but i need some working varient of it so i can at least see how it behaves and what it would look like cause im serious stuck right now
13:00:50 <dmwit> Well, it would look like `class Identified t i o | t -> i o where ident :: t -> i; obj :: t -> o` and `intsance Identified (Identity i o) i o where ident (Identity i _) = i; obj (Identity _ o) = o`.
13:01:13 <dmwit> (All these `Eq`, `Ord`, `Hashable` constraints just seem like they're hiding the core idea to me without really adding anything useful.)
13:01:29 <tty1> dmwit: let me try that out.. I think that `|` in there is new to me and might be what i needed
13:02:19 <dmwit> uh well
13:02:27 <tty1> dmwit: this isnt likely to be useful its just a toy for the moment.. the whole point was for me to better understand classes and how to implement them rather than to do something useful just yet (it may turn into something useful once i understand the parts of it all)
13:02:29 <dmwit> It's not... *needed*. Whether it's *wanted* depends on what you want I guess.
13:03:23 <dmwit> With the `| t -> i o`: each `t` must be associated with a single choice of `i` and `o`. You get better type inference, but are more restricted in what set of instances you write.
13:04:01 <dmwit> Without the `| t -> i o`: you may write multiple instances for a single `t` and different `i` and `o` choices. Basically the opposite tradeoff: worse type inference (since knowing `t` doesn't let you infer `i` or `o`), but you can write a richer set of instances.
13:04:08 <zincy> Do singletons essentially solve the problem of being able to determine the type of `a` in forall a. at runtime instead of compile time?
13:04:35 <dminuoso> ski: Sort of as a PolyApp typing jugdgement. I reckon that the Hindley Milner adaption of Haskell might even have something along those lines to allow for type applications.
13:04:57 <dminuoso> But I wouldn't know, Ive never seen a paper displaying the type system employed by GHC in its fullest.
13:05:25 <tty1> dmwit: i see, thank you.. 
13:08:08 <tty1> dmwit: tried the edits you suggested. here is the new code and new error: https://hastebin.com/koquhexiji.hs
13:11:11 <tty1> oops
13:11:19 <tty1> i think the kernel i ran it in just didnt hve multiparam
13:11:24 <tty1> let me try it in the compiler
13:13:13 <tty1> yea still produces an error just not the error I pasted
13:14:28 <tty1> HEre is the code with the actual error now: https://hastebin.com/rofebuxabu.hs
13:15:32 <Solonarv> TL;DR solution: enable FlexibleInstances as well
13:15:48 <tty1> ok
13:16:37 <tty1> thanks, compiling now.. time to play and learn what this thing is doing now...
13:16:52 <Solonarv> documentation on that extension: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-FlexibleInstances
13:17:36 <Solonarv> basically the Haskell Report is very restrictive regarding what sort of instance declarations are allowed, and GHC follows that unless you tell it not to
13:17:49 <tty1> Solonarv: i feel like i may have gotten deeper down the rabbit hole on that one than is good :)
13:18:21 <Solonarv> FlexibleInstances is a very benign extension tbh
13:18:33 <tty1> Solonarv: is there any advantage to that restrictiveness? would there be any motivation to avoid just setting these things all the time and loosen restrictions always?
13:19:30 <Solonarv> the advantage of that restriction in the report is that it makes typeclasses easier to implement if you just want a report-compliant compiler
13:20:19 <Solonarv> there's not much of a reason to avoid using FlexibleInstances and the like in your code, unless you're really insistent about your code working with mostly-hypothetical compilers that don't support it
13:20:33 <tty1> ahhh so if i take away those restrictions my code may not compile on some compilers
13:21:25 <Solonarv> not quite: some Haskell compilers may not support the FooBar language extension, so code that uses the FooBar extension won't compile with those
13:21:51 <Solonarv> but in practice you will rarely have to work with a compiler that isn't one of the latest ~3 GHC releases, anyway
13:22:24 <tty1> right, makes sense, thanks
13:22:47 <tty1> Now to try to understand what th hell this code is doing :)
13:22:50 <Solonarv> and I believe even a lot of the non-GHC compilers support the "benign" extensions like, for example, FlexibleInstances
13:23:12 <tty1> Solonarv: yea makes sense
13:26:15 <reygoch> Can someone remind me, I think that I've read of a way to have GADTs without the GADTs language extension, but I can't remember the exact ADT syntax for that.
13:27:14 <Solonarv> reygoch: do you mean a way to emulate GADTs without actually enabling GADTs ?
13:27:18 <reygoch> Yes
13:27:48 <reygoch> Solonarv: I remember it being a bit more verbose, but I can't remember exactly how it went
13:28:48 <Solonarv> % data ActualGADT x where ActualInt :: Int -> ActualGADT Int; ActualBool :: Bool -> ActualGADT Bool
13:28:48 <yahb> Solonarv: 
13:28:52 <Solonarv> let's use that as an example
13:29:53 <reygoch> Solonarv: waiting with anticipation :D
13:30:52 <Solonarv> % data FakeGADT x = (x ~ Int) => FakeInt Int | (x ~ Bool) => FakeBool Bool
13:30:52 <yahb> Solonarv: 
13:31:24 <reygoch> Ah.. yes, forgot about type equivalence :D
13:31:32 <reygoch> Solonarv: thanks!
13:32:15 <reygoch> Solonarv: btw, what is the drawback of this approach, except verbosity?
13:32:15 <Solonarv> you need TypeFamilies and TypeOperators to write ~, and ExistentialQuantification to write the constraint there
13:33:38 <Solonarv> well, it's very hard to read IMO
13:33:40 <Solonarv> and very confusin
13:33:53 <reygoch> Solonarv: this way I can actually derive Generic, right?
13:34:04 <Solonarv> I suspect not, let's see
13:34:23 <Solonarv> % deriving instance Generic (FakeGADT x)
13:34:23 <yahb> Solonarv: ; <interactive>:61:19: error: Not in scope: type constructor or class `Generic'
13:34:35 <Solonarv> % import GHC.Generic (Generic)
13:34:35 <yahb> Solonarv: ; <no location info>: error:; Could not find module `GHC.Generic'; Perhaps you meant GHC.Generics (from base-4.12.0.0)
13:34:38 <Solonarv> % import GHC.Generics (Generic)
13:34:38 <yahb> Solonarv: 
13:34:42 <Solonarv> % deriving instance Generic (FakeGADT x)
13:34:42 <yahb> Solonarv: ; <interactive>:64:1: error:; * Can't make a derived instance of `Generic (FakeGADT x)': You need DeriveGeneric to derive an instance for this class; * In the stand-alone deriving instance for `Generic (FakeGADT x)'
13:34:54 * Solonarv sigh
13:35:06 <Solonarv> % :set -XDeriveGeneric -XStandaloneDeriving
13:35:07 <yahb> Solonarv: 
13:35:10 <Solonarv> % deriving instance Generic (FakeGADT x)
13:35:10 <yahb> Solonarv: ; <interactive>:66:1: error:; * Can't make a derived instance of `Generic (FakeGADT x)':; FakeInt must be a vanilla data constructor, and; FakeBool must be a vanilla data constructor; * In the stand-alone deriving instance for `Generic (FakeGADT x)'
13:35:25 <Solonarv> reygoch: doesn't work, as youcan see
13:35:34 <reygoch> damn
13:35:34 <zincy> Are singletons worth the hassle? Seems like they require a lot of boilerplate code.
13:36:53 <Solonarv> reygoch: re readability: I actually like GADT syntax more even for "normal" data types
13:37:20 <Solonarv> it is often more verbose, which can hurt readability - so I don't *always* use it
13:37:45 <reygoch> Solonarv: well, I was hoping to be able to derive Generic instance, but I guess not :D
13:39:10 <Solonarv> there's a library somewhere which can derive Generic for GADTs
13:39:32 <Solonarv> let me see if I can find it
13:39:37 <alx741> hello everyone. I'd love some help with this: I have an incoming stream of data that contains different kinds of JSON objects, I also have a data type and a FromJSON instance (aeson) for each one of those possible JSON objects. The problem is, when I read the raw `ByteString`, I have to try to `decode` (ByteString -> Maybe a) for the first possible type (Maybe Response1) if that gives nothing then try with
13:39:38 <alx741> the next (Maybe Response2), and I end up with a nested set of 'case' where the 'Nothing' case tries up the next posible type
13:39:44 <reygoch> Solonarv: is there a trick to get at least show or eq in a simple manner?
13:39:57 <alx741> How can I improve that mess?
13:40:15 <Solonarv> % deriving instance Show (FakeGADT x)
13:40:15 <yahb> Solonarv: 
13:40:23 <Solonarv> reygoch: simple enough? :P
13:40:33 <Solonarv> % deriving instance Eq (FakeGADT x)
13:40:34 <yahb> Solonarv: 
13:40:44 <Solonarv> % FakeInt 5 == FakeInt 6
13:40:45 <yahb> Solonarv: False
13:40:47 <reygoch> Solonarv, I'll take what you have :D
13:41:09 <Solonarv> reygoch: might not work if there are actual existentials involved though
13:41:27 <reygoch> Solonarv, luckily I don't have any at the moment
13:41:51 <alx741> Note that (I think) binding them won't quite work, because if one of thouse succeeds in the middle I would need it to just short circuit in give that result back, instead of trying to pass that result to the next try...
13:42:01 <alx741> *those
13:42:10 <alx741> *and
13:43:50 <tty1> dmwit: btw your help is really helping me grok this format now, thanks was a huge help
13:46:05 <DigitalKiwi> with hakyll if i have `$if(tags)$ Tags: $tags$ $endif$` it renders "Tags:" if the number of tags is 0 it shows "Tags:" still, how can I make it only show if there are >0 tags? based on this setup https://javran.github.io/posts/2014-03-01-add-tags-to-your-hakyll-blog.html
13:58:31 <tty1> DigitalKiwi: is hakyll a real thing worth checking out? some language varient of haskell? I need to look into this :)
13:58:59 <DigitalKiwi> https://jaspervdj.be/hakyll/index.html
13:59:24 <boj> tty1: it's just a static site generator
13:59:25 <alx741> DigitalKiwi: Sticky situation, `$if(tags)$` only evaluates to False if the `tags` symbol is not defined
13:59:46 <ski> dminuoso : "I mean it seems almost as if they are related by a typing jugement" -- yes, that's one way to think about it
14:00:47 <DigitalKiwi> alx741: yeah :( is there a way to conditionally define something if there are tags?
14:00:53 <alx741> maybe... invoke the compiler like in `if length tags > 0 then let tags = ... ; compiler; else compiler;`
14:01:02 <Solonarv> DigitalKiwi: sure
14:01:14 <Solonarv> let me dig up some more info...
14:01:54 <alx741> so the `let tags` will define 'tags' only when the condition is true... Not sure if that works with how Hakyll expects things to work, but you could try
14:02:49 <tty1> boj: oh, well i do enjoy those. Im a middleman fan myself. worth looking at i guess anyway, but less cool
14:02:56 <alx741> s/compiler/compile (hakyll's compile function)
14:04:40 <Solonarv> should be something like:
14:04:41 <Solonarv> ctxWithTags = if null tags then ctx else listField ... tags ... <> ctx
14:05:14 <Solonarv> where 'ctx' is the previous/default context, and I can't remember how exactly you're supposed to use listField
14:05:31 <ski> <zincy> Do singletons essentially solve the problem of being able to determine the type of `a` in forall a. at runtime instead of compile time?
14:05:40 <ski>   zincy : i don't understand. it can already be that `a' is determined only at run-time, even with Haskell98 code. and what is the problem you mention ?
14:05:49 <ski> zincy ^
14:08:24 <zincy> ski: "We’ve hit upon a fundamental issue in Haskell’s type system: type erasure. In Haskell, types only exist at compile-time, for help with type-checking. They are completely erased at runtime."
14:08:35 <zincy> https://blog.jle.im/entry/introduction-to-singletons-1.html#the-fundamental-issue-in-haskell
14:10:59 <zincy> My question earlier was badly phrased to be honest.
14:11:13 <zincy> I might try again tomorrow when I have had more sleep
14:11:31 <zincy> And worked through some more examples.
14:15:09 <bwe> Hi! I want to use isInfixOf with Data.ByteString.Lazy.Char8, however it's not provided; Data.ByteString.Char8 however provides it. What do you recommend?
14:22:16 <bwe> Err, I realize right now that I should first understand which String type to use when in Haskell. When to use String, Text, ByteString (which variant)?
14:23:18 <alx741> bwe: depends on what are you doing (?)
14:23:50 <geekosaur> String for short stuff (<10-20 chars), generally. Text for general string content, ByteString for things like network streams which are raw octets possibly including some encoded string content
14:23:59 <geekosaur> in general ByteString is for binary content, not text
14:24:46 <bwe> geekosaur: Okay, so for web scraping (HTML) I would pick Text.
14:24:56 <geekosaur> generally, yes
14:25:12 <geekosaur> that said, Text is Unicode, and web pages may have arbitrary encoding
14:26:20 <geekosaur> but unless your'e also implenenting the raw HTTP protocol you probably want Text and tell the HTTP library to convert it
14:27:36 <geekosaur> strict vs. lazy: strict is a single large chunk. lazy breaks it up into smaller chunks which can be streamed, or processed such that earlier no longer necessary parts of the string can be garbage collected
14:28:10 <geekosaur> but if you're talking isInfixOf, you may want strict anyway because it implies you need to hold onto the entire string anyway
14:29:13 <Solonarv> bwe: if your task is specifically web scraping I'd just use a library made for that, instead of using "raw" string operations
14:29:56 <Solonarv> this one is popular I think:
14:29:57 <Solonarv> @hackage tagsoup
14:29:57 <lambdabot> http://hackage.haskell.org/package/tagsoup
14:29:59 <bwe> Solonarv: Yep, I am already opting for Scalpel, however I need to decide which str to use, ain't I? 
14:30:18 <Solonarv> ah, hm, let me have a look
14:31:33 <bwe> geekosaur: I wonder Data.Text has no readFile, is that correct? I am coming from Data.ByteString.Lazy.Char8
14:31:52 <c_wraith> :t Data.Text.readFile
14:31:53 <lambdabot> error:
14:31:54 <lambdabot>     Not in scope: ‘Data.Text.readFile’
14:31:54 <lambdabot>     No module named ‘Data.Text’ is imported.
14:32:07 <c_wraith> @let import qualified Data.Text
14:32:08 <lambdabot>  Defined.
14:32:12 <monochrom> Data.Text.IO
14:32:17 <geekosaur> http://hackage.haskell.org/package/text-1.2.3.1/docs/Data-Text-IO.html
14:32:37 <c_wraith> Oh, right, it's Text that has the separate IO module and ByteString that doesn't
14:33:40 <geekosaur> yeh, ByteString is older, started out as part of ghc internals (fps), and is now stuck with that API
14:36:25 <gentauro> I like ByteString better :)
14:36:38 <bwe> geekosaur: Do I view it correctly for req not returning a Text response type https://hackage.haskell.org/package/req-1.2.1/docs/Network-HTTP-Req.html#g:14? So I need to transform bsResponse into Text...?
14:37:07 <geekosaur> sounds like it gives you the raw response?
14:39:42 <geekosaur> right, this is fairly low level, it gives you the raw response. you'd probably need to inspect the headers to see the Content-Type and specifically charset, then use that to convert it appropriately (http://hackage.haskell.org/package/text-1.2.3.1/docs/Data-Text-Encoding.html)
14:39:43 <bwe> Similarly with Data.Aeson eitherDecode assumes a ByteString. Am I doing it wrong to replace ByteString with Text in my web scraping project?
14:40:35 <geekosaur> the JSON string normally is ByteString because it's ready for the network, and not really suitable for direct inspection
14:42:30 <geekosaur> (in particular, it's using a representation appropriate for javascript, not one for Haskell, which among other things means encoded strings have escapes that haskell's escape processing doesn't recognize as such. so you feed it raw data from the network which is JSON-encoded, and it gives you an appropriate Haskell value
14:42:56 <geekosaur> if you're actually getting JSON, you may prefer to use req's JSON support directly isntead of going through ByteString
14:43:40 <DigitalKiwi> Solonarv alx741 it doesn't like that tags doesn't have a length :/
14:45:16 <tty1> Anyone here use OSK to code haskell, specifically the Haskell for Mac IDE?
14:45:54 <tty1> I dont like the IDE too much but i do find the ability to get information about refernces very useful... Is there a better haskell IDE maybe that has that?
14:45:59 <geekosaur> basically, in the Haskell world we're pedantic about encodings vs. transports. a network stream is raw octets, with encoding determined by usage, so when you get something from one it's generally ByteString which represents raw octets
14:46:31 <DigitalKiwi> https://gist.github.com/Kiwi/46cc1fce02ebf52c919e2d9bb374c995
14:46:42 <geekosaur> if you are owrking with JSON, you feed that to a JSON decoder whih gives you suitable Haskell types (and in particular generally produces Text for string data).
14:46:57 <ski> zincy : it may seem like there's a contradiction between "In Haskell, types only exist at compile-time, for help with type-checking. They are completely erased at runtime." and "it can already be that `a' is determined only at run-time, even with Haskell98 code.", but there is no such
14:47:50 <geekosaur> something like a web page, you inspect the header and then use the appropriate decoder to get Text, so you don't have to worry about how e.g. Â is represented over the network
14:50:22 <geekosaur> some pages are multipart, and you need to use a MIME decoder which should give you Text for HTML content, ByteString for embedded image or file data, etc.
14:51:00 <geekosaur> getting this wrong means eventually you get garbage instead of what you intended, so we're specific about it
14:56:11 <dmwit> I vaguely recall that the JSON spec talks about Unicode codepoints only, and doesn't specify an encoding. But I'm not sure it was always that way (or is still that way?). At least aeson assumes utf-8, which in practice seems to be correct the vast majority of the time.
14:56:45 <dmwit> If you have a Text that conforms to the JSON spec, then wasteful as it sounds, encoding it with utf-8 and passing the resulting ByteString off to aeson may be the most programmer-efficient route.
14:57:27 <geekosaur> aeson still takes a ByteString, per eitherDecode. I suspect that's less about what encoding it expects than that it expects to be given raw data from a network stream, which is an octet string
14:57:28 <dmwit> (And doesn't strike me as obviously troglodytish.)
14:58:43 <dmwit> I don't see how it could be about anything other than what encoding it expects, under the assumption that my half remembered fact about the JSON spec (namely that it is stated in terms of Unicode codepoints) is correct.
14:59:43 <geekosaur> the spec is, yes. that describes semantics, not syntax. the syntax is that of a network stream which is octets
15:00:14 <dmwit> And to convert from octets to Unicode codepoints, what do you do? Answer: you use an encoding.
15:01:20 <geekosaur> the point I was making is that aeson at least expects the common case to be going from raw network data to something directly usable, hence ByteString to some JSON-representable Haskell type.
15:02:00 <monochrom> It is possible that ECMAScript and/or Javascript already specifies UTF-8 so JSON doesn't have to re-state it.
15:02:10 <tty1> there is no way haskell is as hard as im making it... my apologies to you guys ive been trying to learn haskell as i go through a major surgery so I think all the drugs are slowing me down
15:02:18 <geekosaur> how it does it is its problem, not yours; it's trying to present a simple API to go from something directly received from the network (octets) to Haskell-usable value
15:02:31 <geekosaur> tty1, haskell has a lot of new concepts to people used to other languages.
15:02:38 <geekosaur> it does take some time to figure out
15:02:50 <dmwit> It is your problem if you receive your text in a different encoding, or have a Text in your hands instead of a ByteString... as bwe appears to have.
15:02:57 <tty1> geekosaur: that is part of it too I suppose
15:03:13 <geekosaur> right, and there are other decoders for that IIRC
15:03:18 <geekosaur> but they cited that one
15:03:39 <tty1> still i tend to pickup new ideas faster than this
15:03:52 <monochrom> Oh wait, ECMAScript 3 says UTF-16?! Am I reading it wrong?
15:04:04 <geekosaur> tty1, I started out already knowing algebraic types and basic functional programming (SML), so it was IO and laziness that were the hard parts for me.
15:04:19 <tty1> I feel like none of the books are great and the syntax isnt always well explained in those books too
15:04:27 <geekosaur> if you;re starting from Javascript or Python or etc., you get to deal with all of them at once
15:04:36 <bwe> geekosaur + all participated: thanks for helping out =)
15:05:10 <tty1> geekosaur: yea FP is new to me. I picked haskell to learn FPP because it was "pure" and i found the syntax asthetically pleasing
15:05:27 <geekosaur> and some books are better than others. I like Hutton's — but there are multiple boosk because different people learn in differen t ways
15:06:01 <geekosaur> I do not recommend "Learn you a Haskell" unless you have suplemental exercises; otherwise it's like 15 new syntaxes in 15 days and you don't actually learn much of any of them
15:06:24 <monochrom> Haskell is harder for people who have sunk cost investment in other (even opposite) programming styles.
15:07:05 <tty1> geekosaur: i started on learn you a haskell... but it didnt go deep enough and left me confused
15:07:09 <monochrom> For clean slates, Haskell is not hard, but still the extra IO type adds one more thing to learn than other languages.
15:07:15 <geekosaur> exactly
15:07:31 <geekosaur> which is why you need supplemental exercises so you can play with it and pick up the deeper stuff
15:07:40 <geekosaur> @where cis194
15:07:40 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
15:07:49 <tty1> yea well the IO type was part of what drew me to haskell as i have a need for it
15:08:01 <geekosaur> this uses LYAH for at least some of it, but includes more detail and exercises
15:08:12 <tty1> but yea im over 2 decades invested in other languages already
15:11:31 <geekosaur> what helped me most, fwiw, was picking an existing project (in my case xmonad since I already knew X11 APIs) and digging into it
15:12:00 <geekosaur> pick one where you already know what it's doing, so you can use that to orient
15:13:52 <MarcelineVQ> actually I guess it's Γ not reverse L :>
15:14:00 <MarcelineVQ> woops :<
15:21:15 <monochrom> But is :< reverse :> ?
15:21:34 <tty1> geekosaur: yea i have an existing project i want to take over and modify. But first i need to get through understanding the basics
15:24:46 <monochrom> I recommend https://en.wikibooks.org/wiki/Haskell to my students, especially when they are not ready to bet money on a paid book.
15:30:24 <tty1> monochrom: im happy to get a paid book.. I will usually download it first and if i like it buy it later, so no risk
15:47:51 <dmwit> Γ is vertically mirrored L, so the "reverse" of :< is :<
15:48:18 <dmwit> err
15:48:50 <dmwit> horizontally mirrored? The mirror is held horizontal, so things appear to have their vertical relationships modified.
15:49:39 <geekosaur> go stare at XMonad.Layout.Reflect for a while :p
15:50:46 * dmwit holds his head in his hands
15:51:24 <MarcelineVQ> dmwit: your instinct to call it vertical mirroring is correct
15:54:06 <svipal> I think I have a monadic / closure stack that's getting too big 
15:54:42 <svipal> I get : corrupted size vs prev size in fastbin when I use ghci and quit my qpp
16:37:13 <ski> MarcelineVQ : if you split a rectangle vertically, does that mean that you end up with one rectangle above the other one ?
16:52:22 <zachk> ski, to me splitting horizontally or vertically is not clear , unless there is more specifications to it 
17:36:33 <zmoo> question if using haskell install with msys2 tool, if I want to compile/and/or/install additional applications do I use the msys2 package handler pacman and msys2 gcc? Or do I have to compile them using a different method.
17:48:26 <zachk> zmoo, I use cabal from inside of msys2 for haskell packages, and install c libraries that are required for haskell libraries/programs using pacman in msys2
17:49:16 <Solonarv> yep, that's also what I do
17:52:29 <zmoo> well I was asking because I was having problems with linked libraries, well not being found or linked?
18:06:44 <zachk> zmoo, you need to install the correct version of the c libraries via pacman most likely 
18:07:27 <zmoo> yea, ever since the last developers release of 10 or 2019 server, pacman -Syu results in a broken system
18:08:18 <zachk> how recent? I just ran an msys2 update the other month, this year :( 
18:08:25 <zmoo> I have been attempting to be very careful, but Im still managing to break it, any advice on setup is greatly appreciated.
18:09:00 <zmoo> well, it happens just using the version that comes with haskell latest
18:09:11 <zachk> you need to install individual libraries via pacman, I use pacman -Ss I think for what I am searching for than install it 
18:09:18 <zachk> oh
18:09:23 <zmoo> also msys2 version msys2-x86_64-20180531
18:09:26 <zachk> well good luck and have a good night
18:10:26 <zmoo> I will try -Ss thanks
18:19:51 <nshepperd_> Vertical mirroring is when you reverse the vertical axis
18:24:57 <dmwit> I suppose if we want to work in more than two dimensions, then giving the normal rather than the plane of reflection is strictly less information.
18:25:28 <fosterite> more than 3. It's increasingly less higher
18:25:32 <dmwit> So if we must choose a convention, that seems like a nice reason to choose the one nshepperd_ and MarcelineVQ have described.
18:28:22 <monochrom> If our civilization were not proud of "I'm bad at math", I would propose, for reflection, to give the diagonal of the reflection matrix.
18:48:48 <dmwit> Huh. Is that really enough?
18:49:56 <dmwit> Why is that a good choice?
18:50:14 <monochrom> Yes if the reflection matrix is a diagonal matrix.
18:50:51 <monochrom> I guess if a reflection is not aligned with standard axes, use a full matrix.
19:05:21 <dmwit> You have puzzling preferences. =)
20:32:58 <Phyx-> zmoo: you don't have to call cabal from inside msys2, all you need to do is tell cabal where to find msys2 and the lib and header directory. This prevents a lot of issues you would otherwise get by calling using a native application in an emulated posix environment
20:34:38 <Phyx-> zmoo: also when using pacman, you never want to install non native packages, e.g. if you want zlib install mingw-w64-$(uname -m)-zlib, and not "zlib". the latter is a ported posix application using newlib as the c runtime. you'll be mixing multiple C runtimes in one application which will cause issues and break things like signal handlers
20:34:43 <Phyx-> oh.. he left
21:14:04 <iqubic> Singletons are really cool.
21:14:22 <iqubic> just wish we had native support for dependant types in Haskell.
21:19:09 <ski> singletons are awkward
21:24:14 <iqubic> Which is why I'm hoping that Dependent Haskell get finalized soon.
21:24:48 <iqubic> Singletons are an unfortunate quirk of the language that we must be content with for the time being.
21:26:10 <iqubic> What is the current status of Dependent Haskell?
21:32:46 <rotaerk> depends
21:36:01 <iqubic> is that a joke?!?!
21:36:08 <rotaerk> yep
21:36:57 <iqubic> So you don't actually know the status of dependent haskell?
21:37:02 <rotaerk> nope
21:37:09 <iqubic> Darn it.
21:38:50 <slack1256> richard einserberg (I hope that is written correctly) blog says about the work in progress
21:39:00 <slack1256> you could see the date on it to measure activity?
21:43:17 * ski . o O ( `data Singleton (a :: *) :: a -> * where Sing :: (x :: a) -> Singleton a x' )
21:43:25 <iqubic> https://typesandkinds.wordpress.com/2016/07/24/dependent-types-in-haskell-progress-report/
21:43:35 <iqubic> That's from 2016.
21:43:51 * ski . o O ( `class Discrete a where data Singleton (a :: *) :: a -> *; sing :: (x :: a) -> Singleton a x; withSing :: forall (p :: a -> *). Singleton a x0 -> ((x1 :: a) -> (x0 ~ x1) => p x1) -> p x0; withSing_ :: forall (o :: *). Singleton a x0 -> ((x1 :: a) -> (x0 ~ x1) => o) -> o' )
21:44:36 <iqubic> ski: What are you doing?
21:44:56 <ski> just pondering about singletons
21:45:21 <iqubic> I see
21:45:37 <iqubic> What's the current latest verion of GHC?
21:45:53 <c_wraith> 8.6.5
21:46:08 <ski> i was wondering whether one could do something sensible, wrt singletons (or something related ?), for categorical products .. but i couldn't figure out a way
21:46:25 <c_wraith> I think he's behind schedule.  Not unexpected.  But he has kept producing steps along the way, so progress has not halted by any means.
21:46:58 <iqubic> From Eisenburg's blog post:
21:47:09 <iqubic> "GHC 8.6: We’re now talking about a real possibility here."
21:51:29 <iqubic> Also, I've actually been reading Eisenburg Dissertation over the past few weeks. It's really good.
22:12:25 <ski> > isSpace ' '
22:12:28 <lambdabot>  True
22:13:23 <iqubic> I see you are continuing on from the conversation in #emacs
22:17:29 <ski> no lambdabot there
22:17:46 <iqubic> I know.
22:33:00 <nshepperd_> That's not a very spacey space
22:36:22 <ggole> It functions very much like a space in its original context though
23:10:16 <kartikay> So i just checked out what dependent haskell is after reading the messages here
23:10:23 <kartikay> and I went down a rabbit hole
23:11:12 <kartikay> now it seems to me like Dependent Haskell really is the future and standard haskell is pretty much useless :-/
23:13:17 <kartikay> And then I found this with all its dynamic_casts
23:13:20 <kartikay> https://github.com/microsoft/calculator/blob/master/src/Calculator/Controls/CalculationResult.cpp
23:13:35 <kartikay> How do people even write such code!?
23:14:35 <reygoch> So, am I misunderstanding something or do GADTs do not work with DuplicateRecordFields?
23:15:17 <reygoch> I'm getting this error message: Constructors SArticlePage and SArticlePost have a common field ‘alias’,
23:15:18 <reygoch>  but have different result types
