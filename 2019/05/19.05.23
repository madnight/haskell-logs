00:00:23 <ski> iqubic : (flip the arguments). yes, that's a useful initial approximation. (it has its flaws, as other denizens of this channel are quick to point out. but i still thing it can serve a useful purpose, at least for some people)
00:01:31 <iqubic> I never remember the order of the arguments in State. Never ever.
00:02:07 <Solonarv> iqubic: the "computed value" must come last, otherwise the Functor/Applicative/Monad instances don't work
00:02:22 <iqubic> Oh. I suppose that makes sense.
00:02:28 <Solonarv> (this reasoning works for all monads, of course)
00:02:29 <ski> jusss : "but e-> monad is not like Maybe monad or List monad" -- well, yes and no. in some ways `(rho ->)' (the environment/input/reader monad, on environment/input type `rho') *is* just "like `Maybe' monad or `[]' monad"
00:03:00 <Solonarv> additionally, for monad transformers the "underlying" monad is always the second-to-last parameter, otherwise the MonadTrans instance doesn't work
00:03:19 <ski> jusss,iqubic : `Writer w' doesn't "have" `tell'. the type class `MonadWriter w', of which `Writer w' is an instance, has `tell'. `Writer w' is a concrete type, you can pattern-match on it to take it apart
00:03:44 <iqubic> Oh. I see.
00:03:49 <ski> jusss,iqubic : similarly for `State s' vs. `MonadState s', the latter having `get' and `put'
00:03:54 <iqubic> I must have been mistaken.
00:04:16 <iqubic> I'm just so used to using mtl, that I forget how to do stuff without it.
00:04:46 <cocreature> ski: transformers does have specialized versions of tell https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Writer-Lazy.html#v:tell
00:04:50 <ski> jusss,iqubic : now `[]' and `Maybe' don't really have any "corresponding" "monad type classes", like `MonadWriter' or `MonadState'. they're just concrete types, you can pattern-match on values of those types
00:04:52 <Axman6> What all monads do have is return, bind and join, and because of that they also all have mapM, when, forever, etc.
00:05:29 <ski> cocreature : oh, interesting. i hadn't noticed that. i suppose it makes sense, since `transformers' doesn't include the type classes
00:05:48 <iqubic> forever f x = f x >>= forever f x, right?
00:05:54 <Axman6> where what those actually mean depends on the marticular monadc. the meaning of mapM for IO is quite different to its meaning in []
00:06:03 <Axman6> particular*
00:06:45 <iqubic> forever $ putStrLn "Yes" -- the yes function.
00:06:49 <cocreature> ski: yeah transformers has specialized versions of most of the mtl functions
00:07:14 <Axman6> :t forever [True]
00:07:16 <lambdabot> [b]
00:07:25 <Axman6> > forever [True]
00:07:28 <lambdabot>  *Exception: <<loop>>
00:07:33 <Axman6> > forever []
00:07:35 <lambdabot>  []
00:07:36 <iqubic> What does that do?
00:07:56 <Solonarv> forever m = m >> forever m
00:08:08 <Solonarv> er, m >> forever m
00:08:14 <jusss> "map f ma = ma >>= (return . f)"  which this map is?
00:08:34 <iqubic> looks like mapM.
00:08:37 <Solonarv> or perhaps more intuitively:
00:08:38 <Solonarv> forever m = do m; m; m; ... -- goes on forever
00:08:49 <iqubic> But I'm not to sure if that's actually mapM.
00:08:49 <Solonarv> no, that's not mapM
00:08:59 <Axman6> it's just map
00:09:05 <Solonarv> yup
00:09:06 <Axman6> or, fmap
00:09:08 <jusss> map for list?
00:09:12 <Axman6> implemented using Monad
00:09:25 <Axman6> it's map for all monads
00:09:35 <jusss> ...
00:09:41 <Axman6> :t let map f ma = ma >>= (return . f) in map
00:09:43 <lambdabot> Monad m => (a -> b) -> m a -> m b
00:09:55 <ski> `MonadFail',`Alternative',`MonadPlus' are classes of which `Maybe',`[]' are instances, sure. but they don't correspond as directly to those data types (which happen to be monads), as in the case of `Reader',`Writer',`State',`Either',`Cont' corresponding (respectively) to `MonadReader',`MonadWriter',`MonadState',`MonadError',`MonadCont'
00:10:04 <Axman6> if I can turn a's into b's, I can turn m a's into m b's
00:10:15 <iqubic> @src mapM
00:10:15 <lambdabot> mapM f as = sequence (map f as)
00:10:27 <iqubic> @src sequence
00:10:27 <lambdabot> sequence []     = return []
00:10:27 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
00:10:27 <lambdabot> --OR
00:10:27 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
00:10:37 <Axman6> so, I can now map over the "result(s)" of anything which is a monad
00:11:15 <jusss> what is mcompose? map(ma)(f) = flatMap(ma)(unit compose f)
00:12:08 <Solonarv> @src liftM
00:12:08 <lambdabot> liftM f m1 = do
00:12:08 <lambdabot>     x1 <- m1
00:12:09 <lambdabot>     return (f x1)
00:12:20 <dminuoso> jusss: I stand by my point that you should slow down and absorb the topics ski has put into a good order. Leave Monad for another day. :)
00:12:34 <jusss> dminuoso: ok
00:12:38 <Solonarv> ^ this is the same as your 'map f ma = ma >>= (return . f)'
00:12:53 <Solonarv> but yes, seconding what dminuoso said
00:13:23 <ski> iqubic : `forever f x = f x >>= forever f x' actually defines not `forever', something which perhaps might be called `fullLookup', having type `Monad m => (a -> m a) -> a -> m b'
00:14:10 <dminuoso> % :t mfix -- obligatory!
00:14:12 <yahb> dminuoso: forall {m :: * -> *} {a}. MonadFix m => (a -> m a) -> m a
00:15:06 <ski> iqubic : related would be `fullSubst :: Monad m => (a -> m a) -> m a -> m b; fullSubst env expr = do var <- expr; fullSubst env (env var)', which can be used to replace all variables in an expression with corresponding expressions, and then replace the variables in those expressions, until there's no variables left (perhaps we'll get an infinite "expression" tree, though)
00:16:00 <ski> iqubic : "expression trees" (at least without bound variables) can be made into monads, by parameterizing on the type of variable identifiers. `(>>=)' becomes "single substitution"
00:17:06 <ski> <ski> jusss : anyway, i second dminuoso on that it's best to first understand all of (a) data types; (b) polymorphism; (c) type classes (including instances, and constrained types); (d) parameterized types, before tackling monads
00:17:11 <ski> jusss ^
00:17:51 <ski> oh, and together with (a) also comes understanding pattern-matching
00:17:56 <dminuoso> And even then I would follow the progression: Monoid > Functor > Applicative > Monad
00:18:03 <ski> and it probably helps to understand recursion along the qay
00:18:08 <ski> s/qay/way/
00:18:10 <dminuoso> So once you have developed good intuition for those topics, aim for Monad as the last. :)
00:18:33 <ski> yea, i think you should at least understand `Functor' before `Monad'
00:18:44 <ski> the other two are perhaps debatable (?)
00:19:11 <dminuoso> ski: Applicative perhaps, but I like Monoid for being a simpler version of an abstract typeclass. Writing Monoid polymorphic code can help distance yourself from trying to find a purpose.
00:19:12 <maerwald> I find Applicative is much harder to gain intuition about than Monad
00:19:27 <maerwald> Most people are very comfortable with Monad
00:20:09 <jle`> i usually just introduce applicative as a way to squish 'f a' and 'f b' into 'f (a, b)'
00:20:16 <dminuoso> jle`: ^- that! 
00:20:16 <ski> dminuoso : yes. i'm not saying `Monoid' will make things harder. and i agree about understanding abstract type classes
00:20:24 <jle`> and all squishy functors are applicative
00:20:32 <dminuoso> squishy :)
00:20:46 <ski> i don't know about "Applicative is much harder to gain intuition about than Monad"
00:20:48 <dminuoso> And I guess Monoid is a good stepping stone for that.
00:21:01 <jle`> i remember when taking a Haskell course at uni, Applicative seemed like a natural generalization of Functor
00:21:01 <ski> to some extent (from an initial perspective), i think they just appear different
00:21:07 <dminuoso> jle`: So Applicative is a sort of Monoid1? :-)
00:21:19 <jle`> "functor lets you lift an (a -> b), but what if you want to lift an (a -> b -> c)?"
00:21:36 <Ariakenom> I tried to find the versions of massiv availible in stack lts-8.5 but you can't search for snapshots? I think this massiv version and lts version doesn't work https://github.com/haskell-perf/sequences/blob/master/stack.yaml
00:21:39 <Axman6> Is there a canonical example of a functor which isn't applicative?
00:21:43 <jle`> it's actually rather unfortunate that Monad somehow subsumes Applicative
00:21:59 <dminuoso> jle`: Indeed. I find Applicative somewhat orthogonal to Monad.
00:22:02 <jle`> since i see Applicative and Monad now as two "forks" from Functor, and by sheer luck one subsumes the other
00:22:07 <jle`> math is weird
00:22:21 <Solonarv> Axman6: Const b when b isn't a monoid
00:22:40 <jle`> `Const X` where `X` doesn't have any monoid
00:22:44 <Solonarv> or, similarly, (w,) when w isn't a monoid
00:22:52 <dminuoso> jle`: Especially once you think of `f a -> f b -> f (a, b)` and `(f :.: f) a -> f a` they kind of have a similar shape, but they seem very unrelated at first glance.
00:23:01 <dminuoso> jle`: In fact, I dont even understand how they are related at all.
00:23:09 <jle`> Monad1 is probably more related to Alternative-without-Applicative
00:23:13 <jle`> *Monoid1
00:23:22 <jle`> or Data.Functor.Plus
00:23:50 <jle`> but that's just a different monoid, they're all monoids in the cata blah blahs
00:23:51 <dminuoso> What's the connection that makes Monad also Applicative?
00:23:55 <Solonarv> dminuoso: practically, the relation is that you can derive applicative operations using only monad operations
00:24:05 <dminuoso> Solonarv: Well yeah..
00:24:06 <jle`> dminuoso: i think it's just "luck", mathematical coincidence
00:24:31 <Axman6> mf <*> ma = mf >>= \f -> fmap f ma
00:24:43 <Solonarv> more abstractly, *something something furious handwaving mumble mumble exponential categories*
00:26:37 <maerwald> Monoid is so general there is no intuition about it lol
00:26:54 <maerwald> just don't use it :P
00:27:15 <jle`> monoid isn't that general i think
00:27:18 <jle`> that's why we have semigroup
00:27:30 <jle`> and also there's a whole host of non-associative operations people use all the time in programming
00:27:36 <maerwald> Monoid implies semigroup
00:27:42 <dminuoso> Semigroup is easy to build intuition for, and almost every Semigroup can trivially be made into Monoid..
00:27:49 <jle`> or at least, they could be made associative if people knew that associativity was important
00:27:56 <jle`> maerwald: semigroup is more general than monoid
00:27:57 <dminuoso> The thing that Semigroup captures is so deep in our way of thinking. 
00:28:13 <dminuoso> That we dont think about what we think about.
00:28:44 <jle`> oh wait did i mix up the order again
00:29:00 <maerwald> it creates more confusion than it helps. I prefer "foo" ++ "bar" instead of reading stray <> then trying to figure out what it does
00:29:01 <jle`> darn i always mix up the generality direction
00:29:08 <maerwald> not that useful
00:29:14 <jle`> right, i'd never write Sum 1 <> Sum 2 instead of 1 + 2
00:29:31 <ski> hm, i think there was a "applicative functors are just monoids in the category of ..." statement, as well, but i can't find it atm :/
00:29:50 <jle`> but Monoid is a nice position where we have a lot of possible monoid-polymorphic functions
00:29:51 <maerwald> sometimes more specific operators is helpful, sometimes not
00:30:02 <jle`> the whole Foldable typeclass is basically built around monoid-polymorphism
00:30:02 <dminuoso> ski: applicative functors are just monoids in the category of endofunctors equipped with the day convolution as its tensor.
00:30:05 <ski> jle` : "semigroup is more general than monoid" sounds right to me
00:30:26 <ski> dminuoso : can we add that as a quote ?
00:30:36 <jle`> Monoid is a good starting point for an abstraction where it is useful to build functions polymorphic on that abstraction
00:30:49 <jle`> every haskeller runs into mconcat at some point
00:30:54 <jle`> and foldMap
00:30:58 <dminuoso> ski: Sure, but I just quote jle` every time. :)
00:31:35 <ski> dminuoso : i don't find any such quote in lambdabot
00:31:40 <ski> here goes ..
00:31:40 <ski> @remember dminuoso applicative functors are just monoids in the category of endofunctors equipped with the day convolution as its tensor.
00:31:41 <lambdabot> Done.
00:31:48 <jle`> and Monoid-as-an-abstraction also drives the utility of the Const w Applicative, and the Writer w Monad
00:32:03 <dminuoso> ski: Oh then you should remember it grammatically correctly at least, the `monoids` should be in singular.
00:33:45 <dminuoso> % data Day f g a where Day :: f x -> g y -> (x -> y -> a) -> Day f g a
00:33:47 <yahb> dminuoso: 
00:34:14 <ski> dminuoso : "applicative functors are just monoid in the category of ..." sounds off
00:34:21 <ski> @quote delighted.to.learn
00:34:21 <lambdabot> PhilipWadler says: I'm delighted to learn that "a monad is a monoid in the category of endofunctors"---anyone know where I can find a good tutorial?
00:34:35 <ski> @quote just.a.comonoid
00:34:35 <lambdabot> ciaranm says: a comonad is just a comonoid in the category of endofunctors. what's the coproblem?
00:34:40 <ski> @quote analogies.are.endofunctors
00:34:41 <lambdabot> dmwit says: analogies are endofunctors in the category of bad explanations
00:34:48 <ski> @quote morphisms.in.the.category
00:34:48 <lambdabot> merijn says: If you have a problem and you think "I know, I'll use lenses!", you now have morphisms in the category of problems :P
00:34:52 <dminuoso> ski: An applicative functor is a monoid in the monoidal category of endofunctors, equipped with Day convolution as its tensor.
00:34:52 <ski> @quote small.detour
00:34:53 <lambdabot> flebron says: <flebron> Monoidal objects in the monoidal category of endofunctors on a category. I took a small detour through tensor products to understand monoidal categories better, with one
00:34:53 <lambdabot> example of such a product. <mauke> I have no idea what you just said
00:35:10 <ski> @forget dminuoso applicative functors are just monoids in the category of endofunctors equipped with the day convolution as its tensor.
00:35:11 <lambdabot> Done.
00:35:19 <ski> @remember dminuoso An applicative functor is a monoid in the monoidal category of endofunctors, equipped with Day convolution as its tensor.
00:35:20 <lambdabot> Nice!
00:35:25 <ski> better ?
00:35:28 <dminuoso> Yeah I think so.
00:35:41 <MarcelineVQ> you jelly beans
00:35:50 <jle`> why stop at Day and Compose as tensors
00:35:58 <jle`> why not Product, Sum as well
00:36:13 <ski> (if you think it becomes too annoying to have this quote highlight/alert you, i suppose we could always change the `dminuoso' in it to `someone' or something ..)
00:36:21 <dminuoso> jle`: What kind of monoids do we obtain when we equip it with Product or Sum?
00:36:39 <jle`> why would i answer that, and rob you of the fun exercise ;)
00:36:45 <dminuoso> jle`: Oh goodie!
00:36:51 <Solonarv> Product gives us Applicative again (exercise: prove it!)
00:36:59 <Solonarv> I'm not sure what Sum gives us
00:37:04 <jle`> http://oleg.fi/gists/posts/2018-02-21-single-free.html
00:37:09 <jle`> Product doesn't give us Applicative
00:37:16 <ski> MarcelineVQ : hm, ever played Pyjamarama or Herbert's Dummy Run ?
00:37:18 <jle`> it gives us Alternative-without-Applicative, or Data.Functor.Plus
00:37:28 <Solonarv> oh, right
00:37:37 <Solonarv> actually it gives us Alternative
00:37:47 <Solonarv> (all of it, including empty)
00:37:59 <jle`> it doesn't give us <*>/pure i believe
00:38:06 <jle`> just <|> and empty
00:38:07 <Solonarv> oh I misread
00:38:07 <Solonarv> yes.
00:38:23 <Solonarv> I thought you said Alternative-without-empty for some reason
00:38:31 <MarcelineVQ> ski: Absolutely not.
00:38:36 <jle`> easy enough to mix up :)
00:38:43 <Solonarv> but what does Sum give us?
00:38:44 <ski> oh .. the other Oleg
00:39:10 <jle`> it's either an Oleg or a Simon
00:39:45 <MarcelineVQ> often it's a eric or edward
00:39:50 * ski . o O ( My other Oleg is a Simon. )
00:40:33 <ski> MarcelineVQ : just wondering where that phrase "jelly beans" came from
00:40:56 <jle`> dminuoso: hm, that blog post actually suggests why Monad subsumes Applicative even though they have orthongal constructions
00:41:37 <jle`> dminuoso: it talks about a typeclass FromDay h where fromDay :: Day f g a -> p f g a
00:41:57 <MarcelineVQ> well jelly beans are a candy. and I thought it sounded better than "you goobers"
00:42:05 <jle`> and any tensor that is an instance of FromDay will be a subclass of Applicative
00:42:10 <MarcelineVQ> You dang peanutes
00:42:19 <jle`> and you can write a Day f g a -> Comp f g a (which is somewhat surprising to me)
00:42:31 <jle`> i'm not sure if that's a satsfying answer though, since it just shifts the 'why' somewhere else
00:42:45 <MarcelineVQ> ski: Is that a real ctcp some clients have? :>
00:42:55 <jle`> The quote is "Because Hask has rich structure, we can convert Day into Comp."
00:43:02 <jle`> hm, is "rich structure" a technical term?
00:43:08 <jle`> ( phadej )
00:43:21 <merijn> ski: Jelly beans in what context?
00:47:33 <ski> merijn : i dunno. you should probably ask MarcelineVQ about that ?
00:47:55 <ski> MarcelineVQ : not that i know of. but you could still hope ;)
01:15:38 <merijn> I would like to take this moment how amazing Cabal is compared to the suckage that is CMake...
01:16:49 <angeleyes> Hello guys! 
01:16:54 <angeleyes> Do you see my message?
01:17:26 <Taneb> angeleyes: only your hello and "Do you see my message"
01:17:37 <angeleyes> thank you:)
01:17:38 <ski> angeleyes : we can't hear you. speak loader ?
01:17:38 <shachaf> I also saw a "guys".
01:18:02 * ski fetches a hearing aid
01:18:05 <shachaf> But between us we probably have it covered.
01:18:38 <angeleyes> I just started another client and the freenode not ask me for a password and login.
01:18:52 <angeleyes> another irc-client
01:19:29 <Solonarv> yes, you don't need a password to connect to freenode
01:19:57 <angeleyes> ok, than you Solonarv
01:20:04 <angeleyes> thank*
01:20:38 <ski> if you want to register your nickname, you can do that with `/msg NickServ register <password> <email-address>'
01:20:40 <Solonarv> but you might want to register your nickname: https://freenode.net/kb/answer/registration
01:24:30 <asheshambasta> How does one go about defining a 'catchError' for this kind of a stack? https://gist.github.com/asheshambasta/9611c2c3186f4b09334ecf353deb595f
01:25:31 <asheshambasta> Initially, I was thinking of 'unwrapping' OpaleyeT and operating at the ReaderT level, but the handler needs to be within OpaleyeT 
01:25:38 <merijn> asheshambasta: tbh, I would generally advocate for not using ErrorT or MonadError
01:25:42 <Cale> asheshambasta: The secret is never think of your monad as a stack. :)
01:26:03 <asheshambasta> merijn: why? 
01:26:21 <Cale> asheshambasta: You're implementing an instance of MonadError for OpaleyeT, which is defined in terms of ReaderT
01:26:35 <phadej> jle`: yes it is, not well defined
01:26:35 <asheshambasta> Cale: correct 
01:26:43 <Cale> Perhaps it would be okay to implement the instance in terms of the underlying ReaderT instance for MonadError
01:26:44 <phadej> though
01:27:01 <merijn> asheshambasta: Because they're basically lies. Most monad stacks end up with *actual* exceptions (from underlying IO layers) and ErrorT will do nothing to handle those
01:27:09 <Cale> We should think carefully about what it means though
01:27:14 <asheshambasta> Cale: how does the handler translate to the ReaderT level. 
01:27:59 <asheshambasta> merijn: what if I explicitly wanted to handle a type of errors? Isn't that what MonadError is about? The error type is part of the instance 
01:28:18 <merijn> asheshambasta: MonadError pretend only a single specific error can be thrown which prevents you from throwing multiple different errors
01:28:20 <Cale> Well, you've already kind of done it -- by either pattern matching on the OpaleyeT data constructor or using unOpaleyeT, and then you can build an OpaleyeT action from a ReaderT action by applying the OpaleyeT constructor
01:28:40 <merijn> asheshambasta: tbh, I just return Either and deal with it as needed
01:29:02 <merijn> asheshambasta: Where deal can just be "rethrow it as an actual exception" or not
01:29:17 <phadej> jle`: "Hask is richer (categorical) structure than (e.g.) bare monoidal category: there are products and exponentials and ..."
01:30:14 <merijn> asheshambasta: I mean, if you want to handle a type of error, then try/catch would work just as well, no?
01:30:48 <Cale> asheshambasta: In our case here, it looks as if runOpaleyeT does nothing special with regard to cleaning up connections and whatnot, so it should be okay to use it in the context of catchError, I think
01:31:49 <asheshambasta> Cale: the problem is that its hard to get this handler to work at the readerT level
01:32:37 <Cale> asheshambasta: Well, let's see...
01:33:03 <asheshambasta> merijn: correct. So to give you the full context: we have a type of error at the top level, called CoreErr; then we have a typeclass that has instances which are error types. These can be thrown with `throwError'` (wraps inside CoreErr and throws it); that provides with some functionality at the error leve. 
01:33:07 <Cale> We know that we want the result to be an OpaleyeT action, so let's start by applying the constructor:
01:33:34 <Cale> catchError (OpaleyeT rOp) h = OpaleyeT $ do -- and might as well start a do-block because whatevs
01:33:43 <ski> merijn : certainly not using `ErrorT' (as opposed to `ExceptT'). but what about `MonadError' ?
01:34:17 <ski> (`ErrorT' is basically deprecated in favor of `ExceptT')
01:34:23 <Cale> Now, we probably want to use catchError for ReaderT
01:34:35 <Cale> But if we write something like:
01:34:44 <Cale>   catchError rOp h
01:35:03 <Cale> that's not going to typecheck, because our handler is producing an OpaleyeT action
01:35:15 <asheshambasta> Cale: correct 
01:35:16 <Cale> and we need it to produce a ReaderT action
01:35:16 <ski> merijn : "Most monad stacks end up with *actual* exceptions (from underlying IO layers)" -- yes, `ExceptT' and `MonadError' is about something different that those, i agree
01:35:45 <Cale> But that's easy, we can unOpaleyeT
01:36:01 <asheshambasta> Cale: this, to me, sounds a lot like we need to look into the handler :-) 
01:36:06 <merijn> ski: I dunno, I've never really had a problem that MonadError seems to solve
01:36:24 <ski> "MonadError pretend only a single specific error can be thrown which prevents you from throwing multiple different errors" is a general problem with `mtl'. the FDs on the type classes are really limiting
01:36:30 <Cale>   catchError rOp (unOpaleyeT . h)
01:36:46 <merijn> asheshambasta: What you describe can also be done with regular exceptions, though :)
01:36:59 <ski> (but it's not that obvious how to solve it)
01:37:11 <merijn> Everyone seems to always ignore that you can have dynamic hierarchies with regular exceptions too
01:37:35 <ski> oh, `SomeException' is another pet peeve of mine :)
01:38:04 <asheshambasta> `catchError (OT.OpaleyeT rOp) h = OT.OpaleyeT $ rOp `catchError` (OT.unOpaleyeT . h)`
01:38:06 <merijn> ski: So which problem does MonadError improve over just using, say, regular exceptions + MonadThrow/Catch/Mask from exceptions?
01:38:27 <merijn> ski: I think SomeException is fine, we should just have more aggressive subcategories inside base
01:39:23 <Cale> merijn: As an example, I once produced a bunch of refinements of IOException for all its different exception types
01:39:35 <Cale> merijn: Perhaps I should have tried to get that into the actual library :)
01:39:54 <merijn> Cale: Never too late!
01:40:08 <Cale> But I have so many yaks to shave already :)
01:40:09 <Cale> lol
01:40:34 <merijn> Cale: In fact, I think this should be backwards compatible to add, since anything catching either SomeException or the actual type will still work, regardless of anything intermediate
01:40:51 <Cale> It is entirely backwards compatible and can be done in a separate library even.
01:41:54 <Cale> Another cute thing which I'm not sure is even good is an exception instance for Either (perhaps it should be a specially-defined Either-like type) which catches either of two exceptions
01:42:02 <ski> merijn : its `Show' instance is bunk
01:42:19 <ski> > fromException (SomeException DivideByZero) :: Maybe ArithException
01:42:21 <lambdabot>  Just divide by zero
01:42:30 <Cale> ^^ that is annoying, yes
01:42:43 <merijn> ski: Just use displayException? :p
01:43:03 <Cale> We ought to have had a separate concept for pretty printing exceptions
01:43:17 <merijn> But yeah, the fact that for hysterical raisins show instance for exceptions are dumb is annoying
01:43:24 <ski> merijn : harder to do if you have `Map String (Integer,SomeException)' or something
01:43:25 <merijn> Cale: We do now, though :p
01:43:30 <ski> however, it seems the `fromException' implementation on `SomeException' is fixed ?
01:43:39 <merijn> :t fromException
01:43:40 <lambdabot> Exception e => SomeException -> Maybe e
01:43:53 <ski> istr it would automatically unwrap all `SomeException' data constructors ?
01:44:43 <Cale> It's sort of unfortunate that we have this lovely system of exceptions that practically never gets fully used because Haskell programmers are usually more picky about making exceptions explicit in general. Of course, that tendency is almost certainly a good thing.
01:45:21 <ski> hrm, actually
01:45:23 <ski> > fromException (SomeException (SomeException DivideByZero)) :: Maybe SomeException
01:45:27 <lambdabot>  Just divide by zero
01:45:28 <Cale> So you're just way more likely to see IO (Either ...) than you are to see much fancy use of exceptions, because then the types document the exceptions which need to be handled.
01:45:44 <Cale> (because they're not really exceptions then)
01:45:47 <ski> > fromException =<< fromException (SomeException DivideByZero) :: Maybe ArithException
01:45:50 <lambdabot>  Just divide by zero
01:46:02 <ski> those work as expected (modulo the `Show' instances)
01:46:05 <ski> however
01:46:20 <ski> > fmap fromException (fromException (SomeException (SomeException DivideByZero))) :: Maybe (Maybe ArithException)
01:46:23 <lambdabot>  Just Nothing
01:46:28 <ski> > fromException =<< fromException (SomeException (SomeException DivideByZero)) :: Maybe ArithException
01:46:30 <lambdabot>  Nothing
01:46:33 <ski> why doesn't those work ?
01:46:56 <Cale> ummmmmmmm
01:47:40 <merijn> Because SomeException is not an ArithException
01:47:45 <Cale> ski: So the inner fromException, what's its type?
01:47:50 <merijn> ski: Why would you ever expect that to work?
01:48:11 <ski> Cale : should have `Maybe SomeException' as result type
01:48:29 <ski> each `fromException' ought to unwrap a single `SomeException' layer
01:49:24 <Cale> uh, but that's not quite what fromException means
01:49:28 <ski> > fromException (SomeException DivideByZero) :: Maybe SomeException
01:49:30 <lambdabot>  Just divide by zero
01:49:35 <ski> this one is fine
01:49:44 <ski> er, sorry
01:49:46 <Cale> Yeah, the Exception instance for SomeException is trivial
01:49:49 <ski> it's *not* fine !
01:49:58 <ski> > fromException (SomeException DivideByZero) :: Maybe ArithException
01:50:00 <lambdabot>  Just divide by zero
01:50:02 <ski> is fine
01:50:16 <ski> the former of those two ought to give `Nothing'
01:50:27 <phadej> instance Exception SomeException where toException se = se; fromException = Just
01:50:33 <merijn> ski: Why?
01:50:42 <Cale> There's no special handling of SomeExceptions that contain other SomeExceptions
01:50:44 <ski> phadej : yes, i think that's wrong
01:51:04 <phadej> > fromException (SomeException DivideByZero) :: Maybe SomeException
01:51:05 <Cale> When you fromException something that happens to be a SomeException on the inside, it doesn't notice that and unpack it
01:51:07 <lambdabot>  Just divide by zero
01:51:28 <Cale> The instance *could* do that, but... why?
01:53:20 <merijn> ski: tbh, your problem just seems to be "I wish this was defined to do something other than what it's defined to do"
01:54:21 <int-e> also how else would you rethrow arbitrary exceptions?
01:54:32 <Ariakenom> " Just divide by zero" wise words from lambdabot
01:54:45 <Cale> int-e:  throwIO e ?
01:54:47 <int-e> (it'd be really inconvenient if every re-throw would add another SomeException layer)
01:54:54 <ski>   instance Exception SomeException where toException = SomeException; fromException (SomeException exn) = cast exn
01:54:59 <ski> i think that's what i would expect
01:55:03 <ski> > let fromException (SomeException exn) = cast exn in fromException (SomeException DivideByZero) :: Maybe ArithException
01:55:05 <lambdabot>  Just divide by zero
01:55:13 <ski> > let fromException (SomeException exn) = cast exn in fromException (SomeException (SomeException DivideByZero)) :: Maybe ArithException
01:55:15 <lambdabot>  Nothing
01:55:21 <ski> > let fromException (SomeException exn) = cast exn in fromException (SomeException DivideByZero) :: Maybe SomeException
01:55:23 <lambdabot>  Nothing
01:55:31 <Cale> ski: Arbitrary exceptions get re-thrown all the time without running into this nested SomeException case
01:55:51 <ski> merijn : yes
01:55:53 <Cale> If you already *have* a SomeException, you don't tend to wrap it :)
01:56:05 <ski> if you *know* you have a `SomeException'
01:56:09 <int-e> Cale: I'm trying to say that the Exception SomeException instance works the way it does for a reason
01:56:31 <ski> if you only have an `e', where you know `Exception e', then `e' might sometimes be `SomeException'
01:56:45 <Cale> ski: If you have a value of type e where you know there's an instance of Exception e, then you could use toException e
01:56:56 <Cale> :t toException
01:56:57 <lambdabot> Exception e => e -> SomeException
01:57:08 <ski> yes, which should be the same as the data constructor `SomeException'
01:57:12 <Cale> In the case that e ~ SomeException
01:57:13 <merijn> ski: No
01:57:15 <Cale> it won't be
01:57:19 <merijn> ski: That'd break the dynamic hierarchy
01:57:32 <ski> why ?
01:57:32 <Cale> (and in many other cases)
01:57:41 <merijn> ski: The entire point of toException is that it can insert intermediate wrapping
01:58:00 <int-e> nobody's ever supposed to wrap a SomeException inside another SomeException.
01:58:32 <ski> you're never to call use `SomeException' on an abstract `e' where you only know a few constraints like `Exception e' ?
01:58:42 <ski> s/call use/use/
01:58:52 <int-e> ski: no, you're supposed to use toException then
01:59:17 <ski> merijn : then i suppose i don't understand how the dynamic hierarchy is intended to work
01:59:21 <merijn> ski: Have you read the Dynamically Typed Hierarchy of Exceptions paper?
01:59:24 <merijn> ski: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/src/Exceptions.hs#L51-L82
01:59:44 <Cale> I'll rewrite my example, since I'm having trouble digging it up...
01:59:46 <ski> i can't recall the title, anyway, so i suppose not
02:00:21 <merijn> ski: toException on ViolatedInvariant will end up wrapping in a BenchmarkException, which will wrap in SomeException, which means you can now catch classes of exceptions, instead of just single specific ones
02:00:36 <Cale> oh, actually, lol, I didn't even realise that someone *did* put all this stuff into base
02:01:05 <merijn> ski: If you'd directly wrap "ViolatedInvariant" via SomeException then suddenly anyone catching "BenchmarkException" wouldn't catch ViolatedInvariant as intended
02:01:25 <merijn> ski: So explicitly using SomeException of toException breaks that entire usecase
02:01:59 <merijn> Speaking of which, the correct way would probably be to not export the SomeException constructor and only allow a read-only pattern
02:02:03 <Cale> er, no
02:02:17 <Cale> Yeah, I was confused, let's do this again :)
02:06:19 <ski> merijn : hmm. i guess i'd better go read that paper, then. "An Extensible Dynamically-Typed Hierarchy of Exceptions" by Simon Marlow in 2006-09-17 at <https://simonmar.github.io/bib/papers/ext-exceptions.pdf> ?
02:06:20 * hackage multibase 0.1.0.0 - Self-identifying base encodings, implementation of <https://github.com/multiformats/multihash>  https://hackage.haskell.org/package/multibase-0.1.0.0 (jkarni)
02:06:33 <merijn> ski: Yeah, that one
02:07:21 * hackage multihash-cryptonite 0.1.0.0, multihash-serialise 0.1.0.0 (jkarni)
02:08:21 * hackage ipfs-api 0.1.0.0, ipld-cid 0.1.0.0 (jkarni)
02:09:04 <Cale> merijn, ski, int-e: https://gist.github.com/cgibbard/c0eda4da4f6118aa58fee923010fee17
02:09:47 <Cale> (lol, SublimeText's multiple cursors each of which have their own clipboard made that a bit less tedious to write)
02:12:18 <Solonarv> Cale: if you change the extension to .hs then there will be syntax highlighting :>
02:13:00 <Cale> edited
02:13:24 <Solonarv> \o/
02:13:44 <Cale> I've gotten so used to syntax highlighting being terrible that I don't even mind when it's not there anymore
02:16:34 <merijn> The latest vim one I got is pretty decent, except it insist on highlighting obscure shit like ArrowNotation so when using System.Process I get proc highlighted >.>
02:22:17 <Cale> okay, time to use glguy's th-abstraction library to try and make all this template haskell much nicer :D
02:23:10 <Cale> glguy: Somehow when you told me this the other day, it didn't fully sink in, but the fact that you're pre-applying all that variable unification sounds like it's going to make things very nice. I'll have to see how it all shakes out :)
02:23:39 <bollu> Why does base use two spaces to describe instances? ie, "instance<space><space>Show Float<space><space>where"  https://github.com/ghc/ghc/blob/dc8a5868b0be03854927a5efab83a6e9a15e21d1/libraries/base/GHC/Float.hs
02:23:41 <Cale> I think it won't solve my immediate annoyance with this GShow nonsense, but it might make dealing with it more pleasant
02:25:35 <merijn> bollu: Historical reasons, probably
02:25:54 <Cale> Yeah, it might be that someone at some point was lining up a bunch of things
02:26:00 <bollu> merijn right, but I was hoping for a history lesson
02:26:05 <bollu> hmm, but it's throughout the file
02:26:06 <merijn> bollu: If you look at blame the "instance  Show Float  where" line is 18 years old'
02:26:14 <bollu> xD
02:26:36 <merijn> bollu: The newer ones "instance Num Float" (11 months old) is just a single space
02:26:36 <bollu> oh jesus, it's inconsistent. The spacing.
02:26:38 <bollu> yeah
02:26:38 <Cale> Yeah, and in very early Haskell, the spacing was even crazier than it is today
02:26:41 <bollu> I just noticed.
02:26:46 <bollu> Cale do tell?
02:26:50 <merijn> So I suspect Cale is right and someone was lining up in the past
02:26:57 <merijn> bollu: You never seen SPJ style do notation?
02:27:06 <Cale> Well, it's just that there wasn't much culture about how to space things
02:27:08 <bollu> merijn oh the `;` style? I'm ... oddly fond.
02:27:20 <merijn> bollu: I suspect no one wants to redo the spacing now to avoid spurious diffs
02:27:23 <Cale> so people had all sorts of different styles
02:27:58 <Cale> Who's going to spoil an 18 year old blame? :D
02:28:00 <Solonarv> do { foo
02:28:00 <Solonarv>    ; bar
02:28:00 <Solonarv>    ; baz
02:28:00 <Solonarv>    }
02:28:14 <Solonarv> ^ spj-style do notation (just in case anyone wasn't familiar)
02:29:07 <Cale> We should try writing C like that. If only it didn't involve writing C...
02:29:18 <bollu> hmm
02:29:37 <Cale> I guess in C, semicolon isn't a separator, so it doesn't work
02:29:44 <bollu> I find refactoring harder with layout based languages.
02:29:49 <bollu> because you can't just copy paste
02:29:55 <bollu> you need to rein-layout sometimes
02:30:08 <Cale> and no editor knows how to help you with that because they're all uniformly bad
02:30:19 <Solonarv> IME that's not been an enormous problem
02:30:22 <Rembane> I use my autoformatter, and then it fixes all layout. 
02:30:25 <Rembane> Brittany <3
02:30:34 <Solonarv> but I almost always start layout on a new line, so that probably helps
02:30:56 <Solonarv> the only time I have a block start on the same line as its herald is when it's a one-liner
02:31:05 <[exa]> re brittany, I wasn't able to get any useful output from it, it just outputs the perfectly same code no matter what options I use. any idea what I could have done wrong?
02:31:47 <[exa]> 'perfectly same' as in 'not formatted at all, /bin/cat way'
02:31:59 <int-e> bollu: those spaces may actually come straight from the Haskell 98 report.
02:32:18 <bollu> int-e in what section?
02:32:46 <Ariakenom> I read this and wanted to compare to haskell, anyone know of any benchmarks? https://blog.discordapp.com/using-rust-to-scale-elixir-for-11-million-concurrent-users-c6f19fc029d3
02:32:59 <asheshambasta> Cale: thanks a lot btw. 
02:33:19 <int-e> bollu: though hmm I don't see any instances for Num. But look at  https://www.haskell.org/onlinereport/basic.html#sect6.4  for example; the double space is certainly a theme.
02:33:27 <Ariakenom> I did look at haskell-perf/sequences but that did unordered and not random insert & delete
02:33:33 <Cale> asheshambasta: No problem!
02:34:13 <Solonarv> Ariakenom: unlike (apparently) in Elixir we can perfectly well write mutable data structures in Haskell
02:34:31 <Solonarv> hmm, will read later
02:35:36 <ski> Solonarv : i sortof like that formatting style
02:36:22 <[exa]> Ariakenom: kindof seems like they discovered basic datastructure implementation course :]
02:36:42 <ski> hm, i recall seeing people line up `::'s in signatures with `='s in equations
02:36:50 <ski> never made much sense to me
02:37:59 <Ariakenom> [exa]: yeah some of the approaches there are a bit strange
02:38:22 <dminuoso> Solonarv: Oh yes, its incredibly frustrating to not be able to specify mutation *at all*
02:38:27 <dminuoso> Like, not even with dirty primitives.
02:38:42 <Ariakenom> Solonarv: yeah something STM based sounds perfect for this
02:38:57 <dminuoso> Even something mundane as reading configuration on startup and presenting it as an immutable store requires you to express this as stateful processes.
02:39:44 <[exa]> Ariakenom: btw it would probably be >10 times faster if they went for simple B*-trees
02:40:27 * [exa] wonders whether c++ guys finally have a decent btree implementation
02:42:08 <Ariakenom> [exa]: you have any haskell structures to suggest? I may write up some criterion later today.
02:42:41 <[exa]> Ariakenom: Map/Set is 2-3 tree I guess, it would be interesting to see how that compares
02:42:53 <Ariakenom> for sure
02:43:13 <Ariakenom> I did find bytestring-trie on hackage. seems like a candidate
02:43:57 <[exa]> a friend was actually doing a benchmark of zipper-vs-normal trees in c++ and haskell (trivial implementations) and had pretty hard time of getting a c++ implementation that is faster than Hs zipper and still looks trivial
02:44:55 <Ariakenom> im guessing the ordered arbitrary length string thing makes it a bit interesting
03:14:05 <Sylwia_> Hi, we are a data-science paltform and a general-purpose functional programming language based on Haskell and we are looking for Senior Haskell developers. Job sdescription available here: https://stackoverflow.com/jobs/264670/senior-haskell-developer-luna. PM for details.
03:16:50 * hackage transformers-lift 0.2.0.2 - Ad-hoc type classes for lifting  https://hackage.haskell.org/package/transformers-lift-0.2.0.2 (int_index)
03:27:03 <int-e> hmm palts.
03:32:56 <Mo0O> Hi there
03:33:22 <Mo0O> do you know how to pass `-o` flag to `cabla v2-install`?
03:35:10 <Blar> How can I split a ByteString into lines, independent of the concrete EOL (\n or \r or \r\n)?
03:39:05 <int-e> :t Data.Text.lines
03:39:07 <lambdabot> Data.Text.Internal.Text -> [Data.Text.Internal.Text]
03:39:20 * hackage quickcheck-transformer 0.3.1 - A GenT monad transformer for QuickCheck library.  https://hackage.haskell.org/package/quickcheck-transformer-0.3.1 (HenningThielemann)
03:39:33 <int-e> :t Data.ByteString.Char8.lines -- usually you should use Text for text though.
03:39:34 <lambdabot> BSC.ByteString -> [BSC.ByteString]
03:39:43 <Ariakenom> [exa]: How do B*-trees work with strings. And is there any hs implementatio?
03:40:03 <Cale> Blar: That problem is text encoding dependent. ByteString doesn't specify which text encoding you're using, it's just a pile of bytes. As int-e is suggesting, the best way is to first convert to Text somehow.
03:40:23 <Cale> (or use Text from the outset, if possible)
03:41:00 <int-e> oh the BSC one doesn't like \r, let's check Text...
03:41:31 <int-e> same there, hmm.
03:41:42 <Cale> ah, yeah
03:42:32 <int-e> well, that's a bit disappointing.
03:43:17 <Cale> One thing which usually handles this is the NewlineMode stuff at the IO layer
03:43:26 <Cale> see System.IO.hSetNewlineMode
03:44:18 <Cale> http://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#v:hSetNewlineMode
03:45:10 <Maxdamantus> > Text.pack "foo\r\nbar"
03:45:12 <lambdabot>  error:
03:45:12 <lambdabot>      Not in scope: ‘Text.pack’
03:45:12 <lambdabot>      No module named ‘Text’ is imported.
03:45:54 <int-e> > "abc" :: Text -- checking
03:45:56 <lambdabot>  error:
03:45:56 <lambdabot>      • Expecting one more argument to ‘'Text’
03:45:56 <lambdabot>        Expected a type, but ‘'Text’ has kind ‘Symbol -> ErrorMessage’
03:46:57 <Maxdamantus> anyway, Text doesn't do anything special for line endings.
03:47:02 <Maxdamantus> afaik
03:47:26 * Maxdamantus wishes `String` were just a sequence of bytes.
03:47:41 <Cale> nah, that'd be terrible
03:47:55 <Cale> String should probably be Text
03:48:18 <Maxdamantus> Funny how the language developed 20 years later by the people who invented UTF-8 just did it that way, and noone seems to have any serious issues with coding issues there.
03:48:19 <Cale> (except that's probably not going to happen any time soon, because it would break everything everywhere)
03:48:52 <Maxdamantus> meanwhile in Python land
03:48:58 <Cale> You definitely want a type which abstracts over text encodings
03:49:16 <Maxdamantus> How does Text abstract over encodings?
03:49:20 * hackage data-accessor 0.2.3 - Utilities for accessing and manipulating fields of records  https://hackage.haskell.org/package/data-accessor-0.2.3 (HenningThielemann)
03:49:28 <Maxdamantus> It just forces an encoding. There's no particular abstraction.
03:49:30 <Cale> Text is abstractly a sequence of unicode code points
03:49:43 <Cale> It doesn't force an encoding, you get to pick how to convert Text -> ByteString
03:50:00 <Maxdamantus> That doesn't seem very abstract.
03:50:08 <Cale> hm?
03:50:24 <Cale> Internally, Text uses UTF-16, but nothing about its interface suggests this
03:50:35 <Maxdamantus> You're requiring people to specify an encoding. That's basically the opposite of being abstract.
03:50:56 <Cale> Operations acting on Text don't have to care about the eventual encoding
03:51:09 <Maxdamantus> If you just take bytes, a lot of operations shouldn't need to deal with encodings.
03:51:20 <Cale> okay, how about sorting a bunch of strings
03:51:31 <Ariakenom> I want to benchmark insertions (among others) into Data.Set. Can I do a single insertion and have that be a good benchmark? It's spine strict right ... ?
03:51:32 <Maxdamantus> How do you sort a bunch of `Text`s?
03:51:37 <Cale> sort
03:52:03 <Maxdamantus> Does "i" come before or after "I"?
03:52:04 <Cale> (you might want to sortOn toCaseFold)
03:52:39 <Cale> But that kind of operation is way harder to implement on ByteString
03:52:56 <Maxdamantus> It's not really any harder to implement on ByteString than on Text.
03:53:15 <Maxdamantus> If you need to do it "correctly", you need to take into account locale, at which point there's basically no difference between ByteString and Text.
03:53:24 <Cale> Not without essentially going *via* some type like Text
03:53:50 <Cale> Like, you're going to have to work out what codepoints are present
03:53:54 <Cale> and that's encoding-dependent
03:54:04 <Cale> why deal with that at the same time as sorting?
03:54:19 <Maxdamantus> If your locale says something to do with UTF-8, your locale will handle that.
03:54:23 <Ariakenom> bytes -encoding-> unicode
03:54:33 <Maxdamantus> If your locale says something else, maybe your locale will handle it differently.
03:54:56 <Maxdamantus> I don't know exactly how this tends to be handled in a locale-specific way, but I know that something like `Text` doesn't inherently help here.
03:55:08 <Cale> I don't want to work with bytes, I want to work with codepoints (or sometimes even something higher-level still)
03:55:12 <Maxdamantus> since all you're doing is relying on one abstraction "code points" rather than another "bytes"
03:55:29 <Maxdamantus> (and "bytes" is the more abstract one here)
03:55:35 <Cale> bytes are too low-level for most of the manipulations you want to do on text
03:55:39 <Maxdamantus> What do you do with code points?
03:55:59 <Maxdamantus> Code points aren't any more useful than bytes, usually.
03:56:13 <Maxdamantus> If you're making use of code points instead of making use of bytes, you're probably doing something broken.
03:56:34 <Cale> How so?
03:56:45 <Maxdamantus> eg, why is the code point representation of "a\769" more useful than the UTF-8 bytes representation?
03:57:21 <Maxdamantus> (\769 being the combining code point U+301, as in á)
03:58:21 <Cale> Well, okay, sure, there are yet higher level things on top of codepoints you may actually be concerned with
03:59:05 <Ariakenom> you know how to print the intended text in the Text to the terminal. not the bytes
03:59:14 <Maxdamantus> Right, unless your concern is being able to translate between UTFs, you really don't get any useful guarantees from working with code points over working with bytes.
04:00:10 <Maxdamantus> Text probably doesn't know how to print the text to the terminal. It will just involve converting it to UTF-8.
04:00:33 <Cale> It converts it to whatever your environment says to convert it to
04:00:51 <Ariakenom> Text includes the encoding. so you know what you're starting with
04:00:53 <Cale> "The functions in this module obey the runtime system's locale, character set encoding, and line ending conversion settings."
04:01:01 <Maxdamantus> Text doesn't include the encoding.
04:01:12 <Maxdamantus> Sure, the conversion boundary might do something.
04:01:41 <Cale> Text doesn't specify an encoding externally, but internally uses a particular encoding that it knows how to convert
04:01:55 <Cale> (to make sense of what each of you said)
04:03:50 * hackage explicit-exception 0.1.10 - Exceptions which are explicit in the type signature.  https://hackage.haskell.org/package/explicit-exception-0.1.10 (HenningThielemann)
04:04:04 <Ariakenom> yes
04:04:28 <Maxdamantus> Even where that is useful, I would be inclined to just have `Text` be a wrapper around any `ByteString`, where any such conversion only happens if the locale does not specify UTF-8.
04:04:48 <Ariakenom> text could be (Encoding, ByteString)
04:06:18 <Maxdamantus> Since everyone should be migrating to UTF-8 anyway, and once you're on UTF-8, you should be able to just avoid any pointless internal messing up of strings.
04:07:07 <Ariakenom> well there are sequences of bytes that aren't valid utf8. so there's always a difference
04:07:21 <Ariakenom> not just conceptually
04:07:23 <Cale> Yeah, you want a type that removes all the junk
04:07:44 <Cale> and which doesn't let you represent sequences of bytes that don't correspond to sequences of codepoints
04:08:26 <Cale> Now, you might also want a type that removes even more junk, there are plenty of sequences of codepoints that don't make sense either
04:08:44 <Cale> But let's get at least to this level first :)
04:09:43 <Maxdamantus> I want those bytes to be maintained.
04:09:55 <Cale> What do you mean by "maintained"?
04:10:13 <Maxdamantus> Passed through without replacement.
04:10:27 <Cale> through what exactly?
04:11:03 <Maxdamantus> Anything that handles strings.
04:11:18 <Cale> You mean converting ByteString -> Text -> ByteString should be the identity?
04:11:40 <Cale> I think that's a little too strong
04:11:41 <Maxdamantus> Unfortunately that's probably not going to work if "handling" involves encoding in JSON or something, but in other cases it should be passed through.
04:11:44 <Maxdamantus> Yes.
04:11:48 <Maxdamantus> dd if=foo bs=10 count=1 && dd if=foo bs=10 skip=1
04:12:03 <Maxdamantus> That command should produce the contents of `foo`
04:12:04 <Cale> It should be a closure operator
04:12:18 <Cale> i.e. it might normalise some things
04:12:19 <Maxdamantus> regardless of whether it converts the file to Text or not
04:12:32 <Cale> but if applied again, it shouldn't change things further
04:12:45 <Maxdamantus> normalise as in NFC/NFD or something?
04:13:16 <Maxdamantus> so which unicode standard does it normalise according to?
04:13:30 <Maxdamantus> because unicode normalisations change between standards.
04:13:37 <Cale> as in, decode . encode . decode = encode, and encode . decode . encode = decode
04:13:41 <Cale> er, oops
04:13:43 <Cale> lol
04:13:51 <merijn> Maxdamantus: GHC release notes specify which unicode standard is used
04:13:51 <Cale> as in, decode . encode . decode = decode, and encode . decode . encode = encode
04:13:54 <Cale> there :)
04:14:15 <merijn> Maxdamantus: Or are we talking Text and co?
04:14:24 <Cale> Of course, that's still not *quite* right, because we're assuming that decoding is successful
04:15:05 <Cale> but something like that, with the proviso that anything that is produced by encode will successfully decode
04:15:08 <Maxdamantus> merijn: I'm guessing `Text` doesn't implicitly normalise. My point here is that normalisation should not be something that's implicitly applied to strings that come into the system.
04:15:48 <merijn> Maxdamantus: Text just decodes and stores as UTF-16, no other normalisation, afaik, no
04:15:56 <Maxdamantus> (imo it's potentially reasonable to argue in favour of normalisation by default in comparison operations, but even then I think it should probably be explicit)
04:16:49 <merijn> Maxdamantus: If you care about unicode at this level your probably should be using text-icu instead of just Text
04:16:52 <Maxdamantus> but anyway, back to my `dd` command .. that should not produce new replacement characters simply due to what byte the split occured on.
04:16:53 <Cale> Maxdamantus: There may be different sequences of bytes (in whatever encoding) that correspond to the same sequence of codepoints, and I have no particular interest in whether those distinctions are preserved through translation to and from the higher-level representation. The library should be mostly free to do what it wants, but if we're going to specify laws about that, I think it should be not that the bytes are preserved exactly, 
04:16:53 <Cale> but that a canonical choice is made.
04:17:25 <Maxdamantus> merijn: well, I care about other programs not doing undesirable things with bytes.
04:17:41 <Maxdamantus> merijn: eg, Python programs being able to print filenames.
04:17:41 <merijn> Maxdamantus: That sounds like "I want ByteString", then ;)
04:17:49 <Maxdamantus> merijn: indeed.
04:17:52 <Cale> Otherwise, you end up with all sorts of very difficult decisions about how various operations on Text either do or don't preserve distinctions that ought not to matter in the first place.
04:18:07 <merijn> Maxdamantus: Although "able to print filenames" depends on the platform
04:18:18 <merijn> Maxdamantus: Because some platforms demand specific normalisations
04:18:47 <Cale> It's like saying "I want an AND gate, but it should preserve the maximum of the two voltage levels"
04:19:03 <Cale> That's... at the wrong level of abstraction :)
04:19:19 <Maxdamantus> merijn: my main concern is platforms that aren't relying on archaic encodings (eg, CP-1252 or SJIS)
04:19:49 <Maxdamantus> merijn: I'm not saying I don't care about those platforms, just that things should be as correct as possible on ones that are not archaic.
04:20:32 <Cale> (and besides that, it wouldn't work from an engineering perspective -- it's important that gates amplify the difference between the representation of 0 and 1, but the analogy to this situation breaks down there)
04:20:33 <merijn> Maxdamantus: Who says archaic? Both Windows and macOS do *not* have byte sequences as filenames
04:20:33 <Maxdamantus> which in my opinion means not producing errors randomly just because some file has been split in a place which is inconvenient to a UTF-8 decoder
04:21:13 <Maxdamantus> merijn: actually aiui, macOS is moving towards having byte sequences as filenames (APFS)
04:21:37 <Maxdamantus> merijn: I don't know if/when Windows will look into fixing that mistake though
04:21:38 <merijn> Maxdamantus: No, still unicode, but no longer with mandated normalisation (or something along those lines making things subtly hard)
04:22:15 <Maxdamantus> merijn: but again, those *are* archaic as far as I'm concerned, because their architecture is based on assumptions which are now considered suboptimal.
04:22:32 <Maxdamantus> If someone makes an OS today from scratch, it will not have 16-bit filenames
04:22:40 <merijn> I think saying filenames are bytes is suboptimal
04:22:56 <Maxdamantus> so what should they be? code points?
04:22:59 <merijn> It means it's completely impossible to name files non-ascii things
04:23:04 <merijn> Maxdamantus: Specific encodings
04:23:20 <Maxdamantus> UTF-8 allows you to encode many forms of text into bytes.
04:23:22 <Cale> Maxdamantus: What's wrong with using UTF-16? Who cares? That should be a lower-level implementation detail than any programmer would have to worry about, if we were doing it right.
04:23:27 <merijn> Maxdamantus: Ideally UTF-8, but any specific unicode encoding works
04:23:58 <merijn> Maxdamantus: The problem is that, on linux, you have no way to know which encoding was used to generate the filepath's bytes from unicode names
04:24:16 <merijn> Maxdamantus: So there's no way to deterministically display filenames that have unicode names
04:24:34 <Cale> There could even be a unicode encoding used solely for filenames and nobody should have to care
04:24:39 <Maxdamantus> Cale: "what's wrong with UTF-16" is the wrong question. The question should be "what's the point of UTF-16", and the answer is "it's a workaround to the now-invalid assumption that 16-bit code units are useful"
04:24:40 <merijn> Maxdamantus: Now, you could argue that "everything should be UTF-8", which I do agree with, but then we need to just say "filepaths are UTF-8 encoded names"
04:24:43 <Cale> except the people implementing the filesystem
04:25:00 <Cale> Maxdamantus: It seems like a useful compromise in many situations?
04:25:02 <merijn> Maxdamantus: How are "bytes" better than UTF-16?
04:25:09 <Cale> It depends on the average string that you're encoding
04:25:10 <merijn> Maxdamantus: With bytes you know *nothing*
04:25:26 <Cale> Probably for filenames in Western countries, you're right that UTF-8 is probably optimal
04:25:39 <merijn> You can't correctly display a filepath that's just "bytes", at least you *can* render them if they're UTF-16
04:25:39 <Maxdamantus> ... is this really where this conversation is going? "is UTF-8 really better than UTF-16?"
04:25:48 <Maxdamantus> Google it.
04:25:54 <Cale> The point we're trying to make is that it ought not to matter
04:25:56 <Cale> at all
04:25:59 <merijn> Maxdamantus: UTF-8 *is* better, but linux filepaths *aren't* UTF-8
04:26:06 <int-e> merijn: but we have all this (7 in 8 bit) ASCII text lying around!
04:26:11 <Cale> at least, that's what I'm trying to say
04:26:23 <merijn> Maxdamantus: If your proposal is "filepaths are UTF-8", sure, I agree. But that's not what you said initially and that's also not true currently
04:26:30 <Cale> You shouldn't have to care what encoding has been used, nor would you ideally be privy to it.
04:27:02 <Cale> If filenames are some form of text rather than bytes, then in an ideal world, you don't know how that text gets encoded by the filesystem layer.
04:27:32 <Cale> It gets encoded not as UTF-8 or UTF-16 specifically, but *somehow*
04:27:35 <Maxdamantus> merijn: my proposal is "filepaths are bytes". If they are English or French or Chinese or whatever, that's up to a higher level to know about.
04:27:53 <merijn> Maxdamantus: But how do you know whether they're English, French, or Chinese?
04:27:57 <Maxdamantus> merijn: unless you're rendering text, you probably don't need to know about Chinese or about UTF-8.
04:28:00 <merijn> Maxdamantus: There's no metadata to recover that information from
04:29:13 <merijn> Maxdamantus: Simple question: I run "touch αβγ" on linux as a guest user. How can any other user sensibly read the filename in "ls" or a file browser?
04:29:26 <Maxdamantus> merijn: so what's your proposal? Have the kernel reject non-UTF-8 filenames?
04:29:30 <merijn> Maxdamantus: The answer is: "There is no possible way"
04:29:49 <merijn> Maxdamantus: That, or demand unicode and let the filesystem decide on an encoding internally
04:31:03 <Maxdamantus> merijn: so what's the advantage here over just using bytes instead, and have the higher-level text editors/renderers make the assumption that it's UTF-8, just as they're making the assumption that it's making correct use of combining characters?
04:31:22 <Maxdamantus> (bytes in the kernel, that is)
04:31:23 <merijn> Maxdamantus: Filenames are always human readable, that's their entire purpose, however we can't safely assume what language humans want to write them in. We already have a solution for this problem. Unicode, so we should use it. Using bytes for names is a historical mistake originating from the US and the idea that everything is ASCII
04:31:39 <merijn> Maxdamantus: Well, what do you do when the assumption is wrong?
04:31:49 <int-e> . o O ( .git/objects/5c/c504227b240af9fcc689d37eca5ceff2af5d76 )
04:31:52 <Maxdamantus> merijn: are sequences of code points always human-readable?
04:31:54 <merijn> Maxdamantus: How can your editor/shell know what encoding *I* used to create
04:32:02 <int-e> not always human readable ;-)
04:32:40 <Maxdamantus> merijn: the latter assumption can always be wrong.
04:32:48 <merijn> Maxdamantus: That's the problem, there's not system wide setting for what encoding is used to create files, so tooling can't "just assume", because files on the system are made by many people
04:32:57 <Maxdamantus> merijn: eg, a filename can start with "\u{301}"
04:33:10 <merijn> Maxdamantus: So what's wrong with mandating unicode filepaths, at least we KNOW we can render those
04:33:27 <Maxdamantus> merijn: but we DON'T know that.
04:33:33 <merijn> Maxdamantus: How so?
04:33:35 <int-e> merijn: I agree with you on an idealistic level, but in practice I don't see the POSIX interface to be overhauled like that any time soon.
04:33:39 <Maxdamantus> merijn: the filenames might have code points that are not allocated.
04:33:54 <Maxdamantus> merijn: or they might make incorrect use of known combining characters.
04:33:58 <merijn> int-e: Oh sure, I don't expect that to happen, but insisting everything else switches over to POSIX' mistake is dumb
04:34:21 <int-e> So pragmatically I'd prefer to pick one of UTF-8 or UTF-16 for applications to use and stick to (UTF-8 seems the likelier candidate to be universally adopted).
04:34:25 <merijn> Maxdamantus: So validate their correctness in the kernel/filesystem and reject wrong ones
04:34:32 <Maxdamantus> merijn: should the kernel reject filenames that use undefined code points?
04:34:36 <merijn> Maxdamantus: Yes
04:34:41 <int-e> And in the meantime it's a mess.
04:35:15 <merijn> Like, why SHOULDN'T the kernel reject undefined code points in filenames? That's unambigously wrong, give me a single reason to ever want that
04:35:20 <Maxdamantus> merijn: okay, so I just upgraded to Linux 5 and so my system supports code points that your doesn't. What happens if I put such a file in git and you modify another file in the same repository?
04:35:30 <int-e> Oh UTF-16 won't even work, since that can contain *bytes* that encode '/'...
04:35:41 <int-e> (on top of POSIX file I/O)
04:35:55 <Maxdamantus> merijn: is git meant to handle this and explicitly avoid messing up the filename or crashing?
04:36:06 <merijn> Maxdamantus: Git errors out unable to open/clone the file
04:37:05 <Maxdamantus> merijn: so software hosting remote repositories needs to be on a version of Linux greater than or equal to every client?
04:37:15 <Maxdamantus> merijn: otherwise the remote is going to be crashing.
04:37:29 <Maxdamantus> merijn: this is stupid. What problem are you solving by doing this?
04:37:52 <Maxdamantus> Why not just accept that text is sometimes nonsense?
04:38:04 <tty1> I have some recent code I wrote but I cant help but feel it is way more verbose then it needs to be. Since im a complete haskell noob I could use some feedback on how to improve the code (it does work though): https://pastebin.com/cFfwZNkE
04:38:32 <Maxdamantus> even if it's completely valid unicode at every level, some text is not meaningfully useful, but you're not hgoing to create a useful and concise set of rules to capture what text is meaningful.
04:38:35 <merijn> tty1: Any specific reason to use HashMap over Map?
04:38:45 <Maxdamantus> anyway, gtg
04:38:59 <tty1> merijn: IIRC map requires the key to be Ord 
04:39:26 <tty1> merijn: plus a hashmap would be faster than a binary tree implementation
04:39:27 <merijn> tty1: What kinda keys are you expecting that aren't Ord?
04:39:43 <merijn> tty1: Whether a Hashmap is faster is debatable and very dataset dependent
04:39:48 <tty1> merijn: the consumer provides the keys, they could be anything
04:40:14 <Solonarv> tty1: Map is faster/on par with HashMap quite often
04:40:20 * hackage prometheus-proc 0.1.1.0 - Export metrics from /proc for the current process  https://hackage.haskell.org/package/prometheus-proc-0.1.1.0 (OliverCharles)
04:40:28 <merijn> tty1: So, make them deal with making it Ord? Now they need to make it Hashable which is generally more work
04:41:07 <merijn> tty1: Anyhoo, with regard to verbosity, half of it seems to be qualification with HashMap. So why not get rid of the qualification?
04:41:33 <merijn> tty1: As an aside, I would recommend NOT putting the "where" at the end of a line like you don on line 16
04:41:41 <tty1> merijn: qualification in what sense?
04:41:45 <merijn> tty1: I was superconfused reading that until I noticed the where hidden away
04:42:03 <Solonarv> I usually write my imports like this:
04:42:03 <Solonarv> import Data.Map.Strict (Map)
04:42:03 <Solonarv> import qualified Data.Map.Strict as Map
04:42:05 <merijn> tty1: "HashMap.Hashable" in constraints and "HashMap.HashMap" in types
04:42:14 <Solonarv> so the type is just Map and functions are Map.foo
04:42:18 <merijn> tty1: You can just import Hashable and HashMap and use them directly
04:42:32 <tty1> ahhh indeed yea
04:42:56 <tty1> i was thinking there might be a nice way to get rid of those case statements
04:43:08 <merijn> tty1: tbh, most of it doesn't look to verbose (although the lines are a bit long and harder to read due to that)
04:43:43 <tty1> hmm thats good to hear then
04:44:03 <Solonarv> any time you have 'case foo of Nothing -> def; Just a -> a' you can write this as 'fromMaybe def foo'
04:44:05 <lyxia> could use ScopedTypeVariables to avoid repeating the constraints
04:44:35 <Solonarv> separately, you don't need the parentheses in 'case (combine node graph) of ...'
04:44:48 <tty1> ohhh so fromMaybe will extract it and use a default when nothing, cool
04:44:51 <merijn> tty1: Also <++> appears to just be Monoid on Maybe :)
04:45:00 <tdammers> I actually prefer the explicit pattern matching over maybe most of the time
04:45:03 <tdammers> although fromMaybe is nice
04:45:06 <merijn> > Just [1,2,3] <> Nothing <> Just [4,5,6]
04:45:09 <lambdabot>  Just [1,2,3,4,5,6]
04:45:44 <tty1> merijn: oh really? I thought the result of that would be Nothing
04:45:58 <merijn> tty1: Not for Monoid, Nothing is mempty for maybe :)
04:46:07 <tty1> ohh hmmm
04:46:12 <tty1> let me try that
04:46:15 <merijn> tty1: In fact, you can make combine a bunch shorter with my favourite Monoid
04:46:27 <lyxia> edgeMap and addEdgeMapListed are foldl and edgeList is map
04:47:06 <merijn> Code obfuscation time! "HashMap.lookup (node, In) <> HashMap.lookup (node, Out) $ edgeIndex"
04:47:17 <merijn> Function Monoid = best Monoid :)
04:47:24 <Solonarv> also, I might suggest using record syntax for the definition of Graph
04:47:41 <Solonarv> it isn't immediately clear to me what the fields are supposed to be, giving them names would help with that
04:47:51 <tdammers> intuitively, I would guess that mempty /= Nothing would violate the monoid laws
04:48:15 <merijn> tdammers: Yes
04:48:33 <Solonarv> nope - it could also be an absorbing element
04:48:38 <tty1> merijn: when i try to do as you suggest it says "<>" not in scope.. do I have to imprt something?
04:48:40 <tdammers> ah yes, right
04:48:48 <merijn> tty1: Data.Monoid or Data.Semigroup
04:48:55 <merijn> tty1: Alternatively you can use "mappend"
04:48:57 <Solonarv> that would the instance with (<>) = liftA2 (<>), mempty = Just mempty
04:49:32 <tdammers> mempty = Just mempty -- would also work because Nothing <> a = Nothing automatically means that Nothing <> mempty = Nothing, and Just a <> mempty = Just a is given by the monoid instance of the payload
04:49:47 <merijn> Ah, yeah
04:49:48 <tdammers> it would be surprising though IMO
04:50:12 <merijn> Given that Maybe is the free Monoid on Semigroups, yes it would :)
04:50:18 <tty1> ok great gotta all of merijn suggestions in... let me review the others
04:50:18 <Solonarv> not that surprising - it's just the standard lifted-through-Applicative instance
04:50:38 <merijn> tty1: I'm not sure the last one with <> on functions is...recommended ;)
04:50:53 <merijn> tty1: But it's a good trick when you want to combine a lot of function results
04:51:01 <tdammers> well, maybe not surprising, but definitely somewhat unexpected
04:51:05 <absence> does anyone have experience with polysemy? do effects that call e.g. Control.Concurrent.Async.race have to be implemented using Tactical, like bracket in Polysemy.Resource?
04:51:36 <tdammers> then again, maybe not, because mempty = Just mempty is more consistent with Maybe's Applicative and Monad instances, idk
04:51:48 <Solonarv> yes, that is what I said :P
04:51:58 <tdammers> right, but you used fancier words :D
04:52:01 <Solonarv> heh
04:53:03 <tty1> lyxia: I would i use foldl as you suggested?
04:53:22 <tty1> *how would
04:53:23 <lyxia> absence: isovector hangs out on slack though he comes here once in a while
04:55:06 <lyxia> tty1: edgeMap = foldl (\map c -> addEdgeMap (createEdge c) map) Hashmap.empty assocs
04:55:17 <tty1> hmm
04:55:43 <absence> lyxia: i see, thanks
04:56:01 <Solonarv> hmm, that smells like a fromList / fromListWith
04:56:53 <lyxia> heh it does, I didn't think that far
05:06:37 <tty1> Solonarv: how would i write it as a fromList?
05:10:43 <Solonarv> edgeMap = HashMap.fromListWith (++) <something>
05:11:11 <Solonarv> at least I think so, I'm having some trouble figuring out what all these type synonyms represent
05:11:50 * hackage hw-excess 0.2.0.3 - Excess  https://hackage.haskell.org/package/hw-excess-0.2.0.3 (haskellworks)
06:46:21 * hackage git-remote-ipfs 0.1.0.0 - Git remote helper to store git objects on IPFS  https://hackage.haskell.org/package/git-remote-ipfs-0.1.0.0 (jkarni)
07:13:06 <dmwit> Solonarv: It's not the lifted-through-Applicative instance, because (<>) Nothing a = a but liftA2 (<>) Nothing a = Nothing.
07:14:05 <dmwit> Oh, I see I misread.
07:14:12 <dmwit> We are talking about an alternative instance.
07:15:59 <tdammers> yep
07:34:35 <tty1> Is the overloading of functions (differnt number of arguments) forbidden n haskell?
07:34:58 * Solonarv hand wiggles
07:35:05 <Solonarv> sort of
07:35:08 <merijn> tty1: It's not possible, but I'm not sure that's the same as forbidden
07:35:18 <tty1> ok
07:35:22 <tty1> thanks
07:35:29 <merijn> And then there's also all sorts of fancy tricks you can to kinda/sorta fake it
07:35:40 <tty1> such as?
07:35:43 <Solonarv> you can't just define multiple functions with the same name but different types+implementations
07:36:01 <merijn> tty1: Such as this: https://gist.github.com/merijn/dc00bc7cebd6df012c5e
07:36:03 <Solonarv> but you can do it in a roundabout way using typeclasses
07:36:15 <merijn> tty1: But...that's kinda overkill
07:36:24 <merijn> You can also do recursion via typeclasses like Printf does
07:36:55 <tty1> "type family" is new to me....
07:38:01 <merijn> tty1: I can recommend the (pretty readable) "Fun with Type Functions" paper on understanding those
07:38:13 <merijn> https://www.researchgate.net/profile/Simon_Peyton_Jones/publication/225894175_Fun_with_Type_Functions/links/0c960517e31f70c5dc000000.pdf
07:38:16 <tty1> ill check it out thanks
07:39:18 <tty1> How common is it for projects to try to write libraries that dont use any language extensions? Is it common to want to use "base" haskell or are people usually pretty liberal when it comes to using extensions?
07:39:31 <merijn> tty1: But in most cases "variable number of arguments" can be faked via "accepts a list"
07:39:44 <Solonarv> no language extensions at all? that's incredibly rare, I think
07:40:04 <merijn> Solonarv: Naah, not *that* rare, but generally convenience trumps things
07:40:41 <Solonarv> some extensions are not "here is a fancy new feature" but rather "here is a thing that makes sense and is straightforward, but the Haskell Report says otherwise"
07:40:46 <merijn> tty1: GHC evolves pretty rapidly and the standard...not so much, the last update was 2010 and that updated almost nothing
07:41:23 <Solonarv> also, GHC is pretty much the only compiler that sees any use, so there's not much incentive to use a smaller set of extensions to stay compatible with other compilers
07:41:28 <merijn> tty1: Since GHC is the only "real" implementation around, most people just like the convenience the extensions offer
07:41:38 <merijn> Simple example:
07:41:43 <merijn> % :t 1e6
07:41:55 <merijn> hmm, what happend to yahb?
07:41:57 <Solonarv> and many other Haskell implementations support some of the same extensions GHC does
07:42:09 <Solonarv> hm, yahb appears to be offline
07:42:12 <merijn> Drat
07:42:14 <Solonarv> mniip: yahb is down?
07:43:25 <merijn> tty1: Anyway, you can try my example easily in ghci: ":t 1e6" returns "1e6 :: Fractional p => p" i.e. it's a fractional value
07:43:48 <merijn> Now, obviously 1e6 is an integer, so why should I (annoyingly) write out 1000000 instead of 1e6 just because I want an Int?
07:44:28 <merijn> tty1: So if you run ":seti -XNumDecimals" in ghci you'll see that ":t 1e6" becomes "Num p => p"
07:44:32 <kuribas> Solonarv: a friends criticism on  haskell was that you need extensions which alter the language in order to be useful.
07:44:53 <kuribas> Solonarv: where in lisp you do whatever you like with macros
07:45:06 <kuribas> (alter or extend)
07:45:15 <Solonarv> I mean, you can do whatever you like with macros in Haskell too... :P
07:45:22 <Solonarv> (template haskell)
07:45:33 <kuribas> Solonarv: sure, but they don't integrate as nicely as lisp macros
07:46:02 <fizbin> Well, once you add the extension to enable TH, which is one of those extensions which alter the language...
07:46:06 <Solonarv> oh yeah, I wasn't being serious
07:46:14 <merijn> tty1: Do you really *need* NumDecimals to write libraries? No, but it can make your life a lot more convenient. There's a bunch of extensions like those: OverloadedStrings, NumDecimals, OverloadedLists, etc. on the other hand there are also extensions that make the type system more flexible/powerful in ways that let us write more abstract code (i.e. Rank2Types)
07:47:20 <kuribas> Solonarv: compared to scheme, haskell is heavyweight, especially with extensions
07:47:30 <kuribas> Solonarv: strangely he does like bash
07:47:33 <Solonarv> sure, I don't disagree
07:47:46 <Solonarv> I just disagree with the notion that that's automatically a bad thing
07:47:46 <kuribas> Solonarv: which is IMO more heavy on syntax and builtin functionality than haskell
07:48:07 <merijn> tty1: Incidentally, that gist I linked is really going overboard on the extensions :p
07:48:25 <merijn> tty1: You can write plenty of useful and simpler code without that nonsense
07:48:32 <Solonarv> tends to happen when you do a bunch of type-level stuff
07:49:00 <kuribas> IMO extensions are nice when you really need them.  Otherwise they are a code smell.
07:49:20 * hackage aur 6.2.0.1 - Access metadata from the Arch Linux User Repository.  https://hackage.haskell.org/package/aur-6.2.0.1 (fosskers)
07:50:35 <nshepperd_> That seems a bit like complaining that you need to import libraries
07:51:10 <nshepperd_> Enabling extensions isn't hard work, so what's the big deal about having stuff "built in"?
07:51:46 <merijn> nshepperd_: Well, extensions have some overhead in that they turn the language into a large set of dialects depending on which extensions happen to be on
07:52:03 <kuribas> nshepperd_: that you don't have any control over them, how they created, the syntax...
07:52:04 <merijn> So merging extensions into the report would reduce that mental overhead as they're basically "always on"
07:52:32 <Solonarv> merijn: I feel like that complaint would hold a lot more merit if some extensions were mutually exclusive, tbh
07:53:11 <nshepperd_> kuribas: you don't have any control over the syntax of built-in functionality either
07:53:18 <merijn> Solonarv: OverloadedStrings changes rather drastically how to read code
07:53:22 <kuribas> nshepperd_: exactly
07:53:47 <Solonarv> ah yes, the overloaded syntax ones are a bit different - that's a fair point
07:55:15 <fizbin> merijn: That (the mental overhead of different dialects) is strong support for a standard set of "we always turn on these extensions in our cabal files" standards within any company doing more than one thing in Haskell.
07:55:58 <merijn> fizbin: I don't like that either, because now checking which sets is on requires a non-local check in another file :)
07:57:43 <Solonarv> well, I think the idea is that all the code you're working on uses the same set of extensions, so eventually you don't need to check anymore
07:57:44 <nshepperd_> kuribas: so the problem is actually nothing to do with how many extensions you need to enable in haskell
07:59:02 <kuribas> nshepperd_: the critisism went something like, haskell isn't that useful, because you need to keep adding extension to be able to use it.
07:59:10 <nshepperd_> But the fact that you can't just use lisp macros to extend it
07:59:30 <kuribas> nshepperd_: I don't agree, I think lisp is already nicer than other language without many extensions
07:59:35 <kuribas> haskell not lisp
07:59:40 <fizbin> merijn: Only if you're new to the company. Along with the "these are always enabled in the cabal file" standard, you also want a "never enable other extensions in the cabal file unless some technical reason requires you to do so" standard.
08:00:11 <tty1> sorry got booted
08:00:35 <fizbin> That minimizes the non-local file check.
08:04:19 <tty1> merijn: i just tend to be a purest but im wondering if its worth the trouble here
08:05:49 <nshepperd_> kuribas: that seems to make about as much sense as "lisp isn't that useful because you need to keep adding macros to be able to use it" imo
08:06:32 <kuribas> nshepperd_: but that's easy to do
08:06:54 <nshepperd_> So is enabling an extension
08:07:04 <tabaqui> btw, which extensions will be included in Haskell2020?
08:07:21 <tabaqui> FlexibleInstances/Contexts?
08:07:25 <tabaqui> TupleSections?
08:08:04 <tabaqui> s/which/what
08:08:31 <merijn> tabaqui: Let's wait and see if Haskell2020 happens at all :p
08:08:42 <merijn> I think FlexibleX is a pretty safe bet, though
08:10:14 <tabaqui> A lot of extensions bring good sugar, like StandaloneDeriving, LambdaCase and others
08:13:40 <bahamas> can anyone tell me if there's anything in the definition of this resource that references the content of the object? because I don't see it  http://hackage.haskell.org/package/gogol-storage-0.4.0/docs/Network-Google-Resource-Storage-Objects-Get.html
08:15:27 <tabaqui> source code has better readability, though
08:24:33 <tdammers> I think the extensions thing is blown out of proportion
08:25:35 <tdammers> straight-up Haskell2010 without any extensions is pretty damn usable already, and many extensions are perfectly straightforward and uncontroversial
08:31:46 <Blar> Are there four different/incompatible ByteString implementations?  Strict Word8, Strict Char8, Lazy Word8 and Lazy Char8?
08:32:37 <tabaqui> Blar: Word8 and Char8 are the same
08:32:54 <tabaqui> only Lazy and Strict have different implementations
08:33:45 <Blar> tabaqui: if they are different, then why is there a `lines` function for Data.ByteString.Lazy.Char8 but not for Data.ByteString.Lazy?
08:33:56 <tabaqui> iirc, they all are Word8 inside, but Char8 functions make additional conversions
08:34:01 <Blar> tabaqui: if they are _same_, then why is there a `lines` function for Data.ByteString.Lazy.Char8 but not for Data.ByteString.Lazy?
08:34:12 <Solonarv> Blar: bytestrings are really just a bunch of octets
08:34:35 <Solonarv> the .Char8 modules pretend that they are text
08:34:41 <Blar> A function that expects  [Data.ByteString.Lazy] – can I pass in [Data.ByteString.Lazy.Char8] instead?
08:34:49 <Solonarv> yes, that's the same type
08:35:52 <tabaqui> Blar: `lines` works in the reality in which newline is a character
08:36:32 <tabaqui> because there is no special separator number, worded version has no `lines` function
08:36:47 <Blar> tabaqui: but can `lines` split at \n and also at \r\n?
08:37:00 <tabaqui> uh, I don't know
08:37:05 <tabaqui> you can check this
08:37:12 <tdammers> the ByteString types in ByteString and ByteString.Char8 are aliases, i.e., the same type, but the functions defined in those modules are not
08:37:17 <Blar> In Data.ByteString.Lazy there is a function `split`. But it can split on \n but not on \r\n
08:38:03 <tdammers> at this point, you are probably better off upping your game to a proper parser library like attoparsec
08:38:31 <tabaqui> Blar: well, I see that `lines` treats '\r' as any other character
08:38:54 <Blar> tdammers: I just want plattform-independent input files to parse as CSV via Cassava.
08:39:05 <tdammers> oh dear
08:39:16 <tdammers> that's like two rabbit holes in one
08:39:17 <Blar> Instead of parsing the whole file as one (7 gb) I want to do it line-wise.
08:39:49 <tabaqui> uh, attoparsec can be a better choice
08:40:20 * hackage primitive-atomic 0.1.0.1 - Wrappers for primops around atomic operations  https://hackage.haskell.org/package/primitive-atomic-0.1.0.1 (andrewthad)
08:40:31 <Blar> Cassava already depends on attoparsec.
08:40:45 <Blar> It should ideally have done this correctly.
08:40:55 <tdammers> it cannot be done correctly
08:42:52 <Solonarv> er, cassava already has streaming decoding
08:42:57 <fizbin> As an aside, "CSV" is a ludicrously under-specified format. (Compared to something like JSON or even something as wild and loose as "XML" without any DTD or schema)
08:43:04 <Solonarv> here: https://hackage.haskell.org/package/cassava-0.5.1.0/docs/Data-Csv-Streaming.html
08:43:14 <Blar> Solonarv: oki thanks, will check this one out
08:43:32 <Solonarv> mentioned right in the front page of the documentation, even!
08:44:20 <fizbin> (Especially if by "CSV" you mean "what Excel will write/accept in a .csv file")
08:45:52 <Blar> fizbin: Excel outputs for me ssv files => semicolon separated values
08:46:24 <fizbin> Right, because it's really "locale-specific list separator"-separated-values.
08:47:04 <tdammers> fwiw, all the cassava FromField instances for string-like types assume UTF-8, so if your CSV isn't UTF-8, you have a problem already
08:47:20 * hackage error-codes 0.1.0.1 - Error code functions  https://hackage.haskell.org/package/error-codes-0.1.0.1 (andrewthad)
08:48:00 <Vyse007> What's the best book to start learning logic and type-theory with? I understand that these are two different subjects, so I am guessing I should start with logic first? The other day I came across a reference to a 'skolem' and got totally confused on its wiki page.
08:48:09 <fizbin> (In 2007, the only way I found to produce a ".csv" file that Excel versions all over the planet would accept was to encode it in UTF-16LE with a BOM and separate the values with tabs)
08:49:06 <fizbin> (and of course end lines with CRLF)
08:58:50 * hackage ghc-lib-parser 0.20190523 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-0.20190523 (shayne_fletcher)
09:06:51 * hackage ghc-lib 0.1.0 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-0.1.0 (shayne_fletcher)
09:07:50 * hackage ghc-lib 0.20190523 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-0.20190523 (shayne_fletcher)
09:10:34 <dmwit> ?where tapl -- Vyse007
09:10:34 <lambdabot> "Types and Programming Languages" by Benjamin C. Pierce in 2002-02-01 at <https://www.cis.upenn.edu/~bcpierce/tapl/>
09:12:08 <dmwit> Blar: https://hackage.haskell.org/package/csv-conduit perhaps
09:12:29 <Vyse007> dmwit: Thanks! I have heard about TAPL, but I always thought it was meant for folks with an already reasonable background in logic.
09:12:47 <dmwit> There is a pipes-csv and csv-enumerator as well if you're more familiar with pipes or enumerator than conduit.
09:14:01 <dmwit> Vyse007: That may be so, I'm not sure. I admit I had seen the basics of logic when I read it. But I think in the end you can actually learn PL theory and logic as separate topics if you want, and only notice the deep connections after the fact.
09:16:14 <dmwit> Blar: Or for that matter http://hackage.haskell.org/package/cassava-0.5.1.0/docs/Data-Csv-Incremental.html if you want the bare metal. cassava already supports what you ask for, seems to me.
09:18:16 <jb55> pipes-csv is just a pipes wrapper around the cassava incremental apis
09:18:46 <dmwit> I expect the others (conduits and enumerator ones) are similar.
09:19:04 <ski> Vyse007 : re logic, i totally suggest using learning resources which uses Natural Deduction as the proof/deduction/derivation/inference/reasoning system
09:20:47 <Vyse007> ski: Any recommendations? Googling 'natural deduction logic' throws a bunch of hits.
09:24:20 * hackage qrcode-core 0.9.1 - QR code library in pure Haskell  https://hackage.haskell.org/package/qrcode-core-0.9.1 (alexkazik)
09:34:21 * hackage ghc-lib 0.20190523.1 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-0.20190523.1 (shayne_fletcher)
09:48:17 <solrize> Vyse007, harper's book is good as intro level PLT if you're looking for that.  it doesn't use much logic
09:51:25 <solrize> Vyse007, hmm   https://mathoverflow.net/questions/330873/good-introductory-book-to-type-theory
09:54:23 <Vyse007> solrize: Wow those are some good resources. Went through a couple of them, and it looks like they all start with some basics of logic, which is a good thing.
10:03:43 <jle`> phadej: thanks for the clarification :)
10:54:54 <ais> Given `data Box a = Box`, how do i lift the value inside, if it is contained in arbitrarily deeply nested Boxes? Something like `Box (Box (Box 2))`
10:55:17 <ais> `data Box a = Box a`*
10:56:10 <sarahzrf> ais: it can't be
10:56:35 <sarahzrf> something of type "Box (Box (Box 2))" would have type "Box (Box (Box Int))"
10:56:39 <sarahzrf> not Box Int
10:57:43 <lavalike> well it's not impossible
11:03:07 <dminuoso> ais: What exact semantics do you mean by "lift"?
11:03:32 <dminuoso> ais: Do you mean some `Box (... Int) -> Int` for an arbitrarily deep nesting of Box?
11:03:43 <dminuoso> Or `Box (... Int) -> Box Int` ?
11:04:01 <ais> what do the three dots mean?
11:04:21 <dminuoso> ais: Box (Box (Box Int)), Box (Box (Box (Box Int)))
11:04:25 <dminuoso> Any such nesting
11:07:37 <ais> I was thinking about a function like `unwrap :: Box a -> a`, that could unwrap the value that is not a box in nested boxes. I'm trying to understand why this is not possible.
11:08:13 <lavalike> :t join
11:08:15 <lambdabot> Monad m => m (m a) -> m a
11:08:24 <lavalike> something along those lines is the best you can do I think
11:08:56 <lavalike> maybe not, for a specific Box you can do -> a, nevermind
11:09:03 <dminuoso> ais: Im not sure I understand.
11:09:08 <ais> neither do i 
11:09:08 <ais> lol
11:09:14 <dminuoso> ais: What are you trying to do?
11:09:38 <ais> i was trying to understand 
11:09:43 <ais> not write anything in particular
11:09:51 <ais> but i need to untangle my confusion first i guess
11:10:39 <ais> i'm probably assuming something that is false
11:17:00 <dminuoso> Well you could probably hack together some `class Unboxable t a b | a -> b where unbox :: t a -> b`
11:18:07 <dminuoso> Or just coerce.. :o)
11:19:50 * hackage quickcheck-classes 0.6.2.0 - QuickCheck common typeclasses  https://hackage.haskell.org/package/quickcheck-classes-0.6.2.0 (andrewthad)
11:21:50 <ais> since i'm often getting these `Occurs check: cannot construct infinate...` errors, i think i'm confused some where about the type system
11:22:00 <ais> for example, why does this cause the same error :
11:22:08 <ais> https://paste.ubuntu.com/p/fBDt6nFmmb/
11:22:14 <ais> ?
11:22:44 <glguy> on 3 line you were supposed to return a value with type 'Box a'
11:22:55 <glguy> bbut instead you returned one with type 'Box (Box a)'
11:23:03 <argent0> Hi, is this a _sane_ way of handling user input using recursion schemes? https://bpaste.net/show/bffb64183166. The `loop` function in particular.
11:23:11 <glguy> You don't get to pick what 'a' is, the user of your function gets to pick taht
11:23:19 <dminuoso> ais: The error essentially happens when the type system tries to solve for `a ~ f a` of some kind.
11:23:48 <dminuoso> ais: So when you get to `a ~ f a` and you substitute with that, you get `a ~ f a ~ f (f a) ~ f (f (f a)) ~ ...`
11:24:03 <dminuoso> ais: The type checker gives up because this is considered an infinite type and not admissable in this form.
11:25:42 <dminuoso> ais: What you ask for is in principle encodable using type classes.
11:28:02 <ais> i'm sorry if it seems like i'm just ignoring some of the answers, i just usually am trying to wrap my head around them and i take too long
11:31:15 <ais> dminuoso, what does the `~` symbol mean in your example about the type system?
11:31:54 <ski> ais : it means "equal"
11:31:59 <ski> i'd rather write
11:32:27 <ski>   a  =  f a  =  f (f a)  =  f (f (f a))  =  ...   =  f (f (f (f (...))))
11:33:08 <ski> (however, because $REASONS, `~' is how you spell type equality, as a constraint, in Haskell-with-extensions)
11:33:14 <ais> where could i read about how the type system tries to solve solve for a, so that i could get a better understanding?
11:33:30 <ski> hmm
11:33:32 <ais> i mean `a` as in this example
11:33:37 <ski> maybe you could try
11:33:44 <ski> @where polymorphic-type-inference
11:33:45 <lambdabot> "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <https://cs.au.dk/~mis/typeinf.p(s|df)>,<http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.57.1493>
11:34:04 <ski> iirc, it mentions the occurs check somewhere ?
11:34:06 <argent0> ski: doesn't ~ stand for isomorphic?
11:34:09 <ski> (it ought to, anyway)
11:34:29 <dminuoso> argent0: Ive seen various notations for isormorphic.
11:34:32 <ais> thanks, i will look into to it now
11:34:37 <ski> argent0 : i typically write `~=' in ASCII for isomorphic. when i'm not simply writing `=', i.e.
11:34:49 <ski> argent0 : but GHC doesn't have a notion of "isomorphic" to begin with
11:34:56 <dminuoso> ~~~ Ive also being used on IRC to denote isomorphic
11:35:01 <dminuoso> *Ive also seen
11:35:19 <ski> anyway, sometimes people write `===' for equality .. and it's really annoying :)
11:35:25 <dminuoso> ais: You could pick a simpler, perhaps more motivating example:
11:35:31 <k___> I've just predicted the future of Bitcoin! You should too :) Use my reference code NWTLB7Y to signup at 
11:35:31 <k___> https://www.swissborg.com/community-app-referral
11:35:39 --- mode: ChanServ set +q *!*@2001:b07:6461:5d8a:a4ca:8ba:4448:d03b
11:35:50 <dminuoso> @let foo :: a -> [a]; foo x = [foo x]
11:35:50 * hackage primitive-unlifted 0.1.1.0 - Primitive GHC types with unlifted types inside  https://hackage.haskell.org/package/primitive-unlifted-0.1.1.0 (andrewthad)
11:35:51 <lambdabot>  .L.hs:161:10: error:
11:35:51 <lambdabot>      • Couldn't match expected type ‘a’ with actual type ‘[a]’
11:35:51 <lambdabot>        ‘a’ is a rigid type variable bound by
11:35:59 <dminuoso> Huh
11:36:27 <dminuoso> This gives me an occurs check on my GHC
11:36:41 <ais> i'm not sure i understand what the bot is doing here
11:36:44 <ski> @let foo x = [foo x]
11:36:46 <lambdabot>  .L.hs:159:1: error:
11:36:46 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ [a]
11:36:46 <lambdabot>        Expected type: t -> a
11:36:52 <ski> dminuoso : like that ?
11:37:04 <ski> @let eat x = eat
11:37:06 <lambdabot>  .L.hs:159:1: error:
11:37:06 <lambdabot>      • Occurs check: cannot construct the infinite type: t ~ p0 -> t
11:37:06 <lambdabot>      • Relevant bindings include eat :: t (bound at .L.hs:159:1)
11:37:16 <ski> is a famous example
11:37:30 <dminuoso> ski: So this is truly strange. My code snippet produces an occurs check if I paste it exactly into GHCi.
11:37:43 <dminuoso> ski: Is there some flag enabled on lambdabot to change the behavior here?
11:37:45 <ski> dminuoso : in a single line, with type signature and all ?
11:37:48 <dminuoso> ski: Yes.
11:37:57 <ski> % let foo :: a -> [a]; foo x = [foo x]
11:38:05 <dminuoso> yahb is down for some reason
11:38:09 <ski> @slap yahb
11:38:09 <lambdabot> why on earth would I slap yahb?
11:38:14 <ski> bah!
11:39:12 <ski> dminuoso : i think .. perhaps .. `let' in lambdabot just adds it to a file, which is then loaded ?
11:39:52 <dminuoso> ski: Why would that change the diagnostic?
11:40:15 <ski> i dunno
11:40:18 <dminuoso> It think its either a version difference, or some extension that influences the diagnostic.
11:40:28 <dminuoso> Ive also tested loading the code snippet as a file
11:40:30 <ski> could be a version thing, i suppose
11:41:52 <badlicksjs> Why would one ever use Haskell when there is Lisp?
11:42:49 <dminuoso> badlicksjs: We have a strong and expressive type system, parametricity, sleek algebraic data types that let you express a great variety of ideas.
11:44:53 <yushyin> troll attempt failed :)
11:51:53 <zincy_> What are the equivalent types Z and Succ in GHC.TypeLits I can't find them :/
11:52:02 <dminuoso> zincy_: 0 and +1
11:52:19 <dminuoso> @let import GHC.TypeLits
11:52:20 <lambdabot>  Defined.
11:52:26 <dminuoso> :kind! 0
11:52:43 <dminuoso> :kind 0
11:53:03 <dminuoso> Oh well pretend it reads the right(tm) output.
11:53:10 <lyxia> % :kind! 0
11:53:15 <dminuoso> lyxia: yahb is down, sadly.
11:53:19 <lyxia> pff
11:53:41 <zincy_> ah nice
11:53:43 <zincy_> Thanks
11:53:58 <zincy_> How does the conversion work
11:54:05 <lyxia> what conversion
11:54:33 <dminuoso> zincy_: It's GHC magic. A literal in a type expression is considered a type level natural.
11:54:41 <dminuoso> (if you enable DataKinds)
11:54:54 <dminuoso> That is, a *numeric literal*
11:55:01 <zincy_> So it is just hard wired into the compiler
11:55:09 <zincy_> ah right
11:55:24 <zincy_> so its a typelit for natural numbers
11:55:33 <zincy_> Not defined inductively
11:55:40 <dminuoso> I wonder why the module was called TypeLits... :-)
11:55:49 <zincy_> hehe
11:55:51 * hackage primitive-containers 0.4.0 - containers backed by arrays  https://hackage.haskell.org/package/primitive-containers-0.4.0 (andrewthad)
11:55:57 <zincy_> I just thought they wouldn't be useful as type lits
11:56:12 <zincy_> That means they arent defined inductively
11:56:22 <zincy_> So I would ask how is + possible?
11:56:30 <dminuoso> zincy_: again, GHC magic.
11:57:03 <zincy_> I wonder what the performance of those Nat is like compared to handrolling your own in an inductive fashion
11:57:13 <zincy_> thanks for clearing these things up I was confused
11:57:17 <dminuoso> zincy_: Formally they are listed as type families in that module.
11:57:34 <dminuoso> zincy_: But you wont find type family instances for it, GHC does black magic to make them exist.
11:57:48 <zincy_> ok
11:58:40 <zincy_> Well 3 sure reads better than 'S ('S ('S 'Z)))
11:58:58 <zincy_> Even though the latter has the "look how clever I am" feel to it
12:00:14 <dminuoso> zincy_: And then you have some public API, and someone wants to specify a type of 4096... then it rather reads "look how silly they are"
12:00:29 <dminuoso> ;-)
12:00:34 <zincy_> haha
12:01:32 <dminuoso> zincy_: Regarding your performance question, I honestly dont know. But I expect TypeLits to be *much* faster than handrolling peano naturals.
12:01:45 <dminuoso> At least one order of magnitude.
12:02:16 <zincy_> awesome
12:02:23 <dminuoso> zincy_: Especially because you get some general arithmetic tools if you check the type families in that module
12:02:50 <dminuoso> zincy_: You even get Log2, Div, Mod..
12:03:03 <zincy_> Nice
12:03:25 <zincy_> Can you singleton-ify  Nat in GHC.TypeLits?
12:03:40 <zincy_> Maybe you don't need to
12:04:05 <dminuoso> zincy_: Its already done.
12:04:11 <zincy_> natVal?
12:04:17 <dminuoso> zincy_: And KnownNat, yes.
12:04:55 <dminuoso> Or no wait. Mmm.
12:05:12 <dminuoso> zincy_: I suppose `Proxy 4` is a singleton. ;)
12:05:27 <zincy_> Yeah it is a singleton in the general sense right?
12:05:37 <dminuoso> Well there is only one value of type Proxy 4
12:05:41 <zincy_> But not one that plays with the Singletons library
12:06:24 <zincy_> Is Proxy 4 what they call an existential?
12:07:19 <dminuoso> zincy_: SomeNat is an existential
12:07:43 <zincy_> SomeNat is generally a GADT isnt it
12:07:56 <dminuoso> zincy_: No.
12:08:01 <dminuoso> Though you could encode it with a GADT.
12:08:15 <dminuoso> data SomeNat = forall n. KnownNat n => SomeNat (Proxy n)
12:08:49 <zincy_> So it is a higher kinded type which doesn't take just any * as input
12:09:01 <dminuoso> zincy_: No, its an existentially quantified type.
12:09:07 <zincy_> But an "existentially" qualified type
12:09:20 <dminuoso> zincy_: Note that the `forall n. KnownNat n => ...` is to the left of the data constructor
12:09:34 <zincy_> That is the existential qualification righjt
12:09:40 <dminuoso> zincy_: I just said that, yes.
12:10:27 <zincy_> Why the word existential
12:10:31 <dminuoso> zincy_: SomeNat is essentially just `exists n. KnownNat n *> Proxy n`
12:10:40 <zincy_> thanks
12:14:33 <dminuoso> zincy_: By the way since you asked: http://hackage.haskell.org/package/singleton-typelits
12:34:30 <zincy_> dminuoso: cheers!
12:42:20 * hackage prelude-compat 0.0.0.2 - Provide Prelude and Data.List with fixed content across GHC versions  https://hackage.haskell.org/package/prelude-compat-0.0.0.2 (HenningThielemann)
13:06:11 <Black_Beauty> You wanna watch my Live (Starting in 8-10 minutes)? I am going to touch & play with myself. Enter and reserve your seat (FREE for next 5 people): http://qt.ms/2t7yaAS
13:13:31 <BlackCapCoder> data StepperT a m = StepperT { step :: a -> m (StepperT a m) }
13:14:17 <BlackCapCoder> ^ I am looking for a library for this
13:19:12 <sarahzrf> BlackCapCoder: that looks basically like a Consumer from pipes
13:19:18 <sarahzrf> what's your use case?
13:22:50 * hackage non-empty 0.3.2 - List-like structures with static restrictions on the number of elements  https://hackage.haskell.org/package/non-empty-0.3.2 (HenningThielemann)
13:23:44 <BlackCapCoder> sarahzrf: Emulating a toy language called TIS-100. You have a network of processors that each run their own little program
13:24:06 <tabaqui> ooh, you wanna do a fork?
13:24:41 <tabaqui> there was somewhere a beautiful example of cell automates based on comonads
13:24:43 <jle`> BlackCapCoder: hm, it's also MealyT m a (), from machines
13:24:54 <jle`> it's basically MealyT with unit output
13:24:55 <BlackCapCoder> tabaqui: That's baically what I am doing
13:25:08 <BlackCapCoder> tabaqui: going off of this: http://blog.emillon.org/posts/2012-10-18-comonadic-life.html
13:26:02 <jle`> also Auto m a () from the 'auto' library
13:26:02 <tabaqui> not a fork, probably a cover version
13:26:04 <tabaqui> I dunno
13:26:06 <sarahzrf> BlackCapCoder: then something like pipes or machines might be what you want
13:26:21 <jle`> but the machines version might be simpler
13:26:52 <jb55> you're in streaming land now, nothing is simple
13:27:02 <sarahzrf> hahaha
13:27:18 <dminuoso> tabaqui: ekmett ran a blog series about it a while ago.
13:27:36 <tabaqui> maybe I even read them before
13:28:03 <tabaqui> co-things are great, that's a shame I see no points where I could apply any of them
13:31:50 * hackage comfort-array 0.4 - Arrays where the index type is a function of the shape type  https://hackage.haskell.org/package/comfort-array-0.4 (HenningThielemann)
13:33:18 <dminuoso> tabaqui: well there's lens of course.
13:33:33 <dminuoso> If you recall, lenses are just coalgebras for the costate comonad.
13:33:40 <dminuoso> So lots of coco there.
13:34:32 * tabaqui is blushing
13:34:54 <tabaqui> one day I will dive deep into lenses
13:35:12 <tabaqui> I used only one simple template from microlens package before
13:35:56 <tabaqui> afaik, you don't need lenses if you have no complex business logic with many nested structures
13:36:47 <dminuoso> tabaqui: It depends, being able to use then through the MonadReader interface is really convenient.
13:37:04 <dminuoso> tabaqui: And you get a lot of composable behavior that is easy to reason about.
13:37:20 * hackage bazel-coverage-report-renderer 0.1.0 - HTML Coverage Reports for Rules_Haskell  https://hackage.haskell.org/package/bazel-coverage-report-renderer-0.1.0 (SebastianKazenbrootGuppy)
13:37:48 <tabaqui> like "gets (^. someField)"?
13:37:57 <tabaqui> yeah, that's what I did
13:38:52 <dminuoso> tabaqui: I guess nested data structure or wide sum types (or some combination thereof) can be eased with lenses.
13:39:51 * hackage data-combinator-gen 0.1.0.1 - Generate a special combinator from any data type.  https://hackage.haskell.org/package/data-combinator-gen-0.1.0.1 (bolt12)
13:42:20 * hackage lapack 0.3 - Numerical Linear Algebra using LAPACK  https://hackage.haskell.org/package/lapack-0.3 (HenningThielemann)
14:07:51 * hackage polysemy-plugin 0.2.0.0 - Disambiguate obvious uses of effects.  https://hackage.haskell.org/package/polysemy-plugin-0.2.0.0 (isovector)
14:49:21 * hackage quickcheck-classes 0.6.2.1 - QuickCheck common typeclasses  https://hackage.haskell.org/package/quickcheck-classes-0.6.2.1 (chessai)
14:55:39 <dminuoso> :t \f -> foldr f -- pie__ 
14:55:41 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
14:55:46 <dminuoso> :t \f -> foldl (flip f) -- pie__ 
14:55:48 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
15:41:18 <reallymemorable> Is there an opposite to `mconcat`?  I want to turn something back into a list for a particular operation.
15:42:03 <infinisil> :t mconcat
15:42:05 <lambdabot> Monoid a => [a] -> a
15:42:07 <Solonarv> reallymemorable: not in general, no
15:42:45 <reallymemorable> hmm ok
15:45:02 <MarcelineVQ> not in general = depends on the something. so with more information you might get another answer
15:45:35 <reallymemorable> https://gist.github.com/reallymemorable/449670b5cbfb7a8162542a9a0dd4e803
15:45:59 <[exa]> reallymemorable: someone told me that there are anti-associative comonoids, which might be interesting for that purpose
15:48:51 <MarcelineVQ> this problem just needs fmap yeah?
15:49:18 <Solonarv> [exa]: yeah, but there aren't any non-trivial ones in Haskell
15:49:53 <Solonarv> class Comonoid a where
15:49:53 <Solonarv>   consume :: a -> ()
15:49:53 <Solonarv>   split :: a -> (a, a)
15:49:56 <MarcelineVQ> fmap (\(PaymentTerms x y) -> ...dostuff...) testIntervalMap
15:50:08 <Solonarv> obviously we can implement this for every type
15:50:55 <[exa]> Solonarv: becomes interesting with linearity though
15:51:01 <Solonarv> this is interesting if (for example) you have linear types - then Comonoids are exactly those things you can freely duplicate and throw away
15:51:11 <Solonarv> hey, you said that while I was typing my thing! :P
15:51:15 <[exa]> :]
15:51:30 <[exa]> "the connection is striking"
15:51:54 <[exa]> anyway, monoid seen from the linearity perspective is even better, "almost-contraction" and "default construction"
15:52:55 <reallymemorable> ok so i should just fmap in?
15:53:01 <reallymemorable> inside the mconcat
15:56:16 <MarcelineVQ> That's not the response I expected, I seem to have not understood the problem. "I need to do some transformations on each of the first values of `PaymentTerms` based on each of the second arguments." Which second argument are you referring to?
15:56:45 <royal_screwup21> what does ::= mean in haskell?
15:57:13 <reallymemorable> MarcelineVQ: i am trying to normalize the values
15:57:24 <reallymemorable> so for example if i am trying to look at something on an annual basis
15:57:32 <reallymemorable> i want to take any weekly periods and multiply by 52
15:57:52 <reallymemorable> and if i want to look on a weekly basis at an annual value, i need to prorate it
15:59:11 <glguy> royal_screwup21: It means whatever you define it to mean, it's just another operator symbol
15:59:37 <glguy> Because it starts with :, as a value it's a constructor
15:59:39 <MarcelineVQ> And to do this do you just need the values of a PaymentTerms?
16:00:34 <MarcelineVQ> or do you need the Points from the IntervalMap as well?
16:01:09 <reallymemorable> yes i need each of the values of PaymentTerms
16:01:36 <reallymemorable> and these exist in a list of tuples, the snd of which is PaymentTerms
16:14:57 <mac10688> i finally found my way back lol
16:16:38 <mac10688> is there an easy way to filter on constructor?
16:17:39 <mac10688> I have a data type with multiple constructors and I want to filter on one of the constructors but right now I have to make a new function and do pattern matching or an anonymous function with case statement
16:19:16 <infinisil> :t (\v@(Left _) -> v)
16:19:17 <lambdabot> Either a b -> Either a b
16:19:18 <infinisil> mac10688: ^^
16:19:27 <infinisil> Just put the constructor where Left is
16:19:41 <mac10688> thanks!
16:21:16 <MarcelineVQ> > (\v@(Left _) -> v) (Right 3) -- :O
16:21:18 <lambdabot>  *Exception: <interactive>:3:2-17: Non-exhaustive patterns in lambda
16:21:54 <infinisil> Ah
16:22:00 <infinisil> That was stupid sorry
16:22:16 <infinisil> mac10688: ^
16:23:20 <MarcelineVQ> > (\x -> [v | Left v <- x]) [Right 3, Left 2] -- depends what you're filtering, comprehensions are a cheeky way when you have a list
16:23:22 <lambdabot>  [2]
16:24:00 <Solonarv> mac10688: you can write the lambda-with-case very succintly using the LambdaCase extension: (\case Left x -> blah; Right y -> something)
16:24:39 <mac10688> checking it, yeah i tried the first example and I didn't get an error, but I got nothing at all lol
16:24:48 <Solonarv> (\case <stuff>) is the same as (\a -> case a of <stuff>), btw
16:25:36 <fresheyeball> join #haskell
16:25:39 <fresheyeball> ugh
16:25:43 <fresheyeball> hey out there
16:25:45 <MarcelineVQ> don't do it!
16:25:49 <mac10688> ok i like the lambda case extension
16:26:01 <fresheyeball> I want to have a phantom type that can be of any kind
16:26:03 <fresheyeball> possible?
16:26:21 <fresheyeball> newtype Ohm (e :: k) (a :: *) = Ohm a
16:26:35 <fresheyeball> foo :: Ohm 'Nothing Int
16:26:47 <jle`> fresheyeball: what's stopping you? :)
16:26:49 <fresheyeball> foo :: Ohm (Maybe Int) Int
16:27:15 <fresheyeball> I get "Expected a type, but Nothing has a kind of (Maybe a)
16:27:31 <fresheyeball> I enabled PolyKinds
16:27:49 <hpc> DataKinds?
16:27:55 <jle`> % newtype Ohm (e :: k) (a :: *) = Ohm a
16:27:57 <hpc> or is that implied? i forget
16:27:58 <fresheyeball> that too
16:29:01 <jle`> it seems to work fine on my ghci
16:29:06 <MarcelineVQ> fresheyeball: works here :X try a fresh session?
16:29:07 <jle`> maybe you're using a really old ghc ?
16:29:14 <fresheyeball> 8.4.3
16:29:34 <jle`> can you paste some code reproducing this
16:30:42 <jle`> because copying and pasting what you already wrote seems to work fine for me :)
16:31:02 <fresheyeball> Is there an only haskell playground?
16:31:19 <fresheyeball> found one
16:31:21 <fresheyeball> sec
16:34:16 <jle`> here is what i am testing out btw
16:34:17 <jle`> https://repl.it/repls/SnowBrightSnake
16:34:28 <fresheyeball> jle`: yeah I can't get it to reproduce
16:34:47 <jle`> does that mean everything works as expected? :)
16:35:00 <jle`> maybe a solar ray flipped a stray bit the one time that it didn't work
16:35:04 <fresheyeball> no I still have to figure this out
16:38:10 <fresheyeball> yeah I don't get it
16:38:56 <fresheyeball> if I make it (e :: k) I get the error about expecting a type
16:39:13 <fresheyeball> if I make it (e :: Exchange) I get no error about passing the datakind
16:39:27 <fresheyeball> in repl.it I can't reproduce, it gives no error
16:41:14 <jle`> if (e :: k) then it could be that some other operation is causing it to kind-infer k ~ Type
16:41:29 <jle`> for example you might be storing multiple Ohm's in a list
16:41:38 <jle`> and within that list all of the Ohms must have the same type (so the same kind)
16:42:20 <jle`> try making the kind variable explicitly applied, so you can spot where specialization might be happening
16:42:27 <jle`> newtype Ohm k (e :: k) (a :: *)
16:42:40 <jle`> then you should be able to do foo :: Ohm (Maybe Bool) 'Nothing Int
16:42:55 <jle`> later on when you spot the bug you can remove the kind variable
16:42:56 <fresheyeball> smart!
16:43:22 <jle`> but yeah, my guess is that kind inference is causing some sort of monomorphisation into Type, if you have Ohm's interacting with each other
16:43:33 <fresheyeball> oh interesting
16:43:36 <fresheyeball> so I added the k
16:43:42 <jle`> remember that Ohm is poly-kinded, not existentially kinded
16:43:44 <fresheyeball>     Variable ‘k’ used as both a kind and a type
16:43:46 <fresheyeball>     Did you intend to use TypeInType?
16:44:00 <jle`> ah yeah you probably have to turn on TypeInType, import Data.Kind, change * into Type
16:44:31 <jle`> but yeah, Ohm is poly-kinded, not existentially kinded, so you can't, say, have a list of [foo :: Ohm 'Nothing Bool, bar :: Ohm 'True Bool]
16:45:34 <jle`> or if you ever do something with an `Ohm a a`, that'll infer k ~ Type
16:45:49 <jle`> or also if you ever write a Bifunctor instance, then k ~ Type within that instance
16:45:57 <jle`> those are all my guesses :)
16:46:24 <fresheyeball> actually that is ton of work to do
16:47:49 <fresheyeball> ha!
16:47:51 * hackage fltkhs 0.8.0.2 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.8.0.2 (deech)
16:47:54 <fresheyeball> there is only one problem call site
16:48:04 <fresheyeball> the others that use this work the way I expect
16:48:11 <fresheyeball> so yeah specialization somehow
17:04:21 * hackage fltkhs-themes 0.2.0.2 - A set of themed widgets that provides drop in replacements to the ones in FLTKHS.  https://hackage.haskell.org/package/fltkhs-themes-0.2.0.2 (deech)
17:10:19 <mac10688> Anyone want to code review this small project that is related to a company assessment and tell me what they think? https://github.com/mac10688/Ontellus_Haskell
17:11:04 <mac10688> Just added a description
17:12:32 <Axman6> You might be interested in facebook's duckling package
17:14:40 <mac10688> Possibly! I notice that everyone always puts language extensions on each file instead of like in the cabal file or package.yaml. Is it some kind of best practice to put it in each file?
17:20:51 <fresheyeball> I figured it out!
17:20:55 <fresheyeball> a type annotation works
17:21:01 <fresheyeball> but a type application doesn't
17:27:25 <jle`> fresheyeball: ah, it might be because there's an implicit kind variable
17:27:32 <jle`> fresheyeball: you might have to do Ohm @_ @'Nothing Int
17:27:45 <jle`> or Ohm @(Maybe *) @'Nothing Int
17:52:18 <Axman6> mac10688: yeah it's usually considered better practice, so you don't have to hunt to another file to see what's being used in it
18:05:51 * hackage hw-balancedparens 0.2.0.3 - Balanced parentheses  https://hackage.haskell.org/package/hw-balancedparens-0.2.0.3 (haskellworks)
18:09:58 <monochrom> Also different files benefit from different extensions.
18:10:20 <monochrom> In fact lately it is recognized that even different instances benefit from different extensions.
18:12:48 <monochrom> Oh! hw = haskellworks, not hardware.
18:13:06 <monochrom> Was wondering why we need hardware-accelerated balancing of parens. :)
18:14:01 <monochrom> "NVidia announces a new PBPU containing 2000 cores."
18:48:58 <libertyprime> Data is meant to be for generic programming, according to hoogle. Though this looks like a struct to me, types specified now. I am a noob. Could someone briefly tell me why this is generic programming
18:49:02 <libertyprime> vim +/"data Val = Int Integer" "https://raw.githubusercontent.com/acmeism/RosettaCodeData/master/Task/S-Expressions/Haskell/s-expressions.hs"
18:53:31 <libertyprime> i think i was mixing up the data keyword and the data module
19:06:03 <monochrom> Right.
20:35:48 <iqubic> It is dead in here.
20:48:07 <oni-on-ion> everyone stuck in nirvana
21:13:42 <Axman6> IRC is for discussing problems, and we don't have those in Haskell
21:13:48 * Axman6 this is not true
21:16:33 <oni-on-ion> the thought crossed my mind, reflecting on the most silent of the channels within which i reside =) 
21:16:42 <oni-on-ion> i happen to*
21:18:32 <oni-on-ion> some discussion; the camel is getting some things called "continuations" -- we may know of them from common lisp. "Extending OCaml’s type system with algebraic effects would make it similar to Haskell’s, but without requiring monads for effects." hmmm ^_^
21:18:50 <oni-on-ion> did not know this of haskell , must be an extension ?
21:19:02 <Axman6> why people gotta be so scared of monads
21:19:27 <Axman6> if we just called them "Effects" people would be like "oh hey, that's a really simple idea"
21:20:37 <maerwald> We could call them... burritos... badum-tss
21:20:45 <MarcelineVQ> or continuations
21:20:50 <maerwald> or boxes
21:20:51 <maerwald> or..
21:20:58 <maerwald> categories! endofunctors!
21:21:03 <Axman6> Callback'yProcessors
21:21:08 <maerwald> Promises
21:21:23 <oni-on-ion> 'Effects' , sounds alright. to me they were simple to learn when doing IO monad 
21:22:12 <oni-on-ion> associated with I/O is clear enough. but anyway. Axman6 the point isnt to avoid monads. i dont think fear of them is related to the upcoming feature of ocaml
21:22:51 * hackage netlib-comfort-array 0.0.0.1 - Helper modules for comfort-array wrappers to BLAS and LAPACK  https://hackage.haskell.org/package/netlib-comfort-array-0.0.0.1 (HenningThielemann)
21:22:57 <oni-on-ion> but i understand the pride. i'd like to add - http://lambda-diode.com/programming/monads-are-a-class-of-hard-drugs
21:31:54 <ski> oni-on-ion : hm, upcoming feature ?
21:32:13 <oni-on-ion> ski, yeah - https://ocamlverse.github.io/content/future_ocaml.html
21:32:17 <ski> i thought there already was an implementation of delimited continuations in OCaml ?
21:32:21 * hackage blas-comfort-array 0.0.0.2 - Auto-generated interface to Fortran BLAS via comfort-array  https://hackage.haskell.org/package/blas-comfort-array-0.0.0.2 (HenningThielemann)
21:32:28 <ski> or perhaps this is about making it more officially supported ?
21:32:28 <oni-on-ion> ski, yep a seperate fork i think
21:32:46 <oni-on-ion>  http://okmij.org/ftp/continuations/implementations.html 
21:33:30 <oni-on-ion> some food - https://gist.github.com/NicolasT/3789670 - (i havent used them much myself in HS)
21:33:34 <ski> "a bookmark to the current position of the execution (aka continutation) added to each “exception” (aka effect) thrown, so one has the option to continue execution after handling the effect." -- reminds me of restartable conditions in the Lisps
21:34:39 <ski> adding an effect system to OCaml would be interesting .. especially if it could also handle continuation effects
21:35:17 <gentauro> MarcelineVQ, I like contniuations ... wasn't it Filinski who showed that all monads could be written with CPS?
21:35:49 <oni-on-ion> ski, and its through the type system =) 
21:36:04 <oni-on-ion> gentauro, that makes sense 
21:36:24 <ski> oni-on-ion : yes, that's what i meant by "adding an effect system"
21:36:30 <oni-on-ion> late-eval vs. eager-eval makes a difference for CPS though 
21:37:22 <ski> gentauro : he showed that given delimited/composable continuation *side*-effects, and any implementation of a monad (like in Haskell), you could "reflect" that monadic effect into a *side*-effect
21:37:36 <ski> see his "Reflecting Monads" paper
21:37:41 <ski> Andrzej Filinski
21:39:22 <ski> oni-on-ion : lazy vs. eager, you mean ?
21:40:03 <oni-on-ion> ski, yep sry
21:41:34 <ski> i assume you mean that there's different versions of the CPS transformation, encoding different evaluation strategies for the source program, into the target program
21:42:32 <ski> so that, regardless of the strategy used to evaluated the target program, that evaluation will "mimic" either by-name or by-value evaluation (depending on which CPS transformation version was used) of the source program
21:45:07 <oni-on-ion> i'd imagine that lazy-eval is in-out order, where eager is out-in ?
21:46:47 <ski> more or less the opposite
21:48:03 <ski> first. there's normal order vs. applicative order
21:48:18 <ski> applicative order reduces both `E' and `E0' to say `\x0. E1' and `v0', and then continues by reducing `E1[x0 |-> v0]'
21:48:20 * hackage lapack-comfort-array 0.0.0.1 - Auto-generated interface to Fortran LAPACK via comfort-array  https://hackage.haskell.org/package/lapack-comfort-array-0.0.0.1 (HenningThielemann)
21:48:46 <ski> normal order reduces only `E' to `\x0. E1', leaving `E0' be, and then continues by reducing `E1[x0 |-> E0]'
21:48:59 <oni-on-ion> ah, yeah =) 
21:49:35 <ski> also, both will reduce `\x0. E1' (which doesn't have to be applied to anything) by reducing `E1' : iow, they reduce under lambda !
21:50:08 <ski> now, call-by-value and call-by-name are the same, except they don't reduce under lamba
21:50:43 <ski> specifically, by-value will also reduce `E' to `\x0. E1' and `E0' to `v0', then continue by reducing `E1[x0 |-> v0]'
21:51:12 <ski> and by-name will only reduce `E' (to begin with, at least), leaving `E0' alone, continuing by reducing `E1[x0 |-> E0]'
21:51:42 <ski> however, because `x0' may occur multiple times inside `E1', this may amount to duplicating the work of reducing `E0'
21:52:00 <ski> if `x0' occurs zero times, then `E0' will not be performed at all, that's the upside
21:53:20 <ski> so by-value, and applicative order, will both always reduce an actual parameter, an argument expression, to a value (weak head normal form), given an application that is being reduced. and the argument will be reduced exactly once
21:54:33 <ski> while with by-name, and normal order, the argument may be reduced zero times, or more than once, in addition to the possibility of reducing it once. also this reduction may happen long after the reduction of the current application has finished (becaue `x0' may occur inside `E1' hidden behind lambdas or other delaying constructions)
21:55:43 <ski> so, by-need, aka lazy reduction, is an optimization on by-name, namely instead of reducing `E1[x0 |-> E0]', we reduce `let x0 = E0 in E1', and we reduce this by ignoring the `x0 = E0' part initially, continuing already with `E1'
21:56:18 <ski> then, *if* reduction of `E1' requires reduction of `x0', then `E0' will bw reduced, to say `v0', and we will then continue reduction from `let x0 = v0 in E1'
21:56:52 <ski> so, the next time reduction of `x0' is required, we can now simply fetch the cached result `v0', instead of having to reduce `E0' again
21:57:41 <ski> so, `let x0 = E0 in ...' here expresses allocating a thunk named `x0', bound to the computation `E0', such that if/when it is demanded, the reduction of it will be cached
21:58:12 <ski> of course, we also need a garbage collection rule that in `let x0 = E0 in E1', if `E1' doesn't mention `x0' anymore, we can simplify this to just `E1'
22:01:05 <ski> hm .. there was some paper which went into this, but now i can't recall the title/author .. :/
22:04:36 <oni-on-ion> eager v. lazy? ^_^
22:05:15 <babita666> hi
22:05:24 <babita666> anyone online ?
22:05:47 <babita666> Hello !
22:06:08 <babita666> hello
22:06:13 <babita666> Anyone here ?
22:06:19 <babita666> No ones replying !
22:06:25 <babita666> Can you see my message ?
22:06:34 <babita666> Say yes or No atleast
22:06:38 <babita666> Hey
22:06:39 <babita666> Ho
22:06:41 <babita666> Hi
22:06:45 <babita666> Hello
22:06:46 <babita666> Voila
22:06:48 <babita666> Hulo
22:06:51 <babita666> Halo
22:06:55 <babita666> bonjour
22:06:58 <glguy> babita666: stop that
22:06:58 <babita666> konnichiva
22:07:15 <babita666> No i will not cuz im a fucking bot
22:08:33 <oni-on-ion> ski, "Note that monadic and applicative notations will be directly supported by the compiler itself starting from 4.08." sooner than i thought (the prev. link said 'medium-term') 
22:11:20 <iqubic> Can we ban this username? I don't care if they are a bot or not
22:11:47 <iqubic> Saying hello again and again is not productive.
22:12:56 <oni-on-ion> neithr is swearing 
22:14:53 <Axman6> Swearing has been shown to reduce the perception of pain so can be productive
22:16:35 <ski> oni-on-ion : hmm .. which notations would that be, i wonder ?
22:18:52 <ski> iqubic : they're already gone, though
22:19:29 <ski> (and they're not even registered ..)
22:21:19 <iqubic> Oh. I see.
22:21:47 <iqubic> I have my IRC client set-up to hide joins an parts from my view.
22:22:20 <iqubic> So I literally didn't know that they left.
22:22:45 --- mode: ChanServ set -q *!*@2001:b07:6461:5d8a:a4ca:8ba:4448:d03b
22:25:02 <jle`> i just figuratively didn't know
22:25:54 <bahamas> is there a solution that generates tags for identifiers not defined in the project? when I say tags, I mean ctags, etags, etc.
22:26:43 <MarcelineVQ> I knew all along.
22:29:01 <oni-on-ion> Axman6 =) 
22:30:58 <ski> oni-on-ion : so, where was that quote from ?
22:35:21 * hackage hmm-lapack 0.4 - Hidden Markov Models using LAPACK primitives  https://hackage.haskell.org/package/hmm-lapack-0.4 (HenningThielemann)
22:46:01 <oni-on-ion> ski, https://discuss.ocaml.org 
22:52:04 <oni-on-ion> ski, more here; lost the original thread: https://discuss.ocaml.org/t/an-intermediate-abstraction-between-applicatives-and-monads/3441/4 
22:52:44 <oni-on-ion> ski, here:  https://discuss.ocaml.org/t/opam-package-ocaml-monadic/3828/3
22:56:12 <bahamas> can anyone help me understand the typeclass definition here: https://github.com/tweag/inline-java/blob/494a37a9956eb1ed47dcf3706799e2dbf0252e13/jvm/src/Language/Java.hs#L177? does it say that the type synonym family Ty a needs to have a `SingI` instance?
22:58:38 <ski> oni-on-ion : ty
22:58:57 <oni-on-ion> np
22:59:46 <ski> bahamas : yes. the associated type synonym `Ty a'
23:01:09 <ski> perhaps it would have been nice to alternatively be able to write `class Coercible a where {type Ty a :: JType; instance SingI (Ty a); ...}' (but meaning the same thing)
23:02:18 <bahamas> ski: and `JType` is the kind of `Ty a`. I assume that kind can be defined when DataKinds is enabled. I'm only used to the * kinds
23:03:08 <ski> yes, presumably `DataKinds'
23:04:46 <bahamas> ok. thanks!
23:07:31 <ski> np
23:13:20 * hackage simple-cmd-args 0.1.2 - Simple command args parsing and execution  https://hackage.haskell.org/package/simple-cmd-args-0.1.2 (JensPetersen)
23:30:30 <bahamas> anyone know how can Haskell records be represented in Java?
23:32:10 <dminuoso> bahamas: Roughly they correspond to classes in Java.
23:32:35 <bahamas> dminuoso: I see. thank you
23:32:41 <dminuoso> bahamas: And values of data records correspond to instances, roughly.
23:33:23 <dminuoso> bahamas: Note that you cant encode sum types that way though. I dont know enough about Java how to encode that, or whether its even possible.
23:35:19 <bahamas> dminuoso: I just need to provide a Java representation for a Haskell record. I'm trying to navigate this file basically https://github.com/tweag/inline-java/blob/master/jvm/src/Language/Java.hs#L177
23:36:49 * ski . o O ( "java-adt: A tool to create immutable algebraic data structures and visitors for Java (such as abstract syntax trees)." by Andreas Abel at <https://github.com/andreasabel/java-adt> )
23:36:59 <bahamas> btw, what does the 'Type syntax mean? I assume it's enabled by an extension
23:37:07 <ski> also cf.
23:37:10 <ski> @where BNFC
23:37:11 <lambdabot> BNF Converter, http://bnfc.digitalgrammars.com/
23:37:37 <ski> dminuoso ^
23:38:23 <dminuoso> ski: Ah so I remember that in C++ you would use the visitor pattern to semantically implement sum types too, just wasn't sure about Java. Thank you, Ill take a look at it.
23:40:21 * hackage bbi 0.1.1 - Tools for reading Big Binary Indexed files, e.g., bigBed, bigWig  https://hackage.haskell.org/package/bbi-0.1.1 (kaizhang)
23:41:20 * hackage bioinformatics-toolkit 0.8.0 - A collection of bioinformatics tools  https://hackage.haskell.org/package/bioinformatics-toolkit-0.8.0 (kaizhang)
23:42:13 <ski> dminuoso : i also believe the Java version of "Modern Compiler Implementation in (ML|Java|C) by Andrew W. Appel in 1998 at <https://www.cs.princeton.edu/~appel/modern/> uses the VisitorPattern <http://wiki.c2.com/?VisitorPattern>
23:42:46 <ski> (not sure whether the C version uses `switch'es on `struct' of `enum' tag and `union', or perhaps something else)
23:44:57 <oni-on-ion> nearly identical =)
23:45:29 <ggole> https://www.cs.princeton.edu/~appel/modern/c/chap4/absyn.h
23:46:15 <ski> nice
23:47:06 <ski> (i notice it `typedef's pointers. apparently several people dislike that. i'm not quite sure why)
23:54:38 <ggole> typedefing structs is also commonly frowned on
23:55:00 <ggole> C programmers seem to like to know what it is they're working with, in a narrow operational sense
23:56:59 <ski> yes. i'm not so sure on why, though
23:57:41 <ski> perhaps they want to be able to tell at a glance, whether it's possibly a large object, or a small one
23:59:46 <ski> however, they do `typedef' function pointers (i wonder whether `typedef'ing functions would make more sense, then). but that's presumably because of the awkward (inverted, and also mixfixed) syntax
