00:26:21 * hackage classify-frog 0.2.4.2 - Classify sounds produced by Xenopus laevis  https://hackage.haskell.org/package/classify-frog-0.2.4.2 (HenningThielemann)
01:10:23 <dcoutts_> Phyx-: ok, cool. The discussions I'd been reading previously about the I/O manager involved people worrying that we'd need to issue the I/Os from special threads, incurring more context switches, due to the thread termination issues.
01:22:59 <qwebirc12887> good day, noble coders
01:23:51 <qwebirc12887> cannot install with ghcup on Mac OS Yosemite, getting this message: Failed to create temporary directory "ghcup --cache install" failed!
01:24:07 <qwebirc12887> can someone comment ?
01:34:28 <simg> Hi, I wonder if anyone could help me with trying to get zip-conduit to build using stack? have pasted the errors here: https://gist.github.com/simg/fa00f8781f1c947e144a075d975953bf
01:35:49 <simg> I suspect 2 of the errors are caused by deprecated types no longer having instances. the conduit library says "Deprecated: "Use ConduitT directly"  - but I have no idea what this would look like 
01:36:18 <f-a> I am more worried about the UnliftIO
01:38:06 <hvr> simg: looks like zip-conduit doesn't have accurate metadata
01:38:36 <simg> ok, am I using the wrong approach? I have a large csv inside a zip file which I'd like to be able to process in constant memory but I'm not attached to using conduit or zip-conduit
01:38:44 <f-a> simg: would zip-stream do?
01:39:08 <f-a> seems better maintained
01:39:31 <hvr> simg: cassava does have support for constant-memory streaming   http://hackage.haskell.org/package/cassava
01:40:17 <hvr> simg: sorry, nevermind; wrong format
01:40:34 <simg> <hvr> I've bumped the version numbers to get this "far"
01:40:55 <qwebirc12887> cannot install with ghcup on Mac OS Yosemite, getting this message: Failed to create temporary directory "ghcup --cache install" failed!
01:41:02 <qwebirc12887> can someone comment ?
01:43:16 <hvr> simg: have you looked at http://hackage.haskell.org/package/zip 
01:43:47 <simg> <f-a>zip-stream might do, but I was put off by the lack of examples. but maybe I'd be better off manning up and working it out?
01:44:02 <hvr> tbh, zip-archive doesn't look well maintained
01:44:18 <hvr> s/zip-archive/zip-stream/
01:44:22 <f-a> yeah, pending pull requests, etc.
01:44:34 <hvr> (zip-archive is ok; but it doesn't support streaming well)
01:45:25 <simg> hvr: ah, yes. I'm already using "zip". didn't realise it would work with conduit.
01:46:06 <hvr> I'd actually prefer if `zip` was not tied to conduit :-)
01:46:35 <hvr> and be more agnostic to the streaming framework 
01:47:18 <hvr> but if you don't mind using conduit, then `zip` sounds like the best choice here
01:47:29 <simg> I'd like to be agnostic to the streaming framework, but I'm using cassava which works with conduit, so ...
01:47:44 <f-a> qwebirc12887: if no Mac users chime up, try filing a ticked on ghcup repo, they seem quick in replying
01:47:51 <hvr> cassava *is* agnostic to the streaming framework
01:48:15 <hvr> it doesn't depend on any of pipes/conduit/io-stream/machines/streaming
01:48:46 <simg> in which case what would you suggest for zip -> csv -> custom type?
01:49:17 <hvr> there is however a cassava/conduit adapter
01:49:21 <hvr> as a separate package
01:49:40 <hvr> but I can't say anything about its quality as I don't use conduit
01:50:03 <hvr> http://hackage.haskell.org/package/cassava-conduit
01:50:18 <simg> hvr: what do you use for streaming? and why not conduit - I have no idea, obviously ;) 
01:51:10 <hvr> depends on the use-case; sometimes I don't use any "streaming framework" at all; just plain IO or lazy lists; sometimes I go for io-streams, sometimes I might go for pipes
01:51:21 <hvr> recently I've been toying with `streaming`
01:52:58 <simg> I'm currently at more of a "I don't care, I just want it to work, now" stage in the process :)
01:53:18 <hvr> in that case, just try the combination of `zip` and `cassava-conduit`; maybe it works out :-)
01:53:45 <simg> any reason why you don't use conduit?
01:57:16 <hvr> partly because I prefer the more principled design of `pipes`, partly because the conduit ecosystem is poorly maintained
01:57:39 <hvr> and tends to bitrot due to that
01:57:53 <hvr> so it's not something I like to depend on 
01:58:44 <simg> cool, thanks. I'll have a look into pipes too
01:59:15 <hvr> if you are familiar with conduit, pipes will look quite similar
01:59:20 <hvr> but it's subtly different in places
02:00:03 <hvr> the other frameworks I mentioned, streaming/io-streams/machines are less close in terms of API structure
02:01:49 <simg> "familiar" would be overstating to say the least
02:04:51 * hackage elminator 0.0.0.0 - Generate ELM types/encoders/decoders from Haskell types.  https://hackage.haskell.org/package/elminator-0.0.0.0 (sras)
02:05:26 <Phyx-> . 
02:13:00 <Franciman> hi qwebirc12887 do you have the latest ghcup version?
02:29:50 * hackage hlint 2.1.22 - Source code suggestions  https://hackage.haskell.org/package/hlint-2.1.22 (NeilMitchell)
02:34:50 <ocramz> hullo!
02:36:21 * hackage extra 1.6.16 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.6.16 (NeilMitchell)
02:37:53 <Rembane> Good morning ocramz 
02:38:10 <qwebirc12887> ?
02:38:47 <qwebirc12887> I run this command: sudo curl https://get-ghcup.haskell.org -sSf | sh
02:39:04 <f-a> Franciman: 
02:39:06 <Franciman> ok qwebirc12887 
02:39:08 <Franciman> let me see
02:39:26 <qwebirc12887> as it mentioned here https://www.haskell.org/ghcup/
02:40:47 <qwebirc12887> tried without sudo first, same result
02:42:06 <Franciman> if you run: mkdtemp -d
02:42:08 <Franciman> what happens?
02:42:41 <qwebirc12887> usage: mktemp [-d] [-q] [-t prefix] [-u] template ...        mktemp [-d] [-q] [-u] -t prefix
02:42:50 <Franciman> err sorry
02:42:51 <Franciman> I meant
02:42:53 <Franciman> mktemp -d
02:43:11 <qwebirc12887> MacBook-Pro-Spike:haskell koto$ mktemp -d usage: mktemp [-d] [-q] [-t prefix] [-u] template ...        mktemp [-d] [-q] [-u] -t prefix
02:43:20 <Franciman> so I guess this is the problem
02:43:22 <qwebirc12887> just prints out the help
02:43:41 <Franciman> it wants to run mkdtemp -d, but probably on OS X it has a different syntax
02:44:09 <qwebirc12887> looks logical =)
02:44:25 <qwebirc12887> any workarounds?
02:44:37 <Franciman> hm I would surely open an issue on github
02:44:50 <Franciman> temporary workaround? We need to edit the ghcup script
02:45:26 <qwebirc12887> this is the official way to get started with Haskell on OS X =)
02:45:52 <qwebirc12887> I have such bad karma to get started with opening an issue =)
02:46:08 <Franciman> there is a posix version of mktemp
02:46:16 <Franciman> one second
02:46:57 <lavalike> qwebirc12887: a workaround is  brew install coreutils  and then change every instance of  mktemp  with  gmktemp  in the script
02:47:20 <Franciman> no there isn't. You just need to add the missing argument to mktemp
02:47:24 <Franciman> hi lavalike!
02:47:27 <lavalike> hey (:
02:47:47 <qwebirc12887> lavalike: are you sure? =)
02:48:07 <lavalike> qwebirc12887: Imma go with a straight YES
02:48:11 <qwebirc12887> I can try, will my laptop go boom or not? )
02:48:26 <jgt> qwebirc12887: I don't understand the discussion; you want the above linked script to work, and you're checking if `mktemp` works
02:48:43 <Franciman> qwebirc12887, if you don't want to install other software, there is an alternative
02:48:51 <jgt> qwebirc12887: unless I'm blind and my vim search doesn't work, `mktemp` is not even in that script
02:49:03 <qwebirc12887> it's not working with just '-d', it wants some arguments right after
02:49:04 <Franciman> jgt, line 1581
02:49:12 <lavalike> jgt: it downloads *another* script which makes use of it, checks if it is there too, but not if it has the right options: https://gitlab.haskell.org/haskell/ghcup/raw/master/ghcup
02:49:21 <jgt> lavalike: oh right
02:49:38 <lavalike> the joys of  curl ... | sh
02:49:52 <Franciman> qwebirc12887, you just need to provide something like this: "${TMPDIR:-/tmp}"/ghcup-tmp.XXXXXXXX
02:50:05 <Franciman> it wants a template to generate the tmpdir filename
02:50:43 <jgt> ah ok, so this then: https://unix.stackexchange.com/a/84980/69014
02:50:47 <qwebirc12887> "${TMPDIR:-/tmp}"/ghcup-tmp.XXXXXXXX -bash: /var/folders/yc/kjnp0xvx6t1_vlcz1nxxbrnh0000gn/T//ghcup-tmp.XXXXXXXX: No such file or directory
02:51:24 <Franciman> wut
02:51:29 <Franciman> can I see the edited ghcup?
02:51:37 <Franciman> wait
02:51:56 <qwebirc12887> ok ok no hurry at all
02:53:10 <qwebirc12887> I was informed that in Haskell we always want 'principal' way, not fast way =)) I thought it begins when inside already though =))
02:54:28 <Franciman> qwebirc12887, https://bpaste.net/show/e04039585ef4
02:54:45 <Franciman> can you run this script? I PROMISE I WON'T HACK THE WORLD
02:54:51 <Franciman> it's just the ghcup script edited
02:55:03 <Franciman> you need to run it as if it was ghcup
02:55:46 <Franciman> you can check the diffs
02:55:57 <qwebirc12887> MacBook-Pro-Spike:haskell koto$ chmod a+x e04039585ef4.sh  MacBook-Pro-Spike:haskell koto$ ./e04039585ef4.sh  -bash: ./e04039585ef4.sh: /bin/sh^M: bad interpreter: No such file or directory
02:56:01 <qwebirc12887> lol
02:56:05 <Franciman> hmmm
02:56:08 <Franciman> why
02:56:36 <qwebirc12887> if I'll just change it to bash, will it work or not?
02:56:46 <Franciman> you just need to remove the ^M character, I guess
02:56:57 <Franciman> it should work, yes
02:58:06 <qwebirc12887> there is no ^M in code, I've manually erased end of line and added again
02:58:13 <qwebirc12887> same problem with bash
02:58:34 <Franciman> can you show me your ghcup executable?
02:58:38 <Franciman> (it is a script)
03:00:31 <qwebirc12887> https://gist.github.com/kotoOo/2da62b989bc721c53f19207fcc1f068d
03:01:21 <qwebirc12887> I've just got it from curl address (https://get-ghcup.haskell.org/)
03:01:51 <Franciman> ah ok
03:01:53 <Franciman> now I see
03:04:10 <lavalike> ^M is \r, the windows line break extra character
03:07:04 <ocramz> how do we pass flags to dependency packages? In the ghc-options field of a cabal file? e.g. `ghc-options: -Wall -O2 -f openblas`
03:07:13 <ocramz> aren't flags namespaced?
03:08:04 <qwebirc12887> lavalike: wow, it works! thx!
03:08:32 <qwebirc12887> ok now I have that script working, should I use it instead of ghcup?
03:09:31 <lavalike> yeah
03:14:30 <qwebirc12887> Done installing, run "ghci-8.6.3" or set up your current GHC via: e04039585ef4.sh set 8.6.3
03:14:40 <qwebirc12887> MacBook-Pro-Spike:haskell koto$ ghci-8.6.3 -bash: ghci-8.6.3: command not found
03:14:51 <qwebirc12887> ? =|
03:17:36 <f-a> qwebirc12887: ghci ?
03:17:47 <f-a> qwebirc12887: you should really open a ticket
03:18:56 <qwebirc12887> MacBook-Pro-Spike:haskell koto$ ghci -bash: ghci: command not found
03:20:41 <qwebirc12887> I am very newbie to Haskell, so before making issues I should understand what is normal and what is not...
03:21:15 <f-a> this is an installation problem though, not Haskell itself
03:22:10 <qwebirc12887> yep
03:23:48 <qwebirc12887> is ghcup written in Haskel btw?
03:25:34 <f-a> that script is in bash!
03:34:39 <qwebirc12887> https://gitlab.haskell.org/haskell/ghcup/issues/99
03:35:10 <qwebirc12887> hope this'll make the world better =)
03:40:37 <Franciman> back
03:40:47 <Franciman> qwebirc12887, how did you solve?
03:57:54 <qwebirc12887> Franciman: installed ghci and cabal with your script, then added ~/.cabal/bin ~/.ghcup/bin to /etc/paths
03:58:10 <Franciman> cool
03:59:03 <qwebirc12887> thank you so much!
04:00:41 <lamba> hello, does anyone know if it's possible to have ghcjs compiling ghcjs so that we can run the compiler in the browser?
04:01:05 <zincy> lamba: yes it is possible
04:01:26 <lamba> zincy: has anyone done it already?
04:01:29 <zincy> oh wait run the compiler in the browser
04:01:53 <zincy> There is an experiment Haskell -> WASM compiler called Asterius
04:01:58 <zincy> *experimental
04:02:20 <zincy> lamba: I haven't seen it been done before
04:03:07 <lamba> mmm maybe I can get ghcjs compiled to c to run under emscripten or something?
04:03:35 <jgt> is there a nicer way to do this in aeson?
04:03:36 <zincy> What is your end goal?
04:03:37 <jgt> let comparisonId = parseMaybe (\v -> (withObject "conversion" $ \o -> o .: "comparison_id") v) req
04:03:52 <jgt> assuming `req` is some Value
04:03:55 <lamba> have a client side haskell repl in the browser 
04:04:21 <ibloom> What is the state of the art for getting and setting from arrays with lenses?
04:04:42 <cocreature> ibloom: ix
04:04:45 <zincy> repl.it has a Haskell repl in the browser actually
04:05:04 <lamba> yes but it's connected to a server which does the computing
04:05:20 <zincy> oh is it?
04:05:29 <zincy> hmm you have an interesting challenge
04:05:37 <lamba> yes that's why sometimes you have to wait for it to run
04:06:40 <ibloom> cocreature: it seems like ix changed in more modern versions of lens.
04:06:53 <ibloom> Maybe I'm reading it wrong.
04:07:09 <c_wraith> lamba: why would you not try to get it compiling with ghcjs?
04:07:22 <c_wraith> lamba: though really, your trouble is going to be library code.
04:07:29 <lamba> zincy: look at sketch.sh a haskell version would be really nice
04:07:42 <jgt> ok, this is a start: let comparisonId = parseMaybe (withObject "c" $ \o -> o .: "comparison_id") req
04:07:55 <lamba> c_wraith: that's what i'm thinking, just asking to see if it would be repeated work
04:08:03 <cocreature> ibloom: changed how?
04:08:22 <zincy> lamba: Oh fun
04:09:23 <lamba> trying to figure out how difficult this would be to see if it's worth doing
04:09:25 <cocreature> even if you do manage to compile ghcjs with ghcjs, which I expect to be a fairly complex undertaking, the slowdown compared to native GHC is probably going to be significantly large that shipping your code to a server is cheaper
04:10:38 <lamba> I don't think compiling small programs will take that long even if the compiler is now much slower 
04:10:54 <ibloom> Cocreature: I see, it looks like I just need to define and instance of class Ixed for my index newtype.
04:12:01 <lamba> if you look at sketch.sh the output is immediate, compared to for example cocalc's free haskell jupyter notebooks which can take a long time to provide you with resources 
04:12:23 <zincy> I don't know if this is enough context but is it possible to have an index function for a fixed length vector which doesn't take just a (Finite n) indexing param but a (SomeFinite)
04:13:01 <zincy> so index :: SomeFinite -> Vec n a -> a 
04:13:13 <zincy> where SomeFinite ~ Finite n
04:17:08 <lamba> cocreature: also being client side is not just about speed, it also means the code is not shared with an unkown server and someone could bookmark the page and even work offline. Much simpler than getting ghcjs locally
04:17:40 <lamba> plus can work on mobile offline too
04:18:08 <cocreature> lamba: sure there are definitely advantages to being client side. I’m just not sure it’s going to work particularly well for the case of ghc/ghcjs
04:18:54 <c_wraith> libraries are the real problem
04:18:56 <cocreature> I’d love to be proven wrong here though :)
04:19:34 <cocreature> c_wraith: how so? If you manage to compile ghcjs to js, I don’t see why you couldn’t bundle a couple of libraries with it
04:20:01 <c_wraith> the problem is that "a couple of libraries" just won't satisfy.  I want hundreds
04:20:45 <cocreature> depends on what your goal is, repl.it also has a fairly small set of libraries and people seem to find it useful
04:21:18 <cocreature> if you want to move all of your Haskell development to a webbrowser than sure a small set of libraries is not going to cut it
04:21:44 <libertyprime> is there a way to make stack install a little less fussy? http://ix.io/1K10
04:23:06 <lamba> yes libraries are a separate issue. cabal in the browser? :p
04:27:56 <lamba> also worried about the size of the resulting compiler 
04:49:20 * hackage floskell 0.10.1 - A flexible Haskell source code pretty printer  https://hackage.haskell.org/package/floskell-0.10.1 (ecramer)
04:52:30 <sm> libertyprime: it's designed to be fussy, so you know things will compile. You can follow the recommendation (declare gogol-core 0.4.0 as an extra-dep, since it's no in stackage yet)
05:10:11 <libertyprime> sm: cheers. good explanation
05:39:01 <sm> \o/
05:39:41 <f-a> sup sm
05:39:48 <sm> morning f-a
05:39:57 <sm> how's lentil going
05:40:10 <f-a> currently programming the ascii-platformer :P
05:40:20 <sm> ooh fun how's that going
05:40:53 <f-a> nice, I am learning much which is what I was interested in. I can build custom levels and adding monsters as now
05:42:44 <sm> sweet.. needs a browser-playable version like allureofthestars
05:48:15 <gentauro> is there a fancy way to implement `fromList :: [a] -> Tree a` with the following logic -> `fromList [ 0, 1, 2 ] == Node 0 (Node 1 Leaf Leaf) (Node 2 Leaf Leaf)`?
05:53:40 <ggole> Convert to an array and use the usual methods for that?
06:10:23 <yogeshagr> Hi all, I want to learn Haskell. Where should I start? Could anyone please suggest a good resource/book. Thank you! :)
06:10:52 <f-a> hello yogeshagr 
06:11:11 <lavalike> yogeshagr: http://www.cis.upenn.edu/~cis194/spring13/lectures.html
06:11:18 <f-a> I suggest https://www.seas.upenn.edu/~cis194/fall16/index.html
06:11:21 <f-a> =D
06:11:24 <lavalike> haha
06:11:26 <f-a> well done lavalike 
06:12:03 <f-a> yogeshagr: free, clear, thorough on foundamentals, made by a very good haskeller
06:14:02 <yogeshagr> f-a: lavalike Thank you very much. I am a devops engineer and have never done any functional programming. So am I right to to learn haskell? Is this resource good for naive like me
06:14:16 <lavalike> can't recommend it highly enough
06:14:24 <f-a> indeed indeed
06:15:46 <ski> yogeshagr : perhaps you'd like a textbook as well
06:16:10 <yogeshagr> f-a: lavalike okay thank you! Could you also suggest a good book for haskell which I can buy and read it offline
06:16:21 <ski> @where PIH
06:16:21 <lambdabot> "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
06:16:27 <lavalike> +1
06:16:37 <ski> "Haskell: The Craft of Functional Programming" by Simon Thompson
06:17:07 <ski> @where SOE
06:17:07 <lambdabot> "The Haskell School of Expression: Learning Functional Programming through Multimedia" by Paul Hudak in 2000 at <http://www.cs.yale.edu/homes/hudak/SOE/>,<http://haskell.org/soe/> [broken]
06:17:18 <lavalike> a meta-suggestion: if you're ever bored with one resource just drop it and pick another, the trick is being bored with a particular text not with the enterprise of learning the subject in of itself
06:18:14 <ski> @where HR
06:18:14 <lambdabot> "The Haskell Road to Logic, Maths and Programming", by Kees Doets,Jan van Eijck, at <http://homepages.cwi.nl/~jve/HR/>
06:18:24 <ski> @where wikibook
06:18:24 <lambdabot> http://en.wikibooks.org/wiki/Haskell
06:18:27 <ski> @where HTAC
06:18:27 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
06:18:35 <ski> @where WYAH
06:18:36 <lambdabot> "Write You a Haskell" (unfinished) by Stephen Diehl in 2015- at <http://dev.stephendiehl.com/fun/>
06:19:11 <lavalike> randomly browsing the haskell wiki is also bound to find some intriguing pages
06:19:24 <ski> depending on your inclination, you might like some of those more interesting than others
06:19:42 <ski> i've heard many recommend Hutton
06:19:51 <ski> i learned from Thompson
06:20:07 <ski> s/like some/find some/
06:20:48 <ski> yogeshagr : also, you're welcome to ask in here, when you get questions
06:20:52 <lavalike> oh here's another idea: going through something like https://adventofcode.com and trying to solve it w/ the language you're interested in, haskell in this case, is a lot of fun
06:21:31 <lavalike> bouncing back and forth between reading and typing is a strong way to go about it
06:21:54 <bontaq> advent of code with haskell was tons of fun
06:24:31 <yogeshagr> ski: lavalike That's a lot of good info. Thank you! I will get started and ask questions here, when I get stuck or in case of doubts :)
06:37:20 * hackage interpolation 0.1.1.1 - piecewise linear and cubic Hermite interpolation  https://hackage.haskell.org/package/interpolation-0.1.1.1 (HenningThielemann)
06:38:02 <lavalike> f-a: the '16 version is so much more fun than the one I had bookmarked, dang
06:38:30 <f-a> yeah they made a new iteration which feels even better
06:38:40 <f-a> Joachim & co, good work
06:44:22 <jaexil-gilroy-ma> http://downtownbrooklyn.com/listings/atlantic-terminal-mall
07:16:24 <libertyprime> am i right to say that this returns a side effect? http://ix.io/1K1X how would you read this type signature?
07:17:09 <nisstyre> libertyprime: the type signature is generic
07:17:19 <nisstyre> it could return any instance of Monad
07:17:20 * hackage hw-excess 0.2.1.0 - Excess  https://hackage.haskell.org/package/hw-excess-0.2.1.0 (haskellworks)
07:17:32 <nisstyre> the actual definition returns IO ()
07:17:54 <nisstyre> s/definition/use of it/
07:18:08 <lavalike> libertyprime: a nice enough way to talk about values of type Monad m => m a is "action", so the second parameter returns an action m b for each of the elements a of the foldable t a, and they get composed together in the returned action m ()
07:18:36 <lavalike> (more specifically  m a  being the type of actions in the monad m that produce the value a, I guess)
07:22:55 <libertyprime> cheers guys. i will meditate on this
07:23:24 <maerwald> never understood the "actions" metaphor :>
07:23:30 <lavalike> your intution is on the right track anyway, because you can'd do much with the returned value of type IO () beside evaluating it and producing the effect of writing things out
07:23:45 <lavalike> you also get get a () out of it, what a bargain!
07:24:13 <libertyprime> ahh nice :) that is reassuring
07:24:49 <libertyprime> () is basically haskell's nil, right?
07:24:53 <nisstyre> no
07:24:53 <lavalike> yeah
07:24:58 <nisstyre> I would disagree
07:25:06 <lavalike> "unit", a type with a single value
07:25:13 <nisstyre> traditional "null" can be any type
07:25:18 <nisstyre> that's not what () is
07:25:31 <lavalike> (not "nil" in the Go sense, or "NULL" in the C sense, that's different)
07:25:35 <nisstyre> undefined is more like nil/null IMO
07:26:49 <maerwald> undefined is something you should never have in your code. 'nil' is something actually used in other languages
07:27:03 <nisstyre> nil is something you should never have in your code either :p
07:27:08 <maerwald> that is false
07:27:18 <nisstyre> Tony Hoare would agree I think
07:27:34 <maerwald> try writing Go code then
07:27:40 <nisstyre> I'd rather not
07:27:59 <libertyprime> i just quit my go job. mainly because of go
07:28:13 <lavalike> () is like an empty tuple, it only has that one value, (), itself
07:28:16 <maerwald> And then jump to haskell? :>
07:28:32 <maerwald> (in fact, I did that too lol)
07:29:19 <libertyprime> yeah im on a mission to learn haskell and a few other things. i feel like im in good company anyway
07:29:20 <maerwald> I like the attitude of Go programmers though. Just not the language too much.
07:29:46 <lavalike> it doesn't give consumers of values of type () a whole lot to go with, in that it's similar to nil, is what I meant
07:29:59 <lavalike> gives you the least information
07:30:09 <nisstyre> lavalike: sure but your program won't crash because it tried to use ()
07:30:15 <nisstyre> the compiler will know where you used it
07:30:52 <nisstyre> not so true with null
07:31:02 <lavalike> > show (undefined :: ()) -- >:)
07:31:05 <lambdabot>  "*Exception: Prelude.undefined
07:31:28 <nisstyre> that's exactly what I said
07:32:32 <nisstyre> > () :: ()
07:32:34 <lambdabot>  ()
07:32:46 <nisstyre> it knows the type of () is ()
07:32:49 <nisstyre> no ambiguity
07:33:30 <nisstyre> undefined/nil/null/etc can pop up anywhere and you will never be able to detect it
07:37:27 <jaexil-gilroy-ma> https://nyulangone.org/locations/nyu-langone-health-cobble-hill
07:37:38 <jaexil-gilroy-ma> https://www.downstate.edu/contact.html
07:48:50 * hackage elminator 0.1.0.0 - Generate ELM types/encoders/decoders from Haskell types.  https://hackage.haskell.org/package/elminator-0.1.0.0 (sras)
07:51:14 <monochrom> maerwald: What is the attitude of Go programmers such that you like it?
07:53:30 <maerwald> they value simplicity and composable libraries
07:54:14 <maerwald> and API stability
07:58:43 <monochrom> I like those too. But less insistent on stability. Because there cannot be any stability to speak of unless you are solving a solved case-closed problem (which sounds like an oxymoron now doesn't it).
08:00:26 <nisstyre> API stability just means many versions of the API
08:00:38 <nisstyre> which means more code to maintain
08:01:01 <nisstyre> or it's perpetually in a badly designed state
08:03:05 <monochrom> Well I have cross swords with maerwald and I think he even means not even many versions.
08:07:50 * hackage line-bot-sdk 0.5.1.0 - Haskell SDK for LINE Messaging API  https://hackage.haskell.org/package/line-bot-sdk-0.5.1.0 (moleike)
08:14:46 <maerwald> monochrom: it's not very difficult if you leave out experimentation, don't change types around and focus on bugfixing not edge use cases
08:15:05 <maerwald> people sometimes would rather create a new library instead of overhauling API if existing ones
08:15:22 <maerwald> or... just *add* new API
08:18:02 <bahamas> can anyone help me understand this error message? https://bpaste.net/show/dbb004068604 the error message makes me think that the Interp instance for ByteString is not picked up. here is more context https://github.com/tweag/inline-java/blob/494a37a9956eb1ed47dcf3706799e2dbf0252e13/jvm/src/Language/Java.hs#L540
08:19:48 <monochrom> But what about Interp Session?
08:19:57 <bahamas> actually, the second error says what's wrong, but I don't know how to handle this situation. I need to add a `Json.decode` so that I turn the bytestring into my `Session` object. the problem is that `decode` returns Maybe
08:20:20 <f-a> bahamas: maybe? a case?
08:20:25 <f-a> :t maybe
08:20:27 <lambdabot> b -> (a -> b) -> Maybe a -> b
08:20:34 <monochrom> I think of Maybe as a solution, not a problem.
08:20:44 <bahamas> sorry, I don't  understand what you mean
08:21:00 <monochrom> It solves the problem of "what if there is a parse error?"
08:21:23 <bahamas> monochrom: I agree with you, but I don't know how to handle this situation
08:21:38 <f-a> bahamas: pattern match with a case
08:21:45 <monochrom> Maybe is an extremely simple algebraic data type. What do you do to all algebraic data types?
08:22:16 <bahamas> f-a: doesn't instance Reify Session need to return a Session from the function?
08:24:34 <bahamas> it does https://github.com/tweag/inline-java/blob/494a37a9956eb1ed47dcf3706799e2dbf0252e13/jvm/src/Language/Java.hs#L481
08:32:40 <zincy> maerwald: "people sometimes would rather create a new library instead of overhauling API if existing ones" - Yep this is why computers are slow
08:32:52 <monochrom> haha
08:33:22 <zincy> We have had Moore's law for decades and boot times are still bad
08:36:17 <monochrom> But I believe maerwald means "value" not "moral abolute".
08:37:28 <maerwald> zincy: I don't think so
08:37:34 <monochrom> Even I just say "less insistent" not "completely lax"
08:39:46 <monochrom> I think I just put more thoughts on domains that have serious open problems (open problems of "what should the API look like?"), and maerwald and Go programmers face domains with closed problems all the time.
08:40:52 <monochrom> For example I think "what should a Haskell streaming API look like?" is still an open problem. There cannot be peace there.
08:40:54 <maerwald> Also not sure how you came to that conclusion
08:41:21 <monochrom> But you would be right about "why are you people keep changing your string API".
08:41:32 <maerwald> You can create a library with an attempt so solve it. But then why would you redesign the entire approach in the same library? 
08:42:04 <monochrom> Yeah I'm OK with calling it a new library giving it a new name.
08:42:27 <maerwald> There is no technical challenge here, it's mostly just attitude about how to approach APIs
08:42:47 <maerwald> stable APIs have trade-offs too
08:43:20 <oni-on-ion> zincy, ssd/save state
08:43:42 <zincy> what does that mean?
08:45:24 <oni-on-ion> zincy, faster boot times
08:45:32 <zincy> ah ok
08:46:58 <oni-on-ion> my system is old and is just over 10 second somewhere but with ssd and modern non-bios would be near instant (like my tablet where its never a cold boot unless battery loss)
08:50:02 <zincy> Go programmers *value* simplicity ... 
08:50:38 <zincy> Simplicity comes from abstraction which they seem to disdain
08:51:00 <maerwald> zincy: so lens is simple?
08:51:19 <zincy> Nope
08:52:07 <maerwald> I don't know. It's hard to talk about it anyway, unless you have programmed in both languages
08:52:27 <zincy> Programmers that try to fight abstraction at the language level push the complexity from the language into their libraries. 
08:52:48 <maerwald> abstraction itself can also introduce complexity
08:53:21 <zincy> abstraction is a double edged sword right
08:53:41 <maerwald> and the discussions about language features in Go are controversial
08:53:55 <maerwald> It's not like everyone agrees that not having proper sum types is bad
08:54:13 <maerwald> If you follow the issue tracker
08:54:25 <zincy> not sure I understand
08:54:36 <petercommand> maerwald: How's not having a sum type a good thing?
08:54:48 <maerwald> "Programmers that try to fight abstraction at the language level push the complexity from the language into their libraries" -- this is simply not true for the Go community as a whole
08:54:49 <zincy> maerwald didnt say that
08:55:09 <petercommand> *sum types
08:55:38 <zincy> maerwald - where does the complexity go?
08:55:47 <petercommand> zincy: perhaps I didn't phrase my question properly
08:55:49 <maerwald> zincy: what do you mean?
08:56:27 <monochrom> What have I done? :)
08:56:29 <petercommand> I mean, what are the reasons that people have against having sum types in a programming language?
08:56:46 <maerwald> petercommand: check the issue tracker
08:56:54 <petercommand> maerwald: link?
08:57:07 <maerwald> https://github.com/golang/go/issues/19412
08:57:16 <petercommand> thanks
08:57:57 <zincy> "there's no pressing need" for sum types in Go. Even C has them 
08:57:59 <maerwald> zincy: my point was that it's a misrepresentation of the go community to say that they (as a community) are fighting abstraction
08:58:40 <zincy> maerwald: interesting, I am happy to be wrong 
09:01:04 <zincy> maerwald: Thanks for the interesting discussion, perhaps I need to eschew my preconceptions about the Go community
09:01:41 <maerwald> well, I would guess most people just look at the language and derive things about the community based on the language
09:01:48 <maerwald> which is often not very true
09:02:10 <maerwald> like... all haskellers are elitist academics ;)
09:02:14 <monochrom> Yeah! I know right?
09:02:37 <zincy> but we are
09:03:38 <monochrom> One may take a look at System.IO.Unsafe.unsafePerformIO and start imagining things about Haskell programmers!
09:04:06 <zincy> monochrom: what kinds of things?
09:04:36 <f-a> hubris
09:05:03 <zincy> i like that word
09:09:05 <maerwald> you mean haskellers are good sales people who lie a little bit about the illusion of purity? :>
09:09:37 <maerwald> and once you buy into it you probably won't even notice it was a lie
09:11:51 <zincy> its not really an illusion
09:18:50 <int-e> hrm, that moment when cabal v1-install finds a viable plan and cabal new-install does not.
09:19:24 <maerwald> do they use the same hackage file?
09:22:57 <int-e> I think so, but for v1-install there's a sandbox with add-source involved while for new-install there's a cabal.project file. So it's hard to be sure.
09:24:06 <maerwald> check if they are at the same commit then
09:25:35 <int-e> it's the same checked out repository :P
09:28:43 <maerwald> also note that cabal.project can pin the ghc version...
09:29:23 <int-e> well, pushing max-backjumps to 5000 helps. --reorder-goals also helps. whatever.
09:30:12 <int-e> maerwald: none of that is happening: https://github.com/lambdabot/lambdabot/blob/master/cabal.project
09:32:47 <maerwald> interesting, can reproduce
09:35:54 <iqubic> When will we have dependant haskell?
09:36:20 <monochrom> When Richard Eisensberg's PhD student graduates. >:)
09:36:26 <Solonarv> heh
09:36:30 <iqubic> Fair. Fair.
09:36:35 <Solonarv> less facetious answer: there's no known timeline
09:36:47 <Solonarv> basically, "when it's done"
09:36:50 <iqubic> Has there been any work on it?
09:36:58 <Solonarv> yes
09:37:06 <iqubic> What sort of work?
09:37:15 <iqubic> And why is this sort of thing so hard?
09:37:33 * maerwald mumbles something about simplicity =)
09:37:37 <Solonarv> efforts towards Dependent Haskell that have already made it into GHC include TypeInType, and a handful of GHC proposals
09:38:11 <int-e> iqubic: why wouldn't it be hard?
09:38:36 <int-e> . o O ( if you think it's easy you should go ahead and implement it... )
09:39:06 <monochrom> Yeah, either that, or put money where your mouth is: Offer a bounty.
09:39:44 <monochrom> Anyway I drew from a long string of history to say that PhD theses have to be involved.
09:40:01 <c_wraith> there are two big reasons it's hard:  1) GHC's intermediate core language doesn't have the necessary features.  Part of the project is implementing (and proving correct) a new intermediate language with dependent typing.  2) It has to maintain the same quality of type inference that GHC haskell already has. 
09:40:55 <zincy> monochrom: unless you do it in the uk
09:41:27 <c_wraith> And those are on top of the ever-present hard part in any big change:  syntax bikeshedding.  So much syntax bikeshedding.
09:41:33 <monochrom> A hot-plugin system got done because dons had to hand in a PhD thesis.  Backpack got done because ezyang had to hand in a PhD thesis.  And Dependent Haskell is such a tall order, even one PhD thesis (Eisensberg) could only describe what it would look like.
09:41:51 <zincy> wow
09:42:39 <monochrom> The downside of this system is also evident from history.
09:43:04 <monochrom> dons hot-plugin system gets bitrotten after he graduated.
09:43:09 <c_wraith> ....  irc username, irc username, last name.  Do only people who complete their changes to ghc get to go by irc username? :P
09:43:31 <monochrom> Backpack may be not bitrotten yet but when was the last time you heard of it?
09:44:16 <monochrom> Oh I just can't remember Eisensberg's irc name. Patches welcome.
09:45:15 <c_wraith> It's either goldfire or goldfirere.  He uses both names in various places, and I don't recall which he's used here.
09:45:37 <goldfire>   ^ this one
09:48:00 <int-e> maerwald: oh interesting detail: without the sandbox, cabal v1-install --dry-run lambdabot*/  also fails to find a plan.
09:49:05 <c_wraith> that suggests the sandbox had a combination of packages that doesn't get backtracked to
09:49:53 <int-e> or just that the search tree is different
09:50:30 <c_wraith> either way, it's a heuristic search failure because no one wanted exponential exact searches
09:50:50 * hackage rattletrap 6.4.0 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-6.4.0 (fozworth)
09:52:59 <int-e> c_wraith: I get different install plans with and without the sandbox. Fun!
10:20:22 <monochrom> Polynomial-time approximations are fun.
10:24:13 <MarcelineVQ> How fun are they would you guess?
10:59:41 <MarcelineVQ> Trying to navigate the javascript mdn really makes me appreciate haddocks/hackage
11:08:12 <shapr> MarcelineVQ: that's how I felt about trying to dig up Go modules, I'm happy hackage collects libs in one place
12:03:14 <dmrd_> folks, is there a special language pragma for annotating record-style data declarations with type variables?
12:03:14 <dmrd_> Something a la
12:03:14 <dmrd_> ```
12:03:14 <dmrd_> data Foo = Foo {bar :: Maybe a}
12:03:14 <dmrd_> ```
12:03:14 <dmrd_> Can't seem to get GHC to be happy about the typevariable `a`
12:04:04 <MarcelineVQ> do you know how would you write that without record syntax?
12:06:07 <dmrd_> Hmmm, I'm blanking out right now. I've gotten quite used to record syntax. No, I forget. But I can look it up
12:06:33 <dmrd_> I think its just a separate function for each record-style accessor
12:06:43 <dmrd_> w/ pattern-matching on the datatype
12:06:55 <dmrd_> oh wait, I think I see it now
12:07:54 <dmrd_> ah yes, I needed to make `Foo` into `Foo a`, I think
12:08:03 <MarcelineVQ> yep
12:08:08 <dmrd_> thanks :)
12:08:52 <ski> each type variable must be bound somewhere
12:09:06 <ski> it wasn't totally obvious where, and how, you wanted to bind `a' there
12:09:38 <ski> (though one could offer an educated guess)
12:09:43 <ski> dmrd_ ^
12:11:05 <dmrd_> yeah you're right. I think switching back to non-record syntax made it obvious that `a` needed to be bound somewhere. I'm still fighting through a couple compiler errors but I believe I primarily just needed to add the `a` after `data Foo`. So `data Foo a`.
12:11:17 <monochrom> Yeah
12:26:32 <Hot_Blonde_98> Meet girls that are looking to get fucked tonight in your Area. EXCLUSIVE SITE! If you don't find a GIRL TO FUCK, we will pay you 500 Dollars! ---> http://split.to/I7sBMjl :)
12:49:16 <EmilKarlson> wow, such classic
12:56:09 <blackandblue> lol
12:56:24 <blackandblue> damn it. that made me horny
13:17:29 <ski> (it's generally better to ignore spam, not commenting on it)
13:25:57 <nisstyre> that almost seems like fake spam
13:26:02 <nisstyre> spam spam
13:27:43 <spoonm> blackandblue: did the idea of getting $500 for free turn you on?
13:28:19 <blackandblue> spoonm: ofc. what do you think, getting girl would turn me on? meh.
13:33:21 <fufler> Hello everyone. I'm trying to understand example for *or* function in this article https://en.wikibooks.org/wiki/Haskell/Denotational_semantics#Pattern_Matching. It says: «The first equation for or matches the first argument against True, so or is strict in its first argument». How this function can be strict when this `or False (undefined :: Bool) == False` evaluates to True?
13:37:37 <Solonarv> fufler: it is strict *in its first argument*
13:38:20 <Cale> mpickering: What's up with the decision regarding haskell-src-exts? Just don't have time for it?
13:38:30 <Solonarv> that means if you pass in ⊥ as the first argument, you get back ⊥ - it doesn't say anything about what happens if you pass ⊥ as the second argument
13:42:56 <Solonarv> so "or is strict in its first argument" means 'or undefined x = undefined' for any x
13:43:52 <fufler> Solonarv, my mistake. My example was wrong. But anyway, shouldn't `or (undefined :: Bool) True == False` evaluate to False for strict in first argument function?
13:44:17 <Solonarv> well no, it doesn't evaluate to False
13:44:45 <Solonarv> (or undefined True == False) --> (undefined == False) --> undefined
13:44:49 <mpickering> Cale: It is very hard to maintain as faithfully reimplementing the updates to the parser is time consumer and hard to get right
13:45:16 <mpickering> Most PRs are not quite right in some way or diverge from how GHC parses things
13:45:42 <mpickering> and I would rather spend my time on other projects
13:45:50 <fufler> @Solonarv, but why `or undefined True` evaluates to False then?
13:45:50 <lambdabot> Unknown command, try @list
13:45:51 <mpickering> I have done the releases for the last 4 years I think
13:46:06 <Solonarv> fufler: it doesn't evaluate to False, where did you get that idea?
13:46:20 <fufler> Solonarv, ghci
13:46:21 <Solonarv> > undefined || False
13:46:22 <Cale> mpickering: Makes sense -- seems like it could be pretty brutal -- but it's still kind of sad to see it go.
13:46:23 <lambdabot>  *Exception: Prelude.undefined
13:46:32 <Solonarv> > undefined || True
13:46:34 <lambdabot>  *Exception: Prelude.undefined
13:46:56 <Solonarv> fufler: well, if that evaluates to False in your ghci you've probably done something wrong
13:47:07 <Cale> mpickering: Maybe what really needs to happen is that the GHC API needs to be organised in a way where it becomes much more reasonably usable.
13:47:41 <mpickering> I think it's already usable (spoken as a GHC developer)
13:48:32 <mpickering> hlint is now based on GHC's parser
13:48:39 <mpickering> which is why now is a good time to stop maintaining haskell-src-exts
13:55:45 <fufler> Solonarv, you're right. I've done something wrong (still don't know what exactly though). But now I've got this example. Thank you.
13:56:20 <Cale> I dunno, maybe this is somewhat unfair, but to me it has always come off as a big unstructured pile of modules, each of which is filled with abbreviated-beyond-recognition identifiers...
13:56:47 <Cale> There are so many type synonyms as well, that it's very hard to sort out what can be used with what
14:00:03 <Cale> ...and then you end up wanting to use something that takes a DynFlags...
14:00:50 <Cale> which is fine if you're working on GHC itself, because one of those things will be handy probably, but outside of the compiler itself, it's just kind of ridiculous
14:04:11 <mpickering> sure if you want to do anything with a module you need a `DynFlags`
14:04:23 <Cale> right
14:04:35 <mpickering> but that's necessary for correctness
14:04:45 <mpickering> you can't rename a module without knowing about the environment
14:05:28 <Cale> https://hackage.haskell.org/package/ghc-lib-parser-0.20190523/docs/DynFlags.html#t:DynFlags -- I'm not sure that *all* of this is really needed for every operation though.
14:05:58 <Cale> "Oh good, all I have to do is specify these... hundreds of things..."
14:06:41 <mpickering> the way to set up an environment is to query the build tool about which options it passes to ghc when it invokes it
14:06:43 <[exa]> there was something that was able to create relatively good default-looking dynflags from commandline options
14:06:59 <mpickering> you don't manually specify all the options in your program you reuse the options parser
14:07:33 <monochrom> IIRC there is a way to obtain a default, and it's a very reasonable default.  The only missing part you need to provide is path to GHC's lib directory.
14:07:53 <mpickering> [exa]: You call `parseDynamicFlags` on the arguments list
14:08:02 <monochrom> Ah yeah, that one.
14:08:04 <mpickering> making a GHC session is not that hard, if you have the right flags
14:09:03 <[exa]> mpickering: I actually wrapped it in runGhc and somehow terminated it, but yeah.
14:09:09 <monochrom> If you use hint you probably don't even have to worry about that path.
14:09:18 <Cale> I mean, sure, I know there's a way to make a GHC session (though I wouldn't have remembered it off the top of my head), but it feels like such a yak shave to go through in cases where probably only a tiny subset of those flags are really needed by the thing I'm trying to use.
14:10:05 <monochrom> To be sure, GHC API is still pretty big.
14:11:37 <[exa]> wouldn't it be, like, more correct from software-engineering perspective if ghc could output some kind of machine-readable parse tree?
14:11:49 <hxxxrz> im trying to get last but one element, why function (_:x:y:[]) = x doesn't work?
14:12:14 <Cale> (_:x:y:[]) matches a list of exactly 3 elements
14:12:24 <Cale> and x is its second element
14:13:15 <Cale> So it does work, but only for lists of exactly 3 elements ;)
14:13:39 <hxxxrz> so _ means only one element, is there a way to mark "all" elements?
14:13:43 <Cale> no
14:13:59 <Cale> It's only possible to pattern match the first element and a tail
14:14:08 <Cale> and you can do that as many times as you like
14:14:12 <hxxxrz> got it thank you!
14:14:13 <[exa]> hxxxrz: the problem is that lists have implicit parentheses, like _:(x:(y:[]))
14:14:32 <[exa]> so you can't easily match stuff at the end without knowing how many parentheses to open
14:16:17 <Cale> This is also a bit of a fundamental problem regarding what lists "are" in memory in some sense. There's no way to go directly to somewhere near the end of a list without following the chain of pointers along (and in the case of lazy lists, those are even pointers to code, as the tail of the list might not have been constructed yet)
14:16:21 <ski> hxxxrz : `_:x:y:[]' is the same as `[_,x,y]', btw
14:16:31 <Cale> hxxxrz: So you might want to write a function like:
14:16:36 <Cale> f [] = ...
14:16:38 <Cale> f [x] = ...
14:16:43 <Cale> f [x,y] = x
14:16:52 <Cale> f (_:xs) = f xs
14:17:15 <Cale> and I'm not sure what you want to do in the cases where there are 0 or 1 elements
14:17:47 <Cale> Of course, you can also just reverse the list, and pattern match on that
14:18:48 <[exa]> I like the responsibility of haskell people, never mentioning any integer-based solutions
14:19:43 <Cale> Fundamentally, getting the second last element of a list is not an operation that is natural on lists
14:19:54 <Cale> It's a bit like writing a loop which only does something on its second last iteration
14:20:58 <hxxxrz> so "xs" is just a value, it doesn't mean anything special?
14:21:05 <Cale> Yeah, it's a list value
14:21:21 <Cale> The convention is that lists are given plural names
14:21:29 <Cale> and so xs is the plural of x :)
14:21:41 <hxxxrz> cool, thanks
14:21:53 <sarahzrf> "exes"
14:22:03 <lavalike> it even scales, if you have a list of lists, its head could be xs and its tail xss (:
14:22:11 <sarahzrf> "exeses"
14:22:25 <sarahzrf> "excesses"
15:14:40 <iqubic> Polymorphism is one of the best things in Haskell.
15:56:55 <tty1> Is there some function that takes a maybe as an argument and returns True if it is Just * and returns False if it is Nothing ?
15:57:44 <c_wraith> > null Nothing
15:57:46 <lambdabot>  True
15:57:55 <c_wraith> :t null
15:57:57 <lambdabot> Foldable t => t a -> Bool
15:58:05 <c_wraith> tty1: Maybe is an instance of Foldable
15:58:15 <Solonarv> tty1: isJust if you want the monomorphic version
15:58:17 <Solonarv> :t isJust
15:58:18 <lambdabot> Maybe a -> Bool
15:58:27 <iqubic> Both work.
15:58:48 <tty1> hmmm
15:58:57 <tty1> thanks
16:29:01 <hans[m]4> hello is this function correct?
16:29:02 * hans[m]4 sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/AJcKCWJLCSzvhdAEMtZtFmqQ >
16:29:31 <hans[m]4> .
16:29:31 <hans[m]4> .
16:29:48 <hans[m]4> it does not seem like it returns a (Bool, String)
16:30:44 <jle`> hans[m]4: what do you mean by "correct"?
16:30:53 <jle`> we are aren't sure what you want it to do
16:31:03 <jle`> without more information on what you are expecting
16:31:21 <Solonarv> although I can tell you that it does indeed return a (Bool, String)
16:31:34 <Solonarv> (what makes you think it doesn't?)
16:31:45 <jle`> whether or not it outputs what you want it to depends on what you wanted it to output :)
16:33:18 <hans[m]4> im just asking a question, it's in a mooc i'm doing. its not obvious to me where it is returning a (Bool, String)
16:33:38 <jle`> do you know how to construct a tuple?
16:33:52 <jle`> the syntax for tuple construction is ( ???,  ??? )
16:33:54 <clever> :t (,)
16:33:56 <lambdabot> a -> b -> (a, b)
16:33:57 <hans[m]4> you mean the zip function?
16:34:02 <jle`> where the first thing is the first field of the tuple, and the second thing is the second field of the tuple
16:34:06 <jle`> hans[m]4: i mean, a value of type (a,b)
16:34:10 <clever> :t (,) 1
16:34:10 <jle`> for example:
16:34:11 <lambdabot> Num a => b -> (a, b)
16:34:16 <jle`> > (True, "hello")
16:34:18 <lambdabot>  (True,"hello")
16:34:22 <jle`> :t (True, "hello")
16:34:23 <lambdabot> (Bool, [Char])
16:34:35 <jle`> ^ that is the syntax for constructing a value of type (Bool, String)
16:34:54 <jle`> so to make a value of type (Bool, String), you type (thing1, thing2)
16:35:04 <jle`> where thing1 is the Bool you want to put in, and thing2 is the String you want to put in
16:35:14 <hans[m]4> i see but where does that appear? the function is ziping 2 strings to get the tuple
16:35:31 <clever> :t (,) <$> pure True <*> pure "foo" -- another crazy way of doing it
16:35:32 <lambdabot> Applicative f => f (Bool, [Char])
16:36:29 <Solonarv> hans[m]4: = (c `elem` word, [if ... ]) -- there is your tuple syntax
16:38:25 <hans[m]4> ah, i see it! was a bit confused by the list comprehension
16:39:17 <Solonarv> String is the same as [Char], i.e. a list of Char - so you can construct a String using a list comprehension
16:55:21 <hans[m]4> what are some popular haskell libraries or frameworks for web services?
16:56:46 <hpc> snap is pretty good
16:57:23 <hpc> there's another one that's specialized for writing rest apis, but i am totally blanking on the name of it
16:58:02 <Solonarv> servant ?
17:00:32 <hpc> ah yeah
17:08:18 <hans[m]4> thanks guys!
17:16:19 <jchook> quit
17:51:16 <alp> (FWIW: servant isn't just for REST apis, it's just the most common use for it)
19:08:20 * hackage servant-snap 0.8.3 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-snap-0.8.3 (imalsogreg)
19:48:20 * hackage flags-applicative 0.0.1.0 - Applicative flag parsing  https://hackage.haskell.org/package/flags-applicative-0.0.1.0 (mtth)
20:00:00 <sezycei> Hi all! I'm trying to make a very simple webapp that returns the client's IPv4 address and nothing else. Right now I'm using warp/wai, and I've hit a bit of a roadblock. How would you go about extracting the client IP using Haskell? You don't have to write the program for me - just curious if it sounds like I'm on the right path.
20:00:58 <c_wraith> sezycei: in general, it should be part of the request object the framework provides to you
20:01:46 <c_wraith> sezycei: https://hackage.haskell.org/package/wai-3.2.2/docs/Network-Wai.html#v:remoteHost is a good starting spot
20:02:27 <sezycei> c_wraith: Thanks a ton! I was definitely looking in the wrong place then, as I have spent the last three hours trying to extract it from requestHeaders. Thank you a ton!
20:05:00 <c_wraith> sezycei: to be fair...  If you have the server behind a reverse proxy, you will need to look for a header added by the proxy to know the original client's IP.  That's a common complication in real-world deployments
20:05:56 <sezycei> Yep, that's exactly something I'll be dealing with in this application - but I'll be writing it so I can get either the IP locally (no proxy) or from the X-Forwarded-For.
20:37:50 * hackage elminator 0.2.0.0 - Generate ELM types/encoders/decoders from Haskell types.  https://hackage.haskell.org/package/elminator-0.2.0.0 (sras)
20:50:01 <_sras_> Can someone please take a look at this Haskell => Elm code generator that I have written to address the pain points of the existing packages in that space..http://hackage.haskell.org/package/elminator-0.2.0.0
21:19:21 * hackage repa-scalar 4.2.3.3 - Scalar data types and conversions.  https://hackage.haskell.org/package/repa-scalar-4.2.3.3 (BenLippmeier)
23:54:21 * hackage flags-applicative 0.0.2.0 - Applicative flag parsing  https://hackage.haskell.org/package/flags-applicative-0.0.2.0 (mtth)
