00:03:53 <bahamas> geekosaur: hm, ok. I guess in the end I need to figure out what gradle actually wants
00:04:57 <bahamas> btw, how do you find out what package provides a certain module. for example that Setup.hs imports Distribution.Simple. how can I find out where that comes from?
00:05:42 <geekosaur> if it's installed, ghc-pkg find-module
00:06:03 <geekosaur> if it's not, you generally have to go digging on hackage or stackage (sigh. was easier when hayoo worked)
00:06:27 <Solonarv> although in this case I can tell you that it's from Cabal (the library)
00:08:16 <bahamas> thanks. indeed, `ghc-pkg find-module` returned cabal
00:08:29 <Solonarv> Cabal, not cabal
00:08:41 <Solonarv> package names are case sensitive
00:08:51 <bahamas> Solonarv: right. /Users/lucian/.ghcup/ghc/8.4.4/lib/ghc-8.4.4/package.conf.d
00:08:51 <bahamas>     Cabal-2.2.0.1
00:09:42 <[exa]> bahamas: btw it really seems like some part of java toolchain failed, did you check that ant/javac are the correct versions?
00:10:03 <bahamas> I wish PackageImports was more popular.
00:10:15 <bahamas> [exa]: where would I check that? I've never used java
00:10:28 <[exa]> lucky you
00:10:31 * geekosaur was wondering of this was actually something related to stack: possibly something obeyed stack's paths and did the gradle dir setup under .stack-work, but then gradle used standard paths instead
00:10:41 <[exa]> do you have 'javac' installed somewhere in the system?
00:11:14 <geekosaur> hm, but they recommend stack, so presumably not. but it's complaining about output dirs that don't exist
00:11:16 <bahamas> [exa]: I do, but I'm expecting this build process to use the javac inside a docker container. because I'm trying to run the build inside docker
00:11:32 <[exa]> oh so
00:11:38 <bahamas> I mean, I'm not trying. that's what I'm doing
00:12:25 <geekosaur> "Sparkle is not directly supported on non-Linux operating systems" but "/Users/..." suggests OS X
00:12:53 <bahamas> there might be a version mismatch. this project, sparkle, uses nix and pins an older version of nixpkgs. but that causes a stack version mismatch: 1.9.1 vs 1.7.1
00:13:18 <bahamas> geekosaur: yes. that's why I'm running inside docker
00:14:02 <geekosaur> https://github.com/tweag/sparkle#cant-build-sparkle-on-os-x
00:14:25 <geekosaur> hm, although the linked ticket isn't related to this
00:16:59 <bahamas> yes
00:17:55 <geekosaur> you might try simply creating the directories complained about in the bpaste
00:18:32 <geekosaur> actually just one directory, /Users/lucian/dev/juspay/sparkle/build
00:24:01 <bahamas> geekosaur: I tried, but I can't because of the build.gradle file. and I assume that if I change the name of that file, the build system won't find it anymore, because it's a standard name
00:25:14 <bahamas> although build and build.gradle are not the same thing. I don't know. I'm confused
00:25:46 <bahamas> yeah. it was because of BUILD
00:25:58 <geekosaur> ah
00:26:16 <geekosaur> yeh, that makes sense. I'd just rename that out of the way
00:40:11 <bahamas> yep. that's what I did
00:53:57 <asdf99> test
01:05:09 <littlefoxempress> Hello, I'm a newbie Programmer. o/
01:05:10 <littlefoxempress> Would Haskell be a good language to learn as my first and primary language? I know a bit of C, Java and Python, but only enough to build a little calculator.
01:10:08 <[exa]> littlefoxempress: "why not" :] haskell is a general purpose language as all others you mentioned, though somewhat surprising in certain aspects.
01:11:42 <[exa]> littlefoxempress: optimal way to start kindof depends on your background though (any formal experience with algorithms/data structures?)
01:12:19 <maerwald> littlefoxempress: difficult topic
01:12:37 <maerwald> imo, python is a better first language, but that's a very controversial topic
01:12:39 <littlefoxempress> I'm looking to get into AI, Nanotechnology and possibly game engines, so would Haskell be a suitable language for that?
01:12:50 <maerwald> game engines probably not
01:12:53 <[exa]> nanotechnology?
01:13:07 <maerwald> python is used for pretty much everything, especially AI and scientific topics
01:13:11 <maerwald> because it is easy to pick up
01:13:22 <Axman6> and easy to write poorly
01:13:35 <Axman6> which scientists seem to love
01:13:37 <merijn> I think python is a bad first language, because it teaches bad habits, but I also think "the best first language" is heavily dependent on the learner
01:13:38 <maerwald> haskell is more like a laser gun... you need a lot of time to develop the skill, before you can do anything useful
01:13:40 <littlefoxempress> Honestly, I have no idea how to get involved with nanotechnology. I might be in the wrong field for that.
01:13:45 <[exa]> Axman6: it _focuses on the result_ right? :]
01:14:11 <maerwald> it's important to pick something with low frustration level for your first language
01:14:18 <Axman6> nanotech is generally material science, and has very little to do with software
01:14:21 <[exa]> littlefoxempress: that's more of physics/chemistry and a lot of atom-scale simulations, but there are general tools for that.
01:15:15 <littlefoxempress> I am currently studying a Computing degree, but it's piss poor in comparison with what they're doing at Stamford afaik. 
01:15:15 <littlefoxempress> I'm supplementing it with the OSSU for CS on github.
01:16:46 <littlefoxempress> I just did a year of Java and I feel like I learned nothing :c
01:16:55 <[exa]> littlefoxempress: anyway your aims seem to benefit from a lot from readily available libraries, so focusing on python (and the libraries) seems like a good choice. Haskell is great if you want to do programming magic, which is not quite related to results with AI.
01:18:20 <littlefoxempress> I would rather not rely too heavily on the code of others if I can help it. That's why I mentioned game engines, as I would rather write my own than use what's available.
01:19:29 <[exa]> well, if you want to learn all bottom-up, C + Haskell is a good choice
01:22:09 <littlefoxempress> I'll try that then. I do believe in understanding over capability.
01:22:26 <[exa]> littlefoxempress: btw., "I would rather not rely too heavily on the code of others" is a good motivation but poorly implementable nowadays; you already rely on several million LOCs of people who write your OS's kernel and userspace, programming tools, ... :]
01:22:50 <merijn> Honestly, writing your own kernel and userspace isn't even that hard and undoable
01:22:59 <merijn> The real problem is lack of drivers
01:23:08 <[exa]> :]
01:23:11 <merijn> And reimplementing all existing drivers is a major PITA
01:23:26 <littlefoxempress> Mm, I'll just steal Linux drivers.
01:23:35 <littlefoxempress> Or something.
01:24:02 <merijn> littlefoxempress: The problem is that that only works if your kernel is, basically, linux, which considerably complicates and limits your freedom in implementing your kernel
01:25:12 <littlefoxempress> I'm not quite at that level just yet, so I'll just have to wait and let my knowledge accumulate. I'll be able to make better decisions then.
01:25:15 <merijn> littlefoxempress: Anyway, to be a bit more useful. Despite disliking Python, I have to say that if you want to reuse community code (especially in science/AI) you can't get away without it. On the other hand, I would say that Haskell is by far the most pleasant language to write things from scratch in, so if that's what you wanna do, I'd say do it :)
01:25:39 <[exa]> littlefoxempress: anyway, do you have any toy project?
01:26:53 <merijn> littlefoxempress: Alternative summary: Python makes getting something small working quickly easy, but building anything complex and big in Python is a major pain. On the other hand, in Haskell it can be incredibly hard to get over the hurdle of writing your very first succesful program, but once you can do that it becomes MUCH easier to tackle big/complicated problems (much bigger problems than I'd ever 
01:26:59 <merijn> consider working on if I only knew python/C)
01:27:03 <littlefoxempress> I have a couple. A little chatbot written in Chatscript, an Image Scraper in Python.
01:28:15 <[exa]> 'image scraper' as in e.g. 'making a searchable digest from a directory of images' ?
01:28:24 <littlefoxempress> And then I have weekly tasks as given by the courses on OSSU (look it up on github, it's basically a Foss CS degree)
01:28:52 <littlefoxempress> As in archiving all Japanese comic books on the internet.
01:31:36 <littlefoxempress> Right, I'm off to take my first exam!
01:31:48 <[exa]> littlefoxempress: that is quite imaginable in Haskell I guess
01:32:12 <littlefoxempress> It's systems Analysis and design, so I'm not very interested in it though.
01:36:51 <[exa]> anyway, what's the current best alternative for ggplot?
02:53:18 <maerwald> merijn: have you done larger projects in python?
02:53:47 <merijn> maerwald: Define larger
02:53:56 <maerwald> more than 3k LOC
02:54:13 <merijn> Then yes, because most of my phd project's infrastructure was python at some point
02:54:48 <merijn> But I've essentially eliminated all the python and replaced it with Haskell since (except for some extremely thin wrapper scripts around specific libraries which I run from haskell)
02:55:08 <maerwald> Ime, large python projects are fine. Large refactors are just not that of a good idea.
02:55:33 <maerwald> for some languages rewrite > refactor
02:55:37 <merijn> Honestly, as soon as Python goes over 1k LOC it becomes massively hard to get started on the codebase, refactor things, etc.
02:56:14 <maerwald> and you can make good points against refactoring as well
02:56:30 <merijn> Basically, for python, the bigger my code base grows the more I regret using Python. Meanwhile, Haskell is the opposite, the larger my codebase grows the happier I get with using haskell :)
02:59:12 <merijn> maerwald: Look, I'm not advocating getting rid of all existing python code, there are all sorts of pragmatic reasons people need it.
03:00:45 <merijn> maerwald: But I think expectations management is important too. The python ecosystem is far more accommodating for getting a quick hacky small project running, Haskell's ecosystem doesn't accommodate that as easily, but since beginners almost exclusively write small hacky projects it's important to point out the painpoints on small projects shouldn't be extrapolated to larger projects
03:04:55 <maerwald> python ecosystem has lots of facilities for writing large codebases as well
03:05:20 <maerwald> the reason you can do anything (and everything, lol) with it is the ecosystem, yeah
03:09:48 <tdammers> python is definitely heavily biased towards the early parts of the learning curve and project ramp-up
03:12:53 <simon> I seem to recall that `liftA2 (&&)` is defined somewhere as something like `(<&&>)` or the like. can anyone recall where?
03:16:08 <simon> it looks like it's in the 'ghc' package in the module 'Util'. thanks.
03:33:24 <xenog> I think I found a bug in the Haskell runtime where it freezes while doing a simple STM transaction, consuming all available CPU power in all threads. The program becomes completely unresponsive. Do you have any idea what could be happening?
03:35:30 <gonz_> If you think you've found a bug in GHC you should probably make an issue in the tracker.
03:35:52 <gonz_> Especially if it was "easy" to get to a failing case
03:36:08 <gonz_> You're not likely to be the first or the last to end up there
03:38:07 <xenog> No, it isn't easy to reproduce.
03:38:25 <xenog> It happens on a server with a lot of traffic, but with any less traffic the bug doesn't happen.
03:38:35 <xenog> Or it takes weeks to occur.
03:38:44 <xenog> It's a horrible Heisenbug.
03:41:36 <gonz_> In that case I definitely think #haskell is going to be insufficient
03:42:00 <xenog> Yes, I am not expecting an answer, I'm counting on luck at some point in the future.
03:50:06 <zincy> What is the abstract pattern that is the monad
03:50:22 <zincy> I get that they can be used to model effects, failure and collections
03:50:30 <zincy> But what do these have in common?
03:52:19 <ski> zincy : yes
03:52:27 <jgt> zincy: you can lift functions over them, and you can join them together
03:53:11 <zincy> So monadic actions can be joined and normal actions can be promoted to monads
03:53:36 <ski> i think "normal actions" doesn't make sense in this context
03:53:52 <jgt> when we say "action", we usually mean something like :: IO a
03:54:03 <zincy> any computation in a functorial or applicative context would be "normal"
03:54:12 <zincy> Maybe weaker is a better word
03:54:28 <ski> well, i would call it an "applicative" (or "idiomatic") action, in the case of `Applicative'
03:54:59 <zincy> :t liftM
03:55:00 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
03:55:03 <ski> and "functorial action", i suppose, for `Functor', though i don't think the "action" terminology is that common with `Functor' (the "collection" terminology is a bit more common)
03:55:42 <zincy> so actions refer to monadic actions
03:55:45 <zincy> why action?
03:55:54 <ski> and it's not that you "promote" an idiomatic action to a monadic action. you have say an `Maybe'-action. and `Maybe' is already an idiom, and a monad
03:57:19 <ski> (or, in the case of a `ZipList'-action, `ZipList' is an idiom, but is not a monad (or at least not an instance of `Monad'), so there can be no question of "promoting" here either)
03:57:33 <ski> zincy : no, actions may also refer to idiomatic actions
03:57:46 <zincy> > (liftM (neg)) (Just 1)
03:57:48 <lambdabot>  error:
03:57:48 <lambdabot>      Variable not in scope: neg :: Integer -> r
03:58:17 <zincy> > (liftM ((*)-1)) (Just 1)
03:58:19 <lambdabot>  error:
03:58:19 <lambdabot>      • No instance for (Num (Integer -> Integer -> Integer))
03:58:19 <lambdabot>          arising from a use of ‘e_111’
03:58:23 <ski> specifically, actions means `T'-actions, for some `T', that is often (but not always) an instance of `Monad', and that is usually an instance of `Applicative', and universally an instance of `Functor'
03:58:55 <zincy> ski: Ah right
03:59:11 <zincy> Why is the typeclass hierarchy important?
03:59:13 <ski> zincy : so, first and foremost, you have a `T'-action, for some `T', perhaps `Maybe' or `ZipList' or `IO'. that `T' may then in turn be an instance of `Applicative', and perhaps an instance of `Monad'
03:59:34 <ski> all monads are idiomatic. at least in Haskell. and all of them are functors
04:00:09 <zincy> ok so the thing I said about promoting a functorial computation is nonsense
04:00:23 <zincy> because the computation is either a T-action or not
04:00:56 <ski> (and yes, when i say "idiomatic", or "idiom", in this context, i refer to "applicative functors" .. but i think that's a bit of a mouthful, and so i tend to often use the "idiom" term (appearing in the original paper). i think it's not that common to use that term, though, just so you know)
04:01:03 <ski> right
04:01:18 <ski> for some specific `T'
04:01:39 <zincy> So is a computational context the T
04:01:49 <zincy> and computations are lifted into T
04:01:50 <ski> zincy : anyway .. i tend to say that monads express "dynamic sequencing" and idioms express "static sequencing"
04:02:42 <zincy> The reason it is hard for me to differentiate is I can't think of any idioms that are not monad
04:02:43 <zincy> s
04:02:51 <ski> (and i suppose for functors there's no sequencing at all. just an "inert" collection of non-interacting elements / occurances of things, which you can transform uniformly)
04:03:13 <ski> zincy : `ZipList' is not given with a `Monad' instance
04:04:29 <ski> zincy : also, i think you can make weaker parsing combinator libraries, where a `Parser'-action contains some static information that is computed before parsing even starts, and which is used to optimize parsing. this doesn't work with monadic parsers, since there you can dynamically compute new parsers at "run-time execution" of the action
04:04:49 <ski> (that's the *dynamic* sequencing aspect of monads, that it adds over the *static* sequencing of idioms)
04:06:12 <zincy> Does dynamic sequencing equate to - the sequencing operation varies at runtime
04:06:23 <ski> (the problem with such static info with a parser monad is that in `(>>=) :: Parser a -> (a -> Parser b) -> Parser b', you can't analyze the `Parser b' returned by the callback argument, without having a (run-time of parsing computed) `a' to feed it. so you can't preanalyze such a parser)
04:06:58 <ski> "what to do next" may depend on values computed while executing the action
04:07:18 <ski> e.g., with a parser, you can imagine first parsing in an `Integer'. and then parse *that* many lines of input
04:07:19 <zincy> Ah right so the dynamism comes from the fact that the parser may fail?
04:07:26 <zincy> oh
04:07:28 <ski> you can't express that with an idiomatic parser
04:07:42 <zincy> so you can't do backtracking with an idiomatic parser?
04:07:53 <ski> with an idiomatic action, the "structure" of the action is fixed, before execution begins
04:07:58 <zincy> ahh
04:08:00 <zincy> gotcha
04:08:01 <ski> yes, you can do backtracking
04:08:15 <ski> the "fixed structure" can involve distinct alternatives to try
04:08:20 <zincy> right
04:08:43 <ski> but you can't compute, on-the-fly, a new parser, while executing the current one, and continue with executing that generated parser
04:09:05 <ski> @where applicative-vs-monadic
04:09:05 <lambdabot> "Applicative vs Monadic build systems" by ndm in 2014-07-23 at <https://neilmitchell.blogspot.se/2014/07/applicative-vs-monadic-build-systems.html>. (cf. "static sequencing" vs. "dynamic sequencing")
04:09:23 <ski> explains the same kind of difference, in terms of expressive power of build systems (like Make)
04:09:26 <zincy> So with an idomatic parser you couldn't read say the first line to get say the language name and then use a different parser for the rest of the file
04:09:36 <ski> right
04:10:01 <ski> you *could* hard-code a finite amount of alternatives, different language names
04:10:08 <zincy> So the dynamism is computing the next sequence of operations during runtime
04:10:09 <ski> so the difference is a bit subtle, i agree
04:10:13 <ski> yes
04:10:18 <zincy> cool
04:10:31 <dminuoso> jle`: It's so liberating to think of Applicative as a special cased Day. :)
04:10:49 <Rembane> Like a Sunday?
04:10:56 <ski> idioms `I' don't have `(>>=) :: I a -> (a -> I b) -> I b' .. or, equivalently, they don't have `join :: I (I a) -> I a'
04:12:21 <ski> in the `join' case, perhaps you see more easily that it allows computing a new action on-the-fly, at run-time of execution, and then continuing with that fresh action
04:12:23 <zincy> :t (<*>)
04:12:24 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
04:12:50 <ski> in that case, the structure of `f' doesn't depend on `a'. only the `b' depends on `a'
04:13:02 <zincy> So with I the computation doesn't affect the context?
04:13:16 <ski> (and, depending on which "path" in the structure `f' is taken, a different dependency from `a' to `b' might be used)
04:14:09 <ski> the run-time dynamics of the execution, meaning specifically what (intermediate) result values are computed, doesn't affect the "structure of the effects"
04:14:34 <ski> (i'm not sure whether that makes it any clearer or not)
04:14:39 <zincy> Yes it does!
04:15:20 <ski> (perhaps there's a better way to express/explain this, i dunno)
04:15:32 <zincy> So with monads, the structure of effects can be affected by the results of computations in the structure
04:15:52 <zincy> but with applicative functors the structure of effects is static
04:16:09 <zincy> The join operation gives you a new structure
04:16:34 <zincy> So there are two things going on a sequencing of contexts and values in the context for monads
04:16:38 <ski> (for a while, some people wanted to prod people away from thinking of it in terms of "sequencing" (and perhaps they still do) .. but after thinking about it, i've come to the conclusion that it really *is* about sequencing (or at least, that's one aspect of it, or one way to explain it))
04:16:45 <dminuoso> zincy: In some sense we could pretend Applicative had these two methods instead: https://gist.github.com/dminuoso/9ee013cee14159a945928c17c7caa59d
04:16:56 <dminuoso> zincy: I often feel that it best describes what Applicative is, and how Monad can do *more*
04:17:23 <dminuoso> The <+> can only combine effects -> you don't get to decide on effects based on results.
04:17:26 <ski> however, one should be *perfectly* clear that the sequencing we're talking about does *not* necessarily have much of anything to do with the sequencing in the sense of which order reduction/evaluation steps happen in
04:17:44 <ski> we're talking about some kind of more abstract ordering/sequencing here (which is effect-dependent)
04:17:54 <dminuoso> zincy: All <+> does, is combine the `f` layer in an associative way, such that `unit` acts as an identity (up to isomorphism)
04:18:07 <ski> in the list monad, if you write
04:18:38 <ski> > do z <- [1 .. 20]; y <- [1 .. z]; x <- [1 .. y]; guard (x^2 + y^2 == x^2); return (x,y,z)
04:18:40 <lambdabot>  []
04:18:45 <ski> er
04:18:48 <ski> > do z <- [1 .. 20]; y <- [1 .. z]; x <- [1 .. y]; guard (x^2 + y^2 == z^2); return (x,y,z)
04:18:50 <lambdabot>  [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17),(12,16,20)]
04:18:54 <ski> which is the same as
04:19:12 <ski> > [(x,y,z) | z <- [1 .. 20],y <- [1 .. z],x <- [1 .. y],x^2 + y^2 == z^2]
04:19:14 <lambdabot>  [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17),(12,16,20)]
04:19:31 <dminuoso> zincy: And in this form you get to see the applicative laws in a very clean and simple fashion.
04:20:00 <ski> the sequencing indicated by the `;' in the `do'-notation (translating to `(>>=)' by desugaring) (or the `,' in the list comprehension, translating to `concatMap' by desugaring) intuitively expresses "loop nesting"
04:21:02 <ski> zincy : do you see my point ?
04:21:30 <zincy> I think so
04:21:53 <zincy> concatMap combines what would be the lists from each loop into one big list
04:22:10 <ski> (i think some of the qualms people had/has about talking about idioms and monads in terms of sequencing was the fear that people would confuse this abstract sequencing with the operational/procedural ordering (or perhaps, in some cases, of them themselves confusing the two))
04:22:23 <ski> @undo do z <- [1 .. 20]; y <- [1 .. z]; x <- [1 .. y]; guard (x^2 + y^2 == z^2); return (x,y,z)
04:22:23 <lambdabot> [1 .. 20] >>= \ z -> [1 .. z] >>= \ y -> [1 .. y] >>= \ x -> guard (x ^ 2 + y ^ 2 == z ^ 2) >> return (x, y, z)
04:22:32 <ski> @undo [(x,y,z) | z <- [1 .. 20],y <- [1 .. z],x <- [1 .. y],x^2 + y^2 == z^2]
04:22:32 <lambdabot> concatMap (\ z -> concatMap (\ y -> concatMap (\ x -> if x ^ 2 + y ^ 2 == z ^ 2 then [(x, y, z)] else []) [1 .. y]) [1 .. z]) [1 .. 20]
04:22:58 <ski> yes, `concat :: [[a]] -> [a]' is of course `join'
04:23:26 <ski> and one way to implement `(>>=)' in terms of `fmap' and `join' is `ma >>= amb = join (fmap amb ma)'
04:23:29 <ski> @src concatMap
04:23:29 <lambdabot> concatMap f = foldr ((++) . f) []
04:23:34 <ski> er, well, i had
04:23:37 <zincy> So you couldn't express that with <*>
04:23:42 <ski>   concatMap f xs = concat (map f xs)
04:23:45 <ski> in mind :)
04:23:53 <ski> right
04:24:37 <zincy> > (+1) <*> [1..5] 
04:24:39 <lambdabot>  error:
04:24:39 <lambdabot>      • Couldn't match expected type ‘[Integer -> b]’
04:24:40 <lambdabot>                    with actual type ‘Integer -> Integer’
04:25:00 <zincy> > (+1) . (:[]) <*> [1..5] 
04:25:03 <lambdabot>  error:
04:25:03 <lambdabot>      • Couldn't match expected type ‘[Integer -> b]’
04:25:03 <lambdabot>                    with actual type ‘a0 -> [a0]’
04:25:15 <zincy> Any examples of the <*> for lists?
04:25:37 <ski> > [(2 *),(2 ^)] <*> [3,4]
04:25:39 <lambdabot>  [6,8,8,16]
04:25:45 <dminuoso> What's the reason to pick Free over writing something monad polymorphic? Is it so you can change/examine the monadic structure before picking a monad?
04:25:46 <zincy> I guess there you can modify the elemet in a list but without bind you can't modify the whole list
04:26:22 <ski> with bind you can replace one element with several, or with none, depending on the element
04:26:53 <zincy> ski: so without bind you dont have join and therefore you can't return [[a]]
04:27:08 <ski> with `(<*>)' on a list with `m' elements (being functions), and a list with `n' elements, you always get a list with `m * n' elements (all combinations of picking one function from the first list, and one argument from the second list)
04:27:31 <ski> and therefore you can't go from `[[a]]' to `[a]', rather
04:27:32 <zincy> dminuoso: I read that if you have a parse tree and you use Free for your interpreter it helps with things like pretty printing the parse tree 
04:27:42 <zincy> I was wondering myself what Free is for actually
04:28:01 <ski> btw, consider how `sum', or `product', in a sense, is about "sequencing"
04:28:13 <dminuoso> ski: I dislike the word sequencing.
04:28:20 <dminuoso> ski: It's associativity that you are trying to get at, really.
04:28:24 <ski> dminuoso : what would you sugegst in its place
04:28:37 <ski> dminuoso : no, but associativity is part of it, yes
04:28:39 <dminuoso> ski: I always think of Haxl and how you dont really sequence anything with its Applicative interface.
04:29:15 <dminuoso> ski: or rather the monoidal structure beneath.
04:29:31 <ski>   `product [x,y,z]' is `x * y * z'. this might be equal to say `y * z * x', in case the multiplication is commutative. but if we're talking about quaternions, or square matrices, then it isn't in general
04:30:14 <ski> we can define something like `product', as soon as we have a *monoid* (which has identity laws, and associativity law, but no commutativity law)
04:30:36 <ski> @type mconcat
04:30:38 <lambdabot> Monoid a => [a] -> a
04:30:56 <dminuoso> @type foldMap
04:30:57 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
04:30:58 <zincy> I need to get familiar with the identity , associativity and commutativity laws
04:31:09 <dminuoso> % ala Sum foldMap [1,2,3,4]
04:31:11 <yahb> dminuoso: 10
04:31:16 <dminuoso> % ala Product foldMap [1,2,3,4]
04:31:16 <yahb> dminuoso: 24
04:31:21 <ski> so, even if particular monoids, like `Product Integer', might be commutative, the abstract *concept* of a monoid doesn't require that. and so monoids affords us "sequencing" of elements
04:32:11 <ski> (if we drop the associativity law, then instead of taking in a finite sequence (being sequenced/ordered) of elements, we'd take in a tree, where the "grouping" also may matter)
04:32:11 <zincy> monoids just require a append and unit ?
04:32:26 <dminuoso> zincy: plus associativity and identity laws.
04:32:38 <dminuoso> zincy: that's all monoid captures/generalizes.
04:32:44 <ski> zincy : yes, and the unit/identity/neutral element has to satisfy the identity / neutral element laws wrt to the "append", which in turn must also be associative
04:33:27 <ski> anyway, now "monads are just monoids in the (monoidal) category of endofunctors", and so, just like monoids "express sequencing", in a sense, monads also do
04:33:27 <zincy> What is commutavity?
04:33:36 <ski> that `x * y = y * x', for all `x' and `y'
04:33:38 <dminuoso> as soon as you have an operation, lets call it &&& and you satisfy `a &&& (b &&& c) = (a &&& b) &&& c` then you have a semigroup. if you *also* happen to have one special element `u` such that `f &&& u == f` and `u &&& f == f` for all choices of f, then you have a monoid.
04:33:54 <ski> associativity is that `(x * y) * z = x * (y * z)', for all `x',`y',`z'
04:33:55 <zincy> So only defined for binary operations?
04:34:05 <dminuoso> zincy: Correct.
04:34:15 <Ariakenom> I think this explanation could use an elaboration on "sequence"
04:34:29 <ski> commutativity allows us to disregard ordering. associativity allows us to disregard grouping (so, writing `x * y * z', instead of disambiguating which grouping was intended)
04:34:32 <JappleAck> about kleisli arrows, guys, how do you compute more than two values?
04:34:42 <dminuoso> JappleAck: what do you mean?
04:34:48 <Ariakenom> an maybe even use list instead, that's a more common concept
04:34:58 <JappleAck> like kleisli arrows are supposed to deal with pair of values, right?
04:35:05 <dminuoso> JappleAck: No.
04:35:21 <ski> i said "(finite) sequence" rather than "list", because lists in haskell may be infinite
04:35:23 <dminuoso> JappleAck: Are you familiar with function composition?
04:35:35 <JappleAck> dminuoso: of course
04:35:51 <dminuoso> JappleAck: then kleisli arrows are basically about a single function:
04:35:56 <dminuoso> % :t (<=<)
04:35:57 <yahb> dminuoso: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
04:36:05 <ski> @type (.)
04:36:06 <lambdabot> (b -> c) -> (a -> b) -> a -> c
04:36:22 <JappleAck> dminuoso: are we talking about the same kleisli arrows?
04:36:27 <JappleAck> i'm about Control.Arrow
04:36:30 <ski> @type liftA2 (.)
04:36:31 <lambdabot> Applicative f => f (b -> c) -> f (a -> b) -> f (a -> c)
04:36:35 <Ariakenom> ski: but monoids or applicatives don't have that limitation either?
04:36:44 <dminuoso> JappleAck: wait a second.
04:36:56 <Solonarv> JappleAck: 'Kleisli m a b' from Control.Arrow is simply a newtype wrapper around 'a -> m b'
04:37:10 <ski> Ariakenom : ime, it's not as common to talk about lists in math
04:37:19 <dminuoso> JappleAck: we call "arrows" of the shape `a -> m b` kleisli arrows.
04:37:45 <zincy> monoids don't require commutativity and therefore afford us sequencing - I would have thought that commutativity  is needed for sequencing
04:37:46 <dminuoso> JappleAck: the word "arrow" is not identical to the notion of Control.Arrow, which has a more constrained/different notion 
04:38:02 <dminuoso> JappleAck: so the operation (<=<) is called kleisli composition (of kleisli arrows)
04:38:25 <JappleAck> okay, so i guess my vocabulary is incorrect.
04:38:29 <ski> zincy : if you have commutativity, then `x * y * z = x * z * y = z * x * y = z * y * x = ...', and so the ordering/sequencing actually never matters
04:38:49 <ski> zincy : if you don't have commutativity guaranteed, then ordering/sequencing may matter
04:39:04 <Solonarv> for example, consider the monoid of strings with concatenation
04:39:08 <Ariakenom> ski: I just suspect people don't think of a mathematical sequence when hearing sequencing
04:39:19 <Solonarv> i.e. x <> y = x ++ y; mempty = ""
04:39:20 <ski> Ariakenom : point
04:39:23 <JappleAck> so, how do you Control.Arrow for more than two values?
04:39:41 <dminuoso> JappleAck: Can you be more precise? I find the question confusing. :)
04:39:42 <Solonarv> JappleAck: you use tuples, and functions like &&& and ***
04:39:50 <Solonarv> it's not pretty, tbh
04:40:02 <zincy> order matters for the result when concating strings - so the operation doesn't commute
04:40:14 <dminuoso> zincy: the order is about something different.
04:40:34 <zincy> so what is the order there
04:40:38 <dminuoso> zincy: imagine you are stacking lego pieces ontop of each other, with the goal being [Red][Blue][Green][Green][Yellow]
04:40:44 <ski> @type (fst &&& fst . snd) &&& snd . snd
04:40:45 <lambdabot> (c, (c', b)) -> ((c, c'), b)
04:40:57 <JappleAck> Solonarv: yes, i do, with tuple of two values, (a, b), i have `first` and `second`, but what if i have (a, b, c)?
04:40:59 <dminuoso> zincy: Does it matter whether you first put [Green] to [Yellow] and then build [Red][Blue][Green] to the left of it
04:41:04 <Solonarv> "order matters" means that x ++ y may not be the same as y ++x
04:41:11 <Solonarv> JappleAck: you use nested tuples :(
04:41:20 <dminuoso> zincy: Or whether you start building [Red] to [Blue] to [Green] and then combine [Green][Yellow] to the right side of it?
04:41:21 <zincy> dminuoso: no
04:41:32 <Solonarv> zincy: there you go, that's associativity
04:41:59 <zincy> so ordering is about evaluation
04:42:04 <dminuoso> Not evaluation.
04:42:06 <dminuoso> zincy: its about grouping.
04:42:20 <zincy> are they exclusive?
04:42:30 <Solonarv> @let data BT = Branch BT BT | Leaf
04:42:31 <dminuoso> zincy: evaluation is about programming topics, associativity is much more principled.
04:42:31 <lambdabot>  Defined.
04:42:54 <zincy> ah right
04:43:07 <dminuoso> zincy: https://gist.github.com/dminuoso/12f48cec7f0025ce78f35cc886610ad9
04:43:12 <dminuoso> zincy: they all give you the same final lego stack right?
04:43:18 <Solonarv> here (x `Branch` y) `Branch` y /= x `Branch` (y `Branch` z)
04:43:21 <zincy> yeah
04:43:29 <Solonarv> so there's an example of a binary operation that isn't associative
04:43:39 <dminuoso> zincy: https://gist.github.com/dminuoso/85794ef08c4a7e3991ea224a27e7eda0
04:43:45 <dminuoso> zincy: do these give you the same lego stack?
04:44:35 <dminuoso> zincy: the first is about associativity. stacking lego units is associative. but if you change the order in which you stakc them, you get different stacks, so lego stacking is not commutative.
04:45:10 <ski> dminuoso : re Haxl, i was not saying that particular idioms or monads need to have much to do with sequencing. i'm saying that the *abstract* concepts of idiom and monad does have something to do with sequencing. multiplication of real numbers is commutative, and so we may safely ignore ordering, and think of multiplication as taking a (finite) bag (/multi-set) of numbers. but for quaternions it matters. multiplication in a ring need not be commutative
04:45:22 <dminuoso> zincy: there's two sort of orthogonal notions of "order" involved. one is "in which position a lego unit is", and the other is "how do you group the operation"
04:45:32 <zincy> so associativity is grouping doesn't mattter
04:45:37 <dminuoso> zincy: Spot on.
04:45:47 <ski> (hrm cut off near : ".. but for quaternions it matters. multiplication in a ring need not be commutative". so you need to keep track of ordering/sequencing)
04:46:14 <zincy> and commutativity is order of things to the binary operation
04:46:27 <dminuoso> zincy: addition of numbers is both commutative and associative
04:46:27 <zincy> a * b = b * a
04:46:32 <dminuoso> lego stacking is associative but not commutative
04:46:39 <dminuoso> list contatenation is associative but not commutative
04:47:15 <zincy> :)
04:47:23 <Ariakenom> associative: (a * b) * c = a * (b * c)
04:47:31 <dminuoso> zincy: associativity (plus a tiny bit more we can glance over for now) gives you a semigroup
04:47:57 <dminuoso> zincy: now a monoid is a semigroup that *also* has some special element that acts as a 0 with regards to that operation
04:48:06 <dminuoso> zincy: can you think of what that is when talking about addition of numbers?
04:48:21 * ski idly wonders what that tiny bit would be ;)
04:48:22 <zincy> What is the word for describing these properties
04:48:28 <dminuoso> ski: closure.
04:48:39 * ski suspected
04:49:14 <Solonarv> usually "something axioms" or "something laws"
04:49:40 <dminuoso> zincy: so integer addition has an identity element, which is 0. And indeed `f + 0 = f` and `0 + f = f`
04:49:42 <Solonarv> e.g. "semigroup axioms", "monoid laws", "monad laws"
04:49:51 <dminuoso> zincy: Note that both sides are relevant. Some operations only have one-sided elements.
04:49:58 <Younder> Electrical Engineering and it's diffs are more interesting to me now than lattices and recursion relations. Relic from my physics days I guess.
04:50:01 <dminuoso> Example: integer division has a right identity, but no left identity.
04:50:19 <dminuoso> `f / 1 = f`, but 1 is certainly not a left-identity.
04:50:26 <Younder> s/recursion/recurrence/
04:50:44 <zincy> oh sorry this cafe is closing need to go for now but will be back
04:50:56 <zincy> great help! thanks everyone
04:51:13 <dminuoso> ski: Closure is probably kind of implied when talking about the Haskell world as soon as we demand that functions be total.
04:51:33 <dminuoso> (Not sure whether that holds for functions involving infinite streams, but oh well)
04:51:45 <Solonarv> dminuoso: yes, that's why we usually don't mention it
04:51:46 <ski> dminuoso : depending, it would often be taken for granted in math contexts, as well
04:52:30 <ski> Younder : "diffs" being differential equations ?
04:52:37 <Younder> That said through digital signal processing even in hardware Z-transforms are about to replace diffs in Control theory. Kinda cool.
04:52:47 <Younder> ski yes
04:52:59 <dminuoso> fix question, if fix finds the least defined fixed point, shouldn't it always return bottom since bottom is the least defined value and inhabitated by all types?
04:52:59 <Solonarv> oh, I thought you were referring to differentials
04:53:21 <Solonarv> dminuoso: ah, but bottom may not be a fixed point of the function
04:53:44 <dminuoso> Solonarv: Do you have any example?
04:53:56 <Solonarv> for example if f = (1:) you have f undefined = 1 : undefined ≠ undefined
04:53:58 <dminuoso> Oh wait.. functions can disregard their arguments.
04:54:03 <dminuoso> Mmm
04:54:06 <ski> dminuoso : but if `f' is defined by `f xs = 1 : xs', then `_|_' is not a fixed point of `f', since `f _|_ = 1 : _|_ =/= _|_'
04:54:25 <dminuoso> ski: Fair.
04:54:25 <Solonarv> ski: I love how we both picked the exact same example :P
04:54:30 * ski grins
04:55:06 <Younder> For reference recurrence relations are Laplace transform cousin. When you digitize signal processing control theory changes to a lattice problem.
04:55:10 <dminuoso> However
04:55:13 <dminuoso> % fix (\rec n -> if n == 0 then 1 else n * rec (n-1)) 5
04:55:13 <yahb> dminuoso: 120
04:55:29 <dminuoso> Oh. Nevermind!
04:55:38 <dminuoso> I actually had to ask this to understand it. :<
04:55:44 <ski> Younder : hm, where does the lattice come from ?
04:57:16 <ski> for `fix f', we can think of a progression of successively more known/determined states of information, `_|_  =[  1 : _|_  =[  1 : 1 : _|_  =[  1 : 1 : 1 : _|_  =[  ...', where `=[' is the information ordering
04:57:40 <Solonarv> ⊑
04:57:45 * ski nods
04:57:49 <Younder> All processing is done with discrete values. So we move from real fields to integer fields, even with floating point digital logic is quite different from control theory.
04:58:54 <Younder> Z transforms from recurrence relations takes the place of Laplace transforms.
04:59:29 <ski> for that factorial example, we can think of something like `\case {_ -> _|_}  =[  \case {0 -> 1; _ -> _|_}  =[  \case {0 -> 1; 1 -> 1; _ -> _|_}  =[  \case {0 -> 1; 1 -> 1; 2 -> 2; _ -> _|_}  =[  \case {0 -> 1; 1 -> 1; 2 -> 2; 3 -> 6; _ -> _|_}  =[  ...'
05:00:08 <ski> Younder : mhm, i'd have to look more into it to understand that, i think
05:00:55 <Younder> ski Well it is a bit to involved to teach in a chat channel.
05:01:02 <ski> that may be so
05:02:43 <Younder> That said EE has grip on me like I haven't felt in  years. Maybe you should try some into moves in  that area ski?
05:04:15 <ski> perhaps. i've always been weak on electronics (i've read digital logic (on my own), but never really understood the transistor level, not to mention op-amps and the like)
05:11:26 <merijn> Isn't normalise from filepath supposed to strip .. and . from paths?
05:13:20 <merijn> And since the answer is "apparently not..." what's the right way to achieve that?
05:13:29 <Younder> Ski: I started a programmer and found my designs going into FPGA and later ASIC's as i started understanding G5 radio and RADAR. This is seriosly cool stuff. And hand on as I also design quad-copters.
05:15:04 <ski> Younder : it sure sounds like it could be fun
05:16:00 <bzm3r> let `i` be `(->) r`, and let `* :: i (x -> y) -> (i x -> i y)`; this means that `* :: ((->) r (x -> y)) -> (((->) r x) -> ((->) r y))`, which is the same as `* :: (r -> (x -> y) -> ((r - > x) - > (r -> y))`?
05:16:37 <bzm3r> are my parentheses correct?
05:17:36 <ski> you could say `(->) r (x -> y) -> ((->) r x -> (->) r y)' for the middle part, less redundant brackets
05:17:44 <ski> the last version is missing a closing bracket
05:18:10 <bzm3r> ah yes, i see
05:18:27 * ski would tend to say `i' is `(r ->)' (an operator section, on the type level, even though that's not actually supported syntax)
05:18:53 <ski> (oh, and in Haskell, you'd need to say `(*) :: ...', not plain `* :: ...')
05:18:58 <bzm3r> right
05:19:09 <bzm3r> is this the same as an "environment functor"?
05:19:12 <Solonarv> (also, in Haskell that operator already exists and is called <*> )
05:19:26 <Solonarv> bzm3r: yes, that's exactly what it is
05:19:29 <ski> yes, this is environment/input/reader, on `r'
05:19:46 <Solonarv> % :t <*>
05:19:47 <yahb> Solonarv: ; <interactive>:1:1: error: parse error on input `<*>'
05:19:52 <Solonarv> % :t (<*>)
05:19:52 <yahb> Solonarv: Applicative f => f (a -> b) -> f a -> f b
05:20:04 <Solonarv> % :t (<*>) @((->) _)
05:20:05 <yahb> Solonarv: (w -> a -> b) -> (w -> a) -> w -> b
05:20:27 <ski> (sometimes people call it the "function monad/idiom (or applicative functor)/functor", but i don't think that emphasizes enough the focus we're putting on the function arrow here)
05:20:56 <bzm3r> okay, so an implementation for `*` (pretend that `*` isn't already defined in Haskell, etc.) is purported to be: `u * v = \ r -> (u r) (v r)`
05:21:15 <ski> yes, or `(u * v) r = (u r) (v r)'
05:21:33 <ski> (of course `(u r) (v r)' could be written as `u r (v r)', if you want to)
05:22:06 <ski> this operation is also known as the "`S' combinator", in SKI combinatory algebra
05:22:32 <bzm3r> i am having trouble figuring out the type of `u * v`, based on its implementation (as in, i am having trouble seeing that it's the same as the type of `*` i talked about earlier)
05:24:08 <bzm3r> `* :: (r -> (x -> y)) -> ((r - > x) - > (r -> y))`
05:24:15 <dminuoso> bzm3r: If you drop an extra set of parens it should be easier.
05:24:24 <ski> well, you start by inventing new meta-variables for the parameters, so `u :: _a',`v :: _b', and also one for the result, say `_c', and we start with `(*) :: _a -> _b -> _c'
05:24:27 <dminuoso> * :: i (x -> y) -> i x -> i y
05:25:03 <ski> then we need to visit each AST node in the body of the definition, and add type equations, depending on which type of node we're looking at
05:25:45 <ski> the top form of the body is `\r -> ..r..', so `_c' must be a function type, say `_c = _d -> _e', where the local variable `r' is given the type `_d', and the body of the lambda is to have type `_e'
05:26:01 <bzm3r> ski sorry, you'll have to talk like i'm a 5 year old
05:26:07 <ski> okay
05:26:16 <bzm3r> dminuoso i don't see how we can drop those parentheses
05:26:21 <ski> at which point did what i was saying stop to make any sense ?
05:26:30 <Guestss1> hi , register for free on https://www.pokerstrategy.com/#uHQOLZ and get 50$ free money and decent poker education!
05:27:03 <bzm3r> `* :: i (x -> y) -> i x -> i y` seems very different from `* :: i (x -> y) -> (i x -> i y)`
05:27:15 <bzm3r> ski let me try and type out my confusion precisely :)
05:27:17 <ski> bzm3r : note that the `->' operator is, by convention, specified to be right-associative. this means that `X -> Y -> Z' is interpreted as `X -> (Y -> Z)'. just like `a ^ b ^ c' is interpreted as `a ^ (b ^ c)'
05:27:26 <bzm3r> ahhh
05:28:20 <dminuoso> ski: In our case its not by convention, but by the grammar specification in the Haskell standard
05:28:49 <ski> yes, but that is because of a long-standing convention :)
05:29:18 <ski> (which i suppose is what i had in min)
05:29:23 <dminuoso> Oh fair enough. I just figured that they shouldn't run off and think that GHC is merely adhering to convention.
05:29:25 <ski> (s/min/mind/)
05:29:29 <bzm3r> ski so you suggest that the first step is to replace everything by "meta variables"; why should we do this?
05:29:34 <ski> dminuoso : good point
05:30:14 <ski> bzm3r : a "meta variable" (in this case, a "meta *type* variable") is merely a (temporary) name we're giving to something, before deciding on what it should actually be
05:30:26 <ski> (and we need to distinguish these from ordinary type variables in types)
05:30:31 <bzm3r> got it
05:30:53 <ski> bzm3r : so, the parameters `u' and `v' will end up having *some* types (assuming the whole thing type-checks), so call those `_a' and `_b'
05:30:59 <ski> and call the result type `_c'
05:31:10 <bzm3r> cool, this makes sense to me so far
05:31:46 <bzm3r> `(*) :: _a -> _b -> _c`
05:31:49 <ski> now, when calling `u * v', the result `\r -> (u r) (v r)' is computed, and so the type of that expression ought to be the overall result type `_c' of the function
05:32:05 <bzm3r> right, let me try and determine the type of the result
05:32:23 <ski> however, this expression is a function abstraction, a function "literal"/"aggregate", a lambda expression, an "anonymous function"
05:32:24 <dminuoso> bzm3r: You can, at any time, introduce fresh meta-variables by the way.
05:32:39 <bzm3r> ski hold on, let me try it for myself :p
05:32:42 <ski> and so the type `_c' of this expression must be a function type, say `_d -> _e'
05:32:49 <ski> yea, i'll wait now
05:33:05 <ski> (i was merely restating what i had already said)
05:33:14 <bzm3r> ah, i see, ok
05:33:58 <ski> the end result of this phase of type-inference is a bunch of type equations, involving meta variables
05:34:26 <ski> then, we solve this equation system. finally we generalize on any remaining undetermined meta variables
05:35:34 <ski> (you may compare with how, sometimes, when you're solving a linear equation system, e.g. expressed in terms of matrices and vectors, there may not be a unique solution, but may remain some "parameters" which can be picked as any number you like, and you get a valid solution of the system for any choice (or combination of choices))
05:35:59 <bzm3r> based on the expression `u * v = \ r -> (u r) (v r)`, we know that `(*) :: _a -> _b -> c`; noting that `c` is a lambda expression, it must have the type `_d -> _e`, so `(*) :: _a -> _b -> (_d -> _e)`, which is the same as `(*) :: _a -> _b -> _d -> _e` since `->` is right associative (so far so good?)
05:36:01 <ski> (in case you're not familiar with linear algebra, matrices and vectors, you may safely ignore that comment)
05:36:48 <ski> i'd say `_c' (or some other distinguished syntactic convention, to be able to tell the difference with ordinary type variables), rather that `c'
05:37:06 <bzm3r> right, i missed the `_`
05:37:10 <ski> (also, nitpick, `_c' is not a lambda expression, it is the *type* of a lambda expression)
05:37:13 <ski> nw
05:37:25 <bzm3r> right, it is the *type* of a lambda expression, agreed
05:37:40 <bzm3r> i should be precise, so i totally appreciate these nitpicks
05:38:06 <ski> bzm3r : yea, you can immediately plug in the solution of the equation `_c  =  _d -> _e' into `(*) :: _a -> _b -> _c', if you like .. or you can continue on, collecting your equations, and summarize at the end
05:39:57 <ski> you should also note at this point that the local variable `r' will get type `_d', and that the body of the lambda must have type `_e'
05:40:13 <bzm3r> now, looking at the form of the lambda expression, we can think about the type `_e` further: `_e = (_a -> _d) -> (_b _d)`
05:40:14 <ski> do you want to think for a while on how to continue with the AST node `(u r) (v r) :: _e', or should i elaborate on this step ?
05:40:33 <bzm3r> no, i want to work it out on my own :)  i think i get the gist of it, i just need confirmation as i do each step
05:40:43 * ski nods
05:41:17 <ski> can you elaborate on what makes you deduce `_e = (_a -> _d) -> (_b _d)' ?
05:41:30 <ski> (also, did you mean `_b -> _d', in place of `_b _d' there ?)
05:41:57 <bzm3r> yes, i mean `_b -> _d`
05:44:15 <bzm3r> so i am looking at `(u r) (v r)`, and nothing that u has type `_a` and `v` has type `_b`, while `r` has type `_d`; further, i am noting that `u r` has type `(_a -> _d)`, and this takes as input `v r` which has type `_b -> _d`, so we have `(_a -> _d)  -> _b -> _d` (i think i sense a mistake here, let me see if i can figure it out)
05:44:29 <bzm3r> also, nothing should be "noting"
05:44:57 <bzm3r> yes, i see my mistake
05:45:05 <bzm3r> let me fix this
05:45:51 <ski> why does `u r' have type `_a -> _d' ? and why does `v r' has type `_b -> _d' ?
05:46:04 <bzm3r> `u` is a function which takes `r` as input, so this means that `u :: _d -> _f`
05:46:33 <ski> (also, i see you're now doing a bottom-up traversal of the Abstract Syntax Tree. i was thinking of a depth-first top-down traversal. but as long as you visit each node, it's okay)
05:46:52 <ski> bzm3r : yes. and ?
05:47:03 <talqu> hi, I want to start playing with database and wanted to try with beam as it has a tutorial and seems nice in general. However, I the package seems to be broken. What lib would you recommend to use for a noob?
05:47:09 <bzm3r> (sorry, typing is slow, i am using paper, and then writing things out, just a moment)
05:47:18 <ski> no worry. take your time
05:47:27 <dminuoso> talqu: *-simple
05:47:58 <merijn> sqlite-simple, because SQLite == <3
05:49:33 <talqu> dminuoso: thank. https://hackage.haskell.org/package/postgresql-simple-0.4.9.0/docs/Database-PostgreSQL-Simple.html Is this all the relevant docs or is there something more to learn about this lib?
05:49:42 <ski> talqu : if you have the opportunity to, and are inclined to do so, i'd suggest looking a bit closer at the relational data base model (with relational algebra, normalization, and so on)
05:49:53 <dminuoso> talqu: I found the haddock documentation to be sufficient.
05:50:20 <dminuoso> talqu: Note that you most likely want to write your own very thin layer ontop of it. In my cases its usually just a couple functions. :)
05:50:45 <ski> (perhaps later, if you'd rather get some hands-on experience first. but i think knowing the theoretical concepts, the "conceptual landscape", so to speak, can really help)
05:55:40 <bzm3r> `\r -> (u r) (v r)`, and we are saying that `r` has type `_d`, and the result of the lambda has type `_e`; what is `_e`? note that `u r` is a partial function of `r`, so it must have type `_d ->`, let `v -> r` have type `_g`, so `_e = _d -> _g`
05:56:10 <bzm3r> sorry, it should say let `v r` have type `_g`
06:05:14 <Bish> dminuoso: you left #ruby :o
06:05:23 <Bish> ruby doesn't have a flip, right?
06:05:47 <dminuoso> Bish: I no longer actively develop any Ruby programs. It's all Haskell and Elixir now. :)
06:06:11 <Bish> i get the haskell part
06:06:34 <Bish> elixir is odd
06:07:21 <Bish> but i did set up an xmpp server, which made me interested in erlang, so i might look at it
06:10:10 <ski> bzm3r : `u r' is an application of `u' to `r'. perhaps a "partial application". not a "partial function", though
06:11:24 <ski> bzm3r : are you saying `u r' has type `_d -> ...' ? or are you talking about the type of `u' ?
06:11:49 <ski> bzm3r : what is `v -> r' ? it it's to have a type, it ought to be an expression, no ?
06:14:25 <bzm3r> ski: okay, this is what i am thinking now (thank you so much for your patience) `(u r) (v r) :: _e`, `(v r) :: _f `(u r) :: _f -> _e`, note that `_a = _d -> _f` since `v :: _a`
06:14:53 <bzm3r> so my system of equations so far is
06:15:12 <ski> bzm3r : yes, good
06:15:28 <ski> you should also get an equation for `_b' out of that
06:15:35 <bzm3r> yes
06:27:34 <bzm3r> ski my work so far: https://paste.rs/zi7
06:27:43 <bzm3r> i made a mistake in what i typed last time, but now i have it fixed
06:27:54 <bzm3r> (i said v had type _a, when it had type _b)
06:30:14 <ski> bzm3r : looks fine. now solve the equation system, and substitute into the signature ?
06:31:24 <bzm3r> ski: yes, trying that out now :)
06:32:18 <bzm3r> ski: is there an "inverse operation" to `->`?
06:32:38 <ski> not really
06:32:44 <bzm3r> ok, let me think further
06:33:03 <ski> (if you want to, you could elaborate further on what made you ask that)
06:35:01 <bzm3r> so the type variables i currently have are _a, through _f, and i want to write the signature for `*` in terms of `_a`, `_b`, and `_d` alone
06:35:57 <ski> that's the wrong way of thinking about it
06:36:07 <ski> you want to solve the equation system first
06:36:38 <ski> (perhaps this is difficult because it's too simple in this case)
06:36:50 <bzm3r> so i am familiar with solving algebraic equations over number fields, etc.
06:36:59 <ski> say if you had an equation
06:37:01 <bzm3r> but i am not sure what "solving" the equation means in this case
06:37:08 <ski>   T -> U = V -> W
06:37:12 <bzm3r> yes
06:37:22 <bzm3r> then T = V, and U = W
06:37:43 <ski> for some type expressions `T',`U',`V',`W', possibly involving `->'s, meta variables, maybe other type variables, maybe other type constructors
06:37:47 <ski> right
06:37:58 <ski> so you can simplify (in some sense) the system, getting an equivalent one
06:38:17 <bzm3r> got it, let me try
06:38:31 <ski> if you have an equation like `Int = T -> U' or `Maybe T = Either U V', then this would be a type mismatch, so your system has no solutions
06:39:18 <ski> if you have `_a = .._a..', where the expression on the right is not just `_a' itself, then you have an "infinite type constraint", which is also deemed to mean that your system is not solvable
06:40:02 <ski> e.g `_a = [_a]' would give rise to `_a = [[[[....]]]]', which is not considered (for pragmatic reasons, at least) to not be a valid type, on the right hand side
06:40:10 <bzm3r> right
06:40:38 <ski> and, of course, if you have `_a = ...', you can simplify (in some sense) every other equation, by replacing other occurances of `_a' by `...'
06:40:49 <bzm3r> right
06:41:36 <ski> so, in the end, in case the system is solvable, you will end up with a bunch of equations that all look like `_a = ...' with a meta variable `_a' on the left side, it not being mentioned on the right side, and each of the left sides being distinct
06:42:03 <ski> so, you have "values" (types, possible in terms of some meta variables) for some of the meta variables
06:42:14 <bzm3r> right
06:42:20 <ski> and other meta variables instead occur (only) on the right hand sides
06:42:28 <ski> (these are your "parameters")
06:42:49 <ski> now, your equation system is *already* solved, nothing to do there
06:43:02 <bzm3r> apart from substituting it in?
06:43:19 <bzm3r> i am not sure it is solved
06:43:27 <bzm3r> because i feel like i should eliminate _f and _e
06:43:34 <bzm3r> and _c
06:43:44 <ski> so, you just need to substitute solutions into the "formula" (like when optimizing a formula wrt to linear inequality constraints, say), in this case the type signature for `(*)'
06:44:27 <ski> no, `_f' and `_e' (and `_d') are arbitrary parameters, any particular types you pick for them will give a concrete solution
06:44:42 <ski> otoh `_c' must be `_d -> _e', it is not arbitrary
06:44:57 <ski> it has a specific "value" (type), upto choice of the parameters
06:45:02 <bzm3r> right
06:45:05 <ski> s/has/is equal to/
06:45:21 <ski> so .. substitute into the type signature ?
06:45:28 <bzm3r> oh my god
06:45:29 <bzm3r> yeah
06:45:30 <bzm3r> it works
06:45:41 <bzm3r> (*) :: (_d -> _f -> _e) -> (_d -> _f) -> (_d -> _e)
06:45:46 <ski> yea
06:45:51 <ski> now the last step, generalization
06:46:33 <ski> you generalize this signature over any remaining meta variables, that are *mentioned* in it (and so must be parameters, rather than ones which attained values^Wtypes)
06:46:41 <bzm3r> right
06:46:51 <bzm3r> no, wait
06:46:56 <bzm3r> actually, i don't understand that last sentence
06:47:01 <ski> in the general case, you must make sure that you don't generalize over a meta-variable which was introduced "further out"
06:47:22 <ski> e.g. `(*)' might have been a local definition inside some other definition, whose type-inference introduced a meta variable
06:47:51 <ski> in that case, that meta variable (if left unconstrained) could only be generalized at the point where it was introduced, not in this inner definition
06:48:34 <ski> anyway, in this case, generalization means that we (finally) replace the relevant meta variables (`_d',`_e',`_f') with (*bound* (ordinary) type variables
06:48:37 <ski> like so :
06:48:53 <ski>   (*) :: forall a b c. (a -> b -> c) -> (a -> b) -> (a -> c)
06:48:57 <ski> or, if you prefer
06:49:11 <ski>   (*) :: forall r a b. (r -> a -> b) -> (r -> a) -> (r -> b)
06:49:38 <ski> <bzm3r> actually, i don't understand that last sentence
06:49:38 <ski> hm
06:49:52 <bzm3r> ahh
06:50:13 <ski> the meta variables `_a',`_b',`_c' were not mentioned in the signature (after subtitution of the solution), and so we don't generalize over those
06:50:32 <bzm3r> right
06:50:35 <ski> we only generalize over the "parameters" in the solution
06:51:12 <ski> in case we've collected any constraints (like type class constraints) on parameters, those would also be inserted into the signature, at the generalization step
06:51:34 <ski> like `Ord r' or something
06:52:06 <ski> anyway, the full signature of the polymorphic operation `(*)' should include the explicit `forall'
06:52:47 <ski> however, in many situations, Haskell will implicitly insert the `forall' for you, if you don't write it explicitly. but conceptually, it's always there, otherwise it's not a polymorphic operation
06:53:11 <ski> a function always has a type of shape `... -> ...', and anything that has a type of that shape is a function
06:53:32 <hyperisco> *cough* constructors *cough*
06:53:45 <ski> a polymorphic value always has a type that looks like `forall a. ..a..', and anything that has a type that looks like that is a polymorphic value
06:54:34 <bzm3r> right, ok
06:54:55 <ski> (so, strictly speaking `length', of type `forall a. [a] -> Int', is not a function, but a polymorphic value. one could say it's a polymorphic function. but for short, and because polymorphic instantiation and generalization is implicit in Haskell syntax, we often just say "function" in practice)
06:55:52 <ski> here's an example of where you can't generalize on a meta-variable, because it was introduced "in an outer scope" :
06:56:11 <ski>   elem x0 = looking
06:56:13 <ski>     where
06:56:20 <ski>     looking [    ] = False
06:56:35 <ski>     looking (x:xs) = x0 == x || looking xs
06:56:55 <Ariakenom> hyperisco: you wouldn't say every constructor is a function but not every function is a constructor, then?
06:57:09 <ggole> A simpler example is \x -> let y = x in x, y
06:57:38 <ski> the type of `x0' is say `_a'. and the type of `looking' will be `[_a] -> Bool'. but we can't generalize here and say that `looking :: forall a. [a] -> Bool' (or even `looking :: forall a. Eq a => [a] -> Bool', taking the constraint `Eq _a' into account)
06:57:40 <ggole> Obviously you cannot generalise y, it has to remain the same type as x
06:57:54 * ski nods to ggole
06:57:55 <jusss> >>= f g x = g (f x) x
06:57:59 <jusss> this can use eta-reduce?
06:58:09 <ggole> But it's the same problem, of course.
06:58:13 <jusss> (>>=) f g = g ( f x) ?
06:58:46 <ski> jusss : no. also, strictly speaking it's not about eta reduction, but function extensionality (which is closely related, though)
06:59:24 <ski> jusss : function extensionality says that if `f x = g x', for every `x', then `f = g'. implicit in this is that `f' and `g' doesn't depend on `x'. that requirement doesn't hold in your situation
06:59:26 <jusss> ski this function is really weird g ( f x) x
06:59:35 <hyperisco> Ariakenom, they're different on the term level but generalise the same on the type level, which is why we have what we have
06:59:46 <ski> (eta conversion says that `f' is equal to `\x -> f x'. also here, `f' doesn't depend on `x')
07:00:17 <ski> (obviously, not every constructor is a function ..)
07:00:28 <Ariakenom> eh true
07:00:40 <ski> bzm3r : `elem' example (or ggole's) making any sense ?
07:00:50 <jusss> but when (e->) is monad, this is really weird
07:01:14 <ski> jusss : what do you consider weird about it ?
07:02:04 <jusss> ski: g takes (f x)'s output as input, and return something that could not ralated with this input
07:02:11 <jusss> ski: a->m b
07:02:28 <hyperisco> Ariakenom, a possible imagining is that using a constructor name in an application expression is actually referring to a function
07:02:37 <jusss> a->(e->b)
07:02:40 <hyperisco> that just happens to have the same name
07:02:40 <bzm3r> ski: yep! currently, i am trying to figure out more of this paper: https://www.cs.ox.ac.uk/ralf.hinze/Lifting.pdf
07:03:03 <ski> bzm3r : if you're interested in reading more about type inference, you could try
07:03:08 <ski> @where polymorphic-type-inference
07:03:08 <lambdabot> "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <https://cs.au.dk/~mis/typeinf.p(s|df)>,<http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.57.1493>
07:03:08 <bzm3r> ski i wonder if lifting principle is the same as transfer principle: https://en.wikipedia.org/wiki/Transfer_principle
07:03:47 <hyperisco> and all these functions are defined for us specially by Haskell
07:05:27 <ski> bzm3r : interesting paper
07:06:18 <bzm3r> ski: yeah, it's why i am learning how to read haskell :p
07:06:30 <bzm3r> (otherwise, i am sorry, i prefer to write in Rust -_-)
07:06:43 <bzm3r> (simpler for my 5 year old mind)
07:08:02 <merijn> Ok, anyone know how to turn a megaparsec parse error into something pretty/readable that I can show the user?
07:08:54 <bzm3r> @merijn use machine learning, train algorithm on data set of hand translated errors
07:08:54 <lambdabot> Unknown command, try @list
07:09:03 <ski> hyperisco : some constructors are functions
07:09:25 <merijn> Yeah, I mean something less involved...
07:09:46 <ski> bzm3r : fyi, IRC is not Twitter :) it's not an IRC convention to prefix people
07:10:15 <bzm3r> is @ from twitter?
07:10:16 <hyperisco> what is what changes by how one defines words, and so I can imagine both that statement and the converse being true :P
07:10:20 <ski> bzm3r : 's nicknames/handles with sigils like `@', when address them. simply mention their name, possibly at the start of the message, followed by a colon or comma
07:10:31 <bzm3r> got it
07:10:50 <nbloomf> Running into a new happy error: "happy: grammar does not fit in 16-bit representation that is used with '--ghc'"
07:10:59 <ski> bzm3r : it may come from some other platform, i'm not sure. i know it mostly from having seen it on Twitter (and other platforms, which i imagine may have gotten it from there)
07:11:09 <bzm3r> right
07:12:19 <ski> hyperisco : yea, "Some A are B." is logically equivalent with "Some B are A." :D
07:12:32 <hyperisco> yes I meant negation
07:12:48 <ski> oic
07:13:27 <ski> nbloomf : Happy Happy, Joy Joy ..
07:13:39 <hyperisco> we could refer to objects constructed by λ specifically as functions, and so no constructors are functions
07:13:56 <ski> true
07:14:12 <hyperisco> or we could adopt the story I offered about functions that share names with constructors, in which case no constructors are functions but there is a function for every constructor
07:14:20 <ski> but it tends to be useful to call anything which could be sent where a value of function type is required, a function
07:14:52 <hyperisco> or we could say all inhabitants of -> are functions, in which case all constructors are functions but not all functions are constructors
07:14:56 <ski> (still, in some languages (say OCaml), one can't type something like `map Just xs', instead having to fully apply like `map (\x -> Just x) xs')
07:15:07 <benzrf> hyperisco: nah, constructors like Nothing are not functions
07:15:15 <Solonarv> hyperisco: that story is actually fairly close to how GHC does it, amusingly enough
07:15:16 <hyperisco> yes thank-you
07:17:01 * ski . o O ( "Happy Happy Joy Joy" <https://www.youtube.com/watch?v=HZFTUtbn1RU> )
07:20:25 <nbloomf> :) anyway my google-fu doesn't find any relevant info on what that means or how to fix it
07:21:09 <bzm3r> ski many thanks for your time and patience today :)  i'll be logging off for now
07:41:28 <ggole> It's straightforward to rewrite programs so that constructors are wrapped in functions unless they are fully applied, and that covers zero-argument constructors nicely.
08:03:58 <SabkaBaapThanos> hi everyone, can anyone please tell me what's the best way to extract http objects from a pcap . In my case I want to extract an XLS file out of a TCP stream but it's not available when I am trying to export via file-> export objects> http
08:05:52 <merijn> If I want a subprocess to write stdout and stderr to the same Handle I have to explicitly create a pipe myself and pass that to System.Process, yes?
08:05:53 <elfeck> hi, I have some issues using stack under arch-linux. "stack build" complains that it cannot find the module "Prelude". This is because my arch install does not have the static-linked libraries. But can't I use stack for a local-install of all libraries?
08:06:51 <merijn> (i.e. to get the output properly interleaved as a terminal user would expect)
08:07:26 <Solonarv> elfeck: arch packages Haskell stuff weirdly, I'd recommend not installing it through the package manager
08:08:18 <elfeck> But can't I use stack to deal with all the ghc and package stuff? Why do I need a system-level install at all?
08:08:31 <Solonarv> how did you install stack?
08:08:36 <elfeck> via pacman
08:09:17 <Solonarv> ah, that might be the issue
08:09:27 <Solonarv> try following the instructions here: https://docs.haskellstack.org/en/stable/README/
08:10:39 <elfeck> Mhm, okay I will try that
08:10:48 <Solonarv> huh, actually the stack docs recommend installing it via pacman
08:10:59 <yushyin> I use the pacman stack for my projects but I don't let stack use the system ghc so it downloads its own ghc with static libs
08:11:08 <yushyin> works ok for me
08:11:27 <Solonarv> yeah, that should work
08:12:08 <elfeck> yushyin: How do you not let stack use the system ghc?
08:12:21 <elfeck> I thought this to be the case by default anyway
08:12:31 <Solonarv> it is the default, yes
08:12:39 <elfeck> then why do I have this issue?
08:12:52 <Solonarv> hm, could you paste the full error message somewhere and link it?
08:14:13 <elfeck> https://pastebin.com/yDd9L2Ef
08:18:26 <yushyin> don't know if it always was the default but I did: stack config set system-ghc --global false as a global setting and similiar for my projects
08:18:35 <Solonarv> elfeck: what do your stack.yaml, package.yaml and blahblah.cabal file slook like?
08:18:36 <yushyin> elfeck: you can check with stack path
08:19:19 <yushyin> e.g. for me it shows compiler-exe: /home/yushyin/.stack/programs/x86_64-linux/ghc-tinfo6-8.4.4/bin/ghc
08:19:28 <elfeck> stack path gives me the same, yey
08:19:30 <elfeck> yes
08:19:50 <elfeck> .stack/programs/...
08:20:37 <elfeck> stack.yaml only has resolver and packages: .
08:21:01 <elfeck> hmm
08:22:57 <elfeck> I'll try a "stack new test" and see if I can get the default to build
08:24:17 <yushyin> and check if the *-pkg-db paths from stack path are reasonable
08:26:46 <elfeck> yushyin: https://pastebin.com/21R58Yxu
08:26:51 <elfeck> Looks reasonable to me
08:30:57 <elfeck> okay the test with a "stack new" project works
08:31:31 <elfeck> I guess I will go from there and adapt to my project
08:33:40 <elfeck> Ha okay, so there issue was that I missed to depend on base in the cabal file
08:33:43 <elfeck> facepalm
08:33:56 <Solonarv> yeah, I suspected something like that
08:34:03 <Solonarv> that's why I asked to see the cabal file :P
08:34:13 <elfeck> Yeah. Thanks for the help
08:35:46 <talqu> i can connect through the console like with: `psql -d talqudb -U
08:35:46 <talqu>   talqu`. However `connect defaultConnectInfo { connectDatabase =
08:35:46 <talqu>   "talqudb" , connectUser = "talqu" }` throws me an error  Exception: libpq: failed (FATAL:  no pg_hba.conf entry for host "127.0.0.1", user "talqu", database "talqudb", SSL off
08:35:46 <talqu> 17:29 *** vidbina JOIN
08:35:46 <talqu> 17:29 *** sigmundv__ JOIN
08:51:06 <zincy> talqu: libpq is C code no?
08:52:08 <phadej> talqu: psql uses unix domain by default
08:52:28 <phadej> defaultConnectInfo goes through network-loopdevice (127.0.0.1)
08:52:46 <phadej> talqu: set connectHost = ""
08:53:11 <phadej> "On systems that provide unix domain sockets, omitting the host parameter will cause libpq to attempt to connect via unix domain sockets. "
08:56:26 <talqu> phadej: thank you!
09:06:03 <zincy>  https://www.seas.upenn.edu/~cis194/spring15/lectures/11-stlc.html
09:06:33 <zincy> why can't you have eval :: Exp t -> Value
09:06:40 <zincy> For the final function
09:07:07 <zincy> It isn't intuitive to me that calling eval on an expression could return another expression
09:11:18 <MarcelineVQ> What is Value
09:11:48 <Solonarv> zincy: it doesn't return another expression
09:12:06 <jle`> eval :: Expr t -> t
09:12:26 <zincy> Value would be a sum type of say Int Bool Lambda
09:12:36 <jle`> eval :: Expr Bool -> Bool
09:12:40 <jle`> eval :: Expr String -> String
09:13:04 <jle`> zincy: you know it's not a sum type because you know exactly what the result type is
09:13:39 <jle`> eval :: Expr (String -> Bool) -> String -> Bool
09:13:52 <jle`> and `Expr t` represents an expression producing a 't', so eval gets that t
09:14:20 <jle`> eval plus 1 2 => 3
09:14:23 <jle`>  :: Int
09:14:52 <zincy> ok think I got it
09:15:23 <jle`> so `Expr Bool` represents a Bool, so calling `eval` on an `Expr Bool` should return a `Bool`
09:15:37 <jle`> there's no point in returning a sum type between int/bool/function :)
09:15:49 <jle`> since you already know it's a Bool
09:15:59 <zincy> yeah :)
09:16:01 <jle`> that's like saying negate :: Bool -> Either String Bool, but it will always return Right
09:16:08 <jle`> what's the point in using the Either then
09:16:14 <zincy> I am trying to follow along on my own
09:16:17 <zincy> defineLambda :: String -> a -> Exp b -> ReaderT Scope (Except LangErr) Value 
09:16:35 <zincy> it should return an Exp (a -> b) right?
09:17:04 <jle`> what are the input arguments?
09:17:13 <zincy> so defineLambda :: String -> a -> Exp (a-> b) -> ReaderT Scope (Except LangErr) (Exp (a->b))
09:17:32 <zincy> Name of variable the return type and then the lambda body
09:17:34 <jle`> what is the 'a' and the Exp b/Exp (a -> b) ?
09:17:44 <jle`> look at the type of the Lambda cosntructor in the article
09:17:55 <jle`> Lambda :: String -> Type a -> Expr a -> Expr (a -> b)
09:18:06 <zincy> oh yea
09:19:59 <zincy> Not Expr b
09:20:03 <zincy> for the body?
09:20:11 <zincy> Lambda :: String -> Type a -> Expr b -> Expr (a -> b)
09:20:13 <jle`> sorry yeah, it should be Expr b
09:20:37 <zincy> So Expr b when evaluated gives a b?
09:21:39 <jle`> yes
09:28:29 <dTal> What's the term for a combinator which: takes a function f and returns a combinator that, when applied to another function, returns that function but with f applied to its argument
09:31:07 <dTal> "reverse compose"?
09:31:32 <phadej> :t (>>>)
09:31:34 <lambdabot> forall k (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
09:31:48 <phadej> ((+1) >>> (*2)) 3
09:31:55 <phadej> > ((+1) >>> (*2)) 3
09:31:57 <lambdabot>  8
09:35:14 <infinisil> :t flip (.)
09:35:15 <lambdabot> (a -> b) -> (b -> c) -> a -> c
10:41:32 <dmwit> ?pl \f g x -> g (f x)
10:41:32 <lambdabot> flip (.)
10:53:12 <lyxia> dTal: both (.) and flip (.) can reasonably be called "function composition"
10:53:41 <nshepperd> :t lmap -- also this
10:53:42 <lambdabot> Profunctor p => (a -> b) -> p b c -> p a c
10:54:51 <hyperisco> and can be unreasonably called a function adapter factory
11:01:43 <DigitalKiwi> i'm calling them that from now on thanks for the idea
11:01:58 <jle`> FunctionAdapterFactoryBean
11:03:18 <Berengal> To create a pattern synonym that matches multiple patterns do I have to use a view pattern?
11:03:27 <Solonarv> Berengal: yes :/
11:03:37 <Solonarv> you can use LambdaCase to make it a bit less painful
11:04:11 <Berengal> I guess
11:04:53 <jle`> pattern synonym syntax is meant to be as simple as possible, but that does make doing a lot of things more verbose
11:05:02 <jle`> i believe there are some proposals for pattern synonym sugar
11:06:19 <dTal> lyxia: even when curried? in my original question the combinator doesn't return the composed function, but another combinator which must be applied
11:06:38 <dTal> I use this combinator extensively in a program I'm writing, but I don't know what to call it
11:06:45 <Berengal> I guess allowing multiple bidirectional patterns would be incoherent, but multiple unidirectional patterns should be possible
11:06:46 * ski . o O ( `class Adaptive a b c | a b -> c,a c -> b,b c -> a where adapt :: a -> b -> c' )
11:06:49 <jle`> dTal: do you have the type of the thing you are talking about?
11:07:19 <ski> Berengal : disjunctive / "or"- patterns would be nice to have ..
11:07:31 <dTal> jle`: er, function?
11:07:43 <jle`> dTal: i mean, (a -> b) -> (b -> c) -> (a -> c)
11:07:46 <jle`> something like that
11:07:52 <jle`> is that the right type?
11:07:57 <dTal> I don't know that notation I'm afraid
11:08:21 <jle`> an (a -> b) is the type of a function that takes an 'a' and returns a 'b'
11:08:38 <jle`> hm, how familiar are you with haskell and its idioms?
11:08:45 <dTal> not in the slightest
11:08:57 <dTal> well that's not totally true, but it's true to a first approximation
11:09:19 <dTal> I'm actually writing in Scheme
11:09:27 <jle`> ah okay.  (a -> b) -> (b -> c) -> (a -> c) is function composition because it takes an (a -> b) function and a (b -> c) function, and returns a (a -> c) function
11:09:32 <lyxia> dTal: I mean, flip (.) in Haskell is curried and basically does that.
11:09:40 <Solonarv> Berengal: well, it would just have to be explicitly bidirectional
11:09:45 <jle`> in a way it can also be called 'precompose'
11:09:55 <Solonarv> which is already how it works if you define them with ViewPatterns
11:09:57 <jle`> since giving it f, then g, it returns \x -> g (f x)
11:10:07 <jle`> the function returned applies f before applying g
11:10:27 <dTal> yes, I've called it "pre-apply"
11:10:52 <dTal> since it applies f before calling its argument
11:10:53 <jle`> you could also parenthesize the type as (a -> b) ->  ((b -> c) -> (a -> c))
11:11:08 <jle`> which says that giving it f, returns a function that, given g, returns \x -> g (f x)
11:11:21 <jle`> but in haskell the two concepts are mostly interchangeable
11:11:30 <jle`> the uncurried form would be (a -> b, b -> c) -> (a -> c)
11:11:41 <jle`> given a tuple containing an (a -> b) and a (b -> c), return an (a -> c)
11:11:52 <jle`> it looks like you are looking for the curried form, though
11:11:54 <Berengal> Solonarv: yeah, I've used compose/decompose pairs of functions, but I don't see why I should have to define them as separate functions instead of just repeating the same pattern name like I do for the functions
11:12:07 <jle`> but in haskell we sort of assume all functions we talk about are curried
11:12:12 <jle`> it's a cultural thing, you could say
11:12:40 <jle`> there are a few uncurried functions in the standard library, but they are the exceptions
11:13:14 <dTal> I understand. I would have thought that they'd be distinct concepts
11:13:36 * ski . o O ( `(define (((curried-reverse-compose f) g) . params) (g (apply f params)))' )
11:13:36 <dTal> I don't really have the vocabulary or notation to describe this sort of thing effectively yet
11:13:37 <jle`> yeah, in haskell, culturally, we don't make the distinction really
11:14:17 <jle`> we think of (a, b) -> c and its curried form a -> (b -> c) as essentially the same function
11:14:57 <Berengal> What are the non-curried functions other than "curry"?
11:15:05 <jle`> there are a few in Data.Ix
11:15:27 <dTal> I expect I'll end up using Haskell at some point
11:15:31 <ski> (they are distinct concepts, but multiple argument functions are most commonly encoded in curried style, in haskell, not in tupled style. Scheme, unlike Haskell, actually has a concept of multiple-argument functions (which would be distinct from using curried or tupled style))
11:15:41 <dTal> this project in Scheme is proving extremely educational though, it's making me ask all the right questions
11:15:54 <dTal> hopefully by the time I've finished, Haskell will actually make sense to me
11:15:57 <ski> dTal : what you do think of the `define' i suggested ?
11:16:01 <Berengal> I guess, though I always think of the Ix functions as taking in a single bounds
11:16:23 <ski> (if you really want to, you could throw in some `call-with-values' as well, i suppose ?)
11:16:30 * ski idly wonders whether `compose' does that
11:16:35 <jle`> also System.Random's randomR :: Random a => (a, a) -> g -> (a, g)
11:17:24 <ski> (yes, it seems at least Guile `compose' does)
11:17:38 <bzm3r> ski there is a function with the following signature unit:: i (), now i learned that () is the unit type, so i () means "type i applied to unit type", but the signature for the function does not make sense to me because it does not have a return type?
11:18:01 <dTal> ski: compose is nonstandard, right? Chez doesn't seem to have it
11:18:02 <jle`> bzm3r: that's because it's not necessarily a function :)
11:18:02 <ski> bzm3r : it's not a function
11:18:17 <jle`> bzm3r: in haskell, not all values are functions
11:18:23 <jle`> we have plenty of non-function values.  like, say, Int
11:18:23 <ski> (or, it may be, if `i' is `(rho ->)', say, as jle` hinted slightly at)
11:18:40 <bzm3r> right, i see
11:18:44 <jle`> i could also be Maybe
11:18:50 <dTal> ski: your definition is much more elegant and concise than mine, I'll give it a play in my repl
11:18:58 <bzm3r> :t info Maybe
11:18:59 <lambdabot> error: Variable not in scope: info :: t0 -> t
11:18:59 <lambdabot> error:
11:18:59 <lambdabot>     • Data constructor not in scope: Maybe
11:19:08 <jle`> there is no :info in lambdabot
11:19:14 <bzm3r> ah darn
11:19:17 <bzm3r> %t info Maybe
11:19:26 <geekosaur> % :info Maybe
11:19:27 <yahb> geekosaur: data Maybe a = Nothing | Just a -- Defined in `GHC.Maybe'; instance Alternative Maybe -- Defined in `GHC.Base'; instance Applicative Maybe -- Defined in `GHC.Base'; instance Eq a => Eq (Maybe a) -- Defined in `GHC.Maybe'; instance Functor Maybe -- Defined in `GHC.Base'; instance Monad Maybe -- Defined in `GHC.Base'; instance MonadPlus Maybe -- Defined in `GHC.Base'; instance Semigroup a => Monoid (Maybe
11:19:29 <jle`> but it's the type data Maybe a = Nothing | Just a
11:19:37 <jle`> i could also be [], so unit :: [()]
11:19:40 <geekosaur> you probably want %% instead so it pastebins the whole output
11:19:45 <dTal> ski: it also doesn't work :p 'invalid syntax'
11:19:57 <ski> dTal : if you don't care about being able to pass multiple parameters to `f', it becomes even simpler
11:20:19 <bzm3r> jle` geekosaur ty :)
11:20:28 <bzm3r> ok, i see what unit is now
11:20:53 <jle`> rule #n in haskell: not everything is a function
11:21:01 <dTal> I just have (define (pre-apply f) (lambda (g) (lambda (x) (g (f x)))))
11:21:29 <ski> dTal : yea, not all Scheme implementations support the "curried" `(define (((f a) b c) . ds) ..a..b..c..ds..)' syntax, you may have to revert to plain `(define (f a) (lambda (b c) (lambda ds ..a..b..c..ds..)))' syntax
11:21:51 <hyperisco> every value having a Type type can be made a function, though :D
11:22:30 * ski nods to dTal
11:23:19 <hyperisco> also known as the excessively functional programming style
11:24:09 <bzm3r> does this channel have a preferred pastebin?
11:24:18 <merijn> Not anymore, sadly >.>
11:24:25 <bzm3r> ok, sounds good
11:25:25 <hyperisco> for times when you have composition but no application
11:25:44 <dTal> I've aggressively curried every function because I want to do stuff like (-> triangle (scale 3) (rotate 20) (translate (make-point 2 3)))
11:25:51 <hyperisco> f . const x = f x
11:25:59 <hyperisco> erm
11:26:05 <hyperisco> (f . const x) () = f x
11:27:49 <hyperisco> those working with Arrows likely familiar…
11:30:07 <ski> (preferrably some pastebin without too much extra fluff)
11:30:17 <jle`> ie, not pastebin.com
11:30:36 <hyperisco> this used to be an easy problem to solve…
11:30:44 <ski> dTal : is `->' syntax ?
11:31:30 <dTal> it's a primitive "thrush combinator" inspired by Clojure/Hylang's "threading macro"
11:31:41 <talqu> with servant i receive json data from the client, it gets converted to haskell record using aeson, but then I need pass that data as a tuple to postgresql-simple, cause it accepts the paras in this way. What should I do here? Construct the data manually from one to another form every time? This is why in a bit earlier i saw beam and liked, cause it seems to abstract this this converting issue.
11:31:45 <hyperisco> Can a $5/mo linux machine run lpaste? Hm.
11:32:04 <bzm3r> so i'm playing around with the following theorem: https://repl.it/repls/LightgrayWiseOpengl
11:32:09 <dTal> it applies each of its arguments to its first argument, in sequence
11:32:12 <bzm3r> um, that might have too much fluff
11:32:22 <bzm3r> maybe i should just use github gist?
11:32:36 <hyperisco> that seems to be the new hotness
11:32:58 <ski> you could perhaps try <https://paste.debian.net/> ?
11:33:12 <jle`> one of the big problems with lpaste was having to deal with all the spam i think
11:33:15 <jle`> and abuse
11:33:16 <bzm3r> can i edit the paste?
11:33:23 <bzm3r> on paste.debian?
11:33:23 <MarcelineVQ> hyperisco: It's not about running costs, I would think, but curation of it being the reason it wasn't kept up. otherwise you've just created a new spam serivice and these days everyone wants platforms to be responsible for their content so it's kind of a hassle
11:33:25 <hyperisco> some people suck
11:33:34 * ski misses <paste.lisp.org>
11:33:46 <MarcelineVQ> *for their user posted content
11:33:46 * ski doesn't recall
11:33:47 <bzm3r> https://gist.github.com/bzm3r/7cae620107a6db35d837e17a16983799
11:34:10 <bzm3r> first of all, how bad a crime am i committing by using types as inputs to the functions
11:34:12 <hyperisco> okay, well, here's an idea… an lpaste with an integrated IRC bot that allows trusted people to trust people
11:34:16 <bzm3r> (i am trying ot determine the type of the output)
11:34:17 <hyperisco> by IP
11:34:44 <hyperisco> and an inner ring of super trusty people can revoke trust from the less trusty people
11:35:19 <ski> bzm3r : if you're playing with unicode, you might want to try `UnicodeSyntax'
11:35:26 <bzm3r> there is already one error, let me fix it
11:35:29 <merijn> hyperisco: Well, if you contact Chris you can probably take over lpaste if you have the time/ideas...
11:35:48 <merijn> hyperisco: He sunset it because he didn't have the time to fight spam/maintain it and no one suitable took over
11:35:54 <hyperisco> I have and I know, but… well so this idea might add too much friction
11:36:06 <MarcelineVQ> wonder why there's no lpaste repo so anyone can extend, there wasn't last I checked anyway
11:36:16 <hyperisco> when a newbie shows up and wants to paste some code, they don't know to ask someone for a token/whitelist to paste on our private pastebin
11:36:32 <ski> bzm3r : i can't decipher the "using types as inputs to the functions"
11:36:57 <bzm3r> ski good, because it doesn't work :p  let me fix it all
11:37:05 <ski> hyperisco : "Quis custodiet ipsos custodes?" :D
11:37:16 <hyperisco> so… maybe the IRC bot can send a message here when an untrusted person pastes something
11:37:19 <MarcelineVQ> hyperisco: And non-newbies to irc probably aren't eager to expose their handle to a known ip :>
11:37:33 <hyperisco> then a trusted person will see it and either approve or deny it… could be a source of spam all of its own though, hrm.
11:37:36 <MarcelineVQ> *connect their handle
11:38:08 <___laika> hey all, im looking to start a new CLI project (inspired by the git bug project https://github.com/MichaelMure/git-bug). im trying to think about app architecture ahead of time, and i know "three layer haskell cake" is pretty widely liked right now. i was also looking at the readme for polysemy, and was curious if there are any examples of using it to accomplish something similar to 3LHC?
11:38:17 <hyperisco> well the point is that the curation has to be outsourced to the community, because no one person seems interested in that burden
11:38:29 <ski> bzm3r : also, i think you'll only be able to prove the theorem, for particular `i's, being instances of `Idiom'
11:38:49 <bzm3r> ski yes, that is an assumption, so i will write it out to be precise
11:38:58 <sm> ___laika: one easy route: use rio
11:39:04 <merijn> ___laika: What is "3 layer haskell cake"? I've never heard about that
11:39:10 <jle`> ... i have never heard of three layer haskell cake
11:39:12 <___laika> https://www.parsonsmatt.org/2018/03/22/three_layer_haskell_cake.html
11:39:17 <sm> another: just build the simplest thing that works, adapt as you go
11:39:17 <phadej> https://www.parsonsmatt.org/2018/03/22/three_layer_haskell_cake.html
11:39:18 <MarcelineVQ> hyperisco: Curation is as easy as an expiry date if you just want lpaste's look and features. The hitch there being that one of lpaste's advantages was being able to refer to old non-expiring posts :(
11:39:25 <ski> bzm3r : iow, you'll need to rely on the particular implementations of `pure' and `(◇)', for that `i'
11:39:29 <jle`> and i've been using haskell almost exclusively for six years now heh
11:39:30 <hyperisco> what about just… pastes live only 1 day and there is no paste list… any spam will not be searchable and it will die in 24 hours
11:39:48 <___laika> maybe i should say, "it seemed popular based on the reddit comments i read," hahaha
11:40:06 <merijn> ___laika: Reddit is rather skewed in who comments
11:40:07 * ski seconds MarcelineVQ re old non-expiring
11:40:08 <bzm3r> ski but i don't have a particular implementation, the resource that i am following seems to say i should be able to prove this in general?
11:40:21 * ski used to quote some old posts
11:40:56 <jle`> MarcelineVQ, hyperisco: ah, what if we automatically expired pastes, unless they are posted on irc
11:41:08 <ski> bzm3r : hrm .. well. yea, possibly using other laws then. in that case, you should probably state the laws that you want to employ :)
11:41:09 <jle`> then we shift the burden of spam prevention to freenode
11:41:11 <jle`> he he he
11:41:13 <hyperisco> oh man… I dunno… that is kind of cruel
11:41:24 <bzm3r> ski will do
11:41:26 <MarcelineVQ> jle`: That's an interesting idea actually
11:41:27 <hyperisco> yeah exactly that is what we'd be doing
11:41:28 <___laika> makes sense :) sm: ive read about RIO, and i suppose the nice thing there would be also getting the helpful tweaks to the prelude
11:41:44 <hyperisco> granted, it'd take some deliberation to exploit this system…
11:42:23 <MarcelineVQ> A bot in here that listens for lpaste links and flags them as keepers regardless. Then we can shift the burden to #haskell ops >:D
11:42:27 <jle`> besides the people using it for spam probably just had it as one link in their giant extensible spam system
11:42:54 <MarcelineVQ> The burden there being people coming in just to spam links
11:42:57 <hyperisco> yes this works well assuming spammers are not going to study this system specifically and exploit it
11:43:02 <jle`> it's unlikely they would go through the trouble of programming an IRC distributed bot network for one minor pastebin
11:43:29 <hyperisco> I think it is worth trying on a trial basis… can always shut it down if it really gets out of hand.
11:43:36 <jle`> MarcelineVQ: right, but people already come here to spam links. that's something freenode/ops already handle
11:43:37 <sm> ___laika: your other big decision will be the options parsing lib
11:44:11 <merijn> sm: You mean there's other options than optparse-applicative? >.>
11:44:18 <sm> I like cmdargs, many people like optparse-applicative, and it's worth searching hackage for easier modern alternatives
11:44:21 <MarcelineVQ> sure, like optparse-generic
11:44:36 <___laika> ill do some hackage perusing
11:44:45 <___laika> optparse-applicative was probably where i would have started
11:45:19 <___laika> sm: cmdargs also looks very neat
11:45:23 <merijn> MarcelineVQ: 1) that's just a convenience wrapper around optparse-applicative, and 2) that loses a lot of the flexibility
11:45:34 <MarcelineVQ> drat, foiled again
11:45:44 <hyperisco> jle`, I might have time to work on that this year, but I'll forget by next week =\
11:45:48 <merijn> ___laika: I think cmdargs has WAAAY too much magic and too little control. Actually, that goes for most other options libraries
11:45:59 <jle`> lpaste is open source i believe, so maybe it's not too bad
11:46:12 <jle`> i use optparse-applicative for all my options stuff, it gives me enough control i think
11:46:33 <boj> optsparse-applicative is the bees knees
11:46:34 <merijn> I like optparse because it can (almost) anything, flexible, no magic
11:46:46 <jle`> and it's pretty modern, i'd say
11:47:15 <merijn> Hacking together a dirty/simple thing is easy, but unlike cmdargs it's easy to later expand your initial quick&dirty attempt into something "production" quality
11:48:10 <sm> cmdargs gave me more control than o-a. It provides non-magic API if you want that
11:48:22 <merijn> sm: More control how?
11:48:25 <jle`> but also it's easy to forget that haskell comes shipped with a command line arguments parser library within base
11:48:48 <jle`> in System.Console.GetOpt
11:48:59 <sm> sorry, it's been a few years and I don't remember. Things to do with the fine details of command line UXX
11:49:01 <sm> UX
11:49:17 <jle`> i know it's the system that pandoc uses, and pandoc has a pretty rich CLI interface
11:49:24 <sm> also, back then, cmdargs was far better documented. THings may have changed
11:49:24 <jle`> command line interface ... interface
11:49:38 <___laika> heh
11:49:55 * ski . o O ( "CLInterface" )
11:50:17 <jle`> 'stack' uses optparse-applicative, which is another cli-heavy industrial haskell tool
11:50:44 <zincy> does applicative just denote the interface of the library?
11:50:57 <merijn> zincy: Yeah
11:51:04 <jle`> yeah, and it also guides usage patterns i suppose
11:51:12 <___laika> i think architecture wise, i might start with RIO and see if i can apply the "haskell cake" principles. ill probably start with o-a but cmdargs is also on my radar, we'll have to see
11:51:16 <bzm3r> if someone says "assuming f is curried", this means that "assuming f is a partial function" ?
11:51:20 <merijn> zincy: It's an Applicative parser (as opposed to monadic, like the parsecs)
11:51:26 <zincy> How do you decide as a library author whether to expose an applicative or monadic interface?
11:51:27 <jle`> hm, it looks like System.Console.GetOpt doesn't support subcommands
11:51:39 <jle`> bzm3r: no, it means assuming f is curried (as opposed to uncurried)
11:51:51 <merijn> zincy: I would say it's simple. If there is one (i.e. a lawful instance) you should add it
11:51:57 <jle`> bzm3r: a partial function is a differnet concept; it's a function that doesn't have a result for every possible input
11:52:03 <jle`> bzm3r: you might be thinking "f can be partially applied"
11:52:08 <bzm3r> ah yes
11:52:16 * sm remembers one: cmdargs-based apps accept abbreviations of flags (--dry for --dry-run)
11:52:22 <bzm3r> sorry, you are right, i mean "f HAS been partially applied"
11:52:26 <zincy> merijn: So if it can be monadic it should be?
11:52:32 <___laika> sm++
11:52:33 <merijn> zincy: Yes
11:52:34 <jle`> hm, i think in that case it's different
11:52:43 <zincy> merijn: Simples
11:52:46 <bzm3r> "f is curried" = "f has been partially applied"?
11:52:48 <jle`> bzm3r: if you curry something, it means that you give it the ability to be partially applied
11:52:58 <bzm3r> i see
11:53:09 <jle`> for example, myFunc(x,y) = x + y
11:53:18 <jle`> i can curry it and turn it into myFunc x = \y -> x + y
11:53:23 <jle`> that gives me the ability to partially apply it
11:53:27 <bzm3r> right
11:53:32 <bzm3r> what's a function that cannot be curried?
11:53:37 <jle`> but once i partially apply it, i get back (\y -> x + y), which is arguably not a curried function
11:53:53 <zincy> bzm3r: id?
11:54:07 <jle`> bzm3r: you can curry any function that takes multiple arguments
11:54:14 <bzm3r> right
11:54:19 <jle`> as in, (a,b) -> c type of multiple arguments
11:54:22 <hyperisco> zincy, if there is more than one sensible instance and the purpose of your type is not to select an instance, then it is usual to not provide an instance. Also, possibly the current implementation could be, say, a Monad, but it is known the future implementation can not be.
11:55:05 <bzm3r> jle`(a,b) is just a tuple, right?
11:55:16 <jle`> yeah
11:55:19 <hyperisco> Also in some situations the purpose of the type is very specific, and so while an instance could be provided it is not a foreseeable necessity.
11:55:27 <zincy> hyperisco: What do you mean by not providing an instance? Allow the user to define their own?
11:55:52 <hyperisco> zincy, users cannot define their own unless they allow orphan instances, which is is an all bets off sort of ordeal.
11:56:20 <zincy> hyperisco: Is there ever a situation where it would be beneficial to not provide an instance?
11:56:27 <hyperisco> I just outlined three :P
11:57:04 <jle`> sometimes people also withhold the instance to guide how users use the type
11:57:28 <jle`> but this is a controversial reason
11:57:37 <zincy> hyperisco: Thanks, the third doesnt look like a benefit?
11:57:48 <zincy> hyperisco: looks like a case where it just doesn't hurt
11:58:03 <jle`> well, it becomes a breaking API change when you update your type
11:58:13 <hyperisco> the benefit is on the author, because why spend effort implementing instances that almost certainly will go unused
11:58:36 <zincy> I see
11:59:05 <zincy> So many considerations for writing good libraries
11:59:09 <hyperisco> there is the option anyways to add them later if they are needed
11:59:30 <jle`> zincy: it's an art :)
12:01:21 <hyperisco> also, given an implementation, there are some instances which would be possible but would reveal unintended detail
12:02:24 <hyperisco> this is related to "could be a Monad now but may not be in the future" … sometimes you need to give yourself room to wiggle, as a library author
12:03:15 <bzm3r> does the first step in this proof make sense to you: https://gist.github.com/bzm3r/7cae620107a6db35d837e17a16983799
12:03:30 <hyperisco> also some instances would be surprisingly awful… technically there are possible Eq instances for functions
12:04:10 <hyperisco> such as  (BoundedEnum a, Eq b) => Eq (a -> b)
12:04:33 <jle`> that specific example might fall under the multiple-possible-instances case
12:05:13 <bzm3r> right, so they are assuming an instance?
12:05:32 <bzm3r> oh
12:05:33 <bzm3r> sorry
12:05:45 <bzm3r> you are responding to hyperisco
12:05:48 <geekosaur> there's a package for that (universe)
12:07:16 <bzm3r> ski jle` geekosaur: https://gist.github.com/bzm3r/7cae620107a6db35d837e17a16983799 --- does the first step of the proof for this theorem make sense to you?
13:10:45 <mulderr> looking for a cross platform recursive directory copy that preserves symlinks on linux (like cp -r), any library recommendations?
13:17:44 <zachk> mulderr, not sure, check out rsync maybe! with a bunch of options , sure cp -r doesn't preserve symlinks? 
13:19:08 <tdammers> yeah, rsync should be able to do that
13:23:41 <mulderr> i think it does, ideally i'd rather not have to rely on whats in the path or spawn any addional processes but hey if there isn't anything nice out there then sure, whatever works
13:29:43 <Berengal> What would be the easiest way for complete beginners to install haskell on windows? Stack?
13:30:52 <zeta> can someone help me fix my xmonad.hs file, the volume and brigtness are not working ?
13:30:54 <Berengal> Or haskell platform maybe?
13:33:02 <zeta> Berengal: first i would recommend removing windows and replacing it with linux
13:34:09 <boj> Berengal: Look at Haskell Platform, a new version was just released and it covers what you would need
13:35:23 <zeta> can someone please take a look at my xmonad.hs: https://hastebin.com/iduyufamoq.rb
13:36:34 <zeta> the volume and brightness keys are not working ?
13:36:47 <Berengal> I haven't used haskell platform myself, but I've heard it doesn't always play nice
13:38:41 <aveltras_> is there a way to make this code typecheck https://gist.github.com/aveltras/5154d07b7e861f5381d317ceab42ae6b ? until now, ghc complains about a mismatch between a and Bool
13:38:51 <boj> Berengal: i have never used it, but the Windows using members of my team that do out of band development say it works fine
13:39:16 <boj> Berengal: if you are just getting started, it is perfectly reasonable
13:39:49 <Berengal> boj: I'm not the one getting started, I'm looking into creating sort of an intro to comp-sci tutorial package
13:40:09 <boj> gotcha. still seems reasonable if you are targetting Windows users
13:40:38 <Berengal> Yeah, I was looking at a plain ghc installer, but it seems those aren't around anymore?
13:41:05 <boj> i am honestly not sure
13:41:43 <Clint> zeta: are you sure your keyboard is sending the right codes?
13:42:40 <Solonarv> Berengal: I use chocolatey and it seems to work quite well
13:43:12 <Solonarv> for the past few months I harshly advised against using the haskell platform on windows, because ghc 8.6.3 is horribly broken on windows
13:43:27 <Solonarv> but now there is an 8.6.5 platform release so it should work
13:43:35 <lyxia> aveltras_: https://gist.github.com/Lysxia/53cce1f2ceea07c9e7f618f2cd811bab
13:44:23 <Solonarv> Berengal: if people are on win10 there is also the option to just work in WSL and pretend you're using linux
13:44:42 <zeta> Clint: yes, my volume was working fine a while ago, but now its not working, and i am not sure if the brightness is working because i hav to give it root permission to write
13:45:28 <Berengal> Solonarv: Thanks for the suggestions
13:46:43 <aveltras_> lyxia: thanks !
13:47:02 <zeta> if someone could please help me fix this: https://github.com/giovanifss/xmonad-brightness https://hastebin.com/inozusuqel.sql https://hastebin.com/iduyufamoq.rb
13:48:51 <zeta> i am getting this error in the #xmonad channel: `#xmonad: Cannot send to nick/channel`
13:49:11 <zeta> why is this ?
13:51:43 <geekosaur> channel is set to only allow people identified with nickserv to speak, because of a spam attack several months ago. unfortunately nobody int here currently seems tohave ops to clear it
13:52:46 <zeta> geekosaur: so how do i get in there, i need to ask them for help
13:52:49 <yushyin> https://freenode.net/kb/answer/registration
13:53:11 <yushyin> zeta: see ^
13:54:56 <zeta> ok
14:06:56 <monochrom> Hi I showed running ghcup in my class.
14:09:50 <Rembane> Did it work?
14:10:17 <monochrom> Yes! Surprised at how little I needed to customize etc.
14:10:45 <monochrom> Only worry was "OK now 80 students are going to download GHC at the same time and clog the university network" :)
14:11:39 <Rembane> :D
14:11:46 <monochrom> And all those "ghcup rm 8.6.3" and "ghcup set 8.6.5" etc are pretty sweet.
14:12:12 <monochrom> Also very happy that it downloads both ghc and cabal-install.
14:12:15 <Rembane> Nice! It needs bittorrent support so all students can clog the wifi without clogging the internetz
14:12:29 <monochrom> haha
14:16:51 <Solonarv> I mean, now you've replaced "80 students download GHC" with "80 students download a bittorrent client"
14:16:56 <Solonarv> is that better? I don't know!
14:17:03 * Solonarv mumbling in IPFS
14:17:22 <monochrom> Yes, usually bittorrent clients are so much smaller than GHC.
14:17:50 <monochrom> Unless it's Vuze, but that's on Windows.
14:18:00 <Rembane> I just assumed that all students already have a bittorrent client.
14:18:39 <monochrom> I didn't show Chocolatey but I showed them the web pages.
14:19:20 <monochrom> So I have caught up with the 21st century again. :)
14:19:35 <Solonarv> Rembane: well, perhaps, but ghcup would need to somehow check whether there is a bittorrent client present
14:20:32 <Solonarv> perhaps in the distant future it could have flags like '--bittorrent', '--ipfs' to select a different download method
14:20:59 <monochrom> Um I heard it's already a thousand lines of shell script code.
14:21:40 <Solonarv> eh, what's a few hundred more :P
14:21:52 <Solonarv> to be clear, I'm not super serious about this
14:22:21 <monochrom> heheh
14:23:41 <MarcelineVQ> Do they generate the shell code? :>
14:25:19 <Rembane> Solonarv: It's the future! :)
14:25:41 <Solonarv> what's the future?
14:25:56 <Rembane> Bittorrent flags!
14:35:56 <noipmusp> Once I saw a trick that you can specify cabal stuff inside your .hs file and have everything inside one Haskell source file. Do I remember it correcly?
14:36:22 <noipmusp> I'm unable to Google it.
14:37:42 <Xal> Maybe a `stack exec` shebang?
14:37:50 <Solonarv> works with cabal too
14:37:55 <Solonarv> one sec
14:39:13 <Solonarv> noipmusp: Xal: https://cabal.readthedocs.io/en/latest/nix-local-build.html#cabal-v2-run
14:39:22 <aplainzetakind> What do I read to properly learn the commonalities and distinctions between mtl and transformers enough to decide when to use what from which? I'm using whatever function I find first that does what I need from either at the moment, mixing everything up pretty randomly.
14:39:41 <Solonarv> aplainzetakind: mtl reexports all the transformers stuff
14:39:46 <noipmusp> Solonarv: That's it. Thank you very much!
14:40:01 <Solonarv> so usually I just use mtl and don't even depend on transformers directly
14:40:31 <monochrom> The typeclasses like MonadState live in mtl.  If you don't need them, you can stay with transformers, but no harm going mtl either.
14:42:44 <monochrom> If you want to read more than sentence then you will have wait for me to write the history book that's completely irrelevant.
14:42:55 <monochrom> s/than sentence/than two sentences/
14:43:14 <aplainzetakind> So in my imports all the Control.Monad.Trans.Foo's can be replaced by plain Control.Monad.Foo's?
14:43:29 <Solonarv> pretty much
14:43:44 <monochrom> But the synopsis is that the division-of-labour status you see today is a result of a peace treaty. A decade ago they were rivals implementing the same darn thing.
14:43:51 <Solonarv> technically the functions exported from mtl aren't the same as the ones exported from transformers
14:44:42 <aplainzetakind> Where does that put the "reexports everything" statement? Reexports the things it doesn't reimplement?
14:45:08 <Solonarv> since mtl exports polymorphic ask, put, get etc - they're typeclass methods - but transformers exports functions expecting "their" transformer to be at the top of the stack
14:45:13 <monochrom> StateT is defined in transformers. mtl reexports transformers's StateT, then adds MonadState.
14:45:25 <aplainzetakind> I see.
14:45:45 <aplainzetakind> I want to use MonadIO etc. so mtl it is I guess.
14:45:51 <aplainzetakind> Thanks both.
14:45:53 <Solonarv> actually MonadIO is in base :P
14:46:10 <Solonarv> the other classes aren't though
14:46:31 <aplainzetakind> Heh.
14:46:38 <jgt> if Haskell ever had an "there's an app for that" style catchphrase, it might be "actually it's in base"
14:47:32 <Solonarv> or: oh there's a GHC extension for that
14:47:51 <monochrom> By the time the polar caps completely melt, lens will be in base.
14:48:09 <jgt> "…For everything else, there's RankNTypesCard!"
14:49:16 <monochrom> Oh hi bgamari we're just talking about: When will lens be in base?!  >:)
14:51:19 <zeta> the volume was working before, now it is not working? https://hastebin.com/
14:51:37 <zeta> https://hastebin.com/kanofecute.rb
14:52:17 <jgt> interesting that this Haskell stuff has a ruby file extension
14:52:37 <zeta> what is wrong with my xmonad.hs
14:53:00 <Solonarv> hastebin is weird like that, I have no idea how it decides on the extension tbh
14:53:01 <zeta> jgt: i don't know why hastebin does that
14:55:45 <zeta> i think i see a mistake on lower volume, extra space, lets see if that fixes it
15:01:44 <geekosaur> spaces shouldn't matter
15:01:53 <aplainzetakind> I guess there's no generic `runTransStackAllTheWayToIO :: MonadIO m => m a -> IO a`?
15:02:36 <monochrom> No.  StateT Int IO a requires an extra Int parameter, for example.
15:02:38 <c_wraith> you can just change the url to end with .hs
15:02:53 <c_wraith> which also improves the syntax highlighting.
15:03:05 <aplainzetakind> monochrom: Ah, right.
15:03:56 * monochrom considers https://hastebin.com/kanofecute.py5 :)
15:04:22 <c_wraith> python 5 is a truly advanced language
15:07:29 <dmwit> My next debugging step would be to check whether that pactl command works from a terminal. If not, it probably prints some error message that will have more information than you have now; if it *does* work that is also some new information that you don't have right now.
15:08:12 <jgt> dmwit: I was going to suggest that or checking the @DEFAULT_SINK@ value, but I think zeta has left the room
15:14:25 <zeta> i had made a change a while back and the volume stopped working, when i tried to to change it back the volume is still not working?
15:14:31 <zeta> https://hastebin.com/okucifobey.rb
15:15:08 <zeta> is there a mistake somewhere ?
15:15:29 <zeta> i have no idea what to do at this point
15:17:27 <dmwit> zeta: My next debugging step would be to check whether that pactl command works from a terminal. If not, it probably prints some error message that will have more information than you have now; if it *does* work that is also some new information that you don't have right now.
15:17:46 <aplainzetakind> Is there a warning for unused extensions?
15:18:58 <dmwit> I don't know of one. Also it seems kind of hard. e.g. if I turn on both GADTSyntax and GADTs, is one of them unused? Which one?
15:19:14 <dmwit> There's almost certainly other extension pairs like that.
15:19:46 <jgt> doesn't hlint warn against unused extensions in some cases?
15:19:51 <zeta> well the thing is the volume was working fine before. i accidentily made a change to the volume settings, it stopped working, then when i tried to change it back it still is not working ?
15:20:04 <jgt> zeta: bisect your config
15:20:12 <dmwit> By the way, there's also a #xmonad that you may be interested in.
15:20:15 <jgt> zeta: we have no way of knowing what magically changed in your system
15:20:30 <aplainzetakind> zeta: Try redirecting the output of pactl to some file and check what you get?
15:20:43 <aplainzetakind> (in the argument of spawn)
15:21:17 <zeta> jgt: everything works except for the volume
15:21:57 <zeta> dmwit: i can't access monad so i have to ask the questions here
15:22:11 <jgt> it's xmonad, not monad
15:22:11 <Solonarv> dmwit: warning about unused extensions seems hard
15:22:26 <zeta> aplainzetakind: how do i do that ?
15:22:27 <Solonarv> warning about redundant extensions seems doable, though
15:23:04 <Solonarv> note: an extension is redundant if it's already implied by some other extension
15:23:29 <jgt> zeta: open up your terminal on your computing machine, and type the following at the command line interface: pactl set-sink-volume @DEFAULT_SINK@ +1.5%
15:23:51 <zeta> my guess is that the code works, but when i made a change a while back i jacked upped my system
15:24:08 <monochrom> Genetic algorithm to prune unused extensions. :)
15:24:16 <aplainzetakind> spawn "pactl [arguments] > ~/somefilename" 2>&1"
15:24:21 <jgt> anyone ever feel like they're talking into the void?
15:24:36 <aplainzetakind> then from the terminal issue `less ~/somefilename`
15:25:03 <monochrom> jgt: Yes. I solved it by talking to (). >:)
15:25:06 <zachk> jgt, sometimes 
15:25:21 <jgt> monochrom: heeeyyyooooo
15:25:31 <zachk> jgt, or like you say something and it ends the conversation on irc :( 
15:25:39 <zeta> jgt: that command does nothing ?
15:25:54 <jgt> zeta: so maybe that's your problem?
15:25:57 <aplainzetakind> zeta: So it's not an xmonad problem.
15:26:07 <jgt> zeta: maybe xmonad is fine, and that command doesn't actually work properly
15:26:41 <jgt> zachk: conversation is still going, so you weren't guilty of that this time!
15:26:51 <Solonarv> jgt: yes, generally that happens whenever fen is around
15:27:24 <jgt> Solonarv: not familiar with them; I'm not one of the cool kids!
15:27:49 <Clint> don't worry, this channel provides frequent opportunities to be ignored
15:27:55 <jgt> XD
15:28:22 <zachk> jgt, is it still going? ;) 
15:28:23 <zeta> exactly, the xmonad volume was working fine this whole week, now its not working anymore, how strange ?
15:28:45 <monochrom> Someone hacked into your computer.
15:28:59 <geekosaur> check what the default sink is set to, maybe it's set to the wrong device
15:29:09 <monochrom> Like, at this point, why don't we just go wild with tinfoilhat theories.
15:29:13 <aplainzetakind> Or just use plain alsa/
15:29:25 <zeta> no it was a stupid change i made earlier
15:29:28 <DigitalKiwi> monochrom: were they practicing for Cale?
15:29:38 <monochrom> haha
15:30:13 <zeta> geekosaur: how do i do that ?
15:30:30 <geekosaur> pactl list sinks (but this only shows available ones, not which is default)
15:30:37 <josiah> What's the best book for learning intermediate Haskell?  I have a good grasp of monads, monad transformers, abstract types, and the like
15:30:46 <aplainzetakind> zeta: There's #pulseaudio
15:30:56 <josiah> but not such a good grasp on parallel and concurrent programming, or distributed computing
15:31:08 <DigitalKiwi> there's a book on that
15:31:08 <Solonarv> DigitalKiwi: I understood that reference
15:31:14 <Solonarv> @where parconc
15:31:14 <lambdabot> https://www.safaribooksonline.com/library/view/parallel-and-concurrent/9781449335939/
15:31:19 <Solonarv> ^- josiah
15:31:22 <josiah> oh, well, damn
15:31:34 <DigitalKiwi> i haven't read all of that but what i have read was good
15:31:36 <josiah> is that a decent book on the subject?
15:31:42 <josiah> answers my question
15:31:50 <josiah> awesome, I'm getting to work, then
15:32:02 <Solonarv> it's considered the authoritative book on the subject in the context of Haskell, I think?
15:32:08 * Solonarv hasn't read it yet
15:32:09 <zeta> no one is on #pulseaudio
15:32:13 <jgt> monochrom: https://youtu.be/owgckeaMlxU?t=250
15:32:17 <Solonarv> zeta: be patient
15:32:25 <aplainzetakind> How many items are in @where? And how do you retain all the synonyms? Or is it some smart fuzzy finder?
15:32:29 <Solonarv> it's around midnight in europe
15:32:34 <jgt> monochrom: re: hacking
15:33:10 <Solonarv> aplainzetakind: in order: at least 12; I see people use them frequently; and no, it's just a dumb dictionary AFAIK
15:33:16 <josiah> what about some good explanations of some things like flexibleinstances/contexts and forall?
15:33:43 <josiah> I still kinda struggle with those concepts a bit in comparison to GADTs and other things I've seen listed as prereqs to advanced haskell
15:33:45 <jgt> josiah: https://ocharles.org.uk/posts/2014-12-01-24-days-of-ghc-extensions.html
15:34:18 <josiah> jgt: thanks
15:34:22 <jgt> though it doesn't cover those you mentioned :(
15:34:30 <josiah> wow, fast responses, really appreciate it
15:34:45 <josiah> that's okay, I'm still in the information foraging stages
15:35:02 <josiah> I'll read anything that is generally useful to know when working in real world haskell projects
15:35:21 <josiah> I'm wanting to get involved in oscoin and Radicle
15:35:22 <DigitalKiwi> there's a book on that
15:35:26 <jgt> this room is usually pretty quick with responses
15:35:32 <Cale> josiah: So, in Haskell 98 (and 2010), when you make an instance, it must be for a type constructor applied to a bunch of type variables. You're not allowed to specialise anything further than that.
15:35:36 <jgt> and this room is full of geniuses
15:35:38 <jgt> and one clown
15:35:44 * DigitalKiwi is the clown?
15:35:57 * jgt is feeling out-clowned
15:36:14 <Cale> josiah: FlexibleInstances relaxes that constraint in instance heads.
15:36:15 <DigitalKiwi> we can both be clowns it's ok
15:36:18 <josiah> ah, wait, I remember needing to do this once upon a time when I was first learning 3 years ago or so
15:36:45 <josiah> you can, say, Either a b, but not Either a String
15:36:52 <josiah> unless you have flexible instances, right?
15:37:04 <Cale> right
15:37:17 <Cale> If you were making an instance of a class
15:37:33 <josiah> so what is flexiblecontexts, then?
15:37:34 <Cale> instance Foo (Either a String) wouldn't be a valid instance head in Haskell 98
15:37:42 <jle`> josiah: it's the same thing, but for typeclass constraints
15:37:46 <Cale> There's a similar restriction on the superclasses of a class declaration
15:37:54 <Cale> and FlexibleContexts relaxes that
15:38:01 <jle`> myFunc :: Foo (Either a String) => a -> Int
15:38:02 <josiah> ah, okay, that makes sense
15:38:08 <ski> @where PCPH
15:38:08 <lambdabot> "Parallel and Concurrent Programming in Haskell" by Simon Marlow in 2013 at <http://community.haskell.org/~simonmar/pcph/>,<http://chimera.labs.oreilly.com/books/1230000000929/>,<https://web.archive.
15:38:08 <lambdabot> org/web/20180117194842/http://chimera.labs.oreilly.com/books/1230000000929>,<https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/>
15:38:19 <jle`> `myFunc :: Show [a] => [a] -> String` is illegal i believe
15:38:36 <jle`> without -XFlexibleContexts
15:38:48 <jle`> er wait, maybe i got that wrong
15:38:58 <Cale> nah, Haskell 98 is fine with that kind of thing
15:39:11 <jle`> oh yeah it didn't work in my ghci, so it's forbidden
15:39:15 <josiah> hmm, yah, I was going to say, a List of 'a's is still abstract
15:39:22 <Cale> er
15:39:28 <jle`>     • Non type-variable argument in the constraint: Show [a]
15:39:30 <jle`>       (Use FlexibleContexts to permit this)
15:39:32 <jle`>     • In the type signature: myFunc :: Show [a] => [a] -> String
15:39:41 <Cale> oh, huh
15:39:45 <josiah> oh, hmm, good to know
15:39:53 <josiah> what about forall?
15:40:04 <jle`> i guess constraints are only allowed to be on the type variables
15:40:05 <josiah> that's the other thing I had trouble wrapping my head around in type definitions
15:40:55 <jle`> forall is always implicit in type signatures with type variables, but writing it in explicitly can help us be explicit with what we mean
15:40:56 <Cale> josiah: forall is introduced by several different extensions, depending on exactly what sort of forall you need.
15:41:15 <jle`> "forall a. blah" means that the type signature should work for *any* choice of 'a'
15:41:19 <Cale> josiah: It allows you to be explicit about where type variables are bound
15:41:33 <Cale> So, you can e.g. write functions which insist that their arguments are polymorphic
15:41:38 <Cale> (RankNTypes)
15:41:43 <jle`> `myFunc :: forall a. a -> a` means that myFunc has to work for any (all) choices of 'a'
15:42:14 <jle`> defining myFunc :: a -> a, the forall is implicit, but it's still there
15:42:27 <Cale> Or you can write data types which have data constructors which are polymorphic in variables not mentioned in the type (ExistentialQuantification)
15:42:28 <josiah> as in, the function has to work for all possible type instances that could take the place of 'a'?
15:42:32 <Cale> yeah
15:42:46 <jle`> yes. so `myFunc _ = True` is not a valid implementation
15:42:51 <jle`> because that would only work if 'a' were Bool
15:42:57 <Cale> :t runST
15:42:58 <lambdabot> (forall s. ST s a) -> a
15:43:13 <Cale> So that's like  forall a. (forall s. ST s a) -> a
15:43:32 <Cale> This means that the caller of runST doesn't get to choose the type s, instead, runST will determine it
15:43:34 <josiah> ah, okay
15:43:36 <Solonarv> % :set -fprint-explicit-foralls
15:43:36 <yahb> Solonarv: 
15:43:43 <Solonarv> % :t runST -- :D
15:43:43 <yahb> Solonarv: forall {a}. (forall s. ST s a) -> a
15:43:44 <Cale> and 'a' must be selected in a way which is independent of s
15:44:00 <jle`> one way a lot of people like to think of 'forall' is as a type lambda that brings a into scope
15:44:11 <jle`> foo :: \a. a -> a
15:44:19 <jle`> so foo @Int :: Int -> Int
15:44:25 <jle`> foo @Bool :: Bool -> Bool, etc.
15:44:41 <Cale> yeah, it's like there's an invisible type argument being provided implicitly at the term level
15:44:47 <josiah> so what's RankNTypes, then?
15:44:59 <bzm3r> what do the asterisks in this represent?
15:45:02 <bzm3r> https://i.imgur.com/MfJTsXz.png
15:45:06 <Cale> RankNTypes is what lets you put forall to the left of a -> in types
15:45:08 <jle`> normally in haskell you are only allowed to 'forall' the very top level
15:45:09 <Cale> like the type of runST
15:45:18 <josiah> oh, right
15:45:22 <jle`> or hm, cale's description is more correct
15:45:25 <josiah> rankn lets you nest foralls
15:45:38 <jle`> bzm3r: it's the kind of types that can have values
15:45:40 <josiah> get it
15:45:53 <jle`> bzm3r: or 'fully saturated' type constructors
15:45:58 <Solonarv> RankNTypes makes the following legal: '(forall ...) -> ...'
15:46:02 <bzm3r> ah ok, i'll look it up
15:46:09 <Cale> bzm3r: Just as terms have types, types have kinds, and * is the kind of types which have values. * -> * is the kind of types which accept a type argument and produce an ordinary type
15:46:11 <jle`> bzm3r: look up the concept of 'kinds' in haskell
15:46:20 <Solonarv> so, functions that insist that their arguments must be polymorphic
15:46:25 <jle`> josiah: note that foralls to the right of -> are still Rank-1
15:46:27 <Cale> and then * -> * -> * is types which take two type arguments and produce a type
15:46:36 <jle`> for example, const :: forall a. a -> (forall b. b -> a)
15:46:46 <jle`> this is "nested", but it's still technically rank-1
15:46:58 <jle`> because you can float the b all the way back to the top without changing the meaning
15:47:21 <Solonarv> % foo :: (forall a. a -> a -> a) -> (Int, Char); foo f = (f 3 4, f 'a' 'z')
15:47:21 <yahb> Solonarv: 
15:47:27 <bzm3r> i suppose i am not sure what it means to say "the kind of types which have values"
15:47:34 <Solonarv> ^- there is a (somewhat contrived) example
15:47:38 <bzm3r> i understand kind -> type -> term classification
15:47:44 <jle`> bzm3r: for example, "Maybe" is a type, but you can't have any values of type Maybe
15:47:52 <Solonarv> % foo (\x _ -> x)
15:47:52 <yahb> Solonarv: (3,'a')
15:48:02 <Cale> bzm3r: Types such as Integer, Char, String, Int -> Bool, Maybe Double, etc. etc.
15:48:02 <Solonarv> % foo (\_ y -> y)
15:48:02 <yahb> Solonarv: (4,'z')
15:48:13 <bzm3r> ah i see
15:48:15 <Cale> bzm3r: But then think about something like  Maybe
15:48:15 <jle`> i think maybe "the kind of fully saturated type constructors" may be more useful, since there are a lot of kind-* types that 'don't' have any values, technically
15:48:28 <Cale> bzm3r: It isn't something which has values, it's a type-level function on types
15:48:48 <bzm3r> alright, i'm going to read up type families
15:48:50 <Cale> It has kind * -> *, because it takes an ordinary type as its argument, and produces another
15:48:54 <jle`> Maybe :: * -> *
15:49:02 <Cale> This isn't type families, though they have kinds as well
15:49:11 <jle`> Maybe takes a *-kinded type, and returns a new *-kinded type
15:49:14 <Cale> Maybe is just an ordinary parametric data type
15:49:17 <jle`> so Maybe Int :: *, Maybe Bool :: *
15:49:20 <jle`> but Maybe Maybe is a kind error
15:49:21 <Cale> of the Haskell 98 variety :)
15:49:21 <aplainzetakind> Is it accurate to say Maybe is a type really?
15:49:26 <Cale> yes
15:49:32 <jle`> it's a type in the sense that it can have an instance of a typeclass
15:49:32 <Cale> But it's not a type of kind *
15:49:37 <Cale> It's a type of kind * -> *
15:49:44 <jle`> s/have/be ?
15:50:02 <aplainzetakind> rather than the type constructor description you gave.
15:50:04 <bzm3r> i'm sorry, but can i have an "explain like i'm 5"? 
15:50:29 <Cale> bzm3r: Well, are you already familiar with what Maybe is?
15:50:29 <jle`> on what part?
15:50:32 <jle`> ]\
15:50:37 <bzm3r> here's what i understand so far: * is a kind which can hold a value
15:50:43 <bzm3r> there are kinds of types which do not hold values
15:50:47 <Cale> * is the kind of types which can have values
15:51:06 <Cale> yep
15:51:13 <Cale> :k Maybe
15:51:15 <lambdabot> * -> *
15:51:15 <bzm3r> what is the difference between "* is the kind of types which can have values" and "* is the kind of types which do not hold values"?
15:51:18 <Cale> :k Integer
15:51:19 <lambdabot> *
15:51:21 <bzm3r> sorry
15:51:27 <Cale> :k Maybe Integer
15:51:28 <lambdabot> *
15:51:32 <bzm3r> what is the difference between "can have value" and "can hold value"?
15:51:32 <Cale> :k Either
15:51:33 <lambdabot> * -> * -> *
15:51:42 <Cale> nothing
15:51:46 <bzm3r> ok, sweet
15:51:54 <Cale> you said "* is a kind which can hold a value"
15:51:59 <bzm3r> yes
15:52:01 <Cale> and it doesn't hold values directly
15:52:21 <Cale> It holds types which then hold values :)
15:52:22 <bzm3r> i wrote: "* is the kind of types which can have values"
15:52:37 <bzm3r> wait
15:52:37 <Cale> <bzm3r> here's what i understand so far: * is a kind which can hold a value
15:52:38 <bzm3r> sorry
15:52:45 <bzm3r> you're right
15:53:06 <bzm3r> okay, i see now.
15:53:12 <Cale> :k Either
15:53:14 <lambdabot> * -> * -> *
15:53:15 <Cale> :k Either String
15:53:16 <lambdabot> * -> *
15:53:19 <Cale> :k Either String Double
15:53:20 <lambdabot> *
15:53:25 <Cale> :k StateT
15:53:26 <lambdabot> * -> (* -> *) -> * -> *
15:53:29 <Cale> :k StateT Integer
15:53:30 <lambdabot> (* -> *) -> * -> *
15:53:32 <Cale> :k StateT Integer IO
15:53:33 <lambdabot> * -> *
15:53:35 <jle`> when you read a kind signature like Ix :: * -> * -> *, it means that Ix needs two arguments to be "fully saturated"
15:53:38 <Cale> :k StateT Integer IO String
15:53:39 <lambdabot> *
15:53:43 <jle`> so you can haev a value of type `Ix Int Bool`
15:53:50 <jle`> but you can't have a value of type `Ix Int`
15:53:56 <bzm3r> ah i see
15:53:58 <jle`> in addition, the two arguments must be kind-*
15:54:06 <jle`> so you can't have an `Ix Maybe IO`
15:54:41 <bzm3r> right
15:55:04 <bzm3r> why are there three asterisks though, if it only needs two *-kind types to be saturated?
15:55:18 <Cale> Because it produces something of kind *
15:55:23 <Cale> after you provide those things
15:55:31 <jle`> bzm3r: like Int -> Bool -> String, as a type signature
15:55:32 <Cale> It's actually right-associating, like other function types
15:55:32 <aplainzetakind> I have no problem accepting datakinds as types but the "type constructors are types too" thing really bugs me.
15:55:34 <bzm3r> i see
15:55:38 <Cale> * -> (* -> *)
15:55:49 <infinisil> I think it's a lot easier to think of * = Type
15:55:54 <Cale> So you provide one type of kind *, and get something of kind * -> *
15:55:58 <jle`> an Int -> Bool -> String takes an Int, and a Bool, and returns a String
15:56:05 <Cale> to which you can provide another type of kind *
15:56:12 <Cale> and then it results in a type of kind *
15:56:20 <jle`> aplainzetakind: 'type constructors are types' is conflating two levels of meaning, i think
15:56:33 <jle`> but 'Either String is a type too' is probably what you mean to say
15:56:34 <bzm3r> so is Ix a function?
15:56:34 <Cale> Type constructors may or may not have parameters
15:56:42 <Cale> Integer is a type constructor, for example
15:56:46 <jle`> 'type constructors' is mostly a concept on the AST level
15:56:47 <aplainzetakind> jle`: Yes.
15:56:55 <bzm3r> (i.e. is a type constructor a function?)
15:56:57 <Solonarv> infinisil: yes, I've seen a surprising number of new learners confused by the * notation
15:56:59 <aplainzetakind> Why is that not an instance of what I said?
15:57:08 <jle`> and has some implications in unification too
15:57:20 <Cale> aplainzetakind: What's the problem with Integer being a type?
15:57:30 <aplainzetakind> Cale: No problem.
15:57:30 <Cale> It's a type constructor
15:57:31 <jle`> aplainzetakind: something being a type constructor doesn't say anything about its kind
15:57:45 <jle`> and we're not saying that Maybe is a type because it's a type constructor
15:57:56 <Cale> Type constructors are the things which have uppercased names at the type level. They can be pattern matched by instances.
15:58:06 <aplainzetakind> Alright, I don't have the right term to distinguish I guess.
15:58:13 <jle`> it's not a type "because it's a type constructor", it's a type because it denotes a type-level 'value'
15:58:17 <aplainzetakind> Maybe alone shouldn't be called a type
15:58:20 <Cale> (or the infix things which have names starting with ':')
15:58:22 <aplainzetakind> Is my intuition.
15:58:26 <jle`> aplainzetakind: "things that aren't *-kinded"
15:58:30 <Cale> aplainzetakind: Well, it... is? :)
15:58:35 <aplainzetakind> Which could be bad in light of very deep considerations of course.
15:59:09 <jle`> one confusing thing is that we have capital-t Type, which, if Maybe or Either Int were a type, would only represent a subset of types
15:59:12 <Cale> aplainzetakind: But yeah, it's a little bit unfortunate perhaps that we don't have a special word for types of kind * specifically
15:59:14 <bzm3r> what does it mean to write Ix (r, a) a? does it mean: the type constructor Ix is applied to (r, a) and a ?
15:59:20 <jle`> bzm3r: yes
15:59:29 <MarcelineVQ> Cale: we do though.
15:59:30 <bzm3r> ty
15:59:34 <MarcelineVQ> type constant
15:59:46 <Cale> MarcelineVQ: hmm, perhaps!
15:59:50 <MarcelineVQ> The haskell report describes things like Int and Char as type constants to differentiate them from type constructors like Maybe, but largely people will call both Maybe and Int type constructors in informal conversation.
16:00:01 <aplainzetakind> Cale, jle`: Yes the whole thing breaks down with the * = Type terminology.
16:00:26 <jle`> we just need a word for "thing that exists at the type level"
16:00:31 <Solonarv> I've also seen "type constant" to include Maybe and Int, but not Maybe a or [Char]
16:00:36 <bzm3r> so in this https://i.imgur.com/MfJTsXz.png, how is a function with type `Ix (r, a) a` a zero function? 
16:00:46 <jle`> bzm3r: it's not a zero function
16:00:51 <jle`> it's not even a function
16:00:59 <Solonarv> jle`: implement dependent Haskell so we can just call them values :P
16:01:08 <bzm3r> jle`it's a type constructor?
16:01:16 <jle`> it's a value/data constructor
16:01:19 <aplainzetakind> Parametrized type I guess.
16:01:21 <jle`> like 'Nothing', or 'True', or 'False'
16:01:31 <bzm3r> it produces values/data of type Zero?
16:01:36 <jle`> aplainzetakind: i mean, we need a term that applies for *,  *->*, (* -> *) -> *, etc.
16:01:41 <jle`> bzm3r: no, True produces a value of type Bool
16:01:50 <jle`> bzm3r: Zero produces a value of type Ix (p, a) a
16:01:55 <bzm3r> i see
16:01:58 <jle`> bzm3r: hm, are you familiar with GADT syntax?  that would clear up a lot of the confusion
16:02:10 <bzm3r> no, but i will look it up
16:02:10 <jle`> we have data Bool :: * where False :: Bool; True :: Bool
16:02:16 <aplainzetakind> Can we just call everything Thing if we eventually get full dependent types?
16:02:29 <geekosaur> It?
16:02:53 <Solonarv> aplainzetakind: yes, then we can call everything "value"
16:03:00 <MarcelineVQ> aplainzetakind: sure, though you still will need Thing0 Thing1 Thing2 to say at what level you're working at
16:03:09 <jle`> the only thing i name i can think of for all type-level 'values' is 'type', just like how all term-level values are terms
16:03:18 <Solonarv> and we can call values "kind" if their kind happens to be 'Type'
16:03:28 <jle`> despite the confusion with Type
16:03:31 <Solonarv> s/"kind"/"kind" or "type"/
16:03:37 <jgt> aplainzetakind: I won't answer that question now. I am undecidable.
16:03:38 <bzm3r> in this https://i.imgur.com/MfJTsXz.png, does Succ construct a function?
16:03:51 <jle`> bzm3r: look up GADT syntax
16:03:53 <Solonarv> MarcelineVQ: no, with dependent haskell there will only be one level
16:03:58 <jle`> Succ is a data constructor with one field
16:04:07 <jle`> data Maybe :: * -> * where Nothing :: Maybe a; Just :: a -> Maybe a
16:04:09 <Solonarv> currently there are two levels - terms and types (kinds are the same as types)
16:04:28 <bzm3r> can we not use Maybe as an example?
16:04:31 <jle`> there will still be multiple levels, but you can now treat them uniformly
16:04:40 <jle`> bzm3r: what's wrong with Maybe?
16:04:48 <aplainzetakind> Well, 5 is not a function but (+1) is at the term level, so what about type/type function?
16:05:03 <jle`> aplainzetakind: i mean, a word that applies to *both* 5 and (+1)
16:05:10 <bzm3r> well, i get it's an option like thing, but i am not super familiar with it because i don't write haskell, i'm only trying to learn how to read it
16:05:14 <jle`> we already have words that distinguish 5 and (+1)
16:05:30 <jle`> bzm3r: Maybe is a much, much simpler type than the type you are trying to read, heh
16:05:52 <jle`> if you cannot understand Maybe, there is no chance you can understand the GADT that you posted, heh
16:06:06 <jle`> i'm not trying to be condescending, but there's a clear ordering here in complexity
16:06:21 <bzm3r> why not just use a generic example?
16:06:27 <bzm3r> i.e. something called A
16:06:33 <bzm3r> which you can define?
16:06:38 <jle`> learning to read a GADT (which is arguably advanced haskell) without understanding Maybe (which is day 2 beginner haskell) is a weird pursuit
16:06:42 <jle`> okay, how about:
16:06:50 <jle`> data M :: * -> * where N :: M a; J :: a -> M a
16:07:14 <jle`> this is sort of like trying to understand real analysis while trying to avoid understanding addition
16:07:28 <bzm3r> that actually makes a lot more sense to me
16:07:38 <jle`> it's no shame to not know addition; it's just counter-productive to learn real analysis while actively avoiding learning addition
16:07:46 <bzm3r> i think the issue with Maybe is that people keep invoking the bots continously
16:07:48 <jle`> bzm3r: do you see how they are the exact same type? M and Maybe ?
16:07:57 <jle`> all I did was change the name of the constructors
16:08:02 <bzm3r> sure, yeah
16:08:06 <jle`> data Maybe :: * -> * where Nothing :: Maybe a; Just :: a -> Maybe a
16:08:06 <bzm3r> N is Nothying
16:08:09 <jle`> data M :: * -> * where N :: M a; J :: a -> M a
16:08:10 <bzm3r> right
16:08:28 <bzm3r> its just that `data M :: * -> * where N :: M a; J :: a -> M a` was a lot less noisy for me
16:08:42 <jle`> but, this isn't directly as helpful, because to know how to 'use' Ix, you also have to know how to 'use' Maybe
16:09:15 <jle`> there are two ways to construct a value of type `Maybe a`:
16:09:26 <jle`> 1. use the `Nothing` constructor, which has type `Maybe a`.
16:09:35 <jle`> 2. use the Just constructor with a value, like `Just True`, which has type Maybe Bool
16:09:49 <bzm3r> sure
16:10:00 <bzm3r> isn't it weird to write Maybe a though?
16:10:08 <bzm3r> or heck, `M a`
16:10:16 <bzm3r> because, is Maybe being applied to anything?
16:10:28 <bzm3r> if not, why is function application notation being used?
16:10:38 <c_wraith> it is!
16:10:48 <jle`> Maybe :: * -> *
16:10:56 <c_wraith> Maybe is a type constructor.
16:10:58 <jle`> so it takes a type (like Bool), and returns a new type, `Maybe Bool`
16:11:05 <zeta> could you guys help me set this up, i could not get it to work earlier, maybe it is the syntax
16:11:07 <bzm3r> so it is a function?
16:11:12 <c_wraith> it's a type functoon
16:11:15 <jle`> it can be thought of as a type-level function
16:11:19 <bzm3r> cool
16:11:20 <c_wraith> ... function.
16:11:23 <bzm3r> this was an earlier question of mine
16:11:44 <jle`> the kind * -> * also alludes to this
16:11:55 <jle`> since -> is associated with the type/kind of functions
16:12:00 <zeta> https://github.com/giovanifss/xmonad-brightness https://hastebin.com/bicodabuva.rb
16:12:01 <bzm3r> right
16:12:04 <jle`> like, how `Int -> Bool` is the type of a function that takes an Int and returns a Bool
16:12:13 <zeta> help please!!!!
16:12:20 <Solonarv> or perhaps you prefer the newer notation: Type -> Type
16:12:40 <jgt> zeta: add more exclamation marks if you want help faster
16:12:46 <MarcelineVQ> Solonarv: one notation learning at a time :O
16:13:04 <bzm3r> Solonarv that notation is nicer, i have to admit
16:13:08 <bzm3r> * feels overloaded
16:13:21 <Solonarv> yes, also makes the parser more complicated
16:13:35 <Solonarv> especially since there are type-level numbers which use * for multiplication
16:13:43 <bzm3r> yeah
16:13:51 <geekosaur> zeta, you're not doing anything that I see with the moduke
16:13:56 <jgt> they should have gone with ❆ -> ❆
16:14:00 <jle`> it was perhaps a mistake
16:14:17 <geekosaur> you need to add the keybindings for it. you also need to pay attention to the stuff at the bottom of its README: you do not have permission to adjust brightness by default
16:14:20 <bzm3r> ❆ -> ❆would work too, but Type is just clearer
16:14:27 <jgt> ⦿ -> ⦿
16:14:27 <Solonarv> I have seen a good number of beginners confusing * for some sort of wildcard; Type is much more obvious IMO and has also helped these beginners
16:14:42 <jle`> too bad it's hidden behind an extension and an import
16:14:54 <Solonarv> yeah, that'll change eventually
16:15:05 * ski idly recalls `map :: (* -> **) -> [*] -> [**]', in Miranda[TM]
16:15:08 <Solonarv> I don't remember what the deprecation schedule is like but it does exist
16:15:42 <bzm3r> i hate De Bruijn indices
16:15:50 <zeta> geekosaur: one second, let me pastebin it for you guys to check, then we'll set the permissions
16:16:39 <jle`> 🎿 i mean we have numbered wildcards in scala
16:17:30 * ski . o O ( .. perhaps they should introduce named wildcards, while they're at it ? )
16:17:36 <jle`> bzm3r: nobody likes using de brujin indices
16:17:39 <MarcelineVQ> de bruijn indices are great, trick is to just not work with them yourself, let the computer do that
16:19:02 <bzm3r> De bruijn indices that are themselves variables: https://i.imgur.com/oYEzj61.png
16:19:15 <Solonarv> I'm okay with de bruijn indices as long as there are at most two, they are constant, and they are not repeated too much
16:21:20 <bzm3r> can you guys now help me unpack this: https://i.imgur.com/1usLGwU.png
16:21:40 <bzm3r> so, here's what i understand
16:21:58 <MarcelineVQ> bzm3r: what paper is this?
16:22:11 <MarcelineVQ> The one from the other day?
16:22:42 <bzm3r> Ix r t is a De Bruijn index, referring to a variable of type t
16:22:54 <bzm3r> MarcelineVQ: yeah, this one: https://www.cs.ox.ac.uk/ralf.hinze/Lifting.pdf
16:23:12 <bzm3r> what does it mean to say "relative to the typing context r"?
16:23:50 <bzm3r> "Ix r t is a De Bruijn index, referring to a variable of type t, relative to the typing context r"
16:24:43 <bzm3r> "In type theory a typing environment (or typing context) represents the association between variable names and data types. "
16:25:51 <bzm3r> "More formally, G is a set of ordered list of pairs (x, t) where x is a variable and t is its type"
16:26:07 <bzm3r> (G is an environment)(
16:26:12 <bzm3r> okay, i suppose i understand that
16:26:23 <zeta> does the syntal look correct? https://hastebin.com/iqetuyosuj.rb https://github.com/giovanifss/xmonad-brightness
16:26:25 <geekosaur> yes. and you can have multiple envirionments because you can have scope
16:26:39 <geekosaur> say, top level vs. inside a function vs. inside a let binding (in Haskell_
16:26:50 <bzm3r> right
16:27:39 <zeta> geekosaur: does the syntax look correct?
16:27:53 <geekosaur> yes
16:28:02 <geekosaur> so what error(s_ do you get?
16:29:46 <zeta> geekosaur: let me rebuild nixos, i'll let you know if it throws an error
16:30:18 <bzm3r> Alright, so Ix r t is a De Bruijn index for type t, relative to environment r. Zero is defined here: https://i.imgur.com/MfJTsXz.png, and the authors say "for instance Zero::((r, t1), t0) t0"
16:30:32 <geekosaur> the first paste, you had the module imported with a different qualification, I don't know if you had adjusted the name in the keybindings to match
16:31:05 <bzm3r> is (r, t1) an environment? (recall that it is standing where r should stand, and r is an environment?)
16:33:03 <geekosaur> zeta, btw, mod-q should work to rebuild and relaunch xmonad nondestructively
16:33:23 <geekosaur> so you don;t have to quit and restart everything
16:33:46 <bzm3r> there
16:33:52 <bzm3r> (oops)
16:36:48 <bzm3r> eh, maybe it's time for me to give up on this paper
16:36:50 <zeta> geekosaur: oh, that's good to know, theres no errors so now just the permissions, are using nixos, i am not sure how to change this declaratively, or does it not matter what operating system i am using?
16:37:35 <geekosaur> nixos doesn't matter for this, it's related to the linux kernel not nixos
16:37:46 <MarcelineVQ> bzm3r: No, an environment is seperate, you use the Ix to find what you need in the environment.
16:38:19 <geekosaur> although how you arrange for this to happen every boot (/sys is not persistent) might be
16:38:22 <bzm3r> MarcelineVQ: not sure which question of mine you are responding to
16:38:28 <MarcelineVQ> "<bzm3r> is (r, t1) an environment?"
16:38:49 <zeta> https://github.com/giovanifss/xmonad-brightness https://hastebin.com/tumexuweke.rb
16:39:01 <MarcelineVQ> Env is defined on the next page, Env is an environment
16:39:55 <bzm3r> MarcelineVQ: so Zero:: Ix (r, a) -> a, and we are told "for instance Zero::Ix ((r, t1) t0) t0"; see how (r, t1) is standing where r is standing? why is that?
16:39:59 <geekosaur> zeta, you can't set the permissions in your xmonad config (or, if you could, you wouldn't have a permissions issue)
16:40:34 <geekosaur> this is something that would norrmally be done during system boot, with an init script or systemd unit or a devd control entry or something
16:41:17 <zeta> geekosaur: i am using nixos, so is there an easier way to do this?
16:41:36 <geekosaur> I don't know how nixos does system configuration, but to be honest I doubt it
16:42:45 <zeta> geekosaur: thanks i am going to #nixos to get help with permissions
16:43:39 <LovellyEmma> I will start my Live Show in 10 minutes. Check my sexy body, ass, boobs and pussy. Fastest people will join my Private Live for FREE! Be among the first 5 people to write me "FREE INVITE" on my CAM room: https://t2m.io/2jZBozLS
16:43:46 <Axman6> @where ops
16:43:47 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
16:44:06 <geekosaur> they always leave before anyone can do anything
16:44:41 --- mode: ChanServ set +o shapr
16:45:04 <shapr> geekosaur: impure!
16:45:26 <shapr> perhaps we need a cooldown time?
16:45:29 --- mode: shapr set -o shapr
16:45:51 <geekosaur> they waited 14 seconds, spammed, left 7 seconds later
16:46:09 <geekosaur> similar timing to the other ones
16:46:55 <MarcelineVQ> bzm3r: It looks like they're using r as an accumulator for their contexts, the next step could be: Succ (Succ (Zero :: Ix (((r,t2), t1) t0) t2))
16:47:30 <MarcelineVQ> This is what they mean by "For the purposes of this paper, the typing context is always a left-nested product type."
16:47:44 <bzm3r> MarcelineVQ i see
16:48:05 <MarcelineVQ> You choose a pretty tough one for your first dive I gotta say :>
16:48:23 <MarcelineVQ> Lots of terminology to have to pick up
16:48:26 <bzm3r> yeah, well, i am only interested in haskell so that i can understand this paper
16:49:11 <bzm3r> but i think the authors didn't intend for it to be read by anyone except those who are already very familiar with functional programming/haskell
16:49:40 <bzm3r> and i am out of their intended audience, so at some point, i have to make a decision as to whether i continue trying to decipher it, or just look for other things
16:50:22 <bzm3r> (other things being other approaches to proving the lifting lemma/transfer principle)
16:54:54 <MarcelineVQ> bzm3r: Try asking about "approaches to proving the lifting lemma/transfer principle" in ##dependent, it's a bit of a slower channel but there's a chance that the mathy backgrounds of the people there may be able to suggest more suitable material.
16:55:43 <bzm3r> MarcelineVQ thanks, will try it
17:03:19 <zeta> geekosaur: they did not want to help me so i came back
17:05:04 <zeta> could someone help me with the permissions: https://github.com/giovanifss/xmonad-brightness https://hastebin.com/tumexuweke.rb
17:23:09 <zeta> could someone help me with the permissions: https://github.com/giovanifss/xmonad-brightness https://hastebin.com/tumexuweke.rb
17:24:17 <zeta> help please
18:01:45 <Guest37156> How would I make something like this work?
18:01:48 <Guest37156> handleMessage :: Payload -> StateT HandlerState IO ()
18:01:50 <Guest37156> handleMessage payload = case op payload of
18:01:52 <Guest37156>   Ready -> runMaybeT $ do
18:01:54 <Guest37156>       foo  <- MaybeT $ payload
18:01:56 <Guest37156>       quux <- MaybeT $ bar foo
18:01:58 <Guest37156>       lift $ put quux
18:02:25 <Axman6> what doesn't work?
18:02:40 <Guest37156> I have a few functions which are run in sequence and return maybe. At the end, I want to put into the state monad
18:03:19 <Guest37156> runMaybeT does not have the right return type as given in the signature of handleMessage
18:03:49 <Axman6> can't you do: Ready -> mresult <- runMaybe $ do ...; maybe (pure ()) put mresult?
18:04:27 <Axman6> so move the put outside the MaybeT
18:04:47 <Axman6> I assume you only want to put if the MaybeT produces a Just
18:04:52 <Guest37156> yes
18:05:03 <Guest37156> hm yeah I suppose that works
18:05:47 <Axman6> you could also just add pure () after the whole runMaybeT block
18:06:10 <Axman6> () <$ runMaybeT (do ...)
18:06:32 <Axman6> :t (<$)
18:06:33 <Guest37156> hm yeah I suppose that works
18:06:34 <lambdabot> Functor f => a -> f b -> f a
18:06:40 <Guest37156> whoops accidentally pressed up
18:08:25 <Guest37156> sorry, not following your last suggestion
18:08:40 <Guest37156> () <$ runMaybeT (do ...; ...; pure ())
18:08:42 <Guest37156> ?
18:08:52 <Axman6> is the problem that the runMaybeT returns StateT ... (Maybe ())?
18:08:57 <Guest37156> yeah
18:08:59 <Axman6> no need for the pure any more
18:09:54 <Axman6> :t () <$ (undefined :: StateT Bool IO (Maybe ()))
18:09:55 <lambdabot> StateT Bool IO ()
18:10:23 <Guest37156> that is handy
18:10:49 <Axman6> it's a shorthand for const () <$>
18:11:02 <Axman6> (there's also the function void which does the same thing:)
18:11:04 <Axman6> :t void
18:11:05 <lambdabot> Functor f => f a -> f ()
18:11:12 <Axman6> @hoogle void
18:11:13 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
18:11:13 <lambdabot> Data.Functor void :: Functor f => f a -> f ()
18:11:13 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
18:31:22 <jusss> when Monad is [],   >>= :: [a] -> (a-> [b]) -> [b],  I don't understand why not just [a]->[b]
18:31:39 <jusss> this 'return' function is really confused me
18:32:11 <jusss> when Monad is (e->), >>= :: (e->a) -> (a->(e->b)) -> (e->b)  weird too
18:32:53 <jusss> 'cause there's already (e->b) in (a->(e->b)) , so what's the meaning to construct chat e->b?
18:33:18 <jusss> that
18:35:26 <geekosaur> the defined behavior of the list monad is to apply the action to each element of the list, concatenating the result lists to make a new list
18:35:38 <geekosaur> also why do you keep calling it return
18:35:59 <jusss> geekosaur: that's what I don't understand about your term 'action'
18:36:12 <jusss> geekosaur: call it lift? or unit or pure?
18:36:16 <geekosaur> an action is whatever the monad decides it is
18:36:24 <jusss> or semigroup?
18:36:25 <geekosaur> and those are specific "actions"
18:36:43 <geekosaur> not semigroup, that is still unrelated
18:37:09 <geekosaur> jusss, return is an action therefiore you consider every action to be return? like 0 is a number, therefore every number is 0?
18:38:40 <jusss> geekosaur: you mean return is a specific function and (a-> m b) is not, 
18:38:54 <geekosaur> correct
18:39:05 <geekosaur> so it is not correct t call (a -> m b) "return"
18:39:19 <geekosaur> it might sometimes be return.
18:39:24 <jusss> geekosaur: return is implement of (a-> m b) ? or call instance ,improper?
18:39:43 <geekosaur> it is a specific action, in the same way 0 is a specific number
18:39:58 <jusss> geekosaur: and Int is not specific number?
18:40:06 <geekosaur> the monad defines that specific action, but it is not the only action (and a monad where that's the only action isn't very useful)
18:40:37 <jusss> geekosaur: whatever, how we describe the relation between type and function?
18:41:03 <jusss> 'cause type is an instance of typeclass, so I don't know how to describe function with type
18:41:45 <geekosaur> I don't even know what you're asking. I told you what (>>=) does for lists, apparently that is not what you meant
18:42:33 <jusss> geekosaur: the term that describe the relationship between type signature and function definition
18:43:33 <jusss> geekosaur: like can we say a function definition is instance of a type signature? or we say a function definition is an implement of a type signature?
18:43:54 <geekosaur> that is an implementation
18:44:02 <jusss> ok
18:44:35 <geekosaur> an instance, in the context of haskell, usually has one or more implementations associated with it.
18:44:53 <jusss> when monad is [],  a->[b],   when it's (e->) ,  a->(e->b)
18:45:14 <jusss> whatever this is, (a-> m b) seems odd to me
18:45:25 <geekosaur> however we also can say that, for example, 0 is an instance of Int. its not an implementation, it doesn't say how to do anything, it's just a value
18:45:42 <geekosaur> it's the whole point of Monad
18:46:36 <jusss> geekosaur: it seems we already have m b in (a->m b) why we just return it directly
18:46:53 <geekosaur> ?
18:47:36 <jusss> m a -> (a -> m b)  I think this is ready fine
18:47:45 <jusss> already
18:47:53 <jusss> m a -> a -> m b
18:47:57 <geekosaur> sure, if you never do anything
18:48:05 <geekosaur> the whole point of action is to do something
18:48:20 <jusss> 'cause I don't that transform do a -> b
18:48:32 <jusss> in Functor or Applicative, we have that a->b
18:48:36 <jusss> but in Monad, no
18:48:55 <geekosaur> correct.
18:49:11 <geekosaur> you should probably try to figure this out with Maybe, because it's simpler
18:49:46 <jusss> Maybe seems like List to me, and remove the Nothing value
18:50:06 <geekosaur> for Maybe, (>>=) has to deal with two cases for (Maybe a). if it's Nothing, it simply produces Nothing. if it's Just someValue, it hands someValue to the action and produces the action's result
18:51:03 <jusss> what about (m a) -> (a->b) -> (m b) ?
18:51:14 <geekosaur> what about it?
18:51:17 <geekosaur> what does it do?
18:51:46 <geekosaur> you are describing fmap with swapped arguments. why do we need another one?
18:51:58 <jusss> yeah, it's fmap
18:52:04 <geekosaur> Monad is doing something else, not simply doing fmap
18:52:35 <geekosaur> with fmap, it has no access to anything but the a. with bind, it has access to the monad and anything it can do.
18:52:39 <jusss> >>= is related with fmap?
18:52:59 <geekosaur> you apparently want it to be since you keep asking why it's not
18:53:12 <geekosaur> for Maybe, this isn't very much. for IO, it's quite a lot; you can do any I/O action.
18:55:00 <jusss> swap argument in >>=,  we can get (a-> m b) -> (m a) -> (m b)
18:55:24 <jusss> a-> m b,   so m a is m (m b) right?
18:57:10 <geekosaur> ...you're sort of close but wrong
18:57:19 <geekosaur> if you used fmap, you would get that
19:04:13 <jusss> geekosaur: do I lack comprehension?
19:04:44 <geekosaur> I have no idea what you are doing, aside from ignoring or rejecting any explanation of why (a -> m b) and describing it as fmap
19:05:15 <jusss> yes
19:11:24 <Axman6> Has there been any news on unboxed sum types lately? I know we have anonymous unboxed sums, but has there been any progress on unboxing sum types?
19:16:01 <Axman6> jusss: (>>=) is related to fmap in that it is possible to implement fmap using (>>=), but it is strictly more powerful than fmap because the function being used has access to the context m, so it can also be used to do much more
19:16:57 <Axman6> fmap :: (a -> b) -> m a -> m b; fmap f ma = ma >>= (\a -> return (f a))
19:18:06 <c_wraith> technically, you need return/pure along with (>>=)
19:27:30 <hololeap> you can also implement (<*>) in terms of (>>=)
19:27:37 <hololeap> mf <*> ma = mf >>= (\f -> ma >>= (\a -> return (f a)))
19:50:03 <___laika> question for people who use RIO, does anyone use it as their replacement prelude with base-noprelude? im getting weird errors (Ambiguous occurrence ‘catchIO’ from Paths_project and Prelude) and im curious if i can avoid them without "import hiding catchIO"
19:52:23 <geekosaur> I suspect Cabal's Paths_foo support expects the standard Prelude. although it should probably not reexport catchIO.
19:53:42 <___laika> it being RIO?
19:54:10 <geekosaur> the Paths_ module, which is autogenerated by Cabal
19:56:08 <___laika> isnt it just that Paths_ is importing the standard catchIO, and running into a conflict with my local Prelude that exports RIO's catchIO? the ambiguous occurrence  is in the Paths_ module itself
19:57:14 <geekosaur> if it saus "from Paths_project and Prelude" then it is saying that both those modules export catchIO.
20:24:00 <Fourtrees> hello
20:29:31 <dmwit> mahogeny: 'sup
20:30:27 <maxxe> zup! :-)
20:35:57 <mahogeny> heh im trying to learn some haskell for the fun of it
20:41:14 <dmj`> If I have this datatype, data Foo = Foo { foo, bar :: String },  can I do something like this...
20:41:22 <dmj`> fooLens :: Lens' Foo String :*: barLens :: Lens' Foo String = genericLens @Foo
20:55:13 <Axman6> mahogeny: don't do that, learn it to change the world!
20:55:42 <Axman6> dmj`: I think that might be something generic-lens does
20:56:10 <dmj`> Axman6: I checked generic-lens, it doesn't do exactly this
20:56:42 <Axman6> I've definitely seen it done, it's something that the functor-functor stuff allows (see benjamin.pizza
20:56:44 <Axman6> )_
20:57:35 <Axman6> dmj`: see https://www.benjamin.pizza/posts/2017-12-15-functor-functors.html 
20:58:58 <Axman6> https://hackage.haskell.org/package/lens-sop-0.2.0.3/docs/Generics-SOP-Lens.html might also do it
20:59:02 <Axman6> it's hard to tell!
21:01:09 <fDev2179> I'm having a hard time with read.  I have a list that looks like this: nl = [["1.24","0.5"],["0.12","0.43"]].  I want to convert it to [[Double]].  To do this, I did the following in ghci: (fmap . fmap) read nl :: [[Double]].  This works fine.  However, I tried to implement this as follows in the getMapData function: https://gist.github.com/jgrisham4/b01fd4d17c49aa3200ecc3e9c08dfb9b
21:01:57 <glguy> fDev2179: The (at least) problem is the type signature:   :: [a]
21:02:16 <glguy> That doesn't mean what you probably thought it did. The 'a' there is not the same as as from line 22
21:02:26 <glguy> type variables are locally scoped to each type signature
21:02:49 <glguy> So try removing that type signature
21:03:37 <dmj`> Axman6: it would require this proposal afaik, https://github.com/digital-asset/daml/issues/771
21:03:58 <dmj`> Axman6: we'd need `setField` to be added to `HasField`
21:04:11 <fDev2179> Oh my gosh... Thanks @glguy.
21:04:27 <dmj`> Axman6:  o/w there's no way to set a field on a record when reifying the lens in the generic traversal
21:04:30 --- mode: glguy set -o glguy
21:04:35 <fDev2179> That fixed it!
21:06:19 <Axman6> urgh, looks like lens-sop doesn't use lens :(
21:08:03 <dmj`> yea 
21:08:09 <dmj`> :/
21:09:19 <fDev2179> \quit
23:15:46 <Xal> Is it possible to have overlapping associated type families?  What I want works with a closed type family, but I need some functions to go along with it now and I can't have overlap with associated type families.
23:20:02 <Xal> I have this to convert from GHC.Generics into something in terms of (,) and Either: https://hastebin.com/udofoxotam.hs
23:20:31 <Xal> The problem is I need to/from functions to go along with this, but the type family only works if it's closed.
23:21:45 <Xal> The overlapping part are the ones where I match on an empty tail: I don't want a cons-list. (eg I want (Int, (Int, Int)) instead of (Int, (Int, (Int, ()))))
23:40:57 <piyush-k`> ezyang: around
23:40:58 <piyush-k`> ?
23:52:52 <maerwald> how do you compose a Getter that might return 'Maybe a' with another getter that has 'a' as input, without using a prism
23:57:07 <Axman6> well it sounds like it'll have to be a prism or traversal at some point
23:57:27 <maerwald> traversal probably
23:58:06 <Axman6> well PRisms are traversals
23:58:19 <Axman6> so, getter . _Just . thingThatWantsA
23:59:02 <dminuoso> % Just ('a', 2') ^.. _Just . _1
23:59:02 <yahb> dminuoso: ; <interactive>:83:14: error: parse error on input `)'
23:59:04 <maerwald> no, I don't want to use _Just
23:59:12 <dminuoso> % (Just ('a', 2')) ^.. (_Just . _1)
23:59:12 <maerwald> that has different meaning
23:59:12 <yahb> dminuoso: ; <interactive>:84:15: error: parse error on input `)'
23:59:21 <Axman6> how about non
23:59:23 <Axman6> :t non
23:59:25 <lambdabot> (Functor f, Profunctor p, Eq a) => a -> p a (f a) -> p (Maybe a) (f (Maybe a))
23:59:34 <maerwald> it applies Monoid on the result type, which is absolutely arbitrary and removes the Maybe
23:59:42 <Axman6> eh?
23:59:52 <maerwald> yes
23:59:58 <Axman6> I feel you're misunderstanding what _Just does
23:59:59 <dminuoso> maerwald: the point of _Just is to target the _Just side.
