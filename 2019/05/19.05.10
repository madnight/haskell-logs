00:00:10 <Axman6> :T _Just
00:00:12 <Axman6> : _Just
00:00:13 <maerwald> dminuoso: and if it fails it calls mempty on the result type of the entire lens
00:00:15 <Axman6> :t _Just
00:00:16 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Maybe a) (f (Maybe b))
00:00:23 <maerwald> it propagates through the composition
00:00:27 <maerwald> it's not what I want
00:00:27 <dminuoso> maerwald: Huh?
00:00:34 <Axman6> that sounds wrong
00:00:50 <dminuoso> maerwald: No it doesn't. I feel that you have a misconception about what a prism is
00:01:15 <Axman6> > [Just 1, Nothing, Just 2] & each . _Just %~ (*3)
00:01:17 <lambdabot>  [Just 3,Nothing,Just 6]
00:01:42 <Axman6> if you're seeing weird behaviour like that it's not coming from _Just
00:01:49 <maerwald> it is :)
00:02:04 <Axman6> the demonstrate it
00:02:06 <Axman6> then*
00:02:28 <maerwald> second
00:04:15 <dminuoso> maerwald: all prisms `p :: Prism s t a b` are constructed through what you could think of `data Prism s t a b = Prism { build :: b -> t, match -> s -> a + t }`, where + denotes Sum type like with Either. `prism` is the utility to construct a prism from those two parts.
00:04:19 <dminuoso> maerwald: _Just is defined like this:
00:04:21 <dminuoso> _Just = prism Just $ maybe (Left Nothing) Right
00:04:23 <Axman6> Prisms/_Just don't introduce monoids, someof the operators choose functions which do though
00:04:43 <dminuoso> uhh that should have read `match :: s -> a + t`
00:06:13 <dminuoso> so we could pretend for a moment that: `_Just = Prism { build = Just, match = maybe (Left Nothing) Right }` -- there's no mention of monoids here.
00:07:00 <maerwald> > view (_Just . to (+1) . to (\x -> [x])) (Just(3 :: Int))
00:07:02 <lambdabot>  [4]
00:07:06 <maerwald> > view (_Just . to (+1) . to (\x -> [x])) (Nothing :: Maybe Int)
00:07:08 <lambdabot>  []
00:07:12 <maerwald> mempty
00:07:16 <maerwald> and Monoid constraint
00:07:38 <dminuoso> maerwald: The Monoid is introduced by view, indirectly.
00:07:53 <dminuoso> view :: MonadReader s m => Getting a s a -> m a 
00:07:56 <dminuoso> % :i Getting
00:07:56 <yahb> dminuoso: type Getting r s a = (a -> Const r a) -> s -> Const r s -- Defined in `Control.Lens.Getter'
00:08:09 <dminuoso> % :t (_Just . to (+1) . to (\x -> [x]))
00:08:09 <yahb> dminuoso: forall {p :: * -> * -> *} {f :: * -> *} {b}. (Choice p, Applicative f, Contravariant f, Num b) => p [b] (f [b]) -> p (Maybe b) (f (Maybe b))
00:09:13 <dminuoso> Type unification fu, then you end up using the `instance Monoid r => Applicative (Const r)` instance I think.
00:12:48 <dminuoso> maerwald: So if you try to `view` through a prism.. well yeah. You end up using a monoid somehow.
00:13:05 <dminuoso> But that's not a problem with the prism, thats you using view.
00:13:12 <dminuoso> % preview (_Just . to (+1) . to (\x -> [x])) (Nothing :: Maybe Int)
00:13:13 <yahb> dminuoso: Nothing
00:13:24 <dminuoso> % preview (_Just . to (+1) . to (\x -> [x])) (Just 3 :: Maybe Int)
00:13:25 <yahb> dminuoso: Just [4]
00:14:30 <maerwald> hmm
00:15:20 <maerwald> seems like that works
00:25:54 <aplainzetakind> RecordWildCards is super handy but at the same time very unnerving in the way it overloads names.
00:38:01 <maerwald> dminuoso: so basically it's safer to use preview and have something like ". to (maybe x y)" at the end, instead of implicit monoid
00:43:07 <dminuoso> maerwald: You dont need the `to (maybe x y)`
00:43:58 <maerwald> well, I want to provide a default value
00:44:07 <dminuoso> maerwald: then `non` should give you what you want.
00:44:14 <dminuoso> like Axman6 mentioned.
00:49:20 <maerwald> what does 'view' do in combination with 'traverse'? :>
00:49:44 <maerwald> mappend?
00:52:22 <dminuoso> maerwald: Yes.
00:52:25 <dminuoso> % [Product 1, Product 2, Product 3] ^. each
00:52:25 <yahb> dminuoso: Product {getProduct = 6}
00:52:42 <dminuoso> maerwald: A traversal is an optic that can target 0, 1 or many values.
00:53:06 <dminuoso> maerwald: the monoid constraint introduced by view here ensures that we can always condense this into a single value
00:53:41 <maerwald> wonder if there is something with semigroup instead of monoid
00:53:53 <maerwald> I'm mostly concerned about the mempty thing
00:54:03 <maerwald> most of the time it's just not what you really want
00:54:14 <dminuoso> maerwald: No it is.
00:54:24 <dminuoso> maerwald: It's just the refusal to accept that view must produce a value. :-P
00:54:40 <dminuoso> maerwald: When you have an optic that can fail you should default to preview.
00:54:41 <maerwald> dminuoso: I mean if there is something like view, but with Semigroup constraint instead of Monoid
00:55:48 <dminuoso> maerwald: view is for optics that cant fail and target only one value.
00:55:53 <maerwald> before I do ". traverse" I have a nonempty list...
00:56:09 <dminuoso> maerwald: you try and use it on an optic that can fail or target multiple values, how do you expect that to work?
00:57:56 <maerwald> dminuoso: it would only work on an optic that targets multiple values, but cannot fail
00:59:40 <dminuoso> maerwald: I guess there is Traversal1 and Fold1
01:09:43 <roflik> hello, haskell newb here.  i'm playing with https://hackage.haskell.org/package/odbc.  the manual shows i can retrieve tuples of specific types with code like query conn "SELECT * FROM example" :: IO [(Int,Text,Bool)].  i'd like to get records instead (data DBRow = DBRow { db_a :: Int, db_b :: Text, db_c :: Bool }).  is this possible?
01:10:51 <dminuoso> roflik: Write your own FromValue instance for your record.
01:12:02 <roflik> dminuoso: FromValue or FromRow?
01:12:25 <dminuoso> roflik: Good catch. FromRow of course.
01:16:39 <bahamas> does anyone know a workaround for this? https://github.com/commercialhaskell/stack/issues/3862
01:18:33 <roflik> dminuoso: i'm getting Duplicate instance declarations
01:18:59 <roflik> dminuoso: probably because i don't know what i'm doing
01:19:12 <roflik> instance (FromValue a, FromValue b) => FromRow (a, b) where
01:19:28 <roflik>   fromRow [a, b] = DBRow { dbT = a, dbN = b }
01:19:44 <dminuoso> roflik: Are you familiar with the typeclass mechanism of haskell?
01:20:10 <roflik> dminuoso: i'm really just starting with haskell, so no, not familiar.
01:20:53 <dminuoso> roflik: That's not an issue. So a typeclass is a sort of interface, and instances act as implementations of that interface.
01:21:34 <dminuoso> roflik: You tried to supply an `instance ... FromRow (a, b)` which, in this case, is an implementation for FromRow for 2-tuples
01:21:37 <dminuoso> This already exists.
01:21:56 <roflik> oh, i want FromRow DBRow?
01:21:57 <dminuoso> You probably meant to write `instance FromRow YourCustomDataType where fromRow [a, b] = DBRow { dbT = a, dbN = b }`
01:22:00 <dminuoso> roflik: Spot on.
01:23:33 <dminuoso> roflik: You might, depending on the definition of `DBRow`, have to use FromValue on the constituent columns.
01:24:05 <dminuoso> So it might even be:  `fromRow [a, b] = DBRow { dbT = fromValue a, dbN = fromValue b }`
01:29:24 <roflik> dminuoso: thanks a lot.  fromRow [a, b] = Right DBRow { dbT = fromValue a, dbN = fromValue b } is a type mismatch: fromValue returns Either String a0.
01:29:58 <dminuoso> roflik: fromValue could fail.
01:30:35 <dminuoso> roflik: What you could do is this: do { a' <- fromValue a; b' <- fromValue b; return (DBRow a' b'); } 
01:31:39 <jgt> I know there are a few ways to get compile time info, but what's the easiest?
01:31:54 <jgt> I essentially just want the timestamp of compilation
01:33:13 <roflik> dminuoso: awesome, thank you!  what would a do-less version look like?
01:33:25 <jgt> oh, maybe this is this easiest http://hackage.haskell.org/package/th-nowq-0.1.0.3
01:33:44 <dminuoso> roflik: fromValue >>= (\a)
01:33:49 <dminuoso> Oops, hit enter too soon.
01:34:12 <dminuoso> roflik: fromValue >>= (\a' -> fromValue b >>= (\b' -> return (DBRow a' b')))
01:34:16 <ski> @undo do { a' <- fromValue a; b' <- fromValue b; return (DBRow a' b'); }
01:34:16 <lambdabot> fromValue a >>= \ a' -> fromValue b >>= \ b' -> return (DBRow a' b')
01:34:23 <dminuoso> ski: Oh that's much easier. Heh. :)
01:35:07 <roflik> thanks guys!
01:35:12 <dminuoso> roflik: There's much fancier ways to write it, but if you are that new it's probably not the best.
01:35:44 <ski> if any of those `fromValue ...'s yield a `Left ..' result, the result of the whole will also be a `Left ...'. otherwise a `Right ...'. (your original unconditionally yielded a `Right')
01:36:28 <ski> iow, if any of the `fromValue' invocations raise an exception, the whole execution of the action will be aborted, raising that exception (unless you catch it, which you didn't)
01:36:56 <dminuoso> roflik: I would for example just write it as `liftA2 DBRow fromValue fromValue` or `DBRow <$> fromValue <*> fromValue`. But it's exactly the same as the code that you have seen.
01:37:09 <dminuoso> roflik: So decide for yourself.
01:37:12 <roflik> ski: yup i understand that
01:37:38 <ski> sometimes the record syntax is more handy, sometimes the bare data constructor with positional fields is more handy
01:38:07 <dminuoso> Oh well, probably missed an argument there. So `DBRow <$> fromValue a <*> fromValue b` rather. But you get the idea
01:38:21 <zincy> What is a type level symbol as in the TypeLits package?
01:38:21 <roflik> dminuoso: yup, that's what the library does for the tuple instances
01:38:51 <dminuoso> zincy: Are you familiar with say servant?
01:39:04 <zincy> I have used it but don't know how it actually works
01:39:23 <dminuoso> zincy: it's type level strings.
01:39:48 <zincy> What is the value of a type level string?
01:39:59 <dminuoso> zincy: its not inhabitated (I think)
01:40:31 <zincy> Ah ok so type level strings are just an uninhabited type you use for type level computations
01:41:11 <dminuoso> zincy: Sure. Servant for example carries them around in the type-level API descriptions as sort of annotations.
01:41:22 <dminuoso> type API = "position" :> Capture "x" Int :> Capture "y" Int :> Get '[JSON] Position
01:41:35 <dminuoso> Those are type level strings.
01:42:01 <zincy> So it associates the API endpoint return type with its name?
01:42:18 <zincy> And the name is used as the Symbol
01:42:25 <ski> zincy : s/uninhabited/uninhabitable/
01:42:56 <zincy> oh uninhabitable
01:43:02 <zincy> So no data constructors?
01:43:11 <dminuoso> zincy: The symbol is used by servant machinery to generate routing/client code to think of this as a path "/position"
01:43:15 <ski> zincy : not just that
01:43:39 <dminuoso> zincy: The "x" and "y" strings are used for something else, I think its for generating error message when a parameter is incorrect/missing.
01:44:06 <ski> `Void' is uninhabited (ignoring bottoms as usual) (it has no data constructors), but it's still inhabitable, in principle capable of having inhabitants. it's a "concrete type" (to use a term some people don't like that much)
01:44:31 * dminuoso prefers un/inhabitatable especially because of bottom
01:44:41 <ski> however, `Maybe' is not inhabitable, saying `x :: Maybe' is nonsense (hmm ..). you have to say `x :: Maybe T', for some `T'
01:44:43 <zincy> Oh right so an uninhabitated type can have a nullary data constructor
01:44:51 <dminuoso> No.
01:44:53 <ski> dminuoso : elaborate ?
01:45:01 <zincy> I think it clicked
01:45:07 <zincy> * is habitable
01:45:12 <maerwald> hopefully not cracked!
01:45:13 <zincy> anything else isnt
01:45:14 <ski> `* -> *' is not
01:45:15 <dminuoso> ski: So I consider all types of kind * as inhabitatable because they are in fact all inhabitated by bottom.
01:46:01 <zincy> How can something have no data constructors and be inhabited? It would have no values?
01:46:07 <dminuoso> ski: Im genuinely curious. Why did you write (hmm ..) there? :)
01:46:12 <dminuoso> zincy: bottom.
01:46:15 <dminuoso> % data Foo
01:46:15 <ski> similarly, the type of the kind kind `Symbol' (which would be the "type level strings" that were mentioned) are not inhabitable
01:46:15 <yahb> dminuoso: 
01:46:23 <dminuoso> % a :: Foo; a = undefined
01:46:23 <yahb> dminuoso: 
01:46:29 <ski> s/type of the kind kind/types of the kind/
01:46:29 <dminuoso> See? I just made a value of type Foo.
01:46:38 <zincy> bottom is what you get when a value is fully evaluated right?
01:46:54 <dminuoso> zincy: bottom is an imaginary value that denotes failure to compute a result.
01:47:13 <zincy> so why is bottom needed?
01:47:30 <zincy> laziness?
01:47:49 <dminuoso> zincy: Well I guess part of the motivation is because we have a turing complete language.
01:47:50 <ski> dminuoso : "I consider all types of kind * as inhabitatable because they are in fact all inhabitated by bottom." -- i would agree all of them are inhabit*able*, but, ignoring bottoms as usual, i wouldn't say `Void' (or `Equal Int Bool' or some other GADT example) are actually inhabited (by total values)
01:48:10 <dminuoso> zincy: So an infinite loop for example is also considered "failure to compute a result", which is why we assign infinite loops the imaginary value bottom.
01:48:48 <ski> it goes without saying that there's a bottom value in all inhabitable types. so when i say "uninhabited", i tend to ignore things of that ilk
01:48:51 <dminuoso> zincy: by "assign" I mean it in our heads, not in the language itself.
01:49:15 <dminuoso> zincy: So for example if I look at some code like `x = x`, I see an infinite loop and thus conclude "this expression produces this imaginary value bottom"
01:49:20 <ski> "bottom" represents an evaluation with no answer
01:49:45 <ski> this includes (unproductive) infinite loops, and calls to `error', and pattern-match failure
01:50:02 <dminuoso> all of which have one thing in common: they all do not produce a result. :)
01:50:12 <zincy> understood
01:50:27 <zincy> it is that symbol _|_
01:50:28 <dminuoso> zincy: Now this bottom value happens to inhabitate all inhabitatable types.
01:50:30 <zincy> I think
01:50:30 <dminuoso> zincy: yes.
01:50:48 <ski> in terms of behaviour of the program, we'd like to treat these as more or less the same thing (and they are identified in the denotational semantics, which focuses on "answers", as opposed to how we might arrive at them)
01:51:07 <dminuoso> zincy: `undefined` is that bottom value (there's semantically only one bottom value)
01:51:17 <dminuoso> you can also write it as `x = x` 
01:51:23 <ski> zincy : ⌜⊥⌝ in unicode
01:51:33 <Ariakenom> so why say inhabitable instead of "of kind *"?
01:51:34 <dminuoso> zincy: now that bottom value happens to be special in that it doesnt live in a single type.
01:51:43 <dminuoso> zincy: it happens to be a member of many types.
01:51:50 <ski> Ariakenom : well, there's also unboxed kinds
01:52:07 <dminuoso> which types you might ask, well at least all types of kind * (lets ignore unlifted/unboxed/TYPE/etc)
01:52:09 <Ariakenom> ah true
01:52:36 <zincy> So all kinds of * have a ⊥
01:52:42 <dminuoso> zincy: all types of kind *.
01:52:58 <dminuoso> zincy: the same _|_ even. 
01:53:03 <dminuoso> for some sense of "same"
01:53:09 <dminuoso> zincy: so the following is perfectly valid:
01:53:17 <dminuoso> % x = undefined :: Int
01:53:17 <ski> dminuoso : "Why did you write (hmm ..) there?" -- because i've been thinking about a type system which allow exactly things like `x :: Maybe' :)
01:53:17 <yahb> dminuoso: 
01:53:22 <dminuoso> % x undefined :: Float
01:53:22 <yahb> dminuoso: ; <interactive>:114:1: error:; * Couldn't match expected type `t0 -> Float' with actual type `Int'; * The function `x' is applied to one argument,; but its type `Int' has none; In the expression: x undefined :: Float; In an equation for `it': it = x undefined :: Float
01:53:26 <dminuoso> % x = undefined :: Float
01:53:27 <yahb> dminuoso: 
01:53:29 <dminuoso> % x = undefined :: String
01:53:30 <yahb> dminuoso: 
01:53:40 <dminuoso> You can see that undefined happily lives in all those types.
01:53:45 <dminuoso> % x = undefined :: Maybe
01:53:45 <yahb> dminuoso: ; <interactive>:117:18: error:; * Expecting one more argument to `Maybe'; Expected a type, but `Maybe' has kind `* -> *'; * In an expression type signature: Maybe; In the expression: undefined :: Maybe; In an equation for `x': x = undefined :: Maybe
01:53:48 * ski wouldn't say "the same _|_", fwiw
01:54:15 <zincy> Ah maybe isn't inhabited
01:54:20 <zincy> it has no values
01:54:24 <zincy> and _|_ is a value
01:54:31 <dminuoso> zincy: Exactly. Not even _|_
01:54:43 <dminuoso> Maybe cannot have any inhabitants.
01:54:51 <dminuoso> But its a type nevertheless.
01:55:48 <dminuoso> And equivalently "foo" happens to be a type.
01:55:52 <dminuoso> % undefined :: "foo"
01:55:53 <yahb> dminuoso: ; <interactive>:118:14: error:; * Expected a type, but `"foo"' has kind `GHC.Types.Symbol'; * In an expression type signature: "foo"; In the expression: undefined :: "foo"; In an equation for `it': it = undefined :: "foo"
01:56:07 <dminuoso> And it also does not have any inhabitants.
01:56:51 <dminuoso> Maybe exists because it gives you a type level function of sorts. It can be thought of as a `+1`, so it allows you to add 1 to an arbitrary type.
01:57:15 <zincy> Is a type constructor equivalent to a type level function
01:58:28 <dminuoso> zincy: It probably depends a bit on who you ask. It can be thought of as a type level function, yes.
01:58:35 <ski> for each type ⌜T⌝ of kind ⌜★⌝, you conceptually have a ⌜⊥ : T⌝, you could say ⌜⊥_T⌝ if you wanted to distinguish them. of course you can now imagine a polymorphic ⌜⊥ : ∀ α : ★. α⌝, and then with `TypeApplications' one could write instead ⌜⊥ @T⌝
01:58:51 <Ariakenom> equivalent sounds too strong though
01:59:01 <Ariakenom> % :k Maybe
01:59:02 <yahb> Ariakenom: Maybe :: * -> *
01:59:48 <dminuoso> zincy: Type constructors are, in mind, a category of simple/non-programmable type functions. Equivalence is bidirectional, not every type function is a type constructor.
02:00:02 <ski> sometimes, in older terminology, `Maybe' wouldn't be a type, but `Maybe Integer' would be a type. `Maybe' would be called a type constructor (and `Either String' would be another type constructor). hence the older name "constructor classes" for type classes like `Functor',`Monad'
02:00:05 <zincy>  ⌜⊥ : ∀ α : ★. α⌝    Does this say for all type `a`s of kind *  there is a bottom
02:00:08 <dminuoso> zincy: type families for example give you "programmable" type functions of a different sort.
02:00:20 <dminuoso> zincy: so type constructors and type families both are sort of type-level function constructs.
02:00:47 <dminuoso> (by type constructors I specifically refer to parametrized type constructors of course)
02:01:02 <ski> however, i think it makes sense to use the same general term "type" for all type expressions, regardless of whether they have kind `*' or not. you have no qualms about calling `map' and `map (2 *)' values, even if they happen to be functions, because functions are values too !
02:01:13 <dminuoso> ski: Thank you!
02:01:37 <zincy> In what sense are type families programmable?
02:01:38 <ski> also, this means that we could then reserve the term "type constructor" for "atomic defined names on type level" like `Int',`Maybe',`Either', but not `Either String'
02:01:39 <dminuoso> ski: Its refreshing to see someone else share my view in this.
02:01:50 <dminuoso> zincy: so the mapping `Maybe` creates * -> * is fixed.
02:01:56 <ski> so, in some way, there's a vague parallel here between data constructors, and type constructors
02:01:58 <zincy> Type families allow you to pattern match at the type level right?
02:02:03 <dminuoso> zincy: Yes.
02:02:15 <dminuoso> zincy: so you cant have a type constructor map `Int` to `Float`
02:02:28 <zincy> So you use kinds to group your types and then map types between each other within your kind
02:02:31 <zincy> is that correct
02:02:32 <Ariakenom> type vs Type vs TYPE :)
02:02:48 <ski> zincy : you should group it as ⌜⊥ : (∀ (α : ★). α)⌝, so, for all types `alpha', of kind `*', `_|_' can be used as having type `alpha'
02:03:30 <dminuoso> zincy: so Maybe for example gives you an unconditional +1. You cant say "always add 1 to the type unless you stuff in Int"
02:03:41 <ski> zincy : `Int' is a type constructor (in the later sense i mentioned), but is not a type function. type functions have kind `K0 -> K1', for some kinds `K0',`K1'
02:04:10 <dminuoso> zincy: not with type constructors anyway. but you can with type families.
02:04:31 <zincy> ski: How can the kinds vary, I thought a type function would always have kind K -> K
02:04:54 <ski> (type functions should not be confused with function types. just like type tuple/records shouldn't be confused with type/record types. unfortunately the syntax for tuple types overlaps with that for tuple values, so that we can't as easily write a tuple, at the type level, of types (not necessarily all having kind `*'))
02:05:00 <Ariakenom> hm is type the same as forall k. TYPE k?
02:05:34 <dminuoso> zincy: In the generalized concept they can.
02:05:40 <ski> zincy : `Maybe' has kind `* -> *'. `Either' has kind `* -> (* -> *)'. `Fix' has kind `(* -> *) -> *'. `MaybeT' has kind `(* -> *) -> (* -> *)' .. and so on
02:05:44 <dminuoso> zincy: You could imagine a type family: (* -> *) -> *
02:05:53 <dminuoso> zincy: Or perhaps (# -> *)
02:06:05 <zincy> #kinds are new to me
02:06:09 <dminuoso> zincy: Then ignore it.
02:06:16 <dminuoso> zincy: ski has given plenty other examples. :)
02:06:50 <ski> type families allows type functions which are not parametric/uniform in their arguments
02:07:12 <zincy> So the kind of the resulting type can vary?
02:07:21 <ski> type constructors (barring GADTs !), and type synonyms, are all parametric/uniform in arguments
02:07:22 <zincy> with type families?
02:07:37 <dminuoso> zincy: Even with type constructor functions.
02:07:44 <dminuoso> zincy: Either :: * -> (* -> *)
02:07:54 <dminuoso> zincy: Do you see how the input kind is different from the output kind?
02:08:01 <dminuoso> * is certainly not the same as * -> *
02:08:04 <ski> (however, in the case of GADTs, you can recover the shape of the type parameters, by matching on the data constructors .. not so for type families)
02:08:12 <zincy> makes sense yeah
02:08:49 <ski> zincy : kinds are "the types of types"
02:08:55 <dminuoso> zincy: So `Either` is a type function that creates type constructors. If you want. :-)
02:09:02 <dminuoso> Thats one way to see it anyway.
02:09:05 <zincy> So with type constructors the kind of the types in the parameters cannot vary thus are uniform
02:09:24 <zincy> a parametric type function?
02:09:35 <zincy> whereas type families are type level functions which are not paramertric?
02:09:54 <ski> <zincy> So with type constructors the kind of the types in the parameters cannot vary thus are uniform
02:09:58 <ski> no
02:10:08 <ski> specifically to the "the kinds of the types" part
02:10:14 <dminuoso> zincy: Remember how I said Maybe is a sort of (+1)?
02:10:18 <zincy> Right
02:10:24 <ski> it's not about the kinds of the parameter types
02:10:24 <zincy> and Maybe is always (+1)
02:10:25 <dminuoso> zincy: It is uniformly a (+1) no matter what type you put in.
02:10:39 <zincy> yep
02:10:41 <dminuoso> You cant say "Its +2 if an Int is passed and +0 if a Float is passed"
02:10:49 <dminuoso> Not with type constructors anyway.
02:10:54 <zincy> Right but type families do that?
02:11:00 <zincy> well can ...
02:11:01 <dminuoso> You can, if you want.
02:11:15 <zincy> That is what I mean by not parametric
02:11:20 <zincy> meant
02:12:42 <ski> * ski wouldn't say "the same _|_", fwiw
02:12:51 * dminuoso noticed
02:13:02 <Ariakenom> hm, inhabitable type = TYPE k
02:13:09 <dminuoso> Ariakenom: nope
02:13:15 <dminuoso> Or.. wait.
02:13:46 <dminuoso> Ariakenom: Yeah.
02:13:47 <ski> another point there is that i tend to think of different types as "carving out" different "universes of values", with values from different types not being (a priori) comparable to each other, unless one add some notion of subtyping, or the like
02:14:17 <dminuoso> ski: Interesting thought.
02:14:27 <dminuoso> ski: what value do you get from that line of thinking?
02:14:30 <ski> some people tend to prefer thinking in terms of some kind of collection of "all values", and then using types to classify those in useful and meaningful ways
02:14:45 <ski> there are points to each of these two perspectives
02:15:01 <zincy> ski: Did Agda make your Haskell better?
02:15:53 <ski> dminuoso : representation independence. it simply doesn't make sense, from a semantical standpoint (from the level of reasoning in the language, rather than talking about implementations) whether a value of type `T' is represented the same as a value of type `U', unless `T' and `U' are known to be equal types
02:16:13 <ski> it's simply a nonsensical question, a non-question, ill-formed/typed
02:16:49 <ggole> There are properties other than semantic ones. The question makes sense when you look at those.
02:16:53 <ski> and for this reason, it doesn't make sense to ask about the union or intersection of any two sets in math. only if they're given to you as being subsets of a common "domain of discourse"/"universe" does it make sense
02:17:11 <Ariakenom> ski: sounds like a top down vs bottom up value-type hierarchy
02:17:36 <ski> a "universe" here is of course just the same notion as a "type", aka "sort" in some contexts
02:18:23 <ski> a type would sometimes be known as a "structural set", while a subset of a type would be known as a "material set". see <http://golem.ph.utexas.edu/category/2013/01/from_set_theory_to_type_theory.html> for some discussion about that
02:18:56 <Ariakenom> although ski's view is the only one that makes sense to me
02:19:38 <ski> Ariakenom : yea .. i think Jean-Yves Girard in "Proof and Types" (book) at <http://www.paultaylor.eu/stable/prot.pdf> talks a little bit about both of these perspectives
02:20:05 <dminuoso> ski: It sort of reminds me how in category theory there is no notion of "picking an object". Its just not part of the definition of a category.
02:20:31 <dminuoso> (Though you could define yourself a diagram which lets you cleanly define what it means to "select an object" with terminology that you can work with)
02:20:48 <ski> at least to a large degree (perhaps depending a bit on field ?), mathematical practice tends to conform with distinguishing the structural set aspect from the material set aspect, at least in practice, if not so much explicitly, as what one pays lip service to
02:21:19 <ski> dminuoso : can you elaborate on what you had in mind by "select an object" ?
02:21:59 <ski> ggole : yes, in terms of representation/implementation, it certainly can make a lot of sense. e.g. we have `newtype' in Haskell
02:23:19 <ggole> There are operational characteristics that you can consider, too (even without looking at the exact implementation)
02:23:40 <ski> yea, i suppose there's things like "proper tail recursion", e.g.
02:23:45 <ski> is that the kind of thing you had in mind ?
02:23:55 <ggole> Yeah.
02:24:02 <ski> (and that term is really a misnomer, as i'm sure you know)
02:24:21 <dminuoso> ski: Well it was from a talk about limits. It introduced the notion of diagram to distance yourself from "pick an object in a category and show this"
02:24:43 <ggole> "This doesn't take up more storage than that" is (sometimes) a useful question to be able to answer, for example
02:25:09 <ski> well, often "pick an `x'" means more or less "assume you're given any valid `x'"
02:25:37 <ski> ggole : yea .. and then the whole time and space complexity thing
02:25:50 <dminuoso> ski: The point was, you cant simply open up a category and take an object into your hand in a proof relevant way.
02:26:14 <ski> well, that's sortof what natural transformations are all about
02:26:23 <zincy> You get type level lists , can you get type level maps?
02:26:25 <dminuoso> But otoh if you talk about a diagram with a functor, you suddenly reuse category theory objects.
02:26:35 <ski> you can't priviledge some objects by handling them specially, generally speaking
02:26:47 <dminuoso> zincy: http://hackage.haskell.org/package/type-level-sets apparently yes. ;)
02:26:54 <ski> (well, you can, if your category is given as a "data type", say ..)
02:27:10 <dminuoso> ski: Sure, but that is constrained to a particular category.
02:27:16 <ski> but if it's a "large category", more relevantly, it's "open" in a certain sense, then you can't
02:27:21 <dminuoso> ski: In the talk it was used to define the generalized notion of product as a limit.
02:27:36 <ski> i think Martin-Löf talks a little about this in his 1984 Bibliopolis notes on Type Theory
02:27:36 <dminuoso> Which must work even if you dont have a category given as a "data type"
02:28:02 <ski> (linked from <https://intuitionistic.wordpress.com/works-on-martin-lofs-type-theory/>, i believe)
02:28:41 <ski> dminuoso : *nod*
02:28:51 <zincy> Why would you aWhen would you use type level maps vs lists? Performance? :D
02:29:28 <ski> (i suppose you could imagine also doing a "case distinction" on the category. "if we're in `Group', then we define the concept like this, otherwise like that")
02:30:23 <ski> zincy : perhaps you want to associate `Symbol's to types, for some reason ? (perhaps to represent record and variant types ?)
02:30:45 <dminuoso> zincy: Servant could actually serve as an interesting example of where a type level map *could* be used.
02:30:49 <ski> (or maybe for type-checking some object language)
02:31:26 <ski> <ski> dminuoso : "Why did you write (hmm ..) there?" -- because i've been thinking about a type system which allow exactly things like `x :: Maybe' :)
02:31:38 * ski thinks that might have gotten lost in the noise at the time)
02:31:50 <dminuoso> ski: Oh yes. In what sense would that be allowed? 
02:32:18 <ski> well, consider something like `nss :: [[Integer]]'
02:32:37 <zincy> I seen an example of a type level scoping type for variables as type family HasSymbol (g :: [(Symbol,*)]) (s :: Symbol) :: Maybe * where  
02:32:48 <zincy> Surely map is a better fit here?
02:33:17 <ski> imagine if you could name "the outer list level, excluding the actual contents (being lists in this case)", and separately name "the inner list level(s)", and finally each particular `Integer' (that would be a plural of a plural sort of thing)
02:33:41 <zincy> Does the value level intuition carry over of I wouldn't want to traverse the whole list to test for membership when I could do it in constant time
02:34:05 <ski> consider the laws
02:34:28 <ski>   join (return ma) = ma
02:34:34 <ski>   join (fmap return ma) = ma
02:34:55 <roflik> i'm trying to use Text.Printf (printf) with Data.Text, and i'm getting "No instance for (PrintfType Text) arising from a use of 'printf'.  do i have to convert the format string to String?
02:34:56 <ski>   join (fmap join mmma) = join (join mmma)
02:35:10 <ski> what if we could express them instead as something like
02:35:57 <ski>   join (| return (| |),m |) = m
02:36:04 <ski>   join (| m,return (| |) |) = m
02:36:28 <ski>   join (| join (| m0,m1 |),m2 |) = join (| m0,join (| m1,m2 |) |)
02:36:36 <ski> or, take the laws
02:36:56 <ski>   sum (sing n) = n
02:37:11 <ski>   sum (concat nss) = sum (map sum nss)
02:37:12 <ski> where
02:37:16 <ski>   sing = (: [])
02:37:31 <ski> we could imagine reformulating these laws something like
02:38:03 <ski>   sum (| sing (||) | n |) = n
02:38:30 <dminuoso> zincy: Just know that type level arithmetic is not exactly... fast...
02:38:34 <ski>   sum (| concat (| l0,l1 |) | n |) = sum (| l0 | sum (| l1 | n |) |)
02:39:33 <Ariakenom> roflik: do you want to use printf? It's not the simplest way to format
02:39:37 <ski> in the monad law case, we're taking seriously that monads are really monoids .. in some unfamiliar category. and so `m' (and `m0',`m1',`m2') in those laws has type `M', where `M' is the monad in question
02:40:23 <ski> in the summing of lists of numbers (or really inhabitants of any monoid) case, `n' has type `Integer' (or the monoid in question), while `l0',`l1' has type `[]'
02:40:32 <ski> recall the types
02:40:51 <ski>   return :: Id -> M
02:40:57 <ski>   join :: M . M -> M
02:41:00 <Ariakenom> roflik: but yes, it looks like it only takes String
02:41:12 <ski>   sum :: [] Integer -> Integer
02:41:24 <ski>   sing :: Id -> []
02:41:31 <ski>   concat :: [] . [] -> []
02:42:29 <ski> so when i write e.g. `(| l0,l1 |)' i'm thinking of this as a "pair" of some weird sort, of "type" `[] . []'. so the composition `.' at the type level (of functors) is thought of as some kind of "product"
02:42:46 <ski> dminuoso : that's more or less the basic idea/motivation
02:43:08 <roflik> Ariakenom: it's ok, i'm used to printf from other languages (and specifically want to avoid (++)).  my PrintfType issue was cause by not converting the printf result to Text.  (i had q :: Text -> Text -> Text, q lo hi = printf fmt lo hi, but needed q lo hi = pack $ printf fmt lo hi)
02:43:18 <ski> i want to be able to talk about "layers of structure", name them explicitly, instead of having a mess of `fmap's
02:47:51 <zincy> type family HasSymbol (g :: [(Symbol, *)]) (s :: Symbol) :: Maybe * where 
02:47:59 <zincy> ^Are all three of these kind declarations?
02:48:26 <__monty__> I'm getting a clang linker error when running new-test. I have no idea how to go about fixing this. Am I missing a C library or something? http://ix.io/1IzP
02:48:31 <zincy> Is the [] kind the types of (types of types) 
02:51:54 <dminuoso> ski: Mmm, the syntax is too strange to me, with your (| and |)
02:55:52 <martin4> I asked about this yesterday and thought I understood but it turns out I didn't. How can I get this to compile? https://glot.io/snippets/fc2xeev531
02:58:23 <MasseR> martin4: check the type for MaybeT
02:59:35 <MasseR> MaybeT :: m (Maybe a) -> MaybeT m a
02:59:54 <MasseR> Your type for maybeA is Maybe Int
03:00:02 <zincy> :k MaybeT
03:00:03 <lambdabot> error:
03:00:04 <lambdabot>     Not in scope: type constructor or class ‘MaybeT’
03:00:04 <lambdabot>     Perhaps you meant ‘Maybe’ (imported from Data.Maybe)
03:00:45 <zincy> :k MaybeT is  (* -> *) -> (* -> *)
03:00:47 <lambdabot> error:
03:00:47 <lambdabot>     Not in scope: type constructor or class ‘MaybeT’
03:00:47 <lambdabot>     Perhaps you meant ‘Maybe’ (imported from Data.Maybe)
03:00:49 <MasseR> martin4: so you need to have a function of the signature `Maybe a -> m (Maybe a)` for you to use it with `MaybeT`, can you think of such a function?
03:01:02 <martin4> pure?
03:01:06 <MasseR> +1
03:01:39 <MasseR> Can you figure out the rest of the puzzle?
03:02:49 <martin4> oh
03:03:08 <martin4> So I need to write `MaybeT $ pure $` instead of `MaybeT $`
03:03:45 <MasseR> Try it out
03:03:51 <martin4> it compiles
03:04:41 <martin4> :)
03:06:04 <zincy> What is  the `~` doing here?       forall symb. (HasSymbol scope symb ~ 'Just varType) => 
03:06:23 <zincy> What should I google?
03:07:48 <MasseR> zincy: it's an equals relation
03:08:03 <MasseR> It means that left and right side are the same
03:08:54 <MasseR> https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/equality-constraints.html
03:09:01 <MasseR> (old ghc, but googles first result)
03:11:01 <ski> dminuoso : roughly, if `l :: []' and `m :: Maybe', then `(| l,m |) :: [] . Maybe'. and `(| |) :: Id'. further if `n :: Integer' (which would generally be a "plurality" of numbers), then `(| l,m | n |) :: ([] . Maybe) Integer'
03:11:59 <ski> zincy : `[]' is "list of". so the kind `[(Symbol,*)]' is the kind of type-level lists of pairs of symbols and (concrete) types
03:13:15 <zincy> ski: Thanks
03:13:30 <zincy> Each scope is then a value of this type then
03:16:00 <zincy> MasseR thanks
03:46:09 <Guest96606> I need to make a REST API call, first getting an authorisation token by providing email/password programmatically. Corresponding example in Python is here (https://gist.github.com/xfurrier/b3929f27ed99f0af76bf73f0386a48dd). What's the best way to do that in Haskell? I've made simpler calls by using Network.Wreq, but still struggling with this one.
03:48:36 <roflik> is there a flipped version of <$>?
03:49:10 <phadej> :t <&>
03:49:12 <lambdabot> error: parse error on input ‘<&>’
03:49:15 <phadej> :t (<&>)
03:49:17 <lambdabot> Functor f => f a -> (a -> b) -> f b
03:49:30 <phadej> % :i (<&>)
03:49:31 <yahb> phadej: (<&>) :: forall (f :: * -> *) a b. Functor f => f a -> (a -> b) -> f b -- Defined in `Data.Functor'; infixl 1 <&>
03:49:43 <phaul> hackage.haskell.org is down.
03:49:57 <phadej> phaul: it isn't?
03:50:06 <roflik> phadej: thx!
03:50:11 <roflik> phadej: it was for a bit
03:50:47 <phaul> I still can't access it
03:51:05 <phaul> also https://downforeveryoneorjustme.com/hackage.haskell.org says it's not just me
03:52:41 <Ariakenom> https://downforeveryoneorjustme.com/hackage.haskell.org tells me it's just me
03:53:51 <Ariakenom> location dependent is up check, ha
03:54:43 <Ariakenom> https://status.haskell.org/ is green
03:55:22 <phaul> ok good now here too. Maybe you were checking after it came back
03:56:09 <Ariakenom> ok
05:08:48 <mupf> On May 12 it's been a year ever since ertes is gone.
05:09:02 <mupf> wow. 
05:13:29 <zincy> who is ertes?
05:14:05 <phadej> a person who helped a lot of people on this channel
05:14:28 <zincy> gone sounds ominous
05:14:55 <zincy> I actually think I remember them
05:15:14 <phadej> yes, he is deceased
05:15:34 <zincy> What happened :(
05:15:42 <phadej> only close people know
05:16:48 <zincy> Sad he would have been in his 30s it seems
06:05:30 <mupf> zincy phadej he was 33 and died of heart problems.  Here is his Hackage profile: http://hackage.haskell.org/user/ErtugrulSoeylemez
06:25:45 <ski> oh, ertes is gone ?! :/
06:32:23 <ezyang> piyush-k`: hi 
06:38:40 <osa1> does anyone know what parameters stack passes to ghc/cabal when passed --profile flag? e.g. `stack build --profile` 
06:42:18 <saml> no i don't know
06:45:28 <delYsid`> Why is low + hig) `div` 2 supposedly wrong when doing binary search?
06:45:45 <delYsid`> (lo + hi) `div` 2
06:45:54 <fendor> delYsid`, becuase of integer overflow normally
06:46:28 <delYsid`> (watching this video https://www.youtube.com/watch?v=OJLcGJqvWgQ around 4:20, however, I am blind and dont see the slides presented)
06:47:52 <talqu> hi, I need a simple lib to be resize uploaded images. What would you suggest?
06:48:17 <delYsid`> fendor: Ahhh, get it, thanks
06:48:37 <fendor> delYsid`, you're welcome
06:50:27 <Wilmpe> s <- readFile "..."   and then I want to   let rows = Data.Text.lines . fromString $ s    – how can I run this strictly (via `seq`?) to force the whole list to be read into memory?
06:51:01 <delYsid`> fendor: So l + ((h-l) `div` 2) is what is supposed to be done?
06:51:16 <Ariakenom> Wilmpe: use bang patterns
06:51:31 <Ariakenom> let !rows = ...
06:51:32 <fendor> delYsid`, iirc yes
06:51:39 <Wilmpe> Ariakenom: thx
06:52:39 <Ariakenom> Wilmpe: oh no wait, that won't work
06:53:11 <Ariakenom> Wilmpe: you'd need deepSeq
06:54:24 <Ariakenom> Wilmpe: let !rows = force (...)
06:54:24 <Ariakenom> https://hackage.haskell.org/package/deepseq-1.4.4.0/docs/Control-DeepSeq.html#v:force
06:54:52 <c_wraith> Wilmpe: the better solution is to use Data.Text.IO.readFile, which reads the whole thing in one shot anyway
06:55:11 <c_wraith> Wilmpe: *and* you don't need to convert it to Text with a separate function afterwards
06:55:37 <byorgey> delYsid`: yes.  Obviously this only matters if you have a very large array.
06:57:23 <byorgey> I think it is a bit melodramatic to say (lo + hi) `div` 2 is "wrong".
07:01:21 <Ariakenom> byorgey: with 64 bit ints it shouldnt be a problem with a dense array
07:01:50 <c_wraith> Ariakenom: binary search need not be applied to arrays only.  You might just be binary-searching the input space of a function
07:04:19 <Ariakenom> c_wraith: Indeed, hence the dense array part.
07:06:25 <Ariakenom> byorgey: I would definitely call it wrong, with bounded ints
07:15:40 <c_wraith> I'd give it a bit more subtlety.  It's wrong for a general-purpose library.  It probably is totally fine as a one-off in a case where the inputs are known to be bounded at smaller than half the maximum int
07:18:58 <dmwit> This is why I index all my arrays by Rational.
07:19:26 <Ariakenom> I use Float because it's faster, it has pretty big numbers so it's fine
07:22:06 <Solonarv> dmwit: does that even have an Ix instance?
07:22:07 <dmwit> Oh, Float is fun. Numbers ranging from 3e-38 to 3e38, and fully half of them lie between -1 and 1.
07:22:29 <dmwit> Solonarv: I use reticulated splines to interpolate between neighboring array elements.
07:22:31 <Solonarv> just checked - it doesn't
07:22:37 <monochrom> Float is even worse than Int32.
07:23:27 <monochrom> Unless you mean you were joking.
07:23:29 <Solonarv> (I jumped in halfway through the convo, I don't have context)
07:24:37 <dmwit> Solonarv: I use the standard Calkin-Wilf enumeration of Rationals for my Ix instance.
07:24:52 <Ariakenom> dmwit: also 2^24 million nans or so
07:24:58 <dmwit> (Challenge problem: what is the property on predicates that makes binary search sensible in this instance?)
07:24:59 <Ariakenom> dmwit: also 2^24 nans or so
07:34:46 <zincy> How would you go about showing the result of a program here : https://gist.github.com/gallais/12e5ff1015fd28a6fce8c693f8b59a3d
07:38:43 <bahamas> hello. can anyone tell me how I use `tlTables` here to get the corresponding field out of a response? for sure it involves lens given the type signature, but I don't know how https://hackage.haskell.org/package/gogol-bigquery-0.4.0/docs/Network-Google-BigQuery-Types.html#t:TableList
07:43:58 <bahamas> `view tlTables tables` worked
07:44:18 <dmwit> There's also an infix name. `tables ^. tlTables`.
07:44:50 <dmwit> Requires less parentheses when the lens is a constructed one.
07:46:10 <dmwit> zincy: What is the result of a program?
07:46:39 <phaul> is there a succint way of doing old <- get; put new; res <- m ; put old; return res; in the state monad? feels like something that should be in the libs but I cant find it
07:46:56 <zincy> a value of type Program which doesn't have  a Show instance
07:47:20 <phaul> what I want is  executing m while the state is temporarily modified
07:47:52 <dmwit> zincy: I mean, you'd write a pretty-printer. Whether you call that pretty-printer "show" or not is up to you.
07:49:02 <dmwit> :t evalStateT
07:49:03 <lambdabot> Monad m => StateT s m a -> s -> m a
07:49:21 * ski would not make it an instance of `Show', if it's pretty-printing in some custom format
07:49:21 <dmwit> phaul: evalStateT (lift m) new
07:49:31 <phaul> cool. thanks
07:49:46 <dmwit> :t \m new -> evalStateT (lift m) new
07:49:47 <lambdabot> Monad m => m a -> s -> m a
07:50:12 <dmwit> Oops.
07:50:15 <dmwit> That doesn't do what I want.
07:51:21 <Solonarv> I don't think there's a library function which does this
07:51:58 <dmwit> :t (\m new -> evalStateT (Control.Monad.Morph.hoist lift m) new) :: Monad m => StateT s m a -> s -> StateT s m a
07:51:59 <lambdabot> Monad m => StateT s m a -> s -> StateT s m a
07:52:29 <dmwit> But note the input is not polymorphic over all MonadState instances. Bummer.
07:52:32 <ski> @type let localState :: MonadState s m => (s -> s) -> m a -> m a; localState f act = do s <- get; put (f s); a <- act; put s; return a in localState
07:52:33 <lambdabot> MonadState s m => (s -> s) -> m a -> m a
07:53:25 <dmwit> Anyway, there's nothing existing that I know of that does *exactly* what you said.
07:53:40 <Solonarv> yeah
07:53:44 <dmwit> For StateT in particular I like my answer better than yours or ski's. =)
07:53:53 <Solonarv> I wrote it as a gist once but I haven't found it yet
07:53:54 <phaul> ok. I just do the code then. Just wanted to check with you
07:54:11 <phaul> thanks all
07:55:02 <Solonarv> alright, can't find it
07:55:10 <Solonarv> it's pretty much the same as what ski gave anyway
07:57:14 <ski> @type let localStateT :: Monad m => (s -> s) -> StateT s m a -> StateT s m a; localStateT f act = lift . evalStateT act . f =<< get in localStateT
07:57:15 <lambdabot> Monad m => (s -> s) -> StateT s m a -> StateT s m a
08:12:40 <zincy> how do you convert a type to a string at the value level?
08:14:14 <jgt> zincy: you mean other than with show?
08:14:33 <jgt> zincy: oh, a type
08:14:47 <jgt> iirc typeable
08:15:20 <jgt> zincy: https://chrisdone.com/posts/data-typeable/
08:18:40 <Solonarv> typeOf gets you a TypeRep, which you can then simply 'show'
08:18:51 <Solonarv> > show (typeOf "hello")
08:18:53 <lambdabot>  "[Char]"
08:19:53 <zincy> Im not sure if that is the right idea for printing out the following program https://gist.github.com/gallais/12e5ff1015fd28a6fce8c693f8b59a3d
08:19:53 <dmwit> Shower thought: even if you have MonadState because there's a StateT deep in your transformer, you can use hoist (hoist (hoist (... hoist lift...))) to get where you need to go.
08:20:01 <zincy> jgt: thanks
08:20:16 <dmwit> Just like we have MonadState to apply lift to get and put the right number of times, there's probably an analogous generalization to apply hoist the right number of times.
08:20:36 <dmwit> Like a higher-order MonadState class (and one for MonadReader, etc.).
08:20:50 <dmwit> Smells like dependency injection. =)
08:22:06 <dmwit> zincy: Nothing about that program makes me nervous about my plan. What makes you nervous?
08:22:48 <Solonarv> dmwit: if you know precisely how deep the StateT is, and all the transformers on top of it have an MFunctor instance, yes
08:22:59 <Solonarv> example of a transformer without an MFunctor instance: ContT
08:23:05 <zincy> dmwit: Just in a general state of confusion :D
08:23:32 <zincy> What is the Data typeclass for
08:23:49 <dmwit> Solonarv: Similar caveats apply to using lift repeatedly.
08:23:55 <dmwit> Solonarv: I see no particular problem with that.
08:23:59 <Solonarv> fair enough
08:24:29 <Solonarv> note that some of the mtl class methods already can't be implemented by repeated use of lift, for example local
08:24:43 * dmwit nods agreeably
08:29:01 <lyxia> zincy: it's generic metaprogramming, defining functions that work over a large class of types defined by their structure.
08:30:25 <zincy> data Program = forall h. Program (Statements '[] h)  deriving Typeable 
08:30:39 <zincy> ^ Do I need a typeclass constraint on h for Typeable?
08:32:22 <phadej> no
08:32:22 <ski> depends on how `Statements' is defined ?
08:32:34 <phadej> it's irrelevant
08:32:46 <ski> if `Statements f h' is indexed on `h', then you probably don't
08:33:25 <ski> (but if it's uniform in `h', then maybe it could be useful .. depending on what you're doing and what you want to do)
08:33:29 <phadej> Typeable only gives you way to ask whether something is `Program`, the existential h is irrelevant
08:33:56 * ski str McBride using terms "catholic" vs. "presbyterian" for some distinction like this, but can't recall details ..
08:34:21 <zincy> ok thanks
08:34:49 <phadej> (where `Data` would give you a way to actaully look into it, and I for `Data` you'd need constraints on `h`, yes)
08:36:06 <zincy> Don't understand my typeerror https://pastebin.com/wXjFBuYJ
08:36:17 <zincy> At the bottom in the comment
08:38:50 <ski> zincy : can't you derive `Show' in `Statement' and `Statements' ?
08:38:55 <ski> s/in/on/
08:39:10 <zincy> no :(
08:39:17 <ski> oh, you have an empty `instance Show (Statements a b)'
08:39:19 <ski> did you try
08:40:02 <ski>   deriving instance Show (Statements inn out)
08:40:12 <ski>   deriving instance Show (Statement inn out)
08:40:37 <ski> of course you'll need `Show' also on `Type',`VarName'
08:41:09 <ski> zincy ^ ?
08:41:56 <zincy> on it
08:42:49 <zincy> That seems to work
08:42:53 <zincy> however: Can't make a derived instance of ‘Show Program’
08:43:04 <ski> (btw, the type error in tha paste is complaining that you don't have `Typeable h' in `Program', i think)
08:43:19 <zincy> It compiles now
08:43:30 <ski> including `Show Program' ?
08:43:51 <zincy> Yeah
08:43:54 <ski> good
08:44:01 <zincy> but printing an example program doesn't give any output
08:44:13 <zincy> weird
08:44:42 <zincy> The example Program in the Gist it is copied from
08:45:14 <ski> do you still have a manual `Show' instance left ?
08:45:39 <msvan_> so it seems that stack solver is getting removed. What am I supposed to use instead? My usual flow for adding a package is to add it to package.yaml and then type `stack solver --update-config`
08:46:22 <phadej> move to use `cabal-install-3.0` once it's released
08:46:32 <phadej> (or cabal-install-2.4, it's good too)
08:47:48 <zincy> ski: That might be it
08:47:59 <glguy> phadej: What's the timeline for a cabal-install-3?
08:48:07 <phadej> glguy: around 8.8
08:48:10 <phadej> ghc
08:48:16 <zincy> Ski: When I try and derive Show for Program:  Can't make a derived instance of ‘Show Program’:
08:48:45 <zincy>           Constructor ‘Program’ has existential type variables in its type Possible fix: use a standalone deriving declaration instead
08:56:39 <ski> zincy : yes, so try `deriving instance Show Program'
09:00:54 <zincy> ski: https://pastebin.com/rbqtpcN1
09:03:54 <ski> zincy : ok, so it's telling you about more `Show' instances that it's missing
09:05:02 <zincy> oh Exp and ScopedVariable
09:06:47 <zincy> Oh it works!
09:07:07 <ski> great :)
09:07:17 <zincy> Program (Declare VarName Of :> (Assign (The VarName) (Number 1) :> (Declare VarName Of :> (Assign (The VarName) (Add (Variable (The VarName)) (Number 1)) :> (Assign (The VarName) (Add (Variable (The VarName)) (Number 1)) :> (Assign (The VarName) (Not (Boolean True)) :> Done)))))
09:07:20 <ski> zincy : including actually giving sensible output when used ?
09:07:25 <ski> okay :)
09:07:26 <zincy> ^ they are all types right
09:07:46 <ski> that looks like a term/value, not a type
09:08:35 <zincy> hmm they are perhaps all expression values
09:08:50 <ski> fwiw, i'd possibly write a custom instance of `Show' for `Statements' in order to take advantage of `infixr 5 :>' (which the derived instance is sadly ignoring)
09:09:01 <zincy> Just confused about (:>) as it is a data constructor but used as a typeOperator
09:09:10 <ski> that way you wouldn't get such a huge build-up of closing brackets at the end
09:09:35 <ski> no, i don't see `:>' being used as a type operator at all, in that paste
09:10:13 <Solonarv> also, it'd be possible to write a custom Show instance to print (Of :: Type whatever) instead of just Of
09:10:17 <zincy> You are right it is (:) which is used as a type operator
09:10:45 <Solonarv> DataKinds!
09:11:50 <zincy> How do you get the phantom type as a value to feed into typeOf?
09:11:58 <zincy> Of is a data constructor for a proxy type
09:13:07 <Solonarv> scoped type variables
09:13:18 <ski> Solonarv : right, i was thinking that, but forgot to mention it :)
09:14:03 <zincy> What is the intuition for using (:) as a type operator? It combines types?
09:14:18 <Solonarv> it's just the DataKinds-lifted (:) constructor
09:14:33 <Solonarv> so, it prepends to a type-level list
09:14:47 <kuribas> don't you need backtick?
09:14:51 <kuribas> ':
09:14:53 <zincy> yeah
09:14:57 <Solonarv> only to disambiguate
09:15:16 <Solonarv> in this case : alone is not ambiguous so you don't need the tick
09:15:21 <zincy> so ': is just a  Type a b 
09:15:35 <Solonarv> no, 'Type a b' is ill-kinded
09:15:39 <zincy> So it is using a recursive type to express a list
09:16:24 <Solonarv> yes, and the recursive type is [Type], i.e. the usual list type
09:17:10 * ski . o O ( `[(Symbol,Type)]' )
09:17:18 <Solonarv> Solonarv: oh, right
09:17:19 <zincy> Can you get type level lists without using the kind :
09:17:22 <Solonarv> ski: *
09:17:45 <Solonarv> zincy: can you get term-level lists without using the function : ?
09:17:59 <zincy> cons?
09:18:10 <zincy> :t cons
09:18:11 <lambdabot> Cons s s a a => a -> s -> s
09:18:13 <Solonarv> that's just : in a trenchcoat
09:18:18 <zincy> :D
09:18:25 <zincy> ok so no
09:18:44 <Solonarv> well, you can construct an empty list without using : but that's all
09:18:58 <zincy> Perhaps : is just a recursive ___
09:19:43 <talqu> Hi again, I cannot find a library that allows me to scale an image passing a ratios for width and height respectively. I found this function in hip library but it is broken. Friday library only has resize function, which accepts absolute values for width and height. 
09:20:48 <ski> (not a kind `(:)'. it's a type `(:)' (of kind `k -> [k] -> [k]', for any kind `k') which is used there)
09:22:22 <zincy> Of course DataKinds promotes data constructors to types and types to kinds
09:22:27 <zachk> talqu, are you displaying the image to the screen? 
09:22:51 <zincy> ski: That kind declaration implies homogeneous lists right?
09:23:15 <zincy> well a list of types which are homogeneous in their kinds maybe
09:23:17 <zachk> talqu, if you are try gloss, and I believe it has a scale function that can scale by an x and a y factor 
09:23:29 <zincy> but heterogeneous in type
09:24:35 <talqu> zachk: no, just for resizing the image and moving it to a folder. I guess i'll use Friday lib then and pass it absolute values
09:24:51 <zachk> talqu, imagemagick maybe? 
09:25:08 <ski> zincy : homogeneous, yes
09:25:48 <zincy> but homogeneous type level lists allows for Data Family types to be used still right?
09:25:50 <ski> (`[]' is there a data kind)
09:26:31 <ski> i'm not sure what potential interaction issue you have in mind ?
09:27:52 <zincy> If you declare a data family you could have a type level list of the data family type name?
09:32:15 <ski> iiuc, i think so
09:34:22 <talqu> thanks zachk, ill check it
09:34:34 <zachk> its not haskell though :( 
09:34:42 <zachk> just a common unix utility 
09:35:14 <zincy> hmm how do I use ScopedsTypeVariables to print the a proxy's type variable?
09:36:45 <Solonarv> something like this:
09:36:45 <Solonarv> instance Typeable t => Show (Type t) where show x = "(Of :: " ++ show (typeOf x) ++ ")"
09:37:06 <Solonarv> also, just FYI: you don't need to write "deriving Typeable" anymore
09:38:26 <ski> i'd use
09:39:12 <ski>   showParen p x = showParen (p > 0) $ showString "Of :: " . shows (typeOf x)
09:39:27 <zincy> thanks ski and Solonarv
09:39:32 <ski> er, sorry
09:39:40 <ski> s/showParen p x/showsPrec p x/
09:39:41 <fizbin> I have a haskell-based service that (according to ps) is using over a terrabyte of virtual memory, yet was started with +RTS -M3G. Any suggestions on how I start debugging this?
09:39:49 <Solonarv> yeah,do like ski suggested
09:40:09 <ski> (i dunno why i'm mixing those two up when writing them)
09:40:20 <geekosaur> fizbin, ps will show the 2-stage allocator
09:40:21 <zincy> what is showsPrec for
09:40:35 <ski> zincy : instead of the `show', in the `Show' instance
09:40:41 <zachk> fizbin, I have heard that 64 bit ghc allocates a ton of memory, that it rarely ever uses 
09:40:46 <geekosaur> sigh
09:40:59 <zachk> wrong?
09:41:05 <geekosaur> address space, not memory
09:41:09 <geekosaur> ps doesn't expect this
09:41:15 <ski> `showsPrec' also gets the current precedence level, that way it won't always wrap the `Of :: <type>' in outer brackets, unless needed
09:41:41 <ski> (e.g. if you have a value of type `[Type a]', then it won't add those outer brackets around the elements)
09:41:42 <fizbin> geekosaur: Right, so if I saw it with a VSZ of 6 gig, or maybe 7 or 8 gig, I wouldn't worry too much, but this is like 1070 gig.
09:42:10 <geekosaur> most of that TB of space doesn't have any memory pages associated, it's just the page maps that have been allocated. ps isn't smart and reports it as actual memory
09:42:20 <fizbin> Hrm.
09:43:17 <ski> (fizbin : ooc, is the nick inspired by HoMM ?)
09:43:21 <zachk> geekosaur, why does ghc do that? allocate so much space? 
09:43:25 <fizbin> Okay, but I do think I have some sort of memory leak because once/day about 15-20% of the servers get into a state where they stop accepting connections and need to be restarted.
09:43:29 <geekosaur> 2-stage memory allocator
09:44:05 <fizbin> I guess the next step is to turn on verbose garbage collection and watch it overnight.
09:45:31 <fizbin> ski: No, it's a nick I've had since... idk, I might have used it on LambdaMOO in the 90s? No, I guess that was faber. Anyway, chosen to be short but pronounceable.
09:45:34 <zincy> ski: why showsPrec p x ?
09:45:48 <zincy> data Type (a :: *) = Of
09:47:24 <geekosaur> https://ghc.readthedocs.io/en/8.0.1/8.0.1-notes.html#runtime-system
09:47:47 <geekosaur> ^ re 2-stage allocator. as far as I know that and linked ticker are the only real documentation for it
09:48:51 <ski> fizbin : *nod*, fair enough
09:49:16 <fizbin> geekosaur: Ah, yeah. I had just now found the linked ticket.
09:49:21 <zincy> https://pastebin.com/0te3vsXv
09:49:36 <ski> <ski> `showsPrec' also gets the current precedence level, that way it won't always wrap the `Of :: <type>' in outer brackets, unless needed
09:49:39 <ski> <ski> (e.g. if you have a value of type `[Type a]', then it won't add those outer brackets around the elements)
09:49:42 <ski> zincy ^
09:49:57 <zincy> I see :)
09:50:49 <ski> zincy : i indicated only the *first* `showParen' was incorrect, ought to be replaced by `showsPrec'. the second `showParen' should stay
09:50:55 <ski> sorry if i wasn't clear enough
09:51:07 <zincy> no you were, my mistake
09:51:47 <zincy> really appreciate it, you and Solonarv have really helped me of late
09:51:49 <ski> (i've done this mistake twice now, once in this direction, once in the opposite direction .. grmbl)
09:52:33 <ski> zincy : btw, fyi, `shows = showsPrec 0'
09:52:50 <ski> so `shows' starts at precedence level zero
09:55:29 <zincy> ski:       • No instance for (Typeable a) arising from a use of ‘typeOf’
09:55:30 <zincy> showsPrec p x = showParen (p > 0) $ showString "Of :: " . shows (typeOf x)
09:55:57 <zincy> Do I need a typeclass constraint to the type variable in Type?
09:56:07 <ski> did you add a `Typeable' constraint on `h' in `Program' ?
09:56:13 <ski> hm, sorry
09:56:20 <ski> this is not about `Program'
09:56:46 <ski> hm, yea
09:56:53 <ski> i think you need one on `a' in `Type'
09:57:31 <ski>   data Type a = Typeable a => Of
09:57:31 <ski>                 deriving Typeable
09:57:41 <Solonarv> ski: please no
09:57:49 <Solonarv> just add it to the Show instance
09:57:51 * ski ponders
09:57:56 <ski> oh ..
09:58:00 <Wilmpe> c_wraith: good, will do that
09:58:02 <Solonarv> instance Typeable a => Show (Type a) where ...
09:58:10 <Solonarv> (as I already suggested above)
09:58:11 <ski> for some reason i thought zincy had already tried that
09:58:22 <ski> (can you tell i'm a bit tired atm ?)
09:58:30 <Solonarv> slightly :>
10:00:31 <Wilmpe> What are the differences between a Data.ByteString.Lazy.ByteString and a Data.ByteString.Lazy.Char8.ByteString? How can I convert from one to the other?
10:01:30 <geekosaur> they're the same thing underneath, only the functions used to access them differ. "Char8" means the functions pretend it's a [Char] instead of a [Word8], which makes it somewhat dangerous
10:02:30 <Wilmpe> geekosaur: if I use just the lazy version, how can I split into lines?
10:04:12 <geekosaur> http://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString-Lazy.html#v:split
10:05:12 <Wilmpe> That looks good, thx geekosaur.
10:07:36 <Wilmpe> geekosaur: how can I go from a char '\n' to a Word8, so that I can call this?
10:07:51 <Wilmpe> The example as shown by your link simply uses '\n'.
10:08:29 <geekosaur> yeh, the example is using the Char8 version. you can simply use 10
10:08:33 <zincy> Why is varType coming up? https://pastebin.com/rX9XvbKu
10:08:41 <zincy> Solonarv ski ^
10:14:29 <Solonarv> hm, perhaps packing a Typeable constraint into Type is not a bad idea after all
10:15:03 <Solonarv> change its declaration to: data Type (a :: *) where Of :: Typeable a => Type a
10:15:08 <ski> zincy : because you have a `Typeable a' constraint on `Show (Type a)', and `varType' is not a parameter of `Statement inn out', so one can't add a `Typeable varType' constraint on the `Show' instance for that
10:15:34 <ski> zincy : so, either what Solonarv just said, or add `Typeable varType' on the signature of `Declare'
10:17:00 <zincy> The latter worked and I don't know why
10:17:27 <Solonarv> my suggestion in more detail:
10:17:27 <Solonarv> data Type (a :: *) where Of :: Typeable a => Type a
10:17:27 <Solonarv> instance Show (Type a) where
10:17:27 <Solonarv>   showsPrec p t@Of = ... shows (typeOf t) ...
10:17:55 <zincy> typeApplications?
10:18:20 <ski> `Show (Statement inn out)' requires `Show' on the argument types of `Declare' and `Assign'. and `Show' on `Type varType' requires `Show' on `varType' (by the manual `Show' instance you wrote before)
10:18:36 <ski> er, requires `Typeable' on `varType'
10:18:54 <Zemyla> Every time I read "STG" I always read it as "swear to God" first.
10:18:55 <ski> hence it needs to get that `Typeable varType' constraint from somewhere
10:19:25 <Solonarv> no, no type applications there
10:19:31 <Solonarv> just a regular old as-pattern
10:19:34 <ski> zincy : no, that's a normal "at"/"as"-pattern
10:19:47 <zincy> ah yes of course
10:19:53 <ski> (the syntactic overloading is perhaps a bit unfortunate)
10:20:36 <ski> matching on `Of', given the constraint `Typeable a' in `Type', on `Of', brings that constraint into scope, so that `typeOf' can refer to it
10:21:36 <zincy> nice
10:22:01 <zincy> now I just need to rewrite my eval function to get a value out of the Program
11:36:05 <sternmull> i just got the idea of a monad-set instead of a monad-stack (the usual combinder): A combination of monads that act independent of each other. For example you could combine a Reader and Writer by just keeping the state of the other when processing the action of one. Does this make sense? Or does it even already exist?
11:36:25 <dmwit> Read up on effect systems, which are roughly that.
11:36:46 <dmwit> I uh... have some quibbles with the idea. But it's certainly been well explored.
11:36:46 <int-e> add "composable" as a keyword?
11:37:06 <iqubic> How hard would it be to write a web program that has a JS + HTML + CSS frontend with a Haskell backend?
11:37:26 <Solonarv> sternmull: the thing is that not all "effects" are interchangeable like that
11:37:28 <sternmull> dmwit: Thanks, will see what i find about that.
11:37:32 <dmwit> iqubic: Not hard; indeed, common.
11:37:35 <dmwit> I've written several such.
11:38:00 <dmwit> I've used snap and enjoyed it. Other good choices to look into include yesod, warp, wai, scotty.
11:38:35 <iqubic> I notice that GHCJS isn't included in that list.
11:38:47 <dmwit> That's probably also sensible to look into.
11:38:59 <dmwit> It wasn't an intentional omission. My list was not intended to be exhaustive.
11:39:16 <sternmull> Solonarv: Right, but i have a feeling that utilizing independence where possible would make sense.
11:39:25 <int-e> Out of curiosity, I know lens has a combinator to focus on part of a state of a state monad... does that also exist for reader and writer?
11:39:38 <iqubic> Would that allow me to use JS features like the Canvas to draw things in the browser?
11:39:47 <dmwit> int-e: I believe yes for Reader. Not sure about Writer.
11:39:49 <sternmull> but i admit that i haven't thought too much about it
11:40:02 <glguy> There's locally
11:40:11 <Solonarv> iqubic: that happens on the front-end, which you said would be in JS
11:40:21 <Solonarv> the server doesn't care about drawing on canvases
11:40:24 <iqubic> Right. That's true.
11:40:58 <glguy> int-e: and I don't remember if its in released lens or not, but     char *arg1 = neg_arr;
11:41:04 <glguy> https://github.com/ekmett/lens/blob/7a9c21d4fab125f799a4c2fd6d4935f6dc6e1d86/src/Control/Lens/Setter.hs#L62-L64
11:41:22 <iqubic> dmwit: Would Servant be another way to combine a Haskell backend with a JS frontend?
11:41:41 <Solonarv> yes
11:41:59 <int-e> glguy: the C code was a mis-paste, I surmise?
11:41:59 <Solonarv> it is a bit heavier on the type-level stuff, though
11:42:11 <glguy> int-e: Yeah, that's not in lens
11:42:26 <iqubic> Solonarv: Type level stuff doesn't scare me.
11:42:55 <int-e> glguy: thanks, that looks about right :)
11:44:09 <iqubic> What is Hakyll?
11:44:18 <iqubic> Is that helpful/useful?
11:44:22 <phadej> static site generator
11:44:34 <phadej> if you need to generate static sites, then yes :)
11:44:42 <phadej> (e.g. blogs)
11:45:00 <iqubic> Does that mean I write the content for my static page *IN* haskell
11:45:15 <phadej> no
11:45:21 <Solonarv> no, that would be very cumbersome
11:45:33 <phadej> you write "a build system of your site in Haskell"
11:45:47 <Solonarv> you write it in markdown/RST/whatever, and use hakyll to specify how that should be converted to HTML
11:45:51 <phadej> e.g. https://github.com/zfoh/zfoh.ch
11:46:03 <iqubic> Or is hakyll more similar to pandoc, as in, you write a sort of "build system" in haskell?
11:46:21 <Solonarv> hakyll uses pandoc to perform that conversion, yes :D
11:46:30 <iqubic> Oh. I didn't know that. LOL.
11:57:22 <sm> iqubic, here's a possible progression: "I run pandoc to generate each web page from lightweight markup" -> "I use make + pandoc to generate pages which have changed" -> "I use hakyll as a more powerful haskell site-generating toolkit with make and pandoc built in" -> "I use shake + pandoc, still poweful but simpler and needs less recompilation"
11:58:28 <phadej> I wouldn't say shake is simpler than hakyll
12:00:10 <sm> maybe they're about the same ? but I feel learning shake is a better investment
12:01:21 <phadej> well, with shake you'll need to learn pandoc too
12:01:27 <phadej> with hakyll it's mostly hidden
12:02:06 <sm> I could link pandoc into my shakefile.. but for me running it as an external command is a feature
12:03:36 <phadej> maybe; I think that doing all processing in Haskell is nicer; that's what Haskell is good for
12:05:10 <phadej> (I use e.g. https://hackage.haskell.org/package/latex-formulae-pandoc, which I have no idea how to plug into external pandoc)
12:06:42 <sm> "An executable is also provided which can be used as a Pandoc filter from the commandline"
12:07:04 <sm> pandoc filters are great
12:08:31 <phadej> but then you'll need all that installed externally, and not defined in a .cabal file :)
12:09:26 <sm> yes, a tradeoff. I got sick of having to do a massive rebuild when I least expected it and needed to fix a typo on a website
12:12:53 <phadej> index-state (cabal) or fixed resolver (stack)
12:25:46 <aplainzetakind> Vague question: when is TH justified?
12:28:57 <boj> aplainzetakind: when you want to reduce writing mechanical boilerplate
12:29:14 <Cale> aplainzetakind: Most of the TH I personally don't mind using is in the form of things which write boilerplate instances for things based on the structure of data types. You can get a lot more information about what's available than any generics system will give you, and of course, it works with GADTs when other systems for generics won't.
12:30:14 <adius> Uhm short question: Where is the cons operator `(:)` defined? 😳
12:30:50 <Cale> adius: It's built-in.
12:31:10 <Cale> (but it's morally defined by Prelude)
12:31:26 <Cale> It's part of the definition of the list data type
12:31:31 <aplainzetakind> Cale: I guess my intention fits that criteria. From `data Foo = Foo { fooA :: FooA, ... }` I want to automatically get stuff like `data Bar = Bar { barA :: BarA, ... }`.
12:31:45 <Cale> which, if you ignore the fact that it needs special syntax, could be written as
12:31:53 <Cale> data [a] = [] | (a : [a])
12:32:17 <ski> @src []
12:32:17 <lambdabot> data [] a = [] | a : [a]
12:32:30 <Cale> aplainzetakind: I usually don't care for TH which generates names that don't appear in the source
12:32:39 <adius> Cale: Well that explains it. I was looking in Data.List …
12:33:29 <adius> Although I feel it shouldn't be built in ^^
12:33:44 <adius> *like
12:33:46 <Cale> adius: There's no reason it needed to be built in apart from the syntax sugar
12:34:03 <ski>   data List a = Nil | Cons a [a]  -- basically it's this, except with special syntax
12:34:14 <Cale> Cons a (List a)
12:34:18 <aplainzetakind> Cale: Is there a quick and dirty tutorial to teach me to do just that without going through comprehensive documentation?
12:34:21 <ski> er, yea :)
12:34:36 <ski> (however, it is possibly to define your own infix data constructors .. as long as they start with `:')
12:34:47 <aplainzetakind> (just some examples could do I guess)
12:35:11 <ski> `Bool' also has some special support
12:35:14 <ski> @src Bool
12:35:14 <lambdabot> data Bool = False | True deriving (Eq, Ord)
12:35:26 <Cale> aplainzetakind: Basically every moment of working with template-haskell involves poring at the haddock documentation, even if you're very familiar with it
12:35:27 <ski> that's an ordinary algebraic `data' type definition
12:35:47 <Cale> aplainzetakind: But I might be able to dig up some useful stuff
12:35:48 <adius> > :i (:)
12:35:51 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
12:36:05 <ski> however, `if ... then ... else ...', and also guard syntax (and guards in list comprehensions) are special syntax related to `Bool'
12:36:25 <ski> lambdabot has no `info' command
12:36:31 <ski> % :i :
12:36:32 <yahb> ski: data [] a = ... | a : [a] -- Defined in `GHC.Types'; infixr 5 :
12:37:06 <adius> Oh cool, good to know, thx
12:37:14 <ski> (interesting how that shows `...' ..)
12:37:14 <Cale> I've actually been working on some TH code over the past couple of days
12:37:31 <ski> @info elem
12:37:32 <lambdabot> elem
12:37:38 <Cale> https://github.com/obsidiansystems/aeson-gadt-th/blob/develop/src/Data/Aeson/GADT/TH.hs
12:38:08 <ski> @info [() | False]
12:38:08 <lambdabot> if False then [()] else []
12:38:15 <ski> @info [() | let]
12:38:16 <lambdabot> let { } in [()]
12:38:20 <adius> Also there is no such code in GHC.Types …
12:38:23 <Solonarv> ski: IIRC that's just what :info does
12:38:32 <ski> Solonarv : what is ?
12:38:45 <Solonarv> the '...' part
12:39:09 <Solonarv> as for what @info is doing here: lambdabot matches fuzzily, and there's an @undo plugin
12:39:11 <ski> yea, since yahb just did a GHCi `info' :)
12:39:15 * ski nods
12:39:28 <Cale> My code for generating instances of ToJSON (T a_1 ... a_n) and FromJSON (Some (T a_1 ... a_(n-1)) for GADTs T having an index a_n which can be sufficiently recovered from the constructor.
12:39:32 <ski> (however, i was curious about the `info' command showing `...' there)
12:39:53 <aplainzetakind> Cale: Thanks a lot.
12:39:54 <Cale> The new version from yesterday now supports things like data C t :: * -> * where C_t :: t -> C t t
12:40:17 <adius> ski: Yeah, it's like don't look here … nothing  is happening here 👀
12:40:22 <Solonarv> ski: yeah, it does that when you use it on a data constructor
12:40:24 <Cale> and GADTs where constructors are constrained by type classes
12:40:38 <ski> ah. ok
12:40:42 <Cale> (it'll add corresponding constraints to the instances it generates)
12:40:52 <ski> (i think this is relatively new behaviour)
12:40:57 <Cale> There's a bunch of type unification in there which was annoying to do
12:41:10 <ski> (but now that you mention it, i think i've noticed it. i just forgot)
12:41:35 <ski> Cale : interesting
12:41:45 <adius> Is there a specific reason why `(:)` has fixity 5?
12:41:52 <Cale> My coworker Ali took all the useful general code from there, and added it to th-extras https://github.com/mokus0/th-extras/blob/master/src/Language/Haskell/TH/Extras.hs
12:42:06 <adius> I feel like it should be lower …
12:42:08 <Cale> (but I haven't yet added the dependency)
12:42:56 <adamCS> aplainzetakind: https://www.reddit.com/r/haskell/comments/7lzdc3/template_haskell_tutorial/
12:43:18 <qwebirc41608> Hello, I'm trying to install ghcup on macOS but I get this error: "Following commands are required, but missing, please install:  xz". What is xz?
12:43:34 <dmwit> It's a compression tool, similar to gzip or bzip.
12:44:07 <aplainzetakind> adamCS: Thanks.
12:44:12 <dmwit> I don't know what OSX folks use for package management these days; is it still brew? If so, brew install xz will probably get you where you need to go.
12:45:21 <qwebirc41608> @dmwit Yea thanks, the xz in the terminal was so small, I overlooked it :p.
12:45:21 <lambdabot> Unknown command, try @list
12:45:28 <qwebirc41608> dmwit Yea thanks, the xz in the terminal was so small, I overlooked it :p.
12:45:34 <deadnull> brew or port - depends on if you have an aversion to sudo
12:45:40 <deadnull> ;)
12:48:22 <ski> adius : it's the same as for `++'
12:49:28 <adius> ski: And that's important because? 🤔
12:58:14 <segeljakt> hey all
12:58:37 <segeljakt> I just started learning Haskell, I'm wondering, is there any way to generate a project like in Rust with Cargo?
12:59:02 <segeljakt> project skeleton*
13:00:08 <phadej> `cabal init`
13:00:23 <segeljakt> ok sweet, thanks
13:00:59 <hc> phadej: why cabal and not stack?
13:01:05 <Cale> why not?
13:01:07 <ski> adius : well, often you want to write things like `a : bs ++ c : d : es ++ fs ++ g : hs'
13:01:08 <hc> isn't stack the way to go these days?
13:01:13 <Cale> But yeah, stack also has an init command.
13:01:16 <Cale> They're both good
13:01:29 <hc> Doesn't cabal still have the whole dependency hell problem?
13:01:39 <Cale> Personally, using nix a bunch, I don't have any use for all the extra stuff that stack does
13:01:46 <Cale> no
13:02:06 <shapr> cabal new-install and new-build do not have dependency hell problems anymore
13:02:12 <Cale> But also, even the solving that cabal does is unnecessary to me
13:02:25 <shapr> I prefer cabal new-* commands over stack
13:02:36 <phadej> v2-* commands
13:02:37 <Cale> (since I'm always in an environment with exactly the dependencies I'll need installed)
13:02:41 <adius> ski: I guess that makes sense. thx
13:03:20 <segeljakt> what is preferred hs or lhs?
13:03:41 <Cale> segeljakt: They both have their use. Depends on how much of what you're writing is commentary
13:03:50 <ski> adius : of course, one could imagine both having some other precedence level ..
13:04:10 <aplainzetakind> Don't the v2-* commands basically render stack redundant?
13:04:11 <Cale> lhs makes the code secondary, and is useful to be able to make e.g. HTML pages that are also valid Haskell code.
13:04:21 <Cale> Or TeX source
13:04:30 <segeljakt> Ok, nice
13:04:34 <shapr> hc: stack can lose dependency information that's important if you plan on upgrading your project to use newer libraries.
13:04:58 <ski> segeljakt : bara så du vet så finns det en kanal #haskell.se, också (.. samt #haskell.scandinavian)
13:05:13 <shapr> jo, nästan 
13:05:19 <segeljakt> sweet
13:05:20 <shapr> hc: nope
13:05:41 <segeljakt> tack
13:05:47 <shapr> hc: the dependency hell problem has a bunch of different names, the easy way to fix it is to have each version compiled for the binary you're building
13:06:15 * ski . o O ( nästan skjuter ingen hare. nästan har ingen jaktlicens )
13:06:23 <shapr> aw
13:06:42 <shapr> maybe I can practice my Swedish while I'm in New York City for the next three months
13:06:58 <Cale> shapr: Are you coming to Compose?
13:07:24 <shapr> Cale: I think it's during days I'm obligated to be at recurse center, but wasn't there some unconference parts on the weekend?
13:07:30 <Cale> yeah...
13:07:45 <Cale> Unconference: Sat June 22 - Sun June 23
13:07:52 <shapr> I'll certainly be present for the unconference
13:08:01 <shapr> Cale: I've never met you! will you be there?
13:08:01 <Cale> cool!
13:08:03 <Cale> Yeah
13:08:14 <shapr> I think I've known you ... at least fifteen years on IRC
13:08:26 <FriCho> hello
13:08:33 <FriCho> how you doing
13:08:35 <shapr> ski: kommer du till compose?
13:08:41 <ski> njet
13:08:42 <shapr> hi FriCho, how's code?
13:08:46 <ski> hoi FriCho
13:08:59 <FriCho> leuk nederlanders
13:09:08 <FriCho> ik wil starten
13:09:15 <shapr> wat leuk
13:10:09 <Cale> Maybe I should have signed up to do a talk at Compose (but I didn't). I've got a bunch of stuff to share in the hallway anyway :)
13:10:30 <ski> apparently, there's a channel #haskell.dut for dutch speakers. dunno how populated it is, though
13:12:02 <jgt> aplainzetakind: You asked when is TH justified
13:12:11 <jgt> aplainzetakind: afaik there's no other way to get stuff at build time
13:12:32 <jgt> e.g. I use it to roll the build timestamp and latest commit hash into my compiled binary and ship that to the server
13:13:12 <jgt> I use a tonne of TH for other stuff like Persistent DSL and HTML/JS/CSS templates, but I have less justification for the latter
13:13:49 <jgt> one could *maybe* argue that "oh, our front end developers don't understand that h1 [][] means <h1></h1>"
13:14:01 <jgt> but then I'd argue you don't need people like that anyway
13:14:25 <jgt> a junior's junior can translate between different brackets
13:22:21 <segeljakt> what Vim plugins should I use for Haskell?
13:23:14 <ski> @wiki Vim
13:23:15 <lambdabot> https://wiki.haskell.org/Vim
13:23:38 <ski> (perhaps someone here has more suggestions)
13:25:40 <segeljakt> time to write me a haskell
13:26:43 <jgt> segeljakt: other than syntax highlighting, I don't use any plugins vim/haskell plugins
13:27:15 <jgt> segeljakt: I have syntax support for shakespeare files, but that's not _exactly_ Haskell
13:27:44 <jgt> I have a bindings for sending commands to GHCi through tmux and tpope/vim-dispatch
13:27:59 <jgt> (and I think you don't need vim-dispatch if you use nvim)
13:28:46 <jgt> otherwise I use stylish-haskell, hlint, and tabularize, but the first two aren't vim plugins, and the latter is not Haskell-specific
13:29:24 <jgt> https://github.com/jezen/dotfiles/blob/master/.vimrc
13:30:17 <jgt> I don't get to use the iabbrev yeahdawg sunglasses nearly as much as I'd like
13:32:12 <jgt> probably some plugins and ghcid or whatever would be necessary if I didn't have GHCi and vim in adjacent panes
13:40:08 <phaul> speaking of stylish-haskell, brittany is really good.
13:40:38 <phaul> easy to integrate into vim, just set formatprg=brittany
13:41:25 * [exa] runs to try that
13:43:46 <jgt> I forgot that I can use formatprg. My binding just uses a bang filter
13:43:49 <segeljakt> I use this for formatting https://github.com/sbdchd/neoformat
13:44:09 <segeljakt> it automates the set formatrpg
13:44:34 <segeljakt> im lazy lol
13:44:43 <jgt> so is Haskell!
13:45:12 <jgt> you a Chalmers student?
13:45:20 <segeljakt> KTH
13:45:37 <segeljakt> are you Chalmers?
13:45:44 <jgt> ah; sorry for the loss of (what I'm guessing was) one of your lecturers
13:46:00 <jgt> nope. Never went to uni. Too dumb for that.
13:46:20 <jgt> and I'm trying to stay the hell away from gbg, and Sweden in general
13:46:27 * ski . o O ( "Résumé" by Maria Kovalyova,Roman Cheplyaka in 2010-12-12 at <https://ro-che.info/ccc/11> )
13:46:39 <jgt> and now all the Swedes come to my town in Poland anyway
13:46:46 <ski> jgt : who ?
13:47:11 <jgt> ski: Joe Armstrong, if you were asking which lecturer
13:47:16 * ski nods
13:47:19 <jgt> iirc he was lecturing at KTH
13:47:24 <ski> i didn't know he had passed away
13:47:28 <ski> sad news :/
13:48:28 <jgt> yeah it's a real shame. He had an approach to simplicity and a cool dismissal of tech hype which is sorely missed in this industry
13:48:46 <javran> I'm wondering if there's any tool that undos import aligning, not a fan of excessive whitespaces floating around import list
13:48:54 <jgt> "What's Docker?" — Joe Armstrong
13:49:07 <jgt> javran: vim?
13:49:20 <javran> any command line tool will do
13:49:34 <ski> @remember Joe_Armstrong "What's Docker?"
13:49:35 <lambdabot> Done.
13:49:35 <javran> for the record I'm an emacs user
13:50:02 <jgt> javran: so doesn't emacs have something similar to vim's visual block mode?
13:50:37 <jgt> javran: I mean, you could just visual block, draw the box around those chars, and delete
13:50:43 <jgt> or script it, but… https://xkcd.com/1205/
13:51:35 <jgt> ski: that comic is great!
13:53:12 <dmwit> ?forget Joe_Armstrong "What's Docker?"
13:53:12 <lambdabot> Done.
13:53:18 <dmwit> ?remember Joe_Armstrong What's Docker?
13:53:18 <lambdabot> Okay.
13:54:24 <javran> ah I'm not talking about editors, just wondering if there's a tool that can remove those (say, all occurrence in a project) in one go
13:55:10 <jgt> javran: tbh, this is the kind of thing that you should be able to script your editor to do
13:55:28 <jgt> I don't know if a tool already exists to do exactly that
13:55:58 <jgt> you could write it? It'd be something like find piped to sed
13:57:14 <javran> yeah, I'm just checking if there's some previous work before I go ahead xD
13:57:32 <ski> ty, dmwit
13:57:43 <dmwit> javran: sed 's/ +/ /g'?
13:58:13 <jgt> dmwit: you'd need to filter it to lines matching ^import
13:58:39 <dmwit> Oh, sure. But that's easy in sed: sed '/^import/s/ +/ /g`.
13:58:40 <javran> exactly
13:58:44 <monochrom> Oldies may consider sed an editor :)
13:58:52 <javran> that should be good enough
13:59:07 <geekosaur> you need gnu sed -E or '  *' instead of ' +' or \+ instead of +, but.
13:59:14 <dmwit> vi (and vim) also have builtins for this operation.
13:59:50 <jgt> dmwit: I think most of vim's substitution stuff is straight from sed
14:00:32 <dmwit> Supposedly the name grep is an homage to vi's :g command. :g/re/p
14:00:51 <jgt> global regex print
14:00:58 <jgt> or maybe replace, not regex
14:01:00 <jgt> iirc
14:01:24 <jgt> ah it's the former
14:08:55 <segeljakt> are there any languages that complement Haskell?
14:09:06 <jgt> segeljakt: in what way?\
14:09:07 <geekosaur> in what sense?
14:09:42 <monochrom> PHP?
14:10:00 <jgt> monochrom: is this a joke about Purescript, Haskell, and Postgres?
14:10:10 <segeljakt> I don't know enough about Haskell yet to answer lol
14:10:10 <javran> ghc core with type inference?
14:10:17 <ski> perhaps one could say that learning about logic programming in some sense would complement learning about functional programming
14:10:19 <segeljakt> but similar to Python and C++ maybe
14:10:34 <iqubic> Oh dear lord... What have I walked into?
14:10:49 <jgt> segeljakt: you may benefit from going through the book "Seven Languages in Seven Weeks"
14:11:05 <iqubic> May I just say that GUI in Prolog make literally no sense at all.
14:11:10 <ski> (so, like Prolog, Mercury, Oz, lambdaProlog, Lolli, Gödel, Twelf .. then i suppose there's Escher and Curry)
14:11:23 <ski> iqubic : XPCE ?
14:11:24 <jgt> you will pick up some Prolog, and then see how Erlang took ideas from Prolog, and Haskell took ideas from both
14:11:33 <iqubic> I know like.... A little bit of prolog.
14:11:40 <iqubic> Not enough to be dangerous.
14:11:50 <javran> in some sense knowing prolog helps you understand typeclasses
14:11:52 <jgt> I know one Prolog joke
14:11:58 <jgt> it's pretty dangerous
14:12:02 <iqubic> I know enough haskell to really really really mess up someone's computer.
14:12:19 <iqubic> jgt: I want to know the Prolog joke.
14:12:22 <segeljakt> believe it or not, my academic supervisor designed Oz
14:12:36 <jgt> I know enough Haskell to give a VS supermodel frown lines
14:12:37 <iqubic> segeljakt: I don't believe it.
14:12:44 <segeljakt> a language so good it is not used by anybody
14:13:14 <jgt> iqubic: Q. How many Prolog programmers does it take to screw in a lightbulb?
14:13:19 <jgt> iqubic: A. Yes.
14:13:46 <iqubic> I just laughed so loud my Calculus Professor asked me to leave the room.
14:13:54 <javran> ah that one
14:13:54 <jgt> :D
14:14:18 <jgt> I made Stephen Diehl laugh with that one, which is my only claim to fame
14:14:22 <javran> I thought the joke would somehow involve oleg
14:14:33 <iqubic> What is oleg?
14:14:35 <segeljakt> who is Oleg?
14:14:42 <jgt> I thought Oleg was the LinkedIn guy
14:14:44 <phadej> @quote microoleg
14:14:44 <lambdabot> No quotes match. I don't think I can be your friend on Facebook anymore.
14:14:49 <phadej> @quote oleg
14:14:50 <lambdabot> oleg says: The cited code is elegant, but it is not correct.
14:14:53 <phadej> @quote oleg
14:14:53 <lambdabot> oleg says: The implementation of RSA on type level is left for future work.
14:14:56 <phadej> @quote oleg
14:14:56 <lambdabot> oleg says: The cited code is elegant, but it is not correct.
14:14:58 <phadej> @quote oleg
14:14:58 <lambdabot> oleg says: I submit that a type-checker that accepts ill-typed terms, loops and causes segmentation faults is not correct.
14:15:04 <phadej> @quote oleg
14:15:05 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
14:15:11 <phadej> that one
14:15:15 <iqubic> I see.
14:15:19 <phadej> @quote millioleg
14:15:19 <lambdabot> olsner says: < kmc> i think 250 milliolegs is enough to kill an elephant  < olsner> kmc: ... to kill an elephant - in the type system!
14:15:23 <iqubic> Those are all cool.
14:15:49 <jgt> "The cited code is elegant, but it is not correct."
14:15:50 <Zemyla> Monads in category theory are apparently also called triads. Does this mean that category theorists are also Catholic theologians?
14:15:51 <jgt> this is great
14:15:52 <iqubic> So what should I do with my life right now? What should I code in Haskell?
14:16:22 <segeljakt> believe it or not #2, we submitted a paper and got 3 rejects and 1 accept, the guy who accepted as Oleg and he convinced the rest to accept us
14:16:38 <segeljakt> was*
14:16:48 <jgt> iqubic: do you want a job? :P 
14:16:53 <iqubic> No. Not right now.
14:17:05 <jgt> to be fair, who does
14:17:05 <iqubic> I just want some ideas of what to code in Haskell.
14:17:08 <ski>   1972 - Alain Colmerauer designs the logic language Prolog. His goal is to create a language with the intelligence of a two year old. He proves he has reached his goal by showing a Prolog session that says "No." to every query.
14:17:13 <ski>     -- from "A Brief, Incomplete, and Mostly Wrong History of Programming Languages" by James Iry in 2009-05-07
14:17:15 <oni-on-ion> iqubic, game 
14:17:45 <jgt> ski: my girlfriend — currently doing PHP — quite enjoyed the programmable hyperlinked pasta one
14:18:07 <ski> segeljakt : van Roy ?
14:18:20 <iqubic> I'm at the point where I have a large theoretical knowledge of Haskell, but very little actual practical experience.
14:18:34 <jgt> iqubic: I'm the exact opposite
14:18:43 <jgt> total Haskell charlatan, and running three businesses on it
14:19:03 <iqubic> See, do you know what a comonad is?
14:19:16 <jgt> monads with friends
14:19:28 <iqubic> I know what it is, but that's not going to help me write very many actual programs.
14:19:28 <ski> segeljakt : AliceML is also interesting
14:20:01 <iqubic> jgt: comonads are the catagorical dual of monads. XD.
14:20:27 <ski> @quote OlegFacts
14:20:27 <lambdabot> OlegFacts says: Hindley and Milner use only their surnames out of fear of Oleg.
14:20:43 <jgt> iqubic: [in Chief Wiggum voice] Oh really? That's very interesting! Let me just type that up on my invisible typewriter!
14:20:50 <Solonarv> class Functor w => Comonaw w where
14:20:50 <Solonarv>   extract :: w a -> a
14:20:50 <Solonarv>   duplicate :: w (w a) -> w a
14:21:04 <iqubic> That definition is just about as helpful as saying: "Monads are just monoids in the catagory of functors"
14:21:05 <Solonarv>   extend :: (w a -> b) -> w a -> w b
14:21:15 <jgt> iqubic: endofunctors*
14:21:16 * ski . o O ( `preserve :: Comonad w => (w a -> b) -> (w a -> w b)' )
14:21:18 <iqubic> Like, both are correct, but neither are helpful.
14:21:26 <iqubic> What does preserve do???
14:21:40 <jgt> I don't think that infamous phrase is so unreasonable, but that's just me
14:21:43 <ski> @quote fizzled
14:21:43 <Solonarv> preserve f = fmap f . duplicate
14:21:43 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
14:21:54 <Solonarv> also, s/preserve/extend/
14:22:03 <__monty__> jgt: You run three businesses on haskell? That'd be impressive without any haskell involved!
14:22:18 <f-a> I expect the answer to be "no", but is there a way to tell cabal to produce strip'd executables?
14:22:46 <jgt> __monty__: it's *tiring*. Here I am, 23:22 on a Friday night, hacking away at some Yesod stuff
14:22:47 <f-a> I could write a .sh, but that wouldn't work on Windows
14:23:05 <jgt> but also, I've never been more satisfied in my career
14:23:28 <Solonarv> f-a: actually there is an option for that somewhere, I think
14:23:47 <ski> also `extend' is the wrong name for it. "extend" is the pronounciation for `(=<<)'
14:24:08 <jgt> ski: really? I always said "reverse bind"
14:24:17 <ski> jgt : see early Wadler papers, iirc
14:24:19 <Solonarv> ski: well, it's called 'extend' in the actual Haskell library that provides comonads
14:24:23 <__monty__> jgt: Why three?
14:24:43 <ski> Solonarv : i do know. i've complained about it before to kmett :)
14:25:09 <Solonarv> f-a: there is an '--enable-executable-stripping' flag
14:25:15 <Solonarv> for cabal that is
14:25:40 <ski> @quote proved.it.correct
14:25:40 <lambdabot> knuth says: I have not tested this code, only proved it correct.
14:25:40 --- mode: ChanServ set +o glguy
14:25:41 --- mode: glguy set +q-qo *!*@85.95.114.253 *!*@gateway/web/freenode/ip.85.95.114.253 glguy
14:25:44 <f-a> thanks, Solonarv 
14:26:09 <jgt> __monty__: I started the first thing by myself. I built everything, designed everything, and did all the sales and marketing. It makes me a small amount of money every month. After getting my first few customers, I realised I do not like selling. I do not wake up in the morning excited by the idea of picking up the telephone and talking to business people. So I went looking for other co-founders for other
14:26:11 <jgt> projects, and two different promising projects came my way. I was ambitious, and I also wanted to spread my risk and not put all my eggs in one basket.
14:28:04 <ski> whee !
14:28:11 <Clint> choo choo
14:28:14 <__monty__> jgt: Hmm, I suspect people like you are why none of us can have haskell jobs. Come on, bro. Don't bogart al the funyuns. : )
14:28:27 --- mode: ChanServ set +o glguy
14:28:27 --- mode: glguy set +j 3:5
14:28:32 <iqubic> That's a wonderful reference.
14:28:38 <iqubic> __monty__: I get that reference.
14:28:52 <jgt> __monty__: one of my companies is a funded tech startup, and I had my first employees start this week
14:28:59 <jgt> so I am immensely proud this week
14:29:17 <jgt> and assuming all goes to plan, we will grow and I will hire more Haskellers
14:29:44 <boj> i hire haskellers on occasion, if they are willing to move up here to Alaska :)
14:30:14 <iqubic> So what should I do in Haskell right now?
14:30:20 <jgt> building a distributed team was pretty important to me
14:30:42 <boj> (the reality is that i don't hire haskellers, because no one wants to move here. so i have built new haskellers instead)
14:30:43 <MarcelineVQ> iqubic: anything, the first thing that comes to mind. you don't do the things people suggest anyway, and no one's going to sell you on an idea
14:30:53 <iqubic> Also, did Matrix just crash or something?
14:31:05 <__monty__> boj: Let me guess, they're abominable snow nerds?
14:31:12 <Clint> is matrix running on mobil@50.20.246.172 now
14:31:15 <boj> __monty__: haha, indeed
14:31:46 <iqubic> Seems like it.
14:31:53 <jgt> __monty__: one of my guys is in Siberia, so he may be a bit chilly too
14:32:59 <Solonarv> Clint: not matrix, but looks like some kind of bouncer/service/whatever just disconnected a bunch of people
14:33:41 <javran> I guess that was a netsplit
14:34:09 <iqubic> What is a netsplit?
14:34:34 <segeljakt> I promise, I will take a picture of Oleg when I see him
14:34:43 <iqubic> How do people connect with weird hostnames like ~quaLity? or such?
14:35:56 <boj> iqubic still hasn't discovered google it seems
14:40:06 <f-a> Solonarv: it seems it is less aggressive than `strip`, but that's ok
14:40:10 <gonz_> What a wonderful thing to say
14:40:17 <gonz_> For absolutely zero reason
14:40:24 <Solonarv> huh, I would assume it just calls strip
14:40:28 <Solonarv> glad it works for you!
14:50:18 <segeljakt> how does one disable all these "has quit" "has joined" messages?
14:50:34 <monochrom> Depends on IRC software. Which one do you use?
14:50:36 <Solonarv> segeljakt: depends on your client
14:50:38 <boj> segeljakt: depending on your client, you may have a filter
14:50:42 <Solonarv> most clients have a setting to hide them
14:51:36 <segeljakt> irssi
14:52:20 <segeljakt> ok, I did something, let us see if it works
14:53:36 <__monty__> segeljakt: /ignore * JOINS PARTS QUITS NICKS
14:54:51 <ski> (`/set activity_hide_level JOINS PARTS QUITS NICKS' or somesuch ?)
14:56:42 <segeljakt> thx
14:56:49 <monochrom> There were two joins. Did you see them?
14:57:02 <segeljakt> i did not O.o
14:57:09 <monochrom> Then success!
14:57:25 <__monty__> That doesn't hide them from the channel though, ski. Good way to not be bothered by busy channels you only lurk in though : )
14:57:38 <ski> __monty__ : oic. okay
14:57:43 <segeljakt> ♪┏(・o･)┛♪
14:57:46 <__monty__> segeljakt: Remember to /save your configuration if you want it permanently.
14:58:02 <segeljakt> ok
14:58:39 <glguy> I collapse the joins/parts as seen on the screenshot https://github.com/glguy/irc-core#glirc---advanced-console-irc-client
15:03:47 <zeta> could you guys help me setup my brightness functions in xmonad.hs, i need help?
15:05:45 <f-a> zeta: there is an #xmonad channel too
15:06:24 <f-a> (depending if the problem is haskell or xmonad itself)
15:07:11 <zeta> i'm can't identify because i forgot my password, so i can't use xmonad, if you guys could at least give me some pointers
15:07:57 <geekosaur> where this ended the other day is they need root access to set permissions so the backlight can be changed, and somehow that is an xmonad issue
15:08:09 <glguy> zeta: You can reset your password via email if you forgot it
15:08:13 <f-a> zeta: you can reset your freenode password if you want
15:08:37 <monochrom> Oh, I recall the tinfoilhatness now.
15:11:04 <__monty__> Fwiw, I simply change the permissions for my backlight using udev.
15:12:27 --- mode: glguy set -o glguy
15:12:49 <geekosaur> that was something I mentioned
15:13:48 <zeta> in nixos i made my user become a member of video, now i am trying to figure out: how to give permissions to the `video` group to write the file, i am not sure how to do this with udev rules: https://github.com/giovanifss/xmonad-brightness https://unix.stackexchange.com/questions/111593/allow-non-root-user-to-read-write-dev-files#111595 https://wiki.debian.org/udev
15:14:03 <__monty__> glguy: Shameless plug : ) It's a great solution though 👍
15:14:57 <__monty__> zeta: You should be able to figure it out from here: http://ix.io/1CnF
15:15:09 <__monty__> Just do g+w and chown first?
15:15:44 <geekosaur> a file is a member of exactly one group, so chgrp it. that's one of the things suggested by the readme for the brightness stuff
15:16:11 <geekosaur> well, except it suggested making a new group, but reusing the video group should be fine
15:16:45 <geekosaur> it doesn't suggest that because different distributions do things differently and they can't know which groups your system will already have
15:17:41 <zeta> wait you guys confused me, will that pastebin work or do i have to change it up a bit?
15:17:43 <DigitalKiwi> i just use xfce4 with xmonad to get basic power management and such
15:24:39 <dmwit> zeta: These are no longer Haskell questions. You will need to find a different place to ask further.
15:27:20 <zeta> dmwit: it has to do with getting things to work with xmonad.hs, so it is indirectly related to haskell
15:27:45 <geekosaur> this is not an xmonad problem
15:27:52 <geekosaur> it will happen with any way of controlling the backlight
15:27:55 <monochrom> If anyone needs my merciless service, just let me know!
15:28:52 <__monty__> zeta: You have to alter my example. If that's too hard you should maybe try a more user friendly DE until you're comfortable with this stuff.
15:29:44 <boj> not a bad idea. i actually swapped from xmonad to herbstluftwm awhile back because it is easier to configure
15:31:25 <zeta> look, i just need to ask a few more questions(a couple minutes), then i will stop bothering you guys
15:32:03 <zeta> i am almost done with xmonad.hs, here is my config: https://hastebin.com/uquzuvupeh.rb
15:33:23 <zeta> i just have to finish setting up the permissions for xmonad-brightness then i will be good to go
15:35:37 <boj> a region in Japan has a set phrase, like "i am going to make some fish soup." they never make the soup, it is a sign that the guest has overstayed their welcome and should go home
15:37:13 <[exa]> boj: that's fishy.
15:38:26 <boj> in order to save face, the guest says, "that's ok, i am not hungry. it is time for me to go home anyways."
15:40:54 <monochrom> OK I'm going to make fish lasagna!
15:41:23 <Solonarv> joke's on you, I'm hungry again
15:41:30 <monochrom> haha
15:41:42 <boj> awkward XD
15:41:52 <monochrom> Ah but the subtext is "no one waits for monochrom to finish anything".
15:42:35 <monochrom> Next time it's going to be "I'm going to make an OS in Haskell!"
15:43:19 <zeta> i got confused when you started talking about: `g+w`, 'chown' and `chgrp` in: http://ix.io/1CnF
15:43:21 <monochrom> (It's a sign that the host is out of their minds and so the guest should go home)
15:43:44 <Solonarv> monochrom: nice one
15:43:46 <boj> awkward
15:43:54 <zeta> could you clarify this please, i am confused
15:44:26 <boj> zeta: try the #linux channel
15:45:24 <zeta> ok, i'll go to a different channel, thanks for the help guys
15:45:38 <boj> good luck!
15:46:38 <Phyx-> 23:40:32 < monochrom> OK I'm going to make fish lasagna! <-- is that a thing?
15:46:46 <monochrom> No!
15:46:53 <Solonarv> yes, I've had salmon lasagna before - quite good
15:46:57 <monochrom> Oh!
15:47:36 <Phyx-> Hrm...
15:47:53 <geekosaur> this should not surprise you
15:48:32 <MarcelineVQ> salmon pastas are good, salmon lasagna sounds all kind sof wrong, how are you even going to taste it with all the sauce and cheese
15:49:05 <Solonarv> go easy on the sauce & cheese, of course
15:49:08 <MarcelineVQ> You've gone mad with power, all of you.
15:49:13 <Solonarv> but I don't know, it was a while ago
15:49:25 <zeta> yummy
15:49:50 <geekosaur> or use a different sauce and cheese; it's not ike the're any more fixed than the meat is
15:50:09 <Solonarv> yes, that
15:50:20 <Phyx-> don't you just end up with pasta then?
15:50:36 <geekosaur> as a defining factor, yes.
15:50:45 <Solonarv> you still use those sheet noodles
15:50:57 <geekosaur> but that's more or less the defining factor anyway, you vary the rest
15:51:47 <Phyx-> lol
16:00:38 <Amras> what's a good name for a newtype Complex Double representing the output of ex. a Fourier Transform?
16:01:52 <Amras> FrequencyResponse seems too clunky for a type name
16:03:02 <MarcelineVQ> Better than FR and having to commend the top of all your things using it that FR means FrequencyResponse :O
16:03:32 <Amras> oh god yeah
16:03:45 <Amras> I already have TFR for TimeFrequencyResponse, I don't need two acronyms in one project
16:03:50 <Amras> er
16:03:54 <Amras> TimeFrequencyRepresentation*
16:04:20 <Amras> maybe "Response"?
16:04:39 <geekosaur> orat least cut Frequency down to Freq
16:14:26 <dmwit> Is the Fourier transform self-inverse?
16:15:01 <dmwit> Anyway I think I've heard these called "phasors".
16:15:06 <dmwit> Which is a totally dope name.
16:16:25 <aplainzetakind> How can I change color of text in the terminal? Writing \033[ stuff doesn't seem to work.
16:17:46 <jle`> aplainzetakind: check out ansi-terminal
16:21:26 <DigitalKiwi> MarcelineVQ: use more salmon duh
16:22:18 <geekosaur> also if you're doing that writing in Haskell, it'd be \27 not \033
16:22:49 <Amras> I think "Response" sounds better than "FreqResponse" especially since I already have "Frequency" and "TFR" floating around
16:22:52 <mniip> dmwit, not exactly self inverse
16:22:54 <mniip> but it's close
16:23:02 <Amras> and yeah, what mniip said
16:23:11 <Amras> I'm not actually doing fouriers, I'm doing wavelet transforms
16:23:22 <Amras> but the type is the same for both
16:23:25 <mniip> DTFT as a linear operator matrix satisfies the property W W* = nI
16:23:32 <Amras> and I didn't think I'd get an answer if I asked about wavelets
16:23:34 <mniip> where W* is complex conjugate (W is symmetric)
16:23:43 <mniip> and n is the size
16:28:43 <Gabrielle_99> Hey)) Wanna have fun with a horny girl? Check -->> https://t2m.io/i8vbfAhK
16:29:18 <MarcelineVQ> Wait, come back, I've devloped a powerful horn removal cream
16:31:21 <hpc> linear babes on a manifold near you
16:32:01 <infinisil> I remember there being some function of the form `captureStdout :: IO () -> IO String` which runs the action while capturing stdout, returning it as a result
16:32:11 <infinisil> Anybody happen to know about this?
16:33:13 <MarcelineVQ> who's stdout?
16:33:23 <Amras> https://hackage.haskell.org/package/silently-1.2.5/docs/System-IO-Silently.html#v:capture_
16:33:31 <Amras> infinisil ^
16:33:54 <Amras> (also, https://hoogle.haskell.org/?hoogle=IO%20()%20-%3E%20IO%20String )
16:34:07 <infinisil> Ohh right, hoogle
16:34:09 <infinisil> Thanks Amras 
16:34:54 <Amras> followup to my earlier question btw: Complex Double has Applicative on Double, so I can do pure 5 to get a 5:+0 right
16:35:39 <Amras> if I have my newtype Response = Response Complex Double, is there any way I can have pure 5 give me a Response 5:+0 ?
16:35:40 <Solonarv> Amras: that would get you 5 :+ 5
16:35:55 <Solonarv> it can't be 5 :+ 0, that is forbidden by the types
16:36:00 <Amras> oh shit
16:36:14 <Amras> I have code to fix
16:36:23 <Solonarv> but there is a Num instance so you can just write '5' (assuming you meant the literal 5)
16:36:30 <Solonarv> % pure 5 :: Complex Double
16:36:31 <yahb> Solonarv: 5.0 :+ 5.0
16:36:57 <Solonarv> consider: pure 'c' is legal, but that couldn't possibly give you 'c' :+ 0
16:37:03 <Solonarv> (since that's ill-typed)
16:40:13 <Solonarv> if you want x :+ 0, you can just write x :+ 0 ;)
16:40:21 <Amras> yeah, I'll just do that
16:47:51 * ski reduces hereditary Harrop-Rasiowa formulae to Horn clauses
17:40:44 <dmwit> I'm actually a little bit surprised Complex has an Applicative instance. Not sad, just surprised.
17:42:22 <Solonarv> I suppose it makes sense to provide instances that are lawful and unique
17:42:53 <Solonarv> (I'm pretty sure the instance is unique, but I haven't proven that)
17:42:58 <dmwit> > (realToFrac :: Double -> Complex Double) 5
17:43:00 <lambdabot>  5.0 :+ 0.0
17:43:17 <dmwit> (In case we are avoiding the Num suggestion because you don't have a literal.)
17:43:29 <nshepperd> :t join :: Complex (Complex Double) -> Complex Double
17:43:31 <lambdabot> Complex (Complex Double) -> Complex Double
17:43:46 <nshepperd> it has a monad instance too! :D
17:43:46 <dmwit> nshepperd: Complex a ~= Bool -> a
17:43:59 <dmwit> (And the isomorphism is a monad isomorphism.)
17:44:14 <nshepperd> yup, it's basically V2 with the diagonal monad
17:44:27 <nshepperd> how delightful
17:44:55 <Solonarv> diagonal monad means join ((x :+ _) :+ (_ :+ y)) = x :+ y, right?
17:45:08 <dmwit> should mean that, yeah
17:45:21 <dmwit> > join ((a :+ b) :+ (c :+ d))
17:45:23 <lambdabot>  a :+ d
17:45:31 <Solonarv> that's what you get if you just define it in terms of the iso to Bool -> a
17:45:40 * dmwit nods
17:49:33 <infinisil> Oh whaaat
17:49:44 <infinisil> Why does :+ have the real part on the left side
17:50:19 <infinisil> The ":" almost looks like an "i", then `1 :+ 2` would be like `1i + 2`
17:50:24 <infinisil> Damnit
17:54:21 <Solonarv> it's an infix constructor, it has to start with a :
17:54:33 <Solonarv> additionally it's convention to write the real part first
17:54:59 <nshepperd> if you want, you could define i = 0 :+ 1 and write 1 + 2*i
17:55:09 <Solonarv> yep
17:55:43 <Solonarv> or maybe there could be a ComplexLiterals extension that allows writing 2i to mean 0 :+ 2
17:55:53 <Solonarv> (or a GHC plugin)
17:56:38 <hpc> or MultiplicationLiterals
17:56:48 <hpc> 2<anything> = 2 * <anything>
17:57:02 <hpc> (except for stuff like 0x12345)
17:57:12 <hpc> that'd be neat
17:57:25 <infinisil> Hmm.. that would be neat indeed..
17:57:46 <Cale> Kinda... but from another perspective, there's already enough weird edge cases in the parser...
17:58:05 <Cale> People are already mad about the fact that (-x) is not a section, for example
17:59:03 <infinisil> If only math wouldn't have the same sign for subtraction as for negation
17:59:15 * Solonarv shakes fist
17:59:30 <Solonarv> those dang mathematicians and their ambiguous notation!
17:59:41 <Solonarv> physicist are even worse though
17:59:54 <Solonarv> I should know, I'm one of them!
18:02:57 <nshepperd> @let instance (a ~ b, Num a) => Num (a -> b) where { fromInteger x = (*) (fromInteger x) }
18:02:58 <lambdabot>  .L.hs:168:10: warning: [-Wmissing-methods]
18:02:58 <lambdabot>      • No explicit implementation for
18:02:58 <lambdabot>          ‘+’, ‘*’, ‘abs’, ‘signum’, and (either ‘negate’ or ‘-’)
18:03:07 <nshepperd> @let i = 0 :+ 1
18:03:08 <lambdabot>  Defined.
18:03:12 <nshepperd> > 1 + 3i
18:03:14 <lambdabot>  error:
18:03:15 <lambdabot>      Ambiguous occurrence ‘i’
18:03:15 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.i’,
18:03:19 <nshepperd> bah
18:04:02 <nshepperd> > 1 + 3ii
18:04:04 <lambdabot>  error:
18:04:04 <lambdabot>      • Could not deduce (Num a0)
18:04:04 <lambdabot>        from the context: (Num (Complex a1 -> a), Num a1, Num a)
18:08:04 <nshepperd> ah, lambdabot doesn't like instances with warnings
18:08:07 <nshepperd> > 1 + 3ii
18:08:09 <lambdabot>  1.0 :+ 3.0
18:08:27 <FriCho> how exactly do I save channels?
18:08:39 <FriCho> so when i login again #haskell will stay in my channel list without me joining the channel again
18:08:49 <geekosaur> that will depend on the client
18:09:00 <FriCho> on freenode
18:09:21 <geekosaur> the client, not the server
18:09:41 <geekosaur> unless you mean you're using the web client (it doesn't look like it) which can't do that
18:09:59 <FriCho> hexchat
18:10:23 * Solonarv digs through memories
18:10:25 <MarcelineVQ> right click on the channel on theleft and select autojoin, or unselect it if you like
18:10:55 <geekosaur> you can also enter a list of autojoin channels from the server list, edit the server and there's a field for channels to join
18:11:05 <MarcelineVQ> Or are you asking something else, I feel like I read that wrong now
18:11:15 <geekosaur> actually they call it network list, sorry
18:11:18 <MarcelineVQ> Are you wanting a favorite channels list?
18:11:54 <FriCho> yes
18:12:30 <MarcelineVQ> idk if there is one built in, there could be a plugin for it, not sure
19:10:27 <fragamus> I need to ask an off topic question
19:11:19 <fragamus> Is XMLVM still active as a project
19:25:32 <infinisil> A VM for XML? I have no idea what that even means, but sign me up!
19:25:59 <oni-on-ion> VRML? =)
19:46:39 <fragamus> It’s a cross compiling thing that uses xml as a format to store byte code stuff
19:47:21 <fragamus> It looks like the project stopped 5 years ago but maybe it just moved
20:53:44 <dede> hello
20:58:40 <fresheyeball> someone showed me how to get template haskell in the repl from a quasi quote
20:58:55 <fresheyeball> where I can put in a quasi quote and get the template haskell Exp!
20:58:58 <fresheyeball> ExpQ
20:59:32 <fresheyeball> anyone know how to do that?
20:59:35 <fresheyeball> q?
21:01:08 <c_wraith> I think you want runQ
21:02:11 <c_wraith> runQ :: Quasi m => Q a -> m a, and IO is an instance of Quasi 
21:02:55 <fresheyeball> c_wraith:that looks right!
21:03:05 <fresheyeball> what about the `[q|` <- where is that q?
21:03:48 <Cale> Is there something named q in scope?
21:03:56 <Cale> Try :info q
21:04:14 <c_wraith> I thin it's a quasiquote, which is a record
21:04:14 <fresheyeball> Cale: no, I need to make the `Q a` for `runQ`
21:04:41 <Cale> fresheyeball: Try something like  runQ [e| 1 + 1 |]
21:05:14 <fresheyeball> where is `e` coming from?
21:05:20 <Cale> runQ [d| data Tree a = Tip | Branch a (Tree a) (Tree a) |]
21:05:23 <Cale> It's built in
21:05:39 <Cale> There are a few special ones like that, for expressions, declarations and patterns at least
21:05:42 <slack1256> it kind of tells what is inside the brackets
21:05:53 <fresheyeball>     • Not in scope: ‘d’
21:05:54 <fresheyeball>     • In the quasi-quotation: [d| 1 + 1 |]
21:06:17 <Cale> (oh, and types)
21:06:29 <Cale> :set -XTemplateHaskell
21:06:40 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#template-haskell -- you can see the syntax here
21:07:34 <fresheyeball> there we go
21:07:47 <fresheyeball> Cale: you got it, I forgot to set the pragma
21:07:49 <c_wraith> also, if you want to run a QuasiQuoter with runQ, check out the definition:  https://hackage.haskell.org/package/template-haskell-2.14.0.0/docs/Language-Haskell-TH-Quote.html#t:QuasiQuoter
21:07:57 <fresheyeball> just a very confusing error message
21:08:00 <fresheyeball> I am good to go now
21:32:42 <slack1256> Erik meijer worked at reactive extensions for .NET when he was at microsoft, but I didn't seem to have pushed for rx on the haskell-land, does anyone know why?
21:36:59 <Cale> slack1256: What would that mean?
21:37:42 <Cale> slack1256: As far as I'm aware, Erik Meijer hasn't really had anything to do with Haskell in a long time
21:38:26 <Cale> Are you asking why he's not promoting functional reactive programming in Haskell in general?
21:39:03 <Cale> Or ReactiveX particularly? I don't think ReactiveX is a thing in Haskell at all -- it's tied to .NET
21:39:42 <Cale> Oh, apparently despite its name ReactiveX also isn't functional reactive programming
21:42:09 <slack1256> Cale: yeah, I know he left arround the Foldable/Traversable proposal.
21:43:01 <slack1256> The thing is ReactiveX has multiple implementations (rxswift I've been using at work) so when I was hired they told me "So you know Functional reactive programming" and I said yes because I knew reflex
21:43:08 <Cale> Oh, I see, it's just the observer pattern made to look a bit more like FRP events, except without the deterministic simultaneity that grants you...
21:43:27 <Cale> so basically nothing like FRP at all :P
21:43:33 <slack1256> Exactly
21:43:49 <slack1256> So there is a divergence of terms, and was started by a name known in the haskell world
21:44:05 <fresheyeball> Rx is not horrible
21:44:06 <slack1256> So I got interested why he didn't push for his definition on haskell
21:44:55 <Cale> Maybe he knew he wouldn't get away with it :P
21:46:44 <slack1256> Maybe
21:47:26 <fresheyeball> is there a way I can do like `jsg "foo" ^. js1 "bar" 3`
21:47:37 <fresheyeball> in JSaddle without lens?
21:52:03 <Cale> slack1256: One of the biggest problems with the observer pattern is that your event handlers happen in an essentially unpredictable order that nonetheless matters because you can have spooky non-local effects, and I don't think ReactiveX is aiming to solve that at all, while FRP does.
21:52:39 <slack1256> Cale: That is exactly my problem on my current work
21:52:57 <slack1256> The interaction between the different Observables is weird but important
21:53:08 <Cale> yeah
21:53:09 <fresheyeball> Cale: ReactiveX actually is pure FRP, IF the .run method is called at most once in the entire application
21:53:18 <fresheyeball> but that will never happen
21:53:37 <Cale> fresheyeball: uhh, I'm not even sure about that much, but I've only just learned about it
21:54:20 <slack1256> on rx, you subscribe to an observable passing a lambda which is capable of modifiying your self-object
21:54:58 <fresheyeball> Yeah, rx does not encourage much less demand good usage patterns
21:55:06 <slack1256> On work a main component has like 3 Observable with that setup, each "silencing" the other on specific conditions (it sets them to nil and dispose them)
21:55:14 <Cale> Yeah, it doesn't look at all to me like it does anything to try to prevent you from observing the order in which morally simultaneous events are processed
21:55:15 <fresheyeball> but I am still convinced its also possible to use it in a pure FRP way
21:55:52 <fresheyeball> slack1256: I weep for you
21:56:12 <slack1256> fresheyeball: do not :-), laugh for me
21:56:15 <fresheyeball> The only time I saw Rx used in a solid FP way was in Scala
21:56:19 <slack1256> I laugh at work every day
21:57:02 <slack1256> fresheyeball: was it because the scala culture is different?
21:57:19 <fresheyeball> slack1256: I can be even more general
21:57:58 <fresheyeball> If you want to see decent FP style code outside of a pure FP language. It will only be written by people who are productive in Haskell.
21:58:14 <fresheyeball> Luckily there is a smattering in Scala of such people
21:58:40 <slack1256> I should find my next job on scala then
21:58:46 <slack1256> nice tip fresheyeball
21:58:50 <fresheyeball> slack1256: why not find a haskell job?
21:59:01 <slack1256> I tried, but I am based on Chile
21:59:14 <fresheyeball> slack1256: try for remote
21:59:19 <fresheyeball> apply to Formation
21:59:23 <Cale> slack1256: Do you have a github?
21:59:32 <Cale> (or other code to look at)
22:00:04 <slack1256> Cale: yeah, but I haven't done much https://github.com/RubenAstudillo
22:00:16 <slack1256> fresheyeball: What is Formation?
22:01:03 <slack1256> I signed for job offers that appeared on r/haskell , they told me they hired a PhD on functional programming so no luck
22:01:09 <fresheyeball> slack1256: I used to work there untile recently 
22:01:20 <fresheyeball> its a remote haskell shop with HQ in SF
22:02:02 <slack1256> Interesting
22:02:08 <Cale> slack1256: I can't promise anything, but if you're familiar with reflex, you should at least try applying at Obsidian :)
22:03:04 <slack1256> Maybe I should have done so before starting here.
22:03:08 <Cale> We have been hiring some people lately, I'm not sure if we're done with that for the moment or not
22:04:49 <slack1256> Thanks for the tips guys, I will have them on mind if this work doesn't pan out
22:05:11 <slack1256> The thing is they want to start new projects and I will have a voice on them
22:05:20 <slack1256> so I can push for FP solutions
22:07:48 <slack1256> I will go to sleep now, see ya 
23:46:51 <Taneb> Best thing about writing Haskell is edwardk did most of the work for me years ago
