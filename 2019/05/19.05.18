01:16:01 <zincy_> Is the TypeApplications extensions just sugar over explicit type annotations for values?
01:18:15 <Heffalump> zincy_: I doubt it, because there are cases where there is no variable to annotate, particularly when combined with AllowAmbiguousTypes
01:27:16 <slack1256> zincy_: I think it just exposes the Type Applications already present on Core at haskell level
01:27:23 <trcc> I remember reading a book where it contained a quote stating that science contributes to reach a higher level of knowledge and is not necessarily correct (phrased in much better way). Does anyone happen to know *who* this is attributed to? Wild shot, I know
01:27:59 <zincy_> Ah I see
01:43:30 <ski> <ski> zincy : it may seem like there's a contradiction between "In Haskell, types only exist at compile-time, for help with type-checking. They are completely erased at runtime." and "it can already be that `a' is determined only at run-time, even with Haskell98 code.", but there is no such
01:43:35 <ski> zincy_ ^
01:45:41 <zincy_> ski: Is it not a contradiction because a is a type variable which is declared at compile time and then Core gets to determine the actual type `a` takes on at runtime?
01:46:11 <zincy_> Is a type variable a type?
01:46:48 <aveltras> is there a simple way with aeson to get that function "Maybe Value -> (Int, Maybe Value)" or do i have to make a custom parsing thing ?
01:47:27 <ski> a type variable stands for a type, yes
01:49:06 <aveltras> in fact, more like "Value -> (Int, Value)", the Int being a decoded part of the first Value
01:49:20 <ski> zincy_ : let's say that types were not erased by the type we reached run-time. so e.g. when calling `reverse :: forall a. [a] -> [a]', we'd pass a description of the type `a' (e.g. its size, or memory layout. this can be useful for GC, e.g., or for allowing cons cells (containing elements of type `a') to be sized differently, depending on the type `a')
01:51:07 <ski> (i think, in GHC, the actual (low-level) values stored in a cons cell all have the same size, regardless of the type `a', because they're either pointers to "the real value", or they're tagged integers (or the like, say constant data constructors))
01:51:53 <ski> zincy_ : now, there's something called "polymorphic recursion", that is when you have a polymorphic, recursive function, whose recursive calls are not made to the same polymorphic instance of the function
01:52:38 <zincy_> What does " polymorphic instance of the function" mean?
01:52:54 <zincy_> Haven't heard of "instances" of functions
01:53:36 <ski> `reverse :: [Integer] -> [Integer]' is one instance of `reverse', using `Integer' to instantiate the universally quantified tyvar `a'. if we want to be explicit, we can say `reverse @Integer :: [Integer] -> [Integer]', using `TypeApplications' extension
01:53:55 <ski> not "instance of function", but "instance of polymorphic value"
01:54:11 <ski> or, perhaps "specialization" is a better word than "instance"
01:54:28 <ski> anyway, with `reverse @Bool', we instead get type `[Bool] -> [Bool]'
01:54:30 <ski> okay ?
01:54:35 <zincy_> makes sense :)
01:55:02 <ski> consider `reverse'. if we pass in a list of type `[a]', then the tail will also have type `[a]', and so we're using the *same* polymorphic specialization (on the same type parameter `a'), when we're calling recursively
01:55:11 <zincy_> So it would be recursion whereby different types are applied to the `a`
01:55:14 <ski> so, we might write the definition as
01:55:19 <ski>   reverse :: forall a. [a] -> [a]
01:55:58 <ski>   reverse @a [    ] = [                ]
01:56:23 <ski>   revese @a (x:xs) = reverse @a xs++[x]
01:56:30 <ski> (er, typo)
01:56:46 <ski> anyway, point is that we're just passing around the same type parameter, in the recursion
01:56:53 <zincy_> Yep
01:57:03 <ski> and so, just like if it was an ordinary type parameter, we can instead define a local function
01:57:11 <ski>   reverse @a = reverse_a
01:57:14 <ski>     where
01:57:37 <ski>     reverse_a [    ] = [                 ]
01:57:48 <ski>     reverse_a (x:xs) = reverse_a xs ++ [x]
01:58:14 <ski> so, once we've picked a particular `a', we actually have a *monomorphic* function, which is recursive !
01:58:31 <zincy_> So do you need type applications to write functions which exhibit polymorphic recursion?
01:58:34 <ski> so, this would be "monomorphic recursion", as opposed to "polymorphic recursion"
01:58:53 <zincy_> Ah so that is what monomorphic means
01:59:13 <ski> btw, you should note that using `@a' syntax in patterns like above isn't actually supported by `TypeApplications'. i just wrote it like this to explain what i meant
01:59:33 <ski> no, monomorphic means that the type of the value doesn't start with `forall'
01:59:44 <ski> iow, monomorphic means "non-polymorphic"
01:59:55 <ski> (polymorphic means that the type of the value starts with `forall')
02:00:18 <zincy_> I still don't know what forall means?
02:00:18 <ski> but, what i just described is "monomorphic recursion", not "monomorphic"
02:00:35 <ski> okay. i was assuming you had seen that piece of syntax
02:00:48 <ski> so, let's take a little detour to explain `forall', okay ?
02:01:13 * ski looks at zincy_
02:01:20 <zincy_> Have seen it and from my understanding it means that the behaviour is the same no matter what type is applied to the variable
02:01:24 <zincy_> yeah lets do it
02:01:49 <zincy_> It is always implicit for any type variable
02:02:07 <ski> well, it has to do with what you're saying, yes. but first and foremost, it's something more simply described
02:02:18 <ski> consider
02:02:37 <ski>   reverseBoolList :: [Bool] -> [Bool]
02:03:03 <ski>   reverseBoolList [    ] = [                       ]
02:03:17 <ski>   reverseBoolList (b:bs) = reverseBoolList bs ++ [b]
02:03:19 <ski> and
02:03:34 <ski>   reverseIntegerList :: [Integer] -> [Integer]
02:03:42 <ski>   reverseIntegerList [    ] = [                          ]
02:04:02 <ski>   reverseIntegerList (n:ns) = reverseIntegerList ns ++ [n]
02:04:07 <ski> and so on
02:04:23 <zincy_> yep
02:04:31 <ski> it's annoying to have to write the same code over and over, when we don't actually care what the element type is
02:04:45 <ski> and so, we instead introduce type variables
02:04:59 <ski>     reverse :: [a] -> [a]
02:05:13 <ski>   reverse [    ] = [               ]
02:05:26 <ski>   reverse (b:bs) = reverse xs ++ [x]
02:05:58 <ski> each specific call to `reverse' will figure out some actual type to use in place of `a'
02:06:34 <ski> e.g. in `(reverse [False,True],reverse [0,1,2] :: [Integer])', in the first call to `reverse' `a' is `Bool', but in the second `a' is `Integer'
02:06:49 <ski> of course, you know this, i'm just reminding you of it, and point it out, for context
02:07:42 <zincy_> :)
02:07:56 <ski> so, the type "template" `[a] -> [a]' here in the signature is called a "type schema", because it encompasses many types, in this case infinitely many ones
02:08:07 <ski> it's not a single specific type
02:08:13 <ski>   reverse :: [a] -> [a]
02:08:24 <ski> means that we can *use* `reverse' as if it had the signature
02:08:29 <ski>   reverse :: [Bool] -> [Bool]
02:08:34 <ski> but also as if it was
02:08:41 <ski>   reverse :: [Integer] -> [Integer]
02:09:17 <ski> as long as we consistently replace the tyvar `a' with the *same* specific type, for a single use of `reverse'. we can't have one use of `reverse' have the signature
02:09:20 <ski>   reverse :: [Integer] -> [Bool]
02:09:40 <zincy_> Are "template" and "type schema" from type theory?
02:09:56 <zincy_> Or just terms we made up
02:09:58 <ski> (a different tyvar can be substituted with (/ specialied to) with a different specific type, or the same type, if you want to)
02:10:20 <ski> "type schema" is a common term in type system terminology. "template" was just an informal term
02:10:26 <zincy_> ok
02:10:54 <zincy_> When does the substitution happen? Not when Core is outputted, later I guess?
02:11:39 <ski> conceptually, we make a substitution of some specific type for `a', in the type of a *usage* (like a call to, if it's a function) of the polymorphic value in question
02:11:54 <dminuoso> map = fmap @[]
02:12:01 <ski> for each usage, we can make a different substitution
02:12:20 <ski> (i'm not talking about implementations right now, i'm talking about the "conceptual landscape")
02:12:21 <dminuoso> Here @ denotes "type applying" to the type []
02:12:48 <ski> anyway
02:13:07 <ski> what do we really mean with `reverse :: [a] -> [a]' ?
02:13:34 <ski> informally, we mean that, for each type `a', `reverse' *can* be used as having type `[a] -> [a]'
02:14:02 <zincy_> So [a] -> [a] is just a type?
02:14:04 <ski> e.g. if we pick the type `Bool', then we're saying that `reverse' *can* be used as if it had type `[Bool] -> [Bool]'
02:14:10 <ski> no, wait
02:14:22 <ski> we could state this a little bit more formally, as
02:14:25 <ski>   forall a.
02:14:33 <ski>     reverse :: [a] -> [a]
02:15:02 <ski> this is just some kind of logic notation saying (explicitly) that this type signature is to hold for every type `a' (or at least every concrete type)
02:15:23 <zincy_> Yay this is so simple :D
02:15:45 <ski> (`Maybe' is not a concrete type, it's missing a type parameter. we can't say `reverse :: [Maybe] -> [Maybe]'. we're only allowed to replace `a' here by concrete types)
02:16:40 <zincy_> Great explanation, all crystal clear.
02:16:42 <ski> (however, in e.g. `fmap :: Functor f => (a -> b) -> f a -> f b', `a' and `b' must be replaced by concrete types, but `f' must not, it must be replaced by a type like `Maybe', that expects one (concrete) type parameter, before "delivering" back a (concrete) type)
02:17:35 <zincy_> `f` has kind (* -> *)
02:17:58 <zincy_> So you cant have a forall f there?
02:17:58 <ski> (instead of saying that a type is "concrete", we can say it has kind `*'. so `Bool :: *'. otoh `Maybe :: * -> *', indicating that `Maybe' wants a concrete type as input, and will then give us back a concrete type. so `Maybe Bool' is a concrete type, since `Bool' is concrete)
02:19:46 <ski> (kinds are "types of types". values belong to / inhabit types. analogously, types belong to / inhabit kinds. the types that are inhabitable by values are the concrete types. you can't have `x :: Maybe', that's nonsense, since `Maybe' is not concrete)
02:21:48 <ski> (`Maybe' is a type function, a function that given a type of kind `*', will deliver back a type of kind `*'. one can think of it as an "incomplete type", it needs to be completed, with some type parameter(s), in order to reach a concrete type. if we give the type function `Maybe' the input type `Bool', then the output type will be .. `Maybe Bool', so nothing really exciting happens with such type functions)
02:23:24 <ski> (you may compare this to how if you pass the input `False' to `Just', then the output is .. `Just False'. `Just' is a data constructor, and those (in case they take parameters) just "stores the parameters for later retrieval". similarly, you can think of `Maybe Bool' as "storing `Bool' inside")
02:24:11 <ski> (more exciting would be a type function, say `F', so that if you pass it `Integer', it will give `Bool', and if you pass it `Bool', it will give, say `Maybe Integer'. one can define such type functions with the `TypeFamilies' extension)
02:24:42 <ski> (however, the type functions that you defined when you make a parameterized `data' or `newtype' declaration are all just "type constructors", that aren't "exciting" in this sense)
02:25:23 <ski> so, okay, that was an aside, which you don't necessarily have to understand completely. i just thought you might like to hear a little more about "concrete" and "kinds"
02:25:40 <zincy_> Actually it all makes sense!
02:25:51 <ski> anyway, continuing
02:26:25 <ski> we had reached the conceptual stage of having
02:26:27 <ski>   forall a.
02:26:33 <ski>     reverse :: [a] -> [a]
02:26:51 <ski> so, we have two kinds of things here : monomorphic values, and polymorphic values
02:26:57 <qwebirc53346> so uh idk the etiquette here but can someone help me get this fuckin program working
02:27:05 <ski> "polymorphic" means "many forms"
02:27:15 <ski> and "monomorphic" means "one form"
02:27:26 <qwebirc53346> bc not to put too fine a point on it but i am about to have fifteen simultaneous aneurysms
02:27:33 <ski> so `not :: Bool -> Bool' is monomorphic, it has a single type
02:28:13 <ski> but `reverse :: [a] -> [a]' is polymorphic, it has many different types, it has type `[a] -> [a]' for each possible choice of the tyvar `a' (which here must have kind `*')
02:28:48 <zincy_> When you say poly- and mono- morphic are you referring to the type of the function itself
02:29:36 <qwebirc53346> like is it ok if i post my problem
02:31:47 <ski> (btw, i should perhaps also say that there are "unboxed types", like `Int#', which have kind `*'. you can't have `[Int#]' e.g. since `[]' doesn't take a type of kind '#' as input, it wants one of kind `*'. however `x :: Int#' is still allowed, it's possible to have values belonging to / inhabiting types of kind `#'. therefore such types are also called "concrete", despite not having kind `*'. so concrete types have kind `*' or `#')
02:31:53 <ski> (remember that the type `[T]' is syntax sugar for `[] T', `[]' here can be read as "list of". just like you can't have `x :: Maybe', you can't have `x :: []', that's like saying "`x' is a list of". a list of *what* ?)
02:32:12 <ski> zincy_ : no, i'm referring to the thing, the value. the type is *not* polymophic
02:32:48 <zincy_> gotcha
02:32:51 <ski> it's the value `reverse' which can assume many forms, so that we can use it in situations with lists of elements of different types
02:33:32 <ski> the value `reverse' have infinitely many types, `[Bool] -> [Bool]', `[Integer] -> [Integer]', &c.
02:34:13 <ski> however, all of these follow the basic schema/template `[a] -> [a]' (and all specializations/instances/substitutions of that schema/template is a valid type for `reverse')
02:34:43 <ski> so, in short, we say that `reverse' has type `[a] -> [a]', when we really should say that it has type *schema* `[a] -> [a]'
02:34:53 <qwebirc53346> ok so my ghc keeps installing to the .ghcup folder
02:34:57 <ski> (so, strictly speaking, `[a] -> [a]' is not a type, but a type schema)
02:35:15 <qwebirc53346> how do i stop it from doing that so that some other programs im using (atom, tidalcycles) will recognise that i actually do have haskell
02:35:25 <qwebirc53346> sorry for this extremely basic question!!!
02:36:26 <zincy_> a new word for my vocabulary
02:36:30 <ski> which ?
02:36:34 <ski> "type schema" ?
02:36:35 <zincy_> type schema
02:37:01 <ski> btw, this word "schema" is also used in a similar way in axioms and inference rules in logic
02:37:21 <ski> zincy_ : ok, so the last few things i said here applies to basic systems with polymorphism. every value is either monomorphic (has one type), or is polymorphic (has one type schema, which (normally) specializes to / specifies infinitely many types)
02:37:43 <qwebirc53346> the ghcup github page says it's a "painless installation" but what the author has neglected to mention is that i am in quite a lot of pain both physical, mental, and spiritual
02:38:03 <ski> or, perhaps one should say that the polymorphic ones are "pseudo-values", or something. that they don't become actual values until we specialize the type schema to a specific type
02:38:06 <zincy_> that is enlightening, I used to think of types as polymorphic when I really meant values.
02:38:48 <qwebirc53346> sorry to keep clogging up yr interesting discussion. it is a very interesting discussion and im enjoying reading it thank u
02:39:46 <ski> zincy_ : yes, that's a common terminological confusion. people even talk about "polymorphic types" in papers, in that way, which i consider bad. i consider it bad because it generalizes badly. so you should bear in mind that when i say that values, not types, can be polymorphic, that's (unfortunately) not standard terminology even for researchers :/
02:40:13 <zincy_> oh wow
02:40:20 <zincy_> I don't feel so bad now
02:40:25 <ski> zincy_ : however, i'm trying to present the topic in the way which i think makes most sense, and which i thing will generalize nicely later (so not cause undue problems with unlearning then)
02:40:38 <ski> qwebirc53346 : no worry
02:41:10 <ski> zincy_ : perhaps we should move to #haskell-overflow, to not add noise to people who want to ask other questions (like qwebirc53346) ?
02:41:16 <zincy_> yeah
02:41:25 <qwebirc53346> y'all r good!!!
02:41:34 <ski> qwebirc53346 : you're of course welcome to follow us in there and lurk (or interject, if you prefer), if you'd like to
02:42:13 <qwebirc53346> ta very much!! i may (???) have figured out the solution to my problem which is not really a problem
02:42:21 <ski> qwebirc53346 : to get in there, you'd issue the IRC command `/join #haskell-overflow' (without the quotes, of course)
02:42:35 <qwebirc53346> ugh i havent used irc in ages ty
02:43:04 <ski> qwebirc53346 : you may have to restate your problem/question in here, though, because as it is, it unfortunately got spread out a bit into our noise, and so it's not as easy to notice
02:43:08 <qwebirc53346> i love coding, there's nowhere else i can get this much feeling of being intensely out of my depth
02:43:35 <ski> <qwebirc53346> like is it ok if i post my problem
02:44:05 <ski> if it's just a couple of lines, you can show them in here. otherwise it's preferred if you put in online somewhere (on your own site, or on a paste site, e.g.), and give the link to that in here
02:44:28 <qwebirc53346> i think i've figured out what i was doing wrong!!! thank u for being considerate!!!!!
02:44:35 * ski hasn't seen qwebirc53346 entering #haskell-overflow yet
02:44:51 <zincy_> qwebirc53346: Often formulating the question solves the problem :)
02:45:04 <qwebirc53346> ty!!!
02:47:23 * ski looks at zincy_
02:50:56 <ski> zincy_ : or would you prefer continuing in here, now, since qwebirc53346 left us ?
02:51:27 <ski> i haven't gotten to the part of explaining `forall', yet
02:52:35 <ski> (i haven't used `forall' in types, only in the logical pseudo-Haskell notation where i explicitly said that for each type `a' (in formulae : `forall a.'), `reverse' has type `[a] -> [a]' (in formulae : `reverse :: [a] -> [a]'))
02:52:42 <trcc> Yes please continue in here :)
02:53:01 <ski> yea .. but i'd like zincy_ to be present at least
02:53:14 <ski> perhaps they got a phone call or something
02:53:56 * ski notices trcc isn't in #haskell-overflow
02:56:22 <qwebirc53211> i don't know how i broke it this badly
02:56:32 <qwebirc53211> after executing cabal install ghci
02:56:39 <qwebirc53211> cabal: Could not resolve dependencies: [__0] trying: ghci-8.6.5 (user goal) [__1] next goal: template-haskell (dependency of ghci) [__1] rejecting: template-haskell-2.14.0.0/installed-2.1... (conflict: ghci => ghc-boot-th==8.6.5, template-haskell => ghc-boot-th==8.6.3/installed-8.6...) [__1] rejecting: template-haskell-2.14.0.0, template-haskell-2.13.0.0, template-haskell-2.12.0.0, template-haskell-2.11.1.0, template-haskell-2
02:56:58 <zincy_> ski: Yeah lets continue here
02:58:33 <qwebirc53211> i think what im going to do is lie down and cry a lot and see if that fixes it
02:59:33 <Profpatsch> getLabel :: (KnownSymbol s) => TypeArg s t a -> Text.Text
02:59:35 <Profpatsch> getLabel _ = Text.pack $ symbolVal (Proxy :: (Proxy :: Symbol -> *) s)
02:59:45 <Profpatsch> Could not deduce (KnownSymbol n0)
02:59:47 <Profpatsch> wat?
03:00:33 <Profpatsch> Which type variable is that? It’s not listed anywhere in the type error, except in the first line
03:01:33 <ski> qwebirc53211 : you're back ?
03:04:03 <ski> Profpatsch : that's an ambiguity error. you need the `ScopedTypeVariables' extension
03:04:26 <ski> Profpatsch : it doesn't know that the `s' in your type ascription is the same type as the `s' in your type signature
03:04:37 <Profpatsch> ski: That’s enabled
03:04:46 <ski> after enabling that extension, you need to change the source above in one of two ways
03:05:08 <ski> either (a) change the definition equation to
03:05:25 <ski>   getLabel (_ :: TypeArg s t a) = Text.pack $ symbolVal (Proxy :: (Proxy :: Symbol -> *) s)
03:05:38 <ski> to bring `s',`t' and `a' into scope in that defining equation
03:05:48 <ski> or (b) change the type signature to
03:05:49 <Profpatsch> Really? That’s sad
03:05:59 <ski>   getLabel :: forall s. KnownSymbol s => TypeArg s t a -> Text.Text
03:06:14 <Profpatsch> Ok, so in some circumstances I need explicit forall.
03:06:33 <ski> yes, imho, it shouldn't be required to use an explicit `forall s.' here, but unfortunately that's how `ScopedTypeVariables' work, atm
03:06:38 <Profpatsch> Yea are right.
03:06:41 <Profpatsch> *Dou
03:06:48 <ski> i think this is bad, it being exactly opposite to what you'd expect
03:06:49 <Profpatsch> Argh, *you :)
03:06:56 <Profpatsch> yes, that’s why I was confused.
03:07:09 <Profpatsch> But thanks, that worked.
03:07:12 <ski> `forall' is a binder, so you'd expect that if you used it, then `s' would *only* be in scope in that type signature
03:08:08 <ski> while if there was no explicit `forall', then (if `ScopedTypeVariables' is enabled), one could imagine an implicit `forall s.' which scopes over *both* the type signature, and the defining equation, so that we share the same `s' in the same scope, and then your original code would have been correct
03:08:13 <Profpatsch> Explicit forall also solves another error in my code <3
03:08:24 <ski> but as i said, unfortunately that's not what the GHC developers chose to implement
03:08:47 <ski> i think they went the way they did because of backwards compatibility or least surprise/change or something like that
03:09:20 <ski> but, i find this (how it currently works, it being "backwards" as i said) really unfortunate and confusing !
03:09:28 <Profpatsch> it is
03:09:51 <ski> ok. so now i have at least one person who's been confused by this :)
03:09:57 <ski> i should keep a count, perhaps ;)
03:11:30 <ski> personally, i would quite possibly go with option (a), just because i dislike the contraintuitive `forall' in the (b) option that much ..
03:11:56 <ski> zincy_ : ok, then. ready ?
03:14:12 <Profpatsch> I’m not opposed to explicit forall.
03:14:18 <Profpatsch> That’s how purescript does it
03:14:36 <ski> me neither. but i *am* opposed to contraintuitive scoping
03:14:45 <Profpatsch> same
03:15:10 <Profpatsch> “All I wanted was a String”
03:15:16 <ski> in something like purescript, what one'd do is "use both (a) and (b)"
03:15:18 <ski> iow
03:15:35 <ski>   getLabel :: forall s t a. KnownSymbol s => TypeArg s t a -> Text.Text
03:15:55 <ski>   getLabel (_ :: TypeArg s t a) = Text.pack (symbolVal (Proxy :: (Proxy :: Symbol -> *) s))
03:16:31 <ski> (i'm not sure whether you need that kind ascription there, what is the kind of `TypeArg' ? if it is `Symbol -> ...', then i don't think you need that kind ascription)
03:17:02 <ski> well, perhaps purescript would also want to explicitly bind the (distinct) tyvars `s',`t',`a' in the defining equation, maybe like
03:17:09 <ski>   forall s t a. getLabel (_ :: TypeArg s t a) = Text.pack (symbolVal (Proxy :: (Proxy :: Symbol -> *) s))
03:17:12 <ski> or something
03:17:32 <ski> in Java, you do have to type
03:17:51 <ski>   <A> Foo<A>frob(Bar<A> x)
03:18:05 <ski> and that initial `<A>' is basically a `forall' on `A'
03:18:33 <ski> er, i suppose one would usually have a space after the return type, so
03:18:38 <ski>   <A> Foo<A> frob(Bar<A> x)
03:18:52 * ski pokes zincy_ with a stick
03:20:25 <ski> anyway, if one would have such explicit `forall' binders of types, in defining equations, then why not also for the ordinary variable parameters ?
03:20:29 <ski> so, instead of
03:20:32 <ski>   id :: a -> a
03:20:36 <ski>   id x = x
03:20:40 <ski> we'd have
03:20:45 <ski>   id :: forall a. a -> a
03:20:58 <ski>   forall a. forall (x :: a). id x = x
03:21:27 <ski> because that defining equation *is* saying that for every input `x' (of type `a'), `id x' is equal to `x'
03:21:56 <ski> (in Profpatsch's case, there were no named parameters, only the `_', which wouldn't get such a `forall')
03:22:11 <zincy_> ski: back again, doorbell rang
03:22:17 <ski> no worry
03:23:10 <ski> i busied myself with an issue Profpatsch was having, re scoping of type variables. specifically how to refer to a tyvar in a type signature, from a defining equation
03:23:21 <ski> zincy_ : so, shall we continue ?
03:23:29 <zincy_> yeah
03:24:06 <ski> so, we had this dichotomic view of monomophic vs. polymorphic
03:25:05 <ski> a monomorphic thing having one type, a polymorphic thing having many types. in Haskell, we have parametric polymorphism, all these many types are captured by a single "pattern"/"template"/"schema" in terms of "parameters" (type variables)
03:25:46 <ski> however, there are also other notions of polymorphism (in the sense of a thing having many types). e.g. overloading. and subtyping as in (statically types) object-oriented languages
03:26:23 <zincy_> overloading in OO languages is a form ad hoc polymorphism isnt it?
03:26:33 <zincy_> *of
03:26:45 <ski> yes, that's also mentioned in what i'm about to refer to
03:26:54 <ski> if you want to get a better understanding of such different forms of "polymorphism" (which is here used as a vague umbrella covering sortof similar things), you can check out the paper
03:26:59 <ski> @where OnUnderstanding
03:27:00 <lambdabot> I know nothing about onunderstanding.
03:27:03 <ski> er
03:27:12 <ski> @where on-understanding
03:27:12 <lambdabot> "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf>
03:27:13 <ski> right
03:27:34 <zincy_> Thanks
03:27:46 <ski> @where on-understanding-revisited
03:27:46 <lambdabot> "On Understanding Data Abstraction, Revisited" by William R. Cook in 2009-10 at <http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf>
03:28:05 <ski> might also be interesting. it goes into some OO notions
03:28:18 <ski> also, another paper, about polymorphism, is
03:28:25 <ski> @where polymorphic-type-inference
03:28:26 <lambdabot> "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <https://cs.au.dk/~mis/typeinf.p(s|df)>,<http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.57.1493>
03:28:32 <ski> that might also be helpful
03:28:44 <ski> (that's about the parametric polymorphism of Haskell)
03:28:57 <ski> anyway
03:29:33 <ski> now i want to move from this "monomorphic, having a single type" vs. "polymorphic, having many types, captured by a single type schema" picture, to a more refined picture
03:29:41 <zincy_> Can you elaborate on the "parametric" equating to type parameters?
03:29:57 <ski> in `reverse :: [a] -> [a]', `a' would be the "parameter"
03:30:52 <zincy_> Values don't have "parametric" or "ad hoc" polymorphism do they?
03:31:04 <zincy_> They are just polymorphic
03:31:45 <ski> we can plug in any (concrete) type for that, just as we can plug in any (`Bool'ean) `b' in the defining equations `False && b = False' and `True && b = b' for `(&&)'
03:32:47 <zincy_> so parametricity is a property of polymorphic functions?
03:33:13 <ski> it's a *possible* property of having polymorphism in the language
03:33:23 <ski> there's a subtlety here in the terminology
03:33:26 <zincy_> yeah
03:33:54 <ski> just because your language has parametric polymorphism, doesn't mean it enjoys "parametricity". the latter is a stronger condition
03:33:55 <zincy_> So a possible property of functions in a polymorphic language
03:34:18 <zincy_> What is the nature of the distinction?
03:35:18 <ski> Haskell has parametricity. but e.g. Java, or Mercury, which also has parametric polymorphism, *doesn't* have parametricity -- because you can at run-time check the type of a thing, and then much around with that thing once you know the type, even if you're in a parametrically polymorphic operation !
03:35:35 <ski> i can talk a little bit more about that, and the end, if you like
03:36:30 <ski> did you get what i said about `a' being a parameter of the signature `reverse :: [a] -> [a]', in a similar sense to how `b' is a parameter of the defining equations `False && b = False' and `True && b = b' ?
03:37:53 <ski> in the former case, this means that if we pick the "parameter" `a' as e.g. `Bool', then we arrive at `reverse :: [Bool] -> [Bool]' which is a *specific* type (not a type schema), which `reverse' can be used has having
03:37:57 <zincy_> yeah I think so ... `a` is a parameter for the [] type constructor
03:39:10 <zincy_> and a can be any type of kind *
03:39:19 <ski> in the latter case, this means that if we pick the "parameter" `b' as e.g. `True', then we arrive at the "specialized (defining) equations/equalities" `False && True = False' and `True && True = True'
03:39:42 <ski> or, if we pick `b' as `False', then we get `False && False = False' and `True && False = False'
03:40:04 <ski> and these are all true equalities about `Bool'eans and `&&', which we can use when we reason about, and refactor code, e.g.
03:40:04 <zincy_> yeah
03:40:20 <dminuoso>  zincy_ | yeah I think so ... `a` is a parameter for the [] type constructor
03:40:24 <dminuoso> zincy_: I think you misunderstood that part.
03:40:45 <dminuoso> zincy_: The word parameter is not meant as a parameter to the [] type constructor, but rather `a` being a type parameter is a broader sense if you zoom out.
03:41:25 <zincy_> oh in the sense of `a` being a paramter to the entire   `reverse :: [a] -> [a]'
03:41:42 <ski> (i'd say that's the main of defining functions with parameters to the left of the `=' sign, rather than saying something like `(&&) = \b0 b1 -> case b0 of False -> False; True -> b1', which is more similar to a `switch' command, or a chain of `if'-`then'-`else's in other languages
03:42:56 <dminuoso> zincy_: Yes. In some sense it's similar to a lambda abstraction, where ∀ takes a similar role of \ in Haskell. All a lambda abstraction does, is generalize/parametrize some term over a variable.
03:43:26 <ski>  the problem here is that it's not as easy to see the specializations like e.g. `True && False = False' above, and *especially* that it's harder to reason about the cases independently of each other. with separate defining equations, it's simpler to think of each of them as a separate true fact about the operation we're defining (though there is a gotcha there, about patterns in different defining equations overlapping))
03:43:48 <ski> <zincy_> oh in the sense of `a` being a paramter to the entire   `reverse :: [a] -> [a]'
03:43:52 <ski> yes, exactly
03:44:09 <ski> dminuoso : ty for making that clear
03:44:49 <zincy_> So we have moved up a level from talking about substituting types into type constructor parameters to substituting parameters into type schemas to get types
03:45:20 <dminuoso> zincy_: Note that ∀ is the UTF8 symbol for forall, in case you are not familiar with it.
03:45:31 <ski> substitution is about replacing some variable/parameter names with (possibly) more complicated expressions/phrases
03:45:51 <ski> applying `Maybe' to `Bool', getting `Maybe Bool', is not substitution, it's just application
03:46:20 <ski> replacing `a' with `Bool' in `Maybe a' (aka substituting `Bool' for `a' in `Maybe a') *is* substitution
03:46:31 <zincy_> Makes sense
03:46:43 <ski> so, there is no "substituting types into type constructor parameters", strictly speaking
03:47:04 <ski> we have a type expression `Maybe a', which *happens* to be a type constructor applied to a type variable `a'
03:47:16 <ski> and we replace `a' by some specific type (expression)
03:47:35 <ski> but we could just as well have started with `Maybe (Maybe a)', and then replaced `a' in there by some type
03:47:58 <zincy_> Not sure I understand  "substituting `Bool' for `a' in `Maybe a'"
03:47:58 <ski> and that is certainly not just a type constructor applied to parameters
03:48:18 <ski> "substituting `Bool' for `a' in `Maybe a'" means the same thing as "replacing `a' with `Bool' in `Maybe a'"
03:48:27 <zincy_> So application is about reduction whereas substition is replacing?
03:48:29 <ski> the result, in either case, is `Maybe Bool'
03:49:06 <ski> with application, you take two expressions, one describing a function, and the other some value which we'd like to feed as input to the function
03:49:46 <ski> and we "place them next to each other / juxtapose them". in terms of Abstract Syntax Trees, we form a new tree node, an *application* node, which will have these two expressions as subtrees
03:50:08 <ski> so we're just building a larger thing out of smaller things, without modifying the smaller things
03:50:24 <zincy_> ok undestood
03:50:28 <zincy_> *understood
03:50:47 <ski> however, with substitution, we have `Maybe a', we have the parameter-to-substitute-for, that's `a', and we have `Bool', and we end up *modifying* `Maybe a' so that we get `Maybe Bool'
03:51:14 <ski> notice how `x^2 + 1' is not a function, you can't apply it to e.g. `3', `(x^2 + 1)(3)' is nonsense
03:51:26 <zincy_> Yeah so you can't just replace `a` it has to be applied to the type constructor
03:51:38 <ski> you *can* substitute `3' for `x' in the expression `x^2 + 1', getting `3^2 + 1', which is equal to `10'
03:52:08 <zincy_> gotcha
03:52:16 <ski> "substition is replacing" -- yes
03:52:24 <ski> "application is about reduction" -- no
03:52:47 <ski> if we apply the expression `not' to the expression `False', we get the expression `not False'
03:52:55 <ski> reducing that to `True' is a separate thing
03:53:40 <ski> however, if we're focused on the values of expressions, and not on the expressions themselves, then we consider `not False' equal to `True', and then we can say that applying `not' to `False' yields `True'
03:54:22 <zincy_> So application has the same kind of meaning as it does in everyday speak
03:54:37 <ski> however, "application" (and also "substitution") is a syntactic notion. and sometimes this distinction matters / can help make things clearer
03:54:40 <zincy_> You are applying something to something else
03:54:49 <ski> .. i suppose ?
03:55:00 * ski isn't quite sure what the "everyday speak" meaning of the word is
03:55:20 <dminuoso> zincy_: Application can be thought of as a grammatical feature.
03:55:46 <zincy_> ski: Actually there are many "everday speak" meanings so not very helpful
03:55:49 <dminuoso> So if `f` is some term, and `a` is some term, then the term `f a` is described by some grammar rule you might call "Application"
03:55:54 <ski> zincy_ : *nod*
03:56:10 <zincy_> language is so imprecise
03:56:41 <ski> anyway
03:56:50 <ski> you said before
03:56:56 <ski> <zincy_> Values don't have "parametric" or "ad hoc" polymorphism do they?
03:57:01 <ski> <zincy_> They are just polymorphic
03:57:19 <ski> to which i'd like to reply with what i said a bit earlier than that
03:57:28 <ski> <ski> zincy_ : ok, so the last few things i said here applies to basic systems with polymorphism. every value is either monomorphic (has one type), or is polymorphic (has one type schema, which (normally) specializes to / specifies infinitely many types)
03:57:32 <ski> <ski> or, perhaps one should say that the polymorphic ones are "pseudo-values", or something. that they don't become actual values until we specialize the type schema to a specific type
03:57:41 <ski> especially the second of these two statements
03:58:19 <zincy_> right
03:58:24 <ski> so, from this POV. a polymorphic thing isn't a value, it has many forms
03:59:10 <ski> when you select a particular form, by specializing the type scheme, like `[a] -> [a]' to a specific type, like `[Bool] -> [Bool]', then you could say that the resulting thing is a value
04:00:17 <ski> you can't pass around these polymorphic things, these pseudo-values
04:00:18 <zincy_> What does "resulting thing" apply to?
04:00:31 <ski> you can only pass around ordinary monomorphic things, being values
04:00:39 <zincy_> [Bool] -> [Bool] looks like a type?
04:00:41 <zincy_> Not a value
04:00:53 <zincy_> Different level of abstraction ?
04:00:59 <ski> the "resulting thing" being the resulting value, having type `[Bool] -> [Bool]', in that case
04:01:03 <ski> sorry if i was unclear
04:01:17 <zincy_> cool
04:01:59 <ski> so, we start with a polymorphic pseudo-value, `reverse', having type schema `[a] -> [a]', and you select/pick a particular form, out of its many forms, getting .. `reverse', a (monomorphic thing /) value of type `[Bool] -> [Bool]'
04:02:27 <ski> what's passed around at run-time is always the monomorphic things, the values. never the pseudo-values
04:02:53 <zincy_> interesting
04:04:14 <ski> if you call `reverse', you'll call it on some list with a particular type, like `[(Integer,String)]', and so you're actually calling the specialized version of `reverse' having type `[(Integer,String)] -> [(Integer,String)]' (so in this instance/case of calling `reverse', this occurence of the name `reverse', `a' was chosen/picked/selected to be `(Integer,String)')
04:04:47 <ski> and when this `reverse' calls itself recursively, it'll always pass around values of specific types, no polymorphic thingies
04:05:00 <ski> same thing happens if you have one polymorphic function which calls another one
04:06:10 <ski> when you actually call it, you're actually using a specialized version of it, with say a type parameter `a' replaced by, e.g., `[Integer]'. and then it in turn calls some other polymorphic function, it's actually calling the monomorphic / specialized version of it, where, say, a `b' parameter is picked as `Integer'
04:07:06 <ski> (i said `b', to not confuse it with the `a' in the type schema for the first function. however, as you should know, if you write a tyvar `a' in one signature, and an `a' in another signature, then those are different scopes, so they are distinct tyvars)
04:08:02 <ski> however, there's one potential issue here, which may perhaps cause some confusion
04:08:25 <ski> namely that we write the same `reverse' for the polymorhic thing, as for the monomorphic thing
04:08:40 <ski> we don't see the implicit conversion from one to the other, in Haskell source
04:09:22 <zincy_> so at runtime all values are of monomorphic types
04:09:24 <ski> well, with the extension `TypeApplications', we can actually spell the difference out
04:09:28 <ski> zincy_ : yes
04:09:46 <zincy_> question ...
04:10:33 * ski waits
04:11:29 <zincy_> Is it possible to define a polymorphic and recursive function which calls itself with different specialisations of a type parameter to the type schema?
04:12:21 <ski> yes. that's what "polymorphic recursion" means
04:12:22 <ggole> Yep, that's called polymorphic recursion.
04:12:47 <ski> however, i wanted to first give a broader understanding of `forall'
04:12:55 <ggole> Note that you'll need an annotation on the function(s) to do that
04:12:59 <zincy_> Ah I couldn't scroll back far enough to reread your definition for it
04:13:17 <ski> (i haven't done that yet. i've just given the basic understanding, which is also valid in several other languages)
04:13:35 <zincy_> ok lets continue then
04:13:37 <ski> (the broader understanding is valid in Haskell, but not is so many other languages)
04:13:41 <zincy_> ggole: cheers
04:14:05 <ski> so `reverse' will be the polymorphic thing, having type schema `[a] -> [a]', and `reverse @(Integer,String)' (e.g.) will be a particular corresponding selection of one of the many forms, having type `[(Integer,String)] -> [(Integer,String)]'
04:14:15 <ski> this is using the `TypeApplications' extension
04:15:03 <ski> so, using this syntax, we can distinguish between the polymorphic pseudo-values / things, the "many-forms", and the ordinary, polymorphic things, the values, the "single-forms"
04:15:34 <ski> however, enabling this extension still doesn't *require* us to use the `@...' notation in the latter case
04:15:39 <ski> zincy_ : does that make sense to you ?
04:16:03 <ski> (er, s/in the latter case/when moving from the former case to the latter case/)
04:17:09 <ski> (obviously using `not', of type `Bool -> Bool', doesn't involve any polymorphic specialization, since `not' is already monomorphic. but `reverse' is polymorphic, and so to use it, we need to specialize somehow, either implicitly, or explicitly)
04:17:54 <zincy_> I think so ... `a` in  type schema `[a] -> [a]' is a pseudo value i.e it doesn't have any values until the type schema is specialised 
04:18:14 <ski> no, `a' is a type (a type variable, a type parameter)
04:18:29 <ski> `reverse' would be a "pseudo-value", in the terms i was using above
04:18:37 <zincy_> ah ok
04:18:49 <ski> and `reverse @Bool' would be a value, of type `[Bool] -> [Bool]'
04:19:04 <ski> (while `reverse' has the type schema `[a] -> [a]', as we mentioned)
04:19:25 <zincy_> so the pseudo-value term only applies to things which can be values
04:19:30 <zincy_> such as `reverse`
04:20:12 <ski> however, even if you have this `TypeApplications', you dont' have to use this `@' syntax when using `reverse'. in that case the implementation will figure out that you meant `reverse @Bool' (or whatever), and treat the code as if you had written that explicitly
04:20:48 <ski> yes, specifically "pseudo-values" are "polymorphic things", while "values" are "polymorphic things"
04:21:28 <ski> (i don't want to say "functions", since this applies not just to functions. there are also polymorphic things which are not functions, like e.g. `Nothing', having type schema `Maybe a')
04:21:49 <zincy_> Ok I think I have successfuly made the distinction now in my head between the compile time polymorphism and run time monomorphism
04:21:57 <ski> er, sorry, let me repeat the next to last sentence
04:22:12 <ski> yes, specifically "pseudo-values" are "polymorphic things", while "values" are "*mono*morphic things"
04:22:25 <zincy_> because when you see pseudo-values like reverse the fact that it is monomorphic at runtime isn't really explicit
04:22:35 <ski> (i accidentally typed "polymorphic" instead of "monomorphic", in the latter case)
04:23:00 <ski> zincy_ : right !
04:23:05 <zincy_> yay
04:23:14 <ski> zincy_ : however, of course there are also things that are monomorphic at compile-time
04:23:23 <zincy_> not I am questioning what polymorphism means again
04:23:24 <zincy_> haha
04:23:26 <zincy_> now
04:23:31 <ggole> I'm not sure it's a good idea to talk about whether something is monomorphic at runtime, since by runtime all types have been erased.
04:24:06 <ski> ggole : yes, that's exactly one of the issues which started this discussion, and is the reason i needed to talk about "run-time monomorphism"
04:24:54 <ski> ggole : so, i'm saying, there's a reason i'm talking about "run-time monomorphism", despite "by runtime all types have been erased" !
04:25:02 <tty1> Hi, super noob, trying to understand how to implement type classes a bit better. I have a typeclass I am creating which is a subclass of Eq. Is there a way i can define a default implementation of == in the subclass. Here is my attempt but obviously it errors: https://hastebin.com/wuniyuliso.hs
04:25:16 <ggole> OK, guess I'm missing that context.
04:25:25 <dminuoso> tty1: No you cannot.
04:25:54 <dminuoso> tty1: The reason is that (==) is a method of Eq. Subclasses are different from subclasses from some object-oriented languages.
04:26:22 <dminuoso> tty1: You can think of Subclass as being a requirement that instances also have an instance of the respective superclass (and you get implicit access to superclass methods that way)
04:27:31 <tty1> dminuoso: that seems odd to me that there isnt a way to truely extend typeclasses
04:27:36 <Solonarv> tty1: instead what you can do is define a plain old function:
04:27:36 <Solonarv> defaultEq :: (Eq i, Identified t i o) => t -> t -> Bool
04:27:36 <Solonarv> defaultEq x y = ident x == ident y
04:27:36 <Solonarv> and advise users to use this as the implementation for (==):
04:27:54 <dminuoso> tty1: typeclasses serve different purposes than classes in say C++ or Java.
04:28:11 <dminuoso> tty1: A typeclass is a sort of interface, and "subclasses" sort of imply "must also implement XYZ"
04:29:05 <tty1> dminuoso: yea thats how i was thinking about them.. though seems if one can provide a default for another method in the class it should be allowed... oh well no crying over spilled milk, cant do it, then i cant do it
04:29:15 <dminuoso> tty1: Oh well yeah, its certainly not idea.
04:29:41 <ski> zincy_ : i'm trying to give you a solid foundation of the basic idea of (parametric) polymorphism (which also applies in many other languages), so that you can then better appreciate the ways in which Haskell extends this view (into the "broader understanding") in useful ways
04:29:43 <dminuoso> tty1: Like when you write `instance Monad XYZ` you are forced to implement Functor and Applicative, even though technically you could infer the implementations of fmap/pure/(<*>) completely mechanically from Monad.
04:30:28 <zincy_> ski: *nods*
04:30:36 <Solonarv> tty1: yes, it would be convenient to be able to specify defaults
04:30:39 <tty1> dminuoso: yea, seems like the sort of thing they could add to the language for convience somehow.. oh well, it is what it is
04:30:49 <Solonarv> the problem is, what if there are multiple subclasses which each specify a default?
04:31:21 <[exa]> tty1: the 'specialization' stuff you're trying to do is usually better done using a newtype wrapper
04:31:49 <tty1> Solonarv: well that could produce an error and require the implementor in that case to define which of the defaults to use, or roll their own.. at least in theory.. but thats not how its done apparently so its all good
04:32:06 <dminuoso> Solonarv: And I guess the open world assumption *also* makes this problematic.
04:32:13 <Solonarv> tty1: what's usually done is giving the default implementation as a top-level function
04:32:19 <dminuoso> Since it could lead to incoherent programs, no?
04:32:29 <ski> zincy_ : because, quite a few of the things i've been saying, about the "basic understanding", no longer holds true, in the "broader understanding". and so if you're to get a good grounding also on the "basic understanding" (applying also in other languages), i must introduce such statements which (with extensions) no longer holds true (alt. no longer is an adequate way of thinking about stuff) in Haskell
04:32:29 <tty1> fair
04:33:01 <Solonarv> so you can for example write:
04:33:01 <Solonarv> instance Functor Foo where fmap = fmapDefault
04:33:01 <Solonarv> instance Foldable Foo where foldMap = foldMapDefault
04:33:01 <Solonarv> instance Traversable Foo where traverse = <actual implementation here>
04:33:21 <dminuoso> tty1: So I guess this would actually force orphan instances.
04:33:22 <ski> zincy_ : so, i'm going to shake you up a bit, by contradicting some of the things i've said before, and that's one of the reasons i wanted to spent some more time on the "basic understanding" of polymorphism, first
04:33:33 <dminuoso> tty1: So you get all the pain and issues associated with orphan instances if this were possible too.
04:33:34 <Solonarv> fmapDefault and foldMapDefault are defined in Data.Traversable and use Traversable's operations to implement fmap and foldMap, respectively
04:33:37 <ski> zincy_ : do you understand, roughly, what i'm trying to do ?
04:33:44 <tty1> New question... of the people here who feel that haskell is their favorite or second favorite functional language, what is your other favorite functional? I really like the aesthetic of haskell and if i decide to learn another functional language id like some ideas as to what to look into
04:33:55 <ski> zincy_ : also, how about #haskell-overflow now ?
04:33:59 <tty1> dminuoso: makes sense
04:34:08 <dminuoso> tty1: I hear a lot of good about PureScript.
04:34:52 <dminuoso> tty1: Though I should ask, what do you mean by "functional language" exactly?
04:35:41 <dminuoso> tty1: I enjoyed diving into Prolog a lot, since it gave me some fresh insights into logic programming which I was not familiar with before. 
04:36:12 <tty1> dminuoso: not entierly sure.. your clojure, lisp, and haskells of the world I guess.. I usually think of it as languages which tend to shine by passing immutable structures to methods and relies on monads as a central part of their design.. but i dont know enough to really say, hell not even 100% clear on what a monad is yet
04:37:06 <ski> tty1 : i like SML,Scheme,OCaml,Erlang. Clean is also probably fine, although i haven't played that much with it (it is however a lazy^Wnon-strict language, just like Haskell, and it has type classes, so it's similar to Haskell in many ways. however it has "uniqueness" (in types), which is not common)
04:38:48 <dminuoso> Oh Erlang is quite enjoyable too, indeed.
04:39:11 <dminuoso> ski: what is uniqueness?
04:39:27 <ski> tty1 : i haven't tried the various (like statically typed) variants of ECMAScript (of which Javascript is an implementation), so i can't really comment on them
04:40:41 <fendor> tty1, I like rust and elm.
04:41:40 <ski> tty1 : furthermore, if you like functional programming, i'd really suggest looking into logic programming at some point. it differs in some ways, and is similar in some ways. both functional and logic programming are often classified under the wider umbrella of declarative programming (constraint programming also belongs here, at least the constraint logic programming kind. also attribute grammars probably also belong here ..)
04:41:47 <__monty__> tty1: Agda or Idris are interesting too.
04:42:02 * dminuoso has waited for someone to drop in with dependently typed languages
04:43:15 <ski> tty1 : and if you want to look at logic programming, it's hard to avoid Prolog, since most of the resources for LP is in terms of Prolog. still, there are other languages like Mercury (which has e.g. a static type system, quite similar to Haskell's), or Oz (the language of the book CTM). also Gödel,Escher,Curry,lambdaProlog,Lolli,Twelf
04:43:26 <fendor> well, what do you expect here? Someone saying he loves the way you program in c? :D
04:43:32 <ski> @where CTM
04:43:32 <lambdabot> "Concepts, Techniques, and Models of Computer Programming", by Peter Van Roy,Seif Haridi, at <http://www.info.ucl.ac.be/~pvr/book.html>
04:44:31 <dminuoso> ski: Prolog has made it into my list of "useful to widen your horizon". :)
04:44:45 <dminuoso> Any language that changes the way you think about programming is worth learning.
04:45:07 <ski> CTM is a book about programming paradigms (like functional programming, logic programming, object-oriented programming, &c.). (it uses the same language, Oz, for all paradigms. Oz is at the core a logic programming language (without disjunction/"OR")). it's a good book, imho
04:45:16 <ski> you may compare CTM with SICP
04:45:18 <ski> @where SICP
04:45:18 <lambdabot> "Structure and Interpretation of Computer Programs" <http://mitpress.mit.edu/sicp/>,<http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/>,<https://github.com/sarabander/sicp-pdf> | "
04:45:19 <lambdabot> Storage and Identification of Cabalized Packages" <http://www.vex.net/~trebla/haskell/sicp.xhtml>
04:45:37 <ski> (there's videos available there !)
04:46:31 <ski> dminuoso : yes. if you want to widen your horizon, i definitely suggest looking into logic programming. understanding logic programming also helps with understanding unification of types, and inference of type class instances, in the type system of Haskell
04:48:07 <ski> basic Prolog is old, doesn't even have a module system standardized. it has lots of illogical, and side-effectful, features. many flaws. Mercury is meant to address many of these. however, i'd probably still suggest looking into Prolog, at least at some point
04:48:25 <ggole> CTM is a great text, very broad
04:49:43 <ski> because of (a) most literature being in terms of Prolog (as i mentioned); and (b) because i think it probably helps to make all the mistakes that Prolog allow, to better understand what the static checking (of not just types, but also modes, insts, determinisms) in Mercury is good for, what problems it helps avoid
04:50:10 <tty1> hmm
04:50:20 <ski> (e.g. that will help you understanding static checking error messages, understand what the implementation is complaining about)
04:52:05 <ski> see "Re: Mercury in academic teaching?" by Richard A. O'Keefe in 2006-10-(09|10) at <http://www.mercurylang.org/list-archives/users/2006-October/004000.html>,<http://www.mercurylang.org/list-archives/users/2006-October/004011.html> for some more (imho interesting) discussion about such issues
04:53:47 <ski> (it's not just about Prolog vs. Mercury, but more broadly about whether one learns better with more or less safety measures, and about how an implementation can attempt to give better error diagnostics, by trying to explain the problem better, or by guessing what the user intended to do)
04:53:57 <tty1> thanks for all the suggestions
04:56:23 <ski> tty1 : "languages which tend to shine by passing immutable structures to methods and relies on monads as a central part of their design" -- not many of the functional programming languages feature monads much. one can (to lesser or greater extents, will more or less effort) use monadic ideas. but most languages don't have language support, or basic library support, for monads
04:56:52 <tty1> ski interesting
04:57:30 <ski> also, often when people come to Haskell, they make too big of a deal about monads
04:58:11 <ski> monads are "just" a recurring pattern in code, that one can abstract. you can compare the "monad interface" with the "priority-queue interface"
04:58:45 <ski> just as there are several implementations of the "priority-queue interface", there are also several implementations of the "monad interface"
04:59:35 <ski> however, one important difference is that if you only know that you're working with proprity-queues, conforming to the interface, but you don't know *which* implementation you're working with, you can still write useful code
05:00:14 <ski> however, with monads, if you just know you are working with a monad, but don't know which monad in particular, there's not *so* many useful things you can do
05:00:42 <ski> (there are some, like generic traversal things, like `sequence',`mapM',`traverse',&c.)
05:01:13 <ski> in the end, to be able to get something useful out of a monad, you must (in some place in your program) know *which* monad you're working with
05:02:23 <ski> .. and this is probably one reason why it seems to be more effective to learn about monads by focusing more on the particular different monads, and less on the abstract interface (which doesn't tell you much)
05:03:32 <ski> so, to begin with, you don't really learn about "monads", but rather "this particular monad", and "that particular monad". then, after a while, you'll start to notice the similarities (and differences) between these often very different feeling things
05:04:02 <ski> hm .. so, apparently this devolved into a monad rant, i suppose :)
05:04:32 * ski looks in zincy_'s general direction
05:04:38 <zincy_> yep back
05:04:53 <zincy_> Shall we continue here or in overflow?
05:04:55 <dminuoso> ski: Thank you, Ill probably read the whole thread discussion. The both mails seem very interesting, and I do not know Mercurcy honestly to be able to make any sense of it. :)
05:05:11 <ski> zincy_ : shall i repeat the last few things i said (but which you didn't respond to) ?
05:05:48 <ski> well, it appears there's currently no other discussion in here
05:06:20 <ski> (perhaps because i hogged the discussion about different paradigms, and then monads, a bit ?)
05:06:23 <zincy_> yeah sure
05:07:14 <tty1> ski: i havent decided yet if monads are a big dea or not. My friend who convinced me to invest the time thinks monads are the bees knee. He is a clojure guy though. I dunno we will see
05:07:58 <ski> (and, i suppose, interested bystanders might like it if the remainder is also in here. especially if they only notice the discussion later, and realize they weren't in #haskell-overflow .. otoh, perhaps the chance of them noticing the discussion isn't that high, unless they're already looking at the channel during it)
05:08:26 <ski> tty1 : hm, i don't know what the colloquial term "bees knee" mean
05:08:43 <tty1> ski: means "awesome"
05:10:15 <ski> tty1 : monads are one approach to explicitly handling effects (so *enabling* avoiding side-effects). there are also things called "effect systems", which can be considered to have some advantages over monads (more fine grained; commutation of effects; less over-sequentialization)
05:10:39 <ski> tty1 : i think monads are a useful way to better understand effects (and side-effects) in general
05:11:23 <ski> (so, including better understanding how to think about side-effects in imperative languages)
05:11:34 <zincy_> not all monads are about effects though are they?
05:12:03 <ski> tty1 : one might say that part of the utility of monads in Haskell is that we know when we're *not* using them !
05:12:50 <ski> zincy_ : well, i define "effect" to include (at least) everything expressible by monads, so .. ;)
05:13:00 <zincy_> fair enough
05:13:43 <ski> so i have no qualms talking about list-effects (nondeterminism-effects), or `Parser'-effects, or continuation-effects
05:14:25 <ski> <dminuoso> ski: what is uniqueness?
05:14:37 <zincy_> would it be fair to say that monads abstract "effects" into a type of kind * -> *
05:15:22 <zincy_> And be modelling all these different kinds of effects into a typeclass you get a uniform interface for talking about different kinds of effects
05:15:37 <tty1> hmm
05:16:24 <ski> dminuoso : so, uniqueness is about knowing when you have the single reference to a piece of datum in memory. that way, if you need to compute a new one that's mostly the same as the old one, you can simply reuse the memory, using update-in-place. since the old one can't be referred to any more, this is safe from a purity standpoint. both Clean and Mercury has uniqueness (the first in types, the second separately, in "insts")
05:17:32 <ski> dminuoso : uniqueness is sometimes confused with linearity. with linearity, you can express that you aren't allowed to duplicate a particular reference to a datum any *longer*. with uniqueness, otoh, you express that you haven't duplicated it *yet*
05:18:18 <ski> dminuoso : i really should look more into Rust, but iiuc, what they do is similar to, or at least related to, uniqueness
05:18:42 <ski> zincy_ : yes
05:19:12 <ski> zincy_ : also, there's the weaker notion of an idiom (the `Applicative' type class). and also `Functor', if you want to count that
05:19:55 <zincy_> ski: weaker in which sense?
05:20:10 <zincy_> behavioural constraints?
05:20:40 <ski> zincy_ : one might say that idioms allow one to express "static sequencing", while monads allow one to express "dynamic sequencing". the meaning of "sequencing" depends on the particular idiom/monad in question though. it's a conceptual sequencing, which doesn't necessarily have much to do with execution/evaluation order in a low-level machine sense
05:21:13 <ski> (functors doesn't allow one to express "sequencing" at all, only "operating (uniformly) inside a context")
05:21:57 <zincy_> ski: Right the dynamism of sequencing relates toi the control of the computational context you have.
05:22:08 <ski> @where applicative-vs-monadic
05:22:08 <lambdabot> "Applicative vs Monadic build systems" by ndm in 2014-07-23 at <https://neilmitchell.blogspot.se/2014/07/applicative-vs-monadic-build-systems.html>. (cf. "static sequencing" vs. "dynamic sequencing")
05:22:14 <ski> talks about this distinction some
05:22:19 <zincy_> thanks
05:22:53 <ski> with a monad, you can decide "what to do next", depending on *run-time* execution (intermediate) results (so far)
05:23:24 <ski> with an idiom, the "effect structure" is static, fixed in advance (even if it might allow expressing alternative paths, like in parsing)
05:23:42 <ski> with a parser monad, you can first parse an integer, and then parse that many lines of data
05:24:02 <ski> with a parser idiom, you can't do that
05:24:17 <zincy_> So if you think of sequencing of a function then dynamic sequencing is akin to a higher order function which must first be applied
05:24:29 <zincy_> * as a
05:24:49 <zincy_> Maybe that wasn't clear but the sequencing operation can change with monads but not idioms
05:24:55 <ski> with a parser monad, you can also first parse a token describing, or a description of, a particular format to use to parse the next section
05:25:17 <zincy_> yeah
05:25:49 <ski> with a parser idiom, you can do that (in the "parse a token describing" case), *if* you manually enumerate all the different tokens that you want to recognize
05:26:11 <ski> but you can't e.g. look up the token in a table, to get a custom parser for parsing the associated data format
05:27:47 <zincy_> So with a parser idiom, the sequencing operation can change but it has to be specified up front
05:28:14 <zincy_> EarlierI should have said *dynamic* sequencing
05:30:45 <zincy_> ski: So ∀ `a` just says the following expression applies to every possible `a`?
05:31:56 <ski> i'm not sure what you mean by "the sequencing operation can change"
05:32:50 <ski> "So ∀ `a` just says the following expression applies to every possible `a`?" -- iiuc, yes
05:33:12 <ski> <zincy_> ski: Right the dynamism of sequencing relates toi the control of the computational context you have.
05:33:21 <zincy_> :)
05:33:26 <ski> <zincy_> So if you think of sequencing as a function then dynamic sequencing is akin to a higher order function which must first be applied
05:33:32 <ski> <zincy_> Maybe that wasn't clear but the sequencing operation can change with monads but not idioms
05:33:35 <ski> hm
05:33:44 <zincy_> yeah that was clear
05:34:42 <ski> i dunno, perhaps you could find some similarity with a higher-order function which, after it has gotten some callback parameters, defines a local function, in terms of those, that doesn't call back into the general function, and then that function is returned
05:35:18 <ski> while in the "dynamic" case, you might sometimes have that local function call back into the outer more general one, passing along a different callback than what was originally received
05:36:04 <ski> (and this distinction is similar to the "monomorphic recursion" vs. "polymorphic recursion" one, except in that case we're talking about "type parameters" to the function, not ordinary value parameters)
05:36:16 <ski> (but this is one of the things which i mean to clarify further)
05:36:27 <ski> zincy_, ok so :
05:36:32 <ski> <ski> zincy_ : shall i repeat the last few things i said (but which you didn't respond to) ?
05:36:41 <ski> <zincy_> yeah sure
05:36:43 <ski> so
05:36:49 <ski> <zincy_> so the pseudo-value term only applies to things which can be values
05:36:53 <ski> <zincy_> such as `reverse`
05:36:58 <ski> <ski> yes, specifically "pseudo-values" are "polymorphic things", while "values" are "monomorphic things"
05:37:07 <ski> <ski> (i don't want to say "functions", since this applies not just to functions. there are also polymorphic things which are not functions, like e.g. `Nothing', having type schema `Maybe a')
05:37:14 <zincy_> Yeah so the higher order function would need to return a newly defined function for that to "dynamically" affect sequencing I think
05:37:41 <zincy_> oh yes Nothing is a good example
05:37:55 <ski> zincy_ : well, not just initially, but during (e.g.) recursive calls of the locally defined function
05:38:04 <zincy_> yeah
05:38:11 <ski> <zincy_> Ok I think I have successfuly made the distinction now in my head between the compile time polymorphism and run time monomorphism
05:38:12 <zincy_> in that case does the analogy work?
05:38:43 <ski> the analogy with mono- vs- poly- morphic recursion ? yes, i think so
05:38:56 <ski> <zincy_> because when you see pseudo-values like reverse the fact that it is monomorphic at runtime isn't really explicit
05:39:00 <ski> <ski> zincy_ : right !
05:39:03 <ski> <zincy_> yay
05:39:08 <ski> <ski> zincy_ : however, of course there are also things that are monomorphic at compile-time
05:39:17 <zincy_> sorry I meant the sequencing and Higher order funcs analogy but lets just continue
05:39:49 <ski> oh, okay
05:40:01 <ski> <zincy_> now I am questioning what polymorphism means again
05:40:04 <ski> <zincy_> haha
05:40:12 <zincy_> Yeah lets go there first
05:40:18 <ski> <ggole> I'm not sure it's a good idea to talk about whether something is monomorphic at runtime, since by runtime all types have been erased.
05:40:25 <ski> <ski> ggole : yes, that's exactly one of the issues which started this discussion, and is the reason i needed to talk about "run-time monomorphism"
05:40:32 <ski> <ski> ggole : so, i'm saying, there's a reason i'm talking about "run-time monomorphism", despite "by runtime all types have been erased" !
05:40:35 <ski> <ggole> OK, guess I'm missing that context.
05:40:49 <ski> <ski> zincy_ : i'm trying to give you a solid foundation of the basic idea of (parametric) polymorphism (which also applies in many other languages), so that you can then better appreciate the ways in which Haskell extends this view (into the "broader understanding") in useful ways
05:40:54 <ski> <zincy_> ski: *nods*
05:41:20 <ski> <ski> zincy_ : because, quite a few of the things i've been saying, about the "basic understanding", no longer holds true, in the "broader understanding". and so if you're to get a good grounding also on the "basic understanding" (applying also in other languages), i must introduce such statements which (with extensions) no longer holds true (alt. no longer is an adequate way of thinking about stuff) in Haskell
05:41:31 <ski> <ski> zincy_ : so, i'm going to shake you up a bit, by contradicting some of the things i've said before, and that's one of the reasons i wanted to spent some more time on the "basic understanding" of polymorphism, first
05:41:35 <ski> <ski> zincy_ : do you understand, roughly, what i'm trying to do ?
05:42:17 * ski waits for zincy_ to process and respond to that
05:42:31 <zincy_> processing ...
05:43:58 <zincy_> Let me guess when we zoom out conceptually values don't have types at runtime. Types become values in system F that are passed around in each function? 
05:45:24 <ski> values have types, even at run-time. but we need not (depending on implementation strategy) pass around, at run-time, information which allows the implementation to identify those types
05:45:54 <ski> but even if we don't have enough information passed around to be able to recover the types, the values passed around still conceptually have a type
05:46:21 <zincy_> yes thanks for clearing up the terms
05:46:31 <zincy_> I knew that conceptually a value has to have a type
05:46:48 <ski> so "there are no types at run-time" refers to that we may not have enough information to recover the types
05:46:59 <ski> however, conceptually, each value still has a type
05:47:12 <zincy_> So type erasure basically removes the symbolic representation we have given the types
05:47:29 <ski> and *if* we were passing around type information with each value, then we'd never actually perform any type-incorrect operation
05:49:33 <ski> but, since we're not allowed to depend on such run-time type information, we're ensured that whatever operations we perform will yield the same result as if we don't pass any run-time type information around
05:49:34 <zincy_> hmm but Haskell is typesafe and yet at runtime you can't recover the type identifiers from values
05:50:42 <ski> (and therefore the implementation can (is allowed to) erase such run-time type information, in the interest of time and memory efficiency)
05:51:06 <ggole> Values having types is a dicey proposition at best
05:51:27 <ski> ggole : there are two basic philosophical views, yes
05:51:36 <Solonarv> zincy_: thanks to the type-checker, we already know that our program is only putting things together if the types match
05:51:46 <ggole> You can assign the value 1 all sorts of interesting types, depending on the type systems you are considering
05:51:52 <Solonarv> so we don't have to check that again at run-time, so we don't need to keep type information around
05:51:54 <ggole> But it's just a 1 at runtime.
05:52:08 <ski> ggole : one is that you start with values, then carve out useful classes of those, and call those "types". the other is that you start with types (or introduce types simultaneously as values inhabiting them)
05:52:09 <zincy_> Solonarv: Yeah it is correct by construction in a sense
05:52:19 <ggole> Then you get into newtypes/abstract and private types (in ML), etc
05:52:31 <Solonarv> zincy_: yep
05:52:54 <ski> ggole : yes. in the latter view, that "value `1'" is really not a single value, but many different values
05:53:18 <ggole> And representational issues like constructors happening to be physically indistinguishable from some integer
05:53:32 <ski> ggole : so the latter view care more about the conceptual view, the abstract obects, than about representation/implementation issues
05:53:38 <ski> s/care/cares/
05:55:33 <ski> zincy_ : so, shall i continue now ?
05:55:42 <zincy_> ski: yes
05:55:45 <ski> ok
05:56:08 <ski> so, in the "basic understanding", we had this dichotomy between "things" ("at the value level")
05:56:28 <ggole> 1 becoming a different value if you refine its type is a strange idea
05:56:46 <ski> ggole : yes
05:58:29 <ski> ggole : one might say that it's not really that it's a different thing, but rather that the question whether it's the same or different is outlawed, is an illegal (illtyped) question. you can't ask the question whether two values, belonging two types, not known to be equal, whether those two values are equal or distinct
05:59:18 <ski> (how's that for making the issue even stranger ? ;)
05:59:37 <ski> zincy_ : anyway
05:59:42 <ggole> That's not true in general, though. It might be true of Haskell.
06:00:14 <ski> i'm not talking about Haskell
06:00:27 <ski> i'm talking about type theory. and also about category theory
06:01:33 <ski> it's not so much a matter of whether it's true or not, it's more a matter of which conceptual view of the world you have (and then about to which extent different such ontologies might be more or less useful)
06:02:09 <ski> (perhaps more useful in some contexts, and less in others, and vice versa for the other one)
06:03:05 <ski> (so, i was talking about Haskell only insofar it was influenced by those broader fields)
06:03:27 <ski> zincy_ : so
06:03:36 <ski> we had monomorphic things, being of a single form, being called values, having a type
06:03:52 <zincy_> ski: yep
06:04:20 <ski> and we had polymorphic things, being of multiple forms, being called pseudo-values, having a type schema. and we can specialize these, getting values
06:04:32 <Profpatsch> I have data TypeArg (sym :: Symbol) t = TypeArg
06:04:40 <ski> so, values are passed around at run-time, but not pseudo-values
06:04:48 <Profpatsch> And wanted to give a list of type args to my function, with different syms and ts.
06:05:19 <Profpatsch> So I tried  … -> (forall t sym. KnownSymbol sym => [TypeArg t sym]) -> …  (Rank2)
06:05:27 <ski> and every "thing" is either a monomorphic thing, a value, or a polymorphic thing, a pseudo-value
06:05:43 <Profpatsch> But that didn’t work, the compiler was unable to see the `KnownSymbol` constraint on the elements of the list.
06:05:52 <ski> Profpatsch : sounds like you're looking for something like `[exists sym t. TypeArg sym t]'
06:06:11 <Profpatsch> I added an existential wrapper GADT and now it works:
06:06:20 <ski> Profpatsch : what you expressed insists on it being the same `sym' and `t', for all the elements in the list
06:06:46 <Profpatsch> data TypeArgEx where TypeArgEx :: (KnownSymbol sym) => TypeArg sym t -> TypeArgEx
06:07:10 <Profpatsch> ski: Yeah, I thought so much. I tried putting the constraint in the list, bit “GHC doesn’t support impredicative types yet”
06:07:17 <ski> ok, so i should probably have said `[exists sym t. KnownSymbol sym *> TypeArg sym t]'
06:07:44 <ski> the `KnownSymbol sym' constraint has to be provided inside (and yes, i wrote `*>', i didn't mean to write `=>')
06:08:16 <Profpatsch> ski: Is there a better way than to create another wrapper GADT to capture the existental constraints?
06:08:25 <Profpatsch> Or is that the “way to go”?
06:08:45 <ski> hm, and the other problem is that you used `forall', when you wanted `exists'
06:09:20 <ski> yes the `ImpredicativeTypes' extension is broken
06:09:35 <Profpatsch> yeah, I know that in Haskell you have to encode exists in a non-intuitive manner.
06:09:38 <ski> (but you wanted `exists' anyway, not `forall')
06:09:46 <ski> yes (unfortunately)
06:10:09 <ski> i'm mentioning `exists' for a reason, to shield you from that, when thinking conceptually about what you want to express
06:11:07 <Profpatsch> I’m always confusing RankN and Existential, one gives the choice to the caller, the other gives it to the called.
06:11:14 <ski> there's two ways, basically, to encode `exists', in Haskell today : (a) using a `data' type with a data constructor which is polymorphic in a tyvar which doesn't occur in the result type; (b) using a CPS encoding
06:11:21 <ski> Profpatsch : yes
06:11:45 <ski> both encodings are good to know about, but they are useful in different situations
06:12:13 <Profpatsch> tbh I never had any reason to use RankN. It’s always existentials in the end.
06:12:21 <Profpatsch> I know about the ST use, but that’s about it.
06:12:42 <ski> do you intend to have this `[exists sym t. KnownSymbol sym *> TypeArg sym t]' as an input, or as an output ?
06:12:47 <Profpatsch> And that you can encode data types with RankN.
06:13:04 <Profpatsch> ski: The list is given by the user.
06:13:13 <ski> as input to the function ?
06:13:23 <Profpatsch> yeah
06:13:28 <ski> ok
06:13:51 <ski> yea, i think in this case you should do the "existential `data'" encoding (the (a) one)
06:14:22 <ski> (the only way to avoid that would be to not use normal lists, i think, e.g. Church-encoding the list type there)
06:15:21 <ski> Profpatsch : you can either make a new `data' type. or, perhaps, can use a generic one which you can pass `TypeArg' as a parameter to
06:16:20 <Profpatsch> ski: I think I could delete TypeArg alltogether and use Proxy instead.
06:16:21 <ski> Profpatsch : you don't have to express it using GADT syntax, you can also use the `ExistentialQuantification' (a misnomer) extension .. but possibly you'll find the former variant more intelligible
06:16:28 <ski> perhaps
06:16:58 <Profpatsch> Though that’s poly-kinded, so might lead to different inference problems again.
06:17:18 <ski> ("poly-kinded" is also a misnomer, imho :)
06:17:22 <Profpatsch> :)
06:17:23 * ski nods to Profpatsch
06:17:54 <zincy_> ski: where were we?
06:17:55 <ski> zincy_ : ok, where were we ?
06:18:03 * ski low fives zincy_
06:18:07 <zincy_> haha
06:18:25 <Profpatsch> ski: Thanks for the explanation!!
06:18:32 <ski> Profpatsch : np
06:18:44 <Profpatsch> haha, I hit ! twice, now I look like a light novel author.
06:19:04 <ski> <ski> we had monomorphic things, being of a single form, being called values, having a type
06:19:09 <ski> <ski> and we had polymorphic things, being of multiple forms, being called pseudo-values, having a type schema. and we can specialize these, getting values
06:19:15 <ski> <ski> so, values are passed around at run-time, but not pseudo-values
06:19:22 <ski> <ski> and every "thing" is either a monomorphic thing, a value, or a polymorphic thing, a pseudo-value
06:19:34 <zincy_> values have monomorphic types and pseudo-values have polymorphic types. Every value at runtime must be of monomorphic type and any identifying information of types is erased at runtime for performance reasons as it isnt needed.
06:19:49 <ski> no, sorry
06:20:06 <ski> this is another place where i disagree with some current practice
06:20:43 <ski> i don't agree with "pseudo-values have polymorphic types". and then "values have monomorphic types" doesn't really make sense in that comparision either
06:21:19 <ski> ignoring that issue, what you said seems ok
06:21:36 <ski> values have types. pseudo-values have type schemata
06:22:19 <zincy_> type schemas have polymorphic behaviour and give you back monomorphic types?
06:23:09 <ski> every value at run-time must be of some type, and any identifying information of types *may* be erased at run-time for performance reasons as it isn't needed to determine the observable end result (but may be needed for GC or data access, depending on how you represent your values)
06:23:30 <Profpatsch> ski: One more question:
06:23:32 <Profpatsch> typeArg :: forall sym t. (KnownSymbol sym, Interpret t) => TypeArgEx
06:23:34 <Profpatsch> typeArg = TypeArgEx (TypeArg :: TypeArg sym t)
06:23:42 <Profpatsch>     • Could not deduce (KnownSymbol sym0)
06:24:07 <Profpatsch> bound by the type signature for:
06:24:09 <Profpatsch>                    typeArg :: forall (sym :: Symbol) t.
06:24:11 <Profpatsch>                               (KnownSymbol sym, Interpret t) =>
06:24:21 <Profpatsch> Is it impossible to write that helper function?
06:24:30 <ski> type schemata are inhabited by pseudo-values, which are polymorphic things, are many-forms. when you specialize those to single-forms, those are monomorphic things, inhabit types
06:25:30 <ski> Profpatsch : did you turn on `ScopedTypeVariables' in that module ?
06:26:29 <mjrosenb> Does anyone have flycheck for haskell set up with nix?
06:26:31 <zincy_> so the definition for polymorphic function `reverse` is a pseudo-value inhabiting a type schema?
06:29:45 <Profpatsch> ski: yes
06:30:12 <ski> Profpatsch : hm, and `AllowAmbiguousTypes' ?
06:30:16 <Profpatsch> I get the feeling that KnownSymbol is specially handled in the compiler and not exhaustive.
06:30:37 <ski> Profpatsch : you possibly also will have use for `TypeApplications'
06:30:46 <Profpatsch> ski: That seems to work.
06:30:58 <ski> okay, good
06:31:27 <Profpatsch> I’d look it up in the GHC user manual, but the server throws 503s …
06:31:51 <ski> Profpatsch : instead of using type ascriptions like `TypeArg :: TypeArg sym t', you could possibly use `TypeArg @sym @t' (or something like that, i don't recall the signature of `TypeArg') (using `TypeApplications')
06:32:35 <ski> yes, i noticed it claims to be guru meditating, when i was looking up the spelling of `AllowAmbiguousTypes'
06:32:44 <ski> zincy_ : yes
06:33:06 <Profpatsch> Archive.org fixed it for me
06:33:18 <Profpatsch> Though I should have it offline somewhere.
06:34:26 <ski> zincy_ : also, you should note that "pseudo-value" is just a term i made up during this conversation, to be able to refer to this concept. it's not a term i've reserved for this purpose (apart from during this particular discussion), and it's certainly not a term that others use with this specific meaning, that i know of
06:35:20 <ski> (also, obviously, the "thing" part of "monomorphic thing" and "polymorphic thing". since i'm reserving "value" for the former, i can't also use "value" for both of them, hence i decided to use "thing" for the moment)
06:35:41 <mjrosenb> hrm, what happened to Distribuion.PackageDescription.benchmarkEnabled?
06:35:52 <mjrosenb> that appears to be why I can't use flycheck mode.
06:36:36 <ski> Profpatsch : anyway, you needed `AllowAmbiguousTypes' because you have tyvars in your signature which only occur in the `forall' part, and in the constraints, but not in the remaining part (the "ordinary type" part)
06:37:29 <zincy_> ski: So just an unusually nuanced distinction between what most would just say two values
06:38:59 <ski> yes
06:39:20 <ski> and i'm making this distinction because you can't pass the pseudo-values around at run-time
06:39:38 <ski> zincy_ : so .. continue ?
06:40:11 <zincy_> yeah
06:40:24 <ski> ok, i'll start contradicting myself, now ;)
06:41:09 <ski> so, in the "broader understanding" (but not in the "basic understanding") you *can* pass around "pseudo-values" / "polymorphic things", at run-time !
06:41:30 <ski> from now on, i'll call them "polymorphic values"
06:42:51 <zincy_> remind me on the distinction between the understandings again?
06:43:13 <ski> well, that's what i'm trying to explain at the moment
06:43:37 <ski> also, there is no longer a simple dichotomy between "monomorphic things" (each having a single type, those types can of course look quite different from each others. e.g. function types, list types, tuple types, &c.) and "polymorphic things" (each having many types)
06:44:05 <Profpatsch> Though I should have it offline somewhere.
06:44:09 <Profpatsch> whoops
06:44:18 <zincy_> ski: ok
06:44:21 <ski> instead "polymorphic values" now are to be considered to have a distinct shape/form of type, distinct from function types, tuple types, &c.
06:44:33 <ski> so, the first step is revisiting our `reverse'
06:45:08 <ski> we had expressed that, for each type `a', `reverse' *can* be used as having type `[a] -> [a]' as :
06:45:11 <ski>   forall a.
06:45:17 <ski>     reverse :: [a] -> [a]
06:45:55 <ski> (and that's pseudo-Haskell, because you can't put a `forall' there. this is just a logical description of the "basic understanding" view)
06:46:06 <zincy_> gotcha
06:46:09 <ski> now, we will claim
06:46:16 <ski>   reverse :: forall a. [a] -> [a]
06:46:25 <ski> now `reverse' is a value, like other values
06:46:37 <ski> strictly speaking, `reverse' is a "polymorphic value", not a function
06:47:03 <ski> so, there are different types of values : polymorphic values, functions, lists, tuples, &c.
06:47:36 <ski> instead of distinguishing polymorphic from monomorphic, and then subdividing monomorphic into classes of values having different types
06:47:55 <ski> we're now placing "polymorphic" alongside all the other classes like "functions", "lists", "tuples", &c.
06:48:22 <zincy_> So have we grouped them all into just types?
06:48:42 <ski> yes. a function is a value whose type looks like `... -> ...'
06:49:03 <zincy_> Interesting so back to how I used to think of functions
06:49:11 <ski> a tuple is a value whose type looks like `(...,...,...,... ... ...,...)'
06:49:25 <ski> a list is a value whose type looks like `[...]'
06:50:55 <zincy_> Is "union of types" a thing?
06:51:15 <zincy_> Polymorphic values conjure that phrase for me
06:51:34 <ggole> Some type systems have a concept of union
06:52:04 <ski> a polymorphic value is a value whose type looks like `forall a. ..a..'
06:52:19 <ski> (obviously the bound tyvar doesn't have to be named `a' in particular ..)
06:53:05 <ski> zincy_ : so, if it's a polymorphic value, its type *starts* with a `forall'. and if its type starts with a `forall', then its a polymorphic value
06:55:22 <ski> zincy_ : i think "intersection" could be more appropriate an image than "union" .. at least if understood at the value level. in one sense, `Nothing' belongs to all of `Maybe Integer',`Maybe Bool',&c., and so it is in the intersection of those types. therefore it (or something corresponding to it) is in the type `forall a. Maybe a'
06:56:10 <ski> zincy_ : but that's using the "values before types" notion, rather than the "types before (or at the same time as) values" notion, both of which i mentioned briefly before
06:56:23 <ski> ggole ^
06:56:24 <zincy_> Yeah understood :)
06:56:45 <ski> zincy_ : so
06:56:48 <zincy_> " so, if it's a polymorphic value, its type *starts* with a `forall'. and if its type starts with a `forall', then its a polymorphic value"
06:56:48 <ski> when we write
06:56:56 <zincy_> isnt that just the same thing said in reverse?
06:57:15 <ski> zincy_ : yes. the point is that it goes in both directions
06:57:21 <zincy_> right
06:57:48 <ski> zincy_ : polymorphic values has types which starts with `forall'. and *only* polymorphic values has types which starts with `forall'
06:58:15 <ski> anyway, when we write
06:58:17 <ski>   reverse :: [a] -> [a]
06:58:24 <ski> we must understand this as really meaning
06:58:28 <ski>   reverse :: forall a. [a] -> [a]
06:59:19 <ski> specifically, in a type *signature* (with a `::'), we insert a `forall', that binds the tyvars mentioned in the remainder of the signature
06:59:40 <ski> being able to omit the `forall' here is just a convenience. strictly speaking, we should always spell it out
06:59:47 <zincy_> so it is essentially a type variable binding - forall?
06:59:56 <ski> (and, iiuc, purescript requires you to always spell it out)
07:00:04 <ski> yes, `forall' is binding the tyvars
07:00:48 <ski> and it's the presence of the `forall' (whether written explicitly, or inferred implicitly) that signifies the value is polymorphic : *not* the presence of type variables in the type !
07:01:24 <ski> also, it's important to note that this disambiguation rule for making an implicit `forall' explicit *only* applies directly after the `::' in a type signature
07:01:25 <zincy_> are there cases in Haskell where you have type variables and no forall?
07:01:31 <ski> e.g. if we write
07:01:41 <ski> zincy_ : yes, i'll come to that
07:01:46 <ski>   length :: [a] -> Int
07:02:08 <ski> then one might argue : well `[a]' really means `forall a. [a]', and therefore we have
07:02:16 <ski>   length :: (forall a. [a]) -> Int
07:02:26 <ski> or, one might argue : well `a' really means `forall a. a', and therefore we have
07:02:32 <ski>   length :: [forall a. a] -> Int
07:02:39 <ski> but both of these are incorrect !
07:03:12 <ski> we can't explicate implicit `forall' just anywhere. they're only inserted directly after the `::' in a type signature
07:03:19 <ski> so, the correct explication is
07:03:27 <ski>   length :: forall a. ([a] -> Int)
07:03:32 <ski> which is the same thing as
07:03:35 <ski>   length :: forall a. [a] -> Int
07:04:09 <zincy_> Is the reason it needs to be at the beginning because we could have multiple `a`s in the type sig?
07:04:22 <zincy_> So you can only bind `a` once
07:04:45 <ski> this explication only applies to type signatures of _polymorphic values_
07:04:57 <ski> if the type doesn't start with a `forall', then it's not a polymorphic value
07:05:23 <ski> <zincy_> Is the reason it needs to be at the beginning because we could have multiple `a`s in the type sig?
07:05:49 <ski> partly that, but more importantly that the exact placement of the `forall' can change the whole meaning of the type *drastically*
07:05:50 <mjrosenb> zincy_: no, it is because if you put them elsewhere, typechecking becomes much harder.
07:06:08 <ski> (as in behaving in one way, or in the "opposite" way. no small matter)
07:06:13 <zincy_> I see
07:06:56 * ski . o O ( "The Place of the Word / of the Lord / Must be Truly Understood" )
07:07:32 <ski> anyway, i should mention a couple of exceptions to the explication rule for `forall' above
07:08:14 <ski> and remember, this rule is nothing deep, it's just a matter of convenience, of not having to spell out all `forall's, and also of backward compatibility with code from before the `forall' keyword extension existed
07:08:29 <ski> and also to not force this more advanced understanding immediately on beginners
07:08:42 <ski> consider
07:08:51 <ski>   class Eq a
07:08:53 <ski>     where
07:09:01 <ski>     (==) :: a -> a -> Bool
07:09:16 <ski> the question here is whether this signature really means
07:09:20 <ski>     (==) :: forall a. a -> a -> Bool
07:09:41 <ski> and the answer is : no, because `a' is already in scope, is bound in the class head `Eq a'
07:09:49 <ski> zincy_ : okay ?
07:09:55 <zincy_> yep
07:10:30 <ski> so, `(==)', *as* a *method* of `Eq', is a *monomorphic* method (meaning it's not a polymorphic value) !
07:11:01 <ski> however, if we consider it, not as a method of `Eq', but as "just another polymorphic operation, with type class constraints", then its signature is
07:11:10 <ski>   (==) :: Eq a => a -> a -> Bool
07:11:18 <ski> and *then*, *this* really means
07:11:22 <ski>   (==) :: forall a. Eq a => a -> a -> Bool
07:12:21 <zincy_> So as a method it is monomorphic because the typeclass parameter a is applied for an instance?
07:12:23 <ski> in the first case, we're considering `(==)' as something that's inside the `Eq' class (and which we can give an implementation for, when we make an instance of the type class). in the second case, we're considering it as "just another operation, which we can use/call"
07:12:27 <ski> yes
07:12:33 <zincy_> nice!
07:12:33 <ski> if you're making an instance
07:12:39 <ski>   instance Eq Bool
07:12:40 <ski>     where
07:12:46 <ski>     False == False = True
07:12:53 <ski>     True  == True  = True
07:13:10 <ski>     _     == _     = False
07:13:20 <ski> then you're *not* giving an implementation of
07:13:25 <ski>   (==) :: forall a. Eq a => a -> a -> Bool
07:13:34 <ski> instead you're required to give an implementation of
07:13:36 <zincy_> aha
07:13:47 <ski>   (==) :: Bool -> Bool -> Bool
07:14:27 <ski> so, when we say that it is a monomorphic *method*, we mean that, *given* specific types for the parameters in the type class head, it will become a monomorphic value
07:14:35 <ski> however, now compare with
07:14:40 <ski>   class Functor f
07:14:41 <ski>     where
07:14:49 <ski>     fmap :: (a -> b) -> f a -> f b
07:14:55 <ski> now, this signature here really means
07:15:01 <ski>     fmap :: forall a b. (a -> b) -> f a -> f b
07:15:10 <ski> and so `fmap' is a *polymorphic* method
07:16:00 <zincy_> So when a type variable is bound explicitly forall. it is always polymorphic. But if not explicated then not necessarily polymorphic?
07:16:05 <ski> if we make an instance of `Functor Maybe', then we have to implement `fmap :: forall a b. (a -> b) -> Maybe a -> Maybe b', so we have to implement a polymorphic value, working for all possible choices of `a' and `b' that the caller wants to pick/choose
07:16:41 <zincy_> right because Functor is a single parameter type class
07:16:47 <ski> "is it always polymorphic", it's not the tyvar which is polymorphic, but the corresponding value, having the whole type, which is polymorphic (in the tyvar)
07:16:57 <ski> but ignoring that, yes
07:17:25 <ski> the parameter tyvars in a type class are picked by whomever makes an instance of the type class
07:17:27 <zincy_> corresponding value here being the typeclass method in question?
07:18:08 <zincy_> sorry I need to go now. But look forward to continuing when I am back
07:18:29 <zincy_> Thanks so so much for the explanation! Very enlightening.
07:18:46 <ski> the tyvars bound by a `forall' in the signature of polymorphic methods (just as for ordinary polymorphic operations not in a type class) are ones that are picked/chosen by whomever calls the method (or operation)
07:18:59 <ski> okay
07:19:13 <ski> zincy_ : do you have any inkling of when you might be back ?
07:19:30 <machinedgod> argh my stepson is driving me nuts :-D
07:19:55 <machinedgod> Argh, sorry, wrong channel, AGAIN :-(((
07:20:02 <zincy_> Sometime early evening UTC time. Does that work?
07:20:36 <zincy_> say 7pm ish UTC.
07:20:55 <ski> hm, would that be in three and a half hour or so ?
07:21:20 <ski> (very approx.)
07:21:39 * ski tries to recall whether they're before or after UTC
07:21:55 <zincy_> Basically 3 hours from now.
07:21:55 <ski> @localtime lambdabot
07:21:55 <lambdabot> I live on the internet, do you expect me to have a local time?
07:22:15 <ski> zincy_ : ok
07:22:43 <zincy_> Cool speak later
07:27:19 <talqu> hi, https://pastebin.com/G2G49HZS. `return $ applyCookies NoContent` branch executes when i log in, I can the see 204 No Content in chrome dev tools. However protected api routes do not as it does not not `protectedApi (Servant.Auth.Server.Authenticated _) `. I neither can see any cookie stored in local storage in chrome tools, after getting 204 response. What am doing wrong here?
07:28:56 <talqu> *However protected api routes do not work as it does not match `protectedApi (Servant.Auth.Server.Authenticated _) ` which means I dont get the Authenticated request for reason.
07:51:30 <PragCypher> anyone know what a common type class is for converting to and from Text?  From what I understand, show + read should be for debugging
07:52:52 <FriCho> hello
07:55:47 <ski> PragCypher : you know you can convert between `String' and `Text' ?
07:56:17 <PragCypher> ski: I mean like a data record type <-> Text
07:56:30 * ski doesn't understand
07:57:32 <ski> what i'm saying is : it is possible to use the `Show' and `Read' classes to convert to/from `String', and then to convert from/to that `String', to/from `Text'
07:58:28 <PragCypher> ski: ok thanks, I did a web search for this though, and someone was saying that Read /Show should be used for debugging
07:58:31 <ski> PragCypher : so, the real question is : for what purpose do you want to convert to/from `Text' ? for debugging purposes ? for pretty-printing ? something else ?
07:58:37 <ski> yes, that's correct
07:58:53 <PragCypher> for pretty printing, list a ToText version of ToJSON
07:59:04 <ski> but you haven't said whether you want it for debugging, or for some other purpose
07:59:24 <ski> mhm
07:59:32 <PragCypher> for other purposes, like pretty printing
07:59:50 <ski> so, i've heard people say that there are some such classes, in some packages
07:59:56 <ski> i dunno which, i haven't used them
08:00:10 <ski> i'm not sure if there is any particularly standard such type class
08:00:29 <ski> perhaps you'd be best off (?) by making your own type clas ?
08:01:02 <ski> or, if you don't need to be polymorphic in the type to pretty-print, then you don't even need a type class
08:02:09 <PragCypher> I think I'll try the custom type class, then migrate to a more command one when I come across it
08:02:11 <ski> (`Read' and `Show' could also be used for a simplistic serialization/marshalling format .. but if you want to use a custom printing format which doesn't conform to Haskell syntax, then you should, imho, *not*, use `Show' / `Read')
08:02:13 <PragCypher> thanks @ski
08:03:30 <ski> (so it's more that `Show' and `Read' are intended to operate on valid Haskell syntax, than them necessarily being intended only for debugging. still, the two are closely related)
08:04:42 <iqubic> > show (read 5)
08:04:44 <lambdabot>  error:
08:04:44 <lambdabot>      • No instance for (Num String) arising from the literal ‘5’
08:04:44 <lambdabot>      • In the first argument of ‘read’, namely ‘5’
08:04:59 <Solonarv> iqubic: you got them backwards :>
08:05:18 <iqubic> > read (show 5)
08:05:21 <lambdabot>  *Exception: Prelude.read: no parse
08:05:32 <iqubic> Huh?
08:05:44 <iqubic> > show (read "5")
08:05:46 <lambdabot>  "*Exception: Prelude.read: no parse
08:05:48 <Solonarv> iqubic: the type for 'read' is ambiguous there
08:06:03 <iqubic> Yes. I know. That's the sort of thing that pisses me off.
08:06:14 <Solonarv> ghci (and lambdabot too, I guess) have more aggressive defaulting rules, so the type defaults to ()
08:06:18 <ski> @hackage prettyprinter
08:06:18 <lambdabot> http://hackage.haskell.org/package/prettyprinter
08:06:27 <ski> i wonder how well that package works
08:06:29 <iqubic> > read (show @Int 5)
08:06:31 <ski> PragCypher ^
08:06:32 <lambdabot>  error:
08:06:32 <lambdabot>      Pattern syntax in expression context: show@Int
08:06:32 <lambdabot>      Did you mean to enable TypeApplications?
08:06:33 <Solonarv> > show (read "5" :: Int)
08:06:35 <lambdabot>  "5"
08:06:54 <Solonarv> % read (show @Int 5) -- won't work
08:06:55 <yahb> Solonarv: *** Exception: Prelude.read: no parse
08:07:05 <iqubic> Why doesn't that work?
08:07:06 <Solonarv> the type for *read* is ambiguous and defaults to ()
08:07:25 <Solonarv> instantiating show @Int doesn't change the type of read
08:07:30 <Solonarv> % read @Int (show 5)
08:07:30 <yahb> Solonarv: 5
08:07:39 <iqubic> Right. I see.
08:07:52 <Solonarv> note: the type of '5' there is also ambiguous, but defaults to Integer, which is sensible
08:13:05 <PragCypher> thanks @ski
08:15:35 <ski> PragCypher : fwiw, it's not IRC custom to prepend nicknames with sigils like `@', when addressing or mentioning them. simply mention the nickname (anywhere, or e.g. at the start of the message, followed by a comma or a colon, if you want to specifically address someone)
08:16:19 <ski> (also, on IRC, `@' together with a nickname means that they currently have operator status on a channel .. which is probably not what you meant to imply)
08:17:33 <hpc> lines starting with @ trigger bot commands as well, which is spammy
08:17:47 * ski nods
08:18:29 <Solonarv> @hpc: thanks for clarifying :>
08:18:30 <lambdabot> Unknown command, try @list
08:18:46 <mpickering> What happens to files in the `c-sources` section of a cabal file when you load ghci? How does it affect the options passed to ghci
08:22:37 <Solonarv> mpickering: I'm not sure, but you could probably find out by doing 'cabal v2-repl -vvv' 
08:22:46 <Solonarv> to make cabal output the commands it's running
08:23:01 <mpickering> ok, do you know any simple projects with a c-sources field then?
08:23:26 <Solonarv> I don't, I thought you had one and were wondering what happened thee
08:23:34 <mpickering> well I do
08:23:36 <mpickering> but it's called ghc
08:23:55 <mpickering> so the ghci target is not managed by cabal
08:24:00 <Solonarv> hm, that is a bit too large :>
08:24:34 <hpc> https://hackage.haskell.org/package/hsyslog is pretty simple and has c files
08:24:35 <mpickering> and I'm trying to fix the ghci target so that it works, but it is broken on the c-sources bit
08:24:50 <Solonarv> ah, bytestring seems to have some C bits as well
08:25:44 <hpc> bytestring is probably a better point of reference
08:26:35 <mpickering> It seems that cabal passes the .o files on the command line after the list of modules
08:27:36 <avn> Hello! Guys, can you suggest me good examples of usage of Divisible/Decidable (of bifunctors)?
08:27:46 <mpickering> now I need to work out what hadrian does with these files
08:44:22 <freeside> in a State monad, i have a case x testing an input value. in some case i want to noop -- so i've been saying case (Dontcare _) -> modify id
08:44:42 <freeside> is there a better way to achieve a noop than "modify id"? that seems undesirable
08:44:45 <ski> you can use `return ()' or `pure ()' instead
08:44:52 <freeside> thanks
08:45:03 <ski> also, you don't need brackets around `Dontcare _'
08:45:08 <freeside> gotcha
08:45:23 <freeside> it seems weird that i'm allowed to return () because () isn't the type of my state val
08:45:28 <ski> i have sometimes defined `done = return ()'
08:45:35 <ski> @type modify
08:45:37 <lambdabot> MonadState s m => (s -> s) -> m ()
08:45:49 <ski> see the monadic return type there ? it's `()'
08:46:07 <freeside> but that's quietly different to the rest of my state monad which is State MyState MyVal
08:46:14 <ski> `modify' doesn't yield the state (either before or after the modification). it just modifies the state
08:46:39 <ski> `State MyState MyVal' is not your state monad. `State MyState' is your (state) monad
08:46:59 <freeside> ah
08:47:05 <ski> `MyVal' is just some particular monadic result type of some action of type `State MyState MyVal'
08:47:22 <ski> another `State MyVal'-action can have a different monadic result type
08:47:30 <ski> and still be using the same monad
08:47:38 <freeside> so i can sling the State MyState around different computations which could produce MyVal1, MyVal2, MyVal3
08:47:49 <freeside> hmm, this is making more sense, thank you.
08:48:00 <ski> i wouldn't say "sling .. around different computations", but yes
08:48:26 <ski> the computations here would be the values (the actions) of type `State MyState MyVal1',`State MyState MyVal2',`State MyState MyVal3'
08:48:28 <freeside> i see what the second example at https://wiki.haskell.org/State_Monad is trying to illustrate now
08:50:03 <ski> (it's not that you have computations of values of types `MyVal1',`MyVal2',`MyVal3', that you "sling `State MyState' around .. the computations (of types `State MyState MyVal1',&c.) inherently (in the general case) involve the "monadic effect" part, which is the `State MyState' part)
08:50:52 <freeside> i see. so, in the same way that a Maybe Int is a Maybe monad wrapping Ints, a State MyState Int is a State MyState monad wrapping Ints.
08:51:08 <ski> (the case where they don't involve the monad is the `return'/`pure' case)
08:51:36 <ski> not "a Maybe monad wrapping Ints". `Maybe' itself (the type) is the monad
08:51:52 <ski> a monad is not something you can pass around at run-time
08:52:09 <freeside> is there an idiomatic way to say i want to deal only with one particular case of a sum type, and ignore the other cases? so far i have been doing case x of Constructor foo -> ..., _ -> return ()
08:52:18 <ski> so it should be "the `Maybe' monad", not "a `Maybe' monad"
08:52:41 <ski> and "wrapping Ints" is also wrong, since it sounds like you're thinking of something wrapping particular *values* of type `Int'
08:52:58 <freeside> you can tell i have been reading burrito tutorials!
08:53:09 <ski> while what really happens there is that `Maybe' itself (the type) is "wrapping" `Int' itself (the type), getting `Maybe Int'
08:53:19 <erisco> How is ski?
08:53:24 <ski> and then we have not spoken about values (actions) of this type, at *all* !
08:53:35 <ski> erisco : i'm ok, ty :)
08:54:05 <talqu> i was missing for servant auth server to work on localhost, cookieIsSecure = NotSecure. gosh i hate these kind of things :)
08:54:09 <freeside> i am rearranging my mental models. thank you.
08:54:11 <Solonarv> freeside: that seems pretty idiomatic to me
08:54:26 <erisco> freeside, is that a Discord startup message?
08:54:41 <freeside> that's me actually rearranging my mental models.
08:54:44 <freeside> i hope it sticks this time.
08:54:55 <Solonarv> erisco: it probably could be
08:55:15 <ski> freeside : i suppose you could define a helper `fromConstructor :: Blah -> Maybe Foo; fromConstructor (Constructor foo) = Just foo; fromConstructor _ = Nothing', and then you could use `forM_'/`traverse_' to do something on `foo', if there is any there
08:55:22 <erisco> Hrm, we should put together a new client called  λchat  solely for the purpose of clever startup messages
08:56:40 <ski> freeside : similarly, "a State MyState Int is a State MyState monad wrapping Ints" is wrong
08:56:56 <freeside> mm
08:57:18 <erisco> differently correct
08:57:26 <freeside> almost right
08:57:29 <ski> freeside : by "a State MyState Int" i assume you mean a value of type `State MyState Int' (such a value is an action, a `State MyState'-action specifically). and such a value can't be claimed to be "a State MyState monad wrapping Ints" -- remember, monads aren't run-time things
08:58:24 <ski> freeside : a monadic action (like such a value just decribed) isn't somehow "a monad wrapping something". that action/value doesn't have a "monad part". it's the *type* of it that has a "monad part"
08:58:28 <freeside> it seemed grammatically correct to say "a List of Int" but grammatically weird to say "a State MyState of Int"
09:00:23 <erisco> An Int under state MyState? *shrug*
09:00:24 <ski> you can say "a list of `Int's", but not "a list of `Int'" (unless perhaps you're talking about type-level programming, which i doubt)
09:01:08 <ski> similarly, saying "the function `Integer -> Bool'" is wrong. `Integer -> Bool' isn't a function, it's the *type* of some functions
09:01:19 <freeside> mmm
09:01:49 <ski> saying "a function in `Integer -> Bool'" or "an `Integer -> Bool' function" is ok, if you want to avoid the more verbose "a function of type `Integer -> Bool'"
09:01:54 <erisco> "the `Integer -> Bool` function" is cromulent but "the function `Integer -> Bool`" isn't :s
09:02:05 <DigitalKiwi>  Solonarv i eventually got something that had the behaviro of what you two were saying but there's a problem it works globally not per post (which is what i wanted but maybe didn't explain well) so whatever i implemented will hide it if there are NO tags in any post, but if there are any posts with tags it doesn't hide on the posts without tags
09:03:00 <ski> (yeah. similarly one should not confuse "function type" with "type function", or "tuple type" with "type tuple", "list type" with "type list", and so on ..)
09:03:30 <erisco> that took my head for a spin ski
09:04:03 <freeside> a murder of crows, a kindness of types.
09:04:11 <ski> freeside : instead of "a State MyState of Int", you could say "a `State MyState'-action with `Int' result". or simply "a `State MyState Int'"
09:04:42 <ski> @remember freeside a murder of crows, a kindness of types.
09:04:43 <lambdabot> It is forever etched in my memory.
09:04:52 <lavalike> that's lovely
09:04:59 <freeside> whoa, i just discovered it's "an unkindness of ravens"
09:05:31 <erisco> apparently there is a biologist out there who really dislikes birds
09:05:52 <erisco> zoologist? I dunno
09:07:18 <ski> freeside : anyway .. does this help ?
09:07:42 <freeside> yes, it helps very much, thank you.
09:08:33 <ski> np
09:08:34 <freeside> it also lays to rest a question i had been timorously carrying through my coding, which is whether it is proper to shove all my return values into the MyVal part, or if I was supposed to work with functions of some sort of Input -> State MyState MyVal -> MoreVals
09:09:09 <ski> not sure i understand that
09:10:12 <Solonarv> the core function of Monad is '(>>=) :: State MyState a -> (a -> State MyState b) -> State MyState b'
09:10:20 <Solonarv> (specialized to your particular monad, that is)
09:10:25 <erisco> usually you have  Input -> State MyState Output
09:10:32 <Solonarv> note that the last type parameter varies!
09:11:22 <erisco> which unpacks to   Input -> MyState -> (Output, MyState)
09:11:27 <freeside> right. which is why makes sense to have my 'somefunc input = do ..." operating in the State monad. and I was wondering if one ever says something like someFunc input stateThing = ... where someFunc :: Input -> State MyState MyVal -> ActualReturnValue
09:11:37 <erisco> so,  MyState  is part of the input and output!
09:11:39 <ski> @unmtl State MyState Output
09:11:39 <lambdabot> MyState -> (Output, MyState)
09:11:48 <freeside> Solonarv: yes, ski just walked me through how the MyVal can vary
09:12:25 <freeside> this conversation has taught me that if i want to start returning more things, i should shove all those things into the MyVal.
09:12:30 <ski> freeside : Solonarv was merely reinforcing that, and showing it more explicitly in the signature of `(>>=)'
09:12:31 <erisco> well there are some functions which turn one State into another State, say by changing the state type
09:12:46 <erisco> in which case you will take some State as a parameter
09:13:01 <erisco> or an easy example is  fmap
09:13:16 <ski> freeside : "I was wondering if one ever says something like someFunc input stateThing = ... where someFunc :: Input -> State MyState MyVal -> ActualReturnValue" -- yes, but not so often
09:13:57 <erisco> I have situation where I do this usefully (though for Reader, which is half a State), where I add information to the input as I recursively descend
09:14:05 <ski> freeside : and it quite possibly wouldn't be `somefunc input act = do ...' then (with a `do'), unless `ActualReturnValue' is `M T', for some monad `M'
09:15:06 <ski> freeside : basically, you see this happening with "run functions", like e.g. `runState :: State s a -> s -> (a,s)',`execState :: State s a -> s -> s',`evalState :: State s a -> s -> a'
09:17:14 <ski> freeside : but also, sometimes you need to take an action as an argument, e.g. `forkIO :: IO () -> IO ThreadId', or `local :: MonadReader r m => (r -> r) -> m a -> m a', or `replicateM :: Monad m => Int -> m a -> m [a]'
09:17:48 <ski> (well, apparently it's `Applicative' now ..)
09:18:55 <freeside> mmmhm.
09:20:17 <freeside> Solonarv showed me how to use "traverse" to turn a simple function into a stateful function. it looked to me like mapM had roughly the same type; could i use that as well?
09:20:31 <Solonarv> yes, they're the same thing
09:20:33 <sarahzrf> traverse and mapM do the same thing
09:20:43 <sarahzrf> they both exist for historical reasons
09:20:43 <freeside> by "simple function" i mean it operates on a single a -> a, and traverse gets me to [a] -> [a]
09:20:49 <ski> but you wouldn't say `foo :: ... -> State MyState MyVal0 -> StateMyState MyVal1' if you could just as well execute your action of type `State MyState MyVal0' before calling `foo', and then pass the resulting `MyVal0' value to `foo', whose signature is now changed to `foo :: ... -> MyVal0 -> StateMyState MyVal1'
09:20:55 <ski> freeside ^
09:21:01 <sarahzrf> technically they can do different things if your Applicative instance does something different from your Monad instance, iirc
09:21:02 <Solonarv> mapM just has a Monad constraint instead of Applicative, which almost never matters
09:21:03 <sarahzrf> but you shouldnt be doing that
09:21:31 <ski> freeside : actually, they operate on `a -> m b', and gives you `[a] -> m [b]'
09:21:36 <freeside> right
09:22:01 <ski> freeside : this allows your callback function to perform effects. `m'-effects, specifically
09:23:30 <freeside> i was thinking through the steps, and i was mystified by how the state gets correctly passed as the traverse walks through (in my case) the `[a]' part of `[a] -> m [b]'
09:25:18 <freeside> evalState (traverse mycallback inputs) is so magic
09:25:34 <freeside> i just need to break it all down into component parts to see how it works.
09:27:00 <sarahzrf> freeside: :)
09:27:02 <sarahzrf> it really is
09:28:16 <sarahzrf> it's a great showcase of how the F/A/M hierarchy is indeed an excellent interface for manipulation of "effects"
09:28:29 <freeside> mmm. i'm looking at the definitions, http://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Traversable.html#traverse
09:28:50 <sarahzrf> well... actually, there are problems that crop up later once you start wanting to mix and match different kinds of effects
09:29:11 <sarahzrf> well, that may not be an issue of F/A/M so much as other parts of the language - nvm
09:29:39 <freeside> wow, `traverse f = sequenceA . fmap f', but then `sequenceA = traverse id'
09:29:40 <talqu> How do I redirect after successful login instead of 'return $ applyCookies NoContent'. I found people using `throwError $ err301 { errHeaders = [("Location", "https://haskell.org/")] }`. Is this still the way to do this?
09:30:09 <freeside> badge unlocked: multiple recursion
09:31:02 <sarahzrf> freeside: haha
09:31:11 <sarahzrf> the idea is that an instance may define either one, or both
09:31:14 <sarahzrf> then the other comes for free
09:31:34 <sarahzrf> it's like how in Eq, you can define just (==), and then (/=) has a default definition
09:31:42 <sarahzrf> what you want to look at is the instance for lists
09:31:45 <ski> freeside : "mutual recursion" :)
09:33:33 <Solonarv> freeside: they're not actually mutually recursive - that would just be an infinite loop doing nothing useful
09:33:55 <Solonarv> as sarahzrf already said, the point is that when writing a Traversable instance you only need to define one of them
09:36:25 <freeside> oh. right then.
09:36:47 <freeside> when i worked through the purple haskellbook.com i did do all the derivation exercises in each chapter, but that was two years ago.
09:37:13 <sarahzrf> lol
09:37:25 <freeside> entertainingly, mutual recursion and co-recursion are not the same thing
09:37:57 <sarahzrf> freeside: they can be, if u have mutual corecursion
09:38:06 <freeside> naturally
09:38:46 <ski> they would be mutually recursive, if you defined neither, iow used the default implementation for both (and that would be useless, yes)
09:40:21 <ski> but since overriding a default implementation achieves "open recursion", then the other one (the default implementation) will call your definition (which overrode a default implementation), and everything will (hopefully) be just dandy
09:52:48 <ski> @let extendM2_0 :: Monad m => (a -> m b -> m c) -> (m a -> m b -> m c); extendM2_0 = flip . ((=<<) .) . flip
09:52:50 <lambdabot>  Defined.
09:53:02 <ski> @type extendM2_0 fmap  -- `ap',`(<*>)'
09:53:03 <lambdabot> Monad m => m (a -> c) -> m a -> m c
09:53:26 <ski> @let strength :: Functor f => f (a -> b) -> a -> f b; strength = (. flip ($)) . flip (<$>)
09:53:28 <lambdabot>  Defined.
09:53:46 <ski> @type (=<<) . strength  -- `(<**>)'
09:53:48 <lambdabot> Monad m => m (a -> b) -> m a -> m b
09:54:04 <ski> oh, sorry, of course it's better to do
09:54:06 <ski> @undefine
09:54:07 <lambdabot> Undefined.
09:54:21 <ski> @let extendM2_0 :: Monad m => (a -> b -> m c) -> (m a -> b -> m c); extendM2_0 = flip . ((=<<) .) . flip
09:54:23 <lambdabot>  Defined.
09:55:30 <sarahzrf> the fuck u doin
09:55:43 <ski> @let extendM2_1 :: Monad m => (a -> b -> m c) -> (a -> m b -> m c); extendM2_1 = ((=<<) .)
09:55:44 <lambdabot>  Defined.
09:56:33 <ski> well, the other day i recall thinking that perhaps `(<*>)' ought to execute its arguments in the opposite order
09:56:58 <ski> and i was attempting to remember why i was thinking that, attempting to recreate the argument
09:57:40 <MarcelineVQ> ski: probably not related but have you seen https://www.staff.ncl.ac.uk/andrey.mokhov/selective-functors.pdf ?
09:57:44 <ski> hm, or maybe it was regarding `ap' -- i don't recall exactly
09:59:25 <ski> MarcelineVQ : ah, interesting :) the "independent effects" vs. "dependent effects" distinction there appears to be the same as the "static sequencing" vs. "dynamic sequencing" distinction terminology that i've been using
10:03:33 <ski> MarcelineVQ : oh, and that `select :: Selective f => f (Either a b) -> f (a -> b) -> f b' reminds me of an abstraction `eitherA :: ApplicativeChoice i => i (a -> o) -> i (b -> o) -> i (Either a b -> o)' that i've been thinking about occasionally on here, over some span of years
10:03:43 <MarcelineVQ> That sort of subject is interesting to me. I read one time that Applicative parsers are as strong as Monadic parsers if you generate a parser for every possible structure. I can't recall where I read that to cite it though.
10:05:03 <erisco> yes but that is also the rub, because it is really inefficient :P
10:05:05 <MarcelineVQ> Seems reasonable though, in that context-free becomes contextual if you have defined the whole context, those are my own words though so probably wrong :>
10:05:55 <erisco> a -> MyParser b  is just building a parser from a parameter, so you can alternatively just enumerate every parser constructible that way
10:06:16 <ski> erisco : if you can enumerate `a' ?
10:06:55 <erisco> doesn't have to be finite
10:06:59 <ski> MarcelineVQ : hm, i don't follow. care to elaborate ?
10:07:14 <ski> erisco : yes, but some infinite types can't be enumerated
10:07:34 <erisco> I am guessing the claim goes into a more sophisticated argument about that
10:07:49 <erisco> what sort of type could you use to usefully construct a parser that cannot be enumerated?
10:08:09 <ski> i dunno. i haven't seen the argument that MarcelineVQ was talking about
10:08:35 <ski> (also, i'm not sure what you mean by "a parser that cannot be enumerated" ?)
10:08:37 <MarcelineVQ> I'm probably just using context-free wrong as terminology
10:08:38 <erisco> practically speaking I have only seen things which could be enumerated, however impractical
10:09:08 <ski> you can't enumerate `Integer -> Integer'
10:09:24 <ski> or even `Integer -> Bool'
10:09:35 <erisco> no but what do either of those do for a parser
10:09:36 <ski> (Cantor's theorem)
10:09:58 <ski> i dunno, perhaps you want a parser which computes such a function/predicate as result ?
10:10:15 <erisco> the result doesn't have anything to do with the grammar accepted though
10:10:16 <ski> some kind of point-free predicate language which you're parsing, perhaps
10:12:15 <erisco> example… lets say indexed grammars, which can be done with a Monad parser, because you can take the length of the result and construct the next parser from that
10:12:41 * ski doesn't know the term "indexed grammar" .. but ok
10:12:53 <erisco> the alternative is to just enumerate parsers for all the possible indexes :P
10:13:15 <erisco> that's like  a^i b^i c^i
10:13:22 <erisco> abc, aabbcc, aaabbbccc, etc
10:13:46 <ski> hmm
10:13:50 <freeside> https://www.grammaticalframework.org/doc/tutorial/gf-tutorial.html#toc66 talks about that
10:13:59 <ski> what if one uses `Integer -> Bool' as a token type ?
10:14:35 <erisco> we can do that with general CFG parser combinators because we allow ourselves infinite grammars
10:14:47 <erisco> countably infinite grammars afford you many things :P
10:15:24 <ski> `Integer -> Bool' isn't countable
10:15:30 <erisco> I don't know ski… I am sure the argument is specific about what sort of parsers we're talking about and what is and is not qualifying
10:15:38 * ski nods
10:16:14 <erisco> just basically speaking, because grammars with parser combinators can be infinite, we can do a lot more than expected with finite CFGs
10:16:42 <ski> if we have a countable token type, then a given parser can only possibly compute countably many parse results, i think
10:17:22 <ski> so even if we have `Parser Token (Integer -> Bool)', we could actually only produce countably many of the inhabitants of `Integer -> Bool'
10:17:56 <ski> and therefore we could just as well instead generate `Parser Token Integer', giving back the index count of the `Integer -> Bool' in the enumeration
10:18:18 <erisco> makes sense to me
10:18:23 <ski> and then we could enumerate parses like you said
10:18:48 <ski> however, i don't think that works with `Parser (Integer -> Bool) (Integer -> Bool)'
10:19:14 <ski> so, is presume the argument is assuming countable, if not finite, token type
10:19:28 <ski> s/, is /, i/
10:20:20 <ski> hmm .. but i suppose that the above argument of mine relies on `Parser Token (Integer -> Bool)' being algorithmic, so that we can inspect how it was built
10:20:58 <ski> if we can't inspect it, it doesn't really help that there ought to exist a corresponding `Parser Token Integer'. we still can't compute it
10:23:41 <erisco> lets generalise Enum to Integer, then we're basically saying  Enum a => Parser a -> (a -> Parser b)  is  Parser a0 *> f a0 <|> Parser a1 *> f a1 ...
10:24:14 <erisco> well that was a derpy way to write it out
10:24:40 <erisco> p *> f a0 <|> p *> f a1 ...
10:25:50 <erisco> I wonder if that actually works out. Not sure. But that is what I am thinking :)
10:29:10 <zincy> ski: back now
10:36:03 <ski> erisco : yes
10:36:06 <ski> zincy : ok
10:37:08 <ski> zincy_ : so i was talking about the explication rule/convention for where to insert missing `forall's
10:37:16 <zincy_> yep
10:37:31 <ski> zincy_ : all variables must be bound somewhere, at some "level" of scope
10:37:45 <zincy_> even type variables?
10:37:49 <ski> yes
10:37:59 <ski> especially those, in this context
10:38:01 <zincy_> for the Eq typeclass is there a for all.
10:38:11 <zincy_> at the top class Eq forall a. a where ...
10:38:15 <ski> yes, you can think of it like
10:38:31 <ski>   class forall a. Eq a
10:38:35 <ski>           where
10:38:47 <ski>           (==) :: a -> a -> Bool
10:39:04 <ski> or, perhaps
10:39:19 <ski>   forall a. class Eq a
10:39:24 <ski>     where
10:39:31 <ski>     (==) :: a -> a -> Bool
10:39:34 <ski> something like that
10:39:44 <ski> hmm
10:40:06 <ski> in any case, the `class' construction involves a binder for the parameters of the type class
10:40:10 <ski> if you have
10:40:16 <ski>   class Eq a => Ord a
10:40:17 <ski>     where
10:40:23 <ski>     compare :: a -> a -> Ordering
10:40:42 <ski> then obviously the binder scopes over the whole `Eq a => Ord a', as well as over the method signatures
10:40:55 <zincy_> yeah
10:42:12 <zincy_> makes sense 
10:42:22 <ski> (i'm not completely sure that it's reasonable to think of the binder in this case as a `forall'. maybe it's more like a lambda (or something else) .. as i said, unsure .. but it doesn't matter that much here. what's important is that there *is* a binder implied by the `class' declaration)
10:42:29 <ski> otoh, consider
10:42:39 <ski>   instance Eq a => Eq (Maybe a)
10:42:42 <ski>     where
10:42:52 <ski>     Nothing == Nothing = True
10:43:06 <ski>     Just x0 == Just x1 = x0 == x1
10:43:16 <ski>     _       == _       = False
10:43:30 <ski> here it's *definitely* a `forall a.' binder
10:43:47 <ski> (and we can wrap it around the whole `instance ...' declaration, for sure)
10:45:02 <zincy_> So what do well call that case
10:45:07 <ski> we're claiming that for each type `a', if `a' is an instance of `Eq' (iow if `Eq a' holds), then `Eq (Maybe a)' holds (`Maybe a' is an instance of `Eq'), because of the implementation of the required methods for the selection of `Maybe a' as the class parameter
10:45:25 <zincy_> the instantiation of a polymorphic type in a typeclass
10:45:30 <ski> so, conceptually, it makes sense to specialize `a' here to `Bool' e.g., so that we get
10:45:38 <ski>   instance Eq Bool => Eq (Maybe Bool)
10:45:39 <ski>     where
10:45:42 <ski>     ...
10:46:01 <ski> (even though i don't think GHC will like us writing that, much)
10:46:13 <ski> and, because we know `Eq Bool' holds, we can simplify this to
10:46:20 <ski>   instance Eq (Maybe Bool)
10:46:22 <ski>     where
10:46:23 <ski>     ...
10:46:36 <ski> (which would be possible, with `FlexibleInstances')
10:46:42 <ski> this is similar to how
10:47:00 <ski>   insert :: forall a. Ord a => a -> [a] -> [a]
10:47:19 <ski> which, as we said, can be interpreted to mean
10:47:23 <ski>   forall a.
10:47:32 <ski>     insert :: Ord a => a -> [a] -> [a]
10:47:37 <Solonarv> btw, you can even write 'instance forall a. Eq a => Eq (Maybe a)' with an extension
10:47:39 <ski> and then we can specialize this to
10:47:44 <Solonarv> althogh I can't remember if it's in a released GHC
10:47:53 <ski>     insert :: Ord Bool => Bool -> [Bool] -> [Bool]
10:48:02 <ski> er, without the extra indent :
10:48:04 <ski>   insert :: Ord Bool => Bool -> [Bool] -> [Bool]
10:48:14 <ski> and this in turn can be interpreted to mean
10:48:19 <ski>   Ord Bool =>
10:48:25 <ski>     insert :: Bool -> [Bool] -> [Bool]
10:48:35 <ski> and because we know `Ord Bool' holds, we arrive at just
10:48:37 <ski>   insert :: Bool -> [Bool] -> [Bool]
10:48:52 <ski> which we can then apply to a `Bool' and a `[Bool]' to get a `[Bool]'
10:49:05 <ski> Solonarv : which extension is that ?
10:49:22 <Solonarv> ski: I'm not sure, as I said I'm not even sure if it's in a released GHC or just 8.8
10:49:25 <ski> Solonarv : is it higher-rank instances ?
10:49:58 <ski> <zincy_> So what do well call that case
10:49:58 <ski> <zincy_> the instantiation of a polymorphic type in a typeclass
10:50:32 <ski> not a "polymorphic type", in any case (remember that a type like `forall a. ..a..' is not a polymorphic type)
10:50:58 <zincy_> oh yeah values are polymorphic not types
10:51:14 <ski> i'd call the `forall a. Eq a => Eq (Maybe a)' instance above a (constrained) polymorphic instance
10:51:36 <ski> it's polymorphic because there's a tyvar in `Eq (Maybe a)', which we're being general in
10:51:46 <zincy_> right
10:51:49 <ski> it's constrained because there's a condition, a constraint, `Eq a', on `a'
10:51:50 <Solonarv> ski: did a quick test, looks like you just need ExplicitForAll
10:52:18 <ski> compare with how `insert :: forall a. Ord a => a -> [a] -> [a]' is a constrained polymorphic function
10:52:35 <ski> Solonarv : ah, ok. so that's just extra syntax, no extra semantics yet, then
10:53:15 <ski> btw, the `=>' in `instance Eq a => Eq (Maybe a) where ...' doesn't mean the same as the `=>' in `class Eq a => Ord a where ...'
10:53:27 <ski> in the former case, it means implication between constraints
10:54:06 <ski> in `insert :: forall a. Ord a => a -> [a] -> [a]' it doesn't quite mean implication between constraints (what's to the right is a (concrete) type, not a constraint). but it's something related to that
10:55:35 <ski> however, in the `class Eq a => Ord a where ...' case, one might argue that it means an implication `Eq a <= Ord a' in the *opposite* order. because we're declaring that if we're to be allowed to have an instance of `a' for `Ord', then we must already have an instance of `a' for `Eq'
10:55:40 <zincy_> Would this comprise an implication between constraints ?  instance Foo a => Bar (Maybe a) where
10:55:43 <ski> and so `Ord a' implies `Eq a', for all `a'
10:56:29 <zincy_> oh i read former as latter 
10:56:49 <ski> however, another possible reading could be that `class Eq a => Ord a where ...' means that `Eq a' is a presupposition on `Ord a' being wellformed. in that case, if we don't know `Eq a' holds, `Ord a' is not well-formed, we can't even ask whether `Ord a' holds or not
10:57:13 <ski> i'm not quite sure which would be the most sensible reading
10:57:55 <ski> <zincy_> Would this comprise an implication between constraints ?  instance Foo a => Bar (Maybe a) where
10:58:13 <ski> yes, that declaration would mean `forall a. Foo a => Bar (Maybe a)' holds
10:58:47 <Solonarv> and in fact you can write that implication directly, and GHC will solve the constraint using that instance declaration
10:59:44 <zincy_> So is an implication between constraints referring to a relationship about types of kind Constraint?
11:00:13 <ski> yes, at least conceptually
11:00:36 <Solonarv> yes - 'Foo => Bar' means "whenever 'Foo' is satisfied, 'Bar' is also satisfied"
11:01:30 <ski> there may be syntactic restrictions (`Rank2Types',`RankNTypes',`ImpredicativeTypes'(,`PolymorphicComponents')) on where one may place `forall' inside *types*
11:01:58 <ski> (and not only `forall', but also `=>'. e.g. can you say `[Eq a => Tree a]' ?)
11:02:00 <zincy_> So how do you know when you need to explicate the forall. ?
11:02:19 <Solonarv> although with -XEverythingThatIsn'tDeprecated you can write forall in a lot of places
11:02:22 <ski> so, similarly there may be syntactic restrictions on where inside contraints one may place `forall' and `=>'
11:02:34 <ski> e.g., we'd like to be able to declare an instance like
11:03:08 <ski>   instance (forall a. Show a => Show (f a)) => Show (Fix f)
11:03:10 <ski>     where
11:03:12 <ski>     ...
11:03:15 <ski> where
11:03:27 <ski>   newtype Fix f = In (f (Fix f))
11:03:43 <ski> another similar example would be
11:03:59 <Solonarv> this is in fact allowed in GHC 8.6 with QuantifiedConstraints
11:04:05 <ski>   data Foo f = MkFoo (f Int) (f Bool)
11:04:10 <ski> and then we'd like to be able to say
11:04:19 <ski>   instance (forall a. Show a => Show (f a)) => Show (Foo f)
11:04:21 <ski>     where
11:04:23 <ski>     ...
11:05:45 <ski> of course, in the `Fix' case, we *could* also say the simpler and more concrete `instance Show (f (Fix f)) => Show (Fix f) where ...' (*if* we enable `UndecidableInstances', since the constraints are larger than the instance head)
11:06:17 <ski> and, in the `Foo' case, we *could* also say the simpler and more concrete `instance (Show (f Int),Show (f Bool)) => Show (Foo f) where ...'
11:06:31 <ski> (i don't think we need any extra extension in that case)
11:06:42 <ski> however, there may sometimes be reasons why we don't want to do it like this
11:07:19 <ski> e.g. our `Foo' might be an abstract data type, and we might not want to leak implementation details of it, in the constraints part of this instance
11:07:39 <zincy_> What are abstract data types?
11:07:42 <ski> so, this is just another case of rank-2 being used for information hiding
11:07:42 <zincy_> Things like singletons?
11:08:05 <ski> zincy_ : a type whose data constructors (and fields, if using record syntax) are not exported from the module
11:09:23 <ski> example abstract data types are `Char',`Int',`Integer',`Float',`Ratio',`Double',`Array',`Set',`Map',`(->)',`IO',`IORef',`IOArray',`Handle'
11:09:23 <zincy_>  What is the use of the `a` type variable in `instance (forall a. Show a => Show (f a)) => Show (Fix f) `
11:09:37 <zincy_> I see
11:10:32 <ski> we want to say that whatever type `a' the definition of `Fix' (or `Foo' for that matter, in the case of the other instance) wants to apply `f' to, `f a' is required to be an instance of `Show', under the condition that `a' is an instance of `Show'
11:11:24 <zincy_> oh so `f` is Fix and `a` is the type we are applying it to
11:11:33 <ski> in the `Fix' case, it only uses `a = Fix f'. in the `Foo' case, it uses both `a = Int' and `a = Bool', separately
11:11:53 <ski> no, `f' is a parameter passed to `Fix'
11:11:58 <ski> e.g. `f' might be `Maybe'
11:12:22 <ski> so `Foo Maybe' is basically the same as `(Maybe Int,Maybe Bool)'
11:12:48 <ski> while `Fix Maybe' is basically the same as `Maybe (Maybe (Maybe (Maybe (Maybe (...)))))' :)
11:13:16 <zincy_> ok
11:14:10 <ski> anyway, i'd call instances like the above for `Fix' and `Foo' (the former two instances, with nested `forall' and `=>', i'd call then rank-`2' (or higher-rank) instances
11:14:31 <ski> ok, perhaps enough about `class' and `instance' declarations now
11:14:50 <ski> we have two more cases of `forall' explication to consider
11:15:05 <zincy_> So do you need rankN types if you have a polymorphic function which want's to apply different types to `a` on successive calls
11:15:06 <ski> (in case you want to hear about them in more detail. or i could skip that)
11:15:25 <ski> (i can say a little bit more about higher-rank later as well, if you want)
11:15:55 <zincy_> what is the alternative topic?
11:16:03 <ski> (in fact, i think i want to do that, regardless, because of the original questions sparking the discussion)
11:16:17 <zincy_> sure
11:16:50 <ski> there is no alternative topic. it's the topic which i'm heading towards. namely explaining how polymorphic values can be passed around at run-time, with this "broader understanding" of polymorphism
11:16:54 <ski> and things related to that
11:17:42 <zincy_> It would be good to hear about the other cases
11:17:42 <ski> but before i got more into that, i wanted to make it clear how things like `reverse :: [a] -> [a]' really mean `reverse :: forall a. [a] -> [a]', and so i wanted to talk a bit about such `forall' explication
11:17:54 <ski> yea, i was thinking it could be nice to hear about them
11:17:54 <zincy_> of forall explication
11:18:20 <zincy_> yeah
11:18:36 <ski> (btw "`forall' explication" is a term i invented during this conversation. i think it sounds reasonable, so perhaps i'll use it more. but it's not an established term, for what i know at least)
11:18:58 <zincy_> doesn't seem too contentious
11:19:05 * MarcelineVQ looks up explication
11:19:17 <ski> @wn explication
11:19:19 <lambdabot> *** "explication" wn "WordNet (r) 3.0 (2006)"
11:19:19 <lambdabot> explication
11:19:19 <lambdabot>     n 1: the act of making clear or removing obscurity from the
11:19:21 <lambdabot>          meaning of a word or symbol or expression etc.
11:19:23 <lambdabot>     2: a detailed explanation of the meaning of something
11:19:44 <ski> perhaps there's a more appropriate word i can't think of atm
11:19:52 <ski> atm, "explication" will do, i think
11:20:52 <MarcelineVQ> huh odd, that's not the defintion google gave me. that meaning above is to explain something but google claims it is to analyze something. Good job modern dictionaries, good job.
11:21:58 <ski> so, we considered cases where a type signature occurs inside a `class', and an `instance' declaration, and how those situations can cause some tyvars in the signature to already be in scope, and therefore should not be "guarded" by an explicit `forall' after the `::' in the signature (since that would *shadow* the outer in-scope tyvar, which isn't what we want to do in these cases. we want to *refer* to the nonlocal/outer in-scope tyvar)
11:22:30 <zincy_> right
11:22:42 <ski> the tyvars that are bound by a `forall' just after the `::' in the signature will be ones which the user/caller/consumer of the operation will get to pick/choose
11:24:39 <zincy_> so for typeclasses the forall is still there just before the head?
11:26:04 <ski> but the tyvars that are bound by the `class' declaration itself are ones that an `instance' declaration (of some type) for that type class will get to pick/choose. the caller/user/consumer of the methods will *not* get to pick/choose them
11:26:08 <ski> (and neither will the callee/implementation/producer of those methods, i.e. the source inside the `instance' declaration get to pick/choose types for those tyvars *individually*. the choice is made once, for the whole `instance' declaration)
11:26:54 <ski> zincy_ : for `class' and `instance' declarations, basically yes (barring that i said that i'm not completely sure whether it's conceptually a `forall' in the case of `class', or maybe some other type of binder)
11:27:05 <ski> so, what's left ?
11:27:18 <ski> well, consider
11:27:36 <ski>   data Tree a = Node a [Tree a]
11:27:59 <ski> this doesn't involve any type signature, but it still involves binding of type variables
11:28:07 <ski> conceptually, this means
11:28:13 <ski>   data forall a. Tree a = Node a [Tree a]
11:28:14 <ski> or
11:28:16 <ski>   forall a.
11:28:20 <ski>     data Tree a = Node a [Tree a]
11:28:43 <ski> note that `Node' here is not a type, and so neither is `Node a' or `Node [Tree a]' types
11:29:09 <ski> instead these are strange (BNF-inspired) mixtures of values (`data' constructors) and types
11:29:21 <ski> the main point i want to emphasize here is that
11:29:25 <ski>   data Tree a = Node a [Tree a]
11:29:28 <ski> does not mean
11:29:37 <ski>   data Tree a = Node (forall a. a) (forall a. [Tree a])
11:30:09 <ski> which is what it would mean if the rule was "insert `forall'" at the "toplevel of the type expression"
11:30:16 <zincy_> In the latter you could have different a's which would give you a heterogeneous tree?
11:30:19 <ski> (and therefore that suggested rule is wrong)
11:30:37 <ski> yea .. i'll come to what something like the latter declaration really means
11:31:02 <ski> but, recall that we can also declare the same `data' type `Tree', using `GADTSyntax' extension :
11:31:05 <ski>   data Tree a
11:31:08 <ski>     where
11:31:17 <ski>     Node :: a -> [Tree a] -> Tree a
11:31:27 <ski> and *now* we see our missing type signature
11:32:00 <ski> and the rule is, as before, that we should add `forall' after the `::', for the tyvars, *except* tyvars which are already in scope
11:32:52 <ski> and `a' *is* already in scope (bound in the `data' head), and so, arguably, we should *not* add a `forall a.' after the `::' here
11:32:55 <ski> however
11:34:07 <ski> in the `class' case we distinguished between having a monomorphic/polymorphic method, and having the method, treated as an ordinary operation, considered outside of the context of the type class, being monomorphic/polymorphic
11:34:46 <zincy_> yeah
11:34:47 <ski> considered as a `data' constructor of `Tree', we *could* say that `Node' is monomorphic. so it'd be a "monomorphic `data' constructor" then
11:34:56 <ski> (and similarly with `Nothing' and `Just', for `Maybe')
11:35:20 <ski> however, considered as any old function (or other value, in the case of `Nothing'), they are clearly polymorphic :
11:35:32 <ski>   Node :: forall a. a -> [Tree a] -> Tree a
11:35:36 <zincy_> Ah because the `a` has already been applied by the time we can evaluate the data constructor
11:36:11 <ski> so, when we *move* the signature of `Node' outside the scope of the `data' declaration above, we have to add the `forall a.' part, to still have `a' bound, to avoid it "escaping" / being a free tyvar in the type signature
11:37:05 <ski> and the same holds for the `class' case. inside `Eq a' we have `(==) :: a -> a -> Bool'. outside of it, we have `(==) :: forall a. Eq a => a -> a -> Bool' (so we also add the type class head as a constraint here)
11:38:12 <zincy_> I think it makes sense
11:38:18 <zincy_> its a different way of looking at it
11:38:32 <ski> however, i haven't used this terminology "monomorphic/polymoprhic `data' constructor" before, i realized just now that one could have these terms, in analogy with "monomorphic/polomorphic `class' method", which is clearly useful terms, sometimes
11:39:01 <ski> i haven't thought about how useful these "monomorphic/polymoprhic `data' constructor" terms might be, or not
11:39:25 <ski> oh .. and something similar would hold for record fields as well, i think
11:40:05 <ski> (although, there we have an auxilary (infuriating !) complication that there's also an extra (explicit !) *argument* type being added)
11:40:08 <ski> if we say
11:40:20 <ski>   data Person = MkPerson {name :: String,age :: Int}
11:41:18 <ski> then inside `Person' (and also inside record construction and record update syntax for this `data' constructor `MkPerson', which is what's associated with the record syntax (the type `Person' isn't)) `name' has type `String' and `age' has type `Int'
11:42:32 <ski> so, if we write (record construction) `MkPerson {name = myName,age = myAge}' (and call this whole thing `myPerson', say), or if we write (record update) `myPerson {age = myNewAge}', then obviously `myName' must have type `String', and `myAge' and `myNewAge' must have type `Int'
11:42:52 <zincy_> yeah
11:43:25 <ski> however, *outside* of the `data' declaration, and these two cases (the first of which can also be a patter), somehow `name' now has type `Person -> String', and `age' has type `Person -> Int'
11:43:32 <ski> this is nonsense, imho !
11:43:38 <ski> very confusing
11:43:58 <zincy_> that is odd
11:44:07 <ski> e.g., if we wanted to increment `age' by one in `myPerson', we'd have to write `myPerson {age = age myPerson + 1}'
11:44:41 <ski> so, in age = age myPerson + 1', the `age' on the left of `=' has type `Int', but the `age' on the right of `=' has type `Person -> Int' !
11:44:45 <ski> utterly confusing
11:44:56 <zincy_> is ! strict application?
11:45:25 <ski> no the "!" i used here is an exclamation mark
11:45:45 <ski> (if you're talking about `!' in Haskell syntax, that's another thing)
11:46:12 <zincy_> Oh I thought it was the Haskell syntax
11:46:33 <zincy_> misread it
11:46:37 <ski> the *correct* way of doing this (field accessor/selector/projection functions) would be to have some extra syntax for the accessor function, in addition to merely the field name
11:47:03 <ski> so, instead of `age myPerson', we might have had `#age myPerson' (as in SML), or `myPerson .age' (as in OCaml)
11:47:27 <ski> or some other concrete syntax, if we didn't want to use the symbols `#' or `.' here
11:47:52 <ski> the important part is that, for this to be sensible, we need some extra syntactical mark
11:48:24 <zincy_> yeah
11:48:26 <ski> `myPerson {age = #age myPerson + 1}' or `myPerson {age = myPerson .age + 1}' or something along those lines would have been fine
11:48:31 <qualiaqq> ski, how does one add those extra syntax accessor functions for records?
11:48:54 <ski> qualiaqq : they are automatically generated, if you use record syntax in the `data'/`newtype' declaration
11:49:02 <tty1> I asked this question before but I wasnt able to articulate myself well enough to get an answer... let me try again, this time with some code as an example...
11:49:19 <ski> (qualiaqq : i assume you mean "*field* accessor functions", not "*syntax* accessor functions")
11:49:53 <qualiaqq> ski, right that's what I meant.
11:50:23 <ski> zincy_ : ok, so this about record syntax was aside rant .. though a little bit related to the previous discussion in that we added some extra stuff to the signature of `name' and `age', as we moved those signatures out of the `data' declaration
11:50:35 <qualiaqq> ski, so there is an age function generated to get the field out and a #age as well?
11:51:09 <ski> zincy_ : and this is unreasonable in this case, imho, because adding `Persong -> ' to the type signatures means that we can't any longer use `name' and `age' as having the same types, we must *explicitly* apply to a `myPerson'
11:52:34 <ski> zincy_ : while, in the previous cases, `class' declarations and `data' constructor signatures, we only added `forall', and as we've seen the step from `forall a. [a] -> [a]' to `[Bool] -> [Bool]' is implicit. if `reverse' has the former type, then we still (can) write just `reverse' for the specialization to the latter type
11:53:22 <ski> qualiaqq : there is an `age' function, and a `name' function generated, yes. no `#age' function, that's SML syntax, which Haskell (unfortunately) doesn't have
11:53:56 <zincy_> ski: Not sure I follow your last point?
11:54:21 <zincy_> You were saying that in the previous cases we have seen forall. is implicit?
11:54:28 <ski> inside
11:54:30 <ski>   data Person = MkPerson {name :: String,age :: Int}
11:54:31 <tty1> So I have this code that works: https://pastebin.com/2TbCQWw2 . The code isnt meant to be good design or even useful, just a way for me to play with the idea of classes. My question: Is there someway I can enforce/implement Indetified as a subclass of functor (rather than just implementing it as an instance like i do later)?
11:54:32 <ski> we have
11:54:35 <ski>     name :: String
11:54:39 <ski>     age :: Int
11:54:47 <ski> outside of it, we have
11:54:54 <ski>   name :: Person -> String
11:55:00 <ski>   age :: Person -> Int
11:55:00 <qualiaqq> ski, oic
11:55:44 <ski> so, depending on whether we're in an "inside" or "outside" context, we will have to write either just `age', or `age myPerson', for some `myPerson' of type `Person'
11:56:21 <ski> e.g. in `myPerson {age = age myPerson + 1}', the first `age' is in an "inside" context, but the second `age' is in an "outside" context
11:56:41 <ski> and this is very confusing : is `age' a function or not ? it depends on where we write it !
11:56:53 <ski> however, consider again
11:56:57 <ski>   class Eq a
11:56:58 <ski>     where
11:57:01 <zincy_> I always forget you are given free accessor functions for fields
11:57:06 <ski>     (==) :: a -> a -> Bool
11:57:54 <ski> outside of the context of this `class' declaration (and also outside of the context of `instance' declarations for `Eq'), we will have to add a `forall a. Eq a => ', so that we have
11:58:04 <ski>   (==) :: forall a. Eq a => a -> a -> Bool
11:58:06 <ski> outside
11:58:32 <ski> however, we still *can* call `(==)' in the same way, regardless of whether we're in an "inside" or "outside" context here ! 
11:59:33 <zincy_> I see why you introduced the records rant now
12:00:08 <ski> because the specialization of the tyvar `a' to some specific type, like perhaps `Bool', and the subsequent providing of evidence (type class method dictionary / "vtable") for the constraint, here `Eq Bool' in that case, is (or *can* be) *implicit* !
12:00:47 <ski> with the `TypeApplication' extension, we *can* make the specialization of `a' to `Bool' explicit, so that we can write `(==) @Bool myBool0 myBool1'
12:01:22 <ski> but we still *can* write it implicitly, like `(==) myBool0 myBool1' (or infix, like `myBool0 == myBool1') !
12:01:47 <bss> I'm trying to replace a call to Data.Function.fix with a unfold/fold; it seems possible, but I'm not sure.
12:01:48 <ski> so, we don't have this sudden *explicit* change in the type of `(==)', depending on in which context we write it
12:02:28 <ski> bss : we'd have to hear a more involved description, or see the code, to possibly be able to tell
12:02:45 <tty1> oh cool i have a public ipv6 address!!! sweet :)
12:02:56 <ski> zincy_ : anyway, similarly, with
12:02:59 <ski>   data Tree a
12:03:01 <ski>     where
12:03:09 <ski>     Node :: a -> [Tree a] -> Tree a
12:03:10 <bss> Trying to figure out a general folding/unfolding for (Reccursive f, Corecursive f, Alternative m, Monad m) => m f
12:03:11 <zincy_> What is the "subsequent providing of evidence" for Bool being an instance of Eq
12:03:17 <ski> the move of `Node' to "outside", yielding
12:03:22 <ski>   Node :: forall a. a -> [Tree a] -> Tree a
12:03:39 <bss> ski:  It'll be a little out of context, but I'll throw some code on pastbin, just a sec.
12:04:00 <ski> only adds the `forall a.' part to the type, and that doesn't correspond to (or doesn't have to correspond to) a change in the syntax for using `Node'
12:04:45 <bss> ski: https://pastebin.com/4HuXg4qT
12:05:41 <ski> zincy_ : that is something that the language implementation handles implicitly for you. when you make an `instance Eq Bool where ...', one way of implementing that is to transform that to `inst_Eq_Bool :: EqDict Bool', where `data EqDict a = MkEqBool {(==) :: a -> a -> Bool,...}'
12:06:38 <ski> zincy_ : and then `elem :: forall a. Eq a => a -> [a] -> Bool' would get transformed into `elem :: forall a. EqDict a -> a -> [a] -> Bool' (notice the `=>' turned into an `->', so we now have an extra, explicit, argument !)
12:07:13 <bss> In this case I have a think I have something close to a coalgebra: ReadPrec x -> ReadPrec (TermF x); seems like I should be able to turn it into a (generalized) hylomorphism, but I'm not sure.
12:07:33 <ski> zincy_ : and a call like `elem False [True,False,True]' would then be turned into `elemn inst_Eq_Bool False [True,False,True]', so `inst_Eq_Bool' is here the evidence for `Eq Bool' that has been inserted by the language implementation
12:10:31 <ski> bss : `readsPrec :: Int -> ReadS a', so `termLiftReadPrec :: (Int -> ReadS a) -> Int -> ReadS a'. so it'd have to be an anamorhism/unfold, not a catamorphism/fold, if it works at all
12:10:42 <zincy_> so evidence is  stored in a dictionary of typeclass methods for each `a` 
12:11:50 <bss> ski: I think I can use join/embed to handle the folding down; and I think I'm close to the unfold side.
12:13:01 <bss> But, I've thought I was close since last weekend, and none of my fiddling has resulting something that completely type checks.
12:13:18 <ski> zincy_ : yes. and if you make `instance Eq a => Eq (Maybe a)', then that would be translated into `inst_Eq_Maybe :: forall a. EqDict a -> EqDict (Maybe a)', so that if you somewhere need evidence for `Eq (Maybe Bool)', it'd automaticaly construct it by applying the "evidence transformer/constructor" `inst_Eq_Maybe' to the "base evicence" `inst_Eq_Bool', getting `inst_Eq_Maybe inst_Eq_Bool' of type `EqDict (Maybe Bool)'
12:13:46 <bss> ski: I want to consider the general problem, too, since I need to do the same thing with arbitrary / Gen Term.
12:13:52 <zincy_> so a nested dictionary for multi param type classes?
12:14:57 <bss> `oneof :: [Gen a] -> Gen a` and `choice :: [ReadPrec a] -> ReadPrec a` both exist and I think they'd be used similarly, or maybe I'm seeing a similarity where there's actually duality?
12:15:10 <ski> zincy_ : so, whenever you have `instance' declarations with constraints, that would be translated into such functions which can construct new evidence from old evidence. and whenever you need an `Eq' instance for a complicated type like e.g. `Map Int [(Bool,String)]', it'd automatically generate something like `inst_Eq_Map inst_Eq_Int (inst_Eq_List (inst_Eq_Pair inst_Eq_Bool (inst_Eq_List inst_Eq_Char)))' for you
12:16:06 <ski> zincy_ : so, that's some hidden code, generated for you, from type information. you couldn't do that without a static type system (without changing evidence providing from implicit to explicit syntax in the base language)
12:16:11 <zincy_> that sounds complicated to implement
12:16:36 <ski> <zincy_> so a nested dictionary for multi param type classes?
12:16:37 <ski> no
12:17:08 <zincy_> so no nesting the multiple params are just joined to form one key?
12:17:21 <bss> MTPC dictionaries are just records with mutliple parameters.
12:17:53 <ski> for `instance Monoid w => MonadReader w (Writer w)', you'd just get `inst_MonadWriter_Writer :: forall w. DictMonoid w -> DictMonadReader w (Writer w)'
12:19:38 <zincy_> ok
12:19:41 <ski> bss : anyway, recall `type ReadS a = String -> [(a,String)]' ..
12:20:19 <bss> zincy_: class MTPC a b where {..} ~= data InstMPTC a b = {..}  instance MTPC Int Bool where {..} ~= { instMPTC_Int_Bool :: InstMPTC Int Bool; instMPTC_Int_Bool = {..}; }
12:20:57 <bss> ski: Sure.
12:21:20 <ski> hmm
12:21:59 <ski> i think the first `String' should be part of the unfold state
12:22:20 <ski> the question is whether the `Int' from `readsPrec' should also be part of the state, or not ?
12:22:29 <zincy_> bss: thanks
12:23:17 <ski> hmm .. we also need some kind of flattening (like `join') for the `[]' there, i think
12:23:21 <ski> that complicates stuff
12:23:57 <bss> ski: choice :: [ReadPrec a] -> ReadPrec a, so that can flatten, some.
12:24:10 <ski> hm, i suppose
12:24:37 <ski> the question is whether we can manage to get `[]' outside of `ReadsPrec' there
12:25:03 <ski> (also, i'm not so familiar with how `ReadsPrec' is built)
12:25:20 <ski> zincy_ : .. anyway, backtracking a bit
12:25:23 <bss> I think the `Int` can be ignored, maybe, the "nested" calls are all at precdence 9, I think.
12:26:45 <bss> ski: ReadP / ReadPrec is a GHC replacement for ReadS, the guts aren't exposed, but it's basically a CPS parser ala attoparsec.
12:27:10 <ski> zincy_ : we convered type signatures in `class' declarations, type signatures (of `data' constructors) in `data' declarations (using `GADTSyntax'), and also the case of the traditional algebraic data type syntax (no explicit signature in that was, but we could still say there's an implicit signature of the data constructor)
12:27:20 <bss> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Text.ParserCombinators.ReadP.html#P and https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Text.ParserCombinators.ReadP.html#ReadP and https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Text.ParserCombinators.ReadPrec.html#ReadPrec
12:27:52 <ski> zincy_ : and i said that it's the same for `newtype' declarations (except that `GADTSyntax' or `GADTs' isn't allowed there, only the algebaic data type style of declaration)
12:28:07 <ski> bss : yes, i know. i just haven't played around much with it
12:28:12 <ski> bss : CPS you say ? okay
12:28:37 <ski> <bss> I think the `Int` can be ignored, maybe, the "nested" calls are all at precdence 9, I think.
12:28:40 <ski> bss : okay
12:28:43 <bss> ski: I might be abusing the term CPS there.  It's also my first time using it.
12:29:07 <bss> Damn, these storm sirens are annoying.
12:29:14 <ski> bss : doesn't really matter (to me) here, unless i take a look at the implementation, i suppose
12:29:51 <ski> zincy_ : so, the remaining important case is local definitions (where type signatures are also allowed), inside `where' and `let'
12:29:57 <ski> zincy_ : consider this :
12:30:08 <ski>   elem :: Eq a => a -> [a] -> Bool
12:30:17 <ski>   elem x0 = elem_x0
12:30:19 <ski>     where
12:30:54 <ski>     elem_x0 [    ] = False
12:30:57 <bss> ski: It's supposed to be more efficient because it can "process all alternatives in parallel", and the ReadP constructor looks a bit CPS-y to me.
12:31:07 <ski>     elem_x0 (x:xs) = x0 == x || elem_x0 xs
12:31:26 <ski> oh, sorry, i also meant to have a signature on `elem_x0', namely
12:31:43 <ski>     elem_x0 :: [a] -> Bool
12:32:22 <ski> (we shouldn't need the `Eq a =>', since it should already be "in scope", just like `x0' of type `a' is already "in scope", so that we don't need `a -> ' in the type signature of `elem_x0')
12:33:02 <ski> zincy_ : now, the trouble is that without an extension, the `a' in the first signature will be unrelated to the `a' in the second signature
12:33:21 <ski> but we want the `a' in the second signature to be a nonlocal tyvar
12:33:33 <ski> we *don't* want the signature on `elem_x0' to mean
12:33:45 <ski>     elem_x0 :: forall a. [a] -> Bool
12:33:47 <ski> or even to mean
12:33:54 <ski>     elem_x0 :: forall a. Eq a => [a] -> Bool
12:34:07 <zincy_> so we essentially want to have the tyvar bound once for both types?
12:34:33 <ski> because the implementation of `elem_x0' uses `x0', a nonlocal variable, which has type `a', a *nonlocal* type variable ! .. bound in the outer type signature, more or less 
12:34:47 <ski> so, we could say that we want
12:34:56 <ski>   elem :: forall a. Eq a => a -> [a] -> Bool
12:35:00 <ski>   elem x0 = elem_x0
12:35:04 <ski>     where
12:35:14 <ski>     elem_x0 :: [a] -> Bool
12:35:17 <ski>     ...
12:36:07 <ski> however, i don't like this, because if we read `elem :: forall a. Eq a => a -> [a] -> Bool', then that ought to be the same as `elem :: (forall a. Eq a => a -> [a] -> Bool)', iow `a' there ought to be *local* to that type signature, only in scope in that type signature
12:36:33 <ski> so it couldn't be in scope in the defining equation `elem x0 = elem_x0 where elem_x0 :: [a] -> Bool; ...'
12:36:46 <ski> so, what i argue that we'd want here is actually
12:37:05 <ski>   forall a.
12:37:10 <ski>     Eq a =>
12:37:21 <ski>       elem :: a -> [a] -> Bool
12:37:27 <ski>       elem x0 = elem_x0
12:37:31 <ski>         where
12:37:39 <ski>         elem_x0 :: [a] -> Bool
12:37:41 <ski>         ...
12:37:45 <ski> or, possibly
12:37:48 <ski>   forall a.
12:37:57 <ski>     elem :: Eq a => a -> [a] -> Bool
12:38:02 <ski>     elem x0 = elem_x0
12:38:04 <ski>         where
12:38:14 <ski>         elem_x0 :: Eq a => [a] -> Bool
12:38:17 <ski>         ...
12:38:35 <zincy_> so does the ` elem :: forall a. Eq a => a -> [a] -> Bool` example not ensure the `a`s in both sigs refer to the same binding? I wouldnt have thought so.
12:38:42 <ski> (though the latter is less ideal/nice, though it would work)
12:38:44 <zincy_> But the latter two do
12:39:06 <zincy_> Hmm does Eq a => have an implicit forall
12:39:22 <ski> so that we have the same `a' in scope in both the (outer/first) type signature, and in the defining equation for `elem' (which includes the attached `where'-clause, which includes the signature for `elem_x0')
12:39:56 <ski> zincy_ : i'm arguing that `forall a. ..a..' should mean the same as `(forall a. ..a..)'
12:40:13 <ski> and clearly `a' is only in scope in `..a..' in the latter
12:40:32 <zincy_> yeah
12:40:48 <ski> so that we'd have `elem :: forall a. Eq a => a -> [a] -> Bool' meaning the same as `elem :: (forall a. Eq a => a -> [a] -> Bool)', so `a' is only in scope inside this type signature, so can't be in scope in the defining equation
12:41:07 <ski> however, if we write
12:41:24 <ski>   elem :: Eq a => a -> [a] -> Bool
12:41:29 <ski>   elem x0 = elem_x0
12:41:32 <ski>     where
12:41:35 <ski>     ...
12:41:59 <ski> then we could imagine an implicit `forall a.' wrapping both the signature and the defining equation, which would work, in terms of scoping
12:42:17 <ski> so, this ought to work, imho, with the extension in question
12:42:45 <ski> while using `elem :: forall a. Eq a => a -> [a] -> Bool' ought *not* to work, to bring `a' into scope in the defining equation (including signature for `elem_x0')
12:42:53 <ski> zincy_ : however !
12:42:59 <mdunnio> does anyone have experience building a ghc cross compiler for arm?
12:43:12 <mdunnio> I'm trying to use ghc 8.4.3 but I'm running into issues.
12:43:36 <ski> it turns out that the extension `ScopedTypeVariables' work exactly the *opposite* way around as what you'd expect (or at least what *i*'d expect) !
12:43:52 <ski> zincy_ : so, in fact, if you write
12:43:56 <ski>   elem :: Eq a => a -> [a] -> Bool
12:44:21 <ski> with this extension that does *not* bring `a' in scope in the implementation (the defining equations), which i think it ought to do !
12:44:27 <ski> and also, if you write
12:44:32 <ski>   elem :: forall a. Eq a => a -> [a] -> Bool
12:44:51 <ski> with this extension that *does* bring `a' in scope in the implementation (the defining equations), which i think it ought *not* to do !
12:45:03 <ski> zincy_ : so, it's exactly backwards to what i expect
12:45:12 <ski> however, there's also another way to write this
12:45:14 <ski> namely
12:45:23 <ski>   elem :: forall a. Eq a => a -> [a] -> Bool
12:45:32 <ski>   elem (x0 :: a) = elem_x0
12:45:34 <ski>     where
12:45:41 <ski>     elem_x0 :: [a] -> Bool
12:45:44 <ski>     ...
12:47:28 <ski> here we have two differen tyvars in two scopes. one named `a', which is in scope in the type signature of `elem', brought into scope by the `forall a.'. and one named `a', which is in scope in the defining equation (including signature for `elem_x0') brought into scope by the pattern ascription `:: a' in the pattern (or, if you prefer, by an initial, implicit `forall a.', before the `elem (x0 :: a) = ... where ...' part)
12:47:59 <ski> if you wanted to, you could change the signature of `elem' to
12:48:08 <ski>   elem :: forall b. Eq b => b -> [b] -> Bool
12:48:13 <ski> and it's still work
12:48:35 <ski> zincy_ : so, this alternate way does work in a reasonable way, with `ScopedTypeVariables'
12:49:07 <ski> (this latter way used to be called `PatternSignatures' (though it's really ascriptions, not signatures), but it got merged into `ScopedTypeVariables' at some point)
12:49:20 * ski idly wonders whether zincy_ is still with us
12:49:40 <ski> mdunnio : i don't, sorry :/
12:49:54 <zincy_> so `scopedTypedVariables` introduces notion of binding tyvars across multiple type sigs?
12:49:59 <zincy_> had a phone call :/
12:50:06 <zincy_> just catching up
12:50:46 <ski> no worry
12:50:48 <ski> <zincy_> so we essentially want to have the tyvar bound once for both types?
12:50:55 <ski> yes, once for both type signatures
12:51:13 <mdunnio> skI: no worries, I figured. It's not super common.
12:51:31 <ski> or else, we want to ensure that we bring a second `a' (or named, if preferred) into scope, that is the type of `x0', so that we can refer to that same tyvar `a' in the signature of `elem_x0'
12:52:16 <ski> mdunnio : if you wonder, i've been aiming to explain something to zincy_, for a while now. we're working our way towards it, but also covering various more or less related bits along the way ..
12:52:39 <ski> <zincy_> so `scopedTypedVariables` introduces notion of binding tyvars across multiple type sigs?
12:52:47 <ski> not "across multiple type sigs", per se
12:53:12 <zincy_> nested type sigs?
12:53:20 <ski> what it does is make tyvars from the type signature (that are not locally bound) come in scope in all the associated defining equations
12:53:30 <zincy_> as in let and where bindings I mean
12:54:21 <arsdragonfly[m]> has anyone tried to build alsa-mixer lately?
12:54:29 <ski> and those defining equations can contain (type ascriptions, where we'd like tyvars like `a' to be in scope and also) attached `where'-clauses ior `let'-expressions, and those two may contain further type signatures where we'd like tyvars like `a' to be in scope
12:54:43 <ski> zincy_ : right, exactly !
12:55:05 <ski> consider
12:55:13 <ski>   silly :: a -> Maybe a
12:55:26 <ski>   silly (_ :: a) = (Nothing :: Maybe a)
12:56:04 <ski> er, actually, it's enough with
12:56:10 <ski>   silly _ = (Nothing :: Maybe a)
12:56:26 <ski> `:: Maybe a' after `Nothing' here is a type ascription (not a type signature), but we'd still like to be able to refer to the `a' from the type signature in that ascription
12:56:57 <arsdragonfly[m]> https://github.com/haskell/c2hs/issues/192
12:57:18 <ski> (the difference between an ascription and a signature is that a signature is a declaration, but an ascription is an expression (or a pattern, in the case of pattern ascriptions. the previous case was expression ascriptions))
12:58:17 <arsdragonfly[m]> I'm still getting "c2hs: Prelude.head: empty list" when I try to build alsa-mixer
12:58:43 <ski> zincy_ : so, also in this case, `ScopedTypeVariables' perversely force us to use `silly :: forall a. a -> Maybe a' (.. or else use `silly (_ :: a) = (Nothing :: Maybe a)', which isn't perverse)
12:59:32 <ski> zincy_ : now, one can imagine two more cases (that i can think of), more or less, which aren't implemented in Haskell
12:59:37 <ski> imagine
12:59:48 <zincy_> no too clear on declaration vs ascription?
13:00:03 <ski> a declaration is something which we assert as true, more or less
13:00:11 <ski> in
13:00:18 <ski>   blah :: Int
13:00:21 <ski>   blah = 42
13:00:26 <ski> both of these are declarations
13:00:51 <ski> however, `42' in `blah = 42', is an expression, and `blah' in there is a pattern
13:01:18 <ski> so, if we write `blah = (42 :: Int)', then this `(42 :: Int)' is also an expression, not a declaration
13:01:37 <ski> it means "the expression `42', and oh, btw, the type of this is `Int'"
13:01:53 <ski> while the type signature `blah :: Int' means "the type of `blah' is `Int'"
13:02:45 <ski> when i write private notes, i write type ascriptions like `42 (:: Int)', rather than `42 :: Int', to indicate that the `(:: Int)' part, is an "oh, btw" part
13:03:25 <ski> the meaning of a declaration is the claim being made by the declaration
13:03:34 <ski> the meaning of an expression is the value being computed by it
13:03:36 <zincy_> yeah
13:03:52 <zincy_> gotcha
13:03:54 <ski> so a declaration like `blah :: Int' means a claim about something having a certain type
13:04:32 <ski> while an ascription like `blah :: Int' means the value of the expression `blah', while we're also making sure that it has type `Int' (otherwise type error)
13:04:39 <zincy_> isn't Nothing :: Maybe Int a declaration?
13:04:50 <zincy_> actually no
13:04:55 <zincy_> it cant be falsified
13:05:03 <zincy_> it is an expression
13:05:23 <ski> (sometimes people confuse ascriptions with casts/coercions .. but we're not coercion `blah' from possibly some other type, to `Int'. we're declaring "oh, btw, `blah' already must have type `Int'")
13:05:41 <ski> zincy_ : it depends on where you write it
13:05:46 <ski> if you write a declaration
13:05:48 <zincy_> ski: yeah
13:05:56 <ski>   foo = (Nothing :: Maybe Int)'
13:06:07 <ski> then `Nothing :: Maybe Int' there is an ascription
13:06:29 <ski> but if you declare it (conceptually) as a valid type of `Nothing', then its a signature
13:06:34 <tty1> hey asked this earlier but didnt get an answer....
13:06:41 <tty1> So I have this code that works: https://pastebin.com/2TbCQWw2 . The code isnt meant to be good design or even useful, just a way for me to play with the idea of classes. My question: Is there someway I can enforce/implement Indetified as a subclass of functor (rather than just implementing it as an instance like i do later)?
13:07:07 <ski> (so this is another reason why i'd like different syntax for signatures vs. ascriptions (expression vs. pattern ascriptions ought to have the same syntax, though))
13:07:37 <zincy_> but if you declare it (conceptually) as a valid type of `Nothing’”
13:07:38 <zincy_> What does "mean?
13:08:27 <ski> tty1 : for `Functor' you need a parameter of kind `* -> *', however all the parameters of `Identified t i o', namely `t',`i',`o' all have kind `*'
13:08:40 <bss> tty1: Not exactly sure what that means.  They have different kinds.
13:08:48 <ski> tty1 : so it's not even clear what you'd like to enforce be in `Functor'
13:09:03 <ski> zincy_ : i mean that you're allowed to write
13:09:07 <ski>   data Maybe a
13:09:11 <ski>     where
13:09:24 <ski>     Nothing :: Maybe a
13:09:27 <ski>     ...
13:09:41 <ski> however, you're not allowed to write
13:09:49 <tty1> ski: the instance i defined of functor below shows the behavior I want. Its behaving the way I want. I just want to make it so if someone defines something to be an instance of Identified than the compiler forces them to also make it a instance of Functor (as it already does with Eq, Ord, and HAshable).. otherwise i want the same behavior i have now
13:09:49 <ski>   data Maybe Int
13:09:51 <ski>     where
13:09:54 <ski>     Nothing :: Maybe Int
13:09:57 <ski>     ...
13:10:27 <ski> and you're not allowed to write `Nothing :: Maybe Int' as a signature (a declaration), anywhere else as well
13:10:41 <ski> (you could write it as an ascription, but that's a different thing, as i explained)
13:10:47 <zincy_> really?
13:10:57 <ski> however, you could still *conceptually* claim
13:11:02 <ski>   Nothing :: Maybe Int
13:11:11 <zincy_> could you not annotate a function func :: Maybe Int and just return Nothing
13:11:12 <ski>  as holding, even if you can't write that in source
13:11:20 <ski> similarly, if you have
13:11:31 <ski>   insert :: forall a. Ord a => a -> [a] -> [a]
13:11:39 <ski> you're not allowed to simultaneously write
13:11:51 <ski>   insert :: Ord Bool => Bool -> [Bool] -> [Bool]
13:11:52 <ski> or
13:11:56 <ski>   insert :: Bool -> [Bool] -> [Bool]
13:12:02 <bss> tt1: `Eq` and `Ord` are both of kind `Type -> Constraint` so, `Eq a => Ord a`, works,  but all your paramaters to `Indentified` are `Type`, so it's unclear what `Type -> Type` you want to be a `Functor`.
13:12:09 <ski> however, those are still *conceptually* valid claims to make
13:12:27 <ski> <zincy_> could you not annotate a function func :: Maybe Int and just return Nothing
13:12:42 <ski> yes but then that's `func :: Maybe Int', not `Nothing :: Maybe Int'
13:12:45 <ski> you can't write
13:12:51 <ski>   Nothing :: Maybe Int
13:12:56 <ski>   Nothing = Nothing
13:13:05 <tty1> ski: is the thing im trying to do just not possible? 
13:13:20 <zincy_> ski: ah right gotcha
13:13:31 <zincy_> I need to sign off now for the evening :/
13:13:33 <tty1> ski: i guess i want t to have type * -> * and not *
13:13:56 <zincy_> ski: can we finish this tomorrow? I am learning a ton
13:14:30 <bss> class (Eq1 t, Ord1 t, stuff, Functor t) => Identified t i o | stuff where { ident :: forall a. (stuff) => t a -> i; obj :: t o -> o; } might work-ish.
13:14:39 <bss> tty1^
13:15:16 <tty1> bss:  is stuff something defined in prelude or is it something you are defining here?
13:15:24 <bss> I'm not sure if there's a `Hashable1` you could use.
13:15:41 <bss> tty1: Eq1 and Ord1 are in base, in Data.Functor.Classes
13:15:44 <ski> tty1 : not with `class ... => Identified t i o | t -> i o where ident :: ... => t -> i; obj :: t -> o', but if you changed that to `class ... => Identified f i o | f -> i where ident :: ... => f o -> i; obj :: f o -> o', then you could add `Functor f' as a superclass
13:16:34 <tty1> ski: let me tru copy and pasting that (if it works ill try to understand it)
13:16:38 <ski> tty1 : oh, and in this case, i think it would be better to not have `o' as a parameter of `Identified', only `f' and `i'
13:16:46 <bss> tty1: "stuff" was just where I didn't want to type the whole thing out or didn't know exactly what goes there.
13:17:20 <ski> tty1 : oh, and obviously, you'll have to replace `t' by `(f o)', in the other superclasses
13:17:21 <tty1> ski: right, o would actually define the argument of the functor so i figured that might be the case
13:17:41 <tty1> hmm
13:19:08 <ski> tty1 : bss suggestion is also worth considering (except i don't understand why they did the `forall a.' part, instead of using `t o -> i' there, as i did)
13:19:22 <tty1> ski: trying to copy paste in what you typed but im a bit confused what the whole bit looks like ...
13:19:41 <tty1> ski: i will try both but in his case i need to figure out what "stuff" is yet
13:19:47 <bss> ski: `f o` works there, too.  I was prematurely generalizing, which I should stop doing.
13:20:11 <ski> zincy_ : hm .. not sure i'll be online much tomorrow. but if you catch me later in the week, sure !
13:21:00 <ski> <tty1> ski: i guess i want t to have type * -> * and not *
13:21:19 <ski> my `f' had *kind* (*not* type) `* -> *', yes
13:21:32 <ski> (and same with bss's `t')
13:21:54 <tty1> ski: yea but in your version im still confused as to what goes in the "..." part
13:22:05 <ski> zincy_ : did you get that ?
13:22:38 <bss> class (Eq (t o), Ord (t o), Hashable (t o), Functor t) => Identified t i o | t -> i o where { ident :: (Eq i, Ord i, Hashable i) => t o -> i; obj :: t o -> o; }
13:22:59 <bss> tty1: See if that works, I think you need FlexibleContext for the `Eq (t o)` parts.
13:23:02 <tty1> ski im not one to try to just ask for a full answer. im just really confused on all this and the example would be helpful to learn from
13:23:03 <ski> tty1 : the `...' part is merely the lengthy class constraints you had, which i didn't bother to repeat
13:23:18 <tty1> bss: ahh ok thanks let me try that
13:23:20 <ski> tty1 : apart form the superclasses, those shouldn't be changed at all
13:23:57 <ski> tty1 : yes, i meant what bss (ty) now spelled out
13:24:17 <ski> tty1 : except that i'd probably also remove `o' as a parameter of the class
13:24:29 <ski> hmm
13:24:35 <bss> I don't know that you still want the `t -> o` fundep either.
13:24:40 <ski> oh, right !
13:24:46 <tty1> oh?
13:25:04 <ski> you can't actually do that ! without switching to `Eq1' and so on, which bss suggested
13:25:27 <ski> (`o' would not be in scope in the superclass constraints, if we removed `o' from being a parameter of the class)
13:25:56 <ski> bss : i'd say you definitely don't
13:26:15 <ski> bss : or, almost definitely, at least
13:26:18 <tty1> hmm im confused again, so the current solution isnt right? hmmm
13:27:37 <ski> bss : before we had `t -> o', but now we replaced `t' with `f o', so that becomes `(f o) -> o'. but obviously `f o' already depends on `o'. and in the example `f' was `Identity', which clearly doesn't depend on (nor determine) `o'. so the `(f o) -> o' FD can be simplified to just `o -> o', which trivially holds, so can be removed
13:27:49 <ski> tty1 : depends on what you want !
13:27:50 <tty1> that may be why i cant get the instance decleration to compile now.. hmm
13:28:26 <bss> The `t -> o` fundep is odd for a haskell Functor.  Functor are polmorphic on what is in them (one of the reason Set can't be a Functor).
13:29:03 <ski> (i'd consider the use of the term "polymorphic" there an abuse of terminology, fwiw)
13:29:23 <bss> parametric, then?
13:29:24 <ski> (if you said "parametric", then i'd be on board)
13:29:30 * ski smiles
13:30:19 <tty1> so what would my instance decleration look like now?
13:30:52 <bss> class (Eq (t o), Ord (t o), Hashable (t o), Functor t) => Identified t i o | t -> i where { ident :: (Eq i, Ord i, Hashable i) => t o -> i; obj :: t o -> o; }, maybe?
13:30:57 <ski> tty1 : .. i still suspect that you don't really want a type class here .. but thinking about this matter may perhaps teach you a thing or two that can be useful
13:31:22 <bss> Just dropped that one fundep.
13:31:55 <tty1> ski: i have no doubt this is bad design in general and when i get to actually writing my library for real it will look nothing like this. At this point i am just using it as an exercise to understand typeclasses in general. specifically with regards to kinds that arent just *
13:31:57 <ski> bss : looks reasonable (as far as this type class idea is reasonable at all, to begin with), to me
13:32:11 <tty1> bss thanks let me try that
13:32:39 <ski> tty1 : *nod*, that's fine in my book (as long as you're aware that that's what you're doing)
13:33:18 <tty1> bss: oops no thats the class you shared. That part compiled it is the instance declerations i cant quite figure out now
13:34:14 <bss> instance (Eq i, Ord i, Hashable.Hashable i) => Identified (Identity i) i o where
13:34:18 <tty1> hmm
13:34:26 <ski> `instance (Eq i, Ord i, Hashable.Hashable i) => Identified (Identity i) i o where ...' -- `Identity i o' as an actual parameter was replaced by just `Identity i', without the `o', since `f'/`t' in the class is explicitly being applied to `o'
13:34:26 <bss> ^^ your new instance line, I think the body should be good.
13:35:05 * ski low fours bss 
13:35:07 <tty1> Ok thanks, this compiled **finally** now i just need to attempt to understand it .. i think i can manage that if i stare long enough and play with it now
13:35:32 * bss does not leave ski hanging.
13:35:42 <tty1> bss and ski I cant thank you both enough. You guys have been very helpful (and ski thanks for the help on this in the past as well)
13:36:46 <ski> tty1 : btw, instead of `instance (Eq i) => Eq (Identity i o) where ...', you can just say `instance Eq i => Eq (Identity i o) where ...'. those brackets around `Eq i' there were redundant. mutatis mutandis for the `Ord' and `Hashable' instances
13:37:08 <ski> tty1 : similarly, `deriving (Show)' could be just `deriving Show'
13:37:21 <tty1> ski: thanks, that makes sense
13:37:49 * ski is sometimes a bit allergic to redundant brackets (unless they have been left in by choise, e.g. to emphasize a certain reading or pattern)
13:38:41 <bss> Okay, so back to my problems [;)], how do I do this as a recursion scheme instead of explicit recursion:
13:38:45 <bss> fixRecursivelyShrink' :: (Recursive f, Corecursive f, b ~ Base f, Arbitrary1 b) => b f -> [f]
13:38:46 <bss> fixRecursivelyShrink' = map embed . liftShrink fixRecursivelyShrink
13:38:48 <bss> fixRecursivelyShrink :: (Recursive f, Corecursive f, b ~ Base f, Arbitrary1 b) => f -> [f]
13:38:49 <bss> fixRecursivelyShrink = fixRecursivelyShrink' . project
13:38:53 <tty1> I usually just add excessive parenthesis everywhere then remove them when the compiler says I can :)
13:39:10 <bss> hlint loves warning about redundant brackets. :)
13:40:18 <ski> tty1 : anyway, as i said, bss's suggestion about using `Eq1 t',`Ord1 t',`Hashable1 t' in place of `Eq (t o)',`Ord (t o)',`Hashable (t o)' is worth considering .. then you could remove `o' from being a parameter of the class (and you'd probably need to add some of the constraints `Eq o',`Ord o',`Hashable o', to some of the method signatures, then)
13:40:43 <ski> bss : yes ! :D
13:41:29 <ski> (i don't always agree with the opinions of `hlint', but that's one thing i like about it, in general. of course, sometimes i leave in redundant brackets, by design. but that's another thing)
13:41:33 <ski> consider e.g.
13:41:54 <ski>   map :: ( a  ->  b )
13:41:55 <ski>       -> ([a] -> [b])
13:41:55 <tty1> ski: well its also a solution that is a bit harder for me to understand.. Im just starting to understand what `Eq` really means let alone what the hell `Eq1` is.. may be a better solution but i think i need to understand your solution first then move on to understanding his.
13:42:41 <bss> ski: I use a proportional font for chat, I'm assuming that's supposed to be aligned?
13:42:46 <ski> in this case the redundant brackets (around `[a] -> [b]') is by design, to emphasize a certain view of `map', as a function expressed in curried style, that transforms a function operating on elements into a function operating on lists
13:43:28 <ski> tty1 : `Eq1 f' means that `Eq (f a)' holds for every `a' with `Eq a' holding, basically
13:43:37 <ski> tty1 : and similary for the other ones
13:43:58 <ski> bss : yes
13:44:24 <tty1> ski: ohh yes that does sorta sound like exactly what im trying to do.. pass the "property" of being equatable from the thing inside the functor to the functor itself
13:44:38 <bss> Eq t means vlueof of type t can be tested for equality.  Eq1 t means you can lift equality tests into the functor (lowercase 'f') t.
13:45:13 <ski> bss : one could write it without the alignment as well, e.g. on a single line. but the alignment contributes to emphasizing the analog/parallel between the input function of type `a -> b', and the output function of type `[a] -> [b]'
13:45:31 * ski nods to bss
13:45:41 <tty1> bss: indeed that does sound like what im doing.. jesus criminies do they define some special thing for every edge case in haskell .. I mean kinda cool they do that.. though haskell looses some bonus points for picking really non descriptive naming :)
13:46:25 <[exa]> is there some good rationale or summary of the semantic difference between >> and *> ?
13:46:37 <ski> tty1 : sometimes unfamiliar naming, not loaded with potentially slightly incorrect connotations, is better than familiar (but slightly misleading) naming
13:46:55 <[exa]> (I'm kindof debugging my assumptions about the latter)
13:46:59 <bss> Eq1 is relatively new.
13:47:37 <tty1> ski: well i come from the Java world SoINameMyStuffLikeThisToEnsureItIsVeryDescriptiveAndAlsoGivesYouMuscleCrampsEveryTimeYouWriteIt :)
13:47:44 <bss> exa: *> and Applicative came later (than Monad and >>)?  I think that's about it.
13:47:49 <ski> [exa] : `ma >> mb' ought to be `ma >>= \_ -> mb'. so you can't (in the general case) statically extract info from `mb', before executing `ma'
13:48:08 <[exa]> ski: which is possible with *> ?
13:48:10 <ski> [exa] : however, that would often be possible, for `ma *> mb'
13:48:14 <[exa]> ohhhhhh
13:48:32 <ski> [exa] : it of course depends on the actual type which is being made an instance of `Applicative' vs. `Monad'
13:50:09 <ski> tty1 : "Execution in the Kingdom of Nouns" by Steve Yegge in 2006-03-30 at <https://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html>
13:51:47 <[exa]> ski: oh got the whole situation now, I had Maybe in the monad stack there which didn't "fire" when using *>, because the applicative instance wasn't actually matching anything. Thanks!
13:52:17 <ski> "wasn't actually matching anything" ?
13:56:02 <[exa]> ski: it didn't terminate if it saw Nothing on the left side. OTOH I see that's probably correct if I want the applicative symmetric
13:58:11 <ski> mhm
13:58:29 * ski isn't quite sure which monad stack is being considered
14:03:22 <[exa]> ski: sorry, I mixed it up
14:04:34 <arsdragonfly[m]> how do I recursively reinstall a package and its dependencies with profiling libraries?
14:11:11 <zincy_> ski: Speak later in the week :)
14:15:09 <bss> arsdragonfly: Cabal?  If so, I think toggle the global profiling flag, and then --reinstall, but I haven't done it in a long time.
14:21:44 <lukelau> Is there a way to “lift” a transformer using identity into a transformer using IO? e.g. I have `foo :: MyMonadT Identity ()`, and `bar :: MyMonadT IO ()` . Is there a function that can take `MyMonadT Identity ()` and bring it to `MyMonadT IO ()`?
14:25:40 <bss> lukelau: Yes.  I think it's normally called hoist or something like that.
14:26:39 <lukelau> bss: thanks, I had a feeling that it defeinitely existed in some form
14:27:02 <lukelau> I’m trying to keep IO out of my monad as much as possible, so this will be handy
14:28:46 <bss> https://hackage.haskell.org/package/mmorph-1.1.3/docs/Control-Monad-Morph.html#v:hoist with the first argument of https://hackage.haskell.org/package/mmorph-1.1.3/docs/Control-Monad-Morph.html#v:generalize
14:29:01 <Solonarv> ski: actually GADTSyntax is allowed for newtypes - you just write 'newtype Foo where...' instead of 'data Foo where...', and of course the exactly-one-constructor/exactly-one-field restrictions still apply
14:29:01 <Solonarv> ski again: the reason you aren't allowed to write 'data Maybe Int where...' is that, in GADT syntax, the "head" doesn't actually bind any type variables, contrary to what you said earlier; it serves only to define the kind of the datatype being declared
14:29:21 <Solonarv> lukelau: consider also just writing in terms of 'Monad m => ... -> MyMonadT m ()'
14:29:48 <Solonarv> then you still know that function can't do IO, but you don't need to 'hoist' at all
14:30:41 <bss> Solonarn : As an argument type `MyMonadT Identity ()` doesn't require `Rank2Types`, so it's nicer for some places.
14:34:05 <Solonarv> you still don't need Rank2Types for what I said
14:34:33 <bss> If you want to take it as an argument, you do.
14:34:37 <Solonarv> you just write top level functions like:
14:34:37 <Solonarv> doPureStuff :: Monad m => Foo -> MyMonadT m Bar
14:34:52 <Solonarv> and you can just specialize the argument type when you need to
14:34:59 <Solonarv> you don't have to force it to be polymorphic
14:35:04 <bss> imaginary :: (Monad m => MyMonadT m ()) -> Int
14:35:20 <bss> vs. imaginary :: MyMonadT Identity () -> Int
14:35:28 <Solonarv> yes, I would just write the second
14:35:56 <Solonarv> be polymorphic when you're producing a 'MyMonadT', monomorphic when taking one as an argument
14:36:05 <bss> +1, agreed.
14:36:47 <bss> That's actually a general principal.  For example, return `Lens s t a b`, but take as an argument `ALens s t a b`.
14:37:40 <Solonarv> yes, or 'Getting r s a', or whatever
14:39:49 <slack1256> Let's say I got `Data.Map k a` and a `key :: k` I checked it's on the map. How can I encode that the key is in the map, in such way later on I can pattern match on `lookup` only in the `Just` case?
14:40:04 <Solonarv> slack1256: justified-containers
14:40:09 <Solonarv> @hackage justified-containers
14:40:09 <lambdabot> http://hackage.haskell.org/package/justified-containers
14:40:38 <slack1256> Solonarv: Looks promising!, thanks! :-D
14:40:44 <Solonarv> although it's quite heavy on the type wizardry IIRC
14:43:35 <slack1256> I am more interested on how such type wizardry is used
14:46:52 <c_wraith> slack1256: http://kataskeue.com/gdp.pdf  describes the techniques used in justified-containers, as well as how to use such things with other libraries
14:50:19 <arsdragonfly[m]> should I look at haskell's +RTS stack trace from a very different perspective
14:50:32 <arsdragonfly[m]> since everything is lazily evaluated
14:50:48 <monochrom> Yes.
14:51:24 <arsdragonfly[m]> ooops
15:27:36 <mac10688> hello
15:27:55 <mac10688> wow this is cool. command line irc
15:50:14 <MarcelineVQ> If you were going to make bindings for a modern gui lib for haskell what one would you pick? Or if you were going to use an existing haskell package, which one?
15:51:44 <MarcelineVQ> That feels unclear. I'm asking "what gui libs interest you currently?" :>
15:57:42 <hpc> something easy to use on every os would be the dream
15:58:54 <hpc> i don't know what the easiest lib on windows is though
16:01:13 <MarcelineVQ> last I ​used on windows was webkit, slightly cheating that is
16:08:05 <dmwit> GUI libs sort of fall in my "don't really care" zone. I've used GTK for some stuff before and it seemed fine, so I'd probably reach for that again just to avoid sinking a lot of time into learning a new one.
16:09:45 <lukelau> MarcelineVQ: I would like to see something like what Racket does, which abstracts over all bindings and instead chooses the most native solution for each platform. So on linux it binds to gtk, mac it binds to cocoa etc.
16:11:15 <nisstyre> lukelau: it probably does that using parameters
16:11:59 <nisstyre> people seem to dislike the equivalent in Haskell which is implicit params
16:12:46 <nisstyre> I guess you could do it without that
16:15:01 <d34df00d> Hi!
16:15:41 <d34df00d> I have a function that's trying to extract top-most strings surrounded by {} from a lazy ByteString: https://bpaste.net/show/109a11c38cbc
16:16:05 <d34df00d> Is there a way to make this O(1) on memory? Algorithmically, it should be possible, but I'm not sure how to express that neatly.
16:21:19 <hololeap> what's the best way to defer several computations of Floats until the end, so that rounding errors are minimized?
16:21:47 <hpc> if they're really Float, just use Double perhaps
16:25:20 <tty1> Am I the only one that finds haskell syntax so "intuitive" its counter intruitive... like sometimes it feels like its written to talk to a human more so than a compiler?
16:25:46 <tty1> usually when i see a correct syntax after i struggle with how to express something I go "Holy crap you can do that!"
16:26:33 <tty1> bss still around?
16:32:05 <hpc> tty1: learn enough other languages and nothing is intuitive :P
16:32:41 <tty1> hpc: :)
16:32:43 <hpc> there's definitely a lot about haskell that takes away complication
16:33:05 <hpc> so like, there's a neat idea in TDD called mutation testing
16:33:31 <hpc> you have f(args) {definition}, and a test suite which is a map of inputs to outputs
16:33:36 <tty1> hpc: yea ive played with mutation testing before, cool stuff
16:33:41 <hpc> the tests pass if f(input) maps to output, etc
16:33:43 <hpc> oh, that makes this easy
16:34:00 <hpc> so imagine a mutation tester with all the smarts taken out
16:34:12 <hpc> it doesn't know about tokens or logic, it just does things
16:34:25 <hpc> and the goal is to make all the small changes away from a correct program fail to compile
16:34:40 <tty1> ok
16:35:11 <hpc> i think part of what makes it so easy to read is, haskell is good at that sort of testing
16:35:17 <dmwit> hololeap: You might like https://github.com/mikeizbicki/HerbiePlugin
16:35:48 <hpc> small changes away from correct tend to stand out
16:35:53 <hpc> like a case statement
16:36:23 <hpc> the smallest way to screw up a case-of expression is duplicate or overlapping patterns
16:36:44 <hpc> or missing patterns
16:37:00 <hpc> but if you know the data type, it's pretty much a copy-paste job to see that the patterns are written properly
16:37:14 <dmwit> Um.
16:37:20 <dmwit> This line of reasoning is a bit odd.
16:37:35 <dmwit> I think in most languages, a non-syntax-aware mutator is mostly going to produce invalid programs.
16:37:44 <dmwit> Haskell is not special there.
16:38:36 <arsdragonfly[m]> has anyone run into problems with c2hs recently?
16:38:36 <arsdragonfly[m]> https://github.com/haskell/c2hs/issues/237
16:38:49 <arsdragonfly[m]> it's completely broken for me
16:38:58 <hpc> the top two languages are python and javascript
16:39:11 <hpc> if you typo any variable name in either language, it just defines a new variable instead
16:39:20 <tty1> hpc makes sense
16:39:46 <dmwit> hpc: That's a pretty low bar to clear, though.
16:39:57 <hpc> yeah
16:39:59 <hpc> but that's where the bar is
16:40:11 <dmwit> Haskell does some stuff that is so, so much cooler than mere scope-checking.
16:40:41 <hpc> sure, but the original comment was on syntax :P
16:40:47 <lukelau> nisstyre: I think its just dependent on the distrbution of racket that you get
16:41:00 <lukelau> Like the mac distribution is built with cocoa etc.
16:41:13 <lukelau> so not necessarily a parameter
16:41:58 <hpc> anyway the point of all that was, when you're reading the code it's a huge thing to not worry about
16:42:21 <hpc> when i am reviewing non-haskell code at work, i find myself always searching for typos
16:42:27 <hpc> and often finding them
16:44:09 <hpc> it's one less thing preventing the idea in the code from getting across
16:49:25 <dmwit> I am on board with that.
16:50:41 <lukelau> Is `read (show x) === x` a law
16:51:03 <hpc> > read (show (0/0))
16:51:05 <lambdabot>  *Exception: Prelude.read: no parse
16:51:10 <hpc> almost
16:51:29 <hpc> but floats are weird, and i think that's the only exception
16:52:05 <lukelau> > read (show (32.12341324123))
16:52:07 <lambdabot>  *Exception: Prelude.read: no parse
16:52:16 <lukelau> > show 23.2342123
16:52:18 <lambdabot>  "23.2342123"
16:52:32 <lukelau> Might need a type annotation
16:52:56 <hpc> the documentation for Read/Show only talk about derived instances
16:53:27 <geekosaur> it's not a law; it is generally an expectation
16:53:44 <geekosaur> (but often violated in various ways, including "best effort")
16:53:57 <Solonarv> @check \x -> read (show x) == (x :: Float)
16:53:59 <lambdabot>  +++ OK, passed 100 tests.
16:55:08 <dmwit> > 0/0
16:55:10 <lambdabot>  NaN
16:55:17 <dmwit> > read (show (0/0)) :: Double
16:55:19 <lambdabot>  NaN
16:55:41 <dmwit> So I would say even for Double, read (show x) === x.
16:55:47 <Solonarv> yes, well, if you use an actual equivalence relation :>
16:56:01 * Solonarv grumble grumble IEEE 754 stupidity
16:56:01 <dmwit> Hey, lukelau was very careful in their initial question!
16:56:02 <lukelau> @check \x -> read (show x) == (x :: Ratio Float)
16:56:04 <lambdabot>  error:
16:56:04 <lambdabot>  • No instance for (Integral Float) arising from a use of ‘myquickcheck’ • In...
16:56:06 <Solonarv> indeed!
16:56:42 <dmwit> Anyway there's a bunch of exception types that don't satisfy it, as I discovered to my detriment this week.
16:56:49 <Solonarv> @check \x y -> let q = x/y :: Double in read (show q) == q
16:56:51 <lambdabot>  *** Failed! Falsifiable (after 1 test):
16:56:52 <lambdabot>  0.0 0.0
16:56:55 <dmwit> But it's generally considered good practice to abide by that rule in your own types.
16:57:07 <Solonarv> stupid broken Float/Double operations
16:57:23 <hpc> basically always use deriving and you'll be fined
16:57:25 <hpc> *fine
16:57:43 <Solonarv> they break Ord/Eq, they break Num being a ring, their Enum instance is weird...
16:57:57 <lukelau> I think floating point arithmetic gets a pass
16:58:31 <lukelau> My use case is more that I never intend on Show being remotely compatible with my Read instance 
16:58:40 <lukelau> And I’m wondering how taboo this is
17:00:08 <lukelau> @check \x -> read (show x) == (x :: Complex Double)
17:00:11 <lambdabot>  +++ OK, passed 100 tests.
17:00:45 <lukelau> @check \x -> read (show x) == (x :: Fractional (Complex Float))
17:00:47 <lambdabot>  error:
17:00:47 <lambdabot>  • Expected a type, but ‘Fractional (Complex Float)’ has kind ‘Constraint’ • ...
17:02:10 <hololeap> dmwit: what's the best way to convert to/from float and double?
17:04:50 <bss> tty1: I'm back; did you need me specifically?
17:06:00 <tty1> bss: was going to ask you about implementing eq1 instead of q but am off to bed now, maybe ill catch you tomorrow. Thank you though.
17:06:08 <dmwit> hololeap: realToFrac, I guess. round/floor/ceiling if you need out.
17:07:00 <bss> lukelau: I always try and make read . show = id, and have different names for "show"ing and "read"ing other formats.
17:07:59 <bss> It sometimes means I have to explictly pass aroung a an `String -> m a` or `a -> String`, but I find it makes playing around with the code nicer in GHCi is read . show = id.
17:09:28 <hololeap> i'm also seeing float2Double# in GHC.Exts, but i don't understand the #'s that are all over the place in there
17:09:53 <bss> hololeap: # is related to MagicHash
17:10:26 <bss> hololeap: # is related to unboxed types too.
17:10:34 <hololeap> this says not to use realToFrac: https://wiki.haskell.org/Converting_numbers
17:10:57 <hololeap> https://wiki.haskell.org/Converting_numbers#Converting_between_different_floating-point_precisions
17:12:10 <Solonarv> I'm pretty sure there are rewrite rules to turn realToFrac into floatToDouble / doubleToFloat
17:13:20 <Solonarv> bss: hololeap: # isn't inherently related to anything; it's a convention to give primitive operations and types names that end in #
17:13:36 <Solonarv> MagicHash is needed to allows this syntactically but otherwise doesn't do anything special
17:14:54 <bss> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Float.html#double2Float the floatToDouble and doubleToFloat methods are still in GHC.Float.
17:15:26 <bss> I'm not sure why the haddocks don't generate right for those modules, but the hyperlinked src still does.
17:16:45 <bss> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Float.html#word2Float also does confirm the REWRITE rules for readToFrac are in place so if it is used monophically you don't have to worry about Rational not being able to store NaN.
17:17:28 <bss> Solonarv: Isn't # the old kind for unboxed types, too?
17:17:45 <Solonarv> yes, I had forgotten about that
17:18:06 <Solonarv> by the time I learned about how unboxed stuff is handled in the kind system it was not # anymore
17:19:10 <hpc> same
17:19:16 <hpc> i am just glad i didn't have to learn ? and ??
17:19:31 <Solonarv> what even were those
17:19:47 <hpc> :k (->)
17:19:49 <lambdabot> TYPE q -> TYPE r -> *
17:19:56 <hpc> that used to be ? -> ?? -> *
17:20:14 <bss> I forgot.  Maybe something related to ad-hoc kind polymorphism or something?
17:20:30 <hpc> it was something like either * or #, but not an unboxed tuple
17:20:42 <Solonarv> oh, oof
17:20:48 <hpc> yeah
17:33:15 <redrapscallion> Haskell newbie here. I'm trying to use wreq to make a GET request to a web page and then output the body response, but I'm completely unsure why my types won't match up. https://gist.github.com/redrapscallion/ef89a72934120bdc577f951014347b16
17:35:52 <bss> redrapscallion: looking
17:36:43 <bss> Oh, the type of your function will be `IO ByteString`, not `ByteString`.
17:37:16 <redrapscallion> bss: does "do" automatically wrap my result in IO? 
17:37:16 <bss> Once you do `IO` you never totally get out of it.
17:37:43 <bss> redrapscallion: No, it's just syntax sugar that works in any monad.
17:39:59 <bss> do { stmt } ~~> stmt; do { let vars = exprs; stmts } ~~> (\vars -> do { stmts }) exprs; do { v <- stmt; stmts } ~~= stmt >>= do { stmts }.
17:40:37 <bss> Outside of ever wierder things, all the statements in a do-block have to be in the same monad.
17:41:12 <Solonarv> bss: your 'let' desugaring is slightly incorrect
17:41:23 <bss> So, it's actually that used `get "http://httpbin.org/get"` that put you in "IO".
17:41:39 <bss> Solonarv: I know, vars are recusrively bound.
17:41:46 <Solonarv> I don't remember exactly what the difference is, but 'let x = expr in body' is not the same thing as '(\x -> body) expr'
17:42:10 <Solonarv> you could just translate using 'let', which is also how the Haskell Report specifies do notation
17:43:14 <bss> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-440003.12 is the full desugar for let, but it's essentially just (\vars -> x) exprs.
17:43:43 <bss> It's explicitly irrefutable patterns and recursive bindings, but that's about it.
17:47:05 <Solonarv> ⟦ do {          expr; stmts } ⟧ = expr >>          ⟦ do { stmts } ⟧
17:47:05 <Solonarv> ⟦ do { pat  <-  expr; stmts } ⟧ = expr >>= \pat -> ⟦ do { stmts } ⟧ *
17:47:05 <Solonarv> ⟦ do { let { binds }; stmts } ⟧ = let { binds } in ⟦ do { stmts } ⟧
17:47:05 <Solonarv> * note: more complicated for refutable patterns, e.g. 'Just x <- blah'
17:48:09 <dmwit> (\vars -> x) exprs makes all the vars monomorphic. let vars = exprs in x doesn't.
17:48:22 <dmwit> > let f = id in (f "hi", f True)
17:48:24 <lambdabot>  ("hi",True)
17:48:26 <bss> Sure, I also desugared let .. in, too.
17:48:31 <dmwit> > (\f -> (f "hi", f True)) id
17:48:33 <lambdabot>  error:
17:48:33 <lambdabot>      • Couldn't match expected type ‘[Char]’ with actual type ‘Bool’
17:48:33 <lambdabot>      • In the first argument of ‘f’, namely ‘True’
17:49:57 <redrapscallion> bss: Hmm, IO ByteString doesn't work as the correct type either. It tells me it couldn't match expected type IO ByteString with actual type ByteString. 
17:50:04 <redrapscallion> which is weird because the original type I used *was* ByteString.
17:50:43 <bss> redrapscallion: Yeah, you need to return / pure the last line.
17:51:48 <bss> redrapscallion: The documentation in the wreq package is a bit confusing, because GHCi does special things.
17:53:13 <bss> redrapscallion: If you give GHCi something that is `IO a` it will execute it and print the result; if you give it anything else, it will just print that.
17:54:15 <bss> redrapscallion: So, while the documentation is a valid GHCi session, it hides the fact that you'll need some `return` / `pure` calls when writing in source instead of at the REPL.
17:57:52 <redrapscallion> bss: how am I supposed to find out what monad it'll wrap my result in after I use return? It's neither IO ByteString nor Response ByteString, and GHCI just tells me it's some Monad m.
17:58:05 <bss> getHttpBinResponse :: IO ByteString; getHttpBinResponse = do { r <- get "http://httpbin.org/get"; pure $ r ^. responseBody } should work.
17:58:22 <bss> rerapscallion: `return` and `pure` will work in any Monad.
17:58:42 <c_wraith> type inference will figure out which
17:58:50 <c_wraith> haskell type inference has no trouble working on return types
17:58:53 <bss> redrapscallion: It'll use whatever one matches the surrounding context, or complain about an ambigous type.
17:59:01 <c_wraith> unlike some other languages
17:59:29 <bss> redrapscallion: You can use an explicit ascription if you want, though I don't recommend it.
18:00:03 <bss> getHttpBinResponse :: IO ByteString; getHttpBinResponse = do { r <- get "http://httpbin.org/get"; (pure :: a -> IO a) $ r ^. responseBody } has an ascription.
18:01:13 <bss> getHttpBinResponse :: IO ByteString; getHttpBinResponse = do { r <- get "http://httpbin.org/get"; pure (r ^. responseBody) } might be easier to read for now, though a LOT of Haskell code make wide use of the $ operator.
18:01:15 <redrapscallion> oh my god, I forgot to use $ lol
18:38:10 <Average-user> Someone knows some converter from literate haskell to markdown? I can't seem to find quite it
18:39:37 <hpc> pandoc probably?
18:45:13 <bss> Average-user: https://pandoc.org/MANUAL.html#literate-haskell-support
18:45:46 <Average-user> bss: uwu, thanks. I'll look it up
19:18:47 <qualiaqq> Anyone familiar with setting up tests using cabal know if the module to test has to be exposed in `exposed-modules:` in a library? I can't seem to import the function I want to test unless I set it up this way.
19:19:57 <geekosaur> it must, because if it is not in exposed-modules, the only way to get access is to load it as source in ghci / an interpreter
19:22:35 <qualiaqq> Alright, that's fine. I just wasn't sure if I could get away with not having a `library` and not exposing the module for a toy project.
19:35:45 <bss> qualiaqq: Current practice is use exposed-modules for any API, and stick non-public API into .Internal modules.
19:37:11 <bss> qualiaqq: I have heard suggestion that it might be better to just carve off the .Internal modules into their own package, but that is a lot more "fiddly" for deploying things, so I doubt it will catch on.
19:37:56 <qualiaqq> but internal modules can't be tested by a test suite?
19:39:24 <bss> As long as they are exposed, they can be tested and .Internal modules are exposed, they are just (by convention) not considered part of the API (for version bumps, etc.)
19:39:42 <bss> *public API
19:43:31 <qualiaqq> bss, oic
19:47:38 <dmwit> qualiaqq: You can also just list the appropriate directory in your test-suite's hs-source-dirs. It'll rebuild it (i.e. not use the already-built copy in the library) but at least your public API doesn't have to change.
19:47:58 <dmwit> Don't depend on the library if you do this, obviously.
20:06:13 <mac10688> What kind of function am I looking for to help me with my problem. My problem is that I want to take a string and possibly parse it into a datetime, if it isn't a datetime, I'll see if it's a phonenumber, then I'll see if it's a word or just a regular number.
20:06:30 <mac10688> so there's a tryparse function that will return a Maybe Datetime
20:06:53 <mac10688> if it's none, how do I move to the next parser until it finds something?
20:07:19 <mac10688> I've done this before but I forget what it's called
20:07:25 <qualiaqq> dmwit: thanks I'll look into that
20:07:43 <sarahzrf> mac10688: if this is a backtracking parser, you could dispatch on whether it's Nothing and fail if so
20:07:53 <bss> mac10688: The "First" monoid?
20:07:56 <sarahzrf> > :i MonadFail
20:07:58 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
20:08:00 <sarahzrf> hm
20:08:04 <sarahzrf> % :i MonadFail
20:08:04 <yahb> sarahzrf: ; <interactive>:1:1: error: Not in scope: `MonadFail'
20:08:06 <sarahzrf> aw
20:08:46 <mac10688> that monadfail, i've seen that
20:09:24 <sarahzrf> well, if there *is* such a class, i would imagine that there's something like "MonadFail m => Maybe a -> m a"
20:09:25 <ski> @tell Solonarv (re `GADTSyntax' and `newtype') ok, i think that's new, then ? i think i have a memory of it not working. "the \"head\" doesn't actually bind any type variables" -- i know, i was talking from a conceptual standpoint. i suppose i could have been clearer (although it was getting fairly long)
20:09:25 <lambdabot> Consider it noted.
20:10:10 <mac10688> http://hackage.haskell.org/package/time-1.9.2/docs/Data-Time-Format.html#g:2
20:10:16 <mac10688> yeah m is a MonadFail type
20:12:09 <mac10688> I applied for a job to maintain a haskell project but eventually they want to move it to c# in a few years. It sucks I would be taking away haskell but I would love the opportunity to maintain a haskell application to put on my resume
20:12:54 <bss> Convert to F# instead.  You lose laziness and HKT, but gain the CLR, and the porting should be slightly easier.
20:13:32 <mac10688> That sounds good in theory but I know c# pretty good right now and I'll be busy enough getting up to speed on haskell
20:13:37 <mac10688> not trying to drown myself
20:13:42 <bss> :)
20:14:01 <mac10688> i don't know f# well enough to write production code for a company paying me professionaly
20:14:34 <bss> So, do you already have a single datatype that can hold OR(datetime, phonenumber, word, number)?
20:14:44 <mac10688> yeah i was making that
20:16:47 <mac10688> what's the highest abstraction of number in haskell that covers floats and integers?
20:17:04 <mac10688> natural numbers that is
20:17:11 <bss> getFirst . mconcat . map (First .) [ datetime2variant . parseMaybeDatetime, phonenumber2variant . parseMaybePhonenumer, word2variant . parseMaybeWord, number2variant . parseMaybeNumber ]
20:17:30 <mac10688> ohh
20:17:50 <bss> Rational?  Or maybe Scientific?
20:18:32 <mac10688> rational looks good enough for me
20:19:04 <mac10688> I miss this chatroom, I hope i get this job so I'll have more reason to stay in here
20:19:09 <mac10688> thanks bss 
20:19:21 <bss> A JS Number is just Double.  It doesn't handle all Integers / Naturals, but it handles a range, it doesn't have infinite precision but generally enough.
20:19:24 <qualiaqq> mac10688: Moving code from Haskell to C# seems like such a mistake imo. I guess you'd have no argument there. I work professionally in C# and wish I could move our stuff on Haskell or F#, but both are it's too hard to get people on board.
20:20:03 <bss> I work in Java 8, Python 2.7, and ES 5 most of the time. :)
20:20:11 <bss> My down time is Haskell programming. :)
20:20:48 <mac10688> I would just be happy to put haskell on my professional resume. I'm not gonna try to argue with the director who's looking to hire me. You want me to maintain it for a year, ok! I'll do it
20:20:55 <mac10688> then the next job might be a full time haskell dev
20:20:57 <mac10688> omg
20:21:17 <mac10688> I'll take it anyway I can
20:21:29 <qualiaqq> mac10688: I'd probably jump on that opportunity also. I don't blame you.
20:23:20 <bss> Instead of the getFirst / First nonsense, the Alternative instance of Maybe is probably enough.  It's not as points-free, but it might be less to learn.
20:24:24 <mac10688> anyone use command line weechat? I don't know how to scroll up
20:24:38 <slack1256> use glirc2 :-P
20:24:39 <mac10688> that rings a bell bss
20:24:41 <bss> parseVariant s = datetime2variant (parseMaybeDatetime s) <|> phonenumber2variant (parseMaybePhonenumber s) <|> word2variant (parseMaybeWord s) <|> number2variant (parseMaybeNumber s)
20:24:59 <mac10688> bss that totally looks familiar! I did something like this in the haskell book
20:25:02 <mac10688> that's what I want
20:25:15 <bss> Search / reference "Alternative", then.
20:25:35 <bss> That's (one place) where the <|> operator is defined.
20:27:47 <bss> mac10688: https://weechat.org/files/doc/devel/weechat_user.en.html says [PgUp] / [PgDn] should work, or /window page_up and /window page_down
20:28:39 <mac10688> thanks!!
20:28:46 <mac10688> ok i have enough information to move forward
20:28:50 <mac10688> thanks bss
20:28:55 <bss> Best of luck.
20:29:04 <bss> See if you can maintain it so good, they have to stick with HAskell. ;)
21:39:49 <JesusIsGodAlmigh> Hello
21:42:07 <JesusIsGodAlmigh> jennie: hello
21:42:40 <bss> JesusIsGodAlmigh: Hello.
21:44:34 <JesusIsGodAlmigh> <bss "Jesus Is God Almighty Jehovah: H"> bss: HEY!!!
21:44:57 <JesusIsGodAlmigh> This looks pretty good
21:45:10 <JesusIsGodAlmigh> Without much lunacy
21:45:15 <glguy> JesusIsGodAlmigh: Did you have a question about Haskell?
21:45:15 --- mode: ChanServ set +o Cale
21:46:02 <JesusIsGodAlmigh> Oh no, not really just looking into the program iv just installed it.
21:46:31 <JesusIsGodAlmigh> Was trying to find some life glguy
21:46:56 <JesusIsGodAlmigh> glguy: this seems a little like IRC
21:47:05 <Cale> This is exactly IRC
21:47:15 <JesusIsGodAlmigh> Running very smooth as well.
21:47:30 <JesusIsGodAlmigh> Oh.....
21:47:51 <Cale> You're connected via a matrix bridge
21:47:56 <JesusIsGodAlmigh> Well with some updated graphic?
21:48:12 <JesusIsGodAlmigh> Cale: ahhh
21:48:28 <Cale> I don't know exactly what you're looking at, but you could use any IRC client to connect to irc.freenode.net and join #haskell and you'd be here
21:49:11 <JesusIsGodAlmigh> Cale: ahhhh interesting
21:49:55 <DarkiYahu> hello
21:50:00 <Cale> hello
21:50:10 <DarkiYahu> ohhh it worked :)
21:50:33 <DarkiYahu> its me Jesus Is God Almighty Jehovah
21:50:45 <DarkiYahu> on the irc client
21:50:59 <DarkiYahu> neat
21:51:28 <JesusIsGodAlmigh> DarkiYahu: there i am on the irc program :)
21:51:38 <ski> are you thinking of looking into Haskell ?
21:51:55 <JesusIsGodAlmigh> Me?
21:51:58 <ski> yes
21:52:45 <Cale> Yeah, if you're not interested in programming in Haskell, this is the wrong channel to be in
21:53:04 <JesusIsGodAlmigh> I have no idea what it is. I was just looking at the librem program sorry to be off topic.
21:53:15 <ski> it's a programming language
21:53:24 <ski> a "functional programming language"
21:53:39 <JesusIsGodAlmigh> Roger that - was just testing the Librem program chat :)
21:53:54 <ski> based around the idea of evaluating expressions, and feeding inputs to functions (like in math), getting back outputs
21:53:58 <JesusIsGodAlmigh> And seeing what it was
21:54:11 * ski has no idea what Librem is
21:55:05 <JesusIsGodAlmigh> Librem is the company that focus on freedom
21:55:40 <JesusIsGodAlmigh> They make labtops with linux and are making a phone at the momemt.
21:55:55 <Cale> Purism is the company, Librem is what they name every single one of their products for some reason :)
21:56:19 <JesusIsGodAlmigh> https://puri.sm/
21:56:35 <JesusIsGodAlmigh> Cale: thanks
21:57:49 <JesusIsGodAlmigh> Much interested in the phone hope it works out well for them.
21:58:18 <JesusIsGodAlmigh> I'm on the librem chat at the moment trying it out. Seems to work great.
21:58:55 <Cale> Yeah, but this would be the wrong channel to discuss it really. At least go to #haskell-offtopic (though probably there's something altogether more appropriate)
21:59:20 <DarkiYahu> it seems to cut the nsme in the irc client... but it works in the librem program.
22:00:03 <JesusIsGodAlmigh> True sorry guys and thanks have a good day :)
22:00:29 <Cale> There is a #purism which you might prefer to join :)
22:01:21 <DarkiYahu> thanks :)
22:07:04 <j2> hi all :)
22:07:28 <ski> hello j2
22:07:51 <j2> I had a q regarding servant - does anyone have a general quickstart config / setup? For context, it's my first API tutorial, been playing around with haskell for a while
22:08:50 * ski doesn't know about `servant', sorry
22:09:19 <bss> j2: Might look around for some ICFP / CUFP videos.
22:09:27 <ski> (perhaps someone else will answer, if you stick around for a while. at least half an hour, i'd suggest. preferably more)
22:10:04 <bss> j2: ISTR attended a servant tutorial at one ICFP, it started small but did assume you had some Haskell under your belt.
22:11:23 <bss> Aynone know LLVM?  Am I allowed to use multiple phi instructions?  Or do I have to use some sort of tuple/struct type and a single phi?
22:12:10 <ski> hm .. iiuc, i think you're allowed to use multiple ones, as long as there's no other kind of instruction inbetween they start of the basic block, and them ?
22:14:03 <bss> Yeah, they were all going up front.  I just need to "pass" 4 values to the next iteration of my SECD implementation.
22:14:46 <j2> cool - thanks for the heads up :) 
22:48:41 <iqubic> I just solved, by hand, a 26 equation set of simultaneous Boolean equations. Each of the equations had the form of "A = !(B -> C)" Where it's one variable on the LHS and a single binary operation with two different variables on the RHS.
22:50:31 <bss> iqubic: doesn't that simplify to 2sat ?
22:51:07 <bss> iqubic: I mean, still, good job.  I don't think I'd stick through that.
22:51:39 <iqubic> One of the equations was "D = Y && R" Where Y is False and R is True, which makes D False.
22:51:54 <iqubic> bss: What is 2Sat?
22:52:04 <bss> I'd probably just write something to brute force the 2^26 possible assignments.
22:52:15 <bss> It's the little brother of 3Sat (seriously).
22:52:56 <iqubic> I was thinking about brute forcing it, but this was part of a puzzle hunt, so I wanted to do it myself.
22:53:08 <bss> https://en.wikipedia.org/wiki/Boolean_satisfiability_problem#3-satisfiability (3SAT)
22:53:14 <bss> https://en.wikipedia.org/wiki/2-satisfiability (2SAT)
22:53:28 <iqubic> This particular set of equations was created by a human, So I knew there had to be a way to solve it by hand.
22:54:27 <___laika> hello all. im curious if there's a convenient way to write a case insensitive parser for an ADT based on its Read instance, say for `data Foo = Bar | Baz deriving (Read, Show)`, `(foo :: Parser Foo) "bAr" = Bar` (roughly, not sure if i nailed the parser type signatures)
22:54:58 <___laika> i figure i can leverage Data.CaseInsensitive, but I'm not sure i see exactly how
22:55:06 <iqubic> Also, none of the equations were in conjunctive normal form.
22:55:10 --- mode: Cale set -o Cale
22:55:22 <Cale> I don't think there's anything especially convenient
22:55:28 <bss> Anything with fewer than 32 variables can be brute forced on CPUs from 15 years ago.  I imagine GPUs from today can brute-force several more.
22:56:02 <iqubic> bss: I know that. I just didn't feel like writing the code. I wanted the challenge of doing it by hand.
22:56:34 <iqubic> In the end it turns out that only 7 out of the 26 variables had the value of True.
22:56:46 <bss> __laika: I agree with Cale, there's not a really good way to introspect a String -> Int -> ReadS. :/
22:58:29 <___laika> writing a relatively simple CLI app, would it be worth pulling in megaparsec as a dependency for the `string'` parser?
22:58:32 <iqubic> What is ReadS? It looks a little like a singleton.
22:59:05 <___laika> or maybe that wouldn't actually help much...
22:59:29 <Cale> ___laika: It might be worth pulling in megaparsec as a dependency just to write the parser you want by hand
23:00:00 <Cale> If it really follows the structure of the types like that, it should be relatively easy to write in applicative style
23:00:01 <bss> __laika: The GHC-specific ReadPrec stuff isn't much easier to introspect either, so I think you are stuck, unless you are writing the Read instance yourself, then you could probaly reuse code.
23:00:47 <Cale> lol, you might be able to do something with -ddump-deriv
23:01:47 <bss> __laika: If megaparsec is too big, you can still use attoparsec or parsec.  Any of them should be relatively simple to write a small parser in.
23:02:20 <___laika> what im trying to do is parse HTTP methods from the command line in a type safe way, would i be better off just defining several value level parsers that match the strings i want and <|>'ing them?
23:02:32 <bss> iqubic: https://hackage.haskell.org/package/base-4.12.0.0/docs/Text-Read.html#t:ReadS
23:02:42 <Cale> ___laika: that's how I'd do it
23:02:53 <iqubic> How would you write a program to brute force my binary satisfaction puzzle?
23:03:08 <thornAvery> i have a function f :: a -> b -> c -> Bool, why cant I use (not . f) without getting a type error?
23:03:11 <Cale> iqubic: Perhaps the list monad
23:03:29 <Cale> thornAvery: Because the result of f is a function of type b -> c -> Bool
23:03:33 <Cale> which you can't apply not to
23:03:43 <___laika> Cale: ill experiment with that style
23:03:44 <bss> thornAvery: Look at the type of `(.)`.  It takes to functions of single arguments.
23:05:41 <bss> iqubic: I'd map the letters to bit indexes, build up a `Word32 -> Bool` out of the stuff from Data.Bits, and then iterate over [minBound..maxBound] :: [Word32].
23:05:51 <Cale> You could write ((not .) .) . f -- but that's not terribly idiomatic. You're far better off just using a lambda.
23:06:23 <bss> \av bv -> not . f av bv
23:06:36 <iqubic> But how do you write a function that test all 26 equations for the correctness?
23:07:43 <bss> iqubic: parse the input expressions, build it up that way.
23:09:02 <bss> For example `A = !(!B || C]` -> `bitSet 0 n = not (not (bitSet 1 n) || bitSet 2 n)`
23:10:26 <jle`> thornAvery: remember that (.) isn't magical syntax, it's just a normal function with a normal type
23:10:59 <bss> iqubic: You've only got like 4 operators, so it's an easy parser to write.  And, you parse each into a [Word32 -> Bool] and then fold those together with liftA2 (&&)
23:11:51 <iqubic> Actually I have several. AND, NAND, OR, NOR, XOR, XNOR, and implicatin.
23:12:38 <iqubic> How do I create a functino based on a value at compile time? Doesn't that require Template Haskell?
23:12:46 <bss> iqubic: 8 then (+NOT), but all should be pretty trivial.
23:12:53 <bss> iqubic: Not, not at all.
23:13:44 <Cale> > let bit = [False, True] in do a <- bit; b <- bit; c <- bit; guard (a == not (not b || c)); return (a,b,c)
23:13:46 <lambdabot>  [(False,False,False),(False,False,True),(False,True,True),(True,True,False)]
23:13:54 <iqubic> See, each equation has only 1 operator and 1 not at most. And the not is never on the LHS.
23:14:12 <Cale> You can of course, try to rearrange the selections to move guards earlier
23:14:17 <bss> iqubic: Oh, well, you could use template haskell.  I'm thinking of parsing the input file at startup.
23:14:32 <Cale> I would probably write this code by hand, it would still be easier than actually doing the logic by hand :)
23:14:54 <iqubic> I know. But I did the logic by hand already.
23:15:02 <jle`> iqubic: making a value that depends on a value at compiletime does not require TH.  making data type/constructor names and typeclasses and stuff does, though, generally
23:15:14 <Cale> Do you have a listing of the equations?
23:15:20 <iqubic> I do.
23:15:23 <bss> Yeah, it's only 26 equations, I might not parse them at all, and just write the final Word32 -> Bool by hand.
23:15:26 <Cale> (for us)
23:16:57 <Cale> I'd probably start out just using Bool and not trying to be memory efficient with Word32 or whatever
23:20:07 <bss> Cale: Could work, L1 caches are huge these days.
23:22:23 <Cale> Well, depending on how clever you are about ordering the search space, it might not take all that long
23:42:19 <qwebirc10127> When I run 'curl https://get-ghcup.haskell.org -sSf | sh' the program says I need to install 'xz'
23:43:42 <[exa]> qwebirc10127: what distro are you using?
23:43:58 <qwebirc10127> I am running macos
23:43:59 <[exa]> xzip should be available in most packaging systems around
23:44:11 <[exa]> so it's probably something like brew install xz
23:44:31 <qwebirc10127> right... right. 
23:44:35 <qwebirc10127> Thanks.
23:48:59 <[exa]> if there's no such instruction in docs, it could be helpful to ping ghcup people about documenting it explicitly as install dependency
23:49:14 <arsdragonfly[m]> does anyone use taffybar?
23:49:29 <arsdragonfly[m]> the default config isn't working for me
23:50:06 <arsdragonfly[m]> https://paste.ubuntu.com/p/VcYq8G5ZH5/
23:50:08 <[exa]> arsdragonfly[m]: any specific error message or unexpected output?
23:50:09 <[exa]> oh
23:50:41 <arsdragonfly[m]> I changed textClockNew to textClockNewWith
23:51:04 <arsdragonfly[m]> but it still has this error
23:51:16 <[exa]> arsdragonfly[m]: clock apparently expects 2 arguments of string and double, like 'clock "somesODtring" 123.4'
23:51:42 <[exa]> arsdragonfly[m]: no idea what they mean though (I don't use taffybar), perhaps a timezone and widget size?
