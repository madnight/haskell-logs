00:14:24 <f-a> I am a bit at loss with https://www.parsonsmatt.org/2018/03/22/three_layer_haskell_cake.html
00:14:50 <f-a> In the article one of the example instances is `instance MonadTime ((->) UTCTime) where`
00:15:01 <f-a> which I understand
00:15:45 <f-a> But say I have another mtl-like monad, MonadKeys, for key-input
00:16:17 <f-a> then I woul have an instance like `instance MonadKey ((->) SomeKey)`
00:16:25 <f-a> which again is fine
00:16:40 <f-a> but what happens when I have to write a function
00:17:27 <f-a> funWithKeysAndTimer :: (MonadTime m, MonadKey m) => m ()?
00:19:01 <f-a> I can obviously write a specific, two-field datatypes as an instance, but then every time I add a class I'd have to rewrite the instances
00:19:04 <f-a> or am I wrong?
00:29:26 <f-a> mhhh, my explanation was way messy. Here is a file which cleanly summarises the question http://paste.debian.net/1082130/
00:40:06 <Axman6> Don't you just end up with UTCTime -> SomeKey -> a being your two layered monad?
00:40:39 <Axman6> a.k.a ((->) UTCTime ((->) SomeKey a)) 
00:44:16 <f-a> Axman6: maybe I don't understad, if I
00:44:17 <f-a> λ> :t someFun (undefined :: UTCTime)
00:44:25 <f-a> I get • No instance for (MonadKeys ((->) UTCTime))
01:41:21 <golergka> Hi. I don't have a lot of experience with open source, so I've come to ask advice on how to behave in a certain situation. What if I submit a PR to a library that I need, and it just hangs there without an answer for about a week now. I also have just implemented a PR that depends on the first one, but to another library of the same author, and after that I need implement 2 another PRs down the dependency chain. The author of the first two libraries 
01:41:21 <golergka> (where I have already implemented PRs) seem to be not very active, and these libraries have PRs that look good and are left hanging there for more than a year without any answer, and it seems that my PRs would likely meet the same fate. What should I do? One option that I have is to just work on my forks of all the dependency chain of libraries that I need, make them reference one another and backport all trunk changes to my forks, and to just use 
01:41:21 <golergka> these forks in my project (where I need this feature), so this way I'm polite and don't bother anyone - but I just wanted to check if that's the normal mode of operation in these situations.
01:42:55 <golergka> I also understand the burden of open source maintainers who do a lot of unpaid and hard work and don't want to be intrusive in that regard. But abandoned libraries are a thing, and I'm not sure if in this case they are fully abandoned or just neglected a bit.
01:44:09 <f-a> golergka: did you try a gentle nudge?
01:44:28 <f-a> even better, a gentle nudge + an offer to comantain :P
01:44:48 <golergka> f-a: what would be "gentle" here? Just a comment on a PR?
01:45:20 <golergka> f-a: I just started learning Haskell, I don't think that I'm qualified to comaintain anything :)
01:46:03 <golergka> And what is a reasonable time to wait for? The first PR is now a week old, and I also pushed the second PR with a link to the first one, so I think it counts as a nudge...
01:47:21 <f-a> tough question! I usually write some half a month, then ping on the issue tracker. On comaintaining: it's , imho, win/win. They get a helping hand and you get some second pair of eye if some PR/issue looks dodgy but you don't know why
01:48:38 <golergka> f-a: it's also upsetting because it's a feature without which I can't even start working on a project that I started to learn Haskell for
01:48:52 <f-a> golergka: you are aware of cabal.project, right?
01:49:01 <f-a> eases the pain a lot for me
01:49:26 <golergka> f-a: I used stack for the same purpose (to link to a specific commit of my branch instead of the hackage version of the package)
01:49:47 <f-a> then you can work on it, correct?
01:50:28 <golergka> f-a: yes, as I said in the original question, I then end up with 4 forks of 4 different libraries that I also need to keep in sync with what's happening upstream
01:50:49 <f-a> wait
01:51:02 <f-a> upstream is pushing patches without merging prs?
01:51:07 <f-a> or answering to issues?
01:51:15 <golergka> telegram bot library > HTTP.Client > Network.Connection > Network.Socks5
01:51:39 <golergka> f-a: not in the "root" libraries", but in HTTP.Client they certainly push changes all the time, and I can't even open a PR for them unless the previous two are merged
02:00:17 <f-a> golergka: I don't use github but maybe the maintainer is waiting to see all checks green? https://github.com/vincenthz/hs-socks/pull/24
02:01:44 <golergka> f-a: I investigated the check fail, and it seems as if the problem is with the checks: merged PRs also have the same failures https://github.com/vincenthz/hs-socks/pulls?q=is%3Apr+is%3Aclosed
02:03:50 <golergka> f-a: they even failed with the same error message (Executable named haddock not found on path), so I really don't think any of my changes are to blame for this. Of course, I could investigate it and submit a PR that would fix the CI...
02:04:16 <f-a> well, author seems fairly active
02:04:40 <f-a> nudge with a friendly comment to the pr explaining your needs, and cross your fingers
02:04:48 <f-a> in the end people are busy, not assholes
02:12:23 <juri_> golergka: people really appreciate test suite fixes. fixing the CI could go a long way toward good will.
02:13:27 <golergka> f-a: thanks, will do.
02:14:09 <golergka> juri_: I'd certainly try, but it seems that this repo actually has two CI systems at once (and another one is green on my PR), so if it was up to me, I'd just remove the second one.
02:15:51 <juri_> sometimes more is better. i have four test suites on my package, and still feel like i'm barely handling testing.
02:26:17 <Unhammer> How can I with a non-profile build find out what causes a ''getMBlocks: VirtualAlloc MEM_COMMIT failed: The paging file is too small for this operation to complete.''?
02:26:39 <Unhammer> Do I have to put hascallstacks everywhere?
02:33:58 <tty1> In the following class definition am i correct in assuming that the constraint i placed on the ident function is entierly redundant with the earlier constraint on the line. Removing it would have no effect on the code what so ever correct?
02:33:59 <tty1> class (Functor t, Eq (t o), Ord (t o), Hashable.Hashable (t o), Eq i, Ord i, Hashable.Hashable i) => Identified t i o | t -> i where {ident :: (Eq i, Ord i, Hashable.Hashable i) => t o -> i; obj :: t o -> o}
02:35:47 <muzik> Hello! I have an int that is (0 - 1). When i use show on this variable, i get "0-1". Is there a way to evaluate before show?
02:37:28 <tty1> muzik: foo = 0-1; prntln foo.... That doesnt work?
02:37:57 <tty1> muzik: i tried that in my ide just now and gave me -1
02:38:38 <muzik> Yes. It works in ghci but not in my code for some reason. I am using exercism.io which uses a specific version of haskell. I doubt thats the issue. I just a newbie learning. I probably have a silly mistake somewhere
02:39:04 <muzik> I use show in the code to convert the Int to a string. Is that wrong?
02:39:14 <muzik> I cannot find a Int -> String function in Prelude
02:39:25 <f-a> muzik: print, yeah
02:39:35 <tty1> muzik: well sounds like your problem isnt described in a way that gives enough information to solve it. I'm too much of a noob to even speculate on the cause though
02:40:01 <f-a> muzik: is your main like this?
02:40:05 <f-a> main = print (0-1)
02:41:15 <muzik> https://pastebin.com/BQ1K5SCX
02:41:48 <f-a> tty1: I got headache by reading it, which exact constraint?
02:42:08 <muzik> The show on line 52 or 53
02:42:45 <tty1> f-a: the one on ident which restricts i, it was already restricted in the first part of the line (right after the keyword class) right?
02:42:54 <muzik> The areas that set this variable are lines: 23 and 40
02:42:59 <f-a> λ> convertToDoubleDigitString 10
02:42:59 <f-a> "10"
02:43:06 <f-a> works here
02:43:12 <tty1> f-a: this part is redundant i think right "Eq i, Ord i, Hashable.Hashable i"
02:43:37 <muzik> We can write haskell here?
02:44:03 <f-a> tty1: yeah, it's in the class dec, no need to restate it
02:44:54 <tty1> f-a: so all of those letters in the class dec (t, f, i, and o) retain their constraints when reused in the function definitions below?
02:45:06 <f-a> yeah, that's the spirit tty1 
02:45:16 <tty1> f-a: thanks
02:45:39 <f-a> tty1: in general if you cut something that you should have not, the compiler will gladly scream at you
02:46:31 <tty1> f-a: i think the ide im using is suppressing those sort of warnings sadly
02:48:40 <f-a> muzik: I don't get the question, but in any case your program works o ghc 8.6.4
02:49:38 <muzik> @f-a, Yep. It compiles. But when you through certain data at it, it doesnt work. One of the rare cases in haskell where it compiles, but doesnt work properly
02:49:39 <lambdabot> https://wiki.haskell.org/FAQ
02:50:22 <f-a> muzik: whick data?
02:50:45 <muzik> Give fromHourMin the values 1 and -40
02:51:17 <muzik> Then use toString on the returned Clock
02:51:30 <muzik> The minutes comes up as 0-40
02:51:33 <f-a> muzik: can you provide a specific invocation?
02:52:31 <f-a> oh sorry I misread
02:52:58 <muzik> Strange. When I test in ghci, but the exercism.io test fails
02:53:06 <muzik> ghci works for me when i load this and use it
02:53:25 <f-a> http://www.ariis.it/link/t/paste13319-0 this is what I see, muzik 
02:53:50 <f-a> file a ticket with exercism.io
02:54:05 <muzik> Here is the output of the test file that is run: expected: "22:20"
02:54:05 <muzik>  but got: "01:0-40"
02:54:40 <muzik> Good idea. Thanks f-a :)
02:55:01 <f-a> and happy learning!
02:59:16 <muzik> @f-a, got it!
02:59:16 <lambdabot> https://wiki.haskell.org/FAQ
02:59:36 <muzik> Try these 2 after loading this file:
02:59:38 <muzik> a = fromHourMin 1 (-160)
02:59:45 <muzik> toString a
03:00:28 <f-a> "01:0-40"
03:00:41 <muzik> Yep. Exactly
03:00:51 <muzik> No good!
03:01:41 <f-a> muzik: well it seems a logic bug
03:01:43 <f-a> λ> fromHourMin 1 (-160)
03:01:43 <f-a> Clock {clockHour = 1, clockMinute = -40}
03:52:46 <kish> ghci is  a good calculator
03:52:50 <kish> but that's about what i use it for
04:36:07 <Phyx-> import GHC.Event.Windows.ManagedThreadPool
04:38:18 <hpc> [sudo] Password for Phyx-:
04:39:00 <Phyx-> God12345
04:45:30 <golergka> Why do I get error about "Data constructor not in scope" whereas I specifically import it right at the point where it advises me to add the import to the list? https://gist.github.com/golergka/c73173882a3be0ac0e886b6a412f8819
04:46:15 <f-a> import Network.Socks5 (SocksAuthUsername(..))
04:46:20 <golergka> Oh damn. Thanks.
04:46:27 <f-a> remember that *data* constructors are not type cons- yeah
05:32:43 <monpantalon> https://paste.debian.net/hidden/642a8100/
05:33:21 <monpantalon> hello! The following gives me an error: 
05:33:53 <monpantalon> https://paste.debian.net/1082144/
05:34:17 <monpantalon> s/the following/the above/
05:34:44 <monpantalon> Should I do something like parametrize the 'group' class?
05:35:36 <f-a> monpantalon: 
05:35:37 <f-a> this
05:35:38 <f-a> wwminus :: a => WWord a -> WWord a
05:35:41 <f-a> does not make sense
05:35:58 <f-a> before => you need to put constraints
05:36:05 <f-a> Eq a, Num a, etc.
05:36:45 <monpantalon> mmh, and if I have no constraint I can just dispense with the 'a =>' part ?
05:36:55 <f-a> you *have* to
05:37:43 <f-a> monpantalon: it's not a "forall a."
05:38:22 <f-a> the implementation is wrong too
05:38:41 <f-a> wwneutral is a list, not a wword a
05:39:31 <monpantalon> arg, but what about newtype?
05:39:40 <f-a> type is a type synonim
05:39:51 <f-a> *newtype* wraps it
05:40:18 <f-a> so if I write type Aaa = Int I can use Aaa wherever Int is
05:40:34 <f-a> not with newtype, I should wrap those types
05:41:23 <monpantalon> But can you parametrize type?
05:41:41 <f-a> newtype WWord a = List (Sign, a)
05:41:51 <f-a> you wanted a list, didn't you?
05:41:56 <monpantalon> right
05:42:01 <f-a> that's not the way you do it
05:42:11 <f-a> newtype WWord a = List [(Sign, a)]
05:42:16 <f-a> is probably correct
05:42:34 <f-a> list is a data constructor for WWord
05:42:38 <f-a> *List
05:42:55 <monpantalon> oh, but then what about using data ?
05:43:47 <monpantalon> in the line you wrote, `List` is a brand new word, agreed?
05:44:04 <f-a> newtype and data are the same, for datatypes with *one* constructor and *one* field
05:44:07 <f-a> for efficiency reason
05:44:09 <f-a> s
05:44:22 <f-a> monpantalon: yeah
05:44:38 <f-a> wwneutral = List [] -- this would compile
05:44:47 <monpantalon> OK, so there is no way to get a sort of “parametrized type synonim” ?
05:45:29 <f-a> type WWord a = [(Sign, a)]
05:45:32 <monpantalon> But then I'll need to change wwplus and wwminus to deconstruct my arguments, right?
05:46:02 <monpantalon> if I were to go the `data` way
05:46:26 <f-a> you can use type if you want
05:46:39 <monpantalon> yeah, it's a bit easier I think
05:47:05 <f-a> but if you want to make it an istance of Group
05:47:12 <f-a> you have to enable TypeSynonymInstances
05:49:12 <monpantalon> {-# LANGUAGE TypeSynonymInstances #-}
05:49:19 <f-a> yep
05:49:28 <monpantalon> OK, let me see
05:49:50 <f-a> monpantalon: one last thing
05:49:52 <f-a> it is instance Group (WWord a) where
05:50:00 <f-a> notice the brackets
05:51:01 <f-a> sorry mistyped
05:51:02 <monpantalon> mmh, ghc isn't happy yet:
05:51:26 <f-a> yeah, need to add FlexibleInstances
05:51:42 <monpantalon> ah, that's what it complains about
05:52:26 <monpantalon> ok, now it complains about `:::` which I can handle!
05:52:44 <f-a> awesome!
05:53:00 <monpantalon> are those two extensions reasonable to use?
05:53:49 <monpantalon> And thanks for the help! I learned a bit of haskell some time ago, but never really did anything complex with it, and tried now to write something without properly reading the basics again; I'll have to do that now!
05:53:53 <f-a> mostly harmless, but if you can reimplement it with a newtype, do it, it is the preferred way
05:54:06 <f-a> happy studying!
05:59:04 <lukelau> Is there a more idiomatic way of getting a line, reading it and catching EOFs? https://gist.github.com/bubba/9e11395357e23119f9fca6f5eef71d09
05:59:17 <monpantalon> thanks :)
05:59:23 <lukelau> I’m not too happy with how I’m currently doing it, too many cases
06:01:52 <Solonarv> lukelau: it looks like you're just breaking the loop no matter which error you get, why bother catching it at all?
06:02:35 <lukelau> Solonarv: Not if the “read” fails, then I still continue the repl
06:02:50 <Solonarv> yes, I meant the error from getLine
06:03:11 <Solonarv> you could just let that bubble up and catch it somewhere further outside
06:03:47 <Solonarv> (or not catch it at all and let it terminate your program, even - there'll just be an unsightly error message)
06:04:21 <lukelau> Well if there’s an actual error I want to have the program crash, otherwise once repl terminates the ModuleBuilderT monad that its in is used to return something
06:04:39 <lukelau> here’s a bit more context: https://gist.github.com/8660bc8fd9e382339622efc461bcffa9
06:38:52 <monpantalon> hah, I can now compute in the free group… impressive
06:43:15 <f-a> after cabal new-run test --enable-coverage, how do I run hpc?
06:43:43 <f-a> I tried `hpc report test.tix` but it complains: hpc: can not find Lentil.Args in ./.hpc
07:19:33 <pie_> so, what actually makes GHC so big?
07:20:05 <f-a> pie_: dietary choices :P
07:20:17 <JappleAck> it's awesomeness
07:20:22 <JappleAck> its*
07:20:45 <pie_> :p
07:25:16 <erisco> good morning, good morning to ye and ye and ye
08:00:44 <UnkDevE> hello I've been writing a toy aes library however my mix columns function does not work could you have a look at it? https://github.com/UnkDevE/myaes/blob/master/src/Aes.hs#L80
08:02:08 <f-a> UnkDevE: compile error or logic?
08:02:20 <UnkDevE> logic
08:05:39 <f-a> it seems to be a slow day today, so hold tight :P
08:05:46 <UnkDevE> :D
08:06:02 <int-e> Word8 doesn't have the right Num instance for working over GF(2^8)
08:07:21 <UnkDevE> what should it be then for GF(2^8)?
08:09:39 <int-e> So the GF(2^8) representation that Rijndael uses is polynomials over GF(2) modulo x^8 + x^4 + x^3 + x + 1. This maps to bytes by letting the constant coefficient be bit 0 (value 1), the linear coefficient bit 1 (value 2) and so on.
08:13:25 <UnkDevE> ok, go on...
08:19:06 <int-e> Rinndael never needs the full GF(2^8) multiplication, as far as I can see, so I'd go with something like https://en.wikipedia.org/wiki/Rijndael_mix_columns#Implementation_example... possibly making a table for the multiplication by x (represented by 00000010b = 2)
08:21:45 <UnkDevE> right, so is the matrix multiplication a bad idea? 
08:23:57 <int-e> Well, if you want to keep the matrix multiplication you'll need a newtype wrapper for Word8 that provides a Num instance where + is xor, * is polynomial multiplication modulo x^8 + x^4 + x^3 + x + 1, fromInteger maps to either 0 or 1 (otherwise it's not law-abiding).
08:25:22 <int-e> This may be worthwhile after all, if you need the inverse of the MixColumns operation as well (which has larger matrix entries)
08:25:24 <UnkDevE> ah! I get you now!
08:25:53 <UnkDevE> cool well I'll do that then, thank you!
08:35:58 <hseg> Hi. Was reading comments on https://reasonablypolymorphic.com/blog/specialization and a difference between Haskell's and Core's "case" expressions was mentioned but not elaborated on.
08:36:04 <hseg> Can someone clarify?
08:37:23 <c_wraith> hseg: in ghc core, case a of x -> <exp>  will evaluate the expression a, even though x does not contain a pattern to match against
08:37:52 <c_wraith> hseg: in Haskell, case only causes enough evaluation to match the pattern provided
08:37:54 <hseg> So the difference is in the semantics of case a of _ -> <exp> ?
08:38:35 <c_wraith> It's that case in core *always* evaluates.  That's just the simplest example
08:38:36 <hseg> And in the semantics of irrefutable patterns?
08:38:50 <c_wraith> irrefutable patterns get compiled to uses of let
08:39:12 <cocreature> there are also some other differences like in Haskell you can have nested case statements e.g. match on (Just x : _) whereas in Core you will end up with one case statement for deconstructing the list and then another case statement for matching on Just
08:39:26 <c_wraith> in ghc core, let *always* is a heap allocation
08:39:34 <hseg> cocreature: OK, but that's syntactic sugar, no?
08:40:15 <hseg> Besides default cases and irrefutable patterns, can't think of a pattern that doesn't require evaluation to WHNF to match
08:41:00 <cocreature> it also works the other way around: you might see a case statement in core where you had something like "seq" or a bang pattern in Haskell
08:41:44 <hseg> Right. Basically, case serves as Core's mechanism for forcing an evaluation, besides it's pattern-matching role?
08:41:55 <c_wraith> yes
08:42:27 <hseg> Whereas in regular Haskell, it only has the pattern-matching role?
08:43:43 <hseg> I presume splitting these roles is too much of a pain for the devs to be willing to bother with?
08:44:05 <c_wraith> It's actually a simplification of the semantics in core
08:44:23 <c_wraith> because it compiles to "evaluate one constructor then branch on it", every time.
08:44:42 <hseg> Ah. So the actual core does split eval/branch, but the pretty-printer relays it in more familiar syntax?
08:45:05 <c_wraith> Well, no, I meant when the core is compiled to the next layer down, it's always that.
08:46:30 <hseg> Ah, OK. I presume that once it's compiled down, there's room for optimizations involving shuffling the evals around?
08:46:52 <c_wraith> yeah.  some of that is done in core too, but some is done later.
08:47:16 <hseg> Right
08:59:42 <cocreature> if you try to separate the actual pattern match from evaluation you have to define what it means to pattern match on an unevaluated value which doesn’t really make sense.
09:00:09 <cocreature> and once you make pattern matches imply evaluation there is no reason to have a separate statement for evaluation, it’s just redundant at that point.
09:06:56 <hseg> Except possibly if you want to be able to speculatively evaluate stuff, in which case all you're saying is that the evaluation must happen no later than the pattern match.
09:09:19 <cocreature> even then you can just use a case statement for the speculative evaluation with trivial pattern matches and then the actual pattern match later on
09:09:50 <Habib> Can anyone help me understand why let bindings cannot be used in a monadic action that is the second argument to the bind function spanning multiple lines without brackets?
09:09:57 <Habib> https://pastebin.com/xep521ZW
09:10:20 <Habib> I get a variable not in scope error under those very specific conditions.
09:10:27 <hseg> Yeah. Ofc, at that point, you might as well create syntax for case a of _ -> () and call it eval, but that's already moot
09:11:20 <cocreature> hseg: generally intermediate languages try to limit redundancy so adding special syntax for something like that doesn’t really make sense
09:11:55 <cocreature> hseg: note though that "case a of _ -> ()" wouldn’t be it. it would have to be something like "case a of _ -> continue"
09:12:14 <cocreature> or you have to wrap the case in another case to make sure it is actually being run
09:12:30 <cocreature> e.g. case (case a of _ -> ()) of _ -> continue
09:13:17 <hseg> Hm. Or combine it with a tupling and projection at whatever point you want to evaluate it at
09:19:39 <[Leary]> Habib: I'm pretty sure you just need to indent the operators on the successive lines so they parse as part of the same expression as `start`, rather than a new line or an end to the do-block.
09:20:05 <[Leary]> The latter would explain why it says `dependency` is not in scope.
09:21:32 <Habib> Yep, that works also. I guess the error is misleading. Shouldn't it be complaining that the bind operator has no first argument or something?
09:22:08 <[Leary]> I'm positing that the do-block itself is its first argument.
09:24:01 <Habib> If I do something like:
09:24:02 <Habib>     runMonad $ do
09:24:03 <Habib>       >>= start
09:24:04 <Habib> it complains: `error: Empty 'do' block`
09:24:44 <Habib> Kinda weird, since I do almost every multi-line expression unindented, except function application.
09:25:05 <Habib> funcA
09:25:05 <Habib> . funcB
09:25:06 <Habib> is how I do multi-line composition
09:25:21 <Habib> Perhaps I need to start doing everything indented, just to be consistent.
09:25:55 <Habib> Actually, that's not true. I do function application as a function (i.e. dollar) with an indent, too.
09:26:48 <[Leary]> Indentation/layout is pretty important in Haskell. If you don't want to deal with its occasional surprises you can usually use curly braces and semicolons instead.
09:27:18 <[Leary]> > do { x <- pure "eggs"; putStrLn x } -- e.g.
09:27:21 <lambdabot>  <IO ()>
09:27:22 <Habib> Yeah, it does bite me a few times, but I much prefer indentation to curly braces and semicolons.
09:27:54 <Habib> I think GHC just has a few corner cases that could be cleaned up. Or maybe I'm just misunderstanding some very simple fundamental rules.
09:28:13 <Habib> let
09:28:14 <Habib>   a = undefined
09:28:15 <Habib> in
09:28:15 <Habib>   b a
09:28:17 <Habib> is another one.
09:28:34 <Habib> The in has to be indented, which kinda looks ugly, IMO.
09:38:19 <pavonia> Habib: I think the problem in your example is the missing first value to the infix use of (>>=)
09:40:05 <Habib> The first value is the line above, but I think [Leary] was essentially saying the same thing in as many words. I believe GHC recognises the line above as the first argument, otherwise, why would it complain of an empty do block if there were truly no first arguments?
09:44:11 <pavonia> Well, the error message would be correct in that case
09:45:37 <Habib> Right. But if it weren't recognising the first argument when there were one, it would surely emit the same error message (except it would be incorrect in that case), but I'm getting a different error message (which is still incorrect, AFAIU)
09:45:53 <Habib> No, wait, I've just got it.
09:46:25 <Habib> In the non-empty do block, the bind is considering the whole preceding do block as the first argument.
09:47:03 <Habib> Then what I intended to be the second argument is separated from the do block context.
09:47:45 <Habib> Which causes a “not in scope” error when I pass a value defined in the do block as an argument to what I intended to be the second argument of the do block.
09:47:55 <Habib> *second argument of the bind operator
09:48:22 <Habib> Got it, it all makes sense now.
09:48:30 <Habib> Thanks guys.
09:48:59 <MarcelineVQ> You don't need anything in scope for this particular error since it lexical
09:49:14 <MarcelineVQ> % (doesntExist $ do) >>= quibbleboo
09:49:15 <yahb> MarcelineVQ: ; <interactive>:75:16: error: Empty 'do' block
09:50:33 <MarcelineVQ> If you want your next line after do to be >>= start then you need make an operator section. (>>= start)
09:50:55 <MarcelineVQ> If your real use is more complicated you should share that instead :>
09:54:11 <Habib> It was just a bit, and I usually do share the full context, but I'm a bit hesitant in this case for reasons. I appreciate the help, and I think I've understood how GHC is parsing it now (plus I have a true fix which doesn't involve one-lining or bracketing it, thanks to [Leary]).
09:56:01 <Zemyla_> Hmm, how much space would be saved if, when a Seq was created, it was created in the ST monad?
10:01:03 <MarcelineVQ> Why should it save any?
10:01:04 <pavonia> Zemyla_: Why do you think it would save space?
10:01:06 <MarcelineVQ> ehe
10:02:14 <qwebirc63433> Hello, having troubles installing ghcup 'Following commands are required, but missing, please install:  xz'
10:02:27 <qwebirc63433> Could anyone help out? Am new to this
10:02:34 <Habib> What OS are you on?
10:02:38 <MarcelineVQ> macos
10:02:41 <Zemyla> Because four appends to a Seq with a One as the last Digit takes the value from the One and copies it into a Two, then takes the values from the Two and copies them into the Three, then takes the values from the Three and copies them into a Four, then takes the values from the Four and copies them into a Node3 and a Two.
10:02:51 <Zemyla> And each time, it also creates a new Deep.
10:02:54 <qwebirc63433> Am on HighSierra
10:03:16 <Habib> Sorry, MarcelineVQ, I meant qwebirc63433
10:03:54 <Habib> qwebirc63433: you can do a `brew install xz` if you have Homebrew installed.
10:04:23 <Habib> I have an `xz` binary installed, but only one, and it points to a Homebrew package.
10:04:33 <MarcelineVQ> Habib: Me too :> He's at least the third person to come in with the qwebirc name missing xz with ghcup, so I guessed he was on macos too.
10:04:41 <qwebirc63433> I do indeed, that seems to be working
10:04:42 <Habib> Oh, right.
10:04:45 <qwebirc63433> thanks very much for the help
10:05:10 <Habib> qwebirc63433: what's up with all the qwebircs?
10:05:36 <Zemyla> With a mutable Seq of some kind, you could have the digits at the start and end be a circular queue in a SmallMutableArray, and each append only changes the value pointed to by the current end of the circular queue until it gets full.
10:05:55 <MarcelineVQ> as opposed to freenode's web irc? no idea, perhaps it's linked as a resource in some course material
10:06:08 <monochrom> Default nickname generation of some piece of software called, apparently, qwebirc.
10:06:12 <Habib> Ah, I see.
10:07:27 <Zemyla> It would still create new Nodes each time the circular array overfilled, but those Nodes would be appended to the MutableSeq inside.
10:08:26 <monochrom> Wait, there is a MutableSeq?!
10:20:13 <Solonarv> Habib: the indentation depth for layout is determined by the first token *in* the layout
10:20:45 <Solonarv> for example, in a 'do' block it isn't the 'do' itself that determines indentatio, but the first token following 'do'
10:21:41 <Habib> Right, I'm aware of that. Or am I not as aware as I thought?
10:21:59 <Habib> How does that relate to the troubles I was having earlier?
10:26:34 <Solonarv> oh, just clarifying. I wasn't sure if you were aware of that.
10:27:59 <RedNifre> Hey there. Is there a neat way to do (a -> b) -> [Either a b] -> [b] and how would you call that?
10:29:00 <cjay-> :t either
10:29:02 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
10:29:58 <Solonarv> :t \f -> map (either f id)
10:29:59 <lambdabot> (a -> b) -> [Either a b] -> [b]
10:34:32 <RedNifre> ah, thanks.
11:02:41 <untseac> hey. why do I need the fromIntegral here: https://gist.github.com/unit73e/ccd0625f7e0dc56bb2f6e70109558410
11:02:43 <untseac> ?
11:02:54 <untseac> is there a way to avoid it?
11:08:29 <phadej> change to `a -> a -> a` if you mean that
11:19:13 <xstill> untseac: because first argument (b) is Integral, and division needs Fractional arguments (and ^ needs second argument to be Integral), fromIntegral converts to any Num type, in this case to a
11:20:03 <xstill> btw. I would suggest having the type of the first argument be a and b for the second
12:10:41 <untseac> xstill, hum ok. thanks. Yeah I just didn't bother switching b and a.
12:42:51 <zincy> Can type equality constraints be used between types of different kinds?
12:44:01 <c_wraith> what would that even mean?
12:45:08 <phadej> zincy: heterogenous equality can
12:45:45 <zincy> Maybe Int ~ 'True
12:45:47 <phadej> % :kind! Int ~~ Monad
12:45:47 <yahb> phadej: Int ~~ Monad :: Constraint; = Int ~~ Monad
12:45:48 <zincy> Would be an example of this?
12:46:16 <martin__> is there equivalent in haskell for OCaml's local module opens? In OCaml I can do Math.(factorial sqrt 5) to access  math functions only within the brackets
12:46:17 <phadej> but it's never satisfied if the kinds are actually different
12:46:26 <phadej> martin__: nope
12:46:30 <zincy> interesting thanks
12:46:31 <martin__> bummer
12:46:46 <zincy> c_wraith: Which part doesn't make sense?
12:47:37 <c_wraith> How can two types of different kinds ever be equal?
12:49:32 <zincy> c_wraith: you got me there. :D
12:49:59 <zincy> They can still be compared right?
12:50:21 <zincy> But yeah with different kinds the comparison always evaluates to False
12:55:09 <Solonarv> c_wraith: if the kinds are actually different then the types are unequal
12:55:13 <redrapscallion> I'm trying to figure out how to get Aeson to parse this json of top Haskell posts on reddit (https://gist.github.com/redrapscallion/c0c1af3175fc58adb4ab55697159051f). I already have the json data as a string, and if I understand correctly, I make a record (eg; data Post), and then decode the string into a Maybe Post.
12:55:49 <Solonarv> the idea with heterogenous equality is that if you have an equality (a :: k1) ~~ (b :: k2) that tells you k1 ~ k2 and also a ~ b
12:56:12 <redrapscallion> I only really care about the post titles in that JSON data, but to decode that, wouldn't I have to find a way to extract out each post first as a string, then decode each one of those strings? 
12:57:57 <redrapscallion> At least, that's what I gleamed from reading aeson's hackage page at http://hackage.haskell.org/package/aeson-1.4.3.0/docs/Data-Aeson.html
12:59:46 <zincy> Has anyone got any hints for writing a type family allowing for a greater or equal operation on type level Nats?
13:03:41 <lyxia> zincy: What problems did you run into
13:03:57 <redrapscallion> Actually, to clarify my question, what I really want to ask is : For each level of nesting, do I really have to make a whole new record for each nested layer in the JSON data? That would get really tedious for complicated JSON files really fast.
13:04:55 <Solonarv> redrapscallion: you can just work with the JSON data structure directly
13:09:08 <MarcelineVQ> What does :~~: ~~ give you over :~: ~
13:09:52 <JesusIsGodAlmigh> Hello
13:10:53 <zincy> MarcelineVQ equality between heterogeneous kinds vs homogeneous
13:11:24 <MarcelineVQ> Which lets you do what that ~ doesn't?
13:12:54 <zincy> Int ~~ 'Bool
13:13:30 <MarcelineVQ> Which then can be used to..?
13:13:38 <Solonarv> er, that's wrong zincy
13:13:47 <Solonarv> a better example would be Int ~~ 'True
13:14:06 <Solonarv> it's admittedly not something you need often; I certainly can't think of a situation where it's needed
13:14:31 <Solonarv> but I assume GHC's type system supports heterogenous equality for a reason
13:15:26 <zincy> Int has kind * and 'Bool has kind Bool
13:15:26 <zincy> If you are doing type level computations for example
13:15:26 <zincy> you meant want to apply some type level function to one type which will yield another type say of kind 'Bool
13:15:36 <Solonarv> no, 'Bool just has kind Type
13:15:41 <Solonarv> % :k 'Bool
13:15:41 <yahb> Solonarv: ; <interactive>:1:1: error:; Not in scope: data constructor `Bool'; Perhaps you meant variable `bool' (imported from Data.Bool)
13:15:49 <zincy> Sorry that is what i meant 
13:15:50 <Solonarv> er, well, actually it's an error
13:17:25 <zincy> Thanks for correcting me it is easy to get confused
13:17:25 <zincy> One use case is type level computations that return types of different kinds
13:20:42 <zincy> Just checking the kind of 'True is 'Bool right?
13:20:51 <Solonarv> % :k 'True
13:20:51 <yahb> Solonarv: 'True :: Bool
13:20:56 <Solonarv> just Bool, no tick
13:21:56 <zincy> I thought the tick signified promotion weird
13:22:13 <tty1> can someone explain to me what `| t -> i` does in this code (and why i get an error without it): class (Functor t, Eq (t o), Ord (t o), Hashable.Hashable (t o), Eq i, Ord i, Hashable.Hashable i) => Identified t i o | t -> i where{ ident :: t o -> i; obj :: t o -> o}
13:22:37 <zincy> Functional dependency perhaps?
13:22:54 <zincy> Solonarv: Is that not wrong :)
13:23:00 <dmwit> zincy: ticks explained https://stackoverflow.com/a/53815871/791604
13:23:06 <Solonarv> zincy: the tick promotes *constructors*
13:23:11 <Solonarv> Bool isn't a constructor
13:23:21 <dmwit> (yes it is)
13:24:37 <Solonarv> okay mister pedant, s/constructor/data constructor/
13:24:47 <dmwit> tty1: It says that there's a global property of all instances that if you know `t`, then you know `i`, too.
13:25:37 <Solonarv> also, note that the kind and type level have been merged, so 1. and 3. in that answer are now the same thing
13:25:38 <dmwit> tty1: Without it, you could have instances for e.g. `Identified [] Int Int` and `Identified [] Bool Int`, say, so that even though type inference has picked `t ~ []`, it doesn't know whether to pick `i ~ Int` or `i ~ Bool`.
13:25:41 <tty1> dmwit: why would the class definition provide an error without it?
13:26:00 <Solonarv> redrapscallion: I left a comment on your gist
13:26:09 <zincy> Solonarv: Thanks I still need to solidify these concepts, kind of freshly learned
13:26:19 <dmwit> tty1: Because the type of `obj :: t o -> o` does not mention `i`, and so there is no way to specify which instance's `obj` to use.
13:26:39 <dmwit> tty1: (And they could behave differently, of course, so it's not safe to just arbitrarily choose.)
13:27:35 <tty1> dmwit: so basically with it if i define two two instances you used as examples then whichever one i try to define a second time would error?
13:27:59 <dmwit> right
13:28:25 <tty1> dmwit: still not sure why it would know or care what i is in order to call the obj function, since all it does is return o
13:29:02 <dmwit> Suppose you have written `obj [o1, o2] = o1` in one instance and `obj [o1, o2] = o2` in the other.
13:29:16 <dmwit> Now I call `obj "hi"`. Should I get `'h'` or `'i'` as a result? Why?
13:29:32 <tty1> hmm
13:30:48 <redrapscallion> Solonarv: thanks! I'll take a look at it.
13:31:08 <tty1> dmwit: thanks let me think about this now
13:31:15 * dmwit nods agreeably
13:32:49 <JappleAck> did i missed something or TupleSections extension got turned on by default from some version of GHC?
13:35:51 <Solonarv> doesn't look like it, perhaps it's enabled by default from your blah.cabal ?
13:35:54 <Cale> JappleAck: I don't think that happened
13:36:35 <Solonarv> I looked through the Haskell 2010 report and didn't see it mentioned there
13:36:40 <Cale> at least, it's not on by default in 8.0.2, 8.4.4 or 8.6.4, which are the versions I was able to check in the last few minutes
13:36:49 <Solonarv> and the GHC manual doesn't say anything about it being enabled by default even in 8.6
13:37:18 <JappleAck> maybe it turned on by some another extension, because the HIE told me it's redundant, i removed it and `stack repl` says it's okay
13:37:32 <Cale> Are you actually using tuple sections?
13:38:18 <JappleAck> i have these enabled by default: ExplicitNamespaces PackageImports TypeOperators BangPatterns ViewPatterns QuasiQuotes LambdaCase MultiWayIf
13:38:38 <JappleAck> Cale: yes i am, what else (,,) could mean?
13:41:04 <tty1> dmwit: wouldnt the syntax make more sense if it was `t o -> i`.. indicating that Identity [] might have a different type of i than say Identity Int
13:41:20 <MarcelineVQ> :t (,,)
13:41:21 <lambdabot> a -> b -> c -> (a, b, c)
13:41:29 <MarcelineVQ> :t (3,,)
13:41:30 <lambdabot> Num t1 => t2 -> t3 -> (t1, t2, t3)
13:41:36 <MarcelineVQ> the latter is a section
13:42:09 <MarcelineVQ> but the former is just the data constructor for a 3tuple, like how (,) is for a 2tuple
13:43:07 <MarcelineVQ> I was kind of hopinglamdbda would give me an error there :>
13:43:10 <MarcelineVQ> % :t (3,,)
13:43:10 <yahb> MarcelineVQ: ; <interactive>:1:1: error: Illegal tuple section: use TupleSections
13:44:09 <MarcelineVQ> % :t (,,) 3
13:44:09 <yahb> MarcelineVQ: Num a => b -> c -> (a, b, c)
13:45:13 <Cale> JappleAck: (,,) is the constructor itself
13:45:43 <Cale> ah, yeah, MarcelineVQ already got it :)
13:46:33 <JappleAck> Cale: here is the full version: liftAT3 = uncurry3 $ liftA3 (,,)
13:46:53 <JappleAck> it's for liftAT3 :: Applicative f => (f a, f b, f c) -> f (a, b, c)
13:47:01 <dmwit> tty1: eh? [] and Int have different kinds, so it's very unlikely that both Identity [] and Identity Int are valid.
13:47:07 <dmwit> tty1: Do you want to try that question again?
13:47:48 <Solonarv> JappleAck: yeah, there's no tuple section there
13:48:18 <Solonarv> (,,) isn't a tuple section, much like (+) isn't an operator section
13:48:21 <dmwit> :t (3,,4)
13:48:23 <lambdabot> (Num t2, Num t1) => t3 -> (t1, t3, t2)
13:48:25 <dmwit> oh my
13:49:43 <zincy> Anyone got any clues on how to proceed? type family (>=) (a:: Nat) (b :: Nat) :: Bool 
13:50:00 <JappleAck> Solonarv: now i get it, thanks
13:50:11 <tty1> dmwit: In trying to restate the question i think i just answeresd it in my own head lol
13:50:39 <JappleAck> it's just a data-type https://www.stackage.org/haddock/lts-13.21/ghc-prim-0.5.3/GHC-Tuple.html#t:-40--44--44--44--41-
13:50:47 <Solonarv> zincy: how is Nat defined? is it 'data Nat = Z | S Nat' ?
13:51:01 <dmwit> tty1: Sonuds good. =)
13:51:13 <dmwit> tty1: Might be worth stating the question and your proposed answer anyway to get a second pair of eyes on it.
13:51:25 <zincy> Solonarv: Yup
13:51:47 <tty1> dmwit: well im not sure the question even makes sense anymore, let me try
13:53:52 <dmwit> No pressure. If it won't be helpful, you're not obligated to do anything I say. =)
13:54:11 <Solonarv> zincy: well, you'll want some equations for the type family, handling the different possible cases:
13:54:11 <Solonarv> type family (>=) (a :: Nat) (b :: Nat) :: Bool where
13:54:11 <Solonarv>   Z   >= Z   = ???
13:54:11 <Solonarv>   S n >= Z   = ???
13:54:11 <Solonarv>   Z   >= S m = ???
13:54:12 <Solonarv>   S n >= S m = ???
13:54:52 <Solonarv> I'm confident you can figure out what should go in place of these ???
13:55:47 <zincy> Ill give it a go, thank you for believing in me
13:55:54 <tty1> So basically with | t -> i ... then that means if I define an instance of Identified [] Int Bool then if i define another instance like Identified [] Int Int its valid, just cant change the i part (the first Int)... t is a functor though so i was thinking I wanted "a functor of what" to be specified.. So Identified [Int] Int Int might be valid but Identified [Char] Integer Int might also be allowed (but the t->i wouldnt let it, but it SHOU
13:55:54 <tty1> LD be allowed)
13:59:39 <dmwit> Hm.
13:59:47 <dmwit> Again you seem to be mixing up differently-kinded things.
14:00:00 <tty1> wont be the last time :)
14:00:05 <dmwit> If Identified [] Int Int is valid, then neither Identified [Int] _ _ nor Identified [Char] _ _ is likely to be valid.
14:00:21 <dmwit> Because the former has got a * -> * thing in first position, while the latter two have a * thing there.
14:00:33 <tty1> hmmm
14:00:52 <dmwit> (It *is* possible, but you kind of have to work at it to make it happen. Hence the "likely" weasel word.)
14:02:37 <dmwit> tty1: (Or, to be more concrete: if `t` is `[Int]` and `o` is `Int`, then `t o` becomes `[Int] Int`, which is... not right. =P)
14:03:37 <tty1> hmm
14:03:46 <zincy> Solonarv: 'True, 'True, 'False and then for the final case `n >= m`
14:03:59 <tty1> i need to think about this... types/kinds still make me dizzy
14:04:02 <Solonarv> zincy: yes!
14:04:09 <zincy> woop :)
14:04:14 <Solonarv> really, it's no different from defining value-level >=
14:04:46 <Solonarv> you could even combine the first two equations into: _ >= Z = 'True
14:04:46 <zincy> Thanks I thought it would be different because it was type level
14:05:06 <zincy> Good idea I like that
14:06:53 <dmwit> S n >= S m = n >= m; _ >= x = x == Z -- ;-)
14:07:18 <dmwit> (Not serious.)
14:08:38 <zincy> dmwit: hehe
14:24:02 <aplainzetakind> How do I put strictness annotations inside record syntax?
14:31:22 <Solonarv> aplainzetakind: put them in front of the type
14:31:23 <oats> data Foo = Foo { bar :: !Bar, baz :: !Baz }
14:31:25 <oats> I think
14:31:28 <Solonarv> yup
14:31:44 <Solonarv> I don't remember if you need to parenthesize the field type
14:34:14 <aplainzetakind> Ah, I had tried it and it didn't work and I didn't pay attention to exactly why. One field was Set Int and I carelessly put !Set Int .
14:34:27 <aplainzetakind> !(Set Int) works now.
15:58:28 <aplainzetakind> I use ghcup/cabal pretty much only with v2-style projects. I can `cabal new-repl --build-depends foolib` to make libraries available in a repl, but is there a way to do a similar thing to cabal new-run a naked .hs file outside a project that needs some extra libraries?
16:01:29 <fenedor> aplainzetakind, afaik, cabal can do the same as stack
16:03:11 <aplainzetakind> fenedor: Same as stack being?
16:03:57 <fenedor> aplainzetakind, you can use cabal new-run to run a file like a script
16:05:04 <fenedor> https://www.haskell.org/cabal/users-guide/nix-local-build.html#cabal-new-run
16:05:20 <fenedor> it is described how you can add a bang line that cabal can interpret
16:06:06 <fenedor> however, afaik this is not optimal yet, the project needs to rebuilt every time. But this will probably we resolved soon
16:06:10 <fenedor> *be
16:06:42 <aplainzetakind> Nice, I didn't know about putting the dependencies in comments.
16:06:44 <aplainzetakind> Thanks.
16:07:06 <fenedor> aplainzetakind, you're welcome!
16:54:53 <gentauro> anybody understand this implementation of `complement`? -> `filter (`notElem` second) first` -> https://stackoverflow.com/questions/13967243/haskell-opposite-of-intersect-list#comment19278580_13967298
16:57:26 <lyxia> first - second   is every element of first that's not in second
16:57:40 <lyxia> filter p first   is every element of first that satisfies p
16:58:26 <gentauro> lyxia: are `first` and `second` functions from `Control.Arrow`?
16:58:30 <gentauro> or just lists?
16:59:12 <lyxia> just lists
16:59:55 <lyxia> complement x y = filter (`notElem` y) x
17:00:16 <gentauro> now I get it :)
17:00:33 <gentauro> they should probably just have written `xs` and `ys` ...
17:01:03 <monochrom> The meaningless religion of "meaningful" names.
17:02:12 <gentauro> monochrom: I mean, if you are begining to use `Control.Arrows` it really doesn't give sense to use names from well know functions ...
17:02:15 <gentauro> :-\
17:03:15 <monochrom> OTOH, "meaningful" names are a scarce resource. Everyone things a ton of unrelated things should be called "first".
17:04:02 <monochrom> s/things/thinks/
17:04:36 <hpc> just do what lens does and name them _1 instead
17:04:43 <hpc> now you have twice the names!
17:05:11 <gentauro> at least `pedantic` compiler flag will tell if you shadow another variable or function
17:05:25 <monochrom> I'm going to start using these names _i, _ii, _iii, _iv, _v, ...
17:05:59 <hpc> i am still trying to figure out the right way to handle database stuff wrt shadowing of id
17:06:06 <hpc> like, what even is a good alternative name?
17:06:16 <hpc> id is such a huge convention in database stuff
17:07:01 <monochrom> Consider uID
17:07:29 <gentauro> monochrom: I do that as well :)
17:07:39 <hpc> that's a bit close to uuid
17:07:47 <monochrom> Or something like xxx_id if the table is called xxx.
17:07:55 <gentauro> hpc: `uid` -> `unique identifier`
17:07:58 <gentauro> seems to fit :)
17:08:01 <hpc> i keep thinking "pkey" for primary key, but that has other issues
17:15:45 <jle`> ιd
17:48:03 <gentauro> lyxia: can that function (`complement x y = filter (`notElem` y) x`) be used with fields from a record datatype?
17:48:34 <gentauro> data Foo = Bar { foo :: Word, bar :: Char }
17:49:19 <gentauro> I would like get the complement of `Bars` for which their `foo` fields are those I want to filter on
17:50:15 <lyxia> complement :: [Foo] -> [Word] -> [Foo]     is that what you want?
17:50:44 <gentauro> complement :: [Foo] -> [Foo] -> [Foo]
17:50:57 <gentauro> but I'm guessing I will need an extra parameter to provide a `f`
17:51:18 <gentauro> complement :: (Foo -> Bool) -> [Foo] -> [Foo] -> [Foo]
17:51:23 <gentauro> something like that I guess
17:57:42 <gentauro> nevermind, I refactored some code and it works :)
20:44:35 <iqubic> So I need help writing a function. I'm not sure of the best way to describe it.
20:44:50 <iqubic> I have a description here: http://dpaste.com/1MMJHY9
20:47:06 <iqubic> I have no idea how to write this, but it doesn't seem too hard at all.
20:51:14 <jle`> iqubic: you can get something close with applyToList f g xs = [f, g] <*> xs
20:51:17 <jle`> but then you squish the list
20:55:46 <iqubic_> Actually, my idea won't work at all.
20:57:03 <iqubic_> Why is this harder than the powerset function?
20:59:23 <iqubic_> applyToList _ _ [] = [[]]
21:00:12 <iqubic_> applyToList f g (x:xs) = [x:ps | ps <- f xs] ++ [x':ps' | ps' <- g xs] 
21:00:24 <iqubic_> I think that should work. Not too sure though.
21:35:25 <___laika> https://gist.github.com/matthewess/d2d061ee6e3556fa5baab204519c30e0
21:36:15 <___laika> does this seem like an abuse of Data.Data/Typeable? this was where i got to the end of the rabbithole on making case insensitive Read instance
