00:04:07 <maerwald> how do you replace all elements of a list that satisfy a predicate with lens?
00:08:56 <dminuoso> % Just [1,2,3,4,5,6] & partsOf (_Just . each . filtered even) .~ [10,20,30]
00:08:56 <yahb> dminuoso: Just [1,10,3,20,5,30]
00:13:40 <dminuoso> maerwald: Be sure to read the note on partsOf in the haddock documentation though.
00:14:14 <dminuoso> If the list supplied does not match the number of targets, this no longer is a lens.
00:16:05 <dminuoso> > "Sony Playstation" & partsOf (traverse . filtered isUpper) %~ reverse    
00:16:07 <lambdabot>  "Pony Slaystation"
00:19:58 <maerwald> lol
00:22:57 <xacktm> haha
02:11:40 <jgt> that's amazing
02:11:49 <jgt> that's one of the best Spoonerisms I've seen
02:12:29 <jgt> it's second only to my favourite: Apple's external trackpad which they call "Magic Trackpad"
02:12:37 <jgt> Tragic Macpad
02:20:29 <freeside> i have a question about usage conventions for the State monad. Suppose I'm working through a file -- a list of lines, recursively until eof [] -- and i want to edit certain lines based on content and line number. Is it appropriate to accumulate my output list-of-lines into the value part of the state monad itself? or should i keep the state small and maintain the output accumulator in a separate 
02:20:35 <freeside> argument to my function?
02:21:13 <Solonarv> it seems to me like you don't need any kind of monad at all?
02:21:23 <Solonarv> just a [String] -> [String] function
02:21:47 <freeside> the reason I need State is because a lower line may refer to a higher line, e.g. "as aforesaid on line 21"
02:22:12 <freeside> so i want to maintain a Map of certain keywords which have been previously encountered
02:22:24 <Solonarv> aaah, I see
02:22:48 <freeside> at the moment i have State (Phrasebook,[Text.Text]) [Text.Text]
02:23:07 <Solonarv> what's the [Text.Text] in the state supposed to be?
02:23:17 <freeside> but it feels like i'm doing it wrong
02:23:42 <freeside> i'm using the value part of the state as my accumulator, and then when i get to [] i return it
02:24:02 <Solonarv> that does seem wrong
02:24:21 <freeside> the function that does most of the work is eatLines :: [Text.Text] -> LineState
02:24:44 <Solonarv> I'd probably write a function 'processOneLine :: Text.Text -> State Phrasebook Text.Text' (assuming you can process lines one at a time)
02:24:47 <freeside> i have eatlines (x:xs) = do (phrasebook, linesSoFar) <- get ... and the base case bottoms out with   return $ reverse sofar
02:26:17 <freeside> i'll try it with the single line approach. i was confused about the nature of the value part of the state. I was thinking, maybe i use that to store the current line number? but that felt wrong too.
02:26:48 <Solonarv> sure, you can carry the line number through there too
02:27:18 <Solonarv> or change the type to 'processOneLine :: (Text, Int) -> State Phrasebook Text'
02:27:19 <freeside> but then the accumulator goes ... where?
02:27:27 <Solonarv> you don't need an accumulator
02:27:37 <Solonarv> you need traverse
02:27:48 <freeside> ah
02:27:56 <Solonarv> traverse :: (a -> State s b) -> [a] -> State s [b] -- seems useful, yes ?
02:27:59 <freeside> i need to think more functionally.
02:28:58 <jgt> I'm still not seeing the need for the monad stuff
02:29:02 <freeside> whenever i write haskell i keep thinking to myself, "surely i am using way too many words to implement this pattern, there must be a shorter way"
02:29:05 <jgt> what's wrong with using a fold?
02:29:32 <freeside> if a "foo" appears on lines 3 and 8, i want the second appearance to say, "as previously found on line 5, foo"
02:29:48 <jgt> sure, but a fold will give you an accumulator
02:29:54 <Solonarv> so your "driver" is something like:
02:29:54 <Solonarv> processEverything :: Text -> (Phrasebook, Text)
02:29:54 <Solonarv> processEverything input = flip runStateT emptyPhrasebook $ traverse processOneLine (Text.lines input `zip` [1..])
02:30:34 <Solonarv> accumulators schmaccumulators, this is clearly a traversal
02:30:43 <Solonarv> do you recommend people use foldr instead of map too ?
02:31:19 <freeside> take 2 [the arguments of mages ..]
02:31:28 <zincy> Solonarv: I fell asleep before I could take a look your suggestions
02:32:02 <dminuoso> Solonarv: Sounds like recursion schemes to me.
02:32:12 <dminuoso> Surely we can *fix* that.
02:32:18 <Solonarv> yes, foldr is a recursion scheme. so are map, and traverse
02:32:26 <jgt> I'd recommend map if the shape of the data structure doesn't change and there isn't that requirement to maintain state
02:32:29 * ski . o O (; one-based heathens ;)
02:32:58 <Solonarv> (here I use "recursion scheme" to mean "function that handles the recursion for you")
02:33:10 <Solonarv> jgt: exactly, and here it sounds like freeside doesn't want to change the shape
02:33:20 <Solonarv> and traverse preserves the shape, just like map
02:33:21 <ski> @type mapAccumL
02:33:21 <dminuoso> Solonarv: Surely we can factorial this (if you know the reference).
02:33:22 <ski> @type mapAccumR
02:33:22 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
02:33:23 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
02:33:24 <freeside> i think i need the state to maintain references to the prior appearances of the keywords
02:33:50 <Solonarv> yeah, mapAccum{R,L} is just traverse specialized to State
02:33:59 <jgt> Solonarv: fair enough. I'm just not that familiar with traversals
02:34:08 <freeside> "foo" is a keyword in the phrasebook; if it appears on a line, then replace it with "the aforesaid foo from line p" where p is the linenumber of the previous appearance
02:34:17 <Solonarv> jgt: it might help to call traverse by a different name: mapM
02:34:31 <jgt> Solonarv: I've definitely used that recently!
02:34:51 <Solonarv> it's the same thing as traverse (just with a different constraint, which usually doesn't matter)
02:35:02 <freeside> without state, having every keyword encountered force a look through the previous lines, would be O(n^2)
02:35:27 <Solonarv> yeah, using State seems like a good way to keep track of "previously seen things"
02:37:46 <jgt> but still, "I need state" is not necessarily the same as "I need to use the State monad", right?
02:38:14 <freeside> oh, I was trading in my "one free monad for every 10 haskell programs written" frequent coder card
02:38:23 <jgt> :D
02:38:26 <Solonarv> correct, but the State monad is a convenient way to handle state
02:38:54 <Solonarv> s/the State monad/State/
02:38:59 * ski . o O ( "the aftmentioned `foo'" )
02:39:14 <Solonarv> ski: time for TardisT ?
02:39:15 <ski> jgt, right
02:39:25 <dminuoso> jgt: Well to be fair, if you model it with recursion and a stateful parameter, then that's just the State monad really.
02:39:26 <ski> i was thinking `mapAccumR'
02:39:50 <Solonarv> yes, which is traverse-specialized-to-State in a trenchcoat
02:39:51 <ski> (remember, `mapM' isn't really monadic)
02:40:10 <dminuoso> Solonarv: TardisT is really mindboggingly crazy.
02:40:12 <freeside> "monad" is a short word for "the things you already do the long way, without knowing the shorter word for it"
02:40:15 <Solonarv> which one is easier to use depends on a number of things; I usually prefer traverse
02:40:36 <ski> (by `TardisT', i assume you mean a reverse/backwards state monad (transformer))
02:40:41 <dminuoso> ski: Yes.
02:40:48 <Solonarv> both ways at once, even
02:41:06 <dminuoso> newtype TardisT bw fw m a = TardisT { runTardisT :: (bw, fw) -> m (a, (bw, fw)) }
02:41:19 <ski> freeside : i was focusing on the difference between "dynamic sequencing" (iow being monadic), and "static sequencing" (being idiomatic)
02:41:28 <dminuoso> Modify and read state into/from the future and the past.
02:41:37 <ski> ok, so both
02:44:02 <freeside> maybe there ought to be some kind of Rosetta Code set of examples of doing State half a dozen different ways
02:44:09 <fendor> @pl [1.. ] >>= \n -> foo $ replicate n board
02:44:09 <lambdabot> foo . flip replicate board =<< [1..]
02:44:34 <Solonarv> huh, didn't know @pl handled non-top-level lambdas
02:45:13 <Solonarv> @. pl undo do n <- [1.. ]; foo $ replicate n board
02:45:13 <lambdabot> foo . flip replicate board =<< [1..]
02:45:16 <Solonarv> \o/
02:46:25 <fendor> Solonarv++
02:46:40 <fendor> cant remember the karma syntax :(
02:47:40 <lavalike> @help karma+
02:47:40 <lambdabot> karma+ <nick>. Increment someone's karma
02:49:31 <ski> fendor : what you did already did its thing
02:49:59 <lavalike> @karma ski
02:50:00 <lambdabot> ski has a karma of 66
02:50:02 <lavalike> ski++
02:50:04 <lavalike> @karma ski
02:50:04 <lambdabot> ski has a karma of 67
02:50:09 * ski twitches
02:50:11 <jgt> @karma jgt
02:50:11 <lambdabot> You have a karma of 0
02:50:13 <jgt> lol
02:50:19 <ski> @karma- ski
02:50:20 <lambdabot> You can't change your own karma, silly.
02:50:24 <ski> :(
02:50:38 <lavalike> that's karma for you
02:51:09 <Solonarv> oh huh, nick++ works - I did not expect that
02:51:16 <lavalike> @karma nick
02:51:16 <lambdabot> nick has a karma of 5
02:51:17 <ski> lavalike : would you be so kind ?
02:51:17 <Solonarv> sneaky bot!
02:51:20 <dminuoso> So I have developed a habit of writing a `showT :: Show a => a -> Text` because I have Text everywhere in my programs.
02:51:25 <lavalike> ski: but you've been helpful! are you sure?
02:51:30 <dminuoso> This is annoying. Why is there now ShowT class in base? :(
02:51:40 <dminuoso> It would be wonderful to have derivable ShowT.
02:51:44 <Solonarv> well, there are some problems with that idea
02:51:51 <Solonarv> starting with Text not being in base :P
02:51:59 <ski> lavalike : i don't recall me being helpful to you in the immediate past ?
02:51:59 <dminuoso> Solonarv: I have a solution for that!
02:52:03 <Solonarv> I'm pretty sure there is a library for that, though
02:52:15 <Solonarv> @help karma-
02:52:15 <lambdabot> karma- <nick>. Decrement someone's karma
02:52:17 <lavalike> ski: well I thought karma+ was the only way, and you told me ++ worked
02:52:20 <dminuoso> Solonarv: Such a library would be grand design for orphan instances. :(
02:52:24 <Solonarv> oh huh, it really does exist
02:52:28 <dminuoso> Or it'd depend on the entirety of hacakge
02:52:29 <ski> lavalike : yes .. and that's not a good thing
02:52:30 <jgt> Solonarv: this one? http://hackage.haskell.org/package/acme-everything
02:52:42 <lavalike> ski: haha
02:52:43 <ski> lavalike : so i ought to be punished for telling you about that
02:52:49 <Solonarv> dminuoso: yeah, that annoying problem :(
02:52:51 <lavalike> have it as you want it: ski--
02:52:55 <ski> ty
02:53:10 <Solonarv> @karma ski
02:53:10 <lambdabot> ski has a karma of 66
02:53:19 <Solonarv> ah, seems to work too
02:53:31 <dminuoso> Solonarv: Perhaps Text really ought to be in base.
02:53:50 <Solonarv> sure, I'm not opposed on principle
02:54:01 <Solonarv> I also don't have any power over it, so... :P
02:54:32 <dminuoso> We just need to kidnap the powers that be, feed them tacos until they cant take it anymore - and then tell them to move text into base.
02:54:39 * dminuoso is looking for GHC authors
02:55:12 <dminuoso> Jokes aside, do you find yourself having `showT :: Show a => a -> Text` as well?
02:56:14 <Solonarv> not much, but then again in the programs I write I'm rarely 'show'ing anything unless it's immediately printed to stdout
02:57:13 <Putonlalla> I find myself almost never using `show`, favoring more specialized formatting functions instead.
02:57:46 <dminuoso> Putonlalla: So you'd rather have PPR class (or a lot of pprFoo, pprBar, pprQuux)?
02:58:12 <Putonlalla> I'm not sure you can capture the necessary properties in a class, dminuoso.
02:59:12 <Putonlalla> Consider `showIntAtBase` for example.
02:59:19 <dminuoso> Mmm, fair.\
03:19:49 <maerwald> what's the canonical way in a getter lens to provide a default value on failure, basically preview + fromMaybe, but inside the lens composition?
03:23:21 <Solonarv> I'm not 100% confident on this, but I don't think you can do that
03:23:31 <Taneb> :t failing _Just (like 1)
03:23:33 <lambdabot> (Num a, Contravariant f, Applicative f) => Over (->) f (Maybe a) (Maybe a) a a
03:23:48 <Taneb> This is a Getter in spirit but not in type
03:24:03 <Taneb> > Nothing ^?! failing _Just (like 1)
03:24:05 <lambdabot>  1
03:24:17 <Taneb> > Just 2 ^?! failing _Just (like 1)
03:24:20 <lambdabot>  2
03:25:10 <maerwald> > fromMaybe False $ preview (_1 . _Just . to (\_ -> True)) (Just 3, "abc")
03:25:12 <lambdabot>  True
03:25:29 <maerwald> basically the idea was to not have fromMaybe at the front, but yeah
03:27:29 <Solonarv> @let defaulting :: a -> Fold s a -> Getter s a; defaulting d els s = if null (s ^.. els) then to (const d) s else els
03:27:30 <lambdabot>  .L.hs:165:50: error:
03:27:30 <lambdabot>      • Couldn't match type ‘s’ with ‘f s’
03:27:30 <lambdabot>        ‘s’ is a rigid type variable bound by
03:27:41 <Solonarv> @let defaulting :: a -> Fold s a -> Getter s a; defaulting d els s = if null (s ^.. els) then to (const d) s else els s
03:27:42 <lambdabot>  .L.hs:165:20: error:
03:27:42 <lambdabot>      • Couldn't match type ‘s’ with ‘a -> f a’
03:27:42 <lambdabot>        ‘s’ is a rigid type variable bound by
03:27:52 <Solonarv> blergh
04:10:53 <royal_screwup21> could someone help me understand this error and how to fix it? :)  https://scastie.scala-lang.org/OqRf9Zf2TjSk8xu7n7oyvw
04:11:29 <opqdonut> royal_screwup21: wrong channel?
04:11:36 <royal_screwup21> whoops
04:12:06 <royal_screwup21> either way, if anyone knows how to fix it, that'd be cool :)
04:12:39 <Taneb> Your first mistake, I think, was writing it in Scala then asking Haskell people for help
04:14:08 <yushyin> fascinating how you try to do scala, haskell and rust at once.
04:19:42 <zincy> Humble name though
04:29:08 <hpc> what, you've never programmed in scrustell before? ;)
04:51:58 <dminuoso> So here is a question: Ive heard people critize scala for making it impossible to preserve say a ordering since if you pass it to a library, it might use a different ordering. Doesn't the same hold true for Haskell too?
04:52:39 <dminuoso> I mean if my library takes your Integer and wraps it in `data ReverseInteger` that has the reverse ordering, does an operation, and unwraps it - isnt't that the same thing?
04:54:15 <ggole> No, they're different types
04:54:55 <ski> you cannot not import/export an instance for a type that the importer knows about
04:56:34 <ggole> The problem is that with Scala's design, sets/maps using different orderings (of the same type) do not have different types.
04:57:11 <ggole> Haskell's type classes make a choice of ordering one-to-one with types, avoiding that problem.
04:57:47 <dminuoso> ggole: Ahh, so a library would be polymorphic over it (and thus completely agnostic about the choice), and the consumer at some point decices on one particular type and you have a coherent behavior everywhere.
04:57:55 <ggole> Another possible solution is to generate different types of set/map from an ordering, as seen in SML/OCaml
04:58:26 <ski> one can simulate that approach, in Haskell
04:59:22 <ski> (the module becomes a record. abstract types in the module becomes existentials. the module functor becomes a function returning this record)
05:01:58 <phadej> or then just `newtype` over a type
05:02:04 <phadej> key-type
05:04:20 <ski> phadej : in place of ?
05:04:48 <phadej> "Another possible solution is to generate different types of set/map from an ordering, as seen in SML/OCaml"; newtype generates a new type :)
05:05:43 <ggole> That's not a new type of set/map, but a new type of set/map key
05:05:55 <ski> yea, but how do you make a new `newtype', for each possible run-time input (say of type `a -> a -> Comparing') that your function can accept ?
05:06:03 <ggole> Same effect, but the mechanism is a bit different.
05:06:36 <int-e> ski: unsafeCoerce!
05:06:36 <ski> given a type `a', *and* a function of type `a -> a -> Comparing', we wanted to generate a new type
05:06:49 <phadej> ski: reflection, yes
05:06:54 <ski> int-e : existentials can do the job
05:07:25 <ski> phadej : i suppose that could perhaps be employed as well, hm
05:07:26 <phadej> if you can read a -> a -> Comparing from stdout, you can reflect it too
05:07:32 <phadej> stdin*
05:07:50 * ski `fflush'es `stdin'
05:13:39 <int-e> (I want this, (forall a. Ord a => f a -> b) -> (a -> a -> Ordering) -> f a -> b, and there's a cute unsafeCoerce apprach to accomplishing this. At least until we get local type definitions and class instances.)
05:15:02 <int-e> @hackage reflection
05:15:02 <lambdabot> http://hackage.haskell.org/package/reflection
05:24:18 <int-e> using that package, something like  http://paste.debian.net/1083698/  should be useful :)
05:27:40 <ski> int-e, any reason for the strange param ordering ?
05:27:55 <int-e> ski: that way it's basically an identity function
05:28:30 <int-e> other than that, no.
05:28:55 <ski> i meant `magic'
05:29:03 <int-e> yes.
05:29:08 <ski> hmm
05:29:10 <ski> oic
05:29:28 <ski> sneaky :)
05:29:53 <int-e> (the class dictionary construction is, of course, not an identity transformation, but semantically it's close enough.)
05:30:11 * ski nods
05:31:02 <int-e> give a k = unsafeCoerce (Gift k :: Gift a r) a <-- this swaps the arguments again and has the unsafeCoerce I talked about.
05:32:18 <int-e> Ah but to make this story work out, I should write: give (Comparator cmp) f (fmap Wrap x)
05:32:53 <int-e> anyway, details.
05:37:52 <ski> @index Gift
05:37:53 <lambdabot> bzzt
05:37:57 <ski> @hoogle Gift
05:37:58 <lambdabot> Network.Google.Affiliates FreeGift :: LinksListPromotionType
05:37:58 <lambdabot> Network.Google.Affiliates lsoFreeGift :: Lens' LinkSpecialOffers (Maybe Bool)
05:37:58 <lambdabot> Network.Google.Affiliates.Types FreeGift :: LinksListPromotionType
05:38:32 <ski> oh, it's private
05:39:59 <int-e> huh
05:40:30 <ski> ic
05:40:40 <int-e> I just did 'hoogle init' a while ago, how does ndm populate that database?
05:41:09 * ski has no idea :)
05:42:17 <int-e> s/init/generate/
05:48:47 <int-e> Oops, last time I did this was in September 2017. Let's get a new version... (@hoogle will be broken for a few minutes)
05:53:47 <strangeglyph> Hi, I'm trying to build a small interactive CLI program and I'm having trouble echoing input back to the user: https://repl.it/repls/PracticalInnocentBit
05:54:08 <strangeglyph> More specifically I guess my question is, how do I run an InputT monad from haskeline inside an IO monad?
05:54:27 <int-e> ski: but perhaps I misunderstood what you meant by "private". https://hackage.haskell.org/package/gogol-affiliates provides Network.Google.Affiliates
05:54:57 <int-e> @hoogle Gift
05:54:58 <lambdabot> Distribution.SPDX Giftware :: LicenseId
05:54:58 <lambdabot> Distribution.SPDX.LicenseId Giftware :: LicenseId
05:54:58 <lambdabot> Web.Ebay listingInfoGift :: ListingInfo -> !Bool
05:55:01 <ski> int-e : <http://hackage.haskell.org/package/reflection-2.1.4/docs/src/Data.Reflection.html#Gift>
05:56:00 <int-e> Okay. Yes, it's an implementation detail for "give", no more.
06:29:11 <zincy_> strangeglyph: https://repl.it/repls/DarkgraySneakyDaemon
06:31:05 <zincy_> strangeglyph: Is that what you want?
06:31:48 <kuribas>  stack --system-ghc ghci
06:31:48 <kuribas>  
06:31:57 <kuribas> When I try  stack --system-ghc ghci
06:31:57 <kuribas>  
06:32:10 <kuribas> I get: No setup information found for ghc-8.6.5 on your platform.
06:32:19 <kuribas> sorry for the copy paste errors
06:32:36 <kuribas> (on a alpine linux lxd container)
06:33:11 <kuribas> shouldn't it use system ghc?
06:33:13 <kuribas> and ghci?
06:37:59 <zincy_> kuribas: I just did stack new on OSX and got an issue with GHC-8.6.5
06:40:20 <zincy_> Sorry false alarm it was a warning not an error
07:01:57 <kuribas> well, apparently binary ghc doesn't work on stack, but system-ghc should work...
07:05:57 <gentauro> looking for a "On-Screen-Display" for when "screencasting" or "public speaking". Have anbody tried -> http://hackage.haskell.org/package/osdkeys-0.0?
07:06:09 <gentauro> I don't seem to find a single example on usage :(
07:07:28 <gentauro> it's made by Chris Done, otherwise I wouldn't even be bothered
07:10:29 <strangeglyph> zincy_: looks good, thanks!
07:13:21 <zincy_> strangeglyph: Great!
07:16:02 --- mode: glguy set -zq *!*@gateway/web/freenode/*
07:16:25 <glguy> Darwin226: no
07:17:45 <Darwin226> Ok, maybe then there's an alternative solution to my issue.
07:18:25 <dminuoso> Mmm, what's the linux interface for sending and receiving other ethertypes than IP onto the wire?
07:18:31 <Darwin226> I have a type similar to Maybe, and I want it to behave like Maybe does when converting things to JSON
07:18:58 <Darwin226> Meaning that if a field of another type have a value of Nothing, the field is dropped from the JSON rep
07:19:22 <Darwin226> The most direct way to achieve this would be to write an instance for GToJSON similar to the one for Maybe fields
07:19:24 <dminuoso> Darwin226: Then just write that out? If you have multiple such types, you can use deriving via.
07:19:31 <Darwin226> but unfortunately the GToJSON class isn't exposed
07:19:41 <Berengal> Is there some way to write a function something like Int -> exists a. Foo a ?
07:20:00 <dminuoso> Berengal: Yes.
07:20:12 <Darwin226> dminuoso: I don't want to write custom ToJSON instances for each of those types
07:20:15 <dminuoso> % data Foo = forall a. Foo a
07:20:15 <yahb> dminuoso: 
07:20:27 <int-e> dminuoso: my first instinct would be that you just need to create a socket of the right type... never done it myself though, so perhaps that instinct is wrong
07:20:31 <dminuoso> Berengal: ^- this lets you encode existential quantification. You can also use GADTs if you like
07:20:33 <dmj`> Darwin226: deriving FromJSON via (Maybe ThingThatIsRepEqual)
07:20:47 <dminuoso> Darwin226: Hence my note about deriving via.
07:21:26 <dmj`> otherwise it's not too hard to do it by hand
07:21:27 <Darwin226> I probably worded my issue badly
07:21:31 <dminuoso> Berengal: That is, if you need it to have such a type then: data Foo :: (* -> *) where MkFoo :: a -> Foo a
07:21:45 <Darwin226> when you have a type like data MyType = MyType { field1 :: Int, field2 :: Maybe Int }
07:21:52 <Darwin226> and derive a ToJSON instance for that type
07:22:08 <Darwin226> if you put Nothing into the field2 slot, it doesn't show up in the JSON. The field is dropped
07:22:26 <kuribas> Berengal: or you can write it continuation passing style: Int -> (forall a.Foo a -> k) -> k
07:22:30 <dminuoso> Darwin226: You can write your own generic implementation.
07:22:44 <kuribas> Berengal: then you don't need the existential
07:22:45 <dminuoso> Darwin226: and then use deriving via to toggle that behavior on
07:22:48 <Darwin226> Not for ToJSON because GToJSON isn't exposed
07:22:53 <dminuoso> Darwin226: Yes you can.
07:22:59 <dminuoso> Darwin226: You can write your own generic implementation.
07:23:11 <Berengal> I have a GADT with phantom arguments and I want functions that can return multiple different constructors of that type
07:23:49 <dminuoso> Berengal: Yup, GADTs let you do that
07:23:55 <Darwin226> dminuoso: How?
07:24:29 <dminuoso> % :t from
07:24:30 <yahb> dminuoso: forall {p :: * -> * -> *} {f :: * -> *} {s} {t} {a} {b}. (Profunctor p, Functor f) => AnIso s t a b -> p t (f s) -> p b (f a)
07:24:31 <dmj`> Darwin226: you'd have to define your own GToJSON class
07:24:36 <dminuoso> Oops.
07:24:51 <dminuoso> ^- that. :)
07:25:07 <Darwin226> So basically duplicate ALL of the GToJSON functionality
07:25:24 <dmj`> yea, it's better to do this instance by hand probably
07:25:28 <dmj`> Darwin226: can you paste your code?
07:25:31 <dminuoso> Darwin226: Did you check whether the TH version is perhaps configurable?
07:25:50 <Berengal> dminuoso: but to return an existential I have to wrap it in a different existential type?
07:25:50 <dminuoso> Darwin226: For example the lens makeLenses utility is quite customizable :)
07:25:54 <dminuoso> Berengal: No.
07:26:00 <dminuoso> Berengal: GADTs let you encode existentials directly.
07:26:05 <Darwin226> dmj`: There's no code yet. 
07:26:22 <dminuoso> % data Foo :: (* -> *) where MkA :: a -> Foo a; MkInt :: Int -> Foo Int
07:26:23 <yahb> dminuoso: 
07:26:32 <Darwin226> dminuoso: I don't want to use TH
07:26:38 <dmj`> Darwin226: can you show us what the type looks like then
07:26:40 <dmj`> that you have in mind
07:26:42 <dminuoso> % f :: Int -> Foo; f 0 = MkA; f x = MkInt x
07:26:42 <yahb> dminuoso: ; <interactive>:145:13: error:; * Expecting one more argument to `Foo'; Expected a type, but `Foo' has kind `* -> *'; * In the type signature: f :: Int -> Foo
07:27:27 <dminuoso> Darwin226: Oh wait. Mmm.
07:28:18 <Darwin226> ultimately, what I want is: `data Unset = Unset; data MyType a b = MyType { field1 :: a, field2 :: b } deriving (Generic, ToJSON)`
07:29:05 <Darwin226> then, if I set one of the variables to Unset, that field gets dropped from JSON
07:30:05 <dminuoso> % data Foo where MkA :: Foo; MkSome :: a -> Foo
07:30:06 <yahb> dminuoso: 
07:30:11 <dminuoso> % f :: Int -> Foo; f 0 = MkA; f 1 = MkSome 'c'; f _ = MkSome (1 :: Int)
07:30:11 <yahb> dminuoso: 
07:30:19 <dminuoso> Berengal: ^- did you mean something like this?
07:31:05 <Berengal> dminuoso: no
07:31:51 <dminuoso> Berengal: If you want the existential in the type, I guess kuribas's solution would work if you encode it as a continuation.
07:32:40 <Berengal> I want something more like 'data Foo a where IntFoo :: Foo Int; BoolFoo :: Foo Bool; intOrBool "int" = IntFoo; intOrBool "bool" = BoolFoo
07:33:46 <ski> Berengal : you encode existentials with (a) a `data' type with a constructor that is polymorphic in a tyvar not appearing in the result type; or (b) via a CPS-encoding, by taking a polymorphic continuation callback that you pass your existentially quantified thing to
07:33:56 <kuribas> Berengal: that's not possible
07:34:04 <dminuoso> Well it is if you encode it via CPS.
07:34:17 <Berengal> I see
07:34:26 <kuribas> dminuoso: yeah, I mean not possible in that form
07:34:48 <dminuoso> I wonder, wouldn't such a full support be equivalent to having Sigma types?
07:35:09 <dminuoso> Oh probably not, since it would only work for finite GADTs.
07:36:12 <ski> Berengal : `withIntOrBool :: String -> (forall a. Foo a -> o) -> o; withIntOrBool "int" k = k IntFoo; withIntOrBool "bool" k = k BoolFoo'
07:37:23 <ski> that's a CPS encoding of `intOrBool :: String -> exists a. Foo a'
07:37:43 <Berengal> yeah, I was hoping to avoid CPS
07:38:02 <ski> the `data' encoding of `exists a. Foo a' is `data SomeFoo = forall a. WrapFoo (Foo a)', of course
07:38:13 <dminuoso> You can probably throw singletons at it. I once heard a joke that there's no problem that wouldn't disappear if you throw enough singletons at it.
07:38:36 <Berengal> Too bad you can't encode existentials in newtypes
07:39:00 <ski> indeed
07:39:39 <dminuoso> Well since newtypes are erased at compile time, how would that even work?
07:39:56 <Berengal> types are erased anyway
07:40:05 <dminuoso> Berengal: Not with existentials/GADTs.
07:40:21 <ski> dminuoso : you're thinking of constraints ?
07:40:40 <Berengal> hugs allowed existentails in newtypes as long as there were no constraints
07:40:42 <dminuoso> ski: Arent they implemented by carrying type equality proofs inside?
07:40:43 <Squarism> Anyone know of a hamcrest (from java) like library for haskell. Something that lets me match values in different ways in unit testing? Found rematch but it doesnt seem popular enough to be published in stackage
07:40:48 <ski> obviously `newtype Foo = forall a. C a => MkFoo (T a)' wouldn't work
07:40:58 <ski> but `newtype Foo = forall a. MkFoo (T a)' would work
07:40:59 <dminuoso> for coercions
07:41:15 <Berengal> dminuoso: coercions require a constraint
07:41:32 <dminuoso> Ah
07:41:43 <Berengal> and pattermatching on GADTs doesn't do any coercion
07:41:53 <dminuoso> Berengal: Huh?
07:42:20 <Berengal> not of values
07:42:28 <Berengal> types are coerced, but that's during compile time
07:42:45 <delYsid``> I never groked what coercion actually means in a language like Haskell.  Any recommended (blog) article I should read?
07:42:58 <dminuoso> delYsid``: The paper by SPJ is pretty good.
07:43:32 <delYsid``> I am trying to avoid papers due to constantly reoccuring accessibility issues.  But I'll give it a try.
07:44:20 <Wilmpe> How do I work with a (DB) connection pool in Haskell? That is: creation, taking an accessible conn out of the pool, blocking if there is no free conn, etc?
07:44:45 <dminuoso> delYsid``: If it presents an issue, I can help reformat it into a more presentable form if you like. Just give me a shout in a query.
07:45:09 <lavalike> delYsid``: there's also this https://gitlab.haskell.org/ghc/ghc/wikis/roles
07:46:32 <delYsid``> dminuoso: You mean "Safe Zero-cost Coercions for Haskell" from 2016?
07:46:36 <dminuoso> Berengal: Ah I was thinking about core too much. :)
07:48:01 <dminuoso> delYsid``: https://www.microsoft.com/en-us/research/wp-content/uploads/2007/01/tldi22-sulzmann-with-appendix.pdf Ah I guess it's Sulzmann rather.
07:49:10 <dminuoso> delYsid``: I dont get far into the paper, but the key idea is quite readable.
08:00:29 <dmj`> Wilmpe: check out resource-pool
08:00:36 <dmj`> @package resource-pool
08:00:36 <lambdabot> http://hackage.haskell.org/package/resource-pool
08:00:59 <Wilmpe> Danke
08:06:25 <kuribas> is it possible to set the stack resolver globally?
08:23:09 <Younder> I just read a fascinating article in the AMS journal about using sheet homomology to analyze RF signals. Apparently a "off beat" method from harmonic analysis. I wonder if I can use it in RADAR imaging to improve spacial resolution.
08:23:12 <int-e> kuribas: <troll>I hope not :)</troll>
08:24:12 <kuribas> int-e: I normally don't use stack.  But some tools require it.
08:24:24 <phadej> kuribas: yes it is
08:24:42 <phadej> kuribas: though I don't remember where the global configuration file is, it's in the docs though
08:24:49 <kuribas> phadej: ah, ok
08:25:00 <int-e> kuribas: https://docs.haskellstack.org/en/stable/yaml_configuration/ suggests that ~/.stack/config.yaml might work?
08:25:26 <int-e> kuribas: I'm not a stack user either, but that reply was based on a very literal interpretation of "globally".
08:25:47 <int-e> as in, all around the globe.
08:27:34 <kuribas> I'd rather use new-build
08:28:39 <int-e> I should, probably, but I'm finding it hard to get out of the habit of just sprouting sandboxes everywhere... which works well enough for me.
08:28:48 <Younder> In my experience if depth of stack is > 3 then you are doing something inefficiently.
08:29:32 <int-e> Younder: how do you implement quicksort? ;-)
08:29:55 <Younder> int-e, I use merge-sort
08:30:28 <int-e> (I do find the 'stack' tool name awful)
08:30:50 <int-e> but that's a current trend, perhaps started by "go".
08:31:21 <int-e> 'cabal' is also an actual word but at least it's a rare one.
08:31:27 <int-e> </rant>
08:32:09 <phadej> gnu haskell compiler, err.. that's taken already
08:32:38 * ski . o O ( Guarded Horn Clauses )
08:33:29 <Younder> int-e, quick-sort minimizes the amount of swaps. With cheap and abundant memory quick-sort is no longer the obvious win.
08:34:46 <Younder> int-e, in particular merge-sort can be map-reduced. (scatter-gathered)
08:35:08 <kuribas> anyone have experience with eta?
08:35:22 <kuribas> is it easier to deploy an application with eta?
08:35:31 <int-e> Younder: Oh I don't disapprove of merge sort at all. I just wonder whether you're doing it without a stack. (How... I guess it's not all that hard, just fiddly.)
08:36:18 <int-e> krystianbajno: what is eta, besides a greek letter (that features in the lambda-eta calculus) and estimated time of arrival?
08:39:04 <Taneb> JVM Haskell, right?
08:39:32 <Taneb> int-e: https://eta-lang.org/
08:39:38 * ski . o O ( Estimated Time of Arrival )
08:39:38 <kuribas> int-e: a jvm version of haskell
08:39:41 <Taneb> (I haven't used it)
08:40:15 <Taneb> (I mostly know it from when edwardk was talking about it on a stream and it took me far too long to realise he wasn't talking about Ada)
08:40:47 <kuribas> Taneb: was he positive about it?
08:41:11 <Taneb> kuribas: I think so
08:42:02 <bahamas> I'm using lens to retrieve a field like this `session ^. tabSchema`. that yields a `Maybe` value. I want to use lens again to get a field from the value wrapped in `Just`. how can I do that?
08:43:45 <kuribas> bahamas: _Just ?
08:43:48 <kuribas> :t _Just
08:43:49 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Maybe a) (f (Maybe b))
08:44:00 <kuribas> there you go!
08:44:57 <kuribas> > over _Just (+2) (Just 1) 
08:44:59 <lambdabot>  Just 3
08:45:06 <phadej> hmm, there's no hackagebot
08:45:12 <kuribas> > over _Just (+2) Nothing
08:45:13 <phadej> does anyone know where it went?
08:45:14 <lambdabot>  Nothing
08:45:43 <bahamas> kuribas: how exactly should I chain it? I tried `session ^. tabSchema . _Just ^. tsFields` and I got `No instance for (Monoid TableSchema)`
08:46:11 <kuribas> bahamas: tabSchema . _Just . tsFields
08:46:33 <kuribas> bahamas: it composes as other lenses, using (.)
08:47:39 <bahamas> kuribas: thanks. to be honest, I don't understand how lenses compose. I still string things together hoping that they work
08:48:09 <kuribas> bahamas: they compose backwards, thanks to the leaking representation
08:48:26 <bahamas> but I think I understand what you mean here. all three are lenses: tabSchema, _Just, tsField and with (.) you compose them and get the final result
08:48:38 <kuribas> bahamas: yeah
08:49:13 <kuribas> bahamas: actually, you compose them, and you get another lens (or optic)
08:50:32 <kuribas> bahamas: then you get the result by applying the lens to a lens operation
08:52:39 <Solonarv> bahamas: think of a Lens' s a as a function that turns "do something with a"  into "do something with s" 
08:52:47 <Solonarv> then the composition order makes sense
08:53:33 <Younder> a laplace transform..
08:53:45 <Younder> lol
08:58:41 <Younder> (look up Z-transform Wikipedia)
09:22:58 <qwebirc46950> hi I was wondering how to install xz
09:39:52 <honungsburk> Is there any library that give similar functionality as elixir's phoenix.channel? Soft real time, letting me broadcast messages to a bunch of clients? 
09:43:48 <phadej> stm ?
09:44:07 <phadej> unagi-chan
09:44:25 <phadej> for low-level bits (I'm not familiar with elixir at all)
09:48:01 <honungsburk> It's not so much the concurrency aspect that I'm worried about, but more how I would go about broadcasting to 1000 of clients.
09:49:15 <honungsburk> How expensive are tcp sockets?
09:49:34 <monochrom> Goes-through-the-OS expensive.
09:52:42 <monochrom> I would start with Chan from Control.Concurrent.Chan (in base, comes with GHC).  It can have multiple readers via dupChan.  I don't know about soft real-time, but GHC scheduler is fair.
09:53:04 <honungsburk> I'd look it up
09:54:31 <honungsburk> You wouldn't use Control.Cuncurrant.STM.TChan?
09:54:58 <monochrom> I might.  I only said "start".
09:55:55 <monochrom> If you're interested in what I would end with, likely I would end with rolling my own because of NIV.
09:56:34 <honungsburk> NIV?
09:56:40 <monochrom> not-invented-here
09:56:49 <honungsburk> ah
10:04:13 <__monty__> Can I use the install instructions (with cabal) replacing install with new-install? Or does that not work for libraries like Cabal?
10:05:10 <Solonarv> you don't really want to be installing libraries, actually
10:06:38 <Solonarv> 'cabal install --lib foo' means "build 'foo' and add it to the default .ghc.environment", so it's available in a bare GHC(i) invocation
10:13:43 <__monty__> Solonarv: Just trying to follow the instructions in the cabal readme. Running new-install for cabal-install is picking up both Cabal-3.0 and Cabal-2.4 which doesn't seem right.
10:14:30 <Solonarv> er, what command did you run exactly?
10:29:02 <ais_> .
10:31:43 <ais_> if i read a file as ByteString and as Text, will it always be of the same length for both of those data types? 
10:31:44 <__monty__> Solonarv: cabal new-install exe:cabal from the cabal-install subdirectory of the repo.
10:32:26 <__monty__> Solonarv: The build failed because I can't build Cabal-2.4 with GHC 8.9, because of monadfail.
10:36:19 <dmwit> ais_: No.
10:36:57 <Solonarv> __monty__: oh! I think you're supposed to use cabal 3.0 then
10:37:11 <Solonarv> (which is unreleased, but so is ghc 8.9 :P)
10:37:24 <ais_> I'm trying to read various files, but T.length and BC.length seems to always return the same size.
10:37:31 <__monty__> Solonarv: Well yes, but I'm trying to build cabal 3.0 : (
10:37:45 <Solonarv> er
10:38:02 <Solonarv> well, cabal 3.0 isn't on hackage, so you'd need to fetch it somehow
10:38:09 <dmwit> ais_: Perhaps all the files you've tried contain only ASCII bytes, on which utf-8, the likely default encoding for reading Text, always decodes a single byte to a single codepoint.
10:38:40 <Solonarv> git clone wherever-cabal-is && cd cabal/some-subdir && cabal new-install exe:cabal should work?
10:38:41 <__monty__> Solonarv: I'm building it *from* the cabal repository. That's why I'm following the instructions in the readme.
10:38:57 <Solonarv> oh, then I'm not sure why it's trying to build 2.4
10:39:01 <dmwit> ais_: (That is: bytes that are <128.)
10:39:23 <ais_> ah, ok
10:39:37 <ais_> now i see it, thanks
10:41:16 <__monty__> Solonarv: I fear it's because cabal-install uses a custom Setup.hs?
10:43:14 <Solonarv> I suppose you could try building cabal 3.0 using a released GHC (like 8.6), and then maybe you'll be able to do stuff with 8.9
10:43:25 <Solonarv> but I'm just poking around in the dark tbh
11:01:37 <__monty__> Solonarv: Yeah, that worked. Now I'm stuck building happy for my hedgehog testsuite again. Thanks for helping me through this though!
12:22:14 <remexre> if I want to make a 2d program that does geometric primitives, images, and text, is FRP the right abstraction to do it Haskellishly?
12:37:59 <__monty__> Isn't FRP more about time, i.e., the reactive part?
12:38:47 <alexfmpe[m]> there's https://github.com/diagrams/diagrams-reflex but I never tried it, and it doesn't seem particulary active
12:41:27 <lavalike> @hackage gloss
12:41:27 <lambdabot> http://hackage.haskell.org/package/gloss
12:41:35 <lavalike> remexre: this one is a sweetie for that
12:42:23 <remexre> alexfmpe[m], lavalike: okay, I'll give those a peek
12:42:38 <remexre> __monty__: I don't know, I haven't used it before :P
12:51:41 <reactormonk> What is exactly the difference between instance Foo Int and instance (i ~ Int) => Foo i?
12:53:10 <geekosaur> the latter matches on all types, then throws at use sites if the type is wrong
12:53:30 <MarcelineVQ> https://chrisdone.com/posts/haskell-constraint-trick/ is a nice little writeup about it
12:55:42 <zincy> Why are type level DSLs regarded as being more extensible than regular DSLs?
12:57:44 <MarcelineVQ> zincy: Where did you heard that?
12:59:32 <MarcelineVQ> And after that, what is a type level dsl? Do you just mean a dsl that isn't defined by a singular datatype?
12:59:35 <zincy> https://youtu.be/0wxGrf8toWk?t=277
12:59:56 <zincy> I think Servant is an example of a so called type level DSL
13:00:56 <kosmikus> zincy: I've not seen the talk (and I'm currently in an environment where I cannot), but I have worked on servant, and I would say the statement "type-level DSLs are more extensible" is wrong.
13:01:07 <MarcelineVQ> oh hmm, that's weird way to describe that for me, type level dsl, this is a tagless final dsl
13:01:15 <kosmikus> zincy: servant is designed to be extensible, but that's not a consequence of it being type-level.
13:01:26 <MarcelineVQ> And servant has some blog posts on how they do things that might interest you
13:02:00 <zincy> kosmikus: Weird that the guy said that in the talk then
13:02:12 <kosmikus> zincy: I will try to watch it later when I can.
13:02:12 <MarcelineVQ> This is the definitive resource on the subject http://okmij.org/ftp/tagless-final/index.html#course-oxford I'm not sure servant goes as far as this one does but it does use some of the same techniques
13:02:58 <zincy> Interesting!
13:03:02 <kosmikus> and I wouldn't call a DSL that's using finally tagless style type-level, although it has a good chance of being extensible.
13:03:08 <zincy> Is that using HOAS?
13:03:23 <kosmikus> really whether DSLs are extensible and/or type-level are orthogonal issues in my opinion.
13:03:25 <MarcelineVQ> Servasnt does use the term type level dsl, I still think that's a bit weird, but the post covers the ideas well https://www.servant.dev/posts/2018-07-12-servant-dsl-typelevel.html
13:04:19 <zincy> Thanks
13:04:41 <kosmikus> the servant paper also explains a lot of the design decisions in servant that try to make it extensible: https://www.andres-loeh.de/Servant/
13:04:48 <MarcelineVQ> zincy: the it's all in haskell if the subejct interests you, http://okmij.org/ftp/tagless-final/course/lecture.pdf you can implement it yourself as you follow along
13:05:10 <zincy> I literally just bookmarked that hehe
13:05:50 <zincy> Writing such an interpreter really tests your skills
13:06:36 <MarcelineVQ> You'd be surprised how straightforward this method ends up being, if you have a particular goal in mind to work towards
13:07:53 <kosmikus> yes, the tagless-final papers by Oleg are definitely worth reading. far better than most secondary sources.
13:08:37 <zincy> So does EDSL just refer to the fact that one language is embedded in another?
13:08:46 <kosmikus> yes
13:09:03 <zincy> Although it can't strictly be true. A language just is.
13:09:35 <kosmikus> it's necessarily vague to some extent, as to what exactly constitutes a language.
13:09:40 <zincy> Yeah
13:12:44 <Amandaaa> Check my story. You will be amazed how it ends. You will see my nice boobs & clean WET pussy in the end. 18+ only!!! ---> http://snip.li/Su2H :)
13:15:35 <MarcelineVQ> "Yep, that's me, you're probably wondering how I got here. It was a dark and story night..."
13:20:59 <zachk> is the channel gonna go back to having to be registered to talk , if this spam continues?
13:21:35 <MarcelineVQ> it's not too bad, some users here produce more spam than that :>
13:24:11 <Solonarv> yeah, we had a particularly annoying case yesterday
13:24:36 <RedNifre> Hey there. What's a good replacement for inheritance? Right now it would be nice if I had a data UnaryOperator = ... and a separate data BinaryOperator, but later put them into the same list of Operators. What should I do?
13:25:34 <Solonarv> RedNifre: the concept "UnaryOperator or BinaryOperator" is exactly what sum types are for
13:25:37 <RedNifre> (I'm thinking of inheritance because if UnaryOperator and BinaryOperator inherited from Operator I could put them in a List Operator, but that wouldn't work in Haskell because a List of Operator would still require all operators to be of the same concrete type, right?
13:25:52 <Solonarv> so you would have a list of (Either UnaryOp BinaryOp)
13:26:15 <RedNifre> Hm, I'm not sure.
13:26:22 <Solonarv> or perhaps you'd define a separate type: data Operator = UnaryOp UnaryOperator | BinaryOp BinaryOperator
13:26:27 <geekosaur> why are these separate? data Operator = UnaryOp ... | BinaryOp ...
13:26:28 <geekosaur> heh
13:26:35 <RedNifre> The alternative would be to duplicate all the values from UnaryOp and BinaryOp over to Op...
13:27:03 <Solonarv> who said anything about duplicating them? obviously don't do that, that's silly
13:27:10 <RedNifre> it's more like BinaryOperator = Plus | Minus | Times... UnaryOperator = INT | CHS | Sin | Cos ...
13:28:25 <RedNifre> Another idea would be to just have Operator and hope that I always use the right ones in data Expression = BinExpression Op Exp Exp | UnaryExpression Op Exp...
13:28:50 <Solonarv> that's definitely a bad idea, IMO
13:28:59 <int-e> RedNifre: hmm, why do you end up with those operators in the same list?
13:29:07 <int-e> is it when tokenizing?
13:29:45 <RedNifre> Because I'd like to compile for my stack based HP calculator, so `1 + 2 * 3` compiles to `1 ENTER 2 + 3 *`
13:30:16 <int-e> Ah.
13:30:45 <RedNifre> The tricky parts are calculating the stack requirement and the ENTER insertions. First, I have an AST and later a list of OpCodes.
13:30:55 <int-e> Still. This is a new machine. data StackOp = UnaryOp UnaryOperator | BinaryOp BinaryOperator | Push Integer
13:31:06 <int-e> ... doesn't look so bad to me
13:31:22 <zachk> RedNifre, maybe google the railroad shunting algorithm? 
13:31:29 <RedNifre> Weeeeeeell...
13:31:42 <RedNifre> okay, I'll do that. Heh, maybe I made some bad assumptions.
13:32:01 <RedNifre> (I'm trying to compile CommodoreBASIC to HP15c)
13:32:32 <RedNifre> Maybe I should calculate the stack requirements on the BASIC AST (if possible) and put all calculator op codes into the same type.
13:33:46 <ski> RedNifre : BASIC v2.0 ?
13:34:09 <RedNifre> Uhm... maybe? Not totally sure, but my first goal is to get the Hammurabi game working, which only uses a subset.
13:34:18 <RedNifre> E.g. I'm not doing functions and for-loops yet.
13:34:28 <ski> C64 used v2.0
13:35:20 <gaze___> hey folks, does anyone know of any sort of... compile time replacements to the functionality that RTOSes provide? I know Tom Hawkins' Atom is one approach... anyone have any pointers to others?
13:35:40 <RedNifre> I'm parsing what Rosetta Code calls BASIC Commodore PET: https://rosettacode.org/wiki/BNF_Grammar
13:36:09 <RedNifre> My goal is to compile this, which mostly uses assignments, ifs and gotos: http://vintage-basic.net/bcg/hammurabi.bas
13:37:05 <MarcelineVQ> gaze___: ivory is where I'd be looking https://ivorylang.org/tower-overview.html
13:37:54 <gaze___> MarcelineVQ: This is really cool but I think it requires an RTOS to begin with
13:38:35 <MarcelineVQ> Ah could be, I'm not actually sure, but just in case it's helpful :>
13:38:42 <MarcelineVQ> srk: Any ideas for gaze___ ?
13:38:53 <MarcelineVQ> hodapp: ditto
13:38:56 <geekosaur> I
13:39:10 <geekosaur> I'm having trouble understanding the intent of the question
13:39:24 <RedNifre> Another thing regarding using clean types: I think I need to compile in multiple passes, leaving placeholders in the code that have a fake length... should I put those macro-like things in the Operation type or compile to (List (Either Macro Op)) and do passes until it's only filled with Rights and then concat them away?
13:39:27 <geekosaur> RTOS provides (a) device access (b) common routines (c) event management
13:39:34 <RedNifre> same type seems simpler, but less clean to me.
13:39:48 <geekosaur> (c) is necessarily runtime, you don't know the events ahead of time
13:40:12 <geekosaur> (a) and (b) don't require compile time support, you have an RTS or you have libraries or you write your own code for it
13:40:44 <geekosaur> note also overlap between (a) and (c) although events are more general
13:40:48 <gaze___> yeah I'm focusing more on (c)... Atom for instance does compile time task scheduling
13:41:51 <geekosaur> but that's not the entire set, unless you are polling devices in dedicated tasks (which means program correctness now depends on processor speed, among other things)
13:45:40 <geekosaur> you're also approaching the point where ladder logic might make more sense than a standard CPU
13:46:19 <geekosaur> (noting that modern ladder logic may be running on a CPU)
13:47:15 <gaze___> maybe. I'm just looking at alternative implementations of parallelism
13:47:20 <MarcelineVQ> ladder logic :(
13:48:26 <Adluc> gaze___: not sure if applies, but check this https://leepike.github.io/pubs/pike-acsd17.pdf
13:49:33 <gaze___> Adluc: hell yeah now we're talking.
13:49:36 <Adluc> here is a book on ivory/tower http://48.io/~rmarko/book/ written by srk
13:49:37 <gaze___> thanks!
13:50:04 <Adluc> in local hackerspace in brno, we hacked a bit of hardware on it, from iot, to motor control
13:50:19 <Adluc> https://github.com/distrap/lambdadrive
13:50:35 <Adluc> but new boards are needed, because ODrive is not sufficient
13:50:52 <MarcelineVQ> Adluc: what doesn't meet your needs with odrive?
13:52:15 <Adluc> MarcelineVQ: afaik problems with current measurement, RC filter need some tweaking, ground polygons not filled entirely
13:53:00 <Adluc> but overall it works, not having anything against, just needs some more hacking :D
13:53:06 <MarcelineVQ> Ah, nothing fundamental then luckily
13:53:50 <gaze___> I've been writing a little servo driver using chibios
13:54:10 <gaze___> so this project is really cool
13:57:17 <MarcelineVQ> Adluc: you could go agda -> haskell -> ivory -> robut and have provably correct robuts doing provably robut things
13:57:33 <gaze___> I kinda wonder if there's a way to have actor model concurrency and make some compile time guarantees about the depth of the message queues or something
13:58:22 <Adluc> gaze___: afaik tower has some nasa fancy shit description in terms of denotational semantics or so you can use in some tool
13:58:45 <Adluc> MarcelineVQ: never heard about robut
13:59:18 * Solonarv . o O ( I like roBUts and I cannot lie )
13:59:22 <Adluc> oh wait
13:59:27 <MarcelineVQ> ;>
13:59:49 <Adluc> thought its some new millionth buzzword i missed
14:00:06 <Solonarv> I mean, perhaps it is
14:00:36 <Adluc> some startup named robut of course :D
14:00:51 <MarcelineVQ> check out my new paper "correct by construction exoskeletons, how software can prove your suit won't bend backwards and snap your limbs off"
14:01:09 <Solonarv> honestly that sounds like something I'd want before putting on an exoskeleton
14:02:07 <MarcelineVQ> Well we'd all like it, but that kind of thing costs money you know, and people don't want to pay more than they already do for their exosuits.
14:02:31 <__monty__> Also, that's very easily solved mechanically.
14:03:06 <monochrom> Hell, people don't want to pay money for their social networks either.
14:03:11 <MarcelineVQ> easy is a tough term. you see mechanically stopping that kind of thing adds weight, which cuts into battery life
14:03:29 <gaze___> you could do bounded model checking and get a probability of that happening that you could balance against the settlement cost.
14:03:53 <monochrom> Eww. :)
14:04:17 <Solonarv> I mean, in practice you're always doing that
14:04:30 <Solonarv> although s/settlement cost/cost of failure/
14:04:35 <Adluc> gaze___: did you already apply to boeing?
14:04:42 <MarcelineVQ> What you'd want to do is treat every component as a wireless device, so that when wires fail you've already thought of what should happen
14:04:42 <monochrom> haha
14:05:08 <geekosaur> and then they deploy the jammers
14:05:21 <geekosaur> and spoofing
14:05:26 <MarcelineVQ> well, they're not actually wireless, but you'd want ECCM for sure
14:07:12 <Adluc> anyway back to topic, I'd still like to have one day ivory/tower compat with this https://github.com/mn416/blarney
14:07:34 <Adluc> gaze___: which makes me thinking, this is also stuff you should check out
14:07:51 <Adluc> fancy shit giving mental satisfaction
14:08:07 <MarcelineVQ> Oh man, now that's a proper readme, iterative examples
14:09:20 <gaze___> ooh that's cute
14:09:32 <zincy> What is that? Hardware emulation?
14:10:06 <Adluc> generates full verilog along with some other format, also ready for simulation
14:10:27 <MarcelineVQ> zincy: Or programmable chips
14:12:48 <gaze___> I'd love a copy of bluespec to goof around with
14:24:16 <Adluc> f*uck softcores, a lot to do at lower level
14:24:49 <glguy> Adluc: If you recognize that you'd need to put asterisks in a word to send it to channel please just don't send the word
14:24:51 <Adluc> MarcelineVQ: anyway about those robots, its kind of tricky to "verify" anything, because reading erratas to any mcu's makes me think it doesnt matter at all
14:26:35 <MarcelineVQ> aha, so we need a verified cpu from the ground up, what a task we've set for ourselves
14:28:50 <monochrom> Wait, erratas to Marvel Cinematic Universe?  Yeah I think they could use some of those. >:)
14:34:36 <RedNifre> How do I compare to a constructor? If I have data Bla = A | B | C String, how do I check if something is C, regardless of which String is inside?
14:35:18 <monochrom> Pattern matching.
14:35:44 <RedNifre> So I need an extra function outside? Like isC (C _) = True ; isC _ = False ?
14:36:17 <monochrom> You can also use an inline "case" expression if you don't want a separate function.
14:52:22 <hodapp> gaze___: this is sort of what I made Ion for, but it's rather task-specific
14:54:38 <geekosaur> RedNifre, you need a pattern (or hide it in a function, but that has its own issues including introducing extra laziness)
14:55:00 <geekosaur> there's also (C {}) which matches the constructor ignoring any and all parameters
15:06:56 <zincy> What are the pros and cons of using GADTs vs TypeFamilies to define the types Game and Game' here: https://gist.github.com/therewillbecode/2aa5d952f48f4324fc7494f004a0f7cd
15:09:11 <jle`> zincy: well, one produces a data type that you can manipulate at the value level
15:09:25 <jle`> so it's first-class
15:09:58 <zincy> GADTs ^ right?
15:10:03 <jle`> yeah
15:10:47 <zincy> So basically that means Game' wouldn't allow me to modify values within the Vector?
15:10:54 <jle`> although in your situation, Game' and Game don't really do the same thing
15:11:38 <jle`> that kind of analogy doesn't reall work, unless you talk about how you would use Game/Game'
15:11:45 <jle`> you're asking questions about a data structure, but Game' is a type family
15:12:28 <jle`> Game "contains" a vector, but Game' doesn't, unless you associate it with a value
15:13:16 <jle`> so the question of comparison doesn't really make sense on its own
15:13:35 <jle`> it's not like they can easily represent two different strategies for doing something here
15:13:42 <jle`> *the same thing
15:13:59 <zincy> So Game' does not return a type which has values?
15:14:14 <zincy> Sorry Game' isn't a type which has values
15:14:24 <zincy> it is a function which returns a type
15:14:37 <jle`> hm, as you have defined it, Game' returns Game
15:14:40 <jle`> is that what you intended
15:15:05 <zincy> Yes
15:15:14 <jle`> so what are you trying to compare and contrast here?
15:15:34 <zincy> TypeFamilies and GADTs :D
15:15:56 <jle`> type families and GADTs do different things
15:16:10 <jle`> and they solve different problems
15:16:29 <jle`> so it's not really something that you can compare and constrast for pro's and con's, unless you talk about their applicability to a specific problem
15:16:37 <zincy> Yeah that makes sense
15:16:55 <zincy> Ok when would I use a type family?
15:17:00 <zincy> When I want to associate types?
15:17:02 <jle`> so this is like asking for pro's and con's of Strings and Ints...they're two different things, and there isn't many situations where their usage overlaps
15:17:24 <jle`> zincy: yeah :)
15:17:25 <zincy> I.e Give me a Bool and a Maybe String and Ill give you an Int?
15:17:35 <jle`> well, what you described is a function
15:17:36 <zincy> Whereas as GADT's constrain type variables
15:17:52 <jle`> "give me a Bool and a Maybe String and i'll give you an Int"
15:18:01 <jle`> that's a function, Bool -> Maybe String -> Int
15:18:18 <jle`> although in a sense you can think of a Type -> Type -> Type type family in the same way
15:18:19 <zincy> Type families are type level functions I thiink
15:18:29 <jle`> kind of, but there are differences
15:18:55 <jle`> so you might be thinking of type instance MyFamily 'True ('Just "blah") = '9
15:19:02 <jle`> but there are no type-level strings or ints, only Symbol and Nat
15:19:35 <jle`> zincy: a GADT is a data type/value, and it lets you be expressive with constraints on type variables you instantiate them with, yeah
15:19:36 <zincy> Is Symbol not a type level string?
15:19:47 <jle`> it's a type-level string, but it's not a type level String, sorry
15:19:50 <jle`> i misspoke
15:20:48 <zincy> So what is the most common example of a problem where you think ah I need a type family 
15:21:01 <jle`> i don't think you'd ever need a type family to solve a problem
15:21:14 <jle`> but there are some situations where type families might help :)
15:21:34 <zincy> What might they be
15:21:52 <jle`> a common example is associating types within a typeclass
15:22:02 <jle`> or for certain operations
15:22:07 <jle`> it gives you more flexibility with polymorphism
15:22:32 <jle`> for example, there's the monotraversable package, which defines a type family for every container with the type of their "element"
15:22:38 <jle`> so, type instance Elem [a] = a
15:22:42 <jle`> type instance Elem Text = Char
15:23:12 <jle`> and so you can define functions like omap :: (Elem c -> Elem c) -> c -> c
15:23:28 <jle`> for [a], that becomes (a -> a) -> [a] -> [a]
15:23:33 <zincy> So it lets you build a type agnostic interface of sorts?
15:23:41 <jle`> and for Text, that becomes (Char -> Char) -> Text -> Text
15:23:56 <jle`> hm, i'm not sure what you mean by type agnostic
15:24:13 <jle`> but this is one application :)  and mtl-tf, a type families based version of mtl, does something similar
15:24:58 <zincy> You can write typeclass instances for Elem and the type wrapped by Elem effectively hijacks the interface
15:25:28 <jle`> you can't write typeclass instances for Elem itself, since you can't write instances for type family applications
15:25:41 <jle`> but you can write: class OFunctor c where omap :: (Elem c -> Elem c) -> c -> c
15:26:00 <jle`> instance OFunctor [a] where omap = map
15:26:07 <jle`> instance OFunctor Text where omap = T.map
15:26:41 <jle`> i think maybe my previous type signature for omap was deceiving 
15:28:02 <zincy> Oh right because Type families don't have values
15:28:18 <zincy> so typeclasses don't make sense for them.
15:28:19 <jle`> er well the main reason is because type inference doesn't really work
15:28:45 <jle`> typeclasses do make sense for things that aren't kind *, ie. we have Functor, Monad, etc. that are instances for types that don't have values
15:29:06 <zincy> So their main you can have a function which say returns an Elem c
15:29:24 <zincy> And Elem c would be substituted with a type that does have values
15:29:27 <jle`> the problem is that type inference doesn't really tell you which instance to pick
15:29:43 <zincy> rings a bell undecideableInstances
15:29:53 <jle`> it's actually a problem with injectivity
15:30:08 <jle`> if you have a value of type `Char`, and i told you that it came frmo type `Elem c`, can you tell me what c was?
15:30:32 <jle`> you can't; it could be [Char], or it could be Text
15:30:49 <jle`> so you don't have enough information to pick which instance you are using, in most cases
15:31:10 <jle`> omap bypasses this by having c as a value of one of the arguments
15:31:11 <zincy> What is `c`
15:31:21 <jle`> it's a type variable for unification
15:31:30 <jle`> here's a situation where unification/type inference works:
15:31:37 <zincy> Would Elem be a type family    --  type family Elem (c :: *) :: * where 
15:31:39 <jle`> i have a value of type `Maybe Int`, and i told you that it came from type `Maybe c`
15:31:47 <jle`> could you tell me what c is?
15:31:53 <jle`> or, hm
15:31:58 <jle`> i told you that it unifies with 'c Int'
15:32:05 <jle`> you could tell me what c was: it's Maybe
15:32:27 <zincy> Not familiar with unification as a term
15:32:30 <zincy> :/
15:32:54 <jle`> it's a part of the process of picking which type variables must be what, to make two types 'match'
15:33:03 <jle`> for example, if we want to unify (a, Int) and (Bool, b)
15:33:10 <jle`> we could pick a ~ Bool, and b ~ Int. unified :)
15:33:13 <zachk> unification made more sense to me after learning some prolog 
15:34:40 <zincy> zachk: How mind expanding was Prolog?
15:34:49 <zincy> jle`: Ok I follow
15:36:27 <jle`> you can also use type families to define relationships for DataKinds lifted types, sort of like how you would use functions at the value level
15:36:34 <jle`> if you had data Dir = N | S | E | W
15:36:47 <jle`> and data Axis = Horiz | Vert
15:37:09 <zachk> prolog is kinda nice for learning new concepts, kind of a pain to do anything real worldish in it, I have found, at least with multithreading and shared state
15:37:12 <jle`> you could write type family AxisOf (d :: Dir) :: Axis where AxisOf N = Vert; AxisOf S = Vert; AxisOf E = Horiz; AxisOf W = Horiz
15:37:35 <zachk> zincy, it's easy to find cousins in a family tree and find the shortest path between two points ina  graph 
15:38:13 <jle`> and this is where you have some overlap with GADT functionality, where you can instead use GADTs as runtime witnesses for "correct axis assotiation" 
15:38:18 <zachk> I haven't really mastered prolog all the way, but it has an interesting take on programming that is quite different from everything else 
15:38:44 <zincy> jle`: Ah so for example if you want to use a 'Just and 'Nothing as type constructors when checking membership of a type in a type level list?
15:38:49 <jle`> data HasAxis :: Dir -> Axis -> Type where HAN :: HasAxis 'N 'Vert; HAS :: HasAxis 'S 'Vert; HAE :: HasAxis 'E 'Horiz ...
15:39:15 <jle`> zincy: well, checking membership in the type level list is already datakinds enough to talk about how type families work there, heh
15:39:55 <jle`> the difference betwene the GADT HasAxis and the type family AxisOf is that it now becomes a runtime proof of some valid axis assotiation 
15:40:03 <jle`> and AxisOf is instead a compile-time type relationship
15:40:32 <jle`> so say, if you want to manipulate directions as types at runtime, then it makes sense to have a first-class value like HasAxis that you can pattern match on and deconstruct
15:40:38 <jle`> (at runtime)
15:40:53 <zincy> jle`: So the role of type families would be to denote failure at the type level in a similar way to normal Maybe at the term level?
15:41:38 <jle`> zincy: hm, i'm not sure what you mean by failure like that
15:41:52 <zincy> failure as in this element doesn't exist in the list
15:42:26 <jle`> by returning a Maybe, you mean?
15:42:31 <zincy> yeah
15:42:40 <jle`> i wouldn't say that that describes "the role of type families"
15:42:44 <zincy> with type families you can return a 'Just and 'Nothing
15:42:58 <jle`> without type families, you can't even check for existance in a list at the type level
15:42:58 <zincy> to wrap a type to denote failure for a type level computation
15:43:06 <zincy> would you say it describes one possible use case?
15:43:07 <jle`> so type families doesn't really add failure here
15:43:24 <zincy> how else would you use the lifted data constructor?
15:43:24 <jle`> type families let you check for the existence of items in a list in the first place
15:43:41 <jle`> so the failure part is incidental
15:43:49 <zincy> So the latter is datakinds?
15:43:57 <jle`> the latter is just Maybe
15:44:01 <jle`> specifically :)
15:44:10 <jle`> good ol' data Maybe a = Nothing | Just a
15:44:18 <zincy> If it is at the type level is is Maybe and Datakinds no?
15:44:21 <jle`> zincy: you also need DataKinds to check for the existence of items in a type-level list in the first place
15:44:31 <jle`> so DataKinds is already at play, whether you return Maybe or not
15:44:40 <zincy> So not failure by itself but failure at the type level
15:45:10 <jle`> you could have the checking for existence in a list return Bool, as well
15:45:16 <jle`> it's not any deeper thing, i don't think
15:45:23 <jle`> other than just lifting an analogy of a value-level function
15:46:13 <jle`> the failureness doesn't come from datakinds, or type families; it comes from picking Maybe
15:46:27 <jle`> because datakinds or type families are already a part in 'checking' a list using pattern matching
15:46:38 <jle`> and you could use it to return Bool, or even a default value if the list is monomorphic
15:47:00 <jle`> the fact that you can use Maybe isn't indicitative of any deeper aspect of type families; no more than the fact that you can use Bool or lists :)
15:47:24 <zincy> I think I get it
15:49:26 <zincy> Is this yours https://blog.jle.im/
15:49:38 <jle`> it is :o
15:50:15 <zincy> :)
15:50:47 <zincy> I am planning on going through the singletons tutorial
15:52:17 <jle`> ah, i hope you have fun with it :)  and let me know if you have any questions from it too!
15:53:15 <zincy> Awesome, what is the your preferred channel for questions?
15:53:37 <zincy> I can't type I should go to sleep
15:53:48 <jle`> you can ask here too, a lot of people could probably also answer any questions you might have on this topic :)
15:54:00 <zincy> :)
15:55:55 <jgt> jle`: the link to domenkozar[m]'s page on your site goes to https://twitter.com/iElectric, whereas it should probably go to https://twitter.com/domenkozar
15:56:34 * jgt hopes he did not awaken domen
15:59:17 <jle`> jgt: ah, interesting :o i was following the information on the patreon page, but that does sound more relevant
16:30:32 <fr33domlover> Ughhh I have a bug in my yesod web app causing 100% CPU usage, I thought it's a space leak but it seems to happen without high memory usage, I've been looking for the cause of this bug for a few days now, can't find it :p
16:31:11 * fr33domlover tries to keep the motivation up and not lose hope ^_^
16:39:14 <devalot> fr33domlover: Could it be an infinite loop somewhere?  Or does the app work as expected but just uses a lot of CPU?
16:40:28 <dmiles> zachk: somethng that has really helped me got good with prolog is i implemented a Common Lisp interpreer/compiler in Prolog (tha tis that it converts common lisp code ionto prolog srcs intead of typical C sources) then runsa prolog compiler
16:42:06 <dmiles> oh weird .. i just searched the other Lisp channels to see if zachk was there.. and realized *this* is not a Lisp channel
16:42:15 <fr33domlover> devalot, it happens in some DB related piece of code (PostgreSQL), I wonder if there's an infinite loop there yeah in the pure bits, or maybe something like running out of DB connections or idk some busy wait or idk what
16:42:17 <dmiles> hehe
16:42:24 * fr33domlover keeps investinaging!
16:42:32 <fr33domlover> *investigating
16:42:33 <fr33domlover> ^_^
16:43:17 <dmiles> related though.. you might study the Curry compiler .. it translates Curry sources to Prolog sources
16:43:35 <dmiles> I though cant trell teh differnce between Curry code and haskell code
16:44:16 <dmiles> I wish there was a website that taught the two languages (Curry and Haskell) side by side
16:44:17 <devalot> fr33domlover: Is the problem recent?  Can you use `git bisect' to locate it?
16:45:04 <zachk> dmiles, would a scheme interpreter in prolog be good enough?
16:46:29 <dmiles> for sure .. why it was a good idea for me is it got me arround wondering how i was going to do all these silly impertive code things typically programmers need to do
16:47:12 <dmiles> (so you'd do those silly things in Scheme.. then see how prolog did it)
16:47:14 <zachk> did you have to do the imperative things in the end? 
16:47:57 <fr33domlover> devalot, yeah that's what I'm doing, going over the changes and looking for the one that caused it. I think I'm getting close
16:48:04 <dmiles> zachk: hrrm .. i suppose yes i end up doing them
16:49:21 <dmiles> it made code like...  https://github.com/TeamSPoon/wam_common_lisp/blob/master/prolog/wam_cl/fileload.pl#L152-L168
16:51:35 <dmiles> oops that might be bad example since that function is still pretty :P
16:51:52 <dmiles> but at least it looks imperitive
16:59:12 * dmiles was going to write a scheme compiler/interpreter instead.. but there is no scheme standard :(
17:02:05 <dmiles> (at least that is:  you cant just run "off the shelf code") .( you cant write a Scheme Program unless you sign up to use Racket, mscheme, Chicken, etc versionb of the language) 
17:02:42 <zachk> yea I hear that dmiles 
17:04:16 <dmiles> but i might be slightly wrong here.. maybe the R6RS is a standard those impls expand upon?
17:06:17 <oni-on-ion> fr33domlover, prayers with you for pushing ahead & thx for the inspirational side effect =)
17:06:54 <dmiles> like https://github.com/zick/ImplOfR6RSAppA
17:07:51 <fr33domlover> oni-on-ion :)
17:11:34 <dmiles> can someone describe how hard it be to port a Haskell program into Curry program?   Is it all jsut slight syntax modification?
17:17:02 <dmiles> since i got the _impression_ Curry code is Haskell code but with Extra Laziness + Nondeterminism
17:17:48 <dmiles> so " Curry code --> Haskell code " hard
17:18:05 <dmiles> so "  Haskell code --> Curry code " easy?
17:19:18 <dmiles> example https://www-ps.informatik.uni-kiel.de/kics2/lib/Prelude_curry.html  <- does this look like haskell code?
17:20:21 <dmiles> or am i jsut naive and sicnce it its ML-ish syntax and i am ixxing it
17:20:56 <dmiles> (the same naivity that someone might assume lisp between lisp and scheme) 
17:21:01 <geekosaur> it looks haskell-like, but some things were removed and replaced iirc
17:21:46 <dmiles> "type" and "data" decls the same?
17:22:50 <dmiles> (at the URL i gave)
17:24:23 <geekosaur> they're the same, yes
17:24:53 <gonz_> The FFI seems different?
17:25:05 <geekosaur> oh, right. no typeclasses
17:25:14 <gonz_> ```
17:25:14 <gonz_> (=:<=) :: a -> a -> Bool
17:25:14 <gonz_> (=:<=) external
17:25:14 <gonz_> ```
17:25:54 <gonz_> I would expect FFI to be specified with `foreign import` if it was actually Haskell
17:26:04 <geekosaur> also evaluation is fairly different because it can be nondeterministic
17:26:15 <gonz_> Whereas this seems to use a more normalized definition form for FFI and saying that the implementation is simply `external`
17:30:03 <dmiles> so in Haskell that is?
17:30:04 <dmiles>  foreign export __external  (=:<=) :: a -> a -> Bool
17:30:09 <dmiles> oops
17:30:36 <dmiles>  foreign export "__my_whatnot"  (=:<=) :: a -> a -> Bool
17:30:48 <gonz_> Oh, I assumed it was an import
17:30:57 <dmiles> oh oops!
17:31:13 <dmiles>  foreign import "__my_whatnot"  (=:<=) :: a -> a -> Bool
17:32:31 <gonz_> I'm not really versed in the FFI of Haskell, but something like this: `foreign import ccall "fun_name_in_c" (=:<=) :: a -> a -> Bool`
17:32:35 <dmiles> well i guess    __my_whatnot = mkFun a_exp
17:33:25 <dmiles> ok that wouldnt be too bad .. seems syntactic level
17:34:36 * dmiles eventual goal is to write a .haskell -> .curry translator to compile Haskell code with the Curry comppiler
17:36:05 <dmiles> <geekosaur> also evaluation is fairly different because it can be nondeterministic  
17:37:03 <dmiles> so hrrm i'd have to ensure the Curry version was not _accidently_ leverage non-determinism?  
17:37:13 <geekosaur> yes
17:40:18 <dmiles> http://logicmoo.org/Prokhor/haskell_to_curry/?C=N;O=A  i guess i found some exmaples 
17:40:42 <dmiles> of Side-by-side to diff
17:49:31 <dmiles> a diff:  http://logicmoo.org/Prokhor/haskell_to_curry/Screenshot%202019-05-13%2017.47.25.png
18:12:32 <dmiles> <geekosaur> oh, right. no typeclasses
18:12:42 <dmiles> the Curry compiler i used added typeclasses
18:13:32 <dmiles> i suppose they must still be using haskell syntax for them
18:43:47 <jusss> Reader Monad can be used in other languages?
18:44:05 <jusss> Maybe Monad can be used in a language that doesn't support ADT?
18:44:17 <jusss> or implement?
18:44:40 <Cale> Well, the reader monad in some sense is just "functions"
18:44:51 <Cale> But implementing the monad abstraction is the interesting question.
18:45:09 <Cale> Without type classes, it's hard to do a good job
18:45:18 <jusss> Cale: but other languages don't have pattern matching
18:45:51 <Cale> Well, it's less about pattern matching and more about the types of return and (>>=)
18:45:55 <Cale> :t return
18:45:57 <lambdabot> Monad m => a -> m a
18:46:27 <Cale> This type signature already includes a few things which are hard both for many statically typed languages and dynamically typed languages
18:46:43 <Cale> It's polymorphic in the type of its result in a way which can't be determined from its argument
18:46:59 <Cale> which tends to be hard in dynamically typed languages
18:47:35 <Cale> It's abstracted over a choice of a type level function m, which tends to be hard in many statically typed languages which don't support higher-kinded polymorphism
18:48:23 <Cale> and then even if you support higher-kinded polymorphism, it's abstracted over an instance of the type class Monad, which means that the compiler is going to plug in different code based on the choice of type m
18:50:47 <Cale> So, even if you can define Monad as a polymorphic record datatype, like the equivalent of  data Monad m = MkMonad { return :: a -> m a, bind :: m a -> (a -> m b) -> m b }  in Haskell
18:51:11 <Cale> that would still mean that you'd constantly be passing around extra arguments of type Monad everywhere
18:51:39 <Cale> the fact that this happens implicitly in Haskell is rather important for the usability of the abstraction
18:54:39 <Cale> So, you can usually try to implement particular monads, but particular monads is not interesting
18:55:07 <Cale> Really capturing the abstraction in a satisfying way is pretty hard without type classes, I've never really seen anything I was terribly happy with.
18:55:19 <shachaf> Continuations?
18:55:28 <Cale> In OCaml, they use module functors to approximate type classes
18:55:47 <Cale> and that kind of halfway is almost okay, until you want to use more than one monad
18:55:51 <shachaf> Continuations are great at capturing abstraction. They'll capture whatever you want them to, and lots of things you don't want them to.
18:57:13 <Cale> shachaf: You mean "mother of all monads" style? I'd like to see mtl written something like that
18:59:13 <shachaf> People talk a lot about how it's great that you can abstract over all monads, but I'm not sure how big of a deal it is.
18:59:51 <shachaf> You have do notation, which is built-in anyway, and a handful of functions in Control.Monad. There aren't that many other things that meaningfully and usefully abstract over all monads.
19:00:07 <Cale> I dunno, half the stuff I use every day might not even exist if it weren't for monad transformers?
19:00:38 <Cale> But I do live in the strange world of Reflex FRP
19:00:41 <Cale> :)
19:01:35 <Cale> It would be *so* much harder to deal with constructing the monads that we use if we had to do it all at once
19:01:56 <Cale> I should take one of these things apart and really see what it's made of...
19:04:34 <Cale> Okay, random app from work, outermost monad transformer is QueryT, which is itself a newtype of
19:04:41 <Cale> StateT [Behavior t q] (EventWriterT t q (ReaderT (Dynamic t (QueryResult q)) m))
19:05:12 <Cale> newtype EventWriterT t w m a = EventWriterT { unEventWriterT :: StateT (EventWriterState t w) m a }
19:05:32 <Cale> and then inside that, we have RequesterT...
19:05:59 <Cale> newtype RequesterT t request (response :: * -> *) m a = RequesterT { unRequesterT :: StateT (RequesterState t request) (ReaderT (EventSelectorInt t Any) m) a }
19:06:06 <Cale> which is more stuff...
19:06:15 <shachaf> Golly.
19:06:33 <shachaf> Doesn't working on something that deeply nested ruin your day?
19:06:49 <Cale> no, it's fine
19:06:56 <Cale> You *never* think about this nesting
19:08:12 <shachaf> It sounds like you mostly just have a bunch of States and Readers. If you didn't have monads you'd just use a couple of arguments.
19:08:51 <Cale> Well, yes and no. Each of these things is built out of State and Reader, but it's State and Reader of weird stuff, and various type classes are implemented differently for these transformers
19:09:53 <Cale> Principally, we have this type class called Adjustable, which deals with how to dynamically switch between widgets
19:09:58 <shachaf> Sure, but the monad instance is the same.
19:10:18 <Cale> The *Monad* instance is just the GNTD one, yeah
19:10:41 <Cale> But the Adjustable instance for QueryT and RequesterT and all these things is customised.
19:10:52 <Cale> (and several others)
19:10:57 <jusss> Cale: "mother of all monads" style? you mean Continuation Passing Style?
19:11:26 <shachaf> But at that point it's not really "abstracting over monads", it's "abstracting over our own thing".
19:11:30 <Cale> jusss: https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/the-mother-of-all-monads
19:12:15 <Cale> shachaf: Well, Adjustable abstracts over a choice of monad, and its operations are implemented differently for different monads
19:12:38 <shachaf> I say the "mother of all monads" is Codensity, not Cont.
19:12:46 <Cale> (also DomBuilder, etc. etc. there are several of these classes)
19:13:09 <shachaf> i,i wouldn't it be CodBuilder and DomConsumer?
19:13:18 <Cale> haha
19:13:27 <shachaf> I suppose one function's domain is another function's codomain.
19:13:37 <jusss> is that Monad and Continuation both based on Closure?
19:13:38 <Cale> Yeah, it's DOM in the sense of document object model
19:13:53 <Cale> jusss: I wouldn't say either was
19:14:16 <Cale> jusss: Closures are a possible implementation mechanism for implementing functions
19:14:43 <jusss> Cale: and OO is another?
19:15:17 <shachaf> Closures are a possible implementation mechanism for implementing -- lexical scope?
19:15:34 <Cale> Well, there are forms of graph reduction where you're not explicitly forming things that look like closures
19:15:43 <Cale> You can do variable substitution
19:16:44 <Cale> Where instead of storing a separated pair of code and a dictionary which assigns values to the free variables of that code, you can rewrite the code to have those values in it directly.
19:18:35 <Cale> I would usually say the point at which they stop being "closures" and start being "functions" or "something else that has been implemented using closures" is when you can no longer observe the code separately from the environment
19:18:49 <Cale> A closure is explicitly a pair (code, env)
19:19:11 <Cale> You can use that same technique for implementing objects
19:19:41 <shachaf> Unevaluated thunks in Haskell can presumably be closures even if they aren't functions.
19:19:57 <Cale> Yeah
19:20:15 <monochrom> Yeah, the two implementation techniques are closures and substitution.  (There may be others.)
19:46:49 <jusss> Cale: the term Monad, can I think it as an environment which contain a value?
19:47:01 <jusss> or call context? 
19:47:47 <jusss> there're three term make me confused, Environment, Context, and Namespace
19:49:24 <dmj`> jusss: not really, a monad is anything that implements the monad typeclass lawfully. Just implement a lot of instances in practice, work out the laws, and you'll gain intuition that way as your brain generalizes the notion. https://wiki.haskell.org/All_About_Monads
19:50:33 <maerwald> Not sure implementing helps that much. I've maybe implemented 3 monad instances ever. Just read them.
19:51:10 <maerwald> It's more about using them
19:51:43 <maerwald> Implementing them you just follow the types mechanically.
19:51:46 <dmj`> Both help the intuition, the instances show you the proof.
19:52:10 <jusss> dmj`: I implement an instance of Monad a few days ago, it must be instance of Functor and Applicative first, and implement those functions like fmap <*> >>= return 
19:52:12 <dmj`> Sometimes you use a monad, but aren't sure how the bind is implemented, looking under the hood helps
19:52:20 <jusss> but I still don't know what a monad is
19:52:38 <maerwald> It's a typeclass... badum-tss :D
19:53:01 <maerwald> What is love? Don't think about it, go out into the world and experience it :D
19:53:04 <dmj`> exactly, its nothing special, just another typeclass in haskell, except it is special because of the do-syntax treatment, and the IO system is monadic
19:53:13 <jusss> maerwald: agree, not help much 
19:53:44 <jlamothe> I've never understood why people get so rabid about Monads.
19:54:27 <jusss> dmj`: after I implement an instance of Monad, I just realized about polymorphism
19:54:29 <dmj`> jusss: A monad is anything that lawfully upholds the monad laws. Just like how anything is a vector space that abides by the vector space axioms.
19:54:32 <jlamothe> I feel that Functors and Applicatives are also way overlooked.  People use Monad when one of the other two would suffice.
19:55:04 <jlamothe> I've been guilty of this myself.
19:55:06 <maerwald> dmj`: technically no
19:55:10 <dmj`> jusss: you should read this https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
19:55:16 <maerwald> A monad is anything that implements the typeclass, whether lawful or not
19:55:57 <dmj`> maerwald: right, those are naughty monads
19:56:34 <maerwald> eventually end up in monad prison
19:56:45 <dmj`> if gone unchecked, yes
19:57:26 <jusss> dmj`: I really do want to understand the term monad so that I can use it at any lanugaes, not just haskell, 'cause the most people use other lanuages at work
19:58:24 <jusss> the pattern matching is really special
19:58:46 <maerwald> why use them in other languages? chances are you will just obfuscate code and annoy your coworkers
19:58:59 <maerwald> if it doesn't come natural, it doesn't
19:59:15 <maerwald> don't look for tools, look for solutions
19:59:45 <jusss> maerwald: 'cause FP is popular
20:00:10 <maerwald> mongodb was also popular once
20:00:12 <dycan> hi all, anyone know why can't I evaluate this type expression to a Nat? https://gist.github.com/YuMingLiao/d199732449b6f60472396f115c601f84
20:01:04 <dycan> I was experimenting "evaluate a type expression"
20:02:45 <maerwald> jusss: https://blog.daftcode.pl/hype-driven-development-3469fc2e9b22
20:04:42 <shachaf> dycan: You're using the name "e" twice.
20:05:15 <shachaf> Try "Eval ('Add e1 e2) = Add (Eval e1) (Eval e2)" or something.
20:07:06 <dycan> shachaf: Wow! It works! Thanks!      What does I mean if I name e twice?
20:07:20 <dycan> oh pattern match
20:07:59 <shachaf> I'd guess unification?
20:08:31 <dycan> that means I assume them equal, right? And because it's partial so it stays as an expression.
20:08:49 <dycan> shachaf: thanks for explanation.
20:35:04 <rkuo> newbie question: many examples show:  line-1 `fst :: (a, b) -> a` and line-2 `fst (x,y) = x`  In GHCi, I got error with line-1, "No instance for (Show ((a0, b0) -> a0)) arising from a use of ‘print’,…." But I am ok with just line-2, and I got line-1 with `:t fst —> fst :: (a, b) -> a`. What I missed? When do I need to define function signature first? 
20:40:34 <MarcelineVQ> In ghci you enter things one statement at a time, so to define a signature along with a declaration you need to say "fst :: (a,b) -> a; fst (x,y) = x"
20:42:20 <MarcelineVQ> The error you're getting is that fst is already defined in the Prelude so when you type "fst :: (a, b) -> a" you're actually calling fst and telling it what types to use. Similar to how you can write 9 :: Int.
20:43:45 <MarcelineVQ> or 9 :: Double
20:44:48 <jusss> rkuo: it seems you should put the two together like :{ fst::(a,b)->a      fst (x,y) = x :}
20:46:02 <MarcelineVQ> ghci tries to print expressions you give it and printing needs a Show instance. fst is a function and functions don't have a Show instance. You'll see you get the same error if you just type fst on its own.
20:50:43 <rkuo>  Thank you, MarcelineVQ
21:51:52 <qwebirc38390> I'm trying to install the Haskell Platform on Mac, I ran curl https://get-ghcup.haskell.org -sSf | sh but then the computer told me "Following commands are required, but missing, please install: xz"
22:50:13 <maerwald> please install xz
23:01:48 <bahamas> I have a long of tuples that I want to write to a file. how can I do it while putting each list item on its own line?
23:02:38 <bahamas> `show` adds escapes to quotes and the newline I add in a previous step
23:09:44 <Cale> > unlines . map show $ [(1,2),(3,4),(5,6)]
23:09:46 <lambdabot>  "(1,2)\n(3,4)\n(5,6)\n"
23:09:52 <Cale> bahamas: like that?
23:10:43 <bahamas> Cale: it's missing the commas
23:11:04 <bahamas> this is a long list, so I would have to add a lot of commas by hand
23:12:20 <bahamas> so I want an actual list as a result that I can put in a .hs file
23:14:05 <maerwald> add commas
23:14:08 <ski> bahamas : can you give an example of "`show` adds escapes to quotes and the newline I add in a previous step" ?
23:14:34 <maerwald> you should be able to workwith the example cale gave and extend it, or use a pretty printer library
23:15:11 <bahamas> yes. `unlines $ fmap (\s -> ", " ++ show s) sschema` worked
23:15:17 * ski doesn't understand where bahamas would like extra commas
23:15:43 <ski> oh .. before each tuple ?
23:16:05 <bahamas> ski: the resulting string looked like `\\\"NULLABLE\\\", \\\"foo\\\" or something like that
23:16:13 <bahamas> ski: yes, I want a Haskell list
23:16:28 <ski> i don't understand what you mean by that
23:16:45 <ski> i thought you wanted characters to write to a file
23:18:09 <ski> the proliferation of backslashes sounds like using `show' multiple times "on the same thing". or perhaps confusing the way the interactor is showing strings with what will be put in your file. or perhaps both
23:18:50 <bahamas> ski: yes, I called show the first time on the tuple, so I could add the newline and then I called it again on the entire list
23:19:04 <bahamas> ski: I just wanted to write a Haskell file with a valid Haskell list in it
23:19:15 <ski> perhaps you want a custom way to show a list of tuples
23:19:21 <ski> okay
23:20:36 <bahamas> anyway, the solution works. thank you for the help
23:23:02 <ski> > (showString "[ " . (foldr (.) id . intersperse (showString "\n, ") . map shows) [(0,1),(2,3),(4,5),(6,7)] . showString "\n]") ""
23:23:03 <lambdabot>  "[ (0,1)\n, (2,3)\n, (4,5)\n, (6,7)\n]"
23:23:07 <ski> bahamas : something like that ^ ?
23:24:11 <ski> "I called show the first time on the tuple, ... and then I called it again on the entire list" -- yes, that's a mistake
23:25:02 * ski thinks there ought to be a `compose = foldr (.) id', and a `composeMap f = compose . map', in the standard libs
23:26:04 <Solonarv> :t appEndo . foldMap Endo -- ski ;)
23:26:05 <lambdabot> Foldable t => t (a -> a) -> a -> a
23:26:23 <ski> yea, implement it like that, if you prefer
23:26:36 <ski> point was, i want a name for it
23:37:30 <bahamas> ski: where is `showString` from?
23:41:05 <jusss> data Writer w a = Writer { runWriter :: (a, w) }   means runWriter Writer will get (a,w), but what is Writer?
23:41:25 <jusss> what this data type is without record syntax?
23:43:41 <jusss> data Writer w a = Writer (a,w) ?
23:44:32 <jusss> runWriter Writer :: (a,w) ?
23:47:37 <jusss> runWriter (Writer x y) = (y,x) ?
23:47:50 <bahamas> jusss: without `runWriter` you can't get the (a, w) out of Writer, if that's what you're asking
23:48:11 <jusss> bahamas: I'm asking what is this `Writer`
23:49:26 <bahamas> jusss: `Writer` is the name of the type (the part with `data Writer w a`) and the name of the value constructor (the part after `=`)
23:49:46 <jusss> bahamas: Writer w a is a type, and it's value is Writer (a,w) right?
23:50:45 <bahamas> jusss: yes
23:51:08 <jusss> bahamas: but the question, in the function, there's only values, right?
23:51:32 <bahamas> jusss: can you clarify what you mean by that?
23:51:39 <jusss> bahamas: so  runWriter what? = (y,x) ?   if a is y and w is x
23:52:19 <jusss> this `what?` value,  what is it/
23:52:58 <bahamas> jusss: it's `Writer (a, w)` where you replace a and w with actual values
23:53:45 <jusss> bahamas: so it's   runWriter Writer (x,y) = (y,x) , right?
23:53:55 <jusss> that a w don't matter
23:54:00 <Cale> jusss: runWriter is just the field extractor
23:54:25 <jusss> Cale: what you mean? runWriter isn't a function?
23:54:31 <bahamas> jusss: a and w are variables which you can replace with  values
23:54:39 <bahamas> jusss: a field extractor is a function
23:54:40 <Cale> It is a function, it extracts the only field of that record
23:54:45 <Cale> runWriter (Writer x) = x
23:55:01 <Cale> It's automatically defined when you define the type like that
23:55:23 <jusss> wait a sec, Writer a w type, its value is Writer (w,a)
23:55:40 <jusss> we can't operate type in function definition, we operate the value
23:55:52 <Cale> sure
23:55:57 <jusss> so we operate Writer (w,a) right? we can't operate Write a w
23:56:04 <Cale> huh?
23:56:20 <jusss> 'cause Write a w is a type
23:56:27 <jusss> and its value is Writer (w,a)
23:56:31 <bahamas> jusss: I think what confuses you is that both the type and the value have the same name `Writer`
23:56:45 <Cale> Maybe it would help if we defined the type to have a different name from its data constructor
23:56:47 <jusss> bahamas: no, not the name
23:56:56 <bahamas> jusss: if it helps, you can define it as `data WriterType w a = WriterV (a, w)`
23:57:11 <Cale> There's no actual confusion because you can never write types and values in the same place (at least in plain Haskell)
23:57:14 <jusss> bahamas: ok, and the runWriter
23:57:15 <jusss> ?
23:57:29 <Cale> runWriter (WriterV x) = x
23:57:40 <bahamas> jusss: `data WriterType w a = WriterV { runWriter :: (a, w) }`
23:57:44 <ski> @index showString
23:57:44 <lambdabot> Text.Show, Prelude
23:57:46 <ski> bahamas ^
23:57:56 <bahamas> ski: thanks!
23:57:58 <Cale> jusss: x :: (a,w)
23:58:10 <ski> bahamas : so, it's already in `Prelude' ..
23:58:17 <Cale> runWriter :: Writer w a -> (a,w)
23:58:23 <jusss> Cale: wait a sec, runWriter WriterV (a,w) = (w,a)
23:58:53 <Cale> runWriter only takes one argument..
23:59:12 <ski> `runWriter WriterV (a,w)' means `(runWriter WriterV) (a,w)'
23:59:24 <jusss> "data Writer w a = Writer { runWriter :: (a, w) }"
23:59:34 <Cale> It also wouldn't typically flip the tuple around because it's just extracting the value of that field
23:59:42 <Cale> Though I suppose if you want to flip the tuple, you can do that
