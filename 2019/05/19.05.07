00:00:02 <dminuoso> (I did a bit of pseudo code, leaving away the constraints)
00:00:33 <jusss> dminuoso: those type signatures, it's interesting
00:01:12 <dminuoso> jusss: In some sense (<*>) can be thought of generalizing fmap to functions with arbitrary arguments.
00:01:16 <jusss> dminuoso: fmap :: (a -> b) -> f a -> f b,  can I say fmap apply (a->b) on a in f a and get f (a->b) , it's f b
00:01:44 <jusss> dminuoso: or I should say apply (a->b) on f a?
00:01:53 <dminuoso> jusss: That is, fmap lets you lift a 1-arity function `a -> b` to `f a -> f b`, but with pure/(<*>) you can lift `a` to `f a` and `a -> b -> c` to `f a -> f b -> f c`
00:02:07 <dminuoso> Or `a -> b -> c -> d` to `f a -> f b -> f c -> f d`
00:03:01 <dminuoso> jusss: It's rather: `a -> b` is lifted to `f a -> f b`
00:03:27 <dminuoso> fmap is a way to take a function `Int -> Char` and build a `Maybe Int -> Maybe Char` from it.
00:03:45 <dminuoso> Or lift a `Char -> Bool` into `[Char] -> [Bool]`
00:04:02 <dminuoso> Applicative generalizes this to values and functions of arbitrary length
00:04:38 <jusss> dminuoso: about the type inference, how I should understand about that fmap apply (a->b) on (f a) or a in (f a) ?
00:05:22 <dminuoso> jusss: Neither. Type inference is just the act of figuring out what parts of your program have what type, without needing type annotations.
00:06:03 <dminuoso> % :t fmap
00:06:03 <yahb> dminuoso: Functor f => (a -> b) -> f a -> f b
00:06:05 <dminuoso> This is really:
00:06:14 <dminuoso> fmap :: Functor f => (a -> b) -> (f a -> f b)
00:06:24 <jusss> dminuoso: about this fmap :: (a -> b) -> f a -> f b,    is there a type like (a->b) -> f a -> a?
00:06:27 <dminuoso> If you squint for a moment you will see that fmap takes one argument and it returns a function.
00:06:37 <jusss> or (a->b) -> f a -> b
00:07:40 <dminuoso> jusss: Not that I know. There's other things though like `(f a -> b) -> f a -> f b`
00:08:13 <dminuoso> Where there is a special constraint on `f` too.
00:08:46 <jusss> dminuoso: ok, so the final type is what we write not we calculate
00:08:56 <dminuoso> jusss: What do you mean?
00:09:18 <jusss> dminuoso: I thought that we can calculate (f b) from (a->b) -> f a
00:09:44 <dminuoso> I do not follow.
00:10:31 <jusss> dminuoso: if there's a type (a->b) -> f a,  and I thought we can get the final return type is f b through (a->b) -> f a -> f b
00:11:07 <jusss> it seems I was wrong
00:11:23 <dminuoso> jusss: Can you perhaps rephrase the question?
00:11:36 <dminuoso> Or explain in differnet terms?
00:11:38 <jusss> dminuoso: sorry for my English
00:12:30 <dminuoso> jusss: Are you asking whether the return type of `fmap` can be deduced from its arguments
00:12:32 <dminuoso> ?
00:12:37 <jusss> dminuoso: let's assume there's a type like T::(a->b) -> f a,   so we can get T :: f b
00:12:49 <jusss> dminuoso: yeah, that's what I mean
00:13:05 <dminuoso> jusss: Yes, that's what type inference gives us. It's a logic system, basically.
00:13:42 <dminuoso> jusss: For example: If we know a function has type `f :: Char -> Int`, and we know that `x :: Char`, then we can deduce that `f x :: Int`
00:14:06 <jusss> dminuoso: so, look at this fmap :: (a->b) -> f a -> f b, so how should I think about fmap apply (a->b) on (f a) or just a in (f a) and we get (f b)?
00:15:37 <dminuoso> jusss: Neither, like I said.
00:16:05 <dminuoso> jusss: Think that fmap takes *one* argument.
00:16:05 <jusss> dminuoso: ok, no appy, it's just type inference , right?
00:16:21 <jusss> dminuoso: let's just focus on the type inference
00:16:37 <jusss> dminuoso: (a->b) -> f a, we can get f b, right?
00:16:53 <dminuoso> jusss: The language you are using does not make sense to me.
00:17:05 <dminuoso> By language I mean the way you are using what looks like type signatures.
00:17:35 <dminuoso> jusss: fmap is more than just type inference.
00:17:46 <dminuoso> jusss: You can use fmap without any type inference in fact.
00:18:04 <dminuoso> % listMap :: (a -> b) -> [a] -> [b]; listMap = fmap
00:18:04 <yahb> dminuoso: 
00:18:34 <dminuoso> % addOneToEachElem :: [Int] -> [Int]; addOneToEachElem = listMap (+1)
00:18:35 <yahb> dminuoso: 
00:18:40 <dminuoso> % addOneToEachElem [1,2,3,4]
00:18:41 <yahb> dminuoso: [2,3,4,5]
00:18:42 <jusss> dminuoso: (<*>) :: f (a -> b) -> f a -> f b,     I think  it's should be f (a->b) -> f a -> f (f b)
00:19:23 <dminuoso> jusss: Let's ignore (<*>) for a moment, okay?
00:19:30 <jusss> dminuoso: ok
00:19:41 <dminuoso> jusss: Do you see how `fmap` turns a function `Int -> Char` into say `[Int] -> [Char]`?
00:19:49 <dminuoso> `fmap` is a function transformer, if you want.
00:20:33 <dminuoso> It takes a function, and builds a new function (in some way that is related to the original function)
00:20:52 <jusss> dminuoso: yeah, new function with the same input 
00:21:00 <dminuoso> Not the same input.
00:21:21 <jusss> same input type?
00:21:23 <dminuoso> Nope.
00:21:37 <dminuoso> jusss: Whats the input type of `f :: Int -> Char`
00:22:16 <jusss> dminuoso: Int
00:23:19 <jusss> dminuoso: but your `fmap` turns a function `Int -> Char` into `[Int] -> [Char]`  is not a function, it's a list
00:23:28 <dminuoso> jusss: Are you sure?
00:23:38 <dminuoso> `[Int] -> [Char]` is not a function? :-)
00:23:39 <jusss> dminuoso: [Char] is a function?
00:24:18 <dminuoso> jusss: No, but `[Int] -> [Char]` is.
00:24:44 <jusss> dminuoso: oh, just fmap (a->b)
00:24:59 <jusss> (e->a) -> (e->b)
00:25:43 <jusss> dminuoso: yeah, that (e->a) -> (e->b) is a funtion, with a function input and with a function output
00:26:09 <jusss> the function's input type is (e->a)
00:26:12 <dminuoso> jusss: https://gist.github.com/dminuoso/787f98e07af511d3a17908a6c6ba043b
00:26:28 <dminuoso> jusss: fmap transforms a function, it doesnt apply to it.
00:27:46 <dminuoso> jusss: The thing that happens here is that functions are curried.
00:28:07 <dminuoso> `fmap (+1) [1,2,3]` is two applications, in a sense.
00:28:09 <jusss> dminuoso: but how to describe that fmap with (a->b)
00:28:28 <jusss> dminuoso: how fmap use (a->b) to transform (e->a) to (e->b)?
00:28:45 <dminuoso> jusss: That is specified in the instance declaration of the Functor instance for each respective type.
00:29:01 <dminuoso> For example: The way to lift `a -> b` into `Maybe a -> Maybe b` is defined in the instance Functor Maybe.
00:29:40 <jusss> dminuoso: the word to express the relation, "use" is proper?
00:30:02 <dminuoso> jusss: Honestly I do not know what you mean by `e -> a` and `e -> b`
00:30:13 <merijn> dminuoso: tbh, I've never found the "functions are curried" (or really any mention of currying/uncurrying) to be particularly helpful for confused people, because it's mostly orthogonal to the real problem people have (i.e. all functions only ever have one argument)
00:30:16 <jusss> obvious, "apply" is not proper
00:30:42 <dminuoso> jusss: Right. It uses it to create a new function rather.
00:31:00 <dminuoso> (Or in some special cases it may be disregarded)
00:31:14 <jusss> dminuoso: (e->a) is a function, (e->b) same too
00:31:48 <dminuoso> jusss: Ohh I think I just understood your question then.
00:31:59 <dminuoso> jusss: Take it as a challenge.
00:32:14 <dminuoso> jusss: Fix `e` to some type, because the choice does not matter.
00:32:40 <dminuoso> jusss: So try to write a function: banana :: (a -> b) -> (Int -> a) -> (Int -> b)
00:34:15 <jusss> dminuoso: but Int is a specific type, it's ok to use  with that type variables?
00:34:23 <dminuoso> jusss: Yes.
00:34:38 <dminuoso> jusss: The details of why this is okay are really not important.
00:35:37 <jusss> dminuoso: banana::(Int->Int) -> (Int->Int) -> (Int->Int) 
00:36:02 <dminuoso> jusss: You may not change the other type variables.
00:36:08 <dminuoso> banana :: (a -> b) -> (Int -> a) -> (Int -> b)
00:36:12 <dminuoso> This is what you should implement.
00:36:54 <jusss> dminuoso: yeah, I just use Int as the instance of a, that's not ok?
00:37:27 <jusss> banana (+1) (+2)
00:37:49 <dminuoso> jusss: For using it, that's fine. But I want you to write the function `banana` yourself, and it should have the exact type signature I specified.
00:38:17 <jusss> banana x y z = x (y z)
00:39:14 <dminuoso> jusss: That looks good. Are you familiar with the (.) operator already?
00:39:17 <jusss> banana x y = \x x( y x)
00:39:48 <jusss> banana  x y = \z x( y z)
00:40:23 <jusss> dminuoso: (.) is fmap when Functor is (e->)
00:40:34 <dminuoso> jusss: Right.
00:40:39 <jusss> and map is fmap when Functor is List []
00:40:46 <dminuoso> jusss: Also right.
00:40:53 <jusss> and what's wrong?
00:41:03 <dminuoso> jusss: Nothing. :)
00:41:29 <jusss> dminuoso: I always think that there's a consume in that type
00:41:43 <jusss> so we can consume a 'a' in (a->b) -> f a, 
00:41:55 <jusss> consume a 'a' so we can get f b
00:42:01 <jusss> obvious, I was wrong
00:42:29 <jusss> I found that I really like those type variables, not specific type
00:42:47 <dminuoso> jusss: Now do you see how `fmap` lets you transform functions of shape `a -> b` into `f a -> f b` for some choice of f?
00:42:52 <merijn> jusss: That'd be because you're slowly getting an intuition for free theorems ;)
00:43:01 <dminuoso> :)
00:46:30 <jusss> dminuoso: wait a sec, what fmap x = ?
00:46:51 <dminuoso> jusss: Any, really.
00:47:28 <dminuoso> for [], fmap lets you turn `a -> b` into `[a] -> [b]`, for Maybe fmap lets you turn `a -> b` into `Maybe a -> Maybe b`, for IO fmap lets you turn `a -> b` into `IO a -> IO b`
00:47:31 <dminuoso> And so forth
00:47:47 <dminuoso> jusss: https://gist.github.com/dminuoso/daedae39ed76577d81d1a5984bf45b5e
00:48:15 <dminuoso> So Applicative generalizes this pattern to not just work with `a -> b`, but also just `a` or `a -> b -> c`, or `a -> b -> c -> d`, or any such function
00:48:31 <jusss> dminuoso: oh, I think I understand what you mean, fmap turn (a->b) into (e->a) -> (e->b)
00:48:38 <dminuoso> jusss: Right.
00:48:57 <jusss> dminuoso: not fmap use (a->b) turn (e->a) to (e->b)?
00:49:37 <dminuoso> jusss: Well the function is usually used, somehow.
00:49:51 <dminuoso> But its not specified how its used, its different for each type.
00:49:57 <dminuoso> We just have 2 laws you need to satisfy.
00:50:10 <jusss> dminuoso: and what's it?
00:50:20 <dminuoso> jusss: Well it can be condensed into one law really:
00:50:21 <dminuoso> fmap id = id
00:51:01 <dminuoso> Which says if you use `fmap` to transform id, the resulting function must act as the identity function.
00:51:12 <jusss> and ?
00:51:26 <dminuoso> jusss: Forget the other law, I shouldnt have mentioned it. We have only one law.
00:51:44 <jusss> dminuoso: so fmap (\x->x) = \x -> x
00:51:45 <jusss> ?
00:52:33 <dminuoso> jusss: You cant actually write thta.
00:52:50 <jusss> dminuoso: I wonder if I give a function to \x and I get a function?
00:52:52 <dminuoso> jusss: When I say `fmap id = id` its not meant as Haskell code, its a statement of a law.
00:53:01 <dminuoso> Basically:
00:53:06 <dminuoso> fmap id [1,2,3] *must* produce [1,2,3]
00:53:22 <dminuoso> `fmap id (Just 7)` *must* produce `Just 7`
00:53:30 <jusss> dminuoso: fmap id id?
00:54:29 <dminuoso> jusss: that gives you `id` back, trivially
00:54:33 <dminuoso> id x = x
00:55:00 <dminuoso> If you take `fmap id = id`, then you can substitute in your code: id id, and the result of that is just id
00:55:53 <jusss> dminuoso: about fmap :: (a->b) -> ( (e->a) -> (e->b) ),  if id is (a->b) so fmap id = id, the id right after '=' is (e->a)->(e->b) right?
00:56:18 <dminuoso> jusss: `fmap id = id` is not Haskell code.
00:56:43 <jusss> dminuoso: what do you mean is not Haskell code?
00:56:43 <dminuoso> jusss: Perhaps its less confusing if I state it using words: if you fmap over something using id, it must give you that something back unchanged.
00:57:01 <dminuoso> that's the single law of functor
00:57:37 <dminuoso> % fmap id [1,2,3]
00:57:38 <yahb> dminuoso: ; <interactive>:55:1: error:; * Ambiguous type variables `f0', `b0' arising from a use of `print'; prevents the constraint `(Show (f0 b0))' from being solved.; Probable fix: use a type annotation to specify what `f0', `b0' should be.; These potential instances exist:; instance Show a => Show (ZipList a) -- Defined in `Control.Applicative'; instance Show a => Show (Co
00:57:43 <dminuoso> % fmap id "foobar"
00:57:44 <yahb> dminuoso: "foobar"
00:57:48 <dminuoso> % fmap id (Just 'c')
00:57:49 <yahb> dminuoso: Just 'c'
00:57:52 <dminuoso> % fmap id Nothing
00:57:53 <yahb> dminuoso: Nothing
00:58:15 <dminuoso> so `fmap id` is a no-op. It produces the id function.
01:00:31 <jusss> dminuoso: but that type in fmap, the produced id function's type is?
01:00:53 <merijn> :t fmap id
01:00:54 <lambdabot> Functor f => f b -> f b
01:02:00 <jusss> merijn: but the produced id can't be f b -> f b,    id :: a -> a
01:02:10 <dminuoso> jusss: Good catch.
01:02:23 <dminuoso> jusss: Turns out, that `id :: a -> a` is the most general type.
01:02:45 <dminuoso> idInt :: Int -> Int; idInd x = x
01:02:53 <dminuoso> jusss: ^- would you agree that this, too, is an identity function?
01:03:10 <jusss> dminuoso: you want to express a can be f b?
01:03:22 <dminuoso> jusss: Exactly.
01:03:30 <merijn> :t id `asAppliedTo` Nothing
01:03:32 <lambdabot> Maybe a -> Maybe a
01:03:44 <merijn> :t id `asAppliedTo` 'c'
01:03:46 <lambdabot> Char -> Char
01:03:58 <dminuoso> % :t id
01:03:58 <yahb> dminuoso: a -> a
01:04:18 <dminuoso> jusss: There's a cool trick:
01:04:27 <delYsid`> merijn: Thanks for that storable vector hint, its working now.
01:04:31 <dminuoso> % (+1) `id` 5
01:04:31 <yahb> dminuoso: 6
01:04:33 <merijn> delYsid`: \o/
01:04:41 <jusss> dminuoso: wait a sec, % fmap id 3
01:04:47 <merijn> delYsid`: Now you too can program C in Haskell! ;)
01:04:56 <jusss> id 3 is 3, but fmap id 3 is wrong
01:05:11 <dminuoso> jusss: Right!
01:05:17 <dminuoso> jusss: Its a slightly more specialized id.
01:05:32 <dminuoso> jusss: So when I say `fmap id = id` its not meant as "fmap id" gives you the "most general id function back"
01:05:40 <delYsid`> merijn: Yeah, after getting over the initial shock, its actually quite nice.
01:05:46 <dminuoso> But rather "fmap id" gives you a "slightly less general id function back"
01:05:49 <jusss> dminuoso: then fmap id = id, this id shoud change its name like id2 or idf
01:05:55 <dminuoso> jusss: If you prefer, sure.
01:05:58 <dminuoso> If that helps.
01:06:10 <dminuoso> fmap id = id'
01:06:46 <jusss> dminuoso: then the first and only law in Functor is really confusing people
01:07:55 <dminuoso> jusss: Sadly we do not have a precise language to formulate the laws in a way that would be understandable by most beginners.
01:07:55 <merijn> delYsid`: Yes, the application is rather limited, but where applicable (like your problem) it does give you massive performance benefits with the minimum required memory :)
01:08:09 <jusss> 'cause that new id :: f b -> f b, not id :: a -> a,   the new id is a subset of the old id
01:08:35 <dminuoso> jusss: `fmap id = id` seemed like the best effort, do you have a better alternative?
01:08:37 <merijn> delYsid`: You can actually do even more advanced things based on this. You can use mmap to map a file into memory and rely on the OS to page data from disk to memory "on-demand" :)
01:09:08 <dminuoso> jusss: And you are absolutely right.
01:09:39 <dminuoso> jusss: But you are slowly getting a hang for type unification, which I think is great.
01:10:08 <jusss> dminuoso: what about <*> and >>= , they're same with fmap?
01:10:44 <dminuoso> jusss: no, they are more powerful actually.
01:11:20 <jusss> now we can say fmap transform (a->b) to ( (e->a) -> (e->b) ), so I wonder how to express about <*> and >>=
01:11:55 <dminuoso> jusss: https://gist.github.com/dminuoso/daedae39ed76577d81d1a5984bf45b5e
01:12:16 <dminuoso> jusss: This tells you what Applicative (this is the typeclass that <*> is in) is, in relation to Functor.
01:12:25 <dminuoso> (>>=) is... different.
01:12:34 <Solonarv> % :t (<*>) @((->) _) -- here's what <*> looks like for functions
01:12:35 <yahb> Solonarv: (w -> a -> b) -> (w -> a) -> w -> b
01:13:17 <dminuoso> jusss: You can do this yourself very mechanically.
01:13:27 <dminuoso> Replace every instance of `f` with ((->) e)
01:13:31 <Solonarv> % :t (=<<) @((->) _) -- and here's =<< (which is just >>= flipped)
01:13:31 <yahb> Solonarv: (a -> w -> b) -> (w -> a) -> w -> b
01:14:32 <dminuoso> jusss: So Applicative lets you do: `a -> (e -> b)`, `(a -> b) -> (e -> a) -> (e -> b)`, `(a -> b -> c) -> (e -> a) -> (e -> b) -> (e -> c)`, etc...
01:15:03 <dminuoso> jusss: Though it should be said that the `e` here is special.
01:15:09 <Solonarv> dminuoso: your first one is wrong, it should be 'a -> (e -> a)'
01:15:22 <dminuoso> Oh, good catch.
01:15:39 <jusss> dminuoso: Applicative transform (w->a->b) to ((w->a) -> (w->b)) ?
01:16:10 <dminuoso> jusss: take my diagram, and copy some snippet off a type signature
01:16:44 <dminuoso> jusss: And mechanically replace `f` with ((->) e)`, and by mechanically I mean use search-and-replace with your editor
01:17:06 <jusss> dminuoso: in you diagram, Functor only have two element, but Applicative have any element
01:17:11 <dminuoso> jusss: Exactly!
01:17:54 <dminuoso> Applicative is more general than Functor, which is why less instances exist.
01:18:30 <dminuoso> (Since not all type constructors support this "works for any number of components in a function")
01:19:26 <jusss> dminuoso: <*> transform any element to a form that I don't know how to express
01:19:59 <jusss> elements are "contained" by functor
01:20:43 <jusss> dminuoso: wait a sec, those element, they 're function
01:20:47 <dminuoso> jusss: Yup!
01:20:54 <dminuoso> jusss: Applicative too transforms functions.
01:21:00 <jusss> in functor, a->b,  in applicative, a or a->b or a->b->c
01:21:02 <dminuoso> Except Functor limits you to functions taking one argument.
01:21:15 <dminuoso> Applicative lets you do this with functions taking *any* number of arguments
01:21:21 <dminuoso> jusss: Spot on.
01:21:52 <jusss> dminuoso: that arguments are not important I think, 'cause currying
01:22:02 <dminuoso> jusss: They are here.
01:23:44 <dminuoso> jusss: For me, finding good intuition requires frequently changing perspectives. So I constantly jump between "functions have only one argument" and "functions can have many arguments", depending on which perspective gives better intuition.
01:25:55 <dminuoso> jusss: Relatedly, starting from Applicative you stop thinking of that `f` as "container"
01:26:08 <dminuoso> jusss: Usually we start thinking of `f` as being a kind of effect.
01:27:18 <dminuoso> jusss: but that may not be helpful to you, if it confuses you just disregard it.
01:38:49 <talqu> https://www.stackage.org/haddock/lts-7.14/lucid-2.9.7/Lucid-Html5.html#v:script_ I can't write `script_ [src_ "main.js"]`, neither prepending the expression with `with`. How is this element different in the first place and can't be written following what docs say. div_, table_, .. work well. How do i write a script_ with a source attribute?
01:41:55 <Solonarv> talqu: it looks like you always need to give children
01:42:49 <Solonarv> so this should work: script_ [src_ "main.js"] ""
01:43:12 <talqu> Solonarv: 
01:43:38 <Solonarv> hm? did you hit enter too early?
01:47:27 <talqu> sorry hit enter too early :), it compiles when written this way: `script_ [src_ "main.js"] ("" :: Text)`. Now, when I inspect the type I get: `script_ :: [Attribute] -> Text -> HtmlT m ()`, however, in docs the type of the expression is `script_ :: TermRaw arg result => arg -> result` and I don't see how to derive/understan this type to `script_ :: [Attribute] -> Text -> HtmlT m ()`
01:47:36 <jusss> dminuoso: but <*> :: f (a->b) -> f a -> fb,  <*> transform that function in Applicative to another function(f a -> f b) right?
01:48:18 <dminuoso> jusss: Right. So the diagram I showed you is basically what you can do with pure and (<*>)
01:48:18 <jusss> it's kind of like (1+2)*3 == 1*3 + 2*3
01:48:37 <Solonarv> talqu: what I did is to go look at the docs for TermRaw
01:48:53 <dminuoso> jusss: Nope.
01:49:00 <Solonarv> specifically, the instances section
01:50:04 <dminuoso> % liftA0 = pure
01:50:04 <yahb> dminuoso: 
01:50:45 <Solonarv> we know that script_ :: TermRaw arg result => arg -> result
01:50:45 <Solonarv> the instances tell us that this must be 'Text -> Attribute', or 'Text -> HtmlT m ()', or '[Attribute] -> f -> HtmlT m ()' with ToHtml f
01:52:37 <jusss> dminuoso: if f is (e->),   so <*> :: (e->) (a->b) -> (e->a) -> (e->b)
01:53:28 <jusss> I don't know if I can write that (e->) (a->b) to (e->a->b)
01:53:40 <dminuoso> jusss: You must, actually.
01:53:46 <dminuoso> jusss: Alternatively, you can write it as:
01:54:21 <dminuoso> ((->) e (a -> b)) -> ((->) e a) -> ((->) e b)
01:54:39 <dminuoso> So by wrapping the arrow with parens you can write it in prefix notation.
01:54:43 <jusss> dminuoso: and function can be Applicative too?
01:54:44 <dminuoso> Just like you would with operators.
01:54:56 <dminuoso> jusss: Try implementing the following two functions:
01:55:11 <dminuoso> coconut :: a -> (Int -> a)
01:55:37 <dminuoso> mango :: (Int -> (a -> b)) -> (Int -> a) -> (Int -> b)
01:55:50 <jusss> coconut x = \y -> x
01:56:09 <talqu> Solonarv: thank you, i see it now. Also this class use {-# LANGUAGE MultiParamTypeClasses #-} right? You couldn't write `class TermRaw arg result` without that extension?
01:56:23 <Solonarv> talqu: yes, and also FunctionalDependencies
01:56:33 <dminuoso> And FlexibleContexts
01:56:51 <dminuoso> Oh well all those things.
01:56:56 <Solonarv> FlexibleInstances too I think
01:57:16 <dminuoso> MPTC almost always goes hand-in-hand with FlexibleContexts and FlexibleInstances.
01:57:26 <Solonarv> basically a handful of generally-recognised-as-unproblematic extensions to the typeclass machinery
01:57:27 <dminuoso> Its almost suprising why it doesn't include those.
01:58:08 <Solonarv> dminuoso: also with FunctionalDependencies, if you want type inference to work nicely
01:58:26 <dminuoso> Solonarv: Im willing to argue that no.
01:58:48 <Solonarv> Hm. Not always, but certainly often
01:59:36 <jusss> mango \x -> \y -> z = \ICantWrite (\x -> y) -> (\x->z)
02:00:03 <dminuoso> jusss: Use your editor, and use GHC to typecheck and subsequently test your code.
02:05:57 <jusss> dminuoso: let's g :: a->b,  f:: Int -> a ,  g( f Int) = b
02:07:03 <jusss> wrong
02:10:50 <jusss> dminuoso: f::Int->(a->b)   g::Int->a   mango f g Int = (f Int) (g Int)
02:11:13 <jusss> dminuoso: right?
02:12:59 <dminuoso> jusss: You should practice writing this in correct Haskell code.
02:13:19 <dminuoso> This helps you as well as others trying to understand you.
02:14:16 <jusss> Prelude> mango f g x = (f x) (g x)
02:14:22 <jusss> mango :: (t1 -> t2 -> t3) -> (t1 -> t2) -> t1 -> t3
02:14:32 <dminuoso> jusss: Looks great.
02:15:02 <dminuoso> jusss: Now it should be said that Alternative too has some laws, but they are far more elaborate than the simple Functor law.
02:15:40 <dminuoso> jusss: In general you should test whether your instance satisfies the necessary laws.
02:15:51 <Solonarv> dminuoso: did you mean s/Alternative/Applicative/ ?
02:16:36 <merijn> ugh...why do we have catches with a list of handlers, but not handles with a list of handlers? >.>
02:16:57 <dminuoso> Solonarv: Funny, I was just about to write somethig in -ot about Alternative, my mind must have played a trick on me.
02:17:56 <jusss> deduce a function's definition from its type signature is so amazing! of course this one function is just an instance of the type, like a subset
02:19:00 <dminuoso> jusss: The more general a type is, the better this works.
02:19:26 <dminuoso> Also it frequently leads to situations where it's very hard to write something that still type checks but is wrong.
02:19:30 <Solonarv> sometimes (when the type signature is general enough) there really is only one possible non-bottom value for it
02:20:05 <Solonarv> examples: id :: a -> a; (.) :: (b -> c) -> (a -> b) -> (a -> c)
02:20:05 <dminuoso> jusss: Consider `id :: a -> a`, how many different implementations can you think of?
02:20:20 <jusss> dminuoso: what are those laws about Applicative
02:20:39 <jusss> dminuoso: id x = x
02:20:55 <jusss> dminuoso: x can be function or string or int or whatelse
02:20:59 <dminuoso> jusss: You can review them here https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Applicative
02:21:08 <dminuoso> jusss: Okay. Can you write it differently?
02:21:12 <dminuoso> Perhaps in such a way that it changes its input
02:21:40 <jusss> dminuoso: that sounds like a typeclass stuff
02:21:58 <jusss> one type signature but with different instances
02:22:41 <Solonarv> ah, but there's no typeclass in 'id :: a -> a'
02:22:52 <dminuoso> I think I understand what jusss is getting at though
02:23:00 <jusss> yeah, I'm wrong
02:23:11 <dminuoso> jusss: `id :: a -> a` means it must work for *any* possible choice of a.
02:23:19 <jusss> dminuoso: yeah,
02:23:38 <jusss> dminuoso: anything, functor, function, list, string , number, anything
02:23:50 <dminuoso> Exactly.
02:23:53 <jusss> 'cause a can be any type I think
02:24:07 <jusss> like fmap id is a subset of id
02:24:08 <dminuoso> jusss: And that means you cant know anything about its argument. If you dont know anything about it, the only thing you can do is give it back or disregard it.
02:24:40 <dminuoso> But you have to return something of `a`. Since you cant just make up arbitrary values of *any* type, the only thing you can actually do, is return the one thing of type `a` that you have.
02:25:20 <dminuoso> so the type system in its generality has you constrained in such a way, that you can reason about what a function can do and what it cant do
02:25:40 <jusss> dminuoso: so its type has to be defined in the function
02:25:54 <jusss> a specific type
02:26:07 <dminuoso> jusss: The *user* picks the type.
02:26:13 <dminuoso> jusss: The user of your function/value
02:26:23 <dminuoso> User/caller/consumer
02:26:48 <dminuoso> Its not the implementor. The implementor cant know in advance what type or even types (!) the consumer/user/caller will pick.
02:27:25 <dminuoso> `class Functor f where fmap :: (a -> b) -> f a -> f b` here for example an instance implementor cannot know what `a` and `b` are in advance.
02:27:40 <dminuoso> The implementation has to be able to work with *all* choices of `a` and `b`
02:27:49 <jusss> dminuoso: it gives me a feel that type signature is amazing, and function definition isn't
02:28:26 <dminuoso> fmap is by very simple type mechanics prohibited to ever know details about the content. it cant know in advance what `a` or `b` will be
02:28:51 <dminuoso> the implementation must work for all choices, so it knows nothing about it
02:28:58 <dminuoso> except what it has been given, namely that functoin
02:29:13 <dminuoso> % :t ($)
02:29:14 <yahb> dminuoso: (a -> b) -> a -> b
02:29:18 <dminuoso> jusss: ^- try implementing that function.
02:30:16 <jusss> dminuoso: f::a->b     $ f a = b
02:31:05 <dminuoso> So there too, you dont know what `a` or `b` are, the only things you have are your arguments. If you play this game long enough you can solve pretty fancy type puzzles and very often end up with the only but correct solution.
02:32:57 <jusss> $ f x  = f x
02:33:15 <dminuoso> jusss: Notice how both sides are the same? This is a special case of another function you have seen.
02:33:25 <dminuoso> Can you guess which?
02:33:52 <merijn> prettyprinter seems to only split Text on linebreaks for linewrapping, how do I get it to split on words for softwrapping?
02:34:07 <jusss> Prelude> mango f x = f x
02:34:12 <jusss> mango :: (t1 -> t2) -> t1 -> t2
02:34:22 <dminuoso> jusss: Not quite.
02:34:38 <dminuoso> % :t ($)
02:34:40 <yahb> dminuoso: (a -> b) -> a -> b
02:34:46 <dminuoso> jusss: If I write the implicit parens here:
02:34:55 <dminuoso> ($) :: (a -> b) -> (a -> b)
02:35:02 <jusss> dminuoso: id
02:35:15 <dminuoso> jusss: But that means we can use `id` to apply to functions!
02:35:26 <dminuoso> % (+1) `id` 5
02:35:26 <yahb> dminuoso: 6
02:36:31 <dminuoso> jusss: merijn mentioned it earlier. This whole business of "the only possible implementation", "judging what a function can do by just looking at the type signature" is called parametricity.
02:36:35 <jusss> dminuoso: (id (+1)) 5 I perfer
02:36:46 <jusss> id (+1) == (+1)
02:36:51 <dminuoso> jusss: So a shorter implementation of ($) is this:
02:36:56 <dminuoso> ($) = id
02:38:43 <jusss> dminuoso: one signature, it can be other signatures,    a->a can be (a->b) -> (a->b) ?
02:38:53 <dminuoso> jusss: So lets rerwite one type signature
02:38:56 <dminuoso> id :: r -> r
02:39:04 <reactormonk> '<>' is not a (visible) member of class Semigroup - what? I'm using ghc 8.2, so it should be there
02:39:08 <dminuoso> If we set: r ~ (a -> b)
02:39:12 <dminuoso> Then it should be obvious
02:39:57 <dminuoso> jusss: Remmeber: `id :: r -> r` means for *any* choice of type `r`
02:40:04 <dminuoso> that choice includes functions.
02:40:25 <jusss> dminuoso: and wehn r is (a->b)        r->(a->b) can be (a->b)->(a->b)   ?
02:40:47 <jusss> when
02:40:48 <dminuoso> jusss: So things get complicated at this point.
02:41:07 <jusss> dminuoso: and it's more general
02:41:25 <jusss> dminuoso: a can be any type
02:41:29 <dminuoso> jusss: The short answer is, there's different kinds of letters.
02:41:43 <dminuoso> jusss: This act of "setting type variables equal to another" is a business called type unification
02:43:19 <merijn> reactormonk: Did you import it from Data.Semigroup ?
02:43:24 <jusss> dminuoso: and Applicative laws?
02:43:34 <dminuoso> jusss: They too are probably a bit overwhelming for now.
02:43:49 <dminuoso> jusss: Just know there exist laws, but you need not know them for now.
02:44:45 <jusss> dminuoso: I just know that List and Function are Functor and Applicative 
02:44:58 <dminuoso> jusss: Strictly speaking its not function.
02:45:14 <jusss> dminuoso: a partial function?
02:45:29 <jusss> dminuoso: I don't know how to express properly, the name
02:45:33 <dminuoso> jusss: If we think of a function as `A -> B`
02:45:54 <dminuoso> Then we take that type signature and punch a hole in it, turn it into `A -> _`
02:46:13 <dminuoso> That would be a valid functor and applicative.
02:46:33 <jusss> dminuoso: A-> _ isn't a function right?
02:46:52 <dminuoso> jusss: Its a type that's still missing one argument.
02:47:28 <dminuoso> jusss: Now the interesting part is, the choice of `A` is completely free. That is, it doesn't matter whether it's `A -> _`, `D -> _`. It works for *any* choice of a type there.
02:47:30 <jusss> dminuoso: so what's the porperly to express? 
02:47:32 <dminuoso> Which is why the instance is written:
02:47:38 <dminuoso> instance Functor ((->) e)
02:48:24 <dminuoso> So using that previous notation, you could think of `e -> _` being a Functor for every choice of a type e.
02:48:38 <dminuoso> Equivalently [_] is a functor with a hole inside.
02:48:45 <dminuoso> We just write it as []
02:49:03 <dminuoso> But `[]` is basically too missing that type parameter
02:49:40 <jusss> dminuoso: yeah, functor and applicative both need a type to complete themself?
02:49:55 <dminuoso> jusss: Exactly. They work on types missing one type argument.
02:50:05 <dminuoso> Int cant be Functor
02:50:10 <dminuoso> [Int] cant be Functor
02:50:20 <dminuoso> But (Int ->) can 
02:50:25 <dminuoso> [] can
02:50:45 <jusss> dminuoso: and about the m-word?
02:50:50 <dminuoso> jusss: Same story.
02:51:15 <dminuoso> jusss: Functor/Applicative/Monad are all interfaces for types that are "missing one type argument for completion"
02:51:29 <dminuoso> jusss: You can in fact observe this in the type signatures
02:51:32 <dminuoso> % :t fmap
02:51:32 <yahb> dminuoso: Functor f => (a -> b) -> f a -> f b
02:51:47 <jusss> dminuoso: what's the wonders in Monad
02:52:03 <jusss> about
02:52:03 <dminuoso> jusss: Its just a very abstract interface, nothing special.
02:52:25 <jgt> with Yesod's type-safe routing; is there a way to change the protocol?
02:52:53 <dminuoso> jusss: Let me give you an analogy in terms of "just to show you that some ideas are simple in principle, but too broad to recognize instantly"
02:53:01 <jgt> for example, change the rendered url from https:// to ws://
02:53:12 <jusss> dminuoso: ok
02:53:12 <dminuoso> jusss: There's a common typeclass called Semigroup which consists of a single method `(<>) :: s -> s -> s`
02:53:36 <dminuoso> jusss: It doesnt have any special purpose. It just generalizes the idea of "smashing/combining things together" in some meaningful way.
02:54:24 <Logio> with certain properties assumed from the operation, generally
02:54:34 <jusss> dminuoso: that (->) e can be monad?
02:54:46 <dminuoso> jusss: Try implementing this function:
02:55:09 <dminuoso> jusss: cocoa :: (a -> Int -> b) -> (Int -> a) -> (Int -> b)
02:56:20 <jusss> similar with  mango :: (Int -> (a -> b)) -> (Int -> a) -> (Int -> b) 
02:56:34 <dminuoso> jusss: Yup. Its related in some manner, but its still different.
02:58:44 <jusss> dminuoso: cocoa f g x = f (g x) x
02:59:37 <jusss> cocoa :: (t1 -> t2 -> t3) -> (t2 -> t1) -> t2 -> t3
03:00:09 <dminuoso> jusss: Great.
03:00:42 <dminuoso> jusss: This Applicative/Monad instance is usually called Reader and it models threading an implicit parameter through your program.
03:01:11 <dminuoso> A common usecase might be some kind of Config parameter that every part of your program needs, and you get tired of manually passing it everywhere even though only a handful of spots actually use it.
03:01:45 <dminuoso> If you look at cocoa and mango you will see that all it does is applying a parameter everywhere.
03:02:55 <dminuoso> And its the same parameter, so its a kind of shared environment/config
03:03:39 <jusss> dminuoso: that (->) e can be monad?
03:04:20 <dminuoso> jusss: Yes. You just wrote the (>>=) implementation for it.
03:04:29 <dminuoso> (>>=) is your cocoa
03:04:38 <dminuoso> (<*>) is your mango
03:04:40 <jusss> dminuoso: what?
03:04:56 <dminuoso> and pure/return is your coconut
03:05:40 <dminuoso> And banana is fmap
03:05:40 <jgt> …
03:05:51 <jgt> {-# LANGUAGE FruitySynonyms #-} ???
03:06:12 <dminuoso> jgt: Its a private GHC branch
03:06:16 <jgt> ah
03:06:19 <dminuoso> Heh.
03:07:00 <jusss> dminuoso: the position is not right
03:07:11 <jusss> dminuoso: cocoa and >>=
03:07:12 <dminuoso> jusss: cocoa = flip (>>=)
03:07:22 <dminuoso> % :t flip (>>=)
03:07:22 <yahb> dminuoso: Monad m => (a -> m b) -> m a -> m b
03:07:26 <dminuoso> % :t (=<<)
03:07:26 <yahb> dminuoso: Monad m => (a -> m b) -> m a -> m b
03:07:36 <dminuoso> =<< is just >>= with the arguments flipped
03:08:41 <arianvp> % :t flip @((-> r)) (>>=)
03:08:41 <yahb> arianvp: ; <interactive>:1:12: error: parse error on input `r'
03:09:19 <jusss> dminuoso: about the a-> m b, I don't understand what it's used for
03:09:32 <jusss> it's not like functor and applicative
03:09:36 <jusss> this a->m b
03:09:40 <dminuoso> jusss: Yeah its not.
03:09:52 <jusss> dminuoso: and what it is
03:10:01 <dminuoso> jusss: Well what is (<>)
03:10:11 <dminuoso> jusss: Its not for anything.
03:10:12 <Bish> dminuoso: o/
03:10:19 <jusss> <>:: s->s->s?
03:10:21 <arianvp> % :t  (>>=) @((->) r)
03:10:21 <dminuoso> Right
03:10:21 <yahb> arianvp: ; <interactive>:1:14: error: Not in scope: type variable `r'
03:10:23 <arianvp> :/
03:10:34 <dminuoso> jusss: It exists because many things happen to have this shape, for some reason.
03:10:34 <Taneb> % :t (>>=) @((->) _)
03:10:34 <yahb> Taneb: (w -> a) -> (a -> w -> b) -> w -> b
03:10:42 <arianvp> Taneb: thanks
03:10:50 <arianvp> % :t (=<<) @((->) _)
03:10:50 <yahb> arianvp: (a -> w -> b) -> (w -> a) -> w -> b
03:10:51 <dminuoso> jusss: It doesnt have any intrinstic meaning.
03:11:07 <Bish> there is a flipped version of bind, but not a prefix bind?
03:11:17 <dminuoso> Bish: You can put (>>=) in parens
03:11:24 <dminuoso> And then use it in prefix notation.
03:11:31 <Bish> yeah great :D i am just sometimes confused about the logic
03:11:49 <Bish> people would flip it, but never use it prefix
03:12:05 <jusss> dminuoso: use <> to shape for what
03:12:24 <dminuoso> jusss: I wouldnt focus on Monad really, ask what the ((->) e) instance does
03:12:30 <Bish> bind [1] pure
03:12:34 <Bish> i don't think that looks so ugly
03:12:41 <dminuoso> jusss: Ask what the [] instance does. Ask what the IO instance does.
03:12:45 <dminuoso> Each is very simple to understand and use.
03:12:53 <dminuoso> Worry about that m word later.
03:13:34 <jusss> dminuoso: those instance throw something out?
03:13:55 <dminuoso> jusss: Lets go to the (<>) example
03:14:03 <dminuoso> jusss: Adding numbers is simple.
03:14:14 <dminuoso> Multiplying number too is a way to combine numbers.
03:14:24 <dminuoso> Selecting the better number is a more abstract notion of combinining them.
03:14:38 <dminuoso> Or perhaps concatenating their digits.
03:14:50 <Bish> "don't worry about the m thing" :> best advice
03:15:03 <dminuoso> each individual example is trivial and simple
03:15:11 <dminuoso> you dont need more.
03:17:02 <jusss> dminuoso: use that old stuff, when e-> is Monad, >>= transform a function to another complicate function?
03:17:45 <dminuoso> jusss: For (>>=) I would, personally, not think of it as a function transformer anymore.
03:17:50 <phadej> % :t (>>=) @((->) Int)
03:17:50 <yahb> phadej: (Int -> a) -> (a -> Int -> b) -> Int -> b
03:18:16 <dminuoso> jusss: Though you should look at (=<<) rather, if you want that perspective.
03:18:25 <phadej> % :t (=<<) @((->) Int)
03:18:25 <yahb> phadej: (a -> Int -> b) -> (Int -> a) -> Int -> b
03:18:42 * Bish as a noob he would explain >>= as the function that passes the inner value to a function that has to wrap it again
03:19:12 <jusss> dminuoso: what you thought >>= as?
03:19:21 <dminuoso> jusss: Me personally?
03:19:26 <phadej> I think about it as substitution operator
03:19:26 <jusss> dminuoso: yeah
03:19:38 <phadej> take all `a`s and replace them by `m b`
03:19:41 <phadej> inside the structure
03:19:54 <dminuoso> jusss: I like to think of it as a kind of syntactic sugar to make (>=>) pleasant.
03:20:04 <dminuoso> jusss: But I do not think this will help you much.
03:20:06 <Bish> phadej: well, thats what happens all the time in lambda-calc, bit to abstract don't u think?
03:20:21 <phadej> Bish: monad is quite abstract interface
03:20:28 <arianvp> % :t (<=<) @((->) Int)
03:20:28 <yahb> arianvp: (b -> Int -> c) -> (a -> Int -> b) -> a -> Int -> c
03:20:39 <Bish> yeah, but if you say "it substitutes things" you explain nothing which is specific to monads
03:21:03 <jusss> dminuoso: ok, I should just thought =<<
03:21:10 <phadej> Bish: ¯\_(ツ)_/¯
03:21:12 <jusss> as function
03:21:12 <dminuoso> Bish: Pretty sure phadej meant it as `fmap then join`
03:21:21 <dminuoso> Bish: So it boils down to "what does join actually mean"
03:21:40 <phadej> % :t join @((->) Int)
03:21:41 <yahb> phadej: (Int -> Int -> a) -> Int -> a
03:23:05 <dminuoso> Bish: Though Ive started to develop a really cool intuition that jle` and Solonarv helped me with, which is how Applicative and Monad are related.
03:23:46 <jusss> dminuoso: what's the related?
03:23:57 <dminuoso> jusss: Nothing that would help you for sure. :-)
03:24:11 <Bish> dminuoso: well, what did they do to make you get that?
03:24:32 <Bish> read 10 books about cat-theory?
03:24:34 <dminuoso> Bish: You know that "a monad is just a monoid..." joke?
03:24:39 <Bish> no
03:24:46 <dminuoso> Good. Dont google it.
03:24:55 * Bish googles it
03:25:27 <jusss> dminuoso: ok, is there anything else I could learn today? :)
03:26:27 <Bish> dminuoso: well, how is that a joke?
03:27:21 <dminuoso> Bish: Its not helpful at all to learn what it is, how to use it or anything about it.
03:27:37 <dminuoso> Its just utterly complicated and mathy.
03:27:52 <dminuoso> For people not already familiar with the subject anyway.
03:27:53 <Bish> well, i struggled hard, as you know, understanding monadic instances
03:28:09 <Bish> so i started reading about category theory, and i think it's interesting atleast and fascinating
03:28:41 <Bish> but it doesn't help at all to understand relation like applicative and monad
03:28:51 <tdammers> it is interesting and fascinating alright, but it won't help much with understanding the Monad typeclass in Haskell
03:28:54 <Bish> atleast as long as you didn't read allthebooks.png
03:29:04 <Bish> tdammers: not a bit, yes
03:29:08 <dminuoso> Bish: not entirely true.
03:29:10 <tdammers> @where eightfold
03:29:11 <lambdabot> http://dev.stephendiehl.com/hask/#eightfold-path-to-monad-satori
03:29:14 <dminuoso> it can help some for some.
03:29:23 <tdammers> ^ I recommend this
03:29:26 <dminuoso> but emphasis on "can" and both "some".
03:29:31 <Bish> well, it was timewaste in my case
03:29:56 <dminuoso> Bish: I do the CT stuff because its lovely.
03:30:10 <tdammers> it's not a waste of time; it does help understand some of the deeper theory behind it, but that's only going to be useful after you have a bit of a practical grasp on the Monad typeclass and its instances and usage
03:30:30 <Bish> dminuoso: hard to wrap my head around that, i love it too, but i am guess my intelligence is not enoughf or that :D
03:30:35 <dminuoso> So the CT perspective can help you refine your knowledge/perspective if you are already familiar with it.
03:30:57 <dminuoso> But its not a good means to actually learn it, just to study something you already know well deeper for personal interest.
03:30:59 <Bish> to understand monadic instances i just used intesive staring at replicateM
03:31:06 <jusss> dminuoso: thanks for your teaching, :) 
03:31:23 <Bish> because i loved what it does
03:31:30 <jgt> yeah I really didn't think the "monad is just a monoid…" joke was all that crazy
03:31:34 <tdammers> getting to the point where you can do useful stuff with do notation on lists, and actually grok how that works, is fun
03:31:42 <jgt> I mean, you just learn what the words mean
03:32:59 <jgt> "monad is a monoid" ok… so they are composable
03:33:22 <jgt> "…in the category of endofunctors" ok so the "thing" it represents won't change into a different thing
03:33:40 <arianvp> composable itself is a very ambigious word though :P
03:33:55 <arianvp> especially when you combine it with the slogan "Monads don't compose" :P
03:33:55 <dminuoso> And the composition is hard to spot unless you tell the joke not as a joke but correctly
03:34:03 <jgt> for the purposes of understanding what is meant, I think it makes it tangible enough
03:34:13 <dminuoso> A monad is a monoid in *a* category of endofunctors equipped with functor composition as its tensor.
03:34:28 <dminuoso> *in a monoidal category*
03:34:41 <dminuoso> suddenly you need to talk about monoidal categories, monoids, endofnuctors, tensors..
03:34:44 <dminuoso> categories
03:35:08 <jgt> do you though?
03:35:23 <jgt> it seems like the common problem with functor
03:35:41 <dminuoso> jgt: What if I told you that Applicative too is a monoid in a monoidal category of endofunctors?
03:35:43 <jgt> just about anybody can grasp that it's a mappy thing
03:35:53 <arianvp> https://www.youtube.com/watch?time_continue=3&v=SLAmSo0Gd4U
03:35:58 <jgt> which isn't really the whole story
03:36:09 <arianvp> oh wrong link I think
03:36:11 <jgt> but for the purposes of getting someone productive in Haskell, it doesn't matter
03:36:30 <dminuoso> jgt: So if both Applicative and Monad are monoids in the category of endofunctors, whats the difference?
03:36:53 <Solonarv> of course, but it seems the discussion was about the "a monad is just a monoid in the category of endofunctors, what's the problem?"
03:37:04 <jgt> the difference is not relevant to someone stumbling through their first "build a blog in Haskell" tutorial
03:37:08 <Solonarv> (I jumped in halfway through, so might be missing some context)
03:37:22 <dminuoso> Solonarv: I named you as one of the responsible people already. :-P
03:37:41 * Solonarv *scared*
03:37:47 <Solonarv> responsible for what?
03:38:00 <dminuoso> Solonarv: Oh remember that discussion with jle` the other day?
03:38:04 <tdammers> leave it to Haskellers to take a joke seriously and accidentally end up with a productive discussion
03:38:10 <dminuoso> About Day and (:.:)?
03:38:16 <arianvp> which I never seen happen before lol
03:38:26 <Solonarv> dminuoso: oh, I remember
03:38:37 <dminuoso> Solonarv: Ive been trying to build a foundation of intuition of that.
03:38:39 <dminuoso> *on that.
03:38:57 <arianvp> Only time I grasped the whole monad is monoid thing was in a lecture about string diagrams
03:39:34 <arianvp> and forgot again the day after, as always happens with me and category theory
03:39:54 <dminuoso> arianvp: for me cool thing is how it explains the laws in a do-notation perspective better
03:42:14 <Solonarv> after your head gets dunked into category theory deeply enough you start to see it everywhere :P
03:42:52 <Solonarv> and specifically monoids/categories crop up all over the place
03:42:56 <arianvp> http://www.stephendiehl.com/posts/monads.html 
03:43:18 <dminuoso> Solonarv: Its absolutely amazing how category seems to be the fundamental building block for everything.
03:43:32 <dminuoso> Solonarv: Do you read Bartosz's twitter?
03:43:41 <arianvp> wait until you discover higher category theory =)
03:43:57 <Solonarv> I don't, I rarely check twitter at all
03:44:23 <dminuoso> Solonarv: https://www.quora.com/Why-is-a-mathematical-function-allowed-to-have-multiple-outputs-for-single-input-but-not-multiple-inputs-for-same-output-Is-it-just-a-convention-or-it-has-a-logical-reason/answer/Bartosz-Milewski?share=0ce9415c
03:44:43 <dminuoso> I highly enjoyed this answer on: Why is a mathematical function allowed to have "multiple outputs for single input" but not "multiple inputs for same output"? Is it just a convention or it has a logical reason?
03:47:01 <Bish> > just about anybody can grasp that it's a mappy thing
03:47:03 <lambdabot>  error:
03:47:03 <lambdabot>      • Variable not in scope:
03:47:03 <lambdabot>          just :: t0 -> t1 -> t2 -> t3 -> t4 -> t5 -> Expr -> t6 -> t7 -> t
03:47:08 <Bish> fav sentence of the day :D
03:47:20 * jgt blushes on the inside
03:47:43 <t7> what?
03:48:02 <jgt> t7: what what?
04:02:44 <dTal> Hi Haskellers. I have a question that's not specifically about Haskell, but someone suggested maybe you might know the answer to.
04:02:58 <dTal> Is there a word for the operation that takes a function that combines two values, and returns a function that combines two functions that return those values?
04:03:33 <dTal> (or any number of values I suppose)
04:03:40 <dminuoso> dTal: Semigroup
04:04:30 <dminuoso> dTal: Its fully captured by: instance Semigroup b => Semigroup (a -> b)
04:04:45 <jgt> "semigroup" is a category, not an operation, no?
04:04:53 <Solonarv> well, if by "combine" you are talking about <> specifically
04:05:08 <dminuoso> I somehow assumed they were trying to name a thing that already existed.
04:05:30 <Solonarv> oh yes, that thing is called 'on' in Haskell's standard library
04:05:36 <Solonarv> er, wait, liftA2
04:05:46 <dTal> in Scheme it looks like (define (meta fun) (lambda instances (lambda (argtype) (apply fun (map (lambda (instanc
04:05:46 <dTal> e) (instance argtype)) instances)))))
04:05:47 <dminuoso> Solonarv: No pretty sure its the semigroup operation
04:05:50 <dTal> oops sorry
04:05:51 <Solonarv> % :t liftA2 @((->) _)
04:05:51 <yahb> Solonarv: (a -> b -> c) -> (w -> a) -> (w -> b) -> w -> c
04:06:12 <dminuoso> Or?
04:06:15 <dminuoso> Mmm
04:06:17 <dminuoso> Oh you are right Solonarv.
04:07:10 * jgt can't wait to be at that level of wizardry some day
04:07:21 <Solonarv> dTal: or liftA3, liftA4 etc for higher arity
04:07:34 <Solonarv> I don't remember how many of them are defined
04:07:56 <Solonarv> but also: liftAn f x1 ... xn = f <$> x1 <*> ... <*> xn
04:07:56 <dTal> well the thing I just pasted should work for arbitrary arity
04:08:31 <Solonarv> we don't have arbitrary-arity functions in Haskell - at least, not conveniently - so that doesn't translate straightforwardly
04:09:25 <Solonarv> but as I showed you can build "arbitrary-arity liftA*" using repeated applications of <*>
04:09:39 <dTal> That does like it
04:09:45 <dTal> wow, thanks a lot guys
04:10:13 <dTal> it's such a pleasure to "discover" something like that
04:10:16 <Solonarv> > liftA2 (++) tail reverse "hello"
04:10:18 <lambdabot>  "elloolleh"
04:10:48 <Solonarv> or:
04:10:48 <Solonarv> > ((++) <$> tail <*> reverse) "hello"
04:10:50 <lambdabot>  "elloolleh"
04:12:20 <dTal> so this? (map ((liftA2 +) (lambda (x) (+ 1 x)) (lambda (x) (+ x 1))) (iota 10)) => (2 4 6 8 10 12 14 16 18 20)
04:12:49 <dTal> sorry for persistently pasting Scheme, but I figured you probably know more Scheme than I know Haskell
04:15:34 <Solonarv> well, liftA2/3/... is a name for that function in Haskell
04:15:36 <dTal> actually, hold that thought, I'm actually expecting (2 3 4 ...) - the heck
04:15:42 <Solonarv> and it's actually more general than lifting functons
04:16:04 <Solonarv> > map (liftA2 (+) (+1) (1+)) [1..10]
04:16:06 <lambdabot>  [4,6,8,10,12,14,16,18,20,22]
04:16:33 <Solonarv> oh, iota isn't quite what I thought it was - close enough though
04:16:59 <dTal> oh no that is correct, of course you're adding x to itself - just a math brain fart
04:17:02 <Solonarv> I'm not aware of a specific name for this kind of combinator, tbh
04:18:00 <dTal> I guess I'll just call it 'lift' in my program then
04:18:29 <Solonarv> I'd pick something like 'liftFunc'
04:20:03 <dTal> How come? Is 'lift' overloaded?
04:21:19 <Solonarv> it seems like too generic a name
04:21:50 <dTal> to my eyes it warrants it, as it's an extremely generic function
04:22:04 <Solonarv> it applies to other kinds of "function transformer" too:
04:22:04 <Solonarv> > liftA2 (++) ["hi", "bye"] ["dog", "cat"]
04:22:06 <lambdabot>  ["hidog","hicat","byedog","byecat"]
04:22:31 <Solonarv> the liftA2/3/... functions we have in Haskell are even more general, as you can see
04:23:30 <Solonarv> > liftA2 (\x y -> drop (read x) y) getLine getLine
04:23:32 <lambdabot>  <IO [Char]>
04:24:11 <Solonarv> so your combinator is "liftA* for functions"
04:24:22 <dTal> I see
04:24:32 <dTal> I'm afraid I'm not sufficiently enlightened to understand all your examples
04:24:38 <dTal> but point taken
04:25:27 <Solonarv> the examples are meant to show that liftA2 also works for things other than functions: here, lists (written [like, this] in Haskell) and IO actions
04:27:09 <ezyang> roconnor: Do you have a description of your Backpack problem somewhere? 
04:29:20 <dTal> That  liftA2 (++) ["hi", "bye"] ["dog", "cat"] is kind of mind blowing
04:29:44 <dTal> it somehow turns list concatenation into a kind of cross product?
04:30:02 <dminuoso> dTal: we tend to think of lists as modelling non-determinism.
04:31:58 <dTal> I don't even know how to begin interpreting that :p
04:33:01 <Logio> I'd rather think of it as lists having a natural way of combining them by finding all their combinations
04:33:06 <dTal> I feel like I just tripped into the future
04:34:09 <Logio> and the liftA2 just maps (++) to a function that gets applied to these natural combinations 
04:34:38 <dTal> so the combination part is done by juxtaposing the lists, not by liftA2?
04:34:52 <Logio> "modelling non-determinism" just happens to correspond to the combinations
04:35:27 <Logio> dTal: no, it results from the definition of liftA2
04:36:04 <Logio> or rather, the definitions of <$> and <*>
04:37:00 <dminuoso> dTal: So if you think of non-determinism as a kind of "not sure which", then a list of elements is a choice that has not been made yet.
04:37:21 <dminuoso> dTal: So if you have a list of functions, then the choice of the function has not been made yet.
04:38:03 <dminuoso> So to apply such a function to such a value, amounts to giving all combinations as kind of "trying out all possibilities"
04:38:36 <dTal> I think I understand
04:38:49 <dminuoso> and monad brings this to a natural conclusion where you take a choice and make it disappear, or generate new choices based on some choice
04:38:49 <Logio> it's really non-determinism if you don't use all the possibilities, though
04:39:45 <Logio> you can equally well just use it to just compute all the combinations, without thinking it in terms of determinism
04:40:54 <dminuoso> dTal: For what its worth, there's another equally good Applicative instance for [] that works differently, which is captured by ZipList.
04:41:34 <dminuoso> The non-determinism one just happened to be the default for [] for some reason (perhaps because it was deemed more desirable)
04:42:56 <Logio> the default instance probably has better algebraic properties
04:44:02 <Logio> just because it's essentially the kroenecker product of the lists, while the ZipList one is something a bit more contrived (in terms of choices you make)
04:46:42 <Logio> and less choices generally makes for a more general abstraction
04:46:45 <dminuoso> Logio: I guess one major usage of [] is inside a StateT.
04:47:02 <dminuoso> Like some parser constructions.
04:47:13 <dminuoso> The ZipList I dont see too often.
04:47:50 <Logio> I've mostly actually used it in cases where I just need to actually compute all combinations of things
04:48:18 <dminuoso> Logio: I mean if that was really the case, a list comprehension would usually be fine too unless you insisted on using monad combinators.
04:49:12 <Logio> oh, I guess I've actually really needed the Monad instance in most cases 
04:49:35 <dminuoso> What parts of it would you use?
04:50:15 <Logio> I mean, I've needed computation to branch based on the values
04:56:35 <Logio> oh, the comment here makes a good point: https://stackoverflow.com/questions/37627513/why-ziplist-is-not-the-default-applicative-instance-for-list
04:58:22 <Logio> namely that the ziplist instance is not compatible with the Monad instance for lists
04:58:42 <merijn> Logio: Yeah
04:59:50 <Logio> which is pretty much the "better algebraic property" I was thinking of
05:01:13 <dminuoso> Logio: Well the monad compatibility is not really a reason, since you could have an instance Applicative [], instance Applicative NonDet, instance Monad NonDet
05:01:45 <merijn> dminuoso: Yes, but then [] is not a Monad and you need to continually wrap it...
05:02:03 <dminuoso> merijn: OverloadedList :-p
05:07:26 <tty1> man "learn you a haskell" really gets bad once it starts gettinginto applicatives and monoids :(
05:07:28 <tty1> err monads not monoids, the monoid section wasnt bad
05:07:49 <dminuoso> tty1: You could switch the book.
05:08:25 <tty1> dminuoso: yup thats what im considering doing
05:09:04 <tsahyt> is haskellbook.com still the recommended book for learning haskell?
05:09:06 <dminuoso> tty1: CIS194 by Joachim Breitner is pretty solid.
05:09:23 <dminuoso> tsahyt: There is no "the recommended" book. There are many resources, all tailored for different audiences.
05:09:49 <tsahyt> that's better then
05:09:51 <tty1> dminuoso: i tend to be rather unique in the ways in which i learn best, so while that may be a great book I'll have to try it out to see if it works for me. I'll grab a copy and give it a go, thanks for the suggestion
05:09:53 <dminuoso> The Haskell Book is very basic, it's approachable for people with no programming history.
05:10:03 <dminuoso> But if you want something more dense and accurate, it might not be to your taste.
05:10:15 <tsahyt> dminuoso: it's also roughly a thousand pages, and I've seen it scare people away partly because of that
05:10:18 <dminuoso> tty1: Its a uni course that was made public for free.
05:10:22 <tty1> dminuoso: I have over 2 decades of programming expiernce and have pretty good math expiernce too. This is, however, my first functional language
05:10:30 <tsahyt> 1200 actually
05:10:49 <tty1> dminuoso: dense, accurate, and technical is usually what works best for me. Particularly when its heavy in examples
05:10:54 <merijn> tty1: tbh, depending on how brutal you want it, you could also dive into the Report directly and cut out the middle men :)
05:11:02 <dminuoso> tty1: You might be interested in having the haskell 2010 report ready then.
05:11:03 <merijn> tty1: That doesn't really have examples, though
05:11:21 <tty1> yea without examples im probably going to be lost
05:11:23 <dminuoso> tty1: Also the gentle introduction *could* be helpful for you (its anything but gentle, but based on what you just said it could be helpful)
05:11:37 <dminuoso> tty1: and yeah, I think CIS194 could be a good fit together with the Haskell report.
05:11:45 <dminuoso> For you anyway.
05:11:51 <tty1> in fact almost all the haskell i learned to date was from looking at examples and only skimming the text a lot of the time.
05:12:07 <tty1> ill check them all out, thanks
05:12:08 <merijn> There's also "Haskell for Readers"
05:12:26 <tty1> Is there a "Haskell for people who have no fucks left to give" ... lol :)
05:12:44 <dminuoso> tty1: What is that characterization about?
05:13:00 <tty1> dminuoso: just laughing at the fact that it describes my personality in general :)
05:13:15 <merijn> tty1: Haskell for Readers was written for "senior engineers/cryptographs/etc. with many years CS experience that need to read/understand Haskell, but are too busy for long texts"
05:13:21 <tty1> dminuoso: nothing to do with haskell, so far I'm actually enjoying it a good deal
05:13:35 <tty1> merijn: sounds perfect
05:13:44 <merijn> tty1: It might help as supplement combined with the Report and just going through source code if that works for you
05:14:03 <merijn> tty1: Only downside is that it doesn't really cover "how do I write sensible code" just "how do I read existing sensible code" :)
05:14:06 <tty1> ill try all these suggestions and int he end ill go with what works of course
05:14:10 <merijn> tty1: http://haskell-for-readers.nomeata.de/
05:14:46 <tty1> merijn: well good code wilkl come later. For now i just need to understand what things do, all the syntax and important ideas. I tend to have a good instinct for good code once I understand the mechanics
05:14:54 <tty1> merijn: thank you!
05:46:04 <merijn> <3 refactoring Haskell
05:46:39 <aplainzetakind> So I'm looking into using brick for a typing tutor thing I'm working on. Though not a present concern, down the line I'll most likely want to work with scancodes directly and apply whatever keyboard layout the user wants to practice in the program. From what I gather, vty doesn't provide that functionality. Is anyone familiar enough with brick to ascertain if it would be possible to write custom 
05:46:45 <aplainzetakind> events using e.g. SDL without too much hassle to get scancodes from key presses and hook them into brick?
05:47:00 <merijn> aplainzetakind: Fundamentally impossible
05:47:17 <aplainzetakind> Because terminal?
05:47:18 <merijn> aplainzetakind: brick works via a tty, scancodes don't exist in the tty world
05:47:21 <merijn> aplainzetakind: Correct
05:48:05 <merijn> aplainzetakind: Applications running in the terminal basically get a stream of bytes, so at that point you can't really decode the bytes back to keyboard scancodes
05:48:33 <aplainzetakind> Can I query the system for the layout and reverse through that?
05:49:00 <merijn> aplainzetakind: The problem with that idea is: You don't even know if the input of the terminal is coming from the local machine :)
05:49:26 <merijn> aplainzetakind: It might be someone connecting over SSH with a different keyboard than the one attached to the local machine
05:49:49 <aplainzetakind> Right.
05:50:14 <merijn> aplainzetakind: If anything you wanna setup something to just auto-detect common layouts and allow uses to override/specify their own layout
05:50:41 <merijn> By, e.g. making them press all keys in all rows from top left to bottom right and then reading through the results
05:51:16 <merijn> Alternatively, decouple the logic from the UI so you can reuse the same backend/tutor code and add an SDL backend later? :)
05:51:59 <aplainzetakind> ^ That would be great
05:52:19 <aplainzetakind> But I'm having a hard time decoupling such an interface-specific logic.
05:52:27 <Guest13155> greetings to all :)
05:53:01 <merijn> aplainzetakind: maybe have a Chan or something for incoming key events and another chan for outputing command/instructions, then you can attach brick to those channels and future other interfaces can do the same
05:54:55 <aplainzetakind> Hm.
05:56:02 <petrus> I installed xmonad and xmonad-contrib using cabal new-install, but when I attempt to --recompile xmonad config it cannot find XMonad etc modules. Is there a way to point xmonad to cabal's store?
05:57:22 <aplainzetakind> That sounds like the obvious right thing to do. But this being my first foray into writing anything interactive, I have difficulty figuring out how exactly that can be done.
05:57:31 <merijn> aplainzetakind: Basically, you wanna define your logic with abstract input events and abstract output events, the goal of different frontends is then to take actual UI and convert inputs into your own event set and converting the output commands into UI updates
05:57:49 <merijn> aplainzetakind: I haven't really worked with brick before, so not sure how to easily do that
05:58:05 <aplainzetakind> Is Chan something specific that I can use, since you capitalized it?
05:58:24 <merijn> aplainzetakind: Yes, Control.Concurrent.Chan
05:58:36 <aplainzetakind> Alright, I'll look into it.
05:58:40 <aplainzetakind> Thanks.
05:58:43 <merijn> aplainzetakind: It allows code in different forkIO threads to communicate
05:59:41 <merijn> aplainzetakind: So you'd write a library with a function "forkTutorLogic :: Chan Input -> Chan Output -> IO ()" (or something like that) and then you write code with your UI that writes to/reads from those Chans
06:00:47 <merijn> aplainzetakind: That way your logic can ignore the existence of the UI (since it runs in its own thread) and your UI can just ignore the logic and only think about input and output and what to do with those
06:03:34 <aplainzetakind> Is this as easy to use as it seems from the documentation? Looks really neat.
06:03:42 <merijn> aplainzetakind: Pretty much, yes
06:03:48 <aplainzetakind> Great. Thank you.
06:04:08 <merijn> aplainzetakind: There's a reason people say that threading/concurrency is super easy in Haskell ;)
06:04:36 <merijn> aplainzetakind: If you read from an empty channel the thread will just block until something gets written
06:24:17 <freeside> so, apropos of nothing, i just want to say that i'm finally making headway with understanding monads and monad transformers, not because i've finally stumbled across the Right Monad Tutorial, but because i'm actually working on a project which naturally motivates those patterns and so now when i go looking for a Reader or RWST solution it's because i have an actual problem to solve.
06:24:53 <freeside> that's all, i have no question, i just want to say thank you to everyone who has helped me in the past and who may help again in the future
06:25:09 <freeside> now back to fighting with intero
06:40:58 <aplainzetakind> merijn: The implication of what you just said is that the input and output Chans should run on separate threads, right?
06:42:36 <aplainzetakind> I've never used forkIO, but it is :: IO () -> IO ThreadId, so I can't just forkIO newChan. How should I use it?
06:42:41 <merijn> aplainzetakind: Chans don't run in a thread, they are just values, but you want 1 thread that reads inputs, handles the logic and then produces outputs
06:43:03 <merijn> aplainzetakind: "forkIO foo" just means "run IO action foo in a new thread"
06:44:29 <merijn> aplainzetakind: So if you have "runTypeTutor :: Chan Input -> Chan Output -> IO ()" (which reads inputs events and writes output events) then you'd just write "do { inputChan <- newChan; outputChan <- newChan; forkIO (runTypeTutor inputChan outputChan); ...UI code that writes to/reads from Chan ... }"
06:45:12 <aplainzetakind> Hm. Alright.
06:45:32 <aplainzetakind> OK I get it.
06:46:28 <merijn> aplainzetakind: runTypeTutor inChan outChan = forever $ do { event <- readChan inChan; ..some logic that handles the event; writeChan outChan someOutput }"
06:46:31 <merijn> Something along those lines
06:48:08 <aplainzetakind> Forking only one of the UI/backend is sufficient right?
06:48:48 <merijn> aplainzetakind: With the explanation I gave, yes. But you can make things as complex as you want :p
06:49:18 <aplainzetakind> Cool :)
07:07:21 <zincy> What is shallow versus deep embedding in the context of DSLs?
07:07:40 <zincy> As in what is being embedded?
07:07:55 <merijn> zincy: The DSL
07:08:00 <merijn> zincy: In the host language
07:08:14 <zincy> Ok
07:08:29 <merijn> ugh...so how do I correctly write a show instance that matches GHC's derived ones?
07:08:31 <zincy> DSLs can only be interpreter right?
07:09:11 <merijn> Not necessarily
07:12:16 <Uniaika> hmm, that's a nice question you've got there
07:12:24 <Uniaika> Bash as a DSL is indeed interpreted
07:13:11 <Uniaika> if you have a DSL in a language that is compiled, I would say it is first kind of interpreted by the host language, translated into said language, then compiled
07:13:36 <Uniaika> (bash as a DSL is interpreted like Perl is, they are not compiled to a binary)
07:14:15 <Uniaika> I say "kind of interpreted" because it is not like Python which is said to be interpreted, and produces bytecode for the interpeter to execute
07:14:29 <Uniaika> yeah, that's a good question, thanks zincy 
07:15:20 <Solonarv> to your initial question: very roughly, I'd say shallow embedding is when you implement a DSL feature by just using the corresponding host-language feature, whereas in a deep embedding you actually implement it "from scratch"
07:20:50 <aplainzetakind> Why do imports have to be cycle-free?
07:21:12 <c_wraith> according to the spec, they don't
07:21:23 <c_wraith> this is a case where GHC falls short
07:21:26 <merijn> aplainzetakind: Because implementing the spec correctly is hard for technical reasons in GHC
07:22:05 <lyxia> merijn: have you seen show-combinators
07:22:54 <merijn> lyxia: No?
07:24:31 <Uniaika> Solonarv: like when Dhall implements some datastructures in haskell but does not uses GHC's / containers' own implementations?
07:25:34 <Solonarv> I don't feel like that counts as a shallow embedding but my definition is not sharp enogh to articulate why
07:25:38 <zincy> Solonarv: Sort of like the gist you wrote where the arithmetic operations are defined by using Haskell functions rather than the custom lang primitives?
07:26:26 <Uniaika> Solonarv: no, sorry, I was meaning to ask if it was an example of deep embedding
07:28:50 <Solonarv> Uniaika: yeah, I think so
07:29:39 <Solonarv> zincy: no, after all there's no other way I could implement the arithmetic operations given the representation I chose
07:30:17 <Solonarv> the fact that I use a Haskell function value to represent a function value in the lambda calculus is an example of shallow embedding
07:36:48 <dmwit> merijn: lyxia has a cute package based on Generic that can do that; or you can derive Show and -ddump-deriv to get some starter code that you can dump into your file and tweak.
07:37:13 <merijn> dmwit: I can't, because it's an existential type :0
07:37:19 <merijn> dmwit: Else I would just derive it :)
07:37:37 <merijn> But this show-combinators thing looks promising
07:38:59 <dmwit> % data Foo = forall x. Show x => Foo x
07:38:59 <yahb> dmwit: 
07:39:03 <dmwit> % deriving instance Show Foo
07:39:03 <yahb> dmwit: 
07:39:07 <dmwit> % Foo "hi"
07:39:08 <yahb> dmwit: Foo "hi"
07:39:10 <dmwit> merijn: ?
07:39:26 <dmwit> Existential quantification doesn't appear to prevent deriving.
07:40:48 <merijn> hmm, looks like standalonederiving works if I add an additional show constraint, yeah
07:41:14 <tty1> can someone show me a very simple but complete definition of some arbitrary/simple monoid. Something i can copy, paste, it will run and i can play with it. I am trying to do it myself and keep running into errors so I'd like some working example to pull from.
07:41:42 <merijn> tty1: Are the errors you're getting perchance complaining about Semigroup?
07:41:48 <dmwit> % data X = X; instance Semigroup X where X <> X = X; instance Monoid X where mempty = X
07:41:48 <yahb> dmwit: ; <interactive>:19:52: error: parse error on input `instance'
07:41:54 <merijn> tty1: And are you using GHC 8.something?
07:42:04 <dmwit> % data X = X; instance Semigroup X where {X <> X = X}; instance Monoid X where {mempty = X}
07:42:04 <yahb> dmwit: 
07:42:09 <dmwit> tty1: There you go.
07:42:49 <tty1> I am not sure what im using, im working inside a jyupter worksheet right nwo witht he IHaskell kernel (i do have a working haskell project skeleton i could use, that has LTS as the resolver)
07:43:10 <tty1> merijn: no not semigroup, i had that trouble when i tried to define a functor i think it was and i did manage to solve that
07:43:13 <ski> zincy : a shallow embedding represents values by "their semantics". e.g. representing a parser of `String's, generating a semantic result (typically a parse tree) of type `a', by values of type `String -> [(a,String)]'
07:43:46 <tty1> merijn: the errors appear to revolve around superclasses.. let me get the error right now (but i keep bastardizing the code to try to hack it to work so the error may not be relevant anymore
07:43:59 <merijn> tty1: Yeah, that's the issue I was getting too ;)
07:44:31 <merijn> tty1: In recent GHC version Semigroup was made a superclass of Monoid, so to implement Monoid you need to implement Semigroup too (see dmwit's example)
07:44:35 <tty1> Could not deduce (Applicative (WeirdType w)) arising from the superclasses of an instance declaration
07:44:36 <tty1>       from the context: Monoid w bound by the instance declaration
07:44:40 <tty1> oops
07:44:44 <tty1> didnt mean for that to be multiline
07:44:47 <tty1> but thats the error
07:44:50 <ski> zincy : while a deep embedding would represent parsers by how they're constructed, so perhaps `data Parser :: * -> * where Return :: a -> Parser a; Bind :: Parser a -> (a -> Parser b) -> Parser b; Eat :: Parser Char; Choice :: [Parser a]; ...'
07:45:00 <merijn> tty1: Wait...that looks unrelated to Monoid entirely :)
07:45:17 <merijn> tty1: Can you pastebin the code + error somewhere?
07:45:21 <tty1> the format of defining instances is confusing me as well.. 
07:45:35 <dmwit> % System.Info.compilerVersion -- tty1, you can use this to find out what version jupyter is using as its backend
07:45:35 <yahb> dmwit: Version {versionBranch = [8,6], versionTags = []}
07:45:49 <tty1> merijn: i can but my code is getting sorta hackish and not what i originally tried
07:46:30 <ski> Solonarv : "shallow embedding is when you implement a DSL feature by just using the corresponding host-language feature, whereas in a deep embedding you actually implement it \"from scratch\"" -- hm, isn't that more like the distinction between a meta-circular interpreter, and a non-meta-circular one ?
07:46:45 <Solonarv> well, just share some non-working code along with the error it's producing
07:47:08 <Solonarv> ski: yes, perhaps - I like your definition better anyway
07:47:10 <dmwit> Bonus points for minimizing it first.
07:47:33 <tty1> merijn: this is what my current iteration looks like. I started by just defining monoid but got that error and tried defining the super classes in an attempt to fix it (based on advice from here yesterday).. so i may have made the code worse not better: https://hastebin.com/cubezejogu.coffeescript
07:48:23 <phadej> I understand meta-circular more as `self-interpreter`
07:48:42 <Solonarv> tty1: ah, I think the problem there is simply order of definitions
07:48:44 <phadej> A self-interpreter is a meta-circular interpreter where the interpreted language is nearly identical to the host language; the two terms are often used synonymously.
07:49:05 <tty1> Solonarv: i did try reordering them too, with no avail (I think the error changed though)
07:49:39 <Solonarv> if this is all in a single Haskell source file it should work, but if you enter these instances one by one into GHCi (or an IHaskell notebook?) it won't work because the Applicative instance doesn't exist at the time you're defining the Monad instance
07:50:20 <Solonarv> try defining them in this order: Functor, Applicative, Monad
07:50:24 <tty1> Solonarv: they are all in the same file
07:50:32 <dmwit> If you want to enter them one-at-a-time, you could turn on UndecidableInstances and write `instance (Applicative (WeirdType w), Monoid w) => Monad (WeirdType w) where ...`.
07:50:33 <tty1> ok let me see what that does, i think the error changes
07:50:50 <Solonarv> ah, but is it a regular Haskell source file or a jupyter notebook?
07:50:52 <merijn> tty1: Yeah, but the question is "Do IHaskell notebooks behave like regular Haskell source files" :)
07:50:56 <dmwit> Or put them in the order Functor, then Applicative, then Monad, and change `pure x = return x` to `pure x = WeirdType (x, mempty)`.
07:51:21 <dmwit> (This is the solution I would pick. You can change `return x = ...` to `return x = pure x` if you want to adhere to DRY.)
07:51:48 <dmwit> Of course you also have a type error on line 9 of that paste. =)
07:51:49 <Solonarv> (you can even leave out 'return x = pure x' entirely - that's the default definition of 'return' anyway)
07:51:51 <dmwit> But that's a separate thing.
07:52:01 <tty1> merijn: that i dont know but it worked when i had a similar problem earlier and needed to define several instances for a Functor to work (had to define semigroup too)... so i suspect that is not the issue
07:52:09 <merijn> tty1: Because, tbh, that code doesn't look like it should give the error you're getting :)
07:52:22 <merijn> tty1: (i.e. it looks correct at first glance)
07:52:56 <srid> Possibly odd question: is it worth reading the Haskell 2010 Language Report?
07:53:03 <merijn> srid: Yes
07:53:14 <merijn> srid: If you are the sort of person that likes reading specs, anyway
07:53:18 <dmwit> I read the H98 Report and learned many things about Haskell, even after having used it seriously for several years.
07:53:28 <tty1> So when i reorder the instances as suggested this is the new error I get (with the new code): https://hastebin.com/agoxamucet.xml
07:53:30 <merijn> srid: It's one of the most readable specs around and you'll almost certainly learn a handful of new things
07:53:36 <srid> Interesting.
07:53:55 <dmwit> merijn: Yep, like I said, your `(<*>)` is type-incorrect.
07:54:01 <tty1> merijn: im willing to test it in my skeleton project just to be sure.. check out the new error first and see if it gives any new clues before i do that if you dont mind
07:54:12 <dmwit> tty1: Oops, I meant you, not merijn, for my last message.
07:54:35 <merijn> srid: For example, did you know you can escape arbitrary whitespace inside strings?
07:54:54 <merijn> > "Hello \                \ World!" -- Imagine some linebreaks/tabs between those slashes...
07:54:56 <lambdabot>  "Hello  World!"
07:54:59 <dmwit> tty1: We can help you understand the error and fix your code if you want. But pedagogically it might also be worth taking a stab at reading it carefully and trying yourself. What do you prefer?
07:55:03 <tty1> dmwit: type incorrect in that it will give an error or just that it breaks expectations... i bastardized a lot of this just to get it to compile as i dont actually intend to use the type yet, just trying to figfure out why it wouldnt compile
07:55:27 <dmwit> What an odd question. "Does it give an error? I'm getting an error." Uh... question answered, then?
07:55:29 <srid> merijn: What's actually going on there?
07:55:48 <srid> > "Hello                  World!"
07:55:50 <lambdabot>  "Hello                  World!"
07:56:03 <merijn> srid: Well, the report just says you're allowed to escape whitespace like that to simplify, for example, linewrapping long strings
07:56:09 <tty1> dmwit: well I think I understand the code, and why <*> isnt going to follow the Applicative laws.. just not why it doesnt compile (i was looking at the error last night).. keep in mind im VERY noob, so im still trying to make sense of things by example to some extent
07:56:14 <ski> zincy,Solonarv : anyway, i think another way to think about the shallow vs. deep embedding is that the "deep" one focuses on construction, leading to variant/sum types (in Haskell, Algebraic Data Types). while the "shallow" one focuses on "de(con)struction", or observation/properties/selection/projection, so could lead to having a record type, each field/method giving a different "rendering view" of the data
07:56:16 <dmwit> srid: String gaps were designed to give you a way to wrap strings across multiple lines without necessarily including newlines in the string literal itself as a result.
07:56:26 <srid> merijn: Oh I see, I think now understand why people put \ in multi line strings
07:56:31 <srid> *now I
07:56:32 <merijn> srid: That's just one of the wonderous details I learned from reading the report :) (and you can too!)
07:56:37 <dmwit> srid: So you can e.g. end a line with \, then put a \ at the beginning of the string literal on the next line, and everything in between will be ignored.
07:56:51 <merijn> srid: There's a bunch of minor things like that in the report that no one ever covers in books/tutorials
07:57:24 <tty1> what would help me most is just a simple example of a monoid i can plug in and it will work so at least i see a working example as a starting poiint.. this example started as one from a book i was using to learn haskell. So im really not equiped yet to debug it yet as im not done reading
07:57:35 <dmwit> tty1: You haven't answered my question yet, so I don't feel confident taking action. Do you prefer to try to read and understand the error yourself first, or do you want us to begin explanations?
07:57:36 <ski> phadej : not in all cases of an "interpreter where the interpreted language is nearly identical to the host language" are we talking about a meta-circular one, though. it has to "implement object language features in terms of corresponding meta language features" in order for it to count as meta-circular ..
07:57:42 <merijn> srid: Anyway, the conclusion is that, if you're the kind of person that would conside reading language specs, the Report is certainly worth looking at :)
07:57:50 <dmwit> tty1: An example monoid will not help. This code doesn't compile with any monoid.
07:58:26 <dmwit> tty1: (Essentially I'm asking if you want spoilers.)
07:58:34 <tty1> dmwit: id like an explanation. I tried to read the error already and cant grok it
07:58:39 <dmwit> Okay, cool.
07:58:47 <tty1> dmwit: i dont usually want spoilers, but in this case it would be appreciated yes
07:58:59 <dmwit> So, first things first: `WeirdType :: (a, w) -> WeirdType w a`, yes?
07:59:32 <tty1> one would thing, but the example fromt he book just used "WeirdType w" in places, which i found odd and thought could be incorrect but didnt know for sure...
07:59:46 <dmwit> That is, `WeirdType` is a function which takes a single argument, a tuple, and returns something which is definitely not a function.
08:00:23 <dmwit> (`WeirdType w` is not necessarily incorrect. Sometimes the context expects a type that does not yet have all its parameters supplied.)
08:00:40 <tty1> dmwit: my understanding is WeirdType is a new sort of type that simple wraps a 2-tuple, thus as you said takes a 2-tuple as an argument and returns a WeirdType which wraps it
08:00:40 <dmwit> tty1: Do you follow with the non-parenthesized stuff so far?
08:00:48 <dmwit> Good.
08:01:00 <dmwit> Okay, now look at the right-hand side of the equation on line 6 of your paste.
08:01:13 <dmwit>     WeirdType (a) (b `mappend` y)
08:01:26 <dmwit> This is the syntax you use to apply a function to two arguments.
08:01:33 <dmwit> That will never do -- WeirdType takes only one argument!
08:01:34 <tty1> dmwit: wait actually no i dont understand the non parenthesied part on the first line, now that you mention it
08:02:02 <dmwit> Ah, you don't understand this part? "`WeirdType` is a function which takes a single argument, a tuple, and returns something which is definitely not a function."
08:02:05 <tty1> why is the first w a in reverse order, and not in tuple form... is it just saying "they can be any type, w and a"
08:02:42 <tty1> dmwit: well i do understand that statement to be true.. it returns a WeirdType, which is a sort of data type, not a function, so i do understand that statement
08:02:50 <dmwit> Oh. The arguments to the tuple constructor and to WeirdType are in opposite orders because they're declared that way when we defined `WeirdType`.
08:03:11 <tty1> what i dont think i understand is why the first line has "WeirdType w a" and not "WeirdType (a,w)" or something
08:03:14 <dmwit>     newtype WeirdType w a {- w first, then a -} = WeirdType { runWeirdType :: (a, w) {- a first, then w -} }
08:03:49 <tty1> dmwit: to be honest with "instance" the first line always seemed strange to me and up till now ive just been paroting it without understanding it
08:04:08 <dmwit> So I suppose there are two possible questions you could be asking here: 1. Given the definition of the newtype we wrote, why does `WeirdType` have the type it does? 2. Why did we write the newtype definition the way we did?
08:04:15 <monochrom> Maybe it's time to talk about kinds?
08:04:56 <monochrom> And also how "WeirdType w a" means "(WeirdType w) a".
08:05:01 <tty1> I think that would help.. ive seen ":k" but i dont know the vocab or wthe difference between kind or type yet.. I just sorta know i use :t on instances of things and :k on definitions of things
08:05:04 <ski> phadej : there's also the thing that what (e.g.) CPS transformation doing is sortof "opposite" of meta-circular. there are different variants of CPS transformation. if you cbv-CPS (cbn-CPS) transform, then interpret the result, it behaves as if you cbv-interpreted (cbn-interpreted) the original, regardles of whether you're using a cbv or a cbn interpreter for the transformed result
08:05:18 <dmwit> monochrom: Go for it!
08:05:24 <monochrom> No I have to go.
08:05:29 <tty1> I really appreciate all the help by the way
08:06:03 <tty1> I was hoping if i saw enough examples the pattern would click
08:06:18 <tty1> but it makes having these conversations or getting help very hard, short of asking for examples
08:07:12 <jgt> difference between kind and type: types have a kind
08:07:14 <phadej> ski: my point is that "meta-circular" or not and "deep" vs "shallow" embedding are somewhat different; I haven't heard meta-circular used in Haskell land that much
08:07:27 <jgt> a type's kind is how many things you have to give the thing until it's a total proper thing
08:08:10 <jgt> > :k Int
08:08:12 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
08:08:15 <jgt> darn
08:08:17 <tty1> Data Foo...  Foo is a kind... right?
08:08:21 <ski> phadej : right, i agree fully. however, someone else explained "deep" vs. "shallow" more in terms of what i thought sounded like "meta-circular" vs. not
08:08:45 <jgt> tty1: uhhh… I'm not sure I'd say it that way
08:08:53 <ski> phadej : i think SICP uses the term "meta-circular" ?
08:08:59 <tty1> hmmm
08:09:06 <jgt> tty1: think of it like this. How many things do you need to give an Int for it to be an Int?
08:09:20 <jgt> 1 :: Int
08:09:25 <jgt> it's just one thing
08:09:25 <ski> `Foo' is not a kind in `data Foo ...'
08:09:33 <jgt> so its kind is just one star
08:09:40 <jgt> Int :: *
08:09:41 <tty1> jgt: im not sure I understand.. I dont usually give things to an int do I? Wherever I write a number it is an Int
08:09:45 <tty1> hmmm
08:09:48 <aplainzetakind> merijn: My backend reports the results of what happened, so it's sort of IO Report (actually that's inside an ExceptT but that's not important), So I couldn't really fork that one, but I forked the input and output UI procedures. It ran, but after I pressed the first key I got a thread blocked indefinitely in an MVar operation.
08:09:49 <jgt> yes, exactly
08:09:55 <phadej> ski: yes, but I don't recall whether they call an evaluator for logic language also a meta-circular
08:09:56 <jgt> however, what about a Maybe?
08:09:58 <phadej> ski: something to check
08:10:21 <tty1> when I see "1 :: Int" how i read it, and maybe this is wrong is "1, which i am explicitly telling you is an Int" in other words, its a bit like an explicit cast in other languages.. is this not the case?
08:10:22 <jgt> the type is like (Maybe a)
08:10:36 <ski> phadej : hm, i suppose. my immediate reaction would be to apply that term also for logic languages, where appropriate
08:10:40 <jgt> so the kind for (Maybe a) is two stars
08:10:41 <merijn> aplainzetakind: That means you're reading from a thread that no one can ever write too. Are you sure both sides are reading from/writing to the right channel?
08:10:45 <tty1> hmm
08:10:54 <phadej> ski: well, "not suppose", but check the book; it's available online
08:10:59 <jgt> Maybe :: * -> *
08:10:59 <phadej> I won't
08:11:06 <Solonarv> tty1: that's correct, although it's not a cast
08:11:08 <ski> jgt : you may want to distinguish clearly between the *type* `Int', and possible values of that type
08:11:11 <Solonarv> it's an assertion
08:11:17 <aplainzetakind> merijn: I think so, but let me check.
08:11:17 <vivit> Is it possible to define a typeclass without specifying functions?
08:11:20 <jgt> you have to give the Maybe some `a` before it is a full thing
08:11:23 <Solonarv> vivit: yes
08:11:39 <dmwit> vivit: Yes. It's even possible to define a typeclass without specifying any non-function methods. =)
08:11:47 * dmwit puts on his ultra-pedantic hat
08:12:06 <vivit> Lies-to-children, please.
08:12:11 <dmwit> ?src Bounded
08:12:11 <lambdabot> class Bounded a where
08:12:11 <lambdabot>     minBound, maxBound :: a
08:12:18 <ski> vivit : we call the "members" of a type class, "methods"
08:12:19 <dmwit> vivit: ^ A class with methods but no functions
08:12:27 <Solonarv> % class ThisWorks a -- see, no methods
08:12:27 <yahb> Solonarv: 
08:12:37 * ski smiles
08:12:40 <bollu> I'm not able to get packages from hackage like so: $ wget http://head.hackage.haskell.org/package/aeson-1.4.2.0.tar.gz
08:12:43 <tty1> jgt: while i do appreciate the explanation im not sure im understanding it yet.. possibly because I sort of see int as its own special thing, which may be part of the problem.. like im not sure what you mean when you say it takes one thing.. doesnt Maybe also take one thing, but in a different way
08:12:43 <bollu> Anyone knows what's going on?
08:13:02 <aplainzetakind> merijn: Well the keyboard channel is Chan Char and the display prompt channel is Chan String so a mismatch would be a type error anyway.
08:13:06 <Solonarv> % class (Num a, Ord a) => AlsoWorks a -- and if you do something like this it's actually useful
08:13:06 <yahb> Solonarv: 
08:13:09 <merijn> tty1: "Kinds are to types, as types are to values"
08:13:26 <jgt> tty1: Int doesn't take some extra value. It's a full thing on its own. That's why its kind is one star
08:13:28 <merijn> aplainzetakind: Do you have the code somewhere?
08:13:35 <tty1> merijn: hmmm ok that seems helpful... though im not sure how yet, lol .. im trying to orient myself
08:13:44 <aplainzetakind> I have a gitlab repo.
08:13:51 <jgt> tty1: think of it like a type signature for a function
08:13:56 <aplainzetakind> Private, but I can give you access.
08:14:09 <merijn> tty1: The value 1 has type Int, and the type Int has kind * (all types that have values have kind *)
08:14:27 <jgt> tty1: if you have some function which takes `f :: Something -> FullThing`
08:14:32 <ski> tty1 : a value can have type `Int'. it's not possible for a value to have type `Maybe'. `Maybe' is an "incomplete/unsaturated type", like a template that is missing some part. the situation for lists is similar, to be fully explicit you can't just say that `xs' is "a list", you must answer "a list of *what*". e.g. with a list of `Int's, one could say `xs :: [] Int', which has syntactic sugar `xs :: [Int]'
08:14:40 <tty1> jgt: ahh so really your saying Int (a 1) takes 0 things. It is just itself (as an analogy, while it isnt a function, it is like a function that takes no arguments but returns something, vs a function that takes one thing, which is like maybe.. just somehow maybe and Int arent functions their something else (types?)
08:14:45 <merijn> tty1: The type "Maybe" has kind "* -> *" in other words, it takes a type of kind * and returns a type of kind *. So "Maybe :: * -> *" and "Int :: *", so logically "Maybe Int :: *"
08:14:46 <jgt> yes
08:15:00 <jgt> yes
08:15:15 <jgt> I think tty1 gets it now
08:15:18 <merijn> tty1: Basically, kinds are used to "typecheck" your types
08:15:29 <ski> tty1 : so, `Maybe' is like a "function on the type level", if we "pass it" `Int' as an argument, we get `Maybe Int', which is a complete/saturated/"concrete" type, one which it is possible for a value (or expression) to have, as type
08:15:31 <dmwit> vivit: (Do you feel as though you got the answer you needed? Do you feel as though you got enough explanation to understand the answer you got?)
08:15:34 <jgt> even with my braindead explanation
08:16:06 <eacameron> Is there a way to get ghci to not run code until I enter some final delimiter. I don't mean :{ ... :} because that doesn't let you edit previous lines. I want to edit a multiline command all at once.
08:16:14 <tty1> merijn: i get that Maybe would take a type of kind * (though in my head i still read that as any type, not kind... so missing something there).. though im not sure what a Maybe * returns? Isnt Maybe * the thing itself? It is returning something? or do you mean when you get the content out of a Just, that is what it returns?
08:16:24 <vivit> I got the answer I needed, yes.  Solonarv's "ThisWorks" example showed me what I needed.
08:16:29 <dmwit> eacameron: :e ;-)
08:16:38 <ski> tty1 : to express that `Int' and `Maybe Int' are "concrete" types, ones which are capable of having values, we can write kind signatures `Int :: *',`Maybe Int :: *'. and this then means that `Maybe' itself will have kind signature `Maybe :: * -> *', because it's a "function" that takes a concrete type into a concrete type
08:16:39 <tty1> let me go into GTHC and play with :k and :t real fast
08:16:41 <merijn> tty1: Well, you can't have values whose type is "just" (ha!) "Maybe"
08:16:42 <tty1> see if it clicks
08:16:48 <merijn> :t Nothing
08:16:49 <lambdabot> Maybe a
08:16:50 <dmwit> eacameron: That is, make a file and use your favorite text editor, then load it.
08:17:03 <eacameron> dmwit: O_O
08:17:30 <merijn> tty1: All values made with Just and Nothing have type "Maybe ?" so what is ? it is any other type that has kind *
08:17:50 <merijn> tty1: So "Maybe Int" makes sense, so does "Maybe (Maybe Int)", but "Maybe Maybe" does not
08:17:50 <eacameron> dmwit: So what you're saying is "File a feature ticket request on ghci" 👍 got it. :P
08:18:01 <dmwit> eacameron: Nah. Don't implement a text editor in my compiler, please.
08:18:10 <dmwit> There are plenty of them around already.
08:18:26 <merijn> tty1: Why does "Maybe Maybe" not make sense? Because Maybe wants a type that has values, but "Maybe" (without argument) doesn't have any values
08:18:46 <ski> `not False' makes sense, so does `not (not False)', but `not not' does not
08:19:14 <ski> (s/has values/is capable of having values/)
08:19:35 <dmwit> eacameron: More to the point, good text editors take a *lot* of engineering effort. That effort is in very short supply on the GHC team, and (I personally think) there's lots of higher-priority things to work on than duplicating some other projects' efforts.
08:20:00 <eacameron> dmwit: Well really all I want is :{ :} to not suck.
08:20:10 <eacameron> We already support multiline something...it just sucks.
08:20:30 <tty1> merijn: yea i could instinctually tell you Maybe Maybe doesnt make sense.. but id have no clue how to assert that in haskell terms.. I guess thats what the kind of maybe is doing though.. just not sure why cause "Maybe *" in my head would be satisfied by Maybe Maybe even though i know it makes no logical sense
08:21:01 <Solonarv> * is not a wildcard
08:21:05 <merijn> tty1: Maybe is not a kind, Maybe is a type that *has* a kind (specifically "* -> *")
08:21:17 <tty1> hmmmm
08:21:34 <ski> tty1 : think of `Maybe :: * -> *' as being a bit similar to `not :: Bool -> Bool', except the former expresses the kind of a type (in this case a type function), while the latter expresses the type of a value (in this case a function)
08:21:53 <tty1> merijn: ok that helps with the vocab side (and another piece of the puzzle i needed).. 
08:22:11 <merijn> tty1: Hence, "kinds are to types, as types are to values"
08:22:21 <merijn> Values have a type, and types have a kind.
08:22:47 <vivit> what's the deal with showsPrec?
08:22:59 <vivit> What does it do?
08:23:07 <tty1> skithoeg[m]: I guess why im confused about the maybe part of that is because im not sure what it returns.. like i know we can pull the value it contains out of it, but we can only do that because we defined special functions that are capable of that. It doesnt strike me as a quality intrinsic to something defined with "data"
08:23:14 <Solonarv> vivit: there's two separate things going on with showsPrec
08:23:17 <ski> `*' is a specific kind, the kind of all "concrete types", like `Int',`String',`IO Char',`[(String,Int -> IO (Maybe Double))]',`Either String Integer',`StateT Integer IO ()' but not things like `Maybe',`Either',`Either String',`IO',`StateT Integer IO'
08:23:30 <tty1> sorry to take you guys so far down this rabbit hole with me. I think i just need to read a different book
08:24:03 <ski> vivit : it takes the precedence level of the surrounding expression. it is used to decide whether it needs to wrap in protecting brackets or not
08:24:09 <Solonarv> vivit: one is the numeric argument; this tells showsPrec what context the value is being shown in, so that it can decide whether it needs to parenthesize the output
08:24:10 <hyperisco> Take a look, it's in a book!
08:24:13 <tty1> skithoeg[m]: ok that makes sense... though SDtring is technically a [Char] but i guess its still a concrete type and thus still kind of "*"
08:24:14 <ski> vivit : similarly with `readsPrec'
08:25:14 <ski> vivit : if you want to, i could explain a little about how to correctly define `showsPrec' (and `readsPrec'), when (rarely) making a `Show' (or `Read') instance, over in #haskell-overflow (since it's currently a bit noisy in here)
08:25:40 <vivit> yes please
08:25:48 <Solonarv> then there is the fact that it returns a 'ShowS', i.e. 'String -> String', instead of a plain old 'String'; this is simply an optimization because otherwise we would end up ++'ing together a crapload of small strings very inefficiently
08:26:17 <hyperisco> tty1, I get you
08:26:33 <zincy> ski: thanks for the explanation on embedding
08:26:38 <hyperisco> 1 + 2  reduces to  3  so what does  Maybe Int  reduce to?
08:26:52 <hyperisco> The answer is… it reduces to  Maybe Int
08:27:07 <Solonarv> it doesn't reduce to anything, in other words: it's already in its most-reduced form
08:27:28 <Solonarv> much like 'Right 5' doesn't reduce to anything
08:27:42 <hyperisco> The reason function application reduces to something is because there is what is called a beta-reduction rule, which means to substitute the argument for the parameter everywhere in the body
08:27:49 <tty1> hyperisco: yea (+) is a function that takes two ints and returns an int.. but is Maybe even a function.. it seems to be this thing that acts like data but is also function like in some way i dont understand
08:27:53 <phadej> for terms people speak about "it either reduces to something or is a value"
08:28:22 <tty1> hyperisco: makes sense, i do that a lot when trying to reduce complex haskell stuff.. Just start substituting incrementally
08:28:22 <phadej> without type-families GHC types are in value-form
08:28:23 <hyperisco> I argue there should have been a different type than -> for constructors for this reason, because there is no beta-reduction rule for them
08:28:27 <hyperisco> but, that is how things are :)
08:28:39 <Solonarv> hyperisco: soon!
08:28:49 <Solonarv> there's a GHC branch which makes the distinction
08:28:51 <hyperisco> Oh yeah?
08:29:01 <hyperisco> There must be some other motivation for it…
08:29:15 <Solonarv> yes, it lets you work with unsaturated type families
08:29:40 <Solonarv> so it needs to distinguish between a constructor and an unsaturated type family
08:29:47 <hyperisco> Ah! Well interestingly I have been doing that for a while in PureScript. Not sure what the differences will be.
08:30:03 <phadej> hyperisco: there's a preprint
08:30:08 <Solonarv> the difference is part of the arrow, and is called "matchability"
08:30:22 <tty1> anyway thanks for all the help.. going to try to play with some of these ideas so i can try to understand all the wonderful help everyone gave.. I have some really helpful tips to reflect on for understanding this
08:30:29 <phadej> https://www.microsoft.com/en-us/research/uploads/prod/2019/03/ho-haskell-5c8bb4918a4de.pdf
08:30:48 <Solonarv> essentially if f, g :: k1 '-> k2 that means we can "take apart" (f a ~ g b) into (f ~ g, a ~ b)
08:30:59 <Solonarv> (here '-> is the matchable arrow)
08:31:03 <hyperisco> Solonarv, oh I misunderstood for a moment. I was thinking unsaturated type aliases, which is something one can use in PureScript, but you're indicating type families! Well, splendid.
08:32:07 <Solonarv> I don't know much about that GHC branch apart from chatter I overheard in #ghc, I think you could poke kcsongor about it if you wanted
08:32:47 <phadej> I guess it's the race, will the matchability or multiplicity land first
08:33:02 <tsahyt> what's the current state of Haskell on ARM?
08:33:03 <phadej> the other one would get nice conflict to resolve
08:33:34 <Solonarv> phadej: oh yeah, I thought about that when I recently heard that linear haskell was making good progress
08:33:49 <hyperisco> Solonarv, so we can keep around the injectivity of constructors, awesome
08:34:04 <Solonarv> hyperisco: it's more than just injectivity, actually
08:34:23 <Solonarv> injectivity only lets us split (f a ~ f b) into (a ~ b)
08:34:30 <tty1> So im going to start learning haskell over.. I got some book suggestions but before i dive into that does anyone have a haskell book they personally used to learn from without knowing FP, and if so can you please share with me what it is so i can check it out
08:34:38 <Solonarv> we need to already know that we have the same constructor on both sides, in other words
08:34:55 <hyperisco> Solonarv, good point. I don't know what the stronger decomposition is called.
08:35:00 <phadej> the other half (to injectivity) is generativity
08:35:20 <tsahyt> tty1: I used real world haskell back then, but unfortunately it hasn't been updated and so some of the information is out of date by now
08:35:20 <phadej> the paper is good, worth reading
08:35:33 <Solonarv> well, richard eisenberg calls it "matchability" in his dependent haskell thesis
08:35:37 <tty1> tsahyt: cool thanks for the info, i might take a peek
08:35:44 <Solonarv> that's where I took the term from
08:35:49 <Cale> tsahyt: To be fair, it should only be out of date in somewhat trivial ways
08:36:06 <Cale> (but it might be frustrating for a beginner)
08:36:07 <freeside> tty1: i've been very very happy with haskellbook.com
08:36:32 <hyperisco> matchability = injectivity + generativity
08:36:33 <phadej> Solonarv: the paper defines f is matchable ⇐⇒ f is both injective and generative.
08:36:43 <Cale> tty1: I can't claim to have learned from it, given that it didn't yet exist when I learned Haskell, but I really like Graham Hutton's book "Programming in Haskell" as an intro.
08:36:45 <phadej> hyperisco: +1
08:37:26 <Solonarv> phadej: yeah, I just couldn't remember what precisely generativity was
08:37:40 <phadej> Solonarv: that's why you should peek into the references ;)
08:38:07 <tty1> ::nod:: ill take a look at these options, thanks a lot
08:38:08 <tsahyt> Cale: yes, the basics taught in RWH are still relevant. it's just that a lot of the libraries used for the real world parts are hopelessly out of date by now
08:38:18 <tsahyt> Cale: though to be fair they already were when I read it, and I got by fine
08:38:20 <Solonarv> ah, I see the paper you linked references Eisenberg
08:48:41 <Solonarv> phadej: a 2019 paper on type-level haskell using StarIsType :/
08:49:15 <phadej> Solonarv: that's submitted version, who knows how it will be amended :)
08:50:05 <Solonarv> :D
08:53:35 <ski> zincy : np
09:12:55 <tty1> Im reading a gentle introduction to haskell and so far this seems much better, more technical which helps me :)
09:13:33 <tty1> A lot of what you guys said earlier is starting to click now too, so thanks again
09:16:48 <ski> tty1 : heh. have you seen any other functional programming language before ? Scheme ? Erlang ? SML or OCaml ?
09:18:05 <ski> some people have complained about the "Gentle Introduction To Haskell" not being "gentle" at all. at least not if you've not seen any FP before
09:18:13 <ski> but if you like it, go for it !
09:20:06 <tty1> ski: I think my problem is the last book was too gentle. So while it was an easy read it left out details with the expectation of introducing them later. But my brain doesnt work well with that as i cant move on till ihave a complete understanding of all the edge cases of a particular idea
09:23:29 <jgt> I thought HPFFP was a pretty good book. I haven't read all of it, but the exercises are pretty extensive
09:23:45 <jgt> and at least for me, that's what I need to grok stuff in Haskell
09:24:18 <tty1> jgt: what does HPFFP stand for?
09:24:32 <jgt> Haskell Programming From First Principles
09:24:36 <jgt> aka Haskell Book
09:24:48 <jgt> the lengthy one big Chris Allen and Julie Moronuki
09:24:57 <jgt> (not sure if both their names are on the book any more though)
09:25:24 <jgt> s/big/by/
09:25:28 <tty1> jgt: ahh i think i actually have a copy of that. ill take a look
09:26:20 <ski> tty1 : ooc, what was the "last book", then ?
09:27:08 <tty1> ski: the one that failed me earlier? "Learn you a haskell".. dont get me wrong it did get me far enough to write a markov chain program. But it left some rather vital holes by the end in my head
09:27:22 <ski> ah, LYAH
09:27:32 <ski> yea, people here don't tend to recommend it (any longer)
09:27:32 <jgt> tty1: I learned about kinds from that book. Tbh, I think you may have overcomplicated kinds in your head. If you understand partial application, you should understand kinds
09:27:49 <tty1> ski: part of that is my own fault as i did read the book half way through months ago thenjust finished it recently. However i found the structure of the book hard to review from too.
09:27:51 <jgt> that book = HPFFP
09:28:06 <ski> LYAH has been likened with a four-hour long film trailer. not enough depth. also it lacks exercises. but it does have pretty pictures ! :D
09:28:35 <ski> ("likened to" ?)
09:28:51 <jgt> not sure how everyone else feels (probably I am in the minority here) but I can't stand "cute" learning material or documentation
09:28:54 <mniip> compared wiyh
09:29:04 <tty1> jgt: it may not be entierly the books fault re: my last comment. However this gentle introduction cleared up kinds for me (I think) in the first few pages already, or at least it is starting to. So at least as a book to use to review concepts you half know it seems superior (as I said LYAH is hard to review from)
09:29:08 <jgt> like, I have enough going on, no I'm not interested in unicorn emoji
09:29:41 <mniip> > generalCategory '🦄'
09:29:44 <lambdabot>  <hint>:1:18: error:
09:29:44 <lambdabot>      lexical error in string/character literal at character '\129412'
09:29:45 <zincy> tty1: Hutton's book is my favourite
09:30:03 <zincy> It is fantastic
09:30:12 <tty1> jgt: i sorta agree, im a scientist by profression so I do like nice technical, sweet, and serious learning material as I usually dont have the patience for all the fluff and wind up skipping or skimming through a lot.
09:30:20 <MarcelineVQ> the haskell report can also clear up kinds, https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-630004.1
09:30:35 <tty1> zincy: which book sis that exactly? I may have it in my collection
09:30:50 <zincy> "Programming in Haskell"
09:30:57 <zincy> It is concise and to the point.
09:30:58 <tty1> MarcelineVQ: i will look at the haskell report, i did download it. but so far gentle introduction is doing the trick
09:31:07 <tty1> zincy: perfect!
09:31:35 <zincy> You can use "Haskell from first principles" to go in depth on the topics you don't understand
09:31:40 <zincy> and use it as an exercise library
09:31:50 <zincy> The combination of those two was great for me
09:32:30 <MarcelineVQ> in short a type is the type of a value, a kind is the type of a type, and it's not any more or less complicated than that. * just looks stranger than Int so it seems special
09:32:43 <tty1> zincy: yea ill consider that, it sounds promising
09:32:58 <jgt> tty1: do you understand kinds yet? It seemed like you did earlier
09:33:06 <ski> tty1 : yea .. when i read the "gentle" one, it seemed fine to me. but by then i had already read "Haskell: The Craft of Functional Programming" (or at least much of it ?), by Simon Thompson
09:33:56 <tty1> jgt: im getting really close. I understand them much better than i did and am now amble to answer, at least, my own question about why the type type declration was of the form it was. 
09:34:13 <ski> jgt : heh, i'd like emoji eradicated from unicode (at least) ;)
09:34:19 <jgt> tty1: do you understand partial application?
09:34:24 <ski> @where PIH
09:34:24 <lambdabot> "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
09:34:37 <tty1> nice
09:34:38 <ski> @where report
09:34:38 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
09:34:42 <ski> @where tutorial
09:34:42 <lambdabot> http://www.haskell.org/tutorial/
09:35:57 <jgt> tty1: I don't know you, but I am determined to make you understand this
09:36:01 <jgt> it's not super hard
09:36:13 <tty1> The key for me, and a BIG part of my earlier confusion was realizing that the type decleration and the type constructor are in seperate name spaces. So if they have the same name that is simply arbitrary and they are in fact, still, seperate things
09:36:36 <jgt> yes, that is true (and still confuses me sometimes)
09:37:16 <jgt> or rather, I think I know what you're trying to describe, but I think those exact words don't describe it
09:37:57 <tty1> jgt: i have used partial application of functions, and I think I understand it. but as weve seen I seem to understand a lot of ideas a lot less than I thought I understood them... and thank you, I do appreciate you trying to help. Though a word of warning, I dont learn well from people usually, I tend to need to figure stuff out on my own in my own head.. like in math i dont understand an equation or remember it until i can 
09:37:57 <tty1> derrive it. Thus why im trying to read and work through examples a lot.
09:37:59 <jgt> I think you're describing how in `data Foo = Foo`, the two `Foo`s are not the same thing
09:38:20 <jgt> :type 5
09:38:23 <jgt> darn
09:38:25 <jgt> @type 5
09:38:25 <geekosaur> type constructors and data constructors are in separate namespaces
09:38:26 <lambdabot> Num p => p
09:38:28 <tty1> jgt: yes that is exactly what I meant
09:38:41 <jgt> ok tty1 check this out
09:38:53 <tty1> like you could do `data Foo = Bar` and it would be more clear, but you could name Bar to Foo and it is still different from the other Foo
09:38:54 <jgt> you can check the type of something in GHCi with :t
09:39:10 <jgt> or you can check the type of something in lambdabot (here) with @type
09:39:19 <tty1> yes i use :k and :t often
09:39:27 <tty1> been looking at a lot of types to see the pattern lately
09:39:45 <jgt> tty1: ok, so what is the type of Nothing>
09:39:47 <jgt> ?
09:40:04 <ski> (`data Foo = MkFoo')
09:40:06 <tty1> Nothing, I think it is `Maybe a` but id need to double check that
09:40:14 <tty1> @type Nothing
09:40:15 <jgt> you can check it here with lambdabot
09:40:16 <lambdabot> Maybe a
09:40:19 <tty1> yup :)
09:40:19 <jgt> ok, good
09:40:32 <jgt> now, what is the other constructor you have in (Maybe a)?
09:40:38 * ski thinks it helps newbies to not name the type constructor and the data constructor the same
09:40:40 <jgt> theres `Nothing`, and there's…
09:40:42 <tty1> Just and Nothing are the two constructors
09:40:45 <jgt> right
09:40:50 <jgt> so what is the type of `Just`?
09:40:52 <ski> (data constructors)
09:40:52 <tty1> Just takes one parameter, Nothing takes none
09:41:08 <tty1> The type of Just is the same as the Type of Nothing, they are the same type
09:41:13 <[exa]> ski: favorite altname for type constructors?
09:41:24 <jgt> tty1: try checking it
09:41:24 <ski> [exa] : "tycon"
09:41:29 <[exa]> :]
09:41:33 <tty1> @type Just
09:41:34 <lambdabot> a -> Maybe a
09:41:40 <tty1> wait what
09:41:45 <tty1> @type Nothing
09:41:46 <lambdabot> Maybe a
09:41:50 <jgt> you see that? You need to give it an argument for it to be a complete type
09:41:52 <tty1> well thats not what I thought
09:42:03 <MarcelineVQ> "<tty1> Just takes one parameter, Nothing takes none" But it is what you thought :D
09:42:05 <jgt> that's the analogy I'm trying to make with partial application and kinds
09:42:06 <ski> @type Just False
09:42:08 <lambdabot> Maybe Bool
09:42:16 <ski> @type Just (error "oops !")
09:42:17 <lambdabot> Maybe a
09:42:21 <tty1> I thought the type would just be the left hand side of its decleration
09:42:38 <ski> that's the *return* type of the data constructor
09:42:42 <boj> tty1: the type is the left hand, the constuctor the right
09:42:45 <tty1> ohhh yes now i see why i didnt see this earlier.. I never tried type on just `Just` I always did it on something like `Just 1`
09:43:00 <ski> (in the case of `Nothing', that's the whole of the type, since there are no arguments, and so no argument types inside function types)
09:43:07 <jgt> does that make sense now?
09:43:12 <tty1> ohhh shit, i should have realized, they are called constructors after all, they are just functions huh?
09:43:20 <jgt> yeah!
09:43:31 <tty1> a data constructor is just a function! thats what i was missing
09:43:48 <[exa]> tty1: not "just", you can use data constructor for pattern matching, which you can't do with arbitrary functions
09:43:57 <boj> > fmap Just [1,2,3]
09:43:59 <lambdabot>  [Just 1,Just 2,Just 3]
09:44:08 <[exa]> tty1: anyway, from the constructive side, it works just as a function
09:44:38 <tty1> hmm wait, let how do i ask the bot what the type is for some arbitrary function that takes no arguments... is (\ -> 3) a valid lambda?
09:44:50 <tty1> @type (\ -> 3)
09:44:52 <lambdabot> error: parse error on input ‘->’
09:44:59 <tty1> hmmm
09:45:00 <[exa]> functions always take 1 argument
09:45:12 <boj> @type (\_ -> 3)
09:45:14 <[exa]> (sans some syntactic sugar)
09:45:14 <lambdabot> Num p1 => p2 -> p1
09:45:34 <tty1> so Nothing is not a function at all while Just is a function?
09:45:51 <jgt> :type Nothing
09:45:55 <jgt> @type Nothing
09:45:55 <tty1> I was going to think of Nothing as a function that took no arguments but such things dont exist so its just a concrete type in its own
09:45:57 <lambdabot> Maybe a
09:46:17 <tty1> So a data constructor can be **either** some sort of function or a concrete type?
09:46:26 <[exa]> tty1: you may call Nothing a constant
09:47:07 <jgt> tty1: I think I see the line of thought you're going down, and I think you're adhering to the function analogy too strictly
09:47:08 <tty1> ok ... i guess constants are the haskell way of solving the fact that you cant have a function with no arguments.. so they are similar still in some sense
09:47:21 <tty1> jgt: wouldnt surprise me
09:47:25 <[exa]> constants are everywhere
09:47:36 <[exa]> True, False, [], 0,1,2,3..., ()
09:47:39 <boj> :t Nothing :: Maybe Int
09:47:41 <lambdabot> Maybe Int
09:48:12 <tty1> [exa]: ive dealt with a lot of them.. Empty too in my own definitions... its just im starting now to learn about what that really means, before now ive just been parroting code
09:48:34 <tty1> hmmm
09:48:45 <tty1> @type (Nothing ::Maybe Int)
09:48:46 <lambdabot> Maybe Int
09:49:07 <tty1> hmmm 
09:49:08 <jgt> tty1: remember how you checked the type of `Just` before, and it gave you a surprising result? Try checking the kind of `Maybe Bool`, and then try checking the kind of `Maybe`
09:49:25 <[exa]> anyway, data constructor is basically a means of constructing new values of the corresponding type, no matter how many "arguments" it has
09:49:31 <jgt> @kind Int
09:49:32 <lambdabot> *
09:49:35 <tty1> @kind Maybe Bool
09:49:37 <lambdabot> *
09:49:45 <tty1> @kind Maybe
09:49:46 <lambdabot> * -> *
09:50:04 <jgt> you see that? It needs another thing given to it before it's a fully applied thing
09:50:09 <tty1> ohh wait i think i just got that kind stuff now... what you meant earlier with "returns"
09:50:51 <jgt> I don't remember saying anything about "returns" :P 
09:51:09 <tty1> jgt: someone did, it was a point iw as confused on like an hour ago
09:51:43 <tty1> hmm ok let me think outloud for a second, see if i got this....
09:51:46 <jgt> I mean, I may have done, but I don't remember. I try and avoid using the word "return" because it means something very different in Haskell
09:54:07 <geekosaur> I say "result" there usually
09:54:27 <tty1> hmm hold up as i tried to word it i realized im still missing something... one sec.. im getting real close though, just thinking about what im missing
09:55:54 * jgt holds up
09:56:23 <tty1> Im back tracking in my head now trying to think of how declaring a type is related in some way to declaring a data... not even sure if thats a relevant tangent right now
09:57:26 <jgt> it might be a relevant tangent — bear in mind that the constructors can all have a different arity (this is probably the wrong word)
09:57:51 * geekosaur wonders if this is related to type vs. newtype vs. data
09:57:57 <jgt> data Foo = Bar | Baz Int | Qux Int Int
09:58:13 <tty1> jgt: the irony of people using the phrase "bear in mind" when talking to me is I always picture an actual bear, the animal, and thus I literally do hav ea bear in my mind when you say it :) lol
09:58:51 <tty1> well i understand newtype vs type at least.. but im reflecting right now on data vs type
09:58:55 <[exa]> tty1: the usual exercise is to realize some examples of 'data constant', 'data-constructing function', 'type constant', 'type function', and use all of them in a correct place of 'data' declaration
09:59:30 <jgt> tty1: conversely, I'm afraid of using the word "irony" because I'm now convinced I will never know what it means
09:59:32 <tty1> [exa]: that would sound very useful, particularly if i could see examples of all those things side by side
09:59:32 <jgt> https://www.youtube.com/watch?v=m9xbGG9H9mg
09:59:33 <[exa]> tty1: (basic examples, respectively: [], Just, Int, Maybe)
09:59:57 <tty1> jgt: lol
10:00:07 <tty1> hmmm
10:00:09 <[exa]> tty1: problem with 'data' statement is that all of those are kindof mixed up all in one place
10:00:54 <tty1> yea it seems to me that a data decleration can use type declrations in it.. but i think that a type decleration can only reference other types...
10:01:31 <tty1> it feels to me like type just wraps other types, and data defines a concrete data structure
10:01:48 <geekosaur> type defines a type *alias*. (this is fairly confusing)
10:02:02 <geekosaur> type String = [Char] -- the two are identical in all ways
10:02:24 <jgt> in practice, I don't find the `type` keyword particularly useful
10:02:40 <jgt> I only use it if I have some gnarly long type and I want it more human readable
10:02:58 <geekosaur> backward compatibility is another good reason
10:03:05 <tty1> geekosaur: yea type alias i usually think of as just type wrapping, since it is a new type which can have its own instances, and is used in a way to make types behave differently... though more often that seems to be newtype
10:03:10 <jgt> geekosaur: I haven't faced that challenge yet
10:03:28 <tty1> jgt: newtype seems more useful to me in practice than type
10:03:34 <[exa]> tty1: there's a difference between in what the type description contains (say, Maybe Int) and what the data actually contain (like, Nothing contains precisely nothing)
10:03:36 <geekosaur> like, State used to be a distinct type and a lot of code still uses it that way, but since mtl-2.0 it's actually been StateT Identity
10:03:51 <jgt> tty1: that's because newtype actually creates a new type
10:04:04 <jgt> whereas type just creates an alias
10:04:13 <jgt> here's a good example of `type` from Yesod
10:04:17 <jgt> type DB a = forall (m :: * -> *). (MonadIO m) => ReaderT SqlBackend m a
10:04:36 <jgt> you don't want to litter all the cruft all over the place when you want to do database queries
10:04:43 <geekosaur> it also lets you hide internal details, so for example much parsec/megaparsec code uses Parser which has changed "meanings" in mostly backward compatible ways over a decade
10:04:55 <jgt> so instead you can just say `getThings :: DB [Thing]`
10:05:49 <tty1> yea that makes sense
10:06:02 <geekosaur> whereas someone using ParsecT directly will have had to make a lot of changes over the years
10:07:14 <jgt> tty1: oh, that `DB a` type alias. What kind do you think `DB` has?
10:07:36 <tty1> im starting to get really hungry and cant think straight.. but i think im really close to understanding this, if i dont already.. let me get a bite to eat and see if it all seems clear on a full stomach
10:07:48 <tty1> hmmm 
10:08:29 <jgt> the type is `DB a`
10:08:35 <tty1> im actually not used to seeing "forall" 
10:08:47 <jgt> if you just say `DB`, then it's still waiting for the `a`
10:09:00 <jgt> so the kind of `DB a` is * -> *
10:09:03 <jgt> wait
10:09:05 <jgt> no
10:09:07 <jgt> typo
10:09:09 <[exa]> noep
10:09:11 <tty1> well DB I'd expect to be * -> * and DB a to be *
10:09:14 <tty1> or something
10:09:15 <jgt> yes
10:09:16 <tty1> ohh yea
10:09:19 <jgt> that's correct
10:09:28 <jgt> ugh; tired and hungry myself
10:09:51 <jgt> ok I think you get kinds now
10:10:16 <tty1> but when looking at it I was wondering why it says "DB a =..." and not "DB m a =..." thus why i hesitated.. but i also was just getting familiar with Data again so hadnt reoriented myself to the format for the type keywrorc
10:10:40 <tty1> jgt: i think i do too, and really appreciate the help. On a full stomach i bet it will all click instantly
10:54:08 <fen> can we have singletons on constraints?
10:54:32 <fen> the idea is to have a type family return a constraint, but to restrict this so it has to be ()
10:55:33 <fen> the motivation for doing so is to have a class with an associated type, where this is somehow equivalent to a closed type family returning () :: Constraint
10:57:44 <fen> you could have this closed type family returning () :: Constraint as an associated type to the class, which appears as a superclass constraint to the class
10:59:18 <fen> this would mean only the type instances appearing in this closed type family could be instances of the class, so giving a way to do closed classes
11:01:40 <Single21YearsOld> I will start my Live Show in 10 minutes. Fastest people will join my Private Live for FREE! Be among the first 5 people to write me "FREE INVITE" on my CAM room: http://snip.li/Y9uLM
11:02:24 <LKoen> you're doing a live haskell demo?
11:03:05 <fen> type safe dating app?
11:03:48 <tty1> back with a belly full of cheese... going to review all the earlier help now and see if i get this, just wanted to say thanks again you guys are really great, jgt your awesome :)
11:07:21 <Rembane> Cheese is the best.
11:08:06 <Xal> What order does -XDeriveGeneric choose to put product types in?
11:08:45 <[exa]> Rembane: I thought I'm not hungry 3 minutes ago
11:09:22 <Xal> For `data A = A () () () () ()` it seems to do `((() :*: ()) :*: (() :*: (() :*: ())))`.
11:09:28 <Xal> This seems like a really strange choice
11:09:46 <[exa]> tty1: anyway, did you sort out what in 'data' is types, type parameters, data constructor, and data structure content?
11:10:06 <Xal> I would really like it to put them in order like a cons list, so I could chain right-associative generic functions together.
11:12:35 <Rembane> [exa]: One of the big risks with cheese.
11:13:42 <tty1> Rembane: im on keto so its all i eat :)
11:13:51 <Rembane> tty1: Luxury! :D
11:13:55 <tty1> [exa]: I think so, im just thinking it through now
11:14:26 <tty1> [exa]: im doing as you suggested and looking at some examples too just to make sure it all lines up in my head right
11:16:32 <[exa]> tty1: there's sometimes a bit of confusion eg about () or [] (and perhaps some other) that are names for both type constructors and data constructors, but type [] is completely different from data []
11:17:21 <[exa]> tty1: same for (), in 'data () = ()'. The first is the type name you define, the second is an object of that type.
11:18:22 <tty1> [exa]: yes in general the distinction between the name ont he left and the right of the equals is a bit confusing, but i think its just because im lacking a bit of vocabulary because i do understand now how they are used i think
11:19:27 <tty1> Would it be correct to say "I have a Maybe a type with a value of Just 1" is that the correct use of vocabulary there?
11:20:10 <tty1> "I have a `Maybe a` type with a value of `Just 1` "
11:20:46 <[exa]> :t Just 1
11:20:47 <lambdabot> Num a => Maybe a
11:20:58 <[exa]> so yes, except there's extra condition on 'a'
11:22:06 <tty1> wait shouldnt that have said "Maybe Int"? or is 1 here ambiguous and just a Num not specifically an Int so it is just a bit more general?
11:22:15 <tty1> :t Just(1 :: Int)
11:22:16 <lambdabot> Maybe Int
11:22:18 <[exa]> yes
11:22:20 <tty1> ahh there we go
11:22:22 <tty1> :)
11:22:24 <tty1> cool
11:22:27 <[exa]> numbers are sneaky
11:22:30 <tty1> ok yea makes more sense now
11:22:40 <tty1> [exa]: story of my life right there, those damn sneaky numbers :)
11:27:22 <[exa]> tty1: anyway, the syntax from type/data perspective is 'data T t t ... = D t t ... | D t t ... | ...'
11:28:11 <tty1> yea
11:28:26 <[exa]> where T is a type name, D is a data constructor name (you are defining both of those things in one go)
11:28:54 <tty1> yup, makes sense
11:28:57 <[exa]> the 't' behind T are type arguments (those are variables that parametrize your type, you can use them later in the definition)
11:29:20 <[exa]> and the 't' behind Ds are arbitrary types of data fields
11:29:39 <[exa]> (you can use the parameter variables there)
11:29:40 <tty1> Ya know ive been on IRC for a very long time (well over a decade) and this is one of the friendliest help channels I've been on. :)
11:29:54 <[exa]> :D
11:30:09 <[exa]> there's also #postgresql, that one is super-useful
11:30:32 <[exa]> but a bit more production-oriented
11:30:47 <[exa]> and less haskell ofc. :D
11:31:33 <[exa]> tty1: exercise, declare a type of infinite binary trees that contain Int in each node
11:33:22 <Solonarv_> Xal: the *order* of the fields/constructors is the same as in the type's definition
11:34:04 <Solonarv_> However they're associated like a balanced binary tree because that's more efficient
11:34:42 <Solonarv_> A list representation is more convenient to work with though, that is true
11:35:01 <Solonarv_> @hackage generics-sop
11:35:01 <lambdabot> http://hackage.haskell.org/package/generics-sop
11:35:56 <Solonarv_> ^ this library is a layer on top of GHC's Generic machinery that gives you a list representation
11:45:02 <phaul> i'm so confused by https://www.codewars.com/kata/coroutines/, can someone give me pointers?
11:46:25 <phaul> I spent sime time understanding continuation, and I think this is correct , at least it type checks: https://gist.github.com/phaul/a58c24c9a98cdc6f040176b1872224e8
11:46:45 <iqubic> Comonads confuse the heck out of me. Is there any practical use to them?
11:47:53 <phaul> next step was coroutines this type checks but still full of undefineds, and I think I started going off the rails https://gist.github.com/phaul/d92ba5fac4faef9a892f351e3b19cbd2
11:48:56 <iqubic> I don't think haskell has coroutine support
11:49:08 <phaul> I cant see how to use the representation of Command in lets say output :: Coroutine r u d ()
11:50:27 <__monty__> iqubic: Not having coroutines built-in doesn't mean there's no support. And this is about a coding exercise so both those things aren't relevant.
11:50:47 <iqubic> Ah. I see. I literally just joined
11:51:12 <iqubic> Also, that coroutine looks a lot like a continuation to me.
11:52:13 <iqubic> This just looks like a large amount of wrappers around what is essentially just a ContT.
11:52:54 <phaul> not quite
11:53:35 <iqubic> Why not?
11:53:41 <phaul> if you replace `a` in Cont r a with that crazy type it would try to unify Command r u d a with a
11:55:13 <[exa]> iqubic: it has extra semantics on patternmatching the done/in/out, but yeah I guess it would be simpler to build on ContT
11:55:31 <[exa]> phaul: rename variables before substituing them?
11:55:59 <[exa]> phaul: btw the parameter 'a' needs to stay there so that it's still a monad
11:58:26 <__monty__> phaul: Looks fine to me so far. My suppress is a little different but everything else in my solution is fairly similar.
11:58:48 <phaul> that's the thing, I don't know how to handle the different cases of Command in the monadic bind and what the cases mean around line 35
11:59:15 <phaul> I have 0 intuition of this just trying to make it type check
12:00:04 <phaul> Does monad bind mean that m a >>= a -> mb, inputs and outputs are ignored in m a , and it was aborting with a and now we abort with b?
12:01:18 <phaul> or they were run and but still it was abort at the end with a and now we abort with b bu somehow the leftover outputs of m a should be fed into m b? 
12:04:41 <Xyb3rc4t> Hi there
12:04:55 <__monty__> I think it's just chaining, no aborting.
12:06:32 <zincy_> Can you have an Eq operation without a Bool type in a language?
12:06:45 <zincy_> It doesn't make any sense does it?
12:07:04 <__monty__> It does in dependently typed languages.
12:07:47 <phaul> My understanding is that >>> chains with output fed into input ( with somehow tied up with In | Out data constructors, but I don't know how, and my speculation was that Done "aborts" with a
12:07:51 <tdammers> you could implement Eq in continuation-passing style
12:08:26 <zincy_> __monty__: Why so?
12:08:31 <tdammers> class Eq a where { equals :: b -> b -> a -> a -> b }
12:08:47 <pinkunicorn> bgamari: I tried to delete my GHC fork but it failed with the following message: (https://gitlab.haskell.org/snippets/1431). Is there a way to fix this? Now I don't want to delete it.
12:09:17 <__monty__> zincy: ≡ :: *; refl :: a -> a ≡ a is a very common type in dependently typed languages.
12:09:37 <iqubic> What's the difference between IORef, MVar, TVar, and STM?
12:09:41 <zincy_> tdammers: What would the function tell you if two things are equal without Bool
12:09:47 <iqubic> I'm trying to learn about threading in Haskell.
12:10:05 <zincy_> iqubic: STM is a monad in which you can operate on TVars .. I think
12:10:09 <__monty__> zincy_: The refl constructor gives you a proof that any thing is itself : )
12:10:10 <bgamari> pinkunicorn, very interesting
12:10:14 <tdammers> zincy_: whatever you want it to - if the two a's are equal, it gives you the first argument, if not, the second
12:10:22 <__monty__> zincy_: It's more useful than it sounds.
12:10:35 <zincy_> Does refl mean reflection?
12:10:39 <__monty__> Yes.
12:11:09 <iqubic> So it's a proof of the reflexive property.
12:11:13 <bgamari> pinkunicorn, I'm looking into it
12:11:22 <iqubic> It's like an isomorphism.
12:11:46 <zincy_> Whats an isomorphism?
12:11:52 <iqubic> Actually it *IS* an isomorphism.
12:12:05 <zincy_> Same shape?
12:12:38 <iqubic> zincy_: An isomorphism is a function of the type "a -> a"
12:13:00 <iqubic> Well, not that, but...
12:15:22 <iqubic> an isomorphism is a pair of functions "to :: a -> b" and "from :: b -> a" which satisfy the following: "forall x. (to (from x)) = x = (from (to x))"
12:16:04 <iqubic> Basically it states that the two types `a' and `b' have the same shape. I. E. you can convert from one to the other and back without loss of information.
12:20:02 <phaul> __monty__: could you check, in your solution did you have to split case for >>= on the data constructors of Command? I don't see how it typechecks otherwise. But that;s where this thing is different from a Cont in my understanding...
12:20:59 <__monty__> phaul: It's a different kind of composition though. (>>>) composes a bit like (.) but for coroutines, while (>>=) runs one when the other finishes.
12:21:54 <phaul> ok. makes sense
12:22:26 <phaul> and you have chains of (>>> .... >>>) built up put together with >>= on a higher level?
12:22:29 <__monty__> phaul: I did do case analysis, yes.
12:23:23 <phaul> like (a0 >>> a1 >>> ... an) >>= (b0 >>> b1 >>> ... bn) ?
12:24:25 <__monty__> Not necessarily. Just depends on which kind of composition you want/need.
12:24:34 <zincy_> iqubic: Ah thanks
12:25:08 <phaul> ok. I go and spend some more time with this. Thanks.
12:26:02 <dmwit> zincy_: You could imagine an equality operation that returns either a certificate that its two arguments are indeed identical, or else an observation you can make that distinguishes them.
12:26:41 <dmwit> You would need data types for certificates, and data types for observations, but not *necessarily* a Bool anywhere.
12:27:15 <zincy_> That makes sense
12:28:10 <zincy_> So any distinguishing information suffices to say whether or not two things are equal
12:28:20 <zincy_> For example C with 1 or 0
12:28:29 <dmwit> Well. Any distinguishing information suffices to say two things are not equal. =)
12:29:08 <zincy_> :)
12:30:24 <dmwit> (The negation is "(showing that there cannot be any distinguishing information) suffices to say (two things are equal)".)
12:33:44 <zincy_> I was talking about distinguishing information in the result of the Eq operation
12:34:12 <zincy_> As in you could say return an odd number for true and an even one for false
12:35:07 <dmwit> Well, you certainly *could*. But that particular plan just sounds like "we've chosen some weird and bad implementation details for our Bool type" to me. =P
12:35:55 <dmwit> I think people here were trying to propose interesting answers that (==) could give that have either more or less than two usefully-distinguishable inhabitants.
12:36:50 <zincy_> Ah right
12:36:56 <dmwit> e.g. in my proposal, what would normally be a False answer would come along with extra information about *why* you got a False answer, and you could potentially use that for something useful down the line.
12:37:18 <zincy_> I somehow missed that but interesting
12:37:34 <dmwit> (For example, if this is the result of a test case, you could maybe show the answer the subterms that didn't match to highlight what went wrong with the test.)
12:37:41 <zincy_> Yeah
12:37:46 <dmwit> s/answer/user/ yikes
12:38:08 <monochrom> Recall that C and Unix have both chosen to use 0 and non-0 for boolean, and they have chosen opposite conventions.
12:38:44 <dmwit> Or in __monty__'s answer the True answer would come along with a proof that you could use, e.g. in a rewrite system, to show that other things are equal.
12:38:45 <monochrom> This is one of the millions of things that go wrong with "cunning" encodings.
12:38:52 <csaurus> Is there a valid way to do something like this with fused-effects? 
12:38:53 <csaurus> example4 :: (Carrier sig m, Member (Reader String) sig) => m () -> IO ()
12:38:53 <csaurus> example4 m = runM . runReader "hello" $ m
12:39:14 <csaurus> Typed holes suggest an Eff type, but I was wondering if there's a constraint based way to do it
12:40:28 <dmwit> csaurus++ for asking a well-formulated question
12:40:41 <dmwit> (No idea what the answer is, though. I've never heard of fused-effects before.)
12:40:52 <jgt> can someone please remind me: how do I specify the sort order of the constructors in a sum type?
12:41:07 <jgt> do I just sort them manually and then derive enum?
12:41:14 <dmwit> jgt: By writing an Ord instance. The derived Ord instance uses the order the constructors appear in your data declaration.
12:41:33 <jgt> ah, ok. So it works that way by default. Thanks.
12:43:51 <csaurus> dmwit: thanks, I will keep digging
12:58:46 <tsahyt> has someone here used haskell-gi to generate bindings to a library that isn't already covered in the gi-* ecosystem?
13:22:11 <infinisil> Very interesting.. https://www.reddit.com/r/haskell/comments/blr8op/colog_logging_library_with_polysemy_for/
13:26:46 <djanatyn> function composition is a function: (b -> c) -> (a -> b) -> a -> c
13:26:56 <djanatyn> are there circumstances where we would want to apply function composition to itself? like, this type doesn't seem too useful to me: (.) (.) :: (a1 -> b -> c) -> a1 -> (a2 -> b) -> a2 -> c
13:27:48 <Solonarv> but this one is useful:
13:27:48 <Solonarv> :t (.) (.) (.)
13:27:49 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
13:28:06 <Solonarv> you can also write that as (.).(.)
13:28:35 <djanatyn> that's cute
13:29:41 <Solonarv> and of course: (.).(.) = \f g x y -> f (g x y)
13:29:42 <djanatyn> :t iterate (.)
13:29:43 <lambdabot> error:
13:29:43 <lambdabot>     • Occurs check: cannot construct the infinite type: c ~ a -> c
13:29:43 <lambdabot>       Expected type: ((a -> b) -> a -> c) -> (a -> b) -> a -> c
13:29:56 <Solonarv> that doesn't type-check, yeah :P
13:30:21 <Solonarv> % :set -XTemplateHaskell
13:30:21 <yahb> Solonarv: 
13:31:13 <Solonarv> % composes 1 = [| (.) |]; composes n = [| (.) $(composes (n-1)) |]
13:31:14 <yahb> Solonarv: 
13:31:30 <Solonarv> % :t $(composes 3)
13:31:31 <yahb> Solonarv: (a1 -> a2 -> b -> c) -> a1 -> a2 -> (a3 -> b) -> a3 -> c
13:31:43 <Solonarv> % :t $(composes 2)
13:31:43 <yahb> Solonarv: (a1 -> b -> c) -> a1 -> (a2 -> b) -> a2 -> c
13:31:48 <Solonarv> hehe :D
13:31:55 <djanatyn> :) 
13:31:56 <Solonarv> whoops
13:32:05 <Solonarv> % composes 1 = [| (.) |]; composes n = [| $(composes (n-1)) (.) |]
13:32:05 <yahb> Solonarv: 
13:32:10 <Solonarv> % :t $(composes 2)
13:32:10 <yahb> Solonarv: (a1 -> b -> c) -> a1 -> (a2 -> b) -> a2 -> c
13:32:18 <Solonarv> % :t $(composes 3)
13:32:18 <yahb> Solonarv: (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
13:32:26 <Solonarv> there we go ;)
13:32:58 <Solonarv> template haskell looks quite pleasant when you don't have to muck around with the AST directly, eh
13:34:48 <djanatyn> more pleasant, definitely
13:53:00 <reallyme1orable> Where in the reflex-dom  internals  can I get the IP address from a request?
14:01:28 <Cale> reallyme1orable: what request?
14:02:35 <rcat> anyone that has experience using the RIO prelude, I'm having trouble defining my App type to be an instance of HasStateRef :/, kinda of a silly question...
14:04:02 <rcat> ops, nevermind, i realized i wasn't using `newSomeRef' at the right place :)
14:38:02 <p53> hello, how can you extend a long expression over several lines?
14:38:09 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
14:38:09 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
14:38:10 <p53> instance Num Quadrupel where
14:38:10 <p53> 	(Quadrupel a1 a2 a3 a4) + (Quadrupel b1 b2 b3 b4) = Quadrupel (a1 + b1) (a2 + b2) (a3 + b3) (a4 + b4)
14:40:41 <boj> p53: sure, hit enter after the =
14:40:43 <glguy> p53: Just make sure that it is indented more than the first ( there
14:40:48 <glguy> p53: And don't use tabs
14:41:03 <rocket_man> Is it possible to do IO in a pure function? I want to print an error on invalid input but keep going. I get a type error when I try, do I have to use a monad or something or is it just not possible? code: https://gist.github.com/jyn514/bcd6fa75122686069d00675d9e27554b
14:41:18 <boj> rocket_man: no, that would defeat the purpose of a pure function
14:41:29 <boj> rocket_man: you may want to look at Debug.Trace for debugging purposes though
14:42:13 <p53> Ah ok. so simple. Why not tabs? i find spaces to indentation awful and unprofessional.
14:42:14 <rocket_man> I don't want it for debugging, I want this to be user facing
14:43:00 <rocket_man> maybe I could return information about where the error was and do the IO in main
14:43:20 <boj> rocket_man: yep, there you go
14:44:02 <rocket_man> :) thanks
14:54:42 <marnold_> when i run any `stack` commands, my terminal just hangs without showing anything until i ctrl-c -- anybody know how to fix? I've tried reinstalling stack multiple times from every source I can think of. brew gets the farthest, but it hangs at the "configuring GHC..." step :( 
14:55:16 <glguy> p53: In Haskell code, where indentation matters, we avoid tabs. If you have them in your editor you must make sure your editor has tabstops set to 8
14:56:08 <marnold_> I'm on macos 10.14.4 
14:58:08 <p53> mh why?  I even configured the compiler to disable this annoying warning on tabs XD
14:59:40 <monochrom> I would think that's like saying "I don't have a fire alarm in my house, therefore there won't be fire."
14:59:40 <reallymemorable> I have a type that takes 6 constructors and I want to just pull out the last one
14:59:44 <reallymemorable> How would I approach this?
15:00:02 <reallymemorable> MyType val1 val2 val3 val4 val5 val6
15:00:14 <reallymemorable> I want to write something that just grabs val6 from MyType
15:00:30 <monochrom> Do you have actual code to show?
15:00:53 <reallymemorable> (Employment True "Thanos" (Address "555 Apple Road" (Just "Unit Six") "San Francisco" "CA" "33221" "USA" (Just "321456")) "Doctor" (PhoneNumber "6668882233") (fromIntegral 400000))
15:01:09 <monochrom> And the actual code that defines your type?
15:03:48 <zachk> reallymemorable, you might want to use records for that 
15:04:21 <reallymemorable> https://gist.github.com/reallymemorable/93341748f687a97aa2a6eb26a97c2463
15:05:07 <monochrom> Then "_field6" is already a function that gives you the 6th field.
15:05:35 <reallymemorable> so i just call Employment $ field6
15:05:37 <reallymemorable> like that?
15:05:39 <monochrom> I.e., Employment -> USDCents
15:05:47 <monochrom> No.
15:06:09 <geekosaur> theVal (Employment _ _ _ _ _ x) = x
15:06:15 <reallymemorable> got it
15:06:16 <reallymemorable> thanks
15:06:24 <reallymemorable> is there a way to invoke it by name
15:07:06 <geekosaur> p53, Haskell is indentation sensitive, and not all editors etc. agree as to what a tabstop is
15:07:56 <geekosaur> thta's what record syntax is for
15:08:07 <geekosaur> or just define your own like my example and use it
15:08:11 <reallymemorable> ok i guess i need to read more about it
15:11:09 <p53> mh, frankly, tabs are completely unequivocal: each tab corresponds to one level! and I can change the displayed length in the editor at any time and will not patronize.
15:11:28 <boj> not worth arguing
15:13:25 <monochrom> If you use tabs on GHC, real problems (not just disableable warnings) will happen when you mix tabs and spaces.
15:13:51 <monochrom> If you don't mix, if you purely use tabs, very likely no problem.
15:14:23 <monochrom> And here is where your editor can betray you. It can insert spaces behind your back.
15:14:54 <monochrom> In fact I believe that most editors default to doing that.
15:15:17 <hpc> pretty much the only ones that don't anymore are vim and notepad
15:15:59 <petercommand> emacs even mixes spaces and tabs by default in fundamental mode
15:17:15 <monochrom> No one is patronizing. Not even GHC (although I'm pretty sure it doesn't want to be anthromorphized.) But there was a time a lot of people got confused when older GHCs did not issue this warning.
15:17:44 <monochrom> So much for "better error messages". Now suddenly it means being patronizing too.
15:18:46 <hpc> this is why i make all my error messages say "0x0000000000000005"
15:18:50 <monochrom> Yes, if GHC says "Variable 'idd' not in scope, but maybe it's a typo? Do you mean 'id'?", it's patronizing.
15:19:49 <monochrom> If GHC says "your code looks like it needs multiple parameter type classes, do you want to turn on -XMultiParamTypeClasses?" it's patronizing.
15:20:45 <monochrom> Now consider that fact that no one has yet complained that the type error messages are patronizing.
15:21:59 <Solonarv> I'm sure someone somewhere has complained about that at some point
15:22:19 <Solonarv> also, p53 left already anyway :p
15:22:34 <nshepperd_> Time to add a new flag: ghc -fpolite, which makes it start each error message with an apology
15:23:10 <monochrom> That may come off as disingenious and/or passive-aggressive.
15:23:25 <glguy> Sometimes I wish GHC was so forthcoming with the extensions and just said you couldn't do certain things. Sometimes people think turning on an extension was the solution when they should have fixed their program
15:23:30 <glguy> wasn't so*
15:23:33 <monochrom> "Sorry but do you mean id?" is seen by some as even more insulting than "Do you mean id?"
15:23:49 <glguy> Did you mean id, dear?
15:24:26 <hpc> start every error message with "oh, honey"
15:24:31 <MarcelineVQ> "ghc: Maybe you meant one of these other things in scope? here's a link to a wikipedia article explaining scope, in case you need it, not saying you do. But you might."
15:24:32 * nshepperd_ . o O (-fpassive-aggressive)
15:25:06 <glguy> If you have more than a handleful of messages could GHC say "I don't even know where to begin."
15:25:20 <MarcelineVQ> "Are you sure you should be doing this?"
15:25:37 <infinisil> "Sorry, but um, I noticed your program has an error, and you've used `idd`. You see a lot of people misspell `id` as `idd`, so I thought maybe you did too? Sorry, don't mean to be rude!"
15:26:19 <MarcelineVQ> "Of course if you actally meant ldd there's a different problem here entirely so let's step back and get some perspective"
15:26:27 <glguy> More enlightened programming languages just assume you really did know what you were doing and wait until the last moment to let you know at runtime
15:26:56 <hpc> perl achieves maximum enlightenment by trusting you even after an error has occurred
15:27:03 <infinisil> glguy: GHC should automatically define symbols as undefined if they aren't in scope :P
15:27:04 <monochrom> haha
15:27:19 <rocket_man> aka the javascript approach
15:27:31 <koala_man> reminds me of how JavaScript didn't have an 'undefined' keyword. it was just a regular variable name, and if you hadn't defined it, it would have the value of undefined
15:27:31 <glguy> "Who am I to doubt that idd won't be defined later"
15:28:14 <infinisil> glguy: Soon we'll have people patching executables at runtime, replacing the undefined idd as one that is defined
15:28:45 <hpc> infinisil: nah, just get your program popular enough with the error still there, and windows itself will patch it out
15:29:03 <hpc> you'd be shocked at how many times that has occurred
15:29:10 * nshepperd_ . o O (fgrovelling-vizier. "I tremble in your terrible presence, sire, but...")
15:29:52 <infinisil> Huh
15:31:05 <monochrom> The Windows kernel certainly has code that forgives for example Word's wrong use of the Win32 API.  There was leaked kernel source code that contains comments that swear a lot and explain it. And swear a bit more.
15:31:26 <hpc> they also fix some really obscure stuff
15:31:35 <hpc> oldnewthing talks about it
15:32:07 <hpc> if it was me on the windows team, i'd be extra hard on the apps team
15:32:26 <geekosaur> problem being the office team is the company's cash cow
15:32:34 <geekosaur> so they call the shots
15:33:21 <monochrom> Yeah I don't think the power structure there allows a mere kernel team member to be hard on other teams in any sense.
15:49:42 <orion> Hi. I'm attempting to use "upsert" from persistent on a table with a composite primary key. I am getting this error: user error (getByValue: FooTable does not have any Unique) -- What is the best way to proceed?
15:53:23 <hpc> there's no unique key for it to identify what's an update and what's an insert
15:53:53 <hpc> or there is on the table, but persistent's description of the table lacks it
15:54:42 <orion> I have a primary key, which is unique by definition.
15:54:57 <hpc> hmm
16:03:03 <hpc> does the table definition in persistent know about the primary key?
16:04:46 <orion> Yes. It's explicitly defined ("Primary foo bar").
16:05:09 <geekosaur> https://stackoverflow.com/questions/10433212/how-do-i-define-a-composite-key-in-persistent
16:06:02 <geekosaur> one of the comments seems relevant
16:26:32 <dmj`> Is there a peg grammar for objective-c? Or does someone have an alex / happy lexer / parser for it, no monadic parser combinators please
16:37:05 <nisstyre> dmj`: I somehow doubt it but you could probably convert BNF to PEG pretty easily with some minor modifications
16:37:44 <KendraV> You want to look at mе without clothes, sweetie (EXCLUSIVE FREE FOR NEXT 3 PEOPLE!!) ;-) follow the link and add me as a friend -----------> https://cutt.ly/3tYwHa ♥
16:43:59 <rotaerk_> yes, that's precisely what I come to #haskell for
16:44:18 <geekosaur> welcome to the new wave of irc spam
16:44:22 <Axman6> Thanks Kendra, very cool
17:07:24 --- mode: ChanServ set +o dmwit
17:08:15 --- mode: dmwit set +b *!*@*/ip.107.150.30.118
17:08:23 --- mode: dmwit set -o dmwit
17:53:29 <da_> hi, super new to haskell . Wondering how to make my Terminal (mac computer) show colors to highlight errors etc
17:53:44 <da_> i found a rainbow package but don't know how to install.
17:53:48 <da_> thanks
18:04:46 <dmj`> @package ansi-terminal
18:04:46 <lambdabot> http://hackage.haskell.org/package/ansi-terminal
18:04:51 <dmj`> da_: ^
18:05:52 <da_> thks dmj lambdabot
18:05:53 <geekosaur> shouldn't recent ghc already do so?
18:06:13 <geekosaur> (8.x)
18:12:27 <dmj`> https://www.warbyparker.com/eyeglasses/men/haskell/crystal new haskell eyewear is out
18:14:31 <sm> huh.. needs more logo
18:36:00 <Zemyla> What's the name of the transformation that turns a commutative monoid (M, +, 0) to (M x M, *, (0, 0), I)/~ where (a, b) * (c, d) = (a * c, b * d), I(a, b) = (b, a), and (a, b) ~ (c, d) iff a * d = b * c?
18:36:26 <Zemyla> It turns the natural numbers with addition into the integers with addition, for instance.
18:38:18 <Zemyla> I think ~ is actually a * c = b * d.
18:41:07 <jle`> i think you mean (a, b) * (c, d) = (a + c, b + d) and (a, b) ~ (c, d) when a + d = b + c ?
18:47:43 <jusss> about this <>, what it's used for
18:48:13 <jusss> or how it get a -> m b
18:54:08 <JappleAck> jusss: in which cases it gets a -> m b?
18:54:27 <jusss> JappleAck: >>=
18:54:44 <JappleAck> jusss: it's from Semigroup or Monoid, usually for concatenation
18:54:56 <JappleAck> > "foo" <> "bar"
18:54:58 <lambdabot>  "foobar"
18:55:44 <JappleAck> > [1,2,3] <> [4,5,6]
18:55:46 <lambdabot>  [1,2,3,4,5,6]
18:57:11 <JappleAck> while ++ is only works with lists <> works with everything which implements Semigroup/Monoid
18:58:22 <JappleAck> also with wrapped Monoids/Semigroups:
18:58:29 <JappleAck> > Just "foo" <> Just "bar"
18:58:31 <lambdabot>  Just "foobar"
18:59:25 <JappleAck> jusss: could you show some example of "how it get a -> m b"?
18:59:49 * geekosaur guesses they've been confused by that CT joke
18:59:54 <geekosaur> which isn't talking about this Monoid
19:02:49 <monochrom> I wouldn't worry about that monoidal category statement.
19:45:17 <jusss> JappleAck: is there a relationship between <> and unit?
19:46:32 <jusss> return :: a -> m a
19:46:41 <jusss> (<>) :: Semigroup a => a -> a -> a
19:47:37 <jusss> pure unit return,  join flatMap blablah, why there're so many names for same stuff
19:48:48 <MissBrunette> You want to look at mе without clothes, sweetie (EXCLUSIVE FREE FOR NEXT 3 PEOPLE!!) ;-) follow the link and add me as a friend -----------> https://cutt.ly/3tYwHa
19:50:03 <geekosaur> there is not
19:50:55 <geekosaur> and you tell me why everyone else used different names, after waiting over a decade to catch up
19:53:09 <monochrom> Hell I know for a fact that the design patterns people deliberately give different names to the same damn pattern, just because "different applications".
19:55:09 <monochrom> For example if you use it for testing it's "mock testing", if you use it for redirection it's "dependency injection", if you use it for polymorphism it's "template method".
19:56:05 <c_wraith> if you're working in Haskell, you call them "functions".  :P
19:57:47 <monochrom> Yeah!
20:03:38 <maerwald> c_wraith: huh?
20:04:12 <monochrom> hahaha
20:06:59 <jackdk> claim: design patterns are standardised encodings of ideas a language can't express natively, but are "close" enough that the encoding doesn't have that large a blowout factor. So for haskell, something like singletons would fit the bill
20:22:42 <c_wraith> maerwald, all of the patterns monochrom mentioned are easily replicated with partial application of curried functions in Haskell.
20:32:25 <maerwald> jackdk: totally disagree
20:32:46 <maerwald> it's just the design patterns are fundamentally different per paradigm
21:04:10 <glguy> maerwald: Any chance ghcup knows about WSL and getting a version with --disable-large-address-space?
21:08:39 <glguy> or is that even still necessary?
21:11:20 <c_wraith> it's still necessary until wsl2 is common
21:11:27 <maerwald> glguy: you mean a GHC compiled with --disable-large-address-space?
21:12:36 <maerwald> I don't think current OS detection would know it's on wsl
21:13:04 <maerwald> https://github.com/haskell/ghcup/blob/master/ghcup#L610-L744
21:14:55 <maerwald> https://stackoverflow.com/questions/38859145/detect-ubuntu-on-windows-vs-native-ubuntu-from-bash-script
21:15:08 <maerwald> that could be a hack :P
21:15:25 <maerwald> but then we still don't have tarballs 
21:38:10 <fen> can anyone read this? https://gist.github.com/fen-hs/095c58f23cb9e0bda757495fc97645e8
21:38:43 <fen> dont worry about all the type level functions in the import
21:39:14 <maerwald> what language is that?
21:44:08 <Axman6> fen: I believe I can read most of it, understand on the otherhand, perhaps less so
21:44:19 <fen> ok
21:44:32 <Axman6> thought I'm only a little way in
21:44:34 <fen> yeah, that would require reading some of the type level functions
21:45:18 <fen> you know its a good abstraction when it takes a week to write the type
21:45:25 <Axman6> What's the high level of what you're doing? Nest appears to be a list of nested functors, but I'm not sure what that buys you
21:45:31 <Axman6> amen
21:46:10 <fen> right, yeah nest is at the heart of it. its just like folding with compose
21:47:09 <Axman6> "Selectction"
21:47:30 <fen> selection is like "one of the values of this list"
21:47:38 <Axman6> yeah
21:47:42 <fen> its an extensible sum datatype
21:47:46 <Axman6> the spelling is odd though =)
21:48:01 <fen> sorry, it compiles!
21:48:13 <Axman6> words are only for humans anyway
21:48:17 <fen> what its trying to express is that when a nested state produces values it fails at some depth
21:48:35 <fen> so it has a choice over which depth it fails at
21:48:48 <fen> it can be any of those, so its a selection
21:49:02 <Axman6> yep, much like how indexing into a type level specified length vector works
21:49:48 <fen> and then, to construct the type of the state at that level, it says that the "lowest succeeding state" has a parameter around the `a' value
21:50:09 <fen> where this is the nested set of all the "fail" cases below the lowest succeding case
21:50:26 <fen> in words thats pretty simple, but as a type its hellish 
21:51:16 <fen> not even sure if this is the right way to express it - or if it works! 
21:51:32 <fen> 2nd attempt... thought it could do with some input
21:53:44 <fen> oh yeah, and the top right hand side, the final fail case where the upper state fails to return, and the unfold of the nested containers is complete
21:53:51 <Axman6> did you see this a couple of weeks ago? https://www.reddit.com/r/haskell/comments/bg9tyn/video_polysemy_chasing_performance_in_free_monads/ feels relevant
21:54:31 <fen> brarg, its not ready for performance yet
21:54:39 <fen> that would require a vertical zipper
21:54:53 <fen> so that it descends to the lowest case
21:55:26 <fen> ie, so it doesnt need to repeat the "get" calculation at each level as it nyams into the head of each nesting
21:55:47 <fen> will do that after
21:57:12 <Axman6> I thought you might find some of the techniques useful
21:57:14 <fen> freeer
21:57:20 <fen> yeah, maybe at some point
21:58:22 <fen> or was there some other idea?
21:59:10 <fen> not really sure the difficulties in producing this type have a name...
21:59:11 <Axman6> how things like generalised sums can be encoded
21:59:22 <fen> hmm
21:59:51 <fen> well there are 2 versions 
21:59:57 <fen> presented in the paste
22:00:07 <fen> not sure if either works as expected
22:00:18 <fen> do they use a different / better way?
22:01:28 <fen> really at the moment it would be easiest just to assume any encoding would do
22:02:12 <fen> the problem is more to do with if the type expresses what its supposed to, and if the description of a nested state is well devised
22:05:07 <fen> the previous version used more type families, but here there are singleton GADTs instead
22:05:29 <fen> not used to the style, maybe it does something unexpected
22:06:54 <Axman6> I believe I understand what's going on, but not sure about the why - do you have an example of the intended use? I'm also not sure what linear and stack are supposed to mean here
22:07:56 <fen> maybe it would be helpful to focus instead on this understanding
22:08:55 <fen> linear and stack differ only in the "fail" case
22:09:34 <fen> where stacks like [] fail on [] :: [a], and linear things like nonempty fail on End (a :: a) :: Nonempty a 
22:10:26 <fen> so when you do the nesting of fails below the lowest success, it will truncate at the topmost Empty
22:11:26 <fen> the type annotation should be able to reconstruct the nested set of containers when its used as the input to "set"
22:11:45 <fen> based on the depth of this nesting, compared to the total list of tags
22:12:17 <oni-on-ion> its spinning in circles 
22:14:30 <fen> very briefly the inteded use, and corresponding test case is to unfold and refold (hylo get set) a set of nested containers
23:18:42 <dminuoso> @tell Cale sorry I dropped out on the discussion about Pi types, life being life I guess. So in what sense can you use a Sigma type? I mean let's say you have some `(a, b) : Sigma (x : A). B(x)` where `a : A` and `b : B(a)`, how can you consume this?
23:18:42 <lambdabot> Consider it noted.
23:22:43 <dminuoso> I mean I have a motivating example on how to produce one, for example some: `filter : forall a. (a -> Bool) -> Vec n a -> (p, Vec p a)`, but where would the sigma quantifier go? Would this be some `forall a. (a -> Bool) -> Vec n a -> (Sigma (p : Nat). Vec p a)?
23:27:48 <jle`> dminuoso: yeah, that's basically a dependent tuple
23:28:14 <jle`> it would be (exists p. Vec p a), or more usefully (exists p. KnownNat p *> Vec p a)
23:28:57 <dminuoso> jle`: What does *> denote here?
23:29:09 <jle`> idris you'd write that as (p : Nat ** Vec p a)
23:29:27 <jle`> dminuoso: it's like => for existentials, i'm not sure why it was chosen necessarily heh
23:29:40 <simon> on the subject of Stack and GHC, it seems that my default stack GHC is $(stack runghc -- --version) == 8.0.2. this is in a directory without a stack.yaml or a .cabal file.
23:29:55 <simon> how do I tell Stack to use a later GHC than that by default?
23:30:06 <jle`> dminuoso: but yeah at this point you can just do the continuation transformation directly on (exists p. Vec p a), which is pretty mechanical
23:30:36 <jle`> it turns into (forall p. KnownNat p => Vec p a -> r) -> r
23:31:03 <jle`> so filter :: forall a n r. (a -> Bool) -> Vec n a -> (forall p. KnownNat p => Vec p a -> r) -> r
23:31:19 <dminuoso> jle`: Wait wait. When I was talking with Cale we used Pi and Sigma as different quantifiers.
23:31:37 <dminuoso> jle`: It was non-Haskell. ;)
23:31:39 <simon> https://github.com/commercialhaskell/stack/blob/master/doc/faq.md#what-version-of-ghc-is-used-when-i-run-something-like-stack-ghci suggests that I can call $(stack config set resolver lts), but how do I see what it's currently got?
23:31:41 <jle`> ah yeah i see
23:31:50 <jle`> in that case your type signature makes sense :)
23:32:18 <jle`> actually Haskell has a sigma type, from singletons
23:32:40 <jle`> the only tricky thing is that there are no type level lambdas
23:32:44 <dminuoso> jle`: Cale mentioned DSum, actually.
23:32:48 <simon> ah, $(stack config set resolver lts) just updates to the latest lts-13.20. :) that's great.
23:33:05 <jle`> so either you have to explicitly name your relationship, or build it point-free out of combinators
23:33:24 <jle`> in singletons, sigma is:
23:33:57 <jle`> data Sigma k p = exists x. Sing (x :: k) :&: (p @@ x)
23:34:24 <jle`> so roughly your Sigma (p : Nat). Vec p a would be `Sigma Nat (Flip Vec a)`
23:34:31 <jle`> with singletons sigma
23:34:44 <jle`> which i think isn't altogether too bad :)
23:42:20 <zincy> If you are writing a DSL for a lambda calculus based language is there a better way of detecting type errors for the first argument here than pattern matching - functions like IfThenElse :: Value -> Value -> Value -> Value
23:43:13 <Axman6> typed lambda calculus? otherwise it should always be well typed; everything's a function
23:43:59 <zincy> https://github.com/therewillbecode/functional-interpreter/blob/master/src/Interpreter.hs
23:44:15 <jle`> zincy: that's one way of doing it, but maybe with Maybe Value as a result too in case of a type error 
23:44:16 <zincy> Last function in the src file
23:44:34 <zincy> Yeah that might be better or an Either
23:45:05 <jle`> yeah, it looks like you already do that for addition and multiplication and stuff
23:45:43 <jle`> all of the infrastructure is already in place :)
23:46:25 <zincy> :)
23:46:34 <zincy> Is Value the type of my DSL types
23:46:34 <jle`> also be aware that the semantics of your if/then/else is kind of shaky
23:46:39 <zincy> How so?
23:46:54 <jle`> since you evaluate both results no matter what the bool is
23:47:16 <jle`> but if/then/else usually has the semantics/intuition of control flow
23:47:29 <jle`> although in this case the only 'effect' is potentially Left-ing
23:47:51 <zincy> I though that due to Haskells laziness only one expression would be evaluated
23:48:05 <freeside> you're passing Values, not Expressions
23:48:27 <jle`> the actual 'result' won't be evaluated, but between lines 88 to 90, it needs to know if they return Left or Right
23:48:36 <zincy> So the Values are already fully evaluated
23:48:37 <jle`> so it knows whether or not to short-circuit
23:48:49 <zincy> is it better to pass in expressions and then evaluate them inside the ifThenElse
23:49:04 <jle`> so it'll fully traverse both sides of the trees to ensure that there are no Left's, which requires touching the entire tree
23:49:39 <jle`> well, right now, the only way something can be Left here is if there's a type error, so this is basically saying you typecheck both sides before continuing, which is not the end of the world
23:50:02 <jle`> but if you do later decide to add effects to your interpreter, it'll execute the effects on both branches before continuing in that case
23:51:12 <jle`> hm, i guess right now it'll also "break" on something like `if True then 1 else (unfinite tree that will take infinitely long time to typecheck)`
23:51:22 <zincy> So what is the altenative? Pass in Exp not Values?
23:51:40 <jle`> yeah, choose which one to 'evaluate' based on what the bool ends up being
23:51:56 <zincy> Would that stop the infinite tree issue
23:52:06 <jle`> it would
23:52:19 <jle`> but also most languages don't really support infinite trees like that anyway so it's kind of a non-issue
23:52:31 <zincy> Wouldn't everything break on that kind of issue apart from lazy langs
23:52:53 <zincy> By everything I mean any strict language
23:53:27 <jle`> i think typically when we talk about languages like this, infinite trees aren't really a part of the discussion
23:53:48 <jle`> hm, actually maybe homoiconic languages like lisp have to consider this
23:54:02 <zincy> So doing the evaluation inside the ifThenElse means that the return value is inside my eval monad stack
23:54:07 <zincy> Is that ok?
23:54:21 <zincy> Homoiconic = code is data?
23:54:42 <jle`> yeah, it means that 'if/then/else' has the same context as add/mul/etc.
23:54:51 <zincy> Context?
23:55:03 <jle`> the 'context' of the evaluation; your monad stack
23:55:26 <zincy> ok
23:55:42 <jle`> zincy: by homoiconic i'm saying that lisp programs can directly manipulate the syntax tree on the fly
23:55:44 <zincy> Actually add and mul would have a different context then
23:55:51 <zincy> they are in just an Either
23:56:04 <jle`> they can programatically generate AST's, basically
23:56:27 <zincy> jle`: That is the power of lisp macros right you can write AST modifying code?
23:56:40 <jle`> i'm saying that normally "infinite AST"s aren't an issue because a parser/grammar for a language typically will not return an infinite ADT
23:56:48 <jle`> * infinite AST, from a finite source code file
23:56:58 <zincy> ah ok
23:57:08 <jle`> if you parse a finite javascript file into an AST, your AST is probably not going to be infinite if your parser isn't broken 
23:57:36 <jle`> but in something like lisp, where you can modify the AST itself within the program, it might be conceivable to end up with an infinite AST
23:58:24 <jle`> i guess what i'm saying here is that the code as you have it now isn't probably going to show problems in what gets evaluated in the end, but it might if you start adding other effects to your evaluator
23:58:57 <jle`> and, it might be surprising to you that the if/then/else as you had written it before, traverses the entire tree on both cases before it can return anything, even though haskell is 'lazy'
23:59:16 <jle`> the infinite tree stuff probably is a non-issue :)
23:59:57 <zincy> Yes that did surprise me
