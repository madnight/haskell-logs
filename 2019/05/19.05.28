00:38:05 <Social-Reject> hello. How can I make this work? suzamen :: Maybe String -> Maybe String -> Maybe String.
00:38:46 <jackdk> that type has many inhabitants. what are you trying to do, and what have you already tried? use a pastebin if you have a lot of code to share
00:38:51 <Solonarv> Social-Reject: here's an unhelpful answer: suzamen _ _ = Nothing
00:39:26 <Solonarv> as jackdk said, there are many possible functions with that type; which one do you want>
00:39:47 <Social-Reject> I tried suzamen (Just x) (Just y) = Just x, but Im not sure how it returns a value
00:40:20 <iqubic> That should work. You might get some warnings about incomplete pattern matches, but that should work.
00:40:36 <Solonarv> ...for a very lenient definition of "work"
00:40:50 <Solonarv> it will crash if you pass in Nothing as either argument
00:41:03 <Solonarv> I certainly wouldn't call that "it works"
00:41:23 <iqubic> s/work/compile/
00:42:52 <Social-Reject> i'm trying to concat two strings, with two maybe`s, so (Just x) (Just y) should return (Just x (++) y), but I'm not sure what I'm doing wrong
00:43:09 <Solonarv> ah, now we can help you!
00:43:56 <iqubic> If exactly one value is a Maybe, return the other.
00:44:16 <iqubic> I'm too tired to think.
00:44:44 <sean`> preflex: karma iqubic
00:45:13 <sean`> @help
00:45:13 <Solonarv> so we can already write down what you said:
00:45:13 <Solonarv> suzamen (Just x) (Just y) = Just (x ++ y)
00:45:13 <Solonarv> ^- this is the same as your (slightly malformed) sentence "(Just x) (Just y) should return (Just x (++) y)"
00:45:13 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:45:25 <iqubic> Also, I know this isn't the expected answer, but: "suzamen = liftA2 (++)"
00:45:36 <Solonarv> but you still need to specify what should happen if one or both inputs are Nothing
00:45:39 <iqubic> But don't use that if you are learning.
00:45:45 <Solonarv> iqubic: perhaps that isn't even the desired behavior
00:45:49 <iqubic> I know.
00:46:05 <iqubic> I don't know what should happen if one of the inputs is Nothing.
00:46:10 <iqubic> one or both.
00:46:19 <Solonarv> Social-Reject: so, what should happen in that case?
00:48:13 <Solonarv> I have to go now, but hopefully someone can help you finish this
00:48:18 <sean`> ??
00:48:35 <sean`> preflex: list
00:48:49 <Social-Reject> thank you for help 
00:48:50 <Social-Reject> : )
00:48:58 <sean`> @help
00:48:58 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:49:15 <iqubic> Social-Reject: you haven't finished writing the function.
00:49:22 <sean`> @help type
00:49:22 <lambdabot> type <expr>. Return the type of a value
00:49:39 <iqubic> you need to specify what should happen when you have Nothing as an input.
00:50:05 <sean`> preflex: help list
00:50:32 <sean`> preflex: list
01:15:51 * hackage reason-export 0.1.1.0 - Generate Reason types from Haskell  https://hackage.haskell.org/package/reason-export-0.1.1.0 (AndreiBarbu)
01:18:51 * hackage servant-reason 0.1.1.0 - Derive Reason types to interact with a Haskell backend  https://hackage.haskell.org/package/servant-reason-0.1.1.0 (AndreiBarbu)
01:20:51 * hackage proto-lens 0.5.0.1 - A lens-based implementation of protocol buffers in Haskell.  https://hackage.haskell.org/package/proto-lens-0.5.0.1 (JudahJacobson)
01:44:09 <mreh> has anyone successfully enumerated dates in Haskell. I know Day is an Enum, but I need to be able to enumerate midnight for every day in any timezone (ideally) and map that onto my server's local time.
01:45:15 <mreh> it's not just timezone, it's for any location really, because some locations have changing timezones
01:45:47 <phadej> "all midnights for every day in any timezone" is more often than each hour?
01:46:06 <Taneb> phadej: there's a few half-timezones
01:46:24 <phadej> Taneb: "more often than each hour"
01:46:52 <Taneb> phadej: the way you phrased that it sounded like it would be surprising to you
01:47:23 <phadej> not everyone's English is perfect
01:47:27 <phadej> especially mine isn't.
01:47:39 <Taneb> Ah, sorry
01:47:57 <Taneb> Text isn't the best way to transmit thoughts
01:50:16 <phadej> anyway, why enumerate each midnight, if it will end up "more often than each hour"
01:51:18 <Taneb> mreh: what are you actually trying to achieve here?
01:51:39 <mreh> phadej: I just want every midnight between two dates for a the particular location of a user
01:51:58 <mreh> s/a the/the/
01:53:17 <phadej> so for a given timezone
01:53:38 <mreh> phadej: yes
01:54:24 <phadej> e.g. https://hackage.haskell.org/package/tz-0.1.3.2/docs/Data-Time-Zones.html has localTimeToUTCFull :: TZ -> LocalTime -> LocalToUTCResult
01:54:49 <phadej> so you can enumerate LocalTime midnights and change them to UTC
01:56:40 <zincy> Is it better to use Lens to unwrap a value inside a data constructor or just a simple pattern matching function to do so?
01:56:52 <zincy> newtype Foo = Foo Int
01:56:56 <mreh> phadej: interesting...
01:57:06 <Taneb> zincy: if it's just that then pattern matching is cleaner
01:57:12 <zincy> thanks
01:57:24 <Taneb> But for more complicated things, especially with updates and nesting, lenses become better
01:58:16 <dminuoso> zincy: Depending on the situation you could also use coerce or pass the wrapped newtypes instead.
01:59:13 <zincy> dminuoso: Cheers!
01:59:26 <zincy> Appreciate the help
01:59:55 <mreh> phadej: this could work, but I would need to know the timezone for each date for the given location
02:00:00 <zincy> Another question ... When should you encode invariants at the type level versus the value level?
02:00:20 <mreh> I read about this: http://hackage.haskell.org/package/timezone-olson
02:00:26 <mreh> so maybe I need a timezone database
02:00:30 <zincy> DataKinds, Nats etc
02:00:59 <yogeshagr> Hi Guys! does anyone have a link to the haskell vs scala meme ;) I saw it some time back on the internet, where one guy is inventing Haskell and the other guys were copying from him and that's how scala came up. I found that image very inspiring. Would be good if someone could share it if they have :)
02:02:37 <dminuoso> zincy: Whenever you want your type system to enforce those properties.
02:03:12 <zincy> dminuoso: hehe I don't know what I want maybe should just keep experimenting then
02:04:00 <dminuoso> zincy: One motivating example might be servant, where the API information lives in the type system, such that you can extract the API into a seperate package and have multiple project depend on the same API set.
02:04:13 <zincy> One thing that confused me with dependent type related stuff is that the type errors become value errors anyway so why not just not bother all together?
02:04:30 <zincy> I feel I am really missing something to have this line of reasoning
02:04:55 <zincy> Do dependent types just stop you constructing functions that are nonsensical
02:04:57 <Taneb> Because you can automatically check at build time
02:05:17 <zincy> So it adds to the "checks" at build time but not runtime
02:05:33 <dminuoso> zincy: And it makes them exhaustive in some sense.
02:06:15 <dminuoso> zincy: Consider the servant example. Since the API lives in types, you get compile time guarantees that all clients and the server use the exact same API specification.
02:06:32 <dminuoso> If the server API is changed in a breaking way, all clients suddenly fail to compile. 
02:06:51 <zincy> right so the runtime safety is an indirect consequence of the fact you cannot construct nonsensical code
02:06:57 <dminuoso> Right.
02:07:08 <zincy> The indirectness is the key point maybe
02:07:09 <dminuoso> zincy: Well you still can, but you limit the amount of wrong programs.
02:07:27 <dminuoso> It's kind of the point of a type system really, to filter out bad programs as much as possible.
02:07:48 <dminuoso> (While filtering out as few good programs as possible)
02:08:32 <zincy> You can't filter out bad things happening at runtime though you can only make them less likely
02:08:46 <zincy> no
02:08:49 <zincy> that doesn't make sense
02:09:15 <dminuoso> zincy: No you can definitely ensure that *certain* properties hold at runtime with your type system.
02:09:17 <phadej> mreh: no you don't
02:09:23 <zincy> you can filter out *some* classes of bugs
02:09:24 <zincy> yeah
02:09:25 <dminuoso> Exactly.
02:09:28 <phadej> in Helsinki the timezone Is "Europe/Helsinki"
02:09:49 <dminuoso> zincy: Though I wouldn't just call it "bugs", I'd say your program has properties guaranteed by the type system.
02:09:52 <phadej> mreh: and tz / tzdata are exactly timezone database user / provider
02:10:12 <phadej> timezone-olson is another option yes (and you can still use tzdata to bundle the db)
02:10:18 <zincy> Yeah "bug" suggests an idiosyncratic issue not a property
02:10:37 <zincy> property is a stronger guarantee
02:12:12 <dminuoso> zincy: Now the presence of backdoors like unsafeCoerce lets you break properties, so in a system where backdoors exist, you no longer have proper guarantees.
02:16:51 * hackage hasql-dynamic-statements 0.2 - Toolkit for constructing Hasql statements dynamically  https://hackage.haskell.org/package/hasql-dynamic-statements-0.2 (NikitaVolkov)
02:17:35 <dminuoso> zincy: A simple example is, imagine you have some `data SanState = Sanitized | Unsanitized` and then some `data UserInput (s :: SanState) = UserInput String` and then some `obtainInput :: UserInput 'Unsanitized; sanitize :: UserInput 'Unsanitized -> 'Sanitized; storeInDb :: UserInput 'Sanitized -> IO ()`
02:17:46 <phadej> mreh: importantly "clock offset /= timezone"
02:18:05 <dminuoso> zincy: Now if you provide no other way to produce `UserInput 'Sanitized`, then all database input is by the type system guaranteed to be sanitized. Provably.
02:18:17 <dminuoso> Of course that `unsafeCoerce` lets you blatantly break that property.
02:18:51 * hackage hasql-implicits 0.1 - Toolkit for constructing Hasql statements dynamically  https://hackage.haskell.org/package/hasql-implicits-0.1 (NikitaVolkov)
02:19:28 <Solonarv> but there are ways around even this, causing unsafeCoerce to merely crash your program
02:20:21 * hackage antiope-s3 7.0.4, antiope-messages 7.0.4, antiope-dynamodb 7.0.4, antiope-optparse-applicative 7.0.4, antiope-contract 7.0.4, antiope-sns 7.0.4, antiope-sqs 7.0.4, antiope-core 7.0.4, antiope-athena 7.0.4 (arbornetworks)
02:20:23 * hackage gloss-rendering 1.13.1.1 - Gloss picture data types and rendering functions.  https://hackage.haskell.org/package/gloss-rendering-1.13.1.1 (BenLippmeier)
02:20:25 * hackage rattletrap 7.0.2, rattletrap 7.0.1, rattletrap 7.0.0 (fozworth)
02:20:27 * hackage proto-lens 0.5.0.1 - A lens-based implementation of protocol buffers in Haskell.  https://hackage.haskell.org/package/proto-lens-0.5.0.1 (JudahJacobson)
02:20:29 * hackage skylighting 0.8, skylighting-core 0.8 (JohnMacFarlane): https://qbin.io/killed-nv-37vu
02:20:30 <dminuoso> zincy: Oh and it should have been: `sanitize :: UserInput 'Unsanitized -> UserInput 'Sanitized` of course
02:20:31 * hackage nagios-config 0.1.0.0 - EDSL to specify Nagios configuration files.  https://hackage.haskell.org/package/nagios-config-0.1.0.0 (hverr)
02:20:35 * hackage hasql-implicits 0.1, hasql-dynamic-statements 0.2, hasql-cursor-transaction 0.6.4, hasql-optparse-applicative 0.3.0.4, hasql-pool 0.5.1, hasql-transaction 0.7.2, hasql 1.4, hasql-dynamic-statements 0.1.0.2, hasql-dynamic-statements 0.1.0.1 (NikitaVolkov)
02:20:39 * hackage sendfile 0.7.11.1, clckwrks-plugin-media 0.6.16.6, clckwrks-plugin-page 0.4.3.16, clckwrks 0.24.0.12, sendfile 0.7.11, reform 0.2.7.4, clckwrks-plugin-ircbot 0.6.17.5, clckwrks-cli 0.2.17.3, clckwrks 0.24.0.11, happstack-authenticate 2.3.4.16 (JeremyShaw)
02:20:41 * hackage hw-balancedparens 0.2.0.4 - Balanced parentheses  https://hackage.haskell.org/package/hw-balancedparens-0.2.0.4 (haskellworks)
02:20:43 * hackage confcrypt 0.2.3.3 -   https://hackage.haskell.org/package/confcrypt-0.2.3.3 (ChrisCoffey)
02:20:45 <Solonarv> for example you could define:
02:20:45 <Solonarv> data UserInput :: SanState -> Type where
02:20:45 <Solonarv>   UIUnsanitizied :: String -> UserInput 'Unsanitized
02:20:45 <Solonarv>   UISanitized :: String -> UserInput 'Sanitized
02:20:45 <dminuoso> Solonarv: Curious, how would you do that?
02:20:45 * hackage hasbolt-extras 0.0.0.18 - Extras for hasbolt library  https://hackage.haskell.org/package/hasbolt-extras-0.0.0.18 (ozzzzz)
02:20:47 * hackage dson 0.3.0.1 - Haskell Doge Serialized Object Notation Parser  https://hackage.haskell.org/package/dson-0.3.0.1 (lcycon)
02:20:50 * hackage nvim-hs-ghcid 2.0.0.0 - Neovim plugin that runs ghcid to update the quickfix list  https://hackage.haskell.org/package/nvim-hs-ghcid-2.0.0.0 (saep)
02:20:50 <tdammers> I don't think guarding code against malicious programmers is realistic
02:20:52 * hackage ghc-exactprint 0.6.1 - ExactPrint for GHC  https://hackage.haskell.org/package/ghc-exactprint-0.6.1 (AlanZimmerman)
02:20:53 * hackage elminator 0.2.2.1, elminator 0.2.2.0, elminator 0.2.1.0 (sras): https://qbin.io/puppy-menu-mpwo
02:20:56 * hackage haskoin-store 0.16.0 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.16.0 (xenog)
02:20:58 * hackage clisparkline 0.1.0.0 - Tiny library to pretty print sparklines onto the CLI  https://hackage.haskell.org/package/clisparkline-0.1.0.0 (bollu)
02:21:00 * hackage pointfree 1.1.1.5 - Tool for refactoring expressions into pointfree form  https://hackage.haskell.org/package/pointfree-1.1.1.5 (BenMillwood)
02:21:02 * hackage network-multicast 0.3.1, network-multicast 0.3.0 (AudreyTang): https://qbin.io/fish-found-30sv
02:21:04 * hackage Rasterific 0.7.4.4, Rasterific 0.7.4.3 (VincentBerthoux): https://qbin.io/wings-floor-4za6
02:21:06 * hackage polysemy 0.2.1.0 - Higher-order, low-boilerplate, zero-cost free monads.  https://hackage.haskell.org/package/polysemy-0.2.1.0 (isovector)
02:21:08 * hackage data-combinator-gen 0.1.0.4, data-combinator-gen 0.1.0.3, data-combinator-gen 0.1.0.2 (bolt12)
02:21:10 * hackage hledger-flow 0.12.3.0 - An hledger workflow focusing on automated statement import and classification.  https://hackage.haskell.org/package/hledger-flow-0.12.3.0 (apauley)
02:21:12 * hackage haskell-formatter 2.0.1, haskell-formatter 2.0.0 (evolutics): https://qbin.io/craps-games-g41l
02:21:14 * hackage conduit-merge 0.1.3.0 - Merge multiple sorted conduits  https://hackage.haskell.org/package/conduit-merge-0.1.3.0 (cblp)
02:21:16 * hackage systemd 2.0.0 - Systemd facilities (Socket activation, Notify)  https://hackage.haskell.org/package/systemd-2.0.0 (erebe)
02:21:18 * hackage servant-reason 0.1.1.0, reason-export 0.1.1.0, servant-reason 0.1.0.0, reason-export 0.1.0.0 (AndreiBarbu)
02:21:21 * hackage flags-applicative 0.0.4.4, flags-applicative 0.0.4.3, flags-applicative 0.0.4.2, flags-applicative 0.0.4.1, flags-applicative 0.0.4.0, flags-applicative 0.0.3.0 (mtth)
02:21:23 * hackage servant-snap 0.8.3.2, servant-snap 0.8.3.1, servant-snap 0.8.4 (imalsogreg): https://qbin.io/grande-guinea-6veo
02:21:25 * hackage sensu-run 0.6.1.1 - A tool to send command execution results to Sensu  https://hackage.haskell.org/package/sensu-run-0.6.1.1 (MitsutoshiAoe)
02:21:25 <tdammers> the purpose of type "guarantees" is usually to guard against accidents rather than malice, at least as far as the programmer is concerned
02:21:28 * hackage extensible-effects-concurrent 0.24.0 - Message passing concurrency as extensible-effect  https://hackage.haskell.org/package/extensible-effects-concurrent-0.24.0 (SvenHeyll)
02:21:30 * hackage ip2proxy 2.0.0 - IP2Proxy Haskell package for proxy detection.  https://hackage.haskell.org/package/ip2proxy-2.0.0 (ip2location)
02:21:32 * hackage SciFlow-drmaa 0.1.0, SciFlow 0.7.0 (kaizhang): https://qbin.io/drawn-hint-q4jk
02:21:53 <tdammers> and holy crap, hackage bot is on fire
02:22:20 <phadej> it had a bit of backlog to tell us, it seems
02:22:39 <dminuoso> tdammers: I guess my point is that it's still not an absolute guarantee. Ive managed to accidentally break STM in ways the type system would have prevented if I hadn't used some unsafe_ primitives..
02:22:51 <phadej> rattletrap-7.0.0 is from Sun May 26 16:47:01 UTC 2019 e.g.
02:23:06 <phadej> dminuoso: lesson here: don't use unsafe primitives
02:23:23 <Solonarv> now if you unsafeCoerce a UserInput 'Unsanitized into UserInput 'Sanitized you produce bottom, in that any function pattern-matching on it will crash
02:23:45 <Putonlalla> I thought hackage was supposed to collect updates together.
02:24:37 <dminuoso> phadej: I was just harmlessly using unsafePerformIO to create semi-global variables.. :-P
02:24:56 <dminuoso> But yeah I understand now that unsafePerformIO is unsafe for more than just one reason.
02:24:56 <phadej> dminuoso: did you {-# NOINLINE #-} them?
02:25:09 <dminuoso> phadej: Yes.
02:25:15 <dminuoso> phadej: The problem was lazyness.
02:25:21 * hackage hasql-cursor-query 0.4.4.3 - A declarative abstraction over PostgreSQL Cursor  https://hackage.haskell.org/package/hasql-cursor-query-0.4.4.3 (NikitaVolkov)
02:25:55 <phadej> dminuoso: unsafePerformIO and newTVarIO should be "safe", as it's actually mentioned in the docs
02:26:05 <phadej> unsafePerformIO and atomically will break (and that's mentioned too, iirc)
02:27:19 <dminuoso> phadej: well strictly speaking its possible to use atomically inside unsafePerformIO
02:27:31 <dminuoso> phadej: Its just that you need to force thunks outside STM, otherwise things break.
02:27:58 <dminuoso> phadej: But you are right. The warnings were there, my point is just that the type system guarantees are not mathematics level absolute and perfect guarantees.
02:28:01 <phadej> dminuoso: no, just don't
02:29:20 <phadej> every time you use unsafePerformIO you should write a 200 word comment why you think it's ok
02:29:39 <phadej> "It feels it should be safe" is only 6
02:29:52 <maerwald> I only used it for a global var in a test suite once :>
02:30:54 <dminuoso> phadej: Oh wait, I was actually using newTVarIO
02:30:59 <dminuoso> phadej: The problem was still the same. 
02:32:19 <dminuoso> phadej: https://gist.github.com/dminuoso/7d98ae6065bac89004dc2370bbae9a6d here in line 10. The bang pattern fixes the issue -> in retrospect I should probably just cleanly initialize it, but I was too lazy to refactor..
02:32:55 <phadej> that's not even a global?
02:33:53 <Solonarv> yeah, I'm confused too - why even use unsafePerformIO at all?
02:33:57 <phadej> indeed
02:34:00 <tdammers> {-# NOINLINE #-} is not a proper solution to the "I want to use unsafePerformIO so that I can have mutable globals" problem
02:34:27 <tdammers> a proper solution IMO is to rethink your design so that you don't need mutable globals
02:35:05 <Solonarv> tdammers: the best counterexample I can come up with is the http-client library's default Manager thing
02:35:22 <phadej> you really don't want use default manager
02:35:34 <phadej> it's convinient, but you really don't want it
02:35:42 <Solonarv> why specifically?
02:35:59 <Solonarv> I wasn't aware of any problems with it, but I haven't used the library much
02:36:06 <tdammers> "because it uses mutable globals", haha
02:36:19 <maerwald> tdammers: why? It's pretty convenient for test suites for example
02:36:38 <tdammers> test suites follow different rules
02:37:20 <tdammers> although it's still unclear whether that means that they should avoid mutable globals even harder, or that mutable globals are fine there
02:37:26 <tdammers> (unclear to me, that is)
02:37:44 <phadej> in tests making new manager even for every test shouldn't be a problem
02:37:50 <phadej> and will help isolate tests from each other
02:38:14 <phadej> (so dangling keep-alived connections don't mess with reproducibility of tests)
02:38:27 <tdammers> or alternatively, if you really want to reuse the same manager, hey, just make one at startup and pass it around
02:38:48 <tdammers> but yeah, the general notion with tests is to make them as dumb as possible
02:38:54 <tdammers> tests are not the place for fancy abstractions
02:49:04 <ShalokShalom> Hi there :D
02:49:25 <ShalokShalom> I think about an additional layer to the type system and welcome every suggestion: https://gist.github.com/ShalokShalom/67a8b1b071fe4197979f7dade8327e19
02:49:38 <ShalokShalom> This might turn out as an RFC in Github. 
02:52:56 <tdammers> ShalokShalom: isn't that just newtypes?
02:53:23 <ShalokShalom> idk iof that is already implemented in Haskell
02:53:25 <ShalokShalom> let me see
02:54:13 <tdammers> e.g. newtype MyString = MyString { unMyString :: String } -- now MyString is a separate type from String, but the representation is identical, and under normal circumstances, both the MyString constructor and the unMyString deconstructor compile away to nothing
02:54:41 <dminuoso> tdammers: In case of newtype, when would it ever produce code at all?
02:54:45 <ShalokShalom> No, I mean automatically
02:54:48 <ShalokShalom> Always
02:54:50 <dminuoso> ShalokShalom: Automatically when?
02:54:55 <ShalokShalom> A Newtype (ニュータイプ Nyūtaipu) is a person who has reached a new stage of human evolution in the Gundam universe. ^^
02:55:08 <ShalokShalom> dminuoso: At all build in types
02:55:14 <ShalokShalom> where type inference works
02:55:18 <Rembane> ShalokShalom: How would it be done automatically? 
02:55:28 <dminuoso> ShalokShalom: So "foo" and "bar" have different types?
02:55:34 <ShalokShalom> simply replace them on the surface by putting a layer on it with the new type
02:55:42 <dminuoso> ShalokShalom: To what end... ?
02:55:44 <ShalokShalom> no, just on the surface
02:55:55 <ShalokShalom> it gets compiled as build in type
02:56:05 <ShalokShalom> as you can read in the document :)
02:56:07 <dminuoso> ShalokShalom: I think you may be conflating the word "
02:56:14 <dminuoso> ShalokShalom: I think you may be conflating the word "type" with "runtime representation"
02:56:15 <ShalokShalom> which word?
02:56:21 <dminuoso> ShalokShalom: They are very different notions.
02:56:24 <ShalokShalom> might be
02:57:13 <tdammers> is it just me, or are the "Before" and "After" examples in that document absolutely identical, apart from the comment?
02:57:28 <ShalokShalom> yep
02:57:31 <ShalokShalom> correct
02:57:33 <dminuoso> ShalokShalom: newtypes give you exactly what you are asking for.
02:57:34 <ShalokShalom> thats the sense
02:57:45 <ShalokShalom> dminuoso: yes, just manually, right?
02:57:51 <dminuoso> ShalokShalom: It couldnt work differently.
02:57:59 <ShalokShalom> I am talking about an integration of newtypes into the type inference :)
02:58:02 <dminuoso> ShalokShalom: The compiler cant possibly know whether any two strings should be the same.
02:58:07 <ShalokShalom> Why not?
02:58:19 <dminuoso> ShalokShalom: "foo" ++ "bar"  -- should this type check?
02:58:20 <ShalokShalom> -.-
02:58:24 <tdammers> the only metric by which it could would be to give every string literal a different, unique type
02:58:34 <tdammers> but if you do that, you can no longer do anything useful with your strings
02:58:34 <ShalokShalom> the compiler knows, because each item actually gets an OWN type
02:58:43 <ShalokShalom> as shown in the comment
02:58:49 <dminuoso> ShalokShalom: If every item gets their own type, then it wont type check with anything.
02:58:53 <tdammers> the only thing you can do with such a type is to a) pass it around unchanged, and b) toss it
02:58:59 <dminuoso> ShalokShalom: then something like (++) :: String -> String -> String
02:59:01 <dminuoso> becomes *unusable*
02:59:17 <ShalokShalom> tdammers: despite you actually declare the string as string or something else specific
02:59:21 <tdammers> not just unusable; it becomes unwritable
02:59:30 <ShalokShalom> this is only for undeclared sttrings
02:59:38 <tdammers> I don't understand
02:59:39 <Rembane> A very philosophical type system.
02:59:52 <ShalokShalom> while haskell might be not the exact perfect candidate here, since its common to declare all
03:00:04 <ShalokShalom> this is language agnostic
03:00:09 <tdammers> no, I don't understand what you mean
03:00:11 <ShalokShalom> this proposal
03:00:14 <ShalokShalom> i see
03:00:17 <dminuoso> ShalokShalom: I understand that, its still nonsensical.
03:00:23 <tdammers> the proposal seems very confused
03:00:24 <ShalokShalom> thanks a lot
03:00:33 <ShalokShalom> in what way?
03:00:43 <tdammers> I'm sure there's an interesting thought in there, but it's very difficult to extract it from the text
03:01:03 <ShalokShalom> In Haskell, nothing would change as long as you add type declarations, as people are used to. 
03:01:14 <ShalokShalom> I will add that. 
03:01:45 <tdammers> so you're saying that if I write a string literal without an explicit type declaration, then the compiler should conjur up a completely new type for it and infer that?
03:02:03 <dminuoso> That literal becomes unusable. :-)
03:02:13 <tdammers> dminuoso: yes, that's what I was going to get at ;)
03:02:41 <tdammers> well, technically it wouldn't have to become unusable, provided that the compiler also generates suitable typeclass instances for you
03:03:09 <tdammers> but if you do that, and rewrite all the string handling functions in base to operate through those typeclasses, then you are essentially back to square one
03:03:29 <tdammers> because now all those fabricated string types are interchangeable, and you don't win anything from separating them out
03:03:29 <ShalokShalom> Hnn, wait. 
03:04:13 <dminuoso> ShalokShalom: So is OverloadedStrings and newtypes what you are asking for?
03:04:15 <tdammers> which brings us back to the original conclusion: separate types for different string literals is only useful when the programmer can tell the compiler explicitly which of those strings are supposed to be interchangeable and which not
03:04:22 <tdammers> which is exactly what newtypes do
03:04:32 <ShalokShalom> let me see that
03:04:33 <dminuoso> tdammers: I *think* they might be asking for newtypes with OverloadedStrings.
03:04:36 <dminuoso> % :set -XOverloadedStrings
03:04:37 <yahb> dminuoso: 
03:04:42 <tdammers> dminuoso: yes, I think so too.
03:04:47 <ShalokShalom> its not only for strings
03:04:48 <dminuoso> % data UserInput = UserInput String
03:04:48 <yahb> dminuoso: 
03:05:07 <dminuoso> % instance IsString UserInput where fromString = UserInput
03:05:08 <yahb> dminuoso: 
03:05:09 <tdammers> ShalokShalom: no, the string is just an example, the same reasoning goes for anything (and newtypes can wrap any type you like)
03:05:34 <dminuoso> % display :: UserInput -> IO (); display (UserInput inp) = print inp
03:05:34 <yahb> dminuoso: 
03:05:39 <dminuoso> % display "foo"
03:05:40 <yahb> dminuoso: "foo"
03:06:08 <dminuoso> ShalokShalom: ^- this gives you the pretense of treating "foo" as not just a String, but also as UserInput - but you maintain the security of the type wrapper
03:06:18 <dminuoso> *newtype wrapper
03:06:34 <dminuoso> % :t "foo
03:06:34 <yahb> dminuoso: ; <interactive>:1:5: error: lexical error in string/character literal at end of input
03:06:36 <dminuoso> % :t "foo"
03:06:36 <yahb> dminuoso: IsString p => p
03:08:00 <dminuoso> % "foo" `asTypeOf` UserInput "bar"
03:08:00 <yahb> dminuoso: UserInput "foo"
03:08:18 <ShalokShalom> It all comes down to the fact that build-in types are more performant and custom types are more clear to understand. 
03:08:31 <dminuoso> ShalokShalom: types and runtime representations are two different notions.
03:08:36 <ShalokShalom> And my proposal simply suggests a translation between two.
03:08:43 <dminuoso> ShalokShalom: all newtypes get compiled away
03:08:53 <ShalokShalom> Then tell me what runtime representations is in haskell since I cant find anything
03:08:59 <ShalokShalom> ok, fine
03:09:03 <dminuoso> ShalokShalom: so the runtime representation is how values are represented in memory
03:09:12 <dminuoso> ShalokShalom: a type is an abstract idea that only exists at compile time
03:09:19 <ShalokShalom> why not newtypes over each and every build-in type?
03:09:27 <ShalokShalom> i know..
03:09:41 <tdammers> you have to bootstrap things from *somewhere*
03:09:55 <ShalokShalom> Hä?
03:09:56 <tdammers> you can think of the built-in types as the "default" types for the underlying representation
03:10:01 <ShalokShalom> yes
03:10:16 <ShalokShalom> and why not create a transition layer?
03:10:21 <dminuoso> ShalokShalom: we have that. its called newtypes.
03:10:27 <dminuoso> ShalokShalom: its called data types.
03:10:29 <dminuoso> its called gadts
03:10:45 <dminuoso> that gives you three mechanisms to construct a) new types and b) new runtime representations
03:10:46 <ShalokShalom> so the programmer sees the actual type, not the representation of the underlying representation
03:10:50 <ShalokShalom> ok#
03:10:55 <tdammers> you can of course decide to never use the raw built-in types, and instead always newtype them - but you still need the built-in types, because you have to define your newtypes in terms of *something*
03:11:00 <dminuoso> ShalokShalom: well you sort of see both
03:11:05 <ShalokShalom> ok..
03:11:40 <dminuoso> ShalokShalom: `data Foo = Bar !Int` tells you a) about a *type* called Foo, and a data constructor with some details about its runtime representation (assuming the compiler wont optimize it away)
03:11:44 <tdammers> and since the built-in types need to exist anyway, might as well use them directly when the default type's semantics are what you want
03:12:12 <ShalokShalom> I want my type declarations free from String -> String -> String and instead showing the actual content
03:12:18 <dminuoso> ShalokShalom: newtypes are the special type wrappers that create a shallow type but reusing another types runtime representation.
03:12:43 <ShalokShalom> And also a way to prevent Strings from compiling, who are not supposed to get compiled together
03:12:55 <tdammers> yes. newtypes do that for you.
03:12:56 <ShalokShalom> ok, I see these newtypes
03:13:04 <ShalokShalom> and what does OverloadStrings do?
03:13:08 <ShalokShalom> and why just Strings?
03:13:14 <dminuoso> ShalokShalom: it lets you use literals in place of not just string values.
03:13:25 <ShalokShalom> aha, I see
03:13:26 <dminuoso> ShalokShalom: for example we have both String and Text
03:13:34 <dminuoso> ShalokShalom: but string literals "foo" are of type String
03:13:39 <ShalokShalom> and is there something for Int, and Float too?
03:13:40 <dminuoso> so you cant use them in places where Text might go
03:13:45 <ShalokShalom> like OverloadInterger and so?
03:13:51 <ShalokShalom> *integer
03:13:52 <dminuoso> ShalokShalom: Yes, but its turned on always.
03:13:58 <ShalokShalom> ok?
03:13:59 <ShalokShalom> cool
03:14:02 <ShalokShalom> thanks
03:14:06 <dminuoso> % :t 5
03:14:06 <yahb> dminuoso: Num p => p
03:14:07 <tdammers> numeric literals are polymorphic by default
03:14:18 <tdammers> there's also OverloadedLists, which does the same for list literals
03:14:25 <ShalokShalom> ok, thanks
03:14:32 <tdammers> allowing you to write literals for, say Vector, Set, Map, etc.
03:15:12 <dminuoso> ShalokShalom: So if you have some `newtype Password = Password String`, then the runtime representation will be that of String (again assuming no further compiler optimizations), but you have to always construct it via: Password "secret"
03:15:26 <dminuoso> ShalokShalom: If you also wrote an instance IsString for that newtype and turned on the above extension, then you could just use: "secret"
03:16:00 <ShalokShalom> ähm, secret represents what here?
03:16:06 <[exa]> is there some nice way of (transparently) tracking which parts of a structure were changed by a lens-using function? Let's say I have 'f::a->a' that uses lenses (and only lenses) to modify the 'a'; I'd like something like 'trackWrites::(a->a)->(a->(DirtyInfo a, a))' so that I can get the modification info using e.g. 'wasModified::DirtyInfo a -> Lens' a b -> Bool'? I can assume function only uses lenses for 
03:16:09 <dminuoso> The password you are typing into your code.
03:16:11 <ShalokShalom> I didnt see it in the intialisation
03:16:11 <dminuoso> Say you have some
03:16:12 <[exa]> modifications
03:16:21 <ShalokShalom> yeah, so Password is the actual type then, yeah?
03:16:21 <dminuoso> login :: Password -> IO ();
03:16:23 <ShalokShalom> on the surface
03:16:28 <ShalokShalom> yeah, perfect
03:16:32 <dminuoso> ShalokShalom: `Password` is both a type and a data constructor
03:16:36 <dminuoso> perhaps its less confusing if we do it like this
03:16:42 <dminuoso> % newtype Password = MkPassword String
03:16:43 <yahb> dminuoso: 
03:16:45 <ShalokShalom> thanks, thats much more complicated described in the actual manual
03:16:48 <dminuoso> % newtype Password = MkPassword String deriving (Eq, Show)
03:16:48 <yahb> dminuoso: 
03:16:57 <dminuoso> Now you can construct values of type Password like this
03:17:07 <dminuoso> % MkPassword "thisIsNotVerySecret"
03:17:08 <yahb> dminuoso: MkPassword "thisIsNotVerySecret"
03:17:26 <ShalokShalom> exa asked something :)
03:17:52 <dminuoso> [exa]: how nice does nice need be?
03:17:57 <dminuoso> [exa]: For debugging or production?
03:18:13 <[exa]> dminuoso: currently just for playing with it
03:18:15 <dminuoso> [exa]: You could construct the lens with unsafePerformIO tucked in..
03:18:20 <[exa]> oh noes
03:18:42 <[exa]> some level of purity would be nice, yes
03:18:59 <[exa]> otherwise anything goes
03:19:44 <kuribas> [exa]: I had something likes that using json diff as a track, which you can then store, pass to an API etc...  Unfortunately it's broken now, and I did find time to work on it.
03:19:45 <[exa]> higher purpose: I have a set of functions that run on a big State and use 'zoom' a lot, and I'd like to see what they changed so that I can mirror the changes to some external cache
03:20:01 <dminuoso> [exa]: I wonder, couldn't you use the MonadState interface and supply your own stateful monad that tracks writes?
03:20:41 <kuribas> [exa]: http://hackage.haskell.org/package/aeson-diff-generic-0.0.3/docs/Data-Aeson-Diff-Generic-PathOptics.html
03:20:56 <kuribas> [exa]: wouldn't be too hard to fix it, but I didn't find time yet...
03:21:07 <dminuoso> % :t assign
03:21:08 <yahb> dminuoso: MonadState s m => ASetter s s a b -> b -> m ()
03:21:11 <dminuoso> [exa]: ^-
03:21:12 <ShalokShalom> there is a typo https://www.schoolofhaskell.com/user/kseo/overloaded-string-literals
03:21:13 <[exa]> dminuoso: that would work great if I force the user to use 'zoom' for exactly marking the scope of his modification; I'd really love to have effortless tracking of tiniest changes
03:21:31 <ShalokShalom> moudle is supposedto be module, I guess
03:21:37 <[exa]> dminuoso: yeah
03:21:41 <dminuoso> Mmm
03:21:43 <ShalokShalom> somebody here with commit rights to the school?
03:21:57 <[exa]> kuribas: PathOptics sounds cool, will look at it, thanks
03:22:32 <[exa]> kuribas: but again, the state datatype I'm using should be as generic as possible and I can't diff everything (eg functions)
03:23:00 <kuribas> [exa]: you can automatically derive instances with my library
03:23:07 <kuribas> currently using TH
03:23:53 <[exa]> hhhhhhmmmmmmmmmmmmmmmmmmmmmmm
03:24:43 <[exa]> kuribas: instances of which exact class?
03:25:36 <[exa]> oh I guess I see that now
03:28:14 <[exa]> kuribas: okay thank you very much, that is a very useful working example that I should be able to extend without much trouble
03:31:24 <ShalokShalom> Ah, there is also: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-OverloadedLabels
03:32:03 <dminuoso> ShalokShalom: Yes, but that starts to venture into the exotic parts of our type system.
03:32:15 <ShalokShalom> ok, I see
03:32:36 <ShalokShalom> i thought the whole type system is kinda exotic 
03:32:42 <ShalokShalom> in a good way :)
03:33:01 <dminuoso> ShalokShalom: Perhaps "way more expressive than Im used to" is more appropriate. :)
03:34:34 <ShalokShalom> well; its not the expressiveness that I dislike
03:34:47 <ShalokShalom> its more the complicated approach how to explain it
03:35:02 <ShalokShalom> everything in Haskell seems easy to use
03:35:22 <ShalokShalom> while insanely difficult to really understand beyond the surface
03:35:37 <ShalokShalom> and the Haskell community seems to love this area :)
03:40:22 <ShalokShalom> dminuoso: would you say the Haskell community loves to show how something is implemented?
03:41:17 <ShalokShalom> And would you say it is necessarily to really understand how its implemented, in order to simply use it? 
03:41:27 <tdammers> the difficulty in explaining stems from how abstract many of the type concepts are
03:41:32 <ShalokShalom> Since I guess it might be sometimes not so hard as it seems to be.
03:41:44 <tdammers> they're not complex, just very abstract, which makes it difficult to talk about them without resorting to jargon
03:41:53 <ShalokShalom> Well, this was not the question :)
03:42:03 <ShalokShalom> Do you mean explaining the implementation or the usage?
03:42:14 <ShalokShalom> I dont have to understand how a car is build, in order to drive it
03:42:17 <tdammers> the semantics, mainly
03:42:58 <ShalokShalom> While I have sometimes the impression that the community assumes its safer to know how the car is actually constructed, in order to drive it. 
03:43:05 <ShalokShalom> Would you agree on this?
03:43:12 <tdammers> I'd say the opposite is true
03:43:18 <ShalokShalom> ok
03:43:28 <ShalokShalom> Would you say Elm is abstract?
03:43:48 <ShalokShalom> I honestly think abstraction makes it easier to understand, rather than more difficult?
03:44:06 <tdammers> not necessarily
03:44:09 <ShalokShalom> The more difficult things to understand are for me the low level concepts
03:44:18 <tdammers> abstractions require an up-front learning effort
03:44:20 <ShalokShalom> well, to me its that way
03:44:26 <ShalokShalom> Yeah?
03:44:32 <tdammers> but once you do understand the abstraction, it will allow you to reason about complex things in simpler terms
03:44:35 <ShalokShalom> A simple binding is an abstraction?
03:44:48 <tdammers> well, take for example the Monoid abstraction
03:44:56 <ShalokShalom> Heck, every single language construct in Ruby is a heavy abstraction?
03:44:59 <ShalokShalom> Yes?
03:45:26 <tdammers> Monoid is a very simple concept: you have a type (let's call it a), a binary operator (let's call it <>), and a "neutral value" of type a
03:45:34 <tdammers> Formally, you also have laws:
03:45:36 <ShalokShalom> OK
03:45:41 <tdammers> a <> (b <> c) == (a <> b) <> c
03:45:49 <tdammers> a <> neutral == a
03:45:53 <tdammers> neutral <> a == a
03:46:22 <tdammers> this is a bit more abstract, and thus more difficult to grasp, than, say, integer addition
03:46:42 <ShalokShalom> ok
03:46:51 <tdammers> especially, it's more difficult to intuit how the laws work and what "neutral" and "<>" mean
03:47:21 <tdammers> but once you understand the Monoid abstraction, you can now use it as a unified reasoning framework for an infinitely large class of types
03:47:35 <ShalokShalom> it would be more easy to simply show how it works in a screencast or gif?
03:47:50 <ShalokShalom> instead of explaining the certain parts in detail
03:48:05 <ShalokShalom> so to say, how it works in practice
03:48:31 <tdammers> but that's the whole crux - you can't really explain it any more concrete than I just did
03:48:43 <tdammers> the only thing I can do is give you more examples of monoids
03:48:46 <ShalokShalom> what <> means is on stackoverflow :P
03:48:55 <tdammers> <> is just the monoid operator
03:48:59 <ShalokShalom> well, you could show the outcome
03:49:05 <ShalokShalom> then I could infer the meaning
03:49:08 <tdammers> not in a general way
03:49:10 <tdammers> that's the thing
03:49:15 <ShalokShalom> okß
03:49:19 <ShalokShalom> ?
03:49:29 <tdammers> I can give you the meaning of <> for any given example of a monoid, but I cannot write it down for all monoids
03:49:35 <ShalokShalom> then it would work differently in different scenarios
03:49:40 <Taneb> > foldMap (Sum && Product) >> getSum *** getProduct $ [1..10]
03:49:42 <lambdabot>  error:
03:49:42 <lambdabot>      • Couldn't match type ‘(Sum c, Product c')’ with ‘[Integer]’
03:49:42 <lambdabot>        Expected type: [Integer] -> (c, c')
03:49:42 <tdammers> for example, strings form a monoid over concatenation
03:49:49 <Taneb> > foldMap (Sum && Product) >>> getSum *** getProduct $ [1..10]
03:49:51 <lambdabot>  error:
03:49:51 <lambdabot>      • Couldn't match expected type ‘Bool’
03:49:51 <lambdabot>                    with actual type ‘a0 -> Sum a0’
03:49:53 <tdammers> with the empty string as the neutral element ("mempty")
03:49:57 <Taneb> > foldMap (Sum &&& Product) >>> getSum *** getProduct $ [1..10]
03:49:59 <tdammers> so: "foo" <> "bar" == "foobar"
03:49:59 <lambdabot>  (55,3628800)
03:50:06 <Taneb> Next time I copy paste rather than retype
03:50:18 <tdammers> and: "foo" <> "" == ""
03:50:22 <tdammers> uhm
03:50:26 <tdammers> "foo" <> "" == "foo"
03:50:28 <tdammers> (sorry)
03:50:31 <ShalokShalom> ok
03:50:51 <ShalokShalom> so it works differently here?
03:51:00 <tdammers> kind of, yes
03:51:05 <tdammers> it works differently for each monoid instance
03:51:12 <ShalokShalom> and I need to understand the abstraction, in order to guess the implications
03:51:16 <tdammers> but the laws and the shape are always the same
03:51:29 <tdammers> a <> mempty == a -- holds for any choice of a
03:51:29 <ShalokShalom> I see. Why?
03:51:35 <ShalokShalom> What is the benefit?
03:51:53 <tdammers> the benefit is that you can now write functions in terms of Monoid, and they will automatically work on *all* monoids
03:52:05 <Taneb> :t mconcat
03:52:07 <lambdabot> Monoid a => [a] -> a
03:52:12 <ShalokShalom> so higher abstraction on my side?
03:52:15 <tdammers> ^ I was about to write that down
03:52:44 <ShalokShalom> so it seems to me that Haskell deserves its call as professional language
03:53:02 <tdammers> e.g.: mconcat [] = mempty; mconcat (x:xs) = x <> mconcat xs -- voila, and this now works for *all* monoids - integer addition, integer multiplication, strings, Maybe's of lists, ()
03:53:04 <ShalokShalom> would you call a Haskell without the usage of these kinds of abstractions useful?
03:53:24 <ShalokShalom> do I need to understand all these implications, in order to code Haskell?
03:53:31 <ShalokShalom> upfront?
03:53:46 <tdammers> you can get started without learning about typeclasses, but you will run into limitations fast
03:53:50 * hackage timers-tick 0.4.1.0 - tick based timers  https://hackage.haskell.org/package/timers-tick-0.4.1.0 (fffaaa)
03:53:53 <ShalokShalom> ok
03:53:55 <ShalokShalom> i see
03:54:00 <tdammers> you will have to learn about them eventually, they are very fundamental to the language
03:54:08 <ShalokShalom> faster or equal as fast as in Elm?
03:54:16 <tdammers> Elm doesn't have typeclasses
03:54:23 <ShalokShalom> since that one seems enough to produce simple webapps
03:54:27 <ShalokShalom> i know
03:54:57 <tdammers> JavaScript is also enough to produce simple webapps, so that's a very low bar to shoot for IMO
03:55:01 <ShalokShalom> you use the word typeclasses the first time a couple of seconds ago
03:55:12 <ShalokShalom> how are they related to this kind of abstraction?
03:55:15 <tdammers> ah
03:55:19 <Taneb> "Monoid" is an example of a typeclass
03:55:24 <tdammers> OK, maybe you want to read up on those
03:55:25 <ShalokShalom> ok
03:55:48 <ShalokShalom> but isnt the whole Elm runtime a whole IO.Monad?
03:55:57 <Taneb> No?
03:56:01 <ShalokShalom> so it has typeclasses on the implementation level
03:56:04 <ShalokShalom> sure?
03:56:12 <ShalokShalom> its how someone called it 
03:56:13 <tdammers> but indeed, in this example, I casually switched between the "proper" definition of monoid (the triplet of a type, a binary operation on that type, and an "empty" value of that type, plus the monoid laws) and the Haskell typeclass called Monoid
03:56:40 <tdammers> no, Elm doesn't have proper typeclasses. you can quite literally think of a typeclass as a class of types
03:56:52 <ShalokShalom> i mean not on the user level
03:56:53 <tdammers> for example, Monoid is the class of types that form monoids
03:56:59 <ShalokShalom> on the implementation levle
03:57:01 <ShalokShalom> level
03:57:22 <ShalokShalom> so a couple of types create a monoid?
03:57:46 <ShalokShalom> how can a type create something?
03:57:54 <ShalokShalom> I thought thats just a description
03:57:57 <tdammers> no, types don't create anything
03:58:03 <ShalokShalom> ok, I see
03:58:17 <tdammers> the typeclass itself describes the common interface across all of its members
03:58:45 <tdammers> in order to make a type a member of a typeclass, you need to write an instance, which is a description of *how* the type implements the interface
03:58:49 <ShalokShalom> so a typeclass is what combines different types to lets say a Monoid?
03:58:59 <tdammers> I wouldn't say "combines"
03:59:05 <ShalokShalom> what else?
03:59:07 <tdammers> it just describes the "Monoid" interface
03:59:18 <ShalokShalom> how long to you take to understand this?
03:59:28 <ShalokShalom> and have you a master in CS?
03:59:34 <tdammers> it is not defined in terms of "which types belong in this typeclass", but rather, "which operations can I perform on types in this typeclass"
03:59:37 <ShalokShalom> *did
03:59:51 <ShalokShalom> aha, I see
03:59:55 <tdammers> I majored in jazz trombone
04:00:00 <tdammers> took a while to click though
04:00:11 <tdammers> anyway, it helps to look at an example
04:00:57 <tdammers> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.String.html#IsString -- this is a real typeclass from the actual standard libraries that ship with GHC
04:01:06 <ShalokShalom> so its some form of ability check on a specific group of types?
04:01:08 <tdammers> class IsString a where fromString :: a -> String
04:01:42 <ShalokShalom> I really appreciate this effort of yours :)
04:01:50 <tdammers> this says that iff a type "a" has an instance of the IsString typeclass, then fromString can be used with this type, and its type will be "a -> String"
04:01:54 <ShalokShalom> while I really struggle with pseudocode in general
04:02:10 <ShalokShalom> to me, it makes much more sense when I see somebody doing it 
04:02:47 <tdammers> now let's suppose I have a type like this: data Foo = Foo | Bar
04:02:59 <tdammers> and I want to write an IsString instance for it
04:03:09 <ShalokShalom> you seriously majored in jazz trombone? :D
04:03:14 <tdammers> yeah
04:03:17 <ShalokShalom> cool
04:03:24 <tdammers> (btw., it's String -> a, not a -> String, I mistyped)
04:03:29 <ShalokShalom> ok
04:04:07 <tdammers> (I switched to programming because being a musician is great, but being poor isn't cool, especially when you have a family to feed)
04:04:26 <tdammers> so, we could start with a function :: String -> Foo
04:05:08 <tdammers> e.g.: fooFromString :: String -> Foo; fooFromString "bar" = Bar; fooFromString _ = Foo -- that is, if the string is exactly "bar", we'll return `Bar`, otherwise we'll return `Foo`
04:05:26 <tdammers> and now we can say: instance IsString Foo where fromString = fooFromString
04:05:36 <ShalokShalom> I imagine you with a sign which says: I code for food :D
04:05:43 <ShalokShalom> like after the great depression.
04:05:56 <tdammers> I literally do code for food. Well, for money, but I use the money to buy food.
04:06:08 <ShalokShalom> And you do it in Haskell?
04:06:20 <ShalokShalom> This all seems Haskell is all about meta programming
04:06:31 <ShalokShalom> while in a different style, as lets say Clojure or so
04:06:40 <ShalokShalom> with types :D
04:06:46 <ShalokShalom> type based meta programming
04:06:52 <ShalokShalom> could this be said?
04:07:33 <Axman6> I wouldn't say that's true
04:07:44 <ShalokShalom> ok?
04:07:47 <Axman6> we have meta-programming, but everything you've seen is just programming
04:07:57 <ShalokShalom> ok, I see
04:08:12 <tdammers> well, in a way types live one level above terms, so in that sense it's metaprogramming
04:08:41 <tdammers> (and in fact, one of Haskell's major influences is called ML, which is short for Meta-Language, because the inventors intended it to be used merely as a metaprogramming language)
04:08:43 <ShalokShalom> while in that sense every typed based language is so
04:08:47 <tdammers> yes
04:08:50 <ShalokShalom> i know ML
04:08:56 <ShalokShalom> SML, you mean
04:09:04 <ShalokShalom> from this come Miranda
04:09:04 <tdammers> SML is "standard ML", so yeah
04:09:07 <ShalokShalom> and then Haskell
04:09:25 <ShalokShalom> i love that one, while I like the syntax in Haskell a bit more
04:09:32 <ShalokShalom> while its actually quite similar
04:10:14 <ShalokShalom> Haskell is just very focused on understanding the implementation details, to me
04:10:24 <ShalokShalom> I never had to ask how something is implemented in Elm
04:10:27 <ShalokShalom> I just use it
04:10:42 <maerwald> I also prefer languages that don't leak in implementation details
04:10:55 <ShalokShalom> leak?
04:11:12 <maerwald> yes
04:11:21 <ShalokShalom> i mean, they can be there, I just dont want to need to understand them
04:11:27 <tdammers> frankly, I rarely have to care about the implementation of Haskell things
04:11:41 <ShalokShalom> in the very sense as I dont wont to understand how my engine works, when driving my car
04:11:42 <maerwald> tdammers: oh well, laziness is not that well defined, is it? :>
04:11:57 <ShalokShalom> tdammers: well, because you already know about them?
04:12:14 <tdammers> when I do, it's usually for one of two reasons: performance, and someone (including myself) cleverly bypassing things with unsafePerformIO and friends
04:12:28 <tdammers> and no, not because I know how things are implemented under the hood
04:12:42 <ShalokShalom> i guess you have it in your subconsciousness? 
04:12:46 <tdammers> in fact, I didn't even know how IO is implemented internally until I started working on GHC itself
04:12:54 <ShalokShalom> ok, I see
04:12:56 <tdammers> no, you don't need to know
04:12:58 <maerwald> tdammers has all of GHC in his subconciousness :D
04:13:05 <ShalokShalom> so this is not always the case
04:13:08 <tdammers> all you need to know, most of the time, is the semantics of the types you are using
04:13:25 <tdammers> it is actually very rare that you need to dig down and look at the implementation
04:13:29 <ShalokShalom> ok. where to learn that?
04:13:33 <tdammers> learn what
04:13:33 <ShalokShalom> i see
04:13:35 <ShalokShalom> perfect
04:13:42 <ShalokShalom> the sementics of the types
04:13:47 <ShalokShalom> and nothing else
04:13:56 <tdammers> pick up an introductory Haskell textbook and work your way through it
04:14:00 <tdammers> @where haskellbook
04:14:00 <lambdabot> http://haskellbook.com
04:14:02 <ShalokShalom> ok
04:14:11 <tdammers> ^ this one is probably one of the better ones, though not free
04:14:41 <tdammers> just the textbook example: let's say you are confronted with a function whose type is :: a -> a
04:14:48 <tdammers> now try and figure out what this function can do
04:14:59 <tdammers> note that "a" means "any type the caller picks"
04:15:28 <tdammers> can this function add numbers? no, because that only works on numbers, and we have to be able to consume *any* type
04:16:03 <tdammers> can this function ignore its input and always produce the same output value? no, that's not possible either, because we also need to be able to *produce* values of any type the caller picks
04:16:20 <tdammers> we can only do two things: return the original value unchanged, or crash
04:16:39 <tdammers> (where "crashing" includes "keep running forever without ever producing anything")
04:17:45 <tdammers> but the kicker is that we do not need to know how this function is implemented - the type already tells us all we need to know
04:17:46 <ShalokShalom> can this function add numbers? no, because that only works on numbers, and we have to be able to consume *any* type
04:17:50 <ShalokShalom> I dont get this
04:18:00 <ShalokShalom> aha, ok wgy?
04:18:02 <ShalokShalom> why
04:18:14 <tdammers> the "a" part left of the arrow means "this function will accept any type you pick as its input"
04:18:31 <ShalokShalom> why do we have to be able to consume any type?
04:18:37 <ShalokShalom> a number is any type
04:18:39 <Taneb> Let's say you try to write "foo :: a -> a; foo x = x + 1", and I try to do "foo True". From my point of view this typechecks, foo :: a -> a which means I can use it as Bool -> Bool
04:18:54 <Taneb> But what is True + 1? That doesn't typecheck
04:19:25 <ShalokShalom> pk
04:19:28 <tdammers> no, a number is not any type, a number is just one type. "any type" also includes strings, functions, IO actions, file handles, suspension bridges, mixed fruit platters, and rocks so heavy that God himself cannot move them
04:19:28 <ShalokShalom> ok
04:19:38 <ShalokShalom> yeah, what I mean
04:19:39 <tdammers> and pretty much any other type you can think of
04:19:45 <ShalokShalom> but a number is part of "any type"
04:19:57 <ShalokShalom> what cant we add numbers at a -> a
04:20:04 <tdammers> yes, but it has to accept *every* one of those types. not just some of them.
04:20:08 <ShalokShalom> yes
04:20:16 <ShalokShalom> so it *can* be adding a number?
04:20:18 <tdammers> if you want to write a function that can add numbers, you have to be more specific about the input type
04:20:19 <ShalokShalom> or anything else
04:20:23 <ShalokShalom> it does not tell much
04:20:28 <ShalokShalom> aha, ok?
04:20:35 <ShalokShalom> so a-> a is used when?
04:20:44 <ShalokShalom> when its not specific enough`
04:20:47 <ShalokShalom> ?
04:20:48 <tdammers> when you want a function that returns its argument unchanged
04:21:11 <tdammers> "a -> a" says "you can give me any type, I don't need to know anything about it, and I'll give you a value of the same type"
04:21:42 <tdammers> but because you promised that you don't need to know anything about the type, you can't even tell which values there are in it, let alone how to make new ones
04:22:20 <ShalokShalom> so how does it look like when adding numbers?
04:22:32 <tdammers> there are several ways
04:22:44 <tdammers> the cheap cop-out is to ask the caller to also provide an addition function
04:22:47 <tdammers> e.g.:
04:22:54 <tdammers> foo :: (a -> a -> a) -> a -> a
04:23:07 <tdammers> foo add x = add x x
04:23:22 <tdammers> now I can use it to add a number to itself by passing in the addition operator: foo (+) 5
04:23:30 <tdammers> but that really only defers the problem
04:23:39 <tdammers> another cheap solution is to pick a specific type, e.g.:
04:23:43 <tdammers> foo :: Int -> Int
04:23:46 <tdammers> foo x = x + 5
04:24:02 <tdammers> now it works, because I no longer promise to accept *all* types, I now specifically demand an Int
04:24:17 <tdammers> and once I know that I will always receive an Int, I can safely add 5 to it
04:24:34 <tdammers> but the downside of this is that it doesn't support any other numeric types anymore
04:25:08 <tdammers> the one where we explicitly passed in the addition function does, but having to pass the (+) function every time gets old quick, and feels wrong, because for any given numeric type, there is only one way to perform addition
04:25:09 <ShalokShalom> so that is why in haskell, people tend to do type annotations
04:25:17 <tdammers> it is one reason
04:25:27 <tdammers> but it's not necessary, actually
04:25:30 <ShalokShalom> in order to declare upfront, what you are trying to do
04:25:42 <tdammers> if you leave out the type annotation entirely, the compiler will infer the most general type possible for you
04:25:47 <tdammers> I'll get to that in a sec
04:26:18 <tdammers> now we have the one where we explicitly pass the addition function, which is ugly, and we have one that only supports ints, which is too specific
04:26:41 <tdammers> what we want to say is "given any type 'a' that supports addition, you can give me an 'a', and I'll get you an 'a' back"
04:26:46 <tdammers> this is where typeclasses come in
04:27:02 <tdammers> the `Num` typeclass has, among other things, a method (+)
04:27:23 <tdammers> meaning that any type for which a Num instance exists can be added to other values of the same type
04:27:36 <tdammers> so now we can add Num as a constraint on our type a, and write the function as such:
04:27:41 <tdammers> foo :: Num a => a -> a
04:27:44 <tdammers> foo x = x + 5
04:28:32 <tdammers> which means: I will accept any type 'a', as long as it is a numeric type (i.e., it is a member of the Num typeclass), and I will give you a value of that same type back
04:28:52 <tdammers> but because we constrained the type, we can (paradoxically) perform a wider range of operations on it
04:29:25 <tdammers> it's not actually paradoxical, because we constrained the caller in order to liberate the consumer - our function foo can do more because we put more demands on the caller
04:36:14 <ShalokShalom> why is explicitly passing the addition function ugly?
04:36:41 <ShalokShalom> and to me, this still looks very much like meta programming
04:36:52 <ShalokShalom> while I could have a misunderstanding of that one
04:37:12 <ShalokShalom> and also like you show me the guts of the language
04:37:29 <ShalokShalom> like, how and why type classes are implemented
04:38:15 <ShalokShalom> so Num is a construct 
04:38:25 <ShalokShalom> implemented as a type class
04:38:44 <ShalokShalom> and why is this different compared to other languages, who use other constructs?
04:38:51 <ShalokShalom> I mean, from the user side.
04:44:19 <tdammers> passing the addition function explicitly is ugly because it produces a lot of syntactic noise
04:44:27 <tdammers> you need to pass it along the entire call graph
04:44:47 <tdammers> and if you need more operations, then you need to pass more functions along
04:45:00 <tdammers> it's not always bad, mind you - often, things are so ad-hoc that passing the function is the nicer solution
04:49:05 <ShalokShalom> and how would that look like with Num?
04:49:27 <ShalokShalom> so, type classes are used to create constuctors in Haskell?
04:51:32 <ShalokShalom> how different are type classes from Ocamls higher order modules?
04:53:38 <ShalokShalom> So type classes are some kind of filters...
05:01:02 <lortabac> ShalokShalom: another use-case for type-classes is when you need global coherence. For example you want the ordering function of the elements of a set to be always the same, so using the Ord class is probably a good idea
05:02:01 <lortabac> if you pass an ordering function explicitly, you may accidentally use different functions in different parts of the code, and introduce bugs
05:04:13 <lortabac> whereas if you use the Ord type-class, there can be only one Ord instance for each type
05:04:28 <lortabac> and it's the same for the whole program
05:05:47 <ShalokShalom> which is again a filtering
05:06:03 <ShalokShalom> so type classes are filters under each circumstance#
05:06:23 <lortabac> maybe, I don't know what filtering is
05:06:44 <ShalokShalom> filtering like in using a filter
05:06:51 <ShalokShalom> like in general, real life
05:06:57 <ShalokShalom> not really in any implementation
05:07:17 <lortabac> IMHO it's more like selecting
05:07:32 <ShalokShalom> why do I use type classes, if not for specifying a certain group of types?
05:07:38 <ShalokShalom> ok, selecting
05:07:41 <ShalokShalom> its the same for me
05:07:46 <lortabac> you select a value (or a record of values) for each type
05:08:11 <ShalokShalom> consciousnos filtering
05:08:28 <ShalokShalom> yeah, cool
05:09:43 <ShalokShalom> thanks a lot
05:10:23 <ShalokShalom> so learning Haskell means learning type classes 
05:10:45 <lortabac> yes, I'd say type classes are an important part of Haskell
05:10:47 <ShalokShalom> simply put, type classes are the main constructors in Haskell.
05:10:59 <lortabac> no, I wouldn't say that
05:11:11 <lortabac> the basic bricks are algebraic data-types and functions
05:11:11 <ShalokShalom> which other constructs are there?
05:11:15 <ShalokShalom> ok
05:11:27 <ShalokShalom> but besides of this
05:11:31 <lortabac> but if you know OCaml you probably already know them
05:11:43 <ShalokShalom> type classes, algebraic data types and functions
05:11:45 <ShalokShalom> yeah
05:11:57 <ShalokShalom> the main difference, I mean
05:13:32 <lortabac> and purity. In order to use Haskell in the real world you need to learn how IO works
05:14:00 <ShalokShalom> and how do you see OCamls higher order modules in comparison?
05:14:46 <ShalokShalom> Since they can quite achieve with them, what you achieve with type classes
05:14:56 <ShalokShalom> and something else, I guess.
05:16:48 <lortabac> I don't know OCaml well enough
05:17:11 <lortabac> so I can't compare
05:17:23 <kuribas> [exa]: I have free days from thursday, I'll see if I can fix the PathOptics
05:18:43 <[exa]> kuribas: oh, don't worry about that, I'll need to redo the whole thing anyway
05:19:03 <kuribas> [exa]: you're going to write my library?  :-O
05:20:01 <kuribas> [exa]: you cannot use it as it is?
05:20:34 <kuribas> [exa]: or extend it?
05:20:39 <[exa]> kuribas: I need to omit the aeson part, to get a slightly more general form
05:21:23 <kuribas> [exa]: generic in what way?
05:21:39 <kuribas> generics?
05:24:06 <[exa]> kuribas: for any user-defined stuff (probably only for valid Functors or Generics)
05:25:27 <vlatkoB> Does anybody know if Text.Shakespeare.Text supports "$maybe" syntax?
05:25:36 <kuribas> [exa]: there is: http://hackage.haskell.org/package/aeson-diff-generic-0.0.3/docs/Data-Aeson-Diff-Generic-TH.html
05:25:45 <kuribas> [exa]: generics would be possible, but I didn't implement it.
05:26:48 <[exa]> yeah, I saw that
05:27:08 <joehh> hello. Im trying to use brick, but seem to be missing many events
05:27:24 <joehh> is this a known issue? or could I be doing something silly?
05:27:25 <[exa]> kuribas: I'll look into that next week, gonna ping you if I get something interesting
05:27:41 <kuribas> [exa]: ok :)
05:27:45 <[exa]> joehh: how much events is "many"? (do you have eg. minimal working example that fails?)
05:27:55 <joehh> roughly 50%
05:28:12 <joehh> currently pulling together a minimal example
05:28:18 <kuribas> [exa]: if your usecase doesn't match the library, I'd be interested why...
05:28:59 <[exa]> kuribas: as I wrote above, I want to autogenerate UIs from user-defined structure, just like with imgui, but ideally without the constant redrawing
05:29:15 <[exa]> oh I didn't write that :D
05:30:10 <[exa]> anyway imgui is pretty good (see https://github.com/ocornut/imgui), but works good only for realtime graphics and in languages that directly support references
05:30:41 <[exa]> so we're trying to rewrite that to sane haskell where lenses are references and this "patching" handles the problematic part for non-realtime graphics
05:36:50 <makalu> how do I know what to write in stack's compiler field if I want to use ghcjs? It doesn't have any releases on github. Where do the version numbers come from? Stack's documentation has something like ghcjs-0.1.0.20150924_ghc-7.10.2.
05:38:56 <UnkDevE> hello, does anyone know how to do polynomial multiplaction in binary for AES, I can't get the left shift right, as there was  four terms in each poly i thought a shift by 4 would work but it doesn't, any ideas?
05:44:17 <[exa]> UnkDevE: polynomial multiplication over GF(2^n) is like normal multiplication, but you don't carry anything when adding the subresults together
05:46:33 <UnkDevE> that makes sense, I've looked up most people use xor as add is that right?
05:49:21 <lyxia> yes
05:51:29 <UnkDevE> cool
05:56:22 <[exa]> UnkDevE: there's even CPU instruction for that somewhere, carry-less multiply
05:58:24 <[exa]> anyways after you do that, you just xor the result with the shifted modulo (100011011) several times so that you erase all 1's above 8 bits, and that's it
06:16:57 <bolverkr> > :t (.) 3
06:16:59 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
06:17:57 <bolverkr> @type (.) 3
06:17:59 <lambdabot> Num (b -> c) => (a -> b) -> a -> c
06:18:15 <bolverkr> why is that not an error? 
06:18:32 <lavalike> :t ((.), 3)
06:18:33 <lambdabot> Num b1 => ((b2 -> c) -> (a -> b2) -> a -> c, b1)
06:19:15 <lavalike> it unifies (b2->c) with b1 and gives you the constraint Num (b2->c) on the remaining type (a->b2)->a->c
06:20:08 <lavalike> it's not going to end well since (a->b) won't probably have a Num instance, but so far so good
06:20:52 <bolverkr> wait what, i don't understand. It is asking for a (b -> c) but I gave it a 3. How does that typecheck?
06:21:15 <lavalike> bolverkr: that's what I was trying to show, look at the two types separately
06:21:37 <lavalike> (.) :: (b2 -> c) -> (a -> b2) -> a -> c  one one side and  3 :: Num b1 => b1  on the other
06:22:26 <lavalike> if you apply the function to the argument, you're saying the type of the first argument: (b2->c) must match the type of the applied value (Num b1 => b1)
06:23:01 <lavalike> which results in (b2->c), as a unit, to get the constraint Num, as in Num (b2->c)
06:23:20 <lavalike> which is what you were getting your starter example, modulo renaming of the type variables
06:23:52 <lavalike> maybe this will keep the names the same:
06:23:56 <lavalike> :t let f = (.); x = 3 in (f, x, f x)
06:23:58 <lambdabot> (Num (b2 -> c1), Num b1) => ((b3 -> c2) -> (a1 -> b3) -> a1 -> c2, b1, (a2 -> b2) -> a2 -> c1)
06:24:15 <lavalike> ok it switched them around but you can follow them all in the same context at least
06:26:03 <lavalike> the key, using these last names, being that "b1" can be any type, and "b2->c1" is such a possible type for "b1"
06:32:50 * hackage servant-elm 0.6.0.0 - Automatically derive Elm functions to query servant webservices.  https://hackage.haskell.org/package/servant-elm-0.6.0.0 (k_bx)
06:33:09 <bolverkr> I kinda get it but my mind is melting with this information, I'll need some time to look at it carefully :) thank you for answering
06:34:20 <lavalike> np!
06:37:04 <bahamas> anyone have any idea how I could write a Coercible instance for a record type? https://github.com/tweag/inline-java/blob/494a37a9956eb1ed47dcf3706799e2dbf0252e13/jvm/src/Language/Java.hs#L177
06:37:57 <joehh> [exa]: found the issue, I was calling mkVty twice
06:38:00 <joehh> thanks
06:43:20 <[exa]> joehh: :] np
06:45:56 <bolverkr> msg lavalike are you still there?
06:59:03 <c_wraith> bahamas: you can't write Coercible instances at all.  they're strictly derived.
07:00:01 <Solonarv> c_wraith: wrong Coercible
07:00:57 <Solonarv> the question is about inline-java:Language.Java.Coercible, not base:Data.Coercible.Coercible
07:02:08 <c_wraith> Oh, whoops
07:04:45 <bahamas> man, this is the most difficult API I've ever had to deal with. I've been staring at it for days
07:05:29 <bahamas> it doesn't help that it uses so many concepts I'm not familiar with: singletons, type families, FFI, type representations
07:06:23 <cppxor2arr> i've so had that feeling
07:08:10 <dminuoso> bahamas: Perhaps you reached for a library outside your comfort zone..
07:09:05 <int-e> bahamas: what are the intended semantics here?
07:10:09 <bahamas> dminuoso: that's a definite thing. but I don't have a choice, since this project needs to run on Spark and the only way to do that is through Sparkle, which relies inline-java, jvm, jni and so on
07:10:16 <bahamas> int-e: can you clarify what you mean?
07:10:58 <int-e> I'm assuming that the record type is a Haskell type... what do you want to happen on the Java side? I suspect you're trying to do something that the library doesn't support, namely synthesize a Java class for a given record type. As far as I can see (I may well be wrong, I'm only skimming the code...) the library is exclusively for accessing existing java classes and their instances from Haskell.
07:12:20 * hackage biohazard 2.0 - bioinformatics support library  https://hackage.haskell.org/package/biohazard-2.0 (ustenzel)
07:12:51 <bahamas> int-e: my use case is that I want to implement the following in Haskell: read some logs from S3 which contain JSON. decode the JSON to a `Session` type, which is a Haskell record type as you correctly assumed. then, process this session type. at the end, convert it back to JSON and write it in some storage options
07:13:40 <int-e> ... and where does Java come in here?
07:13:45 <bahamas> int-e: indeed the examples I've found only show interacting with Java code. I just assumed that since Sparkle allows you to run Haskell on Spark, it would provide a way to run any valid Haskell code
07:13:51 <Solonarv> this may seem like a silly question, but do you even need Spark?
07:14:36 <bahamas> int-e: Spark is a Java app
07:14:46 <bahamas> Solonarv: what would be the alternative? Cloud Haskell?
07:14:56 <Solonarv> as a rule of thumb, distributed computing (e.g. Spark) is probably not the right approach if your data fits onto a single computer, definitely not the right approach if it fits into RAM
07:15:04 <bahamas> or are you suggesting not using a distributed approach at all
07:15:17 <Solonarv> if the logs are not too large that is indeed what I am suggesting
07:15:40 <Solonarv> you haven't said how large they are, though
07:17:04 <bahamas> Solonarv: I don't know yet. I was brought on this project when Spark was already in use. there is a current service running on Spark. it's just written in Python
07:17:47 <bahamas> so I'm assuming that the people who made the choice knew what they were doing
07:17:58 <Solonarv> I wouldn't be so quick to assume that
07:18:42 <Solonarv> but okay, let's say you don't want to fight that fight
07:19:12 <bahamas> Solonarv: I know what you mean, but my interactions with them lead me to believe they know what they're doing. these logs involve payment processing, so I'm assuming the volume is huge
07:19:58 <Solonarv> hm, could be
07:19:58 <bahamas> so the logs are between 3GB in an hour to 24GB in an hour
07:22:04 <bahamas> Solonarv: yes, do you have any suggestions for tackling this fight?
07:22:15 <int-e> bahamas: I'd expect to go though 'new' to create a new Session object from the record, or perhaps through 'call' for updating the fields. Coercible seems to be designed for primitive data types. I mean, just read  https://github.com/tweag/inline-java/blob/494a37a9956eb1ed47dcf3706799e2dbf0252e13/jvm/src/Language/Java.hs#L174-L176 ...
07:23:01 <int-e> Anyway. As indicated earlier, I don't really know. I've never used that library and I don't want to play around with it now either.
07:23:10 <Solonarv> bahamas: no suggestion other than "encode it as a byte[] on the java side, it doesn't need to be inspected"
07:23:21 <Solonarv> which I believe was already suggested :P
07:24:20 <bahamas> int-e: and Solonarv actually, I already did that part, i.e. encode Session as a bytestring using `Binary.encode`. the problem is that because of `Json.decode`, I also need to handle `Maybe Session`. that's where I got stuck
07:26:21 <Solonarv> it looks like you should be able to write a 'Coercible a => Coercible (Maybe a)' instance using Optional on the java side
07:26:41 <Solonarv> (this should be provided by inline-java, but doesn't seem to be)
07:27:41 <Solonarv> and then you can write a separate 'Coercible Session' instance which just translates to byte[]
07:28:09 <Solonarv> in the end your java-side type is Optional<byte[]>, or - because of type erasure - simply Optional
07:30:11 <int-e> https://github.com/tweag/inline-java/blob/494a37a9956eb1ed47dcf3706799e2dbf0252e13/jni/src/Foreign/JNI/Types.hs#L260-L269 is in almost direct correspondence with the Coercible instances. I'm sure that's not an accident.
07:30:17 <bahamas> Solonarv: Coercible or Reflect and Reify. that's what the current error is complaining about
07:30:32 <int-e> I'm really quite convinced that you're trying to abuse Coercible for something it wasn't meant for.
07:30:49 <bahamas> int-e: yeah. that's what I wanted to say. there's no constructor for creating an Array there
07:31:50 * hackage servant-elm 0.6.0.1 - Automatically derive Elm functions to query servant webservices.  https://hackage.haskell.org/package/servant-elm-0.6.0.1 (k_bx)
07:31:52 <Solonarv> ah yes, it looks like you want Reify/Reflect instead
07:33:05 <Solonarv> strangely enough there is no instance for Maybe
07:37:56 <int-e> Hmm... https://github.com/tweag/inline-java/blob/494a37a9956eb1ed47dcf3706799e2dbf0252e13/jvm/src/Language/Java.hs#L581-L586 (one of the more obscure features of unsafeDupablePerformIO is that the IO actions can be stopped in the middle... so potentially the deleteLocalRef is called less often than the findClass...
07:40:32 <int-e> (That happens without raising an exception. But then again the code is obviously not exception safe either. It's probably not a huge deal anyway, in this particular case.)
07:41:04 <bahamas> ok, this is strange. I tried this implementation and I'm getting an error about a missing instance. https://bpaste.net/show/e1e6f799fb90
07:42:31 <int-e> ... arising from a use of ‘RDD.map’
07:42:41 <int-e> so what is RDD?
07:44:10 <int-e> (it doesn't occur in the paste, so I'll assume it's unrelated)
07:44:36 <bahamas> int-e: https://github.com/tweag/sparkle/blob/master/src/Control/Distributed/Spark/RDD.hs
07:44:44 <bahamas> it's a Spark data type
07:46:20 * hackage hasql-implicits 0.1.0.1 - Implicit definitions for Hasql, such as default codecs for standard types  https://hackage.haskell.org/package/hasql-implicits-0.1.0.1 (NikitaVolkov)
07:46:26 * shapr hops cheerfully
07:46:29 <shapr> Good morning #haskell !
07:46:33 <bahamas> RDD.map calls my processSession function which does the JSON decoding and all the processing.
07:48:03 <int-e> bahamas: Well I have no clue where the Static class comes from.
07:51:48 <halogenandtoast> Is there a more elegant way to write: draw :: Int -> Deck -> ([Card], Deck); draw c = take c . getDeck &&& Deck . drop c . getDeck
07:52:34 <shapr> semi-ontopic: I'm building a research paper annotation tool, is DOI the best unique id for a publication? Anyone know if there's a title -> DOI tool or API?
07:52:42 <Rembane> halogenandtoast: There's a function Data.List which I have forgotten tha name of which does that at the same time. 
07:52:58 <Rembane> halogenandtoast: splitAt is the name. 
07:53:20 * hackage bytestring-strict-builder 0.4.5.3 - An efficient strict bytestring builder  https://hackage.haskell.org/package/bytestring-strict-builder-0.4.5.3 (NikitaVolkov)
07:53:35 <halogenandtoast> Rembane: right, that is a thing isn't it!
07:53:41 <halogenandtoast> Rembane: no idea how I forgot that
07:53:41 <Rembane> :t splitAt 
07:53:43 <lambdabot> Int -> [a] -> ([a], [a])
07:53:51 <Rembane> halogenandtoast: It's appearantely easy to forget. 
07:53:56 <Solonarv> draw c = second Deck . splitAt c . getDeck
07:55:26 <bahamas> int-e: it comes from here https://hackage.haskell.org/package/distributed-closure-0.4.1.1/docs/Control-Distributed-Closure.html#t:Static
07:56:08 <int-e> Yeah the Static class is this one, presumably: http://hackage.haskell.org/package/distributed-closure-0.4.1.1/docs/Control-Distributed-Closure.html#t:Static  I'd hope you can use withStatic in analogy to  https://github.com/tweag/inline-java/blob/494a37a9956eb1ed47dcf3706799e2dbf0252e13/jvm/src/Language/Java.hs#L529 ff.
07:56:37 <halogenandtoast> Solonarv: thanks for the implementation, I would have had to find second (don't use Bifunctor as much as I should probably)
07:58:40 <dmwit> halogenandtoast: `draw = coerce splitAt`, I think
07:59:08 <dmwit> Oh, I see I've been beaten to the punch.
07:59:53 <dmwit> % :t splitAt @[Bool]
07:59:53 <yahb> dmwit: Int -> [[Bool]] -> ([[Bool]], [[Bool]])
08:00:00 <dmwit> % data Card
08:00:00 <yahb> dmwit: 
08:00:06 <dmwit> % :t splitAt @Card
08:00:06 <yahb> dmwit: Int -> [Card] -> ([Card], [Card])
08:00:18 <dmwit> So `coerce (splitAt @Card)` then.
08:01:34 <Rembane> :t coerce
08:01:35 <lambdabot> error:
08:01:35 <lambdabot>     • Variable not in scope: coerce
08:01:35 <lambdabot>     • Perhaps you meant ‘coerced’ (imported from Control.Lens)
08:02:03 <bahamas> int-e: do I need to enable anything other than TemplateHaskell? I'm getting a parse error on the first `instance` keyword
08:02:07 <dmwit> % :t coerce
08:02:07 <yahb> dmwit: Coercible a b => a -> b
08:02:20 <dmwit> % newtype Deck = Deck { getDeck :: [Card] }
08:02:21 <yahb> dmwit: 
08:02:24 <Rembane> Interesting. I can still find it on Hoogle. 
08:02:38 <bahamas> eh, nevermind. I switched d|
08:02:46 <dmwit> % f :: Int -> Deck -> ([Card], Deck); f = coerce (splitAt @Card)
08:02:46 <yahb> dmwit: 
08:03:15 <Rembane> I need to use coerce much more in my code, thank you dmwit ! 
08:03:25 <dmwit> yay!
08:03:59 <bahamas> wowk, it actually compiled. I think that was it
08:11:40 <bahamas> int-e: Solonarv: thank you so much for your help!
08:11:42 <halogenandtoast> dmwit: just for clarification I need TypeApplications for that right?
08:13:59 <dmwit> yep
08:14:11 <dmwit> You can do it without, but it's more verbose.
08:14:56 <dmwit> % f :: Int -> Deck -> ([Card], Deck); f = coerce (splitAt :: Int -> [Card] -> ([Card], [Card]))
08:14:56 <yahb> dmwit: 
08:18:01 <dmwit> % data Card = TenOfHearts; newtype Deck = Deck { getDeck :: [Card] }
08:18:01 <yahb> dmwit: 
08:18:32 <dmwit> % f :: Int -> Deck -> ([Card], Deck); f = coerce ((\g -> const g (g 0 [TenOfHearts])) splitAt) -- yikes
08:18:32 <yahb> dmwit: 
08:19:03 <dmwit> (Don't do that.)
08:19:51 <dmwit> (Besides being completely inscrutable, it isn't free and so you've lost the benefit of using coerce in the first place and might as well use the other excellent suggestion by Solonarv.)
08:23:51 * hackage tintin 1.10.0 - A softer alternative to Haddock  https://hackage.haskell.org/package/tintin-1.10.0 (NickSeagull)
08:24:50 <halogenandtoast> Strangely I can not see anything yahb is typing aside from dmwit's name
08:24:55 <halogenandtoast> Is there some encoding issue going on?
08:25:25 <halogenandtoast> or is there no output
08:25:42 <halogenandtoast> (I now realize yahb probably stands for yet another haskell bot)
08:26:07 <Solonarv> halogenandtoast: that's just an empty output
08:26:28 <Solonarv> ghci doesn't output anything when you enter a definition
08:28:32 <halogenandtoast> roger
08:28:54 <halogenandtoast> I didn't realize initially that yahb was a bot
08:29:03 <halogenandtoast> The old bot used to be named something different
08:29:21 <halogenandtoast> (lambda I think)
08:31:17 <sm> bots should be named bot
08:31:20 <nshepperd_> lambdabot is still here
08:31:21 <Solonarv> oh, lambdabot is still around
08:31:30 <Solonarv> they're not quite the same
08:34:18 <Solonarv> lambdabot evaluates Safe Haskell expressions and has a bunch of miscellaneous extra functionality; yahb is an interface to an actual GHCi session running on an actual server
08:44:12 <halogenandtoast> > 1 + 2
08:44:14 <lambdabot>  3
08:44:28 <halogenandtoast> Good ol' Safe Haskell expressions
08:46:03 <lyxia> > a + b
08:46:06 <lambdabot>  a + b
08:48:14 <dminuoso> Solonarv: An actual server? As opposed to.. what exactly?
08:48:38 <sarahzrf> i think that's just paired with "actual GHCi session" :p
08:51:45 <Solonarv> indeed
08:54:21 <dmwit> halogenandtoast: Nevertheless the empty replies carry information: specifically, because there was no type error reported, ghci accepted that my definitions type-checked.
08:55:16 <dmwit> halogenandtoast: I used yahb instead of lambdabot because I think coerce is not available in lambdabot (and TypeApplications is not available in lambdabot).
09:16:56 <tabaqui> why haskell template cannot deal with types defined before?
09:22:27 <shapr> tabaqui: I don't exactly understand your question, but from what I know, Template Haskell needs access to the type table. So I'm guessing types erasure means you can't work with those types anymore?
09:27:17 <Solonarv> actually the questions is wrong - TH *does* have access to types defined earlier
09:27:44 <shapr> tabaqui: do you have code to demonstrate the problem?
09:31:37 <Solonarv> example:
09:31:37 <Solonarv> % writeFile "THTest.hs" "{-# LANGUAGE TemplateHaskell #-} module THTest(fooInfo) where\n data Foo = MkFoo\nfooInfo = $(stringE . show =<< reify ''Foo)"
09:31:37 <yahb> Solonarv: 
09:31:43 <Solonarv> % :l THTest.hs
09:31:43 <yahb> Solonarv: [1 of 1] Compiling THTest ( THTest.hs, interpreted ); THTest.hs:3:1: error: parse error on input `fooInfo'; |; 3 | fooInfo = $(stringE . show =<< reify ''Foo); | ^^^^^^^; Failed, no modules loaded.
09:32:09 <Solonarv> % writeFile "THTest.hs" "{-# LANGUAGE TemplateHaskell #-}\nmodule THTest(fooInfo) where\n data Foo = MkFoo\nfooInfo = $(stringE . show =<< reify ''Foo)"
09:32:10 <yahb> Solonarv: 
09:32:13 <Solonarv> % :l THTest.hs
09:32:13 <yahb> Solonarv: [1 of 1] Compiling THTest ( THTest.hs, interpreted ); THTest.hs:4:1: error: parse error on input `fooInfo'; |; 4 | fooInfo = $(stringE . show =<< reify ''Foo); | ^^^^^^^; Failed, no modules loaded.
09:32:30 <Solonarv> huh? one sec
09:34:31 <Solonarv> oh really, that doesn't work? I'm very surprised.
09:36:18 <int-e> Solonarv: you have a stray space before 'data'
09:36:31 <Solonarv> I know, I fixed it in PM
09:36:39 <Solonarv> % :l THTest.hs
09:36:40 <yahb> Solonarv: [1 of 1] Compiling THTest ( THTest.hs, interpreted ); THTest.hs:5:13: error:; * `Foo' is not in the type environment at a reify; * In the untyped splice: $(stringE . show =<< reify ''Foo); |; 5 | fooInfo = $(stringE . show =<< reify ''Foo); | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; Failed, no modules loaded.
09:36:52 <Solonarv> getting this now, which is a bit surprising
09:37:13 <int-e> mm
09:37:38 <dminuoso> shapr: TH is executed during parsing in fact.
09:37:57 <dminuoso> This revelation helped me understand what must be possible and what cant be possible in TH.
09:38:35 <Solonarv> well, but this common idiom works:
09:38:35 <Solonarv> data Foo = <whatever>
09:38:35 <Solonarv> $(makeLenses ''Foo)
09:39:10 <dminuoso> Solonarv: The problem you stepped into is related to the declaration groups I think.
09:39:48 <int-e> Solonarv: yeah, that's odd. Putting a  $([d| |]) before fooInfo helps...
09:39:59 <Solonarv> oh wow, that's really weird.
09:40:24 <dminuoso> int-e: Did you get my message regarding the backjumps about lambdabot by the way?
09:40:30 <int-e> I guess only top-level splices delimit the TH stages.
09:40:57 <dminuoso> int-e: Well the declaration is not yet fully finished parsing..
09:41:42 <unrooted[m]> watcha doin my Haskell friends?
09:41:43 <unrooted[m]> any nice project to do in Haskell to show that I understand it?
09:41:44 <int-e> oh I'm allwed to write [d| |] (bare top-level splice...)
09:41:44 <unrooted[m]> simple project ofc
09:41:48 <unrooted[m]> https://wiki.haskell.org/Roll_your_own_IRC_bot
09:41:49 <unrooted[m]> maybe something simpler?
09:41:53 <int-e> dminuoso: I must have missed it
09:41:59 <dminuoso> unrooted[m]: Write software that is useful to you.
09:42:03 <dminuoso> unrooted[m]: Or that you need or enjoy writing.
09:42:21 <dminuoso> unrooted[m]: Do you have a favourite subject? Are you perhaps studying some field of math to write programs for?
09:42:43 <shapr> I'm building a research paper annotation tool
09:43:03 <dminuoso> int-e: So I dug some deeper and realized that vault (through lens) together with warp created a scenario to try out many thousand combinations quickly draining backjump ticks
09:43:24 <dminuoso> int-e: Building with `-v3` revealed the many backjumps.
09:43:34 <dminuoso> Didn't seem pathological
09:43:51 <int-e> fun :(
09:44:40 <dminuoso> int-e: Is the problem still there with HEAD on lambdabot?
09:44:55 <int-e> HEAD... of cabal-install?
09:45:27 <dminuoso> int-e: didn't you say that you had the backjump exhaustion when building lambdabot?
09:45:30 <int-e> I have a ticket for lambdabot here, https://github.com/lambdabot/lambdabot/issues/183
09:45:42 <dminuoso> int-e: Ah great, cheers.
09:45:47 <unrooted[m]> <dminuoso "unrooted: Do you have a favourit"> man I'm 15yo
09:46:03 <Solonarv> you can have interests at 15 ;)
09:46:31 <dminuoso> unrooted[m]: Writing software that you enjoy using helps with the motivation a lot.
09:46:50 * hackage network-multicast 0.3.2 - Simple multicast library  https://hackage.haskell.org/package/network-multicast-0.3.2 (AudreyTang)
09:46:51 <dminuoso> (Or contributing to software that you use and/or enjoy)
09:47:46 <Solonarv> unrooted[m]: 15 is about the age I started to dive really into programming, the big drive was modding and making games
09:48:13 <unrooted[m]> I like aviation, photography, coffee and functional programming
09:48:14 <unrooted[m]> oh, I got an idea
09:48:17 <unrooted[m]> CLI based drinked coffee stats
09:48:24 <unrooted[m]> is there a way to write something like that? I mean, command `+cup` will add cup of coffee into the statistics of drinked coffees and statistics will reset at 12am
09:48:25 <unrooted[m]> wdyt?
09:49:05 <zincy> good interests
09:49:56 <dminuoso> unrooted[m]: Go for it then.
09:50:07 <Solonarv> seems very doable
09:50:15 <unrooted[m]> nice then I think
09:50:52 <dminuoso> int-e: it seems like a regression on cabal-install
09:51:48 <zincy> there must be a way of automating the `+cup` part
09:52:06 <unrooted[m]> HMM
09:52:08 <unrooted[m]> I don't think so
09:52:15 <unrooted[m]> I mean,there isn't a way
09:52:16 <int-e> dminuoso: I suspect that to some extent this kind of thing is unavoidable... the underlying dependency resolution problem is NP-complete after all. And we are dealing with packages with hundreds of versions. The annoying bit is that it's really hard to figure out what changed and triggered the bad behavior. It can be simply a new package version, but hackage revisions can also make the search...
09:52:22 <int-e> ...harder.
09:52:51 * hackage haskoin-store 0.16.1 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.16.1 (xenog)
09:52:52 <zincy> probably not. Was thinking of some connected coffee machine but even then you get false positives
09:52:57 <Solonarv> well, there is a way for sure, but not using Haskell
09:53:08 <Solonarv> (at least not Haskell alone)
09:53:20 <Solonarv> you could have some sort of "smart coffee cup" I guess :P
09:53:25 <zincy> Solonarv: interested in hearing more
09:53:39 <Solonarv> zincy: too bad, that's all I had :P
09:53:48 <int-e> (and from a SAT solver perspective, 1000 backjumps are nothing)
09:53:56 <int-e> or 5000 for that matter
09:53:58 <dminuoso> int-e: Its the exact same packages.
09:54:08 <zincy> Solonarv: Sent that message too late. Good idea though
09:54:22 <zincy> Cup gets hot and sends a request to aserver
09:54:28 <unrooted[m]> then, it shall use computer's camera and detect coffee cup that has been drinken by the computer right in front of the computer
09:54:32 <int-e> dminuoso: sorry I'm missing a step here. did you try different cabal-install versions?
09:54:50 <dminuoso> int-e: Yes but it triggers for all. I did a mistake.
09:54:51 <zincy> unrooted[m]: I would start with the manual +cup way first
09:55:18 <zincy> unrooted[m]: Add things on after that are complex otherwise you may never start :D
09:55:35 <zincy> just giving food for thought
09:56:13 <dminuoso> int-e: The triple hashable/vault/wai is both the cause in my package as well as yours.
09:58:41 <int-e> (Hmm, cabal update  supports timestamps, so we can bisect the hackage database and find the point where 2k backjumps were no longer enough. Though the more interesting question is whether there was a sharp jump or a steady growth over time. Can cabal-install print the number of back-jumps it used?)
10:00:00 <unrooted[m]> if you get a guests, you make more coffee haha
10:00:03 <unrooted[m]> <zincy "probably not. Was thinking of so"> yeah
10:00:04 <unrooted[m]> <zincy "unrooted: Add things on after th"> okie
10:00:10 <unrooted[m]> any ways how to do that +cup?
10:01:31 <edwardk> if you want an exercise in frustration, accidentally give a project in another folder of your cabal.project the same name as another project (e.g. while copying/pasting a .cabal file into another folder) and forget about it
10:01:49 <edwardk> you can get all sorts of impossible seeming errors that are fun for the whole family to try to debug
10:02:00 <zincy> haha
10:02:28 <edwardk> i spent an hour trying to figure out why cabal couldn't find directories that were right in front of its face.
10:02:32 <zincy> maybe that will be our new family game at xmas
10:02:53 <dminuoso> edwardk: Mmm, what exactly went wrong?
10:03:43 <zincy> unrooted[m]: Have a long running command line program that waits for you to input "+cup" and then hit enter
10:03:53 <edwardk> https://www.irccloud.com/pastebin/AdyUgFxR/
10:04:32 <edwardk> which gives no indication that the 'raw' it is looking for is actually in lib/harfbuzz-freetype, a half-finished stub project i'd just started
10:05:20 <edwardk> https://www.irccloud.com/pastebin/nM56L63M/
10:05:26 <edwardk> being the example in larger context =)
10:07:16 <zincy> I need some advice - I have coded myself into a corner with type families https://github.com/therewillbecode/Bluffy/blob/master/src/Lib.hs
10:08:04 <edwardk> zincy: yes, yes you did
10:08:14 <zincy> how do I get out the maze?
10:09:07 * edwardk introduces zincy to the idea of ADTs. No, no, not GADTs, ADTs. =)
10:09:58 <edwardk> Making impossible states unrepresentable is a laudable goal but you still need to make the ones you want to have be possible, possible to represent, too. ;)
10:10:21 <edwardk> pwd
10:10:26 <edwardk> er wrong window
10:10:36 <dminuoso> edwardk: Still curious. I take it `raw` is a dependency that you happened to have copied its cabal file from into that other project?
10:10:50 <edwardk> let me dig up the dir
10:11:10 <edwardk> https://github.com/ekmett/codex/tree/master/lib/harfbuzz
10:11:39 <edwardk> now, in preparation for some additional work i went and copied lib/harfbuzz/harfbuzz.cabal to lib/harfbuzz-freetype/harfbuzz-freetype.cabal
10:11:53 <edwardk> but then got distracted before doing anything more.
10:12:01 <edwardk> but the name _in_ the cabal file was harfbuzz
10:12:39 <edwardk> so when the top level cabal.project file kicked in which includes . and lib/*   it found both harfbuzzes
10:13:06 <dminuoso> Ohh I see. Interesting, I was not aware of that lib/* mechanism. 
10:13:06 <edwardk> and for giggles decided the other one won
10:15:09 * edwardk is lost in a twisty mage of packages related to fonts and glyphs and shaping all alike.
10:15:17 <dminuoso> edwardk: I can see the amounts of fun you can draw from this. How did you determine that it was picking up the "wrong" library? dtrace? cabal debugging?
10:15:29 <Rembane> edwardk: Have you been nerd sniped? 
10:15:37 <edwardk> Rembane: its a sub-project =)
10:15:46 <int-e> dminuoso: but I see what you're saying... base, hashable, vault, wai and also base, hashable, vault, warp are the most frequent backjumps :)
10:15:53 <dminuoso> int-e: Yup.
10:15:53 <Rembane> edwardk: Sweet! 
10:16:02 <edwardk> i just want to print pretty text and be done with it correctly forever, is that too much to ask?
10:16:21 <shachaf> edwardk: You haven't come to the conclusion that rendering text is impossible yet?
10:16:30 <edwardk> i'm pretty close to that view
10:16:50 <shachaf> I've been there for a while.
10:16:58 <shachaf> It's definitely at least NP-hard.
10:17:15 <edwardk> you should never have infected me with that harfbuzz prion. now have of my text is the wrong way around and i don't even speak any of the languages for which that matters!
10:17:15 <int-e> dminuoso: 5 days ago 7 backjumps were needed!
10:17:25 <edwardk> er now half
10:17:28 <int-e> (for new-install lambdabot in lambdabot's HEAD)
10:17:48 <dminuoso> int-e: Is it possible some bound got changed in the set of "warp/wai/hashable/vault"
10:18:00 <dminuoso> int-e: Oh wait. I should be able to recover my old cabal new store and then compare.
10:18:02 <int-e> dminuoso: yeah. I'm bisecting :)
10:18:42 <edwardk> dminuoso: nothing so sophisticated. i just stared at it really hard, and progressively started to doubt my sanity more and more
10:19:27 <dminuoso> edwardk: The Feynman algorithm at work!
10:20:30 <edwardk> now i just need to figure out how to get _users_ to be able to install fontconfig, freetype and harfbuzz and icu4c all in a consistent manner in such a way that i can link against them
10:20:44 <edwardk> freetype <-> harfbuzz have a circular dependency, so you need to install freetype twice typically
10:20:50 <shachaf> Just link statically.
10:21:23 <edwardk> icu4c is basically impossible on a mac, because it doesn't get told to pkg-config, so now users need to add an extra line to their .profile to find it..
10:21:30 <shachaf> Oh, you're talking about library users.
10:21:39 <edwardk> harfbuzz needs icu4c installed beforehand toget the harfbuzz-icu parts...
10:21:46 <edwardk> shachaf: yes
10:22:20 <edwardk> fontconfig needs freetype installed to give me some support for constructing freetype faces directly..
10:24:22 <edwardk> basically the entire font ecosystem deserves to die a fiery death, but it is being held out of the flames by the behdad esfahbod single-handedly. if he was 20% less competent, text on the interwebs would cease to exist and we'd have to communicate in pictures.
10:24:35 <edwardk> er by behdad
10:25:03 <dminuoso> int-e: The regression occured on the 28th of may between 06 and 16:00 UTC
10:25:05 <edwardk> except for the fact that the major way we communicate through pictures these days is emoji... and he has his hand in there too!
10:25:13 <dminuoso> int-e: *23th!
10:25:52 <dminuoso> Is there a list to see what updates were uploaded to hackage on a given date?
10:26:10 <int-e> dminuoso: last good state 2019-05-23T08:29:28Z first bad state 2019-05-23T08:35:02Z is what I have now...
10:26:20 <dminuoso> int-e: Ah okay.
10:26:31 <dminuoso> int-e: Lets dig in IRC logs perhaps to see if hackage made any reports?
10:26:50 <edwardk> we used to have a bot sit in here and tell us
10:27:03 <edwardk> then people got sick of me spamming out 50 package updates a day on channel ;)
10:27:18 <Rembane> It does still tell us, but it bunches up the news. 
10:27:24 <edwardk> now ryanglscott does 100, but no bot
10:27:28 <dminuoso> And it filters out updates by edward.
10:27:30 <edwardk> ah
10:27:32 <dminuoso> :-p
10:29:29 <int-e> dminuoso: https://hackage.haskell.org/package/unordered-containers has a new version with that timestamp
10:29:50 <int-e> dminuoso: ... which is the first version not to exclude hashable-1.3
10:30:37 <dminuoso> int-e: https://github.com/tibbe/unordered-containers/commit/29e48855408f2da55463afe2936f50b5943e7cf9
10:30:39 <dminuoso> Indeed.
10:31:24 <int-e> and indeed with --constraint=hashable\<1.3 I'm back to 7 backjumps
10:31:50 <dminuoso> int-e: The real question is, why is the regression so unbelievably bad if you relax hashable to 1.4?
10:32:03 <dminuoso> I mean 7 backjumps to 2000 is not just a bad case of "gotten slightly worse"
10:34:03 <int-e> dminuoso: well it selects hashable-1.3 at depth 80 (I think the first number is the depth?) and finally starts finding conflicts at depth 207...
10:34:41 <unrooted[m]> using stack on Windows rn
10:34:45 <unrooted[m]> how to add modules with Stack?
10:34:57 <unrooted[m]> I can't find any nice answer
10:35:07 <dminuoso> int-e: what does the depth measure?
10:35:39 <dminuoso> int-e: Is each "level" a sort of candidate that is currently being tried?
10:35:52 <dminuoso> (And each level checking dependencies..)
10:36:21 <int-e> dminuoso: I'm not sure, but if this is anything resembling DPLL then it should be the number of package versions currently selected (some inferred, some by making a decision that can be retracked later)
10:36:41 <int-e> length of the trail in DPLL parlor.
10:36:48 <dminuoso> Ah
10:41:17 <dminuoso> int-e: Im thinking a hotfix could be if vault was bumped to allow for hashable-1.3.*
10:41:40 <int-e> dminuoso: ah, for each version of warp it tries it also tries versions of warp-tls, and only then finds a conflict involving vault. so that's how that particular conflict set (hashable, vault, warp) appears so often.
10:41:45 <dminuoso> int-e: Because a lot of the backtracking happens because so many versions of warp and wai are tried, that all faul on hashable (because hashable-1.4 is selected early on)
10:41:58 <dminuoso> int-e: Ah yeah, I was on the same track there.
10:42:30 <int-e> and on a level before that it iterates through hoogle versions. beautiful. learning would help :)
10:42:37 <int-e> (clause learning, CDCL)
10:42:52 <dfeuer> Is there a nice way to combine finite state machines? Something like   Pipe a a' (StateT s m) p -> Pipe b b' (StateT t m) q -> Pipe (Either a b) (Either a' b') (StateT (s,t) m) (p, q) ?
10:43:10 <int-e> but that's enough to be on the order of 10^3 already.
10:43:45 <dfeuer> I'm not seeing such combinators in libraries, except in one obscure and overly pure FSM package. But maybe I'm missing the obvious pattern for doing it.
10:45:35 <dminuoso> int-e: So as far as I can t selects hashable-1.3 early on (because its the most recent presumably), and then for each warp-tls version it tries every warp version, and then it tries every vault version.. rejecting the conflict with the earlier picked hsahable.
10:45:43 <dminuoso> *as I can see it
10:45:44 <int-e> dminuoso: hmm, with vault out of the way there's base, hashable, http2, psqueues, time.
10:46:21 <int-e> so psqueues is another relevant package depending on hashable.
10:48:55 <lyxia> dfeuer: this looks like something you can build on top of zipConduit https://hackage.haskell.org/package/conduit-1.3.1.1/docs/Data-Conduit.html#t:ZipConduit
10:49:00 <dminuoso> int-e: It seems that the core issue is that one of the most dependet upon dependencies got bumped... and some packages have upgraded the bounds on it, others dont.
10:49:04 <int-e> and uniplate. that's it for lambdabot :)
10:49:54 <dminuoso> int-e: Over time the issue should dissipate as more and more packages allow for hashable < 1.3 (since each relaxed bound eases on the backtracking)
10:51:43 <dfeuer> lyxia: yeah, that looks pretty close. It's missing the fact that each input is only directed to *one* processor, but okay.... OTOH, I'm a bit wary of Conduit in general.
10:52:11 <dminuoso> I guess if a new version of `vault` was released most of the pain would disappear.
10:57:35 <unrooted[m]> wait a sec guys
10:57:45 <unrooted[m]> I'm not into that much
10:57:45 * unrooted[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/vgMIgHeWZwPTgYhlSWRiPMAR >
10:57:49 <unrooted[m]> how to use modules and shit?
10:59:50 <cocreature> unrooted[m]: there is no module called Network, at least not in any particularly popular package. the "network" package has a module called Network.Socket so maybe you are looking for that?
11:01:45 <int-e> dminuoso: I updated the lb issue :)
11:07:24 <dmwit> unrooted[m]: One possible misconception, especially from those coming from Python and Java, is that there might be a way to say something like "import Foo.Bar and Foo.Baz and all the other Foo.* stuff", perhaps with the syntax "import Foo".
11:08:09 <dminuoso> int-e: Great, Im writing a vault issue for others to stumble onto (and as a nice ask for the author to release his new version)
11:08:14 <dmwit> But in Haskell, `.` has no special significance in module names. So just like you can't write "import Foo" and expect to get modules FooSBar and FooSBaz, you also can't write "import Foo" and expect to get modules Foo.Bar and Foo.Baz.
11:09:21 <reallymemorable> If I have a function that works like the following: Frequency -> Maybe (IntervalMap (Endpoint Day) Double) 
11:09:22 <int-e> dminuoso: uh I just made a vault issue
11:09:28 <int-e> dminuoso: and psqueues, and uniplate
11:09:29 <reallymemorable> How can I pull out the `Double`?
11:09:50 <dmwit> Can't. (There might not even be one!)
11:09:56 <dminuoso> int-e: Ah. :)
11:10:17 <dminuoso> int-e: Great then.
11:10:29 <dmwit> If there's a `Functor` instance for `IntervalMap k`, then you could `fmap (fmap (fmap foo))` where `foo :: Double -> X`.
11:11:34 <dmwit> (If `foo :: Double -> X` then `fmap (fmap (fmap foo)) :: (Frequency -> Maybe (IntervalMap (EndPoint Day) Double)) -> Frequency -> Maybe (IntervalMap (EndPoint Day) X)`.)
11:12:03 <Solonarv> ...although that doesn't "pull out" anything, really - it *modifies*
11:12:11 <reallymemorable> hmm
11:12:17 <reallymemorable> I need to just have a Double at the end
11:12:37 <Solonarv> well, what do you do if the functions returns Nothing ?
11:12:52 <reallymemorable> Well its a Maybe Double
11:13:01 <int-e> dminuoso: anyway, thanks a lot for the discussion!
11:13:07 <int-e> (and reminder)
11:13:33 <Solonarv> aaah, okay.
11:13:48 <dminuoso> int-e: You seemed to have done most of the work, so thank you for making Haskell a better place. :)
11:13:51 <dmwit> reallymemorable: And what do you do if the IntervalMap has multiple keys?
11:13:56 <Solonarv> so really you want to pull out a Double from an 'IntervalMap (Endpoint Day) Double', yes?
11:14:08 <reallymemorable> dmwit - they are singletons
11:14:17 <reallymemorable> Solonarv - yes
11:14:41 <dmwit> reallymemorable: Then leastView will get you where you need to go.
11:14:52 <Solonarv> ah, so picking some arbitrary key-value pair should work
11:15:06 <Solonarv> dmwit: this is an IntervalMap, not a Map - are you sure it even has a leastView?
11:15:26 <dmwit> It isn't called leastView for Map!
11:15:34 <dmwit> That one is minView. =)
11:15:34 <Solonarv> ah, true!
11:15:49 <reallymemorable> I already did a transformation to get to Frequency -> Maybe (IntervalMap (EndPoint Day) x_
11:16:21 <reallymemorable> i dont want to key back into the interval map
11:16:28 <dmwit> \f freq -> do { im <- f freq; ((_, d), _) <- leastView im; return d }
11:17:03 <reallymemorable> sorry dmwit -- what is that?
11:17:08 <reallymemorable> i am still new to this
11:17:12 <Solonarv> ah, looks like it's called minView for IntervalMap as well
11:17:30 <dmwit> Solonarv: https://hackage.haskell.org/package/fingertree-0.1.4.2/docs/Data-IntervalMap-FingerTree.html#t:leastView ?
11:17:38 <dmwit> Perhaps there is more than one IntervalMap.
11:17:42 <Solonarv> ah, I was looking at IntervalMap
11:17:46 <Solonarv> (that's the package name)
11:18:13 <dmwit> reallymemorable: It is a function of type `(Frequency -> Maybe (IntervalMap (EndPoint Day) Double)) -> (Frequency -> Maybe Double)`.
11:18:26 <int-e> dminuoso: yeah but your input actually triggered the investiagtion. I was so close to just stick --reorder-goals into the .travis.yml file :)
11:18:29 <dmwit> ...if your IntervalMap is from the fingertree package. =P
11:18:39 <reallymemorable> yes it is
11:19:54 <Solonarv> well, there you go :D
11:20:06 <dmwit> But I protest: if you know your thing returns only singletons, then your thing has got the wrong type and the wrong implementation.
11:20:25 <reallymemorable> what do you mean
11:20:46 <reallymemorable> I'm using singletons for testing purposes
11:21:01 <reallymemorable> i figured that i would get to the rest after i could make it work wiht a single record
11:21:05 <dmwit> Why `Frequency -> Maybe (IntervalMap (EndPoint Day) Double)` instead of `Frequency -> Maybe (EndPoint Day, Double)`?
11:21:44 <reallymemorable> I wish i had an answer
11:21:45 <dmwit> Or: if you plan to graduate past singletons, then surely your consumer should be able to handle non-singletons sensibly, and so you should think longer about my question of "what if there are multiple keys?".
11:21:53 <reallymemorable> thats just how i receive it from the other parts of the codebase
11:23:27 <int-e> dminuoso: oh: https://github.com/haskell/cabal/pull/5886 "Increase `max-backjumps` default from 2000 to 4000"
11:24:03 <int-e> (that one would not have saved lambdabot though...)
11:27:34 * dmwit . o O ( max-backjumps doubles every 18 months )
11:27:50 * hackage merkle-log 0.1.0.0 - Merkle Tree Logs  https://hackage.haskell.org/package/merkle-log-0.1.0.0 (larsk)
11:30:50 * hackage knit-haskell 0.4.0.0 - a minimal Rmarkdown sort-of-thing for haskell, by way of Pandoc  https://hackage.haskell.org/package/knit-haskell-0.4.0.0 (adamCS)
11:33:23 <tabaqui> shapr: sorry, I was away
11:33:35 <tabaqui> you cannot compile such example:
11:33:39 <tabaqui> data Foo
11:33:47 <tabaqui> err, fail
11:33:48 <tabaqui> again:
11:33:56 <tabaqui> $(someTemplate ''Foo)
11:33:57 <tabaqui> data Foo
11:35:07 <Solonarv> oh yes, that's a known restriction
11:35:18 <tabaqui> • Not in scope: type constructor or class `Foo’
11:35:23 <tabaqui> • In the Template Haskell quotation ''Foo
11:35:27 <Solonarv> TH imposes an ordering restriction
11:35:42 <Solonarv> (that's part of why I'm not a huge fan of TH)
11:35:54 <int-e> dminuoso: oh, one can pass --index-state='2019-05-23T08:35:02Z' directly to cabal new-install... that would've saved me a bit of time :)
11:36:33 <tabaqui> Solonarv: is there some strong reason? Like, it is to complicated to impelement pre-processor in case of recursive bla-bla-bla
11:36:57 <Solonarv> I've never looked too deeply into the reason tbh
11:37:04 <Solonarv> it's a limitation of how TH is implemented
11:54:21 <dminuoso> int-e: Ahh that's good to know. I was using `cabal new-update 'hackage...'` to do the bisection (not knowing you were doing it the same way presumably)
11:57:23 <int-e> dminuoso: ah and if you're wondering how I found the unordered-containers update, I did that by looking at the 01-index.tar file with tar tvf and matching the file timestamp.
11:58:44 <dminuoso> int-e: Where is that 01-index.tar file from?
11:59:43 <int-e> ~/.cabal/packages/hackage.haskell.org/ (it may be 02-index.tar now? I'm mixing v1- and v2- commands merrily so I don't really know; the v2- commands use the v1- database if it exists.)
12:00:30 <monochrom> 01.  It's v1 ~ 00, v2 ~ 01.
12:00:38 <int-e> thanks
12:01:01 <phadej> not really even so
12:01:12 <phadej> 00=insecure, 01=secure
12:01:16 <monochrom> Ah.
12:01:20 <phadej> recent enough cabal uses 01 always
12:01:57 <dminuoso> phadej: Ah its interesting. You were even directly responsible for my backjump bug the other day. :-P
12:03:06 <monochrom> "00-index" came from the bygone era of public FTP servers on which they want to give you a list of the files they have, and to make sure it is alphabetically the first file so you don't have to hunt for it, start with "00".
12:03:38 <monochrom> "00-readme.txt" was also popular, likewise.
12:04:23 <phadej> Hackage is old tech :)
12:05:19 <int-e> old tech that is still in use is good. except for FTP.
12:06:03 <dminuoso> and telnet
12:06:07 <phadej> i already forgot what's bad in FTP, but whatever
12:06:11 <dminuoso> and HTTP
12:06:35 <int-e> (I'm only half kidding. The bad thing about modern technology is that it tends to be awfully complex.)
12:06:45 <monochrom> I wouldn't call FTP bad, but its default behaviour is incompatible with firewalls.
12:06:56 <boj> plain text auth
12:06:57 <phadej> firewalls are bad :)
12:07:14 <phadej> boj: you can have sFTP
12:07:20 <boj> that is true
12:07:20 <phadej> the same way there is https
12:07:29 <boj> was trying to recall why ftp was bad :)
12:07:37 <dminuoso> My main problem with HTTP is the kind of overuse for all kinds of purposes.
12:07:53 <int-e> boj: because initially the client would instruct the server where to send the file to.
12:08:02 <dminuoso> HTTP has become a transport layer protocol for many applications.
12:08:04 <monochrom> I.e., to download a file, the client has to listen to a port, the server connects to the client's port.
12:08:09 <int-e> and then it's a plain text protocol...
12:08:21 <monochrom> Ah what have I done.
12:08:25 <int-e> you could have three parties!
12:08:26 <dminuoso> int-e: the plain text I could even live with, that's functionally not an issue.
12:09:15 <int-e> monochrom: well, reminiscing is fun.
12:09:39 <phadej> plain text protocols were nice when the goto language was perl, not haskell ;)
12:09:44 <Solonarv> dminuoso: I blame firewalls zealously blocking everything that isn't HTTP(S)
12:10:36 <monochrom> This is why I use port 993 for my sshd. >:)
12:11:30 <Solonarv> oh, and also firewalls/ISPs/other middlemen futzing with unencrypted connections
12:11:47 <monochrom> Actually I mean I use port 443 for my IRC bouncer!  993 is IMAPS.
12:12:27 <dminuoso> Solonarv: Can you imagine that look on my face when our service partner that provides the internet connection for us started DPIng TLS traffic (and I didn't have their root certificate in my trust store...)
12:12:51 <monochrom> Sorry what's DP?
12:13:00 <dminuoso> monochrom: DPI = deep packet inspection
12:13:13 <monochrom> Hrm.
12:13:17 <dminuoso> monochrom: iow they play NSA.
12:13:58 <dminuoso> I mean I know its just some "security appliances" that are grossly overpriced just to satisfy some bosses desire to "make everything securer and better" that does this, so its not maliciously done by our service partner.
12:14:16 <int-e> Oh hmm, is there anything new on the "e"TLS front?
12:14:35 <int-e> or maybe I should write that as eTL"S".
12:15:14 <ryandv> by https://wiki.haskell.org/Existential_type it appears that an existential type is one in which there are variables used in the RHS of the type definition that do not appear on the left
12:15:21 <int-e> oh well, I should ask elsewhere.
12:15:55 <ryandv> if this is correct, could the following type in TypeScript (i know) be considered an existential type? `export type TransactionManager = <T>(f: (t: Transaction) => Promise<T>) => Promise<T>`
12:16:42 <ryandv> or is this terminology something that is exclusive to Haskell and not a larger, language-agnostic concept
12:16:52 <monochrom> I don't know TypeScript. But could you show me how to translate "data M a = C Char a" into TypeScript?
12:17:20 * hackage insert-ordered-containers 0.2.2 - Associative containers retaining insertion order for traversals.  https://hackage.haskell.org/package/insert-ordered-containers-0.2.2 (phadej)
12:17:20 <dminuoso> ryandv: An existential can be better observed with GADTSyntax.
12:18:30 <dminuoso> ryandv: Are you familiar with universal and existential quantification from logic?
12:19:43 <ryandv> dminuoso: I am, yeah. never really used GADTs too much in Haskell
12:19:59 <dminuoso> ryandv: Let me show you how one would define an existential using GADTs then:
12:20:02 <dmwit> (existentials are not Haskell-only, they are a larger, language-agnostic concept)
12:20:11 <dminuoso> % data Foo where MkFoo :: a -> Foo
12:20:12 <yahb> dminuoso: 
12:20:12 <Solonarv> (the same is true for universals)
12:20:56 <dminuoso> ryandv: So existential quantification in Haskell is the same idea, the broader concept is from logic.
12:21:49 <dminuoso> % data Bar :: (* -> *) where MkBar :: Show a => a -> Bar a
12:21:49 <yahb> dminuoso: 
12:21:50 <Solonarv> ...but maybe this isn't an existential at all
12:21:59 <dminuoso> Perhaps this is a bit better example
12:22:04 <ryandv> monochrom: https://gist.github.com/ryandv/21be2b37abe6d52e613f591c0f0fd6b0
12:22:10 <dminuoso> Or no..
12:22:12 <ryandv> mm
12:22:59 <ryandv> dminuoso: not really sure I understand here; is MkFoo a data constructor?
12:23:03 <ryandv> or a type constructor
12:23:26 <monochrom> Ah.  I'm wondering whether "type TransactionManager = <T>..." would be universal instead.
12:23:26 <dminuoso> ryandv: MkFoo is a data constructor. I named it `MkFoo` purposefully as to avoid possible confusion with the type constructor Foo.
12:23:46 <dmwit> If that were an existential type, it seems like it wouldn't be a very useful one, under the assumption that `foo: bar => baz` is the type of functions which accept an argument of type `bar` and return a value of type `baz`.
12:23:47 <Solonarv> ryandv: if I have a (mgr : TransactionManager) I can apply it to (foo : Transaction => Promise<Foo>) or to (bar : Transaction => Promise<Bar>)
12:23:49 <Solonarv> is that correct?
12:24:27 <dmwit> (where "that" in my previous sentence is the type from the original question)
12:24:33 <dminuoso> ryandv: Let me make a bit more useful example. One moment
12:24:38 <ryandv> Solonarv: that's correct, I want one type to capture all those transactionManager instances that can handle transactional functions returning any type
12:24:50 <Solonarv> ryandv: in that case you don't have an existential
12:24:52 <ryandv> and I don't want to statically predetermine that all transactions will return a (Promise of) Foo or Bar
12:25:16 <Solonarv> you have a universal type - TransactionManager works for *all* choices of T
12:25:56 <Solonarv> the Haskell translation of that type synonym would be:
12:25:56 <Solonarv> type TransactionManager = forall a. (Transaction -> Promise a) -> Promise a
12:26:04 <Solonarv> (or maybe there'd be some IO involved, whatever)
12:26:19 <dminuoso> Presumably Promise would have IO inside.
12:26:56 <Solonarv> dminuoso: ah, but perhaps creating a promise involves forking a thread (or a fiber), which requires IO as well
12:27:00 <ryandv> so what is the difference between an existential type and a universal type? I guess existential types are in some way a "subset" of universal types? in the `data Foo where MkFoo :: a -> Foo` example, is Foo not also a universal type?
12:27:00 <Solonarv> but that's tangential
12:27:11 <Solonarv> they're not really a subset at all
12:27:17 <dminuoso> They are dual notions.
12:27:20 * hackage row-types 0.3.0.0 - Open Records and Variants  https://hackage.haskell.org/package/row-types-0.3.0.0 (dwincort)
12:27:30 <ryandv> or is it not known at that point that for any `a` I can indeed construct a `Foo`
12:27:46 <dminuoso> data Showable where MkShowable :: Show a => a -> Showable
12:27:48 <dminuoso> % data Showable where MkShowable :: Show a => a -> Showable
12:27:48 <yahb> dminuoso: 
12:28:05 <Solonarv> forall a. F a means "can be F a, for any choice of a";
12:28:06 <Solonarv> exists a. F a means "is F a, for some particular choice of a (but I'm not telling you which)"
12:28:16 <dminuoso> % ht = [MkShowable 'a', MkShowable 1, MkShowable "foobar"]
12:28:16 <yahb> dminuoso: 
12:28:29 <dminuoso> % :t ht
12:28:29 <yahb> dminuoso: [Showable]
12:28:39 <ryandv> I guess I am partially confused by the fact that the Existential type page (https://wiki.haskell.org/Existential_type) uses the `forall a.` syntax here
12:28:56 <Solonarv> they are dual in that the following types are equivalent: ((exists x. F x) -> R) ~ (forall x. (F x -> R))
12:29:05 <dmwit> Yes. The GHC folks really wanted to avoid adding a new keyword, so they reused `forall` for existentials.
12:29:08 <dmwit> That is way confusing.
12:29:10 <dmwit> Sorry about that.
12:29:18 <Solonarv> with this equivalence you can encode existentials using universals
12:29:38 <monochrom> There is a way to explain why "forall" is still OK there. But I think it's contrived.
12:29:40 <dminuoso> ryandv: There's another encoding of existentials which is CPS style existentials.
12:29:47 <monochrom> There are people who disagree with me. :)
12:30:02 <dminuoso> ryandv: (Which is applicable in more cases in Haskell)
12:30:17 <dminuoso> ryandv: My example with Showable is a simple example of existentials in action.
12:30:22 <monochrom> But it's what Solonarv said.
12:31:00 <monochrom> The explanation makes good sense if you use GADTs syntax instead.
12:31:18 <dminuoso>  % data Showable where MkShowable :: forall a. Show a => a -> Showable
12:31:25 <dmwit> ryandv: If you want some excellent writing on the topic, you might consider TAPL.
12:31:28 <dmwit> ?where tapl
12:31:29 <lambdabot> "Types and Programming Languages" by Benjamin C. Pierce in 2002-02-01 at <https://www.cis.upenn.edu/~bcpierce/tapl/>
12:31:45 <dmwit> ...but you will have to pay for some excellent writing on several nearby topics, too. =P
12:32:09 <dminuoso> dmwit: Any particular recommendations of related literature one might consume for/alongside TaPL?
12:32:11 <ryandv> dmwit: yeah I was about to ask for resources for further reading haha, unfortunately type theory is not my forte... not even sure how to go about proving Solonarv's example of those types being equivalent
12:32:25 <dminuoso> ryandv: It's from logic.
12:32:42 <ryandv> I guess I'm not sure quite how type theory and logic are related
12:32:51 <ryandv> I mean I know a bit of first-order logic with quantification
12:32:54 <dminuoso> ryandv: There's this thing called curry howard isomorphism that says types are propositions and programs are proofs.
12:32:59 <phadej> TAPL in Haskell would be more approachable for haskell beginners:)
12:33:01 <ryandv> oh yes, I have heard of this lol
12:33:20 <dmwit> dminuoso: Academic papers. ;-)
12:33:28 <monochrom> If you're good at logic, you're already good at type theory, just under a different name.
12:33:34 <monochrom> (Consider the flip side.)
12:33:44 <dmwit> But if you are good at programming, you may still be a lousy logician.
12:34:07 <dmwit> ?quote Cale applied logicians
12:34:07 <lambdabot> Cale says: But in another sense, functional programmers are applied logicians who spend all their time proving trivial theorems in interesting ways in an inconsistent intuitionist logic.
12:34:24 <monochrom> Actually it is us formal methods people who are applied logicians.
12:34:28 <monochrom> Programmers? Meh.
12:34:32 <monochrom> and bleh.
12:35:14 <monochrom> Programmmers are they can't do math and they can't read or write doc and they aren't scientifically minded so they're left with either programming or clergy.
12:35:15 <Solonarv> if we want to encode exists x. F x, we transform as follows:
12:35:15 <Solonarv> exists x. F x
12:35:15 <Solonarv> -CPS-> forall r. ((exists x. F x) -> r) -> r
12:35:15 <Solonarv> -UEA-> forall r. (forall x. F x -> r) -> r
12:35:15 <Solonarv> where UEA stands for "Universal-Existential adjunction", which is the equivalence I mentioned above
12:35:22 <monochrom> Just look at Larry Wall.
12:35:30 <dminuoso> ryandv: So you get that idea that functions correspond to implication from logic.
12:35:37 <dminuoso> ryandv: The rest you should know from logic. :)
12:35:51 <dminuoso> (function types that is)
12:36:40 <dminuoso> Why are we using arrows for function types anyway? Is that because of the Curry Howard isomorphism? Is there a different background story?
12:36:57 <monochrom> IIRC the background story is category theory.
12:37:17 <dmwit> What, really?
12:37:22 <adius> Does anyone know why it's called `Just` and `Nothing` in Haskell, altough it was `None` and `Some` in ML and it's direct successor Standard ML ?
12:37:28 <dmwit> I feel sure the set theory guys were using arrows for functions long before we cooked up category theory.
12:37:46 <monochrom> "f : A -> B" was set theory people taking that notation from the category theory founders.
12:38:15 <monochrom> I got this from a mathematician.
12:38:39 <monochrom> But I would say that the telltale sign is that it is not "f ∈ A -> B".
12:39:08 <ryandv> so what does "application of a type variable to a type constructor" (as in F x) correspond to in logic?
12:39:20 <Solonarv> ...although one could write 'f ∈ B^A"
12:39:25 <ryandv> not even sure if that question makes sense
12:39:41 <Solonarv> it does make sense
12:39:49 <dminuoso> ryandv: a type constructor is on an abstract level a type function.
12:40:31 <monochrom> Hell actually I complained about the inconsistency "why is it 1 ∈ N but suddenly when it comes to functions they suddenly freak out and switch to colon?"  Then a mathematician informed me "dude they learned it from category theory. you love category theory too, right? RIGHT?"
12:40:34 <ryandv> so is it implication elimination?
12:40:42 <ryandv> and F is actually an implication?
12:40:54 <dminuoso> ryandv: (->) itself on the type level is implication.
12:41:52 <phadej> Solonarv: categorically B^A and A -> B are different things; former is an object, latter is a morphism; and it's somewhat subtle
12:43:17 <Solonarv_> types are logical statements and terms (values) are proofs of these statements
12:43:20 <phadej> F X in logic would be instantiation of universal theorem with (forall x. ... ) with concrete proposition
12:44:10 <phadej> HM = forall (x : haskeller), isHuman x; HM phadej = isHuman phadej
12:46:00 <dmwit> That... doesn't seem right to me.
12:46:03 <dminuoso> I guess implication elimination is the observation that if `f : A -> B` and `v : A`, then `f v : B` (that is the [App] inference rule in HM). Or am I mixing things up here?
12:46:35 <phadej> dminuoso: yes, implication elimination is application; implication introduction is (lambda) abstaction
12:46:38 <dmwit> Type-level application in Haskell is instantiation of a parameterized type.
12:46:54 <dmwit> The parameterized type is not necessarily universally quantified (indeed not necessarily quantified at all).
12:48:48 <dminuoso> dmwit: Perhaps the case could be made that kinds can be seen as propositions and types as proofs?
12:49:02 <dmwit> Sure. But one isomorphism at a time, please.
12:49:27 <monochrom> Oh wait haha -fdefer-type-errors implies -fdefer-out-of-scope-variables too?!
12:50:08 <dmwit> (Or else the question becomes, "What does kind application mean on the logic side?" and we have not actually made any progress.)
12:50:28 <dmwit> (Because the answer is the same as before: it is instantiation of a parameterized proposition.)
12:50:46 <Solonarv_> this all is a lot more interesting when you have dependent(ish) types
12:51:13 <dminuoso> monochrom: https://gitlab.haskell.org/ghc/ghc/issues/12170
12:51:36 <dminuoso> monochrom: Or rather the related issue https://gitlab.haskell.org/ghc/ghc/issues/10569
12:52:00 <monochrom> Actually I don't mind that.
12:54:21 * hackage polysemy-plugin 0.2.0.1 - Disambiguate obvious uses of effects.  https://hackage.haskell.org/package/polysemy-plugin-0.2.0.1 (isovector)
12:57:20 * hackage hasql-dynamic-statements 0.2.0.1 - Toolkit for constructing Hasql statements dynamically  https://hackage.haskell.org/package/hasql-dynamic-statements-0.2.0.1 (NikitaVolkov)
13:07:00 <orzo_> Is there a way to specify a default signature for a type family instance within a class instance declaration?
13:07:39 <orzo_> I was adding default signatures for types that implement Num, but i have a related type that I don't know how to specify the default for
13:08:34 <Solonarv_> orzo_: you just write 'type Blah = <default here>' instead of 'type Blah'
13:09:43 <orzo_> in other words, this is a universal default
13:10:06 <orzo_> which actually works well in my situation and probably what i should have thought to do anyway
13:26:15 <Cale> monochrom: I said *functional* programmers, not the dysfunctional ones ;)
13:29:50 * hackage debug-dump 0.1.0.1 - File-based debug output  https://hackage.haskell.org/package/debug-dump-0.1.0.1 (vmchale)
13:40:21 * hackage smallcaps 0.6.0.6 - Flatten camel case text in LaTeX files  https://hackage.haskell.org/package/smallcaps-0.6.0.6 (StefanBerthold)
13:41:06 <d34df00d> Hi!
13:41:12 <d34df00d> What's the right way to parse strings with trifecta?
13:41:36 <d34df00d> I want to do something like       commandId <- some $ 'A' ~~ 'Z' <|> 'a' ~~ 'z' <|> char '_' <|> '0' ~~ '9'     where ~~ is an alias for satisfyRange.
13:42:04 <d34df00d> But this is a per-char parsing and it gives me a [String], which, judging by experience with attoparsec, is suboptimal.
13:42:14 <d34df00d> Meh, just String, not [String], of course.
13:47:29 <infinisil> d34df00d: What type would you want otherwise?
13:47:38 <d34df00d> ByteString or Text
13:47:50 <d34df00d> ByteString ideally.
13:48:33 <Solonarv_> well that's a problem, because a bytestring isn't a sequence of characters
13:49:14 <phadej> there's a combinator in trifecta to get part of input matched by underlying parser, but I don't remember how its named
13:50:07 <d34df00d> phadej: that'll still imply it'll allocate a list of chars (though it'll be thrown away immediately and thus not so painful)?
13:50:17 <d34df00d> Solonarv_: hmm, in what sense?
13:50:35 <infinisil> I think (but not sure) that if you just do `commandId <- Text.pack <$> some (...)`, Haskell's lazyness should keep it as fast as can be
13:51:13 <d34df00d> AFAIK attoparsec returns a bytestring that actually points into the underlying input, thus only allocating a dozen of bytes for the BS value itself.
13:51:22 <d34df00d> T.pack will keep that allocation of the whole string :(
13:51:26 <d34df00d> Maybe I'm wanting too much.
13:52:42 <phadej> d34df00d: skipSome + slicedWith (Run a parser, grabbing all of the text between its start and end points)
13:52:50 <phadej> it might be efficient, or might not
13:53:08 <phadej> (or just sliced: Run a parser, grabbing all of the text between its start and end points and discarding the original result)
13:53:29 <d34df00d> Cool, thanks!
13:53:32 <d34df00d> I'll give it a shot!
13:53:50 * hackage debug-dump 0.1.0.2 - File-based debug output  https://hackage.haskell.org/package/debug-dump-0.1.0.2 (vmchale)
13:53:57 <phadej> also error reporting might be confused by that; dunno
14:03:29 <merijn> d34df00d: What are you parsing? (aka, are you sure this even matters at all?)
14:04:07 <merijn> d34df00d: You're right that attoparsec docs say (and are right) that doing that is suboptimal, but whether "suboptimal" matters depends on what you're doing
14:04:53 <d34df00d> merijn: lol, you're right. I'm parsing some cmake files, and even for one of my projects that's fairly big there's maybe like 10k of cmake code, and whether it gets parsed in 0.01 or 0.1s is probably not a big deal.
14:05:33 <merijn> attoparsec is designed for parsing machine output and network protocols, so you wanna be able to handle gigabytes per second or at least aim for that kinda throughtput. Trifecta is designed for "human written" input and readable errors, so it (implicitly) assumes your inputs will be measured in kilobytes (since no one is handwriting gigabyte source files...), so parsing speeds is almost entirely irrelevant
14:06:18 <merijn> Which is a very long-winded way of saying "I wouldn't worry about it" ;)
14:07:49 <d34df00d> Dunno, I was rather just curious. I've been using attoparsec a lot previously, and I'm interested how it translates to trifecta (which I'm using for the first time) performance- and usage-wise.
14:08:04 <d34df00d> But, indeed, realistically it does not matter.
14:12:56 <merijn> d34df00d: There's also megaparsec, which seems to have added most of the stuff necessary to get "trifecta pretty" errors, while also supporting "attoparsec high performance combinators"
14:14:18 <phadej> btw, parsec based .cabal file parsed handles 100k files (573MBs) in 100seconds. 
14:14:58 <phadej> so 5MB a second, and I wouldn't say it's "obfuscated" with performance tricks
14:15:12 <phadej> quite normal parsec code
14:15:40 <merijn> phadej: To be fair, attoparsec's "takeWhile" is hardly obfuscated ;)
14:18:03 <phadej> i'm just trying to say, first write clean-ish working parser
14:18:21 <phadej> in 99% cases, it will be fast enough
14:23:50 * hackage fused-effects-lens 0.2.0.0 - Monadic lens combinators for fused-effects.  https://hackage.haskell.org/package/fused-effects-lens-0.2.0.0 (patrick_thomson)
14:31:29 <isovector1> anyone know about the `reflection` package?
14:32:04 <merijn> isovector1: Yes
14:32:30 <merijn> isovector1: I even used it once, but please don't ask how, because despite it working, I'll be damned if I know how :p
14:32:41 <isovector1> merijn: i'm trying to wizard up `MonadState` and `MonadReader` dicts at the same time
14:33:11 <isovector1> both of them work individually, but trying to use them at the same time complains 
14:33:46 <isovector1> more info here: https://github.com/ekmett/reflection/issues/43
14:33:58 <noipmusp> What is pointfree version of following pattern – f <$> g?
14:34:13 <noipmusp> I'm probably looking for some functor composition operator.
14:34:25 <shachaf> That's already point-free.
14:34:25 <hpc> that's already pointfree
14:34:42 <shachaf> (And not a pattern.)
14:44:23 <tty1> Anyone have haskell IDE working. I seem unable to get it fully working in vs studio or atom
14:47:34 <noipmusp> Can anyone help me simplify following code – https://bit.ly/2W8wCxw?
14:49:25 <shachaf> Please don't use URL shorteners like that in here.
14:50:07 <noipmusp> shachaf: Why?
14:50:10 <shachaf> (This paste looks fine but they've historically been used for spam a lot.)
14:50:31 <noipmusp> Oh, ok.
14:50:54 <sm> something like: getVar x = maybe Nothing (Map.lookup x . variables) <$> getScope
14:51:06 <shachaf> You can use... Man, hpaste.org is just gone.
14:51:16 <glguy> noipmusp: https://gist.github.com/glguy/2c91be5d8eecc6409af8c6704f4d2fab something like this
14:52:39 <noipmusp> glguy, sm: Thank you.
14:52:42 <glguy> You could get that down to one line with: (Map.lookup x . variables =<<) <$!> getScopeM -- but I don't know that that's clearer
15:27:34 <fresheyeball> hey out there
15:27:46 <fresheyeball> I just need to put some key value pairs in a request body
15:28:03 <fresheyeball> is Network.HTTP.Client.MultipartFormData really the most welcoming api for this task?
15:28:07 <fresheyeball> or am I missing something
15:31:46 <jle`> anyone know if there's a way to provide haddock documentation for a pattern synonym record accessor?
15:43:09 <jle`> in an unrelated question, is there a name for hte fixed point of (a + a + a + a + a ...) ?
15:43:20 <jle`> it's essentially (Nat, a)
15:43:34 <reallymemorable> Can anyone see what I'm doing wrong here? 
15:43:35 <reallymemorable> https://gist.github.com/reallymemorable/c9eb89a453e57987b4be2cba3c10cb89
15:44:10 <dmwit> reallymemorable: Sure, that last guard is nonsense.
15:44:20 <dmwit> (And the first two aren't needed.)
15:44:23 <jle`> reallymemorable: what do you think 'earliestDay lastDay' is supposed to mean?
15:44:36 <reallymemorable> they are both `Just` Days?
15:44:37 <dmwit> reallymemorable: Just `diffMaybeDays = liftA2 diffDays` and you're done.
15:44:38 <jle`> * latestDay
15:44:54 <jle`> reallymemorable: remember all guards are just expressions
15:44:55 <dmwit> reallymemorable: Why would it mean that?
15:45:25 <reallymemorable> I'm not sure
15:45:27 <reallymemorable> im lost
15:45:27 <jle`> reallymemorable: so we have myFunc x y | expr1 = ... | expr2 = ... | expr3 = ...
15:45:32 <dmwit> reallymemorable: (Would you want `earliestDay == Nothing` to mean that all of `earliestDay`, `==`, and `Nothing` were `Just` Days?)
15:45:34 <jle`> earliestDay == Nothing is an expression
15:45:41 <jle`> latestDay == Nothing is an expression
15:45:56 <jle`> `earliestDay latestDay` is an expression that is the application of earliestDay to latestDay, like `f x`
15:46:01 <jle`> > negate 9
15:46:03 <lambdabot>  -9
15:46:11 <reallymemorable> right
15:46:15 <reallymemorable> i guess i was trying to say
15:46:25 <reallymemorable> do this third thing if neither of the arguments are `Nothing1`
15:46:28 <reallymemorable> `Nothing`
15:46:31 <jle`> so it looks like in the last guard, you are trying to apply earliestDay to latestDay, as if earliestDay was a function
15:46:41 <jle`> reallymemorable: you can use 'otherwise'
15:46:50 <dmwit> reallymemorable: There is `otherwise` (or just `True`) for "this guard should always succeed".
15:46:59 <jle`> but if you want to match on what case is Nothing/Just/etc., then you should use pattern matching
15:47:01 <jle`> not guards
15:47:02 <dmwit> reallymemorable: But you should be using pattern matching, not guards, for this.
15:47:24 <jle`> if you are trying to match on constructors, don't use guards and equality, use pattern matching :) that's pretty much the exact reason pattern matching was invented
15:47:28 <reallymemorable> How would one approach this with pattern matching?
15:47:29 <dmwit> reallymemorable: But you should be using none of the above anyway, per my comment above about your last clause covering all the cases anyway.
15:47:36 <jle`> diffMaybeDays Nothing Nothing = Nothing
15:47:42 <jle`> er
15:47:46 <jle`> diffMaybeDays Nothing _ = Nothing
15:47:51 <jle`> diffMaybeDays _ Nothing = Nothing
15:48:05 <jle`> diffMaybeDays (Just e) (Just l) = Just (diffDays e l)
15:48:29 <dmwit> Or `diffMaybeDays (Just e) (Just l) = Just (diffDays e l); diffMaybeDays _ _ = Nothing`.
15:48:43 <jle`> the possibilities are endless :)
15:48:48 <jle`> or well, they are enumerable
15:49:21 <reallymemorable> https://gist.github.com/reallymemorable/421d3a5faf3e8b1cfc5f0d0cba37e716
15:49:24 <reallymemorable> so something like that?
15:49:30 <jle`> reallymemorable: but yeah, this general pattern of "apply an (a -> b -> c) function to Maybe a and Maybe b" is very common
15:49:39 <jle`> reallymemorable: liftA2 was inveted exactly for this pattern :)
15:50:00 <jle`> reallymemorable: no, that's not really valid syntax
15:50:08 <jle`> both me and dmwit gave ways to do it using valid syntax :)
15:50:11 <dmwit> reallymemorable: wha...
15:50:23 <dmwit> reallymemorable: Just copy and paste the code jle` showed you.
15:50:39 <jle`> if you're having problems with syntax, just use the reference syntax we gave :)
15:50:44 <reallymemorable> as three distinct functions?
15:50:52 <dmwit> yah
15:50:52 <jle`> one function, with three cases
15:51:02 <jle`> or two cases, in dmwit's example
15:52:08 <reallymemorable> ok
15:52:13 <reallymemorable> im messing up something basic
15:52:21 <reallymemorable> i will re-read about case statements
15:52:30 <reallymemorable> and try to implement jle`'s
15:52:33 <jle`> you can just copy and paste what we wrote, heh
15:52:35 <reallymemorable> as that makes the most sense to me
15:52:45 <jle`> but dmwit's example is probably cleaner
15:52:59 <jle`> but yeah, it's good to also brush up on case statements for future reference :)
15:53:06 <reallymemorable> ah yeah
15:53:08 <reallymemorable> diffMaybeDays (Just e) (Just l) = Just (diffDays e l); diffMaybeDays _ _ = Nothing
15:53:12 <reallymemorable> i see what's happening
15:57:48 <reallymemorable> thanks everyone
15:57:53 <reallymemorable> i got dmwit's version working
15:59:03 <Cale> also s/case statements/case expressions/ :)
15:59:36 <Cale> (they're an expression in Haskell rather than a statement)
16:09:21 * hackage docker 0.6.0.2 - An API client for docker written in Haskell  https://hackage.haskell.org/package/docker-0.6.0.2 (denibertovic)
16:24:19 <reallymemorable> What's the best way to go from Integer to Double?
16:25:49 <oni-on-ion> fromIntegral ?
16:26:44 <reallymemorable> whats the difference between that and fromIntegral?
16:26:50 <reallymemorable> they are effectively interchangeable?
16:27:40 <MarcelineVQ> between that and fromInteger? check the types to see the difference, one is more general (meaning it applies to more types)
16:27:47 <shachaf> fromIntegral and fromIntegral are interchangeable.
16:27:52 <shachaf> @src fromIntegral
16:27:52 <lambdabot> fromIntegral = fromInteger . toInteger
16:28:12 <reallymemorable> ah ok
16:28:13 <reallymemorable> thanks
16:28:33 <ememberr> haskell good language fro cryptography and crpytocoins ?
16:30:44 <Cale> ememberr: There are a lot of people using it for that, because it's a good language in which to write correct programs, and if you're going to lose all your money, you might as well lose it correctly.
16:31:43 <ememberr> Cale:  but haskell isnt as fast as c++ right ?
16:31:48 * boj smirks
16:32:42 <jle`> ememberr: haskell is comparable to C++ in many situations
16:35:21 <ememberr> thanks jle`  and Cale  so haskell is very much suitable for them i believe
16:35:34 <Cale> ememberr: If anything is.
16:36:15 <Cale> Personally, I wish people would just stop trying to make that particular dystopian future a reality.
16:36:44 <Cale> But, you know, money.
16:37:58 <int-e> I wouldn't mind except for all the wasted electricity.
16:39:54 <Cale> There's that, then there's all the wasted effort of capable people. Then there's the aspect that people are pouring their life savings into speculative gambles on effectively unregulated securities.
16:41:23 <Cale> Then there's the fact that smart contracts are solving a problem that nobody had, and are much much worse than real contracts. With real contracts, if something goes wrong, humans can be involved who can dismiss or rework parts of it. Smart contracts are unthinking programs being executed on other people's computers.
16:41:58 <Cale> You know, reworks like "this amounts to indentured servitude and therefore is illegal and void."
16:48:15 <nisstyre> Cale: some of the same technology being used for smart contracts applies generally to writing secure distributed programs
16:48:58 <nisstyre> i.e. it is not useless
16:49:06 <nisstyre> even if you think the social uses of smart contracts are bad
16:49:08 <Cale> Maybe
16:49:24 <Cale> I think a lot of that stuff you would do it completely differently in any practical application
16:49:42 <nisstyre> http://wiki.erights.org/wiki/Main_Page has a lot of interesting research links
16:51:09 <nshepperd_> Haskell is a great language for writing correct cryptographic algorithms whose side channel security properties are completely unknown
16:51:17 <Cale> hahaha
16:51:23 <Cale> Yeah, that's also quite true
16:51:32 <Axman6> nshepperd_++
16:52:00 <Axman6> Cryptol is quite good for actually doing that though
16:52:45 <shachaf> "completely unknown" is going a bit far. With high probability they have side channels.
16:54:55 <Cale> Well, a lot of the time, the crypto stuff just directly calls C functions, which might have side channel attacks, but is maybe a little more battle-tested.
16:55:10 <nshepperd_> Ehehe
16:55:36 <Cale> But you do still have to worry about any Haskell-side marshalling that goes on
17:28:19 <shachaf> Is it possible to disable the 1TB-up-front allocator in GHC, or at least to change the size with an RTS flag?
17:35:02 <c_wraith> shachaf, not with an rts flag. it can only be done with a build-time flag in ghc itself.
17:35:42 <c_wraith> shachaf, if you want to run it on wsl, hvr has a ppr with builds with that allocator turned off.
17:37:41 <shachaf> c_wraith: Apparently you can set RLIMIT_AS/ulimit -v to limit it.
17:39:26 <c_wraith> actually, I guess that ppr would work in any Ubuntu, not just wsl Ubuntu
17:39:59 <shachaf> c_wraith: (This is for <https://github.com/mattgodbolt/compiler-explorer/issues/1412>.)
17:43:15 <shachaf> If I'm confusil you can comment about how to fix GHC or something. But it seemed to work here.
17:50:46 <c_wraith> shachaf, I'm not sure that's the issue. ghc has done this for several versions now.
17:52:02 <shachaf> c_wraith: But the memory limit was just added to godbolt a couple of days ago.
17:52:27 <c_wraith> doesn't that say older versions of ghc work fine?
17:53:44 <shachaf> It does. I guess it doesn't say which.
17:54:59 <shachaf> Man, the GitHub UI doesn't let you answer pretty simple questions about history.
17:57:48 <shachaf> Oh, GHC 8.4.4 works. So I guess it's something else.
18:31:58 <infinisil> Hey, I have three different types which almost look the same
18:32:49 <infinisil> send :: a -> b -> c -> m message    transfer :: message -> a -> b -> c -> m message    recv :: message -> a -> b -> c -> m () 
18:33:14 <infinisil> And these a -> b -> c are really repetitive (not real code but you get the idea)
18:33:45 <infinisil> These are all defined in data type records
18:33:59 <infinisil> Is there some nice way to abstract this?
18:34:54 <jackdk> type T in out = in -> a -> b -> c -> m out; send :: T Void message; transfer :: T message message; recv :: T Void () ?
18:35:12 <jackdk> actually you might just want () for both
18:35:25 <infinisil> jackdk: That works, but it's not very nice
18:35:50 <jackdk> collect your zillion arguments into a record?
18:35:59 <infinisil> I'm thinking, something like taking a, b and c in a single function as arguments, and then matching in the body on some Send/Transfer/Recv GADT something
18:36:12 <jackdk> R = R a b c; type T in out = in -> R -> m out
18:36:14 <iqubic> Yeah, that should work.
18:36:31 <iqubic> That's not even a GADT, but that should work.
18:36:48 <infinisil> Well I guess I simplified too much, there's also constraints involved
18:36:55 <MarcelineVQ> What do you mean when you say "These are all defined in data type records" which these?
18:37:23 <infinisil> data Algorithm = Algorithm { send :: ...; transfer :: ...; recv :: ... }
18:37:46 <infinisil> Ah though I guess I could still put constraints in such an R
18:37:54 <iqubic> Oh. You can change the type of the data in the record.
18:38:03 <iqubic> What constraints do you have?
18:40:12 <infinisil> Hmm no the factoring out a, b and c works well for me
18:40:17 <infinisil> I'll just roll with that
18:40:27 <infinisil> Can always refactor later when I realize it's a problem
18:40:57 <infinisil> Well it doesn't work super well, but eh
18:42:54 <iqubic> What are the issues?
18:54:15 <halogenandtoast> If I have newtype Foo = Foo { getFoo :: [] }, whats the best way to make an empty list into a Foo, I considered using mempty here
18:54:42 <halogenandtoast> I am trying to find something more elegant than (Foo [])
19:00:44 <MarcelineVQ> could use coerce, might be elegeant depending on what other code there is, Foo [] looks pretty okay to me though
19:02:40 <widmur> Is every Foo intended to contain only an empty list?
19:02:55 <halogenandtoast> No, Foo here is actually a Hand of cards
19:03:06 <halogenandtoast> and I wanted a way to setup an empty hand
19:04:42 <Gurkenglas> Why is it a newtype in the first place? You could just use [].
19:04:56 <halogenandtoast> I enjoy type safety
19:05:02 <halogenandtoast> and Hand != Deck
19:05:26 <halogenandtoast> (I actually have a third type of [Card] as well in this app)
19:06:17 <MarcelineVQ> empty_hand :: Foo a; empty_hand = Foo []
19:06:28 <widmur> I think Gurkenglas is just pointing out that [] is a data constructor, not a type constant.
19:08:25 <halogenandtoast> widmur: I might not be understanding the terminology here, so forgive me if I get this wrong, but if I use newtype, I can't pass the wrong type around
19:08:51 <halogenandtoast> I think if I just pass [] it balks at me
19:09:01 <halogenandtoast> I understand what you're saying now I think
19:09:23 <MarcelineVQ> halogenandtoast: they're wondering about your original definition which is missing a type variable
19:09:53 <Axman6> halogenandtoast: I assume you meant  newtype Foo = Foo { getFoo :: [Thing] }?
19:10:03 <halogenandtoast> Oh right `newtype Hand = Hand { getHand :: [Card] }`
19:11:07 <Axman6> emptyHand :: Hand; emptyHand = Hand []; ... <do things iwth emptyHand>
19:11:52 <halogenandtoast> Yeah Axman6, MarcelineVQ mentioned the same thing, for some reason it doesn't resonate with me (but that's a me issue)
19:12:09 <Axman6> what do you want then?
19:12:46 <Axman6> there's an IsList class, and OverloadedLists will let you write [Ace Hrta] and [] as valid Hands]
19:13:01 <halogenandtoast> to be honest I'll probably go with that (the emptyHand method).
19:13:06 <Axman6> but it doesn't really buy you much, and somewhat removes the safety you were after
19:13:26 <halogenandtoast> I had used DeriveGeneric to implement SemiGroup and Monoid to use mempty
19:13:31 <halogenandtoast> but it felt like a rather large hammer
19:17:11 <MarcelineVQ> I've suddenly decided to camelCase only things with function signatures and to snake_case bindings. where emptyHand would be a method to empty a hand, and empty_hand is the hand which is already empty.
19:21:02 <widmur> I'm trying to test a Traversable instance using the Checkers library (https://hackage.haskell.org/package/checkers), but I'm having trouble understanding how the signature of 'traversable' maps to the signature of 'traverse'. Specifically the Monoid constraint in 'traversable :: forall f a b m. (Traversable f, Monoid m, ...) => f (a, b, m) -> TestBatch'. I think 'traversable' delegates to 'foldable' but I'm not sure why.
19:24:01 <jackdk> https://hackage.haskell.org/package/checkers-0.5.0/docs/src/Test.QuickCheck.Classes.html#traversable your instinct is correct. It's using foldMapDefault to do foldMap using the traversable instance and checking that it's correct
19:24:04 <jackdk> See https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Traversable.html#v:foldMapDefault
19:26:03 <widmur> Thanks Jackdk. I'll go take a look.
19:40:20 * hackage cabal-cache 1.0.0.11 - CI Assistant for Haskell projects  https://hackage.haskell.org/package/cabal-cache-1.0.0.11 (haskellworks)
21:16:51 * hackage extensible-effects-concurrent 0.24.1 - Message passing concurrency as extensible-effect  https://hackage.haskell.org/package/extensible-effects-concurrent-0.24.1 (SvenHeyll)
21:41:53 <Axman6> 'RIP Matrix
21:42:50 <oni-on-ion> aha
21:47:04 <isd> Hey all. Does anyone know of any examples of use cases for rank 3 or higher types? I've seen plenty of use of rank 2, but not rank 3, and am curious as to how that would be used (and what it would be good for).
21:47:41 <Axman6> Gonna need a reminder what a rank 3 type looks like
21:47:42 <Cale> Rank 3 is indeed quite rare...
21:47:50 * hackage cabal-cache 1.0.0.12 - CI Assistant for Haskell projects  https://hackage.haskell.org/package/cabal-cache-1.0.0.12 (haskellworks)
21:48:39 <Cale> ((forall a. ... a ...) -> b) -> c
21:48:54 <isd> Axman6: it would be something where the forall is to the left of two arrows. so e.g. ((forall a. a) -> b) -> c
21:49:25 <Cale> Maybe something involving lenses somehow, I can imagine it coming up
21:49:36 <isd> I feel like I've seen an example somewhere, but wasn't able to dig it up.
21:51:05 <Cale> I have a (useful) type of kind (((* -> *) -> *) -> *) -> (* -> *) -> * though
21:51:47 <isd> Let's hear it.
21:52:23 <jackdk> monadmask?
21:52:54 <Cale> So, this is in a context where we're using container types that are parametrised by a choice of functor in order to abstract over whether data has not yet been filled in, or is merely present, or if perhaps data for many users at once is present in each field
21:53:15 <Cale> So functor-parametric container types have kind (* -> *) -> *
21:53:31 <isd> with yo so far.
21:53:37 <isd> *you
21:53:48 <wagle> whats the "best" .hs extension for visual studio?
21:53:53 <isd> jackdk: ah, good example, thank
21:53:56 <isd> thanks
21:53:57 <Cale> Now, this thing I have is a Map-like data structure, where the keys are some GADT whose type index is a functor-parametric container type
21:54:16 <isd> mask :: ((forall a. m a -> m a) -> m b) -> m b
21:54:22 <Cale> So the kind of the key type of this Map-like thing is ((* -> *) -> *) -> *
21:55:02 <Cale> and the index type of the key tells you what sort of functor-parametric container gets paired up with that
21:55:29 <sarahzrf> good lord
21:55:31 <Cale> and this Map-like structure (I call it a Vessel) is itself parametrised by a functor, and passes that choice along
21:55:38 <Cale> newtype Vessel (k :: ((* -> *) -> *) -> *) (g :: * -> *) = Vessel { unVessel :: MonoidalDMap k (FlipAp g) }
21:55:38 <Cale>   deriving (Generic)
21:55:39 <Cale> newtype FlipAp (g :: k) (v :: k -> *) = FlipAp { unFlipAp :: v g }
21:55:39 <Cale>   deriving (Eq, Ord, Show)
21:55:41 <sarahzrf> do you ever wonder if you're taking things too far
21:56:04 <Cale> Yes, but in this case, I think it actually ends up being worth all the trouble
21:56:09 <wagle> nevah! infinite streams of things!
21:56:16 <Cale> I was very reluctant to accept this type
21:56:19 <Cale> lol
21:57:36 <Cale> But ultimately, I was able to write ToJSON and FromJSON instances, Monoid/Group for specific functors, as well as a whole lot of other machinery that we need, and it will eventually save us a lot of trouble repeatedly generating all that boilerplate for the protocols we use in communicating between our frontends and backends
21:58:26 <Axman6> package incoming?
21:58:46 <Cale> @hackage vessel
21:58:47 <lambdabot> http://hackage.haskell.org/package/vessel
21:58:55 <Cale> oh, not there yet
21:59:03 <Axman6> :'(
21:59:05 <Cale> https://github.com/obsidiansystems/vessel
21:59:08 <Cale> it is there though
21:59:22 <Cale> Just hasn't been put on Hackage
21:59:31 <Cale> It's not *quite* where I want it to be for real use.
22:00:19 <isd> I think I understand. But it definitely does set off my needless-complexity-warning-systems.
22:00:20 <Cale> For one, everything is all dumped into one module right now, including the other functor-parametric containers that will go alongside it -- really they need to be in their own modules and have much more functionality
22:01:41 <Cale> Basically, we needed a way for frontends to accumulate "queries" or "view selectors" which describe what data a user is trying to look at, and which are going to change dynamically as they move around an app
22:01:54 <Cale> and then those get shoved over a websocket
22:02:28 <Cale> whenever a user's query changes, we immediately send them whatever data it is that they would then need (assuming they have permission to see it etc.)
22:02:46 <Cale> but we also aggregate all the users' queries into a global query
22:03:07 <Cale> and whenever we receive a notification from the database that a table has changed, we send the interested users patches
22:03:52 <Cale> Doing that involves a kind of transposition, where we take a Map from connected clients to queries, and turn it into a single global query, and then the inverse, turning a global view into individualised views.
22:04:28 <Cale> and we also end up needing to be able to crop users' views to just what was requested
22:04:57 <Cale> After spending several years implementing these things with big record types, we got sick of having the same bugs crop up in all the relevant typeclass instances
22:05:14 <Cale> This data structure lets us describe what our keys are, and simply be done
22:05:45 <isd> Makes sense. I may stare at this more when it's not so late.
22:07:24 <Cale> It's also rather nice that it's inherently nestable: you can have a key in your Vessel associate itself with another type of Vessel, which makes application protocols nestable, and so the hope is that this will lead to more reusable backend components
22:08:51 <isd> Yeah, the fact that vanilla record labels aren't "first class" in most any typed language can definitely be a pain.
22:10:07 <Cale> https://github.com/obsidiansystems/obelisk/blob/cg-tabulation/lib/tabulation/src/Data/Tabulation.hs -- this should probably be in its own package, but right now it's just in my PR to obelisk because I just happened to need it for some of the route-encoding stuff
22:11:29 <Cale> But yeah, the idea with this class is to use a GADT to enumerate the fields of a record type, and obtain ways to either construct ("tabulate") a new record from a function from field identifiers to values, or be able to obtain lenses from field identifiers.
22:11:49 <isd> This gets into this sortof weird uncanny valley you can wind up in with type level programming where if you pull out all the stops you can make something work, and maybe it's worth it, but it gets me wanting to step back and rethink foundations a bit. I feel like dependent types would make this kind of thing much easier.
22:12:10 <maerwald> lol
22:12:21 <Cale> This is right on the borderline of dependent types before it stops being sensible to do it in Haskell I think
22:12:31 <Cale> Singletons is where I draw the line
22:12:45 <Cale> If you need singletons, you've gone too far :)
22:13:21 <Cale> But only because Haskell makes anything of that sort really way too ugly at the moment, and way too hard to work with -- you end up wanting to do too much type level *computation* then.
22:13:36 <Cale> and that's when you really start getting painted into a corner
22:13:36 <isd> singletons make me sad.
22:13:59 <Cale> To some extent, that's when you start getting painted into a corner with dependently typed languages as well
22:14:34 <Cale> People writing things in dependently typed languages rework them endlessly to try to avoid having to put computations in their types
22:14:39 <Cale> (too much)
22:15:11 <isd> The thing with dependent types is that the type system to some extent stops being the bottleneck; you can get into a situation where the type system is perfectly capable of expressing what you want, but you're just not smart enough to formalize it and work with it that way.
22:15:20 <MarcelineVQ> Yeah, you want to compute types, but not so much compute in types
22:19:40 <Cale> isd: There are a few things which still worry me about dependent types. One is the subtlety of ordering your definitions in a module such that everything which is needed in order to make things typecheck is proved before it is needed. Another is the breaking of the function abstraction to some degree in terms of caring about whether things compute on terms which have free variables in them
22:20:05 <Cale> That is, from an engineering perspective
22:20:21 <Cale> On the whole though, I am more a fan of them than not :)
22:21:31 <Cale> Even fancy types in Haskell, wielded without caution, can already create horrible code that ensures very little of value in terms of desired properties, while making it fiendishly difficult to maintain the code.
22:22:18 <isd> I definitely think it's on the whole a better situation to be in than working with piles of incremental additions like in Haskell. I remember my first exposure to idris and being like "something this powerful has no right to feel simpler than Haskell"
22:22:30 <Cale> So I really do try to stick to the simplest types I can get away with. Lately I've been quite happy with how GADTs can be leveraged to remove or at least centralise a whole lot of boilerplate.
22:24:07 <Cale> But most of the time, I try to stay away from overly fancy types.
22:24:21 <isd> Sometimes I think a lot of type-level hackery would be better addressed by other language mechanisms. Reading the GHC.Generics paper was basically the strongest argument I've seen as to why template haskell is a better solution to the problem it's solving.
22:24:53 <Cale> Template Haskell is an intensely okayish solution.
22:25:38 <isd> I also think the general principle of template haskell (abstract at the level of syntax) can be done much better than the actuall TemplateHaskell extension.
22:26:00 <isd> And it would be much more ergonmic if Haskell's AST were simpler.
22:26:02 <Cale> But having written a bunch of it lately, I've been pretty annoyed with the lack of various things. I'm at a point with some stuff where I'm pretty sure the only way forward is practically to implement type class instance resolution in terms of reifyInstances
22:26:33 <Cale> and it's like... why am I writing the Haskell typechecker
22:27:20 <Cale> (This has to do with determining which constraints to put on a generated instance head)
22:28:26 <isd> Ideally you'd have something in the api that would let you query that stuff.
22:28:57 <Cale> yeah, they give you a way to look up the instances of a class for a particular type, but if that type has a variable in it, they simply give you a list of all the instances which would unify
22:29:11 <Cale> There's no way to mark the variable as rigid as best I can tell
22:29:50 <Cale> So, basically, in some cases, e.g. asking for the instances of Show which would match  a Double
22:30:00 <Cale> where it's going to give you a tremendous pile of garbage
22:30:04 <isd> which brings me to my next grievance with the Haskell type system: the type class system has grown into an unplanned logic programming language, and has most of the problems of I-didn't-mean-to-make-a-programming-language
22:30:15 <Cale> and then you have to sort through and figure out if anything *actually* matches
22:30:36 <Cale> I've been able to do some pretty fun things with constraints lately
22:30:38 <isd> And so you've got a whole solver infrastructure that's hidden from the language -- and thus your problems.
22:30:46 <Cale> I have a kind-of-sort-of constraint-level pi types
22:31:00 <isd> But I need to get going; later all.
22:41:34 <jle`> `.
23:34:07 <bahamas> I just added the StaticPointers extension and it triggered a full rebuild. is that normal?
23:37:19 <typetetris> Hi there! How can get HsYAML or yaml  packages to print error messages with line numbers? (yaml does this with an YamlParseException, but not with the others, especially the ones contstructed by `fail` or `typeMismatch`. And yes, if I can convince my coworkers, I would rather switch to dhall.)
23:49:56 <Cale> typetetris: What did you mean by "the others" there?
23:50:19 <Cale> http://hackage.haskell.org/package/yaml-0.11.0.0/docs/Data-Yaml.html#v:prettyPrintParseException
23:50:25 <Cale> seems to be able to print line numbers
23:51:44 <typetetris> Cale: sadly it doesn't for `AesonException` (at least in yaml-0.8.32), which are generated by `typeMismatch` called in a FromJSON-instance of my own data structures.
23:52:09 <Cale> oh
23:52:47 <Cale> I see, yeah, that's quite unfortunate. I suspect those errors are coming from Aeson's conversion of the resulting Value into whatever type of data structure was requested
23:52:55 <Cale> So, there's no location information at that point
23:54:12 <bahamas> is this definition of the Typeable type class, is `k` the kind of `a`? https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Dynamic.html#t:Typeable. if so, what does it mean?
23:54:16 <typetetris> Okay, but one could augment the Value values with the line number and column, where this Value came from and so it shouldn't be impossible to get this.
23:54:35 <dminuoso> bahamas: It means the type is polymorphic.
23:54:39 <Cale> bahamas: It just means that the type a can be of any kind
23:54:59 <Cale> bahamas: For example, you can have an instance Typeable Maybe
23:56:17 <Cale> typetetris: In principle, yeah. But Aeson doesn't annotate its representation of JSON values with line and column numbers.
23:59:31 <dminuoso> bahamas: Consider how ⌜class ... Functor (f :: * -> *) where ...⌝, ⌜class Num (f :: *) where ...⌝ which are both limited by types of a single kind.
