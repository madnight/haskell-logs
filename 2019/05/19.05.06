00:02:57 <jle`> btw, in this form, Dialog resembles the encoding of Moore (or MooreT) from the machines library
00:03:49 <jle`> type Dialog = MooreT IO Event [Widget X]
00:04:53 <clever> i'll give that a read tomorrow
00:07:28 <jle`> so in the end, we only need to care about our external API, and write to that, for the most part.  we don't need to worry about thinking about moving around values; we can just directly read off our API as a data type :)
00:07:32 <dminuoso> jle`: Interesting, Moore looks superficially similar to FunList
00:08:58 <jle`> hm yeah, it's similar. the main difference i think is that FunList is non-regular
00:09:24 <jle`> so the "output" changes at every iteration
00:09:29 <jle`> *output type
00:10:00 <jle`> actually there might be more than that difference, now that i look at the two side by side
00:10:59 <dminuoso> Oh right, somehow I was thinking Moore was non-regular too.
00:11:31 <dminuoso> But: Moore :: b -> (a -> Moore a b) -> Moore a b
00:12:40 <dminuoso> More :: a -> FunList a (a -> b) -> FunList a b
00:12:50 <dminuoso> Very different.
00:13:01 <clever> jle`: it type-checks!
00:13:41 <jle`> :D
00:14:32 <clever> and it "works", but there is currently only 1 dialog, and it doesnt do half of what i described above
00:14:59 <clever> i'll need to flesh it out tomorrow, its now 4am
00:15:17 <clever> mkDlg1 state = Dialog { dRender = dlg1Render state, dHandleEvent = dlg1HandleEvent state }
00:15:29 <clever> this is also key to making things simpler to deal with
00:15:34 <clever> it just creates a new set of partially applied handlers, for a given state
00:16:11 <clever> so the func in dHandleEvent can mutate the state, then call mkDlg1 to create a new Dialog with the new state baked into the dHandleEvent
00:16:46 <clever> and the file-chooser example from before, would have a FilePath->Dialog within its state, and use that to go backwards in the stack when needed
00:17:29 * clever heads off to bed
00:28:22 <hc> hi, a little bit OT, but does anyone know if there's an applicative lifting operator like <$> in javascript?
00:28:24 <jle`> clever: have a good night :)
00:28:40 <jle`> hc: do you mean one that is polymorphic for all 'functor's ?
00:28:41 <hc> Specifically, I'd like to writesomething like this: "const name = decodeUtf8 <$> await readNameAsUint8Array"
00:29:04 <jle`> hc: that all depends on the API of 'await'
00:29:16 <hc> await is part of the promises API
00:29:36 <hc> I.e., you could write it as readNameAsUint8Array.then((blob) => return decodeUtf8(blob));
00:29:38 <jle`> right, i'm saying that your question boils down to await/promises
00:30:00 <Cale> hc: Couldn't you write a function which does exactly that in general then?
00:30:02 <jle`> are you asking for a unified abstraction for *all* functors in javascript?
00:30:10 <jle`> or just something for await ?
00:30:16 <hc> just for await
00:30:35 <jle`> yeah, that depends on the API for await/promises
00:30:54 <jle`> or are you asking for a syntactic operator
00:30:58 <Cale> function mapPromise(f,p) { return p.then((x) => return f(x)) }
00:31:01 <Cale> or some such
00:31:14 <hc> I'm asking what's the most elegant way to do it
00:31:16 <jle`> mapPromise(decodeUtf8, await readNameAsUint8Array)
00:31:30 <hc> hmm, that sounds interesting
00:31:40 <hc> I think it'd be await mapPromise(decodeUtf8, readName...) though
00:31:56 <hc> Thanks! I'll try that
00:31:58 <jle`> fwiw i think there are libraries in javascript that attempt to unify different functors under a common interface like this
00:32:11 * hc is a javascript novice
00:32:18 <jle`> but all that gains is that you can use them all with the same name
00:32:28 <jle`> it doesn't add any functionality that didn't already exist
00:38:20 <dminuoso> hc: ramda gives you polymorphic map
00:40:00 <hc> ah nice
00:40:50 <dminuoso> hc: And as for promises, you can use .then to just map over values.
00:41:22 <dminuoso> The whole behavior of .then is frustratingly annoying because its a mixture of functor and unlawful monad.
00:49:39 <Axman6> Is there any way to tell GHC that a pattern synonym is exhaustive?
00:50:29 <jle`> yes
00:50:53 <dminuoso> Axman6: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#complete-pragmas
00:50:54 <Axman6> Why is it always jle` who brings me the best news
00:51:08 <jle`> the one i always refernece is Seq, which was one of the big initial motivations for such a feature in the first place
00:51:09 <Axman6> and often also dminuoso =)
00:51:35 <jle`> i just check the source code of https://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Sequence.html every time lol
00:51:52 <jle`> {-# COMPLETE (:<|), Empty #-}
00:51:54 <jle`> {-# COMPLETE (:|>), Empty #-}
00:53:56 <Axman6> <3 you both, this is greAT
00:54:01 <Axman6> great too
00:54:18 <jle`> E>
01:04:32 <Axman6> If you're curious, we're working on a non-empty text package which was originally data Text1 = Text1 {-#UNPACK#-} !Char {-#UNPACK#-} !Text; which I'm converting to newtype Text1 = UnsafeText1 Text and a pattern synonym which matches the old Text1 one so none of the old code breaks
01:08:05 <Axman6> It'd be nice to be able to implement a Coercible instance for the Text1 -> Text direction but not the other way, is that currently possible?
01:14:18 <jle`> Coercible itself is only ever witnessed by the compiler
01:15:22 <jle`> so you can't ever write any instances yourself
01:21:19 <koz_> jle`: Could a plugin for GHC derive some Coercibles?
01:21:25 <koz_> (well, 'derive')
01:21:32 <koz_> ('define'?)
01:22:25 <Solonarv> yes, a type-checker plugin can solve constraints much like the compiler can by itself
01:22:51 <Solonarv> I see no reason that wouldn't work for Coercible constraints, but you'd have to be careful to make sure it's actually sound
01:23:22 <jusss> jle`: fmap::(a->b) -> (e->a) -> (e->b), that (a->b) do changes (e->)'s output from a to b, 
01:23:47 <jle`> it changes the (e -> a) into an (e -> b)
01:23:54 <Solonarv> jusss: you've been stuck on this for a few days, try a different perspective: fmap doesn't modify anything
01:24:03 <jle`> so it takes a function with input e and output a, and returns a function with input e and output b
01:24:21 <Solonarv> fmap constructs an entirely new function (e -> b) out of (a -> b) and (e -> a)
01:24:26 <Solonarv> none of the inputs are modified
01:26:48 <jusss> https://twitter.com/john_emacs/status/1125232071016718337
01:31:21 <jle`> that's a nice website :)
01:31:22 <jusss> Solonarv: ok, no modify, in this view, I can understand why (->) e is similar with []
01:36:34 <jusss> think about input and ouput, fmap apply function A on another function B, it return a new function C,  C has the same input with B, but different output
01:38:42 <jusss> so we can say fmap "change" a function's output with return a new function way
01:40:19 <jusss> right？
01:44:53 <bahamas> with Nix how do you specify the ghc version you want to build your project with?
01:46:01 <[exa]> jusss: a useful point of view on (-> e) is to see functions as 'containers for the results'
01:48:42 <jusss> [exa]: what about to see functions as containers that not throw its return value yet
01:49:11 <[exa]> jusss: yeah, you need to supply 'e' to get it "opened"
01:49:25 <[exa]> it's a childish explanation but probably the best intuition for (->e) functor I have
01:49:55 <Solonarv> [exa]: if you want to use sections, write it (e ->)
01:50:00 <Solonarv> otherwise write ((->) e)
01:50:04 <[exa]> Solonarv: oh noes, sorry.
01:50:24 <[exa]> yeah its ((->) e) :]
01:50:56 <Solonarv> (-> e) is also meaningful (if interpreted as an operator section, which GHC doesn't allow), and doesn't mean the same thing as ((->) e)
01:51:22 <jusss> [exa]: throw a 'e' to the container, and when the container doesn't throw a 'a' out, the container is a Functor
01:51:48 <[exa]> well, same intuition kindof holds even for the profunctor, but that's not what we were heading :]
01:52:09 <Guest25031> Hi, i can't compile my code. It says there are files missing in split-0.2.3.3 package and when i run ghc-pkg check i get errors for files not existing or not a directory
01:52:33 <Guest25031> i already triend cabal install split --force-reinstalls
01:52:36 <[exa]> jusss: you have a container that receives 'e' and gives 'a'. You can turn it to a container that from 'e' gives 'b' using a function of type (a->b).
01:53:01 <[exa]> Guest25031: do you perhaps have the full install error?
01:53:20 <[exa]> jusss: and that ^ is the function functor.
01:54:04 <merijn> Guest25031: You really never want --force-reinstalls, tbh
01:54:41 <jusss> [exa]: and what about list functor? now I don't understand list functor any more
01:55:07 <jusss> throw a 'a
01:55:20 <merijn> Guest25031: Which GHC and cabal-install version are you using?
01:55:22 <jusss> throw a 'a' to a [] and it turns [a]
01:55:51 <jusss> it won't throw something out right?
01:56:13 <Guest25031> ghc-8.6.4 and cabal 2.4.0.0
01:56:52 <jusss> or it throw itself out? [a]?
01:58:03 <merijn> Guest25031: And why are you installing split? For use in your own project?
01:58:30 <[exa]> jusss: list already contains the result (multiple results) that you can get without any 'e' throwing
01:58:37 <Solonarv> Guest25031: how did you install GHC and cabal? are you perchance on archlinux
01:58:44 <merijn> Guest25031: tbh, if it's reporting missing files in split-0.2.3.3 it sounds like your package database has gotten mangled. Have you used --force-reinstalls in the past?
01:58:55 <[exa]> jusss: the similarity is that if you have list that contains 'a' and function (a->b), you can get list that contains 'b'
01:59:01 <merijn> Solonarv: tbh, this doesn't sound like an Arch problem, those only show up during linking
01:59:40 <Guest25031> I am on arch.
01:59:55 <Solonarv> fair point, it's actually been a while since I witnessed arch-related problems
02:00:16 <Guest25031> i already used it the coding is done and the code is already compiled
02:00:41 <merijn> Guest25031: Can you pastebin the exact error?
02:00:47 <Guest25031> but this is an assignment and proffessor couldn't compile it and he wants me to compile the code infront of him and and can't compile it now
02:00:59 <Guest25031> pasting
02:01:58 <[exa]> let's build a mock cabal in shell that looks like compiling... :D
02:02:23 * Solonarv mumbles something about cabal script
02:03:02 <Guest25031> https://pastebin.com/Dcu6muiP
02:03:44 <merijn> Guest25031: And what does ghc-pkg check report?
02:05:56 <Guest25031> lots of line saying /usr/share/doc/xxx/html or /usr/share/doc/xx/xx.haddock doesn't exist or isnt a directory or isn't a file
02:07:09 <merijn> Guest25031: tbh, that sounds like something broke your install
02:07:50 <merijn> I'd probably just purge GHC and cabal-install, reinstall them and then try to compile again
02:08:42 <Guest25031> how can i use static compiler?
02:12:04 <Solonarv> I'd just install them via ghcup, instead of the system package manager
02:12:04 <Solonarv> @where ghcup
02:12:05 <lambdabot> https://www.haskell.org/ghcup/
02:12:25 <Solonarv> that ships a static GHC
02:25:40 <jusss> [exa]: wait a sec, but [] is Functor, [a] is not, e->a will return a, but List a will return?
02:26:32 <[exa]> jusss: (e->a) is also not a functor, (e->) is
02:26:59 <[exa]> jusss: the point about functors is that you can change what type they "contain" by fmapping a simple function (a->b)
02:27:11 <jusss> [exa]: yeah, so the problem is that a in [a] is an input or an output
02:28:38 * Rembane does the natural transformation dance
02:28:49 <jusss> it seems I'm getting another puzzle
02:29:04 <Solonarv> jusss: it's an output, if you want to think of it that way
02:29:08 <Solonarv> definitely not an input
02:29:39 <[exa]> like, Maybe , [], Either l, (e->), IO all "contain" 'a' and can be converted using '(a->b)' to contain 'b'
02:31:31 * kuribas doesn't get why the container analogy is so popular
02:31:52 <kuribas> it's undescriptive and mostly wrong
02:32:02 <Solonarv> kuribas: it's reasonably intuitive and works for many common functors, is probably why
02:32:06 <Rembane> kuribas: You can look at it and it works for a while
02:32:14 <kuribas> Solonarv: it's used for monads as well
02:32:43 <kuribas> maybe container = set
02:32:43 <Solonarv> it even works for (e ->) if you view functions as containers with an item for every possible input
02:32:59 <kuribas> so a function is a set, sounds right
02:33:08 <Solonarv> kuribas: yeah, I don't think it works quite as well for explaining monads anymore
02:33:25 <Solonarv> well, if you work within set theory everything is a set, that's kind of the point
02:33:40 <jusss> [exa]: (e->) is functor, ok, it 'contain' 'e', but [a] isn't functor, [] 
02:33:41 <Solonarv> (unless it's too large to be a set, but functions aren't)
02:33:49 <jusss> [] 'contain' a
02:33:57 <Solonarv> jusss: no, (e ->) doesn't contain anything
02:34:15 <Solonarv> you can think of (e -> a) as containing a separate 'a' for every possible 'e' you might apply it to
02:34:19 <jusss> Solonarv: but (e->) return something like 'a'
02:34:33 <kuribas> functor is a structure preserving mapping
02:34:54 <Rembane> What does the word structure mean here?
02:34:56 <dminuoso> [exa]: Imagine a functor having a sort of hole in the type. `(e -> _)` is a functor for every choice of a type e.
02:35:06 <dminuoso> Uhh I meant jusss.
02:35:08 <dminuoso> Of course.
02:35:29 <kuribas> or better a type and it's structure preserving mapping
02:35:34 <[exa]> we need better functor analogy
02:35:51 <[exa]> wo sind meine pfannkuchen
02:36:10 <Rembane> Ganz weg! 
02:36:15 <Solonarv> kuribas: btw, this post convinced me to not dislike the functor~container analogy as much: https://bartoszmilewski.com/2014/01/14/functors-are-containers/
02:36:16 <dminuoso> kuribas: The container analogy is surprisingly good actually.
02:36:16 <kuribas> the analogy would be you have something in a shape, and you change while preserving the shape.
02:37:01 <dminuoso> The reason the container analogy works so well, is because the hask specific functors all tend to model containers really well, for some notion of container.
02:37:08 <jusss> dminuoso: but it conflict between list functor with function functor
02:37:22 <dminuoso> jusss: a function can be thought of as a generalized container, indexed by its domain
02:37:26 <kuribas> Const () is a functor, it doesn't contain anything
02:37:39 <dminuoso> jusss: `Natural -> Char` can be thought of as isomorphic to [Char]
02:37:56 <maerwald> kuribas: no, it contains nothing :)
02:37:59 <dminuoso> So `Natural -> Char` contains many characters, and you select one by feeding the function some input.
02:38:56 <dminuoso> (We need to squint a bit and not focus on things like length)
02:39:42 <dminuoso> kuribas: Thats not a problem, we can map over empty lists too, cant we?
02:40:07 <kuribas> dminuoso: yes, but it isn't a container
02:40:28 <maerwald> you're thinking of collections
02:40:28 <dminuoso> kuribas: Why not? Its just the most trivial container you could think of: an empty container.
02:40:49 <maerwald> container is a very abstract term
02:40:49 <dminuoso> Its always empty.
02:41:00 <maerwald> it can be used to describe functors
02:41:10 <kuribas> container is a poor man's set
02:41:15 <maerwald> I'm confused why people try to reduce it to collections
02:42:10 <jusss> dminuoso: so we can image that a function is a container, there're lots of results in it, we can get the result with give it a index value, and we can image that list is a container, there're lots of results in it, we can get the result with give it a index value, ???
02:43:40 <dminuoso> jusss: There's many ways to think of them as a container. I tend to think of lists not as an ordered set of elements, but rather as a non-determinstic value.
02:43:48 <Solonarv> false equivalence: not all containers have a way to "take out" a value
02:43:51 <dminuoso> (It depends on situation though)
02:44:09 <dminuoso> jusss: So [1,2,3] for me models as "not sure whether 1, 2 or 3"
02:44:19 <dminuoso> Its a kind of "fuzzy container"
02:44:44 <dminuoso> (This notion can help a lot when thinking about the Applicative or Monad instance for []
02:44:48 <dminuoso> For some.
02:48:06 <jusss> what about to see a container that 'contain' a value, a function that 'contain' a output, a list that 'contain' its value
02:48:49 <jusss> (e->a) is a container (e->) 'contain' its output value 'a'
02:49:12 <jusss> [a] is a container [] 'contain' its value 'a'
02:51:13 <jusss> fmap apply a function on that value which is in the container, and get a same container with a new value
02:51:47 <dminuoso> Its things like STM, IO or Async where the container notion is stretched to some degree.
03:16:12 <Phyx-> git grep -n BlockedOnForeignCall
03:20:12 <dminuoso> Phyx-: fatal: not a git repository (or any of the parent directories): .git
03:20:58 <Phyx-> heh, so that's where my focus was..
04:58:28 <tabaqui> has anyone seen tdammers last time?
04:59:04 <tabaqui> s/last time/recently
04:59:11 <Rembane> Some hours ago, how come?
04:59:43 <tabaqui> I've sent him a message one week ago, no respond still
05:00:05 <Rembane> I see. Is it a question only tdammers can answer? 
05:00:11 <tabaqui> He maintains a library I'm using
05:00:21 <tdammers> tabaqui: I did respond, but it may have gotten lost in the bowels of IRC
05:00:32 <tabaqui> oh, ok
05:00:41 <tabaqui> so
05:00:49 <tabaqui> can you repeat please?
05:00:50 <tdammers> to reiterate my answer: the reason there's not been much activity on ginger lately is because I don't have a pressing need to change anything
05:01:20 <tdammers> but if you do, and want to contribute, I'll be happy to accept your contributions and help you along
05:01:21 <tabaqui> I just wanted to bring it in stackage lts
05:01:29 <tdammers> ah
05:01:47 <tdammers> that shouldn't be a huge hassle
05:02:43 <tabaqui> I would be grateful
05:03:30 <tdammers> ooooh, I see...
05:03:51 <tdammers> current stackage has a comment on ginger, saying BuildFailureException Process exited with ExitFailure 1: ./Setup build
05:04:03 <tdammers> unfortunately that doesn't tell us why exactly it failed to build
05:07:37 <Darwin226> Is there a proposal somewhere to remove the "in expression ... in expression .. in equation ..." part of compiler errors? Since we have source locations with a code listing now it's completely redundant.
05:08:14 <Darwin226> and it would dramatically reduce the size of the average error
05:08:40 <phadej> Darwin226: I don't think you need a proposal if you want to implement a flag
05:09:08 <Darwin226> aren't language extensions just flags?
05:09:11 <phadej> implementing flag, then showing by evidence it can be on by default -> profit
05:09:27 <phadej> Darwin226: it's not language extension
05:10:43 <tdammers> tabaqui: ginger builds cleanly against current hackage and all GHC releases 7.10.3 through 8.6.5, but it's possible that it fails for some stackage snapshots, due to the way stack resolves (or rather, doesn't resolve) dependencies
05:10:49 <Darwin226> Sure. I was just hoping that someone else was already doing that
05:11:03 <phadej> Darwin226: ah, sorry, i missunderstood
05:11:16 <phadej> Darwin226: I don't recall anything like that; but it does sound valid
05:11:18 <phadej> idea
05:11:31 <tdammers> tabaqui: running a stack build as we speak
05:12:37 <tabaqui> ok, cool
05:12:51 <tabaqui> I can check deps boundries, btw
05:14:03 <tdammers> hmm, stack barfs on me, blaming cabal... how classy...
05:19:38 <tabaqui> guys, what do you think about give up .cabal in favor of stack file configs?
05:20:26 <Rembane> I'd rather go the other way around. 
05:21:40 <merijn> tabaqui: That seems like a terrible idea, tbh
05:21:58 <yushyin> stack is ok but please also provide a .cabal, always.
05:22:10 <tabaqui> I used this approach for building personal environment (xmobar, xmonad, plugins...)
05:22:14 <merijn> yushyin: Stack uses cabal files too
05:22:28 <tabaqui> so probably it is fine for personal tools
05:22:32 <merijn> yushyin: It just happens to support automatically running hpack, leading some people to use hpack
05:22:47 <merijn> and hpack is the real problem, imo
05:23:27 <yushyin> I'm aware, yes.
05:23:37 <MasseR> merijn: not disagreeing, but why is hpack *the* problem?
05:25:27 <merijn> MasseR: It lags behind the latest features supported by Cabal, it's a woefully underdocumented YAML (which is a terrible format) format, it requires external tooling (hpack) that a large part of the community doesn't have installed and it only provides one feature Cabal doesn't yet, but that could be added without too much problems
05:25:47 <tdammers> the only "advantage" of ditching cabal files in favor of stack configs is that cabal would no longer work
05:26:01 <Rembane> merijn: Which feature does hpack have that Cabal doesn't? 
05:26:15 <tdammers> not to stir up a mud throwing contest here, but I can imagine how this could be considered an advantage by some people
05:26:23 <MasseR> merijn: agree on all but the first one, mostly because I'm not sure what you mean about it
05:26:30 <merijn> Rembane: Cabal doesn't (at the moment) support wildcards without extension for data files
05:26:49 <merijn> MasseR: Not all functionality of Cabal is supported by the hpack format, is what I meant
05:26:58 <Rembane> merijn: Got it. I have never needed that feature, but YMMV I suppose. 
05:27:15 <merijn> Rembane: It's a super minor thing, yeah
05:27:37 <merijn> The main argument for hpack used to be "sharing build-depends across executables" but Cabal now supports common stanzas to do just that
05:28:03 <phadej> (which is btw silly, as YAML natively supports shared sections!)
05:28:05 <MasseR> By the virtue of yaml, hpack also supports sharing configuration between subprojects
05:28:36 <merijn> MasseR: No, I meant that the main reason it became popular is because hpack supported that, but cabal didn't
05:28:41 <merijn> MasseR: But that's no longer true
05:29:31 <merijn> I believe in live and let live when it comes to stack vs cabal, but please just ditch hpack and write cabal files...
05:29:47 <MasseR> merijn: we might be saying different things. We for example have something like 6 subprojects, some of which are libraries for some microservices. Each and every one of them share a common set of language extensions, which is shared in a separate yaml file and included in the hpack file
05:30:09 <MasseR> Which also incidentally was a bane of my existance for months
05:30:48 <merijn> MasseR: Ah, I meant sharing stanzas across exes/libraries in the same cabal package
05:31:22 <merijn> MasseR: tbh, I don't believe in having extensions enabled via cabal files, I'm a firm believer in per-file pragmas
05:31:57 <merijn> MasseR: Although, if that was really critical you could do the same via cabal.project (but then you'd lost portability between stack and cabal-install)
05:34:26 <tdammers> tabaqui: hmm, so ginger apparently works fine against the latest stackage lts
05:34:39 <tdammers> frankly, that's about as far as I'm willing to go in investigating this issue
05:35:36 <tdammers> IMO, if it builds fine against several GHC's on my machine, and hackage's build matrix says it builds fine against any GHC it claims to support, then it is fine, and if it doesn't work with stack, then that's a stack (or stackage) bug
05:48:03 <MasseR> merijn: agreed on the extensions. I tried to debate against my team lead for it
05:48:06 <MasseR> *on it
05:49:07 <MasseR> I think I got bamboozled on it. I agreed on having a really critically limited subset of extensions enabled by default. In the end we have something like ~20 extensions enabled by default
05:50:50 <yushyin> I do would like some of the extensions part of next haskell', tbh
05:52:27 <tabaqui> tdammers: cool, thanks
05:52:42 <tabaqui> I hope to see it in the next release
05:57:01 <tdammers> tabaqui: btw., you do realize that you can also use packages that aren't in stackage with stack, no?
05:57:09 <tabaqui> sure :)
05:57:19 <tdammers> tabaqui: also, out of curiosity, what do you use ginger for?
05:58:30 <tabaqui> business saas infrastructure, frontend sends some configuration files in xml/jinja, saas updates them and sends further
05:58:54 <tdammers> whoa
05:59:28 <tdammers> so you're passing user-supplied templates to ginger?
06:00:02 <tabaqui> not really, user fills very few fields in post form
06:00:22 <tdammers> oh, OK
06:00:25 <tabaqui> somewhere deep in the cloud there is some tools that can work with json/xml templates
06:00:41 <tdammers> so the user supplies a bunch of fields, and you use ginger to bake XML or JSON configuration files from those?
06:00:48 <tabaqui> and saas updates config with some internal information
06:01:36 <tabaqui> we already have the template with few holes, it is not provided by users
06:01:46 <tdammers> yeah, that's alright then
06:02:02 <tabaqui> thank you by the library, btw :)
06:02:08 <tdammers> yw
06:02:54 <tabaqui> ghc-8.4 broke backward compatibility, so I prefer to stay on ghc-8.2.2 instead of ghc-8.6.2
06:03:17 <tabaqui> if iperez will not update Yampa, then I try to fork it later
06:13:46 <tdammers> in fact, interpreting user-supplied templates is doable, if you sandbox them into a monad that cannot do any harm on the host, and limit the execution time and memory for the interpreter job, but it's still a bit icky
06:42:16 <phaul> what is fmap for newtype Cont r a = Cont { runCont :: (a -> r) -> r } ? 
06:42:49 <phaul> I can't work it out, but there should be one as Cont is Covariant in a..
06:43:29 <phaul> there are lots of Monad impls for continuation out there, but I want to understand this from firstprinciples
06:43:52 <merijn> phaul: Well, if you have something that wants "a -> r" to produce an 'r' and "a -> b", what do you get? :)
06:46:55 <phaul> donno. I've spent the last hr trying to match up types, and failed, so just tell and I spend more time to understand it..
06:47:34 <tabaqui> try to write something simple with Cont monad
06:47:48 <tabaqui> but don't use cps in real projects
06:48:02 <merijn> phaul: Think of "Cont r a" as "something containing an 'a'"
06:48:27 <merijn> phaul: It's "something containing an 'a'", so if given a function "a -> r" you can get an 'r'
06:48:47 <merijn> phaul: If you fmap "a -> b" then you get "Cont r b", aka "something containing a 'b'"
06:49:01 <merijn> phaul: So it's like fmap applies a function to the contained 'a'
06:51:14 <dmwit> fmap :: (a -> b) -> ((a -> r) -> r) -> ((b -> r) -> r)
06:51:39 <dmwit> So, let's write `fmap f g h = ...` to begin with, since its type says it's a thing that takes three arguments.
06:52:01 <dmwit> In `...`, we have `f :: a -> b`, `g :: (a -> r) -> r`, and `h :: b -> r`.
06:52:22 <dmwit> The only two things we can really combine in any sensible way are `f` and `h`, which we can compose.
06:52:35 <dmwit> This gives us `h . f :: a -> r`.
06:52:58 <phaul> got it.
06:53:04 <dmwit> That's the type of argument `g` is looking for, so we could now combine those two to get `g (h . f) :: r`.
06:53:20 <dmwit> We're supposed to return an `r`, so we could return that.
06:53:31 <phaul> thanks guys. the trick of thinking of fmap as 3 argument function just didn't occur to me
06:53:37 <dmwit> So `fmap f g h = g (h . f)` should type-check. Then we only need to check that it does what we want it to do.
06:54:07 <dmwit> (...plus add in some newtype wrapping and unwrapping, of course. ;-)
06:58:49 <tabaqui> LeiraSarvo
06:58:56 <tabaqui> damn
06:59:03 * tabaqui is changing password
07:06:35 <tty1_> Hey guys, I'm reading "learn you a haskell" and the author continually says throughout the book that "lists are for non-deterministic values" yet when I read his explanation for what he meant it didnt make sense to me, it didnt sound like anything special and it definately didnt sound non-deterministic (unless maybe an IO is put into it).. any idea what he might have meant
07:07:01 <tty1_> in my head non-deterministic means that given the same starting conditions you can have different ending conditions.. in other words, same input doesnt garuntee the same output
07:08:13 <roconnor> in this case non-deterministic means a function/algorithm with multiple simulaneous outputs.
07:08:28 <merijn> tty1_: The idea is that if you have a function "a -> [b]" the Monad instance for list will explore *all* resulting elements parallel
07:08:38 <tty1_> roconnor: in that sense a tuple can also be seen as non-deterministic?
07:09:02 <tty1_> since it has multiple values in it and can represent multiple outputs
07:09:03 <roconnor> typically outputs would have the same type.
07:09:09 <merijn> tty1_: So the idea is that the list monad lets us easily explore the entire potential result space, rather than a single non-deterministic point in that search space
07:09:34 <tty1_> merijn: i havent gotten to monads yet (im doing that chapter now) so i have yet to understand what monad means as a word
07:09:47 <roconnor> but ya, you might use return a pair to represent the output of a non-determinisitc sqrt function.
07:09:59 <merijn> tty1_: As a word it means nothing, just mentally replace it with "an abstract interface"
07:10:21 <roconnor> however, if you want to compose lots of non-deterministic functions, you end up needing something like a list.
07:10:22 <tty1_> okkk, I can kinda see that, non-deterministic seems like a bad word to use there for me but at least I understand what he means
07:10:23 <merijn> tty1_: tbh, talking about lists as modelling non-determinism without talking about their monad instance is a bit nonsensical
07:11:14 <tty1_> merijn: well im pretty sure he said that in an attempt to get us thinking in a monadic way, it just failed cause it seemed like a silly thing to say given that i didnt know about monads yet
07:11:16 <merijn> > [1..5] >>= \x -> ([6..10] >>= \y -> (pure (x, y)))
07:11:18 <lambdabot>  [(1,6),(1,7),(1,8),(1,9),(1,10),(2,6),(2,7),(2,8),(2,9),(2,10),(3,6),(3,7),(...
07:11:37 <merijn> Or, more readable
07:11:39 <tty1_> anyway yea i understand what he tended the word to mean at least, and that is very helpful thank you
07:11:58 <merijn> > do { x <- [1..5]; y <- [6..10]; pure (x,y) }
07:12:00 <lambdabot>  [(1,6),(1,7),(1,8),(1,9),(1,10),(2,6),(2,7),(2,8),(2,9),(2,10),(3,6),(3,7),(...
07:12:15 <merijn> We can do even do more complicated and interesting things like
07:12:22 <merijn> > do { x <- [1..5]; y <- [0..x]; pure (x,y) }
07:12:24 <lambdabot>  [(1,0),(1,1),(2,0),(2,1),(2,2),(3,0),(3,1),(3,2),(3,3),(4,0),(4,1),(4,2),(4,...
07:13:03 <merijn> tty1_: tbh, I don't think LYAH is very good as intro book, but I'm not aware of a better one that's free
07:13:56 <tty1_> merijn: i am not impressed with it in terms of how he explains things. But I am very good at learning concepts from pure examples (the less talking the better). So in that regard ive found it very helpful until now despite being poorly written
07:14:19 <merijn> Well, if you like brutal and not verbose, there's always
07:14:22 <merijn> @where tutorial
07:14:23 <lambdabot> http://www.haskell.org/tutorial/
07:14:34 <merijn> @quote brend gentle
07:14:35 <lambdabot> No quotes for this person. Your mind just hasn't been the same since the electro-shock, has it?
07:14:42 <merijn> @quote gentle.intro
07:14:42 <lambdabot> haskruby says: A Gentle introduction to Haskell is as gentle as Mike Tyson
07:14:49 <merijn> hmm, not the one I was going for
07:15:49 <merijn> @quote Brend gentle
07:15:49 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
07:15:51 <merijn> That one :p
07:16:41 <dmwit> Well, the Gentle Introduction to Haskell was written by PL researchers for other PL researchers. It... *is* pretty gentle, if you're already an expert in Coq.
07:16:59 <merijn> I know
07:17:18 <merijn> dmwit: Just a bit of expectation management ;)
07:17:22 <tty1_> well it may be just my speed. I mean if its all examples and very little explanation, but the examples are really good ones then It may be better for me thant he alternatives
07:17:39 <merijn> There's also the CIS-194 stuff online
07:17:52 <dmwit> Anyway, the Gentle Intro is my personal favorite, and I'm sad that it's fallen out of favor and gone unmaintained.
07:18:06 <merijn> dmwit: Be the change you wanna see in the world! ;)
07:18:26 <dmwit> Yup. It's on my long list of things to do in my copious free time. =)
07:19:44 <merijn> dmwit: I know the feeling :p
07:40:49 <c_wraith> I swear, one of these days I'm going to write a tutorial on reading types.
07:41:31 <c_wraith> maybe I'll find a week to take off work for it.
07:41:42 <merijn> c_wraith: With what audience in mind?
07:42:02 <c_wraith> people who think types aren't documentation
07:42:53 <merijn> c_wraith: Does Haskell for Readers perhaps cover what you wanted?
07:42:59 <c_wraith> no
07:43:29 <c_wraith> it's nice, but it doesn't cover "this type requires the value have these properties"
07:43:46 <merijn> So more of a "theorems for free" introduction kinda dealio?
07:44:11 <c_wraith> except without the word "theorem" :)
07:45:38 <merijn> c_wraith: Sure, gotta trick people into reading about math :)
07:46:00 <c_wraith> I've never really understood how the free theorem generator works. even though I can predict its output. so I clearly don't understand it for real. :)
08:03:08 <roflik> hello, haskell newb here.  i'm trying to connect to a MS SQL Server using HDBC-odbc.  so far i only need to select data, but it's failing.  it returns some data, then says SqlError {seState = "[]", seNativeError = -2; seErrorMsg = "sqlFetch: []"}
08:03:45 <merijn> roflik: That looks like the SQL server/library is hitting an error
08:05:04 <roflik> merijn: what error could it be?   Database.ODBC.SQLServer does not give me any errors.
08:06:18 <roflik> merijn: i'm trying to move to HDBC-odbc because i need column names,  odbc (D.O.SS) does not have that functionality afaict.
08:07:13 <merijn> I'm not familiar with ODBC or SQLServer, tbh
08:51:05 <zestymug> whats your favorite monad
08:51:59 <Taneb> Reverse state monad
08:52:45 <bahamas> hello. how do I fix this? "base-noprelude must match >=4.11 && <5, but the stack configuration has no specified version  (latest matching version is 4.12.0.0)" if the last matching version is 4.12.0.0. doesn't that fall within >=4.11 && <5?
08:56:37 <Solonarv> bahamas: I think that's the latest matching version *anywhere*
08:57:25 <bahamas> Solonarv: what does that mean?
08:57:30 <Solonarv> I suppose the idea is that you would look up which snapshots contain base-noprelude-4.12.0.0, and pick one of them to use instead of the current one
08:58:27 <cocomo> is it ok to conceptualize recursion as function composition f(f(f(x))) = (f.f.f)(x)
08:58:29 <Solonarv> which snapshot are you using currently?
08:58:58 <bahamas> Solonarv: if you mean resolver, it's lts-10.0
08:59:06 <Solonarv> bahamas: that is what I mean
08:59:09 <Solonarv> too old
08:59:18 <Solonarv> I'm guessing, anyway
08:59:34 <bahamas> Solonarv: I'm trying to use sparkle, so I don't think I have a choice in choosing the resolver
08:59:47 <bahamas> I assume the other option is to change the base version in my project
08:59:57 <Solonarv> I have no idea what sparkle is
09:00:04 <bahamas> I'm talking about this project: https://github.com/tweag/sparkle
09:01:37 <Solonarv> ah, I see
09:02:55 <Solonarv> base-noprelude doesn't seem to be in that snapshot at all
09:03:28 <Solonarv> base-noprelude-4.10 would probably be compatible with it, but that's not in the version range you need (>= 4.11 && < 5)
09:03:38 <cocomo> is there a general purpose functional programing channel?
09:04:00 <bahamas> Solonarv: actually, this is a new project, so I think it's ok to just downgrade the version of base-noprelude in my project.
09:04:00 <jgt> cocomo: there's a general purpose FP Slack channel
09:04:11 <jgt> though I feel kinda dirty recommending a Slack channel here on IRC
09:04:18 <Solonarv> bahamas: yeah, that would work
09:04:30 <jgt> cocomo: https://fpchat-invite.herokuapp.com/
09:04:46 <cocomo> thanks jgt 
09:04:46 <bahamas> Solonarv: it's actually working :) thanks for the help
09:04:48 <Solonarv> (and you should probably just specify ==4.10.* in that case)
09:05:26 <bahamas> ok, I'll do that
09:44:28 <turion> stack ghci always loads the stuff I put under other-modules in my .cabal. Is that intended? I thought other-modules are never to leave the internal scope of the package?
09:46:22 <Solonarv> turion: ah, but you're running 'stack ghci' from within the package
09:46:50 <MarcelineVQ> afaik yes, stack ghci/repl loads the project into ghci. stack exec ghci should be a regular ghci with the same environment as your poject
09:47:12 <turion> Solonarv: Yes... so if I create an executable and run stack ghci myexecutable, I shouldn't see them anymore?
09:47:31 <turion> But then I wouldn't see the exposed-modules either...
09:47:53 <Solonarv> maybe, I don't actually use stack anymore so I'm not sure
09:48:57 <dmj`> stack removed ghcjs installation support :(
09:49:26 <turion> Ok, related question: I have a library, and I want to ship a .ghci file that defines a few ghci macros that call a few functions from my library. Does anyone else do something like this?
09:51:32 <turion> Say I have in my .ghci ":def foo foo", and foo is a function in the module Foo my library. How can I make sure Foo is imported?
09:52:18 <Solonarv> you put ':m + Foo' on an earlier line
09:52:27 <Solonarv> (or an import statement)
09:53:40 <turion> Solonarv: Yes! :m +, not :load
09:54:14 <nshepperd> hm... when i run stack ghci it also loads the package environment from ~/.ghc/x86_64-linux-8.6.4/environments/default
09:54:24 <nshepperd> that seems like it could cause problems
09:54:42 <phadej> nshepperd: I think new enough stack doesn't load
09:56:01 <phadej> oh, there weren't a release with a fix
09:56:04 <phadej> no luck then
09:56:49 <Solonarv> nshepperd: there's some flag or environment variable you can pass to GHC(i) to make it not do that
09:57:22 <phadej> or just don't use stack :P
09:57:29 <phadej> cabal v2-repl is at least as good
09:57:45 <Solonarv> or you can go the other way and tell cabal to not generate it by setting 'write-ghc-environment-files: never'
09:58:09 <Solonarv> not using stack is also a solution, yes :P
09:59:10 <phadej> (for the record: write-ghc-environment-files is about local ~/.ghc.environment.* files; not the "global" ~/.ghc/.../environments/$name)
10:00:05 <Berengal> I'm having some issues with deriving instances for GADTs, can I get Show, Eq and Ord for this? https://gist.github.com/Berengal/5705cb84a439501113733d5e1869ad17
10:00:54 <phadej> Berengal: you can try StandaloneDeriving
10:01:08 <phadej> and `deriving instance Show (Expr2 a)`
10:01:14 <phadej> if that doesn't work, then you have to write manually
10:01:25 <Berengal> It doesn't work
10:02:21 <nshepperd> alright, i'll use stack-git then
10:02:36 <talqu> hi, https://pastebin.com/fqx3s0qA, the static css, js files get loaded well when i run this basic servant app with `cabal run`. However, once i build the binary it stops working. What am I missing to make the /static permanent and working when building the binary?
10:04:42 <phadej> talqu: the static/ contents aren't "in the binary", you have to move them with your binary (and run binary in CWD so static/ is valid directory)
10:06:10 <talqu> phadej: cwd? can i declare all of this in cabal file? Any link where I can learn how to do what you say
10:06:21 <phadej> "current working directory"
10:06:30 <talqu> :) oh
10:08:09 <phadej> talqu: it depends what you want. if you want to move files along side the binary, then you have to move them; or you can use something like http://hackage.haskell.org/package/file-embed-lzma-0/docs/FileEmbedLzma.html#v:embedRecursiveDir to actually embed files into the binary; like in http://hackage.haskell.org/package/servant-swagger-ui-0.3.2.3.19.3/docs/src/Servant.Swagger.UI.html
10:08:18 <roconnor_> Can I set per-library haddock flags in .cabal?
10:09:14 <Zvpun> How should one split a list in items of 3 elements? Is `f [] = []; f xs = let (a, b) = splitAt 3 xs in a : f b` a good version?
10:09:26 <phadej> ;t chunksOf
10:09:28 <phadej> :t chunksOf
10:09:30 <lambdabot> Int -> [e] -> [[e]]
10:09:38 <Solonarv> yeah, that
10:09:58 <phadej> roconnor_: no you cannot; you could however in cabal.project in package settings (maybe, it should work)
10:10:01 <Solonarv> but the implementation of chunksOf is pretty much what you wrote there anyway
10:10:48 <roconnor_> phadej: ah.  I need/want everything bundled into one .cabal file since I'm using backpack.
10:11:24 <talqu> phadej: what solution is better recommended? I'm playing with nix also, i was able to deploy a simple servant server with nixops, however, now i have this issue with static files (I don't wanto to move them manually/ with script to some remote machnine's dir and use them from that binary). I'll see the solution which let's embed the static files in the binary
10:11:33 <Zvpun> and how would you critise my version of chunksOf?
10:12:27 <Solonarv> Zvpun: it's perfectly fine, actually
10:13:12 <Solonarv> I'd make the 3 an argument rather than hard-coding it though
10:13:14 <Zvpun> I was thinking about foldr but I saw nothing, now I wonder.
10:13:19 <Zvpun> ofc
10:13:43 <Solonarv> you can write it using foldr but it's not particularly pretty
10:14:45 <Solonarv> I'd write it like so:
10:14:45 <Solonarv> chunksOf n = go where go [] = []; go xs = let (b, e) = splitAt n xs in b : f e
10:16:48 <phadej> talqu: embedding is easier to deploy, as your artifact is binary + C-shared dependencies
10:17:09 <phadej> talqu: the downside is https://github.com/haskell/cabal/issues/5786
10:17:40 <phadej> (and in fact with fileembedlzma the static contents are compressed, which I found handy; as JS and CSS compress quite well)
10:18:09 <Zvpun> I have this intuition about folds acting on one element of a time. Is there a generalization?
10:18:40 <Solonarv> yes, several of them
10:20:18 <Solonarv> if I wanted to use something to abstract out the recursion here, I would use
10:20:18 <Solonarv> :t unfoldr
10:20:20 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
10:20:22 <talqu> phadej: thank you
10:21:30 <Solonarv> @let myChunksOf n = unfoldr (\xs -> case xs of [] -> Nothing; _ -> Just (splitAt n xs))
10:21:32 <lambdabot>  Defined.
10:21:37 <Solonarv> :t myChunksOf
10:21:38 <lambdabot> Int -> [a] -> [[a]]
10:21:47 <Solonarv> > myChunksOf 3 [1..10]
10:21:50 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
10:22:11 <Zvpun> interesting
10:22:56 <Zvpun> thank you for your time
10:23:56 * Solonarv bows
10:24:01 <Solonarv> thank you, I'm here all day!
10:25:03 <roconnor_> phadej: where is it legal to place the "doc-index-file" cabal field?
10:28:05 <roconnor_> ah maybe cabal.project
10:28:27 <phadej> roconnor_: that sounds like something which goes into ~/.cabal/config; but I have no idea if it's recognised there
10:29:24 <phadej> roconnor_: that goes beyond my knowledge of interactions with haddock :/
10:37:50 <Berengal> is there a way to say something like "forall (n :: Nat). (n < 10) => Foo n" ?
10:38:43 <yitz> map . filter (< 10) [1,2,..] ?
10:38:54 <Cale> Berengal: Not without involving singletons and a whole lot of impractical nonsense
10:39:24 <Cale> oh, wait, you *only* want a constraint at the type level?
10:39:32 <Berengal> Yes, only the type level
10:39:34 <Cale> Then you could implement < as a type family
10:39:56 <talqu> phadej: I'm stuck of how to write something like this: `serveDirectoryFileServer $(embedRecursiveDir "static")`. serveDirectoryFileServer is servant-servant function and takes a FilePath.
10:40:05 <Cale> or as a type class...
10:40:21 <phadej> talqu: serveDirectoryEmbedded
10:40:22 <Berengal> I tried doing it as a type class but the typechecker blew up
10:40:29 <Berengal> but I probably did it wrong
10:40:51 <Berengal>  I had 1 < 2, 2 < 3 etc. and (a < b, b < c) => a < c
10:41:01 <phadej> % :t 5 <= 10
10:41:01 <yahb> phadej: Bool
10:41:07 <phadej> % :kind! 5 <= 10
10:41:08 <yahb> phadej: ; <interactive>:1:3: error: Not in scope: type constructor or class `<='
10:41:16 <phadej> % import GHC.TypeLits
10:41:16 <yahb> phadej: 
10:41:18 <phadej> % :kind! 5 <= 10
10:41:18 <yahb> phadej: 5 <= 10 :: Constraint; = 'True ~ 'True
10:41:32 <phadej> :t Proxy :: Proxy (5 <= 10)
10:41:34 <lambdabot> error:
10:41:34 <lambdabot>     Not in scope: type constructor or class ‘<=’
10:41:45 <phadej> % :t Proxy :: Proxy (5 <= 10)
10:41:45 <yahb> phadej: Proxy ('True ~ 'True)
10:42:24 <phadej> http://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-TypeLits.html#t:-60--61-
10:42:46 <Cale> Berengal: I'd go with something like
10:42:55 <Cale> class LessThan (n :: Nat) (m :: Nat)
10:43:00 <Cale> instance LessThan Zero m
10:43:04 <Berengal> phadej: that's neat
10:43:14 <Cale> instance LessThan n m => LessThan (Succ n) (Succ m)
10:43:38 <Cale> Oh, nice, right, TypeLits has some arithmetical stuff built in
10:43:49 <phadej> Cale: that's less-than-equal-to btw, the one you wrote
10:43:54 <Cale> oh, right :D
10:43:55 <Berengal> I actually have a very bounded enum used to tag GADTs I'm trying to order
10:44:17 <Cale> If you want a strict bound, you want instance LessThan Zero (Succ m)  as the base case
10:44:47 <Cale> Berengal: What is the ultimate goal of this?
10:45:16 <phadej> Cale: https://github.com/futurice/haskell-mega-repo/blob/2e227ec40384383d99b83c5b7579251c025226fa/futurice-integrations/src/Futurice/Integrations/Serv.hs#L47 I wrote once LessThan stuff
10:45:23 <Berengal> The ultimate goal is just messing around with the type system, but I'm trying to get something similar to subtyping
10:45:27 <phadej> to make a set: https://github.com/futurice/haskell-mega-repo/blob/2e227ec40384383d99b83c5b7579251c025226fa/futurice-integrations/src/Futurice/Integrations/Serv.hs#L181
10:45:51 <phadej> it works fine for <10 element enum
10:46:41 <Cale> phadej: Ah, yeah, this general strategy of having a GADT of indexed proofs, and then a typeclass-based proof search is really interesting in general.
10:46:49 <Berengal> I have a type "Expr a" where the a is a phantom type and I just want to say "FooExpr :: forall a. (a < SomeBound) => Int -> Expr a -> Expr SomeOtherBound"
10:47:03 <Cale> I've done that with finding type level list elements
10:47:16 <phadej> Cale: for this example it actually works, even without overlapping instances
10:47:26 <phadej> which makes it fast enough in practice
10:48:08 <phadej> Cale: in fact, you have to formulate LessThan exactly as you wrote, for search to work
10:49:06 <phadej> the LERefl :: LE n n; REIncr :: LE n m -> LE n ('S n) cannot be found directly
10:49:25 <phadej> though is the same proposition
10:49:47 <Cale> phadej: Yeah, you want to be pattern matching on the first argument so that you can actually get somewhere :)
10:50:31 <phadej> I want to some basic stuff to @package fin; but the fact there's two way to formulate, and then whether LT should be own GADT or type alias LT n m = LE n (S m) etc makes my head hurt
10:50:37 <phadej> too many questions to answer at once
10:50:38 <talqu> phadej: serveDirectoryEmbedded $(embedRecursiveDir "static") does not work either :/
10:50:57 <phadej> talqu: and you have LANGUAGE TemplateHaskell enabled?
10:51:18 <phadej> talqu: could you paste an error into some pastebin
10:51:58 <halogenandtoast> For types like Name, which would be preferable `type Name = String` or `newtype Name = Name { getName :: String }`
10:52:13 <phadej> in the long run; latter
10:52:15 <cocreature> halogenandtoast: the latter
10:52:37 <Cale> halogenandtoast: If you're going to do something at the type level at all, probably newtype
10:52:50 <cocreature> the former doesn’t provide additional safety but it still makes it harder to use your API since I have to figure out what the type synonym actually maps to.
10:53:22 <Cale> halogenandtoast: But consider how much benefit you're actually getting from the newtype -- how often are you likely to confuse a Name with some other piece of text?
10:53:41 <Cale> If it's a lot, then go for it and newtype, if it seems kind of unlikely, then maybe now.
10:53:42 <Cale> not*
10:54:31 <Berengal> I like sticking newtypes at module boundaries and work with the wrapped type directly inside a single module
10:55:58 <talqu> phadej: sorry, im an idiot, i didn't have templateHaskell extension enabled. It's the first time i needed it :) However the error started like Couldn't match expected type `template-haskell-2.14.0.0:Language.Haskell.TH.Syntax.Qtemplate-haskell-2.14.0.0:Language.Haskell.TH.Syntax.Exp... Seeing it even now doesn't help me to understand than the extension is missing. Anyways, it compiles now, thank you very much for th
10:55:59 <talqu> e help :)
10:56:49 <phadej> talqu: good; now you learned than when you have template-haskell...Q template-haskell.Exp doesn't match, that's because TemplateHaskell is not enabled :)
10:57:23 <phadej> a bit like
10:57:29 <phadej> > "1" + "2"
10:57:31 <lambdabot>  error:
10:57:31 <lambdabot>      • No instance for (Num [Char]) arising from a use of ‘+’
10:57:31 <lambdabot>      • In the expression: "1" + "2"
10:57:45 <phadej> (which might mean that you don't enabled OverloadedStrings)
10:57:47 <halogenandtoast> cocreature and Cale thanks, I feel like I have heard here a number of times to use the latter
10:57:53 <halogenandtoast> but I forget why it might be better
10:58:53 <phadej> halogenandtoast: not really an advice, try to go with former in big enough project (arbitrarily >=3kLOC); you'll learn why through own experience
10:59:52 <phadej> halogenandtoast: in fact exactly the same effect why dynamicly typed languages are quie fine for small projects with little external dependencies: you can keep all stuff in head quite fine
10:59:54 <Solonarv> Berengal: btw, you can just write: type n < m = CmpNat n m ~ 'LT
11:00:00 <Solonarv> to define <
11:01:05 <Cale> halogenandtoast: Well, newtype adds an actual new datatype which the type system will consider different, and so it can help you distinguish whether you're using data correctly, but you'll also have to deal with explicitly wrapping and unwrapping things (even if the runtime cost of that is zero). By contrast, type only makes a new name for an existing type, and doesn't really help prevent any bugs.
11:04:00 <jle`> halogenandtoast: i think the two serve different purposes
11:04:14 <talqu> hmm, now I've noticed that changing static files does not reload them. I have to stop ghchid -r and rerun it again. phadej how do you approach this type of problem? In other language I would use serveDirectoryFileServer "static/" in development mode, and `serveDirectoryEmbedded $(embedRecursiveDir "static")` in production mode based on the env variable. Is it ok to do the same here also?
11:04:21 <jle`> halogenandtoast: the former is to help with conceptualization and understandling
11:04:26 <jle`> halogenandtoast: the latter is for type-safety and semantics
11:05:15 <jle`> so the first one doesn't help at all with type safety, and the second is sort of the opposite of helping conceptualize certain types
11:05:32 <jle`> the second is an abstraction to 'hide' the internal representation, in a sense
11:08:07 <roconnor_> phadej: Are you in the middle of making haddock work with backpack? @ https://github.com/haskell/cabal/commit/16db160988c1f653e777e15552a98fe28d8908a9 ?
11:12:42 <phadej> roconnor_: not really, I wanted to make reexported-modules appear in haddock module listing; there might be positive effect on signatures too
11:14:25 <phadej> talqu: i'd rather make it a cabal flag; so there are no conditionals in the final binary; but i don't really write JS / CSS a lot, for that to be a problem
11:19:12 <Solonarv> hm, that actually seems like a bug in the file embed library you're using
11:19:37 <Solonarv> pretty sure TH has a function to declare "I am depending on this external file, please recompile when it changes"
11:20:27 <phadej> Solonarv: I did link https://github.com/haskell/cabal/issues/5786 issue
11:20:42 <phadej> Solonarv: it has, but it doesn't work with v2-build
11:20:50 <Solonarv> aw, dang
11:21:01 <Solonarv> I was too lazy to clic the link earlier
11:21:03 <phadej> (ghc realises if there's something else changed though)
11:21:28 <phadej> as in, an empty line in any file
11:21:32 <phadej> but that's :(
11:28:47 <talqu> phadej: while googling i found that based on flag it's possible to toggle between main-is: A.hs or main-is: B.hs for example. Is it what you were suggesting in my case too, dispathing different files? Sorry for such a noob, is there some link I could read about that, please paste it
11:35:13 <Solonarv> talqu: I'd just use CPP here (C PreProcessor)
11:36:44 <Solonarv> let me find some relevant docs
11:39:54 <phadej> talqu: yes, the simplest case would have hs-source-dirs: src for common stuff; and hs-source-dirs: src-embed  for embbedded or hs-source-dirs: src-with with a single method `serveStaticDirectory :: ServerT Raw m` 
11:40:24 <phadej> defined as serveDirectoryEmbedded $(embedRecursiveDir "static") in one and serveDirectoryFileServer "static" in other
11:41:54 <phadej> in this (simple) case CPP approach would work too; but there more stuff you have conditional on the same thing, the more it makes sense to just have compeletely separate modules
11:43:10 <Solonarv> talqu: read about cabal flags here: https://cabal.readthedocs.io/en/latest/developing-packages.html#configurations
11:43:10 <Solonarv> example of how to do this with CPP: https://gist.github.com/Solonarv/b7cf341485474ac9559cb9b321cfbf28
11:54:17 <nek0> Fellow haskellistas, for a JSON-API server I would like to have a volatile mutable global storage for authenticatiuon tokens. Is it possible to fabricate this wthout having to resolve tos State Transformer Monads?
11:54:45 <jgt> nek0: why not STM?
11:55:06 <jgt> (I'm guessing I don't understand the question)
11:55:32 <Solonarv> nek0: it doesn't actually have to be global, does it?
11:56:06 <nek0> jgt: I find setting up a STM stack painful and too much over the top.
11:56:17 <jgt> I just realised State Transformer Monad also shares the STM initialism
11:56:25 <jgt> I actually meant Software Transactional Memory
11:56:27 <Solonarv> heh
11:56:28 <nek0> Solonarv: maybe not fuly global, but with a higher level scope.
11:56:59 <jgt> maybe I'm dumb but if I were doing this my first thought would be stick it in a TVar
11:57:14 <jle`> nek0: if you're making a server you can try using STM maybe
11:57:22 <Solonarv> TVar, or IORef, or MVar, or whatever
11:59:11 <nek0> I would like to have a accessible name for that storage and not pass a reference aroud.
12:00:06 <nek0> or is it something I don't fully understant?
12:00:26 <Solonarv> if you just want something more convenient than passing it around explicitly you can probably stick it in a ReaderT
12:00:42 <Solonarv> IIRC most of the web frameworks let you do that
12:01:04 <jgt> that's basically how Yesod works I think
12:01:14 <jgt> and RIO? (?)
12:01:44 <Solonarv> RIO is not really related
12:01:49 <jgt> and then you'd do something like this in your handler
12:02:07 <jgt> tokens <- getsYesod appAuthenticationTokens >>= readTVarIO
12:02:22 <jgt> ok yeah don't listen to me I'm clueless :P
12:03:37 <nek0> I'm using servant here.
12:04:43 <Solonarv> ah, I'm not sure if servant has a facility for changing which monad the handler runs in
12:05:48 <Solonarv> according to the docs it does, let's see
12:06:20 <boj> nek0: you would probably want a small ReaderT IO stack which passes around a TVar/MVar/IORef, and you use `ask` to grab it when needed
12:08:42 <talqu> phadej: Solonarv thank you! It was very helpful
12:09:20 <jgt> now that boj said ReaderT IO I feel less dumb for having said "RIO", because I was fairly sure that's essentially what RIO is
12:09:51 <boj> jgt: not sure how widely used that is yet, so wanted to clarify
12:10:24 <boj> it can be confused with an unrelated prelude replacement as well
12:12:18 <boj> the acronym that is
12:13:00 <nek0> hmm. ok. I will probalby stick to a StateT IO stack, since I also need to alter the state, like adding and removing tokens.
12:13:17 <nek0> Thanks so far for clarifying that for me.
12:13:26 <boj> nek0: keep in mind that StateT will not work if your system is concurrent
12:13:36 <nek0> oh.
12:13:42 <nek0> hmm...
12:14:05 <nek0> in that case I would want to use what?
12:14:12 <boj> what i described
12:15:40 <Solonarv> pass around an IORef/MVar/TVar and modify that
12:16:08 <Solonarv> very rough sketch: https://gist.github.com/
12:16:11 <Solonarv> whoops
12:16:15 <Solonarv> https://gist.github.com/Solonarv/13ab61dac615331d0ac2154e70e0e82c
12:17:03 <nek0> but i can't alter the state inside a ReaderT after putting it there, or do I have a misunderstanding?
12:17:29 <boj> nek0: TVar/MVar/IORef are mutable references
12:17:53 <nek0> ah. ok. Now I understand.
12:17:57 <Solonarv> you don't put your state in there, you put a mutable reference
12:18:01 <nek0> I never alter the reference.
12:18:15 <nek0> thanks a lot.
12:18:40 <fen_> the problem with trying to make zippers from nested containers is that each level could be unfolded value-wise to progress the zipper forwards. the Get instance for a nested container that results from an instance recursion must therefor give an instance for each depth and some way to specify which instance to use
12:19:28 <fen_> how can this be done? to give the depth of the desired get instance... and to recursively produce each of these instances 
12:19:36 <Solonarv> inside a handler you might do something like:
12:19:36 <Solonarv> storeRef <- ask
12:19:36 <Solonarv> modifyMVar storeRef $ \oldStore -> ...
12:22:36 <fen_> for example, just as you can have get :: [a] -> Maybe (a,[a]), for nested containers there are as many choices as nestings, eg; get :: [[a]] -> Maybe (a,[[a]]) or get :: [[a]] -> Maybe ([a],[[a]])
12:25:52 <fen_> seems like a TypeApplication might be the way to go, over the `a' type of State x s a, with [[a]] -> Maybe (a,[[a]]) being State x [[a]] a, with x s a ~ Maybe (a,s) 
12:26:25 <fen_> but then still not quite sure how to generate each of these instances
12:27:58 <fen_> seems like the zipper would have to store a Nat depth as well, and somehow generate the TypeApplication from that...
12:28:57 <fen_> or maybe a Zipper would be as yet unspecified as to which instance to use, and this could be specified with a TypeApplication? 
12:29:12 <fen_> but then that might throw an ambiguous instance error...
12:30:17 <fen_> maybe by representing nested containers as a nonempty type level list of containers (something like being folded with Compose)
12:30:43 <fen_> then a Nat could be included, specifying which depth the nesting was "open" at
12:31:29 <fen_> as if it were a type level zipper of the nestings, where the zipper position specifies the "upper" and "lower" nestings...
12:31:44 <fen_> that might remove the ambiguity
12:31:54 <fen_> but not sure if thats the right way to do it
13:00:56 <Lisa_TX> You wanna watch my Live (Starting in 8-10 minutes)? I am going to touch & play with myself. VIP members get Requests Permissions (FREE VIP for the next 2 people). Link to my room: https://cutt.ly/EtQnEI ♥
13:31:00 <roconnor> phadej: I'm moderately convinced I cannot haddock reexported modules from internal libries because Cabal's haddock support keeps overwritting the generated haddock interface files when compiling each internal library.
13:40:02 <bartavelle> why is evaluating "id id id id id id id id id id id id id id id id id id id id 5" in ghci taking a time exponential in the number of "id", while typing it is instantaneous?
13:40:31 <bartavelle> naively I would have expected the evaluation to be quick
13:41:18 <koala_man> wow, look at that
13:41:23 <ricky_clarkson> fidbonacci
13:41:35 <NemesisD> i've got a type for CPU count and a type for memory amount, is there some way (maybe type familiies or something) to create a product type where the choice of CPU determines the choices of memory? e.g. 1 cpu allows 512mb and 1gb, 2cpu allows 1gb, 2gb
13:42:12 <roconnor> bartavelle: https://stackoverflow.com/questions/23746852/why-does-haskells-do-nothing-function-id-consume-tons-of-memory
13:42:28 <bartavelle> roconnor: thanks, I should have googled it :/ will read it right now
13:43:05 <bartavelle> and it is also very clear
13:46:57 <jle`> bartavelle: yeah, the difference is clear if you try compiling and running it, and the time spent is in the compilation
13:47:10 <jle`> the problem is in the typechecking
13:48:21 <jle`> ah, a comment on the SO question says naive type inference is potentially double exponential
13:50:53 <bartavelle> why is it fast to :t the expression, and slow to interpret it then?
13:51:48 <roconnor> I'm a little confused to.  Without polymorphic let, the type inference ought to be (quasi-)linear time
13:52:06 <geekosaur> third comment
13:52:26 <geekosaur> :t does sharing, which is lost during actual compilation
13:52:27 <lambdabot> error: parse error on input ‘,’
13:54:17 <ricky_clarkson> I'm not getting this id thing. :t id id id gives a -> a, not a more complex signature. How can I see the more complex signature, and why does it happen?
13:56:21 <phadej> ricky_clarkson: the complex type is the type of first `id`
13:56:27 <Solonarv> :t (id :: ()) id id
13:56:28 <lambdabot> error:
13:56:28 <lambdabot>     • Couldn't match expected type ‘(a1 -> a1) -> (a2 -> a2) -> t’
13:56:28 <lambdabot>                   with actual type ‘()’
13:56:35 <phadej> Solonarv: clever :)
13:56:57 <Solonarv> :t (id :: ()) id id id id id -- uh oh
13:56:58 <lambdabot> error:
13:56:59 <lambdabot>     • Couldn't match expected type ‘(a1 -> a1)
13:56:59 <lambdabot>                                     -> (a2 -> a2) -> (a3 -> a3) -> (a4 -> a4) -> (a5 -> a5) -> t’
13:57:21 <Solonarv> and this doesn't even show the entire type, actually
13:57:32 <Solonarv> :t (id :: ()) id id `asTypeOf` id
13:57:34 <lambdabot> error:
13:57:34 <lambdabot>     • Couldn't match expected type ‘(a1 -> a1) -> (a2 -> a2) -> a -> a’
13:57:35 <lambdabot>                   with actual type ‘()’
13:57:41 <Solonarv> a-ha!
13:58:32 <phadej> :t (id :: ()) id id () `asTypeOf ()
13:58:33 <lambdabot> error: parse error on input ‘(’
13:58:43 <phadej> :t (id :: ()) id id () `asTypeOf` ()
13:58:45 <lambdabot> error:
13:58:45 <lambdabot>     • Couldn't match expected type ‘(a1 -> a1)
13:58:45 <lambdabot>                                     -> (a2 -> a2) -> () -> ()’
13:58:58 <ricky_clarkson> phadej: I see.
13:59:56 <Solonarv> so basically, the type of the first 'id' gets larger and larger and larger - it doubles in size for every additional 'id' we add to the chain
14:00:13 <phadej> well, it actually doesn't show the real type, as it fails early on, as first id isn't a function, but it should be
14:00:25 <phadej> without annotation the a1 and a2 are instantiated further
14:03:38 <Solonarv> yeah
14:03:58 <Solonarv> % :set -XPartialTypeSignatures
14:03:59 <yahb> Solonarv: 
14:04:04 <Solonarv> % :t (id :: _) id id 
14:04:05 <yahb> Solonarv: ; <interactive>:1:8: warning: [-Wpartial-type-signatures]; * Found type wildcard `_' standing for `a1 -> a1'; Where: `a1' is a rigid type variable bound by; the inferred type of <expression> :: a1 -> a1; at <interactive>:1:8; * In an expression type signature: _; In the expression: id :: _; In the expression: (id :: _) id id; a -> a
14:04:21 <Solonarv> % :t (id :: _) id id id id
14:04:22 <yahb> Solonarv: ; <interactive>:1:8: warning: [-Wpartial-type-signatures]; * Found type wildcard `_' standing for `a1 -> a1'; Where: `a1' is a rigid type variable bound by; the inferred type of <expression> :: a1 -> a1; at <interactive>:1:8; * In an expression type signature: _; In the expression: id :: _; In the expression: (id :: _) id id id id; a -> a
14:04:29 <Solonarv> bah, even that doesn't help.
14:06:36 <geekosaur> yeh, that one fires too soon
14:07:58 <Solonarv> I'm sure there's some way to massage the typechecker into spitting out the type of that first id, but I have no idea how
14:08:41 <MarcelineVQ> Didn't you earlier with () ?
14:14:05 <geekosaur> :t (id `asTypeOf` ()) id id id
14:14:06 <lambdabot> error:
14:14:06 <lambdabot>     • Couldn't match expected type ‘(((a -> a) -> a -> a)
14:14:06 <lambdabot>                                      -> (a -> a) -> a -> a)
14:14:21 <geekosaur> % :t (id `asTypeOf` ()) id id id
14:14:22 <yahb> geekosaur: ; <interactive>:1:16: error:; * Couldn't match expected type `(((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a' with actual type `()'; * In the second argument of `asTypeOf', namely `()'; In the expression: id `asTypeOf` (); In the expression: (id `asTypeOf` ()) id id id
14:19:08 <tty1> Is there any sense of data integrity in haskell.. like if i create a data type is there some way for me to express what is or is not allowed in that type, short of  just writing sane functions.. like in non-functional languages this is done inside a class by determining how you can access the internal data and restrict it
14:20:28 <boj> tty1: an example perhaps?
14:21:42 <tty1> boj: well not a very useful example might be a class called "primeNumber" which just has a getter and a setter that sets/gets an int.. if the int is prime when you set it then it works just fine. IF it is not prime it would throw an exception. Therefore it is garunteed that the class always contains a prime number.
14:23:28 <boj> i suppose you would simply make a function to check this. newtype Prime = Prime Int;  mkPrime :: Int -> Maybe Prime
14:23:39 <dibblego> tty1: you might want to look up something called a smart constructor
14:24:54 <tty1> dibblego: ahh i guess because in haskell everything is immutable all you have to do is make sure the integrity is in tact int eh constructor and your good, no need to worry about things changing afterwords... so yea i could see that working, not sure what a smart constructor is but any sort of logic in the constructor would do the trick yea
14:25:17 <dibblego> tty1: essentially, you expose the data type but not the constructor
14:25:43 <geekosaur> actual constructors have no smarts; a "smart constructor" is just a function. you hide the actual constructor and provide a function that validates and constructs values instead
14:25:53 <dibblego> newtype Prime = Prime Int; make :: Int -> Maybe Prime; extract :: Prime -> Int -- imagine you can never call the Prime constructor.
14:26:19 <tty1> ahh i see, ig you can hide the constructor in that way i can see how that might be similar.. ill read up on it. But that sounds like a very useful pattern
14:26:55 <dibblego> the make function determines what gets to be a Prime value
14:27:02 <geekosaur> languages that support types that depend on values (here, "has type Prime if its value is ...") exist, but when you use the values you need to provide proofs that they are valid
14:27:14 <tty1> dibblego: that example makes some sense, though i need to read up on how to prevent calling the prime constructor then.. but ill look it up, it gives me something to google, thanks
14:27:30 <dibblego> you just don't export it from that module — only that module can call it
14:28:21 <tty1> dibblego: hmm well youd have to export the Prime type, just not its constructor I guess.. im crazy noob so not seeing how to do that, but its probably obvious
14:28:30 <dibblego> tty1: correct
14:28:41 <dibblego> I'll write it
14:30:46 <dibblego> https://gist.github.com/tonymorris/797bff974c4219c1bdf376d759c8d55c
14:30:56 <dibblego> oops, sec
14:33:32 <tty1> dibblego: ahh i think i see why i didnt get it.. Whenever i export a data type i always did "Prime(..)" as i was just repeating what i learned fromt he book and it worked. But I didnt learn yet what exactly the "(..)" part does in all that. I guess i need to try to understand (..) and your answer will make 100% sense. But otherwise i get whats going on here, so thanks.
14:33:59 <dibblego> it means "and the constructors"
14:34:06 <geekosaur> it means "also include all data constructors for the type"
14:34:22 <geekosaur> you can instead list specific ones, oromit it and only the type is exported without data constructors
14:39:41 <tty1> ahhh i see
14:39:52 <tty1> thanks makes sense now. Easy enough!
14:40:45 <tty1> im gtting excited to actually try a legit project from scratch soon.. Just need to learn a few more pieces and i think i can make a decent go at it
14:41:08 <tty1> I'll probably do yet another machine learning library or maybe a Graph Theory library.. I've written enough of the :)
14:41:12 <tty1> *them
14:52:58 <argent0> Hi, is there a type like: `Either a a`? I'm trying to use it for something like `Free (Either a a)` and use Left to signal the end of the Free ...
14:54:07 <Solonarv> argent0: 'Free (Either a a)' doesn't kind-check, did you mean 'Free (Either a) a' ?
14:54:22 <argent0> Solonarv: yes
14:55:03 <Solonarv> there are two ways for that to end: Pure (_ :: a), or Free (Left (_ :: a))
14:55:09 <Solonarv> surely that isn't what you meant?
14:55:31 <Solonarv> in other words, Free already has "signal the end" built in - that's what its Pure constructor does
14:56:28 <argent0> Solonarv: you are right, i must rethinki my code
15:01:09 <jfischoff> Is there a Haskell channel to advertise jobs?
15:01:24 <jfischoff> Not sure this is the right spot
15:01:35 <boj> jfischoff: should be fine to post here
15:05:45 <jfischoff> Alright. Simspace is hiring Haskell backend engineers and basically has way more reqs than we can responsible fill so I’m trying to get creative in getting the word out. We are a distributed company that helps build systems for cyber security training. US/Canada only. Here is the job req but feel free to DM me and ask questions: https://angel.co/simspace/jobs/64261-software-engineer-backend
15:07:52 <boj> jfischoff: you may also want to consider the haskell cafe mailing list an r/haskell on reddit
15:08:25 <jfischoff> Yeah other members of SimSpace are meant to tackle that ...
15:09:39 <Lycurgus> what's it pay?
15:10:04 <Lycurgus> (assuming it's a commercial firm)
15:11:19 <Lycurgus> wadler's video cadiz '16 ct for the working hacker is good
15:11:27 <jfischoff> pay’s market I guess. I don’t know the exact scale … it will depend on what you ask I imagine
15:11:34 <Lycurgus> (you tube)
15:11:55 * Lycurgus checks Simspace's locale
15:12:30 <jfischoff> Headquarters are in Boston but most of the company is elsewhere 
15:12:41 <Lycurgus> oh lordy, warmongers
15:13:00 <jfischoff> I geuss
15:13:56 <Lycurgus> well gsa rates for work like that are typically billed in the 300/hr range
15:14:05 <Lycurgus> though ofc the worker doesn't get that
15:15:08 <jfischoff> 300 hr is 600k a year. Not many salaried employees get that as base compensation in any job FWIW 
15:16:50 <Lycurgus> no, the shibboleth principal ERP consultant on-site or the vendor being an exception and then yeah he or she doesn't take that home
15:17:08 <Lycurgus> *for the
15:17:55 <Lycurgus> at wadler's talk he asked how many knew about curry howard and it was half the audience
15:33:30 <tty1> which pastebin should I use to post here?
15:38:15 <Lycurgus> any
15:38:35 <jle`> gist maybe?
15:38:48 <nek0> or hastebin
15:38:50 <Lycurgus> there is or used to be an hpaste i believe
15:41:32 <MarcelineVQ> most anything but pastebin.com works and that's mainly due to the colorizing it does to quotes " "​is hard to read
15:43:35 <jle`> lpaste used to be the standard one that everyone loved
15:43:38 <jle`> but infrastructure is expensive
15:47:32 <kadoban> gist.github.com is pretty good, at least the syntax highlighting and lack of ads are nice.
15:48:31 <threestrikes> I've been using ghcid with vscode.  It has an autosave feature that allows instant feedback
15:51:38 <threestrikes> d
15:59:21 <LovellyEmma> You wanna watch my Live (Starting in 8-10 minutes)? I am going to touch & play with myself. VIP members get Requests Permissions (FREE VIP for the next 2 people). Join it now (my user is LovellyEmma): https://short1.link/LGA6Ny ♥
16:02:06 <threestrikes> If I wanted to write my own simple network scanner that only stated if the device was on the network, where would I start?
16:03:28 <geekosaur> that... can be surprisingly difficult. and annoying
16:04:07 <amiri> I am trying to consume a list of records a bit at a time, according to a predicate, using span. I am having a hard time understanding how to "recurse" after the first chunk. How do I continue to get the rest of the list without ending up with something like ([Record],([Record],([Record]))) instead of ([Record],[Record],[Record]).
16:04:12 <geekosaur> most devices respond to ping / ICMP ECHO REQUEST, but at least on POSIX a process must have elevated privileges
16:04:33 <tty1> im trying to learn haskell, pulled the following example direct (almost) from abook. But gives the attached error. Can someone tell me why? https://hastebin.com/owocazeyaj.coffeescript
16:04:38 <geekosaur> (to send/receive ICMP)
16:06:18 <geekosaur> tty1, ghc was changed some versiosn back such that a Monad instance can only be provided if there is an Applicative instance
16:06:57 <tty1> geekosaur: so monad no longer derives from Applicative, you have to define both seperately?
16:07:40 <geekosaur> "derives from" doesn't mean what you think it does. it should more properly be called a prerequisite: you must provide an Applicative instance somehow
16:08:03 <geekosaur> as it turns out, you can cheat with a boilerplate instance: instance Applicative (WeirdType w) where { pure = return; (<*>) = ap }
16:08:13 <geekosaur> which reuses the Monad instance, which is acceptable
16:08:16 <tty1> Would i be correct then in assuming that future versions of haskell make no effort to maintain backwards compatability. Every time you want to upgrade your code to work with a newer version of haskell there is a potential you will have to rewrite a portion of your code?
16:08:29 <jle`> hm, i don't think that is a correct assumption
16:08:35 <jle`> there is plenty of effort to maintain backwards compatibility
16:08:38 <geekosaur> the haskell standard attempts to provide compatibility, usually. ghc doesnt necessarily, and has a number of breaking changes
16:08:43 <jle`> that was actually around most of the discussion behind the change
16:08:53 <jle`> the way to make the change that would maintain the most backwards compatibility
16:08:53 <geekosaur> jle`, not only this but Num vs. Eq and Show
16:09:08 <tty1> hmm i guess i need to learn how/why ghc can differ from haskell standard then.. but thats a question for another time
16:09:10 <geekosaur> and Semigroup, and Foldable/Traversable
16:09:12 <tty1> thanks for the answer
16:09:21 <jle`> i do think yes, there is some potential that you will have to change some parts of your code
16:09:30 <jle`> but, there is also a lot of effort into maintaining backwards compatibility
16:09:35 <jle`> so, in a sense, both are true
16:09:41 <tty1> yea i already ran into the problem with Applicable needing to be a semigroup (or was it a monaad) thankfull i figured that one out
16:09:46 <geekosaur> basically because the standard is very conservative but ghc is about the bleeding edge
16:09:57 <tty1> I see
16:10:18 <tty1> That is a bit off putting, but ill wait until i understand haskell better before i raise any alarms 
16:10:19 <jle`> for the record i don't think there has been much change in the Prelude for a couple of years now
16:10:29 <tty1> ahh that is comforting
16:10:33 <geekosaur> (and the standard would like to leave the possibility open for other implementations, although I think at this point that's a lost cause because so much code assumes ghc extensions and changes_
16:10:40 <tty1> maybe haskell is just a lot newer than i realized 
16:10:41 <threestrikes> I don't understand, what makes it hard?
16:11:02 <jle`> actually hm the Monoid/Semigroup change might have been more recent
16:11:11 <jle`> tty1: it's a very old language, but it acts like a new one, heh
16:11:28 <geekosaur> it's fairly recent, yes, 8.x
16:11:29 <jle`> "avoid 'success at all costs'", so they say
16:12:15 <geekosaur> and currently we have MonadFail in progress
16:12:52 <tty1> well by new i mean more so than say Java, which also expiernced a lot of flux in the early years with stuff becoming deprecated. But its been decades now since that has happened really.
16:13:07 <jle`> but, changes to superclasses like Monad/Monoid mostly affect library writers, less so end-users and application developers
16:13:31 <jle`> tty1: yeah, haskell is actually about five years older than java
16:13:40 <geekosaur> yes, but Foldable / Traversable meant a lot fo programs using Prelude functions suddenly required extra type annotations
16:13:42 <jle`> but unlike haskell, it never moved out of that sort of mindset
16:13:48 <jle`> *unlike java
16:14:02 <jle`> that's the sense when i mean that haskell is an old language that acts like a new language, heh
16:14:17 <jle`> geekosaur: yeah, that is something other than adding a superclass, so that's definitely more breaking
16:15:09 <tty1> jle`: ahh i see.. well im enjoying haskell so ill deal with it for now.. hopefully wont be a big issue. But that does have me a bit worried. Backwards compatability seems really really important in a core language IMO.. but maybe its not as important in haskell for some reason i just cant see yet
16:15:48 <jle`> your concern is not unfounded
16:16:00 <jle`> one of Haskell's "killer apps" is its ease in maintanability
16:16:07 <geekosaur> one reason it's less important in Haskell is that other lamnguages are prone to catch things like that at runtime. in haskell it's always a compile time error, so it cant slip through and bite you later
16:16:19 <jle`> and how you can jump back into working on an old project with no problems, and not be afraid of things breaking
16:16:33 <geekosaur> and the error messages usually do a good job of telling you what went wrong and why
16:16:34 <jle`> so having breaking changes in the base library is a bit antithetical to that advantage
16:17:14 <jle`> but yeah, like geekosaur says, debugging breaking changes in haskell is much more mechanical and safe/reliable than in other languages, so that does mitigate some of the cost
16:17:32 <tty1> geekosaur: that is nice. Though to be fair ive dealt with similar issues in statically typed languages that used libraries that didnt maintain backwards compatability. Even with all the errors caught at compile time it wound up being a major issue at times. Not saying that will be true with haskell, but like i said, it is concerning to see.
16:18:23 <jle`> fwiw the experience with static types in haskell is very different than the experience of static types in other languages
16:18:26 <jle`> also because you have things like purity
16:18:39 <jle`> so you don't have to keep track of hidden side effects and stuff like that
16:28:46 <tty1> yea, i look forward to seeing how this plays out
16:29:58 <geekosaur> also consider that golang pays ~no attention to backward compatibility (conversion tools, basically). and there are a few others similar
16:31:44 <geekosaur> (and then there's js libs that don't bother with backward compatibility)
16:36:06 <geekosaur> I am not, myself, especially fond of this. but considering the number of websites I encounter that regularly break in some fashion, and that I've learned not to look at the browser's js console, I'm something of a minority these days
16:43:23 <tty1> fair point yea
16:54:03 <infinisil> > lines ""
16:54:05 <lambdabot>  []
16:54:16 <infinisil> Wouldn't it make more sense for this to be [""]?
16:55:13 <geekosaur> how many lines does an empty file have?
16:55:59 <infinisil> You can see it as one empty line
16:56:05 <infinisil> (without any line ending)
16:56:12 <infinisil> > lines " "
16:56:14 <lambdabot>  [" "]
16:56:21 <infinisil> It's just a bit inconsistent if you look at this ^^
16:58:40 <jle`> arguably "" has no lines and " " has one
16:59:09 <infinisil> And this is also weird:
16:59:20 <infinisil> > unlines $ lines "foo"
16:59:22 <lambdabot>  "foo\n"
16:59:24 <infinisil> > unlines $ lines "foo\n"
16:59:25 <lambdabot>  "foo\n"
16:59:43 <infinisil> It automatically adds a trailing newline
17:00:02 <jle`> yeah, it's normalizing in that sense
17:00:22 <infinisil> boo
17:01:27 <jle`> i guess it's more that (lines . unlines) = id, and not (unlines . lines) = id
17:01:40 <jle`> although we have a weird situation when we consider unicode
17:01:50 <jle`> @check \x -> lines (unlines x) == x
17:01:51 <geekosaur> but with yours, unlines $ lines "" = "\n"
17:01:52 <lambdabot>  *** Failed! Falsifiable (after 14 tests and 8 shrinks):
17:01:53 <lambdabot>  ["\182947\nBW%\CAN/ \DC4\NUL\425363\f\f","\144158\&9","\46964z\ESC tl\657949...
17:02:31 <jle`> if we can trust shrinking, it means that (lines . unlines) = id for most reasonable inputs heh
17:03:17 <infinisil> Well darn
17:03:19 <MarcelineVQ> scary words :>
17:03:38 <jle`> cursed words
17:03:57 <infinisil> Is there a good way to transform every line in a string that actually only transforms the lines themselves?
17:04:29 <infinisil> Because `unlines . f . lines` could mess up the last line, or an empty string
17:04:33 <jle`> splitOn and intercalate seem to preserve the structure
17:04:41 <infinisil> Ohh
17:04:46 <MarcelineVQ> or if you want homework you can use an invertable parser :>
17:05:08 <infinisil> MarcelineVQ: I am interested in those already :)
17:05:21 <infinisil> Invertible parsers are a nice concept
17:05:37 * geekosaur notes that historically most unix utilities silently forced final newline. which gnu versions have consistently treated as a bug, but a few such still do it
17:05:51 <geekosaur> sometimes because they got too many bug reports if they didn't
17:05:58 <MarcelineVQ> They're an interesting thing, the future is dependent types and reversible computation. Also a bunch of other things but those don't confirm my bias.
17:06:28 <jle`> infinisil: there's 'lined' from lens which lets you map over each line, and it uses intercalate i think
17:06:46 <jle`> it uses lines and intercalate "\n" actually
17:06:53 <infinisil> jle`: Well I won't be pulling in lens just for that, but that's nice to know
17:06:58 <jle`> > over lined reverse "hello\nworld\nhow are you"
17:07:00 <lambdabot>  "olleh\ndlrow\nuoy era woh"
17:07:22 <infinisil> splitOn + intercalate works for me very nicely
17:08:08 <jle`> > over lined (show . length) "hello\nworld!\nhow are you"
17:08:10 <lambdabot>  "5\n6\n11"
17:17:21 <fen> do we have docker in haskell?
17:18:29 <fen> or can we run docker on "virtualisation features" provided by some haskell program?
17:18:46 <fen> instead of those provided by a linux kernal
17:18:47 <fen> ?
17:24:13 <fen> all I can find is an API to docker, not an implementation
17:28:05 <fen> might be possible to make something like a hyper-v implementation? 
17:32:53 <dmj`> fen: why use docker at all, just go bare metal
17:33:54 <fen> im not going to list the reasons people use docker... are you saying these can all be done using some "bare metal" solution?
17:34:20 <fen> most poeple run an os, and it seems to be important to run virtualisations on top of each other
17:34:46 <dmj`> Why not just use the linux kernel
17:34:49 <fen> eg, you could run windows 10 on a VM on a mac, and then use docker with hyper-V
17:35:11 <fen> but you couldnt do that if you had to use bare metal
17:35:47 <fen> idk, maybe someone has a mac and they need to test some development build tools to run on the windows machines they use at work
17:36:00 <dmj`> sure, you can run haskell programs in a  VM on a hypervisor
17:36:25 <fen> why are you saying sure like that answers the question at all?
17:37:51 <MarcelineVQ> what was the question
17:38:07 <dmj`> fen: you haven't really asked a clear question or one that makes sense in any way, besides when you gave an example
17:38:09 <Lycurgus> where's my damn hs docker thing?
17:38:48 <fen> basically there are 2 places to hack at here, one is docker itself, which you would have to alter the source of an implementation (preferably in haskell) of docker - to enable it to use virtualisation features provided by some (new) hypervisor
17:39:02 <fen> the second is to provide such a (not bare metal) hypervisoe
17:39:35 <dmj`> fen: can you tell us what you're trying to do and why, more context would help
17:40:02 <fen> it could also do the opposite... lets just have the question phrased as is
17:41:14 <fen> "why not use a linux kernal" - because that would require a VM 
17:41:24 <fen> and spoils the point of using docker
17:41:49 <dmj`> why does using the linux kernel require a VM
17:42:14 <fen> because in the hypothetical scenario a mac was being used
17:42:34 <fen> and the machines at work were running windows
17:42:38 <nitrix> You might be conflating virtualization and containerization. As it currently is, Docker needs a host to function.
17:43:06 <fen> yes, the host OS provides the virtualisation tools by means of a hypervisor 
17:43:11 <fen> the idea would be to have a cross platform hypervisor in haskell
17:43:32 <dmj`> you want to write a hypervisor in haskell ?
17:43:46 <fen> i would rather someone else did
17:43:50 <fen> it was just an idea
17:44:15 <MarcelineVQ> there's HalVM but it runs on xen
17:44:24 <fen> yah, thats the problem
17:44:45 <dmj`> garbage collected langs don't make good candidates for systems work
17:45:18 <dmj`> but if you insist, I'd strip the linux kernel down to nothing and set the init process to be the haskell program
17:45:29 <fen> fine if you have hardware you can strip back, as they probably would be on a real server bank, but for testing and development a kind of stack over a conventional opperating system is needed
17:45:30 <dmj`> clever and I did something like this, mostly clever though
17:45:38 <dmj`> w/ nix
17:46:58 <fen> so if you assume the dev has a mac and a windows machine and wants to develop on both, then they cant use the hypervisors provided by their computers OS and have to use a VM
17:47:24 <dmj`> why not just use a cloud machine that runs linux, or colocate a linux box in a data center
17:47:48 <dmj`> why relegate yourself to computers solely "in the office"
17:48:05 <fen> idk maybe there is a set of compatible tools on windows and mac and linux which docker uses, but the build systems are usually quite different no? we have to do the whole mingw thing to use unix toolchains on windows
17:48:26 <dmj`> windows has a linux subsystem
17:49:03 <fen> dmj` sure, why not just do everything on a remote linux machine.... thats an alternative to using a VM, but with similar latency issues 
17:49:47 <dmj`> Are latency issues a real problem though? What does your application do
17:49:57 <fen> the idea is to present the tool required to avoid these compomises 
17:50:29 <dmj`> I think it'd be easier to buy a linux machine and put it in your office than rewrite a hypervisor in haskell, just to run haskell programs on it
17:50:46 <fen> probably why it hasnt happend yet
17:50:53 <fen> doesnt mean it wouldnt be a good tool
17:51:27 <fen> and there was nothing about this that was "to run haskell programs on it"
17:52:02 <fen> it was just to be able to hack at a haskell docker implementation - to allow it to run on a haskell hypervisor implementation 
17:52:30 <fen> whatever is then used with the resulting cross platform docker knock off is up to the user
17:52:55 <dmj`> If you have a 5-6 years to kill, to rewrite docker in haskell, it might be a good idea, but expect strange memory leaks.
17:53:05 <fen> what?
17:53:12 <fen> why?
17:53:18 <fen> are you lying!?
17:53:20 <geekosaur> I'd expect a gc language to be as bad a choice for a hypervisor as for a kernel. you really don't want the thing doing business as OS or "hardware" to stop and gc
17:53:29 <fen> ah, ok
17:53:38 <dmj`> geekosaur: that's what I said (=
17:53:48 <fen> thought haskells way of abstracting away memory access would make it have less memory bugs...
17:54:06 <geekosaur> especially given things that operate at interrupt level (devices and device drivers) where gc is not an option
17:54:06 <dmj`> fen: how quickly do you think you could rewrite docker in haskell
17:54:13 <fen> but if gc is performance bottleneck then this might be a fair comment
17:54:23 <fen> dmj`: why?
17:54:39 <dmj`> gc in haskell is stop the world, and the parallel gc perf. in haskell is pretty atrocious ime
17:54:45 <geekosaur> and not just for performance reasons; interrupt handlers need to be fast and need to make minimal assumptions about the state of the system
17:55:16 <fen> hmm
17:55:53 <geekosaur> which is why for example OS network stacks have their own dedicated interrupt buffer pools that don't require knowing that the memory allocator was in a sane state when the interrupt came in
17:55:59 <fen> well it would be really nice to have haskell pipes between docker-like nodes. 
17:56:20 <geekosaur> (which you can't guarantee; interrupts hapen when the device says so, not when the system is ready for them)
17:56:34 <fen> was wondering if the cyclic graph stencil could be used to facilitate comunications on a docker swarm
17:57:17 <fen> which seemed to require a haskell implementation
17:57:28 <fen> maybe the haskell hypervisor isnt then nesacary
17:57:51 <fen> geekosaur: so what about halVM, does it get round this by being baremetal?
17:58:58 <fen> like, by being closer to the metal it avoids OS threads and stuff that could complicate its gc / interrupt buffer pools rtc
17:59:07 <fen> etc*
17:59:43 <geekosaur> it's no directly on hardware, it runs on top of xen which provides its own services for e.g. queueing
18:00:06 <fen> oh yeah, its xen which is baremetal
18:00:58 <dmj`> fen: it's also paravirtualized xen, so there's a layer of indirection where the machine instructions must be translated. 
18:01:18 <fen> hmm, maybe not, does that mean it is the kind of cross platform haskell virtualisation layer actually already exists?
18:01:26 <dmj`> fen: it also needs its own file system / network stack drivers which are implemented in haskell and subject to GC 
18:02:02 <fen> that would be awesome! then the haskell docker implementation could serve to target HalVM as well as the common OS hypervisors
18:03:21 <fen> so there is nothing we can do to get a haskell virtualisation stack to be as fast as using that provided by the native OS?
18:03:24 <fen> thats a shame...
18:04:01 <geekosaur> in general the OS has privileged access nothing else does
18:04:17 <fen> well, it makes sense that an extra layer that enabled cross platform functionality would be an extra layer of indirection..
18:04:22 <geekosaur> and in particular, anything else has to go through the OS to do anything
18:04:26 <flebron> Hi folks. Playing with DataKinds. Suppose I have a typeclass Fooable a, with foo :: a -> Int. I have a data P where (:>) :: (Fooable a, Arbitrary a) => a -> P -> P; Nil -> P. How could I write an instance of Arbitrary, for all such "lists of arbitrary fooables"? i.e. I'd like to be able to QuickCheck a function that takes XXX :> YYY :> ZZZ :> Nil, where each of those is Fooable and Arbitrary.
18:04:31 <fen> probably still more lightweight than virtualbox...
18:05:05 <fen> which was one of the few options available to the hypothetical dev
18:05:14 <flebron> (By this I mean, the function would be f :: (XXX :> YYY :> ZZZ :> Nil) -> Bool, for example, and I'd like to QuickCheck something about it, but I can't figure out how to make the Arbitrary instance for "All those type lists.")
18:05:33 <dmj`> fen: KVM (kernel virtual machines) lets vms that run inside the hypervisor access host machine resources directly
18:05:49 <dmj`> virtual box is probably the slowest
18:06:02 <fen> but doesnt docker serve instead of kernals?
18:06:11 <Cale> flebron: It *might* be possible to use an existential to quantify over many type level lists
18:06:13 <geekosaur> also keep in mind things like vbox are dealing with non-native OSes (it will always be faster to run one OS inside another instance of the same OS as many things can be directly delegated instead og having to be emulated or translated)
18:07:34 <geekosaur> windows and linux are very different things, and then there's os/2 / ecomstation which is still more different and requires a lot more special hypervisor support (very few Intel OSes use more than rings 0 and 3, but OS/2 puts device drivers in ring 1)
18:07:57 <geekosaur> which complicates all access control checks
18:08:02 <fen> basically, instead of having to use vbox to emulate a non-native OS, both machines would simply use the same cross platform layer, such as xen
18:08:37 <fen> dmj` your saying any KVM would work like this
18:09:25 <dmj`> fen: depends on if your hardware supports the virtualization extensions
18:09:29 <fen> so does paravirtualised xen + halvm provide such a KVM ?
18:09:58 <fen> seems strange to use that then in addition to docker since both give the option of running multiple kernals 
18:10:32 <dmj`> fen: at work we use NixOS and run haskell programs on NixOS inside of qemu virtual machines. In the bios of our machines we make sure the virutalization extensions are enabled, and the vm's run integration tests much faster (compared to doing it all in software)
18:11:12 <dmj`> the nixos testing framework uses https://www.qemu.org/ 
18:11:21 <dmj`> "Run KVM and Xen virtual machines with near native performance"
18:11:22 <fen> so xen would need specific hardware setup
18:11:37 <fen> ok awesome
18:12:14 <fen> now we just need a haskell docker implementation so that we can add HalVM + Xen virtualisation tools into the mix
18:12:24 <flebron> Cale: Not sure I follow. The existential would be at the kind level? Or?
18:13:01 <fen> oh wait, then we wouls just get docker to use Xen or the KVM directly right?
18:13:49 <fen> does that mean that HalVM is actually the closest we have to a haskell version of Docker?
18:13:55 <Cale> flebron: Existentials let you say that some type t exists for which the type of your term is some function of t
18:13:58 <dmj`> flebron: you can use closed type families over constraints to collapse them into one
18:14:27 <fen> just want some haskell kernals to run on my representation of a graph communicating over its edges...
18:14:40 <Cale> flebron: So if you were inventing some sort of random generator that's supposed to produce values of many different types at once, an existential quantifying over the part of the type which is changing would be a possibility
18:15:30 <fen> the docker coms seem to be through the deamons or via http... could maybe encapsulate a deamon on an edge like as a pipe...
18:15:51 <dmj`> fen: HaLVM is a Haskell compiler that cross compiles Haskell programs for the Xen platform (which also happens to be x86) and links a boot loader, network drivers and a few other necessary c libs statically into a kernel. Docker is a container virtualization technology that allows applications to run isolated but share the same kernel.
18:15:51 <fen> yeah, maybe a haskell version isnt nesacary, but thought it might be a more direct way
18:16:20 <fen> argh crap, thought halvm was a hypervisor
18:16:29 <fen> ok, so we just use xen
18:16:30 <dmj`> Xen is the hypervisor, HaLVM is a compiler
18:16:46 <dmj`> cross-compiler, with a very bespoke linking step at the very end
18:16:48 <fen> the VM part threw me because it was like "virtual machine" like vbox
18:16:49 <geekosaur> something to keep in mind about docker is that it's less about being a hypervisor than about creating and  managing hypervisor images
18:17:07 <dmj`> fen: HaLVM creates virtual machines that run on Xen
18:17:08 <infinisil> Hmm what's the package called again that has a monad for accumulating errors
18:17:29 <fen> yeah, but just virtual machines running haskell programs?
18:17:32 <geekosaur> i.e. saying "build this vm by layering together these component packages that provide these features"
18:17:41 <fen> thats pretty limmiting. would want to be able to run linux on it at least
18:17:48 <dmj`> @package validation
18:17:49 <lambdabot> http://hackage.haskell.org/package/validation
18:17:49 <fen> to consider it to be a "virtual machine"
18:18:45 <fen> geekosaur: so we can use docker with HaLVM?
18:18:50 <geekosaur> and optional isolation between those components, but that's n ot so much virtualization as comppartmentalization by means of cgroups (essentially "packages" of restrictions to be applied to a group of processes)
18:18:52 <dmj`> fen: no
18:19:01 <dmj`> fen: they're not related
18:19:05 <infinisil> dmj`: Ah thanks
18:19:08 <dmj`> infinisil: np
18:19:30 <fen> right right, hypervisor images, not whatever it is that the haskell only vm's are
18:20:13 <geekosaur> and the compartmentalization aspect of docker neither uses nor requires a hypervisor (unless the host OS doesn't support cgroups, in which case you get separate VMs running in a hypervisor and a slower and less flexible setup as a result)
18:20:46 <dmj`> fen: you can use docker on osx correctly now (not w/ virtualbox), it will use Hypervisor.Framework to create a linux machine that the containers will use. 
18:20:54 <fen> so we have compartmentalisation via KVMs also, and docker just gives a way to do it that provides the deamon for coms between component kernals, or hypervisor images. 
18:21:29 <fen> geekosuar: right, the idea was to swap cgroups for HaLVM's
18:22:01 <fen> sorry, the components it creates using those virtualisation tools
18:22:30 <geekosaur> that's a slowdown though. cgroups will always be faster because there's no virtualization going on, the kernel does extra permission checks instead while it's doing the standard ones. cgroups are *much* faster as a result
18:22:45 <dmj`> fen: docker and hypervisors just aren't related.
18:22:56 <fen> right, so host OS's are providing these tools, be it mac giving a close-to-the-ground linux interface, or windows with hyper-v
18:23:30 <jchia1> Functionally, what's the difference between pipes and conduit nowadays?
18:23:40 <jchia1> I.e. on the current versions of each.
18:23:49 <fen> geekosaur: one advantage of having the virtualisation is that you can run it on home written virtual hardware
18:23:52 <geekosaur> well, docker falls abck to hypervisors when not on linux
18:23:56 <jchia1> Any difference, anything one can express that the other can't?
18:24:48 <dmj`> right, using hyperkit, but it's definitely a fallback
18:25:16 <dmj`> jchia1: they both are slower than lazy IO
18:25:26 <geekosaur> but that makes it slower and less flexible because it has to plumb separate vms together instead of tossing a cgroup around each process and letting them run normally
18:26:04 <fen> so basically, docker probivides *fast* API for communication between containers. and a haskell hack version would, by breaking the use of cgroups, allow eg, for the development of virtual hardware 
18:27:10 <fen> jchai1: not sure if there is an API they implement...
18:27:26 <fen> some standard or something...
18:27:29 <dmj`> fen: there will always be more overhead than just using interprocess communication (i.e. TCP or unix sockets)
18:28:10 <fen> hmmm
18:28:34 <geekosaur> if you are working with virtual device drivers, you don;t really want docker. there's no "fast API for communication", there are just permissions restrictions keeping processes from seeing or interfering with each others' storage etc.
18:30:05 <fen> you could consider for example trying to train a pair of adversarial neural nets to perform and defend against timing exploits on a simulated representation of a p2p network
18:30:29 <fen> so you want to have a nice interface for the system specs of the various nodes
18:30:54 <fen> hence the idea of virualised hardware being a requirement for some dev
18:31:20 <fen> maybe docker is ok for this, idk if haskell tools are particularly easy to do this with
18:32:28 <fen> or like, malicious nodes or whatever
18:33:19 <fen> "eclipse attacks" or whatever they are called - basically training the net to identify friend from foe 
18:33:52 <fen> its a good example for training adversarial nets
18:34:51 <fen> and possibly even be a way to determine the reliability of a p2p network, trust in which is a principal measure 
18:36:53 <fen> software toolchains for developing and testing these kind of fintech tools is serious stuff!
18:38:26 <fen> docker seems really nice for this, just not sure if everything you would want of it is available and that the haskell API is all that is needed
18:39:05 <fen> seems like pottentially a more haskelly implementation would give better scope to interface with virtual hardware for example
18:43:23 <dmj`> in theory, but not in practice. The GC will murder you
18:44:04 <dmj`> unless all you did was work on the C heap from Haskell
19:14:25 <monochrom> Hey that's an interesting thought!
19:17:22 <dmj`> the GC murdering?
19:18:48 <monochrom> Using C's heap from Haskell
19:56:05 <davean> doesn't a lot of stuff do that?
19:58:15 <davean> flebron: lets be very clear - docker *does not virtualize anything*
19:58:19 <davean> er fen
19:58:31 <davean> its much more akin to a process than a VM
20:10:31 <nshepperd_> Isn't it mostly just chroot in a trenchcoat
20:11:21 <geekosaur> cgroups make it more than that
20:11:38 <geekosaur> but its still not a VM
20:34:40 <Maxdamantus> I don't consider cgroups to be the important part. The important part is "namespaces", as well as the typical process isolation you get.
20:36:38 <Maxdamantus> A process basically can't inherently do anything other that computation. For it to have some meaningful impact, it needs to make system calls. Namespaces influence what other processes and network interfaces etc the process gets to see.
20:37:20 <Maxdamantus> and as usual, chroot influences what files it sees when performing filename resolution calls.
20:59:14 <royal_screwup21> could someone give me an example of haskell code that doesn't have an equivalent in oop langauges? 
21:00:12 <MarcelineVQ> y
21:00:44 <royal_screwup21> why? Just out of curiosity
21:01:30 <MarcelineVQ> That's a pretty good reason
21:02:09 <royal_screwup21> MarcelineVQ you've been very helpful thus far, thanks 
21:02:29 <geekosaur> not sure there is such a thing. you can generally replicate it (even laziness), it's just really clumsy
21:03:21 <MarcelineVQ> You'd be surprised how useful asking why is for that question. It's a tough question really, computation is computation, oop make something things easier to express, fp makes some things easier to express, I'm not sure there's exclusivities at the root of things
21:04:08 <geekosaur> turing equivalence means there isn't. but every language can be a turing tarpit too
21:08:08 <royal_screwup21> how do you do higher order polymorphim in java? data Fix f = In (f (Fix f) 
21:09:04 <geekosaur> probably have to represent it indirectly
21:09:16 <MarcelineVQ> is IORef haskell's analoge to OCaml's ref?
21:09:57 <geekosaur> I mean, worse come to worst, you in effect compile it to an intermediate representation and run that, providing your own type engine for that representation
21:10:19 <MarcelineVQ> They're using it similarly in this code I'm seeing but they also describe it as a pointer, though they're not using it like one
21:10:41 <MarcelineVQ> it being ref
21:11:20 <geekosaur> it's roughly IORef, yes.
21:11:27 <MarcelineVQ> thank you
21:12:11 <geekosaur> it's a "pointer" in the sense that you can think of it as passing a constant pointer to a value instead of to the value, and code using it always dereferences the pointer but can't change the pointer itself
21:12:52 <geekosaur> perhaps a better analogy would be C++ references instead of C pointers
21:36:46 <Maxdamantus> Might have been worth mentioning f-bounded polymorphism to royal_screwup21: class Enum<E extends Enum<E>>
21:37:07 <Maxdamantus> (which might capture a small number of cases)
23:48:33 <jusss> is there something it's a Functor but not a Monad?
23:49:22 <dminuoso> jusss: Yes.
23:49:37 <dminuoso> jusss: In fact there's many things that are Functor but not Monad.
23:50:29 <Rembane> Are functions Functor but not Monad?
23:51:00 <jusss> dminuoso: for example?
23:51:14 <dminuoso> jusss: `Const a` is an example from base
23:52:12 <dminuoso> jusss: ZipList is another
23:52:36 <jusss> (>>=) :: m a -> (a -> m b) -> m b
23:53:00 <jusss> dminuoso: those 'm' should be same type?
23:53:14 <dminuoso> jusss: Yes, this fact is denoted by them all having the same name.
23:53:24 <dminuoso> jusss: If they differ they *can* be the same though, but they can also differ.
23:53:44 <dminuoso> That is, (>>=) does not demand that `a` and `b` be different, but they can be.
23:54:35 <jusss> dminuoso: like List and Maybe both are Monads,  can I give a List Monad to >>= and get a Maybe Monad?
23:54:59 <dminuoso> jusss: No
23:55:09 <dminuoso> jusss: So the way you use >>= is the following
23:55:18 <dminuoso> Pick a type for `m` and replace `m` with that type in the entire signature
23:55:33 <dminuoso> (The type must have a valid instance Monad of course)
23:55:53 <dminuoso> So if we fix m ~ Maybe, then (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
23:56:13 <dminuoso> And equivalently if we fix a ~ Int, then (>>=) :: Maybe Int -> (Int -> Maybe b) -> Maybe b
23:56:21 <jusss>  (<*>) :: f (a -> b) -> f a -> f b
23:56:34 <dminuoso> And if we fix b ~ Char, then you'd get: (>>=) :: Maybe Int -> (Int -> Maybe Char) -> Maybe Char
23:56:55 <jusss> it seems that Applicative do same thing like that
23:57:08 <dminuoso> jusss: Its similar, but different.
23:57:36 <jusss> <*> apply a function on f a and get  f b
23:58:26 <jusss> >>= apply a->m b on m a and get m b
23:58:42 <jusss> what's the different
23:58:59 <dminuoso> jusss: https://gist.github.com/dminuoso/1b7925f8a04f9740757d79266d724792
23:59:42 <dminuoso> Here (=<<) is just the flipped version of (>>=)
