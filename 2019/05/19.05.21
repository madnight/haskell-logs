01:25:32 <gentauro> I re-wrote a python script for the `futhark` project (saw it in Haskell Weekly) -> https://github.com/diku-dk/futhark/issues/748. I managed to produce this -> https://gitlab.com/spisemisu/futhark-cmp-bench-json (sadly I saw the comment after I already wrote `instance JSON Benchmark where` for `json`). Any feedback and what would you have done different? :)
01:33:15 <merijn> gentauro: I'm sure Athas will be in here at some point today to have a look :)
01:35:10 <gentauro> merijn: already speaking with him ;)
01:54:49 <gentauro> merijn: but kind of funny task since I can't get my Python to work (since I moved from QubesOS -> NixOS), so the only output I had was a pastebin from Athas :D
01:55:14 <gentauro> but it seems to produce the same output and when compiled, it's x5 faster than the python script, which sounds nice :)
01:55:53 <Athas> gentauro: you have a very unusual style with respect to whitespace and alignment.  Where did you pick that up?
01:56:02 <Athas> The linebreaks are a bit Elm-ish.
01:56:09 <merijn> Honestly, anything that's not python is better :p
01:57:50 <merijn> I find the parenthesised case/huge expressions feeding into >>= rather inconvenient to read, tbh
01:58:26 <avn_> gentauro: python usually easy on nixos.
01:58:58 <merijn> gentauro: the $ on lines 244 and 253 (and probably some other places) is redundant
01:59:00 <gentauro> Athas: the `elm-formatter` tool :)
01:59:27 <gentauro> merijn: yeah, I noticed that as well
01:59:46 <merijn> gentauro: Similarly, on line 248 and 256 the " >>= Ok" seems redundant too
01:59:54 <avn_> gentauro: ask me in proper channel, if you need help with python on nixos ;)
02:00:09 <merijn> gentauro: Which would let you get rid of the weird parentheses around case too
02:00:24 <Solonarv> also, 'sequence $ map foo xs' = 'mapM foo xs'
02:00:39 <gentauro> avn_: at first I was a bit "bitter". Now I actually see it as a feature and an excuse not to use Python anymore :D
02:00:54 <merijn> gentauro: Similarly, the huge lambda on line 429 should probably go into it's own where definition
02:01:13 <Athas> Consider replacing mapM with forM where appropriate.
02:01:23 <Solonarv> yes, same thing with the arguments flipped
02:02:18 <merijn> oh, yes
02:02:34 <merijn> large lambdas are acceptable with forM
02:02:37 <Solonarv> there are also a lot of redundant patterns
02:02:40 <gentauro> merijn: that actually a fair point
02:03:03 <merijn> gentauro: So "forM_ (inputs x) $ \(s,i,l) ->" although even then I only really do so with do blocks
02:03:08 <gentauro> Solonarv: how come? I have --pedantic turned on, so I need to be thorough on all pattern branches
02:03:20 <gentauro> otherwise, it will not build
02:04:01 <gentauro> merijn: what's the difference between `forM_` and `mapM_`? Aren't they doing the same?
02:04:04 <Solonarv> for example line 327-244 could be replaced with:
02:04:04 <Solonarv> ben [Ok b1, Ok b2] = <lines 331-342>
02:04:04 <Solonarv> ben _ = []
02:04:06 <merijn> gentauro: Anyway, the code itself looks pretty straight forward, your layout just looks very weird :)
02:04:21 <Solonarv> gentauro: they're the same, just with a different argument order
02:04:28 <maerwald> how do you turn Fold1 into Fold
02:04:28 <Solonarv> mapM_ f xs = forM_ xs f
02:04:29 <merijn> gentauro: forM has the function second, so you don't get the awkward parenthesisation of large lambdas like you have on line 429
02:05:31 <gentauro> but if I move lambdas to `where` it wouldn't make a difference
02:05:55 <gentauro> forM just sounds to imperative in my book :)
02:05:59 <maerwald> _fold1 :: Prism (Fold a b) (Fold a c) (Fold1 a b) (Fold1 a c) -- I wonder if this is implementable
02:06:03 <bahamas> how do I get a value out of Aeson Parser?
02:06:29 <Solonarv> bahamas: parseEither, or parseMaybe, or one of the variants
02:06:49 <bahamas> Solonarv: thanks!
02:07:43 <Solonarv> gentauro: is that why you avoid do notation, as well?
02:07:53 <Solonarv> we have it for a reason!
02:08:07 <Solonarv> and that reason is that it's more readable than the desugared version
02:08:57 <__monty__> The ________ wildcards are weird.
02:09:06 <Solonarv> yes, that too
02:09:10 <MarcelineVQ> smelly
02:09:31 <Solonarv> I mean, not really - it's just a (very, IMO) weird formatting choice
02:09:38 <MarcelineVQ> oh it's not a madlib
02:09:58 <__monty__> I don't like [          ] either tbh.
02:10:44 <Solonarv> I'm so distracted by the formatting and layout that the only feedback I can give is "use less weird formatting"
02:10:52 <gentauro> Solonarv: I don't think do notation is readable as you state
02:11:24 <merijn> gentauro: Most of the Haskell world will probably not agree with you on that, tbh
02:11:26 <MarcelineVQ> The question to ask is who's going to be reading this code, if it's other people then the majority opinion is a good baseline to work from.
02:11:39 <gentauro> I mean if it was like: `do foo <- bar; baz = qux` it would be OK, but the `do foo <- bar; let baz = qux` is a bit meh
02:11:47 <f-a> I have a type: newtype Replay a = Replay (String, [a])
02:12:18 <Solonarv> and if it's meant as a contribution to some existing project (as is the case here), you can also try to follow that project's code style
02:12:20 <gentauro> merijn: so is it OK to mix do-notation with `>>=`?
02:12:22 <merijn> gentauro: I think let inside do blocks should be avoided at all cost anyway. I only ever use it when using where is impossible
02:12:29 <f-a> deriving (applicative) with GeneralizedNewtypeDeriving does not work, but I thought (,) has its own monad instance? What is the blocker here?
02:12:42 <merijn> gentauro: "It Depends", I'm sure I do that in a bunch of places
02:13:11 <Solonarv> f-a: GND here wants 'Replay a' to be isomorphic to 'f a' for some 'f', but it isn't
02:13:20 <Solonarv> instead it's 'f (g a)'
02:13:31 <merijn> DerivingVia Compose ;)
02:13:41 <Solonarv> yes, I was going to suggest that ;)
02:14:04 <gentauro> I wish there was only one way and a tool like `elm-formatting` that just showed code uniform on all projects :D
02:14:20 <gentauro> s/showed/formatted/
02:14:26 <Solonarv> unfortunately can't also grab the monad instance from WriterT String [], because transformers has its tuples backwards :/
02:15:32 <merijn> gentauro: I mix >>= and do in a bunch of places in my own code: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/plot-src/Plot.hs#L284 https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/ingest-src/ProcessPool.hs#L138-L139 and probably more
02:15:55 <merijn> gentauro: tbh, I don't belive auto-formatting can even produce code that's as readable as human formatting
02:16:07 <Solonarv> I also use =<< a bunch, and I really like the '>>= \case' construct
02:16:21 <tdammers> >>= \case is great
02:16:55 <gentauro> tdammers: that's in newer GHC right?
02:17:07 <Solonarv> not that new
02:17:09 <tdammers> it's the LambdaCase extensions, it's been around for a while now
02:17:15 <tdammers> extension*
02:17:31 <Solonarv> since 7.6.1 apparently
02:17:57 <gentauro> merijn: I hooked `.stylish-haskell.yaml` up on save in my emacs to format a bit my files
02:17:57 <tdammers> yep
02:18:15 <gentauro> but it's no way near `elm-formatter` :D
02:18:21 <f-a> Solonarv: that makes sense, and indeed replacing [a] with a works
02:18:47 <tdammers> I find the >>= \case idiom much more pleasant than introducing a fairly meaningless variable just so you can pattern-match on it in a monadic context, or using a bunch of specialized pattern matching functions like maybe, either, etc.
02:18:59 <gentauro> but I agree that `auto-format` doesn't always produce readable code (patterns for example, can be tricky to do, that's why I use ________ instead of a single _)
02:19:21 <tdammers> gentauro: Elm is pretty big on the "one way of doing it", and that makes the language and its ecosystem rather stifling IMO
02:19:30 <Solonarv> I don't agree that "readable" means "everything is aligned as much as possible", tbh
02:19:45 <gentauro> tdammers: yeah, there is a team who "decides" the "best practice" on format
02:19:45 <tdammers> I much prefer a bit of chaos and anarchy, when that means I get more freedom in expressing my intentions
02:19:58 <tdammers> and that team's name is Evan :x
02:20:15 <gentauro> I'm fine with that, if people who have written a lot of code (and read a lot of other peoples projects) decide what's best, I can live with that ;)
02:20:41 <tdammers> but seriously, it's an evolving language, nobody can possibly be in a position to tell what's a best practice yet. maybe in 10 years.
02:21:01 <gentauro> 11:19 < tdammers> and that team's name is Evan :x <- As true as it gets xD
02:21:33 <tdammers> I prefer language designers who expose a humble kind of open-mindedness
02:21:54 <tdammers> SPJ has absolutely mastered that particular art
02:22:30 <__monty__> gentauro: You could combine hindent with stylish-haskell or use brittany instead.
02:23:21 <tdammers> oh, and also: I think that when you use autoformatters, then that is a sign of a language design flaw, because it means the language does not maximally exploit formatting as an expressivity axis
02:23:43 <tdammers> (which, btw., does not mean that a language should have semantically relevant whitespace, mind you)
02:23:59 <ocharles> tdammers: i don't really buy that argument tbh
02:24:07 <ocharles> We have a ton of Elm at work and an equal ton of Haskell
02:24:20 <gentauro> __monty__: just what I need !!! -> https://github.com/lspitzner/brittany#brittany---
02:24:21 <ocharles> Elm's restrictions felt horrible at first but now I am actually pretty grateful of them, and they've changed how I write Haskell
02:24:23 <gentauro> :o
02:24:39 <phadej> ocharles: my POV is that Elm is not general purpose language; so different rules apply
02:24:44 <ocharles> Agreed
02:24:55 <gentauro> ocharles: so you are on my side :D
02:25:05 <ocharles> Psh, I don't take sides ;)
02:25:16 <gentauro> ocharles: I'm on the "dark side" :D
02:25:19 <Rembane> Be greedy, take all the sides! 
02:25:36 <merijn> The fact that it affects how you write code, doesn't mean you necessarily want to be forced into a specific style ;)
02:25:37 <ocharles> I'm lazy, I just take sides when I'm forced to
02:25:40 <ocharles> I'll see myself out
02:25:43 <gentauro> in Denmark we have this nice sentence: "Moral is good, double moral is twice as good" :D
02:26:17 <merijn> Lots of things have affected and evolved my layout over time, but the overriding rule of thumb has always been "readability trumps consistency"
02:27:44 <Rembane> I just use brittany and don't think about it. I can now think about other things instead.
02:28:33 <Solonarv> I wanted to use stylish-haskell (or was it hindent?) recently and it choked on BlockArguments 
02:28:42 <Solonarv> perhaps I should see if brittany handles it
02:33:08 <Solonarv> oh, it doesn't build with base-4.12 - that answers it 
02:34:32 <__monty__> Solonarv: Yeah, these tools don't get much contribution so they have a hard time keeping up with GHC.
02:37:20 <tdammers> Elm's restrictions are great if they enforce how you want to write code
02:37:25 <tdammers> but in my case, they don't
02:38:00 <tdammers> and some of them are really just stupid, and I suspect that they are based on an inability to implement certain things, rather than a conscious decision to not have them
02:39:02 <tdammers> and of course the whole not-being-a-general-purpose-language thing - it's questionable whether client-side scripting really is a narrow enough domain for a DSL to pull its cognitive weight
02:39:25 <maerwald> can you turn a fold back into a getter?
02:40:01 <phadej> Fold s a  into  Getter s [a]  might work
02:40:27 <maerwald> yeah
02:46:19 <Solonarv> shitty inefficient version:
02:46:19 <Solonarv> :t let getFold l = to (toListOf l) in getFold
02:46:20 <lambdabot> (Profunctor p, Contravariant f) => Getting (Endo [a]) s a -> Optic' p f s [a]
03:16:37 <maerwald> preview docs say "Retrieve the first value targeted by a Fold or Traversal (or Just the result  from a Getter or Lens)." -- is there something that only works on Getter or Lens without the "first value" behavior?
03:20:53 <ocharles> What do you mean "without the first value behaviour"? What value do you want?
03:21:00 <ocharles> Are you just looking for `view`/`^.`?
03:22:47 <tama00> Hi
03:24:23 <maerwald> ocharles: view doesn't do what preview does in light of a _Just
03:25:03 <maerwald> refactoring your lens, preview might suddenly to something completely different
03:25:26 <maerwald> but compiles happily 
03:25:57 <ocharles> I don't really understand what you're asking for then
03:33:26 <kosmikus> maerwald: I'm repeating myself, but I think view in optics has the behaviour you want :)
03:34:27 <Taneb> > view _Just Nothing :: String
03:34:30 <lambdabot>  ""
03:36:05 <maerwald> > preview (to (NEL.nonEmpty) . _Just) $ [(1,2), (2,3)] -- Just ((1,2) :| [(2,3)])
03:36:05 <maerwald> > preview (to (NEL.nonEmpty) . _Just . traverse1 . _1) $ [(1,2), (2,3)] -- Just 1, not what I wanted...
03:36:06 <maerwald> > view (to (NEL.nonEmpty) . _Just . traverse1 . _1) $ [(1,2), (2,3)] -- compile error
03:36:09 <lambdabot>  error:
03:36:09 <lambdabot>      Not in scope: ‘NEL.nonEmpty’
03:36:09 <lambdabot>      No module named ‘NEL’ is imported.
03:36:09 <lambdabot>  error:
03:36:09 <lambdabot>      Not in scope: ‘NEL.nonEmpty’
03:36:11 <lambdabot>      No module named ‘NEL’ is imported.
03:36:13 <lambdabot>  error:
03:36:15 <lambdabot>      Not in scope: ‘NEL.nonEmpty’
03:36:17 <lambdabot>      No module named ‘NEL’ is imported.
03:36:41 <bgohla> hi, hoping this is the right place: i'm trying to build ghc-8.4.4 using ghc-8.0.2. i get an error: «
03:36:41 <bgohla> <<ghc: 301624588 bytes, 82 GCs, 8267654/23252276 avg/max bytes residency (6 samples), 57M in use, 0.001 INIT (0.001 elapsed), 0.791 MUT (0.825 elapsed), 0.616 GC (0.622 elapsed) :ghc>>
03:36:43 <bgohla> compiler/stage1/build/Parser.hs:1445:48: error:
03:36:44 <bgohla>     Not in scope: type variable ‘a’
03:36:46 <bgohla> <<ghc: 917581224 bytes, 299 GCs, 13921169/46289268 avg/max bytes residency (8 samples), 94M in use, 0.001 INIT (0.003 elapsed), 1.390 MUT (1.894 elapsed), 1.194 GC (1.201 elapsed) :ghc>>
03:36:47 <bgohla> make[1]: *** [compiler/ghc.mk:446: compiler/stage1/build/Parser.o] Error 1
03:36:52 <bgohla> make[1]: *** Waiting for unfinished jobs....
03:36:53 <bgohla> »
03:36:55 <bgohla> what could be the cause and how do i fix it?
03:37:39 <bgohla> i got sources from  git://git.haskell.org/ghc.git
03:38:19 <bgohla> do i need to build another intermediate version first?
03:38:35 <bgohla> thanks
03:51:54 <maerwald> > preview (to (Just) . _Just . traverse . _1) $ [("1","2"), ("2","3")] -- doesn't concatenate
03:51:55 <maerwald> > view (to (Just) . _Just . traverse . _1) $ [("1","2"), ("2","3")] -- completely unwraps the Maybe and uses mempty if the input list is empty
03:51:57 <lambdabot>  Just "1"
03:51:58 <lambdabot>  "12"
03:52:50 <__monty__> bgohla: Did you run ./boot && ./configure first?
04:13:44 <martin__> If the the objects of Hask are types, wouldn't the arrows be kinds rather than functions as the Haskell wiki says?
04:15:17 <tabaqui> Kind is not a function from type to type
04:16:03 <tabaqui> It's not even a function *on* types
04:16:14 <tabaqui> as TypeFamilies is
04:16:25 <martin__> hm
04:16:52 <martin__> Sorry, I have the terminology confused
04:16:53 <tabaqui> every type in Haskell has the kind *
04:16:54 <kosmikus> maerwald: in that last example, what is it you actually want?
04:17:06 <martin__> But the kind of the arrows must be * -> * right?
04:17:08 <kosmikus> > preview (to Just . _Just) $ foldOf (traverse . _1) $ [("1", "2"), ("2", "3")]
04:17:11 <lambdabot>  Just "12"
04:17:13 <int-e> martin__: the picture is, if A and B are types, then each function f :: A -> B is an arrow from A to B.
04:17:15 <kosmikus> maerwald: ^^ this?
04:17:34 <tabaqui> martin__: not really, we have type constructor (->) with the kind * -> * -> *
04:17:47 <tabaqui> and we have completed types, e.g. Int -> Char with kind *
04:17:55 <martin__> So what is the identity arrow of a type?
04:18:00 <int-e> :t id
04:18:02 <lambdabot> a -> a
04:18:09 <int-e> that, for the particular type
04:18:13 <tabaqui> :t id @Int
04:18:14 <lambdabot> error:
04:18:15 <lambdabot>     Pattern syntax in expression context: id@Int
04:18:15 <lambdabot>     Did you mean to enable TypeApplications?
04:18:24 <tabaqui> yeah, like idInt :: Int -> Int
04:18:29 <ski> tabaqui : concrete types
04:18:54 <martin__> Isn't inc n = n + 1 also an identity arrow in that case, since it has the type inc :: Int -> Int
04:18:59 <ski> (or, complete(d), i suppose)
04:19:00 <int-e> % :type id @Int
04:19:00 <yahb> int-e: Int -> Int
04:19:39 <ski> martin__ : no, because `inc . f' is not the same as `f', for any arrow `f'
04:20:46 <martin__> From what I understand, an identity arrow maps from an object to the same object. The objects are types. So anything that maps from a type to the same type would have to be the identity
04:21:04 <ski> nope
04:21:07 <ski> only some of them
04:21:11 <ski> in fact, only one of them
04:21:14 <martin__> Unless the objects are values, in which case I understand why id would be the identity
04:21:24 <kosmikus> martin__: no. and object can have many arrows from it to it. they don't all have to be identity arrows.
04:21:27 <kosmikus> *an object
04:21:30 <int-e> martin__: the identity arrows *also* satisfy  id_A o f = f o id_B = f  for f : A -> B
04:21:39 <ski> no, the objects are (concrete/complete(d) types), in this category
04:22:01 <ski> `inc . inc' is not the same as `inc', e.g.
04:22:12 <ski> hence `inc' can't be an identity arrow on `Int'
04:22:57 <Mo0O> Hi there
04:23:08 <ski> hello Mo0O
04:23:45 <martin__> Okay. I will think about this for a bit
04:24:00 <ski> you can think of an arrow from `A' to `B' as taking a walk, starting from `A', and ending at `B'
04:24:19 <ski> then if `A' and `B' is the same, we're taking a walk that starts and ends at the same place
04:24:25 <int-e> . o O ( categories are burritos, too! )
04:24:28 <martin__> I'm mostly confused about the distinction between types and values in the category
04:24:37 <int-e> there are no values
04:24:51 <int-e> category theory is largely pointfree.
04:24:56 <ski> however, the identity arrows is the walk that takes zero steps, zero distance, just stands still. it takes you from where you start, `A', to the same place `A', which is where you end
04:24:59 <Taneb> Categories don't really have a notion of "value"
04:25:03 <martin__> then how can there be multiple arrows from an object to itself if there are no values?
04:25:17 <int-e> because they are distinct arrows
04:25:33 <martin__> In what sense are they distinct if there's no notion of values?
04:25:44 <Taneb> There's a notion of distinction of arrows
04:25:44 <ski> martin__ : just draw multiple arrows on paper, starting and ending at the same place ?
04:25:47 <Taneb> Which we just take as a given
04:25:49 <int-e> an arrow carries more information than just source and target.
04:26:09 <Taneb> The arrows aren't even necessarily functions in some categories
04:26:11 <int-e> so succ :: Int -> Int and id :: Int -> Int are distinct arrows.
04:26:13 <ski> there can be many arrows starting from some `A', ending at some `B'
04:27:09 <martin__> And this property of the identity arrow that it satisfies id x = x, how is it expressed if you can't talk about values?
04:27:21 <ski> it's not expressed
04:27:28 <martin__> it's implied?
04:27:30 <ocharles> martin__: arrows are just "things", I think you are trying to interpret them as something particular (e.g., functions)
04:27:30 <int-e> For this concrete case (Haskell functions) you can distinguish the functions by applying them to different values, but category theory doesn't care how you distinguish them.
04:27:33 <Taneb> You talk about identity in relation to other morphisms
04:27:39 <ski> martin__ : there are no values. therefore there is no `x', and there is no `id x', either
04:27:45 <ocharles> Thing about a category more like a database with objects and arrows
04:27:48 <ocharles> Think*
04:27:56 <int-e> martin__: id o f = f o id = f  is what category theory requires of identities.
04:28:05 <Taneb> id has the property that for any morphism f, f . id === id . f === f, if you match the types
04:28:14 <ski> martin__ : in some cases, you can have "values", which are really special arrows. but in a category, there's only objects and arrows. nothing else
04:28:52 <zincy> How would you have a type wrapping a Nat which restricts the types of Nat to a discrete set of possibilities. So for context I have 2 players seated in a 6 seated game. The type I am asking about would be CurrPlayerPosToAct
04:28:59 <ski> ("in some cases" meaning "in some particular categories")
04:29:06 <martin__> okay
04:29:33 <martin__> Also, someone mentioned "concrete types" above. What is a concrete type?
04:29:35 <bgohla> @__monty__ yes, that's what i did: «./configure --prefix=${HOME}/.local  --with-ghc=${HOME}/.local/bin/ghc-8.0.2 »
04:29:36 <lambdabot> Unknown command, try @list
04:30:03 <ski> martin__ : that's a notion in Haskell. do you know about `Maybe' ?
04:30:07 <martin__> yes
04:30:16 <zincy> martin__: Types which have values are said to be concrete
04:30:19 <ski> martin__ : you know how you can have `x :: Maybe Integer', yes ?
04:30:29 <zincy> excluding the value _|_
04:30:36 <ski> zincy : types which are capable of having values
04:30:46 <ski> (`Void' is concrete)
04:30:55 <zincy> ski: Ah thanks
04:31:09 <ski> one might say, "inhabitable types"
04:31:35 <martin__> but Void has no values?
04:31:49 <ski> tabaquis : "complete(d) types" notion isn't too bad, either. it means the same as "concrete types"
04:32:12 <ski> martin__ : right, but that's just because it happens to have zero data constructors. it *might* have had (total) values
04:32:26 <ski> martin__ : now, do you understand `x :: Maybe Integer' ?
04:32:29 <martin__> yes
04:32:32 <ski> ok
04:32:41 <ski> do you understand why `x :: Maybe' doesn't work ?
04:32:56 <martin__> yes, Maybe has kind * -> *
04:33:07 <ski> `Maybe' is not a concrete type. it is a type function
04:33:24 <ski> it's "incomplete". it's still waiting for a type argument, to specify the "element type"
04:33:31 <merijn> concrete type ಠ_ಠ
04:33:32 <martin__> okay, so the opposite of concrete type is type function
04:33:46 <ski> (a `Maybe T' can be be thoughtof as a collection that has at most one element of type `T')
04:33:58 <ski> martin__ : not necessarily "opposite"
04:34:02 <merijn> martin__: Short answer: No, that's not the opposite of concrete type
04:34:16 <merijn> martin__: Long answer: People should stop saying concrete type: https://gist.github.com/merijn/796b8e041885df870fbb53b7191644b6
04:34:21 <ski> martin__ : you wouldn't say that the opposite of functions like `not' or `succ' is .. say `Integers', would you ?
04:35:47 <ski> er, is .. say, `Integer's like `42', i should say
04:36:12 <martin__> merijn: that's helpful
04:36:20 <ski> some values are functions, some values are integers, some values are lists, some values are tuples
04:36:30 <ski> there can be many different sorts of values
04:37:01 <ski> some types are concrete types, some types are type functions, there could possibly also be type tuples, type lists, &c.
04:38:19 <martin__> okay but the intersection of concrete types and type functions is empty then
04:38:41 <ski> martin__ : fwiw .. i think the terms "monomorphic types" and "polymorphic types" tend to be abused. (e.g. `Maybe a' is not polymorphic, nor is `forall a. Maybe a')
04:38:56 <ski> martin__ : just like the intersection of integers and functions is empty
04:40:20 <ski> to me, things like `id',`reverse',`Nothing',`[Nothing,Nothing]' are polymorphic (values)
04:40:37 <ski> (i don't know whether anyone would disagree with this terminology)
04:41:32 <martin__> ski: why is Maybe a not polymorphic?
04:42:09 <ski> their respective types, `forall a. a -> a',`forall a. [a] -> [a]',`forall a. Maybe a',`forall a. [Maybe a]', are not polymorphic (i don't think it makes sense to apply this term to them, at the same time as applying the same term to the values just above. please choose at most one of these two lists, to apply "polymorphic" to. i chose the first list)
04:43:20 <ski> martin__ : `Nothing' is polymorphic, because it can fit in many different contexts. if you want a `Maybe Integer', then `Nothing' can have that type
04:43:22 <tabaqui> ski: "some types are type functions" is wrong
04:43:49 <ski> tabaqui : that's another terminology thing. i can explain, in a little bit, ok ?
04:43:50 <tabaqui> type is an object in Hask
04:43:56 <tabaqui> ok
04:43:57 <ski> if you want a `Maybe Bool', then `Nothing' can also have that type
04:44:54 <ski> the point is that if we think of the type of the value as its "shape" (as opposed to how it "looks inside"), then `Nothing' is capable of having many shapes, like `Maybe Bool',`Maybe Integer',`Maybe [(String,Int -> Bool)]', &c.
04:45:50 <ski> all these types fit the general pattern/template `Maybe a' .. all all types that we can get by replacing `a' with a specific type in the template are valid types of `Nothing'
04:46:26 <ski> so, for all types `a', `Maybe a' is a valid type of `Nothing'. we abbreviate this by saying that `Nothing' has type `forall a. Maybe a'
04:47:21 <bgohla> __monty__ : yes, that's what i did: «./configure --prefix=${HOME}/.local  --with-ghc=${HOME}/.local/bin/ghc-8.0.2 »
04:48:12 <ski> similarly, `take' can be used as having type `Int -> [Int] -> Int]', and as having type `Int -> [Bool] -> [Bool]'. in this case, the general type of `take' is `forall a. Int -> [a] -> [a]'. note that when deriving specific types from this, we must make sure to replace `a' consistently, with the same type in all places
04:48:26 <ski> so `Int -> [Bool] -> [Int]' is not a valid type of `take
04:48:27 <ski> '
04:48:37 <ski> martin__ : making sense, so far ?
04:48:40 <martin__> I agree that Nothing is polymorphic
04:48:51 <martin__> but you said Maybe a is not polymorphic
04:49:13 <ski> first, you can't just say `Maybe a' -- you have to say where `a' comes from !
04:49:24 <martin__> forall a. Maybe a
04:49:31 <ski> that's similar to how you can't evaluate `x + 1', without telling what value `x' is to have
04:49:36 <int-e> ski: the terminology doesn't translate well between Hindley Milner and higher order types
04:49:39 <ski> yes, that's better. `forall' binds type variables
04:49:45 <ski> int-e : which of them ?
04:49:49 <Solonarv> it is easy to find out whether something is polymorphic (according to ski's definition): ask ghci about its type/kind; if it has a 'forall' at the outermost point then it is polymorphic
04:49:54 <int-e> "polymoprhic"
04:50:07 <merijn> Most people mean "polymorphic type" to mean "type that can unify with multiple things"
04:50:08 <Solonarv> % :t Nothing
04:50:08 <yahb> Solonarv: Maybe a
04:50:13 <Solonarv> grr!
04:50:21 <int-e> or perhaps its' that ghc treats  id :: a -> a  and  id :: forall a. a -> a  as the same
04:50:23 <Solonarv> % :set -fprint-explicit-foralls
04:50:24 <yahb> Solonarv: 
04:50:28 <Solonarv> % :t Nothing
04:50:28 <yahb> Solonarv: forall {a}. Maybe a
04:50:43 <ski> merijn : i don't think that makes sense, and still use "polymorphic" to describe values like `take', if we want to be able to use `forall' in kinds ..
04:50:45 <Solonarv> int-e: it "treats them the same" by inserting an implicit forall, yes
04:51:05 <Solonarv> % :k Maybe a
04:51:06 <yahb> Solonarv: ; <interactive>:1:7: error: Not in scope: type variable `a'
04:51:07 <martin__> Is there a thorough discussion of this somewhere? blog post/article/book
04:51:12 <int-e> Solonarv: but afaiu ski, the former is polymorphic; the latter isn't.
04:51:13 <merijn> ski: Define "makes sense" :)
04:51:31 <merijn> martin__: On what topic specifically? Types/type checking in general?
04:51:53 <Solonarv> int-e: well, I was being sloppy: ghc inserts an implicit forall unless 's' is bound in some outer scope
04:51:55 <ski> merijn : ok. i don't think it's *helpful* to (imho) confuse terminology like this, rather than leverage the clear analogy correctly
04:52:12 <martin__> I guess specifically on the definition of polymorphism, but I wouldn't mind a good reference on types in general
04:52:13 <Solonarv> (separately, ski disagrees with the use of 'forall' as a binder)
04:52:20 <ski> (i do ?)
04:52:23 <merijn> @where tapl
04:52:23 <int-e> Solonarv: that's fine, I meant this to be at the top level
04:52:24 <lambdabot> "Types and Programming Languages" by Benjamin C. Pierce in 2002-02-01 at <https://www.cis.upenn.edu/~bcpierce/tapl/>
04:52:42 <merijn> martin__: That one is the best text on types/type checking
04:52:44 <martin__> hah, I see this is a common request
04:52:55 <Solonarv> ski: I should have said: as a binder that also scopes over the function body
04:53:02 * ski seconds checking out TaPL, if you're interested in type systems
04:53:11 <yushyin> % :t Nothing
04:53:12 <yahb> yushyin: forall {a}. Maybe a
04:53:22 <yushyin> % :t Just
04:53:22 <yahb> yushyin: forall {a}. a -> Maybe a
04:53:42 <merijn> martin__: That book covers everything from "undergrad level I don't know anything about type checking" to "more than you ever wanted to know about the soundness and completeness of java's typechecking in the presence of inheritance"
04:54:03 <ski> Solonarv : not so much that. it's just that i insist on scopes following the ordinary program phrase nesting, in the abstract syntax tree
04:54:23 <merijn> martin__: It starts with the untyped lambda calculus and step by step introduces adding more and more complex typing features, how to typecheck them and comes with reference implementations of most of the discussed type checkers :)
04:54:34 <martin__> okay I will read this book
04:54:39 <__monty__> bgohla: Did you run ./boot before though?
04:54:40 <Solonarv> alright, let me weasel out one last time: you disagree with the way forall is used as a binder in current GHC haskell :>
04:55:05 <merijn> martin__: The references are Ocaml, rather than Haskell, but they're basic enough that you should be able to grok them with only beginner Haskell understanding
04:55:12 <bgohla> __monty__: sorry, forgot to mention, yes i did
04:55:14 <martin__> I've written a fair bit of ocaml
04:55:15 <ski> martin__ : anyway, types like `Int',`Maybe Int',`forall a. Maybe a',`Maybe' are all *monomorphic*. the first three have kind `*', the last has kind `* -> *'
04:55:17 <martin__> so that's fine
04:56:07 <__monty__> bgohla: Are you maybe specifying to freeze stage1 without having built it?
04:56:44 <ski> martin__ : this is similar to claiming that `False',`succ False',`all (> False) [not False]',`not' all being monomorphic. the first three have type `Bool', the last has type `Bool -> Bool'
04:56:44 <__monty__> bgohla: You should probably ask in #ghc, more knowledgeable people than me over there.
04:57:18 <martin__> ski: Ah, so you mean that forall a. Maybe a is monomorphic becuse it does not have a type variable?
04:57:29 <ski> martin__ : a polymorphic type would be one that, e.g., has kind `* -> k -> *', for all kinds `k'. iow, it has kind `forall k. * -> k -> *'
04:57:34 <ski> martin__ : no
04:57:39 <Solonarv> martin__: no, because *its type* (or its kind, in this case) doesn't have a forall
04:57:43 <bgohla> __monty__: not that i know of. right, #ghc, thanks.
04:57:46 <ski> martin__ : it is monomorphic because it has just one kind
04:57:52 <Solonarv> % :k forall a. Maybe a
04:57:52 <yahb> Solonarv: forall a. Maybe a :: *
04:57:57 <Solonarv> ^ as you can see
04:58:11 <ski> martin__ : `not' has just one type. it is monomorphic. `take' has many types. it is polymorphic
04:58:41 <ski>   newtype Const c a = MkConst c  -- this defines a polymorphic type
04:58:44 <ski> @kind Const
04:58:46 <lambdabot> * -> k -> *
04:59:08 <ski> (the `forall k.' here is elided (implicit), but really is present)
04:59:41 <Solonarv> % newtype MyConst b a = MkMyConst b
04:59:42 <yahb> Solonarv: 
04:59:45 <Solonarv> % :k MyConst
04:59:45 <yahb> Solonarv: MyConst :: forall {k}. * -> k -> *
04:59:59 <Solonarv> ski: if you use yahb you can tell it to print the foralls 
05:00:00 <ski> you can have a type `Const Int Bool', as well as `Const Int Maybe'. `Bool' has kind `*', while `Maybe' has kind `* -> *'
05:00:05 <Solonarv> (as I already did)
05:01:37 <zincy> ski: " newtype Const c a = MkConst c  -- this defines a polymorphic type". Types aren't polymorphic though are they?
05:01:43 <ski> you can have a value `take 1 [False,True]', as well as `take 1 [not,id]'. `[False,True]' has type `[Bool]', while `[not,id]' has type `[Bool -> Bool]'
05:01:54 <ski> zincy : they can be .. with extensions
05:02:06 <zincy> ski: polykinds?
05:02:06 <ski> (we didn't get that far, last time)
05:02:19 <zincy> ah ok let's leave the spoilers for now then haha
05:02:20 <ski> yes (although that extension is a misnomer, imho)
05:03:25 <ski> in the `Const Int Bool' vs. `Const Int Maybe' example, the former `Const' is used having kind `* -> * -> *', the latter `Const' is used having kind `* -> (* -> *) -> *'
05:04:12 <ski> in the `take 1 [False,True]' vs. `take 1 [not,id]' example, the former `take' is used having type `Int -> [Bool] -> [Bool]', the latter `take' is used having type `Int -> [Bool -> Bool] -> [Bool -> Bool]'
05:04:55 <martin__> okay, i gotta go. thanks for the explanations
05:06:29 <ski> tabaqui : anyway. in the old terminology, a type is something which is cabable of having values. so `Int -> Bool' and `Either String Int' are values, but `Either' and `Either String' are not. these latter would be called type constructors (hence the older name "constructor classes" (instead of "type classes") for classes like `Functor',`Monad')
05:07:01 <tabaqui> uhm
05:07:09 <tabaqui> "Just 2" is a value
05:07:14 <tabaqui> Maybe Int is a type
05:07:18 <ski> sure
05:07:28 <tabaqui> "Maybe", ugh, incomplete type, type constructor, whatever
05:07:30 <tabaqui> but not a type
05:07:34 <bahamas> anyone familiar with the google cloud storage API can confirm whether `objMetadata` is the field that stores the content of the object? for example, the contents of a file http://hackage.haskell.org/package/gogol-storage-0.4.0/docs/Network-Google-Storage-Types.html#v:objMetadata
05:07:36 <ski> however, we do allow things (functions) like `not',`chr',`lines' as values (this is a functional programming language, after all, where functions are first-class values)
05:07:57 <tabaqui> because any specific function *is* a value
05:08:08 <ski> we don't stop call it a value, just because it is parameterized, just because we can feed it an argument
05:08:12 <tabaqui> "not" is a value of type "Bool -> Bool"
05:08:15 <ski> right
05:08:36 <jchia_1> I've a stack/github problem. There's a package/project on github that has submodules: https://github.com/chrisdone/labels/blob/master/.gitmodules . Without a working github SSH key, if I stack build a project that depends on this github project, stack will try to "git clone --recursive" and fail because the submodule URLs are SSH-style, not HTTPS-style, resulting in "permission denied". Other than getting the owner to change the URL, is
05:08:36 <jchia_1>  there a way to fix this problem?
05:08:44 <ski> similarly, i think it makes more sense (is more helpful/useful/uniform) to allow any "type expresions" like `Maybe',`Either',`Either String' as "types"
05:09:38 <Maxdamantus> Maybe `Maybe` is a function of type `Type -> Type`
05:09:49 <tabaqui> I think, that we can use it at home, but have to be accurate when "category", "object" or "arrow" terms come to play
05:10:08 <ski> and so we need a (new) term for the types that *are* capable of having values. i use "concrete type". some other people aren't too fond of the term "concrete". i've also seen "complete". are there any other suggestions ?
05:10:55 <zincy> "inhabited"?
05:11:01 <int-e> jchia_1: does something like this work? git config --global url.https://github.com/.insteadOf git@github.com/  (cf. https://stackoverflow.com/questions/1722807/how-to-convert-git-urls-to-http-urls )
05:11:37 <ski> also, now that "type constructor" is free for grabs, we can decide to use it for "atomic types" like `Int',`Maybe',`Either' (but *not* `Either String'). compare with how `False',`Nothing',`Just',`Node' (but *not* `Node False') are all considered data constructors
05:11:40 <Maxdamantus> I'm inclined to go in the direction away from overloaded terminology.
05:12:02 <ski>   data Tree a = Node a [Tree a]  -- this `Tree' from `Data.Tree', in case you're wondering
05:12:54 <ski> zincy : "inhabitable", i'd prefer (because `Void' is not inhabited, barring partial values, but we clearly want to count `Void' here as well)
05:13:18 <zincy> Why are types of kind (* -> *) called "universes" in type theory?
05:13:37 <zincy> Does universe refer to capable of having values?
05:15:15 <ski> i agree with "Why You Should Stop Saying \"Concrete Type\"" that it's bad to have ambiguity, but i argue that all but one of the interpretations given there are just wrong (not helpful, if you prefer), and so i tend to interpret "different people are meaning different things by those words" in terms of "people aren't aware of how they're currently already using inconsistent or otherwise confusing terminology, and if they were more aware, this would be less 
05:15:30 <ski> .. but that's just my take on it
05:15:54 <ski> zincy : universes are types whose values *encode* (some) types
05:16:28 <zincy> What does encode mean here?
05:16:33 <Maxdamantus> imo we should just separate the notion of `*` and "type"
05:17:05 <Maxdamantus> so `4` is of type `Int` and `Int` is of type `*` and `*` is of type "kind"
05:17:12 <ski> zincy : instead of having `id : (A : Type) -> A -> A', you actually have `id : (A : TypeRep) -> El(A) -> El(A)', where `El(A)' is a special construction that given a *value* `A' of type `TypeRep', will compute a type
05:17:17 <merijn> ski: I think it's because I wrote that post with regards to Haskell2010 types and your explanation using forall, etc. assumes all sorts of things beyond Haskell2010 typing, which I don't think is relevant to beginners
05:18:11 <jchia_1> int-e: Good idea. It works when I do "git config --global url.https://github.com/.insteadOf git@github.com:"
05:18:43 <ski> zincy : so, say `data TypeRep = NatType | FunType TypeRep TypeRep' in Haskell syntax, then `El(NatType) = Nat' and `El(FunType tr0 tr1) = El(tr0) -> El(tr1)' would specify how to interpret `El(A)' for any value `A' of type `TypeRep'
05:18:48 <merijn> ski: Your definition of "polymorphic type" comes from "we have polykinds". I don't think we should address polykinds and RankN *at all* when talking to beginners, which is when people tend to use "concrete type"
05:19:04 <merijn> They don't need to know about poly kinds or RankN and SystemF, etc.
05:19:56 <merijn> So, since Haskell2010 doesn't have polykinds, the term "polymorphic type" for "the type of a polymorphic thing" is 1) both intuitive to beginners (from personal experience of talking to many) and 2) unambiguous since there's nothing else it can mean.
05:20:19 <ski> merijn : i agree we shouldn't talk about those things when explaining basics to newbies. but i do think we should, as far as we reasonably can, be _forward compatible_ to later being introduced to those extensions
05:20:23 <zincy> ski: Can you briefly explain the notation for ; `id : (A : Type) -> A -> A'
05:20:42 <ski> merijn : this is also a reason why i lament the syntax for tuple types
05:21:12 <zincy> ski: I am confused because
05:21:14 <zincy> :t id
05:21:15 <lambdabot> a -> a
05:21:16 <merijn> ski: SUre, forward compatible is good, but "concrete type" isn't anymore forward compatible than "polymorphic type" and is more confusing
05:21:28 <ski> zincy : `id' is a function "of two arguments" (really it's a function that given its (sole) input returns a new function that given its (sole) input returns ..)
05:21:39 <merijn> ski: So, if you can come up with another alternative to "polymorphic type" that's forward compatible, I'm all ears
05:22:01 <merijn> ski: But sticking with "concrete type" is definitely not the solution, imo
05:22:05 <ski> zincy : the first argument of `id' has type `Type'. let's call the first argument `A'. the second argument of `id' has type `A'. the result type is `A'
05:22:23 <ski> zincy : this is all Agda syntax, more or less (though Agda uses `Set', not `Type')
05:22:45 <zincy> Are we talking about Haskell's id?
05:23:00 <Maxdamantus> It's also valid in Idris.
05:23:03 <ski> zincy : no, you were asking about type theory. so i answered in terms of type theory
05:23:11 <ski> <zincy> Why are types of kind (* -> *) called "universes" in type theory?
05:23:33 <Maxdamantus> fwiw, `(a: b) -> c` is a "dependent function type"
05:23:34 <zincy> Ok I was just checking you weren't talking about Haskell
05:23:44 <ski> Haskell isn't type theory
05:23:52 <ski> at best, Haskell is *inspired* by type theory
05:23:53 <zincy> Yeah 
05:24:06 <ski> (type theory isn't merely type systems in general)
05:24:26 <Maxdamantus> often notated as `\Pi_{a: b} c` in formal descriptions of intuitionistic type theory.
05:24:38 <zincy> Oh that last point i didn't know
05:24:44 <Maxdamantus> https://en.wikipedia.org/wiki/Intuitionistic_type_theory#%CE%A0_type_constructor
05:25:15 <zincy> oh pi types?
05:25:18 <Maxdamantus> Yes.
05:25:33 <ski> merijn : can you elaborate on "\"concrete type\" isn't anymore forward compatible than \"polymorphic type\" and is more confusing" ?
05:25:41 <libertyprime> hey guys. im trying to compile my xmonad. i guess it's been a while since i have done this and my setup is not working. here is the error. pls help http://ix.io/1JEd
05:25:54 <zincy> Dependent types are essentially either pi or sigma types right
05:26:08 <zincy> but anyway back to ski's explanation
05:26:15 <Maxdamantus> so it's the same construction that lets you write `(n: Nat) -> Vec n`, but instead of taking a `Nat` as its argument, it's taking a `Type`
05:26:38 <Maxdamantus> and the second argument will be "something of that type" rather than "a vector of that length"
05:26:47 <Maxdamantus> er, the return value*
05:27:09 * ski . o O ( `replicate : (A : Type) -> (n : Nat) -> A -> Vec A n' )
05:27:09 <Maxdamantus> zincy: yes, sigma types are also known as "dependent pair types"
05:27:30 <zincy> and pi is dependent product I guess
05:27:46 <Maxdamantus> Yes, though "dependent product" seems a bit confusing.
05:28:00 <Maxdamantus> since pairs are also products .. just in a different way.
05:28:53 <ski> sometimes "dependent function types" are called "dependent products", and "dependent pair types" are called "dependent sums". but sometimes the latter of these two are called "dependent products". it can be a bit confusing
05:29:20 * Maxdamantus likes the terms "dependent function types" and "dependent pair types"
05:29:40 <merijn> ski: The entire origin of that post was that people kept getting confused by "concrete type", and empirically my explanation seems to help lessen/eliminate the confusion. But "concrete type" isn't more forward compatible, it doesn't have a well-defined meaning, so if we move on to more detailed/complex type theory it STILL doesn't have a well-defined meaning. So sticking with "concrete type" because 
05:29:45 <ski> a dependent pair type could be written `(n : Nat) * Vec A n', e.g. (that's basically the type of (finite) lists with elements of type `A')
05:29:46 <merijn> "polymorphic type" isn't forward compatible, basically says "I'm ok with leaving the initial confusion in place", which seems like throwing out the baby with the bathwater
05:29:51 <Maxdamantus> Should be bracketed as "(dependent function) type" and "(dependent pair) type" respectively.
05:30:06 <Maxdamantus> since they're types .. of "dependent functions" and "dependent pairs"
05:30:35 <Maxdamantus> id : (a: Type) -> a -> a; id t x = x
05:30:38 <zincy> So would you need a dependent function type if you were to encode some discrete set of Nats?
05:30:57 <Maxdamantus> `id` is a dependent function, and `(a: Type) -> a -> a` is its type (which is obviously a "dependent function type")
05:31:16 <ski> merijn : hm, i think i've been attempting to clear up said initial confusion, by explaining how (to me) it makes no sense to apply the term "polymorphic" to `forall a. Maybe a'
05:31:25 <Maxdamantus> You need a dependent function type when the type of the output depends on the value of the input.
05:31:34 <ski> merijn : is there any other part of the initial confusion which i'm forgetting about / leaving out ?
05:32:01 <Maxdamantus> ie, if the variable the value is bound to appears on the right side of `->`
05:32:08 <Maxdamantus> (a: Type) -> a
05:32:18 <Maxdamantus> `a` there appears on the right side of `->`
05:32:24 <merijn> ski: Right, but now you have to drag in SystemF, explicit forall's, etc.
05:32:42 <merijn> ski: Which, to someone struggling what "* -> *" means, seems less than ideal
05:32:44 <zincy> so id in type theory has a parameter which defines the type it is operating in?
05:32:49 <Maxdamantus> if you just had `(a: Foo) -> Bar`, there's no dependency on the value, so you can instead just write it as `Foo -> Bar`
05:33:07 <merijn> ski: So personally I prefer to just handwave it and leave it for when they've got a more solid grasp on the basics
05:33:40 <ski> merijn : "But \"concrete type\" isn't more forward compatible, it doesn't have a well-defined meaning" -- if you can write (or have a typing judgement, if you want more formality) `v :: T' for `v' a value, then i call `T' a "concrete type". roughly "concrete types" are types of values (things you can pass around at run-time, basically)
05:34:27 <merijn> ski: Perhaps that's what you mean, but that leads back to "many people use it to mean monomorphic"
05:35:14 <Maxdamantus> zincy: that's one way of writing it in intuitionistic type theory at least.
05:35:43 <ski> merijn : "now you have to drag in SystemF" -- well, only to the extent i have to try to explain the already existing conflicting terminology, no ?
05:35:48 <Maxdamantus> (it can also be written that way in Idris, and apparently Agda, though there are other ways of writing it at least in Idris)
05:36:43 <ski> merijn : and i really think that explicit `forall's is something people should be told comparatively early about (well, probably after type classes)
05:36:54 <zincy> just ask the beginner if they want the red pill now or later
05:38:23 <ski> merijn : my ideal would probably be to more or less handwave "concrete type" (for the time being, until they get more advanced), without mentioning anything about polymorphic types, and `forall' in kinds
05:38:49 <ski> merijn : i suppose it's a bootstrap problem. how do you bootstrap a change in terminology ?
05:39:32 <ski> zincy : in type theory, you don't write `id False', you write `id Bool False'
05:39:58 <zincy> ski: Makes sense 
05:40:03 <ski> zincy : of course, you could write `id (fst (Bool,Nat)) False', as well
05:40:29 <Maxdamantus> You could argue that you're effectively doing the same thing in Haskell, but the `Bool` argument is implicit.
05:40:31 <zincy> Is dependent typing a programming language thing and not a type theory thing?
05:40:31 <ski> so "types are values too" or "types are first-class values", basically
05:41:01 <Maxdamantus> and likewise, definitions requiring instances of type classes take those instances as implicit arguments.
05:41:02 <zincy> ski: yeah, in Haskell we need singletons right to fake the transition to enable runtime recovery of type information?
05:41:29 <ski> dependent typing comes from type theory (afaik). it has also been applied in a few more traditionally oriented programming languages (that aren't attempting so much to be languages for expressing proofs of theorems in math)
05:41:39 <zincy> ah cool
05:41:50 <ski> zincy : more or less, yes. which is why Haskell doesn't have dependent typing
05:41:59 <zincy> Will Haskell in the future be the first dependently typed language with a production ready runtime?
05:42:06 <ski> Idris being one of them. ATS another, i think
05:42:06 <Maxdamantus> so `forall a. Show a => a -> String` is analogous to `(a: Type) -> Show a -> a -> String`, but the first two arguments are magically implicit.
05:42:37 <merijn> zincy: Doubt Haskell will beat Idris in that regard
05:42:52 <merijn> zincy: Especially since retro-fitting dependent types in Haskell is hella awkward
05:43:01 <ski> dependent typing requires the ability to both use a single thing at the type level, and the value level, simultaneously
05:43:11 <zincy> merijn: Idris isn't used at all for things like web apps though right?
05:43:20 <merijn> Does Idris to TypeInType or is it sane and do the automatic stratification thing?
05:43:23 <zincy> merijn: Whereas Haskell is
05:43:24 <merijn> s/to/do
05:43:33 <Maxdamantus> (so `forall` and `=>` here are both effectively just extra function type constructors, but they're just treated slightly specially)
05:43:45 <merijn> zincy: Sure, but that doesn't mean Haskell's dependent types will be production ready for that any time soon :p
05:44:07 <zincy> merijn: So will it be a very gradual introduction
05:44:33 <merijn> Ah, yes, Idris has a hierarchy of universes
05:44:38 <merijn> I should really learn Idris
05:44:43 <ski> Maxdamantus : yes, but you can only have such named arguments which are in scope in the remainder of the function type, when that argument is a type. in Haskell
05:45:23 <ski> Maxdamantus : you can't have `forall (n :: Nat). ..n..', and then go on to apply your ordinary *value*-level operations on `Nat' to manipulate that `n' in the type, in Haskell
05:45:53 <ski> (if you write `forall (n :: Nat). ..n..' in a type in Haskell, then `n' will be a type, not a value. and `Nat' there is a kind, not a type)
05:47:09 <ski> in terms of logic, Haskell allows you to quantify over propositions/types. but not over individuals/values (and also not over mixtures like predicates (functions that given a value computes a type, in a Haskell context))
05:47:29 <Maxdamantus> Sure, that's one of the ways that `forall` is special; it only accepts things whose types are kinds.
05:48:50 <zincy> How advanced is Rust's type system compared to Haskell?
05:49:05 <Maxdamantus> not very, imo.
05:49:09 <merijn> zincy: Hard to say, the complexity is completely orthogonal
05:49:24 <zincy> ok
05:49:28 <merijn> Maxdamantus: I disagree, borrowchecking is pretty damn complicated
05:49:34 <ski> hm .. last i saw, it couldn't encode general existentials, like `exists a. C a *> T a', only `exists a. C a *> a' ?
05:49:41 <talqu> hi, with this: let x = [A {a :: Int, b :: Int}] i could do `fmap a x`. And if data is defined like this: A = A Int Int, how can i achieve the same in similar way without passing a newly defined lambda that gets the second param?
05:49:59 <ski> also, i'm not sure whether it has higher-order types ? (iow allow type variables to be non-concrete)
05:50:26 <Maxdamantus> merijn: well, I think that's somewhat orthogonal to most of Haskell's type system.
05:50:27 <zincy> are higher-order and higher-kinded the same thing for types?
05:50:27 <ski> yes, ownership is interesting
05:50:43 <ski> zincy : except i don't like the term "higher-kinded", yes :)
05:50:51 <ski> @kind Fix
05:50:52 <lambdabot> error:
05:50:53 <lambdabot>     Not in scope: type constructor or class ‘Fix’
05:50:57 <Maxdamantus> but I don't think it's *that* complicated.
05:51:00 <ski> @kind Mu
05:51:01 <lambdabot> (* -> *) -> *
05:51:04 <ski> @kind MaybeT
05:51:05 <lambdabot> error:
05:51:06 <lambdabot>     Not in scope: type constructor or class ‘MaybeT’
05:51:06 <lambdabot>     Perhaps you meant ‘Maybe’ (imported from Data.Maybe)
05:51:20 <lyxia> you don't think "higher-order" can be confused with "higher-rank"?
05:51:24 <ski> @kind Control.Monad.Trans.Maybe.MaybeT
05:51:25 <lambdabot> (* -> *) -> * -> *
05:51:34 <ski> @kind StateT
05:51:35 <lambdabot> * -> (* -> *) -> * -> *
05:51:41 <ski> these are all higher-order types
05:51:51 <ski> just like e.g.
05:51:56 <ski> @type all
05:51:57 <merijn> Maxdamantus: Well, hence why I said I don't think they're comparable :)
05:51:58 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
05:52:08 <ski> @type interact
05:52:09 <lambdabot> (String -> String) -> IO ()
05:52:15 <ski> @type map
05:52:17 <lambdabot> (a -> b) -> [a] -> [b]
05:52:23 <ski> are all higher-order values (functions)
05:52:44 <ski> (so, the previous ones are higher-order type *functions*)
05:53:06 <Maxdamantus> merijn: well, I think the ownership/uniqueness/borrowing stuff could be added to Haskell relatively easily (Idris seems to be doing something like that)
05:53:40 <Maxdamantus> imo the rest of Rust's type system is fairly lacking relative to just standard Haskell.
05:53:47 <ski> talqu : `fmap (\(A a b) -> a) x' ?
05:54:07 <ski> talqu : or does that count as "newly defined lambda" ? (imho, there is no definition in that expression)
05:54:10 <Maxdamantus> since it doesn't have higher-kinded polymorphism, and I think type classes are a bit clearer to use than traits
05:54:27 <talqu> ski, oh, didn't think you can pattern match with that lambda syntax
05:54:28 <talqu> xD
05:54:32 <talqu> thanks, exactly that
05:55:02 <Maxdamantus> though traits do have associated types, unlike classes in standard Haskell (but obviously there are extensions for that)
05:55:10 <ski> talqu : if you need to handle multiple different cases, use `\case'
06:00:11 <Maxdamantus> it seems like traits end up adding a bunch of workarounds for the fact that you're not meant to address trait members directly (you have to access them off something that implements the trait), so if you have something like `trait Foo { type Bar; } impl<A> Foo for Baz<A> { type Qux = A; }`, you have to write `<Baz::<i32> as Foo>::Qux` to access the `Qux` type for the `Foo` impl of `Baz<i32>`
06:02:26 <Maxdamantus> would much rather have a mechanism where it would make sense to just write `(%instance :: Foo (Baz i32)).Qux`
06:02:40 <Maxdamantus> (taking inspiration from Idris)
06:03:33 * Maxdamantus sleeps
06:06:13 <ski> Maxdamantus : s/Qux/Bar/ ?
06:07:14 <Maxdamantus> er yeah, looks like I started using `Qux` instead of `Bar`, so s/\<Qux\>/Bar/g
06:08:00 <Maxdamantus> also, apparently Idris uses `%implementation` now, not `%instance`
06:09:02 <Maxdamantus> eg, `the (Monad IO) %implementation` (or `%implementation :: Monad IO` using Haskell's notation for type unification)
06:11:29 <Maxdamantus> btw, `the` in Idris is the `id` function we were talking about earlier
06:11:37 <Maxdamantus> the : (a: Type) -> a -> a
06:11:45 * Maxdamantus sleeps
06:12:13 <Maxdamantus> (the Int 4, the Double 4)
06:12:31 <Solonarv> oho, that's cute
06:13:10 <Reisen> Does anyone who's used servant for much know how to extract a cookie by name? There's SetCookie but it doesn't seem to give me any control, scouring the docs and can't find anything. Surely this is possible?
06:14:09 <Rembane> Reisen: You should be able to do it through the CookieJar in another part of the HTTP stack, but I don't know of a Servant way. 
06:15:37 <Reisen> Damn, that seems like such an oversight, I guess the only way is to define a new combinator
06:15:47 <dminuoso> Reisen: It looks like you can simply use FromHttpApiData
06:15:55 <dminuoso> So deserialize it into a Map
06:16:20 <Reisen> Won't that just deserialize the contents of one cookie to a Map?
06:16:30 <Rembane> Reisen: There's an example here of something like what dminuoso said: https://stackoverflow.com/questions/49339259/servant-cookie-minimal-example/54890919#54890919
06:16:34 <Rembane> ...hopefully. :D
06:17:14 <dminuoso> Reisen: Remember that cookies are, formally, just HTTP headers.
06:17:20 <dminuoso> So just treat them as such.
06:17:43 <Reisen> dminuoso, that's kind of the problem though, Servant allows listing multiple `Header` combinators, but I have no guarantee of order or how many cookies are defined
06:18:01 <Rembane> Reisen: Why do you need those guarantees?
06:18:22 <Reisen> Rembane, some cookies are set by scripts, third party libraries, any tracking code might add cookies that go through our stack
06:18:27 <dminuoso> Reisen: So?
06:18:46 <Rembane> Reisen: Yes, it's a mess. How would order help with that? 
06:18:55 <dminuoso> Reisen: You dont consume HTTP headers. It's more like a read-only environment you can tap into.
06:19:06 <Reisen> Rembane, I have no way in the combinator itself to say, like Header, do: `Header "mycookie" Text -> Get '[] NoContent`
06:19:22 <Reisen> I can only say "SetCookie", and parse one cookie
06:19:26 <dminuoso> Reisen: The order doesnt matter, and you can have many or even just a single `Map Text Text` sort of cookie jar
06:19:56 <dminuoso> Ah I think I can see the problem
06:19:58 <Reisen> dminuoso, I might just be being stupid, but I assumed doing `Header "Set-Cookie" (Map Text Text)` would parse the contents of the _first_ cookie to a map
06:20:22 <Reisen> What I actually want is to ask specifically for a cookie by name
06:20:34 <Reisen> Given that I don't know how many cookies or what order in the headers they will be set
06:20:56 <Rembane> Reisen: In the parsing example @ StackOverflow you get a list of tuples where you can use lookup from Data.List for instance to get the cookie. 
06:21:13 <Reisen> Rembane, yes, you're right, that looks promising!
06:21:19 <Reisen> I'm still surprised this isn't just something Servant offers :(
06:21:22 <Reisen> Will give that a shot
06:21:47 <Reisen> Will also have to do the cookie parsing manually in the requests which is a shame
06:22:12 <dminuoso> Reisen: If you have any improvement suggestions, feel free to open an issue at github.
06:22:46 <dminuoso> phadej might have something to say about it, seeing as he's a maintainer.
06:23:14 <Reisen> Seems someone did, though it has been closed: https://github.com/haskell-servant/servant/issues/468
06:24:02 <Reisen> I'll give that SO post a shot for now, thank you Rembane, dminuoso, I appreciate the help
06:24:13 <Rembane> Reisen: No worries. Good luck! 
06:52:45 <noipmusp> Does anyone know how to make ghcid and happy work together?
06:56:05 <dodo> hello
06:56:13 <merijn> noipmusp: In what way does it not work?
06:58:07 <noipmusp> merijn: Problem is that ghcid cannot import Parser.y file. Ghci is probably totally bypassing "build-tools" from .cabal file.
06:59:10 <merijn> Why would you be able to import a Parser.y in ghci?
06:59:15 <merijn> It's not a Haskell file
07:00:12 <noipmusp> merijn: That's the problem. I need to turn it automatically, using ghci and happy, into Parser.hs file.
07:00:31 <merijn> noipmusp: Sounds like you want "cabal repl" or "cabal v2-repl", rather than ghci
07:01:50 <noipmusp> merijn: Oh, I was thinking ghci is just alias to "cabal repl".
07:02:12 <merijn> noipmusp: No, ghci is an executable that comes with GHC
07:02:14 <Mo0O> is there a way to call an IO function using getContents which is called on every single char?
07:02:31 <Solonarv> noipmusp: 'cabal ghci' is an alias for 'cabal repl', but 'ghci' by itself is a standalone executable
07:02:38 <merijn> Mo0O: mapM ?
07:02:40 <merijn> :t mapM
07:02:41 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
07:03:06 <Mo0O> thanks merijn I'll give it a try
07:04:20 <noipmusp> merijn: `ghcid -c "cabal new-repl"` did the trick. Thank you!
07:06:01 <Mo0O> you rox merijn, thanks a lot :)
07:14:34 <yorick> > preferredVersions $ db ! mkPackageName "MissingH" -- "MissingH <1.4.1.0 || >1.4.1.0"
07:14:36 <lambdabot>  error:
07:14:36 <lambdabot>      Variable not in scope: preferredVersions :: t0 -> terror:
07:14:36 <lambdabot>      • Variable not in scope: db :: Array i0 t0
07:14:36 <yorick> WHAT
07:14:38 <yorick> why?
07:14:50 <yorick> what was wrong with 1.4.1.0?!
07:15:32 <merijn> yorick: Changelog says there was a regression
07:15:50 <yorick> merijn: 1.4.1.0 is what stackage uses, though
07:17:02 <merijn> Not sure what kinda reaction/answer you expect here?
07:17:24 <yorick> cabal2nix uses hackage-db. How do I tell hackage-db to ignore the preferred versions?
07:18:00 <c_wraith> if you're using cabal2nix, why does it matter what stackage uses?
07:18:28 <c_wraith> Also, I was under the impression MissingH is mostly deprecated these days...
07:18:56 <yorick> c_wraith: I'm pre-generating nix for the entire stackage snapshot, but cabal2nix "cabal://MissingH-1.4.1.0" does not work anymore
07:20:10 <c_wraith> that stackage resolver is broken.  pick a different one.
07:20:41 <yorick> c_wraith: lts-13.22, that was released yesterday, has 1.4.1.0
07:20:55 <c_wraith> being released yesterday doesn't mean it's not broken.
07:21:30 <yorick> c_wraith: the last one without 1.4.1.0 was released last october
07:21:39 <tdammers> "this hasn't seen any commits for 10 years, that means it must be very mature"
07:24:01 <yorick> tdammers: this worked a few months ago and now it doesn't and we changed nothing and I spent 4 hours on figuring out why already
07:25:03 <merijn> Well, yes, that's the fundamental bug/feature of snapshots, it's all or nothing
07:27:33 <nshepperd_>  Do cabal2nix with a different minor version then manually change the version to the broken one
07:27:37 <nshepperd_> Or don't
07:27:52 <yorick> I'll patch it to grab the old .cabal out of all-cabal-hashes
07:28:26 <nshepperd_> It's there anything wrong with using "lts-13.22, but with a fixed MissingH version"
07:29:22 <yorick> nshepperd_: not in theory, no. in practice, I want to automate this and want to deterministically nixify the stackage snapshots
07:30:31 <Mo0O> do you know how tell getContents to not display escape as ^[ backspace as ^?, etc. ?
07:32:34 <dminuoso> Mo0O: getContents does not "display" anything by itself.
07:33:25 <nshepperd_> Automate it with a patches system then
07:33:31 <Mo0O> I see, maybe there's an System.IO setting to make it act like at tty
07:34:00 <nshepperd_> "If MissingH version is 1.4.1.0, set version to xxx"
07:34:12 <nshepperd_> Assuming there aren't a huge number of cases like this
07:34:30 <yorick> nshepperd_: also, I don't know if any downstream packages explicitly depend on 1.4.1.0
07:34:35 <dminuoso> % :t withEcho
07:34:35 <yahb> dminuoso: ; <interactive>:1:1: error: Variable not in scope: withEcho
07:34:48 <dminuoso> % :t hGetEcho
07:34:49 <yahb> dminuoso: Handle -> IO Bool
07:34:51 <dminuoso> % :t hSetEcho
07:34:51 <yahb> dminuoso: Handle -> Bool -> IO ()
07:34:56 <dminuoso> Mo0O: ^- these are likely what you want.
07:35:15 <dminuoso> Mo0O: Or do you want something in between?
07:37:06 <Mo0O> dminuoso: maybe it could do what it. I just want it act like a "normal" tty
07:37:21 <Mo0O> I'm going to give it a try, thx dminuoso 
07:37:38 <yorick> nshepperd_: oh yes, 'network' won't compile with missingh-1.4.2.0
07:38:10 <nshepperd_> Sad
07:38:19 <yorick> at least, I think? https://github.com/commercialhaskell/stackage/issues/4528
07:39:52 <nshepperd_> I don't see anything about missingh on that page
07:40:16 <dminuoso> Mo0O: So I dont see what you are seeing.
07:40:25 <dminuoso> Mo0O: I think it might depend on your terminal what the line editor does?
07:41:49 <Mo0O> dminuoso: the plan is to retrieve a shell from a websocket, sending stdin to that websocket and printing websocket result to stdout
07:41:52 <nshepperd_> It would have been better if they would have made a patch release 1.4.1.1 to fix the bug, but packages with correct version bounds should accept 1.4.2.0?
07:42:16 <dminuoso> Mo0O: So essentially nc?
07:42:22 <Mo0O> dminuoso: my terminal is st (simple terminal) which works basicaly like xterm
07:42:26 <dminuoso> Mo0O: What does it mean to "retrieve a shell"?
07:42:47 <Mo0O> a docker container shell
07:42:59 <dminuoso> I dont know what "retrieving a shell" means.
07:43:42 <Mo0O> a bash prompt from a websocket
07:44:38 <dminuoso> Mo0O: Okay, so essentially you just want to stream stdin in one direction, and stdout the other direction?
07:44:51 <Mo0O> dminuoso: exactly
07:45:29 <Mo0O> maybe getContents is not the good option
07:45:54 <dminuoso> Mo0O: What do you want to happen when you press an `a`?
07:46:10 <dminuoso> Mo0O: What semantics do you want wrt to cookied/raw?
07:46:18 <Mo0O> dminuoso: it display the letter `a`
07:46:31 <dminuoso> Mo0O: Because your local line editor shows you that?
07:46:45 <dminuoso> Or do you want to control your terminal in raw mode, and let the remote side handle that?
07:47:04 <Mo0O> in raw mode yes
07:47:23 <Mo0O> remote side will handle the rest
07:48:04 <dminuoso> Mo0O: You could look into vty 
07:48:45 <dminuoso> Mo0O: Know that your remote shell needs to have line editor support, of course. :)
07:49:10 <Mo0O> of course :)
07:49:20 <Mo0O> thanks a lot dminuoso 
08:15:34 <bahamas> can anyone explain what do I need to do in order to make my data type coercible to a Java type? I tried to derive different type classes from this file, but with no success https://github.com/tweag/inline-java/blob/master/jvm/src/Language/Java.hs
08:21:53 <lyxia> bahamas: is it really a coercion you want
08:22:34 <lyxia> In Haskell it means a very specific thing which is very different from what you might find in other languages
08:24:35 <bahamas> lyxia: to give you the big picture. I want to run something in Spark using another package called Spark. for that, I need to make my type available as a Java object.
08:25:22 <bahamas> lyxia: I first tried to derive the `Reflect` type class, since it says in its docs that it's the way to marshal a Haskell value to a Java object
08:25:34 <lyxia> So you want to convert to and from Java, so far that has nothing to do with Data.Coerce
08:25:55 <bahamas> lyxia: but I get the error "Couldn't match type ‘J.Interp Session’ with ‘J.Ty Session’". `Session` is my type
08:26:33 <bahamas> ok, then I didn't use the right word
08:28:01 <lyxia> well "coercion" might still be a good word for what you want, it's just that it's a pretty overloaded term, so you shouldn't expect that anything branded with the same word is going to be relevant to you
08:28:11 <jusss> >>= = return . join  ?
08:28:57 <jusss> join::m a-> a   and return :: a -> m a
08:29:18 <kuribas> jusss: \f -> join . fmap f
08:29:44 <kuribas> well flip (>>=)
08:30:02 <lyxia> bahamas: where do you get that error
08:30:15 <kuribas> :t \m f -> join $ fmap f m 
08:30:16 <lambdabot> Monad m => m a1 -> (a1 -> m a2) -> m a2
08:30:21 <kuribas> :t (>>=)
08:30:23 <lambdabot> Monad m => m a -> (a -> m b) -> m b
08:30:50 <bahamas> lyxia: on the line where I derive the class. I'm using data Session = Session ... deriving (J.Reflect)
08:30:56 <lyxia> jusss: join :: m (m a) -> m a    the extra m's matter
08:30:59 <kuribas> jusss: (>>=) is flatMap, join is flatten, fmap is map :-)
08:31:37 <kuribas> jusss: join is basically a type level join, or type level mappend if you like...
08:34:45 <ski> @type (join .) . fmap
08:34:47 <lambdabot> Monad m => (a1 -> m a2) -> m a1 -> m a2
08:34:55 <lyxia> bahamas: Reflect has an Interpretation superclass, do you have an instance of it
08:35:59 <bahamas> lyxia: I tried to add one and I got the error "No instance for (Data.Singletons.SingI (J.Interp Session))"
08:36:07 <lyxia> bahamas: that library is actually using Data.Coerce so nevermind what I said earlier...
08:36:35 <int-e> lyxia: but it also defines its own 'coerce' function... confusing
08:36:46 <lyxia> exactly
08:36:47 <jusss> kuribas: t \m f -> join $ fmap f m  what this m is?
08:37:20 <kuribas> jusss: the monad
08:37:31 <bahamas> lyxia: from what I see in the file Interp is a type family, so I don't know how to deal with that
08:38:07 <yorick> all-cabal-hashes more like most-cabal-hashes
08:38:11 <jusss> kuribas: I dont understand what fmap f m is
08:38:37 <int-e> bahamas: Interp is an associated type family for the Interpretation class. Ty is an associated type family for the Coercible class. I suspect you need instances for both of them for your Session type, but I'm not sure.
08:38:44 <kuribas> :t fmap -- jusss
08:38:46 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:39:01 <int-e> bahamas: I'm sure I'm echoing your thoughts, but documentation would help :)
08:39:14 <lyxia> bahamas: given the apparent reliance on Data.Coerce and the example at the top, it looks like you're supposed to use newtypes here. What is the actual definition of Session, can it be a newtype?
08:39:43 <dminuoso> jusss: m is just an argument to the lambda function.
08:40:03 <int-e> ah. deriving (J.Coercible, J.Interpretation, J.Reify, J.Reflect) <-- there are the Coercible and Interpretation instances at least
08:40:03 <bahamas> lyxia: current definition is data Session = Session <record>
08:40:09 <dminuoso> jusss: \arg fun -> join (fmap fun arg)
08:40:22 <dminuoso> jusss: Here I replaced m with arg, f with fun, and added explicit parens for readability.
08:40:24 <jusss> kuribas: (e->) or [] can be monad, but I don't know you m in this lambda is a (m a) or a m in type
08:40:45 <dminuoso> jusss: m is just a variable name of the lambda binder.
08:40:57 <lyxia> bahamas: is it a record with one field whose type is of the form "J _"
08:41:11 <dminuoso> jusss: it has no specific meaning.
08:41:23 <dminuoso> jusss: you can call it `x`, `foo` or `baz` instead if you prefer.
08:41:30 <jusss> dminuoso: ok
08:41:38 <bahamas> lyxia: it's a record with many fields which are Haskell types
08:42:00 <jusss> dminuoso: and >>= is return . join ?
08:42:20 <dminuoso> jusss: no.
08:42:30 <jusss> ok
08:43:03 <dminuoso> jusss: So let me explain what kuribas mentioned. Instead of looking at (>>=) for this, try considering (=<<) instead.
08:43:11 <dminuoso> (It has a bit better symmetry for this kind of comparison)
08:43:39 <dminuoso> f =<< m    =   join (fmap f m)
08:44:00 <dminuoso> (=<<) = \f -> join . fmap f
08:44:19 <dminuoso> Which illustrates the "first fmap, then join" part of it.
08:45:24 <jusss> ok
08:48:33 <jusss> dminuoso: how this (=<<) is related with (>>=) ?
08:48:41 <lyxia> bahamas: it doesn't look like you're meant to use deriving for such types.
08:48:44 <dminuoso> jusss: its just a flipped (>>=)
08:49:11 <bahamas> lyxia: what should I do instead?
08:49:33 <dminuoso> jusss: f >>= g  ===  g =<< f
08:50:23 <lyxia> write the instances manually, or maybe there is a TH or Generics solution
08:50:56 <dminuoso> jusss: But really, there is not much intuition to be gained if you are not yet familiar with (>>=) using the "its just fmap then join"
08:51:33 <kuribas> there is little point in trying to understand monad when you don't understand lambda
08:51:44 <jusss> dminuoso: wait a sec, f =<< m    =   join (fmap f m),  so f >>= m    =   ?
08:52:02 <dminuoso> _flow_: f >>= m = join (fmap f m)
08:52:04 <dminuoso> err jusss 
08:52:33 <jusss> <dminuoso> f =<< m    =   join (fmap f m) ??
08:52:39 <bahamas> lyxia: will learning more about type families help me with this? I feel completely lost right now
08:53:00 <bahamas> I mean, I don't know how the instances would look like
08:55:33 <bahamas> would they look similar to the instances of `Coercible` for the primitive types? if that means I need to construct a JObject with all the fields of my records, it's going to be a big pain. this record has a lot of fields
08:56:39 <Mo0O> dminuoso: I've try using hGetEcho and hSetEcho and it works like a charm using zsh or bash, but with ash there's some extra output like '[2;5R' it looks like the format is '[<line number>;<column number>R'; maybe this is related to my local shell, iduno
08:58:03 <Mo0O> not sure how this syntax is named
09:00:08 <lyxia> bahamas: I don't see anything that would do that for you in this file. Try asking the authors directly. If there is something better to do they'll tell you quickly.
09:00:42 <bahamas> lyxia: ok. I will do that. thank you for trying to help
09:35:09 <aloiscochard[m]> hey all, could any body tell me the meaning of the new `^>=` operator in Cabal? it's rather hard to google this one :) thanks
09:35:11 <dmwit> dminuoso: No, f >>= m = join (fmap m f).
09:38:48 <dmwit> aloiscochard[m]: https://cabal.readthedocs.io/en/latest/developing-packages.html#pkg-field-build-depends has the details
09:39:01 <dmwit> aloiscochard[m]: Scroll to just past the first "Warning" box there.
09:40:28 <aloiscochard[m]> dmwit: this is so cool, thank you!
09:41:58 <aloiscochard[m]> I have to admit I did dream of having such an operator happy
09:43:26 <dmwit> =D
09:54:46 <sm[m]> .
10:02:45 <fizbin_> Is there a ghc equivalent of c++filt that takes function names as shown in gdb and gives back demangled names? E.g. turns base_GHCziEventziEPoll_new10_info into something like base/GHC.Event.EPoll.new
10:07:41 <int-e> % import Encoding
10:07:41 <yahb> int-e: ; <no location info>: error:; Could not load module `Encoding'; It is a member of the hidden package `ghc-8.6.0.20180620'.; You can run `:set -package ghc' to expose it.; (Note: this unloads all the modules in the current scope.)
10:08:12 <int-e> fizbin_: the Encoding module in the ghc package has a zDecodeString function: zDecodeString "base_GHCziEventziEPoll_new10_info" = "base_GHC.Event.EPoll_new10_info"
10:08:44 <fizbin_> Hrm.
10:09:24 <int-e> yeah this isn't a complete answer
10:11:03 <int-e> But I'm not sure whether there is a more complete answer. This is the info table for a closure that (judging by the name) is a part of the 'new' function in the GHC.Event.EPoll module.
10:12:07 <int-e> I'm almost certain that it's not the `new` closure itself, because that shouldn't have that extra 10.
10:13:52 <int-e> there was a bot that had a zdec command... maybe lambdabot should steal that feature
10:24:37 <_sras_> Can someone take a look at this package that I am working on, that can generate Elm types, encoders/decoders from Haskell types, and possibly give some feedback. I would also like to know if I have missed any common use cases. Here is the package candidate link at Hackage https://hackage.haskell.org/package/elminator-0.1.0.0/candidate
10:26:18 <lyxia> funny name
10:27:02 <_sras_> lyxia: :)
10:27:28 <lyxia> _sras_: you can get syntax highlighting by opening code blocks with ```haskell
10:34:45 <lyxia> _sras_: this uses both TH and generics to look up type information?
10:36:07 <_sras_> lyxia: Yes. It used TH to look up the type variables, and figure out where they appear in the constructors.
10:38:00 <_sras_> lyxia: /s/used/uses
10:39:24 <lyxia> could you write to a file when running the splice? that seems more direct than dumping it into a haskell string, compile that, and run the executable.
10:47:42 <mac10688> http://hackage.haskell.org/package/thyme-0.3.5.5/docs/Data-Thyme-Format.html
10:48:08 <mac10688> This is frustrating. The parseTime function has two String arguments and there's nothing to describe what they should be
10:48:18 <mac10688> and this library looks so good too
10:48:33 <_sras_> lyxia: Yes. that should be possible. I just thought it would be safer to keep the action that writes to file explicitly triggerd by the user.
10:53:57 <lyxia> mac10688: looking at the source helps, but yeah this should really be documented http://hackage.haskell.org/package/thyme-0.3.5.5/docs/src/Data-Thyme-Format.html#formatTime
10:54:22 <nshepperd_> It's pretty safe to assume the format string goes first
10:55:13 <nshepperd_> It would be better there was a FormatString type synonym or something to document it though, wouldn't it
10:56:31 <lyxia> the format is probably the same as  http://hackage.haskell.org/package/time-1.9.3/docs/Data-Time-Format.html
11:02:11 <isovector1> what's the deal with impredicative polymorphism? why is it ok to have a function `IO IdNewtype` where `newtype IdNewtype = forall a. a -> a`, but not have a function `IO (forall a. a -> a)` directly?
11:02:43 <c_wraith> nothing is wrong with it conceptually, but it breaks type inference
11:03:04 <c_wraith> the new type wrapper allows type inference to work again
11:03:21 <isovector1> lots of things break type inference. the RankNTypes you need to write these things in the first place already breaks inference
11:03:23 <mac10688> yeah lyxia I think you're right. I'm just gonna go back to the time package. bbl
11:03:50 <c_wraith> no.. RankNTypes don't break type inference. 
11:04:05 <c_wraith> they aren't inferred, but they don't break anything.
11:04:17 <isovector1> oh, i see what you're saying
11:04:28 <isovector1> how does it break inference in this case?
11:05:38 <c_wraith> I really don't know how it goes wrong. I just have seen that the current type inference algorithm completely fails when you use them.
11:05:52 <isovector1> my (very limited) understanding of impredicativity is that you can intialize the type as itself? like let `a ~ forall a. a -> a` in `forall a. a -> a`
11:06:41 <c_wraith> like I said, nothing is conceptually wrong with them. it's just that ghc can't handle them properly. the current status is "gave up on even trying unless someone has a new idea"
11:06:45 <isovector1> cool
11:08:14 <isovector1> i'm working on a library in which it's super natural to pass around natural transformations, but now i want to do some initial setup in `IO` for these things
11:09:01 <isovector1> adding newtype un/wrapping in those cases is fine... but unnatural compared to the rest of the library --- if you'll excuse the pun
11:10:06 <c_wraith> yeah
11:10:46 <c_wraith> Haskell has definite awkward spots. that kind of polymorphism is an awkward one, when you start wanting it. 
11:12:37 <isovector1> i wonder if i can just unsafe coerce the newtypes out of existence....
11:12:57 <isovector1> but you're right, i just tried turning on ImpredicativeTypes, and i can't even get `pure id` to typecheck -- even with explicit type sigs
11:14:18 <isovector1> (turns out you can safe  coerce it!)
11:19:03 <lyxia> Impredicativity in Haskell is a problem that gets brought up once in a while and I've never seen any clue about what the actual problem is and how hard it seems.
11:19:42 <lyxia> Sometimes there's links about indecidability results that I never got the time to read.
11:19:53 <isovector1> yeah... so even though i can write all the pieces i want with ImpredicativeTypes turned on, i can't actually call the composition :(
11:20:35 <Cale> ImpredicativeTypes has been practically broken for a very long time I think
11:21:07 <Cale> There was some while after it was first introduced where it worked okay
11:22:33 <isovector1> https://github.com/isovector/polysemy/issues/42#issuecomment-494502914 this seems to work just fine --- reasonably sure i could massage the types into the things i want
11:24:33 <Cale> I'd say even if you manage to get things working, you're probably better off avoiding ImpredicativeTypes, because it's not a terribly popular extension, and so I'd expect it to be prone to further breakage.
11:24:54 <Cale> (unless you have an interest in making it work well yourself...)
11:26:05 <isovector1> good advice, but where's the _fun_ in that?
11:26:11 <Cale> haha
11:27:01 <lyxia> My current hypothesis is that there is an invisible force which repels anyone who tries to think about the problem.
11:27:14 <Cale> Well, I've been working on dependent-sum-template, adding support for deriving stuff like GEq, GCompare, GShow etc. for multiparameter GADTs with constrained constructors and the such like.
11:27:15 <lyxia> You'd think by now someone should have written a blogpost or two about it.
11:27:50 <Cale> It's hard enough dealing with all the foralls as it is ;)
11:29:28 <Cale> The question I'm currently pondering is how to gather up all the Show instances that will ultimately be required by the GShow instance that gets written by Template Haskell... I'm basically implementing a type checker in TH, doing limited amounts of unification and stuff.
11:29:46 <Cale> (I need to know how to build the instance head)
11:30:37 <glguy> Cale: are you using the th-abstraction package?
11:30:46 <Cale> I'm not...
11:31:29 <Cale> Perhaps it would make my life a little bit simpler
11:31:33 <glguy> I don't know if we have the solution to your exact problem, but it makes working with GADTs a lot simpler
11:32:20 <glguy> Also has some unification helpers iirc
11:32:27 <Cale> The main thing I end up doing is re-unifying the type variables that occur in the arguments to a data constructor with the variables that occur in the instance head by doing a comparison with the result type of the constructor.
11:32:37 <[exa]> is there some good abstraction or library for "binary blobs mmapped from disk" ?
11:33:04 <[exa]> (ideally with a MVector-like interface)
11:34:21 <iqubic> So, I have a problem I'm trying to solve, and I'm fairly certain I can turn it into a SAT or QBF, but I'm not quite sure.
11:34:52 <Cale> (and I do this a bunch while iterating over the arguments to each constructor in my GADT while I generate constraints on the instance)
11:35:17 <glguy> The package above handles generating those constraints
11:36:23 <iqubic> I have a list of 8 numbers that I need to split into two groups, where the sum of group 1 must equal the sum of group 2. All 8 numbers must be partitioned into either group 1, or group 2.
11:36:47 <iqubic> There is no limit on the size of the groups. It could wind up that I have to split the numbers into 7 and 1.
11:37:18 <Cale> hmm
11:37:53 <Cale> I might give it a shot at some point. I'm not sure about the non-capture-avoiding substitution though, that's already bitten me once :)
11:38:22 <iqubic> I feel like if I define the problem correctly, I can express it well with edwardk's ersatz library.
11:38:42 <[exa]> iqubic: you have less than 256 possibilities of splitting 8 numbers like that, bruteforcing is probably a good idea
11:38:42 <Cale> This is a good sort of library to have in general though, I'm glad someone thought to make it :)
11:38:56 <Cale> There's not enough support libraries for TH
11:39:22 <iqubic> [exa]: So are you suggesting that I don't try to use minisat or cryptosat?
11:39:34 <[exa]> certainly not for 8 numbers
11:40:39 <[exa]> I'd suggest some kind of graph problem for playing with SATs
11:41:31 <iqubic> This doesn't have to solved with SAT. I just thought it seemed like it could be really easily solved that way.
11:42:20 <iqubic> I might write a partition function with type [Int] -> [(Int, Int)]
11:42:22 <[exa]> iqubic: computing all possible splittings is probably faster than going with SAT. But if you want constraint-like programming, I suggest you try with list monad.
11:42:49 <iqubic> The only issue I see is how to make sure that I get all the splittings exactly once.
11:43:05 <[exa]> iqubic: how many possible splits are there?
11:43:11 <iqubic> I'm not sure.
11:44:01 <iqubic> I feel like the answer is (2^n - 2) ways to split n elements into two groups.
11:44:49 <[exa]> how many possibilities with 2 items?
11:44:53 <[exa]> (numbers)
11:45:00 <iqubic> [exa]: 2.
11:45:01 <glguy> Cale: I'd recommend never processing template-haskell's Decl representation directly for data declarations including data family and newtype. Too much changes between versions of GHC and it's far to close in some cases to the actual syntax
11:45:05 <iqubic> Or rather: 1.
11:45:15 <[exa]> iqubic: yes, you can break a bit of symmetry
11:45:45 <[exa]> iqubic: anyway, it gives a fairly straightforward way for generating all solutions recursively, right?
11:45:45 <glguy> There are also a number of bugs in old th versions the abstraction package back ports fixes for
11:45:49 <Ariakenom> % length (replicateM 8 [True, False])
11:45:50 <yahb> Ariakenom: 256
11:46:13 <Ariakenom> don't forget empty groups
11:46:22 <iqubic> If you have the numbers 1 and 0, the only way to partition them is ([1], [2])
11:46:35 <iqubic> Ariakenom: In my case you can't have any empty groups.
11:46:35 <__monty__> iqubic: That doesn't seem right unless it matters which group a number's in.
11:46:38 <[exa]> Ariakenom: iqubic said he doesn't want empty groups :] but yeah
11:47:27 <iqubic> Each one of the two groups must have at minimum a single number.
11:47:42 <Ariakenom> sry I missed that
11:48:39 <iqubic> __monty__: Yeah. I'm if you put 1 into the first group and 2 into second group, that will be the same as putting 2 into the first group and 1 into the second group. 
11:49:06 <Cale> glguy: One thing which I've just been ignoring thus far is the fact that multiple GADT constructors can be defined with the same type signature
11:49:32 <iqubic> So for the constraints that I have there is only one way to partition 2 numbers.
11:49:39 <Cale> glguy: But also, thankfully, most of what I'm writing doesn't need to work on anything pre-8.0, so that misses out most of the current weirdness with old versions.
11:49:40 <iqubic> It's just two groups of 1 each.
11:50:19 <Cale> (there have been a bunch of changes to dependent-sum and dependent-map recently that already killed support for pre-8 GHCs)
11:50:23 <__monty__> iqubic: Σ_(k = 1..⌊n/2⌋) (n!/(k!(n-k)!)
11:50:25 <Ariakenom> iqubic: I think the symmetry is removed if you place the first element in the first group. and then place the rest except one in either
11:50:30 <Solonarv> iqubic: so, 2^(n-1)-1, I think
11:50:35 <__monty__> iqubic: I think that's how many possible splits there are.
11:50:42 <Solonarv> (number of possiblt groupings, that is)
11:51:17 <iqubic> But 3 numbers can be grouped as ([1, 2], [3]) or ([1, 3], [2]) or ([2, 3], [1])
11:51:41 <Solonarv> > 2^(3-1)-1
11:51:43 <lambdabot>  3
11:51:47 <Solonarv> looks right to me!
11:51:49 <iqubic> 4 numbers has a lot more possibilities.
11:51:50 <Ariakenom> first one in first. pick one to go into second. rest randomly. 1*(n-1)*2^(n-2)
11:52:05 <iqubic> So, how do I generate the list of all possible partitions?
11:52:34 <iqubic> partition :: [a] -> [([a], [a])]
11:54:22 <int-e> @hoogle partitionM
11:54:22 <lambdabot> Control.Monad.Extra partitionM :: Monad m => (a -> m Bool) -> [a] -> m ([a], [a])
11:54:22 <lambdabot> Extra partitionM :: Monad m => (a -> m Bool) -> [a] -> m ([a], [a])
11:54:22 <lambdabot> Game.LambdaHack.Core.Prelude partitionM :: Applicative m => (a -> m Bool) -> [a] -> m ([a], [a])
11:55:21 <__monty__> Solonarv: Just denoting the "left" group for 4 items: [1], [2], [3], [4], [1,2], [1,3], [1,4], [2,3], [2,4], [3,4].
11:55:25 <iqubic> And once I have the list of partitions, then all I have to do is "filter (\(fst, snd) -> sum fst == sum snd)) partitions" to get only the partitions where the sum of both groups are the same.
11:56:09 <iqubic> I think that works.
11:57:17 <iqubic> So, how do I use partition/partitionM to generate the partitions?
11:57:43 <int-e> > filterM (const [False,True]) "123"
11:57:45 <lambdabot>  ["","3","2","23","1","13","12","123"]
11:58:28 <iqubic> > partitionM (const [False, True]) "123"
11:58:29 <int-e> partitionM would produce the remainder lists as well. and you can break the symmetry by dealing with the first element of the list sepearately.
11:58:31 <lambdabot>  error:
11:58:31 <lambdabot>      • Variable not in scope:
11:58:31 <lambdabot>          partitionM :: (b0 -> [Bool]) -> [Char] -> t
11:58:51 <iqubic> @import Control.Monad.Extra
11:58:52 <lambdabot> Unknown command, try @list
11:59:02 <int-e> yeah it inexplicitely doesn't exist
11:59:10 <iqubic> @let import Control.Monad.Extra
11:59:12 <lambdabot>  Defined.
11:59:25 <iqubic> > partitionM (const [False, True]) "123"
11:59:28 <lambdabot>  [("","123"),("3","12"),("2","13"),("23","1"),("1","23"),("13","2"),("12","3"...
11:59:37 <iqubic> Oh, I see.
11:59:52 <iqubic> But that gives me a few things that I don't want.
12:00:01 <__monty__> > filterM (const [False, True]) "1234"
12:00:03 <lambdabot>  ["","4","3","34","2","24","23","234","1","14","13","134","12","124","123","1...
12:00:37 <__monty__> Yeah, you'll have to filter out the ones with an empty group and the symmetric solutions.
12:00:39 <iqubic> I'm fine with having that first partition in there, because it's clear that it won't ever be the solution.
12:00:53 <int-e> > let f [] = [([],[])]; f (x:xs) = map (first (x:)) $ partitionM (const [False, True]) xs in f "123"
12:00:56 <lambdabot>  [("1","23"),("13","2"),("12","3"),("123","")]
12:01:10 <iqubic> Because the sum of some numbers will never equal the sum of no numbers.
12:01:26 <iqubic> How does that work?
12:02:06 <iqubic> int-e: What the heck did you just do there?
12:02:11 <int-e> it always stuffs the first given element into the first part of the partition.
12:02:20 <_sras_> lyxia: After giving it some thought, I went ahead with your suggestion of writing to the file on spilce expansion. Thanks.
12:02:37 <iqubic> Oh, I see.
12:02:59 <int-e> iqubic: Ariakenom mentioned this earlier
12:03:23 <__monty__> iqubic: Maybe take another approach. Sum all the elements. Then find out splits that sum up to half that.
12:03:44 <iqubic> Would that actually be simpler?
12:04:09 <int-e> well it enables some bounding (for branch & bound)
12:05:04 <iqubic> What does branch & bound mean in this context?
12:05:17 <int-e> I would also sort the numbers (largest first) and stop when the sum of the remaining numbers becomes too small. But there's a lot of things one might try here (stop if the remaining numbers are all even but the remaining sum is odd...)
12:05:37 <iqubic> That sounds like a lot of work here.
12:05:52 <__monty__> It actually *saves* a ton of work : >
12:05:52 <int-e> iqubic: pruning the search tree, but specific to working with numbers (where you can have upper and lower bounds).
12:06:22 <int-e> iqubic: it's not a terrible amount of work to write and it can pay off handsomely.
12:06:36 <iqubic> If I'm only ever going to be dealing with 8 numbers, I might not need to deal with these complex search tree pruning.
12:06:44 <int-e> sure
12:07:16 <int-e> but this might push the feasible size to 30 and beyond. (a lot depends on the actual numbers though)
12:09:23 <__monty__> Ouch, this is sounding a *lot* like the subset sum problem. So it's not really solvable depending on your definition of "solved."
12:09:53 <__monty__> Oh, bounded to small numbers. Probably not a problem then.
12:11:33 <int-e> Ah, if the numbers are really small, dynamic programming will also work (there's a pseudopolynomial time algorithm).
12:13:35 <iqubic> The size of the input will be relatively small (10 or less). 
12:18:38 <fragamus> hey eich
12:18:43 <eich> hey
12:19:19 <fragamus> this chat used to be red hot
12:19:41 <fragamus> now it's nice and quiet
12:19:48 <zincy> Anyone know why the last function wont type check? https://pastebin.com/WZU7K6j0
12:19:55 <iqubic> We were just discussing my problem.
12:19:56 <monochrom> Yeah now the vocal minority have all got day jobs.
12:21:50 <MarcelineVQ> zincy: looks like you might need ScopedTypeVariables since you're using a type variable in a term
12:21:56 <iqubic> That is a really weird type error.
12:22:10 <Ariakenom> iqubic: just wondering, are all your numbers positive?
12:22:16 <MarcelineVQ> this introduces a fresh variable usually without you specifying it shouldn't via ScopedTypeVariables
12:22:25 <iqubic> Ariakenom: Yes.
12:22:50 <zincy> Sorry I forgot to include the extensions I have there but ScopedTypeVariables is one I have on already
12:23:15 <MarcelineVQ> zincy: Did you read the docs for ScopedTypeVariables?
12:23:39 <zincy> Briefly yes
12:23:54 <MarcelineVQ> Do so again if this is your actual code :>
12:24:05 <iqubic> Ariakenom: Are you proposing that instead of partitioning the 8 or so numbers, I just make some of them negative, and then some the entire list?
12:24:26 <int-e> iqubic: http://paste.debian.net/1082530/ ... it really isn't that much code.
12:24:32 <zincy> Yeah this is my code :)
12:24:38 <iqubic> Where the groups would be numbers that are positive, and numbers that are negative, and the valid partitions are lists that sum to 0?
12:24:54 <Ariakenom> iqubic: no, I just suspected it from what you were saying but didn't here you say so.
12:24:58 <zincy> MarcelineVQ: What does scoped type variables have to do with this error?
12:25:03 <monochrom> zincy: The TLDR is that in addition you need to throw in a couple of "forall"s.
12:25:03 <iqubic> Ah. I see.
12:25:04 <Ariakenom> eh words. you understand hopefully
12:25:32 <zincy> monochrom: thanks
12:25:35 <iqubic> int-e: What have you done?
12:25:39 <MarcelineVQ> (seatsVec :: Vec n (Maybe SomePlayer)) is a fresh n that has nothing to do with your previous n
12:25:56 <zincy> Right but that doesn't have anything to do with the error does it?
12:26:12 <int-e> iqubic: bar takes a list of numbers and tries to find a sublist whose sum is half of the sum of all the numbers.
12:26:18 <monochrom> I would believe MarcelineVQ.
12:26:25 <MarcelineVQ> It doesn't?
12:26:45 <int-e> iqubic: and I liked the fact that [25,39,86,135,184,233,282,331,380,429,478,527,576,625,674,723,772,821,870,919,968,1017,1066] has 42 solutions (including symmetric ones)
12:26:46 <zincy> It was a question from me not a statement :)
12:26:48 <MarcelineVQ> The error says it does, though I've not tried the code myself
12:27:03 <iqubic> I'm a little confused as to how bar works?
12:27:22 <int-e> iqubic: it's the branch&bound approach I outlined above.
12:28:00 <iqubic> What is this doing: "(zip xs' (scanr (+) 0 xs'))"
12:28:05 <iqubic> On line 6
12:28:25 <int-e> > scanr (+) 0 [1,2,3] -- compute list of sums of tails ("sum of remaining elements" in context)
12:28:27 <lambdabot>  [6,5,3,0]
12:28:47 <iqubic> I see. But why do you then zip it with the tail?
12:28:50 <fragamus> > 1+1
12:28:52 <zincy> Ok I am going to read ScopedTypeVariables docs again
12:28:52 <lambdabot>  2
12:29:21 <iqubic> > let f xs' = (zip xs' (scanr (+) 0 xs')) in f [1,2,3]
12:29:24 <lambdabot>  [(1,6),(2,5),(3,3)]
12:29:24 <int-e> iqubic: so that in the search I can access both the list elements (which I want to select from) and the remaining sum (for pruning the search tree)...
12:29:36 <iqubic> Ah. I see.
12:30:28 <iqubic> I'm not sure how the multiple cases of go work.
12:30:43 <zincy> I am 70 percent sure it isn't ScopedTypeVariables related but I would love to be wrong
12:31:24 <iqubic> int-e: what even is that `go' part doing
12:32:09 <int-e> iqubic: it takes a list of elements to select (with associated sums of remaining elements) from and a target sum to reach.
12:32:25 <int-e> iqubic: and all the code assumes that the original list elements are positive.
12:32:59 <iqubic> Which is a valid assumption to make. I forgot to add that as one of my constraints, but that is one of them.
12:34:19 <int-e> iqubic: so if the target is 0, we have exactly one solution (first case) that selects no arguments at all... s < tgt means the remaining arguments are not enough to reach the target; x > tgt means we cannot select x; otherwise we try both selecting x and not selecting x.
12:34:47 <int-e> iqubic: I've written *a lot* of code of this flavor :)
12:34:58 <iqubic> Why?
12:35:08 <int-e> because it's fun
12:35:19 <int-e> (for me, ymmv...)
12:35:35 <iqubic> I find this sort of thing fun too.
12:36:54 <monochrom> Cyclic definitions with scanl and scanr are wacky.
12:37:18 <int-e> well none of that is happening here :)
12:37:37 <int-e> > fix((0:).scanl(+)1) -- I guess thsi?
12:37:40 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
12:37:43 <monochrom> Yes!
12:38:14 <monochrom> And I saw "xs' = zip xs' (scanr ... xs')"
12:38:53 <iqubic> How did you just generate the fibonnaci numbers?
12:38:56 <int-e> monochrom: and your internal typechecker didn't notice anything wrong? shame, shame on you!
12:39:15 <iqubic> How does that fix magic work?
12:39:19 <monochrom> Oh nevermind misread!
12:39:24 <int-e> @src fix
12:39:24 <lambdabot> fix f = let x = f x in x
12:39:57 <iqubic> let x = ((0:).scanl(+)1) x in x
12:40:03 <iqubic> > let x = ((0:).scanl(+)1) x in x
12:40:06 <monochrom> http://www.vex.net/~trebla/haskell/scanl.xhtml is my explanation.
12:40:06 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
12:40:10 <int-e> iqubic: by this point that snippet is folklore. there's a funny way of computing fibonacci numbers: F_n = 1 + F_0 + F_1 + ... + F_(n-1) (for n >= 1).
12:40:57 <iqubic> I didn't know that worked.
12:40:57 <int-e> err
12:41:05 <int-e> I it should stop at F_(n-2)
12:41:39 <iqubic> > fix (scanl (+) 1)
12:41:42 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
12:41:49 <iqubic> How the hell???
12:42:12 <int-e> 1, 2 = 1+1, 4=2+1+1, 8 = 4+2+1+1, ...
12:42:35 <iqubic> What does circle with a + in it mean on the scanl tricks page?
12:42:44 <iqubic> :t scanl
12:42:45 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
12:42:51 <monochrom> An arbitrary infix operator.
12:43:13 <int-e> > scanl (*) 1 [1..]
12:43:15 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
12:43:19 <monochrom> Really any 2-ary function you want (provided it type-checks in that context).
12:43:38 <int-e> scanl is useful enough without fixed points ;-)
12:43:39 <iqubic> @src scanl
12:43:39 <lambdabot> scanl f q ls = q : case ls of
12:43:39 <lambdabot>     []   -> []
12:43:39 <lambdabot>     x:xs -> scanl f (f q x) xs
12:44:26 <iqubic> How does scanl work?
12:44:29 <monochrom> There is a cognitive dissonance or even brainwashing to be said about that question.  Because no one raises the logically equivalent questions "and what do that s0, x, y, z mean?"
12:45:02 <int-e> iqubic: think of q as an accumulator.
12:45:13 <monochrom> The conclusion is that people have been brainwashed to accept "OK s0, x, y, z are arbitrary variables, but operators are constants and I need to be told"
12:45:18 <int-e> @src foldl
12:45:18 <lambdabot> foldl f z []     = z
12:45:19 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:45:34 <int-e> it's like this, but produces a list of intermediate results instead of just the final result
12:45:59 <zincy> monochrom: don't operators generally have well accepted meanings?
12:45:59 <iqubic> Wait, so it's like a fold, but it produces the results of (f z x) at ever stage.
12:46:19 <monochrom> Well that's the brainwashing I'm talking about.
12:46:34 <monochrom> In Haskell, operators generally are user-definable variables.
12:46:42 <monochrom> Even parameters
12:47:00 <monochrom> The very same status as x, y, z.
12:47:04 <int-e> monochrom: FWIW I tend to use (?) for the arbitrary infix operator
12:47:10 <zincy> monochrom: So are people brainwashed into thinking (+) is addition?
12:47:17 <iqubic> So, how does using scanl with fix work?
12:47:56 <int-e> > let (+) = (-) in 34 + 8
12:47:58 <lambdabot>  26
12:48:16 <iqubic> Oh dear.
12:48:36 <int-e> scanl (⊕) s0 [x,y,z] <-- I have to agree with monochrom here. (⊕) is clearly the first argument of scanl.
12:49:28 <iqubic> So how does scanl and fix work?
12:49:49 <monochrom> You want the short answer or the long answer?
12:49:56 <int-e> > let (?)(??)(???)=(??)+(???) in 34 ? 8
12:49:58 <lambdabot>  42
12:50:10 <iqubic> I want the answer that makes sense.
12:50:14 <iqubic> monochrom: ^^^
12:50:18 <zincy> monchrom: Up to you
12:50:22 <int-e> iqubic: magic!
12:50:23 <monochrom> My web page makes sense.
12:50:36 <iqubic> I now want the long nswer.
12:50:48 <int-e> the web site is long too? :)
12:50:48 <monochrom> My web page is the long answer. It also makes sense.
12:50:49 <zincy> Go for the long one
12:51:01 <zincy> I dont understand
12:51:09 <monochrom> For the short answer I was going to say "mathematics".
12:51:29 <iqubic> Oh. LOL. 
12:51:47 <shachaf> I want the long answer, but I also want it typed into IRC.
12:51:56 <zincy> monochrom: So mathematics brainwashes us into associating addition with (+) in haskell?
12:52:12 <monochrom> And no I refuse to give a non-mathematical essay oh-so-intuitive "answer".
12:52:28 <iqubic> What was the long answer going to me? "mmmmmaaaaattttthhhhheeeeemmmmmaaaaatttttiiiiicccccsssss"?
12:52:53 <monochrom> I would say "the average math class/teacher does that brainwashing", rather than math itself.
12:53:17 <zincy> You haven't really answered the question have you 
12:53:26 <monochrom> Sorry which one?
12:53:42 <iqubic> How does Scanl with Fix produce fibonnaci numbers?
12:53:53 <int-e> > "iqubic" >>= replicate 6
12:53:56 <lambdabot>  "iiiiiiqqqqqquuuuuubbbbbbiiiiiicccccc"
12:54:03 <monochrom> My answer is on that web page. Hello it gives two formulas.
12:54:11 <zincy> "So mathematics brainwashes us into associating addition with (+) in haskell?"
12:54:12 <monochrom> s/Hello/Hell/
12:54:23 <monochrom> No, the average math class/teacher does.
12:54:26 <[exa]> int-e: man the questionmark example is priceless
12:54:31 <[exa]> taking it
12:54:55 <zincy> Is there a link to your webpage monochrom
12:54:55 <shachaf> iqubic: I think the web page has been suggested to you three or four times by now. Have you read it yet?
12:54:56 <iqubic> int-e: You mean I didn't have to type it out by hand.
12:55:05 <monochrom> http://www.vex.net/~trebla/haskell/scanl.xhtml
12:55:07 <int-e> iqubic: something like that :)
12:55:08 <zincy> ugh where is it
12:55:21 <shachaf> It looks pretty good and it seems to answer all the questions.
12:55:42 <int-e> iqubic: I also thought that while we're having fun with scanl it couldn't hurt to throw (>>=) into the mix as well
12:55:56 <zincy> shachaf: can you summarise the answer here then?
12:56:27 <shachaf> No. I'm only here to tell people to read the web page instead of asking people to summarize it for them.
12:56:33 <monochrom> Yeah people assert that the whole point of sitting on IRC is to have everything appearing in the IRC window, eh?  If they were expecting something in the web browser they would be on Youtube instead.
12:56:36 <monochrom> And so...
12:56:42 <monochrom> Theory
12:56:47 <monochrom> scanl behaves like this:
12:56:53 <zincy> shachaf: I can't read it without a link :)
12:56:53 <monochrom> scanl (⊕) s0 [x,y,z] = [s0, s0⊕x, (s0⊕x)⊕y, ((s0⊕x)⊕y)⊕z]
12:56:58 <monochrom> One way to state it in general: let rs = scanl (⊕) s0 xs:
12:57:03 <monochrom> rs !! 0 = s0
12:57:08 <monochrom> rs !! (n+1) = (rs !! n) ⊕ (xs !! n)
12:57:14 <shachaf> zincy: monochrom just linked it above. Twice.
12:57:16 <monochrom> Conversely, if we have a list rs satisfying these two equations, we can use scanl (⊕) s0 xs for it. Actually we will use the converse more often — we have some list in mind, we verify that it satisfies the two equations, and we conclude that we can use scanl to produce the list.
12:57:24 <monochrom> rs !! 0 = s0
12:57:29 <int-e> and now monochrom's pasting the whole thing here
12:57:30 <monochrom> s !! (n+1) = (rs !! n) ⊕ (xs !! n)
12:57:30 <monochrom> ⇒ 	
12:57:30 <monochrom> rs = scanl (⊕) s0 xs
12:57:43 <monochrom> This characterization talks about “the nth item” because we will connect it with recurrences, which also talk about “the nth item”.
12:57:44 <int-e> but it's inconvenient to read because other people keep adding noise in the middle ;-)
12:57:49 <shachaf> monochrom: Can you give me the answer, but fix it so I don't have to read anything?
12:57:49 <monochrom> etc etc I get tired.
12:58:06 <monochrom> Yeah! Where is your USB port in your head?
12:58:18 <monochrom> Or you have wifi?
12:58:25 <SrPx> Hi all, here is a tutorial for Formality-Core, a parallel functional language without GC compatible with bookkeeping-free optimal reductions: https://github.com/moonad/formality-core/wiki/ -- it is meant to be the ultimate compile target for resource-aware functional languages
12:58:47 <monochrom> In the TV series Heroes, someone's brain could decode and encode wifi signals.
12:58:54 <shachaf> I only take RJ-11 and AppleTalk.
12:59:51 <monochrom> Actually I don't mind doing summaries, you know. In fact I did. "mathematics".
12:59:52 <int-e> shachaf: try https://www.youtube.com/watch?v=wZZ7oFKsKzY if you need to make room in your head :P
13:00:28 <shachaf> int-e: Do you like this?
13:01:00 <int-e> no I think it's a modern Rick-roll.
13:01:56 <MarcelineVQ> zincy: idk if it works but I removed the sig on seatsVec and wrote updatePosToAct :: (p ~ Seats n) => Fin n -> Game s b p -> Either UpdatePosToActErr (Game s b p)
13:02:01 <zincy> shachaf: Oh that was the link with the answer? haha
13:02:27 <monochrom> SrPx: Ah the lambdas are affine, no wonder.
13:02:28 <MarcelineVQ> By idk if that works I mean idk what kind of onus that puts on you at the use-site, never used ~ myself
13:03:51 <monochrom> But I wouldn't claim "ultimate" so quickly. I mean just look at those "HD" and "UHD". Pretty sure there will be ten more things beyond "U"HD>
13:05:09 <tdammers> Unutterable Accursed Ultimate High Definition
13:05:48 <monochrom> I had "unaffordable" in mind. >:)
13:06:16 <MarcelineVQ> an alternative reading of ultimate is the last step of a process
13:06:20 <zincy> MarcelineVQ: Thanks for the suggestion but same error :/
13:06:30 <MarcelineVQ> eh? no error here
13:06:41 <zincy> weird hmm
13:07:20 <zincy> Nope I am wrong
13:07:29 <zincy> That fixed it now I need to understand why ...
13:08:18 <int-e> tdammers: I've always dreamed of transferring 1500MB/s to my monitor :)
13:11:37 <shachaf> int-e: Isn't that just regular UHD?
13:12:08 <zincy> MareclineVQ: Thanks!
13:12:14 <MarcelineVQ> There's no relation between n and Game s b p so when we pattern match the value of Game we don't create any gurantees about the types we expose in the match. p ~ Seats n establishes a relation between the two to inform the types we later expose. Specifically that p will have the form Seat n, which means we can affect it with the n we have. I guesss, dunno actually :>
13:12:59 <int-e> shachaf: yes. the 8K UHD is 4 times more, obviously.
13:15:09 <int-e> . o O ( uselessly high density )
13:25:23 <systemfault> I wonder if it's actually useless... I mean, remember when people were saying that 128kbps MP3s were "CD Quality"? :/
13:25:39 <systemfault> We'll see..
13:25:42 <MarcelineVQ> 256 colors aught to be enough for anybody
13:25:46 <systemfault> But I'm skeptical too
13:26:06 <MarcelineVQ> 8k matters when you're blowing it up to watch on a wall.
13:26:48 <MarcelineVQ> sure not the typical household usecase though
13:35:38 <int-e> MarcelineVQ: I think even 4K is questionable (especially in TVs... but it sure works great in cramped stores where you're right next to the display.)
14:17:34 <randoUser987> hi, quick question. I was trying to implement the sum function directly (sum' (x:xs) = x + sum' xs) and it is somehow 10x slower than the builtin sum, compiling with -O2 and ensuring the list is evaluated before calling the function, does anybody know why is this?
14:19:10 <lavalike> @src sum
14:19:10 <lambdabot> sum = foldl (+) 0
14:19:21 <boj> randoUser987: maybe compare your implementation to the source: https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Foldable.html#sum
14:19:59 <lavalike> also (+) x (sum' xs) is not tail recursive so that's a difference I guess
14:20:44 <jle`> randoUser987: it's probably because of some extra laziness
14:21:29 <jle`> randoUser987: try searching up some breakdowns of foldl vs. foldl' :)
14:21:47 <glguy> Cale: What are you writing anyway (regarding earlier)
14:21:53 <jle`> what you have is a foldr, but it suffers from some similar issues as foldl does in this case
14:22:27 <randoUser987> I also tried foldr and it was still slower than the Prelude function
14:22:39 <jle`> randoUser987: right, i'm saying that your version is equivalent to the foldr version
14:22:52 <randoUser987> ahhh thanks
14:22:56 <int-e> > foldl' (+) 0 [1..100]
14:22:57 <randoUser987> that makes more sense
14:22:59 <lambdabot>  5050
14:23:25 <int-e> I think that's the usual recommendation: left fold, with a strict accumulator
14:23:58 <jle`> randoUser987: the 'high level' problem is that foldr (+) 0 [1,2,3,4] builds up a tree, 1 + (2 + (3 + (4 + 0))
14:24:22 <jle`> first, it builds the tree.  then, when you evaluate the result, it "collapses" the tree
14:24:56 <jle`> so if your list is big, it'll allocate a huge tree on the heap, before trying to collapse it and find the answer when youe valuate it 
14:25:02 <int-e> hmm, no, it goes down the tree immediately, (the (1+), (2+), etc. go on the stack)
14:25:31 <jle`> hm, disregard what i said then :)
14:25:34 <randoUser987> but i thought that it was better to use foldr / foldl' compared to foldl to avoid mem leaks
14:25:52 <jle`> foldl' is better than foldl
14:26:08 <jle`> foldr and foldl' are "different" enough that their use cases aren't very overlapping
14:26:14 <int-e> foldl is the one that builds the whole tree first, and then collapses it, unless the compiler gets clever and deduces additional strictness.
14:26:28 <randoUser987> ok, i thing that i understand the problem
14:26:31 <randoUser987> thnx
14:27:16 <int-e> (foldl' has the added benefit that it's a standard list function so it may benefit from build/foldr fusion that can eliminate intermediate lists)
14:32:19 <zincy_> So does anyone know if type equality constraints like this are a code smell?
14:32:21 <zincy_> updatePosToAct :: (p ~ Seats n) => Fin n -> Game s b p -> Either UpdatePosToActErr (Game s b p) 
14:41:33 <lyxia> No that's quite a useful pattern. It's kind of a type-level "let"
14:43:52 <lyxia> One alternative might be a type synonym   type Game' s b n = Game s b (Seats n)  but that's a bit of a pain if there are lots of types to wrap like that.
14:49:25 <zincy_> lyxia: cheers
14:58:25 <iqubic> So I'm trying to do some type level stuff in Haskell.
14:59:18 <iqubic> The following code refuses to compile, due to the @a in the opinion function. I'm getting the error that the type variable a is not in scope.
14:59:21 <iqubic> http://dpaste.com/138G8YC
14:59:44 <iqubic> Can someone help me figure this out?
15:00:56 <iqubic> Maybe the handleState function needs to take a bag as input, instead of just 3 options to chose from?
15:01:00 <dmwit> Turn on ScopedTypeVariables, AllowAmbiguousTypes, and add `forall a.` to the beginning of the type signature.
15:01:20 <iqubic> Why do I need both of those?
15:01:47 <dmwit> You could read the documentation on them.
15:01:50 <dmwit> Then you would know.
15:02:06 <dmwit> Or at least have a better, more focused question... ;-)
15:04:09 <iqubic> As soon as I added scoped type variables and the forall to the beginning of the opinion function, handleState's type signature now has an error: "Cannot deduce (HandleState a0) from the context HandleState a bound by the type signature...."
15:04:48 <Solonarv_> actually, you don't need a forall on handleState's signature
15:05:03 <Solonarv_> typeclass methods "inherit" a forall from the class head
15:05:15 <dmwit> No. You need it on `opinion`'s type signature.
15:05:24 <Solonarv_> oh, yes.
15:05:25 <dmwit> Which is where the error is.
15:05:42 <iqubic> I didn't change handleState.
15:05:52 <dmwit> You also didn't take my complete advice.
15:06:16 <iqubic> All I did was add a forall to the opinion function, and turned on scoped type variables.
15:06:29 <dmwit> Yes. And that is only 2 out of the 3 things I advised you to do.
15:07:04 <bachibuzuk> hi there
15:07:08 <dmwit> What's more, the error you got even says to do the third thing if you read it fully.
15:07:56 <iqubic> I didn't add AllowAmbiguousTypes yet, because I was confused as to why ADDING a language pragma would cause an error in a place that was previously error free.
15:08:09 <dmwit> That place was not previously error free.
15:09:00 <iqubic> What do you mean?
15:09:17 <iqubic> Oh, I suppose that Emacs was only showing me one error at a time.
15:09:35 <dmwit> You have not yet successfully compiled this file. Therefore it was not previously error-free.
15:09:44 * dmwit waves at bachibuzuk
15:10:47 <iqubic> I have now compiled the file successfully.
15:12:23 <iqubic> And finally I have something that compiles: http://dpaste.com/24XX5CV
15:18:54 <iqubic> So I have my bag code from above.
15:19:07 <iqubic> Is it possible to write a function of the type: "asWhite :: Bag a -> Bag White"?
15:19:26 <iqubic> Which does nothing but changes the type of the bag given and leaves the values alone?
15:20:11 <int-e> :t Data.Coerce.coerce
15:20:13 <lambdabot> Coercible a b => a -> b
15:20:32 <iqubic> int-e: Is that safe to use here?
15:20:42 <int-e> (as long as the 'a parameter has a phantom role that will work)
15:21:03 <int-e> iqubic: Basically the whole point of coerce is that it's type-safe.
15:21:34 <iqubic> Cool. It does have a phantom role.
15:21:52 <int-e> (in contrast to unsafeCoerce, which should always be met with suspicion)
15:22:08 <iqubic> What does unsafeCoerce do?
15:22:09 <tty1> Is there any way of derriving from or extending data types.. like adding an additional constructor to it?
15:22:26 <iqubic> And why is one better/more safe than the other/
15:22:29 <int-e> :t Unsafe.Coerce.unsafeCoerce
15:22:30 <lambdabot> a -> b
15:22:50 <int-e> iqubic: note the `Coercible` constraint on the arguments of `coerce`.
15:23:05 <iqubic> I do note that.
15:23:10 <lyxia> tty1: https://blog.poisson.chat/posts/2018-11-26-type-surgery.html
15:23:10 <int-e> which is checked by the compiler.
15:23:22 <tty1> thanks
15:23:23 <iqubic> I didn't derive coercible at all.
15:23:31 <int-e> in contrast, unsafeCoerce just say "please treat this value of type a as a value of type b, I promise that's okay"
15:23:43 <iqubic> I have this code if you want to see http://dpaste.com/24XX5CV
15:23:49 <int-e> Coercible is handled by the compiler.
15:24:08 <c_wraith> sort of like Typeable
15:24:17 <iqubic> I see.
15:25:38 <tty1> lyxia: this appears to be json specific, you sure it was the link you meant?
15:26:23 <lyxia> tty1: that's just an example
15:26:40 <tty1> ok... hmm
15:27:12 <lyxia> The idea and implementation is pretty general.
15:27:28 <lyxia> It's also far from ideal of course
15:27:47 <lyxia> you don't get pattern-matching
15:28:35 <tty1> lyxia: so generally it should be avoided i guess
15:29:13 <tty1> there is probably a better way to do what i want and i just dont know haskell well enough to see it yet :(
15:29:57 <tty1> im too used to OO programming where i can define some sane structures but allow the user to extend from them if their not sufficient
15:30:11 <tty1> hard for me to see how they might do that in haskell though in a sane way
15:32:37 <iqubic> Alright... Here's the thing I need now. I need a way to make a list of bags of all color.
15:33:11 <iqubic> So I need to take my bag code as seen here: http://dpaste.com/24XX5CV, and somehow make a heterogenous list of bags.
15:34:14 <iqubic> So the list could be something like: [Money 4 :: Bag White, Jewel "Ruby" 7 :: Bag Red, Money 10 :: Bag Blue]
15:34:18 <iqubic> Is that possible?
15:34:57 <iqubic> I feel like I need to define "Data SomeBag a = forall a. Bag a" and then make the list be of type SomeBag
15:35:38 <iqubic> *data SomeBag = forall a. Bag a
15:35:40 <iqubic> rather.
15:35:43 <iqubic> Will that work?
15:36:04 <[exa]> certainly possible, but you need to constraint 'a' to be able to work with that
15:36:27 <lyxia> tty1: what you said reminds me of the expression problem https://oleksandrmanzyuk.wordpress.com/2014/06/18/from-object-algebras-to-finally-tagless-interpreters-2/
15:36:37 <iqubic> [exa]: What does that mean?
15:36:46 <tty1> lyxia: ill check it out
15:36:51 <zincy_> iqubic: You might like the book "thinking with types"
15:37:15 <iqubic> [exa]: I just added the line: "data SomeBag = forall a. Bag a" and the language pragma ExistentialQualification and the compiler seems to accept it.
15:37:31 <[exa]> iqubic: that you probably won't be able to check whether the bag is White for really all types 'a'
15:37:44 <iqubic> What does that mean?
15:38:13 <iqubic> So are you saying my handleState machinary will fail to work with this hetorgeneous list?
15:38:39 <[exa]> usually you put some kind of typeclass before that; like forall a. Color a => Bag a
15:38:56 <iqubic> Why?
15:39:02 <iqubic> What benifit does that give me?
15:39:30 <iqubic> I've already set it up so that the a of Bag a can only be one of three different types.
15:39:45 <iqubic> The type parameter a is phantom.
15:39:58 <iqubic> Have you looked at the code I linked to?
15:40:10 <[exa]> okay if you don't need to access it that way, no problem then
15:41:12 <jle`> hm, why is there still no integerToNat :: Integer -> Maybe Natural in base
15:43:03 <zincy_> jle`: Finished part 3 of your Singletons tutorial :)
15:43:12 <lyxia> iqubic: your bags don't need the state tag, so you could also define a simple    data Bag = Money Int | Jewel String Int    and then augment it    type ColoredBag (a :: BagState) = Tagged a Bag   (from the tagged package)
15:43:25 <iqubic> Gah... What's going on here??? http://dpaste.com/2260ZEP
15:43:34 <jle`> zincy_: ah congrats :D hope you enjoyed it :)
15:43:39 <iqubic> lyxia: That might actually be a bettwe way to do it.
15:43:45 <zincy_> jle`: It is awesome!!
15:44:13 <iqubic> I'm not sure how the tagged package works. Besides, I nearly have this complete anyways.
15:44:30 <iqubic> Except for the darn heterogeneous list thing.
15:44:44 <iqubic> I can't make a heterogeneous list in the way that I want to.
15:45:01 <lyxia> iqubic: newtype Tagged a b = Tagged b   that's one of the simplest packages out there
15:45:15 <iqubic> Oh. I see.
15:45:25 <iqubic> I think I'll stick with my method for now.
15:45:29 <zincy_> jle`: Is the SomeDoor pattern useful outside of singleton types?
15:45:45 <lyxia> iqubic: you forgot to give a constructor for SomeBag, and then you need to use that constructor in the list.   data SomeBag = forall a. SomeBag (Bag a)
15:45:52 <jle`> zincy_: do you mean, is SomeDoor still useful if we don't have singletons?
15:46:11 <lyxia> iqubic: testList = [SomeBag (Money 4 :: Bag White), SomeBag (...), ...]
15:46:40 <jle`> zincy_: the question might be a bit weird, because SomeDoor is equivalent to just Door
15:46:58 <jle`> so it's not useful unless you eventually want to reify the Door to the type level at some point
15:47:09 <zincy_> jle`: yes, I have a GADT with 5 different data constructors and I want to operate on the GADT itself in a data constructor agnostic way
15:47:28 <iqubic> So I have that now, but how do I get the original Bag a out of the SomeBag data wrapper?
15:47:29 <jle`> oh okay, so not SomeDoor over a singleton, but an existential over a GADT
15:47:46 <zincy_> Yeah 
15:48:15 <jle`> zincy_: it can be useful, yeah, mostly if you want to send values of your type over some monomorphic channel
15:48:27 <jle`> or store them all in the same container
15:48:39 <jle`> s/mostly/for example
15:48:42 <lyxia> iqubic: you pattern-match on it   case mySomeBag of { SomeBag bag -> ... }
15:49:14 <zincy_> jle`: oh good idea!
15:49:38 <jle`> zincy_: for something like that you don't need singletons really. libraries like 'dependent-sum' have a data type like that
15:49:52 <iqubic> There's really no easy way to map the show function over the elements of testList is there?
15:50:00 <jle`> sometimes it can be useful to tuple it with a singleton of the type being hidden, and that's Data.Singletons.Sigma is for
15:50:10 <jle`> or also dependent-sum has that too
15:50:13 <iqubic> http://dpaste.com/1N4P3E9
15:50:17 <iqubic> In that code?
15:50:20 <zincy_> jle`: I confused myself here is a code snippet https://pastebin.com/XZP1L1r4
15:50:27 <iqubic> Can I easily map show over testList?
15:51:11 <jle`> zincy_: hm, i'm not sure what you mean, what ar eyou trying to avoid rewriting 5 times?
15:51:23 <iqubic> I think using Tagged might actually be easier here.
15:51:28 <lyxia> iqubic: no that's why you were told you would need a constraint at some point
15:51:31 <jle`> oh, the different matches on udpatePostTOAct
15:51:39 <zincy_> jle`: This pattern match - g@(PreDealGame (Seats seatsVec))
15:51:39 <lyxia> iqubic: to remember the color of the bag
15:51:41 <zincy_> jle`: yeah
15:51:53 <jle`> zincy_: well usually like in normal haskell code, you can try to isolate the logic out
15:52:07 <iqubic> lyxia: But then I can only have lists of one color, right?
15:52:13 <lyxia> no...
15:52:22 <jle`> zincy_: hm, it looks like all of your Game constructors have a 'Seats n', and you just need that 'Seats n' for the logic right?
15:52:26 <iqubic> Huh?? What do you mean?
15:52:32 <jle`> zincy_: do you ever use the extra field in FlopGame?
15:52:43 <lyxia> iqubic: data SomeBag = forall a. HandleState a => SomeBag (Bag a)
15:53:05 <iqubic> And then how would I use that to Show all the elements of a list of bags?
15:53:10 <lyxia> iqubic: now you can standalone derive Show:     deriving instance Show SomeBag
15:53:18 <lyxia> and (map show testList) 
15:53:21 <zincy_> jle`: Which extra field do you mean?
15:53:34 <jle`> zincy_: the Vec (...)
15:53:40 <jle`> zincy_: i'm assumign you want to treat each constructor identically
15:53:50 <zincy_> jle`: Those Seats n is the logic for the player states which change for every game round well actually every turn so maybe they shouldn't be there
15:54:01 <jle`> zincy_: if so then you can just write a function that takes a Seats n, not a Game
15:54:28 <zincy_> jle`: Correct each constructor should be treated identically for the updatePosToAc function
15:54:47 <zincy_> jle`: oh its that simple :D
15:54:59 <jle`> zincy_: yeah, it's basically the same as any normal haskell code with adt's :)
15:55:27 <zincy_> jle`: Haha it is easy to overthink things
15:55:35 <jle`> i've been there heh
15:56:09 <zincy_> jle`: What is the rule for when I need a singleton?
15:56:11 <iqubic> How does the Show SomeBag work?
15:56:39 <iqubic> Like when I do the standalone deriving, what code is actually created?
15:56:40 <zincy_> jle`: From my understanding it is basically when at runtime you need to recover type information?
15:57:18 <jle`> zincy_: i wouldn't say you necessarily "need" one, but it is a tool that lets get access to the type at runtime, yeah
15:57:35 <jle`> that's a situation where singletons might be useful/simplify a lot of code :)
15:57:59 <jle`> i don't think it necessarily will ever enable code that would otherwise be impossible. but it definitely can be useful for cleaning things up in some situations
15:58:33 <lyxia> iqubic: exactly the same code you would get for a regular type with one constructor and one field
15:58:41 <jle`> but yeah nowadays if i ever need to "pattern match" on a type, i usually reach for a singleton of it
15:59:18 <jle`> the alternative would be maybe some typeclass based system, like what we have in GHC.TypeLits
15:59:19 <iqubic> lyxia: That can't be right.
15:59:24 <lyxia> iqubic: why
15:59:25 <zincy_> jle`: So kind of like pattern matching at the value level based on types ...
15:59:36 <iqubic> It must somehow unbox the SomeBag type.
15:59:47 <lyxia> iqubic: yeah, pattern-matching does that.
16:00:03 <iqubic> Can you show me?
16:00:27 <lyxia> iqubic: you can compile your code with -ddump-deriv and see for yourself
16:00:30 <jle`> zincy_: yeah, that's a situation where i would begin to consider using singletons
16:01:28 <zincy_> jle`: Thanks for your help. Your tutorial on fixed length vectors was super helpful too.
16:01:31 <iqubic> I'll look into that.
16:01:45 <jle`> zincy_: of course :D  happy it was helpful :)
16:01:54 <zincy_> jle`: When is the book coming?
16:02:23 <lyxia> iqubic: simplified, it may look like this https://gist.github.com/Lysxia/86d9adc6cb142959fbb0469250796c13
16:02:51 <jle`> zincy_: heh, no book planned atm, but i've heard a lot of good things about sandy maguire's book :D
16:03:26 <iqubic> What book did Sandy Maguire write?
16:04:31 <jle`> Thinking With Types
16:06:41 <lyxia> iqubic: jle`'s Introduction to singletons that's been discussed in parallel just now is also closely related to what you're doing https://blog.jle.im/entry/introduction-to-singletons-1.html
16:10:20 <iqubic> I've read the first part of that, yeah.
16:29:11 <qwebirc68467> hi
16:29:32 <qwebirc68467> ghci command not found
16:39:17 <jackdk> have you checked behind the sofa?
16:40:48 <r734> jackdk, yeah good call, I lost my ghci underneath the front passenger seat last week
16:54:34 <dmwit> jackdk: http://i.imgur.com/Q7uuN.png
16:55:58 <jackdk> dmwit: "The Internet" sounds like something only Carmen Sandiego could steal.
16:56:15 <dmwit> Oh, she's good. She's *very* good.
16:57:04 <jackdk> A quick search suggests that she's stolen "The world's TV signals", "Portugese" and "The Rings of Saturn", so I don't doubt her thieving skills.
17:02:08 <mac10688> http://hackage.haskell.org/package/time-1.9.3/docs/src/Data.Time.Calendar.Days.html#Day Anyone know how I could create a Day type? I tried `toModifiedJulianDay 50` but that doesn't work
17:02:24 <dmwit> ModifiedJulianDay 50
17:02:30 <mac10688> hmm
17:03:00 <mac10688> newtypes still confuse me but i guess that makes sense
17:03:07 <iqubic> would my bag data be easier to write if I used the Tagged package?
17:03:26 <hpc> you want to look up record syntax
17:03:39 <hpc> (which newtypes tend to use frequently)
17:03:41 <mac10688> thanks dmwit !
17:03:52 <dmwit> iqubic: 6 of one, half dozen of the other. The real blocker here is your understanding, I think, not whether you use a prerolled library or not.
17:04:36 <dmwit> (And avoiding the prerolled version is better for improving your understanding.)
17:04:36 <iqubic> really?
17:04:49 * dmwit shrugs
17:05:10 <dmwit> Propose an alternative theory, and we can think of a test that will distinguish them.
17:05:31 <iqubic> What parts of this have I failed to undersstand?
17:07:13 <dmwit> The question is wrong. It assumes that "understand" is a predicate, either true or false.
17:08:04 <dmwit> But "understand" is actually a gradation. It moves smoothly from "completely confused" to "sometimes, with effort, I get it right" to "I can use it" to "it is completely automatic".
17:08:30 <iqubic> What parts of this have I been struggling with?
17:08:57 <dmwit> At least: ambiguous types, existential quantification.
17:09:05 <dmwit> Probably more. Those are just the two I was here for.
17:09:41 <iqubic> What do ambiguous types do?
17:09:57 <dmwit> Please don't read this as a value judgment. It would be wildly unrealistic to think that you would move from "never heard of it" to "it's completely automatic" in the span of a few hours.
17:10:37 <iqubic> I know. I know
17:12:08 <iqubic> Can someone explain what Ambiguous types are?
17:12:18 <dmwit> Have you read the documentation?
17:12:31 <iqubic> No.
17:12:41 <iqubic> I couldn't find it to be honest.
17:12:45 <dmwit> Yes, somebody can explain what ambiguous types are, and already has.
17:13:29 <dmwit> Okay. If you don't already know what ambiguous types are, the documentation is actually not super helpful on this particular point.
17:13:51 <dmwit> This is a bit unusual.
17:15:13 <dmwit> It's like this: types have a context (the bit before a `=>`) and a head (the bit after).
17:16:29 <dmwit> So you have something like `Num a => a -> a -> a`, say.
17:16:33 <jle`> it'd be cool if MINIMAL pragmas could also include associated types, hm
17:16:40 <dmwit> jle`: agreed
17:17:04 <dmwit> This type says that the behavior of the function depends on how the `Num` methods are implemented for the type `a`.
17:17:46 <dmwit> Under normal circumstances, at the use of a value with this type, we pick a type for `a`; then this tells us how the `Num` methods should behave and so how the function itself should behave.
17:17:46 <shachaf> MINIMAL is such a great extension, huh.
17:17:59 <dmwit> But sometimes the circumstances are not normal!
17:18:27 <dmwit> In non-normal circumstances, you have constraints that mention variables that would not be determined by type inference at the use site.
17:18:36 <dmwit> For example, `Num a => String -> String -> String` would be such a type.
17:19:26 <dmwit> This type says again that the behavior of the function may depend on the behavior of the `Num` methods for type `a`. But we can't determine which type `a` to use just from the use site: type inference only tells us that we must call it with two `String`s, but not how to pick `a`.
17:19:50 <dmwit> Types like this, where the constraints mention type variables that are not determined by the head, are called ambiguous.
17:27:20 <iqubic> I see.
17:27:22 <iqubic> Makes sense.
17:27:28 <iqubic> Thanks for that.
17:27:53 <iqubic> Why would we chose to write ambiguous types?
17:28:22 <shachaf> dmwit: You should take that explanation and put it up on the FAQ.
17:28:24 <shachaf> @faq
17:28:24 <lambdabot> https://wiki.haskell.org/FAQ
17:29:03 <shachaf> Then you can tell people to read that next time. Or copy and paste it from there, for people who don't have a web browser.
17:29:11 <dmwit> iqubic: Look no further than `opinion`.
17:29:31 <iqubic> What makes the opinion function ambiguous?
17:29:51 <iqubic> Is it the HandleState a => String signature?
17:30:43 <dmwit> Yes. Notice how it has a constraint that mentions type variables in the context that don't appear in the head?
17:31:42 <iqubic> Right. Why did I need that constraint?
17:32:25 <dmwit> Because you plan to call the only method that HandleState has, of course.
17:32:42 <iqubic> Right. LOL.
17:32:48 <iqubic> Which is a sensible thing to do.
17:34:26 <iqubic> What is the difference between the code I'm writting right now, vs the code I'd get if I chose to use the Tagged package?
17:35:51 <shachaf> Have you looked up how the Tagged package works?
17:35:57 <iqubic> no.
17:36:03 <shachaf> Then I suggest you do that.
17:39:14 <iqubic> So I looked at the package, and I'm really confused.
17:39:21 <iqubic> Why would anyone want this?
17:41:00 <shachaf> Have you looked for answers on the Internet?
17:41:13 <shachaf> Because I just did, and I found an article that explains it.
17:43:08 <dmwit> iqubic: This really needs to become a habit for you. You need to learn to search for existing resources before asking here.
17:43:54 <dmwit> Why it's good for us: because it reduces duplicated exposition effort.
17:44:07 <iqubic> I'm having trouble finding articles on Data.Tagged
17:44:19 <dmwit> Why it's good for you: because spending effort on the topic first makes folks in here more excited about helping you, so you will get more targeted, higher-energy assistance.
17:46:02 <iqubic> I just tried looking for info on the Data.Tagged library, and couldn't find it.
17:47:07 <dmwit> https://stackoverflow.com/q/27044209/791604 looks relevant
17:49:25 <shachaf> @google haskell examples of tagged type
17:49:25 <lambdabot> https://www.reddit.com/r/haskell/comments/3xhoce/tag_dont_type/
17:49:51 <shachaf> golly
17:55:30 <orzo_> I have some code that imports a module purely for RULES pragmas (Numeric.FastMath).  I'm warned that it's a redundant import except to import instances.  Do I still get the RULES if I restrict the import to () as if i want instances only?
18:02:13 <dmwit> I don't know. You could test painfully with -ddump-simpl, or possibly you could test less painfully with https://hackage.haskell.org/package/inspection-testing .
18:04:00 <shachaf> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#rewrite-rules says "All rules are implicitly exported from the module, and are therefore in force in any module that imports the module that defined the rule, directly or indirectly."
18:05:03 <orzo_> I'm not 100%, but that language leans me toward "yes" to my question.
18:05:48 <shachaf> The rest of the sentence might help you get above 99%.
18:06:01 <shachaf> 100% is difficult to be, to be sure.
18:08:12 <orzo_> If the answer is yes, then what happens when a rewrite rule references a symbol that is not in scope?
18:08:37 <dmwit> Rewrite rules are not limited to the usual rules about scope.
18:10:12 <shachaf> Alternatively, rewrite rules are lexically scoped, like definitions?
18:18:08 <orzo_> Maybe the ghc error should says instances and rewrite rules
18:19:07 <orzo_> that probably covers everything imported by an empty import list
18:20:43 * monochrom uploads package "acme-singleton" which consists of just one module ACME.Singleton which contains just one rewrite rule "forall x. x = ()"
18:21:02 <monochrom> Wait a second, that won't type-check.
18:21:52 <monochrom> Darn, now I have to rename it s/singleton/heat-death/ and change () to bottom.
18:22:37 <monochrom> Err s/heat-death/vanity/.  Vanity of vanity, all is vanity, forall x. x = error "vanity"
18:25:12 <orzo_> it's probably fun inside your head, but the rest of us will never know
18:26:08 <fresheyeball> hey out there
18:26:17 <fresheyeball> I would like to use stable-memo with ghcjs
18:26:30 <fresheyeball> But it needs GHC.Prim (Any)
18:26:36 <fresheyeball> is there a way around this?
18:26:45 <fresheyeball> perhaps a better weak ref based memo library out there?
18:26:53 <dmwit> monochrom: Are rewrite rules even subject to typechecking?
18:27:05 <monochrom> Yes as I recall.
18:28:01 <dmwit> Illegal expression: x; LHS must be of form (f e1 .. en) where f is not forall'd
18:28:02 <dmwit> Bummer.
18:28:08 <monochrom> Darn.
18:28:31 <monochrom> Oh well that's a vain joke anyway.
18:28:45 <monochrom> But hey who says I must upload a package that builds!
18:29:01 <dmwit> oh wow
18:29:10 <dmwit> just went over to the "chaotic evil" side of things
18:29:23 <dmwit> You were lawful evil before. Now I hardly know you.
18:29:26 <Axman6> I was literally about to type chaotic evil
18:29:59 <monochrom> Blame it on the coffee I had today.
18:30:01 <Axman6> This is honestly one of the most shocking things I've seen in this channel in the past 10 years
18:30:06 <shachaf> dmwit: It sounds to me like a package that breaks the type system not type-checking is much more lawful than the other way.
18:31:58 <monochrom> That's an interesting view. I guess it's still better than the mainstream pythonist behaviour of "let me upload a package that would not type-check under python 5" tee hee hee
18:34:49 <dmwit> shachaf: I tried to enjoy your joke but I can't understand it.
18:35:14 <shachaf> dmwit: Because me not good put words next each other
18:35:21 <dmwit> =D
18:35:37 <shachaf> dmwit: What I mean is: If your package breaks the type system, isn't it more lawful for it to fail to build, rather to build successfully?
18:36:05 <dmwit> Oh! Yeah, but monochrom isn't to blame for the typechecker being foisted off on rewrite rules.
18:36:39 <monochrom> "It's no one's fault."  I learned that from the Pikachu movie today.
18:36:43 <dmwit> (Those poor rules! Forced to live under the tyranny of the police state, always being checked for "types". Just straight up racism if you ask me.)
18:37:13 <shachaf> monochrom is proposing to upload this package, which is clearly invalid. You thought that was lawful evil. Now you have the new information that the package doesn't build. I claim that only makes it more lawful, not less.
18:37:36 <monochrom> No, it was chaotic evil.
18:37:47 <shachaf> dmwit: See http://strictlypositive.org/winging-jpgs/
18:38:24 <monochrom> haha engage in criminal activity
18:38:45 <dmwit> shachaf: Oh, no, monochrom is proposing to make a package. Then I informed him that it won't work, and so he can't upload it, and this is lawful evil. But then he says he can upload it even so. This is chaotic evil.
18:39:08 <shachaf> Ah.
18:41:28 <monochrom> Wait what, predicate transformers?
18:42:19 <monochrom> I will join this revolution. Just because predicate transformers are brought up!
18:42:47 <monochrom> It's about time the functional formal methods fanboys learn from the imperative formal methods experts!
18:47:00 <iqubic> What is a predicate transformer/
18:47:34 <iqubic> newtype Predicate a = {runPredicate :: a -> Bool} is a contravariant predicate
18:47:46 <monochrom> A function from postconditions to weakest preconditions, in Dijkstra's version.
18:49:01 <iqubic> I'm still not understanding.
18:49:09 <monochrom> It's OK.
18:49:32 <shachaf> iqubic: I suggest you refer to the last thing dmwit said to you.
19:04:17 <iqubic> shachaf: The thing were he said he wanted to make a package/
19:05:06 <shachaf> I was thinking of "iqubic: This really needs to become a habit for you. You need to learn to search for existing resources before asking here."
19:05:32 <shachaf> If you did search for resources, you can ask a question like "I read X and I was confused about what Y meant", or something.
19:05:33 <monochrom> I thought I was the one wanting to make a package.
19:07:30 <z0> ?type pure id
19:07:31 <lambdabot> Applicative f => f (a -> a)
19:08:53 <monochrom> Yeah, "pure id" is a perfect thing to be used as the left operand of <*>, e.g., "pure id <*> foo"
19:10:38 <shachaf> :t \foo -> pure id <*> foo
19:10:40 <lambdabot> Applicative f => f b -> f b
19:11:41 <monochrom> Algebraically, pure id <*> foo = fmap id foo = foo. Boring example but good exercise for getting used to the types and algebra.
19:18:39 <z0> got it
19:25:55 <ski> dmwit : "(Those poor rules! Forced to live under the tyranny of the police state, always being checked for \"types\". Just straight up racism if you ask me.)" -- <http://www.lisperati.com/landoflisp/panel60.html>
19:31:44 <fresheyeball> so I keep getting These modules are needed for compilation but not listed in your .cabal file's other-modules
19:31:51 <fresheyeball> and I keep checking the .cabal file
19:31:56 <fresheyeball> AND THEY ARE THERE
19:40:45 <qwebirc55544> Hello, I am trying to install haskell on Mac OS with:curl https://get-ghcup.haskell.org -sSf | sh and I get the message: To install and run GHC you need the following dependencies: Following commands are required, but missing, please install:  xz
19:40:56 <qwebirc55544> I am unsure what this means 
19:41:17 <MarcelineVQ> it means you need to brew install xz probably :>
19:41:54 <fresheyeball> does cabal ignore other-modules on exes?
19:42:01 <MarcelineVQ> fresheyeball: no
19:42:38 <qwebirc55544> I see, thank you MarcelineVQ
19:43:03 <fresheyeball> https://gitlab.com/fresheyeball/Shpadoinkle/blob/lens-example/examples/package.yaml#L30
19:43:15 <fresheyeball> MarcelineVQ: ^^ if you want to take a look
19:44:21 <c_wraith> qwebirc55544, xz is a compression utility. you can install it via homebrew or the like
19:44:46 <c_wraith> huh, a bit redundant there. sorry.
19:44:59 <monochrom> I don't think cabal reads package.yaml at all?
19:45:01 <MarcelineVQ> that's not a cabal file :O
19:45:55 <monochrom> It's OK to use stack, but you should say that stack is involved. That changes the question.
19:46:44 <MarcelineVQ> monochrom: in fairness it doens't mean stack is involved either, but let's wait and see
19:51:09 <MarcelineVQ> I'm getting really interested now: these qweb+macos+ghcup questions are exceedingly similar, wonder what the common thread is. a class? a study group? a reddit/blog post? How are they all so consistently well asked, pretty much exactly the same, and somehow unsolvable for the asker
19:54:50 <MarcelineVQ> fresheyeball: *psst* when I said to monochrom let's wait and see, it was a hint that you might want to share what steps you're doing to produce your problem, what you expected to see, and what you saw
20:15:26 <monochrom> MarcelineVQ: I am beginning to suspect it's my fault. I told my students about ghcup. (But I didn't tell them about IRC.)
20:27:29 <jusss> there're three functions to describe monad? join, flatMap, and?
20:31:15 <oni-on-ion> bind
20:31:23 <oni-on-ion> return, and ..
20:31:24 <suzu> return
20:35:14 <jusss> join, bind, and return?
20:38:38 <fresheyeball> MarcelineVQ: so all you need to do is run nix-shell then cabal new-build todomvc --ghcjs
20:38:54 <fresheyeball> apparently ghc doesn't have a problem only ghcjs
20:43:22 <jackdk> juss: return (aka pure from Applicative) and one of {join, (>=>), (>>=) aka "bind" aka "flatMap"}, IIRC
20:43:29 <jackdk> jusss^
20:43:52 <fresheyeball> MarcelineVQ: yeah, ghc sees the other-modules, but ghcjs doesn't
20:50:12 <jusss> jackdk: why people use >>=, not return or join to operate monad?
20:50:54 <jackdk> I do not understand your question. return is not equivalent to join or >>=
20:51:12 <monochrom> >>= is more convenient for programmers. join is more convenient for mathematicians.
20:51:23 <jackdk> join, >>= and >=> are equivalent to each other, in that you could write any one of them using any one of the others
20:51:27 <monochrom> But all need return.
20:52:01 <monochrom> Also, the two suites are {return, >>=} and {return, join, fmap}.
20:52:10 <jusss> monochrom: return is ralated with lift?
20:52:19 <monochrom> Also, fmap does not stand for "flatmap". The "f" is "functor".
20:52:26 <monochrom> No.
20:52:30 <dmwit> Depends on the relation you choose.
20:52:57 <monochrom> Anyway I shouldn't be getting involved.
20:55:25 <jackdk> monochrom: why not?
20:56:08 <monochrom> Because they have shown tendency to scramble information.
20:56:58 <MarcelineVQ> monochrom: But the interesting part is that it's all the same client, the same OS, the same question, and the same helplessness despite asking a question in such a clear way that it answers itself
20:57:46 <monochrom> Hmm I think "homebrew" or "macports" is not deducible from the question.
20:57:57 <monochrom> But maybe I didn't read the error message carefully.
20:58:35 <dmwit> Googling "how to install xz on osx" gets you instructions on how to install brew and then how to use brew to install xz.
20:58:36 <MarcelineVQ> still the last 3 words of the question are "please install: xz" even if a method isn't given
20:58:37 <monochrom> But they are more data points for my simple yet accurate model that people simply black out upon messages that are marked as "error" messages.
20:58:38 <dmwit> I tried it.
20:58:47 <jackdk> no that's depressingly common with students. I see many posts where cabal says "re-run the configure command" and the request for help doesn't say "I tried to run the configure command"
20:59:23 <monochrom> Suppose I say, simply, "press the red button". You will, simply, press the red button.
20:59:28 <fresheyeball> what the heck
20:59:39 <MarcelineVQ> The consistency is the interesting part to me more than anything else
20:59:39 <sclv> ideally we wouldn't require xz tho i guess
20:59:42 <fresheyeball> I got the whole thing building and serving this ghc and jsaddle-warp
20:59:48 <jackdk> (this is on an internal course discussion board.) And since I feel like yelling at clouds, I blame years of useless errors from the "oops, something went wrong :(, sorry!" school of "friendly" UI design
20:59:52 <fresheyeball> but ghcjs says other-modules not found
20:59:53 <monochrom> But suppose I say, "error. press the red button to fix it". You will, simply, panic.
21:00:18 <sclv> oh hmm -- i guess ghchq distro bundles all are xz now, so no choice
21:00:19 <jusss> err.. I thought we were talking about monad
21:00:21 <monochrom> This has been reliably reproduced over and over again in this channel.
21:00:21 <dmwit> jackdk: Those past years can't be causing the current crop of fresh-faced helplessness, since they never saw it.
21:01:01 <dmwit> jusss: Meanwhile, I thought we had answered all your questions about monads.
21:01:08 <dmwit> But if you have more, fire away.
21:01:14 <jusss> dmwit: yeah, you did
21:01:52 <jusss> dmwit: but I lack the comprehension ability
21:02:58 <fresheyeball> I added fno-warn not happy but it worked
21:04:27 <monochrom> jackdk: Read my maturity requirement in http://www.cs.utoronto.ca/~trebla/CSCC24-2019-Summer/course-info.html and be very afraid >:)
21:07:11 <jackdk> monochrom: o7
21:08:17 <dmwit> The comment on how minutes with seconds are displayed for due dates + submission dates is really unfortunate.
21:08:36 <dmwit> I don't mean the comment is unfortunate. I mean the misleading display is unfortunate.
21:09:52 <jackdk> monochrom: you start the course with "Why FP Matters"? That's awesome
21:10:22 <monochrom> I so love the phrase "due diligence". I learned this from a friend working in the financial sector, e.g., an investment manager/advisor/salesperson is supposed to do standard background+audit checks on their potential customers so "at least the customer doesn't look like trying to do money laundry".
21:12:47 <dmwit> monochrom: Hm. You may want to be aware of https://stackoverflow.com/q/56194525/791604
21:13:25 <dmwit> The SO policy on homework is this: it is the student's responsibility to be aware of the course requirements, and behave according to the course policy. Answerers are not expected to know the course policy without being told it.
21:13:39 <dmwit> Nevertheless if I have inadvertently enabled cheating I apologize.
21:14:03 <monochrom> Ah thanks.
21:18:53 <fresheyeball> woot! my ui lib examples now fully work with ghc and ghcjs!
21:18:59 <Axman6> monochrom: "Anti-Piazza position statement:" <3
21:19:09 <Axman6> fresheyeball: nice
21:19:12 <MarcelineVQ> fresheyeball: woo :D
21:19:20 <monochrom> Yeah congrats fresheyeball
21:19:48 <Axman6> I was really impressed when I saw that superrecord supported both, that sounds more difficult
21:21:39 <ski> Piazza ?
21:22:26 <dmwit> A popular piece of software for distributing course materials and supporting out-of-class discussions.
21:23:02 <dmwit> Some classes had requirements to make a certain number of posts in the Piazza forums, and this was never a good idea.
21:23:17 <monochrom> Eww
21:23:22 <dmwit> People log on at ten seconds to the deadline and post "Hm, yes, I agree with you dmwit, good point.".
21:23:31 <monochrom> haha
21:23:33 <dmwit> Verbatim. No thought for themselves.
21:24:16 <dmwit> So you punish the good students and make absolutely no difference to the people that actually need that policy.
21:24:36 <Axman6> Needs the bot the xkcd IRC chat has, which mutes you for exponentially increasing times for saying anything which has been said before
21:25:50 <monochrom> Wait wow, that requires a lot of memory doesn't it?
21:26:08 <dmwit> Probably not, actually.
21:26:21 * ski would probably refuse to use such a third-party discussion forum, for a course
21:26:24 <monochrom> Or is it just some mix of Markov chain, neural network, and Bloom filters? >:)
21:26:42 <fresheyeball> Thanks Axman6 MarcelineVQ monochrom !
21:26:53 <dmwit> e.g. my #haskell logs spanning ten years are less than one gigabyte without any attempt at making the storage efficient.
21:26:56 <fresheyeball> Next up it wont build with nix-build
21:27:03 <fresheyeball> it will for ghc but not ghcjs
21:27:16 <fresheyeball> ghcjs builds fine in the shell but not with nix-build
21:27:16 <monochrom> Hmm I guess.
21:27:26 <fresheyeball> it fails on building hpack
21:27:41 <monochrom> Just don't store them as Haskell [Char]. >:)
21:27:42 <fresheyeball> why in the heck does it need to build hpack with ghcjs
21:27:50 <dmwit> monochrom: Hah, yes!
21:28:49 <Axman6> That's just UTF-32, a perfectly cromulent text encoding
21:28:56 <dmwit> I wonder what fraction of IRC messages are "<nick>: {yes,no,hmm}".
21:29:07 <MarcelineVQ> ye
21:29:07 <Axman6> Time to find out
21:29:30 <monochrom> No no, it's 3 times UTF-32.  66% of the space is for (:) cells.
21:29:35 <dmwit> Axman6: Yes, but it gets worse: [] has an extra pointer for each cons cell, and Char has an extra pointer, period.
21:29:50 <avnerium> Hi, what is a good book to learn Haskell from? I started reading from haskellbook.com feel it's too slow (already familiar a bit with functional programming) - is there something faster or more challenging?
21:30:00 <dmwit> monochrom: (33%?)
21:30:15 <Axman6> So we're writing objects to disk now?
21:30:21 <shachaf> avnerium: Yes. Hutton's _Programming in Haskell_ is good.
21:30:38 <shachaf> That book seemed quite bad, last I saw content from it.
21:30:39 <monochrom> OK so I am also exploiting some internal thing GHC exploits. GHC runtime keeps a small flyweight table for commonly occuring characters.
21:30:48 <dmwit> avnerium: If you want to asymptotically approach light speed, try the Gentle Introduction.
21:31:19 <monochrom> So for example if you have "replicate 10000 'a'" you don't have 10000 copies of 'a's.  You just have 10000 (:) cells.
21:31:21 * glguy doesn't want to length contract that much
21:31:21 <avnerium> OK, thank you!
21:31:49 <dmwit> monochrom: Oh, good point.
21:31:59 <monochrom> Each cell is 3 words.  Now, I'm also exploiting that we are comparing what happens with what our expectation is.
21:32:22 <dmwit> I didn't know it did that with Char but it seems completely reasonable to.
21:32:28 <MarcelineVQ> avnerium: just out of curiosity what about your current book makes it feel slow?
21:33:28 <monochrom> What happens: 3*10000 words.  Expectation: "length is 10000 so I expect it to be fair to spend 10000 words". So flip it around, 2/3 (of what actually happens, the 3*10000 words) is spent on overhead
21:33:52 <monochrom> OK in retrospect that's pretty warped logic!
21:34:57 <avnerium> MarcelineVQ: I think it might be better for those who are really new to functional programming. For me I feel that some things are explained using too much text, and I also wish the exercises were harder
21:35:10 <monochrom> I should have heeded my own advice of just spilling out the math (e.g., 3*n words) instead of "intuitive" percentages geared towards dumb manager types.
21:35:14 <avnerium> right now I'm in chapter 6 (typeclasses)
21:35:45 <eich> exit
21:40:50 <fresheyeball> grr, no build with nix-build and ghcjs
21:41:05 <fresheyeball> it keeps trying to compile all manner or irrelevant junk
21:56:17 <Axman6> That's been my experience with nix always
21:56:33 <Axman6> Want some haskell stuff? Let's compile GHC 7.4!
21:58:29 <ski> @where gentle
21:58:29 <lambdabot> http://www.haskell.org/tutorial/
21:58:40 <ski> hm, they left
22:04:57 * ski . o O ( "Calculational Mathematics - Writings on the predicate, relational, and other calculi" by Edsger W. Dijkstra,Wim Feijen,Netty van Gasteren in 1990-11-08 (?) - 1996 summer (?) at <http://www.mathmeth.com/files/calc_collection.pdf>,(cf. <http://www.mathmeth.com/>) )
22:47:55 <Axman6> edwardk: Hey, I've been playing around with the discrimination package, and was wondering what a suitable Grouping instance for Text would look like - the obvious one is just using the instance for [a] and Char via unpack, but it feels like an inefficient way to do things
22:51:18 <Axman6> the other option I tried was using hashing, but it feels like the technique shouldn't need to read the whole Text before making a decision
22:51:40 <Axman6> I'd thought of using something like a suffix tree
22:59:34 <linyxus> hello
23:02:47 <Axman6> Hello linyxus
