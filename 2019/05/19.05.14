00:01:24 <bahamas> jusss: the parenthesis matter `runWriter (WriterV (a, w))`. you pass the value `WriterV (a, w)` to `runWriter` and it extracts `(a, w)`
00:01:53 <jusss> bahamas: aha, that's what I'm confusing
00:02:13 <jusss> bahamas: I misunderstood about the record syntax 
00:03:09 <Cale> e.g. you might also define a type like  data Employee = MkEmployee { name :: String, salary :: Integer }
00:03:18 <Cale> and then that will automatically define for you the functions
00:03:23 <Cale> name :: Employee -> String
00:03:30 <Cale> salary :: Employee -> Integer
00:03:34 <Cale> by writing
00:03:47 <Cale> name (Employee x _) = x
00:03:56 <Cale> salary (Employee _ x) = x
00:04:11 <Cale> oops, meant to write MkEmployee there :)
00:04:21 <Cale> (in the pattern matches)
00:04:32 <jusss> "data Writer w a = Writer { runWriter :: (a, w) }"  it means runWriter Writer (a, w) = (w, a) ,   not means runWriter Writer = (a, w)  right?
00:04:55 <Cale> uhhh
00:04:58 <Cale> neither?
00:05:07 <Cale> It means runWriter (Writer x) = x
00:05:23 <Cale> runWriter :: Writer w a -> (a,w)
00:05:41 <jusss> Cale: wait a sec, so what is the type  `data Writer w a = ? `
00:05:56 <Cale> I don't understand that question
00:06:33 <jusss> Cale: data Writer w a = Writer { runWriter :: (a, w) },  this is a data type definition, right?
00:06:40 <Cale> sure
00:06:45 <jusss> it define a type called Writer w a, right?
00:06:48 <Cale> yes
00:06:59 <jusss> and this Writer w a's value is ?
00:07:09 <Cale> and it also defines a data constructor  Writer :: (a,w) -> Writer w a
00:07:29 <Cale> (which is the primitive way of creating values of that type)
00:07:44 <Cale> and then it also defines a function  runWriter :: Writer w a -> (a,w)
00:08:04 <monochrom> Value "Writer (True, "abc")" has type "Writer String Bool".
00:08:06 <Cale> which simply pattern matches on the Writer data constructor and gives you back what it found
00:08:26 <Cale> We could write this without using record syntax
00:08:35 <Cale> data Writer w a = Writer (a,w)
00:08:44 <monochrom> I think you're really hung up on preserver the order "w first, a second".
00:08:45 <Cale> runWriter :: Writer w a -> (a,w)
00:08:53 <Cale> runWriter (Writer x) = x
00:09:06 <monochrom> s/preserver/preserving/
00:10:21 <monochrom> To break this yoke, consider data Foo a b c = MkFoo c Int a String b Bool c b (c -> a -> b -> a -> c)
00:10:24 <jusss> Cale: I don't understand this runWriter (Writer x) =x,  it suppose to be runWriter (Writer x y) = (y,x)
00:10:32 <Cale> huh?
00:10:42 <Cale> The Writer data constructor only has one argument
00:10:46 <Cale> which is a pair
00:10:59 <monochrom> No, it is supposed to be runWriter (Writer x) = x.  x happens to be a tuple.
00:11:05 <Cale> I think maybe you *are* confused about which is the type and which is the data constructor
00:11:11 <Cale> Let's name them different
00:11:15 <MarcelineVQ> go back to the Writer that uses different names on each side :>
00:11:16 <Cale> data Writer w a = W (a,w)
00:11:25 <Cale> runWriter (W x) = x
00:11:29 <bahamas> jusss: I think the fact that types and values have the same name confuses you. I was confused by this for a long time
00:12:03 <Cale> jusss: Does that make sense?
00:12:08 <jusss> Cale: but this runWriter(W ("3",3)) will get ("3",3) not (3,"3")
00:12:15 <Cale> yes
00:12:33 <Cale> Try it
00:12:38 <Cale> It absolutely will
00:12:40 <jusss> Cale: but in this data type it's Writer w a = W (a, w)
00:12:42 <monochrom> And we like it that way.
00:12:54 <jusss> the type variables swapped
00:13:03 <Cale> jusss: so?
00:13:20 <Cale> They also swap order in the type of runWriter
00:13:27 <Cale> runWriter :: Writer w a -> (a,w)
00:13:53 <jusss> Cale: but it doesn't swapped in the function definition
00:14:01 <Cale> It didn't have to
00:14:08 <monochrom> Wait til you run into "data State s a = MkState (s -> (a, s))".
00:14:10 <jusss> that's the question
00:14:14 <Cale> A value of type Writer w a contains a value of type (a,w)
00:14:23 <Cale> and we can just pull it out and hand it back
00:16:14 <jusss> Cale: data Writer w a = W (a, w)   what the related with W (w,a)
00:16:33 <Cale> We could use that variation if you prefer it
00:16:34 <monochrom> Unrelated.
00:16:39 <Cale> It obviously makes little difference
00:16:46 <Cale> But you shouldn't be confused either way
00:16:55 <Cale> We get out whatever type of pair we put in
00:18:58 <bahamas> I think jusss is asking what's the difference between `W (w, a)` and `W (a, w)`. jusss, the order matters if you define a Functor instance for that type, for example
00:19:03 <Cale> (I actually prefer that variation as well -- for various reasons, the last component of a tuple is the "main" one)
00:19:21 <Solonarv> monochrom: the swapped order in the tuple for State / Writer annoys me too
00:20:47 <jusss> data Writer w a = Writer { runWriter :: (a, w) }  it means  data Writer w a = Writer (a, w)    and   runWriter :: Writer w a -> (a, w)   , runWriter (Writer x) = x,  right?
00:21:18 <Cale> If I ever find sufficient reason to define a new monad library, I'll flip those pairs, and I'll also flip the arguments to all the run functions so they take the actions last, since in practice, that's what you want almost 100% of the time
00:21:38 <Cale> jusss: right
00:21:59 <Cale> jusss: also, the derived Show/Read instances will use record syntax
00:22:14 <Cale> but apart from that, they're the same
00:22:22 <monochrom> OK, but "data StateT s m a = MkStateT (s -> m (s, a))" contains the "substring" "... m ... s ... a ..." so sooner or later you have to learn to dissociate type parameter order from field order.
00:22:31 <jusss> Cale: and so what's the value of type (a,w)?
00:22:54 <Cale> jusss: in the definition of runWriter?  x
00:22:56 * ski sometimes writes manual `Show' and `Read' instances, just to avoid the record syntax
00:23:05 <jusss> Cale: I mean in the data type
00:23:27 <Cale> jusss: Oh, what does it mean? It's the "result" and "written value" of the action.
00:24:20 <Cale> We're going to think of values of type Writer w a as being like "programs which may write values of type w which are appended together, before producing a result of type a"
00:24:57 <Cale> The (>>=) operation is going to concatenate together the written values:
00:26:08 <Cale> x >>= f = Writer $ let (v,w) = runWriter x; (v',w') = runWriter (f v) in (v', w <> w')
00:26:47 <Cale> i.e. x >>= f will be the action which first runs x, getting some result v, and written value w
00:27:14 <Cale> and then runs (f v), getting some result v', and additional written stuff w'
00:27:27 <Cale> and its result will be v', and it will have written w <> w'
00:27:45 <Cale> Here, <> is the Monoid operation, also called mappend
00:28:35 <Cale> return v = Writer (v, mempty)
00:29:00 <Cale> will be the action which produces v as its result, "without writing anything" i.e. its written value is the identity of the monoid
00:29:24 <Cale> and in addition to the Monad operations, we very importantly have
00:29:40 <Cale> tell w = Writer ((), w)
00:30:00 <Cale> tell :: w -> Writer w ()
00:30:30 <Cale> given some w, produces the action which writes that value, producing an empty tuple as its result
00:30:59 <Cale> There are also some other operations, but these are the main ones you'll probably run into
00:31:27 <Cale> > runWriter (do tell [1]; tell [2]; tell [3]; return "hello")
00:31:29 <lambdabot>  ("hello",[1,2,3])
00:34:17 <Cale> jusss: Does that all make sense?
00:35:00 <Cale> jusss: The idea is that we've implemented a kind of tiny programming language with only writing effects, and no longer need to use the Writer data constructor directly to use it.
00:37:01 <zincy> So the wrapped type in a writer is always a Monoid
00:37:19 <zincy> Reader doesn't have such a restriction
00:37:36 <f-a> I would like to move the executable I am building from ./dist-newstyle/build/ to , say, ./bin. Is a custom setup the correct way to achieve this?
00:37:37 <Cale> zincy: The 'w' type is, yeah, at least if you want to have a Monad or Applicative instance (and you do)
00:38:14 <zincy> Cale: So do Reader and Writer just have different directionalities?
00:39:40 <zincy> Directionality as in scope. As in with Writer you can update a global value and this will propagate across all scopes. Whereas Reader has local and you can only ever update the global in the inner scopes?
00:40:07 <Cale> zincy: hmm... well, it might help in some way to know that there's a corresponding comonad (->) w when w is a monoid, and a comonad (,) e which doesn't require e to be a monoid
00:40:25 <zincy> What is a comonad
00:40:58 <Cale> So, with Monad, we have return :: a -> m a, and  join :: m (m a) -> m a, right?
00:41:07 <zincy> Yeah
00:41:25 <Cale> Comonad goes the other way, providing
00:41:47 <Cale> extract :: w a -> a and duplicate :: w a -> w (w a)
00:42:02 <zincy> Oh that easy huh
00:42:05 <zincy> :)
00:42:26 <Cale> (and it's required to be a Functor as well)
00:42:41 <zincy> so can I do   return . extract . return 
00:42:52 <Cale> If something was both a monad and comonad, yeah
00:43:09 <jusss> Cale: sorry, I was just thinking your words about runWriter (Writer x) = x, and I think I get it now
00:43:16 <zincy> I wonder what kinds of things Comonads lets you do
00:43:17 <Cale> jusss: cool
00:43:43 <Cale> zincy: Well, one thing is various "cellular automaton like" things
00:43:56 <Cale> That comonad of functions out of a monoid I mentioned
00:43:57 <zincy> Game of life?
00:44:01 <Cale> yeah
00:44:06 <jusss> Cale: Writer ("3", 3) :: Writer Int String, right?
00:44:11 <Cale> If we pick the monoid to be pairs of integers under addition
00:44:59 <Cale> then functions out of that monoid, perhaps to Bool say, are like cellular automaton states
00:45:29 <Cale> for that comonad, we have  duplicate f x y = f (x <> y)
00:45:35 <zincy> So a Comonad is useful here because we want to group lots of little interactions between cells into bigger actions?
00:45:36 <Cale> and  extract f = f mempty
00:46:02 <Cale> duplicate will basically produce a "grid of all possible translations of the grid"
00:46:26 <Cale> and then we can implement our cellular automaton logic by fmapping over that a function which just looks near the origin
00:46:28 <zincy> What is a "translation"
00:46:39 <Cale> I mean like sliding the values by some amount
00:47:18 <Cale> jusss: With the convention we were using, yeah
00:48:12 <Cale> zincy: Imagine (for convenience, I don't want to define a new type) that (Int, Int) has the monoid instance where we add the pairs componentwise
00:48:29 <Cale> Then functions (Int, Int) -> Bool are like our game of life states
00:48:52 <zincy> Right because without the Comonad you would have to pattern match and construct a value of your (Int, Int) a lot
00:49:14 <zincy> I think I can visualise it
00:49:28 <Cale> and  duplicate f (x,y) = \(x',y') -> f (x + x', y + y')
00:50:03 <zincy> You extract the value of each cell, slide its value and then put the cell value back into the monadic context
00:50:12 <Cale> no monad
00:50:12 <zincy> then this is just one operation you call <$> on
00:50:43 <zincy> If I replace the term monadic with comonadic is that statement fair
00:51:04 <Cale> duplicate f :: (Int, Int) -> ((Int, Int) -> Bool)
00:51:19 <Cale> which is like a grid, and at each position, there's another grid
00:51:52 <zincy> What is Bool for?
00:52:05 <Cale> Well, because game of life cells are either on or off
00:52:24 <Cale> And what grid is going to be at position (x,y)? Well, its value at the origin is the value of the original grid at (x,y)
00:52:44 <zincy> Oh I thought cells had continuous values doh
00:52:48 <Cale> so it's like we've shifted the original grid to make (x,y) the origin
00:52:57 <Cale> and we've done this for each possible x and y
00:53:05 <Cale> making a grid of grids
00:53:15 <Cale> that's what the "duplicate" for this comonad does
00:53:19 <zincy> ah gotcha
00:53:46 <Cale> and that's convenient because that means we only need to work out how to evaluate the next step for the cellular automaton at the origin
00:53:59 <Cale> and then fmap that function over (duplicate f)
00:54:17 <zincy> https://chrispenner.ca/posts/conways-game-of-life
00:54:42 <Cale> http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
00:54:48 <zincy> I might implement this to learn comonads
00:55:06 <Cale> (though I'm pretty sure the later one adds a bunch of practicality)
00:55:27 <Cale> Representable will help make this actually practical
00:56:21 <Cale> Another use for this comonad I came up with is...
00:56:34 <Cale> http://hackage.haskell.org/package/category-printf
00:56:53 <Cale> (but it's a much different and more mundane way of thinking about it)
00:57:27 <zincy> Typesafe C like string formatted printing?
00:58:03 <Cale> yeah, though your format specifiers are not themselves strings, so it's not completely C-like
00:58:23 <Cale> http://hackage.haskell.org/package/category-printf-0.1.1.0/docs/Control-Category-Printf.html
00:59:57 <Cale> Basically, I watched a talk by Dan Patterson at NYHUG where he explained a method for typesafe printf where he was manipulating continuation-passing style functions of type (String -> a) -> b all the time
01:00:21 <zincy> Are Cokleisli Arrows analagous to normal kleisli arrows but they work on extract?
01:00:35 <Cale> and at one point he defined a function (%) :: ((String -> b) -> c) -> ((String -> a) -> b) -> ((String -> a) -> c)
01:00:48 <zincy> What is continuation-passing-style? Callbacks?
01:00:50 <Cale> and I thought "that's got to be the composition for some category..."
01:00:55 <Cale> yeah, basically
01:01:40 <zincy> Yeah each argument type signature has a very similar structure
01:01:42 <Cale> Where you're always taking functions to which your own result will be passed
01:04:29 <Cale> So, yeah, Cokleisli is like Kleisli, but whereas Kleisli composition (<=<) :: (b -> m c) -> (a -> m c) -> (a -> m c) works by (f <=< g) x = f =<< g x = join (fmap f (g x))
01:04:56 <Cale> we have (=<=) :: (w b -> c) -> (w a -> b) -> (w a -> c)
01:06:09 <Cale> and it's  (f =<= g) x = f (g <<= x) = f (fmap g (duplicate x))
01:06:59 <Cale> Everything is just uniformly backwards :)
01:10:03 <Cale> But the nice thing is that I didn't even have to understand the inner workings of the composition in order to write my library
01:10:56 <Cale> I sort of knew already what the composition would do
01:11:07 <Cale> It was going to compose formatting specifiers
01:11:24 <Cale> and the type of the formatting specifier sort of tells you how the type of printf itself is going to change
01:11:40 <zincy> cool!
01:12:18 <Cale> I have a shorthand there  type Format m = Cokleisli ((->) m)
01:12:28 <Cale> just because the latter isn't very ergonomic to type all the time
01:13:04 <Cale> and there's a Category instance for Cokleisli which lets us use the generalised (.) to compose these formatters
01:13:18 <zincy> what is a Category instance
01:13:27 <Cale> class Category c where
01:13:43 <Cale>   id :: c a a
01:14:01 <Cale>   (.) :: c v w -> c u v -> c u w
01:14:25 <Cale> http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Category.html
01:15:00 <Cale> So, hilariously, putting format specifiers together is going to look like string concatenation in PHP
01:15:12 <zincy> haha
01:15:53 <Cale> Have a look at 's'
01:15:59 <Cale> s :: (Monoid s, IsString s, Show t) => Format s a (t -> a) 
01:16:10 <zincy> Can I make monad transformers into a Category?
01:16:18 <Cale> apart from the extra generality, the idea is that we're formatting a string of type s here
01:16:42 <Cale> and this formatter splices in anything which has a Show instance
01:16:46 <delYsid``> "(.) :: c p q -> c o p -> c o q" :-)
01:16:53 <Cale> and its type there  Format s a (t -> a)
01:17:10 <Cale> basically says that if printf had the type a before, when you use this, it will get the type t -> a
01:17:20 <Cale> i.e. we need to provide an additional argument of type t
01:18:04 <Cale> zincy: You could make them into a category, but not a Category
01:18:11 <Cale> zincy: since they're at the type level
01:18:47 <zincy> types are the only things which can be made instances of typeclasses though
01:18:58 <Cale> Well, then, not directly
01:18:59 <zincy> category isn't a typeclass is it?
01:19:18 <Cale> no, I mean, composition of monad transformers is a thing
01:19:34 <Cale> but it's type-level composition in Haskell
01:19:42 <zincy> oh
01:19:54 <Cale> Monad transformers are arrows in a category whose objects are monads
01:20:01 <zincy> What is the most basic example of type composition?
01:20:12 <Cale> Well, we have
01:20:28 <Cale> newtype Compose f g x = Compose { getCompose :: f (g x) }
01:20:33 <zincy> I am wondering if type composition is a term which just refers to using multiple existing types to form a new one?
01:20:58 <Cale> I mean, exactly the same thing as function composition, but for type level functions
01:21:17 <Cale> Monad transformers are type level functions whose kind is (* -> *) -> (* -> *)
01:21:33 <Cale> and we can compose them together to get another monad transformer
01:22:16 <Cale> I don't know if anyone's written that instance...
01:22:39 <zincy> So is the composition of monad transformers not really something which is done but is possible
01:23:03 <Cale> I mean, we sort of do it all the time, by applying many monad transformers one after another when building up the monad we're interested in
01:23:31 <Cale> and sometimes we defining a monad transformer by newtyping what is effectively the composite of some others
01:23:35 <Cale> define*
01:24:16 <zincy> So does that count as composition?
01:24:17 <Cale> newtype QueryT t q m a = QueryT { unQueryT :: StateT [Behavior t q] (EventWriterT t q (ReaderT (Dynamic t (QueryResult q)) m)) a }
01:24:22 <Cale> ^^ from reflex ;)
01:24:36 <maerwald> not pretty
01:24:39 <Cale> You can ignore the details
01:24:54 <Cale> The point is that it's a composite of a StateT, an EventWriterT and a ReaderT
01:25:00 <Cale> with some parameters supplied
01:25:01 <zincy> f g = f g 
01:25:13 <zincy> would be a function which takes one argument
01:25:23 <zincy> and would be equivalent to f . g right?
01:25:26 <Cale> no
01:25:35 <Cale> (f . g) x = f (g x)
01:25:44 <Cale> Or
01:25:48 <Cale> (f . g) = \x -> f (g x)
01:25:51 <Cale> if you prefer
01:25:58 <zincy> The x was just implicit in mine :)
01:26:04 <Cale> it wasn't though
01:26:23 <zincy> Would it have worked with an explicit type signature which defined x?
01:26:25 <Cale> This isn't the same as (f . g) x = f g x
01:26:53 <zincy> Oh of course
01:27:09 <zincy> composition gives you a new thing of the type of the things you composed
01:27:14 <Cale> yeah
01:27:17 <Cale> roughly :)
01:27:21 <Cale> :t (.)
01:27:22 <lambdabot> (b -> c) -> (a -> b) -> a -> c
01:27:32 <zincy> so composition doesn't just apply to functions
01:27:41 <Cale> Right, that's the idea of category theory
01:28:10 <ski> CT is an "abstract theory of functions with compositions"
01:28:18 <Cale> That all throughout mathematics, we're never content to study objects in isolation. Instead, we study entire classes of related objects.
01:28:47 <zincy> ski: What is T?
01:28:48 <Cale> and we study various structure-preserving mappings, or relationships, or analogies-of-some-fashion between them
01:29:20 <Cale> CT = Category Theory
01:29:32 <ski> instead of just studying concrete vector spaces, like `n'-dimensional Euclidean space, we allow any set of "vectors" (whatevers, we just call them vectors), that support addition and scaling, to be a "vector space"
01:29:50 <zincy> Oh looked like (T with my font
01:30:26 <Cale> Well, the important thing is that we're not just studying vector spaces, but also the linear transformations which go between those
01:30:30 <zincy> So you abstract away dimensionality
01:30:48 <zincy> well not dimensionality but instances of it
01:30:56 <ski> same with group theory. instead of merely studying geometric transformations, which form a group under composition, and also studying permutation groups. we say that a "group" is any set of things which has a binary operation satifying a bunch of laws
01:31:14 <Cale> Well, that's... one level of it
01:31:40 <Cale> But the thing I really want to get at is the abstraction that has to do with category theory, which is that we don't stop at just defining groups
01:31:48 <Cale> but we talk about group homomorphisms
01:32:01 <ski> yes, "structure-preserving mappings" is a really important concepts. for vector spaces, these are called linear transformations. in the "ordinary finite-dimensional case", these would correspond to matrices (given a selection of bases)
01:32:02 <zincy> equivalence of shapes of groups?
01:32:23 <Cale> zincy: Are you familiar with what a group is?
01:32:34 <zincy> Is rotating a matrice a linear transformation?
01:32:36 <ski> and for groups, we have group homomorphisms. for rings, we have ring homomorphisms. .. for topological spaces, we have continuous functions. &c.
01:32:44 <zincy> Cale: Not yet :P
01:32:48 <Cale> Ah, okay
01:33:09 <Cale> Well, you already know about monoids :)
01:33:15 <ski> a matrix expressing rotation (say of the plane around a selected origin point) corresponds directly to a linear transformation
01:33:26 <Cale> A group is a monoid in which every element has an inverse
01:33:39 <zincy> Cale: haha but do I really "know" about monoids :D
01:33:43 <Cale> For example, integers under addition form a group
01:34:15 <Cale> because for every integer, we have its negative, and when you add those, they give you the identity
01:34:27 <Cale> i.e. we have "inverses" for addition
01:34:34 <zincy> So that relationship is what preserves structure?
01:34:39 <ski> if `M' is the rotation matrix, and `v' is any vector, and `M*v' is the "rotated vector", then if you define `f(v) = M*v', then `f' is the corresponding linear transformation
01:34:40 <Cale> No
01:35:23 <zincy> ski: I think I get it
01:35:42 <Cale> Given two groups G and H, a group *homomorphism* is a function f: G -> H for which f sends the identity of G to the identity of H, and f sends x*y in G to f(x) * f(y) in H
01:35:53 <Cale> i.e. it "preserves" the unit and multiplication
01:36:03 <Cale> (and we can show it also preserves inverses from this)
01:36:52 <zincy> How can a group have an identity?
01:36:57 <zincy> Is it the identity function?
01:37:05 <Cale> It's the identity element
01:37:15 <Cale> I should have done a better job of the definition I suppose
01:37:30 <zincy> Ok so 1 for multiplication and 0 for addition
01:37:33 <zincy> of integers
01:37:43 <zincy> Are they separate groups?
01:37:46 <ski>   f(x *_G y) = f(x) *_H f(y)  -- the group homomorphism `f' preserves the `*' operation of groups
01:37:47 <Cale> yeah, if we're adding integers, the identity is 0
01:38:01 <ski> zincy : yes
01:38:18 <Cale> zincy: When we're speaking abstractly, we tend to say "multiplication"
01:38:19 <zincy> ah so a Group is a structure preserving mapping
01:38:23 <ski> no
01:38:34 <Cale> zincy: even though "addition" is a perfectly good definition of how "multiplication" works a lot of the time
01:38:44 <zincy> but addition is a structure preserving mapping no?
01:38:56 <Cale> no and yes (but we haven't said anything about that, so no)
01:39:03 <ski> conceptually, groups come first, (group) structure preserving map, aka homomorphism, comes second
01:39:24 <zincy> so structure preserving maps are homomorphisms
01:39:36 <ski> first you need to pick two groups, `G' and `H'. then you can start to think about what a group homomorphism `f' from `G' to `H' is. written
01:39:41 <ski>   f : G >---> H
01:39:43 <Cale> "structure preserving map" and "homomorphism" are effectively synonyms
01:39:47 <zincy> ok
01:40:07 <ski> a group is "a set, with group structure"
01:40:35 <zincy> so a group homomorphism is a function which is given the identity element of one group and returned the identity element of the the other?
01:40:36 <ski> a group homomorphism between two groups (from one, to the other), is "a function between the corresponding two sets, preserving the group structure"
01:40:47 <Cale> zincy: That's half the definition
01:41:02 <ski> (or a third, depending on how you count ..)
01:41:18 <Cale> zincy: But it's also got to be the case that applying the function to a product will result in the product of applying the function to each of the factors
01:41:28 <Cale> for whichever notions of multiplication the two groups have
01:41:59 * ski tends to prefer the universal algebra perspective, rather than the too group-centric (too accomodating to "particular accidents of how groups works") view
01:42:33 <Cale> i.e. If our two groups are (G,*,1) and (H,#,e), then f: G -> H is a function such that f(1) = e, and for all x and y in G, we have f(x*y) = f(x) # f(y)
01:42:41 <zincy> Trying to understand "a function between the corresponding two sets, preserving the group structure" 
01:42:48 <zincy> there are two groups there no?
01:42:59 <zincy> a group is comprised of one set?
01:43:16 <Cale> Let's look at some examples of groups
01:43:16 <ski> a group has three operations : (a) you can combine two elements of the group; (b) there is a neutral element, aka identity or unit element; (c) each element has a corresponding inverse element
01:43:32 <Cale> apart from the integers and addition :)
01:43:45 <zincy> yep
01:43:54 <Cale> We also have the invertible real-valued matrices, and matrix multiplication
01:43:55 <ski> a group consists of (A) one set; (B) particular selections of the three group operations, on that set; (C) proofs that the operations satisfy the group laws
01:44:13 <Cale> or really tiny ones like the set {0,1} and addition modulo 2
01:44:33 <Cale> In general, addition modulo some number gives a group
01:44:35 <zincy> How can you have a selection of group operations?
01:44:50 <ski> (the smallest group has exactly one element. the "multiplication" table for it is obvious, as is the selection of the neutral element, and the inverse for each element)
01:45:10 <Cale> Or given some set S, we can look at all the invertible functions S -> S, and take multiplication to be composition
01:45:32 <ski> zincy : if the set is `S', then you pick any function `mult : D *
01:45:40 <Cale> zincy: ski means multiplication, identity and inverse
01:46:03 <Cale> zincy: When we define a group, we get to pick what these things are
01:46:08 <ski> zincy : if the set is `S', then you pick any function `mult : S * S >---> S', you pick any element `neut : S', and any function `inv : S >---> S'. subject only to the requirement that the group laws hold for those
01:46:38 <ski> zincy : so, for a particular set, there can potentially be many different ways in which to pick particular selections for the operations
01:46:42 <Cale> btw, using >---> is kind of confusing, because that tail sometimes means "injective"
01:47:04 <Cale> (zincy wouldn't be familiar with that notation, but still ;)
01:47:13 <zincy> hmm
01:47:18 <ski> zincy : consider the type `Integer'. it can be made a monoid in (at least) two different important ways. in Haskell, we write these as `Sum Integer', and `Product Integer'
01:47:27 <zincy> So a subset of the group is still within the group
01:47:32 <ski> (a monoid is just a group which we don't require an inverse operation for)
01:47:59 <zincy> I keep thinking in types of elements
01:48:10 <zincy> but groups are focused on operations perhaps
01:48:29 <ski> the set provides all the elements
01:48:39 <ski> the operations operate on the elements in the set
01:49:15 <zincy> so anything that satisfies the laws and operations can be in the set which forms the group
01:49:15 <ski> the neutral element can be thought roughly as "a function of no argument which simply picks out some particular element"
01:49:21 <ski> zincy : exactly !
01:49:27 <Cale> zincy: Here's another group: Consider all the functions R^2 -> R^2 which preserve distances, i.e. this includes all translations, rotations, and reflections
01:49:42 <Cale> zincy: We can think about those functions and composing them together
01:49:54 <Cale> and the identity function is such a function
01:50:18 <ski> that's the key abstraction idea that we use, over and over again, when going from particular mathematical "systems", like e.g. real numbers with addition and multiplication. or euclidean geometry with distance and so on ..
01:50:25 <Cale> and if we apply any such function, well, perhaps this is not entirely obvious, but it's invertible
01:50:46 <zincy> So Group theory is focused on studying the form of operations that particular sets of elements support
01:51:11 <ski> we investigate a system, including some concrete operations on it, and identify some interesting laws. and we start to notice similarities between different systems
01:51:14 <Cale> Group theory is *really* focused on studying the symmetries of objects, abstractly
01:51:20 <zincy> Is the R a real number in - R^2
01:51:30 <ski> no
01:51:30 <Cale> yeah, R is the set of real numbers
01:51:34 <ski> it's the set of all real numbers
01:51:37 <zincy> what is the context of the use of symmetry?
01:51:54 <Cale> Consider some geometric shape
01:51:56 <zincy> symmetrical in laws and operations
01:52:06 <Cale> any shape at all (but it helps if you pick a symmetrical one)
01:52:13 <zincy> a circle
01:52:26 <Cale> and consider the functions which send that shape to itself, preserving distances
01:52:39 <zincy> rotation
01:52:53 <ski> `R^2' is `R*R' is the cartesian product of the set `R' with itself. this is just the set of all pairs of elements, both taken from the set `R'. we write `R^2 = {(x,y) | x : R , y : R}' -- the set of all pairs `(x,y)' with `x' and `y' being real numbers
01:52:54 <zincy> flipping
01:52:54 <Cale> rotation, and then given the way I described it, we can also reflect the circle
01:52:57 <Cale> yep
01:53:14 <Cale> So there is a group consisting of all the rotations and reflections of the circle
01:53:22 <Cale> if we compose any two of those, we'll get another one
01:53:43 <zincy> that is awesome
01:53:46 <Cale> and the identity, which just leaves the circle alone is one of them
01:54:02 <Cale> So group theory abstractly studies "what kinds of symmetries can things have?"
01:54:22 <zincy> it sounds like category theory would be useful for computer graphics
01:54:42 <ski> the identity is the "rotate zero degrees (or radians, if you prefer)" transformation
01:54:44 <zincy> sorry group theory
01:55:01 <Cale> In the most general way, where instead of saying we have symmetries that we're composing, we're just going to say we have a set of things, and some "multiplication"
01:55:45 <Cale> and there has to be an identity thing for that multiplication, multiplication has to be associative (like composition of functions was), and there must be inverses, because symmetries don't smush things irretrievably
01:56:12 <Cale> and that's all we're going to assume
01:56:37 <ski> (in Haskell, if `R' is to be modelled by the type `Double', then `R^2', aka `R * R', would be the type `(Double,Double)' (unfortunately this is using the same syntax as that for pairs ..). or you could define a new type, like `data R2 = MkR2 R R', if you prefer)
01:57:03 <ski> (er, `data R2 = MkR2 Double Double', i meant)
01:57:31 <Cale> Now, think again about the group we described for the circle, and think about the similar group of distance-preserving transformations of the whole plane
01:58:10 <zincy> ski: so you are keeping it as a pair to operate on the elements individually?
01:58:17 <Cale> Every transformation we applied to the circle can be thought of as corresponding to some motion of the entire plane, yeah?
01:58:45 <zincy> Cale: Are they equivalent?
01:58:53 <Cale> Well, they're not exactly the same thing
01:59:03 <zincy> They have the same effect?
01:59:09 <Cale> For instance, our motions of the circle might only even be defined on the circle itself
01:59:20 <Cale> and not defined for other points in the plane
01:59:50 <Cale> But there is a correspondence between the distance-preserving functions on the circle, and *certain* distance preserving functions on the plane
02:00:33 <zincy> The same relationships hold for a sphere in 3d space right?
02:00:56 <Cale> Yeah, for a sphere in 3D space and 3D space itself
02:01:10 <ski> zincy : a cartesian product of two sets *is* the set of all possible pairs with first component from the first set, and second component from the second set
02:02:07 <zincy> ski: I didn't realise that a cartesian product results in a new set
02:03:19 <zincy> How do I go about applying this to Haskell
02:03:20 <ski> possibly the most basic constructions for forming new sets out of old are : disjoint union, cartesian product, function set (aka exponential)
02:03:35 <Taneb> zincy: (Int, Char) is a different type to Int and to Bool, right?
02:03:43 <zincy> Taneb: yeah
02:03:47 <Taneb> It's the cartesian product of Int and Char
02:04:06 <zincy> Same cardinality
02:04:16 <ski> if two two sets/types are `A' and `B', those would be represented in Haskell as `Either A B',`(A,B)',`A -> B'. in more mathy notation, we'd often write `A + B',`A * B',`B ^ A' (note the order !)
02:04:17 <Taneb> Same thing
02:04:35 <zincy> So is cartesian product the union
02:04:39 <ski> no
02:04:55 <Taneb> Cartesian product is the pair
02:05:09 <Taneb> (well, set of pairs)
02:05:16 <Cale> zincy: So anyway, we've gone quite a ways afield here, but the point I was going to make is that group homomorphisms can explain those relationships
02:05:24 <ski> if `A' is a type/set with `m' elements, and `B' is a type/set with `n' elements, then `Either A B'/`A + B' is a type/set with `m + n' elements
02:05:41 <ski> and `(A,B)'/`A * B' is a type/set with `m * n' elements
02:05:47 <Cale> zincy: the ways that the symmetries of a circle correspond to symmetries of a sphere or the plane
02:05:57 <ski> and `A -> B'/`B ^ A' is a type/set with `n ^ m' elements
02:06:46 <ski> this is the rationale for using the symbols `+',`*',`^' here, when forming these new sets/types. and is the rationale for using the terms "product" and "exponential"
02:06:51 <Cale> zincy: or something more abstract, like the ways that all these geometric transformations we've been discussing correspond to certain types of matrices, and composition to matrix multiplication
02:06:57 <ski> the "disjoint union" is also called the "sum"
02:07:12 <zincy> ski: That is the algebra in ADTs huh
02:07:17 <ski> yes
02:07:24 <ski> part of it, at least
02:07:39 <ski> (there's also another sense of "algebra" that is relevant there)
02:08:23 <zincy> Cale: So what is the group in "group homomorphism"
02:09:10 <ski> depends on which two groups you pick as source and target, as domain and codomain, as argument and result type
02:09:46 <zincy> so it is getting at the notion of symmetry
02:09:53 <zincy> il.e you can go back
02:09:55 <ski> consider the group `|R' of all real numbers, with addition as the group operation
02:10:13 <ski> and also the group `|R_+' of all positive real numbers, with multiplication as the group operation
02:10:33 <zincy> ok now i see
02:11:13 * Cale hopes that ski is about to mention logarithms or exponential functions
02:11:16 <ski> then take the function `f' defined by `f(x) = 2^x', e.g. .. this is a group homomorphism from this `|R' group to the other `|R_+' group, because `2^(x + y) = 2^x * 2^y'
02:11:22 <Cale> yay
02:12:05 <ski> (of course you can take any other positive real number, apart from `1', as the base, in place of `2')
02:12:26 <ski> if we want to be more explicit, we could write
02:13:00 <ski>   f : (|R,(+),0,negate) >---> (|R_+,(*),1,recip)
02:13:24 <zincy> that looks like the category composition arrow
02:13:40 <zincy> >>>> 
02:14:22 <ski> here `(|R,(+),0,negate)' is the one group (the source / domain / argument/input type, of the group homomorphism `f'), consisting of the set `|R', and the operations `(+)',`0',`negate' .. and ditto for the other group (the target / codomain / output/result type, of the group homomorphism `f')
02:15:11 <ski> yes, i tend to write an arrow like `>--->', when talking about morphisms in a category. many other people would just use an `--->' arrow (and reserve `>--->' for something more restricted)
02:15:44 <zincy> so a morphism is a structure preserving mapping
02:15:56 <zincy> structure being group
02:16:22 <ski> however, often the context makes it reasonably clear which operations we intended for the group, and so we say "the group `|R'" and "the group `|R_+'", when really, in the above view, those are only the set parts/components of the group
02:16:36 <zincy> `f(x) = 2^x' is a morphism because it goes between homomorphic groups?
02:16:41 <ski> in this case, the morphisms are group homomorphisms, yes
02:17:18 <ski> *homo*morphisms are structure preserving mappings/maps/functions/transformations
02:17:36 <ski> "group" is one particular kind of "structure". another is "monoid"
02:17:41 <Cale> So, yeah, go up one level now, and we have these things called groups, and these mappings between them called homomorphisms. Composing any two homomorphisms gets us a homomorphism. The identity function from a group to itself is a homomorphism. What if we blurred our eyes some and forgot all about the details of everything that's going on here, and just started studying things which abstractly looked like that?
02:17:52 <Cale> i.e. we have some collection of "objects"
02:17:56 <ski> zincy : "homomorphic groups" sounds like nonsense here
02:17:58 <Cale> and some "arrows" going between them
02:18:27 <zincy> ski: so operations are homomorphic not groups?
02:18:42 <zincy> maybe I am thinking of isomorphisms
02:18:45 <ski> there is a framework called "universal algebra", which deals with homomorphisms. instead of e.g. the group operations, you could imagine any specification of operations, and any specification of laws for them
02:18:46 <Cale> zincy: If anything, groups are homomorphic because there is a homomorphism of groups between them, but "homomorphic" isn't a very common concept to think about
02:19:33 <Cale> There's a homomorphism between any two groups, which sends every element of one group to the identity element of the other, for one
02:19:36 <ski> "category theory" is an even more general framework, which encompasses "universal algebra" (which uses the term "homomorphism"). CT uses the term "morphism", or "arrow"
02:20:05 <ski> (one could say that "not all structure is algebraic structure", perhaps)
02:20:06 <Cale> There is a notion of isomorphism of groups
02:20:25 <ski> an isomorphism is a particular kind of morphism. roughly, an "invertible morphism"
02:20:28 <Cale> which we can (and should perhaps) get to quite hastily if we know what homomorphisms are
02:21:09 <ski> (there are also some other particular, generally useful, notions of particular kinds of morphisms. e.g. monomorphism, epimorphism)
02:21:23 <Cale> An isomorphism a: G -> H is a homomorphism for which there's some homomorphism b: H -> G such that a . b = id and b . a = id
02:21:40 <zincy> so a homomorphism is a functiion which takes us from the identity element of one group to another's
02:21:46 <Cale> Note that this definition didn't actually require anything about groups
02:22:01 <Cale> The definition of isomorphism only requires that we know what our homomorphisms are
02:22:02 <ski> (s/homomorphism/morphism/)
02:22:37 <Cale> So, when we move to category theory, it's something which we can define in an arbitrary category
02:23:00 <Cale> also: in any category, we can consider the set of all isomorphisms of an object to itself
02:23:10 <Cale> this will always be a group under composition!
02:23:11 <ski> zincy : "a homomorphism is a functiion which takes us from" each operation of one algebraic structure, to the corresponding operation of another algebraic structure of the same kind .. roughly
02:23:29 <Cale> and now I've provided the true motivation for studying group theory
02:23:51 <ski> if we have a homomorphism of groups
02:23:55 <Cale> Because for every type of object in mathematics, we never study them in isolation, we study categories of things -- objects together with mappings between them
02:24:20 <Cale> and once we have a category of things, we can look at the invertible relationships that a thing has with itself
02:24:24 <zincy> so categories are groups of groups?
02:24:25 <Cale> and those will always form a group
02:24:41 <ski>   f : (G,(*_G),1_G,(1/_G)) >---> (H,(*_H),1_H,(1/_H))
02:24:51 <ski> then `f' being a homomorphism means that we're requiring
02:24:52 <Cale> Every object of every category has an "automorphism group"
02:25:27 <Cale> i.e. given an object X in some category, we can consider the isomorphisms X -> X
02:25:31 <ski>   f (x *_G y)   =   f x  *_H  f y    -- for all `x',`y' in `G'
02:25:36 <Cale> i.e. those arrows X -> X which have inverses
02:25:42 <ski>   f 1_G   =   1_H
02:25:51 <zincy> Would automorphisms encompass all our rotate the circle, sphere etc operations
02:25:57 <ski>   f (1/_G x)   =   1/_H  f x    -- for all `x' in `G'
02:26:02 <Cale> In the category of sets, the automorphisms of a set are just all the invertible functions
02:26:18 <Cale> In the category of metric spaces, the automorphisms of a metric space would be the distance-preserving functions
02:26:19 <zincy> Is the operation to flip a circle an invertible function?
02:26:25 <Cale> yes
02:26:40 <ski> because the group structure specifies three operations, we get three corresponding "preservation" equations that a homomorphism must satisfy
02:26:42 <zincy> metric spaces not heard that term before
02:26:59 <Cale> Yeah, they're just sets with a distance function saying how far apart any pair of points is
02:27:09 <Cale> which has to satisfy a few conditions
02:27:33 * ski idly wonders whether we should move to #haskell-overflow, as this is currently more about math than Haskell ..
02:27:57 <Cale> We could, but it's the middle of the night in NA, and I don't think anyone cares at the moment ;)
02:28:19 <ski> yea, i haven't seen anyone else ask a more on-topic question, yet
02:28:23 <Cale> Specifically, https://en.wikipedia.org/wiki/Metric_space#Definition these conditions
02:29:21 <ski> (although, sometimes people might perhaps get scared about abstract stuff like this, perhaps not wanting to barge in with their more mundane issue, in a discussion like this ..)
02:29:22 <zincy> metric is just a notion of distance
02:29:28 <ski> yes
02:29:39 <ski> satisfying some reasonable axioms
02:29:45 <ski> (axioms/laws)
02:30:46 <zincy> It is funny that categories are groups of groups and therefore just a group
02:31:00 <Cale> I wouldn't say "groups of groups" as such
02:31:12 <zincy> categories of groups?
02:31:23 <zincy> since they are not necessarily related
02:31:25 <Cale> Every category has a group associated to each of its objects
02:32:09 <zincy> Why can't an object live outside a group
02:32:22 <Cale> it... does? kinda/
02:32:55 <ski> (a) categories can be seen as generalizations of the concept of monoids .. but also of the concept of preorders; but (b) there's also a category of all monoids, and a category of all preorders
02:32:58 <zincy> so object /= element 
02:33:36 <Cale> You start with the category, it consists of some specified collection of objects, together with some specified arrows between them (possibly many arrows between any ordered pair of objects), and then some specified means of composing those arrows, which is associative, and there are identity arrows
02:33:52 <Cale> So it's a bit like a monoid, but you're only allowed to compose arrows which line up head to tail
02:33:54 <ski> (a) is saying that each monoid (and hence each group, since each group is a monoid) can be regarded as a category. also each preorder (and hence each partial order, and each total order, since total orders are partial orders, and partial orders are preorders) can be regarded as a category
02:34:24 <Cale> zincy: In the case of the category of groups, our objects were groups, and our arrows were group homomorphisms
02:34:30 <Cale> There's a category of sets and functions
02:34:43 <Cale> There's a category of metric spaces and distance-shortening maps
02:35:09 <ski> but (b) is different. instead of having a single monoid (e.g. a group) that is a category, we have a category of *all* monoids (including all groups). and similarly with a category of all preorders, instead of considering a particular category that *is* some preorder
02:35:16 <zincy> oh so groups themselves are just one of many categories
02:35:22 <Cale> zincy: Yes
02:35:29 <ski> groups are monoids are categories
02:35:42 <ski> the category of all groups, `Group', is a different category
02:35:44 <Cale> zincy: There's a category of logical statements and proofs of implication
02:36:06 <zincy> a monoid is both a group and a category?
02:36:07 <Cale> (the objects of a category need not even be sets)
02:36:22 <Cale> A group is a kind of monoid
02:36:28 <Cale> (it's a monoid with inverses)
02:36:50 <ski> zincy : all groups are monoids. not all monoids are groups. all monoids are (or can be regarded as) categories. not all categories are (or come from considering a) monoid
02:36:51 <Cale> a monoid can be seen as a kind of category (having one object, all the arrows go from that object to itself)
02:37:28 <dminuoso> Cale: Thank you a lot for your explanation of Pi/Sigma types by the way. I've been reshaping my mental model a lot, and they are really simple to think about. :)
02:37:37 <dminuoso> Cale: You helped a lot.
02:37:38 <Cale> dminuoso: nice!
02:38:05 <zincy> yeah thanks Cale and Ski for the category theory intro
02:38:08 <ski> a homomorphism is a structure-preserving *function* (between two "underlying" sets of two algebraic structures, e.g. two groups, or two vector spaces)
02:38:19 <ski> a morphism doesn't have to be a function
02:38:21 <zincy> It has really made me want to explore it more
02:38:31 <ski> an object in a category doesn't have to be (or consist partly of) a set
02:39:00 <zincy> so homomorphisms are operations within the structure 
02:39:15 <zincy> morphisms go between structures
02:39:25 <ski> you can have a category where the objects are natural numbers, and morphisms (say from `m' to `n', e.g.) are `n'-by-`m' matrices
02:39:26 <aveltras> anyone knows why x is ambiguous in that gist ? https://gist.github.com/aveltras/833664abf03e3c5b72df2141506ea264
02:39:29 <Cale> That distinction that ski made is a bit contentious :)
02:39:40 <Cale> Between homomorphism and morphism
02:39:49 <dminuoso> zincy: Are you familiar with affine transformations?
02:40:03 <Cale> I think many people would consider morphism just to be a short form of homomorphism
02:40:04 <ski> yea, perhaps some people also use "homomorphism" even when there isn't an "underlying function"
02:40:12 <zincy> dminuoso: Head of them something to do with linear algebra
02:40:15 <zincy> *heard
02:40:18 <Cale> and some use homomorphism to mean "arrow in any category"
02:40:24 <dminuoso> zincy: http://www.geom.uiuc.edu/docs/reference/CRC-formulas/img46.gif
02:40:25 <ski> i use "morphism" as synonymous with "arrow"
02:40:29 <Cale> and there's also the word "arrow" which I've been using
02:40:41 <dminuoso> zincy: Consider this image perhaps. Do you see that the image is transformed, but some conceptual shape is preserved?
02:40:52 <dminuoso> Some kind of.. structure that you may not be able to express, but you can see it at least.
02:41:02 <Cale> So there's like a gradient of "abstractness connotation" in these words which are otherwise synonyms
02:41:02 <zincy> yeah I can see it
02:41:51 <dminuoso> zincy: This is just *one* of many examples of what structure preserving morphisms could mean. Here the structure preserved is of some geometrical meaning.
02:42:08 <zincy> so structure is about relationships
02:42:40 <dminuoso> Heh, this is like "monads are about ..." :-)
02:42:55 <zincy> vague nonsense sorry :)
02:43:29 <ski> zincy : anyway, this category, call it `Matr', is instructive in that the objects are merely plain natural numbers. the objects are not sets/types, nor do they contain such. also, the morphisms/arrows are matrices, which one commonly doesn't regard as a kind of function, at least not from some domain and codomain related to `m' and `n' here
02:44:19 <dminuoso> Cale: So when you said you wrote something like a constraint-level pi type, does this mean you have a kind of `Pi (x : A). B(x)` where `B : A -> Constraint`?
02:44:28 <ski> zincy : one could say that category theory is relationships between things. the "things" being the "objects", and the "relationships" being the morphisms/arrows
02:44:41 <zincy> ski: :)
02:45:28 <ski> zincy : so, studying something from categorical point of view means that we refrain from "looking inside the objects", instead we investigate how they relate to each other only be "external means", iow investigating the "relationships", the morphisms between them, and how those compose to other morphisms
02:45:35 <Cale> dminuoso: yeah, kinda
02:46:20 <dminuoso> Cale: Okay that's pretty cool. Is this a mimicry of something you might find in Idris or Agda?
02:46:28 <Cale> not really
02:46:38 <Cale> At least, I haven't seen it there
02:46:41 <ski> zincy : of course, it can often be useful to study a matter at hand, at several different levels of abstraction at the same time, or flipping between them. so it would not be uncommon to think about the "innards" of an object (which is then not "thinking categorically"), only to then try to reformulate what you're thinking, "externally", in terms of the morphisms only
02:47:20 <zincy> ski: So maths are computing are similar in that regard
02:48:03 <ski> zincy : category theory tends to focus on specification, how things are supposed to "behave", in relation to other things of the same kind. as opposed to set theory, which tends to focus more on representation/implementation of things, rather than "external properties and characterizations"
02:48:27 <zincy> ski: Earlier I was really confusing those two
02:48:54 <zincy> behaviour is more abstract in a sense than representation
02:49:08 <ski> yes
02:49:16 <zincy> because behaviour can affect representation
02:49:20 <zincy> not vice versa
02:49:43 <ski> but merely studying possible behaviour, without knowing whether there's anything that can implement that behaviour, isn't that useful :)
02:50:07 <zincy> haha are there any examples of that?
02:50:42 <ski> hm, i recall reading an anecdote about some mathematics teacher of some uni course
02:51:29 <ski> partway into the course, he, on impulse, put up a few operations and axioms/laws, and started investigating the consequences of those
02:51:48 <ski> e.g. how one could build new structures of the same kind, given a couple of existing structures of that kind
02:52:00 <ski> and proving theorems about such structures, and homomorphisms for them
02:52:15 <ski> and other people at the faculty started attending his lectures as well ..
02:53:06 <ski> .. until someone in the audience realized that (iirc) the only possible model/implementation of this structure was the real numbers (or perhaps the singleton set, or empty set, or something like that, i don't recall exactly)
02:53:33 <zincy> :D
02:53:41 <zincy> Did the teacher know until then?
02:53:42 <ski> at that point, the course resumed to where it had left off, some lectures before, and the other factulty members stopped attending
02:53:45 <ski> no
02:53:52 <zincy> Slightly embarrassing?
02:53:57 <ski> yea, you could say so
02:54:25 <ski> i think it was someone on ##math who linked to a description of this anecdote. i don't think i have a copy of the link
02:54:53 <dminuoso> "2019-04-29 14:58:02     Cale    Make sense? :)" -- Yes it does now! :-)
02:55:34 <zincy> People think of math as one subject which seems to be a very misguided view
02:57:50 <Cale> https://blog.plover.com/2008/02/07/#major-screwups-4
02:59:13 <Cale> (I was reminded of this blog post from 2008, lol)
03:14:19 <ski> zincy : it's more like a loose conglomerate of different subjects, which are partly related. perhaps that's why it's "mathematics", in plural
03:15:02 <ski> zincy : category theory is one attempt of making a "universal language" of mathematics, with which we can more easily translate, compare, and contrast concepts from different fields of math
03:15:30 <ski> zincy : one could probably say that set theory is an earlier such attempt. but set theory is in a sense "bottom-up", while category theory is "top-down"
03:15:42 <zincy> yeah
03:16:46 <ski> Cale : haha :)
03:17:17 <tty1> so trying to solve a problem a few days ago. Was making an instance of applicative but t was suggested I use apply since it was basically an applicative without the pure function. So is there also a variant of monad that extends from apply instead of applicative?
03:17:25 <ski> reminds me of some other person, a finn i think, who had a page where he collected counterexamples to published theorems
03:18:05 <ski> i think the story there commonly went : the theorem held for all "large enough" cases. but sometimes there would be counterexamples in the "small enough" area
03:18:14 * ski can't recall the name of him, atm
03:18:58 <Cale> tty1: http://hackage.haskell.org/package/semigroupoids-5.3.2/docs/Data-Functor-Bind.html#t:Bind
03:19:05 <ski> (zincy : of course that description doesn't exhaust the differences between set theory and category theory ..)
03:19:11 <Cale> tty1: What's the thing you're making an instance for?
03:19:33 <tty1> Cale: a graph, as in Graph Theory, specifically nodes
03:20:21 <Cale> ah, and how does the instance work?
03:20:41 <Cale> I would somewhat expect there to be a full Applicative there, if not a Monad
03:20:52 <Cale> But I guess it depends on what you're doing graph-theoretically
03:21:19 <tty1> Cale: not too sure yet, its my first haskell program so im sorta hacking up the architecture as i go. it may be a design deadend who knows
03:21:43 <Mo0O> Hi there
03:22:48 <[exa]> would cartesian product work as graph join?
03:22:50 <Cale> In that case, I would somewhat recommend taking all these abstractions with a grain of salt, just defining the functions that you need in your specific application, and only once you have things kind of working, go back and see if you can make things fit
03:23:07 <Mo0O> I'm importing Aeson.Lens using `import Data.Aeson.Lens` but after that if I do `:t asText` ghci complain `<interactive>:1:1: error: Variable not in scope: asText`, but it shouldn't http://hackage.haskell.org/package/aeson-lens-0.4.0.0/docs/Data-Aeson-Lens.html right?
03:23:36 <Cale> [exa]: yeah, it would be some kind of graph product that would work
03:23:49 <Cale> (probably several would)
03:24:07 <tty1> Cale: well i have a vague sense of where im going just hard to articulate. Basically im going to want to iterate across nodes and into them and nodes can contain almost anything
03:24:08 <Mo0O> I don't understand where is my error
03:24:33 <Cale> [exa]: Well, not for join itself so much as <*>
03:27:41 <Mo0O> By the way I cannot find `_String`
03:28:52 <jgt> Mo0O: did you do the import in GHCi? Or just in your file?
03:29:13 <Mo0O> jgt: both, in GHCi and in my file
03:29:32 <trcc> Anyone familiar with some open source CI hosting that is free of charge?
03:29:52 <jgt> Mo0O: and if you fully qualify it in GHCi?
03:31:07 <jgt> like :i Data.Aeson.Lens.asText
03:31:42 <Mo0O> <interactive>:1:1: error: Not in scope: ‘Data.Aeson.Lens.asText’
03:32:04 <Mo0O> it looks like I'm importing this version of Data.Aeson.Lens https://hackage.haskell.org/package/lens-aeson-1.0.2/docs/Data-Aeson-Lens.html#v:_String
03:32:47 <Mo0O> not that one http://hackage.haskell.org/package/aeson-lens-0.5.0.0/docs/Data-Aeson-Lens.html
03:33:04 <jgt> heh… just realised aeson-lens and lens-aeson are two different packages. How confusing.
03:33:16 <Mo0O> totaly
03:33:35 <Mo0O> jgt: and the import path is the same -_-'
03:33:46 <Mo0O> wierd
03:33:54 <jgt> ok, so it's no surprise that asText is not in scope then
03:34:13 <Mo0O> yes, it make more sense
03:34:26 <Mo0O> but it cost me time to figure it out :D
03:38:10 <__monty__> trcc: Only travis but that may not be what you want to hear : )
03:38:21 <trcc> __monty__: I have no experience with travis
03:38:23 <trcc> so thanks!
03:41:11 <__monty__> trcc: Travis got bought by a company that's infamous for milking every last cent out of whatever they buy. Maybe check out circleci, seems to be the popular alternative.
03:52:38 <dminuoso> @tell int-e Cheers, socket is indeed the right interface. :)
03:52:38 <lambdabot> Consider it noted.
03:52:57 <zincy> If you use datakinds to promote a type to a kind what happens to the type variables?
03:53:09 <zincy> are they promoted too?
03:53:52 <dminuoso> zincy: Give it a try?
03:54:00 <dminuoso> % :set -XDataKinds
03:54:00 <yahb> dminuoso: 
03:54:15 <dminuoso> % data Foo a = Bar a
03:54:15 <yahb> dminuoso: 
03:54:33 <dminuoso> % :k 'Bar
03:54:33 <yahb> dminuoso: 'Bar :: forall a. a -> Foo a
03:54:57 <dminuoso> Note that this is kind polymorphism.
03:55:11 <ski> @kind Int ': '[]
03:55:12 <lambdabot> [*]
03:55:18 <ski> @kind 'a ': '[]
03:55:19 <lambdabot> error:
03:55:19 <lambdabot>     Illegal promoted term variable in a type: a
03:55:30 <dminuoso> % :k 'Bar Maybe
03:55:30 <yahb> dminuoso: 'Bar Maybe :: Foo (* -> *)
03:55:33 <dminuoso> % :k 'Bar Maybe
03:55:33 <yahb> dminuoso: 'Bar Maybe :: Foo (* -> *)
03:56:00 <zincy> so it goes from type variable to kind variable
03:56:20 <dminuoso> % :k 'Bar (Maybe ': Either Int ': '[])
03:56:21 <ski> which does ?
03:56:21 <yahb> dminuoso: 'Bar (Maybe ': Either Int ': '[]) :: Foo [* -> *]
03:57:03 <zincy> ski: `a`
03:57:11 <zincy> in  data Foo a = Bar a
03:57:39 <ski> it becomes a kind variable (obviously ?)
03:57:41 <dminuoso> zincy: I prefer to not think of them as "type variables", but rather "parameters" in a function abstraction sense.
03:58:44 <dminuoso> Bar :: ∀a. a -> Foo a
03:59:00 <dminuoso> Where ∀ acts like a lambda (like \ for functions) but just on the type level
03:59:10 <dminuoso> And the same for the kind level.
03:59:40 <dminuoso> (Or well I guess you could still call them type variables)
04:00:11 <dminuoso> zincy: That way you stop thinking about "letters being promoted", and start thinking about what that type means.
04:00:20 <dminuoso> :t Bar
04:00:20 <ski> (not quite like a lambda .. but like a binder, sure)
04:00:21 <lambdabot> error:
04:00:21 <lambdabot>     • Data constructor not in scope: Bar
04:00:21 <lambdabot>     • Perhaps you meant one of these:
04:00:37 <dminuoso> ski: Other than a binder.. what is a lambda? :-p
04:00:51 <ski> `let' is also a binder
04:00:53 <dminuoso> Ah
04:01:21 <ski> a type `\a -> (a -> Bool)' is not the same as a type `forall a. (a -> Bool)'
04:01:31 <ski> the former has kind `* -> *', the latter has kind `*'
04:01:45 <ski> they are simply different binders
04:01:55 <dminuoso> ski: It depends on how you squint.
04:02:04 <ski> (different, but closely related)
04:02:06 <dminuoso> ski: The issue is that type applications happen transparently.
04:02:17 <ski> yes. we could move to System F, if you prefer
04:02:22 <dminuoso> We could pretend that `forall a. (a -> Bool)` is of kind `* -> *`
04:02:27 <ski> no
04:02:49 <dminuoso> Well, we could introduce a different arrow, if you prefer.
04:03:00 <dminuoso> (forall a. a -> Bool) : * ~> *
04:03:17 <dminuoso> Where ~ denotes the implicit type parameter for type applications
04:03:35 <dminuoso> Perhaps that is cleaner since we dont have to conflate it with the -> kind
04:03:42 <ski> no, i don't think that makes any sense
04:04:26 <ski> it's *values* of type `forall a. a -> Bool', which have an implicit type parameter
04:04:32 <ski> not the type `forall a. a -> Bool' itself
04:04:59 <ski> if `p :: forall a. a -> Bool', then `p @Integer' makes sense, and has type `Integer -> Bool'
04:05:12 <dminuoso> ski: I mean that `* ~> *` is the kind of types, whose values take one implicit type parameter.
04:05:31 <ski> but `(forall a. a -> Bool) Integer' (or if you want to write some special type of application there) doesn't make any sense to me
04:05:36 <dminuoso> Namely, they take an implicit type parameter of kind *
04:05:48 <dminuoso> ski: Fair enough.
04:06:02 <dminuoso> Maybe I am mixing up the universes here.
04:06:09 <ski> polymorphic values have types which are concrete. so of kind `*' here
04:07:11 <ski> (you can e.g. say `data Leibniz a b = Leib (forall f. f a -> f b)', and then `Leib :: forall a b. (forall f. f a -> f b) -> Leibniz a b'. clearly `forall f. f a -> f b' here has kind `*')
04:07:19 <dminuoso> Its funny, I just thought that forall quantification is sort of the inverse of dependent typing (where in TA you have values parametrized over types, and in DT you have types parametrized over values). Am I on a right track here?
04:07:50 <dminuoso> But I can see where my confusion was here.
04:08:29 <ski> one can think of `forall (a :: K). ..a..' as being shorthand for `Pi_K (\(a :: K) -> ..a..)', where `Pi_K :: (K -> *) -> *'
04:08:55 <ski> so, a `forall' type would then *involve* a corresoponding lambda, but wouldn't *be* that lambda
04:09:10 <dminuoso> Ah I see what you mean.
04:09:53 <ski> (and then of course one can have a polymorphic `Pi', of kind `forall k. (k -> *) -> *' .. and that `forall' is then on the kind level, which one could in turn explain in terms of a kind level `Pi', and so on ..)
04:10:14 <dminuoso> ski: In my notation I would write that as: x : Pi (a :: K). B(a), where B : (K -> *) -> *
04:10:20 <dminuoso> Did I read yours right?
04:10:38 <dminuoso> Do we have kind applications?
04:10:54 <dminuoso> I mean obviously I can tap into it with TypeApplications and TypeInType..
04:10:58 <dminuoso> Probably?
04:11:00 <dminuoso> Or?
04:11:09 <ski> @kind 'Just Int
04:11:10 <lambdabot> Maybe *
04:11:15 <ski> that's a kind application
04:11:16 <dminuoso> ski: Ahh I see.
04:11:30 <ski> (application of the kind `Maybe', to the kind `*')
04:12:07 <dminuoso> ski: (I did not understand your reference to Leibniz, but I have seen it somewhere on hackage as some sort of "Leibnizian equality"
04:12:25 <dminuoso> http://hackage.haskell.org/package/eq-4.2/docs/Data-Eq-Type.html
04:12:26 <dminuoso> This one?
04:13:50 <ski> (yea, the exact `Leibniz' example wasn't important. i just selected it, because it was an example of a data type with a data constructor with `PolymorphicComponents' (meaning the data constructor will be rank-2))
04:14:03 <ski> anyway, i need to leave presently ..
04:14:13 <ski> .. if you want to, perhaps we could continue the discussion later
04:14:37 <phadej> why it's leibniz's ? https://en.wikipedia.org/wiki/Identity_of_indiscernibles
04:15:35 <dminuoso> ski: I would like that, talk to you later.
04:16:25 <dminuoso> phadej: principium identitatis indiscernibilium
04:17:07 <dminuoso> phadej: cf Leibniz, Nouveaux Essais sur L'entendement humain II, ch. 27, § 1, 3
04:20:20 <dminuoso> Or perhaps `Gottfried Wilhelm Leibniz. Neue Abhandlungen über den menschlichen Verstand` as the German variant. That's the source I found anyhow.
04:23:33 <hpc> iirc it's "von Leibniz"
04:23:41 <hpc> he added "von" himself to sound more noble
04:36:35 <tdammers> incidentally, Beethoven once tried to use the "van" part in his name to be able to try a custody case at a court for the nobility, instead of the court for commoners, figuring he might have a better chance there. they caught on to him though, and as he had expected, he lost the case at the commoners' court
06:36:12 <ski> dminuoso : yea, that's one package (`eq', i.e.) with it
06:36:49 <ski> <dminuoso> ski: In my notation I would write that as: x : Pi (a :: K). B(a), where B : (K -> *) -> *
06:36:53 <ski> <dminuoso> Did I read yours right?
06:39:02 <ski> dminuoso : i didn't have any `x' named. did you mean `B : K -> *' ? if so, then your `Pi (a :: K). B(a)' would correspond to my `forall (a :: K). ..a..' (and to `Pi (\(a :: K) -> ..a..)'), yes
06:39:19 <bahamas> what library can I use for date and time handling? I need to get the current time and format that value using a specific format. I found the "time" package, but I don't understand how I can format with it
06:40:26 <ski> (and it's `Pi' here which would have kind `(K -> *) -> *' .. and as i mentioned one could generalize, making `Pi' polymorphic over this `K' .. and then (as i also briefly mentioned) for each rung in the sort hierarchy, we could have a `Pi' on that level)
06:42:12 <Cale> bahamas: Did you find formatTime?
06:42:20 <Cale> http://hackage.haskell.org/package/time-1.9.2/docs/Data-Time-Format.html#v:formatTime
06:42:41 <bahamas> Cale: http://hackage.haskell.org/package/time-1.9.2/docs/src/Data.Time.Format.Format.Class.html#formatTime. I don't understand what `TimeLocale` should be
06:42:54 <Cale> click on that type
06:42:59 <Cale> and you'll find defaultTimeLocale
06:43:31 <ski> <dminuoso> Do we have kind applications?  <dminuoso> I mean obviously I can tap into it with TypeApplications and TypeInType..  <dminuoso> Probably?  <dminuoso> Or?  <ski> @kind 'Just Int  <lambdabot> Maybe *  <ski> that's a kind application  <dminuoso> ski: Ahh I see.  <ski> (application of the kind `Maybe', to the kind `*')
06:44:44 <ski> dminuoso : well, when i said "kind application", there, i just meant a normal application of a kind function to a kind. just like `Either String' is a type application, an application of a type function to a type, and `Just False' is a value application, an application of a value function to a value
06:45:48 <bahamas> Cale: ok. I thought it would just use the locale for the American format and not let me specify a different format
06:46:04 <ski> dminuoso : `TypeApplications' is something else, that's (explicitly) applying a (polymorphic) value to a type. so, perhaps by "Do we have kind applications?" you were really thinking about something like `TypeApplications', but on the next level/rung up the sort hierarchy. iow, applying a polymorphic type explicitly to a kind
06:46:09 <bahamas> I don't understand why the function needs to take that `TimeLocale`, if you can just specify the format
06:46:25 <Cale> bahamas: Well, defaultTimeLocale *is* the specification of the American format. If you want other ones, you'll have to make your own.
06:46:39 <Cale> bahamas: It needs the strings that will get spliced in
06:46:47 <Cale> Like, the names of days of the week, etc.
06:46:49 <Solonarv> dminuoso: if your question was about a TypeApplications equivalent at the type level, no, we don't have that
06:46:58 <Solonarv> but it will be in ghc 8.8 IIRC
06:47:03 <Cale> bahamas: If you look at the definition of the TimeLocale type, it'll be obvious
06:49:00 <bahamas> Cale: ok. I think I understand what you mean. if I wanted to display the month as "nov" for example, it would have to take it from somewhere
06:49:10 <ski> (btw, just in case there's any confusion, `forall a. [a] -> Int' is *not* a "polymorphic type". but if you declare `newtype Const c a = MkConst c' (requiring `PolyKinds', which, btw, imho, is probably (?) a misnomer) (or `newtype Const c (a :: k) = MkConst a' if you want to be more explicit, this also requires `KindSignatures'), then `Const' is a polymorphic type, of kind `forall k. * -> k -> *')
06:49:25 <bahamas> Cale: I guess some examples would have helped, but it's all clear now. thank you for the help
06:50:33 <ski> (so a polymorphic value is a value whose type looks like `forall a. ..a..', while a polymorphic type is a type whose kind looks like `forall k. ..k..'. the type of a polymorphic value could be called a `forall'-type, or a universal type. similarly for the kind of a polymorphic type)
06:51:04 <Cale> bahamas: Yeah, and e.g. https://web.library.yale.edu/cataloging/months every language has its own abbreviations of the month names
06:54:18 <ski> % :k Const
06:54:18 <yahb> ski: Const :: forall {k}. Type -> k -> Type
06:54:22 <ski> % :k Const @ *
06:54:22 <yahb> ski: ; <interactive>:1:7: error: parse error on input `@'
06:55:09 <ski> dminuoso : seems like it doesn't work (that's with `TypeApplications' and `TypeInType')
06:57:21 <ski> dminuoso : anyway .. i was going to say also that instead of just having `Pi :: forall k. (k -> *) -> *', one could imagine having it as `Pi :: forall k0 k1. (k0 -> k1) -> k1'. so the idea is that `(forall a. ..a..) T' will mean `forall a. (..a..) T'
07:39:22 <cjay-> Are there any scenarios where the strict State monad performs better than ST?
07:39:59 --- mode: ChanServ set +o Sigyn
07:42:06 <ovitus> Can someone help me load a Haskell module in Tidalcycles BootTidal.hs?
07:44:55 <dmwit> I'm not too familiar with Tidalcycles. What have you tried, and what went wrong?
07:53:01 <ovitus> Well there is a BootTidal.hs startup script when you launch Tidal
07:53:35 <ovitus> import Sound.Tidal.Context import Data.List(findIndex) import Data.Maybe(fromJust)  markovStep :: [[Double]] -> [Int] -> [Int] markovStep tp xs = (fromJust $ findIndex (r <=) $ scanl1 (+) (tp!!(head xs))) : xs where r = timeToRand $ fromIntegral $ length xs markovPat n xi tp = slow (fromIntegral n) $ listToPat $ reverse $ (iterate (markovStep tp) [xi]) !! (n-1) 
07:53:59 <ovitus> Basically trying to load that. but how would I make a module out of it so I can import it?
07:54:42 <ovitus> if I try loading it via BootTidal.hs, for some reason all the other functions are out of scope
07:55:02 <ovitus> only works if I execute it in the Tidal environment
08:00:29 <lyxia> Do you mean that you have those lines above in a module?
08:00:36 <lyxia> How are you loading it in BootTidal??
08:07:00 <dminuoso> ski: So let's pretend for a second that `;;` meant "has kind", and we used `forallk` and `forallt` for kinds and types respectively. `Const ;; forallk k. Type -> k -> Type` right?
08:07:39 <dminuoso> (The point here is to introduce a language that removes the visual ambiguity between types and kinds, though TypeInType is another story...)
08:08:31 <ski> yes
08:08:49 <ski> (you could use `::_0',`::_1' in place of `::',`;;', if you wanted to)
08:09:15 <Younder> Seriously all you need is classes.. I refer to Categorical logic by Robert Goldblat
08:09:15 <dminuoso> Oh that would be helpful too if we started talking about sorts.
08:09:16 <ovitus> I was using :l /home/awright/.vim/plugged/vim-tidal/Markov.hs in the BootTidal.hs startup script to load it
08:09:17 <ski> (and, i suppose, `forall_0',`forall_1', in place of `forallt',`forallk')
08:09:23 <dminuoso> ski: Yeah I figured.
08:09:54 <ovitus> That was how I was loading it, but with 'module Markov where' at the beginning
08:10:20 <dminuoso> x : ∀_0 (x :: Type). B(x) -- value-level polymorphism
08:10:36 <dminuoso> x : ∀_1 (x :: Kind). B(x) -- type-level polymorphism, like with Const
08:10:51 <dminuoso> Oh, perhaps I shouldn't be mixing : and ::..
08:13:50 <dminuoso> ski: So inside that tower here, Pi types are above that, arent they?
08:14:09 <dminuoso> z : ∀_0 (x : (F : Type)). B(x)
08:15:42 <dminuoso> ski: sort of in this sense https://gist.github.com/dminuoso/7a82323a3e6632afc7c0c13fb1fd88c5
08:17:01 <ski> "above" ?
08:25:11 <ski>   v : ∀₀ (α : ★). T α
08:25:15 <ski>   τ : ∀₁ (κ : ✶). K κ
08:25:23 <ski> or, generalizing a little bit
08:25:42 <ski>   v : ∀₀ (α : K). T α
08:25:50 <ski>   τ : ∀₁ (κ : T). K κ
08:27:02 <ski> in the first two, we have ⌜T : ★ →₀ ★⌝, respectively ⌜K : ✶ →₁ ✶⌝
08:29:34 <ski> in the latter two, we have ⌜T : K →₀ ★⌝ with ⌜K : ✶⌝, respectively ⌜K : S →₁ ✶⌝ with ⌜S : ✷⌝, say
08:29:46 <lyxia> ovitus: you might want to read about the various module-related commands https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#module-and-load
08:29:47 <ski> anyway, i was saying we could reformulate these two as
08:30:30 <c_wraith> Huh.  I'm surprised that bug made it into rust, given that GHC haskell had the same issue for forever...
08:30:36 <ski>   v : ∏₀ (λ (α : K) ↦ T α)
08:30:38 <ski>   τ : ∏₁ (λ (κ : T) ↦ K κ)
08:30:51 <ski> so that here we'd have
08:30:55 <c_wraith> This is just like why GHC no longer allows manual Typeable instances https://blog.rust-lang.org/2019/05/14/Rust-1.34.2.html
08:31:40 <ski>   ∏₀ : (K →₀ ★) →₀ ★
08:31:43 <ski>   ∏₁ : (S →₁ ✶) →₁ ✶
08:31:57 <ski> or, generalizing over ⌜K⌝ and ⌜S⌝
08:32:06 <lyxia> ovitus: you might be looking for :add
08:32:30 <Shifno> I am looking for something like `newline` on Hoogle, which is clearer than   putStrLn ""
08:32:46 <c_wraith> lyxia: holy crap, I didn't know that existed.  thanks!
08:33:44 <lyxia> :)
08:34:48 <c_wraith> Shifno: don't think it's defined anywhere standard.  It's just so easy to define yourself, it doesn't seem worth exporting a name for it.
08:36:53 <Shifno> c_wraith: I guess I expected it to be in Prelude. Anyway, thx for confirming
08:37:27 <ski>   ∏₀ : ∀₁ (κ : ✶). (κ →₀ ★) →₀ ★
08:37:29 <ski>   ∏₁ : ∀₂ (σ : ✷). (σ →₁ ✶) →₁ ✶
08:38:28 <ski> or, reformulating
08:39:16 <ski>   ∏₀ : ∏₁ (λ (κ : ✶) ↦ (κ →₀ ★) →₀ ★)
08:39:17 <ski>   ∏₁ : ∏₂ (λ (σ : ✷) ↦ (σ →₁ ✶) →₁ ✶)
08:39:24 <Solonarv> Shifno: putStr "\n" -- :D
08:40:18 <ski>   ∏ᵢ : ∏ᵢ₊₁ (λ (x : ★ᵢ₊₁) ↦ (x →ᵢ ★ᵢ) →ᵢ ★ᵢ)
08:40:30 <ski> dminuoso : ^ making any sense to you ?
08:49:03 <benzrf> https://i.warosu.org/data/ck/img/0103/75/1522458790330.jpg
08:49:06 <benzrf> oops wrong channel sorry
09:02:28 <DigitalKiwi> if this is the wrong channel what's the right one?
09:03:21 <benzrf> shrug!!
09:35:17 <__monty__> I bet it's some sort of sexy channel.
09:40:51 <benzrf> D:
11:16:20 <Unhammer> hm, is it common that the times in .hp files are quite a bit off?
11:16:54 <Unhammer> (looking at the hp2ps, it seems the runtime was 10 minutes, while my regular logs show 30 minutes)
11:17:09 <Unhammer> this is a non-profile build with -hT, if that matters
11:29:02 <aveltras> is there some ghc extension to make ResponseT injective ?
11:29:07 <aveltras> https://www.irccloud.com/pastebin/rUPbkYe1/
11:30:06 <ski> use `data' rather than `type' ?
11:30:41 <Guillaum> How can I create a type level NonEmpty?. With Data.Singletons.Prelude.List.NonEmpty, I tried ("hello" ':| '[])
11:30:44 <Guillaum> ("hello" ':| '[])
11:31:21 <Guillaum> (sorry). But ':| does not exists.
11:33:28 <ski> i assume you already have enabled `DataKinds'
11:35:06 <aveltras> ski: hmm, having other problems now but no injectivity ones at least :)
11:35:18 <Guillaum> ski: yes ;)
11:35:54 <Solonarv> I'm not sure why you would need singletons?
11:36:05 <Solonarv> % import Data.List.NonEmpty (NonEmpty(..))
11:36:05 <yahb> Solonarv: 
11:36:16 <Solonarv> % :set -XDataKinds
11:36:17 <yahb> Solonarv: 
11:36:28 <Solonarv> % :kind! ("hello" :| [])
11:36:28 <yahb> Solonarv: ; <interactive>:1:13: error:; * Expecting one more argument to `[]'; Expected kind `[GHC.Types.Symbol]', but `[]' has kind `Type -> Type'; * In the second argument of `(:|)', namely `[]'; In the type `("hello" :| [])'
11:36:35 <Solonarv> % :kind! ("hello" :| '[])
11:36:35 <yahb> Solonarv: ("hello" :| '[]) :: NonEmpty GHC.Types.Symbol; = "hello" ':| '[]
11:36:54 <ski> hm, yea .. i can imagine a singleton version of `NonEmpty' not fitting well with `DataKinds' .. at least not without also `TypeInType' ?
11:37:07 <Guillaum> Solonarv: so obvious ;) I need Data.List.NonEmpty in scope... I'm stupid. Thank you ;)
11:37:20 <Solonarv> TypeInType is just an alias for PolyKinds+DataKinds+KindSignatures nowadays
11:37:29 <ski> oh .. merely forgot to `import' it ?
11:37:42 <ski> Solonarv : oic
11:37:45 <ski> til
11:38:22 <Solonarv> I admit I am surprised that Data.Singletons.Prelude.List.NonEmpty does not reexport (parts of) Data.List.NonEmpty
11:38:53 <Guillaum> ski: yes, that's stupid, sorry ;) After fighting many hours with singletons, I just forgot about the basics ;(
11:52:24 <gbd_628> Hi, quick GHC question: how do the warning options stack? E.g., if I say "-Wall -Werror -Wwarn -w -Wdefault", what happens? Do they add, or do the later options override the previous ones? The documentation isn't very clear on this.
11:53:17 <geekosaur> generally ghc options are applied in order
11:55:20 <cocreature> gbd_628: -Wwarn definitely overrides -Werror, I am not sure how -Wall -Wdefault behaves. Probably easiest to just try it out :)
12:17:05 <jle`> Guillaum: this is a situation where reading the error helps :)
12:17:28 <jle`> it probably told you that :| is not in scope
12:17:37 <jle`> which means you have to import it :)
12:27:43 <jle`> ah they announced the winners of the IOCC (obfuscated c code contest) this past week
12:27:49 <jle`> one of the winners was a haskell compiler
12:28:04 <MarcelineVQ> And I can't read the other's name
12:29:30 <jle`> looks like the source code isn't up yet
12:31:21 <jle`> but do i really want to read an obfuscated haskell compiler written in C
12:32:29 <geekosaur> only if it somehow manages to look like haskell code?
12:33:15 <geekosaur> (somehow I don't think that happens even with BWK-level cpp hackery)
12:45:28 <Guillaum> jle`: I interpreted "not in scope" as "you are not using the right operator".
12:48:58 <dmwit> Aw, the winners are announced, but you can't look at the winning submissions yet?
12:49:22 --- mode: dmwit set -o dmwit
12:51:36 <lavalike> geekosaur: what's BWK?
12:51:48 <geekosaur> Brian Kernighan
13:10:21 <thecodedmessage> jle`: is this for 2019? Where's the announcement?
13:11:18 <phadej> http://www.ioccc.org/2019/whowon.html
13:13:20 <geekosaur> although really I should have cited Steve Bourne, whose original shell was written in mutant Algol via CPP hackery
13:13:37 * geekosaur saw that source once; it was a trip :)
13:14:26 <ski> @quote SteveBourne
13:14:26 <lambdabot> No quotes match. Are you on drugs?
13:14:32 <dminuoso> ski: Im reading it now, this will take a moment.
13:16:48 <dminuoso> ski: What do the brackets around ⌜K⌝ indicate?
13:17:19 <dminuoso> Or is this just a way to quote type language into a sentence?
13:18:09 <zincy> How come the following (<>) constructs an infinite type? https://repl.it/repls/TemporalOilyLogins
13:19:39 <dminuoso> zincy: So consider:
13:19:50 <dminuoso> (:-) :: a -> Vector a n -> Vector a (Succ n)
13:19:56 <geekosaur> I... am not sure that makes sense. type level sized vectors are distinct types, but the "contract" for Semigroup is "same type"
13:20:12 <[exa]> zincy: (<>) is a->a->a, so e.g. Vector 3 -> Vector 3 -> Vector 3
13:20:20 <[exa]> zincy: not "Vector 6" on the end
13:20:25 <dminuoso> zincy: Unify this with your usage of (<>)
13:20:26 <zincy> :/
13:21:01 <zincy> Yep that makes sense
13:21:20 <zincy> It was the words "infinite type" which really confused me
13:21:45 <dminuoso> zincy: GHC deduces, by type inference, that:  v ~ 'Succ v
13:21:46 <phadej> > f f
13:21:48 <lambdabot>  error:
13:21:48 <lambdabot>      • Could not deduce (Show t0) arising from a use of ‘f’
13:21:48 <lambdabot>        from the context: FromExpr t
13:21:55 <phadej> hmm
13:21:57 <dminuoso> zincy: If you set: v ~ 'Succ v
13:21:58 <ski> dminuoso : yes
13:22:07 <dminuoso> zincy: Then you are a bit in a problem.
13:22:12 <phadej> :t \x -> x x
13:22:13 <lambdabot> error:
13:22:13 <lambdabot>     • Occurs check: cannot construct the infinite type: t ~ t -> t1
13:22:13 <lambdabot>     • In the first argument of ‘x’, namely ‘x’
13:22:31 <phadej> basic example of "infinite type"
13:22:39 <dminuoso> zincy: Because if `v ~ Succ v`, then `v ~ Succ v ~ Succ (Succ v) ~ Succ (Succ (Succ v)) ~ ... ad infinitum`
13:22:59 <dminuoso> (Leaving the ticks away for readability)
13:23:44 <zincy> I see!
13:24:04 <zincy> Oh well there goes my idea of trying to write a monoid instance for my vector
13:24:43 <dminuoso> zincy: Take note that the very core idea of a monoid is this shape of `a -> a -> a`, where *all* three a are the same.
13:25:15 <dminuoso> zincy: you can still write a monoid instance if you constraint it a bit more, but it will act differently.
13:25:44 <zincy> I have almost never written any instances manually apart from show and to and from JSON hehe
13:26:08 <zincy> Just always derived them
13:26:47 * dminuoso preferred to handwrite instances until he understood how they worked and needed to be written intuitively, at which point he started using `deriving` to save time.
13:27:15 <zincy> In hindsight I did it wrong
13:27:33 <zincy> manual first
13:27:39 <phadej> or then no
13:27:42 <[exa]> zincy: you may try adding Num instance to some things; that's the most obvious and useful exercise out there
13:27:45 <phadej> writing Ord by hand is just PITA
13:27:48 <phadej> and you don't learn anything
13:27:54 <dminuoso> ski:  "ski |   v : ∀₀ (α : K). T α", "τ : ∀₁ (κ : T). K κ", can you elaborate on the usage of `T` and `K` here? 
13:28:15 <zincy> [exa]: Good idea thanks
13:28:19 <[exa]> zincy: e.g. for your vector, or Num [a]   (usage: fibs=0:1:fibs+tail fibs)
13:28:42 <dminuoso> phadej: On my first day or two I wrote them out by hand actually, and then I started deriving them... *shrugs*
13:28:53 <zincy> a num instance for my vector how would that work
13:28:57 <dminuoso> Perhaps it sounded a bit longer than that.
13:29:42 <phadej> I took another route, it took me 10 years or so to write non-trivial Show instance
13:29:45 <zincy> Can you get lazy evaluation for types?
13:30:03 <zincy> you have been using Haskell for > 10 years?
13:30:35 <dminuoso> phadej: Heh. I still dont understand Show1 :-)
13:30:35 <phadej> professionally for less, but yes, for over a decade otherwise
13:30:46 <[exa]> zincy: you add/multiply/subtract vectors simply element-by-element to form a new vector
13:31:13 <zincy> That could be useful actually
13:31:14 <ski> @type let sort [] = []; sort xs = round [[x] | x <- xs] where round [x] = [x]; round xs = round (pass xs); pass (x0:x1:xs) = merge x0 x1 ++ pass xs; pass xs = xs; merge [] ys = ys; merge xs [] = xs; merge xs0@(x:xs) ys0@(y:ys) | x <= y = x : merge xs ys0 | otherwise = y : merge xs0 ys0 in sort
13:31:15 <lambdabot> error:
13:31:16 <lambdabot>     • Occurs check: cannot construct the infinite type: a2 ~ [a2]
13:31:16 <lambdabot>       Expected type: [a2] -> [[a2]]
13:31:26 <ski> zincy : can you spot the problem in that ^ ?
13:31:53 <[exa]> zincy: it keeps the size of the vector so at least no problem with infinite types there. :]
13:32:38 <dminuoso> ski: Your generalization step confuses the hell out of me, Ive been staring at it for the better part of 15 minutes.
13:33:10 <georg_> Hello, do I need to import anything beyond Test.Quickcheck to get forAllBlind? I keep getting "Variable not in scope: forAllBlind :: Gen Valuation -> (Valuation -> Property) -> prop1"; cabal list says that I do have it installed: QuickCheck; Default available version: 2.13.1, Installed versions: 2.10.1, 2.13.1; http://hackage.haskell.org/package/QuickCheck-2.13.1/docs/Test-QuickCheck.html doesn't say anything regarding a version speci
13:33:22 <georg_> idea how to remedy this? Thanks you in advance!
13:34:50 <[exa]> georg_: certainly it's not in 2.10.1
13:35:22 <dminuoso> [exa]: It would be more honest if you used Fractional instead of Num
13:35:25 <ski> dminuoso : ⌜T⌝ in that first one is a type function, expressing the body of the ⌜∀₀⌝. it corresponds to your ⌜B⌝ (in ⌜B(x)⌝, which would be my ⌜T α⌝). this ⌜T⌝ has kind ⌜K →₀ ★⌝
13:35:35 <dminuoso> [exa]: You know, since vector spaces are defined over fields.. :p
13:36:01 <georg_> [exa]: let me try to remove that one, but the default version is 2.13.1, it says
13:36:03 <[exa]> georg_: so you might want to force your compiler to use the 2.13.1; that kindof depends on what package management you use but trying ghc-pkg usually helps
13:36:15 <[exa]> georg_: how do you run the build?
13:36:33 <georg_> just plain cabal run
13:36:46 <[exa]> georg_: do you have sandbox there?
13:38:03 <georg_> did cabal init -n --is-executable; let me try to change the proj.cabal file
13:38:32 <dminuoso> ski: I do not understand the ⌜K : *⌝ part.
13:38:38 <georg_> [exa]: yeah it was the version, thanks a lot!
13:38:57 <dminuoso> ski: If it was ⌜K : Box⌝, then I would see what you mean.
13:39:01 <georg_> (forced >=2.13)
13:39:05 <[exa]> it worked? wheew nice
13:39:27 <ski> dminuoso : and that ⌜K⌝ has sort ⌜✶⌝
13:40:02 <[exa]> dminuoso: there's fromInteger in Num, that usually provides most fun, esp. for sized vectors
13:40:50 <dminuoso> ski: Ah, so we could say that ⌜K : ✶₁⌝
13:41:22 <dminuoso> ski: It seems that you reused ⌜✶⌝ in different universes to me.
13:41:44 <dminuoso> ski: By the way, what technique do you use to type unicode characters?
13:42:01 <ski> dminuoso : oh, it shouldn't be ⌜T⌝ in the second one, it ought to be ⌜S⌝, otherwise it makes no sense. sorry about that, mea culpa. ⌜K⌝ in the second one is a kind function, expressing the body of the ⌜∀₁⌝. ⌜K⌝ has kind ⌜S →₁ ✶⌝. and ⌜S : ✷⌝
13:42:07 <ski> (dminuoso : i'm assuming here that ⌜★ : ✶⌝, and that ⌜✶ : ✷⌝. later i changed notation to an indexed one, like ⌜★₀ : ★₁⌝, and ⌜★₁ : ★₂⌝, in general ⌜★ᵢ : ★ᵢ₊₁⌝)
13:42:35 <ski> dminuoso : .. copy and paste ;}
13:43:33 <ski> yes, ⌜*⌝ was just another notation for `Box', where `Type :: Box'
13:43:57 <ski> (when writing on paper, i often use stars akin to these)
13:44:03 <dminuoso> ski: Gotcha, I was worried for a moment that we were in TypeInType.
13:44:19 <ski> you could go there, if you wanted to
13:44:53 <ski> dminuoso : sorry again about inadvertently using ⌜T⌝ when i meant ⌜S⌝, in the second of those two
13:45:39 <zincy> ski: The problem is that sort and round have this mutual recursion where they sort is eventually called again in the otherwise case of the merge function which keeps wrapping the type in a list?
13:45:41 <ski> dminuoso : anyway, the ⌜K⌝ in the first of those is unrelated to the ⌜K⌝ in the second of them
13:45:44 <dminuoso> ski: That's alright. Stumbling over it means I'm paying attention. :-)
13:46:37 <ski> ⌜K : ✶⌝ for the former one. ⌜K : S →₁ ✶⌝ for the latter one
13:47:35 <ski> zincy : `sort' and `round' are not mutually recursive
13:48:43 <zincy> oops
13:49:36 <ski> zincy : `merge' does not call `sort', the `in sort' in `let sort ... in sort' was just the end of the `let', required to be able to ask the type of the whole expression
13:49:57 <ski> (zincy : otherwise i'd first have had to do a `@let sort ...' to define `sort', and then `@type sort' to ask for the type, and i didn't feel like doing it in two commands .. oh, and it wouldn't work anyway, because of the type error .. so i suppose it wouldn't matter, and so i could just as well have went for the possibly less confusing `@let' ..)
13:50:25 <zincy> ski: Is the infinite type an infinitely nested list?
13:52:08 <ski> zincy : if the type `a2' is to be equal to the type `[a2]', then that means `a2  =  [a2]  =  [[a2]]  =  [[[a2]]]  =  [[[[a2]]]]  =  ...  =  [[[[[...]]]]]'. an "infinite type" (aka a "cyclic type", or, sometimes, a "rational type")
13:52:23 <ski> zincy : so, yes. a list of lists of lists of lists of ...
13:52:49 <zincy> so is lazy evaluation at the type level possible
13:53:05 <dminuoso> zincy: Well we have the concept of infinite types, but we need to express them differently.
13:53:43 <ski> zincy : i made (by intent) a mistake, in the definition of `sort' above, which causes this "infinite type error" (aka "occurs type error"). it sounded like you weren't that familiar with this, so i thought i'd conjure up some example of it, for you to ponder
13:54:14 <[exa]> zincy: infinite type _terms_ are forbidden by purpose, you can't compare them for equality very efficiently
13:54:31 <ski> (i was first trying to make an error in a simpler function, but i couldn't figure out a way to make it reasonably believable, with the error not immediately obvious. and so i tried with `sort' ..)
13:54:38 <dminuoso> % data Nu f = forall a . Nu a (a -> f a)
13:54:39 <yahb> dminuoso: 
13:54:39 <geekosaur> sounded more to me like they were hoping type level-sized vectors would be considered the same type ignoring the size
13:54:43 <Guillaum> Is there a way to convert type-level String to Symbol? I can do the opposite using FromString from singletons (Data.Singletons.Prelude.IsString), but not the other way around.
13:54:45 <zincy> ski: Yeah thanks!
13:54:49 <dminuoso> zincy: ^- this lets you create coinductive infinite types.
13:54:54 <zincy> ski: I am not familiar with merge sort either
13:55:01 <ski> [exa] : well, yes. but that's not the main reason for disallowing them. `ocaml -rectypes' can handle them just fine
13:55:50 <[exa]> ski: do they dodge the NP-hard instances somehow?
13:56:05 <zincy> geekosaur: kind of I didn't realise that a type family called Plus which operated on two Nats was not just a type synonym of sorts
13:56:44 <ski> (zincy : or .. if i'm being nitpicky (which i am), i should say that, no, "the infinite type" is not "an infinitely nested list". rather "the infinite type" is the *type* of values which are "infinitely nested list"s)
13:57:01 <dminuoso> Guillaum: What's the difference between "type-level string" and symbol?
13:57:09 <ski> dminuoso : that's the State encoding of `nu', yes
13:57:13 <Cale> zincy: Also, a *large* number of typos can be made legitimate typechecking programs if you admit infinite types... there was a really good mailing list post providing examples of this at one point, perhaps I can try to dig it up
13:57:42 <ski> dminuoso : i assume you also recall the Church encoding of `Mu' ?
13:57:49 <ski> dminuoso : sorry, of `mu'
13:58:02 <Cale> (they'd be typechecking, but they'd be totally not the program you intended, but some garbage which would loop forever or something)
13:58:22 <ski> [exa] : you just need to check for cycles
13:58:40 <ski> [exa] : tortoise-and-hare
14:01:55 <Cale> ugh, so hard to find anything that far back
14:02:38 <eacameron> Is there a good way to encode "negative" constraints? I.e. I really want to say "give me something that doesn't have an instance for X"
14:03:07 <lavalike> eacameron: what is that good for?
14:03:11 <Cale> In any case, "occurs check" errors are often the result of leaving out an argument to a function by accident
14:03:17 <eacameron> The only way I know of is to define a newtype, leave out the instance, and ask for the newtype specifically. But this doesn't compose, if you want to ask for something that doesn't have X *and* Y
14:03:34 <Cale> and so just allowing things to proceed with an infinite type for the function usually wouldn't be what you wanted at all
14:04:15 <Solonarv_> Guillaum: you can't have a String at the type level, so you can very easily convert every type-level String into a Symbol ;)
14:04:17 <Cale> eacameron: There is by design no way to say that, because there always might be an instance in a module yet to be compiled (or written)
14:04:57 <eacameron> lavalike: For example: `runThingThatDoesn'tDealWithExceptions :: (Doesn'tHave MonadThrow f) => f a -> g a`
14:05:34 <eacameron> Cale: Right...but is there a different way to encode it, other than just lots of newtypes and dozens/hundreds of redundance instances
14:05:39 <eacameron> *redundant
14:05:44 <Cale> eacameron: So the compiler will complain when it absolutely needs an instance in order to be able to compile but can't find it, but it can't really be sure that the problem isn't just that the instance is in a future module.
14:06:07 <Cale> well...
14:06:21 <Cale> How did you intend to use that constraint?
14:06:36 <geekosaur> mroe or less. the way to encode it is to provide a (runtime) witness for its (non)existence
14:06:36 <tristah> I am new to haskell why does the compiler warn me about using tabs??
14:06:37 <Cale> Like, what does knowing that f doesn't have a MonadThrow instance buy you?
14:07:07 <Cale> tristah: Because tabs are always treated by the compiler as aligning to the next multiple of 8 spaces, and most people's editors aren't configured like that
14:07:17 <eacameron> Cale: Well it buys me that you didn't throw lol. It's sort of half-baked in my mind as of yet
14:07:28 <eacameron> geekosaur: Which I guess is a newtype
14:07:49 <eacameron> constructor
14:07:54 <geekosaur> or a class with a bunch of instances, as you found
14:08:09 <geekosaur> there's no way to do this nicely, absence of evidence at compile time is not evidence of absence
14:08:27 <geekosaur> unless it's final link (so a whole-program compiler could do this)
14:08:29 <Cale> tristah: So pretty much everyone in Haskell-land uses spaces instead of tabs. It's possible to write really sneaky programs with tab characters, which behave differently than they look if your tab stops are set to, say, 4 instead of 8.
14:08:38 <ski> tristah : Haskell uses semantically meaningful indentation layout. using tabs can easily mess with that, if your editor doesn't display them with the same width that the compiler is using. you *can* use tabs for indentation, but you must be quite careful and disciplined about it. for newbies, it tends to be simpler to just altogether not use tabs
14:08:57 <dmwit> tristah: Because some tyrants got ahold of the parser!
14:09:19 <Cale> (I actually think tab characters shouldn't be allowed in source files at all -- it should be a straight up lexical error, like vertical tab)
14:09:38 <Solonarv_> (if the compiler is going to barf on them, certainly)
14:09:47 <Solonarv_> they could be allowed in string literals I guess
14:10:01 <delYsid``> Cale++
14:10:04 <ski> tristah : in case you want to use tabs, you must make sure to *only* use tabs for indentation, and to also break line after any layout-introducing keyword (that's `where',`let',`of',`do') followed by a layout block comprising more than one item
14:10:07 <Cale> Yeah, maybe, though usually in string literals, you'd write \t or something
14:10:10 <dmwit> I have documented my stance here: http://dmwit.com/tabs . But my opinion is not a popular one.
14:10:16 <dmwit> I like tabs. They have semantic content that spaces do not.
14:10:42 <Cale> dmwit: I could agree with you if the entire ecosystem of software were different :D
14:10:57 <ski> Cale : fwiw, i sometimes use form feeds in source :)
14:11:10 <dmwit> (And I think it's weird that GHC has a warning for a stylistic choice like this one.)
14:11:17 <eacameron> Cale says: "I could agree with you in the universe were reoriented in such a way that I was wrong" LOL
14:11:24 <Cale> haha
14:12:03 <Cale> We ideally almost shouldn't be storing programs as text documents at all, though I've never seen anything which actually makes working with anything more structured less painful than working with text.
14:12:17 <tdammers> ^ this, pretty much
14:12:25 <eacameron> ^ second
14:12:45 <tdammers> structural editing is morally the right choice, but in practice, the practical shenanigans associated with editing anything but plain text are just too much
14:13:00 <dmwit> I don't advocate a style which requires all new software.
14:13:05 <Rembane> Some dayt I'll build a vim for structural editing 
14:13:16 <dmwit> Indeed, I have advice for configuring existing software, like vim and emacs, for the style of tab use that I advocate.
14:13:51 <Cale> Yeah, but then the problem is going to be that most people's software won't be configured like that
14:13:57 <tdammers> the problem with tabs is not the availability of suitable software; the problem is availability of suitable users
14:14:41 <dmwit> Here is the solution I use: be the only coder on all your projects.
14:14:44 <dmwit> ;-)
14:14:49 <Cale> Like, I totally agree that *if* we could treat tabs as having a strict semantic meaning, and this would cause editors to display things with an awareness of what that meaning was
14:14:54 <Cale> then that would be awesome
14:15:19 <ski> dmwit : yea, i thought i remembered someone interleaving tabs and spaces. tabs for indentation and spaces for alignment. i tried to phrase what i said carefully
14:15:33 <Cale> But tabs unfortunately don't *quite* mean that thing, at least by default. They mean "align me to the next multiple of n column"
14:16:05 <Cale> where n is default to 8 in a lot of places, and 4 in a lot of others...
14:16:17 <Cale> and it's just a big pile of garbage
14:16:20 <dmwit> That is why I advocate a style of tab use which is tabstop-agnostic.
14:16:48 <dmwit> This way it looks correct in 8-space environments and 4-space environments alike.
14:17:31 <tdammers> here's another solution: instate an 80-column limit, and mandate tabs to be 96 columns wide
14:17:52 <tdammers> so tabs are technically allowed, but will automatically overrun the line length limit
14:17:57 <tdammers> everyone wins
14:18:01 <Cale> It still doesn't completely prevent someone from being sneaky and making a program look like it does one thing with 4 space tabs and another thing with 8 space tabs
14:18:11 <dmwit> Yes, it does prevent that.
14:18:13 <ski> tdammers : hmm, the former part sounds interesting
14:18:30 <Cale> dmwit: I guess with some preprocessor to check that the convention is being followed?
14:18:44 * [exa] checks calendar
14:18:49 <dmwit> There currently is no such. I agree it would be nice to have, and it is on my long list of things to do in my copious free time.
14:19:04 <[exa]> 2019 and we still don't have editor that can hang a paragraph
14:19:05 <Cale> The nice thing about "no tabs" is that it's an easy rule to apply
14:19:22 <Cale> [exa]: yep, nothing can comprehend the complexities of the offside rule
14:19:25 <oni-on-ion> psh 2019 our video games still dont even have shadows 
14:19:26 <dmwit> Ideally it would be part of GHC's parser -- an -fwarn-dodgy-tabs or similar -- to check that the layout decisions are consistent with the "tabs are of incomparable width to spaces" rule.
14:19:53 <[exa]> oni-on-ion: oh games. Fireballs don't burn wooden furniture.
14:20:09 <oni-on-ion> yeh. *too* realistic leaves a lot of swish cheese feeling
14:20:24 <[exa]> Cale: :]
14:20:44 <zincy> Is there any way saying the `a` in progress games type signature is of type Game but is still a type variable which can be passed to NextGame? https://repl.it/repls/BlissfulEminentConfiguration
14:20:46 <Cale> Fireballs cause wooden furniture to go flipping around in the air
14:21:04 <Cale> very physics
14:21:29 <oni-on-ion> half-forward-walk-keyframes when turning, cool 
14:21:30 <[exa]> yeah fire works that way!
14:22:25 <MarcelineVQ> zincy: what sig?
14:22:31 <Cale> zincy: btw, you might really like the TypeLits extension
14:22:42 <ski> fireballs, as in .. ball lightning ?
14:22:50 <dmwit> zincy: You probably want `class Progress a where type NextGame a; progressGame :: a -> NextGame a`.
14:22:54 <zincy> MareclineVQ: progressGame - its commented out 
14:22:59 <MarcelineVQ> oh it's commented in a colour my eyes can't see, fuccck you design devs :(
14:23:08 <MarcelineVQ> comments are more important than code >:<
14:23:18 <Cale> MarcelineVQ: comments are the least important thing, didn't you know?
14:23:22 <dmwit> zincy: Then one instance for each of the type instances you currently have written.
14:23:25 <zincy> Cale: Yeah I found it a few days ago :)
14:23:26 <Cale> hahaha
14:23:28 <Solonarv_> Cale: I think it's been folded into DataKinds
14:23:34 <ski> or more like burning things they threw over walls into cities under siege assault ?
14:23:37 <Solonarv_> % :set -XTypeLits
14:23:37 <yahb> Solonarv_: Some flags have not been recognized: -XTypeLits
14:23:38 <Cale> Solonarv_: ah, cool
14:24:28 <MarcelineVQ> And the text highligher does't invert colors on this site, it just adds another shade of grey, that's at least a little funny :>
14:24:45 <zincy> any other suggestions welcome
14:25:04 <zincy> just exploring what is possible at the type level
14:25:30 <dmwit> zincy: Or possibly `type Foo a = Game (Stage a) (Vector Card (CardCount a)); class Progress a where type NextPhase a; progressGame :: Foo a -> Foo (NextPhase a)`.
14:25:32 <oni-on-ion> i store all my comments on irc 
14:25:48 <dmwit> zincy: With a type family `CardCount` that maps `PreDeal` to `Z`, etc.
14:26:16 <zincy> dmwit: is that the alternative syntax for type families - Progress
14:26:36 <dmwit> Progress is just a normal class. It's NextPhase that's a type family.
14:26:45 <zincy> the class syntax for typefamilies doesnt make sense to me 
14:26:54 <zincy> oh a normal typeclass
14:27:05 <oni-on-ion> when is a class of a type not a type of a class ?
14:27:19 <zincy> then Game would be made an instance?
14:27:26 <zincy> when its a kind class
14:27:51 <dmwit> zincy: In my latest proposal, the instances would be for PreDeal, PreFlop, Flop, Flop, Turn, and River.
14:27:52 <zincy> jk
14:28:12 <dmwit> s/Flop, //
14:29:24 <zincy> So each stage is a type synonym there?
14:29:33 <dmwit> No?
14:29:35 <zincy> PreDeal, PreFlop etc
14:29:50 <dmwit> I have not modified the definitions of PreDeal, PreFlop, etc. in my proposal.
14:31:15 <zincy> Are you referring to the promoted data constructors called PreDeal, PreFlop etc
14:31:22 <dmwit> Yes.
14:35:24 <dmwit> I don't understand why your Game constructors take Stage arguments.
14:35:49 <dmwit> All the Stage arguments are fully monomorphic, and only contain a Typeable dictionary for that monomorphic thing. So, like... just use that dictionary where you need it?
14:36:44 <zincy> dmwit: because then the Stage arguments can constrain the final type?
14:37:04 <dmwit> You can just do that. You don't need a field, too.
14:37:36 <dmwit> In fact, I'd get rid of Stage entirely, I think.
14:37:53 <zincy> Yeah
14:37:59 <zincy> good idea
14:38:15 <zincy> The GADT already does the job of constraining the type variables
14:38:46 <dmwit> Just `data Game (stage :: GameStage) (cardCount :: Nat) where PreDealGame :: Vector Card Z -> Game PreDeal Z; PreFlopGame :: Vector Card (Succ Z) -> Game PreFlop Z; {- etc -}`
14:39:32 <dmwit> ...but I don't really understand what these type indices are doing for you anyway.
14:40:44 <dmwit> (Like, shouldn't the Nat argument be completely determined by the GameStage argument? So why do you need both?)
14:42:20 <dmwit> (And then again, if you can decide the size of the Vector based only on the GameStage argument, why not have a type family for that and then use, say, `type Game stage = Vector Card (CardCount stage)`, or, if you really need the `stage` index around, `type Game stage = Tagged stage (Vector Card (CardCount stage))`?)
14:43:17 <zincy> Which type indices?
14:43:43 <dmwit> I expanded on what I meant in the following two parentheticals.
14:44:15 * dmwit disappears in a puff of smoke
14:44:42 <zincy> Yeah the GameStage indices are kinda pointless
14:46:16 <zincy> Thanks for the feedback
14:49:06 <zincy> Oh I think I see why the type indices are needed 
14:50:20 <zincy> NextGame or NextPhase typefamily needs it as it is the only way of determining what the next stage of the game would be in order to return the appropriate type
16:18:03 <___laika> is there any easy way to ignore a `cabal.project.freeze` file during development? id like to keep it generally checked into source control, but id prefer it be ignored for dev workflows
16:55:25 <dycan> hi all,   At compile time/type-level, is it possible to get a list of type class that a type has? So I can know in type-level what types has the same type class ...etc
16:59:51 <hpc> types and classes don't have that kind of relationship
17:00:32 <hpc> two major complications are multiparameter type classes, and type variables in instances
17:03:02 <dycan> hpc: I see now. Thanks for pointing it out.
17:03:36 <hpc> there might be something in template haskell, but i haven't seen it in my brief dips into that topic
17:04:36 <hpc> i think i would try and reframe the problem so there's an easier solution
17:06:42 <dycan> I see. I am just tring to get information at type-level, so I can classify which types have which type class.
17:08:37 <dycan> then I can do something like a type predicate shows if a type has type class A.
17:11:08 <dycan> hpc: Good advice. I'll review if I need this. Thanks!
17:16:25 <ski> dycan : you can ask `:info Eq' in the interactor
17:17:47 <ski> oh, and `:info Bool' will also show the classes `Bool' is an instance of (or rather, out of the classes currently in scope)
17:17:54 <ski> @instances Bool
17:17:57 <lambdabot> Couldn't find class `Bool'. Try @instances-importing
17:18:10 <ski> er, right
17:18:12 <ski> @instances Show
17:18:14 <lambdabot> (), (Data.Fixed.Fixed a), (IM.IntMap a), (Lens.Const a b), (M.Map k a), (S.Set a), (Shrink2 a), (a, b), (a, b, c), ASCIIString, All, AllocationLimitExceeded, Any, ArithException, Array a b, ArrayExcep
17:18:14 <lambdabot> tion, AssertionFailed, AsyncException, BlockedIndefinitelyOnMVar, BlockedIndefinitelyOnSTM, Bool, Char, CompactionFailed, Complex a, Constr, ConstrRep, DataRep, DataType, Deadlock, Double, Down a,
17:18:14 <lambdabot> Dual a, Dynamic, Either a b, ErrorCall, First a, Fixity, Float, Fun a b, GeneralCategory, IO a, IOException, IS.IntSet, Identity a, Int, Int16, Int32, Int64, Int8, Integer, Interval a, Large a, Last
17:18:14 <lambdabot> a, Level i a, MaskingState, Maybe a, NestedAtomically, NoMethodError, NonEmptyList a, NonNegative a, NonTermination, NonZero a, OrderedList a, Ordering, PatternMatchFail, Positive a, PrintableString,
17:18:14 <lambdabot>  Product a, Ratio a, RecConError, RecSelError, RecUpdError, SCC vertex, Shrinking s a, Small a, Smart a, SomeAsyncException, SomeException, StdGen, Sum a, Sym a, Tree a, TyCon, TypeError, UnicodeStrin
17:18:16 <lambdabot> g, Word, Word16, Word32, Word64, Word8, ZipList a, [a]
17:18:33 <ski> er .. that's a lot more than i thought it would show !?
17:18:57 <dycan> ski: Sure, I see. I am just looking a bit further:  to bring this list into type-level programming.  Thanks!
17:19:11 <ski> dycan : OWA
17:20:28 <dycan> what is WSA?
17:20:31 <dycan> OWA
17:21:39 <ski> Open-World Assumption
17:22:05 <ski> you can't know, in general, which types are *not* instances of type class
17:22:27 <ski> if you see an instance of a type, for a type class, then you know that instance exists
17:22:36 <ski> if you don't see an instance, that doesn't mean it doesn't exists
17:22:42 <ski> it might be defined in another module
17:23:28 <ski> and we'd like to keep separate compilation, where the compilation of a module doesn't necessitate knowing already about (and reading) all other modules that will be used in the program
17:23:55 <ski> also, if you're writing a library, then perhaps someone in the future will make an instance, and import your library. you can't know about that
17:24:41 <dycan> Okay, "It is possible to add instances for more and more types." OWA That makes sense. thanks for the enlightment.
17:24:56 <ski> so, the result is that, if there's an instance (in a module that will end up in the program), you can know about it (by finding that module. and all modules (transitively) importing it will also know the instance. including the `Main' module of the program)
17:25:07 <ski> but if there is no instance, then you will not know about that
17:25:51 <dycan> Coo, so it seems I can't make sure how many instance a type has and how many types a type class has, in type-level.
17:25:53 <dycan> Cool
17:26:06 <ski> btw, the terms OWA and CWA also appear in logic programming, and knowledge bases (AI term). .. and i think one could also apply them to relational data base relations/tables
17:26:29 <rg_[m]> does that energy performance bench mark worry anyone here?
17:29:55 <hpc> link?
17:30:45 <dycan> ski: relations! that's exactly what I am interested in now. Have you heard of project-m36? I was trying to see if I can make a Relation type. Just do it for fun. That leads me to this type class question.
17:32:58 <ski> dycan : no, what's that ?
17:33:31 <rg_[m]> hpc, the link is in the article https://thenewstack.io/which-programming-languages-use-the-least-electricity/
17:34:02 <dycan> ski: It adheres strictly to the mathematics of the relational algebra.
17:34:32 <hpc> neat
17:35:26 <ski> dycan : btw, if you know a little about relational data base theory, specifically normal forms, then you might be interested in learning that one can declare functional dependencies on (multiple parameter) type classes
17:36:28 <MarcelineVQ> Doesn't seem so worrying
17:36:41 <ski> dycan : do you mean it's an implementation of D, a la The Third Manifesto ?
17:36:49 <ski> dycan : or, perhaps, it's more related to Datalog ?
17:37:03 <boj> rg_[m]: mildly interesting at best
17:39:02 <dycan> ski: I know not much. But yes, I think it's an implementation of D. https://github.com/agentm/project-m36 has better explanation.
17:39:36 <hpc> haskell doesn't seem to do that poorly
17:40:28 <hpc> if you look at the normalized results table instead of whatever that top graph is
17:40:47 <dycan> ski: what I like it is:  I am an amatuer of database. I always found database are hard to understand. and I saw Chris Date's database and get hooked on relational algebra and this project.
17:40:50 <hpc> they don't seem to line up
17:43:40 <dycan> ski: I guess you will be interested in it too since you mention relational database.
17:46:25 <rg_[m]> ok, yeah that graph is catchy
18:17:37 <adamCS> If I have a library and some executables as examples, all specified in the same cabal file, do the dependencies of the executables become dependencies of anything that depends on the library?  This is a "cabal-version: 2.2" cabal file.
18:19:36 <lyxia> technically no but I'm not sure how to install only the library
18:20:49 <adamCS> Hmm. So when I indicate that the package is a dependency I am sort-of saying that I need all the things? 
18:21:18 <adamCS> Because the executabel could be a tool I actually need for something rather than an example?
18:21:37 <adamCS> Should I make the examples into tests to avoid that?
18:22:36 <adamCS> I guess maybe I'm asking which is worse form:  to have examples that require out-of-date versions of things or to make examples look like tests?
18:23:28 <adamCS> That wasn't clear: rather, examples that require library-users to use older versions of other dependencies than the library itself requires?
18:25:42 <lyxia> I don't think examples should be executables in the package, that being the main technical reason.
18:25:58 <lyxia> Either tests or a separate (possibly unreleased) package.
18:26:25 <adamCS> Okay.  That makes sense.  Making them tests is straightforward enough.  Thanks!
18:28:51 <jusss> data Reader r a = Reader {  runReader :: r -> a } , this means `data Reader r a = Reader r->a ` and `runReader Reader x = x` ?
18:29:13 <jusss> and x is r->a ? this is possible? 
18:29:53 <jusss> a function's type signature show up in a data type definition?
18:31:04 <geekosaur> need extra parens for both of those. (and there's also a pattern matching component)
18:31:51 <jusss> I don't understand what you mean
18:32:24 <geekosaur> data Reader r a = Reader (r -> a); runReader (Reader x) = x
18:33:04 <jusss> geekosaur: yeah, that's what I mean, and r->a shows up in data type is ok?
18:33:23 <geekosaur> the pattern matching aspect is that you could write the second one as: runReader (Reader {runReader = x}) = x
18:33:36 <ski> `x' has type `r -> a' there, yes
18:33:38 <geekosaur> and yes, function types are perfectly permissible types
18:33:54 <geekosaur> that's kinda the point of a functional language, functions are first class types
18:33:54 <ski> functions are values, too
18:34:00 <geekosaur> and values
18:34:06 <ski> s/types/values/
18:34:10 <jusss> wow, that's wonderful!
18:34:33 <ski> (function types are first class types)
18:34:39 <geekosaur> "types" is also true, but I tend to think of C first and C functions are especially woeful
18:34:55 <jusss> but that means Reader come with any unary function, that would be Reader type, right?
18:35:07 <geekosaur> when its wrapped in the Reader constructor
18:35:31 <geekosaur> although this is complicated by the fact thaat you get a slightly simpler Reader-like abstraction from bare functions
18:35:38 * ski hopes jusss knows the difference between data constructor and type constructor
18:35:46 <jusss> Reader (\x->x)   and Reader (\x->1) are both Reader r a  type?
18:35:59 <jusss> ski I did
18:36:13 <geekosaur> that is, there are various instances for (r -> a) without the Reader wrapper. but you don't have "ask" or "asks" to request all of part of the environment
18:36:16 <ski> jusss : in the former case, if `x' has type `r', then `Reader (\x -> x)' has type `Reader r r'
18:36:41 <ski> jusss : in the latter case, if `x' has type `r', and `1' has type `Integer' (say), then `Reader (\x -> 1)' has type `Reader r Integer'
18:37:04 <ski> jusss : so you know that there's two different things called `Reader', above, yes ?
18:37:27 <ski> .. and they could have been named differently, not the same as each other
18:37:29 <jusss> ski yeah, one is type constructor, and another is value constructor
18:38:02 <ski> e.g. `data Reader r a = MkReader (r -> a)', then `MkReader' would be the data constructor, but `Reader' is still the type constuctor
18:38:11 <jusss> ski but that means any unary function come with Reader, like Reader f, it means it's Reader r a type, right?
18:38:40 <ski> and then `MkReader (\x -> x)' would have type `Reader r r', and `MkReader (\x -> 1)' would have type `Reader r Integer', if we follow the same reasoning as i did just above
18:38:44 <jusss> geekosaur: ski I wonder is there a function without parameter can be exist in haskell?
18:39:01 <ski> jusss : all functions in Haskell are uniart
18:39:03 <jusss> ski yeah, I do
18:39:13 <ski> er, s/uniart/unary/
18:39:27 <jusss> ski so there's no such that function right?
18:39:29 <geekosaur> that's a little complex. technically every function has one parameter; if it appears to have multiple, it actually returns a function that takes the next parameter, etc.
18:39:38 <ski> jusss : no such function as what ?
18:40:00 <geekosaur> and som ething with apparently no parameters is a "constant applicative form". it can still be an expression; laziness means it's only evaluated when needed, so acts like a zero-parameter function
18:40:07 <jusss> geekosaur: ski  f = ()=> do-whatever
18:40:09 <ski> jusss : if `f' has type `r -> a', then `MkReader f' has type `Reader r a'
18:40:28 * ski doesn't follow what jusss just said
18:40:30 <geekosaur> but it does have some special attributes, notably with respect to sharing
18:40:42 <jusss> ski a function without any parameter
18:40:48 <ski> no such thing in Haskell
18:41:05 <ski> all functions in Haskell take exactly one input
18:41:16 <jusss> ski but there're lots of that functions in python and js and C and whatelse languages
18:41:22 <ski> sure
18:41:34 <ski> those language has multiple-argument functions. Haskell doesn't
18:41:42 <ski> but, we tend to pretend it has ..
18:42:01 <ski> .. because one can easily *encode* multiple-argument functions .. in two different ways, nonetheless
18:42:16 <ski> you can say
18:42:31 <ski>   tupledPyth :: (Double,Double) -> Double
18:42:49 <ski>   tupledPyth (x,y) = sqrt (x**2 + y**2)
18:42:53 <ski> or you can say
18:43:13 <ski>   curriedPyth :: Double -> (Double -> Double)
18:43:19 <ski>   curriedPyth x y = sqrt (x**2 + y**2)
18:43:44 <jusss> curriedPyth x  = \y -> sqrt (x**2 + y**2)
18:43:44 <ski> the latter encoding tends to be more common, in Haskell
18:43:51 <ski> yes, that's the same thing
18:44:06 <ski> and because the latter is more common, one can write the type signature there as
18:44:10 <ski>   curriedPyth :: Double -> Double -> Double
18:44:14 <ski> but it means the same thing
18:44:35 <ski>   curriedPyth = \x -> \y -> sqrt (x**2 + y**2)
18:44:40 <ski> one can abbreviate this as
18:44:44 <ski>   curriedPyth = \x y -> sqrt (x**2 + y**2)
18:44:49 <ski> and obviously one can also write
18:44:58 <ski>   tupledPyth = \(x,y) -> sqrt (x**2 + y**2)
18:45:31 <ski> `tupledPyth' also takes a single input
18:45:37 <ski> but that input happens to be a pair
18:45:55 <ski> and by using pattern-matching on that pair, we can directly give names `x' and `y' to the two components of the pair
18:46:16 <ski> so that it "looks like" we're having multiple parameters like in C or something ..
18:47:46 <jusss> yeah, that seems good
18:48:23 <jusss> I'm learning the reader monad, it confused me a few days,
18:55:33 <jusss> >>=:: Reader (e->a) -> ( (e->a) -> Reader (e->b) ) -> Reader (e->b) , right?
18:55:55 <jusss> and Reader is monad, and a is e->a, b is e->b
19:05:33 * ski blinks
19:08:26 <ski> @tell jusss no, `Reader' (curriedly) takes two parameters. so `>>=:: Reader (e->a) -> ( (e->a) -> Reader (e->b) ) -> Reader (e->b)' is nonsense. also the middle `e->a' ought to be just `a'. the signature ought to be `(>>=) :: Reader e a -> (a -> Reader e b) -> Reader e b', which, yes, would amounts to `(>>=) :: (e -> a) -> (a -> (e -> b)) -> (e -> b)', if you unwrapped the `Reader's
19:08:26 <lambdabot> Consider it noted.
19:35:04 <jusss>  >>=:: Reader r a -> (a -> Reader r b) -> Reader r b, right?
19:36:05 <jusss> ski sorry, I wasn't here before
19:36:12 <jusss> I saw your messages
20:06:45 <ski> jusss : yes, except it should be `(>>=)'
20:08:33 <jusss> ski: and in Reader (e->a), Reader e-> is the moand
20:08:54 <jusss> Reader e is the monad, not Reader
20:09:11 <ski> `Reader (e->a)' is not a concrete type
20:09:30 <ski> `Reader e ->' is nonsense
20:09:37 <ski> `Reader e' is the monad, yes
20:10:34 <ski> in `(>>=) :: m a -> (a -> m b) -> m b', you replace the monad parameter `m' with the specific monad `Reader e'
20:10:53 <jusss> ski like your said `(>>=) :: (e -> a) -> (a -> (e -> b)) -> (e -> b)', if you unwrapped the `Reader', I don't know can we remove the Reader value constructor in the >>= type signature
20:11:56 <jusss> (e->a) is not same as Reader (e->a) I think
20:12:07 <ski> <ski> `Reader (e->a)' is not a concrete type
20:12:19 <ski> you can't say `x :: Reader (e -> a)', that's nonsense
20:12:25 <ski> (but `x :: e -> a' is not nonsense)
20:12:34 <jusss> why
20:12:46 <ski> the definition is
20:12:49 <ski> @src Reader
20:12:50 <lambdabot> type Reader r = ReaderT r Identity
20:12:50 <lambdabot> --OR
20:12:50 <lambdabot> data Reader r a = Reader { runReader :: r -> a }
20:13:01 <ski> well, say the latter of those
20:13:16 <ski> there is both an `r' and an `a' parameter
20:13:33 <ski> if you say `Reader (e -> a)', that means you've specified the `r' parameter as `e -> a'
20:13:40 <ski> but you haven't specified the `a' parameter at all
20:13:54 <ski> `Reader (e -> a)' is not at all the same as `Reader e a'
20:13:57 <ski> don't confuse the two
20:14:23 <ski> if you say `Reader e a', then a value of that type contains a value of type `e -> a'
20:14:42 <ski> if you say `Reader (e -> a) b', then a value of that type contains a value of type `(e -> a) -> b'
20:15:12 <ski> (and there are no, *can't* be any, values of type `Reader (e -> a)', because that's not a concrete type)
20:15:46 <jusss> ski: so Reader (e->a) is actually Reader r, not Reader r a, right?
20:15:58 <jusss> 'cause (e-a) is r, not r a
20:16:36 <ski> (just like you can't have any values of type `Maybe', or of type `[]' .. you can't say `x :: []' .. `x' is a list of elements of *what* element type ? .. but you can say `x :: [] Int' (which has sugar `x :: [Int]'), and you can say `x :: Maybe Int'
20:17:13 <ski>  `[] Int' and `Maybe Int' are concrete types. `[]' and `Maybe' (and `Reader (e -> a)') are not concrete types. they are still "waiting for"/"expecting" an actual parameter)
20:17:51 <ski> `Reader (e -> a)' matches with `Reader r', if `e -> a' matches with (is equal to) `r', yes
20:17:54 <jusss> ski: and Reader (e->a) :: Reader r ? wait for a type to complete?
20:18:12 <ski> `Reader (e -> a)' can't be compares to `Reader r a', just like `False' can't be compared to `Nothing'
20:18:54 <ski> `False' has type `Bool', `Nothing' has type `Maybe a' (for any type `a'). the types `Bool' and `Maybe a' are different. you can't compare values from different types with each other
20:19:02 <jusss> ok, so Reader r is the monad, and the monad's value is like Reader (e->a)
20:19:28 <ski> similarly, the "kind" of `Reader (e -> a)' is `* -> *', while the "kind" of `Reader r a' is `*'
20:19:47 <ski> `* -> *' and `*' are different kinds, and you can't compare types belonging to different kinds
20:19:48 <jusss> can we retur to the >>=
20:20:09 <ski> `Reader (e->a) :: Reader r ?' is nonsense
20:20:25 <jusss> ok monad is nonsense
20:20:32 <ski> <jusss> ok, so Reader r is the monad, and the monad's value is like Reader (e->a)
20:20:37 <ski> also sounds like nonsense, to me
20:20:45 <ski> "monad's value", what's that ?
20:20:51 <jusss> a in m a
20:20:57 <jusss> not
20:21:10 <ski> i think that you writing `Reader (e -> a)' in the first place is a mistake, a misunderstanding
20:21:15 <jusss> like Just 3 is Maybe Int
20:21:53 <ski> (one *might* sometimes have a use for `Reader (e -> a)' .. but you've not shown to me here that there's be any use of using that here. so i believe you're mentioning it, because you're somewhat confused)
20:22:05 <ski> `Just 3' has type `Maybe Int'
20:22:18 <jusss> ski I just want to know >>=:: (e->a) -> (a->(e->b)) -> (e->b) when monad is (e->) and they told me that's Reader Monad
20:22:20 <jmorris> jusss: 'a' is more like a type than a value
20:22:29 <ski> if `m' is a monad, and `a' a type, then a value of type `m a' is called an `m'-action, or just an action for short
20:22:53 <ski> (for it's not a value of type `m', that's nonsense. it's not a "value of a monad")
20:23:22 <jmorris> ski: Isn't 'm' just a functor from a -> a?
20:23:38 <jmorris> and endofunctor
20:23:53 <ski> no
20:24:04 <ski> a functor from `*' to `*'
20:24:15 <ski> there is no "function from `...'"
20:24:19 <ski> er
20:24:23 <ski> there is no "functor from `...'"
20:24:34 <ski> there can be "functor from `...' to `...'"
20:24:45 <ski> you have to have both a "from" and a "to"
20:24:50 <jmorris> ski: Isn't that what i said
20:24:53 <jmorris> m : a -> a
20:25:01 <ski> no, you said "from a -> a"
20:25:08 <ski> `a -> a' is a single thing, not two things
20:25:14 <jmorris> Right, i see what you mean
20:25:16 <ski> `->' is not the english word "to"
20:25:24 <jmorris> Yeah, thats how i was reading it
20:25:35 <ski> also, if `a' is a type variable there, then "functor from `a' to `a'" is still wrong
20:25:36 <jusss> ski Reader (e->a) 's type is ?
20:25:56 <ski> because it shouldn't be from a type, to a type, but from a *kind* to a *kind*
20:26:06 <jmorris> ski: Why is that?
20:26:11 <ski> `Reader (e -> a)' is not a value. it doesn't have a type
20:26:17 <ski> it is a type, it has a kind
20:26:25 <ski> the kind of it is `* -> *'
20:26:30 <ski> @kind Int
20:26:32 <lambdabot> *
20:26:34 <ski> @kind Maybe Int
20:26:36 <lambdabot> *
20:26:36 <ski> @kind Maybe
20:26:37 <lambdabot> * -> *
20:26:44 <jmorris> Ohhh
20:26:47 <ski> @kind Reader [String] Int
20:26:48 <lambdabot> *
20:26:49 <ski> @kind Reader [String]
20:26:50 <lambdabot> * -> *
20:26:51 <ski> @kind Reader
20:26:52 <lambdabot> * -> * -> *
20:27:25 <jmorris> ski: so 'a' can be a functor?
20:27:37 <jmorris> is that what you mean?
20:27:43 <ski> if it has a kind that looks like `... -> ...', yes
20:27:49 <ski> but not if it has kind `*'
20:27:55 <jmorris> ski: Which would make 'm' a natural transformation!
20:28:02 <jusss> Reader (\x->x) is a value to you?
20:28:12 <jusss> does it have a type?
20:30:00 <ski> jusss : which definition of `Reader' are you using, currently ?
20:30:21 <ski> jmorris : which `m' ?
20:30:48 <jmorris> ski: m : a -> a, where a : * -> *
20:31:10 <jmorris> Can a natural transformation even be a monad?
20:31:11 <ski> jmorris : ok, so you're not talking about Haskell here, but CT, yes ?
20:31:27 <jmorris> ski: I suppose yeah
20:32:01 <jusss> ski Reader r a = Reader (r->a)
20:32:24 <ski> jusss : did you mean to start that with `data' or `newtype' ?
20:32:34 <jusss> data
20:32:38 <ski> ok, so
20:32:45 <ski>   data Reader r a = Reader (r -> a)
20:32:51 <ski> i now rename this to
20:32:54 <ski>   data Reader r a = MkReader (r -> a)
20:33:18 <ski> in order to have different names for the data constructor and the type constructor, so that we don't run the risk of confusing them
20:33:34 <ski> jusss : now, can you restate your last question, in terms of this modified type definition ?
20:34:14 <jusss> what is MkReader (\x->x)'s type
20:34:27 <ski> jmorris : a monad is an endofunctor, together with two (particular) natural transformations satisfying three (particular) laws
20:34:35 <ski> jmorris : that's a value, yes
20:35:23 <ski> <ski> jusss : in the former case, if `x' has type `r', then `Reader (\x -> x)' has type `Reader r r'
20:35:32 <ski> <ski> jusss : in the latter case, if `x' has type `r', and `1' has type `Integer' (say), then `Reader (\x -> 1)' has type `Reader r Integer'
20:35:36 <ski> <ski> jusss : so you know that there's two different things called `Reader', above, yes ?
20:35:41 <ski> <ski> .. and they could have been named differently, not the same as each other
20:35:47 <ski> <ski> e.g. `data Reader r a = MkReader (r -> a)', then `MkReader' would be the data constructor, but `Reader' is still the type constuctor
20:35:55 <ski> <ski> and then `MkReader (\x -> x)' would have type `Reader r r', and `MkReader (\x -> 1)' would have type `Reader r Integer', if we follow the same reasoning as i did just above
20:36:00 <___laika> anyone using IOHKs haskell.nix instead of the traditional workflows? https://input-output-hk.github.io/haskell.nix/architecture/
20:36:14 <ski> jusss : that should answer your current question
20:37:26 <jusss> ski: MkReader (\x->x) has the type Reader r a, and what thing has the type Reader r ?
20:37:37 <ski> er, sorry, i meant to say, before
20:37:46 <ski> jusss : that's a value, yes
20:38:08 <ski> jmorris : so, if you want a natural transformation to be a monad, then it first has to be a functor
20:38:40 <ski> jmorris : a natural transformation `eta' is generally a morphism from `F' to `G', for some two functors `F' and `G', both from `C' to `D' (being two categories)
20:39:17 <ski> jmorris : so if `eta' is to be a functor, that means that `F' and `G' must be categories .. so you must then have two functors which you can regard as categories
20:39:30 <jmorris> ski: Is a natural transformation a functor in the functor category
20:39:31 <ski> jmorris : .. and i'm not seeing how that could work
20:39:53 <ski> no, a natural transformation is a morphism in a functor category
20:40:04 <jusss> ski sorry, I don't follow, and what thing has the type Reader r?
20:40:20 <jmorris> ski: so a natural transformation cant be a monad because its not a functor, that makes sense
20:40:26 <ski> the objects in that category (write it `D^C') are functors (from `C' to `D',say). natural transformations are the morphisms between these objects
20:40:50 <ski> jusss : "what thing has the type Reader r?" -- no !
20:41:12 <benzrf> `Reader r' is not a type :O
20:41:13 <ski> jusss : that question is incorrect, nonsense. the question has a type error. it's an invalid question. you can't ask it
20:41:22 <ski> (is not a *concrete* type)
20:41:46 <benzrf> im not a huge fan of "concrete" meaning "has kind *"
20:41:59 <ski> jusss : the type `Reader r' is not concrete, is not *capable* of having values. you can't ask what values of it could be, that's wrong
20:42:01 <jusss> (e->) is a monad, and what 's the monad  in that
20:42:09 <benzrf> i mean it's not as though we call integers concrete values or something
20:42:46 <ski> a type `T' is concrete it it makes sense to consider `x :: T', for a variable `x'
20:42:51 <benzrf> i hear "concrete" and i start to imagine "polymorphic as opposed to monomorphic" or something
20:43:02 <benzrf> as opposed to "not a type-level thing which is in fact a type"
20:43:11 <benzrf> jusss: it's for the same reason that "Maybe" is not a type
20:43:25 <benzrf> "Maybe Int" and "Maybe String" are types, but "Maybe" is a type *constructor*
20:43:32 <ski> "concrete values" doesn't make sense in this regard, since if `v' is a value, then `x :: v' can't make sense. you can't put a value to the right of `::'
20:43:34 <benzrf> you can apply it to other types to get a type
20:43:45 <benzrf> ski: you're taking my analogy too literally :P
20:43:53 <glguy> I haven't really used Docker to do much yet. I'm thinking that it would be a really nice way to configure CI for my IRC client. This is what I have so far that same to work OK. I'm wondering if anyone has suggestions or feedback regarding what I might do differently if anything: 
20:43:54 <glguy> https://gist.github.com/glguy/b9da02f5483084d2aeefaf7af807dc26
20:44:54 <ski> benzrf : anyway, you can consider `x :: Int#', but `Int#' doesn't have kind `*', but rather `#'. so not all concrete types have kind `*'
20:45:01 <benzrf> oh shoo
20:45:32 <benzrf> fine, "exists w. TYPE w"
20:45:34 <benzrf> :-)
20:45:38 <glguy> Maybe and Int are both type *constructors*
20:45:48 <benzrf> sighhh
20:46:04 <benzrf> okay fine that's tru
20:46:06 <benzrf> e
20:46:27 <ski> (but `Either String' is not a type constructor)
20:47:11 <glguy> nor is it a type variable
20:47:16 <ski> (all type constructors are types)
20:47:19 <maerwald> glguy: less RUNs, ideally just one imo. And clean up the hackage tarball and everything you don't need after v2-update, v2-build. Also clean up after apt, e.g. /var/lib/apt/lists
20:47:33 <benzrf> ffff
20:47:36 <ski> (all data constructors are values)
20:47:42 <benzrf> okay forget i said "type constructor" ;_;
20:47:59 <glguy> maerwald: Do you have a favorite example of doing that cleanup?
20:48:11 <glguy> Just delete the files?
20:48:24 <maerwald> https://docs.docker.com/develop/develop-images/dockerfile_best-practices/
20:48:29 <maerwald> rm -rf /var/lib/apt/lists/*
20:48:52 <maerwald> of course, in the same RUN
20:50:07 <ski> jmorris : maybe it can. i don't know. i don't see how a functor can be a category, though
20:50:21 <ski> <jusss> (e->) is a monad, and what 's the monad  in that
20:50:33 <jmorris> ski: It can't
20:50:34 <ski> jusss : the monad is `(e ->)'
20:51:23 <jmorris> ski: Because a functor doesn't have morphisms, so it can't be a functor
20:51:41 <jmorris> I mean
20:51:49 <jmorris> it can't be a category
20:52:32 <jmorris> because for a natural transformation to be a functor it would need to map morphisms in functor F to functor G
20:52:35 <jmorris> which doesn't make sense
20:53:22 <jmorris> *to morphisms in functor G
20:53:58 <glguy> maerwald: Thanks
20:57:37 <jusss> ski I do mess up with type and value, but not by the names, in function type signature, I don't know what (e->a) any more , a type or a value , so I can know what e-> is
21:12:45 <ski> @tell jusss `e -> a' is a type (a function type). not a value. it's the same thing as `(->) e a'. this is a concrete type, having kind `*'. otoh `(->) e' (aka `(e ->)') is not a concrete type, it's a type of kind `* -> *' (and finally `(->)' is also not concrete, being a type of kind `* -> * -> *')
21:12:45 <lambdabot> Consider it noted.
21:18:36 <MarcelineVQ> idk if people actually check tells, that would be an interesting stat to get out of lambdabot, best not to rely on them if you care about repeating yourself :> tells themselves are reliable, but a person being aware of needing to check them isn't
21:19:23 <MarcelineVQ> Ah I see in the scrollback that he got the message, that's a good sign :D
21:19:24 <dmwit> lambdabot informs you that you need to check them and how to do it.
21:19:39 <dmwit> ?tell MarcelineVQ Here's what it looks like.
21:19:39 <lambdabot> Consider it noted.
21:19:53 <dmwit> (now say something ;-)
21:20:33 <MarcelineVQ> ehe I know, I've tested it in the past :> But humans aren't always so attentive
21:29:40 <ski> @messages-loud
21:29:41 <lambdabot> You don't have any messages
22:07:51 <nitrix> ?tell lambdabot ?tell ski Test :D
22:07:51 <lambdabot> Nice try ;)
22:08:06 <nitrix> Clever monkeys.
22:27:53 <___laika> any nix-using haskellers online? im having some issues using some nix-haskell stdlib functions
22:28:19 <___laika> namely, im putting packages into the argument for shellFor in my shell.nix, but im not getting access to those packages
22:28:23 <___laika> https://gist.github.com/matthewess/6848331be03882a5998bf577253658cc
22:36:03 <cocreature> ___laika: putting a package in packages gives you an environment for _building_ that package. it doesn’t bring the package itself into scope
22:36:04 <___laika> ooof
22:36:09 <___laika> yes
22:36:17 <___laika> ive just fully read the comment documenting it
22:36:20 <___laika> cocreature++
22:36:26 <___laika> ___laika--
22:37:43 <___laika> cocreature: looks like i probably want to pass arguments to go back to one of these? https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/haskell-modules/make-package-set.nix#L303-L304
22:38:40 <cocreature> ___laika: if you do something like `nix-shell -E "with import <nixpkgs> {}; haskellPackages.shellFor { packages = p: [p.generics-sop]; buildInputs = [haskellPackages.hlint]; }"` you get an environment for building generics-sop and you get hlint in scope
22:39:03 <___laika> cocreature++ perfect, exactly what i needed :) thank you
22:58:38 <qwebirc559> yo how do I install curl
22:58:44 <qwebirc559> on a mac
22:59:02 <qwebirc559> so that I can install ghcup
23:00:54 <jgt> brew install curl
23:00:57 <jgt> or
23:01:00 <jgt> nix-env -i curl
23:01:10 <jgt> you need to have homebrew or nix installed
23:01:47 <jusss> (e->a) is a type not a value, and \x->x is a value not a type, right?
23:02:02 <jusss> so what's the type (e->a)'s value
23:03:42 <jle`> there are values of you pick specific e's, a's
23:03:48 <jle`> for example, the `not` function has type Bool -> Bool
23:03:51 <jle`> :t not
23:03:52 <lambdabot> Bool -> Bool
23:04:08 <jle`> the 'ord' function has type Char -> Int
23:04:10 <jle`> :t ord
23:04:11 <lambdabot> Char -> Int
23:05:00 <jle`> a lot of values in haskell have function types, actually :)
23:05:53 <jgt> commonly referred to as "higher order functions", unless I'm wildly confused
23:05:55 <jusss> jle`: data Maybe a = Just a | Nothing,    so data (->) e a = ?
23:06:01 <jgt> (which I often am, especially before coffee)
23:06:09 <jle`> jgt: no, i mean, just functions
23:06:24 <jle`> any-order :)
23:06:31 <jle`> jusss: (->) is not an algebraic data type
23:06:35 <jle`> it's an abstract data type
23:06:39 * jgt immediately starts coffee machine
23:06:48 <jle`> so you can't define it using Algebraic Data Type syntax
23:07:28 <jusss> jle`: so what is a abstract data type?
23:07:42 <jle`> it's a type where you don't really know about how it is implemented
23:07:45 <jle`> only its external API
23:07:49 <jusss> and can we use abstract data type in algebraic data type?
23:08:20 <jle`> an algebraic data type is a type that can be made out of sums (different constructors) and products (multiple values in a constructor)
23:09:12 <jle`> in general, not all types can be broken down so cleanly
23:09:17 <jle`> (->) is such a case
23:09:38 <jusss> jle`: and what else?
23:09:46 <jusss> other cases I mean
23:09:48 <jle`> it's 'abstract' in the sense that when we use a value of type (a -> b), we don't care about how it is implemented, just the external API/operations we have on it
23:10:09 <jle`> for functions, the main usage is "function application"
23:10:21 <jle`> so if i have a function 'f :: Int -> Bool', i can apply it to an Int, like 'f 8'
23:10:55 <jle`> i don't need to know anything about how f is implemented, i just need to know that i can apply it to 8
23:11:24 <jle`> we can also consider lambda syntax as a method of constructing functions, as well
23:11:34 <jle`> and things like defining top-level bindings
23:12:42 <jusss> jle`: wait a sec, data Maybe a = Just a| Nothing, ok, we can't put Maybe on the right part of '=' without another type constructor, right? like T a = Maybe a is not ok, but we can do T a = V (Maybe a) right?  so what about this special type (e->a), 
23:13:03 <jusss> can we put this type (e->a) in the left part of '=' in data type definition?
23:13:19 <jle`> data Maybe a = Just a | Nothing, we are defining a *new* type called Maybe, with two constructors, Just and Nothing
23:13:22 <jusss> and do we need a value constructor before it?
23:13:31 <jle`> data T a = Maybe a is legal, we are defining a *new* type called T, with one constructor, Maybe
23:13:52 <jle`> this constructor Maybe is unrelated to any Maybe type, so it can be a bit confusing
23:13:57 <jle`> it's a data constructor here
23:14:00 <jusss> jle`: but this has nothing to do with the old Maybe
23:14:04 <jle`> like data MyType a = MyConstr a
23:14:06 <jle`> yes
23:14:31 <jusss> jle`: yes, so what about the (e->a)
23:14:40 <jle`> syntactically you can define data types with type constuctors that are operators, like data (:+:) a b = ... is allowed
23:14:49 <jle`> but i'm saying that (->) doesn't have a definition in terms of ADT syntax
23:15:21 <jle`> so you can use an operator as a type constructor...but ADT syntax only is useful if you want to define your type using some form of algebraic data type
23:15:48 <jle`> but (->) cannot be represented. the problem isn't the lhs, it's that there's no sensible rhs that would give you the 'function type'
23:15:53 <jusss> jle`: ok, I wonder how can I use this (e->a) in the data type definition? not how to define it in the data type definition
23:16:11 <jle`> data Endo a = Endo (a -> a)
23:16:15 <jle`> is a common type with a field that is a function
23:16:26 <jusss> jle`: and data Endo a = (a->a) is ok?
23:16:28 <jle`> (it's actually a newtype, in Data.Semigroup)
23:16:49 <jle`> jusss: no, becuase (->) is not a valid identifier for a data constructor
23:16:54 <jle`> but also they are different types
23:17:20 <jle`> even if you did data Endo a = a :->: a, defining a *new* data constructor :->:
23:17:26 <jusss> jle`: so if (e->a) shows up on the right part of '=', we do need a value constructor, right?
23:17:37 <jle`> that Endo type would be a different type
23:17:43 <jle`> it'd be basically a tuple
23:17:58 <jle`> jusss: well, we need a value constructor if we want a field with some known type
23:18:02 <jle`> e -> a isn't special here
23:18:05 <jle`> it's the same for Int, or Bool
23:18:09 <jle`> data Any = Any Bool
23:18:25 <jle`> here we are defining a data type Any, with a single constructor Any, with a single field that is a Bool
23:18:26 <jusss> jle`: ok, but that (e->a) can be show up in the left part of '=' ?
23:18:56 <jle`> the left hand side is *defining* a new type constructor
23:18:58 <jusss> jle`: it can't, right?
23:19:00 <jle`> it's not using any existing type constructors
23:19:12 <jle`> so even if -> was a valid identifier, it would be defining a *new* type
23:19:17 <jle`> not using an existing type
23:19:28 <jle`> for example, i can write `data Int = Blah String`
23:19:36 <jusss> ok, so (e->a) is only used on the right part of '='
23:19:38 <jle`> i'm basically defining a new data type called Int that is shadowing Int from prelude
23:19:57 <jle`> function types are nothing special here, they follow the same rules as any other type
23:20:09 <jusss> and we don't have the definition of (e->a)
23:20:35 <jle`> the basic syntax is `data <TyCon> <var1> <var2> = <Con1> <field1a> <field2a> | Con2 <field2a> ..., etc.
23:20:52 <jle`> right, (->) isn't defined using ADT syntax anywhere
23:20:54 <jle`> since it isn't an ADGT
23:20:55 <jle`> * ADT
23:21:20 <jle`> you could say that it is built into the language
23:21:35 <jle`> but, a lot of "built-in" types are indeed ADTs, so that might not be helpful
23:23:54 <jusss> jle`: that function type is really special
23:24:34 <jle`> in terms of implementation? it definitely is :)
23:24:51 <jle`> but as a type that you use and construct values of, it's not particularly special
23:25:37 <jusss> jle`: so when monad is (e->) what this >>=:: (e->a) -> (a->(e->b)) -> (e->b) has to do with Reader Monad?  'cause Reader Monad do have a type constructor or value constructor called Reader
23:25:55 <jle`> the only thing special about it is the internal implementation, really.  as a type-level thing it isn't different than any other type level thing, and values of type function aren't different than values of any other type
23:26:12 <jle`> that's the nice thing about abstract data types
23:26:19 <jle`> we don't have to understand how they are implemented, in order to use them
23:26:35 <jle`> it gives us a uniform interface for working with all values, of many different types
23:27:18 <jle`> jusss: 'Reader' is a common synonym for (->), which helps emphasize some conceptual aspects of how you use (->)
23:27:36 <jle`> for Reader, (>>=) :: Reader e a -> (a -> Reader e b) -> Reader e b
23:27:49 <jle`> which, if you take `type Reader = (->)`, is exactly the same as for (->) e
23:27:52 <jusss> jle`: but Reader is not (->) right?
23:28:01 <jusss> Reader is a algebraic data type
23:28:21 <jle`> eh, Reader is essentially a synonym for (->)
23:28:29 <tdammers> yes, but it's isomorphic with (r->)
23:28:30 <jle`> might be hidden behind a newtype wrapper in some libraries
23:28:45 <tdammers> indeed, mtl newtypes it IIRC
23:29:03 <jle`> but really you can imagine `type Reader = (->)` (a type synonym) in this situation
23:30:59 <jle`> if you interpret `Reader e a` as "an a, but which is waiting for an 'e' input"
23:31:26 <jle`> then (>>=) :: Reader e a -> (a -> Reader e b) -> Reader e b means that if you have an 'a' waiting for an e, and a function from an 'a' to a 'b' waiting for an 'e', then you have a 'b' waiting for an 'e'
23:31:58 <jusss> jle`: so what this type Reader e's value looks like?
23:32:03 <jle`> it lets you apply the (a -> Reader e b) to the "future a" in `Reader e a`
23:32:14 <jle`> jusss: well, if we take `type Reader = (->)`
23:32:20 <jle`> then for example, not :: Reader Bool Bool
23:32:24 <jle`> ord :: Reader Char Int
23:32:33 <jle`> even :: Reader Int Bool
23:32:45 <jusss> Reader r a = Reader {  runReader :: r -> a }
23:32:45 <jle`> length :: Reader [a] Int, etc.
23:32:53 <jle`> that's another definition of Reader
23:33:04 <jusss> data Reader r a = Reader r->a 
23:33:33 <jusss> what data Reader r = ?
23:33:57 <jle`> my definition i am using is `type Reader = (->)`
23:34:08 <jle`> but data Reader r a = Reader (r -> a) is another common one, yes
23:34:22 <ski> jusss : not `data Reader r = ...'
23:34:30 <ski> (also you were missing brackets)
23:34:32 <ski> jusss : `Char',`Int',`Integer',`Float',`Double',`Array',`IO',`IORef',`IOArray' are also abstract data types, not just `(->)'
23:35:39 <jusss> oh, my fault, data Reader r a = Reader (r->a) there're two type variables and one value
23:36:10 <jusss> this (r->a) is one value, it need two variables
23:36:38 <jusss> so Reader r = Reader (->) r  is not right
23:36:39 <ski> jusss : the implementation of those abstract data types are provided by the language. just like the implementation of the values `pi :: Double',`chr :: Int -> Char',`ord :: Char -> Int',`listArray :: Ix i => (i, i) -> [e] -> Array i e',`getChar :: IO Char',`writeIORef :: IORef a -> a -> IO ()',&c. are provided by the language implementation
23:36:42 <yushyin> a bit tedious to write a type with infinite values with ADT syntax :)
23:37:31 <ski> jusss : `r -> a' is not a value, it's a type. it's the type of the value stored inside a use of the data constructor (not the type constructor) `Reader' (i'd really like to rename it to `MkReader' ..)
23:38:26 <jusss> ski: yes, 
23:38:58 <jusss> ski, this (e->a) is one type, and it needs two variables to construct
23:39:45 <jusss> ski the value I mean like Just a in the Maybe a = Just a | Nothing
23:40:03 <jusss> I don't how to express this Just a, can we call it a value of a type?
23:40:22 <jusss> 'cause Just is a value constructor
23:40:30 <ski> (i'm, nickpicking on your terminology. i'm doing that, because, ime, it commonly helps newbies, with their conceptual map of things, to be really strict about keeping distinct things separate in the language used, not by mistake (or sloppiness) using not quite the right term for what you mean)
23:41:17 <jusss> so what's the term? or how you express that right part of '=' in ADT?
23:41:27 <Kartha> hey
23:41:29 <Kartha> λ: 'L' : tail "lists"
23:41:29 <Kartha> "Lists"
23:41:37 <Kartha> ^ what does this mean?
23:41:48 <Kartha> is this something I run in ghc?
23:41:53 <ski> (when you're more confident about the relevant distinctions, it's more okay to be sloppy about these things, because then you more likely know what you really meant. at least it's more ok, if you're talking to someone else, who's also familiar with the territory, as opposed to another newbie who's not firm yet of the terms)
23:42:14 <ski> Kartha : yes, apparently
23:42:23 <ski> > 'L' : tail "lists"
23:42:25 <lambdabot>  "Lists"
23:42:33 <Kartha> what does tail do?
23:42:42 <opqdonut> > tail "lists"
23:42:44 <lambdabot>  "ists"
23:42:54 <Kartha> oh, it removes the head
23:43:00 <ski> Kartha : in your interactor, the `>' at the start might look like `Prelude>' actually, being the prompt the interactor gives you
23:43:04 <Kartha> I think I've seen this in Lisp or Scheme or something
23:43:48 <ski> jusss : "this (e->a) is one type, and it needs two variables to construct" -- it needs two components, two type parameters. in this case, they were tyvars. in `Int -> Char', they're not tyvars
23:44:02 <Kartha> ski um, this was given to me as an example of mutability of lists in haskell
23:44:21 <Kartha> afaibt, everything is immutable in haskell
23:44:45 <ski> jusss : a `data' type definition like `data Maybe a = Just a | Nothing' gives "templates" for constucting values of the newly defined type. here `Nothing' is of type `Maybe a'. but `Just a' isn't of type `Maybe a'. rather the template `Just a' means that if `x' is of type `a', then `Just x' is of type `Maybe a'
23:45:27 <Kartha> > 'L'+'ists'
23:45:29 <lambdabot>  error:
23:45:29 <lambdabot>      • Syntax error on 'ists'
23:45:29 <lambdabot>        Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
23:45:44 <Kartha> > 'L'+"ists"
23:45:44 <ski> jusss : similarly, if you define `data Person = MkPerson String Integer', then the "template" `MkPerson String Integer' here means that if `name' is of type `String', and `age' of type `Integer', then `MkPerson name age' is of type `Person'
23:45:46 <lambdabot>  error:
23:45:46 <lambdabot>      • Couldn't match expected type ‘Char’ with actual type ‘[Char]’
23:45:46 <lambdabot>      • In the second argument of ‘(+)’, namely ‘"ists"’
23:45:55 <yushyin> Kartha: yeah tail does not 'remove' the head it 'gives' you back the tail
23:45:59 <Kartha> > "L"+"ists"
23:46:01 <ski> @src tail
23:46:01 <lambdabot> tail (_:xs) = xs
23:46:01 <lambdabot> tail []     = error "Prelude.tail: empty list"
23:46:01 <lambdabot>  error:
23:46:02 <lambdabot>      • No instance for (Num [Char]) arising from a use of ‘+’
23:46:02 <lambdabot>      • In the expression: "L" + "ists"
23:46:14 <ski> Kartha : ^ that's the implementation of `tail'
23:46:28 <Kartha> oh, it looks like a splice
23:46:32 <ski> you can't use `+' on `String's. `+' is for numbers
23:46:43 <Kartha> then how is concatenation?
23:46:52 <ski> > "L" ++ "ists"
23:46:54 <lambdabot>  "Lists"
23:46:57 <Kartha> oh haha
23:47:06 <Kartha> thanks
23:47:41 <Kartha> ski so this means that strings and lists are mutable, right? ie, they can be changes
23:47:43 <Kartha> *changed
23:47:47 <ski> nope
23:48:20 <jp673> is this the right place to ask questions about the stack tool?
23:48:43 <jusss> ski ok
23:48:57 <ski> @let myString0 = "Lists"
23:48:59 <lambdabot>  Defined.
23:49:04 <ski> > myString0
23:49:06 <lambdabot>  "Lists"
23:49:11 <ski> @let myString1 = [head myString0]; myString2 = tail myString0
23:49:13 <lambdabot>  Defined.
23:49:18 <jusss> all I just want to know is just that monad (e->a), 
23:49:23 <ski> > (myString0,myString1,myString2)
23:49:25 <jusss> monad (e->)
23:49:26 <lambdabot>  ("Lists","L","ists")
23:49:46 <ski> @let myString3 = myString2 ++ myString1
23:49:47 <lambdabot>  Defined.
23:49:53 <ski> > (myString0,myString1,myString2,myString3)
23:49:55 <lambdabot>  ("Lists","L","ists","istsL")
23:49:58 <jusss> I don't reallize that function type is special
23:50:50 <ski> Kartha : note how passing the strings to the functions, like `head',`tail',`(++)', doesn't change the original `String's. they're still there, with the same value as before. these functions compute new `String's for us, without touching the old ones, that we use as parameters
23:51:08 <ski> jusss : what about it ?
23:51:48 <Kartha> ski I see
23:51:52 <jusss> ski: what it's used for? >>= f g x = g (f x ) x is weird function
23:51:52 <jusss>  
23:52:26 <ski> Kartha : and by "touching", i meant "changing". obviously the old values are "touched" in the sense that they are inspected, by these functions
23:52:33 <jusss> ski this is when monad is (e->) its funtion looks like
23:53:09 <jusss> and people always tell me when monad is (e->) that's a Reader Monad
23:53:42 <ski> > (do x <- (^2); y <- (^3); return (x + y)) 4
23:53:44 <lambdabot>  80
23:53:54 <ski> > (do x <- (^2); y <- (^3); return (x + y)) 4  :: Expr
23:53:56 <lambdabot>  4 * 4 + 4 * 4 * 4
23:54:10 <ski> > liftA2 (+) (^2) (^3) 4
23:54:12 <lambdabot>  80
23:54:46 <jusss> ski Reader Monad has to do with do-notation?
23:54:51 <Kartha> ski is there a cli program using haskell that I can fiddle on
23:54:58 <ski> > liftA sum (sequence [(^2),(^3)]) 4
23:54:59 <lambdabot>  80
23:55:24 <ski> jusss : `do'-notation works for every instance of `Monad', including `(rho ->)'
23:56:39 <MarcelineVQ> Kartha: haskell installations come with a program called ghci which you can play in
23:57:09 <ski> `liftM2 f g h', with `g' and `h' being functions (so that we use the `(rho ->)' monad, for some type `rho', being the input type of `g' and `h'), amounts to `\x -> f (g x) (h x)'
23:57:53 <jusss> sorry, I'm not familiar with liftM2 or liftA2 functions
23:57:56 <jusss> yet
23:58:03 <Kartha> MarcelineVQ lol, ok I'll build it myself then. I was hoping to find like a standard application template for cli meni driven or command driven application that have already been through all the production phases
23:58:13 <ski> jusss : `(rho ->)' monad is sometimes used to "pass along" an input (here `x'), to several functions (like `g' and `h') here
23:58:29 <ski> jusss : `liftM2 f g h' is the same as `liftA2 f g h' is the same as `f <$> g <*> h'
23:58:42 <ski> @src liftM2
23:58:42 <lambdabot> liftM2 f m1 m2 = do
23:58:42 <lambdabot>     x1 <- m1
23:58:44 <lambdabot>     x2 <- m2
23:58:46 <lambdabot>     return (f x1 x2)
23:58:55 <ski> @type liftM2
23:58:57 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:59:28 <jusss> ski I perfer fmap f g <*> h
23:59:45 <ski> yes, `(<$>)' is `fmap'
23:59:52 <jusss> so I can know that fmap f g = \x -> f (g x)
23:59:59 <ski> (and `fmap' is basically the same as `liftA', and `liftM')
