00:14:57 <honungsburk> Suppose I want to write a mobile app letting users get realtime updates on sports results. I would like the server to instantly push to the client whenever there is an update. Are there any simple ways of doing this in haskell? 
00:29:54 <Ke> tbh. I tried compiling existing android app and the process made me cry, eventually I decided Android is no way forward here
00:30:17 <Ke> adding haskell in to the mix will surely streamline the experience
00:31:14 <tsahyt> honungsburk: this might be worth a look https://hackage.haskell.org/package/push-notifications
00:57:53 <Axman6> Squarism: Map Subject (MVar ())? I think we may also have reader-writer locks somewhere
01:53:04 <Guest44764> 기회가 있다면 잠수함에서 바다 밑으로, 잠수함에 타고 싶습니까?
01:54:15 <segeljakt> What do I use, cabal or stack?
01:54:28 <segeljakt> or rather, which is the best?
02:01:30 <rizary> segeljakt: imho, cabal
02:03:40 <hvr> segeljakt: cabal :-)
02:13:06 <jgt> slightly apples-to-oranges
02:13:18 <jgt> should be a discussion between stack and cabal-install
02:13:26 <jgt> there's no getting away from cabal
02:13:43 <jgt> personally, I do everything with nix and cabal
02:13:51 <jgt> and I use neither stack nor cabal-install
02:29:56 <segeljakt> Ok, I will try out cabal
02:30:27 <jgt> cabal-install*
02:31:29 <segeljakt> Another question, I created a bnfc grammar, how do I make cabal compile it into a parser?
02:34:19 <segeljakt> on cabal-build, I would like to run `bnfc -haskell src/Parser.cf` which generates `src/Parser/{Abs.hs Doc.txt ErrM.hs Lex.x Par.y Print.hs Skel.hs Test.hs}`
02:34:34 <osa1> how do I force cabal new-build to rebuild after changing a data file?
02:39:00 <jgt> osa1: did you try cleaning out any files that cabal-install created during compilation?
02:39:48 <bendo> jgt: how is it with nix and pc resources?
02:39:49 <jgt> osa1: I have the following in a Makefile which I use to clean out my project when the linker gets confused in GHCi: http://ix.io/1IN2
02:40:05 <hvr> osa1: a direct way is to `rm` all build-related `cache` folders inside `dist-newstyle`, if GHC would detect the change in the data files
02:40:13 <bendo> jgt: if I remember goot it eats a lot of memory, or?
02:40:27 <hvr> osa1: assuming you don't want the sledge hammer `cabal clean`
02:41:09 <osa1> hvr: shouldn't cabal detect changes in the data files? I'm trying to avoid rebuilding the code
02:41:12 <jgt> bendo: haven't really had problems, and my machine is pretty weak. I'm running a 2017 MacBook Air, 1.8GhZ i5, 8GB RAM
02:41:51 <hvr> osa1: iirc there's a ticket about that to consider extra-source files as inputs to all components
02:42:13 <hvr> osa1: that would then take care of having `ghc --make` reinvoked, if that's what you want
02:42:26 <osa1> hvr: I just want cabal to copy the new data files
02:42:29 <hvr> but this all hinges on `ghc --make` being able to detect the data file changes
02:42:40 <osa1> ghc doesn't know anything about data files though
02:42:46 <osa1> why would that be ghc's responsibility
02:42:58 <hvr> osa1: wait... cabal doesn't copy data files around for local packages...
02:43:03 <hvr> afaik
02:43:25 <osa1> I think it does. I'm editing these data files and unless I remove dist-newstyle it keeps using the old files
02:43:27 <hvr> where do you see data files being copied?
02:43:40 <hvr> used for what exactly?
02:43:48 <hvr> how do data files affect your build currently?
02:44:09 <osa1> ooooooooooh
02:44:33 <osa1> this uses file-embed. sigh.
02:44:39 <hvr> so it *is* about TH :-)
02:44:45 <osa1> this is stupid
02:45:10 <hvr> and that's where that ticket I hinted at that takes extra-source files into account for the file monitoring would help
02:46:34 <hvr> (without resorting to really bad things such as parsing .hi files or the dump-hi output)
03:05:18 <fizbin> I have a question about low-level behavior of the GHC's I/O manager based on what I'm seeing using strace on individual system threads. Where would be the best place to ask about this?
03:18:03 <osa1> fizbin: here or #ghc
03:19:47 <fizbin> osa1: Okay. Let me investigate what I'm seeing a bit more so I can ask a better question and then I'll ask when it's awake time for more the world.
03:22:12 <jgt> fizbin: I probably can't help, but the depth of your question sounds like you should type it up in a StackOverflow question first and then link it here or in the #ghc channel
03:27:43 <gonz_> Does anyone know an even remotely satisfying alternative to type classes?
03:29:38 <[exa]> gonz_: what's "even remotely satisfying"?
03:29:54 <phadej> gonz_: what's dissatisfying about type-classes?
03:30:07 <[exa]> gonz_: anyway, there are reviews of various overloading methods and related typesystem tools
03:30:32 <jgt> I had the same question as [exa] and phadej, but in truth I wouldn't even know what unsatisfying alternatives would look like
03:30:38 <jgt> but it did lead me to find this: http://hackage.haskell.org/package/cluss
03:30:48 <gonz_> phadej: That's not what that sentence is implying at all. It's asking for satisfying alternatives, of which I've found none.
03:31:05 <phadej> gonz_: oh yes, type classes are in own league
03:31:16 <gonz_> I can't find anything that makes better tradeoffs than type classes and I legitimately would like to hear a good alternative.
03:31:47 <gonz_> Implicits seem to solve it with having a more or less complicated resolution scheme that you have to learn instead, which is worse to me than just having to newtype new instances
03:31:59 <gonz_> So I'm not buying it as a win
03:32:14 <jgt> gonz_: if you have evaluated what I linked above, I'd be interested to hear your review
03:32:22 <[exa]> gonz_: virtual-style run-time polymorphism is quite popular way to do technically the same thing
03:32:36 <gonz_> jgt: I'll take a look, thanks. :)
03:33:54 <[exa]> gonz_: ad-hoc approaches are also popular, if you have less requirements on type checking (btw blind adhoc overloading resolution is in NP)
03:35:16 <keepLearning512> Hi, can anyone tell me.
03:35:17 <keepLearning512> what this “(last .) . take . (+ 1)” actually do? How do understand this type of function composition?
03:35:43 <cocreature> keepLearning512: the easiest way to understand this kind of code is to simply substitute the definition of (.)
03:37:00 <jgt> is there ever a case where using (.) in a section is easier to read than the not-pointfree (pointed?) version?
03:37:46 <keepLearning512> Thanks for quick response @cocreature. Will try out
03:38:04 <cocreature> (last .) . take . (+1) = (last .) . (take . (+1)) = \x -> (last .) ((take . (+1)) x) = \x -> last . ((take . (+1)) x) = \x -> \y -> last ((take . (+1)) x y) = \x -> \y -> last (take (x + 1) y)
03:38:31 <cocreature> I combined some steps into one and the order is somewhat arbitrary
03:38:49 <[exa]> lambdabot knows un-pointfreeing, right?
03:39:13 <jgt> does lambdabot know what that's called?
03:39:16 <jgt> freepointing?
03:39:21 <cocreature> it does but I don’t think it’s particularly enlightening to just ask lambdabot here.
03:39:31 <cocreature> Working trough it yourself at least a few times is quite helpful
03:39:40 <[exa]> @unpl (last .) . take . (+ 1)
03:39:40 <lambdabot> (\ x x0 -> last (take (x + 1) x0))
03:39:59 <[exa]> unpl == unpointless
03:40:05 <[exa]> probably.
03:48:17 <phadej> gonz_: there're developments lke https://arxiv.org/abs/1807.11267 which would make type-classes applicable when you'd need something more implicit-like
03:49:29 <phadej> sorry, wrong link https://sigplan.org/OpenTOC/haskell18.html see Coherent explicit dictionary application for Haskell
04:22:04 <gonz_> Thanks :)
04:46:11 <talqu> hi, i'm playing postgresql-simple and can't figure how to implement toField instance. Here is an example: https://pastebin.com/hWyXV9CF. FromField works well, however ToField doesn't. 
05:02:19 <jgt> talqu: what's the error?
05:02:32 <jgt> it looks like you want a Maybe type, no?
05:03:30 <jgt> I've never used postgresql-simple, so it's for me to guess
05:04:41 <talqu> Exception: SqlError {sqlState = "42703", sqlExecStatus = FatalError, sqlErrorMsg = "column \"big\" does not exist", sqlErrorDetail = "", sqlErrorHint = ""}
05:05:32 <jgt> should there be a table called "big"?
05:05:37 <jgt> sorry
05:05:41 <jgt> column, not table
05:06:49 <jgt> talqu: maybe you want something more like this? https://github.com/the-adirondacks-project/crik-server/blob/87c8fd0ac3520e3e313378b67b6ef672bdc1ec68/src/Database/Instance.hs#L23
05:07:25 <jgt> talqu: when I'm not sure how to use something in Haskell, I do a query like this in GitHub: https://github.com/search?q=instance+ToField+simple+language%3Ahaskell&type=Code
05:11:12 <talqu> cool, what is `simple` in your query?
05:11:30 <hpyCdr> I need to read from a binary file multiple times at specific indices. How can I achieve this with proper, lazy access?
05:11:47 <hpyCdr> open/close on each access would ensure this, but is very inefficient
05:11:48 <talqu> jgt: simple as keyword to simple-postgresql?
05:13:10 <hpyCdr> I guess using a handle and seeking might work
05:44:56 <talqu> jgt: thanks, I figured out looking at that search result :)
05:51:01 <jgt> talqu: yes, "simple" to try to narrow the results to those more specific to postgresql-simple
06:01:25 <zincy> What is a type instance?
06:01:27 <zincy> type instance Plus (Succ n) :+ m = Succ (Plus n m)
06:02:50 <zincy> Sorry shouldn't have the :+ type operator in there
06:18:26 <coldpress> hey all, with this cabal new-install, how do I run ghci in my module without passing a whole bunch of `-package` options to ghci?
06:20:46 <[Leary]> zincy: It's one case of a open type family. I.e. that line extends an existing type level function `Plus` to handle new input.
06:20:51 <Solonarv> coldpress: how is your project set up? is it just a single .hs file, or a proper package with a blah.cabal file?
06:21:11 <Solonarv> if the latter: just do cabal new-repl
06:21:33 <coldpress> blah.cabal, thanks :)
06:21:52 <coldpress> I see that I'm supposed to have a cabal.project as well? Should I change my blah.cabal to a cabal.project?
06:22:03 <Solonarv> no, they do different things
06:22:30 <Solonarv> blah.cabal describes one package, cabal.project describes a project (which might contain multiple packages)
06:22:54 <Solonarv> the simplest cabal.project just contains one line: packages: .
06:24:37 <Solonarv> in cabal.project, you can also specify things like "pull this package from a git repository", or you could have multiple packages in subdirectories
06:24:37 <coldpress> ah, so even if a project depends on multiple packages, as long as the project is one package, we still use blah.cabal
06:24:56 <Solonarv> you always use blah.cabal if your project is non-empty
06:27:21 <coldpress> ah ok, that makes  things clearer, thanks Solonarv!
06:28:41 <Solonarv> here's an example multi-package project structure: https://gist.github.com/Solonarv/d4e75c09754a4fc6d027759a3afbd57a
06:33:44 <zincy> So for append :: Vector a n -> Vector a m -> Vector a (Plus n m)        is Plus a type function or just a new type?
06:35:07 <Solonarv> it's a type function
06:35:17 <zincy> thanks
06:35:44 <zincy> so are type operators like :> usually just type functions implemented with type families?
06:36:10 <Solonarv> no, those are completely unrelated
06:36:32 <zincy> :/
06:36:38 <talqu> I have a data type A written with record syntax. It has 20 type params, including id, which maps directly to id in the postgresql table. This type A is an instance of FromField from postgresql-simple lib, so I can do selects nicely already. Now, I want to do inserts, which could use the A type if it didn't have the id attribute. I can new data type B duplicating A and removing id param, but can I do this in some bet
06:36:38 <talqu> ter way?
06:37:26 <Solonarv> type operators are the same as regular Uppercase Types, the distinction is entirely syntactic
06:37:58 <coldpress> Solonarv: beautiful project structure, thanks
06:39:40 <jgt> sounds like talqu wants row polymorphism
06:39:53 <zincy> So type operators are just type constructors infixed
06:40:34 <Solonarv> yup
06:40:56 <talqu> i remember when checking purescript it had those :)
06:41:07 <jgt> talqu: again I haven't used postgresql-simple, but you might want the approach used in persistent
06:41:31 <jgt> in persistent your type B would be something like User
06:41:56 <jgt> and your type A would be something like (Entity User)
06:42:30 <jgt> the Entity gives you two fields — entityKey, which is the id, and entityVal, which is your type B
06:43:02 <jgt> so Entity is a wrapper that lets you carry the id around
06:44:00 <talqu> jgt: nice, ill try this idea
06:46:37 <talqu> I'm looking for a haskell operator of this https://pastebin.com/S6LeeUmA
06:47:56 <jgt> talqu: I'm not really sure what that does; I've forcibly removed all traces of Clojure from my brain through heavy drinking
06:49:15 <jgt> but it _looks_ like: concat . intercalate ", " . map aKey . data
06:49:38 <talqu> :)) sorry, it was hard to explain and i thought an example would explain it better. Something like composition function but sticks the param as the first arg
06:49:56 <jgt> Haskell does this by default
06:50:04 <jgt> look at something called "pointfree"
06:50:24 <jgt> f x = g x == f = g
06:50:33 <jgt> does that line above make sense?
06:51:04 <jgt> instead of writing `myFunction anArg = otherFunc2 . otherFunc1 $ anArg`
06:51:16 <jgt> you can just write `myFunction = otherFunc2 . otherFunc1`
06:51:38 <jgt> this is also called eta-reduction
06:52:12 <talqu> (f a) . (g b) $ 5 will be (f a (g b 5)) i want 5 to sticked as first param
06:52:41 <jgt> @pl (f a) . (g b) $ n
06:52:41 <lambdabot> f a (g b n)
06:52:59 <jgt> ¯\_(ツ)_/¯
06:53:22 <Solonarv> talqu: can you write out what you would like the function to actually do? because I'm not sure what that is, currently
06:53:23 <talqu> right, i want the output to be (f (g 5 b) a)
06:53:30 <jgt> probably best to write it out the long way first and then have someone else review it
06:53:32 <Solonarv> ah, now I see!
06:53:49 <Solonarv> @pl \a b -> f (g 5 b) a
06:53:49 <lambdabot> flip (f . g 5)
06:54:17 <Solonarv> or was the 5 supposed to be an argument? in that case:
06:54:17 <Solonarv> @pl \x -> f (g x b) a
06:54:17 <lambdabot> flip f a . flip g b
06:54:25 <Solonarv> oof, not pretty.
06:56:52 <talqu> i found it! https://hackage.haskell.org/package/flow-1.0.18/docs/Flow.html#v:-124--62-
06:57:21 <jgt> @type (&)
06:57:22 <lambdabot> a -> (a -> b) -> b
06:57:41 <jgt> talqu: I think you're looking for Data.Function.&
07:01:28 <talqu> that's right i can do the same with $ but it looks confusing to read: `negate $ recip $ succ $ 3` vs `3 |> succ |> recip |> negate`
07:01:41 <Solonarv> yes, that's what & is
07:01:49 <Solonarv> @let import Data.Function
07:01:50 <lambdabot>  Defined.
07:02:00 <Solonarv> > 3 & succ & recip & negate
07:02:02 <lambdabot>  -0.25
07:02:24 <jgt> talqu: $ /= &
07:02:55 <talqu> Solonarv: ohh, "&" I thought i was looking to "$" :)
07:03:01 <talqu> thank you, that's great 
07:29:43 <zincy> Can I use GADTs to associate the constructors of two types together to build a new product type?
07:30:56 <zincy> Uh no GADT's match on types
07:31:13 <zincy> So I would need to represent the data constructor names at the type level with TypeLit
07:44:09 <__monty__> Could someone explain to me why this test depends on Cabal the library? I'm passing some --allow-newers and using a GHC built from master.
07:44:12 <__monty__> http://ix.io/1IOg
07:47:17 <geekosaur> "[setup]"?
07:47:34 <geekosaur> i.e. Setup.hs (or lhs) requires the Cabal library, always
07:50:03 <__monty__> So it's because of a custom Setup.hs? Hackage doesn't list the Cabal dependency, hence my confusion.
07:51:21 <geekosaur> it's implicit, even without a custom Setup.hs it'll use a default one. which invokes a function from the Cabal library
07:53:27 <__monty__> geekosaur: Then why does the Cabal dependency only show up for this? It's the only occurrence in the tred output.
07:54:10 * ski isn't sure what zincy is after ..
07:54:34 <geekosaur> it's the only one that lists a setup dependency, so I would suspect it's attached to the only package that would need to be installed?
07:55:05 <geekosaur> actually it's possible a non-custom setup uses a prebuilt one now, so it wouldn'tt need tp build except in the custom case
07:55:27 <geekosaur> default Setup.hs should depend only on ghc/base and Cabal lib
08:01:48 <phadej> geekosaur: stack uses prebuilt one, cabal uses `cabal act-as-setup` built-in functionality
08:02:07 <phadej> both ingore bundled `Setup.hs` if build-type: Simple
08:02:25 <geekosaur> ok, so that'd be the one package with a custom Setup
08:02:36 <geekosaur> == build-type: custom
08:03:01 <phadej> yes, happy has `build-type: Custom`
08:11:40 <__monty__> phadej: Ah, ok. One more question about the output, why are some packages enclosed in []'s?
08:16:08 <zincy> ski: I will have a think about it and come back with a well formulated question
08:16:55 <delYsid``> I found my first Monoid in the wild!
08:17:04 <maerwald> did you shoot it?
08:17:12 <delYsid``> no
08:17:16 <jgt> category-ball, go!
08:17:48 <maerwald> if you don't shoot it, it will grow into a Monad
08:18:11 <delYsid``> A QuadBitboard (from chess) is a Monoid under bitwise XOR.  And a very useful one actually.
08:18:56 <__monty__> A Nibbleboard?
08:19:15 <delYsid``> yes.
08:19:21 <delYsid``> indeed.
08:25:51 <hpc> ah yes
08:25:56 <hpc> the natural predator of breadboards
08:26:09 <monochrom> haha
08:26:57 <phadej> __monty__: that's old cabal-plan output, I actually changed it; and don't remember how it looks like now
08:27:03 <phadej> __monty__: there's no "deep reason"
08:30:24 <__monty__> phadej: It's a fairly recent master though. And most aren't enclosed.
08:31:07 <delYsid``> Does GHCi have some trick to go to warning locations using :edit?
08:32:24 <phadej> __monty__: ah, i see; the [...] are legacy units (which consist of multiple components, incl. custom-setup) OR non-main-library components (setup, tests, executables...)
08:32:30 <hpc> if your editor is vim and you have line numbers, :345 (or whatever the line number is) to jump to it
08:32:54 <phadej> it actually prints
08:32:56 <hpc> sadly you can't jump within the line by doing :345:65
08:32:56 <phadej> [happy-1.19.10:all] <- all
08:33:03 <__monty__> hpc, or 345gg which is obviously more ergonomic.
08:33:06 <delYsid``> hpc: Sure, I was hoping there was some way to make it automatically go to the line, like it already can for errors.
08:33:19 <phadej> TL;DR those aren't packages, but units/components
08:34:17 <__monty__> phadej, geekosaur: Ok, thanks for the clarifications!
08:34:24 <hpc> aha - https://stackoverflow.com/questions/4466950/go-to-n-th-symbol-in-line?noredirect=1
08:34:32 <hpc> 345gg65|
08:42:04 <segeljakt> anyone installed haskell-ide-engine?
08:44:08 <segeljakt> for me, it takes an eternity
08:47:38 <cjay-> segeljakt: that's normal, it tries to support many ghc versions. you can restrict it to fewer versions somehow, it's in the documentation.
08:48:40 <cjay-> is there a reason that the main thread is always a bound thread, other than to avoid bad surprises when turning on "-threaded"?
08:49:32 <segeljakt> I believe I did, but maybe even a single version takes forever hehe
08:49:49 <hpc> it might be less work that way?
08:49:51 <cjay-> possible, it builds a lot of other tools 
08:50:08 <hpc> the main thread isn't created, it just happens when the program runs
08:50:31 <cjay-> hm, maybe
08:51:37 <cjay-> oh, and it seems to be the only way to access the main thread that as to exist from the perspective of the OS
08:51:43 <cjay-> probably that's the main reason
08:52:01 <cjay-> some things have to happen in the main thread
08:52:03 <hpc> it's also why when the main thread exits the whole program exits, i bet
08:52:18 <segeljakt> O.o it finally completed
08:53:59 <hpc> i should read the ghc source sometime
08:54:02 <segeljakt> time to write me a haskell ᕕ( ᐛ )ᕗ
08:58:40 <cjay-> a whole haskell? :O
08:59:27 <jgt> segeljakt: famous last words
09:02:22 <hpc> when i was a lad i wrote four dozen haskells every morning to help me get nerd
09:02:40 <hpc> and now that i'm grown i write five dozen haskells so i'm roughly as smart as edwaaaaaaaaard@
09:02:43 <hpc> !
09:03:31 <monochrom> That's still a special case of getting nerd.
09:03:46 <hpc> i am happy just to make it rhyme
09:03:55 <monochrom> Oh!
09:12:23 <segeljakt> legend says Oleg writes a haskell in his sleep
09:12:55 <hpc> the original haskell was implemented by simon
09:12:59 <hpc> spelling garfunkel horribly wrong
09:13:25 <c_wraith> Simon is actually a title awarded to advanced haskellers
09:18:39 <hc> lol
09:22:00 <jgt> SIMON is actually what Haskellers play instead of SKATE on Tony Hawk's Pro Skater 2
09:22:51 * jgt contributes a measly f :: String -> String -> String
09:23:01 <jgt> [game]: YOU GOT THE S!
09:33:42 <cjay-> is there a way to manage a pool of resources per capability, to avoid synchronization when acquiring such a resource?
09:34:45 <pagnol> is there anybody around who has used https://hackage.haskell.org/package/xlsx and can tell me how well it works in practice?
09:36:10 <cjay-> I can check on which capability the current thread runs with `threadCapability` from Control.Concurrent. But to acquire a resource I'd need to make sure the thread stays on that capability for a short time.
09:36:53 <Solonarv> make a new bound thread and have that thread manage the resource?
09:37:28 <cjay-> that would defeat the purpose, I want to avoid synchronization between threads
09:37:28 <hpc> i can't imagine what cares about what thread you're on, other than opengl
09:37:44 <cjay-> hpc: myself
09:38:14 <Solonarv> do it in the main thread then I guess
09:38:22 <cjay-> I want to be able to take something from the pool without doing thread synchronization
09:38:38 <cjay-> I want to be able to do this in many threads
09:39:21 <cjay-> forkOn binds a thread to a capability, but that's permanent
09:39:38 <cjay-> permanent binding is more than I want
09:40:15 <Ariakenom> a pool of bound threads?
09:41:00 <cjay-> that's even more overkill than forkOn
09:43:46 <cjay-> nevermind, I think I found a way to not need what I described
10:00:19 <zincy> What is the "parameter" in multi-parameter type classes ?
10:01:59 <ski> e.g. in `MonadReader r m', `r' and `m' are the two parameters
10:02:04 <monochrom> For example "class Foo a b c d e where ..." a, b, c, d, e.
10:02:40 <monochrom> Haskell2010 has only single-parameter type class, "class Zen a where ...".
10:06:49 <zincy> so parameter is type constructor arguments?
10:06:52 <zincy> a
10:11:40 <Cale> zincy: When you have something like (\x -> x*x) 5
10:11:43 <Cale> x is the parameter
10:11:47 <Cale> 5 is the argument
10:12:36 <ski> (sometimes `x' would be called the formal parameter, and then `5' is the actual parameter)
10:12:37 <Cale> So when we're defining:  class MonadReader r m | m -> r where ...
10:13:05 <Cale> ski: Sure, but if we're going to use the term "argument" we should reserve "parameter" for the other job :)
10:13:16 * ski nods
10:13:21 <Cale> r and m are parameters there
10:14:02 <Cale> and then in a specific case like  foo :: forall m. MonadReader Integer m => m Integer
10:14:17 <Cale> The Integer and m are arguments to MonadReader
10:15:22 <zincy> So argument is reserved for the substitution case
10:15:38 <zincy> parameter is is a name
10:15:38 <Cale> Yeah, "argument" refers to the thing which is being substituted in
10:15:54 <Cale> and "parameter" for the thing we've abstracted over
10:16:29 <zincy> Is the  | m -> r    a functianal dependency?
10:16:32 <Cale> yeah
10:16:44 <zincy> It says m determines r
10:16:46 <ski> in `f (x,y) = sqrt (x^2 + y^2)', you could say `(x,y)' is a parameter. then a parameter doesn't need to be merely a single name, it could be a more complicated pattern
10:16:48 <Cale> right
10:17:14 <Cale> which means that for any given m, there can be at most one r for which there's an instance MonadReader r m
10:17:17 <zincy> ski: yeah
10:17:49 <zincy> otherwise the function would be undefined?
10:18:00 <zincy> if there wasnt an r for a given m
10:18:29 <ski> that functional dependency is logically claiming `forall m. unique r. MonadReader r m' (you can read `unique' as "exists at most one"), which means the same as `forall m r0 r1. (MonadReader r0 m,MonadReader r1 m) => r0 = r1'
10:19:19 <ski> so, if you have two instances of `MonadReader', where the two `m' parameters are the same, it *has* to be that the two `r' parameters are also the same (so that in this case we're actually looking at the same instance, twice !)
10:20:08 <zincy> yep
10:20:13 <zincy> I follow I think
10:20:16 <ski> the static checker will prevent you from declaring two instances with the same type in place of the `m' parameter, but two distinct types in place of the `r' parameter
10:22:09 <ski> also, the direct practical utility of the FD is that if you e.g. use a method of the type class twice, and the type checker determines that the same type `m' is used for both usages of the method, then it can simplify the "double" constraint `(MonadReader r0 m,MonadReader r1 m)' to just `MonadReader r m' (`r' being the same as `r0' and `r1', which the FD claimed must be equal here)
10:23:09 <ski> so, you'll get less ambiguity, that's the gain. less having to explicitly annotate code e.g. with type signatures, to get the system to understand which instance you actually wanted to use
10:23:24 <zincy> What does the = denote in (MonadReader r0 m,MonadReader r1 m) => r0 = r1
10:23:34 <zincy> equality?
10:24:04 <ski> the more abstract gain is in modelling. if the type class you're making corresponds to a property in a problem domain where the FD holds, then you probably want to add the FD, to more closely model your problem domain
10:24:37 <ski> (and if the FD is not in the problem domain, you may want to think twice about introducing an FD, merely to attempt to get less ambiguity)
10:24:42 <ski> zincy : yes
10:25:35 <ski> (in actual GHC, you'd write `r0 ~ r1' for the constraint that the types `r0' and `r1' are equal. but i was more using a logical notation to express the FD property, a notation which just happened to look a bit like type notation in Haskell)
10:26:51 <ski> zincy : "otherwise the function would be undefined?","if there wasnt an r for a given m" -- there is actually no function there, in that situation
10:29:40 <zincy> In what way can multiparam type classes be said to create relationships between type ?
10:30:46 <zincy> Is it because you are essentially pattern matching on the type variables in the type constructor (assuming params = type variables) and then declaring the resulting type of each method in the multiparam typeclass?
10:31:31 <ski> zincy : however, instead of `class MonadReader r m | m -> r where {ask :: m r; local :: (r -> r) -> m a -> m a}' (MPTC with FD), one could use AT (Associated Type), like `class MonadReader m where {type EnvType m; ask :: m (EnvType m); local :: (EnvType m -> EnvType m) -> m a -> m a}
10:31:52 <ski> and then `EnvType' would be such a (type-level) function
10:32:09 <zincy> are associated types open type families?
10:32:49 <ski> they are open, but associated to a type class. so when making an instance of the type class, you're also making an instance of that associated type family
10:33:15 <zincy> Are Data families the equivalent of doing MPTC + FD and getting a data constructor all in one?
10:33:25 <ski> "pattern matching on the type variables in the type constructor" -- which type constructor ? i don't follow
10:33:46 <zincy> data Maybe a = Just a | Nothing
10:33:52 <zincy> a is the type variable
10:34:00 <ski> yes. a parameter
10:34:36 <zincy> MPTC would work on data MyType a b = MyType (One a) (Two b)
10:34:54 <ski> data families are to type families what data types are to type synonyms, basically
10:35:02 <zincy> as that is a type of two paramters
10:35:32 <ski> i don't follow how the multiple parameters of a MPTC would related to the multiple parameters of that data type
10:35:37 <ski> s/related/relate/
10:36:33 <zincy> as in the purpose of the MPTC extension is to allow you to write typeclasses for such types as MyType
10:36:42 <zincy> Is what I understand
10:36:50 <ski> no
10:37:00 <zincy> :/
10:37:12 <ski> you can already write `instance (Eq a,Eq b) => Eq (MyType a b)', e.g.
10:37:38 <zincy> oh of course
10:37:52 <zincy> Either has two type parameters 
10:37:56 <ski> `Eq' (to the right of `=>') is used with a single argument, not two. but that single argument is a type constructor applied to two tyvars
10:39:23 <zincy> So MPTC lets you write a typeclass which would have different results for particular arguments to the parameters a or b
10:40:07 <ski> MPTC lets you write type classes with multiple parameters. that's all
10:40:27 <ski> i don't see why you're bringing multiple-parameter data types into this
10:44:21 <zincy> where did I bring multiple param data types in?
10:44:46 <ski> <zincy> MPTC would work on data MyType a b = MyType (One a) (Two b)
10:45:01 <ski> <zincy> as that is a type of two paramters
10:45:06 <ski> <zincy> as in the purpose of the MPTC extension is to allow you to write typeclasses for such types as MyType
10:45:24 <zincy> oh that
10:45:45 <ski> perhaps "Either has two type parameters" as well. and probably also "So MPTC lets you write a typeclass which would have different results for particular arguments to the parameters a or b", though i didn't really understand what you were trying to say there
10:48:54 <monochrom> Sounds like mixing up type and class.
10:49:08 <zincy> yeah
10:49:50 <zincy> class Monoid v => Measured v a | a -> v where
10:49:51 <zincy>   measure :: a -> v
10:50:13 <zincy> Why not just drop the `v` in the first line?
10:50:48 <ski> you mean `class Measured a where measure :: Monoid v => a -> v' ?
10:50:48 <monochrom> I did not invent this Measured class, so I can't answer for its author.
10:51:07 <monochrom> But you can always explore what would happen if you deleted v.
10:51:18 <Cale> zincy: which v?
10:51:26 * ski assumed, all of them
10:51:54 <zincy> all but the one in the measure type declaration
10:51:58 <monochrom> which means now you have to write your own concrete code, rather than passively wait for a white knight in your armchair.
10:52:05 <Cale> The point of that class is to provide a means of summarising the elements at the leaves of a tree-like structure using some type which is required to be a monoid
10:53:17 <Cale> It needs to be a monoid because the tree-like structure is going to be rebalanced, and so in various cases, we'll need the associativity to ensure we don't have to recompute the summaries of various subtrees.
10:53:25 <zincy> monochrom: Not sure I follow :P
10:53:35 <Cale> (and occasionally, we'll need the identity when the subtrees become empty)
10:54:15 <Cale> But we don't want to insist that the elements at the leaves are themselves a monoid
10:54:28 <zincy> monochrom: Don't think I need to write any code to understand why the v is needed
10:54:31 <Cale> (the type of elements at the leaves)
10:54:41 <zincy> Cale: Thanks
10:55:24 <zincy> so can you introduce type parameters in to the typeclass method if they are not explicitly mentioned in the typeclass declaration
10:55:44 <monochrom> Yes, and you have seen Functor doing that.
10:56:29 <zincy> monochrom: right
10:56:56 <zincy> so the only reason to have the `v` in the typeclass declaration is to explicate the functional dependency from a to v
10:56:57 <zincy> ?
10:57:21 <Solonarv> zincy: no
10:57:44 <Solonarv> the a -> v fundep means that whoever's writing the instance for an 'a' gets to pick one particular 'v'
10:58:24 <Solonarv> if the definition was instead 'class Measured a where measure :: Monoid v => a -> v', then this 'measure' would have to work for every possible choice of v
10:59:31 <zincy> There is the white knight
10:59:56 <monochrom> Yes the Internet is full of do-gooder white knights.
11:00:08 <monochrom> This is why learning is at a all-time decline.
11:00:22 <ski> zincy : `class Measured a where measure :: Monoid v => a -> v' really means `class Measured a where measure :: forall v. Monoid v => a -> v', so that the method is polymorphic in `v' (but not `a'). however, the method in the original class is not polymorphic (since given a particular instance of `Measured', you'll have particular types in place of `v' and `a')
11:00:37 <zincy> not trolling but are you saying I should be struggling more
11:01:17 <monochrom> I don't know about struggling. It was not a struggle for me.
11:01:59 <__monty__> How do white knights prevent learning? (Maybe take this discussion to #haskell-offtopic though.)
11:02:47 <zincy> monochrom: Try and communicate with more emotional intelligence it will serve you well
11:02:55 <Cale> zincy: I don't understand your question about having v in the type class declaration -- where else would you expect it to go?
11:03:10 <ski> there is a balance between helping too little, and helping too much
11:03:30 <Rembane> I usually try to confuse people until they learn out of self-preservation.
11:03:55 <Cale> zincy: Like, what is the alternative definition of the type class you're considering?
11:04:33 <Cale> Both a and v are used in the type of measure...
11:04:39 <zincy> class Monoid v => Measured v where
11:04:39 <zincy>    measure :: a -> v
11:04:51 <Cale> That would make measure totally polymorphic in a
11:04:54 <monochrom> That one deletes a, not v.
11:04:59 <ski> zincy : monochrom is acting as a valuable counterbalance of the channel
11:05:13 <Cale> So it wouldn't be able to determine anything about the value it was given
11:05:31 <zincy> monochrom: Right but it still illustrates the point
11:06:02 <Cale> For example, any function of type  a -> Integer  is a constant function.
11:06:31 <Cale> right?
11:06:42 <zincy> yeah
11:06:43 <monochrom> OK, what instances could it have, and what instances could it not have?  What and what not could measure do?  What and what not could measure be used for?
11:07:20 <zincy> Cale: So by making it totally polymorphic in a you are essentially ensuring that it wont be a useful function in a sense
11:07:26 <Cale> right
11:07:26 <zincy> since it would have to be const
11:07:31 <Cale> yes
11:07:41 <ski> (any function of type `forall a. a -> Integer')
11:08:55 <zincy> monochrom: Is that in the case of a totally polymorphic a?
11:09:19 <monochrom> You have made a totally polymorphic, so yes.
11:10:04 * ski would say the method is "totally polymorphic in `a'"
11:10:23 <ski> (`a' is not polymorhic)
11:10:39 <monochrom> Yeah.
11:10:44 <zincy> It could only ever return a value of type V
11:11:08 <zincy> And the value would be defined for a given instantiation of the typeclass
11:12:58 <ski> zincy : whether the `forall' appears on the method signature (either implicitly or explicitly), or not, crucially changes the meaning
11:13:24 <Cale> ski: errr
11:13:34 <Cale> Well, okay, either implicitly or explicitly :D
11:13:45 * ski smiles
11:13:49 <Cale> Leaving it out doesn't change the meaning here because it's implied
11:14:07 <monochrom> Sometimes I regret that Haskell leaves forall implicit.
11:14:12 <Cale> The only way for it not to be implied is if the type variable a were somehow already in scope
11:14:26 <Solonarv> monochrom: likewise
11:14:27 <ski> if `a' is a parameter of the type class, then it isn't implicitly quantified by a `forall' on the method signature
11:14:33 <Cale> and the only possibility for that to happen is for it to be bound by the class
11:14:50 <zincy> ski: yeah
11:15:01 <ski> if `a' is not a parameter of the type class, then it would be implicitly quantified by a `forall' on the method signature, unless you go for an explicit quantification in the same spot, with the same effect
11:15:25 <monochrom> The #1 reason why students write "f :: a -> [a]; f x = y where { y :: a; y = x }" and don't know why it is an error.
11:15:42 <ski> if you have `class Monoid v => Measured v a ...', then conceptually there's a `forall v a.' wrapping that whole thing
11:15:45 <monochrom> To a large extent actually the student is right, the language is wrong.
11:16:17 * ski . o O ( "The place of the Word / of the Lord / must be truly understood" )
11:17:16 <monochrom> But the sadest part is not just that Haskell leaves forall implicit, but how some third-party not-on-the-committee community members zealotly defend it.
11:17:49 <ski> monochrom : imho, that could possibly have been valid, with `ScopedTypeVariables' enabled, if it had been specified differently
11:17:56 <Solonarv> ski: yes, that's the point
11:17:56 <monochrom> The defense being "it is simpler, it is easier to teach and learn".
11:18:03 <monochrom> No, it is harder to teach and learn.
11:18:19 <Solonarv> with STV and an explicit forall on f's signature that would be perfectly fine, and would do what the student likely intended
11:18:40 <ski> (or else, one could require a pattern signature in the defining equation that binds the `a' .. in any case, requiring an explicit `forall' after the `::', in order for the tyvars to be in scope in the body, is, imho, buts)
11:18:48 <ski> (s/buts/nuts/)
11:19:03 <monochrom> I'm pretty sure the committee's reason was more nuanced and less naive than "it's easier".
11:19:58 <ski> (iow, having `f :: forall a. a -> [a]; f x = y where { y :: a; y = x }' be valid with `ScopedTypeVariables', is nuts)
11:23:08 <__monty__> monochrom: How would the student be right in that example? I've never made this particular mistake.
11:24:36 <monochrom> The student writes "a" 3 times rather than 3 different names because the intention is clearly aliasing.
11:24:54 <monochrom> or maybe s/aliasing/identification/
11:25:01 <Athas> One weird aspect of ScopedTypeVariables is that names bound in the type signature are visible in the definition, which may be arbitrarily far away.
11:26:21 <__monty__> monochrom: Oh, I got confused by the [a].
11:26:28 <ski> Athas : yes, as i mentioned :)
11:26:37 <monochrom> Oh! Yeah my typo.
11:26:42 <ski> (or, at least, implied)
11:26:53 <monochrom> Make it "f :: a -> a" sorry.
11:27:07 <Athas> I wonder what the rules are that makes this work: https://paste.fedoraproject.org/paste/vNDQlq3LFYiJrfcZNE9zpw
11:27:28 <Athas> Any type variables used in the type annotation of any name on the LHS is in scope?
11:28:04 <Solonarv> Athas: yes, type signatures in patterns bring type variables into scope
11:28:07 <ski> or go `elem :: Eq a => a -> [a] -> [a]; elem x0 = search where search :: [a] -> [a]; search [] = False; search (x:xs) = x0 == x || search xs'
11:28:22 <Solonarv> that's why being able to write signatures in patterns is tied to ScopedTypeVariables
11:28:49 <monochrom> Interesting I haven't thought of doing this!
11:29:34 <ski> oh, sorry, should be `elem :: Eq a => a -> [a] -> Bool', and `search :: [a] -> Bool', obviously
11:31:13 <ski> @let myElem :: Eq b => b -> [b] -> Bool; myElem (x0 :: a) = search where search :: [a] -> Bool; search [] = False; search (x:xs) = x0 == x || search xs
11:31:14 <lambdabot>  Defined.
11:50:20 <tty1> is there some way to generate a unique ID without needing to employ a IO ?
11:51:20 <tty1> normally id use pointers for the task in any other language
11:51:56 <tty1> here im thinking some sort of UUID but i dont want to use a random number generator because then it will all be IO
11:52:49 <monochrom> Do you mind one single invocation of IO, but henceforth you work on either a pure infinite list or a state monad?
11:55:20 <tty1> monochrom: if it comes to that i will. But id rather not because im trying to implement an applicative and specifically pure with a hidden id
11:55:51 <tty1> monochrom: so wouldnt really work anyway for that
11:56:24 <monochrom> pure should not have hidden anything.
11:56:35 <monochrom> Ideally anyway.
11:58:35 <Ariakenom> tty1: pure is deterministic, so are you fine with depending on a seed?
11:59:32 <MarcelineVQ> [1..] is an endless list of unique things
12:10:05 <Athas> I wonder what the fastest functional language is for pure code on the CPU.  My guess would be OCaml in the single-threaded case and Haskell for multi-threaded code, but I have only a dim awareness of F# and Scala performance.
12:10:11 <Athas> And maybe there's some research language I don't know.
12:10:43 <monochrom> ATS. But the horror.
12:12:06 <oats> howdy, I'm feeling kinda overwhelmed by all the networking packages out there. I just need to send and receive data, probably preferably Text, over a tcp connection. Could I get a recommendation for the right package to use?
12:12:10 <Athas> Oh yeah, probably ATS.
12:12:31 <tty1> hmm
12:12:38 <tty1> maybe i should explain more
12:12:57 <tty1> because maybe im going about pure wrong and there is a better option
12:13:32 <Athas> monochrom: actually, is *pure* ATS particularly fast?
12:13:55 <Athas> I thought the point of it was that you could do imperative things in a relatively safe way.
12:14:01 <tty1> Ariakenom & monochrom you know at a basic level what grah theory is? (I want to write a data structure that is a graph)
12:16:32 <tty1> I want to be able to add arbitrary items to a graph by wrapping it in a Node type i will define. A node will effectively be a tuple containing a unique id and some content. Then i can connect nodes va edges This allows me to have two seperate nodes with equal content bit different connections... the id takes the place of a pointer in other languages
12:16:42 <tty1> make sense si far?
12:17:05 <monochrom> I haven't tried ATS but I heard from others that it's pretty optimized.
12:17:31 <monochrom> Yes it can also be extremely safe with extremely lots of proofs you write, too.
12:17:47 <monochrom> ATS proofs tend to be less readable than Agda proofs.
12:18:00 <dmj`> oats: network is great, websockets is great too
12:19:11 <tty1> Node is already an instance of Eq, Ord, Hashable, and functor... no issues there, but making it an applicativ, specifically the pure implementation is where im stuck since im trying to hide the id since there is no need to know it directly. 
12:19:20 <tty1> make more sense now?
12:19:24 <dmj`> oats: just use websockets, its pretty dead simple, make sure to forkPingThread though
12:19:25 <monochrom> tty1: Yes I would work in a state mond.
12:19:30 <monochrom> err, s/mond/monad/
12:19:57 <tty1> monochrom: im an extreme noob, still learning haskell... so i dont knoew state monad or what it does
12:20:15 <oats> dmj`: that package looks useful, but I'm not using websockets :)
12:20:34 <oats> I'm toying with a simple irc bot in haskell, so I'm using plain TCP connections
12:20:58 <oats> I'll check out network, thanks!
12:21:16 <dmj`> oats: websockets are plain tcp connections, they are just initiated with an HTTP upgrade request. The client isn't a browser in your case.
12:23:14 <tty1> trying to read up on state monad
12:23:40 <dmj`> oats: websockets are easier to deal with than trying to configure SSL manually with HsOpenSSL. Let nginx terminate your SSL and initiate the websocket connection through that.
12:24:33 <oats> dmj`: I'm sorry, I don't understand. The IRC protocol has nothing to do with http
12:24:39 <oats> as far as I understand
12:25:02 <dmj`> ah, have fun then
12:25:02 <oats> negotiating a connection with an irc server doesn't use http
12:25:16 <oats> ok :)
12:25:34 <dmj`> I missed your previous message
12:26:47 <oats> hey no worries
12:29:54 <tty1> I think i have a simple solution
12:30:13 <tty1> pure creates crippled node objects with id 0 that cant be compared....
12:31:43 <dmj`> > flip execState (1,1) $ replicateM_ 5 (_1 += 1)
12:31:45 <lambdabot>  (6,1)
12:34:27 <Solonarv> > (1,1) &~ replicateM_ 5 (_1 += 1)
12:34:29 <lambdabot>  (6,1)
12:34:33 <Solonarv> dmj`: :D
12:35:16 <Solonarv> x &~ st = execState st x , of course
12:35:35 <Solonarv> but conveniently infix and operator-y, as anything lens-adjacent should be :P
12:36:38 <tty1> does my approach sound sane ?
12:37:03 <monochrom> I thought you haven't finished describing it.
12:37:23 <tty1> ohh no thats it but i can elaborate if needed
12:39:55 <monochrom> I think it's OK.
12:40:59 <zincy> What does a kind of Maybe * mean?
12:41:29 <c_wraith> it means the polykinds extension is enabled and mucking up the display
12:42:14 <zincy> I dont have that extension on
12:42:25 <c_wraith> Oh, I suppose you could have DataKinds on, then
12:42:25 <monochrom> What is the context?
12:42:36 <zincy> But I wrote it as a explicit type annotation for the return type of a type family
12:42:42 <zincy> Yes Datakinds
12:43:17 <ski> your type family maybe computes a type
12:43:20 <dmj`> Solonarv: nice
12:43:26 <zincy> I wrote some code from my armchair so can show if needed :)
12:43:52 <ski>   type instance UnMaybe (Maybe t) = Just t
12:44:04 <ski>   type instance UnMaybe  _        = Nothing
12:44:07 <ski> perhaps
12:44:32 <tty1> monochrom: the thing is, does an object produced through pure need to be generally viable or can it be seen as a temporary wrapper that wont usually be used on its own beyond an immediate operation?
12:44:45 <zincy> ski: Yeah that is what is happening
12:45:20 <monochrom> I don't understand the question.
12:45:41 <zincy> my question?
12:45:45 <ski> yes
12:45:57 <ski> er, no. tty1's question
12:48:22 <zincy> So basically promoting maybe to the kind level is used it seems to denote failure in a type level function just like the at the term level
12:48:39 <ski> yes
12:48:48 <zincy> But you don't get the convenience of the typeclass instances
12:49:11 <ski> should there be kind classes ?
12:49:18 <zincy> Is there not?
12:59:44 <ski> hm, i suppose you could make type classes like `class Foo k where type Bar :: k -> k'
13:00:08 <Solonarv> yeah, you can do that
13:00:24 <Solonarv> but I'm not sure if they're all that useful
13:00:34 <ski> (requires `TypeInType' though, it seems)
13:00:49 <tty1> monochrom: well the way i see it if pure is only used in stuff like this `foo <$> bar" then the pure context is temporary so the fact that it is half incomplete wont matter (as ids arent important when applying applicatives).. but if someone would create a node object through pure on its own and intend to use it on its own it may cause issues with my approach
13:01:49 * ski is unfortunately not understanding what tty1 is talking about
13:02:12 <monochrom> I don't understand why pure is responsible for creating new nodes.  Or rather, I think it is highly misguided.
13:02:21 <tty1> ski: did you see the earlier explanation of what im doing in detail?
13:02:41 <tty1> well i dont want to use pure for creating new nodes at all usually.. but i need to impleent pure
13:03:24 <ski> `pure' is typically used it "trivial branches", e.g. base cases
13:04:06 <ski> (another use is using `pure'/`return' at the end of a `do'-block)
13:04:11 <tty1> would it help if i share the code up till now, its just a few lines
13:04:19 <ski> shoot
13:04:23 <tty1> ok
13:05:03 <ski> (i didn't read the earlier explanation, no. i suspect monochrom did, but still was confused by your earlier question)
13:06:20 <tty1> ok so this is what i have so far: https://hastebin.com/qewatunifu.sql
13:06:38 <tty1> trying to define a graph theory type data structure with nodes and edges
13:06:47 <monochrom> Wow hastebin really randomizes the file extension no?
13:07:02 <monochrom> Because last time someone got .rb
13:07:09 <Solonarv> fixed  - https://hastebin.com/qewatunifu.hs
13:07:19 <tty1> thx
13:07:22 <Solonarv> I don't know why it picks a random extension instead of asking, tbh
13:07:29 <Solonarv> but you can just edit the URL manually
13:07:38 <monochrom> No, let's try https://hastebin.com/qewatunifu.f
13:08:33 <Solonarv> tty1: that seems like a strange graph representation
13:09:54 <Solonarv> something like this seems more sensible to me:
13:09:54 <Solonarv> data Graph i v = Graph { nodeVals :: Map i v, edges :: Set (i, i) }
13:10:40 <Solonarv> (ditching the Node datatype)
13:11:03 <dmj`> type AdjList = IntMap IntSet, if only using Ints
13:13:11 <tty1> Solonarv: so what if i wanted two seperate nodess int he graph each one having the value of 5?
13:13:35 <tty1> Solonarv: or what if i wanted to stick non hashable values into the graph?
13:13:43 <tty1> someone needs to define the ID somewhere no?
13:17:49 <Solonarv> tty1: Graph { nodeVals = Map.fromList [(1, 5), (2, 5)], edges = Set.fromList [(1, 2)] }
13:18:11 <Solonarv> the only thing that needs to be Hashable is 'i', which is the *indexes* of your nodes
13:18:23 <tty1> Solonarv: right how is that functionally different than mine?
13:19:49 <Solonarv> tty1: you're using a set-of-pairs with strange Eq/Ord/Hashable instances to hack together a Map
13:19:53 <Solonarv> why not just use a Map ?
13:20:21 <tty1> Solonarv: because then the id's are exposed tot he consumer rather than handled transparently
13:20:39 <Solonarv> you can just wrap them in an opaque newtype or something
13:20:44 <ski> (oh .. if i manually insert `raw/' in the right place in the URL, then i can actually see the code)
13:21:13 <Solonarv> newtype Node i v = MkNode i, and just use 'Node i v' in your API
13:21:18 <ski> (obviously the "Just Text" button didn't work, i had to dive into the HTML source)
13:21:31 <Boarders> I am trying to get a stack trace after building with profiling but I am getting no output, I built with "cabal new-build --enable-profiling" and then passed the option +RTS -xc -RTS, could someone let me know if this is incorrect?
13:21:53 <Solonarv> ski: I assume you have aggressively disabled JS ?
13:22:16 <ski> tty1 : actually, i see no `pure' there ?
13:22:29 <ski> Solonarv : W3m doesn't support ECMAScript
13:22:36 <Solonarv> Boarders: looks good to me
13:23:02 <Boarders> do you need to do --enable-executable-profiling?
13:23:02 <Solonarv> if you're running the program using something like 'cabal v2-run', make sure you're passing the RTS args to your program and not to cabal
13:23:05 <tty1> ski: because i havet implemented it yet.. i was going to add Applicative next but not sure how to go about it sanely other than the ideas i shared
13:23:17 * ski doesn't get why people would make buttons on pages that can't be operated without ECMAScript
13:24:12 <Solonarv> tty1: tbh, I can't think of a reasonable 'pure' implementation
13:24:59 <ski> (is tty1 thinking about `Applicative (Node i)' ?)
13:25:02 <tty1> Solonarv: the only one i can think of is to give it an id of 0 and then teat 0 special such that it can be compared or equated or hashed.. that way pure wil only be used as a transient container for doing applicative operations on it
13:25:10 <tty1> yes
13:25:11 <Solonarv> seems icky
13:25:16 <tty1> i want to make Node applicative
13:25:25 <tty1> it does yea
13:25:40 * ski . o O ( `Monoid' )
13:25:41 <Solonarv> is there a particular reason you're so insistent on this Node type?
13:26:49 <tty1> Solonarv: well i want to hide the ID from the user for one.. for another i will later add other stuff to it (like weighted nodes)
13:27:23 <Solonarv> if you want to hide the ID, use something like the newtype I suggested above
13:31:13 <tty1> Solonarv: what does the v do in that new type? looks like a type that isnt actually used in the expression
13:31:41 <Solonarv> yes, that is correct
13:31:54 <Solonarv> you could leave it out as well
13:41:21 <tty1> Solonarv: how does that benefit me then?
13:41:50 <Solonarv> helps show in your API which graph an index "belongs" to
13:42:05 <Solonarv> I'm not sure if that's useful, though
13:45:17 <tty1> Solonarv: can you show me an example usage?
13:45:43 <Solonarv> not really, tbh I'm not convinced that the v parameter should be on Node at all
13:49:09 <Solonarv> tty1: this s roughly how I'd implement a simple graph structure: https://gist.github.com/Solonarv/033d56b6e360c1a81960ae807161fd61
13:50:02 <tty1> hmm
14:11:13 <trcc> How do you guys do logging in haskell - i.e. to a file? Does your functions return a tuple, where one value is the accumulated log, and then at the "top-level" perform the actual write to the file?
14:14:35 <c_wraith> usually logging is done where IO is available
14:15:08 <trcc> c_wraith: hehe that can be avaiable anywhere
14:22:23 <mp___> https://hackage.haskell.org/package/base-4.12.0.0/docs/Debug-Trace.html - this is sometimes useful to track what and when is evaluated in pure code, but its more for debugging I guess..?
14:23:18 <trcc> mp___: yes I think so. I am looking for some ideas on "patterns" or similar
14:37:13 <zincy> Is this the usual way of creating a Symbol type:  data MySymb
14:38:02 <zincy> Or is this what the Proxy type is for
14:43:01 <fif> what does it says when the power output of a laser is stated as "100 mW with 5%"
14:43:01 <fif> is that just 5mW?
14:43:01 <fif> if so, why they describe it like that
14:43:43 <SteveDeFacto> Anyone here to development for salesforce/apex?
14:43:49 <Solonarv> perhaps that's variance or something
14:44:06 <Solonarv> like, a way of saying "somewhere between 95mW and 105mW"
14:44:14 <segeljakt> what does <|> and <*> mean?
14:44:18 <SteveDeFacto> I know it's completely unrelated to haskell but I have no idea what irc has active users for salesforce/apex?
14:44:35 <Solonarv> segeljakt: they're members of Alternative and Applicative, respectively
14:45:17 <segeljakt> thx
14:45:20 <zincy> alternative and applicative
14:45:39 <Cale> Whenever you actually have a monad, it might help to know that mf <*> mx is basically the same thing as  do f <- mf; x <- mx; return (f x)
14:45:51 <Solonarv> you can read <|> as "or else", but I don't have as convenient a phrase for <*>
14:46:09 <segeljakt> are there any more < > thingmajigs?
14:46:16 <zincy> <$>
14:46:20 <zincy> And many more
14:46:35 <Cale> Applicative generalises that kind of operation further, so that you might not actually have a bind operation, and may not even be able to decide on which effects will happen based on the outcomes of previous actions
14:46:38 <segeljakt> are they builtin?
14:46:43 <Cale> No
14:46:43 <SteveDeFacto> I'll just ask my question... Sales people in our company want to use a browser extension to essentially DDoS attack our Salesforce org... Does salesforce have anything to prevent this from effecting other users in the org?...
14:46:46 <Cale> They're library functions
14:47:04 <segeljakt> ok
14:47:09 <zincy> <*> - is basically a way of statically sequencing values without changing the context of the computation
14:47:16 <Cale> SteveDeFacto: This is... not likely going to be the right crowd of people to ask
14:47:24 <zincy> not values operations
14:47:30 <Solonarv> segeljakt: they're part of the standard library; I guess you could call them "built in", but the compiler doesn't treat them specially
14:47:33 <SteveDeFacto> Cale: any idea where I can ask this?...
14:47:39 <Cale> I dunno, google it
14:47:47 <SteveDeFacto> Cale: I did...
14:47:53 <SteveDeFacto> Cale: There is nothing...
14:47:59 <Cale> and you came up with the Haskell IRC channel?
14:48:17 <__monty__> How do these random questions end up here?
14:48:28 <SteveDeFacto> Cale: yes, it was the most active developer community according to people on hackernews...
14:48:49 <Solonarv> yes, it's a community of Haskell developers. Not a community of generalist wizards.
14:48:55 <Cale> SteveDeFacto: I don't even know what Salesforce is, but it sounds like a company. You'd be best off contacting them directly.
14:49:35 <SteveDeFacto> Cale: Part of my issue is that our support is monitored by management... Management is stupid and doesn't understand...
14:50:09 <SteveDeFacto> Cale: They want 300 sales people to use this extension to refresh pages every 1 second....
14:50:38 <Cale> anyway, this is offtopic here.
14:50:41 <dmj`> SteveDeFacto: ddos'ing sounds unethical, but salesforce can handle the traffic I'm sure, being a large saas provider, or they'll just ban your ip range and email you if they don't like it.
14:50:48 <SteveDeFacto> Cale: I told them it would destory our instance performance. They said it's not their problem...
14:51:03 <dmj`> SteveDeFacto: they'll probably just throttle you if they can
14:51:04 <Cale> Sounds like not our problem to me
14:51:52 <SteveDeFacto> dmj': Salesforce limits our instance's bandwidth so it will essentially make salesforce unusable and I will be blamed...
14:51:58 --- mode: ChanServ set +o Cale
14:52:28 <SteveDeFacto> dmj': I know they will... I need to prevent this from happening...
14:52:33 --- mode: Cale set +b *!*@ip-173-138-135-25.phnxaz.spcsdns.net
14:52:39 --- kick: SteveDeFacto was kicked by Cale (SteveDeFacto)
14:52:48 --- mode: Cale set -o Cale
14:54:51 <Solonarv> Cale: thanks
14:55:18 <MarcelineVQ> Not sure why he thought we could help with an internal communication issue :X Cale: Are there any main/particular parts where reflex diverges from frp as conal would describe it?
14:56:15 <MarcelineVQ> If it does that is
14:56:24 <Cale> MarcelineVQ: Conal's FRP has more operations, for example integration
14:56:35 <Cale> It makes stronger assumptions about the nature of time
14:57:18 <Cale> Reflex's model is compatible with such things, but we haven't implemented them, and it's sort of impossible to tell whether time is discrete or continuous -- it's simply totally ordered.
14:58:09 <JohnSnow> Hello, it's me again.
14:59:18 <Cale> At present, Reflex only gives you a way to get hold of Behaviors that are step functions, but also gives you no way to show that this is actually the case. We *could* have continuously varying Behaviors, there's just no way to get hold of them (yet?)
14:59:19 <JohnSnow> I'm the guy who was asking about where to ask questions regarding  blocking users from DDoSing an Salesforce instance. You can't ban me...
14:59:30 --- mode: ChanServ set +o Cale
14:59:32 <JohnSnow> I have endless Ips...
14:59:34 --- mode: Cale set +b *!*@gateway/web/freenode/ip.46.21.151.107
14:59:34 --- kick: JohnSnow was kicked by Cale (JohnSnow)
14:59:51 * Clint sighs.
14:59:52 <MarcelineVQ> Oh see that's pretty interesting, I'm reading http://neilsculthorpe.com/publications/safe-FRP-types.pdf and it differentiates discrete and continuous things as well as uses integration as one of the examples so the fact that you mention these things specifically is semi-serendipitous
15:01:08 <__monty__> Hmm, I think I figured out how people with random questions get here. "I have a DDOS question, I need a hacker. Googles 'hackers'. Hmm, hackernews looks promising. Reads #haskell on IRC is the largest community." And then they come here to ask their question.
15:01:22 <zincy> Am I right in saying that GADTs don't magically allow you to use type variables of kind other than * 
15:01:45 <Cale> zincy: You can have GADTs parametrised over types of another kind if you like
15:01:51 <Cale> Including constraints
15:01:56 <MarcelineVQ> __monty__: pretty much, and their cover story doesn't tend to last too long, as you can see in this case.
15:02:14 <zincy> Cale: I am trying to have a type variable be a kind Symbol
15:03:00 <Solonarv> zincy: you don't need GADTs for that, you need KindSignatures (to write the kind signature; GHC can perfectly well infer it too)
15:03:30 <zincy> I am using the GADTs for something else though :)
15:03:34 <Solonarv> % newtype MyNamedVal (name :: Symbol) a = MyNamedVal a deriving (Show, Functor)
15:03:34 <yahb> Solonarv: ; <interactive>:134:29: error: Not in scope: type constructor or class `Symbol'
15:03:58 <Solonarv> yes, you can do that with GADTs too; they can be parameterized over types of whatever kind you want
15:04:24 <zincy> Maybe I need to use a proxy type
15:05:58 <Solonarv> well, yes, you can't have a field of type Symbol
15:06:19 <Solonarv> perhaps you could say what you've tried, or what you'd like to write but isn't working?
15:07:11 <zincy> Sorry for not being clearer
15:07:40 <zincy> It came down to     PreDealGame :: "PreDeal" -> Vector Card Z -> Game  ("PreDeal") (Vector Card 'Z ) 
15:07:55 <zincy> versus     PreDealGame :: Stage "PreDeal" -> Vector Card Z -> Game  (Stage "PreDeal") (Vector Card 'Z ) 
15:08:19 <zincy> I am not 100 percent sure why but "PreDeal" had kind Symbol and the compiler wasnt happy
15:08:25 <Solonarv> what's Stage? just a specialized Proxy?
15:08:30 <zincy> Yes
15:08:39 <zincy> data Stage (a :: Symbol) where Stage :: Typeable a => Stage a 
15:08:51 <Solonarv> zincy: yes, the types of fields must be inhabited, which means their kinds must be Type
15:09:01 <zincy> is Type = *
15:09:04 <Solonarv> yes
15:09:17 <Solonarv> the * causes some problems and will eventually be gone
15:09:24 <zincy> So why is a symbol not of kind Type?
15:09:39 <zincy> Because it has no inhabitants?
15:09:43 <Solonarv> because its kind is Symbol, and Symbol ≠ Type
15:09:44 <zincy> apart from _|_
15:09:49 <Solonarv> no, not even bottom
15:10:24 <Solonarv> much like you can't have a value of type 'Maybe', you can't have a value of type 'Symbol'
15:10:38 <geekosaur> Type means it has values. a Symbol has no values, it's a "marker" / phantom
15:10:45 <geekosaur> or it can have values
15:11:09 <Solonarv> if T is the type of a value, then T :: Type, always (ignoring unlifted/primitive types, which don't meaningfully change the story)
15:11:26 <geekosaur> notably it cant have a value level String as a value because then it would be unclear whether a value level String were kind Type or Symbol
15:12:00 <zincy> gotcha
15:12:37 <zincy> So it appears that GHC.TypeLits uses DataKinds to promote Symbol to the TypeLevel
15:12:41 <geekosaur> well, that's oversimpliying  because values have types, not kinds, but the type woul be ambiguous between one of kind Type and oen of kind Symbol. <-- pedantry...
15:12:42 <zincy> sorry kind
15:13:44 <Solonarv> well, actually Symbol is wired in and powered by compiler magic
15:13:53 <geekosaur> I think that's just an accident of implementation; iirc it's difficult at the level of ghc to create a new kind on the fly, it's easier to promote a new type
15:14:06 <Solonarv> yup, pretty sure that's it
15:14:36 <upper> It's Steve again. I'm more than happy to play this game with you all day but you should be aware that you are banning IPs from various VPN providers and will eventually hurt many users of this IRC channel. I have no malicious intentions.
15:14:37 <geekosaur> and may be a "known name", as opposed to generated internally
15:15:54 <zincy> So does compiler magic power the mechanism through which any string literal can be made into a type of kind Symbol with just an explicit type annotation?
15:16:39 <Solonarv> zincy: those aren't string literals describing values and magically being turned into types
15:16:43 <upper> Any who, are there any general developer IRC channels where I can ask questions about Salesforce/Apex?
15:17:32 --- mode: Cale set +b *!*@gateway/web/freenode/ip.193.148.16.211
15:17:32 --- kick: upper was kicked by Cale (upper)
15:17:43 <Solonarv> the type application syntax @<blah> means that <blah> is a type, and "quoted string" in types are Symbol's
15:18:38 <zincy> ah nice
15:19:19 <zincy> Haskell language extensions are way more powerful in general than I thought
15:20:09 <phadej> indistiguishable from magic
15:20:35 <zincy> Dark sorcery
15:20:43 --- mode: Cale set +b *!*@199.249.230.22
15:20:44 --- kick: SteveDeFacto was kicked by Cale (SteveDeFacto)
15:21:34 <zincy> So recently learning about GADTs and TypeFamilies
15:21:57 <zincy> What would be the next ones to investigate for type level stuff
15:22:12 <zincy> obviously I have looked at DataKinds
15:24:15 <quilll> Cale: I know you think you have power but you don't.
15:24:29 --- mode: Cale set +b *!*@gateway/web/freenode/ip.103.16.27.26
15:24:29 --- kick: quilll was kicked by Cale (quilll)
15:28:08 <oats> that was actually pretty funny
15:29:34 <righttex> Cale: I will write a script if you want to continue this.
15:34:36 --- mode: Cale set +q *!*@gateway/web/freenode/ip.185.103.96.151
15:38:34 <zincy> Is this kind of practice frowned upon:  type PreDealGame = Game (Stage "PreDeal") (Board 'Z) 
15:38:59 <zincy> Where Board 'Z is a type level list
15:39:22 <zincy> and Stage "PreDeal" is a Proxy holding a Symbol
15:39:23 <Cale> Why use Symbol when you could use a type that actually enumerates the possibilities?
15:40:10 <zincy> That would be at the value level?
15:40:34 <Cale> DataKinds are a thing
15:40:42 <zincy> oh tell more
15:40:54 <zincy> So just promote the constructors
15:41:01 <Cale> yeah
15:41:11 <zincy> and then have say Game 'PreDeal (Board 'Z)
15:41:22 <Cale> But also I should say, I'd generally frown on doing this kind of thing without very good reason
15:41:56 <illunation> Cale: How are you feeling today?
15:42:01 --- mode: ChanServ set +o geekosaur
15:42:15 --- mode: geekosaur set +b *!*@*.199.19.94.62
15:42:54 <Cale> You *can* encode a lot of information at the type level, but the more you do that, the more you end up wanting to encode computation at the type level as well, and that's significantly more awkward than encoding the same computation at the term level in general.
15:43:23 <infinisil> There should be an IRC command to mute somebody, but without them realizing it
15:43:40 --- mode: geekosaur set -b *!*@*.199.19.94.62
15:43:44 <Cale> Yeah, I'd love to be able to shadowban
15:43:49 <Solonarv> yeah!
15:43:55 <zincy> hmm       • Expected a type, but ‘ 'PreDeal’ has kind ‘Stage’
15:44:26 <zincy> Cale: Yeah it is a learning exercise
15:45:25 <Solonarv> zincy: yes, your Game definition should reflect that it takes a Stage as a parameter
15:45:46 <wesshaskell> Cale: It's unfortunate that this IRC channel has a moderator like you who disregards the negative effects of his actions.
15:46:20 --- mode: Cale set +b *!*@gateway/web/freenode/ip.62.102.148.166
15:46:20 --- kick: wesshaskell was kicked by Cale (wesshaskell)
15:49:21 <zincy> Solonarv:     PreDealG :: 'PreDeal -> Board 'Z -> PreDealGame 
15:49:39 <zincy> The first parameter reflects that no?
15:49:48 <lhdsf> Cale: You are about to be blocking chat bots all day rambling around random garbage.
15:50:01 <Solonarv> no, constructor fields' types must have kind Type
15:50:02 <yushyin> I'm ok with +r
15:50:04 <yushyin> :)
15:50:47 <Solonarv> so you would have something like:
15:50:47 <Solonarv> data Game (stage :: Stage) where
15:50:47 <Solonarv>   PreDealG :: Board 'Z -> Game 'PreDeal
15:52:10 <lhdsf> Cale: How long have you been a moderator on here?
15:53:08 <infinisil> lhdsf: If you want to talk about offtopic stuff, go to #haskell-offtopic please
15:53:50 <lhdsf> infinisil: This is between me and Cale. You stay out of it.
15:53:57 --- mode: Cale set +b *!*@gateway/web/freenode/ip.89.238.166.235
15:53:57 --- kick: lhdsf was kicked by Cale (lhdsf)
15:54:50 <zincy> Solonarv: Does the final type not need to include the Board 'Z ?
15:56:06 <Solonarv> zincy: it could, if that were part of the definition
15:56:38 <rexyo> What are your three must have smart phone apps?
15:56:45 --- mode: Cale set +b *!*@gateway/web/freenode/ip.62.102.148.164
15:56:45 --- kick: rexyo was kicked by Cale (rexyo)
15:58:34 <zincy> Solonarv: https://gist.github.com/therewillbecode/2aa5d952f48f4324fc7494f004a0f7cd
15:58:35 <vexbo> What qualities do you value most in a friend?
15:58:56 <MarcelineVQ> are 'lens' lenses profunctor based?
15:59:01 <vexbo> Would you rather have to sit all day or stand all day?
15:59:13 <oats> vexbo: hey, all you're doing is annoying everyone else in here now. would you mind knocking it off please?
15:59:19 <vexbo> Who is your favorite actor/actress?
15:59:33 <vexbo> Would you prefer to live in an urban area or a rural area?
15:59:40 <Solonarv> MarcelineVQ: no, they use the van laarhoven encodig
15:59:50 <vexbo> thanks. I'll stop now.
15:59:51 <Solonarv> although prisms and isos are some unholy hybrid of the two
15:59:58 <Solonarv> because they don't work well in the VL encoding
16:00:03 <MarcelineVQ> Solonarv: Do you happen to know why that is?
16:00:11 <Solonarv> MarcelineVQ: no idea tbh
16:00:28 <MarcelineVQ> Alrighty
16:01:03 <Solonarv> zincy: this clearly doesn't type-check
16:01:38 <SteveDeFacto> Cale: You aren't so bad.
16:02:06 <Solonarv> zincy: you say that Game takes a Type parameter but then you go on to give it PreDeal and PreFlop, which are :: Stage and not :: Type
16:03:20 <geekosaur> oh, is our new pet back?
16:06:21 <hpc> oh god, i just googled van laarhoven encoding
16:06:52 <hpc> i really need to get better at higher-ranked types
16:07:44 <Cale> hpc: They're not necessarily higher-ranked...
16:07:49 <MarcelineVQ> hpc: there's a data61 repo about making your own lenses that has you make van larrhoven ones iirc
16:08:23 <hpc> ah
16:08:36 <hpc> i just found another package that had a higher-ranked type around (forall m. Monad m => ...)
16:08:44 <hpc> and figured that was the main bit
16:08:51 <Solonarv> I like the profunctor encoding better because prisms/lenses are more uniform
16:09:29 <Solonarv> type Lens  s t a b = forall f. Strong p => p a b -> p s t
16:09:30 <Solonarv> type Prism s t a b = forall f. Choice p => p a b -> p s t
16:10:17 <hpc> that's pretty nice
16:10:23 <Solonarv> yeah :D
16:12:03 <hpc> MarcelineVQ: ooh, bookmarked
16:12:08 <MarcelineVQ> Would much of lens be subsumbed by first class record syntax? If that's a sensible question
16:12:55 <hpc> i think so
16:13:04 <Solonarv> nah
16:13:11 <zincy> Solonarv: Ok having a look
16:13:31 <Solonarv> lenses could be a way to expose row-polymorphic record operations
16:13:39 <Solonarv> but lenses are not the only kind of optic around
16:14:08 <Solonarv> other examples include prisms, traversals, isomorphisms, folds, ...
16:18:59 <dmwit> forall f. Strong p, eh?
16:19:07 <dmwit> =P
16:19:12 <Solonarv> bleh, typing is hard
16:19:18 <Solonarv> I should really be asleep tbh :P
16:19:53 <hpc> anything goes pre-typechecking
16:22:57 <Solonarv> compare the van laarhoven encoding:
16:22:58 <Solonarv> type Lens  s t a b = forall   f.            Functor f      => (a -> f b) -> s -> f t -- okay, pretty nice
16:22:58 <Solonarv> type Prism s t a b = forall p f. (Choice p, Applicative f) =>  p a (f b) -> p s (f t)
16:22:58 <Solonarv>                                  ^^^^^^^^^^^^^^^^^^^^^^^^^     ^^^^^^^^^
16:22:58 <Solonarv>                                  the fuck is this shit???      ???
16:23:39 <phadej> *cleverness*
16:25:21 <hpc> you know, (->) is an instance of Choice
16:25:29 <hpc> so in a special case:
16:25:31 <MarcelineVQ> Doesn't look that different to a dummy like me, you still need to know what Choice is
16:25:31 <hpc> type Lens  s t a b = forall   f.            Functor f      => (a -> f b) -> s -> f t
16:25:59 <Solonarv> yes, (->) is choice, which means that setters work
16:26:08 <Solonarv> (setters use f ~ Identity)
16:26:10 <hpc> type Prism s t a b = forall f.             (Applicative f) =>  (a -> f b) -> s -> f t
16:26:17 <hpc> ah, almost aligned
16:26:17 <MalkataChochka> Hi, boys! It's time for my Live Show. I start in 10 minutes. If you would like to watch, just send me a message "Free Vip Invite" in the Cam Site (and let the fun begin!). Link: https://ix2.co/gvcYro9
16:26:25 <Solonarv> and that ^ is a traversal, not a prism
16:26:47 <Solonarv> you can use it to try to retrieve some unknown number of values, or as a setter
16:26:59 <Solonarv> notable you can't turn it around to use as a constructor
16:27:17 <hpc> (i say "you know", but that was a lucky guess that i checked with hoogle lol)
16:27:44 <Solonarv> it's a fairly safe guess, (->) is an instance of most of the profunctory classes
16:28:10 <hpc> it's not quite as magical as Choice/Strong though
16:29:33 <Solonarv> I also like the Choice/Strong versions because Choice/Strong are basically "interacts nicely with sums/products", and prisms/lenses are isomorphisms to a sum/product
16:29:39 <Solonarv> so it's nice and symmetric
16:30:35 <Solonarv> whereas I had to look up how lens even does Prism, because it makes no darn sense
16:31:07 <phadej> I probably should extend glassery with VL stuff
16:31:13 <phadej> for comparison
16:37:01 <SteveDeFacto> sw1nn: Why are you joining from an ec2 instance?
16:45:29 <hpc> having 100% uptime in an irc channel is pretty handy
16:46:52 <Solonarv> yeah, I'll be connecting from a VPS once I can figure out how to install stuff on it
16:47:26 <Solonarv> although if you see someone connect, they sure don't have 100% uptime!
16:47:54 --- mode: ChanServ set +o glguy
16:47:54 --- mode: glguy set +qz *!*@gateway/web/freenode/*
16:53:32 --- mode: geekosaur set -o geekosaur
17:00:06 <phadej> Solonarv: network glitches happen :)
17:00:15 <Solonarv> true
17:00:23 * Solonarv something something five nines
17:00:30 <hpc> something something nine fives
17:01:37 <phadej> my client dropped in the beginning of May, and in the beginning of February before that
17:01:54 <phadej> maybe server just kicks me out every three months :(
17:03:12 <hpc> gotta have a little bit of downtime, or you'll technically have zero nines of uptime
17:05:53 <DigitalKiwi> thanks i hate it
17:39:46 <dibblego> MarcelineVQ: I think it wouldn't subsume much at all. Ed and I are running that material today in Melbourne.
17:40:56 <MarcelineVQ> gonna be filmed? :>
17:46:20 <DigitalKiwi> dibblego: make sure to canvas for icelandjack while you're in melbourne
17:46:40 <dibblego> What you mean canvas?
17:46:57 <dibblego> I don't think it is filmed. Can't see any camera
17:48:39 <DigitalKiwi> locate him
17:49:38 <DigitalKiwi> he wasn't in brisbane or sydney melbourne was the next place to look
17:51:50 <DigitalKiwi> is that not a correct usage of canvas
17:52:13 <DigitalKiwi> have i committed a foe paw
17:59:22 <geekosaur> I've seen that usage spelled "canvass", and suspect it's somewhat regional
18:02:23 <geekosaur> "Canvass Can"vass, v. t. [imp. & p. p. canvassed; p. pr. & vb. n. Canvassing.] [OF. Canabasser to examine curiously, to search or sift out; properly, to sift through canvas. See Canvas, n.]"
18:03:11 <MarcelineVQ> canvas also means to fully cover
18:03:29 <MarcelineVQ> or exhaustively search
18:08:39 <DigitalKiwi> phew i was worried people might know, i mean think, i was an id10t
18:15:22 <Axman6> Bloody New Zealanders talking in their New Zealandish
18:17:31 <DigitalKiwi> i'm not a native english speaker; i'm american!
18:17:39 <Axman6> ha
18:39:58 <royal_screwup21> what does "monomorphic" binary search mean? I'm looking at an example here https://github.com/fpinscala/fpinscala/blob/master/answers/src/main/scala/fpinscala/gettingstarted/GettingStarted.scala
18:42:17 <monochrom> Usually "monomorphic" = "not polymorphic"
18:42:29 <geekosaur> tey're showing how to write the search for a specific single type (String) first
18:42:34 <geekosaur> the next example is polymorphic
18:43:08 <royal_screwup21> ah okay...I'm not sure how binary search comes into the picture then; it seems like a linear traversal
18:43:23 * DigitalKiwi sees dibblego has been telling scala folks to learn haskell again ;p
18:43:56 <geekosaur> it's progressive. all the examples are in the same class, starting from monomorphic linear and building toward polymorphic binary
18:44:50 --- mode: ChanServ set +o dmwit
18:45:07 <geekosaur> hm, except it's incomplete
18:45:21 <geekosaur> they build a bunch fo stuff and then it just ends
18:45:59 <geekosaur> kinda looks like it's a work in progress, with the bones of an earlier version
18:46:03 <monochrom> I am not polychromic :)
18:46:12 <royal_screwup21> hmm yeah, polymorphic or monomorphic, that's definitely not a binary search
18:46:56 <geekosaur> yeh, but they're building the components needed for the other afterward
18:47:00 <geekosaur> they never use them though
18:47:24 <geekosaur> which is why I think it's a work in progress, ince I don't see an indication that you're supposed to put the pieces together and the pieces are incomplete
18:53:29 <geekosaur> exempt
18:53:30 <geekosaur> er
20:36:18 <davean> __name__: 
20:52:39 <royal_screwup21> so I'm looking at the definiton of <*> in the context of parsers 
20:52:43 <royal_screwup21> ` >   Parser pf <*> Parser px =>     Parser (\ts -> [ (f x, ts'') | (f, ts')  <- pf ts>                                  , (x, ts'') <- px ts'])`
20:53:23 <royal_screwup21> err I have a clear screenshot https://prnt.sc/nnr8ng
20:53:37 <royal_screwup21> anyway, so what happens if px ts's returns an empty list?? 
20:53:59 <royal_screwup21> then we woulnd't be able to extract a (x, ts's) out of it 
20:54:16 <royal_screwup21> (x, ts'')  **
20:55:07 <royal_screwup21> and the types wouldn't match...would that result in a runtime error?
20:58:57 <ski> no run-time error
20:59:00 <geekosaur> no, it invokes list's fail which produces the empty list
20:59:16 <ski> > [(x,y) | x <- [0,1,2,3],y <- []]
20:59:18 <royal_screwup21> ahhh
20:59:18 <lambdabot>  []
20:59:54 <ski> > concatMap (\x -> error "whatever") []
20:59:55 <lambdabot>  []
21:00:10 <ski> it amounts to that
21:00:54 <ski> `<-' in a list comprehension means "try selecting each element of the list"
21:01:06 <ski> with multiple `<-'s, it'll try each combination of selections
21:01:25 <ski> if one of the lists is empty, then there's zero combinations. `4 * 0' is still `0' in the above example
21:01:42 <ski> (and, `<-' in `do', for the list monad, does the exact same thing ..)
21:01:53 <suzu> it can also be rephrased into do-notation: do { x <- [0..3]; y <- []; return (x, y) }
21:01:57 <ski> > do x <- [0,1,2,3]; y <- []; return (x,y)
21:01:59 <lambdabot>  []
21:02:04 * ski smiles
21:02:29 <suzu> > do { x <- [0..3]; y <- [0..3]; return (x,y) }
21:02:31 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3,...
21:02:40 <suzu> > do { x <- [0..3]; y <- [0..1]; return (x,y) }
21:02:42 <lambdabot>  [(0,0),(0,1),(1,0),(1,1),(2,0),(2,1),(3,0),(3,1)]
21:02:47 <suzu> > do { x <- [0..3]; y <- []; return (x,y) }
21:02:49 <lambdabot>  []
21:03:05 <ski> > do x <- [0 .. 3]; y <- [0 .. x]; return (x,y)
21:03:07 <lambdabot>  [(0,0),(1,0),(1,1),(2,0),(2,1),(2,2),(3,0),(3,1),(3,2),(3,3)]
21:04:44 <ski> > do z <- [1 ..]; y <- [1 .. z]; x <- [1 .. y]; guard (x^2 + y^2 == z^2); return (x,y,z)  -- Pythagorean triples
21:04:48 <lambdabot>  [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17),(12,16,20),(15,20,25),(7,24,...
21:05:20 <ski> > [(x,y,z) | z <- [1 ..],y <- [1 .. z],x <- [1 .. y],x^2 + y^2 == z^2]  -- as a list comprehension
21:05:23 <lambdabot>  [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17),(12,16,20),(15,20,25),(7,24,...
21:06:12 <ski> (exercise : make that list not contain any triple which is a proper (integral) scaling of another triple in the list)
21:07:28 <ski> (e.g. `(6,8,10)' is a scaling of `(3,4,5)', since `(2 * 3,2 * 4,2 * 5) = (6,8,10)'. and it's proper, since the scaling factor `2' is not `1' (or `-1'))
21:09:39 <ski> (fwiw, i probably wouldn't express myself as "invokes list's fail" .. though i do know what was meant)
21:13:57 <suzu> hmm
21:14:39 <suzu> i suppose x must be a list of primes then?
21:15:23 <ski> `8' doesn't look like a prime, to me
21:18:16 <suzu> i mean to satisfy the exercise
21:18:24 <suzu> limit the chosen 'x' to be only prime numbers
21:19:20 <suzu> hm wait nope
21:19:27 <suzu> wait hm
21:19:29 <suzu> yea..h?
21:19:35 <suzu> idk my number theory is prett yshit
21:20:12 <suzu> it'd exclude 8 15 17
21:20:17 <suzu> so it doesn't work
21:37:51 <jle`> hm, does the github package registry announcement mean anything for the haskell ecosystem 
21:56:05 <suzu> no
21:56:08 <suzu> not yet at least
21:56:19 <suzu> but even in general, no
21:56:21 <[exa]> jle`: hopefully not, seems extremely npm-oriented
21:56:29 <suzu> yeah
21:59:28 <[exa]> anyway there could probably be direct cabal to that, provided they'd add api support, but I'm seriously scared of having a package repository without some at least partially serious decisive authority behind
21:59:39 <MarcelineVQ> conal: Is http://conal.net/papers/push-pull-frp/ the latest writing you have on frp?
22:16:34 <dmwit> geekosaur: (There's no call to `fail` in there. None of the patterns fail to match. The continuation just doesn't get called.)
22:50:01 <jgt> has anyone tried using test-fixture or monad-mock?
