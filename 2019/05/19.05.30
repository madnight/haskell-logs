00:30:56 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
00:30:56 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
00:30:56 --- names: list (clog rfold savolla freeside esp32_prog ralejs acidjnk zariuq _bo juri_ freeman42x antsmartian koz_ mulk cur8or bahamas Sk01 lprd_ monochrom reactormonk jusss` thc202 Saukk jgt takuan nshepperd henriksod veox1 fmixing jeltsch nfd9001 danso unlink2 revtintin slomo gmips[m] fweht rruizt f-a raatiniemi osa1 MoarSpaceFi honungsburk vlatkoB jneira boj Anthaas xelxebar niHiggim harfangk forgottenone pankajgodbole tomboy64 nowhere_man alyptik mikecheck tabemann)
00:30:56 --- names: list (Clough cjenn toppler`` [Leary] otto_s wei2912 lagothrix nesqi taiite shah^ theDon teardown jchia kwantam jb55 justanotheruser hamishmack tromp polmaan cybai hiredman dfordivam eiGHttt albertus11 troydm keep_learning_M aarvar ziyourenxiang plutoniix carlomagno sudden oats Foritus notzmv byorgey ricekrispie2 acarrico averell Lord_of_Life filedesless hiptobecubic_ pfurla eschnett kipras sz0 Xeyame TommyC s00pcan subfacto1 sqrt2 poljar noan abrar oni-on-ion)
00:30:56 --- names: list (royal_screwup21 MatrixBot3 vjacob gxt andreas303 ClaudiusMaximus wnbehsklr zxrf gienah RedNifre wonko7 JimmyRcom teaknow[m] fionnan DigitalKiwi zzz alp nighty revprez Sgeo_ gentauro caa51h mnrmnaughmnrgle golergka nullifidian nicoulaj Frobozz catsup ashirase eeva zmt01 texasmynsted mceier enragedjam piyush-k` yahb mniip giraffe dmiles mkoenig_ Cloud[m] nyaomi DTZUZU2 WeiTang[m] ShujaRafi[m] thecodedmessage wengrow[m] soaoaig[m] avocado runningriot9[m])
00:30:56 --- names: list (rainbyte[m] ovigren[m] nirvin[m] MichalLaskus[m] iarp[m] vladimirp1[m] GNULizard[m] cr0gs Warder[m] vars[m] actartis[m] thejonny[m] haiderkhan[m] reedhhw[m] hkimhvyh[m] Obscurity[m] jennie[m] kahuna[m] fregex JakeO[m] illandan[m] int-index AkikoHimenokoji[ cjskaggs[m] deklund[m] eckt[m] hackeryarn[m] petrichor ad5twoknebor[m] mithrandi[m] pineapple[m] buggeas40d[m] cepxuo roberth MerlinGttlinger[ m1andrew[m] hans[m]4 limabeans[m] supersweetsweetc jhg_0[m])
00:30:56 --- names: list (hjoest[m] godva[m] jerrytgarcia[m] jenkee[m] joenase[m] luciandesozay[m] tmallard[m] cawal[m] risorg[m] aitzol[m] dag[m] ciet[m] tswett[m] shanesveller[m] Videled[m] Mesa[m]1 Syllo[m] buster528[m] unevens[m] tinwood[m] Adam[m]7 kai10[m] zocijux[m] bt[m] javjarfer[m] hsw[m] Mougan[m] GhostofaConsole[ dlilja[m] exarkun1 NickHu bdesham[m] atgo[m] alicedebob[m] bobach[m] cbg[m] dxml[m] foxadee[m] capillary_cup[m] fiddeldibu[m] cosson[m] etjet[m] Cenion[m])
00:30:56 --- names: list (Noughtmare[m] Bimmie[m] bb010g alexshpilkin tet[m] potato44[m] sielicki whoops sylvie[m] marijuanafermion siraben roninkaizen[m] hgfedcba[m] vaibhavsagar spherinder[m] Rich[m] simbergm maigel[m] nkhodyunya[m] mmynsted[m] kadoban jibby[m] stan[m] Uma[m] macerbi[m] ejpcmac josiah_sama sepp2k kitsune[m]1 vkleen vk3wtf[m] rizary giuseppe[m] hdurer[m] kaychaks[m] lierdakil[m] humanwire[m] bee[m]1 alexfmpe[m] mujx[m] M0x8badf00d[m] atopuzov[m] domenkozar[m])
00:30:56 --- names: list (arsdragonfly[m] fgaz Ekho[m] aloiscochard[m] irdr arahael1 srnty zaquest fryguybo1 yaroot2 xorander khisanth_ seizo polman YongJoon StoneToad DrAwesomeClaws gspia dibblego Jesin ericsagnes alx741 d34df00d saml cybj Unhammer anishathalye lnostdal rembo10 tabaqui sdrodge ziman megaTherion Putonlalla leah2 Kaivo moldybits srid63908 lpvb jchia_1 hololeap _ashbreeze_ Cale Remy^ MonkeyNOS m1dnight_ seanparsons Fairy tjbp sea-gull_ mnrmnaugh powerbit)
00:30:56 --- names: list (revprez_atlanta Fubar^ rainmanjam recurse thunderrd miklcct albel727 tomku newhoggy dedgrant Guest8430 eruditass datajerk kyagrd__ dani- ocharles Wizek milessabin meck sebhoss peschkaj monad_cat ghuntley graingert Kamuela m-renaud glowcoil rslima_ J_Arcane metalrain typetetris Lowl3v3l Vq moony t7 stilgart Folkol revprez_anzio Mike2_ PLPD-Bot swater nckx mjuad Guillaum seveg gehmehgeh immae Natch yitz cyphase phadej ion xpoqp oldnborg cow-orker totte)
00:30:56 --- names: list (jonatan pigsalsa ahihi rom1504 hvr pong Stanley00 xplat phaul Chobbes chirpsalot survove bydo atk phreedom korzq atraii tnks oo_miguel_win SCHAPiE delYsid`` shutdown_-h_now Tuplanolla armyriad unyu defanor lstdgtfp dolio erikd jle` mimi_vx a3Dman nek0 nopf theorbtwo dsal theophil893 wrunt max1 jsatk roman1 noam__ eof verlet64 haasn PlasmaStar Novitsh bandali urdh elvishjerricco aesi Offaiah_ azahi OnkelTem _janne revprez_ody ibloom dustinm Majiir spion ido)
00:30:56 --- names: list (wildlander klntsky niklasl lawid bartavelle jeff___ Cthalupa Xal MindlessDrone mjrosenb SquidDev Madars Rudd0 kubrat cppxor2arr duckonomy valdyn telser Maxdamantus oleks hsyl20 perrier-jouet amiri leothrix nh2 isacl___ spinda dgpratt alexelcu runeks teehemkay adamse mmaruseacph2 cbarrett lightandlight simony sariyar rotaerk fcse__ sppky kip hsiktas lockshaw_ billstclair ixian abuss rodlogic feepo mankyKitty duncan^ celphi georgew caasih ajmcmiddlin dongcarl)
00:30:56 --- names: list (gonz_ iphy pent EduardoBautista coot alunduil PotatoGim tehidiot bs338 NemesisD jetpack_joe JSharp nickoralias pasukon Jon coeus_ cpup dysfigured clever bsima dminuoso jbetz Axman6 shadowdao bollu cross nonzen drbean veverak quaestor hackage vk3wtf markus1189 @glguy hive-mind Sparadox n-st corvidzz petermw milli Zoddo steve nikivi pie__ Mo0O energizer_ Sose Bergle_2 AkhILman Netwolf yushyin acro dmwit hpc M2tias i7c le_jonge mickdekkers__ __4matter_)
00:30:56 --- names: list (stylewarning runde parseval edmundnoble mudri carter thi cyjiao__ unsymbol scav johs drewr micro Dabo mou stux|RC-- hc Zialus cpape jzl tessier eikke so Ke bdw niko monokrome michaelpj esph tobiasBora iomonad lemald tv andjjj23 myme lyxia kqr freusque apoc APic Ranhir suzu cgfbee restrictedchoice Amadiro daGrevis jdevlieghere Cathy _guios evilmonads_ kiprasz infinity0_ Jello_Raptor gothos thaumavorio_ Adeon raek_ lantti jrm sud0 Ekho hongminhee exarkun)
00:30:56 --- names: list (orzo_ ayako opqdonut tmciver henrik__ anry_ tumdedum apeyroux_ jlamothe statusfailed petercommand xintron1 nilOps_ marble_visions_ tA_ Tristan- madnight ManiacTwister diginet spoonm forell_ Shockk phlym_ mikeplus64 verement srk Adluc chin-tastic bcoppens kAworu edwardk lpsmith m4lvin infinisil seliopou winny sis7 bod_ cheater jrslepak obiwahn PragCypher Wamanuz2 RusAlex jkachmar dcoutts_ bitonic rann underikar mitchellsalad_ affinespaces alextes moobar)
00:30:56 --- names: list (koankeeper Profpatsch yumh darxun nahra TMA drdo noCheese oberstein scinawa devopsdeluxe dashkal avn avn_ bgamari nyuszika7h dogui usern4m3 NightA lassulus swalladge RoguePointer keep_learning devurandom yrid bwe asjo Niamkik a3f bolverkr Dykam wagle nitrix mp___664 aveltras ab9rf andyo teej tinwood crtschin dan64 FliiFe Igloo otulp xstill matheus trebuh tms_ grumble jackhill sujeet S007 uwap cocreature johnw parenthetical Klumben codedmart arkeet AJTJ)
00:30:56 --- names: list (stiell noctux nurupo lambdabot bjobjo feuerbach uptime Velpoman Geekingfrog Phyx- Frans-Willem haveo Tourist @Sigyn mikolaj_ Miroboru cjwelborn sukbeom9 linduxed mupf cheers stass dmj` kini dukedave rdivyanshu absence d0liver Tritlo iravid Moyst Taneb greymalkin arianvp kungp cods runawayfive cchalmers charukiewicz wrengr_away mccoyc aweinstock echoreply MasseR shreyasminocha Bish wayne_ CindyLinz michaelsdunn1_ dontdieych thallada Tene bobby gaze___ aldum)
00:30:56 --- names: list (vimto Peppep violeta vxe Hijiri MarcelineVQ cloudhead dredozubov rotty1 linoge terrorjack_ thoughtpolice remexre bertschneider_ comboy_ dstolfa_ Deadhand pdgwien cyris212 yorick noko_ jwynn6 noexcept c-rog kaol chindy diskie Tspoon__ nekomune simon Zemyla jtcs_ bspar `slikts mort lukelau fr33domlover sdx23 raoul interruptinuse epta michalrus zfnmxt gsingh93 soncodi pwestling xorpse Athas aramiscd ft icrainbow xacktm sigmundv_ tdammers Twey kav Nik05 _ikke_)
00:30:56 --- names: list (bind hegge drewbarbs Ckat l8star PierreM_ iltiades1 wreckingwalla_ amuck spamlessj Firedancer devalot GGMethos TheSpectre mingc obfusk catern nano- Rembane verite- ecx86 Peter_Storm_ bananagram jmsx ullbeking abbe intelux hexo Hotbees benl23 flogfr Enigmagic hodapp higherorder joeyh PoliticsII geronimogarcia silverneedle flux pierrot Blkt nemesit|znc ProofTechnique SrPx Konehalt1 heyj AndreasK ranberry__ ryzokuken acowley Neuromancer casdr mrd [exa] Nevoic)
00:30:56 --- names: list (mikolaj typedrat Philonous int-e scal PHO connrs_ pdxleif Jonno_FTW WarzoneCommand Randy ByronJohnson ljhms Nascha TimWolla dionyziz amx sphalerite DustyDingo lkurusa dpn` xtsee SegFaultAX glowpelt jophish systemfault ebutleriv bradparker zabracks cemerick fingerzam nbouscal banjiewen Jabbslad scivola Eliel lc_ raoulb srhb gluegadget alexknvl amatecha polux7 wtw alanz irclogger_com andromeda-galaxy jix chivay saurik_ ent Logio cgoldamm1r davl vodkaInf1rno)
00:30:56 --- names: list (loc _ag_ ammar2 edwtjo Wojciech_K blackdog rzmt aib Nikotiini earthy bitemyap1 saidinwot seventh__ bjs Akii CelestialLake mtjmullen t36s gambpang dumptruckman hexagoxel rootnode_ deni Ring0` connrs- sebastianrkg NextHendrix ynyounuo geekosaur AfC shrifbot PtxDK beka vanyaklimenko tsahyt Ulrar ski vqrs lortabac tristanC tstat mpickering gargawel strangeglyph treehaqr jp reyu Unode deu ahri aidecoe tigerchops lachenmayer owlscientist pigs greeny__ qz Squarism)
00:30:56 --- names: list (ephemeron c_wraith shapr nvt dilinger Ornedan luite joel135 lexi-lambda platz Reisen burp ekleog rj1 Kiruwa joehillen tabaqui1 pacak quarters exferenceBot Guest40074 moocow flebron Mon_Ouie canta Arguggi beaky nshepperd_ lurkless fiQ2 bs zymurgy sms [df] shachaf twk- qzo_ Aleksejs coldpress carbolymer ycheng mulderr nibbling_ vin-ivar habbah agrif exio4 h30 rkrishnan dequbed puffnfresh adarqui betawaffle akermu fiddlerwoaroof sivs atomi niklasb_ dqd _flow_)
00:30:56 --- names: list (Deewiant lieven paraseba debugloop tchakka kosmikus adius fredcy_ jonrh barrucadu SlashLife rodgzilla _ceb koala_man jokester e rootmos_ sm LeaChim eldritch geal luigy sarahzrf dh jorj Willis ego Liskni_si integral Chousuke Firedancer_ nisstyre maerwald Jacoby6000 aplainzetakind EvanR implementation_ crooked d3lxa w1gz comstar Flonk adarshaj ubercow eagleflo Xandaros wz1000 duairc gilbertw1 cesardv HalfEatenPie fiatjaf pharaun lispy steell zenzike dexterfoo)
00:30:56 --- names: list (makergrl ventonegro SolarAquarion Annihitek Franciman sssilver dyl ldlework lowryder ftop Kneiva avp RecursiveG tureba PyroLagus lavalike _6a68 ambrosia d6e asm89 anderson djanatyn mstruebing Jaxan xnyhps raid Someguy123 solarus jinblack ezyang jdanforth markhuge idupree DwarfMaster mrus davean rinfiyks iron_houzi brisbin lugh ryjm[payon] wraithm riatre abra0 kloeri cjay- liff Forkk tolt stefan-_ sbrg joeytwiddle ruffy_ adamCS cyberlard Clint furnost klugez)
00:30:56 --- names: list (@ChanServ jvanbure michalisko)
00:52:29 <c4droid> Hi, I'm a newbie for haskell, I'm trying configure haskell platform at my windows PC, I don't know how to configure it with vscode, anybody can help me?
00:53:11 <jgt> c4droid: did you try using stack?
00:54:20 <c4droid> I'm tried, but let me confused the environment variable...
00:55:45 <jgt> I don't know what that means :-/
00:56:06 <jgt> maybe you should ask in #haskell-beginners
00:56:15 <c4droid> Ok.
01:13:20 * hackage pencil 1.0.0 - Static site generator  https://hackage.haskell.org/package/pencil-1.0.0 (elben)
01:23:51 * hackage servant-swagger 1.1.7.1 - Generate a Swagger/OpenAPI/OAS 2.0 specification for your servant API.  https://hackage.haskell.org/package/servant-swagger-1.1.7.1 (phadej)
01:32:51 <gentauro> https://blogs.ncl.ac.uk/andreymokhov/you-should-try-hadrian/
01:33:22 <gentauro> anybody can explain (shortly) `hadrian` vs `stack`? 
01:33:26 <gentauro> why do I need it?
01:33:42 <gentauro> (I mean, stack works just as what I'm expecting for a build system)
01:43:28 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
01:43:28 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
01:43:28 --- names: list (clog cur8or mreh ricekrispie dTal zincy ruskey qwebirc93236 jose_zap geronimogarcia xff0x bblfish glguy olligobber kwantam cynick __bo Aquazi revprez_atlanta revprez_anzio zariuq oish vijaytadikamalla esp32_prog jusss chaosmasttter ggole darjeeling_ poljar1 rfold acidjnk koz_ mulk bahamas Sk01 lprd_ monochrom reactormonk thc202 jgt nshepperd veox1 jeltsch nfd9001 danso unlink2 revtintin slomo gmips[m] fweht rruizt f-a raatiniemi osa1 honungsburk vlatkoB)
01:43:28 --- names: list (jneira boj Anthaas xelxebar niHiggim harfangk forgottenone pankajgodbole tomboy64 nowhere_man alyptik mikecheck tabemann Clough cjenn toppler`` [Leary] otto_s wei2912 lagothrix nesqi taiite shah^ theDon teardown jchia jb55 justanotheruser hamishmack tromp polmaan cybai hiredman dfordivam eiGHttt troydm keep_learning_M aarvar ziyourenxiang plutoniix sudden oats Foritus notzmv byorgey acarrico averell Lord_of_Life filedesless hiptobecubic_ pfurla eschnett)
01:43:28 --- names: list (kipras sz0 Xeyame TommyC s00pcan subfacto1 sqrt2 noan abrar oni-on-ion royal_screwup21 MatrixBot3 vjacob gxt andreas303 ClaudiusMaximus wnbehsklr zxrf gienah RedNifre wonko7 JimmyRcom teaknow[m] fionnan DigitalKiwi zzz alp nighty revprez Sgeo_ gentauro caa51h mnrmnaughmnrgle golergka nullifidian nicoulaj Frobozz catsup ashirase eeva zmt01 texasmynsted mceier enragedjam piyush-k` yahb mniip giraffe dmiles mkoenig_ Cloud[m] nyaomi DTZUZU2 WeiTang[m])
01:43:28 --- names: list (ShujaRafi[m] thecodedmessage wengrow[m] soaoaig[m] avocado runningriot9[m] rainbyte[m] ovigren[m] nirvin[m] MichalLaskus[m] iarp[m] vladimirp1[m] GNULizard[m] cr0gs Warder[m] vars[m] actartis[m] thejonny[m] haiderkhan[m] reedhhw[m] hkimhvyh[m] Obscurity[m] jennie[m] kahuna[m] fregex JakeO[m] illandan[m] int-index AkikoHimenokoji[ cjskaggs[m] deklund[m] eckt[m] hackeryarn[m] petrichor ad5twoknebor[m] mithrandi[m] pineapple[m] buggeas40d[m] cepxuo roberth)
01:43:28 --- names: list (MerlinGttlinger[ m1andrew[m] hans[m]4 limabeans[m] supersweetsweetc jhg_0[m] hjoest[m] godva[m] jerrytgarcia[m] jenkee[m] joenase[m] luciandesozay[m] tmallard[m] cawal[m] risorg[m] aitzol[m] dag[m] ciet[m] tswett[m] shanesveller[m] Videled[m] Mesa[m]1 Syllo[m] buster528[m] unevens[m] tinwood[m] Adam[m]7 kai10[m] zocijux[m] bt[m] javjarfer[m] hsw[m] Mougan[m] GhostofaConsole[ dlilja[m] exarkun1 NickHu bdesham[m] atgo[m] alicedebob[m] bobach[m] cbg[m])
01:43:28 --- names: list (dxml[m] foxadee[m] capillary_cup[m] fiddeldibu[m] cosson[m] etjet[m] Cenion[m] Noughtmare[m] Bimmie[m] bb010g alexshpilkin tet[m] potato44[m] sielicki whoops sylvie[m] marijuanafermion siraben roninkaizen[m] hgfedcba[m] vaibhavsagar spherinder[m] Rich[m] simbergm maigel[m] nkhodyunya[m] mmynsted[m] kadoban jibby[m] stan[m] Uma[m] macerbi[m] ejpcmac josiah_sama sepp2k kitsune[m]1 vkleen vk3wtf[m] rizary giuseppe[m] hdurer[m] kaychaks[m] lierdakil[m])
01:43:28 --- names: list (humanwire[m] bee[m]1 alexfmpe[m] mujx[m] M0x8badf00d[m] atopuzov[m] domenkozar[m] arsdragonfly[m] fgaz Ekho[m] aloiscochard[m] irdr arahael1 srnty zaquest fryguybo1 yaroot2 xorander khisanth_ seizo polman YongJoon StoneToad DrAwesomeClaws gspia dibblego Jesin ericsagnes alx741 d34df00d saml cybj Unhammer anishathalye lnostdal rembo10 tabaqui sdrodge ziman megaTherion Putonlalla leah2 Kaivo moldybits srid63908 lpvb jchia_1 hololeap _ashbreeze_ Cale Remy^)
01:43:28 --- names: list (MonkeyNOS m1dnight_ seanparsons Fairy tjbp sea-gull_ mnrmnaugh powerbit Fubar^ rainmanjam recurse thunderrd miklcct tomku newhoggy dedgrant Guest8430 eruditass datajerk kyagrd__ dani- ocharles Wizek milessabin meck sebhoss peschkaj monad_cat ghuntley graingert Kamuela m-renaud glowcoil rslima_ J_Arcane metalrain typetetris Lowl3v3l Vq moony t7 stilgart Folkol Mike2_ PLPD-Bot swater nckx mjuad Guillaum seveg gehmehgeh immae Natch yitz cyphase phadej ion)
01:43:28 --- names: list (xpoqp oldnborg cow-orker totte jonatan pigsalsa ahihi rom1504 hvr pong Stanley00 xplat phaul Chobbes chirpsalot survove bydo atk phreedom korzq atraii tnks oo_miguel_win SCHAPiE delYsid`` shutdown_-h_now armyriad unyu defanor lstdgtfp dolio erikd jle` mimi_vx a3Dman nek0 nopf theorbtwo dsal theophil893 wrunt max1 jsatk roman1 noam__ eof verlet64 haasn PlasmaStar Novitsh bandali urdh elvishjerricco aesi Offaiah_ azahi OnkelTem _janne revprez_ody ibloom)
01:43:28 --- names: list (dustinm Majiir spion ido wildlander klntsky niklasl lawid bartavelle jeff___ Cthalupa Xal MindlessDrone mjrosenb SquidDev Madars Rudd0 cppxor2arr kubrat duckonomy valdyn telser Maxdamantus oleks hsyl20 perrier-jouet amiri leothrix nh2 isacl___ spinda dgpratt alexelcu runeks teehemkay adamse mmaruseacph2 cbarrett lightandlight simony sariyar rotaerk fcse__ sppky kip hsiktas lockshaw_ billstclair ixian abuss rodlogic feepo mankyKitty duncan^ celphi georgew)
01:43:28 --- names: list (caasih ajmcmiddlin dongcarl gonz_ iphy pent EduardoBautista coot alunduil PotatoGim tehidiot bs338 NemesisD jetpack_joe JSharp nickoralias pasukon Jon coeus_ cpup dysfigured clever bsima dminuoso jbetz Axman6 shadowdao bollu cross nonzen drbean veverak quaestor hackage vk3wtf markus1189 hive-mind Sparadox n-st corvidzz petermw milli Zoddo steve nikivi pie__ Mo0O energizer_ Sose Bergle_2 AkhILman Netwolf yushyin acro dmwit hpc M2tias i7c le_jonge)
01:43:28 --- names: list (mickdekkers__ __4matter_ stylewarning runde parseval edmundnoble mudri carter thi cyjiao__ unsymbol scav johs drewr micro Dabo mou stux|RC-- hc Zialus cpape jzl tessier eikke so Ke bdw niko monokrome michaelpj esph tobiasBora iomonad lemald tv andjjj23 myme lyxia kqr freusque apoc APic Ranhir suzu cgfbee restrictedchoice Amadiro daGrevis jdevlieghere Cathy _guios evilmonads_ kiprasz infinity0_ Jello_Raptor gothos thaumavorio_ Adeon raek_ lantti jrm sud0)
01:43:28 --- names: list (Ekho hongminhee exarkun orzo_ ayako opqdonut tmciver henrik__ anry_ tumdedum apeyroux_ jlamothe statusfailed petercommand xintron1 nilOps_ marble_visions_ tA_ Tristan- madnight ManiacTwister diginet spoonm forell_ Shockk phlym_ mikeplus64 verement srk Adluc chin-tastic bcoppens kAworu edwardk lpsmith m4lvin infinisil seliopou winny sis7 bod_ cheater jrslepak obiwahn PragCypher Wamanuz2 RusAlex jkachmar dcoutts_ bitonic rann underikar mitchellsalad_)
01:43:28 --- names: list (affinespaces alextes moobar koankeeper Profpatsch yumh darxun nahra TMA drdo noCheese oberstein scinawa devopsdeluxe dashkal avn avn_ bgamari nyuszika7h dogui usern4m3 NightA lassulus swalladge RoguePointer keep_learning devurandom yrid bwe asjo Niamkik a3f bolverkr Dykam wagle nitrix mp___664 aveltras ab9rf andyo teej tinwood crtschin dan64 FliiFe Igloo otulp xstill matheus trebuh tms_ grumble jackhill sujeet S007 uwap cocreature johnw parenthetical)
01:43:28 --- names: list (Klumben codedmart arkeet AJTJ stiell noctux nurupo lambdabot bjobjo feuerbach uptime Velpoman Geekingfrog Phyx- Frans-Willem haveo Tourist @Sigyn mikolaj_ Miroboru cjwelborn sukbeom9 linduxed mupf cheers stass dmj` kini dukedave rdivyanshu absence d0liver Tritlo iravid Moyst Taneb greymalkin arianvp kungp cods runawayfive cchalmers charukiewicz wrengr_away mccoyc aweinstock echoreply MasseR shreyasminocha Bish wayne_ CindyLinz michaelsdunn1_ dontdieych)
01:43:28 --- names: list (thallada Tene bobby gaze___ aldum vimto Peppep violeta vxe Hijiri MarcelineVQ cloudhead dredozubov rotty1 linoge terrorjack_ thoughtpolice remexre bertschneider_ comboy_ dstolfa_ Deadhand pdgwien cyris212 yorick noko_ jwynn6 noexcept c-rog kaol chindy diskie Tspoon__ nekomune simon Zemyla jtcs_ bspar `slikts mort lukelau fr33domlover sdx23 raoul interruptinuse epta michalrus zfnmxt gsingh93 soncodi pwestling xorpse Athas aramiscd ft icrainbow xacktm)
01:43:28 --- names: list (sigmundv_ tdammers Twey kav Nik05 _ikke_ bind hegge drewbarbs Ckat l8star PierreM_ iltiades1 wreckingwalla_ amuck spamlessj Firedancer devalot GGMethos TheSpectre mingc obfusk catern nano- Rembane verite- ecx86 Peter_Storm_ bananagram jmsx ullbeking abbe intelux hexo Hotbees benl23 flogfr Enigmagic hodapp higherorder joeyh PoliticsII silverneedle flux pierrot Blkt nemesit|znc ProofTechnique SrPx Konehalt1 heyj AndreasK ranberry__ ryzokuken acowley)
01:43:28 --- names: list (Neuromancer casdr mrd [exa] Nevoic mikolaj typedrat Philonous int-e scal PHO connrs_ pdxleif Jonno_FTW WarzoneCommand Randy ByronJohnson ljhms Nascha TimWolla dionyziz amx sphalerite DustyDingo lkurusa dpn` xtsee SegFaultAX glowpelt jophish systemfault ebutleriv bradparker zabracks cemerick fingerzam nbouscal banjiewen Jabbslad scivola Eliel lc_ raoulb srhb gluegadget alexknvl amatecha polux7 wtw alanz irclogger_com andromeda-galaxy jix chivay saurik_ ent)
01:43:28 --- names: list (Logio cgoldamm1r davl vodkaInf1rno loc _ag_ ammar2 edwtjo Wojciech_K blackdog rzmt aib Nikotiini earthy bitemyap1 saidinwot seventh__ bjs Akii CelestialLake mtjmullen t36s gambpang dumptruckman hexagoxel rootnode_ deni Ring0` connrs- sebastianrkg NextHendrix ynyounuo geekosaur AfC shrifbot PtxDK beka vanyaklimenko tsahyt Ulrar ski vqrs lortabac tristanC tstat mpickering gargawel strangeglyph treehaqr jp reyu Unode deu ahri aidecoe tigerchops lachenmayer)
01:43:28 --- names: list (owlscientist pigs greeny__ qz Squarism ephemeron c_wraith shapr nvt dilinger Ornedan luite joel135 lexi-lambda platz Reisen burp ekleog rj1 Kiruwa joehillen tabaqui1 pacak quarters exferenceBot Guest40074 moocow flebron Mon_Ouie canta Arguggi beaky nshepperd_ lurkless fiQ2 bs zymurgy sms [df] shachaf twk- qzo_ Aleksejs coldpress carbolymer ycheng mulderr nibbling_ vin-ivar habbah agrif exio4 h30 rkrishnan dequbed puffnfresh adarqui betawaffle akermu)
01:43:28 --- names: list (fiddlerwoaroof sivs atomi niklasb_ dqd _flow_ Deewiant lieven paraseba debugloop tchakka kosmikus adius fredcy_ jonrh barrucadu SlashLife rodgzilla _ceb koala_man jokester e rootmos_ sm LeaChim eldritch geal luigy sarahzrf dh jorj Willis ego Liskni_si integral Chousuke Firedancer_ nisstyre maerwald Jacoby6000 aplainzetakind EvanR implementation_ crooked d3lxa w1gz comstar Flonk adarshaj ubercow eagleflo Xandaros wz1000 duairc gilbertw1 cesardv HalfEatenPie)
01:43:28 --- names: list (fiatjaf pharaun lispy steell zenzike dexterfoo makergrl ventonegro SolarAquarion Annihitek Franciman sssilver dyl ldlework lowryder ftop Kneiva avp RecursiveG tureba PyroLagus lavalike _6a68 ambrosia d6e asm89 anderson djanatyn mstruebing Jaxan xnyhps raid Someguy123 solarus jinblack ezyang jdanforth markhuge idupree DwarfMaster mrus davean jvanbure michalisko @ChanServ klugez furnost Clint cyberlard adamCS ruffy_ joeytwiddle sbrg stefan-_ tolt Forkk liff)
01:43:28 --- names: list (cjay- kloeri abra0 riatre wraithm ryjm[payon] lugh brisbin iron_houzi rinfiyks)
01:43:32 <alp> gentauro, Hadrian is GHC's new build system, it's not a "competitor" to stack/cabal-install/etc
01:43:47 <alp> so unless you want to contribute to GHC, you don't need it =)
01:53:28 <gentauro> alp: thx for that :)
01:54:20 <alp> if you do want to contribute to GHC, do feel free to hop in #ghc and ask Hadrian questions, I'd be happy to help =)
01:56:02 <maerwald> because there are not enough build systems
01:56:34 <gentauro> alp: I don't know if I'm good enough to contribute to GHC ;) (maybe someday)
01:58:20 <maerwald> I feel those things make it just harder for contributors and are an optimisation for the seasoned developers
01:59:48 <alp> there's no such thing. sure, the typechecker or code generators bits are not trivial to touch, but there are many many other things to be done in GHC, including newcomer friendly ones: https://gitlab.haskell.org/ghc/ghc/issues?label_name%5B%5D=newcomer :)
02:01:30 <alp> maerwald, in this precise case it's about replacing a Make-based build system, which is very very hard to maintain and evolve at that scale. GHC's various components aren't yet buildable by Cabal-the-library alone (therefore, not buildable by cabal-install/stack), hence hadrian.
02:17:13 <arahael1> Today I was using haskell stack on macos, and I couldn't figure out why it wasn't working.  Weird messages and linking errors.  turned out it was because I added a file to the Lib directory (of a basic stack project)...  And that file had the wrong case.
02:17:26 <arahael1> I had a foobar.hs instead of Foobar.hs (the module was Foobar)
02:18:30 <arahael1> Fixed it but I had to rename it half a dozen times and restart my text editors. :)
02:30:53 <zincy> What makes more sense for a type modeling two cards held by a player in a card game - Maybe (Card,Card) or a Maybe (FixedLenVec 2 Card)
02:31:06 <zincy> Where fixedLenVec is a sized vector
02:32:12 <f-a> zincy: why would you need FixedLenVec?
02:32:13 <zincy> The only kinds of operations what will be used are get and set essentially they don't need to be modified in any way
02:32:33 <zincy> f-a: There can only ever be two cards held by a player or none
02:33:10 <zincy> Hmm maybe newtype PocketCards = PocketCards Card Card
02:33:15 <zincy> just makes more sense
02:33:28 <f-a> can't newtype on more than one field
02:33:41 <zincy> oh yea
02:33:56 <f-a> but on that single maybe you can
02:42:10 <zincy> Is it a good idea to use two elements of a list as arguments to a data constructor?
02:42:50 <f-a> you mean a two-list-element, right?
02:43:09 <zincy> yeah I am trying to construct PockerCards from a two element list
02:43:20 <zincy> applicative?
02:44:05 <zincy> That is what I was confused about data constructors are just regular functions and regular functions have instances for functor and applicative.
02:44:07 <zincy> silly me
02:44:47 <f-a> generally it's not the constructor, but the data itsel
02:45:04 <f-a> (++) <$> getLine <*> getLine -- e.g.
02:45:32 <f-a> *the Type itself
02:46:03 <zincy> So would PocketCards need an instance declaration of those typeclasses?
02:46:42 <f-a> if you want to, yes. If it is a newtype, you can derive those with an extension
02:47:10 <zincy> thanks
02:47:14 <f-a> in general zincy , I don't see a pressing matter not to have `Maybe (Card, Card)` 
02:47:44 <zincy> yeah
02:47:58 <zincy> the other question is if pocket cards may or may not be held
02:48:13 <zincy> is it that or is the Maybe wrapping the PocketCards
02:48:50 <zincy> I guess the tuple is better since it already has the instances needed
02:51:45 <zincy> forgot that last statement it doesnt make sense
02:51:57 <zincy> thanks f-a. I have settled on your solution
02:52:07 <f-a> happy coding!
02:52:12 <zincy> :)
02:52:25 <zincy> f-a: are you otherwise known as goldfire?
02:52:37 <f-a> nope
02:52:45 <zincy> ah ok
02:54:51 * hackage servant-swagger-ui-core 0.3.3 - Servant swagger ui core components  https://hackage.haskell.org/package/servant-swagger-ui-core-0.3.3 (phadej)
02:55:50 * hackage servant-swagger-ui 0.3.3.3.22.2 - Servant swagger ui  https://hackage.haskell.org/package/servant-swagger-ui-0.3.3.3.22.2 (phadej)
02:56:51 * hackage servant-swagger-ui-jensoleg 0.3.3, servant-swagger-ui-redoc 0.3.3.1.22.2 (phadej): https://qbin.io/judges-sc-tyt8
02:56:57 <zincy> f-a: In order to have a functor I need something like newtype PocketCards a = PocketCards (a,a)
02:57:14 <zincy> which feels a bit weird since a *should* only ever be Card
03:00:30 <DJ__> ???
03:03:21 <zincy> DJ__: Is that for me?
03:05:16 <zincy> Feel free to not restrict yourself to punctuation marks
03:06:51 * hackage servant 0.16.1 - A family of combinators for defining webservices APIs  https://hackage.haskell.org/package/servant-0.16.1 (phadej)
03:07:50 * hackage servant-server 0.16.1 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-server-0.16.1 (phadej)
03:19:38 <Phyx-> 09:57:58 < maerwald> I feel those things make it just harder for contributors and are an optimisation for the seasoned developers <---- shhhhh not so loud :)
03:20:09 <Phyx-> maerwald: though I'd disagree with you on your last point though. 
03:25:14 <hololeap> lortabac: 
03:25:25 <hololeap> oops, sorry
03:34:20 * hackage lentil 1.3.0.0 - frugal issue tracker  https://hackage.haskell.org/package/lentil-1.3.0.0 (fffaaa)
04:07:53 <tromp> > 1+2
04:07:56 <lambdabot>  3
04:08:15 <tromp> > let (a,b) = (418570661488118,-341761513981705) in a*sqrt(2)+b*sqrt(3)
04:08:17 <lambdabot>  0.0
04:08:23 <tromp> > let (a,b) = (418570661488118,-341761513981705) in a*sqrt(2)+b*sqrt(3) :: CReal
04:08:25 <lambdabot>  -0.0747605093359020406251581598418512614546
04:09:21 <tromp> >let f (a,b,x,c,d,y) = if x< y then (a,b,x,c-a,d-b,y-x) else (a-c,b-d,x-y,c,d,y)
04:11:10 <tromp> > let l = iterate f (1,0,sqrt(2),0,1,sqrt(3)) :: [(Integer,Integer,CReal,Integer,Integer,CReal)]
04:11:13 <lambdabot>  <no location info>: error:
04:11:13 <lambdabot>      not an expression: ‘let l = iterate f (1,0,sqrt(2),0,1,sqrt(3)) :: [(Int...
04:12:27 <tromp> > let f (a,b,x,c,d,y) = if x< y then (a,b,x,c-a,d-b,y-x) else (a-c,b-d,x-y,c,d,y)
04:12:29 <lambdabot>  <no location info>: error:
04:12:30 <lambdabot>      not an expression: ‘let f (a,b,x,c,d,y) = if x< y then (a,b,x,c-a,d-b,y-...
04:14:13 <Solonarv> tromp: lambdabot is not an interface to a GHCI prompt, you can only enter expressions
04:14:24 <Solonarv> let var = <expr> is not an expression
04:14:55 <tromp> i thought there was a syntax for adding definitions
04:15:17 <Solonarv> yes, but it's a separate command, not >
04:15:18 <Solonarv> @let f (a,b,x,c,d,y) = if x< y then (a,b,x,c-a,d-b,y-x) else (a-c,b-d,x-y,c,d,y)
04:15:20 <lambdabot>  .L.hs:242:1: warning: [-Woverlapping-patterns]
04:15:20 <lambdabot>      Pattern match is redundant
04:15:20 <lambdabot>      In an equation for ‘f’: f (a, b, x, c, d, y) = ...
04:15:26 <tromp> ah yes, that was it
04:15:44 <tromp> @let f (a,b,x,c,d,y) = if x< y then (a,b,x,c-a,d-b,y-x) else (a-c,b-d,x-y,c,d,y)
04:15:46 <lambdabot>  .L.hs:242:1: warning: [-Woverlapping-patterns]
04:15:46 <lambdabot>      Pattern match is redundant
04:15:46 <lambdabot>      In an equation for ‘f’: f (a, b, x, c, d, y) = ...
04:15:47 <Solonarv> (but also f is already bound in lambdabot, so you should choose a different name)
04:15:55 <Solonarv> @let foo (a,b,x,c,d,y) = if x< y then (a,b,x,c-a,d-b,y-x) else (a-c,b-d,x-y,c,d,y)
04:15:57 <lambdabot>  Defined.
04:16:32 <tromp> @let l = iterate f (1,0,sqrt(2),0,1,sqrt(3)) :: [(Integer,Integer,CReal,Integer,Integer,CReal)]
04:16:34 <lambdabot>  .L.hs:239:13: error:
04:16:34 <lambdabot>      Ambiguous occurrence ‘f’
04:16:34 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.f’,
04:17:01 <tromp> @let loo = iterate foo (1,0,sqrt(2),0,1,sqrt(3)) :: [(Integer,Integer,CReal,Integer,Integer,CReal)]
04:17:04 <lambdabot>  Defined.
04:17:20 <Solonarv> note: the parentheses in sqrt(2) and sqrt(3) are redundant
04:17:20 <tromp> > loo !! 100
04:17:26 <lambdabot>  mueval-core: Time limit exceeded
04:17:49 <tromp> right you are:)
04:17:57 <tromp> > take 5 loo
04:17:59 <lambdabot>  [(1,0,1.4142135623730950488016887242096980785697,0,1,1.732050807568877293527...
04:18:10 <Solonarv> heh
04:18:13 <Solonarv> > loo !! 5
04:18:16 <lambdabot>  (5,-4,0.1428645815899660698986582550250009250771,-1,1,0.31783724519578224472...
04:18:17 <tromp> > loo !! 10
04:18:19 <lambdabot>  (38,-31,0.0465403355424157551133349332864836104206,-11,9,0.03210808201585010...
04:18:30 <Solonarv> what's this supposed to calculate, anyway?
04:18:45 <tromp> oh, working on IBM's Ponder This challenge
04:19:20 <tromp> want a linear combination of sqrt(2) and sqrt(3) that's tiny
04:19:48 <tromp> > loo !! 40
04:19:50 <Solonarv> with integer coefficients, I assume? otherwise it's trivial :P
04:19:54 <lambdabot>  mueval-core: Time limit exceeded
04:19:59 <tromp> yes, integers
04:20:15 <tromp> seems i need to work with fixed precision
04:20:39 <Solonarv> I'm not actually sure why it's timing out so early
04:20:49 <tromp> or get CReal working in my Haskell environment
04:30:04 <tromp> i may be a little too naive... i ran stack update followed by stack install fixedprec
04:30:26 <tromp> and then expected Data.Number.FixedPrec to be available in ghci
04:30:50 <tromp> but :m +Data.Number.FixedPrec says Could not find module ‘Data.Number.FixedPrec’
04:32:11 <tromp> ah, solved it
04:32:19 <tromp> i need to run stack repl instead
04:53:17 <tabaqui> oh, (!!) operator reduces head elements to NF?
04:53:29 <tabaqui> "> loo !! 40;  mueval-core: Time limit exceeded"
04:53:48 <tabaqui> @let a = [undefined, 1]
04:53:51 <lambdabot>  Defined.
04:53:55 <tabaqui> > a !! 1
04:53:57 <lambdabot>  error:
04:53:58 <lambdabot>      Ambiguous occurrence ‘a’
04:53:58 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.a’,
04:54:12 <tabaqui> > [undefined, 1] !! 1
04:54:14 <lambdabot>  1
04:54:29 <tabaqui> > [(undefined, 0), (1, 0)] !! 1
04:54:31 <lambdabot>  (1,0)
04:54:36 <tabaqui> weird
04:54:56 <tabaqui> oh, I see, nevermind :)
05:04:08 <makalu> how do I learn to use persistent-template's language? The haddock documentation only lists functions and yesod's book is incomplete. For example, there's a Primary keyword which is not documented in either one.
05:21:34 <tiger> Hi
05:21:45 <nek0> is anyone here familiar with the concept of functional reactive programming?
05:25:07 <Solonarv> nek0: a little bit, there are others here who know more
05:25:10 <Solonarv> just ask!
05:26:51 <nek0> I am considering rewriting my game engine using FRP, but I have starter problems, as I am new to FRP. I'm not quite sure how to pull it off.
05:27:37 <Solonarv> that's actually what I've been using FRP for as well
05:27:52 <Solonarv> which FRP library are you using?
05:28:09 <nek0> I am considering using reactive-banana
05:28:47 <Solonarv> ah, I don't know much about that - I've used reflex
05:29:50 <nek0> reflex was also in my scope, but it seems to be aimed more at web-applications.
05:30:47 <Solonarv> indeed it is
05:30:54 <Solonarv> (using reflex-dom)
05:31:05 <Solonarv> but there are other backends, for example reflex-sdl2
05:31:36 <ski> halogenandtoast : no problem
05:35:00 <nek0> ok. reflex-sdl2 is intriguing, but quite a lot to read...
05:45:05 <tabaqui> I'm using FRP to impelement some business logic
05:45:19 <tabaqui> not quite complex it is mostly First Order FRP actually
05:45:42 <tabaqui> but Yampa is pretty easy to use and powerfull enough
05:46:23 <tabaqui> iperez made other FRP libs too, like Dunai which provides monad transformer if iirc
05:46:36 <Solonarv> yeah, reflex-sdl2 is a bit heavy to get into at first
05:47:00 <tabaqui> anyway I highly recommend you to use arrowized FRP because it is very intuitive
05:47:23 <Solonarv> I think that's the first time I've heard anyone call arrows intuitive
05:47:59 <Solonarv> I found reflex's FRP model pretty easy to wrap my head around, most of my troubles were along the lines of "okay, how do I get it to actually *do things* 
05:48:51 <tabaqui> yeah, you have to work in gamedev already or read a lot of papers
05:49:29 <tabaqui> I dunno, "The Yampa Arcade" shows how to implement negative action loop
05:50:05 <tabaqui> I enjoyed when have read it at first time
05:50:27 <tabaqui> https://wiki.haskell.org/Yampa
05:50:35 <tabaqui> Here you can find images describing arrows
06:34:21 * hackage purescript 0.13.0 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.13.0 (hdgarrood)
06:49:02 <boeingx> Hi! For Peano number types, is there a way to write a function fromInt which takes an integer and returns the Peano number?
06:49:14 <boeingx> I've a code snippet here https://gist.github.com/BoeingX/32f73ef6fb00654da653f6c1e20ff166
06:50:39 <tsahyt> yes
06:50:43 <boeingx> toInt is fairly easy, but fromInt is kind of difficult, because Z and S n are different types
06:50:55 <tsahyt> but it'll be partial, due to negative numbers
06:51:20 <tsahyt> boeingx: you can implement such a thing with type classes I believe
06:52:33 <boeingx> tsahyt: really? Yes if such a function exists it would be partial
06:53:39 <boeingx> tsahyt: you mean by defining a type class and make Z and S n instances of it?
06:54:48 <tsahyt> you'd have a type class FromInt n, with a single member fromInt :: Natural n -> Int
06:55:13 <tsahyt> and an instance for Z and one for FromInt n => FromInt (S n)
06:55:19 <Axman6> this is the sort of thing the singletons package lets you do
06:55:32 <tsahyt> yes, doing it manually does become a bit painful at times
06:55:47 <tsahyt> though on the other hand I'm sometimes reluctant to pull in all of singletons for just a single use
06:56:01 <Axman6> fromInt :: (forall n. Natural n -> a) -> Integer -> a is basically the type you end up using
06:56:51 <Axman6> "As long as you ptovide me with a function which can handle _all_ Naturals, I can give you a natural corresponding to a given Integer" (roughly)
06:57:30 <boeingx> tsahyt: I see... that's what I tried at the very beginning but failed to make it typecheck, let me have a new try 
06:57:54 <boeingx> Axman6: so this is a rank-2 function?
06:58:07 <Axman6> I believe so
07:00:20 <Axman6> the implementation will look something like this I think: fromInt k int = go int NumZ where go 0 nat = k nat; go n nat = go (n-1) (NumS nat)
07:00:43 <boeingx> that's interesting! never wrote rank n type functions so far
07:00:58 <Axman6> (I'm not sure if that will type check without any signatures)
07:01:39 <Axman6> jle`'s posts on the singletons package are great for getting your head around how it all works
07:02:24 <boeingx> https://blog.jle.im/entry/introduction-to-singletons-1.html
07:02:29 <boeingx> that looks cool
07:03:00 <boeingx> Thank you Axman6, I'll have a look at it
07:06:47 <ski>   withNatural = flip fromInt
07:07:01 <ski> `withNatural' is using CPS
07:11:47 <tabaqui> withNatural :: (forall (n :: 'Int). Natural n -> a) -> Int -> a; withNatural f 0 = f NumZ; withNatural f n = withNatural (f . NumS) (n - 1)
07:11:49 <tabaqui> err
07:11:56 <tabaqui> withNatural :: (forall n. Natural n -> a) -> Int -> a; withNatural f 0 = f NumZ; withNatural f n = withNatural (f . NumS) (n - 1)
07:11:57 <tabaqui> here
07:12:30 <tabaqui> but a in (Natural a) can be any type, so you have no proper function f here
07:12:40 <tabaqui> you have to add some constraints
07:12:50 <tabaqui> I dunno, probably DataKinds can solve this
07:13:08 <tabaqui> like "data Natural (Int -> Int) where"
07:13:23 <tabaqui> forall (n :: Int). Natural n -> a
07:16:43 <ski>   withNatural :: Integer -> (forall n. Natural n -> o) -> o  -- was what i had in mind
07:17:12 <ski> you'd use it like `withNatural k \n -> ..n..'
07:17:57 <ski> yea, you possibly want some constraint as well (depending on how that `Natural' type is defined)
07:20:15 <boeingx> ski: How is `fromInt` defined in `withNatural = flip fromInt`?
07:22:59 <dmwit> fromInt = flip withNatural, naturally
07:23:37 <dmwit> (Seriously, though. They're implemented the same way, and ski was just observing that there's a common Haskell programming pattern lurking there if you squint in the right way.)
07:25:21 * hackage ptr 0.16.6.1 - Abstractions for operations on pointers  https://hackage.haskell.org/package/ptr-0.16.6.1 (NikitaVolkov)
07:26:26 <ski> boeingx : ask Axman6 ?
07:27:08 * ski attempts to squint in the wrong way
07:27:20 <boeingx> ski: ah sorry I wasn't aware that you are referencing that function
07:27:35 <ski> nw
07:28:37 <Axman6> yeah that order of arguments is probably more useful, I started with the continuation typo and went from there but in practice having the continuation last makes use easuer
07:28:41 <Axman6> easier*
07:29:27 <ski> i suppose if you want to compose many `withX's, having the other order could be more handy ?
07:31:21 <Axman6> tabaqui: boeingx provided a definition for Natural as a GADT where a is Z or S n, so it can't be any a, in case you missed the link
08:07:59 <boeingx> tsahyt: well with typeclass I finally got a typechecked version
08:08:01 <boeingx> class FromInt a where fromInt :: Int -> a
08:08:04 <boeingx> instance FromInt (Natural Z) where fromInt 0 = NumZ
08:08:07 <boeingx> instance (FromInt (Natural n)) => FromInt (Natural (S n)) where fromInt n = NumS (fromInt (n - 1))
08:09:16 <tsahyt> nice
08:09:29 <boeingx> But in practice this is not very useful, because I've to write explicitely the type of fromInt n, this is aweful for, say `fromInt 100`
08:11:31 <wuschel> Hey folks - 
08:12:32 <tabaqui> it will not work
08:13:11 <tabaqui> fromInt 0 has type `Natural n`, not `Natural Z`
08:13:58 <wuschel> I am currenty at p~800+ in the "Haskell from First Principles" book, and Monoids/Applicatives, etc are looking at me. I find Haskell quite a tough nut to master (Python experience only, with knowledge in LISP and a bit of C). Honestly, I can not say that I have a full understanding of the chapters, but I start to realize what kind of investment Haskell really is. (Bascially, a latin of the computer languages). 
08:14:42 <boeingx> tabaqui: actually, there is a overlap, if we annotate explictely the type like fromInt 0 :: Natural Z, it works
08:14:55 <dmj`> wuschel: that's good
08:15:08 <tabaqui> but how do we know the actual type?
08:15:22 <boeingx> it's kind of like Read typeclass
08:16:11 <tabaqui> how can we deal with user input?
08:16:16 <boeingx> tabaqui: that's the problem. my motivation of `fromInt` is to be able to construct n-th Peano number easily
08:16:33 <wuschel> I am looking for a strongly typed general purpose language (web development, calculations, models, data) with good libraries - but I am not sure whether Haskell is really worth it when it comes to practical libraries. Could someone give me reasons to switch to F#/Rust/Ocaml/(alternative)? It's not that I do not see the beauty in the language, I am just beginning to question the time to get up to speed with Haskell to attack real worl
08:16:41 <boeingx> but this implementation does little help on that :(
08:17:34 <wuschel> I see the worth in knowing about patterns on computation with algebra and types. It is just... hard. 
08:17:47 <wuschel> dmj' Thanks.
08:17:58 <wuschel> dmj` Thanks
08:19:10 <Ariakenom> wuschel: are you looking for an excuse to quit? :D
08:19:14 <dmj`> wuschel: the more you do it, the less heavy the types will feel. The brain is good at picking up on patterns, just got to keep practicing, doing many projects, keep it fun. Haskell is pretty good at keeping things fun.
08:19:55 <tabaqui> Fun does matter!
08:20:16 <dmj`> people rarely succeed unless they enjoy what they're doing
08:20:45 <tabaqui> it wasn't sarcasm :) actually, it is one of the reasons why I'm changing my job
08:21:27 <wuschel> Ariakenom: Kind of... XD... starting to question my sanity. Python is lovely with all its libraries and easy entry curve. but one needs to know how to structure code well and keep the discipline. Haskell on the other hand... it really tough, and I am not even sure I will be using it. 
08:23:12 <wuschel> dmj` I will try to do some small projects. Lets see. What is your daily usage in Haskell?
08:23:53 <wuschel> tabaqui What are you planning to work on with Haskell (type of problem)?
08:24:00 <tsahyt> boeingx: that's where existential quantification comes in. you'd have a data SomeNatural = SomeNatural (forall n. Natural n)
08:24:02 <dmj`> wuschel: just need to fall in love with the process of getting better, and seeing yourself improve will keep you motivated to go farther. It's like climbing a mountain, the higher you go, the more you can see, but the climb isn't always easy.
08:24:05 <Ariakenom> tabaqui: Definitely. What are you changing between, if I may ask?
08:24:09 <tsahyt> boeingx: but of course this all becomes rather cumbersome
08:24:24 <tsahyt> boeingx: you can have a look at GHC.TypeLits for what this looks like
08:24:30 <tsahyt> although that doesn't use Peano numbers
08:24:52 <dmj`> wuschel: use haskell daily for all kinds of things
08:24:54 <tabaqui> Ariakenom: I am the only haskell developer in the small team, and after three years of work they asked me to rewrite my code on Go/Python
08:25:25 <tabaqui> wuschel: heavy business logic based on FRP and a lot of network things as a client cross-platform utility
08:25:34 <Solonarv> tsahyt: that's not an existential at all
08:25:54 <Solonarv> the existential is written like so: data SomeNatural = forall n. SomeNatural (Natural n)
08:25:54 <tsahyt> did I misplace the forall?
08:25:56 <tsahyt> yes I did
08:26:04 <wuschel> dmj` I agree with the attitude. But then there is opportunity cost. So I have to choose the cliff well :) Would F#/Ocaml/Rust be a good stepping stone for Haskell?
08:26:22 <tsahyt> Solonarv: for some reason I can never remember that, I usually just try both until one compiles
08:27:16 <wuschel> Rust seems to be very noisy for my eyes, F# is a MS platform, and Ocaml seems to be a bit deserted.
08:27:24 <wuschel> tsahyt Thanks. 
08:27:31 <__monty__> wuschel: Yes, but the step from those to haskell would be mostly lateral. Neither of those is easier.
08:27:52 <tabaqui> tsahyt: you can remember that any function like "flip :: (a -> b -> c) -> b -> a ->c" has the actual signature "flip :: forall a b c. (a -> b -> c) -> b -> a -> c"
08:28:07 <wuschel> I think I am one of those poor souls that pesters you poor guys with his Haskell pain. Sorry for that. :X
08:28:21 <wuschel> __monty__ Any path you would suggest in particular?
08:28:56 <tsahyt> tabaqui: I think it's easier to remember with GADT syntax, because of that
08:30:06 <nitrix> wuschel: We used to be in your shoes, I see no problem there.
08:30:28 <Ariakenom> tabaqui: So more away from something than to something?
08:30:30 <wuschel> nitrix Thanks for the heads up. 
08:30:34 <nitrix> wuschel: The real secret is that we're all still learning Haskell to some degree ;)
08:30:47 <wuschel> LOL. OK :)
08:31:01 <__monty__> wuschel: I'd recommend just learning haskell. Go through simple tutorials until it clicks. You could check out elm first, it's more beginner friendly in a way but the mentality's very different from haskell.
08:31:31 <tabaqui> Ariakenom: yeah, I don't like some sort of languages, which Go definetely belongs
08:31:46 <wuschel> __monty__ Thanks for the recommendation.
08:31:47 <tabaqui> But I would be fine with Closure, Elixir, Rust and so on
08:32:06 <Ariakenom> tabaqui: interesting thanks
08:32:07 <tabaqui> *Clojure
08:33:38 <phadej> sounds like "better no types. than bad types" :)
08:34:42 <boeingx> tabaqui: but Go tends to be quite verbose
08:34:46 <tabaqui> List has the types, you build
08:35:02 <tabaqui> *that you build
08:35:18 <tabaqui> Go is horrible, everything is wrong
08:35:21 <dmj`> wuschel: honestly, with haskell, the best bang for your buck, and the best way to use it at work I'd say is to use vanilla Haskell 98.
08:35:31 <boeingx> it's quite depressing when switching from Haskell
08:35:36 <tabaqui> Documentation is pure, build system is pure, testing libraries are poor
08:35:54 <restrictedchoice> i have a general question about handling "state" in a web request in a functional language. i've built my first non-trivial webapp in purescript using https://github.com/cprussin/purescript-httpure. right now i have a middleware that wraps the request is a record that includes the original request and my app state. downstream handlers now deal with
08:35:54 <restrictedchoice>  my record rather than the raw request, and therefore get access to state as well. is there a "better" way to do this? i ask here because the question seems just as applicable in the haskell world.
08:36:00 <tabaqui> I spend two days to implement incremental decoder like "cereal" because Go ecosystem is a piece of shit
08:36:03 <dmj`> wuschel: most people try to get too fancy in the workplace with haskell and then the company is bottlenecked on a few people that know the custom fancy stuff, or at a complete halt / standstill, resist the temptation to get too fancy
08:36:23 <tabaqui> s/pure/poor
08:36:51 <dmj`> wuschel: keeping it simple allows you to onboard new developers as well. 
08:36:55 <tabaqui> dmj`: it is a problem of company actually
08:37:08 <tabaqui> manager can hire juniors
08:37:25 <tabaqui> that will be teached by haskeller
08:37:43 <dmj`> tabaqui: it's a problem with both, I've seen insecure employees tie up the company with their fancy abstractions that are half-baked and nobody else understands but them
08:38:13 <tabaqui> anyway I'm a selfish egoistical asshole that thinks about his own future
08:38:27 <dmj`> tabaqui: the goal of software engineering is to manage complexity, not create additional complexity. People code themselves into a corner all the time with half-baked understanding of GHCs type level tricks
08:38:47 <tabaqui> well, it is non-professional
08:39:46 <dmj`> I see this often in companies that don't have clear monetization strategy, they setup a knowledge hierarchy, and whoever knows the most about certain things are considered "senior", not the people who directly affect the bottom line
08:39:49 <tabaqui> I mean math fans that use high-level abstractions that no one understand
08:40:10 <dmj`> yes, its often proof-by-intimidation
08:40:37 * tabaqui is out
08:45:30 <Cale> restrictedchoice: That's a hard question to answer just because it's kind of vague...
08:46:27 <Cale> restrictedchoice: On the face of it, that sounds like a perfectly reasonable way to deal with things though.
08:47:43 <Cale> restrictedchoice: The only thing I'd question in general is whether any part of the system has access to more state than it ought to, and look into controlling that more finely as it comes up.
08:48:09 <restrictedchoice> Cale: i was thinking about that as well, though I wasn't sure how to accomplish something like that.
08:48:32 <Cale> restrictedchoice: Well, one way is just to process the larger state as it comes in
08:48:44 <restrictedchoice> Cale: i'm also now interested in introducing things like logging to my handlers, and it seems like i'll have to move towards something like monad logger and actually learn monad transformers :|
08:48:58 <Cale> Maybe...
08:49:14 <restrictedchoice> Cale: though all the handlers do return Effect (IO in haskell)
08:49:41 <restrictedchoice> so technically i can just sprinkle around log statements. though i'd like to not have those print out when, say, running tests.
08:50:05 <Cale> I've never been particularly impressed by any of the logging monad stuff. It's fine I suppose if you're already using some monad transformers, but the first transformer that takes you away from working in IO has a high cost associated with it.
08:50:35 <restrictedchoice> Cale: you'd worded perfectly a tension i'm feeling. i have no reason to use transformers otherwise.
08:50:45 <sm> +1
08:50:47 <Cale> (because it makes higher-order things like forking new threads or handling exceptions much more tricky)
08:50:48 <restrictedchoice> Cale: is there a more straight-forward way to introduce logging?
08:50:59 <Cale> You're in IO, just write some stuff which does logging.
08:51:14 <Cale> I think there are good enough libraries for that out there as well
08:51:22 <restrictedchoice> Cale: got it. and maybe make it aware enough to not actually log in test runs?
08:52:50 <Cale> Yeah, there are various approaches you can take, from conditionally compiling the thing which writes to the log, to passing around a function for writing the log.
08:53:07 <restrictedchoice> Cale: you're right, these libraries do exist! https://github.com/rightfold/purescript-logging seems pretty nifty and aligns with this approach.
08:53:14 <restrictedchoice> thanks a lot, this advice is super helpful
08:53:36 <tabaqui1> MonadLogger works perfectly fine with MonadBaseControl and liftBase forkIO
08:54:20 <Cale> I really don't like MonadBaseControl though. It should really be split up into different classes for each of the higher order functions we use.
08:55:21 <Cale> It doesn't in general make sense to handle things the same way -- MonadBaseControl does something which will typecheck, but it's often hard to pick apart exactly what that is, and it's easy to make mistakes with it
08:55:30 <Boarders> what is the go to thing for command line applications which have the ability to edit lines and have a history of commands etc
08:55:35 <Boarders> do people use brick or something else?
08:56:14 <Solonarv> haskeline?
08:56:22 <Solonarv> that's what GHCi uses, I think
08:58:05 <Cale> Yeah, brick is more aimed at laying out text-graphical screens, though you might be able to use it for something like that. haskeline is directly solving the issue of keeping track of history and doing line editing and stuff
08:58:22 <Solonarv> brick also doesn't work on windows, IIRC - haskeline does
09:01:14 <Boarders> ah great, I did just want something like edit-lines
09:01:16 <Boarders> thank you
09:05:51 <z0> what's the idiomatic way of guarding agains inequality? (ex: if in `Data a b c d` a,b,c and d are /= x)
09:09:23 <ski> i suppose you could use `notElem' ?
09:10:15 <z0> what i have now is `Data a b c d <- data , null $ filter (== N) [a,b,c,d]`
09:10:56 <Solonarv> that could be replaced by N `notElem` [a, b, c, d]
09:11:03 <z0> notElem simplifies it, yes. but somehow this still feels inelegant
09:11:33 <dmj`> foo (Data a b c d) | all (/=x) [a,b,c,d] = action | otherwise = action2
09:11:42 <z0> (specially because my Constructor has 9 arguments
09:12:30 <z0> i guess ill go with that, thanks
09:16:38 <AlexanderZ> Hello, everyone. Can anybody help me with installing LLVM 6.0.1 on windows? 
09:22:33 <bwe> How do I insert an element at the right depth of a tree structure? Questions enabling me to finding the solution on my own preferred ^^. https://bpaste.net/show/35d65c2a8641
09:24:07 <lavalike> bwe: what's the right depth?
09:25:37 <ski> z0 : a variant would be `null [() | N <- [a,b,c,d]]', since apparently `N' is a data constructor
09:26:10 <bwe> lavalike: Paren [Paren [TextComponent "foo", ParenClosed]] -- has two depths, ParenClosed indicates that depth 2 is finished; 'b' should be inserted at depth *one* as two has been marked completed.
09:27:34 <bwe> Paren [ -- constitutes depth 1 Paren [ -- constitutes depth 2 -- TextComponent "foo", ParenClosed -- closes depth 2] 
09:28:31 <bwe> I would need a way to determine the highest current open depth, in this example, it would be 1. 
09:30:09 <bwe> In addition, I'd need a function to un-nest up to current open depth (of level 1); (then append to that and returning the entire updated tree structure)
09:34:09 <AlexanderZ_> Hello, everyone. Can anybody help me with installing LLVM 6.0.1 on windows?
09:35:22 <lavalike> bwe: that's a strange tree but sure
09:37:34 <bwe> lavalike: well, I try to get a data structure for inverse parentheses: (foo(bar)) => (foorab) => baroof
09:37:54 <lavalike> cute
09:38:17 <infinisil> AlexanderZ_: Wrong channel
09:39:47 <lavalike> bwe: in principle you don't need to put Paren in your data structure, but you can if you want to tokenize and then parse I guess
09:40:59 <lavalike> e.g. tokenize :: String -> [Token] which does tokenize "(foo(bar))" -> [Paren, Str "foo", Paren, Str "bar", CloseParen, CloseParen]
09:41:15 <lavalike> but I think parsing the first string or the tokenized list is basically the same thing
09:41:58 <bwe> lavalike: I need to move. Let's talk later, ok?
09:42:13 <lavalike> sure thing!
09:42:16 <restrictedchoice> Cale: i ended up rolling my own little logger that works great -- https://pastebin.com/RVGpLASu
09:42:21 <restrictedchoice> thanks again for the feedback
09:43:37 <dexterfoo> does law of demeter apply to haskell code?
09:44:16 <jgt> I guess it depends on your philosophy behind trying to adhere to LoD
09:44:17 <restrictedchoice> dexterfoo: kind of tricking to write functional programs with only two-ish function calls in a pipeline
09:44:21 <restrictedchoice> *tricky
09:44:55 <jgt> restrictedchoice: is it about function calls? I thought it was more about reaching deeply into objects?
09:45:27 <restrictedchoice> jgt: well it's nuanced. in OO often "reaching deeply into objects" is really chaining method calls
09:45:41 <jgt> yeah that's true
09:46:17 <jgt> in any case, I've come to see SOLID as just a set of coping mechanisms
09:46:17 <restrictedchoice> jgt: and the "fluent api" style encourages returning "self". the resulting "train wreck" is still thought of as a demeter violation by some folks.
09:46:26 <restrictedchoice> jgt: agreed
09:47:47 <fendor> when using cabal, I should prefer v2-build over new-build right? since, new-* commands are removed in the next major release?
09:48:13 <Solonarv> fendor: they won't be removed
09:49:00 <Solonarv> the change coming in 3.0 for command names is that cabal cmd now means cabal v2-cmd instead of cabal v1-cmd
09:49:19 <Solonarv> cabal new-cmd will continue to mean cabal v2-cmd, so you can use whichever
09:49:31 <jgt> Solonarv: what happens to the old ones? cabal old-cmd?
09:49:51 <Solonarv> yes, in fact cabal old-cmd already means cabal v1-cmd
09:50:16 <fendor> Solonarv, do you have a source for that? because someone reported that cabal 3.0 does not have a new-install option?
09:50:41 <Solonarv> the source is "I have cabal HEAD installed and ran cabal new-build"
09:50:48 <jgt> fendor: well following the naming convention we just discussed, I would expect it to have `install` and `old-install`
09:51:10 <fendor> fair, i suppose
09:52:24 <fendor> oh, i see, the error is actually, that symlink-bindir is no longer recognized
09:53:51 <Solonarv> the current state (2.4) is that there are two command sets:
09:53:52 <Solonarv> cmd, old-cmd, v1-cmd are the legacy commands
09:53:52 <Solonarv> new-cmd, v2-cmd are the nix-style commands
09:53:52 <Solonarv> the state in 3.0 will be very similar:
09:53:52 <Solonarv> old-cmd, v1-cmd are the legacy commands
09:53:52 <Solonarv> cmd, new-cmd, v2-cmd are the nix-style commands
09:55:03 <Solonarv> fendor: yes, cabal 3.0 no longer always symlinks; you can tell it to copy instead
09:55:10 <toastdieb> Hi, rather new to monad transformers here. I was just wondering, is it preferred generally to explicitly lift functions through the stack from the layer they are defined in, or to derive mtl typeclasses (eg MonadReader) and use the functions directly?
09:55:14 <Solonarv> the option is named installdir instead
09:55:37 <cocreature> toastdieb: the latter is more common I’d say
09:55:41 <fendor> Solonarv, is that backwards compatible? e.g., can I use that in cabal2.4 as well?
09:55:43 <Solonarv> cocreature++
09:55:48 <Solonarv> fendor: I'm not sure
09:56:04 <Solonarv> check the documentation or cabal v2-install --help
09:56:19 <Solonarv> cabal 2.4 only supports symlinking
09:56:21 <fendor> Solonarv, i dont have HEAD installed :(
09:56:41 <Solonarv> fendor: good! you asked how it works on 2.4 after all, presumably you have that installed?
09:56:54 <fendor> oh, yes
09:56:59 <fendor> now i understand what you mwan
09:57:04 <Solonarv> :D
09:57:22 <fendor> sometimes, i am slow :(
09:59:23 <fendor> it doesnt look like it
10:00:29 <toastdieb> cocreature: Is it just a matter of style? I would imagine the former could be more efficient since you could bind a few actions in the base monad before lifting in one go
10:01:07 <Solonarv> shouldn't really matter, GHC is very very good at optimizing mtl-style code
10:05:13 <ocharles> The only real problem the GHC optimizer has is that if you have some module Foo that uses MonadX, MonadY in a big do block, GHC can't really optimise much because it doesn't even know what >>= is
10:05:28 <ocharles> If you were to specialise the monad stack, then GHC might be able to optimize it more
10:05:54 <ocharles> If the action in Foo is INLINEABLE then *maybe* it'll get specialized at the callsite with a concrete stack
10:09:50 <cocreature> often it also simply doesn’t matter all that much since your bottleneck is somewhere else so even if there is a performance downside (and as Solonarv mentioned, GHC is pretty good at eliminating that downside) the convenience can be more important
10:14:38 <toastdieb> Ok thanks a lot.. but for me it feels cleaner to group actions that can be done in the base monad as much as possible before lifting them together. Feels wasteful to pass around a whole bunch of things when you're not actually using them
10:15:24 <ocharles> I wouldn't make decisions on what "feels wasteful" but on what produces clean code
10:15:37 <ocharles> I try to avoid having to need any explicit `lift` at all
10:16:04 <ocharles> That's just plumbing, and I should be able to have that done implicitly by the compiler during instance resolution
10:21:03 <cocreature> yeah it’s not really something that I want to have to care about both when writing but also when reading the code later
10:21:06 <toastdieb> Ok thank you for clearing things up, will try to digest and put to practice :)
10:33:20 * hackage rattletrap 7.0.3 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-7.0.3 (fozworth)
10:34:44 <edwardk> i used something like this inside of my opengl code, but i don't think i've seen the idea packaged up anywhere in haskell
10:34:45 <edwardk> https://github.com/ekmett/codex/blob/master/lib/ptrdiff/src/Foreign/Ptr/Diff.hs
10:34:48 <edwardk> anybody?
10:35:54 <edwardk> mainly because when doing ffi into stuff you wind up either using storable and serializing the whole big object or you work with opaque pointers
10:36:20 <edwardk> so here at least you get some help comparing the before and after types of the chain of pointers
10:37:53 <edwardk> ocharles: backpack that thing ;)
10:38:16 <edwardk> not that backpack-based monad transformers are usable. i've tried like 3-4 times and gave up as too messy
10:45:03 <o1lo01ol1o> edwardk: whoa, codex looks like it could be the answer to my UI dreams -- when's the release?
10:47:55 <edwardk> o1lo01ol1o: some time after i figure out how to get fonts to not suck ;)
10:48:27 <edwardk> o1lo01ol1o: right now we're working on getting nice haskell bindings to freetype, fontconfig, harfbuzz, etc. so i can use them to produce nice sequences of characters
10:48:28 <o1lo01ol1o> I'm a stickler for aesthetics, but typography is a deep hole  . . .
10:48:31 <edwardk> so its a long way away
10:48:42 <o1lo01ol1o> lol, ok
10:48:42 <edwardk> i'm aware
10:48:56 <edwardk> i've been spackling over the holes for a few days now
10:49:06 <edwardk> i now have complete bindings to harfbuzz and to fontconfig
10:49:32 <edwardk> i was trying to use the old haskell bindings to freetype2 that lispy wrote back in the day, but i'm giving up and just rewriting them from scratch now
10:49:48 <edwardk> i first tried just using freetype-gl but the quality left me sad
10:50:11 <o1lo01ol1o> Right, ok.  But the opengl bidings are done?
10:50:27 <edwardk> that part is about 30 minutes worth of work
10:50:41 <o1lo01ol1o> (by bindings, I mean also the higher level abstractions needed to make things that one could call a "UI")
10:50:48 <edwardk> oh no
10:50:52 <edwardk> that part is also a ways away
10:51:17 <edwardk> so far its mostly 'hey lets get good wrappings on the gl package, get a bunch of stuff for fonts, fix every problem we encounter along the way dead, etc.
10:51:36 <edwardk> so far its spun off a bit over a half-dozen little libraries i've needed as i went this last week or two
10:52:23 <o1lo01ol1o> gotcha, I'll keep an eye on it then
10:52:36 <edwardk> i've mostly been working on it on ##coda
10:53:32 <edwardk> it has a hell of a long way to go before it is as usable as something like https://makepad.github.io/makepad/
11:00:18 <o1lo01ol1o> That's fine, all i want to do is render particles with some sliders and some data-overlays
11:01:48 <edwardk> cd ..
11:01:49 <edwardk> c
11:23:53 <ezyang> edwardk: what happened with backpack monad transformers? :) 
11:29:19 <edwardk> ezyang: the fact that i can't specify the moral equivalent of default definitions in them makes them really hard to write
11:29:40 <edwardk> that and you wind up needing to plumb some kind of extra argument through everything in case the state or the monad needs something like a region parameter
11:29:48 <edwardk> e.g. consider StateT (Foo s) (ST s) ...
11:30:18 <edwardk> basically you need like 100+ libraries to get the functionality of the mtl
11:30:40 <edwardk> because you need the little modules for lifting, say, Reader behavior over State, etc.
11:30:50 <edwardk> each instance becomes a tiny little library
11:32:56 <edwardk> hah, that ptrdiff thing helped me figure out how to deal with shared object lifetimes
11:33:30 <edwardk> because if i 'own' something with a foreignptr i can use plusForeignPtr to build a new foreign ptr that is 'morally' the same ptr but at a new address, sharing finalizers
11:34:13 <edwardk> so when i go to access, say, the face field of another foreign ptr, rather than give you back a completely _new_ foreignptr, i can cheat and just repurpose the existing one by computing the ptr diff of the old and new one, and adding that diff to the existing foreignptr
11:34:25 <edwardk> now ownership of the new foreignptr keeps the old thing alive
11:34:42 <Solonarv> ooh, sneaky!
11:35:05 <edwardk> before what i had to do was grab hold of the IORef down in the guts of the foreignptr and tie a mkWeak# to it to keep the other foreignptr alive!
11:35:52 <edwardk> this should rather drastically reduce the amount of finalizers i'm using in my code
11:37:24 <phadej> I'm confused by the name, btw, because of http://hackage.haskell.org/package/codex
11:38:15 <edwardk> phadej: i realized that the name was taken after starting it
11:38:21 <edwardk> i'll rename it at some point
11:38:42 <edwardk> the author of codex even offered me the name, but i'm unlikely to take them up on it
11:39:21 <phadej> edwardk: :)
11:40:05 <phadej> edwardk: soon enough you'll be stuck with the name :)
11:40:11 <edwardk> happens
11:40:28 <edwardk> right now the top level project is unimaginatively named 'ui' =)
11:40:38 <Stuck_> :/ it already stuck
11:41:25 <edwardk> mostly right now its acting as a monorepo for a bunch of little libraries that will spin out
11:41:25 <edwardk> https://github.com/ekmett/codex/tree/master/lib
11:44:05 <phadej> edwardk: hkd looks like something next major adjunctions could depend on for FFunctor?
11:45:45 <phadej> https://github.com/ekmett/adjunctions/blob/master/src/Data/Functor1.hs and https://github.com/ekmett/codex/blob/d4eeebf55a8c2bc9b858cdc0ddccb2679e03091f/lib/hkd/src/Data/HKD.hs#L61 ; + Log stuff
11:46:18 <edwardk> phadej: thats kind of the direction its going in
11:46:27 <phadej> good to know
11:46:38 <aarvar> where does FRepresentable go?
11:46:40 <edwardk> i reserve the right to thrash the hell out of everything in here
11:46:56 <phadej> edwardk: in hkd or adjunctions? :)
11:46:58 <phadej> or both
11:47:25 <edwardk> hkd right now provides me what i need inside this project. from there i'll debate about keeping it or just moving it all into distributive or something
11:48:15 <edwardk> its mostly being used for comparatively silly usability experiments like
11:48:16 <edwardk> https://github.com/ekmett/codex/blob/master/lib/harfbuzz/src/Graphics/Harfbuzz/Object.hs#L34
11:48:44 <edwardk> or https://github.com/ekmett/codex/blob/master/lib/atlas/src/Data/Atlas.hs#L66
11:48:49 <phadej> edwardk: yeah, it's fine. Until there's some pressing reason to make a release of adjunctions it can wait (as currently it's not really in a bit of limbo state, with names and places of things. e.g. is it FFunctor or Functor1 or ..)
11:48:50 * hackage servant-elm 0.6.0.2 - Automatically derive Elm functions to query servant webservices.  https://hackage.haskell.org/package/servant-elm-0.6.0.2 (k_bx)
11:48:50 <edwardk> where Box is an FFunctor
11:49:12 <edwardk> Functor1, etc. doesn't work because I want FFunctor, FFoldable, FTraversable..
11:49:23 <edwardk> and the latter become Foldable1 and Traversable1 under that convention!
11:49:37 <phadej> makes sense
11:49:39 <edwardk> notably in the code above i need each of those
11:50:52 <edwardk> but basically doing this as a microcosm of little packages is helping me get back into the swing of writing a bunch of little libraries in a releasable-ish state
11:51:09 <edwardk> and doing them for a purpose lets me avoid getting nerdsniped into backport hell ;)
11:52:14 <phadej> yes, libraries tend to get better if they are used :)
11:53:42 <johnw> edwardk: are you in CA yet?
11:54:03 <edwardk> johnw: soon!
11:54:11 <johnw> see you at Zurihac?
11:54:15 <edwardk> yeah
11:54:24 <edwardk> after i get back from zurihac i go out to california to find a place
11:54:24 <johnw> excellent
11:55:41 <mbwgh> If I have a prototypical expression language in syntax functor representation, are there any "intuitive" things I can do to it with 'ana'? I can find almost no examples of anamorphisms, and most of what I try seems to either not terminate or explode into some wild tree. If I have literals and addition, how could I use ana to, say, generate `1 + 2 + 3`?
11:56:56 <phadej> to the first approximation the same way as you would generate [1,2,3] list
11:57:29 <johnw> I've never used ana to generate expressions
11:58:27 <phadej> ana with non-regular tree shapes is tricky, as your seed have to guide the generation into right branches
11:58:48 <phadej> (puns unintended)
11:59:05 <mbwgh> I think I have the wrong intuition about ana.
12:00:03 <mbwgh> Should I only expect "infinite trees" from it, analogous to infinite streams for lists?
12:00:05 * ski . o O ( `anaM :: (Monad m,Traversable f) -> (s -> m (f s)) -> (s -> m (Nu f))' )
12:01:05 <ski> i suppose you could use an PRNG state, and a max depth or something as your seed ?
12:01:55 <ski> > unfoldr (\n -> guard (n < 1000) >> Just (n,2 * n)) 1  -- not infinite stream
12:01:58 <lambdabot>  [1,2,4,8,16,32,64,128,256,512]
12:02:24 <ski> @type split
12:02:26 <lambdabot> Splitter a -> [a] -> [[a]]
12:02:30 <ski> er, not that one
12:02:40 <ski> @type System.Random.split
12:02:41 <lambdabot> RandomGen g => g -> (g, g)
12:04:07 <ski> with a monadic version, you could use a state monad to keep track how many nodes you've generated in subtrees to the left, so that you know how many nodes you have left to generate (at maximu, say)
12:04:52 <Solonarv> ski: btw, whatever >> return bar = bar <$ whatever (or whatever $> bar)
12:04:52 <ski> but merely keeping track of max depth (so environment, rather than state), should work, to avoid getting infinite depth
12:05:48 <mbwgh> Okay, so 'ana' is too weak for that kind of thing? I was able to generate things like `1`, `2 + 2 + 2 + 2`, `3 + 3 + 3 + 3 + 3 + 3`, which was weird, but I thought I was getting somewhere :/
12:05:50 <ski> Solonarv : hm, yeh. i suppose i'm used to typing that version
12:06:15 <ski> mbwgh : as i said, you could probably get somewhere even with just depth and PRNG state, with plain `ana'
12:07:03 <edwardk> here https://www.irccloud.com/pastebin/up0tEVfR/mbwgh.hs
12:07:10 <edwardk> mbwgh: ^-
12:08:32 * ski was assuming mbwgh wanted some kind of random generatation, but sure
12:08:44 <edwardk> he asked how to generate 1+2+3 =)
12:08:50 <edwardk> i figured i'd take him at his word
12:08:55 * ski smiles
12:09:06 <edwardk> an easier seed is to do an apomorphism
12:09:18 <tabaqui> What is Control.Functor.Pointed in mathematical sense and why there is no "instance (Applicative f) => Pointed f where point = pure"?
12:09:28 <ski>   foo = Add (Lit 1) (Add (Lit 2) (Lit 3))  -- tree "generated" ;)
12:09:51 <edwardk> instance Applicative f => Pointed f    would mean there can be no pointed instances that are not applicative
12:09:54 <edwardk> e.g. Set wuld go away
12:09:56 <ski> tabaqui : overlapping instances like that tends to be problematic
12:10:03 <edwardk> er would
12:10:19 <tabaqui> oh, right
12:10:36 <tabaqui> so Applicative is basically a subclass of Pointed?
12:10:44 <edwardk> morally
12:10:47 <ski> you could view it as such, yes
12:10:51 <edwardk> but its not in the standard hierarchy that way
12:10:53 <mbwgh> Thank you very much for the example!
12:11:16 <tabaqui> that is fine, Haskell doesn't follow mathematical hierarchy completly
12:12:03 <tabaqui> edwardk: no, wait
12:12:15 <tabaqui> I didn't mean "class Applicative f => Pointed f"
12:12:18 <edwardk> anyways you can see that you need to do something to distinguish left vs right
12:12:19 <tabaqui> I meant instance
12:12:25 <edwardk> tabaqui: the instance is what i meant
12:12:46 * ski . o O ( "Supertyping Suggestion for Haskell" by John Meacham in 2004 (?) at <http://repetae.net/recent/out/supertyping.html> )
12:12:48 <edwardk> given any instance ... => Foo f               that instance will overlap _all_ other possible instances for Foo
12:12:49 <tabaqui> but "instance con1 => con2" doesn't imply that any con2 is con1
12:13:08 <edwardk> you can't write any other instances without overlap
12:13:32 <tabaqui> if you do, than you can broke equation pure === point
12:14:09 <tabaqui> *break
12:14:14 <edwardk> tabaqui: the issue is that instance resolution is done by looking at the heads not by checking to see if the bodies are satisfied.
12:14:37 <tabaqui> s/equation/identity
12:14:39 <edwardk> with your instance in scope, ghc is free when given a demand for a Pointed instance for f to turn it into a demand for the 'simpler' Applicative instance during instance resolution!
12:15:03 <tabaqui> oh, I rememeber
12:15:05 <tabaqui> yeah
12:15:25 <edwardk> instance Show a => Show [a]     -- says when you encounter the right hand side Show [something]   go look for an instance for Show something -- nowhere does the system backtrack if that is a bad idea
12:15:47 <edwardk> backtracking on failure is incompatible with the open world assumption
12:16:04 <mbwgh> Since my question was about a rather unidiomatic use-case, what would be more typical use-cases of `ana`? Is it used as often (seldomly) and for the same purposes as unfoldr?
12:16:23 <edwardk> mbwgh: unfoldr _is_ an anamorphism for lists
12:17:01 <tabaqui> % data Foo
12:17:02 <yahb> tabaqui: 
12:17:07 <edwardk> and yeah its mostly useful for things like half of a metamorphism for things like streaming radix conversion, of as half of a tree sort or something
12:17:10 <edwardk> its not super common
12:17:11 <tabaqui> % instance Show [Foo] where show _ = "foos"
12:17:11 <yahb> tabaqui: ; <interactive>:131:10: error:; * Overlapping instances for Show [Foo] arising from a use of `GHC.Show.$dmshowsPrec'; Matching instances:; instance Show a => Show [a] -- Defined in `GHC.Show'; instance Show [Foo] -- Defined at <interactive>:131:10; * In the expression: GHC.Show.$dmshowsPrec @([Foo]); In an equation for `showsPrec': showsPrec = GHC.Show.$dmshowsPrec @([
12:17:15 <tabaqui> here it is
12:17:27 <mbwgh> edwardK: I know, but I wanted to make sure that I am not approaching this too biased, since 'ana' is more general
12:17:40 <tabaqui> ok, thank you
12:17:44 <edwardk> mbwgh: i use the notion a lot in my hyperfunctions cofe
12:17:47 <edwardk> er code
12:17:50 * hackage primitive-offset 0.2.0.0 - Types for offsets into unboxed arrays  https://hackage.haskell.org/package/primitive-offset-0.2.0.0 (andrewthad)
12:17:51 <ski> tabaqui : that's a bad `Show' instance, btw. in more than one way
12:18:25 <ski> edwardk : you mean "codfefe" ?
12:18:36 <edwardk> mbwgh: https://github.com/ekmett/hyperfunctions/blob/master/src/Control/Monad/Hyper.hs
12:18:45 <tabaqui> ski: what do you mean?
12:18:46 <edwardk> mbwgh: might serve as some anamorphism porn for you
12:19:07 * nshepperd wonders if it would be more accurate to read 'instance con1 => con2' as 'con2 if and only if con1'
12:19:12 <edwardk> that module and the representable versions are probably the most i've ever used anamorphisms in anger
12:19:30 <ski> tabaqui : (a) it's overlapping with the existing `instance Show a => Show [a] where ...' instance; (b) `show _ = "foos"' is a bad implementation of `show'
12:19:46 <tabaqui> ski: yeah, it was an example for the discussion above
12:19:51 <tabaqui> about how GHC resolve instances
12:20:36 <ski> in this particular case, you *could* define `showList' in `instance Show Foo where ...' .. but i suggest you don't
12:20:58 <tabaqui> yep
12:21:25 <edwardk> mbwgh: i use the anamorphism again here: https://github.com/ekmett/hyperfunctions/blob/master/examples/Cantor.hs#L34
12:22:34 <edwardk> where it shows that using escardo's "seemingly impossible functions" hyper functions from bool to bool are very strange, given that they are isomorphic to the naturals, and under certain continuity conditions (that every such function passed to them terminates in a fixed amount of time, then they are their own "double power set"
12:23:37 <ski> oh, `Hyper' looks fun
12:24:12 <edwardk> ski: https://github.com/ekmett/hyperfunctions/blob/master/src/Control/Monad/Hyper/Rep.hs#L54 is my preferred form for it
12:24:13 <ski> @where impossible
12:24:13 <lambdabot> <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>,<http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
12:24:30 <edwardk> in general when faced with things i'm going to define via anamorphism i like to see if i can switch them into some form using a representable functor
12:24:55 <edwardk> https://www.schoolofhaskell.com/user/edwardk/moore/for-less is a few year old article i wrote on the idea
12:25:30 <edwardk> mbwgh: ^- that might also be useful for you if you're fishing for ana intuitions
12:26:01 <tabaqui> oh, category-extras is not included in stackage lts
12:26:20 <edwardk> category-extras was split into like 40 little packages like 10 years ago
12:26:44 <mbwgh> edwardk: The grand goal was originally to work my way up to dynamorphism. I was trying my way at some dynamic programming problems and asked on reddit about it.
12:27:06 <tabaqui> well, googling "zygo haskell" returns me link on /r, SO and category-extras
12:27:10 <tabaqui> *links
12:27:16 <edwardk> dynamorphisms are kind of a dead-end tbh, they handle a small subset of dynamic programming problems at the cost of turning your brain to mush ;)
12:27:33 <edwardk> tabaqui: recursion-schemes replaced the category extras version
12:27:49 <mbwgh> oh man :(
12:28:31 <edwardk> mbwgh: i figure when tarmo uustalu, the guy who was responsible for half the craze on recursion schemes gave up on them it was time for me to do the same ;)
12:28:47 <tabaqui> google -_-
12:28:49 <tabaqui> ok, thx
12:28:51 <edwardk> the basic cata/ana/hylo are kinda useful
12:29:06 <edwardk> the notion that you can build up the rest with distributive laws or adjoint functor pairs is kinda nice
12:29:25 <edwardk> but the details of any particular choice of monad/comonad/adjoint functor pair less so
12:30:04 <jkachmar> Greg Pfeil (sellout) is still kinda plugging away at some new recursion schemes work in his `yaya` library afaik, but idk where that's going
12:30:53 <edwardk> jkachmar: yeah i've talked to greg about it
12:32:28 <jkachmar> unrelated to any cool categorical stuff: has anyone used `vty` to build something that's _not_ basically a Terminal UI?
12:32:29 <jkachmar> I'm looking for something to help deal with the futzy stuff of interactively drawing updates to a tree-structured log of events, but I'd still like to avoid taking over the whole terminal, still allowing the user to scroll, etc.
12:33:06 <edwardk> jkachmar: how would that work?
12:33:42 <edwardk> oh http://hackage.haskell.org/package/vty
12:34:11 <jle`> jkachmar: some people have made roguelikes and visual games like that, if that's what you are talking about
12:34:21 <jkachmar> Well, right now the system my coworker is using has `ansi-terminal` jump around and update/redraw things, but this gets especially fiddly when we want to accept user input but not have it bork the drawing, not mess up updating the terminal when it gets resized, etc.
12:35:14 <jkachmar> jle`: What I'm going for is more of something that looks like `npm` or Scala's `fury` than a fully interactive Terminal UI, if that makes sense?
12:35:28 <edwardk> when terminals get resized things get pretty wonky. if they rewordwrap, etc. seems pretty terminal dependent
12:38:00 <mbwgh> One last question, is there an accessible explanation of the differences between Fix/Mu/Nu somewhere?
12:38:03 <edwardk> jkachmar: i say that mostly because it can make a curses-style api get really confused about what is on the screen if you only drew part of it, say to put some spinners up for file uploads, etc.
12:38:22 <edwardk> in haskell they are all of equivalent power
12:38:34 <edwardk> in other languages the least and greatest fixed points may not coincide
12:38:41 <edwardk> and Fix may not even be a thinkable thought
12:39:09 <edwardk> its a fun exercise to write the code to convert between Mu <-> Fix   and Mu -> Nu
12:39:39 <mbwgh> Does "other languages" mean anything not haskell, or do you mean total languages specifically?
12:39:40 <edwardk> but coming Nu -> Mu is more platform dependent
12:39:56 <edwardk> i mean basically any language that is strict
12:40:15 <edwardk> doesn't even need totality
12:40:35 <jle`> mbwgh: one thing that was illuminating to me was seeing Fix/Mu/Nu in a language without type level recursion like dhall
12:40:55 <jle`> or well, without any recursion at all
12:41:48 <jkachmar> edwardk: yeah, I know that's kind of gonna be a pain; probably just worth it to heavily constrain the kind of interactivity we allow. Thanks
12:41:56 <jle`> mbwgh: it turns out you can implement Nu, but you can only write 'Corecursive'/'ana' with it
12:42:09 <jle`> mbwgh: and you can implement Mu, but you can only write Recusrive/cata with it
12:42:40 <mbwgh> interesting!
12:43:12 <jle`> er wait, i might have missed something
12:43:18 <ski> perhaps one should clarify which version of `Mu' and `Nu' is talked about, here ..
12:43:22 <edwardk> jkachmar: i've wanted a principled way to throw up a few lines of interactive text where it handles spinners, etc.
12:43:36 <edwardk> you can turn off echo to avoid user typing causing you pain
12:44:11 <mbwgh> I thought there was an authorative definition?
12:44:16 <edwardk> and pump it and draw it yourself like i would back in my mud days
12:44:44 <edwardk> mbwgh: mu is the least fixed point, nu is the greatest fixed point. they are formally defined by the existence of cata and ana
12:44:47 <jle`> mbwgh: here is a nice reference implementation https://github.com/sellout/dada
12:44:54 <jle`> if you're familiar with dhall syntax
12:45:03 <edwardk> mbwgh: https://www.schoolofhaskell.com/user/edwardk/recursion-schemes/catamorphisms
12:45:37 <jle`> mbwgh: and so you get some interesting results, as well: in a total language like dhall, List is only Corecursive, not Recursive
12:45:54 <jle`> er wait i mixed that backwards
12:46:08 <jle`> it's only Recursive, not Corecursive
12:46:32 <edwardk> you get similar results in scala though, you don't even need totality
12:47:16 <jle`> oh that's neat too
12:47:23 <jle`> maybe i should expand my horizons more beyond just haskell, heh
12:47:24 <mbwgh> because of strictness?
12:48:02 <mbwgh> (or is this question incredibly stupid...)
12:48:32 <edwardk> you can kind of fake the distinction in haskell by talking about Mu vs. Nu for something like data Option a = None | Some !a deriving Functor
12:48:54 <edwardk> now Mu Option and Nu Option aren't "the same size"
12:49:14 <edwardk> where i lied about the functorness of Mu there
12:49:20 <edwardk> er of Option
12:53:46 <jkachmar> edwardk: Yeah, I think turning off echo for stdin and then looping something like `hGetChar` will get me what I want; again, tyvm
12:55:05 <edwardk> jkachmar: i also do periodic polling of the window size to check to see if i'm hosed =)
12:56:05 <edwardk> like i mentioned wordwrap on resize is basically impossible to detect right though
12:56:54 <edwardk> e.g. https://www.tenforums.com/tutorials/94092-turn-off-wrap-text-output-resize-console-window-windows.html shows it being a configuration option for the windows console
12:57:05 <edwardk> but there is no 'terminfo' telling you which way it is set ;)
12:58:14 <edwardk> i remember way back in the late 80s writing a BBS and building my own emulator of ansi internally to the BBS so i could draw popup windows that looked like the ones from turbo pascal /  technojock's toolkit on top of the otherwise console-like output of the board
12:59:23 <edwardk> i went so far as hooking the fossil driver that was used to pump characters <-> the modem so i could spy on third party applications like bbs doors and overlay text on them to let you chat even when someone was in a game
13:00:01 <edwardk> sadly, people don't want to let you control their terminal like that today, as being able to see the text that other applications have spewed to the terminal is a giant security risk =)
13:06:27 <jkachmar> Yeah, but is the security _really_ worth it if we lose the ability to do things like that to our terminals   :T
13:07:07 <edwardk> jkachmar: http://ballingt.com/rich-terminal-applications-2/ talks a bit about different mitigation strategies for resize
13:07:42 <jkachmar> edwardk: Also thanks for the period reminder that, under the hood, all our "modern terminals" are really just frontends to some twisty mess of emulation layers on top of historical concerns like modems, UART, etc.
13:08:18 <jkachmar> s/period/periodic
13:39:24 <phadej> I still use terminal over not-so-reliable network connections, so maybe not modems but still something not-reliable
13:42:21 * hackage hoogle 5.0.17.9 - Haskell API Search  https://hackage.haskell.org/package/hoogle-5.0.17.9 (NeilMitchell)
13:51:45 <jgt> also typewriters, iirc
13:54:20 * hackage refined 0.4.2 - Refinement types with static and runtime checking  https://hackage.haskell.org/package/refined-0.4.2 (chessai)
14:25:03 <alicej> Im trying to deriveJSON for a datatype indexed by a datakind. I only want to derive it for one kind. Is there a way to do something like: $(A.deriveJSON defaultOptions '(OutgoingEmail 'Serialized))? Where Serialized is an element of a datakind 
14:27:13 <lyxia> alicej: how is OutgoingEmail defined
14:29:53 <phadej> hmm, with TH it won't work
14:30:18 <alicej> lyxia: There is a GADT inside OutgoingEmail with the following type data Attachment :: Serialization -> Type
14:30:27 <phadej> with Generics one could write instance FromJSON (MyType 'SomeParam) where parseJSON = genericParseJSON defaultOptions
14:30:28 <alicej> Outgoing email is just a record 
14:30:42 <alicej> phadej: I tried that but its not letting me derive generic for the GADT
14:30:53 <phadej> oh, if it's GADT, you have to write instance by hand
14:30:58 <phadej> TH won't help either
14:31:29 <phadej> that's the price of GADTs; no nice metaprogramming (it's a research topic, to some degree)
14:32:29 <Solonarv> what about kind-generics ?
14:37:22 <johnw> phadej: and Haskellers don't realize how nice and easy pattern matching on GADTs is :)
14:37:43 <phadej> Solonarv: i consider it "under a research"
14:39:20 <Solonarv> ah, fair enough
14:40:28 <mac10688> Does anyone use docker for their local development? I'm using docker compose and when I want to put the latest source code in the docker container I rebuild the image/container and it causes me 2 problems. 1. It pulls down all the dependencies again, instead of using cached and 2. Creates a new image that I need to delete
14:40:43 <mac10688> What should I be looking to do to streamline my development?
14:41:47 <phadej> if you insist on using docker, than having a volume where to store the dependencies, so they persist between builds
14:41:59 <phadej> but "how" is tricky, it's been time since I touched docker :(
14:43:07 <mac10688> :( That doesn't sound promising lol
14:43:09 <johnw> mac10688: is this Haskell related?
14:43:26 <mac10688> well it's part of my stack/haskell environment
14:43:39 <mac10688> i'm trying to figure out how to streamline my haskell development using docker or something
14:43:41 <johnw> if you use Nix, there's a very nice way to eliminate dependency rebuilding when creating Docker containers
14:43:53 <jkachmar> mac10688 `stack` has Docker integration if you'd like to develop within a Docker container but still cache everything
14:43:59 <johnw> the dependencies are built and kept in your own Nix store, and reused each time you build the container
14:44:28 <johnw> this is how we deploy Haskell binaries to a Docker container at work
14:45:04 <phadej> johnw: you mix up docker for development vs. docker for deployment
14:45:17 <phadej> (but I kind of agree, don't use docker for development; it's not really made for that)
14:45:36 <mac10688> yeah I've always heard a lot about nix but it's a whole OS isn't it? Either I'm using nix or ubuntu right? Also, jkachmar i saw that stack integrates with docker but I didn't know how i would get it to work with docker-compose
14:45:51 <mac10688> since docker-compose I point it to a dockerfile
14:46:10 <johnw> is docker for development using a docker-built binary to test, or actually using a container as your development environment (editor, debugger, compiler)?
14:46:39 <johnw> NixOS is the OS
14:46:41 <mac10688> to build my project and run it so i can test it
14:50:31 <lyxia> alicej: I would really like to see the whole definition, because as others have said there is currently no automated solution but I am looking for nails to hit with the kind-generics hammer.
14:50:41 <mac10688> This whole nix thing doesn't feel good to me. 1. I don't know what it really does. 2. It feels like another huge rabbit hole that's going to distract me from writing haskell 3. I don't want to install an OS just so I can do development. I was hoping to use docker so I can write code from any machine and deploy with docker.
14:51:50 <boj> mac10688: you concerns make sense, however, nix is a package manager that gives you deterministic builds. NixOS is built on top of nix. you can install nix on Ubuntu, or in docker, etc.
14:52:19 <jkachmar> fwiw, I find Nix to be fairly complicated and I generally only try to use it in as thin a manner as possible
14:53:08 <jkachmar> mac10688: why do you need docker-compose for this, I'm somewhat confused as to what your setup is here
14:53:50 * hackage rattletrap 8.0.0 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-8.0.0 (fozworth)
14:54:00 <mac10688> I'm writing a webserver with haskell-servant and it will have a database and use nginx as a reverse proxy. I think docker-compose is a great way to keep it all together
14:54:18 <jgt> Nix is the only thing I could make work with a holistic approach for my Haskell projects
14:54:21 <mac10688> I'm not an expert at docker though and I'm still feeling it out
14:54:51 <jgt> like, there's all these other things — stack, cabal-install, halcyon, docker, blah blah blah
14:55:29 <jgt> nix is the only thing I've managed to make work. It handles my development environment, dependency management (all of it, not just Haskell packages), and all my cloud infrastructure stuff
14:55:59 <alicej> lyxia: https://gist.github.com/mckeankylej/56a63c688ed87292d7188e8d92ca5b92
14:56:01 <jgt> but I know other people make docker work, so if what you have works then just stick with it
14:58:21 <jkachmar> mac10688: so you have separate Dockerfiles for your major applications, correct? It sounds like what you want here is to have some sort of intermediate cache so your Haskell server doesn't have to rebuild everything when you go to run integration tests or w/e
14:59:30 <mac10688> I think that's right
15:01:18 <mac10688> it's just that docker-compose down and docker-compose up --build will create a new image and it starts from scratch! That's time consuming and takes up a gig of memory on my drive
15:03:20 <mac10688> I think I might just scratch it. It doesn't sound like there's going to be an easy answer. I'll just do my quick tests and stuff on my local machine and if I think everything is right there, I'll deploy to docker as a final test
15:03:29 <mac10688> and in the meantime look into the nixos
15:03:40 <jgt> mac10688: you don't need NixOS to use Nix
15:04:04 <jgt> mac10688: I develop Haskell locally on my MacOS machine, in a Nix shell
15:04:35 <jgt> and most of my software is installed through Nix; it has mostly replaced homebrew for me
15:06:16 <johnw> jgt: same
15:06:26 <mac10688> I get mixed messages when I go to their site. https://nixos.org/nix/ the site is nixos and the header says purely functional package manager
15:06:32 <johnw> i've been used it as my only package manager and dev environment for 5 years now
15:06:35 <johnw> (on macOS)
15:07:02 <mac10688> ok i'm going to take an hour or two to try to download and configure this and see what's going on
15:07:10 <johnw> lol
15:07:17 <johnw> oh, the optimism of youth
15:07:20 <mac10688> should I just hop in and start hacking away or is there a resource that will explain it all?
15:07:38 <jgt> mac10688: NixOS = operating system. Nix = package manager. NixOps = cloud management software.
15:08:07 <jgt> mac10688: there are many resources that help explain it, though it _may_ take a little longer than an hour or two
15:08:11 <jgt> still, have at it!
15:08:34 <jgt> and ask around in #nixos if you get stuck
15:08:45 <mac10688> oh i'll check that channel out. thanks
15:20:43 <jkachmar> johnw: your dotfiles setup is pretty awesome, gotta say
15:20:49 <jkachmar> it's the thing that makes me want Nix to work for me
15:21:10 <johnw> thanks!
15:22:55 <jgt> so… you two just gonna keep this dotfile goodness to yourselves or what?
15:24:01 <shapr> is it https://github.com/jwiegley/dot-emacs ?
15:39:14 <shanesveller[m]> Hi folks - I’m still quite new to Haskell but starting to try to internalize idioms. other than some instinctive decisions about readability that I will take more time to develop, does anyone have any guidance when I might prefer, for a function body specifically, “let..in...” vs “stuff...where...”?
15:39:15 <shanesveller[m]> My FP-specific background is primarily a few years of Elixir, a tiny bit of Clojure and some casual Emacs Lisp if that helps give some common frame of reference.
15:40:29 <shanesveller[m]> Also have access to a couple of textbooks if those contain good references, I have a Safari sub as well as Practical Haskell 2E and Haskell Programming From First Principles
15:40:43 <jkachmar> jgt: https://github.com/jwiegley/nix-config
15:40:53 <shanesveller[m]> Working through the latter two concurrently
15:40:56 <tty1> does stack know about things installed via cabal and vice versa? Can I for example install something with cabal and then uninstall with stack?
15:41:25 <shanesveller[m]> Nix/Dhall ultimately brought me to Haskell 😁
15:41:25 <jkachmar> tty1: you can't uninstall with either `stack` or `cabal`
15:41:48 <jkachmar> But no, `stack` and `cabal-install` don't know about packages installed or managed by each other
15:42:25 <tty1> wait you cant uninstall.. what bull cocky is that :(
15:42:41 <jkachmar> `stack` typically installs packages to `$HOME/.local/bin` and `cabal-install` to `$HOME/.cabal/bin`
15:42:51 <jgt> tty1: you can uninstall with Nix!
15:42:56 <jkachmar> tty1: think `make install` not `apt-get install`
15:43:10 <jkachmar> You can uninstall with Nix because it's going to install those things more like `apt-get` would
15:43:26 <tty1> ahh i always avoid installing from source for that very reason :(
15:43:28 <hpc> the notion of installing is a bit of a historical detail, and not really part of their intended model
15:43:34 <jkachmar> (or rather, because Nix itself is "more" than `cabal` or `stack` is)
15:43:44 <jkachmar> tty1: I mean when you `stack install` you're installing from source
15:43:47 <hpc> "install" would be better named "add-to-build-environment"
15:44:04 <jkachmar> `stack install` is just an alias for `stack build --copy-bin`, which I think is more informative
15:44:07 <hpc> and sometimes that environment is "the global one"
15:44:32 <hpc> a better way of turning haskell stuff into rpms or debs would clear all this up
15:44:58 <hpc> nix can uninstall because it's closer to a distro package manager than being a pure build system
15:45:14 <tty1> well this may cause me some issues as i installed the wrong version of something that my ide needs to work (its not for a project at all)
15:45:33 <jkachmar> `which <something>` and then delete it
15:46:15 <jkachmar> for `stack`, it's generally recommended that you do something like `stack install --copy-compiler-tool <package>`, which will install it to a directory that's corresponds to the version of GHC that your resolver is tied to
15:47:02 <jkachmar> e.g. `stack install --copy-compiler-tool --resolver=lts-12.26` will install things using the LTS 12.26's package set and GHC 8.4.4; `stack install --copy-compiler-tool --resolver=lts-13.22` will use LTS 13.22 and GHC 8.6.5
15:47:32 <jgt> "You almost certainly do not want to use stack install" — https://lexi-lambda.github.io/blog/2018/02/10/an-opinionated-guide-to-haskell-in-2018/#understanding-stacks-model-and-avoiding-its-biggest-gotcha
15:47:40 <jkachmar> From thereon, `stack exec` will drop you into a subshell that corresponds to resolver currently in scope
15:47:48 <ski> shanesveller[m] : i tend to think `where' is often more readable. but it depends on whether one'd prefer to read the details first (so bottom-up), or the big picture first (top-down)
15:48:07 <jkachmar> ah, you want `stack build --copy-compiler-tool`, my bad
15:48:49 <hpc> shanesveller[m]: yeah, this is one of the purest examples of "programming communicates with not just the machine, but other programmers too"
15:49:11 <jgt> tty1: be sure to read that section of the article I just posted
15:49:34 <tty1> will do
15:49:57 <shanesveller[m]> Thank you both
15:52:31 <ski> shanesveller[m] : tibbe's style guide at <https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md> is mostly sensible, i think. i use two-space indentation
15:56:35 <shanesveller[m]> That looks like a great resource and is new to me, so thanks again
15:58:16 <hpc> i'll say some of the stuff in that guide is quite odd
15:58:38 <hpc> like the preceeding comma layout for lists, and similar treatment of other delimiters
15:59:10 * ski does that all the time
15:59:18 <shanesveller[m]> Is that an instance of elm creeping back into Haskell, maybe?
15:59:22 <hpc> but writing readable haskell is quite intuitive in my experience
15:59:30 * ski has no idea how Elm looks like
15:59:56 <hpc> i always do [\n\ta,\n\tb\n\tc...
16:00:03 * ski also tends to align things .. perhaps a bit obsessively
16:00:06 <hpc> (mentally replace \t with spaces)
16:01:05 <hpc> i only use significant alignment
16:01:32 <hpc> with an ide that highlights in blocks instead of just keywords, i would probably like alignment a lot more
16:01:38 <hpc> like if you did
16:01:43 <hpc> f Nothing = ...
16:01:48 <hpc> f _       = ...
16:02:06 <hpc> and the highlighting for the parameter was a solid block instead of being shaped like a backwards 7
16:02:39 <ski> it would be nice to have awareness of two-dimensionality like that
16:02:40 <tty1> Woot after like a week of trying to get any haskell IDE to work I finally got a working env.. shits about to get real :)
16:03:05 * ski idly wonders what "haskell IDE" means in this instance
16:03:30 <hpc> it'd be fun to write a haskell language server
16:03:41 <hpc> but ghc is still rather daunting for me
16:04:11 <hpc> and i hardly even spend time coding my existing projects lol
16:21:53 <jgt> yeah I've never really understood what IDE meant
16:22:19 <jgt> I'm sure someone showed me "the power of automatic refactoring" once, and it was basically variable renaming
16:27:12 <hpc> it's variable naming with full knowledge of the code behind it
16:27:17 <hpc> if you're say, in java
16:27:19 <Nevoic> Renaming is pretty important. I worked on a Python project that was quite large, and we kept legacy names (GithubRepo for example) for an object that pretty much became our entire domain model (github, gitlab, heroku, etc.) because it was far too much effort to go through thousands of line of codes "just to rename".
16:27:35 <Nevoic> code*
16:27:35 <hpc> refactoring the foo member of objects of class Bar
16:27:53 <hpc> it's going to look for every instance of a value referenced in the code where the type is Bar, then rename the ".foo" after it
16:27:58 <Nevoic> It's cool to be able to safely rename something in a couple seconds instead of a few hours.
16:28:05 <hpc> but not any other ".foo" where it would be inappropriate
16:28:45 <jackdk> if your compiler caught that it wouldn't be so much of a problem though
16:28:47 <hpc> it gives you extra contextual navigation as well, like jumping to definition or rendering documentation
16:28:57 <jgt> ok, so simple find and replace + GHC is effectively the same
16:29:06 <Nevoic> But an IDE is definitely more than just renaming. I have HIE setup in vim and I get inline compile time errors, warnings, optimizations, type definitions, etc.
16:29:19 <Nevoic> Yeah, having a compiler is like at least half the battle, I agree.
16:29:25 <hpc> haskell's unusual in how effective the plain type system is at catching that stuff
16:29:30 <Nevoic> It would cut down the few hours to probably 5 or 10 minutes.
16:29:42 <Nevoic> Still not as "cool" as 2 or 3 seconds, but not as much of a hurdle.
16:29:51 <Nevoic> I'm talking for codebases with thousands or tens of thousands of lines of code.
16:30:04 <jgt> I think I don't miss and IDE since I pair vim with GHCi basically always, so I get all those features there
16:30:24 <Nevoic> Also hpc does bring up a good point, if you start renaming shit with find/replace it could implicitly start changing type definitions. It's rare, but that'd be an annoying/unnecesssary thing to go through.
16:30:49 <Nevoic> Assuming people aren't writing type definitions for everything, which obviously hopefully they are.
16:30:52 <jgt> type definitions? really? even with casing?
16:30:56 <Nevoic> Just talking worst case scenario here.
16:31:16 <Nevoic> Na, I mean implicitly changing the meaning of types, not effecting actual type annotations.
16:31:22 <Nevoic> i.e via type inference.
16:31:37 <Nevoic> This is assuming the project has no type annotations, which like I said hopefully isn't the case.
16:31:51 <jgt> heh… I've never seen that in the wild
16:32:06 <Nevoic> I'm glad to hear that, some of us aren't as lucky x(
16:33:00 <hpc> that's what :t is for
16:33:20 <hpc> turn on warnings, then ghci the crap out of any file that comes up
16:33:32 <Nevoic> Also pairing vim with ghci isn't the same as HIE inside vim, HIE integrates GHCI but also linters/warnings etc.
16:33:32 <Nevoic> I've found entire functions that exist in the prelude that I accidentaly duplicated unknowingly.
16:35:23 <jgt> yeah I have some ghetto patchwork setup that includes all that stuff too
16:35:37 <Nevoic> Ah nice. I'm not that clever.
16:35:54 <jgt> a 21-line .ghci file, and then some vim-dispatch bindings that send stuff out through tmux send-keys
16:36:15 <Nevoic> I also like autocomplete, cool to start writing a function and seeing a list of potential functions that are in scope based on my imports (i.e not just text based auto complete) with type information.
16:36:39 <hpc> extra credit if it hides things it knows could never unify in the current context
16:36:44 <jgt> that'd be nice; I think I'd have to use tags for that, but currently I'm just doing vim's native completion
16:37:07 <Nevoic> It's still not on par with say Intellij + Kotlin/Java, where when you actually write the function it'll suggest things to fill in. I've gotten through some very poorly documented libraries using that feature.
16:37:35 <Nevoic> If there are like 100s of variables/functions etc. in scope it's hard to read through all the source code and find what types fit into what.
16:37:47 <jgt> supposedly, typed holes provides that sort of workflow, but I've never really done that
16:37:48 <Nevoic> Cool to just have the IDE highlight the things via autocomplete that fit.
16:38:10 <Nevoic> Yeah, typed holes get some of that. That's something I've been meaning to setup.
16:38:24 <Nevoic> But the largest problem with all of this (HIE/tags/autocomplete etc.) is the setup.
16:38:41 <Nevoic> Intellij + kotlin is literally just installing the IDE and the JDK and you're good. Full blown IDE features.
16:38:50 <Nevoic> Took me a total of probably 15 hours to set up HIE for the first time.
16:38:57 <jgt> yeah, it was loooaaaads of trial and error before I got to where I am now
16:38:58 <Nevoic> I've been through 4 different autocomplete engines due to different bugs.
16:39:09 <Nevoic> Some of them entirely froze vim if certain conditions were met.
16:39:14 <jgt> took me a long time to realise that I shouldn't actually use yesod-devel
16:39:49 <MarcelineVQ> fwiw it takes about 3 minutes to set up ghcid, and 2 minutes of that is build time
16:40:09 <Nevoic> Yeah, once you know what you're doing then it's easy.
16:40:39 <jgt> I've essentially reimplemented ghcid
16:41:07 <Nevoic> I could get my setup going in under 30 minutes on another computer (assuming I have access to my .vimrc).
16:41:16 <Nevoic> Not including HIE build time.
16:41:17 <jgt> or rather, I copied all the stuff Neil Mitchell was doing before he formalised it as ghcid
16:42:43 <Nevoic> But the tooling isn't there, generally speaking. Different versions of Haskell can break certain parts of my tooling system, and I had to change from ghc-mod to HIE due to that very problem.
16:42:43 <Nevoic> I have never really "fought" with IDEs in other static languages, they're usually just packaged up nicely into one thing, and they have all the features I want.
16:42:43 <Nevoic> It's a bad sign when some Python developers have more tooling setup than some Haskell developers.
16:43:58 <Nevoic> I'd much rather work on Haskell over Python, don't get me wrong. But I see some Python developers using Kite for intelligent "AI" autocomplete with inline docs with "type information" (if you can even call it that in a unityped language), and some Haskell developers working in a text editor with no inline information/error detection/linting etc. ou
16:43:58 <Nevoic> tside of GHCI in a separate window.
16:44:18 <Nevoic> Just because of the hassle, and I get that. It is a hassle. I just wish it wasn't.
16:44:47 <ski> "seeing a list of potential functions that are in scope based on my imports (...) with type information.","extra credit if it hides things it knows could never unify in the current context" -- Alfa (structural editor for Agda1) did that
16:45:17 <ski> type error slicing support would be nice to have
16:45:57 <Nevoic> I honestly think Idris is heading in a good direction. They understand the importance of tooling, and are emphasizing the importance of it early on.
16:46:23 <Nevoic> It took me a small fraction of the time to get idris-vim hooked up compared to all the HIE stuff I had to get for Haskell, because it was natively supported by the language developer(s?).
16:48:00 <jackdk> I found out the other day Edwin also did the esolang "whitespace". The world is small.
16:49:48 <ski> (Edwin as in the MIT Scheme Emacsen ? a "whitespace" mode for it ?)
16:50:16 <lavalike> jackdk: Brady
16:50:22 <jackdk> http://esolangs.org/wiki/Whitespace
16:50:24 <lavalike> *ski
16:50:53 <jgt> "Whitespace is an esoteric programming language developed by Edwin Brady and Chris Morris at the University of Durham"
16:51:01 <ski> lavalike : oh. ok
16:51:04 <jgt> I *wish* it were the other Chris Morris
16:51:08 <jgt> of IT Crowd fame
16:51:13 * ski has run into Whitespace before
16:51:35 <jackdk> I feel like there's a skifree joke in there somewhere
16:51:48 * ski is not free
16:52:03 <hpc> ski is a combinator calculus, so skifree would be... pointful?
16:52:11 <jgt> jackdk: this is the most obscure humour
16:52:12 <hpc> it must be, otherwise how would you get a high score
16:52:17 <lavalike> @free ski
16:52:19 <lambdabot> Extra stuff at end of line in retrieved type "error: Variable not in scope: ski\n"
16:52:25 * ski is not a calculus
16:52:38 <hpc> ski ne pass un calculus
16:53:29 <ski> see <http://lambda-the-ultimate.org/node/533#comment-7712>
16:54:33 <hpc> aha!
16:54:52 <hpc> that's a nice distinction
16:55:15 <hpc> i wonder what the "bound variables" are of actual calculus
16:55:25 <hpc> probably the things we take limits to or integrals over
16:56:04 <ski> or differentiate wrt
16:56:30 <ski> `d / d x' is a rebinder
17:16:50 * hackage scan-metadata 0.2.1.0 - Metadata types for Albedo Scanners  https://hackage.haskell.org/package/scan-metadata-0.2.1.0 (arbornetworks)
17:37:44 <xunsmdlo> Is it possible to check whether a number has all the same digits without lists? Just mod, div and pattern matching?
17:38:11 <dolio> Yes, it's possible.
17:38:32 <Axman6> More homework xunsmdlo?
17:39:33 * ski . o O ( `(0 ==)' )
18:01:38 <infinisil> I've given polysemy a test run now, and I gotta say, it's pretty nice
18:01:40 <infinisil> https://hackage.haskell.org/package/polysemy
18:03:16 <Axman6> yeah I have high hopes for it, hopefully his patch for GHC will make it in 
18:03:38 <Axman6> If it hasn’t alreadfy
18:05:21 <shachaf> whoa, you can press s on Hackage pages to search the entire package
18:05:40 <Axman6> for some packages yes
18:05:56 <Axman6> not sure what needs to be done to make that happen
18:10:17 <infinisil> Axman6: I think it did! https://gitlab.haskell.org/ghc/ghc/merge_requests/668
18:13:51 <infinisil> Very nice
18:17:02 <infinisil> Zero-cost abstractions, now in Haskell too!
18:17:41 <shachaf> There's no such thing as zero-cost abstractions.
18:18:05 <shachaf> If someone tells you something is free they're probably misling you.
18:21:14 <Nevoic> Are you saying there's no situation where a compiler could optimize code down to the Assembly equivalent, or that compile time is a cost?
18:21:34 <Nevoic> If the latter, then I agree, I think everyone would need to.
18:22:05 <shachaf> Compilation time is one cost. There are a lot of other costs too.
18:22:23 <Nevoic> That's obviously almost always true, but my question is it necessarily true?
18:22:34 <shachaf> If you're buying an abstraction -- or anything else -- you should know the cost and make an informed decision, rather than pretend it's free.
18:22:36 <Nevoic> Do you believe that there is literally no situation where the compiler could optimize away all costs (except compile time)?
18:22:45 <contrun[m]> How to set environment variable for `stack build`?  I use https://github.com/rikvdkleij/intellij-haskell to edit haskell source file, which requires stack. I have a package which requires me to `export PKG_CONFIG_PATH=/nix/store/lsilwdmbq0fg5l0972p405apnzh56j0z-libxml2-2.9.8-dev/lib/pkgconfig`. How can I automatically export this variable to make pkg-config works?
18:23:08 <shachaf> Your code being harder to understand and made of more pieces is also a cost.
18:23:45 <shachaf> And being locked into a particular way of doing things, such that what would be a small change without the abstraction is a big change, is definitely a cost.
18:24:07 <Nevoic> IMO you're reading too much into "zero-cost abstractions". You seem to be claiming that abstractions themselves have cost by nature. The statement isn't trying to claim that abstractions are always good, I think it's about runtime performance.
18:24:10 <shachaf> The abstraction might be worth the cost, of course.
18:24:28 <dolio> Code being hard to understand is a cost of not abstracting, too.
18:24:59 <shachaf> Yes. Abstractions have both costs and benefits.
18:25:18 <Nevoic> Agreed. I doubt (maybe I'm wrong) people who say "zero-cost abstractions" think that everything should always be abstracted.
18:25:32 <Nevoic> I've always read it as a runtime performance metric.
18:25:55 <shachaf> Compared to what?
18:26:07 <Nevoic> X. It's definitely a relative statement.
18:26:11 <winny> abstractions always have a cost
18:26:35 <winny> if not performance, it will still be cognitive
18:26:52 <Nevoic> "cost" is also relative. Something can be "free" in a monetary sense and not a moral/societal sense, but people would still advertise it as free.
18:27:00 <Nevoic> When people say "cost" it's in the context of a medium.
18:27:20 <Nevoic> If I see "buy one get one free" I don't contemplate the moral characteristics of not injecting more money into the business.
18:27:33 <winny> right, maybe they didn't mean in the context of mental overheat, but only in the context of performance, for example
18:27:42 <Nevoic> In the same light, when I see "zero cost abstractions" I don't think about the cost of abstractions in a mental capacity.
18:27:49 <Nevoic> I thought they were about runtime performance.
18:27:57 <Nevoic> Maybe other people view it differently, just trying to justify my way of thinking.
18:27:58 <Axman6> This is definitely not a zero-cost conversation
18:28:02 <shachaf> Even in the context of performance "zero-cost abstractions" usually have a cost.
18:28:22 <Nevoic> Well then I'd (again personally) disagree that they're truly zero-cost abstractions.
18:28:34 <shachaf> People compare the code generated by the compiler when you use the abstraction to you writing the same code that the compiler generates by hand.
18:28:41 <Nevoic> Like I asked originally, I'm curious as to if your position is that no piece of high level code can ever reach the efficiency of the most efficient assembly code.
18:29:05 <Nevoic> No matter how advanced the compiler (imagine a compiler with super human level intelligence).
18:29:21 <winny> Axman6: I had a giggle, thank you :)
18:29:46 <dolio> Why would you compare to the most efficient assembly? That's is almost certain not to be reachable.
18:29:48 <shachaf> Well, my original position is that you should consider all costs, not just which instructions get emitted into the executable.
18:29:59 <Nevoic> Sure, I agree with that.
18:30:02 <Axman6> Is Coercible a negative cost abstraction?
18:30:09 <Nevoic> I think our disagreement is largely semantics tbh.
18:30:12 <shachaf> I'm comparing to the code that you would write by hand.
18:31:41 <shachaf> If you have a metric on programs, or something, such that some programs are close and some programs are far, using abstractions changes that metric. That's more or less the point of abstractions.
18:32:38 <shachaf> Some things that might be pretty close without the abstraction might be very far with the abstraction, even if it generates the same code.
18:32:51 * hackage witherable 0.3.1 - filterable traversable  https://hackage.haskell.org/package/witherable-0.3.1 (FumiakiKinoshita)
18:32:59 <shachaf> Maybe it forces you into a particular memory layout, or something.
18:34:01 <Nevoic> On a side note, I generally don't care about memory/performance characteristics in a philosophical sense. I think that'll be one of the first pieces of our craft to go.
18:34:30 <Nevoic> I obviously care in a practical sense, humans still need to tell computers how to be effective, but soon enough we'll get real intelligence injected into these things.
18:34:43 <kadoban> What does "in a philosophical sense" mean there?
18:35:17 <Nevoic> I don't know how else to phrase it. Maybe at a high level?
18:35:36 <comet23> java is a functional language because it has lambdas
18:36:18 <Nevoic> It's the part of programming that I think will become obsolete first due to machine intelligence.
18:36:29 <kadoban> Not really sure what you mean then Nevoic . Can you give an example of what someone else might care about that you don't there?
18:37:05 <brool> java is a functional programming language because it has lambdas
18:37:25 <Nevoic> I think some people attach importance to humans being able to understand performance characteristics.
18:37:31 <Nevoic> I don't.
18:37:38 <Nevoic> I might be wrong about that.
18:38:17 <Nevoic> In isolation.
18:38:17 <Nevoic> Currently it's necessary to understand performance characteristics to make performance better.
18:38:34 <Nevoic> Once that's not the case, I'll stop caring about understanding why something is performant.
18:42:13 <comet23> brool: you're a bit late to the party
18:42:26 <comet23> where is the haskell chat log
18:42:35 <brool> ;~;
18:42:51 <ski> comet23 : see topic ?
18:42:57 <Nevoic> were you two looking to have a serious conversation about that, or did you just want to provoke people?
18:43:05 <comet23> no it's a serious topic
18:43:15 <comet23> java is a functional programming language because it has lambdas
18:43:22 <Nevoic> Do you define a functional language as a language with lambdas?
18:43:23 <kadoban> Nevoic: I don't see that coming about for quite a while myself. But ya I don't think I personally enjoy all that much thinking about performance in several situations. If it magically gets figured out for me I wouldn't mind.
18:43:24 <comet23> what part of that confuses you?
18:43:26 <jackdk> Fun fact: classic refactoring moves like "replace temp with query" are only possible in languages like java when your code is referentially-transparent: https://refactoring.com/catalog/replaceTempWithQuery.html
18:43:37 <comet23> yes, if you have lambdas you have a functional programming language
18:43:50 <Nevoic> Alright, I disagree with that definition. But if that's the definition that you use then you're necessarily right.
18:43:58 <comet23> lambdas are functional by definition
18:44:04 <Axman6> yeah that's a really terrible definition
18:44:11 <Nevoic> Agreed, but it's just semantics.
18:44:28 <Nevoic> If you want to align with other people in terms of word usage (to you know, communicate effectively) it'd be best to adopt everyone else's definition.
18:44:29 <Nevoic> But your call.
18:44:46 <comet23> what is someone who is against semantics called? an anti semite? would that mean that haskell is an anti semitic language?
18:44:56 <Axman6> C is a functional language because it has function pointers and structs, so you can make closures
18:45:06 <Nevoic> I'm sorry but I'm honestly doubting that you're here for a serious conversation lol
18:45:17 <comet23> sorry i'm drunk right now
18:45:21 <brool> but no function in C can see anything outside its own scope
18:45:30 <Nevoic> kadoban: Yeah, I mean here's to hoping lol
18:45:36 <Axman6> it can with void pointers!
18:45:44 <brool> show me this magic
18:45:57 * jackdk doesn't feel like gazing into the void* today
18:46:09 <Axman6> you can do anythning with void pointers, just look at Objective-C, EVERYTHING's a void pointer!
18:46:09 <comet23> i had too many beers
18:46:26 <brool> comet23: there are no such things as too-many beers
18:46:29 --- mode: ChanServ set +o shachaf
18:46:39 --- mode: shachaf set +b *!*uid302178@gateway/web/irccloud.com/x-shkzfxwbupsmfsvj
18:46:39 --- kick: comet23 was kicked by shachaf (comet23)
18:46:41 --- mode: shachaf set +b *!*grendel@2600:1700:7d20:ae60:2c68:fddb:7f86:*
18:46:41 --- kick: brool was kicked by shachaf (brool)
18:46:47 --- mode: shachaf set -o shachaf
18:47:03 <Axman6> :o
18:47:56 --- mode: ChanServ set +o glguy
18:47:57 --- mode: glguy set +bb-bb *!?id302178@gateway/web/irccloud.com/* *!*@2600:1700:7d20:ae60::/64 *!*uid302178@gateway/web/irccloud.com/x-shkzfxwbupsmfsvj *!*grendel@2600:1700:7d20:ae60:2c68:fddb:7f86:*
18:47:57 --- mode: glguy set -o glguy
18:48:22 <Nevoic> Sounds like Python lmao
19:07:27 <habbah> What is the process of using a package which requires an older version of aeson? I want to use a newer version
19:08:13 <glguy> Update the bounds in the package's .cabal file, see if it builds against the newer version, see if the tests still pass
19:08:44 <glguy> consult the changelog for the new aeson to see what changed to help debug any issues that arise
19:30:29 <habbah> glguy: How can I do that and specify the my version of this package in my own project?
19:32:08 <maerwald> habbah: you can clone the repository locally and tell cabal or stack to use that version
19:32:15 <glguy> You can add the updated source directory to your cabal.project's packages: section
19:35:39 <MarcelineVQ> the analogous thing to do is add the path to the modified lib to your extra-deps in your stack.yaml if that's what you're using
19:40:25 <qwebirc3425> hey all, I'm trying to install haskell on osx (10.14.5) and getting "checking whether the C compiler works... no". any tips, quick google didn't yield much... 
19:41:02 <qwebirc3425> (using ghcup)
19:43:15 <maerwald> qwebirc3425: you have a working C compiler?
19:43:42 <maerwald> GHC checks for gcc and clang during configuration
19:45:55 <qwebirc3425> yeah, have gcc installed.
19:46:10 <qwebirc3425> ➜  ~ gcc -v Configured with: --prefix=/Applications/Xcode-9.4.1.app/Contents/Developer/usr --with-gxx-include-dir=/Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/c++/4.2.1 Apple LLVM version 9.1.0 (clang-902.0.39.2) Target: x86_64-apple-darwin18.6.0 Thread model: posix InstalledDir: /Applications/Xcode-9.4.1.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin
19:46:32 <qwebirc3425> Installing GHC-8.6.5 for Darwin on architecture x86_64   % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                  Dload  Upload   Total   Spent    Left  Speed 100  151M  100  151M    0     0  8375k      0  0:00:18  0:00:18 --:--:-- 8528k checking build system type... x86_64-apple-darwin18.6.0 checking host system type... x86_64-apple-darwin18.6.0 checking target system type
19:46:57 <qwebirc3425> checking whether the C compiler works... no configure: error: in `/var/folders/zy/76qtlswd40x0vktbf_3f6z9w0000gp/T/tmp.41MwDPbU/ghc-8.6.5': configure: error: C compiler cannot create executables
19:47:05 <maerwald> please use pastebin for long pastes :o
19:47:05 <glguy> Paste bin
19:47:10 <qwebirc3425> ah, thx
19:47:20 <maerwald> ok so you have clang-4.2.1 it seems
19:48:16 <qwebirc3425> https://pastebin.com/ZrDvL3JM
19:48:32 <glguy> That's an old version of xcode, if your macOS version isn't similarly old it might not be a working C compiler
19:49:52 <maerwald> I wonder if gcc from homebrew works? But I'm not a mac user
19:51:13 <glguy> What version of macOS are you using? The C compiler installed by xcode works assuming everything is updated
19:51:44 <qwebirc3425> Mojave (10.14.5)
19:51:57 <qwebirc3425> trying to upgrade xcode...
19:51:59 <MarcelineVQ> iirc this is due to a problem in how the ghc configuration script parses the c compiler versions
19:52:20 * hackage pencil 1.0.1 - Static site generator  https://hackage.haskell.org/package/pencil-1.0.1 (elben)
19:52:36 <MarcelineVQ> dunno myself, merijn knows the issue better but isn't here atm
19:52:57 <maerwald> MarcelineVQ: is there a ticket for it?
19:53:38 <MarcelineVQ> suposedly but I haven't seen it myself
19:54:59 <maerwald> https://phabricator.haskell.org/D4069 blergh
20:11:00 <qwebirc3425> upgrading to new xcode version did the trick (funny thing is I actually had to open xcode to complete upgrade otherwise no go). thx!! :)
20:33:43 <MarcelineVQ> qwebirc3425: good to know that works, in case another person comes in with the problem
20:38:15 <maerwald> could add a troubleshooting section in the readme
20:46:47 <xunsmdlo> why am I getting a parse error? 
20:46:50 <xunsmdlo> pairdistance :: [Integer] -> [Integer]
20:46:50 <xunsmdlo> pairdistance y:[] = []
20:46:50 <xunsmdlo> pairdistance x:y:ys = (distance x y) : pairdistance y:ys
20:48:00 <eckt[m]> use pairdistance [y] = [] or pairdistance (y:[])
20:48:08 <ski> `pairdistance y:[]' is parsed as `(pairdistance y):[]'
20:48:54 <ski> similarly `pairdistance x:y:ys' is parsed as `(pairdistance x):(y:ys)', and `pairdistance y:ys' is parsed as `(pairdistance y):ys'
20:49:09 <ski> `[y]' is shorthand for `y:[]', yes
20:49:12 <habbah> Is this the only way to install local packages with cabal? https://www.haskell.org/cabal/users-guide/installing-packages.html#secure-local-repositories
20:49:24 <xunsmdlo> the last line also generates a parsing error
20:49:36 <xunsmdlo> ah, ok
20:50:14 <ski> also, the brackets around the call to `distance' are redundant
20:51:10 <MarcelineVQ> habbah: no, https://www.haskell.org/cabal/users-guide/nix-local-build.html#specifying-the-local-packages is the option glguy suggested earlier
20:53:04 <habbah> Thank you MarcelineVQ 
20:54:58 <MarcelineVQ> There's other options too but above is the modern one
21:00:30 <xunsmdlo> If I want to match the pattern of a list of tuples, can I use the pattern ((x,y):(x,y)s) instead of x:xs?
21:03:09 <ski> xunsmdlo : you can do `(x,y):xys'
21:03:30 <xunsmdlo> great thanks
21:03:31 <ski> xunsmdlo : but `xys' is a list (of pairs). not a pair (of lists)
21:04:09 <ski> if you really want to get a pair of lists, you could use `(x,y):(unzip -> (xs,ys))' -- using the `ViewPatterns' language extension
21:04:25 <ski> but quite possibly just getting the list of pairs `xys' is all you need
21:05:26 <ski> (in fact, even the pattern `(unzip -> (x:xs,y:ys))' would work there)
21:05:36 <xunsmdlo> the examiner won't let us use anything we don't define ourselves
21:05:55 <ski> well, i suppose you could define `unzip' ..
21:06:00 <MarcelineVQ> When someone's confused about whether the two 'x' letters in "x:xs" are the same thing, mentining ViewPatterns is a bit of a leap ^^;
21:06:27 <ski> > [(p,p^2) | p <- [2,3,5,7]]
21:06:30 <lambdabot>  [(2,4),(3,9),(5,25),(7,49)]
21:06:31 <ski> > unzip [(p,p^2) | p <- [2,3,5,7]]
21:06:33 <lambdabot>  ([2,3,5,7],[4,9,25,49])
21:06:43 <ski> that shows what `unzip' does
21:06:52 <ski> MarcelineVQ : i suppose :)
21:09:18 <MarcelineVQ> Though I see now the interpretation of the question that lead to your answer so I could be the wrong one :>
21:09:27 <ski> (i suppose in `syntax-rules' patterns in Scheme, one could use `((?x ?y) (?xs ?ys) ...)' (with a literal ellipsis `...' in there, yes). then `?xs' and `?ys' would become lists ("plurals"))
21:10:37 * ski tends to err on the side of giving people enough rope to hang themselves with, while trying to explain why they normally should think twice before attempting to use it
21:12:16 <xunsmdlo> transform (x:y:ys) | fst x == fst y = (x,(snd x + snd y)):ys
21:12:21 * hackage polysemy 0.2.2.0 - Higher-order, low-boilerplate, zero-cost free monads.  https://hackage.haskell.org/package/polysemy-0.2.2.0 (isovector)
21:13:07 <xunsmdlo> why do I get a type error :ys ?
21:13:26 <ski> xunsmdlo : please match on the pairs, rather than using `fst' and `snd'
21:13:55 <ski> the error is probably because you used `x' rather than `fst x'
21:13:59 <Axman6> Are there any higher operformance ways to implement a concurrent counter than something like TVar Int? looking for something which can be incremented by one thread, decremented by many other threads, and can be waited on until it's zero by the first thread
21:16:44 <xunsmdlo> ski : thanks, solved it
21:19:12 <dmwit> xunsmdlo: You might also like:
21:19:19 <dmwit> :t M.fromListWith (+)
21:19:20 <lambdabot> (Num a, Ord k) => [(k, a)] -> M.Map k a
21:19:30 <ski> Axman6 : i suppose you've already considered `QSem',`QSemN',`TSem' ?
21:19:43 <MarcelineVQ> Axman6: some options explored here https://codeburst.io/the-haskell-concurrency-primitive-shootout-538c21993f1c
21:20:25 <Axman6> I don't know what the maximum count will be so QSem probably isn't what I'm after
21:20:34 <Axman6> MarcelineVQ: ta, I'll take a look
21:21:04 <Axman6> though, these threads are also going to be doing a lot of IO so my counter is hardly foing to be my bottleneck :)
21:21:09 <Axman6> going*
21:29:13 <Axman6> MarcelineVQ: really odd results in there!
21:29:22 <MarcelineVQ> interesting yeah?
21:29:36 <Axman6> indeed. concurrency primitives are tricky
21:30:16 <Axman6> I'd use atomic counter if it were easy to wait for it to be zero
21:30:21 <MarcelineVQ> contention especially mucks with numbers, you might have to do your own testing :(
21:31:11 <Axman6> I was going to just do a quick atomically $ readTVar >>= \x -> when (x > 0) retry
21:38:10 <snkx> Do you guys use stack?
21:38:56 <snkx> I used to write one off haskell programs pretty comfortably 
21:39:06 <snkx> But I can't get the hang of stack
21:39:47 <snkx> All my editors freeze when trying to spawn ghci (intero)
21:40:09 <slack1256> if stack doesn't work for you, you can use cabal 
21:40:33 <Axman6> I write one off tools with stack all the time
21:40:47 <Axman6> using VS Code and haskell-ide-engine works quite well
21:42:54 <snkx> Earlier my setup was pretty simple, just a text editor and a ghci. I can't seem to get the hang of stack, but I gotta learn it. Thanks. I will try vs-code too 
21:43:57 <snkx> I think stack is slow for the first time
21:44:47 <snkx> But once the project is built and all the toolchain is fetched, its fine
21:44:51 <Axman6> most tools need you to have built your code to do all the nice IRE-y things
21:46:22 <snkx> My compulsion is two fold. 1) I am stuck with a very old university issued laptop with 4Gigs of RAM, and for some reasons I have to stick with Windows 
21:47:23 <snkx> Setting up haskell toolchain makes my laptop die a little :)
21:47:50 <Axman6> :'(
21:48:37 <snkx> Another issue is that we get limited amount of internet data per day
21:48:47 <snkx> So we have to check how much we download
21:53:00 <habbah> I put packages: Cabal /local/path/to/project/project.cabal in my cabal file. How do I know it's using that package? I upgraded the version of aeson I'd like to use in the other project and got it to compile with v2-build, but I still get messages saying the package I want to use requires an earlier version 
22:09:09 <habbah> I had the package in build-depends as well. That was the problem
22:12:37 <habbah> Well actually, if I remove it from build-depends, then I don't have access to the local package.
22:18:47 <habbah> Okay, moving the package into my own project and putting packages: Cabal project/ in my cabal file did the trick
22:55:29 <dminuoso> habbah: Are you using a gitspec in your project.cabal file?
23:16:20 * hackage yam 0.6.2 - A wrapper of servant  https://hackage.haskell.org/package/yam-0.6.2 (leptonyu)
23:17:20 * hackage yam-datasource 0.6.2 - Yam DataSource Middleware  https://hackage.haskell.org/package/yam-datasource-0.6.2 (leptonyu)
23:19:21 * hackage yam-redis 0.6.2 - Yam Redis Middleware  https://hackage.haskell.org/package/yam-redis-0.6.2 (leptonyu)
23:28:20 * hackage yam-datasource 0.6.3 - Yam DataSource Middleware  https://hackage.haskell.org/package/yam-datasource-0.6.3 (leptonyu)
23:29:20 * hackage yam 0.6.3 - A wrapper of servant  https://hackage.haskell.org/package/yam-0.6.3 (leptonyu)
23:30:20 * hackage yam-redis 0.6.3 - Yam Redis Middleware  https://hackage.haskell.org/package/yam-redis-0.6.3 (leptonyu)
23:37:44 <bahamas> sanity check. the error "gradle: readCreateProcess: runInteractiveProcess: exec: does not exist (No such file or directory)" means that cabal is trying to call `gradle`, but fails because it can't find the executable, right?
23:38:09 <jgt> that's right
23:43:46 <dminuoso> Cale: It seems that person is doing this across multiple channels, concurrently..
23:50:49 <xunsmdlo> Couldn't match expected type ‘Integer’ with actual type ‘Int’
23:50:50 <xunsmdlo>       In the expression: [(x, length (collatz [x])) | x <- [1 .. n]]
23:51:09 <xunsmdlo> Why did that happen? What's the difference between Integer and Int?
23:51:28 <ski> `Int' is bounded, `Integer' is unbounded
23:51:52 <xunsmdlo> countcollatz :: Integer -> [(Integer, Integer)]
23:51:56 <ski> presumably you're using the second components of the pairs of that list somewhere, at type `Integer'
23:51:56 <xunsmdlo> that's the signature
23:52:05 <bahamas> jgt: thanks!
23:52:08 <ski> yea, that counts as a use
23:52:29 <jgt> xunsmdlo: maybe you could use a typeclass constraint instead of a concrete type
23:52:33 <ski> use `fromIntegral' to convert, or use `genericLength' instead
23:52:33 <xunsmdlo> isn't Integer more general than Int?
23:52:37 <MarcelineVQ> :t length
23:52:39 <lambdabot> Foldable t => t a -> Int
23:52:46 <xunsmdlo> ah, I see
23:52:50 <ski> there are no implicit coercions between numeric types, in Haskell
23:54:38 <ski> (otoh, numeric literals are overloaded ("constrained polymorphic", just like the numeric operations). so if you write `2' that can be of type `Int',`Integer',`Rational',`Double',`Complex Double',&c. .. whatever is expected by the context. similarly if you write `2.3', except then it can't be integer types like `Int',`Integer')
23:55:20 * hackage serverless-haskell 0.8.8 - Deploying Haskell code onto AWS Lambda using Serverless  https://hackage.haskell.org/package/serverless-haskell-0.8.8 (AlexeyKotlyarov)
23:56:04 <ski> > 2.3 :: Rational
23:56:07 <lambdabot>  23 % 10
23:56:11 <ski> > 2.3 :: Complex Double
23:56:14 <lambdabot>  2.3 :+ 0.0
23:56:22 <ski> > 2.3 :: Complex Rational
23:56:25 <lambdabot>  error:
23:56:25 <lambdabot>      • No instance for (RealFloat (Ratio Integer))
23:56:25 <lambdabot>          arising from the literal ‘2.3’
23:56:31 <ski> heh
23:58:40 <xunsmdlo> which function finds member of a list of tuples with maximum snd component?
23:59:42 <Axman6> I'm sure your lecturer has provided you with the materials which have the answer. We are not here to do your homework xunsmdlo
