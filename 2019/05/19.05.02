00:36:17 * hackage cache 0.1.1.2 - An in-memory key/value store with expiration support  https://hackage.haskell.org/package/cache-0.1.1.2 (hverr)
01:03:47 * hackage fast-builder 0.1.0.1 - Fast ByteString Builder  https://hackage.haskell.org/package/fast-builder-0.1.0.1 (AkioTakano)
01:09:40 <dcoutts> shapr: email admin@hackage.haskell.org for password resets
01:11:08 <merijn> #ghc is kinda quiet, so does anyone here know where I can find the CI generated bindists? I recall they exist, but no idea where
01:20:23 <maerwald> merijn: https://downloads.haskell.org/~ghc/ these
01:20:24 <maerwald> ?
01:20:53 <merijn> maerwald: No, those I know how to find, but the CentOS bindist is missing
01:21:15 <maerwald> Yeah, not sure that one is auto generated
01:21:22 <merijn> I know the CI automatically creates bindists now on gitlab, because I downloaded a GHC bindist from there like...2 months ago
01:21:24 <maerwald> bsd is also missing occasionally
01:21:41 <merijn> I just for the live of me can't remember where to find those
01:21:50 <merijn> s/live/life
01:23:38 <merijn> bleh...that's what I get for wanting to upgrade GHC before being forced too >.>
01:46:17 * hackage filelock 0.1.1.3 - Portable interface to file locking (flock / LockFileEx)  https://hackage.haskell.org/package/filelock-0.1.1.3 (AkioTakano)
01:58:17 * hackage fay-base 0.21.1.1 - The base package for Fay.  https://hackage.haskell.org/package/fay-base-0.21.1.1 (swamp_agr)
01:59:39 * merijn resets the "It has been N days since I was last screwed by someone not setting an upperbound on a package" sign back to 0
02:00:25 <phadej> oh, that was actually me releasing new major version :)
02:00:37 <merijn> phadej: I know, I just noticed :p
02:00:58 <merijn> Should be a simple revision on data-interval, though
02:03:45 <__monty__> merijn: I think you may be able to figure it out from here: "https://gitlab.haskell.org/${fork}/ghc/-/jobs/artifacts/${branch}/raw/${config.tarball}?job=${config.job}"
02:04:02 <merijn> __monty__: mpickering just pointed me to the right place :)
02:05:00 <__monty__> Ah. This was based on his artefact-nix so props go to him anyways.
02:05:26 <phadej> merijn: please open an issue to the authors issue tracker; I'll review the packages; but as it affects latter versions it would be good to notify the author (and make the PR fixing those, so it won't regress)
02:05:41 <mpickering> I am the only one capable of navigating gitlab
02:06:41 <merijn> phadej: I'll open an issue, but given the last update is from 2013 I'm not sure how likely a reaction is :)
02:07:03 <phadej> merijn: you never know; and if one wants lattice-2 support...
02:28:21 <__monty__> mpickering: Consider yourself our designated gitlab driver from now on ; )
02:38:29 <chillitom> Any good place to find Haskell remote work?
02:39:42 <Taneb> chillitom: maybe have a look at https://github.com/erkmos/haskell-companies ? It lists a lot of companies using Haskell and whether they allow remote work
02:55:00 <tdammers> chillitom: best way IMO is to immerse yourself in the community and keep your ears open
02:55:54 <merijn> haskell-cafe mailing list and haskell subreddit have job postings semi frequently
02:57:17 <tdammers> ^ this. also, meetups and events like zurihac and such. even if there are no suitable job offers being made right there and then, just the networking is usually worth it
02:58:00 <merijn> Time for the world's hardest problem: Naming things! So, suppose I have a function foo that returns an Either/Maybe/etc. to signal error, how would you name a variant that throws an exception?
02:58:05 <maerwald> remote is hard when it's your first time using the language professionally
02:59:42 <tdammers> maerwald: doesn't have to be. it is if the place isn't heavily biased towards remote workers already, but if it's a remote-only or remote-first environment, then it shouldn't be a big issue
03:22:38 <Chris___> does anyone know how the x-axis of a heap profile works? It’s not as simple as execution time; I found this but I’m a bit confused about what it’s trying to explain: https://mail.haskell.org/pipermail/ghc-devs/2014-December/007748.html
03:26:31 <dminuoso> Chris___: Perhaps its just wall clock vs cpu time confusion?
03:27:47 <dminuoso> Chris___: Do you know the difference between those two?
03:30:08 <dminuoso> Chris___: First there's preemption/implicit yields, your program might be sleeping for some time to give other processes some CPU time. The actual time spent in your program is much less than the "wall clock time" (the time you measure looking at a fictional clock, say hanging at the wall)
03:30:25 <dminuoso> Then there's differentiation between how much time is spent inside user code, and how mich is spend inside kernel code (for syscalls)
03:46:45 <merijn> Let's try again: Time for the world's hardest problem: Naming things! So, suppose I have a function foo that returns an Either/Maybe/etc. to signal error, how would you name a variant that throws an exception?
03:48:30 <Solonarv> I'd just stick a 'Throw' at the end of the name
03:49:13 <merijn> Solonarv: That was my initial thought, but I'm not quite sold on it :\
03:50:22 <Taneb> Hmm, I'm a little surprised there's no function "Exception e => Either e a -> IO a"
03:51:05 <merijn> Taneb: Fairbairn threshold
03:51:25 <merijn> That's just "either throwIO return"
03:51:48 <Taneb> merijn: and your thing is just "either throwIO return . foo", right?
03:52:44 <merijn> Taneb: Sure, but I use the throwing version more than the non-throwing one
03:53:19 <Taneb> Ah, liftEither in mtl
03:53:51 <merijn> That lifts to MonadError, not throwIO, though
03:54:08 <Taneb> MonadExcept, which has an instance for IO (if you have IOException)
03:54:21 <Solonarv> if you use the throwing version more, you could also consider using the "plain" name for that and tacking an Either/Maybe suffix on the name of the non-throwing one
03:54:21 <Taneb> No, MonadError
03:54:27 <Taneb> You're right
03:54:54 <merijn> Solonarv: Then I'd have to think of a name for the non-throwing one, so the problem is still there :p
03:55:05 <Taneb> fooEither
03:55:10 <Solonarv> yes
03:55:14 <Solonarv> that was my suggestion
03:55:48 <Solonarv> foo       :: blah -> IO whatever -- throws FooError
03:55:48 <Solonarv> fooEither :: blah -> IO (Either FooError whatever)
04:07:06 <tdammers_> ^ much in favor of this flavor
04:09:35 <merijn> tdammers_: I normally prefer non-throwing as default name (because I think APIs should encourage explicit error handling), but in this case it's obscure, internal and only for me anyway, so I'll go that way
04:15:48 <Solonarv> I recommended this way of doing it purely because you said you use the throwing version more often :>
04:16:00 <Logio> merijn: so you don't want to encourage yourself to do explicit error handling?
04:16:24 <merijn> Logio: explicit error handling with Either is important in APIs where code/logic may want to work around them
04:16:41 <merijn> Inside executables you often just want to exit with an error message
04:17:03 <merijn> Logio: Either is good for the former, but exceptions are good for the latter
04:20:07 <Logio> Exiting with an error message is orthogonal to the error handling that precedes it, though
04:20:40 <merijn> Logio: My point is that in executables, 90% of the time I *don't* (want to) handle errors, because there is no way to recover
04:20:59 <merijn> Logio: Littering my logic with either unwrapping everywhere only to throwIO right after is pointless
04:21:41 <merijn> Library APIs *should* use Either everywhere so they can leave it up to users to decide whether to throw or not (or alternatively, libraries should provide both versions)
04:25:03 <hoppfull> Hello! in this line: "class Comonad w => ComonadStore s w | w -> s where", what does this syntax mean: "| w -> s"? Is it that the constructor requires a function (w -> s)?
04:25:38 <Solonarv> not at all
04:25:51 <Solonarv> this is a functional dependency; you can read it as "w determines s"
04:26:02 <hoppfull> hmm okay?
04:26:21 <hoppfull> so if w is M a, then s is a or something?
04:26:38 <[exa]> hoppfull: 's' argument is completely determined by value of 'w'
04:26:42 <Solonarv> it's a restriction on what kinds of instances you're allowed to write: specifically, it means you're not allowed to write instances with the same w but different s
04:26:57 <[exa]> hoppfull: so your example is basically right, though not as generic
04:27:10 <hoppfull> So it means they're not allowed to be the same?
04:27:27 <hoppfull> Could it mean other things?
04:28:03 <Solonarv> the idea is that as soon as you (or the typechecker) has figured out what 'w' should be, it can use the available instances to figure out what 's' should be
04:28:15 <hoppfull> aha
04:28:15 <Solonarv> even if 's' is otherwise completely unknown so far
04:28:21 <hoppfull> okay cool
04:28:35 <hoppfull> "w determines s" makes more sense
04:28:37 <hoppfull> now
04:28:40 <hoppfull> thanks!
04:29:58 <hoppfull> Could you write "a -> b && c -> d" or "a -> b -> c"?
04:30:31 <[exa]> it has a documentation somewhere
04:32:54 <[exa]> hoppfull: ah here: https://downloads.haskell.org/%7Eghc/latest/docs/html/users_guide/glasgow_exts.html#functional-dependencies
04:35:51 <Logio> merijn: sure, but you are talking about a special case of application where exiting at any point without further error handling is possible
04:35:52 <hoppfull> [exa]: thanks, my dude! :)
04:36:12 <Logio> considering resources in use etc.
04:36:19 <merijn> Logio: That "special case" covers like 80-90% of my application code
04:36:43 <merijn> Logio: I think having to do extra error handling *is* the special case
04:36:55 <Logio> just remember that kids might be watching you code and follow your example :)
04:37:30 <Solonarv> Logio: if you use bracket and bracket-like functions (withFile etc) you should get cleanup on exception "for free" anyway
04:37:38 <merijn> ^^^ that
04:37:46 <Logio> that's true
04:38:01 <tdammers_> exiting without error handling is *always* possible. it's called "crashing"
04:38:07 <Solonarv> and since you might get an exception tossed at you at any point you should already be using those functions
04:39:13 <Logio> but also I would argue that doing proper handling of Eithers shoudn't incur a penalty if the API is sensible
04:39:47 <merijn> "shouldn't incur a penalty" <- define penalty
04:40:15 <Logio> merijn: your point about littering the code with either unwrapping
04:40:35 <Logio> as defined by you as the reason to use exceptions
04:40:51 <merijn> Logio: So instead of unwrapping either I'd do...what exactly?
04:41:55 <Logio> merijn: I'm not making a point that you specifically should do something differently
04:44:04 <Logio> I'm claiming that if exceptions everywhere are easier than handling errors using pure code, it's a problem in general
04:47:11 <merijn> This seems like a kinda pointless discussion. I said "exceptions are very easy when writing executables where you don't handle errors" and somehow were arguing some strawman argument about "exceptions everywhere instead of pure code is bad" which isn't remotely related to the initial question/discussion
04:53:29 <Logio> to be fair, you brought up the general topic of exception vs Either, I was just wondering if you make exceptions for yourself w.r.t. APIs encouraging good practice
04:53:55 <merijn> Logio: I always implement both throwing and non-throwing versions, hence the question
04:54:16 <merijn> (But normally my API is more elaborate so I just keep identical names but in different modules)
05:17:14 <enoq> hi guys, it's easy to group a list into different buckets by having a grouping criterium, but is there a good way to group things by adjacency?
05:17:25 <enoq> I want to group week days with the same opening hours together
05:18:50 <Clint> enoq: groupBy?
05:18:50 <hoppfull> enoq: Could you sort them by opening hours?
05:18:57 <enoq> e.g. Monday: 09:00-12:00, Tuesday: 09:00-12:00, Wednesday: 10:00-11:00, Thursday: 09:00-12:00 should become Monday-Tuesday: 09:00-12:00, Wednesday: 10:00-11:00, Thursday: 09:00-12:00
05:19:24 <enoq> Clint: doesnt work since only adjacent groups of days are grouped together
05:19:31 <Clint> that's why hoppfull asked about sorting
05:20:22 <enoq> Clint: I don't see how sorting should help here
05:20:34 <Clint> it would make them adjacent
05:20:44 <enoq> they already are
05:20:52 <enoq> the list is ordered by day of week
05:21:14 <Clint> so order them by opening hours, group them, and then reorder them
05:22:04 <enoq> how do you group them?
05:22:12 <Solonarv> groupBy only groups together things that are already adjacent which seems to be what you want
05:22:36 <hoppfull> If you want to get a given order back, pair your items with indices from 0 .. n, then sort by the the original value and then sort by your index.
05:22:50 <hoppfull> ... to get back your original order.
05:23:09 <enoq> Solonarv: sounds great, how would one go about implementing this on your own?
05:23:32 <enoq> nvm, will take a look at the source
05:25:43 <enoq> always amazing how people use single characters as variable names in haskell code
05:31:38 <delYsid`> bindings, haskell has no variables :-)
05:32:09 <merijn> delYsid`: Yes it does...unless we're going to throw out several centuries worth of math terminology...
05:32:50 <delYsid`> oh, right.  I was thinking in terms of C.
05:33:20 <delYsid`> Still, talking about variables in a immutable context is a bit strange at least.
05:34:20 <tdammers_> "constants are variables, too!"
05:34:39 <tdammers_> seriously though, they're variables alright - C kind of butchered the concept, along with "function"
05:34:49 <merijn> delYsid`: They're called variables because in different contexts they have different values
05:35:12 <merijn> They're called variables because they "vary across usage contexts" rather than C's weird notion of "varies across time"
05:35:38 <tdammers_> well, "point in time" usually qualifies a usage context too
06:02:56 <dmwit> enoq: How to group similar items in a list? https://stackoverflow.com/q/12398458/791604
06:03:39 <enoq> thanks
06:33:59 <Axman6> what's the most up to date was to make a library for binding to a C library these days?
06:35:01 <Axman6> I haven't kept track of what all the packages which aim to make it simpler. Ideally something I can point at a .h file and generate a lot of the boilerplate would be good
06:40:37 <Axman6> Looks like inline-c is a pretty modern and powerful way to do it
06:44:53 <JappleAck> Axman6: i believe you don't have any libraries to do so
06:46:03 <JappleAck> Foreign.Storable and Foreign.C are both from "base" package
06:46:30 <JappleAck> and ForeignFunctionInterface is built-in ghc extension
06:46:40 <Solonarv> it's part of the Haskell2010 standard, even
06:46:49 <Axman6> sure, but there are several packages for making working with the FFI easier
06:48:02 <JappleAck> Axman6: you may look at X11 and/or gtk3 packages for example, to see how it's done
06:48:53 <elvishjerricco> Does forkOS always create a new OS thread? With -N2, can you only forkOS once, or will it happily make more threads than the -N<n> argument?
06:49:00 <JappleAck> Axman6: i believe inline-c is not for that purpose. it's for.. well.. for inlining some c-code
06:49:29 <Axman6> that's specifically one of the usecases for inline-c
06:55:21 <JappleAck> elvishjerricco: i believe forkOS is almost the same as forkIO except some details about calling FFI code
06:56:22 <elvishjerricco> JappleAck: forkOS creates a thread that will always be scheduled on the same OS thread; and C FFI calls will be called on that thread as well.
06:56:47 <elvishjerricco> But I don't know if multiple threads can be bound to the same OS thread, or if forkOS makes new OS threads for the new bound thread
06:57:30 <Axman6> I can't remember what the difference between forkOnIO and forkOS is, though I'm sure parallel and concurrent programming in haskell has the answer
06:59:22 <Axman6> https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/ specifically https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/ch15.html#sec_conc-ffi
06:59:33 <Axman6> search for forkOS
07:00:17 <Axman6> "Care should be taken when calling forkOS; it creates a complete new OS thread, so it can be quite expensive."
07:01:30 <matsurago> wow, that wasn't in my Queue.
07:02:05 <Axman6> if you care about parallelism or concurrency at all, it should be, it's a really fantastic book
07:02:21 <c_wraith> I was under the impression forkOS has no such requirement
07:03:15 <c_wraith> Maybe that's just theoretically
07:04:15 <elvishjerricco> Axman6: Well the question is if it ALWAYS makes a new OS thread, or if it can bind to an existing capability
07:04:40 <c_wraith> it always uses an existing capability
07:04:52 <c_wraith> the extra OS thread is only used for making FFI calls
07:05:34 <elvishjerricco> c_wraith: So, with -N4, no more than 4 bound threads can be making FFI calls at one time?
07:05:54 <c_wraith> no, that sets the number of capabilities, not the size of the FFI pool
07:07:10 <c_wraith> when a (haskell) thread is making a (safe) FFI call, it gives up the capability that was running it.
07:38:17 <elvishjerricco> c_wraith: Still not quite following... A bound thread must always run on the same OS thread, including its FFI calls. So if bound threads are bound only to the same capabilities that other Haskell threads might use (which is limited by -N<n>), then n limits the number of bound threads that can be doing FFI at once
07:38:48 <c_wraith> a bound thread only needs to always run its FFI calls from the same thread.  There is no requirement that haskell code always run on the same thread.
07:39:01 <elvishjerricco> ah sure
07:39:03 <elvishjerricco> still, same effect
07:39:10 <elvishjerricco> oh
07:39:22 <elvishjerricco> no, you're saying the FFI calls are on a different pool of threads
07:39:29 <elvishjerricco> is that right?
07:39:45 <c_wraith> safe FFI calls are always on a separate pool, regardless of bound or not
07:40:02 <c_wraith> I'm not actually sure how unsafe FFI calls and bound threads interact
07:40:35 <elvishjerricco> for my curiosity's sake, how to unbound threads and unsafe FFI calls work?
07:40:47 <elvishjerricco> they just do the FFI immediately on the haskell capability?
07:40:49 <c_wraith> yes
07:40:54 <elvishjerricco> cool
07:41:08 <c_wraith> with all the side effects implied...  they can block all sorts of things if they don't return promptly
07:41:22 <elvishjerricco> Anyway, is the thread pool for FFI calls unbounded?
07:41:30 <elvishjerricco> in size, that is
07:41:45 <elvishjerricco> i.e. can there be arbitrarily many concurrent FFI calls?
07:42:14 <c_wraith> I don't think it's unbounded.  That could get ridiculous.
07:42:42 <c_wraith> I don't know how it is bounded, though.  Maybe it's a function of -N after all
07:43:30 <elvishjerricco> And this is all why Haskell's C FFI is known for being slow, I'm guessing? it has to notify another thread to do FFI, and schedule the haskell thread to start again when that FFI thread finishes?
07:46:15 <c_wraith> No, the main reason Haskell FFI is considered slow is that it crosses memory management systems and the contract of memory use is very different between C and Haskell, and that means doing it correctly requires copying arguments and return values
07:47:08 <elvishjerricco> That cost seems smaller than the cost of switching threads entirely
07:49:47 <c_wraith> switching threads is really not that expensive.  Copying a Haskell String to a C char* is a *lot* of work
08:01:23 <hyperisco> came to a realisation… layout primitives in GUIs are really an EDSL for computing the absolute position of elements
08:04:25 <hyperisco> particularly apparent because you first build up some layout structure, then at once all the positions are calculated
08:04:49 <hyperisco> as opposed to calculating a position, then adjusting it, then adjusting it again, and so forth
08:09:51 <elvishjerricco> hyperisco: I'm sure it gets more complicated than that in animated layouts
08:10:18 <hyperisco> mm, no, time just adds another dimension to it
08:10:53 <monochrom> The main point is you have an EDSL whether by design or by accident. (So better make it by design.)
08:10:55 <elvishjerricco> hyperisco: Not if you want to do it efficiently
08:11:14 <hyperisco> this is the efficient method
08:11:36 <elvishjerricco> redrawing the entire layout to its raster image every frame is wasteful. Need to be able to track the differences and change them incrementally for animation to be efficient
08:11:52 <elvishjerricco> otherwise you end up with the same inefficiencies of the original FRP formulation
08:12:05 <elvishjerricco> (that's what made push/pull so important; it made changes incremental)
08:12:08 <hyperisco> we're talking about different things
08:12:50 <elvishjerricco> How so? An animation is just a layout over time.
08:14:47 <hyperisco> the basic idea is that instead of committing a step, then another step, then another step, we defer some work, by constructing data
08:15:07 <hyperisco> this data then is interpreted later, where the work is done
08:15:21 <fen_> cant you use a Store for that? 
08:15:34 <fen_> just composing the actions using (.)
08:15:54 <hyperisco> and by doing so smartly, less work may have to be done overall, because you can inspect the data to get the bigger picture, to see what is coming next
08:16:25 <fen_> but applying id is not slow...
08:16:59 <fen_> you only need to store the places where its not id though... so thats faster?
08:17:00 <elvishjerricco> hyperisco: I don't really follow. What data is constructed? How is it interpreted?
08:17:26 <hyperisco> depends on the GUI implementation, but for web it is DOM
08:17:33 <jgt> how should I reduce a list of sets into a single set?
08:17:37 <fen_> you have like a (Int,Int) -> Colour right?
08:17:47 <jgt> should I just use foldl'/foldr?
08:17:53 <hyperisco> or we can take the perspective of HTML + CSS
08:18:14 <delYsid`> jgt: fold
08:18:26 <fen_> so then the changes are for each different (Int,Int)
08:18:35 <fen_> :t fold
08:18:36 <lambdabot> (Monoid m, Foldable t) => t m -> m
08:19:05 <dmwit> jgt: Guess it depends on how you want to reduce them.
08:19:21 <hyperisco> one can express how items should flow in a flex box, but that does not fully decide the final absolute positions of the elements in that flex box, as the whole flex box can be positioned
08:19:22 <dmwit> (Union and intersection seem likely choices, but I could imagine others.)
08:19:28 <jgt> delYsid`: specifically `fold`? Or just one of the fold functions?
08:19:39 <fen_> have managed to write [* ~> *] -> (* -> *) more or less...
08:20:01 <delYsid`> jgt: If you want to use the Monoid instance of your Set, I'd use fold.
08:20:06 <hyperisco> from an implementation perspective, we can calculate all the positions of the items in the flex box, then when we move the flex box we can then move all the items inside
08:20:15 <fen_> but you have to fold the symbols onto an Undefined type, and then unfold them into a Nested datatype!
08:20:32 <dmwit> :t S.unions -- jgt
08:20:32 <fen_> its a total hack, adding then discarding the Undefined
08:20:33 <lambdabot> Ord a => [S.Set a] -> S.Set a
08:20:47 <elvishjerricco> hyperisco: Yea but my point is that the browser wouldn't do that simply by re-evaluating the positions of everything in the layout when the position of one part changes; it has to track a lot more information to change only what's relevant
08:21:13 <hyperisco> *or* we can defer this, so that first we figure out where the parent is positioned, then we can calculate the absolute position of items together with their relative placement in the flex box all at once
08:22:09 <fen_> isnt the real issue that you need to get the pixels for each frame?
08:22:11 <hyperisco> so it is, in other words, whether we know the parent's offset at the time we calculate the children's positions, or not
08:22:29 <jgt> Oh wow, that's great! The saves me implementing the folding function manually. Thanks delYsid`, dmwit!
08:22:31 <hyperisco> if you do it eagerly then you do not, but if you defer the work then you do
08:22:40 <fen_> like, there is no option of just leaving the pixels on the screen, the raster call refreshes every pixel
08:22:53 <hyperisco> and that in a lot of ways resembles how EDSLs look
08:24:00 <hyperisco> constructing data to represent what you want is a way to defer work
08:24:21 <fen_> you could only use this way of only referring to the updated subset if you had a call which just took a subset, but we dont
08:27:06 <hyperisco> it is the more efficient method because it reduces from O(n^2) to O(n)
08:28:14 <hyperisco> an element at depth n has to be repositioned n times, if you do it eagerly
08:28:43 <hyperisco> if you defer so that you can work from the parent down instead, then you only have to position it once
08:31:03 <fen_> here is the "unfold a Nest" codehttps://pastebin.com/raw/yc01jNSH
08:31:09 <fen_> here is the "unfold a Nest" code https://pastebin.com/raw/yc01jNSH
08:32:41 <fen_> hyperisco: oh right so its the updating thats expensive?
08:33:46 <hyperisco> of course, the depth is the log of the size of a well balanced tree… another perspective
08:35:23 <Boarders> does anyone know in haddock how I write a list like [1,2,3]
08:35:48 <Boarders> if I do it just as it it ignores [ and ] and if I try to use the escape character \[ then it interprets it as mathmode
08:36:16 <lyxia> @[1,2,3]@
08:36:16 <lambdabot> Unknown command, try @list
08:36:45 <hyperisco> elvishjerricco, when a parent moves by v, so do all its children by v
08:37:11 <Boarders> lyxia: thanks!
08:37:13 <hyperisco> interesting to me is that… say we want to communicate what changed in a scene
08:37:36 <hyperisco> if the renderer knows how layouts are interpreted, then we can just send the delta for the parent
08:37:58 <hyperisco> if the renderer does not know how layouts are interpreted, we have to send the delta for the parent and all descendants
08:39:58 <hyperisco> I am thinking, more flexibly and simply, that the renderer understands element positions as formulas, so it may know the x coordinate of a particular element is  a + b + c + 10  then we can communicate the changes in variables, by name
08:40:48 <hyperisco> then, if we want to move many elements together, we just communicate the change in a shared variable
08:49:31 <fen_> so then instead of having to calculate each of the formulas you just update one of the variables?
08:49:39 <fen_> thats seems like it should be faster
08:49:52 <Taneb> What are some examples of types that are Foldable but not Functor, other than Set?
08:50:07 <merijn> Taneb: Define Foldable
08:50:27 <Taneb> merijn: the Foldable typeclass in base
08:51:15 <merijn> oh, wait I thought Functor was a superclass of Foldable, but looks like it only is for Traversable
08:51:28 <Boarders> does anyone know how to ensure that cabal new-haddock builds documentation for dependencies?
08:51:43 <merijn> Taneb: Basically "anything Foldable with a constraint on the elements"
08:51:45 <Boarders> I get "could not find link destinations for:" errors
08:51:51 <merijn> Boarders: Which cabal-install version?
08:52:03 <Boarders> 2.4.1.0
08:52:06 <merijn> Boarders: new-haddock was...brittle for a while
08:52:49 <merijn> Boarders: Does it work if you do --haddock-for-hackage ?
08:53:00 <Boarders> one of the things stack curretnly manages to do a better job at
08:53:06 <Boarders> I'll try it
08:53:46 <Boarders> merijn, it certainly looks like it is building the deps now
08:53:49 <Boarders> thank you
08:53:58 <merijn> Boarders: "cabal v2-haddock --haddock-for-hackage" works to build documentation tar balls for Hackage, not sure if that's what you wanted/needed
08:54:21 <merijn> (with 2.4.1 and later, that is)
08:54:42 <Boarders> hmm unfortunately still doesn't correctly link to package dependencies
08:57:15 <Solonarv> Taneb: also anything that mentions its type parameter in contravariant position
08:57:27 <Solonarv> although that's a bit of a silly example
08:57:53 <Solonarv> data Silly a = Silly a a (a -> Int)
08:58:08 <Piwanke> How can I configure Stack to always implicitly run `--copy-compiler-tool intero`?
08:58:32 <Solonarv> Piwanke: you can't, but why would you need to specifically install intero that often?
08:58:51 <Solonarv> the whole point of --copy-compiler-tool is that you don't have to install the same tool three times a week
08:59:07 <Piwanke> Solonarv: I want to run Intero. I have enabled Docker in my stack.yaml.
08:59:25 <Solonarv> aaah, docker. I've never used that
08:59:42 <Piwanke> But Intero can’t just be used inside a dockerized process. I read at https://stackoverflow.com/questions/51725510/running-emacs-intero-mode-with-stack-docker-integration that I need to specify `--copy-compiler-tool intero`
09:00:21 <Piwanke> Obviously I can’t pass in this option – Intero is the one doing the call.
09:01:48 <Solonarv> 'stack build --copy-compiler-tool intero' is the command to *install* intero, not to run it
09:03:36 <fen_> here is the code so far, partially unfinished, but shows the idea; https://gist.github.com/fen-hs/b5641e3e5612bebd912c2d2f1c774ac4
09:03:52 <Solonarv> also, the SO question you linked already mentions a solution - have you tried it? does it not work?
09:05:55 <fen_> (trying to unfold a state one less nested than the input state)
09:07:24 <Piwanke> Solonarv: with this explicit copying I can get it to work. I just thought that there might be a way to make it reproduciple. A dev clones the repo, opens Emacs and everything will work out of the box.
09:07:44 <Piwanke> Solonarv: but probably this is good enough. Just one more (small) installation step.
09:35:04 <Boarders> I tried to upload a package candidate to hackage but it doesn't correctly build  and link to the documentation
09:35:15 <Boarders> does anyone know any resources for what you can do about it?
09:36:27 <merijn> Boarders: What do you mean doesn't correctly build? Does it not build at all? Does it build but are the docs wrong when you upload them?
09:36:35 <dmwit> It's a shame that countLeadingZeros/countTrailingZeros aren't in their own class.
09:36:51 <dmwit> Seems like Integer could offer countTrailingZeros, e.g., even though it can't offer finiteBitSize.
09:36:54 <Boarders> merijn: the docs are not linked to
09:37:02 <merijn> Boarders: Did you upload the docs?
09:37:10 <dmwit> Boarders: Is it possible that you simply haven't waited long enough?
09:37:15 <Boarders> I don't know, I used cabal sdist
09:37:20 <merijn> Boarders: The docs aren't included in the sdist
09:37:22 <Boarders> it is very possible
09:37:44 <dmwit> Docs take a while to build. (Sometimes I've seen lag times on the order of a day or two.)
09:38:08 <Boarders> merijn: what is one meant to do?
09:38:14 <merijn> Boarders: If you run "cabal v2-haddock --haddock-for-hackage" it will put all the relevant docs in foo-docs.tar.gz under dist-newstyle
09:38:49 <merijn> Boarders: "cabal upload --documentation dist-newstyle/foo-0.1.0.tar.gz"
09:39:07 <c_wraith> dmwit, I actually think countTrailingZeroes is just in the wrong class. 
09:39:24 <Boarders> merijn: thanks, will that still work with my package candidate?
09:39:34 <c_wraith> dmwit, the specification for Bits already says index 0 is the least significant bit.
09:39:38 <merijn> Boarders: Yes, that will upload candidate docs
09:39:55 <merijn> Boarders: You need to use --publish for both non-candidate packages as well as non-candidate docs
09:40:06 <Boarders> I see
09:40:07 <Boarders> thank you
09:40:09 <c_wraith> dmwit, oh I see. it's in that class to handle "what do I return when all bits are 0?"
09:42:59 <dmwit> c_wraith: Oh. Well that's silly.
09:43:11 <dmwit> What is this type system for, anyway?
09:43:44 <dmwit> indexOfLeastSignificantSetBit :: Bits b => b -> Maybe Int
09:45:59 <Boarders> merijn: thanks for your help!
09:46:06 <merijn> Boarders: np
10:29:20 <zincy> Say you have something like this
10:29:23 <zincy> newtype Memory =
10:29:23 <zincy>   Memory (Map String Value)
10:29:24 <zincy>   deriving (Show)
10:29:26 <zincy> data VarBinding =
10:29:28 <zincy>   VarBinding String
10:29:29 <zincy>              Value
10:29:31 <zincy>   deriving (Show)
10:29:35 --- mode: ChanServ set +o glguy
10:29:35 --- kick: zincy was kicked by glguy (zincy)
10:29:52 --- mode: glguy set -o glguy
10:29:55 <zincy> Oops sorry
10:30:27 <zincy> Should have used pastebin there
10:31:37 <zincy> Is this the best way of representing a collection of variable bindings?
10:39:41 <monochrom> Depends on context.
10:46:47 <zincy> Interpreter for a simple language?
10:50:29 <jle`> it's hard to say if it's the best for every situation
10:50:42 <jle`> but it's probably sufficient for many situations
10:51:03 <jle`> knowing if something is 'the best' is going to take a lot more context and details
10:51:49 <jle`> since we have to tell you that there definitely exists no better way in all of haskell
10:53:50 <monochrom> "simple language" is vague.
10:54:08 <monochrom> Perhaps you need to see two simple examples of why it really depends.
10:54:48 <monochrom> http://www.cs.utoronto.ca/~trebla/CSCC24-2019-Winter/Interpreting.hs implements a simple language in which Map String Value is appropriate.
10:55:08 <monochrom> http://www.cs.utoronto.ca/~trebla/CSCC24-2019-Winter/Mutable.hs implements another simple language in which it's utterly dumb.
10:55:27 <monochrom> Therefore no, "simple language" contains 0 information.
10:57:06 <monochrom> Overall I am baffled at the prevailing millenial attitude that the asker needs to provide 0 information and the answerer needs to provide infinite information.
10:59:26 * jgt sniggers in millenial
11:01:32 <roconnor> Is it possible to have a cabal Test-Suite depend on the Library being built?
11:12:51 <DigitalKiwi> monochrom: i feel the same about boomers
11:13:01 <roconnor> ugh, this is some sort of backpack weirdness I don't understand.
11:18:45 <roconnor> mitchellsalad_: Hi, how did you solve https://github.com/haskell/cabal/issues/4876#issuecomment-457939448
11:25:04 <dmj`> life is too short for -O2
11:25:49 <dmj`> roconnor: yes it is
11:26:04 <dmj`> monochrom: sounds like a google query
11:26:32 <roconnor> dmj`: Thanks.  I realize my problem is that I'm in backpack hell. :D
11:27:56 <fen> how can we write class instances recursively without making them undecidable?
11:27:59 <dmj`> roconnor: do you have to use haskell?
11:28:04 <dmj`> roconnor: lol backpack**
11:28:42 <roconnor> dmj`: Backpack does exactly what I want to do.  I'm pretty sure I see a long windy path out of this problem, but I'm hoping for a short-cut. :D
11:29:02 <dmj`> roconnor: what are you trying to do exactly
11:29:11 <fen> maybe they have to be undecidable, but how can we work with them anyway?
11:29:18 <fen> how to resolve them
11:30:10 <roconnor> dmj`: I have a indefinite package that I'm both trying it instantiate and depend on.  This complies; however when you try to import the library into a test-suite, Cabal complains about a circular dependency.
11:30:37 <fen> and a different question, how did haskell manage to make functions first class values and what would need to be done to make this possible at the type level?
11:31:08 <roconnor> Both instantate and depend on because the modules that I'm writing to instantate the signature depend on types exported in other modules defined by the indefinite package.
11:31:37 <fizbin> Re-sharing a question about stack from last night that was never answered, but now on stackoverflow: https://stackoverflow.com/q/55957477/107331 (basically, can I get expansions in --test-arguments the way cabal's --test-option expands $test-suite)
11:31:50 <fen> roconnor: as is the case with UndecidableSuperclasses, you need to put all these in one module
11:32:13 <roconnor> I mean this is pretty natural IMHO becuase of course the signature in the indefinite package will have types provided by the rest of the modules in the package.
11:34:01 <fen> roconner: you mean you need types defined in some module and this module should also have instances of the classes defined in the current module?
11:34:59 <roconnor> mitchell rosen has a cryptic comment saying he spend and hour and solved the problem saying "it was tricky"
11:35:16 <roconnor> what did you do mitchell?!!! :D
11:35:34 <fen> not sure if he is online
11:35:57 <roconnor> fen: My issue is regarding Backpack's signature rather than class signatures.
11:36:12 <fen> idk about that sorry
11:36:18 <roconnor> no worries
11:36:42 <fen> so why do types need defunctionalising but functions dont?
11:36:58 <roconnor> maybe ezyang is around? 
11:37:08 <fen> whats the difference? is that what "functions first class values citizens" means? 
11:38:05 <fen> and could we work through an example of a recursive instance to see how they work?
11:38:19 <fen> recursion using type families seems different...
11:40:19 <fen> maybe something like Class A a, instance (A x,A xs) => A (x:xs), instance A '[]
11:40:41 <fen> think thats a kind error, but something similar should work
11:43:09 <fen> sure things like this exist...
11:44:02 <fen> maybe it was something to do with Nat...
11:45:27 <fen> ah, ok, heres a good example; http://hackage.haskell.org/package/fixed-list-0.1.6/docs/src/Data-FixedList.html
11:46:02 <fen> the FixedList and Append classes have instances which are recursive over a list of types 
11:46:38 <fen> not a type list sorry, a fixed list
11:48:17 <fen> oh wait, its using Cons in the instance param, so it must be a type list arg...
11:56:36 <fen> % data D = A D | B
11:56:36 <yahb> fen: 
11:56:41 <fen> % class C (c :: D)
11:56:41 <yahb> fen: 
11:56:46 <fen> % instance C 'B
11:56:46 <yahb> fen: 
11:56:51 <fen> % instance C a => C ('A a)
11:56:51 <yahb> fen: 
11:58:10 <zincy> monochrom: The problem is knowing what infro toprovide as question asker
11:59:02 <fen> like, thats Undeciadable right?
11:59:22 <fen> how does it know which instance to use for the constraint `C a'
12:00:03 <fen> guess its only a problem if they are Overlapping?
12:00:08 <zeta> can this be used for haskell as an ide ?  https://github.com/lamdu/lamdu
12:00:49 <merijn> zeta: No, it's inspired by Haskell but a completely unrelated language
12:02:58 <zeta> oh, so is this the best haskell ide ? https://github.com/haskell/haskell-ide-engine
12:03:08 <fen> so what about type families as first class citizens?
12:04:52 <fen> partly confused by the other dependent languages... they dont have the same type checker capabilities as haskell? 
12:05:20 <fen> are we supposed to abandon the benifits of haskell and move to a different language as soon as we start type level programing?
12:05:56 <fen> how is it so difficult to make functions first class citizens at type level?
12:06:08 <fen> isnt that like, what haskell is all about
12:06:10 <fen> ?
12:06:20 <fen> well, and lazy evaluation of course 
12:06:33 <fen> probably some other stuff too...
12:07:16 <fen> type level programing in haskell is like reverting to some ancient and bad language
12:07:37 <fen> why is it so difficult to put our nice language features at type level?
12:08:48 <fen> like, lambdas fine, they break inference, but partial function application does this too?
12:09:17 <geekosaur> it's not an ide. it's a backend that ides can use
12:10:54 <fen> basically, what kind of magical awesomeness does GHC have that allows partial function application in the first place
12:11:01 <fen> and then, why cant we do that at type level?
12:12:23 <fen> what features does type checking have that kind checking does not, and is that the issue?
12:21:04 <jollygood2> hi. what is a better way of doing this than the mess I have? 
12:21:09 <jollygood2> > let xs = [1,2,3,4] in [ys | a <- xs, b <- xs, c <- xs, d <- xs, let ys = [a,b,c,d], length (nub ys) == 4]
12:21:11 <lambdabot>  [[1,2,3,4],[1,2,4,3],[1,3,2,4],[1,3,4,2],[1,4,2,3],[1,4,3,2],[2,1,3,4],[2,1,...
12:23:12 <jollygood2> (lambdabot snipped the result, I want to get permutation of the list)
12:25:28 <lavalike> > permutations [1,2,3,4]
12:25:30 <lambdabot>  [[1,2,3,4],[2,1,3,4],[3,2,1,4],[2,3,1,4],[3,1,2,4],[1,3,2,4],[4,3,2,1],[3,4,...
12:25:42 <jollygood2> that is no fun :)
12:25:54 <jollygood2> I didn't know about that one, so thanks. I still want to do it myself though
12:26:43 <zachk> jollygood2, try using do notation in the lst monad to do it! 
12:26:46 <merijn> So...anyone good with extensible exceptions? Do I understand the paper right that you can only really add things at the bottom and not "wrap" an existing Exception instance with an intermediate node in the hierarchy?
12:26:47 <geekosaur> yours will fail if any list has duplicate items
12:26:59 <jollygood2> geekosaur good point
12:27:11 <lavalike> if your elements are unique a more efficient way is recursively producing the permutations of ys where (y,ys) is every way to pick an element out of xs, and sticking y on top of them
12:27:29 <lavalike> (y being the element, ys the rest)
12:27:37 <merijn> I mean, I can wrap them by catching, wrapping and rethrowing, but that's kinda annoying...
12:32:02 <jollygood2> zachk, I'd basically write the same thing but in a different syntax
12:33:23 <zachk> jollygood2, is there a link to your list permutation code?
12:34:17 <dmwit> > let xs = [1,2,3,4] in filter ((4==) . length . nub) (mapM (const xs) xs)
12:34:19 <lambdabot>  [[1,2,3,4],[1,2,4,3],[1,3,2,4],[1,3,4,2],[1,4,2,3],[1,4,3,2],[2,1,3,4],[2,1,...
12:35:52 <dmwit> ?let zippers = go [] where go _ [] = []; go l (h:r) = (l,h,r) : go (h:l) r
12:35:53 <lambdabot>  Defined.
12:36:50 <dmwit> > let perms [] = [[]]; perms xs = do (l,h,r) <- zippers xs; hs <- perms (l++r); return (h:hs) in perms [1..4]
12:36:52 <lambdabot>  [[1,2,3,4],[1,2,4,3],[1,3,2,4],[1,3,4,2],[1,4,3,2],[1,4,2,3],[2,1,3,4],[2,1,...
12:38:38 <dmwit> jollygood2: Two approaches there. One that uses the same algorithm but doesn't repeat the name `xs` quite as much, and one that uses a better algorithm that doesn't produce duplicate elements in the first place and so is faster and avoids the need to filter.
12:39:07 <dmwit> jollygood2: (The implementation of permutations that comes with GHC can be seen as a variant of the second one.)
12:40:27 <dmwit> Whoa. Just checked the implementation that comes with GHC. It can no longer be understood as a variant of the second one.
12:41:18 <dmwit> Somebody should write a blog post explaining what's going on there and why, yeesh.
12:45:31 <zincy> Is there a way of throwing an Except error in a monad stack if a variable returned to the bind function fails a pattern match
12:46:27 <zincy> The monad stack is : StateT Memory (Except Err) Value
12:46:52 <zincy> Maybe the way to do this is to change it to a  StateT Memory (Except Err) (Either Err Value)
12:47:01 <zincy> But that feels weird 
12:47:09 <Solonarv> that's definitely not right
12:47:40 <Solonarv> if a pattern match fails that will end up calling Control.Monad.Fail.fail
12:47:51 <Solonarv> (which is a member of the MonadFail typeclass)
12:48:14 <Solonarv> so as long as there is a MonadFail instance for your transformer stack you're good
12:50:37 <zincy> Ok I'll make it an instance
12:51:03 <dmwit> You'll need to use a different underlying monad than Except, which already has a fail that doesn't do what you want.
12:51:26 <dmwit> Once you do that, though, StateT will inherit an appropriate MonadFail instance.
12:51:39 <Solonarv> if you're going to do that you should wrap the stack in a newtype so you don't end up writing orphan instances / overlapping with existing instances, yes
12:53:00 <dmwit> Oh, sure. You can either use a different underlying monad than Except or wrap StateT _ (Except _) in a newtype and write whatever instances you like.
12:53:03 <zincy> thanks
12:53:36 <zincy> Or use case instead of the pattern match and throwError if the data constructor isnt a match
12:53:43 * dmwit nods agreeably
12:56:06 <zincy> Nested case expressions look unclean though
12:56:33 <dmwit> Why are they nested?
12:57:07 <dmwit> A guess: you have written `v <- foo; case v of Left err -> throwError err; Right v' -> ...`.
12:57:33 <dmwit> If my guess is correct, consider instead `v <- foo; v' <- case v of Left err -> throwError err; Right v' -> return v'; ...`.
12:58:08 <dmwit> Hm. That was less clear than it could have been, because I didn't include explicit braces.
12:58:32 <zincy> Oh you can do the case to the right of the <-
12:59:06 <Solonarv> better yet:
12:59:06 <Solonarv> v <- foo >>= \case { Left err -> throwError err; Right v' -> pure v' }
12:59:06 <Solonarv> (avoids one unnecessary intermediate name)
12:59:39 * Solonarv really likes '>>= \case'
12:59:43 <dmwit> zincy: https://gist.github.com/dmwit/ec3859dd3de56f3a835998b219b7a996
12:59:48 <zincy> https://pastebin.com/g1gh2XRP
12:59:58 <dmwit> zincy: Sure, you can put *any* expression to the right of <-
13:00:36 <zincy> lines 95 and 96 
13:01:27 <dmwit> zincy: Oh no!
13:01:30 <dmwit> zincy: This is no good.
13:01:56 <dmwit> Like, you don't handle nested expressions like (a+b)+c here.
13:02:49 <dmwit> To evaluate `Add e e'`, you should evaluate `e` -- this will do whatever lookups or nested additions or literals or whatever and just produce an `Int` -- then evaluate `e'`, then add the two `Int`s together.
13:02:53 <dmwit> No pattern match failure there.
13:04:19 <dmwit> (Okay, okay, it will produce a `StateT Memory (Except Err) Int`, not an `Int`. You get my drift. Binding will give you a variable whose type is `Int`.)
13:04:53 <zincy> Ah yes
13:05:03 <zincy> I forgot to handle nested expressions there
13:06:03 <zincy> so strip out the pattern matches and just call eval for the two expressions in the binary op
13:06:17 <dmwit> I suspect your `FunVal` should be `FunVal (Value -> Value)` or `FunVal (Exp -> Value)` (depending on calling convention), too.
13:15:18 <merijn> Is there a version of mapException that's...less horrible?
13:15:34 <merijn> Or should I just write it myself using catch?
13:18:36 <[exa]> merijn: what implementation are you referring to? the one with a coercion to Exceptional?
13:18:54 <merijn> [exa]: https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Exception.html#v:mapException
13:20:18 <[exa]> merijn: oh okay that's horrible
13:20:36 <merijn> Yes, hence my question ;)
13:21:32 <[exa]> the one from explicit-exception looks better but I don't know how brutal for you is the use of Exceptional
13:22:52 <merijn> [exa]: That looks entirely unsuitable for me, I don't like ExceptT except when I actually have Either
13:39:06 <dmwit> What type would you prefer?
13:39:27 <phaul> hey guys. I have spent the day wrestling with trying to build haskell-ide-engine and still not successful. I didn't have any luck with stack, I have a working envirnment with ghcup that has cabal, and i tried to do cabal new-build -j1 in the dir haskell-ide-engine either way I am expereiencing the same behaviour: When it builds Cabal-2.4.1.0 it allocates ~3Gb memory, about 1G of swap and all  of physical
13:39:29 <phaul> memory 2Gb, and gets stuck on a single source file. After waiting for 6 hrs, in which I can hear the disk constantly swapping I gave up. [159 of 220] Compiling Distribution.Simple.Setup ( Distribution/Simple/Setup.hs, dist/build/Distribution/Simple/Setup.o ) was the last thing and then 6hrs of nothing. I'm  not sure what to try but even before that I saw ridiculous compile times and memory usage per source
13:39:31 <phaul> file.
13:39:49 <phaul> any suggestions?
13:40:33 <merijn> dmwit: Essentially I just want "mapException f = handle (throwIO . f)"
13:40:54 <Solonarv> wait, is that not what the mapException in base does?
13:41:13 <merijn> Solonarv: No, it's a mix of evaluate and unsafePerformIO
13:41:46 <Solonarv> oh wait, I somehow glossed right over its type.
13:43:33 <dmwit> Heh. Hoogle suggests https://hackage.haskell.org/package/servant-exceptions-0.1.1/docs/Servant-Exception.html#v:mapException
13:43:59 <merijn> I'll bug edwardk to add a sane version to exceptions
13:43:59 <Solonarv> I guess the unsafePerformIO is indeed safe there, and it doesn't even break denotational semantics too much (since it just turns bottoms into different bottoms, but we usually don't care to distinguish bottoms)
13:44:34 <Solonarv> still that should not take up such a valuable name
13:45:49 <dmwit> phaul: You could try asking GHC to use less memory. Check +RTS --help, I think it's the -A option. But I think the usual way is to just build on a beefier machine and copy binaries over.
13:46:37 <phaul> dmwit: thnx, Ill try it now. on the beefier machine. yeah. if I had one :)
14:04:26 <roconnor> Ugh, I cannot get cabal to build my backpack stuff.
14:04:36 <roconnor> The following packages are broken because other packages they depend on are missing. These broken packages must be rebuilt before they can be used.
14:04:37 <roconnor> planned package Simplicity-Bitcoin-0.0.0 is broken due to missing package Simplicity-0.0.0-8PxCVWG7Ur3JJjEfs4OsCb+LBGmYIqVz14IA3lMbvdgQX
14:05:37 <roconnor> I have         include Simplicity-0.0.0-8PxCVWG7Ur3JJjEfs4OsCb[Simplicity.Primitive=Simplicity-Bitcoin-0.0.0-HWJLc8rGcO6A3XgSHg1eVd:Simplicity.Primitive.Bitcoin]
14:06:18 <roconnor> But I don't  understand what LBGmYIqVz14IA3lMbvdgQX is
14:08:02 <merijn> roconnor: Might wanna ping ezyang when he's online
14:26:41 <phaul> what's the way to propagate +RTS -M 1024Mb -RTS to ghc in my build? I am still struggling with the same issue. I assume -A that was suggested is actually -M as -A is minimums whereas -M is maximums. I put it in the program-default-options: ghc-options: section of my .cabal/config but it doesn't seem to be picked up by running cabal new-build. How do I set this?
14:28:45 <phaul> I also hacked the project .cabal everywhere where there was a ghc-options: part by adding the RTS options. but still not picked up by the build
14:46:03 <zincy> https://pastebin.com/YqzpRMcv
14:46:39 <zincy> Does anyone know why the pattern match in the case expressions at lines 96 and 100 are failing?
14:51:14 <Solonarv> zincy: those aren't failing pattern matches, that's a type error!
14:51:19 <MarcelineVQ> eval expA results in a value of StateT Memory (Except Err) Value. Did you perhaps intend to a <- eval expA and then case a of ?
14:51:51 <Solonarv> 'eval expA :: StateT _ _ Value', but your case expression assumes its type is Value
14:52:52 <Solonarv> you can write: do { valA <- eval expA; a <- case valA of { same as before }; ... }
14:53:33 <zincy> Solonarv: Yep
14:53:44 <Solonarv> or you can enable the LambdaCase extension and write: do { a <- eval expA >>= \case { NumVal n -> return n; _ -> throwError "blah" } }
14:54:20 <Solonarv> personally I like the '>>= \case' version
14:56:59 <zincy> Sorry it is late
14:57:06 <zincy> Hence my blunders
14:58:13 <Solonarv> zincy: https://gist.github.com/Solonarv/e73fcabd7ceb43a12c1f6320498020dc
14:58:35 <Solonarv> oh, also you don't need parentheses around the patterns there
14:59:18 <zincy> Thanks!
15:00:14 <roconnor> I made a really tiny backpack example that is failing in the same way, so I guess this is progress.
15:00:28 <zincy> Appreciate it
15:00:30 <Solonarv> as a rule of thumb, if you're somewhere only a single pattern is legal then you don't need parentheses around that pattern
15:04:22 <zincy> Solonarv: When you said eval handles the case already I am bit confused
15:04:38 <Solonarv> zincy: I said eval *should* handle that case already
15:04:44 <zincy> oh
15:05:05 <Solonarv> actually in your code it's already redundant
15:05:26 <Solonarv> since the first clause in your 'binaryOp' definition always matches
15:05:48 <Solonarv> there's a GHC warning which should tell you this, I don't remember what it's called
15:05:56 <Solonarv> included in -Wall though
15:36:42 <roconnor> Okay my best understanding is that nix (aka using runhaskell Setup.hs) doesn't let you use backpack across separate pacakages (only withing a single .cabal file).
15:37:29 <roconnor> because nix doesn't run cabal newbuild
16:12:21 <phaul> anybody? nobody? before I go , suggest me a way to set ghc options globally, and I kick off my builds then go
16:25:55 <fen> there are more codes @ https://gist.github.com/fen-hs/b5641e3e5612bebd912c2d2f1c774ac4 
16:26:29 <fen> particularly line 46 of Zipper.hs
16:26:37 <fen> very complicated
16:33:29 <fen> when you use a datatype like data :: (* -> *) -> (* ~> *) to "tell" GHC that the first argument has a new type 
16:33:40 <fen> it kind of feels like type applications
16:33:49 <fen> in that it provides info to the compiler
16:34:47 <fen> and that the ambiguous types seem kind of like the things we complain about the compiler not being able to resolve type level lambdas 
16:35:17 <fen> basically, is the defunctionalisation giving a kind of kind applications?
16:36:03 <fen> if thats the case couldnt we just get some kind of neat syntax for defunctionalasing, like KindApplications, and that would be all we need?
16:53:40 <d34df00d> Hey, I'm trying to write a one-line Eratosthenes sieve. The following works: erato = [ n | n <- [2..], all (/= 0) [ n `mod` n' | n' <- [2 .. n - 1] ] ], but it's not the sieve strictly speaking due to [2..n-1] being excessive.
16:53:47 <d34df00d> Is there a way to reuse the already computed numbers in erato?
16:54:04 <d34df00d> Smth like erato = 2 : [ n | n <- [3..], all (/= 0) [ n `mod` n' | n' <- takeWhile (< n - 1) erato] ] does not work, and I'm not really sure I fully understand why.
16:56:31 <d34df00d> After a second thought I guess I understand why it does not work (hanging after computing 2 and 3), but I'm still not sure how to fix it.
17:50:40 <martin__> Is `stack install xyz` the recommended way to add a package to your project?
17:50:59 <martin__> When I do it I have to add tons of items to extra-deps in stack.yaml
17:53:40 <MarcelineVQ> no, stack install is for building and then installing executables, making a package available is just a side effect.
17:54:16 <MarcelineVQ> The reccomended way to add a dependency to your project is to add it to the relevant build-depends section of your cabal file and from then on running most any stack command will make sure that package is available beforehand
17:57:31 <MarcelineVQ> in some cases the package you want isn't in your chosen resolver (specified in your stack.yaml) and you'll need to either find a resolver that does provide the package you need or add what it requires to extra-deps
17:59:24 <martin__> @MarcelineVQ thanks, will try this
17:59:25 <lambdabot> Unknown command, try @list
17:59:56 <MarcelineVQ> fizbin: man, who the heck downvoted your SO post, seems like a perfectly reasonable question
18:01:22 <MarcelineVQ> martin__: could be relevant for you https://docs.haskellstack.org/en/stable/stack_yaml_vs_cabal_package_file/
18:11:35 <fizbin> MarcelineVQ: I know, right? Stackoverflow, man...
18:41:56 <fen_> what is a closure? is it anything to do with being able to pass functions as arguments? 
18:43:03 <fen_> i can find this; https://wiki.haskell.org/Closure
18:43:23 <fen_> but its not very detailed...
18:44:12 <ski> a closure is a particular implementation technique for a function value
18:44:38 <fen_> that sounds exactly like its the right kind of thing
18:45:27 <ski> one can view it as an optimization on the substitution-based (operational) semantics for functions
18:46:06 <fen_> what are, and what is wrong with those?
18:46:20 <ski> (cf. how logic / dataflow / meta- variables can be viewed as an optimization on existential goals and universal assumptions)
18:46:31 <ski> closures
18:46:38 <ski> wrong with it ?
18:46:47 <fen_> no, the operational semantics for functions
18:47:08 <fen_> they are not as good as closures?
18:47:31 <fen_> are closures what you need to get functions as values, or is it about partially applying them?
18:47:32 <ski> substitution works
18:48:01 <fen_> for what?
18:48:09 <ski> for function values
18:48:26 <fen_> so closures are just about partial application?
18:48:33 <fen_> or is it something to do with scoping?
18:48:50 <fen_> cant understand what the wiki page is actually getting at
18:48:53 <ski> closures "close over" the non-local variables
18:49:10 <ski> perhaps you should try to read SICP (and do exercises) (?)
18:49:50 <fen_> i just want to understand why haskell manages so neatly to have function values, and to be able to partially apply them and pass them as arguments etc
18:49:59 <fen_> and totally fails to achieve this at type level
18:50:17 <fen_> if all the machinery and techniques exist, whats the challenge at type level?
18:50:24 <siraben> fen_:  type constructors can be partially applied
18:50:28 <ski> that's more about higher-order unification being problematic
18:50:52 <ski> there is no unification of values, at value level
18:51:06 <siraben> But also as ski says, type level unification is hairy stuff
18:51:07 <fen_> unification is something like f a ~ g b implies f ~ g and a ~ b ?
18:51:11 <ski> (well, there is, in a logic programming language. but Haskell is not one of those. look elsewhere)
18:51:25 <siraben> Make it too expressive and unification is undecidable.
18:51:29 <fen_> siraben: whats a type constructor? a datatype constructor?
18:51:52 <ski> fen_ : solve the equation `f 0 = 0', what can `f' be ?
18:51:54 <siraben> fen_:  A type constructor takes types and constructs types
18:51:59 <siraben> :k Maybe
18:52:01 <lambdabot> * -> *
18:52:01 <fen_> the problem is with type synonyms and type families
18:52:03 <siraben> oops
18:52:06 <siraben> :k Just
18:52:07 <lambdabot> a -> Maybe a
18:52:16 <siraben> Well anyway, Maybe is a type constructor
18:52:25 <siraben> :k Maybe Int
18:52:26 <lambdabot> *
18:52:30 <siraben> Here I applied it to the type "Int"
18:53:02 <fen_> but it can be partially applied because it has a "Constructor" where type synonyms/families do not
18:53:18 <siraben> fen_:  Have you read the basics of haskell, by any chance?
18:53:46 <siraben> I wouldn't worry about type families etc. until fully understanding type constructors, kinds, types etc.
18:53:48 <fen_> this seems to indicate that it has something to do with the type checker being able to resolve things using e.g. the newtype constructor, to distinguish otherwise equivalent types
18:54:27 <siraben> fen_:  not sure by what you mean "it has a constructor"
18:54:38 <fen_> ski: f is polymorphic in its argument, restricted to be the class which has 0 as instances
18:55:02 <ski> fen_ : i'm not talking about polymorphism
18:55:22 <fen_> siraben: it must be something to do with it corresponding to records, like, ways to "wrap" a value
18:55:22 <ski> (for concreteness' sake, you could say `0' there is a natural number')
18:56:36 <fen_> what can f be? anything polymorphic in its first argument? oh, does it have to be id?
18:58:22 <fen_> right, so your specifying 0 :: Nat, ok, then it is just (\x -> x)
18:58:22 <fen_> id :: Nat -> Nat
18:58:22 <fen_> why?
18:58:23 <fen_> does polymorphism have something to do with functions as values?
18:59:35 <fen_> siraben: can you understand why haskell cant pass unsaturated type synonym/families? 
19:00:48 <fen_> ski: your segway about `f' seems totally unrelated at this point
19:01:08 <ski> fen_ : another solution is `f = \_ -> 0'
19:01:18 <fen_> oh ok
19:01:27 <fen_> yeah, guess id . id would work also
19:01:37 <ski> the important point is that there is no most general unifier
19:01:37 <fen_> but, whats the relevance? 
19:01:51 <fen_> ah, unification
19:02:01 <ski> so, you end up with non-determinism (e.g. implemented as backtracking), in the type system .. ambiguity. that's not good
19:02:32 <ski> worse, you don't get completeness. there is no algorithm which gives all solutions
19:02:32 <siraben> fen_:  right, hence if you try to do that with type families, it blows up
19:02:32 <fen_> ok, so there are choices, and ambiguities and so it cant solve stuf and resolve somethings type
19:02:45 <ski> generally, a large headache
19:03:05 <fen_> ok, lests try and get the specifics
19:03:57 <fen_> what about undecidable unification
19:04:13 <ski> but you can look up "L-lambda matching", which is a restricted case, where you do get completeness (though still no most general unifier, so you still have non-determinism. lambdaProlog implements this. and i think Twelf probably as well (?))
19:04:52 <fen_> so why do we need this most general unifier?
19:05:25 <fen_> how does this have something to do with newtypes?
19:06:48 <fen_> i dont get how the type level and value level are different...
19:07:33 <ski> if you infer a type for an expression, or a definition, you'd like it to be the most general one, which encompasses each possibly more restricted one the use may have had in mind
19:07:44 <geekosaur> it's not happening because the typechecker is already the slowest part of compiling aand people already complain about it,, and handling unsaturated type families would slow things down even more even if it just tosses type inference out the window when it sees one (as already happens for rank-N types)
19:08:07 <ski> (buy you already lose this with polymorphic recursion. and with higher-rank)
19:08:52 <roconnor> Anyone familiar with QualifiedConstraints want to explain this error:  https://gist.github.com/roconnor-blockstream/b2d64c685fbe142accdb30b451b68ba6  I mean Isn't Eq (arr a b) a smaller constraint than Eq (SomeArrow arr)?  What's the definition of smaller?
19:08:59 <fen_> none of these statements make any sense
19:09:30 <fen_> so there is something about higher rank things now?
19:09:54 <fen_> why do these inhibit type inference?
19:10:33 <Cale> roconnor: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#instance-termination
19:11:14 <fen_> roconner: its like you have written instance A a => B a
19:11:33 <Cale> roconnor: I would turn on UndecidableInstances without a second thought typically. The only downside of that extension is that it becomes possible to write nonterminating type level programs, but if the typechecker finishes, then nothing is ambiguous or anything like that.
19:12:08 <fen_> the constraint alone cant restrict the instance, its basically still totally polymorphic (like writing instance A a), as it does not check the constraints until after it has decided which instance to use
19:13:08 <roconnor> fen_: No way, the instance has a SomeArrow constructor that is stripped away in the context.
19:14:17 <fen_> oh so its more like instance Show a => Show [a]
19:14:20 <roconnor> Maybe it is accounting the a and b variables as more variables even though they really don't count since they are not free variables.
19:14:20 <fen_> hmm
19:14:27 <Cale> roconnor: Yeah, hmm...
19:15:01 <roconnor> (I mean maybe they really do count and my intuition is all wrong. :)
19:15:18 <fen_> could be
19:15:34 <fen_> like, its not as if you chose actual specific types
19:15:46 <Cale> Have you managed to give a forall constraint on an instance without it complaining?
19:16:02 <roconnor> This is my first time.
19:16:04 <fen_> is it not like instance forall a. a ~ b => A b
19:16:04 <Cale> I can imagine that it could be that it just always complains in this way.
19:16:31 <roconnor> I'll try turning on UndecidableInstances just this one time.
19:16:36 <fen_> thats a restriction on b, it has to be the same as a, but thats not really much of a restriction
19:17:03 <roconnor> has to be the same as every a.
19:17:25 <Cale> roconnor: It's really just OverlappingInstances and IncoherentInstances that you typically want to worry about.
19:17:28 <fen_> well isnt that just the same as instance A a
19:17:29 <fen_> ?
19:17:41 <roconnor> Cale: that does make me feel better.
19:18:10 <fen_> but that would happen as soon as you define anything!
19:18:10 <roconnor> The constraint (forall a. a ~ b) says that b needs to be idential to every type. ... which of course will never be true.
19:18:51 <fen_> oh, i just thought it mean for each specific a. 
19:19:09 <fen_> like you mean forall a. a ~ b, is not the same as a ~ b
19:19:10 <fen_> ?
19:19:16 <roconnor> correct.
19:19:21 <roconnor> they are not the same.
19:20:07 <fen_> but then you cant write instance a ~ b => A b
19:20:11 <fen_> oh! that why
19:20:18 <fen_> because it *cant* just put a forall...
19:21:05 <fen_> man, no wonder I cant even understand undecidable unification 
19:23:11 <fen_> geekosaur: why would type inference break when it encounters an unsaturated type family?
19:23:32 <fen_> and how is that anything like Rank-N types?
19:25:14 <Cale> https://github.com/ghc/ghc/blob/610ec224a49e092c802a336570fd9613ea15ef3c/compiler/typecheck/TcValidity.hs#L1890
19:25:32 <Cale> Here's the code which checks the instance termination (which UndecidableInstances turns off)
19:26:02 <fen_> argh!
19:26:23 <Cale> It does appear to be collecting the foralled tyvars
19:26:53 <roconnor> To be fair, I'm just guessing bound variables ought not to count.
19:27:24 <Cale> It would make sense for them not to count
19:27:33 <roconnor> I don't have a termination proof in hand though.
19:27:42 <Cale> oh, also which version of the compiler are you using?
19:27:48 <roconnor> 8.6.4 I think
19:28:38 <Cale> okay, code looks similar there...
19:29:37 <Cale> oh, wait, no it's not quite the same
19:30:16 <fen_> so its something to do with decidability and that has something to do with unification?
19:30:18 <AJTJ> hey, so I'm just starting with Haskell
19:30:23 <AJTJ> trying to get the tools worknig
19:30:25 <Cale> Hello!
19:30:30 <AJTJ> hi! :D
19:30:34 <maerwald> Welcome
19:30:40 <fen_> your using the haskell platform?
19:30:59 <AJTJ> so, I got Haskero working with VSCode. I've installed intero etc...
19:31:36 <roconnor>               -- Termination of the quantified predicate itself is checked
19:31:38 <roconnor> -- when the predicates are individually checked for validity
19:32:02 <AJTJ> I ran "stack new my-project new-template" in terminal and it pumped out a project template, but it has an error in it
19:32:23 <AJTJ> in app/Main.hs the line `main = someFunc` is an error
19:32:32 <AJTJ> ...in my linter's eyes
19:32:36 <Cale> Is someFunc defined?
19:32:43 <Cale> Oh, just the linter?
19:32:47 <Cale> Ignore it then.
19:32:49 <fen_> you could replace someFunc by undefined
19:33:18 <Cale> What is the linter telling you?
19:33:36 <Cale> No top level type signature?
19:33:49 <AJTJ> https://ibb.co/kMqVXM4
19:34:01 <Cale> Oh
19:34:15 <Cale> Well, the problem is that someFunc doesn't exist, sure.
19:34:26 <xcthulhu> You can just do main = pure () for now
19:34:30 <AJTJ> ok, I just wanted to be sure that I have installed the tools correctly
19:34:39 <Cale> Amusingly "someFunc" is pretty inappropriate as an imaginary variable name, because main is not a function.
19:34:55 <AJTJ> why would it spit that out as the template?
19:34:56 <Cale> You could try  main = putStrLn "Hello, world!"
19:35:01 <maerwald> now just click "Quick Fix" until your editor has implemented the entire program for you :P
19:35:09 <Cale> I dunno, I guess they just expect you to fill that bit in
19:35:15 <xcthulhu> @Cale Function of zero arguments...
19:35:15 <lambdabot> Unknown command, try @list
19:35:15 <fen_> someIO?
19:35:33 <Cale> xcthulhu: A function of zero arguments is not a function at all.
19:35:43 <Cale> xcthulhu: Every function has a domain and codomain
19:36:45 <AJTJ> do any of you work with Haskell in your job?
19:36:49 <Cale> I do
19:37:08 <Cale> Amusingly, I've never been bothered to set up any of the stuff that you just did
19:37:09 <xcthulhu> Yeah I do too
19:37:23 <roconnor> I guess I do.
19:37:35 <AJTJ> Cale: what toolage do u use?
19:37:39 <AJTJ> any?
19:37:54 <maerwald> the only thing that works for me is codex
19:37:55 <Cale> A text editor, ghci, ghcid, nix
19:38:05 <maerwald> everything else is either broken or doesn't scale on large projects
19:38:13 <xcthulhu> Which text editor?
19:38:21 <MarcelineVQ> "<Cale> Well, the problem is that someFunc doesn't exist, sure." The popup is hiding an import. someFunc exists in src/Lib.hs which is part of the default project
19:38:23 <Cale> Sublime Text right now, sometimes vim
19:38:45 <Cale> MarcelineVQ: ah, in that case, it's not building the thing correctly.
19:39:35 <Cale> xcthulhu: I don't have any special Haskell support configured, apart from using hasktags to get the ability to jump to definitions, and using the default Haskell syntax highlighting
19:40:36 <AJTJ> Cale: MarcelineVQ: https://ibb.co/5cVzgD5
19:40:41 <xcthulhu> That's cool.  I mostly just use ghcid
19:40:54 <roconnor> what's ghcid?
19:41:31 <AJTJ> maerwald: so, there are no good build tools for Haskell?
19:41:37 <Cale> roconnor: It's a thing which will talk to ghci and keep a list of the current errors/warnings on your project up to date as you save things
19:41:43 <xcthulhu> It's a continuous compilation system for Haskell.  Matt Parsons has a nice blog post about it: https://www.parsonsmatt.org/2018/05/19/ghcid_for_the_win.html
19:41:48 <fen_> i was trying to comment my code, but it has no comments so i dont know what it does
19:41:51 <Cale> (on the terminal)
19:41:52 <fen_> !?
19:41:54 <AJTJ> I'm a web developer, so I'm used to having lots of tools
19:42:18 <fen_> basically, normally i just read the type signature
19:42:21 <AJTJ> Cale: did u see that second image?
19:42:23 <maerwald> AJTJ: haskell tooling in general is not in a good state, but for small projects you can get away with one or another
19:42:26 <fen_> but now that is actually a computation :-(
19:42:27 <Cale> AJTJ: I dunno, there are tools, but I'm just not used to actually using most of them, ghci does a lot of things for you.
19:43:05 <fen_> "if you solve this type level program in your head, then you will understand what the program does"
19:43:15 <Cale> (I've been programming in Haskell since before most of the tools existed, and I haven't found any of them to be life-changing enough to be bothered with setting them up)
19:43:33 <Cale> Well, apart from the things I mentioned
19:43:36 <maerwald> you are such a purist :P
19:44:10 <xcthulhu> He's not the first veteran I've met to express this opinion
19:44:38 <xcthulhu> One of my colleagues is very senior and he uses essentially the same settup
19:44:45 <xcthulhu> (except for nix)
19:44:49 <Cale> Tools are often crutches used to make up for weaknesses in a language
19:45:15 <fen_> ides are for java programers that have renamed everything which we would just write using hofs and instantly know what they do and not end up with excessive superfluous synonyms
19:45:17 <AJTJ> https://ibb.co/5cVzgD5 is anyone able to tell me why this `someFunc` is read as an error? Somebody mentioned that perhaps the Lib wasn't building correclty
19:45:29 <maerwald> well, I like to see types of arbitrary expressions... you would think that should be easy in haskell editor, but it appears it isn't
19:45:40 <Cale> Yeah, it looks like your editor doesn't know about the contents of Lib, which is being imported it seems.
19:45:54 <MarcelineVQ> have you tried turning it off an on again?
19:46:00 <fen_> good haskell code should fit on one page or your doing something wrong
19:46:02 <Cale> So, everything should be fine, but whatever your editor is doing to check it is wrong.
19:46:08 <fen_> like writing a compiler, thats just a bad idea
19:46:37 <MarcelineVQ> fen_: writing a compiler is a very common thing to do in haskell, not as common as an interpreter though
19:46:40 <xcthulhu> @AJTJ: Maybe try the command line and type `stack build`
19:46:40 <lambdabot> Unknown command, try @list
19:47:50 <Cale> maerwald: It's easy enough with ghcid, add an annotation of :: _ to whatever expression, and it'll tell you the type
19:48:29 <maerwald> last time I tried ghcid it didn't work, because the config file parser is broken and doesn't understand --some="bar baz"
19:48:46 <Cale> I don't understand --some="bar baz" either
19:48:53 <AJTJ> why do the tools suck with Haskell?
19:49:02 <maerwald> Cale: well, it doesn't understand the quotes
19:49:09 <xcthulhu> AJTJ: It's rarely used in industry
19:49:13 <maerwald> so it doesn't parse valid config flags
19:49:36 <maerwald> at that point I gave up on it
19:49:54 <Cale> AJTJ: I don't know, some combination of "there isn't enough money or people who are interested in improving them"
19:49:59 <MarcelineVQ> probably not true but consider the case: when less tooling is needed to get something done, less people work on tools
19:50:17 <maerwald> MarcelineVQ: probably not true ;)
19:50:25 <AJTJ> yea, I don't agree with that
19:50:45 <Cale> AJTJ: As I've expressed, I'm pretty light on tool requirements, but I don't feel like the tools which I do use are getting in my way or lacking very much
19:51:17 <AJTJ> Cale: so u use ghci?
19:51:37 <Cale> Yeah, I keep a ghci window open alongside my code a lot of the time I'm working on it.
19:52:15 <Cale> As I make changes, I type :r in ghci to reload my file, and then test out some expressions based on the things I've defined in my file, or use :t to check the type of an expression
19:52:15 <MarcelineVQ> I've an editor window and ghci and ghcid
19:53:01 <Cale> ghcid is like an automated limited ghci that only displays a list of errors/warnings, and updates it every time you save
19:53:22 <fen_> "isnt enought money" ... strange idea
19:53:55 <Cale> You can give it a command to run with the -c flag if you want to use "cabal repl" or some stack command that will get you a ghci
19:54:00 <maerwald> Cale: well, so you are basically switching the window ~200 times per day, type :r manually and copy paste or retype entire expressions that already exist in code. That probably wastes up to an hour of time
19:54:20 <Cale> nah
19:54:29 <maerwald> Compared to it just being a tooltip in your editor
19:54:49 <Cale> Compared to what just being a tooltip?
19:54:57 <maerwald> types of expressions for example
19:55:02 <xcthulhu> fen_: Well, Target uses it for some of their infrastructure team, and Facebook uses it for one of their filtering services.  There's IOHK but I've seen a few resumes from their employees floating around recently so I wonder what their financials are like.
19:55:07 <xcthulhu> And there's Galois
19:55:10 <Cale> If I want the type of an expression, I'll type ":: _"
19:55:16 <Cale> and ghcid will display it
19:55:40 <Cale> Well, depending on whether I want something which is already part of the code or not
19:55:49 <Cale> If it's not part of the code, I'll use :t
19:55:49 <fen_> its a problem if you can name all the places that use a language...
19:55:56 <xcthulhu> lol yeah
19:56:04 <Cale> You didn't name my company :(
19:56:06 <xcthulhu> Really, it's not a big community
19:56:18 <Cale> Or any of our clients
19:56:35 <xcthulhu> Cale: I should say I don't know everything about the industry
19:56:47 <maerwald> no touting :P
19:56:53 <Cale> Yeah, I'm just pointing out that wasn't a complete list
19:56:56 <AJTJ> Cale: u don't have something that hot reloads your ghci when u save?
19:57:02 <Cale> for fen's sake
19:57:05 <fen_> sure
19:57:14 <fen_> the industry in haskell page is out of date
19:57:17 <Cale> AJTJ: That would be annoying
19:57:29 <maerwald> you lose defined bindings
19:57:43 <Cale> AJTJ: Sometimes I want to save something that I know will temporarily break things
19:57:53 <Cale> and still retain access to the loaded code
19:58:05 <fen_> copy paste?
19:58:06 <Cale> ghcid will auto-reload to present me with errors
19:58:19 <Cale> and I can reload ghci manually once it tells me that things are working
19:58:33 <MarcelineVQ> Cale: :reload! :>
19:58:33 <xcthulhu> TBH I never use ghci
19:59:17 <Cale> TBH, in work projects, I use ghci directly a lot less than I'd perhaps like to, because I'm typically working on web and mobile applications, and it's just not as useful as simply running the code
19:59:18 <xcthulhu> I use ghcid to run tests continuously and I never bother repl debugging.  We need like 50 monad transformers to do anything anyway
19:59:32 <Cale> But for personal projects, I use ghci constantly
19:59:34 <MarcelineVQ> 50 sounds like a lot
19:59:40 <fen_> i like the idea that there is some industry dudes that know about haskell but they are just "waiting for it to be ready" and it just keeps getting less ready
19:59:43 <MarcelineVQ> actually 5 sounds like too many
19:59:58 <Cale> fen_: In what sense?
20:00:03 <fen_> more advnaced
20:00:08 <Cale> huh?
20:00:10 <AJTJ> stack looks like it's updated a lot
20:00:11 <MarcelineVQ> You have to opt-in to lagnauge extentions.
20:00:21 <fen_> more language extensions etc
20:00:27 <fen_> more space age 
20:00:36 <Cale> AJTJ: Yeah, stack is well-maintained. I've never had the occasion to use it, but it seems nice enough.
20:00:43 <fen_> industry are like, damn, we should have gone with it at haskell98
20:01:02 <MarcelineVQ> you have plenty of power at haskell98
20:01:05 <maerwald> "updated a lot" for sure is correct
20:01:14 <MarcelineVQ> e.g. http://okmij.org/ftp/tagless-final/cookbook.html
20:01:29 <AJTJ> maerwald: is it bad?
20:01:32 <AJTJ> stack
20:01:48 <xcthulhu> It's good in some ways and bad in others
20:01:54 <maerwald> AJTJ: no
20:01:57 <fen_> MarcelineVQ: thats just not what you say to the industry ppls
20:02:07 <fen_> *whomp* 
20:02:12 <maerwald> it's opinionated :)
20:02:18 <MarcelineVQ> in fact I don't say anything to the industry ppls ;>
20:02:31 <MarcelineVQ> Except when they're in here
20:02:32 <fen_> thatl learn em
20:02:52 <MarcelineVQ> Cale: how do you do, fellow industry ppl
20:02:54 <fen_> using C like troglodytes 
20:03:02 <AJTJ> anyone use stack in here?
20:03:06 <xcthulhu> @MarcelineVQ: I actually try my best to write Haskell98 as much as I can at work.
20:03:07 <lambdabot> Unknown command, try @list
20:03:47 <fen_> then there is the ol' uni x-ray bean written in cobalt
20:04:00 <fen_> cos thats the way we likes it
20:04:02 <Cale> That's interesting if we don't have a stack user present right now
20:04:29 <Cale> (I'm sure there will be plenty of people idling in here who might not be watching actively and who use stack)
20:04:46 <xcthulhu> I'm a stack user
20:04:49 <MarcelineVQ> Most people just don't respond to one word answer questions ehe. AJTJ yes there are many
20:05:06 <AJTJ> that makes sense
20:05:24 <xcthulhu> @AJTJ: Do you have some stack-related questions?
20:05:24 <lambdabot> Unknown command, try @list
20:05:50 <xcthulhu> lol I need to stop using @ it's driving lambdabot nuts
20:06:16 <AJTJ> xcthulhu: I do, I'm a beginning and I'm trying to figure out why my linter is saying someFunc is an error https://ibb.co/5cVzgD5
20:06:25 <Cale> xcthulhu: Yeah, it's uncommon on IRC. Most clients will tab complete with a colon or comma.
20:06:26 <fen_> haskell wont be useful to anyone until we have fuzzy-neural adversarial causal inference eigensystem realisation
20:06:50 <AJTJ> xcthulhu: this is after running `stack new my-project`
20:07:01 <Cale> fen_: I would appreciate it if you'd troll just slightly less
20:07:08 <xcthulhu> Cale, I blame slack
20:07:31 <MarcelineVQ> AJTJ: People would need to know what you're using, editor + plugin + linter, to try to tackle why it's not working. Did you try running "stack build" like xcthulhu suggested earlier?
20:07:38 <xcthulhu> AJTJ, at the command line, go to the project and type "stack build"
20:07:47 <AJTJ> xcthulhu: done that already 
20:07:54 <xcthulhu> No errors?
20:08:25 <xcthulhu> try `stack ide targets` and print what it says here
20:08:43 <fen_> Cale: sorry, i cant read my code because all the types are programs and am becoming hysterical 
20:09:33 <Cale> fen_: Try just getting really restrictive with the language features you use. There's a lot to be said for good ol' functional programming.
20:09:44 <Cale> (without all the type level fanciness)
20:09:58 <fen_> if there was a way to refactor it as such that would be really good actually
20:09:58 <AJTJ> xcthulhu: my-project:lib
20:09:59 <AJTJ> my-project:exe:my-project-exe
20:09:59 <AJTJ> my-project:test:my-project-test
20:09:59 <Cale> Even type classes are often more than you really want.
20:10:07 <fen_> !
20:10:25 <AJTJ> xcthulhu: here is the output from after I ran stack build
20:10:25 <Cale> Just like basic data types and functions can really take you quite a long way
20:10:26 <AJTJ> https://gist.github.com/AJTJ/f459bfc0d4f044af91e33b03a42b2106
20:10:35 <xcthulhu> AJTJ: "stack run my-project-exe"
20:10:47 <xcthulhu> It should print "someFunc"
20:11:09 <fen_> https://gist.github.com/fen-hs/b5641e3e5612bebd912c2d2f1c774ac4
20:11:19 <AJTJ> xcthulhu: it does that... hmm
20:11:38 <fen_> its got to the point where you would have to be able to read it to be able to tell if it could be written differently
20:11:40 <AJTJ> printed someFunc
20:11:42 <Cale> Type classes can be helpful and awesome, but it's not always the case, and a simple record of functions will often do just as well -- particularly if you find you have a lot of instances that would want to be at the "same" type.
20:11:46 <xcthulhu> AJTJ: Your program is fine, but probably intero is messed up in VSCode
20:12:16 <fen_> Cale: think the idea was to make a State over nested containers which could be unfolded into less nested containers
20:12:23 <AJTJ> xcthulhu: it would be intero that is the issue?
20:12:27 <fen_> that bits ok, but the unreadable code bit isnt
20:12:36 <xcthulhu> AJTJ: usually that's my experience
20:12:50 <Cale> :t mapState
20:12:51 <lambdabot> ((a, s) -> (b, s)) -> State s a -> State s b
20:13:01 <Cale> ah, that's not what I want...
20:13:22 <MarcelineVQ> xcthulhu: have you determined they're using intero?
20:13:44 <AJTJ> xcthulhu: what does one do in this situation?
20:13:48 <xcthulhu> MarcelineVQ, AJTJ mentioned it earlier I believe
20:13:53 <Cale> Oh, right, withState isn't type-changing
20:13:53 <AJTJ> I am
20:14:03 <Cale> You maybe want zoom from lens
20:14:04 <AJTJ> xcthulhu: I'm attempting to use Haskero
20:14:28 <xcthulhu> AJTJ, I know that HIE has an error log in VSCode, and intero in emacs has an error log
20:14:33 <fen_> like, if it had an example with unfold written as described, we could refactor it from there more easily, because we could see what it does
20:14:53 <fen_> but its not going to get there easily in this state. whats with all these tags!?
20:14:53 <Cale> (though lens is its own complicated chungus that I'd usually rather avoid when I can)
20:15:20 <fen_> its like having to learn a new paradigm, which is second nature eventually, but when you cant read the code you just wrote thats not a good sign
20:15:36 <Cale> zoom :: Monad m => Lens' s t -> StateT t m a -> StateT s m a -- at least, that's one of the ways that it specialises :P
20:15:58 <fen_> nonono
20:16:02 <xcthulhu> Cale, I wish my all my coworkers followed your philosophy.  Writing MFunctor instances for continuation passing style state monad transformers is a high-brow waste of time
20:16:18 <Cale> xcthulhu: Indeed.
20:17:02 <fen_> like (unfoldr (s :: State '[[],Nonempty,Tree,[],[]] a) :: State '[Nonempty,Tree,[],[]]
20:17:04 <Cale> All those fancy type system features and techniques and such exist for a reason, but many of them are terrible if overused.
20:17:17 <fen_> (unfoldr (s :: State '[[],Nonempty,Tree,[],[]] a) :: State '[Nonempty,Tree,[],[]] [a]
20:17:51 <Cale> fen_: Well, what's your ultimate goal? To be able to have complicated states, and have some parts of the computation which only have access to some of them?
20:17:57 <AJTJ> xcthulhu: hmm, for some reason it's complaining about someFunc not being in scope
20:18:09 <fen_> !?
20:18:19 <fen_> see the type above
20:18:55 <Cale> I'm not sure I follow what the code there means
20:18:59 <fen_> the paste gives the machinery to do that
20:19:02 <fen_> but i cant read it
20:19:29 <fen_> Cale: it gives the return type of unfoldr applied to a state
20:19:31 <Cale> I can't either (or maybe I could, but it's tedious to read)
20:19:46 <Cale> :t unfoldr
20:19:46 <xcthulhu> AJTJ, https://github.com/chrisdone/intero/issues/171
20:19:47 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
20:19:54 <Cale> ^^ this unfoldr, or another one?
20:20:03 <fen_> ok lets break it down; we have;
20:20:04 <fen_>  State '[[],Nonempty,Tree,[],[]] a
20:20:11 <fen_> Cale: the paste man!
20:20:26 <fen_> https://gist.github.com/fen-hs/b5641e3e5612bebd912c2d2f1c774ac4 
20:20:29 <fen_> line 94
20:20:30 <Cale> I don't see where you've defined State
20:20:44 <Cale> data TyCon2 (tc :: a -> b -> c) (tf :: TyFun a (b ~> c)) ?
20:20:45 <fen_> State is on 111
20:20:56 <Cale> type (:.$$$$) a b x = (:.) a b x -- line 111
20:20:57 <fen_> Cale: no not that 
20:21:01 <fen_> the second part
20:21:03 <fen_> zipper.hs
20:21:24 <Cale> oh, I didn't even notice that part :P
20:21:44 <fen_> haha, the first one is just type level helpers, dont mind that
20:21:49 <Cale> type State x s a = s -> x a s
20:21:52 <fen_> right
20:21:55 <fen_> so that x
20:22:02 <fen_> thats the "basefunctor"
20:22:15 <fen_> see line 90
20:22:23 <Cale> Wait, but then the things you've been writing are kind errors
20:22:33 <Cale> State '[[],Nonempty,Tree,[],[]] doesn't seem right
20:22:36 <fen_> no they are not
20:22:39 <fen_> it all compiles
20:22:47 <fen_> ah, ok that isnt quite right sorry
20:22:48 <xcthulhu> AJTJ, Sadly, it's hard for me to debug without having the errors in front of me.  I haven't encountered your bug in VSCode before (nor in emacs).
20:23:05 <AJTJ> xcthulhu: thanks for that link, I'm looking through it now
20:23:18 <fen_> see line 36
20:23:29 <fen_> data BCConstructor = LinearC (* -> *) | StackC  (* -> *) | StreamC ((* -> *)) | Nested [BCConstructor] 
20:23:44 <fen_> thats the thing that "Containers" must have associted
20:23:55 <xcthulhu> Cale, it was nice chatting with you.  You were right about the 0-arity function thing.
20:23:57 <fen_> so the Nested case is that list of types given to state
20:23:58 <fen_> sorry..
20:24:06 <fen_> it was more brief to write it wihtout that
20:24:18 <Cale> xcthulhu: I was being picky ;)
20:24:27 <Cale> xcthulhu: see you around!
20:24:40 <MarcelineVQ> AJTJ: importantly that's not a compilation error, your program compiles and runs, so you can continue on writing other things
20:24:56 <AJTJ> MarcelineVQ: yes
20:24:56 <Cale> fen_: That's interesting. I wouldn't have even expected this to be valid syntax for a data declaration.
20:25:10 <AJTJ> but it's annoying because I hate squiggly red lines
20:25:22 <Cale> But I suppose it almost makes sense? I guess you can now only use this thing at the type level?
20:26:30 <Cale> This all seems quite ridiculous, I can't imagine a problem for which all this would be the best solution.
20:27:10 <Cale> Like, are you actually trying to write a program to do a thing?
20:27:24 <fen_> yes!
20:27:46 <Cale> Or I should say, is there some running code with an annoyingly repetitive pattern in it that you're trying to eliminate?
20:27:50 <fen_> the unfold above is the recursive instance
20:28:00 <Welkin> is anyone here familiar with SASL?
20:28:08 <glguy> Welkin: I can help with that
20:28:18 <fen_> its for zippers over nested containers
20:28:26 <Cale> Welkin: David Turner's language?
20:28:32 <Welkin> I'm so close to having this scram sha-1 implementation working, but I'm having troule wit hthe text encoding of the buffers near the end
20:28:57 <Cale> Welkin: ah, I was thinking of https://en.wikipedia.org/wiki/SASL_(programming_language)
20:29:04 <fen_> (there is some special thing with fusion on the depth 2 nested case which im trying to get to which will be a zipper over Free things like trees)
20:29:07 <Cale> which was one of the precursors to Haskell :)
20:29:15 <Welkin> when I need to include the client proof in the final message (ase64 encoded) I can't seem to get a reversible encoding of the buffer
20:29:21 <Welkin> base64*
20:29:43 <Welkin> because the byte buffer contains non-showable characters, and it just gets all messed up
20:29:55 <Cale> fen_: Rather than all this, wouldn't it be easier just to hand-code whatever zipper it was that you needed?
20:29:57 <fen_> Cale: i get your idea, of seeing if this is nesacary
20:30:04 <AJTJ> does anyone know how to check my version of intero?
20:30:18 <Cale> I've written zippers manually for various types, and it's never been this much trouble.
20:30:26 <Cale> Even if I added up all the zippers I've ever written
20:30:29 <Welkin> this is in the browser/js using TextEncoder/TextDecoder (which are utf-8 only), and I even tried using String.fromCharCode
20:30:39 <Cale> It wouldn't add up to this much hard-to-understand shenanigans
20:31:03 <Welkin> I don't know how I need to convert from byte buffers to text
20:31:13 <Welkin> my server says the proof is wrong
20:31:18 <fen_> Cale: if there is less machinery to get that it would be awesome, but thats only going to be easy to describe when this is done, the i can say "can you write this any easier" but currently just trying to get to that point, and having to ask at a partial stage means there isnt this example which is nesacary to easily describe the aim
20:31:32 <glguy> Welkin: non-printable characters should be no problem if you're converting them to base64
20:31:59 <glguy> I'm not familiar with scram specifically, so I'm trying to figure that out at this moment
20:32:06 <Cale> fen_: Well, which types are you interested in having zippers for/
20:32:08 <Cale> ?*
20:32:08 <lambdabot> Maybe you meant: v @ ? .
20:32:13 <Cale> hah
20:32:22 <fen_> Cale: that was stated in the type above...
20:32:26 <Welkin> scram is just a way to have both the client and server calculate the same value independently and they send each other nonce values that get appended
20:32:38 <Welkin> and it includes multiple hmac hashing iterations
20:32:42 <Cale> fen_: So, lists, Nonempty, Tree?
20:32:53 <glguy> Welkin: amdj implemented scram in atheme and says you can send him a PM with your question but that he might not be able to get back to you right away
20:32:57 <fen_> thats everything right?
20:32:57 <Cale> fen_: and some particular combinations of them, maybe?
20:33:04 <fen_> yeah, the nested case
20:33:14 <fen_> the Tree is cool because its a depth 2 nested case
20:33:18 <fen_> ah
20:33:20 <fen_> Free aswell
20:33:27 <fen_> you can zipper over that vertically
20:33:28 <Cale> I mean, but are you writing a program for which these zippers are important? Which cases does that program need?
20:33:34 <glguy> Welkin: Do you have some code to paste that we could compare to a spec?
20:33:38 <Cale> We could write the zippers that it needs by hand...
20:33:39 <Welkin> in haskell I could just base64 encode a bytestring, but in javascript I'm working with ArrayBuffers, which don't seem to have an easy way to do this
20:33:39 <fen_> Cale: yes
20:34:02 <fen_> this captures all containers, gives unfoldable and foldable instances trivially
20:34:11 <Cale> "trivially"
20:34:13 <Cale> hahaha
20:34:21 <fen_> basically it collapses Traverse Foldable and Unfoldable 
20:34:25 <fen_> they are not classes
20:34:25 <Welkin> if I use btoa on the buffer it coerces it into a string of the array with elements separated by commas (of course it does haha)
20:34:34 <Welkin> and TextDecoder doesn't seem to do the right thing
20:34:35 <fen_> because it gives all the implementations
20:34:44 <fen_> they are just functions
20:35:01 <Cale> fen_: Have you looked at any/all of the generics libraries?
20:35:05 <Welkin> even using String.fromCharCode seems wrong
20:35:25 <fen_> Cale: this was discussed before
20:35:52 <fen_> we can write all lenses. there is no need to resort to generics
20:36:02 <Cale> ???
20:36:10 <Cale> I mean, you're talking about passing to zippers anyway...
20:36:21 <AJTJ> ok, I'm skipping stack for now
20:36:24 <fen_> well, thats just get and set
20:36:40 <AJTJ> does anyone work with VSCode and have a good linting setup for Haskell
20:36:46 <AJTJ> love to know
20:36:50 <fen_> but they make foldable and unfoldable redundant for a large (if not exhaustive) set of containers
20:37:15 <Cale> AJTJ: Don't bother with linting initially, the linters provide a lot of "helpful" suggestions that if you follow them all, will result in a mess
20:37:17 <fen_> and being partially suspended traversals, Traversable also
20:37:42 <fen_> until this is proven exhaustive the default functions are good enough 
20:37:58 <Cale> AJTJ: They're mostly useful for getting suggestions on things you might've missed, rather than as something you want underlining stuff in your editor
20:38:34 <Cale> and you should take all their suggestions with a giant grain of salt -- use your judgment for what you actually like better
20:38:43 <fen_> so no, it is not obvious that there is a less complex way to achieve this 
20:38:52 <Cale> The typechecker is the more important linter :)
20:39:04 <AJTJ> Cale: what about code formatting?
20:39:13 <AJTJ> I like code formatters
20:39:24 <Cale> AJTJ: Whenever one thing is part of another thing, indent it to a deeper column
20:39:53 <AJTJ> hmm
20:40:03 <AJTJ> Cale: what about typechecker?
20:40:11 <Cale> Typechecker will run inside ghci or ghc
20:40:23 <Cale> You can't compile your program without passing it :)
20:40:34 <fen_> i guess for the Zipper you need get and set which need Container instances, so maybe thats where to start. they need to be recursive instances too
20:41:07 <AJTJ> huh, so nobody uses a linter here?
20:41:29 <fen_> its cool though right? to be able to zipper over arbitrary nestings of non-generic Trees?
20:41:36 <Cale> Personally, I find most of the suggestions inane... occasionally I'll get one or two which I might be like "okay, maybe that's better"
20:41:52 <Cale> Often I'll get suggestions where I'm like "no thanks"
20:42:14 <Cale> Maybe that's just because I'm already writing code which is mostly okay
20:42:23 <Cale> but there are lots of random things it'll complain about
20:43:26 <fen_> Cale: you keep asking to understand the "why" of the code? 
20:43:28 <Cale> AJTJ: One thing I can suggest trying with respect to style is to try to keep most of your alignment to the left edge -- some people like to line up the = signs in equations and stuff
20:44:07 <Welkin> glguy: this is my implementation https://github.com/ericnething/elm-xmpp/blob/master/examples/src/sasl.js#L147
20:44:09 <Cale> fen_: Yeah, just because I feel like this is a deep rabbit hole that you've gone down, and if you were writing a specific program like a compiler or something, I could make suggestions about how else to tackle the specific problem which arose
20:44:33 <Cale> fen_: and when I talk about a specific program, I mean like something that a user would run and it would put stuff on the screen and things would happen
20:44:34 <fen_> so isnt that zipper or traverse over arbitrary nested containers?
20:44:36 <Welkin> resource for the spec https://stackoverflow.com/questions/29298346/xmpp-sasl-scram-sha1-authentication
20:44:49 <Welkin> and the actual spec https://tools.ietf.org/html/rfc6120
20:44:53 <Cale> fen_: Users don't typically run programs to zipper over arbitrary nested containers
20:44:58 <fen_> Cale: you wouldnt ask that of Lens would you?
20:45:04 <Cale> I would, tbh
20:45:14 <Welkin> I think it's just that one part that is messed up (that is where it fails)
20:45:14 <Cale> A lot of Lens, I consider fairly excessive.
20:45:15 <AJTJ> Cale: yea, I get that. I'm not new to coding. I just like a clean style and when I use Prettier with JavaScript (for example) it saves me tons of time. I don't have a fascination with formatting my own code all the time.
20:45:15 <fen_> abstractions rule
20:45:29 <Welkin> converting the byte buffer to text
20:45:57 <fen_> we have established that Lens captures 2 abstractions simultaniously, one of recursion-schemes and one of arbitrary access locations
20:46:14 <fen_> this is an attempt to do just one of those, which seems to be missing
20:46:19 <Cale> AJTJ: Well, the reason I suggest that is just that it results in lots of annoyance if people have to constantly re-align things in the code as names change.
20:46:39 <fen_> allowing people to consider get and set as specific accessors restricted to the first element as they pertain to zippers and traversals
20:47:16 <fen_> having established this aim it is not relavent which programs could be written by users of this
20:47:25 <AJTJ> Cale: esoteric, specific notions of how to line up code aren't as interesting to me as having strong standards that people can agree upon
20:47:28 <fen_> unless a specific example is useful for discussion
20:47:38 <fen_> but then you would just take an easy example
20:47:47 <AJTJ> teamwork stuff :D
20:47:56 <fen_> like the type given in the state unfold above
20:48:31 <MarcelineVQ> that's easy enough, have a style-guide for the team
20:48:47 <MarcelineVQ> such as https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
20:48:59 <Cale> AJTJ: In that case, just indent by 2 spaces or something, and don't worry about aligning stuff very much. Break lines after do and where, maybe not after let? Depends how much that 4 space indent bothers you.
20:49:16 <Cale> I mean, aligning stuff apart from the left edge
20:49:35 <fen_> fen_: Users don't typically run programs to zipper over arbitrary nested containers
20:49:42 <Cale> Oh, and the #1 most important rule for working with other people in Haskell. Don't use tabs.
20:49:59 <fen_> users dont often "fold" over things, or "pass functions as arguments" 
20:50:32 <fen_> i would argue a really large amount of the worlds code secretly consists of zipping over arbitrary nested containers
20:50:35 <Cale> Have your editor produce spaces. Tabs in source code should be considered a lexical error, but they aren't :P
20:50:55 <Cale> (they align to the next multiple of 8 spaces, but most editors won't display them that way)
20:51:27 <AJTJ> interestnig
20:51:32 <AJTJ> thanks for the thoughts :D
20:51:53 <fen_> anyway, its supposed to be used as a representation in the sciences where "nested containers" could consist of systems of interacting components
20:51:59 <fen_> which is quite ubiquitous 
20:52:05 <fen_> free monads are ok
20:52:19 <fen_> but then all the components need to be made of versions of themselfs
20:52:24 <fen_> which is pretty restrictive
20:53:02 <fen_> traversing over arbitrary nested containers is basically the business 
20:53:39 <fen_> so in seeking that abstraction, why ask for a specific example, other than as a trivial test case?
20:53:48 <Cale> fen_: I would recommend actually writing a real executable program which is going to make heavy use of your library, and try to see if the library is actually helping, or if there's some obvious other way of moving forward.
20:54:11 <Cale> It's not trivial, it's very important to having *good* abstractions in the end
20:54:23 <Cale> There are infinitely many possible abstractions
20:54:30 <fen_> i have tests from a few years ago on much simpler things, basically just a 2d grid interacting with a 1d strand
20:54:42 <Cale> and only some of them are especially usable
20:54:50 <fen_> the idea was to make the strand cyclic, and to extend it to arbitrary dimensionality
20:54:54 <Cale> and having a real-world use case keeps you honest
20:55:20 <fen_> polygon self assembly in a 2d fluid?
20:55:31 <Cale> Every abstraction should be constructed in anger with something less abstract
20:55:47 <fen_> if you need an imagination of what the simulation you describe might be like
20:55:59 <MarcelineVQ> is there a haskell -> js method of some kind that creates readable js? as in js you could load up in an editor and hack on afterwards. do fey or jmacro fit that bill?
20:56:29 <Cale> There should be a good reason that the less abstract thing is not doing its job well -- the code is buggy because it admits details which it shouldn't, or the code is excessively repetitive, or some such thing.
20:56:55 <fen_> well, 1 its not easy to extend this to high dimensional settings
20:57:01 <Cale> If you come up with abstractions randomly, you might hit on something which saves you from situations that aren't really problems to begin with.
20:57:08 <MarcelineVQ> more restrictivey, is there js generation that you could hand the js files to someone else to work on and they won't struggle through endless function calls or nonsensicle var names
20:57:30 <fen_> 2 its difficult to make deep complexes of different components at different length scales
20:57:46 <Cale> (and you probably will, unless you have a *tooooon* of experience and... well, that's basically the same as knowing all the examples you want to abstract over)
20:57:46 <fen_> randomly!?
20:58:06 <fen_> its a systematic derivation of a fundamental abstraction
20:58:13 <fen_> your comments are quite bizzare
20:58:19 <MarcelineVQ> idris at least creates a nest of function calls that makes the js pretty difficult to just dig into. partly due to specialization I think
20:58:50 <fen_> what am i going to do today, well ill just randomly come up with abstractions and bother Cale with them for no reason
20:59:21 <glguy> Welkin: What does this mean, I don't know the backtick syntax:         const clientFinalMessage = `${clientFinalMessageBare},p=${btoa(clientProof)}`;
20:59:39 <glguy> I guess I'm not really in the right channel
20:59:39 <Cale> fen_: I consider it random if you don't already have a program and a goal of improving the problems you're having maintaining that program.
20:59:54 <fen_> a good plan
21:00:24 <Welkin> a template string
21:00:37 <fen_> well ok, what about ASTs?
21:00:42 <Welkin> the ${} are interpolation markers
21:01:09 <Cale> fen_: and then you can consider the question "do I really need this?", "is this easier or more complicated in the end than what I was doing before?" "does it systematically eliminate potential for bugs that were actually occurring while I was working on my program?"
21:01:16 <fen_> sure you programing folks can write compilers and web apps better if you can structure your language as a hetrogenous hylomorphic cyclic graph?
21:02:13 <fen_> Cale: it provides instances for all the most fundamental haskell classes for any user defined container!!!
21:02:21 <fen_> how is that not a helpful thing!?
21:02:37 <fen_> "do i really need this"
21:02:50 <Cale> So what? Lots of things provide instances for those classes.
21:03:16 <fen_> no, just keep writing them algoritmically using generics and hiding the actual implementation from the user, or overstepping the nesacary abstraction and using lenses, with similar obfuscation
21:03:25 <fen_> sure my code might be completely illegible
21:03:40 <fen_> but it manages what huge behemoth libraries do in like 3 pages!
21:04:07 <Cale> Even if your goal is purely to do mathematics, the best abstractions always come from taking a whole ton of examples of things which people have tediously proven analogous things about them, and saying "here's what these examples all had in common, and I can now prove those things once and for all, and the proof will apply to everything"
21:04:44 <fen_> sure, it would have been impossible without the foundations provided by these things
21:05:10 <fen_> but to just fail to appreciate the utility of the approach is not pragmatic  
21:05:25 <roconnor> Cale: that or if category theory has named it, just use that abstraction. :P
21:05:35 <Cale> Or: here are a bunch of programs which are all very similar, and this is what they have in common, and here's a polymorphic/parametric program which specialises to all of them
21:05:51 <Cale> roconnor: Well, everything in category theory is like that too
21:06:03 <roconnor> Good point.
21:06:19 <fen_> how is "implementing (almost) all unfoldable/foldable/traversable" things not doing exactly that?
21:06:22 <Cale> All the common definitions you get in category theory only exist because we've done every one of them 16 times over in every branch of mathematics
21:06:30 <roconnor> I suppose the minor difference is that someone else has gone through the trouble of finding a whole tone of examples already.
21:06:46 <fen_> its such a far reaching abstraction though
21:06:56 <fen_> same as with lens, you can use it for most things!"
21:07:04 <fen_> so everything is a pottential use case
21:07:07 <Cale> Right, it's okay to take other people's programs and use those to find the abstractions which will clean their code up
21:07:27 <fen_> "what are you going to use this /language/ for?" - "any possible program!?"
21:07:57 <Cale> You *can* use lens for most things, it doesn't mean you *should* use it for most things. Lens has its place, but I've seen it overused to death by intermediate Haskell users a *lot* lately.
21:07:58 <fen_> "well, you need to have a program in mind, or there is no point"
21:08:03 <fen_> dud philosphy
21:08:37 <Cale> There will be far more straightforward ways of doing things, and I'll have to deal with a nigh-incomprehensible line of type tetris with traversals that might even sometimes do the wrong thing.
21:08:53 <Cale> and it's really getting on my nerves tbh :)
21:09:12 <fen_> its horrible! 
21:09:16 <fen_> i cant read any of it!
21:09:21 <fen_> brarg!
21:09:23 <Cale> I will take a nested sequence of case expressions 5 pages long over that any day of the week
21:09:47 <Welkin> glguy: I linked you the wrong rfc earlier, here it is https://tools.ietf.org/html/rfc5802
21:09:51 <Cale> (well, 5 pages is a bit extreme...)
21:09:55 <fen_> bring back fortran!
21:10:04 <Cale> Usually it's like, 3 lines instead of one
21:10:14 <Cale> except that they're crystal clear, entirely in Haskell 98
21:10:26 <Cale> and obviously correct
21:10:34 <fen_> right, we can marvel at the expressive power of fold all day!
21:10:53 <fen_> and then if we can manage to write almost every possible instance...
21:11:01 <maerwald> Cale: I guess you don't like prisms then xD
21:11:08 <glguy> Welkin: I'd already switched to that one
21:11:26 <Cale> maerwald: There are always exceptions where even I will use prisms, but I won't use prisms spuriously when I don't need to
21:11:45 <Cale> I will use prisms as a last resort after trying every simpler thing I could do
21:11:59 <Cale> and finding that it doesn't capture what I'm trying to express
21:12:09 <fen_> i do not look forwad to this "prisms" of which you speak
21:12:33 <Cale> They're just "lenses that can fail to match"
21:12:49 <Cale> expressed in an insane way using profunctors
21:12:59 <maerwald> it's a thing that almost always compiles, but you won't be sure it does what you want xD
21:13:23 <Welkin> glguy: https://tools.ietf.org/html/rfc5802#section-5 I
21:13:34 <Welkin> I'm looking here for a test case
21:13:38 <Welkin> I think this is it
21:13:49 <roconnor> prisims are a little more tha lenses than can fail to match (lenses that can fail to match are affine traversals)
21:14:21 <roconnor> prisims also let you construct the variant that it matches.
21:14:24 <fen_> are they physical?
21:14:35 <fen_> do we find prisms in nature?
21:14:47 <fen_> otherwise ill just stick to updating things with fmap
21:14:48 <Lycurgus> they are metaphorical
21:14:48 <Cale> fen_: I don't know what that even means.
21:15:02 <maerwald> can you find Functors in nature?
21:15:02 <Cale> fen_: None of this is physical, or all of it is
21:15:09 <roconnor> I mean prisms are to variants as lenes are to fields.
21:15:19 <Lycurgus> and yes, rainbows, etc.
21:15:21 <fen_> if its just for code then it cant be used for representing the manipulation of structures found in science
21:15:22 <Cale> roconnor: Okay, that's a better way to put it
21:15:57 <fen_> like, a DSum molecule would be pretty crazy
21:16:06 <fen_> nooo, mind blown
21:16:38 <Cale> fen_: "Can be used for science" is pretty arbitrary and unpredictable.
21:16:43 <roconnor> I usually think of prisms as something that would be useful for code that has a complicated set of exceptions you want to catch.
21:17:00 <roconnor> The sort of code I'd try to avoid writing in the first place. :D
21:17:20 <Cale> fen_: "Has been used in science" is a better measure perhaps? But relying on scientists to use everything they perhaps ought to use is unreliable
21:18:49 <roconnor> Prisms let you make a abstract type of expections in order to allow it to be extensible.  You provide prisms to various concrete exceptions, and you can safely add more exceptions as things get more complex.
21:19:31 <Welkin> okay, with that test case, my client proof is totally wrong, but I don't know if it's because of encoding or something else
21:19:35 <roconnor> Similar to how in lensy situtaitons you can make a record type abstract and add more lenses if you need to extend it with more fields.
21:19:40 <Cale> roconnor: Haha, "Great! Now don't do that!"
21:20:09 <roconnor> I guess I've never tried that.  Normally I just use String for my exceptions and forget about them.
21:20:14 <Cale> hahaha
21:20:44 <Cale> Well, I guess it depends on the use case
21:20:55 <Cale> Sometimes String is fine enough.
21:21:14 <Cale> Sometimes just returning an Either or something would be a little nicer.
21:21:35 <Cale> I mean, an Either of some data type you've defined
21:23:40 <roconnor> I'm enmored with some James Mckenna / Conor McBride work where the type (Either ErrorData ParsedData) is isomorphic to SourceData, which implies the ErrorData is exactly enough to capture all the data of invalid data.
21:24:13 <roconnor> But ain't nobody got time for that.
21:28:43 <Cale> haha, yeah, that sounds awesome, if you can do it at all
21:29:25 <Cale> Well, you could always return unparsed input :P
21:31:05 <roconnor> Here is some math to get you started: http://blog.sigfpe.com/2007/09/type-of-distinct-pairs.html
21:32:17 <Cale> This reminds me a bit of "Seven trees in one"
21:51:32 <sicklorkin> Is it possible to calculate missing sequences for structured alpha numeric data? e.g. A..X,Z would compute Y or AA,BB,DD,A,D,E would compute CC,B,C and finally 20..8,5,4,1 would compute 7,6,3,2?
21:51:58 <sicklorkin> w/o having an Ord/Enum instance?
21:59:54 <jle`> sicklorkin: that's kind of an unsolved problem, heh
22:00:10 <jle`> the best you can do is program in special cases
22:00:34 <jle`> also, you might be misinterpreting the role of typeclasses
22:00:59 <jle`> you need some sort of typeclass if you want to make something polymorphic over different types
22:04:09 <sicklorkin> jle`: what about some kinda bijective numeration kinda thingy over all bases? I think excel solves this problem pretty well already - I guess this is what they do?
22:04:43 <jle`> excel programs in a bunch of special-cases, yeah
22:05:00 <jle`> they don't have any general-case solutions
22:05:49 <jle`> try dragging 27, 82, 41, 124, 62, 31 ... and seeing if it completes the hailstone sequence for you ;)
22:06:18 * sicklorkin curious to see
22:08:40 <sicklorkin> is the next number 65.4666666667?
22:08:42 <sicklorkin> ;)
22:16:21 <jle`> it's supposed to be 94, 47, 142, 71, 214 ...
22:23:12 <Welkin> at least I've been able to verify which parts work
22:23:40 <Welkin> now if I can find a known valid implementation of the hash iterations function I can test that
22:24:02 <Welkin> I have one in erlang
23:52:25 <akr> Hi!
23:52:38 <akr> How can I write this idiom in a better way? https://gist.github.com/osense/bb8caf725ce75ea7fdf17b1371cd388c
23:57:18 <akr> I can use MonadPlus to combine all the maybes into one, but then I don't know which one was Just
23:57:32 <dminuoso> akr: lens?
23:57:49 <akr> ah okay I haven't learned about lenses yet
23:58:03 <dminuoso> akr: The details depend a bit on what you intend to do afterwards relaly
23:59:13 <akr> dminuoso: something like this https://gist.github.com/osense/bb8caf725ce75ea7fdf17b1371cd388c
23:59:16 <dminuoso> akr: I think this might be a case of boolean blindness.
