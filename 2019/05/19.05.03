00:00:13 <dminuoso> akr: Semantically that looks like `data OneOfThree a b c = One a | Two b | Three c`
00:00:48 <akr> well, multiple results can be Just
00:01:03 <jle`> akr: that's a type error, isn't it?
00:01:16 <jle`> akr: should the last line be _ -> error "" ?
00:01:26 <akr> oh yeah
00:01:42 <jle`> you can do something along the lines of Alternative/MonadPlus
00:01:45 <dminuoso> akr: Is the inner type of the Maybe's the same in all three?
00:01:50 <dminuoso> Or does it vary?
00:01:57 <akr> it's the same
00:02:11 <jle`> asum [doActionA <$> f, doActionB <$> g, doActionC <$> h]
00:02:28 <jle`> asum [x,y,z] = x <|> y <|> z, if you prefer the explicit <|> version
00:02:59 <jle`> <|> = mplus, if you're familiar with MonadPlus and not Alternative
00:03:07 <dminuoso> % let dat = (Just 'c', Just 'b', Nothing)
00:03:07 <yahb> dminuoso: 
00:03:13 <dminuoso> % dat ^? each._Just
00:03:13 <yahb> dminuoso: Just 'c'
00:03:39 <akr> jle`: ah, cool
00:03:51 <jle`> dminuoso: doesn't quite work here because actionA vs. actionB vs. actionC
00:04:03 <dminuoso> jle`: Ah we can fix that.
00:04:12 <jle`> yeah, you can pre-fmap and things work out the same way
00:04:43 <jle`> at that point the fmaps will give you a list of all the same values, and preview (each @[] . _Just) is just asum :)
00:04:51 <dminuoso> Though I'd probably prefer asum anyway
00:04:55 <jle`> er, each @[Maybe (IO ())] or something
00:05:19 <MarcelineVQ> but what happens after
00:05:21 <jle`> the version with explicit <|>'s is probably what i'd prefer
00:05:33 <jle`> but i'm not sure how the fixities interact with <$>
00:06:36 <akr> I like the asum version, as it's easier to extend in the future
00:06:53 <dminuoso> % transposeOf traverse [[1,2,3],[4,5,6]]
00:06:53 <yahb> dminuoso: [[1,4],[2,5],[3,6]]
00:06:55 <dminuoso> Oh this is cool :)
00:07:18 <jle`> akr: but yeah, that gives you a Maybe (IO a), or whatever you want
00:07:36 <jle`> akr: also be aware that using error is pretty bad for actual code, and especially in IO
00:07:43 <jle`> if your goal is to exit the program as a runtime exception
00:08:34 <akr> no, the goal is to produce some error message that is then caught somewhere higher up and logged, and life goes on :)
00:08:47 <jle`> also it might be nice to note here that being to fmap IO actions over Maybe, and only execute the first Just of the three, is a really nice showcase of why "first class statements"/IO-as-a-data-type is so powerful
00:08:59 <jle`> akr: ah yeah, but the problem is that 'error' can't really be meaningfully caught
00:09:04 <jle`> try using throwIO (userError "blah") instead
00:09:13 <jle`> (if you're in IO)
00:09:52 <dminuoso> akr: Try catching an exception thrown by error. Also try knowing where in your program errors can bubble up.
00:10:07 <dminuoso> error is probably the most frustrating thing in Haskell. :(
00:10:30 <akr> hmm errors thrown by error are routinely caught
00:11:12 <akr> also it produces a nice stack trace in a profiling build 
00:11:36 <jle`> you're relying on undefined behavior D:
00:11:38 <dminuoso> akr: You can produce stack traces yourself too.
00:11:43 <dminuoso> With supported features.
00:12:15 <dminuoso> akr: Another issue with catching error is that its highly non-specific. Did you just catch the failure of your pattern match or perhaps a failed `tail`?
00:12:20 <jle`> also, why would you need a stack trace if you're catching it, heh
00:12:52 <dminuoso> And because its non-specific you cant recover.
00:13:03 <jle`> `error "" :: IO a` can't be reliably caught, since it isn't an IO exception and so lives outside of the io exceptions method of haskell 
00:13:13 <dminuoso> Since you'd need to understand the error and deal with it, but at that point you are forced to do this with your type system
00:14:01 <akr> recovering is not a concern
00:14:03 <jle`> if your IO action is "throw an IO exception here", then that's throwIO (whatever exception).  'error ""' doesn't have that semantics, it's essentially undefined behavior
00:14:11 <akr> also, there are libraries that use error
00:14:20 <dminuoso> akr: And those libraries *suck* to use.
00:14:21 <jle`> libraries aren't supposed to use error as control flow
00:15:08 <jle`> akr: didn't you say that the goal is to be caught within haskell? unless you mean caught outside of the haskell application after the program exits
00:15:10 <dminuoso> akr: I get annoyed every time I see `read: no parse` screwing with my program. Majorly.
00:15:24 <akr> dminuoso: heh, yeah, that sucks
00:15:38 <akr> jle`: yup, catching in haskell
00:15:38 <jle`> and yeah, error is not control flow.  it can't be used as control flow, can't be reliably caught, has undefined behavior at runtime, etc.
00:15:48 <jle`> akr: so, why would you say that recovering si not a concern?
00:16:01 <jle`> "catching and handling" is recovering
00:16:31 <akr> fair enough, I meant in the context of knowing what kind of an error it was so that you can recover in different ways
00:16:38 <akr> I only need to recover in one way
00:16:44 <jle`> ah yeah. error can't be recovered *at all* reliably
00:16:49 <jle`> in any way, 0, 1, or many
00:17:11 <akr> well, it's been in production for ~10 years and it seems to be working fine :P
00:17:21 <dminuoso> My granddad is 80 and he smokes.
00:17:21 <jle`> if you are using something that appears to let you do so, you're relying on undefined behavior
00:17:31 <akr> jle`: could be
00:17:33 <dminuoso> akr: ^- your point being? :-)
00:17:41 <jle`> akr: sure, but why not just switch to throwIO and have defined behavior and semantics? :p
00:17:50 <jle`> is there an emotional attachment here
00:18:09 <akr> dminuoso: point being that even though it may not be pretty, it currently works
00:18:13 <akr> jle`: the problem is lack of time
00:18:25 <akr> to perform a meaningful refactor of all code
00:18:29 <jle`> in the time it took us to have this discussion, you could have easily changed one line of code ;)
00:18:34 <jle`> akr: you don't have to refactor all the code
00:18:37 <jle`> you can just change this single line
00:18:51 <jle`> and be happy that your code is 1% safer
00:18:57 <akr> there's hundreds of `error` statements
00:19:07 <dminuoso> akr: Every 1% safer is time saved down the road when you need to debug a regression after a GHC upgrade
00:19:27 <jle`> akr: nobody is asking you to change all of your error statements, heh
00:19:42 <jle`> we're just letting you be aware that using error in IO for control flow is undefined behavior 
00:20:00 <jle`> and usage of throwIO is more defined and and semantically valid
00:20:12 <jle`> so is objectively better within IO
00:20:27 <akr> what would I use in a MonadIO
00:20:29 <akr> ?
00:20:30 <jle`> whether or not you use that information to sink the time into changing all of your error's is now a value call for you
00:20:47 <jle`> akr: (lift . throwIO) ?
00:20:47 <dminuoso> % :t throwIO
00:20:47 <yahb> dminuoso: Exception e => e -> IO a
00:20:50 <dminuoso> akr: ^- 
00:21:10 <jle`> er, (liftIO . throwIO)
00:21:11 <akr> ah, right
00:21:32 <jle`> also error in an arbitrary MonadIO is a thousand times worse and less well-defined than error in IO, heh
00:21:46 <dminuoso> I wonder why throwIO is not defined with MonadIO
00:21:54 <jle`> some libraries also provide pre-lifted IO actions, for actions like throwIO and ptuStrLn etc. if you don't want to explicitly lift
00:22:01 <jle`> dminuoso: the same reason why putStrLn is not, presumably
00:22:07 <dminuoso> jle`: And that is...?
00:22:34 <dminuoso> Less confusion for beginners?
00:22:50 <jle`> hm, i can think of some pros and cons, but i'm not sure the exact reason why it was chosen.  just that whatever reason was chosen for one was also chosen for the other
00:23:01 <jle`> better error messages/confusion for beginners would be a big one yeah.
00:23:38 <jle`> akr: we can't argue if changing all of the error's in your code base is a worthwhile time investment
00:23:56 <dminuoso> I would simply replace an error every time I encounter one.
00:24:08 <dminuoso> Sort of cleaning up a spot you happen to already be in
00:24:10 <jle`> akr: we're just talking about how throwIO is more meaningful/semantically defined than error in IO 
00:24:38 <jle`> what actions you take from it are up to you, we're not going to follow up to judge you later :p
00:24:45 <dminuoso> jle`: Curious though, whats the big deal with `error` specifically in `IO`?
00:24:47 <akr> yup, I get it :) thanks for the information. I'll be on a train later today so I'll look into it, I want to read a bit more about error
00:24:56 <akr> by the way, is there something else I should be aware of if I'm raising exceptions in code that's wrapped in `rdeepseq` and `evaluate`?
00:25:23 <jle`> one blurred layer of meaning here is when you say "raising exceptions"
00:25:28 <maerwald> error is for... errors, things that shouldn't happen. Don't throw exceptions for things that are not meant to be caught
00:25:36 <jle`> 'error' does not raise exceptions
00:25:44 <maerwald> exactly
00:26:15 <jle`> the minute you talk about exceptions, handling exceptions, throwing/raising exceptions, etc., error is now in a completely different universe
00:26:22 <dminuoso> jle`: Ah you mean its not specified as such in the report.
00:26:23 <maerwald> yes
00:26:24 <jle`> it has nothing to do with exceptions
00:26:33 <maerwald> and exceptions are not for errors.
00:26:49 <dminuoso> akr: The Haskell report has the following to say about `error`:
00:26:55 <dminuoso> When evaluated, errors cause immediate program termination and cannot be caught by the user
00:27:35 <maerwald> Don't throw exceptions for things that are not meant to be caught
00:27:42 <maerwald> use error :)
00:27:52 <jle`> *semantically*, errors are *values* that are "bottom", _|_
00:28:05 <akr> I don't get why `catch` catches them then, though
00:28:13 <jle`> other bottoms include things like nonterminating computations, `sum [1..]` etc.
00:28:28 <jle`> akr: it's...a precarious cascade of undefined behavior
00:28:50 <dminuoso> jle`: Id say its actually well defined behavior. `catch` is completely divergent.
00:29:00 <jle`> it actually breaks the semantics of haskell
00:29:29 <dminuoso> The report very clearly states that a call to error terminates the program, producing some nice diagnostics, and cant be caught.
00:29:32 <jle`> the fact that error can be "caught" breaks the underlying semantics of haskell values and data types
00:30:33 <akr> jle`: why? haskell is already inconsistent, as you mentioned due to nonterminating computations
00:30:35 <jle`> haskell's semantics say that undefined, error "hi", etc, are indistinguishable from any divergent computation
00:30:45 <akr> oh, hmm
00:30:52 <dminuoso> akr: Its not inconsistent.
00:30:57 <jle`> so the fact that it can be distinguished breaks the semantics
00:31:03 <dminuoso> akr: nonterminating computations are assigned bottom, its very well defined actually.
00:31:18 <jle`> you could say that it breaks the semantics for "practical" reasons, but...
00:31:34 <akr> I mean from the point of view of logic, you can construct values / proofs of ⊥
00:31:48 <jle`> yeah, but all values of _|_ are supposed to be indistinguishable
00:31:58 <dminuoso> akr: you just cant recover any information from _|_ because any values of it are indistinguishable
00:32:10 <jle`> the reason why you can "catch" error is a part of the weird interplay between execution (IO) and evaluation in Haskell
00:32:15 <akr> okay, interesting
00:32:37 <jle`> in Haskell, IO triggers evaluation
00:32:42 <jle`> (lazily)
00:32:47 <jle`> or at least, in GHC haskell
00:33:10 <jle`> so an IO action could potentally trigger the evaluation of _|_
00:33:37 <jle`> error ""/undefined can be thought of like runtime "flags" on values that say "yup i can tell you right now that this is bottom, abort right now before going on forever"
00:34:07 <jle`> during the process of *evaluating* a value
00:34:47 <jle`> this "flag" only gets triggered upon the process of evaluating a value
00:35:09 <jle`> so now you have a problem: evaluation in Haskell is a nondeterministic process
00:36:11 <akr> right
00:36:16 <jle`> GHC reserves the right to re-order and restructure the process of evaluation as long as it preserves semantics...so the actual evaluation of values should be treated as nondeterministic. it can even change depending on optimization flags
00:36:55 <jle`> so "when" the error explodes is undefined
00:37:15 <merijn> akr: In fact! GHC doesn't even promise to actually lazily evaluate everything! It just promises to deliver results AS IF it has
00:37:49 <merijn> (else optimisation like strictness analysis and unboxing wouldn't be correct)
00:38:01 <jle`> so, the reason why putStrLn "hello" >> error "goodbye" explodes is not because any exceptions that are being thrown or raised
00:38:25 <jle`> it's because `putStrLn "hello" >> error "goodbye" :: IO ()` is *a value* that GHC is trying to evaluate
00:38:45 <akr> jle`: okay, I get that
00:38:48 <jle`> remember that in haskell, IO is a value. it can be thought of as a lazy tree
00:39:05 <jle`> so it's equivalent to saying `1 : 2 : undefined`
00:39:46 <jle`> so here's a weird part about how haskell evaluation and execution interplays together: haskell executes an IO action, but in order to know how to execute an IO action, it first has to evaluate that IO action to see what it is
00:39:54 <jle`> "is it putStrLn? is it getLine? is it readFile?"
00:40:26 <maerwald> s/haskell/GHC/
00:40:28 <dminuoso> jle`: Interesting, so strictness analysis could force that evaluation much sooner than it executes any previous actions?
00:40:53 <dminuoso> Would it be reasonable for a program `putStrLn "Hello" >> error "goodbye"` to not print "Hello" at all?
00:41:43 <phadej> no
00:41:53 <dminuoso> phadej: Why not?
00:42:04 <merijn> dminuoso: I don't think so, because that'd mean >> is strict in the right hand which seems needlessly confusing
00:42:22 <merijn> dminuoso: I wouldn't say it's necessarily wrong, but that's because IO is super unspecified in the report
00:42:47 <merijn> So, let's go with "not unreasonable in the letter of the law, but certainly unreasonable in the spirit
00:42:55 <jle`> i think it's 'important' that >> is not strict on the RHS, otherwise 'forever' wouldn't work
00:43:04 <jle`> forever x = x >> forever x
00:43:20 <merijn> jle`: Wouldn't it?
00:43:36 <merijn> That's not the definition of forever, though
00:44:37 <merijn> jle`: You could still easily do the current definition like "forever act = let x = act >> x in x"
00:44:41 <jle`> using listy things as an analogy, it'd say it's like repeat x = x :|> repeat x, from Data.Sequence
00:45:22 <jle`> @let repeatSeq val = let x = val :<| x in x
00:45:24 <lambdabot>  .L.hs:169:29: error:
00:45:24 <lambdabot>      • Data constructor not in scope: (:<|) :: t -> t1 -> t1
00:45:24 <lambdabot>      • Perhaps you meant one of these:
00:45:31 <jle`> er, x :<| repeat x.
00:45:53 <jle`> @let repeatSeq val = let x = val Seq.:<| x in x
00:45:54 <lambdabot>  Defined.
00:46:38 <jle`> repeat x = x : repeat x only works becuase : is lazy on RHS
00:47:27 <jle`> akr: but yeah, i guess my point is that the reason error blows up is not because of any exception mechanism being used, but rather due to the interplay between evaluation and execution in IO
00:47:56 <merijn> jle`: Sure, but I don't think the report defines a strictness for >>? Although non-strict semantics means lazy right hand is the most natural interpretation, yes
00:48:02 <jle`> akr: contrast that to *actual* exceptions, which are a tool used in IO to do control flow exactly like what you are trying to do, with those exactly defined semantics as IO
00:48:34 <maerwald> I think it's clear that error is not an exception
00:48:35 <jle`> merijn: right, the report might not define a strictness for (>>), but i don't think forever would work if (>>) was strict on RHS
00:49:11 <jle`> > repeatSeq 1 Seq.!? 0
00:49:14 <lambdabot>  *Exception: <<loop>>
00:49:19 <merijn> jle`: honestly, your definition of forever wouldn't work with non-strict RHS for >> either :p
00:49:35 <jle`> shouldn't it? :O
00:49:37 <merijn> jle`: You'd blow up the pattern stack in all likelihood due to infinite bind buildup
00:49:49 <merijn> jle`: That's why it's defined like fix as in my example
00:49:59 <jle`> % let jleforever x = x >> jleforever x
00:49:59 <yahb> jle`: 
00:50:21 <jle`> % jleforever (putStrLn "hi i hope yahb doesn't print infinitely many lines")
00:50:22 <akr> jle`: I see, thanks for the explanation :)
00:50:26 <yahb> jle`: hi i hope yahb doesn't print infinitely many lines; hi i hope yahb doesn't print infinitely many lines; hi i hope yahb doesn't print infinitely many lines; hi i hope yahb doesn't print infinitely many lines; hi i hope yahb doesn't print infinitely many lines; hi i hope yahb doesn't print infinitely many lines; hi i hope yahb doesn't print infinitely many lines; hi i hope yahb doesn't print infinitely man
00:51:12 <jle`> akr: np :) i do sympathize with your argument for "keeping" error in your codebase, and it's a completely valid action. my point was to compare and contrast the semantics of both and why one is more meaningful than the other
00:51:50 <maerwald> meaningful?
00:52:00 <maerwald> You can also use exceptions wrong
00:52:34 <merijn> maerwald: Less likely to be subtly wrong, though.
00:52:44 <merijn> jle`: What was the argument for keeping error?
00:53:17 <maerwald> merijn: well, I think exceptions for things that are not recoverable is, for example, a popular case and not that rare
00:53:59 <maerwald> if you can't catch it, it's not an exception ;)
00:54:33 <jle`> merijn: one of the arguments would be that there would be time sunk into the refactoring of a large codebase, with little actual concrete gain because GHC haskell somewhat reliably behaves in a consistent way that makes this "work"
00:54:49 <maerwald> and yeah, sometimes you will end up forcing values where you know there might be an error instead of a value
00:55:33 <jle`> also i do agree that for debugging, error might be more useful
00:55:49 <jle`> well, i guess it is objectively more useful, because it functions as a debugging tool
00:55:55 <jle`> whereas io exceptions...not really
00:56:04 <jle`> debugging/interactinve programming
01:01:24 <merijn> hmm, is it parseable or parsable?
01:02:13 <jle`> hard to make a judgment
01:05:32 <merijn> jle`: wiktionary says both are correct
01:05:56 <merijn> On a completely unrelated note, wtf is up with all these trivial syntax proposals popping up
01:06:18 <merijn> Like this new qualified import syntax and the 15th suggestion to switch :: and :
01:06:37 <merijn> Why are people so insistent on breaking everything for utterly minor syntactical things
01:06:54 <jle`> i think the github repo has made the barrier of entry to submitting proposals smaller these days
01:07:12 <merijn> Like, it was a massive struggle to get AMP done and that had real, tangible benefits, but now we're getting 10 different stupid syntax suggestions...
01:07:20 <merijn> jle`: Sure, but why are they getting *accepted*?
01:07:35 <jle`> that's the question
01:08:31 <maerwald> merijn: guess a lot of people are on vacation
01:08:44 <maerwald> so they are bored and think of syntax :P
01:08:45 <merijn> The qualified import thing has cost and drawbacks "The implementation of the change is but a few lines (Parser.y for the grammar and RdrHsSyn.hs for warnings/errors). The increased flexibility comes with no discernible drawbacks."
01:08:53 <jle`> also i don't know why anyone would bother trying to keep a syntax highlighter or any external tooling for haskell these days
01:09:04 <merijn> I mean, really? No discernible drawbacks? You're breaking every non GHC tool
01:10:56 <jle`> yeah it was weird reading that section
01:11:41 <jle`> well, i'm not too concerned about the code breakge for a proposal like that; it's essentially an either-or thing that you can flip
01:11:59 <jle`> it doesn't seem concerned with being "the" way, just "a" way
01:12:12 <jle`> what i'm more concerned about is the needless fracturing of the ecosystem ...
01:12:36 <jle`> any external tooling has to implement both, and you have to switch your state of mind when switching between projects
01:13:32 <maerwald> it's supposedly health for your mind though
01:13:37 <merijn> I mean, there are lots of warts in Haskell that I'd do differently if I was starting from scratch, but we aren't starting from scratch...
01:28:54 <Rembane> Aren't there language extensions for Haskell so that you can almost write your own syntax? 
01:31:04 <merijn> Rembane: RebindableSyntax?
01:32:32 <Rembane> merijn: Yes, I think that's the one. 
01:33:04 <jle`> it doesn't let you write your own 'syntax' per se; it just lets you use haskell's syntax to do different things heh
01:33:27 <merijn> Rembane: That just replaces all occurences of function in syntactic sugar (i.e. do notation, list comprehensions) with their name, rather than the Prelude equivalents
01:34:36 <Rembane> jle`, merijn: Okay, got it. I got it mixed up. 
01:40:53 <merijn> Given "Typeable a => a" is there a convenient way to get a string naming the type?
01:42:24 <dminuoso> Rembane: quasiquotation?
01:42:40 <dminuoso> I think thats what you might be looking for.
01:42:57 <jle`> merijn: show (typeRep @a) ?
01:43:17 <jle`> from Type.Reflection, not Data.Typeable
01:44:09 <merijn> jle`: Turns out the TypeRep returned by typeOf has a show instance that's just a type :)
01:45:31 <Rembane> dminuoso: That could work too. Will it let me replace all :: with : ? :)
01:45:55 <merijn> Rembane: No, thank god :)
01:45:57 <jle`> ah yeah, both TypeRep types have the same Show instance :)  was mentioning that to say that typeRep @a might be more convenient than typeOf (Proxy @a), unless you have a 'p a' hanging around already
01:46:06 <dminuoso> Rembane: Well yeah...
01:46:45 <dminuoso> Rembane: Your QQ just needs to be able to parse Haskell. But its certainly possible..
01:47:51 <merijn> jle`: typeOf takes a value, not a proxy
01:48:12 <jle`> oh ah yeah. same deal then, (undefined :: a)
01:48:16 <merijn> jle`: So you can just do "typeOf True" or something
01:48:26 <jle`> unless you have a value on-hand
01:49:41 <Rembane> merijn: :D
01:50:05 <Rembane> dminuoso: That sounds like it could turn nasty real quick. I think regexen is a better solution. :D
01:51:30 <merijn> Or just learn to accept life and use :: >.>
01:51:36 <jle`> #def :: :
01:52:51 <__monty__> jle`: Isn't that backwards?
01:53:00 <jle`> #def : ::
01:53:13 <Rembane> merijn: I don't mind either, I'm just exploring the solution space. :)
01:53:33 <Rembane> What happens if you use both of jle`s defs? :)
01:54:06 <__monty__> Oh, forgot about (:).
01:54:11 <merijn> Sadness :p
01:57:20 <merijn> hmm, persistent doesn't have a function that returns the SqlType of a PersistValue, does it? I don't want to write out a mapping for each constructor :\
02:39:29 <delYsid`> How do I make a newtype an instance of Prim for Vector.Unboxed?
02:40:03 <delYsid`> I have newtype Foo = Foo Word16 and would like to use a Foo in an Unboxed Vector
02:41:07 <ziman> i don't think you can even tell what the SqlType was; a PersistText could well be SqlCustom "varchar(42) character set boo" or something
02:42:53 <ziman> even more so for the numeric types, i guess
02:47:40 <merijn> delYsid`: For newtypes you can just use GeneralisedNewtypeDeriving for Unbox, I expect
02:48:43 <delYsid`> hmm, that doesnt appear to work.
02:48:45 <merijn> delYsid`: Prim instance are for Vector.Primitive, not Vector.Unboxed
02:50:03 <delYsid`> I seem to be confused.  Unbox needs MVector and Vector instances.  When I try to define a MVector instance for my newtype, it complains that there is no Prim instance.
02:51:52 <merijn> delYsid`: Sounds like you're mixing imports from different modules of Vector
02:54:08 <delYsid`> possible.
04:41:31 <eirslett> Hey! Could anybody please help me a little bit with a Yesod challenge? I'm trying to use the urlRender function, but I cannot make the type system work... I have hardcoded a URL in my code, but I would like it to "guess" hostname based on the client request, instead of being harcoded or configured: https://github.com/navikt/repo-tools/blob/master/src/Auth/Oidc.hs#L52
04:44:48 <eirslett> I tried this, but it doesn't work... https://github.com/navikt/repo-tools/commit/e88115d635dd21c2eba948b144496b5511c10df4
04:55:38 <[exa]> eirslett: "doesn't work" in what way? If you have error message from ghc or some example of erroneous output, it will probably help a lot if you can share it.
04:57:22 <eirslett> It doesn't compile because of some wrong types... I will paste the output, just a second
04:58:28 <eirslett> This is the compiler error: https://pastebin.com/ZDYV4reZ
05:02:35 <[exa]> doesn't seem like a wrong type, it's probably just missing import for StaticR
05:08:56 <eirslett> I'm not sure StaticR is even right, isn't it for static assets like js/css?
05:09:51 <eirslett> I also tried let callbackUrl = render $ PluginR "oidc" ["callback"] but then I get a much longer compiler error: https://pastebin.com/qkczxQGj
05:30:33 <delYsid`> Abstractions are a blessing and a curse at the same time.
05:31:25 <comerijn> delYsid`: The problem isn't abstraction, but Yesod having lots of "magic boilerplate" that leaks out through problems/errors
05:38:52 <eirslett> I'm a beginner at both Haskell and Yesod, so these types are making me quite confused...
05:41:09 <comerijn> eirslett: Honestly, I'm far from a Haskell beginner and Yesod's types *still* make me confused :)
05:42:37 <eirslett> The whole dynamic route render thing looks like it works as long as it's within a widget, but I need it to render a HTTP 301 redirect URL as part of the authentication plugin, so I need to call it in my code instead of relying on magic...
05:44:33 <eirslett> Is this chat channel the best chance of getting help anywhere? Unfortunately I'm pretty lost on this issue, I spent so many hours fiddling with the compiler, trying to make it compile somehow, and unfortunately I cannot deploy my app in production (or dev) because "localhost" is hardcoded in it :P
05:46:00 <comerijn> I think there's also a #yesod channel, but not entirely sure
05:49:00 <eirslett> "[14:48] == Cannot send to nick/channel: #yesod" :-/
05:52:46 <comerijn> Might require a register nickname here, because I just checked and it does exist :)
05:53:50 <yushyin> https://freenode.net/kb/answer/registration
06:15:04 <w1n5t0n> hey all, I have a datatype `Signal a = Signal {runSig::Double -> a}`, and then a datatype that, among others, holds a list of those. How would I go about making the latter an instance of NFData so that I can use DeepSeq on it before storing it in an IORef? 
06:16:39 <w1n5t0n> I should perhaps mention that signals are, among others, an instance of Num, so I do things like `sin x + 2 * (cos x)` etc, which if I understand correctly is not eagerly evaluated to produce the resulting signal
06:18:44 <w1n5t0n> what I ultimately want is to spawn many threads to read these signals independently in a time-sensitive manner, so I want to make sure everything has been evaluated as much as possible before being passed on to the threads
06:20:35 <pavonia> w1n5t0n: Why do you need deepseq before storing it in an IORef?
06:22:01 <w1n5t0n> because I have noticed occassional glitches when I replace the IORef while the threads are running but those glitches don't continue if I don't mess with it (threads still running), which leads me to believe that the threads are being asked to do work that should be done before the IORef is replaced
06:24:55 <pavonia> I don't know for sure but I would assume the value is fully evaluated before it is stored
06:25:31 <pavonia> When using multiple threads you might want to use a thread-safe alternative like MVar anyway
06:25:38 <Tritlo> Is there any way to have GHC recursively derive instances?
06:26:29 <Tritlo> I want to derive Data instances for a top-level type, but it stops when it hits some underlying type. When that happens, I want to derive a Data instance for that too!
06:27:15 <Axman6> IORefs are fine for threade safert if used properly, ie atomicModifyIORef*
06:27:48 <Axman6> Tritlo: no, you need to be explicit about which types derive which classes
06:29:03 <delYsid`> Why is Haskell so unexpectedly memory hungry... Reading a 1.4GB file of 16-byte records into a single Vector uses about 34GB of RAM.  Why?  Thats a 20x overhead.  Trying to switch to an Unboxed vector didnt really help and did actually make things even slower.
06:29:52 <Solonarv> surely that isn't using 34GB all at once? that seems more like a "total allocation" statistic than a "maximum residency" statistic
06:31:28 <Solonarv> delYsid`: could you share your code? it's hard to tell what's causing all that memory usage otherwise
06:31:42 <delYsid`> no, its the number from top
06:31:59 <delYsid`> leemme commit
06:34:10 <comerijn> delYsid`: Are you parsing in textual data to build these records?
06:34:59 <delYsid`> https://github.com/mlang/chessIO/blob/master/src/Game/Chess/Polyglot/Book.hs
06:35:07 <delYsid`> comerijn: nope, reading via Data.Binary
06:35:13 <comerijn> delYsid`: Incidentally, I highly recommend the GHC user guide section on profiling for the next time you run into problems like this
06:35:16 <Solonarv> the talk of "16 byte records" is making me a bit suspicious - if your Haskell representation is something like 'data Record = Record Word8 Word8' that's 40 bytes per record on a 64bit machine, IIRC
06:36:01 <Solonarv> Haskell isn't very good at packed data structures, unfortunately
06:36:23 <delYsid`> I tried to bang it, but it apparently didnt help 
06:36:33 <comerijn> delYsid`: I know where the slowdown comes from
06:36:47 <delYsid`> comerijn: tell me
06:36:57 <comerijn> delYsid`: Ok, so a couple of things: ! in the record just makes them strict, it doesn't get rid of the extra pointer
06:37:04 <comerijn> delYsid`: You probably want to bang + unpack
06:37:23 <delYsid`> ah, unpack pragma
06:37:35 <comerijn> delYsid`: Like: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/src/Model.hs#L183-L189
06:37:50 <comerijn> delYsid`: Second, I assume your unbox implementation is based on the tuple one?
06:38:01 <Solonarv> comerijn: it is
06:38:08 <Solonarv> it's in the same file
06:38:27 <comerijn> delYsid`: The tuple unbox is a "struct-of-arrays" representation, which utterly ruins your cache locality
06:39:11 <comerijn> delYsid`: So I expect that to ruin your performance if you had some level of cache locality before
06:39:19 <comerijn> delYsid`: What is the definition of this Ply type?
06:40:16 <delYsid`> Its a newtype over Word16
06:41:00 <comerijn> delYsid`: You control the input data your parsing with Binary?
06:41:58 <comerijn> (aka all those Words are in the same byte-ordering as the machine your running on)
06:42:01 <hyperisco> if I have a Heyting algebra with no negation, what would that be?
06:42:24 <hyperisco> so, min and max
06:42:30 <Solonarv> a lattice?
06:42:38 <hyperisco> mm right, meet and join
06:43:56 <delYsid`> Hmm, UNPACK didnt help.
06:44:01 <Solonarv> in fact it looks like a heyting algebra is exactly a lattice-plus-negation
06:44:13 <Solonarv> (or, equivalently and more commonly, implication)
06:45:00 <comerijn> delYsid`: Do you control the input data? i.e. can you safely assume the binary data has the same byte ordering/endianness as the machine you run on?
06:45:38 <hyperisco> I noticed that rectangles, defined by width and height, have this structure where one operation is the smallest rect which contains two rects, and the other is the largest rect contained by two rects
06:45:40 <comerijn> delYsid`: (btw, using get/put from Binary isn't correct if your input data is produced outside of haskell)
06:46:08 <hyperisco> which ultimately is just a point-wise min and max on a 2-tuple
06:46:27 <Solonarv> it's a bit more complicated actually - it's a 4-tuple
06:46:37 <delYsid`> comerijn: It isn't?
06:46:40 <Solonarv> (minX, minY, maxX, maxY)
06:46:46 <Solonarv> but basically yes
06:47:01 <hyperisco> not sure what you mean
06:47:09 <delYsid`> I remember the docs sayed it uses network byte order, which looked sensible to me.
06:47:19 <hyperisco> these rectangles are defined only by width and height, they are not positioned anywhere
06:47:34 <hyperisco> or if you prefer that, they are always positioned at the origin
06:47:47 <comerijn> delYsid`: The Binary class uses it's own serialisation format, aka, it can insert (and expect) custom padding when used
06:47:49 <Solonarv> oh I see
06:48:05 <Solonarv> in that case you're right
06:48:10 <comerijn> delYsid`: If you use Binary with an existing format you want to explicitly use Data.Binary.Get and Data.Binary.Put
06:48:33 <hyperisco> Solonarv, that said, maybe the 4-tuple rects have the same structure
06:48:52 <Solonarv> hyperisco: it's pretty similar
06:49:10 <comerijn> delYsid`: Anyway, if you control the endianness of the input data you can copy my approach and skip parsing altogether and just directly map your vector over a blob of binary data (i.e. ByteString)
06:49:11 <Solonarv> it's just not uniformly the same of {min,max} on all the tuple elements
06:49:17 <hyperisco> Solonarv, I am not sure what to do about the zero-area rect, which comes from a disjoint intersection… where is it positioned?
06:49:54 <comerijn> delYsid`: See https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/src/Model.hs#L183-L215 (how I define a Storable instance for Treenode)
06:50:09 <hyperisco> maybe the equality has to be tweaked so all zero-area 4-tuple rects are equivalent
06:50:11 <Solonarv> hyperisco: we can just say that any rectangle with minX > maxX ∧ minY > maxY denotes the empty rectangle, I think
06:50:29 <Solonarv> ...which is the same thing you proposed :P
06:50:34 <comerijn> delYsid`: And https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/src/Utils.hs (which brutally rips the ForeignPtr out of a strict ByteString and converts it into a Storable Vector)
06:50:58 <comerijn> delYsid`: With that approach you Storable Vector should be exactly 1.4GB, just like your input file
06:53:02 <delYsid`> So I need to learn the Storable class?
06:53:15 <comerijn> delYsid`: Do you know (a bit of) C?
06:53:28 <delYsid`> yeah, I know about sizeof and stuff.
06:53:48 <comerijn> delYsid`: Storable is just "how do I read something from a pointer to bytes"
06:56:07 <delYsid`> So I'd write an instance for Storable BookEntry, and get the Vector reading for free?  Or do I need a Storable (Vector BookEntry) instance as well? And how do I read my vector from a file/bytestring, then?
06:56:28 <comerijn> delYsid`: Storable Vector uses the Storable instance for BookEntry
06:56:38 <delYsid`> k
06:56:50 <comerijn> delYsid`: Basically, storable vector is just a (thin) wrapper for a raw pointer
06:57:33 <w1n5t0n> pavonia: the threads are only reading from the IORef, never writing to it, and they do so at regular intervals
06:57:47 <w1n5t0n> every 0.5 seconds to be precise
06:58:50 <w1n5t0n> but some times, when the value stored in the IORef becomes larger and larger, there is a very audible glitch when I press a key to replace the previous IORef with a new one
06:59:02 <delYsid`> Hmm, unsafeFromForeignPtr0, ok, the fun stops here.
06:59:19 <w1n5t0n> to be clear, the threads are not reading values, but `Double -> Double` functions, which they then go on to evaluate themselves for certain inputs
06:59:24 <comerijn> delYsid`: pfft, that's where the fun starts ;)
06:59:55 <delYsid`> comerijn: Thanks for pointing me in a direction I dont wanna go :-)
07:00:15 <merijn> delYsid`: The direction is definitely fast, though :p
07:01:02 <delYsid`> merijn: I believe you.  It just has a quite opaque feel to it right now, gotta read up on things.
07:01:33 <w1n5t0n> pavonia: so there's two possibilities, either the glitches happen because I replace the IORef while the threads are reading from it by reference (which I don't even know if that's the case), or the glitches happen because when I store a new IORef it's not fully evaluated and so the threads need to spend extra time doing that on their first go around
07:02:56 <Solonarv> the second seems more likely to me, I don't think the first can even happen
07:04:12 <pavonia> w1n5t0n: Do you actually write the new ref before you pass them to the threads or does that all happen in an action that may be deferred until it's read the first time?
07:05:11 <w1n5t0n> pavonia: I write it, this all happens in a live coding context where an interpreter is running and I send it blocks of code as strings to store them in the IORef, using the strict verion of modifyIORef
07:07:03 <w1n5t0n> so it goes like this: interpreter starts with an empty session stored in the IORef, threads reading from it every 0.5s, I write some code and send it to the interpreter to put in the IORef, repeat
07:11:57 <pavonia> w1n5t0n: And those glitches happen at the time the ref is read and not when it is written?
07:13:20 <w1n5t0n> pavonia: they happen very shortly after I press the key to send the new code block to the interpreter, and they're a result of the threads not meeting their deadline to read and evaluate the signals on time
07:13:51 <w1n5t0n> but they only miss that deadline once, after that they keep reading and evaluating the same signals as normal
07:14:18 <Solonarv> yes, definitely looks like work is happening on the wrong thread
07:14:57 <Solonarv> should be fixed if you change writeIORef' ref foo to writeIORef' ref (force foo)
07:16:12 <w1n5t0n> Solonarv: that's what I thought, but then I need to make my datatype an instance of NFData and I'm not sure how that works for `a -> b` types
07:16:42 <Solonarv> for functions NF is just the same as WHNF
07:17:00 <Solonarv> pretty sure deepseq has that instance already
07:22:44 <w1n5t0n> Solonarv: yeah it seems like it has one, so it should be possible to derrive NFData for my custom data type that contains some algebraic datatypes, and a [(String, (Int, Signal))]? Sorry if that's a stupid question but this is a side of Haskell I'm not familiar with yet
07:23:03 <Solonarv> should work, yeah
07:23:30 <Solonarv> make sure your type derives 'Generic' and then just write 'instance NFData MyType'
07:34:11 <w1n5t0n> Solonarv: thanks, I managed to make the compiler happy so now I'll test it and make sure it solves the problem!
07:35:11 <w1n5t0n> out of curiosity, what's the deal behind deriving instances? for example, why couldn't I write `data Session ... deriving NFData' but I could do that with Generic instead?
07:35:40 <merijn> w1n5t0n: Deriving is built into the compiler, so it only works for things the compiler knows about
07:36:40 <w1n5t0n> merijn: that makes sense, but then again I didn't really have to write anything other than `instance MyType NFData` after that, so the compiler must be doing some of the work here too
07:37:01 <w1n5t0n> so isn't it in a sense deriving that as well?
07:37:22 <merijn> w1n5t0n: Not really. You can define a default implementation for classes, and with the DefaultSignatures extension you can define a default implementation for some instances
07:37:37 <merijn> w1n5t0n: NFData is defined with a default implementation that uses Generic
07:37:42 <Solonarv> to expand on this, there are three so-called "deriving strategies":
07:37:42 <Solonarv>  - 'stock': the compiler knows about this class and there is specific code to figure out how to write an instance of this class
07:37:42 <Solonarv>  - 'newtype': enabled by the GeneralizedNewtypeDeriving extension. Works on any class but only for newtypes, by re-using the instance from the wrapper type
07:37:42 <Solonarv>  - 'anyclass': enabled by the DeriveAnyClass extension, and simply causes the compiler to write an empty instance declaration
07:38:00 <merijn> w1n5t0n: So when you write "instance NFData Foo" GHC uses the default implementation of NFData, which uses Generic and "just works"
07:38:20 <phadej> via
07:38:59 <Solonarv> ah yes, there's also via - which is a generalization of GeneralizedNewtypeDeriving that lets you say which type's instance you want to re-use
07:41:12 <w1n5t0n> aah I see, that clears things up!
07:41:31 <w1n5t0n> what exactly does an empty instance declaration do?
07:42:09 <merijn> w1n5t0n: If there are default implementations an empty instance declaration is equivalent to defining each function in the class as the default implementation
07:46:10 <mythreaddead> I'm having a bug where I get an out of memory error when compiled with -O1 but runs fine with -O0 using ghc 8.6.3. I know there have been issues like this in the past, but I can't seem to find them on trac. Could anyone who might remember or can find some of those issues link them?
08:01:20 <Welkin> glguy: I woke up this morning, took a look at another javascript implementation for scram sha1, and realized a very subtle detail I missed (and yes I missed a lot)
08:01:24 <Welkin> it was an encoding problem!
08:01:27 <Welkin> I finally got it working
08:01:53 <Welkin> after realizing that I need to base64 decode the salt (and the servermessage as part of the auth message) directly into a byte buffer
08:02:08 <Welkin> instead, I was decoding them into a byte buffer as unicode text
08:02:10 <Welkin> fuck encodings!!!!
08:02:28 <Welkin> I can't believe I spent several days on this thing
08:02:47 <Welkin> I never want to implement a tedious, pedantic, arcane thing like this ever again
08:03:00 <Welkin> I was up 'till almost 4 am
08:03:35 <Welkin> so, sometimes I need to base64 decode (sometimes twice), sometimes I need to treat it as unicode, other times directly write the byte buffer
08:04:13 <Welkin> I started to think I had gone mad. I checked every single line of the code logically and empirically against another implementation, and everything checked out
08:21:19 <zincy> Hmm how should I define lambda expressions in an interpreter
08:21:29 <zincy> yes vague question
08:21:48 <zincy>         (Lambda "x" (Add (Variable "x") (Variable "x"))) 
08:22:22 <zincy> If the data constructor for a lambda is   FunVal (Exp -> Value)
08:22:57 <Putonlalla> You can't inspect arbitrary functions to perform substitution, zincy.
08:23:09 <Cale> Yeah, so you have the explicitly named variables way, and then higher order abstract syntax
08:23:15 <sicklorkin> SKI?
08:23:47 <zincy> Not sure I follow those answers :/
08:24:13 <Cale> zincy: I'm just providing names for the approaches that you're already providing examples of
08:24:29 <zincy> AH ok
08:24:54 <zincy> Is higher order abstract syntax just one where the argument can be any value?
08:26:45 <ski> (with HOAS in lambdaProlog or Twelf, you *can* inspect the lambda terms)
08:27:18 <Cale> Higher order abstract syntax is where you don't have explicitly occurring variable identifiers, and instead encode things in terms of functions that make substitutions into other expressions
08:28:19 <Cale> There are also fancier tools
08:28:20 <Cale> http://hackage.haskell.org/package/bound
08:28:24 <ski> (and Dale Miller had a paper about an extension to ML, "syntactic lambda expressions", that allowed something simular. also, in MetaML (but not MetaOCaml, iirc), you can match on code snippets of function type .. like if one could match on `Expr (a -> b)' in TH)
08:28:26 <Cale> http://hackage.haskell.org/package/unbound
08:29:13 <Cale> tbh, I haven't really had the opportunity to explore using these, so I can't provide too much insight into how they tackle the problem
08:29:41 <zincy> So is this a relatively uncommon way of expressing a syntax for a functional language?
08:30:14 <Cale> Is which?
08:30:42 <zincy> They snippet I originally posted
08:30:51 <zincy> The AST expression
08:31:00 <Solonarv> that's quite common actually
08:31:05 <Solonarv> especially for the front-end
08:31:31 <Cale> Yeah, that first thing is what everything tends to start with, and then you may or may not pass to some representation that elides the variable names
08:31:33 <Solonarv> it's not the most practical to actually interpret/evaluate, but it pretty much falls out of your parser that way
08:31:58 <Putonlalla> Besides, you need something like that for preserving named arguments.
08:32:21 <Cale> If you want to provide sensible error messages back to the user, you'll tend to need to know the names of variables
08:32:32 <jchia_> In case I mess up, should I backup /etc/nixos/configuration.nix or keep a version history myself or does NixOS automatically keep old versions?
08:32:33 <Cale> So you need to hang on to them at least as long as that :)
08:32:53 <delYsid`> merijn: How do I deal with big endian data with Foreign.Storable?
08:33:19 <zincy> thanks
08:33:28 <jchia_> sorry wrong chat
08:37:55 <zincy> So an Exp becomes a Value when I call my eval function
08:38:09 <Cale> That makes sense
08:38:24 <zincy> Now eval runs in the State monad
08:38:46 <Cale> Not just a Reader?
08:38:56 <Cale> Do you have effects?
08:39:15 <zincy> I am thinking a lambda expression is a Value which takes another Value and when evaluated returns a Value
08:39:27 <zincy> this lambda does not run in the State monad
08:39:47 <zincy> I need someway to delay evaluation of the function body which is an expression
08:39:55 <Cale> Usually you'll want a monad that keeps track of which variables are bound to what
08:40:11 <zincy> Effect is a Map String Value representing memory
08:40:13 <Cale> and usually Reader is sufficient, if your language is pure
08:40:34 <Cale> (because you only locally bind things, so you can use the 'local' function)
08:40:40 <zincy> yes that is what state is doing
08:40:58 <Cale> :t local
08:41:00 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
08:41:30 <zincy> Can you update the value wrapped in the reader though?
08:41:36 <zincy> i.e setting a variable
08:41:46 <zincy> or binding a variable
08:41:53 <merijn> delYsid`: by manually reordering the bytes, sadly
08:42:08 <Cale> So when evaluating an application, you'd use that local function to insert something into the Map of bound variables (r) while you evaluated the body of the lambda.
08:42:51 <Cale> and that way, the change to the environment automatically only affects the evaluation of the body of the lambda, you don't have to reset the binding after
08:42:57 <delYsid`> ouch.
08:43:05 <zincy> Cale: Neat
08:43:21 <Solonarv> % flip runReaderT [("x", 3)] do liftIO . print =<< asks (M.! "x"); local (M.insert "x" 42) do liftIO . print =<< asks (M.! "x");
08:43:21 <yahb> Solonarv: 3; 42
08:43:41 <Solonarv> % flip runReaderT [("x", 3)] do liftIO . print =<< asks (M.! "x"); local (M.insert "x" 42) do { liftIO . print =<< asks (M.! "x") }; liftIO . print =<< asks (M.! "x")
08:43:41 <yahb> Solonarv: 3; 42; 3
08:45:42 <zincy> Maybe that deals with scope
08:45:54 <zincy> Otherwise every variable is global
08:46:21 <Solonarv> yes, that handles scoping nicely
08:46:32 <zincy> sweet
08:47:31 <zincy> is State is like a Reader where puts would be the modification of a global?
08:47:50 <zincy> Hence the modeling of imperative code
08:48:53 <ski> environment/input/reader is only pushed ("distributed") "downwards", into the computation. you can "change" it, as it's "trickled down", though, like with that `local'
08:48:57 <Solonarv> you can have a rule like:
08:48:57 <Solonarv> eval (App f x) = eval f >>= \case { Lambda v body -> do arg <- eval x; local (Map.insert v arg) (eval body); _ -> fail }
08:50:16 <ski> output/logging/writer is only "pulled" "upwards" (and merged, at nodes with multiple children), from the computation. you can also "change" it, as it's "bubbled up", with `censor'
08:50:38 <zincy> ski: Thanks!
08:51:32 <ski> state is both "downwards" and "upwards" ("sideways" at nodes with multiple children), "threaded" through the computation. you can change it, as it's passing you by, with `modify'
08:51:43 <ski> zincy ^
08:52:38 <zincy> So state, reader and writer essentially differ in the directionality of state changes in respect to function scope?
08:53:08 <ski> zincy : if you think of environment variables of processes in Unix, they are inherited by new children processes. (but then a process can also modify them, so that aspect is more like state. but that modification doesn't affect values in child processes already spawned)
08:53:38 <zincy> :)
08:53:50 <zincy> Solonarv: Awesome thanks
08:53:50 <ski> zincy : i wouldn't call it "state" in all those cases .. but, basically, yes
08:55:36 <zincy> I love this channel
09:10:34 <lstdgtfp> I have a small question where GHC seems to contradict all the information I can find with Google
09:10:51 <lstdgtfp> The expression `let x = [] in show x` types
09:11:27 <lstdgtfp> Why does type inference for that work? since `x :: [t]`, I would have thought that the `t` was ambiguous 
09:11:41 <lstdgtfp> to be more precise, `x :: (Show t) => [t]`
09:11:54 <Solonarv> lstdgtfp: are you perchance doing this in GHCI ?
09:11:58 <lstdgtfp> yes
09:12:09 <Cale> GHCi has ExtendedDefaultRules enabled
09:12:10 <Solonarv> GHCI has more aggressive defaulting rules
09:12:20 <Solonarv> which causes the 't' there to default to '()'
09:12:41 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#extended-rules-around-default-declarations
09:12:49 <lstdgtfp> Ah, wow, that's really interesting. 
09:12:52 <lstdgtfp> Thanks!
09:12:57 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#type-defaulting-in-ghci
09:13:00 <Cale> rather
09:28:15 <talqu> hi, i have the most basic example warp server using servant. `cabal run` compiles, builds and starts the server on port 3000 the project. But every time I change something, i need to C-c the running server and run `cabal run` again. Is there a tool you use to that's waiting to src file changes and rebuilds, reruns the app? Or is it not recommeneded/liked solution? What is your development flow in this example?
09:30:49 <Cale> talqu: This is not really a proper answer to your question, but that is something that Obelisk's ob run does
09:31:28 <Welkin> just set up a file watcher to trigger a recompile on change
09:31:30 <Cale> You can probably use ghcid to accomplish the same
09:31:40 <Welkin> you can do it with a shell script
09:31:41 <talqu> Cale, i know, obelisk was the first thing i tried actually in haskell practical stuff and it was awesome
09:31:50 <talqu> that's why im wondering 
09:31:59 <Welkin> it isn't magic
09:32:06 <Cale> ghcid has a --run option you can provide to give a command to run after loading
09:32:22 <Cale> oh, and it conveniently defaults to main
09:32:36 <Cale> So you can ghcid -r -c cabal repl
09:32:39 <Cale> or something like that
09:32:41 <Welkin> I don't like that to happen though because haskell compilation can be slow
09:32:54 <Welkin> so I don't want it to recompile every time I save a file
09:33:06 <Cale> Well, it's using ghci, so it's faster than compiling at least
09:33:19 <Cale> and you often do want to know about the errors as you're working on things anyway
09:33:34 <Cale> so ghcid's auto-updated list of errors is handy
09:33:45 <Welkin> I usually make huge changes and deal with the errors at the end
09:33:48 <Cale> (it'll only try to run the thing once everything is successful)
09:33:55 <Welkin> like changing a few thousand lines at once
09:34:01 <Cale> That's... interesting
09:34:03 <Welkin> it's probably not ideal
09:34:29 <Cale> I usually change one line and steamroll the compiler over it, and let it tell me how to follow up until things compile again
09:34:35 <talqu> :)
09:34:35 <Welkin> it usually works pretty well
09:34:46 <Welkin> except for that one time I did a port from scotty to servant
09:34:52 <Welkin> servant's types can be a nightmare
09:35:13 <Cale> I'm still not convinced that servant's type level fanciness is necessary
09:35:16 <Welkin> if you stay away from crazy types, this approach works
09:35:30 <Cale> It seems like a term level representation of the same thing would be more type safe, ironically
09:35:35 <Welkin> you can reason about your program in your head and be reasonably sure that it will work
09:35:52 <Welkin> I don't like to blindly follow the compiler's commentary
09:36:04 <Cale> Well, you shouldn't *blindly* follow it, sure
09:36:39 <alp> Cale, did you read the post where I motivated the current design? that design is I think necessary to achieve the goals that we had back then. but there are alternatives for sure, that some people have explored (but not enough to my taste)
09:36:41 <Cale> But it is nice to have it point out line numbers and such, especially if you're working in a team and might not know where all the affected bits of code would be
09:36:58 <Cale> alp: I haven't, it would be interesting to see :)
09:38:12 <alp> Cale, https://haskell-servant.github.io/posts/2018-07-12-servant-dsl-typelevel.html -- at least you'll know exactly what problem we were solving, with what constraints.
09:42:42 <alp> also note that I sympathize with the few precise problems that people point out with servant. this approach is bound to have some, and whether using servant for a given task is "justified" usually amounts to how much one gains in exchange for the pain that comes from those problems =)
09:46:05 <Welkin> my solution was to not use haskell at all for web servers
09:47:12 <Welkin> the WebMachine approach to web api implementation is the best in my experience (which is in erlang, modern implementation as cowboy rest handlers)
09:48:08 <Welkin> you model each request/response cycle as a state machine and override the default behavior where necessary
09:56:24 <ski> Solonarv : hm, i was thinking a little more on pattern synonyms, the other day. (i sketched out type system rules for the generalization i was thinking about before.) and i thought up a couple of examples ..
09:59:57 <martin___> I have code that looks like this. Is there any shorter way of doing this? https://pastebin.com/sz7vA5rR
10:01:50 <ski>   execCommand (Gen genOptions) = gen genOptions
10:01:55 <ski>   execCommand (Ls   lsOptions) = ls   lsOptions
10:01:56 <ski>   execCommand (Cat catOptions) = cat catOptions
10:01:58 <ski>   ...
10:01:59 <ski> ?
10:02:54 <ski> or, i suppose if you define a `foldOptions', you could perhaps say
10:02:55 <merijn> So, if I have a "ReaderT r Foo a" and a brackety-function "Foo a -> Foo a", is there some convenient way to make that "ReaderT r Foo a -> ReaderT r Foo a"? hoist from mmorph?
10:02:56 <ski>   execCommand = foldOptions gen ls cat ...
10:03:06 <ski> that relies on position, though
10:03:25 <martin___> ski: thanks for the tips
10:04:00 <ski> @type mapReaderT  -- merijn ?
10:04:01 <lambdabot> forall k2 k1 (m :: k2 -> *) (a :: k2) (n :: k1 -> *) (b :: k1) r. (m a -> n b) -> ReaderT r m a -> ReaderT r n b
10:04:23 <Solonarv> which is just the ReaderT-specialized version of hoist
10:04:41 <ski> i suppose `hoist' could also work
10:04:51 <merijn> ski: Ah, that might work nicely :)
10:04:53 <ski> otoh ..
10:05:00 <ski> @type mapWriterT
10:05:01 <lambdabot> (m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b
10:05:13 <ski> @type mapStateT
10:05:14 <lambdabot> (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
10:05:21 <Solonarv> yeah, those aren't the same as hoist
10:05:25 <ski> @type mapRWST
10:05:27 <lambdabot> (m (a, s, w) -> n (b, s, w')) -> RWST r w s m a -> RWST r w' s n b
10:05:42 <Solonarv> but mapReaderT happens to be the same as hoist @ReaderT
10:05:44 <martin__> quit
10:06:23 * ski nods
10:06:49 <ski> actually, i was trying to change the type of the state the other day, and was annoyed that `mapStateT' couldn't do it
10:07:40 <ski> @type \fwd bwd -> StateT . (fmap (fmap fwd) .) . (. bwd) . runStateT
10:07:42 <lambdabot> Functor m => (a1 -> s) -> (s -> a1) -> StateT a1 m a2 -> StateT s m a2
10:08:28 <ski> hm, also `hoist' is rank-2
10:09:23 <ski> @type mapExceptT
10:09:24 <lambdabot> (m (Either e a) -> n (Either e' b)) -> ExceptT e m a -> ExceptT e' n b
10:09:50 <ski> (while `mapReaderT',`mapWriterT',`mapStateT',`mapRWST',`mapExceptT' allow you to access the result)
10:11:20 <ski> Solonarv : anyway, apart from `(->)', i had `(+)',`(/\/)',`(++)',`mapInv',`map' as examples ..
10:23:18 <jle`> to change the type of state...
10:27:09 <jle`> :t \f g -> TS.state . runStar . dimap f g . Star . runState
10:27:10 <lambdabot> Monad m => (s -> c) -> (c -> s) -> State c a -> StateT s m a
10:27:27 <jle`> makes me think that it could be done with a coerce of dimap
10:32:06 <jle`> :t \f g -> StateT . fmap getCompose . runStar . dimap f g . Star . fmap Compose . runStateT
10:32:07 <lambdabot> Functor m => (s -> b) -> (b -> s) -> StateT b m a -> StateT s m a
10:32:15 <jle`> yeah, mapState f g = coerce (dimap f g) :)
10:32:31 <jle`> hm
10:32:47 <jle`> mapState f = coerce . dimap f :)
10:38:35 <ski> jle` : heh, i even named it `dimapStateT'
10:39:00 <jle`> hm i suppose it only works if m's first type parameter is representational
10:39:32 <ski> the `coerce' version ?
10:39:35 <jle`> yeah
10:39:43 <jle`> or, maybe not
10:39:46 <ski> what's the difference between `Star' and `Kleisli' ?
10:39:57 <jle`> actually it doesn't need it, i misread some typechecker output :)
10:40:04 <ski> okay
10:40:18 <jle`> hm Star is more natural as a profunctor to me
10:40:48 <jle`> i associate it in my head more with profunctors.  but yeah they are identical types
10:53:09 <jle`> they're both also 'identical' to ReaderT, except ReaderT has its arguments ordered to be a MonadTrans and not a Profunctor
10:54:01 <Cale> alp: ah yeah, the GADT approach you were talking about there is pretty much the approach I was thinking of. I'm not altogether certain why it demands that we think of everything up front -- you could have some very general constructors after all -- but I can see how the type class approach met your needs.
11:29:41 <alp> Cale, ah so you didn't notice any hole in the reasoning, that's good =) but yes, none of the original 3 authors (of which I'm one) was ready to give up on "broad extensibility".
11:30:45 <camsn0w> What is the best place to start learning haskell?
11:31:06 <lavalike> here (:
11:31:28 <Cale> Yeah, there's asking lots of questions here :D
11:31:50 <Cale> For a book, I often recommend Graham Hutton's "Programming in Haskell"
11:32:16 <Cale> There's also http://www.cis.upenn.edu/~cis194/spring13/lectures.html -- this course
11:32:32 <Cale> which provides a pretty good start, most people like it, I think
11:36:45 <dmwit> ?where tutorials
11:36:45 <lambdabot> http://haskell.org/haskellwiki/Tutorials
11:42:24 <saml> > "I" - "I"
11:42:26 <lambdabot>  error:
11:42:26 <lambdabot>      • No instance for (Num [Char]) arising from a use of ‘-’
11:42:26 <lambdabot>      • In the expression: "I" - "I"
11:51:13 <dmwit> :t \f g act -> gets f >>= runStateT (MM.hoist lift act) >>= state . pure . fmap g
11:51:14 <lambdabot> (Monad m, MonadTrans t, MonadState s (t m)) => (s -> a) -> (a -> s) -> StateT a m b -> t m b
11:53:49 <alla> https://2no.co/2P9af5.jpeg
11:54:11 --- mode: ChanServ set +o dmwit
11:54:47 --- mode: dmwit set +b *!*@*.109.227.93.164
11:54:53 --- mode: dmwit set -o dmwit
12:26:14 <zwelstern_> Hi
12:26:50 <zwelstern_> Is this channel alive?
12:27:10 <Tuplanolla> Yes.
12:27:13 <hc> > ['n', 'o']
12:27:15 <lambdabot>  "no"
12:27:34 <zwelstern_> pretty new to this
12:28:05 <zwelstern_> Anyone hacking on IPFS here?
12:29:09 <zwelstern_> Tuplanolla: what's up
12:30:55 <hc> zwelstern_: what's IPFS?
12:32:01 <yushyin> interplanetary filesystem
12:32:24 <zwelstern_> https://ipfs.io
12:33:04 <zwelstern_> Its pretty cool
12:34:06 <MarcelineVQ> IPFS has come up here before, I don't recall who it was that did so though
12:36:24 <MarcelineVQ> mmm, no one in my log that mentioned it is in here just now
12:39:11 <Lycurgus> maybe you were thinking of the more likely HTTP/2
12:41:33 <MarcelineVQ> Nah it's there, just the people aren
12:41:35 <MarcelineVQ> t
12:43:19 <Lycurgus> i know, I just wanted to contrast the slow mover with then not going anywhere
12:43:29 <Lycurgus> *with the
12:47:45 <hololeap> i'm a bit lost, can someone show me an example of a Parsec parser that would remove an extension from a filename?
12:49:48 <merijn> hololeap: What do you mean?
12:50:02 <hyperisco> hololeap, parsers do not remove things, they break things into parts
12:50:33 <hololeap> if the file was "abc.efg.hij", it would break it into ("abc.efg", ".hij"
12:50:42 <hololeap> )
12:51:12 <merijn> hololeap: Writing a parser means defining how to break that into parts
12:51:20 <hyperisco> so, for efficiency reasons, it is probably better to break at every dot
12:51:37 <merijn> honestly, you probably just want the filepath package
12:51:53 <merijn> That has lots of functions for manipulating paths and extensions
12:51:53 <hyperisco> or… we can just go right-to-left
12:52:07 <hyperisco> which then becomes the first dot, which is easy peasy
12:52:09 <hololeap> well, there is more to the parser just than that, but i need some help getting started
12:52:51 <hololeap> hyperisco: reversing it isn't a bad idea
12:53:08 <hyperisco> so if you want to work with file paths generally, then your parser should probably be designed to parse any valid file path, breaking it into parts, like directories and file names and extensions
12:53:26 <hyperisco> removing a file extension then is just dropping a part and then printing as a string again
12:54:18 <hyperisco> more directly for this specific problem it'd be usual to do a reverse string (Text) search for '.', and then slice the string (Text) from the beginning to before the '.'
12:54:56 <hololeap> the regex would look like this: /^(\d{8}) (.+) (.{11})\.json$/
12:55:14 <hololeap> should i just use a regex library? i wanted to use the opportunity to get more acquainted with parsec
12:55:25 <hyperisco> there are so many libraries that use String or Text for paths that I find having the string-munging versions of path functions quite practical…
12:55:54 <hyperisco> the relationship between Haskell and regex is rather hostile…
12:56:11 <merijn> hyperisco: filepath just operates on strings, though
12:56:25 <hyperisco> okay cool, go for it :)
12:56:42 <merijn> Why not just write a parser that parses a random string and then use filepath functions to manipulate the parsed name/file
12:57:14 <hyperisco> let me count the ways…
12:57:20 <Lycurgus> if it was a homework, it was a trick, see if they try to kill a gnat with a machine gun
12:59:06 * hyperisco recalls a particular Family Guy episode
13:02:21 <hyperisco> One reason is that you want to reject malformed paths. Another reason is you want diagnostics on a malformed path. Another reason is you also want an ADT which is guaranteed to construct valid paths. Another reason is because such an ADT can better represent portable paths. Another reason is because some string-based manipulations have to do a lot of parsing-like work anyways for otherwise easy things, and that work has 
13:02:21 <hyperisco> to be redone every single time.
13:04:36 <hyperisco> On the other hand, sometimes a 3rd party spits a path string at you, in a predictable way, and you just need to plug it into some other bit on the spot
13:12:59 <martin__> I made a little command line tool. Criticism, adulation and/or silence are all welcome: https://github.com/msvbg/p
13:13:57 <hyperisco> I choose pie
13:15:45 <hyperisco> A former prof of mine had a knack for grading work by quickly scanning it… looks good!
13:17:55 <merijn> martin__: Looking over your options parser I'd recommend using more where bindings to avoid excessive nesting/parentheses in the parser
13:18:34 <martin__> merijn: thanks for the advice
13:18:42 <martin__> I will look into that
13:19:00 <martin__> hyperisco: if directed to me, thanks :)
13:19:51 <merijn> You can also use mconcat + list of options instead of using a lot of <> for defining options
13:20:29 <merijn> martin__: Something along the lines of the parsers here: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/model-src/Options.hs
13:20:47 <hyperisco> martin__, indeed it was. I am pretty sure his trick was to just aesthetically appraise the work, because if it looks neat and tidy then it probably had a lot of care put into it.
13:21:06 <martin__> that does look neat
13:21:33 <martin__> hyperisco: yes, that is a nice trick
13:21:53 <merijn> martin__: Other than that it looks pretty clean at first glance
13:22:11 <jgt> is there a way to wrap an esqueleto query with some other function?
13:23:02 <merijn> martin__: I'm a firm beleiver that there's no such thing as "too many where bindings" ;) You can even nest them, having where bindings attached to where bindings :)
13:23:09 <jgt> I want to build a query with esqueleto, and whatever it generates, I want to then wrap with `SELECT count_estimate(<esqueleto generated query goes here>);
13:23:45 <merijn> jgt: tbh, I just build queries in Text and use persistent's rawSql for that sorta thing >.>
13:23:54 <martin__> merijn: ha, that's fair. i do dislike excessive indentation
13:24:07 <jgt> merijn: how do you handle multiple WHERE statements?
13:24:20 <merijn> jgt: I looked into esqueleto for a bit, but it seemed to verbose/complicated to deal with
13:24:39 <jgt> merijn: don't you need to change all but the first WHERE into an AND?
13:25:34 <merijn> jgt: Yeah, I just manually inserted AND between every condition before inserting it into the where of the query :p
13:26:22 <jgt> oh, that makes sense. I guess I could do it that way.
13:26:39 <merijn> jgt: I replaced most of my multiple where clauses with "WHERE expr IN (??)" now, but inserting commas within the ?? is much like inserting AND between clauses: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/model-src/StepQuery.hs#L36-L40
13:28:22 <jgt> merijn: that's really helpful, thanks!
13:28:49 <jgt> I like esqueleto, but I'm finding a whole bunch of cases where I can't really use it
13:29:05 <merijn> jgt: As you can see below that I've mostly switched to just hand writing lots of SQL, because it's actually a pretty good language from complex queries :)
13:29:14 <jgt> still, I'd rather that as a safer default than the other way around
13:30:36 <merijn> Yeah, I'd like a more first class DSL to manipulate queries in Haskell, but so far all alternatives I've found are either lacking in functionality (like esqueleto) or just god awfully complicated
13:31:06 <Rembane> merijn: Have you taken a look at Selda? 
13:32:03 <merijn> Rembane: Yeah, Selda looks ok, but by the time it was announced I was already using persistent in this code :)
13:32:17 <Rembane> merijn: Meh. You've been hacking for too long. :D
13:33:49 <merijn> Rembane: I don't wanna migrate now, but my next project with a database I'm gonna play with Selda. I even prepared by bugging them into exposing the SQLite internals foor me already :p
13:34:00 <Rembane> merijn: ^^
13:34:13 <merijn> jgt: Some people really like stuff like BEAM, but then I see the type signature like this: https://hackage.haskell.org/package/beam-core-0.8.0.0/docs/Database-Beam-Schema.html#v:modifyTable
13:34:26 <merijn> jgt: And then I'm all: Screw that...
13:34:33 <Rembane> merijn: I can see why. How much database interaction do you do? 
13:35:36 <merijn> Rembane: That code from my phd is the only project that really uses a database that I've worked on in, like, a decade :p
13:36:04 <Rembane> merijn: That sounds like fun! :D
13:36:39 <Rembane> merijn: Maybe this is a stupid question but... why do you need a database?
13:37:12 <merijn> Rembane: Because as of last time I looked I have about 5 million benchmarking measurements and associated properties from my experiments :p
13:38:44 <merijn> Rembane: I used to have them scattered across text files, but decided to move to a database for ease of querying/analysing. The modeling and analysis is 1 to 2 orders of magnitude faster due to 1) SQL queries being better than scanning through text files and 2) the SQL rows actually already contain stuff as ints, doubles, etc. instead of needing to parse first
13:39:20 <merijn> Rembane: Added bonus, I can now concurrently add/update measurements and use the database as a specification which experiments still need to run :)
13:43:30 <Rembane> merijn: Those are really good reasons. ^^
13:44:00 <martin__> cleaner https://github.com/msvbg/p/blob/master/src/Parser.hs
13:44:59 <merijn> Rembane: Last time I was using the "text files + bash + python" setup I had originally it took about 45 minutes to run a model training sessions and 30 to evaluate a model. Currently (with a 5-10x larger dataset) it's about 30 seconds to train and 10 seconds to evaluate :p
13:45:16 <merijn> martin__: Yeah, that looks massively better
13:47:38 <Rembane> merijn: Those are very good reasons too. 
13:50:42 <fen> how do you unfold or traverse a prism?
13:51:34 <Zemyla> (->) is a Choice.
13:52:04 <fen> :k (->)
13:52:05 <lambdabot> TYPE q -> TYPE r -> *
13:52:23 <fen> arent prisms like Either?
13:52:50 <fen> its not like extensible Sum types?
13:53:34 <fen> data Selection (fs :: [* -> *]) (a :: *) where 
13:53:39 <fen>  Pass        :: Proxy f -> Selection fs a -> Selection (f ': fs) a 
13:53:40 <fen>  Selectction ::     f a -> Proxy     fs   -> Selection (f ': fs) a 
13:53:57 <vukonen> Hi, I have a question about a solution for checking if a String is a palindrome I saw recently
13:54:27 <vukonen> Namely (reverse >>= (==))
13:54:58 <dmwit> ?src (->) (>>=)
13:54:58 <lambdabot> f >>= k = \ r -> k (f r) r
13:55:20 <dmwit> reverse >>= (==) = \r -> (==) (reverse r) r = \r -> reverse r == r
13:55:25 <Zemyla> @unpl reverse >>= (==)
13:55:25 <lambdabot> (reverse >>= (==))
13:55:37 <Zemyla> :t reverse >>= (==)
13:55:38 <lambdabot> Eq a => [a] -> Bool
13:56:07 <vukonen> I understand why it works but it would seem that "[a] ->" is a Monad instance to make it work
13:56:11 <vukonen> Or something similar
13:56:14 <dmwit> vukonen: Correct.
13:56:29 <Zemyla> (->) e is in fact a monad for all e.
13:56:41 <dmwit> vukonen: See the implementation of (>>=) above; meanwhile `return x = \r -> x`.
14:00:16 <fen> > ((return (1 :: Int) >>= return) :: forall a. a -> Int) 2
14:00:18 <lambdabot>  1
14:02:17 <fen> is Selection above like a Prism?
14:03:27 <dmwit> Wise tautology #0: “X is like Y” can always be argued to be true.
14:03:36 <dmwit> http://www.vex.net/~trebla/humour/tautologies.html
14:03:48 <fen> hmm
14:04:03 <fen> well you can traverse over it, but can you prism over it?
14:05:08 <fen> like if a list is somehow an archtypal traversable, is Selection like an achetypal prism?
14:05:23 <fen> (that quantifies "like")...
14:06:11 <fen> "list is to Traversable as Selection is to Prism" ?
14:06:34 <vukonen> dmwit: Thanks, the implementation of >>= for -> makes it clearer
14:07:02 <fen> btw idk what is a Prism
14:07:15 <fen> thats basically what would be the aim to discover here
14:08:21 <fen> the inclination is that its something to do with extending Either to Selection, as [] is the extension to (,)
14:08:37 <fen> right?
14:09:54 <fen> um, ok thats not quite right because Seclection is a choice between varous `f' in `f a'
14:10:03 <fen> really it should just be a choice between various `a'
14:10:11 <fen> but yeah, thats the idea
14:11:28 <fen> basically just to have instead of a HList, its more like a HSum, or DSum?
14:11:40 <fen> idk what any of these things are really... help!
14:12:28 <fen> i can have a state which unfolds lists, but to be able to cover Sum datatypes it needs Prisms? correct?
14:14:12 <Solonarv> fen: Prism is the dual of Lens - Prism is to Either what Lens is to (,)
14:14:34 <fen> hmmm
14:14:45 <fen> so what if we just consider the "head" lens
14:14:47 <fen> like get/set
14:15:00 <fen> because thats what you need for folding/unfolding/traverse
14:15:17 <fen> ?
14:15:29 <jle`> head for normal lists is not a lens
14:15:32 <Solonarv> "head" isn't a lens
14:15:36 <jle`> but it's a lens for hlists if that's waht you are talking about
14:15:40 <fen> lens "on" head
14:15:48 <vukonen> So is -> as a Monad representing the idea of creating higher order functions?
14:15:57 <vukonen> With the bind operator
14:15:58 <jle`> right, there is no lens to the head of a normal list
14:16:27 <fen> wait, why is hlist for lens??
14:16:31 <jle`> vukonen: for (->) r, we have (>>=) :: (r -> a) -> (a -> r -> b) -> r -> b, so that's a higher order function yes
14:16:36 <Solonarv> for HList (or really, any list where you can express that its length is >=1 in the type) you can write a lens onto its head
14:16:47 <jle`> vukonen: but remember that (>>=) is a higher order function already
14:16:49 <jle`> for any Monad
14:17:09 <jle`> so i wouldn't say that (->) r represents the idea of higher order functions
14:17:19 <jle`> since (>>=) for Maybe, IO, [], Either e, etc. are all higher order functions
14:17:31 <fen> oh right its just for type safety
14:17:42 <jle`> fen: a lens has a total getter and setter
14:17:42 <fen> no maybe case for head [] failiure
14:17:54 <fen> ok, so we consider Nonempty
14:18:11 <fen> then we have a lens on the head?
14:18:12 <jle`> fen: another way of thinkg about it is that a lens on some value inside means that you can break down a type into a product of that value and some other 'leftover' data
14:18:25 <Solonarv> indeed, we have a lens onto the head of a NonEmpty
14:18:27 <jle`> fen: yeah, we can do that with NonEmpty
14:18:30 <fen> ok
14:18:39 <jle`> because a `NonEmpty a` is a product between its `a` head, and its [a] tail
14:18:40 <fen> anyway, we want to restrict to just this lens
14:18:47 <fen> for the sake of traversing
14:18:55 <fen> basically get/set
14:19:03 <fen> and then, whats that with Prism?
14:19:18 <jle`> a prism is preview and review
14:19:31 <fen> (lens not only abstracts over the container, but the position, and we just want to abstract over the container)
14:19:46 <fen> and then whats that same approach with Prism?
14:19:46 <Solonarv> a Lens selects a part of a product type; a Prism selects a part of a sum type
14:20:03 <fen> well, the head in this case
14:20:09 <Solonarv> so you could have a Prism for the (:) constructor, and a Prism for the [] constructor
14:20:10 <jle`> there is no head prism
14:20:23 <jle`> you cannot have a prism into the first item of a list
14:20:27 <fen> well ok head is an operation on lists
14:20:45 <fen> but we would be using the nonempty, unparamatrised varient of Selection above
14:21:46 <jle`> there is no prism into the first item in a nonempty
14:22:42 <vukonen> So I guess the first argument in ([a] -> [a]) in something like let f = (reverse >>= (==)) is the same argument that f expects?
14:22:58 <fen> data Selection (as :: [*]) where 
14:23:04 <vukonen> Cause it seems like >>= uses only the -> [a] part of reverse
14:23:04 <fen>  Pass        :: Proxy a -> Selection as -> Selection (a ': as) 
14:23:04 <fen>  Selectction ::       a -> Proxy     as -> Selection (a ': as)
14:23:15 <jle`> vukonen: yes :) >>= leaves the "input" preserved
14:23:45 <fen> thats nonempty
14:23:50 <vukonen> jle`: Thanks, I guess it's the same for every Monad, but it gets more confusing with functions
14:23:57 <fen> so we can have a head-like prism on that?
14:24:05 <jle`> vukonen: well, it's different here because not every monad has a notion of an "input"
14:24:23 <jle`> `(->) r` is unique here as a monad because it has a concept of an "input value" within the monad
14:24:41 <jle`> this isn't the case with monads like Maybe, []
14:24:50 <Solonarv> fen: yes, because this is just an n-ary sum type
14:24:58 <Solonarv> which prisms are perfectly suited for
14:24:59 <fen> but it will fail normally?
14:25:12 <Solonarv> prisms already have "possibility of failure"
14:25:19 <fen> because the head is not where the value is
14:25:33 <jle`> fen: btw, just in case you aren't aware, the Proxy there doesn't serve any purpose, it's redundant
14:25:41 <fen> [_,_,_,value :: as !! 4 ,_,_ ...]
14:25:58 <jle`> fen: a good check that you can do if you can have a prism (or a lens) on a data type, is if you can separate your type into a sum type between the value you want to point to, and some other alternative
14:26:11 <fen> jle`: really? 
14:26:12 <jle`> that is, if you have a `Prism' s a`, it means that s is isomorphic to Either a q, for some q
14:26:26 <jle`> if you can "pick" that q, and prove that the isomorphism exists, then you prove that you have the lens
14:26:37 <fen> the idea is to just pass the type without needing a value, thats exactly what Proxy is for?
14:26:39 <jle`> similarly for lens, if you have a `Lens' s a`, it means that s is isomorphic to `(a, q)` for some q
14:27:04 <jle`> so if you want to see if a prism exists for your type, pick a 'q', and give that isomorphism
14:27:08 <jle`> and you prove the prism :)
14:27:20 <fen> well we just want the head varient for traversing
14:27:44 <fen> you have to get rid of the "any position" aspect of the Lens/Prism abstraction
14:27:44 <jle`> if you want a 'head prism', then you have to prove that Selection (a ': as) is a sum between Selection a and ???
14:28:05 <jle`> it just so happens that `Selection (a ': as)` is isomorphic to Either a (Selection as)`
14:28:15 <jle`> so, that means you *can* have a Prism into the first item
14:28:38 <jle`> well, only if you can prove that the two are isomorphic ;)
14:28:57 <Solonarv> but in this case that's pretty easy
14:29:09 <vukonen> jle`: So -> has this implicit a kind of inserted, and for other Monads everything is contained within?
14:29:12 <fen> but what about traverse?
14:29:22 <fen> there we had get/set
14:29:30 <fen> they can be used to implment traverse
14:29:38 <fen> now we have some prism things
14:29:41 <jle`> vukonen: i wouldn't say anything about 'other monads'
14:30:03 <jle`> vukonen: `(->) r`  (with the r, remember) contains the idea of an "input value"
14:30:08 <jle`> vukonen: other monads might, and other monads might not
14:30:18 <fen> get/set are the "head lens", so then what is the "head prism" ? 
14:30:20 <jle`> you can't really say anything true in general about "for other monads"
14:30:30 <jle`> fen: what do you mean about how get/set are head lens?
14:30:34 <reality> .
14:31:26 <fen> eg, for list get :: [a] -> Maybe (a,[a]), set :: Maybe (a,[a]) -> [a]
14:31:28 <jle`> vukonen: some other monads also have an idea of some 'input value'
14:31:41 <jle`> fen: that's...not what get/set are for lists at all
14:31:48 <jle`> and if they are, it's unrelated to the idea of lenses, heh
14:31:59 <fen> both those statements are false
14:32:21 <fen> i cant even try to understand what could motivate them
14:32:30 <jle`> well, get and set have a very specific meaning in lens
14:32:38 <fen> well im stealing them
14:32:39 <jle`> and this deviates from the meaning it has in lens
14:32:45 <jle`> right, i'm explaining my motivation
14:32:48 <fen> ok
14:33:01 <jle`> what you have there is an isomorphism between [a] and Maybe (a, [a])
14:33:16 <fen> i though lens had getters and setters, and that get and set could safely be used to mean head getter and head setter
14:33:26 <jle`> so usually they call them "to" and "from"
14:33:41 <jle`> fen: ah yeah, no, get and set in lens is incompatible with the idea of a head setter and head getter
14:34:10 <fen> setter probably means consting away to replace a value...
14:34:50 <jle`> the 'set' here is compatible with a head traversal, or a head Setter
14:34:50 <vukonen> jle`: Do you remember any off the top of your head other than "(->) r"?
14:34:55 <jle`> but not ocmpatible with a head Lens
14:35:14 <fen> well the lens would be the combination of both
14:36:34 <jle`> if we talk about the [a] ~ Maybe (a, [a]) isomorphism, we could have an Iso
14:36:51 <jle`> @let listiso = iso uncons (maybe [] (uncurry (:)))
14:36:52 <lambdabot>  Defined.
14:36:59 <jle`> then we have get and set with a specific type:
14:37:04 <jle`> :t get listiso
14:37:05 <lambdabot> (Profunctor p, Functor f, MonadState t ((->) (p (Maybe (a1, [a1])) (f (Maybe (a2, [a2]))) -> p [a1] (f [a2])))) => t
14:37:16 <jle`> oops heh
14:37:18 <jle`> :t view listiso
14:37:19 <lambdabot> MonadReader [a2] m => m (Maybe (a2, [a2]))
14:37:40 <lavalike> what's "iso" from?
14:37:42 <jle`> that would be [a] -> Maybe (a, [a]), like your 'get'
14:37:50 <jle`> :t set listiso
14:37:52 <lambdabot> Maybe (a2, [a2]) -> [a1] -> [a2]
14:38:12 <Solonarv> lavalike: it's from lens
14:38:13 <jle`> hm, i guess that's the same as yours if you ignore the second argument
14:38:25 <Solonarv> specifically Control.Lens.Iso
14:38:35 <Solonarv> :t review listiso
14:38:36 <lambdabot> MonadReader (Maybe (a1, [a1])) m => m [a1]
14:38:43 <Solonarv> that's the one
14:38:45 <jle`> hm, so your get/set are get and set for the list isomorphism between [a] and Maybe (a, [a])
14:38:57 <jle`> but they do not correspond to any Lens
14:39:35 <jle`> fen: also, check out the chart here, it specifies what things are a combination of what -- https://hackage.haskell.org/package/lens
14:39:36 <fen_> well we need to make the connection to lens to be able to use the understanding of Prism 
14:39:49 <jle`> there's a nice plot here too http://oleg.fi/gists/posts/2017-04-18-glassery.html
14:40:44 <fen_> most of those are not relavent here
14:40:57 <jle`> right, but i'm showing how lens, prisms, traversals, folds, isomorphisms are related to each other
14:41:27 <fen_> lens is not a getter setter pair?
14:41:38 <fen_> in the sense i was using those terms
14:41:54 <fen_> seems like, view, set is the lens termanology from what you wrote
14:41:56 <jle`> the getter and setter pair have to follow strict rules/laws to be considered a lens
14:42:15 <fen_> ok
14:42:16 <jle`> the rules dissalow a getter/setter pair, together, to form a lens into a head of a list
14:42:29 <fen_> thats why we were using Nonempty
14:43:02 <fen_> ah, then we need a different isomorphism
14:43:15 <fen_> Nonempty a ~ (a,Maybe (Nonempty a))
14:43:29 <jle`> yeah, NonEmpty a ~ (a, [a]).  that's what gives you the ability to hav ea lens on the head of a NonEmpty
14:43:42 <fen_> ok
14:43:47 <fen_> so what about prisms?
14:43:47 <jle`> fen_: but to get back to Selection, what sort of operation were you looking to define on it?
14:43:50 <Solonarv> (by composing this iso with _1, say)
14:44:05 <fen_> right, sure 
14:44:07 <jle`> fen_: prisms means you have an isomorphism between 's' and `Either a q`
14:44:21 <fen_> there are many isomorphisms and we are restricting to the head version
14:44:38 <jle`> so in your case, `Selection (a ': as)` is isomorphic to `Either a (Selection as)`
14:44:51 <jle`> which means you can have two prisms, selectHead :: Prism' (Selection (a ': as)) a
14:45:00 <jle`> and selectionTail :: Prism' (Selection (a ': as)) (Selection as)
14:45:18 <fen_> data Selection (as :: [*]) where 
14:45:22 <fen_>  Pass        :: Proxy a -> Selection as -> Selection (a ': as) 
14:45:22 <fen_>  Selectction ::       a -> Proxy     as -> Selection (a ': as)
14:45:32 <jle`> but, there is no `Lens' (Selection (a ': as)) a`
14:45:51 <fen_> right, just like how there is no `Prism' for Nonempty
14:46:23 <jle`> there's no prism for the head of NonEmpty yes. because the isomorphism to a sum doesn't exist
14:46:36 <fen_> so now how do we do traverse?
14:46:37 <jle`> but, Selection and NonEmpty i wouldn't say are very similar types
14:46:38 <fen_> or unfold?
14:46:43 <jle`> fen_: what do you mean by 'traverse' ?
14:46:53 <fen_> from data.Traversable
14:46:59 <jle`> well, the kinds don't align
14:47:05 <fen_> or the version which takes the "basefunctor"
14:47:10 <fen_> as a parameter
14:47:40 <jle`> but you can get a lens-library traversal, `Traversal' (Selection (a ': as)) a`
14:47:59 <fen_> idk what that is or if its the right thing 
14:48:07 <Solonarv> which is just the same as the Prism, you've just chosen to forget that it's a prism
14:48:25 <fen_> !?
14:48:43 <jle`> traverseHead :: Traversal' (Selection (a ': as)); traverseHead f (Pass x xs) = pure (Pass x xs); traverseHead f (Selection x xs) = Selection <$> f x <*> pure xs
14:48:49 <fen_> liek it could be a lens or a prism?
14:48:51 <jle`> and that gives you a traversal into the first item of your Selection
14:49:05 <jle`> so you have a prism into the first item, and you also have a traversal
14:49:15 <Solonarv> that is a Prism if you write it properly (which I can't be bothered to do)
14:49:17 <jle`> (but, all prisms give rise to traversals in general)
14:49:17 <fen_> nonoono
14:49:20 <fen_> this is all wrong
14:49:37 <fen_> a traversal should modify all the values
14:49:40 <fen_> :t traverse
14:49:41 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
14:50:08 <jle`> "a traversal should modify all the values" is definitely not true :)
14:50:17 <jle`> consider traverse for tuples
14:50:23 <jle`> it only modifies the second value, not the first value
14:50:30 <fen_> all the values of that parameter
14:50:38 <Solonarv> also not true
14:50:40 <jle`> and so, what is the parameter here?
14:50:48 <jle`> what parameter are we modifying here?
14:50:51 <Solonarv> consider: every Lens is a valid Traversal
14:51:02 <Solonarv> and a Lens can only ever target one value
14:51:07 <fen_> oh right its the prism being like an extended tuple but with sum instead of product
14:51:09 <jle`> for `Traversal' (Selection (a ': as)) a` ... we *do* modify all of the values of the first parameter
14:51:15 <fen_> so we only need to modify one value
14:51:26 <Solonarv> similarly a Prism always targets one or zero values
14:51:29 <fen_> the one corresponding to the type at a particular position in the list of types
14:51:32 <jle`> right, here we modify one value because one value is *all* values
14:51:42 <jle`> so it is true that our traversal here modifies all values of that type parameter
14:51:45 <fen_> hmmm
14:51:49 <jle`> it's just that we have at most one value of that type parameter
14:52:07 <jle`> and all other values have a different type
14:52:20 <jle`> so this is a true traversal, even under your definition :)
14:52:45 <fen_> so when we extend the idea of traverse over Selection-like things (how do you say that, extensible sum types?) - we get this prism traversal thing which just modifies the value according to the type of the input function
14:53:24 <jle`> well for things parameterized over a list of types, we can only touch one of them with a rank1 function
14:53:27 <fen_> but then how do you unfold them?
14:53:38 <jle`> what would it even mean to unfold them?
14:53:47 <fen_> :t unfoldr
14:53:48 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
14:53:56 <fen_> but with the correct base functor
14:54:03 <jle`> right, you have problems now because of the heterogeneity
14:54:05 <fen_> that we gave in the isomorphism with Nonempty
14:54:09 <fen_> hmm
14:54:23 <jle`> by the way, Selection is a weird analogy to use from list
14:54:35 <jle`> lists are essentially successive products
14:54:41 <jle`> but selection here is successive sums
14:55:08 <jle`> what you have is more analogous to (Int, a) than [a]
14:55:18 <fen_> well we could have a HList?
14:55:29 <jle`> yeah, HList is closer analogy to lists
14:55:37 <fen_> but then the same problem unfolding them
14:55:44 <jle`> well, one trick a lot of people do to write functions to "map over items" in an HList is to parameterize it over a functor
14:56:30 <jle`> you have might have seen it; data Prod :: (k -> Type) -> [Type] -> [Type]; PNil :: Prod f '[]; (:<) :: f a :< Prod f as -> Prod f (a ': as)
14:56:47 <jle`> so a Prod f '[Int, Bool, String] contains an `f Int`, a `f Bool`, and an `f String`
14:56:57 <jle`> this is the vinyl Rec type, among other things
14:57:01 <fen_> well its pretty easy to unfold an (Int,a) if thats really what this boils down to
14:57:14 <jle`> the problem with generalizing unfold/etc. to this is the heterogenity
14:57:24 <jle`> so the neat thing about adding a functior is that now you get a meaningful rank-n map
14:57:27 <fen_> ok
14:57:30 <fen_> at this point
14:57:32 <hololeap> ok, i made a working parser, but i had to resort to parsing individual pieces and gluing it together in the Either monad: http://dpaste.com/3JF1PC7
14:57:39 <jle`> mapProd :: (forall x. f a -> g a) -> Prod f as -> Prod g as
14:57:42 <hololeap> is there a better way to write this?
14:57:48 <fen_> it should be noted that it *has* to have only one parameter!
14:57:53 <fen_> :-(
14:57:58 <fen_> because its totally incomplete
14:58:02 <jle`> mapProd :: (forall x. f x -> g x) -> Prod f as -> Prod g as
14:58:15 <jle`> traverseProd :: Applicative h => (forall x. f x -> h (g x)) -> Prod f as -> h (Prod g as)
14:58:26 <jle`> so with traverseProd we have a traversal over all items in a Prod
14:58:30 <jle`> but it's a Rank2 traversal
14:58:48 <jle`> you could get something similar with HList, because HList ~ Prod Identity, but ... note the type:
14:58:56 <jle`> mapHList :: (forall x. x -> x) -> HList as -> HList bs
14:59:05 <jle`> is pretty boring, because the only function of type (forall x. x -> x) is id
14:59:33 <jle`> fen_: well, Prod has two parameters, *but* it's useful to think of when you fix a single parameter
14:59:45 <jle`> Prod is most useful when you "partially apply" it, so to speak
14:59:51 <jle`> fen_: like you see for HList, HList is just Prod []
14:59:57 <jle`> er, Prod Identity
15:00:05 <jle`> so Prod Identity is single-parameter
15:00:20 <jle`> another thing you can do is `Prod Sing`, which is single-parameter
15:00:26 <jle`> can you guess what `Prod Sing` is?
15:00:39 <jle`> Prod Sing :: [Type] -> Type, or even [k] -> k
15:00:43 <jle`> * [k] -> Type
15:01:20 <jle`> hololeap: looks good to me :)  there's a lot you could refactor in terms of Applicative combinators as well
15:01:33 <fen_> Selection?
15:01:37 <jle`> fen_: maybe Sing is a bad example because it brings in an external library; how about `Prod TypeRep`, from Type.Reflection
15:01:58 <jle`> but, think about what `Prod Sing '[a,b,c]` contains
15:02:09 <jle`> it contains a `Sing a`, a `Sing b`, and a `Sing c`
15:02:25 <jle`> which is just values `a`, `b`, and `c`
15:02:49 <jle`> so ... Prod Sing is equivalent to a value level list! :O  Prod SBool is equivalent to [Bool]
15:03:13 <jle`> Prod TypeRep, or Prod Sing :: [Type] -> Type, is equivalent to a list of types
15:03:15 <hololeap> jle`: could you give me an example of what you mean by Applicative combinators? do you mean doing it without a `do` block?
15:03:35 <jle`> hololeap: not necessary entirely without a do block, but a lot of _ <- things might be simpler with Applicative combinators
15:04:42 <jle`> hololeap: for example, `i <- many (noneOf ".") *> char '.' *> count 11 anyChar
15:04:54 <jle`> or i <- count 11 anyChar <* space
15:05:03 <hololeap> oh, sure
15:05:31 <jle`> fen_: and so here's something neat, too, `Prod (TypeRep :*:)`, where :*: is Functor product (from Data.Functor.Sum)
15:05:44 <fen_> TypeRep is not easy to understand
15:05:49 <jle`> er i mean Prod (TypeRep :*: Identity)
15:05:59 <jle`> or Prod (Sing :*: Identity), they're equivalent here
15:06:18 <jle`> a Prod (Sing :*: Identity) '[Int, Bool, String]
15:06:29 <jle`> contains an Int, a Bool, and a String, just like HList
15:06:40 <jle`> but they're all paired with a singleton telling you what type that is
15:06:40 <fen_> wow
15:06:48 <jle`> so now look at what the traversal's type is
15:07:00 <fen_> so we can encode both regular and heterogeneous lists in one thing
15:07:00 <vivit> Is there any way to declare a type variable inside the scope of a datatype definition
15:07:01 <jle`> mapProd :: (forall x. f x -> g x) -> Prod f as -> Prod g as
15:07:07 <jle`> it becomes:
15:07:25 <jle`> mapProd :: (forall x. Sing x -> x -> g x) -> Prod (Sing :*: Identity) as -> Prog g as
15:07:27 <fen_> vivit: no!
15:07:31 <fen_> we dont have Let
15:07:37 <jle`> so now your mapping function gives both the value inside the hlist ... *and* a singleton telling you what type it is
15:07:39 <fen_> unless you define it maybe?
15:07:48 <jle`> vivit: unfortunately no :'( but you can fake it with GADT syntax
15:07:51 <fen_> but its not built in syntax thats for sure
15:08:04 <jle`> vivit: although i'm not sure what you mean exactly
15:08:08 <geekosaur> I'm not sure what's being asked tbh. in some ways that's forall (which is why it's reused for ScopedTypeVariables)
15:08:08 <jle`> can you give an example?
15:08:08 <vivit> Record syntax has type signatures in it
15:08:12 <fen_> there is some work to be don on static type level scoping
15:08:27 <jle`> yeah, actually i'm not sure what is being asked too.
15:08:37 <jle`> hololeap: actually one major thing, i notice that you use parse twice with two parses
15:08:47 <fen_> it would be like a where bound type family
15:09:08 <fen_> we just dont have those scope
15:09:10 <jle`> oh hm, actually that might be unavoidable because you reverse the string
15:09:18 <jle`> vivit: can you give an example of what you are trying to do?
15:09:24 <vivit> Hold on a moment
15:09:56 <fen_> jle` what about traversable?
15:10:15 <jle`> traverseProd :: Applicative h => (forall x. f x -> h (g x)) -> Prod f as -> h (Prod g as)
15:10:15 --- mode: ChanServ set +o glguy
15:10:16 --- mode: glguy set -j
15:10:33 <jle`> traverseProd :: Applicative h => (forall x. Sing x -> x -> h (g x)) -> Prod (Sing :*: Identity) as -> h (Prod g as)
15:10:47 <jle`> so you get a Rank-N traversal over every item in the type, where you also have access to what the type is
15:10:59 <vivit> Okay
15:11:27 <fen_> so just like a HList of singletons
15:11:37 <vivit> Hey wait a minute
15:11:52 <vivit> (Never mind lol)
15:12:02 <jle`> fen_: well, type singletons and also the value of that type
15:12:04 <hololeap> jle`: yeah, reversing the string simplified it, because there is arbitrary data in the middle of two fixed-length strings
15:12:19 <fen_> type singletons!?
15:12:24 <fen_> brarg
15:12:38 <Tuplanolla> You must really hate fen_ to be teaching him singletons, jle`.
15:12:40 <jle`> hololeap: i guess the point i was going to make was that the entire "point" of parser combinators is to be able to combine them, without exiting and re-entering
15:12:51 <jle`> fen_: just showing you one example of something that can be throw into a Prod :)
15:12:57 <vivit> Okay, so say I want to have a data type that is just an aggregate of functions with one argument each
15:12:59 <jle`> that by varing the 'f', you get a bunch of different possibilities
15:13:09 <jle`> it doesn't have to be singletons, it can be anything you desire ~
15:13:15 <hololeap> jle`: that was actually why i asked. i don't like that i had to parse twice and glue it together in Either
15:13:16 <fen_> i always get worried when i llearn new things its going to make everything iv ever done redundant
15:13:17 <jle`> the 'vinyl' library really goes to town with this concept
15:13:33 <fen_> perhaps this is bound to be the case
15:13:50 <jle`> sunk cost fallacy :)
15:13:58 <fen_> well
15:14:10 <fen_> there is some logic that we are genuinly missing Set and Get classes
15:14:22 <hololeap> but after staring at the Parsec combinators for a while, i didn't see a simple way to do it. my method works, at least
15:14:25 <fen_> just wasnt sure how these were something to do with Prisms
15:14:27 <vivit> Okay so for an example of what I was trying to do:
15:14:44 <jle`> hololeap: yes, the fact that you reverse things breaks the abstraction of parser combinators
15:14:49 <jle`> so this makes sense i think
15:14:57 <jle`> the only other way would be to reformulate your second parser in reverse
15:15:03 <vivit> data CharacterData = CharSheet { getStat :: (Num n) => Statistic n -> n }
15:15:17 <jle`> vivit: ah, you can make a data type that works for *all* Num instances
15:15:20 <fen_> so this Prod encoding seems pretty powerful, maybe it can fit into the Get / Set basecfunctor stuff
15:15:31 * ski idly wonders whether vivit wanted a `forall n. ' in there
15:15:35 <jle`> data CharacterData = CharSheet { getStat :: (forall n. Num n => Statistic n -> n) }
15:15:49 <jle`> that means that whatever function you throw in has to work for *all* Num instances
15:16:03 <ski> @palomer
15:16:03 <lambdabot> Brump!
15:16:07 <hololeap> yeah, well it would be equivalent to the regex /(.*) (.{11})\.[^.]+$/
15:16:13 <jle`> and when you pattern match on it to get it out, you can use it on all Num instances
15:16:54 <hololeap> it just seems really difficult to get Parsec to pull arbtrary data out _before_ reaching something fixed
15:17:15 <jle`> hololeap: is there a way you would do it as a person?
15:17:19 <jle`> how would you know when to stop?
15:17:32 <hololeap> jle`: haha, i would read it backwards
15:18:12 <hololeap> i dunno, it's hard to translate my visual pattern matching skills into code
15:18:17 <jle`> hm. i mean technically could do it with heavy backtracking
15:18:20 <vivit> How can I make (getStat c a) return different types for different values of a but the *same* value of c
15:18:33 <vivit> That's what I want to know
15:18:38 <ski> jle` : where's that `Prod' from ?
15:18:41 <fen_> what would the basefunctor of Prod be?
15:18:49 <ski> i think i accidentally it, the other day
15:18:58 <jle`> hololeap: basically try dropping 0 character then parsing to the end. then try dropping 1 character, etc. ... 
15:19:04 <jle`> maybe a bad idea performance wise :3
15:19:07 <fen_> data Prod :: (k -> Type) -> [Type] -> [Type]; PNil :: Prod f '[]; (:<) :: f a :< Prod f as -> Prod f (a ': as)
15:19:08 <jle`> 🎿 vinyl has it
15:19:25 <jle`> i got the name from type-combinators which has now bitrotted unfortunately
15:19:31 <fen_> is that a ski emoji?
15:19:36 <ski> fen_ : `k' is a singleton variable
15:19:37 <jle`> nowadays if i need it i use vinyl
15:19:53 <jle`> ah yeah, sorry, that was my mistake earlier
15:19:58 * ski doesn't do emojis, only (some) smileys
15:20:09 <jle`> the true kind is Prod :: (k -> Type) -> [k] -> Type
15:20:18 * ski called it `ListOf', fwiw
15:20:40 <ski> (used with a singleton, yes)
15:20:42 <fen_> emojis can be perturbing 
15:21:01 <jle`> yeah, the neat thing is that you can have it without a singleton, and then add the singleton later if you wanted
15:21:06 <jle`> or the Dict of a typeclass instance too
15:21:18 <jle`> data ShowDict a = Show a => ShowDict a
15:21:23 <ski> as long as i'm not exposed to them ,,
15:21:33 <jle`> type ShowableHList = Prod (ShowDict :*: Identity)
15:21:41 * ski nods
15:21:45 <jle`> vivit: that's actually what it already does, with how i wrote it :)
15:22:30 <jle`> getStat :: Num n => CharacterData -> Statistic n -> n 
15:22:42 <ski> vivit : a value of type `CharacterData' contains a polymorphic function, already
15:22:48 <fen_>  Prod Sing ::  [k] -> k
15:22:54 <fen_>  Prod Sing ::  [k] -> *
15:23:12 <jle`> yeah, Sing is a little misleading because it's poly-kinded
15:23:24 * ski . o O ( `Sum Dance' )
15:23:25 <jle`> but the k there is whatever the kind that the singleton is reprenseting
15:23:49 <jle`> so Prod (Sing @k) [k] -> Type, if we allow type-level -XTypeApplications
15:24:06 <jle`> or Prod SBool :: [Bool] -> Type, Prod SNat :: [Nat] -> Type, etc.
15:24:09 * ski . o O ( s/poly-kinded/polymorphic/ )
15:24:52 <fen_> ok, this is a lot to parse
15:25:04 <fen_> jle`
15:25:05 <fen_> thanks
15:25:11 <vivit> jle`: Ah so you just put it outside the record syntax area?
15:25:21 <jle`> vivit: yeah, that's what record syntax does
15:25:24 <jle`> it gives you an accessor function
15:25:31 <jle`> fen_: np :) although i'm not sure if it solves your original function
15:25:40 <jle`> Prod doesn't have a "base functor" in the recursion-schemes sense
15:25:42 <jle`> *original problem
15:25:48 <ski> vivit : a record field automagically defined a field accessor function / projection/selector
15:26:17 <ski> (isn't `Const T' always a "base functor" of `T' ?)
15:26:18 <vivit> Yeah I forget that accessor functions are just mappings
15:26:25 <jle`> the generalization of cata/ana to dependently typed things like this is talked about in http://www.cse.chalmers.se/~peterd/papers/Inductive_Families.pdf
15:26:35 <ski> vivit : unfortunately, yes
15:26:52 <Solonarv> ski: indeed, though that isn't very useful
15:26:54 <jle`> s/just/also
15:27:32 <jle`> 🎿 base functor in the sense that you can abstract away the explicit recursion in the data type definition
15:27:59 <jle`> i don't know if there's a way to do that for Prod, but you can sort of do it with Sum
15:28:23 <jle`> data Sum :: (k -> Type) -> Type where InL :: a -> Sum (a ': as); InR :: Sum as -> Sum (a ': as)
15:28:32 <jle`> ^ that's your Selection type but parameterized over a functor, fen_ 
15:28:43 <jle`> that has explicit recursion but you can make a version without explicit recursion
15:28:55 <jle`> data Sum :: (k -> Type) -> Type where At :: Index as a -> a -> Sum as a
15:29:01 <koz_> Let newtype Foo f a b = Foo (a -> f b). Does Foo f a have an Alternative instance if f has an Alternative instance? 
15:29:07 <jle`> but how you define Index in a way that isn't recursive is a different story ;)
15:29:35 <jle`> koz_: i think so
15:29:46 <jle`> at least Kleisli has one
15:30:02 <jle`> it's probably lawful, if Alternative can be thought of as having any laws :)
15:30:14 <koz_> jle`: It's lawful for some subset of possible Alternative laws. :P
15:30:16 <jle`> (<|>) = (liftA2 . liftA2) (<|>)
15:30:35 <jle`> oh actually it can just be liftA2 (<|>)
15:30:46 <koz_> Yeah, I was wondering why you needed that second liftA2.
15:30:58 <koz_> I keep forgetting liftA2 is a thing, lol.
15:30:59 <jle`> i was thinking about (<>) = (liftA2 . liftA2) (<>) maybe :)
15:31:36 <ski>   data Prod (f :: k -> *) :: [k] -> * where Nil :: Prod f '[]; Cons :: f a -> Prod f as -> Prod f (a ': as)  -- ?
15:31:48 <jle`> actually i was wrong, Kleisli does not have an Alternative instance ...
15:31:50 <koz_> How would empty be then? I can't see how I can 'magic up' an arbitrary a -> f b even knowing that f is an Alternative itself.
15:32:09 <koz_> s/arbitrary/appropriate/ argh
15:32:10 <jle`> but Star does :)
15:32:17 <jle`> https://hackage.haskell.org/package/profunctors-5.3/docs/src/Data.Profunctor.Types.html#line-78
15:32:20 <ski> jle` : don't you just need a version of `Mu' with kind `(([k] -> *) -> [k] -> *) -> [k] -> *)' ?
15:32:51 <koz_> jle`: Hmm, interesting.
15:32:55 <jle`> koz_: (<|>) = liftA2 (<|>); empty = pure empty
15:33:11 <jle`> 🎿 hm, i guess that is fair
15:33:14 <jle`> * ski 
15:33:15 <koz_> Ah, I get it.
15:33:21 <koz_> You just ignore the argument and give back empty.
15:33:49 <jle`>  ski: sounds rather mechanical now that i think about it :)
15:33:49 <koz_> I seem to have this weird moralistic imperative to use every function argument. :P
15:34:13 <jle`> i too was taught not to waste food, in my childhood
15:34:48 <koz_> Must be it.
15:35:22 <koz_> :t Kleisli
15:35:23 <lambdabot> (a -> m b) -> Kleisli m a b
15:35:36 <koz_> So wait, how does Kleisli differ from Foo above?
15:35:42 <jle`> it's the same
15:35:47 <koz_> Oh, derp.
15:35:54 <jle`> it's just that there is no instance in base
15:36:13 <jle`> there is no Functor, Applicative, MOnad instance either
15:36:21 <jle`> i think maybe it's to discourage certain patterns of usage
15:36:45 <jle`> koz_: btw, `Foo m a` is also just `ReaderT a m`
15:37:02 <jle`> and ReaderT a m has an instance of Alternative too
15:37:09 <koz_> So does this mean Kleisli m a is ReaderT a m ?
15:37:22 <jle`> yeah, Kleisli m a ~ ReaderT a m ~ Star m a
15:37:35 <koz_> Yeah, Star just rearranges the type arguments.
15:37:36 <jle`> ReaderT's type parameters are switched so that it can have a MonadTrans instance
15:37:54 <jle`> Star and Kleisli are the same; their parameters are in an order that you can have Arrow and Profunctor instances
15:38:07 <koz_> Yeah, I guessed as much.
15:38:11 <jle`> it's a weird side-effect of this positional system we have in type constructors and typeclasses
15:38:27 <koz_> Well, it's the same reason we have Op.
15:38:46 <koz_> Because for a -> b, the type arguments are in the 'wrong order'.
15:38:52 <jle`> yeah, everything is a bunch of newtype hacks
15:40:28 <koz_> What patterns of Kleisli usage is a lack of Functor, Applicative and Monad instances meant to discourage?
15:41:09 <vivit> Is there a way to define a typeclass  Cl a  that specifies a function but give instances the freedom to return whatever type they want
15:41:56 <koz_> vivit: I'm not quite sure what you mean by that. Do you mean 'the freedom to return any type the implementer wants' or 'the freedom to return any type the caller requires'?
15:42:40 <jle`> vivit: in a sense that's what classes like Functor do
15:42:51 <jle`> it fixes f, but fmap :: (a -> b) -> f a -> f b
15:43:00 <jle`> the a and b can be chosen by the caller
15:43:14 <vivit> Say I wanted to define a typeclass "Trait a" that specified a function "getTrait" and have the return type of getTrait be determined by "a" but not *be* "a"
15:43:16 <jle`> but yeah, it would be helpful to know what sort of problems you are trying to solve
15:43:37 <jle`> vivit: sometimes you can do this using multi param typeclasses, or type families
15:43:53 <Solonarv> vivit: I'd reach for a multi parameter type class + functional dependency here
15:44:01 <jle`> class Trait t a | a -> t where getTrait :: a -> t
15:44:32 <Solonarv> the 'a -> t' bit is literally "t is determined by a"
15:44:39 <jle`> you can have it without the fundep but that could potentially be a type inference nightmare
15:44:42 <vivit> If I want to use that class in a type signature, will I have to supply both parameters?
15:44:50 <jle`> yes
15:44:58 <vivit> Hmm
15:45:10 <jle`> the alternative solution, type families/associated types, will allow you to not need to supply both
15:45:21 <jle`> but MPTC's are often more intuitive to use
15:45:36 <jle`> class HasTrat a where type Trait a; getTrait :: a -> t
15:45:41 <jle`> oops
15:45:43 <jle`> class HasTrat a where type Trait a; getTrait :: a -> Trait a
15:46:03 <jle`> i believe both are essentially the same in functionality in this specific situation
15:46:11 <vivit> Haskell has too damn many generalizations of the idea of the type
15:46:22 <vivit> type classes, type families, kinds
15:46:36 <jle`> depends on what you mean by 'too many' :)
15:47:05 <vivit> Considering that most languages have zero? Probably one or two
15:47:14 <koz_> vivit: That's not because Haskell has too many.
15:47:18 <koz_> It's that most languages have too few.
15:47:18 <Solonarv> the only thing in that list that's actually a generalization of the "type" idea is kinds
15:47:30 <vivit> I would agree that most languages have too few
15:47:40 <vivit> But I would also argue that haskell has too many
15:48:01 <Solonarv> type families are functions that work on types; type classes are properties/relations on types
15:48:22 <koz_> vivit: Which one(s) do you consider excessive?
15:48:58 <jle`> in this case, both MPTC's and associated types give you the sort of functionality you are looking for
15:49:03 <vivit> No particular one is excessive; it's just that there are too many to keep track of :p
15:49:15 <jle`> so there is some freedom here in which you can choose
15:49:23 <koz_> vivit: Not really. They do (fairly) distinct things, and sometimes, you need one particular one.
15:49:35 <koz_> Some are more frequently useful than others, but I think they're all useful sometimes.
15:49:39 <Solonarv> it's certainly true that the zoo is a bit confusing, especially because there are often several ways to accomplish something
15:50:20 <vivit> I'm kidding mostly
15:50:43 <koz_> vivit: Sorry, I have trouble following intent, especially in a text-only medium.
15:50:49 <ski> Solonarv : i suppose higher-order types would be considered a generalization, from the POV of most languages
15:51:04 <vivit> koz_: don't we all?
15:51:20 <koz_> vivit: Me especially. I fail to pick up sarcasm IRL basically all the time.
15:51:30 <koz_> I default to 'serious unless massively and obviously flagged'.
15:51:35 <koz_> It causes some social awkwardness.
15:51:49 <vivit> I can imagine!
15:52:10 <MarcelineVQ> koz_: but it's allways a joke
15:52:23 <koz_> MarcelineVQ: I think a default of 'serious' is safer.
15:52:30 <koz_> YMMV.
15:55:39 <aswsd> is VS code a good IDE for haskell? anyone tried?
15:56:33 <Rembane> aswsd: afaik it's alright. I haven't tested in a while though. Use HIE with it and it should do what you need it to.
15:57:56 <koz_> As long as the GHC you're using is supported.
15:58:02 <koz_> This can be an issue, varying by time of year.
15:58:21 <koz_> (at least it seems to be the case with much of the tooling - I dunno if HIE is exempt)
15:59:34 <aswsd> Rembane: is HIE called the haskell Language Server when I search under extensions?
15:59:45 <Rembane> aswsd: Hm... dunno, try it! 
16:00:21 <aswsd> what is the recommended haskell IDE among experts here?
16:00:27 <koz_> aswsd: Vim.
16:00:27 <aswsd> for newbies
16:00:30 <koz_> Oh.
16:00:49 <sicklorkin> I'm not an expert, but I use HIE and w/nvim+coc and ghcid
16:01:15 <aswsd> I thought vim is a text editor, not IDE.
16:01:26 <koz_> aswsd: You can set it up to give you basically all the benefits.
16:01:37 <koz_> I use Vim with ALE and a small local config.
16:01:38 <sicklorkin> ghcid is also an IDE
16:01:41 <koz_> It works for what I need it to do.
16:01:53 <jle`> when i was a haskell newbie i already knew how to use vim, so i'm not sure if i'd say vim is not for haskell newbies
16:02:00 <jle`> but vim is not good if you don't already know vim, i think
16:02:11 <jle`> or...why not?
16:02:21 <koz_> jle`: It really wasn't that bad IMHO, but maybe I'm not a typical example.
16:02:32 <koz_> Compared to, say, Emacs, which I never understood and still don't, despite years of use.
16:02:41 <jle`> i guess maybe it's not the best idea to try to learn *both* at the same time
16:02:42 <koz_> Vim worked pretty much after 10 minutes of configuration.
16:02:45 <jle`> a new language, and a new editor
16:02:52 <sicklorkin> jle`: I think the vim larning curve isn't that bad.
16:03:09 <sicklorkin> time well invested forsure
16:03:22 <jle`> it's not, but if you're getting started with one or the other, it's easier to focus on learning a language or learning an editor, not both at the same time
16:03:23 <jackdk_> I think the learning curve for either of the old-school unix editors is not that bad, and if you're going to work in teams it's good to know a bit of both
16:03:52 <jackdk_> vim and emacs both have pretty good tutorials
16:04:23 <Solonarv> the problem is needing a tutorial for the editor in the first place, I think
16:04:41 <shapr> how can I set cabal new-install overwrite-policy to always in my ~/.cabal/config ?
16:05:26 <jackdk_> I don't think that's true. Once you start going from normal-user tasks like word processing to professional tools like development environments, I think a bit of learning is fine
16:05:55 <shapr> Solonarv: that's the ad for golang, right? no learning needed?
16:06:03 <Solonarv> shapr: just put 'overwrite-policy: always' in there
16:06:12 <Solonarv> and, I've never touched go, so I wouldn't know
16:06:30 <koz_> shapr: More like 'no learning needed if the last language you learned was C in the 80s'.
16:06:33 <koz_> (aka 'Rob Pike')
16:06:55 <shapr> koz_: as far as I can tell, golang is riding on the popularity of python/ruby coders.
16:07:07 <koz_> shapr: I can only speak from my own experience.
16:07:27 <jackdk_> pretty sure that's true for people fed up with python, but my impression was rubyists went more to elixir or rust
16:07:29 <shapr> I think golang is the perfect next step for a python/ruby coder, it has types that solve some problems, it compiles quickly so it's almost dynamic, it runs fast.
16:08:03 <shapr> Solonarv: I was a solid vim user until I spent a month trying out emacs
16:08:07 <Rembane> It has quite some libraries. 
16:08:26 <shapr> Solonarv: I wanted to see if I was just being difficult in not liking emacs, turns out I was
16:08:34 <koz_> shapr: I was a solid Emacs user until I spent a month trying out Vim. :P
16:08:43 <shapr> koz_: you found something you like! good job!
16:08:49 <koz_> shapr: Likewise. :D
16:09:03 <shapr> I try to introduce people to good things. I am angry if they learned one thing and never tried anything else.
16:09:34 <Solonarv> I've only recently actually switched to vim
16:09:46 <shapr> you like Haskell? try FORTH or Joy or APL or Prolog or ...
16:10:09 <Solonarv> was using vscode for a while before that, but finally got fed up with how it was taxing my poor laptop
16:10:48 <shapr> I like to think that Haskell will be very different and very much better in 100 years. So I gotta go find the cool future features and see if they fit, right?
16:11:15 <shapr> Solonarv: I'm glad you tried new things! Have you written down what you liked (and disliked) about vscode, and now vim?
16:12:06 <Solonarv> not coherently, just in the form of IRC messages ;)
16:12:37 <shapr> I recommend recording your thoughts coherently so you can come back later and learn from what you wrote
16:13:40 <shapr> Solonarv: that worked! I got warnings, but now cabal new-install overwrites: Warning: /home/shae/.cabal/config: Unrecognized field overwrite-policy on line 23
16:13:43 <Solonarv> mhm, should definitely do that
16:14:07 <Tuplanolla> I have this `vim-hatelist.md` that's several hundred lines long...
16:14:14 <Solonarv> shapr: that's... very weird
16:14:18 <shapr> yeah, I dunno
16:14:28 <shapr> Tuplanolla: so you're an experience vim user?
16:14:35 <Tuplanolla> Yes, shapr. One day I'll turn it into an article.
16:15:05 <shapr> I've been using emacs for twenty years now. emacs often makes me angry, but less angry than anything else I've tried.
16:15:29 <Tuplanolla> Those are familiar sentiments.
16:15:53 <koz_> Everything is broken; some things are just less broken than others. :P
16:16:17 <Tuplanolla> Only two segmentation faults, though.
16:16:32 <koz_> I recently read an issue of Doom Patrol (back when Grant Morrison wrote for it), and Niles Caulder has a brilliant set of panels there which describe my reaction to most software. :P
16:16:55 <shapr> I often told people how Haskell could fix the problem they were having in work code, at some point they asked me if Haskell was perfect... golly this language has warts
16:17:19 <shapr> but at least it has pattern matching and real enums, unlike the work codebase I abandoned forever last week
16:17:52 <shapr> koz_: imgur those panels?
16:18:02 <koz_> shapr: I might, once I'm done typing this all up.
16:18:09 <shapr> Tuplanolla: I've had two segfaults in twenty years, that's not bad
16:18:20 <shapr> one of them when I was hot swapping IDE drives (which shouldn't be possible)
16:18:59 <Rembane> For how long did it work?
16:20:07 <shapr> uh, I think four IDE drive swaps before everything started going sideways, and list of kernel complaints was long
16:20:35 <shapr> Rembane: was that what you meant?
16:21:25 <Rembane> shapr: Yup. That's many for something that isn't possible. 
16:22:11 <geekosaur> shapr, fwiw I tossed out a web query for cabal overwrite-policy and got a bunch of .cabal/config-related bugs
16:22:40 <shapr> oh interesting
16:24:45 <Solonarv> I've also noticed install-method not actually working (still had to specify it on the command line)
16:25:25 <shapr> what's install-method ?
16:27:46 <Lears> I'm trying to use some pattern synonyms that should be harmless, but they're breaking type inference. Can anyone tell me what I'm doing wrong? https://gist.github.com/LSLeary/d873b20e73aa1896ac4552de4e1b5753
16:28:47 <jle`> Lears: what ghc are you using?
16:29:05 <Lears> 8.6.3
16:30:08 <toblorone> hi, I've been reading about type systems and I was wondering what are some languages that are structurally typed. A lot of articles online seem to claim that Haskell is structurally typed, but that seems to be obviously wrong
16:31:21 <Solonarv> shapr: specifies how to install binaries, the options are 'symlink' and 'copy'
16:31:45 <Solonarv> it's not in 2.4 but it will be in 3.0 and is already in cabal head, which I use
16:43:49 <Tuplanolla> One segmentation fault was caused by pasting a block selection (tricky indexing) and the other one by signal handler congestion (tricky part of the language), shapr.
16:44:40 <Tuplanolla> You can try this to reproduce the former: http://tuplanolla.no-ip.org/tmp/vimagic.md
16:45:22 <Tuplanolla> I'm optimistic Yi will save me one day.
20:03:36 <remexre> is there a reason why https://p.acm.umn.edu/WqAy1wLR8AA= isn't used as the standard formulation of the free monad?
20:04:03 <remexre> is it just the GADT requirement? because it seems a lot easier to understand written like this :P
20:08:41 <MarcelineVQ> You're in luck, it's not even a GADT, it's just written in GADT syntax and uses an existential
20:09:51 <benzrf> Tuplanolla: this doesnt segfault for me
20:12:04 <roconnor> remexre: That representation overspecifies what a free monad it.  You can distinguish between how different binds are assocatied even though the monad laws say they are equal.
20:12:25 <roconnor> *what a free monad is.
20:12:59 <benzrf> yeah
20:13:59 <remexre> roconnor: oh, so it's a law that they need to have identical representations, rather than just identical semantics?
20:15:29 <roconnor> I mean the law just says they are equal; and I don't really mean to get into the philosophy of what that means.  I just want to point out that other definitions of a free monad, such as the one in the free library, make expressions that are equal under the monad laws indistinguishable (possibly modulo the usual bottom issues we ignore in Haskell).
20:16:42 <roconnor> remexre: the thing that make the above definition bad is that you can actually pattern match to distinguish between expressions that are supposed to be equal.
20:19:10 <benzrf> roconnor: to be fair, you cant if u dont export the constructors :-)
20:19:19 <roconnor> With the free monad implemenation found in the free package, the different expressions that are equal are likely still have different internal representations, and even different operational properties, such as complexity, but you cannot write normal functions in Haskell to draw a distinction between them
20:19:49 <roconnor> benzrf: yep, if you use the module system to hide it you get something that acts like a free monad.   Though I'm not so sure it is that good for understanding what a free monad is.
20:19:59 <benzrf> 👍
20:20:43 <remexre> what makes the other representation better? (other than not needing to hide the ctors)
20:21:51 <roconnor> I mean, it plainly presents a recursive algebraic data type that represents a free monad.  So it is useful for understanding what a free monad is in that respect.
20:23:01 <roconnor> As for applications of a free monad, your link with hidden constructors, or the free package, or any of the other free monad representations all work fine, with different operational tradeoffs.
20:25:06 <roconnor> heck even your linked representation with a comment that says "pinky swear that you will not abuse these exported data constructors for evil purposes" is also reasonable.
20:25:21 <benzrf> Tuplanolla: https://benzrf.com/uploads/06986609a681a4db.webm
20:25:22 <roconnor> for application purposes.
20:33:10 <ski> @pinky
20:33:11 <lambdabot> Uh, I think so, Brain, but I get all clammy inside the tent.
20:33:55 <MarcelineVQ> Sure, Brain, but where are we going to find rubber pants our size?
21:06:46 <nomi> hi, is this channel active?
21:13:55 <ski> nomi, sometimes
21:16:19 <nomi> cool, thanks ski
21:16:29 <ski> did you have any question or comment ?
21:21:51 <nomi> no, but I'm learning haskell and I figure it would be good to have this as a resource if I need it
21:21:59 <ski> okay
21:22:20 <ski> well, at the moment, probably most people in the channel are sleeping, or otherwise busy
21:22:41 <ski> if you stick around, eventually conversation is bound to happen
21:23:01 <ski> you're welcome to stay and lurk, and see what people talk about, perhaps learn a thing or two
21:23:45 <ski> if you do ask a question, later, please make sure to let sufficient time pass after you've stated it, in case the channel is slow at the time
21:24:21 <ski> that meant, wait at *least* half an hour (preferably more) before giving up for that time. and do come back later, the same day, or another day
21:25:04 <ski> (i'm saying this because lots of IRC beginners seem to think that IRC is like IM (Instant Messaging), so that if they don't get an answer within five minutes, then that must be because the channel is dead)
21:25:51 <dumbintel> irc is not what it used to be. These days it feels like a forum more than a  chat.
21:26:28 <ski> (they don't understand that IRC can be more asynchronous. IRC is, mostly, oriented around group discussion in channels with particular topics. and people like to keep their IRC clients connected, even if they're not watching it atm, so that they can later come back and check whether anything interesting has happened)
21:27:14 <ski> (it's very frustrating to see a question you could answer, or a comment you could respond to, but the person who stated it left within five minutes or something, and you only noticed it later)
21:27:32 * ski sighs
21:28:08 <ski> dumbintel : mhm (?)
21:28:36 <dumbintel> mhm?
21:28:56 <ski> i just wondered whether you wanted to expand/elaborate on that remark, is all
21:31:27 <dumbintel> oh, well when freenode came about there were lots of discussions on the topic. Today, or the last 6-8 years irc has been somewhere you lurk and leave a question and maybe it gets answered in an hour
21:32:21 <dumbintel> possibly two. But usually, it doesn't. That being said, with stackoverflow and google irc's reliability as a hub of intellects has fallen to the wayside imo
21:32:49 <ski> well .. at least this channel often is very lively, i think
21:33:05 <dumbintel> Not saying that people here aren't really smart and sharp, just that a decline in discussion is all. irc rooms would be lively a large portion of the time
21:33:15 <ski> Google IRC ?
21:33:18 <ski> okay
21:33:38 <dumbintel> google, *
21:34:31 <dumbintel> or google; 
21:35:53 <dumbintel> I joined irc back in 98, was on DalNet and EFnet, freenode became the goto back in 02 for me
21:36:28 <ski> okay
21:36:38 <dumbintel> maybe 03, I know in college I'd use irc as a resource. Today, google and stackoverflow are more reliable resources if I need a question answered. 
21:36:54 <ski> i started IRCing in 2001 (or was it 2000 ?), on Freenode .. though it was Openprojects, at the time
21:37:03 <ski> in fact, my first channel was this channel ! :)
21:37:31 <dumbintel> haskell was rather new then, or atleast picking up popularity
21:37:51 <ski> (i first saw IRC in high school, i think. some girl in the library was chatting happily away, in turkish. using mIRC, of course)
21:38:42 <ski> (does Google have/offer, a particular IRC interface ? or network ?)
21:38:47 <dumbintel> I wonder which server. I learned about IRC when I got into hacking in 7th and 8th grade. Back in 99
21:38:58 <dumbintel> ski: not that I'm aware of
21:39:16 <dumbintel> or maybe 98
21:39:40 <dumbintel> back then I went by the name "tonelock" 
21:39:59 <ski> which sense of "hacking", if you don't mind me asking ?
21:40:21 <dumbintel> I believe I joined freenode or openprojects due to #2600 taking place here. "hacking" in all senses ;)
21:40:41 <ski> okay
21:41:00 * ski 's older brothers were into the cracking and demo scene
21:41:04 <dumbintel> more like penetration testing before it was called that. Didn't think ethical hacking would become a thing
21:41:24 <ski> ok, so netrunning
21:43:21 <dumbintel> back then, the motto was "got root?" based loosely off of the popular "got milk" slogan :)
21:45:34 <dumbintel> this account is apparently only 9  years old according to nickserv
21:50:44 * ski nods
21:51:03 <ski> (sorry if i'm beeing intermittent .. but i'm trying to welcome a newbie, in another channel, atm)
