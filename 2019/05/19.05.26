00:55:21 * hackage drone 1.0.1 -   https://hackage.haskell.org/package/drone-1.0.1 (matsubara0507)
01:39:21 * hackage deque 0.4.2.2 - Double-ended queues  https://hackage.haskell.org/package/deque-0.4.2.2 (NikitaVolkov)
01:47:21 * hackage deque 0.4.2.3 - Double-ended queues  https://hackage.haskell.org/package/deque-0.4.2.3 (NikitaVolkov)
02:00:08 <ShalokShalom> hi ^^
02:00:56 <ShalokShalom> Cabal tells me that I should put a specific package into the .cabal, while this package is already in. 
02:02:09 <ShalokShalom> I use the Haskell Stack Tool, statically linked
02:12:11 <ShalokShalom> Uploaded file: https://uploads.kiwiirc.com/files/2d6618ce9e67e41850f105378f530c2f/pasted.txt
02:12:52 <ShalokShalom> This is about what I did to utilize stack in order to build the whole thing. 
02:19:20 * hackage hasql-dynamic-statements 0.1 - Toolkit for constructing Hasql statements dynamically  https://hackage.haskell.org/package/hasql-dynamic-statements-0.1 (NikitaVolkov)
02:37:10 <jgt> how do I programmatically clear the prompt in GHCi?
02:37:39 <jgt> I know that :!clear will clear the buffer
02:38:12 <jgt> and that <c-u> (ctrl+u) will clear line while I'm inside GHCi
02:38:31 <jgt> but how do I express that from a predefined command in my .ghci file?
02:49:03 <jgt> I tried :!^U but it was to no avail
02:49:14 <mniip> clear which prompt
02:49:22 <jgt> mniip: in GHCi
02:49:35 <mniip> you mean the text you have input?
02:49:40 <jgt> yes
02:49:58 <shachaf> I had a look and the ghci prompt is already empty.
02:50:03 <erikd> jgt: control-l ?
02:50:06 <jgt> -_-
02:50:17 <ShalokShalom> hi :D
02:50:25 <jgt> if the GHCi prompt is *not* empty
02:50:33 <jgt> meaning I have already typed stuff in there, and forgotten about it
02:50:41 <shachaf> I suggest you provide some more context on your ultimate goal.
02:50:50 <jgt> how do I *programmatically* clear the prompt
02:50:57 <jgt> I don't know how to give more context than that
02:51:02 <ShalokShalom> has anybody else ever had the issue that Cabal complains about a package not being available, while that one is already in "exposed modules"?
02:51:03 <mniip> what do you mean by "programmatically"
02:51:07 <jgt> I wrote *programmatically* in my original question
02:51:12 <mniip> from where?
02:51:13 <shachaf> I know.
02:51:17 <shachaf> But what context is this happening from?
02:51:23 <ShalokShalom> :)
02:51:30 <jgt> mniip: I mean that in the .ghci file, one can define GHCi commands
02:51:40 <mniip> right
02:51:49 <shachaf> What's the program executing the command? How is the program being executed?
02:51:52 <shachaf> You must have more context.
02:51:58 <jgt> yikes
02:52:00 <jgt> ok
02:52:02 <mniip> but to type a ghci command you need to already have started your line with :
02:52:03 <jgt> ultra verbose mode
02:52:10 <mniip> and not have anything else
02:52:22 <mniip> unless you're using some other mechanism to pipe commands into ghci
02:52:23 <jgt> in my .ghci file, I have commands like the following
02:52:29 <jgt> :def! serve const . return $ ":l app/DevelMain\nDevelMain.update\n"
02:53:06 <jgt> in my vim session — in a separate tmux pane — I have leader keys mapped to sending commands out to another tmux pane via the vim-dispatch plugin
02:53:47 <jgt> to run the aforementioned :serve command, which is defined in my .ghci file, I have the following mapping in my .vimrc file
02:53:49 <jgt> nnoremap <leader>gr :Dispatch! tmux send-keys -t left ':serve' C-m<cr>
02:54:14 <jgt> in my vim session, I type <leader>gr and it runs the :serve command in the GHCi session in the adjacent tmux pane
02:54:21 <shachaf> OK.
02:54:32 <shachaf> So it sounds like your vim session has a way of sending keys to your ghci session. Use that.
02:54:40 <jgt> oh my god
02:54:42 <jgt> yes
02:54:44 <jgt> I know that
02:54:55 <jgt> but how do I clear the prompt?!
02:55:11 <jgt> I can clear the *buffer* with :!clear
02:55:14 <mniip> you said it yourself - C-U
02:55:20 <Rembane> Readline <3
02:55:20 <shachaf> The only way I know of to run :foo commands in ghci is for the prompt to already be clear.
02:55:45 <shachaf> Which means no ghci command will do what you want.
02:55:46 <jgt> mniip: Ok, but I don't quite understand how the escape/control sequence/code for this works here
02:55:54 <mniip> well that's not up to GHCI
02:56:01 <mniip> but rather for vim to send the correct characters
02:56:01 <shachaf> Instead you should use your tmux/vim command to send the ^U. This has nothing to do with ghci.
02:56:13 <mniip> I'm assuming there's a pty involved somewhere
02:56:19 <jgt> ahhhhh
02:56:21 <mniip> (otherwise how is readline functioning)
02:56:21 <jgt> yes, that might work
02:57:38 <jgt> now I just need to figure out the syntax
03:01:55 <jgt> ok, so the vim command should look like this: nnoremap <leader>gr :Dispatch! tmux send-keys -t left C-u ':serve' C-m<cr>
03:02:07 <jgt> it's the C-u that clears the line
03:02:24 <jgt> so I should probably move my :!clear command out of my GHCi commands
03:02:32 <shachaf> You might consider C-c instead.
03:02:44 <shachaf> And also probably use C-l to clear the screen if you want to.
03:03:14 <jgt> shachaf: I thought C-c was to "end transmission" iirc
03:03:30 <jgt> as in, wouldn't that quit whatever program has control?
03:04:06 <jgt> oh, in GHCi C-c seems to work fine
03:04:13 <jgt> what's the difference?
03:04:39 <shachaf> You can probably observe the difference by trying both.
03:05:14 <jgt> C-c leaves the line without executing it, and gives me a new prompt
03:05:19 <jgt> C-u clears the line
03:05:42 <shachaf> Yes.
03:05:55 <Maxdamantus> C-u clears the line up to where the cursor is.
03:06:10 <Maxdamantus> C-e C-u clears the line
03:06:24 <jgt> oh, that's a good point
03:08:46 <jgt> ok, I had to use the C-e C-u approach
03:09:13 <jgt> for some reason, C-c just gave me an "Interrupted."
03:19:39 <talqu> hi, serveDirectoryEmbedded does not cache the static files. When serving with serveDirectoryFileServer, all requests after the first one get the response of 304, however with serveDirectoryEmbedded it is always 200. Am I missing something here? 
03:20:47 <shachaf> I think you're missing some context, because those functions aren't in base.
04:13:51 * hackage nagios-config 0.1.0.0 - EDSL to specify Nagios configuration files.  https://hackage.haskell.org/package/nagios-config-0.1.0.0 (hverr)
04:24:20 * hackage hasql-dynamic-statements 0.1.0.1 - Toolkit for constructing Hasql statements dynamically  https://hackage.haskell.org/package/hasql-dynamic-statements-0.1.0.1 (NikitaVolkov)
04:30:21 * hackage data-combinator-gen 0.1.0.2 - Generate a special combinator from any data type.  https://hackage.haskell.org/package/data-combinator-gen-0.1.0.2 (bolt12)
04:54:51 * hackage data-combinator-gen 0.1.0.3 - Generate a special combinator from any data type.  https://hackage.haskell.org/package/data-combinator-gen-0.1.0.3 (bolt12)
04:59:50 <fufler> Hello. I'm trying to write memoized version of two-arguments function. What am I doing wrong? Why do these functions evaluate to different values ? https://repl.it/repls/NavyblueEvenDiskdrive
05:02:31 <f-a> fufler: repl doesn't load here, care to paste it somewhere else?
05:02:37 <f-a> oh, loaded now
05:03:51 <f-a> what does `solve` solve, fufler ?
05:04:20 * hackage haskell-formatter 2.0.0 - Haskell source code formatter  https://hackage.haskell.org/package/haskell-formatter-2.0.0 (evolutics)
05:04:40 <fufler> f-a, Does it really matter?
05:07:51 * hackage haskell-formatter 2.0.1 - Haskell source code formatter  https://hackage.haskell.org/package/haskell-formatter-2.0.1 (evolutics)
05:08:04 <fufler> f-a, If it does, then it's solution for this problem https://projecteuler.net/problem=15. I can't understand what's wrong with memoized version, since it provides invalid result.
05:08:25 <f-a> yeah, it's a polite thing to do
05:13:45 <lavalike> fufler: should c (k,l) point to a different value of r for each different (k,l)?
05:16:16 <fufler> lavalike, I think so
05:17:16 <lavalike> fufler: n=1, k=1, l=2, k*n+l=1*1+2=3; n=1, k=2, l=1, k*n+l=2*1+1=3
05:20:02 <Ariakenom> k and l should be less than n for 2d indexing
05:21:06 <fufler> lavalike, Thanks. I've treated n and m as constants. Didn't realize they were changing.
05:23:29 <fufler> Ariakenom, k ≤ m and l ≤ n since ranges are [0..m] and [0..n]. And this is automatically guaranteed since first recursion call invokes solve m n. Isn't it?
05:24:35 <Ariakenom> lavalike's example had too small n
05:25:04 <f-a> fufler: http://www.ariis.it/link/t/paste2510-0 this should do it
05:25:04 <Ariakenom> fufler:  length [0..n] = n+1
05:25:09 <f-a> it feels very unhaskelly
05:25:28 <f-a> and I am not sure the solve_memoized has any benefit on solve
05:25:57 <Ariakenom> it looks to be O(n^2) instead of O(2^n)
05:26:12 <fufler> f-a, Can't open the link
05:26:46 <Ariakenom> your c indexes wrong
05:26:49 <fufler> Ariakenom, it should be so. regular solve version cannot compute value for 21x21 lattice. I mean it computes too long
05:27:26 <f-a> fufler: https://pastebin.com/jLQppbTc
05:27:54 <f-a> where are you from fufler, if I may ask? (so I can check which IPs my ISP blocks)
05:28:09 <fufler> f-a, Moscow
05:28:39 <f-a> that explains it
05:29:08 <fufler> f-a, How does it explain this? :)
05:29:09 <Ariakenom> link worked for me btw. where are you from f-a?
05:29:40 <f-a> Ariakenom: I am from Italy. My ISP block some IPs from Russia b/c of referral spamminig
05:29:43 <f-a> *spamming
05:30:29 <f-a> fufler: remember to check https://wiki.haskell.org/Euler_problems/11_to_20#Problem_15
05:30:34 <f-a> I always found interesting solutions
05:30:59 <f-a> usually functional
05:32:39 <fufler> f-a, Thanks. Got the problem. I've missed +1 because of range [0..n]. Pretty stupid. Thanks for link, I'll check it as soon as i finish rewriting my own solutions from Python to Haskell.
05:34:12 <f-a> fufler: this one you could solve on paper
05:34:52 <fufler> f-a, c_n^k for the rescue
05:36:20 * hackage data-combinator-gen 0.1.0.4 - Generate a special combinator from any data type.  https://hackage.haskell.org/package/data-combinator-gen-0.1.0.4 (bolt12)
05:37:21 * hackage hw-balancedparens 0.2.0.4 - Balanced parentheses  https://hackage.haskell.org/package/hw-balancedparens-0.2.0.4 (haskellworks)
06:11:51 * hackage hledger-flow 0.12.3.0 - An hledger workflow focusing on automated statement import and classification.  https://hackage.haskell.org/package/hledger-flow-0.12.3.0 (apauley)
06:14:20 * hackage pointfree 1.1.1.5 - Tool for refactoring expressions into pointfree form  https://hackage.haskell.org/package/pointfree-1.1.1.5 (BenMillwood)
06:52:30 <royal_screwup21> I'm trying to understand how parsers work, specfifically chainl1. I don't get the answer to this question https://prnt.sc/ntiosu
06:52:41 <royal_screwup21> specifically, where in the code does *evaluation* happen?
06:53:09 <royal_screwup21> ah actually nvm
09:14:21 * hackage flags-applicative 0.0.3.0 - Applicative flag parsing  https://hackage.haskell.org/package/flags-applicative-0.0.3.0 (mtth)
09:35:51 <PoopSick[m]> hey guys, if i use BangPatterns, in the expression `let !(!a, !b) = foo` first exclamation mark is redundant, am i right?
09:41:26 <monochrom> No.
09:41:46 <monochrom> But you could do some tests.
09:42:10 <monochrom> Could you design an experiment that refutes your hypothesis?
09:45:51 * hackage happstack-authenticate 2.3.4.16 - Happstack Authentication Library  https://hackage.haskell.org/package/happstack-authenticate-2.3.4.16 (JeremyShaw)
09:47:09 <hpc> a small hint (or perhaps a large one) - bang patterns affect behavior with regard to undefined, so that's probably what you want to experiment with
09:48:20 <clever> hpc: do BangPatterns also work in the form of `foo <- action` ?
09:48:21 * hackage rattletrap 7.0.0 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-7.0.0 (fozworth)
09:48:29 <monochrom> Yes.
09:48:29 <clever> like, changing it to `!foo <- action` ?
09:48:40 <clever> nice, i had a problem like that a month ago
09:48:56 <clever> i tried `action :: IO (!Thing)` but it didnt parse
09:49:08 <hpc> it goes in pattern matches
09:49:11 <hpc> anywhere they are
09:49:15 <clever> nice
09:50:36 <f-a> hpc: I am a bit at loss. where does !(!a, !b) differs from (!a, !b)?
09:51:29 <Solonarv> it really shouldn't, (_, _) is already strict
09:51:33 <Solonarv> since it's matching on a constructor
09:51:51 <f-a> yeah that's what I thought
09:52:18 <MarcelineVQ> Solonarv: assuming you use the ( , )
09:52:53 <Solonarv> oh! yes
09:55:21 * hackage clckwrks 0.24.0.11 - A secure, reliable content management system (CMS) and blogging platform  https://hackage.haskell.org/package/clckwrks-0.24.0.11 (JeremyShaw)
09:56:50 <nshepperd> it does differ
09:56:51 * hackage clckwrks-cli 0.2.17.3 - a command-line interface for adminstrating some aspects of clckwrks  https://hackage.haskell.org/package/clckwrks-cli-0.2.17.3 (JeremyShaw)
09:57:12 <nshepperd> that's counterintuitive
09:58:05 <ShalokShalom> hi there
09:58:21 <Solonarv> > let (_,_) = undefined in "no bangs"
09:58:21 <Solonarv> > let (!_,!_) = undefined in "inner bangs"
09:58:21 <Solonarv> > let !(_,_) = undefined in "outer bangs"
09:58:21 <Solonarv> > let (_,_) = undefined in "all bangs"
09:58:26 <lambdabot>  "no bangs"
09:58:26 <lambdabot>  "*Exception: Prelude.undefined
09:58:26 <lambdabot>  "inner bangs"
09:58:27 <lambdabot>  "all bangs"
09:58:37 <Solonarv> whoops
09:58:39 <ShalokShalom> my cabal tells me I need to add a package to its "exposed modules", which is already there...
09:58:43 <Solonarv> > let !(!_,!_) = undefined in "all bangs"
09:58:44 <ShalokShalom> can anybody help me?
09:58:45 <lambdabot>  "*Exception: Prelude.undefined
09:59:54 * Solonarv shakes their head
10:00:00 <Solonarv> these impatient youngsters!
10:00:21 <Solonarv> ShalokShalom: welcome back!
10:00:37 <Solonarv> could you post your cabal file and the full error message?
10:00:38 <ShalokShalom> back
10:01:50 * hackage clckwrks-plugin-ircbot 0.6.17.5 - ircbot plugin for clckwrks  https://hackage.haskell.org/package/clckwrks-plugin-ircbot-0.6.17.5 (JeremyShaw)
10:02:06 <ShalokShalom> sure
10:02:07 <ShalokShalom> thy
10:02:42 <ShalokShalom> https://gist.github.com/ShalokShalom/285efcc7bcc9e716dff0861b88c2be28
10:04:12 <ShalokShalom> https://i.imgur.com/0g4jvDZ.png
10:05:10 <ShalokShalom> I used the Haskell Tool Stack, static 
10:05:12 <ShalokShalom> thanks
10:07:42 <MarcelineVQ> ShalokShalom: In the warning "In exe:elm:" means the section of the cabal file for the executable called elm
10:07:51 * hackage reform 0.2.7.4 - reform is a type-safe HTML form generation and validation library  https://hackage.haskell.org/package/reform-0.2.7.4 (JeremyShaw)
10:07:53 <Solonarv> ShalokShalom: the error occurs while compiling the 'exe:elm' component (described in the 'Executable elm' section, lines 164-185), which doesn't list the module Elm.Package
10:08:09 <ShalokShalom> aha..
10:08:12 <ShalokShalom> ok, thaks 
10:08:18 <ShalokShalom> I will take a look on it
10:08:22 <ShalokShalom> *thanks
10:08:42 <Solonarv> although if you simply add that module there you might just get more errors/warnings
10:08:55 <ShalokShalom> ok..
10:08:59 <ShalokShalom> what do you recommend?
10:09:17 <Solonarv> I think there should be a 'elm-compiler' entry in that section's 'build-depends'
10:09:33 <nshepperd> isn't that just a warning
10:09:45 <nshepperd> it looks like all the actual errors are type errors in the code
10:09:51 <ShalokShalom> this package is supposed to build
10:09:59 <ShalokShalom> so, my build script I mean
10:10:00 <Solonarv> nshepperd: good point
10:10:10 <Solonarv> yeah there are actual errors in the source code
10:10:12 <ShalokShalom> nshepperd: thanks
10:10:19 <ShalokShalom> in the source code of?
10:10:20 <ShalokShalom> Elm?
10:10:38 <Solonarv> yes
10:10:42 <ShalokShalom> might be that this old version dont build with the current Haskell?
10:10:51 <ShalokShalom> since its 0.18, 0.19 is current
10:10:52 <Solonarv> no, that doesn't seem to be the cause of the problem
10:10:57 <ShalokShalom> ok, I see
10:11:06 <ShalokShalom> but, why does it build for everybody else?
10:11:31 <ShalokShalom> I mean, thats the official release
10:11:38 <ShalokShalom> which is used since years
10:11:39 <Solonarv> I can't see the full errors in the screenshot you shared (the top is cut off), so I don't know
10:11:46 <Solonarv> might want to poke the maintainer about it
10:11:46 <ShalokShalom> ok; I see
10:11:54 <ShalokShalom> unmaintined
10:12:00 <ShalokShalom> I should switch to 0.19
10:12:28 <Solonarv> (also, in the future please share errors as text, not images - you could've just added all that to your gist as a second file)
10:12:30 <nshepperd> why are all the elm packages on hackage deprecated
10:13:15 <ShalokShalom> Solonarv: Yes, I know. 
10:13:55 <ShalokShalom> I was so smart to put a glas of water over my laptop and now is it impossible to do any mouse input, so its hard for me to create some text output currently
10:14:07 <ShalokShalom> I tried with > txt.txt but this doesnt work
10:14:50 <MarcelineVQ> nshepperd: dunno but if they are it could be the reason for the elminator libs dev being so active lately
10:15:21 <nshepperd> it seems the latest package is just called 'elm' and is only on github
10:15:49 <nshepperd> meanwhile there's a package on hackage called 'Elm' which is deprecated O_O
10:16:14 <ShalokShalom> guess it is not maintained anymore
10:16:30 <ShalokShalom> if I got his recent talk right, he is using another compiler now
10:16:40 <ShalokShalom> while I have no idea which one
10:17:12 <__monty__> ShalokShalom: You need to redirect stderr to stdout for that redirection to work as you intended `command >out.txt 2>&1`
10:17:24 <ShalokShalom> ok, thanks
10:19:32 <nshepperd> ShalokShalom: it looks kinda like https://github.com/elm/compiler is the correct one now
10:19:56 <ShalokShalom> its that one I use
10:20:14 <ShalokShalom> I use a Pacman based distro, while independent 
10:20:20 * hackage sendfile 0.7.11 - A portable sendfile library  https://hackage.haskell.org/package/sendfile-0.7.11 (JeremyShaw)
10:20:27 <ShalokShalom> And simply adopted the seemingly working Arch AUR package
10:21:01 <k_> https://bit.ly/2HZgKDr
10:22:31 <ShalokShalom> https://gist.github.com/ShalokShalom/64f0f71e3071adbe2faa7f2b4c23b8dc
10:25:18 <Solonarv> okay, I have some idea of how the package is broken
10:26:05 <Solonarv> the package description requires 'indent >= 0.3 && < 0.4', but it is being built with 'indent-0.4.0.1' which is outside that range
10:26:29 <Solonarv> (this is allowed because allow-newer is enabled)
10:26:57 <ShalokShalom> ok?
10:27:35 <ShalokShalom> so this package grew to much, since the build instruction was written?
10:27:46 <ShalokShalom> and how to resolve?
10:27:52 <ShalokShalom> thanks
10:27:57 <Solonarv> well, there's a reason allow-newer is not enabled all the time
10:28:23 <Solonarv> I think you could try to edit the package files to fix this
10:28:45 <Solonarv> but you'd probably be better off just building from github tbh
10:29:27 <nshepperd> why is allow-newer enabled, i wonder
10:29:48 <ShalokShalom> idk
10:29:55 <ShalokShalom> thats the default configuration
10:30:08 <nshepperd> is it in the PKGBUILD
10:30:14 <ShalokShalom> Solonarv: this builds from Github
10:30:15 <ShalokShalom> ok
10:30:51 * hackage flags-applicative 0.0.4.0 - Applicative flag parsing  https://hackage.haskell.org/package/flags-applicative-0.0.4.0 (mtth)
10:31:01 <ShalokShalom> https://gist.github.com/ShalokShalom/dd1b5bba2a496c19734d628defe66db5
10:31:48 <nshepperd> oh, it's in the stack.yaml
10:31:54 <nshepperd> allow-newer: true
10:31:57 <nshepperd> how baffling
10:32:28 <Solonarv> ah, it looks like stack.yaml was added by whoever packaged this
10:32:38 <ShalokShalom> aha, ok..
10:32:46 <ShalokShalom> that means I should remove this?
10:32:49 <Solonarv> at least I don't see a stack.yaml in the current github.com/elm/compiler repo
10:32:52 <ShalokShalom> I mean, it is build with stack
10:33:02 <ShalokShalom> yeah, I show you in a minute
10:33:25 <ShalokShalom> https://aur.archlinux.org/cgit/aur.git/tree/stack.yaml?h=elm-platform
10:33:29 <ShalokShalom> there it is..
10:33:45 <ShalokShalom> set it to false?
10:34:07 <ShalokShalom> while this should be right setting, or?
10:34:27 <nshepperd> set it to false
10:35:14 <Solonarv> you can also just remove that line
10:35:16 <ShalokShalom> ok, fine
10:35:19 <ShalokShalom> ok
10:35:27 <ShalokShalom> and will this break in Arch as well?
10:35:36 <nshepperd> dunno
10:35:40 <ShalokShalom> I guess so, since it uses the packages provided by stack, yes?
10:35:47 <ShalokShalom> since then, I will write a comment
10:35:49 <nshepperd> the latest version of the aur package has elm-0.19
10:36:00 <ShalokShalom> oh, I see..
10:36:05 <ShalokShalom> yeah, sure. thats the issue
10:36:09 <ShalokShalom> I changed that
10:37:20 <nshepperd> you may need an older stack resolver version if you want to build 0.18
10:37:32 <ShalokShalom> so, its building now
10:37:43 <ShalokShalom> with the current 'resolver'
10:37:53 <ShalokShalom> how do I get an older version?
10:38:13 <nshepperd> if it's building and doesn';t have any dependency errors i guess it's fine then
10:38:15 <ShalokShalom> I like that Haskell does install all packages into an own folder
10:38:32 <ShalokShalom> there you can see that Linux is the primary Kernel in the Haskell world
10:38:35 <nshepperd> ShalokShalom: the 'resolver: lts-11.22' line in stack.yaml
10:38:40 <ShalokShalom> most other languages put all in your PATH
10:38:49 <ShalokShalom> ah, I see ofc
10:38:58 <ShalokShalom> and put that to what?
10:39:40 <ShalokShalom> while, I will let it build now, lets see
10:39:45 <ShalokShalom> thanks for the great help
10:39:54 <nshepperd> that comes from the lts versions at https://www.stackage.org/
10:40:03 <ShalokShalom> ok, perfect
10:42:49 <ShalokShalom> well, it now fails with another error: https://i.imgur.com/lyg0s4o.png
10:42:50 * hackage clckwrks 0.24.0.12 - A secure, reliable content management system (CMS) and blogging platform  https://hackage.haskell.org/package/clckwrks-0.24.0.12 (JeremyShaw)
10:43:03 <ShalokShalom> so, changing Stack
10:43:21 <Solonarv> a-ha! yes, do exactly what it suggest there
10:43:48 <ShalokShalom> ok?
10:43:52 <ShalokShalom> i do
10:43:54 <Solonarv> add those four things to the 'extra-deps' section, like so:
10:43:54 <Solonarv> extra-deps:
10:43:54 <Solonarv>  - aeson-pretty-...
10:44:02 <ShalokShalom> ok
10:44:15 <ShalokShalom> and leave stack at 11.22?
10:44:27 <ShalokShalom> i like that concept of Stackage
10:44:29 <Solonarv> yup
10:45:03 <ShalokShalom> the Haskell tools seem to be very rich and there is a lot of stuff around
10:45:22 <Solonarv> a snapshot (or resolver) is a set of packages with a specific version for each package; the extra-deps section allows you to specify different/additional packages and versions for your project
10:45:34 <ShalokShalom> ah, I see
10:45:43 <ShalokShalom> so a collection of different lts packages, yes?
10:45:54 <ShalokShalom> thats awesome. how can you maintain so much?
10:46:05 <ShalokShalom> or is it simply, "so that it can build"
10:46:30 <Solonarv> yeah, the stackage snapshots are sets of packages that all build together
10:46:39 <ShalokShalom> ok, fine
10:46:42 <ShalokShalom> thats nice
10:46:53 <Solonarv> so you don't run into version conflicts as long as all the packages you're using are in the same resolver
10:47:18 <ShalokShalom> cool
10:47:38 <ShalokShalom> how are the error messages improved over the last couple of years?
10:47:50 <ShalokShalom> I find Eta quite appealing do to that
10:48:14 <ShalokShalom> Tried Haskell a few years ago and ditched it because I felt like the error messages actually hate me :)
10:48:59 <Solonarv> hm, they've certainly improved
10:49:12 <Solonarv> but I can't really quantify how much or give examples right now
10:49:32 <absence> does recursion-schemes have something like scanl/scanr?
10:49:51 * hackage clckwrks-plugin-page 0.4.3.16 - support for CMS/Blogging in clckwrks  https://hackage.haskell.org/package/clckwrks-plugin-page-0.4.3.16 (JeremyShaw)
10:50:06 <ShalokShalom> should I add those packages including their shasum, as displayed in the error message?
10:50:17 <ShalokShalom> or simply the name, without version?
10:50:30 <Solonarv> oh you definitely need to specify the version
10:50:35 <Solonarv> I'd copy the shasum as well
10:50:40 <ShalokShalom> ok
10:51:13 <ShalokShalom> there is no extra-deps
10:51:20 <Solonarv> yeah, you'll have to add that
10:51:25 <ShalokShalom> ok
10:53:49 <ShalokShalom> ah, in stack.yaml ^^
10:53:58 <ShalokShalom> i putted it into the cabal file :p
10:54:21 * hackage clckwrks-plugin-media 0.6.16.6 - media plugin for clckwrks  https://hackage.haskell.org/package/clckwrks-plugin-media-0.6.16.6 (JeremyShaw)
11:01:17 <josiah_sama> What's the best QuickCheck tutorial out there?
11:01:30 <ShalokShalom> well, it seems to work ^^
11:01:31 <josiah_sama> I'm struggling to make that transition from ScalaCheck to Haskell QuickCheck
11:01:36 <ShalokShalom> thanks a lot you all
11:01:53 <ShalokShalom> it builds at least
11:02:33 <ShalokShalom> out of curiosity: it reported another package missing, once I added the 4 above mentioned. Why does this happen in stages, and not all at once? 
11:03:12 <Solonarv> ShalokShalom: the new package is probably a dependency of one of the 'extra-deps' you added
11:03:23 <ShalokShalom> ah, I see
11:03:26 <ShalokShalom> makes sense
11:03:38 <ShalokShalom> and I had to put a - in front of the packages 
11:03:41 <ShalokShalom> now all works
11:03:53 <ShalokShalom> I like yaml, by the way ^^
11:04:02 <ShalokShalom> awesome that you use it
11:04:16 <ShalokShalom> all to often in JSON or even XML in use
11:04:32 <Solonarv> well, stack uses it and so do some autoformatters/linters
11:04:40 <Solonarv> cabal uses its own format
11:05:23 <ShalokShalom> aha, I see
11:05:42 <ShalokShalom> I have seen it in other Haskell projects as well
11:05:52 <ShalokShalom> it seems to be popular among the community
11:05:59 <ShalokShalom> also Elm makes use of it
11:06:36 <ShalokShalom> it reflects the indentation sensitivity, I guess  
11:12:51 <ShalokShalom> What are your favorite librarys/tools and that kind of stuff in Haskell?
11:13:04 <ShalokShalom> the most useful communities, tutorials and guides?
11:13:17 <ShalokShalom> guidelines for beginners?
11:15:34 <__monty__> ShalokShalom: This is the most useful community. There's tons of good tutorials, too many to list. Same thing for the libraries, haskell does *not* have a universally agreed upon set of libraries. It's very different from elm in this regard.
11:15:51 <ShalokShalom> ok, I see
11:15:56 <ShalokShalom> thanks :D
11:16:18 <sm> heh I was about to say. http://haskell.org and https://haskell.fpcomplete.com/learn are two good starting points
11:16:42 <Vq> ShalokShalom: http://dev.stephendiehl.com/hask/
11:17:49 <josiah_sama> > ShalokShalom: http://dev.stephendiehl.com/hask/
11:17:49 <josiah_sama> +1.  Love that post
11:17:52 <lambdabot>  <hint>:1:48: error:
11:17:52 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
11:17:58 <sm> @where HTAC
11:17:58 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
11:19:00 <Solonarv> also, if you want something more like a course:
11:19:00 <Solonarv> @where cis194
11:19:00 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
11:19:03 <JoeCordingley> Hi. Importing modules while in the stack repl adds them on to the prompt line until there's no room left for writing functions. Anyone know how to combat this?
11:19:06 <ShalokShalom> Successfully build, thanks a lot community ^^
11:19:46 <Solonarv> JoeCordingley: you can change the prompt using :set prompt or :set prompt-function
11:20:03 <ShalokShalom> Solonarv thanks a lot ^.^
11:20:05 <josiah_sama> Is there a good way to enforce a List needing to be NonEmpty at compile time?
11:20:21 * hackage flags-applicative 0.0.4.1 - Applicative flag parsing  https://hackage.haskell.org/package/flags-applicative-0.0.4.1 (mtth)
11:20:23 <Solonarv> and you can make this apply to all GHCi sessions by default by putting the corresponding commands in ~/.ghci
11:20:32 <zincy> Are these "Game" types going in the right direction? https://github.com/therewillbecode/Bluffy/blob/master/src/Types.hs#L161
11:20:41 <Solonarv> for example here's mine:
11:20:41 <Solonarv> :set prompt "\ESC[1;34m%s\n\ESC[0;34mλ> \ESC[m"
11:20:41 <Solonarv> :set prompt-cont "\ESC[0;34mλ| \ESC[m"
11:20:50 <JoeCordingley> Thanks. I thought I had tried that, obviously not.
11:22:06 <zincy> I am just wondering if I got too fancy when something simpler will do?
11:23:00 <f-a> zincy: undecidable instances?
11:23:16 <f-a> is this for a poker game?
11:23:37 <zincy> yeah
11:23:47 <f-a> I guess "too fancy" is in the eye of the beholder :P
11:24:09 <ShalokShalom> thanks sm as well ^^
11:26:02 <zincy> I mean I have used  type families but I am not sure if I am using them well
11:26:02 <zincy> Kind of an experiment in advanced Haskell
11:26:21 <f-a> zincy: if it is an experiment, then *do* experiment
11:27:04 <zincy> okay continuation monad here I come
11:27:04 <zincy> I am just hoping that type level stuff doesn't make the Aeson instances a nightmare
11:27:28 <zincy> I quite like deriving my instances 
11:27:47 <f-a> yeah, derivingvia and friends are Godsent
11:28:11 <ShalokShalom> did anybody here saw Rich Hickeys talk about the Maybe type implementation and that kind of stuff?#
11:28:18 <MarcelineVQ> zincy: might be relevant when the time comes http://hackage.haskell.org/package/aeson-gadt-th
11:28:45 <ShalokShalom> its called Maybe Not and I am interested if such an implementation as shown in Dotty, is possible here as well
11:28:59 <zincy> oh thanks
11:29:27 <c_wraith> ShalokShalom: Rich Hickey has a lot of good talks.  That isn't one of them.
11:29:38 <ShalokShalom> haha
11:29:48 <ShalokShalom> i like a lot of them, this is one of them
11:30:01 <ShalokShalom> i would be more interested into a technical discussion
11:30:11 <__monty__> He's really anti haskell for some reason.
11:31:03 <ShalokShalom> what do you think about the Dotty implementation?
11:31:18 <ShalokShalom> he is also really anti type system and I am very much for them
11:31:34 <ShalokShalom> I also think Haskell is much more readable as Clojure
11:32:17 <MarcelineVQ> do you have a specific question about Maybe? There's lots of people here who could answer something like that and less people who use/know dotty :>
11:32:38 <c_wraith> I think the real issue with that talk is that he sees all code as application code.  He discounts the possibility of library code where you don't have customers changing their requirements every 10 minutes.
11:32:49 <monochrom> What we need is a psychologist like Freud to trace programmer strong opinions to their childhood trivial incidents.
11:32:52 <ShalokShalom> it starts at 13:00
11:33:00 <zincy> monochrom: haha
11:33:02 <ShalokShalom> MarcelineVQ sounds reasonable
11:33:31 <__monty__> monochrom: I think this one's easy. He must've had a bad curry in his formative years.
11:33:36 <MarcelineVQ> monochrom: That'd be pretty interesting, not Freud in particular though, otherwise it'd all be your parents faults.
11:33:45 <zincy> monochrom: what triggers someone to like haskell?
11:33:47 <ShalokShalom> c_wraith; what is the benefit of not seeing all as application code?
11:34:14 <ShalokShalom> zincy. to me, all its popular traits: its type system, syntax, semantics, purity 
11:34:23 <zincy> Is an operating system kernel application code?
11:34:27 <ShalokShalom> obviously, now its community and tooling :)
11:34:50 <ShalokShalom> zincy: no, I am asking about the benefits
11:35:18 <c_wraith> ShalokShalom: you can choose a representation for data and just keep it.
11:35:37 <ShalokShalom> I can do that with such application code as well?
11:36:12 <c_wraith> Until your customer changes all their requirements.  Which usually happens once a month, for some reason.  Ok, maybe I'm a bit of a cynic there. :)
11:36:19 <ShalokShalom> seems like I can do both cases with one way, and one thing with the other one?
11:36:39 <trcc> Any native english speakers? I need to state that a project ran from start 2016 to end 2018. Usually I would say primo and ultimo, but I do not think that works in English. Is start and end fine?
11:36:49 <zincy> If a new gender pronoun is invented you modify your schema for your DB but your graphics card drivers can stay as is
11:37:08 <c_wraith> trcc: I'd say "ran from the start of 2016 to the end of 2018"
11:37:21 <trcc> c_wraith: sounds better!
11:37:46 <trcc> Thanks
11:38:58 <tty1> can someone explain this error to me please: https://0bin.net/paste/CTxttaNB1Qd9NXSy#kbWWD6BSTZ9sX73y7khGhYE756duDL2OzhB7NHFr4k7
11:39:01 <monochrom> Requirement changes can benefit or get hurt from static typing, depending on the actual requirement change.
11:39:33 <zincy> Is that an argument for keeping your code as abstract as possible?
11:39:47 <monochrom> I know of two convincing use cases for dynamic typing. Beginner encouragement and hot swapping.
11:40:37 <c_wraith> yeah, having done hot swapping in haskell...  you *really* need to design your interfaces carefully to not have them prevent doing anything.
11:40:43 <monochrom> Keeping your code abstract requires knowing the correct abstraction boundary. But you seldom know.
11:40:51 <tty1> Ive been trying all day to fix that error :(
11:41:12 <f-a> tty1: maybe try to use a non js paste servie
11:41:13 <f-a> ce
11:41:18 <ShalokShalom> ahh
11:41:36 <ShalokShalom> i always wanted to ask something, that nobody could really explain to me
11:41:42 <tty1> f-a: recommend one, hastebin stopped working
11:41:53 <f-a> paste.debian.net ? hastebin had js
11:41:54 <iqubic> I use dpaste.
11:41:57 <ShalokShalom> why do we use primitive types, instead of custom types for all and everything?
11:42:20 <c_wraith> efficiency
11:42:36 <ShalokShalom> there is one example in Hickey talk, which would be not a valid critic on Haskell anymore, if only custom types would be used
11:42:37 <c_wraith> cpus work *way* faster with primitive Int or Double types, for instance
11:42:43 <ShalokShalom> well, ofc
11:42:51 * hackage elminator 0.2.1.0 - Generate ELM types/encoders/decoders from Haskell types.  https://hackage.haskell.org/package/elminator-0.2.1.0 (sras)
11:42:52 <ShalokShalom> while I mean in modeling and so on
11:43:04 <ShalokShalom> APIs and so on
11:43:28 <monochrom> In fact most OOP teachers teach premature abstraction, and their reason is the same: anticipating changes in requirements.  But their abstraction is premature because it anticipates only one kind of changes, not the opposite kind.
11:44:50 * hackage ghc-exactprint 0.6.1 - ExactPrint for GHC  https://hackage.haskell.org/package/ghc-exactprint-0.6.1 (AlanZimmerman)
11:44:58 <monochrom> See "the expression problem" for two opposite kinds of additions to requirements, and how one is well-handled by subclassing and the other is well-handled by algebraic data types.
11:45:24 <tty1> can someone explain this error to me please: https://dpaste.de/L7HQ
11:45:25 <monochrom> Of course the OOP teachers are going to talk like only one of them ever happens.
11:47:10 <c_wraith> tty1: usually an error like that means you gave a function one too many or too few arguments
11:47:27 <MarcelineVQ> tty1: line 48 binds leftMap rightMap, so it's thinking you're using those, not the functions.
11:47:48 <tty1> ohhhhh
11:47:51 <tty1> thanks
11:47:58 <MarcelineVQ> The way to tell this is to read the list of bindings in the error
11:48:32 <MarcelineVQ> With the intuition that c_wraith mentions above where you go, hang on, this should be a function, why isn't it... or why doesn't it like my argument count
11:48:50 * hackage SciFlow 0.7.0 - Scientific workflow management system  https://hackage.haskell.org/package/SciFlow-0.7.0 (kaizhang)
11:49:33 <MarcelineVQ> This might be caught by turning on a name shadowing warning, I don't recall
11:49:51 * hackage SciFlow-drmaa 0.1.0 - Scientific workflow management system  https://hackage.haskell.org/package/SciFlow-drmaa-0.1.0 (kaizhang)
11:50:50 <MarcelineVQ> can try -Wname-shadowing and see
11:51:21 <tty1> compiles now thanks :)
12:04:20 * hackage flags-applicative 0.0.4.2 - Applicative flag parsing  https://hackage.haskell.org/package/flags-applicative-0.0.4.2 (mtth)
12:09:53 <sm> "`stack.yaml` now supports `snapshot`: a synonym for `resolver`" \o/
12:10:21 * hackage flags-applicative 0.0.4.3 - Applicative flag parsing  https://hackage.haskell.org/package/flags-applicative-0.0.4.3 (mtth)
12:16:21 <zincy_> Is the continuation monad transformer combined with State a good way of modelling a finite state machine or is there a more suitable way?
12:17:07 <monochrom> You just need State for state, no?
12:17:16 <zincy_> right
12:17:26 <zincy_> but what would ContT wrapping state give me?
12:17:35 <Solonarv> if you don't need to inspect the state machine you can just use a ball of mutually-recursive functions
12:17:49 <zincy_> It would allow me to dynamically alter the state transitions right/
12:18:28 <zincy_> Basically an action is applied to a game state and yields a new game state
12:18:33 <zincy_> so far I have used State
12:18:41 <Solonarv> or something like:
12:18:41 <Solonarv> newtype SMNode i m o = SMNode { nextState :: i -> m (SMNode i m o, a) }
12:19:13 <zincy_> thanks
12:19:16 <Solonarv> each state of your state machine is an 'SMNode' value, and they return each other depending on what input you feed them
12:19:26 <Solonarv> (I think this is MealyT or MooreT from machines)
12:19:34 <zincy_> I guess `m` could be an Either to represent failure
12:20:21 <Solonarv> yeah, or maybe it's not even needed
12:20:22 <zincy_> well it only has * -> * so no actually
12:20:32 <Solonarv> it could be (Either ErrorMessage) though!
12:20:47 <zincy_> Is that a *?
12:20:54 <zincy_> :k Either
12:20:55 <lambdabot> * -> * -> *
12:25:33 <zincy_> So this is that I had before StateT Game IO (Either GameErr ())
12:25:53 <zincy_> Kinda hard to argue with it, why am I looking for more elaborate abstractions
12:28:54 <Solonarv> I'm not really a fan of StateT over IO, tbh
12:40:57 <MarcelineVQ> zincy_: now's your chance to flex on types, model your FSM using a gadt indexed by your state :O
12:41:15 <monochrom> onoes
12:44:40 <zincy_> Does it not look a bit odd to have   -   ActiveGame (Stage 'PreDeal) (Vector 0 Card) (Seats n) (State GameState)
12:44:50 * hackage rattletrap 7.0.1 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-7.0.1 (fozworth)
12:44:53 <zincy_> When all of it is "state" hehe
12:45:12 <zincy_> Solonarv: need the IO for randomness to shuffle cards
12:45:27 <Solonarv> I'm not objecting to having IO
12:46:38 <zincy_> So IO (StateT Game Either GameErr ())
12:46:40 <zincy_> interesting
12:46:53 <Solonarv> what no, that's not what I'm suggesting either
12:47:29 <zincy_> what are you suggesting?
12:48:12 <Solonarv> instead of StateT s IO, use an IORef or something similar to store your game state
12:51:09 <zincy_> Whats the advantage of that?
12:52:23 <Solonarv> StateT behaves non-intuitively in the presence of exceptions, concurrency and similar things
12:52:44 <zincy_> uh ok
12:52:52 <zincy_> cheers
12:54:04 <Solonarv> you can use ReaderT to pass around the IORef/whatever and your code will be just as convenient as if you had used StateT
12:56:20 <Solonarv> since you can write functions like
12:56:20 <Solonarv> modify :: (MonadReader (MVar s) m, MonadIO m) => (s -> s) -> m ()
12:56:20 <Solonarv> modify f = liftIO . modifyMVar f =<< ask
12:57:04 <zincy_> Would it make sense to put it in a TVar instead if you are using STM anyway?
12:57:18 <monochrom> Yes.
12:57:41 <Solonarv> yup!
12:57:42 <zincy_> oooh
12:57:48 <zincy_> That feels elegant
12:58:03 <zincy_> So just a TVar in a Reader nice and simples
12:58:21 <zincy_> thanks
12:58:41 <zincy_> monochrom: I am responsible for my own learning but appreciate the help
13:08:17 <d34df00d> Hi!
13:08:54 <d34df00d> I've just found myself writing `-- TODO migrate to foobar once time-1.9 is available in LTS`. What's the proper way to express this in code so that I get reminded later when I upgrade my stack LTS snapshot?
13:09:02 <Beauty_Without_B> I will start my Live Show in 10 minutes. Check my sexy body, ass, boobs and pussy. Fastest people will join my Private Live for FREE! Be among the first 5 people to write me "FREE INVITE" on my CAM room: https://www.traff.co/Z2D48q :)
13:52:50 * hackage clisparkline 0.1.0.0 - Tiny library to pretty print sparklines onto the CLI  https://hackage.haskell.org/package/clisparkline-0.1.0.0 (bollu)
13:52:54 <bollu> So I just uploaded a package to hackage, and it barfed back this at me: �}T]o�0�+��ak�jHh%1�>�! �h���s�Xsl�v�U��s�]Qb��sϽ�8���׋���c����������N/�\^�����7d��d�����/��:F7c�뺬;ͬ߰�7�أL���s������P��&�/�O���RZ ��ETQ�uڊ��VJa�j�\y/6P�Rhe�]��B )�=�S��\��Đm��h
13:52:56 <bollu> ???
13:53:00 <bollu> what's going on?
13:53:08 <erisco> That just gave me the bell
13:53:41 <bollu> erisco what do you mean?
13:54:06 <erisco> I am guessing there is a 7 in there somewhere
13:55:20 * hackage flags-applicative 0.0.4.4 - Applicative flag parsing  https://hackage.haskell.org/package/flags-applicative-0.0.4.4 (mtth)
14:07:32 <monochrom> Hrm, would it be possible that hackage suddenly decides to give you UTF-16?
14:08:21 * hackage confcrypt 0.2.3.3 -   https://hackage.haskell.org/package/confcrypt-0.2.3.3 (ChrisCoffey)
14:08:30 <iqubic> What the heck is that???
14:09:18 <monochrom> I believe that's exactly the question being asked.
14:09:29 <iqubic> I see.
14:10:47 <shachaf> monochrom: Doesn't look like UTF-16.
14:10:57 <MarcelineVQ> monochrom: I'd wonder about the browser before the website since the docs I'm looking at have "<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />"
14:11:10 <MarcelineVQ> Though idk if that's a gurantee at all hehe
14:11:42 <monochrom> Ah. But browsers don't give you crap like that either.
14:12:04 <monochrom> (Some other crap under some other condition, yes. But not like this.)
14:14:21 <monochrom> I tend to bet on the website being buggy since a web server claiming "UTF-8" is usually hand-coded and a web server's output encoder stage is also usually hand-picked and nothing says they must be in sync unless the programmer triple-checks.
14:15:04 <shachaf> But that data doesn't look like any Unicode encoding I know of.
14:16:57 <monochrom> Now is the time for a sale pitch for phaton-typed bytestrings!  "ByteString UTF8", "ByteString Latin1", and "ByteString UTF32LE"!
14:17:23 <hpc> ByteString DunnoLOL
14:17:43 <shachaf> The best thing to do is to only use UTF-8 anywhere.
14:18:19 * hpc . o O ( type-level record syntax )
14:18:44 <hpc> ByteString {strategy = Lazy, encoding = UTF8}
14:19:06 <monochrom> Oh!
14:19:38 <hpc> that's the kind of "Oh!" that usually has a paper i don't understand after it
14:20:08 <monochrom> Haha don't worry I don't have time to write papers.
14:20:26 <hpc> phew
14:20:37 <monochrom> But be very afraid if goldfiere sees it and also goes "Oh!"
14:21:37 <hpc> i really kind of want this now
14:22:24 <hpc> Parser {stream = ByteString, token = Char} DataStructure
14:22:59 <monochrom> Do we already have this now?  Like if I turn on DataKinds and just write "data T = MkT{x,y :: Bool}" for example?
14:23:20 <Solonarv> not as far as I know
14:24:30 <hpc> i get a parse error when i try it
14:24:45 <monochrom> I guess it doesn't count if I can write "ByteString (MkT False True)" because the point is nice name=value syntax.
14:26:04 <hpc> i see this being most useful with putting type-level features to work in practical libraries
14:26:19 <Solonarv> seems like it should just be a fairly straightforward bit of syntax sugar
14:26:29 <hpc> where things aren't so generic you can't give the type vars a good name anyway
14:26:34 <Solonarv> well, record *update* syntax would be a bit more complicated
14:29:14 <monochrom> . o O ( type instance Foo Int64 = (Foo Int32){size = 64} )
14:32:05 <SrPx> C-like arrays in Formality! https://www.reddit.com/r/haskell/comments/btdhan/inplace_clike_arrays_in_formality_using_linearity/?
14:32:45 <hpc> how about - type Int64 = Word {signed = True, size = 4} -- size in bytes
14:34:20 <hpc> or if someone is writing emulation stuff - type N64Float = Float {roundingMode = something slightly different}
14:43:56 <oo_miguel_win> hi
14:44:10 <Solonarv> hello!
14:49:22 <d34df00d> What's the modern/recommended way to talk to postgresql in haskell?
14:49:47 <hpc> firmly but politely
14:49:48 <hpc> :P
14:49:59 <d34df00d> postgresql-simple looks,well, simple.
14:50:03 <hpc> https://hackage.haskell.org/package/postgresql-simple is alright
14:50:05 <d34df00d> (which is not bad, mind you)
14:50:05 <hpc> heh
14:50:13 <d34df00d> What do you think about http://hackage.haskell.org/package/opaleye ?
14:51:07 <d34df00d> Every time I hear "typesafe" and "DSL" my heart goes a-flutter.
14:51:31 <hpc> every so often i think that kind of library would be nice for sql
14:51:46 <hpc> but usually i think just writing the sql is better
14:52:16 <d34df00d> Well, this is a hobby project, so "just write sql" is boring :)
14:52:19 <hpc> it's already a pretty good language, and what sql is generated is a lot more likely to matter to you than say, what assembly a compiler generates
14:52:20 <d34df00d> Especially given that I'm not good at that.
14:52:43 <hpc> oh, you should get good at sql then
14:52:59 <hpc> i am sure there's open-source databases of things you can mess around with
14:53:07 <d34df00d> Well, I even realized I shall write "having count(1) = smth" instead of putting that in "where", but that's abou tit.
14:53:11 <hpc> my record for meaningful sql query written on purpose is ~80 lines
14:53:17 <d34df00d> Dammit, mine is 3.
14:53:43 <d34df00d> I have about 4 gigs worth of data to play around, but it's pretty stupid.
14:53:58 <hpc> start with nested queries
14:54:09 <d34df00d> Just some state for a web site scraper/alternative UI that the original author got tired of, so I'm picking that up and reimplementing everything in haskell.
14:54:52 <d34df00d> (dom-selector is neat btw, but it has a very limited selector language, so I'm curious if there's anything more powerful)
14:57:19 <yett> hello
14:58:12 <eruvarn> That was quick
15:00:43 <hpc> irc is just more efficient that way
15:00:52 <hpc> on discord it would have taken 10 minutes :P
15:01:40 <infinisil> The same user did the same on another channel, asking "anybody here?" after 5 minutes of silence, and after I told them "no", they left. Then they rejoined with a different nick and ip
15:02:04 <d34df00d> How do you know it's the same user then?
15:02:29 <infinisil> Very similar username and joined right after the other, also with a gateway/web/freenode/* host
15:03:00 <d34df00d> Ah, that's reasonable.
15:03:00 <monochrom> IP doesn't change that quickly.
15:03:03 <infinisil> (And talked again in a similar style)
15:04:07 <monochrom> I even heard that NSA requested ISPs to keep IPs stable so tracking is easier. IOW everyone gets practically static IPs for no extra fee!
15:04:59 <hpc> how nice of them
15:06:20 <dibblego> run open wifi
15:07:09 <eruvarn> why?
15:07:49 <dibblego> because I am not responsible for what my neighbours do, or the car parked out the front right now
15:17:48 <Phyx-> l
15:20:14 <Solonarv> m
15:59:22 <infinisil> a
16:11:21 * hackage reason-export 0.1.0.0 - Generate Reason types from Haskell  https://hackage.haskell.org/package/reason-export-0.1.0.0 (AndreiBarbu)
16:14:51 * hackage servant-reason 0.1.0.0 - Derive Reason types to interact with a Haskell backend  https://hackage.haskell.org/package/servant-reason-0.1.0.0 (AndreiBarbu)
16:28:15 <cjay-> does anyone happen to know how expensive myThreadId is? my intention is to automatically detect IORefs that have crossed thread boundaries and might be stale because of that. 
16:30:50 <hpc> anecdotally in ghci with :set +s
16:30:51 <hpc> Prelude Control.Concurrent> sequence (replicate 1000000 myThreadId) >> return ()
16:30:54 <hpc> (0.45 secs, 296,675,304 bytes)
16:31:41 <hpc> Prelude> sequence (replicate 1000000 (return 1)) >> return ()
16:31:41 <hpc> (0.31 secs, 280,674,120 bytes)
16:31:50 <hpc> so pretty cheap probably
16:31:58 <cjay-> thanks
16:35:16 <shachaf> ghci benchmarks are very unreliable, though.
16:38:47 <cjay-> do I understand the IORef documentation correctly, that "atomicModifyIORef' ref (\x -> (x, ()))" will guarantee that the IORef is not stale after sending it to another thread?
16:40:07 <Solonarv> cjay-: what's a "stale" IORef?
16:41:50 <cjay-> Solonarv: a IORef that doesn't observe the latest value that was written in another thread
16:42:13 <cjay-> I'm basing this on the last sentence of the documentation "An atomicModifyIORef is never observed to take place ahead of any earlier (in program order) IORef operations, or after any later IORef operations."
16:42:28 * Solonarv blinks
16:43:08 <Solonarv> yeah, I suppose atomicModifyIORef <do nothing> acts as a barrier to reordering
16:43:08 <hpc> i think you're reading things into that statement
16:43:17 <cjay-> :\
16:44:04 <cjay-> if that's not the way, is there no way to make sure a IORef is observed correctly after sending it to another thread?
16:44:32 <Solonarv> my instinct would be "use an MVar instead"
16:44:36 <hpc> ^
16:44:54 <Solonarv> because then you can just send an empty MVar to the other thread and block until it's been filled
16:45:04 <Solonarv> which seems to be what you want
16:45:10 <hpc> can you take a step back and describe what you need this for?
16:45:50 <cjay-> the thing is, the IORefs I'm thinking about would usually stay on the same thread. I just want to have safety when accidentally sharing them.
16:46:35 <Rembane> How do you accidentally share an IORef? 
16:46:47 <hpc> i think in that case, i would work on the broader design of what's allocated to what threads so you can know for certain you aren't doing that
16:47:44 <hpc> s/what's allocated to what threads/what each thread is doing/ -- phrased that weirdly
16:47:48 <cjay-> Rembane: having it as a part of the result of an async operation for example
16:48:31 <cjay-> hpc: what if I'm writing a library and can't be sure if users obey the rules?
16:48:36 <cjay-> but still want IORef performance
16:49:00 <hpc> either write your abstraction so it's not possible, or just trust your users
16:49:16 <hpc> make it not your library's responsibility by just leaving it alone
16:49:34 <Rembane> cjay-: Got it. 
16:50:17 <hpc> this sounds like a case of either using MVar, or trusting your users to use MVar instead of IORef
16:55:54 <cjay-> the IORef is an implementation detail of a certain object. I'd have to make functions that repack the object to MVars before sending it to other threads, and then repack it again into the previos form in the destination thread :\
17:08:51 <cjay-> ok it's not that bad, the sending thread could do an atomic write before sending the IORef, no need to repack then
17:09:54 <cjay-> it would be cool if atomicModify in the receiving thread would work too, that's what I meant with the original question
17:12:18 <cjay-> can the cpu core "flush" a memory location to make sure it reveives writes from other cores, or must it always be the threads that writes that does the flushing?
17:12:38 <cjay-> s/threads/core/
17:29:52 <reallymemorable> I am making music with Euterpea and I want to stream it live from my website
17:30:04 <reallymemorable> I have no idea how to approach such a problem
17:30:22 <reallymemorable> has anyone done anything like this
17:34:06 <hpc> from a browser perspective, https://developer.mozilla.org/en-US/docs/Web/Guide/Audio_and_video_delivery/Live_streaming_web_audio_and_video is a good place to start
17:36:01 <reallymemorable> hpc - thanks this is helpful
17:36:11 <hpc> for the backend, my guess would be something like
17:36:39 <reallymemorable> The thing that I am really confused about is how to get a MIDI online
17:36:42 <hpc> vlc or whatever to reencode it to a nice format, and devices / playDev
17:36:50 <reallymemorable> right now i have something client side that loads sound fonts
17:37:07 <gaze___> hey guys, really basic question but what's that function that can take on any type and errors out in evaluation which is useful for stubbing out functions to figure out their types?
17:37:08 <reallymemorable> playDev is a Euterpea function right?
17:37:36 <Solonarv> gaze___: undefined
17:37:48 <Solonarv> or error "your message here" if you want a nicer error message
17:37:52 <hpc> yeah
17:38:10 <reallymemorable> so you have some experience with Euterpea
17:38:22 <hpc> i just googled it
17:38:25 <reallymemorable> oh lol
17:38:26 <hpc> but i have messed with...
17:38:32 <gaze___> Solonarv: that's it! thanks!
17:38:41 <hpc> synthesizer-alsa
17:38:52 <Solonarv> gaze___: you can also use typed holes to help figure out implementations based on types
17:39:11 <Solonarv> and with -fdefer-typed-holes you can still compile a program even if it has holes in it
17:39:27 <reallymemorable> http://alsamodular.sourceforge.net/ this is an open source synth
17:39:28 <reallymemorable> ah
17:39:43 <reallymemorable> so i can install this on my server?
17:41:39 <reallymemorable> should i run this off an EC2 or something?
17:42:02 <reallymemorable> I'm super unfamiliar with even teh basic steps in setting something like this up
18:02:14 <hpc> reallymemorable: you want something that takes an input stream from an audio device, and outputs it in a way browsers can connect to
18:02:32 <hpc> and then have that input device be a virtual device that the thing creates, and your code outputs to
18:04:04 <hpc> if you start by looking at a media player like say vlc, those usually have streaming input/output built in
18:48:40 <reallymemorable> hpc - and host my own instance of VLC?
18:49:37 <reallymemorable> also, sorry -- what kind of virtual input device am i looking for?
19:54:20 * hackage gloss-rendering 1.13.1.1 - Gloss picture data types and rendering functions.  https://hackage.haskell.org/package/gloss-rendering-1.13.1.1 (BenLippmeier)
22:17:51 * hackage polysemy 0.2.1.0 - Higher-order, low-boilerplate, zero-cost free monads.  https://hackage.haskell.org/package/polysemy-0.2.1.0 (isovector)
22:25:38 <jle`> hm, is there a common typeclass on f that just has `empty :: forall a. f a`
22:25:51 <jle`> like 'Plus' but just zero, from Data.Functor.Plus from semigroupoids
22:34:36 <jle`> we have MonadFail but that requires Monad
22:35:10 <jle`> so maybe I want MonadFail without Monad
22:36:39 <iqubic> So you want Fail?
22:38:07 <jle`> heh, i suppose so
22:38:38 <MarcelineVQ> neutral, identity, pointed (sort of), fail, this thing has too many names :<
22:38:53 <jle`> MarcelineVQ: it's not quite pointed
22:38:57 <MarcelineVQ> Right :>
22:38:59 <jle`> it's sort of the anti-pointed
22:39:15 <MarcelineVQ> but not copointed
22:39:24 <jle`> yeah, anti in another way perhaps
22:39:49 <jle`> hm, do you know if neutral/identity exists anywhere?
22:39:57 <MarcelineVQ> not that I can find
22:40:14 <jle`> hm, i guess i'll just use Plus for now
22:40:29 <jle`> ty
22:43:01 <MarcelineVQ> the closest thing I came across http://hackage.haskell.org/package/free-algebras-0.0.7.2/docs/Data-Algebra-Pointed.html but it's not f a, just a. And the instance list is somewhat sparse.
22:44:39 <jle`> hm oh yeah, i could also just look at it from the monoid perspective. a monoid with no <>.
22:44:46 <MarcelineVQ> What does having the typclass you need enable you to do?
22:45:59 <jle`> well i have a system that lets you retract functors from a data type if you have a given constraint on the functor 
22:46:05 <jle`> retract :: Monad f => Free f a -> f a
22:46:14 <jle`> retract :: Applicative f => Ap f a -> f a
22:46:21 <jle`> retract :: Functor f => Coyoneda f a -> f a, etc.
22:46:39 <jle`> one data type i have is `MaybeF f a ~ Maybe (f a)`
22:46:49 <jle`> the constraint on that would only need such a 'fail' typeclass
22:47:27 <jle`> so if i ask for Alternative, or Plus, then it would not be usable in situations where it should be usable
22:47:38 <jle`> retract :: ??? f => MaybeF f a -> f a
22:47:57 <jle`> but admittedly in practice, you probably won't have any types that only support fail and not <|>
22:48:06 <MarcelineVQ> Oh neat, and Monoid (f a) => ... is too restrictive if Alternative is as well I guess?
22:48:27 <jle`> yeah, really you can implement `retract = fromMaybe zero . runMaybeF`
22:48:31 <jle`> all you need is zero to implement retract
22:48:53 <jle`> MaybeF would actually be the free structure of that typeclass
22:49:15 <jle`> in practice this isn't too bad probably because what data types implement empty but not <|> ?
23:06:50 * hackage ip2proxy 2.0.0 - IP2Proxy Haskell package for proxy detection.  https://hackage.haskell.org/package/ip2proxy-2.0.0 (ip2location)
23:35:19 <iqubic> What would MaybeF be?
23:36:15 <iqubic> MaybeF a = MaybeF (Maybe a) (MaybeF a)?
23:38:17 <bahamas> can anyone explain how this definition works? https://github.com/tweag/inline-java/blob/494a37a9956eb1ed47dcf3706799e2dbf0252e13/jni/src/Foreign/JNI/Types.hs#L230 `J` is defined recursively, right?
23:39:49 <dminuoso> bahamas: Yes, its a recursive newtype.
23:40:21 <iqubic> That looks like a weird type.
23:41:31 <bahamas> iqubic: tell me about it. I don't know how to read it
23:41:55 <dminuoso> bahamas: I suppose its intended to being able to dereference arbitrarily often?
23:42:43 <iqubic> It's a ptr, or it's a ptr to a ptr, or it's a ptr to a ptr to a ptr....
23:42:54 <dminuoso> Yup, exactly.
23:42:56 <iqubic> at the end it points to an a.
23:43:05 <dminuoso> iqubic: See the unsafeCast?
23:43:29 <dminuoso> I think its what allows you to terminate that dereferencing and treat whatever you have as no longer a pointer
23:43:42 <iqubic> :t unsafeCast
23:43:44 <lambdabot> error: Variable not in scope: unsafeCast
23:43:49 <bahamas> iqubic: ok. that makes sense
23:43:52 <iqubic> I don't do FFI stuff.
23:44:40 <iqubic> :t castForeignPtr
23:44:41 <lambdabot> error: Variable not in scope: castForeignPtr
23:45:14 <iqubic> unsafeCast :: J a -> J b
23:45:17 <iqubic> unsafeCast (J x) = J (castForeignPtr x)
23:46:58 <iqubic> Again... I don't do FFI, so IDK what that means.
23:54:11 <simg> could anyone tell me why this code fails to compile (error in gist): https://gist.github.com/simg/035ec4d08b866d59196bcc793c13d85e
23:59:01 <simg> I think that I need to lift runConduit into the withArchive monad somehow, but if use liftIO I get a different set of errors 
