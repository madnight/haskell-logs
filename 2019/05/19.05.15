00:00:03 <jusss> and \x -> f (g x)  <*> h
00:00:03 <ski> yes
00:00:19 <ski> @type return
00:00:21 <lambdabot> Monad m => a -> m a
00:00:24 <ski> @type liftM
00:00:25 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
00:00:26 <ski> @type liftM2
00:00:28 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
00:00:28 <ski> @type liftM3
00:00:30 <lambdabot> Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
00:00:34 <MarcelineVQ> Kartha: Oh you're asking to see a cli program made in haskell, not a cli program for haskell?
00:01:00 <ski> `return' could have been called `liftM0'. and `liftM'/`fmap'/`(<$>)' could have been called `liftM1'
00:01:20 <jusss> that liftM is Applicative
00:01:26 <ski> no
00:01:29 <opqdonut> how about calling liftM return1 and liftM2 return2?
00:01:34 <ski> it says `Monad' in the type, not `Applicative'
00:01:45 <opqdonut> or perhaps rreturn and rrreturn in a lispy fashion
00:01:47 <jusss> that liftM is <*>
00:02:39 <jusss> right?
00:02:44 <ski> the only reason we have separate names for `liftM2',`liftM3',&c. (separate from `liftA2',`liftA3',&c.) is because `Applicative' didn't exist at that time the former were invented/named
00:03:09 <ski> jusss : no, `(<*>)' corresponds to `ap', on the monadic side
00:03:12 <ski> @type (<*>)
00:03:14 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
00:03:15 <ski> @type ap
00:03:16 <lambdabot> Monad m => m (a -> b) -> m a -> m b
00:03:57 <jusss> ok, that's advance version of return ?
00:04:01 <ski> `liftM' is `liftA' is `fmap' is `(<$>)'
00:04:05 <ski> advance version ?
00:04:43 <jusss> return :: a -> m a,   and liftM :: (a->b) -> m a -> m b
00:05:03 <jusss> so it gives me feel like that
00:05:15 <jusss> ok, it's fmap
00:06:31 <jusss> <ski> jusss : `(rho ->)' monad is sometimes used to "pass along" an input (here `x'), to several functions (like `g' and `h') here, I don't follow this
00:06:55 <jusss> fmap f g x <*> h ?
00:07:07 <ski> no `x' there
00:07:34 <ski> btw, another way of writing `fmap f g <*> h' is `pure f <*> g <*> h'
00:07:50 <ski> (if you for some reason don't like `f <$> g <*> h')
00:07:50 <jusss> not so fancy
00:08:08 <jusss> I can't take so fancy thing now
00:08:12 <ski> okay
00:08:26 <ski> if you write
00:08:56 <ski>   foo x y = blah (f x) (g x 1) (h y)
00:09:03 <ski> then you can reformulate this as
00:09:13 <ski>   foo x y = (blah (f x) (g x 1) . h) y
00:09:20 <ski> and then, by function extensionality, as
00:09:25 <ski>   foo x = blah (f x) (g x 1) . h
00:09:27 <ski> okaye ?
00:10:18 <jusss> ok eta-reduce
00:10:30 <ski> no, eta-reduction would be going from
00:10:39 <ski>   foo x = \y -> (blah (f x) (g x 1) . h) y
00:10:40 <ski> to
00:10:46 <ski>   foo x = blah (f x) (g x 1) . h
00:11:11 <ski> what i describe just before this is called "function extensionality". it's closely related to eta conversion, but it isn't the same thing
00:11:23 <jusss> ok
00:11:57 <ski> eta conversion says that any function expression `...' is equal to `\x -> (...) x', (assuming the expression `...' doesn't mention `x' (freely))
00:12:11 <ski> function extensionality says that if `f x = g x', for all `x', then `f = g'
00:12:54 <jusss> ok
00:13:11 <ski> (two functions which "behave the same", in the sense of giving equal outputs, for all possible inputs, are actually equal functions. because the only thing you can do with a function, to get information out of it, is to apply it to an input, so that it computes an output)
00:13:22 <ski> anyway, consider instead
00:13:37 <ski>   foo x y = blah (f x) (g x 1) (h y) (i x y)
00:14:02 <ski> now, there's two uses of `y', not just one, so we can't use function composition, `(.)', like we did before, to "get rid of `y'"
00:14:10 <ski> however, we *can* reformulate as
00:14:25 <ski>   foo x y = liftM2 (blah (f x) (g x 1)) h (i x) y
00:14:33 <ski> and then using function extensionality, we get to
00:14:38 <ski>   foo x = liftM2 (blah (f x) (g x 1)) h (i x)
00:15:12 <ski> note that `liftM f g = f . g', in the case of the monad `(rho ->)'
00:15:24 <ski> (`liftM' does the same thing as `fmap', remember)
00:15:56 <ski> jusss : also, `join f x = f x x'. so we can pass the same input `x' twice, using `join'
00:17:16 <ski> jusss : these "tricks" regarding `(rho ->)' can *occasionally* be useful, to make code more pointless .. but one should be really careful that one isn't making the code too clever, that the code doesn't become *harder* to understand, in say a month's time or two 
00:17:27 <ski> ("pointless" here is a technical term)
00:17:37 <jusss> ski the point is we change the parameter in the left of '=' and it changes on the right?
00:18:00 <ski> if we rewrite
00:18:26 <ski>   sumSquares xs = sum (map (^2) xs)
00:18:27 <ski> to
00:18:33 <ski>   sumSquares = sum . map (^2)
00:18:41 <jusss> we need to transform or construct that right part of '=' with a x ?
00:18:47 <ski> then this is said to be written in "pointless" (or "pointfree") style
00:18:55 <ski> the "point" being the explicitly named input `xs'
00:18:57 <jusss> so we can change x in the left part, it will change it the right part?
00:19:37 <ski> pointless style avoids explicitly nameing inputs and outputs (including intermediate results)
00:20:04 <ski> focusing instead on the functions that are composed (using ordinary (serial) function composition, or, sometimes, some more fancy type of composition)
00:20:35 <ski> we focus more on the transformations themselves, that we "pipe together", rather than on the individual values which will "flow along the pipeline"
00:20:57 <ski> jusss : can you give an example of what you're talking about ?
00:21:09 <jusss> ski, sorry, I don't follow
00:21:12 <ski> okay
00:21:39 <jusss> I think this need a time to think
00:21:46 <ski> that may be so
00:22:31 <gentauro> point free style is really good to ensure that input is only used once
00:22:44 <Rembane> If you're not using (***) or (&&&)
00:23:21 <ski> (i don't understand what you mean when you say "we change the parameter in the left of '=' and it changes on the right", or when you say "we need to transform or construct that right part of '=' with a x", or "so we can change x in the left part, it will change it the right part")
00:23:54 * ski . o O ( coinput )
00:24:25 <int-e> @bot
00:24:28 <Rembane> coinput == output? 
00:24:31 <lambdabot> :)
00:25:58 <ski> Rembane : i was more thinking like, `(&&&)' allows an input to be used more than once, `(|||)' allows a coinput to be used more than once
00:26:26 <ski> @type (&&&)
00:26:33 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
00:26:34 <ski> @type (|||)
00:26:41 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
00:27:24 <ski> % :t (&&&) @(->)
00:27:24 <yahb> ski: forall {b} {c} {c'}. (b -> c) -> (b -> c') -> b -> (c, c')
00:27:25 <ski> % :t (|||) @(->)
00:27:25 <yahb> ski: forall {b} {d} {c}. (b -> d) -> (c -> d) -> Either b c -> d
00:27:27 <gentauro> Rembane: but initial input?
00:27:35 <gentauro> wouldn't it already be transfored?
00:28:37 <Rembane> ski: Got it. 
00:29:03 <Rembane> :t (***)
00:29:11 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
00:39:45 <Kartha> MarcelineVQ yes!
01:25:44 <bahamas> how can I convert an Integer to Pico? this is when dealing with functions from the "time" library
01:26:42 <jgt> is this line idiomatic? Or is it too terse? atomically (withRoom app key $ pure . (, ()) . exit) $> ()
01:27:21 <jgt> I'm having difficulty reading around `(, ())`, but maybe I'm just not good at reading
01:29:58 <lavalike> too terse
01:30:26 <jgt> thought so. Left it as a review comment for a colleague.
01:33:32 <phadej> bahamas: depends, `truncate` or `floor` is one way
01:33:46 <phadej> ah, to pico: fromInteger
01:33:59 <Solonarv> bahamas: well, what unit is your Integer in? is it seconds, or something else?
01:35:02 <phadej> % :t Data.Fixed.MkFixed
01:35:02 <yahb> phadej: forall {a}. Integer -> Fixed a
01:35:21 <phadej> % Data.Fixed.MkFixed 1001 :: Data.Fixed.Pico
01:35:21 <yahb> phadej: 0.000000001001
01:35:43 <phadej> with recent enough base, `MkFixed` constructor is exposed; prior that you need to use
01:35:51 <phadej> % :t Data.Fixed.resolution
01:35:51 <yahb> phadej: forall {a} {p :: Type -> Type}. HasResolution a => p a -> Integer
01:36:12 <phadej> :% Data.Fixed.resolution (1 :: Pico)
01:36:16 <phadej> % Data.Fixed.resolution (1 :: Pico)
01:36:16 <yahb> phadej: 1000000000000
01:36:51 <Ariakenom> on terminology: terse isn't the problem. the problem is hard to follow, or something. it's not unreasonable that there may be a both short and clear way of writing it
01:39:09 <bahamas> phadej: `fromInteger` worked. thanks!
01:39:15 <bahamas> Solonarv: it was seconds, yes
01:39:20 <int-e> jgt: I'd probably use void $ ... rather than ... $> ()
01:39:23 <Unhammer> I have a `data F = A | B | C | D | E | Other Text`, can I use genericParseJSON to turn "\"A\"" into A and any other string into Other Text?
01:39:39 <jgt> int-e: void is _definitely_ clearer
01:39:53 <Unhammer> I feel like https://hackage.haskell.org/package/aeson-0.9.0.1/docs/Data-Aeson-Types.html#t:SumEncoding should be useful here, but I really don't understand the docs
01:42:16 <Solonarv> Unhammer: I don't see a way to do that using the generic defaults
01:42:41 <Unhammer> ok, guess I'll have to explicitly parseJSON "A" = return A etc
01:43:19 * ski thinks this `void' ought to be renamed to `ignore' or something like that
01:43:50 <ski> @index void
01:43:50 <lambdabot> Foreign.Marshal.Error, Foreign.Marshal, Foreign, Foreign.Safe, Foreign.Marshal.Safe, Data.Functor, Control.Monad
01:43:52 <Unhammer> or hm could I make a wrapper type  like  `data Foo = F | Other Text` â€¦
01:44:51 <ski> (it can stay `void' in the FFI modules, i suppose. at least the ones pertaining to C. but please, no `void' in `Data.Functor' and `Control.Monad'. `void' ought to be the name for `absurd', in `Data.Void')
01:45:53 <Solonarv> Unhammer: that seems a bit more sensible
01:46:17 <Solonarv> a FromJSON instance that can't produce every constructor smells like a bug waiting to happen, IMO
01:46:40 <phadej> there is `genericParseJSON` in aeson
01:47:34 <phadej> and documentation of ToJSON http://hackage.haskell.org/package/aeson-1.4.3.0/docs/Data-Aeson.html#t:ToJSON mentions that
01:47:47 <jgt> ski: s/ignore/lolwut/
01:47:58 <phadej> and http://hackage.haskell.org/package/aeson-1.4.3.0/docs/Data-Aeson.html#t:FromJSON
01:48:02 <phadej> and https://hackage.haskell.org/package/aeson-1.4.3.0/docs/Data-Aeson.html#t:FromJSON
01:48:06 <Solonarv> yes, but that doesn't help if you want to do weird stuff like "never parse to this constructor"
01:48:53 <phadej> ye,s because how `Other "A"` would be encoded?
01:48:59 <Solonarv> ski: the same function being named different things in different modules in base seems even more terrible than the current situation
01:49:50 <phadej> Solonarv: "generic defaults" is bad wording, as "generics can be parameterised to not use defaultOptions"
01:50:31 <Solonarv> when I said "generic defaults" I actually did mean genericParseJSON; it was unclear though, so thanks for clarifying
02:01:11 <ski> Solonarv : well .. we already have some alias names
02:02:17 <ski> btw, i think it could be nice if we could rename on import and export (but the system knows that it's the same thing, so that if we import the same thing via two different export paths, the system knows that it's the same thing)
02:19:05 <jgt> ski: couldn't you do that [awkwardly] now already?
02:19:37 <jgt> import with `hiding`, and then define some top level identifiers that reference the fully-qualified thing you were hiding
02:19:47 <jgt> (haven't actually tested if this works)
02:56:56 <Unhammer> Solonarv a FromJSON instance that can't produce every constructor smells like
02:56:57 <Unhammer>          a bug waiting to happen, IMO
02:56:59 <Unhammer> the bug already happened because we thought the external api which we don't control had a closed list of possible values, so we didn't get _any_ parse. We want to ignore (and log) any new values they somehow produce =P
02:57:31 <Unhammer> on a not related note, anyone know how to combine Graphics.Rendering.Chart.Easy with the non-easy module?
02:58:10 <Unhammer> I'd like to use â€¦Chart.Easy.vlinePlot inside â€¦Chart.Easy.EC
03:00:16 <jgt> I like the idea of modules graded by difficulty
03:00:33 <jgt> Graphics.Rendering.Chart.IAmDeathIncarnate
03:00:37 <Unhammer> me too, as long as it's easy to step up â€¦
03:00:43 <Unhammer> lol
03:01:54 <berndl> Say I am writing a function with constraints (Functor f, Functor g, Functor h) and I want to use the different fmaps from f, g and h in the definition. Is there some special syntax that allows me to disambiguate all the different fmaps?
03:02:13 <Solonarv> yes - TypeApplications
03:02:23 <Solonarv> you can write fmap @f, fmap @g, fmap @h
03:02:41 <berndl> Excellent.
03:02:47 <Solonarv> (you will also need ScopedTypeVariables to bring these type variables into scope, of course)
03:02:56 <berndl> Solonarv: Let me try.
03:03:45 <Solonarv> I've got to go, so a final reminder: you need an explicit forall with STV
03:03:57 <berndl> Really? OK.
03:04:00 <berndl> Thanks.
03:12:45 <ski> berndl : unfortunately, yes
03:39:43 <enoq> do people have dependency injection frameworks in haskell as well that allows you to swap out side effect functions in your test cases?
03:40:18 <enoq> e.g. don't read from a http request but use this file
03:41:21 <__monty__> I don't know but it sounds like something that could be achieved with the ReaderT pattern.
03:42:18 <enoq> right, so do people actually wrap all of their impure stuff in ReaderT?
03:53:03 <__monty__> I don't know. All I know is "dependency injection" is definitely not a popular thing in the haskell community as far as I've seen.
03:57:55 <berndl> ReaderT is your dependency injection framework.
03:58:38 <Solonarv> I was going to say; in Haskell it's so easy you don't need to call it anything
03:59:10 <Solonarv> it's like talking about the "command pattern" when we can just partially apply functions and/or have them produce an IO () value
04:07:07 <__monty__> Is there an easy way to make fractional literals default to Rational in ghci? Typing it out every time is a bit of a drag.
04:08:13 <Taneb> __monty__: something like "default (Integer, Rational)"
04:09:43 <__monty__> Taneb: Yes, that works. How do I make sure ghci loads that every time it starts?
04:10:12 <Taneb> You could make a .ghci file but I'm not sure how they work
04:18:07 <__monty__> Hmm, .ghci doesn't seem to work with default. I assumed it'd work just as for imports.
04:39:12 <bahamas> is there a safe version of `List.last`?
04:45:26 <maerwald> bahamas: https://hackage.haskell.org/package/safe-0.3.17/docs/Safe.html#v:lastMay
04:46:47 <bahamas> maerwald: thanks!
04:55:51 <absence> are versions of head, last, etc. that return Maybe defined somewhere in the standard library or common dependencies, or just in alternative preludes?
04:57:01 <lyxia> they're in the "safe" library (see link ten minutes ago)
05:00:30 <absence> thanks!
05:04:26 <__monty__> Hmm, suspicious coincidence, are these people in the same course, I wonder?
05:10:19 <bahamas> __monty__: I'm not in a course :)
06:09:47 <svipal> hey !
06:10:05 <svipal> I'm wondering what the 'combine' function used in Hashable.Generics is
06:10:15 <svipal> (https://hackage.haskell.org/package/hashable-generics-1.1.4/docs/src/Data-Hashable-Generic.html#gHashWithSalt)
06:13:24 <svipal> Since the package doesn't work anymore with stack (asks for an old version of base) I tried just copypasting the source in a module since it's so convenient.
06:13:47 <svipal> Turns out GHC tells me 'combine' doesn't exist
06:13:54 <svipal> and I can't find it on hoogle
06:16:56 <dmwit> svipal: https://hackage.haskell.org/package/hashable-1.1.0.0/docs/Data-Hashable.html#v:combine looks like
06:17:03 <Cale> svipal: It's in old versions of Data.Hashable...
06:17:03 <Cale> yeah
06:17:22 <Cale> combine :: Int -> Int -> Int
06:17:23 <Cale> combine h1 h2 = (h1 + h1 `shiftL` 5) `xor` h2
06:19:50 <svipal> thanks !
06:21:02 <Cale> hashable-generics is apparently obsolete -- it's part of the hashable package now
06:21:38 <absence> is anyone familiar with the recursion-schemes blog posts by patrick thomson? part 1 says the next part will discuss anamorphisms, and part 3 says the previous part discussed anamorphisms, but i can't find anything about anamorphisms in part 2
06:21:39 <Cale> also, the combine function that it uses has changed
06:22:24 <svipal> I just realized that there's no need for it anymore too :')
06:23:52 <Cale> absence: I wasn't familiar, but I agree that it seems to be the case
06:24:07 <Rembane> I wonder if they are there but never mentioned by name.
06:24:20 <Cale> It doesn't appear so
06:24:23 <Rembane> Oh
06:24:35 <Rembane> Let me reroll my reading check.
06:25:49 <Rembane> You are completely right.
06:25:52 <Rembane> I was mistaken
06:40:15 <kuribas> @hoogle (Applicative f, Monoid (f a)) => Maybe t -> (t -> a) -> f a
06:40:16 <lambdabot> Safe scanl1May :: (a -> a -> a) -> [a] -> Maybe [a]
06:40:16 <lambdabot> Safe scanr1May :: (a -> a -> a) -> [a] -> Maybe [a]
06:40:16 <lambdabot> Yesod.Paginator.Prelude scanl1May :: () => (a -> a -> a) -> [a] -> Maybe [a]
06:43:30 <dmwit> :t traverse . (pure.)
06:43:32 <lambdabot> (Applicative f, Traversable t) => (a -> b) -> t a -> f (t b)
06:44:32 <dmwit> :t (asum.) . fmap
06:44:34 <lambdabot> (Functor t, Alternative f, Foldable t) => (a1 -> f a2) -> t a1 -> f a2
06:44:50 <dmwit> kuribas: You might like that second one.
06:45:09 <dmwit> well
06:45:27 <dmwit> :t \f -> asum . fmap (pure.f)
06:45:28 <lambdabot> (Functor t, Alternative f, Foldable t) => (a1 -> a2) -> t a1 -> f a2
06:46:36 <kuribas> > ((asum.) . fmap) (+ 2) (Just 3)
06:46:38 <lambdabot>  error:
06:46:38 <lambdabot>      â€¢ Ambiguous type variables â€˜f0â€™, â€˜a0â€™ arising from a use of â€˜show_M11395...
06:46:38 <lambdabot>        prevents the constraint â€˜(Show (f0 a0))â€™ from being solved.
06:46:47 <kuribas> > ((asum.) . fmap) (+ 2) (Just 3) :: [Int]
06:46:49 <lambdabot>  error:
06:46:49 <lambdabot>      â€¢ No instance for (Num [Int]) arising from a use of â€˜+â€™
06:46:49 <lambdabot>      â€¢ In the first argument of â€˜(asum .) . fmapâ€™, namely â€˜(+ 2)â€™
06:47:16 <kuribas> > (\f -> (asum. . fmap (pure.f)) (+ 2) (Just 3) :: [Int]
06:47:18 <lambdabot>  <hint>:1:15: error: parse error on input â€˜.â€™
06:47:24 <kuribas> > (\f -> (asum. fmap (pure.f)) (+ 2) (Just 3) :: [Int]
06:47:26 <lambdabot>  <hint>:1:53: error:
06:47:26 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
06:47:40 <dmwit> nailin' it
06:48:07 <dmwit> > (\f -> asum . fmap (pure.f)) (+2) (Just 3) :: [Int]
06:48:09 <lambdabot>  [5]
06:48:50 <dmwit> > foldMap (Alt . pure . (+2)) (Just 3) :: Alt [] Int
06:48:52 <lambdabot>  Alt {getAlt = [5]}
06:49:31 <kuribas> I want a combinator to construct lists from possible maybe values
06:49:38 <dmwit> :t listToMaybe
06:49:39 <lambdabot> [a] -> Maybe a
06:49:45 <Solonarv> :t catMaybes
06:49:45 <dmwit> :t toList
06:49:46 <lambdabot> [Maybe a] -> [a]
06:49:46 <lambdabot> error:
06:49:46 <lambdabot>     Ambiguous occurrence â€˜toListâ€™
06:49:46 <lambdabot>     It could refer to either â€˜F.toListâ€™,
06:49:49 <Solonarv> :t mapMaybe
06:49:51 <lambdabot> (a -> Maybe b) -> [a] -> [b]
06:49:54 <dmwit> :t F.toList
06:49:55 <lambdabot> Foldable t => t a -> [a]
06:50:05 <Solonarv> a flood of options!
06:50:25 <dmwit> :t maybe []
06:50:27 <lambdabot> (a1 -> [a2]) -> Maybe a1 -> [a2]
06:50:46 <kuribas> > let (?->) = (\f -> asum . fmap (pure.f)) in Just 3 ?-> (+ 2) :: [Int]
06:50:48 <lambdabot>  error:
06:50:48 <lambdabot>      â€¢ Couldn't match expected type â€˜Integer -> Intâ€™
06:50:48 <lambdabot>                    with actual type â€˜Maybe Integerâ€™
06:51:03 <kuribas> > let (?->) = flip (\f -> asum . fmap (pure.f)) in Just 3 ?-> (+ 2) :: [Int]
06:51:05 <lambdabot>  [5]
06:51:38 <dmwit> > let m ?-> f = asum (fmap (pure.f) m) in Just 3 ?-> (+2) :: [Int]
06:51:40 <lambdabot>  [5]
06:52:15 <Solonarv> > let m ?-> f = foldMap (pure . f) m in Just 3 ?-> (+1) :: [Int]
06:52:18 <lambdabot>  [4]
06:52:20 <dmwit> > let m ?-> f = map f (F.toList m) in Just 3 ?-> (+2) :: [Int]
06:52:23 <lambdabot>  [5]
06:53:21 <dmwit> > let m ?-> f = f <$> F.toList m in Just 3 ?-> (+2) :: [Int]
06:53:23 <lambdabot>  [5]
06:53:49 <dmwit> I think that's my favorite. Small enough that I'd even hesitate to define it in the first place.
06:54:39 <kuribas> @hoogle Functor f => f a -> (a -> b) -> f b
06:54:39 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
06:54:40 <lambdabot> Prelude (<$>) :: Functor f => (a -> b) -> f a -> f b
06:54:40 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
06:54:47 <dmwit> :t (<&>)
06:54:48 <lambdabot> Functor f => f a -> (a -> b) -> f b
06:55:17 <kuribas> I might do mapMaybe [mbVar1 <&> \var1 -> ..., ...]
06:56:12 <kuribas> :t foldMap pure
06:56:13 <lambdabot> (Applicative f, Monoid (f a), Foldable t) => t a -> f a
06:56:17 <kuribas> :t mapMaybe
06:56:18 <lambdabot> (a -> Maybe b) -> [a] -> [b]
06:56:35 <kuribas> :t catMaybes
06:56:37 <dmwit> um
06:56:37 <lambdabot> [Maybe a] -> [a]
06:56:44 <kuribas> that's the one...
06:57:17 <kuribas> I suppose mapMaybe is better as I don't need to define another combinator
06:58:07 <dmwit> It occurs to me that we have the < and > convention for pointing to which side's computed values are used, but no convention for which sides are effectful and which aren't.
06:58:51 <dmwit> e.g. compare <$> and <*>, which are both "lifted" ($)
07:03:35 <glguy> Yeah, it's quite a mix: <$ ?? <&> <**>
07:03:47 <kuribas> :t (??)
07:03:48 <lambdabot> Functor f => f (a -> b) -> a -> f b
07:04:54 <glguy> :t iterate ?? True
07:04:55 <lambdabot> (Bool -> Bool) -> [Bool]
07:13:50 <glguy> phadej: is there a public tool you're using to find lower bounds that need to be raised?
07:20:35 <phadej> glguy: there's code I have thrown to github https://github.com/phadej/trustee but it's "deliberately" undocumented
07:21:09 <phadej> also checking lower bounds for e.g. lens is not cheap
07:21:11 <phadej> usr: 18289.040s   sys: 1539.330s   cpu: 887.771%   time: 2233.500s
07:21:22 <Solonarv> oof
07:21:43 <phadej> and that's really just setting each dependency alone to the lower one
07:21:49 <phadej> so it's far from complete check
07:21:50 <Solonarv> how does it work? tries to compile with all past versions using something like binary search?
07:22:35 <phadej> Solonarv: not even that, it finds a lowest version with install plan, and tries to execute it
07:22:47 <Solonarv> ah
07:23:39 <phadej> i.e. it doesn't really search what's the lowest possible bound is, but barely checks that lowest bound specified is ~correct
07:26:04 <phadej> for the search human-based heuristic-feeden "machine" is way more efficient. `trustee` is something I can throw at a package so my machine does something "useful" while I sleep
07:50:49 <sternmull> Data.Time.Format only has defaultTimeLocale. Is there a library with localized TimeLocale values? I already use Data.Time.Zones but that also doesn't provide localized values... which is probably fine because they are dependent on the language and not on the timezone.
08:26:30 <Cale> sternmull: I had a very quick look the other day and didn't find anything.
08:29:47 <sternmull> Cale: Ok, i had not much hope. The state of all the timezone stuff is a bit rough. tz (which is Data.Time.Zones) was the best i found (also only with help of this channel) and that package states "The package is currently in an alpha phase, ...". Sadly the whole topic looks a bit confusing (Tz s. TimeZone etc.) and incomplete.
08:31:51 <strangeglyph> For my project I have an alex lexer description and a frown parser description. Is there an easy way to integrate generating haskell files from those into 'stack build'?
08:37:36 <Cale> sternmull: we tend to use http://hackage.haskell.org/package/timezone-olson
08:41:02 <Cale> sternmull: That'll let you load a TimeZoneSeries from an Olson file (you can get an Olson database for all the timezones online here https://www.iana.org/time-zones)
08:41:22 <Cale> http://hackage.haskell.org/package/timezone-series-0.1.9/docs/Data-Time-LocalTime-TimeZone-Series.html#v:timeZoneFromSeries
08:41:53 <Cale> and then use that TimeZoneSeries along with a UTCTime to determine the TimeZone present for that location at that time.
08:41:58 <sternmull> Does that have any advantage over tz?
08:42:27 <Cale> Olson database is just another name for tz database :)
08:42:59 <sternmull> I saw the TimeZoneSeries but it looked more complex than the stuff in Data.Time.Zones of tz.
08:43:44 <Cale> oh, well, the thing about the tz package is that it just compiles in all the data
08:44:23 <Cale> (which will eventually be out of date)
08:45:34 <Cale> Also it has some slightly foolish stuff in it like the TZLabel type
08:46:48 <Cale> (Who is honestly going to want to pattern match on all those cases?)
08:48:44 <sternmull> and timezone-olson is not "alpha", so i probably should use that instead of tz
08:48:47 <int-e> And where's the AoE timezone in that list?
08:49:34 <glguy> strangeglyph: Cabal already knows how to build .x files with Alex
08:49:46 <glguy> I don't know if it knows how to build whatever file extension frown files use
08:50:05 <strangeglyph> if it doesn't, is my only option a custom Setup.hs?
08:50:13 <glguy> If it doesn't you can use a Custom Setup.hs to have Cabal generate the frown parser
08:51:08 <glguy> strangeglyph: Looking at the docs it doesnt look like it knows about frown
08:51:53 <glguy> strangeglyph: Have you generated modules from Setup.hs before?
08:52:21 <strangeglyph> no. I never even used cabal or stack before. I inherited this project and it originally used Makefiles
08:53:06 <glguy> I have an example of generating a module with a custom setup: https://github.com/glguy/irc-core/blob/v2/Setup.hs
09:00:36 <strangeglyph> glguy: thanks!
09:00:41 <phadej> sternmull: there's nothing `alpha` in tz
09:00:44 <phadej> it's a solid library too
09:01:32 <sternmull> phadej: https://hackage.haskell.org/package/tz-0.1.3.2 "The package is currently in an alpha phase, I'm still experimenting with different ideas wrt. scope/API/implementation/etc. All comments are welcome!"
09:02:11 <phadej> sternmull: that text is there since "Uploaded by MihalyBarasz at Thu Dec 10 23:08:14 UTC 2015"
09:02:38 <sternmull> so what? It is there.
09:03:46 <phadej> honestly, i would rather be sceptical about "this package is stable and suitable for production use" statements; license is still the same NO WARRANTY :)
09:06:20 <phadej> as in, neither stable, provisional or alpha are well defined terms
09:12:02 <phadej> anyway, I have used `tz` for about 3? years in production, and didn't have problems with it
09:12:28 <tdammers> consider this: it's all open source, provided free of charge, so basically that means if you use it, YOU are responsible for it, at least for the scope of your using it
09:12:33 <tdammers> people tend to forget that
09:14:01 <sternmull> i am thankful if a library explicitly states that it is "alpha" or has some other potential deficits. You cant blame me to believe that paragraph :)
09:21:08 <izmar> From John Hughes' talk https://www.youtube.com/watch?v=XrNdvWqxBvA&t=354s, can someone explain how a Region can be defined as Point -> Bool?
09:21:51 <tdammers> without watching the talk, I'd naively assume that since a region is essentially a set of points, we can express it as a function that, for any given point, tells us whether the point is in the set
09:22:07 <izmar> Hm... I suspected that.
09:23:18 <izmar> That's a good thing. But I still can't really picture how one would use this function as a data structure. I probably need to get some hands-on experience and play with Haskell code to grok that.
09:24:27 <[Leary]> It's an extremely convenient representation for certain operations. E.g. intersection = liftA2 (&&); union = liftA2 (||).
09:25:19 <[Leary]> And you can e.g. print a region to a pixel grid just by testing the centre of each pixel for inclusion.
09:26:46 <phadej> yet, contaisn :: Region -> Region -> Bool is impossible to define
09:26:52 <phadej> it really depends on what you are trying to do
09:27:09 <phadej> if you ok registering to skillsmatter site: https://skillsmatter.com/skillscasts/12359-elegant-geometry-with-denotational-design is a related talk (and uses geometry as a running example!)
09:27:57 <izmar> I would like to see the 85 lines of code John talks about, to see how the point data is passed to the Haskell applications entry point and its further travels.
09:28:24 <izmar> Ah nice one phadej.
09:28:26 <phadej> IIRC that paper is not hard to find
09:28:37 <phadej> the John talks about
09:28:48 <izmar> ok, I'll try to dig that up as well then.
09:30:11 <phadej> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.368.1058&rep=rep1&type=pdf
09:34:26 <jpg> Hello guys. How do you write lhs2TeX using -XDataKinds? The parser cannot deal with apostrophes. Although I can Write things like " Prom A " instead of " 'A " and then use a format directive, I would prefer a better solution so my code compiles to TeX with no modification
09:36:08 <izmar> Unfortunately it doesn't list the full source code phadej.
09:36:16 <phadej> izmar: well, there are references
09:36:19 <phadej> jpg: https://github.com/kosmikus/lhs2tex/pull/45
09:43:59 <earnestjfk> I'm running into "ghc.EXE: loadObj: can't preload `\\Mac\[...]\HSWin32-2.5.4.1[...].o' trying to compile a project on Windows 10 inside Parallels using Stack 1.9.3. Full log at https://gist.githubusercontent.com/earnestjfk/59cf54b5ec3dd1a5532c8d4d30ebfe04/raw/6d9bd81b70e97a22c166c5e09e6d9ef10a91ce91/parrot.log. Any suggestions (aside from filling a bug as directed)?
09:44:28 <lyxia> are there advantages to lhs2tex over making a hybrid lhs/tex file in the first place
09:46:11 <int-e> lyxia: lhs2tex does better syntax highlighting, doesn't it?
09:46:53 <lyxia> that may very well be the case, haven't tried :)
09:47:21 <jpg> phadej: this gives me lexical error on ':  = {-"\mathbin{{}^\backprime{}\!\!:}"-} 
09:47:30 <jpg> My lhs2TeX version is 1.22
09:50:42 <phadej> that patch does contain changes to `lhs2tex` itself, so you'll need to compile it
10:01:11 <phadej> jpg: https://imgur.com/a/NW8QPqI
10:02:58 <parenthetical> Hi all, I would appreciate some pointers on how to define an executable semantics for FRP which supports temporal recursion; I thought the following would work but it loops: https://gist.github.com/parenthetical/a339e965a26c393243cddf4078ab21a2
10:07:29 <jle`> parenthetical: do you have a specification for the semantics of your temporal recursion?
10:07:41 <jle`> having an idea of what you want to happen will help with designing an implementation that supports it
10:09:03 <jle`> also i just realized how confusing of a keyword mdo is
10:09:14 <jle`> shouldn't it be rdo or something lol.
10:11:45 <boj> probably consistent with mfix?
10:12:08 <Cale> boj: Though, the m part of mfix refers to the fact that it's monadic
10:12:17 <boj> ah
10:12:20 <Cale> and do is already monadic
10:12:21 <Cale> lol
10:12:28 <izmar> Anyone know a fail-safe way to setup an IDE with Haskell support in Windows 10?
10:12:35 <Cale> But yeah, the new way is to use rec
10:12:58 <Cale> (and in the case of the program at hand, I wouldn't even use do-notation)
10:13:27 <izmar> I've tried Visual Studio Code + Haskero but I get an error "Whilst trying to load:  (dynamic) pthread"
10:36:20 <izmar> Wow, just installed Haskell for Mac and downloaded the Flappy Bird clone
10:36:25 <izmar> It's awesome :)
10:37:46 <izmar> Amazing how small the source code is.
10:38:24 <izmar> It's like all noise has been removed.
10:39:10 <Cale> izmar: Which one?
10:39:38 <izmar> cale https://github.com/mchakravarty/lazy-lambda
10:40:14 <Cale> ahh, Manuel's thing
10:40:23 <Cale> I remember his talk about this :)
10:40:37 * izmar looks on youtube
10:41:39 <izmar> Doesn't seem to be there.
10:42:49 <Cale> https://www.google.com/search?q=Manuel+Chakravarty+spritekit&source=lnms&tbm=vid&sa=X&ved=0ahUKEwiWmZzXip7iAhVDR60KHc7nB3sQ_AUIDigB&biw=2176&bih=1081
10:43:06 <Cale> He's given similar talks at a bunch of places it seems
10:43:28 <qwebirc42601> join
10:43:56 <hpyCdr> I have a function f :: Int -> Int -> Int and the values x, mayY, mayZ where mayFoo :: Maybe Int
10:44:14 <izmar> cale ah cool
10:44:25 <hpyCdr> how can I retrieve Maybe f, which is Just if params are Just
10:44:38 <hpyCdr> I tried f x <$> mayY <*> mayZ
10:45:00 <Cale> f only has two parameters
10:45:00 <hpyCdr> but didn't work in my case (maybe caused by something else, just making sure this is at least correct)
10:45:03 <sarahzrf> hpyCdr: if f only takes two ints, then why are you applying it to three
10:45:21 <hpyCdr> ah that's just an error in my example then
10:45:32 <sarahzrf> lol
10:45:46 <hpyCdr> ;)
10:46:00 <sarahzrf> if you meant "f :: Int -> Int -> Int -> Int", then that should work
10:46:05 <hpyCdr> so the <$> <*> combination with the function and params is correct, right?
10:46:07 <hpyCdr> okay, thanks
10:46:09 <Cale> yeah
10:47:02 <Cale> That's a case where the applicative syntax is probably more helpful than not, but if you'd prefer, you can also write something like  do y <- mayY; z <- mayZ; return (f x y z)
10:47:28 <Cale> In more complicated instances, things like that can be clearer
10:48:05 <hpyCdr> yep, I actually do something like:
10:48:08 <Cale> e.g. even if it was just the "x" rather than the "y" that you had a Maybe of, you'd probably prefer to use do-notation.
10:48:34 <Cale> (because at that point you'd be stuck writing a lambda anyway)
10:48:53 <hpyCdr> https://pastebin.com/Yx1jMXgK
10:49:03 <hpyCdr> where options is going to list all combinations
10:49:37 <hpyCdr> each param might fail, so I want the first working combination if present
10:49:40 <sphalerite> What's the best way of getting a state variable within IO?
10:49:45 <Cale> I'd usually use a case expression rather than null/head
10:50:12 <Cale> sphalerite: There are a bunch of ways, with different advantages...
10:50:26 <Cale> sphalerite: Are you familiar with IORef? That's probably the most straightforward
10:50:27 <hpyCdr> Cale case combined with (x:xs) ?
10:50:55 <sphalerite> Cale: most straightforward sounds good, to fit perfectly with my use of [] and String :)
10:51:28 <Cale> hpyCdr: yeah, so instead of the if expression, you'd have:
10:51:32 <Cale> case options of
10:51:37 <Cale>  [] -> putStrLn ...
10:51:42 <hpyCdr> I think I got it, I like it :)
10:51:45 <Cale>   (x:_) -> ...
10:52:16 <Solonarv> hpyCdr: perhaps instead of mapMaybe and checking whether the resulting list is empty, you could use asum
10:52:25 <Cale> sphalerite: http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-IORef.html
10:52:48 <sphalerite> looks easy, thanks :)
10:52:59 <Solonarv> options = [ pf2Pf ... ]; case asum options of Nothing -> _error; Just result -> _success
10:53:01 <hpyCdr> Solonarv, also nice
10:53:13 <Solonarv> :t asum :: [Maybe a] -> Maybe a
10:53:15 <lambdabot> [Maybe a] -> Maybe a
10:53:47 <aveltras> what are you fellow haskell people using nowadays to manage database schema evolution ?
10:54:42 <Cale> aveltras: Where I work, we've been using groundhog almost entirely for its migrations, but we're switching to Beam soon.
10:54:51 <hpyCdr> Solonarv, went directly with   conversion = asum [...]   case conversion of ...
10:55:14 <Solonarv> yeah, that works too
10:55:38 <Solonarv> asum's type is actually quite general:
10:55:39 <Solonarv> :t asum
10:55:40 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
10:56:54 <Solonarv> using it with f := Maybe is a nice way to say "try these things and keep the first one that worked"
10:57:57 <sarahzrf> is there any reason to expect a difference between a "Monoid (F a)" instance and an "Alternative F" instance
10:58:08 <sarahzrf> (note that the former is *not* "Monoid a => Monoid (F a)"
10:58:09 <Solonarv> yes
10:58:10 <sarahzrf> )
10:58:17 <sarahzrf> ?
10:58:24 <Solonarv> there are often multiple plausible Monoid (F a) instances
10:58:53 <Solonarv> the Alternative-based monoid is one possibility, but not the only one
10:59:08 <sphalerite> Cale: actually, looks like iterateM on my state is a much nicer option for my use case (since I'm using the vars in a forever currently)
10:59:20 <Solonarv> for example, if F is an Applicative you can have mempty = pure mempty; (<>) = liftA2 (<>)
10:59:36 <Solonarv> this is the Monoid instance for e.g. IO and functions
11:00:02 <Cale> sphalerite: You can also just write a recursive function
11:00:27 <Cale> sphalerite: loop x = do ... ; loop (f x)
11:01:01 <sphalerite> yeah, I prefer seeing my function as a step function and iterating that
11:03:41 <sphalerite> or rather, iterateM_
11:04:21 <sphalerite> ah, but that means dependencies
11:17:10 <jpg> I compiled lhs2TeX by myself from repo, still getting a lexical error
11:17:29 <jpg> reading  %format 'T = "blah" 
11:23:55 <izmar> Cale Cool talk, just watched it
11:23:55 <Cale> Great, now we don't just get join/part spam when the matrix thing disconnects and reconnects, we also get idle autokick spam from it.
11:24:34 <jgt> I configured my IRC to not show me any of those messages
11:24:43 <jgt> weechat smartfilter or something
11:26:45 <Solonarv> Cale: hey, at least that means those accounts won't be part of the dis/reconnect spam
11:34:14 <__monty__> So people won't be able to use matrix as a bnc anymore?
11:34:51 <__monty__> I think for many that was a large part of the attraction, no? Or is the history available in matrix rooms anyways?
11:35:49 <mceier> matrix - "lurkers are not welcome"; irc - "go ahead, test your isp stability" :)
11:42:40 <glguy> Cale: If they actually maintain the clean up it won't be as bad going forward
12:00:03 <fr33domlover> I have a really weird bug, where persistent's runSqlPool seems to cause 100% CPU and the actual SQL queries don't get executed
12:01:03 <jgt> fr33domlover: where could the bug possibly be? Could it be in the entity DSL?
12:08:35 <jgt> I would like to know more about this persistent issue so I don't run into the same thing
12:37:55 <fr33domlover> jgt, idk I don't hurry to assume a bug in persistent, it could be a bug in my code but I'm failing to find the cause :-/ I thought maybe runDB inside runDB but the monads prevent that; and I raised from 10 to 50 connections and it didn't help
12:38:21 <jgt> fr33domlover: is this in development? Or production?
12:38:33 <fr33domlover> Its like some specific code runs, and after that things go crazy :p
12:38:50 <jgt> fr33domlover: do you know _which_ specific code?
12:38:57 <jgt> maybe try tracing your program?
12:39:27 <jgt> I had a similar thing recently where I [rather stupidly] wrote an infinite loop while writing an instance
12:40:21 <fr33domlover> jgt, yes I know which code but idk *why* it causes that; yeah maybe an infinite loop that I haven't found yet :p
12:43:15 <jgt> fr33domlover: I'd be interested to see a minimal example
12:44:38 <parenthetical> jle`: I'm following http://conal.net/papers/push-pull-frp/, I'd like `result` to have the value 1 which I thought that would follow from the definition of `stepper` but it doesn't seem that way
12:50:46 <adius> Is there any way to make this work?
12:50:46 <adius> ```
12:50:46 <adius> a = (+1)
12:50:46 <adius> b = (+1)
12:50:46 <adius> a == b
12:50:47 <adius> ```
12:51:31 <boj> a 1 == b 1
12:52:24 <Solonarv> adius: not in general
12:53:15 <Solonarv> there is no way to inspect functions, so the only way to check that two functions are equal is to actually just feed every possible input to them
12:54:19 <Solonarv> you can use something like quickcheck to generate random inputs and test on those
12:54:34 <dmwit> adius: https://stackoverflow.com/q/17045941/791604
13:00:29 <adius> Thx, but my case is a little different, as it's literally the same code. Isn't there a pragma  / TH / C++ or something like this to compare the underlying representation?
13:01:27 <Solonarv> sure, you can use TH to grab the function definitions and compare them
13:01:30 <dmwit> No. However, IORef has an Eq instance which does not depend on its contained values being equal.
13:02:01 <Solonarv> also: CPP means C PreProcessor, not C Plus Plus
13:04:31 <dmwit> There is also https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Unique.html I suppose.
13:04:56 <Solonarv> dmwit: that doesn't quite seem relevant?
13:05:10 <Solonarv> adius: there is also https://hackage.haskell.org/package/inspection-testing which may be of interest
13:06:32 <Solonarv> adius: note that both template haskell and that library I linked let you syntactically compare the code, they do not look at the code's behavior at all
13:06:55 <dmwit> Solonarv: I'm imagining a similar use to IORef, but without the mutability of IORef.
13:07:06 <Solonarv> for example (\x -> x+(x+x)) and (\x -> (x+x)+x) would not be considered equal
13:07:28 <Solonarv> dmwit: well yes, but that doesn't seem to be what adius was asking about?
13:07:32 <dmwit> e.g. data IDd a = IDd { id :: Unique, val :: a }; newIDd :: a -> IO (IDd a); instance Eq (IDd a)
13:07:56 <Solonarv> AFAICT the question was "how can I compare functions?", not "how can I generate things which are equal only to themselves?"
13:08:08 * dmwit shrugs
13:08:20 <dmwit> Ask for the impossible, I will talk to you about nearby things that are possible.
13:08:37 <Solonarv> but my things are closer than your things! :P
13:09:13 <dmwit> =D
13:10:53 <dmwit> (oops, I forgot deref :: IDd a -> a)
13:12:40 <adius> inspection-testing seems to fit. Thx for the pointer 
13:14:38 <Unhammer> What do FUN_1_0 and THUNK_1_0 typically mean in -ht profiles like https://i.imgur.com/IVL3yXL.png 
13:14:39 <Unhammer> ?
13:15:44 <Unhammer> (trying to figure out why I'm getting 3x higher memory usage when upgrading from stack lts 6.35 to 13.7 â€“ I'm hoping I can avoid having to go bisect through every single lts and package to find the culprit :-S)
13:19:38 <phadej> Unhammer: that looks like https://github.com/snoyberg/conduit/issues/370
13:20:20 <phadej> and there FUN_1_ and THUNK_1_0 are NeedInput and HaveOutput fields
13:20:45 <phadej> (respectively, iirc, but it's irrelevant)
13:22:55 <phadej> https://www.well-typed.com/blog/2016/09/sharing-conduit/ might or might not help you figure out what is a culprit
13:30:45 <Unhammer> ooh
13:31:04 <Unhammer> wow, thanks phadej
13:38:21 <Unhammer> "Building â€¦ WITH profiling, makes the problem go away" â€“ same here (made it hard to find the culprit, happy someone else did!)
13:56:30 <___laika> exit
13:56:37 * ___laika facepalm
14:22:40 <jgt> does Yesod have some convenience for sending DELETE requests like Rails does?
14:23:31 <jgt> I know the router supports the DELETE method, but I'd like to send this request as a form submission with some special param
14:34:09 <lavalike> jgt: http forms only support post and get methods iirc
14:34:19 <lavalike> *html
14:34:57 <jgt> lavalike: yes, that is correct
14:35:19 <jgt> but some frameworks â€” including Yesod â€” provides workarounds for things like this
14:35:29 <lavalike> some custom js?
14:35:56 <jgt> for example, you can change the accept headers for a GET requesy by including the special _accept parameter in the query string
14:36:29 <jgt> this is completely non-standard, but it's a convience included with Yesod. I had hoped there would be some similar mechanism for interpreting POST requests as DELETE requests instead.
14:36:54 <lavalike> ah I see what you mean, dunno
14:37:17 <jgt> lavalike: JS is an option, though I _think_ that means I can't write an integrated test with yesod-test for that endpoint
14:37:51 <jgt> another option is to just use a POST request to an endpoint like /thing/#ThingId/delete
14:44:38 <lavalike> not a bad option
14:52:07 <buiweto> Prelude> [x:ys|x<-[1,2,3], ys<-[[]]] [[1],[2],[3]] => [[1],[2],[3]]
14:52:23 <buiweto> Prelude> [x:ys|x<-[1,2,3], ys<-[]] => []
14:52:30 <buiweto> How is that possible
14:52:45 <buiweto> 1:empty
14:52:50 <lavalike> 3*0=0
14:52:54 <buiweto> shouldn't really return anything
14:53:02 <buiweto> shouldn't work at all
14:53:49 <lavalike> buiweto: [] can have type [[a]]
14:54:51 <_ceb> Do you guys know graham hutton
14:55:00 <_ceb> He replied to my twitter dm :D
14:55:02 <buiweto> so, how the [a] inside [] can combine with 1
14:55:22 <buiweto> 1:[a] => 1:[] => [1]?
14:55:31 <buiweto> but it returns [] instead.
14:56:32 <Cale> buiweto: Don't get confused between types and terms
14:57:16 <buiweto> type is [a]
14:57:23 <Cale> Things on the right side of the :: are types, sometimes they look similar to terms, as in the type [a] looks like a singleton list, but note that it's the type of *all* lists having elements of type a
14:57:29 <Cale> even the empty list
14:57:35 <Cale> :t []
14:57:37 <lambdabot> [a]
14:58:00 <Cale> So, for example, [] can have type [Integer] when it needs to
14:58:09 <Cale> It can also have type [[Integer]]
14:58:19 <Cale> (by picking a = [Integer])
14:58:31 <lavalike> [ x:ys | x <- [1,2,3], ys <- []Â ]  desugars to  concatMap (\x -> concatMap (\ys -> [x:ys]) []) [1,2,3]
14:58:38 <lavalike> I forget the command to ask lambdabot to do that
14:58:54 <buiweto> :t concatMap
14:58:56 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
14:58:57 <lavalike> @undo [ x:ys | x <- [1,2,3], ys <- []Â ]
14:58:57 <lambdabot> concatMap (\ x -> concatMap (\ ys -> [x : ys]) ([] Â)) [1, 2, 3]
14:59:36 <Cale> That type for concatMap is perhaps needlessly confusing. You can think of it as  concatMap :: (a -> [b]) -> [a] -> [b]
14:59:37 <jgt> â€¦where did that circumflex come from?
15:00:13 <c_wraith> sometimes lambdabot has bugs
15:00:19 <Cale> I'm seeing it as a unicode replacement character
15:00:30 <lavalike> something borked in my input
15:00:37 <Cale> U+FFFD
15:00:38 <jgt> ah, it's not a circumflex; it's aâ€¦ caret?
15:00:45 <jgt> w/e
15:00:54 <Cale> It looks like a black diamond with a question mark inside it for me
15:01:06 <lavalike> capital a with a circumflex accent for me
15:01:14 <Cale> some sort of weird encoding failure
15:01:23 <jgt> "Blackjack!" â€” lambdabot, probably
15:01:24 <lavalike> @undo [ x:ys | x <- [1,2,3], ys <- [] ]
15:01:24 <lambdabot> concatMap (\ x -> concatMap (\ ys -> [x : ys]) []) [1, 2, 3]
15:01:35 <Phyx-> izmar: that error means you have a global version of libpthread on your PATH somewhere which is causing an ABI issue with the one GCC requires.
15:01:54 <Cale> Interesting!
15:02:19 <Phyx-> we try to cover up for this, but depending on which version of GCC you're more/less isolated from the problem.
15:02:48 <Cale> ah, you had a \160 in your first string
15:03:08 * jgt can't wait to get mega rich so I can pay people to write a better version of yesod-test
15:03:24 <Cale> (the space just before the final ])
15:03:33 <lavalike> sometimes I manage to get a weird nonprintables in there with some ctrl/alt combination
15:04:32 <buiweto> Maybe it's the list comprehension being somewhat disambiguous that it caused confusion
15:04:46 <buiweto> I mean ambiguous
15:05:33 <buiweto> Because the list comprehension unlike concatMap seems to suggest to do the impossible 1:empty
15:05:48 <buiweto> returning []
15:07:01 <buiweto> I kind of understand now. Thank you both lavalike and Cale
15:08:50 <buiweto> By the way, this question arose while I was reading "Thinking Functionally with Haskell" ch5 Sudoku solver
15:13:03 <Cale> buiweto: Ah, when there are no choices for ys, no elements of the resulting list will be generated
15:13:18 <Cale> buiweto: so you'll just get an empty list in that case
15:13:24 <Cale> buiweto: you can also consider something like:
15:13:53 <Cale> > [(x,y) | x <- [1..10], y <- if even x then [x,10*x] else []]
15:13:56 <lambdabot>  [(2,2),(2,20),(4,4),(4,40),(6,6),(6,60),(8,8),(8,80),(10,10),(10,100)]
15:14:32 <Cale> buiweto: note that we've effectively filtered out the odd choices of x, because there are no choices for y in those cases
15:15:16 <oats> list comprehensions are so cool
15:15:19 <buiweto> Cale: That clarifies a lot
15:15:29 <buiweto> Cale: Thank you 
15:15:34 <Cale> no problem
15:15:44 <oats> my mind was blown a bit when I found out it's syntactic sugar for list monad operations
15:20:54 <jle`> i wouldn't say that it "is" sugar for list monad operations, but you could say that there is an equivalent list monad operation for every list comprehension maybe
15:21:30 <jle`> in normal haskell it actually is not sugar, unless you enable an extension; but the extension is only used when you want to use comprehension syntax for non-list things
15:22:01 <Solonarv_> well, after inlining you probably(?) end up with the same code
15:25:39 <oats> interesting
15:25:59 <oats> jle`: are you talking about monad comprehensions?
15:26:19 <jle`> yes :)
15:26:26 <oats> those are neat :D
15:26:46 <jle`> monad comprehensions "generalize" list comprehensions by interpreting it as monadic operations
15:26:53 <MarcelineVQ> I used one for Maybe the other day, wasn't clearer but I felt more clever
15:27:11 <oats> ^ my haskell experience in a nutshell
15:27:48 <jle`> [ x | somePredicate ] is a common idiom
15:27:50 <slack1256Work> I feel cleven when using traverse_ on Maybe :-)
15:28:04 <jle`> that is Just x when somePredicate is true, and Nothing otherwise
15:28:05 <slack1256Work> I feel less clever when saying cleven though
15:28:12 <jle`> i think it's the cleanest way of writing it
15:28:42 <jle`> oh wait no
15:28:52 <jle`> for that i write `x <$ guard somePredicate`
15:29:07 <jle`> i guess they are both equally clean
15:29:21 <oats> hm, I still don't know what <$ does
15:29:25 <oats> I'll have to remedy that
15:30:07 <MarcelineVQ> for <$ it's all in the type
15:30:59 <oats> > :t (<$)
15:31:01 <lambdabot>  <hint>:1:1: error: parse error on input â€˜:â€™
15:31:01 <jle`> it's basically "replace all occurrences"
15:31:18 <jle`> > 5 <$ [1,2,3,4]
15:31:18 <oats> can lambdabot print the types of things?
15:31:20 <lambdabot>  [5,5,5,5]
15:31:23 <jle`> :t (<$)
15:31:24 <lambdabot> Functor f => a -> f b -> f a
15:31:28 <MarcelineVQ> yes but lambdabot isn't ghci
15:31:28 <oats> ah :D
15:31:33 <jle`> > 5 <$ Just True
15:31:35 <lambdabot>  Just 5
15:31:46 <Axman6> :t (<$) -- no > needed
15:31:47 <lambdabot> Functor f => a -> f b -> f a
15:31:47 <jle`> so `guard p` returns `Just ()` if p is True, and Nothing otherwise
15:32:18 <jle`> meaning 5 <$ guard p will be Just 5 if p is True, and Nothing otherwise
15:33:29 <oats> ah, so it's equivalent to `(const 5) <$> [1..4]`
15:33:42 <oats> > (const 5) <$> [1..4]
15:33:43 <jle`> right, x <$ y = const x <$> y :)
15:33:45 <lambdabot>  [5,5,5,5]
15:33:50 <jle`> that's actually the default definition i believe
15:34:14 <jle`> oh actually that is the actual definition
15:34:20 <jle`> i thought it was a part of the typeclass for some reason
15:34:26 <orzo> What's the most popular fatter alternative prelude?
15:34:26 <oats> man, toying around with haskell is one of the most fun things I've done in a really long time
15:34:28 <jle`> oh wait, it is a part of the typeclass.
15:34:39 <oats> I feel like I'm learning programming all over again
15:34:40 <jle`> yeah, it's the default definition :)
15:34:45 <MarcelineVQ> jle`: you've gone mad with power
15:34:54 <jle`> oats: that's a good attitude :)
15:36:57 <jgt> love it when Yesod/GHCi hangs on to postgres connections à² _à² 
15:37:04 <jgt> libpq: failed (FATAL:  sorry, too many clients already
17:02:18 <Axman6> oats: the best thoing is that feeling never ends, there's _always_ more to learn
17:02:23 <Axman6> thing*
17:05:22 <luciandesozay33[> https://www.breadandlife.org/
17:05:31 * luciandesozay33[ uploaded an image: images-6.jpg (3KB) < https://matrix.org/_matrix/media/v1/download/matrix.org/iTqZIwztnbMMaIMSCSAHbirR >
17:05:41 * luciandesozay33[ uploaded an image: images-5.jpg (6KB) < https://matrix.org/_matrix/media/v1/download/matrix.org/KWzpmSeFonOUFxIDwprQyJPD >
17:05:54 * luciandesozay33[ uploaded an image: images.jpg (7KB) < https://matrix.org/_matrix/media/v1/download/matrix.org/atFXEJmsXgYglROtrwNFntND >
17:06:06 * luciandesozay33[ uploaded an image: images-3.jpg (7KB) < https://matrix.org/_matrix/media/v1/download/matrix.org/uDFHQhUTkFuxXODrOdsiCELl >
17:06:12 <Axman6> @where ops
17:06:12 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
17:06:23 --- mode: ChanServ set +q *!*@gateway/shell/matrix.org/x-iqrsvoysdhigktle
17:09:37 <oats> that's some weird spam
17:11:09 <MarcelineVQ> idk why you'd need to advertise for bread and life anyway, everyone loves bread and life is shown to be preferred by the vast majority of people polled
17:11:13 <hpc> it's part of their grand plan
17:11:26 <hpc> soon spammers will be productive members of the channel, and the game will be over :P
17:11:29 --- mode: ChanServ set -q *!*@gateway/shell/matrix.org/x-iqrsvoysdhigktle
17:14:36 --- mode: ChanServ set +o Cale
17:14:40 --- mode: Cale set +b *!*@gateway/shell/matrix.org/x-iqrsvoysdhigktle
17:14:40 --- kick: luciandesozay33[ was kicked by Cale (luciandesozay33[)
17:14:43 --- mode: Cale set -o Cale
17:38:58 <libertyprime> hey guys. any way to use a 'ghci' command such as :Browse but rather than ending in interactive mode, simply print to stdout
17:40:33 <boj> echo :browse | ghci
17:40:54 <libertyprime> :) thanks
17:41:14 <geekosaur> or as a bashism: ghci -q0 ... <<< :browse
17:41:29 <geekosaur> (also zsh)
17:41:34 <libertyprime> im trying to make a fuzzy finder / help system for emacs similar to emac's describe-function. i wonder if this is the way to do it
17:41:41 <libertyprime> thanks guys
17:42:23 <geekosaur> sorry -v0 not -q0
17:42:29 <geekosaur> turns off the prompt and other noise
18:03:40 <MarcelineVQ> libertyprime: note that ghci can be used in an ide mode, can check out dante for how you might speak to it https://github.com/jyp/dante https://github.com/jyp/dante/blob/master/dante.el#L248 is an example of a ghci command being called from emacs
19:05:10 <metreo> Is there any reason cabal would fail spectacularly to install alex and happy?
19:05:28 <metreo> From a fresh ghc build on Linux?
19:08:24 <metreo> I was using Agda last week and everything was good today I got weird depends errors, ghc-pkg said my pacakges were broken so I attempted to reinstall but couldn't build the prerequisites. Is there something up with Haskell?
19:09:00 <maerwald> unless there was a recent release that breaks something, then no
19:09:06 <metreo> Ok thanks. 
19:10:07 <maerwald> a log would have been useful though :>
19:10:32 <pavonia> Too bad they didn't tell in what way it failed "spectacularly"
19:17:57 <jusss> hello
19:20:12 * ski stares expectantly at jusss
19:24:41 <jusss> ski: still not understood Reader Monad, :-(
19:25:34 <ski> it just hides passing along ("downwards") a "configuration" parameter
19:26:11 <jusss> return a = Reader $ \_ -> a,  this is weird, we return an anwser as an output of function
19:26:27 <ski> "an answer" ?
19:26:34 <ski> what do you mean ?
19:26:34 <jusss> an result
19:26:53 <ski> usually, functions result in computing an output
19:26:57 <jusss> a is an result of  \_-> a, but we already have the result
19:27:02 <jusss> no need for computation
19:27:05 <ski> "the result" being what ?
19:27:50 <jusss> being a paramter for another function
19:28:11 <ski> i don't know what you mean by "the result", when you said "we already have the result"
19:28:20 <ski> which is this "the result" that we already have ?
19:28:42 <jusss> return a,  a is we given, so we have knew it
19:28:45 <jusss> known
19:28:57 <jusss> \_ -> a,  a is no need for computation
19:28:59 <ski> can you repeat a haskell expression which expresses what you meant by "the result" there ?
19:29:07 <pavonia> `\_ -> a` basically says "we don't care what reader parameter is passed to us, because the result will always be `a`"
19:29:37 <ski> jusss : okay
19:29:41 <ski> yes, we already know `a'
19:29:43 <ski> so what ?
19:29:48 <ski> what's weird about that ?
19:30:02 <jusss> ski: no need for computation
19:30:07 <ski> i agree
19:30:12 <ski> i still don't see what's weird
19:30:33 <jusss> ski: it's just like a thunk
19:30:49 <ski> can you elaborate ?
19:31:26 <jusss> var f = function() { g()}
19:32:24 <ski> jusss : okay ?
19:32:38 <ski> jusss : if you want it, here's an exercise for you :
19:32:38 <jusss> ski: never mind, this is not related with this
19:32:46 <ski> define a tree type like
19:32:59 <ski>   data Tree a = Nil
19:33:11 <ski>               | Node a (Tree a) (Tree a)
19:33:25 <ski> now, define a function
19:33:39 <ski>   addToTree :: Num a => Tree a -> a -> Tree a
19:34:00 <ski> that adds its second argument to all the elements of the tree, giving back the corresponding new tree
19:34:24 <ski> jusss : do you understand ?
19:34:49 <jusss> ski: ok
19:35:02 <jusss> pass the a to all other stuff
19:35:20 <ski> adding it to all elements
19:35:28 <ski> do you think you can code up such a function ?
19:35:42 <ski> (this is related to your question about `Reader')
19:37:59 <jusss> addToTree Nil x = Nil
19:39:23 <jusss> addToTree (Node x Nil Nil) x = Nil
19:40:35 <ski> no
19:41:00 <ski> the shape of the returned tree should be the same as the shape of the input tree. so they should have the same number of elements, e.g.
19:41:33 <ski> `Node x Nil Nil' is a tree with one internal node, one element, but your output tree `Nil' is the empty tree (leaf tree), having no element
19:42:01 <ski> jusss : the solution may be simpler than what you're perhaps thinking of
19:52:11 <ski> jusss : if you wanted to wrote `addToList :: Num a => [a] -> a -> [a]', how would you write that ?
20:37:53 <jusss> ski: sorry, I don't get it
21:06:19 <slack1256> Has anyone run a haskell app on an iphone?
21:06:31 <slack1256> Any reference would be appreciated
21:10:02 <slack1256> Nevermind, found a wiki page
21:24:47 <Aditya> hi
21:46:04 <ski> jusss : did you get stuck writing one or the other of the two functions i suggeted ?
22:29:03 <diginet> I've never looked deeply into typeclasses heretofore (more of an ML guy) but what is the rationale for having to explicitly implement a typeclass as opposed to being more like C++ Concepts, where an concept is implemented if it is fulfilled, so to speak
22:30:27 <jgt> diginet: I generally don't know what I'm talking about, but a typeclass is just a map of functions, and the compiler needs to know what everything is at compile time
22:30:52 <jgt> also I've never written C++
22:31:06 <jgt> (except a function to convert from Celsius to Fahrenheit when I was 12)
22:32:13 <geekosaur> at the level of types, you're providing a witness to the type having an appropriate instance. in terms of ghc's implementation, that witness consists of a record of typeclass method implementations
22:35:19 <diginet> geekosaur: my guess is that this would interfere with type inference in uniquely awful ways (iirc type inference with typeclasses as they exist in Haskell isn't strictly decideable?) but what would be loss, conceptually, if instead a type t was a member of a class C iff the set of functions which compose C were all extant for t
22:35:28 <diginet> without any kind of explicit instantiation
22:36:45 <geekosaur> diginet, among other things, they can be polymorphically recursive
22:36:55 <geekosaur> consider Show instances that delegate to other Show instances
22:37:23 <diginet> oooooooh okay
22:38:16 <ski> diginet : cut off at end of ".. iff the set of functions which compose C were all extant for t"
22:38:48 <diginet> ski: oh, I say " <diginet> without any kind of explicit instantiation"
22:38:51 <diginet> *said
22:38:56 * ski perhaps wouldn't call that "recursive" .. at least not in the usual sense
22:39:31 <ski> diginet : yes, but what was the word starting with "t", after "were all extant for" ? and were there any more missing words after that ?
22:40:05 <diginet> oh sorry, I meant "t" as a meta-variable for type variables
22:40:12 <ski> oic :)
22:40:13 <diginet> referring back to where I said "a type t"
22:40:27 <diginet> if only IRC supported TeX
22:40:52 * ski was supposing a word like "the" or "that" or the like
22:41:04 <ski> diginet : one reason could be that the programmer (and the reader of docs/source) should be aware that a promise is being made of the operations/methods satisfying the laws of the type class
22:41:05 <jgt> -Werror turns all warnings into errors, but how do I upgrade a single warning to an error?
22:41:17 <MarcelineVQ> diginet: you can get plugins for some clients
22:41:18 <jgt> I'd like to always error on -Wincomplete-patterns
22:41:47 <ski> diginet : also, the only means of overloading in Haskell, is via type class methods
22:41:55 <MarcelineVQ> -Werror=incomplete-patterns
22:41:59 <diginet> ski: okay that makes sense
22:42:16 <jgt> MarcelineVQ: ty
22:42:45 <diginet> I'm asking in the context of a language that I'm designing. I figured that that was part of the rationale (that is, making typeclass membership always explicit)
22:42:59 <ski> diginet : an empty type class can still make sense to have instances for, if there are laws associated with the type class (regarding methods of superclasses)
22:43:22 <diginet> right yeah
22:44:08 <ski> diginet : still, note that we can have orphan instances. an instance doesn't need to be declared either in the module defining the type class, or the module defining (one of) the type(s). this is both a good and a bad thing
22:44:14 <jusss> ski: I stuck in the data type, sorry to being reply late, I had some work to do
22:44:21 <ski> jusss : no worry
22:45:09 <diginet> ski: so wait, are you saying that a type *can* be a member of a class, call it, "anonymously"?
22:47:24 <ski> diginet : no. i'm saying that the instance can be declared in a third party module/library/package
22:47:28 <dminuoso> ski: Do you consider polymorphic types, such as  âŒœâˆ€ (Î± : K). B(Î±)âŒ, themselves being objects in Hask?
22:48:01 <diginet> ski: oh, i see yeah, sorry misread the original message
22:49:14 <ski> dminuoso : i do not call those polymorphic types. that's a `forall'-type, or a universal type. sometimes types like that are called "(type) schemas". they are certainly types in the sense of having a kind. but there are restrictions on where you can place them
22:50:47 <dminuoso> ski: The reason I ask, is because you can clearly have values of that type. I mean I can simply write: `x = 0; x :: forall x. Num x => x` - so after some pondering that felt a bit uncomfortable.
22:51:04 <ski> dminuoso : e.g. `[forall a. T a]' requires `ImpredicativeTypes', which is not fully supported/implemented. also `(forall a. T a) -> ...' requires `Rank2Types' (or `RankNTypes' in general, if you nest more to the left of a `->'). and `data Blah = MkBlah (forall a. T a)' requires `PolymorphicComponents' (which nowadays is just a synonym for `Rank2Types'/`RankNTypes', iirc)
22:51:52 <dminuoso> ski: I tend to pretend that at least RankNTypes is enabled by default. It feels like such a natural feature.
22:52:16 <ski> dminuoso : yes, the kind of `forall a. T a' here would be `*', so that that type (scheme) is a concrete type
22:53:18 <dminuoso> % type F = (forall a. Maybe a :: *)
22:53:18 <yahb> dminuoso: ; <interactive>:203:32: error:; Operator applied to too few arguments: *; With NoStarIsType (implied by TypeOperators), `*' is treated as a regular type operator. ; Did you mean to use `Type' from Data.Kind instead?
22:53:36 <ski> % type F = forall a. Maybe a
22:53:36 <yahb> ski: 
22:53:40 <ski> % :k F
22:53:40 <yahb> ski: F :: Type
22:53:53 <dminuoso> That's motivating.
22:54:02 <ski> % :k forall a. Maybe a
22:54:02 <yahb> ski: forall a. Maybe a :: Type
22:54:03 <ski> of course
22:54:16 <ski> @kind forall a. Maybe a
22:54:18 <lambdabot> *
22:55:31 <ski> dminuoso : a polymorphic type, would be something like `Const', defined by `newtype Const c a = MkConst c'. `Const' has kind `forall k. * -> k -> *' (if you enable `PolyKinds', which i consider to be a misnomer)
22:56:09 <dminuoso> ski: Yup, that seems justified now.
22:56:21 <dminuoso> Equivalently we might have polymorphic kinds if we had other sorts than Box.
22:57:28 <ski> i know it's quite common to call `forall'-types, "polymorphic types" (or "poly-types"), but i think it's misleading, if we want to call things like `Nothing',`replicate 3 []',`length' polymorhic values
22:58:30 <ski> (i could possibly accept "poly-types", with the understanding that it means "types of polymorphic values")
22:59:01 <ski> (compare with how "function types" means "types of functions", and "tuple types" means "types of tuples", &c.)
22:59:32 <ski> (however, we can say "a function", and "a tuple", but it sounds weird (?) to say "a polymorphic")
23:00:07 <ski> (and saying "polymorphic value" all the time is a bit long-winded ..)
23:00:58 <ski> dminuoso : "Equivalently ..." -- yes
23:01:08 <ski> (but see `TypeInType')
23:01:13 <dminuoso> Right.
23:04:18 <dminuoso> ski: Semantically, what's the difference between "universal types" as we have in Haskell and pi types then? Couldn't one consider the Haskell universal types as pi types limited to values of singleton types?
23:04:49 <dminuoso> Or is this the connection why we can mimic dependent typing using singleton types in Haskell?
23:13:26 <ski> dminuoso : what do you mean by "pi types limited to values of singleton types" ?
23:34:59 <dminuoso> ski: Let me sink back into my head and think about this.
23:51:53 <zincy_> Does anyone know why this vector is adding one to the index when it shouldn't be modifying it at all.
23:51:54 <zincy_> https://repl.it/repls/BlissfulEminentConfiguration
23:52:15 <zincy_>  Couldn't match type â€˜'Zâ€™ with â€˜'Succ 'Zâ€™
23:52:15 <zincy_>       Expected type: Vector Card ('Succ 'Z)
23:52:15 <zincy_>         Actual type: Vector Card 'Z
