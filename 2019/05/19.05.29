00:03:27 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
00:03:27 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
00:03:27 --- names: list (clog JonHanDin cfarem fphilipe encod3 rruizt pqzx lprd donotturnoff revprez thc202 kapilp halogenandtoast Miroboru_ mkoenig_ ShalokShalom bahamas Cloud[m] Spanktar dycan yoneda osa1 nyaomi Sgeo__ barrenbass fmixing jamm libertyprime takuan DTZUZU2 harblcat jneira honungsburk nshepperd Arcaelyx WeiTang[m] ShujaRafi[m] thecodedmessage wengrow[m] soaoaig[m] avocado runningriot9[m] rainbyte[m] ovigren[m] nirvin[m] MichalLaskus[m] iarp[m] vladimirp1[m] GNULizard[m])
00:03:27 --- names: list (cr0gs Warder[m] vars[m] actartis[m] thejonny[m] haiderkhan[m] reedhhw[m] hkimhvyh[m] Obscurity[m] jennie[m] kahuna[m] fregex JakeO[m] illandan[m] int-index AkikoHimenokoji[ cjskaggs[m] deklund[m] eckt[m] hackeryarn[m] petrichor ad5twoknebor[m] mithrandi[m] pineapple[m] buggeas40d[m] cepxuo roberth MerlinGttlinger[ m1andrew[m] hans[m]4 limabeans[m] supersweetsweetc jhg_0[m] hjoest[m] godva[m] jerrytgarcia[m] jenkee[m] joenase[m] luciandesozay[m] tmallard[m])
00:03:27 --- names: list (cawal[m] risorg[m] aitzol[m] dag[m] ciet[m] tswett[m] shanesveller[m] Videled[m] Mesa[m]1 Syllo[m] buster528[m] unevens[m] tinwood[m] Adam[m]7 kai10[m] zocijux[m] bt[m] javjarfer[m] hsw[m] Mougan[m] GhostofaConsole[ dlilja[m] exarkun1 NickHu bdesham[m] atgo[m] alicedebob[m] bobach[m] cbg[m] dxml[m] foxadee[m] capillary_cup[m] fiddeldibu[m] cosson[m] dahuoji[m] etjet[m] Cenion[m] Noughtmare[m] Bimmie[m] bb010g alexshpilkin tet[m] codesoup fweht potato44[m])
00:03:27 --- names: list (sielicki whoops sylvie[m] marijuanafermion siraben roninkaizen[m] hgfedcba[m] vaibhavsagar spherinder[m] Rich[m] simbergm maigel[m] nkhodyunya[m] mmynsted[m] kadoban jibby[m] stan[m] Uma[m] macerbi[m] ejpcmac josiah_sama sepp2k kitsune[m]1 vkleen vk3wtf[m] rizary giuseppe[m] hdurer[m] kaychaks[m] lierdakil[m] humanwire[m] bee[m]1 alexfmpe[m] mujx[m] M0x8badf00d[m] atopuzov[m] domenkozar[m] arsdragonfly[m] Guest7629 yahb mniip _vaibhavingale_ Ekho[m])
00:03:27 --- names: list (aloiscochard[m] irdr forgottenone olligobber piyush-kurur arahael1 srnty Zer000 notzmv toppler`` niHiggim_ vlatkoB zaquest nbloomf otto_s_ tabemann [Leary] pankajgodbole fryguybo1 lagothrix yaroot2 theDon sword865 xorander nighty wei2912 ym555_ khisanth_ seizo cybai jluttine jusss pfurla_ polman eiGHttt polmaan YongJoon hexfive StoneToad DrAwesomeClaws aarvar ziyourenxiang plutoniix gspia dibblego Jesin joehh ericsagnes keep_learning_M ClaudiusMaximus)
00:03:27 --- names: list (Lord_of_Life eschnett alx741 winfield d34df00d saml cybj nesqi ffl^ Jahangir Unhammer anishathalye lnostdal jb55 rembo10 tabaqui sdrodge ziman ricekrispie megaTherion Putonlalla leah2 tsaka__ wonko7 Kaivo moldybits srid63908 taiite slomo lpvb danso jchia_1 mulk jgt hololeap nullifidian acarrico _ashbreeze_ juri_ byorgey Cale Remy^ MonkeyNOS Anthaas m1dnight_ RedNifre seanparsons catsup ashirase bennofs Fairy tjbp poljar1 sea-gull_ mnrmnaugh jackdk powerbit)
00:03:27 --- names: list (revprez_atlanta Fubar^ rainmanjam xelxebar recurse bengt_ thunderrd miklcct albel727 oni-on-ion tomku newhoggy kipras dedgrant Guest8430 eruditass datajerk kyagrd__ dani- ocharles Wizek milessabin meck sebhoss peschkaj monad_cat ghuntley graingert Kamuela m-renaud glowcoil rslima_ J_Arcane metalrain typetetris Lowl3v3l Vq moony t7 stilgart Folkol revprez_anzio Mike2_ zmt00 PLPD-Bot gienah_ swater andreas303 nckx mjuad Guillaum henriksod seveg gehmehgeh immae)
00:03:27 --- names: list (Natch yitz cyphase phadej ion xpoqp oldnborg cow-orker totte raatiniemi jonatan golergka_ pigsalsa ahihi gentauro DTZUZU rom1504 hvr pong Stanley00 xplat phaul Chobbes chirpsalot optmzr survove bydo atk phreedom korzq atraii tnks oo_miguel_win SCHAPiE delYsid`` shutdown_-h_now Tuplanolla armyriad unyu alyptik defanor lstdgtfp dolio MatrixBot3 erikd justanotheruser jle` mimi_vx s00pcan a3Dman nek0 nopf theorbtwo dsal theophil893 wrunt zargoertzel max1 jsatk)
00:03:27 --- names: list (roman1 noam__ eof verlet64 haasn PlasmaStar Novitsh bandali urdh elvishjerricco aesi jchia Offaiah_ azahi OnkelTem _janne earldouglas revprez_ody ibloom dustinm Majiir bontaq spion ido kwantam wildlander klntsky caa51h niklasl lawid bartavelle jeff___ Cthalupa Xal MindlessDrone mjrosenb SquidDev Madars Rudd0 koz_ kubrat cppxor2arr duckonomy valdyn telser Maxdamantus oleks hsyl20 perrier-jouet amiri leothrix nh2 isacl___ spinda dgpratt alexelcu runeks teehemkay)
00:03:27 --- names: list (adamse mmaruseacph2 cbarrett lightandlight simony sariyar rotaerk fcse__ sppky kip hsiktas lockshaw_ billstclair ixian abuss rodlogic feepo mankyKitty duncan^ celphi georgew caasih ajmcmiddlin dongcarl gonz_ iphy pent EduardoBautista coot alunduil PotatoGim tehidiot bs338 NemesisD jetpack_joe JSharp nickoralias pasukon Jon coeus_ cpup dysfigured clever bsima dminuoso gxt jbetz Axman6 shadowdao bollu cross nonzen drbean veverak quaestor hackage vk3wtf)
00:03:27 --- names: list (markus1189 glguy hive-mind Sparadox nfd9001 n-st corvidzz petermw milli Zoddo steve nikivi pie__ Mo0O energizer_ Sose Bergle_2 AkhILman Netwolf yushyin acro TommyC dmwit hpc M2tias i7c le_jonge tomboy64 mickdekkers__ __4matter_ stylewarning runde parseval edmundnoble mudri carter thi cyjiao__ unsymbol scav johs travv0 drewr micro Dabo dTal mou stux|RC-- hc Zialus nicoulaj cpape jzl tessier eikke so jvanbure michalisko @ChanServ klugez furnost Clint cyberlard)
00:03:27 --- names: list (adamCS ruffy_ joeytwiddle sbrg stefan-_ tolt Forkk liff cjay- kloeri abra0 riatre wraithm ryjm[payon] lugh brisbin iron_houzi rinfiyks davean mrus DwarfMaster idupree jfredett markhuge jdanforth ezyang jinblack solarus Someguy123 raid xnyhps Jaxan mstruebing djanatyn anderson asm89 d6e ambrosia _6a68 lavalike PyroLagus tureba RecursiveG avp Kneiva ftop lowryder ldlework dyl sssilver Franciman Annihitek SolarAquarion ventonegro makergrl dexterfoo zenzike steell)
00:03:27 --- names: list (lispy pharaun fiatjaf HalfEatenPie cesardv gilbertw1 duairc wz1000 Xandaros eagleflo ubercow adarshaj Flonk comstar w1gz d3lxa crooked implementation_ EvanR aplainzetakind Jacoby6000 maerwald nisstyre Firedancer_ Chousuke integral Liskni_si ego Willis jorj dh sarahzrf luigy geal eldritch LeaChim sm rootmos_ e jokester koala_man _ceb rodgzilla SlashLife barrucadu jonrh fredcy_ adius kosmikus tchakka debugloop paraseba lieven Deewiant _flow_ dqd niklasb_ atomi)
00:03:27 --- names: list (sivs fiddlerwoaroof akermu betawaffle adarqui puffnfresh dequbed rkrishnan h30 exio4 agrif habbah vin-ivar nibbling_ mulderr ycheng carbolymer coldpress Aleksejs qzo_ twk- shachaf [df] sms zymurgy bs fiQ2 lurkless nshepperd_ beaky Arguggi canta Mon_Ouie flebron moocow Guest40074 exferenceBot quarters pacak tabaqui1 joehillen Kiruwa rj1 ekleog burp Reisen platz lexi-lambda joel135 luite Ornedan dilinger nvt shapr c_wraith ephemeron Squarism qz greeny__ pigs)
00:03:27 --- names: list (owlscientist lachenmayer tigerchops aidecoe ahri deu Unode reyu jp treehaqr strangeglyph gargawel mpickering tstat tristanC lortabac vqrs ski Ulrar tsahyt vanyaklimenko beka PtxDK shrifbot AfC geekosaur ynyounuo NextHendrix sebastianrkg connrs- Ring0` deni rootnode_ hexagoxel dumptruckman gambpang t36s mtjmullen hiredman CelestialLake Akii bjs seventh__ saidinwot boj bitemyap1 earthy Nikotiini aib rzmt blackdog Wojciech_K edwtjo ammar2 _ag_ loc vodkaInf1rno)
00:03:27 --- names: list (davl cgoldamm1r Logio ent saurik_ chivay jix andromeda-galaxy irclogger_com jdt alanz wtw polux7 amatecha alexknvl gluegadget srhb raoulb lc_ Eliel scivola Jabbslad banjiewen nbouscal fingerzam cemerick zabracks bradparker ebutleriv systemfault jophish glowpelt SegFaultAX xtsee dpn` lkurusa DustyDingo sphalerite amx dionyziz TimWolla Nascha ljhms ByronJohnson Randy WarzoneCommand Jonno_FTW pdxleif connrs_ PHO scal int-e Philonous typedrat mikolaj Nevoic [exa])
00:03:27 --- names: list (mrd casdr Neuromancer acowley ryzokuken ranberry__ AndreasK heyj Konehalt1 SrPx ProofTechnique nemesit|znc Blkt pierrot flux silverneedle geronimogarcia PoliticsII joeyh higherorder hodapp Enigmagic flogfr benl23 Hotbees hexo intelux abbe ullbeking jmsx bananagram Peter_Storm_ ecx86 verite- Rembane nano- catern obfusk mingc TheSpectre GGMethos devalot Firedancer spamlessj amuck wreckingwalla_ iltiades1 PierreM_ mceier l8star Ckat drewbarbs hegge bind _ikke_)
00:03:27 --- names: list (Nik05 kav Twey tdammers sigmundv_ xacktm icrainbow ft aramiscd Athas xorpse sqrt2 pwestling soncodi gsingh93 zfnmxt michalrus epta interruptinuse raoul sdx23 fr33domlover lukelau mort `slikts bspar jtcs_ Zemyla simon nekomune Tspoon__ diskie chindy kaol c-rog noexcept jwynn6 noko_ yorick zxrf cyris212 pdgwien Deadhand enragedjam dstolfa_ comboy_ bertschneider_ remexre thoughtpolice terrorjack_ linoge rotty1 dredozubov cloudhead MarcelineVQ Hijiri vxe violeta)
00:03:27 --- names: list (Peppep vimto aldum gaze___ bobby Tene thallada dontdieych michaelsdunn1_ CindyLinz wayne_ Bish shreyasminocha MasseR echoreply aweinstock mccoyc wrengr_away charukiewicz cchalmers runawayfive cods kungp oats arianvp greymalkin Taneb Moyst iravid Tritlo d0liver absence rdivyanshu dukedave kini dmj` stass cheers mupf linduxed sukbeom9 cjwelborn giraffe Miroboru mikolaj_ @Sigyn Tourist haveo dfordivam Frans-Willem Phyx- Geekingfrog Velpoman uptime feuerbach)
00:03:27 --- names: list (teardown bjobjo lambdabot nurupo noctux stiell AJTJ arkeet codedmart Klumben parenthetical johnw cocreature uwap S007 sujeet jackhill monochrom sudden grumble tms_ trebuh matheus xstill otulp Igloo fionnan FliiFe dan64 crtschin tinwood teej stk andyo ab9rf aveltras mp___664 nitrix wagle Dykam bolverkr a3f Niamkik asjo bwe yrid devurandom keep_learning RoguePointer swalladge lassulus NightA usern4m3 dogui nyuszika7h bgamari avn_ avn dashkal devopsdeluxe scinawa)
00:03:27 --- names: list (oberstein noCheese troydm drdo TMA nahra darxun yumh rcdilorenzo Profpatsch koankeeper moobar alextes affinespaces mitchellsalad_ underikar rann bitonic dcoutts_ Foritus jkachmar RusAlex Wamanuz2 PragCypher obiwahn jrslepak cheater bod_ sis7 winny seliopou infinisil m4lvin lpsmith edwardk kAworu bcoppens chin-tastic Adluc srk verement mikeplus64 phlym_ Shockk forell_ spoonm diginet ManiacTwister madnight Tristan- tA_ marble_visions_ nilOps_ xintron1)
00:03:27 --- names: list (petercommand statusfailed jlamothe apeyroux_ tumdedum anry_ henrik__ tmciver opqdonut ayako orzo_ exarkun hongminhee Ekho sud0 jrm lantti raek_ Adeon thaumavorio_ gothos Jello_Raptor infinity0_ kiprasz evilmonads_ _guios Cathy jdevlieghere daGrevis Amadiro restrictedchoice cgfbee suzu Ranhir APic apoc freusque kqr lyxia myme andjjj23 tv lemald iomonad tobiasBora esph michaelpj monokrome niko bdw Ke)
00:09:16 <dminuoso> So while its ill-kinded to write `instance Functor Num` or `instance Num Maybe`, it'd be valid to write both `instance Typeable Num` and `instance Typeable Maybe`.
00:09:58 <dminuoso> Or `instance Functor Int` rather, and `instance Typeable Int`. :o)
00:13:11 <jusss> monoid's mempty and mappend have to do with monad's identity law and associativity law?
00:13:57 <Cale> uhhh... in the case of the Writer monad that's true
00:15:17 <jusss> Cale: if I want turn a type T to Monad, can I just make T be the instance of Functor, Applicative and Monad?  does T need to be instance of Monoid?
00:15:42 <Cale> It wouldn't even make sense for T to be an instance of Monoid in that case
00:15:45 <Cale> It's not the right kind
00:16:01 <Cale> :k Monoid
00:16:03 <lambdabot> * -> Constraint
00:16:03 <jusss> Cale: but Monad is a Monoid
00:16:07 <Cale> :k Monad
00:16:09 <lambdabot> (* -> *) -> Constraint
00:16:16 <Cale> hm?
00:16:33 <jusss> not right?
00:16:38 <Cale> Monoid is for monoid objects in the category of sets (or Haskell types)
00:16:44 <jusss> that famous joke!
00:16:58 <Cale> Monads are monoid objects in the category of endofunctors on some category
00:17:24 <Cale> (in this case, the endofunctors on the category of Haskell types)
00:17:51 <Cale> I can sketch the connection a little if you want
00:17:57 <jusss> please
00:18:53 <Cale> So recall that a monoid is a set M with some unit element e in M, which, since we have our category theory hats on, we can regard as a function 1 -> M, where 1 is some one element set
00:19:08 <Cale> and a multiplication M x M -> M
00:19:12 <jusss> Cale: wait a sec, is Maybe a Monoid instance?
00:19:15 <Cale> where x is Cartesian product
00:19:25 <Cale> not directly
00:19:43 <bahamas> dminuoso: ok, that makes sense. so `k` is a kind variable, if I can call it that
00:20:01 <bahamas> dminuoso: does `k` have special meaning or can you use a different letter?
00:20:15 <Cale> jusss: However, there is an instance Semigroup a => Monoid (Maybe a)
00:20:35 <Cale> So while there's no instance Monoid Maybe (nor does that kind-check)
00:20:45 <Cale> there is an instance Monoid (Maybe a), whenever there's an instance Semigroup a
00:21:11 <Cale> bahamas: You can use any letter
00:21:25 <Cale> bahamas: or any identifier starting with a lowercase letter
00:22:08 <jusss> Cale: actually I wonder what's the shape of monoid in haskell, like 1 + 0,  1 * 3,  id . f
00:22:18 <jusss> what's the monid?
00:22:23 <Cale> hm?
00:22:35 <bahamas> Cale: aha, so it's like a variable. thanks!
00:23:06 <bahamas> I guess you could use `anyKind` to make it more explicit
00:23:06 <jusss> [] is monad in something, e-> is mond in something, what's the monoid like?
00:23:13 <Cale> huh?
00:23:22 <Cale> Monads and monoids are only very abstractly similar
00:23:48 <Cale> There won't be a monoid corresponding to any given monad
00:24:13 <Cale> Well, I could come up with several, but there isn't a canonical choice of one :)
00:24:30 <Cale> (Monoids are very easy to come up with)
00:25:02 <jusss> come up with what form or shape?
00:25:38 <Cale> For example, if M is a monad, we could turn M () into a monoid, where mappend is (>>) and mempty is return ()
00:26:24 <Cale> Also, for any type t, we could turn functions a -> M a into a monoid, where mappend is (<=<) and mempty is return
00:26:32 <Cale> er, for any type a
00:26:44 <Cale> (I was going to use t, and then I didn't ;)
00:27:31 <jusss> still don't get it
00:27:49 <Cale> Also, for any monad M, we can define an instance Monoid a => Monoid (M a) where mempty = return mempty; mappend = liftM2 mappend
00:28:06 <Cale> There are a lot of monoids
00:28:43 <Cale> jusss: I might not be understanding what you're trying to get
00:30:08 <jusss> Cale: what it's like? now I can get Functor, Applicative and Monad, like we can implement fmap, apply and bind also return to turn the type be an instance of those three typeclass, but Monoid is like that? 
00:30:20 <jusss> sorry, my English is not good
00:30:33 <Cale> For Monoid, you define mempty and mappend
00:30:53 <Cale> A simple monoid instance is the one for lists:
00:30:57 <jusss> Cale: yeah, and how those two functions work?
00:30:59 <Cale> instance Monoid [a] where
00:31:01 <Cale>   mempty = []
00:31:04 <Cale>   mappend = (++)
00:31:44 <Cale> instance Num t => Monoid (Sum t) where -- the Sum type here is a newtype wrapper
00:31:48 <Cale>   mempty = Sum 0
00:31:55 <jusss> Cale: yeah, [] is instance of List Monad, but Maybe Monad hasn't instance right?
00:31:56 <Cale>   mappend (Sum x) (Sum y) = Sum (x + y)
00:32:07 <Cale> The Monad is irrelevant here
00:32:15 <Cale> We didn't use return or (>>=) or anything based on Monad
00:32:22 <Cale> We only used [] and (++)
00:32:45 <jusss> Cale: what about Maybe
00:32:56 <jgt> is this clearer when eta-reduced? hcUsers = (\info -> (historyChatUser $ getCountry info) info) <$> usrs
00:33:08 <jgt> after reduction: hcUsers = (historyChatUser =<< getCountry) <$> usrs
00:33:11 <Cale> and it's a monoid because for any list xs, we have [] ++ xs = xs and xs ++ [] = xs, and for any lists xs, ys, zs, we have xs ++ (ys ++ zs) = (xs ++ ys) ++ zs
00:33:29 <bahamas> jusss: Monad and Monoid are `type classes`. `List` and `Maybe a` are `types`, in case the distinction is not clear
00:34:02 <Cale> jusss: I never got through explaining the connection between Monoid and Monad, it's *very* abstract
00:34:13 <Cale> Do you happen to know what a natural transformation is?
00:34:35 <jgt> Cale: is that helpful to a beginner?
00:34:43 <jusss> Cale: bahamas if we turn Maybe as an instance of Monoid, how we impelemnt the mempty and mappend?
00:34:49 <Cale> jgt: Not especially, but jusss specifically requested that I explain it
00:34:53 <jgt> Cale: surely it's enough for a beginner's purposes to let them know how to use them
00:34:56 <jgt> ah ok, fair enough
00:35:20 <Cale> jgt: and I think jusss is overthinking the importance of it -- perhaps understanding it a bit will let them decide it's not worth much in actual programs :)
00:36:14 <Cale> jusss: We can use a Semigroup instance for a to obtain an instance of Monoid for Maybe a
00:36:14 <jusss> Cale: I don't know about natural transformation yet, I heard that name before :)
00:36:29 <Cale> instance Semigroup a => Monoid (Maybe a) where
00:36:33 <Cale>   mempty = Nothing
00:36:48 <Cale>   mappend Nothing y = y
00:36:55 <Cale>   mappend x Nothing = x
00:37:06 <Cale>   mappend (Just x) (Just y) = Just (x <> y)
00:37:22 <Cale> Where now <> is the Semigroup operation
00:37:43 <Cale> This is a way of adding an identity element to any semigroup
00:39:00 <bahamas> jusss: are you trying to understand how monoids work or something else?
00:39:08 <Cale> jusss: So, natural transformations are the arrows in the category that monads are monoid-objects in. For now, you can think of a natural transformation f -> g as being a polymorphic function of type  forall a. f a -> g a
00:40:02 <jusss> bahamas: I'm trying to know how to turn a type as an instance of monoid
00:40:42 <Cale> jusss: A monad consists of some endofunctor M: C -> C, and then a couple of natural transformations: return: 1 -> M, and join: M . M -> M. Here, 1 is the identity functor, and the '.' is composition of functors
00:40:58 <Cale> This abstractly looks like our picture for monoids that I gave before
00:41:39 <Cale> But since in one case, we were dealing with pairs of elements of a set, and combining them, and now we're taking things of type M (M a), and producing things of type M a
00:42:08 <Cale> well, it's not *quite* the same thing as soon as you look at the details
00:42:26 <bahamas> jusss: you need to implement the two methods required by Monoid: mempty and mappend. that means that your type needs to have a meaningful mempty value. like 0 is in the case of addition, [] for the list type, Nothing for the Maybe a type
00:42:31 <Cale> It's like, if you can blur your eyes enough, these become exactly the same thing, and they even have the same laws.
00:42:43 <Cale> But as soon as you unblur them, they're completely different concepts.
00:44:16 <jusss> bahamas: Cale and those mempty and mappend are linked with identity law and associativity law ? 
00:44:26 <Cale> jusss: mempty <-> return
00:44:30 <Cale> mappend <-> join
00:45:11 <Cale> The identity law and associativity law can be made to look the same for monads and monoids, if you write them in a particular funny way
00:45:28 <bahamas> jusss: mempty is the identity element
00:45:44 <bahamas> jusss: like 0 is for addition and 1 for multiplication
00:45:48 <Cale> If we go back to our picture of monoids where we had some function e: 1 -> M picking out the identity element
00:45:53 <Cale> and m: M x M -> M
00:46:00 <Cale> the multiplication
00:46:44 <Cale> then we could write the unit laws in a particular way... I fear the notation won't make any sense, because I haven't introduced much of it
00:47:20 * hackage tree-diff 0.1 - Diffing of (expression) trees.  https://hackage.haskell.org/package/tree-diff-0.1 (phadej)
00:47:33 <Cale> actually, I'd also have to introduce the left and right unitors and the associator...
00:47:35 <Cale> hah
00:47:51 <Cale> https://en.wikipedia.org/wiki/Monoid_(category_theory) -- maybe just look here for a moment
00:48:24 <Cale> In one case, we can replace the tensor product symbols (x) with Cartesian product
00:48:33 <Cale> and interpret I as some one-element set
00:49:07 <Cale> and then alpha is a function which reassociates tuples alpha ((x,y),z) = (x,(y,z))
00:49:13 <jusss> Cale: wait a sec, "mempty = Nothing"  this mempty is a function without arguments?
00:49:36 <jusss> every function is an unary function
00:50:01 <Cale> jusss: It's not even a function as it's expressed in Haskell. In the stuff I'm talking about, we're taking it to be a function from a one-element set, but usually it makes more sense just to think of it as an element of the monoid.
00:50:02 <Axman6> it's just a value
00:50:08 <Axman6> @src Monoid
00:50:08 <lambdabot> class Monoid a where
00:50:08 <lambdabot>     mempty  :: a
00:50:08 <lambdabot>     mappend :: a -> a -> a
00:50:08 <lambdabot>     mconcat :: [a] -> a
00:51:36 <Cale> jusss: anyway, I think it's probably best to ignore the connection between Monad and Monoid, since it's really abstract, and even once you understand it, it won't do much for you unless you're interested in many other areas of mathematics -- in which case, it leads to asking about what the monoid objects of other categories might look like.
00:51:55 <jusss> Cale: ok
00:52:02 <Cale> For programming in Haskell, the connection isn't useful in any way
00:52:25 <Cale> (at least, in any way that we've managed)
00:52:53 <jusss> Cale: so It doesn't need to be a monoid befor a monad, right?
00:53:04 * Axman6 huffs in Kmett
00:53:20 <Cale> yeah, these concepts don't even really discuss the same *kind* of things
00:53:31 <Cale> jusss: A monoid has to be a type of kind *
00:53:38 <Cale> A monad has to be a type of kind * -> *
00:53:41 * edwardk looks up then looks back down at a ton of low level font code
00:54:02 <Cale> edwardk: Doing the shader font rendering shenanigans?
00:54:09 <edwardk> Cale: yeah
00:54:20 <edwardk> right now binding to all the things to get nice formatting
00:54:43 <jusss> Cale: forgive me, I forget how the (m a) is with * -> *
00:54:51 <edwardk> doesn't matter how pretty the letters are if the glyphs are all in the wrong place
00:54:58 <jusss> I remember that Either a is a mond, not Either
00:55:19 <Cale> jusss: that's right
00:55:29 <jusss> Maybe is a mond , Maybe a isn't
00:55:39 <Cale> jusss: yep
00:55:55 <jusss> and with the kind type *-> *  ,  I forget the connection
00:56:02 <Cale> :k Maybe
00:56:04 <lambdabot> * -> *
00:56:07 <Cale> :k Maybe Int
00:56:09 <lambdabot> *
00:56:15 <Cale> :k Either
00:56:17 <lambdabot> * -> * -> *
00:56:19 <Cale> :k Either String
00:56:20 <lambdabot> * -> *
00:56:22 <Cale> :k Either String Int
00:56:25 <lambdabot> *
00:56:39 <Cale> Monads M are always things of kind * -> *
00:56:42 <Cale> so that the types
00:56:46 <Cale> return :: a -> M a
00:56:47 <Cale> and
00:56:47 <jusss> ok, Maybe a is *,  Maybe a is a monoid
00:56:51 * hackage swagger2 2.4 - Swagger 2.0 data model  https://hackage.haskell.org/package/swagger2-2.4 (phadej)
00:56:53 <Cale> (>>=) :: M a -> (a -> M b) -> M b
00:56:55 <Cale> will make sense
00:57:04 <jusss> Maybe is *->* ,   Maybe is a monad
00:57:08 <Cale> jusss: Maybe a *could be* a monoid
00:57:10 <Axman6> edwardk: pfft, details, as long as it's fast!
00:57:37 <Cale> jusss: Given a type of kind *, it might have a Monoid instance or might not
00:57:39 <jusss> Cale: until we implement mempty and mappend, right?
00:57:54 <Cale> right, it won't until we actually say what mempty and mappend should be
00:57:58 <Cale> and write the instance
00:58:02 <dminuoso> Do others here use nix to prepare an environment with cabal but then use `cabal new-*` rather than nix for the haskell build itself?
00:58:10 <jusss> Cale: like Maybe may be a monad until we implement fmap, apply, bind and return
00:58:34 <Cale> dminuoso: I don't think there's any difference if you're in a nix environment...
00:58:45 <Cale> dminuoso: at least, if it did its job correctly
00:59:03 <dminuoso> Cale: Well the difference is actually large. There's so many packages on hackage with failing builds..
00:59:08 <dminuoso> Failing tests I mean.
00:59:31 <Cale> dminuoso: Oh, well, I'm always going into environments which have every dependency
00:59:54 <Cale> dminuoso: and if there are failing tests or whatever, there will be a dontCheck on that derivation
01:00:26 <dminuoso> Cale: Sure. It's just annoying to bandaid your dependencies manually.
01:00:42 <Cale> (or in some cases, I'll have unpacked it from source and it'll be a thunk to a forked repo...)
01:01:07 <Cale> Yeah, it's just... what we do at Obsidian.
01:01:13 <dminuoso> Ah
01:01:32 <Cale> On the one hand, it's extremely annoying, on the other hand, you're saving other people from having any given annoyance
01:03:28 <Cale> Also, it's important when we actually go to deploy things that everything gets built consistently
01:04:15 <Cale> It sucks to have bugs in production that didn't show up in testing because cabal decided to pull a slightly different version of something from hackage.
01:05:01 <dminuoso> Cale: fwiw you can still experience that with nix
01:05:22 <Cale> How? Impure derivations?
01:05:50 <dminuoso> Cale: Well do you pin your channels to specific commits?
01:05:53 <Cale> yes
01:05:57 <dminuoso> Oh neat.
01:06:08 <dminuoso> I didn't say anything then. :)
01:07:46 <Cale> Or rather, we refer to a particular hash of the nixpkgs repo
01:08:08 <Cale> (which is roughly the same thing)
01:08:40 <Cale> But we don't use <nixpkgs> or whatever
01:08:42 <dminuoso> Curious, how do you keep all systems in sync with regards to that hash?
01:09:54 <Cale> Well, I don't know what the guys who are running nixos are doing exactly.
01:10:16 <Cale> Personally, I'm only using nix as a build system on my machine.
01:10:28 <Cale> There is a company nixos config though...
01:10:46 <MasseR> We're in a similar situation
01:11:05 <MasseR> Thinking of moving to using <nixpkgs> though, but having CI make sure that the projects are buildable with current stable and future unstable
01:11:44 <Axman6> jackdk: ping
01:12:36 <Cale> dminuoso: In any case, it doesn't seem to matter too much if your system is built from the same hash of nixpkgs, though I guess it does introduce a little room for error in testing.
01:12:37 <DigitalKiwi> unstable is future stable
01:13:07 <Cale> (I'm running Linux Mint and everything runs in a reasonably similar fashion after all)
01:13:44 <dminuoso> Cale: Im doing it mixed style because at the time I didn't fully understand nix, and I couldn't afford to experiment for 2-3 weeks until I had everything worked out with pure nix. But I suppose it's not a big issue to move from this "half nix half cabal v2-*" to raw nix down the road. :)
01:14:35 <Cale> Yeah, I think if I was going it alone -- well, I wouldn't have even gotten this far
01:15:04 <Cale> I have a lot of complaints about the nix language and the culture surrounding its use
01:15:06 <jackdk> Axman6: pong
01:15:51 <Cale> My main complaint is that the benefits of pure functional programming hinge directly on the ability to understand things by looking at their definitions, and these benefits vanish if you can't find the definition of the thing you're looking for.
01:16:16 <Axman6> jackdk: thoght you might be interested in this nix discussion
01:16:19 <MasseR> There is a big lack of documentation. Once you undestand the underlying nix model it's not too bad
01:16:22 <Axman6> thought too
01:16:40 <dminuoso> Cale: Or even if you find the definition, the documentation...
01:16:48 <Cale> The way in which records are built up recursively, and have many hundreds of fields often coming from many different files is pretty unacceptable.
01:17:00 <Cale> I can live without documentation if I can actually find the definition of everything.
01:17:32 <MasseR> I partially disagree. It's a pragmatic solution that works surprisingly well. But it requires some effort from the developer/configurer to keep everything tidy
01:17:39 <Cale> But with nix, I can't do that, it's nearly impossible. It's nearly impossible to determine what a given attrset contains or might contain
01:18:12 <jackdk> thanks Axman6. It's an amazing piece of software but it's sad how undisciplined its language is
01:18:27 <Cale> You go into the nix repl and you try tab completing some stuff and hope that it doesn't just shit all over your terminal in the middle of printing the results
01:18:39 <jackdk> when my best shot at finding something is grep 'name ='
01:18:45 <Cale> You can't discern it from looking at the source
01:18:47 <jackdk> I tend to use builtins.attrNames for that
01:18:52 <Axman6> needs moar lenses
01:19:34 <Cale> Needs moar *types*
01:20:00 <Cale> and even without types, just keeping the number of things in any given attrset low and well-specified
01:20:13 <bahamas> Cale: would using Dhall instead of the nix language make it better?
01:20:48 <bahamas> it's probably doesn't change much since the majority of derivations are written in the nix language
01:20:52 <MasseR> As it is, it requires a full programming language. Just replacing the language won't do the trick
01:20:54 <Cale> bahamas: I don't know. I'd like to use Haskell, but GHC would need to get some pretty crazy features to make that kind of thing reasonably possible.
01:21:20 <bahamas> Cale: like what?
01:21:22 <MasseR> It's relying heavily on laziness and recursion
01:21:55 <Cale> bahamas: 99.9% of everything is going to be dead code each time you use nixpkgs. You don't have time to parse it all.
01:22:13 <Cale> bahamas: nix dynamically loads stuff really well
01:22:31 * Solonarv can't remember how well dhall does that
01:22:37 <Solonarv> it's not turing complete though
01:22:58 <Solonarv> which is actually a good thing, but might make translating existing nix code to it harder
01:23:32 <Cale> I don't know, I've seen some good come of nix's Turing completeness. I've also seen a lot of annoying bullshit come of it.
01:23:38 <jusss> Cale: "<Cale>   mappend (Just x) (Just y) = Just (x <> y)"  what this semigroup <> do?
01:23:45 <Cale> jusss: Depends on the type
01:23:54 <jusss> Cale: String?
01:23:58 <Cale> concatenation
01:24:13 <jusss> Cale: Int?
01:24:21 <Cale> nothing, there's no Semigroup instance
01:24:23 <Solonarv> there is no Semigroup Int instance
01:24:28 <Solonarv> > 3 <> 5 :: Int
01:24:30 <lambdabot>  error:
01:24:31 <lambdabot>      • No instance for (Monoid Int) arising from a use of ‘<>’
01:24:31 <lambdabot>      • In the expression: 3 <> 5 :: Int
01:24:41 <jusss> Cale: Solonarv Maybe a?
01:24:42 * Solonarv slaps lambdabot
01:25:05 <Cale> jusss: If it's Maybe a, it'll use mappend again :)
01:25:12 <Solonarv> jusss: why don't you look up the actual instance definition?
01:25:36 <dminuoso> jusss: (<>) captures the notion of "smashing things together" in a way that makes sense. So if you ever find yourself writing something like `A -> A -> A`, then it's a possible candidate for Semigroup.
01:25:52 <Solonarv> (<>) is part of Semigroup, which is from Data.Semigroup - link: https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Semigroup.html#t:Semigroup
01:26:17 <Solonarv> if you scroll down a bit you can see the list of instances, click the Source link next to one of the instances to see that instance's implementation
01:26:42 <Solonarv> for example here is the instance for Maybe a: https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#line-403
01:26:49 <Cale> The law is that x <> (y <> z) must be the same as (x <> y) <> z
01:26:59 <Cale> so long as that's true, you can define a Semigroup instance
01:27:13 <Cale> The reason that there's no instance for Int is that there are two obvious ones: addition and multiplication
01:27:23 <Cale> To pick one, use the Sum and Product newtypes
01:27:23 <Solonarv> (and a whole lot of less obvious ones)
01:27:31 <dminuoso> Cale: There shouldn't be one for Int because you dont have closure.
01:27:39 <Cale> You do though
01:27:55 <dminuoso> Cale: Ah, is addition/multiplication defined as modulo arithmetic?
01:28:15 <Cale> It's arithmetic modulo some unspecified power of 2 (which can be determined by looking at maxBound and minBound)
01:28:25 <Solonarv> > 2^31 + 2^31 :: Int32
01:28:28 <lambdabot>  0
01:28:36 <dminuoso> Oh yeah. :)
01:28:40 <Solonarv> yup, modular arithmetic
01:29:21 <Solonarv> closure is actually implicit in the type as long as <> is total
01:30:33 <Cale> dminuoso was thinking that it wasn't total
01:30:36 <Solonarv> and there is *usually* an expectation of totality anyway - especially for the less kludgy typeclasses - so that just isn't mentioned in the docs
01:30:57 <Solonarv> (Num is a big offender for "kludgy typeclass", and so is Enum)
01:31:08 <Cale> (it would be somewhat reasonable to error out if there was overflow, except we'd find that horribly inconvenient in Haskell)
01:31:31 <Axman6> There's definitely more than two obvious Semigroup instances for Int. xor is also a nice one
01:31:42 <Axman6> (Also a monoid)
01:31:53 <dminuoso> Cale: I guess my real mistake was thinking that you had to implement it in terms of (*) and (+), but I realized that it doesnt matter since you could implement (+ mod n) and (* mod n) for a suitable n by hand anyway.
01:31:55 <Solonarv> Axman6: also bitwise equality
01:32:58 <kuribas> are there haskell ways for debugging besides Debug.Trace?
01:33:13 <Solonarv> or gcd/lcm, at least for Integer - can't remember if those work in modular arithmetic
01:33:23 <kuribas> while I find writing lisp harder than haskell, debugging using traces is so much easier than in haskell.
01:33:34 <Solonarv> kuribas: there is an interactive step-through debugger built into GHCi
01:34:07 <kuribas> Solonarv: that wouldn't work with databases or a live system
01:34:14 <Solonarv> oh, indeed
01:34:20 <Solonarv> I was assuming you wanted to debug pure code
01:34:26 <kuribas> nah :)
01:34:42 <Solonarv> if your code is already running in IO you can just vomit stuff to stderr or some other logging method normally
01:35:08 <kuribas> Solonarv: to get the same as in lisp I'd need to log every function then...
01:35:09 <Solonarv> Debug.Trace is specifically for "I want to do printf debugging but the code I want to debug isn't running in IO"
01:35:21 <kuribas> I suppose Debug.Trace is the way though...
01:35:44 <kuribas> probably with ghci
01:35:48 <kuribas> for quick reloading
01:35:53 <Solonarv> no, Debug.Trace is just a wrapper around unsafePerformIO (value <$ putStrLn "debug message")
01:36:18 <Solonarv> if you already in IO you can just putStrLn (or whatever) directly
01:36:22 <mpickering> kuribas: Why won't the ghci debugger work for you
01:36:29 <mpickering> if you're going to interpret the code anyway
01:36:34 <kuribas> mpickering: I found it awkward to use
01:36:51 <kuribas> offering little flexibility in what to evaluate
01:36:51 <Solonarv> I think there's some way to get your hands on a call stack using the HasCallStack machinery
01:37:15 <mpickering> what do you mean? If you want to evaluate something you use `:force` or just type the expression into the repo
01:37:17 <mpickering> *repl
01:37:23 <kuribas> mpickering: it feels to imperative
01:38:39 <Solonarv> if you want a call stack it looks like you can just use 'callStack :: HasCallStack => CallStack' from GHC.Stack
01:38:55 <mpickering> your alternative is to add trace statements which get output in a linear unstructured order
01:39:31 <kuribas> Solonarv: no, just a trace from a function
01:39:46 <Solonarv> I'm still confused as to what your actual situation is
01:39:58 <kuribas> Solonarv: while I think live coding is crazy, seeing a trace in a live system is also handy
01:40:36 <Solonarv> you have functions which are already producing IO actions, why can't you just insert some putStrLn statements in there?
01:40:39 <kuribas> Solonarv: I'd like to introduce some haskell in the company, but the criticism is that you cannot do live coding or debugging in haskell.
01:41:11 <Solonarv> I mean, you can't magically get traces on everything without using a debugger or changing anything in the source code, that's crazy
01:41:18 <Solonarv> you need to do *something*
01:42:10 <kuribas> Solonarv: in lisp/clojure you can :)
01:42:25 <Solonarv> well you're clearly still doing something!
01:42:51 <lortabac> Solonarv: if you compile with profiling enabled, and launch your executable with +RTS -xc -RTS, you get stack traces on every exception
01:42:59 <Solonarv> unless you're telling me every lisp/clojure program logs literally everything by default
01:43:09 <kuribas> Solonarv: all I need to do is to connect to the live system, then use cider-toggle-trace-var in emacs, and I get a trace in the repl.
01:43:27 <Solonarv> lortabac: yeah, but it looks like kuribas wants traces/logging in non-exceptional situations too
01:43:46 <lortabac> oh, I missed the beginning of the conversation
01:43:50 <Solonarv> kuribas: ah, I see
01:43:50 <kuribas> Solonarv: not really, a good alternative that I can present my team is also good.
01:44:37 <kuribas> Solonarv: perhaps it modifies the function code to emit a trace.
01:44:57 <Solonarv> well yes, of course it does
01:45:07 <kuribas> Solonarv: perhaps ghci + debug trace is enough (or putStrLn in IO)
01:45:23 <lortabac> maybe the new interpreter that Chris Done is implementing will be able to do this, I don't know
01:45:26 <Solonarv> that certainly seems to be enough for most people here (including myself)
01:46:30 <kuribas> ok
01:55:03 <lortabac> kuribas: if you introduce Haskell to your team, consider investing some time to build monitoring tools
01:56:58 <lortabac> for example in my company we built a monitoring system based on http://hackage.haskell.org/package/ekg
01:57:37 <dminuoso> lortabac: We just use the prometheus package, which integrates nicely into our large prometheus environment. :)
01:57:58 <dminuoso> (There's a good RTS stats exporter package even)
01:59:07 <dminuoso> though ekg is really nice if you need to quickly add some monitoring in under a minute. :)
01:59:43 <lortabac> dminuoso: we added some javascript graphs etc
02:00:33 <dminuoso> lortabac: We have a grafana dashboard, giving us all the graphing magic. :)
02:01:36 <lortabac> I didn't know about the prometheus package, I will have a look
02:01:55 <lortabac> it might be better than the manual prometheus integration we have now
02:02:32 <lortabac> anyway, my point was that you can compensate for the lack of debugging facilities through other means
02:03:01 <lortabac> and those means are even better in the case of large applications
02:03:18 <Solonarv> and it looks like live monitoring is what you wanted in the first place, which isn't exactly the same as debugging
02:03:36 <lortabac> yes
02:04:48 <mpickering> kuribas: Are you aware of the eventlog? 
02:05:14 <kuribas> lortabac: cool :)
02:05:35 <kuribas> mpickering: no
02:05:49 <mpickering> lortabac: Are you aware of the eventlog? 
02:06:02 <mpickering> You can use it to monitor things like memory usage
02:06:06 <mpickering> and also user defined events
02:06:42 <kuribas> lortabac: for logging we just dump stuff to a file, then use unix tools to get information
02:07:00 <kuribas> I am not sure if we need anything beyond that
02:07:23 <kuribas> but certainly worth looking into...
02:10:07 <dminuoso> lortabac: https://hackage.haskell.org/package/prometheus-client https://hackage.haskell.org/package/prometheus-metrics-ghc is what we use :)
02:10:34 <lortabac> thanks
02:11:36 <dminuoso> There's also another package for process information by the same author that might be interesting.
02:28:13 <Frobozz> openssh
03:34:06 <kuribas> can you get a regular adt out of a servant API?
03:34:13 <kuribas> with the same information?
03:34:35 <dminuoso> kuribas: You mean a reified api?
03:34:51 <kuribas> I guess?
03:35:09 <kuribas> a simple non-polymorphic value
03:35:25 <kuribas> with endpoints as strings for example
03:35:40 <dminuoso> kuribas: To genererate an actual ADT I think you couldn't get around TH.
03:35:54 <kuribas> dminuoso: generics?
03:36:10 <dminuoso> kuribas: You cant derive a type with generics.
03:36:36 <dminuoso> data YourAPI = ... what should go here? ...
03:37:55 <kuribas> dminuoso: [EndPoint] ?
03:38:17 <dminuoso> kuribas: Look at servant-docs then
03:38:24 <dminuoso> It's kind of that.
03:39:13 <dminuoso> kuribas: It produces some `Map Endpoint Action` from an api specification
03:39:25 <dminuoso> (buried in the API data type)
03:39:30 <kuribas> dminuoso: nice, that's what I want ...
03:39:38 <dminuoso> http://hackage.haskell.org/package/servant-docs-0.11.3/docs/src/Servant.Docs.Internal.html#API
03:39:51 <kuribas> dminuoso: for example to compare against a swagger
03:40:03 <kuribas> to see if they match
03:56:54 <absence> is there an extension tha allows empty record updates?
03:57:30 <merijn> absence: What would that mean?\
03:57:57 <merijn> An empty record update sounds like, well, not an update...
03:57:58 <absence> merijn: id, i guess?
03:58:17 <merijn> absence: What problem are you trying to solve?
03:58:35 <absence> merijn: getting the haskell code generated by the thrift compiler to compile
03:59:24 * dminuoso smells xy
04:02:38 <absence> merijn: it generates the code "something = blabla{}" which fails to compile. i guess i can just remove the {} manually, but if there's some option i can pass to ghc that makes it compile, i'd be happier
04:03:49 <f-a> absence: it should work, no?
04:04:22 <f-a> λ> data Prova = Prova
04:04:22 <f-a> λ> a = Prova {}
04:06:27 <absence> f-a: your example is different, as your line starts with "data" and has a capital identifier :)
04:07:15 <f-a> ah, I misread, sorry absence 
04:08:28 <absence> no worries. fwiw, the compiler complains about "Empty record update"
04:08:41 <f-a> unfortunately not much seems to be moving... https://gitlab.haskell.org/ghc/ghc/issues/7658
04:10:01 <absence> oh well, so the thrift compiler is buggy
05:00:24 <bobakk3r> Does anyone know how I can generate unique paired identifiers in haskell?
05:00:30 <absence> is there a trick to combine the results of "on (==) field1" and "on (==) field2" using e.g. && without spelling it all out, or is that stretching the power of on?
05:01:38 <Solonarv> (liftA2 . liftA2) (&&) :: (a -> b -> Bool) -> (a -> b -> Bool) -> a -> b -> Bool
05:02:04 <Solonarv> you can define <<&&>> = (liftA2 . liftA2) (&&)
05:02:47 <Solonarv> and then write: (==) `on` field1 <<&&>> (==) `on` field2
05:03:12 <lyxia> > (==) `on` liftA2 (,) ?field1 ?field2
05:03:15 <lambdabot>  mueval-core: internal error: PAP object entered!
05:03:15 <lambdabot>      (GHC version 8.2.2 for x86_64_unknown_linux)
05:03:15 <lambdabot>      Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
05:03:30 <lyxia> uh
05:03:59 <lyxia> > \field1 field2 -> (==) `on` liftA2 (,) field1 field2
05:04:02 <lambdabot>  error:
05:04:02 <lambdabot>      • No instance for (Typeable a0)
05:04:02 <lambdabot>          arising from a use of ‘show_M35900842137764317201392’
05:04:19 <lyxia> :t \field1 field2 -> (==) `on` liftA2 (,) field1 field2
05:04:21 <lambdabot> (Eq b, Eq a1) => (a2 -> a1) -> (a2 -> b) -> a2 -> a2 -> Bool
05:04:52 <Solonarv> oh, good idea!
05:05:48 <absence> thanks both of you :)
07:16:15 <ocharles> fwiw, I don't think any of these suggestions have made code more readable
07:34:04 <tokdaniel> quit
08:22:44 <gobby> I want to create a website and use Haskell on the backend. Anybody have any experience with frontends to use? If possible I'd like to  use something like WordPress or Joomla on the front end and send JSON requests to yesod
08:23:25 <tdammers> if all you do on the Haskell side is expose a JSON API, then the frontend can be anything you want
08:24:11 <tdammers> although wordpress wasn't really meant to be used this way, it's a blogging platform intended as an all-in-one solution for running a complete blog on a cheap shared hosting service
08:24:12 <c_wraith> I do find calling wordpress or joomla "front end" amusing.  I mean, I guess they can be, but they usually aren't.
08:24:34 <tdammers> "frontend/backend" is a bit of a confusing distinction too
08:25:10 <tdammers> in corporate, "frontend" means "anything other than the databases and the processes acting directly upon those", whereas in web dev land, "frontend" means "html, css, javascript'
08:26:08 <c_wraith> I mean, there are a lot of installs where wordpress is the only thing interacting with the database.
08:26:55 <c_wraith> But there are also installs where you have tons of plugins/customization that use APIs to populate data, which makes it much more of a front end.
08:34:46 <Zemyla> I really want mutable versions of Seq, Set, Map, IntSet, and IntMap in containers.
08:38:59 <Solonarv> stuffing one of these in an IORef/MVar/TVar/whatever is the best you can get
08:39:06 * ski . o O ( "s/mutable/ephemeral/" )
08:39:32 <Solonarv> you could build mutable-from-the-ground-up pendants but those are entirely different data structures
08:43:33 <halogenandtoast> For `newtype Deck a = Deck { getDeck :: [a] } deriving Show` is there a way I can restrict what a is allowed to be here I have two types Troop and Tactic (and these should be in separete decks)
08:43:47 <halogenandtoast> *separate
08:49:18 <gobby> tdammers: do you have any recommended front end frameworks that might play nicely here? I'm currently using elm but I'd rather a template of some sort.
08:53:10 <Madderote> tdammer: SilverStripe is highly customizable. Not the most well know out there but an interesting alternative
08:53:28 <Madderote> tdammers: Drupal also an option
08:59:29 <ski> (you could also have references to mutable boxes, as values in the containers .. just as you could have `Int's there, with HashConsing)
09:00:42 <ski> halogenandtoast : well, would it be preferable to restrict `Deck', rather than making sure you only use it in a restricted way ?
09:05:42 <halogenandtoast> ski: Not sure I know the pros/cons for either approach
09:06:48 <halogenandtoast> In application terms I have two types of card, these come from different decks, can compose the same players hand, and can be played to one of 9 flags in the game (the side they are played to matters)
09:07:08 <halogenandtoast> so I want to represent that a Deck is a list of these card types but can't contain both at the same time
09:07:21 <halogenandtoast> a Hand, or side of a flag, can contain either
09:09:48 <Zemyla> Actually, I thought of a way to have a mutable Seq, in such a way that building one from a list takes far less time than it normally would.
09:17:23 <Zemyla> A MutFingerTree s a has a MutableByteArray s which contains the size and info on the circular queues used for the prefix and suffix; a MutableArray s a which holds 8 elements, which represents the head and tail of the FingerTree; and a pointer to a MutFingerTree s (Node a), for the interior.
09:19:42 <Zemyla> 3 times out of 4, adding a value to a mutable sequence will involve reading the info word, incrementing the size of the circular queue, and inserting a value, plus incrementing the size.
09:20:43 <Zemyla> The other 1/4 the time, it'll have to remove 3 values from the queue, put them in a Node, append it to the child tree, and then add the new value.
09:21:31 <ski> halogenandtoast : how much of the code manipulating decks needs to know the type of card ?
09:24:14 <ski> sometimes people ask about restricting a parameter of a data type (or type synonym, i assume) to belong to a particular type class. turns out there's no direct way to do that. also, what people tend to do is put such constraints on the operations instead (at least in the cases where the operation needs them, or might have needed them, with a different implementation)
09:24:31 <ski> (it seems that your question is perhaps related to this)
09:25:52 <fendor> what is the purpose of cabal-cache? Could it be used to speed up building a package from source?
09:31:14 <jgt> I need to password-protect a file before I add it as an attachment to a message through the Mailgun API. Anyone know a good approach to password protecting a file (or actually, a string)
09:48:51 <tty1> would you guys agree that Haskell is noth OOP and functional?
09:48:57 <jgt> I think I might end up using scrypt
09:49:12 <jgt> tty1: I don't know what that means
09:49:30 <tty1> oop = object oriented programming
09:49:42 <boj> tty1: how are you seeing it as OOP?
09:49:43 <jgt> no, I know what OOP means
09:49:57 <tty1> oh
09:50:01 <jgt> but I don't understand the question
09:50:23 <jgt> Haskell is FP, not OOP
09:50:29 <tabaqui> define OOP
09:50:29 <sm> you can write "object oriented" code in Haskell, but there's no special support for it in the language
09:50:38 <tty1> well the class and instance stuff in haskell looks like OOP to me. Defining functions that act on types, types have their own self contained data
09:51:04 <tty1> jgt: i think we could all agree its FP. But to my eyes it appears to **also** be OO
09:51:08 <jgt> tty1: types have their own self contained data? Are you sure?
09:51:09 <tabaqui> there are at least 3 different definitions of OOP
09:51:30 <tabaqui> old-school Alan Key OOP (Smalltalk, Erlang)
09:51:42 <tty1> jgt: yea when you define something as Data, you are creating the implementation of the typeclass (which is like the interface)
09:51:49 <tabaqui> C++ - Inheritance, Incapsulation, Polymorphism
09:51:55 <tabaqui> and new-school SOLID
09:52:00 <argent0> Hi, why is something like: `traverse_ putStrLn $ repeat "y"` lazy?
09:52:20 <jgt> I take OOP to mean new-school SOLID, like in Ruby, which I'd say Haskell isn't like
09:52:36 <kaol> tabaqui: Erlang? Did you mean Eiffel?
09:52:45 <tabaqui> kaol: I mean actors
09:52:57 <kaol> Ok then.
09:53:00 <tty1> tabaqui: im trying to avoid a technical definition, since there is want, and seeing it more in vague terms.. do you have objects that have their own functions and data self contained within them, and some sense of hierarchy across objects/types
09:53:05 <jgt> kaol: I think he meant Erlang, as IIRC Alan Kay just meant OOP as "message passing"
09:53:27 <tty1> since we dont have a single technical definition anyway
09:53:36 <tabaqui> tty1: yes, yes, yes
09:53:54 <tty1> to me haskell feels both functional and OOP
09:54:03 <tabaqui> fine thing is that C is OOP in that sense
09:54:23 <tty1> which i quite like about haskell so far actually (I was hoping to find a language that was functional with OOP features as well)
09:54:54 <tabaqui> it is not quite true
09:54:56 <boj> argent0: well, repeat is lazy since it doesn't actually compute an infinite list of "y" ahead of time
09:55:14 <tabaqui> Python has lambda functions and closures but it doesn't follow functional paradigm
09:55:32 <tdammers> you can implement all three notions of OOP in Haskell
09:55:41 <tabaqui> Haskell has type class hierarchy but programmers don't think in OOP terms
09:55:50 <tdammers> typeclasses aren't OOP classes
09:56:03 <tdammers> if you're going to model classes, you'd use records
09:56:19 <argent0> boj: I think I get it now. That code would never end and thus never produce the 'Appicative f => f ()` return value. And the putStrLn is just producing side effects/
09:57:04 <kaol> I've read blog posts arguing about whether comonads are objects.
09:57:21 <tabaqui> we don't think about "Employer extends Person class with new attributes"
09:57:34 <tty1> tabaqui: well i define functional different than most people, or at least different than you do... to me lambda functions and closures are common to functional programming but not really what defines something as functional
09:58:04 <tabaqui> tty1: same is true for OOP
09:58:17 <tabaqui> it is not just classes with overloaded methods and inheritance
09:58:30 <tabaqui> it is factories, contexts, interfaces and so on
09:58:35 <tty1> tabaqui: to me functional programming is more about deterministic qualities (same input gives same output) and generally a strong reliance on immutable objects as the default, just as much as it is about closures and lambdas
09:59:08 <tty1> tabaqui: well yea how we define it is the issue, we arent dealing with a technical definition of some universal acceptance, so its more about how a language "feels" than it is about anything concrete
10:00:01 <jgt> tty1: you could do typically FP things in Ruby for example, by treating classes as method buckets and making all those methods pure
10:00:07 <jgt> tty1: but that's not idiomatic Ruby
10:00:31 <zachk> tty1, if you want something designed as both FP and OOP look at Scala maybe 
10:00:41 <boj> tty1: i think your intuition is close, when we say "functional" we don't mean "with functions", we mean something closer to "equational reasoning"
10:01:06 <tty1> jgt: you would still lack efficient immutable bject classes though. If you wrote libraries that included that then I'd be more likely to accept ruby as having functional aspects
10:01:31 <tty1> boj: yes thats clse to how I see it
10:04:59 <jgt> tty1: tbh, for the purposes of this discussion, classifying languages by exactly which features they technically support is not very useful
10:05:48 <tty1> jgt: I agree
10:07:20 * hackage model 0.5 - Derive a model of a data type using Generics  https://hackage.haskell.org/package/model-0.5 (PasqualinoAssini)
10:24:37 <jgt> aaaarrhhhggg haskellers! "This library does not support zip encryption because zip encryption is bad and nobody should use it"
10:25:35 <jgt> actually maybe I'm very much barking up the wrong tree here and I should be looking to create a tar archive, and not a zip archive
10:28:25 <jgt> wrong again; tar doesn't support password protection
10:30:40 <phadej> IIRC zip password protection is quite weak
10:32:52 <cocreature> you could use something like gpg to encrypt whatever file you have
10:33:58 <cocreature> or tarsnap’s scrypt or whatever you prefer :)
10:35:25 <phadej> at least gpg is way more explicit about the algorithms used for encryption, looks like 7-zip uses AES-256, but I have no idea how well that's supported across all zip stuff out there
10:36:27 <phadej> e.g. https://superuser.com/a/1299756/708224 suggest that badly
10:41:48 <Solonarv> jgt: gzip/xz/zip/whatever turns an opaque bytestring into another (usually shorter) bytestring, why does encryption need to be mixed into that?
10:46:01 <tdammers> I don't see anything wrong with refusing to put voluntary effort towards supporting a feature that is objectively bad
10:57:24 <jgt> Solonarv: the reality of the business world (especially when dealing with governments) is they expect to be able to just pass aroud password-protected zip archives
10:57:39 <jgt> yes, the protection is weak
10:57:59 <jgt> but no, it's not worth my time to try and make a foreign government organisation change their process
11:00:24 <Solonarv> oh, I see
11:02:14 <jgt> cocreature: yeah I was going to go with scrypt; I've used it for another project and it's real nice
11:04:23 <jgt> in my discussions with this organisation I was collaborating with (I'll say they're in the UK, but nothing more), we discussed the level of security they require for passing confidential information
11:05:01 <jgt> they said "well you can password protect a zip file, and you could use a password like Jonathan1"
11:05:35 <jgt> all I can do is nod and smile
11:09:24 <jgt> ok, so the strategy will be: ensure zip is installed using the NixOps configuration, and just call the external program from my Haskell application
11:09:47 <jgt> should I just use System.Process.readProcess for this?
11:15:35 <cocreature> or callProcess if you don’t need to capture stdout
11:18:48 <jgt> cocreature: I need to turn it back into a String
11:19:03 <jgt> cocreature: (I am aware this will be horribly inefficient)
11:19:47 <jgt> the flow is like app -> zip -> app -> wreq -> mailgun
11:20:40 <jgt> or… hmm. Maybe not. I need to check the wreq docs again
11:28:55 <jgt> ok yeah, that's basically the flow
11:37:30 <cocreature> jgt: I’d probably try to at least go with a ByteString
11:40:09 <jgt> cocreature: yeah, I can do that in Wreq with either partBS or partLBS
11:40:24 <jgt> although I have no intuition for whether a strict or lazy bytestring is better here
11:40:33 <jgt> I'm guessing strict, since I need all of it anyway
11:41:44 <jgt> the challenge now is: how do I get zip to accept stdin, do the compression and password-protection, and send the result to stdout
11:41:50 <Solonarv> generally the advantage of lazy BS is that you can stream it
11:42:15 <Solonarv> depending on how large your input is that might not be worth the bother
11:42:51 <jgt> Solonarv: quite small input; I'll get an exact number in a minute or so
11:43:30 <cocreature> getting the output of a process as a lazy BS requires lazy IO so I’d stay away from it unless you know things are going to be sufficiently large that streaming will be benefitial
11:44:17 <jgt> cocreature: that's a good point; thanks for that hint!
11:44:30 <grayson> hi all -- rather nooby question here
11:44:41 <Solonarv> grayson: ask away!
11:44:49 <jgt> Solonarv: input is about 4.7K — I _think_ this is small
11:44:56 <Solonarv> yeah, that's small
11:45:06 <Solonarv> strict BS it is!
11:45:40 <grayson> trying to decode some YAML on disk, using Data.Yaml and decodeFileEither which returns IO (Either ParseException a)
11:46:01 <jgt> cocreature: I think my hands are tied by System.Process.readProcess anyway, as it's a `IO String`
11:46:37 <grayson> my issue is that I'd like to compose over Eithers in the main app and throw all error handling to a single function, and I've got an ADT defined for a general `ProgramError` 
11:46:51 <grayson> but what's the best way to handle `ParseException`?
11:46:55 <cocreature> jgt: readProcess is just a high-level wrapper around things like withCreateProcess that give you a Handle so you could get a ByteString from it. there are also some packages that have the same high-level wrappers for ByteString
11:46:59 <boj> jgt: Data.ByteString.Char8.pack
11:47:22 <cocreature> boj: please no, that’s a terrible function that should not be used
11:47:32 <boj> oh, well then
11:48:26 <jgt> boj: I'm aware of how to convert between different types of IsString things, but I didn't realise it would save me anything by doing String -> ByteString rather than just using the String I already have directly
11:48:35 <cocreature> also if you already have a String there is little point in converting to a ByteString instead of passing the String to wreq. The point of going via ByteString is that you avoid needlessly (or even incorrectly if you are actually dealing with binary data) converting to a String
11:49:06 * jgt achievment unlocked: write a thing which cocreature then confirms in his own words
11:49:18 <cocreature> jgt: you type too fast :)
11:50:01 <Solonarv> no such thing!
11:50:08 <Solonarv> thw fatsre you type the better
11:50:16 <cocreature> for 4.7k I probably wouldn’t worry about the performance overhead of String unless I’m sure this is an issue but I would worry about correctness if you are dealing with binary data (which in the context of compression and encryption you probably are)
11:50:16 <Solonarv> there is no dwnside
11:50:35 <Solonarv> it's certainly binary data after being compressed
11:51:23 * jgt giggled at "thw fatsre"
11:51:57 <Solonarv> success!
11:52:01 <jgt> cocreature: what kind of correctness issues should I look for?
11:52:40 <jgt> my naïve thought is "any character not ascii-lookin"
11:52:51 <jgt> and then maybe also weird things like BOMs
11:52:54 <cocreature> jgt: trying to decode arbitrary bytes as unicode is at best going to throw an exception or at worst might discard data depending on how lenient the decoding is
11:55:51 <jgt> cocreature: the stuff I want to zip in this case is some XML generated with Text.XML. The XML contains some values that a human has entered into a web form.
11:56:03 <jgt> I don't know if that added context is helpful
11:56:33 <Solonarv> jgt: it doesn't really matter that that data you're feeding to zip is textual
11:57:04 <Solonarv> what you get back is 100% binary data, which can (and, eventually, will) break if you treeat it as a String
11:57:15 <cocreature> by default all the IO in base is als dependent on your locale so you can end up with fun issues where it works for literally the same data on your local machine but not when you deploy your code
11:57:29 <jgt> ah, that's a good point
11:57:57 <grayson> sorry if that question was a little too general -- I be a little more specific if necessary
11:58:43 <cocreature> jgt: process-extras is one of the packages that I mentioned before that has at least some of the highlevel wrappers in ByteString variants
11:58:55 <cocreature> given that it’s rather tricky to replicate them yourself, I’d go for an existing package
11:59:09 <fendor> grayson, what do you want to do if the data you read is not parsable?
11:59:14 <jgt> ok, so should I take a completely different approach instead? One idea that comes to mind is: 1. Save XML to file in tmp dir with UUID filename 2. run zip on it using some function from System.Process (but _not_ readProcess) 3. Read in resulting zip archive as a ByteString some other way (like Conduit)
11:59:55 <Solonarv> that would also work
11:59:56 <cocreature> the important part is to not read binary data as a String
12:00:01 <grayson> fendor: if it's not parsable, I'd like to return a `Left ProgramError` to be handled by a larger error handler later
12:00:09 <zeta_0> in ~/.cabal/config for the haddock hoogle option, if i set it to True does that just mean that cabal integrates with and activates hoogle by searching for the hoogle env var? is that correct?
12:00:12 <Solonarv> but futzing around with temp files seems a bit more annoying
12:00:22 <cocreature> whether you read the output of the process as a ByteString or have it write in a file and read that as a ByteString isn’t that important
12:00:43 <fendor> grayson, alright, so what you want to have is a `Either ParseException a -> Either ProgramError a`?
12:03:18 <jgt> Solonarv: Yeah, it does. Ok, so it looks like I can use System.Process.ByteString.readProcessWithExitCode, assuming I can use zip as a stdin/stdout type program
12:03:20 * hackage byte-order 0.1.0.0 - Portable big-endian and little-endian conversions  https://hackage.haskell.org/package/byte-order-0.1.0.0 (andrewthad)
12:03:58 <jgt> cocreature: I know I wouldn't have found process-extras (or even thought about this potential issue) on my own. Thank you for this!
12:04:39 <cocreature> jgt: pretty sure I only discovered it after having run into somewhat similar issues at some point. you learn from your mistakes :)
12:32:20 * hackage rewrite-inspector 0.1.0.0 - Inspection of rewriting steps  https://hackage.haskell.org/package/rewrite-inspector-0.1.0.0 (omelkonian)
12:33:20 * hackage rewrite-inspector 0.1.0.1 - Inspection of rewriting steps  https://hackage.haskell.org/package/rewrite-inspector-0.1.0.1 (omelkonian)
12:40:50 * hackage pandoc-pyplot 2.1.2.0 - A Pandoc filter to include figures generated from Python code blocks  https://hackage.haskell.org/package/pandoc-pyplot-2.1.2.0 (LaurentRDC)
12:52:51 * hackage libffi-dynamic 0.0.0.2 - LibFFI interface with dynamic bidirectionaltype-driven binding generation  https://hackage.haskell.org/package/libffi-dynamic-0.0.0.2 (JamesCook)
13:07:19 <lukelau> Is haskell.org down for anyone else?
13:07:51 * hackage rewrite-inspector 0.1.0.2 - Inspection of rewriting steps  https://hackage.haskell.org/package/rewrite-inspector-0.1.0.2 (omelkonian)
13:08:04 <machinedgod> lukelau: https://isitup.org/haskell.org
13:08:09 <machinedgod> (its up)
13:08:29 <grayson> Please advise on this is
13:09:29 <grayson> sorry, ignore that :/
13:11:11 <Boarders> lukelau: it is down for me
13:12:24 <machinedgod> lukelau: Correcting myself: its down for me too (isitiup.org is a liar)
13:12:33 <machinedgod> Sorry :-(
13:13:46 <monochrom> It is up for me. However, my home internet seems to be down, I can't ssh to my home computer.
13:14:09 <monochrom> Oh wait, misread, hackage is up.
13:14:30 <monochrom> Yeah I can't reach haskell.org either.
13:14:50 <monochrom> OK correlation implies haskell.org is hosted at my home!
13:15:14 <Solonarv> monochrom: well go fix it then!
13:17:05 <monochrom> I am making C lecture slides. I am fighting the urge to do fibonacci or factorial.
13:18:11 <zachk> do them iteratively with for loops
13:18:35 <monochrom> No, int is too small for them.
13:19:33 <zachk> can't you do a few before it overflows?
13:19:33 <Solonarv> ah yes, that's a problem
13:20:02 <monochrom> Yes but no fun.
13:20:16 <Solonarv> oh! you could do euclid's algorithm (the one for finding GCDs)
13:20:22 <monochrom> Ah.
13:21:07 <Solonarv> it's tail recursive without an accumulator
13:21:55 <Boarders> you could do pascal's triangle
13:22:53 <Boarders> hmework is to nicely print it out mod 2 :)
13:39:28 <MarcelineVQ> Are they supposed to be fun slides?
14:00:00 <rabican> hey haskellers
14:00:16 <rabican> anyone using acid state?
14:00:27 <rabican> can you make a acid state cluster?
14:00:36 <rabican> happstack.com looks strong
14:00:49 <rabican> ==
14:02:25 <grayson> okay, so I've been hacking on this for a second
14:02:48 <grayson> and I think the main issue I'm having is getting `decodeFileEither` to return something other than `ParseException`
14:03:34 <grayson> i'd like something like decodeFile :: IO (Either ProgramError Config)
14:05:59 <merijn> grayson: You mean "how do I stop it from returning parseexception?" or "how do I change ParseException into some ProgramError?"
14:06:16 <grayson> merijn: the second one
14:06:24 <merijn> :t first
14:06:26 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
14:06:30 <merijn> hmm, wrong one
14:06:30 <grayson> as soon as I make the signature anything other than `decodeFile :: IO (Either ParseException Config)`, ghci starts complaining about ambiguous types
14:06:38 <merijn> :t Data.Bifunctor.first
14:06:39 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
14:07:59 <merijn> grayson: Not sure where decodeFile comes from/what it's type is, but generally you'd just want to have "ParseException -> ProgramError" and then just handle the Left case of Either (which is what first from Bifunctor does)
14:08:46 <grayson> context is trying to decode Yaml on disk using Data.Yaml (decodeFileEither)
14:11:45 <grayson> assuming the Either is wrapped in IO, something like:
14:12:08 <grayson> decoded <- decodeFileEither f
14:12:17 <grayson> return $ first asProgramError decoded
14:12:19 <grayson> ?
14:12:32 <grayson> seems to compile /shrug
14:13:23 <grayson> merijn: thanks :)
14:26:36 <merijn> grayson: Yeah, alternatively you can do "first asProgramError <$> decodeFileEither f" or, like, a million other variations using fmap or something :)
14:26:47 <fresheyeball> hey out there
14:26:52 <fresheyeball> I am trying to use this https://github.com/haskell-hvr/OTP
14:27:04 <fresheyeball> but I can't get it's output to match google authenticator
14:27:31 <fresheyeball> I tried encodeing and decoding the secret in base32 using "sandi"
14:27:35 <fresheyeball> but no dice
14:28:27 <vijaytadikamalla> how to define a newtype that would represent an Int limited to the range [0..9] deriving (enum,Eq,Ord,Show)?
14:28:54 <fresheyeball> vijaytadikamalla: you can just use generalizednewtypederiving
14:29:10 <Solonarv> vijaytadikamalla: you can't let GHC derive Enum there, that would allow you to go out of the range
14:29:49 <Solonarv> % newtype SingleDigit = SingleDigit Int deriving newtype (Eq, Ord, Show, Enum)
14:29:50 <yahb> Solonarv: ; <interactive>:111:1: error:; Illegal deriving strategy: newtype; Use DerivingStrategies to enable this extension
14:29:57 <Solonarv> % :set -XDerivingStrategies
14:29:58 <yahb> Solonarv: 
14:30:00 <Solonarv> % newtype SingleDigit = SingleDigit Int deriving newtype (Eq, Ord, Show, Enum)
14:30:00 <yahb> Solonarv: ; <interactive>:113:57: error:; * Can't make a derived instance of `Eq SingleDigit' with the newtype strategy: Try GeneralizedNewtypeDeriving for GHC's newtype-deriving extension; * In the newtype declaration for `SingleDigit'; <interactive>:113:61: error:; * Can't make a derived instance of `Ord SingleDigit' with the newtype strategy: Try GeneralizedNewtypeDeriving for GHC's newtype-deriv
14:30:10 <Solonarv> ffs
14:30:18 <Solonarv> % :set -XGeneralizedNewtypeDeriving
14:30:18 <yahb> Solonarv: 
14:30:21 <Solonarv> % newtype SingleDigit = SingleDigit Int deriving newtype (Eq, Ord, Show, Enum)
14:30:21 <yahb> Solonarv: 
14:30:39 <Solonarv> % succ (SingleDigit 9 )
14:30:39 <yahb> Solonarv: 10
14:30:41 <Solonarv> uh oh!
14:30:53 <fresheyeball> or right
14:31:01 <fresheyeball> you need to write a custom enum instance with mod
14:31:07 <Solonarv> yes
14:31:16 <Solonarv> (you can also clamp to the range instead of wrapping around)
14:34:35 <vijaytadikamalla> without Enum, what should I do?
14:34:44 <vijaytadikamalla> how to define a newtype that would represent an Int limited to the range [0..9] deriving (Eq,Ord,Show)
14:35:13 <ski> "smart constructors" ?
14:36:14 <Solonarv> well you just... write that newtype?
14:36:15 <ski> however, you should probably also ask yourself what you want to be able to do, with values of this type
14:36:24 <Solonarv> you can't build the limited range into the newtype itself
14:37:05 <ski>   newtype SingleDigit = MkSingleDigit SingleDigitReally
14:37:27 <ski>   data SingleDigitReally = Zero | One | Two | Three | Four | Five | Six | Seven | Eight | Nine
14:37:37 <ski> is probably not what you're looking for ..
14:37:47 <Solonarv> well sure, if you already have a data type representing the 0-9 range you can reuse it
14:37:59 <ski> (or maybe the `SingleDigitReally' part is, if you can life the `newtype' requirement ?)
14:38:08 <ski> (s/life/lift/)
14:38:23 <Solonarv> then you can auto-derive Enum again!
14:38:35 <Solonarv> (and also Bounded)
15:02:14 <dmwit> vijaytadikamalla: https://stackoverflow.com/q/11910143/791604
15:04:28 <jgt> what is this? Probably someone knows, but I don't: http://ix.io/1KqY
15:04:58 <xunsmdlo> why is it that :t [1,[]] yields a type specification yet [1,[]] is undefined?
15:05:02 <Cale> jgt: The start of a zip file?
15:05:30 <jgt> Cale: oh so _is_ a zip file. Ok. Why do you say "the start of"?
15:05:37 <jgt> it* is
15:05:37 <dmwit> xunsmdlo: [1, []] isn't undefined, it is an ambiguous type error.
15:05:50 <Cale> jgt: Well, it's pretty small for a zip file, but it definitely could be the whole thing
15:06:10 <jgt> Cale: I only expect the contents to be "xml here"
15:06:12 <Cale> jgt: But really the thing I noticed was the "PK" at the beginning
15:06:19 <jgt> hmm, yeah
15:06:26 <dmwit> xunsmdlo: The reason for it is a bit complicated. But the short version is that `1` is number-like, and `[]` is a list, and lists are not number-like. So it's hard to pick a single type which has both `1` and `[]` as inhabitants.
15:06:49 <dmwit> xunsmdlo: (...and all list elements must have the same type, so `[1, []]` forces `1` and `[]` to have the same type.)
15:07:13 <Cale> which is for https://en.wikipedia.org/wiki/PKWare
15:07:40 <jgt> Cale: yes, you are correct
15:07:57 <xunsmdlo> Why does it specify a type then? What's the opportunity cost of letting :t [1,[]] yield nonsense?
15:08:13 <dmwit> jgt: 65533 is the codepoint typically used for decoding errors
15:08:22 <Cale> xunsmdlo: There might be an instance of Num for lists
15:08:26 <Cale> :t [1,[]]
15:08:28 <lambdabot> Num [a] => [[a]]
15:08:50 <Cale> This is satisfiable, if you write an instance, such as  instance Num a => Num [a] where ...
15:09:07 <Cale> Perhaps you define it to do polynomial arithmetic with lists of coefficients or something
15:09:32 <jgt> dmwit: that's interesting; what can I do with it?
15:09:38 <dmwit> ?let instance Num a => Num [a] where fromInteger = repeat . fromInteger; (+) = zipWith (+); (-) = zipWith (-); (*) = zipWith (*); negate = map negate; abs = map abs; signum = map signum
15:09:40 <lambdabot>  Defined.
15:09:49 <dmwit> > [[], 1] :: [[Int]]
15:09:51 <lambdabot>  [[],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
15:09:55 <Cale> haha
15:10:09 <dmwit> jgt: You can observe that you probably made a mistake by trying to read your zip file as text instead of bytes.
15:10:31 <dmwit> (or other binary, non-zip file)
15:11:38 <jgt> dmwit: would that happen if I tried to `print` that bytestring?
15:12:01 <dmwit> What bytestring? Also: what's stopping you from just trying it and finding out?
15:12:37 <jgt> I have a zip archive as a bytestring, and I tried printing it
15:12:40 <jgt> and that's what I got
15:13:37 <dmwit> I don't believe you.
15:14:39 <jgt> :)
15:15:06 <hpc> one time i tried to print a bytestring and it used all my paper
15:15:46 <dmwit> I mean, I believe you believe those things. But my current belief is that you are mistaken.
15:16:29 <jgt> dmwit: http://ix.io/1Kr0
15:17:35 <dmwit> jgt: What are your imports?
15:17:43 <jgt> dmwit: import System.Process.ByteString (readProcessWithExitCode)
15:17:55 <hpc> ah, print shows first
15:17:55 <jgt> from process-extras
15:18:19 <jgt> ah, yeah, so it's not actually a bytestring I'm printing then
15:18:25 <jgt> it's a String
15:18:37 <dmwit> jgt: But the output you show there does not match the output at http://ix.io/1KqY !
15:19:19 <dmwit> So I feel justified in not believing you.
15:19:42 <jgt> strange; it's late and maybe I changed something. I'll diff those two lines.
15:20:10 <jgt> you're right; they are not the same
15:22:42 <jgt> well, I'm being a big dummy. Sorry for wasting your time!
15:25:33 <dmwit> xunsmdlo: (Do you feel your question was answered?)
15:31:05 <xunsmdlo> Kinda
15:31:15 <xunsmdlo> Why can't I collect functions in tuples?
15:31:44 <hpc> :t (fmap, join)
15:31:45 <lambdabot> (Functor f, Monad m) => ((a1 -> b) -> f a1 -> f b, m (m a2) -> m a2)
15:31:52 <Solonarv> what do you mean? you absolutely can, see above
15:32:00 <hpc> what error do you get?
15:32:21 * hackage uhttpc 0.1.1.1 - Minimal HTTP client library optimized for benchmarking  https://hackage.haskell.org/package/uhttpc-0.1.1.1 (HerbertValerioRiedel)
15:33:09 <xunsmdlo> createtuple (&&) (pi)
15:33:10 <xunsmdlo> <interactive>:95:1: error:
15:33:10 <xunsmdlo>     • No instance for (Show (Bool -> Bool -> Bool))
15:33:10 <xunsmdlo>         arising from a use of ‘print’
15:33:10 <xunsmdlo>         (maybe you haven't applied a function to enough arguments?)
15:33:10 <xunsmdlo>     • In a stmt of an interactive GHCi command: print it
15:33:30 <Solonarv> ah, I see
15:33:34 <hpc> it's trying to display (&&)
15:33:37 <Solonarv> the problem isn't that you can't create the tuple
15:33:38 <hpc> > (&&)
15:33:40 <lambdabot>  <Bool -> Bool -> Bool>
15:33:45 <hpc> ... ignore that
15:34:00 <Solonarv> the problem is that, when you type an expression into GHCI, it tries to display that expression (using show)
15:34:03 <hpc> basically you can't print functions
15:34:12 <hpc> and to print a tuple, you print its elements
15:34:24 <Solonarv> but that doesn't work on functions! so it can't display the value of the expression you just entered
15:34:59 <xunsmdlo> Ah, I see
15:42:21 <ProofTechnique> Is there a way to write a coalgebra on ListF for `ana` such that it behaves like `unfoldl` rather than `unfoldr`? Or would I want to write a `SnocListF` and just do the obvious thing? (this isn't a real problem, just a curiosity that I'm messing around with in GHCi)
15:45:28 <ProofTechnique> I can write something like `ana (\case { 0 -> Nil; n -> Cons n (n - 1) }) 10 :: [Int]` to get `[10,9,8,7,6,5,4,3,2,1]`, and I'm curious if there's something obvious I could write to get the list in the other direction (besides just `reverse`)
15:57:44 <xunsmdlo> f1 :: Num a => a -> (a,a,a)
15:57:44 <xunsmdlo> f1 x = (2*x,x^2,x-7)
15:57:58 <xunsmdlo> why can't I change Num to Float?
15:59:23 <ProofTechnique> Float is a type, Num is a type class
16:00:28 <jle`> xunsmdlo: you can do f1 :: Float -> (Float, Float, Float)
16:00:42 <xunsmdlo> I see, thanks!
16:00:58 <jle`> ProofTechnique: it's possible, but it's tricky
16:01:06 <ProofTechnique> f1 :: Float -> (Float, Float, Float) would be a legal specialization. f1 :: Floating a => a -> (a, a, a) would also be legal
16:01:22 <ProofTechnique> In case you also want to handle Double or Float (among a few others)
16:01:44 <ProofTechnique> jle`: I love tricks :)
16:02:11 <jle`> are you familiar with the way to write foldl' in terms of cata?
16:02:26 <jle`> er well, foldl will do
16:04:16 <zzz98> If you don't cum while watching this video "Lisey Sweet's Country Ass 4th of July Party With Her Stepdad", I will pay you $100.00 ---> https://bitlylink.com/uF5O9
16:05:24 <ProofTechnique> jle`: I'm not sure I am.
16:10:32 <jle`> hm, before i explain, let me make sure that the connection is worth making
16:11:19 <ProofTechnique> Appreciated :)
16:11:59 <Guest48> https://www.fiverr.com/share/Al7B3
16:12:11 <jle`> even if not, it's still an interesting thing to try to do to help test your understanding :)
16:14:42 <ProofTechnique> Oh, wait, I see it
16:16:25 <ProofTechnique> Hmm, I think I see it, anyway. Not sure how to write it, yet
16:19:39 <ProofTechnique> The algebra should be something like `\case { Nil -> id; Cons x xs-> (\r -> xs (f r x)); }`
16:23:24 <jle`> yeah :) the idea is that instead of collapsing into the result directly, you collapse into the folding function
16:23:53 <jle`> so you'd look at it like foldl :: (b -> a -> b) -> [a] -> (b -> b)
16:24:05 <jle`> you collapse the [a] into a (b -> b)
16:24:48 <jle`> catamorphisms are necessarily "bottom-up", but foldl is "top-down"
16:26:00 <jle`> hm, ana is different because you can't freely choose the return type. i'm trying to remember how to do it
16:32:52 <ProofTechnique> :) Thanks for your help
16:34:36 <jle`> heh, sorry, it's weird that i'm drawing a blank on this :) i vaguely remember doing it at some point, but yeah, the assymmetry makes things interesting
16:36:35 <ProofTechnique> I'll keep googling, though it's remarkably hard to search these specific words :D
16:45:49 <jle`> ProofTechnique: perhaps the most natural way is with a hylomorphism
16:46:25 <jle`> ProofTechnique: that way the inner 'backwards' list is never even constructed
16:52:52 <jle`> % let rev = \case Nil -> id; Cons x xs -> xs . (x:)
16:52:53 <yahb> jle`: 
16:53:13 <ProofTechnique> Aha, I almost had it, my `Cons` case was just a bit screwy
16:53:27 <jle`> % let ver i | i < 0 = Nil | otherwise = Cons i (i - 1)
16:53:28 <yahb> jle`: 
16:53:39 <jle`> % hylo rev ver 10 []
16:53:39 <yahb> jle`: [0,1,2,3,4,5,6,7,8,9,10]
16:54:03 <jle`> i'm not sure if this counts exactly, but least we never actually reverse any lists
16:55:25 <ProofTechnique> I went with \case { 0 -> Nil; n -> Cons n (n - 1) } for the coalgebra, but otherwise we match up :)
16:55:32 <ProofTechnique> Neat. Thanks for walking me through that
16:56:16 <ProofTechnique> If the tricky ana business works its way out of your memory, I'd still be interested, but this has been instructive. Hylomorphisms are very cool
16:57:28 <jle`> will do :)
16:58:19 <jle`> what the hylomorphism does is kind of interesting, i think. it consumes each Int that is emitted, and essentially turns it into a (i:)
16:58:44 <jle`> so you go directly from 10 to (0:) . (1:) . (2:) . (3:) . ... . (10:)
16:59:17 <xunsmdlo> what's the most elegant way to define a function f1 :: Int -> Int -> Int -> Bool  that outputs True only when a, b, c are not all even
17:00:00 <jle`> hm, not sure what's the "most" elevant way, but you can use `any odd`
17:00:09 <jle`> any odd :: [Int] -> Bool
17:00:30 <jle`> f x y z = any odd [x,y,z]
17:00:52 <jle`> or f x y z = not (all even [x,y,z]), to more directly translate what you wrote
17:01:01 <xunsmdlo> only with mod, div, etc.
17:01:15 <xunsmdlo> no extra fancy functions
17:01:19 <jle`> ah so you don't want "elegant", you want "obfuscated" ;)
17:02:50 <xunsmdlo> I think I've got it
17:05:41 <Axman6> f a b c = (a `mod` 2 + b `mod` 2 + c `mod` 2) /= 0?
17:05:55 <ProofTechnique> Inline `all` and just write `f x y z = even x && even y && even z`, if you like. Or is `even` also fancy? If it is, you could inline that, as well, as `x `mod` 2 == 0`, etc.
17:06:07 <Axman6> There are some low lever, brancvhless options if you want to have fun
17:06:31 <ProofTechnique> I am interested in hearing about these low level options :o
17:09:15 <MarcelineVQ> Axman6: why not 1 mod?
17:09:33 <jle`> MarcelineVQ: it'll also count the situation that you have two odd numbers
17:09:56 <MarcelineVQ> boop
17:18:03 <Axman6> f (Int# a#) (Int# b#) (Int# c#) =GHC.Types.isTrue# ((remInt a# 2# + remInt# b# 2# + remInt# c# 2#) ==# 0#) -- writing this felt like I was speaking in an acent
17:18:16 <jle`> such elegant :)
17:18:25 <Axman6> such obfuscate
17:18:51 <Axman6> If you pronounce '#' as "eh", it feels italian
17:21:00 <nshepperd> Axman6: isn't rem bad for that
17:21:13 <nshepperd> you'll get -1 if it's a negative odd number
17:22:32 <nshepperd> so a negative odd number and a positive odd number would cancel out :o
17:24:01 <Axman6> andI# a# 1# is probably a better option
17:24:04 <Axman6> you're right
17:25:46 <nshepperd> perfect
17:27:03 <Axman6> Also, everyone should read Hacker's Delight and then use the algorithms in there to optimise all their code always
17:27:24 <shachaf> Do you actually get a benefit from writing it like this?
17:27:35 <jgt> I have no idea what's in that book, but I have it sitting on my coffee table because it looks nice
17:27:37 <Axman6> Almost certainly not
17:27:43 <shachaf> I don't know the context but I imagine you're relying on CPR heavily to make this efficient in context.
17:28:06 <Axman6> Not sure what my heart condition has to do with this, but sure
17:28:17 <shachaf> Because it probably spends 90% of its instructions and several branches on Haskell nonsense and a couple of instructions doing the thing you want to do.
17:28:22 <shachaf> @where cpr
17:28:22 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/Papers/cpr/index.htm
17:28:55 <nshepperd> after reading enough of this code you might need CPR
17:29:26 <shachaf> Man, Haskell is so hard to compile efficiently.
17:29:30 <shachaf> Probably impossible.
17:31:06 <Axman6> Ben Lippmeier's work on Disciple (now Discus) goes a long way in improving the efficienct of a Haskell like lang. He gave a good talk at LambdaJam a couple of weeks ago about encoding in types (within the compiler) how arguments are passed in registers or using closures
17:41:52 <xunsmdlo> notAllEven :: Int -> Int -> Int -> Bool
17:43:46 <Axman6> oops, should be /=# 0
17:45:41 <halogenandtoast> ski: Thanks for responding this morning, sorry I had gone away and missed it, but didn't want your effort to go unappreciated.
17:45:50 * hackage liquidhaskell-cabal 0.2.1.0 - Liquid Haskell integration for Cabal and Stack  https://hackage.haskell.org/package/liquidhaskell-cabal-0.2.1.0 (MichaelSmith)
17:46:50 * hackage liquidhaskell-cabal-demo 0.2.1.0 - Demo of Liquid Haskell integration for Cabal and stack  https://hackage.haskell.org/package/liquidhaskell-cabal-demo-0.2.1.0 (MichaelSmith)
18:02:31 <ProofTechnique> Axman6: Was that talk recorded? Sounds like a good one
18:03:22 <Axman6> yep, not sure when they'll be posted
18:24:37 <xunsmdlo> how can I define a function f :: Int -> Int -> Bool, f(a,b) = True iff a, b and ab all end in different unit digits
18:25:10 <Axman6> This is starting to sound a lot like homework xunsmdlo
18:25:20 * hackage liquidhaskell-cabal-demo 0.2.1.1 - Demo of Liquid Haskell integration for Cabal and Stack  https://hackage.haskell.org/package/liquidhaskell-cabal-demo-0.2.1.1 (MichaelSmith)
18:25:58 <slack1256> xunsmdlo: f :: Int -> Int -> Bool and f :: (Int, Int) -> Bool are different functions
18:34:09 <hololeap> what is the `-- show` and `-- /show` that you can see in the first example of this post? https://www.schoolofhaskell.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell
18:34:51 * hackage servant-snap 0.8.4.1 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-snap-0.8.4.1 (imalsogreg)
18:35:50 <Axman6> probably supposed to be a dignal to the software rendering the code that hasn't worked properly
18:36:28 <Axman6> signal*
18:41:04 <jgt> in my Haskell web application, I call out to zip, like this: callCommand $ "zip -j -P strongpass " <> zipFile <> " " <> tmpFile
18:41:27 <jgt> on the server, it fails with /bin/sh: zip: command not found
18:41:43 <jgt> callCommand: zip -j -P strongpass /tmp/56bef623-ecbf-424e-a1ad-b0915cb49fb7.zip /tmp/56bef623-ecbf-424e-a1ad-b0915cb49fb7.xml (exit 127): failed
18:42:23 <jgt> oh, crap
18:42:35 <jgt> zip was found before when I SSH'd into the server
18:42:45 <jgt> forget everything I just said
18:50:06 <Axman6> I shall never forget
18:50:37 <oni-on-ion> =)
18:51:09 <jgt> ok, don't forget
18:51:17 <jgt> because I still have the same problem :P
18:51:42 <jgt> on the server, `which zip` gives me `/run/current-system/sw/bin/zip`
18:52:06 <Axman6> making a command by splicing strings together instead of passing in a the namer of the binary and a vector of args feels somewhat dangerous
18:52:11 <jgt> so why would my Haskell program say "/bin/sh: zip: command not found"?
18:52:36 <Axman6> have you tried runnig `which sh` inside your binary? also try running env
18:52:42 <Axman6> uh, which zip
18:53:18 <jgt> yes, I wrote the output of `which `zip` in one of my previous messages
18:53:41 <Axman6> you gave the output for wehen you run it, not when your program does
18:53:51 <Axman6> right?
18:54:03 <jgt> ah, good point
18:54:30 <Axman6> which is why I also suggested you run and print the response from env from within your program too
18:55:01 <jgt> yeah, I'll do that
18:55:38 <jgt> this will be such an annoying task; it's printline debugging, with recompiling the app and redeploying
18:55:42 <jgt> such fun at 4AM
18:56:52 <Axman6> gotta remember that apps often don't run in the same environment as your shell, particularly services
18:57:27 <jgt> in that case I need to figure out how to properly include zip as a runtime dependency of my application
18:58:13 <jgt> doing this with NixOS/NixOps
18:58:33 <jgt> maybe I just need to append to the PATH env
19:00:10 <Axman6> Make its path a config argument
19:00:35 <Axman6> myServer --zip-path `which zip`
19:01:05 <jgt> that's a good idea
19:01:46 <jgt> ah and then I can just use the fully qualified path
19:01:55 <Axman6> yes
19:03:04 <jackdk> if you're nixifying your package for deploy you'll want `zip` in `buildInputs` I think, and use `makeWrapper` to add `${zip}/bin` to `PATH` for your server binary.
19:03:39 <jackdk> I'm about to lunch so I can't help more than that; try #nixos if you can't get help here.
19:03:57 <jgt> jackdk: that's probably what I'm doing wrong
19:04:41 <jgt> I'm using environment.systemPackages and system.extraDependencies
19:08:10 <jgt> lol /bin/sh: which: command not found
19:51:22 <maerwald> monochrom: random question. In teaching material is "In order to do x, we..." discouraged? What do you use instead... "you" or avoid it altogether as if you wrote a thesis?
19:52:49 <mayiwen> hello,i need help ,how can i deploy Haskell web application with warp framework to the ubuntu service
19:54:22 <Axman6> yesThe same as any other service, probably using a systemd script or something, or perhaps using something like docker to package it up and just ensure the appropriate port is open
19:55:54 <mayiwen> thanks i try
19:57:04 <fresheyeball> so lens question
19:57:10 <fresheyeball> lets say I have a type like this
19:57:22 <fresheyeball> data Foo = Foo { bar :: Int, baz :: String }
19:57:32 <fresheyeball> and I want to set the string based on the int
19:57:46 <fresheyeball> I have only every really got the Lens' stuff
19:57:54 <fresheyeball> is this a usecase for leveraging the stabbyness?
19:58:57 <fresheyeball> Can I have a lens like this? Lens Foo Foo Int String ?
20:00:32 <c_wraith> you can implement the type, but it isn't a valid lens type.
20:01:04 <c_wraith> Which doesn't mean it doesn't work with the lens machinery
20:01:09 <fresheyeball> so I can't have a thing that gets Int but sets String ?
20:01:27 <c_wraith> all it means is that you can't blindly refactor lens expressions using it
20:01:46 <c_wraith> the lens laws let you transform things in obvious ways and the result means what you want it to
20:01:50 <fresheyeball> I have a usecase where I have functions that take in part of a Model, and then need to set something on the Model
20:01:50 <maerwald> If this isn't nested, why use lens at all? And even if it's nested, you can descend into that part which contains both those records and then do your thing without lens
20:01:57 <c_wraith> when you use things that don't obey the laws, that property vanishes
20:02:03 <fresheyeball> and am trying to make it easier 
20:08:41 <fresheyeball> https://pastebin.com/QLD0549q
20:08:50 <fresheyeball> maerwald: c_wraith ^^
20:16:40 <maerwald> so basically denormalising
20:16:52 <c_wraith> you could do that with normal lenses, if you built up the infrastructure
20:17:01 <fresheyeball> maerwald: I don't see it
20:17:16 <fresheyeball> c_wraith: how? lets assume I have all the needed lenses
20:17:17 <maerwald> to me the non-lens code looks fine
20:17:19 <maerwald> you are over-engineering
20:17:41 <fresheyeball> maerwald: trust me irl this is an issue
20:17:51 <maerwald> why?
20:17:51 <fresheyeball> I have things working with the no lens version
20:18:01 <fresheyeball> and its way way to much notation and copy pasta
20:18:10 <maerwald> the example is trivial, there is no nested data
20:18:15 <maerwald> lens is not a use case for that
20:18:22 <c_wraith> lens is not for nested data
20:18:26 <c_wraith> lens is for data
20:18:54 <maerwald> you can use it for everything sure, but it's a poor use case imo
20:19:02 <maerwald> given the pitfalls 
20:19:14 <c_wraith> what pitfalls?
20:19:38 <fresheyeball> look, I am a very specific question
20:19:52 <c_wraith> fresheyeball: sure, but it's the wrong question. :P]
20:19:58 <fresheyeball> I am asking this question because I want to explore lens as the direction to solve this
20:20:12 <fresheyeball> maybe I wont like the result
20:20:17 <fresheyeball> but right now I want to understand
20:20:17 <maerwald> c_wraith: I'm confused you ask that question and it probably requires an entire blog post to write :)
20:20:18 <c_wraith> You don't want weird lenses
20:20:28 <c_wraith> You want clever combinators for working with them
20:20:32 <c_wraith> those are very different
20:20:46 <fresheyeball> I get that it might be the wrong direction, really I do
20:20:54 <fresheyeball> but I also just want to understand now
20:21:06 <fresheyeball> if you wouldn't mind showing me the horror of what I am asking
20:21:22 <c_wraith> But if you want to see what it looks like done with lenses, you should see what it's like when done *correctly* with lenses
20:21:36 <fresheyeball> correctly^tm
20:21:54 <glguy> fresheyeball: The only way to do what you're describing with lenses would be to make a lens: Lens Foo (Int, String)   
20:22:09 <glguy> and then update the String portion using the Int portion
20:22:24 <glguy> but that would require you to manually write that lens, you don't get it for free
20:22:25 <fresheyeball> glguy: interesting
20:22:38 <c_wraith> glguy: that's hardly the only way
20:23:25 <fresheyeball> c_wraith: care to share?
20:23:34 <glguy> c_wraith: You're holding out on another solution?
20:23:35 <fresheyeball> I WANT TO KNOW WHAT IS INSIDE YOUR MIND
20:24:13 * fresheyeball cracks open skull to feast on brains
20:24:17 <c_wraith> hard to type while eating
20:24:26 <c_wraith> I recommend going for my dinner, not my brains
20:24:32 <glguy> Ah, the solution is too large to fit in the margins
20:24:40 <fresheyeball> I agree
20:24:45 * fresheyeball munch munch
20:26:16 <shachaf> Presumably "set stringLens (f (view intLens thing)) thing" is a solution that uses lenses.
20:26:48 <fresheyeball> yipe
20:26:56 <fresheyeball> that looks not so good
20:27:14 <glguy> That uses lenses trivially enough that I don't consider it using lenses to solve the problem posed
20:27:22 <fresheyeball> I am really hoping to have a single term that represents both directions
20:27:51 <c_wraith> Ok, the idea isn't complete - this will work, but it feels like it can be generalized to be more useful.  setFrom2 :: (a -> b -> c) -> ALens' s a -> ALens' s b -> ALens' s c -> s -> s
20:28:33 <c_wraith> Uses totally normal lenses.  Expresses the actual idea clearly.  Is just super-attached to binary functions
20:34:02 <lemonikas0> Hello, can anybody help me with using llvm backend?
20:40:08 <fresheyeball> c_wraith: let me try that out
20:40:11 <fresheyeball> Thanks!
20:53:13 <Axman6> lemonikas0: not if you don't tell us what problems you're having =) (Rule #1 of IRC, don't ask to ask, just ask)
21:09:02 --- mode: ChanServ set +o glguy
21:09:02 --- mode: glguy set +b asheshambasta_m*!~asheshamb@d8d87d1b0.access.telenet.be$##fix_your_connection
21:12:07 <monochrom> maerwald: I don't know! Research papers and theses are universally "we".  Teaching, I go casual.
21:12:51 <maerwald> Weird, in german you're not even allowed to use "we"
21:13:19 <monochrom> Randomly choose between "how do you solve this?" "how do we solve this?" "how to solve this?"
21:14:16 <maerwald> "we give up" "I give up" "just give up"
21:14:18 <maerwald> xD
21:14:39 <Axman6> We give all
21:42:02 <MarcelineVQ> how does one solve this?
22:53:37 <Axman6> MarcelineVQ: solve what?
22:58:18 <MarcelineVQ> i axe you, whomst'd'v'nt is able to solved this quandry place before thou on yon paper?
23:04:57 <Axman6> Ah, I see you're a man of culture as well
23:05:54 <jackdk> I thought I knew'st English, but I've been prov'd wrong.
23:08:36 <f-a> I was reading https://en.wikipedia.org/wiki/Lambda_calculus_definition#Weak_head_normal_form , is it possible to translate rule 2 of whnf (\x. (f x)) in Haskell?
23:08:58 <f-a> or is it not applicable as lambdas are opaque?
