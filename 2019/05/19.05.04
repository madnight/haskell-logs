00:39:11 <fuzzy-id> i'm currently copying a heterogeneous list example. it starts with 'data HList (ts :: [Type]) where'. but using this ghc yells 'Not in scope: type constructor or class ‘Type’' at me. replacing 'Type' with '*' works somehow.
00:40:10 <fuzzy-id> i hade a similar question some time ago where it was said that '*' is replacable by 'Type' in recent ghc versions.
00:40:17 <fuzzy-id> so why doesn't it work in this case?
00:42:31 <jle`> fuzzy-id: "Not in scope: ..." etc. usually means that the thing you are trying to use is not yet imported
00:42:40 <jle`> did you import Type ?
00:42:48 <jle`> er, i mean, did you import a module that exports Type?
00:43:17 <jle`> the error isn't saying that you can't replace * with Type, just that Type is not yet imported :)
00:43:36 <jle`> it's the same thing that happens if you, say, use `Text` as a type if you don't import Data.Text or some other module that exports the Text type
00:43:45 <jle`> or if you use 'fromMaybe' without importing Data.Maybe, etc.
00:45:24 <fuzzy-id> ok, that makes sense then
00:46:03 <MarcelineVQ> people tend to forget to tell you to import Data.Kind when using Type, though eventually you probably won't have to
00:46:40 <fuzzy-id> MarcelineVQ: yep, that solved it
00:52:39 <jle`> a good example of a 'step 1, read the error message' kind of problem :)
01:43:42 <Squarism> Anyone know how to deal with stack using only cabal on $PATH regardless of lts version? Ive still got projects that rely on cabal 1.x in parallell to 2.x dependent projects
01:50:40 <kayzen> https://africageographic.com/blog/lion-mass-slaughter-house/
01:50:43 <kayzen> sanction south africa
01:55:54 <gonz_> What's the catch with STM? Could you just stick a TVar in a ReaderT and be off to the races, guaranteed no data races in different threads along the way?
01:57:35 <gonz_> It seems like run-time magic so I'm mostly wondering what I need to be careful with here
02:21:42 * luftmensch[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/YlULnveVEwyUoPcgSylqXTKn >
02:22:08 <luftmensch[m]> Not Haskell per se but interesting wrt software licensing
02:59:23 <ScriptRunner> Hi everyone, does anyone know how you get invited to the #NotHaskell channel?
05:46:57 <tsahyt> I just stumbled across this haddock page. why is it formatted/typeset differently? https://hackage.haskell.org/package/sop-core-0.4.0.0/docs/Data-SOP.html
05:47:02 <tsahyt> it's not particularly new either from what I can tell
06:05:42 <infinisil> tsahyt: Hmm, can't package authors upload their own generated docs?
06:05:52 <infinisil> I thought so anyways
06:06:28 <tsahyt> hm, maybe that's the reason. by now I've figured out that the theme is apparently NewOcean and got accepted into haddock per PR
06:06:39 <tsahyt> I quite like it
06:07:25 <tsahyt> there are build logs available for the docs though. I'm not sure whether they exist when the author uploads their own doc
06:14:37 <__monty__> tsahyt: I think haddock renamed that theme since btw.
06:15:10 <__monty__> tsahyt: The reason there's still old theme docs around is not all docs are rebuilt by hackage.
06:15:31 <tsahyt> __monty__: are new docs being built with the new theme automatically?
06:15:38 <__monty__> Yeah.
06:15:41 <tsahyt> I've uploaded a small library a week or so ago and it's been built with the same theme
06:15:44 <tsahyt> the old one
06:16:26 <__monty__> Hmm, the folks over in #hackage'll probably know why.
06:16:40 <__monty__> gtg
06:25:24 <phadej> sop-core docs were manually uploded, hackage docbuilder uses old theme, see eg recently uploded http://hackage.haskell.org/package/tinylog-0.15.0
06:27:05 <tsahyt> okay. thanks for the clarification!
07:54:41 <zincy> Not sure what is going wrong with my use of Reader. But my interpreter doesn't seem to be binding variables when there I use. Let statement 
07:54:43 <zincy> https://github.com/therewillbecode/functional-interpreter/blob/reader/src/Interpreter.hs
07:56:34 <Solonarv_> zincy: 'local' doesn't change the environment for the rest of the computation, but for a specific sub-computation
07:56:45 <Solonarv_> (which is the second argument to 'local')
07:57:07 <Solonarv_> if you have: do foo; local f inner; bar
07:57:07 <Solonarv_> then only 'inner' sees the modified environment
07:58:14 <Solonarv_> so bindVar actually doesn't do anything to the environment
07:59:54 <zincy> Oh thanks
08:00:12 <zincy>   `bindVar varName val; eval exp`
08:00:31 <Solonarv> yeah, that doesn't do anything
08:00:41 <zincy> The second computation should be passed perhaps as an argument to bindVar
08:00:48 <Solonarv> exactly
08:01:52 <zincy> Hmm what should I call the argument
08:02:06 <zincy> innerScope?
08:02:28 <Solonarv> just call it 'inner'
08:02:58 <Solonarv> or avoid naming it at all, since you can just write 'bindVar name val = local (Map.insert ...)'
08:04:01 <zincy> Thanks!
08:04:18 <zincy> I feel like the VarBinding return value in the monad is pointless too
08:04:30 <zincy> Maybe just make it the actual value which is bound so it composes
08:05:21 <zincy> I wonder how I would add function composition to my langauge
08:05:40 <zincy> So I could write curried functions
08:08:12 <jusss> fmap :: (a->b) -> (e->a) -> (e->b)
08:08:18 <jusss> fmap (+1) (+1)
08:08:34 <Solonarv> well, you don't actually need to add anything special to the language
08:08:35 <jusss> functor (->) e is '+' or (+1) ?
08:09:07 <zincy> (+1)
08:10:05 <jusss> zincy: and this fmap (+1) (+1) is a function after currying? it doesn't have a, right?
08:10:06 <Solonarv> Lambda "f" (Lambda "g" (Lambda "x" (FunCall (Variable "f") (FunCall (Variable "g") (Variable "x))))
08:10:28 <Solonarv> zincy: ^-  there's your function composition
08:10:37 <zincy> Cool!
08:11:12 <Solonarv> (this is just the usual '\f g x -> f (g x)' definition written in your AST)
08:11:12 <zincy> juss: right
08:11:44 <jusss> I thought that \f g x -> g(f x)
08:12:26 <Solonarv> while that's a perfectly sensible definition, it's not the usual one
08:12:29 <Solonarv> @src .
08:12:29 <lambdabot> (f . g) x = f (g x)
08:13:22 <jusss> Solonarv: if a->b is f, and g is the functor, fmap f (g x) = g(f x) ?
08:13:39 <Solonarv> no, the types don't line up
08:13:53 <Solonarv> % :t fmap @((->) _)
08:13:53 <Solonarv> % :t (.)
08:13:53 <yahb> Solonarv: (a -> b) -> (w -> a) -> w -> b
08:13:54 <yahb> Solonarv: (b -> c) -> (a -> b) -> a -> c
08:14:20 <Solonarv> as you can see those are the same type, just with different names for the type variables
08:15:17 <zincy> data Value = NumVal Int | FunVal (Exp -> ReaderT Scope (Except LangErr) Value)
08:15:20 <jusss> Solonarv: wait a sec, so if e-> is functor g, and e->b is not (g b) ?
08:15:28 <zincy> How would I make that type monad agnostic
08:15:31 <zincy> free monads?
08:16:49 <Solonarv> you can just write something like: data Value m = NumVal Int | FunVal (Exp -> m (Value m))
08:17:17 <Solonarv> or keep your current definition, which is also fine
08:17:46 <Solonarv> though you might want to define a type synonym for your 'ReaderT Scope (Except LangErr)' stack, since you're using it a lot
08:24:17 <zincy> Solonarv: If we define a lambda ```(Lambda "plusOne" (Add (Variable "x") (Number 1)))``` 
08:24:34 <zincy> Compose our plusOnes twice to get a function which adds 2 to the argument.
08:24:34 <zincy> ```(FunCall "compose" (Variable "plusOne") ((FunCall "compose" (Variable "plusOne"))```
08:24:48 <zincy> Am I on the right track
08:24:52 <Solonarv> ...that's not right
08:25:18 <Solonarv> in Haskell syntax, you just wrote: (.) (+1) ((.) (+1))
08:25:47 <Solonarv> it's just (FunCall "compose" (Variable "plusOne") (Variable "plusOne"))
08:26:37 <zincy> How can the lambda take two params
08:26:48 <Solonarv> currying
08:27:00 <Solonarv> oh wait, I'm a dummy
08:27:48 <Solonarv> (FunCall (FunCall (Variable "compose") (Variable "plusOne")) (Variable "plusOne"))
08:28:06 <[exa]> zincy: Lambda is an actual pairing of variable and expression
08:28:28 <Solonarv> or using infix notation: ((Variable "compose" `FunCall` Variable "plusOne") `FunCall` Variable "plusOne")
08:28:56 <zincy> You are better than me at the language I wrote :P
08:29:21 <zincy> Well to be fair someone else gave me the grammar I am just implementing it
08:29:34 <[exa]> zincy: strongly recommend replacing the misleading "call" name with "apply", call belongs to spaces where call conventions make sense
08:29:55 <zincy> Good idea
08:33:16 <svipal> Hllo ! Could someone help me with MonadBaseControl ? having a hard time understanding liftBaseWith
08:33:23 <zincy> Writing interpreters in Haskell feels like cheating
08:35:32 <c_wraith> svipal: my usual approach is "don't bother understanding, just use things built on it." :)
08:35:53 <svipal> I definitely know the feeling but I want to understand it hahaha
08:37:04 <c_wraith> well, the basic idea of the class is that it does whatever the heck is necessary to unwrap and rewrap a monad transformer
08:37:34 <svipal> I want to write an implementation of it for my custom monad (which just has MonadState and MonadIO instances)
08:40:18 <svipal> https://pastebin.com/v9U8aPJi (lol at the haskell markdown)
08:45:48 <zincy> Solonarv: What am I doing wrong? https://pastebin.com/J0YLQcS2
08:46:29 <Solonarv> zincy: "plusTwo" /= "PlusTwo"
08:47:46 <zincy> Sorry not sure I follow
08:48:28 <[exa]> zincy: string comparison does not ignore case, so it doesn't find "plusTwo"
08:48:42 <[exa]> (or the other way)
08:50:18 <[exa]> zincy: btw for debugging it's nice to also include a list of available variable names in the error message; you can more easily see what's the context of the problem. Like: "unbound variable: x, available variables: y, z, w"
08:50:57 <zincy> Ah yes my eyesight failed me
08:51:01 <zincy> P versus p
08:52:38 <svipal> my brain is going to split
08:53:11 <zincy> exa: Thanks it is hard to debug when you cant see the bound variables
09:03:47 <Solonarv> zincy: if you want to look at my approach: https://gist.github.com/Solonarv/8525a61340edaad47908081381be6ff1
09:04:22 <zincy> Solonarv: Oh wow great.
09:04:26 <zincy> Will do!
09:05:34 <zincy> was getting "f" isnt a bound variable for the updated pastebin https://pastebin.com/NGupX6TC
09:05:58 <zincy> No doubt I will have questions about your approach :)
09:07:32 <stevenxl> Hi folks.
09:08:02 <Solonarv> stevenxl: hi!
09:08:06 <stevenxl> I have a custom monad which, part of the effects it has, is to log output. However, that functionality is nog working, and i can't figure out why
09:08:07 <stevenxl> https://gist.github.com/StevenXL/0aa216536c57dea745db980d78cf2934
09:08:37 <stevenxl> I think the relevant parts are the logOutput helper function, which I don't see anythign wrong with, and the instance of Monad for the Computation type constructor, which i also don't see anythign wrong with.
09:10:41 <monochrom> What is an example of "not working"?
09:12:21 <erisco> stevenxl, Computation can only set the String, not modify or read it, so you only get one log message, and it is the last one =\
09:14:32 <monochrom> No answer?
09:14:35 <svipal> I don't see you actually printing anything ? 
09:15:39 <svipal> oh sorry 
09:21:59 <svipal> stevenxl : is the result you get good ?
09:22:04 <svipal> besides the log
09:24:46 <Solonarv> zincy: I updated the gist a bit, just so you know
09:32:28 <zincy> Solonarv: thanks
09:34:11 <eruvarn> Hey
09:34:17 <eruvarn> I've got a really simple question
09:34:47 <eruvarn> I've been trying to make a simple fibonacci function in haskell
09:35:18 <eruvarn> f x = if x < 2 then x else f(x-1) + f(x-2)
09:35:45 <eruvarn> But that becomes really inefficient for x > 30 or so
09:35:57 <eruvarn> Is there a better way to do this in haskell?
09:37:27 <svipal> look up memoization
09:38:22 <svipal> basically you keep in memory the precedent results and you get quite a speed up
09:39:51 <svipal> this should interest you : https://wiki.haskell.org/Memoization
09:41:07 <eruvarn> Interesting
09:43:06 <garvis> eruvarn: one idea can be fib@(_:fib') = 1 : 1 : zipWith (+) fib fib'
09:47:22 <cocreature> eruvarn: do you know how to implement fibonacci using a loop in an imperative language?
09:47:31 <eruvarn> Yeah
09:48:10 <cocreature> memoization is a useful context in general but if your goal is to write a fast fibonacci, speeding up a dumb exponential implementation of fibonacci is probably a worse idea than just translating the loop
09:49:13 <eruvarn> How would I go about doing that?
09:49:33 <eruvarn> I'm quite inexperienced with Haskell
09:49:49 <merijn> eruvarn: garvis' example is much better already, since it's linear unlike the naive recursive one which is exponential
09:52:17 <cocreature> you can translate the standard loop into "fib n = go 0 0 1 where go m i j | m == n = i | otherwise = go (m + 1) j (i + j)"
09:52:20 <garvis> eruvarn: the code I wrote gives you an infinite list of all fibonacci numbers, then you can simply build your `f x` on top of it using `last` and `take n`
09:52:41 <Cale> I like this version:
09:52:51 <Cale> lucas a b = a : lucas b (a+b)
09:52:52 <cocreature> you can usually convert any loop into a recursive function that has the variables that are modified in the loop as parameters
09:52:58 <Cale> fibs = lucas 0 1
09:53:11 <eruvarn> Garvis' method worked great, but I struggle to understand exactly how it works
09:53:15 <cocreature> there are various cute solutions for fibonacci but those are much harder to generalize
09:53:47 <eruvarn> And how I would implement something similar myself
09:55:14 <cocreature> the 1:1 translation of loops into recursive functions often does not produce idiomatic code but it should at least give you a starting point that has similar performance characteristics
09:56:14 <garvis> eruvarn: my advice is to start reading as much code as possible to start understand more deeply the usage of a purely functional language. One book that was useful to me is "Learn You Haskell for Great Good!"
09:56:21 <Cale> eruvarn: The version that garvis wrote is a sort of folklore trick for this, it relies on the property that if you take a shifted copy of the Fibonacci sequence and add it with the original, you get another, yet more shifted copy of it.
09:57:12 <Cale> The version that I wrote via the Lucas sequences requires perhaps slightly less insight
09:57:49 <Cale> In case it's not clear, zipWith (+) will take two lists and add them elementwise
09:58:56 <Cale> So if we already had the Fibonacci sequence, fibs, and we did zipWith (+) fibs (tail fibs), we would end up with a Fibonacci sequence starting from the 3rd element of the list (or the 2th, depending on how you count)
09:59:36 <Cale> By giving the first couple of elements explicitly, we can turn this into a complete recursive definition of the list
10:00:31 <eruvarn> Okay, I think I got it
10:00:38 <Cale> Giving the first couple is enough to be able to determine the first element of zipWith (+) fibs (tail fibs) would be, and then that additional element is enough to determine the next, and so on
10:01:29 <eruvarn> zipWith (+) fib fib' adds every fib(n) to fib(n+1), right?
10:01:36 <Cale> yeah
10:01:54 <Cale> @let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
10:01:56 <lambdabot>  Defined.
10:02:04 <Cale> > zipWith (+) fibs (tail fibs)
10:02:06 <lambdabot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1771...
10:02:12 <Cale> > fibs
10:02:14 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
10:02:20 <Cale> > tail fibs
10:02:23 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
10:02:40 <eruvarn> That's really neat
10:02:50 <lavalike> it really is
10:05:25 <remexre> is there a better approach to extensible ASTs in Haskell than something like https://github.com/remexre/stahl/blob/haskell/src/Language/Stahl/Ast.hs#L105-L114 ?
10:06:22 <remexre> my main issue with this approach being the need for things like https://github.com/remexre/stahl/blob/haskell/src/Language/Stahl/Ast.hs#L188-L197
10:10:12 <stevenxl> svipal: sorry i was away from my comp
10:10:18 <stevenxl> yea the results are fine except for the log
10:10:28 <stevenxl> erisco: I don't know what you mean by `Computation` can only set, not modify or read;.
10:11:20 <lyxia> remexre: have you seen recursion-schemes and comp-data
10:12:23 <lyxia> remexre: and what's the problem with those lines in particular
10:12:25 <stevenxl> This seems to show logoutput working as expected https://usercontent.irccloud-cdn.com/file/5KW8cLkG/Screen%20Shot%202019-05-04%20at%2012.11.44%20PM.png
10:14:28 <remexre> lyxia: this is "inspired by" recursion-schemes, but I never "got" that; I haven't seen comp-data
10:15:30 <remexre> lyxia: and just the general annoyance of having to do things with these huge gross functions, I guess
10:18:40 <remexre> lyxia: huh, per the link being purple, I apparently have seen compdata, I just don't remember it
10:22:12 <erisco> stevenxl, I explained that really poorly. What I thought maybe you were after was writing the log to stdout for each message. I was trying to say that it just collects a single log message, and you can only retrieve it at the end of the computation to print it.
10:22:54 <stevenxl> erisco: I see. Yes, I was just wondering why the collection of the logs into a single log message at the end is not working
10:23:06 <stevenxl> it has something to do with replicateM_, but I can't figure it out.
10:24:35 <nshepperd> remexre: http://okmij.org/ftp/tagless-final/course/lecture.pdf was posted here recently, which directly relates to your problem
10:24:53 <svipal> stevenxl, I can't make your examples work
10:25:05 <rcat> how should I user cabal new-* to have the `:doc' command available in ghci?
10:25:16 <stevenxl> svipal: Let me put up a gist.
10:25:19 <svipal> wait
10:25:21 <svipal> I can
10:25:35 <svipal> but for some reason doesn't work with mapM
10:26:27 <stevenxl> svipal: Yea, check out this gist: https://lpaste.com/5JXXkZX19S
10:26:54 <merijn> rcat: You mean how to load a new-* project into ghci?
10:26:55 <stevenxl> The difference between `runComputation program stdGen 10` versus `runComputation (replicateM_ 10 program) stdGen 10`
10:26:59 <stevenxl> I don't understand.
10:27:32 <rcat> merijn: if I do `cabal new-repl' having compiled the project with `cabal new-build' :doc doesn't work
10:27:43 <rcat> i get something like haddock isn't avaible
10:27:59 <merijn> rcat: That seems mostly unrelated to new-build and more related to ghci and haddock?
10:28:06 <rcat> i tried with `cabal new-build --enable-documentation' but doesn't seem to work
10:28:07 <remexre> nshepperd: I've seen tagless-final before, but I didn't think it'd work out well for a multi-stage compiler, where you're introducing/lowering new constructs at each stage
10:28:17 <merijn> rcat: Which cabal-install version?
10:29:06 <rcat> merijn: cabal-install version 2.4.1.0
10:29:42 <merijn> rcat: Oh, wait, did you run new-repl with --enable-documentation too? :p
10:30:15 <nshepperd> remexre: oh. well, i don't know much about compilers, but it seems like it would at least make extensibility easy, since you just make a new typeclass for each extension
10:31:08 <rcat> merijn: i just tried, same problem "ghc: Can't find any documentation for Data.Vector" "This is probably because the module was compiled without '-haddock'"
10:31:30 <Squarism> ive noticed you can omit setting a field of a record and then get a runtime error if its accessed. Can you make the compiler fail if a record field is unset upon creation?
10:31:30 <remexre> nshepperd: this isn't compiler-specific, I guess, but writing the (ExprBase a, ExprFoo a, ExprBase b, ExprBar b) => a -> Either [Error] b function seems like it'd be annoying
10:31:32 <erisco> stevenxl, actually I am way wrong here, one can define 'listen', which copies the log to the output
10:31:37 <merijn> rcat: I recall at some point there were issues with building docs if you hadn't had them enabled from the start, but I dunno the details
10:31:59 <merijn> rcat: You can try asking in #hackage, although most people there tend to mostly be active during workdays :)
10:33:42 <remexre> nshepperd: I guess *a* solution is (ExprBase b, ExprBar b) => ExprFooInitial -> Either [Error] b :P
10:33:46 <stevenxl> erisco: I'll take a look at this in more detail and let you know.
10:34:12 <remexre> nshepperd: but then I've got initial encodings of everything again
10:34:23 <svipal> damn my monadic is reusty
10:35:22 <rcat> merijn: in any case thanks for the help! :)
10:35:51 <nshepperd> yeah you can make 'convert to an initial encoding' one of the instances of ExprBase etc
10:36:29 <nshepperd> remexre: you can also take apart a Foo by writing instances
10:37:09 <svipal> I wonder what would cause replicateM to act like that
10:37:15 <erisco> stevenxl, your Applicative instance does not match your Monad instance, is probably the issue
10:37:27 <erisco> stevenxl, just change to (<*>) = ap
10:37:45 <remexre> nshepperd: If I just care about turning the Foo "ctors" into Bar and Base "ctors"? how?
10:37:48 <nshepperd> instance ExprBar b => ExprFoo (ToBar (Either [Error] b))
10:37:52 <svipal> ap ?
10:38:03 <stevenxl> erisco: Oh shoot!
10:38:05 <stevenxl> Thank you so much.
10:38:08 <nshepperd> (where ToBar is newtype just to identify the instance)
10:38:17 <stevenxl> Yes I wanted to write it out longhand because I wanted to practice
10:38:20 <stevenxl> But yea I see it now
10:38:22 <remexre> nshepperd: Oh, hm
10:38:23 <stevenxl> I forgot to combine the logs
10:38:51 <svipal> nice eye
10:38:52 <stevenxl> And `replicateM_`'s signature is: `Applicative m => Int -> m a -> m ()`
10:39:07 <stevenxl> so it is using `<*>` rather than `>>=`. 
10:39:10 <stevenxl> Thank you erisco !
10:39:13 <nshepperd> i suppose probably instance (ExprBase b, ExprBar b) => ExprFoo (ToBar (Either [Error] b))
10:40:34 <svipal> Speaking of writing monadic instances by hand , I want to write liftBaseWith for MonadBaseControl on top of that monad : https://pastebin.com/v9U8aPJi
10:44:20 <cocreature> svipal: that looks like Game is equivalent to StateT GameEnv IO so you can look at the instance of StateT for inspiration
10:45:52 <svipal> Very nice pointer
10:46:00 <svipal> thanks cocreature
10:47:20 <cocreature> svipal: but if you want to keep your sanity, you might also want to consider not using MonadBaseControl :)
10:47:32 <svipal> I already lost it long ago..
10:47:48 <svipal> the reason I thought I needed it is because I want to use this module : 
10:47:50 <nshepperd> remexre: i also think that maybe having initial encodings of everything wouldn't be too bad if you have the typeclasses. instead of making them extensible you could keep them clean and have a different type for each compiler stage, and only use them on the left of ->
10:47:57 <svipal> http://hackage.haskell.org/package/lifted-async-0.10.0.4/docs/Control-Concurrent-Async-Lifted.html
10:48:07 <svipal> and use forConcurrently
10:48:13 <svipal> in particular
10:48:59 <remexre> nshepperd: but then what's the point of tagless final versus recursive functions on the initial encoding, other than saving typing the function name?
10:49:00 <nshepperd> with easy conversion with eliminator function fromFoo :: (ExprBase b, ExprFoo b) => ExprFooInitial -> b
10:50:17 <nshepperd> oh, but that still requires you to write out each case when you take it apart, so the 'instance (ExprBase b, ExprBar b) => ExprFoo (ToBar (Either [Error] b))' method is much better on that count
10:51:03 <svipal> unless there is an easier way for parallelism in a monadic context ?
10:51:57 <cocreature> svipal: the problem is that while MonadBaseControl allows you to get things like forkIO on "Game a" to typecheck, the semantics might not be what you want: You now have two separate states that involve independently
10:54:07 <remexre> nshepperd: I might play with this on paper for a bit, I still don't see the advantage tagless final is giving if I need to write out initial encodings anyway
10:54:29 <nshepperd> remexre: i guess the advantage is that when you're constructing an AST value with a Lam you don't need to ask whether that's Stage1.Lam or Stage2.Lam, or worry about parameterising the AST with some functor to express the stage
10:54:55 <svipal> I thought I'd play around it, but do I have alternatives ?
10:55:18 <nshepperd> you just use the 'lam' method and it's handled
10:55:48 <remexre> nshepperd: I do care about the concrete functor though, it's the one that contains all the constructs I have syntax for :P
10:56:46 <remexre> nshepperd: I guess to be fair, I could parse into a superset of what I can now
10:56:49 <nshepperd> yeah, and those constructs would have their own typeclass
10:57:46 <cocreature> svipal: stuff your state in an MVar/TVar and just work with IO directly
10:58:02 <cocreature> svipal: then your states will actually share the state which sounds like that’s probably more appropriate
10:58:18 <remexre> nshepperd: like I totally get how this would be nice for compiler-as-a-lib, but I don't see how it's better for compiler-as-an-app
10:59:59 <cocreature> svipal: there is MonadUnliftIO which is somewhat similar to MonadBaseControl but restricts the instances such that you can avoid accidentally forking or loosing state. However, that means that you can’t make instances for things like StateT (deliberately).
11:00:01 <nshepperd> I don't think you need initial encodings either
11:00:14 <nshepperd> unless you really want to use 'case'
11:00:18 <cocreature> MonadBaseControl on the other hand lets you make instances for a lot of stuff while ignoring the question of whether those instances are reasonable
11:00:37 <svipal> hahaha
11:23:05 <svipal> actually StateT only has a MonadTransControl instance actually
11:23:15 <svipal> getting tired
11:26:32 <cocreature> svipal: it definitely has a MonadBaseControl instance, look at the instance list in https://hackage.haskell.org/package/monad-control-1.0.2.3/docs/Control-Monad-Trans-Control.html#t:MonadBaseControl
11:28:55 <merijn> Honestly, monad-control gives me a freaking headache and I would avoid it at all cost, especially as beginner
11:29:51 <svipal> literal headache yep. I looked in the instance list - it's just that the instance declaration is made using defaultLiftBaseWith
11:30:41 <cocreature> the frustrating thing about monad-control is that if you do spend the time to understand it, it doesn’t become a nice and sane abstraction. you just start to understand why it’s a mess that should be avoided :)
11:32:39 <svipal> I think I actually know what you were talking about with because I had a lot of trouble with multiple states using my monad (using put in multiple places)
11:32:57 <svipal> when I wanted to try using less IORefs
11:34:37 <merijn> svipal: STRef? ;)
11:35:40 <cocreature> in the context of game state I would expect that you probably want to have all threads operate on the same state.
11:35:54 <cocreature> StateT is not going to give you that, no matter how much MonadBaseControl you throw at it
11:36:37 <svipal> besides putting stuff in MVars, is there something else ?..
11:36:50 <svipal> merijn  : wdym ?
11:37:08 <merijn> svipal: What are you using/needing IORef/MVar for?
11:37:15 <cocreature> why do you want something else? MVar/TVar is exactly how you handle shared state in Haskell
11:37:27 <svipal> I don't want something else, this is what I was going for
11:37:30 <svipal> just curious
11:38:01 <cocreature> in that case, no there’s not really anything else :)
11:38:47 <merijn> svipal: I didn't realise we were talking about concurrent state and games. If you have single threaded state STRef can be an alternative to IORef
11:40:04 <svipal> I see
11:43:52 <svipal> funny that the package that provides using MVars in any MonadIO Monad is mongodb
11:44:29 <merijn> svipal: I mean, you can just use liftIO together with MVar without that package...
11:47:28 <svipal> sure enough but grating. there's actually http://hackage.haskell.org/package/monadIO-0.11.1.0
12:08:18 <srid> TIL: `let x = (2 :: Natural) in x - 1` throws arithmetic underflow.  
12:10:10 <glguy> srid: Not for me
12:10:14 <glguy> How'd you test that?
12:10:25 <srid> glguy: Yea, I figured. It happens only in GHCJS
12:10:41 <srid> https://github.com/mrkkrp/pagination/issues/6
12:17:38 <aplainzetakind> Is there a good way to read a random line from a huge file without loading the entire thing into memory?
12:18:48 <Rembane> aplainzetakind: Do you know where the line starts?
12:19:04 <glguy> files aren't indexed by newlines, so you'd have to read through chunk by chunk counting line terminators
12:21:43 <geekosaur> proper way is read through by chunks indexing line terminators, then pick one from the resulting list; cheap but skewed way is to pick a random offset into the file and scan forward to the next line terminator, then read that line. (this is skewed by line lengths, and needs to backtrack if it happens to land in the final line)
12:22:25 <aplainzetakind> Rembane, glguy: I see. I wanted to generate a random number and read the corresponding line. Since I'll do it a lot of times I guess it's best to load the lines into an array first.
12:24:45 <aplainzetakind> geekosaur: Actually that would be good enough for my purposes. Since my file is static I can exclude the last line from the range of offsets, and I don't care about any even distribution.
12:25:26 <geekosaur> the cheaty one skips knowing line offsets, so you can't readily exclude that last line until you encounter it once
12:26:11 <aplainzetakind> What function reads from a given offset?
12:26:23 <geekosaur> also if it's a static file, you might consider a preprocessing run which reformats it into fixed length records
12:26:48 <geekosaur> it's not a single function. hSeek or hSetPosition, then hGetLine
12:27:19 <aplainzetakind> geekosaur: I'll look into those, thanks.
12:27:21 <geekosaur> beware of the difference between hSeek and hSetPosition on Windows (line terminators being two characters on disk)
12:28:33 <geekosaur> actually, hSetPosition can't (safely) be used with a randomly generated offset, so you'd have to use hSeek and watch out for landing between \r and \n. and binary mode for the file.
13:07:31 <bentai> How can I get the second value in the tuple from the head of list [('a',"app")]?
13:08:23 <aplainzetakind> bentai: snd . head
13:10:04 <bentai> I get an error
13:10:45 <bentai> Couldn't match expected type ‘a -> (a0, c)’
13:10:45 <bentai>                   with actual type ‘(Char, [Char])’
13:11:10 <aplainzetakind> > snd . head $ [('a',"app")]
13:11:12 <lambdabot>  "app"
13:16:31 <bentai> that worked, thank you
13:19:28 <roconnor> aplainzetakind: There is some trick where you scan the first line, then replace it with probabilty 1/2 with the second line, then replace whatever you have with probability 1/3 with the third line, etc.
13:20:39 <roconnor> after you have scanned all the lines in the file you return whichever line you ended up keeping in memory.
13:22:12 <roconnor> For example in a 3 line file you end up with a probability of 1/3 of returning the last line.  You end up with a probability of 2/3 * 1/2 = 1/3 of returning the second line and a probability of 2/3 * 1/2 * 1 = 1/3 of returning the first line.
13:47:20 <bentai> speller :: [[Char]] -> [Char]
13:47:20 <bentai> speller input = input ++ " is for " ++ lookups
13:47:23 <bentai> error
13:47:48 <bentai> Couldn't match type ‘[[Char]] -> [Char]’ with ‘[Char]’
13:47:48 <bentai>       Expected type: String
13:49:13 <bentai> when I am ready, I want to collect a line from input IO, strip out the first letter, then lookup a phrase from a dictionary(list of tuples). Looking up the phrase is no problem. I haven't worked on the do part yet.
13:56:29 <aplainzetakind> roconnor: Nice trick, though traversing the entire file each time would be too inefficient in my case.
13:59:37 <bentai> I am not quite getting the paradigm, which is to take a string, get a char from it in a function, compose that result into another function which returns a value from a data structure. What is the template?
14:02:57 <infinisil> roconnor: This can also be used to select k out of n elements by playing with the probabilities
14:02:59 <monochrom> I don't understand your description. Could you show some examples?
14:03:04 <infinisil> I implemented this at some point, let me try to find it..
14:07:25 <infinisil> Ah, I didn't use it to select a random subset, but to change a random subset of characters: https://github.com/Infinisil/aoc18/blob/master/aoc2/src/Main.hs#L131
14:07:52 <bentai> firstLetter input = input !! 0
14:07:52 <bentai> lookups = snd . head $ filter(\(x,y) -> x == firstLetter) dictionary
14:07:53 <bentai> speller :: [[Char]] -> [Char]
14:07:53 <bentai> speller input = lookups input ++ " is for " ++ lookups
14:08:17 <infinisil> This little bit of code is really neat imo: head . filter (/=c) <$> getRandomRs ('a', 'z')
14:08:38 <bentai> dictionary = [('a',"app"),('b',"bool")]
14:08:53 <bentai> Oh....you're not talking to me :\
14:09:00 <infinisil> No xD
14:10:55 <roconnor> aplainzetakind: oh I maybe didn't get what you were trying to do then.
14:12:56 <roconnor> aplainzetakind: if you want to get k random lines with duplicates, you can run my algorithm in parallel with itself.
14:13:55 <roconnor> If you want to get k random lines without duplicates, you should be able to adapt the method to remember the first k lines and then swap the nth line in with probability 1/n into one of the k lines stored in memory chosen randomly.
14:14:34 <roconnor> If the value 'k' isn't static, then I'm not sure what you are trying to do. :D
14:17:01 <talqu> how do i install gnutls-bin on nixos?
14:17:19 <monochrom> Wrong channel?
14:17:23 <fen> classes are something to do with polymorphism, right? 
14:17:33 <fen> like, thats what haskell does
14:17:44 <fen> like, before haskell that wasnt a thing?
14:17:59 <roconnor> classes are used in Haskell to implement ad-hoc polymorphism.
14:18:10 <fen> no
14:18:12 <talqu> it is this one nix-env -iA nixos.gnutls right?
14:18:16 <fen> its parametric and ad-hoc
14:18:19 <fen> thats the point
14:18:23 <fen> it unifies them
14:18:52 <fen> thats the opening statement of "making ad-hoc polymorphism less ad hoc"
14:18:52 <roconnor> talqu: see #nixos
14:19:43 <fen> anyway, trying to understand how haskell can have functions as first class values and why it cant do this at type level
14:19:54 <fen> thought maybe multiparameter typeclasses might help
14:20:00 <Tuplanolla> OCaml has polymorphism without type classes, fen.
14:20:12 <fen> how?
14:20:13 <talqu> ups sorry, wrote on the wrong channel
14:20:21 <Tuplanolla> Just fine, I guess.
14:20:33 <Cale> I don't care for using the word "ad-hoc" to describe the polymorphism that type classes give you. The key difference is that type class polymorphism lets you define type class polymorphic things by simply using other type class polymorphic things.
14:20:35 <fen> but this was after haskell?
14:21:03 <c_wraith> another term for what classes provide is "bounded polymorphism"
14:21:08 <Cale> With ad-hoc polymorphism, at least as I would use the term, the implementation to be used must be determined at the usage site.
14:21:39 <Cale> Yeah, it's more similar to bounded parametric polymorphism
14:21:43 <Tuplanolla> Well, Caml appeared in 1986.
14:21:49 <fen> hmm
14:21:50 <Lycurgus> sounds more like dynamic to me
14:21:51 <fen> ok fair
14:21:54 <roconnor> thats fair
14:22:11 <Lycurgus> ah hoc could be a matter of the number of man years invested
14:22:15 <fen> guess wadler was not the first to make this unification using type classes...
14:22:30 <fen> there was a talk he gave about this, the idea was from other languages
14:22:40 <roconnor> ML's eqtype polymorphism is adhoc?
14:22:52 <fen> but that the idea of classes was supposed to remove the distinction between ad hoc and parametric polymorphism
14:23:29 <Cale> "remove the distinction"?
14:23:44 <roconnor> parametric polymorphism to me requires unconstrained type variables, i.e. no type classes.
14:24:45 <Cale> Wadler gave his paper a catchy title "How to make ad-hoc polymorphism less ad-hoc", but I wouldn't take that as an endorsement for calling type class polymorphism "ad-hoc polymorphism" itself.
14:24:53 <fen> "This paper presents type classes, which extend the Hindley/Milner type system to include certain kinds of overloading, and thus bring together the two sorts of polymorphism that Strachey separated."
14:25:14 <Shockk> haskell-related fun thing; with some help from existential quantification, I managed to rejig my semantic tree structure entirely, and you can see the result (old vs new) here https://gist.github.com/shockkolate/d8de87cab07117e54262a9110b8f2aea
14:25:20 <fen> "Strachey chose the adjectives ad-hoc and parametric to distinguish two varieties of polymorphism [Str67]."
14:25:20 <Cale> roconnor: Would you consider a type like  OrdDict a -> [a] -> [a]  parametrically polymorphic? :)
14:26:06 <roconnor> Cale: I mean ya, the answers to these questions sort of depend on what googles you are veiwing them through.
14:26:17 <Cale> (But yeah, it's better to maintain a distinction between parametric polymorphism and the sort of polymorphism where variables are constrained by type classes)
14:26:33 <benzrf> :k Str67
14:26:35 <lambdabot> error:
14:26:35 <lambdabot>     Not in scope: type constructor or class ‘Str67’
14:26:58 <roconnor> Reminds me of the "are functions using monad impure or pure debate"  where the answer is that "a -> M b" is a pure function that denotes an impure function of type "a -> b".
14:28:09 <roconnor> When you wear googles so that the class bound is viewed as a dictionary parameter then this extended function is parametric polymorphic.
14:28:19 <fen> the examples of multiplication as ad-hoc, where many things (Double Ints etc can all use the opperater (*)) use the same function, and for parametric polymorphism fmap, where the parameter applied to the type the Functor class is instantiated over, is parametric in the contents 
14:28:22 <roconnor> But you can wear the same googles when looking at ML's eq-types.
14:28:28 <fen> seems like a strange distrinction
14:28:34 <fen> anyway, thats not the point at all
14:28:49 <fen> its about type families as multi-parameter typeclasses
14:29:12 <monochrom> "OrdDict a ->" is very different from "Ord a =>".
14:29:51 <fen> we dont have a typeclass mechanism at type level?
14:30:00 <fen> so type families have to do?
14:30:10 <roconnor> For me parametric polymorphism is largely about the free theorems it induces, and with type class constraints you don't get those free theorems if you ignore the constraint, but you do get a variant of the free theorem if you suitably include the constraint.
14:30:25 <monochrom> Suppose I am writing binary search tree operations.  "OrdDict a -> a -> BST a -> BST a" ensures that someone will break invariants, "Ord a => a -> BST a -> BST a" ensures they can't.
14:30:55 <roconnor> monochrom: unless you do tricky things with imports?
14:31:21 <monochrom> What is that?
14:31:23 <roconnor> oh maybe tricky things involve orphan instances.
14:31:27 <fen> how is it anything to do with AmbiguousTypes?
14:31:44 <fen> like, we need a type signature or TypeApplication to specify which typeclass instance to use
14:32:44 <fen> in a sense, the typeclass and the type annotation work together to resolve instances. this is how typechecking is decidable?
14:33:29 <fen> so then, is that supposed to be how defunctionalisation can be avoided, by making multiparameter typeclasses at type level?
14:33:48 <fen> so that decidability (maybe also for type level lambdas?) can be enabled
14:34:27 <fen> and if we just have to work with type families instead of classes, that this isnt the same mechanism
14:35:02 <fen> or am i just totally confused...
14:37:51 <roconnor> aplainzetakind: I'm not really sure about my math regarding chosing k distinct lines.  You'll want to double check that.
14:39:15 <fen> how is it that kind annotations are not enough to allow the resolution of partially applied type families or type level lambdas?
14:40:05 <fen> if there was the ability use constraints in kind annotations would that be enough to allows us to pass unsaturated type synonyms/families?
14:40:46 <fen> similarly, what mechanism allows us to do this at value level?
14:41:40 <fen> "making unsaturated type synonyms/families first class citizens" 
14:42:28 <fen> and languages that manage this at the expense of some type checker capabilities, whats that all about? what do they manage, and at what expense?
14:43:00 <fen> languages like agda and idris...
14:43:10 <fen> is it something to do with "dependent types" ?
14:43:25 <fen> has that got anything to do with dependent scoping?
14:43:33 <fen> apparently static scoping is the way to go...
14:48:30 <bentai> Anyone want to take a whack at debugging my haskell thinking?
14:53:30 <bentai> Anyone from U. of Glasgow? I am doing the online Futurelearn course.
14:53:51 <Shockk> I'm not from the university of glasgow but I am in fact in glasgow
14:53:57 <Shockk> not sure if that counts
14:54:18 <fen> just ask!
14:55:55 <bentai> Ok.
14:57:37 <bentai> firstLetter input = input !! 0
14:57:38 <bentai> -- get a tuple from the dictionary list, then produce the matching string
14:57:39 <bentai> lookups firstLetter = snd . head $ filter(\(x,y) -> x == firstLetter) dictionary
14:57:55 <bentai> -- assemble the ouput
14:57:55 <bentai> speller :: [[Char]] -> [Char]
14:57:56 <bentai> speller input = (\(a)  firstletter ++ " is for " ++ lookups 
14:58:17 <bentai> main::IO ()
14:58:17 <bentai> main = do
14:58:19 <bentai>        putStr "Please enter your word: "
14:58:19 <bentai>        firstLetter <- getLine
14:58:20 <bentai>        putStr (speller [firstLetter])
14:58:49 <bentai> the dictionary is dictionary = [('a',"app"),('b',"bool")]
14:58:56 <Shockk> try and post code snippets like that, somewhere like https://gist.github.com/ in future 
14:59:50 <bentai> I can get the individual parts to work in GHIC, but basically one enters a word "airplane" and the program outputs "a is for app"
15:00:30 <ryant[m]> Speaking of GitHub
15:00:31 <ryant[m]> https://www.zdnet.com/article/a-hacker-is-wiping-git-repositories-and-asking-for-a-ransom/
15:00:54 <bentai> The first part that is broke is getting the input in main, then passing the input through and transforming it until the concatenated string is produced.
15:02:41 <Shockk> bentai: when you say it's broken, what exactly happens?
15:03:23 <bentai> Just a moment and I can dump my interactive session into github
15:03:58 <bentai> lookups is broke on type : Couldn't match expected type ‘[Char]’
15:03:58 <bentai>                   with actual type ‘Char -> [Char]’
15:05:19 <Shockk> so, lookups is a function that takes the first letter, right? 
15:05:52 <Shockk> right now, in your definition for `speller`, you aren't applying any argument to it
15:07:50 <fen> ryant: other peoples?
15:13:09 <bentai> lookups takes the first letter of the input, so if I set input = "airplane" then it should get 'a' from firstLetter
15:14:59 <monochrom> What does it mean to say "foo"++lookups, if lookups is not a string?
15:15:13 <eruvarn> in the code you don't call the function with any arguments, so the return type becomes Char -> [Char]
15:15:30 <monochrom> Like, if lookups is a function, don't you need to give it a parameter?
15:15:39 <MarcelineVQ> Better to see the actual code, the example line using lookups earlier wasn't complete.
15:15:50 <monochrom> Yeah that too.
15:16:44 <bentai> hold on
15:18:58 <bentai> https://github.com/bentaisan/intro-to-haskell
15:19:03 <bentai> speller.hs
15:22:38 <bentai> If you want to see my session as I tried little bits out, and error messages, it is what I actually checked in mistakenly as speller.hs first
15:24:07 <bentai> If the hint can be made in socratic form...I might be able to suss a bit of it on my own, but right now, not sure where to start. I am sure it could idiomatically be stiched together much simpler
15:24:14 <Berengal> I'm getting a compiler warning and I don't know if it's a compiler bug or if I'm doing something stupid
15:24:33 <Berengal> https://pastebin.com/7rwDrR3m
15:25:18 <eruvarn> bentai: Aren't you calling lookups without arguments on line 19?
15:25:31 <bentai> Berengal, for all my ignorance, that seems like an infinite loop in your code
15:25:50 <Berengal> The code works fine, it's the compiler that gets stuck in a loop
15:26:22 <Berengal> Or rather, just the part that checks for overlapping patterns
15:26:32 <bentai> In line 19, lookups should get firstLetter
15:27:35 <monochrom> If that's really what you think, then what the hell would "lookups input" mean?
15:29:27 <bentai> I fixed it to "lookups Firstletter", updated in github
15:30:01 <monochrom> The question still stands.
15:30:28 <eruvarn> But firstLetter isn't defined in that context, right?
15:30:42 <monochrom> Oh there is a global firstLetter too.
15:30:54 <bentai> I pushed my interactive session to github
15:30:55 <eruvarn> Oh
15:30:58 <monochrom> And that one is a function not a Char.
15:31:29 <monochrom> Also no one is using input now.
15:31:34 <bentai> It isn't saying it doesn't exist, just that it is eating the wrong type
15:33:06 <monochrom> OK, tell me why it is not:  firstLetter input ++ " is for " ++ lookups (firstLetter input)
15:33:32 <bentai> let me try
15:37:11 <jle`> Berengal: hm. how sure are you that your pattern match is complete? 
15:39:28 <eruvarn> I'm not sure if I understand the program correctly
15:40:00 <monochrom> Yeah too many "firstLetter"s.
15:40:00 <eruvarn> But this is how I would fix it: https://pastebin.com/Pi7bk2Mh
15:41:15 <eruvarn> I'd say that if you have a function that returns the first letter of a string, it's better to call it getFirstLetter
15:45:40 <Berengal> jle`: I'm not sure, but that's not what the compiler warns about
15:46:07 <Berengal> Actually, I am sure because I have a catch-all at the end
15:47:29 <jle`> Berengal: then, it's probably a bug :)
15:49:11 <bentai> I uploaded a file called "figuring-out-steps.txt" where I work out indindividual steps of the program
15:49:39 <bentai> Except, instead of getting input from the keyboard, I set input="zebra"
15:50:13 <bentai> https://github.com/bentaisan/intro-to-haskell/blob/master/figuring-out-steps.text
15:50:40 <bentai> (I might learn pastebin, that seems like an easier way to communicate)
15:51:31 <bentai> So, the question is, how is this put together into a standalone program, before the main and IO is added
15:51:33 <bentai> ?
15:52:45 <Solonarv> bentai: I would recommend github gist ( https://gist.github.com ) over pastebin
15:53:20 <Solonarv> it supports multiple files, edits/revisions, has syntax highlighting, and a sane UI
15:53:34 <jle`> bentai: i would recommend writing a function that takes the input and returns an output
15:53:53 <jle`> and then just using main = interact myFunction or something like that
15:54:04 <jle`> myFunction :: String -> String
15:54:18 <jle`> or main could just be getting a string, applying myFunction, and printing the reuslt
15:56:04 <eruvarn> bentai: just a tip, if you want to add a char to the begginning of a string, you can just use ':'
15:57:03 <eruvarn> 'a' : " is for airplane" == "a is for airplane"
15:58:15 <bentai> Good tipe
15:58:17 <bentai> tip
15:59:17 <bentai> If I wanted to pipe the input into the first letter extraction, the lookup and then into the result of the function, how would I do that? 
16:00:31 <bentai> It seems I should be able to cut and paste the snippets from the shell into a file and make a program
16:00:40 <fen> https://gist.github.com/fen-hs/b5641e3e5612bebd912c2d2f1c774ac4
16:01:04 <jle`> bentai: i don't think you can really use any of the lines as-is, without some major editing
16:01:27 <fen> have added a datatype for Nested states...
16:01:34 <jle`> bentai: but remember you can use let/where bindings within a function to make your thought process easier to follow and keep track of
16:01:43 <jle`> myFunction input = ....
16:01:51 <jle`>   where
16:01:56 <jle`>   firstLetter = input !! 0
16:02:06 <bentai> ahhhh
16:02:08 <jle`> er, that firstLetter should be indented a little more
16:02:15 <jle`>     lookups = snd . head $ ...
16:02:22 <jle`>     speller = ..., etc.
16:02:43 <bentai> now I can lookup where in the docs/book and get a pattern to follow
16:11:18 <bentai> I didn't want to do the lazy thing and just do
16:12:20 <bentai> speller 'a' = "a is for app"
16:12:21 <bentai> etc.
16:12:30 <bentai> as one long funciton
16:12:49 <monochrom> Huh, no one said you should.
16:15:44 <bentai> I know, but the p-set said I COULD do that, but I don't think that would be learning much
16:17:35 <fen> what about instead of a type level list of nested container types its a Tree?
16:18:55 <fen> if every possible container that can be unfolded is to be represented in one, then it would have to abstract over the shape of the representation of the nested containers, and the only option for this is a tree?
16:19:10 <monochrom> Type-level tree?  I think the dependent-type fanatics still haven't thought of that.
16:19:10 <jle`> bentai: also i'm not sure if i would call that the 'lazy' way ;)
16:19:13 <fen> f (g ... (h a))
16:19:20 <jle`> it sounds much more work-intensive
16:19:47 <fen> but where eg, g = \a -> (l (m ... (n a)))
16:20:09 <MarcelineVQ> monochrom: are you goofin :>
16:20:21 <bentai> I had to make the dictionary...
16:20:28 <monochrom> Err what did I goof?
16:20:46 <fen> well there is the way jle` mentioned of using Prod Sing
16:21:02 <fen> but that seems similar to just using a type level list
16:21:21 <MarcelineVQ> monochrom: well like, there's fully-type-level red-black trees in haskell already, you're sure to find them in dependent languages
16:21:23 <fen> oh, wait, no this is different because they are "composed"
16:21:55 <monochrom> OK!
16:22:30 <fen> so then (f (g .. (h a))) ~ [f,g ... h] a
16:22:50 <fen> and g ~ [l,m .. n]
16:22:58 <fen> so then its like Free []
16:23:33 <fen> and maybe there is information stored there that would not be contained simply in a type level list of nested containers
16:24:15 <Cale> fen: Could it be that what you're really looking for is Traversable and Foldable instances for Compose?
16:24:31 <fen> Compose only takes 2 things
16:24:36 <fen> this takes a Tree of things
16:24:48 <Cale> yeah, but if you keep applying it, you can compose as many functors as you want
16:24:56 <MarcelineVQ> monochrom: what I was thinking of http://hackage.haskell.org/package/red-black-record in case it was of interest
16:25:15 <fen> but it would not preserve the orignial shape?
16:25:25 <Cale> hm?
16:25:59 <fen> if it flattened them down
16:26:37 <fen> you would just end up with [f,l,m .. n, .. h]
16:27:18 <fen> and you wouldnt be able to turn that back into the version where g consited of a nesting, so it wouldnt unfold into itself
16:27:32 <fen> (thats the unit test)
16:28:16 <fen> oh, maybe it ends up backwards when you unfold it... so basically, if you make a zipper, it would need to preserve the shape
16:30:18 <fen> basically the recursive instances for Unfoldable,Foldable via Set,Get respectively, are essentially the Compose case, but instead of writing it like (Compose f (Compose g) ...) its a type level list (or Tree..) 
16:30:27 <delYsid`> Why would a storable vector implementation behave differently in GHCi vs. the compiled program?  I am baffled.
16:31:59 <fen> so yeah, if you say the "Compose" instance, basically yes thats the idea, except here that is just the inductive step to the length -1 length list
16:32:22 <fen> and it also needs to handle the Free varient of this..
16:32:31 <fen> quite daunting really
16:34:53 <fen> bascailly the task is to write these recursive instances for Get and Set and Container in https://gist.github.com/fen-hs/b5641e3e5612bebd912c2d2f1c774ac4
16:35:22 <fen> ie given the head of the list satisfies the constraint, recurse over the tail
16:36:56 <fen> but that because of the way BCConstructor is written like a Tree, it should really be a kind of Free version of this recursion :-0
16:38:17 <fen> maybe it only makes sense with the example above if g is a newtype wrapper over a Free thing....
16:38:33 <fen> does that make sense?
16:41:04 <fen> like you can convert between (f (g .. (h a))) and [f,g .. h] a, but what would be the lhs of this if the rhs was like Free [Pure f,Free [Pure l,Pure m .. Pure n] .. Pure h]
16:43:56 <fen> thats the case when the Container instance of g gives it an associated Base which is NestedC [BaseOf l, BaseOf m .. BaseOf n]
16:44:49 <fen> it seems like it should be really easy to write...
16:45:12 <fen> just cant quite wrangle this Free aspect...
16:46:18 <fen> maybe you just call BaseOf on the head of the list and the recursion just happens...
16:46:21 <fen> :-/
16:48:13 <fen> like, maybe its always a list, because the newtype wrapper on eg. g serves instead of the Free constructor...
16:48:52 <fen> huh, maybe you are right Cale and the Compose case is enough...
16:50:13 <fen> (which is the head tail recursion in this setting)
16:50:57 <fen> so then we dont need type level Free composed nested containers...
16:55:05 <fen> like, because you can pattern match with a type family to convert from (f (g .. (h a))) but you wouldnt be able to pattern match into the g newtype that wraps another layer of nesting...
17:21:06 <^Tranquil^> where is gogs and magogs wall ?
17:21:12 <^Tranquil^> who is dajjal father ?
17:25:36 <vukonen> Is something like let f = (all predicate .) . zip the idiomatic way to make a function that takes 2 arguments with point-free style?
17:26:11 <jle`> vukonen: the idiomatic way would be to not be point-free
17:26:53 <Cale> (but yeah, that's a thing you can do to compose a function onto the result of a function of two arguments)
17:27:00 <jle`> myFunc x = f . g x, or myFunc x y = f (g x y) are both much more readable and idiomatic
17:27:03 <Cale> Lambda does exist for a reason though :)
17:31:17 <vukonen> Thanks
17:33:34 <vukonen> I guess that makes sense cause I saw this on a programming challenges website and people tend to be overly concise on there
18:05:53 <xcmw> Does this data structure have an existing name?
18:05:56 <xcmw> data Mealyish m a b = Mealyish {unMealyish :: Mealy a (m b)}
18:06:30 <xcmw> I see MealyT but this is different
18:07:12 <Cale> I dunno, but that also might be written  Compose (Mealy a) m b
18:07:21 <jusss> about Functor, fmap::(a->b)->(e->a)->(e->b),   (->) e is a function?
18:07:55 <jle`> jusss: (e -> a) is a function, (e -> b) is a function
18:08:00 <jle`> or well, they are types of functions
18:08:15 <Cale> (->) e a is the same thing as (e -> a)
18:08:20 <jusss> jle`: and what (->) e is
18:08:29 <Cale> It's just the function arrow written prefix and then applied to a single argument
18:08:44 <jle`> it's a partial application of (->)
18:09:06 <jle`> `(->) e a` is a function
18:09:18 <jusss> I'm stuck with the function and functor
18:09:20 <jle`> so `(->) e` is a partial application of (->)
18:09:46 <Cale> So, (->) e is the type level function which, when applied to some t, gives e -> t
18:09:58 <Cale> so in the type of fmap
18:10:04 <Cale> fmap :: (a -> b) -> f a -> f b
18:10:16 <Cale> here, we're choosing f t = e -> t
18:11:16 <jusss> jle`: what I don't understand is, like (->) e a construct a function right? and fmap can change that apart a in (->) e a, it's like fmap can change a function's definition
18:11:32 <jle`> jusss: `fmap f` takes a function, and returns a new function
18:11:35 <jusss> change something inside a function from the outside
18:11:47 <jle`> so it is "changing the function's definition", in the sense that `negate` changes an integer
18:11:55 <Cale> jusss: I think we're confusing types and values here
18:12:12 <jusss> Cale: yeah
18:12:18 <Cale> jusss: (e -> a) is the *type* of functions which accept an argument of type t, and produce a result of type a
18:14:11 <Cale> So, fmap :: (a -> b) -> (e -> a) -> e -> b
18:14:14 <Cale> Let's implement it
18:14:20 <fen> yeah but how are you making this thing? if your using the applicative pure then its just const anyway...
18:14:21 <Cale> fmap f g x = ...
18:14:33 <Cale> Here we have
18:14:40 <Cale> f :: a -> b
18:14:44 <Cale> g :: e -> a
18:14:46 <jusss> for example, like list functor, fmap::(a->b)->[a]->[b], we know that (a->b) will work on a in [], but if it's (e->a), we can't say (a->b) work on a in (e->) right?
18:14:47 <Cale> x :: e
18:15:12 <Cale> and we're trying to produce a result of type b
18:15:15 <jusss> about functor, e->  and [],   they're different match
18:15:30 <Cale> I'm not sure what you're trying to say there
18:15:38 <fen> :t (fmap (+1) ((*) 2))
18:15:39 <lambdabot> Num b => b -> b
18:15:42 <Cale> The implementation of fmap for each instance will be different
18:15:48 <fen> > (fmap (+1) ((*) 2)) 3
18:15:50 <lambdabot>  7
18:16:18 <jusss> Cale: fmap +1 [3]  that +1 will work on 3 and return [4] right?
18:16:35 <geekosaur> with parentheses to make a valid section
18:16:42 <jusss> my English is not good, if I express not properly
18:16:43 <Cale> If you think of a function e -> a as being like a container indexed by values of type e, holding values of type a, then fmap f will apply a function of type a -> b to each of the values of type a, in order to obtain a function e -> b
18:16:56 <Cale> > fmap (+1) [3]
18:16:58 <lambdabot>  [4]
18:17:21 <Cale> > fmap reverse show 123
18:17:23 <lambdabot>  "321"
18:17:36 <fen> jusss: correct
18:18:05 <Cale> (the parens around (+1) there are not optional, that's an operator section)
18:18:37 <jusss> Cale: that (+1) apply on 3 right?
18:18:44 <Cale> yeah
18:18:47 <Cale> > (+1) 3
18:18:50 <lambdabot>  4
18:18:55 <Cale> > fmap (+1) [3]
18:18:57 <lambdabot>  [4]
18:19:05 <Cale> > fmap (+1) (const 3) 0
18:19:07 <lambdabot>  4
18:19:13 <jusss> Cale: but if it's not a list, it's a function, fmap (+1) (+2)
18:19:36 <jusss> Cale: we can't say (+1) apply on 2 right?
18:19:42 <Cale> > fmap (+1) (+2) 1
18:19:44 <fen> :t \ f g -> (f .) . g
18:19:44 <jusss> because we can't get 2 from (+2)
18:19:45 <lambdabot>  4
18:19:45 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
18:20:01 <Cale> If we apply (+2) to 1, then there's a 3
18:20:05 <Cale> > (+2) 1
18:20:07 <lambdabot>  3
18:20:26 <fen> its just flip?
18:20:31 <Cale> and if we fmap (+1) (+2), then it will be 4
18:20:37 <Cale> > fmap (+1) (+2) 1
18:20:39 <lambdabot>  4
18:20:57 <fen> fmap (+1) (+2) = (+2) . (+1)
18:21:06 <Cale> fmap f g = f . g
18:21:21 <fen> oh, not swapping 
18:21:24 <fen> ok
18:21:39 <jusss> Cale: we can't change that something inside a function, (+1) can't get 2 from (+2) ?
18:21:39 <fen> thought it acted on the input?
18:21:51 <Cale> jusss: I'm not sure what you mean
18:22:03 <fen> oh, no its alread partially applied nvm
18:22:05 <jusss> Cale: (e->a)  (+2) 
18:22:05 <Cale> jusss: Here, let's just implement fmap by hand, given the type:
18:22:13 <Cale> rather than getting distracted by examples
18:22:25 <fen> :t fmap @ (->)
18:22:27 <lambdabot> error: parse error on input ‘->’
18:22:31 <Cale> fmap :: (a -> b) -> (e -> a) -> (e -> b)
18:22:32 <fen> :t fmap @(->)
18:22:33 <lambdabot> error: parse error on input ‘->’
18:22:35 <fen> ?
18:22:40 <Cale> I've got it
18:22:54 <jusss> Cale: (e->a) -> (e->b) it seems that function e->a can change to (e->b)  but (+2) we can't get 2 from (+2) we can't change it to (+3)
18:23:08 <Cale> jusss: sure, let's see how it actually works
18:23:12 <[Leary]> jusss: It doesn't need to "get anything out of" the function definition, it just acts on the result of applying the function.
18:23:23 <Cale> fmap f g x = ...
18:23:29 <Solonarv> fen: lambdabot doesn't have TypeApplications enabled
18:23:31 <Cale> We'll bind variables for
18:23:34 <Cale> f :: (a -> b)
18:23:37 <Cale> g :: (e -> a)
18:23:39 <Cale> and
18:23:42 <Cale> x :: e
18:23:43 <fen> yeah maybe the monoidness of + is confusing here
18:23:53 <Cale> and now our goal is to produce a result of type b
18:24:10 <Cale> yes?
18:24:15 <fen> ie +a . +b = +(a+b)
18:24:23 <fen> thats confusing
18:24:28 <Cale> uh
18:24:44 <fen> take an example where it doesnt look like your changing the first argument to +
18:25:14 <Cale> jusss: Are those types for f, g, and x obvious?
18:25:20 <Cale> and our goal?
18:25:28 <fen> a function taking 2 different values
18:25:36 <fen> 2 values of different types*
18:25:57 <jusss> e->b is a function that take one parameter, but after partial e-> , what this is, it take one parameter and return nothing? I don't know we can partial on unary function
18:26:15 <Cale> jusss: (->) e is not a type which has values
18:26:30 <fen> @let eg a b = b ++ show (a+1)
18:26:31 <lambdabot>  Defined.
18:26:32 <Cale> jusss: It's a type-level function, which will take a type, and produce another type (which then will have values)
18:26:34 <fen> :t eg
18:26:35 <lambdabot> (Show a, Num a) => a -> [Char] -> [Char]
18:27:03 <fen> :t fmap reverse (eg 1)
18:27:08 <lambdabot> [Char] -> [Char]
18:27:19 <fen> > (fmap reverse (eg 1)) "hello "
18:27:21 <lambdabot>  "2 olleh"
18:32:21 <fen> Cale: but its not a type level function like a type family...
18:32:29 <fen> or even a type synonym
18:33:00 <fen> so why do we need the datatype to do this>
18:33:01 <fen> ?
18:33:23 <fen> (->) must be a datatype right?
18:33:37 <fen> so we could fmap over the second argument 
18:33:54 <fen> the `b' of `(->) a b'
18:34:25 <fen> but if we wrote type Func a b = (->) a b
18:34:55 <fen> then we couldnt fmap over the partially applied; (Func a)
18:36:16 <fen> just like if we had a newtype wrapping a functor, we wouldnt get the functor instance automatically
18:38:03 <fen> newtype Func a b = Func (a -> b) would work...
18:38:31 <fen> ie, we could write its functor instance
18:38:44 <fen> well, the functor instance for (Func a)
18:39:04 <Cale> sure
18:39:14 <fen> but why not the type synonym version?
18:39:51 <fen> say, for a version with the ags flipped, so its not just the same instance it has already;
18:40:06 <fen> type FlipFunc a b = (b -> a)
18:41:19 <fen> if this were indistinguishable from (b -> a) it would make sense, since that already has a Functor instance, so we couldnt overwrite it 
18:41:58 <Cale> You're not allowed to partially apply type synonyms, because that's basically type level lambda
18:42:01 <fen> but it cant be indisinguishable because as a type synonym its not the same as a datatype
18:42:17 <fen> why not?
18:42:38 <Cale> Type synonyms are indistinguishable from the types they're synonyms of
18:43:09 <Cale> If I define  type Foo = Integer, then anything demanding something of type Foo, I can give it an Integer, and vice versa.
18:43:14 <fen> but they are clearly different, as a type synonym of a datatype cant be partially applied...
18:43:56 <Cale> You could, if you wanted, define  type Func = (->)
18:44:10 <fen> @let type FlipFunc a b = (b -> a)
18:44:12 <lambdabot>  Defined.
18:44:31 <fen> @let instance Functor (FlipFunc a)
18:44:32 <lambdabot>  .L.hs:167:10: error:
18:44:32 <lambdabot>      • The type synonym ‘FlipFunc’ should have 2 arguments, but has been given 1
18:44:32 <lambdabot>      • In the instance declaration for ‘Functor (FlipFunc a)’
18:44:35 <Cale> FlipFunc, you won't have much luck with, because you have to apply it to two arguments before it will reduce
18:45:00 <Cale> (Moreover, you have to give it two arguments anywhere that you use it)
18:45:30 <fen> it cant reduce it based on a ploymorphic snd type parameter it guesses using a forall?
18:45:52 <Cale> It wouldn't be forall
18:45:57 <Cale> It would be lambda
18:45:59 <fen> is this something to do with Colsure?
18:46:03 <fen> Closures*
18:46:25 <Cale> If we had type level lambdas, then it could treat FlipFunc a as \b -> (b -> a)
18:46:43 <fen> but your saying GHC cant reduce that
18:46:53 <Cale> We don't have type level lambda
18:47:00 <fen> why not?
18:47:07 <fen> that was the question to begin with maybe
18:47:57 <Cale> Well, because it makes type inference significantly worse, and would interact badly with type classes in a bunch of ways, and people haven't yet figured out how to make it play really nicely with the rest of Haskell's features yet.
18:48:03 <Cale> But maybe at some point.
18:48:19 <fen> http://www.cs.uu.nl/research/techreps/repo/CS-2015/2015-014.pdf
18:48:43 <fen> they say the managed and added it to a "development version of GHC"
18:49:22 <fen> how does it make type inference worse?
18:49:38 <fen> what ways does it interact with type classes badly?
18:49:55 <fen> which other parts of haskell does it not play really nicely with?
18:50:35 <fen> "it ruins inference" basically, but, how? why?
18:50:59 <int-e> "Type inference with type level lambdas would require higher order unification which is undecidable."
18:51:09 <fen> oh yeah...
18:51:14 <fen> there is not id
18:51:17 <fen> or something...
18:51:28 <fen> no unique higher order unifier? 
18:51:50 <Cale> Not even just not unique, but it's not decidable whether there is a unifier
18:51:59 <fen> so undecidability is ok normally its just overlapping things which are a problem
18:52:00 <int-e> There are als no most general unifiers, right.
18:52:26 * int-e is somewhat surprised that soundness doesn't become an issue, actually.
18:52:55 <fen> if we need to resolve an ambiguity which prevents inference from resolving the types we just annotate with a type signature or TypeApplication
18:53:01 <fen> so whats the problem?
18:54:12 <fen> its making everything overlapping?
18:54:34 <fen> cant we solve that with typelevel classes?
18:55:14 <int-e> If you allow lambdas I don't think ghc could get away with type erasure anymore? I mean, how do you handle an abstracted type family?
18:55:46 <fen> whats erasures? whats an abstracted type family?
18:56:08 <Cale> fen: Types don't exist at runtime
18:56:12 <int-e> (Lambda x. Foo x) where Foo is a type family with a single argument.
18:56:13 <Cale> (as it stands)
18:56:26 <fen> whats that got to do with anything?
18:56:50 <Cale> they're all erased by the process of compilation, following typechecking (actually, following simplification, since GHC's core language is typed as well)
18:57:14 <int-e> Well, type families can inspect their argument type, and the resulting type depends on that inspection.
18:57:31 <fen> pattern matching?
18:57:38 <int-e> on types.
18:57:48 <fen> but we can do that at value level and it causes no ploblem...
18:57:57 <int-e> Which is fine because it all can be resolved at compile time as things stand.
18:58:26 <fen> why would pattern matching at type level need to be done at runtime?
18:58:27 <int-e> But I'm not sure whether that property holds up with lambdas.
18:58:59 <int-e> fen: well a program can instantiate an unbounded number of types at runtime.
18:59:27 <fen> what does it mean to instantiate types at runtime?
19:00:35 <fen> so the problem is that if the type parameter is as yet unspecified, it cant yet be matched upon?
19:00:50 <fen> i dont get how that works
19:00:58 <int-e> that's what I'm worrying about, yes.
19:01:42 <fen> is that problem apparent in the FlipFunc example above?
19:01:52 <fen> or do we need a different example to understand that?
19:02:38 <fen> anyway, its also a problem with synonyms
19:02:42 <fen> and these have no matching
19:03:27 <fen> maybe a type level case expression would capture both these aspects
19:03:42 <fen> thats like a lambda with pattern matching right?
19:04:44 <fen> or lambdaCase?
19:05:54 <fen> (\case Bool -> Int; Int -> Bool)
19:07:31 <fen> so then it has these 2 problems, right? its a lambda, ie there is no actual type family name that could be resolved (like a datatype could be) 
19:08:15 <fen> and, if it were partially applied (well it only takes one argument, so totally unapplied) it couldnt have an instance written over it - or appear anywhere
19:08:27 <fen> which is something to do with the pattern matching?
19:11:24 <fen> if we just use newtypes make type synonyms decidable (or however you say it) cant we just use data families for the pattern matching thing?
19:11:55 <fen> and then for closed data families we just get GADT's...
19:12:12 <fen> so whats the problem with that?
19:13:10 <fen> does that mean type level lambdas are similar to type synonym instances?
19:14:39 <fen> basically, that paper seems to say everything can work, so specifically, why isnt it a part of GHC?
19:14:46 <fen> what exactly is the problem?
19:23:49 <fen> apparently scala has them with extra names for the instances
19:24:01 <fen> couldnt that for the basis for KindApplications?
19:24:46 <fen> or is that different... like then you could have 2 different instances for any class... 
19:24:49 <fen> ok nvm
19:28:27 <int-e> :t let foo :: f x -> x; foo = undefined in foo (Right False)
19:28:28 <lambdabot> Bool
19:42:12 <bentai> I got it down to one error, maybe
19:42:14 <bentai> https://gist.github.com/bentaisan/fcdb9b3c07d9776a5aa3ded37468fef4
19:42:39 <jle`> bentai: you need the 'in' :)
19:42:43 <bentai> getting a parse error(assuming there is a dictionary like in the source file)
19:42:47 <jle`> let .. in ...
19:58:15 <bentai> close
19:58:55 <cobreadmonster> what's up guys
19:59:05 <cobreadmonster> Any cool gsoc papers?
19:59:11 <bentai> this
19:59:14 <bentai>  output firstLetter
19:59:54 <bentai> getting type mismatch
20:00:17 <bentai> Couldn't match type ‘[[Char]]’ with ‘Char’
20:00:18 <bentai>       Expected type: [Char]
20:00:18 <bentai>         Actual type: [[[Char]]]
20:01:06 <bentai> could I try to head it once?
20:04:17 <jusss> fmap :: a -> (b->e) -> (a->e) -> b   this is available?
20:05:33 <jle`> @djinn a -> (b -> e) -> (a -> e) -> b
20:05:33 <lambdabot> -- f cannot be realized.
20:10:24 <geekosaur> I don't see where you got that question
20:10:28 <geekosaur> :t fmap
20:10:30 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:11:31 <jusss> a-> (b -> f a) -> f b
20:12:55 <jusss> jle`: a->b is an unary function, (+1) is an instance of a->b, but I don't know what (->) a is
20:13:00 <jusss> a->
20:13:58 <geekosaur> it's artially applied, like (+1) is partially applied
20:14:35 <jusss> I thought that (+1) is just an identifier for \x -> x+1
20:15:16 <geekosaur> it is. and (a->) would be a partially applied type lambda, but Haskell doesn't support type level lambdas
20:15:17 <jusss> \x -> x+1 , its type is a->b
20:16:17 <jusss> geekosaur: what \x -> x+1 looks like after partial applied?
20:16:31 <jusss> it just has one parameter
20:16:33 <jle`> jusss: (\x -> x + 1) applied to, say, y, is:
20:16:37 <jle`>  (\x -> x + 1) y
20:16:39 <jle`>  = y + 1
20:16:42 <geekosaur> that is not itself partially appliable
20:16:57 <geekosaur> (+) takes two parameters.. (+1) provides one of them, and is therefore a partial application
20:16:59 <jle`> you apply it to get y + 1, so it's not really "partial application". it's "full application"
20:18:06 <jusss> jle`: so \x -> x+1 can not be partial applied?
20:18:23 <jle`> it can be applied
20:18:59 <jusss> and it would be (+ x ) or (+ 1) ?
20:19:10 <jle`> jusss: "partial application" is just what we call application when it returns a different function; it hasn't "resolved" to a full non-function value yet
20:19:25 <jle`> jusss: the application of (\x -> x + 1) to 7 is 8
20:20:03 <jle`> > (\x -> x + 1) 7
20:20:05 <lambdabot>  8
20:21:00 <geekosaur> jusss, you are confusing action and result. (+1) is the result of a partial application, not the cause of one
20:24:32 <jusss> jle`: geekosaur fmap (+1) (+1),  is there a functor in (+1) ? or (+1) is the functor?
20:24:55 <jle`> (+1) is not a functor
20:25:03 <jusss> those e->a doesn't have the same behavior with []
20:25:16 <jle`> `e -> a` is comparable to [a]
20:25:29 <[Leary]> This whole conversation would be simpler if all operator use (and special list syntax) were desugared to prefix.
20:25:46 <geekosaur> but you're probably comparing on value level, and (->) doesn't have value level but [] has both type and value level.
20:25:49 <jusss> jle`: but fmap can apply a->b on a in [a], but fmap can't apply a->b on a in e->a
20:26:03 <geekosaur> the comparison to [] here is that you can write [Int] as ([] Int)
20:26:38 <Cale> jusss: The functor in that case is (->) Integer
20:26:53 <jusss> geekosaur: fmap can apply a->b on Int in [Int] right?
20:27:11 <jle`> jusss: also note something -- 'f a' doesn't necessarily have an a "in" it
20:27:15 <geekosaur> you have type and value level confuse, I think
20:27:19 <Cale> jusss: Supposing that a is Int, yes?
20:27:24 <jle`> so "applying a -> b to the a's in [a]" is something that is accurate to lists in particular
20:27:27 <jle`> but not all Functor instances
20:28:03 <Cale> In some sense, even in the function case, we have that fmap f g applies f to all the possible results of g
20:28:04 <jle`> 'f a' doesn't necessarily have an 'a' "in" it.  `[] a` does.  `((->) e) a` does not.
20:28:15 <geekosaur> note this ^ carefully
20:28:16 <Cale> which if you like, you can think of as the "elements contained in g"
20:28:21 <jusss> jle`: so "<jusss> those e->a doesn't have the same behavior with []"
20:28:27 <geekosaur> the functor is ((->) a)
20:28:31 <Cale> though the sense in which they're "contained" is a little more abstract now
20:28:39 <jle`> jusss: right, the behavior of fmap is different for every single Functor
20:28:51 <jle`> the behavior of fmap for lists is different than the behavior of fmap for `(->) e`, etc.
20:29:01 <Cale> Sometimes it can be helpful to think of a function of type e -> a as being like a giant array indexed by values of type e, having values of type a at each position
20:29:42 <jle`> there's one potential confusion here as well, it's that we're using "function" to mean a few things at a few different levels
20:30:03 <jle`> so it might be useful to not think about `(->) r`, but rather `Reader r`, if you understand the semantics of `Reader r a`
20:30:04 <jusss> Cale: but function is not a container
20:30:11 <jusss> and list is a container
20:30:21 <Cale> jusss: I'm telling you the sense in which you can think of functions as a sort of container
20:30:35 <jle`> a value of type `Reader r a` "contains" an 'a', that must be given an 'r' to access
20:30:54 <Cale> jusss: Did you read the array analogy?
20:30:58 <jle`> so you cannot access the 'a' without an 'r', so to speak.  and giving different r's will give you different a's
20:31:06 <jusss> Cale: list is a container, because I can change the value in the list, but I don't think we can change the value in the function,
20:31:06 <jle`> so fmap :: (a -> b) -> Reader r a -> Reader r b
20:31:13 <Cale> jusss: Sure we can
20:31:26 <Cale> jusss: In any sense in which you could change the elements of a list
20:31:28 <jle`> it takes something that "produces" an a, and turns it into something that "produces" a b
20:31:54 <jusss> Cale: for example, \x->x+1, how to change that 1 to 2?
20:32:22 <geekosaur> you'r thinking wrong
20:32:33 <geekosaur> a function, includin g a lambda, is a single non-decomposable thing
20:32:35 <Cale> jusss: Which 1? The 1 that results when you apply that function to 0?
20:32:39 <geekosaur> nothing can see the 1 there
20:32:41 <geekosaur> or change it
20:32:52 <geekosaur> the only access you have is to apply it to some parameter
20:32:53 <jusss> geekosaur: but if it's list, we can
20:33:02 <Cale> > (\f x -> if x == 0 then 2 else f x) (\x -> x + 1) 0
20:33:04 <lambdabot>  2
20:33:07 <Cale> > (\f x -> if x == 0 then 2 else f x) (\x -> x + 1) 1
20:33:09 <lambdabot>  2
20:33:10 <Cale> > (\f x -> if x == 0 then 2 else f x) (\x -> x + 1) 2
20:33:12 <lambdabot>  3
20:33:18 <geekosaur> yes, and?
20:33:23 <Cale> There, I changed it.
20:33:32 <geekosaur> is it somehow not possible that different types are different?
20:35:13 <jle`> i think jusss's point is that functions in general are not inspectable in the same way that lists are, which is a part of the concept of container-ness in their experience
20:35:29 <[Leary]> (\x -> x + 1) is not a container holding x, + and 1, it's a "container" holding the value (x + 1) at the index x.
20:35:30 <geekosaur> if there were a formulaic way to define what fmap does, fmap would be a function, not a typeclass method. but the notion of functor is more abstract. it applies in one way to lists. a different way to functions. a still different way to State, etc.
20:36:03 <Cale> jusss: You can think of the function (\x -> x + 1) as being the set of pairs (0,1), (1,2), (-1,0), (2,3), (-2,-1), ...
20:36:22 <Cale> The second components of those pairs are the "elements" which we're modifying by way of fmap
20:36:27 <geekosaur> similarly, *if* you insist on thinking in terms of "container", there is an abstract way to recognize a function as a "container". but only that abstract way; it does not become a funny looking list
20:36:55 <Cale> i.e. a function is a thing which pairs up inputs and outputs in a particular way
20:37:00 <geekosaur> frankly, I find it better to not think in terms of "container" because it will mislead you
20:37:06 <Cale> and fmap applies a function to all the outputs of another function
20:37:45 <Cale> Abstractly, there's no requirement that we recognise the type as a container type in order to make an instance of Functor
20:38:36 <Cale> All that is required is that we have a type F of kind * -> * and a function fmap :: (a -> b) -> F a -> F b for which it's the case that fmap id = id, and fmap f . fmap g = fmap (f . g)
20:38:54 <Cale> and as it happens, if fmap id = id, then in Haskell, it's impossible for the second law not to hold.
20:40:18 <monochrom> Hey, I once had fun exemplifying to a student the corresponding between (Int, Int) and Bool->Int.
20:40:32 <monochrom> s/corresponding/correspondence/
20:40:58 <jusss> Cale: think function like (0,1) and (e->) in fmap, would be (0,) ?
20:41:35 <jusss> that "container" or "wrapper" stuff in every Functor article
20:41:40 <jusss> or Monad
20:42:15 <jusss> geekosaur: what it's used for like (e->) ?
20:42:22 <jusss> in fmap, of course
20:42:40 <jusss> what this abstract stuff is used to?
20:42:42 <Cale> jusss: Let's use monochrom's example and consider functions of type Bool -> Int
20:43:16 <Cale> jusss: You can fully characterise such a function by what it gives when applied to False and True
20:43:37 <monochrom> Yes, I did this to my student precisely because they were learning functor-applicative-monad and they still drew a pretty clear line between "container" and "function".
20:43:38 <Cale> So, Bool -> Int is similar in nature to (Int, Int)
20:44:09 <Cale> Given a function f :: Bool -> Int, we can turn it into a pair (f False, f True)
20:44:40 <Cale> and given such a pair (x,y), we can turn it into the function (\b -> case b of False -> x; True -> y)
20:48:18 <jusss> a partial applied function may be a functor?
20:48:45 <monochrom> No. A type of kind *->*
20:48:50 <nisstyre> Cale: would it be more like a 2 element set?
20:49:00 <nisstyre> 2 elements of pairs that is
20:49:09 <nisstyre> (if you're defining functions as sets)
20:49:13 <monochrom> (->)Bool is a type of kind *->*. This is not a partially applied function. This is not even at the term level.
20:49:51 <jusss> monochrom: (->) Bool is not * -> ?
20:50:01 <jusss> it lacks a type
20:50:03 <monochrom> Set loses the sequential structure.
20:50:21 <monochrom> {1,2} /= (1,2).
20:50:33 <monochrom> Because {2,1} = {1,2} but (2,1) /= (1,2)
20:51:00 <monochrom> Set also loses the multiplicity structure. {1,1}={1} but (1,1) /= (1)
20:51:15 <monochrom> Set loses so much, why would anyone use sets at all?
20:51:47 <monochrom> The kind of (->) Bool is * -> *  there is no typo in this sentence. This is non-negotiable.
20:52:22 <monochrom> Oh it lacks a type? Sure, that's why the kind is not simply *
20:53:20 <monochrom> And yes all confusions are caused by wrong assumptions. Erase all assumptions and start again.
20:53:34 <Cale> jusss: A partially applied type-level function can be a Functor, yes.
20:54:10 <Cale> (if you just say "function" most people will think you mean a value-level function)
20:56:04 <jusss> Cale: what is "type level lambdas" ?
20:56:17 <jusss> or type-level function
20:57:24 <geekosaur> I think you just hit the root of the problem
20:58:57 <geekosaur> [] is a type level function: it takes a type such as Int, and produces a type such as [Int] (which can also be written: [] Int)
20:59:42 <geekosaur> Maybe is a type level function: it takes a type such as Int, and produces a type such as Maybe Int, whose values are Nothing or (Just some_Int_goes_here)
21:02:14 <jusss> what's the type-level function related with functor?
21:03:18 <geekosaur> Functor itself, which is defined as a typeclass. each type with a Functor instance specifies what that means.
21:04:40 <geekosaur> however, it's not quite a type level function; it's a constraint. type level functions can't say "I accept only certain types", it has to accept any type with the correct kind; so we have constraints that can say that.
21:05:26 <geekosaur> that is, Maybe can't say (Maybe Int) is valid but (Maybe Integer) isn't. Constraints can.
21:06:55 <jusss> geekosaur: oh, Maybe and e-> both need a type to complete
21:07:13 <geekosaur> yes, because both have the kind * -> *
21:08:09 <geekosaur> in the case of Functor, one of the types is supplied by and controlled by Functor, so you have to omit that type when defining instances of it.
21:09:03 <geekosaur> so there is Instance Functor Maybe where ... -- this instance doesn't get to say "Maybe _what?_"
21:09:41 <geekosaur> and there is instance Functor ((->) e) where ... -- this instance doesn't get to say "function produces _what?_"
21:15:30 <jusss> geekosaur: those Functors they don't have the same behavior, right?
21:15:49 <geekosaur> they have conceptually similar behavior. not identical behavior
21:15:50 <jusss> like list and function in fmap
21:16:31 <jusss> geekosaur: that conceptually similar behavior is just they all need a type to complete
21:16:45 <geekosaur> no
21:18:17 <jusss> fmap :: (a->b) -> (e->a) -> (e->b)    fmap (*100) (+3)  that return type would be ?
21:18:18 <geekosaur> "adding two numbers together" and "adding two strings together" (concat) are conceptually similar, but different. in this case, the concept behind Functor is a bit trickier than that: given Thing a for unknown a, and a function (a -> b), produce Thing b
21:19:11 <geekosaur> in your case, a and b happen to be the same type, so fmap :: (a -> a) -> (a -> a) -> (a -> a)
21:19:45 <jusss> geekosaur: what I express is the return type would be the same with (*100)
21:19:46 <geekosaur> because (*) and (+) both require the same types everywhere
21:20:14 <[Leary]> The conceptual behaviour is that for any Functor `f`, whenever `x :: f a` would produce a `y :: a`, `fmap g x :: f b` would instead produce `g y :: b`.
21:23:21 <[Leary]> fmap intercepts and augments the production of values, whether that production is by indexing a list, pattern matching on Just, or applying a function.
21:23:31 <[Leary]> etc
21:24:14 <Cale> jusss: It's important to notice that the values that fmap is modifying in the case of lists might not all be in memory at the time as well
21:24:22 <Cale> > fmap (*10) [1..]
21:24:24 <lambdabot>  [10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,...
21:24:33 <Cale> ^^ you can fmap over an infinite list :)
21:25:24 <Cale> > [fmap (*10) (\x -> x+1) n | n <- [0..]]
21:25:28 <lambdabot>  [10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,190,200,210,...
21:25:32 <geekosaur> "but they're not the same kind of things" that is why it's a typeclass, so each type can specify what fmap means for that type. for functions, it means function composition. for lists, it means applying a transform to every member of one list, producing a new list.
21:26:33 <jusss> geekosaur: and they all have the same type signature, that's wonderful
21:26:40 <jusss> magic?
21:27:02 <geekosaur> not magic, that's the point of typeclasses. the Functor constraint basically *means* that.
21:27:04 <Cale> Well, that's what type classes are for: classifying types for which similar functionality can be provided
21:27:29 <geekosaur> similarly there is a Monoid constraint that captures the idea that addition, multiplication, list concatenation, etc. all do "something similar"
21:30:08 <jusss> find the similar and use it to do what?
21:32:53 <geekosaur> whatever you need to do. people find lots of uses for fmap. people find a number of uses for mappend (the combining operation of Monoid). Monad captures the idea of combining "actions" of some variety, which is fairly useful.
21:33:39 <geekosaur> Num captures the idea of "number" that you can do addition, subtraction, etc. with, so we don't have to have separate add_Int, add_Integer, add_Double, etc..
21:34:48 <geekosaur> Enum captures the idea of "preceding / following value"
21:37:13 <Cale> jusss: Here's a cool example with Monoid. There is a Monoid instance for Ordering, the type of result that "compare" gives, consisting of EQ, LT, GT for "equal", "less than" and "greater than"
21:37:36 <Cale> What that Monoid instance does is as follows:
21:37:39 <Cale> EQ <> y = y
21:37:45 <Cale> x <> _ = x
21:38:03 <Cale> So, if the first comparison gives EQ, use the second, otherwise, use the first.
21:38:43 <Cale> Also, there is an instance (Monoid a) => Monoid (e -> a) where (f <> g) x = f x <> g x
21:39:26 <Cale> Putting these things together, we automatically have Monoid (e -> Ordering), and then Monoid (e -> e -> Ordering), i.e. we're allowed to combine functions which make comparisons
21:39:56 <Cale> > sortBy (comparing length <> compare) (words "here is a bunch of words to sort by length and then alphabetically")
21:39:58 <lambdabot>  ["a","by","is","of","to","and","here","sort","then","bunch","words","length"...
21:41:32 <Cale> Monoids show up everywhere. Combining configurations, combining queries for data, combining summary information about subtrees of a tree (the associativity of the combination is what lets us rebalance the tree efficiently without recomputing everything)
21:42:44 <Cale> Nearly every tree-based algorithm in computer science is exploiting trees that are annotated with some monoid at the branch nodes which summarizes the data at the leaves.
