00:00:59 <jgt> xunsmdlo: probably none
00:01:04 <ski> @type maximumBy  -- xunsmdlo ?
00:01:05 <lambdabot> Foldable t => (a -> a -> Ordering) -> t a -> a
00:01:23 <ski> @type maximumBy (comparing snd)
00:01:25 <lambdabot> (Ord a1, Foldable t) => t (a2, a1) -> (a2, a1)
00:01:27 <jgt> xunsmdlo: you can compose your own function out of smaller pieces for this
00:06:53 <dminuoso> Im quite glad that Haskell has no implicit conversions of numeric types...
00:07:26 <dminuoso> The sheer amount of C/C++ bugs I have experienced in my lifetime due to implicit numeric conversions doing exactly the thing you don't want...
00:12:26 <Axman6> let alone JS
00:13:14 <ocramz> morning!
00:13:27 <xunsmdlo>   parse error (possibly incorrect indentation or mismatched brackets)
00:13:27 <xunsmdlo>    |
00:13:27 <xunsmdlo> 70 | countcollatz :: Integer -> [(Integer,Int)]
00:13:39 <xunsmdlo> now what jesus
00:22:32 <jgt> xunsmdlo: I can understand your frustration, but of all the error messages GHC could have given you, that one is _really_ clear
00:22:44 <jgt> xunsmdlo: it's probably time to brew some coffee, go outside, and stretch your legs
00:23:29 <xunsmdlo> I'll finish this and go to bed
00:25:07 <jgt> hint: the parse error is usually _before_ the line it reports to you
00:25:54 <jgt> the line you provided looks fine to me, so it probably isn't this line
00:27:36 <xunsmdlo> It compiled :]
00:30:22 <xunsmdlo> now I can test the Collatz conjecture lol
00:48:30 <jgt> ocramz: good morning
02:08:50 * hackage membership 0 - Indices for type level lists  https://hackage.haskell.org/package/membership-0 (FumiakiKinoshita)
02:22:08 <jgt> this was amusing: my Haskeller colleagues are all Russian, and one of them came up with a type called UserSimpleSearchResult. He then wrote a function that maps a database row representing a user to this type, and the function ended up being called `userRowToUSSR`
02:32:39 <absence> jgt: now you just need a CartesianClosedCategoryProducer :)
02:34:26 <absence> Data.Map has fromList, but not fromFoldable. is there no advantage over fromList . Foldable.toList?
02:52:13 <jgt> absence: bravo :D
03:04:55 <dminuoso> How can I disable code generation with cabal new-build using command line flags?
03:05:04 <AfC> jgt: nice
03:06:43 <AfC> Axman6: is the TVar a performance bottleneck?
03:16:50 * hackage pairing 0.3.1 - Optimal ate pairing over Barreto-Naehrig curves  https://hackage.haskell.org/package/pairing-0.3.1 (sdiehl)
03:21:20 <zincy> https://pastebin.com/UVzwNPL9
03:22:02 <zincy> I have no idea what is going on there with cabal versioning come someone shed some light?
03:24:02 <dminuoso> zincy: Check your cabal file.
03:24:39 <zincy> I am using the package.yaml file
03:25:00 <zincy> so when I delete my cabal file and run stack build a new cabal file is generated from that
03:25:29 <dminuoso> zincy: package.yaml is just input for hpack, a cabal file is generated regardless.
03:25:44 <zincy> ok
03:25:54 <dminuoso> zincy: And its the cabal file that really matters.
03:26:22 <zincy> Ah never new that - I feel really naive about this stuff
03:26:23 <dminuoso> zincy: (So stack has some hpack integration to compile package.yaml into a cabal file, and then use that cabal file to build the project)
03:26:28 <zincy> cabal-version: 2.2 apparantly
03:26:37 <dminuoso> There you go then.
03:26:55 <dminuoso> Perhaps there's some hpack directive that causes this? Or perhaps its an hpack version problem? Im not sure.
03:27:09 <zincy> So is that a bug in hpack probably?
03:27:17 <dminuoso> zincy: Can you gist your package.yaml file?
03:27:24 <dminuoso> zincy: and perhaps your stack.yaml file?
03:28:01 <zincy> Which would be https://pastebin.com/WYXM4MYw
03:28:23 <zincy> ^ package.yaml
03:28:50 * hackage elminator 0.2.3.0 - Generate ELM types/encoders/decoders from Haskell types.  https://hackage.haskell.org/package/elminator-0.2.3.0 (sras)
03:29:00 <zincy> stack.yaml -  https://pastebin.com/G66W9CTy
03:34:02 <dminuoso> zincy: Honestly no idea. You could just get rid of hpack I guess..
03:34:19 <dminuoso> hpack does not seem to be adding much value - quite the opposite actually.
03:37:06 <lyxia> what is your version of stack
03:37:36 <zincy> stack -Version 1.9.3, Git revision 40cf7b37526b86d1676da82167ea8758a854953b (6211 commits) x86_64 hpack-0.31.1 
03:38:00 <zincy> dminuoso: no worries - really appreciate your time though looking into it
03:39:30 <lyxia> ok it seems the Cabal version is somehow tied to the resolver
03:39:43 <lyxia> can you pick a newer resolver?
03:41:38 <zincy> lyxia: yes will try with 13.21
03:58:59 <zincy> lyxia: And it works :)
05:06:18 <bahamas> when using the extra-libraries cabal field, does the name have to match the file name exactly? in the cabal file it's "jvm". on my file system it's libjvm.so
05:06:58 <cocreature> bahamas: it has to match such that -l<libname> works
05:07:17 <cocreature> so if the file is called libjvm.so, jvm should be fine since the linker will accept -ljvm
05:08:02 <bahamas> cocreature: then I'm missing something, because it can't find it. I'm doing cabal new-build --extra-lib-dirs=/path/to/libjvm/dir
05:10:39 <cocreature> bahamas: iirc new-build doesn’t make CLI options like extra-lib-dirs global, they only apply to your current package. So try specifying it in a package specific section in your cabal.project file, see https://github.com/haskell/cabal/issues/2997#issuecomment-244293196 for an example
05:12:54 <bahamas> cocreature: the problem is that libjvm is provided by nix
05:13:31 <bahamas> there's no way to specify it on the command line?
05:14:16 <bahamas> cocreature: putting the dir in LIBRARY_PATH seems to do it
05:17:06 <hazkal> Hey. Are there any Haskell books out there for people with no Haskell experience but lots of programming experience?
05:17:32 <bahamas> hazkal: there was one. let me see if I find its name
05:19:11 <bahamas> I guess I remembered incorrectly
05:22:43 <bahamas> I don't know why everyone targets haskell books to absolute beginners
05:25:18 <__monty__> hazkal: Maybe check out the "Gentle introduction."
05:25:51 <hazkal> __monty__: Isn't that outdated?
05:26:02 <hazkal> Also, why the heck so many people join and leave this channel?
05:26:33 <bahamas> hazkal: looks like a network issue. there was a word for this. I forget
05:26:49 <__monty__> @where gentle
05:26:49 <lambdabot> http://www.haskell.org/tutorial/
05:27:47 <__monty__> What are you actually looking for if you consider that outdated? RWH is generally considered dated but that's because it focuses on "real world" application. The gentle introduction is more about the concepts.
05:28:38 <__monty__> If you're looking for an "If you want to do X use lib Y." you're SOL. That's just not how the haskell ecosystem rolls.
05:30:58 <yushyin> hazkal: you often see that with people using matrix.org, most of us filter join/part messages anyways
05:31:09 <yushyin> bahamas: netsplit?
06:22:16 <halogenandtoast> Is something like this just not possible? https://gist.github.com/halogenandtoast/391434e9b709c6abe330ece1f5addb61
06:22:33 <halogenandtoast> I might be misunderstanding ExplicitForAll (among other things)
06:23:54 <lyxia> halogenandtoast: you want ScopedTypeVariables
06:24:06 <jgt> halogenandtoast: I'm guessing and I have no idea, but maybe you want ExistenialQuantification
06:24:17 <jgt> https://ocharles.org.uk/guest-posts/2014-12-19-existential-quantification.html
06:24:47 <lyxia> both ScopedTypeVariables and RankNTypes imply ExplicitForall
06:26:17 <halogenandtoast> lyxia, that seems to at least get me to a different error
06:27:31 <halogenandtoast> somehow it's still not agreeing that my a is the same a
06:27:40 <halogenandtoast> https://gist.github.com/halogenandtoast/391434e9b709c6abe330ece1f5addb61 <-- updated with new error
06:28:28 <lyxia> ok, right, that's not coercible
06:28:47 <halogenandtoast> okay, so it is impossible then
06:29:15 <halogenandtoast> I can't specialize splitAt to handle a Deck of Cardable
06:29:23 <lyxia> coercions don't work well with polymorphic types.
06:30:19 <cocreature> existentials don’t have the same runtime representation since the dictionary needs to be stored somewhere
06:30:30 <cocreature> so you can’t coerce here
06:30:39 <halogenandtoast> I basically want Decks to only contain a single type of card (these can't be mixed), but want some helper methods that work on any type of deck
06:31:43 <halogenandtoast> I considered using GADTs and then just pattern matching each type of Deck, but it ends up with a lot of duplication
06:37:33 <halogenandtoast> with GADTs I can do something like https://gist.github.com/halogenandtoast/cff9539aa6aa29809a98ef99f4b2fdeb
06:37:40 <halogenandtoast> but I feel like the duplication is a mit meh
06:38:38 <phadej> can't there be `newtype Deck a = Deck [a]`
06:38:46 <phadej> I don't see a value of GADT in that example
06:39:54 <halogenandtoast> phadej: I am probably going about it the wrong way but I want to ensure decks can only be of certain types
06:40:12 <halogenandtoast> it has to be a list of cards, but different types of cards can't be mixed together
06:40:27 <phadej> you cannot mix [Int] with [Char]
06:40:42 <phadej> or [Troop] and [Tactic] i nyour case
06:40:59 <phadej> that's already prevents mixing, doesn't it?
06:41:00 <halogenandtoast> Right but a Deck of [Int] shouldn't be possible
06:41:24 <halogenandtoast> because Int is not a "type of" card
06:41:58 <halogenandtoast> Right now the only two possibilities are Deck [Troop] and Deck [Tactic]
06:42:08 <phadej> does it harm, if you never use it? note how your draw :: Int -> Deck a -> ([a], Deck a) is polymorphic in a, if `newtype Deck a = Deck [a]`; then you can be sure that whatever deck you have (Troop or Tactic), the `draw` operates the same
06:42:23 <phadej> but with GADTs, you may be able to draw Troop or Tactic decks differently
06:42:45 <halogenandtoast> phadej: there is no harm, I am just trying to learn how some of the more advanced type-level features work
06:42:46 <phadej> and whether that's a bug for a feature should be explicit decision
06:43:17 <phadej> halogenandtoast: you make things too complicated, when you don't need to; And in this case, i think there is more harm of GADTs than you benefit from them
06:43:18 <halogenandtoast> Trying to figure out what is or isn't possible (regardless of practicality)
06:44:06 <halogenandtoast> phadej: sure, this isn't production code or anything, I am just trying to understand what these things let me do in order to understand and determine their worth
06:44:56 <phadej> halogenandtoast: and I'm saying you that in this case, they aren't their worth :) e.g. the duplication is exactly the price you have to pay, as you **can** handle different decks differently now
06:45:58 <halogenandtoast> Right, I agree with that assessment in this case, I don't yet have a way where drawing is different (when it is valid for you to draw can be different though).
06:46:08 <halogenandtoast> But that's not entirely a reason to use them
06:47:06 <halogenandtoast> personally I like the newtype approach, I just wanted to see how far down the rabbit hole I could go
06:47:24 <phadej> anyway, I find it's more interesting to figure out how to do things without resorting to advanced features
06:47:56 <phadej> in my experience, you get better code without using all possible features
06:48:49 <phadej> I'm not sure how educative is to do something which can be (simply) done without complex features, using the complex features
06:48:59 <phadej> complicating for the sake of complicating? not useful skill.
06:49:06 <halogenandtoast> phadej: then how do you learn when or how to use complex features?
06:49:16 <halogenandtoast> I wasn't complicating it to complicate it
06:49:22 <halogenandtoast> I was trying to figure out if this was how to use it
06:49:30 <phadej> halogenandtoast: that's indeed a good question. One have to find a problem where one cannot simply do without
06:49:32 <halogenandtoast> and even if it wasn't get a better understanding of what it does
06:50:25 <phadej> usual example for GADTs, is well typed expressions
06:50:31 <halogenandtoast> phadej: how do you know which tool you need, when you've never seen the tool ;)
06:50:35 <phadej> but that might be a bit too abstract
06:50:51 <halogenandtoast> Anything can be a hammer if you try hard enough
06:50:54 <ski> <ski> halogenandtoast : how much of the code manipulating decks needs to know the type of card ?
06:51:35 <halogenandtoast> ski: basically it's related to whether or not the player can draw from a deck, the actual drawing from a deck, and determining if the game is over
06:51:52 <halogenandtoast> only 1 deck can end the game, 1 deck has logic as to whether or not a player is allowed to draw from it
06:52:15 <halogenandtoast> There may be other effects in the game that could modify these
06:56:06 <halogenandtoast> I think doing something like https://gist.github.com/halogenandtoast/4c588ac90f5c878e046e5e2dff68c126 is perfectly valid for this
06:56:47 <halogenandtoast> or draw n = second Deck . splitAt n . coerce
06:58:13 <halogenandtoast> but the coerce there is probably overkill
07:00:45 <halogenandtoast> and if I wanted to be "fancy"
07:00:46 <halogenandtoast> draw :: forall a. Int -> Deck a -> ([a], Deck a); draw = coerce (splitAt @a)
07:04:50 * hackage elminator 0.2.3.1 - Generate ELM types/encoders/decoders from Haskell types.  https://hackage.haskell.org/package/elminator-0.2.3.1 (sras)
07:12:03 <dmoerner> Question about cabal-install: I was looking on hackage and 2.2.0.0 requires (base >=4.6 && < 5), but the 2.4.x series requires (base >= 4.8 && < 4.13). Is cabal-install 2.2.0.0 some sort of special, forwards-compatible long-term stable release, or were its base requirements just a bit over-optimistic about when and how base would be incremented?
07:13:04 <glguy> Just more optimistic
07:13:06 <dmoerner> I guess that looking at the Cabal requirements shows that it must be the second options
07:13:10 <dmoerner> Thanks
07:16:09 <absence> Data.Map has fromList, but not fromFoldable. is there no advantage over Map.fromList . Foldable.toList?
07:18:05 <phadej> not really
07:28:20 * hackage refined 0.4.2.1 - Refinement types with static and runtime checking  https://hackage.haskell.org/package/refined-0.4.2.1 (chessai)
07:32:04 <halogenandtoast> phadej: from our earlier discussion would you consider this to be too complicated? draw :: forall a. Int -> Deck a -> ([a], Deck a); draw = coerce (splitAt @a)
07:32:40 <phadej> nope, in fact, that's cool
07:32:49 <phadej> I don't think you even need to say @a
07:33:11 <phadej> just coerce splitAt
07:33:17 <halogenandtoast> phadej: without it you get
07:33:21 <halogenandtoast> Couldn't match representation of type ???a0??? with that of ???a???
07:33:22 <halogenandtoast>         arising from a use of ???coerce???
07:34:16 <phadej> silly GHC
07:34:28 <halogenandtoast> yup
07:34:45 <phadej> does `draw n d = coerce splitAt n d` work ?
07:35:11 <ski> @ghc
07:35:11 <lambdabot> At least one of the forall'd type variables mentioned by the constraint must be reachable from the type after the '=>'
07:35:16 <halogenandtoast> nah, same issue
07:35:29 <phadej> ok, then you have to typeapply there
07:38:50 * hackage github 0.22 - Access to the GitHub API, v3.  https://hackage.haskell.org/package/github-0.22 (phadej)
07:39:36 <Turdl> Hey everyone, hope you're well
07:41:15 <Turdl> Please could somebody explain why the type signature for "second xs = head (tail xs)" is [a] -> a and not [a] -> [a] -> a? 
07:41:59 <Turdl> Maybe I'm getting confused with how type signatures are generated with curried functions, but would you not have to consider that it takes a list, applies a function on it to create another list before just becoming an element?
07:42:10 <ski> your `second' is only taking one parameter
07:42:54 <ski> the type `[a] -> [a] -> a' does not mean that a list of `a' is transformed into a list of `a', and then that is transformed into an `a'
07:43:12 <aveltras> the type signature doesn't describe what happens inside your function but only it's "interface"
07:43:14 <ski> also, there are no "curried functions"
07:43:37 <jgt> Turdl: fyi, your function could be eta-reduced to this: second = head . tail
07:43:54 <lavalike> it's true that it does what you said, but that intermediate list is not a parameter, it's the value of the expression "tail xs", the type of "second" is the type of "\xs -> head (tail xs)"
07:44:46 <glguy> jgt: that's not eta reduction, it's using (.)
07:45:24 <jgt> glguy: I thought eta reduction was synonymous with pointfree
07:45:58 <ski> no
07:46:06 <Turdl> Much appreciated, so because it returns a value and not another function, you wouldn't say the intermediate type?
07:46:12 <ski> eta reduction claims that `f  =  \x -> f x'
07:46:26 <Turdl> Where tail x returns a value I mean
07:46:38 <jgt> :t tail
07:46:40 <lambdabot> [a] -> [a]
07:46:45 <ski> related to this is function extensionality, which claims that if `f x = g x', for all `x', then `f = g'
07:47:12 <ski> Turdl : you never state the type of intermediate values in a computation, in a type signature
07:47:55 <Turdl> Whereas with a function that had multiple parameters, like foo x y z = x*y*z, the type signature would be Int -> (Int -> (Int -> Int)) because it returns mult x, and then mult x y and then mult x y z before x*y*z?
07:48:11 <ski> Turdl : for the type signature of a function, you state the type of the input, and the type of the output. the "interface" as aveltras said. what you need to know about the function, to be able to call it. what type of input it accepts, and what type of output you're to expect back from it
07:48:48 <ski> Turdl : strictly speaking, all functions in Haskell take a single input. so, all functions have a single parameter
07:49:20 <jgt> ski: glguy if I run hlint on `foo x = head x`, it says "Warning: Eta reduce"
07:49:41 <ski> jgt : yes, i'd say that's a misnomer
07:49:46 <ski> Turdl : if you have something that you *think* of as a function of multiple parameters, then you can *encode* it in Haskell, in mainly two different ways
07:50:03 <glguy> jgt: that's not the same
07:50:14 <Turdl> Thank you very much for all the help
07:50:22 <Axman6> "All functions take exactly one argument" is something you should tattoo to the back of your hand so you don't forget it when learning Haskell
07:50:27 <ski> Turdl : (a) you can use "tupled style", like `fooTupled (x,y,z) = x*y*z'. instead of a tuple, you could have used a record, or a list, or some other compound data structure
07:50:35 <glguy> That's dropping the function parameter and the immediate application of a function to that parameter
07:50:40 <jgt> glguy: why? Because of the difference between composition and application in `head . tail`?
07:51:07 <glguy> . Is just naming the pattern
07:51:09 <ski> Turdl : (b) you can use "curried style", like `fooCurried x y z = x*y*z'. so `fooCurried' is a function that when given `x' will compute a new function that when given `y' will compute a new function that when given `z' will compute `x*y*z'
07:51:16 <glguy> It's not simplifying the term
07:51:50 <Turdl> Tyvm, much appreciated
07:52:17 <jgt> surely I have a lot to learn, but currently I see no practical difference between `head (tail xs)` and `head . tail $ xs`
07:52:48 <ski> Turdl : that said, Haskell *does* have syntactic facilities that *encourages* using curried style, when *encoding* multiple-argument-functions
07:53:06 <lavalike> :t \x y z -> x*y*z
07:53:08 <lambdabot> Num a => a -> a -> a -> a
07:53:10 <lavalike> :t \x -> \y -> \z -> x*y*z
07:53:11 <lambdabot> Num a => a -> a -> a -> a
07:53:13 <Turdl> Would there be any advantages to using "tupled style" over "curried style"? My university notes speak about how currying allows partial application
07:53:44 <lavalike> :t (\x -> \y -> \z -> x*y*z) 42
07:53:46 <lambdabot> Num a => a -> a -> a
07:54:07 <glguy> jgt: eta reduction is specifically the simplification of eliminating a lambda that just applies a function to it's argument
07:54:11 <Turdl> how the "curried style" allows partial application even, apologies if I'm using incorrect terminology
07:54:34 <glguy> Using . Doesn't eliminate anything, it just moves it to the definition of .
07:54:41 <Turdl> ski++
07:54:51 <Axman6> there are definitely times where you would use a function which takes a tuple of arguments, but it's trivial to show that they're isomorphic to the curried version, and it depends on how it's used
07:55:00 <Axman6> :t curry
07:55:02 <lambdabot> ((a, b) -> c) -> a -> b -> c
07:55:04 <Axman6> :t uncurry
07:55:05 <jgt> glguy: using (.) in my example is not really the detail I was focusing on
07:55:05 <lambdabot> (a -> b -> c) -> (a, b) -> c
07:55:16 <Axman6> :t curry . uncurry
07:55:18 <ski> Turdl : i use the term "partial application" for the situation when, given a multiple-argument-function, you supply some, but not all, arguments, yielding a (commonly) multiple-argument-function which still "waits" for the remaining argument(s). but, since Haskell doesn't have multiple-argument-functions, using "partial application" in the context of Haskell is a figure of speech, referring to the multiple-argument-function that you have *encoded* (in tuple
07:55:18 <lambdabot> (a -> b -> c) -> a -> b -> c
07:55:19 <jgt> glguy: the point was I got rid of the explicit `xs`
07:55:25 <Axman6> :t uncurry . curry
07:55:27 <lambdabot> ((a, b) -> c) -> (a, b) -> c
07:55:28 * ski twitches
07:55:49 <ski> (hm, did that got cut off at the end ?)
07:56:00 <barrucadu> It got cut off after "(in tuple"
07:56:07 <glguy> jgt: the point is that there was no eta reduction happening
07:56:12 <ski> ".. (in tupled or curried style) in Haskell"
07:56:14 <ski> barrucadu, ty
07:56:33 <jgt> glguy: ok, so what is the word I am looking for? Just "pointfree"?
07:57:08 <glguy> Sure
07:57:17 <halogenandtoast> what's the way to generate the intermediate representation of a Haskell program with GHC again?
07:57:18 <ski> Turdl : so, considering curried style, e.g. `\x z -> x*3*z' is a partial application of `\x y z -> x*y*z', supplying `y', as an "early argument/formal parameter", with the value (actual parameter) `3'
07:57:54 <ski> Turdl : or, in tupled style, `\(x,z) -> x*3*z' would be a partial application of `\(x,y,z) -> x*y*z'
07:57:56 <jgt> ok, so we should go tell ndmitchell that he's wrong
07:58:02 <glguy> No
07:59:00 <Axman6> My google fu is failing me, I'm trying to find a package which can measure bandwidth through a conduit producing bytestrings. Trying to figure out how many MB/s something is being processed
07:59:27 <glguy> The hlint example isn't related you yours
07:59:29 <ski> Turdl : of course, in curried style, it's particularly easy to partially apply to a prefix of the parameters, since, if `fooCurried x y z = x*y*z', then because of eta conversion, `\z -> fooCurried 2 3 z' is the same as `fooCurried 2 3'
07:59:53 <ski> Turdl : okay ?
08:00:09 <jgt> glguy: ski _did_ use the word "misnomer"
08:00:19 <glguy> Eta reduction does help achieve point free
08:00:29 <jgt> glguy: i.e., "a wrong or inaccurate use of a name or term"
08:00:53 <Turdl> ski: Thank you very much, just trying to wrap my head around that last example using \x y z 
08:00:58 <ski> going from `forall x. foo x = head x', to `foo = head', is exactly function extensionality
08:01:14 <ski> exercise : prove function extensionality is equivalent to eta conversion
08:01:21 <ski> <Turdl> Would there be any advantages to using "tupled style" over "curried style"? My university notes speak about how currying allows partial application
08:02:32 <halogenandtoast> I think what I was looking for was -ddump-simpl
08:03:07 <ski> Turdl : with curried style, you can easily partially apply to a prefix of your parameters. with tupled style, you can easily pass on your "multiple parameters", from being result(s) of one expression, to parameters of a function. in `f (g x)', `g x' could be a tuple, and `f' accept such a tuple as input
08:04:03 <ski> Turdl : if you want to treat multiple things as a single thing, e.g. a number of coordinates for a point or vector, then tupled style may be preferable. you can of course also mix tupled style and curried style
08:04:13 <ski> @type inRange
08:04:14 <lambdabot> Ix a => (a, a) -> a -> Bool
08:04:16 <ski> @type range
08:04:18 <lambdabot> Ix a => (a, a) -> [a]
08:04:31 <ski> these take a pair `(lo,hi)' as input
08:06:47 <Turdl> I know I've said it several times already but thank you so much for all the help, it's really nice to be able to ask what I imagine are relatively simple questions and receive super helpful in depth answers
08:06:55 <ski> > map (inRange (3,7)) [0 .. 9]
08:06:57 <lambdabot>  [False,False,False,True,True,True,True,True,False,False]
08:06:59 <Turdl> Where I'd just be called an idiot or downvoted elsewhere 
08:07:05 <ski> > range (3,7)
08:07:07 <lambdabot>  [3,4,5,6,7]
08:08:10 <Turdl> ski: So I imagine it can be useful if you want to force rigidity in the format of your input/outputs?
08:08:33 <ski> i'm not sure what you mean by "force rigidity in the format of your input/outputs"
08:08:54 <Axman6> Turdl: thanks for asking clear questions, and being clear that you're doing this for a course (we try not to answer people's homework, but help them to come to the answer themselves)
08:09:30 <jgt> Axman6: I see you're still annoyed about the guy from earlier today :P 
08:10:21 <Axman6> not just today, it's been a few days now
08:10:58 <Axman6> they don't acknowledge me when I point out we're doing their homework for them
08:11:12 <jgt> yeah, I noticed
08:13:21 <Turdl> Thanks for putting up with me so far, one last thing before I leave you
08:14:34 <Turdl> Is it possible to get GHCi to give me type signatures using parentheses, like Int -> (Int -> (Int -> Int)) instead of it just simplifying it as Int -> Int -> Int -> Int
08:14:53 <ski> hm, i don't think so
08:15:13 <ski> but you can write those extra brackets in your type signatures, if you prefer
08:15:15 <jgt> Turdl: I don't think it is, and I would just get used to the "simplified" notation anyway
08:15:21 <ski> sometimes i write something like
08:15:28 <jgt> since it's what you will encounter most in the wild
08:15:45 <ski>   map :: ( a  ->  b )
08:15:46 <ski>       -> ([a] -> [b])
08:16:13 <ski> (where the latter pair of (round) brackets is redundant), to emphasize some "pattern"
08:16:39 <ski> in this case, that `map' takes a function on elements, and produces a function on lists
08:16:44 <jgt> I find that more confusing
08:16:48 <ski> therefore, you can type
08:17:16 <ski> > map (map (2 *)) [[0,1,2,3],[4,5,6],[7,8],[9],[]]
08:17:19 <lambdabot>  [[0,2,4,6],[8,10,12],[14,16],[18],[]]
08:17:29 <ski> and not just merely
08:17:38 <ski> > map (\xs map (2 *) xs) [[0,1,2,3],[4,5,6],[7,8],[9],[]]
08:17:41 <lambdabot>  <hint>:1:15: error: Parse error in pattern: 2 *
08:17:47 <ski> er, sorry, that should be
08:17:50 <Axman6> \the brackets are implicit because (->) associates to the right, but it is always to the right. If an argument is a function parens are required
08:17:51 <ski> > map (\xs -> map (2 *) xs) [[0,1,2,3],[4,5,6],[7,8],[9],[]]
08:17:52 <Axman6> :t map
08:17:53 <lambdabot>  [[0,2,4,6],[8,10,12],[14,16],[18],[]]
08:17:54 <lambdabot> (a -> b) -> [a] -> [b]
08:17:55 <ski> or
08:18:19 <ski> > let doubleList xs = map (2 *) xs in map doubleList [[0,1,2,3],[4,5,6],[7,8],[9],[]]
08:18:20 <halogenandtoast> > map (*2) <$> [[0,1,2,3],[4,5,6],[7,8],[9],[]]
08:18:22 <lambdabot>  [[0,2,4,6],[8,10,12],[14,16],[18],[]]
08:18:23 <lambdabot>  [[0,2,4,6],[8,10,12],[14,16],[18],[]]
08:18:40 <ski> > ((2 *) <$>) <$> [[0,1,2,3],[4,5,6],[7,8],[9],[]]
08:18:41 <jgt> hlint says "Warning: Eta reduce" for the (\xs -> map (2 x) xs) above
08:18:43 <jgt> I didn't say it
08:18:43 <lambdabot>  [[0,2,4,6],[8,10,12],[14,16],[18],[]]
08:18:45 <jgt> hlint did
08:18:47 <jgt> don't blame me
08:18:59 <ski> jgt : that would be a case of eta reduction
08:19:16 <jgt> I said it
08:19:17 <jgt> hlint didn't
08:19:19 <jgt> I am right
08:19:30 <ski> by eta conversion, `\xs -> map (2 *) xs' is equal to `map (2 *)'
08:20:50 <ski> if `map' had been tupled, like `mapTupled :: (a -> b,[a]) -> [b]', then one'd have had to say `mapTupled (\xs -> mapTupled ((2 *),xs),[[0,1,2,3],[4,5,6],[7,8],[9],[]])', one couldn't have avoided that `\xs ->' (without using say the `uncurry' function)
08:21:39 <ski> er, sorry, that should be `curry', not `uncurry'
08:21:48 <ski> `curry' can be thought of as a function that converts a two-argument function from tupled style to curried style :
08:22:42 <ski>   curry :: ((a  ,  b) -> c )
08:22:44 <ski>         -> ( a -> (b  -> c))
08:23:05 <ski> (and `uncurry' converts in the opposite direction)
08:24:41 <ski> however, `curry' (in Haskell), can *also* be thought of as a two-parameter function (itself being encoded in *curried* style), that *partially* *applies* a two-argument-function (in tupled style) to its first argument :
08:25:42 <ski>   curry :: ((a,b) -> c)
08:25:51 <ski>          ->   a
08:26:00 <ski>         -> (   b  -> c)
08:26:27 <ski> so, this might have been called `curriedlyPartiallyApply', and then we could have had
08:26:50 <ski>   tupledlyPartiallyApply :: ((a,b) -> c,a) -> (b -> c)
08:29:17 <glguy> jgt: eta-reduction is specifically this pattern: (\x -> f x) -->η f   where x is not free in f 
08:29:59 <glguy> The reason that example x = head x   --> example = head   works is if you don't distinguish between:   example x = head x   and  example = \x -> head x    then its an instance of the pattern
08:31:05 <glguy> eta-reduction is a specific transformation that eliminates redundant lambda abstractions. (rather than the name for an transformation that eliminates a lambda abstraction)
08:31:16 <glguy> for any*
08:31:59 <ski> (exercise : prove `forall x. f x = ..x..' is equivalent to `f = \x -> ..x..')
08:33:03 <glguy> and since eta-reduction is more specific than the general equivalence expressed there (it tells us the direction of the transformation) it's not redundant
08:34:07 <ski> beta-reduction is about eliminating a function abstraction "followed" by a function application, as in `(\x -> ..x..) (...)'. eta-reduction is about eliminating a function application followed by a function abstraction, as in `\x -> ((...) x)'
08:34:15 <bahamas> I'm trying to build a package that will run on the JVM, so it has to compile to java. at some point the build fails with these errors: https://bpaste.net/show/9b3ee3970c82. does this mean that cabal is calling `javac` directly?
08:34:29 <ski> s/reduction/expansion/, if you're going the other way around. "conversion" for the general, bidirectional, rule
08:35:06 <jgt> yeah I'm just gonna say "pointfree" now
08:35:35 * ski prefers the term "pointless" ;)
08:36:06 <jgt> pointless reminds me too much of Richard Osman
08:36:13 <ski> who'se that ?
08:37:24 <jgt> presenter of a British television programme called 'Pointless'
08:37:28 * ski . o O ( "Austin Osman Spare" )
08:38:20 <ski> oh, a fairly recent thing
08:39:40 <jgt> he's the kind of guy who would have a column in The Guardian
08:39:50 <jgt> also he actually does have a column in The Guardian
08:40:18 <jgt> so "pointfree" is what I'll stick with :P
08:41:12 <ski> i suppose i prefer "pointless", since it confers an (imho) more appropriate sense of the seriousness of the matter
08:46:21 * hackage cereal 0.5.8.1 - A binary serialization library  https://hackage.haskell.org/package/cereal-0.5.8.1 (EricMertens)
09:25:34 <halogenandtoast> Do these simpl dumps imply performance differences between these two implementations? https://gist.github.com/halogenandtoast/b8a48442a94f9b8d65ab5d78e00fc568
09:28:39 <phadej> maybe, latter is better, but given an arguments they still may optimise to the same code
09:29:09 <halogenandtoast> phadej: is there any suggested way to verify that?
09:29:49 <phadej> profiling the real code
09:30:13 <Solonarv> actually that looks suspiciously unoptimised
09:30:25 <Solonarv> did you enable optimizations?
09:30:58 <Solonarv> oh, also you can add -dsuppress-all to make the dumps much more readable
09:31:01 <halogenandtoast> Solonarv: probably not ghci -ddump-simpl Main.hs > dump is what I ran
09:31:12 <halogenandtoast> Solonarv: oh good point
09:31:17 <Solonarv> ah, indeed - there are no optimizations in ghci
09:31:28 <Solonarv> you can also add -ddump-to-file
09:31:36 <Solonarv> which does exactly what it looks like
09:33:12 <Solonarv> so in total: ghc -ddump-simpl -dsuppress-all -ddump-to-file Main.hs
09:33:26 <halogenandtoast> I think -ddump-to-file implies the other 2
09:33:53 <halogenandtoast> but maybe not, my test with ghci produces the same output
09:33:54 <Solonarv> that would be very surprising
09:34:13 <Solonarv> there are many things you can tell GHC to dump, not just -simpl
09:34:24 <Solonarv> and you don't always want -dsuppress-all
09:34:36 <Solonarv> (since sometimes the details it hides *are* relevant)
09:35:11 <halogenandtoast> No you are right, if you leave off -ddump-simpl, then -ddump-to-file is a noop
09:35:15 <halogenandtoast> which is why my file looked the same
09:35:19 <halogenandtoast> as it wrote nothing
09:37:44 <halogenandtoast> Solonarv: one reason I was using ghci instead of ghc was to avoid defining main
09:37:56 <halogenandtoast> do you know if there is a ghc option to ignore the missing main
09:38:28 <halogenandtoast> I tried -no-hs-main, but that doesn't do it
09:43:20 <nshepperd> -c
09:45:03 <Solonarv> halogenandtoast: you just need a module header
09:45:14 <Solonarv> e.g. 'module BifunctorExample where'
09:45:30 <halogenandtoast> hmm alright
09:45:38 <Solonarv> if there's no module header then the module name is Main and there must be a main action defined
09:45:54 <halogenandtoast> For stack is there a way to install a global haskell version, one system is 8.0.2 and another 8.4.4 and I'd like them both to be 8.4.4
09:46:39 <Solonarv> stack doesn't use a globally-installed GHC
09:46:57 <Solonarv> you can pick a GHC per-project and stack will take care of installing it, in isolation
09:47:31 <halogenandtoast> sure, I mean to say I added ~/.stack/programs/x86_64-osx/ghc-8.0.2/bin to my path and I'd like to setup 8.4.4 to do the same
09:47:51 <halogenandtoast> Actually I'll just drop that and so something else
09:47:53 <halogenandtoast> nvm
09:47:58 <Solonarv> I suggest ghcup >:
09:48:00 <Solonarv> :>
09:48:28 <Solonarv> I've actually used it now and it works perfectly as far as I can tell
09:54:51 <halogenandtoast> Solonarv: in the simpl dumps, what is the way to convert <Co:15> style information
09:55:04 <halogenandtoast> i.e. draw = splitAt `cast` <Co:15>
09:55:26 <halogenandtoast> convert is the wrong word, I mean to say, how do I know what that means
10:04:50 <halogenandtoast> Also, thanks for all the information, it has been super helpful
10:18:40 <ilmu> can anyone give me an idea how hard it would be to write a weechat plugin in haskell as a newbie learning project?
10:19:13 <Solonarv> halogenandtoast: oops, didn't see your earlier message
10:19:52 <halogenandtoast> Solonarv: no worries, I didn't go anywhere
10:20:06 <Solonarv> halogenandtoast: <Co:15> is a coercion - it's short for the whole (<Deck a_a1P3>_R ->_R Main.N:Deck[0] <a_a1P3>_N :: (Deck a_a1P3 -> Deck a_a1P3 :: *)
10:20:06 <Solonarv> ~R# (Deck a_a1P3 -> [a_a1P3] :: *)))) nonsense
10:21:04 <halogenandtoast> Ah alright, is that documented somewhere
10:21:17 <Solonarv> probably somewhere
10:21:19 <halogenandtoast> I tried to look up what the stuff in simpl meant, but couldn't find a good resource
10:21:49 <halogenandtoast> Solonarv: no worries then, if you don't know off hand I can keep looking
10:22:00 <Solonarv> here: https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/fc
10:22:03 <boj> ilmu: "hard" if you aren't sure how to interface with weechat's API via FFI
10:22:17 <Solonarv> this explains the theory behind GHC Core, including casts
10:22:51 <Solonarv> note that casts don't exist at runtime, so if you just want to look at performance you can ignore them
10:23:15 <halogenandtoast> Solonarv: right, thanks!
10:23:16 <Solonarv> (this is why -dsupppress-all is helpful: it hides the details inside each coercion, since those don't matter most of the time)
10:24:15 <ilmu> boj: yeah that's what I ment by the question, could have been more clear, like: Where do I get started looking into how to do it? or something
10:24:35 <ilmu> but yeah FFI, I'll go read
10:25:25 <Solonarv> projects requiring FFI are probably not a great idea as a beginner's first project, tbh
10:26:14 <boj> i was thinking the same, but then realized that as a seasoned developer having a solid goal is a good motivator
10:27:14 <Solonarv> that is also true
10:27:38 <Solonarv> it's just that you'll be learning how to FFI at the same time that you're learning how to Haskell
10:27:52 <Solonarv> and learning more stuff at the same time is obviously harder :>
10:27:55 <boj> yep
10:31:49 <reallymemorable> I'm using this function from Data.DependentMap `lookup :: forall k f v. GCompare k => k v -> DMap k f -> Maybe (f v)` and I want to be able to feed in a list of possible dmap keys for that first argument
10:31:53 <reallymemorable> ratheer than a specific one
10:31:54 <halogenandtoast> Solonarv: so out of curiosity with this https://gist.github.com/halogenandtoast/64db4e7cfb7f48d0610e27e9cbc46dbc would it make sense that reasonably, once the casts are gone, then the function being passed to second is id so it should remove that?
10:31:59 <reallymemorable> whats the best wayy to approach this
10:32:08 <boj> i struggle with finding ways to nicely tell someone that, no really, the haskell part of the problem is going to be a struggle regardless of your experience level with programming
10:33:00 <halogenandtoast> boj: A reasonable analogy is like learning a new spoken language, a lot of the constructs may be the same, but without a working knowledge of what composes it as well as the culture, you'll be lost
10:33:57 <boj> halogenandtoast: my former C# developer didn't take that analogy very well when i used it (delivered as a second language learner myself)
10:34:31 <halogenandtoast> boj: sure but a lot of spoken languages are similar, as an English speaker, any tonal languages may be extremely difficult for me
10:35:11 <halogenandtoast> Just because you know 2 or 10 languages, doesn't mean you can proficiently use an 11th, without actually learning it
10:35:37 <halogenandtoast> and it doesn't guarantee that learning it will be sufficiently easy
10:36:02 <boj> right, we are in agreement there
10:36:12 <halogenandtoast> The correct answer then
10:36:17 <halogenandtoast> was to fire your C# developer
10:36:27 <halogenandtoast> ;)
10:36:30 <boj> it is just hard to talk those people back down to "so, writing a calculator in haskell is a good first project..."
10:36:36 <boj> lol
10:36:42 <MarcelineVQ> or an alarm clock :>
10:36:56 <halogenandtoast> I basically write the same set of programs in each language I want to learn
10:37:14 <halogenandtoast> generate a random number, write a guess my number game, write hangman, write sokoban
10:38:08 <halogenandtoast> examples: https://github.com/halogenandtoast/randl
10:39:11 <boj> in my case i pair program features with people over the course of a few weeks
10:39:37 <boj> so far so good. 9 non-haskellers all trained up
10:39:54 <halogenandtoast> boj: where does your definition of all trained up finish
10:39:56 <halogenandtoast> out of curiosity
10:40:00 <MarcelineVQ> 9? You makin' money at that :>
10:40:21 <boj> halogenandtoast: releasing production features without my help :)
10:40:40 <boj> i code review everything of course, but rarely have to make comments these days
10:41:13 <halogenandtoast> Sure, that's an ideal metric ;)
10:41:47 <boj> C# developer recently wrote some type family code i did not understand, so he clearly leveled up :D
10:42:00 <halogenandtoast> That right there might be a testimate to Haskell, I've tried numerous times to train Java developers to use Ruby, and it always takes more than a few weeks
10:42:36 <boj> for sure, it took an average of 1-3 months per person depending on temperment, prior skill, and amount of things to unlearn
10:43:30 <Solonarv> halogenandtoast: no, that isn't the case
10:43:50 <Solonarv> there is no rule that rewrites 'second (<cast here>)' to <different cast here>
10:44:21 <Solonarv> although I do find it strange that GHC doesn't inline the Bifunctor (,) dictionary there; maybe try -O2 ?
10:45:28 <halogenandtoast> Solonarv: that starts getting trippy
10:45:51 <MarcelineVQ> reallymemorable: What have you tried?
10:45:57 <halogenandtoast> Solonarv: https://gist.github.com/halogenandtoast/1890e512ff4a533d6850260c2a6b30a4
10:46:49 <phadej> Solonarv: if you look at http://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Bifunctor.html#line-114
10:46:57 <phadej> you can notice that second = bimap id
10:47:21 <phadej> and bimap is defined (for pairs) as bimap f g ~(a, b) -- so I think GHC waits for last argument to appear to do the magic
10:47:42 <phadej> or something like that
10:48:24 <phadej> (i.e. in (,) bifucntor dictionary second g ~(a,b) = (a, g b))
10:49:04 <phadej> not sure, one have to dump .hi of Data.Bifunctor to see what's there
10:57:15 <isovector1> anyone know if there's an easy place to get in touch with ndmitchell?
11:01:47 <ski> @quote ndm
11:01:48 <lambdabot> ndm says: If you do things like this, randomly changing the semantics of functions, people will come round to your house with burning pitch forks!
11:03:35 <davean> I always like a good pitchfork burning.
11:04:15 <jkachmar> isovector1: Honestly I think Twitter might be your best bet
11:06:09 * ski reads those two messages as referring to the same topic
11:09:03 <isovector1> jkachmar: oh no :( i dont do that
11:09:40 <jkachmar> idk, want me to tweet at him and see if he responds?
11:09:43 <MarcelineVQ> you're one of the good ones, isovector1
11:11:31 <isovector1> jkachmar: was hoping to have a five minute chat with him about "where is a good place to inject some logic into ghcid"
11:11:54 <isovector1> i'm sure i can work it out in thirty minutes, but a quick chat seemed easier :)
11:12:08 <isovector1> not sure if farming out the communication to someone else would be as fruitful or fast though
11:13:09 <cocreature> isovector1: he’ll be at zurihac if you can wait two weeks. otherwise github issues and email should work reasonably well or as jkachmar mentioned twitter
11:13:39 <ski> (thirty minutes, or two weeks, tough choice)
11:13:51 <isovector1> cocreature: i won't be, alas
11:14:00 <cocreature> isovector1: ah that’s a shame :(
11:14:13 <isovector1> that being said, if someone wants to sponsor my trip i'd more than happily come ;)
11:15:42 <cocreature> just spend some of the millions that you made from the sales of “thinking with types” ;)
11:16:13 * ski . o O ( "Now you're thinking with types." )
11:16:21 * hackage digraph 0.1.0.0 - Directed Graphs  https://hackage.haskell.org/package/digraph-0.1.0.0 (larsk)
11:16:53 <isovector1> i'd consider it if zurich weren't the MOST EXPENSIVE CITY IN THE WHOLE DANG UNIVERSE
11:18:17 <halogenandtoast> Thinking with Types is a great book btw, as was your blog post about Csongor
11:19:20 <halogenandtoast> Although the Tic Tac Toe example grinds me a bit as it because exponentially less easy when you think about how to update the board
11:19:48 <halogenandtoast> I assume you'd write a function that wraps the previous board except for the Triple you care about
11:20:54 <halogenandtoast> s/Triple/Three/
11:21:37 <isovector1> thanks for the kind words! iirc that example got added late in the lifecycle of the book, so it probably wasn't as well covered as it should have been
11:22:31 <halogenandtoast> I mean it's a really neat example
11:22:38 <halogenandtoast> for an empty board *D
11:22:41 <halogenandtoast> :D
11:31:22 <halogenandtoast> isovector1: out of curiosity, in your interpretation, would making a move look something like this? https://gist.github.com/halogenandtoast/7f90354016b861ec92b3cdc751dde210
11:33:35 <isovector1> halogenandtoast: lgtm. ship it
11:36:32 <Solonarv> you could also write the lambda like this: \x' y' -> (xo <$ guard ((x,y) == (x',y'))) <|> board x' y')
11:44:39 * ski . o O ( `replace :: Int -> (a -> a) -> ([a] -> [a])' )
11:52:14 <halogenandtoast> Solonarv: do you see a lot of benefit to writing it that way?
11:52:21 <halogenandtoast> I haven't used `guard` a lot
11:52:30 <halogenandtoast> so not sure how idiomatic it is in the wild
11:55:30 <Solonarv> eh
11:55:39 <MarcelineVQ> pretty common, but your version is immediately clear
11:56:08 <Solonarv> I personally like 'foo <$ guard <condition>' and find it quite readable, but idk how common it is
11:59:25 <MarcelineVQ> next step MonadComprehension version
12:02:43 <cocreature> [foo | guard 
12:02:49 <cocreature> [foo | condition]
12:02:54 * ski . o O ( "Comprehending monads" by Philip Wadler in 1992 at <http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#monads> )
12:05:13 <cocreature> I’m slightly disappointed that this incurrs a Monad constraint
12:06:37 <ski> @type guard  -- oh, right. this uses `Alternative', nowadays
12:06:38 <lambdabot> Alternative f => Bool -> f ()
12:07:30 <cocreature> it does desugar to Alternative but it gets a useless Monad constraint in addition to that
12:07:41 <cocreature> :t \f c -> [f | c]
12:07:43 <lambdabot> a -> Bool -> [a]
12:07:50 <cocreature> % :set -XMonadComprehensions
12:07:50 <yahb> cocreature: 
12:07:57 <cocreature> % :t \f c -> [f | c]
12:07:57 <yahb> cocreature: (Monad m, Alternative m) => b -> Bool -> m b
12:08:18 <lavalike> that looks almost like bra-ket
12:08:26 <cocreature> and ApplicativeDo doesn’t help either. Not that I expected it to but it was worth a try anyway :)
12:10:17 <MarcelineVQ> there's no skin in the game luckily, Maybe is already a Monad
12:11:21 <lavalike> MarcelineVQ: what do you mean?
12:11:42 <cocreature> this wouldn’t be #haskell if we stopped once we’ve solved the actual problem at hand :)
12:12:22 <MarcelineVQ> lavalike: That there's no generality loss from being constraint to Monad when the golfing is about a Maybe result
12:13:05 <lavalike> sure, I don't get the reference to sitg
12:14:23 <MarcelineVQ> You won't be losing any skin off your nose, since there's none in the game
12:14:47 <lavalike> if anything I'd argue in golfing there's more at stake: soul in the game
12:15:07 <MarcelineVQ> The well of idioms runs deep, especially with applicatives involved
12:16:18 <ski> @hoogle Alternative i => Bool -> a -> i a
12:16:19 <lambdabot> Protolude orEmpty :: Alternative f => Bool -> a -> f a
12:16:19 <lambdabot> Protolude.Applicative orEmpty :: Alternative f => Bool -> a -> f a
12:16:19 <lambdabot> Control.Bool aguard' :: Alternative m => Bool -> a -> m a
12:27:28 <solonarv_> 5/save
12:27:32 <solonarv_> whoops!
12:39:06 <dmoerner> Really basic question: Are ghc package keys always the same length, or can they differ in length between recompiles with different versions of ghc?
13:02:59 <ilmu> þgo 5
13:05:43 <sm> g'day all. Is there a standard short form of "test for equality only if this Maybe is a Just" - something clearer than  fromMaybe x mThing == x  ?
13:07:40 <Solonarv> sm: what should the result be when the Maybe is Nothing? True or False?
13:07:53 <sm> True
13:08:07 <ski>   maybe True (x ==) mThing  -- ?
13:08:09 <cocreature> mThing == Just x
13:08:23 <Solonarv> cocreature: that'll be False when mThing is Nothing
13:08:25 <Solonarv> ski got it
13:08:29 <ski> cocreature, wrong way around
13:08:33 <Solonarv> that's the same thing I was going to type
13:08:33 <cocreature> oh right
13:08:54 <sm> ski's looks nice than mine
13:08:56 <sm> nicer
13:09:13 <sm> I'm wondering about fmap (==)
13:09:19 <ski> perhaps you could do something with `for_' as well ..
13:09:55 <sm> ok. Thanks all!
13:24:16 <dmwit> sm: `all (x==)`
13:24:32 <dmwit> > (all (3==) Nothing, all (3==) (Just 3))
13:24:35 <lambdabot>  (True,True)
13:25:13 <monochrom> Nice.
13:25:14 <sm[m]> dmwit: nice! possibly a tad less clear
13:25:16 <phadej> dmwit: cool
13:26:55 <dmwit> dmoerner: I don't think the key being the same size is part of the contract.
13:27:27 <dmwit> (Indeed, in certain past versions of GHC, they were 0 bits long... ;-)
13:29:34 <ski> dmwit : oh, nice !
13:30:47 * ski tends to forgot operations were generalized from lists
13:31:56 <dmwit> I have created a cellular automata which encodes the Collatz sequence. Now to just find a glider and crack one of the most famous open problems in mathematics wide open.
13:32:50 <monochrom> Or just create a lambda term that encodes said cellular automaton.
13:33:26 <dmwit> Well, I've got that. Obviously the first thing I did after I created it was implement it in Haskell. =D
13:33:39 <monochrom> Oooohhhh
13:40:13 <mniip> just treat it as a category and ponder whether it is thin
13:40:24 <mniip> compute the fundamenal group :D
13:40:56 <dmwit> Is this a joke or is there actually a sensible way of treating a cellular automaton as a category?
13:41:08 <mniip> it's a graph
13:41:11 <mniip> i.e. a quiver
13:41:17 <mniip> you can generate a free category from it
13:41:26 <dmwit> What are the nodes and edges?
13:44:46 <mniip> nodes numbers, edges transisions
13:45:49 <monochrom> I say joke.
13:46:05 <dmwit> But transitions consider a cell and its neighbor. So this is a hypergraph? It's not as clear to me how to convert a hypergraph to a category.
13:46:49 <dmwit> Okay, what. DuckDuckGo says "no results" when I search for "quiver". That can't be right.
13:46:50 <monochrom> However, there may still be an opportunity to publish a paper that proves that the fundamental group problem is undecidable.
14:07:21 * hackage digraph 0.1.0.1 - Directed Graphs  https://hackage.haskell.org/package/digraph-0.1.0.1 (larsk)
14:21:50 * hackage extra 1.6.17 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.6.17 (NeilMitchell)
15:07:14 <sm> what could be different about locale/encoding handling of haskell programs built with nix ?
15:08:17 <sm> eg, this fails with "invalid byte sequence": nix-env -i -f https://github.com/NixOS/nixpkgs/archive/fe41fd.tar.gz -A hledger; curl -s https://raw.githubusercontent.com/simonmichael/hledger/master/examples/unicode.journal | ~/.nix-profile/bin/hledger -f- print
15:08:43 <sm> ..even though LANG is set correctly. If installed any other way, the program runs fine
15:22:17 <jumper149> Hi, can anyone tell me how I can set specific types to specific instances in a class
15:22:41 <jumper149> You can see my problem here: https://github.com/jumper149/haskell-lie/blob/master/src/Lie/LieAlgebra.hs
15:23:26 <jumper149> class LieAlgebra a where
15:23:42 <jumper149>   f :: Double -> a -> a
15:23:52 <jumper149>   g :: a -> a -> Double
15:24:05 <jumper149> I want to be able to set this type Double for the whole class
15:24:29 <jumper149> but make it variable so that it can still be Complex Double for example
15:25:44 <lavalike> jumper149: two ways I know of: functional dependencies and type families
15:27:15 <jumper149> lavalike: ty, are functional dependencies not enabled by default for ghc? I had problems when trying that
15:27:35 <solonarv> they are not
15:27:48 <lavalike> you need FunctionalDependencies yeah, which implies MultiParamTypeClasses
15:27:52 <solonarv> you can enable them with {-# LANGUAGE FunctionalDependencies #-} at the top of the file
15:28:08 <lavalike> incidentally that solution will add another parameter to your class, which is picked by the other parameter
15:28:13 <solonarv> then you can write something like: class LieAlgebra a s | a -> s where ...
15:28:25 <solonarv> and replace all the 'Double's in your class methods with 's'
15:28:53 <solonarv> and then your 'instance LieAlgebra Vector' becomes 'instance LieAlgebra Vector Double'
15:30:03 <jumper149> ok seems fine, but can you explain to me what the '| a -> s' part is for when declaring the class
15:30:11 <lavalike> "such that a chooses s"
15:30:38 <lavalike> i.e. there's only going to be 1 possible choice of s for each choice of a, can't have more
15:30:41 <solonarv> also, there is a 'linear' package which already provides a definition of a vector space; you could build your LieAlgebra on top of that instead
15:31:12 * ski would go `LieAlgebra s a | a -> s', rather than `LieAlgebra a s | a -> s'
15:31:39 <ski> jumper149 : `a' functionally determines `s', in the relation `LieAlgebra s a'
15:31:57 <ski> jumper149 : for each `a', there can be at most one associated `s'
15:33:07 <lavalike> on the other hand the TypeFamilies solution (also a LANGUAGE flag) doesn't require you to change the number of class parameters: class LieAlgebra a where { data Thing a :: a; f :: Thing a -> a -> a; g :: a -> a -> Thing a } or a better domain specific name of course (:
15:33:53 <lavalike> and then each instance can declare what Thing a is for its specific a like: instance LieAlgebra String where { data Thing String = Double; ... }
15:33:54 <solonarv> (the better name here would probably be 'Scalar', imo)
15:34:09 <lavalike> for your very useful lie algebra of strings
15:34:42 <ski> s/data/type/
15:35:32 <lavalike> ah, haven't used it in a while
15:35:49 <solonarv> (associated data families are also a thing, but a different thing)
15:36:40 <lavalike> so this would be an associated type synonym
15:37:16 <jumper149> I think I'm gonna try to implement the functionaldependency approach as it seems to implement the number field in a obvious way
15:37:37 <solonarv> yeah, fundeps are nice for this sort of thing
15:37:53 <lavalike> those two solutions are equivalent for these intents and purposes right?
15:41:02 <solonarv> yup
15:41:34 <solonarv> you can always convert associated type families into fundeps straightforwardly
15:42:17 <solonarv> you can also convert the other way, but that gets complicated (as in: I don't remember how to do it) when the fundeps form loops
15:44:55 <jumper149> ty guys, that was just super smooth to change :)
16:10:43 <Nevoic> Is there anyway to implement ad-hoc polymorphism with x number of class constraints? When I try to make two separate class instances, only differentiating in class constraints, the compiler thinks they're duplicate.
16:12:26 <hpc> they are duplicate - only the parameters to the type class are considered for instance resolution
16:12:27 <Nevoic> I just want to have X number of Y classes (Animal, Bipedal, Swimmer, etc.) and X number of "data" implementations of it (John, MyDog, ADolphin, etc.), and then an ad-hoc polymorphic method that can accept any number of arbitrary combination of Y classes.
16:12:50 <hpc> with ConstraintKinds you can maybe make your constraint a parameter
16:13:33 <Nevoic> Is that the haskelly way of doing it? I'm looking for whatever the simplest, most functional solution is to this type of abstraction.
16:13:56 <Nevoic> Or if you see a different way of abstracting it, I'm coming from an OO background so maybe I'm using too many type classes/instances? I don't know.
16:14:01 <Nevoic> Just looking for general guidance lol
16:14:30 <hpc> ah
16:14:43 <Nevoic> I didn't mean to say X twice in the original example, that was my bad. They can be different in count.
16:15:26 <hpc> you probably want to avoid type classes entirely then
16:15:58 <Nevoic> Alright.
16:16:13 <hpc> avoid writing what in something like java would be a deep inheritance hierarchy, and write data types that do what you need instead
16:16:18 <hpc> ADTs are quite powerful
16:17:46 <Nevoic> My ultimate goal is to allow extensibility in terms of making more data types.
16:18:41 <Nevoic> I'm looking to have a program with lets say 20 arbitrary things (John, Mary, Potatoman, DolphinPerson, etc.) and the ability to pass those things into one method and have the method resolve what to do based on what those "things" are.
16:19:23 <Cale> Note that if things have different types, you're not going to be able to, e.g. put them into a list together.
16:19:30 <ski> if you're thinking of OO stuff, then a plain record-of-"methods" can be useful
16:19:44 <hpc> ski: beat me to it
16:19:50 <Cale> You might want these things to be values of the *same* type but which are constructed differently
16:19:58 <Nevoic> I'm not necessarily thinking OO, I don't think I could do what I want to above with Kotlin/Java generics.
16:20:09 <hpc> instead of class Animal {void makeNoise() {}}
16:20:20 <hpc> data Animal = Animal {makeNoise :: IO ()}
16:20:27 <ski> a "class" (or "class constructor") will be a function that returns such a record
16:21:30 <Cale> Things are sort of mixed up in most typed OO settings because the method implementations are tied to the (most specific) type of the objects.
16:21:31 <hpc> or if you know there's only a finite number of things, data Animal = Dog {old :: Bool, tricks :: [Tricks]} | Cat {lives :: Int}
16:21:42 <Nevoic> Cale: I don't think I want them of the same type, because if I had a type like:
16:21:42 <Nevoic> data Thing = Animal | Bipedal | Swimmer | etc.
16:21:42 <Nevoic> then I couldn't have a Thing that is both Bipedal and a Swimmer.
16:22:07 <solonarv> well, that just means that definition is bad
16:22:22 <Cale> Nevoic: What if you slice it differently? Do you want a record of boolean flags of these properties?
16:22:27 <ski> (`Bipedal',&c. are not types, btw)
16:22:49 <solonarv> perhaps instead you want: data Thing = Animal { isBipedal :: Bool, canSwim :: Bool } | ...
16:23:05 <Nevoic> I'm pretty much looking for some sense of type composition. I want a number of distinct types that can be composed in arbitrary ways into unnamed new types.
16:23:21 <Nevoic> Maybe kinds is the only way to do that.
16:23:25 <Cale> In Haskell, types are always named, and they're only around at compile time.
16:23:30 * ski isn't convinced Nevoic's "types" are really types
16:23:54 <Cale> You just have to think a little bit more about what you actually want
16:23:56 <Nevoic> By "unnamed types" I'm talking:
16:23:56 <Nevoic> (Show a, Swimmer a) => a
16:24:00 <Cale> Think about the operations that you need
16:24:08 <Nevoic> "a" is an unnamed (maybe generic is a better word) type.
16:24:18 <solonarv> actually there has been some research into this, let me find a link
16:24:19 <Cale> and then consider for instance if it's okay just to have a record consisting of all those operations taken together
16:24:30 <hpc> it's a type variable
16:24:44 * ski idly wonders to which extent Nevoic understands the duality between variant/sum types and record/product types
16:25:11 <solonarv> Data Types a la Carte (paper): https://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf
16:25:12 <Cale> Nevoic: But when it occurs like that, you're going to have to pick a specific a whenever you use the thing in question
16:25:35 <Nevoic> Cale: yup, and I know and will define those at compile time.
16:25:45 <Cale> So, that's certainly fine
16:26:53 <Cale> Like, if you have a bunch of Swimmer operations (it really might be much better to use a more realistic example...) that are similarly structured on many of your types, then that's possibly a sensible type class
16:27:13 <Nevoic> There's no realistic example here, I'm just playing with the type system.
16:27:46 <Cale> It's hard to get a good sense for how this stuff gets used with such fake examples though.
16:27:57 <Nevoic> What do you mean by "fake" and "real"?
16:28:01 <Nevoic> What qualifies something as real?
16:28:17 <Nevoic> Stuff that a business would utilize?
16:28:32 <hpc> more or less, yeah
16:28:37 <Cale> I mean whether you have a goal in mind for what the program that you're trying to write is going to accomplish
16:28:44 <Nevoic> Yeah I'm not super concerned with what a business needs Haskell for.
16:28:45 <ski> something that you're not just making up, to play with the ideas ?
16:28:58 <Cale> It doesn't have to be specifically a program that would be used in business
16:28:59 <Nevoic> Everything I've ever coded was something I or someone else made up.
16:29:15 <hpc> animal/cat/dog is too disconnected in terms of meaning to make any determination on the right way to express it
16:29:20 <Cale> It could be a game or a utility or a solution to a programming puzzle, or anything else
16:29:52 <Nevoic> hpc: are you sure you're not just trying to justify potential shortcomings in Haskell's type system? I'm easily able to represent those concepts in OO, and TBH I haven't had much trouble in FP either.
16:29:53 <ski> yes, but the question is which comes first, wanting to play with the ideas (which is fine), or wanting to figure out how to best think about some kind of problem domain
16:29:58 <Cale> Just having a goal when it comes to "it's going to take these inputs and produce these outputs" is a huge help when it comes to determining if what you're doing with an abstraction makes any sense.
16:30:12 <boj> oof
16:30:47 <hpc> Nevoic: you can represent a concept that uses those identifiers
16:31:03 <Cale> Nevoic: If you show me an OO program, I can translate it for you :)
16:31:08 <hpc> depending on what you're using it for, it could just as easily be data Animal = Cat | Dog
16:32:08 <hpc> if you're running a vet clinic, maybe the animal type is just a string in a Visit record
16:32:23 <Cale> The manner in which that translation is going to proceed depends pretty importantly on what your OO classes actually contain, what their subclasses look like and how they're structured -- how many additional methods they might have and whether we can easily collapse a bit of the hierarchy
16:32:25 <Nevoic> I don't exactly get your points, was this just a way of venting that it's harder to help me through examples that aren't connected to something you all value?
16:32:44 <hpc> or if you're writing a strategy game of cats vs dogs, they aren't even compatible types of thing because they behave differently in every way
16:33:14 <Cale> Nevoic: I'm just pointing out that it would be a good idea to just start writing a real program that does something, and then think about these sorts of architectural questions in context, because then the answers will have a real meaning to you.
16:33:34 <Nevoic> I do write real programs in Haskell, I'm just not right now, because I'm exploring shit.
16:33:47 <Nevoic> Mainly because this is fun for me.
16:33:52 <Cale> It's fine to explore shit like this :)
16:33:58 <boj> Nevoic: maybe step back for a bit? take a quick break and come back
16:34:14 <Nevoic> boj: I'd rather not lol
16:34:37 <Cale> I'm just saying that if it seems hard to decide between different strategies for encoding things, having a real program sitting in front of you tends to make those kinds of questions more obvious.
16:34:54 <boj> Nevoic: well, these people are genuinely trying to help you, so take it all with a grain of salt
16:35:23 <Nevoic> Yeah, and I appreciate the help.
16:35:39 <Cale> I would have trouble deciding abstractly which of any of the things we've discussed to use, and I have a lot of experience in that kind of thing -- it's just like we're trying to find a unique solution with not enough equations to pin things down
16:36:19 <Cale> (so there isn't one)
16:37:21 <Cale> There's generally going to be a broad space of possible designs for your functions, types and classes, and often even with real-world constraints, there are lots of tradeoffs to make between them.
16:38:55 <boj> the OOP -> FP learning phase is real
16:39:20 <Cale> As a simple example, if you're writing a game, you might define a type for game objects which simply enumerates using a sum type all the possible objects in the game, and then there's some pattern matching which goes on in various functions to determine how to handle them. This is a decent approach if there are relatively few sorts of objects in the game. You can be certain that you've handled everything, and it's easy to write new 
16:39:20 <Cale> functions which exhaustively handle the cases.
16:39:22 <Nevoic> Yeah I've been at it for a couple months now, and this is like my third go at it.
16:39:23 <boj> (unlearning?)
16:39:55 <Nevoic> It's going to be hard to know if doing all this learning is worth it, but I rarely come out of learning something and regret doing it.
16:39:58 <Cale> By contrast, another approach is to instead look at all the things that you *do* with the game objects, and put together a record consisting of those functions.
16:40:28 <Cale> This will make it easy to extend the number of types of game objects that you have, just by writing new records of these "methods"
16:40:44 <Cale> Of course, they're not actually new *types* in the technical sense.
16:40:58 <Cale> Just new values of a single type of records.
16:42:07 <Cale> Such a type might look something like data Obj = MkObj { timeStep :: DeltaTime -> Obj, react :: UserInput -> Obj, draw :: Picture }
16:42:38 <Cale> The downside of this is that if you want to add new fundamental features alongside these methods, you need to extend all the existing objects.
16:43:26 <ski> it's the basic "OO" vs. "FP" trade-off
16:43:42 <ski> (more like "record/product type" vs. "variant/sum type" trade-off)
16:43:47 <Cale> yeah
16:44:25 <Nevoic> Cale: IK you mentioned earlier that if I made a short OO script you'd translate it for me
16:44:26 <Cale> I tend to associate classical FP with using a bit more sum types, and classical OO with using records of functions
16:44:31 <Nevoic> would you still be down for that? x)
16:44:32 <Nevoic> lol
16:44:49 <Cale> Well, it depends on how large it is, but if you have a good example of what you're aiming at
16:45:05 <Nevoic> Yeah, I'll try to keep it short.
16:45:08 <Nevoic> idk how long it'll be yet.
16:46:24 <Cale> But yeah, the point I'm trying to make here is that we can make different tradeoffs between extensibility in different directions. There *are* ways to get both extensibility in terms of which operations are supported and extensibility in terms of which overall cases we have as well, but these also have downsides
16:47:03 <nshepperd_> I find the idea of trying to find the "right" way of designing some whole class of applications rather unfathomable.
16:47:56 <nshepperd_> My 'process', such as it is, is 'use the right abstraction, not the wrong abstraction'. Which depends on the application!
16:49:05 <Cale> They tend to be more cumbersome in different ways (depending on which strategy you take) -- you're going to need to ensure that enough of the matrix of fundamental cases and operations on them is filled in, and the compiler will be a little less helpful because you haven't specified as clearly up front what the constraints really are.
16:49:45 <Cale> nshepperd_: Yeah, that's what I was getting at before with the talk about "it would be better if we had a real program as our example"
16:50:16 <Cale> A lot of these questions are also not answered completely by what our program *is* but how we expect it to change in the future.
16:55:31 <hololeap> how do you actually use GHC.TypeLits.CmpSymbol ?
16:57:28 <Cale> :k GHC.TypeLits.CmpSymbol
16:57:29 <lambdabot> GHC.Types.Symbol -> GHC.Types.Symbol -> Ordering
16:58:38 <hpc> how is that defined?
16:58:40 <hpc> ghc magic?
16:59:04 <Cale> It's defined as a type family
16:59:11 <Cale> I think the instances are all magical
16:59:18 <lyxia> hololeap: https://hackage.haskell.org/package/symbols uses that a lot
16:59:29 <lyxia> yes it's magic
16:59:35 <hpc> ah, that makes sense
16:59:57 <Cale> :k GHC.TypeLits.CmpSymbol "hello" "world"
16:59:59 <lambdabot> Ordering
17:00:27 <hpc> hmm, is there a way to reduce type aliases?
17:01:27 <hpc> :k (_ ~ GHC.TypeLits.CmpSymbol "hello" "world") => ()
17:01:29 <lambdabot> error:
17:01:29 <lambdabot>     Wildcard ‘_’ not allowed in a constraint
17:01:29 <lambdabot>       except as the last top-level constraint of a type signature
17:01:37 <hpc> :k (?x ~ GHC.TypeLits.CmpSymbol "hello" "world") => ()
17:01:38 <lambdabot> error: parse error on input ‘~’
17:03:30 <Cale> :t let { foo :: ('GT ~ GHC.TypeLits.CmpSymbol "hello" "world") => Int; foo = 5 } in foo
17:03:31 <lambdabot> error:
17:03:31 <lambdabot>     Couldn't match type ‘'GT’ with ‘'LT’ arising from a use of ‘foo’
17:03:44 <Cale> They get reduced in errors, at least :)
17:03:52 <Lears> % :kind! GHC.TypeLits.CmpSymbol "hello" "world"
17:03:52 <yahb> Lears: GHC.TypeLits.CmpSymbol "hello" "world" :: Ordering; = 'LT
17:04:05 <Cale> ah, nice
17:04:08 <hpc> yahb <3
17:34:20 <Sir_Cheer> YOUR MOM
17:37:24 <MarcelineVQ> got 'em
18:53:20 * hackage canon 0.1.1.0 - Massive Number Arithmetic  https://hackage.haskell.org/package/canon-0.1.1.0 (grandpascorpion)
21:40:42 <mac10688> quit
22:14:31 <petersen> Any suggestions on how to build the tls stack now with ghc7 - is the answer just to use new-build?
