00:20:37 <maerwald> it seems shake doesn't propagate signals
00:32:20 <pounce> >change concat to (<>) >program compiles
00:32:22 <pounce> heck
00:32:37 <paulasdf> Is there a way to early exit out of a do notation? For instance, if I have a case statement and in all but one of the cases, the function is recursively called. I would like to do the recursive call after the case statement rather than the recursive call in each case branch. 
00:32:52 <tdammers> pounce: that's because they have different types, no?
00:32:56 <tdammers> :t mconcat
00:32:58 <lambdabot> Monoid a => [a] -> a
00:33:00 <tdammers> :t (<>)
00:33:02 <lambdabot> Semigroup a => a -> a -> a
00:33:21 <tdammers> (m)concat takes a list and concatenates all elements together; (<>) takes two elements and concatenates together
00:33:33 <tdammers> so naturall mconcat oneThing otherThing -- won't work
00:33:37 <iqubic> paulasdf: I have the same query as you.
00:33:37 <jle`> paulasdf: some languages invented after haskell have a nice way to do it buitl into the syntax, but haskell doesn't really
00:33:47 <pounce> oh, heck
00:34:06 <iqubic> Having that would make my Intcode interpert just a bit nicer.
00:34:09 <jle`> paulasdf: can you show your code that you are trying to simplify?
00:34:35 * pounce . o O ++ = <>
00:34:37 <pounce> oh
00:34:49 <iqubic> pounce: for lists, that is true.
00:34:58 <pounce> ye using a list here
00:35:12 <iqubic> In fact (<>) for lists is defined as ++ in the GHC base.
00:35:17 <maerwald> https://github.com/ndmitchell/shake/issues/169 I'm baffled this is known since 2014
00:35:33 <paulasdf> Yeah, it was yesterday's advent of code problem https://pastebin.com/raw/0qPb8Ere
00:35:33 <maerwald> better switch back to 'make' I guess
00:35:48 <iqubic> Ah. I see.
00:36:09 <iqubic> I have the same query. I'm most likely not going to change it.
00:36:28 <Arahael> I'm having trouble profiling my application, how do I troubleshoot this error? (I use 'fish' as my shell): https://gist.github.com/arafangion/3ba9eb6b289caabad1c46acfa85b18db
00:36:37 <Arahael> It doesn't seem to compile.
00:36:53 <iqubic> Mainly because I have no idea what other intcode operators will do.
00:36:53 <Arahael> (Definitely does compile if I don't specify --profile, however)
00:37:35 <iqubic> I'm handling input and output and jumps and tape writes in the same big case statement.
00:37:46 <paulasdf> Yeah, I was stuck on a bug for a while but I had just forgot to make the recursive call... ugh...
00:38:29 <iqubic> That's also the case statement where I handle halting, which is the case where I don't want to recursively call the step function.
00:39:27 <[Leary]> paulasdf: You could have a second case expression at the end like: `case op of Terminate -> return (); _ -> runMachine input`.
00:39:50 <paulasdf> ah yeah good idea
00:40:03 <[Leary]> Though there's probably a better way to refactor that.
00:41:17 <amalloy> you could factor out the recursive call into a different function, so that runMachine only runs a single step, and something else calls it recursively
00:52:48 <paulasdf> For insance, have [Leary]'s case check in another function?
00:55:27 <jpcooper> Hello. For a constraint synonym C, what is the closest statement to `data D = E | F deriving C` that actually works?
00:56:09 <jpcooper> `type C t = (A t, B t, E t)`
00:56:31 <jpcooper> s/E/G
01:02:21 <jle`> jpcooper: nothing probably until we get 'first class deriving'
01:04:07 <jpcooper> Shame. Thanks
01:06:23 <jpcooper> Is there something I can derive which implies the usual suspects like Ord, Eq, Bounded, Enum and Show?
01:07:59 <Arahael> As an update: Compiling "several times" managed to "work".  Will see if the final profile run actually produces profiling output.  Not terribly pleased with the stability of the compiler - I suspect the yesod templates here are probably to blame.
01:19:18 <Geekingfrog> Is there a "built-in" function to wait forever? Like `forever (threadDelay maxBound)` ?
01:20:15 <Rembane> Geekingfrog: I think you can use an MVar for this 
01:20:29 <Rembane> Geekingfrog: In combination with takeMVar 
01:21:14 <Geekingfrog> Wouldn't I get the exception waitIndefinitelyOnMVar (or something like that)?
01:21:27 <merijn> Geekingfrog: Only if no other thread has a reference to it
01:23:12 <Rembane> Geekingfrog: Why do you want to wait forever btw?
01:28:32 <aplainzetakind> https://hackage.haskell.org/package/parser-combinators-1.2.0/docs/src/Control.Monad.Combinators.html#many Why is go defined in terms of a parameter f in the where clause when only go id is needed?
01:29:01 <aplainzetakind> Oh
01:29:03 <aplainzetakind> never mind
01:29:08 <Geekingfrog> Rembane, I have a long running process, and, depending on the configuration, perhaps another one (http server for health check). I want to race both so if something goes wrong, the whole process stop (and will be restarted by something else). But when I don't have a port for the server, I need something else.
01:29:44 <Geekingfrog> Although there is probably an easier solution, only use `race` when I have the server.
01:30:44 <merijn> Geekingfrog: "waitIndefinitelyOnMVar" is a "courtesy exception" that only gets thrown when GHC is 100% absolutely positive that under no condition anything can ever write to that MVar anymore (i.e. when the only references to it are held by threads who are currently blocked on trying to read from it), if the MVar is still referenced by anything else it won't trigger
01:31:39 * hackage mmsyn6ukr 0.4.0.1 - A musical instrument synthesizer or a tool for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.4.0.1 (OleksandrZhabenko)
01:37:14 <Rembane> Geekingfrog: I have solved something similar a while ago, we used async to make sure that all threads crashed at the same time and then used systemctl to restart the process if that happened. 
01:37:33 <Rembane> Geekingfrog: I'm not 100% sure that it applies to your problem though
01:37:52 <Rembane> Geekingfrog: This is pure gold: http://hackage.haskell.org/package/async
01:38:39 <Geekingfrog> Rembane, yes, I know. I'm slowly discovering that our codebase is littered with forkIO with some dubious pattern.
01:39:00 <Geekingfrog> So I'm figuring out what to do to eradicate all of that
01:40:44 <Rembane> Geekingfrog: It must make your life interesting. 
01:41:16 <Geekingfrog> if only -_-"
01:44:09 * hackage cobot-tools 0.1.2.0 - Biological data file formats and IO  https://hackage.haskell.org/package/cobot-tools-0.1.2.0 (ozzzzz)
01:45:09 <haskeldjiq_> Geekingfrog: just out of curiosity, as a person who's in the process of littering the whole codebase with forkIO
01:45:32 <haskeldjiq_> Geekingfrog: is this a bad practice, and where can I get more information
01:45:58 <merijn> haskeldjiq_: I would recommend not doing that, yeah :p Not because forkIO is necessarily bad it's just...primitive
01:46:14 <Geekingfrog> haskeldjiq_, it's very easy to make mistake with forkIO, especially when you factor in asynchronous exceptions. Too low level as merijn said
01:46:32 <haskeldjiq_> what do you guys suggest
01:46:37 <merijn> haskeldjiq_: It also depends on the exact code base of course, but properly ensuring threads also get terminated, handling (async) exceptions is tricky business
01:46:39 <Geekingfrog> haskeldjiq_, basically, use the async library instead, and you can't really go wrong. 
01:46:43 <merijn> haskeldjiq_: Depends on what you're doing
01:46:45 <Geekingfrog> https://hackage.haskell.org/package/async-2.2.2
01:46:51 <merijn> async is a nice high level interface, yeah
01:47:05 <haskeldjiq_> nothing too complicated
01:47:08 <Geekingfrog> If you want to learn about that, there is the book "parallel and concurrent programming in haskell"
01:47:17 <Geekingfrog> I believe it's free online
01:47:21 <haskeldjiq_> I've read that half through
01:47:30 <merijn> Yeah, Simon Marlow Parallel & Concurrent Haskell is good
01:47:30 <boxscape> is that the one from Simon Marlow?
01:47:32 <Geekingfrog> yes
01:47:39 <boxscape> ok
01:47:42 <haskeldjiq_> probably got the forkIO stuff I'm using now and missed the part where they said "that's all nice, but don't use it"
01:47:42 <haskeldjiq_> lol
01:47:57 <merijn> haskeldjiq_: If you read, for example, the chapter on Chan it shows you how finnicky it can be
01:48:36 <haskeldjiq_> yeah Chan is shitty I know
01:48:43 <Geekingfrog> The main issue with forkIO is that it's very hard to wait for the thread to finish reliably.
01:48:47 <haskeldjiq_> I'll read up on the async library
01:48:54 <merijn> Chan is fine, but the implementation is super tricky
01:49:05 <haskeldjiq_> I'm anticipating an issue that we'll have
01:49:25 <haskeldjiq_> currently we run under the assumption that some thread just lives there and does work
01:49:27 <merijn> haskeldjiq_: So the main problem is something like: Suppose you spawn a thread to do X, now X fails with an exception, your original thread has no way to detect this
01:49:31 <tdammers> in practice, the one big issue with Chan (or TChan) is that there's no backpressure; if you keep producing faster than you consume, the Chan will happily eat up all your RAM
01:49:32 <haskeldjiq_> which is not a really solid assumption
01:49:56 <haskeldjiq_> merijn: we don't care at this point but we'll care very soon
01:50:08 <haskeldjiq_> merijn: no, we actually care now but we've closed our eyes
01:50:22 <merijn> haskeldjiq_: You *can* manually setup some notification system to detect this, but it's *hard*. Async basically does all that hard and wraps it in a convenient interface
01:50:30 <haskeldjiq_> merijn: thank you so much
01:51:07 <haskeldjiq_> I'll probably come back and ask you guys stuff again at some point
01:51:19 <haskeldjiq_> but these discussions are really helpful
01:51:26 <Rembane> There are bounded chans which mitigates the eat-up-all-the-ram-problem
01:51:41 <merijn> tdammers: That's why I implemented a parallelised back-pressure conduit! ;)
01:51:51 <haskeldjiq_> I really haven't heard of people that don't use bounded channels
01:52:26 <haskeldjiq_> oh, async has 0 documentation
01:52:27 <haskeldjiq_> lol
01:52:29 <merijn> tdammers: Which lets you run multiple (presumably slow) IO operations in parallel while keeping back pressure on the conduit :)
01:52:34 <merijn> haskeldjiq_: What?
01:52:51 <merijn> haskeldjiq_: https://hackage.haskell.org/package/async-2.2.2/docs/Control-Concurrent-Async.html ?
01:52:52 <haskeldjiq_> merijn: nah, forget it
01:52:58 <haskeldjiq_> merijn: yeah
01:53:00 <haskeldjiq_> lol
01:53:07 <haskeldjiq_> oh this is gold
01:53:29 <haskeldjiq_> (dance)
02:15:39 * hackage mmsyn6ukr 0.4.0.2 - A musical instrument synthesizer or a tool for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.4.0.2 (OleksandrZhabenko)
02:23:09 * hackage mmsyn6ukr 0.4.0.3 - A musical instrument synthesizer or a tool for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.4.0.3 (OleksandrZhabenko)
02:25:57 <aplainzetakind> https://gist.github.com/aplainzetakind/c117568cb257d17b1e7d93fa3aaa9bb4 This seems to always produce empty structures but I can't spot why.
02:26:40 <aplainzetakind> Specifically parseTest (combineWith (\x -> (x:)) anySingle) $ T.pack "abc" gives ""
02:26:56 <merijn> aplainzetakind: You keep recursing until you hit Nothing
02:27:03 <merijn> aplainzetakind: At which point you return mempty :p
02:27:31 <merijn> aplainzetakind: Presumably you want "pure (f mempty)"? :)
02:28:54 <aplainzetakind> Ah, forgot the f there.
02:28:57 <aplainzetakind> Thanks.
02:45:46 <absence> i'm trying to replace Proxy with TypeApplications in "RElem (s :-> a) rs => Proxy (s :-> a) -> Record rs -> a", but i'm not quite sure how to proceed. "forall r rs a s. (r ~ (s :-> a), RElem r rs) => Record rs -> a" gives me ambiguity errors about s, i guess because it doesn't appear to the right of => anymore?
02:46:35 <boxscape> absence that's right, but you can enable -XAllowAmbiguousTypes to allow it
02:47:21 <boxscape> probably
02:47:34 <absence> is that a good idea? and is it possible to change the type signature to make it unambiguous?
02:48:01 <boxscape> absence As far as I understand TypeApplications is the one place where it makes sense
02:48:05 <merijn> I would strongly caution *against* using TypeApplications over Proxy
02:48:15 <boxscape> why is that?
02:48:47 <merijn> It makes your code more brittle by relying on something that almost no library/API guarantees
02:49:16 <merijn> If there is no explicit forall in a type signature there is no promise on what order the type variables are introduce by the implicit forall, so no guarantee that it is stable
02:49:27 <boxscape> but here it's not relying on another API, it's about making your own API, so that would mean you can guarantee it, no?
02:49:41 <merijn> Additionally, if a dependency decides "hey, I need ScopedTypeVariables for this function" and adds an explicit forall, things are now changed
02:50:16 <merijn> boxscape: "you can guarantee it" <- theoretically, sure. In practice I don't think anyone is careful enough to do so
02:50:30 <boxscape> hm, I'm looking forward to visible dependent quantification
02:50:34 <merijn> The only way to reliably guarantee it would be to always explicitly writeout your forall's and never changed them
02:50:55 <jpcooper> Given a data type `data C = D | E` and DataKinds, is there a class I can derive such that given a Proxy for 'D or 'E, I can get _the_ corresponding value?
02:50:58 <boxscape> there's a proposal for -XNoImplicitForall :) admittedly that doesn't fix the order
02:51:23 <absence> to be fair, things break if you change the parameter order of a function as well
02:51:26 <boxscape> but visible forall should solve these things, anyway
02:56:48 <Solonarv> absence: generally speaking, if you want to write a function intended to be used with TypeApplications you will need AllowAmbiguousTypes
03:00:09 <haskelllisp[m]> Data.Text.Internal.Lazy.Text -> ByteString
03:00:50 * haskelllisp[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/ODXhKQfemoKQhNyZjBxqFmuO >
03:12:40 <aleator> Hi. I'm looking to get started on nix with Haskell. Should I go via cabal2nix route or is it smart idea to use iohks haskell.nix?
03:18:33 <jgt> I'm still using cabal2nix. If I remember correctly, using haskell.nix means you don't get to use the normal binary caches
03:20:25 <aleator> Well, my main machine is a mac, so I guess I don't get those anyways. But I'm kinda fuzzy on other benefits as well 
03:20:33 <__monty__> I like haskell.nix, early days still though so it's a little rough if you're new to nix.
03:20:42 <__monty__> nixpkgs caches for macs.
03:20:48 <jgt> aleator: I'm also on a Macintosh. I use the binary caches.
03:21:07 <__monty__> There's a cachix instance for haskell.nix. It's just a bit hard to find the right pins to benefit from it.
03:21:32 <aleator> jgt: Oh. I had a misconception there then.
03:22:39 * hackage mmsyn6ukr 0.4.0.4 - A musical instrument synthesizer or a tool for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.4.0.4 (OleksandrZhabenko)
03:24:22 <aleator> jgt, __monty__: Thanks. 
03:42:56 <pta2002> So I have a Map a b
03:43:03 <pta2002> and i have a function that returns me an IO b
03:43:26 <pta2002> how do i make a function that puts a bunch of those bs and returns an IO (Map a b)?
03:43:35 <pta2002> I guess i could just use a bunch of <-, but is that the best way?
03:44:30 <Solonarv> you already have a Map a b? how do you decide where the result of tht IO b should be inserted into the map?
03:45:37 <[exa]> pta2002: the function that returns the 'IO b' takes any parameters?
03:46:13 <absence> Solonarv: are there any gotchas with AllowAmbiguousTypes?
03:46:20 <pta2002> Solonarv: filesystem reads, i wanted to cache them
03:46:41 <pta2002> so a is just the file name
03:47:21 <Solonarv> absence: eh, it just moves ambiguity errors to the use sites rather than the definition
03:47:46 <Solonarv> so it can make it harder to figure out why you are getting an ambiguity error, but otherwise it should not break anything
03:47:56 <absence> Solonarv: that doesn't sound too bad. thanks!
03:48:49 <haskelllisp[m]> logout :: Key -> Maybe ClientId -> AW ()
03:48:49 <haskelllisp[m]> logout k Nothing = return ()
03:48:49 <haskelllisp[m]> logout k (Just ClientId cd) = do
03:49:03 <haskelllisp[m]> how match `(Just ClientId cd)`
03:49:06 <Solonarv> pta2002: so you don't actually have a Map FilePath b already, right? you are trying to create one
03:49:14 <pta2002> Solonarv: yep
03:49:37 <pta2002> function is just load :: IO (Map FilePath whateverthefiletypeis)
03:49:50 <Solonarv> pta2002: okay, then you can just use 'traverse' or 'sequence'
03:50:39 * hackage free-algebras 0.0.8.1 - Free algebras  https://hackage.haskell.org/package/free-algebras-0.0.8.1 (coot)
03:50:42 <Solonarv> sequence :: Map k (IO v) -> IO (Map k v)
03:50:44 <yasar> I am very new to haskell and trying to write a "walk directory recursively" function. It doesn't even compile :)  https://gist.github.com/yasar11732/186e511186d928f182433216192a1650
03:51:01 <Solonarv> pta2002: that sound like what you need?
03:51:30 <pta2002> oh
03:51:31 <pta2002> alright
03:51:45 <pta2002> yeah sequence sounds like it, i'll just create a map with the io thing and then take it out
03:52:43 <Solonarv> yup
03:53:16 <Solonarv> something like: sequence $ Map.fromList [(fp, readFile fp) | fp <- files]
03:53:34 <pta2002> yeah that works
03:53:40 <boxscape> yasar what do you expect `files <- map doesFileExist fullPaths` to do?
03:53:45 <Solonarv> or if you have a Set of filenames you are interested in: sequence $ Map.fromKeys readFile pathSet
03:53:46 <pta2002> is a map the best way to do caching or is there something more purpose-made?
03:54:09 * hackage dhall-fly 0.2.2 - Translate concourse config from Dhall to YAML  https://hackage.haskell.org/package/dhall-fly-0.2.2 (axeman)
03:54:14 <Solonarv> pta2002: well, you will end up loading all the files right at the start rather than on-demand
03:54:22 <Solonarv> but it's a reasonable way to do this
03:54:28 <pta2002> Solonarv: yeah that's what i want
03:54:30 <yasar> boxscape: it is meant to be filter :(
03:54:35 <Solonarv> perfect
03:54:39 <pta2002> it's a game, if i was lazy loading the files it'd cause frame drops
03:55:03 <boxscape> yasar so `files <- filter doesFileExist fullPaths`?
03:55:09 <yasar> yes
03:55:34 <yasar> it is meant to separate files from directories
03:55:56 <merijn> PSA: doesFileExist is dangerous and you should probably not use it unless you understand why and why it's okay for your use-case 
03:57:02 <Solonarv> the reason it's dangerous is that you are probably using it to check whether the file is there before accessing it somehow
03:57:12 <boxscape> yasar doesFileExist has type `FilePath -> IO Bool`. filter has type `(a -> Bool) -> [a] -> [a]`. Can you see how you're trying to put something like `(_ -> IO Bool)` into something that expects something like `(_ -> Bool)`?
03:58:09 * hackage diagrams-pgf 1.4.1.1 - PGF backend for diagrams drawing EDSL.  https://hackage.haskell.org/package/diagrams-pgf-1.4.1.1 (BrentYorgey)
03:58:13 <Solonarv> but the file could change (be created/destroyed) between doesFileExist and whatever you are trying to do to it
03:59:09 * hackage free-category 0.0.4.1 - efficient data types for free categories and arrows  https://hackage.haskell.org/package/free-category-0.0.4.1 (coot)
03:59:38 <yasar> boxscape so, I need a monad version of filter? Is there such a thing as filterM?
03:59:47 <boxscape> yasar that's exactly right :)
04:00:06 <__monty__> @hoogle filterM
04:00:07 <lambdabot> Control.Monad filterM :: Applicative m => (a -> m Bool) -> [a] -> m [a]
04:00:07 <lambdabot> Data.Vector filterM :: Monad m => (a -> m Bool) -> Vector a -> m (Vector a)
04:00:07 <lambdabot> Data.Vector.Fusion.Bundle filterM :: Monad m => (a -> m Bool) -> Bundle v a -> Bundle m v a
04:00:14 <__monty__> Hoogle's your friend.
04:03:41 <yasar> can I mix monad assignment (<-) and regular assignment (=) inside do notation?
04:04:00 <boxscape> yes, you can write a line containing something like "let x = 4"
04:04:06 <merijn> yasar: = is not assignment
04:04:06 <Solonarv> yes, you just need a 'let' for regular assignment
04:04:15 <Solonarv> s/assignment/definition/
04:04:20 <merijn> (neither is <- when we get down to it...)
04:05:05 <boxscape> what *is* <- called, anyway?
04:05:26 <kuribas> is there a way to pass information from a WAI middleware to a servant endpoint?  Let's say I want a middleware for handling authentication, and pass that information to the endpoint.
04:05:32 <merijn> boxscape: Nothing, ir "bind" if you really have to
04:05:33 <dibblego> "turn left"
04:05:41 <merijn> boxscape: I mean <- is just >>=
04:06:07 <boxscape> and yet "let x = 4" can also be called a let binding :/
04:06:10 <kuribas> boxscape: COMEFROM, duh...
04:06:29 <merijn> kuribas: Don't joke, COMEFROM exists :p
04:06:39 <kuribas> merijn: it does?
04:06:42 <merijn> It's in Intercal, I think?
04:06:53 <kuribas> merijn: yeah, that was the joke
04:07:55 <kuribas> So I have people advicing to do authentication on the middleware level, then how can you pass it to the endpoints?
04:08:19 <merijn> Man, how did I not know this package? https://hackage.haskell.org/package/acme-flipping-tables-0/docs/Acme-Error.html
04:08:38 <yasar> This looks better I guess, but still not compiling :)  https://gist.github.com/yasar11732/186e511186d928f182433216192a1650
04:09:14 <merijn> yasar: Style note: I would put a newline after do and just indent everything, like, 4 spaces instead of having it all so far right
04:09:23 <kuribas> yasar: haha, that's great
04:09:40 <kuribas> ehm merijn I mean
04:11:22 <merijn> yasar: At first glance the code looks reasonable, so I'm curious what the error you get is
04:12:01 <boxscape> map walkDirectory dirs
04:12:09 <merijn> oh, yeah
04:12:15 <boxscape> same issue as with filter
04:12:31 <boxscape> uh wait
04:12:35 <boxscape> maybe one more issue
04:12:58 <merijn> yasar: FYI, System.FilePath has an operator </> that joins two path components
04:13:02 <boxscape> walkDirectory takes two arguments but you're only giving it one yasar
04:13:15 <lavalike> hvr: you around?
04:13:45 <merijn> yasar: So you could simplify "map (\x -> joinPath [rootDir, x])" to "map (\x -> rootDir </> x)" or even just "map (rootDir </>)"
04:13:45 <boxscape> yasar also once you fix that line the `return ()` is not necessary
04:16:04 <merijn> kuribas: In a similar vein, this looks like a really well done acme package: https://hackage.haskell.org/package/acme-zalgo-0.1.2.1/docs/Text-Zalgo.html
04:18:17 <hpc> acme-schoenfinkel is still my favorite
04:18:32 <merijn> hpc: I quite like acme-dont and acme-LookOfDisapproval
04:18:53 <hpc> those are good too, but hasslich is the best identifier name ever
04:20:25 <boxscape> quite convenient that unschön is an actual German word, as well. Wouldn't work in English, with "unbeautiful"
04:20:39 <boxscape> at least I don't think I've ever heard someone say that
04:21:21 <hpc> i wish acme-microwave got more attention, but i think it goes over a lot of people's heads
04:22:35 <yasar> So sorry to bother but, I still can't get it to compile :(  https://gist.github.com/yasar11732/186e511186d928f182433216192a1650
04:23:04 <boxscape> yasar close, now you just have the same problem as with filter earlier
04:23:10 <boxscape> but with map this time
04:24:11 <yasar> am I correct to think that files, and dirs has type [String] ?
04:24:28 <boxscape> map :: (a -> b) -> [a] -> [b], so if you give it a function of type (a -> IO ()), it will give you [IO ()] in the end - but you want IO ()
04:24:33 <boxscape> that sounds right yasar
04:25:17 <yasar> so, if I had return () would it work?
04:25:21 <yasar> after the map
04:26:10 <boxscape> no - a line in a do block of IO like that has to be of type IO <something>, not [IO <something>]
04:26:40 <boxscape> % :t mapM
04:26:40 <yahb> boxscape: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
04:26:53 <boxscape> if you used this, it would give you IO [()], which is closer
04:27:34 <boxscape> basically each invocation of walkDIrectory produces a () as result and mapM would collect the results in a List [()]
04:27:43 <boxscape> but you don't need those results, you just want ()
04:27:58 <boxscape> so there's a function that lets you discard the results
04:28:01 <boxscape> % :t mapM_
04:28:01 <yahb> boxscape: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
04:29:39 <lavalike> is it possible to run the same search engine and collection of pages that stackage.org runs but locally?
04:32:00 <merijn> lavalike: I don't know about stackage, but Hoogle has an executable you can build locally
04:32:13 <merijn> lavalike: Setting up the initial database can be a bit of a pain
04:32:19 <merijn> @hackage hoogle
04:32:19 <lambdabot> http://hackage.haskell.org/package/hoogle
04:32:40 <yasar> boxscape so, mapM works like monad version of map, and mapM_ works like "foreach thing, do and action and return ()" ?
04:32:52 <yasar> do an* action
04:33:15 <merijn> yasar: mapM_ is just "mapM, but I don't care about the result list" (because a list of () values is a bit useless and wastes memory)
04:33:37 <boxscape> yasar yeah, mapM_ is semantically much the same as writing `mapM f xs` and then `return ()` in the next line
04:33:53 <merijn> Except more efficient ;)
04:34:02 <boxscape> hence "semantically" :)
04:37:41 <lavalike> merijn: I have much more success with stackage so I'd love to have that when I'm off the internet
04:38:04 <merijn> lavalike: Pretty sure stackage search is also just Hoogle, but with a different CSS skin
04:38:18 <lavalike> it finds different things so it's the db the difference for me
04:38:43 <Solonarv> hackage's hoogle can use the stackage db too, IIRC
04:38:46 <merijn> lavalike: Presumably it's database if based on stackage
04:39:09 <merijn> lavalike: Yeah, but locally you can build custom database with whichever package(s) you want
04:45:39 * hackage cabal-cache 1.0.1.3 - CI Assistant for Haskell projects  https://hackage.haskell.org/package/cabal-cache-1.0.1.3 (haskellworks)
04:54:05 <yasar> It works now, but when I run it I get "<stdout>: commitBuffer: invalid Argument (invalid Character)" error. I am guessing it is about output encoding or something similiar
04:54:24 <yasar> is there a way to fix that? I am using windows
04:55:24 <yasar> This is the final version: https://gist.github.com/yasar11732/186e511186d928f182433216192a1650
04:56:31 <merijn> Filenames on windows are utf16 (iirc), so if the output encoding is set to something more limited that might be a problem
04:56:39 * hackage mason 0.1 - Fast and extensible bytestring builder  https://hackage.haskell.org/package/mason-0.1 (FumiakiKinoshita)
04:57:00 <merijn> yasar: https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO.html#g:23
04:57:02 <sshine> I'm trying to get a WHOIS request via Network.Socket.ByteString.recv, and because of an artificial delay imposed by the WHOIS server between the header and the response, my 'recv' call seems to only get the first chunk. how do I ensure that I read the entire response sans timing-induced buffering?
04:57:23 <boxscape> yasar for what it's worth, the code works for me as is, also on Windows
04:57:35 <merijn> sshine: You loop until the connection terminates
04:57:51 <sshine> apparently there isn't a 'recvAll', but I'll make that then.
04:58:21 <yasar> boxscape it is probably because of my filenames, they include Turkish characters
04:58:27 <merijn> sshine: That's because there's no notion of packets in TCP, so how would you decide when to stop
04:58:35 <boxscape> ah, yeah I suppose that might be it
04:59:00 <sshine> merijn, point.
04:59:39 <sshine> so perhaps I should include a timeout in my recvAll in case the WHOIS server decides to not terminate the connection.
04:59:39 <merijn> yasar: Looks good, aside from that issue
04:59:57 <merijn> The seems unlikely, but who knows ;)
05:00:05 <sshine> right :)
05:03:40 <yasar> is there a function for only getting files/directories so I don't have to call doesFileExist/doesDirectoryExist for each path?
05:04:01 <yasar> it feels very inefficient
05:07:01 <boxscape> yasar the extra package has a function for it, but does essentially the same thing you're doing
05:07:22 <boxscape> @hoogle listDirectories
05:07:23 <lambdabot> Extra listDirectories :: FilePath -> IO [FilePath]
05:07:23 <lambdabot> System.Directory.Extra listDirectories :: FilePath -> IO [FilePath]
05:08:25 <boxscape> if you were to look at the source code ( https://hackage.haskell.org/package/extra-1.6.18/docs/src/System.Directory.Extra.html#listDirectories ) you'd see that they also filterM doesDirectoryExist
05:25:11 <jpcooper> `data Mapping k v = k :-> v`. `data Map [Mapping * *]`. How can I define a type synonym of `Map` where the `k` position is restricted to a polymorphic kind chosen outside of the `[]`? Everything I have tried has suggested that I enable `TypeInType`, but I don't see why
05:27:01 <jpcooper> I tried `data Map (n :: forall k. [forall a. Mapping (a :: k) *]) where`, but GHC says that a and k are being used both as kinds and as types
05:27:39 <Solonarv> that is what you need TypeInType for
05:27:40 <jpcooper> Also the k should be defined before n
05:28:07 <boxscape> Solonarv TypeInType as Extension is deprecated, Type :: Type is always true
05:28:38 <boxscape> wait
05:28:40 <jpcooper> In `data Map (n :: [forall a. Mapping (a :: k) *]) where`, why is GHC saying that a is used both as a type and a kind?
05:28:47 <boxscape> it suggests that you enable TypeInType?
05:28:54 <jpcooper> Yes
05:28:55 <Solonarv> you are quantifying over it with 'forall a. 
05:28:55 <boxscape> does it still do that? What ghc version are you on?
05:29:46 <jpcooper> 8.4.3
05:29:59 <boxscape> Ah, maybe it wasn't deprecated at that point
05:30:15 <boxscape> (still, Type :: Type I believe has always been true since 8.0)
05:30:33 <jpcooper> Why do we need Type :: Type here though?
05:31:57 <boxscape> I'm not really sure - what happens if you try `data Map (n :: forall k. [forall (a :: k). Mapping a *]) where` ?
05:32:13 <dminuoso> jpcooper: Type :: Type  essentially collapses the entire `Type -> Kind -> Sort -> ...` tower flat into types.
05:32:32 <boxscape> Actually I think the reason it suggests TypeInType is because you need -XPolyKinds, which -XTypeInType enables?
05:32:40 <jpcooper> boxscape: That would be incorrect. I want k to be defined before n
05:32:53 <jpcooper> PolyKinds is enabled
05:33:19 <boxscape> jpcooper then it was incorrect in the version you pasted here as well, no?
05:33:33 <jpcooper> dminuoso: Yes. I would just like to understand in this case why Type :: Type is actually needed
05:34:01 <jpcooper> Maybe I can define this kind with a type family
05:34:09 <dminuoso> jpcooper: Well at first Id say your data type Map  requires impredicative polymorphism.
05:35:51 <jpcooper> dminuoso: Are you sure? Does `data Map [Mapping * *]` require impredicative polymorphism?
05:36:25 <yasar> is there a way to ignore permission denied errors while using listDirectory function?
05:36:40 <dminuoso> jpcooper: Mmm, under the paradigm of TypeInType, Id say yes. 
05:36:47 <jpcooper> yasar: have +r set on the directory
05:37:03 <boxscape> does that mean `data Map = Map [Mapping * *]`?
05:37:16 <Solonarv> you need impredicative polymorphism because you have a (forall a. ....) type as argument t a type constructor other than (->)
05:37:24 <jpcooper> dminuoso: If I could define `data Map = Map [Mapping k *]` while suggesting that k is a kind, would this require impredicative polymorphism?
05:37:47 <dminuoso> jpcooper: Oh wait, Im just talking about your original
05:37:53 <dminuoso> `data Map (n :: forall k. [forall a. Mapping (a :: k) *])`
05:38:01 <Solonarv> yes me too
05:38:16 <dminuoso> % data Mapping k v = k :-> v
05:38:16 <yahb> dminuoso: 
05:38:25 <dminuoso> % data Map (n :: forall k. [forall a. Mapping (a :: k) *])
05:38:26 <yahb> dminuoso: ; <interactive>:143:1: error:; Illegal polymorphic type: forall (a :: k1). Mapping a *; GHC doesn't yet support impredicative polymorphism
05:38:34 <jpcooper> dminuoso: I agree with your comment on that original. Actually I'm more interested in finding a solution to expressing `k is a kind` and `data Map = Map [Mapping k *]`
05:39:11 <jpcooper> `data Map (n :: forall k. [forall a. Mapping (a :: k) *])` is not what I want, as k needs to be a single k for the whole Map
05:39:34 <dminuoso> % % data Map k = Map [Mapping (k :: Type) *]
05:39:34 <yahb> dminuoso: ; <interactive>:146:1: error: parse error on input `%'
05:39:38 <dminuoso> % data Map k = Map [Mapping (k :: Type) *]
05:39:38 <yahb> dminuoso: 
05:39:52 <dminuoso> Mmm
05:40:03 <jpcooper> k needs to be a kind
05:40:17 <dminuoso> jpcooper: TypeInType.
05:40:46 <boxscape> were you able to have a kind annotation `k :: BOX` before 8.0?
05:40:51 <jpcooper> % data Map k = Map [Mapping (k :: Kind) *]
05:40:51 <yahb> jpcooper: ; <interactive>:148:33: error: Not in scope: type constructor or class `Kind'
05:40:56 <jpcooper> % data Map k = Map [Mapping (k :: BOX) *]
05:40:56 <yahb> jpcooper: ; <interactive>:149:33: error: Not in scope: type constructor or class `BOX'
05:41:22 <jpcooper> % data Map k = Map [Mapping (k :: Sort) *]
05:41:22 <yahb> jpcooper: ; <interactive>:151:33: error: Not in scope: type constructor or class `Sort'
05:41:23 <dminuoso> jpcooper: I have a question
05:41:35 <jpcooper> Yes
05:41:40 <dminuoso> jpcooper: Is Mapping supposed to be used only lifted?
05:41:58 <dminuoso> jpcooper: TypeInType buys you exactly what you want. :)
05:42:14 <dminuoso> jpcooper: Think about it in terms of universes for a second.
05:42:23 <dminuoso> You want a type applied to a kind. That's crossing universes.
05:43:30 <jpcooper> I am trying to adapt Map in https://github.com/dorchard/type-level-sets/blob/master/src/Data/Type/Map.hs so that it is defined not only over Var (Symbol) keys, but I also want the ability to restrict the key kind to Symbol so that it is still possible to define those Show instances
05:43:43 <jpcooper> dminuoso: I'm not sure what you mean by lifted in this case
05:47:22 <jpcooper> Maybe this is just down to the GHC version. I've probably been using TypeInType without knowing it in my other project. I've just been confused as to why `Map [Mapping * *]` does not need TypeInType while `Map [Mapping (t :: k) *]` does
05:47:56 <dminuoso> jpcooper: Id say both do?
05:48:21 <jpcooper> The first instance compiles without saying that TypeInType is needed
05:48:30 <boxscape> jpcooper keep in mind that Type :: Type is always true, enabling the extension just gives you some syntactic tools to work with it
05:48:43 <dminuoso> jpcooper: Type :: Type is already the default behavior since 8.0 I think?
05:48:50 <jpcooper> I understand
05:49:00 <boxscape> dminuoso not just the default, it's the only behavior
05:49:00 <dminuoso> jpcooper: When I say TypeInType I specifically mean the `Type :: Type` paradigm. 
05:49:14 <jpcooper> Okay. I will just enable it. Sorry for being stubborn :)
05:49:22 <dminuoso> jpcooper: You dont need it.
05:49:28 <jpcooper> Oh
05:49:33 <dminuoso> jpcooper: TypeInType effectively just turns on PolyKinds nowadays I think?
05:49:43 <dminuoso> Maybe DataKinds too?
05:49:57 <jpcooper> PolyKinds and DataKinds are already enabled in Map.hs
05:50:18 <boxscape> yeah TypeInType just enabled those two
05:50:19 <jpcooper> I'm going to try with a newer ghc version
05:50:31 <boxscape> might have done something else in 8.4, indeed
05:51:22 <boxscape> https://downloads.haskell.org/~ghc/8.4.1/docs/html/users_guide/glasgow_exts.html#extension-TypeInType
05:51:39 <boxscape> (8.4 version of user's guide)
06:02:18 <dminuoso> Gah, why doesn't postgresql-simple use Vector instead of [] for query... :(
06:02:35 <dminuoso> But I guess with this amount of data Im better off streaming with cursors anyway...
06:09:20 <Bish> @src map
06:09:20 <lambdabot> map _ []     = []
06:09:20 <lambdabot> map f (x:xs) = f x : map f xs
06:09:24 <Bish> @src fmap
06:09:24 <lambdabot> Source not found. You type like i drive.
06:09:29 <Bish> eh, sure
06:09:47 <Solonarv> @src fmap Maybe
06:09:47 <lambdabot> Source not found. Take a stress pill and think things over.
06:09:54 <Solonarv> hm :(
06:09:58 <Bish> @src fmap []
06:09:58 <lambdabot> Source not found. My mind is going. I can feel it.
06:10:06 <merijn> Bish: @src is just a string lookup to a file with pre-defined definitions (mostly from the report) and doesn't represent that actual source of any function
06:10:30 <yasar> How do you get output from "catch"? I tried this but didn't work: https://gist.github.com/yasar11732/186e511186d928f182433216192a1650#file-walk-hs-L12
06:11:45 <Clint> yasar: did you get a type error?
06:11:47 <merijn> yasar: It doesn't work because: 1) "putStrLn $ "Cannot read " ++ rootDir" is not a function, but an IO value, and 2) it has a different return type than "listDirectory rootDir"
06:12:24 <merijn> yasar: FYI (</> rootDir) puts the rootDir *after* the filename
06:12:36 <merijn> You, presumably, want (rootDir </>)
06:13:02 <yasar> merijn that explains the weird looking output :)
06:16:29 <kuribas> tdammers: hi.  You said authentication should be done on middleware level, not servant level, then how do you pass authentation information to the endpoint handlers?
06:19:02 <kuribas> tdammers: it seems there is no way, which is why the servant-auth package exists.
06:19:29 <tdammers> aww
06:19:52 <yasar> merijn got it to work :)  https://gist.github.com/yasar11732/186e511186d928f182433216192a1650
06:20:10 <tdammers> not sure how to do it with servant, but in general, you'd probably have some sort of shared vault or similar data structure between the authentication and authorization parts
06:21:26 <kuribas> tdammers: I could pass a fake header to the endpoint, and have a hashmap with the info, but that looks like an ugly hack
06:21:58 <kuribas> tdammers: what do you not like about servant-auth?
06:22:40 <kuribas> tdammers: I suppose the middleware could set a cookie
06:33:03 <alp> kuribas, servant lets you access the request's "Vault" too
06:33:40 <alp> https://hackage.haskell.org/package/servant-0.16.2/docs/Servant-API-Vault.html#t:Vault
06:34:47 <kuribas> alp: ah right!
06:34:47 <Phyx-> yasar: use chcp and change your console's codepage, that error should go away
06:37:50 <Phyx-> yasar: `chcp 65001` will give you a utf8 codepage
06:38:30 <kuribas> alp: so you create a typed key, which you then use both in the middleware and the endpoint?
06:39:20 <dminuoso> alp: Is there some combinator to sneak in all request headers by the way? Or do I have to list them all explicitly?
06:42:37 <alp> dminuoso, I don't think we have one yet, but I'd take a PR adding a dedicated combinator :)
06:43:32 <alp> kuribas, I haven't used 'vault' in a long while but yes, the middleware and the servant handlers would have to agree on a key/place to store the value of interest in the vault
06:45:36 <alp> dminuoso, should be fairly easy to write one based on the definition of the Header combinator, you'd just strip the part that looks up a particular header name
06:45:46 <alp> and adapt the type of the argument that the handlers get
06:46:26 <kuribas> alp: is this vault argument removed in clients?
06:48:18 <alp> kuribas, yes: https://hackage.haskell.org/package/servant-client-core-0.16/docs/src/Servant.Client.Core.HasClient.html#line-584
06:48:41 <alp> notice how we don't have: type Client m (Vault :> api) = Vault -> Client m api
06:48:55 <alp> but instead just the recursive "call" to Client
06:51:48 <kuribas> right
06:58:38 <kuribas> That would work, but why is it better than servant-auth?
06:59:29 <kuribas> it would require me to check the authentication and do redirect in each endpoint.
07:00:44 <sondr3> does anyone have an example repo for Advent of Code using HUnit/Hspec? Trying to set up testing for my attempt in Haskell this year
07:02:07 <Bish> can i do an functor instance as an inline
07:04:12 <Bish> instance Functor Mylist where fmap f (Liste a b) = Liste (f a) (fmap f b) fmap f _ = ListEnd
07:04:15 <Bish> like this?
07:04:31 <e1fa> hey can someone give me some syntax advice?
07:04:50 <merijn> Bish: Sure
07:04:56 <Bish> merijn: what do i do wrong then
07:04:59 <Cale> Bish: Ah, you mean on a single line? You just need a semicolon
07:05:24 <merijn> ^^
07:06:18 <boxscape> with let bindings, assuming -O0, if I define a function like "id :: a -> a; id x = x", roughly speaking, does ghc create a new closure for that every time the let binding is evaluated? (and garbage collect it at some point?)
07:06:33 <Bish> cool thanks
07:06:39 <boxscape> e1fa if you tell us what you need advice with, someone will probably give it :)
07:06:59 <e1fa> awesome gimme a sec
07:07:11 <e1fa> i'm trying to do pattern matching with a map lookup
07:08:03 <e1fa> right now i'm using guards and evaluating the lookup but i think theres a cleaner way to do it
07:08:52 <merijn> e1fa: Can you show what you mean?
07:09:03 <e1fa> https://gist.github.com/crclark96/f3de722aa01fdddaf0383f23d7be607b
07:09:24 <e1fa> yeah here's the function
07:09:47 <merijn> e1fa: Ah, yeah you wanna avoid "x == Nothing" always, because it restricts you to elements that are instances of Eq :)
07:09:59 <merijn> e1fa: But you can just use case-of
07:10:14 <merijn> e1fa: i.e. "case M.lookup obj m of ..."
07:11:33 <merijn> e1fa: So, like https://paste.debian.net/1119798/
07:11:46 <merijn> e1fa: Gets rid of the fromJust too
07:11:48 <Bish> instance Functor Mylist where fmap f a = case a of (Liste h t) -> (Liste f h) (fmap f t);_ -> ListenEnde
07:11:51 <Bish> why wouldn't this work?
07:12:29 <Bish> oh it does
07:12:30 <Bish> nvm
07:12:33 <Bish> wrong parenthesis
07:12:46 <e1fa> merijn: awesome, that's exactly what i was looking for
07:13:34 <merijn> e1fa: case-of is an expression, so you can pretty much put them anywhere whenever you want to pattern match
07:14:31 <e1fa> merijn: so it's kind of like if?
07:14:43 <Bish> where would i find the src of <*> for []
07:14:54 <merijn> e1fa: Pretty much, see for example https://github.com/merijn/AdventOfCode2019/blob/master/Day3.hs#L61-L65 (AoC day 3 spoilers, obviously ;))
07:15:29 <e1fa> merijn: if you couldn't tell i'm on day six haha
07:15:58 <merijn> e1fa: Arguably "if foo then x else y" is just syntactic sugar for "case foo of True -> x; False -> y"
07:16:17 <e1fa> merijn: ah that makes a lot of sense
07:16:47 <Ariakenom> merijn: whats the argument against?
07:18:44 <merijn> Ariakenom: The fact that GHC with, for example, RebindableSyntax if/then/else gets handled separately
07:20:17 <c_wraith> that just says that there's a level of indirection before it becomes the case expression, and you can change the indirection when that extension is enabled.
07:20:29 <merijn> e1fa: case-of is really the "one single way" of doing pattern matching and stuff like pattern matches in functions are just convenient syntactic sugar to make writing complex matches simpler. In the end GHC will compile most of them to a bunch of nested cases
07:21:03 <c_wraith> case expressions and function application.  That's all evaluation is made of...
07:21:24 <merijn> c_wraith: Sure, my point was just that if/then/else isn't literally/directly syntactic sugar for case, since it's built into the compiler, as opposed to do which is defined as being just syntactic sugar
07:22:27 <merijn> Ariakenom: So, the arguable part is that while they're semantically the same, there's no guarantee that it actually is syntactic sugar
07:22:34 <e1fa> merijn: gotcha. i think i just get stuck in ruts because i'm literally learning everything from scratch 
07:25:02 <c_wraith> I'm just annoyed hlint yells at me for using case on Bool instead of if/then/else.  I prefer the syntactic regularity!
07:25:18 <Ariakenom> merijn: yeah makes sense
07:26:09 <geekosaur> hlint is often annoying, tbh
07:26:54 <boxscape> I just use multiline if everywhere
07:27:11 <boxscape> at least syntactically regular wrt guards
07:35:11 <boxscape> err multiway if, rather
07:39:58 <merijn> c_wraith: I have a simple 1 step solution for you!
07:50:01 <maralorn> I am now offiicially in the dependen haskell hell. "Could not deduce (Monoid (NonEmpty (UUID, Bool)))"
07:50:20 <maralorn> How is NonEmpty not a Monoid?
07:50:35 <boxscape> what's mempty?
07:50:54 <boxscape> I imagine it has a Semigroup instance if that helps
07:51:28 <kuribas> maralorn: I don't see anything dependend there.
07:51:57 <e1fa> is Data.Map implemented as a tree?
07:52:03 <merijn> e1fa: Yes
07:52:05 <maralorn> boxscape: Uuuuh m(
07:52:11 <e1fa> merijn: why?
07:52:16 <merijn> e1fa: Why not?
07:52:26 <merijn> e1fa: C++'s std::map is tree based too
07:52:31 <e1fa> merijn: hashmaps are O(n) for insert and lookup
07:52:35 * geekosaur wonders about mempty :: UUID
07:52:43 <kuribas> merijn: doesn't do sharing I suppose?
07:52:57 <merijn> e1fa: Presumably you meant O(1), not O(n), since trees are O(log n)
07:53:02 <maralorn> kuribas: I am trying to proof that I can add this stuff by patternmatching on a GADT.
07:53:18 <e1fa> merijn: yeah that's what i meant
07:53:26 <boxscape> e1fa you can use Data.HashMap if you want to use a HashMap
07:53:32 <merijn> e1fa: Hashmaps are, in fact, not O(1), they're O(k) where 'k' is the complexity of your hash operation and you need to handle key collisions
07:53:39 <e1fa> boxscape: it's deprecated
07:53:43 <boxscape> oh oops
07:53:47 <Taneb> maralorn: what part of your error is unexpected?
07:53:50 <merijn> e1fa: So the worst case complexity of hashmaps is, in fact O(n)
07:54:16 <merijn> e1fa: Not to mention hashmaps are trickier to implement efficiently in an immutable world (not impossible, just trickier)
07:54:33 <kuribas> there are hashmaps in haskell, but they are trees
07:54:52 <kuribas> they just hash first
07:54:59 <merijn> e1fa: Meanwhile, trees based maps are O(log n) worst case complexity (assuming a self-balancing tree implementation) and much easier to implement in an immutable setting since you can share large parts of the tree
07:55:28 <monochrom> Basically replacing array by high-fanout search trees.
07:55:53 <merijn> e1fa: And, most importantly, for 95% of usecases involving a "dictionary" like type tree based maps are plenty fast
07:55:58 <boxscape> e1fa where does it say that Data.HashMap is deprecated?
07:56:10 <Ariakenom> e1fa: if you want a nice immutable structure you pretty much end up with O(log n)
07:56:17 <merijn> boxscape: iirc there's two libraries implementing hashmaps, one is deprecated
07:56:39 <merijn> hashmap is deprecated in favour of unordered-containers
07:56:55 <boxscape> ah, okay, I was looking at the latter
07:57:41 <monochrom> This is what's wrong with only mentioning a module name.  Multiple unrelated packages use the same module name.
07:57:50 <maralorn> Taneb: The unexpected problem was, that I thought (++) was the Semigroup version in the Prelude I am using, but I had to use (<>).
07:57:54 <Ariakenom> are there any somewhat popular mutable maps in haskell?
07:57:55 <e1fa> boxscape: https://hackage.haskell.org/package/hashmap-1.3.2/docs/Data-HashMap.html
07:58:14 <boxscape> there's also hashtables which I'm assuming isn't tree-based
07:58:45 <merijn> e1fa: You want the unordered-containers package for a HashMap, although I maintain that you do not, in fact, want a hashmap and should just use Map from containers
07:59:33 <monochrom> There are cases Map is faster than HashMap
07:59:48 <boxscape> Ariakenom hashtables has 65000 downloads
08:00:08 <merijn> And if you really do need faster than Map, then just ensure your keys are Int and use IntMap >.>
08:00:23 <Ariakenom> boxscape: oh I thought those were persistent. thanks
08:00:33 <merijn> boxscape: That's just bots :p
08:00:46 <monochrom> I think i also had a case where Map Int was faster than IntMap and HashMap Int
08:01:00 <boxscape> odd
08:01:04 <maralorn> merijn: Under what conditions is your advice to use Map over HashMap valid?
08:01:12 <e1fa> merijn: i was just curious i don't actually need a performance boost
08:01:50 <merijn> maralorn: Unless you're *absolutely* sure Map isn't good enough and have benchmarks to prove it, then you could look at HashMap (which isn't actually guaranteed to be any faster)
08:02:23 <merijn> maralorn: I think the main argument for HashMap is if you have a type that doesn't admit a sensible total ordering, but does admit a sensible hash operation
08:02:30 <Ariakenom> oh I see. I confused hashmap and hashtables. I blame the package namers
08:02:40 <boxscape> Does it make sense to generally prefer IntMap over Map? (assuming you don't have to go out of your way to get Int keys)
08:03:07 <merijn> boxscape: If you have Int keys anyway it can't hurt (well, monochrom mentions that it could, but I find it unlikely)
08:04:03 <maralorn> merijn: Hm, oh ok.
08:04:06 <merijn> boxscape: Basically, due to the fact that the key type is known and has an obvious structure (i.e. finite number of bits) you can use smarter ways to order/construct your trees
08:04:27 <boxscape> I see
08:04:50 <merijn> maralorn: Basically, in the past 10 years I've never really had a reason to reach for HashMap because Map has always has been fast enough
08:06:13 <maralorn> merijn: It does depend on the number of entries, doesn‘t it?
08:06:42 <maralorn> But what are the downsides of HashMap?
08:06:56 <kuribas> maralorn: it's unordered
08:07:14 <merijn> maralorn: Possibly, but I've used Maps of several thousand/ten thousand entries without too much difficulty
08:07:16 <kuribas> maralorn: with a Map you can get all elements after one element
08:08:41 <merijn> maralorn: You need to implement a Hash function for your key types and developing a good hash function is tricky/hard business, you loose some convenient query functions for min/max, you add an extra dependency to your tree (since containers is almost certainly already in there)
08:09:45 <Ariakenom> can you not `derive` a good hash function?
08:10:12 <merijn> Ariakenom: Maybe, I dunno? As mentioned I've never had too :p
08:12:37 <Cale> Depending on the key types involved and the size of the maps, hashing the key you want to look up in a HashMap might even be more expensive than performing the handful of comparisons when doing a lookup
08:13:18 <merijn> I blame all the dynamic languages for somehow implanting the idea that only hashmaps are efficient data structures for looking stuff up
08:13:54 <saml> what other efficient data structure is there for looking stuff up?
08:14:06 <kuribas> saml: binary search tree
08:14:09 <Cale> Balanced trees of various sorts
08:14:11 <merijn> saml: Eh...trees like we were just discussing?
08:14:19 <saml> ah i see
08:14:40 <saml> I was wondering if there's something that can tell membership but doesn't actually store full object
08:14:47 <merijn> Meanwhile C++ uses a tree for std::map and you never hear anyone complain/ask about its performance >.>
08:15:01 <Ariakenom> for <100 elements and small keys. probably a linear search through an array is fastest
08:15:10 <merijn> saml: Well, if your object is already used elsewhere then object storage is free anyway ;)
08:15:34 <merijn> saml: Since you can share the object between set/map and wherever else you use it
08:15:48 <Ariakenom> pointers arent free :[
08:15:49 <saml> ah so you only store pointer
08:16:05 <merijn> saml: Everything's immutable, so you can always store everything by reference/pointer
08:16:41 <merijn> saml: Hell, due to laziness you can store something that's expensive to compute/large without actually computing it ;)
08:17:11 <Ariakenom> union-find is a cool structure if you want fancy stuff
08:17:15 <saml> but to balance tree, you need to compute before comparing stuff
08:17:27 <merijn> > let stuff = M.fromList [(1, [1..]), (2, [2..])] in M.lookup 1 stuff
08:17:30 <lambdabot>  Just [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
08:17:38 <merijn> saml: You need to compute the *keys*
08:17:41 <[Leary]> saml: you might be interested in bloom filters.
08:17:44 <merijn> saml: For sets you're right
08:18:37 <Ariakenom> You can have infinite keys in some structures
08:18:55 <merijn> If you can compare said infinite keys in finite steps, of course
08:19:01 <merijn> Getting something out might be hard... :p
08:20:55 <Ariakenom> ex you can build an infinite binary tree. and assign each node an Integer and store a value there. 0 bit go left, 1 bit go right, no more bits stop.
08:23:31 <tdammers> comparing infinite keys in finite steps, heh
08:24:40 <tdammers> newtype Borked a = Borked [a]; instance Ord a => Ord (Borked a) where compare (Borked xs) (Borked ys) = compare (listToMaybe xs) (listToMaybe ys) -- whee
08:24:55 <mycroftiv> http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/
08:25:41 <Cale> haha, that reminds me...
08:26:02 <Cale> instance Ord1 Down where liftCompare comp (Down x) (Down y) = comp x y
08:26:18 <Cale> This is currently what is in base
08:26:41 <nshepperd2> :[
08:26:47 <mycroftiv> also relevant: http://okmij.org/ftp/continuations/index.html#reify-search infinite lazy search trees with pluggable search methods
08:26:48 <Cale> http://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Functor.Classes.html#line-653
08:32:33 <kuribas> saml: why aren't there require queryparam type?  I find it strange that params are not required by default.
08:33:14 <saml> kuribas, it's because requiring them breaks monadic rule
08:33:25 <kuribas> saml: how?
08:34:18 <saml> to make unit return, it's easier to have it 0 required params 
08:35:13 <nshepperd2> 'data Keyed s k a = Keyed k a; keyed :: Reifies s (k -> a) => k -> Keyed s k a' seems like a legitimate case where you could have an Ord only look at part of the object
08:35:26 <nshepperd2> Since you know that same k implies same a
08:35:34 <nshepperd2> Not sure what it's good for though
08:36:34 <dmwit> How could you possibly know that?
08:36:50 <dmwit> Ah, okay, I see how you could possibly know that.
08:37:03 <dmwit> The s is like the ST trick, roughly.
08:37:22 <kuribas> I have a type RequiredQueryParam = QueryParam' '[Strict] 
08:37:33 <kuribas> saml: I would expect to have it in servant
08:38:04 <nshepperd2> dmwit: exactly
08:38:16 <kuribas> saml: I don't even see what queryparameters have to do with monads...
08:38:54 <kuribas> saml: it's not a big deal, I just defined it myself, just wondered why it wasn't there.
08:38:57 <saml> kuribas, i don't understand. I don't know what's queryparam. I thought you were joking because i'm Security Assertion Markup Language
08:39:09 * hackage hlint 2.2.5 - Source code suggestions  https://hackage.haskell.org/package/hlint-2.2.5 (NeilMitchell)
08:39:33 <kuribas> saml: ah sorry, alp is the guy I needed
08:40:05 <kuribas> (or gal)
08:40:44 <kuribas> saml: sorry for the confusion
08:43:09 * hackage th-lift 0.8.1 - Derive Template Haskell's Lift class for datatypes.  https://hackage.haskell.org/package/th-lift-0.8.1 (ryanglscott)
08:45:19 <Pamelloes> Are there any good techniques for finding cost centers in an optimized program?
08:45:39 * hackage mmsyn6ukr 0.4.0.5 - A musical instrument synthesizer or a tool for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.4.0.5 (OleksandrZhabenko)
08:45:43 <kuribas> alp: why isn't there a RequiredQueryParam type?  I find it strange that params are not required by default.
08:45:47 <saml> what are cost centers?
08:45:49 <alp> kuribas, well you could make a PR to suggest that we include such synonyms, but then do we really want one per combination, or do we want to stop midway? it's hard to draw a line there.
08:46:13 <kuribas> alp: I dunno, most of our params are required
08:46:23 <kuribas> maybe that's untypical...
08:46:28 <alp> kuribas, the default is to get a 'Maybe' because you can implement the required behaviour in terms of it, but not nice versa. so it's a bit more "universal" in a way
08:46:46 <Pamelloes> saml: They're what wind up in the .prof file whe you run with +RTS -p. They describe where your program spends most of its time,
08:47:46 <kuribas> alp: I find it ugly to write QueryParam' '[Optional, Strict] 
08:47:57 <alp> kuribas, at least that was my thinking when I wrote the first incarnation of QueryParam.
08:48:59 <alp> kuribas, yes, so do I, but I'm usually eager to define type synonyms whenever I'm going to resort to the non default behaviour a lot 
08:49:26 <kuribas> alp: ok, I see.
08:50:41 <alp> it's pretty cheap. the sample applies for patterns that occur many times in an API (so any kind of resource-ish abstraction).
08:51:02 <kuribas> alp: true, I have a pattern synonym for pagination :-)
08:51:09 <kuribas> ehm type synonym
08:51:30 <kuribas> and a helper function to collect al the similar arguments in a datatype
08:51:35 <alp> right
08:52:39 * hackage mmsyn6ukr 0.4.0.6 - A musical instrument synthesizer or a tool for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.4.0.6 (OleksandrZhabenko)
09:01:24 <dmwit> This mmsyn package family could really use better names. =P
09:02:01 <dmwit> mmsyn2, mmsyn3, mmsyn4, mmsyn5, mmsyn6ukr, and they all do completely different things
09:02:13 <AWizzArd> dmwit: oh really? (-:
09:05:34 <Pamelloes> dmwit: Wow, I didn't expect them to be _that_ unrelated.
09:09:51 <dminuoso> Is there a cute way to make a function `(a -> b) -> [a] -> [(a, b)]`?
09:10:12 <dminuoso> I feel like Arrow has this, but Ive been staring at Haskell for too long I think
09:10:14 <[exa]> dminuoso: reader?
09:10:32 <[exa]> dminuoso: does the 'mmsyn' actually mean anything?
09:10:39 <[exa]> oh sorry, dmwit^^
09:11:07 <[Leary]> % :t fmap . (id &&&)
09:11:08 <yahb> [Leary]: Functor f => (a -> c') -> f a -> f (a, c')
09:11:13 <glguy> > map (ap (,) (*2)) [1..5]
09:11:16 <lambdabot>  [(1,2),(2,4),(3,6),(4,8),(5,10)]
09:12:18 <solonarv> glguy: not enough operators
09:12:31 <solonarv> > ((,)<*>(*2))<$>[1..5]
09:12:33 <lambdabot>  [(1,2),(2,4),(3,6),(4,8),(5,10)]
09:13:15 <nshepperd> :t (.)(<$>)((,)<*>)
09:13:17 <lambdabot> Functor f => (a1 -> a2) -> f a1 -> f (a1, a2)
09:13:43 <[exa]> :t map . ((,) <*>)
09:13:45 <lambdabot> (a1 -> a2) -> [a1] -> [(a1, a2)]
09:26:20 <AWizzArd> Is there a way to serialize multiple Compacts into one single file? And also, is there a way to specify exactly at what position in a file (i.e. seek) I want to read in how many bytes and parse this as a Compact?
09:26:25 <dmwit> > (length "((,)<*>)", length "(id&&&)")
09:26:27 <lambdabot>  (8,7)
09:27:01 <dmwit> :t fmap fmap (ap (,))
09:27:03 <lambdabot> Functor f => (a1 -> a2) -> f a1 -> f (a1, a2)
09:28:46 <dmwit> AWizzArd: Do hPutCompact and hUnsafeGetCompact not work for you?
09:29:26 <AWizzArd> dmwit: not sure how to use them. Can I "limit" a Handle somehow, so that it works as a window into a file?
09:32:47 <glguy> > (,) `ap` (*2) `map` [1..5] -- solonarv: more operators
09:32:50 <lambdabot>  [(1,2),(2,4),(3,6),(4,8),(5,10)]
09:33:45 <dmwit> AWizzArd: You can use hSeek to move to a particular position. I do not believe you can restrict the head from moving past a certain point during hUnsafeGetCompact, but you could check after it finishes whether it is in the right spot.
09:34:24 <dmwit> But uh... where is the "how many bytes" requirement coming from?
09:34:40 <dmwit> What goes wrong if you just let hUnsafeGetCompact do its thing?
09:34:45 <solonarv> the question is, does hUnsafeGetCompact just gobble the entire file? or until end of file?
09:35:02 <solonarv> dmwit: I believe the idea is to serialize multiple Compact s into one file
09:35:05 <AWizzArd> dmwit: Yes, I could jump to the correct start position. I didn’t try this yet, but would hUnsafeGetCompact stop to read after the correct amount of bytes, if there really *is* a correctly compacted value?
09:35:23 <dmj`> jle`: your double Map trick was so cheeky
09:35:34 <nshepperd> @djinn (a -> b) -> (c -> d -> e -> a) -> (c -> d -> e > b)
09:35:35 <lambdabot> Cannot parse command
09:35:36 <AWizzArd> solonarv: yes right, I suspected that it might try to read the rest of the file.
09:35:58 <dmwit> Okay, good point; hUnsafeGetCompact does expect the entire (rest of the) file to be involved in the Compact you read.
09:36:03 <AWizzArd> solonarv: But possibly hPutCompact stores the size that hUnsafeGetCompact has to read also into the file.
09:36:32 <dmj`> jle`: but I've heard others constructed an undirected graph by parsing both the child -> parent, parent -> child maps into a single Map String [Direction String]
09:36:42 <solonarv> @djinn f :: (a -> b) -> (c ->d  -> e -> a) -> (c -> d -> e -> b)
09:36:42 <lambdabot> Cannot parse command
09:36:43 <dmwit> You could probably patch up the compact package to change that; or make a copy of it yourself to hack on.
09:36:47 <AWizzArd> dmwit: If I could create a "virtual handle" that presents itself as if there was a true full file behind it, then this could be used.
09:37:20 <solonarv> AWizzArd: that is probably doable if you write some C bits
09:37:27 <solonarv> possibly also without C bits
09:37:31 <AWizzArd> dmwit: I could have a look.
09:37:51 <AWizzArd> solonarv: Without changing the Handle code?
09:38:09 <AWizzArd> solonarv: Or you mean working with the Compact code, where the actual reading is taking place?
09:38:13 <dmj`> jle`: one cool trick for calculating the longest path is to call maximum on a [[a]]
09:38:27 <solonarv> AWizzArd: I am thinking you write a mix of Haskell and C hackery to produce such a restricted Handle
09:38:29 <dmj`> > maximum [[1,2,3],[3,4]]
09:38:33 <lambdabot>  [3,4]
09:38:45 <dmwit> Still, this seems weird. If the Compacts are going to be big, so the concern is only loading part of the file, why not make multiple files? Or if the Compacts are going to be small, then why write a Compact a, Compact b, and Compact c when you could just write a Compact (a, b, c)?
09:41:52 <dmwit> Okay. That's a silly objection. I withdraw it.
09:42:23 <AWizzArd> dmwit: the background is that I want to experiment with a data store, storing JSON.
09:43:01 <AWizzArd> dmwit: some million JSON objects. And I would not want to store them as text, but already as a Aeson `Value`.
09:43:16 <AWizzArd> So that I can simply read them back in without the need to parse anything. I directly get the correct bytes.
09:44:12 <dmwit> And a million-element Array would not be good for you?
09:44:17 <dmwit> (Just checking.)
09:45:05 <AWizzArd> dmwit: In what way? I need the JSONs in single/random quantities. So I can't have them all in RAM at once.
09:45:44 <AWizzArd> dmwit: Besides that, I really think that hUnsafeGetCompact has complected its core task with the storage format. This should be fixed in any case.
09:57:14 <Gurkenglas> How do I use MVectors to get (Monad m => (Int -> (m a, a -> m ())) -> m b) -> Vector a -> (b, Vector a)?
10:13:22 <Gurkenglas> unsafeRead -> "Yield the element at the given position. No bounds checks are performed." <- What happens if it tries to read out of bounds?
10:13:54 <dmwit> You get garbage, and possibly a crash.
10:14:28 <dmwit> I don't understand what behavior you want from your first type signature.
10:15:32 <dmwit> Oh, maybe I do.
10:17:46 <Gurkenglas> Oh, I probably want to use Data.Vector.modify
10:17:47 <dmwit> Something like: \f v -> runST do { mv <- thaw v; b <- f (\n -> (read n, write n)); v' <- freeze mv; pure (b, v') }
10:19:02 <dmwit> You can probably unsafeFreeze if you want.
10:23:03 <Gurkenglas> huh, http://hackage.haskell.org/package/vector-0.12.0.3/docs/Data-Vector.html#v:modify uses (forall s. MVector s a -> ST s ()) -> Vector a -> Vector a instead of (forall s. MVector s a -> ST s _x) -> Vector a -> Vector a
10:34:10 * hackage stack2cabal 1.0.4 - Convert stack projects to cabal.project + cabal.project.freeze  https://hackage.haskell.org/package/stack2cabal-1.0.4 (tseenshe)
11:08:42 <Raito_Bezarius> is there a way to have multiline string in ghci?
11:08:50 <Raito_Bezarius> like I want to copy a string and perform some stuff on it
11:09:03 <monochrom> No.
11:09:14 <Raito_Bezarius> :(
11:09:15 <Raito_Bezarius> Okay
11:09:41 <monochrom> Perhaps use getContents instead.
11:10:44 <matheus> objection, you can: https://hydraz.semi.works/snip/sel.a3f55.txt
11:11:24 <monochrom> Yeah right, vanilla copy-paste is going to do those \n and \ for you automatically, sure.
11:11:46 <Raito_Bezarius> Indeed, copy-paste is not going to do it
11:11:55 <Raito_Bezarius> I heard about some extension for QuasiQuote
11:11:58 <solonarv> IIRC getContents leaves stdin in a weird "semi-closed" state
11:11:59 <Raito_Bezarius> But I'm not sure how to enable it in GHCI
11:12:09 <solonarv> so you might not want to do that
11:12:10 <monochrom> QuasiQuote is not going to fly in ghci either.
11:12:46 <monochrom> Oh oops getContents immediately aborts ghci.
11:13:00 <monochrom> probably what solonarv means
11:13:23 <matheus> QuasiQuote will fly in ghci just fine..
11:13:25 <matheus> https://hydraz.semi.works/snip/sel.11b93.txt
11:13:49 <matheus> :set -XQuasiQuotes, then import Language.Haskell.TH.Quote, and Language.Haskell.TH
11:13:56 <Raito_Bezarius> I guess QuasiQuote is the simplest solution to this issue
11:14:22 * hackage mmsyn6ukr 0.4.1.0 - A musical instrument synthesizer or a tool for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.4.1.0 (OleksandrZhabenko)
11:14:56 <solonarv> you actually do not even need to import either of those
11:15:12 <solonarv> instead you need to import a string QQ from somewhere :P
11:15:54 <monochrom> Oh, the import is for hand-defining r = QuasiQuoter blah blah in situ.
11:16:02 <solonarv> oh, right
11:16:10 <matheus> yeah, instead of depending on a cabal package for a one-line QQ definition
11:16:13 <monochrom> People love to enter code by hand into ghci, right?
11:16:23 <monochrom> Then they love to ask "how do I save?", right?
11:16:26 <solonarv> you cuold put it in your ghci!
11:16:30 <solonarv> er, I mean .ghci
11:16:51 <monochrom> You could put it in a file.
11:17:47 <solonarv> if you want this QQ to be available in all your ghci sessions you will need to do it in .ghci anyway
11:18:24 <monochrom> I love false dichotomies like "either enter by hand into ghci or get from hackage", "either apt-get or build from source".
11:19:22 <monochrom> "either static-link everything or dynamic-link everything"
11:20:06 <LKoen> if you mix them, you'll dynamite everything
11:20:15 <monochrom> I was in a cafe and overheard a couple of students in a symoblic logic course almost (fortunately, only almost) thought that the negation of "everyone wears glasses" was "no one wears glasses".
11:20:46 <solonarv> ...you made me type 'coffee' instead of whatever I actually wanted to type
11:21:04 <solonarv> if you find yourself needing this often but don't want to depend on another package, a few lines in .ghci are probably the right approach
11:21:06 <monochrom> You were in a coffee? :)
11:21:28 <solonarv> no, but maybe a coffee should be in me
11:24:15 <monochrom> Fun fact: When in ghci, you don't have to import, you can use the long form, e.g., Language.Haskell.TH.Quote.QuasiQuote
11:24:44 <monochrom> Probably super-important (pun!) if you have code in .ghci
11:25:43 <boxscape> tsf h
11:25:45 <boxscape> oops
11:25:48 <boxscape> wrong keyboard layout
11:26:02 <boxscape> I was going to say, you can do that even in regular Haskell files with the right Extension enabled
11:26:23 <boxscape> or rather flag, actually
11:26:39 <monochrom> hrm what is the flag?
11:26:54 <boxscape> -fimplicit-import-qualified
11:33:10 <monochrom> Hrm it is not listed in 8.6.3 user's guide.  Also seems to do nothing (but not rejected).
11:33:25 <monochrom> But I should also try 8.8.1
11:34:14 <monochrom> Do nothing in 8.8.1 too.
11:34:25 <boxscape> oh, I guess I never actually tried it
11:34:32 <monochrom> My code is: main = print (Data.Char.ord 'X')
11:34:34 <boxscape> % :set -fno-implicit-qualified
11:34:34 <yahb> boxscape: Some flags have not been recognized: -fno-implicit-qualified
11:34:40 <boxscape> % :set -fno-implicit-import-qualified
11:34:40 <yahb> boxscape: 
11:34:46 <boxscape> % Data.Char.ord
11:34:46 <yahb> boxscape: ; <interactive>:172:1: error:; * No instance for (Show (Char -> Int)) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
11:34:55 <boxscape> hmm, interesting.
11:35:00 <boxscape> % :set
11:35:00 <yahb> boxscape: options currently set: none.; base language is: Haskell2010; with the following modifiers:; -XAllowAmbiguousTypes; -XBangPatterns; -XConstrainedClassMethods; -XConstraintKinds; -XDataKinds; -XNoDatatypeContexts; -XDeriveDataTypeable; -XDeriveFoldable; -XDeriveFunctor; -XDeriveTraversable; -XDisambiguateRecordFields; -XBlockArguments; -XEmptyCase; -XExistentialQuantification; -XExplici
11:35:13 <boxscape> this will list -fimplicit-import-qualified at the end
11:35:44 <monochrom> Ah yeah, 8.6.3 lists it too
11:36:20 <boxscape> actually if I disable it in my local ghci it really doesn't work anymore
11:36:39 <boxscape> strange that yahb is different, I thought it was 8.6.5 as well
11:36:45 <monochrom> OK "ghci -fno-implicit-import-qualified" has super-interesting results (TLDR a lot of not-in-scope errors and aborts)
11:37:38 <solonarv> boxscape: yahb just cuts off the output because it is too long
11:37:55 <solonarv> %% :set
11:37:56 <yahb> solonarv: http://qp.mniip.com/y/22
11:38:06 <boxscape> solonarv right, but I mean that if you do :set -fno-implicit-import-qualified yahb still seems to find Data.Char.ord
11:38:28 <boxscape> (and it's not at the end in that output because I turned it off)
11:38:29 <monochrom> Yeah, in ghci (after it starts successfully), ":set -fno-implicit-import-qualified" is effective.
11:38:44 <monochrom> just doesn't seem to do much for the compiler
11:38:49 <solonarv> guess you could put it in ghcid if you really want it to
11:38:58 <boxscape> I think someone just told me in ghci that it works for the compiler and I believed them
11:39:01 <boxscape> uh
11:39:03 <boxscape> in IRC
11:39:04 <boxscape> not in ghci
11:39:05 <boxscape> lol
11:39:16 <monochrom> Haha, I'm in a coffee, you're in a ghci
11:39:48 <monochrom> and lambdabot is on the phone
11:39:57 <boxscape> @where lambdabot
11:39:57 <lambdabot> http://haskell.org/haskellwiki/Lambdabot
11:40:04 <boxscape> oh I expected some jokey answer
11:42:51 * hackage mmsyn6ukr 0.4.2.0 - A musical instrument synthesizer or a tool for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.4.2.0 (OleksandrZhabenko)
11:47:18 <lavalike> now that's a package
11:47:51 * hackage mmsyn6ukr 0.4.2.1 - A musical instrument synthesizer or a tool for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.4.2.1 (OleksandrZhabenko)
11:48:26 <dmj`> jle`: tonight is where I stage my giant AoC comeback
12:03:09 <merijn> Tonight is where I stage my even further fall behind ;)
12:10:18 <jle`> dmj`: it's the weekend, so this is where the real fun begins :)
12:11:08 <aplainzetakind> How can I descend a rose tree in a tail-recursive way? Is it trick or am I missing an obvious approach?
12:11:12 <dmj`> jle`: they better not make it harder
12:11:20 <dmj`> jle`: after that virtual machine I'm spent
12:11:30 <dmj`> jle`: had a buzzer beater last night to finish day 5 before 6 was released
12:11:45 <aplainzetakind> s/trick/tricky
12:16:06 <jle`> dmj`: it seems to be alternating this year
12:16:40 <dmj`> jle`: so tonight is going to be a doozy?
12:17:29 <dmj`> aplainzetakind: you can write two mutually recursive functions, one to recurse on the parent, one to recurse on the child
12:18:39 <monochrom> Actually I don't understand the question.
12:18:52 * hackage streamly-fsnotify 1.0.0.0 - Folder watching as a Streamly stream.  https://hackage.haskell.org/package/streamly-fsnotify-1.0.0.0 (koz_ross)
12:19:17 <monochrom> Case 1: If "descend" just means walking down one path, the tail-recursive version is already trivial.
12:19:40 <monochrom> (or, the straightforward algorithm is already tail-recursive)
12:20:12 <monochrom> Case 2: If you're traversing the whole tree (so not "descend"), I have doubts about why insist on tail recursion.
12:21:53 <dmj`> merijn: never give up, trust your instincts
12:22:23 <merijn> dmj`: Not because I'm stuck, but because I'm several days short of sufficient hours in the week >.>
12:22:41 <dmj`> merijn: yea, it's hard to work a job and do AoC on the east coast
12:22:49 <dmj`> merijn: you gotta be fast, or wake up early
12:22:50 <jle`> dmj`: it might be an extra fun one :)
12:22:57 <dmj`> merijn: plus your brain is not that optimal at night
12:22:57 <aplainzetakind> monochrom: Traverse is what I meant. Why is tail-recursiveness irrelevant in that case?
12:23:12 <merijn> dmj`: Hard to work a job, do AoC, and code on your thesis in CET >.>
12:23:19 <dmj`> merijn: if you notice, both glguy and jle` are on the west coast.... so the deck is completely stacked against us
12:23:29 <monochrom> It can be done but it's awkward for no benefits.
12:23:39 <jle`> simply relocate
12:23:46 <merijn> aplainzetakind: Why do you think tail recursion matters?
12:23:56 <monochrom> awkward and obfuscating and error-prone and unreadable and etc
12:24:22 <monochrom> But the common "trick" is maintaining your own stack.
12:24:37 <merijn> jle`: You literally cannot pay me enough money to get me to do so :)
12:24:46 <aplainzetakind> Doesn't it make things more memory-efficient in general?
12:24:58 <merijn> aplainzetakind: Not "in general"
12:25:04 <aplainzetakind> I have a vague understanding of these matters obviously.
12:25:12 <merijn> Sometimes, in specific cases of laziness leaks
12:25:30 <monochrom> In fact, in general, is never more memory-efficient.  Just same shit in different forms.
12:25:38 <merijn> aplainzetakind: Tail recursion is important in strict languages so tail call optimisation can prevent call stack overflows
12:25:45 <jle`> merijn: not even temporarily?
12:25:59 <merijn> aplainzetakind: (GHC) Haskell does not even *have* a function call stack
12:26:46 <monochrom> Graham Hutton has papers showing you how to calculate the tail-calling, DIY-stack version.
12:26:56 <merijn> jle`: Well, it also depends on where, of course, but I was assuming we were referring to the US :p
12:26:58 <monochrom> You will find that it uses just as much space.
12:27:10 <monochrom> For the benefit of not understanding the code.
12:28:15 <monochrom> I once showed this to my students.  No one was able to follow.
12:28:56 <jle`> yeah, aiming for tail recursion in haskell in and of itself doesn't make much sense really
12:29:10 <jle`> in other languages it is a nice goal in and of itself because of TCO
12:29:29 <koz_> That was a habit I had to un-learn. :P
12:29:38 <monochrom> You don't even try tail recursion in C if you're attempting a tree traversal algorithm.  It's mental masturbation.
12:29:49 <jle`> there are situations where the "tail recursive" version can be better in your specific case, but it's not because of tail recursion, it's because of coincidence with other factors
12:29:59 <monochrom> You don't even try tail recursion in C if you're implementing graph DFS.
12:36:36 <monochrom> I should write a book called "Unreal World Haskell" for these.  Various ways of deriving obfuscated code from straighforward code for no reason (apart from urban legends and ideologies).
12:36:59 <koz_> monochrom: 'Surreal World Haskell' might be a better title. :P
12:37:06 <koz_> Or just 'Surreal Haskell'.
12:37:24 <monochrom> Yeah surreal is better!
12:37:32 <Solonarv_> I have an entry for you: translating imperative code that mutates variables everywhere into pure functional code
12:37:42 <nshepperd1> RealWorld Haskell
12:38:03 <Solonarv_> I prefer s Haskell
12:38:07 <koz_> nshepperd1: So... basically 'everything in IO'?
12:38:21 <koz_> That's RealWorld Haskell.
12:38:22 <dsh> one giant do statement
12:38:28 <Solonarv_> oops, typo: I prefer forall s. s Haskell
12:38:38 <koz_> Solonarv_: ST Haskell. :P
12:38:42 <Solonarv_> yes :D
12:44:11 <monochrom> Here: http://www.vex.net/~trebla/tmp/NumStack.hs
12:51:19 <EvanR> (forall s . s s) (forall s . s s)
12:52:59 * solonarv sweats profusely
13:08:52 <[itchyjunk]> this might be slightly offtopic, but why does quantitative analysts use functional programming?
13:09:02 <[itchyjunk]> i didn't know fp was popular in that quant sector :s
13:10:46 <EvanR> they have money to blow? :P
13:12:40 <[itchyjunk]> heh
13:13:00 <[itchyjunk]> well there must be something about functional programming that they like
13:13:00 <merijn> [itchyjunk]: There's a whole bunch of banks using Haskell
13:13:09 <merijn> [itchyjunk]: A bunch of FinTech startups too
13:13:09 <[itchyjunk]> merijn, :O why banks?
13:13:28 <[itchyjunk]> is it just a random trend? or there is actual reason?
13:13:46 <merijn> [itchyjunk]: Last time I talked to Lennart about Haskell in Standard Chartered he said they have 1.5 million LOC of GHC Haskell and 1 million LOC of Mu (their internal Haskell compiler)
13:14:06 <[itchyjunk]> :O
13:14:17 <merijn> [itchyjunk]: Less bugs than many other languages, easy to test, nice for quick prototyping
13:14:30 <[itchyjunk]> oh less bugs.. maybe thats a good reason
13:14:47 <merijn> Barclays reached out to me because they were starting a Haskell group at some point too
13:15:09 <merijn> [itchyjunk]: See also: https://wiki.haskell.org/Haskell_in_industry
13:15:18 <merijn> Hah, top entry ABN AMRO, another bank ;)
13:15:29 <merijn> I know Target (the store) uses Haskell for their logistics backend
13:15:53 <[itchyjunk]> wow crazy
13:16:12 <[itchyjunk]> here i thought fp was something pure math type people enjoyed using
13:16:41 <solonarv> well, they do! they're just not the only ones :D
13:18:02 <[itchyjunk]> true
13:18:39 <[itchyjunk]> so many of these trading type companies seem to use it!
13:18:50 <[itchyjunk]> AT&T too!
13:19:19 <[itchyjunk]> what about the machine learning scene, is fp use for that stuff?
13:21:51 * hackage mmsyn6ukr 0.4.2.2 - A musical instrument synthesizer or a tool for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.4.2.2 (OleksandrZhabenko)
13:22:18 <merijn> [itchyjunk]: There's some people doing it, but I don't know how many
13:22:26 <[itchyjunk]> ah
13:24:09 <EvanR> yes you could take the obvious route and list all the advantages of haskell for programming
13:24:39 <EvanR> the followup question "then why is not everyone using it for everything" might be answered by "these banks and financials have the money to blow"
13:24:56 <glguy> Or that the banks lose a lot of money if they aren't quick enough or make mistakes
13:25:25 <EvanR> yeah, the alternate question would be how do most people get by without haskell. Fair
13:25:45 <merijn> EvanR: They don't, poor souls
13:26:01 <EvanR> the answer might be "with a little help from my friends"
13:26:21 <merijn> tbh, the most underrated killer feature of Haskell is how easy it is to do FFI, drop to low level stuff and wrap up all sorts of ugly low level dirtiness in a convenient high level interface
13:26:41 <[itchyjunk]> whatf FFI? :s
13:26:55 <EvanR> still waiting for the opengl version of that
13:27:03 <merijn> [itchyjunk]: Foreign Function Interface, i.e. "call C (or other code that has a C FFI) from Haskell"
13:27:44 <EvanR> (ok there's gpipe)
13:27:45 <[itchyjunk]> ah. i think i heard that term in context of python and numpy or somesuch.
13:28:00 <merijn> [itchyjunk]: Yeah, but Python's FFI is a pain to use :p
13:28:23 <[itchyjunk]> ah 
13:29:13 <EvanR> [itchyjunk]: most languages have something like this, java calls it the native interface
13:29:20 <EvanR> for some reason
13:37:23 <merijn> [itchyjunk]: So if you know C it's super low-effort to quickly use some C code if you have to (for speed or for reasons like "this library doesn't exist in Haskell yet")
13:39:46 <[itchyjunk]> merijn, ah i see. i never thought of it that way
13:40:03 <[itchyjunk]> so people who know haskell in conjuction of some other language can leverage both
13:41:32 <merijn> [itchyjunk]: See for example: https://github.com/merijn/posix-pty/blob/master/System/Posix/Pty.hs#L283-L297
13:41:57 <merijn> [itchyjunk]: Which lets you just call these functions: https://github.com/merijn/posix-pty/blob/master/cbits/fork_exec_with_pty.c
13:45:09 <[itchyjunk]> hnnn
13:46:09 <[itchyjunk]> interesting, looks like you can just call the C stuff. i'm guessing it's not this straightforward in other languages
13:47:17 <merijn> [itchyjunk]: You're limited to integer/double values and pointers (so you can't pass/return structs/union), but since you *can* pass pointers to structs/unions that's not a big problem in practice
13:48:57 <geekosaur> there's a utility called swig which helps to write such interfaces for other languages
13:50:12 <geekosaur> in Haskell, for more complex values (e.g. structs) you do need a Storable instance, but writing those is straightforward enough that the swig-like utility that used to exist fell into disuse something like a decade ago and is long bitrotted
13:50:29 <geekosaur> (greencard, if anyone cares)
13:50:33 <[itchyjunk]> :o
13:51:59 <matheus> interesting that GHC can't derive Storable instances
13:52:34 <merijn> matheus: What would deriving those mean?
13:52:37 <geekosaur> there is c2hs which is useful when translating C header files in bulk, most useful for writing interfaces to large/complex C APIs
13:52:58 <merijn> matheus: Like, suppose I have "data Foo = Foo Int Double" what would that produce?
13:54:40 <matheus> Would probably get laid out in memory like the C struct { int x; double y; }, I suppose?
13:55:07 <merijn> matheus: See, the problem is that it is implementation defined how a C compiler lays that out in memory
13:55:18 <matheus> fair point
13:55:34 <geekosaur> this also gets more interesting if it's: data Foo = Foo Int Double | Bar Double Double
13:55:52 <merijn> matheus: It's not guaranteed to be the same across C compilers even, and the C ABI (the thing we use for portable cross-compiler/cross-language interaction) explicitly doesn't describe how structs/unions are laid out in memory
13:55:59 <geekosaur> because there are a number of ways to represent the tagged union, none directly applicable to C which has untagged unions
13:56:58 <merijn> matheus: c2hs and co actually generate C code that outputs strings of Storable instances with the right sizes/offsets inserted, which (tbh) is rather a hack
13:57:13 <matheus> indeed
13:57:25 <merijn> Absolute best solution is "try and avoid having to deal with struct layout unless you control them yourself and even then"
13:57:56 <matheus> for the product case, laying out the fields in sequence seems to be what the instances in base do already, so i'm not sure why an instance that does that can't be derived
13:58:17 <matheus> (c.f. Ratio and Complex)
13:58:37 <merijn> Complex is at least defined in C11 and C++11
13:58:50 <merijn> i.e. it's guaranteed to be two densely packed doubles
13:59:09 <merijn> Ratio doesn't really have a corresponding C notion, afaik
14:00:43 <matheus> Complex isn't required to be two Doubles, though, you can make a 'Complex Word8' and that'll be poke'd as just two bytes
14:01:06 <merijn> matheus: Sure, but C can't access that directly anyway :)
14:01:26 <glguy> I don't think C99 defines a complex word-8
14:02:46 <merijn> glguy: It doesn't
14:03:06 <glguy> afaik it only has complex double/float/long double
14:10:33 <solonarv> no love for gaussian integers :(
14:42:18 <dmj`> gauss knew some things
14:45:43 <solonarv> have a look at "list of things named after Carl Friedrich Gauss" sometime
14:45:54 <solonarv> there are quite a lot of them
14:49:02 <[itchyjunk]> gauss loved quadratic recipocity
14:49:21 <[itchyjunk]> he had 5 published proofs and they found 2 more in his notes after his death i think
16:02:24 <iqubic> The Peano Numbers are quite natural.
16:03:27 <hpc> /kick iqubic
16:09:11 <ziman> nah, they succ
16:10:00 <evelyn> prove it!
16:19:38 <Olius> Hiya! Anybody here tried to use ghcup with macOS <= 10.10 (Yosemite)?
16:21:10 <Olius> mktemp doesn't seem to work correctly; I saw they consciously tried to cater to old Macs, but I don't know how old.
16:34:40 <koz_> iqubic: That pun made me groan.
17:10:35 <maralorn> I liked it!
17:17:30 <dmj`> jle`: next year, you should try to do every AoC using just hmatrix
17:19:48 <efm> [itchyjunk]: my understanding is that JaneStreet started using Ocaml, then realized they were like most of the Ocaml community, and didn't want to stop using it, so they started sponsoring FP seriously
17:21:01 <[itchyjunk]> oh
17:21:46 <efm> https://www.janestreet.com/technology/
17:22:42 <efm> another tool popular in Finance, and not much in other places is kdb+ 
17:23:01 <efm> that's APL-ish
17:23:39 <efm> The tensorflow of it's time
17:52:09 <dmj`> efm: kdb's query language is extremely awful
17:52:18 <dmj`> it's almost half as non-sensical as R
17:52:34 <dmj`> or any other language created by physicists / statisticians w/ no regard for PLT
18:03:26 <dansho> like python?
18:05:17 <dmj`> yea
18:05:31 <dmj`> python is a snake in the grass
18:05:54 <dmj`> just waiting to bite ya
18:38:09 <efm> dmj`: that sounds painful. R was extremely hard to learn
18:38:45 <dsal> R is OK.  It wasn't hard to learn in a good way.
18:47:35 <dsal> Everybody was throwing around their performance numbers for their AoC day 4 solution.  I was snowboarding, so just now got around to it, but By the Power of Haskell: http://public.west.spy.net/tmp/bench.html
18:56:57 <dmj`> R is trash
18:57:07 <dmj`> R put the 'r' in trash
18:58:10 <dsal> I like ggplot2
18:58:27 <dmj`> but does ggplot2 like you
19:00:18 <dsal> Something doesn't... I've got a program that runs pretty well for a while, and on one computer, just spins out of control.  No idea what causes it.
19:01:01 <dmj`> dsal: maybe it's the beginning of the AI takeover
19:01:30 <dsal> Yeah.  It's not a super powerful computer, so they're probably just testing the waters.
19:12:43 <dmj`> ya never know these days
19:13:11 <dmj`> could be a black budget deep state project
19:13:29 <dsal> Yeah.  I wish I could get backtraces or something...
19:13:49 <pounce> so is all = (foldl (&&) .) . map
19:13:57 <dsal> @src all
19:13:57 <lambdabot> all p = and . map p
19:14:27 <dmj`> :t foldl1 (&&)
19:14:29 <lambdabot> Foldable t => t Bool -> Bool
19:14:35 <pounce> cool
19:14:42 <dmj`> > foldl1 (&&) [True, True]
19:14:44 <lambdabot>  True
19:14:51 <solonarv> might be foldr actually
19:14:53 <dmj`> @src and
19:14:53 <lambdabot> and = foldr (&&) True
19:15:01 <dsal> foldl is kind of a "do not use" feature.
19:15:02 <dmj`> solonarv gets the prize
19:15:07 <pounce> oh, ye sorry
19:15:13 <pounce> always forget which is which
19:15:18 <dmj`> foldl is evil ! but foldl1 ... is fine ;) 
19:15:25 <ephemient> or `foldr (&&) True`
19:15:36 <solonarv> I reasoned like so: 'all' should be able to short circuit. foldl cannot even short circuit. therefore 'all' must be a foldr.
19:15:43 <ephemient> > and []
19:15:45 <lambdabot>  True
19:15:45 <solonarv> *cannot ever
19:15:53 <dmj`> > foldr (&&) [False, undefined]
19:15:55 <lambdabot>  error:
19:15:55 <lambdabot>      • Couldn't match expected type ‘Bool’ with actual type ‘[Bool]’
19:15:56 <lambdabot>      • In the second argument of ‘foldr’, namely ‘[False, undefined]’
19:16:13 <dmj`> > foldr (&&) True [False, undefined]
19:16:15 <lambdabot>  False
19:16:25 <dsal> > all (&&) [False, undefined]
19:16:27 <lambdabot>  error:
19:16:28 <lambdabot>      • Couldn't match type ‘Bool -> Bool’ with ‘Bool’
19:16:28 <lambdabot>        Expected type: Bool -> Bool
19:16:31 <dmj`> > foldl (&&) True [False, undefined]
19:16:33 * dsal sigh
19:16:33 <lambdabot>  False
19:16:37 <dsal> > all [False, undefined]
19:16:39 <lambdabot>  error:
19:16:39 <lambdabot>      • Couldn't match expected type ‘a -> Bool’
19:16:39 <lambdabot>                    with actual type ‘[Bool]’
19:16:44 <dsal> :t all
19:16:46 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
19:16:48 <dsal> oooh
19:16:51 <solonarv> :t and -- this
19:16:53 <lambdabot> Foldable t => t Bool -> Bool
19:17:01 <solonarv> anyway:
19:17:03 <dsal> > and [False, undefined]
19:17:06 <lambdabot>  False
19:17:10 <dsal> > all id [False, undefined]
19:17:13 <lambdabot>  False
19:17:16 <solonarv> > foldl (&&) True (False : undefined)
19:17:18 <dsal> OK.  Sorted.
19:17:19 <lambdabot>  *Exception: Prelude.undefined
19:17:31 <solonarv> > foldr (&&) True (False : undefined)
19:17:34 <lambdabot>  False
19:18:13 <solonarv> foldl might not force every list element (that depends on the function you pass to it), but it *will* force the entire list spine
19:18:29 <solonarv> > foldl (&&) True (repeat False)
19:18:38 <lambdabot>  mueval: ExitFailure 1
19:18:44 <solonarv> > foldr (&&) True (repeat False)
19:18:46 <lambdabot>  False
19:20:28 <solonarv> pounce: is your question answered satisfactorily?
19:21:45 <pounce> yee
19:22:03 <pounce> sorry, working in racket atm and im trying to go between the two langs/irc channels and it's confusing me lol
19:22:34 <solonarv> I figured something like that would be the case, that's why I pinged you :)
19:22:43 <pounce> thanks ♥
19:34:12 <dsal> I solved my problem with LimitCPU
19:38:49 <iqubic> What is LimitCPU?
19:49:39 <dsal> ulimit in systemd.  If my program spins out of control, it'll get killed.
19:49:44 <dsal> Also, if it works fine for too long, it'll get killed.
20:02:44 <iqubic> Why would you want that?
20:05:13 <slack1256> iqubic: Sometimes you can't patch some services (shipped with the distro etc), so a way to troubleshoot that without asking for the code is to kill and restart on some condition, as cpu time can be.
20:05:27 * slack1256 saw some RHEL-nightmares.
20:06:44 <monochrom> dsal: w00t how can I also do that?
20:07:26 <dsal> iqubic: What I *want* is to know what it's doing when it spins out of control, but SIGQUIT doesn't work, so when it gets itself into this situation, I can't do much more than restart it.
20:07:58 <monochrom> Oh, I guess it's a config file for a service, and the config file specifies a time limit.
20:08:09 <dsal> CPU time, yeah.  systemd
20:08:49 <slack1256> That sound something like ebpf on linux should help.
20:10:41 <dsal> dtrace would be great.
20:10:43 <monochrom> ebpf looks like llvm and jvm...
20:15:28 <nfd9001> doesn't ghc have an experimental llvm backend?
20:15:36 <monochrom> Yes
20:15:50 <monochrom> Now we just need an experimental ebpf backend :)
20:16:39 <slack1256> Shouldn't ebpf just work with any program running on linux?
20:17:07 <monochrom> dunno, only googled it five minutes ago
20:17:07 <heatsink> doesn't ghc have a non-experimental llvm backend?
20:17:13 <monochrom> Yes
20:17:59 <slack1256> I think the llvm backend is not experimental anymore. It is just a pain to use because the llvm api changes so much.
20:19:27 <ephemient> doesn't GHC for AArch64 *only* have LLVM codegen?
20:21:41 <dmj`> ephemient: no
20:21:55 <ephemient> hmm, I misremember then
20:22:12 <dsal> This is aarch64
20:22:26 <dsal> I built the compiler, but I forgot everything about it.
20:22:42 <ephemient> I do remember it being practically impossible to find a GHC that would run *on* my Android, but maybe that was for other reasons
20:29:12 <dsal> Database/SQLite/Simple/Ok.hs fails to build because fail.
20:32:11 <ephemient> MonadFail
20:34:00 <dsal> Yeah.  Just hoping everything fixes itself.
20:45:24 <mozzarella> bang
20:45:28 <mozzarella> then boom
20:45:32 <mozzarella> bob's your uncle
20:45:34 <mozzarella> enjoy
20:46:52 * hackage tmp-postgres 1.28.0.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.28.0.0 (JonathanFischoff)
20:52:49 <dmj`> jle`: where are you
20:52:56 <dmj`> jle`: santa is leaving soon
21:51:47 <iqubic> Anyone have know of a good tutorial where I can learn about threading in haskell.
21:52:41 <iqubic> Specifically I need threading and queues.
21:53:41 <c_wraith> for AOC?  You don't need that.  Laziness is enough.
21:53:47 <iqubic> Really?
21:53:58 <iqubic> I'm working on part 2 today.
21:54:10 <c_wraith> I just finished part 2.  "You got rank 390 on this star's leaderboard."
21:54:23 <jacks2> AOC?
21:54:37 <c_wraith> laziness is *almost* cheating, looking at how far I moved forward from my rank on part 1.  :)
21:55:38 <shachaf> Today's AOC challenge is to prove that every vector space has a basis.
21:55:48 <iqubic> Currently I have this: "execProg :: [Int] -> Memory -> [Int]"
21:56:00 <c_wraith> If you want threads and queues, look at forkIO https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Concurrent.html#v:forkIO and Chan (https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Concurrent-Chan.html)
21:56:28 <c_wraith> If you're production in your output, that type is good enough for laziness
21:56:32 <c_wraith> *productive
21:56:51 <iqubic> Where I can't modify inputs after the program has started execution and I can't get outputs of the program until it has finished executing.
21:57:57 <c_wraith> Sure you can.  let outputA = execProg (phaseA : 0 : outputE) ; outputB = execProg (phaseB : outputA) ...
21:58:41 <c_wraith> Since the problem guarantees it will eventually terminate, that's all you need to know that it will eventually stabilize.
21:59:35 <c_wraith> jacks2: advent of code. https://adventofcode.com/2019
22:00:46 <c_wraith> iqubic: the whole point of laziness is that you don't need to worry about order of evaluation.  As long as *some* order works, it will work out.
22:06:37 <nshepperd> iqubic might have written the program in a way that is less lazy than required
22:06:41 <monochrom> shachaf: hahaha
22:06:56 <c_wraith> nshepperd: true, though that type at least makes it possible to be as lazy as required
22:07:05 <nshepperd> I had to modify mine to be productive in the output
22:07:42 <c_wraith> I had to write a new "run" function, but my "step" function was still fine.  That wasn't much work, especially since I figured it was coming.
22:08:01 <c_wraith> and step has all the logic in it.
22:09:00 <nshepperd> today's puzzle certainly shows off the magic of laziness
22:09:09 <c_wraith> yeah
22:09:36 <iqubic> I don't think I did this right.
22:10:14 <iqubic> Here's what I have for the "wiring" http://dpaste.com/0TDZYNN
22:10:46 <iqubic> Here's where I test all the settings: http://dpaste.com/30ESYNG
22:10:49 <c_wraith> you want the last output from E, not the first
22:11:31 <iqubic> Good. That was easy.
22:12:15 <c_wraith> Getting the right answer now?
22:12:52 <iqubic> Yes.
22:13:08 <c_wraith> nice
22:13:18 <c_wraith> now, the important question - you see how that's working?
22:14:10 <iqubic> I do indeed.
22:14:26 <c_wraith> Sometimes Haskell feels like cheating. :)
22:14:36 <iqubic> I know. It really does.
22:15:15 <iqubic> In any other language this would be a complex exercise in threading and mutable state and channels.
22:15:38 <c_wraith> You could do it without, with some sort of "runUntilNextOutput" function
22:15:55 <iqubic> Sure. But that also sounds hard.
22:16:00 <c_wraith> it would be
22:16:47 <iqubic> But this challenge required 0 changes to my day 5 code.
22:17:16 <c_wraith> always nice when your design turns out to keep working. :)
22:17:24 <iqubic> I know.
22:17:52 <ChaiTRex> What's a spiffy way of implementing maybeMinimum [] = Nothing; maybeMinimum xs = Just (minimum xs)?
22:18:07 <c_wraith> honestly, I'd leave it like that.
22:19:16 <iqubic> c_wraith: lists are basically just a poor man's TChan.
22:19:47 <nshepperd> TChan is a poor man's lists :p
22:20:02 <iqubic> Why do you say it like that?
22:20:10 <c_wraith> ChaiTRex: though you could do stuff like   fmap minimum . Data.List.NonEmpty.nonEmpty
22:20:32 <nshepperd> for when you are stuck in IO with side effects but must soldier on anyway
22:20:32 <c_wraith> ChaiTRex: I don't think it's a real improvement, but it is an option!
22:22:17 <ChaiTRex> c_wraith: Ahh, thanks.
22:22:26 <ChaiTRex> c_wraith: I think I'll probably leave it.
22:23:17 <nshepperd> there's a Min monoid you could foldMap over too
22:24:24 <nshepperd> fmap getMin . foldMap (Just . Min)
22:25:00 <iqubic> I love when I get to use knot tying in Haskell.
22:28:46 <ChaiTRex> nshepperd: Thanks. I'll take a look at it.
22:28:53 <slack1256> iqubic: I like it too. I feel I am justifying laziness a bit.
22:44:39 <paulasdf> that AOC problem was fun. took me an hour. pretty sloppy but look forward to refactoring.
22:51:05 <iqubic> It took me like a 10 minutes for part 1, and then 15 minutes for part 2.
22:51:59 <iqubic> The first 10 minutes of working on part 2 was me researching how to do threading and TChans in Haskell. Eventually I figured out a simple way of doing it.
22:52:16 <c_wraith> figured out. :P
22:52:54 <iqubic> Well, I asked in here for a good Threading and TChan tutorial.
22:53:14 <iqubic> But you people quickly figured out that it was an XY problem and gave me a better solution.
22:54:01 <iqubic> In my defence, Threads and TChans would have worked well.
22:56:11 <iqubic> c_wraith: Are you doing AoC this year?
22:56:16 <c_wraith> yeah
22:56:31 <c_wraith> though I'm not worrying about trying particularly hard.
22:56:40 <iqubic> Neither am I.
22:57:03 <iqubic> But somehow I'm 8th on the IRC private leaderboard for today.
22:58:28 <iqubic> c_wraith: Why was your Intcode interperter from day 5 not lazy enough to tye the knot for the feedback loop today?
22:58:59 <c_wraith> I had "all the output in reverse" as part of the interpreter state, because I was just being lazy on day 5
22:59:08 <iqubic> Ah. I see.
22:59:46 <iqubic> I used MonadWriter and tell to get write to the output. Seems lazy enough for today.
22:59:59 <iqubic> But I'm also storing the input as part of the state too.
23:00:54 <iqubic> After I read a value from the input, I update the state so that the new list of input is equal to the tail of the input.
23:01:04 <iqubic> All that just seemed to work just fine.
23:01:10 <c_wraith> yeah, that's how mine works too
23:01:40 <iqubic> With MonadWriter for output?
23:01:52 <c_wraith> No, the input part
23:02:30 <iqubic> I'm using this:  "type Interperter = StateT Memory (Writer [Int]) ()"
23:02:55 <iqubic> With memory being this: http://dpaste.com/0AS1H8G
23:52:20 <aplainzetakind> Seq.viewl is strict right?
23:59:32 <kaol> Is there a way to make ctrl-C in ghci kill child threads too? For example, forkIO (forever $ threadDelay 1000000 >> putStr "a") >> (forever $ threadDelay 1000000 >> putStr "b") keeps on printing "a".
