00:05:26 <maralorn> Hm, new I implemented it myself and endet with the same code. I enabled flexible instances now …
00:34:16 <jusss> a funciton f, which take another function g as its parameter, call g in f, and g never go back in f, f is a continuation-passing function, g is the continuation, right?
00:37:09 <dminuoso> "continuation-passing function" is not really a term Ive heard.
00:37:16 <dminuoso> "continuation-passing" is a coding style.
00:37:40 <dminuoso> jusss: And no, f might do things after g.
00:38:04 <dminuoso> For example `withConnection :: (Connection -> IO a) -> IO a` usually does resource cleanup after the continuation is done.
00:38:23 <jusss> dminuoso: then it's against the "and g never go back in f"
00:38:28 <dminuoso> jusss: Right.
00:38:46 <jusss> dminuoso: so f won't do thing after g
00:39:01 <dminuoso> jusss: Well "after" is a difficult term.
00:39:44 <jusss> dminuoso: may use "call g in the last code in f"?
00:39:52 <jusss> of f
00:40:11 <dminuoso> jusss: If we are talking about `withConnection`, what such a continuation would usually do, is prepare a connection handle, provide it to your continuation, and then close the connection using `finally`
00:40:34 <dminuoso> (The finally is done to ensure that the resource is released even if your continuation throws an exception)
00:41:21 <jusss> dminuoso: how you describe the function f :: (a->r) -> r?
00:41:49 <jusss> if (a->r) is the type of a continuation
00:42:48 <jusss> Cont r a >>= ...   this Cont r a is a continuation?
00:43:01 <dminuoso> jusss: Id call it a continuation handler, maybe.
00:43:28 <jusss> err, wait, there's no Cont r a, right?
00:43:32 <dminuoso> jusss: Sure there is.
00:43:40 <jusss> type Cont r = ContT r Identity
00:43:53 <jusss> Cont is defined by ContT
00:44:00 <jusss> type Cont r = ContT r Identity
00:44:01 <kuribas> jusss: that's fabricating an 'a' out of thin air.
00:44:03 <dminuoso> jusss: It turns out that Cont and ContT are the same thing. :)
00:44:12 <dminuoso> kuribas: Nope.
00:44:34 <dminuoso> kuribas: type aliases can be defined to be non-saturated on the RHS.
00:44:38 <jusss> dminuoso: wait a sec, Cont is a Monad, ContT is a Monad Transformer
00:45:01 <dminuoso> jusss: Try implementing the monad instance for both. It's an interesting excercise.
00:45:19 <jusss> dminuoso: I even don't know the data type of Cont...
00:45:35 <jusss> I can't find its definition on the haskell.org
00:45:38 <kuribas> dminuoso: "(a implies r) implies r", is the same as "a" is true, logically
00:45:42 <jusss> it's defined by ContT
00:45:42 <dminuoso> data Cont r a = Cont { runCont :: (a -> r) -> r }
00:46:18 <dminuoso> equivalently
00:46:25 <dminuoso> data ContT r m a = Cont { runCont :: (a -> m r) -> m r }
00:46:49 <dminuoso> Err
00:46:53 <dminuoso> data ContT r m a = ContT { runContT :: (a -> m r) -> m r }
00:46:56 <dminuoso> :)
00:47:43 <jusss> dminuoso: it reminds me about Reader...
00:48:13 <jusss> there's a Kleisli arrow in its type
00:48:17 <kuribas> dminuoso: right, it's a clojure containing some a, which is passed to the continuation
00:48:19 <dminuoso> It's quite unlike Reader.
00:48:23 <kuribas> dminuoso: closure
00:48:28 <dminuoso> kuribas: Might not be a closure.
00:48:34 <dminuoso> kuribas: A closure is a particular type of implementation.
00:49:09 <dminuoso> I'd just call it a continuation handler.
00:49:27 <dminuoso> It knows how to handle/run a continuation.
00:49:36 <kuribas> dminuoso: it must get an a from somewhere
00:49:44 <jusss> >>= :: Cont r a -> (a -> Cont r b) -> Cont r b 
00:50:21 <jusss> >>= :: ContT r m a -> (a -> ContT r m b) -> ContT r m b?
00:52:49 <jusss> data Cont r a = Cont (a->r) -> r;  x :: Cont r a;  x is the `continuation handler'?
00:53:56 <jusss> it needs a (a->r) to extract the r?
00:54:09 <kuribas> jusss: x is a continuation, which is a function which accepts the result of the previous computation.
00:54:44 <jusss> kuribas: wait, x >>= \...    this x is a continuation?
00:55:34 <kuribas> jusss: yes
00:56:18 <jusss> "<heatsink> Cont values are not continuations.  They are continuation-passing functions.  The continuation-passing part is hidden inside the monad.                                                       [15:01]"
00:56:27 <mycroftiv> continuations are a really deep subject, http://okmij.org/ftp/continuations/ has a ton of material including some introductory/tutorial code
00:59:18 <kuribas> jusss: well, technically it's the continuation, with the previous value already filled in.
00:59:38 <kuribas> jusss: so it's the part which computes a new value, and passes it to the next continuation
01:00:43 <jusss> kuribas: then what's the context? what's the effect?
01:01:09 <kuribas> jusss: I'd say the context is the next continuation, the effect is passing the computed value to the next continuation.
01:01:39 <jusss> kuribas: but some people said Cont Monad doesn't have an effect...
01:01:48 <jusss> not all Monads have effects...
01:02:03 <kuribas> jusss: indeed, not a real effect, like in IO
01:02:35 <kuribas> jusss: it's like emulating non-local jumps in imperative language, though it's more powerful than that.
01:02:47 <haskeldjiq> guys
01:02:49 <haskeldjiq> https://pastebin.com/MpW2096b
01:02:54 <haskeldjiq> does anyone know if something like this is possible
01:03:00 <haskeldjiq> and how would the function signatures look like
01:04:17 <haskeldjiq> essentially modeling a store that can hold multiple types of entities
01:04:51 <jusss> kuribas: err.. is there a clear definition of `continuation'? not something about CPS and callCC?
01:05:17 <kuribas> jusss: continuations are linked to CPS and callCC
01:05:37 <jusss> kuribas: if even there's no CPS and callCC, continuation still exists
01:06:01 <MarcelineVQ> haskeldjiq: I don't understand what you're aswking there. but when you said earlier "there should be some sort of a way to express a Store that is able to hold multiple types of entities"  https://hackage.haskell.org/package/dependent-map might be an option
01:06:07 <kuribas> jusss: having a continuation implies doing CPS, or having a low level primitive (like in scheme)
01:06:37 <haskeldjiq> MarcelineVQ: think about having a typeclass for a sql database (for example)
01:06:39 <jusss> even from https://wiki.haskell.org/Continuation,  it's talk about CPS and callCC, not really about what exactly is a continuation
01:06:55 <jusss> scheme provide call/cc to capture continuation
01:06:55 <haskeldjiq> MarcelineVQ: the typeclass would allow you to query for multiple entities
01:07:06 <jusss> but it doesn't define it in scheme
01:07:19 <haskeldjiq> MarcelineVQ: I know it is possible just don't know how
01:07:33 <kuribas> jusss: loosely, you could say, a continuation is a function which you accept, which you pass the computed value.  It represents "the rest of the computation".
01:07:40 <merijn> haskeldjiq: I'd accomplish this by having a generic query type
01:07:56 <jusss> kuribas: (+2) is a continuation?
01:07:58 <merijn> haskeldjiq: So that in your class you'd just get "foo :: Query a -> m (Result a)" or something
01:08:01 <kuribas> jusss: could be
01:08:10 <merijn> haskeldjiq: Then the type of 'a' doesn't have to be defined or handled in your class
01:08:21 <kuribas> jusss: it implies that you never return a value.
01:08:24 <jusss> kuribas: f = \x -> (x 2)   this f is a continuation?
01:08:33 <merijn> haskeldjiq: I'd also add that I would probably avoid making a class for that sorta thing, though
01:08:35 <kuribas> jusss: sure
01:08:43 <merijn> jusss: any function can be a continuation
01:08:48 <haskeldjiq> merijn: why do you think it's bad
01:08:58 <haskeldjiq> merijn: like, not bad, but why wouldn't you
01:09:13 <merijn> jusss: So "is 'f' a continuation?" is always "yes" if 'f' is a function
01:09:15 <jusss> kuribas: but (+2) :: Int -> Int,  it return a Int
01:09:44 <merijn> jusss: 'f' is not continuation passing style, but it can be a continuation
01:09:47 <kuribas> jusss: the first google link on scheme gives me a definition: https://courses.cs.washington.edu/courses/cse341/04wi/lectures/15-scheme-continuations.html
01:09:55 <haskeldjiq> merijn: we have an event-sourced system and these "stores" are used to store projections
01:09:57 <kuribas> An expression's continuation is "the computation that will receive the result of that expression". 
01:10:17 <haskeldjiq> merijn: joining between stores is kind of clumsy atm syntax wise
01:10:40 <haskeldjiq> merijn: so I'm hoping to get all of the needed projection types in one instance
01:10:46 <haskeldjiq> merijn: not sure if that made any sense
01:11:08 <merijn> haskeldjiq: Generally I think lots of people are too eager in defining typeclasses for things. The only "custom" classes I generally end up declaring is "tagless final" style classes (i.e. so I can implement some operations for 2 different monads and reuse them)
01:11:46 <haskeldjiq> merijn: yes, we have the case of needing to implement the same store for different monads
01:11:54 <jusss> merijn: kuribas ok, so (+2) could be a continuation, but it's not a continuation-passing style function?
01:12:00 <merijn> haskeldjiq: But do you need a typeclass for that? I obviously don't know how exactly your query results/joins look atm, but I'd try and see if you can just generalise
01:12:03 <maralorn> Axman6: That classyLense solution is awesome for my situation. Thanks!
01:12:11 <maralorn> Axman6++
01:12:18 <haskeldjiq> merijn: we have another typeclass called CanJoin
01:12:27 <jusss> do we have the term continuation-passing style function?
01:12:28 <haskeldjiq> merijn: we use the Store typeclasses to provide a default implementation for the join functions
01:12:37 <jusss> or just continuation-passing style will be fine?
01:12:40 <haskeldjiq> merijn: so you get the CanJoin instances for free
01:12:42 <merijn> jusss: A function in CPS is just "a function that takes a continuation (i.e. another function) and calls that continuation on it result" and code in CPS just is an endless sequence of those
01:12:49 <jusss> those terms , ....
01:13:47 <kuribas> jusss: no, because then it would also take a continuation
01:13:58 <haskeldjiq> merijn: each service that has a connection to the central event store implements the Store typeclass depending on what projections it needs
01:14:04 <merijn> haskeldjiq: Right, but then you can only have one type of store per monad, right? And I assume the point is that you'd like to use multiple different stores within the same monad?
01:14:22 <maralorn> The lambdabot help is very confusing: How can I get a list of all commands?
01:14:25 <kuribas> jusss: like \v k -> k (v+2)
01:14:31 <haskeldjiq> merijn: you can have one type of store per monad for a particular projection
01:14:37 <maralorn> @help says try list, but I don‘t get it.
01:14:37 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:14:50 <haskeldjiq> merijn: but you can have many stores for the same monad if they are for different projections
01:14:59 <boxscape> maralorn I don't think that's possible. You can only get a list of modules and a list of commands within a module.
01:15:28 <haskeldjiq> merijn: I was hoping that there could be some magic that would allow us to say "instance Store '[Entity1, Entity2, Entity3] SomeM"
01:15:29 <boxscape> @list where
01:15:30 <lambdabot> where provides: where url what where+
01:15:41 <haskeldjiq> merijn: and we can automatically get the joins between those and all that
01:15:42 <maralorn> boxscape: Okay
01:17:54 <jusss> kuribas: this k is continuation?
01:18:15 <jusss> f = \v k -> k (v+2)       this f is continuation?
01:18:44 <merijn> haskeldjiq: Have you considered doing what I like to call OO Haskell? Which basically means instead of having a typeclass you have a record whose fields correspond to the typeclass operations. So handwavily "data Store a { querySingle :: IO a; queryMany :: IO [a] }" (or some other monad) then you can do something like "newFooStore :: Config -> IO (Store Foo); newFooStore config = do { cfgMvar <- newMVar 
01:18:50 <merijn> config; return State{ querySingle = foo configMVar, queryMany = bar configMVar } }"
01:19:47 <haskeldjiq> merijn: but can you somehow make the store be able to hold multiple types of `a`
01:20:49 <merijn> haskeldjiq: If you change it to "data Store = Store { querySingle :: forall a . Queryable a => m a }" then you can
01:21:12 <haskeldjiq> merijn: think I got it
01:21:14 <haskeldjiq> merijn: thanks!
01:21:21 <haskeldjiq> merijn: I'll experiment a bit
01:22:25 <maralorn> Oh, noes. Is there a "withReaderT" equivalent that can convert a (MonadReader a m) to a (MonadReadr b m)? 
01:22:30 <merijn> haskeldjiq: The basic trick is to share state via MVar/IORef/etc. hide the fact that you're doing that by storing all the shared methods in a single record and then using that. Which matches very well to the OO design approach of having a (virtual) interface that you can overload, because you can create as many unique instantiations
01:22:55 <merijn> maralorn: Nope, because the FunDeps fixes 'm' to a specific 'a'
01:23:07 <merijn> maralorn: You can use mmorph to drill down your stack and use withReaderT
01:23:22 <maralorn> mmorph?
01:23:34 <haskeldjiq> merijn: thank you for thinking along! I'll try this approach now
01:23:57 <merijn> @hackage mmorph
01:23:57 <lambdabot> http://hackage.haskell.org/package/mmorph
01:25:17 <merijn> haskeldjiq: How well it fits your problem depends on the details of your problem, but it would allow you to, for example, use multiple stores that refer to the same entity type which you can't now
01:28:50 <merijn> Someone (i.e., not me >.<) should really write a nice example/tutorial on that design pattern... >.>
01:29:53 <maralorn> merijn: Do I understand correctly that I don‘t need mmorph if I know that the ReaderT is the outermost transformer?
01:31:09 * hackage hasql-th 0.3 - Template Haskell utilities for Hasql  https://hackage.haskell.org/package/hasql-th-0.3 (NikitaVolkov)
01:32:57 <merijn> maralorn: Sure
01:33:40 <merijn> maralorn: The reason why MonadReader can't do this is because it just says "there is something reader like somewhere in this monad" (it doesn't even have to be ReaderT, you can implement your own instances) so there's no obvious way to make it work
01:33:55 <maralorn> Yeah, I understand.
01:34:05 <merijn> If you know that 1) you have ReaderT and 2) where in your stack it is, then you can use either mmorph to drill down or just use withReaderT directly
01:34:48 <maralorn> But of course that way I loose a lot of flexibility in my type signatures …
01:36:16 <maralorn> … that moment where you have implemented all your functions for the cool shiny typeclass you defined and now realize that you can‘t provide an instance for that typeclass …
01:37:12 <merijn> maralorn: tbh, I mostly find the 'mtl' classes a misfeature
01:37:30 <maralorn> It looks like at this point using polysemy would have been easier …
01:37:36 <merijn> I prefer either a specific monad stack or just defining a custom monad entirely
01:37:38 <kuribas> jusss: yes
01:37:59 <maralorn> merijn: So how would you work with them?
01:38:01 <merijn> And then defining primitive operations as a typeclass imlemented by your monad
01:38:14 <merijn> maralorn: Well, why do you need to expose the reader/state/etc.?
01:39:17 <maralorn> Hm, okay.
01:39:50 <maralorn> merijn: What do you mean with expose?
01:39:50 <maerwald> how do you handle async exceptions (e.g. signals) in shake?
01:40:19 <jusss>  kuribas: both are continuations?
01:40:59 <merijn> maralorn: Like, why do other functions need "MonadReader"? You could also define "newtype FooM a = .." and then, for example "getConfig :: FooM Config" instead of having "MonadReader config m" everywhere
01:41:13 <kuribas> jusss: <merijn> jusss: any function can be a continuation
01:41:52 <maerwald> actionFinally :: Action a -> IO b -> Action a -- not clear to me if this catches async ones
01:41:53 <merijn> maerwald: "carefully" ;)
01:42:21 <merijn> maerwald: finally in Control.Exception doesn't catch, just guarantee that a cleanup runs
01:42:30 <merijn> maerwald: So I would expect it to not catch *anything*
01:43:28 <maralorn> merijn: But then I can only work with the FooM Monad?
01:43:30 <maerwald> because if you run docker jobs in your shake and jenkins kills the shake process, nothing really stops
01:45:00 <merijn> maralorn: 1) that's usually not a problem and 2) if you really do need to sometimes use it inside other stacks you can define a small number of primitive Foo operations and define a typeclass for those
01:46:39 <merijn> maralorn: For example, I have a newtype for my application that handles configuration, database connections, etc. but sometimes I need to run queries inside a conduit so I just have a MonadSql class that defines the primitives I need for querying and then my query functions are all "MonadSql m => ..." letting me use them in conduit where needed
01:47:56 <maralorn> Okay. So I basically want a newtype around ReaderT?
01:49:32 <merijn> maralorn: For example. The advantage is that now you can also more easily refactor/restructure the internals of your monad stack if/when you need to, as long as you can support the same API for the typeclass everything will keep working
01:51:11 <tdammers> maerwald: you mean NL-FP day? not sure, I might
01:51:51 <maralorn> merijn: It sounds plausible. But I have still problems with that would actually look like. Do you maybe know of a small example I can look at?
01:54:36 <merijn> maralorn: Only huge ones ;)
01:54:38 <merijn> maralorn: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/src/Core.hs#L130-L150
01:55:16 <merijn> tdammers: pfft! I'm not hassling everyone into coming for nothing!
01:55:52 <maerwald> tdammers: yeah
01:57:06 <tdammers> merijn: it's a friday, which means it's my turn to pick up the kids from school, which means that I can only come if I can solve those particular logistics
01:57:11 <tdammers> merijn: it's an NP-hard problem
01:57:52 <MarcelineVQ> P=NP if it's wednesday at least
01:58:02 <merijn> tdammers: Pfft, it'll be an exercise in zelfredzaamheid ;)
01:58:26 <maralorn> merijn: That helps anyways.
02:00:09 <tdammers> MarcelineVQ: you reckon there's a paper in it?
02:00:51 <MarcelineVQ> if the kids haven't run off with it
02:02:21 <maralorn> merijn: I still feel like this would be more fun if I had used polysemy from the start …
02:07:01 <merijn> tbh, polysemy looks neat, but it *also* looks like a lot of the type-level traps in Haskell
02:07:29 <merijn> Where all the enthusiastic people try to do everything on the type level and all the cool stuff, and you end up in a tarpit of fighting the type checker instead of getting anything done
02:08:39 * hackage hasql-th 0.3.0.1 - Template Haskell utilities for Hasql  https://hackage.haskell.org/package/hasql-th-0.3.0.1 (NikitaVolkov)
02:08:43 <merijn> I see so many people join here, get really enthusiastic, get carried away with all sorts of type level death machinery and then come in with "how do I make this thing *pastes 300 lines of DataKinds+TypeFamilies+UndecidableInstances+KitchenSink source* work?"
02:08:51 <maralorn> Well I feel like I am already hear.^^
02:09:11 <merijn> And then you're just "well, I would've just checked this invariant and runtime and gotten on with my life"
02:09:11 <maralorn> *there
02:09:32 <Solonarv_> oof, merijn - right in the heart
02:09:35 <merijn> I think GHC extensions are like spices
02:09:41 <Solonarv_> I still haven't quite found the right balance tbh
02:09:48 <merijn> A little goes along way
02:10:03 <merijn> And always throwing everything in is usually not the best approach
02:10:51 <merijn> Of course, I say this having 12 lines of extensions in that file I linked >.>
02:10:55 <maerwald> merijn: mh, but with effects system I think the way kinda is "all or nothing"
02:10:58 <merijn> So maybe I'm just talking out my ass ;)
02:11:15 <Solonarv_> although if we are talking about syntax extensions (e.g. BlockArguments, LambdaCase) IMO it's fine to just turn those on all the time
02:11:45 <merijn> Solonarv_: I still try to be a bit conservative wrt to those
02:11:58 <maralorn> merijn: That‘s the problem. I think most extensions are pretty harmless. So it’s always tough to tell, when exactly it’s too much.
02:12:53 <merijn> maralorn: You should always be suspicious when you start trying to do something dependently typed with extensions
02:13:16 <Solonarv_> I don't have to be compatible with any older GHCs and really like how much those two extensions specifically reduce visual noise, but others' opinions may vary of course
02:13:19 <merijn> Dependent types in Haskell are just not ergonomic and a solid way to get yourself into lots of pain
02:13:47 <boxscape> I enjoy the pain
02:14:23 <boxscape> (Luckily I don't have to actually get anything done in Haskell)
02:14:23 <Solonarv_> usually when I reach for them it is because I convinced myself it would be less painful than the alternative
02:14:25 <merijn> boxscape: Don't get me wrong, I like playing with these things and write short hacky things to see if I can make something ridiculous work
02:14:33 <Solonarv_> ...sometimes I'm even correct abouut that ;)
02:14:52 <merijn> boxscape: But you need to decide whether you're 1) fucking around for fun/hack value, or 2) trying to get something done
02:14:58 <boxscape> yeah
02:15:46 <Solonarv_> for example I'm doing advent of code, and today's task involves six-digit numbers and properties about their digits
02:15:48 <merijn> And I feel a lot of beginners take blogs that are "look at this cool trick I hacked up" and read "you should do this in real code"
02:16:30 <Solonarv_> my first approach defined a `data Thing a = Thing a a a a a a deriving EverythingYouCanDerive` and working with `Thing (Finite 10)`
02:16:43 <kuribas> merijn: yeah, right on point.
02:16:57 <Solonarv_> it didn't work, of course, and was really annoying to actually get things done with
02:17:22 <Solonarv_> then I switched to horrible `Int` and `[Int]` for the digits and it was a breeze from there
02:19:04 <kuribas> merijn: I haven't quite understood the hate for monad stacks.
02:19:21 <kuribas> or dislike at least
02:20:27 <merijn> kuribas: Hold on, I never complained about monad stacks :)
02:20:46 <maerwald> merijn: wrt the type level confusion... do you think that will get better or worse with dependent haskell ;) 
02:20:54 <kuribas> merijn: I mean the need for polysemi etc...
02:21:10 <merijn> *Specific* transformer stacks are great, application specific DSL style classes are fine, it's mtl style "stack polymorphism" which sucks
02:21:29 <kuribas> maerwald: IMO in idris type checking is worse, but doing type level stuff is easier.
02:21:40 <kuribas> maerwald: I don't know how it will be in haskell though
02:21:44 <merijn> kuribas: Well, polysemy style things is for people who think the problem with "stack polymorphism" is the mtl implementation, as opposed the entire idea just being flawed :p
02:21:56 <merijn> maerwald: worse, definitely worse
02:22:00 <merijn> TypeInType is an atrocity
02:22:31 <kuribas> merijn: it's flawed, but I can live with it.
02:23:03 <maerwald> merijn: you don't like mtl style stuff?
02:23:16 <kuribas> merijn: the polymorphism is nice to have
02:23:33 <merijn> I'd be in favour of having a redesigned "Haskell++" with dependent types designed in, but people are to invested in GHC's implementation for that to ever happen
02:23:47 <merijn> maerwald: No, never have
02:24:05 <kuribas> merijn: you never use ask, get, etc... ?
02:24:12 <maerwald> Weird, I always felt the other way around.. I dislike transformers and mtl is a little better (API-wise)
02:24:30 <kuribas> the boilerplate is minimal with generalisednewtypederiving
02:25:14 <maerwald> mtl is more declarative and doesn't require constant lifting
02:25:51 <kuribas> except IO
02:26:00 <merijn> maerwald: Sure, explicit lifting sucks, which is why you should immediately wrap your transformers into an application specific monad :p
02:26:35 <maerwald> I don't like application monads, it's like the god object in OOP
02:26:47 <EvanR> i always saw transformers as a possible way to implement an app monad or local monad, not to be used directly
02:26:59 <maerwald> I want the smallest necessary effect surface, at all times
02:27:08 <EvanR> yes IO as a god object is much better :)
02:27:26 <maerwald> at least IO isn't lying
02:27:35 <EvanR> it is the iota, and the omega
02:27:38 <maerwald> and the API is crystal clear
02:27:56 <kuribas> maerwald: you don't need to put everything in the application monad
02:28:22 <maerwald> I feel someone needs to write a blog post about this for a proper discussion
02:28:24 <merijn> maerwald: I'm not advocating for "everything should be in that monad"
02:29:45 <merijn> maerwald: But, for example, my entire codebase is just either 1) stuffing stuff into a database or 2) querying said database, so my application monad at the bottom is all the necessary global config to handle database access, logging configuration, input/UI handling
02:30:31 <merijn> maerwald: Any error handling via MaybeT/ExceptT is wrapped around that where needed. In general MaybeT/ExceptT should always be the outermost thing, imo
02:30:32 <maerwald> what about a function that *just* queries the database, but doesn't do anything else, does it run in the application monad?
02:31:13 <merijn> maerwald: A function that queries the database still needs access to the database info and logging config
02:31:42 <maerwald> so you can't tell from a function signature whether there are just database reads or database writes or both?
02:31:45 <merijn> maerwald: So only the UI/input bit is redundant for that code, but so far factoring that out is too much hassle
02:32:13 <merijn> maerwald: No, because 90% do both
02:32:15 <tdammers> related to all this: custom monads / monad stacks go two ways - adding functionality by stacking additional stuff on top, and constraining functionality by wrapping things and consuming by typeclass
02:32:42 <merijn> maerwald: And for my application distinguishing the two is irrelevant
02:33:05 <tdammers> DatabaseMonad m => Username -> m (Maybe User) -- means "I'm going to touch the database, but there won't be any other effects"
02:33:10 <merijn> maerwald: I don't have any real reason to care which are read only
02:34:21 <maerwald> merijn: I see, I generally want this distinction on type level
02:34:41 <merijn> maerwald: That wouldn't be to hard to accomplish with an application monad, though
02:34:54 <merijn> maerwald: Just parameterise with a "Read | Write" phantom type
02:35:17 <merijn> Or something along those lines
02:40:28 <EvanR> ReadOnly | ReadWrite ?
02:42:04 <nn> Hello all - I am new to Haskell (sorry!) - Why, if partial functions should be avoided, are some functions in the standard library, for example 'head', defined in such a way?
02:42:56 <merijn> nn: Many people consider that a historic mistake
02:43:15 <nil> who says they should be avoided?
02:43:18 <merijn> nn: The other point of view is that sometimes you know better than the compiler
02:43:25 <merijn> nil: Basically everyone :p
02:43:40 <EvanR> it's part historical raisins, it's also that sometimes it is sound to use
02:43:40 <merijn> :t groupBy
02:43:42 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
02:44:06 <boxscape> the types of group and groupBy are also historical mistakes
02:44:07 <nil> head is perfectly safe to use on infinite lists, for example
02:44:20 <EvanR> and a well typed replacement has a terrible power to weight ratio (in haskell)
02:44:24 <merijn> nn: For example, groupBy never produces empty lists, so "map head . groupBy f" is perfectly fine/safe, you could achieve the same thing via a safeHead function, but it'd be rather annoying
02:44:31 <boxscape> nil then why not have a type Stream a = Cons a (Stream a) that guarantees you have an infinite list
02:44:42 <boxscape> nil and define head to use that
02:45:02 <nil> i guess it depends on how much type safety you want
02:45:04 <EvanR> head for Stream is completely fine but not on topic
02:45:12 <nn> OK - so in some cases/functions, it makes sense. But is it non-trivial to reimplement functions like 'head', or are there some other reasons for keeping them as partial functions?
02:45:43 <EvanR> it's non trivial to make head well typed for something like a list that may be empty
02:45:57 <merijn> nn: You can't implement a safe head with the same type
02:45:59 <EvanR> (returning Maybe only delays the inevitable)
02:46:05 <merijn> nn: All safe versions have a different type
02:46:12 <infinity0> what's the best way to have a map-like data structure where the key and value both contain a hidden existential type param and i want them to match up
02:46:24 <merijn> nn: So it's not about complexity, you can't fix it without breaking it's only usecase
02:46:25 <boxscape> it would be a breaking change to make them total at this point. There are some custom Preludes which provide a typesafe head though.
02:46:31 <Solonarv_> infinity0: sounds like dependent-map?
02:46:32 <EvanR> infinity0: dependent map ?
02:46:34 <nn> so is it not desirable to have `head` have the type :: [a] -> Maybe a ?
02:46:44 <merijn> nn: "It Depends (TM)"
02:46:50 <EvanR> :t listToMaybe
02:46:52 <lambdabot> [a] -> Maybe a
02:46:54 <Solonarv_> no, because then every piece of code anywhere that uses `head` breaks
02:46:58 <merijn> nn: For example, my example of "map head . groupBy f" would no longer work
02:47:04 * Solonarv_ doesn't like the `listToMaybe` name
02:47:06 <infinity0> ah ok, that's the "standard way"? i couldn't get my head around the API yesterday
02:47:07 <EvanR> heh
02:47:09 <boxscape> nn btw some prefer head :: NonEmpty a -> a
02:47:15 <merijn> Solonarv_: It's a bit long, yeah
02:47:40 <Solonarv_> for my advent of code stuff I defined safeHead :: [a] -> Maybe a
02:47:43 <Solonarv_> purely because of the better name
02:47:57 <Solonarv_> ...and because I can never remember which module listToMaybe actually lives in :P
02:48:03 <boxscape> % :t Data.List.NonEmpty.group
02:48:03 <yahb> boxscape: (Foldable f, Eq a) => f a -> [GHC.Base.NonEmpty a]
02:48:11 <EvanR> safeFromJust :: Maybe a -> Maybe a
02:48:15 <boxscape> huh I didn't actually know that existed before now. I like it.
02:48:46 <EvanR> nn: when you know a list is not empty, then [a] -> Maybe a is pretty wrong
02:49:23 <infinity0> "More informally, DMap is to dependent products as Map is to (->)." -- why not "Map is to (,)"
02:49:24 <EvanR> when you know a list is not empty, head :: [a] -> a is pretty brittle
02:49:26 <EvanR> but not wrong
02:50:02 <EvanR> it's brittle because the knowledge of being not empty isn't in the types
02:50:09 <EvanR> and knowledge changes
02:51:03 <Solonarv_> infinity0: hmm, probably needs fixing
02:51:04 <EvanR> infinity0: dependent product probably means dependent function here
02:51:17 <EvanR> they should just say dependent function
02:51:27 <infinity0> ah ok
02:51:44 <infinity0> yes function makes more sense than product
02:52:09 <EvanR> Pi type stands for 'product'... but... anyway
02:52:26 <infinity0> perhaps the previous sentences about DSum confused the author or something, since that would be about products
02:52:39 * hackage safe 0.3.18 - Library of safe (exception free) functions  https://hackage.haskell.org/package/safe-0.3.18 (NeilMitchell)
02:52:45 <EvanR> and sigma stands for sum
02:53:08 <EvanR> pi and sigma are unambiguous, but somehow product is ambiguous
02:53:09 <Solonarv_> "dependent product" is used with two different meanings, unfortunately
02:53:35 <nn> Evan - what it wrong with 'head' returning Just a? Assuming all our code expects this (i.e. standard library was always written this way)...
02:53:52 <EvanR> nn: how can all your code expect "always Just"
02:54:05 <EvanR> Maybe encodes literally "maybe Just"
02:54:10 <EvanR> "maybe not"
02:54:41 <Solonarv_> it can mean (t :: k, x :: F t) which is sigma; or it can mean (x1 :: F t1, x2 :: F t2, ...) where t1, t2, ... are all the possible t :: k
02:54:59 <Solonarv_> (the latter is pi)
02:55:10 <Solonarv_> I wrote both meanings as tuples to hopefully make it clear why they are both called "product"
02:55:21 <merijn> nn: What's wrong is "it breaks a substantial amount of code that exists which will all have to be fixed"
02:55:32 <infinity0> "data DSum tag f" -- can i just make tag = Sing because i don't really have a separate "tag" kind
02:55:33 <merijn> nn: So the cost of changing things is higher than the benefit
02:55:42 <nn> Hmmm - i see i need to revisit Maybe. Like I said, I'm a newbie. I thought Maybe a, would return Nothing (empty list) or Just a (non-empty list). Sorry if these are confused questions.
02:55:50 <EvanR> that and it's just wrong to wrap Just around something and have no code path to deal with Nothings
02:56:22 <Solonarv_> infinity0: yes you can
02:56:23 <merijn> nn: Sure, but now the code calling head has to handle "what to do if this is Nothing?"
02:56:27 <EvanR> nn: note i prefixed that wrongness with "you *know* the list can't be empty"
02:56:37 <infinity0> ah ok great
02:56:40 <Solonarv_> infinity0: or you can make your own GADT that only allows the options that make sense
02:56:53 <EvanR> i.e. no Nothings
02:58:04 <nn> marijn - OK. I understand that would (now) require a lot of work. But in theory, if I understand correctly, if existeing code was not a problem, could `head` (for exampe) use the Maybe type? Or simply be non-partial (again, without worrying about breaking existing code bases)
02:58:19 <Solonarv_> yes, it could
02:58:45 <Solonarv_> there are some quibbles about exactly what form it should take
02:58:48 <EvanR> we have safeHead and headMay and listToMaybe that all do that
02:59:00 <Solonarv_> [a] -> Maybe a is one option, NonEmpty a -> a another
02:59:12 <EvanR> but when you have a definitely-not-empty-list, Maybe is just wrong
02:59:25 <Solonarv_> an even more convoluted option is some fancy list type that tracks at the type level how many elements it has (at least)
02:59:32 <EvanR> it's basically adding false information to the type
02:59:35 <Solonarv_> which requires a lot of type wizardry
02:59:50 <Solonarv_> but would allow you to safely write e.g. head (drop xs)  if xs is known to have at least 2 elements
03:01:13 <nn> I see I still have a lot to learn then.
03:01:26 <EvanR> nn: imagine using a Maybe-returning head on a list you know is not empty. Then you pattern match on this maybe to do the next step on your task. This requires you to handle an impossible Nothing. Sometimes the programmer will put "error" here and crash. So we accomplished nothing
03:02:07 <EvanR> partiality still lurking
03:02:56 <EvanR> NonEmpty can often solve the issue
03:03:15 <EvanR> sometimes not even NonEmpty will work
03:03:28 <bahamas> how come the Bounded class doesn't have a minimal complete definition? does that mean that types can implement any of the two methods?
03:03:32 <EvanR> like the "has at least 2" list 
03:04:00 <Solonarv_> bahamas: I'd guess haddock only lists a minimal complete definition if it's something other than "define every method"
03:04:18 <bahamas> Solonarv_: oh, so both are required
03:04:37 <EvanR> isn't minimal complete part of the doc comments
03:04:47 <EvanR> manually entered by the author
03:04:50 <Solonarv_> no, it's actually a GHC pragma
03:04:56 <EvanR> ah
03:05:15 <Solonarv_> {-# MINIMAL pure, (liftA2 | (<*>) ) #-} is the one for Applicative for example
03:05:36 <Solonarv_> this is so GHC can warn you when you don't provide a complete definition
03:05:38 <EvanR> yeah so Bounded just doesn't have that
03:05:56 <Solonarv_> yes, because the default {-# MINIMAL #-} is just "every method"
03:06:12 <Solonarv_> or possibly "every method that doesn't have a default definition"
03:07:36 <phadej> the latter
03:08:01 <bahamas> Solonarv_: Enum doesn't have that pragma, but the docs still show it http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Enum.html#Enum
03:08:01 <phadej> {-# MINIMAL #-} was introduced so GHC wouldn't need to try to infer through cycles, what's the actual minimal definition needed
03:08:32 <infinity0> 'Could not deduce (DM.GCompare Sing)'
03:08:34 <phadej> bahamas: i.e. lists all methods without default definition
03:08:49 <infinity0> error remains even after i add a DM.GCompare Sing =>, what's the best way to fix this?
03:08:53 <phadej> MINIMAL is needed when you can pick one of two, and other one is defined in terms of the other
03:09:01 <phadej> like foldMap or foldr in Foldable
03:09:09 * hackage ghcid 0.8 - GHCi based bare bones IDE  https://hackage.haskell.org/package/ghcid-0.8 (NeilMitchell)
03:09:30 <Solonarv_> infinity0: hmm, you might have to make your own GADT then..
03:09:40 <infinity0> aw, sad :(
03:09:55 <Solonarv_> perhaps there is some generic Typeable-based thing
03:10:31 <bahamas> phadej: sorry, I don't understand. on haddock, Enum's docs say Minimal complete definition
03:10:34 <bahamas> toEnum, fromEnum
03:11:06 <phadej> bahamas: yes, an all other methods have deafult definitions, e.g. succ                   = toEnum . (+ 1)  . fromEnum
03:11:10 <phadej> they are at the bottom of the class
03:11:26 <phadej> you know, you can have definition quite far from type-signature :)
03:11:31 <Solonarv_> infinity0: ah yes, you can use TypeRep
03:11:52 <Solonarv_> (the newer one, from Type.Reflection)
03:12:12 <infinity0> ah awesome thanks i'll take a look
03:12:20 <M0b10s> good morning everyone! anyone knows a good place to start learning about monads?
03:12:35 <EvanR> have you tried reading some monad tutorials
03:12:39 * EvanR hides
03:12:53 <Solonarv_> @slap EvanR
03:12:53 * lambdabot jabs EvanR with a C pointer
03:13:32 <EvanR> you can't deny that is where we all began learning about them
03:13:41 <EvanR> for better or worse
03:14:21 <Solonarv_> true
03:14:22 <bahamas> phadej: but I don't see minBound and maxBound's default definitions
03:14:39 <Rembane> M0b10s: Let's try this one: http://dev.stephendiehl.com/hask/#eightfold-path-to-monad-satori
03:14:41 <M0b10s> EvanR, i'm about to do it now ofc... (https://wiki.haskell.org/All_About_Monads) i was just asking because i had my 1st class about them today, and maybe u guys had a good place to start on...
03:14:51 <phadej> bahamas: they aren't in Enum?
03:15:11 <bahamas> phadej: I'm looking here http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Enum.html#Bounded
03:15:15 <EvanR> really, minBound and maxBound have defaults?
03:15:27 <Solonarv_> they do not
03:15:29 <M0b10s> Rembane, ty u! 
03:15:35 <EvanR> would be surprising
03:15:52 * Solonarv_ . o O ( "thank you you" ?)
03:15:59 <phadej> bahamas: bounded haddocks don't say minimal pragma, probably because "everything is required" is omitted by default
03:16:02 <phadej> as it's common
03:16:56 <bahamas> phadej: ok, now I understand. if a class doesn't use a MINIMAL pragma, it means all methods are required. if it does use an empty MINIMAL pragma, it considers all methods without a default as required
03:17:31 <phadej> "if it does use an empty MINIMAL pragma" <- that's nonsense
03:18:45 <infinity0> Solonarv_: nice, it worked thanks https://repl.it/repls/LawfulLongReference
03:18:47 <bahamas> phadej: that's what I assume Solonarv_ said with this comment: "Solonarv_> yes, because the default {-# MINIMAL #-} is just "every method"
03:19:19 <phadej> {-# MINIMAL #-} there means "MINIMAL pragma", not literal syntax
03:19:25 <EvanR> i took that to mean, the default (no pragma) is equivalent to putting {-# MINIMAL #-}
03:19:25 <M0b10s> sry about the side talk but "... I suggest a path to enlightenment:1-Don't read the monad tutorials.2-No really, don't read the monad tutorials..." i'm rofl x)
03:19:36 <phadej> {-# MINIMAL #-} literally would probably be rejected
03:19:44 <phadej> try out these things!
03:19:58 <EvanR> M0b10s: you've already learned some important things about monads!
03:20:10 <Solonarv_> I was being sloppy and wrote `{-# MINIMAL #-}`, rather than being explicit and saying: the default minimal complete definition is "every method (that doesn't have a default definition)"
03:20:36 <bahamas> Solonarv_: ok. now I understand
03:20:50 <M0b10s> EvanR, it's a good thing that before we had monads, we were seeing about data types in deep
03:20:52 <Solonarv_> infinity0: M, MM, MMM
03:20:55 <Solonarv_> very tasty! ;)
03:21:02 <infinity0> hehe
03:21:18 <bahamas> phadej: I have the feeling I annoyed you with my comments. sorry about that!
03:22:00 <Solonarv_> infinity0: if you have a GCompare k instance then you can collapse MMM k v to just DMap k v
03:22:22 <EvanR> M0b10s: good because learning about data types is often skipped by people trying to learn monads and nothing else about haskell
03:22:51 <Solonarv_> monads are data types with some particular operations defined on them
03:22:58 <phadej> bahamas: not at all, but you should try these things, writing a small .hs file and loading it into GHCi is more precise :)
03:23:04 <Solonarv_> so it is very hard to learn about them without learning about data types!
03:23:06 <phadej> % :i Bounded
03:23:07 <yahb> phadej: class Bounded a where; minBound :: a; maxBound :: a; {-# MINIMAL minBound, maxBound #-}; -- Defined in `GHC.Enum'; instance Bounded GeneralCategory -- Defined in `GHC.Unicode'; instance Bounded Int8 -- Defined in `GHC.Int'; instance Bounded Int64 -- Defined in `GHC.Int'; instance Bounded Int32 -- Defined in `GHC.Int'; instance Bounded Int16 -- Defined in `GHC.Int'; instance Bounded Word -- Defined 
03:23:19 <phadej> GHCi for example prints inferred MINIMAL
03:23:25 <phadej> haddock choses differently
03:23:35 <infinity0> Solonarv_: ah right yes, thanks i'll look into that
03:23:45 <phadej> *inferred (all mehtods required) MINIMAL
03:24:11 <phadej> % :i Enum
03:24:12 <yahb> phadej: class Enum a where; succ :: a -> a; pred :: a -> a; toEnum :: Int -> a; fromEnum :: a -> Int; enumFrom :: a -> [a]; enumFromThen :: a -> a -> [a]; enumFromTo :: a -> a -> [a]; enumFromThenTo :: a -> a -> a -> [a]; {-# MINIMAL toEnum, fromEnum #-}; -- Defined in `GHC.Enum'; instance Enum a => Enum (Q.Small a) -- Defined in `Test.QuickCheck.Modifiers'; instance Enum a => Enum (Q.Shrink2 a) 
03:24:25 <bahamas> phadej: ok, good to know. I didn't notice that ghci does that
03:24:28 <Solonarv_> infinity0: GCompare instances aren't too hard to write, so this should be no trouble assuming you control whatever choice(s) of `k` actually end up being used
03:24:39 * hackage intro 0.6.0.1 - Safe and minimal prelude  https://hackage.haskell.org/package/intro-0.6.0.1 (minad)
03:24:48 <Solonarv_> they're basically the same as Ord instances, with some extra type juggling
03:24:58 <phadej> bahamas: :i does a lot of things, it's a good too for exploration
03:25:02 <phadej> good tool*
03:25:17 <phadej> among, :browse Some.Module
03:25:24 <infinity0> the thing i'm writing is a generic util that should allow the user to supply k, but i'll see how hard it is to write GCompare and whether i want the user to have that burden
03:25:27 <phadej> makes you a bit more independent of Hackage docs :)
03:26:55 <M0b10s> Solonarv_, you were talking about (io exp): return :: a -> IO a and (>>=) :: IO a -> (a -> IO b) -> IO b? those 2?
03:27:05 <Solonarv_> yep!
03:28:07 <libertyprime> Hey guys. I was wondering why the 2nd example here lags so much: https://lotz84.github.io/haskellbyexample/ex/spawning-processes
03:29:24 <Solonarv_> there are other sets of operations you can use for the definition: for example, you can use (return :: a -> IO a, fmap :: (a -> b) -> IO a -> IO b, join :: IO (IO a) -> IO a) or (return :: a -> IO a, (>=>) :: (a -> IO b) -> (b -> IO c) -> a -> IO c)
03:29:29 <Solonarv_> these are equivalent
03:29:53 <Solonarv_> but for the Monad class as defined in Haskel, you usually give (return, >>=)
04:12:09 * hackage haskoin-core 0.9.7 - Bitcoin & Bitcoin Cash library for Haskell  https://hackage.haskell.org/package/haskoin-core-0.9.7 (xenog)
04:56:54 <svipal> Hey all. I s there a less cumbersome way to read integers with a base than readInt from Numeric ?
04:59:35 <tdammers> what would that look like?
05:07:27 <davean> not take two functions that do the same thing?
05:08:39 <svipal> ^
05:08:41 <svipal> I
05:09:10 <svipal> 'm making a custom way to do it, but probably someone already did
05:09:28 <davean> yah I tihnk readInt is one of the worst functions in base
05:09:54 <boxscape> bold claim
05:09:58 <boxscape> oh wait
05:09:59 <int-e> davean: They're not doing the same thing though. You can pass 'digitToInt' even when parsing binary numbers.
05:10:06 <boxscape> I thought you wrote *the worst*
05:10:15 <boxscape> (instead of "one of")
05:11:02 <davean> int-e: sure, and in that case isValidDigit is just "const true", but that is the same thing
05:11:03 <svipal> they're not doing the same thing, but they have a lot of overlap and using it feels -mega- clunky, not to mention having to get the result from a ReadS
05:11:22 <tdammers> oh wait, readInt is the one that gives you a ReadS
05:11:27 <davean> tdammers: yes, yes it is
05:11:59 <davean> int-e: isValidDigit is just the edge case handler of digitToInt
05:12:05 <int-e> > readInt 2 (`elem` "01") digitToInt "10123"
05:12:07 <lambdabot>  [(5,"23")]
05:12:22 <dolio> For binary the valid digits are 0 and 1, not any character.
05:12:27 <jpcooper> Hello. Is there some sort of functor which takes instances of MonadPlus to a Monad such that binding is mplus?
05:13:09 <davean> dolio: I'd have called that base-2
05:13:39 <jpcooper> I want to write a do-block and have each line "mplussed"
05:18:42 <davean> jpcooper: does that make sense as a doblock? Thats a list thats folded with mplus right?
05:22:29 <jpcooper> davean: I'm still not sure, really. I'm trying to develop a DSL which generates sentences in a language of choice based on constant terms, providing alternatives and then appending all the alternatives. I have a sort of grammar for this, but now I'm trying to figure out how to realised this in Haskell. It would be nice to put each of these instances on separate lines in a do-block and have them appended
05:23:37 <jpcooper> Think of "hello" ++ one_of("davean", "jpcooper") ++ "."
05:24:21 <davean> right, so you'd need to distinguish between do blocks that do options and ones that concatinate, yes?
05:24:25 <jpcooper> This won't work over Strings alone. I'm thinking it might be nice if this works over Monads as well, so I can generate command strings, and then use each generated command string to generate a shake rule
05:25:01 <jpcooper> Send "hello" ++ one_of("davean", "jpcooper") ++ "." to some analogue of `do "hello"; one_of(...); "."`
05:25:15 <arianvp2> im using hspec-discover in hspec, but  `stack test --coverage` gives no coverage whatsoever
05:25:23 <arianvp2> is coverage simply broken when using `hspec-discover` ?
05:25:58 <davean> jpcooper: right, so you'll notice "one_of" is different there
05:26:23 <jpcooper> "hello" might exist in some suitable container, like a Const constructor of the GADT of the language
05:26:24 <davean> thats a choice operator not a do block persay
05:26:39 <jpcooper> the one_of would possibly occur on a single line of a do-block
05:26:42 <davean> jpcooper: you should look at the opposite case - parsing.
05:26:50 <davean> jpcooper: theres good examples in like megaparsec and such
05:27:04 <jpcooper> Exactly. I'm trying to build a sort of dual to that
05:27:09 * hackage ghc-lib-parser 8.8.1.20191204 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-8.8.1.20191204 (cocreature)
05:27:22 <davean> jpcooper: right so choice is an operator that takes a list not a do block
05:27:23 <arianvp2> e.g. I get this error: https://github.com/wireapp/hscim/issues/34
05:27:39 <jpcooper> I might look at the parsing libraries a bit more. The question is how to maintain this state of building a sentence in the chosen language
05:27:42 <davean> jpcooper: the code for both sides is basicly identical - infact you could run parser code in "reverse"
05:28:09 * hackage amqp-utils 0.4.0.1 - Generic Haskell AMQP tools  https://hackage.haskell.org/package/amqp-utils-0.4.0.1 (woffs)
05:28:11 * hackage ghc-lib 8.8.1.20191204 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-8.8.1.20191204 (cocreature)
05:28:25 <jpcooper> Yes
05:28:48 <Lears> % pure "hello " <> Ap ["davean", "jpcooper"] <> pure "."
05:28:48 <yahb> Lears: Ap {getAp = ["hello davean.","hello jpcooper."]}
05:28:58 <Lears> Something like that, maybe?
05:30:15 <davean> jpcooper: maybe I don't understand your question - it sounded more like a design question. What are you worried about with maintaining the state?
05:30:24 <jpcooper> Lears: Aah. The mplus/Alternative must be implicit here
05:30:45 <jpcooper> davean: I was looking for something similar to what Lears just gave an example of
05:30:48 <svipal> TH is.. interesting 
05:31:13 <svipal> But I just can' t get the intuition for when I'm going to be able to do something with it or not yet
05:31:46 <Lears> jpcooper: mplus and alternative are just Monoids on a Functor structure, so if you're trying to be more general you can go straight to the source.
05:31:59 <davean> jpcooper: in that case, you've seen the list monad? It seems like it already does what you're looking for
05:32:02 <Lears> *MonadPlus and Alternative, I should say.
05:32:51 <jpcooper> davean: Yes. It's more about not writing <> explicitly, and having things over separate do-lines. I suppose I could write some sort of transformer
05:34:00 <jpcooper> In the parser, the String is destructed with each following do-line 
05:34:13 <davean> right, and you can just construct it
05:34:23 <davean> though theres some issues with Writer
05:34:42 <jpcooper> But with successive do-lines, and for general Monads/Monoids?
05:34:45 <svipal> frankenReadBase : 
05:34:46 <svipal> https://pastebin.com/7ZU8VBgC
05:35:07 <svipal> works for my purposes but you might want bleach for your eyes
05:35:17 <jpcooper> I think Writer is more about writing/overwriting a single state
05:35:28 <davean> its about constructing it
05:35:47 <jpcooper> You are write
05:35:52 <jpcooper> That looks like the one. Thanks
05:36:08 <davean> You might be better off with State and a ref in some cases
05:36:23 <davean> or whatnot
05:36:47 <jpcooper> Will make a general transformer if possible
05:39:19 <davean> yah, and writing your own version might be better in your case - Writer has its issues
05:44:26 <maralorn> merijn: I actually found a solution for my problem (nesting MonadReader) without using any newtypes: https://termbin.com/4oer
05:45:09 <maralorn> I basically have a way to convert a MonadReader Constraint without knowing the MonadStack.
05:48:18 <maralorn> Anything wrong with that approach?
06:15:39 * hackage haskoin-store 0.18.8 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.18.8 (xenog)
06:19:05 <svipal> *very* dead chat
06:38:09 * hackage op 0.1.0.0 - Common operators encouraging large-scale easy reading  https://hackage.haskell.org/package/op-0.1.0.0 (infinity0)
06:42:20 <zincy_> How does second order logic relate to dependent types?
06:44:32 <boxscape> zincy_ https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence#General_formulation
06:45:49 <dminuoso> zincy_: What initiated your question? Were you reading something in particular?
06:46:25 <zincy_> Been reading up on formal verification a bit
06:46:40 <zincy_> And saw that Lean is built on dependent type theory
06:46:55 <zincy_> And am just trying to understand the foundations of different proof assistants
06:47:08 <zincy_> With the grand goal of understanding cubical type theory
06:48:29 <zincy_> Whilst thinking am I really that interested in a careers a web app developer
06:48:41 <zincy_> :)
06:53:03 <Lycurgus> cubical type theory
06:53:41 <c_wraith> I translated that to "the lambda cube"
06:54:28 <nn> I was here earlier asking about "why there are so many partial functions in the standard library". I got called away. Just wanted to say Thank You to those who answered.
07:05:09 <Kristjan1291983> Hey guys !!! Plaese check out a game of clicks in Javascript on gameofclicks . getenjoyment.net ..... It requires turning on Chrome Experimental features, if they aren't already turned on .. It is interacrive, best players get their names in top players list !
07:25:05 <Putonlalla> Is there a canonical name for paramorphism-after-apomorphism in the same way there is one for catamorphism-after-anamorphism? If not, here's your chance to come up with one.
07:29:05 <Putonlalla> Perhaps edwardk knows.
07:56:09 * hackage pretty-hex 1.1 - A library for hex dumps of ByteStrings  https://hackage.haskell.org/package/pretty-hex-1.1 (IavorDiatchki)
07:57:19 <merijn> !
07:57:27 <merijn> That looks like a library I've wanted for ages
07:58:21 <boxscape> hm, first new version of that library in 5 years. And it's the second version.
07:58:39 * hackage genvalidity 0.9.1.0 - Testing utilities for the validity library  https://hackage.haskell.org/package/genvalidity-0.9.1.0 (Norfair)
07:58:56 <merijn> boxscape: If it works, don't touch it :p
07:59:03 <boxscape> I suppose so
07:59:39 * hackage genvalidity-containers 0.8.0.1 - GenValidity support for containers  https://hackage.haskell.org/package/genvalidity-containers-0.8.0.1 (Norfair)
08:00:45 <merijn> boxscape: I mean, sometime ago I adopted a package from someone which hadn't been updated in 9 years and still worked fine
08:01:29 <Athas> I love such libraries.  They are unfortunately rare in Haskell due to GHC churn, but they are really how code should work!
08:02:09 <Rembane> OTOH they are generally easy to update and the only updates they get are due to GHC churn.
08:06:51 <M0b10s> maybe not a quick one: i'm trying to create a instance for Read Frac that takes (F n d) where data Frac = F Integer Integer... but i'm kinda lost here
08:12:30 <merijn> That looks like you're reinventing Rational?
08:13:01 <merijn> (i.e. do you really need to implement that or can you get away with just using that?)
08:13:45 <M0b10s> i need to implement x) 
08:14:13 <merijn> M0b10s: Can't derive it either?
08:14:43 <M0b10s> merijn, derive? like normalize? 
08:15:39 <AWizzArd> Haddock. How can I link to https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html#g:1 from my project’s docs? Doing   'Data.Map.Strict.Map' does not do the trick.
08:15:43 <merijn> "data Frac = F Integer Integer deriving (Read)"
08:16:45 <merijn> AWizzArd: can you elaborate on "not doing the trick"?
08:16:58 <merijn> What do you get, how do you haddock, etc.
08:18:05 <AWizzArd> merijn: The generated html says "Map" in a monospace font, but it does not link to anything. It is just text.
08:18:34 <AWizzArd> I triggered the generation with:  stack exec -- haddock --html --hyperlinked-source --odir=testoutput Main.hs
08:19:13 <merijn> oh, I have no idea how with stack
08:19:36 <merijn> With cabal-install there's "--haddock-for-hackage" which generally seems to produce the right thing
08:19:53 <M0b10s> merijn: i wish i could just use deriving... but i can't... i need to create the instance to read exampl: "(-30/-50) :: Frac"
08:20:31 <Putonlalla> You might need to have `build: haddock: true` in your Stack configuration when building the dependencies, AWizzArd.
08:21:13 <Putonlalla> As a consequence, everything will be processed twice.
08:21:43 <svipal> M0b10s, have you ever used  http://hackage.haskell.org/package/base-4.12.0.0/docs/Text-ParserCombinators-ReadP.html before ?
08:22:26 <svipal> Also I assume you meant `return (F n d) where data Frac = F Integer Integer`, not take ?
08:24:43 <svipal> You can easily turn a parser written with readP into a readPrec instance with lift in this : http://hackage.haskell.org/package/base-4.12.0.0/docs/Text-ParserCombinators-ReadPrec.html#t:ReadPrec
08:25:09 <svipal> ^ wording is incorrect, into a Read Instance with readPrec* 
08:26:19 <svipal> there are a lot of tutorials for readP, and once you learn it you will also automagically know how to use any other parser combinator =)
08:27:43 <M0b10s> svipal: ty for the advice! i'm working on it =)
08:55:21 <maralorn> Wow, I spend my whole day introducing a useful abstraction into my code. Now the code is much cleaner, the program does the same as before and clicking a button now gets processed with a noticeable delay. /o\
09:02:16 <berndl> I'm getting confused with Free monads again. For example, how can I "lift" runWriter : Writer w a -> (a, w) to a handler of type Free (Writer w :+: g) a -> Free g (a, w)?
09:07:32 <infinity0>       Expected type: DM.DMap k1 (TypeRep k1) (MM k1 (X k1) (X k1))
09:07:32 <infinity0>         Actual type: DM.DMap * (TypeRep *) (MM * (X *) (X *))
09:07:45 <svipal>  those smileys
09:07:50 <infinity0> not sure how to fix this, this is with ghc -fprint-explicit-kinds when i try to actually instantiate a dependent map
09:08:49 <infinity0> https://repl.it/repls/EvenZanyTransversals
09:11:30 <infinity0> it compiles if i disable PolyKinds (and delete Intf) and change U1 to have kind * -> *, but ideally i wouldn't need to do that...
09:15:11 <infinity0> if i replace the type sig using one with holes, DM.DMap _ _ it advises me that "Found type wildcard ‘_’ standing for ‘TypeRep * :: * -> *’" for the first _
09:15:14 <infinity0> and "Found type wildcard ‘_’ standing for ‘MM * (X *) (X *) :: * -> *’" for the second _
09:15:22 <infinity0> but if i make those substitituions in the source code, it still fails...
09:16:33 <infinity0> ah, using ':: DM.DMap (TypeRep :: * -> *) (MM X X :: * -> *)' works
09:16:51 <infinity0> i guess the error message is adding extra * which exists internally in the ghc representation but it doesn't like to see in the source code for some reason
09:16:56 <infinity0> ghc bug?
09:17:25 <infinity0> or "wishlist" or something
10:29:12 <hseg> Hi. I'm trying to install hmatrix and combinat user-locally, probably am doing something wrong. Isn't cabal install --lib "${packages[@]}" sufficient?
10:38:46 <enoq> what's the big challenge when implementing HKTs in a language? currently looking at Kotlin's Arrow lib and their workaround is a bit nasty imo
10:39:40 <hseg> I'm getting "Could not load module... It is a member of the hidden package..." -- even after I've added the relevant module to build-depends.
10:40:18 <hseg> nm, had added it to the wrong section
10:50:53 <sm[m]> refusenick: just curious, did you figure out your cabal/stack woes mentioned on the Interactive Haskell reddit thread recently ?
10:51:20 <maralorn> Hmm I get compiler errors with "Perhaps you haven't installed the profiling libraries for package" but I used cabal --profiling, why does this happen?
10:51:39 <f-a> maralorn: you mean --enable-profiling ?
10:51:47 <maralorn> f-a: Yeah
10:52:03 <f-a> weird, should recompile/work with that
10:53:14 <maralorn> I fear it has to do with some of my packages being provided by nix and not by cabal …
10:56:24 <snyp> I wonder how the State monad is much useful, since the function you pass to bind is of type (a -> State s a), not ((a, s) -> State s a). I'd think that the function should require the just-created state to produce the new (State s a).
10:57:27 <hseg> snyp: Note that State s a ~ s -> (s, a), so a -> State s b becomes a -> s -> (s,b) ~ (s,a) -> (s,b)
10:58:46 <snyp> ah.. yea. got it. have to play around some more. 
11:26:32 <voyons_osti> is there a more generic `lines` function? i would like to split a list by slashes, for example
11:27:01 <voyons_osti> "usr/bin/ghc" -> ["usr", "bin", "ghc"]
11:27:28 <glguy> ?hackage split
11:27:29 <lambdabot> http://hackage.haskell.org/package/split
11:27:40 <glguy> voyons_osti: There's a package of various list splitting functionality
11:28:22 <voyons_osti> perfect, thank you
11:36:09 <higherorder> Hello! Quick question: is there a way to set options on compilation of a Haskell module that gets embedded in the binary? 
11:36:20 <higherorder> by options I meant attribute-value pairs
11:43:09 * hackage boolean-normal-forms 0.0.1.1 - Boolean normal form: NNF, DNF & CNF  https://hackage.haskell.org/package/boolean-normal-forms-0.0.1.1 (phadej)
12:21:17 <nil> why does the Alternative instance for ExceptT combine the exceptions monoidally? i'd expect  throwError foo <|> bar  to be equivalent to bar
12:21:32 <nil> ErrorT seems to have the expected semantics, but it's deprecated
12:22:12 <monochrom> Because some time ago someone else raised the complement question.
12:22:13 <nil> maybe i should be using catchE instead
12:22:24 <nil> hm
12:23:09 <monochrom> I expect this to be a toggle switch that will be toggled every 5 years.
12:25:01 <nshepperd1> nil: because if you try a bunch of things and they all fail, it's probably more useful to get all the errors instead of just the last one
12:25:32 <nil> ok, fair. i should really be using catchError
12:27:41 <Cale> monochrom: It should use Semigroup append, and then if you want one way, you can use the First newtype
12:29:02 <Cale> Doesn't quite make sense for the e to be required to be a monoid, I think.
12:29:29 <monochrom> #onemethodperclass
12:29:30 <Cale> (why should there necessarily be an empty error)
12:31:07 <nil> well empty is part of the MCD of Alternative
12:31:15 <monomethodism> One method per class. :)
12:31:58 <nil> are you suggesting we put (<|>) into Semialternative and empty into Alternative? :D
12:32:25 <Cale> oh, you're right, empty probably wants some sort of empty reason for failure there
12:32:36 <Cale> That's kind of awkward though
12:32:38 <Cale> huh
12:32:51 <Raito_Bezarius> I built something using "stack build --profiling" when I do "stack run <executable> -- +RTS -p", it's saying it's not built with -prof
12:33:40 <monochrom> Perhaps ExceptT should not be in Alternative.
12:34:39 <monochrom> Or even better, monomethodist would say that Alternative should be split. :)
12:35:23 <amalloy> Raito_Bezarius: stack run is willing to build the executable as well, so i'd worry that it's rebuilding without -prof. what if you use stack exec instead?
12:35:37 <Raito_Bezarius> amalloy: it was indeed this
12:35:45 <Raito_Bezarius> when I do stack run without --profile
12:35:53 <vaibhavsagar> monochrom: AZero and Alt
12:35:54 <Raito_Bezarius> it rebuilds it without -prof
12:40:57 <bifunc2> attoparsec has "manyTill"
12:40:57 <bifunc2> https://hackage.haskell.org/package/attoparsec-0.13.2.3/docs/Data-Attoparsec-ByteString-Char8.html
12:41:15 <bifunc2> How can I do a  "manyTill" with a particular Int length limit?
12:41:38 <bifunc2> For safety. I don't want it to keep trying for  too  far.
12:42:49 <Raito_Bezarius> BTW, how can Haskell uses a lot more memory on the heap than I have on my system (swap + RAM)?
12:43:00 <Raito_Bezarius> when 0 % of the time it's doing GC
12:43:21 <monochrom> It doesn't. You are only looking at a requested address space size.
12:43:41 <Raito_Bezarius> What does it mean in practice?
12:43:54 <Raito_Bezarius> I have this result from +RTS -s http://ix.io/23zh
12:44:12 <Raito_Bezarius> How can I interpret the first line?
12:44:16 <monochrom> It means, like, every country plus China proclaims "I have a piece of the Arctic circle" but no one actually uses it.
12:44:43 <Raito_Bezarius> Alright
12:44:51 <Raito_Bezarius> Is there any metric of live memory consumption?
12:44:58 <Raito_Bezarius> Is it the "total memory in use" one?
12:45:14 <monochrom> Ah OK, "191,920,801,720 bytes allocated in the heap" does not subtract what's deallocated.
12:45:26 <Raito_Bezarius> How can I know what's deallocated?
12:45:35 <Raito_Bezarius> Is it like the "copied during GC" ?
12:45:41 <monochrom> "2,663,336 bytes maximum residency"
12:45:46 <Raito_Bezarius> Okay
12:46:55 <amalloy> bifunc2: i'd try something like: atMostNTill 0 _ = pure []; atMostNTill n p = ((:) <$> p <*> atMostNTill (n -1) p) <|> pure []
12:47:16 <amalloy> well, i gues that's just atMostN but without the till part
12:48:23 <amalloy> but the idea is to have a base case at 0, and map (:) into the recursive call using the applicative instance
12:53:18 <svipal> So in your opinion, what is the worst function in base ?
12:54:03 <monochrom> Does it have to be a function?
12:55:11 <shachaf> Not even being a function would surely count against it.
12:56:05 <monochrom> Actually I should expand my horizon further!  Does it even have to be a value? :)
12:56:19 <Rembane> Types are the worst! 
12:56:32 <monochrom> I have type aliases in mind.
12:56:33 <shachaf> I'm not sure you can expand your horizons much further than the union of functions and nonfunctions.
12:57:00 <Rembane> I'm having concerns about FilePath
12:57:07 <monochrom> Yeah, that one.
12:57:56 <monochrom> Worst type alias: FilePath. Second worst type alias: String
12:58:02 <monochrom> Worst value: otherwise
12:58:20 <monochrom> The Oscar Academy Awards.
12:58:56 <svipal> thought otherwise was an actual keyword until right this instant
12:59:11 <monochrom> My point.
12:59:21 <amalloy> worst typeclass award goes to Num?
12:59:35 <svipal> Num is useful so can't be the worst
12:59:56 <Rembane> It's a bit too big 
13:00:16 <Rembane> I'm very conflicted about the numerical typeclasses. 
13:00:26 <monomethodist> Num has the most methods so a monomethodist says it's worst.  One method per class.
13:00:26 <EvanR> the operating system CAF  string ?
13:00:28 <geekosaur> you want too big, go look at Foldable
13:00:43 <monomethodist> Oh!
13:00:57 <monomethodist> OK Num is 2nd worst. :0
13:01:00 <Rembane> There's an idealistic part of me that want to rebuild it all into something very opinionated, but another part of me thinks it works reasonably well. 
13:01:01 <monomethodist> Err, :) !
13:01:11 <svipal> I would say the whole number typesystem in haskell is actually bad. When I started out it was just the worst 
13:01:21 <svipal> when to use truncate fromInteger, fromIntegral
13:01:26 <Rembane> svipal: Has it become better since than? 
13:01:28 <Rembane> *then
13:01:42 <amalloy> svipal: imo that's why otherwise is a great value. it's a tiny definition that does a good job of letting people write readable code, and it doesn't even need language support
13:01:51 <Rembane> monochrom: I thought monomethodist was an OOP programmer! :O
13:01:58 <svipal> I have become better, not sure about it becoming better haha. maybe ?
13:02:13 <Rembane> svipal: I dunno, I haven't paid attention. :)
13:02:30 <EvanR> haskell's type system changed my life
13:02:38 <svipal> and type errors around it tend to be a bit obscure
13:03:24 <geekosaur> go redo it using TypeError :p
13:03:49 <amalloy> EvanR: your life changed? clearly you haven't accepted immutability into your heart. you should have just developed a new, different life
13:04:08 <svipal> Sadly we live in the  RealWorld
13:04:28 <bifunc2> amalloy thanks that will work
13:04:34 <EvanR> which is deeply magical
13:04:45 <bifunc2> but it's strange it's not already in the lib imo
13:04:52 <bifunc2> seems like a common use case
13:05:10 <svipal> amalloy : I think otherwise is actually clever too  =)
13:09:51 <EvanR> who does this
13:10:07 <EvanR> > let x=5 in x -1
13:10:10 <lambdabot>  4
13:10:18 <EvanR> that's just abusive
13:13:42 <svipal> I don t but I do stuff like 
13:14:28 <svipal> `a x = case x of Nothing -> 0 Just x -> x` 
13:14:35 <svipal> without remorse
13:16:57 <dsal> EvanR: it's all about avoiding magic numbers... What does 5 mean all by itself?  By naming it, you can see that it means x
13:21:04 <EvanR> write - 1 as -1
13:21:10 <EvanR> space -1
13:21:16 <EvanR> very tricky
13:21:53 <EvanR> in 3000 years they will look at our math, x - -1 and be like wtf
13:25:54 <geekosaur> there's already an extension for that, I think?
13:29:09 <EvanR> there's NegativeLiterals but i didn't know there was extension to change the weird unary minus thing
13:29:23 <amalloy> back on the topic of base razzies, what wins Worst Instance of Typeclass?
13:31:10 <amalloy> my vote is Foldable ((,) a)
13:31:32 <EvanR> Enum Double
13:31:35 <monochrom> > let x = 5 in x--1
13:31:38 <lambdabot>  5
13:31:42 <monochrom> \∩/
13:31:51 <EvanR> wth
13:32:00 <EvanR> oh
13:32:03 <monochrom> --1 is a comment
13:32:23 * monochrom is a tokenizer
13:32:38 <svipal> you got me there 
13:32:48 <svipal> I even typed it into ghci and went into panic mode
13:32:53 <EvanR> > let x = 5 in x-- --C++ would hate it!
13:32:54 <geekosaur> heh
13:32:56 <lambdabot>  5
13:33:28 <geekosaur> but --C++ is just C :p
13:33:46 <geekosaur> (actually it's undefined behavior, iirc)
13:33:51 <monochrom> "leave your comments below"
13:33:57 <EvanR> was about to say
13:34:16 <EvanR> C rarely has defined behavior
13:34:23 <EvanR> much less sensible
13:37:40 <Phyx-> koz_: your example works fine for me.. aside from that getMessage will in the end get called on an invalid handle. but catching that excaption makes it exit cleanly
13:37:55 <Phyx-> koz_: are you running on a native Windows shell or bash/msys2?
13:40:18 <gentauro_> EvanR: following our chat from yesterday on why I just don't install others packages -> https://www.zdnet.com/article/two-malicious-python-libraries-removed-from-pypi/
13:40:24 <gentauro_> (there you have your answer)
13:42:50 <EvanR> in js you avoid writing your own code at all costs. in C you rewrite everything you need. in python you get pwned?
13:43:35 <dsal> c++ has the goes to operator, though..
13:43:46 <EvanR> goes to
13:43:57 <dsal> x --> 0
13:44:09 <EvanR> goes to is declarative whereas goto is imperative?
13:44:11 <merijn> >.>
13:44:41 <svipal> declarative goto sounds like sex. gimme please
13:45:04 <monochrom> That's prolog. :)
13:45:36 <EvanR> x --> 0, stores whatever is in x to location zero?
13:45:53 <merijn> EvanR: It's a decrement loop from x to 0
13:46:03 <merijn> EvanR: It's not actually an operator
13:46:09 <EvanR> omg
13:46:15 <merijn> EvanR: It's "while (x-- > 0)"
13:46:19 <svipal> this is insane, I love it
13:46:24 <merijn> EvanR: Except spaced differently
13:47:00 <EvanR> that takes the cake
13:48:28 <monochrom> haha
13:51:00 <merijn> I've also seen the joke that ----> and ------> make it go faster
13:51:07 <merijn> Which isn't true, but still
13:51:25 <merijn> (Because they're UB)
13:58:36 <jgt> the next contest is for wildest Haskell operator
14:00:33 <ChaiTRex> `wildest`
14:02:19 <vaibhavsagar> jgt: I vote `.`
14:02:28 <vaibhavsagar> what does it mean? nobody knows
14:03:01 <jgt> I don't even know what it's called
14:03:10 <jgt> "one dotty boi"?
14:03:18 <vaibhavsagar> 'dot'?
14:03:30 <vaibhavsagar> I like 'one dotty boi'
14:04:50 <jgt> I decided to go look for some
14:05:07 <jgt> apparently (&&&) is "the three stripping nuns"
14:08:01 <svipal> &&& is cool
14:08:36 <dmwit> EvanR: The only thing better than goto is comesfrom.
14:09:17 <dmwit> 10 COMESFROM 20
14:09:20 <dmwit> 20 PRINT "HELLO WORLD"
14:11:09 * hackage hw-bits 0.7.1.0 - Bit manipulation  https://hackage.haskell.org/package/hw-bits-0.7.1.0 (haskellworks)
14:11:24 <nil> dmwit: what the- what language is that
14:11:38 <EvanR> intercal on interstates!
14:11:42 <svipal> I hope there is at least one language that implements it
14:11:59 <nil> https://en.wikipedia.org/wiki/COMEFROM
14:15:44 <svipal> I think my favorite operator is &
14:16:11 <jgt> ah yes, the lone nun
14:18:05 <svipal> "Anything the compiler can't understand, which in a normal language would result in a compilation error, is just skipped."
14:18:22 <svipal> I really, really, really like this. So simple yet so brilliant
14:18:56 <monochrom> Sounds like most students and askers on IRC.
14:19:55 <monochrom> You give them an answer. Or even you're just saying something to engage them. But they don't understand what you're saying. That's fair, but the unfair part comes when they just ignore you.
14:20:43 <monochrom> Shows that they don't want to engage, they just want something they can hand in.
14:23:44 <svipal> Yeah, happens a lot. I used to do something similar actually
14:24:15 <svipal> when people used to tell me "you can do this another way" , I would get pretty stubborn 
14:24:56 <svipal> Not because of assignments , just cause I wanted to understand the way I was asking about, even if it was detrimental to the project
14:25:06 <svipal> maybe that' s why I never got anything done
14:25:33 <svipal> mood : &
14:39:34 <koz_> Phyx-: Hope your flight went well! Any chance you had a moment to look at my problem code?
14:51:09 * hackage hw-rankselect-base 0.3.3.0 - Rank-select base  https://hackage.haskell.org/package/hw-rankselect-base-0.3.3.0 (haskellworks)
14:55:10 <Phyx-> koz_: yeah I typed above :)
14:55:19 <koz_> Phyx-: Sorry, I must have missed it!
14:55:25 <koz_> Would you mind repeating yourself?
14:55:32 <Phyx-> koz_: " your example works fine for me.. aside from that getMessage will in the end get called on an invalid handle. but catching that excaption makes it exit cleanly"
14:55:45 <Phyx-> koz_: "are you running on a native Windows shell or bash/msys2?"
14:55:58 <koz_> Phyx-: I'm using PowerShell, and running via cabal new-exec.
14:56:31 <koz_> The way the application will be used in anger will be 'double click the icon', though.
14:56:39 * hackage musicw 0.2.0 - Sound synthesis library, to be used with GHCJS and Web Audio API  https://hackage.haskell.org/package/musicw-0.2.0 (dktr0)
14:57:13 <Average-user> How are you guys doing with this years aoc?
14:57:26 <ChaiTRex> I'm doing OK.
14:57:50 <ChaiTRex> Not getting on the main scoreboard OK, but practicing Haskell is going OK.
14:57:53 <Phyx-> koz_: what happens if you just cabal repl? (you don't need the new- prefix for cabal 3.0 it's the default)
14:58:05 <koz_> Phyx-: Let me try.
14:58:37 <koz_> Phyx-: Same deal - program still runs after I close the window.
14:59:24 <Average-user> ChaiTRex: Because of my timezone I'm starting puzzles like half a day after, so not even an attempt to the leaderboard
14:59:50 <Phyx-> koz_: hmmm odd, it closes for me.. and code looks correct.
15:00:04 <koz_> Let me try the use in anger option.
15:01:05 <koz_> OK, that spins up a separate shell _as well as_ the window, shell keeps running if I close window.
15:01:28 <koz_> Closing the window also burns CPU a lot (like, 11 to 20% load).
15:01:59 <Phyx-> koz_: you can try running it under Spy++ and looking at the window messages. I suspect a message is not being delivered, probably WM_DESTOY
15:02:07 <koz_> Spy++?
15:03:20 <Phyx-> right the extra shell is expected, since you've declaired a console program and inside the console are creating a GUI. but the OS would have created a console
15:03:39 <koz_> Can I somehow not get the extra shell?
15:04:01 <Phyx-> on Windows GUI applications use WinMain instead of main as the entry point
15:04:11 <koz_> What about Win32 and Haskell?
15:05:30 <Phyx-> what ya mean? Haskell programs are just another program. you'll need the same along with `-optl-mwindows` to tell the linker about it
15:05:50 <koz_> Oh, so you mean I have to create a WinMain :: IO () in Main?
15:06:17 <Phyx-> Spy++ is part of the visualstudio SDK, https://github.com/westoncampbell/SpyPlusPlus these look like they come from there
15:06:20 <koz_> Sorry if the question is obvious, I have absolutely no knowledge of this stuff.
15:08:17 <Phyx-> no worries
15:08:37 <Phyx-> as for WinMain, you can't do it in Haskell directly
15:08:44 <Phyx-> you'll need a small C stub for it
15:09:19 <koz_> Ah, so it goes something like
15:09:34 <koz_> Haskell main -> call stub with FFI -> WinMain -> call back into Haskell?
15:10:45 <Phyx-> no, C WinMain -> Initialize RTS -> Call Haskell main
15:11:09 <koz_> Ah, I see.
15:11:35 <koz_> I guess then there's no way to write a program that can be run either as a CLI application or a GUI one, but is GUI if the icon gets double-clicked?
15:12:39 <Phyx-> there is, but you still need WinMain
15:13:06 <koz_> Would I have to make the decision which way to run inside WinMain?
15:13:17 <Phyx-> https://gitlab.haskell.org/ghc/ghc/issues/2459 is a bit old but it shows the gist. I don't believe the add root is needed nowadays
15:14:29 <Phyx-> koz_: yeah. if you want to allocate a Console yourself using AllocConsole https://docs.microsoft.com/en-us/windows/console/allocconsole and then you can be a console program
15:15:19 <koz_> Phyx-: Sorry, I should have been more clear. Basically, I need the program to be able to run in batch mode (i.e. without a GUI), but only when called from within a console with specific flags. If you just double-click its icon, it should default to having a GUI.
15:15:49 <Phyx-> the reverse is also possible, in main you can destroy the console you were given with https://docs.microsoft.com/en-us/windows/console/freeconsole but you'll see a quick flash as the window will start drawing before killed
15:16:32 <Phyx-> koz_: yes that's what I mean too. basically run interactive or non-interactive
15:17:03 <koz_> Ah, OK. So basically, it goes something like
15:17:32 <koz_> WinMain -> initialize RTS -> decide what to do by parsing CLI options if any -> call Haskell main?
15:23:39 * hackage musicw 0.3.0 - Sound synthesis library, to be used with GHCJS and Web Audio API  https://hackage.haskell.org/package/musicw-0.3.0 (dktr0)
15:25:39 * hackage advent-of-code-api 0.2.7.0 - Advent of Code REST API bindings and servant API  https://hackage.haskell.org/package/advent-of-code-api-0.2.7.0 (jle)
15:25:48 <koz_> Phyx-: How do I catch the exception you mention? Do I need to modify my getMessage call somehow?
15:31:20 <koz_> Also, I'm using Spy++, but when I watch the CabinetWClass corresponding to my program, I get no messages in the Messages window.
15:31:48 <koz_> Am I meant to watch the ShellTabWindowClass instead?
15:33:03 <koz_> Not seeing any messages for resizing, minimizing or maximizing either.
15:47:49 <mikel> hi all - I was chatting with some folks here the other day that were trying to point me to typed holes, but my installation was too old
15:48:07 <mikel> specifically, GHCi, version 7.6.3
15:49:02 <mikel> And I wanted to circle back to this group because I took a look at how I went about installing my haskell platform (in the last month)
15:49:56 <mikel> The install approach that I took was via a yum package, retrieved from the Fedora epel repo
15:50:12 <mikel> Specifically, I first downloaded the rpm for the repo:
15:50:23 <mikel> wget https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm -P /tmp
15:50:30 <glguy> https://www.haskell.org/ghcup/ is my favorite way to get a GHC environment on Linux and macOS
15:50:33 <mikel> Then configured it:
15:50:34 <mikel> sudo yum install -y /tmp/epel-release-latest-7.noarch.rpm
15:50:44 <mikel> And then, installed Haskell: sudo yum install haskell-platform
15:52:07 <mikel> glguy: Thanks - next time I can give ghcup a try
15:54:48 <mikel> Anyway, I just wanted to report back to explain how I ended up with an "ancient" version of ghci
15:55:03 <mikel> Given the instructions from here: https://www.haskell.org/platform/linux.html#linux-redhat
15:55:34 <mikel> I should probably have taken more of a clue from the comment "If you prefer to use the latest version rather than the distribution-packaged version, then you may want to use the generic Linux installer."
15:55:56 <mikel> but that aside, the install page only has one immediate action that you can take:
15:56:05 <mikel> Simply run,$ sudo yum install haskell-platform
16:20:24 <sm[m]> distros tend to have old versions of things, but that's really old
16:20:43 <sm[m]> is it an older fedora version  ?
16:21:10 <mikel> the repo I added was EPEL7
16:22:18 <sm[m]> hpd: some problems with brick/vty and another package in stackage, unfortunately: https://travis-ci.org/commercialhaskell/stackage/builds/620783108?utm_source=github_status&utm_medium=notification . I wonder how I could have reproduced this before the PR 
16:23:09 <sm[m]> oops, wrong window
16:23:31 <sm[m]> mikel: would that be.. Fedora 32 ? I don't know the naming
16:24:28 <mikel> It corresponds to Red Hat 7 or Centos 7.... I'm unsure of the Fedora mapping myself
16:24:38 <sm[m]> Extra Packages for Enterprise Linux for RHEL/CentOS 7 (and maybe Fedora * too ?) I guess
16:25:23 <mikel> It looks like RHEL7 is related to Fedora 20
16:25:51 <sm[m]> So I agree with glguy. ghcup or just stack, no point using packages that old
16:25:53 <mikel> This is in the context of a cloud-hosted virtual host, so I am just using an off-the-shelf image
16:26:10 <sm[m]> (for learning haskell)
16:26:12 <mikel> Yep, totally makes sense
16:31:36 <n1c31e> why doesn't `getContents >>= lines` work?
16:32:11 <glguy> because lines doesn't return something with type (IO _)
16:32:21 <glguy> :t (getContents >>=)
16:32:22 <lambdabot> (String -> IO b) -> IO b
16:32:26 <glguy> :t lines
16:32:28 <lambdabot> String -> [String]
16:32:36 <ChaiTRex> @redo getContents >>= lines
16:32:36 <lambdabot> Maybe you meant: undo todo do
16:32:38 <glguy> [] /= IO
16:32:40 <ChaiTRex> @do getContents >>= lines
16:32:41 <lambdabot> do { a <- getContents; lines a}
16:33:25 <sm[m]> getContents >>= return . lines  or  lines <$> getContents
16:33:34 <ChaiTRex> :t getContents >>= return . lines
16:33:36 <lambdabot> IO [String]
16:34:13 <n1c31e> Thanks
16:35:12 <dmj`> :t mapM_ putStrLn =<< lines <$> getContents
16:35:14 <lambdabot> IO ()
16:39:04 <infinity0> does anyone have an example on how to actually write an instance of GEq from Data.GADT.Compare from dependent-sum
16:39:19 <infinity0> i am struggling to an instance of it even for the Identity functor :/
16:39:58 <jle`> it's not possible to write it for Identity
16:40:28 <jle`> at least not in the way it's meant to be used
16:41:29 <jle`> infinity0: usually the way to implement is through pattern matching on GADT constructors until you can witness a ~ b, or you find that you cannot
16:42:03 <jle`> for example: data Foo :: Type -> Type where F0 :: Foo 'False; F1 :: Foo 'True
16:42:16 <jle`> it's only really useful when the constructor can fully determine what the type parameter is
16:42:33 <infinity0> so for example if it contains a (Sing x)?
16:42:45 <jle`> yeah
16:43:06 <jle`> for my example, geq F0 F0 = Just Refl; geq F1 F1 = Just Refl; geq _ _ = Nothing
16:43:25 <jle`> because in the F0,F0 case, you know that 'a' and 'b' are both 'False, so they are equal
16:43:35 <jle`> in the F1,F1 case, you know 'a' and 'b' are both 'True, so they are equal
16:43:51 <jle`> in all other cases you cannot deduce that 'a' and 'b' are equal, so you just have to return Nothing
16:44:14 <infinity0> how does this work for dependent-map, because at least for dependent-map you also want to match on the values, but there is only a GCompare (and GEq) constraint but no actual Eq/Ord constraints
16:44:49 <infinity0> i'm also struggling, with a data type that does contain Sing x, to match two Sing x to get a Refl
16:45:51 <jle`> infinity0: you can use (%~) :: Sing a -> Sing b -> Decision (a :~: b)
16:45:59 <jle`> to get a Refl from two Sing's of the same kind
16:46:11 <infinity0> oh wait, maybe i'm mis-understanding dependent-map, it says "equivalent to a set of DSum k f where no two elements have the same tag"
16:46:37 <infinity0> so i guess i can't actually have two keys with the same tag but two different values (as in the type-level concept of value)
16:46:37 <jle`> yeah, you can have two items with the same 'a' type parameter, but different values in their tags
16:46:51 <jle`> and in that case you'd return Nothing i think for geq
16:48:00 <infinity0> hm ok, so maybe the doc of dependent-map is a bit misleading then
16:49:24 <dmwit> Perhaps "no two elements have the same tag" means "no two elements have the same runtime tag", not "no two elements have the same compile-time tag".
16:50:56 <dmwit> Yes, having just looked at it a bit, I think the documentation is clear and precise and you are misunderstanding.
16:52:30 <dmwit> e.g. DMap (Const keyTy :: () -> Type) is essentially the same thing as Map keyTy
16:52:58 <infinity0> if my keys are of kind Bool -> Type i can have more than two runtime keys, that would be what is "intuitive" but the words "no two elements have the same tag" suggests that you can't have two keys with tag 'True
16:53:36 <dmwit> No, the documentation consistently uses "tag" to describe a runtime thing, not 'True.
16:53:50 <dmwit> ('True is a strictly compile-time thing.)
16:55:47 <infinity0> so how am i supposed to interpret "k is a GADT-like thing [..] elements of which function an identfiers tagged with the type of the thing they identify"
16:55:59 <infinity0> "tagged with the type" suggests that the word "tag" here refers to e.g. 'True or 'False
16:56:10 <jle`> yeah, i think that might be a miscommunication there
16:56:17 <dmwit> Okay, that one is bad, I agree.
16:57:09 <infinity0> ok cool, now i'm understanding correctly at least and the map does do what i originally wanted to do (several runtime keys with the same type-tag)
16:57:36 <infinity0> going back to comparing two Sing, i need a SDecide k constraint but i'm not sure where to put the k on the RHS of the instance declaration
16:58:37 <infinity0> so i have data U1 (a :: k -> *) where U1 :: !(Sing x) -> !(a x) -> U1 a, and i'm tryign to write "instance GEq U1" which intuitively ought to be possible, and each value has a Sing x for a witness
16:59:17 <infinity0> and i suppose SDecide k means i can only do this with a U1 where the k satisfies SDecide, but not sure the syntax for this in the instance declaration
17:00:42 <jle`> SDecide k => .. should do, as long as you (a :: k) somewhere
17:01:08 <jle`> also your U1 is essentially Sigma
17:01:28 <jle`> type U1 (a :: k) = Sigma k (TyCon1 a)
17:02:02 <infinity0> i see ok, i was suspecting there was a link earlier when i saw it because i was sure the library authors must have written something along those lines
17:02:04 <jle`> but i suppose it doesn't have the right instances :)
17:02:24 <jle`> so maybe defining your own type is the way to go
17:57:02 <dmj`> jle`: 3 hours
17:58:18 <iqubic> I'm ready
18:01:42 <koz_> Phyx-: I solved it!
18:01:57 <koz_> Basically, instead of passing (Just hwnd) to getMessage, I was _supposed_ to pass Nothing.
18:02:06 <koz_> Thanks for your help and patience!
18:05:13 <dmj`> iqubic: did you see my view pattern code
18:05:26 <jusss> merijn: about last day's continuation talk, when a function can be a continuation? what's the condition?
18:06:26 <jusss> merijn: inC `bind` fn = \out -> inC (\inCval -> (fn inCval) out)    from  https://jsdw.me/posts/haskell-cont-monad/      do you think this inC is a continuation?
18:07:15 <boxscape> ugh, kind of strange that you can do "data HList :: [*] -> * where", but you can't do "type HList [*] -> *; data HList where"
18:07:34 <jusss> based on this article, the continuation should be a function f, which take a function g, and call g in the final of f
18:07:41 <boxscape> (using standalone kind signatures)
18:08:10 <jle`> boxscape: ghc 8.10 has some new toys to play with for kind sigs like that, if you haven't looked at it yet
18:08:14 <jle`> unless that's what you were referring to
18:08:20 <boxscape> jle` I'm on 8.11 :)
18:08:28 <ChaiTRex> jle`: Wait, did they release 8.8?
18:08:50 <jle`> boxscape: ah. sounds like you should draw up a proposal :)
18:08:55 <jle`> ChaiTRex: yeah 8.8 has been out since the end of august
18:09:04 <boxscape> jle` perhaps. I'm not entirely sure what the right design would be, here
18:09:25 <jle`> ChaiTRex: but it didn't really add too much besides breaking most of the ecosystem, which hasn't fully moved forward yet
18:09:43 <ChaiTRex> jle`: Ahh, I see. So no moving to it just yet.
18:09:52 <jle`> so i wouldn't fault you for not hearing about it :)
18:11:02 <jusss> f = k1 >>= \v -> return k2; f g will call g in k1, and v is the result that g in k1, then it make a new continuation k2, and call g again in that k2
18:13:20 <jusss> g is passing in the chain
18:16:59 <jle`> rest in peace stackage nightlies
18:23:27 <jle`> 2014 - 2019
18:28:19 <glguy> jle`: huh?
18:29:06 <jle`> they seem to have been halted for the past week or so
18:29:23 <jle`> was just being a little melodramatic :) but i'm not sure if there is a way to find out what is going on
18:45:07 <boxscape> I'm trying to make a heterogeneous list that can store both lifted and unlifted values. I'm not sure if my approach is right, but is there any way I can get around this error? It seems like it might be a hard barrier making it impossible https://pastebin.com/eUwW02KV
18:45:36 <boxscape> (the code uses 8.10 features)
18:46:21 <jle`> boxscape: well, the 'r' leaks so your list ks is no longer a valid list
18:46:27 <boxscape> ahh, right
18:46:30 <jle`> it's the same reason why you can't store a Maybe Int and a Maybe Bool in the same list
18:46:39 <jle`> > [Just (3 :: Int), Just True]
18:46:42 <lambdabot>  error:
18:46:42 <lambdabot>      • Couldn't match type ‘Bool’ with ‘Int’
18:46:42 <lambdabot>        Expected type: Maybe Int
18:46:48 <jle`> so maybe you can use an Either
18:47:14 <boxscape> though the error message seems to be about a different error? But I'll try something along those lines
18:47:14 <jle`> HKList :: forall (ks :: [Either (TYPE UnboxOrWhatever) Type]) ...
18:49:57 <boxscape> thanks
18:59:11 <boxscape> % () :: forall a . ()
18:59:11 <yahb> boxscape: ()
18:59:16 <boxscape> % () :: forall (a) . ()
18:59:16 <yahb> boxscape: ; <interactive>:43:16: error: parse error on input `)'
18:59:19 <boxscape> odd to make that a parse error
19:04:41 <dmwit> Not that odd. Only identifiers are allowed there.
19:05:26 <dmwit> (And not, in particular, arbitrary type expressions, that therefore could need parentheses for disambiguation.)
19:05:33 <boxscape> well, (a :: Type) is allowed as well
19:05:47 <dmwit> ack
19:06:41 <dmwit> ok =)
19:13:45 <sleblanc> boxscape, what is your objective in having an heterogeneous list?
19:13:55 <boxscape> sleblanc mostly just seeing if it's possible :)
19:14:18 <G_Ryan> nice
19:14:29 <sleblanc> I just can't find how it is a solution that simplifies a problem, rather than making it more complex
19:14:51 <sleblanc> for instance, what would you make of that heterogeneous list?
19:15:36 <boxscape> Uh I'd be surprised if there's a situation where it's actually useful
19:15:58 <nshepperd> boxscape: maybe you could parameterise your hlist by a hlist of types :p
19:16:07 <boxscape> nshepperd that's what I'm doing!
19:20:30 <boxscape> I think the actual error ghc gave me was because I was trying to be levity polymorphic in the parameter of a function
19:20:39 <boxscape> and IIRC you can only be levity polymorphic in the return type
19:22:42 <boxscape> (unless the function is bottom, apparently)
19:24:09 <sleblanc> boxscape, have you looked at Data.Dynamic? is this relevant to what you are doing?
19:24:12 <contrun[m]> how do i have a not =? in xmonad mangehook
19:24:46 <nshepperd> 'cons :: forall (a :: TYPE t) (h :: HList ts). a -> HHList h -> HHList (Cons a h)' or something
19:25:11 <boxscape> sleblanc it might be, I'm not sure how it interacts with unboxed types, but I'll take a look. At this point I don't think that what I wanted to do is possible in quite that way, i.e. you can't have something like "5 `HCons` 5# `HCons` HNil"
19:25:23 <boxscape> nshepperd yeah that doesn't work because you can't be levity polymorphic in a here
19:25:46 <boxscape> ghc doesn't know what the calling convention for that function should be if it's levity polymorphic
19:25:48 <boxscape> or something like htat
19:25:52 <nshepperd> right
19:26:08 <nshepperd> no worries, stick a typeclass on t
19:27:19 <sleblanc> contrun, not <$> (<your condition>)
19:27:43 <contrun[m]> sleblanc: thanks
19:28:23 <boxscape> nshepperd not really sure how  that would help
19:28:39 <boxscape> nshepperd seems like that would restrict it to just "TYPE LiftedRep" again
19:30:14 <nshepperd> something like 'class Cons t where cons :: forall (a :: TYPE t) (h :: HList ts). a -> HHList h -> HHList (Cons a h)'
19:30:51 <nshepperd> then in any particular instance t (and hence the calling convention) is known
19:30:59 <boxscape> hm, interesting
19:31:42 <nshepperd> so you'd have an instance for each of LiftedRep, TupleRep, whatever
19:32:24 <haskelllisp[m]>  @free fmap :: (a -> b) -> (F a -> F b)
19:32:46 <boxscape> I think you can't make a class like that though
19:32:53 <boxscape> % class Testing (a :: TYPE r) where
19:32:54 <yahb> boxscape: 
19:32:55 <boxscape> % :k Testing
19:32:56 <yahb> boxscape: Testing :: * -> Constraint
19:33:06 <boxscape> it's still not levity polymorphic
19:33:13 <boxscape> or wait
19:33:24 <boxscape> the argument is a RuntimeRep
19:33:25 <boxscape> not a type
19:33:50 <boxscape> I'll see how far I get
19:34:32 <sleblanc> i just fail to see how this is useful in anyway
19:34:37 <boxscape> it's not
19:34:51 <sleblanc> i don't mean any offense, though. 
19:34:56 <boxscape> okay :)
19:35:35 <sleblanc> aren't you just implementing serialization in a weird way?
19:36:01 <sleblanc> that is, in a format that only your code can reinterpret later?
19:36:37 <boxscape> hm, maybe? I'm not immediately seeing how it relates to serialization
19:37:42 <sleblanc> boxscape, the way I am seeing it, you are trying to coax the type system into accepting your data as being heterogeneous, when you could just serialize it in some lightweight format (think C structs) and have the same outcome with less headache
19:38:01 <sleblanc> performance-wise the difference would be minimal
19:38:29 <G_Ryan> sleblanc can u hear me
19:38:38 <sleblanc> G_Ryan, negative
19:38:39 <boxscape> Okay, yeah, that sounds you could compare it to that
19:39:05 <G_Ryan> really?? sleblanc
19:39:08 <sleblanc> boxscape, I like how it is an exercise in understanding the type system, though
19:39:20 <sleblanc> G_Ryan, no, my system does not have text to speech
19:40:06 <G_Ryan> that makes sense
19:40:11 <G_Ryan> heh :D
19:40:53 <nshepperd> isn't it more like the opposite of serialization, in that serialization throws away all static type information
19:41:41 <sleblanc> nshepperd, depends on the serialization. if you are converting to JSON, then sure, everything will become either string or number
19:42:10 <sleblanc> but msgpack and protobufs are examples that let you encode all desired type information
19:42:43 <maerwald> unfortunately, not much mature protobof support in haskell last I checked
19:42:46 <sleblanc> that is, you can encode as much or as little as you want of your type. take for example python pickling
19:42:46 <nshepperd> well, no matter the format, what you end up with is a ByteString
19:43:02 <nshepperd> and you have to do dynamic stuff to get back to your actual type
19:43:12 <sleblanc> nshepperd, yes, and then you can have a bytestring -> whatever you had to begin with
19:43:25 <sleblanc> but this begs the question: what useful thing are you going to do with such data?
19:43:42 <sleblanc> if you are looking to save it to disk, then voila, that's serialization in a weird way
19:44:07 <Pamelloes> Is there a standard way to benchmark Haskell code?
19:44:07 <sleblanc> but if you are looking to dispatch an action on each datum, then why not box it in a Command or other data type?
19:44:39 <nshepperd> i dunno
19:44:43 <sleblanc> Pamelloes, I don't think so. you can use Unix "time" to test minimal working examples
19:45:20 <sleblanc> nshepperd, because if that is the case, then what you are doing in fact is outputting a stream of (Command)s
19:46:06 <nshepperd> the only time i've thought "i should use a hlist" in actual programming was trying to make a printf-like thing less confusing
19:48:45 <dsal> Pamelloes: criterion is pretty good
19:49:42 <nshepperd> because a function that accepts a hlist seems easier to understand than one that has a variable number of arguments
19:51:52 <nshepperd> but in that case the function was a sort of adapter from haskell to a dsl, where the types had to match up, so homogenizing by turning them into Commands wouldn't work
19:53:25 <sleblanc> nshepperd, what about a solution that produces code for each possible type, using TemplateHaskell for instance?
19:53:57 <sleblanc> surely your type input domain was not unbounded
19:55:08 <sleblanc> as a comparison, the Haskell printf function has to handle only 5 types, actually, and they are String, Char, Int, Integer and RealFloat
19:56:10 <nshepperd> well yes, but printf has to deal with as many combinations of those types as you give it
19:56:51 <sleblanc> true, and so would be a solution using a list of Dynamic, but you only have a limited number of actions you can take on your values (as you don't know how to process any value of a type that you have not anticipated)
19:57:32 <nshepperd> a list of Dynamic works if you're ok with printf throwing an exception if given the wrong type
19:57:47 <sleblanc> so any value of an unexpected type might as well be a Void or a () on which you can't do anything
19:57:57 <nshepperd> it doesn't work if you want to somehow statically assert that the format string matches the arguments
19:58:06 <sleblanc> yes, of course
19:58:26 <sleblanc> the thing with printf is that you are trying to match the shape of the format string with the shape of the rest of the input
19:58:50 <Cale> Have you seen my category-printf package? lol
19:58:57 <sleblanc> no, will check it out
19:59:07 <Cale> http://hackage.haskell.org/package/category-printf
19:59:42 <Cale> The idea here, which is shared by a bunch of other typed approaches to printf is that the type of a format specifier can explain the manner in which the type of printf would change
19:59:50 <sleblanc> OverloadedStrings, I like that
20:01:21 <Cale> For example, a format specifier that requires an additional argument of type t would have a type like Format m a (t -> a) (in my types, m is the monoid being concatenated together, so String for example)
20:02:29 <Cale> and then when you compose together many formatters, what happens to the types is perfectly analogous to function composition
20:02:43 <sleblanc> this is impressive
20:02:45 <Cale> so analogous that there's a Category instance for them
20:03:02 <Cale> and in fact, it wasn't even a new Category instance, it was already in Ed Kmett's libraries :D
20:03:25 <Cale> (I just had to recognise it as being relevant and write some formatters)
20:04:28 <Cale> You actually get really nice type errors with this, it's surprisingly usable... but I still never use it
20:04:39 <sleblanc> I like the part with the stack manipulation
20:04:43 <Cale> yeah, haha
20:04:50 <Cale> There's a little forth hiding in there
20:05:01 <sleblanc> that's what I was about to say
20:05:04 <sleblanc> reminds me of forth
20:05:50 <sleblanc> I just glanced at the apply2 example and I was wondering how it could have been implemented (the dup . s) then I could only think of a stack-based interpreter as the simplest solution
20:06:18 <sleblanc> this is very cool
20:06:19 <nshepperd> what this really just needs is a ghc type checker plugin that turns printf @"hello %i world" into sprintf (c "hello " . i . c " world")
20:06:55 <sleblanc> dup = arr (\k x -> k x x) -- this is soooo weird!
20:07:00 <Cale> Well, all that stack manipulation stuff is handled by arr, which lets you write a function that takes the continuation and any arguments and apply the continuation differently if you want
20:07:30 <Cale> Or looked at another way, it's just lifting a pure function to be a formatter
20:07:39 <sleblanc> categories, eh.
20:08:08 <Cale> So if you provide a function of type (t -> t -> a) -> (t -> a), it's going to turn that into something of type Format m (t -> t -> a) (t -> a)
20:08:43 <Cale> i.e. something which takes you from needing two arguments of type t to only needing one
20:09:48 <boxscape> (arr . join)
20:09:55 <Pamelloes> dsal: I just looked at criterion and it seems to be what I'm looking for. Thanks for the recommendation :)
20:09:57 <sleblanc> :t arr . join
20:09:59 <lambdabot> Arrow a => (b -> b -> c) -> a b c
20:10:41 <boxscape> or wait
20:10:44 <boxscape> is it (arr join)?
20:10:51 <boxscape> :t arr join
20:10:52 <Cale> :t arr join
20:10:53 <lambdabot> (Arrow a1, Monad m) => a1 (m (m a2)) (m a2)
20:10:54 <lambdabot> (Arrow a1, Monad m) => a1 (m (m a2)) (m a2)
20:10:55 <Cale> yes
20:10:58 <boxscape> ok
20:11:14 <Cale> :t arr (join :: (t -> t -> a) -> (t -> a))
20:11:14 <sleblanc> :info join
20:11:15 <lambdabot> Arrow a1 => a1 (t -> t -> a2) (t -> a2)
20:11:25 <Cale> :t join
20:11:27 <lambdabot> Monad m => m (m a) -> m a
20:11:55 <Cale> join x = do y <- x; v <- y; return v
20:12:07 <Cale> Or join x = x >>= id
20:12:46 <boxscape> tbh I find defining Monads in terms of join a lot more intuitive than defining them in terms of bind, usually
20:13:02 <boxscape> shame that the current implementation of Roles is preventing join from being added to the Monad class
20:13:06 <Cale> In the monad of functions from a fixed type, "running" a function means applying it to the parameter of your overall function
20:13:29 <Cale> > (do x <- id; y <- map toUpper; z <- reverse; return (x,y,z)) "hello"
20:13:33 <lambdabot>  ("hello","HELLO","olleh")
20:13:46 <Cale> and so join basically applies a function to the same argument twice in that instance
20:13:47 <Phyx-> koz_: ah great! no you need to watch the window itself (use the binoculars and drag the target onto the window to select it)
20:14:05 <koz_> Phyx-: Ah, I see. Thanks for all your help!
20:14:28 <Cale> This stuff is all a bit too cute for its own good, but eh
20:15:41 <sleblanc> Cale, I did not get that monad example, though
20:15:58 <sleblanc> how does do-notation turn that into a function that accepts an argument?
20:16:14 <Cale> Well, remember do-notation works to combine actions of any monad m
20:16:23 <Cale> In this case, we're picking m t = e -> t
20:16:30 <Cale> Or more precisely, String -> t
20:16:37 <boxscape> :t (id >>= \x -> map toUpper >>= \y -> pure (x, y))
20:16:38 <lambdabot> [Char] -> ([Char], [Char])
20:16:46 <Cale> There's an instance Monad ((->) e)
20:17:32 <Cale> (which is a way of saying that m t = e -> t, using a partially applied (->))
20:17:35 <sleblanc> does it have anything to do with ApplicativeDo?
20:17:38 <Cale> nope
20:17:47 <sleblanc> ok, what is pure for?
20:17:52 <boxscape> pure = return
20:18:05 <Cale> return :: a -> m a in general
20:18:07 <Cale> so in this case
20:18:11 <boxscape> :t (id >>= \x -> map toUpper >>= \y -> return (x, y))
20:18:11 <Cale> return :: a -> (e -> a)
20:18:12 <lambdabot> [Char] -> ([Char], [Char])
20:18:19 <Cale> which pretty much has to be const
20:18:27 <Cale> return x = \v -> x
20:18:49 <Cale> and then (>>=) :: m a -> (a -> m b) -> m b
20:19:03 <Cale> so in this case (>>=) :: (e -> a) -> (a -> (e -> b)) -> (e -> b)
20:19:17 <Cale> and if you think that type through, there's only one reasonable thing for such a function to do
20:19:31 <Phyx-> koz_: np, good to hear you got it working!
20:19:38 <Cale> (f >>= g) x = g (f x) x
20:19:38 * Phyx- goes back to bed :)
20:19:45 <sleblanc> which is composition
20:19:49 <koz_> Phyx-: Rest up!
20:19:51 <Cale> Not quite composition
20:19:56 <Cale> But if you look at fmap
20:19:58 <koz_> sleep 10 ^ 32
20:20:10 <Cale> fmap :: (a -> b) -> (e -> a) -> (e -> b)
20:20:14 <sleblanc> oh
20:20:16 <Cale> that's got to be exactly composition
20:20:50 <Cale> This is really just the Reader monad unwrapped, if you've seen Reader
20:21:23 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
20:21:27 <lambdabot>  [5,7,10,25,32]
20:21:58 <Cale> sequence :: [m a] -> m [a]
20:22:04 <sleblanc> oh, right
20:22:07 <Cale> so in this case, sequence :: [e -> a] -> e -> [a]
20:22:15 <boxscape> nshepperd fyi your class thing works, I can now write (5 .:. 5# .:. HKNil)
20:22:23 <boxscape> so thanks!
20:22:53 <Cale> anyway, the only reason I brought it up was to explain what boxscape was doing with join there :)
20:23:04 <Cale> join :: m (m a) -> m a
20:23:11 <nshepperd> boxscape: nice! :)
20:23:17 <Cale> so in this case, (e -> e -> a) -> (e -> a)
20:23:31 <sleblanc> It was very informative
20:28:40 <boxscape> (Though right now I can't have anything with TupleRep and other RuntimeReps that take arguments, because then it would be polymorphic again. Maybe there's a way around that too, though)
20:31:17 <Axman6> Can someone explain to me what the polint of UnliftIO actually is? There's fuck all instances for it but it permeates a lot of the ecosystem
20:32:06 <dsal> Axman6: unliftio is super useful if you have a monad stack and want to do stuff like... async or whatever.
20:32:49 <koz_> Axman6: https://lexi-lambda.github.io/blog/2019/09/07/demystifying-monadbasecontrol/ <-- this is about MonadBaseControl, but the purpose is similar.
20:32:56 <koz_> It's pretty well-explained, as Alexis King is wont to do.
20:33:00 <Axman6> except it's not, because no monad stacks seem to implement it. there's no instance for ExceptT for example
20:33:01 <dsal> It's used when you have a ReaderT or similar, and want to call IO and have a callback that needs to restore your stack.
20:33:27 <koz_> (she also calls out UnliftIO specifically there)
20:33:28 <dsal> Not everything can sensibly be unlifted.
20:33:34 <Axman6> I understand what it does, but I don't understand why when it has no instances
20:34:02 <dsal> I use it with a logger=reader+IO
20:34:08 <Axman6> it has three instances: IdentityT, ResourceT and ReaderT. this isn't useful
20:34:12 <Axman6> and IO
20:34:50 <Axman6> I wanted to use the UnliftIO.Async stuff but can't
20:35:18 <dsal> If you can sensibly implement unlift for your type, then you could, but I'm not sure about ExceptT
20:35:28 <lexi-lambda> Axman6: Michael Snoyman really likes writing code in a monad that is isomorphic to `r -> IO a`. The idea is that if you want exceptions, you can use IO exceptions, and if you want state, you can use IORefs/MVars/TVars. I’m not personally all that into that style of programming, but it’s one way to write Haskell.
20:35:29 <koz_> Axman6: I believe it's because it's more-or-less always used for the ReaderT IO pattern.
20:35:30 <dsal> it's pretty easy with reader.
20:35:51 <koz_> lexi-lambda: Hihi! Thanks for the much better explanation.
20:36:00 <koz_> (also that article in general - it was a goldmine for my own learning)
20:36:40 <Axman6> lexi-lambda: neither am I, we have better tools than that
20:36:50 <lexi-lambda> Do we, though? :)
20:37:15 <dibblego> Yes.
20:37:56 <lexi-lambda> I’m half-joking. Monad transformers have a lot of problems.
20:38:06 <shapr> more than meets the eye?
20:38:09 * shapr sighs
20:38:22 <shapr> lexi-lambda: is there something better?
20:38:27 <shachaf> A lot of problems meet the eye.
20:38:37 <shapr> ooh, ouch
20:39:02 <dibblego> I agree, but gimme a transformer before a -> f b throwing exceptions
20:39:02 <lexi-lambda> I’m trying! Effect systems based on delimited control seem promising, but implementing one in Haskell and getting everything to work out is tricky.
20:39:16 <shapr> oh, is that the new thing you wrote recently?
20:39:23 <shapr> uh, fused-effects maybe?
20:39:26 * shapr googles
20:39:43 <lexi-lambda> Not quite—I wrote a thing tentatively called `eff`, but then I rewrote it two and a half times.
20:39:48 <shapr> oh, exciting!
20:39:59 <shachaf> I don't think there's any good practical answer in Haskell.
20:40:42 <dibblego> I look forward to {-# LANGUAGE LexiLambda #-} :)
20:40:57 <shapr> me too
20:40:59 <lexi-lambda> The best paper I’ve seen that addresses all the subtleties is this technical report from Daan Leijen: https://www.microsoft.com/en-us/research/publication/algebraic-effect-handlers-resources-deep-finalization/
20:41:12 <lexi-lambda> I am trying to figure out if it’s feasible to implement in Haskell.
20:41:24 <dibblego> back in the day, DDC tried to resolve this problem
20:42:30 <lexi-lambda> The main thing that makes all of this hard is IO exceptions, especially async exceptions.
20:45:17 <shapr> kill 'em off?
20:47:05 <lexi-lambda> I think async IO exceptions aren’t even a bad idea, really (imprecise, synchronous exceptions are the ones I really dislike, but I don’t really care about those too much), but the tricky thing is getting masking to cooperate with delimited control.
20:47:21 <lexi-lambda> It’s theoretically perfectly doable, I just need to figure out how to get the RTS to cooperate.
20:48:03 <boxscape> hm, any idea how to make TupleRep and such work here? https://pastebin.com/9Nk2mw7T
20:48:24 <boxscape> with CVec you could conceivable list all finite possibilities
20:48:33 <boxscape> but CTuple has a parameter with infinite possible values
20:48:40 <boxscape> or TupleRep does, rather
20:58:13 <dmj`> the advent is upon us
20:58:19 <dmj`> get ready children
21:02:26 <koz_> dmj`: Lol.
21:04:12 <boxscape16> why does void# exist?
21:04:27 <boxscape16> % :t void#
21:04:27 <yahb> boxscape16: Void#
21:04:57 <Cale> :k Void#
21:04:59 <lambdabot> error:
21:04:59 <lambdabot>     Not in scope: type constructor or class ‘Void#’
21:04:59 <lambdabot>     Perhaps you meant ‘Void’ (imported from Data.Void)
21:05:07 <boxscape16> I had thought that the idea behind Void# was that it's definitely uninhabited
21:05:10 <boxscape16> even more so than Void
21:05:12 <boxscape16> but apparently not
21:05:49 <boxscape16> % let f :: Void# -> (); f _ = () in f undefined
21:05:49 <yahb> boxscape16: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:53:37 in interactive:Ghci26
21:05:52 <boxscape16> % let f :: Void# -> (); f _ = () in f void#
21:05:52 <yahb> boxscape16: ()
21:07:18 <Cale> % :info Void#
21:07:18 <yahb> Cale: data Void# :: TYPE ('TupleRep '[]) -- Defined in `GHC.Prim'
21:07:27 <boxscape16> that's a lie
21:08:01 <boxscape16> even the kind of Void# suggests that it need not be empty, since it's the same kind as (# #)
21:08:41 <Axman6> It's probably like Proxy# which has no runtime representation so can be optimised away when being passed to functions
21:09:22 <boxscape16> but with Proxy# the idea is to provide exactly one value, I don't understand why a value of type Void# is provided
21:09:28 <boxscape16> or well
21:09:38 <boxscape16> I guess it can be optimized away if you do it that way, yes
21:09:45 <boxscape16> but you shouldn't be able to pass it to functions in the first place
21:10:21 <boxscape16> maybe there's a Note in the ghc source code
21:12:53 <boxscape> looks like arguments of type Void# are used in some places internally to make sure some things remain lazy, or something like that
21:15:06 <koz_> base 4.8 is which GHC?
21:16:03 <boxscape> https://gitlab.haskell.org/ghc/ghc/wikis/commentary/libraries/version-history
21:16:06 <boxscape> koz_ 7.10
21:16:11 <koz_> boxscape: Woah, OK.
21:20:37 <pounce> is there a function f :: (a->c) -> (a,b) -> (c,b)
21:20:52 <koz_> pounce: first from Data.Bifunctor
21:21:06 <koz_> :t first
21:21:08 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
21:21:12 <koz_> No, not that one lol.
21:21:18 <koz_> :t Data.Bifunctor.first
21:21:20 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
21:21:23 <koz_> Better.
21:22:11 <boxscape> > first (+3) (1,2)
21:22:14 <lambdabot>  (4,2)
21:22:15 <Axman6> I use first and second all the time, works for both Either and (,)
21:22:21 <boxscape> seems like they both do the same thing in this case
21:22:31 <Axman6> % :t first @Either
21:22:32 <yahb> Axman6: ; <interactive>:1:1: error: No instance for (Arrow Either) arising from a use of `first'
21:22:42 <Axman6> % :t Data.Bifunctor.first @Either
21:22:42 <yahb> Axman6: (a -> b) -> Either a c -> Either b c
21:23:00 <pounce> ty koz
21:23:06 <koz_> pounce: You're welcome.
21:24:04 <boxscape> we should have a generalized version "first :: (Arrow a, Bifunctor p) => a b c -> a (p b d) (p c b)" that subsumes both
21:24:59 <boxscape> kinda messed up the type variables there but you get my point
21:26:13 <boxscape> I suppose I could suggest that to the library committe
21:26:14 <boxscape> e
21:30:45 <Axman6> :o
21:30:53 <Axman6> except Arrow--
21:31:21 <boxscape> what does that mean
21:32:10 <Axman6> No one uses arrows anymore really (Category and Profunctor subsumes it IIRC)
21:32:25 <boxscape> hm, okay
21:32:36 <dibblego> modulo arr
21:33:10 <habbah> is there a way to load ghci with dependencies from your test-suite?
21:35:02 <boxscape> actually not sure if my proposed function would work in general, anyway
21:40:15 <koz_> Axman6: I think arrowized FRP is the biggest thing for Arrows. Well, and HXT.
21:43:13 <Axman6> and Opaleye
21:43:53 <habbah> is there a way to run your test suite from ghci?
21:47:22 <Axman6> if you can load the fileinto ghci, then you can run it
21:47:25 <koz_> GHC 8.0.2 is failing to build documentation for containers-0.6.2.1. Is this a known thing, or am I missing something?
21:47:28 <nisstyre> habbah: how are you running it now?
21:47:33 <nisstyre> you can do :l foo.hs
21:47:41 <nisstyre> or you can do :! shellcommand
21:48:12 <Axman6> :! stack test or :! cabal test should do it
21:50:31 <habbah> I have a dependency in my test-suite that isn't in my library or executable, should I simply add the dependency to those portions of the cabal file as well so that I can interactively use the depedency? I don't actually need it in the final exe
21:52:08 <heatsink> You can load your test suite in the repl
21:52:37 <heatsink> If your test suite is called "tests", then run `cabal repl tests`
21:53:18 <heatsink> It will load the test suite's dependencies
21:55:42 <habbah> thank you heatsink!
22:09:33 <habbah> :set -XNoImplicitPrelude; import qualified RIO.Prelude as Prelude ; :i Prelude.print -- says that it is imported from System.IO and searching through the RIO source, I'm unable to see where it's imported.
22:09:49 <habbah> how is it imported or better yet, where? :) 
22:11:04 <habbah> https://github.com/commercialhaskell/rio/search?q=system.io&unscoped_q=system.io   https://github.com/commercialhaskell/rio/search?q=print&unscoped_q=print
22:12:42 <MarcelineVQ> once you've loaded ghci Prelude is there. you'll need to pass that flag ahead of time ghci -XNoImplicitPrelude  or possibly  :module - Prelude  would work
22:13:16 <habbah> thank you MarcelineVQ!
22:13:16 <boxscape> You can also type :set -XNoImplicitPrelude and then :m
22:13:35 <boxscape> though :m unloads *all* modules
22:13:39 <lexi-lambda> dibblego: Don’t you get arr from Category + Profunctor? `arr f = rmap f id`
22:14:19 <dibblego> hmm yes, you're right
22:15:08 <lexi-lambda> I don’t know if you can get all the Arrow laws from the laws for Category + Strong alone, but the types work out at least
22:18:52 <habbah> is it possible to pass NoImplictPrelude to cabal new-repl?
22:19:03 <dibblego> habbah: set it in the .cabal file
22:19:12 <dibblego> or :set -XNoImplicitPrelude
22:19:39 <habbah> did both of those things
22:20:05 <habbah> guess I could try :m after calling :set -XNoImplicitPrelude
22:53:01 <bahamas> everyone who made the :doc command a reality, thank you! I appreciate your work!
22:59:57 <ovitus> anybody know how to modify cabal modules?
23:01:47 <dminuoso> ovitus: Rather than asking a meta question, its usually more helpful to you and others to ask your question directly
23:02:33 <ovitus> meta question?
23:03:10 <ovitus> I want to modify a package I installed via Cabal, I'm not sure how to do that
23:03:12 <dminuoso> ovitus: Well, what are you trying to find out? Whether anyone has cabal modification competencies, or do you have a cabal question?
23:03:43 <ovitus> I've installed Tidal and I want to modify a data type in one of the modules
23:03:57 <ovitus> idk where they are located on my Linux PC or how they are compiled
23:04:45 <dminuoso> ovitus: I see. The conventional way to modify a package is to grab either the cabal package from hackage, or the raw sources via the source repo linked in https://hackage.haskell.org/package/tidal
23:05:23 <dminuoso> ovitus: You would then make the modifications as necessary, and then direct GHC (usually via cabal) to use that package instead.
23:05:29 <dminuoso> That is, use the local package.
23:05:36 <ovitus> how do you use the local package?
23:05:52 <dminuoso> ovitus: Do you use cabal for your program/library?
23:06:33 <ovitus> I believe so
23:06:54 <maerwald> that was an either or question I think
23:07:02 <dminuoso> ovitus: How do you build your program? Do you use an invocation like `cabal build`, `cabal v2-build` or `stack ...`?
23:07:22 <dminuoso> Or just raw ghc?
23:07:31 <ovitus> cabal install tidal
23:07:31 <dminuoso> (Or maybe even a different compiler)
23:07:41 <dminuoso> ovitus: Ah, so you are using old style cabal.
23:08:01 <ovitus>  /home/awright/.cabal/lib/x86_64-linux-ghc-8.2.2/tidal-1.0.14-CayGnlsdnzQJNavWH99Ij/Sound/Tidal
23:08:11 <ovitus> I see files there but they are .hi, not .hs
23:08:19 <ovitus> and I don't think it loads from there..
23:08:22 <maerwald> dminuoso: that is not old style
23:08:58 <ovitus>   /home/awright/.cabal/packages/hackage.haskell.org/tidal  is where I have a tgz file that contains the hs files
23:09:13 <ovitus> then I have a binary here: /usr/local/bin/tidal
23:09:55 <maerwald> without understand how you want to use tidal, it is difficult to make suggestions... are you using it as a library in an existing project? do you just want to rebuild the binary with changes to the source?
23:10:25 <ovitus> I just want to modify and rebuild if possible
23:10:39 <maerwald> so you are just running the binary
23:11:05 <ovitus> oyes
23:11:08 <dminuoso> ovitus: Dont modify that, it's internal stuff.
23:11:11 <ovitus> this is the error I get:
23:11:12 <ovitus> <interactive>:36:14: error:    • Couldn't match type ‘Sound.Tidal.Context.Value’                     with ‘Value’      NB: ‘Value’ is defined at <interactive>:(16,1)-(23,35)          ‘Sound.Tidal.Context.Value’            is defined in ‘Sound.Tidal.Pattern’ in package ‘tidal-1.4.4’      Expected type:
23:11:13 <ovitus> Sound.Tidal.Context.Value -> Maybe ControlMap        Actual type: Value -> Maybe ControlMap    • In the second argument of ‘_cX’, namely ‘getC’      In the expression: _cX "" getC      In an equation for ‘cC0’: cC0 = _cX "" getC
23:11:22 <maerwald> clone the repo, then do 'cabal upate && cabal install --installdir=$HOME/.local/bin'
23:11:29 <maerwald> inside the checkout
23:12:00 <dminuoso> ovitus: Grab the source from https://github.com/tidalcycles/Tidal, modify it, then use `cabal v2-run whatever-the-exe-component-is`
23:12:27 <ovitus> or is there a way to replace a data type?
23:12:28 <ovitus> <interactive>:53:1: error:    Qualified name in binding position: Sound.Tidal.Context.Value
23:12:32 <maerwald> dminuoso: v2 is not default
23:12:36 <maerwald> *now
23:12:38 <ovitus> I want to change that whithin ghci
23:14:57 <bahamas> ovitus: if you have the source code, you can replace anything as long as you know what you're doing
23:16:17 <ovitus> well I have the source code, but I want to change just that
23:17:53 <bahamas> ovitus: ok. what's stoping you?
23:18:23 <ovitus>       Expected type: Sound.Tidal.Context.Value -> Maybe ControlMap        Actual type: Value -> Maybe ControlMap
23:18:39 <ovitus> if I rename it:
23:18:40 <ovitus> <interactive>:91:1: error:    Qualified name in binding position: Sound.Tidal.Context.Value
23:18:59 <bahamas> ovitus: are you renaming it in ghci?
23:19:08 <ovitus> yeah
23:19:10 <ovitus>       NB: ‘Value’ is defined at <interactive>:(16,1)-(23,35)          ‘Sound.Tidal.Context.Value’            is defined in ‘Sound.Tidal.Pattern’ in package ‘tidal-1.4.4’      Expected type: Sound.Tidal.Context.Value -> Maybe ControlMap        Actual type: Value -> Maybe ControlMap
23:19:40 <bahamas> ok. why don't you want to use Sound.Tidal.Context.Value?
23:22:24 * haskelllisp[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/WohKkRwNLROvqJFeevzjNgmj >
23:22:39 * hackage fplll 0.1.0.0 - Haskell bindings to <https://fplll.github.io/fplll/ fplll>  https://hackage.haskell.org/package/fplll-0.1.0.0 (lanceroy)
23:27:42 <ovitus> I want to add an additional data type
23:32:11 <bahamas> ovitus: then you need to change that function that only expects that specific Value type
23:35:28 <ovitus> thinking compiling from source might be easier
23:35:33 <ovitus> not sure how to do that though
23:35:53 <dminuoso> ovitus: 08:08:55        dminuoso | ovitus: Grab the source from https://github.com/tidalcycles/Tidal, modify it, then use `cabal v2-run whatever-the-exe-component-is`I
23:37:25 <ovitus> [awright@t460 Tidal]$ cabal v2-runcabal: unrecognised command: v2-run (try --help)
23:37:58 <dminuoso> ovitus: Upgrade your cabal.
23:38:09 <dminuoso> ovitus: It's severely outdated if it doesn't even know that command.
23:38:18 <ovitus> it's up to date
23:39:10 <dminuoso> ovitus: It's definitely not when it does not recognize v2-run.
23:39:13 <ovitus> [awright@t460 Tidal]$ cabal --versioncabal-install version 2.0.0.1compiled using version 2.0.1.0 of the Cabal library 
23:40:09 <dminuoso> ovitus: Where did you install cabal from?
23:40:20 <ovitus> yum repository
23:41:04 <dminuoso> ovitus: I'd get rid of your yum install cabal (and presumably ghc), and grab them from ghcup instead.
23:41:21 <maerwald> ouch, I thought tidal already recommends ghcup
23:41:32 <dminuoso> It's just as simple, and you get a guaranteed up-to-date compiler and cabal
23:43:56 * haskelllisp[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/aGishBiaxQkzUaxtYldKIMSo >
23:57:26 <ovitus> am I doing this right?
23:57:27 <ovitus> [awright@t460 Tidal]$ cabal v2-run tidal.cabal Resolving dependencies...cabal: The run command is for running a single executable at once. The target'tidal' refers to the package tidal-1.4.6 which includes the test suite'tests', the benchmark 'bench-speed' and the benchmark 'bench-memory'.
23:58:17 <evelyn> haskelllisp[m]: I think (and it's just a guess), Char isn't really polymorphic is it? Contrast to something like [[2,3], [4]] :: (forall a. Num a => [[a]]).
