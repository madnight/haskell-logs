00:23:49 <iqubic> I wish IntMap had mapMaybeWithKey to do a mapping operation, but also delete things out of the map.
00:24:04 <iqubic> mapMaybeWithKey :: (Key -> a -> Maybe b) -> IntMap a -> IntMap b is what I want.
00:26:04 <mniip> alterWithKey?
00:26:31 <mniip> ah not exacrlt
00:26:35 <mniip> not exactly
00:27:33 <mniip> what's wrong with
00:27:43 <mniip> :t Data.IntMap.Strict.mapMaybeWithKey
00:27:45 <lambdabot> (IS.Key -> a -> Maybe b) -> IM.IntMap a -> IM.IntMap b
00:28:13 <iqubic> Huh?
00:28:18 <iqubic> What is that?
00:28:26 <iqubic> And why is it not in Lazy?
00:28:40 <iqubic> Oh it is. I'm blind.
00:31:54 * hackage http-download 0.1.0.1 - Verified downloads with retries  https://hackage.haskell.org/package/http-download-0.1.0.1 (MichaelSnoyman)
01:17:13 <dminuoso_> Hi. Is there an elegant way to avoid this unsafePerformIO? https://gist.github.com/dminuoso/fa1af867c336a8f8eae1d4a66c1f1eaa
01:17:26 <dminuoso_> I really dont want to parametrize cmd for this user.. :(
01:20:08 <merijn> dminuoso_: Not really, you can't lookup an ENV variable without IO and I don't see anyway to get it without parameterising the function
01:22:52 <dminuoso_> merijn: Ah well, I guess I could lift it up a level like this https://gist.github.com/dminuoso/fa1af867c336a8f8eae1d4a66c1f1eaa
01:23:04 <dminuoso_> Im still torn though, unsafePerformIO feels tempting here.
01:38:18 <ben> is there a nice way to implement [Either a b -> 
01:38:21 <ben> err
01:38:32 <ben> [Either a b] -> Either a [b]
01:38:40 <ben> just taking the first Left
01:38:49 <merijn> eh
01:38:51 <merijn> :t sequence
01:38:53 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
01:38:55 <merijn> :p
01:39:05 <ben> yep, thanks!
01:39:45 <dminuoso_> ben: Look into whether traverse is perhaps the better choice.
01:40:27 <dminuoso_> ben: That is, look into the place where you produce this `[Either a b]` and think about whether you could have used `traverse` there instead.
01:40:32 <koz_> traverse truly is the answer to everything.
01:41:41 <merijn> koz_: Naah, only to half of things
01:41:49 <merijn> koz_: The other half is "function instance for Monoid"
01:41:55 <koz_> Lol, yes.
01:42:38 <koz_> Ultimate power move is using both at once.
01:49:43 <ben> hmm, `traverse` seems to make my code shorter, but not having that intermediate [Either a b] means I don't get to `map ... . zip [0..]` to annotate the Left with its position in the input, and instead I have to do that right away
01:51:40 <ben> Thanks for the help!
01:58:54 * hackage hzenhan 0.0.4 - Zenhan library for Haskell  https://hackage.haskell.org/package/hzenhan-0.0.4 (karky7)
02:38:01 <kolbycrouch> Hi all! I'm totally new to haskell so this is probably a dumb question, but here goes. I want to take a list of key/values from System.Environment.getEnvironment and get an output that looks like "key=value" seperated by newlines. How might I do this?
02:38:55 <phadej> :t unlines
02:38:57 <lambdabot> [String] -> String
02:39:14 <phadej> > let (k,v) = ("FOO", "bar") in k ++ "=" ++ v
02:39:16 <lambdabot>  "FOO=bar"
02:39:22 <phadej> those should get you started
02:40:42 <boxscape> should be lines rather than unlines in this case I think?
02:40:47 <boxscape> oh no
02:40:50 <boxscape> never mind
02:46:35 <kolbycrouch> phadej: Thanks. I think that leads me in the right direction. I guess I'm clueless about how to work with types in haskell. This gives me "expected type (a,b)" while getEnvironment has a type of "IO [(String, String)]"
02:47:20 <phadej> kolbycrouch: you better read a chapter or two in http://book.realworldhaskell.org/read/
02:49:14 <phadej> it's old book, but those things (e.g. upto chapter 7) are the same
02:50:48 <kolbycrouch> phadej: thanks I'll try to dive into it. 
02:59:47 <merijn> There's a (partially) revised version of RWH that I saw dons endorse on twitter
03:00:04 <merijn> https://github.com/tssm/up-to-date-real-world-haskell
03:00:24 <merijn> Mind you, I don't think RWH is ideal for learning Haskell
03:05:53 <phadej> different things work for different people, I liked rwh, it wasn't too sparse nor terse (and it's free)
03:05:58 <MarcelineVQ> it does have cool tasks though
03:17:44 <Athas> RWH was what really taught me Haskell back in the day.  Is it still up to date?
03:19:32 <Athas> Today I realised that Cabal does not build with GHC 8.8.1.  That's a bit tragicomic.
03:19:36 <boxscape> huh looking at the ghci examples in http://book.realworldhaskell.org/read/systems-programming-in-haskell.html they all just say that the functions used aren't in scope, odd
03:19:58 <boxscape> (okay not all but the ones towards the end of the chapter)
03:20:48 <Phyx-> phadej: yeah seems so. requests to the community portal are timing out. https://status.chocolatey.org/ I'm considering starting to mirror the GHC packages as a backup on my private feed
03:23:44 <phadej> Phyx-: seems to work /now/, though
03:29:36 <boxscape> oh boy RHW uses datatype contexts
03:30:32 <phadej> :)
03:31:05 <boxscape> s/RHW/RWH
03:32:03 <phadej> looks like that if you want perfect material you have to make it yourself (and it won't be perfect that way either)
03:32:44 <phadej> Phyx-: have you heard anything about 32-bin dists for GHC 8.8.2 or 8.10.1, btw?
03:32:48 <phadej> will there be ones?
03:37:29 <Athas> phadej: why do you need that?
03:37:38 <Athas> (Just curious.)
03:38:15 <phadej> Athas: I don't need it, but I test my code on 32bit too, if it's easily available
03:38:29 <phadej> (and with appveyor it is)
03:39:09 <phadej> especially if the package does some FFI stuff
03:40:32 <Athas> Do you know why people might need or want it?
03:40:38 <Athas> I assume it's 32-bit x86?
03:41:21 <__monty__> I'm stuck on a 32bit machine.
03:43:33 <Athas> __monty__: how old is that machine?
03:43:56 <__monty__> About a decade?
03:53:23 <phadej> but yes, I don't know why anyone would want to use 32bit machine nowadays, even phones have quite a lot of ram (though they aren't x86, but anyway)
03:54:30 <Phyx-> phadej: there should be, I fixed the issues that was blocking them
03:54:31 <__monty__> Large parts of the world are restricted to hand-me-down devices.
03:54:40 <phadej> Phyx-: ok, good to know
03:55:24 <phadej> __monty__: yes, but it's not "want to", it's more of "no other choice" situation
03:55:47 <Phyx-> phadej: problem is 32-bit Windows isn't covered by CI. so problems are usually noticed at the very last minute when the release manager is making the final tarballs
03:55:54 <Phyx-> at that point they won't stop the release for it
03:56:08 <phadej> that's :/
03:56:19 <__monty__> Yes, phadej, I'm just trying to get Athas to think about more than the rich places.
03:57:05 <phadej> Phyx-: not that cabal e.g. doesn't suffer from that (it just happens to work)
03:57:41 <Phyx-> phadej: to be fair, if the linking speed was faster I'm sure they would add it.
03:58:09 <phadej> Phyx-: it could be at least weekly build or something like that
03:58:20 <phadej> so it's not "the day before the release", but "a week before the release"
03:58:27 <Phyx-> but tbh, after working all day when I get home I don't really feel like doing more work on binutils lol. But I'll take a look after this I/O manager is shipped
03:58:50 <Phyx-> phadej: true, not sure gitlab allows that though. It seems that all triggers are based on a patch not timed
03:59:41 <phadej> Phyx-: it does https://docs.gitlab.com/ce/user/project/pipelines/schedules.html
04:00:31 <phadej> I think those are used (nightly slowtest runs, iirc)
04:00:56 <Phyx-> phadej: ah, then yeah can be proposed. the tarballs are produced by gitlab so the setup to build 32-bit is already there
04:07:07 <phadej> something to think about when there's no other things to think about :)
04:16:32 <Phyx-> I'll ping Ben after the holidays :) think he's away now
04:32:03 <phadej> iirc some release candidate should happen on 26.12 (i think 8.10.1)
04:32:25 <phadej> that's why i try to get all done today
04:34:32 <boxscape> https://gitlab.haskell.org/ghc/ghc/wikis/status/ghc-8.10.1 says alpha 3
04:58:22 <fenedor> ghc-paths statically links the paths of the ghc into the executable that it has been compiled with, right?
05:04:23 <merijn> fenedor: Looks like it, yes
05:06:01 <fenedor> so, that would imply that the executable is not relocatable, e.g. I cant copy the executable to another pc, unless the paths are exactly alike
05:06:38 <fenedor> moreover, on nixos, if the ghc version I use is changed somehow, e.g. link to more libraries or something like that, the path will also be incorrect.
05:07:28 <merijn> I don't really see why you'd ever want to use ghc-paths anyway?
05:07:30 <fenedor> implied question: does it make sense to want to be able to copy some executable to another system? Or is that with haskell currently not really possible anyways?
05:08:36 <merijn> fenedor: Also: You can't usefully change the GHC version, as there is no stable ABI
05:08:51 <merijn> fenedor: So all libraries within an application have to be built with the same GHC version anyway
05:09:32 <phadej> boxscape: some release :)
05:10:16 <fenedor> merijn, I want to use it, because I need the location of the libdir :)
05:10:29 <test5864346[m]> Might want to consider static linking.. used to work for me at least in Debian. Surely not absolutely static due to glibc. But binary worked on another Deb box w/o ghc installed
05:10:58 <fenedor> test5864346[m], but linking a ghc installation into the executable sounds... huge?
05:11:26 <merijn> fenedor: Why do you need the location of the libdir?
05:11:32 <test5864346[m]> It was ok.. iirc 10 mb, or twice that
05:20:20 <fenedor> merijn, to run a ghc session
05:20:21 <nshepperd2> fenedor: you can find the libdir by calling ghc --print-libdir
05:20:40 <fenedor> nshepperd2, yeah, but this is problematic on systems where only stack is installed
05:20:50 <merijn> fenedor: Have you looked into how ghcide/hie-bios work?
05:21:03 <fenedor> merijn, I am fixing hie-bios atm, so yeah
05:21:07 <fenedor> and ghcide uses ghc-paths
05:22:14 <nshepperd2> fenedor: how so? it'll work as long as you can somehow find the correct ghc
05:22:16 <fenedor> merijn, or rather, hie-bios calls `ghc --print-libdir` which fails on systems when there is only stack installed and no ghc on the path
05:22:46 <fenedor> nshepperd2, yes, it is hard to tell which ghc should be executed.
05:23:05 <fenedor> but I suppose you are definitely right, that this needs to be resolved at run-time
05:23:06 <nshepperd2> if you want your program to run under stack can't you just run it under 'stack exec'?
05:23:24 <nshepperd2> which'll put the right ghc in PATH
05:23:26 <fenedor> nshepperd2, yeah, but I dont like the UX of that.
05:23:36 <fenedor> and I think it is hard to explain to newcomers
05:24:19 <fenedor> moreover, you might only use stack-exec for some projects that use stack and not for others that are using cabal...
05:27:06 <nshepperd2> well, i suppose it could attempt to somehow detect whether you're using stack or what
05:27:39 <nshepperd2> by searching for a stack.yaml
05:27:59 <fenedor> nshepperd2, yeah, we are doing that atm. I think that is the best way, too.
05:28:08 <fenedor> or not quite, but soon will
05:29:06 <nshepperd2> I always thought the lack of levers for telling these editor plugins how to compile your code was rather odd
05:30:29 <fenedor> nshepperd2, what you mean?
05:33:28 <merijn> nshepperd2: That's not good enough
05:33:41 <merijn> nshepperd2: The presence of stack.yaml doesn't mean the user wants to use stack
05:34:35 <merijn> For example, lots of repositories made by others include a stack.yaml that I will then check out, but I never want tooling to use stack
05:35:05 <fenedor> exactly, that's why there is now a hie.yaml where you can specify the build-tool to use
05:35:25 <fenedor> or based on the existence of `.stack_work` nad `dist-newstyle`
05:50:54 * hackage taskwarrior 0.1.2.0 - Types and aeson instances for taskwarrior tasks  https://hackage.haskell.org/package/taskwarrior-0.1.2.0 (maralorn)
05:55:54 <haskeldjiq> guys, can you somehow pattern match on Proxy?
05:56:16 <haskeldjiq> I have a function getEventType :: Proxy (Event a) -> EventType
05:56:25 <haskeldjiq> and no idea how to implement it
05:56:40 <dminuoso_> haskeldjiq: You generally dont.
05:57:07 <dminuoso_> haskeldjiq: Pattern matching on *types* is usually done via typeclasses.
05:57:17 <haskeldjiq> dminuoso_: yes, that makes sense
05:57:30 <haskeldjiq> dminuoso_: I was hoping on someone mentioning some other mechanism
05:57:36 <haskeldjiq> dminuoso_: that could suffice
05:58:04 <dminuoso_> haskeldjiq: Depending on what you intend to do, GADTs might be a useful tool too
05:58:09 <dminuoso_> haskeldjiq: But it's hard to say without knowing more
05:59:53 <haskeldjiq> dminuoso_: one second, I'll put together a pastebin
06:00:09 <haskeldjiq> dminuoso_: it's not anything important, really, I'm just wondering what to do
06:03:28 <haskeldjiq> https://pastebin.com/jTywdhsZ
06:04:07 <haskeldjiq> obviously it's not like this is a hindrance of any kind, I'm just wondering whether there's a way to do it better without adding too much complexity
06:05:40 <dminuoso_> haskeldjiq: Which safety are you worried about exactly
06:06:11 <haskeldjiq> dminuoso_: lol, I'm definitely not worried about anything, just bored
06:06:26 <haskeldjiq> dminuoso_: perhaps the possibility of pattern matching on some inner value of the event
06:06:55 <haskeldjiq> dminuoso_: just a thought experiment, nothing more
06:07:27 <boxscape> seems like you should just be able to either use a proxy as you did above or Type Application rather getting an Event as argument
06:07:47 <boxscape> or..
06:07:52 <boxscape> I'm not sure actually
06:07:56 <haskeldjiq> boxscape: yeah I tried using Proxy
06:07:59 <haskeldjiq> but you can't pattern match
06:08:07 <dminuoso_> haskeldjiq: I think you actually meant:
06:08:08 <boxscape> is that getEventType implementation one for a single instance?
06:08:18 <haskeldjiq> one implementation per instance yeah
06:08:24 <dminuoso_> haskeldjiq: class SomeClass where data Event a :: *; getEventType :: Proxy a -> EventType
06:08:38 <boxscape> as in one line per instance or all of the lines from the pastebin per instance?
06:08:51 <dminuoso_> haskeldjiq: Then you can just write `instance SomeClass YourType where getEventType _ = whatever ...`
06:08:51 <haskeldjiq> each SomeClass instance has a number of events
06:08:57 <haskeldjiq> getEventType returns a different type per event
06:09:04 <dminuoso_> Ah
06:09:07 <haskeldjiq> dminuoso_: but there are many event types
06:09:43 <haskeldjiq> you'd have something like instance SomeClass MyType where data Event = SomeEvent | AnotherEvent | AThirdEvent etc.
06:10:12 <dminuoso_> haskeldjiq: Can you perhaps elaborate a bit more on a grand scheme of things why you think you need this?
06:10:25 <haskeldjiq> need what
06:10:33 <haskeldjiq> to "improve" the implementation
06:10:41 <haskeldjiq> I don't need to do that, it's just a thought experiment
06:12:33 <haskeldjiq> yeah, you're right, I should probably be doing something more useful
06:14:26 <haskeldjiq> oooh yeah I remembered why I wanted to do this
06:15:15 <haskeldjiq> but it'll get tangled up, perhaps I'll ask after the holidays
06:17:37 <dminuoso_> haskeldjiq: Why do you want an associated data type in the first place?
06:20:47 <dminuoso_> merijn: AMS is on by the way! :)
06:20:55 <merijn> dminuoso_: Nice :)
06:21:04 <phanimahesh[m]> AMS?
06:21:13 <dminuoso_> Amsterdam
06:21:45 <phanimahesh[m]> ooo
06:37:54 * hackage schemas 0.4.0.0 - schema guided serialization  https://hackage.haskell.org/package/schemas-0.4.0.0 (PepeIborra)
06:55:13 <Amras> I'm having a bit of trouble writing a type signature which would accept any (a,a) -> a
06:55:48 <nil> Amras: what does that mean?
06:56:11 <Amras> specifically, in the function this argument ((a,a) -> a) is used on tuples of various types.
06:56:39 <nil> maybe you want to use RankNTypes and `(forall a. (a, a) -> a) -> ...` ?
06:56:56 <Amras> when ghc encounters the first tuple the arg is used on, it assigns a to the type of that tuple. Then subsequent tuples can't be evaluated with this arg.
06:57:33 <Amras> yup, that's what I needed
06:57:34 <Amras> thanks
07:45:54 * hackage pandoc 2.9.1 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-2.9.1 (JohnMacFarlane)
07:58:24 <boxscape> is there a good reason for foldl' not being in the Prelude?
08:07:19 <geekosaur> if we start tossing around "good reasons", shortly half of bse will bein the Prelude
08:07:22 <geekosaur> *base
08:08:43 <geekosaur> (Foldable doesn't help this in the slightest…)
08:09:07 <chloekek> I was wondering if someone integrated ICU boundary analysis with Parsec or Megaparsec to parse graphemes.
08:11:10 <chloekek> I think I can just use the result of Data.Text.ICU.breaks as the stream to parse from, rather than Text or String.
08:20:42 <Uniaika> boxscape: I think the Prelude is defined in the standard
08:21:42 <geekosaur> if it were defined that strictly, Foldable and Traversable couldn't exist as they do
08:22:11 <geekosaur> :t length -- not according to the standard's Prelude
08:22:12 <lambdabot> Foldable t => t a -> Int
08:22:34 <geekosaur> (the standard says [a] -> Int)
08:23:15 <geekosaur> we also have some things from Applicative in ghc's Prelude, etc.
08:24:12 <Amras> I could use some dsp help for a really simple stateless filter I'm trying to write
08:24:43 <Amras> this is probably the wrong channel to ask this in, but I can't find a more helpful one
08:25:57 <Amras> I just need to get a low-pass filter, [(Time, a)] -> Frequency -> [(Time, a)]. I know I could use an fft + ifft here, but I'm wondering if there's a faster/cleaner solution
08:29:23 * hackage util 0.1.17.0 - Utilities  https://hackage.haskell.org/package/util-0.1.17.0 (MatthewFarkasDyck)
08:33:54 * hackage copilot-c99 3.1.1 - A compiler for Copilot targeting C99.  https://hackage.haskell.org/package/copilot-c99-3.1.1 (frankdedden)
08:48:58 <dminuoso_> prettyprinter, Im lovin' it!
08:49:32 <dminuoso_> Everything that's wrong with templating libraries is solved by prettyprinter. :)
09:13:17 <oats> I'm working on the advent of code day 7, the "feedback amplifiers" problem. I'm worried that I accidentally made my intcode vm eager instead of lazy, and since I'm using knot tying to solve part2, I think it's being sent into an infinite loop. Can anyone take a look at my code? https://paste.xinu.at/MuR3K2/
09:13:37 <oats> is there something about the combination of StateT and Except that makes it not lazy?
09:15:15 <oats> they way I get input and output in and out of my vm is just a couple lists that are stored in MachineState
09:17:55 <glguy> Except can't be lazy
09:18:15 <glguy> It tell you if the program successfully terminated or if it failed
09:18:25 <glguy> and you won't get any outputs until that is known
09:20:35 <oats> ahhh
09:20:41 <oats> so I overengineered my vm :P
09:21:45 <glguy> not over, different :)
09:21:59 <glguy> If you want to stream outputs from a machine you'll need to stream errors, too
09:23:02 <glguy> Like mine will stop when it's done, it has an error, has an output, or needs input: https://github.com/glguy/intcode/blob/master/src/Intcode.hs#L203-L208
09:23:07 <oats> glguy: how would that work?
09:23:21 <oats> aha
09:23:27 <oats> thanks for the sample :)
09:24:57 <oats> glguy: does your vm have to run in IO?
09:25:42 <glguy> no
09:29:24 <oats> I see you're not afraid of sloc :P
09:29:28 <oats> I've tried to keep mine kinda terse
09:41:17 <bitmapper> the monadfail change is a bit confusing for me when updating some older packages
09:42:15 <oats> bitmapper: how so?
09:42:33 <bitmapper> i'm not certain as to what has to be changed
09:43:43 <oats> glguy: how do you decide what fields of a record should be strict?
09:44:09 <chloekek> In Parsec there’s the uncons method of Stream to read a token with effects. Does Megaparsec also allow the stream to produce effects? I don’t seen an m there.
09:44:37 <chloekek> Or more generally: is it possible for the parser to “put back” some tokens into the stream, that were not originally in the stream?
09:45:51 <Rembane> chloekek: Just for X/Y: Why do you want to do that? 
09:48:26 <chloekek> Context-sensitive grammar that supports splicing of a string produced by evaluating an expression from the input string.
09:49:28 <chloekek> The spliced string does not have to form a valid expression, so simply non-tail recursing is insufficient, as long as the new input with the string spliced into it is still valid.
09:49:45 <solonarv> bitmapper: rule of thumb: 1) write MonadFail instances, 2) add MonadFail constraints, 3) remove failable pattern matches if the omnad in use doesn't actually have a notion of failure
09:49:56 <chloekek> E.g. "mixin('1 + ') 2" is valid syntax.
09:51:23 <solonarv> for example you might have 'newtype AppM a = AppM { runAppM :: Config -> IO (Either AppError a) } deriving (Functor, Applicative, Monad, MonadIO, MonadReader Config, ...) via (ReaderT Config (ExceptT AppError IO))'
09:51:35 <solonarv> then you can simply add 'MonadFail' to that 'deriving' clause
09:53:21 <solonarv> bitmapper: or at a use site where you have 'foo :: MonadKeyVal m => m Foo; foo = do Just v <- lookup "key"; return (frobnicate v)' you would have to change the type to 'foo :: (MonadKeyVal m, MonadFail m) => ...'
09:53:43 <bitmapper> thanks!
10:08:24 * hackage dual 0.1.0.3 - Dual category  https://hackage.haskell.org/package/dual-0.1.0.3 (MatthewFarkasDyck)
11:03:03 <dmwit> Interesting. I always thought type applications replaced proxies entirely, but I can't work out a way to pass along `c` with just type applications here: https://gist.github.com/dmwit/12a9fb639ca5918a2325003d6b5d737a
11:03:13 <dmwit> Do I need a proxy, or is there another way?
11:05:56 <solonarv> dmwit: can you also add the error you are getting?
11:06:14 <dmwit> Oh, sure.
11:06:37 <dmwit> Well, for that exact code: c is not in scope. Without the @c annotation: c is ambiguous.
11:07:07 <solonarv> dmwit: oh, I see
11:07:36 <solonarv> use InstanceSigs to write a signature for withDropProp, with an explicit forall to bring c into scope
11:08:15 <dmwit> gist updated to include full error texts
11:08:22 <dmwit> solonarv: Ah!
11:13:27 <dmwit> solonarv: Even after reading the docs, I'm still not sure how. Here's my try: https://gist.github.com/dmwit/8d434ab38bc92e774a642dd6ece36c2d
11:14:49 <boxscape> dmwit I think I ran into that same issue a couple days ago, this was the minimized example I had: https://gist.github.com/JakobBruenker/69f99a23138169a6221d06b5028167f8
11:15:16 <boxscape> proxy does work, but I think once this proposal is implemented that should make it possible without proxy https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0155-type-lambda.rst
11:15:38 <dmwit> It is a fairly puzzling error.
11:15:55 <dmwit> The two signatures look identical, and surely any signature is more general than itself.
11:17:35 <boxscape> yeah, no way for ghc to tell that the variables are supposed to be the same I suppose, but definitely doesn't make for a good error message
11:18:06 <dmwit> Your example is nice and compact, by the way. I like it.
11:18:17 <boxscape> thanks
11:28:28 <solonarv> dmwit: hmm, puzzling. I must admit I have no idea why that error is showing up
11:57:54 * hackage mmsyn7ukr 0.1.2.0 - A simple basic interface to some SoX functionality or to produce a close to the proper Ukrainian speech (if you pronounce sounds properly) with your own recorded voice.  https://hackage.haskell.org/package/mmsyn7ukr-0.1.2.0 (OleksandrZhabenko)
12:36:43 <wildtrees> if I have a GADT like : Key a where KeyBool :: Key Bool, KeyString :: Key String .... is there a way I can do something like parse :: String -> Key a , latter I wouldn't mind having a typeclass constraint on the a in another function or even in parse for going like Key a -> a 
12:37:46 <wildtrees> tried a few things, just generally bonking my head against the wall 
12:38:10 <dmwit> parse :: String -> Some Key, using http://hackage.haskell.org/package/parameterized-utils-2.0.1.0/docs/Data-Parameterized-Some.html
12:38:53 <dmwit> more google-juice: "existential box"
12:41:57 <wildtrees> I think I have used dependent sums, for something like that before 
12:42:04 <wildtrees> will check out existential box 
12:43:36 <cdunklau> if i have `data Distance = Distance Int`, how can i get 5::Int from `Distance 5`?
12:43:49 <dmwit> getDistance (Distance x) = x
12:44:08 <dmwit> or you may `data Distance = Distance { getDistance :: Int }` and this function will be defined for you.
12:44:32 <dmwit> % data Distance = Distance Int
12:44:32 <yahb> dmwit: 
12:44:45 <dmwit> % :t case Distance 5 of Distance x -> x
12:44:45 <yahb> dmwit: Int
12:44:48 <dmwit> % case Distance 5 of Distance x -> x
12:44:48 <yahb> dmwit: 5
12:45:17 <dmwit> ^ in case you want to do it inline without defining a function
12:46:21 <cdunklau> dmwit: awesome thanks. i knew how to do the record syntax thing but i wasn't making the connection 
12:47:40 <dmwit> For single-field types like this, it is usually slightly better to use newtype than data.
12:47:54 <dmwit> You won't notice for a long time if you're just making toys, though.
12:49:10 <cdunklau> dmwit: could i still make newtype Distance an instance of Bounded?
12:49:38 <cdunklau> i think i tried that and ran into problems, but i don't remember the details
12:50:06 <iqubic> cdunklau: You totally can make it an instance of bounded.
12:50:53 <cdunklau> ok cool
13:01:24 * hackage language-bash 0.9.0 - Parsing and pretty-printing Bash shell scripts  https://hackage.haskell.org/package/language-bash-0.9.0 (KyleRaftogianis)
13:09:52 <cdunklau> is there a thing like sortOn but does minimum? i see minimumBy but that takes a comparison fn not a key
13:10:27 <Orbstheorem> Hello, I have written a DSL in haskell and I would like to document it. I thought about adding haddock comments (and publish a haddock documentation), but the PO requires a generated standalone markdown file with each type containing a description of each field a one or many examples. I don't have a clue where to start. 
13:11:40 <Orbstheorem> This is what my DSL looks like: https://gitlab.com/agepoly/it/infra/kubernetes/blob/master/scripts/silhouette/src/Silhouette/Readers/ApplicationSpec.hs
13:12:54 * hackage glib 0.13.8.0 - Binding to the GLIB library for Gtk2Hs.  https://hackage.haskell.org/package/glib-0.13.8.0 (HamishMackenzie)
13:13:54 * hackage gio 0.13.8.0, gtk2hs-buildtools 0.13.8.0, pango 0.13.8.0, cairo 0.13.8.0 (HamishMackenzie)
13:14:54 * hackage gtk3 0.15.4 - Binding to the Gtk+ 3 graphical user interface library  https://hackage.haskell.org/package/gtk3-0.15.4 (HamishMackenzie)
13:15:54 * hackage gtk 0.15.4 - Binding to the Gtk+ graphical user interface library.  https://hackage.haskell.org/package/gtk-0.15.4 (HamishMackenzie)
13:26:54 <wildtrees> @type sortBy 
13:26:55 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
13:27:07 <wildtrees> cdunklau, ^^^ is that what you want? 
13:35:47 <jollygood2> > minimumBy (comparing length) (words "aaa a aa") "a"
13:35:49 <lambdabot>  error:
13:35:50 <lambdabot>      • Couldn't match expected type ‘[Char] -> t’
13:35:50 <lambdabot>                    with actual type ‘[Char]’
13:35:57 <jollygood2> > minimumBy (comparing length) (words "aaa a aa")
13:36:00 <lambdabot>  "a"
13:36:04 <jollygood2> :t comparing
13:36:06 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
13:37:53 <jollygood2> one neat thing about comparison functions is that you can combine them as Monoids
13:39:35 <cdunklau> wildtrees: the other way, i was looking for minimumOn. but minimumBy works
13:41:51 <glguy> oats: I make record fields strict if they are either small types where I want them to unpack into the record or if I think that having that field strict will lead to the evaluation behavior I'm looking for
13:42:30 <glguy> oats: if I know a field is going to be updated a lot more than it will be used, but that it's always used, having it be strict can help avoid building up thunks
13:43:55 <glguy> I leave them lazy when I intend to rely on that for streaming behavior or to avoid evaluating fields that might never be used
13:49:45 <jollygood2> > sortBy (comparing (map toLower)) (words "CC b AA c a BB")
13:49:48 <lambdabot>  ["a","AA","b","BB","c","CC"]
13:50:20 <jollygood2> sortBy (comparing length <> comparing (map toLower)) (words  "CC b AA c a BB")
13:50:25 <jollygood2> > sortBy (comparing length <> comparing (map toLower)) (words  "CC b AA c a BB")
13:50:28 <lambdabot>  ["a","b","c","AA","BB","CC"]
14:00:24 * hackage webkit2gtk3-javascriptcore 0.14.4.0 - JavaScriptCore FFI from webkitgtk  https://hackage.haskell.org/package/webkit2gtk3-javascriptcore-0.14.4.0 (HamishMackenzie)
14:02:51 <pavonia> :t (<>) @ (a ->)
14:02:53 <lambdabot> error: parse error on input ‘)’
14:03:14 <pavonia> :t (<>)
14:03:17 <lambdabot> Semigroup a => a -> a -> a
14:04:19 <MarcelineVQ> % :t (<>) @((->) _ _)
14:04:19 <yahb> MarcelineVQ: Semigroup w1 => (w2 -> w1) -> (w2 -> w1) -> w2 -> w1
14:04:21 <monochrom> probably you have to say "((->) a)"
14:04:37 <monochrom> err nevermind :)
14:04:50 <MarcelineVQ> a isn't in scope so you need to wildcard it
14:05:52 <solonarv> % :t (<>) @(_ -> _)
14:05:52 <yahb> solonarv: Semigroup w1 => (w2 -> w1) -> (w2 -> w1) -> w2 -> w1
14:07:15 <solonarv> that works too: you only need to use prefix (->) if you are trying to partially apply it
14:07:32 <MarcelineVQ> as I should mention that operator sections don't work there so I used (->) because that's what you'd write if you were only supplying one argument to ->
14:07:34 <MarcelineVQ> oh ehe
14:08:40 <pavonia> I'm still puzzled how this works in the sorting example above. It's not just function chaining here, right?
14:09:39 <amalloy> pavonia: f <> g = \x -> f x <> g x
14:10:18 <pavonia> :t sortBy
14:10:19 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
14:10:22 <amalloy> since Ordering is a semigroup (choosing the first non-EQ result), so are functions which produce an Ordering
14:10:53 <amalloy> (and functions which produce functions which produce an Ordering)
14:11:26 <pavonia> So if the first result is EQ, it chooses the second one?
14:11:50 <monochrom> > (EQ <> GT)
14:11:52 <lambdabot>  GT
14:11:55 <monochrom> > (EQ <> LT)
14:11:58 <lambdabot>  LT
14:12:08 <monochrom> Yeah
14:12:25 <monochrom> this gives you lexicographical ordering.
14:12:42 <pavonia> That's a neat trick
14:46:39 <moet> question for users of new-build .. where is the plan stored? and do you commit it to your repo? .. it looks to me like the plan is dependent on cabal.project.local and .ghc.environment.* ... should i commit those two to make my future builds reproducable?
15:04:51 <solonarv> moet: it's stored somewhere in dist-newstyle, I don't remember where exactly
15:05:08 <solonarv> moet: if you want to freeze dependency versions & flags you can do 'cabal v2-freeze'
15:05:39 <solonarv> this will output a cabal.project.freeze file which you can check into source control if you like
15:06:26 <moet> ah, great. thank you
15:09:37 <solonarv> moet: cabal.project.local is *not* supposed to be checked in, that's why it's called .local
15:09:58 <solonarv> same for .ghc.environment.* (and those are architecture-specific anyway)
15:44:10 <moet> ok, thanks.. that's a good thing to know; i'll add them to my ignore file
16:10:10 <hyiltiz`> hi, can someone help me with a combinatorics problem with list?
16:10:24 <hyiltiz`> Int -> [[a]] -> [[a]]
16:11:09 <hyiltiz`> sampleInput = [[a1,a2,a3], [b1,b2], [c1,c2,c3,c4]]
16:11:39 <hyiltiz`> sampleOutput = [[a1,b1,c1], [a1,b1,c2], ..., [c1, a1, b1], ...]
16:12:13 <hyiltiz`> Was writing a solver for a game, and got stuck here 
16:15:11 <rwmorrison> Hello. I'm using `Network.Socket` and `Data.Binary` to implement a simple protocol over TCP. I can easily send messages (by using `sendAll` and `encode`), but I don't know how to properly receive messages. Those may be of a variable length and I can't find an incremental `decode` function for that
16:15:22 <rwmorrison> Should I switch to `attoparsec` instead?
16:17:17 <Axman6> attoparsec would certainly give you that
16:24:58 <hyiltiz`> hoogle pointed to a few functions that wasnt quite useful
16:25:05 <hyiltiz`> any idea to go at it?
16:26:40 <Axman6> > replicateM 3 ["ABC","XYZ","123"]
16:26:42 <lambdabot>  [["ABC","ABC","ABC"],["ABC","ABC","XYZ"],["ABC","ABC","123"],["ABC","XYZ","A...
16:26:58 <Axman6> hmm, no
16:28:11 <Axman6> > sequence  ["ABC","XYZ","123"]
16:28:14 <lambdabot>  ["AX1","AX2","AX3","AY1","AY2","AY3","AZ1","AZ2","AZ3","BX1","BX2","BX3","BY...
16:29:06 <LKoen> > sequence ["dna"]
16:29:09 <lambdabot>  ["d","n","a"]
16:30:39 <hyiltiz`> Thanks @Axman6 sequence seems to work for the problem I specified there
16:30:44 <jollygood2> > sequence ["dino", "dna"]
16:30:47 <lambdabot>  ["dd","dn","da","id","in","ia","nd","nn","na","od","on","oa"]
16:30:51 <hyiltiz`> but i wasnt clear what I was going for 
16:31:54 <Axman6> > replicateM 3 "ABC" -- this is what I was initially thinking of but it's the wrong thing
16:31:56 <lambdabot>  ["AAA","AAB","AAC","ABA","ABB","ABC","ACA","ACB","ACC","BAA","BAB","BAC","BB...
16:32:17 <hyiltiz`> output should be ["A", "X", "1", "AX", ..., "AX1", ..., "AXAX", ...]
16:32:49 <hyiltiz`> so non-consecutively repeating list of elements up to the order of N
16:33:08 <jollygood2> what's the input?
16:33:15 <hyiltiz`> I guess I can combine sequence with something else
16:33:38 <hyiltiz`> [[('A',1),('A',2),('A',3)],[('B',1),('B',2),('B',3)],[('C',1),('C',2),('C',3)],[('D',1),('D',2),('D',3)]]
16:33:59 <Axman6> > iterate sequence "ABC"
16:34:00 <hyiltiz`> So 4 sublists of A, B, C, D, each with 3 elements
16:34:01 <lambdabot>  error:
16:34:01 <lambdabot>      • Couldn't match type ‘Char’ with ‘[a]’
16:34:01 <lambdabot>        Expected type: [[a]]
16:34:08 <Axman6> > iterate sequence ["ABC"]
16:34:10 <lambdabot>  [["ABC"],["A","B","C"],["ABC"],["A","B","C"],["ABC"],["A","B","C"],["ABC"],[...
16:34:23 <Axman6> nope
16:34:47 <hyiltiz`> take n . iterate . sequence $ input?
16:35:04 <Axman6> probably not
16:35:37 <hyiltiz`> yeah didnt work :(
16:37:24 <hyiltiz`> `sequence input` gives me all items of order 4, nice!
16:38:20 <hyiltiz`> but iterate has elements that are consecutively repetitive, like ('A', 1), ('A', 2)
17:12:52 <wildtrees> so for Christmas I got myself a slightly better understanding of GADTs 
17:26:56 <pounce> hecko have to remember how view patterns work
17:29:28 <Axman6> > let f (show -> x) = x in f True
17:29:30 <lambdabot>  "True"
17:31:01 <pounce> hmm?
17:31:12 <pounce> is f binding to `x` along w the pattern?
17:31:23 <Axman6> that's how view patterns work.
17:31:42 <Axman6> x is the result of applying show to the argument of f
17:32:57 <pounce> ohh makes sense i didn't recognize this as a function definition
17:36:37 <jusss> newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }
17:36:43 <boxscape> % let () = if | (const () -> ()) <- () -> () in ()
17:36:43 <yahb> boxscape: ()
17:37:02 <jusss> ContT () IO Target is a type, right?
17:37:37 <jusss> ContT (Target -> IO ()) -> IO ()    is a type or value?
17:38:27 <jusss> there's no Just Int, so ContT (Target -> IO ()) -> IO () doesn't exist?
17:38:42 <jusss> totally confused again 
17:39:38 <jusss> if f :: (a->m r) -> mr, then ContT f is a value which has ContT r m a type
17:40:24 <jusss> 3 :: Int, Just 3 :: Maybe Int
17:40:55 <solonarv> jusss: 'ContT () IO Target' is a type, yes
17:41:18 <solonarv> 'ContT (Target -> IO ()) -> IO ()' looks like a type but is actually a kind error
17:41:51 <jusss> solonarv: it's not a type, not a value, right?
17:42:29 <solonarv> well, it isn't anything
17:42:34 <solonarv> it's wrong
17:42:43 <Axman6> boxscape: you're a terrible person
17:43:11 <jusss> solonarv: what if ContT (f :: (Target -> IO ()) -> IO ()) ?
17:43:19 <jusss> solonarv: this is a value , right?
17:43:30 <solonarv> it sure looks like a value
17:43:31 <Axman6> that looks like ContT () IO Target to me
17:43:31 <boxscape> Axman6 thank you
17:43:43 <solonarv> yes, and its type is ContT () IO Target
17:44:21 <jusss> Axman6: solonarv why it reverse the position in ContT?
17:44:32 <Axman6> huh?
17:44:55 <jusss> why not just ContT Target IO ()?
17:45:09 <Axman6> remember that r in ContT r m a is the type that the continuation passed to the computation will return
17:45:21 <Axman6> @src ContT
17:45:21 <lambdabot> newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }
17:45:53 <jusss> yeah, I know, which is (a->m r)
17:46:03 <Axman6> :t ContT `asAppliedTo` (undefined :: (Target -> IO ()) -> IO ())
17:46:05 <lambdabot> error:
17:46:05 <lambdabot>     Not in scope: type constructor or class ‘Target’
17:46:05 <lambdabot>     Perhaps you meant ‘Large’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
17:46:12 <Axman6> :t ContT `asAppliedTo` (undefined :: (t -> IO ()) -> IO ())
17:46:14 <lambdabot> ((a -> IO ()) -> IO ()) -> ContT () IO a
17:59:11 <iqubic> Can I use runState with a function that never returns?
18:00:26 <iqubic> Specifically I have a MonadState computation that will be outputing values via MonadWriter. Can I get the values from the writer, even if stateful computation is an infinite loop that recursively cals itself?
18:12:06 <Axman6> that probably depends on a lot of things. if youyr writer is using [a] then probably not
18:12:58 <Axman6> since it's constantly calling acc ++ newValues, it can't know how many times the first : will need to be reevaluated
18:17:51 <boxscape> % let (id -> id -> id -> ()) = () in ()
18:17:51 <yahb> boxscape: ()
18:34:34 <glguy> Yes, you can generally stream from the writer with []
18:36:30 <Axman6> can you?
18:36:49 <glguy> > head $ execWriter (do tell "a"; undefined)
18:36:52 <lambdabot>  'a'
18:37:10 <glguy> Now if you had: undefined; tell "a" 
18:37:30 <glguy> Then you'd have trouble with [] because ++ is strict in first argument
18:38:35 <glguy> If you use WriterT the streaming only works if the transformed monad can stream, too. So not IO for example
18:38:36 <Axman6> > take 10 $ execWriter (flip runState 0 $ forever (get >>= \n -> tell (show n) >> put (n+1)))
18:38:39 <lambdabot>  error:
18:38:40 <lambdabot>      • Couldn't match type ‘(a0, Integer)’
18:38:40 <lambdabot>                       with ‘WriterT [a] Identity a1’
18:38:49 <Axman6> > take 10 $ execWriter (flip runStateT 0 $ forever (get >>= \n -> tell (show n) >> put (n+1)))
18:38:51 <lambdabot>  "0123456789"
18:38:57 <Axman6> huh
18:39:10 <iqubic> I'm only composing state and writer here.
18:39:16 <iqubic> But it looks like that should work.
18:39:25 <syd> huh, TIL
18:39:35 <Axman6> yeah I didn't expect that to work
18:39:43 <iqubic> Haskell's laziness is great.
18:39:48 <iqubic> I'm going to be using that.
18:40:09 <glguy> People's expectations of Writer are all over the place; you're in good company :)
18:40:21 <Axman6> would'ver thought it was producing (((((... "1" ++ "2") ++ "3")...
18:40:57 <glguy> forever and right associated >>
18:41:11 <glguy> So therefore you get right associated ++
18:41:38 <glguy> forever uses* right associated >>
18:42:09 <iqubic> So, will the (++) just work properly here?
18:42:49 <glguy> Properly?
18:43:10 <iqubic> Like will I be able to get values out, even if I use forever and >>?
18:46:31 <glguy> Yeah, but with the normal Haskell laziness caveats that you have to have a pretty complete understanding of the evaluation behavior of the thing youre building to get the streaming to work out and the types won't help you
18:49:50 <dmwit> Welcome to Saturday Night Haskell, where the evaluation order doesn't matter and the types can't help you.
18:58:49 <iqubic> I wish there was a version of when that lets you decided what to do when the condition is false too.
18:59:02 <iqubic> So you give it what to do when true, and what to do when false.
18:59:38 <dsal> What condition?  It sounds like you're describing 'if'
19:00:10 <iqubic> I want a monadic form of if.
19:00:50 <iqubic> :t when
19:00:51 <lambdabot> Applicative f => Bool -> f () -> f ()
19:01:05 <iqubic> That's the when I was talking about.
19:01:52 <jollygood2> iqubic, if b then getLine else return "" 
19:02:25 <dsal> @src when
19:02:25 <lambdabot> when p s = if p then s else return ()
19:03:03 <iqubic> Oh. I see.
19:03:22 <koz_> There is also unless.
19:04:50 <dsal> :t bool
19:04:51 <lambdabot> a -> a -> Bool -> a
19:06:08 <dsal> mif would basically be that.  but with more monads.
19:07:26 <iqubic> I see.
19:07:32 <EvanR> monadic 'if' is probably in monad-loops
19:07:43 <jollygood2> to me, monadic if would be Monad m => m bool -> m a -> m a
19:07:54 * hackage numhask-array 0.5.0.0 - n-dimensional arrays  https://hackage.haskell.org/package/numhask-array-0.5.0.0 (tonyday567)
19:08:42 <EvanR> Monad m => m Bool -> m a -> m a -> m a
19:08:52 <jollygood2> right
19:08:52 <dsal> mamama
19:09:07 <dsal> Monad h => h Bool -> h a -> ha -> ha
19:09:15 <dsal> close
19:10:09 <iqubic> Is hoogle down???
19:10:37 <dsal> Down To Find things.
19:10:55 <iqubic> I keep getting 502 Bad Gateway errors when trying to access https://hoogle.haskell.org/
19:11:04 <dsal> You can install it locally.
19:11:20 <iqubic> I know.
19:11:44 <iqubic> But that won't let me search the lens documetation.
19:11:54 <iqubic> I have it installed locally already.
19:11:54 <dsal> Why wouldn't it?
19:12:33 <iqubic> Because I don't have the documentation for that library installed locally.
19:13:14 <dsal> The first thing hoogle does when I run it near a project is get all the relevant docs together.
19:13:32 <iqubic> I see.
19:14:19 <iqubic> This should be working, but it just isn't.
19:14:24 <iqubic> I'm getting pissed here.
19:49:54 * hackage hoppy-generator 0.7.0 - C++ FFI generator - Code generator  https://hackage.haskell.org/package/hoppy-generator-0.7.0 (khumba)
19:50:54 * hackage hoppy-docs 0.7.0, hoppy-runtime 0.7.0, hoppy-std 0.7.0 (khumba)
20:05:21 <dmwit> dsal: What more monady things would mif do that bool doesn't do?
20:08:03 <dsal> No idea.  I was just thinking mif would be a good, though not particularly idiomatic name if one doesn't like if itself.
20:09:10 <EvanR> you can get the same thing with lambda case like
20:09:20 <EvanR> myBoolAction >>= \case
20:09:30 <EvanR>   False -> ...
20:09:36 <EvanR>   True -> ...
20:09:42 <dmwit> But the request wasn't even about making the Bool argument more monady???
20:10:30 <EvanR> my irc client is lacking a search for "original request"
20:10:56 <dmwit> "I wish there was a version of when that lets you decided what to do when the condition is false too."
20:12:02 <jusss> I found two very good articles about Cont and ContT, I wonder is there another good article about callCC and delimited continuation?
20:12:21 <jusss> Cont http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
20:12:21 <jusss> ContT http://www.haskellforall.com/2012/12/the-continuation-monad.html
20:13:03 <EvanR> yeah ok that's just if then else directly
20:14:53 * hackage ascii-holidays 0.1.0.0 - ASCII animations for the holidays!  https://hackage.haskell.org/package/ascii-holidays-0.1.0.0 (TomMurphy)
20:26:02 <int-e> I regret sticking with a pure Intcode interpreter (of [Input] -> [Request] style) for AoC. Knot-tying has so much potential for going wrong.
20:26:35 <dsal> should've got a prenup
20:27:00 <nshepperd2> Tying knots? Bring a sword!
20:28:26 <int-e> Oh I guess I should write [Reply] -> [Request] there.
20:30:17 <zeta_0> what does this mean? import Control.Monad (forM_)
20:30:18 <int-e> It's not really about purity either; the sane pure style would be continuation/free monad based, data M = M Request (Maybe Reply -> M).
20:30:32 <int-e> zeta_0: It only imports  forM_  from Control.Monad
20:30:36 <int-e> :t forM_
20:30:38 <lambdabot> (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
20:30:40 <zeta_0> the forM_ part confuses me
20:31:01 <int-e> :t forM
20:31:03 <lambdabot> (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
20:31:49 <int-e> forM_ is a function, a variant of forM that discards all results. (forM takes a list of monad actions, executes them in sequence, and returns the list of results)
20:31:50 <jle`> zeta_0: ah yeah, form_ is just the same as any other identifier
20:32:08 <jle`> you could do import Control.Monad (forM_, return, ap, replicateM)
20:32:12 <jle`> to import four different functions
20:32:38 <int-e> uuhm
20:32:49 <jle`> so forM_ isn't a special language keyword, it's just the name of a function that Control.Monad exports
20:33:30 <int-e> I described sequence/sequence_. forM_ takes a list and a function that can be applied to each monad element, producing the monad actions I was talking about.
20:34:01 <zeta_0> thanks guys, i need to spend for time with monads, because they still confuse me
20:39:35 <fog> classes are the natural thing to expect when eg traversing a HList, as the functions mapped being able to act on more than one type with a definition is precisely that which is given in instances
20:39:54 <fog> thats fmap, what about applicative? 
20:40:58 <jle`> what HList are you talking about?
20:41:00 <fog> returnC :: (ApplicativeC c m,c b) => a -> m b
20:41:15 <monochrom> Yeah why are HList and fmap in the same sentence?
20:41:40 <jle`> what is ApplicativeC?
20:42:02 <fog> jle' well I guess it would have to have constraints on the list aswell to match that the fmap function was of the class the values of the HList where guarantied to be part of. im calling that a CList.
20:42:15 <jle`> okay, so what is an HList and what is a CList
20:42:25 <jle`> are they defined somewhere?
20:42:39 <fog> FList was where the cons had type f x -> FList f xs -> FList f (x:xs)
20:43:10 <jle`> i feel like i keep on asking questions and you keep on answering different ones :p
20:43:30 <fog> and CList has cons of type; c x => x -> CList c xs -> CList c (x:xs)
20:43:30 <jle`> ...is this a bot
20:45:57 <fog> so you can have a HFunctor instance for a CList, but it places a constraint on the first argument of fmap, namely that the function must be available within the scope of the constraint 
20:47:09 <jle`> 🌫 you can't really use obscure terms like this without defining them first, if you expect people to be able to understand you :)
20:47:15 <jle`> * fog 
20:49:53 <fog> class HFunctor clist where hmap :: c a => (c a => a -> b) -> clist c xs -> clist c (Replicate (Length xs) b)
20:51:29 <fog> and then if you want it to be more diverse than b, that a unique b for each `c a => a' heterogeneous choice, then i guess it would have to satisfy the constraint of inplementing an associate type family of another class which is used to determine the return type
20:51:42 <jle`> what is HList ?
20:51:47 <fog> hetrogenous list
20:51:51 <jle`> what is its definition
20:52:09 <jle`> is it a haskell type?
20:52:18 <jle`> or are you talking about an abstract concept or something
20:52:49 <fog> sorry i thought i did that above but i only did FList and CList.
20:52:56 <fog>  HList has cons of type; x -> HList xs -> HList (x:xs)
20:53:27 <jle`> what about ApplicativeC ?
20:53:54 <fog>  FList is when the type of each element is returned by some type family mapped over the input parameter list, CList is when they satisfy a constraint
20:55:05 <fog> ApplicativeC was supposed to be like FunctorC, being able to map over the hetrogenous types, but instead that would be pure having to produce the value of some choice of constrained to lie within a class
20:55:12 <fog> and I was wondering about (<*>)
20:56:23 <jle`> what is FunctorC ?
20:58:44 <fog> oh right sorry no its HFunctor, since the constraint only appears in the type signature of hmap 
20:58:55 <fog> class ApplicativeC m where pureC :: (ApplicativeC m c,c b) => a -> m b
21:00:44 <fog> hmap above, if using a constraint on the output b there would have to be a class linking both a -> b (injective associated type family?)
21:01:31 <fog> which would be mapped over the type list of the values at each point in the abstracted clist
21:02:03 <fog> instead of just Replicating b
21:02:23 <fog> :t (<*>)
21:02:24 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
21:03:23 <fog> i guess the type level params would contain the information of if it was a diagonal "zip" style applicative instance
21:03:50 <fog> ie, since the types fix this association there is only one instance?
21:05:33 <fog> unless to recover the ability to abstract over that, the class would need a way to generate the resulting types by having an associated type family to do so satisfying some constraint 
21:06:00 <fog> but then what about monad!?
21:06:22 <fog> i guess Alternative is pretty straintforward... just abstracting over (++) 
21:06:25 <fog> :t <|>
21:06:27 <lambdabot> error: parse error on input ‘<|>’
21:06:32 <fog> :t (<|>)
21:06:35 <lambdabot> Alternative f => f a -> f a -> f a
21:08:01 <fog> again, the type level lists will be merged, so giving a fixed implementation (only the order of types and their values can change, maybe either or and both give 3 options of classes)
21:09:10 <fog> partially fixed* the types appearing in fixed positions can still have their values changed, but if the types are supposed to be able to change thats another option, again requiering a way to determine these output types, so another injective associated type famility 
21:09:27 <fog> :t join
21:09:29 <lambdabot> Monad m => m (m a) -> m a
21:09:38 <fog> :t (>>=)
21:09:39 <lambdabot> Monad m => m a -> (a -> m b) -> m b
21:09:54 <fog> i dont know which of those is easier to try
21:13:45 <fog> i guess join is more strange, since there is an extra parameter to m which is the type level list of the values types
21:14:46 <fog> but that bind has again this problem with having to constrain that there is a way to determine the output type list from the input type list
21:15:31 <fog> i guess because its nested m's for join that there is then like a list of lists of types being held and that these are simply concatinated
21:16:03 <fog> again, there is only one instance here, its like list append but that can change the values because the order of the types is unchanged
21:16:24 * hackage qtah-generator 0.6.0 - Generator for Qtah Qt bindings  https://hackage.haskell.org/package/qtah-generator-0.6.0 (khumba)
21:16:54 <fog> and that adding the way to determine the new types would be abstraction over this
21:17:24 * hackage qtah-examples 0.6.0, qtah-qt5 0.6.0, qtah-cpp-qt5 0.6.0 (khumba)
21:17:26 * hackage jsaddle 0.9.7.0 - Interface for JavaScript that works with GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-0.9.7.0 (HamishMackenzie)
21:18:21 <fog> then for monadplus there might be some strange way these type mappings coincide...
21:18:24 * hackage jsaddle-webkit2gtk 0.9.7.0, jsaddle-wkwebview 0.9.7.0, jsaddle-warp 0.9.7.0 (HamishMackenzie)
21:19:24 * hackage jsaddle-clib 0.9.7.0 - Interface for JavaScript that works with GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-clib-0.9.7.0 (HamishMackenzie)
21:50:54 * hackage cobot-io 0.1.2.4 - Biological data file formats and IO  https://hackage.haskell.org/package/cobot-io-0.1.2.4 (zmactep)
21:53:10 <fog> really want traverse for CList-like things
21:55:46 <fog> its element wise right? so it would just have to have a constant way of determining the output type from the input type...
21:56:47 <fog> wonder where the applicative comes in...
21:57:24 * hackage mono-traversable 1.0.15.0 - Type classes for mapping, folding, and traversing monomorphic containers  https://hackage.haskell.org/package/mono-traversable-1.0.15.0 (MichaelSnoyman)
21:58:57 <fog> if it was HList as the applicative it would just join them together with hAppend
22:03:28 <fog> can anyone write this?
22:03:56 <fog> can anyone parse the "written in english" version?
22:04:25 <fog> or help with the types?
22:06:47 <fog> ah, its the cons that get fmaped into the values and then folded with (<*>) during traversal
22:08:24 <fog> :t traversable 
22:08:26 <lambdabot> error:
22:08:26 <lambdabot>     • Variable not in scope: traversable
22:08:26 <lambdabot>     • Perhaps you meant one of these:
22:08:34 <fog> :t traverse 
22:08:35 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
22:09:57 <fog> that is the t of `f b's that are partially applied to (<*>)
22:10:19 <fog> partially applied to cons* folded over with (<*>), sorry
22:26:24 * hackage jsaddle-dom 0.9.4.0 - DOM library that uses jsaddle to support both GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-dom-0.9.4.0 (HamishMackenzie)
22:30:23 * hackage hasbolt 0.1.4.1 - Haskell driver for Neo4j 3+ (BOLT protocol)  https://hackage.haskell.org/package/hasbolt-0.1.4.1 (zmactep)
22:40:39 <pounce> can i use >>= in view patterns
22:40:59 <pounce> wait no i think im dumb sorry
22:44:39 <pounce> actually no, say i have some f :: a -> b and g :: m a -> m b could i write `g ((fmap f) -> b) = b`
23:48:13 <lyxia> that looks ok
23:48:53 * hackage ascii-holidays 0.1.0.1 - ASCII animations for the holidays!  https://hackage.haskell.org/package/ascii-holidays-0.1.0.1 (TomMurphy)
