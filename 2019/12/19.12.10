00:22:24 <dminuoso> % :t foldrM
00:22:24 <yahb> dminuoso: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
00:22:28 <dminuoso> This is neat! :)
00:24:02 <bahamas> anyone know what happened to this effort https://github.com/text-utf8/text-utf8? on text's home page it says they're investigating using utf-8 as an internal encoding. should I understand it didn't deliver enough benefits to make it the default implementation?
00:27:50 <c_wraith> bahamas: https://jaspervdj.be/posts/2011-08-19-text-utf8-the-aftermath.html
00:30:57 <MarcelineVQ> weird timelines though, 2011 post, 2018 last git commit
00:36:57 <bahamas> c_wraith: thanks!
00:37:54 <jpcooper> Morning. Could anyone tell me why the `type Rep a` of the Generic class is `Type -> Type`? What does the argument after a signify?
00:39:03 <bahamas> jpcooper: what argument after `a`? `Rep` has kind `Type -> Type` because it takes one argument
00:40:25 <jpcooper> type Rep a :: Type -> Type. What does x signify in Rep a x?
00:40:29 <Solonarv> no, it actually does have an extra type parameter
00:40:34 <Solonarv> to be honest I am not sure why
00:40:50 <Solonarv> I think it's because the same Generic machinery is used for Generic1?
00:41:24 <dminuoso> There's a pervasive phantom type for, mostly, historical reasons I think?
00:41:36 <Solonarv> hysterical raisins
00:42:39 <jpcooper> So D1 = M1 D = Meta -> (k -> Type) -> (p :: k) -> Type
00:43:19 <jpcooper> if p is set to (x :: Type), then k is set to Type. Makes sense
00:43:55 <jpcooper> As you normally have type Rep a = D1 meta const, leaving the p argument unset
00:48:02 <jpcooper> Solonarv: Makes sense. It seems to be for Generic1. In case of Generic, then I guess the argument is thrown away
00:48:17 <Solonarv> yeah, it ends up never actually being used
00:48:36 <yasar> whatWentWrong  is not passing type checks -> https://gist.github.com/yasar11732/fc4c2692dcd6d356658b807182af34c6
00:48:45 <yasar> what am I doing wrong
00:49:08 <f-a> yasar: for the love of what's Holy, include the errors :P
00:50:05 <f-a> yasar: where is module Log?
00:50:28 <c_wraith> I'm going to guess "precedence error between <$> and $ on line 43"
00:50:36 <c_wraith> but error messages would eliminate guessing
00:50:47 <jpcooper> f-a: Is there anything like godbolt for Haskell?
00:51:39 <yasar> Error Message Here -> https://gist.github.com/yasar11732/fc4c2692dcd6d356658b807182af34c6#gistcomment-3107040
00:51:45 <c_wraith> actually, line 43 is all sorts of wrong
00:52:14 <f-a> jpcooper: that would be for sure useful, I don't know really
00:52:36 <c_wraith> you either want map extractLogMessage . filter isSever . inOrder
00:52:43 <c_wraith> or you want to just name the parameter
00:53:14 <phanimahesh> but that would be MessageTree -> [String]
00:53:43 <phanimahesh> If you already have [LogMessage] you probably just need `map extractLogMessage . filter isSever`
00:53:57 <c_wraith> ah, good point.  but yeah, that just means "get rid of inOrder"
00:54:13 <c_wraith> or change the type
00:55:09 <yasar> exercise says that whatWentWrong  takes an unsorted list of LogMessages
00:55:22 <yasar> I have to sort them
00:55:53 <phanimahesh> But the error is curiously can't match LogMessage with [LogMessage]
00:57:13 <phanimahesh> then write a helper that takes [LogMessage], makes a MessageTree and then back into [LogMessage] using inOrder
00:57:55 <phanimahesh> unless you don't want sort r sortWith
00:58:03 <phanimahesh> * unless you don't want sort or sortWith
01:01:49 <yasar> This is the current error -> https://gist.github.com/yasar11732/fc4c2692dcd6d356658b807182af34c6#gistcomment-3107047
01:02:42 <yasar> I am using <$> as infix map
01:02:48 <yasar> is that right?
01:12:09 <bahamas> yasar: I would replace all function composition, function application and fmap operators with parentheses. unless you know the fixity of each of them really well, they will trip you up, like it's happening here
01:21:20 <phanimahesh> why use <$> when map extractLogMessage . filter isSevere .sortLogMessages nicely works and is more readable?
01:22:02 <phanimahesh> prefer readability over clever code.
01:22:38 <phanimahesh> But if you want <$>, you'll need two of them both . and map are fmaps for functions and lists respectively
01:23:03 <phanimahesh> or one <$> and one of map or .
01:23:55 <Phyx-> koz_: don't use PASCAL, use WINAPI
01:24:07 <phanimahesh> `map extractLogMessage <$> filter isSevere . sortLogMessages` should work. Byt why would anyone do that, I have no idea.
01:24:13 <Phyx-> koz_: secondly did you remember to use -optl-mwindows -no-hs-main? 
01:28:38 <infinity0> could someone give an example, like concrete example with source code, how to implement this typeclass ArgDict from constraint-extras
01:28:39 <infinity0> http://hackage.haskell.org/package/constraints-extras-0.3.0.1/docs/Data-Constraint-Extras.html
01:28:54 <Gcf> Is there any way to give the original value a name when destructuring inside a let?
01:29:00 <Gcf> Something like: `let (lx,ly)@lazerPtr = (stX, 0) in`
01:29:21 <infinity0> i want to Read/Show a DSum and there is already an instance (GRead tag, Has' Read tag f) => Read (DSum tag f) likewise for Show, implementing GRead is straightforward (more or less) but Has' Read tag f less so
01:29:54 <phanimahesh> did you try `let lazerPtr@(lx,ly) = (strX, 0) in` ? I think that works.
01:30:41 <Gcf> Right, same way as in function args... 
01:31:05 <Gcf> Thanks.
01:31:22 <Gcf> Geeze, I must be more tired than I realized.
01:31:36 <phanimahesh> :D happens.
01:50:50 <merijn> Is anyone aware of some larger/more elaborate Ghosts of Departed Proofs examples beyond what's in the paper?
02:15:10 <iqubic> What's a quick way to reverse the order of the list given by sortOn?
02:15:30 <merijn> iqubic: Down
02:15:31 <MarcelineVQ> Down
02:15:33 <MarcelineVQ> :>
02:15:36 <iqubic> How so?
02:15:37 <merijn> :t sortOn
02:15:39 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
02:15:45 <merijn> > sortOn Down [1..5]
02:15:48 <lambdabot>  [5,4,3,2,1]
02:16:10 <iqubic> But I'm actually doing "sortOn getAngle xs"
02:16:16 <iqubic> How do I reverse that?
02:16:19 <iqubic> :t Down
02:16:21 <lambdabot> a -> Down a
02:16:22 <sshine> > sortOn (Down . length) ["hello", "wat"]
02:16:22 <merijn> iqubic: "sortOn (Down . getAngle)"
02:16:27 <lambdabot>  ["hello","wat"]
02:16:34 <merijn> iqubic: Down is a newtype that has a reversed Ord instance
02:16:37 * MarcelineVQ dusts off the spoonfeeding manual
02:16:57 <sshine> $ stack install spoon
02:17:13 <sshine> (I don't know if that's actually a package, sorry for confusion.)
02:17:49 <merijn> sshine: It is, actually
02:17:51 <merijn> @hackage spoon
02:17:51 <lambdabot> http://hackage.haskell.org/package/spoon
02:25:50 <michaelis> Hi. I'm new to Haskell so my questions will be very basic. What's the equivalent in Haskell to memory allocated variables in C?
02:27:50 <[exa]> michaelis: the memory allocation of whatever size happens automatically in haskell and you are kindof supposed "not to care at all". But if you really want to call malloc, you can call it and get an actual Ptr to the memory (also, you may happily segfault the program)
02:29:37 <therisen> quit
02:30:44 <michaelis> Thank you. The reason for asking is that yet understand how to work with the concept of variables in Haskell. If I have a graphical program that lets a user to draw objects, how do I store these since variables cannot change? I cannot see how I can have a linked list that changes in size depending och added/deleted data structures, for example.
02:31:23 <michaelis> s/that yet/that I don't yet/
02:33:25 <f-a> michaelis: the simplest solution is just to pass the list around
02:33:48 <[exa]> michaelis: well, the "variables" are not variables but values (stored magically for you) and bindings (names for the values that you can see). Values are immutable so the thing with "modifying a linked list" really does not work
02:33:48 <f-a> plot :: SomeState -> IO () and doSomething :: State -> State
02:34:16 <f-a> if you really miss mutation, there are some tricks
02:35:09 <[exa]> michaelis: surprisingly that restriction is rarely a problem -- e.g. modifications "at the beginning" of the list are fast, and there are many other data structures (eg. Seq) which support fast modification at both ends
02:35:48 <michaelis> f-a: I cannot say I miss it since I don't yet know how to work without it in Haskell. I just don't understand how to solve the problem without mutable variables.
02:36:15 <michaelis> Thank you [exa].
02:36:58 <f-a> michaelis: which material are you learning on?
02:37:28 <michaelis> f-a: I've begun reading "Learn You a Haskell for Greater Good!".
02:37:33 <[exa]> michaelis: instead of mutation, you just throw away the old one and create a new one. That might seem like a waste of resources, but if you do it with some minor care, it actually doesn't waste much resources at all.
02:38:19 <f-a> michaelis: excellent. CIS194 is another great (and free) one
02:38:57 <opqdonut> michaelis: if you want haskell exercises, have a look at https://github.com/opqdonut/haskell-exercises
02:39:14 <opqdonut> LYAH lacks exercises, and so do most other haskell materials on the web
02:39:38 <f-a> write a roguelike, the best exercise there is!
02:40:00 <yasar> does function application (i.e space) have lower precedence then function composition (i.e (.)) 
02:40:14 <f-a> yasar: application >>> everything
02:40:18 <[exa]> yasar: no, "space" has higher precedence than any operator
02:40:59 <yasar> Consider this "whatWentWrong = map extractLogMessage . filter isSevere . sortLogMessages"
02:41:19 <yasar> is it equal to "map (extractLogMessage . filter isSevere . sortLogMessages)"?
02:41:20 <[exa]> yasar: (as a side note, the "dot" may be also parsed as qualified name, for example in 'Map.insert k v', but there "Map.insert" is a single identifier)
02:41:37 <f-a> yasar: no
02:41:55 <f-a> (map extractLogMessage) . (filter isSevere) . sortLogMessages
02:47:08 <michaelis> [exa], f-a, opqdonut: I thank you for your help, much appreciated. I will look into the things you mentioned and will surely get back to you another day. :)
02:48:22 <f-a> cheers
03:11:25 <heebo> anyone used the Frames package? I have a csv that has some missing columns , I would like to read them into a datastructure that replaces missing values with 0.
03:11:34 <heebo> anyone have an idea how to do this?
03:20:24 <seishun> given a list, how do I get a list of indexes of elements that match a value? something like `map fst . filter ((== '#') . snd) . zip [0..]`
03:20:43 <jle`> seishun: that looks good to me
03:21:38 <seishun> oh there's elemIndices
03:22:21 * hackage cobot-tools 0.1.2.1 - Biological data file formats and IO  https://hackage.haskell.org/package/cobot-tools-0.1.2.1 (ozzzzz)
03:22:52 <jle`> :O
03:26:23 <kuribas> > foldr (\e f c -> if e == '#' then c : f (c+1)  else f (c+1)) (const []) "ab#cde#fg" 0
03:26:29 <lambdabot>  [2,6]
03:26:46 <kuribas> --seishun ^^
03:27:02 <heebo> Data.List has findIndices
03:27:16 <heebo> best not to reinvent the wheel
03:27:23 <kuribas> heebo: don't spoil the fun
03:27:40 <kuribas> heebo: it's always better in foldr form
03:27:50 <heebo> 8-)
03:29:11 <opqdonut> > concatMap (\(c,i) -> guard (c=='#') >> return i) (zip "ab#cde#fg" [0..])
03:29:14 <lambdabot>  [2,6]
03:29:34 <jle`> guard b >> return i   == i <$ guard b
03:30:02 <opqdonut> yeah I was just trying to remember what that operator was
03:33:03 <kuribas> do (c,i) <- (zip "ab#cde#fg" [0..]); i <$ guard (c=='#')
03:33:06 <kuribas> > do (c,i) <- (zip "ab#cde#fg" [0..]); i <$ guard (c=='#')
03:33:09 <lambdabot>  [2,6]
03:33:56 <kuribas> that actually looks nice
03:34:06 <kuribas> maybe not so performant though
03:34:16 <opqdonut> oh it'll all just fuse away :P
03:36:50 <jle`> 'looks nice'
03:37:12 <kuribas> declarative
03:38:10 <kuribas> for each character with index, keep the index if the character matches the given character.
03:38:26 <opqdonut> more like imperative, right?
03:38:54 <kuribas> why?
03:39:06 <kuribas> there's no side effect
03:40:39 <jle`> i'm still pretty sure elemIndices is probably more of a declarative ideal
03:40:49 <jle`> > elemIndices '#' "ab#cde#fg"
03:40:53 <lambdabot>  [2,6]
03:40:54 <kuribas> jle`: of course
03:49:21 <yasar> Can you read function documentation in ghci?
03:50:53 <f-a> yasar: 
03:50:57 <f-a> :doc function
03:51:28 <jpcooper> How can I "evaluate" a type family in ghci?
03:51:52 <merijn> jpcooper: :k!
03:51:57 <jpcooper> The type family gives a kind that is not Type, so I can't just to :t (undefined :: Family x)
03:52:00 <jpcooper> Thanks
03:52:23 <jpcooper> :k just gives me the kind, which I already know
03:52:26 <lambdabot> error: parse error on input ‘,’
03:52:28 <merijn> jpcooper: Oh, whoops ":kind!"
03:52:37 <merijn> :k! apparently doesn't work
03:52:47 <jpcooper> I've tried :k and :kind
03:54:15 <jpcooper> Oh I see. Thanks
04:04:55 <yasar> Anyone up for a code review? -> https://codereview.stackexchange.com/questions/233780/cis-194-homework-3
04:06:20 <jpcooper> yasar: Eta-reduce (\x -> snd x) to snd
04:07:21 <jpcooper> yasar: Move filter function to inside zipped so that you do not need to destruct the zipped tuples
04:08:18 <[exa]> yasar: you may try hlint, it's nice. Also, takeEvery might be more efficient as recursive, using `drop (n-1)`
04:08:20 <jpcooper> You could also replace "(\(x,y) -> takeEvery x y)" with "uncurry takeEvery"
04:10:21 <jpcooper> Anyway, as it stands, it seems that x is always equal to 1. Maybe you meant to filter the xs instead
04:11:28 <yasar> jpcooper which x?
04:11:29 <jpcooper> Sorry, that's bs. Disregard the above sentence and the sentence about moving the filter.
04:12:47 <jpcooper> In essence: eta-reduce (\x -> snd x) to snd, and you could also replace "(\(x, y) -> takeEvery x y)" with "uncurry takeEvery"
04:14:31 <jpcooper> You could also move the "take" part to the outer level and look into using zipWith, to avoid the uncurry bit
04:21:49 <steevveenn> much like there is a relation between join and monadic bind,  `m >>= f join $ fmap f m`  , is there a lnown/famous relation to express fish operator (kliesli arrow am I right) `>=>` or `<=<` in terms of join , fmap, >>= , return ?
04:22:02 <steevveenn> lnown = known
04:22:39 <nil> You could try to derive it yourself, it's a good exercise
04:23:21 <[exa]> steevveenn: I thought typeclassopaedia had one but I strongly suggest to try it yourself as well, it's strikingly intuitive
04:23:51 <steevveenn> @nil ok, gonna try it. You assure me there's one ;-)
04:23:51 <lambdabot> Maybe you meant: url unpl pl id bid
04:24:33 <merijn> cocreature: :O
04:24:47 <merijn> cocreature: Does my eye spy a beta-attempt at TH support in ghcide? :>
04:29:58 <Putonlalla> What's the canonical package for binary trees?
04:31:03 <merijn> Putonlalla: I don't think there is one?
04:31:18 <merijn> I mean, Data.Set if you want an ordered one, I suppose
04:33:29 <cocreature> merijn: yep
04:40:25 <iqubic> I have a "StateT Memory (Writer [Int]) a" How hard is it to add MonadError into that stack and change all the `error "Message"` calls in my code to something that doesn't error out?
04:40:30 <merijn> cocreature: I'll try it out tonight and see if I hit anything :)
04:40:49 <iqubic> Basically I want better error handling in my Intcode computer from AoC.
04:42:11 <Putonlalla> That's a shame.
04:42:33 <Putonlalla> There's `binary-tree`, but it's not on Stackage.
04:42:37 <dminuoso> iqubic: If you write it mtl style, it's generally easier to add effects after the fact.
04:42:55 <dminuoso> iqubic: (Also it lets you do things like `MonadStack m`)
04:42:59 <iqubic> I have it in MTL style already.
04:43:57 <iqubic> I have a bunch of (MonadState Memory m) => .... and a few (MonadWriter [Int] m) => .... functions in my code already.
04:44:11 <iqubic> I just want to add Error handling into that.
04:44:54 <iqubic> Will that be hard?
04:47:20 <merijn> dminuoso: Why would you need mtl style for "MonadStack m"?
04:48:53 <iqubic> For me, mtl is good for documenting what "effects" (reading from environment, manipulating state, appending to an output stream) each function is able to do.
04:49:20 <iqubic> It's also good for preventing me from using Writer effects in a place where they aren't needed.
04:52:28 <nil> iqubic: should be as easy as adding ExceptT somewhere in your monad stack and replacing error with throwError
04:54:09 <iqubic> Cool.
04:54:47 <fendor> lookupEnv documentation claims that it has the same behaviour on posix as getEnv, which throws an exception if the env variable does not exist. However, for me this works as expected, e.g. lookupEnv returns a Nothing if env var is unknown
04:55:37 <fendor> do I still have to catch the "isDoesNotExistError" to be safe?
04:56:34 <merijn> Are you sure you're using the same getEnv as in base? There's also one from the unix package...
04:58:33 <fendor> I imported System.Environment
04:59:31 <fendor> so, yeah, I think so
05:07:50 * hackage haskoin-node 0.9.14 - Haskoin Node P2P library for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-node-0.9.14 (xenog)
05:20:05 <bl4ckb0ne> day2 part2 done, without Array!
05:21:20 <bl4ckb0ne> https://github.com/Bl4ckb0ne/advent-of-code-2019/blob/master/day2/part2.hs
05:35:53 <jonathan_> I have a list of (Int64,Int64). They represent connections between objects, the edges of a graph, if you will. Is there some convenient way to check whether the graph contains any cycles? More specifically: I need to check whether adding a new edge to the graph would cause cyclicity
05:37:12 <seishun> is there a function that calculates the gcd of two numbers, then divides both numbers by it?
05:49:27 <aplainzetakind> Is there something like #aoc-haskell?
05:51:49 <__monty__> aplainzetakind: Lots of haskell folks over in ##adventofcode-help fwiw.
05:52:35 <safinaskar> i remember some time ago there was two public instances of hoogle. one had new index, but for some reason was not recommended for everybody (it was buggy, beta or something like this), and another was stable, but had old index. did situation resolved since that time?
05:54:06 <__monty__> hoogle.haskell.org is the newer one, doesn't find some things the old one does but better in other ways. haskell.org/hoogle is the old one.
05:59:46 <safinaskar> __monty__: when i type haskell.org/hoogle , i got redirected to hoogle.haskell.org
06:00:38 <__monty__> Ah, you're right, I switched to h.h.o a while back so I didn't notice.
06:01:25 <safinaskar> okey, so now we have one true hoogle, right? :)
06:02:01 <__monty__> I guess.
06:03:51 <safinaskar> cool! :)
06:06:41 <sshine> I've used haskell.org/hoogle until a few weeks ago, and I haven't noticed a difference. I like that my browser can disambiguate a few characters sooner, though.
06:08:35 <sm[m]> safinaskar: there's also per-snapshot hoogles at https://www.stackage.org
06:08:50 <Rembane> Can you download your own hoogle? 
06:08:53 <Rembane> +and run
06:08:57 <merijn> Rembane: Yes
06:09:01 <merijn> @hackage hoogle
06:09:01 <lambdabot> http://hackage.haskell.org/package/hoogle
06:09:42 <__monty__> Nix makes it super easy to do so with `ghcWithHoogle`.
06:10:09 <__monty__> sshine: The newer hoogle doesn't find some of the matches the old one would.
06:11:03 <Rembane> Nice! 
07:42:52 <bl4ckb0ne> is it posible to have an output from a function that doest involves the IO?
07:45:58 <geekosaur> not really. (there's Debug.Trace but you will get unfortunate surprises if you try to use it for general I/O)
07:46:52 <bl4ckb0ne> that what i went for
07:47:08 <bl4ckb0ne> but i got this `Couldn't match expected type ‘Int’ with actual type ‘a0 -> b0’`
07:48:15 <boxscape> You're going to need to provide a little more context than that if you want people to understand what problem you're having :)
07:48:16 <bl4ckb0ne> or maybe I should do all of my input processing in my main before diving into pure functions
07:48:33 <bl4ckb0ne> yeah sorry, i'll paste my code
07:48:38 <boxscape> generally you should only use Debug.Trace for debugging
07:48:39 <boxscape> hence the name
07:48:42 <geekosaur> use a paste site.
07:49:06 <geekosaur> Debug.Trace will show you how things are actually evaluated. this will probably be a big surprise if you aren't already used to non-strict evaluation
07:49:15 <bl4ckb0ne> https://pastebin.com/iDfVvSHv
07:49:25 <geekosaur> and will definitely be surprised if you try to cheat and slipstream I/O into pure functions
07:49:29 <bl4ckb0ne> i just want to see the output before going forward
07:50:18 <dmwit> Huh, the instances of Applicative and Monad for StateT in C.M.S.Strict don't mention seq or ($!). What gives?
07:50:27 <dmwit> http://hackage.haskell.org/package/transformers-0.5.6.2/docs/src/Control.Monad.Trans.State.Strict.html#line-218
07:50:59 <boxscape> bl4ckb0ne trace is a cheaty "pure" (though not really) function that doesn't reside in the IO monad, so you don't need to use a do block
07:51:08 <tdammers> I'm very much used to non-strict evaluation, and Debug.Trace.trace still surprises me occasionally
07:51:41 <bl4ckb0ne> oh
07:51:48 <bl4ckb0ne> I though do was mandatory for multi lines functions
07:52:08 <boxscape> no, do is syntac sugar for the methods of the Monad class
07:52:14 <boxscape> s/syntax/syntax
07:52:17 <bl4ckb0ne> huh
07:52:17 <boxscape> er
07:52:29 <bl4ckb0ne> good to know
07:52:34 <bl4ckb0ne> works way better, thanks!
07:52:38 <boxscape> np
07:52:46 <bl4ckb0ne> and array looks perfect
07:53:11 <tdammers> boxscape: do blocks aren't needed for IO either. the two are only very loosely related.
07:53:22 <boxscape> air
07:53:25 <boxscape> fair
07:53:56 <tdammers> (and while we're at it, I suggest avoiding the term "IO Monad", it's misleading - IO has a Monad instance, but what's special about IO has nothing to do with Monads)
07:54:14 <boxscape> seems like it's relevant when talking about do notation though?
07:55:21 <yushyin> Monad and do notation? yes.
07:56:11 <bl4ckb0ne> is there something standard to represent 2d lines?
07:56:34 <bl4ckb0ne> or tuple of tuples should be good
07:56:39 <merijn> So any windows people around? What editor do you use for Haskell on windows? Notepad++ seems to not even do basic stuff like "be able to highlight trailing whitespace" >.>
07:56:41 <tdammers> do notation and Monads are intricately related, but IO has little to do with it
07:56:56 <boxscape> merijn why not just use what you use on linux?
07:57:08 <merijn> boxscape: 1) I don't use linux, 2) it's not for me :p
07:57:29 <boxscape> ah, I had assumed from the way the question was phrased :D
07:57:39 <c_my_nick> @merijn, i use sublime text
07:57:40 <lambdabot> Unknown command, try @list
07:57:46 <yushyin> bl4ckb0ne: (x,y) is fine, you could also use the linear library
07:57:49 <merijn> And I'm not gonna go and suggest gvim because I don't wanna deal with the hassle of a divorce >.>
07:58:07 <tdammers> oh, it's for the wife
07:58:11 <yushyin> vscode?
07:58:27 <tdammers> windows people seem to love vscode and sublime text, yeah
07:58:43 <c_my_nick> i dont know if sublime text can highlight trailing whitespace, but it has an auto trim trailing whitespace when you save
07:58:48 <__monty__> True, people who love eachother don't make one another use graphical vim.
07:58:50 <merijn> Guess I'll see if one of those works better
07:59:14 <merijn> __monty__: gvim is fine, I used it for ages on windows and terminal vim isn't really an option there :p
07:59:32 <turion> ghcid is not at all related to ghcide, right?
07:59:46 <__monty__> No.
07:59:47 <merijn> turion: Correct
08:00:30 <merijn> Well, there is some relation, just not one that's particularly relevant
08:00:45 <tdammers> indeed. they are related, but not in a way that you need to know about as a user
08:01:07 <turion> Are they related any other than that they talk with GHC?
08:01:17 <tdammers> https://www.youtube.com/watch?v=cijsaeWNf2E <- this might clear things up
08:01:43 <yushyin> merijn: what material are you going to give your wife for learning haskell?
08:02:15 <turion> thanks!
08:03:21 <merijn> yushyin: She read through about 80% of Haskell from First Principles last year, now it's mostly JIT links to relevant tutorials/blogposts/papers ;)
08:03:43 <yushyin> ah ok
08:03:44 <c_my_nick> i didnt think haskell was well supported on windows.  i run a unix virtual machine running samba and mount it as a network drive so i can use my windows editor
08:04:09 <merijn> c_my_nick: What makes you say that?
08:04:56 <alx741> hello all. I'm using ghcup, when installing xmonad with `cabal v2-install xmonad`, `ghc-pkg recache && ghc-pkg list xmonad` says there is no such package, what I am missing?
08:04:56 <merijn> The wider ecosystem tends to be a bit *nix focussed, but windows is still a tier 1 supported platform for GHC. Which it will probably remain as long as SPJ works on GHC :p
08:05:06 <c_my_nick> thats the impression i got several years ago, i live under a rock so i dont know if things have changed since then :p
08:05:27 <merijn> alx741: v2-install doesn't install into the "default" package database
08:06:19 <alx741> merijn: `cabal install xmonad` gives the same result though :/ (is that what you mean?)
08:07:01 <boxscape> I've started using nix+haskell in the windows subsystem for linux, which works great, though I imagine it's not a great solution for deploying for windows
08:07:08 <__monty__> Depending on your cabal version that could be the same command.
08:07:10 <merijn> alx741: Which version of cabal-install?
08:07:14 <merijn> alx741: 3.0 by any chance?
08:07:17 <boxscape> or is it the linux subsystem for windows
08:07:44 <alx741> oooh... you're right! 
08:07:50 <alx741> yes, 3.0.0.0 
08:08:01 <merijn> alx741: In 3.0 all the non-prefixed commands are v2-
08:08:20 <merijn> alx741: Also, are you sure you really need/want to install xmonad globally?
08:08:31 <geekosaur> mod-q is godawful slow otherwise
08:09:05 <boxscape> oh that reminds me I wanted to see if I can install xmonad in windows' linux subsystem, hmm
08:09:20 * geekosaur tried doing it right for a bit, then gave up because laptop on battery and waitiing several minutes for xmonad to finish rebuilding on startup because buildscripts can't test whether it's needed was no go
08:09:46 <geekosaur> so xmonad is back to v1-install and staying there
08:10:04 <__monty__> Sounds like nix could help there.
08:10:17 <merijn> I don't use xmonad, tbh, so I'm not sure what makes the buildscript recompile eachtime
08:10:22 <alx741> v1-install did it :) , merijn: A better option would be to have a cabal file for building my xmonad.hs, but was stumped about cabal not actually installing the package
08:10:35 <alx741> what does v2-install/install does then?
08:10:41 <geekosaur> xmonad checks for recompile on startup because you might have upgraded xmonad or xmonad-contrib or ghc in the meantime
08:10:51 <merijn> alx741: It installs into the global store
08:11:13 <geekosaur> but the buildscript assumes the build manager will do the check. which it does (cabal, here) but it's much slower and heavier weight than the built-in check
08:12:00 <merijn> geekosaur: The cabal check is actually really fast IFF there's no rebuilding, so presumably the problem here is that intermediate updates trigger a rebuild due to changed buildplan
08:12:16 <geekosaur> but nothing changes
08:12:28 <alx741> merijn: Don't really understand how is it different... global store vs default package db (?)
08:12:38 <merijn> geekosaur: It's really slow despite no rebuild?
08:12:40 <geekosaur> there's no default package db with v2
08:12:44 <geekosaur> merijn, yes
08:12:52 <alx741> geekosaur: that's what I would like to end up with
08:13:01 <merijn> geekosaur: On all projects, per chance?
08:13:26 <geekosaur> v2 is generally fast afterward, so I think it's because nothing is cached or something
08:13:35 <merijn> geekosaur: I suspect I may know the problem
08:13:57 <geekosaur> ghc is a little slow to start but that would affect v1 builds as well
08:14:24 <merijn> geekosaur: Can you tell me what you get if you run "echo $PKG_CONFIG_PATH"?
08:14:31 <alx741> mmh got it, will try to have a cabal file for this, thanks guys!
08:15:06 <geekosaur> alx741, v2 installs things to internal caches and builds a custom package db for anything you build. v2-install only installs executables, which breaks xmonad's mod-q because libs aren't globally installed
08:15:41 <geekosaur> there's a way to "install" libraries but it writes .ghc-environment files; I wasn't able to get that working on a quick attempt, but it's a bit difficult to experiment currently
08:15:45 <geekosaur> merijn, it's empty
08:16:09 <merijn> geekosaur: Completely empty string, no colons?
08:16:37 <geekosaur> no colons
08:16:41 <merijn> hmm
08:16:46 <merijn> ok, so not the issue I had
08:17:08 <geekosaur> hilfy Z$ echo "x${PKG_CONFIG_PATH}x"xx
08:17:26 <geekosaur> bah, this thing compresses out newlines on send
08:17:37 <geekosaur> hilfy Z$ echo "x${PKG_CONFIG_PATH}x"
08:17:38 <geekosaur> xx
08:18:00 <merijn> geekosaur: I had really big slowdowns with the v2 recompilation check that would always run, took me 2 weeks and a whole bunch of obscure unix trivia to debug >.<
08:19:53 <merijn> End conclusion: Sysadmins were constructing PKG_CONFIG_PATH via blindly doing PKG_CONFIG_PATH="foo:$PKG_CONFIG_PATH", which, in case of an empty PKG_CONFIG_PATH, results in a trailing colon
08:19:56 <massudaw_> Does anyone know if Integer data type stores it's representation in PINNED memory, my application is having high residency problems due to I think fragmentation and we rely heavily in Integer. 
08:20:23 <merijn> Fun random unix trivia: leading/trailing colons are considered equivalent to CWD
08:21:17 <merijn> So if the access time of CWD had changed it'd trigger a rescan for pkg-config related executables, resulting in a rebuild v2-cache, which was super slow
08:21:41 <merijn> geekosaur: I'd audit the common path variables for trailing/leading colons and (if you find any) see if removing those improves the recompilation check
08:22:10 <merijn> (LIBRARY_PATH, INCLUDE_PATH, those sorta things)
08:23:10 <geekosaur> I refuse to set most of those and have a scan-and-optimize for $PATH itself (remove nonpresent directories, compress out empties because they mean rescan .)
08:23:41 <geekosaur> scan-and-optimize happens when debianoid X11 startup sources my .profile
08:32:20 * hackage tmp-postgres 1.31.0.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.31.0.0 (JonathanFischoff)
08:32:46 <dminuoso> Mmm, why is there no `traverseKeys :: (Applicative f, Ord k2) => (k1 -> f k2) -> Map k1 a -> f (Map k2 a)
08:41:11 <dmwit> I suspect because it can't be done more efficiently than the obvious user-level implementation of converting to a list, traversing that, and converting back.
08:41:25 <dmwit> ...and because it's a pretty uncommon need.
08:41:34 <dminuoso> Fair enough
08:44:36 <dminuoso> dmwit: I admit, my use case is a bit edgy. Im loading up large amounts of data from a relational database in such a way, that the queries are highly efficient - but they dont match the structure I need very well.
08:48:50 * hackage ucd 0.0.1.1 - Unicode Character Database — Predicates on characters specified by Unicode  https://hackage.haskell.org/package/ucd-0.0.1.1 (MatthewFarkasDyck)
08:50:21 * hackage spacecookie 0.2.1.1 - Gopher Library and Server Daemon  https://hackage.haskell.org/package/spacecookie-0.2.1.1 (sternenseemann)
08:51:03 <nibburg> I have a question regarding sharing of partially applied functions.
08:51:12 <nibburg> My code is here https://gist.github.com/nbun/a601ed0a964ab08649775e83db4f88cf
08:52:04 <nibburg> When the functions f1 and f2 are shared, the traced argument is not shared. For f3 and f4, the argument is shared, however.
08:52:51 <nibburg> Compiled without optimizations, the first two options are lambda functions while the latter to are partially applied functions.
08:53:12 <nibburg> Does anyone know why the arguments are not shared in the first case? Is is just because of the lambda functions?
09:09:36 <zincy_> How do you insert a null field with postgres-simple?
09:10:19 <dminuoso> zincy_: Use the Maybe type and produce Nothing.
09:10:37 <dminuoso> zincy_: There's also an explicit Null type if you dont have any value ever.
09:13:13 <zincy_> dminuoso: When I try to put a Just $ T.pack "hello" in a field I get the compiler message saying expected a Text where there was a Maybe Text
09:13:37 <zincy_> This is where my Maybe Text value is a parameter in the `execute` function
09:15:34 <zincy_> dminuoso: https://pastebin.com/vVxngD1x
09:15:48 <amx> using Maybe works for reading at least
09:15:59 <zincy_> amx: Yeah works for me
09:16:03 <zincy_> when reading
09:16:50 <amx> (and writing records)
09:21:30 <amx> hmm, does the error go away if you use a tuple instead of a list as the container for parameters?
09:22:09 <hyperisco> If Int# has kind #, and Int has kind Type, what is the kind of -> ?
09:23:06 <zincy_> amx: Yes! Thanks
09:23:35 <zincy_> amx: *sends virtual coffee*
09:24:57 <amx> thanks, I was all out anyway
09:35:51 <zincy_> postgres-simple is so much better than using an orm.
09:36:06 <zincy_> As someone said here relational algebra and lambda calculus dont meld nicely
09:38:10 <heatsink> Now I wonder how datafun relates to relational algebra
09:39:25 <dminuoso> zincy_: Just a hygiene tip: FromRow and ToRow are sort of evil.
09:40:16 <zincy_> dminuoso: In the way of marshalling values between types is always brittle? Is there an alternative? 
09:40:37 <dminuoso> zincy_: Its not brittle, it's just messy because it forces you to always create a data type for every query you make.
09:40:59 <zincy_> dminuoso: Yeah I thought that might happen
09:41:16 <zincy_> data MySalesGroupedByWeek etc 
09:41:55 <dminuoso> zincy_: You can use `toField` and `field` directly
09:42:17 <dminuoso> You can also use the various predefined tuple instance
09:43:01 <zincy_> dminuoso: Isn't to field limited in usefulness to queries which return one column
09:43:18 <dminuoso> zincy_: No?
09:43:31 <dminuoso> zincy_: it has a monad instance.
09:43:38 <dminuoso> That is, RowParser has one
09:44:20 <zincy_> How would I go about returning a tuple of 2 arity where each value is a product type?
09:44:53 <zincy_> Say (Person, OtherProdType )
09:44:55 <dminuoso> (,) <$> field <*> field
09:44:58 <dminuoso> Oh well
09:45:11 <dminuoso> (,) <$> person <*> someOther
09:45:13 <zincy_> So that is where fromField would come in handly
09:46:24 <c_my_nick> if Person and OtherProdType both have fromRow instances, your query can return a (Person :. OtherProdType)
09:46:52 <dminuoso> zincy_: My point is, its no different than say parser combinators or IO..
09:47:29 <dminuoso> I dont particularly like the FromRow/ToRow instances, because they suggest that this type can only have one exact column representation for any given query that produces this data
09:48:34 <dminuoso> Plus, because circular module dependencies are a mess, it presents annoyances like your `Foo.Types` carrying the FromRow instance, but where do you place your query that produces matching values? In your Foo.Types? In a different module?
09:48:58 <dminuoso> Somehow I feel that FromRow should have an additional method `Proxy a -> Query`
09:50:15 <zincy_> Thanks that helps
09:50:28 <zincy_> I think I understand the usefulness of to and from field now
09:51:03 <zincy_> FromRow is just using the applicative instance over all your fields
09:51:24 <zincy_> If it has a monad instance then I am confused
09:51:35 <zincy_> Because I dont know what that would look like
09:52:45 <c_my_nick> generally speaking, most of my database entities have a single representation.  at the worst, i am only having to select a couple extra columns for the purpose of filling up the type
09:53:27 <dminuoso> c_my_nick: It separates the code that produces the data from the rowparser. 
09:53:34 <dminuoso> For no good reason eiter.
09:53:44 <c_my_nick> if i have cases where i regularly only need a small subset of columns, i split the type
09:53:52 <dminuoso> Its not like the FromRow/ToRow typeclasses buy you functionality that you couldn't obtain with a simple.... binding...
09:54:09 <Ariakenom> Does anyone have a info on the work on providing traps for floats?
09:54:21 <dminuoso> Instead what now happens, if you have two different queries you start introducing newtypes just for the purpose of selecting the queries.
09:54:30 <dminuoso> You get all the quirks and effects of abusing typeclasses for something they are not made for
09:57:12 <c_my_nick> i find that it makes code easier to read.  because the alternative to not having a ToRow is pretty unwieldy.
09:57:54 <zincy_> This might be more a postgres thing but
09:58:20 <zincy_> What is the general way of denoting success/failure for an update query?
09:58:35 <dminuoso> c_my_nick: Have you ever used parser combinators?
09:59:11 <c_my_nick> @zincy_, there are 2 types of failures:  constraint violations or no records matched (in the case of an update)
09:59:11 <lambdabot> Unknown command, try @list
09:59:33 <c_my_nick> dminuoso, yes
10:01:31 <zincy_> c_my_nick: Hmm not sure how I would deal with a no records matched
10:02:10 <c_my_nick> execute returns an Int64 of the number of records found
10:02:11 <zincy_> Perhaps return the id field wrapped in a Maybe and return Nothing if no records matched for the update
10:02:19 <zincy_> ahh thanks
10:03:03 <c_my_nick> for my own personal apps, i mostly ignore the no matches case and only care about the constraint violations
10:04:29 <zincy_> Is it not better to tell the client that the thing they are trying to update doesnt exist?
10:04:50 <heebo> http://www.willamette.edu/~fruehr/haskell/seuss.html
10:05:23 <c_my_nick> sure, but after the update, i return them to the page containing the thing they updated... so its kinda obvious if it wasnt found :p
10:05:26 <koz_> heebo: Lol.
10:15:51 * hackage haskoin-store 0.18.9 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.18.9 (xenog)
10:20:41 <seishun> given `[(a, b)]`, how do I get `Map a (Set b)`? is there a way that doesn't involve Set.singleton?
10:21:36 <amalloy> seishun: how could it not involve singleton? given [(1,2)], your end result will have a singleton set in it, which has to come from somewhere
10:21:37 <glguy> If you wanted to, you could make a Map a [b] first, and then fmap Set.fromList
10:22:25 <seishun> I'd have to use (++) to make a Map a [b], right?
10:22:52 <glguy> No, you wouldn't have to; you could.
10:22:55 <ammar2> no? you can't just put it on the head
10:23:03 <glguy> I don't really understand the game we're playing though
10:34:15 <seishun> glguy: what would be the other way?
10:34:36 <glguy> using (:) to add elements to the front
10:34:44 <glguy> but using ++ is fine when you're adding singleton lists with it
10:34:54 <glguy> (as long as you're adding them on the front)
10:35:20 * hackage tree-sitter 0.7.0.0 - Unstable bindings for the tree-sitter parsing library.  https://hackage.haskell.org/package/tree-sitter-0.7.0.0 (tclem)
10:35:39 <seishun> I can't quite see how one would insert with (:) to a Map
10:36:49 <glguy> There are a lot of ways to update a Map
10:37:45 <amalloy> you could fold over the list, accumulating a map, and use insertWith or alter at each step
10:39:50 * hackage tree-sitter-java 0.6.0.0 - Tree-sitter grammar/parser for Java  https://hackage.haskell.org/package/tree-sitter-java-0.6.0.0 (tclem)
10:44:21 * hackage tree-sitter-python 0.8.0.0 - Tree-sitter grammar/parser for Python  https://hackage.haskell.org/package/tree-sitter-python-0.8.0.0 (tclem)
10:47:20 * hackage tree-sitter-go 0.3.0.0 - Tree-sitter grammar/parser for Go  https://hackage.haskell.org/package/tree-sitter-go-0.3.0.0 (tclem)
10:50:20 * hackage tree-sitter-json 0.5.0.0 - Tree-sitter grammar/parser for JSON  https://hackage.haskell.org/package/tree-sitter-json-0.5.0.0 (tclem)
10:52:21 * hackage tree-sitter-ruby 0.3.0.0 - Tree-sitter grammar/parser for Ruby  https://hackage.haskell.org/package/tree-sitter-ruby-0.3.0.0 (tclem)
10:53:20 * hackage tree-sitter-tsx 0.3.0.0 - Tree-sitter grammar/parser for TSX  https://hackage.haskell.org/package/tree-sitter-tsx-0.3.0.0 (tclem)
10:54:50 * hackage tree-sitter-typescript 0.3.0.0 - Tree-sitter grammar/parser for TypeScript  https://hackage.haskell.org/package/tree-sitter-typescript-0.3.0.0 (tclem)
11:05:51 <jle`> seishun: you can avoid it using fmap ($ []) $ M.fromListWith (.) [ (x,(y:)) | (x,y) <- xs ]
11:06:07 <jle`> seishun: but i don't really see a reason to do so
11:06:25 <jle`> seishun: also i don't really see a good reason for avoiding using Set.singleton, but if you can use Set, you can do
11:06:42 <jle`> M.fromListWith (<>) [ (x, S.insert y S.empty) | (x,y) <- xs ]
11:06:51 <jle`> that way avoids Set.singleton by inserting into an empty set
11:21:40 <jpcooper> Is there a general function that covers Data.Maybe ( catMaybes )?
11:23:05 <dsal> What do you mean?
11:23:10 <dsal> :t catMaybes
11:23:14 <lambdabot> [Maybe a] -> [a]
11:23:29 <dsal> > catMaybes [Just 1, Nothing, Just 2]
11:23:33 <dsal> That's kind of like sequenceA
11:23:34 <lambdabot>  [1,2]
11:23:41 <dsal> Except for being more special.
11:23:53 <dmwit> % :set -XNoDeriveTraversable -XGeneralizedNewtypeDeriving
11:23:53 <yahb> dmwit: 
11:23:57 <dmwit> % data Foo a = Foo (IM.IntMap a) deriving Traversable
11:23:58 <yahb> dmwit: ; <interactive>:58:41: error:; * Can't make a derived instance of `Traversable Foo': You need DeriveTraversable to derive an instance for this class; * In the data declaration for `Foo'
11:24:11 <dmwit> Why isn't GND good enough?
11:24:53 <dmwit> jpcooper: wither
11:25:01 <jpcooper> dsal: It is not sequenceA, as I want a [a] and not Maybe [a]
11:25:24 <dmwit> It's not like sequenceA at all...
11:26:52 <dmwit> jpcooper: You might also consider:
11:26:59 <dmwit> :t \f -> asum . map f
11:27:00 <lambdabot> Alternative f => (a1 -> f a2) -> [a1] -> f a2
11:31:50 * hackage filepath-bytestring 1.4.2.1.0 - Library for manipulating RawFilePaths in a cross platform way.  https://hackage.haskell.org/package/filepath-bytestring-1.4.2.1.0 (JoeyHess)
11:32:38 <jpgarcia> Hi guys. I work on a library implemented using a lot of type level programming (extensible records et al). I have discovered some performance issues at compile time with certain use cases. It would be nice to have a way to benchmark my compilation, to know which type families are computing slow and that kind of thing. Is there a way to do that? 
11:33:51 * hackage diagrams-svg 1.4.3 - SVG backend for diagrams drawing EDSL.  https://hackage.haskell.org/package/diagrams-svg-1.4.3 (BrentYorgey)
12:21:24 <merijn> cocreature: The TH bits seem to work (or rather, I no longer get an error), but I seem to have merely discovered more broken things :p
12:44:09 <merijn> hmmm, anyone care to wager why ghci would be unable to find stat64 of all thing?
12:44:50 * hackage tree-sitter-ruby 0.3.1.0 - Tree-sitter grammar/parser for Ruby  https://hackage.haskell.org/package/tree-sitter-ruby-0.3.1.0 (tclem)
12:54:04 <merijn> Man...I wish github had an easy way to see which issues you subscribed too
12:55:35 <dsal> I was just trying to find my own bugs in my own projects recently...
12:58:41 <sm[m]> merijn: it does.. saw it the other day
12:59:08 <merijn> sm[m]: I can only find issues I've commented or been assigned, not subscribed
13:00:01 <sm[m]> Hmm
13:45:37 <zeta_0> how would i translate this code into haskell? https://gist.github.com/zeta-00/28fddea5506c4f04f1e69c250764c0c4
13:46:04 <zeta_0> maximum a b c = body
13:46:27 <zeta_0> i am not sure about the body part
13:48:23 <davve> i would make it a function, using pattern matching (sorry for not being able to give you a better/full answer, i am a noob also :))
13:50:02 <zeta_0> i want to do i using if then else expressions first then translate it to gaurds using pattern matching?
13:50:08 <Rembane> zeta_0: You can do that thing using if-then-else expressions or you can use guards. 
13:50:23 <solonarv> eh, sticking to if/then/else is actually fine
13:50:30 <solonarv> I think I'd even prefer it here
13:50:42 * Noughtmare[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/UScNADlhSJorvpLAjnhOljkp >
13:50:45 <zeta_0> Rembane: i am just not sure how to use nested if expressions
13:51:38 <zeta_0> Noughtmare[m]: thanks
13:52:10 <solonarv> yeah, there is no great secret to ot
13:52:13 <solonarv> *it
13:53:04 <aplainzetakind> Is there something like this: Monad m => m a -> (a -> m b) -> m (a, b)
13:53:25 <Rembane> aplainzetakind: Where do you get the b from? 
13:53:44 <Rembane> Oh
13:53:46 <Rembane> Sorry
13:54:04 <solonarv> zeta_0: left a comment on your gist showing how I usually format if/then/else expressions
13:54:23 <solonarv> aplainzetakind: I am not aware of it being defined anywhere
13:54:34 <Rembane> do; a' <- a; b' <- f a'; pure (a',b')
13:55:08 <solonarv> the ; immediately after do is unnecessary :>
13:55:19 <zeta_0> solonarv: that code is much cleaner and easier to understand, thanks
13:55:25 <Rembane> solonarv: I did it for good luck. ^^
13:55:33 <aplainzetakind> Easy to do with do notation but perhaps there's a fancy combinator or two that can achieve this without 'looking inside'.
13:56:14 <solonarv> yes, using arrows
13:56:37 <Rembane> aplainzetakind: sequence . (id &&& f) . (=<< a)
13:57:18 <aplainzetakind> Nice, I should get used to these I guess.
13:57:29 <solonarv> % :t flip \f -> runKleisli (Control.Category.id &&& Kleisli f)
13:57:30 <yahb> solonarv: ; <interactive>:1:6: error:; Unexpected lambda expression in function application:; \ f -> runKleisli (Control.Category.id &&& Kleisli f); You could write it with parentheses; Or perhaps you meant to enable BlockArguments?
13:57:39 <solonarv> -.- really now
13:57:49 <solonarv> % :set -XBlockArguments
13:57:49 <yahb> solonarv: 
13:57:52 <solonarv> % :t flip \f -> runKleisli (Control.Category.id &&& Kleisli f)
13:57:52 <yahb> solonarv: Monad m => a -> (a -> m c') -> m (a, c')
13:58:39 <solonarv> % :t flip (runKleisli . (Control.Category.id&&&) . Kleisli) -- point free!
13:58:39 <yahb> solonarv: Monad m => a -> (a -> m c') -> m (a, c')
13:59:31 <solonarv> aplainzetakind: what do you think? :>
14:00:08 <Rembane> aplainzetakind: Or don't get used to the arrow notation and use some lambdas instead. :)
14:00:46 <solonarv> <pedant>that's not arrow notation</pedant>
14:00:50 <xenon-> I like (&&&)
14:01:05 <solonarv> yes, there are a few nice operators in there
14:01:06 <aplainzetakind> solonarv: I think I need to learn Arrow.
14:01:23 <solonarv> (&&&), (***), first/second are the main ones
14:01:39 <solonarv> although often first/second from Bifunctor are more practical
14:01:42 <sim590> I have a problem where I have to find the minimal string (called mchaine) that has some property. I'm using a breadth-first approach: https://paste.debian.net/1120572/. The code is really readable (see function btMChaine). I don't get why I don't get the optimal solution even though I think that the expresison I wrote does breadth-first search. I'm not sure though due to some order of evaluation
14:01:43 <sim590> default in haskell that I'm confusing.
14:02:57 <xenon-> can you give an example of using (***)?
14:03:09 <solonarv> oh, I don't use it often
14:03:23 <sim590> In my mind `head $ solutions ++ map go nextCandidates` should give the optimal solution since it takes the first element of some infinite list that is constructing in breadth-first manner, no?
14:03:28 <solonarv> basically it is just: f *** g = \(x,y) -> (f x, g x)
14:03:38 <solonarv> I mean *f x, g y)
14:03:56 <sm[m]> merijn: isn't https://github.com/notifications/subscriptions it ?
14:04:18 <Ariakenom> Does anyone have a info on the work on providing traps for floats? merijn?
14:04:25 <xenon-> > (*10) *** (*100) (1,2)
14:04:28 <lambdabot>  error:
14:04:28 <lambdabot>      • Couldn't match expected type ‘(b, c)’
14:04:28 <lambdabot>                    with actual type ‘Integer -> Integer’
14:04:48 <xenon-> -querz lambdabot
14:04:51 <xenon-> :/
14:05:13 <xenon-> > ((*10) *** (*100)) (1,2)
14:05:16 <lambdabot>  (10,200)
14:05:58 <zeta_0> the code throws an error when i call the function and pass it 3 args in ghci!
14:06:01 <zeta_0> maximum a b c =
14:06:01 <zeta_0>   if a > b
14:06:01 <zeta_0>      then if a > c
14:06:01 <zeta_0>              then a
14:06:01 <zeta_0>              else c
14:06:01 <zeta_0>      else if b > c
14:06:01 <zeta_0>              then b
14:06:02 <zeta_0>              else c
14:06:29 <amalloy> sim590: that looks depth first to me
14:06:32 <solonarv> "throws an error" is very unspecific
14:06:36 <solonarv> what kind of error?
14:06:58 <solonarv> also, please do not dump 5+ lines of code straight into IRC
14:07:44 <zeta_0> solonarv: https://gist.github.com/zeta-00/28fddea5506c4f04f1e69c250764c0c4
14:07:54 <amalloy> you first see if any of the nodes at the current level generate a solution, and if so yield it. fine so far. then you call go, a function which returns all the solutions for a node. you call this on each node at the current level, and look at the first one that yields a solution
14:08:18 <jared-w> that code is very different than what you just pasted into the irc
14:08:19 <amalloy> if the leftmost node in your current tree has any solutions nested at any depth within it, you will look at that solution before you look at a solution in your rightmost node
14:08:43 <geekosaur> that would be expected, since there's already a `maximum` defined. which is what the error is telling you
14:08:46 <dsal> > maximum [3, 5,1]
14:08:49 <lambdabot>  5
14:09:14 <geekosaur> so it's saying to specify whether you want Prelude.maximum (the existing one) or Main.maximum (yours)
14:09:18 <zeta_0> oh, i forgot so i need to define it as maximum'  ?
14:09:25 <geekosaur> or rename it, yes
14:09:43 <dsal> Call it macksimon
14:09:47 <zeta_0> thanks
14:10:17 <xenon-> maximum' a b c = maximum [a,b,c]
14:10:18 <sim590> amosbird: How so? So, a level in the tree, is all the combination of valid numbers appended to the dual string. For instance, at level 1, one can add only the number 0. Then, at level 2, one can add either 0 or 1, so there's [0,0] and [0,1] as possibilities. You agree ?
14:14:34 <sim590> I guess that it's harder to see when you don't know the whole picture, but I think that nextCandidates should give a whole level before going to the children.
14:16:54 <zeta_0> it finally works, thanks guys:
14:16:58 <zeta_0> maximum' :: Ord a => a -> a -> a -> a
14:16:58 <zeta_0> maximum' a b c =
14:16:58 <zeta_0>   if a > b
14:16:58 <zeta_0>      then if a > c
14:16:58 <zeta_0>              then a
14:16:58 <zeta_0>              else c
14:16:58 <zeta_0>      else if b > c
14:16:59 <zeta_0>              then b
14:17:00 <zeta_0>              else c
14:19:29 <amalloy> zeta_0: as solonarv says, please do not paste giant clips into irc. glad you have it working
14:20:06 <EvanR> hmm isn't maximum' a b c = max a (max b c)
14:20:38 <ephemient> maximum' = (. max) . (.) . max
14:20:43 <EvanR> i.e. 1/8 of the lines
14:21:19 <EvanR> yeesh at that point free version
14:22:18 <zeta_0> i was just trying to translate a nested if then else  algorithm(pseudocode) to haskell
14:22:56 <fendor> any hints what this stack error message might indicate? https://gist.github.com/fendor/7d84f19b0a647567f9bce5130c17cc63 It only happens in CI
14:23:15 <zeta_0> i didn't think that piece of code was that long, but okay, from now on i'll pastebin
14:24:17 <zeta_0> anyways will translating that code into a guard expression be difficult?
14:25:55 <solonarv> not particularly, but it will be annoying
14:26:51 <zeta_0> ahh, am not sure where to start
14:26:57 <ephemient> maximum' a b c | a > b, a > c = a | a > b = c | ...
14:27:00 <ephemient> why would you, though
14:27:13 <amalloy> how am i just learning today that you can put commas in guard clauses
14:27:41 <Clint> same
14:28:26 <amalloy> i wonder why that feature was added, when && works fine too
14:28:45 <ephemient> [ x | x <- [1..100], x `mod` 3 == 0, x `mod` 5 == 0 ] -- consistent with list comprehensions
14:28:45 <sim590> amalloy: I think you're right. I've just made a trace in comments and I think that this gives this: https://paste.debian.net/1120575/. And that as soon as we reach i=2, the approach really shows to be depth first search
14:28:58 <ephemient> also pattern guards are a thing
14:29:22 <fendor> pattern guards are great, but look hilarious with case expressions
14:29:33 <sim590> amalloy: even i=1. Yeah, I really didn't understand that it wasn't breadth-first search.
14:29:42 <amalloy> sim590: to do BFS you kinda need a queue to exist somewhere
14:29:49 <ephemient> case | <- ->
14:29:54 <fendor> > (case x of x | Just y <- x -> y) (Just 3)
14:29:57 <lambdabot>  error:
14:29:57 <lambdabot>      • Couldn't match expected type ‘Expr’
14:29:57 <lambdabot>                    with actual type ‘Maybe (Maybe Integer -> t)’
14:30:03 <amalloy> if you rely on the stack to hold your intermediate values, then you're using a stack instead of a queue, and you'll wind up with DFS
14:30:08 <dsal> zeta_0: It's a little weird to translate that code.  One wouldn't write that in haskell.
14:30:38 <sim590> amalloy: Yeah, my book suggests that, but I didn' know what was the actually way to do this in Haskell. I guess I could use the list as a queue. I just shouldn't do a map on the list since I don't control the order in which cases are checked.
14:31:10 <amalloy> using a list as a queue works fine for reasonable numbers of nodes, or you could use Data.Sequence to get an efficient queue
14:31:51 <dsal> I used Data.PQueue last year.
14:32:01 <ephemient> if you wanted to build your own, two lists for a deque is amortized O(1)
14:32:17 <dsal> That's a neat algorithm.
14:33:56 <sim590> Oh right since lists are only singly linked lists, right ?
14:34:28 <solonarv> yes
14:34:36 <ephemient> building a doubly-linked list in Haskell is possible, but not very useful
14:34:40 <sim590> We don't have a pointer to the end of the list, so haskell joins two lists in O(n) operations, righ?
14:35:00 <ephemient> well... it's lazy
14:35:19 <solonarv> even if we had a pointer to the end, it would not help
14:35:25 <solonarv> because we are not allowed to mutate it
14:35:31 <sim590> right.
14:35:47 <ephemient> > head $ [1] ++ repeat 0
14:35:51 <lambdabot>  1
14:35:56 <ephemient> O(1) instead of O(infinity) :)
14:36:08 <sim590> solonarv: but in the background, doesn,t haskell optimize this by mutating lists if it knows it can?
14:36:21 <solonarv> no, it does not
14:36:22 <ephemient> nope
14:36:28 <ephemient> there's list fusion though
14:36:38 <sim590> ephemient: Yeah. That was my idea behind the line I used with `head` since the list I'm building is infinite
14:36:39 <solonarv> yes, which makes the intermediate lists never exist at all
14:39:13 <dexterfoo> Hello. is this website considered a literate program? https://pomb.us/build-your-own-react/
14:40:38 <sim590> Am I forced to pass the list (queue) in parameter of `go` or is there a more neat way to write it?
14:46:07 <argent0> Hi, is there a container with O(1) lookups, and O(1) updates? Data.Array.IArray.// is O(n), Data.Vector.update is O(n+m) and Data.Seq.adjust' is O(log(n)).
14:46:21 <argent0> diffarray is IO
14:46:54 <argent0> I'm looking to map Int to Int
14:47:55 <dsal> If mutable arrays work for you, there are mutable arrays.  Your constraints are pretty difficult, though.
14:48:06 <solonarv> argent0: there is no such immutable data structure
14:48:19 <solonarv> those cannot get better than O(log n)
14:49:03 <xenon-> immutability wasn't part of the requirement
14:49:04 <solonarv> well, there is no such immutable data structure *that is built from algebraic data types*
14:49:32 <solonarv> yes, I am implying that to get these performance characteristics you do not have a choice: you *must* use a mutable data structure
14:49:40 <xenon-> yeah
14:50:03 <dsal> solonarv: I did end up implementing my virtual memory in my mutable array ST thingy.  http://public.west.spy.net/tmp/computer.html
14:50:11 <argent0> OK, thanks for the insight
14:50:51 <argent0> solonarv: is there a theorem for that? (< solonarv> those cannot get better than O(log n))
14:51:08 <solonarv> yes, actually
14:51:13 <solonarv> let me see if I can find it
14:52:14 <solonarv> "Purely Functional Data Structures" by Chris Okasaki: https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
14:52:40 <solonarv> the result is from that thesis
14:54:33 <ephemient> dsal: I switched to vector so it works in either IO or ST (both are PrimMonad), https://github.com/ephemient/aoc2019/blob/hs/src/Intcode/Vector.hs
14:54:50 <solonarv> dsal: oh that is quite the difference
14:55:54 <merijn> solonarv: Eh, Okasaki's observation is an upperbound on immutable data structures (i.e. immutable solutions are *at most* O(log n) less efficient, not *at least*)
14:56:15 <dsal> ephemient: that's pretty neat.  I just duplicated a bunch of code for a map/immutable version and a ST/mutable array version.  heh
14:58:38 <solonarv> merijn: ah, seems I misremembered it
14:58:47 <solonarv> I'm not sure if I ever actually read it, tbh
15:05:51 <jared-w> merijn: _is_ there an immutable structure that has O(1) update and lookup, then?
15:06:32 <jared-w> everything I've seen so far is "morally constant *coughitslogncough*"
15:06:48 <solonarv> I'm not aware of one
15:07:46 <amalloy> sim590: you can do various clever things which all eventual boil down to making the queue a parameter of go
15:08:04 <solonarv> in practice, I usually just end up reaching for Map or IntMap
15:08:11 <amalloy> the most obvious being, do it in State (Queue Node)
15:08:32 <solonarv> (they are both logarithmic, but IntMap only accepts Int keys and is faster on some operations)
15:11:48 <jared-w> There's also edwardk's unpacked-containers which I've been wanting to find an excuse to try out: https://hackage.haskell.org/package/unpacked-containers
15:12:08 <solonarv> ah right, that thing
15:12:11 <solonarv> backpack still scares me
15:12:38 <jared-w> don't worry, there's an easily digestible book-sized thesis if you wanna get up to speed :p
15:13:09 <solonarv> snrk
15:13:32 <jared-w> https://people.mpi-sws.org/~skilpat/papers/kilpatrick-thesis-nov-2019-publication.pdf
15:14:01 <solonarv> oh, wasn't this posted on the sbureddit recently?
15:14:15 <jared-w> yup
15:15:36 <jared-w> https://plv.mpi-sws.org/backpack/ this is the more digestible version if you don't wanna swim through all 240ish pages of that, and the https://www.reddit.com/r/haskell/comments/e7gopg/new_haskell_phd_thesis_on_backback_foundations/ thread had some links that were probably more approachable than that
15:17:13 <zeta_0> what is the best/standard haskell library for coding guis?
15:17:37 <solonarv> hmm
15:17:44 <zeta_0> when i search the internet i get a bunch of options and don't know which ones to choose
15:17:50 <solonarv> there isn't really a standard or best choice, afaik
15:17:54 <jared-w> zeta_0: there's a thread on this every 2-3 months or so on reddit. The consensus is "they all suck" but some people have a version of suck they're particularly fond of
15:18:06 <solonarv> yeah that's about it
15:18:45 <zeta_0> are they at least improving? last time a did a bunch of gui programming was with java years ago
15:18:58 <jared-w> https://www.reddit.com/r/haskell/comments/djt7s2/yearly_obligatory_gui_question/ this is the latest one
15:19:32 <jared-w> And yes, they are, but GUI programming in a language that doesn't map cleanly to OO is very painful because nobody has the hours and money required to re-invent the wheel enough to keep up with QT and/or GTK
15:20:11 <jared-w> outside of those two, the other options are either macOS specific or Windows specific and the OS specialized platforms are essentially the only way to go for "truly native" feeling apps.
15:20:38 <jared-w> Then of course there's stuff like react native, java spring, and a couple other "almost sorta kinda good enough-ish" things that stay alive
15:20:40 <solonarv> the little bit of FRP I have tried felt very nice conceptually, but definitely needs some improvements in usability etc.
15:21:30 <zeta_0> oh so the problem is manpower, i think when functional programming becomes more mainstream these things will improve
15:21:52 <jared-w> But ultimately GUIs are a completely unsolved problem and it's bad enough that people largely tend to resort to shipping a web app inside a sandboxed browser (a la electron) rather than use a native library. It performs well enough and solves the cross platform UI better than anything else so far, which is equal parts pathetic and amazing
15:23:29 <zeta_0> then there's web-assembly but i don't think that is going to be ready for at least a couple years
15:23:59 <zeta_0> haskell_web-assembly integration that is
15:24:11 <dansho> is immediate mode gui not practical in haskell? i can't find any libraries on hackage
15:24:16 <jared-w> Doesn't solve anything GUI related, it's just an intermediate language that people can target instead of treating JS like the intermediate language. The GUI libraries and ecosystems themselves still need to use it
15:25:35 <zeta_0> ' anyways thanks for the input guys
15:26:45 <dsal> The only time I've had any good luck in GUI stuff it's either been in smalltalk or Cocoa where the widgets and the language were so intertwined they basically were the same thing.  Everything else just feels bad even when someone does a great job.
15:28:01 <jared-w> Haven't done any GUI work in smalltalk but I've heard wonderful things about it
15:28:27 <jared-w> and the IDE/GUI sorta experience in smalltalk is wild to look at
15:28:39 <dsal> eclipse?
15:28:44 <solonarv> dsal: it sort of seems like FRP could lead to a similar GUI library/language
15:29:04 <solonarv> *similarly good/integrated
15:29:06 <dsal> Yeah, I've not tried anything lately.  I can throw together web stuff well enough that it does OK.
15:29:21 <solonarv> I haven't touched anything UI-adjacent in forever
15:29:34 <xenon-> for programs with simple UI consider using some haskell web framework. it'll be accessible from every OS, including mobile OSes
15:29:54 <conal> Better yet, don't start with FRP but rather with a semantic/mathematical/denotational model of GUIs. Then ask whether FRP semantics match the chosen GUI semantics.
15:30:09 <solonarv> true
15:30:44 <conal> If the semantic model is a poor match or if there isn't one, then the result is guaranteed to be a mess of one form or another.
15:31:34 <maralorn> "i think when functional programming becomes more mainstream these things will improve" I can think of so many zynic thinks to respond to that.
15:31:48 <conal> OO approaches to GUI lack anything like a precise & simple model/denotation and instead try to get by with a mountain of operational mechanism.
15:32:48 <maralorn> I am actually amazed by reflex-frp. But the conceptual problems with that have been noted above already. (i.e. not native)
15:32:50 <dsal> I found the NeXTSTEP model pretty good overall.
15:33:12 <mycroftiv> the plan 9 native 'rio' gui that presents its interface as an fs is a very different model of both interaction and implementation. im not sure how to translate all its ideas to a functional context, but the fact that it presents itself as a tree of files and is freely recursively nestable inside itself is intriguing
15:33:53 <dsal> Last time I tried plan 9, it was with 8½ (and I was able to run 8½ in an 8½ window).
15:33:55 <conal> I always feel sad when I see functional programmers trying to emulate imperative thinking.
15:34:20 <maralorn> I think gui is a very much not imperative problem.
15:36:36 <conal> "It's very dangerous to mix up the words *natural* and *habitual*. We have been trained to be quite habitual at communicating in ways that are quite unnatural." - Mohandas K. Gandhi
15:36:56 <conal> For instance, OO and state for GUIs are habitual, not natural.
15:36:57 <zeta_0> well haskell was just a research language for a while but now it can be used in the real world, so having the backing of industry as well as the open source community will be a good thing for functional programming in general '
15:37:31 <zeta_0> conal: agreed
15:38:38 <conal> The real trick is seeing beyond the habitual (and thus the repetition-induced "obvious").
15:40:51 * hackage venzone 1.0.0.3 - ASCII platform-adventure game  https://hackage.haskell.org/package/venzone-1.0.0.3 (fffaaa)
15:46:58 <mycroftiv> intuitively, theres a dream of a functionally composable gui interface, where the data transformation layer and the presentation layer are manipulable in a common frame, so you create a composition of data flows and then freely attach 'viewer/interactor' application modules into it
15:47:50 <mycroftiv> in practice, everyone has binary file formats to view, websites to visit, lots of fossilized legacy systems, and everything is just a barely-working pragmatic wrapper on whatever is needed to interact with a disorganized universe
15:56:14 <jared-w> dsal: I was thinking of https://pharo.org/
15:57:50 * hackage downloader 0.1.0.1 - A small, low-dependency library that provides turn-key file download over HTTP and HTTPS.  https://hackage.haskell.org/package/downloader-0.1.0.1 (deech)
16:13:20 * hackage evdev 0.2.0.0 - Bindings to libevdev  https://hackage.haskell.org/package/evdev-0.2.0.0 (GeorgeThomas)
16:15:16 <bl4ckb0ne> is there something like `zip [0] [0..10]` that will generate [(0,0),(0,1),..,(0,10)] ?
16:15:44 <f-a> > zip (repeat 0) [0..10]
16:15:49 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(0,10)]
16:16:05 <bl4ckb0ne> thanks!
16:16:07 <f-a> np
16:23:19 <phadej> > map (0, ) [0..10]
16:23:22 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(0,10)]
16:31:15 <boxscape> hm, I feel like there might have been some way to be able to enter the real record field signatures, e.g. something similar to `data Id a where Id {runId :: Id a -> a}`, but I might also be completely misremembering
16:31:33 <boxscape> s/where/=
16:31:39 <boxscape> that'ss not supposed to be GADT syntax
16:37:50 <int-e> boxscape: data Id a where Id :: { runId :: Id a -> a } -> Id a
16:38:20 * hackage evdev 0.2.0.1 - Bindings to libevdev  https://hackage.haskell.org/package/evdev-0.2.0.1 (GeorgeThomas)
16:38:42 <boxscape> int-e but then runId has the type `Id a -> Id a -> a`
16:39:25 <int-e> boxscape: Ah. Just runId :: a then.
16:39:46 <boxscape> right, but I was wondering if there was some way to enter the real signature, because I feel like I have a vague recollection of something like that being a thing
16:40:10 <int-e> boxscape: I see, I misread your question. I don't share your feeling though.
16:40:22 <boxscape> I might be thinking of a different language or I might just be making stuff up
16:41:35 <aplainzetakind> bl4ckb0ne: > (,) <$> [0] <*> [0..10]
16:42:18 <aplainzetakind> > (,) <$> [0] <*> [0..10]
16:42:21 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(0,10)]
16:43:00 <sim590> Sometimes my programs don't do anything. I don't understand why. CPU is not used and my function doesn't return.
16:43:04 <boxscape> > map (0,) [1..10]
16:43:06 <aplainzetakind> > (*) <$> [2,3] <*> [5,7]
16:43:07 <lambdabot>  [(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(0,10)]
16:43:08 <lambdabot>  [10,14,15,21]
16:43:22 <f-a> needs TupleSection
16:43:25 <boxscape> oh that solution was already posted
16:44:33 <sim590> For instance, I have changed my code from last pastebin for this https://paste.debian.net/1120586/. For instance, I'm trying to run it with the trace on nextCandidates, but nothing prints and nothing is going on.
16:46:40 <f-a> sim590: you forgot to include the definition of MChaine
16:53:58 <sim590> f-a: You can get it from this paste: https://paste.debian.net/1120572/. But, the most recent version of btMChaine (main algorithm) is from the last paste I did.
17:11:45 <iqubic> @unmtl
17:11:45 <lambdabot> Plugin `unmtl' failed with: Parse error: ;
17:13:13 <iqubic> @unmtl ExceptT String (StateT (Int, Int) (Writer [Int])) Int
17:13:13 <lambdabot> ExceptT String (StateT (Int, Int) (Writer [Int])) Int
17:13:39 <iqubic> That didn't do what I wanted.
17:14:00 <iqubic> @mtl ExceptT String (StateT (Int, Int) (Writer [Int])) Int
17:14:00 <lambdabot> Maybe you meant: url unmtl pl msg
17:14:08 <iqubic> I don't get why that didn't work.
17:16:44 <Axman6> @mtl ErrorT String (StateT (Int, Int) (Writer [Int])) Int
17:16:44 <lambdabot> Maybe you meant: url unmtl pl msg
17:16:48 <Axman6> @unmtl ErrorT String (StateT (Int, Int) (Writer [Int])) Int
17:16:48 <lambdabot> Int -> Int -> (Either String Int, Int, Int, [Int])
17:17:14 <Axman6> Hmm, I feel like there's some lies there
17:18:09 <iqubic> Sure is.
17:40:55 <mastarija> can anyone help me a bit with implementing a math expression parser using ReadP?
17:42:00 <mastarija> I kind of have trouble with properly parsing this expression "5-2-1" my parser interprets it as "5-(2-1)" which gives 4 instead of 2 as a result.
17:44:02 <mastarija> Here's the pastebin of my code https://pastebin.com/wnjLaNWR
17:45:10 <mastarija> I guess making things left associative would fix the problem but I can't figure out how to make that happen with my code.
18:05:37 <sim590> f-a: I found my error finally. It was due to a zip I was doing that I shouldn't have done. I thought that zip would do like cartesian product, but it doesn't indeed! So, it was cutting my list, so may be I was always doing recursion with empty list. Therefore, I would be trying to evaluate `head` of an infinitly constructing list. Would that explain the fact that ghci was not using any CPU but
18:05:39 <sim590> also no returning?
18:06:24 <sim590> but why wouldn't that consume CPU ?
18:18:22 <iqubic> Why is fromRight not a thing in haskell's prelude?
18:18:44 <iqubic> It would be of type "Either a b -> b"
18:20:07 <iqubic> By prelude I mean base.
18:23:04 <iqubic> I just spent the past 45 minutes changing "execProg" from "Tape -> [Int] -> [Int]" to "Tape -> [Int] -> Either IntcodeError [Int]"
18:23:33 <iqubic> But now I fear that I no longer have a sufficiently lazy execProg function.
18:24:05 <iqubic> Because it will now need to evaluate execProg fully before giving me any outputs.
18:24:40 <iqubic> type Interpreter = StateT Memory (WriterT [Int] (Except IntcodeError)) ()
18:24:49 <iqubic> execProg t i = runExcept $ execWriterT $ execStateT step initialMem
18:25:06 <iqubic> step :: Interpreter
18:25:28 * unclechu uploaded an image: Screenshot from 2019-12-11 04-13-42.png (15KB) < https://matrix.org/_matrix/media/r0/download/matrix.org/qxvVxBqXcjGjSROJprdcqVkR >
18:25:44 <unclechu> best `Semigroup` instance ever 🤦
18:25:44 <iqubic> Is that still lazy?
18:26:03 <iqubic> Nice.
18:26:43 <iqubic> Is my new execProg function sufficiently lazy?
18:38:27 <bl4ckb0ne> i have a fold that takes too much time, is there a way to optimize it?
18:38:29 <bl4ckb0ne> https://paste.sr.ht/%7Ebl4ckb0ne/9eb44d0d42b91be1322e463ae1ad5e6373a54755
18:44:44 <dsal> :t fromRight
18:44:46 <lambdabot> b -> Either a b -> b
18:45:18 <iqubic> Where is that defined?
18:45:22 <dsal> Data.Either
18:45:26 <iqubic> Ah.
18:45:48 <dsal> bl4ckb0ne: You could add a ' and that'd probably help, but have you profiled?
18:45:49 <Ailrun[m]> Use hoogle, that helps us a lot.
18:46:56 <bl4ckb0ne> yup, i moved to the foldl1'
18:47:01 <bl4ckb0ne> but still processing
18:47:13 <lyxia> bl4ckb0ne: intersect is really slow on big lists
18:47:20 <dsal> bl4ckb0ne: that's ... yeah, I was going to say
18:47:28 <dsal> You surely don't want a list there.
18:47:45 <bl4ckb0ne> set maybe
18:47:51 <bl4ckb0ne> but idk how many duplicates i have
18:48:38 <dsal> If  you knew, and it was a small number overall, then list might be OK.  :)
18:49:02 <lyxia> it's especially slow if there are few duplicates
18:49:11 <bl4ckb0ne> both of the lists are around 150k elems
18:49:22 <dsal> OMG.  Yes.  Don't do that.
18:49:48 <lyxia> the size of the result is really not the deciding factor for how slow intersect is
18:50:05 <dsal> The only constraint is Eq, so it has to compare everything against everything else.
18:50:44 <bl4ckb0ne> 150k against 150k is a lot
18:51:01 <dsal> It's millions of unnecessary comparisons.  Just use a Set.
18:55:24 <wrunt[m]> Is there a simple way in Haskell to get the size of a data type? I.e. the number of distinct values of that type? E.g. Bool's size is 2, Int's size is (maxBound - minBound), Double's size is... huge but finite, Text's size is infinite.
18:56:35 <lyxia> wrunt[m]: check out the universe and size-based packages
18:57:52 <pounce> is there a function f :: [a] -> [(Int,a)] labels each element with its index
18:57:58 <koz_> wrunt[m]: Also finitary. :P
18:57:58 <koz_> </blatant_self_promotion>
18:58:28 <koz_> pounce: zip [0..]
18:58:46 <koz_> > zip [0..] ['a', 'b', 'c']
18:58:49 <lambdabot>  [(0,'a'),(1,'b'),(2,'c')]
18:59:02 <pounce> ah makes sense
18:59:12 <koz_> You can make it [1..] if you prefer 1-based indexing.
18:59:22 <pounce> 🤔
18:59:24 <ChaiTRex> 1-based indexing is the work of Satan.
18:59:38 <koz_> ChaiTRex: Most of the 'mathy' languages do it. And Lua, for raisins.
18:59:47 <koz_> ('mathy' meaning Matlab, Julia, R, etc)
19:00:07 <koz_> I'm not here to judge - just sayin' the option's there.
19:00:32 <ChaiTRex> I was just kidding, but 0-based makes a lot of things easier.
19:02:01 <wrunt[m]> Ah, cardinality. That's the term I was searching for. Thanks lyxia and koz_.
19:02:22 <koz_> wrunt[m]: No problem.
19:03:14 <bl4ckb0ne> is there a head function for Set?
19:03:27 <f-a> bl4ckb0ne: there is no head in Set
19:03:32 <f-a> elements are *unordered*
19:03:49 <koz_> f-a: Set is ordered, due to the Ord requirement on elements. THe function you seek is lookupMin.
19:04:51 <bl4ckb0ne> ty
19:05:47 <bl4ckb0ne> i found findMin which doesnt returns a maybe
19:05:58 <koz_> s/you/bl4cbone/
19:06:08 <koz_> bl4ckb0ne: There's a reason it returns a Maybe.
19:06:12 <koz_> What if your Set is empty?
19:06:12 <f-a> use `maybe` to unrwap it
19:06:19 <f-a> of pattern match on it
19:06:22 <koz_> Do you like your code randomly exploding?
19:06:30 <koz_> f-a is giving correct advice. :D
19:06:33 <dsal> partial functions are bad and you should feel bottom
19:06:44 <pounce> feel, bottom
19:06:52 <koz_> dsal: Yeah, if you use partial functions, your code will _|_ you.
19:07:04 <bl4ckb0ne> 0.38s with Data.Set :D
19:07:06 <bl4ckb0ne> thanks
19:07:12 <koz_> bl4ckb0ne: You're welcome!
19:07:15 <bl4ckb0ne> koz_: i know my set has at least 1 element
19:07:24 <f-a> then 
19:07:27 <koz_> bl4ckb0ne: A lot of disasters began with such assertions. :P
19:07:35 <f-a> :t maybe (error "prova") 
19:07:36 <lambdabot> (a -> b) -> Maybe a -> b
19:07:40 <koz_> (no joke, I crashed GHC once because of that)
19:07:43 <bl4ckb0ne> koz_: its advent of code
19:07:47 <bl4ckb0ne> also I like to live dangerously
19:07:52 <bl4ckb0ne> hi pounce 
19:07:57 <pounce> oh hi
19:08:19 <koz_> bl4ckb0ne: http://m.quickmeme.com/img/54/5451d350c005719d708ebac4e60b838a802a375d18f45a9b35a86ec5cb09c2a6.jpg
19:10:46 <pounce> where do u put the .s when composing lots of functions
19:10:54 <koz_> pounce: What do you mean?
19:12:24 <dsal> pounce: I put it between the functions.
19:12:28 <pounce> like, to make it look pretty
19:12:37 <pounce> i know you put them between the functions :<
19:12:40 <koz_> pounce: One space either side, like operators should be.
19:12:43 <koz_> So something like
19:12:55 <koz_> > fmap ((+ 1) . subtract 3) [1, 2, 3, 4]
19:12:58 <lambdabot>  [-1,0,1,2]
19:13:18 <dsal> let  ~*.*~ = . in      fmap ((+ 1) ~*.*~ subtract 3) [1..4]
19:13:26 <dsal> > let  ~*.*~ = . in      fmap ((+ 1) ~*.*~ subtract 3) [1..4]
19:13:28 <lambdabot>  <hint>:1:6: error: parse error on input ‘~*.*~’
19:13:33 <dsal> damnit . I was trying to make it look pretty.
19:13:39 <pounce> wha
19:13:54 <pounce> no, i mean where do you put it in relation to whitespace
19:13:56 <koz_> > let (~*.*~) = (.) in fmap ((+ 1) ~*.*~ subtract 3) [1, 2, 3, 4]
19:14:01 <lambdabot>  [-1,0,1,2]
19:14:12 <dsal> oh.  *sigh*
19:14:20 <koz_> dsal: Gotta fish out your inner Lisper for infix operators. :P
19:14:37 <koz_> I gotta note here that this is also possible:
19:14:47 <koz_> > fmap (subtract 3 >>> (+ 1)) [1, 2, 3, 4]
19:14:48 <dsal> Yeah.  That was silly.
19:14:49 <lambdabot>  [-1,0,1,2]
19:15:01 <koz_> Or, if you wanna be maximally [insert appropriate slur]:
19:15:13 <koz_> > fmap ((+ 1) <<< subtract 3) [1, 2, 3, 4]
19:15:17 <lambdabot>  [-1,0,1,2]
19:15:19 <Ailrun[m]> Yeah, if one prefers Arrows
19:15:22 <dsal> leftist.
19:15:30 <koz_> dsal: Lol.
19:15:31 <dsal> I never got into arrors.
19:15:37 <dsal> haha, weird typo
19:15:57 <Ailrun[m]> arrors! error and arrows
19:16:28 <koz_> So basically the Kleisli arrow of the form (MonadError e m) => a -> m b?
19:16:34 <djanatyn> what is the proper name for a typeclass with a data family definition? I used the term "type family" and was corrected before - i think there's something more precise, but it doesn't look like "data family" or "type synonym family"
19:17:55 <Ailrun[m]> for the data family, there is a name. Associated data family
19:18:21 <Ailrun[m]> However, for the class, I doubt there is a name.
19:42:20 * hackage Enum 0.2.0.0 - Non-crashing `Enum` operations  https://hackage.haskell.org/package/Enum-0.2.0.0 (MatthewFarkasDyck)
20:14:09 <pounce> >trying to figure out the closest common node in a tree
20:14:12 <pounce> https://haskelltree.com/
20:15:25 <ChaiTRex> pounce: use a tape measure
20:15:33 <pounce> hmm
20:15:55 <Welkin> what
20:16:19 <Welkin> haskell can trim your trees?
20:16:32 <pounce> ChaiTRex: it's too big
20:16:43 <ChaiTRex> Welkin: it has that and many more tree algorithms!
20:16:56 <pounce> where :<
20:17:19 <incertia> anyone able to help with polysemy? i'm trying to interpret State in ST and the forall is going into the wrong place
20:17:58 <monochrom> Haskell grows trees lazily.  An ounce of sustainable growth is worth a pound of after-the-fact trimming. :)
20:19:22 <maerwald> growth is expensive
20:33:06 <mastarija> Is it possible to write math expression parser with ReadP? Seems like left recursive parser is not possible with it. My expression "1-2-1" get's interpreted as "1-(2-1)" instead of "(1-2)-1". When I try to switch associativity parser just hangs.
20:37:23 <pavonia> ReadP also has chainl, IIRC, so it should be possible
20:37:54 <monochrom> chainl and similar parsers are also easily user-definable.
20:38:50 <glguy> Prelude Text.ParserCombinators.ReadP> readP_to_S (chainl (X <$ string "X") (O <$ string "-") Z <* eof) "X-X-X"
20:38:50 <glguy> [(O (O X X) X,"")]
20:43:31 <pounce> Data.Tree doesn't have that many functions..
20:44:19 <dsal> It's got ascii drawing functions.  What else do you need?
20:44:38 <dsal> It's got a ton of instances, too.
20:44:42 <Welkin> the data transfer rate to my usb thumb drive is slower than my wifi
20:44:44 <monochrom> Have you taken into account Tree is an instance of several important classes and so it also enjoys a lot of methods?
20:44:45 <Welkin> o.o
20:45:08 <Welkin> even usb c/3 is slower than my wifi
20:46:50 <Welkin> monochrom: you've taken it a step too far now by personifying trees as enjoying leisure activities
20:46:56 <Welkin> how does a tree enjoy methods?
20:47:20 <MarcelineVQ> maybe the real enjoyment was the trees we met along the way
20:47:40 <dsal> haha
20:47:49 <monochrom> Yes but I learned from an older wiser generation, e.g., Hoare wrote like that.
20:47:49 <ChaiTRex> Welkin: trees enjoy the smile method. you can tell because they're smiling when you call it.
20:48:18 <monochrom> "the natural numbers enjoy the following properties: ..."
20:48:57 <Welkin> they also enjoy long walks on the beach, and they're single and ready to mingle
20:49:00 * dsal likes being counted, just like natural numbers
20:49:17 <monochrom> I'll count you in!
20:49:33 <dsal> pounce: What is it you wish you do with a Tree that isn't covered?
20:49:50 <dsal> I didn't even know about MonadZip, and now I can't because it's almost midnight somewhere.
20:50:18 <iqubic> what is MonadZip?
20:50:24 <ChaiTRex> dsal: can't we just enjoy the natural beauty of uncovered trees?
20:50:44 <monochrom> Count Dracula and his successor function.
20:51:23 <dsal> mzipWith :: (a -> b -> c) -> Tree a -> Tree b -> Tree c
20:51:32 <shachaf> iqubic: Can you think of a way you might answer this question?
20:51:44 <dsal> And the sexy, munzip :: Tree (a, b) -> (Tree a, Tree b)
20:51:56 <ammar2> m'unzip
21:01:05 <pounce> dsal: wanna find the smallest subtree which contains two nodes
21:12:06 <iqubic> Repeat only evaluates the value of the nth element when I ask for it right?
21:13:19 <ChaiTRex> iqubic: Wouldn't the nth element be the same as head?
21:13:19 <f-a> > length $ take 10 $ repeat undefined
21:13:22 <lambdabot>  10
21:13:49 <iqubic> ChaiTRex: I'm thinking about what I need to do for today's AoC.
21:14:04 <iqubic> All I have is: "execProg :: Tape -> [Int] -> [Int]"
21:14:27 <iqubic> My program crashes as soon as it runs out of input to read. I hardly call that an advantage.
21:15:06 <iqubic> All I have is a machine that needs all of it's input in a lazy list, and spits out all of it's input in a lazy list.
21:15:26 <iqubic> Second one should be output.
21:15:31 <ChaiTRex> iqubic: Can't you do interactive input?
21:15:40 <ChaiTRex> iqubic: Watch the output as you input things?
21:15:54 <iqubic> What does that mean?
21:17:15 <ChaiTRex> iqubic: Like when it produces on the output list, print it to the screen. When you enter an input with the keyboard, put that on the last of the input list.
21:17:37 <ChaiTRex> iqubic: Like a normal program with stdin and stdout.
21:17:49 <iqubic> Not easily.
21:50:45 <iqubic> What happens if I try to delete an element from a set, when that element isn't in the set already?
21:51:07 <monochrom> What does the doc say?  What does your experiment say?
21:52:07 <f-a> iqubic: set is returned as-is
21:52:17 <shachaf> monochrom's answer was better.
21:54:50 <monochrom> "Independent Study: A Literate, Scientific, Hands-On, Invisible-Guiding-Hand Approach"
21:57:34 <monochrom> https://www.youtube.com/watch?v=oCrKy03-9Tg
21:59:14 * monochrom rogersrolls you!
21:59:30 <monochrom> Or should it be "fredrolls"?
22:00:21 <monochrom> I am going to make it a declared course policy that I will fredroll my students when they ask poor questions.
22:08:05 <jle`>  /b 2
22:13:09 <MarcelineVQ> u sank my battleship
22:15:27 <monochrom> search for "battleship drinking game" for enhanced versions!
22:21:27 <mastarija> pavonia, glguy, Hm... I still have problem getting my ReadP parser to become left associative. I can't see how chainl can fit into that story.
22:21:48 <mastarija> Can someone maybe take a look at my code? https://pastebin.com/wnjLaNWR
22:49:14 <bahamas> I was thinking of safe handling of file IO and I found this library: https://hackage.haskell.org/package/safer-file-handles. is it something that people use?
22:51:25 <pavonia> mastarija: You need to split your expE parser somehow to handle those operations separately using chainl
22:52:22 <mastarija> pavonia, my main problem is that I don't know how I'd do that.
22:52:48 <dsal> Is megaparsec an option?  It makes what I think you might be doing pretty easy.
22:53:09 <dsal> ...but I'm going to bed, so don't listen to me.
22:53:23 <dminuoso> mastarija: Formally all you need to do is make your grammar right-recursive instead of left-recursive.
22:54:23 <bahamas> does it make sense to want a library that returns a Maybe or Either when it doesn't find a file rather than throw an exception? or should I just catch exceptions myself in these situations?
22:55:31 <pavonia> mastarija: It's `chainl (numE +++ bktE expE) (Sub <$ char '-')` for substraction, I think
22:56:30 <mastarija> hm.. gonna try that now
22:58:50 <dminuoso> bahamas: For that example specifically?
22:59:29 <dminuoso> bahamas: I think exceptions make perfect sense there.
22:59:37 <mastarija> riiight.. I mean why would chainl work here? form what I understand it's used for repeating pattern
23:00:34 <dminuoso> mastarija: Not necessarily repeating
23:00:42 <dminuoso> chainl :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a 
23:02:32 <bahamas> dminuoso: yes, that example and other similar ones. why do you think throwing an exception is more appropriate than returning a Maybe/Either?
23:03:27 <dminuoso> bahamas: So `Maybe` is definitely not sensible, for the reason that it can't communicate why it failed to open the file.
23:04:18 <dminuoso> bahamas: There's roughly 20 possible error conditions why an `open(2)` call can fail under linux for instance.
23:04:29 <bahamas> dminuoso: that's true
23:05:36 <dminuoso> bahamas: Overall I think it would greatly hamper the usage of IO if every interaction that *could* fail for remote reasons would produce `Either SomeErr`
23:06:08 <haskelllisp[m]> I generated a binary file with the `stack install` command on my local server, and then I transferred the binary file to the production server. Can I run the binary file even if ghc is not installed on the production server?
23:06:11 <dminuoso> You'd have to use transformers everywhere just to get the default behavior a user would expect.
23:06:26 <maerwald> is there a simple scheduler for executing programs?
23:06:31 <dminuoso> (And perhaps there's also the historical reasons that the APIs were designed before transformers were a thing, so IO exceptions is a cleaner choice)
23:07:00 <dminuoso> bahamas: Also there's possible performance reasons.
23:10:48 <svipal> I finally did what I wanted to do with TH
23:11:03 <svipal>  and it works without issues
23:11:04 <bahamas> dminuoso: when you say you'd have to use transformers, you mean because you're dealing with two monads, IO and Either? I can't say I understand transformers well, that's why I'm asking
23:11:14 <dminuoso> bahamas: So consider this:
23:11:25 <dminuoso> bahamas: You want to open a file, read it, modify it with function `f`, and write it back.
23:11:30 <f-a> always a relief, svipal!
23:11:35 * bahamas nods
23:11:52 <dminuoso> bahamas: And all file IO actions/functions produce *Maybe` results.
23:12:00 <dminuoso> bahamas: How would you write that?
23:12:05 <dminuoso> Or lets assume
23:12:13 <svipal> f-a it 's mostly thanks to this chat
23:12:15 <dminuoso> you want to read content from 3 files, concatenate it, and then write it back.
23:12:18 <dminuoso> Think is probably a better exampl.
23:12:28 <f-a> svipal: curious, what did you need it for?
23:12:32 <dminuoso> bahamas: ^- once you understand why this would be annoying, you understand the purpose of transformers.
23:12:57 <svipal> I'm creating a sound application that works with nodes placed on a grid
23:13:07 <bahamas> dminuoso: you'd have a monad nested inside the other. from what I understand, this is where transformers make life easier
23:13:09 <f-a> interesting
23:13:50 <bahamas> ok, so it's about ergonomics and possibly performance overhead
23:14:17 <dminuoso> bahamas: readFileMaybe :: FilePath -> IO (Maybe String); 
23:14:17 <dminuoso> bahamas: Go write some code that reads the content from three files, and only if *all* three files were successfully ready, concatenate the output and print it.
23:14:28 <dminuoso> bahamas: Really try that, it might be a helpful excercise. :)
23:14:35 <svipal> making a new node was a very lengthy process that involved making the node type, writing the  node instance (with the onPulse, clean,  etc... functions) , updating the overnode type to include the node type, and updating a few functions. all this was  in about 3 different files
23:15:14 <svipal> and it felt super clunky
23:15:50 <bahamas> dminuoso: ok :)
23:27:35 <maybefbi> Is there a good tutorial for data-has
23:27:52 <maybefbi> I still don't get it
23:28:19 <maybefbi> I understand it has something to do with putting monad transformers inside tuples
23:30:54 <c_wraith> it's simpler than you're giving it credit for
23:31:16 <c_wraith> It's just a wrapper around arbitrary tuples that lets you look up values from them by type
23:31:40 <maybefbi> by type?
23:31:57 <maybefbi> how do i use types inside code using values
23:32:14 <c_wraith> inference, usually.
23:32:24 <maybefbi> ah ok
23:32:48 <dminuoso> maybefbi: You can use type inscriptions and annotations, as well as TypeApplications to help guide the type checker.
23:33:01 <dminuoso> (Type ascriptions?)
23:35:45 <maybefbi> ok
23:36:11 <dminuoso> maybefbi: Its frequently useful to expressions onto separate bindings, then annotate these bindings with type signatures. It helps visualize your own type assumptions better, and it improves type inference and diagnostics too.
23:41:04 <maybefbi> ok i get it now. the getter inside Has can get the monad inside the tuple
23:44:04 <DigitalKiwi> https://twitter.com/ArchKiwi/status/1204666857199816704?s=20 i painted stickers
23:44:20 <DigitalKiwi> https://twitter.com/ArchKiwi/status/1204666915471294464?s=20
23:45:13 <koz_> DigitalKiwi: Nice colours. :)
23:45:57 <f-a> how are those made DigitalKiwi ?
23:46:05 <f-a> and yeah, good colour choice
23:46:40 <DigitalKiwi> i put gesso on shipping labels and airbrush them
23:46:55 <DigitalKiwi> https://twitter.com/ArchKiwi/status/1198095178294341632?s=20
23:47:15 <DigitalKiwi> and then i seal them with modge podge and cut them
23:49:04 <DigitalKiwi> https://twitter.com/ArchKiwi/status/1188116089072431106?s=20 has a high res of some agda ones i did on drawing paper in A5 (or just checkout my feed mostly post art a lot of haskell/nixos)
23:50:44 <f-a> where are the hex-lambdas from?
23:51:01 <DigitalKiwi> that's the nix/nixos logo
23:52:13 <DigitalKiwi> i made a bunch for nixcon https://twitter.com/ArchKiwi/status/1164233261469581312?s=20
23:53:16 <f-a> lovely job
23:54:11 <DigitalKiwi> https://twitter.com/grhmc/status/1168918720120573956?s=20 this was the tweet i actually wanted
23:54:20 <DigitalKiwi> ty
