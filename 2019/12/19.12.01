00:02:31 <c_wraith> What cases does Set.map not preserve composition?
00:02:55 <jle`> if you have a 'bad' Eq instance
00:03:09 <jle`> although i suppose that might be more the fault of the Eq instance than with Set
00:03:26 <c_wraith> Well, ok, but nothing works right if you don't assume the Ord instance is an equivalence relation
00:03:30 <c_wraith> err.  Eq is
00:03:37 <c_wraith> And that Ord is compatible with it
00:04:08 <c_wraith> So yeah, it gets you into trouble if you have Ord/Eq instances that ignore some fields
00:04:19 <jle`> the Eq instance can be an equivalence relation, but still break Set.map composition
00:04:54 <jle`> you need a stronger constraint to make sure Set.map preserves composition
00:05:50 <jle`> namely you need (x == y) => forall f. f x == f y
00:06:30 <jle`> reflexivity/symmetry/transitivity isn't enough
00:07:12 <Pamelloe1> Interesting
00:07:25 <Pamelloe1> I don't know if that's a bug or a feature
00:08:17 <jle`> for example consider data Tup a = Tup Int a, where the Eq/Ord instance only looks at Int
00:08:49 <jle`> people sometimes use this type for priority queues for some reason
00:09:27 <jle`> this follows reflex/symm/transitivity and is a "lawful" Eq instance by virtue of defining an equivalence relation
00:10:01 <jle`> but if you go "through" it during function composition, it won't be preserved by Set.map
00:10:24 <jle`> but yeah, i consider this a bad Eq instance, so maybe it's not worth taking into account :)
00:11:09 <Pamelloe1> I wonder if you can formally encode the notion of a function being well-defined over an Eq isntance
00:11:44 <Pamelloe1> Formally encode it in Haskell, that is
00:11:59 <Pamelloe1> Probably not
00:12:09 <c_wraith> Haskell doesn't really deal with things like that.
00:13:07 <c_wraith> You probably could encode it with enough indirection, but then it'd be so awkward you wouldn't want to use it
00:15:09 <Pamelloe1> I guess the other way of looking at it would be to try and distinguish between Eq being logical equality and Eq being any old equivalence relation
00:19:00 <Pamelloe1> Is there any way to tell GHC to ignore conflicting type family instances?
00:22:45 <totbwf> You can do that sort of thing in agda/coq/idris etc
00:29:37 <dsal> I can't figure out how to make a SigD in TH.  I've got a MonadIO constraint and a couple of aliased types and when I try to generate something close, it just fails in various ways. (e.g., "Data constructor not in scope: MonadIO").  The fundef seems OK, but I want the declaration.
01:58:22 <xenon-> hi. what do you prefer, blaze html or lucid?
01:58:41 <Rembane> Lucid! 
01:58:47 <Rembane> It's sane! 
02:17:40 <xenon-> Rembane, and blaze isn't? why? :)
02:18:16 <xenon-> I haven't tried either yet. trying to decide quickly which one to use
02:37:40 <Rembane> xenon-: I've only used Lucid and it has been a good experience, but Chris Done has a quite good motivation for why he created Lucid in the first place instead of Blaze: https://chrisdone.com/posts/lucid/
02:45:42 <merijn> "import Foreign" time for the fun bit of my coding :p
02:46:36 <Rembane> :D
02:46:41 * Rembane does the segfault dance
02:47:20 <merijn> Rembane: That doesn't happen that often, tbh. This is more of "write C without the suck via Vector.Storable" :p
02:50:46 <Rembane> merijn: That sounds like a not too terrible experience.
02:52:18 <merijn> Rembane: I just write completely unpacked/strict data structures with a handwritten Storabe instance, dump a ByteString straight into Storable Vector and get instant C speed ;) (well, almost it's slightly slower, but not too much)
02:53:37 <Rembane> merijn: Nice! That is definitely today's lifehack. Do you have any issues with laziness? 
02:55:30 <merijn> Rembane: Generally not, but in this case I *really* want GHC to just load things into memory register directly
02:55:54 <Rembane> merijn: Got it. 
02:57:55 <merijn> Rembane: I've got a Vector based binary decision tree for example, and the reason I laid it out with structs per element is exactly to ensure that it actually reads those things in one go into the cache to speed things up
03:01:39 <merijn> Rembane: So I'm just hoping that having each entry be completely unpacked + strict convinces GHC to actually read it as I want (which it mostly seems to...or at least it's not slow enough to investigate deeper right now)
03:14:58 <Rembane> merijn: That's really good stuff. Fast enough is one of the best speeds.
04:28:20 <mbwgh> Hello I am trying to foldr over an infinite list of ´[(String, Map String Int)]`. Inside the fold, I can alter the `Map` alright. But what I want to do in addition is to annotate with the number of occurrences of certain `Strings` on the left side of the 2-tuple, so I want to make it a `[(Int, String, Map String Int)]`. However this does not seem to work at all and the function bottoms immediately without 
04:28:26 <mbwgh> producing anything. Shouldn't this be possible with foldr?
04:28:38 <maralorn> Hm, that’s the first time I added "lens" to my includes. I wonder how tough it will be.
04:29:45 <__monty__> mbwgh: No reason that shouldn't work. Paste your code so we can take a look.
04:29:45 <Rembane> mbwgh: What is the problem you are trying to solve? 
04:30:34 <maralorn> How can a foldr over an infinite list ever terminate?
04:31:28 <int-e> > foldr (\_ _ -> 42) 23 [1..]
04:31:30 <lambdabot>  42
04:33:15 <int-e> > let takeWhile' p = foldr (\x xs -> if p x then x : xs else xs) [] in takeWhile (<10) [1..]
04:33:18 <lambdabot>  [1,2,3,4,5,6,7,8,9]
04:34:11 <int-e> > take 10 $ foldr (:) [] [1..] -- "termination" is a murky concept as well in the presence of lazy evaluation.
04:34:14 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
04:34:30 <danielbrauer> In Learn You A Haskell, on this page: http://learnyouahaskell.com/starting-out , it says "As seen in this example, tuples can also contain lists". Does anyone know which example it's referring to?
04:34:50 <int-e> maralorn: do those examples help?
04:35:56 <merijn> danielbrauer: Not really sure, but note that LYAH isn't a particularly great book
04:36:14 <merijn> int-e: pfft, you forgot the best way to show that
04:36:28 <merijn> > foldr f z [1..] :: [Expr]
04:36:31 <lambdabot>  error:
04:36:31 <lambdabot>      • Couldn't match expected type ‘[Expr]’ with actual type ‘Expr’
04:36:31 <lambdabot>      • In the expression: foldr f z [1 .. ] :: [Expr]
04:36:40 <merijn> > foldr f z [1..] :: Expr -- like this, I guess?
04:36:43 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 (f 11 (f 12 (f 13 (f 14 (f...
04:36:46 <xenon-> danielbrauer, String is alias for [Char], a list of Chars
04:37:12 <merijn> maralorn: Note that if 'f' doesn't need it's second argument to return a result
04:37:52 <xenon-> :t ("Christopher", "Walken", 55)
04:37:53 <lambdabot> Num c => ([Char], [Char], c)
04:38:12 <merijn> maralorn: Consider the case of 'f' = && and '1' = False, then it can immediately return False without evaluating the "f 2 ..." part
04:39:04 <Rembane> Is the name foldr weird or do I have to think about it in another way? 
04:41:10 <int-e> Rembane: The name is just fine... it's a right-associative fold. But because of laziness we evaluate the resulting term from outside, not from inside.
04:41:36 <maralorn> merijn: int-e: Yeah I get it. The accumulating function is lazy in the next list element.
04:42:46 <maralorn> That doesn‘t work with foldl though, does it?
04:42:53 <int-e> right.
04:43:44 <Rembane> int-e: That we evaluate it from the outside and not inside was the missing part for my understanding. Thank you.
04:44:07 <merijn> maralorn: Correct
04:44:17 <merijn> maralorn: That's why foldr works with infinite lists and foldl can't
04:44:26 <merijn> > foldl f z [1..5]
04:44:28 <lambdabot>  f (f (f (f (f z 1) 2) 3) 4) 5
04:45:03 <Ariakenom> foldr f z (x:xs) = f x (foldr f z xs)
04:45:15 <merijn> the outermost 'f' needs the last list element
05:00:20 <danielbrauer> merijn Thanks, which book would you recommend for someone with plenty of experience with imperative languages?
05:01:38 <merijn> danielbrauer: I don't really have any personal recommendations, since most of them weren't around when I started :p I've heard that Graham Hutton's "Programming in Haskell" is good. Haskell from First Principles seems quite comprehensive too
05:01:50 <merijn> danielbrauer: There's https://github.com/bitemyapp/learnhaskell with a bunch of resources too
05:02:27 <merijn> danielbrauer: LYAH is nice as a sort of "look how neat this stuff is", but there's a lot of things it doesn't explain well (or at all) and no real exercises
05:04:38 * hackage niv 0.2.4 - Easy dependency management for Nix projects  https://hackage.haskell.org/package/niv-0.2.4 (nmattia)
05:06:15 <mbwgh> Ok, let's take this function as example: annotate :: [Int] -> [(Int, Int)]
05:06:15 <mbwgh> annotate = foldr step []
05:06:15 <mbwgh>     where
05:06:15 <mbwgh>         step n []               = if even n then [(1, n)] else [(0, n)]
05:06:18 <mbwgh>         step n acc@((i, _):_) = if even n then (i+1, n):acc else (i, n):acc
05:06:37 <mbwgh> Could this be changed to work with an infinite list?
05:06:37 <danielbrauer> merijn Cheers, thank you!
05:09:08 * hackage yesod-core 1.6.17 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.6.17 (MaxGabriel)
05:10:29 <merijn> danielbrauer: And tbh, the recommendations for "lots of experience with imperative languages" are pretty much the same as for those with basically no experience programming. There's plenty of knowledge that carries over from imperative programming, but usually only later in learning and not when learning the basics
05:12:39 * hackage yesod-test 1.6.9 - integration testing for WAI/Yesod Applications  https://hackage.haskell.org/package/yesod-test-1.6.9 (MaxGabriel)
05:23:54 <Panormus> Hey
05:24:36 <Panormus> Hi
05:25:41 <evelyn> λ
05:26:17 <Athas> Oh no, 'cabal run' prepends the output with 'Up to date'.
05:27:15 <Athas> Is cabal-install 3 known to still be unpolished?  I'm encountering a lot of paper cuts, but they could all also be conscious design decisions.
05:29:04 <merijn> Athas: -v0
05:29:23 <merijn> Athas: It's intentionally not quiet, since it will also build anything unbuild
05:29:50 <merijn> So else you'd change the source, use cabal run and then be confused why it's taking 5 minutes to start
05:30:02 <Athas> It could dump all that on stderr instead.
05:30:04 <merijn> Arguably if there's really no rebuilding it could/should skip that output
05:31:00 <merijn> It doesn't do that? Lemme check
05:32:04 <Athas> I fully acknowledge that it's not clear a priori what should go on stdout versus stderr, but for a 'run'-style command, I think all the meta-information definitely belongs on stderr.
05:32:23 <Athas> Even if normal 'cabal build' output might well go to stdout.
05:32:49 <merijn> Athas: I think there's something to be said for either
05:33:19 <Athas> Right.  But for 'cabal run', I think there is zero justification for intermixing.  Sometimes consistency is not what is desired.  I wonder what 'stack run' does.
05:34:58 <Athas> Well!  At least now my ray tracer can generate PPM images when run as 'cabal run -v0'.
05:35:09 <merijn> Athas: You want "a convenient tool that just does what I want for students", and I empathise with that, but the current design is very much "consistency and separation of mechanism and policy, so it can predictably used in complex situations"
05:35:22 <Athas> No, not just for students.  Right now I want a convenient tool for hacking around myself.
05:36:11 <Athas> Specifically, I've had the following issues: 'cabal build' doesn't give me a binary I can run.  'cabal install' hides compiler warnings (by default?  Couldn't find a flag to change it).  'cabal run' corrupts my stdout by default.
05:36:13 <merijn> Athas: It's fairly trivial to setup either a small script or a config file so that it behaves as you want, though. Because all the options from our discussion yesterday can be permanently set in ~/.cabal/config and/or cabal.project
05:36:21 <Athas> Apart from that, cabal-v3 has been fairly pleasant.  Sure feels faster than stack.
05:36:30 <merijn> Athas: Wait, cabal isntall hides compiler warnings? That's wrong
05:37:00 <merijn> Athas: Or did you install something already built?
05:37:04 <Athas> merijn: it could also be a design decision!  When 'cabal install'ing some Hackage thing, maybe I don't want to see the warnings.
05:37:15 <Athas> No, I've been using 'cabal install' as a shortcut for building and putting binaries in my cwd.
05:37:23 <merijn> Athas: On my machines 'cabal install' very much shows me warnings?
05:37:39 <merijn> Lemme check if I'm going crazy
05:37:40 <Athas> I'm using cabal-install 3.0.0.0.  Maybe it was fixed later?
05:37:59 <Athas> 3.0.0.0 seems the most recent.
05:38:22 <fendor> what is cabal-v3? cabal version 3.0.0.0 or are there a set of commands `v3-*`? 0-o
05:38:31 <merijn> fendor: 3.0.0.0
05:38:37 <fendor> ah, ok
05:38:40 <merijn> fendor: which made v2 the default
05:38:47 <Athas> Sorry, my notation was sloppy.
05:39:43 <merijn> I'm checking what happens to my warnings on install now
05:40:08 <fendor> not sloppy, I was just unsure
05:40:33 <merijn> fendor: I wouldn't expect another major v2 like overhaul anytime this decade ;)
05:41:55 <Athas> Looks like the 'cabal run' behaviour has already been reported, but progress stalled: https://github.com/haskell/cabal/issues/4652
05:41:55 <fendor> well, there could be small backwards incompatible changes that justify a v3 set? 
05:42:07 <Athas> The cabal devs seem to agree that it's a problem, fortunately.
05:42:33 <merijn> Athas: hvr very much wants to make cabal run easy to use, so I'm not surprised
05:42:56 <merijn> Athas: He spent a lot of timing making the recompilation check fast so that it wouldn't get annoying when you "cabal run"
05:43:06 <Athas> cabal-install 3.0.0.0 is in many ways very very good, and in particular it is fast.
05:43:25 <Athas> There is very little left to make me prefer stack for larger projects.
05:44:25 <merijn> hmm, looks like you're right and install does hide warnings in log files
05:44:56 <merijn> Maybe I'm thinking of 2.4 that did show them
05:49:49 <Athas> Meanwhile, 'stack' recently started displaying warnings even for dependencies!
05:50:05 <Athas> Maybe it's just a general policy of doing what stack doesn't.  It's a constructive way to guarantee a niche.
06:28:00 <fendor__> why is cabal install so expensive after a build? it still takes a huge amount of time
06:31:40 <merijn> fendor: Which version of cabal-install?
06:32:13 <fendor> cabal 3.0.0.0
06:33:31 <merijn> fendor: Because it runs sdist and installs from the tarball, so the preceding build is ignored (I'm not entirely sure of the reasoning) otoh, there's also no real reason to "build first" and then install
06:35:08 <fendor> merijn, yes there is, to see warnings and build progress.
06:35:47 <merijn> fendor: You can look up the warnings in the build log, though?
06:36:37 <fendor> but then there is no colour! I like my colour output T_T
06:36:58 <merijn> Generally I only pay attention to warnings for stuff I'm working on directly and if I'm working on it, then I don't bother installing in the first place
06:38:32 <pie_> has anyone ever seen something like this: filtering a set of positions out of a data structure and keeping some kind of pointers to them around, then being able to manipulate the resultion pointer structure as if you were mutating the original values
06:38:56 <pie_> what i actually want to do is in python, and i want to filter a subset of a list and then change some of the values
06:39:01 <merijn> pie_: I'm gonna need some clearer explanation, tbh
06:39:07 <pie_> buti figured you guys might know some concept that i can google for
06:39:08 <pie_> ok
06:39:36 <pie_> im parsing some text into tuples of (whitespace, content, newline) into a list,
06:39:46 <pie_> err, some kind of crappy lexing phase
06:40:10 <pie_> and the tuples are implicit, its actually just a list of things
06:40:15 <fendor> merijn, there is the problem that cabal run not necessarily puts executables on the path when tests are run, to trick that, I install the executable and then run the tests
06:40:19 <pie_> and i want to convert the whitespaces into INDENT/DEDENT symbols
06:40:35 <pie_> i.e if the indentation level increases i want to put an INDENT symbol
06:41:16 <pie_> so i figured what i could reduce the problem by filtering out the whitespace items from the list, and look at neighboring whitespace items
06:41:25 <pie_> does that make sense?
06:41:54 <pie_> im just bad at algorithms so im having a little trouble coming up with how to do this nicely (i should just go and write the damn for loop)
06:42:46 <pta2002> is there any way to simplify editing some property nested within a record?
06:42:46 <pta2002> like
06:42:57 <pta2002> j{a = (a j){b = 3}}
06:43:02 <pta2002> is there any way to shrink that
06:43:06 <hexagoxel> The first thing `stack --system-ghc --no-install-ghc runhaskell Foo.hs` does is .. installing a new ghc version.
06:43:22 <fendor> pta2002, not without library support.
06:43:42 <pta2002> not using any library here
06:43:58 <merijn> fendor: If you run "cabal run" with --enable-tests does it add them then?
06:44:01 <pta2002> but so there's no syntax or language extesnion for it?
06:44:11 <evelyn> pta2002: RecordWildCards might be orth a look
06:44:25 <pta2002> i'll look into it
06:44:27 <pta2002> thanks
06:44:31 <pie_> ["    ", "stuff", "\n", "  ", "stuff", "\n"] -> ["stuff", DEDENT, newline, "stuff", newline]
06:44:37 <merijn> RecordWildCards won't help much, though
06:44:51 <merijn> The real answer for truly nested structures is "use (micro)lens"
06:45:47 <evelyn> In this case it seems like unneccesary difficulty to not use libraries.
06:46:20 <fendor> merijn, not sure, gotta try it. I rememebr that it did not work with cabal 2.4
06:46:48 <pta2002> evelyn: can't, this is a school project, and the server doesn't allow libraries
06:47:27 <pie_> is there a minifier for haskell that imports everything into one source code file? ;D
06:50:05 <bushuo> Hi all, I have a list like this [["awake","awaken"],["awake","wake"],["dig","dog"],["dig","fig"],["fig","fin"],["fig","fog"],["fin","fine"],["fine","wine"], ...] how can i extract the longest sequence out of this. these length 2 lists are connections
06:50:09 <evelyn> pta2002: is this a technical restriction (like no network access) or a restriction in the assignment? In the former case I would just consider placing the microlens source with my code and work from there...
06:50:32 <pta2002> restriction in the assignment
06:50:37 <LKoen> bushuo: so you want to learn how to play domino?
06:50:41 <pta2002> i mean i can ask the teacher but yeah
06:50:51 <pta2002> we're learning haskell and i think the point is for us to do it ourselves
06:50:58 <pta2002> i should probably look into lens though
06:50:59 <bushuo> LKoen: sure ^^
06:51:35 <LKoen> bushuo: what do you know about graphs?
06:51:56 <LKoen> you're basically looking for the longest path in a graph
06:53:49 <bushuo> LKoen: yeah i thought about that. but i have only done graph algorithms in imperative languages. Still quite new to Haskell. and the graph is not fully connected its like a forest
06:54:36 <LKoen> a forest? you mean it acyclic?
06:54:47 <LKoen> that actually makes it more simple
06:55:07 <bushuo> LKoen yeah acyclic and many trees
06:55:42 <nil> so just find the longest path for every connected component and take the longest of those
07:05:21 <bushuo> ok i will try that. should i start with extracting every connected component from the list? :)
07:33:57 <sandman13> if I have something like this: "type M a = State -> (a, State)" what should I do to make "show" work?
07:34:18 <sandman13> do I have to implement the typeclass myself?
07:34:37 <merijn> sandman13: You can't really show functions, so I'm unsure what you'd expect that to even show?
07:35:11 <geekosaur> and "type" does not create a new type, it creates an alias; you can't create a Show instance for M
07:36:57 <sandman13> https://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf trying out code in ghci for now
07:38:16 <sandman13> Above code is from section 2.8 of that paper
07:44:28 <geekosaur> as noted, it'll be complaining abotu Show on a function type. theres an instance in Data.Function.Show iirc, which just says "<function>" because there's not a lot else to be done (not entirely true but there are strict limits)
07:47:15 <sandman13> in real code, it doesn't make much sense to print State as is, does it?
07:47:41 <sandman13> if I need to print it, I would have to extract the value and show it
07:47:50 <geekosaur> right, because it's a function (we generally refer to that kind f function as an action)
07:48:06 <geekosaur> you'd apply it and show the result, yes
07:49:49 <sandman13> it's been a long time since I have worked on Haskell, so I kind of forgot the terms and ways
07:49:51 <sandman13> :D
08:08:57 <siraben> When should I use IOThrows over ExceptT and vice versa?
08:25:08 <haselion> can someone here explains to me how default works???
08:25:13 <haselion> I'm very confused dude
08:26:00 <geekosaur> it's only going to make sense if you understand hwo type inference works in general
08:26:21 <haselion> please elaborate more geekosaur
08:26:28 <haselion> would you mind explaining what u meant?
08:26:58 <geekosaur> there are a handful of "special" typeclasses (Num, Eq, Show, Ord, some others, and ghci has an extended list) for which type inference will go "through" them instead of requiring the type be specified explicitly.
08:27:34 <geekosaur> if it does this and reaches the point where it can't work out a specific type, it tries substituting in the types from the default list until one typechecks
08:28:10 <geekosaur> this is most commonly used with `default (Double, Integer)` (the default default, if you will) so that numeric calculations will infer an appropriate numeric typee
08:28:51 <haselion> so when i typed literal 3, it actually can't be infered?
08:28:58 <geekosaur> modern ghci has some additional defaults, in particular it will try to infer lists for Foldable and () if it can't determine any other type; that last can produce surprises
08:29:00 <geekosaur> :t 3
08:29:03 <lambdabot> Num p => p
08:29:26 <haselion> but when i used default (), :t 3 becomes unknown
08:29:32 <geekosaur> that's the best it can do. but Num is one of the typeclasses it will try to keep going for
08:29:57 <geekosaur> right, because there's no situation in which (3 :: ()) typechecks
08:30:12 <geekosaur> unless you've defined a Num instance for (), which I wouldn't recommend
08:30:31 <geekosaur> (it'd be useless and would make error messages especially confusing)
08:31:06 <geekosaur> whereas (3 :: Double) typechecks as does (3 :: Integer) so it can resolve both of those
08:31:48 <geekosaur> also I misspoke earlier, the `default default` is `(Integer,Double)`, it only tries Double if Integer won't typecheck (because, say, you used `/`)
08:34:07 <haselion> geekosaur also mind helping another one?
08:35:43 <haselion> for a function accepting something typeconstrainted, and i gave it an instance it works correctly. But for a function returning something typeconstrained, I return it instance it shows error
08:35:47 <haselion> why is that?
08:35:58 <haselion> sorry for my noob question
08:36:27 <geekosaur> if you have a function of type: X a => ... -> a, a is chosen by the caller
08:37:07 <geekosaur> you do not get to pick an a yourself, you must accept whatever a the caller chooses and you can't ask what type they chose
08:38:30 <haselion> can you elaborate more, but it seems very intuitive for me at least (?)
08:38:46 <geekosaur> this is not object oriented programming, X is not a superclass that you can pick subclasses of
08:39:06 <haselion> f::(Num a)->b=>a
08:39:28 <geekosaur> X is a contract with the caller: "I can work with whatever instance of X you choose"
08:39:53 <geekosaur> but the caller does the choosing.
08:40:15 <geekosaur> :t (+)
08:40:16 <lambdabot> Num a => a -> a -> a
08:42:19 <haselion> why can't the callee choose too ?
08:42:20 <geekosaur> this means "for whatever type a the caller chooses, provided it has a Num instance, the operator `+` will combine two values of that type to produce a new value of that type"
08:42:41 <geekosaur> for one, neither the caller nor the callee can ask what type was chosen
08:43:19 <geekosaur> for another, you want something to be "fixed" or there's no way to do type inference
08:44:07 <geekosaur> and one particularly useful form of type inference is result polymorphism in typeclasses: the caller specifies which typeclss instance to use via the type of a function result
08:44:43 <geekosaur> in most languages, result types are fixed / can't be overloaded
08:45:19 <geekosaur> > maxBound :: Int -- maxBound :: Bounded a => a
08:45:22 <lambdabot>  9223372036854775807
08:45:44 <haselion> could you explain more this sentence ' the caller specifies which typeclss instance to use via the type of a function result' ?
08:45:50 <geekosaur> I just showed it
08:46:37 <geekosaur> maxBound is a method of the Bounded typeclass. I picked the specific Bounded instance to use by specifying the type of the result of `maxBound`
08:46:51 <haselion> so what happens there?
08:47:14 <haselion> I've always have difficulty understanding it too
08:47:22 <geekosaur> you'll need to learn about typeclasses or none of this will make much sense. typeclasses *are not* OOP classes, and trying to use them that way will quickly get you into trouble
08:47:23 <haselion> did we call first / how does it actually work?
08:48:08 <haselion> yeah I get the sense of typeclass already, so you can make function like + instead of plusInt etc (?)
08:48:19 <geekosaur> that was the original intent, yes
08:48:39 <haselion> the part i did not understand is how does it work, like when I call maxBound::Int, what happens there?
08:48:50 <haselion> maxBound return something and I cast it to Int ? or how 
08:49:07 <haselion> sorry if I'm so bad at this :(  
08:49:24 <geekosaur> :: is not a cast, it does no conversion. it specifies the type I wan t and if the expression can't take that type a type error is raised
08:49:35 <geekosaur> there is no casting as such, aside from specific functions
08:49:41 <geekosaur> ::t fromIntegral
08:49:45 <geekosaur> er
08:49:48 <geekosaur> :t fromIntegral
08:49:50 <lambdabot> (Integral a, Num b) => a -> b
08:49:50 <haselion> ah okay that's casting
08:50:17 <haselion> so :: is compiler annotation ?
08:50:23 <geekosaur> but it only works in that case. since you can arbitrarily extend a typeclass, there's no way for the language to know how to "cast"
08:50:42 <geekosaur> yes, it's an annotation
08:51:18 <geekosaur> I could also set the type some other way, although simple examples are kinda silly
08:51:41 <geekosaur> :t maxBound `asTypeOf` length "abc" -- nobody would actually do this, of course
08:51:42 <lambdabot> Int
08:53:30 <geekosaur> it's more useful for inferring that if an expression uses `length` then it's going to be computing an `Int`
08:53:43 <haselion> thanks
08:53:45 <haselion> a lot
08:53:56 <geekosaur> which is inferring `Num` rather than `Bounded`
08:57:33 <sondr3> question, does anyone have a good way to organise a Haskell project for Advent of Code? Or just examples, I did the last year in Rust but want to practice Haskell this year and last year I created individual binaries for each day that I could run... is something like this possible with Cabal?
08:58:22 <dcoutts> sondr3: you can have multiple executables in a single cabal package, if that helps.
08:58:52 <sondr3> dcoutts: yeah, that sounds like exactly what I want
09:00:01 <dcoutts> so just use multiple "executable" stanzas in the .cabal file. You can decide if you use a shared source tree, or separate source subdirs
09:01:05 <dmwit> sondr3: You could do a lot worse than copying what glguy does: https://github.com/glguy/advent2018 (tl;dr he uses the feature dcoutts just told you about).
09:01:35 <sondr3> dmwit: awesome, thank you, looks exactly like what I want! 
09:01:41 <sondr3> dcoutts: thanks a lot, just found it in the documentation
09:11:42 <cheater> how do you pattern-match against a value stored in a variable?
09:11:51 <cheater> eg let s = 2; foo s = ...
09:11:56 <cheater> guards only?
09:13:49 <cheater> i don't want s to be captured here, i want the arg to be compared against the value of s that exists before foo is defined
09:14:08 <geekosaur> cheater, yes, use guards
09:14:29 <geekosaur> or explicit case s of ...
09:15:22 <cheater> i would still need to do something like let z = myfunc ...; case s of z
09:15:27 <cheater> which then just captures s into z
09:15:32 <cheater> rather than compare s against z
09:15:32 <geekosaur> that has to be done with a guard
09:15:36 <cheater> yes
09:15:38 <cheater> ok, thanks
09:15:54 <geekosaur> patterns match constructor structure, not values
09:21:58 <cheater> yep
10:00:09 <tomjaguarpaw> Suppose I write the following.  What sense, if any, does Foo make as something of kind *?
10:00:12 <tomjaguarpaw> data Foo = Foo Type
10:00:14 <tomjaguarpaw> foo :: Foo
10:00:17 <tomjaguarpaw> foo = Foo _
10:00:30 <tomjaguarpaw> There's nothing I can fill in for that _, surely?  How does it even make sense to write `foo :: Foo`?
10:01:27 <Ariakenom> tomjaguarpaw: it does not
10:01:38 <geekosaur> you're confusing type and value level. Foo is a type of kind * (no parameter), and a value level (data) constructor that takes a parameter
10:02:06 <geekosaur> and yu can fll lin any value but can't' really get it back out or do anything with it, as written
10:02:22 <Ariakenom> data Foo = MkFoo Int; Foo has kind *; MkFoo has type (Int -> Foo)
10:02:41 <geekosaur> rephrasing as a GADT would allow the pattern match to extract the value and its type
10:03:06 <merijn> https://i.imgflip.com/3i33dm.jpg
10:03:38 <Ariakenom> oh I thought "Type" wasn't *
10:03:52 <merijn> Ariakenom: It is with TypeInType and that other extension
10:04:21 <geekosaur> TypeInType does lead to interesting messes, yes
10:04:28 <Ariakenom> I meant I thought it was just an unfortunately chosen placeholder type
10:04:38 <tomjaguarpaw> geekosaur: I can't fill in any type.  It wants something of type *, but * is not a type!
10:04:49 <merijn> Galaxy Brain take: TypeInType exists solely to finally make type level worse enough that it motivates people to switch to Idris
10:05:17 <Ariakenom> tomjaguarpaw: why are you using both * and Type. they are the same
10:05:33 <geekosaur> oh, right, Type has specific meaning these days. yug
10:05:36 <tomjaguarpaw> Sure, I'm writing Type in my program, GHC is saying "*" in its error message.
10:05:37 <geekosaur> that's a mess
10:05:40 <geekosaur> yes
10:05:55 <geekosaur> error messages haven't been rewired for NoStarIsType yet
10:06:14 <tomjaguarpaw> I'm confused why I can even write the type signature `foo :: Foo`
10:06:17 <tomjaguarpaw> It's not well-kinded
10:06:28 <tomjaguarpaw> unless there's something I'm missing
10:06:38 <tomjaguarpaw> (8.4.4 btw.  Maybe something's changed.)
10:07:27 <geekosaur> minus DataKinds it's well kinded, data Foo = Foo Int is fine, Foo the type :: *, Foo the value :: Int -> Foo
10:07:37 <geekosaur> Type there makes a mess
10:08:28 <geekosaur> because TypeInType implicitly assumes types get promoted to kinds, but Type has no "de-promotion" to a type (that direction doesn't exist)
10:08:59 <geekosaur> in short, merijn's jpg has a point :)
10:09:00 <tomjaguarpaw> Even absent DataKinds the following compiles fine
10:09:01 <tomjaguarpaw> data Foo = MkFoo Type
10:09:01 <tomjaguarpaw> foo :: Foo
10:09:01 <tomjaguarpaw> foo = MkFoo undefined
10:09:28 <dsal> Is there a way to see the code TH generates?
10:09:41 <geekosaur> right, it's promotion that leads to confusion. in terms of Haskell it's meaningful, in terms of TypeInType + DataKinds it gets confused trying to build the promoted type
10:09:51 <geekosaur> dsal, -ddump-splices
10:09:52 <merijn> dsal: -ddump-splices
10:09:59 <orzo> I think the registerTimeout function should be callable from within an STM transaction
10:10:33 <merijn> orzo: That doesn't seem transactional, though?
10:10:56 <merijn> orzo: Also seems rather trivial to set it a timeout to update STM code?
10:11:11 <dsal> geekosaur, merijn: nice, thanks.   It does what I wanted, except it made gross  names.
10:11:16 <orzo> well, here's my situation, maybe you can help
10:11:46 <dsal> Ah, newName vs. mkName
10:14:02 <orzo> i have a query being sent, and the a response arriving.  I'm using a registerTimeout to set a timer to indicate the query timed out.  But i'm canceling that timer when the response arrive using unregisterTimeout
10:14:33 <orzo> setting that up in a logically non-racey manner is proving difficult
10:14:39 * hackage hledger-lib 1.16 - Core data types, parsers and functionality for the hledger accounting tools  https://hackage.haskell.org/package/hledger-lib-1.16 (SimonMichael)
10:14:45 <merijn> "the query" what query? To a database?
10:14:48 <orzo> the unregisterTimeout function needs a timer object that's already been registered
10:14:50 <merijn> To some server?
10:15:03 <orzo> the code is reused in multiple situations, but typically to a server
10:15:13 <siraben> Why does the definition of xs *> ys for lists not xs *> ys = ys ?  https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html
10:15:14 <siraben> It's written as xs *> ys  = [y | _ <- xs, y <- ys] instead. Does it not make a difference since Haskell is lazy?
10:15:39 * hackage hledger-web 1.16, hledger-ui 1.16, hledger 1.16 (SimonMichael): https://qbin.io/md-motion-p9zf
10:15:46 <siraben> Ah, I just got the semantics wrong. 
10:15:47 <merijn> siraben: Because your definition isn't correct, it returns too few elements
10:15:54 <siraben> take 50 ([1..] *> [1..10])
10:16:01 <siraben> > take 50 ([1..] *> [1..10])
10:16:04 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,...
10:16:29 <merijn> orzo: So what are you trying to do upon timeout and why did you want to do it in STM?
10:16:39 <orzo> when i send the query, i store (via STM) an action to occur upon response
10:16:59 <siraben> merijn:  So what is *> supposed to do in the context of lists?
10:17:03 <orzo> one of the things the action does is unregister the timeout
10:17:24 <merijn> orzo: Oh, that's fairly simple, I think?
10:17:44 <siraben> > foo xs ys = concatMap (const ys) xs
10:17:47 <lambdabot>  <hint>:1:11: error:
10:17:47 <lambdabot>      parse error on input ‘=’
10:17:47 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
10:18:13 <orzo> well, does the stm action that stores the on-response action happen before or after registerTimeout?  One way screws up a response that is too fast and the other way screws up if it is too slow
10:18:14 <merijn> orzo: Have a TMVar with the action upon response, have the response handler do "tryTakeTMVar" (or whatever it's called) if it gets Just, run the action, if Nothing it timed out
10:18:27 <siraben> > let foo xs ys = concatMap (const ys) xs in take 50 % foo [1..] [1..10]
10:18:29 <siraben> let foo xs ys = concatMap (const ys) xs in take 50 (foo [1..] [1..10])
10:18:30 <lambdabot>  error:
10:18:30 <lambdabot>      • Couldn't match expected type ‘[a] -> [a]’
10:18:30 <lambdabot>                    with actual type ‘[Integer]’
10:18:31 <siraben> Well, yeah, it's like concatMap with const?
10:18:42 <merijn> orzo: Then register the time to "atomically $ tryTakeTMVar ..." to remove the callback
10:19:18 <merijn> orzo: If the response was already done the tryTakeTMVar gets nothing and becomes a no-op, if the timeout occurs first the response handler becomes a noop
10:19:43 <orzo> well, i was trying to avoid having too many dangling no-op timers registered
10:20:01 <merijn> orzo: Well, you can always unregister the noop timer upon success *too*
10:20:20 <orzo> what is success
10:20:25 <orzo> a response?
10:20:52 <orzo> i can't unregister a timeer until it's been registered
10:20:55 <merijn> orzo: Yeah, so upon response take the response handler first, then handle the response and unregister the timeout
10:22:03 <merijn> create TMVar with response action, register time out, start request, upon response take the response action then run the action and unregister timer (in whatever order)
10:23:39 * hackage weigh 0.0.15 - Measure allocations of a Haskell functions/values  https://hackage.haskell.org/package/weigh-0.0.15 (ChrisDone)
10:24:14 <dmj`> jle`: nothing like a warm glass of milk and some advent of code this christmas
10:24:27 <dmj`> with maybe some ginger snaps on the side
10:24:39 * hackage sdl-try-drivers 0.0.0.2 - small testing tool for sdl2 and accelerated drivers  https://hackage.haskell.org/package/sdl-try-drivers-0.0.0.2 (typetetris)
10:24:56 <jle`> hear hear
10:31:16 <orzo> merijn: currently, the transaction that stores the response-action also decides the expiry
10:31:21 <orzo> the expiry of the timeout
10:31:34 <dmj`> calling read on a String makes me happy
10:32:01 <merijn> orzo: Why is that in a transaction, though? And why does it have to be?
10:32:29 <orzo> well, the network protocol changes it timeout behavior based on conditions
10:32:39 * hackage weigh 0.0.16 - Measure allocations of a Haskell functions/values  https://hackage.haskell.org/package/weigh-0.0.16 (ChrisDone)
10:33:02 <orzo> so the expiry has to be a decision based on state
10:33:38 <merijn> Yeah, but why does it have to be a single transaction?
10:38:27 <orzo> the code that decidedes the expiry is givien a query-id that is generated in the same transaction that stores the response and acts as a key to that response
10:40:14 <geekosaur> I think you're conflating two different kinds of transaction
10:40:53 <orzo> i carefully avoided using the word transaction if i'm not talking aobut an STM transaction
10:41:18 <orzo> query-id is an identifier for the network query
10:41:43 <merijn> I fail to see why which transaction generates the key is relevant for which code does something with it?
10:42:19 <merijn> Anyway, I think this is too vague for me to say something useful
10:43:00 <orzo> well, anyway, why is registerTimeout "not transacitonal"
10:43:20 <orzo> registerTimeout is modifying some state, which I as far as I can see, could be STM state
10:43:34 <merijn> For one, if the timeout is exceeded before the transaction aborts you can rollback the registration
10:43:52 <merijn> orzo: The timeout can do arbitrary IO which you cannot rollback
10:44:34 <orzo> but you dont understand the proposal.  The upon-timeout-event is an IO action.  It is the 'registerTimeout' function itself that happens within STM
10:44:39 * hackage AesonBson 0.4.0 - Mapping between Aeson's JSON and Bson objects.  https://hackage.haskell.org/package/AesonBson-0.4.0 (NiklasHambuechen)
10:44:53 <merijn> orzo: That's the problem
10:45:12 <merijn> orzo: How do you rollback "registering a timeout" if the IO action has already fired? You can't
10:45:35 <habbah> is there a function which takes an "m a" and returns an IO a?
10:45:47 <orzo> the timer wouldn't even start counting until the STM transaction succeded
10:45:47 <merijn> habbah: Depends on the 'm a'
10:45:56 <orzo> so the IO action could not fire before that
10:46:09 <merijn> orzo: But that's ust the same as returning an IO action that registers the timeout from your transaction
10:46:15 <merijn> orzo: Which you can already do
10:46:25 <sleblanc> habbah, you just need a function (m a) -> a, then it is trivial to wrap that value in IO
10:46:50 <ChaiTRex> habbah: Not in general. For example, what wauld ([] a) produce for an infinite list?
10:46:53 <geekosaur> "just"
10:47:00 <sleblanc> habbah, thing is, a value of type (m a) is an especially vague type
10:48:30 <merijn> orzo: Nothing stops you from building IO actions inside STM and then returning them from the transaction. You just can't run those IO actions inside the transaction
10:48:31 <habbah> this m has an instance of Monad, Functor, MonadFix, MonadIO
10:48:40 <merijn> None of those help
10:48:46 <merijn> MonadUnliftIO might
10:49:08 <habbah> MonadReader?
10:49:13 <merijn> Doesn't help
10:49:23 <habbah> Applicative?
10:49:27 <merijn> Nope
10:49:30 <habbah> ok
10:50:37 <geekosaur> how about telling us the problem you're trying to solve, instead of playing twenty questions
10:50:51 <habbah> sleblanc: I like your suggestion. 
10:51:09 <orzo> merijn: i suppose you're right, but the probably pointless feature would save me some a lot of work with my current code base
10:51:13 <orzo> heh
10:51:30 <geekosaur> it's not that it's pointless, it's that it's not possible in many use cases
10:52:15 <orzo> it's pointless and always possible as it's equivelent to invoking an IO action returned from STM that registers a timeout.
10:52:16 <geekosaur> let's say this is a callback of type IO a, and you want to pass a StateT Something IO a. how does a change in the state make it from when the callback is invoked back into your program?
10:52:31 <geekosaur> oh, wrong thread, sorry
10:54:35 <geekosaur> as for yours, a timeout is a callback stored in global state, which sounds IO to me. unless you have your timeouts as TChan entries or some such (maybe an STM pqueue), but having it fire still wants something that is IO-ish
10:55:36 <sleblanc> habbah, where/how are you getting your value?
10:56:03 <geekosaur> and you can't fire that within STM because nothing can be done on `retry` to undo it. unless that fires from outside on a regular schedule and accesses (again) an STM pqueue or whatever to invoke callbacks
10:56:11 <sleblanc> note that i'm in no way an expert here, so you might be better served with other users' advice
10:58:08 <Athas> How do I pass RTS options when using 'cabal bench'?  There apparently used to be a --benchmark-options option, but it is reject by cabal 3.0.0.0.
10:59:43 <merijn> Athas: hmm, I generally just use cabal run when I wanna run individual benchmarks/test with options
11:00:33 <Athas> merijn: so you don't use the 'benchmarks' section in .cabal files?
11:00:40 <merijn> Athas: Those work with run too
11:01:12 <merijn> Athas: The problem is that test/bench run ALL of them, which means it becomes hard to have a consistent/logical way to pass options to a single one
11:01:43 <Athas> Okay, but then the cabal executable eats the +RTS option.  I guess I need to pass --RTS or something?
11:02:01 <merijn> Athas: -- before options, that also disables consuming +RTS
11:02:22 <Athas> Doesn't look like it does.
11:02:29 <dsal> Is there a sensible mconcatM sort of thing I'm missing?    I'm doing mconcat <$> traverse
11:02:32 <Athas> Ah, wait, it does.
11:02:41 <Athas> Well, great.
11:02:54 <merijn> Athas: I was about to say, because I 300% sure I've used that in 3.0 :p
11:03:13 <cocreature> the -- thing is part of the flag parser in the RTS so it works for any Haskell app
11:03:50 <Athas> Uh.  What exactly is the "--" thing in general, then?  That RTS options are ignored after any "--" entry in argv?
11:04:01 <cocreature> yep
11:04:22 <Athas> Fair workaround, I guess.
11:05:49 <cocreature> https://gitlab.haskell.org/ghc/ghc/blob/master/rts%2FRtsFlags.c#L701
11:06:27 <orzo> merijn: I have a bug, possibly related to the registerTimer issue, that causes a lot of things to stop working.  Apparently threadDelay hangs forever.  Any insights into what might cause that?  I also use the "timeout" function in places and i had a theory that I was using it with some non-interruptable action and that's causing all kinds of time-related badness.
11:07:07 <Athas> cocreature: is that really only documented in the source code?
11:07:19 <Athas> The GHC manual does not mention it at all.  It mentions --RTS, which I think has the same effect.
11:08:47 <cocreature> Athas: sadly I think it is. I remember that I wanted to write docs when I found this but then I forgot about it :)
11:09:30 <Athas> I guess I have now also become the carrier of hidden folk wisdom.
11:09:56 <cocreature> it is more fun to spread hidden folk wisdom than linking people to the docs
11:09:57 <Athas> Feels much more authentic when software is documented by oral tradition.
11:11:39 * hackage ghc-lib-parser 0.20191201 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-0.20191201 (shayne_fletcher)
11:12:31 <geekosaur> -- is a POSIX-specified thing, not ghc specific
11:12:32 <merijn> Athas: How else will we cultivate our aura of mystical shamans once people find this whole functional thing isn't really *that* difficult... >.>
11:12:39 * hackage ghc-lib 0.20191201 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-0.20191201 (shayne_fletcher)
11:13:15 <geekosaur> it turns off all option parsing from that point on so things that otherwise look like options will be taken as parameters
11:13:29 <cocreature> geekosaur: sure but it still seems worth pointing out in the docs somewhere that this works for GHC RTS options
11:13:36 <Athas> geekosaur: that's not literally what it means in this context, though.
11:13:45 <geekosaur> which can pass them through to other programs, or let you (say) remove a file that starts with -
11:13:49 <Athas> Except with a certain interpretation of what the GHC RTS does for you, I suppose.
11:13:53 * merijn calls "Not it" for updating the docs
11:14:09 <merijn> Hah, now one of your suckers has to
11:14:23 <Athas> Man, I have enough trouble documenting one compiler already.
11:14:51 <merijn> See, that's why my code isn't documented! ;)
11:15:13 <merijn> (That's not actually true, I have a readme *and* all my commandline options and commands are documented!)
11:15:41 <cocreature> documenting things is horrible. then you might get users and they will find bugs and complain about your docs and all of that causes a ton of work
11:15:51 <merijn> cocreature: Word.
11:16:52 <merijn> cocreature: OTOH, then I could skip writing tests and make users do it for me :p
11:17:45 <Athas> I fear my mind is fundamentally incompatible with Haskell's parallel strategies.  I can spend all day writing actual lecture material on how to use them, and the next day I have to look up how to something as trivial as parallelise divide-and-conquer.
11:20:20 <cocreature> Athas: I’ve taken the fact that nobody seems to use them as an indicator that they are incompatible with most people’s minds :)
11:21:02 <Athas> Right!  Well, they are more used (based on Hackage statistics) than the otherwise much more comprehensible Par monad, but I suspect most of the uses are wrong, or just use some simple pattern cribbed from an example.
11:21:09 <dsal> TH is kind of neat.  I found the bug on generating comments with an idea from SPJ from like, 8 years ago.  Guessing that's not happening any time soon.  For the stuff I'm doing right now, though, this is pretty nice: https://github.com/dustin/tesla/commit/cabd8b1a80bd2b80d072ca9a55f6d39a8294fb58
11:21:54 <merijn> dsal: Typed TH is even neat :)
11:22:18 <dsal> I think I'm not on the right level.  What's that do?
11:22:52 <merijn> dsal: Normal TH is untyped (i.e. you can create Haskell ASTs that fail to compile due to type errors
11:22:55 <dsal> I was kind of annoyed that I had to use mkName for all of my symbols.  It didn't  seem to know how to deal with my type aliases or constraints.
11:23:14 <dsal> Ah, I see.
11:23:15 <cocreature> Athas: I remember some quote from simon marlow that he also doesn’t really like the strategies stuff and prefers Par :)
11:23:22 <merijn> dsal: "Now" (this was added like 5 years ago by now xD) there's typed TH which guarantees all generated ASTs are well typed
11:23:39 <Athas> cocreature: and Simon wrote several papers on patching up strategies!  He also wrote Par.
11:24:02 <Athas> Par is probably my favourite task parallel model, out of any language.  It's not terribly fast, but that's just Haskell Things.
11:24:23 <merijn> dsal: The TH seems overkill there? xD
11:24:48 <dsal> Maybe a little.  Writing these out sucked:  https://github.com/dustin/tesla/blob/master/src/Tesla/Command/Media.hs
11:25:10 <dsal> That generates a bunch of    volumeDown :: forall m. MonadIO m => Car m CommandResponse
11:25:22 <dsal> I figured since I'm doing it, might as well use it more places.  It's nice.
11:27:18 <dsal> I could get fancier with named parameters for the commands that require junk.  I've got some that want a lat/lon pair, some ints, some bools.  I did seat heating with an enum of which seats I want heated.  Since that code's all done, it'd be overkill, though.
11:27:39 <tomjaguarpaw> merijn: data Foo = Foo Type does not require TypeInType, actually.  At least, it doesn't reqire me to turn on the extension (or indeed *any* extensions)
11:33:00 <geekosaur> that's the essence of the problem. what, if anything, does that even mean?
11:33:49 <dsal> Is this super gross as a convenience method for grabbing a bag of things? https://www.irccloud.com/pastebin/PC78RPWu/export.hs
11:34:34 <geekosaur> and behind this two questions:
11:34:36 <merijn> dsal: I use the same sometimes
11:34:47 <geekosaur> 1) what does Type mena when used as a type nstead of as a kind?
11:34:59 <dsal> I made a bunch of tiny modules with  like, one or two things, but in practice, I probably want all of them.  Thanks.
11:35:37 <tomjaguarpaw> geekosaur: I guess it's uninhabited as a type
11:35:39 <geekosaur> 2) ghc internally assumes and uses TypeInType, but throws if a user writes code that requires it without enabling it. but just as it didn't come up with an answer for (1), it lets this pass and then becomes confused later
11:36:03 <merijn> geekosaur: Honestly, I've done quite a lot of type level hackery and abuse, but TypeInType confuses the fuck outta me and I don't understand all these crazy people who claim its sensible...
11:36:51 <geekosaur> seems to me it's sensible iff you always ascend the hierarchy, it's descent (as here) that's asking for confusion
11:38:46 <merijn> geekosaur: I don't even think it's sensible going up, the main complaint of DataKinds is that it makes types ambiguous, TypeInType just extends that confusion infinitely. Stratified universes are way more clear and unambiguous
11:42:02 <nshepperd> makes sense to me. Type is a type that contains no values, just like Void
11:43:51 <geekosaur> did you look at the start of this thread?
11:47:35 <geekosaur> merijn, my problem witht hat one is that it's a sunk cost. Haskell lets you reuse a type constructor name as a data constructor; TypeInType + DataKinds extends that (granted, impicitly; this should be fixed not with removal but with marking things to be promoted), and arguably stratification would mean not allowing name reuse between type and kind
11:47:36 <geekosaur> level, etc. and extending that downward as well.
11:47:57 <geekosaur> not that extending it downward wouldn't have an anti-confusion benefit, but it'd also break massive amounts of code
11:48:57 <nshepperd> % seq ([undefined] :: [Type]) ()
11:48:57 <yahb> nshepperd: ()
11:49:16 <Athas> I wonder how many download the binary cabal release for AIX.
11:49:28 <merijn> To many :p
11:55:14 <maralorn> What I don‘t like about hoogle: Whenever I look for a conversionfunction it suggests unsafeCoerce.
11:59:10 <geekosaur> type directed search has its downsides
12:05:37 <monochrom> Something is wrong if cabal-install is built for AIX but ghc isn't :)
12:13:03 <iqubic> @pl \x -> (x `div` 3) - 2
12:13:04 <lambdabot> subtract 2 . (`div` 3)
12:15:32 <iqubic> Here's my pointless solution to day 1 of AoC: http://dpaste.com/079GRFW
12:16:49 <iqubic> And yes, I did just rewrite the fuel function using lambdabot's help.
12:19:23 <iqubic> Is there a Megaparsec parser of type "Parser String" that returns the input? So, basically does no parsing at all.
12:20:39 * hackage ttc 0.1.0.1 - Textual Type Classes  https://hackage.haskell.org/package/ttc-0.1.0.1 (TravisCardwell)
12:20:47 <merijn> iqubic: Multiple
12:21:57 <iqubic> What are they called?
12:22:34 <merijn> There was one that just returned the entire remaining input, but I forget the name
12:22:54 <dsal> What's the thing that spits out reasonable bounds for my dependencies?
12:23:04 <dsal> I'm using stack, but I remember some cabal command that did the thing.
12:23:17 <geekosaur> cabal freeze?
12:23:18 <sleblanc> iqubic, what about "return []" ^
12:23:31 <merijn> geekosaur: That doesn't spit out bounds, though
12:23:52 <merijn> dsal: The reasonable bounds are "lower bound equal to your current local version, upperbound as per the PVP"
12:23:55 <merijn> @where pvp
12:23:55 <lambdabot> https://pvp.haskell.org/
12:24:15 <dsal> Yeah, there was some command that would do all of  that for me.
12:26:39 <dsal> Ah, it's   cabal gen-bounds
12:27:27 <sleblanc> iqubic, apparently, you can use "getInput"
12:28:39 <dsal> Except it doesn't build with those constraints.  Neat.
12:28:46 <sleblanc> iqubic https://hackage.haskell.org/package/megaparsec-8.0.0/docs/Text-Megaparsec.html#v:getInput
12:30:17 <iqubic> If I pass scanl1 an infinite list, can I still get the first, second, and third elements of the output?
12:30:50 <amalloy> > take 5 $ scanl1 (+) [0..]
12:30:53 <lambdabot>  [0,1,3,6,10]
12:30:56 <iqubic> Cool.
12:31:26 <iqubic> I just came up with a nice way to solve AoC 2018 day 1 part 2.
12:31:30 <amalloy> iqubic: for such simple questions it's often easier to try it and see than it is to even ask
12:31:47 <dminuoso> Or, just look up the source and judge for yourself.
12:31:55 <dminuoso> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.List.html#scanl
12:32:36 <iqubic> part2 = firstDup . scanl1 (+) . cycle -- or something similar.
12:33:14 <iqubic> amalloy: That's actually the solution you came up with in your video.
12:33:31 <amalloy> well, except i don't like scanl1
12:33:55 <iqubic> Why not?
12:34:00 <merijn> dsal: Which version of cabal-install do you have?
12:34:01 <amalloy> i used scanl (+) 0, which is a character longer but isn't partial
12:34:21 <dsal> merijn: I  don't seem to have it.  I don't use cabal much directly.
12:34:27 <aveltras> has anyone somehow integrated ghcid and emacs ? by this i mean more tightly than just having a buffer open with ghcid output but something like error highlighting
12:34:34 <dsal> Oh, that's cabal.
12:34:35 <dsal> cabal-install version 3.0.0.0
12:34:38 <merijn> dsal: The cabal executable *is* cabal-install :)
12:34:55 <merijn> dsal: This is why I wrote: https://gist.github.com/merijn/8152d561fb8b011f9313c48d876ceb07 ;)
12:35:11 <merijn> hmm, that's weird that it doesn't build. I was expecting 2.4 or earlier
12:35:46 <merijn> What's the error?
12:35:51 <merijn> Oh!
12:35:55 <dsal> Oh, I mean it just spat out bounds that weren't useful.
12:36:01 <merijn> What's your system GHC?
12:36:05 <dsal> All the lower bounds were > LTS
12:36:15 <dsal> oh, 8.8.1
12:36:29 <merijn> dsal: And your LTS uses 8.8 too?
12:36:40 <dsal> I don't use system ghc.  I have a lot of things where I just pressed "yeah, yeah, yeah" a bunch until it started building.
12:36:55 <dsal> LTS should be 8.6.5
12:36:57 <merijn> dsal: "I don't use system ghc" <- cabal does unless you tell it differently
12:37:10 <merijn> dsal: cabal-install will just use whatever one is in your path
12:37:14 <dsal> Right.  I just mean I've got lots of things I don't know anything about.
12:37:42 <merijn> dsal: So if your bounds are based on your 8.6.5 version it's imaginable they don't work with 8.8
12:37:55 <dsal> It was the other way around, it seems.
12:39:51 <juliusdeane> Does anyone know if there are libraries out there for working with the international phonetic alphabet?
12:44:17 <dibblego> in what way exactly?
12:45:18 <juliusdeane> Simple stuff, mostly. Mainly useful would be some sort of IPA letter datatype that has Show and Eq instances
12:45:49 <dibblego> which does what?
12:46:32 <juliusdeane> The functionality wouldn't really matter.
12:46:36 <sleblanc> juliusdeane, I think it would take you less time to write a sum type that contains all letters (data NATO = Alpha | Bravo | Charlie…) than trying to find a library that provides everything you need in the way you want
12:46:55 <juliusdeane> Alright
12:46:59 <dibblego> http://hackage.haskell.org/package/alphachar
12:47:00 <sleblanc> then provide a function 'charToNato c'
12:48:22 <sleblanc> dibblego, wow, the author of this package has this as their email address: <oᴉ˙ldɟb@llǝʞsɐɥ>
12:48:33 <dibblego> What would it return for '4' ?
12:48:43 <dibblego> sleblanc: yes, to stop spammers
12:48:45 <sleblanc> dibblego, Nothing
12:48:54 <dibblego> why nothing?
12:49:02 <sleblanc> cuz not nato alphabet
12:49:13 <dibblego> also, yesterday I had to use BN in quick succession, so it is pronounced differently
12:49:30 <sleblanc> (ok, then, the type would be named "NATOAlphabet")
12:50:00 <dibblego> yes, it is pronounced fow-er with particular stress on syllables
12:51:16 <dibblego> thare also groupings if you take it all the way
12:51:31 <dibblego> and pronunciation that depends on context
12:51:32 <sleblanc> (also Quebec is pronounced Keh-beck and not Kwe-beck)
12:52:01 <sleblanc> I suppose juliusdeane (who left) is not interested in writing a text to speech engine
12:52:27 <dibblego> right, but I was wondering, then what?
12:53:29 <sleblanc> beyond that, it's an implementation spec entirely dependent on your use case
13:02:37 <nshepperd2> IPA is a different thing to the nato alphabet
13:03:41 <merijn> Entirely different, even
13:06:24 <geekosaur> sadly, "IPA" is also used to refer to the NATO alphabet. probably shouldn't be, but.
13:07:15 <sleblanc> oh dang, i just assumed NATO phonetic. i'm aware of what the IPA is
13:09:15 <dibblego> "8300" is either "eight three zero zero" or "eighty three hundred", depending on its context
13:10:05 <iqubic> I prefer to call it the NATO Phonetic Alphabet.
13:10:16 <dibblego> (ICAO)
13:10:34 <iqubic> But when I read IPA, I thought of beer at first.
13:12:39 * hackage tesla 0.1.0.0 - Tesla API client.  https://hackage.haskell.org/package/tesla-0.1.0.0 (dustin)
13:17:46 <maralorn> I am confused: When I use parseTimeM with m = Either String, how can `fail` lead to a runtime panic? Why doesn‘t it give me a "Left"?
13:18:21 <maralorn> How can "fail" lead to a runtime error in any case?
13:21:19 <geekosaur> make sure that's the instance it actually used. there are monads which have fail = error
13:21:22 <merijn> maralorn: Which GHC version?
13:21:33 <maralorn> 8.6.5
13:22:10 <merijn> maralorn: Enable MonadFailDesugaring
13:22:10 <geekosaur> I should say MonadFail-s these days
13:22:36 <merijn> maralorn: The answer is: Either isn't an instance of MonadFail
13:22:41 <maralorn> merijn: parseTimeM does not use MonadFail
13:22:53 <geekosaur> it uses fail, you said
13:23:03 <merijn> maralorn: It does in the latest version of time
13:23:16 <merijn> maralorn: https://hackage.haskell.org/package/time-1.9.3/docs/Data-Time-Format.html#v:parseTimeM
13:30:49 <nshepperd1> The old pre-monadfail definition of fail for Either had to be error, since there were no constraints on the Monad instance
13:33:23 <geekosaur> hm? Either itself is ill-kinded, Either String had the instance, and fail = Left should typecheck
13:33:39 * hackage vector-algorithms 0.8.0.3 - Efficient algorithms for vector arrays  https://hackage.haskell.org/package/vector-algorithms-0.8.0.3 (ErikDeCastroLopo)
13:36:09 * hackage niv 0.2.5 - Easy dependency management for Nix projects  https://hackage.haskell.org/package/niv-0.2.5 (nmattia)
13:47:57 <aplainzetakind> Is there a difference in efficiency between Text and ByteString (when parsing, specifically)?
13:48:41 <merijn> Well, one is correct the other is wrong, so there's that
13:48:51 <merijn> Which one is wrong depends on what you're parsing
13:49:33 <dsal> Man, I didn't know AoC started.  I'm behind.  heh
13:50:30 <aplainzetakind> merijn: List of numbers from the AoC input, specifically.
13:50:58 <merijn> For AoC's amount of input the speed isn't going to matter
13:51:12 <merijn> That's starts to matter when we're talking gigabytes of data
13:51:20 <merijn> And you should just use Text, because aoc is text
13:51:48 <merijn> aplainzetakind: By "what you're parsing" I meant "binary data" vs "textual data"
13:51:52 <refusenick> How expensive is compiling to categories? Would it be possible to use it to map Haskell programs to the category of graphs to get something like OCaml's Irmin?
13:52:27 <refusenick> https://github.com/mirage/irmin
13:52:39 <refusenick> Something like that could make package management easier.
13:52:47 <aplainzetakind> merijn: OK, thanks.
13:53:20 <refusenick> I suppose mapping dependencies and type signatures would be sufficient.
14:07:30 <aplainzetakind> What's the right way to get file contents as Text? pack'ing after readFile feels sketchy.
14:08:08 <MarcelineVQ> use text's IO module
14:08:18 <c_wraith> the right way is to read as a bytestring and then convert to text with the correct encoding
14:08:23 <MarcelineVQ> there's lazy and not
14:10:10 <merijn> c_wraith: Data.Text.IO.readFile is fine too
14:10:21 <c_wraith> if your data is in the system encoding
14:10:50 <c_wraith> If you can't guarantee what the system encoding that, you should explicitly use the correct encoding for your data.
14:10:50 <merijn> Sure, but that's a reasonable assumption for many usecases, especially one as simple as AoC
14:10:57 <dsal> aplainzetakind: For  the first couple of days, my  parser is basically     fmap read . lines <$> readFile "input/day1"
14:11:44 <dsal> I eventually break out megaparsec (probably too early), but "list of space separated numbers" is usually a thing you'd just do in ghci when playing around.
14:11:44 <c_wraith> merijn: but the question was "what is the right way"?  The right way is strangely verbose.  Why doesn't Text have something that combines IO and explicit encoding?
14:11:51 <aplainzetakind> dsal: I'm trying to get good performance with a large "challenge" input.
14:12:09 <merijn> c_wraith: Patches welcome? ;)
14:12:19 <dsal> Ah, makes sense.  Start with criterion.  :)
14:12:38 <c_wraith> how big?  I think the obvious code on strings could work with gigabytes basically as fast as they can read from disk
14:13:14 <aplainzetakind> merijn: Switching to Text from the wrong ByteString with pretty much everything the same seems to have cost me about 5% in time.
14:14:38 <c_wraith> I really did enjoy the line "the remaining mass, if any, is instead handled by wishing really hard, which has no mass and is outside the scope of this calculation."
14:14:51 <higherorder> Hello! Quick question: how can I prettify the default output of `show` for a tree of ADTs?
14:15:04 <higherorder> I want to print it out on multiple lines as opposed to a single one
14:15:21 <merijn> @hackage pretty-show
14:15:22 <lambdabot> http://hackage.haskell.org/package/pretty-show
14:15:28 <maralorn> merijn: That is nice. But I don‘t have time-1.9.3 here …
14:16:10 <higherorder> merijn: Basically I want to prettify the output of a failing hunit test (which dumps two big expressions not matching). Should I use `read` then `pretty-show`? or is there a direct way to prettify it?
14:16:16 <merijn> maralorn: In the older versions fail is method of Monad and all monads without a sensible fail (like Either) use error
14:16:48 <maralorn> merijn: So do I have any chance to capture the fail message purely?
14:17:18 <merijn> IO exceptions in IO?
14:17:41 <merijn> higherorder: Might be a direct way, but I'd just go with the "read then show"
14:17:45 <maralorn> So I have to use unsafePerformIO?
14:17:46 <higherorder> ok thanks
14:17:54 <HaskellLord69> Is there a link for a haskell Advent of Code leaderboard?
14:17:56 <merijn> higherorder: Are you trying to determine the difference between two large result values?
14:18:01 <higherorder> merijn: yes
14:18:20 <merijn> higherorder: Pfft, I'd skip this step, then
14:18:32 <merijn> higherorder: And go straight to me dramatically improving your life
14:18:38 <merijn> @hackage tree-diff
14:18:39 <lambdabot> http://hackage.haskell.org/package/tree-diff
14:18:41 <higherorder> merijn: I am all ears
14:18:57 <merijn> That lets you diff arbitrary nested datastructures :p
14:19:20 <merijn> So you get highlights of the part of your records that actually differ
14:20:23 <higherorder> merijn: oh my, that's amazing. How can I use this in place of an `@=?` hunit assertion?
14:21:10 <merijn> higherorder: You can manually check if things match and then use assertFailure with a custom error message (iirc, about hunit's API)
14:21:25 <higherorder> Alright I'll check that out; thanks!
14:21:55 <jle`> HaskellLord69: the unofficial one is 43100-84040706
14:22:48 <HaskellLord69> ty
14:23:03 <HaskellLord69> damn its full
14:23:28 <dsal> I would be #1 if I started on time and were better at reading directions.
14:23:39 <HaskellLord69> sure sure
14:23:42 <jle`> yeah luckily this year we have a chance now that dsal missed a night
14:24:11 <jle`> :)
14:25:35 <aplainzetakind> c_wraith: Not that big, 50MB. But switching to megaparsec from lines <$> readFile did make a significant difference.
14:26:03 <lionrouge> hi !
14:26:30 <c_wraith> oh. at that size it's in disk buffers, so slowdowns are more obvious
14:26:38 <merijn> aplainzetakind: Text takes about 2 bytes per character + some bytes overhead 
14:26:48 <merijn> aplainzetakind: String can take as many as 24 bytes per character
14:27:05 <lionrouge> so it looks like https://github.com/haskell/haskell-ide-engine is the modern way to go to support some editor like Atom or VSCode?
14:27:21 <merijn> lionrouge: Or ghcide, which also uses LSP
14:27:48 <lionrouge> merijn, which one would you personally recommend? I'm new to Haskell and am absolutely unfamiliar with the tooling
14:28:44 <merijn> I use ghcide, but it's still rather beta. I've never used HIE because it seemed such a hassle to get working
14:29:19 <merijn> tbh, I mostly use "nothing, except manually running build every so often" mostly, because ghcide doesn't support the Template Haskell in my project
14:30:34 <lionrouge> do you have highlighting, autocomplete and linting with your toolset?
14:31:10 <HaskellLord69> i just switched from intero to ghcide and its pretty neat but i find the popup annoying when I hover over code when I have a split window
14:31:19 <merijn> I just use the vim highlighting and wordbased autocomplete, tbh
14:31:25 <HaskellLord69> in emacs*
14:37:00 <[itchyjunk]> Hey i can't remember how you did that fib sqe function. I want to generate this recurrance sequence, s_1 = 4, s_{n+1} = (s_n)^2 - 2
14:37:29 <[itchyjunk]> so i am trying to define a function lucas = [ list comprehension here ] right?
14:39:47 <[itchyjunk]> oh the wiki has example code
14:39:49 * [itchyjunk] tests
14:42:02 <[itchyjunk]> https://wiki.haskell.org/The_Fibonacci_sequence
14:42:15 <[itchyjunk]> the "haskell translation of python algo", that IS the python code right?
14:42:33 <[itchyjunk]> ah it is 
14:47:21 <d34df00d> Hi!
14:47:42 <[itchyjunk]> hi
14:48:04 <d34df00d> I just wrote a function with the type `MonadError e' m => (e -> e') -> (forall m'. MonadError e m' => m' a) -> m a` with the obvious semantics, and it felt like I'm reinventing the wheel.
14:48:12 <d34df00d> Is there something readily available for this?
14:49:27 <Rembane> d34df00d: Something like mapErrorT?
14:50:10 <d34df00d> Rembane: yeah, but that doesn't force EitherT.
14:50:19 <d34df00d> ErrorT that is.
14:51:21 <d34df00d> And my function is really simple, `convert cvt act = runExceptT act >>= (liftEither . first cvt)`, so I'd expect the amount of plumbing required for mapErrorT to be comparable.
14:56:49 <jle`> d34df00d: there isn't really a point to 'take' a Rank-N polymorphic value unless you use it for more than one instantiation
14:57:13 <jle`> d34df00d: so you can just take `ExceptT e m a`
14:58:24 <d34df00d> jle`: my reasoning is that it's a bit more readable that way (or communicates the intent better). Personally I read that as "take an action that can live in arbitrary monad along as said monad is also `MonadError e`".
14:59:12 <d34df00d> s/along/as long/
15:00:11 <jle`> hm, if you write it as ExceptT then at least it is more obvious what it does
15:00:32 <jle`> MonadError e' m => (e -> a') -> ExceptT e m a -> m a
15:00:41 <jle`> it "generalizes" an ExceptT e m a
15:00:48 <jle`> s/a'/e'
15:00:57 <d34df00d> Did you intend to have m under ExceptT or should it be m'?
15:01:08 <jle`> well the way you wrote it, it is m
15:01:18 <jle`> it has to be, to fit your implementation
15:01:27 <d34df00d> Hmm why?
15:01:32 <jle`> check the type :)
15:01:41 <jle`> >>= needs both sides to be the 'same monad'
15:01:54 <jle`> so the monad that runExceptT act gives must be the same one that liftEither gives
15:02:02 <jle`> aka the final result monad
15:02:18 <d34df00d> That makes sense.
15:02:19 <d34df00d> Interesting.
15:02:24 <d34df00d> Now I don't understand my implementation.
15:06:25 <ornxka> Text.Parsec or Text.ParserCombinators.Parsec
15:06:28 <ornxka> which one is the good one
15:06:37 <ornxka> or is there even a difference
15:06:55 <Clint> the former, if those are your two choices
15:07:03 <ornxka> thanks mate
15:07:48 <d34df00d> jle`: soo... in this case the function also accepts actions that throw errors of type e' (since that's the top-level constraint).
15:07:59 <d34df00d> While with the RankN, it only accepts actions that throw e.
15:08:02 <d34df00d> Right?
15:09:16 <jle`> in the original case the m can throw e'
15:09:24 <jle`> because ExceptT e m a throws e, not e'
15:10:56 <d34df00d> But we also know that `MonadError e' m` in the latter case.
15:11:01 <d34df00d> So can't we throw e' as well?
15:12:55 <d34df00d> I also stopped understanding what my original code means.
15:13:06 <d34df00d> > convert (show @Int) (liftIO $ print ())
15:13:08 <lambdabot>  error:
15:13:08 <lambdabot>      Pattern syntax in expression context: show@Int
15:13:08 <lambdabot>      Did you mean to enable TypeApplications?
15:13:15 <d34df00d> Why does this typecheck even though I don't mention MonadIO for the action I'm passing?
15:14:08 <d34df00d> ...ah, right, it doesn't, as expected. I forgot to change back the type.
15:58:52 <jle`> d34df00d: the thing is that 'throwError' for the input monad will throw e'
15:58:58 <jle`> d34df00d: you can't in general throw e'
15:59:02 <jle`> * you can't in general throw e
15:59:14 <jle`> d34df00d: your original type is too polymorphic to throw e'
15:59:25 <jle`> d34df00d: but ExceptT e m a is monomorphic enough to throw e'
16:13:42 <nshepperd2> % :t return @Either
16:13:42 <yahb> nshepperd2: ; <interactive>:1:9: error:; * Expecting one more argument to `Either'; Expected kind `* -> *', but `Either' has kind `* -> * -> *'; * In the type `Either'; In the expression: return @Either
16:14:18 <nshepperd2> :t return :: a -> Either b a
16:14:20 <lambdabot> a -> Either b a
16:14:39 * hackage rib 0.5.0.0 - Static site generator using Shake  https://hackage.haskell.org/package/rib-0.5.0.0 (sridca)
16:38:25 <jle`> % :t return @(Either _)
16:38:25 <yahb> jle`: a -> Either w a
16:38:31 <jle`> hm, that was not expected
16:39:34 <hpc> the first type parameter is m :: * -> *
16:40:13 <hpc> you can see it if you look at the Monad instance too, m = Either w
16:40:19 <crestfallen> hi, wondering does anything in a do block necessitate a monad (as in return (x /= y) on line 4)? I'm wondering because the return value there is a Bool.   https://paste.ee/p/WL2mG
16:41:01 <crestfallen> ie necessitate return
16:41:20 <iqubic> The function return isn't used like it is in other programming languages.
16:41:23 <maralorn> crestfallen: return necessitates monad.
16:41:37 <hpc> that code is using a rarely-used feature of do-notation
16:41:52 <jle`> hpc: yeah, i was just surprised it uses 'w' by default
16:41:56 <hpc> if you do a pattern match using "<-", the case of it not matching uses fail
16:42:38 <hpc> so it could be written as case (x /= y) of {True -> the rest of the do block; False -> fail "such and such error on line number 4"}
16:42:56 <jle`> crestfallen: the return value can be any pattern
16:42:58 <jle`> monad or otherwise
16:43:08 <jle`> it's just normal pattern syntax
16:43:22 <jle`> crestfallen: just like how 'x' is a pattern matching on an Int, and 'y' is a pattern matching on an Int
16:43:40 <jle`> it's {any pattern} <- {any expression}
16:43:49 <jle`> syntactically, at least.
16:43:55 <crestfallen> so that is a predicate, but it still requires return.
16:44:18 <jle`> well, remember that each line has to have to be a 'monadic action'
16:44:23 <iqubic> I have a string that has many newlines, and ends with a newline. Is there a way to prevent 'lines' from giving me a list ending with an empty string?
16:44:38 <jle`> crestfallen: so the first one is [Int], the second one is [Int], the third one is [Bool], the final one is [(Int, Int)]
16:44:53 <jle`> so if you have a bunch of actions together in do notation, each one has to be a 'monadic action' of the same monad
16:44:56 <jle`> in this case, []
16:45:32 <jle`> iqubic: you can filter for (not . null), maybe
16:45:41 <jle`> but lines should not return any empty trailing strings
16:45:46 <crestfallen> so that is actually [True] <- return (x /= y)     ?
16:45:52 <jle`> > lines "hello\nworld"
16:45:54 <lambdabot>  ["hello","world"]
16:46:06 <jle`> crestfallen: no, remember that for pat <- expr, if expr :: m a, then pat :: a
16:46:06 <iqubic> > lines "hello\nworld\n"
16:46:09 <lambdabot>  ["hello","world"]
16:46:16 <jle`> crestfallen: like x <- getLine
16:46:22 <jle`> getLine :: IO String, so x :: String
16:46:24 <glguy> \n is a line *terminator*
16:46:30 <iqubic> I see.
16:46:47 <jle`> crestfallen: so for `x <- myAction`, if myAction :: M A, then x :: A
16:47:01 <dsal> iqubic: Did  you AoC?  I forgot to start.
16:47:10 <jle`> crestfallen: so it is actually (True :: Bool) <- (return (x /= y) :: [Bool])
16:47:26 <jle`> just like we have (resp :: String) <- (getLine :: IO String)
16:47:45 <jle`> or also you have in that code (x :: Int) <- ([1,2,3] :: [Int])
16:48:46 <rifkik> Hey IRC, I just "finished" my first Haskell program, any suggestions to improve its code quality would be welcome https://github.com/IamRifki/segno
16:48:59 <iqubic> dsal: I'm 12 on the Haskell leaderboard and 16th on the irc leaderboard.
16:49:05 <iqubic> I'd say I started.
16:49:06 <jle`> rifkik: congrats :D
16:49:14 <rifkik> Thanks
16:49:51 <crestfallen> right, since (x /= y) produces more than one value, we have (return x \= y) :: [Bool]   jle` 
16:50:16 <jle`> crestfallen: well, return (x /= y) produces one value. it's equlvaient to True <- [x /= y]
16:50:17 <dsal> iqubic: nice.  I'm... far down, but hopefully I'll stay behind and not get obsessed like last year.
16:50:26 <jle`> crestfallen: since return x = [x]
16:51:00 <jle`> crestfallen: so you could write that line as (True :: Bool) <- ([x /= y] :: [Bool])
16:51:14 <jle`> remember that x :: Int and y :: Int
16:51:55 <jle`> rifkik: fwiw it looks like a really useful tool :)
16:52:09 <rifkik> Nah, not really
16:54:49 <crestfallen> right ok but you're saying it looks like this after /= is finished:    True <- [True,True,True] , in the case where we have 2 lists with 3 inhabitants. jle` 
16:55:26 <crestfallen> 3 inhabitants each
16:56:33 <iqubic> @pl (\x -> f x - g x)
16:56:34 <lambdabot> liftM2 (-) f g
16:57:43 <koz_> iqubic: You can also do (-) <$> f <*> g.
16:58:32 <EvanR> > length "\x -> f x - g x"
16:58:34 <lambdabot>  <hint>:1:11: error:
16:58:35 <lambdabot>      lexical error in string/character literal at character ' '
16:58:39 <EvanR> > length "liftM2 (-) f g"
16:58:42 <lambdabot>  14
16:58:44 <EvanR> > length "\\x -> f x - g x"
16:58:47 <lambdabot>  15
16:59:06 <koz_> > length "(-> <$> f <*> g"
16:59:08 <lambdabot>  15
16:59:16 <koz_> (spelling error but ehh)
16:59:30 <matheus> don't forget you can remove the spaces in that one but not the others :p
16:59:41 <matheus> > length "(-)<$>f<*>g" -- please don't do this
16:59:44 <lambdabot>  11
16:59:46 <iqubic> I like being point free.
16:59:59 <iqubic> -- >>> runSolutionOnInput 1 $ liftM2 (-) part2 part1
17:00:02 <iqubic> -- Right 1632312
17:00:29 <iqubic> That's an AoC day 1 thing there.
17:00:34 <EvanR> liftA2 (-) f g has the advance of being unobvious to an outsider </forthecabal>
17:00:39 <EvanR> advantage
17:01:42 <jle`> crestfallen: yeah, it will eventually be 'run' multiple times
17:02:12 <jle`> crestfallen: but you shouldn't think of it as multiple values
17:02:19 <koz_> EvanR: How is '(-) <$> f <*> g' less obscure?
17:02:45 <jle`> crestfallen: you should think of it as a single one, because that's how the types and the semantics of list >>= behave, i feel.  thinking of it as more than one is going to lead to misunderstandings
17:03:26 <jle`> crestfallen: it will never be True <- [True, True, True], it will always be True <- [True] or True <- [False]
17:03:44 <EvanR> i wasn't even counting (-) <$> f <*> g
17:04:03 <EvanR> i kind of hate that pattern
17:04:39 <jle`> i only use it when i plan on extending it with more inputs possibly
17:04:48 <EvanR> \x -> f x - g x has the disadvantage of being incredibly obvious
17:04:56 <jle`> oh, i would never use it for functions
17:05:23 <jle`> real friends don't let friends directly use the Applicative or Monad instances of functions
17:05:53 <EvanR> it's funny how even haskell wants to avoid lambdas heh
17:05:59 <jle`> unless in cases where it makes things more readable in six months
17:06:04 <jle`> which are rare
17:06:20 <jle`> i try to follow the 'six months later' rule
17:07:20 <d34df00d> jle`: cool, that aligns with my intuition then, thanks for confirming and explaining in better words!
17:15:16 <koz_> Maybe I'm just strange, but I find applicative style using <$> and <*> easier to read.
17:15:33 <EvanR> it's very idiosyncratic
17:16:28 <EvanR> especially when you went from x + y to (+) <$> x <*> y
17:16:48 <EvanR> i heard you like operators operating on your operators
17:17:02 <koz_> EvanR: Yo dawg.
17:17:26 <crestfallen> jle`, so in this program, it could be True <- [False] ?
17:18:24 <jle`> that could happen, yeah, during the runtime of the program
17:18:50 <jle`> but that would cause that 'branch' of the loop to fail and not manifest in the final answer
17:20:05 <dmj`> jle`: you ready?
17:20:14 <crestfallen> so if it's monadic structure, then that's like a Nothing value being passed to True .. resulting in failure
17:20:19 <iqubic> Ready for what?
17:20:24 <dmj`> iqubic: you know what
17:20:29 <jle`> dmj`: i'm never ready :O
17:20:57 <crestfallen> in that branch of the loop
17:22:03 <crestfallen> in any case it gets cut off
17:22:03 <iqubic> Ah. I do know.
17:22:35 <iqubic> It's still 3.5 hours away.
17:22:50 <dmj`> jle`: gotta hold the lead
17:23:29 <dmj`> iqubic: no problem starting to warm up now though, go through 99 haskell problems
17:23:35 <dmj`> @google 99 haskell problems
17:23:36 <lambdabot> http://www.google.com/url?q=https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems
17:23:36 <lambdabot> Title: Уведомление о переадресации
17:24:50 <d34df00d> So we know lambdabot is Russian.
17:25:00 <koz_> Komrade Lambdabot.
17:25:09 <d34df00d> Tovarisch.
17:25:25 <koz_> Vodka, balalaika, medved'. :P
17:26:51 <d34df00d> Crap, I should've known about AoC.
17:26:59 <d34df00d> Would have taken a day off tomorrow otherwise.
17:28:01 <koz_> d34df00d: No such luck for me I'm afraid.
17:28:10 <koz_> Gotta hammer out that Haskell-on-Windows. :P
17:28:25 <d34df00d> Sounds nasty.
17:28:31 <d34df00d> I only use Windows as a game launcher.
17:28:54 <koz_> d34df00d: I don't even go that far, but employer's gonna employer. :P
17:31:28 <koz_> It is a unique experience trying to stitch together Win32, MSDN docs (for a different language) and my own total disregard for Windows anything. :P
17:32:45 <d34df00d> I remember building some of my C++ stuff for Windows like 10 years ago.
17:32:51 <d34df00d> I mean, trying to port my Linux app over.
17:32:54 <d34df00d> Was a nightmare.
17:33:09 <koz_> d34df00d: If you know anyone hiring remote Haskellers, I'm willing to listen.
17:39:15 <crestfallen> jle`, if you have time, this last example, which is giving me insight into the last one, returns parse error: (possibly incorrect indentation or mismatched brackets). it errors on the 1st character 'n' of the function name     https://termbin.com/zbzz
17:51:36 <crestfallen> well I have it exactly as the example except I named it. anyone see my error? ^
17:55:15 <ChaiTRex> crestfallen: return (x,y
17:55:39 <ChaiTRex> crestfallen: Last line in definition of mm
17:56:25 <crestfallen> geez what a botch. thanks ChaiTRex !
17:56:31 <ChaiTRex> crestfallen: No problem.
18:08:11 <jusss> jle`: does Cont Monad have an effect?
18:08:28 <jusss> is that all Monads about effects?
18:10:17 <jle`> i'm not sure what your last sentence means, sorry
18:10:40 <jusss> all Monads have their own effects?
18:10:56 <jusss> my English is not good, :)
18:11:25 <jle`> no worries :)
18:11:34 <jle`> i would say 'yes' in a tautological way
18:11:41 <jusss> but?
18:11:56 <jusss> there always is a but?
18:12:06 <jle`> tautalogical = yes but in the most useless way
18:12:17 <jle`> yes, by "definition" of the word effects :)
18:12:40 <jle`> in this sense we are defining "effects" as "the thing that monads have"
18:12:51 <jle`> so all monads have effects by definition
18:12:57 <crestfallen> I wonder how you would write the first list binding to \x then the second one being bound to \y. I mean, as evaluation steps, is there a way to write out the last function, nn? https://termbin.com/zbzz
18:14:29 <jle`> jusss: i suppose i mean 'yes, but tautologically true, since it's not very deep or insightful'
18:15:13 <jusss> jle`: and what's about Cont Monad?
18:15:16 <crestfallen> not so much the case statement, but at the beginning where the bind operators are.
18:15:40 <jusss> there're a few Monads I still havn't meet, Cont and Free blablah
18:16:03 <jle`> crestfallen: are you talking about hwo to step through the valuation of nn ?
18:17:05 <crestfallen> jle`, I say evaluation steps, not sure if that's the same thing?
18:17:34 <jle`> crestfallen: ah sorry, i mean tthe evaluation of nn
18:17:53 <jle`> but yeah, if that's what you wnat, you would apply the definition of the outermost >>=
18:17:56 <crestfallen> Like what would [1,2,3] look like after it was bound to (\x -> [1,2,3]
18:17:56 <jle`> and then etc. to the end
18:18:17 <jle`> crestfallen: well the binding happens at the top level
18:18:21 <jle`> so it just looks like the end result
18:18:33 <crestfallen> sorry not following..
18:18:36 <jle`> > concatMap (x -> [x,x]) [1,2,3]
18:18:40 <lambdabot>  error:
18:18:40 <lambdabot>      Pattern syntax in expression context: x -> [x, x]
18:18:43 <jusss> :t Just
18:18:45 <jle`> > concatMap (\x -> [x,x]) [1,2,3]
18:18:45 <lambdabot> a -> Maybe a
18:18:47 <lambdabot>  [1,1,2,2,3,3]
18:18:55 <jle`> crestfallen: 'what it looks like' is just the final result of nn
18:19:13 <jle`> crestfallen: but you can imagine what the result is for every possibility, before the concat, maybe
18:19:16 <glguy> I don't think monads are so much about effects as things that are about effects sometimes have a monad interface
18:19:19 <jle`> replace the >>= with a map and you can inspect it
18:20:13 <jle`> glguy: that's fair, but i also don't really have a good way to define what an effect is with rigor without reference to an Applicative/Monad instance
18:21:29 <jusss> jle`: if `f::a->b' and `g::b->a' ,how we call the relation between f and g?
18:21:33 <jle`> jusss: i don't have a good answer to how to interpret Cont r a as an effect, i think, in a way that provides too much insight. maybe the effect is 'redirectable control flow'?
18:21:51 <jle`> jusss: maybe f and g "composable"?
18:22:09 <jle`> it's like the relationship between an NxM and an MxR matrix
18:22:37 <jusss> jle`: can we call it Isomorphism?
18:22:38 <jle`> "compatible", some people call it, for matrices
18:22:48 <jle`> jusss: no, they are only an isomorphism is f . g = id, and g . f = id
18:23:08 <jle`> *isomorphism if
18:24:23 <jusss> jle`: but based on `f::a->b' and `g::b->a' ,  f . g == id?
18:24:51 <matheus> technically assuming f :: a -> b means f _ = ⊥
18:25:01 <crestfallen> jle`, sort of following..
18:25:02 <matheus> and g :: b -> a means g _ = ⊥, too
18:25:34 <jusss> what this symbol mean?
18:25:46 <jusss> I can't input it...
18:26:07 <matheus> bottom. either an infinite loop, or a call to `error`/`undefined`
18:26:09 <matheus> https://wiki.haskell.org/Bottom
18:26:20 <glguy> matheus: Are you not understanding the question or just being a bit pedantic?
18:26:52 <matheus> glguy: being a bit pedantic; anyway, that the types of two functions would fit (.) doesn't mean their composition is the identity function
18:27:09 <glguy> matheus: OK, because in this case the pedantic response doesn't really help
18:27:57 <matheus> jusss: say `f :: String -> Int` and `g :: Int -> Int`. then `g . f :: String -> Int` which is not the identity function
18:28:00 <matheus> there, more helpful?
18:28:25 <matheus> (f could be length, for example, and g could be \x -> x * x)
18:29:16 <jusss> matheus: if `f::String -> Int' and `g::Int -> String' ?
18:29:39 <jusss> can we say f and g are isomorphic?
18:30:01 <jle`> you can't say from their type, only from their definitions are
18:30:03 <matheus> f = length, g x = replicate x 'a'
18:30:17 <matheus> jusss: also, i think you're still a bit confused
18:30:25 <jusss> matheus: yeah
18:30:45 <matheus> for two functions f and g to be isomorphic, they need to have the same type and be equal at every possible input
18:31:37 <jusss> newtype Identity a = Identity { runIdentity :: a }
18:31:43 <shachaf> That's not what "isomorphic" means.
18:31:46 <matheus> for two functions to be an *isomorphism*, they need to have types _like_ "f :: a -> b" and "g :: b -> a", and f . g = id; and g . f = id
18:32:00 <jusss> runIdentity . Identity = id, they're isomorphic , right?
18:32:08 <shachaf> Except in some pretty bizarre usage?
18:32:12 <jle`> they aren't isomorphic, but together they witness an isomorphism
18:32:16 <matheus> they're halves of an isomorphISM, they're not isomorphic
18:32:26 <EvanR> equal at every possible input is extensionally equal
18:32:28 <crestfallen> jle`, are you saying concatMap is very close to the way bind is operating in the nn function?
18:32:47 <jle`> crestfallen: for lists, xs >>= f = concatMap f xs
18:32:51 <jle`> crestfallen: bind is literally concatMap
18:32:54 <jle`> just as an operator
18:33:17 <jle`> crestfallen: so if you want to 'visualize' how things step out, you could maybe replace bind with fmap (concatMap with map) to see the tree that eventually gets collapsed
18:33:57 <jle`> crestfallen: you'll get a giant nested list of lists, and their full concatenation is your final result
18:34:36 <jle`> at least in this sense you can visualize which branches dead-end and which ones continue to contribute to your final result
18:35:47 <EvanR> who are you guys talking to anyway
18:37:00 <crestfallen> jle`,   but in a concatenated list how does the predicate know which is x and y?
18:37:22 <crestfallen> [1,1,2,2,3,3] say
18:37:32 <jle`> crestfallen: in the final concatenated list you cannot
18:37:37 <jle`> only in the intermediate steps can you distinguish
18:38:00 <crestfallen> ok thanks kindly that ain't easy
18:38:00 <EvanR> ah it was a jusss question
18:38:05 <jle`> crestfallen: i'm saying, do all your maps to get a big [[[(Int, Int)]]]
18:38:13 <jle`> crestfallen: so you can see the final result of each branch
18:38:27 <jusss> EvanR: what?
18:38:33 <matheus> EvanR: do you have them on ignore?
18:39:14 <EvanR> if f :: A -> B and g :: B -> A then there doesn't seem to be any special relationship at all
18:39:47 <EvanR> rather if there was, they didn't give enough info to identify it
18:39:58 <jusss> newtype Identity a = Identity { runIdentity :: a },  and Identity with runIdentity?
18:40:11 <jusss> > newtype Identity a = Identity { runIdentity :: a }
18:40:14 <lambdabot>  <hint>:1:1: error: parse error on input ‘newtype’
18:40:41 <EvanR> a constructor / destructor pair?
18:41:16 <jusss> ok
18:41:16 <matheus> jusss: in that case `Identity a` and `a` are isomorphic, and runIdentity/Identity witness that isomorphism
18:41:25 <jle`> i think the closest thing i've found is the idea "compatible matrices", are B -> C and A -> B.  so maybe A -> B and B -> A are "mutually compatible"?
18:41:56 <crestfallen> jle`, very sorry I don't understand your exercise with " fmap (concatMap with map) ".
18:42:05 <jle`> crestfallen: i mean, replace bind with fmap
18:42:15 <jle`> crestfallen: which is the same as saying replace concatMap with map
18:42:22 <jle`> since bind = concatMap and fmap = map
18:42:34 <jle`> sorry, my phrasing was probably unclear :)
18:42:51 <crestfallen> thanks, just replace them inline with backticks?
18:43:07 <crestfallen> `fmap`
18:43:23 <jle`> crestfallen: so instaed of writing xs >>= (\x -> ys >>= (\y -> ...))), use xs <&> (\x -> ys <&> \y -> ...)
18:43:30 <jle`> fmap won't quite work because the argument order is backwards
18:43:34 <jle`> but you can use flip fmap, aka <&>
18:43:38 <jle`> from Data.Functor
18:43:49 <crestfallen> that's nuts :)
18:43:53 <jle`> in the end, you'll get a big nested list, like [[[(Int, Int)]]] or something
18:44:15 <jle`> the first layer will be the 'leaf' of each of the original x in xs
18:44:32 <jle`> the second layers will be the 'leaves' of each of the original y in ys, under the appropriate x
18:44:37 <jle`> etc.
18:53:11 <crestfallen> jle`, thanks kindly I have to come back to this at a later date I fear.
19:03:17 <crestfallen> jle`, also, I simply did r/>>=/<&>/  but that gave copious errors (ambiguous occurrence)
19:09:46 <Pamelloes> Is there a reason why an explicit instance of Sing in the form `data instance Sing (n :: Shape) where' would compile fine on GHC 8.6 but be problematic on GHC 8.8?
19:10:17 <Pamelloes> (I'm trying to update a library to GHC 8.8)
19:17:45 <jle`> Pamelloes: it might be because the singletons version for ghc 8.8 now has Sing as an injective type family instead of a data family
19:18:39 <habbah> data FooNum = Foo Int deriving Generic ; Binary.decode (Binary.encode (Foo 3))  -- results in (), but why? I expected "Foo 3"
19:19:22 <habbah> I forgot to mention there is also "instance Binary FooNum"
19:19:52 <jle`> habbah: decode is return value based
19:19:58 <jle`> so it depends on what type you want to get back
19:20:01 <jle`> it's similar to read
19:20:04 <jle`> > read "3" + 9
19:20:07 <lambdabot>  12
19:20:10 <jle`> > read "True" || False
19:20:13 <lambdabot>  True
19:20:16 <jle`> > read "()"
19:20:19 <lambdabot>  ()
19:20:33 <jle`> habbah: if you're in ghci it's probably assuming you want to decode a binary blob as ()
19:20:41 <jle`> you have to tell ghc you want a FooNum somehow
19:20:50 <habbah> thanks jle`, I've got it now
19:21:29 <habbah> data FooNum = foo Int deriving (Generic, Show) ; instance Binary FooNum; Binary.decode (Binary.encode (Foo 3)) :: FooNum
19:38:39 * hackage crypto-keys-ssh 0.1.0.0 - Like crypto-pubkey-openssh but not dependent on any specific crypto library  https://hackage.haskell.org/package/crypto-keys-ssh-0.1.0.0 (puffnfresh)
19:51:47 <jle`> habbah: nice :)
19:52:09 <jle`> habbah: yeah, in real programs usually you will use the FooNum in a way that you don't need a specific type annotation
19:52:22 <jle`> it's just when you play around in ghci and stuff that it can get wonky
19:54:09 * hackage flags-applicative 0.1.0.2 - Applicative flag parsing  https://hackage.haskell.org/package/flags-applicative-0.1.0.2 (mtth)
20:15:25 <iqubic> What's a good way to get the 5 least significant bits of a number in haskell?
20:16:46 <jle`> if it's an integer, (`mod` 10000)
20:16:54 <jle`> oh, bits, not digits
20:17:05 <jle`> (`mod` (2^5))
20:57:20 <amalloy> or (.&. 31)
21:32:09 * hackage stack-wrapper 0.1.0 - Call ghc within stack by calling ghc  https://hackage.haskell.org/package/stack-wrapper-0.1.0 (kakkun61)
21:32:24 <koz_> Is there something like foldyTraverse :: (Applicative f, Traversable t, Monoid m) => (a -> f m) -> t a -> f m ?
21:40:00 <MarcelineVQ> typewise it's (fmap fold .) . traverse but idk how it behaves
21:40:17 <koz_> I guess I could do that.
21:50:29 <jusss> inC `bind` fn = \out -> inC (\inCval -> (fn inCval) out)
21:50:46 <jusss> inC `bind` fn = \out -> inC (fn out)
21:50:56 <jusss> this this equal?
22:01:53 <Axman6> doesn't look equal to me
22:03:00 <Axman6> but this is I thnk: inC `bind` fn = \out -> inC (flip fn out) 
22:04:17 <jusss> :t flip
22:04:19 <lambdabot> (a -> b -> c) -> b -> a -> c
22:05:16 <jusss> I'm trying to learn about Cont Monad from this article https://jsdw.me/posts/haskell-cont-monad/
22:06:02 <jusss> it's not easy to understand to me even it describes its details... I don't have a good comprehension
22:08:46 <Axman6> the Cont monad is very confusing, even to people who've been using Haskell for a long time
22:12:22 <jusss> Axman6: but continuation is a easy concept in scheme, they provide call/cc to capture it
22:12:31 <jusss> an
22:12:59 <amalloy> i don't know that continuations are really that easy in scheme either
22:13:05 <jusss> now I don't know what it's a continuation
22:14:04 <Axman6> I'm not sur eI would call it an easy concept in Scheme either but I haven't used it there either. if you try and think about the type thast the equivalent Scheme code would have you might find it actually takes some time to understand what they should actually be
22:15:35 <jusss> Axman6: are they the same thing in Scheme and Haskell?
22:16:48 <hololeap> :t \f -> mfix $ \ ~(a, _) -> runState (f a)
22:16:50 <lambdabot> (t -> State b t) -> b -> (t, b)
22:17:25 <hololeap> i'm having a hard time figuring out how the MonadFix instance for (,) would work
22:17:44 <hololeap> or rather ((,) a)
22:19:40 <hololeap> oh, wait i think i figured it out... a has to be a Monoid, so it has an mempty
22:20:22 <hololeap> i was stuck trying to understand where the initial t was given
22:28:36 <koz_> Also, call-cc is _not_ the same as Cont.
22:28:42 <koz_> (one's undelimited, the other is delimited)
22:30:33 <koz_> In fact, as Oleg argues quite well, call-cc is _super_ difficult for very little real gain.
22:31:53 <[exa]> well not _super_ difficult given how long the actual definition is :]
22:32:16 <[exa]> it just requires a bit more practical intuition before you start coding
22:38:19 <koz_> [exa]: It's not just for use - implementation of call-cc is also difficult.
22:43:26 <refusenick> Is HIE more feature-complete than ghcide, or has ghcide supplanted it?
22:44:53 <refusenick> My main trouble with Haskell involves managing dependencies within Emacs without having to jump to the terminal, which HIE lists support for (type "import Control.Foo", and it will add it to the dependencies in bar.cabal)
22:47:37 <dminuoso> Which libraries might be of interest to me, if I want to build a simple CLI that just asks basic questions, demands some input, maybe validates it, maybe requests information anew, etc..
22:47:51 <jneira_> refusenick: the plan is to merge both: https://github.com/haskell/haskell-ide-engine/issues/1416
22:47:55 <jle`> dminuoso: haskeline probably :) if it's interactive
22:49:03 <refusenick> jneira_: That's great to hear! It sounds like I should install HIE, then
22:49:11 <dminuoso> jle`: That looks spot on! Cheers. :)
22:49:14 <jneira_> but afaik hie has more features but actual master is less reliable in general
22:49:40 <refusenick> I'm not writing anything big, so I can't imagine it having serious problems.
22:49:53 <refusenick> I just need development to feel snappy
22:50:57 <jneira_> we are about to merge a internal change that makes it more similar to ghcide, maybe it worths to try out it (but it is under development): https://github.com/mpickering/haskell-ide-engine
22:51:57 <jneira_> i dont use it personally but it seems ghcide is snappier too ;-)
23:09:28 <hololeap> i actually can't find a MonadFix instance for ((,) a) in the standard libraries
23:09:50 <jle`> yeah finding instances for built-in types is a little tricky
23:09:56 <jle`> hololeap: did you look in the module that MonadFix is defined in?
23:10:21 <jle`> hololeap: ah if you do :i MonadFix in ghci then it should tell you where it is defined in
23:10:24 <jle`> % :i MonadFix
23:10:24 <yahb> jle`: class Monad m => MonadFix (m :: * -> *) where; mfix :: (a -> m a) -> m a; {-# MINIMAL mfix #-}; -- Defined in `Control.Monad.Fix'; instance [safe] (Monoid w, MonadFix m) => MonadFix (WriterT w m) -- Defined in `Control.Monad.Trans.Writer.Lazy'; instance [safe] MonadFix m => MonadFix (StateT s m) -- Defined in `Control.Monad.Trans.State.Lazy'; instance [safe] MonadFix m => MonadFix (ReaderT r m) -
23:10:32 <jle`> somewhere down that list :)
23:10:45 <hololeap> i actually don't think it is
23:10:48 <jle`> hm, it looks like there is no instance in base
23:11:10 <hololeap> i was actually trying to understand how the MonadFix instance worked
23:11:35 <jle`> imagine a two-sided coin
23:11:36 <hololeap> instance for StateT
23:11:45 <jle`> and then flipping it
23:11:57 <jle`> if it is heads, you get a hundred dollars
23:12:07 <jle`> if it is tails, a bomb explodes
23:12:12 <jle`> that's how the instance works
23:12:30 <hololeap> here is how mfix is defined for StateT
23:12:37 <hololeap> :t \f -> StateT $ \s -> mfix $ \ ~(a, _) -> runStateT (f a) s
23:12:39 <lambdabot> MonadFix m => (a -> StateT b m a) -> StateT b m a
23:13:08 <hololeap> i thought that inner mfix was working on ((,) a), but it actually seems that isn't the case
23:14:20 <lavalike> how are you supposed to install ghcid with cabal 3?
23:15:55 <lavalike> I was surprised just now by "cabal: installdir is not defined. Set it in your cabal config file or use --installdir=<path>"
23:17:24 <maerwald> lol, I just hit that too when trying to install homplexity
23:18:40 <maerwald> --installdir=$HOME/.local/bin worked... I think it's the same as --symlink-bindir
23:18:45 <maerwald> just renamed
23:20:20 <hololeap> so what exactly is going on here?
23:20:23 <hololeap> :t \f -> state $ \s -> fix $ \ ~(a, _) -> runState (f a) s
23:20:25 <lambdabot> MonadState b m => (a -> State b a) -> m a
23:21:59 <hololeap> (a -> State b a) -> State b a
23:26:39 * hackage ghc-events 0.12.0 - Library and tool for parsing .eventlog files from GHC  https://hackage.haskell.org/package/ghc-events-0.12.0 (MitsutoshiAoe)
23:27:50 <koz_> @pl \x y -> pure (x <> y)
23:27:51 <lambdabot> (pure .) . (<>)
23:28:01 <lavalike> maerwald: aah I got scared, it does indeed just do the symlinking! good (:
23:36:09 <iqubic> > [1..1]
23:36:13 <lambdabot>  [1]
23:36:20 <iqubic> That took a while to return.
23:38:00 <dansho> what's the difference between ghcide and hie?
23:38:22 <hololeap> iqubic: that's bitten me before. it can also be sneaky with something like [x..x*y] when you hit the corner case of y == 1
23:38:48 <hololeap> oh, wait i'm thinking of a different thing
23:38:49 <iqubic> hololeap: Actually, that's the behavior I want in this case.
23:40:42 <hololeap> > let x = 5 ; y = 0 in [0,y,x*y]
23:40:45 <lambdabot>  [0,0,0]
23:40:50 <hololeap> > let x = 5 ; y = 0 in [0,y..x*y]
23:40:52 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
23:41:01 <Athas> dansho: I think hie is built on ghcide.
23:41:16 <Athas> Also, there is ghcid, which is completely different... Naming is hard, apparently.
23:41:21 <hololeap> that's what i was thinking of...
23:41:46 <hololeap> iqubic: you can do [1,1..1]
23:41:53 <hololeap> > [1,1..1]
23:41:55 <Athas> All of the following are Haskell programs, tools, or libraries: ghc, ghci, ghcid, ghcide.  What'll be next?
23:41:56 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
23:42:43 <Ariakenom> I always read ghcide like patricide
23:43:41 <opqdonut> ghcidea from IntelliJ ;)
23:43:49 <koz_> Ariakenom: So, 'gee-eych-side'?
23:45:05 <hololeap> it's a typo. it's supposed to be ghcade
23:45:07 <amalloy> we'll finally reach the apex with ghcideal
23:45:39 <koz_> amalloy: All these puns are making me feel ghcidal.
23:45:40 <Ariakenom> koz_: sure. but mostly like its about killing ghc
23:48:16 <hololeap> :t \f -> StateT $ \s -> mfix $ \ ~(a, _) -> runStateT (f a) s
23:48:18 <lambdabot> MonadFix m => (a -> StateT b m a) -> StateT b m a
23:48:20 <dansho> =< why is ghcide installing ghc-8.4.4 stuff
23:48:46 <hololeap> so why does the tuple need to be lazily evaluated here?
23:52:40 <rifkik> It’s me again I got some suggestions for the main file, but haven't gotten any for the the actual machinery AKA the Music.hs file
23:52:40 <rifkik> The code can be seen here:
23:52:40 <rifkik> https://github.com/IamRifki/segno/blob/master/src/Segno/Music.hs
23:55:16 * koz_ wonders why 'ask' needs Monad.
23:55:21 <koz_> Hysterical raisins I guess.
23:59:54 <rotaerk> koz_, well, first it needed a very specific monad (Reader r), and then it was generalized to work with any (ReaderT r m) where m is a Monad
