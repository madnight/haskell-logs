00:02:02 <miller> Ah, great!  I was less confused by Generic functions than Walk, but if that's my way forward, I shall go port over.  Thanks!  shachaf++
00:03:34 <haskeldjiq> hey guys, I have perhaps a stupid question regarding concurrent programming
00:04:04 <haskeldjiq> how can I wait for a variable (e.g. IORef) to change to a specific value
00:04:19 <haskeldjiq> e.g. if I had an IORef Int how could I wait for it to become 3 or 4 or some other specific number
00:08:26 <haskeldjiq> https://www.reddit.com/r/haskell/comments/7gxwnq/can_you_detect_when_an_ioref_changes/ this solves it
00:51:29 <ephemient> after jackdk's earlier question about posix-pty, I set about messing around with PTYs in Haskell
00:53:17 <ephemient> good news: you can definitely avoid using posix-pty; https://gist.github.com/ephemient/3608786603889022b55da6a8dc8879ea is an example which creates a pseudo-tty, runs any program inside of it, and forwards everything between that and the "real" tty
00:53:58 <ephemient> bad news: it seems that fdRead on a tty is uninterruptible? tiny repro case: https://gist.github.com/ephemient/6acbfdc1e5fec57cd80410b0fdc59f50
00:54:39 <ephemient> you'd expect the output "kill?" to be followed by "kill!", but it won't happen on its own
00:55:12 <ephemient> is GHC refusing to put the terminal FD into nonblocking mode?
00:57:54 * hackage fold-debounce-conduit 0.2.0.4 - Regulate input traffic from conduit Source with Control.FoldDebounce  https://hackage.haskell.org/package/fold-debounce-conduit-0.2.0.4 (debugito)
00:58:27 <ephemient> it works as expected with the (buffered) getChar
01:06:54 * hackage wild-bind 0.1.2.5 - Dynamic key binding framework  https://hackage.haskell.org/package/wild-bind-0.1.2.5 (debugito)
01:07:54 * hackage wild-bind-x11 0.2.0.9 - X11-specific implementation for WildBind  https://hackage.haskell.org/package/wild-bind-x11-0.2.0.9 (debugito)
01:11:54 * hackage hspec-need-env 0.1.0.4 - Read environment variables for hspec tests  https://hackage.haskell.org/package/hspec-need-env-0.1.0.4 (debugito)
01:20:19 <fog> I wrote HFree! https://pastebin.com/raw/saJNTbn7
01:20:54 * hackage greskell-core 0.1.3.1 - Haskell binding for Gremlin graph query language - core data types and tools  https://hackage.haskell.org/package/greskell-core-0.1.3.1 (debugito)
01:22:24 * hackage greskell-websocket 0.1.2.1 - Haskell client for Gremlin Server using WebSocket serializer  https://hackage.haskell.org/package/greskell-websocket-0.1.2.1 (debugito)
01:23:24 * hackage greskell 1.0.0.1 - Haskell binding for Gremlin graph query language  https://hackage.haskell.org/package/greskell-1.0.0.1 (debugito)
02:00:20 <FabianW> Heya! I am running a program with System.Process.createProcess, which is supposed to read one character and then output two lines afterwards. If I run the program in the shell it does this wonderfully. However, when I use hGetLine on the read end of the pipe connected to this program in my Haskell code, it just freezes indefinitely. Is there something obvious I might be doing wrong?
02:01:10 <ephemient> buffering, probably
02:01:48 <FabianW> Since I don't know what I'm doing regarding that, you are probably right. Any tips? Should I just change the buffering mode?
02:02:27 <ephemient> if you're trying to act immediately upon a single character, yes
02:03:35 <FabianW> Well the output is always one character followed by a newline, the input is the same. I'll try messing around with the BufferModes, thanks!
02:10:39 <cdunklau> FabianW: the program might behave differently if its hooked up to a pty vs pipes
02:17:13 <FabianW> cdunklau: The subprogram is a haskell program using putStrLn and getLine to read from its standard fds. I'm using a CreateProcess with CreatePipe set to get handles to pipes hooked up to stdin and stdout. I am then trying to first use hPutStrLn to input a digit and then hGetLine to read the response. I have no idea where it could start breaking, all I know is that hGetLine doesn't terminate even though 
02:17:19 <FabianW> the handle for the output claims to be readable and open, and the same input leads the program to respond when it is opened in a shell.
02:18:25 <FabianW> Maybe the newlines being written aren't being read as newlines?
02:29:12 <FabianW> ephemient: could you elaborate on Buffering? Changing buffering modes hasn't done much, hGetLine keeps reading forever whether there is LineBuffering, NoBuffering or BlockBuffering somethingorother
02:32:37 <ephemient> FabianW: you're setting the buffering on the child's stdin, right?
02:33:36 <ephemient> also the parent needs to make sure to flush its end of the pipe
02:33:46 <fog> What kind of functions should HFree support?
02:34:12 <fog> I'm thinking traversable, but not really sure how
02:34:31 <FabianW> ephemient: I'll try explicitly flushing the input from the parent's end
02:36:53 <fog> also not sure about Applicative and Monad... Free [] === [[[...] which can be concatinated to [] but eg Nonempty . [] in a HFree does not collapse to anything simple, it can be Nonempty, but calculating that is not trivial 
02:38:40 <FabianW> ephemient: Doesn't work. I didn't expect to lose my sanity solving adventOfCode in Haskell  when I became a TA.
02:40:53 <cdunklau> FabianW: multiple processes for AoC? i think you're overengineering this :)
02:41:06 <cdunklau> FabianW: which day are you doing this for?
02:41:22 <cdunklau> it's day 7 isn't it
02:42:09 <FabianW> cdunklau: I am supposed to reuse a solution for day 5, which is the intcode machine thingy. day7 and 11 are driving me mad trying to launch the example solution for day 5 in my solution for day 7
02:42:22 <FabianW> and 11
02:43:10 <FabianW> Though for some reason the approach worked for the first part of day 7 where you just have to launch the program once and read its output once it terminates
02:43:33 <cdunklau> FabianW: okay, well the thing to realize is that you don't need a separate process to model the execution of an IntCode computer
02:44:23 <seishun> day 7 taught me about mapAccumL
02:45:03 <FabianW> cdunklau: Yea, I am starting to realize coding my own solution for day 5 and using that might be easier than wrapping my brain around passing data between tons of processes
02:45:05 <cdunklau> IME the hardest part of AoC is figuring out how to represent state. if you have a good data structure for that, the rest is pretty easy
02:47:50 <cdunklau> i'm still playing with day 7 part 2, but so far i've had good results by representing the IntCode computer's memory with `type IntCodeMemory = Array Int Int` and the whole state with `data ComputerState = ComputerState { cpuMem :: IntCodeMemory, cpuInstPtr :: Int, cpuInputs :: [Int], cpuOutputs :: [Int] }`
02:49:08 <cdunklau> while i had to do loads of refactoring between days 2, 5, and 7, i was able to reuse the core concepts based on that state
02:50:18 <FabianW> cdunklau: Every TA is supposed to choose 3 days to code an example solution for and I had the misfortune of choosing two days which depend on the Intcode Machine, so I'm most likely going to end up coding five days of this stuff. 
02:50:45 <cdunklau> lol
02:51:01 <FabianW> the example solution has been realized solely using I/O to the standard handles so it's hard to use it without IO
02:51:10 <cdunklau> yeah, screw that
02:51:59 <cdunklau> i mean, if you did it in like bash or something, sure I/O could be reasonable
02:52:21 <Rembane> Modelling the problem in terms of pure functions that do computations one step at the time makes the problem more pleasant. 
02:53:35 <FabianW> I also think that using child processes is just going to make the computations take hours. Day 7 part one launched about 600 child processes and took 12 seconds to terminate. I don't wanna know what would happen if I used the same approach for part two
02:54:34 <cdunklau> day 7 part 2 required me to rewrite a lot, because until then the IntCode computer always terminates because the inputs are known a priori
02:55:06 <cdunklau> so i wound up making a ComputationResult concept that could be either Running, InputRequired, or Halted
02:56:19 <ephemient> inter-process communication over pipes that works for me: https://gist.github.com/ephemient/755f0c10ffb9b938a00b76107cb92964
02:56:32 <cdunklau> FabianW: my d7p1 takes like a second
02:56:49 <ephemient> should not be super-different with createprocess, I just didn't bother compiling a binary for this
02:56:52 <cdunklau> and i'm quite sure it's not optimized at all
02:57:01 <FabianW> cdunklau: because you are using a sane approach
02:57:04 <cdunklau> :D
02:59:32 <seishun> day 7 taught me about mapAccumL
02:59:42 <FabianW> ephemient: interesting read, thanks for the example
03:02:54 <FabianW> seishun: That's a pretty cool function. These kinds of patterns are always really satisfying to understand.
03:07:32 <ephemient> in any case, for aoc day 7, I'm pretty proud of my solution that only runs each VM once :D
03:45:13 <FabianW> ephemient: and you have every right to be, solving that cleanly is a big piece of work
03:48:42 <nil> seishun: fwiw, mapAccumL is just traverse specialised to State
03:48:57 <nil> well, equivalent to
03:50:20 <dminuoso_> Id rather use traverse with State than mapAccumL
03:50:29 <dminuoso_> It opens up the wonderful wealth of monad combinators :)
03:50:55 <nil> and i guess mapAccumR would be using Backwards (State s) instead of State s
04:31:47 <fenedor> does stack not support internal libraries?
05:06:11 <hololeap> i'm a bit confused why `listen` is (m a -> m (a, w)) instead of just (m w)
05:07:09 <hololeap> i don't see a prominent example of when you wouldn't just use `listen $ pure ()`
05:08:20 <dminuoso_> hololeap: Think of the word listen.
05:08:31 <dminuoso_> hololeap: It's sort of like listening in on a line
05:08:45 <dminuoso_> It's an NSA style tap
05:08:51 <dminuoso_> Of course you don't get rid of the result
05:09:55 <dminuoso_> Oh wait, I grossly misread.
05:11:13 <hololeap> isn't `(a,w) <- listen m` equivalent to `a <- m ; (_,w) <- listen (pure ())`
05:14:13 <hololeap> oh, i guess it isn't. `listen` doesn't affect the current `w`
05:15:36 <hololeap> does it? how can i peek at the current `w` inside a MonadWriter? is it even possible?
05:19:14 <jackdk> ephemient: I'm about to sleep but thanks for digging. I'll have a look at those pastes.
05:20:05 <dminuoso_> hololeap: Why not?
05:20:48 <dminuoso_> hololeap: Ant it does affect it
05:21:27 <dminuoso_> hololeap: `listen` is basically "execute action then ask"
05:21:51 <dminuoso_> Or equivalently, a writer-specific ask is isomorphic to `listen (pure ())`
05:22:30 <nshepperd2> listen (pure ()) is pure mempty
05:22:51 <dminuoso_> hololeap: The thing is, unlike Reader you cant actually *read* your log until you have written it
05:23:14 <hololeap> https://hackage.haskell.org/package/transformers-0.5.2.0/docs/src/Control.Monad.Trans.Writer.Strict.html#line-247
05:23:52 <dminuoso_> (So `listen` can be thought of as embedding a sub-writer whose log you can read)
05:24:01 <nshepperd2> You can't access the 'current w' in Writer because there actually isn't really any such thing
05:24:08 <dminuoso_> "execute that thing, and tell me what it would append to the log"
05:25:48 <hololeap> ok, so then it isn't possible to check on `w` from within the MonadWriter. i can only check on it after calling runWriterT (or something similar)... is that right?
05:30:15 <hololeap> right now i'm looping in a (MonadWriter w m, MonadError e m) and i want to be able to `throwError $ MyError w` where `w` is the current accumulated monoid
05:30:30 <nshepperd2> @unmtl Writer w a -> Writer w (a, w)
05:30:30 <lambdabot> Writer w a -> Writer w (a, w)
05:30:38 <nshepperd2> Eh
05:31:26 <nshepperd2> Well anyway it's just (w,a) -> (w,(a,w))
05:35:55 <maerwald> my doctests can't find a module, although the dependency is in build-depends in the executable
05:37:57 <maerwald> this must be a regression
05:57:30 <dminuoso_> hololeap: Yes, that's right
06:00:31 <maerwald> is it possible to conditionally expose internal modules based on a cabal flag?
06:25:25 <hololeap> dminuoso_: thanks
06:26:32 <dminuoso_> hololeap: Remember that `Writer w a` is just `(w, a)`, you can't get the `w` out without actually computing the entire pair.
06:26:42 <dminuoso_> (Lazyness aside)
06:38:26 <halogen64> I am trying to better understand type families and monday morning haskell has an example that looks like this: https://gist.github.com/halogenandtoast/0fabd245cafd6f3a2faa81f4430d02a1, but I can not figure out how to use that instance, as it always tells me the logger is ambiguous, does anyone know what I can do to run this logger and then call prevMessages on the result?
06:38:42 <dminuoso_> halogen64: Can you include the complete error message?
06:40:27 <halogen64> dminuoso_: I don't have a good example that runs at the moment, hence the undefined. I could try to write something out, but I'd be concerned that I am approaching it entirely incorrectly.
06:40:51 <dminuoso_> halogen64: I dont mind the undefined in main.
06:41:01 <dminuoso_> halogen64: It doesnt have to run, I just care about the exact error message.
06:41:29 <halogen64> dminuoso_: Sure, I'll craft something up. My question isn't really about the specific error, but how to use such an instance.
06:41:54 <halogen64> the code with the undefined compiles
06:42:27 <dminuoso_> halogen64: Pretty much like you just did :)
06:42:34 <halogen64> Let's say I do something like: main = print $ prevMessages $ flip runState (ListWrapper []) $ logString "Hello"
06:42:53 <dminuoso_> halogen64: It's equivalent to multi-param typeclasses with functional dependencies.
06:43:23 <halogen64> Posted a comment here: https://gist.github.com/halogenandtoast/0fabd245cafd6f3a2faa81f4430d02a1
06:43:26 <halogen64> that shows the error I see
06:43:38 <dminuoso_> halogen64: Say `class MyLogger l m | l -> m where prevMessages :: l -> [String]; logString -> logString :: String -> m ()`
06:44:07 <dminuoso_> halogen64: This form is idiomatic in mtl and similar libraries. Yours uses closed type families, but its equivalent
06:44:39 <dminuoso_> halogen64: Ah right!
06:45:50 <halogen64> runState might not even be the right way to use this thing here, but I couldn't think of what to actually do with this instance.
06:46:18 <dminuoso_> halogen64: So first, your AllowAmbiguousTypes is unjustified, it hides a deeper flaw
06:46:45 <dminuoso_> % class MyLogger logger where   type LoggerMonad logger :: * -> *;   prevMessages :: logger -> [String]; logString :: String -> (LoggerMonad logger) ()
06:46:45 <yahb> dminuoso_: ; <interactive>:27:104: error:; * Couldn't match type `LoggerMonad logger0' with `LoggerMonad logger'; Expected type: String -> LoggerMonad logger (); Actual type: String -> LoggerMonad logger0 (); NB: `LoggerMonad' is a non-injective type family; The type variable `logger0' is ambiguous; * In the ambiguity check for `logString'; To defer the ambiguity check to use 
06:46:51 <dminuoso_> halogen64: Do you understand why you get this error message?
06:47:33 <dminuoso_> (Technically I lied, MPTC with fundeps are not equivalent, they are more constrained)
06:48:34 <halogen64> I assume because we don't know that the LoggerMonad is undecideable when I call logString
06:48:39 <bbear_> hi
06:48:41 <dminuoso_> Not undecideable
06:48:45 <dminuoso_> halogen64: Its non-injective
06:49:16 <dminuoso_> halogen64: Injectivity just means that the type family must not map two types to the same type
06:49:39 <halogen64> As in a uniquely determines b
06:49:49 <dminuoso_> That's the consequence
06:49:54 <dminuoso_> If its injective, it uniquely determines it
06:50:26 <dminuoso_> If its not, it doesnt. So conversely, if the type inference then saw `State ListWrapper` it *cannot* deduce that your `instance MyLogger ListWrapper` is to be chosen
06:50:51 <halogen64> So I would assume I'd either have to make it injective somehow, or use type applications to let the compiler know what I mean.
06:51:09 <dminuoso_> I could just write `instance MyLogger Bool where type (LoggerMonad Bool) = State ListWrapper`
06:51:35 <dminuoso_> So the type is truly ambiguous
06:52:01 <dminuoso_> halogen64: Right, either add an injectivity annotation to the type family, or just use the more readable fundep :)
06:52:19 <dminuoso_> mptc+fundeps are equivalent to associated injective type families
06:53:03 <dminuoso_> halogen64: If you do either, the error disappears
06:55:45 <halogen64> I'll have to mess with that a bit to see if I can get it working, it seems like a really weird example for MMH then since it's not usable in that form
06:56:11 <halogen64> The original article for reference: https://mmhaskell.com/blog/2019/2/4/why-haskell-v-type-families
06:57:00 <halogen64> It gets extremely hand-wavey towards how to use these
06:57:03 <dminuoso_> halogen64: Indeed. Its also weird to explain type families this way..
06:58:42 <dminuoso_> halogen64: Its quite possible the author never even tried to use their instances.
06:59:30 <dminuoso_> halogen64: I like to think of type families as giving you type level functions with case-of power. :)
06:59:46 <dminuoso_> What the article describes is *associated* type families, which is a bit more special
07:00:16 <halogen64> dminuoso_: I was trying to figure out associated type families specifically
07:00:49 <halogen64> Either way I switched to using functional deps, and there is still ambiguity https://gist.github.com/halogenandtoast/0fabd245cafd6f3a2faa81f4430d02a1
07:07:17 <dminuoso_> halogen64: Ah the fundep is the wrong way around.
07:07:24 <dminuoso_> halogen64: it has to be m -> l
07:08:15 <halogen64> I tried that too
07:08:40 <dminuoso_> Or.. let me look closed
07:09:17 <halogen64> It just changes which thing is ambiguous
07:09:30 <halogen64> m -> l, makes the m ambiguous
07:09:38 <halogen64> l -> m, makes the l ambiguous
07:10:00 <dminuoso_> Ah well yes, you definitely need AllowAmbiguousTypes for this class
07:10:12 <dminuoso_> In addition, such that ambiguity checks are deferred to call sites
07:10:33 <dminuoso_> halogen64: You want `m -> l` because you want the monad to uniquely determine the internal log format
07:11:01 <dminuoso_> halogen64: And you probably want `prevMessages` to have type `m [String]`
07:13:15 <halogen64> dminuoso_: it seems like this example might be a lost cause
07:19:22 <dminuoso_> halogen64: the flip is also ill placed.
07:20:10 <dminuoso_> halogen64: or rather runState
07:25:22 <halogen64> dminuoso_: how so?
07:25:42 <dminuoso_> halogen64: https://gist.github.com/dminuoso/51b46d464e5fe03472326b87eb1d4f95
07:25:51 <dminuoso_> halogen64: Something along these lines is what they probably meant
07:27:31 <dminuoso_> But the example remains weir
07:27:33 <dminuoso_> *weird
07:30:39 <halogen64> dminuoso_: thanks for your help, one day I will be able to add this to my toolbox, today doesn't seem like that day though.
07:43:49 <maerwald> can someone explain why I can build package A that depends on a newer containers version than shipped with my ghc, but only if I don't build the doctests?
07:46:36 <maerwald> package A depends on package B. Package B depends on containers>=0.5.8.2, ghc-8.0.2 ships with containers==0.5.7.1. Package A and B build fine, unless doctests are enabled
07:51:51 <maerwald> I'm starting to dislike doctests
07:52:42 <Taneb> As in, does enabling doctests cause the build to fail, or merely introduce a failing test
07:53:09 <maerwald> cabal cannot find a build plan
08:03:10 <bbear> hi
08:03:44 <heatsink> hi
08:05:07 <bbear> hi
08:05:53 <sm[m]> maerwald: we’d have to stare at the cabal output I think. Usually there’s some clue
08:20:54 * hackage filepath-bytestring 1.4.2.1.2 - Library for manipulating RawFilePaths in a cross platform way.  https://hackage.haskell.org/package/filepath-bytestring-1.4.2.1.2 (JoeyHess)
08:48:11 <maerwald> sm[m]: https://git.io/JeAZ7
08:51:23 <sm[m]> --minimize-conflict-set, interesting
08:52:11 <sm[m]> maerwald: maybe I’d try installing doctest directly with ghc 8.0, and look for further clues
08:53:08 <maerwald> sm[m]: I don't understand
09:00:00 <sm[m]> it’s failing to find an install plan for doctest I think ? Then try installing just doctest, to give it a simpler task, and the messages might be clearer
09:08:00 <giuliohome> Hi! I'm trying to stack build the repo https://github.com/glguy/advent2019 on Win 7
09:08:30 <fog> did anyone manage to read the HFree paste above?
09:08:34 <maerwald> sm[m]: doctests installs fine
09:09:20 <solonarv> giuliohome: it's not set up for building with stack (as you can see by the lack of a stack.yaml file), so that might not be possible without a bunch of hassle
09:09:24 * hackage filepath-bytestring 1.4.2.1.3 - Library for manipulating RawFilePaths in a cross platform way.  https://hackage.haskell.org/package/filepath-bytestring-1.4.2.1.3 (JoeyHess)
09:09:24 <giuliohome> I'm getting: unix is a library dependency, 
09:09:49 <solonarv> oh! okay, you have approximately zero solutions then
09:09:53 <giuliohome> Someone helped me with a stack.yaml last time on this channel
09:09:58 <solonarv> 'unix' unsurprisingly does not work on windows
09:10:01 <glguy> giuliohome: you don't need stack to build that repo. The cabal instructions in the readme work well
09:10:12 <giuliohome> Hi glguy!
09:10:31 <giuliohome> You are the master here in person, pleased to meet you "virtually"
09:11:01 <giuliohome> I'm a beginner in haskell, I know I have installed stack, should I also install cabal?
09:11:05 <solonarv> there is a 'vty' dependency and that library just doesn't work on windows
09:11:14 <fog> just trying to find the link, hang on
09:11:18 <solonarv> switching to a different build tool won't magically change that
09:11:48 <glguy> The vty dependency is for a standalone Breakout player. If you remove that from the cabal file you can build everything else
09:12:22 <fog> here it is; https://pastebin.com/raw/saJNTbn7
09:12:38 <giuliohome> Thank you, I try to remove it ... congrats again for the awesome result glguy
09:14:09 <glguy> I don't know if ansi-terminal works on Windows, but the standalone intcode player can be disabled if not
09:15:08 <solonarv> it does IIRC
09:15:10 <giuliohome> stack build is going on.. downloading 30 packages..
09:15:27 <giuliohome> in progress 15/30
09:15:50 <solonarv> even says so right in the subheading: "Simple ANSI terminal support, with Windows compatibility"
09:16:24 <giuliohome> I'm curious about day 23 at the moment, part 2 takes 3 minutes with my F#... lol
09:16:31 <glguy> Neat
09:17:32 <glguy> Mine runs in under a second iirc
09:18:07 <giuliohome> Indeed I read stats of mstksg and it was under a second too... so I wanted to look into the haskell code
09:19:07 <glguy> https://github.com/glguy/advent2019/blob/master/execs/Day23.hs
09:19:13 <giuliohome> yeah lol
09:19:21 <giuliohome> very funny
09:19:40 <giuliohome> I mean running maybe taking some internal stats I don't know how
09:26:04 <giuliohome> It is almost done... I remember last time I had to rebuild after changing the input file wiht mine
09:26:39 <giuliohome> kind of strange to me...the input is somehow linked into the build process... isn't it?
09:28:03 <glguy> No, the input is loaded at runtime
09:28:17 <glguy> You can specify a file name as the command line argument
09:30:04 <giuliohome> Perfect, thank you... will do ... (the linking phase is taking so long)
09:30:33 <giuliohome> yes just breakout failed
09:30:40 <giuliohome> I guess the rest is ok...
09:33:18 <giuliohome> yes it runs under a sec with my input file
09:33:58 <giuliohome> it writes a lot of SendY 10854 in the end. (and of course 10854 is the correct answer to part 2)
09:34:52 <glguy> Oops; I left that debugging code in at the end of main
09:34:55 <giuliohome> at first sight seems doind the same things, but much faster ... maybe the intcode machine itself is faster... I on
09:35:07 <giuliohome> but ok it is better for me
09:35:25 <giuliohome> otherwise I should have added and I didn't know how
09:36:22 <giuliohome> ok, thank you very much again, I'll play with it maybe next days... Happy new year!!!
09:38:50 <glguy> You're welcome, have happy New year to you, too
09:59:09 <heatsink> What do you call functions that deconstruct a data type in the most general way, like `maybe` and `either`?  They're like elimination rules in logic.
09:59:44 <solonarv> I've seen them called "eliminators"
10:00:07 <solonarv> also maybe "catamorphisms", although I tend to associate that with recursive data types specifically
10:02:21 <anon> does anyone know of a typeclass like Show which does not reveal security sensitive information, such as user passwords?
10:04:22 <MarcelineVQ> heatsink: oh man there is a word for it, right on the tip of my tongue
10:04:36 <ptrcmd> anon: how can it tell if something contains user passwords?
10:04:43 <ptrcmd> anon: manual annotation?
10:05:56 <anon> the idea would be that all types with instances of the type class will agree to not reveal sensitive info
10:07:26 <solonarv> you just rephrased the question
10:07:35 <solonarv> how is it supposed to know what "sensitive information" is?
10:08:38 <solonarv> you can easily write this: newtype Password = Password { getPassword :: Text }; instance Show Password where show _ = "Password \"redacted\""
10:08:50 <anon> instance SafeShow Username where    safeShow = showinstance SafeShow Password where    safeShow _ = "****"
10:09:12 <solonarv> well again, you don't need a fancy new typeclass for that
10:10:02 <anon> i was just wondering if there was already a well established typeclass for that
10:11:29 <geekosaur> what counts as sensitive depends on the app and its usage, seems to me a general typeclass would be tricky at best
10:12:19 <geekosaur> you don't get to override existing instances, for example
10:13:02 <MarcelineVQ> Why are you showing it anyway if it's not to be shown
10:16:01 <heatsink> thanks solonarv
10:16:53 <erisco> Show is not designed for user-facing output, btw
10:17:35 <fog76> has anyone ever been so miserably cold they have typed [1..] at the ghci terminal in the vague hope that it will burn some cpu and generate some heat!?
10:17:59 <MarcelineVQ> best to fork that a few times
10:18:06 <erisco> I want something multithreaded that does that for my laptop
10:18:07 <geekosaur> it's more for debugging output, and one of the principles is that what it produces should be a Haskell expression and in particular accepted by the corresponding Read instance
10:18:14 <anon> could be useful for logging where you want to dump some data without having to through nested structures to hide info. you could get free 'safeShow' instances for record types with generics
10:18:46 <erisco> Heated keyboard would be the best feature
10:18:49 * geekosaur got a hot back and a dead battery from his laptop not suspending this morning….
10:18:57 <geekosaur> (oops)
10:19:10 <anon> i'm aware of the relation with read, was just an example
10:19:55 <erisco> Laptops with metal chasis (like mine) wick away all your hand heat
10:20:47 <geekosaur> (I've also had a computer that worked as a space heater. also got a $1000 electric bill from the experience. not repeating that one again)
10:22:54 <erisco> Was it a Celeron D?
10:24:16 <fog76> a better use of cpu time would be training a deep generative net on old joe rogan vlogs to create the elusive deep fake rogan 
10:28:08 <fog76> i would have an episode where he interviews himself, getting more and more hilarious, and revealing the secrets of aliens and time travel and his own virtual existence 
10:28:37 <ptrcmd> fog76: lol
10:29:05 <ptrcmd> fog76: right, a great way to waste computaitonal resource lol
10:29:39 <fog76> not if it wins us the election! 
10:34:03 <MarcelineVQ> fog76: you can just watch an alex jones interview ep for that
10:34:40 <MarcelineVQ> jones on rogan I mean
10:51:54 * hackage git-annex 7.20191230 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-7.20191230 (JoeyHess)
10:59:31 <sm[m]> maerwald: back.. is this project or the cabal file visible online ? I like to practice deciphering these things
11:00:31 <sm[m]> it would be awesome if cabal/stack/something new could solve the problem of always providing clear actionable user messages
11:01:08 <int-e> . o O ( "You're using stack. Please seek assistance." )
11:01:15 <DigitalKiwi> i made a thing https://twitter.com/ArchKiwi/status/1211720742389321729?s=20
11:02:09 <sm[m]> oh it's hpath, I see
11:10:49 <maerwald> sm[m]: https://git.io/JeAlo
11:10:59 <maerwald> try with ghc-8.0.2
11:11:24 <maerwald> https://github.com/composewell/streamly/issues/83 also relevant
11:13:14 <maerwald> I think it must be the *package* 'ghc', which pins the containers version or something
11:13:57 <maerwald> https://hackage.haskell.org/package/ghc-8.6.5 this is probably installed by ghc, right? and then it pins all deps to the shipped ones
11:14:13 <merijn> If you link against GHC, yes
11:14:26 <maerwald> well, does doctest?
11:14:31 <merijn> Maybe?
11:14:33 <merijn> I dunno
11:16:28 <maerwald> I should be looking for a replacement of doctest, it just causes too many problems
11:17:22 <maerwald> keeps failing to find packages with newer cabals, so you must not use cabal new-run or cabal new-test, but cabal new-exec (what?)
11:18:05 <maerwald> also doesn't work well with docker images (it needs the entire source code and a working ghc)
11:18:19 <sm[m]> maerwald: cabal new-build finds an build plan here. Have you tried cabal new-update ?
11:18:28 <maerwald> sm[m]: what branch are you using
11:18:47 <maerwald> also, you need to pass --enable-tests
11:19:11 <sm[m]> the default.. eh.. master
11:19:26 <maerwald> I linked to the correct branch above
11:19:32 <maerwald> I don't push broken things to master :P
11:19:34 <sm[m]> thx
11:20:03 <geekosaur> this sounds like the bug is the ghc package is not itself pinned to the installed one, maybe. ghc 8.0, but ghc-8.6.5 package? sounds wrong
11:20:50 <maerwald> [__3] trying: ghc-8.0.2/installed-8.0... (dependency of doctest)
11:22:36 <maerwald> it kind of makes sense I guess, you can't have two different versions of containers in one dependency graph
11:23:32 <maerwald> but you can have a different container than the one shipped with your ghc, in some cases
11:24:21 <maerwald> that kind of breaks: https://github.com/composewell/streamly/blob/master/streamly.cabal#L88-L92 :P
11:27:49 <geekosaur> isn't it asking a bit much that they test with a package they presumably don't even know about that hauls in a doctest dependency?
11:28:58 <maerwald> any package that depends on 'ghc', that's not a trivial depgraph imo
11:29:20 <geekosaur> right, but few packages depend on ghc and it's normally hidden to avoid such deps
11:29:29 <d34df00d> I have a probably stupid question about criterion.
11:29:43 <d34df00d> I wanna write a blog post describing progressive steps on optimizing a certain function.
11:29:56 <d34df00d> And I'd like to include graphs comparing the different versions of ti.
11:30:00 <maerwald> 'ghc' doesn't have too many dependencies, so I guess it could be possible to compatibility with lower/upper bounds on releases
11:30:06 <geekosaur> er
11:30:07 <maerwald> *test
11:30:15 <geekosaur> you do know what ghc package is, right?
11:30:33 <maerwald> https://hackage.haskell.org/package/ghc
11:30:46 <d34df00d> But I dont' want to have N benchmark suites, where N is the optimization steps count. How do I best generate multiple result graphs from a single criterion benchmark set, progressively enabling more of the benchmarked implementations?
11:31:34 <merijn> d34df00d: Add a flag that controls which benchmarks to run?
11:31:52 <merijn> d34df00d: In fact, I'm 99% certain criterion's defaultMain already has a way to only run some benchmarks
11:33:09 <d34df00d> Hmm, yeah, I think I've seen that.
11:33:22 <d34df00d> Probably the best way to automate is to just throw up a small shell script or something.
11:33:36 <dsal> d34df00d: I used stack bench --ba computer/reddit for this thing today:  http://public.west.spy.net/haskell/reddit.html
11:34:04 <d34df00d> dsal: interesting, thanks!
11:34:20 <dsal> The benchmark suite is just code.  So you can generate as much as you want and then filter it however you want.
11:35:00 <dsal> Then I optimized my code by sticking `INLINE` in a few places.  heh
11:35:15 <geekosaur> channel?
11:35:39 <d34df00d> I had to write some code in ST with explicit loops :(
11:36:24 <d34df00d> https://github.com/0xd34df00d/edit-distance-linear/blob/master/src/Text/EditDistance/Linear.hs <- 20-30% faster than C++ with the same algo on my machine, slower than edit-distance though (they use a very different a way smarter algorithm, with different space-time tradeoffs though).
11:37:01 <maerwald> did you also test energy consumption? :P
11:37:27 <d34df00d> My machine eats 180 watts idle, that's probably not gonna be useful :)
11:38:39 <maerwald> https://greenlab.di.uminho.pt/wp-content/uploads/2017/10/sleFinal.pdf C++ still better than haskell
11:41:58 <sm[m]> maerwald: I'm not sure if you and geekosaur have figured this out already ?
11:43:55 <solonarv> dsal: great domain name, btw!
11:44:11 <sm[m]> streamly 0.7.0 requires a newer version of containers than the one that comes with ghc 8.0. In home dir, if I do cabal new-install streamly-0.7.0  --dry-run, it's happy to install the newer containers and streamly. But if I add doctest to that command line, it refuses to upgrade containers because "constraint from user target requires ==0.5.7.1". I can't see why that is.
11:44:41 <merijn> sm[m]: Presumably because doctest somehow uses ghc to get the doctests from the source?
11:46:27 <sm[m]> ok.. doctest depends on ghc.. and it's required to use the ghc that's installed, because ghc is a non-upgradeable package.. and therefore also the containers that ghc is depending on.
11:46:48 <geekosaur> sm[m], doctest uses ghc-as-a-library, which requires the containers that came with ghc
11:48:14 <dsal> solonarv: Thanks.  I've had it for like... 24 years now.  :|
11:49:31 <sm[m]> bottom line I guess: depending on doctest makes it harder to support many GHC versions; it requires that all your other deps support the libs that came with those GHC versions (unlike streamly in this case)
11:50:55 <maerwald> it's an unfortunate situation, because there's no easy way to know if you're breaking someone elses doctests
11:51:27 <geekosaur> there's on ly a small handful of such deps, and containers is generally the most annoying. ghc devs have considered various solutions but it's a hard problem
11:51:49 <sm[m]> is it possible to use doctest's test runner without depending on doctest ?
11:51:57 <geekosaur> (it also used to bite users of template haskell, some of whose apis used to expose bits of containers)
11:54:31 <sm[m]> as usual, after you understand the problem, then cabal's output makes sense
11:54:46 <sm[m]> s/usual/often/
11:56:59 <maerwald> it's still slightly confusing, because if you look at https://hackage.haskell.org/package/ghc-8.6.5/ghc.cabal containers is NOT pinned
11:58:11 <maerwald> so there's an exception to the rule, but the output doesn't show that this exception is currently applying
11:58:29 <merijn> maerwald: It doesn't have to be pinned, because you can't really buils ghc with cabal
11:59:09 <merijn> There's work towards making ghc (the library) cabal installable, but it's far from done
12:00:53 <geekosaur> in particular the cabal file is just enough to make hackage happy, not a full specification.
12:01:18 <maerwald> is ghc the only non-installable package? 
12:02:02 <merijn> In fact, to the best of my knowledge doctest is the main reason there is any effort at all to make ghc-the-library cabal installable
12:03:15 <geekosaur> base
12:03:27 <geekosaur> hm, I think
12:03:42 <maerwald> yeah, so I'm thinking maybe it would be good for cabal output to indicate that there's a non-installable package in the depgraph
12:03:48 <geekosaur> actually rts seems likely
12:04:05 <sm[m]> as it turns out, yes you can run doctests using doctest's generic "doctest" executable, instead of building your own test runner (and depending on doctest). 
12:04:38 <geekosaur> base might be installable given installed rts.
12:04:51 <geekosaur> and ghc-prim but I think for various reasons that one is installable
12:05:02 <maerwald> sm[m]: yep, but then it'll whine about dependencies missing ;)
12:05:28 <maerwald> it still needs access to the project environment
12:05:40 <sm[m]> if you need doctests to be an actual test suite, you can make one that just runs that exe (and fails gracefully if it isn't installed)
12:05:52 <sm[m]> you can to run it with (stack|cabal) exec -- 
12:06:14 <maerwald> yeah, that's the suggested solution on the doctest issue tracker as well
12:06:28 <sm[m]> aha
12:06:40 * sm[m] reinventing solutions the hard way
12:06:49 <maerwald> https://github.com/sol/doctest/issues/245
12:07:18 <sm[m]> actually, that might solve my own doctest problem (it can't see packages when run via cabal test, https://github.com/simonmichael/hledger/issues/1139)
12:07:44 <maerwald> yes, that looks like the same problem
12:08:08 <maerwald> after looking at cabal-doctest for 5 seconds, I looked away xD
12:08:19 <maerwald> looked like work.
12:09:34 <maerwald> the sad part is, if you want to create a test docker image from your project, it works very well with hspec, because it's just the spec executable. With doctest now you need the source code and a running ghc 
12:09:38 <sm[m]> maerwald: same! I couldn't understand it
12:09:59 <maerwald> that will blow up the size of your image as well
12:10:23 <glguy> I didn't bother understanding cabal-doctest. I copied the example in the readme and it worked
12:11:03 <sm[m]> I just wanted to understand the status, ie is cabal-doctest something I should even be using
12:11:18 <sm[m]> the package description itself throws that into question :)
12:17:50 <d34df00d> Uh.
12:17:53 <d34df00d> I'm reading vector docs.
12:17:56 <d34df00d> > constructN 3 f = let a = f <> ; b = f <a> ; c = f <a,b> in f <a,b,c>
12:17:58 <lambdabot>  <hint>:1:16: error:
12:17:58 <lambdabot>      parse error on input ‘=’
12:17:58 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
12:18:10 <d34df00d> Should it be `in <a, b, c>` and not `f <a, b, c>`?
12:19:02 <d34df00d> https://hackage.haskell.org/package/vector-0.12.0.3/docs/Data-Vector.html#v:constructN for instance.
12:56:49 <dmwit> d34df00d: probably
12:57:07 <d34df00d> dmwit: thanks.
12:57:11 <d34df00d> Will shoot them a PR.
12:57:41 <dmwit> > a == a
12:57:43 <lambdabot>  True
12:58:04 <ChaiTRex> :t a
12:58:06 <lambdabot> Expr
12:58:13 <dmwit> ?let succExprLol x = if x == a then b else if x == b then c else d
12:58:14 <lambdabot>  Defined.
12:59:12 <stilgart> > take 5 $ iterate succExprLol a
12:59:14 <lambdabot>  [a,b,c,d,d]
12:59:58 <stilgart> (omg, it works)
13:03:55 <ChaiTRex> > gcd a b
13:04:02 <lambdabot>  mueval-core: Time limit exceeded
13:06:03 <sm[m]> @where+ cabal-and-stack https://www.reddit.com/r/haskell/comments/egc8d0/a_few_haskell_highlights_of_2019/fcjr4tv/
13:06:03 <lambdabot> Nice!
13:07:41 <sm[m]> I think the post linked there is great and deserves more exposure
13:18:50 <maerwald> as a commenter said: with freeze files and index pinning, I don't see any reason to consider stack anymore. Especially because I can move faster with dependencies, without waiting for the next lts. And library authors are encouraged to keep their .cabal files proper and up2date
13:20:20 <fendoer> maerwald, last remaining pain point are automatic ghc installations
13:20:24 <maerwald> the docker integration: never needed, the nix integration: broken (according to a nix packager)
13:20:36 <maerwald> fendoer: well, ghcup ;)
13:21:27 <fendoer> maerwald, does it support windows now? 
13:21:39 <maerwald> fendoer: no, there is chocolatey for that
13:22:05 <maerwald> or https://github.com/kakkun61/ghcups/
13:22:10 <fendoer> then it still isnt as smooth as stack
13:22:17 <fendoer> oh nice
13:22:28 <maerwald> that is just a wrapper around chocolatey
13:23:08 <fendoer> that is fine as long as it is a single command or two at most
13:25:24 * hackage radius 0.6.1.0 - Remote Authentication Dial In User Service (RADIUS)  https://hackage.haskell.org/package/radius-0.6.1.0 (erick)
13:27:29 <fendoer> does cabal work now reliably on windows?
13:33:24 * hackage structured-cli 2.5.2.0 - Application library for building interactive console CLIs  https://hackage.haskell.org/package/structured-cli-2.5.2.0 (erick)
13:49:33 <phadej> fendoer: https://hub.zhox.com/posts/introducing-haskell-dev/
13:52:01 <phadej> afaik stack installs own msys2, which is suboptimal
13:53:21 <maerwald> phadej: according to the haskell survey 2019, 1% of windows users use chocolatey =o
13:54:12 <maerwald> "popularity quickly growing" is unfortunately an overstatement
13:54:45 <phadej> popularity of chocolatey in general, not in Haskell
13:55:36 <maerwald> well, don't have any numbers for that
13:56:03 <phadej> chocolatey ghc and cabal pckages are good, so i recommend them
13:56:24 <fendoer> well, not that I want to develop on windows, but it is obviously good if the situation is improving
13:56:53 <maerwald> phadej: yeah, but I'm wondering why most people here haven't heard of it
13:57:09 <merijn> because most people *here* use linux or macos :p
13:57:10 <phadej> otoh homebrew formulas on macos are bad, as they don't support multiple versions
13:57:25 <maerwald> merijn: where are the windows users? matrix?
13:58:31 <maerwald> and haskell-platform doesn't seem to recommend it, that might be another reason
13:58:50 <merijn> homebrew sucks balls for Haskell, yeah, especially with their "bleeding edge always" policy
13:59:23 <merijn> maerwald: No clue, maybe not anywhere?
14:00:42 <fendoer> I know one windows dev here.
14:04:38 <merijn> phadej: On the other other hand, macOS bindists are super simple to install, since there's only one instead of guessing which of the 10 linux bindists you need :)
14:05:05 <maerwald> lol
14:05:05 <fendoer> haskell-dev is really cool. It looks like it is really easy now to set up a full haskell env with few steps
14:06:05 <maerwald> I think we should work towards a fully statically linked GHC and put an end to this libtinfo and whatnot madness
14:07:00 <merijn> maerwald: word
14:07:06 <Uniaika> maerwald: preach
14:13:41 <solonarv> fendoer: last I used it, cabal worked fine on windows; the 3.0 release fixed the last issues I had been running into
14:14:32 <solonarv> those issues being: v2-install couldn't install by copying bins, only by symlinking; and cabal script failing because of CRLF line endings
14:15:27 <fendoer> I didnt like the msys2 dep which I never figured out completely. 
14:15:45 <fendoer> But I didnt know that choco can take care of this... I expect stuff to become easier
14:16:23 <solonarv> I actually used msys2 as my main shell :P
14:16:33 <solonarv> only used cmd when I had to
14:16:34 <maerwald> you'll still have lots of packages being straight out incompatible with windows...
14:16:43 <solonarv> yeah, that is a problem
14:16:50 * solonarv looks askance at vty
14:17:54 <fendoer> yeah, that is a problem, too.
14:18:56 <maerwald> Well, I prefer packages failing to build over half-assed platform-abstraction. Platform abstraction is hard and may not be correct. So sometimes it's better to write different code for both platforms.
14:19:54 <maerwald> for mac vs linux vs *bsd that may not be a problem, but for windows I believe it is
14:24:20 <Uniaika> sometimes the mac/linux/BSD abstractions are the trickiest when too much similarity is assumed and some code behaves in improbable ways, whereas Windows code has the merit to be targetting a whole different platform so we're not too tempted to reuse stuff that shouldn't be
14:24:47 <Uniaika> but as with most questions, the answer is of course "it depends"
14:27:50 <maerwald> depends on whether you have enough users who do the bold testing :P
14:29:07 <merijn> tbh, I think one of the problem is that the cross platform abstractions never really go the extra mile of implementing proper windows support :p
14:29:39 <merijn> Lots of stuff is possible, but someone has to be both windows savvy enough to implement it and actually have that time
14:29:53 <maerwald> if they do, you'll end up with something like the 'directory' package, where it becomes impossible to reason about your codebase
14:30:20 <maerwald> all you know it that it *roughly* does the same
14:30:34 <maerwald> so "deleteFile" *probably* does not create directories...
14:36:21 <maerwald> then again, wxWidgets managed to do something like that
14:36:51 <maerwald> but it probably wasn't trivial :P
14:37:08 <Uniaika> < maerwald> depends on whether you have enough users who do the bold testing :P // I was about to make a joke about ANSI bold styling then realised you deserved better out of an IRC conversation :P
15:15:37 <dsal> Does anyone have an example bit of code for returning a list from FFI?
15:17:16 <nathan> nick remexre2
15:17:19 <nathan> whoops
15:17:42 <remexre2> (how) should one install stack if ghcup is already installed??
15:17:46 <merijn> dsal: The Foreign.Marshal hierarchy has methods for turning C arrays into lists
15:18:04 <merijn> (and vice versa)
15:18:07 <Axman6> we were just talking about this yesterday
15:18:20 <dsal> merijn: Thanks.  Looking about.  This is the less fun stuff to write.  :)
15:18:37 <Axman6> http://hackage.haskell.org/package/marshal-contt-0.2.0.0/docs/Foreign-Marshal-ContT.html imakes FFI code much more pleasant
15:19:40 <Axman6> which was born from this conversation: http://tcp.st/78v35.png
15:20:27 <dsal> I don't know ContT.  I guess I should do some of that.
15:20:56 <solonarv> remexre2: stack and ghcup should be completely independent
15:21:02 <Axman6> you don't really need to know it, just that it makes the explicit continuation passing code you usually write when marshalling stuff unnecessary
15:21:32 <Axman6> % :t ContT (allocArray 10)
15:21:33 <yahb> Axman6: ; <interactive>:1:8: error: Variable not in scope: allocArray :: Integer -> (a -> m r) -> m r
15:21:33 <solonarv> so installing stack is exactly the same, no matter whether ghcup is already installed or not
15:21:41 <dsal> Hmm....  Yeah, I ahve some of that.
15:21:55 <merijn> dsal: See this stackoverflow: https://stackoverflow.com/questions/26436095/what-are-good-haskell-conventions-for-managing-deeply-nested-bracket-patterns
15:22:20 <remexre2> solonarv: okay, so I can do the normal "install to home folder" procedure?
15:22:31 <Axman6> using the real world haskell example of binding to pcre, you can make this change: https://gist.github.com/axman6/3a1528111aad4cb79ea44b51836dec85
15:22:52 <dsal> Nice.  This does look familiar.
15:23:14 <Axman6> (where the second set of code is using the finctions in the linked module)
15:25:23 <solonarv> remexre2: indeed
15:26:13 <remexre2> solonarv: okay, thanks
15:34:43 <sm[m]> has anyone got ghcide working with intellij IDEs yet ?
15:35:28 * dsal keeps reading "ghcide" as some kind of GitHub killer
15:38:08 <ephemient> you could theoretically set up stack to use a ghcup-installed ghc
15:38:15 <hpc> a type theorist was found dead in his home, it was ruled a homicide :D
15:38:34 <hpc> dsal: ^^
15:39:00 <Rembane> The murderer was chased in HoTT pursuit.
15:40:24 <hpc> the detectives said they were still investigating, but would soon get to the bottom of it
15:47:11 <maerwald> detective Curry lazily evaluated the crime scene
15:48:00 <bitmapper> hmm
15:48:17 <bitmapper> the monadfail proposal is confusing me
15:48:34 <bitmapper> i should have spent more time reading about it
15:48:46 <dsal> Proposal?
15:48:54 <sm[m]> dang I wanted to hear what happened next
15:49:17 <maerwald> sm[m]: his wife Idris called and told him to stop being lazy
15:49:49 <bitmapper> dsal: yes, the doc that talks about monadfail
15:49:52 <sm[m]> I forget and can't see from the readme, is ghcide supposed to work across GHC versions ? Or do you have to use a ghcide compiled with the same GHC as your project ?
15:50:32 <dsal> bitmapper: You mean how fail was removed from Monad?  Seems a little late to call that a proposal if that's what you're talking about.
15:50:45 <bitmapper> no, i mean the actual proposal document
15:50:58 <bitmapper> i'm reading over it trying to figure out how to update this old code
15:51:06 <sm[m]> I just built the latest ghcide with 8.6, and when I run it in a 8.8 project it says ghcide: unable to load package `ghc-prim-0.5.3'
15:51:55 <solonarv> bitmapper: write MonadFail instances where possible, add MonadFail constraints where needed, remove failable pattern binds in monads that aren't MonadFail
15:52:52 <solonarv> for example, if you have a do block in 'StateT S (Writer W)' it should not contain any failable pattern binds (like 'Just x <- ...')
15:53:06 <MarcelineVQ> "<sm[m]> ... is ghcide supposed to work across GHC versions" not that I've seen with that kind of tool
15:54:00 <bitmapper> specifically there's a line like this 'Weight _ w _ <- liftST $ readSTRef r'
15:55:31 <bitmapper> nevermind
15:55:38 <bitmapper> got it solved
15:57:16 <dsal> So far, my biggest problem has been Other People's Code
15:57:33 <sm[m]> ack, there it is: "t's important that ghcide is compiled with the same compiler you use to build your projects."
15:57:36 <bitmapper> that's always the biggest problem
15:57:49 <bitmapper> sm[m]: the solution is to use hugs
15:57:54 <bitmapper> never changes versions
15:57:55 <bitmapper> no worries
15:57:58 <sm[m]> ha ha
15:58:39 <bitmapper> i'm trying to update JHC's GRIN backend so i can look at bolting it on to idris
15:58:48 <dsal> Solution to making the world a better place:  hugs
16:01:32 <MarcelineVQ> a grin backend for idris already exists
16:06:06 <bitmapper> yes, but it uses the annoying llvm grin
16:09:41 <loli> really?
16:09:46 <loli> how is grin annoying?
16:09:52 <loli> it seems to be a decent set of optimizations?
16:15:35 <bitmapper> loli: it's a pain to build on macos
16:15:45 <loli> ahh that is a shame, why is that?
16:15:50 <loli> building LLVM in general is a mess
16:15:51 <bitmapper> llvm is a static library
16:16:07 <bitmapper> template haskell requires dynamic libraries
16:16:11 <bitmapper> (for this)
16:16:18 <bitmapper> iirc
16:17:06 <aplainzetakind> :t foldl (>=>) pure
16:17:07 <lambdabot> (Foldable t, Monad m) => t (b -> m b) -> b -> m b
16:17:58 <aplainzetakind> Is there something like this which takes the initial b and ends up with m (t b), collecting the intermediate stuff?
16:18:29 <Rembane> aplainzetakind: Something like scanl'? 
16:18:33 <Rembane> :t scanl' 
16:18:35 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
16:18:39 <solonarv> traversing with StateT should do it
16:18:41 <loli> there is a generic scanl in the stdlib
16:18:51 <loli> :t mapAccumR
16:18:52 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
16:19:08 <solonarv> that's not actually general enough
16:19:13 <solonarv> it traverses with State, not StateT
16:19:57 <aplainzetakind> I considered scanl but thought that might lead to unexpected stuff with the effects in general.
16:20:20 <aplainzetakind> Each entry of the list would start over so to say.
16:24:13 <solonarv> :t \f a xs -> runStateT (traverse (\e -> do s <- get; s' <- lift (f e s); put s'; return s') xs) a
16:24:14 <lambdabot> (Traversable t1, Monad m) => (t2 -> b -> m b) -> b -> t1 t2 -> m (t1 b, b)
16:25:20 <solonarv> aplainzetakind: I think this is more or less what you want
16:25:46 <aplainzetakind> solonarv: Precisely the type signature I need.
16:25:56 <aplainzetakind> Thanks.
16:25:57 <solonarv> up to minor variations like using ReverseStateT instead of StateT, or swapping the argument order of 'f', etc
16:26:15 <solonarv> this traverses left-to-right
16:37:32 <sm[m]> yup, using a ghcide binary built with matching GHC version fixed that error
16:38:10 <sm[m]> https://github.com/gtache/intellij-lsp/issues/125 is how far I got with ghcide + intellij IDEA. Subscribing/voting/commenting there might attract help
16:47:23 <sm[m]> @where+ ghcide-intellij https://github.com/gtache/intellij-lsp/issues/125
16:47:23 <lambdabot> Done.
17:07:24 * hackage quantification 0.5.1 - Rage against the quantification  https://hackage.haskell.org/package/quantification-0.5.1 (chessai)
17:11:54 * hackage geos 0.3.0 - Bindings for GEOS.  https://hackage.haskell.org/package/geos-0.3.0 (petefrance)
17:21:24 * hackage chimera 0.3.0.0 - Lazy infinite streams with O(1) indexing  https://hackage.haskell.org/package/chimera-0.3.0.0 (Bodigrim)
18:39:20 <dsal> solonarv: what is reverse state?  I don't quite get the concept.
18:39:52 <Axman6> reverse state passes the state from the future into the past
18:40:01 <dsal> I tried reading tardis docs and vacillated between "this is neat" and "this is pointless"
18:40:03 <Axman6> (That's not a joke, that's literally what it does)
18:40:44 <dsal> What is a use case of reverse state?
18:45:38 <Axman6> I'm sure there's many, but I think one of the canonical examples is labeling all the elements in a traversable strucutre in reverse order, without knowing ahead of time how many elements there are. something like traverse (\a -> modify (+1) *> (,a) <$> get) would give the rightmost element in the structure the lowest label and the leftmost the highest
18:46:22 <solonarv> one of mapAccumR / mapAccumL is traverse using State as the applicative, the other one is traverse using ReverseState
18:46:51 <solonarv> you can actually find a StateL and a StateR in Data.Traversable or wherever mapAccum{R,L} are implemented
18:47:59 <dsal> That's interesting.
18:48:13 <dsal> I was hoping for something exotic.
18:48:47 <Axman6> it can probably be used for abstracting some tying-the-knot algorithms
18:49:46 <iqubic> What the hell are StateL and StateR?
18:50:02 <solonarv> one of them is just the usual State, the other one is ReverseState
18:50:47 <solonarv> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Functor.Utils.html#StateL
18:53:53 <dsal> I think I've internalize the concept a bit.
18:54:38 <dsal> So, get the value and call it x.  Then add two to it.  Then store 1.
19:35:49 <Ailrun[m]> Or one can use `Backwards` transformer on State monad.
19:42:12 <Ailrun[m]> (or `Reverse`, depending on his/her use case)
19:47:19 <a1c> let fn = out fn in return fn, what this suppose to mean?
19:47:36 <a1c> fn = out fn would be infinite type?
19:51:40 <mniip> depends on the type of `out`
19:53:18 <ephemient> same as `return (fix out)` isn't it?
19:53:54 <a1c> not same as `return (out fn)`?
19:53:54 <ephemient> :t fix
19:53:55 <lambdabot> (a -> a) -> a
19:54:31 <a1c> this is related to fixed-point
19:54:32 <a1c> ?
19:55:25 <ephemient> the `return` doesn't really have anything to do with it
19:55:45 <a1c> fn is a fixed-point in out?
19:56:19 <ephemient> given `let fn = out fn` then `return fn` and `return (out fn)` are the same thing by substitution
19:57:06 <a1c> ephemient: but that fn is not defined anymore
19:57:17 <ephemient> why isn't it?
19:58:59 <a1c> \out -> let fn = out fn in return fn
19:59:11 <a1c> \out -> return (out fn)
19:59:19 <a1c> where this fn come from?
19:59:32 <ephemient> I mean like let fn = out fn in return (out fn)
20:00:39 <a1c> when will `out fn` == fn?
20:00:55 <a1c> f(x) = x
20:02:07 <ephemient> that's what the fixed point is
20:06:47 <iqubic> Alright.. I just discovered the best new feature ever.
20:08:22 <dsal> I've known about that feature for years.
20:10:26 <iqubic> Well, It's just that I can now jump to the definition of the function where my mouse cursor is.
20:10:47 <iqubic> I can also get the type of said function.
20:11:25 <iqubic> Even if that function happens to be defined in a where block, and I haven't explicitly stated its type.
20:11:31 <dsal> Are you using emacs?
20:12:01 <iqubic> Yes.
20:12:04 <iqubic> I'm using Dante.
20:17:31 <leifm> What's the best way of getting that working with vim? Tags?
20:18:43 <iqubic> I have no idea.
20:44:55 <Ailrun[m]> HIE?
20:46:18 <Ailrun[m]> I mean, Haskell IDE Engine with some kinds of LSP client.
20:46:36 <oats> I hear hie + coc.nvim is nice, but I haven't gotten it working properly yet :(
21:06:11 <Tordek> hi
21:09:58 <Tordek> is there a way to combine different `Either`s? e.g., I have some function `openFile :: String -> Either LoadFileError File` and `readFile :: File -> Either ReadFileError String` and I want to combine them into some sort of... `openAndRead :: String -> AnyOf ReadFileError OpenFileError String`
21:11:54 <dibblego> you can use classy prisms to do it
21:12:53 <dsal> Time travel is kind of neat. https://www.irccloud.com/pastebin/dnwzJzOO/tard.hs
21:12:58 <dsal> I'll have to figure out a way to do this.
21:13:00 <Tordek> thank you
21:13:23 <Tordek> that filename tho
21:14:50 <iqubic> dsal: Does that return 3?
21:14:54 <dsal> It does.
21:15:28 <iqubic> Cool. And I assume it can also be used like a bog standard state monad too.
21:15:35 <Ailrun[m]> Tordek: try monad transformer, or bifunctor to lift error types
21:15:47 <dsal> iqubic: It's two states and an output.  So you can do forward and reverse state at the same time.
21:16:08 <dsal> {send,get}{Future,Past}
21:16:24 <iqubic> I know. I know how it works.
21:16:49 <dsal> Heh, why do you ask questions when you know the answers?  :)
21:17:06 <dsal> He quit, but he knew I asked the question, anyway.
21:17:43 <N3RGY> Tordek: http://paste.best/p/gi30HlJzBEE=
21:18:38 <N3RGY> ^ That's using bifunctor to wrap the error types in another type
21:21:06 <Tordek> cool, thank you N3RGY!
21:25:16 <N3RGY> Sure thing! If you use a monad transformer to combine error handling with IO, those will also expose some way to map over the error values
21:28:34 <N3RGY> You can also use something like the Capabilities package to name the different kinds of errors you can throw, and you can later decide whether you want to wrap them up or throw them as IO exceptions or whatever. Your code will end up looking like 'throw @"foo" FooError >> throw @"bar" BarError'. That's kind of advanced though. Just maybe something to look forward to if you tire of manual Either-based error management
21:29:17 <iqubic> This is literally the coolest emacs thing I've found.
21:29:18 <iqubic> https://github.com/jyp/attrap
21:33:09 <iqubic> Except it doesn't work with hlint, which is a bit sad.
22:29:02 <root> hai
22:29:06 <root> anyone here?
22:29:19 <heatsink> no one is here
22:29:52 <Guest8590> sorry
22:59:24 <const_91> what does this "(..)" symbol mean in this line "import           Crypto.Hash             (hash, SHA256 (..), Digest)" ?
23:00:10 <heatsink> It imports all the constructors and field names of SHA256
23:00:43 <const_91> oh! Thanks!!
23:32:24 * hackage boopadoop 0.0.0.1 - Mathematically sound sound synthesis  https://hackage.haskell.org/package/boopadoop-0.0.0.1 (lazersmoke)
