00:58:57 <rnmhdn> how does haskell handle complex expr + complex expr ?
00:59:20 <rnmhdn> in what conditions does it do lazy evaluation and optimizes it into 2*complex expr?
01:03:49 <pavonia> Are you sure it ever does that? x + x could result in something completely different than 2*x
01:05:58 <ClaudiusMaximus> rnmhdn: common subexpression elimination by introducting sharing can change space usage dramatically, so afaik ghc doesn't do it much
01:06:33 <rnmhdn> in what conditions does it do lazy evaluation and optimizes it into 2*complex expr?
01:06:43 <LevyElara[m]> what are the other possible io replacements/effect management? So far I'm aware of linear types for the world (and uniqueness), continuation passing, and streaming io.
01:07:03 <rnmhdn> ClaudiusMaximus: thanks
01:08:17 <LevyElara[m]> ClaudiusMaximus: if it's let bound it will iirc but otherwise not iirc
01:09:30 <ClaudiusMaximus> LevyElara[m]: if it's let bound the programmer explicitly added sharing?
01:11:50 <LevyElara[m]> yes
01:15:11 <qualiaqq> My impression of rnmhdn's question was: Does lazy expressions ever become optimized into strict?
01:16:09 <rnmhdn> what does optimized into strict mean?
01:17:25 <qualiaqq> Just doing something like 2 + 2 instead of heap allocating thunks etc.
01:17:49 <LevyElara[m]> like most languages it's changed to be evaluated instantly rather than delayed
01:21:15 <qualiaqq> Without seq or bang patterns and things like that? 
01:22:00 <qualiaqq> How would it now it's not going to hit an error like let x = 2 + undefined
01:22:13 <qualiaqq> know*
01:31:37 <LevyElara[m]> it would hit the error
01:31:40 <LevyElara[m]> if it's used
01:37:44 <qualiaqq> I was just genuinely curious about it. Just found in the Haskell book it mentions the following: "GHC Haskell has some opportunistic optimizations which intro-duce strictness to make code faster when it won’t change how yourcode evaluates." page 319
01:40:25 <qualiaqq> I'm curious how that works because let x = 2 + undefined will result in an error if it's used, but if strict vs lazy can change the behavior of when the error occurs.
01:44:38 <pavonia> Note that it very much depends on the type that is being used. You could define a data type for which `2 + undefined` doesn't give an error, or atleast not immediately. For the native types `x = 2 + undefined` and `x = undefined` should be equal
01:50:23 * hackage gi-gtk-declarative 0.6.1 - Declarative GTK+ programming in Haskell  https://hackage.haskell.org/package/gi-gtk-declarative-0.6.1 (owickstrom)
01:51:23 * hackage gi-gtk-declarative-app-simple 0.6.1 - Declarative GTK+ programming in Haskell in the style of Pux.  https://hackage.haskell.org/package/gi-gtk-declarative-app-simple-0.6.1 (owickstrom)
01:51:25 * hackage tidal 1.4.7 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-1.4.7 (AlexMcLean)
01:58:22 <qualiaqq> "Why is the list shown fully evaluated when it’s not been needed by anything? This is an opportunistic strictness. GHC will not thunk (and thus delay) data constructors. Data constructors are known to be constant, which justifies the safety of the optimization." pg 1074 Haskell Book
01:59:10 <qualiaqq> Some missing context there, but it seems GHC is smart enough to avoid optimization from non-strict to strict when it will hit bottom (an error).
02:02:57 <qualiaqq> Instead of my saying "will hit" I probably should have said "could hit."
02:14:00 <phadej> I don't see "will hit" in that quote
02:14:21 <phadej> ah, your saying
02:15:32 <phadej> GHC is indeed "smart enough" (i'd rather say correct and conservative) to not do any (potentially) unsound transformataions
02:15:36 <Phyx-> phadej: quick question.. can I still specify hsc2hs-options in a .cabal file? I'm getting unknown field ..
02:16:54 <phadej> Phyx-: no, simonmar made a PR recently, https://github.com/haskell/cabal/pull/6295, but didn't come back after "change requested" comments
02:18:51 <Phyx-> phadej: ah, those are quite minor. I'll probably respin that next week as without it debugging hsc2hs with cabal is hard
02:20:01 <Phyx-> phadej: fyi the bug reported for win32 is either a cabal or hsc2hs bug, trying to figure which one now. but indeed, hsc2hs thinks it needs to cross compile, so not sure if it detected this or if cabal told it to
02:22:44 <phadej> (FWIW, my plan for 2020-01 is to go thru open Cabal PRs and either try to merge them, or close; this PR as currently will fail into close: I briefly reviewed that PR the next day, but as there are no action, I'd rather not leave it lingering)
02:22:53 * hackage gi-gtk-declarative-app-simple 0.6.2 - Declarative GTK+ programming in Haskell in the style of Pux.  https://hackage.haskell.org/package/gi-gtk-declarative-app-simple-0.6.2 (owickstrom)
02:23:35 <phadej> (as e.g. having open PRs from 2015 doesn't really add any value :)
02:23:54 * hackage gi-gtk-declarative 0.6.2 - Declarative GTK+ programming in Haskell  https://hackage.haskell.org/package/gi-gtk-declarative-0.6.2 (owickstrom)
02:25:05 <Phyx-> phadej: fair enough, but that PR is very handy though.
02:26:17 <phadej> you are the proof that handy / important things will pop up again :)
02:27:49 <phadej> (and I'd rather concentrate on things that need fixing, but no-one wants or dare to fix)
02:28:25 <phadej> e.g. cache directories on Windows ;)
02:28:58 <Phyx-> phadej: \o/
02:29:12 <Phyx-> phadej: do you know when cabal decides it needs to cross compile?
02:29:24 <Phyx-> that logic seems to be incorrectly triggering for x86 builds
02:30:28 <Phyx-> ah no, wait.. maybe I see the problem..
02:34:14 <Phyx-> phadej: it seems it's just a bug in the appveyor script :)
03:06:48 <wonderC[m]> what is Curry-Howard isomorphic? what it's used to? what is Peirce's law and used to?
03:31:12 <wonderC[m]>  callCC::(a->m b)->m a->m a, f::(a->m b)->m a, what this f looks like?
03:32:10 <shachaf> It looks like f _ = 5, or f k = k 5, or something more complicated.
03:36:54 <wonderC[m]> but f _ = 5 don't match the type
03:48:19 <shachaf> f _ = return 5
03:49:51 <wonderC[m]> shachaf but _ doesn't match a->m b
03:50:29 <shachaf> How could it not?
03:50:54 <wonderC[m]> it could?
03:51:51 <Rembane> :t \_ -> return 5 
03:51:52 <lambdabot> (Monad m, Num a) => p -> m a
03:53:05 <jle`> wonderC[m]: _ matches anything ...
03:53:07 <jle`> it's a wildcard
03:53:19 <jle`> there isn't anything that it *doesn't* match
03:53:23 <wonderC[m]> g = \_ -> return 5
03:53:39 <wonderC[m]> g :: a-> m a
03:54:07 <wonderC[m]> f g = return 5
03:54:38 <wonderC[m]> but what callCC f id =?
03:55:14 <wonderC[m]> callCC f :: m a
03:55:30 <jle`> wonderC[m]: do you have a working ghci/ghc/haskell installation available?
03:55:42 <jle`> if so, you can find out by trying it out interactively :)
03:56:02 <wonderC[m]> jle I'm on the road
03:56:25 <wonderC[m]> with my phone here,
04:31:24 * hackage path 0.7.0 - Support for well-typed paths  https://hackage.haskell.org/package/path-0.7.0 (mrkkrp)
04:54:43 <hseg> Hi. How do I convert a function of type RandomGen g => g -> (P, g) to a Gen P ?
04:54:59 <hseg> (the library I'm using doesn't provide an Arbitrary instance)
05:20:12 <nil> hseg: use that function to implement a Random P instance, then use chooseAny :: Gen P
05:21:12 <hseg> Ah, OK.
05:24:49 <hseg> Q: Once I have a Gen P, how do I use it to test a property of type P -> Property?
05:26:13 <hseg> Make an Arbitrary instance from that Gen P, then quickcheck prop ?
05:26:32 <Rembane> hseg: Or feed it a P and then run quickCheck on it. 
05:26:47 <Rembane> hseg: now I understood what you said, yes your approach is good.
05:27:10 <hseg> Oh, so do { p <- generate $ chooseAny randP; quickcheck (prop p); } would also work?
05:27:21 <Rembane> Yes. 
05:27:34 <hseg> type tetris is a bit harder due to quickcheck being variadic
05:27:36 <hseg> thanks
05:27:44 <Rembane> It is. No worries.
05:40:28 <ggole> > (+) 0o17
05:40:31 <lambdabot>  <Integer -> Integer>
05:40:33 <ggole> > (+) 0o18
05:40:36 <lambdabot>  9
05:40:48 <ggole> Hmm.
05:41:26 <LKoen> what
05:41:43 <LKoen> > (+) 0o17 0
05:41:45 <lambdabot>  15
05:41:50 <LKoen> that makes sense
05:42:04 <LKoen> > 0o18
05:42:05 <ggole> The lexer is seeing the second as 0o1 8
05:42:06 <lambdabot>  error:
05:42:06 <lambdabot>      • Could not deduce (Num t0)
05:42:06 <lambdabot>        from the context: (Num t, Num (t -> t1))
05:42:12 <LKoen> oh, fair enough
05:43:19 <jchia_> I've a question about the streaming package, specifically, enumFrom. https://www.stackage.org/haddock/nightly-2019-12-27/streaming-0.2.3.0/Streaming-Prelude.html#v:enumFrom
05:43:28 <ggole> Not sure this is likely to be mistake in real programs, but still an eyebrow raising moment
05:43:46 <jchia_> They say that code snippet is impossible is impossible with each [1..], but I just tried it without problems in my repl
05:43:53 <jchia_> what's going on? is the doc out-of-date?
06:23:07 <Phyx-> phadej: you wouldn't happen to know how to modify nested cabal configs? hvr showed me once but I lost the logs.. I thought it was "cabal user-config diff -f -a 'program-locations' -a 'pkg-config-location: fooo'" but that just says unknown field pkg-config-location
06:40:19 <statusfailed> ghci is printing ? for unicode characters, I assume I've messed up some environment variables for that to happen?
06:41:24 * hackage arrowp-qq 0.3.0 - A preprocessor and quasiquoter for translating arrow notation  https://hackage.haskell.org/package/arrowp-qq-0.3.0 (riuga)
06:50:45 <[exa]> statusfailed: very probably just set TERM or LC_ALL to a reasonable value
07:08:32 <statusfailed> [exa]: doesn't seem to work weirdly
07:09:15 <statusfailed> it's weird cuz it works in my terminal
07:15:52 <phadej> Phyx-: no idea, sorry
07:30:08 <sm[m]> statusfailed: have you mentioned your OS ?
07:31:59 <geekosaur> also if it's locale related, mention if you're using nix because it needs some special hacks outside of a nix environment
07:32:11 <geekosaur> (I came in late byt saw LC_ALL mentioned)
07:34:34 <sm[m]> https://github.com/simonmichael/hledger/issues/1033#issuecomment-497940396, right geekosaur ?
07:34:57 <geekosaur> yes
08:02:04 <Raito_Bezarius> I'm trying to add features to some Haskell binary, but I failed due to build issues (https://github.com/phuhl/linux_notification_center/issues/21) ; do anyone knows if there could have been breaking changes regarding haskell-gi recently? Most specifically, for `styleContextAddProviderForScreen` and `CssProvider`/`ManagedPtr`
08:05:53 * hackage bugsnag-hs 0.1.0.0 - A Bugsnag client for Haskell.  https://hackage.haskell.org/package/bugsnag-hs-0.1.0.0 (JasperWoudenberg)
08:06:51 <geekosaur> iirc that happens with a sufficiently recent ghc, which tightened some rules on newtypes
09:05:35 <sim590> I'm trying to use System.Process.withCreateProcess like so https://paste.debian.net/1123052/. I'm simply calling the function, putting stuff on stdout and trying to pipe string "toto" to the command "cat" which should then output "toto" on stdout, but I don't see "toto". Am I doing something wrong ?
09:19:11 <merijn> sim590: Buffering mode
09:19:24 <merijn> pipes between processes default to block buffered (usually 4kb or so)
09:19:37 <merijn> So cat doesn't see the string until way later
09:20:58 <geekosaur> except the handle should be closed after the hPutStrLn, shouldn't it?
09:21:04 <geekosaur> unless there's more to it not shown
09:23:24 * hackage haskeline 0.8.0.0 - A command-line interface for user input, written in Haskell.  https://hackage.haskell.org/package/haskeline-0.8.0.0 (JudahJacobson)
09:34:19 <monochrom> Does withCreateProcess kill the process?
09:34:52 <geekosaur> yes
09:35:03 <monochrom> Curiosity kills the cat :)
09:35:16 <geekosaur> hm. hopefully giving it a chance t finish, since ideally you close the pipe to its stdin and it finishes and exits
09:35:20 <geekosaur> that could be an issue
09:36:47 <monochrom> It's up to the OS to give cat a chance to run or not.  I bet not.
09:38:17 * geekosaur adds withCreateProcess to the list of best-practice-what's-that ecosystem functions
09:39:31 <nil> monochrom: i'm confused, why would it be up to the OS?
09:40:07 <nil> does withCreateProcess kill the process immediately after creating it?
09:40:10 <geekosaur> whether the OS decides to schedule the subprocess to run before scheduling the parent to run (and kill the subprocess)
09:40:15 <nil> that seems a bit silly
09:40:19 <geekosaur> immediately after the write, in this case.
09:40:36 <geekosaur> no guarantee of a task switch to allow the process to read and write the data
09:41:00 <monochrom> No, immediately after the hPutStrLn. (In general, immediately after whatever code you give to withCreateProcess.)
09:41:04 <geekosaur> flip side, also no guarantee either process gets scheduled until after some other process has run
09:41:08 <nil> so what's the intended use of withCreateProcess?
09:41:17 <monochrom> It's a "bracket create kill your_code"
09:41:18 <nil> somehow wait for the process to do its job?
09:41:25 <solonarv> yes!
09:41:40 <solonarv> I'm pretty sure you are supposed to wait for it to finish
09:41:41 <monochrom> You have heard of the halting problem no? Wait how long? What wait?
09:42:02 <solonarv> waitForProcess is a function in proces
09:42:07 <monochrom> The intended use is you write code to wait.
09:42:27 <nil> ok
09:43:00 <sim590> According to the documentation, withCreateProcess "does automatic cleanup when the action finishes." Should it not be sufficient?
09:43:00 <monochrom> For example you pipe both stdin and stdout, you wait for answers from stdout.
09:43:29 <solonarv> so the fix is: withCreateProcess (blah) \(Just stdin, _, _, p) -> do hPutStrLn "hihi" stdin; waitForProcess p
09:43:39 <geekosaur> sim590, define cleanup
09:43:50 <solonarv> sim590: the problem is that the action finishes immediately, and "cleanup" includes "kill the process"
09:44:02 <solonarv> anyway, gotta go
09:44:08 <sim590> but it says "when the action finishes" Therefore, it should wait, no?
09:44:42 <nil> the action being whatever you pass to withCreateProcess, not the process you spawn
09:45:19 <geekosaur> do remember nobody knows what asynchronous multitasking means. "of course" when you do the write, everything stops so the process can read and deal with it…
09:46:55 <sim590> Alright. Now I put waitForProcess, but it never finishes. Therefore, I guess I need to put some endoffile character in the pipe.
09:47:05 <geekosaur> there is no end of file character
09:47:22 <sim590> In python, I remember that I do "flush" I think.
09:47:39 <nil> you should close the pipe, yes
09:47:42 <sim590> Which I thought would send the eof.
09:47:57 <sim590> But I thought that withCreateProcess would close the file.
09:48:20 <geekosaur> if you are doing the aitForProcess yourself then you must also close the pipe yourself
09:48:32 <geekosaur> otherwise you are waiting on the process which is waiting for more input
09:48:54 <sim590> Then I should not use waitForProcess and we come back to what I had before.
09:49:35 <geekosaur> if you are using waitForProcess then you are doing part of the cleanup yourself, yes, so you need to do more of it yourself and must question using withCreateProcess
09:49:44 <geekosaur> the correct answer is, it's not intended for this use case
09:50:40 <sim590> What use case is it intended for? I mean, I don't see how this is not the most intuitive use case.
09:51:07 <sim590> I thought withCreateProcess was pretty much like "with" in python.
09:51:47 <geekosaur> except "with" doesn;t explicitly kill the process, it expects the process to finish by itself probably when its stdin closes
09:52:45 <geekosaur> if it does kill it, it probably follows POSIX recommendations (close-wait-TERM-wait-KILL)
09:52:57 <sim590> withCreateProcess doesn't kill the process except if there's an "exception in the body", so it should be fine, no?
09:53:27 <nil> it does kill the process, as part of the "cleanup"
09:54:17 <geekosaur> it says bracket-style, which implies the leanup is run on normal termination as well
09:57:09 <sim590> I think that the issue is that cat never reads my block of data. I have to make him read it. Although, I thought that closing the pipes would have done it.
09:58:40 <nil> sim590: what code are you running?
09:59:08 <geekosaur> https://paste.debian.net/1123052/
09:59:36 <sim590> nil: more precisely, this: https://paste.debian.net/1123055/, but it has no effect on the pipe.
10:01:30 <geekosaur> cleanup runs right after the do returns, and kills the cat before it can run
10:01:32 <monochrom> My use case would be I pipe both stdin and stdout, I wait for stdout to EOF.
10:01:45 <geekosaur> ooh, open3 fun?
10:01:46 <nil> you're not waiting on the process there
10:02:23 <monochrom> You need to close hin yourself if you plan to waitForProcess
10:02:59 <monochrom> withCreateProcess kills the cat. waitForProcess brings it back. :D
10:04:32 <sm[m]> At this point might I venture to suggest using typed-process ?
10:05:09 <sim590> I changed for this https://paste.debian.net/1123058/ but now it just blocks.
10:05:13 <sim590> Never terminates.
10:05:36 <nil> close the pipe
10:05:42 <monochrom> It is funny how non-programmers are doubtful about computers being smart but programmers (of all people) simply assume that computers can just DWIM automatically.
10:06:16 <sim590> nil: with "cleanupProcess" ? But it says, it will kill it.
10:06:21 <nil> no
10:06:26 <nil> hClose hin
10:06:35 <sim590> Oh.
10:06:42 <sim590> OK, I get it.
10:07:45 <maerwald> meh, streamly only works with Handles, not file descriptors
10:07:45 <sim590> alright. I got it. hClose was what I was missing.
10:08:27 <sim590> Yay. Now my emoji is copied to my clipboard: ʘ‿ʘ.
10:08:38 * sm[m] notices that haskell packages look pretty good on google now (Featured Snippets): https://www.google.com/search?q=typed-process&ie=utf-8&oe=utf-8
10:10:02 <sim590> I made a program to select an emoji... https://i.imgur.com/g6WkXr5.png. Who said haskell was useless?
10:10:59 <sm[m]> NOBODY
10:12:17 <nil> those aren't emoji
10:12:30 <sm[m]> uncouth persons of no consequence
10:13:45 * sim590 ᵒᴥᵒ#
10:14:34 <sim590> nil is like: (╯°□°）╯︵ ┻━┻
10:14:50 <nil> more like ¯\_(ツ)_/¯
10:14:56 <sim590> :D
10:15:21 <heatsink> just use words ಠ_ಠ
10:16:38 * sim590 spent 12 hours on this and likes to use it now  ᕦ(ò_óˇ)ᕤ
10:16:38 <monochrom> Just don't press enter.
10:55:49 <d34df00d> Hi!
10:56:35 <fenedor> I forgot again, how do I get the *most* concrete type of the exception  I just caught?
11:07:45 <d34df00d> Let's say I want to have something `data Foo = Foo { produceSomething :: Maybe Obj, consumeSomething :: Obj -> Blah }`, where `Obj` is an opaque type that can be different for different values of type `Foo`.
11:07:58 <d34df00d> My best bet is to do some type classes with type families and existentials, or can I do better?
11:08:30 <merijn> Or, just...parameterise Foo over Obj?
11:09:47 <koz_> Yeah, like 'data Foo a = Foo { unFoo :: Maybe a }'
11:10:11 <koz_> (well, and the rest)
11:10:31 <d34df00d> But that means I'll have `data SomeFoo where MkSomeFoo :: Foo a -> SomeFoo` eventually.
11:10:49 <merijn> Why?
11:11:27 <lyxia> fenedor: catch the exceptions you want to catch (so you know what their types are in the first place)
11:12:10 <fenedor> I dont wanna dug through the library code to find out the exact exception >_>
11:12:26 <rotaerk> data Foo a = Foo { produce :: Maybe a, consume :: a -> Blah };  data SomeFoo = forall a. SomeFoo (Foo a);  blah :: [SomeFoo]
11:12:33 <d34df00d> Let's say I'm writing a program that, say, works with some tools that have configurations. Tool A stores config in YAML, tool B stores config in XML, etc. So I want to represent a tool via this Foo structure, and Obj corresponds to the specific config format a given tool works with.
11:13:15 <monochrom> fenedor: My http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml#supertyping can help you discover the exception type.
11:13:20 <d34df00d> merijn: that means that `a` is fixed when I _define_ a given object of the tool and methods for working with it. And then I'd like to work with those tools uniformly, so I'll need to erase `a` to, say, store them in a list.
11:14:11 <merijn> d34df00d: Why does Obj need to be stored as part of the tool, can't you just partially apply the specific config type upon creation?
11:14:37 <d34df00d> merijn: what would be the type of the list of different tools?
11:15:03 <merijn> d34df00d: No, my question is: Why does the Obj type need to be part of the tool record
11:15:24 <d34df00d> Because it's specific to the tool, and it's only need to match the type of produceSomething with the type of consumeSomething.
11:15:31 <fenedor> monochrom, thanks, nice tutorial, I will save that somewhere! Exactly what I need
11:15:34 <d34df00d> Ideally it should be hidden as much as possible.
11:15:50 <d34df00d> (in reality there will be more associated types, and I don't want to parametrize Foo with all of them)
11:16:09 <merijn> d34df00d: Wait, produceSomething and consumeSomething correspond to the same type?
11:16:20 <merijn> d34df00d: And you only ever wanna use those two together
11:16:31 <d34df00d> merijn: sort of.
11:17:11 <merijn> Then you can just use an existential?
11:17:13 <d34df00d> But there's some external processing that's not specific to any given tool, so I'd like to separate producing Obj, handling errors and what not, and then passing the Obj to consumeSomething.
11:17:27 <d34df00d> Hmm.
11:17:33 <d34df00d> Damn.
11:17:34 <d34df00d> Right.
11:17:49 <d34df00d> Why did I need all this typeclasses nonsense in the first place when I can just make my Foo an existential.
11:17:57 <d34df00d> merijn: thanks.
11:18:16 <merijn> The day is saved from overcomplicated typeclasses and typefamilies once again! \o/
11:18:56 <monochrom> No, I think it will be tragedically using all of existential, class, family in conjunction.
11:20:45 <monochrom> But "exists a. (a, a -> B)" is better than "((exists a. a), (exists a. a) -> B)" because the former has the two "a"s in sync.
11:21:02 <c_wraith> ie, the former is actually usable
11:21:22 <c_wraith> Though it's not much different from just B, in practice.
11:21:33 <monochrom> This is why programmers, of all people, need the most to learn predicate logic.
11:22:07 <c_wraith> You need to get up to somewhere around Coyoneda for the existential to really do something useful.
11:23:58 <c_wraith> data Coyoneda f a where Coyoneda :: forall b. (b -> a) -> (f b) -> Coyoneda f a
11:24:48 <c_wraith> Now you have captured the essence of fmap.  Even for types that aren't instances of Functor.  (Though doing something useful might be trickier if it's not)
11:26:05 <c_wraith> (Coyoneda IORef makes some sense.  Coyoneda Predicate doesn't)
11:35:02 * ksqsf action
11:35:35 <fog> can anyone talk me through whats happening in this paste? https://pastebin.com/raw/yyfJ38Ja
11:38:14 <fog> I get whats happening with the To, it takes 4 params, the fist two being the kinds of the inputs and outputs
11:38:35 <fog> input and output, the 3rd arg and the kind of the fully applied type family
11:38:59 <fog> and thats being used to cast between containers and their h and f varients
11:39:18 <fog> but then what about FMap at the end (more like HMap) ?
11:41:01 <fog> i guess if it were better it would have F_Containers constrained to be with corresponding FMap instances
11:41:23 <fog> but its all done with open type families instead of classes, which dont work well at type level
11:41:56 <fog> I like how the To class seems to be polymorphic in its kind
11:42:14 <fog> and that by having an extra 2 params for the kinds, its almost like having a "kind constraint"
11:42:43 <fog> ie, the instance is for particular kinds in the normal input and output pair (of To)
11:43:30 <fog> and that this type having polymorphic kinds, constrained to have an instance of that type family - is almost like a class at type level
11:55:21 * i\o action
11:55:37 <monochrom> :)
12:03:32 <solonarv> monochrom: why a backslash instead of a forward slash, though?
12:06:15 <nil> i don't think IRC allows /
12:06:22 <d34df00d> Hmm.
12:06:30 <d34df00d> merijn: that didn't work as nicely.
12:07:24 <d34df00d> So I have this existential:
12:07:40 <d34df00d> https://bpaste.net/Z52A
12:08:41 <d34df00d> And I'm trying to use it as: https://bpaste.net/G33A
12:09:03 <d34df00d> And I'm getting: https://bpaste.net/4WQQ
12:09:11 <d34df00d> So how do I avoid typeclasses and existentials over them and all that?
12:12:48 <c_wraith> need a lot more context on the second one - at least give a full do block around it with a type
12:18:36 <c_wraith> the two lines you quoted look fine
12:20:37 <fragamus> what is the idiomatic way to take a list  and repeat each element N times in the output list
12:20:53 <c_wraith> concatMap and replicate
12:21:03 <ksqsf> concatMap (replicate N)
12:22:11 <fragamus> okie thanks
12:22:45 <merijn> Does replicateM work?
12:22:52 <merijn> > replicateM 2 [1..5]
12:22:54 <lambdabot>  [[1,1],[1,2],[1,3],[1,4],[1,5],[2,1],[2,2],[2,3],[2,4],[2,5],[3,1],[3,2],[3,...
12:23:03 <merijn> ah, not quite, I guess
12:23:09 <c_wraith> if you want every combination...
12:31:52 <d34df00d> Oh... I'm probably an idiot... This error is from a related code, but a few lines away, that hasn't been refactored yet.
12:32:09 <d34df00d> c_wraith: so disregard that, sorry, it is indeed fine.
12:32:19 <c_wraith> :P
12:42:19 <ephemient> concatMap on [] is also >>=, so
12:42:27 <ephemient> > [1..5] >>= replicate 2
12:42:28 <lambdabot>  [1,1,2,2,3,3,4,4,5,5]
12:43:52 <erisco> So of course we must go to the ultimate conclusion and say  (. replicate) . (>>=)
12:44:20 <ksqsf> clever
12:44:26 <ksqsf> much harder to understand though
12:44:47 <ChaiTRex> You don't have @unpl built in to your head?
12:45:19 <solonarv> :t (=<<) . replicate
12:45:21 <lambdabot> Int -> [b] -> [b]
12:45:29 <solonarv> much better! almost reasonable, even
12:45:41 <solonarv> :t concatMap . replicate
12:45:43 <lambdabot> Foldable t => Int -> t b -> [b]
12:45:45 <erisco> I was going by the original argument order
12:47:18 <solonarv> < ChaiTRex-> You don't have @unpl built in to your head? -- no, but I have @pl built into my head!
12:48:24 * hackage apply-refact 0.7.0.0 - Perform refactorings specified by the refact library.  https://hackage.haskell.org/package/apply-refact-0.7.0.0 (mpickering)
12:52:34 <erisco> > (getZipList . sequence . ZipList . map ZipList . replicate 3) "hello sailor!"
12:52:37 <lambdabot>  error:
12:52:37 <lambdabot>      • No instance for (Monad ZipList) arising from a use of ‘sequence’
12:52:37 <lambdabot>      • In the first argument of ‘(.)’, namely ‘sequence’
12:52:47 <erisco> Oh
12:53:00 <erisco> > (getZipList . sequenceA . ZipList . map ZipList . replicate 3) "hello sailor!"
12:53:02 <lambdabot>  [ZipList {getZipList = "hhh"},ZipList {getZipList = "eee"},ZipList {getZipLi...
12:53:13 <erisco> Someone can lens that up
13:10:24 * hackage lawz 0.0.1 - Common mathematical laws.  https://hackage.haskell.org/package/lawz-0.0.1 (cmk)
13:32:24 * hackage connections 0.0.2.2 - Partial orders, lattices, & Galois connections.  https://hackage.haskell.org/package/connections-0.0.2.2 (cmk)
13:41:01 <davve> does hackage announce new packages or what?
13:41:24 * hackage rings 0.0.2.2 - Groups, rings, semirings, and dioids.  https://hackage.haskell.org/package/rings-0.0.2.2 (cmk)
13:42:50 <phadej> davve: there is a rss feed https://hackage.haskell.org/recent.rss
13:43:11 <davve> ah
13:46:54 * hackage rings 0.0.2.3 - Groups, rings, semirings, and dioids.  https://hackage.haskell.org/package/rings-0.0.2.3 (cmk)
13:49:24 * hackage rings 0.0.2.4 - Groups, rings, semirings, and dioids.  https://hackage.haskell.org/package/rings-0.0.2.4 (cmk)
14:05:54 * hackage PyF 0.9.0.0 - Quasiquotations for a python like interpolated string formater  https://hackage.haskell.org/package/PyF-0.9.0.0 (guibou)
14:49:53 <d34df00d> I think I want something strange, but let's say I have a function that takes a ton of arguments.
14:50:39 <d34df00d> That might be considered unreadable, so one might like to pass a record with the arguments instead.
14:50:54 <d34df00d> But I'm sort of lazy to make a record just for the sake of it, polluting the global scope with the selectors of that record.
14:51:44 <d34df00d> Can I do something like an ad-hoc-definition of a "named tuple" of sorts, probably with all the KnownSymbols and type literals and what not to get the same level fo type safety without an explicit record definition?
14:51:53 <d34df00d> Or smth like a dependent map, dunno.
14:52:01 <solonarv> yes, there are a handful of libraries like that in fact
14:52:32 <d34df00d> solonarv: are there any good recommendations?
14:53:54 * hackage distributed-closure 0.4.2.0 - Serializable closures for distributed programming.  https://hackage.haskell.org/package/distributed-closure-0.4.2.0 (MathieuBoespflug)
14:54:01 <solonarv> I usually reach for vinyl, it is a bit fiddly and up there type-wise but has no dependencies
14:54:17 <EvanR> d34df00d: you can put the record in it's own module and don't export selectors
14:54:20 <solonarv> other than the occasional large type error I haven't had issues with it, but I am fairly comfortable with type voodoo
14:54:33 <phadej> just pollute the global namespace
14:54:36 <solonarv> EvanR: if you don't export selectors, you can't construct it easily
14:54:44 <d34df00d> EvanR: in fact I have several functions with overlapping selector names, and it gets messy.
14:54:56 <phadej> import qualified
14:55:04 <d34df00d> They're in the same module semantically.
14:55:07 <EvanR> get down on your knees and pray for the "NoSelectors" (?) extension to come out
14:55:14 <solonarv> of course you can just do 'MyRecord field1 field2 ...', but that's hardly any better than just calling the function without going through a record!
14:55:36 <EvanR> i am suspicious about "a ton of arguments" too
14:55:39 <d34df00d> solonarv: type voodoo is nice, I'm always up for some type voodoo.
14:55:48 <d34df00d> EvanR: 2-3-4.
14:55:53 <EvanR> are many of these arguments Maybes? would seem like an API issue
14:55:55 <solonarv> that's not that many, really
14:56:06 <EvanR> 4? that's it?
14:56:08 <solonarv> 4 args is just on the upper end
14:56:14 <solonarv> I was imagining like 6+
14:56:19 <EvanR> i was imagining 100
14:56:22 <d34df00d> EvanR: but they have fairly generic types like T.Text, and I don't think wrapping that in newtypes is a good idea (I'm rather looking towards benefits in readability than safety in this case).
14:56:31 <d34df00d> EvanR: nah, none of those are maybes.
14:56:39 <EvanR> so you want keyword args
14:56:44 <d34df00d> Sorta.
14:56:52 <EvanR> me too i think
14:57:07 <EvanR> a record does seem overkill for this
14:57:16 <d34df00d> I start feeling uncomfortable having fields like
14:57:18 <d34df00d> formatFile :: T.Text -> [ConfigItemT 'Value] -> FilePath -> CmdArgs
14:57:29 <EvanR> at least the args all have different types
14:57:40 <d34df00d> or styleOpts :: T.Text -> [ConfigItemT 'Supported] -> [ConfigItemT 'Value] -> OptsSource [ConfigItemT 'Value]
14:58:02 <phadej> looks normal
14:58:11 <phadej> 3 is not ton
14:59:00 <d34df00d> Well ok.
14:59:04 <d34df00d> No type voodoo for me.
14:59:15 <solonarv> you can use haddocks to say what they mean at the definition, and at use sites sensible variable names should clarify things
15:04:02 <d34df00d> That works too.
15:04:25 <d34df00d> It's just my rule of thumb that the less comments and more compiler-enforced stuff the better. But that's probably not worth it in this case.
15:08:09 <solonarv> with enough extensions, vinyl would let you write styleOpts :: FieldRec '["blah" ::: T.Text, "supported" ::: [ConfigItemT Supported], ...] -> ...
15:08:55 <solonarv> and call it with styleOpts $ record (#blah =: "hello world", #supported =: foos, ...)
15:09:09 <solonarv> but again, for three arguments that's overkill
15:09:42 <d34df00d> But that looks really awesome!
15:09:45 <d34df00d> Library noted, thanks!
15:10:49 <d34df00d> Interesting, the more refactoring, abstraction and decoupling I throw at my code, the faster it runs (although the difference is marginal, but notable).
15:15:16 <NotGate> Haskell noob here`flip` is interesting to me because it seems like a specific case of treating a function signature like a data structureEx: `a->b->c->d` into `b->a->c->d` feels like one of many operations you could potentially perform on the list or tree that represents the signature of the functionIs there a more general way to think about
15:15:16 <NotGate> functions like `flip` and how you can use them to transform the signature of complex functions?
15:15:37 <NotGate> oh my formatting got messed up. sorry
15:15:52 <ChaiTRex> NotGate: You can rearrange the arguments however you want.
15:16:14 <ChaiTRex> @pl \ a b c d -> f d b a c
15:16:14 <lambdabot> (flip .) . flip (flip . flip f)
15:17:08 <ChaiTRex> NotGate: It's not that pretty, though.
15:17:58 <ChaiTRex> @pl \ f a b c d -> f d b a c
15:17:59 <lambdabot> ((flip .) .) . flip . (flip .) . flip
15:18:10 <ChaiTRex> That's a bit more like what you had with flip.
15:22:07 <NotGate> Alright thank you :)  Gonna mess around with this for a bit
15:22:24 * hackage profunctor-optics 0.0.0.5 - An optics library compatible with the typeclasses in 'profunctors'.  https://hackage.haskell.org/package/profunctor-optics-0.0.0.5 (cmk)
15:48:58 <jackdk> NotGate: A useful/similar perspective: add the implicit brackets to function signatures and see if it changes your perspective. e.g. `map :: (a -> b) -> [a] -> [b]` is the same as `map :: (a -> b) -> ([a] -> [b])`
15:49:33 <jackdk> but the second one highlights an alternate perspective: map lifts a function on elements into a function on lists
16:28:24 * hackage cborg 0.2.2.1 - Concise Binary Object Representation (CBOR)  https://hackage.haskell.org/package/cborg-0.2.2.1 (BenGamari)
16:37:54 * hackage cborg-json 0.2.2.0 - A library for encoding JSON as CBOR  https://hackage.haskell.org/package/cborg-json-0.2.2.0 (BenGamari)
16:38:54 * hackage serialise 0.2.2.0, cbor-tool 0.2.2.0 (BenGamari): https://qbin.io/bc-lazy-jxmj
16:51:54 * hackage coformat 0.3.0.0 - Generate clang-format config based on some existing code base  https://hackage.haskell.org/package/coformat-0.3.0.0 (0xd34df00d)
17:10:23 <jusss> f _ = return 5
17:10:42 <jusss> runCont f id == 5
17:10:49 <iqubic> Correct.
17:10:57 <jusss> runCont (callCC f) id
17:11:09 <iqubic> Also 5.
17:11:09 <jusss> runCont (f 3) id 
17:11:15 <iqubic> Also 5.
17:11:50 <jusss> what _ :: ?
17:11:55 <jusss> here
17:12:36 <jusss> _ :: a->m b?
17:12:36 <iqubic> _ :: a. It can take a value of any type at all.
17:12:47 <jusss> f :: (a->m b)->m a
17:12:51 <jusss> return 5 :: ma
17:12:56 <jusss> so _ :: a->m b?
17:13:13 <jusss> callCC :: (a->m b) -> m a-> m a
17:13:20 <iqubic> That is correct.
17:13:31 <iqubic> _ :: a -> m b
17:13:55 <jusss> that m a should get a from a-> m b?
17:14:08 <jusss> if it's not, what's the point of a->m b?
17:14:35 <iqubic> jusss: I think this would be easier for you to understand if you tried working through the examples in ghci.
17:14:47 <jusss> iqubic: I am, now
17:16:54 <jusss> a more generic definition with function, callCC f cc = f (\x _ -> cc x) cc
17:17:18 <jusss> callCC :: (a-> m b)->m a->m a
17:17:21 <iqubic> Alright. Looks reasonable.
17:17:28 <jusss> f::(a->m b)->m a
17:17:31 <jusss> cc::m a
17:18:01 <iqubic> Well, actually callCC :: ((a-> m b)->m a)->m a
17:18:14 <jusss> iqubic: yeah, 
17:18:32 <iqubic> But other than that, it's right.
17:18:34 <jusss> m a ~ (a->r)->r
17:18:58 <iqubic> Sure.
17:19:09 <ephemient> callCC :: ((a -> m ()) -> m a) -> m a would probably be usable too
17:19:32 <iqubic> Why?
17:19:49 <ephemient> can always sequence some junk after the exit, it doesn't matter
17:20:19 <ephemient> but m b is easier to fit into wherever, so why not
17:20:26 <shachaf> ((a -> m Void) -> m a) -> m a would be a good type. It doesn't matter.
17:20:44 <shachaf> () is too specific to be useful.
17:20:59 <ephemient> that would be a more meaningful type, yes
17:21:30 <shachaf> Another reasonable type would be ((a -> m Void) -> m Void) -> m Void, though it wouldn't really be callCC at that point.
17:21:35 <jusss> in that case x :: a?
17:21:39 <shachaf> Uh, ((a -> m Void) -> m Void) -> m a
17:21:40 <ephemient> although forall b. b when it clearly can't produce a 'b' has about the same meaning
17:21:59 <jusss> callCC f cc = f (\x _ -> cc x) cc
17:23:06 <jusss> no
17:23:26 <jusss> callCC f = \cc -> f (\x _ -> cc x) cc
17:23:41 <jusss> cc :: (a->r)->r
17:23:49 <ephemient> same thing, btw
17:24:06 <jusss> callCC f cc :: would be no type
17:24:21 <jusss> (+1) 2 3 :: ?
17:24:26 <jusss> (+1) 2 = 3
17:24:45 <iqubic> (+1) 2 3 :: (Num a) => a
17:24:55 <jusss> aha
17:25:01 <iqubic> callCC f cc :: m a
17:25:47 <jusss> f :: (a->m b)->m a
17:25:52 <jusss> (\x _ - cc x) :: ?
17:27:14 <jusss> the a->m b thing in f, I really don't understand
17:27:22 <jusss> what it is, how it's like
17:27:28 <ephemient> (+ 1) 2 3 :: (Num (a -> b), Num a) => b
17:28:07 <jusss> some people say ((a->m b)->m a)->m a is like that Peirce's law which I don't know yet
17:28:40 <shachaf> Are you the same person as wonderC?
17:28:47 <jusss> if we can already defined m a in f, why bother to give it a (a->m b), that's meaningless
17:28:52 <shachaf> Why are people so focused on learning this one thing?
17:28:52 <jusss> shachaf: yes
17:29:10 <shachaf> My recommendation: Forget about callCC and Cont, learn more Haskell first.
17:29:33 <shachaf> The questions you're asking aren't really Cont-specific, they're questions about figuring your way around Haskell types out.
17:29:45 <shachaf> And Cont isn't a good way to do that because it's kind of complicated.
17:30:02 <iqubic> I'm quite good at haskell, and Cont still confuses me so much.
17:30:05 <shachaf> It's also not that important.
17:30:28 <MarcelineVQ> also there's http://www.vex.net/~trebla/haskell/cont.xhtml which I'm sure has been linked already in the previous conversations
17:31:06 <iqubic> The best way to understand Cont is to learn how to use it, and kinda accept that it is black magic.
17:31:18 <mniip> cont as an effect isn't really that complicated
17:31:28 <jusss> I have already saw two articles about Cont and ContT, https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/the-mother-of-all-monads, http://www.haskellforall.com/2012/12/the-continuation-monad.html
17:31:44 <mniip> at every line in a do block you have access to all the code that's put afterwards
17:31:46 <jusss> and how to use >>= to chain Cont
17:31:58 <ephemient> it's not really all that magical
17:32:14 <ephemient> how you want to use it dictates the types, and the types dictate how it's assembled, more or less
17:32:18 <jusss> but this callCC, is really I don't understand
17:32:20 <shachaf> No, the best way to understand Cont is to actually understand it.
17:32:33 <mniip> callCC is *the* cont's effect
17:32:57 <mniip> you take the "current continuation" and give it to a function
17:33:13 <jusss> that Promise stuff in Javascript, is really like Cont in Haskell
17:33:29 <ephemient> not really?
17:33:41 <mniip> no
17:33:53 <jusss> Promise.then().then()...  Cont r a >>= a -> (Cont r b) ...
17:33:53 <mniip> promises are monads, cont is a monad
17:34:11 <mniip> you're confused about which is the more general concept
17:34:22 <iqubic> I don't understand promises.
17:34:43 <jusss> Promise is non strict monad, it doesn't obey the laws of monad
17:35:05 <mniip> iqubic, they're not that different from IO in the sense that you're telling it (at evaluation time) what to do later (at execution time) via a monadic interface
17:35:09 <ephemient> Javascript Promise is not a Monad, but that's a mistake
17:35:31 <iqubic> ephemient: JS doesn't have Monads, and that's the real mistake.
17:35:38 <mniip> ephemient, oh? how so
17:36:17 <solonarv> it doesn't actually have bind
17:36:21 <solonarv> for really really dumb reasons
17:36:24 <iqubic> No??
17:36:33 <solonarv> well, you can probably hack one together
17:37:25 <solonarv> but if you look at the issue where this was discussed (don't have a link, sorry) you see some Haskell-famous person arguing that really, this should be a monad for obvious reasons (which he explained)
17:38:03 <mniip> well last time I wrote javascript it didn't have promises so I can't say about that
17:38:03 <solonarv> and a bunch of people going "no, that's a mathematical concept, JS is a practical language and we don't want any of that icky stuff"
17:38:14 <mniip> but in general promises as a programming paradigm are just a yet another monad
17:39:05 <shachaf> Who cares whether it's a monad? JavaScript doesn't let you abstract over monads anyway, so you should just use the thing that works for your situation.
17:39:23 <jusss> shachaf: yeah, it can
17:39:24 <mniip> to be fair you don't need to abstract over monads to use them
17:39:26 <shachaf> "it's a mathematical concept" isn't a good argument for making something have a particular API.
17:39:39 <shachaf> Make the actual argument if you want.
17:39:48 <solonarv> yes, and the argument was made
17:39:48 <ephemient> https://buzzdecafe.github.io/2018/04/10/no-promises-are-not-monads
17:39:54 <mniip> I understand that haskell has the tools to do so and is hence attractive but other languages exist too and you can write code in them too
17:39:58 <ephemient> how much it matters... *shrug*
17:40:13 <solonarv> but I lost the link to the discussion and can't faithfuly reproduce it from memory
17:40:15 <ephemient> it's challenging to work with promises returning promises
17:40:17 <jusss> const pure = x => cb => cb(x)
17:40:21 <jusss> const bind = amb => ma => cb => ma(a => amb(a)(cb))
17:40:59 <ephemient> it's *almost* true, but not quite
17:41:04 <shachaf> Yes, I know you can write Cont in JavaScript.
17:41:17 <jusss> that's not my code...
17:41:26 <mniip> ephemient, just wrap them in a dummy datatype idk
17:41:59 <mniip> regardless
17:42:14 <mniip> jusss, promises are not CPS
17:42:30 <shachaf> I made this argument once (for some reason I used CoffeeScript???): https://slbkbs.org/toys/callfront.txt
17:42:50 <solonarv> coffeescript? I haven't heard that name in years...
17:42:54 <mniip> the exact issue you're having is that they both have a monadic interface: return and bind
17:42:59 <mniip> because they *are* both monads
17:43:14 <mniip> but not all monads are Cont and hence not all monads have a callCC effect
17:43:27 <shachaf> Anyway JavaScript is neither here nor there.
17:43:30 <jusss> mniip: MonadCont
17:43:46 <mniip> I wouldn't expect promises to be a MonadCont
17:46:05 <jusss> it's so different that callCC in Haskell and call/cc in Scheme...
17:46:30 <mniip> no?
17:46:34 <mniip> they're essentially the same thing
17:46:35 <shachaf> They are the same thing.
17:46:52 <jusss> call/cc is primitive implemented in Scheme
17:47:01 <mniip> so?
17:47:22 <mniip> behaviorally they're the same
17:47:24 <mniip> and haskell is famous for not having too many things implemented primitively
17:47:40 <jusss> you tell me how I can capture all the code after callCC with callCC f = \c -> f (\x -> \_ -> c x) c?
17:48:36 <shachaf> That's the (\x -> \_ -> c x)
17:49:11 <jusss> (call/cc (lambda (k) ...) (a ...) (b...) that all the lines after (call/cc ...) would be captured and store into k
17:49:34 <ephemient> oh is Scheme one of the ones with undelimited continuations?
17:49:58 <shachaf> They're doing the same thing.
17:50:09 <jusss> call/cc for full-continuation, shift/reset for delimited continuation
17:50:53 <jusss> you mean that (a...) (b...) is (\x -> \_ -> c x) ?
17:50:57 <shachaf> > (`runCont` id) $ do { x <- callCC (\k -> k 5); return (x + 1) }
17:50:59 <lambdabot>  6
17:51:24 <shachaf> k is the function: (\v -> do { x <- return v; return (x + 1) }
17:51:31 <shachaf> It's capturing the continuation.
17:52:21 <iqubic> That's a good way of putting it
17:53:14 <jusss> shachaf: what id here is?
17:53:38 <ChaiTRex> @src id
17:53:38 <lambdabot> id x = x
17:53:40 <ephemient> Haskell's Cont is really a delimited continuation
17:54:25 <jusss> ephemient: Haskell's callCC capture delimited continuations? 
17:54:50 <jusss> but there is shift/reset in Haskell
17:54:57 <ephemient> well the interface is different than Scheme's
17:56:03 <jusss> shachaf: can we return k in (`runCont` id) $ do { x <- callCC (\k -> k 5); return (x + 1) }
17:56:14 <iqubic> Not easily.
17:56:17 <ephemient> callCC $ \exit -> do ... exit x ...   ~~   (reset (... (shift x) ...))
17:56:45 <iqubic> ephemient: if that's true, the why do shift/reset exist?
17:56:55 <mniip> iqubic, abstraction
17:57:05 <iqubic> I see.
17:57:24 <iqubic> And the cool thing is, callCC can just ignore its function.
17:57:36 <iqubic> callCC $ const 5
17:57:51 <shachaf> You have no idea about any of this, do you?
17:58:03 <mniip> I've written this really cool function before
17:58:07 <mniip> @let puncture = (`runCont` \xs -> fmap (second ($ fmap fst xs)) xs) . traverse (\x -> callCC (\k -> pure (x, \xs y -> fmap fst $ (`runCont` id) $ k (y, \_ _ -> xs))))
17:58:09 <lambdabot>  Defined.
17:58:09 <mniip> :t puncture
17:58:11 <lambdabot> Traversable f => f b -> f (b, b -> f b)
17:59:12 <iqubic> "callCC $ const 5" just short circuits the entire computation that it's inside of and returns 5. It just throws out all the work that was done, and sets the result to 5.
17:59:24 <jusss> shachaf: elaborate please
17:59:27 <mniip> > snd (puncture [0, 1, 2] !! 1) 10
17:59:29 <lambdabot>  [0,10,2]
17:59:35 <ephemient> callCC $ const $ return 5 you mean
17:59:47 <mniip> hmmm
18:00:12 <iqubic> ephemient: Yes.
18:00:17 <mniip> (b, b -> f b) = Store b (f b)
18:00:27 <monochrom> @type callCC (const 5)
18:00:31 <lambdabot> (MonadCont m, Num (m a)) => m a
18:00:39 <iqubic> mniip: That looks a lot like a lens.
18:00:53 <mniip> in some way yes
18:00:56 <iqubic> > fst (puncture [0, 1, 2] !! 1) 10
18:00:59 <lambdabot>  error:
18:00:59 <lambdabot>      • Could not deduce (Num t0)
18:00:59 <lambdabot>        from the context: (Num t, Num (t -> t1))
18:01:06 <iqubic> What?!?!
18:01:31 <mniip> sadly lambdabot doesn't have comonads :(
18:01:31 <iqubic> :t callCC (const (return 5))
18:01:33 <lambdabot> (MonadCont m, Num a) => m a
18:01:51 <iqubic> What benefits do we get from using return there?
18:02:01 <monochrom> No, callCC (const (return 5)) throws away nothing.
18:02:10 <iqubic> It doesn't?
18:02:14 <iqubic> What does it do then?
18:02:32 <monochrom> You made a claim, you prove it.
18:02:43 <iqubic> I'm too lazy to do that.
18:02:47 <shachaf> Have you, y'know, tried it? Or tried thinking about it?
18:03:00 <monochrom> And not lazy enough to keep quiet in the first place?
18:03:05 <iqubic> Lol. I see.
18:03:40 <jusss> I tried, maybe not on the right dierection
18:04:17 <monochrom> Here is an experiment to prove my claim.  do { putStrLn "1"; callCC (do { putStrLn "2"; return 5 }); putStrLn "3" }
18:05:13 <monochrom> err change all putStrLn x to liftIO (putStrLn x) there.
18:05:33 <monochrom> (This needs to be ContT r IO a, and you also need a runContT)
18:06:00 <monochrom> And I have a type error.
18:06:10 <ephemient> you forgot the const :)
18:06:37 <monochrom> runContT ( do { liftIO (putStrLn "1"); callCC (\_ -> do { liftIO (putStrLn "2"); return 5 }); liftIO (putStrLn "3") } )
18:08:04 <monochrom> If you start writing like "callCC (\k -> ...)" and actually try to use the k there, that will have a chance of throwing something away.  But even then, not the past, not the work already done.
18:08:12 <ephemient> + return, to make runContT happy
18:08:48 <monochrom> Oh, yeah, runContT (...) return
18:08:58 <monochrom> This is why the name "runContT" is wrong.
18:09:14 <monochrom> It should be simply unContT.
18:13:28 <monochrom> shachaf: The problem with "thinking" is that people simply think they're right.
18:14:18 <shachaf> Yes, experiments are even better, when you can get away with them.
18:14:46 <monochrom> What people lack and need to learn is designing experiments that have at least 1 bit of information, i.e., at least 2 possible outcomes.
18:15:17 <srid> Someone here pointed out that I don't need a type class in my library; well, they turned out to be right! Type class got replaced by simple functions: https://github.com/srid/rib/pull/65
18:15:48 <monochrom> For example my experiment has 3 bits of information: 8 possible outcomes, each of the 3 putStrLn's may happen or not.
18:16:05 <MarcelineVQ> put another useful way, an experiment should be intended to prove your idea wrong, not to prove it right
18:16:44 <shachaf> If an experiment proves your idea right it's also good.
18:16:50 <MarcelineVQ> If you can't design such an experiment then you know you lack knowlege or your idea is more solid than otherwise
18:16:53 <ephemient> or it could _|_ at any point ;)
18:21:48 <MarcelineVQ> proof is good :> but if I make an experiment while intending to be right I'm more likely to fall to confirmation bias, iow to stop as soon as I get a good looking result.
18:22:38 <MarcelineVQ> *to stop refining the experiment as soon
18:22:42 <shachaf> People talking about falsifiability has always seemed kind of funny to me.
18:22:53 <shachaf> The negation of a falsifiable statement is a verifiable statement.
18:23:20 <shachaf> It's all good as long as your experiment provides useful information.
18:24:38 <jusss> I didn't think I'm right, I just asked something I don't understand
18:24:49 <ephemient> I wanted to try `runCont (callCC mfix) id` but it told me "No instance for MonadFix" :(
18:25:26 <monochrom> There is an urban legend theorem that says Cont cannot be a MonadFix.
18:27:15 <mniip> % puncture = (`runCont` \xs -> fmap (fmap ($ fmap pos xs)) xs) . traverse (\x -> callCC (\k -> pure $ store (\y xs -> fmap pos $ (`runCont` id) $ k $ store (\_ _ -> xs) y) x))
18:27:15 <yahb> mniip: 
18:27:25 <mniip> % peeks negate <$> puncture [1..5]
18:27:25 <yahb> mniip: [[-1,2,3,4,5],[1,-2,3,4,5],[1,2,-3,4,5],[1,2,3,-4,5],[1,2,3,4,-5]]
18:27:55 <mniip> % :t puncture
18:27:55 <yahb> mniip: Traversable f => f b -> f (StoreT b Identity (f b))
18:28:11 <mniip> reminds me a lot of lens's pretext machinery
18:28:35 <shachaf> Yes, doesn't lens have this thing?
18:28:43 <shachaf> :t holesOf
18:28:45 <lambdabot> Conjoined p => Over p (Bazaar p a a) s t a a -> s -> [Control.Lens.Internal.Context.Pretext p a a t]
18:28:55 <shachaf> Ridiculous type notwithstanding.
18:28:56 <mniip> % peeks negate <$> holesOf each [1..5]
18:28:56 <yahb> mniip: [[-1,2,3,4,5],[1,-2,3,4,5],[1,2,-3,4,5],[1,2,3,-4,5],[1,2,3,4,-5]]
18:30:07 <shachaf> Cont seems like overkill, anyway (as it almost always is).
18:30:40 <mniip> pretty sure it's necessary here
18:30:41 <Axman6> :t withFile
18:30:42 <lambdabot> error:
18:30:43 <lambdabot>     • Variable not in scope: withFile
18:30:43 <lambdabot>     • Perhaps you meant one of these:
18:31:12 <Axman6> @hoogle FilePath -> (Handle -> IO a) -> IO a
18:31:13 <lambdabot> Sound.Audacity.Project.Track.Wave.Summary withHandle :: FilePath -> (Handle -> IO a) -> IO a
18:31:13 <lambdabot> System.IO.SafeWrite withOutputFile :: (MonadMask m, MonadIO m) => FilePath -> (Handle -> m a) -> m a
18:31:13 <lambdabot> Clr.Marshal marshal :: Marshal a b => a -> (b -> IO c) -> IO c
18:31:16 <shachaf> holesOf isn't implemented with Cont, is it?
18:31:20 <mniip> % :t Pretext @(->)
18:31:20 <yahb> mniip: ; <interactive>:1:1: error:; * Cannot apply expression of type `t1'; to a visible type argument `(->)'; * In the expression: Pretext @(->)
18:31:27 <iqubic> Why are you using Peeks?
18:31:30 <mniip> % :t Pretext
18:31:30 <yahb> mniip: ; <interactive>:1:1: error: Data constructor not in scope: Pretext
18:31:41 <mniip> % :t Control.Lens.Internal.Context.Pretext
18:31:41 <yahb> mniip: (forall (f :: * -> *). Functor f => p a (f b) -> f t) -> Control.Lens.Internal.Context.Pretext p a b t
18:31:49 <mniip> % :t Control.Lens.Internal.Context.Pretext @(->)
18:31:49 <yahb> mniip: (forall (f :: * -> *). Functor f => (a -> f b) -> f t) -> Control.Lens.Internal.Context.Pretext (->) a b t
18:31:54 <mniip> looks like a cont to me
18:32:11 <Axman6> % :t ContT (withFile "foo" undefined)
18:32:11 <yahb> Axman6: ContT r IO Handle
18:33:19 <mniip> yea I was talking about doing marshalling using ContT and someone sat down and wrote this library http://hackage.haskell.org/package/marshal-contt-0.2.0.0/docs/Foreign-Marshal-ContT.html
18:34:00 <Axman6> Lovely
18:34:02 <mniip> cause e.g. to marshal a list of strings you can traverse cont over the list
18:34:25 <mniip> and it would turn into a nesting of "withAllocation" type things
18:35:35 <iqubic> What does that do?
18:36:40 <Axman6> I'll have  to keep that library in mind next time I'm writing FFI code
18:36:51 <iqubic> Me too.
18:37:09 <iqubic> Also, sized vector has what is effectively a continuation.
18:37:22 <iqubic> withSized or some such, I think it was called.
18:37:52 <mniip> 'alloca f' is a much much safer and paradigmatic way of saying 'malloc >>= \x -> f x <* free x'
18:38:55 <shachaf> It's "safer" in the sense that you won't get memory leaks, I guess.
18:39:05 <mniip> well yea
18:39:21 <mniip> to truly implement 'alloca' you need to whip out mask/bracket and all that stuff
18:39:26 <mniip> I'm just showing the gist of what it's doing
18:40:18 <monochrom> The Navy has Foreign Admiral ContT. :)
18:41:56 <mniip> code like this hits a sweet spot in my heart
18:42:03 <mniip> using high level abstractions to do low level stuff
18:43:10 <shachaf> Of course the implementation is very inefficient compared to something like alloca in C.
18:43:17 <shachaf> It shouldn't even be called alloca.
18:44:17 <Axman6> is it really a call to malloc?
18:45:46 <mniip> it's probably a newByteArray#
18:46:12 <mniip> shachaf, safer than C's alloca tho
18:46:46 <Axman6> iqubic: for reference, the package mniip linked makes code like https://github.com/tssm/up-to-date-real-world-haskell/blob/master/17-interfacing-with-c.org#putting-it-all-together look much more monadic, while still having the same behaviour as the explicit continuations found in that code
18:46:48 <shachaf> Yes, C's alloca isn't very good because you have no idea what the call stack is like.
18:47:00 <shachaf> I would allocate on my own stack instead of the call stack. But surely not call malloc.
18:47:14 <Axman6> @where paste
18:47:14 <lambdabot> https://gist.github.com
18:47:30 <mniip> someone quoted me the other day
18:48:23 <mniip> % :t traverse (ContT . BS.useAsCString) >=> ContT . Foreign.Marshal.withArray
18:48:23 <yahb> mniip: [BS.ByteString] -> ContT r IO (Ptr Foreign.C.String.CString)
18:49:08 <shachaf> Hmm, is ContT even the right thing? Can you cause a double-free by calling a continuation twice?
18:49:30 <mniip> no
18:50:09 <mniip> you can't cause any more double frees by using `ContT alloca` than by using just `alloca`
18:50:17 <Axman6> iqubic: https://gist.github.com/axman6/3a1528111aad4cb79ea44b51836dec85
18:50:18 <shachaf> Oh, right, of course.
18:52:39 <mniip> this is where it's all originated from http://tcp.st/78v35.png
18:58:17 <jackdk> https://git.sr.ht/~jack/libtelnet-haskell/tree/master/src/Network/Telnet/LibTelnet/Ffi.hsc#L175
18:59:48 <mniip> yeah that's writing ContT's bind/traverse by hand essentially
19:02:33 <jackdk> ah thanks
19:02:38 <chrisb> hackage.haskell.org seems to have a bad cert
19:03:07 <Axman6> hmm, any reason the recursive call to go is inside the continuation and not after it?
19:03:38 <Axman6> oh I see
19:04:42 <jackdk> get all the temporary c strings available in the accumulator param, then reverse them into an array. I was thinking of lisp's push/nreverse idiom when I was writing that
19:05:27 <chrisb> hackage.haskell.org presents a fastly.com cert with a *.haskell.org wildcard entry x509v3 subject alternative name
19:06:21 <shachaf> Of course a more efficient thing would be to allocate one buffer for all the strings.
19:06:48 <Axman6> chrisb: #haskell-infrastructure might be a better place to bring this up
19:07:34 <Axman6> shachaf: is there a function to place a bytestring into a given pointer address?
19:08:04 <jackdk> poke, from the Storable instance, perhaps?
19:08:55 <Axman6> Storable doesn't support variable sized types IIRC
19:16:40 <chrisb> Axman6: ok thanks
19:18:00 <Axman6> chrisb: FWIW, I can't see any problems with the cert here
19:19:08 <Axman6> Not Valid After: Friday, 12 June 2020 at 3:07:55 am Australian Eastern Standard Time
19:22:53 <dibblego> "3:07:55 am Australian Eastern Standard Time" <-- this is a problem
19:23:32 <chrisb> Axman6: i think my freebsd fetch does not like the wildcard or the use of alternative subject name
19:24:22 <chrisb> Axman6: the cert applies to several dozen different .[com,net,org] domains
19:25:19 <chrisb> Axman6: i agree the cert is valid for signature, expiration, chain to CA
19:32:04 <jackdk> dibblego: is it? you have a date and a timezone name, so doesn't this map to exactly one UTC offset?
19:33:31 <Axman6> It's also just the user friendly representation of a (I assume) UTC timestamp and not the actual data
19:33:31 <jackdk> anyone here good with ptys? I'm trying to read all the output from a subprocess I'm talking to through a pty, using the posix-pty package. It seems that readPty is blocking, and won't stop even if I wrap it in a System.Timeout.timeout call.
19:57:24 * hackage ats-pkg 3.4.0.6 - A build tool for ATS  https://hackage.haskell.org/package/ats-pkg-3.4.0.6 (vmchale)
20:00:54 * hackage ats-pkg 3.4.0.7 - A build tool for ATS  https://hackage.haskell.org/package/ats-pkg-3.4.0.7 (vmchale)
20:13:27 <dibblego> jackdk: where is the time zone?
20:14:58 <jackdk> dibblego: you don't need to know that. You know that on 2020-06-12 "Australian Eastern Standard Time" means "UTC+10"
20:15:10 <dibblego> jackdk: but it doesn't mean that
20:15:44 <jackdk> dibblego: I could speak those words in London or Cairo and "Australian Easter Standard Time" on 2020-06-12 means "UTC+10". Where am I wrong?
20:15:54 <jackdk> s/Easter/Eastern/, natch.
20:16:26 <dibblego> jackdk: two reasons. 1) some people in UTC+11 call themselves AEST, correctly so if it is fixed 2) AEST means UTC+10 at this moment, but not necessarily future moments.
20:17:00 <Axman6> AEDT /= AEST
20:17:18 <dibblego> no instance Eq (IO TimeZone)
20:17:21 <jackdk> Explain why 1) is correct and not AEDT? 2) we are talking about a timezone name plus a day
20:18:26 <dibblego> jackdk: 1) because Sydney reasons 2) while you were travelling to London, "eastern" voted, and now it is UTC+10:45
20:18:51 <dibblego> let's agree that (IO TimeZone) is not the same type as TimeZone
20:18:58 <monochrom> What you need is a probability monad so you can specify a probability distribution of what AEST will mean in about 6 months. :)
20:19:04 <dibblego> and you cannot "get a TimeZone out of a IO TimeZone"
20:19:13 <dibblego> monochrom: yes, this has been proposed before
20:19:13 <jackdk> dibblego: unsafePerformIO
20:19:53 <dibblego> you've gone to the dark side friend
20:19:59 <monochrom> The Seldon monad haha
20:20:36 <jackdk> har. I'll concede, since we don't have probability distribution over `TzName -> UtcOffset`
20:23:02 <dibblego> a town of 50 or so have decided that it is currently 1307 ACWST (UTC+8:45) — don't rely on the humans. Welcome back.
20:24:52 <jackdk> standing watch through tz shifts is fun. I stood a 3-hour watch from 1600-1800 one day because we were traveling west
20:25:11 <jackdk> it started at 1600 and ran from 1500 to 1800
20:25:24 <dibblego> bless you
20:26:34 <monochrom> I gave my students a 23-hour extension for an assignment because I gave a "1 day" extension but it spanned across a change from standard to daylight-saving (is that the right order?)
20:26:48 <iqubic> I think so.
20:26:54 <monochrom> (yes it is, I never taught courses in falls)
20:27:50 <jackdk> anyway as far as I can tell, there's no way for posix-pty to give me a nonblocking read, or to get the FD and feed it to some equivalent of select or poll
20:30:24 * hackage hoauth2 1.10.1 - Haskell OAuth2 authentication client  https://hackage.haskell.org/package/hoauth2-1.10.1 (HaishengWu)
20:30:59 <ephemient> not sure if it'll give you what you need, but there shouldn't be anything forkpty() does that can't be done with a combination of System.Process.Terminal and System.Process
20:57:48 <iqubic> This is a helpful error message, I must admit: "Map.!: given key is not an element in the map."
21:32:24 * hackage quipper 0.9.0.0 - Meta-package for Quipper.  https://hackage.haskell.org/package/quipper-0.9.0.0 (PeterSelinger)
21:33:24 * hackage quipper-algorithms 0.9.0.0, quipper-libraries 0.9.0.0, quipper-utils 0.9.0.0 (PeterSelinger)
21:33:37 <zeta_0> could you guys give me a hint on how to solve this? https://www.hackerrank.com/challenges/fp-filter-array/problem
21:34:06 <zeta_0> would using a list comprehension be a good idea?
21:34:24 * hackage quipper-language 0.9.0.0, quipper-demos 0.9.0.0, quipper-cabal 0.9.0.0, quipper-all 0.9.0.0 (PeterSelinger): https://qbin.io/must-walker-8l09
21:35:24 * hackage quipper-tools 0.9.0.0 - Miscellaneous stand-alone tools for Quipper  https://hackage.haskell.org/package/quipper-tools-0.9.0.0 (PeterSelinger)
21:36:52 <leifm> zeta_0: `filter` is what you want
21:40:38 <zeta_0> leifm: i don't want use haskells inbuilt functions, i wanted to writ one from scratch, i am looking at example code now, i just wanted a hint'
21:45:20 <leifm> Ah, ok. Yes, a list comprehension would be good idea.
21:46:17 <zeta_0> leifm: the instructions are a little confusing, so i am still trying to break them down
21:48:08 <zeta_0> [x | x <- arr, x < n]
21:48:40 <zeta_0> leifm: ^
21:49:59 <leifm> Yep, that's basically perfect. If you want to, you could rewrite it using `foldr`.
21:50:51 <iqubic> zeta_0: That looks like takeWhile
21:51:06 <iqubic> takeWhile (< n) arr
21:51:41 <leifm> % takeWhile (< 3) [1, 2, 3, 4, 5, 1, 5]
21:51:41 <yahb> leifm: [1,2]
21:51:47 <iqubic> Actually, no I'm wrong. It's a filter.
21:52:01 <leifm> % filter (<3) [1, 2, 3, 4, 5, 1, 5]
21:52:01 <yahb> leifm: [1,2,1]
21:52:21 <iqubic> I mean, it depends on which behavior you want.
21:52:51 <zeta_0> hackerrank accepted the code, thanks for the tips guys
21:53:35 <leifm> Did you try writing it using a fold? Folds are some of the most fun to be had in FP
21:54:35 <zeta_0> leifm: i haven't yet, but i will try folds out
21:56:23 <dsal> If you don't want to use haskell builtins for some reason, then for whatever that reason is, you surely don't want to use a list comprehension.
21:58:17 <leifm> List comprehensions are do-notation + filter, right? Or are they more complex than that.
21:58:30 <leifm> s/./?
21:58:40 <iqubic> No.
21:59:03 <zeta_0> https://www.hackerrank.com/challenges/fp-filter-positions-in-a-list/problem?h_r=next-challenge&h_v=zen
21:59:33 <zeta_0> i have filter odd and even numbers, but i have never filtered odd or even positions
22:01:21 <leifm> You could create a list like [(1, 2), (2, 4), (3, 1), (4, 1)], where the first item of each tuple is the item's position in the list.
22:01:35 <leifm> % zip [1..] [2, 4, 1, 1]
22:01:36 <yahb> leifm: [(1,2),(2,4),(3,1),(4,1)]
22:02:36 <leifm> Then the problem becomes filtering the tuples whose first item is even
22:03:48 <iqubic> Correct.
22:03:57 <iqubic> You can also do this with a fold.
22:07:19 <zeta_0> f lst = [x | x <- lst, x /= [1,3..]]
22:08:17 <dsal> List comprehensions are fine, but other than list comprehensions, I'm not sure how much you'll learn from them.
22:09:29 <zeta_0> dsal: yeah your right i have become really comfortable with list comprehensions, i need to try other approaches
22:10:38 <zeta_0> the list of tuples looks confusing, i think i will try using fold
22:11:43 <dsal> > let fil p [] = []; fil p (x:xs) | p x = x: fil p xs | otherwise = fil p xs in fil even [1..7]
22:11:45 <lambdabot>  [2,4,6]
22:14:10 <zeta_0> dsal: if i understand correctly p is predicate, but i am not sure what the abbreviation for fil is?
22:14:12 <dsal> > let fil p = foldMap (\x -> bool [] [x] (p x)) in fil even [1..7]
22:14:14 <lambdabot>  [2,4,6]
22:14:28 <dsal> fil is the filter function I wrote there
22:14:39 <zeta_0> sorry those abbreviations mess with me sometimes
22:14:44 <dsal> There are lots of ways to do it.
22:14:48 <ChaiTRex> @src bool
22:14:48 <lambdabot> bool f _ False = f
22:14:48 <lambdabot> bool _ t True  = t
22:17:58 <dsal> The first one up there is the pretty basic "I have to write this myself" variant using a recursion scheme that's pretty common for when a fold just won't quite do what you want (though a fold will most of the time)
22:18:54 <dsal> zeta_0: anyway, these are just scribbled into my phone as I'm getting ready for bed. I think it'd be worth understanding what each does.
22:19:20 <zeta_0> dsal: i think i'll try implenting the filter function, i'll try fold on another problem
22:19:28 <zeta_0> dsal: ok, and thanks for the help
22:19:55 <dsal> List comprehensions are a big fancy tool that does a lot for you, but not always the right tool.
22:21:47 <zeta_0> dsal: i don't know, they seem simple and make a lot of sense to me, but yeah, probably not good for all use cases
22:23:06 <dsal> If you want to know how to make filter (which I used a lot in the last few days), they won't teach you much. Can't just drop a list comprehension in the middle of a composed function.
22:23:39 <dsal> I mean, filter exists, of course, but if you can't write it yourself, there's a lot of similar things you can't do.
22:24:19 <zeta_0> dsal: so for this problem that i am working on, what would you recommend that i do?
22:25:59 <dsal> The easiest thing would be to match two items at a time and spit one out.
22:27:19 <zeta_0> fold [1,3..] lst
22:27:41 <dsal> > let f (x:y:xs) = x : f xs; f _ = [] in f "I just wrote this on my phone. Probably doesn't work."
22:27:44 <lambdabot>  "Ijs rt hso ypoe rbbydentwr"
22:28:36 <iqubic> That works.
22:29:05 <zeta_0> cool
22:29:36 <dsal> > let f (_:x:xs) = x : f xs; f _ = [] in f "I just wrote this on my phone. Probably doesn't work."
22:29:39 <lambdabot>  " utwoeti nm hn.Poal os' ok"
22:29:42 <dsal> It's good to understand why.
22:29:56 <iqubic> That's all the even elements.
22:30:12 <zeta_0> oh
22:30:20 <dsal> Yeah. The other was odd.  Take your pick. :)
22:31:18 <iqubic> I'm going to be doing a thing that is very similar to this for my solution to AoC 2015, Day 7, Part 1.
22:31:21 <zeta_0> for this problem i need all the even positions, so your 2nd solution should work
22:31:26 <ChaiTRex> The odd one needs a [x] case, I think.
22:31:44 <iqubic> It does.
22:31:48 <ChaiTRex> It leaves off the period at the end.
22:31:58 <zeta_0> and the odd positions filtered
22:33:17 <zeta_0> dsal: so you are recursively calling the function f?
22:33:17 <dsal> Yeah, numbers might be a better demo. I didn't expect it to even compile, though.  Writing Haskell in irc in the phone shouldn't work well.
22:33:37 <dsal> Yep.  That's how we loop.
22:34:39 <zeta_0> recursion never made sense to me, but after working through the recursion chapter in lyah, recursion makes a lot more sense now
22:35:40 <zeta_0> the other problem that i have is, i understand category theory pretty well but trying to understand it in haskell is hard for me
22:35:52 <zeta_0> i guess i just need to practice a lot more
22:35:55 <dsal> zeta_0: once recursion makes sense to you, recursion will make sense to you.
22:38:15 <zeta_0> to me recursion means defining function then defining the same function again in its own body, so it is essentially calling itself to be applied to some input until some condition is met
22:39:14 <dsal> @src iterate
22:39:14 <lambdabot> iterate f x = x : iterate f (f x)
22:40:24 <dsal> It's just how loops happen.  There doesn't need to be a condition. Just call me.
22:42:13 <ChaiTRex> > iterate (+1) 0
22:42:15 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
22:42:22 <zeta_0> ChaiTRex: so this [x] case is missing?
22:42:48 <ChaiTRex> zeta_0: Yeah, the odd function f from dsal is just missing f [x] = ...
22:43:05 <ChaiTRex> zeta_0: It left off the period at the end of the sentence.
22:43:43 <N3RGY> Interesting that iterate doesn't have a worker function inside. Most prelude functions are written that way iirc
22:46:16 <zeta_0> i am too tired too think, anymore, thanks for the help guys, i'll come ask for more help some other time when i get stuck
22:46:19 <zeta_0> later
22:50:32 <ChaiTRex> N3RGY: Looks like iterate uses iterateFB through a RULES pragma https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.List.html#iterate
22:51:06 <N3RGY> Ah sensible
23:23:24 * hackage edf 1.0.0.0 - EDF parsing library  https://hackage.haskell.org/package/edf-1.0.0.0 (cbou)
23:40:39 <dsal> N3RGY: @src is more illustrative than authoritative. :)
23:42:54 * hackage picosat 0.1.6 - Bindings to the PicoSAT solver  https://hackage.haskell.org/package/picosat-0.1.6 (sdiehl)
23:53:41 <miller> I'm trying to use Text.Pandoc.Generic.topDown , but the walk of the document tree might wish to do IO, so I need to transform `(Block -> Block) -> Pandoc -> Pandoc` into `(Block -> IO Block) -> Pandoc -> IO Pandoc` .  Is there some `lift`-like function I can use to do this ?
23:54:48 <miller> My hoogle query for `(a->a) -> b -> b -> (a -> m a) -> b -> m b` returns nothing
23:55:44 <shachaf> No, it's impossible.
23:56:01 <shachaf> The version with IO contains more information.
23:56:24 * hackage tonatona-servant 0.1.0.3 - tonatona plugin for servant.  https://hackage.haskell.org/package/tonatona-servant-0.1.0.3 (arowM)
23:57:08 <shachaf> http://hackage.haskell.org/package/pandoc-types-1.20/docs/Text-Pandoc-Generic.html says there's a bottomUpM, but it doesn't mention topDownM.
23:57:33 <shachaf> It also mentions you should be using .Walk, which has walkM.
