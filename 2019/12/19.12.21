00:03:53 <DigitalKiwi> https://dpaste.org/PWKZ
00:09:09 <pounce> so say i had an arbitrary number of lists i wanted to "zip" together, like [[1,2,3],[4,5,6]]->[[1,4],[2,5],[3,6]]
00:09:16 <pounce> is that just List.transpose?
00:16:50 <jle`> pounce: yup
00:16:59 <jle`> or sequenceA with ZipList
00:17:11 <jle`> "zipping arbitrary things together" in general is sequenceA
00:17:16 <jle`> (or sequence)
00:17:26 <jle`> *arbitrary number of things together as a list
00:17:42 <jle`> but the problem is List's normal Applicative instance doesn't get the right behavior for zippy
00:17:54 <jle`> but it works nicely for other types
00:18:08 <jle`> > squenceA [Just 1, Just 2, Just 3]
00:18:11 <lambdabot>  error:
00:18:11 <lambdabot>      ‚Ä¢ Variable not in scope: squenceA :: [Maybe Integer] -> t
00:18:11 <lambdabot>      ‚Ä¢ Perhaps you meant one of these:
00:18:19 <jle`> > sequenceA [Just 1, Just 2, Just 3]
00:18:21 <lambdabot>  Just [1,2,3]
00:18:37 <jle`> > sequenceA [ZipList [1,2,3], ZipList [4,5,6]]
00:18:40 <lambdabot>  ZipList {getZipList = [[1,4],[2,5],[3,6]]}
00:18:48 <pounce> oh, hm
00:19:02 <pounce> why is List's applicative weird
00:19:18 <jle`> > sequenceA [[1,2,3],[4,5,6]]
00:19:20 <lambdabot>  [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
00:19:22 <jle`> it gives the cartesian product instead
00:21:20 <pounce> ah
00:21:21 <pounce> makes sense
00:28:01 <pounce> can `Char`s be unicode in haskell
00:28:47 <jle`> > ord 'üòÉ'
00:28:49 <lambdabot>  128515
00:30:01 <pounce> lol ok
00:30:46 <jle`> that was supposed to be the smile emoji, if that didn't show up
00:39:01 <olligobber> it did on my client
01:14:58 <wz1000> Is there a function `forall a msg. TypeError msg =>`
01:15:11 <wz1000> TypeError msg => a
01:18:29 <lhurttila> What would be a good way for making components optional when constructing your own types?
01:22:13 <jollygood2> lhurttila, this idiom is pretty common:   default = MyType { fill fields with default values }  and then use "default { fill the rest of the values (or alter default ones) }"
01:33:53 <bifunctor> Hi all
01:56:39 <asheshambasta> Anyone using csound-expression here? (https://github.com/spell-music/csound-expression/)
03:24:26 <phanimahesh[m]> there is Data.Default for that
03:24:40 <phanimahesh[m]> defines def
04:32:42 <talpa> !lista
04:32:42 <monochrom> talpa: http://okmij.org/ftp
04:33:12 <lavalike> xD
05:38:17 <fenedor> @help tell
05:38:17 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
05:38:49 <fenedor> @tell RSWilli hie now supports Cabal 3.0.0.0!
05:38:49 <lambdabot> Consider it noted.
06:49:23 <jumper149> Hi Im working on a program that is basically parsing a bytestring and printing it to the terminal. Since I am using a stream of bytestrings with Conduit as the input I thought about using Bytestring Builder before outputting. Now I noticed there is a difference between Data.ByteString and Data.ByteString.Lazy, but what exactly is the difference here?
06:51:53 <geekosaur> a lazy ByteString is a (wrapped) lazy list of strict ByteStrings, split into (usually around 64K) chunks. generally with a network stream you want lazy, because otherwise you get nothing until the entire stream has been read
06:52:21 <geekosaur> (conduit does allow you to chunk things its own way though; but you have to do it explicitly)
06:53:38 <geekosaur> which one is better at the end of the stream depends on how much you can stream the output and how much data there is, among other things
06:54:36 <jumper149> I'm already using builderToByteString from Conduit, but I'm generally curious. Is <> in O(n) for ByteString and O(1) for Builder?
06:56:21 <geekosaur> that's much of the point of Builder, yes
06:58:35 <geekosaur> http://hackage.haskell.org/package/bytestring-0.10.10.0/docs/Data-ByteString-Builder.html
06:59:12 <jumper149> Well ye I should have done a little bit more reading before asking ^^
06:59:15 <geekosaur> the stuff at the very top talks about performance and why it produces lazy ByteStrings
06:59:52 <Zemyla> I kind of wish the bytestring package had a fingertree of strict ByteStrings, which would have all strict fields but O(lg c) concatenate.
07:01:42 <Zemyla> It'd be like Builder, but more explicit in its storage and also inspectable.
07:02:15 * geekosaur admits to having wondered about that as well
07:06:26 <Zemyla> Another thing I also want: A safe and reasonably portable interface that allows me to use the equivalent of GHC.Prim.plusWord2#, GHC.Prim.timesWord2#, and GHC.Prim.divModWord2#.
07:07:19 <Zemyla> class (Integral a, FiniteBits a) => Integral2 a where { plus2 :: a -> a -> (a, a); times2 :: a -> a -> (a, a); divMod2 :: a -> a -> a -> (a, a) }
07:07:52 <Zemyla> divMod2 nh nl d throws an exception if d == 0 or nh >= d.
07:08:32 <Zemyla> Actually, should the type of plus2 and minus2 be a -> a -> (Bool, a)? I think so.
08:01:38 <sim590> Is there an implemntation of Johnson's algorithm for finding the total number of elementary circuits inside a graph. I don't see that in Data.Graph for now. For reference, the algorithm is described in https://www.cs.tufts.edu/comp/150GA/homeworks/hw1/Johnson%2075.PDF.
08:17:15 <sm[m]> IIRC several of the graph libraries come with only a few algorithms.. you should check all out all of them (graph libs)
08:17:51 <sm[m]> eg try http://hackage.haskell.org/package/fgl
08:39:54 <simple_guy> Would Haskell prove difficult to learn as a complete noob that only knows a slight bit of Java?Thanks.
08:43:12 <__monty__> simple_guy: That might be an advantage. More experienced programmers usually have a harder time letting go off what they're used to.
08:44:43 <Rembane> simple_guy: Do you like math? 
08:46:55 <p0lyph3m>  simple_guy : if you didnt go through the hell of NullPointerException/Segfaults and nested loops with lot of mutating variables , its harder to appreciate what haskell has to offer ...
08:47:23 <p0lyph3m> hmmm .... too late 
08:47:36 <sim590> simple_guy: Conceptually, I do agree with __monty__, except for the fact that documentation of libraries (especially more advanced) are usually far more harder to understand than their counterpart, sadly. But as far as understanding the base concepts, understanding haskell can be as easy as understanding Java. You just have to put yourself in a different mindset though. You don't think of
08:47:39 <sim590> operations in terms of sequence, but more in terms of composition (function composition). Also, you rather think in terms of immutability rather than mutable. Therefore, for instance there are no assignments of values to "variables". It's different, but not so much harder.
08:48:00 <p0lyph3m> guess simple_guy didnt like math 
08:48:43 * sim590 is sad that he wrote big text while the recipient didn't read it before leaving.
08:48:56 <__monty__> Imo you don't need to like math to like haskell. You have to understand that math means something different to the people who like it than it does to the ones who don't.
08:49:04 <geekosaur> heh
08:49:15 <geekosaur> well, "which math?"
08:50:25 <fenedor> I would not argue that you need math to like haskell. But at some point, understanding the math helps you utilise the concepts. but this is not unique to haskell
08:51:45 <asheshambasta> https://github.com/spell-music/csound-expression/blob/master/tutorial/chapters/UserInteractionTutorial.md am I wrong in finding the types in this library a little sloppy? 
08:52:08 <asheshambasta> (no disrespect to the author, just trying to be critical here.)
08:54:48 <Rembane> asheshambasta: What types do you prefer to model the domain? 
08:54:57 <sim590> sm[m]: Looking at https://stackoverflow.com/questions/5411991/implementation-of-johnsons-algorithm-to-find-elementary-circuits-cycles-in-a, there doesn't seem to be any result listed there. I've looked at fgl which you mentioned, but it doesn't seem like it has anything to do with cycles or circuits.
08:56:17 <asheshambasta> Rembane: I don't have suggestions in particular; but then I'm not entirely sure about everything being a signal; and then also some things like the output of a switch being 1 or 0 (Signal); instead of something like a True/False sum type. 
08:57:17 <__monty__> I guess that's simpler if you're just gonna convolute the signals anyway or whatever.
08:57:40 <Rembane> asheshambasta: Got it, I wonder if there is a natural way to think about this problem if you come from a sound-/dst-background and that is what's making the types interesting in this case. 
08:58:57 <geekosaur> this is more or less how midi "thinks", iirc
08:59:02 <asheshambasta> __monty__: right; that it simplifies the overall combination of Sig's is something I can buy; I'm not sure that still means all types being the same though, but maybe I've not thought about this in depth. 
08:59:04 <geekosaur> since it's a midi interface
08:59:41 <asheshambasta> geekosaur: not always; you're also producing non-midi output when you use oscs etc. 
08:59:41 <geekosaur> and between the first and second examples you get why they're the same type; one is raw and the other with instrument effects, but both are playable sounds
09:00:16 <simple_guy> __monty__ really? Though I am already a bit used to classes and OOP
09:00:55 <simple_guy> Rembane Yes, I do
09:02:01 <asheshambasta> geekosaur: correct 
09:02:52 <Rembane> simple_guy: Liking math will probably make it easier to learn Haskell.
09:03:13 <geekosaur> there's more discrete math here than alg I, though
09:03:27 <asheshambasta> my brief train of thought would be to implement something like `class IsSignal a where ... ` and then implement some arithmetic around that; ``` (.+) :: (IsSignal a, IsSignal b) =>  a -> b -> a``` etc.
09:04:40 <asheshambasta> and then have ``` mul :: Int -> MulSig ``` (with ` instance IsSignal MulSig` ); that would mean a signal from some `mul` can only be used in certain contexts 
09:04:55 <asheshambasta> (i.e. not to end up accidentally wiring things wrongly.)
09:06:38 <geekosaur> Define "wrong"
09:06:43 <asheshambasta> but then once we start thinking of sound synthesis from the analog synth. world, all signals are of the same type, and anything can be wired to anything. 
09:06:49 <geekosaur> especially in this context, more likely "interesting"
09:07:00 <geekosaur> for that matter, same goes for signal processing in general
09:07:05 <asheshambasta> geekosaur: currently; it would be possible to have a very large `mul` factor to be applied to a signal from an `osc`. 
09:07:23 <asheshambasta> And that can damage your hearing / equipment. 
09:07:52 <geekosaur> sure, but you need dependent types to differentiate the very large one from a very small one or a close-to-unity one
09:08:11 <geekosaur> or treat them as different things, which causes other problems
09:08:49 <geekosaur> moreover, in that world you have to deal with such problems anyway so you use shapers / clamps on later stages anyway
09:08:50 <asheshambasta> geekosaur: why would we need dependent types? 
09:10:10 <geekosaur> really? your mul factor isn't some value from a range? if it's not, tell. if it is, how do you differentiate a very large one from a very small one at type level?
09:10:37 <geekosaur> for that matter, "range" requires dependent types or at least smart constructors, and (again) might be better handled with a clamp or shaper on the end of the pipeline
09:11:04 <asheshambasta> currently we have: ```mul :: SigSpace a => Sig -> a -> a``` 
09:11:04 <asheshambasta>  
09:11:28 <asheshambasta> We can possibly do ```mul :: Int -> MultFactor ``` 
09:11:56 <asheshambasta> sorry; ```mul :: MultFactor -> a -> a```
09:11:58 <oats> this feels like a silly question, but is there a class similar to Show in stdlib already, but for formatting values into a human-friendly string? (as opposed to formatting into valid haskell code)
09:12:22 <geekosaur> oats, no, because every human (and often every specific application) haas its on notion of "human friendly"
09:12:30 <asheshambasta> And have a safe constructor ```multBy :: a -> MultFactor``` (which is a scaling function, in essence) 
09:12:35 <geekosaur> there are some tools for building them
09:13:48 <geekosaur> I have a  few applications where I've built up my own prettyprinters; in most I don''t even bother with typeclasses because it's not worth it, and when I do the result isn't really reusable because it's heavily based on application dependent types
09:14:03 <geekosaur> and all the real work is in the instances, so there's not really a shareable "framework"
09:14:33 <asheshambasta> but then like I said, my train of thoughts on this is also too undecided; I wanted to ask what the design of types felt like to more seasoned haskell programmers than myself. 
09:14:36 <geekosaur> unless you go really generic like various prettyprinter libraries on hackage which give you a Doc type and various ways to combine them
09:15:52 <geekosaur> asheshambasta, again I think the real answer there is what makes sense to people who work with this kind of thing. I'm only on the fringes of that and already apparently confusing you?
09:16:33 <asheshambasta> geekosaur: from a sound design perspective, treating everything as the same is what happens in real life. 
09:17:12 <asheshambasta> I guess, I can rephrase my question to: can haskell make sound design "safer" and more hard to make mistakes in? 
09:17:38 <geekosaur> at the price of not being comprehensible to people who work with it, yes
09:17:43 <geekosaur> is what I've been trying to say
09:18:01 <asheshambasta> geekosaur: yeah I guess. 
09:18:11 <geekosaur> it's easier to do that out on the fringes of research. for audio design, that just means your lib rary doesn't get used
09:18:49 <asheshambasta> yeah; but then again; I'm not sure if this library is being used by anyone outside of Haskell
09:19:20 <asheshambasta> so I've come to almost assume that a Haskell library tackling a problem from a domain will improve upon it's safety.
09:20:03 <asheshambasta> and to some extent this lib. does: we still get to compose things seamlessly that is more like actual sound design (given the Haskell syntax); but I do feel that the lack of safety is maybe a missed opportunity. 
09:23:46 <geekosaur> part of the problem there is that audio has a fair amount of "but then you can't be clever" to it as well
09:24:04 <asheshambasta> but yes, there's a good chance that at this stage I'm oversimplifying the lengths we'd need to go to achieve this safety.
09:24:17 <asheshambasta> yea 
09:26:08 <Amras> what's a good way to display evaluation times for specific hspec tests?
09:33:05 <jumper149> Is it expensive timewise to convert ByteString to Builder and vice versa?
09:36:30 <geekosaur> more expensive than sticking to one or the other, but in particular Builder to ByteString should be fairly quick because it just concatenates the components into a lazy list. you do not want to switch between them constantly, though; in that case, just sticking to ByteString should be cheaper even if it does mean slower concat
09:37:49 <geekosaur> alternately build a lazy ByteString in a streaming fashion by using Builder to build up a chunk, convert to lazy ByteString, and concatenate with the existing one; this only seems to make much sense if you get data in largeish chunks and process in streaming fashion between chunks, though
09:38:06 <Zemyla> Like I said, I want a fingertree of ByteStrings which exists as a structure in memory instead of an unapplied function, and which allows O(1) cons and snoc and O(lg c) (<>).
09:38:22 <Zemyla> And O(lg c) index,
09:38:51 <jumper149> It's just that I've been unfamiliar until with Builder until now and I want to keep it readable, so I thought about keeping some exported functions with (... -> ByteString).
09:46:55 <sm[m]> Amras: add a call to http://hackage.haskell.org/package/timeit ?
10:10:06 <koz_> Zemyla: It sounds like you want a rope?
10:10:16 <Zemyla> Yeah, pretty much.
10:10:34 <koz_> I dunno if there's a ByteString based rope library around.
10:10:37 * koz_ checks.
10:11:48 <koz_> There is one by Edward, but it's not very documented and not been updated for nearly six years.
10:12:22 <koz_> The current ropes are designed for UTF-8 or UTF-16.
10:12:29 <koz_> I assume this won't do?
10:12:45 <koz_> s/not/has not/
10:15:32 <jumper149> koz_: In the English language, can't the "'s" from the "it's" hold multiple extensions (like is or has) in a single occurence? :D
10:15:56 <koz_> jumper149: Sometimes, but not the way I constructed that sentence.
10:16:18 <koz_> "It's cool and funny" <-- works
10:16:33 <koz_> "It's not very documented and not been updated for nearly six years" <-- hideous kludge
10:16:34 <jumper149> koz_: there it extends to is both times
10:16:59 <jumper149> there it would extend to is first and has for the second part? :D
10:17:20 <koz_> jumper149: It doesn't work in that case due to the verb change.
10:17:37 <koz_> In my first example, you're spanning 'is cool' and 'is funny'.
10:17:55 <koz_> In my second, you're trying to span 'is not very documented' and 'has not been updated', so it doesn't work.
10:18:08 <koz_> There's no common verb to factor out.
10:18:50 <jumper149> Ah ye ok I understand it :D Are you absolutely sure this is correct?
10:19:25 <koz_> jumper149: Pretty darn, considering I worked as an ESOL teacher in a past life. :P
10:19:39 <geekosaur> formally corect. practically, English has a certain "it'll be understood so it's not wrong" quality‚Ä¶ but it sounds "off"
10:20:06 <koz_> geekosaur: Yeah, that's true as well. In fact, modern ESOL teaching practice focuses on 'did your idea get across' rather than 'did you get every rule right'.
10:20:22 <geekosaur> rules‚Ä¶ natural language‚Ä¶
10:20:36 <koz_> However, given that I'm an L1 speaker, and a pretty educated one to boot, I should hold myself to a slightly higher standard. :P
10:20:48 <koz_> (especially in a text-only medium, where body language, tone etc don't carry)
10:22:37 <MarcelineVQ> it's was's fine's koz's
10:23:07 <MarcelineVQ> conveyance of meaning is more imporant than purity of form
10:23:43 <MarcelineVQ> Understand you yes? :>
10:23:54 <LKoen> MarcelineVQ: well I'm reviewing this 400-lines long function that someone wrote and I can say there is such a thing as no conveyance + no purity
10:24:02 <MarcelineVQ> ye
10:24:43 <koz_> MarcelineVQ: There's degrees, and it's highly contextual.
10:24:58 <koz_> (for what it's worth, your meaning came across well, sarcasm and all)
10:25:43 <koz_> LKoen: No conveyance + no purity - some code I saw at work that I decided to rewrite instead of improving.
10:25:47 <MarcelineVQ> *rhetoric and all
10:26:02 <koz_> Seriously, if you write 100+ line long functions with zero docs in 'C with classes'...
10:26:19 <koz_> (funnily enough, my immediate superior thinks the person who wrote this does good work)
10:26:25 <geekosaur> well, haskell it ain't
10:26:28 <koz_> (I would _love_ to inform them just how wrong they are)
10:26:34 <koz_> geekosaur: Ain't _that_ just the truth.
11:06:56 <MarcelineVQ> What can‚Äã I use to manually retreive a file modification time? letting hinotify tell me when it happens is not applicable for my situation
11:07:29 <AWizzArd> streamly. It makes some bold claims about efficiency: ‚ÄúOther streaming libraries like "streaming", "pipes" and "conduit" are orders of magnitude slower on most microbenchmarks.‚Äù  ‚Äì is this generally observed to be true?
11:07:56 <geekosaur> ‚Ä¶sigh‚Ä¶
11:08:09 <MarcelineVQ> AWizzArd: there's a link to those benchmarks where they compare, if you put much stock in bench's
11:08:47 <AWizzArd> MarcelineVQ: I followed the that links and took a look at the benchmarks (without inspecting the code). Do you have experience with streamly?
11:09:25 <monochrom> MarcelineVQ: Does something in System.Directory help?  If not, does something in System.Posix help?
11:09:33 <dishonor-garbage> MarcelineVQ:  Maybe `modificationTime` in https://hackage.haskell.org/package/unix-2.7.2.2/docs/System-Posix-Files.html#g:6 ?
11:10:12 <MarcelineVQ> AWizzArd: only just a little
11:10:55 <AWizzArd> MarcelineVQ: any negative comments? Did those little tests work out for you?
11:14:57 <MarcelineVQ> AWizzArd: I found it pretty novel in how simply things composed and that you could change the behavior of streams using combinators, and that one could even create FRP by combinging those streams. I don't have enough experience with it to have specific positive or negative comments but there's a few examples of using streamly that give you a good idea and the devs are very responsive to questions. One big positive is that it comes with a tutorial 
11:14:57 <MarcelineVQ> module, which I really  think all libs should.
11:15:23 <MarcelineVQ> monochrom dishonor-garbage; thank you, I see a getModificationTime in System.Directory that might do the job
11:17:00 <koz_> AWizzArd: I have found streamly to be plenty good. Good enough that I wrote a support library for it.
11:17:50 <AWizzArd> koz_: okay, so this is some positive feedback. Btw, what support library?
11:18:07 <koz_> streamly-fsnotify
11:18:20 <koz_> https://hackage.haskell.org/package/streamly-fsnotify-1.0.0.0
11:20:15 <koz_> I can also second documentation quality and dev responsiveness.
11:22:54 <AWizzArd> koz_: danke
11:23:05 <koz_> AWizzArd: You're welcome, but I'm not German.
11:30:20 <AWizzArd> koz_: I didn‚Äôt suspect you were german, I just speculated that you can parse "danke" (:
11:31:32 <koz_> I can, but I always find it funny when folks do that.
11:42:07 <sm[m]> argh.. lesson learned, don't edit reddit like a wiki, it will eat your work
11:43:31 <dignissimus> I defined the natural numbers in Haskell, what can I do with this now? http://ix.io/253M
11:44:38 <koz_> dignissimus: Have a sense of pride and accomplishment? :P
11:44:53 <koz_> 'Definite multiplication' is also a valid option.
11:45:29 <dignissimus> I'll have to think about multiplication for a bit
11:45:36 <leifm> Do it again with a binary representation
11:46:53 <koz_> x * 0 = 0; x * S(y) = x + x * y
11:47:14 <koz_> Straight from Peano.
11:47:18 <koz_> (I think)
11:48:09 <leifm> Also monus: (x + 1) - (x + 1) = x; 0 - x = 0; x - 0 = x
11:48:35 <nil> dignissimus: instance Num Nat
11:48:50 <nil> wait... that's not gonna work
11:48:52 <koz_> That will necessarily be partial.
11:48:56 <koz_> In a rather significant way.
11:49:14 <nil> yeah
11:49:48 <dignissimus> So I've done multiplication
11:49:56 <dignissimus> Could I do something similar for the integers?
11:55:35 <leifm> Anyone know why GHC's StgSyn defines a new kind for its type indices?
11:56:12 <leifm> I.e. why it defines `StgPass = Vanilla | CodeGen | ...` rather than `data Vanilla`, `data CodeGen` etc
11:56:29 <leifm> https://gitlab.haskell.org/ghc/ghc/blob/master/compiler/stgSyn/StgSyn.hs#L433
11:59:25 <dmwit> Because that makes it harder to accidentally put `Int` where `Vanilla` should go?
11:59:43 <dmwit> All the same reasons we like having a type system for the computation level, basically.
12:01:25 <bifunctor> hi all
12:01:45 <bifunctor> Could someone tell me, how to convert String into Int value?
12:02:04 <bifunctor> I've found http://hackage.haskell.org/package/base-4.12.0.0/docs/Text-Read.html
12:02:14 <bifunctor> but do not know, if it is the right lib
12:02:19 <bifunctor> thanks
12:02:49 <dignissimus> I think the `read` is in prelude
12:03:00 <dignissimus> the `read` function*
12:03:09 <stilgart> > read "123"
12:03:12 <lambdabot>  *Exception: Prelude.read: no parse
12:03:19 <phadej> > read "123" :: ()
12:03:22 <lambdabot>  *Exception: Prelude.read: no parse
12:03:24 <phadej> > read "123" :: Int
12:03:27 <lambdabot>  123
12:04:15 <geekosaur> read (in the prelude) is the quick and dirty version. Text.Read functions let you handle errors a bit better than throwing an exception. parsers give you more control (Text.Read gives you a simple parser, but you may prefer one with better behavior and performance)
12:05:14 <bifunctor> I would like to use Text.Read
12:05:24 <bifunctor> but do not know how.
12:05:36 <phadej> > Text.Read.readMaybe "123" :: Maybe Int
12:05:38 <bifunctor> Could someone show me an example
12:05:40 <jumper149> An ignorant would be to just use read
12:05:42 <lambdabot>  error:
12:05:42 <lambdabot>      Not in scope: ‚ÄòText.Read.readMaybe‚Äô
12:05:42 <lambdabot>      No module named ‚ÄòText.Read‚Äô is imported.
12:05:47 <phadej> % Text.Read.readMaybe "123" :: Maybe Int
12:05:48 <yahb> phadej: Just 123
12:05:49 <jumper149> *ignorant approach
12:05:52 <phadej> % Text.Read.readMaybe "xyz" :: Maybe Int
12:05:52 <yahb> phadej: Nothing
12:07:21 <phadej> but really, read is probably wrong thing
12:07:32 <phadej> % Text.Read.readMaybe "0123" :: Maybe Int
12:07:33 <yahb> phadej: Just 123
12:07:36 <phadej> % Text.Read.readMaybe "0x123" :: Maybe Int
12:07:36 <yahb> phadej: Just 291
12:07:45 <phadej> % Text.Read.readMaybe "-0.123" :: Maybe Int
12:07:46 <yahb> phadej: Nothing
12:07:49 <bifunctor> http://hackage.haskell.org/package/base-4.12.0.0/docs/Text-Read.html#v:readMaybe
12:07:50 <phadej> % Text.Read.readMaybe "-0123" :: Maybe Int
12:07:50 <yahb> phadej: Just (-123)
12:07:56 <bifunctor> works amazing 
12:08:01 <bifunctor> thanks a lot guys
12:08:24 <leifm> % Text.Read.readMaybe "+4" :: Maybe Int
12:08:24 <yahb> leifm: Nothing
12:08:45 <phadej> it's quite closely tied to Haskell syntax, for good and bad
12:08:59 <phadej> % Text.Read.readMaybe "0b0123" :: Maybe Int
12:08:59 <yahb> phadej: Nothing
12:09:15 <phadej> (one can argue that should work)
12:09:24 <phadej> at least with recent `base`
12:10:09 <phadej> read is really only usable to AoC like problems :)
12:25:29 <hololeap> i have a Proxy (Maybe Symbol) and i want to use symbolVal if it's ('Just Symbol) and get an empty string if it's 'Nothing ... how can i do this without using the singletons library?
12:29:23 <phadej> class MyKnownSymbol (m :: Maybe Symbol) where mySymbolVal :: Proxy m -> String; instance MyKnownSymbol 'Nothing where mySymbolVal _ = ""; instance KnownSymbol s => MyKnownSymbol ('Just s) where mySymbolVal _ = symbolVal (Proxy :: Proxy s)
12:29:46 <phadej> read about what singletons library generates, and write that by hand.
12:32:03 <fen> did anyone understand about what is up with HMonads?
12:32:40 <fen> i cant really understand about how a HList is a functor....
12:33:02 <fen> and if a HTree flattens to a HList on join, then what is HApplicative!?
12:33:37 <fen> is this a thing?
12:35:39 <fen> HTree was here; https://pastebin.com/raw/acKmr5xE
12:36:11 <fen> just cant understand how to make classes it can instantiate...
12:36:34 <fen> i guess it should be traversable, but i cant even map over it...
12:38:30 <fen> maybe there is more like a zip applicative instance with hetrogenous functions which match the types at the leafs...
12:39:46 <fen> which seems to motivate having homogenous trees as hetrogenous trees but with "type level repeat" to generate the fact that they are hetrogenous...
12:40:40 <fen> that way you can map a type family over them and have it be hetrogenous automatically if the type family maps all the contents to the same type
12:42:46 <fen> ie; type ListN (a :: *) (n :: Nat) = HList (Replicate n a) 
12:43:12 <fen> ie; type ListN (a :: * ) (n :: Nat) = HList (Replicate n a) 
12:43:24 <fen> (sorry, kiwiIRC made that into a winky face...)
12:44:28 <fen> not sure then how to make it polymorphic in its length...
12:44:54 <fen> like, to have tree use this uniform HList instead of [] in; data Tree a = Branches [Tree a] | Leaf a
12:53:45 <fen> hmm, seems impossible actually...
12:57:45 <pounce> ok so i have a bit of a problem
12:58:45 <fen> if you describe it then we can make suggestions
12:59:11 <pounce> im trying to modify a function. it's pretty much a recursive function `f :: a -> a` which modifies its argument and then changes its argument and calls itself, except in one case where it just returns
13:00:12 <fen> how is that "modifying a function" ?
13:00:21 <pounce> i want to change it so instead of being recursive it just takes its argument and returns the modified version which can then be passed back in. But then im trying to figure out how to get the recursive version back out
13:01:11 <pounce> my first instinct was i want to fix this function to get a value, but that's completely wrong since it's strict and needs an initial argument to start.. instead i suppose i want to find a fixed point given an initial condition
13:01:17 <fen> :t scan
13:01:19 <lambdabot> error:
13:01:19 <lambdabot>     ‚Ä¢ Variable not in scope: scan
13:01:19 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
13:01:22 <fen> :t scanr
13:01:24 <lambdabot> (a -> b -> b) -> b -> [a] -> [b]
13:02:46 <fen> pounce, how isnt that just fixing it?
13:03:12 <pounce> fixing the function would yield _|_ because i have to evaluate the argument to produce the return value
13:03:22 <fen> fix f x = fix f (f x)
13:03:24 <fen> that right?
13:03:58 <pounce> sure but the least defined fixed point of this function is bottom so it wouldn't work....
13:04:23 <fen> i dont understand why...
13:04:34 <fen> @let fix f x = fix f (f x)
13:04:36 <lambdabot>  .L.hs:163:11: error:
13:04:36 <lambdabot>      Ambiguous occurrence ‚Äòfix‚Äô
13:04:36 <lambdabot>      It could refer to either ‚ÄòData.Function.fix‚Äô,
13:04:44 <fen> @let myfix f x = myfix f (f x)
13:04:45 <lambdabot>  Defined.
13:04:50 <fen> :t myfix
13:04:51 <lambdabot> (t1 -> t1) -> t1 -> t2
13:05:00 <fen> you mean that t2 is the problem?
13:05:39 <pounce> that's a different fix than i know about
13:05:40 <pounce> :t fix
13:05:42 <lambdabot> (a -> a) -> a
13:06:52 <fen> oh, but its what you were after?
13:07:16 <fen> i normally call that "repeatedly"
13:07:24 <fen> im not sure maybe its in modan loops or something
13:08:10 <fen> :t iterate
13:08:12 <lambdabot> (a -> a) -> a -> [a]
13:08:37 <pounce> yeah i could just iterate it and look for two repeated values but that seems a bit silly
13:09:07 <fen> oh, like a convergence condition
13:09:17 <fen> monad-loops has iterateWhile
13:09:46 <pounce> ooh!
13:10:01 <pounce> that might work nicely! thank you
13:10:44 <pounce> especially because my value here is wrapped in a monad
13:11:39 <fen> might be something like, foldr (>=>) (return a) . repeat f
13:12:27 <fen> oh wait, thats for if f :: a -> m b, nvm sorry
13:12:37 <fen> a -> m a *
13:15:05 <fen> probably thats; iterateM_ :: Monad m => (a -> m a) -> a -> m b 
13:16:11 <fen> though yeah, unless you detect the fixed point its just going to keep looping forever
13:18:37 <fen> so whatever the stopping criteria was that was of the original recursion would be embeded into a Maybe
13:18:44 <fen> so then see; whileJust :: Monad m => m (Maybe a) -> (a -> m b) -> m [b]
13:18:56 <fen> or; unfoldrM :: Monad m => (a -> m (Maybe (b, a))) -> a -> m [b]
13:20:05 <fen> actually yeah, whileJust doesnt seem to return a new `a' to act on
13:20:16 <fen> so probably what you want is last and unfoldrM
13:21:02 <fen> unless the way that this seems to map over the resulting list to give `b' is unnesacary
13:24:10 <Ailrun[m]> :t \f -> foldr (>=>) return $ repeat f
13:24:12 <lambdabot> Monad m => (c -> m c) -> c -> m c
13:25:03 <phadej> :t mfix
13:25:05 <lambdabot> MonadFix m => (a -> m a) -> m a
13:25:09 <phadej> ok, not the same
13:25:25 <bifunctor> I am using stack 
13:25:50 <bifunctor> and it supports docker integration
13:26:54 <bifunctor> but the image size of a build is 8.52 GB
13:27:18 <fulaphex> hello, I'm trying to learn some haskell and I have a question. I understand that assert is an identity, function and I'm wondering what's the idiomatic way to use them. What would you say about such piece of code? http://ix.io/254m
13:27:31 <bifunctor> that is huge
13:27:46 <bifunctor> why it is so big?
13:33:23 <cipharius> fulaphex: oh no, you should be using guards to have predicate for a function https://en.wikibooks.org/wiki/Haskell/Control_structures#if_and_guards_revisited
13:35:00 <fulaphex> cipharius: so I shouldn't be using the assert at all?
13:39:09 <Logio> fulaphex: right, and generally anything else that throws exceptions.
13:39:17 <cipharius> fulaphex: In general you want to avoid runtime errors. Haskell's strict type system is one of it's main features after all, should learn how to use it
13:40:49 <cipharius> otherwise you lose the whole "if it compiles it will run without a hitch" confidence
13:42:25 <fulaphex> well, used can still submit input that will result in a failure, right?
13:43:51 <cipharius> you want to get away from such unstable state as soon as possible. Parse the input data into a safe data type
13:45:08 <fulaphex> so is that the way to write it? http://ix.io/254H?
13:49:10 <hololeap> phadej: oh, i see. i can have different instance for both ('Just Symbol) and 'Nothing. thanks
13:50:02 <cipharius> i'd use replicate: replicate x $ replicate x Nothing
13:50:23 <phadej> hololeap: yes, you could define SMaybe singleton and ... but that's just a detour
13:51:42 <cipharius> btw, one way to avoid the possibility of providing an invalid number is to ask for a Natural number, that way compiler will stop you from making mistake at compile time
13:52:33 <cipharius> so you could have a function with signature genEmptyBoard :: Natural -> [[Maybe Bool]] and the function can simply be genEmptyBoard x = replicate x $ replicate x Nothing
13:53:07 <cipharius> Natural number data type can be found in module Numeric.Natural
13:53:18 <hololeap> i already had `class HasCode s ; fromCode :: t s -> String` but i never thought of making an instance for 'Nothing
13:54:20 <fulaphex> cipharius: thanks, I'll just need to google the $ function
13:54:27 <hololeap> i was caught up on "how do i pattern match a type-level Maybe?"
13:54:33 <hololeap> i guess that's how :p
13:54:45 <fulaphex> also, is that good practice to write such longer oneliners>
13:55:34 <cipharius> that's not really that long and I've noticed that's pretty idiomatic for Haskell code
13:56:46 <cipharius> $ is function application operator, a great way how to avoid too many parenthesis
13:57:36 <fulaphex> cipharius: awesome, I'm trying to learn it the idiomatic way, so I'm trying to grasp those concepts
13:57:42 <cipharius> replicate x $ replicate x Nothing can be written as (replicate x (replicate x Nothing)), both are identical
13:57:47 <fulaphex> but it's quite different from python :D
13:58:46 <cipharius> I'm pretty new myself, I'm still figuring out the common haskell abstractions
14:00:59 <d34df00d> Hi!
14:01:18 <d34df00d> Let's say I have a type `data Foo (f :: MyType)`, where `data MyType = MT1 | MT2 | MT3`.
14:01:39 <d34df00d> Can I write a function that takes `Foo f` for f equal to MT1 or MT2, but not MT3?
14:02:22 <d34df00d> Or, rather, how do I express that in types?
14:02:57 <bifunctor> https://stackoverflow.com/questions/59440139/how-to-build-a-docker-image-from-exe-in-haskell
14:03:04 <d34df00d> I surely could do a type family that maps the good ones onto 'True and bad ones onto 'False and have an equational constraint in the contest, but that seems a bit clunky.
14:03:10 <bifunctor> Would be very happy if someone could helo
14:03:12 <bifunctor> help
14:10:18 <d34df00d> Ah, I was having an XY problem. In particular I was only caring that some other type family `TF f ty` maps ty = Void to Void.
14:10:26 <d34df00d> And I could just write `TF f Void ~ Void => ...`
14:10:32 <d34df00d> Which works.
14:18:26 <hololeap> how would i write a type family of kind (k -> Constraint) where it always returns () no matter the kind passed in?
14:20:55 <hololeap> i need it to be `type family ConstUnit :: k -> Constraint` so i can't use k in the instance
14:26:09 <jle`> hololeap: why not just type family MyFam k where MyFam k = () :: Constraint ?
14:26:57 <jle`> type family ConstUnit k :: Constraint where ConstUnit k = ()
14:27:10 <hololeap> jle`: i have `type family MaybeConstraint (c :: k -> Constraint) (m :: Maybe k) :: Constraint`
14:27:24 <hololeap> and i need something to pass in for 'Nothing
14:27:45 <hololeap> wait... no that's not the whole problem
14:28:23 <hololeap> i have `class HasExWrapper (c :: k -> Constraint) (t :: k -> Type)`
14:28:33 <hololeap> and i want to pass in a partially applied MaybeConstraint
14:28:42 <hololeap> which isn't possible apparently
14:28:51 <jle`> 'pass in' ?
14:29:14 <jle`> is there a function you are writing
14:29:39 <jle`> or are you saying you want to write an instance for a partially applied type family
14:30:10 <jle`> you want to write an instance for HasExWrapper for `MaybeConstraint 'Nothing` ?
14:30:31 <jle`> *instance of
14:31:55 <hololeap> i have a bunch of GADTs that have the form `data Gadt (code :: Symbol) where` and each one has a corresponding `data SomeGadt where ; SomeGadt :: KnownSymbol c => Gadt c -> SomeGadt`
14:32:00 <jle`> partial application is an issue here maybe yeah, but the bigger issue is what it would even mean for an unapplied type family to be an instance of a typeclass
14:32:22 <hololeap> so i wrote the HasExWrapper class for it, which works well
14:32:32 <jle`> it barely even makes any sense for a type synonym to be an instance of a typeclass
14:33:04 <hololeap> but i have one GADT which has the form `data Weirdo (code :: Maybe Symbol)` and i want to be able to write a HasExWrapper instance for it
14:33:56 <jle`> so you're not married to MaybeConstraint as a type family?
14:33:58 <hololeap> hence i made the MaybeConstraint type family, but i have to have something of kind (k -> Constraint) to "pass in" to HasExWrapper
14:34:09 <jle`> because usually things of type `k -> Constraint` are typeclasses
14:34:23 <jle`> not ... type families
14:34:28 <hololeap> jle`: i'm not married to any of this :p
14:34:34 <jle`> and typeclasses can be instances of typeclasses no problem
14:34:51 <jle`> so normally you have instance HasExWrapper KnownSymbol Gadt, right?
14:35:01 <hololeap> jle`: right
14:35:04 <jle`> the thing going in the 'c' is a typeclass right?
14:35:14 <jle`> so you just need another typeclass here
14:35:19 <jle`> not a type family
14:35:41 <jle`> class KnownSymbolMaybe (s :: Maybe Symbol), perhaps
14:35:50 <jle`> instance KnownSymbolMaybe 'Nothing
14:35:57 <jle`> instance KnownSymbol s => KnownSymbolMaybe ('Just s)
14:36:14 <jle`> there are probably better ways to do this in a more general case, but my point is that you should be using a typeclass for 'c'
14:36:17 <jle`> not a type family
14:36:27 <jle`> since you were already happily using a typeclass before :)
14:37:01 <hololeap> well when i started down this path i didn't realize that type families couldn't be "partially applied"
14:38:18 <koz_> Yeah, that's a nuisance.
14:38:31 <koz_> It's why singletons has to have a gigantic workaround in the form of defunctionalization.
14:38:40 <jle`> ah yeah, my 'should' there isn't a "you should have known to use a typeclass", but rather "this is a way forward that you can use"
14:38:56 <bifunctor> second Problem https://stackoverflow.com/questions/59440352/fooservice-exe-port-getenv-does-not-exist-no-environment-variable
14:39:07 <jle`> but i'm hoping that this solution should appear to you to be more simple than using a type family
14:39:30 <jle`> and suggesting a line of thought that you could use to deduce it :)
14:40:46 <hololeap> jle`: it's a good solution, although i suppose i would be more interested in knowing a more general solution using type classes where i'm not writing KnownSymbolMaybe KnownNatMaybe etc... this is just for my future knowledge/convenience, it isn't an important project or anything
14:40:52 <koz_> bifunctor: What's your code?
14:42:51 <jle`> hololeap: in the general case you can parmaeterize your known-maybe on the typeclass
14:43:21 <jle`> class MaybeC (c :: k -> Constraint) (a :: Maybe k) where
14:43:29 <jle`> it dpeends on the thing you want to do with it of course
14:43:54 <hololeap> just apply c to k if it's 'Just or simply () if it's 'Nothing
14:44:17 <hololeap> i just don't know what to put in the body of the class for that
14:44:46 <jle`> hololeap: that's because a 'general solution' only works as far as what sort of general behavior you are trying to use
14:44:59 <jle`> for example you could use it with Monad too, or Typeable
14:45:16 <jle`> but...it would be meaningless because there is no concept of what idea you are trying to unite
14:45:25 <jle`> what would you be trying to unite with KnownSymbolMaybe and KnownNatMaybe ?
14:47:05 <jle`> at least, what behavior is HasExWrapper supposed to be generalizing?
14:47:29 <hololeap> for (Maybe Symbol) use the constraint (KnownSymbol s) when it is ('Just s) or () when it is 'Nothing; for (Maybe Nat) use the constraint (KnownNat n) when it is ('Just n) or () when it is 'Nothing ...
14:47:58 <jle`> but what do you want to use the constraint to do?
14:48:01 <jle`> just ... exist?
14:48:07 <jle`> if that's the case then the class body can be empty no problem
14:50:20 <hololeap> yeah, i suppose i just need it to exist :p 
14:51:56 <hololeap> anyway i'll experiment using a typeclass instead. thanks jle` :)
14:52:15 <jle`> np :)
15:05:22 <pounce> is Integer the arbetrary precision one?
15:05:26 <koz_> pounce: Yes.
15:05:43 <koz_> Int is the corresponding machine/bounded size/overflowy-underflowy one.
15:13:05 <pounce> hmm, i suppose there isn't any way to efficiently use Integers like Intmap
15:13:09 <pounce> should prob just use Map
15:13:19 <koz_> pounce: What are you trying to achieve?
15:13:35 <ChaiTRex> pounce: Easy way to remember is that Integer holds all the letters you need and Int truncates.
15:16:20 <pounce> working on advetn of code bc im dumb
15:16:34 <ephemient> Int can be unboxed and Integer can't be
15:17:05 <ephemient> shouldn't *need* Integer for AoC
15:17:18 <pounce> humm
15:17:46 <pounce> ye they're like "you need big numbers" and give the examle of "1125899906842624" but that fits in an int fine
15:18:27 <ChaiTRex> Only thing on that is that Int won't work on 32-bit architectures on some problems. You need specifically Int64.
15:18:40 <ephemient> that number is 2^50
15:18:59 <pounce> makes sense
15:19:04 <ephemient> so it even fits in a double
15:19:20 <ephemient> which is convenient for certain *ahem* languages that don't have native ints
15:19:40 <koz_> ephemient: Yeah, naming no names.
15:19:46 * koz_ looks pointedly at JavaScript.
15:20:49 <evelyn> it would point back except it lacks pointers
15:21:25 <koz_> Wouldn't be the only thing it lacks.
15:21:29 <pounce> ok well for some of these AOC problems I was using `Seq Int` because i wanted quick access into adjacent numbers
15:22:03 <pounce> but now some of them are asking for more random access, and something that's more efficient than just a growing `seq` i think would be a map which i could split and then turn into a list
15:22:26 <pounce> and i could use Map Integer Integer instead
15:22:28 <koz_> IntMap would work.
15:22:34 <pounce> ye or IntMap
15:22:38 <koz_> If you aren't worried about overflow.
15:22:45 <ChaiTRex> pounce: If 32-bits of indexes work, IntMap is available too.
15:22:58 <koz_> ChaiTRex: Is it _strictly_ capped to 32 bits?
15:23:02 <koz_> I thought it was native Int size?
15:23:08 <ChaiTRex> koz_: If you're on a 32-bit machine, yeah.
15:23:15 <koz_> ChaiTRex: Yeah, what I figured.
15:23:17 <ephemient> if you need more than 32 bits of indices, you're using so much memory you might be in trouble anyway :D
15:23:36 <pounce> but that's not the problem, i think i want more sparse memory
15:23:43 <pounce> which i think IntMap woudl do better
15:23:53 <ChaiTRex> IntMap is whatever size Int is, 32 or 64.
15:33:18 <fulaphex> what's the best way to get a print in a function? for debug purposes only, at least right now
15:33:57 <ChaiTRex> fulaphex: There's a debug print module. Let me check.
15:34:23 <fulaphex> but can I just use standard print statement? inside a do block
15:34:25 <ChaiTRex> fulaphex: Debug.Trace has functions to print: http://hackage.haskell.org/package/base-4.12.0.0/docs/Debug-Trace.html
15:34:35 <ChaiTRex> fulaphex: Sure, you can do that for IO.
15:34:45 <ChaiTRex> fulaphex: Outside of IO, you'll need Debug.Trace.
15:35:23 <fulaphex> so I can print if return type of the function is IO, meaning it's either reading stdin or writing to stdout?
15:35:41 <ChaiTRex> fulaphex: You can print if you're in a do block of type IO whatever.
15:35:45 <fulaphex> and if the return type is different I need debug.trace?
15:36:19 <ChaiTRex> fulaphex: Outside of a do block of type IO whatever, you'll need Debug.Trace, like if you're defining the fibs Fibonacci function, it's not IO whatever, it's just [Integer].
15:36:46 <fulaphex> yup, that's what I meant
15:37:50 <fulaphex> thanks, haskell surely is confusing
15:39:43 <hpc> it'll make sense once you've done a bit more
15:40:01 <hpc> it has to be a bit different because printing stuff out is IO, and we want IO to be separate for yet more reasons
15:41:40 <fulaphex> that certainly is my hope
15:42:25 <fulaphex> one more thing - does trace only print if it's used in return statement?
15:42:53 <fulaphex> if my function is a do block with multiple steps, how do I print a non-final step?
15:43:21 <hololeap> fulaphex: what monad are you in?
15:43:30 <hpc> (trace "blahblah" expr) prints if expr is evaluated
15:43:32 <ChaiTRex> fulaphex: If you're using Debug.Trace, you need to evaluate the value that has the trace part in it.
15:43:32 <hpc> however that happens
15:44:10 <fulaphex> hololeap: I'm not that far yet, I don't know answer to that question
15:44:19 <hpc> you can add trace anywhere you have an expression
15:44:40 <hpc> (return whatever) is an expression, so you can do trace "foo" (return whatever)
15:44:47 <phadej> it's also a sign if nothing is printed
15:44:48 <hololeap> it's ok. you said you are using a do block, which is syntactic sugar for monads, so you are "in a monad" by using "do"
15:44:57 <hpc> but you can also (in a do block) do things like x <- trace "foo" (some action returning x)
15:45:15 <fulaphex> `let cols = traceShow([row !! 2 | row <- board])` I expected that to print, it doesn't
15:45:23 <hpc> or let x = trace "foo" (some expression)
15:45:39 <hpc> fulaphex: make sure you're using cols
15:46:00 <fulaphex> trace won't evaluate cols?
15:46:00 <hpc> if you really want to be sure, https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Exception.html#v:evaluate is an option as well
15:46:20 <hololeap> haskell is lazy so it won't evaluate anything unless it is forced to
15:46:22 <hpc> er, at that point you'd just be using IO nvm
15:46:50 <fulaphex> hololeap: I know that part, my expectation was that printing would evaluate
15:46:58 <hpc> other way around
15:47:16 <hpc> evaluation makes printing happen, when you use trace
15:47:30 <fulaphex> oh
15:47:38 <fulaphex> that changes a lot
15:49:07 <hpc> this is another "we want lazy evaluation for yet more reasons" ;)
15:50:16 <hololeap> trace hangs a sign on the expression that says "print something when you evaluate me!"
15:51:38 <fulaphex> that's awesome to know, at least I know why it's not printing my stuff. next question - can I force evaluation of the variable without using it further in code?
15:52:13 <fulaphex> my thing is - I'm writing a function, I would want to see whether I botched it as I write it
15:52:21 <fulaphex> and not debug it after it's all written
15:52:42 <hololeap> you can use the `seq` function to do that, but technically `seq` forces evaluation of one expression when another expression is evaluated
15:54:33 <hololeap> fulaphex: probably the simplest way to do what you're looking for is import the function into ghci and play around with different inputs. you could also look into testing frameworks which aren't actually that bad
15:55:16 <fulaphex> hololeap: how would importing the function help me with printing the intermediate state?
15:55:42 <hpc> to get a feel for it
15:55:57 <hpc> what sorts of things print or don't print
15:56:52 <hololeap> i suppose it wouldn't unless you broke up the internals into smaller functions (in global scope) that you could play around with
15:57:14 <hololeap> it's usually best to break things up into nice easily testable parts and then compose them
15:57:39 <hololeap> the standard libraries have a lot of those little parts already defined if you know where to look
15:57:52 <fulaphex> how could I use seq to force the evaluation?
15:58:12 <ChaiTRex> fulaphex: To print the value of a variable in a do block that's not IO a, do { let x = trace "Hello" 5; return x } or do { x <- fmap (trace "Hello") whatever; return x }. Basically, you need the result to use that variable.
15:58:54 <ChaiTRex> fulaphex: Since it's returning x, which evaluates with a message to your screen, you can evaluate what it returns to get that message.
15:59:37 <fulaphex> ok, I think I might start to get the feel for that
15:59:40 <hololeap> it should be evaluating the internal parts when you evaluate the final answer
16:00:12 <fog> Hi, I created an example of mapping over a HTree
16:00:13 <fog> https://gist.github.com/fog-hs/d1b938938223a8fcfd02c6c8e2b8724b
16:00:14 <hololeap> seq is more useful for instance for when you need things to get evaluated in a specific order 
16:00:43 <fog> can anyone read that to comment on the approach?
16:01:15 <fulaphex> ChaiTRex: it might not be the prittiest, but I got it working attaching the trace to the return statement
16:01:34 <fog> the key type is;
16:01:35 <fog> data CFNodeTree (c :: k -> Constraint)(f :: k -> *) n (t :: Tree k) where 
16:01:42 <fog> data CFNodeTree (c :: k -> Constraint)(f :: k -> Type) n (t :: Tree k) where 
16:02:06 <ChaiTRex> fulaphex: Ahh, that works too :)
16:04:20 <fog> there is a problem trying to Traverse over this, so its just done more simply using Isomorphisms
16:21:40 <fulaphex> Couldn't match type ‚ÄòBool‚Äô with ‚ÄòMaybe Bool‚Äô - I'm struggling with this error. Shouldn't a Bool be a Maybe Bool?
16:22:10 <ChaiTRex> fulaphex: No, you'll need something to convert it, like the Just or pure functions.
16:22:50 <ChaiTRex> fulaphex: Haskell is pretty strict about keeping distinct types distinct, even when humans could figure out what you mean.
16:23:24 <fulaphex> can I type the variable as Just Bool?
16:23:31 <jle`> Just True or Just False would work, yeah
16:23:36 <jle`> fulaphex: Bool has two values -- False and True
16:23:37 <ChaiTRex> fulaphex: Yeah, Just x or Just True or whatever will work.
16:23:48 <jle`> fulaphex: Maybe Bool has three -- Nothing, Just False, and Just True
16:23:56 <jle`> so the two types are distinct
16:24:06 <fulaphex> jle`: yeah, but one is a subset of the other one
16:24:30 <jle`> fulaphex: sure, that's like saying Int is a subset of Double
16:24:31 <monochrom> "Just Bool" is mixing up types with terms.  What subset?
16:24:45 <hpc> not quite a subset
16:24:51 <hpc> Just False is different from False
16:24:56 <jle`> fulaphex: so maybe it's like saying "couldn't match type 'Int' with Double'"
16:25:01 <hpc> in the same way ["a string"] is different from "a string"
16:25:13 <fulaphex> hpc: that one sure
16:25:22 <fulaphex> but integer is a correct double
16:25:48 <ChaiTRex> fulaphex: Loosely, but Haskell hates loosely :)
16:25:48 <fulaphex> can I specify a Just Type?
16:25:51 <hpc> they're still different types
16:25:57 <jle`> fulaphex: do you understand why you can't use Integer when a function expects Double?
16:26:11 <monochrom> I would s/understand/accept/
16:26:25 <hpc> even if you take it as a given that integers and doubles can be the same, they're very different bitwise and in what cpu operations they require
16:26:36 <monochrom> Sometimes people know and understand, they just don't want to believe it.
16:26:38 <hpc> so even at the level where they are usually conflated, it's just an illusion
16:26:39 <jle`> yeah. same for Bool and Maybe Bool
16:26:51 <jle`> semantically there are similarities and you can think of them as subsets
16:27:00 <jle`> but representationally, etc., they can't relaly be thought of as such
16:27:01 <fulaphex> hpc: true, but it doesn't seem like haskell is low level enough so that user needs to care about bit representation
16:27:25 <monochrom> This is not about bit representation.
16:27:31 <jle`> fulaphex: the point is that they have different bit representations, so you can't really use them interchangeably
16:27:52 <jle`> that would mean things like ... implicit conversions or something
16:27:54 <hpc> it doesn't have to be about bit representation, the point is that 1 and 1.0 are completely different things
16:27:56 <jle`> gross :|
16:28:12 <hpc> there's no inherent relationship between Int and Double
16:28:18 <hpc> or between Bool and Maybe Bool
16:28:24 <ChaiTRex> jle`: I think they're talking about autoconversion to double when an int is presented as a double argument like in Java or whatever.
16:28:34 <fulaphex> any value of Bool is a correct value of Maybe Bool
16:29:01 <jle`> fulaphex: 'semantically' yes, just like how every Int represents a valid Double
16:29:04 <monochrom> Also I suggest focusing on Bool, Maybe, and algebraic data types, and no need to drag number systems into this.
16:29:08 <jle`> fulaphex: but that doesn't mean you should be able to use them interchangeably
16:29:19 <jle`> fulaphex: or that it would be meaingful to do so
16:29:31 <fulaphex> jle`: yes, I understand/agree that's the case
16:29:32 <jle`> at least, in an automatic way
16:30:03 <fulaphex> is there a type, that would be accepted by `Maybe Bool` that would have same values as `Bool`?
16:30:11 <fulaphex> `Just Bool` doesn't seem to work
16:30:28 <monochrom> No.
16:30:28 <jle`> fulaphex: usually we would just use 'Bool' for a type that has the same values as 'BOol'
16:30:48 <ChaiTRex> fulaphex: You need Just value, not Just Type. Just is a function that turns Bool into Maybe Bool.
16:30:51 <jle`> fulaphex: there isn't really a clean way to have a function take "either Maybe BOol or Bool" in an automatic way
16:31:01 <jle`> usually in haskell we like to be explicit with our data transformations
16:31:03 <ChaiTRex> :t Just
16:31:05 <lambdabot> a -> Maybe a
16:31:12 <jle`> so taking Maybe Bool and requiring the user to use Just :: Bool -> Maybe Bool is 'the haskell way'
16:31:18 <fulaphex> jle`: ok, that's the answer I was looking for
16:31:31 <jle`> in this case it helps because the user can now choose "which" way they want to turn a Bool into a Maybe Bool
16:31:38 <jle`> because just slapping on Just might not be the behavior they want
16:32:27 <jle`> for Bool this distinction is a little silly ... but think of something more complex like Maybe Int and Int :)
16:33:12 <fulaphex> I mean - I see some benefits to very strict type checking and no implicit anything
16:33:20 <monochrom> No, let's go to town and thinking of Int and Map [Char] (Seq Int)
16:33:53 <jle`> fulaphex: also remember that Maybe is a 'user-defined' type, without any special casing in the compiler
16:34:15 <jle`> unlike in some other languages
16:34:25 <fulaphex> jle`: ok, explains some stuff
16:34:42 <jle`> `data Maybe a = Nothing | Just a`, which lives in user-space
16:34:59 <jle`> so the compiler can't really do any special-case stuff with it since it's a normal user-defined data type
16:35:44 <fulaphex> yeah, I guess I'm still thinking about objects, inheritance and all those things
16:35:59 <fulaphex> which are not a thing in haskell
16:38:36 <dmwit> This... isn't really special to Haskell or functional programming, is it?
16:38:56 <dmwit> I mean, even in Java, a Foo and an Option<Foo> are pretty distinct. You can't pass one in place of the other.
16:39:13 <dmwit> There's some subtyping in the language, to be sure, but... not that.
16:42:00 <fulaphex> dmwit: I guess, I'm coming from python, which is a wild wild west, when it comes to typing
16:42:28 <fulaphex> and in python you can supply a Boolean to Optional[Boolean]
16:44:07 <jle`> i wasn't aware there was an Optional type in python :o
16:44:19 <jle`> and even if there was ... that's not saying much. in python you can supply an Int to Optional[Boolean]
16:45:25 <hpc> python's type system doesn't build up values the way haskell's does
16:45:42 <hpc> you start with the type of "this can be literally anything" and then narrow it down
16:45:57 <fulaphex> jle`: well, you can supply anything to anything, it's python, there is no strict typechecking
16:46:16 <fulaphex> but it's better than nothing
16:46:50 <jle`> fulaphex: what is 'nothing' here?
16:47:34 <fulaphex> python before type hints were introduced
16:47:36 <jle`> or ... is that a pun
16:47:57 <jle`> ah, i see
16:48:25 <hpc> a good way to see the difference between the type systems is Either
16:48:28 <fulaphex> but yeah, Maybe Bool /= Bool, now I know
16:48:32 <hpc> in haskell, say you have Either Bool Bool
16:48:43 <hpc> this has four possible values
16:49:08 <hpc> under a type system like python's, Either Bool Bool is the same as Bool
16:49:08 <jle`> my point was that the example doesn't really relate tooo much here because it's like saying "in python you can pass a Bool to a function expecting an Int", but you didn't really expect that in Haskell, right?
16:49:55 <fulaphex> well, not necessarily, mypy will complain if it detects you doing such nasty stuff
16:50:26 <fulaphex> I mean - I understand that haskell is much stricter, I'll just have to accept that and get used to it
16:51:19 <monochrom> No I don't think even python is that flexible.
16:52:08 <monochrom> Nor scheme. Nor lisp. Nor BASIC.
16:52:14 <monochrom> Nor Perl.
16:52:28 <monochrom> Nor bash.
16:54:05 <monochrom> Only by the time you get to asm you can get close because one single address that you fetch a machine int from is indistinguishable from one single address at the beginning of an array of multiple machine ints.
16:55:26 <bitmapper> what
16:55:27 <bitmapper> NEW: Miranda‚Ñ¢ source release version 2.057 of 8 December 2019
16:55:47 <bitmapper> there's even comments about macos catalina support
16:55:54 <hololeap> :% fmap @Maybe
16:55:58 <hololeap> % fmap @Maybe
16:55:58 <yahb> hololeap: ; <interactive>:122:1: error:; * No instance for (Show ((a0 -> b0) -> Maybe a0 -> Maybe b0)) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
16:56:02 <monochrom> Their way of saying "Merry Christmas and Happy New Year" :)
16:56:39 <hololeap> % :t fmap @Maybe @Bool
16:56:40 <yahb> hololeap: (Bool -> b) -> Maybe Bool -> Maybe b
16:57:09 <hololeap> fulaphex: you can use fmap to lift a function (Bool -> b) to (Maybe Bool -> Maybe b)
16:57:20 <hololeap> just as an aside :)
16:59:17 <fulaphex> that's a cool one, thanks
17:03:42 <hololeap> fmap is from the Functor typeclass (which Maybe is an instance of), and is the gateway to Monads and all that fun stuff :)
17:04:46 <monochrom> Don't forget Foldable and Traversable.
17:16:36 <int-e> @hoogle (a -> b -> c) -> c -> c -> [a] -> [b] -> [c]
17:16:37 <lambdabot> No results found
17:16:38 <int-e> :/
17:17:16 <MarcelineVQ> oh I‚Äã get it
17:18:18 <hololeap> fulaphex: at some point you will really want to read https://wiki.haskell.org/Typeclassopedia
17:18:57 <int-e> Oh, I'm stupid, that's not what I want...
17:19:12 <MarcelineVQ> did you want a -> c and b -> c ?
17:19:27 <fulaphex> oh god, that's super long. right now I'm going through learn you a haskell and implementing something for myself, but that might be an idea for the future
17:19:50 <int-e> MarcelineVQ: yeah, or possibly [a] -> [c] and [b] -> [c]
17:20:37 <LevyElara[m]> fulaphex: you can read it on and off as you go through LYAH to match the sections there
17:21:00 <LevyElara[m]> It will clear future pain
17:21:38 <hololeap> fulaphex: it is long, but it starts out with the basics (Functor) and builds from there. reading and comprehending the whole thing will open a whole new world of haskell and you will no longer wonder why people love it
17:22:11 <fulaphex> ok, thanks for pointing that way then
17:22:21 <fulaphex> I'll know what I'll be doing during xmas
17:22:29 <hololeap> but yeah... "There is no royal road to Haskell" lol
17:22:29 <int-e> (but of course(?) hoogle still doesn't find anything)
17:23:12 <int-e> There is no road to Haskell. It's a hyperdimensional mess of twisted paths.
17:23:32 <LevyElara[m]> hololeap: It's only down the rabbit hole from there
17:23:50 <int-e> . o O ( It's rabbit holes all the way down. )
17:25:15 <LevyElara[m]> with barbed wire
17:28:15 <MarcelineVQ> notably the barbs only catch when you try to back out
17:31:05 <hololeap> something something lenses bananas
17:37:18 <gaze__> hey what's the right way to parse something that has some nested open/close symbol?
17:37:27 <gaze__> using megaparsec
17:37:38 <gaze__> in other words key = {value {value} {{value}}}
17:37:51 <gaze__> mapping to ["key","value {value} {{value}}"]
17:45:29 <monochrom> Use recursion.
17:57:59 <suzu> use recursion or a stack
18:10:07 <fog> int-e: but its stabilised 
18:10:56 <fog> so, I have the setup here;
18:10:56 <fog> https://gist.github.com/fog-hs/d1b938938223a8fcfd02c6c8e2b8724b
18:11:06 <fog> for mapping over my HS and LHS files
18:11:14 <fog> so now what options are there?
18:11:35 <fog> can I use some library to parse the comments or do I have to write this myself?
18:11:47 <fog> like, is it all internal to GHC and impossible to hack at
18:12:08 <fog> or is there some nice way to parse haskell files, eg to translate between hs and lhs
18:12:31 <fog> or to write something like browse or something like a simple IDE using a show instance
18:13:11 <fog> basically I think i want to check to see which versions have the same implementations of a function, or of all the implementations of a function of the same name and type, which are equivalent
18:13:41 <fog> i guess I will have to just read them because using a proof assistant might be overkill at this point
18:14:07 <fog> really I want to greatly reduce the amount of code I have by factoring the common code into a library
18:14:26 <fog> and getting benchmarks or quickchecks or something to test to see if the code does what its supposed too
18:14:57 <fog> are there available libs on hackage that could help with this?
18:16:11 <fog> also, any comments on the style of the code would be appreciated, I guess there is a way to do it without using HTrees...
21:00:55 <pounce> so in Data.Map is `toAscList` always O(n)? i.e. does `snd . head . toAscList $ m` take time proportional to the number of items in `m` or is it a list of thunks which depends on how many i consume
21:03:49 <MarcelineVQ> afaik the latter
21:04:23 <pounce> even with Data.Map.Strict?
21:04:26 <MarcelineVQ> depends a little I think on whether you've Data.Map.Lazy
21:04:37 <pounce> ah
21:05:57 <MarcelineVQ> I'm not sure how to test just toAscList come to think of it.  lazy is fine with   head $ toAscList (fromList [(5,undefined), (3,"b")])  strict hits the undefined, but it's doing so when making the Map in the first place
21:32:35 <dmwit> MarcelineVQ: That's asking the wrong question of GHC anyway.
21:33:14 <dmwit> You want to ask whether it's looking at the rest of the spine, which it might do even if it doesn't look at all the values.
21:33:37 <dmwit> I think for this it's timing measurements or read the code.
21:34:30 <dmwit> Since I believe the API does not offer a way to build only a partial spine.
22:04:57 <slack1256> I got a TChan which I would like to filter so it only emits distincts elements. I could write the filter myself but I am sure there must be a package for it.
22:05:15 <slack1256> Does anybody know about it?
22:20:45 <dsal> depends on what you mean by distinct?  Never emits the same thing twice in a row?  Twice during its lifetime?  Twice during the process' lifetime?  Twice during the universe's lifetime?
