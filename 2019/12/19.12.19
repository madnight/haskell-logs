00:07:45 <amalloy> iqubic: not personal, really. after the first two years, i've quit mid-year every year. i think i just run out of appetite for the puzzles
00:08:20 <amalloy> some of it is that they get longer over the month and i don't want to work on a puzzle for all that long, but i think it's also just like, enough puzzles
00:18:37 <jusss> cont $ \out -> out "hello" ++ out "hello"   without parenthesis, I don't know how to understand it
00:18:52 <jusss> it's cont $ \out -> (out "hello" ++ out "hello") ?
00:19:15 <jusss> cont $ \out -> out ("hello" ++ out "hello")
00:22:12 <iqubic> the first one is correct.
00:22:34 <iqubic> cont $ \out -> (out ("hello") ++ out ("hello"))
00:22:51 <dminuoso_> Haha, Im starting to think that `Device { foo = bar, baz <- quux, tut = tat }` would be nice syntax.
00:22:58 <iqubic> More parentheses added for clarity.
00:24:41 <jusss> https://paste.ubuntu.com/p/dgbHQVYkYT/
00:24:53 <jusss> why the result is 2hello2hello, not 2hellohello?
00:26:29 <day> amalloy: yeah that puts me off too. every second day is part of a multiday challenge
00:31:30 <olligobber> jusss, out "hello" ++ out "hello" = (out "hello") ++ (out "hello")
00:31:52 <koz_> such parse, very precedence, amaze
00:32:22 <olligobber> operators like ++ take precedence over simple function application
00:32:40 * koz_ slinks off in shame.
00:33:46 <bahamas> if you're familiar with streamly, what's the difference between merging two streams and nesting them? in both cases, it seems you end up with a stream that is a combination of both input streams
00:33:47 <olligobber> koz_, wow
00:34:11 <koz_> olligobber: ALL MY LIFE I HAVE WAITED FOR THIS
00:34:12 <koz_> :P
00:34:30 <koz_> bahamas: Sorry, what do you mean by 'merging' and 'nesting' in this case?
00:34:35 * koz_ is somewhat familiar with streamly.
00:35:17 <bahamas> koz_: as they are used in the tutorial here: https://hackage.haskell.org/package/streamly-0.7.0/docs/Streamly-Tutorial.html. basically, merging is a semigroup operation and nesting a monadic one, if I understand
00:35:23 <jusss> I hope there's good article about Cont...
00:35:33 <jusss> I really hate this I can't understand...
00:35:50 <koz_> bahamas: With the semigroup merge, it depends what kind of stream it is.
00:36:10 <koz_> With a non-W stream, it's concatenation, with a W-stream, it's kinda zip.
00:36:41 <koz_> https://hackage.haskell.org/package/streamly-0.7.0/docs/Streamly-Tutorial.html#g:11 <-- this has all the details, but my summary is more-or-less the gist of it
00:37:08 <bahamas> koz_: yes, I understand that part
00:37:11 <koz_> There's some technicalities around Serial versus Ahead versus Async versus Parallel, but that's the gist.
00:37:13 <bahamas> I mean, what you said so far
00:38:00 <bahamas> koz_: ok, I can see a difference. with merging, you have width first strategy available for Ahead and Async. with nesting you don't
00:38:03 <koz_> Ah, OK. So it's the whole 'how is merge different to that' that you're not sure about?
00:38:33 <bahamas> koz_: yes, how is merging different from nesting
00:38:45 <koz_> The easiest way to imagine nesting is as a nested loop.
00:38:56 <koz_> So if you nest (say, Serial) streams, it's like having a stream of streams.
00:39:08 <koz_> Key sentence is: Notice that this is analogous to merging streams of type Serial or merging streams using serial.
00:39:17 <koz_> So for Serial specifically, it's the same.
00:39:22 <bahamas> koz_: right, so when you generate the second stream you can use values from the first. with nesting that is. with merging you can't do that, right?
00:39:50 <koz_> bahamas: Yes, I believe so, near as I can determine.
00:39:59 <koz_> In the Serial case specifically, they are extremely similar.
00:40:44 <bahamas> indeed
00:40:47 <koz_> I must admit I haven't really looked into the monadic behaviour of streamly streams before, so this is kinda new to me too.
00:41:28 <koz_> But your description seems right based on what I can see.
00:41:34 <bahamas> koz_: I haven't written concurrent programs before, but this library seems very powerful
00:41:42 <jonge[m]> hi there. If i have a tuple `(U, V, W)` and U, V, W are all of typeclass Y and i have a function `f :: Y a => a -> Z` and  want to apply this function `f` to the tuple to get a list of Zs that i can further fold down to something else - is there a way to `iterate` this tuple like a list to do this?
00:41:44 <koz_> It's pretty darn amazing.
00:42:36 <bahamas> koz_: btw, I have something else I don't know. what does bounded and unbounded mean in the context of concurrency? async is bounded while parallel is unbounded
00:42:47 * koz_ goes and reads.
00:43:34 <bahamas> the terms aren't explained explicitly on the tutorial page
00:45:06 <koz_> The terms don't even _appear_ on the tutorial page as far as I can see - where did you see them described in this way?
00:45:50 <bahamas> koz_: there's a matrix with the 4 types: Serial, Ahead, Async, Parallel near the top. 
00:46:32 <bahamas> where they're described in terms of Execution, Consumption and Concurrency
00:46:40 <koz_> Ah, I see.
00:46:47 * koz_ was looking in the wrong place, derp.
00:46:57 <bahamas> no worries :)
00:48:02 <koz_> I'm not entirely sure - this is probably something to report to Harendra.
00:48:06 <koz_> (in a Github issue)
00:48:18 <koz_> I can guess sorta-kinda, but I'd rather not.
00:48:24 <koz_> (don't wanna give you bad info)
00:48:46 <koz_> https://github.com/composewell/streamly/issues
00:49:39 <koz_> He's pretty responsive to documentation issues, and I agree that it's not entirely clear (at least, not to me).
00:49:53 <koz_> It's _especially_ odd that _all the other_ vocab used in that matrix _is_ explained.
00:50:39 <cdunklau> jonge[m]: maybe just write the thing?   splat :: (Y a) => (a, a, a) -> [a, a, a]
00:51:09 <jonge[m]> cdunklau: yes, but for tuples of any size?
00:51:20 <koz_> jonge[m]: I don't think this is easily possible in Haskell.
00:51:25 <cdunklau> jonge[m]: lenses
00:51:36 <jonge[m]> lenses could do it?
00:51:40 <koz_> If you want a 'a collection of a of arbitrary size' you want a vector, probably.
00:51:43 <bahamas> koz_: alright. thanks
00:51:54 <koz_> bahamas: No worries - helped me learn a thing or two.
00:51:55 <cdunklau> jonge[m]: i've come across them in my googling about your problem (i'm quite new)
00:52:12 <koz_> (amusingly, I've actually written a streamly-adjacent library)
00:52:41 <koz_> jonge[m]: I would argue that if you want 'a tuple of any size', you want a vector.
00:52:49 <koz_> This isn't Python.
00:53:01 <cdunklau> koz_: lies, of course this is python
00:53:04 <cdunklau> it has list comps
00:53:12 <koz_> (especially if they're type-homogenous)
00:53:19 * koz_ laughs in Prolog.
00:53:22 <jonge[m]> <koz_ "jonge: I would argue that if you"> but i can't store items of different types (but same typeclass) in vectors
00:53:27 <cdunklau> (this is a bad thing to do in python too)
00:53:56 <cdunklau> yay hackage is borked
00:54:02 <cdunklau> PR_END_OF_FILE_ERROR
00:54:32 <koz_> jonge[m]: You can't refer to a tuple of arbitrary size where everything is an instance of a type class either.
00:54:46 <bahamas> koz_: I have the feeling that streamly could be used for a lot of stuff. I don't know how performant ghcjs is but I could it see it being used like React for example
00:54:50 <koz_> Even a concept like 'tuple of arbitrary size' isn't something you can state in Haskell without being super-awkward.
00:55:05 <koz_> bahamas: It is quite deliberately designed with reactive programming in mind.
00:55:23 <koz_> (although it lacks a whole bunch of IO-adjacent stuff in its core modules AFAICT)
00:55:31 <koz_> (that's what led me to write streamly-fsnotify)
00:57:44 <bahamas> I see
00:58:16 <koz_> Like, all the necessary bits and pieces _are_ there, someone just has to write a lot of the glue stuff and package it into nice libraries like how pipes and conduit have it.
00:58:24 <koz_> (which I am actually more than a little bit tempted to do)
00:59:41 <koz_> Like, the actual code to do it is pretty easy: https://hackage.haskell.org/package/streamly-fsnotify-1.0.0.0/candidate/docs/src/Streamly.FSNotify.html#watch
01:00:14 <koz_> There's a bit of munging going on there, but the overall code should be pretty clear.
01:04:39 <bahamas> yes, I realize that the logic needs to be expressed using the streamly combinators
01:07:12 <koz_> I'm very tempted to write streamly-sqlite next. :P
01:09:03 <Mrbuck> hi #haskell
01:10:36 <koz_> Mrbuck: Wazzup?
01:11:07 <maerwald> koz_: with cursors? lol
01:11:14 <Mrbuck> hello koz_  nothing much. 
01:11:43 <koz_> maerwald: Lololol.
01:11:51 <Mrbuck> The Algorithms classes which I never used to understand for years...looking so easy all of a sudden
01:11:52 <koz_> No, something far more principled.
01:12:07 <koz_> (which I have to come up with first, fml)
01:12:46 <maerwald> (I have this amazing idea... I just don't know it yet)
01:15:18 <Mrbuck> So now I understand with proper Algorithemic thinking we can write haskell faster than c++ or eve c
01:15:20 <koz_> (the margin isn't big enough to contain it)
01:40:57 <bahamas> koz_: I found out what bounded and unbounded mean. the words refer to the number of threads available. async is bounded and uses a thread pool, while parallel creates as many threads as possible
01:41:13 <koz_> bahamas: Oh, cool. Thanks!
01:41:27 <bahamas> you're welcome!
01:42:59 <merijn> bahamas: Wait, since when does async use a thread pool
01:43:05 <merijn> Last I checked it didn't
01:43:12 <bahamas> merijn: I'm referring to streamly's async
01:43:31 <merijn> Ah
01:44:10 <tdammers> Mrbuck: the performance of the fastest implementation of a given program you can write in a given language is rarely an interesting metric in practice. what you are interested in is a cost/benefit calculation: what is the implementation cost and organizational liability of an implementation of the given program in the given language that performs adequately
01:45:05 <tdammers> so not: "how fast can we possibly make this given unlimited time and manpower", but "how much time and manpower do we need to invest to make this fast enough, and how ugly do we have to make it"
01:46:02 <Mrbuck> cost-benefit calculation in enlighting
01:46:06 <tdammers> in many cases, "about 2-5 times slower than heavily optimized C" is plenty, and naively written idiomatic Haskell can often get there without any specific effort spent on performance
01:46:24 <tdammers> and the resulting code is going to be cleaner and more maintainable than a C version that performs similarly
01:46:40 <merijn> Not to mention if you really *do* need C, it's easy to plug low level C stuff into Haskell
01:46:45 <tdammers> that, too
01:47:06 <merijn> IMO Haskell is a better glue language than Python
01:47:07 <tdammers> though you have to give up some conveniences for that, especially when you want to build for more than one target platform
01:47:17 <tdammers> but that is par for the course for C bindings
01:47:22 <tdammers> regardless of host language
01:47:37 <tdammers> merijn: well, duh, that's because Haskell is a better language than Python ;)
01:49:31 <Mrbuck> what do you mean by glue?
01:49:48 <tdammers> glue together the C code that does the heavy lifting
01:50:00 <tdammers> it's a common term in "modern" software dev
01:50:03 <merijn> Mrbuck: as in "tying code from (multiple) different libraries/languages together"
01:50:25 <tdammers> rather than write all the functionality yourself, you just find a bunch of libraries that cover various aspects of the problem, and then you write just enough code to make them work together
01:50:28 <tdammers> you "glue them together"
01:50:39 <tdammers> and the code that does that is your "glue code"
01:50:55 <tdammers> it doesn't do anything specific itself, it just holds your libraries together
01:51:17 <Mrbuck> thats nice
02:42:23 <boxscape> huh strange that you can't use partial type signatures in instance sigs
02:43:22 <merijn> ugh...why is GHC calling the C compiler with -Werror >.<
02:57:48 <dminuoso_> Why do you produce warnings?! 
03:40:22 <yasar> Is there a tutorial somewhere that demonstrates how to use this module? http://hackage.haskell.org/package/threads-pool-0.1/docs/Control-Concurrent-Pool.html
03:40:31 <yasar> I can't find any
03:49:19 <yasar> Anyone has any experience using `ghcid` ? I am using VS Code with hslint extension, is it a replacement for hslint or should I be using them side by side?
03:54:53 <fendor> yasar, i think you can run it side by side
04:01:52 <__monty__> It's not a replacement.
04:02:02 <__monty__> Ghcid just does type checking.
04:10:10 <yasar> I am seeing characters like "←[;1m" in ghcid output (using windows). Is there a way to fix that?
04:11:09 <hpc> those look like bash colors
04:12:29 <yasar> I tried it with Git Bash also, but still not working
04:14:55 <yasar> putting "--color=never" to ".ghcid" file worked
04:16:10 <__monty__> yasar: Ah, good. There's something in my logs about running it in git bash using `winpty ghcid`.
04:17:47 <yasar> I just discovered this today : https://typeclasses.com/
04:17:52 <yasar> looks very promising
04:19:19 <yasar> pharasebook looks like a good walkthrough :https://typeclasses.com/phrasebook
04:36:26 <boxscape> Is there a way to make this work? I don't fully understand why it complains even though the type sigs are identical. In the real application, I cannot make the type family injective. https://gist.github.com/JakobBruenker/69f99a23138169a6221d06b5028167f8
04:36:41 <boxscape> Maybe there's a way to get access to t inside the method body without the full instance sig?
04:43:05 <boxscape> Actually don't even need the type family to get this error, I've simplified the example
04:53:11 <boxscape> It seems like this would be trivial if the proposal were implemented that allows you to use type application to bind type vars like `f @t a = ...`
04:53:35 <boxscape> still, it seems like there *must* be a way to write the instance type signature here, no?
05:13:27 <yasar> when I declare `z = a:b:c:d:[]` , will haskell incrementally create and destroy lists to calculat `z` ?
05:14:00 <merijn> yasar: Which list would need to be destroyed?
05:14:55 <yasar> since (:) is a function, (a:b:c:d:[]) is 4 function calls, but we only keep the result from last function call
05:15:44 <merijn> yasar: Even if we use the perspective then the result from the "last" one still uses the result of the 2nd to last, so nothing gets destroyed
05:16:46 <yasar> So, it keeps a pointer instead of creating new lists at each application of (:) ?
05:17:37 <merijn> Yes, no, maybe. Depending on your definition of "pointer", "creation" and whether we're talking about the meaning of code or the operational details of how it gets computed
05:18:44 <yasar> merjin, I am trying to imagine how it would be converted to C code in the end
05:19:42 <merijn> Personally I think it's not very helpful to think about how things could/would be converted to C, tbh
05:20:22 <Arahael> C isn't even /that/ close to the machine anymore.
05:21:01 <Arahael> Heck, casting between different types of pointers is now Undefined Behaviour.  I dont' think it used to be long ago.
05:21:11 <boxscape> Personally I've found thinking about how it gets converted to STG somewhat helpful
05:21:44 <kosmikus> on evaluating z, you wouldn't expect anything to be destroyed here. it's just allocating a linked list. what makes this tricky though is that ultimately it very much depends on how z is consumed. the list might not be evaluated all in one step, or parts of the list could be removed again while consuming it (streaming), or ...
05:22:13 <merijn> boxscape: STG is not similar to C, though ;)
05:22:30 <boxscape> yeah, I wasn't trying to imply that :)
05:23:11 <boxscape> my comment was more an addition than an objection
05:46:52 <boxscape> Hm, if I have a type family that takes a `t :: Type -> Type -> Type`, and I want to give it something like `\v k -> [] v`, is there an easier way to do this than to pull in singletons and use their defunctionalization mechanism along with the defunctionalized Const function?
05:47:06 <boxscape> (or Const type family, as it were)
05:47:27 <boxscape> (note that this lambda is supposed to be a type-level lambda)
05:55:22 <yasar> What does this function supposed to do? https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Foldable.html#v:asum
05:55:33 <__monty__> yasar: You could also think about how the immutability means you don't have to destroy or copy the smaller lists. The head of the longest one can just point at the next longest one.
05:57:17 <[exa]> yasar: basically folding with <|>
05:58:33 <[exa]> yasar: (i.e. takes the first non-failed-like thing from a foldable "container")
06:13:23 <Amras> abs's type signature continues to frustrate me
06:13:49 <merijn> :t abs
06:13:51 <lambdabot> Num a => a -> a
06:13:57 <merijn> Amras: Why's that?
06:14:10 <Amras> `(abs (a-b)) < (realToFrac 0.1)` - rationally this should work whether a and b are real or complex
06:14:27 <Amras> but complex isn't ord, so abs (a-b) isn't Ord
06:14:54 <merijn> I'm not really sure what that has to do with abs?
06:15:02 <merijn> Seems more like an issue with < then
06:15:28 <Amras> not really; it makes sense that < only works for ords
06:15:42 <Amras> abs should be able to take a complex value and spit out a real one
06:15:47 <merijn> Why?
06:15:52 <merijn> What would that do/mean?
06:16:23 <merijn> I don't see why "turn Complex into a Real" should be part of the definition of abs?
06:18:24 <Amras> how would you suggest coercing the result of abs here?
06:18:53 <tdammers> :t abs
06:18:55 <lambdabot> Num a => a -> a
06:19:22 <tdammers> I think the general notion is that the absolute value of something is the same type as the original thing
06:19:37 <tdammers> which holds true for integers, floats, etc.
06:19:39 <merijn> realPart (abs (a-b)) ?
06:19:43 <Amras> :t realPart
06:19:45 <lambdabot> Complex a -> a
06:19:57 <Amras> that won't work for abs on a real
06:20:07 <Amras> ie. if a,b are real
06:20:57 <tdammers> "For a complex number z, abs z is a number with the magnitude of z, but oriented in the positive real direction, whereas signum z has the phase of z, but unit magnitude."
06:21:13 <Amras> huh
06:21:20 <Amras> ok, I haven't come across that definition
06:21:32 <tdammers> if a is a real number represented as a complex number where the imaginary part is 0, then it just performs abs on the real part
06:21:40 <tdammers> but the result is still a Complex, not a real
06:21:46 <tdammers> hence the realPart
06:22:16 <tdammers> https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Complex.html, fwiw
06:22:45 <tdammers> wikipedia seems to agree
06:23:09 <merijn> Ugh
06:23:10 <Amras> :t (realPart $ abs (realToFrac a - realToFrac b) < (realToFrac 0.1)
06:23:13 <lambdabot> error:
06:23:13 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
06:23:21 <tdammers> The absolute value (or modulus or magnitude) of a complex number z = x + yi is r = |z| = √x²+y²
06:23:23 <merijn> for some reason cabal-install or GHC is setting -Werror before compiling C code
06:23:32 <Amras> :t realPart $ abs (realToFrac a - realToFrac b) < (realToFrac 0.1)
06:23:34 <lambdabot> error:
06:23:34 <lambdabot>     • Couldn't match expected type ‘Complex a’ with actual type ‘Bool’
06:23:34 <lambdabot>     • In the second argument of ‘($)’, namely
06:23:36 <merijn> And I can't figure out how the hell to make it stop
06:23:39 <yushyin> :t magnitude
06:23:42 <lambdabot> RealFloat a => Complex a -> a
06:23:54 <Amras> :t (realPart $ abs (realToFrac a - realToFrac b)) < (realToFrac 0.1)
06:23:55 <lambdabot> Bool
06:24:13 <merijn> :ls
06:24:22 <Amras> :t \(a, b) -> (realPart $ abs (realToFrac a - realToFrac b)) < (realToFrac 0.1)
06:24:23 <lambdabot> (Real a1, Real a2) => (a1, a2) -> Bool
06:24:25 <Amras> there we go
06:28:27 <Amras> yushyin, that's still got the issue of only accepting complex and not reals
06:32:19 <yushyin> Amras: yeah, just wanted to see the type signature of it.
06:32:29 <tdammers> I don't understand what the problem is
06:32:50 <tdammers> if you want the abs of a Complex, you get a Complex, and you can take the real part from it to get rid of the imaginary 0
06:33:04 <tdammers> if you want the abs of a real, you just call abs on it, no?
06:39:00 <boxscape> tdammers I think the idea is to have one polymorphic expression that works with both Complex and real numbers
06:43:11 <merijn> boxscape: Sure, I get that that's the idea, but you can't
06:43:19 <merijn> Because the two are doing fundamentally different things
06:44:55 <boxscape> well, you could if you used a `class ToRational a where toRational :: a -> Rational`, or something along those lines
06:45:57 <boxscape> Perhaps other names would be better
06:46:22 <boxscape> but the point is, there are mathematical formulas that use abs for reals and magnitude for complex numbers, and it might be nice to have that sometimes
06:47:15 <boxscape> s/names/names and types
06:47:28 <merijn> boxscape: Sure, but the question is "at what cost?" :)
06:47:32 <boxscape> fair
06:48:09 <merijn> Man...I really need more excuses to use SQLite at work, the more I plan with the more complex innards, the cooler this stuff gets :>
06:48:41 <dminuoso_> Mmm, is there a way to turn a strict map into a lazy one other than going through a list?
06:48:58 <merijn> dminuoso_: They're literally the same datatype
06:49:09 <merijn> dminuoso_: Map.Lazy and Map.Strict only differ in the exported functions
06:49:11 <dminuoso_> merijn: Oh!
06:49:22 <dminuoso_> merijn: Cheers, didn't know that. :)
06:49:39 <merijn> Wait, shit, I take it back. I should've been wittier and replied "id"
06:49:47 <dminuoso_> Heh
06:53:58 <boxscape> unsafeCoerce ;)
06:55:59 <merijn> Also, reminder for anyone close to the Netherlands that registration for NL-FP closes tomorrow!
06:56:28 <dminuoso_> merijn: Is NL-FP held in Dutch?
06:56:33 <merijn> dminuoso_: No, English
06:56:49 <merijn> dminuoso_: Athas is coming to present on Futhark :)
06:57:09 <dminuoso_> merijn: What is his name?
06:57:13 <dminuoso_> Or, their, rather.
06:58:22 <dminuoso_> Mmm
06:58:29 <dminuoso_> Any ticket prices?
06:59:06 <merijn> No, registration is free, there's a networking/hang out dinner afterwards which is basically at your own cost
06:59:21 <merijn> dminuoso_: https://sites.google.com/view/nl-fp-day-2020/home
06:59:52 <merijn> Athas: Looks like we'll have a SaC talk too :)
06:59:53 <dminuoso_> I think I might actually make it then!
07:03:10 <dminuoso_> Signed up, now lets see whether I can make anyone pay for that trip here. :)
07:05:24 <Athas> merijn: yes, on tensor contractions.  Sounds good to me.
07:18:20 <boxscape> oh no, I thought I might've just found a workaround for my issue of not being able to write that instance signature, but turns out I only shifted it to the callsite -.-
07:20:26 <boxscape> or actually it might be fine since at the callsite, I *can* use ScopedTypeVariables
07:21:58 <merijn> boxscape: You can use InstanceSigs to write, well, instance signatures? :p
07:22:07 <boxscape> https://gist.github.com/JakobBruenker/69f99a23138169a6221d06b5028167f8
07:22:18 <boxscape> I can't manage to write this one, merijn
07:22:59 <merijn> CursedExtensions
07:23:15 <merijn> That class also seems rather weird
07:23:17 <boxscape> hehe I didn't bother deleting the ones that are made superfluous by minimizing the example
07:23:29 <boxscape> merijn it's just the simplest example I could think of for a more complex use case
07:23:36 <boxscape> that still shows the same issue
07:24:42 <boxscape> s/for/instead of
07:26:02 <boxscape> really curious if this will work (without instance sig) once https://github.com/ghc-proposals/ghc-proposals/pull/155 is implemented
07:26:12 <boxscape> until then, I've resorted to adding t as parameter to the class
07:26:34 <merijn> Or add Proxy t to the method
07:26:47 <dmwit> s/P/p/ ;-)
07:26:48 <boxscape> oh yeah I suppose I could do that
07:26:56 <boxscape> thanks :)
07:26:59 <merijn> method :: Storable t => proxy t -> Int
07:27:09 <merijn> Yeah, follow dmwit's comment and use proxy, not Proxy
07:27:13 <boxscape> right
07:27:42 <dmwit> That way I can make people mad and call it like `method [()]`.
07:27:53 <geekosaur> heh
07:27:55 <boxscape> oh boy
07:28:12 <geekosaur> `method Nothing`
07:28:29 <geekosaur> (I don't think that quite flies :p  )
07:28:29 <dmwit> or `method "the String instance, please"` to really get people riled up
07:28:48 <Taneb> dmwit: I love it
07:28:53 <dmwit> (it's subtle, isn't it?)
07:29:04 <merijn> dmwit: That'd be the Char instance, though
07:29:05 <boxscape> wouldn't that be the Char instance?
07:29:10 <dmwit> merijn: it's subtle, isn't it?
07:29:18 <boxscape> hmm
07:29:27 <dmwit> and it is WORKING
07:29:37 <geekosaur> o rile-y?
07:29:48 <dmwit> ya riley
07:32:24 <Taneb> method ("Should I use the Bool instance?", False)
07:33:46 <dmwit> ^_^_^
07:36:32 <Taneb> ...method fromEnum
07:37:46 <boxscape> method getChar
07:39:27 <boxscape> % method getChar
07:39:27 <yahb> boxscape: 4
07:39:42 <Taneb> % method fromEnum
07:39:42 <yahb> Taneb: ; <interactive>:49:8: error:; * Ambiguous type variable `a0' arising from a use of `fromEnum'; prevents the constraint `(Enum a0)' from being solved.; Probable fix: use a type annotation to specify what `a0' should be.; These potential instances exist:; instance Enum (Fixed a) -- Defined in `Data.Fixed'; instance forall a k (b :: k). Enum a => Enum (Const a b) -- Def
07:39:47 <Taneb> :(
07:39:51 <boxscape> :t fromEnum
07:39:53 <lambdabot> Enum a => a -> Int
07:40:19 <Taneb> I thought that would default to () -> Int
07:40:24 <boxscape> % method (fromEnum :: () -> Int)
07:40:24 <yahb> boxscape: 8
07:40:38 <boxscape> I suppose Enum is not part of the ExtendedDefaultRules
07:40:51 <geekosaur> there are limits, yes
07:41:12 <Taneb> Aargh, it's default (Integer, Double) by default, not default ((), Integer, Double)
07:41:34 <geekosaur> but I think it's ((->) a) that isn't part of it, so it can't default Enum through it
07:41:37 <Taneb> I guess that would get really confusing if someone defines instance Num ()
07:41:37 <boxscape> I do believe () is part of it in ghci taneb
07:41:54 <geekosaur> it's part of ExtendedDefaultRules and therefore ghci
07:42:25 <boxscape> any numeric class, Show, Eq, Ord, Foldable or Traversable
07:42:27 <geekosaur> () is, that is
07:42:35 <boxscape> those are the ExtendedDefaultRules classes
07:42:41 <Taneb> I'd misremembered how that stuff all worked
07:43:00 <geekosaur> ok, so no Enum, I thought there was a more flexible rule tuned to allow the more common single parameter classes
07:43:03 <Taneb> It's so rare that I ever need to think about it
07:43:55 * geekosaur doesn't really like ExtendedDefaultRules, it's begging for unexpected interpretations
07:44:01 <boxscape> yeah
07:44:43 <dmwit> % method toInteger
07:44:44 <yahb> dmwit: ; <interactive>:53:1: error:; * No instance for (Storable Integer) arising from a use of `method'; * In the expression: method toInteger; In an equation for `it': it = method toInteger
07:44:50 <dmwit> ...fair
07:45:09 <dmwit> % method length
07:45:10 <yahb> dmwit: 8
07:45:12 <dmwit> yay
07:45:14 <Taneb> % method fromRational
07:45:15 <yahb> Taneb: 8
07:47:34 <geekosaur> I meant Functor earlier when I cited the ((->) a) instance of it. feh.
07:50:25 <aplainzetakind> Can functions be memoized?
07:50:38 <p0lyph3m>  /window split 50%
07:51:07 <boxscape> yes, if you do it yourself or use a library to do it, aplainzetakind
07:51:09 <boxscape> see https://hackage.haskell.org/package/memoize
07:51:30 <aplainzetakind> I have f :: [Int] -> [Int]. I want to do a search over possible inputs of f, breadth first. If I define f' ys xs = drop (length ys) $ f (ys ++ xs) in a let block, would it do the job, for instance?
07:53:38 <dminuoso_> aplainzetakind: Look into MemoTries :)
07:53:48 <dminuoso_> https://hackage.haskell.org/package/MemoTrie
07:55:22 <aplainzetakind> boxscape, dminuoso_: Thanks.
08:01:28 <ski> @where impossible
08:01:28 <lambdabot> <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>,<http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
08:25:46 <hseg> Hi. Have three formulas for computing the same calculation, would like to test they are consistent. Recommendations?
08:27:35 <solonarv> hseg: quickcheck!
08:27:46 <hseg> (test space blows up exponentially, so probably combination of small inputs + random inputs desirable)
08:28:03 <hseg> OK, tutorial recommendations?
08:28:51 <orzo> Hey, is there a cabal/ghc option to prefer a fast compile over an optimized one?  I normally build with optimization, but for devel purposes, I'd like to occassionally build some changes without optimizations for speedy feedback.  The problem is that --enable-optimizations wants to globally enable and forces the rebuild of a lot of code which defeates the whole point of disabling optimizations.
08:29:16 <orzo> I would like it to use the optimized builds oportunistically, but anything that needs rebuilding, switch to fast build
08:29:17 <heatsink> smallcheck does exhaustive checking on small inputs
08:29:55 <maerwald> orzo: you can disable optimisation of the current package (excluding the dependencies)
08:30:00 <maerwald> in cabal.project
08:30:23 <hseg> Great -- could you give me some pointers to get started?
08:30:55 <heatsink> hseg, Here's an intro to quickcheck https://www.fpcomplete.com/blog/2017/01/quickcheck
08:31:35 <hseg> OK, thanks!
08:35:09 <orzo> maerwald: that's better than nothing.  I found "optimization: nat" in the cabal docs but my cabal.project has only a "packages:" field with a list of directories under it and I don't know where to insert this so that it referes to one of the directories
08:36:21 <orzo> cabal should have a --quick-and-dirty flag
08:36:34 <orzo> that will just do whatever it can to get a build as fast as possible
08:39:36 <orzo> I guess I found the answer in the "5.5.4. Package configuration options" section.  Thanks
08:42:14 <maerwald> orzo: package <yourpackage>\n\toptimization: False
08:44:12 <orzo> maerwald: your \t is actually wrong, cabal complained when i used an actual tab character but accepted spaces.
08:44:14 <hseg> Hrm. Is there a clean way to write Int -> ((a->a)->a) -> ([a]->a) -> a (idea is to iterate taking continuations n times, assemble them all in a list, and pass to input function)
08:44:59 <orzo> maerwald: which is odd since the "packages:" field uses a tab character in the same file.
08:46:35 <hseg> ... and djinn doesn't give many results
08:50:57 <c_wraith> hseg: djinn only generates total functions, and that cannot be a total function.  It has no way to produce an `a' value
08:51:34 <c_wraith> hseg: oh, nevermind, missed the obvious passing [] to the second function.  ok, in that case, the problem is just that djinn doesn't support [] as a type
08:51:41 <hseg> ... The idea is that eg iter 2 i f = i $ \x -> (i $ \y -> f [x,y]) 
08:52:58 <c_wraith> Oh, then that's definitely not total
08:53:12 <nil> hseg: try to write it in terms of the Monad instance for Cont
08:53:31 <hseg> Why? Given finite iteration count, total i,f, that should be total.
08:53:53 <hseg> nil: That's what I'm guessing should be the correct answer, but I'm a bit stumped on how to do it.
08:55:52 <c_wraith> hseg: "iter 2 (+) sum" will diverge
08:56:23 <c_wraith> err, (+1)
08:57:47 <hseg> c_wraith: still doesn't typecheck -- (+1) isn't of type ((Int->Int)->Int)
08:57:57 <hseg> c_wraith: Did you mean ((+1).) ?
08:57:57 <c_wraith> right, whatever.  ($ 0)
08:58:28 <hseg> Why is that undefined? It reduces to f [0,0], no?
08:58:41 <nil> hseg: look at the definition of (>>=) for ContT, remove the constructors and deconstructors, and try to see how that looks like your thing
08:59:07 <hseg> nil: Right, Cont r a ~ ((a -> r) -> r)
08:59:14 <nil> iter is basically just replicateM
08:59:26 <hseg> So my signature is basically Int -> Cont a a -> Cont r [a]
09:00:03 <nil> actually  Int -> Cont r a -> Cont r [a]
09:00:30 <hseg> Right! that works, thanks!
09:01:21 <nil> if you wanted to write it by hand, it would go:  iter 0 i f = f []; iter n i f = i $ \x -> iter (n - 1) i $ \xs -> f (x:xs)
09:02:34 <c_wraith> I'm clearly not awake somehow. But that type still doesn't make sense unless you're calling f with [] somewhere.  Which I see nil's example is doing.
09:03:11 <hseg> c_wraith: Simpler case: iter 1 i f = i $ \x -> f [x]
09:03:44 <c_wraith> that still creates a circular dependency in the values
09:03:58 <nil> how so?
09:03:58 <c_wraith> you literally have to call f with [] as an argument in order to not do so.
09:04:31 <c_wraith> I'm apparently not awake enough to demonstrate how, but the type says it has to
09:04:35 <hseg> Why? Let i be something of the form ($a). Then you're literally just constructing f [a]
09:04:52 <hseg> (in my usecase, i integrates over an interval)
09:04:53 <c_wraith> So ($a) doesn't demonstrate the circularity.
09:05:02 <nil> % let iter 1 i f = i $ \x -> f [x]    in iter 1 ($ 42) id
09:05:02 <yahb> nil: [42]
09:05:37 <seishun> is there a better way to count how many values fulfil a condition than to use a dummy value? e.g. `length [() | x<-l1, y<-l2, cond x y]`
09:06:59 <dminuoso_> seishun: Sure. 
09:07:04 <dminuoso_> seishun: Not using a list comprehension to begin with.
09:07:09 <hseg> seishun: length . filter (uncurry cond) $ zip l1 l2
09:07:14 <c_wraith> hseg: but look at the type.  ((a -> a) -> a) famously does not produce a value of type a in a total manner.  ([a] -> a) can only produce a value of type a from scratch if passed [].
09:07:35 <dminuoso_> hseg: Note that this is semantically different from what they wrote.
09:07:49 <hseg> c_wraith: Right. But nil made me realize the type I wanted was actually ((a->r)->r)
09:08:00 <hseg> dminuoso_: oops.
09:08:11 <dminuoso_> hseg: They wrote something closer to `(length . filter id) (liftA2 cond l1 l2)`
09:08:13 <hseg> seishun: length . filter (uncurry cond) $ liftA2 (,) l1 l2
09:08:26 <dminuoso_> hseg: really? liftA2 (,) and then uncurry again? :o
09:08:34 <hseg> :facepalm:
09:08:39 <hseg> It's late
09:08:51 <yasar> I just realized you can do this -> `fmap Just [1,2,3,4,5]`
09:09:06 <c_wraith> yasar: fmap = (.)
09:09:10 <dminuoso_> yasar: Just is just a function. :-)
09:09:21 <c_wraith> Holy crap, I am tired. that's not the relevant instance
09:09:37 <yasar> "Just is just a function" -> that is the revelation I am having :)
09:09:39 <seishun> okay sorry my condition is a bit more complicated, the whole thing looks like `length [() | x <- [0..49], y <- [0..49], run [x, y] 0 0 program == [1]]`
09:09:48 <nil> :t Just
09:09:50 <lambdabot> a -> Maybe a
09:11:04 <nil> seishun: i'd say this is the simplest way
09:12:18 <nil> of course, in your *particular* instance, since i know you're solving advent of code, you could also sum all the outputs
09:12:25 <yasar> :t Nothing
09:12:26 <lambdabot> Maybe a
09:12:33 <yasar> Hmm
09:38:49 <markusl2ll[m]> hello
09:39:12 <markusl2ll[m]> is this now more popular than the irc channel on freenode?
09:39:50 <ChaiTRex> markusl2ll[m]: This is the IRC channel on freenode.
09:40:14 <markusl2ll[m]> o m g :p
09:43:47 <nil> matrix users seem to be living in a different world
09:45:03 <markusl2ll[m]> I guess hadn't you said that others wouldn't even have known what was I saying..
09:45:43 <markusl2ll[m]> but yes, joined the channel from the android riot.im app, i.e through the matrix protocol
09:45:46 <solonarv> yes, I was confused for a bit
09:46:00 <solonarv> ...until I saw the [m] at the end of your nickname
09:46:10 <solonarv> that's the default for bridged matrix users
09:46:18 <markusl2ll[m]> ah, so it does show something
09:46:49 <solonarv[m]> well, anyone can put [m] at the end of their name
09:47:21 <markusl2ll[m]> but here on my app it doesn't show
09:47:26 <nil> some people can't, because their nickname is already larger than the nickname length limit minus three
09:47:57 <markusl2ll[m]> ..and, on the matrix it only shows the fakers
09:48:56 <Lycurgus> fakers
09:49:44 <markusl2ll[m]> people who fake coming from the matrix
09:50:04 <markusl2ll[m]> this conversation is really getting ambiguous :p
09:50:10 <Lycurgus> ah, i was thinking faux thinkers
09:50:28 <markusl2ll[m]> "noone can be told what the matrix is" :p
09:51:20 <markusl2ll[m]> yup, but meant people who manually add the [m]
09:51:51 <Lycurgus> curry seems like the best logic programming haskell hybrid but i'd prefer a) something that was more like a  haskell lib and b) something that could process standard prolog
09:52:52 <Lycurgus> it's be easy enough to go on matrix and see
09:53:03 <Lycurgus> *it'd
09:53:16 <Lycurgus> if you could stand it
09:53:31 <hseg> How do you form a section for subtraction?
09:54:40 <pavonia> You use subtract instead
09:54:48 <hseg> Ah, thanks
09:55:27 <solonarv> hseg: similarly, negation is 'negate'
09:55:44 <solonarv> -x = negate x
09:55:52 <hseg> ty
10:05:23 <Lycurgus> also some clients identify the domain of origin of [m] nicks as matrix.org
10:06:22 <solonarv> Lycurgus: I think that's just part of the host/ident/whatever else /WHOIS returns
10:06:49 <solonarv> and, well, obviously bridged matrix users are connecting from a matrix server
10:07:09 <Lycurgus> right but it would be onerous and unlikely to be faked
10:08:08 <Lycurgus> like fake deplorables, of fake anything that why would anybody bother
10:09:21 <Lycurgus> also there are other projects that combine logic frameworks with hs but they're not "universal"/general purpose
10:10:04 <Lycurgus> *or fake anything
10:15:24 <solonarv> I know Ed Kmett is (was?) working on one, but I haven't kept up with it
10:16:33 <Lycurgus> from such an auspicious source, naught but good could come, if it did
10:18:06 <Lycurgus> but you have the clean slate chicken vs the decades of development chicken
10:18:20 <Lycurgus> *clean slate egg
10:28:33 <jgt> > @help
10:28:35 <lambdabot>  <hint>:1:1: error: parse error on input ‘@’
10:28:47 <jgt> @help
10:28:47 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:28:55 <jgt> @help list
10:28:55 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
10:29:09 <jgt> @info traverse
10:29:09 <lambdabot> traverse
10:29:13 <jgt> @type traverse
10:29:16 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
10:29:26 <jgt> @type sequence
10:29:30 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
10:30:28 <jgt> > sequence [("foo", Just "bar"), ("spam", Nothing)]
10:30:34 <lambdabot>  ("foospam",[Just "bar",Nothing])
10:32:49 <jgt> > traverse id [("foo", Just "bar"), ("spam", Nothing)]
10:32:52 <lambdabot>  ("foospam",[Just "bar",Nothing])
10:33:26 <jgt> > sequence <$> [("foo", Just "bar"), ("spam", Nothing)]
10:33:28 <lambdabot>  [Just ("foo","bar"),Nothing]
10:33:59 <jgt> > catMaybes . sequence <$> [("foo", Just "bar"), ("spam", Nothing)]
10:34:03 <lambdabot>  error:
10:34:03 <lambdabot>      • Couldn't match expected type ‘Maybe [a]’
10:34:03 <lambdabot>                    with actual type ‘([Char], Maybe [Char])’
10:34:10 <jgt> > catMaybes $ sequence <$> [("foo", Just "bar"), ("spam", Nothing)]
10:34:13 <lambdabot>  [("foo","bar")]
11:05:59 <solonarv> jgt: you can play with lambdabot in priv msgs, you know
11:09:21 <jgt> solonarv: ah, sorry!
11:46:59 * dsal comes to irc just to hang out with lambdabot 
11:49:25 <lavalike> @botsnack
11:49:25 <lambdabot> :)
11:53:27 <yasar> These guys compile haskell into web assembly : https://www.tweag.io/posts/2019-12-19-asterius-diagrams.html
11:53:32 <yasar> looks interesting
11:59:57 <zeta_0> error: ghcmod: could not find module Yesod?
12:01:10 <zeta_0> does this have to do with haskell-ide-engine, or is this something that is nix related?
12:22:22 <bbarker> What do people use for refactoring, in particular simple things like symbol renaming, in GHC 8.6.x?
12:26:21 <dsal> I use emacs.  GHC is just the compiler.
12:28:50 <bbarker> yeah I was thinking of HaRe which seemed dependent on the compiler
12:29:00 <bbarker> I was waiting for someone to say sed or awk 
12:30:09 <koz_> bbarker: https://xkcd.com/378/
12:30:09 <bbarker> dsal, but on a more serious note, i do use emacs but am not a power user of it - are you using some common emacs functionality or a haskell package for emacs for renames?
12:31:04 <bbarker> hahaha
12:31:06 <dsal> It's just not a thing I care enough about to try to learn a new tool to do vs. just editing.
12:31:22 <iqubic> What is HaRe?
12:31:28 <bbarker> fair enough, my usual approach as well
12:31:42 <dsal> "HaRe can rename symbols, lift definitions, convert equivalent Haskell constructs like ifs and cases and more while preserving program semantics, types and correctly handling indentation. Only HaRe can execute identity transformation!"
12:32:53 <dsal> Refactoring tool == new tool to learn.  I can generally change things in my code and just let the compiler guide me to what I was trying to do by compiling or not.  When it compiles, I've usually at least done the thing I set out to do correctly.  Sometimes it was even what I should've done.
12:37:34 <koz_> Yeah, agreed with dsal.
12:39:44 <bbarker> sounds good; i'll probably try a command line global replace with sed and see how it goes
12:42:10 <dsal> Go shipped a tool that did somewhat semantic refactoring because they needed to make language changes. It could do expression rewriting. Looked neat. I think I used it once.
12:42:15 <jgt> I also agree with dsal; I've seen no better IDE "refactoring" tool than :silent! argdo %s/foo/bar/gc and GHC
13:15:09 <yasar> I am seeing the word `nix` occasionally on Haskell related texts
13:15:17 <yasar> what is that exactly
13:15:31 <cdunklau> yasar: https://en.wikipedia.org/wiki/Nix_package_manager
13:15:34 <cdunklau> presumably
13:17:34 <solonarv> correct
13:50:52 <wildtrees> how do I promote/lift a value of String , known only at runtime to the typelevel? do I want to use Data.Singletons, the library's help seems a bit large 
13:52:22 <lyxia> wildtrees: https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-TypeLits.html#v:someSymbolVal
14:12:20 <zeta_0> i am getting the error: `ghcmod: could not find module Yesod` even though i have yesod installed, what is causing this error and how do i fix it?
14:42:27 <sm[m]> is there any point in using ghc-mod these days ?
14:43:01 <sm[m]> now that we have hie and ghcide ?
14:43:26 <monochrom> Is ghc-mod maintained?
14:44:19 <monochrom> because ghc-mod is one of those high-maintenance software, i.e., someone needs to check that it is compatible with newer GHC versions.
14:45:18 <monochrom> moreover, even if "no change", you need to rebuild it when you change GHC version, too.
14:46:53 <sm[m]> zeta_0: high level summary: there’s not just one place to have Yesod installed. You’d need to mind-meld with ghc-mod, find out the environment it runs in and ensure yesod is visible  there. And ghc-mod is considered outdated.
14:49:09 <monochrom> I think we will never convince beginners "you don't need anything remotely close to IDEs for haskell, despite your experience with other languages".
14:50:13 <sm[m]> summary of the summary: too hard, try ghcid and after that maybe ghcide instead
14:53:51 <iqubic> We have ghc, ghci, ghcid, and ghcide. What's next?
14:54:08 <monochrom> ghcidea
14:54:35 <ephemient> jetbrains' next product :D
14:54:36 <MarcelineVQ> gii
14:54:37 <iqubic> So it's going to be a jetbrains Haskell IDE?
14:54:40 <dmwit> fghcide
14:54:58 <dmwit> ghcider
14:55:22 <dmwit> > sort "fghcide"
14:55:25 <lambdabot>  "cdefghi"
14:55:38 <monochrom> Oh! haha
14:56:51 <fenedor> to be fair, ghcide and ghcid are by similar people
14:57:03 <fenedor> at least one intersection
14:57:12 <fenedor> maybe at most
14:57:14 <fenedor> i dunnp
14:57:18 <dmwit> now be unfair, pls
14:57:29 <monochrom> probably one is a subset of the other
14:57:32 <ephemient> $ grep 'g.*h.*c.*i.*d' /usr/share/dict/words
14:57:32 <ephemient> meningorhachidian
15:00:04 <zeta_0> i am using hie(haskell-ide-engine) and i think ghc-mod is integrated with hie, anyways when i run the program it compiles and runs fine, but hie in emacs is throwing the error: `ghc-mod: could not find module Yesod` , also i am using nixos, so i installed hie with nix in home.nix, but i don't think that this is nix related?
15:00:07 <zeta_0> sm[m]: ^
15:00:38 <fendoer> zeta_0, hie isnt using ghc-mod any longer
15:01:02 <fendoer> from tomorrow evening on
15:01:04 <wildtrees> zeta_0, did you install yesod using nix as well? 
15:01:24 <wildtrees> zeta_0, I found some things all broken and really weird in nix, from their way of doing things 
15:01:59 <monochrom> > length (4 :+ 5)
15:02:03 <lambdabot>  2
15:02:38 <monochrom> > foldMap show (4 :+ 5)
15:02:40 <lambdabot>  "45"
15:02:49 <monochrom> this is deeply unsettling :)
15:03:18 <wildtrees> monochrom, whats :+ supposed to do? 
15:03:21 <zeta_0> yes, i have everything installed with nix: https://hastebin.com/aninalerob.py
15:03:28 <monochrom> complex number.  4 + 5i
15:03:47 <monochrom> @type 4 :+ 5
15:03:48 <lambdabot> Num a => Complex a
15:04:02 <wildtrees> show (4 :+ 5) 
15:04:06 <wildtrees> > show (4 :+ 5) 
15:04:08 <lambdabot>  "4 :+ 5"
15:04:30 <wildtrees> @type foldMap 
15:04:31 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
15:04:32 <zeta_0> well if ghc-mod is not even a part of hie why am i getting this weird ghc-mod error and why does hoogles documentation highlighting stop work in hie when i get this error?
15:04:38 <ephemient> I guess it's a natural fallout of the Functor/etc. instances of Complex
15:04:44 <wildtrees> monochrom, isn't the weirdness from the monoid instance? 
15:05:10 <ephemient> > succ <$> 4 :+ 5
15:05:11 <fendoer> zeta_0, I said from tomorrow on ;D sorry
15:05:12 <lambdabot>  5 :+ 6
15:05:27 <monochrom> monoid instance of what? string?
15:05:48 * dmwit doesn't think there's been any weirdness exhibited yet
15:05:59 <wildtrees> monochrom, yea
15:06:10 <monochrom> That part is not weird at all.
15:06:27 <monochrom> dude, I know string <> is ++, OK?
15:07:21 <ephemient> well hah
15:07:37 <ephemient> > show <$> 4 :+ 5
15:07:39 <lambdabot>  "4" :+ "5"
15:07:45 <ephemient> of course
15:08:01 <ephemient> > length $ () :+ ()
15:08:02 <lambdabot>  2
15:08:10 <ephemient> very good complex numbers, those are
15:08:36 <monochrom> OK, it only gets better:
15:09:13 <monochrom> > (4 :+ 5) >>= \x -> ((x-1) :+ (x+1))
15:09:16 <lambdabot>  3 :+ 6
15:09:33 <hpc> awesome
15:09:46 <monochrom> OK I think the following is clearer:
15:09:48 <hpc> complex numbers are arrows confirmed
15:10:00 <monochrom> > join ((1 :+ 2) :+ (3 :+ 4))
15:10:02 <lambdabot>  1 :+ 4
15:10:16 <Axman6> :|
15:11:05 <dmwit> :-
15:11:10 <dmwit> With our powers combined, we are :+
15:11:54 <monochrom> > mapM (\x -> [x, x]) (4 :+ 5)
15:11:57 <lambdabot>  [4 :+ 5,4 :+ 5,4 :+ 5,4 :+ 5]
15:12:06 <Axman6> > join ((a :+ b) :+ (c :+ d))
15:12:10 <lambdabot>  a :+ d
15:12:29 <dmwit> monochrom: Surely there could be no other sensible answer to that query. You don't object to that one, do you??
15:12:59 <dmwit> (Although I don't agree with objecting to some of the others, I could see how a sensible person might disagree with me. But that one seems just objectively correct.)
15:13:21 <monochrom> I object to Complex being considered a "container" type at all, and so it shouldn't be Foldable, Traversable, Functor, Applicative, or Monad.
15:13:29 <monochrom> such travesty
15:13:31 <zeta_0> fendoer: `from tomorrow on`? what do you mean by that?
15:14:01 <monochrom> However, if you force it to be one, all of the implementations are correct.
15:14:05 <dmwit> :t sum . ((^2)<$>)
15:14:06 <lambdabot> (Foldable t, Functor t, Num c) => t c -> c
15:14:22 <dmwit> the worst way to do this =P
15:14:58 <dmwit> :t traverse (Const.Sum.(^2))
15:15:00 <lambdabot> error:
15:15:00 <lambdabot>     Not in scope: data constructor ‘Const.Sum’
15:15:00 <lambdabot>     No module named ‘Const’ is imported.
15:15:07 <dmwit> :t traverse (Const . Sum . (^2))
15:15:08 <lambdabot> (Traversable t, Num a) => t a -> Const (Sum a) (t b)
15:15:16 <monochrom> On the bright side, next time someone hates "length (x,y) = 1" or "foldMap f (x, y) = f y", point them to Complex.
15:15:45 <Axman6> > length (1 :+ 1)
15:15:45 <dmwit> hm =)
15:15:48 <lambdabot>  2
15:15:58 <dmwit> "X is fine because Y is worse"... ick
15:16:12 <monochrom> See?!
15:16:16 <monochrom> QED
15:16:24 <zeta_0> so does fendoer mean that hie is going to stop using ghc-mod tomorrow?
15:16:32 <dmwit> However, I do like "X is fine because Y is worse and Y is fine". ^_^
15:16:40 <monochrom> haha
15:17:12 <wildtrees> Axman6, is your name from the name of a battle mech in battletech? 
15:17:13 <monochrom> OK, on to Quaternion!
15:18:13 <Axman6> It is not
15:18:30 <wildtrees> oh ok, always wondered
15:19:03 <monochrom> Anyway, I was preparing to teach my students Foldable, so I looked into base doc for Foldable examples, and found Complex as one.  That started all this.
15:20:08 <Axman6> It'd be interesting to see if it's being used in any codebases
15:20:21 <Axman6> wildtrees: Axman6 is my name
15:21:42 <monochrom> Oh! pure x = x :+ x
15:21:53 <monochrom> > pure 4 :: Complex Integer
15:21:55 <lambdabot>  4 :+ 4
15:22:18 <monochrom> But hey why don't I go to town
15:22:35 <monochrom> > pure "abc" :: Complex String
15:22:38 <lambdabot>  "abc" :+ "abc"
15:23:02 <monochrom> > (sin :+ cos) <*> (0.1 :+ 0.2)
15:23:04 <lambdabot>  9.983341664682815e-2 :+ 0.9800665778412416
15:23:27 <wildtrees> Axman6, there was mechs in battletech named, hatchetman and axman, I think thats how they were spelled 
15:23:32 <monochrom> Complex (Double -> Double).  Take that, mathematicians!
15:24:08 <Axman6> > abs (sin :+ cos)
15:24:11 <lambdabot>  error:
15:24:11 <lambdabot>      • No instance for (RealFloat (Double -> Double))
15:24:11 <lambdabot>          arising from a use of ‘e_1’
15:24:21 <monochrom> Num instance is more restrictive.
15:28:01 <fendoer> zeta_0, well, yeah, the pull #1126 in hie ois ditching ghc-mod ni favour of hie-bios and cabal-helper. And this pr is going to be merged soon(tm)
15:28:06 <fendoer> *bios
15:29:00 <monochrom> wow hie in bios...
15:29:09 <fendoer> hie and hie-bios
15:29:39 <monochrom> so hie is available even if I boot DOS...
15:29:46 <zeta_0> fendoer: oh, ok, sounds good. i've always had problems with ghc-mod, so it is good that i don't have to use it anymore
15:30:00 <fendoer> monochrom, never claimed that :)
15:30:23 <fendoer> zeta_0, hopefully from tomorrow on. Maybe next week
15:30:56 <monochrom> Will there also be hie-uefi?
15:31:38 <fendoer> monochrom, probably. You know the haskell ecosystem 
15:31:44 <Axman6> yeah I'm on a mac, I don't have BIOS, can I still use it?
15:31:49 <monochrom> "yeah hie-uefi sits in uefi and type-checks your grub or windows boot manager before running them!"
15:33:12 <monochrom> Ahhh how do I teach Foldable to my students...
15:33:27 <zeta_0> the rest hie does not work because of the ghc-mod error, dam it
15:34:56 <monochrom> Oh! Array is not in base, it's in "array".
15:35:50 <solonarv> monochrom: bad answer: a Foldable is anything you can convert to a list!
15:38:12 <yushyin> even better! 'Data structures that can be folded.' -- hackage
15:40:00 <MarcelineVQ> Data strctures capable of being phrased as a catamorphism conforming to the catamorphic structre of a Natural number decorated with values.
15:40:46 <solonarv> I most like 'foldMap' as its characteristic funcion
15:44:31 <monochrom> @type bifoldMap
15:44:32 <lambdabot> error:
15:44:32 <lambdabot>     • Variable not in scope: bifoldMap
15:44:32 <lambdabot>     • Perhaps you meant one of these:
15:45:11 <monochrom> % :type bifoldMap
15:45:12 <yahb> monochrom: ; <interactive>:1:1: error:; * Variable not in scope: bifoldMap; * Perhaps you meant one of these: `ifoldMap' (imported from Control.Lens), `foldMap' (imported from Prelude)
15:45:54 <monochrom> Ah, they have it, just not imported.
15:46:22 <monochrom> > Data.Bifoldable.bifoldMap show show (4, True)
15:46:24 <lambdabot>  error:
15:46:24 <lambdabot>      Not in scope: ‘Data.Bifoldable.bifoldMap’
15:46:25 <lambdabot>      Perhaps you meant ‘Data.Foldable.foldMap’ (imported from Data.Foldable)
15:46:39 <zeta_0> is a lot of the stuff in the 1st edition yesod book deprecated? should i use the 2nd edition of the yesod book instead? 
15:48:25 <monochrom> lambdabot is strange.
15:48:29 <monochrom> % Data.Bifoldable.bifoldMap show show (4, True)
15:48:29 <yahb> monochrom: "4True"
15:49:09 <monochrom> But hey watch this
15:49:21 <monochrom> % Data.Bifoldable.bifoldMap show show ((), 4, True)
15:49:21 <yahb> monochrom: "4True"
15:49:38 <monochrom> actually even better:
15:49:42 <monochrom> % Data.Bifoldable.bifoldMap show show (undefined, 4, True)
15:49:43 <yahb> monochrom: "4True"
16:11:42 <iqubic> % :t Data.Bifoldable.bifoldMap
16:11:42 <yahb> iqubic: (Data.Bifoldable.Bifoldable p, Monoid m) => (a -> m) -> (b -> m) -> p a b -> m
16:12:16 <dmwit> monochrom: But there's no Foldable instance for triples?? What is this madness.
16:12:37 <iqubic> dmwit: No.
16:13:07 <iqubic> And I think Either is a Bifoldable too. Not sure though.
16:13:43 <dmwit> We somehow got the worst of both worlds. The detractors got away with no instance for 3- and higher-tuples, which is inconsistent, the attractors got away with yes instance for 2-tuples, which is confusing.
16:14:11 <monochrom> I want Monad for triples!
16:14:22 <dmwit> Yes, why not!
16:14:59 <EvanR> ((b,c),a) ?
16:15:25 <iqubic> No. (b,c,a)
16:15:27 <monochrom> Such is politics.
16:16:41 <wildtrees> how do I get to the tasty Proxy s inside a s SomeSymbol, using GHC.TypeLits, I want different runtime strings to end up producing different types 
16:17:04 <mycroftiv> I need an expose on the politics of the tuple limitations on foldable haskell monads
16:17:15 <wildtrees> right now , I was using Proxy "somesymbol" with type families to trigger instance resolution for typeclasses 
16:17:19 <EvanR> you say ((b,c),a) i saw (b,c,a) let's call the whole thing off
16:17:28 <wildtrees> but the proxy being wrapped in SomeSymbol prevents that atm 
16:17:55 <monochrom> wildtrees: Have you glanced over all of the offerings in GHC.TypeLits?
16:20:04 <dsal> Is there a way in tasty (or test framework in general) I can have some tests only enabled if I pass a flag?
16:21:17 <monochrom> Or maybe I misread the question.  Use pattern matching?  SomeSymbol is a very simple existential type.
16:23:52 <monochrom> I think the whole enterprise is in vain.  I probably can prove it too.
16:24:45 <monochrom> The original goal was to achieve, in terms of dependent types, (x::String) -> Parser (F x), or maybe Map (x::String) (Parser (F x))
16:25:26 <monochrom> We all agree it can be reduced to (x::String) -> Proxy x, i.e., if you can do that, the rest is easy.
16:25:56 <monochrom> But Haskell is not dependently typed.  Not even after all the emulations and encodings.
16:26:19 <monochrom> Haskell doesn't have any equivalent of (x::String) -> Foo x
16:28:31 <monochrom> Then you make a concession.  You accept the independently typed String -> Parser (an existential type existentially quantified over type-level strings, e.g., SomeSymbol.)
16:29:16 <wildtrees> monochrom, oh :( so there is no way? what if I am shoving the results from the parsers into a dependent sums used in dependent-map? 
16:30:02 <monochrom> This concession defeats the whole point.  The conceded type says that the type-level string in the codomain has nothing to do with the string parameter in the domain.
16:30:40 <monochrom> Therefore all the work of building an elaborate infrastructure surrounding type-level string is totally pointless.
16:31:32 <monochrom> You may as well go back to the low-tech String -> Parser (a vanilla existential type or even simpler an ADT) because it is no less powerful.
16:33:01 <wildtrees> monochrom, would these help? String -> DSum Key Identity ? https://hackage.haskell.org/package/dependent-sum-0.6.2.0/docs/Data-Dependent-Sum.html 
16:33:02 <EvanR> a dependently typed parser is basically the only way to go from the real world to a sane dependently typed program core
16:33:18 <EvanR> with enough information about the input to work with
16:34:10 <wildtrees> yea I was thinking why bother earlier today, just wrap my parser in an ADT sum type, but then a container of my parser results could possibly contain something that is incorrect for a parsed field 
16:34:51 <monochrom> which part in "DSum Key Identity" does it say that it depends on your string value?
16:36:44 <wildtrees> oh I was thinking if I could map from String to (Key a) where Key a is a Gadt 
16:47:19 <wildtrees> monochrom, so basically, what I wanted to do can not be currently done in haskell, whatsoever? 
16:47:26 <monochrom> Right.
16:47:38 <wildtrees> ok thank you for all your help 
16:48:13 <monochrom> If you can't write down this type "(x::String) -> Proxy x" you can't do anything more.
16:48:39 <monochrom> And the point being the codomain type varies by the domain value.
16:48:48 <monochrom> a mapping from value to type.
16:49:04 <monochrom> In Haskell, at best you have a mapping from type to type.
16:49:15 <wildtrees> so like dependent pairs in the codomain like from Idris (n ** Vect n Char) or what have you? 
16:49:23 <EvanR> well that type is literally possible using DataKinds
16:49:35 <EvanR> where String means Symbol
16:49:39 <EvanR> but i am probably late to this convo
16:49:41 <monochrom> I don't know what's ** in Idris.
16:49:46 <MarcelineVQ> Sigma
16:49:51 <EvanR> dependent pair constructor
16:49:52 <wildtrees> dependent pair 
16:50:04 <EvanR> er, type former
16:50:06 <monochrom> Yeah OK
16:50:26 <monochrom> (x::Nat, Vect x Char)
16:50:35 <monochrom> again x is a value not a type.
16:51:05 <monochrom> And no, DataKinds literally proves that it doesn't do "(x::String) -> Proxy x"
16:51:24 <monochrom> Listen to yourself.  DataKinds.  Not DataTypes.
16:51:33 <wildtrees> yea something along those lines, in idris if you don't use it , it will complain, though you can use it, and just throw away part of the result via patter matching after specifying a dependent pair and it usually works fine 
16:51:44 <wildtrees> pattern matching, even 
16:52:38 <monochrom> Listen to yourself.  The type "True" of kind "Bool".  Where is "value" there?  (For DataKinds)
16:53:18 <monochrom> Listen to yourself.  The type "abc" of kind Symbol.  Where is "value" there?  (For type-level strings)
16:53:28 <MarcelineVQ> wildtrees: indeed monochrom's example is in idris without involving pairs,  "(x::String) -> Proxy x"  is "(x : String) -> Proxy x"  in idris, a depending function or pi type, where ( x : Nat ** Vect n a) is a dependent pair, or sigma type.
16:54:14 <MarcelineVQ> for some valid Proxy :>
16:55:41 <monochrom> Because of all these, my opinion is that a lot of people are fooled by DataKinds and TypeLits into believing that Haskell comes remotely close to dependent typing, and a lot of other people actively fools themselves such.
16:56:27 * wildtrees was roughly under the notion that something like dependent types had been approached in haskell 
16:56:45 <monochrom> I.e., they just look at the deceptive "MyTypeFamily True" and "MyTypeFamily False" and go "w00t I have a boolean value in my type!"
16:57:06 <EvanR> using type classes to do type level computation might qualify as "remotely close" (wait... what a contradiction)
16:57:22 <Axman6> singletons gets you s long way towards dependant types no?
16:57:22 <monochrom> Wrong.  You have a type of kind Bool in your type.  You are still stuck with mapping types to types.
16:57:30 <Axman6> I haven't been following the discussion very closely
16:58:14 <monochrom> singletons probably proves my point even more, not less.
16:58:14 <wildtrees> Axman6, I basically want String -> Parser x where x would be different types depending on the value of String at runtime passed to it 
16:58:34 <EvanR> hence (x:String) -> Parser (f x)
16:59:24 <EvanR> you can do (f x) in haskell but x can't be the runtime value
16:59:24 <monochrom> Again, listen to yourself.  "singleton".  The type has only one value.  How do you usefully "vary type by value" if there is only one possible value?
16:59:51 <jle`> we have dependent pairs in haskell and they can look similar syntactically in Haskell as well
16:59:59 <jle`> the only thing we don't have are anonymous dependent pairs
17:00:07 <jle`> like they do in idris
17:00:16 <EvanR> why does dependent pair keep coming up for this problem
17:00:20 <jle`> but for the most part the 'mechanics' work similar in haskell and idris
17:00:30 <EvanR> it's a Pi question
17:00:49 <jle`> EvanR: from what i'm interpreting this as, wildtrees is saying that there is something in idris that is not expressable in haskell types
17:00:55 <MarcelineVQ> the mechanics being, hey, make a tag datatype of possible return types. surely you can't want 'any possible' type
17:00:58 <monochrom> No, that's me.
17:01:00 <jle`> but i'm saying that what they are trying to say is not representable in either haskll *or* idris
17:01:10 <jle`> and it's bunk in both
17:01:26 <jle`> the difference between haskell and idris isn't the problem here
17:02:55 <jle`> hm, i think i might have jumped in at a weird time
17:02:57 <jle`> ignore me :)
17:03:06 <jle`> this conversation goes a lot deeper than i had thought
17:03:07 <wildtrees> was recently exposed to (closed) type families, thought I could use that to corral the properly lifted value of String into a sensible number of finite types and dispatch via typeclasses 
17:07:22 <jle`> wildtrees: are you saying you want to parse the string at the type level *and* at the value level?
17:07:53 <monochrom> use a value to determine a parser type.
17:08:24 <monochrom> type family but not parametrized by type, instead parametrized by value.
17:09:03 <monochrom> Also I can refute "named dependent pair in haskell" along the same line.
17:10:48 <monochrom> You have "exist type-level number n. Proxy n" and you can define an existential type for it.  But the n there is a type, not a value.
17:11:25 <monochrom> You may then try to salvage it by "use natVal to map Proxy n to Integer".
17:11:26 <Axman6> is parse :: String -> (forall (a :: SomeKind). Parsed a -> b) -> b possible
17:11:37 <jle`> hm. whatever the technicalities, i think what wildtrees is suggesting doesn't make much sense in either idris *or* haskell. so the difference isn't the significance thing
17:11:40 <jle`> *significant
17:11:46 <jle`> there's a more fundamental issue
17:12:10 <monochrom> But does natVal's type-level guarantee say: "Proxy n -> {Integer but I guarantee you the value is n}"?
17:14:39 <monochrom> But I didn't hinge anything on Idris.
17:15:26 <monochrom> CoC supports "(x::Nat) -> F x" let's start from there.
17:20:33 <monochrom> http://docs.idris-lang.org/en/latest/tutorial/typesfuns.html  and look for "mkSingle : (x : Bool) -> isSingleton x"
17:21:04 <monochrom> actually direct jump http://docs.idris-lang.org/en/latest/tutorial/typesfuns.html#dependent-types
17:22:14 <rmorrison> Hello. I have a UTF-8 encoded `ByteString` of SHA-1 hashes. And I need a raw `ByteString` from it. What can I do? I can use something like `T.encodeUtf8` but then I won't have a way to get a raw `ByteString` from `Text`
17:22:48 <jle`> rmorrison: if you need a raw ByteString ... don't you already have that?
17:22:56 <Axman6> yeah I'm confused
17:23:10 <rmorrison> It's UTF-8 encoded
17:23:12 <jle`> oh, do you mean you have something like "abc153fge23" but as a bytestring?
17:23:13 <Axman6> do you want to convert the Base64 format to the bytes that represents?
17:23:18 <wildtrees> what about this then http://www.ponies.io/posts/2014-07-30-typelits.html almost seems to be doing what I wanted 
17:23:24 <monochrom> Perhaps you need to show examples.
17:23:44 <Axman6> https://hackage.haskell.org/package/base64-bytestring is usually how that's done
17:23:57 <Axman6> hmm, probably base16 actually
17:24:12 <Axman6> https://hackage.haskell.org/package/base16-bytestring
17:27:27 <rmorrison> Oh, no, it's different. I'm writing a torrent client. And each hash value of all pieces of data you can download is concatenated and UTF-8 encoded (Is it even possible?). And I need to get back the raw hashes
17:27:32 <EvanR> rmorrison might be talking about a Word160 that's been encoded as text, encoded as a bytestring
17:27:33 <rmorrison> > encoding: (optional) the string encoding format used to generate the pieces part of the info dictionary in the .torrent metafile (string)
17:27:36 <lambdabot>  <hint>:1:82: error: parse error on input ‘of’
17:27:43 <rmorrison> > pieces: string consisting of the concatenation of all 20-byte SHA1 hash values, one per piece (byte string, i.e. not urlencoded)
17:27:45 <lambdabot>  <hint>:1:27: error: parse error on input ‘of’
17:27:49 <monochrom> wildtrees: It is no different from what you have been doing.
17:29:38 <wildtrees> what I am doing, hasn't been working much at all 
17:29:56 <monochrom> Well OK, then it tells you how to do what you have been doing!
17:30:22 <jle`> wildtrees: i might have missed it, but can you give us an example of what you are trying to do?
17:30:40 <monochrom> For example how to use pattern matching ("case ... of SomeSymbol p -> ..." now p is your proxy) on SomeSymbol
17:31:07 <monochrom> But again no type-level guarantee of correctness.
17:31:15 <wildtrees> jle`, I don't have a clean example atm, it's a mess mixed up in another file where I am experimenting 
17:31:26 <monochrom> Type-level guarantee of correctness is overrated IMO anyway.
17:31:27 <jle`> hm, no simple self-contained thing?
17:31:35 <wildtrees> not really 
17:31:37 <jle`> with an example string and example kind
17:32:36 <monochrom> And I have trouble finding what's the point or benefit of that article.  There are better and 1st-year-CS ways of receiving a "dance" parameter and printing out a dancing figure.
17:33:38 <monochrom> And even when you extend to "there are several possible strings, map/dispatch accordingly to responses" it is still a 1st-year-CS exercise.  What's type-level strings doing here?!
17:33:52 <wildtrees> jle`, from about type family FConvert onwards https://0paste.com/45222 it's just a mess atm though 
17:34:01 <monochrom> And the article doesn't cover error handling.
17:34:35 <wildtrees> so it's roughly the same as just not using types? 
17:34:47 <monochrom> Perhaps the purpose is to omit error handling so as to fool you into thinking "no possibility of runtime errors, yay this is dependent types!"?
17:35:30 <monochrom> Because like if I ran "runhaskell Command.hs dontdance" what's going to happen?
17:35:53 <wildtrees> nothing cause the when won't fire 
17:37:21 <wildtrees> monochrom, it shows how to get to the "juicy" proxy inside the SomeSymbol though 
17:37:40 <monochrom> OK so I guess the benefit is "forM_ handlers" instead of traversing a list of type [(String, IO ())] ?
17:38:00 <monochrom> Yes I grant you that.
17:38:31 <monochrom> But you can find it in any tutorial on existential types too.  For example the GHC user's guide.
18:12:14 <rmorrison> Is there `printLn` function?
18:12:37 <rmorrison> hoogle can't find anything 
18:12:51 <koz_> :t putStrLn
18:12:53 <lambdabot> String -> IO ()
18:12:59 <rmorrison> :t print
18:13:00 <koz_> ^
18:13:01 <lambdabot> Show a => a -> IO ()
18:13:09 <rmorrison> I want `Show a` part
18:13:19 <koz_> Yeah, print is what you're after then.
18:13:37 <koz_> There's no function that adds a newline by default I think.
18:13:41 <koz_> You can write one though.
18:13:57 <rmorrison> > print "a" >> print "b"
18:13:59 <lambdabot>  <IO ()>
18:14:02 <MarcelineVQ> print already adds a newline ^^;
18:14:03 <rmorrison> :c
18:14:08 <koz_> MarcelineVQ: TIL lol.
18:14:31 <MarcelineVQ> print = putStrLn . show
18:15:37 <rmorrison> Oh, it's true. Thank you
18:17:25 <rmorrison> Though my output for some reason is still one big line
18:20:47 <rmorrison> Is there a way to simplify (get rid of map) here. I have lots of functions written like that: `fmap toInteger . VB.int <=< M.lookup "length"`
18:24:13 <monochrom> What is VB?
18:27:09 <rmorrison> Oh, it's qualified function of mine. The problem is `(VB.int <=< M.lookup "length") :: Map k v -> f a` and I want to append function of type `a -> b` to it 
18:29:52 <rmorrison> It can be done without point-free style `toInteger <$> (M.lookup "length" x >>= VB.int)`. But that's still not ideal
19:03:32 <Henson> I'm working on one of the advent of code problems (day 2) and am trying to remember monad transformers.  I'd like to combine a state monad (for performing operations on the simulated memory) and except monad (to short circuit in case of an illegal operation) together in a pure computation.  It's been a while, so I can't remember if I should use monad transformers (with Identity as the base monad)
19:03:53 <koz_> Henson: If you want all those effects, you want transformers.
19:03:55 <Henson> or if transformers should only be used if I have a monad like IO at the base.
19:04:05 <koz_> You can use Identity at the heart just fine.
19:04:14 <koz_> However, given that you want two different effects, there's two ways it can stack.
19:04:28 <koz_> @unmtl StateT s (EitherT e) a
19:04:28 <lambdabot> s -> EitherT e (a, s)
19:04:39 <koz_> @unmtl EitherT e (StateT s) a
19:04:40 <lambdabot> EitherT e (StateT s) a
19:04:49 <koz_> @unmtl EitherT e (State s) a
19:04:49 <lambdabot> EitherT e (State s) a
19:05:07 <koz_> Sorry, let me be more exact.
19:05:17 <koz_> @unmtl StateT s (EitherT e Identity) a
19:05:17 <lambdabot> s -> EitherT e Identity (a, s)
19:05:27 <koz_> @unmtl EitherT e (StateT s Identity) a
19:05:27 <lambdabot> EitherT e (StateT s Identity) a
19:05:52 <koz_> ... sigh, I am daft.
19:05:57 <koz_> :t ExceptT
19:05:59 <lambdabot> m (Either e a) -> ExceptT e m a
19:06:00 <Henson> koz_: yes, so the next question is what's the stack order?  I want the thing to result in an Either, at the end of everything, so that means runExceptT should be first, which means inside of that should be runStateT, right?
19:06:15 <koz_> Henson: The question is 'should the state survive after an error'?
19:06:25 <koz_> Let's look more carefully.
19:06:27 <Henson> koz_: hmmmm, good question.
19:06:34 <koz_> @unmtl StateT s (ExceptT e Identity) a
19:06:35 <lambdabot> s -> ExceptT e Identity (a, s)
19:06:45 <koz_> Here, you lose the state as soon as an error occurs.
19:06:57 <koz_> @unmtl ExceptT e (StateT s Identity) a
19:06:57 <lambdabot> ExceptT e (StateT s Identity) a
19:07:50 <koz_> Something is weird with that. Is it ErrorT?
19:07:57 <koz_> @unmtl ErrorT e (StateT s Identity) a
19:07:57 <lambdabot> s -> (Either e a, s)
19:08:01 <koz_> Yeah, that's better!
19:08:10 <koz_> In this case, you keep the state no matter what.
19:08:21 <koz_> So that's the thing you gotta decide.
19:08:32 <koz_> Both are valid stackings, but which one is valid _in your use case_ depends on what you want.
19:09:20 * Henson tries to keep up
19:09:43 <koz_> I can go over it more slowly if that was too quick.
19:14:55 <Henson> koz_: well, I don't understand exactly what @unmtl is doing.  But it looks like using ErrorT is better because you put in a state S and what you get out at the end as a return value is Either e a and the state s.  But ErrorT says it's deprecated in favour of EitherT, so should that be used?  The computation in the end won't have any return value, although in general it could.
19:15:07 <koz_> Henson: OK, one thing at a time.
19:15:14 <Henson> koz_: maybe just walk me through what one of the @unmtl things is doing
19:15:29 <koz_> Basically, you can think of a transformer stack as being 'morally equivalent' to some combination of non-transformer things.
19:15:32 <koz_> For example
19:15:45 <koz_> State s a is morally equivalent to s -> (a, s)
19:15:54 <koz_> All @unmtl is doing is exposing this.
19:15:58 <koz_> @unmtl State s a
19:15:59 <lambdabot> s -> (a, s)
19:16:06 <Henson> koz_: what do you mean "morally equivalent"?
19:16:11 <koz_> They do the same things.
19:16:20 <MarcelineVQ> close enough to the same to call it the same :>
19:16:52 <Henson> ahh, ok
19:16:55 <koz_> Now, the reason I used ErrorT instead of EitherT is because @unmtl predates the deprecation of ErrorT.
19:17:10 <koz_> However, you can mentally replace ErrorT with EitherT in all my examples, and it'll mean the same.
19:20:07 <Henson> koz_: what do you mean "State s" is morally equivalent to "s -> (a,s)"?  I'm trying to understand how this equivalence is derived from what's in the StateT documentation.
19:21:06 <lyxia> They don't have the same instances though
19:21:45 <iqubic> henson: Look at this:
19:21:51 <iqubic> :t runState
19:21:53 <lambdabot> State s a -> s -> (a, s)
19:22:20 <iqubic> Notice the how that turns a "State s a" into a "s -> (a, s)"?
19:22:35 <iqubic> I think that's what koz_ was hinting at.
19:22:36 <Henson> yes
19:22:38 <Henson> ok
19:23:05 <koz_> Basically, you _could_ use s -> (a, s) everywhere. State s a just makes it more convenient.
19:23:17 <koz_> (as lyxia said, it has different instances for _exactly_ that reason)
19:23:31 <koz_> The equivalence comes purely from how StateT is defined.
19:23:35 <koz_> Since the definition is something like
19:23:50 <koz_> StateT s m a = StateT { runStateT :: s -> m (a, s) }
19:24:27 <koz_> Now, if we note that State s a is just StateT s Identity a, we can see that State s a is really s -> Identity (a, s), which is _really_ s -> (a, s).
19:24:57 <koz_> All monad transformers act as convenience wrappers to avoid us having to thread the stuff around manually.
19:25:05 <koz_> (the instances help with this too)
19:28:57 <Henson> koz_: in the case of "ErrorT e (StateT s Identity) a" which is equivalent to "s -> (Either e a, s)", does this retain the ability to short circuit in case of a failure?  I want the state computation to stop immediately when a failure happens.  Does the monad ordering matter for that properly?
19:29:08 <koz_> Very much so.
19:29:14 <koz_> Look at the type of what you've just given me.
19:29:26 <koz_> s -> (Either e a, s) will keep a state around even if you fail.
19:29:36 <koz_> If at the point of failure, you no longer care, you want the other way around.
19:30:02 <koz_> @unmtl StateT s (ErrorT e Identity) a
19:30:02 <lambdabot> s -> Either e (a, s)
19:30:13 <koz_> Here, if you hit an error, you lose the state, and _must_ stop computing.
19:30:24 <koz_> Literally, there's no state for you to pass along to _continue_ with.
19:30:28 <acubakari> Hi, I just started learning haskell yesterday
19:30:38 <dmwit> Both must stop computing.
19:30:54 <Henson> koz_: I was going to say that you can't inspect the state that caused the failure, but you can simply include the state-at-failure in the error message you return.
19:30:57 <dmwit> With `s -> (Either e a, s)`, there is still no `a` to pass to the continuation in case of failure.
19:31:13 <koz_> dmwit: But the state can still be modified.
19:31:19 <dmwit> no
19:31:24 <dmwit> Because the continuation does not run.
19:31:32 <dmwit> *cannot* run
19:31:44 <koz_> OK, I'm now rather curious as to why it's not gonna run.
19:31:53 <koz_> Since I clearly don't understand this as well as I thought I did.
19:32:07 <dmwit> Because it is a function that takes an `a`, and we have no `a` to pass it.
19:32:33 <koz_> But s -> (a, s) doesn't take an 'a'. Am I misunderstanding something?
19:32:37 <dmwit> Kind of a "I have no mouth but I must scream"-y sentiment.
19:32:43 <MarcelineVQ> :t (>>=)
19:32:45 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:32:52 <koz_> Oooooh.
19:32:55 <koz_> Right, I see.
19:33:02 <Henson> dmwit: but it doens't need the a to continue running, does it?  It needs the s.  Only the very last a is relevant for the return value.
19:33:12 <dmwit> Henson: different `a`
19:33:24 <dmwit> The `a` I'm talking about here is the one from `(>>=)`'s type.
19:33:37 <Axman6> what you really have there is (s -> (a,s)) -> (a -> s -> (b,s)) -> (s -> (b,s))
19:33:42 <koz_> So basically, does this mean the stacking order _only_ determines whether the state is 'lost' on error?
19:33:53 <koz_> (at least in this particular case)
19:33:57 <Axman6> but if you stick some Either in there, you don't have no a's no more when you fail
19:34:09 <Axman6> yes
19:34:11 <dmwit> More or less. It therefore affects what catchError does.
19:34:35 <koz_> :t catchError
19:34:37 <lambdabot> MonadError e m => m a -> (e -> m a) -> m a
19:34:57 <koz_> dmwit: How does it affect it?
19:35:06 <dmwit> One catchError *must* reset the state, just by looking at the types.
19:35:15 <dmwit> The other error *may* reset the state. I don't remember whether it does or not.
19:35:29 <dmwit> s/error/catchError/
19:35:49 <koz_> I see. That makes a lot of sense, and was very educational!
19:36:13 <koz_> This is why I love #haskell - my mistakes get corrected and I learn new things. :P
19:38:34 <Henson> I'll see what progress I can make on this.  Thank you koz_, dwmit, and others for your input.
19:38:59 <koz_> Henson: No problem. If you're stuck, let us know, and we'll try our best to help.
19:39:37 <Henson> I often find Haskell's typing to be so complicated that trying to do things in an elegant and facy way is almost beyond my understanding, or takes several days of staring at the screen and reading manuals and guides to figure out :-(
19:39:57 <koz_> Henson: It _does_ get easier.
19:40:04 <koz_> It's only complicated because it's honest.
19:40:13 <koz_> (other languages are 'simple', but they lie through their teeth constantly)
19:40:19 <koz_> Alternatively, you _can_ just do everything in IO.
19:40:28 <koz_> (which is basically what implictly happens everywhere else)
19:40:28 <Henson> and I realize that the typing of this problem isn't so complicated.  A couple years ago when I was reading through the Real World Haskell book's Monad Transformer chapter I might have understood it a little better, but I'm very rusty on Monad Transformers.
19:40:59 <koz_> Henson: It's mostly just practice. It took me quite a while to have all this 'make sense' on an intuitive level, but you can get surprisingly far just by following the types.
19:41:15 <koz_> (and as you can see above, I'm _still_ not entirely there yet)
19:43:05 <Henson> koz_: oh my dear lord.  I found a bug in one of my Python programs today because I did something with datetime objects.  For example "(t2-t1).total_seconds < 0" is always False, regardless of what the time variables are, because I forgot the () at the end of total_seconds, and a function is always greater than an integer, apparently, in Python.
19:43:29 <koz_> Henson: Welcome to why I stick to Haskell. :P
19:43:45 <Axman6> ...
19:44:23 <Henson> I love Haskell for it's type safety, strictly functional approach, and all the other things, but find the typing to be very difficult to fathom sometimes.
19:44:35 <koz_> Henson: Again, practice, follow the types.
19:44:53 <koz_> It's either that, or enjoy fixing weird runtime issues.
19:45:00 <koz_> You spend the same amount of time, just in different places.
19:45:23 <koz_> (unless you care about the impression of doing more 'work' more quickly, but to be honest, I put little stock in that)
19:45:32 <Axman6> but only the latter breaks prod regularly
19:45:39 <koz_> Lol, yeah.
19:46:33 <Axman6> it's very rare for our Haskell to break, but very common for infrastructure to break, since we don't have a good typesafe language for describing out stacks
19:47:43 <Henson> I'd love to stick around and chat, but I gotta take the garbage out before bed time :-(  Thanks everyone for your help.
19:47:55 <koz_> Henson: No worries - enjoy!
19:51:26 <heatsink> Wasn't Backpack supposed to describe module interfaces?
19:53:41 <koz_> heatsink: I think Axman6 was referring to a slightly different problem.
19:54:57 <heatsink> mm
19:55:05 <Axman6> stack = AWS CloudFormation stack
20:22:48 <maerwald> what a bummer pattern matching on Excepts is not exhaustive
20:22:56 <maerwald> makes the whole library useless, imo
20:25:06 <Axman6> excepts?
20:26:37 <maerwald> https://docs.haskus.org/variant/excepts.html
20:27:34 <maerwald> https://gist.github.com/hasufell/0f9d5fb403e2211e4aeb3d9c11e5a12e#file-excepts-hs-L49
20:30:19 <Axman6> I tend to use classy prisms for that sort of thing
20:30:43 <Axman6> (MonadError e m, AsParseError e) => m Int
20:31:32 <koz_> I always found the 'classy'
20:31:35 <koz_> prefix funny.
20:31:45 <koz_> It's like 'as opposed to what, _trashy_-prisms'?
20:31:58 <maerwald> Axman6: you have an elaborate example on the use?
20:34:58 <Axman6> https://github.com/data61/Mirza/blob/master/projects/or_scs/src/Mirza/OrgRegistry/Handlers/Location.hs#L48 is something I worked on a year ago. member t xs is just shorthand for a being all the classes in xs
20:37:54 <maerwald> Axman6: can you emulate checked exceptions, where you have a guarantee that the type level list of errors is empty after running a "handler"?
20:38:19 <Axman6> I don't believe so
20:50:54 <maerwald> I also don't see a way to do this with excepts, even if you write something like: catchAllE' :: Monad m => (V es -> Excepts '[] m a) -> Excepts es m a -> Excepts '[] m a 
20:51:14 <maerwald> You still have to match on VLeft in the end when you run it, because it's not a GADT
20:55:09 <Axman6> I did a think years ago which allowed you to do that, using indexed monads: https://gist.github.com/axman6/19adc08a809d919a2efb
20:55:13 <maerwald> all the matching is done with pattern synonyms
21:05:02 <maerwald> Axman6: newtype ThrowsI i j a = ThrowsI (IO a) -- I don't get the difference between i and j
21:07:29 <maerwald> ijoin :: IxMonad m => m i j (m j k a) -> m i k a -- lolol
21:11:51 <Axman6> i si the input set of exceptions, and j is the output set
21:32:27 <iqubic> Why is there no function of the type "(a -> bool) -> Map k a -> [(k, a)]"
21:33:01 <iqubic> I would love a function of that type.
21:33:50 <heatsink> :t const Map.assocs
21:33:52 <lambdabot> error:
21:33:52 <lambdabot>     Not in scope: ‘Map.assocs’
21:33:52 <lambdabot>     Perhaps you meant one of these:
21:34:52 <iqubic> Oh, very very clever.
21:35:26 <Axman6> Map.toList . Map.filter f?
21:35:44 <iqubic> Axman6: Does that even typecheck?
21:36:31 <iqubic> I want to get a list of all the entries where the value satisfies my predicate.
21:40:24 <monochrom> You are just rejecting Axman6's perfect correct answer just based on a completely wrong speculation.
21:41:15 <iqubic> I know.
21:42:45 <monochrom> We need to crack down on unscientific programmers who make easily falsifiable speculations.
21:43:17 <Axman6> There's also probably a lensy way to do it, for bonus points
21:43:24 <monochrom> Because even flat-earthers and anti-vaxxers do more observations and read more papers than those programmers.
21:43:28 <Axman6> % :t ifiltered
21:43:29 <yahb> Axman6: (Indexable i p, Applicative f) => (i -> a -> Bool) -> Optical' p (Indexed i) f a a
21:43:35 <iqubic> How does that work?
21:48:57 <maerwald> monochrom: flat-earthers are surprisingly scientific in a negative sense
21:49:27 <Axman6> % Map.fromList (zip "abcde" [1..]) ^@.. ifiltered (\_i a -> even a)
21:49:27 <yahb> Axman6: ; <interactive>:67:1: error:; Not in scope: `Map.fromList'; Perhaps you meant one of these: `M.fromList' (imported from Data.Map), `S.fromList' (imported from Data.Set), `IM.fromList' (imported from Data.IntMap); No module named `Map' is imported.
21:49:33 <Axman6> % M.fromList (zip "abcde" [1..]) ^@.. ifiltered (\_i a -> even a)
21:49:34 <yahb> Axman6: ; <interactive>:68:37: error:; * Couldn't match type `Indexed i a (Const (Endo [(i, a)]) a)' with `M.Map Char Integer -> Const (Endo [(i, a)]) (M.Map Char Integer)'; Expected type: IndexedGetting i (Endo [(i, a)]) (M.Map Char Integer) a; Actual type: Optical' (Indexed i) (Indexed i) (Const (Endo [(i, a)])) a a; * Possible cause: `ifiltered' is applied to too many arguments; I
21:50:10 <Axman6> u wot?
21:50:15 <maerwald> also, industry doesn't want scientific programmers most of the time, just energetic ones that can be burned out :P
21:51:02 <Axman6> % :t (^@..)
21:51:02 <yahb> Axman6: s -> IndexedGetting i (Endo [(i, a)]) s a -> [(i, a)]
21:52:24 <cipharius> unless it's a more scientific industry. Also labs have plenty of freedom on choosing your own tools, but they don't pay as well as industries
21:54:05 <maerwald> keeping ones physical health and mental sanity as a programmer is quite a challenge :P
22:14:07 <LevyElara[m]> maerwald: physical should be easier since you can always put aside an hour or so for it before working each morning and use Haskell to manage meals (meals are constraints on resources after all thus a constraint satisfaction problem). Better to force those thunks before they build up
22:15:28 <monochrom> Are you saying that my belly is a thunk?!  (hehe)
22:16:04 <LevyElara[m]> It's a space leak
22:41:57 <toast52> Hi all. I've been doing this years advent of code in haskell, and recently I decided to redesign my intcode machine
22:43:17 <toast52> It currently looks like this: `intcode :: [Integer] -> [Integer] -> IO [Integer]` where it takes in the program, a lazy list of inputs and outputs a lazy list of outputs which can be fed back into the machine as inputs
22:45:12 <nil> heh, that's what mine looked like *before* i redesigned it
22:45:48 <toast52> But currently the output comes out in the "reversed" order since I build it up recursively by consing the subsequent outputs to the list of outputs
22:46:27 <amalloy> toast52: are you sure your output list is actually lazy?
22:46:37 <nil> toast52: https://git.monade.li/aoc/tree/src/2019/IntcodeIO.hs
22:47:14 <nil> output laziness is done with unsafeInterleaveIO here
22:47:39 <toast52> Yeah thats what is giving me problems now.. this design worked really well for some of the problems with mfix to tie the knot but in day 13 it kinda falls apart rather fragily
22:51:12 <toast52> hmmm. So currently my problem is that I need to reverse the output before I can operate on it and feed it back to the input
22:52:07 <nil> in other words, your output list isn't lazy
22:52:14 <toast52> How does unsafeInterleaveIO allow the output to be streamed?
22:52:47 <nil> it makes the rest of the computation lazy, so that you can access the first element without forcing the rest to be computed
22:53:03 <nil> https://hackage.haskell.org/package/base-4.12.0.0/docs/System-IO-Unsafe.html#v:unsafeInterleaveIO
22:54:43 <toast52> but the first element is still at the very end of the list. is that fine?
22:55:26 <nil> it's not
22:55:57 <toast52> And is there a neater solution to streaming output in the correct order as they are produced 
22:57:09 <toast52> I'm considering going back to my uglier single step solution rather than trying to build this stream of inputs
22:58:07 <nil> i'm not aware of a better solution than using unsafeInterleaveIO, at least if you're gonna do things in IO. but it is producing the list in the right order
22:59:15 <toast52> ok let me take a closer look at your solution
23:01:01 <toast52> oh i see how your end of the list is given at the end of the program. Mine starts as an empty list and builds up, thus producing reversed outputs
23:03:17 <toast52> Actually regarding doing things in IO, I realise after changing to the streamed input I'm only using IO for the mutable vector which holds the program, so I could switch easily to ST and have a pure interface
23:11:34 <iqubic> Well, this isn't doing what I want it too.
23:11:35 <iqubic> groupBy ((==) `on` fst)
23:12:56 <olligobber> % groupBy ((==) `on` fst) [(1,2),(1,3),(2,3),(1,2)]
23:12:57 <yahb> olligobber: [[(1,2),(1,3)],[(2,3)],[(1,2)]]
23:13:11 <iqubic> [("BI",V2 2 39),("MX",V2 2 53),("MX",V2 94 39),("BI",V2 94 83)] is the list I have. I want turn that into groups where the first element of the tuple is equal.
23:13:17 <iqubic> But that's not happening.
23:13:41 <iqubic> olligobber: See how that put all the elements into 3 lists?
23:13:48 <iqubic> I want that in two lists.
23:14:15 <olligobber> ah, you want partition, not groupBy
23:14:19 <iqubic> I do?
23:14:38 <iqubic> No, that only makes two groups.
23:14:40 <MarcelineVQ> or just to sort first if you're not after exactly two groups
23:14:49 <iqubic> No I'm not.
23:15:17 <nil> i'd use Data.Map.fromListWith (++)
23:15:18 <olligobber> oh, I see what you want
23:15:41 <iqubic> nil: What does that do?
23:15:42 <olligobber> yeah, doing groupBy after sorting is what you want
23:15:51 <olligobber> or using a map
23:16:06 <nil> it builds a map in which the keys are your two-letter groups and the values are lists of V2's
23:16:16 <iqubic> Does that work?
23:16:18 <nil> well, you need to wrap each V2 in a singleton list first
23:16:24 <iqubic> Yeah. I know.
23:16:43 <nil> M.fromListWith (++) [(k, [v]) | (k, v) <- yourList]
23:17:01 <olligobber> iqubic, I recognise this data, good luck with task 2
23:17:17 <olligobber> I think I'm going to have to implement A*
23:17:17 <dsal> iqubic: Are you grouping warps?
23:17:30 <iqubic> dsal: I am indeed.
23:17:31 <dsal> iqubic: I just did   m (_,[v1, v2]) = [(v1,v2), (v2,v1)]
23:17:33 <nil> i wish there was something like  M.fromListWithInitial (:) [] yourList
23:17:55 <nil> fromListWithInitial :: (a -> b -> b) -> b -> [(k, a)] -> Map k b
23:17:55 <olligobber> dsal, I had a portal pair with keys "BB"
23:18:31 <iqubic> dsal: How does that work?
23:18:36 <dsal> Neat.  Mine all seem different.
23:19:01 <dsal> iqubic: Map.fromList . concatMap m . Map.toList . portalRev       That's most of   warpMap :: Map Point PortalID -> Map Point Point
23:19:03 <iqubic> currently I have "[(String, Pos)]" which is close, but not quite what I want.
23:19:38 <dsal> er, portalRev makes   [PortalID, Point]
23:19:46 <iqubic> And I'm not sure what to do with that (String, V2 Int)
23:19:46 <olligobber> I'm considering giving you advice that would make this easier and help you with task 2, but I want you to go through the same pain as me
23:20:09 <dsal> 2 wasn't much different from one.
23:20:37 <iqubic> dsal: I have a way of generating [(String, Point)] for my maze.
23:20:38 <olligobber> dsal, depends how you differentiated each end of the portal
23:20:49 <iqubic> I don't have a way of pairing those up.
23:21:11 <olligobber> dsal, also, my task 2 is taking way longer to run than task 1, I thought using A* would fix that, but maybe I just made some other error
23:21:12 <dsal> Map.fromListWith (<>) [(v,[k]) | (k,v) <- yourThing]
23:21:34 <iqubic> What is the type of the output there?
23:21:37 <dsal> olligobber: Yeah, mine's a good deal longer.  It goes further.  I haven't profiled.
23:21:56 <iqubic> Also, I think you have your k and v backwards.
23:22:02 <olligobber> dsal, approximately how long did it take?
23:22:13 <dsal> iqubic: Yeah, mine are backwards, so that's possible.
23:22:15 <dsal> olligobber: 5s for 2
23:22:38 <olligobber> ok, mine was running for this whole conversation and didn't finish, so I think there's some mistake. did you use dijkstra?
23:22:57 <dsal> Map.fromListWith (<>) [(k,[v]) | (k,v) <- [("AA", (1,1)), ("BB", (1,2)), ("AA", (3,3))]
23:23:01 <dsal> > Map.fromListWith (<>) [(k,[v]) | (k,v) <- [("AA", (1,1)), ("BB", (1,2)), ("AA", (3,3))]
23:23:02 <lambdabot>  <hint>:1:88: error:
23:23:03 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
23:23:07 <dsal> typing is hard
23:23:40 <dsal> > M.fromListWith (<>) [(k,[v]) | (k,v) <- [("AA", (1,1)), ("BB", (1,2)), ("AA", (3,3))]]
23:23:43 <lambdabot>  fromList [("AA",[(3,3),(1,1)]),("BB",[(1,2)])]
23:23:55 <dsal> olligobber: Yeah, I'm using dijkstra
23:24:49 <iqubic> dsal: That's great. How do you use that?
23:25:07 <dsal> I ended up just using it to build the Point -> Point map
23:25:19 <iqubic> Yeah, I'm going to do that too.
23:26:25 <iqubic> This feels like the most horrific line of code ever: "M.toList $ M.fromListWith (++) [(k, [v]) | (k, v) <- filtered]"
23:27:07 <iqubic> I don't like it.
23:28:27 <dsal> > let m [v1,v2] = [(v1,v2),(v2,v1)]; m _ = [] in    concatMap m $  M.elems $ M.fromListWith (<>) [(k,[v]) | (k,v) <- [("AA", (1,1)), ("BB", (1,2)), ("AA", (3,3))]]
23:28:30 <lambdabot>  [((3,3),(1,1)),((1,1),(3,3))]
23:29:02 <olligobber> I checked a few steps of dijkstra and it seems to be working properly, not sure why it's taking so long to get the final answer
23:31:23 <dsal> All 112 tests passed (13.69s)
23:31:25 <dsal> I've got some work to do.
23:31:36 <dsal> But I think I'll sleep.  Haven't been doing that enough lately.
23:39:23 <nil> iqubic: are you sure you need M.toList?
23:39:59 <iqubic> Where?
23:40:34 <olligobber> ok, I found a path manually, no idea why it's taking so long for dijkstra to find the shortest..
23:40:40 <iqubic> Oh yeah. I'm not using that horrid line of code. I've switched to this:
23:40:41 <iqubic> http://dpaste.com/164DGHP
23:41:16 <nil> that looks pretty much the same
23:41:34 <iqubic> Do you have any comments on it?
23:42:04 <nil> what's in `ends`?
23:42:29 <iqubic> ends is a list of all the labels and the locations they are next to.
23:43:15 <iqubic> [("BI", V2 2 40), ("BI", V2 40 2)...] basically.
23:43:16 <nil> it's a Map
23:43:20 <iqubic> Yes.
23:43:25 <nil> you can't have duplicate keys in a map
23:43:32 <iqubic> Oh. Right.
23:44:27 <iqubic> Gotta change that too "[(String, Pos)]"
23:44:29 <Synthetica> (For Pandoc/pandoc-types) is there a way to use walkM to walk over all CodeBlocks and inline Code simultaneously? 
23:44:53 <iqubic> Can't make it a map or else I lose half the portal entrances/exits.
23:46:26 <olligobber> yeah, something is going very wrong, the path I found has a length that's 4 digits, but my dijkstra's couldn't find a path with any 4 digit length... clearly I did something wrong
23:47:04 <olligobber> in fact it got to length 1195169 before I killed it
23:53:13 <dminuoso_> This is weird. I regularly hit into corner cases where I wish impredicativity was a thing.
23:54:54 <iqubic> I'm a really big idiot.
23:55:03 <iqubic> I'm a really really really big idiot.
23:56:02 <dminuoso_> Can we put that into lambdabots knowledge base?
23:56:21 <olligobber> I should test this on smaller input
23:56:38 <iqubic> I'm trimming my input before I work with it.
23:56:46 <iqubic> So that's not good.
23:56:59 <iqubic> :t Data.Text.Strip
23:57:01 <lambdabot> error:
23:57:01 <lambdabot>     Not in scope: data constructor ‘Data.Text.Strip’
23:57:01 <lambdabot>     No module named ‘Data.Text’ is imported.
23:57:43 <olligobber> it worked with the second sample, why doesn't it work with the actual input?
23:57:57 <dminuoso_> Is there an idiomatic way to turn a prism into a predicate that merely tells me whether it fails or not?
23:58:24 <dminuoso_> (In order to use say _Left to filter a list of [Either Int Bool] into [Either Int Bool] that only contains left elements)
23:58:54 <olligobber> dminuoso_, do {Left x <- list; return (Left x)}
23:59:17 <olligobber> or just filter predicate list
23:59:26 <dminuoso_> olligobber: I want to filter something using a prism.
23:59:32 <kangyu> :t "hello"
23:59:34 <lambdabot> [Char]
23:59:36 <dminuoso_> It's more complicated in my case
23:59:38 <olligobber> no idea what a prism is
