00:02:22 <koz_> (<$>) <$> (,) g -- thanks @pl
00:02:50 <koz_> :t (<$>) <$> (,)
00:02:52 <lambdabot> Functor f => a1 -> f a2 -> f (a1, a2)
00:03:14 <rotaerk> :t fmap <$> (g,)
00:03:17 <lambdabot> error:
00:03:17 <lambdabot>     • Couldn't match type ‘(t0, t)’ with ‘a -> b’
00:03:17 <lambdabot>       Expected type: t -> a -> b
00:03:26 <rotaerk> :t \g -> fmap <$> (g,)
00:03:28 <lambdabot> error:
00:03:28 <lambdabot>     • Couldn't match type ‘(t, t1)’ with ‘a -> b’
00:03:28 <lambdabot>       Expected type: t1 -> a -> b
00:03:39 <koz_> rotaerk: I don't think lambdabot is TupleSections aware.
00:03:54 <rotaerk> hmm
00:04:22 <Ariakenom> % :t :t fmap <$> (g,) 
00:04:23 <yahb> Ariakenom: ; <interactive>:1:1: error: parse error on input `:'
00:04:24 <hololeap> koz_: ask comes from MonadReader, and i can only assume that they force m to be a Monad to fit the convention of Monad* classes
00:04:26 <Ariakenom> % :t fmap <$> (g,) 
00:04:26 <yahb> Ariakenom: ; <interactive>:1:11: error: Variable not in scope: g
00:04:48 <Ariakenom> % :t \g -> fmap <$> (g,) 
00:04:48 <yahb> Ariakenom: ; <interactive>:1:16: error:; * Couldn't match type `(t, t1)' with `a -> b'; Expected type: t1 -> a -> b; Actual type: t1 -> (t, t1); * In the second argument of `(<$>)', namely `(g,)'; In the expression: fmap <$> (g,); In the expression: \ g -> fmap <$> (g,); * Relevant bindings include g :: t (bound at <interactive>:1:2)
00:05:08 <Ariakenom> % :set -XTupleSections
00:05:08 <yahb> Ariakenom: 
00:05:10 <Ariakenom> % :t \g -> fmap <$> (g,) 
00:05:10 <yahb> Ariakenom: ; <interactive>:1:16: error:; * Couldn't match type `(t, t1)' with `a -> b'; Expected type: t1 -> a -> b; Actual type: t1 -> (t, t1); * In the second argument of `(<$>)', namely `(g,)'; In the expression: fmap <$> (g,); In the expression: \ g -> fmap <$> (g,); * Relevant bindings include g :: t (bound at <interactive>:1:2)
00:05:26 <rotaerk> it's just wrong
00:06:46 <rotaerk> (<$>) <$> x == fmap fmap x
00:16:33 <MarcelineVQ> :t fmap . (,)
00:16:35 <lambdabot> Functor f => a1 -> f a2 -> f (a1, a2)
00:18:27 <koz_> MarcelineVQ: Woah.
00:18:32 <koz_> So that could be rephrased...
00:18:37 <koz_> :t (.) <$> (,)
00:18:39 <lambdabot> a1 -> (a2 -> b) -> a2 -> (a1, b)
00:18:50 <koz_> No wait, that's not it.
00:18:58 <MarcelineVQ> :t fmap fmap (,)
00:19:00 <lambdabot> Functor f => a1 -> f a2 -> f (a1, a2)
00:19:10 <koz_> :t (<$>) (<$>) (,)
00:19:12 <lambdabot> Functor f => a1 -> f a2 -> f (a1, a2)
00:19:14 <koz_> There we go.
00:20:09 * hackage http-io-streams 0.1.2.0 - HTTP client based on io-streams  https://hackage.haskell.org/package/http-io-streams-0.1.2.0 (HerbertValerioRiedel)
00:21:48 <koz_> :t (.) (<$>) (,)
00:21:50 <lambdabot> Functor f => a1 -> f a2 -> f (a1, a2)
00:21:53 <koz_> Best one so far.
00:26:39 * hackage connections 0.0.2.1 - Partial orders & Galois connections.  https://hackage.haskell.org/package/connections-0.0.2.1 (cmk)
00:31:29 <edwardk> :t fmap fmap (,)
00:31:31 <lambdabot> Functor f => a1 -> f a2 -> f (a1, a2)
00:31:37 <koz_> Hi edwardk!
00:31:40 <edwardk> yo
00:33:39 * hackage rings 0.0.2.1 - Rings, semirings, and dioids.  https://hackage.haskell.org/package/rings-0.0.2.1 (cmk)
01:05:09 * hackage advent-of-code-api 0.2.5.0 - Advent of Code REST API bindings and servant API  https://hackage.haskell.org/package/advent-of-code-api-0.2.5.0 (jle)
01:06:16 <iqubic> That's what you love to see. An errant GHC process spirals out of control and eats up your RAM. Lovely.
02:26:46 <dmj`> jle`: we basically did the same thing, n^2 search, getter / setter . You used Seq I used Vector. Lovely use of splitOn
02:34:15 <jle`> dmj`: my actual implementation is log(n) ;)
02:34:22 <jle`> i used an exponential search
02:34:27 <dmj`> jle`: what ?!!
02:34:46 <jle`> but also i probably should have used Vector too, since it has better indexing anyway
02:35:08 * yushyin used Vector
02:35:25 <dmj`> vector has that nice Data.Vector.(//) to update a pure vector. It's a great function.
02:37:10 <yushyin> ok /me used STVector ^^
02:37:41 <dmj`> jle`: i was lazy and just did forM_ (liftA2 (,) range range) $ \(noun,verb) -> 
02:37:45 <dmj`> yushyin: fancy :)
02:38:25 <dmj`> I feel bad for people that use other languages and have to spend half their time doing imperative parsing
02:38:35 <AWizzArd> Is there a lib that helps to deep-merge Aeson Values? I want to load a config from a file, but additionally allow env vars, which can override what is in the file.
02:38:49 <merijn> dmj`: Word
02:38:58 <phadej> AWizzArd: I have in https://hackage.haskell.org/package/aeson-extra-0.4.1.3/docs/Data-Aeson-Extra-Merge.html
02:39:14 <AWizzArd> phadej: ah cool, will have a look!
02:39:22 <merijn> One of the best things of replacing my python research code with Haskell is that I could more easily output more structured data since I can now use megaparsec to read it back in :)
02:39:28 <dmj`> AWizzArd: you need like a recursive unionWith
02:41:19 <yushyin> dmj`: just used STVector because I failed to see a cool functional solution so I just did it with my favorite imperative language
02:41:29 <merijn> yushyin: ;)
02:41:31 <Ariakenom> map read . lines is usually my parsing. how do you do fellow haskellers :]
02:41:55 <merijn> yushyin: Everyone knows MagicHash, Storable and mutable Vector is all you need to write C :p
02:42:14 <dmj`> Ariakenom: map read . lines , the most powerful command in the haskell ecosystem indeed
02:42:39 <jle`> dmj`: just pushed a change with the exponential search version, https://github.com/mstksg/advent-of-code-2019/blob/master/reflections.md#day-2
02:42:54 <dmj`> yushyin: https://github.com/dmjio/advent-of-code-2019/blob/master/2/2.hs#L49
02:43:09 * dmj` looks at jle's code
02:43:47 <Ariakenom> :t \solve -> interact (show . solve . map read . lines)
02:43:48 <dmj`> jle`: this a binary search ?
02:43:49 <lambdabot> (Show a, Read b) => ([b] -> a) -> IO ()
02:43:55 <jle`> dmj`: it's an exponential search
02:44:04 <jle`> which uses binary search at some point
02:44:22 <Ariakenom> the complicated structure of my code
02:46:50 <jle`> dmj`: i used it before i realized that there was a max bound of 99
02:47:08 <iqubic> My code is simple, I think.
02:48:04 <iqubic> I do use Seq.index with no bounds checking, so that's cool.
02:48:54 <dmj`> jle`: ah, I wasn't sure if the output of running the program was a linear function of the input, otherwise I would have tried binary search. 
02:49:02 <jle`> dmj`: ah with a binary search (using 99 as upper bound), it's even better
02:49:10 <jle`> dmj`: yeah, i checked to make sure it was monotonic first
02:49:17 <dmj`> jle`: you would
02:49:32 <iqubic> Should I re-write my code to use a mutable data structure or not?
02:49:51 <dmj`> jle`: I was afraid the puzzle input would be too large and brute force wouldn't be feasible, like some previous puzzles
02:50:08 <iqubic> Yeah, me too.
02:50:18 <iqubic> I was able to brute force it.
02:50:52 <dmj`> iqubic: nice
02:50:54 <iqubic> I used a list comprehension to do a sort of loop.
02:51:33 <dmj`> iqubic: I doubt a mutable data structure is needed, I originally used a list, which was great, then refactored to a vector after finding the solutions
02:51:45 <jle`> dmj`: yeah, i didn't want to brute force it at first either :|
02:52:04 <dmj`> jle`: premature optimization is the root of all evil - Donald Knuth
02:53:00 <dmj`> donald knuth is the santa claus of advent of code
02:53:14 <iqubic> dmj`: I used Data.Sequence from containers.
02:53:22 <iqubic> Which worked well enough.
02:53:26 <dmj`> iqubic: that's what jle` used
02:53:45 <dmj`> I considered that, but didn't want to fiddle with qualified imports because I don't like typing
02:53:47 <iqubic> I know.
02:54:06 <merijn> Premature optimisation is the root of all evil, but not all optimisation ahead of time is premature
02:54:30 <merijn> I'm a firm believer that optimisation is a hollistic process and not thinking about it ahead of time WILL doom you
02:54:42 <iqubic> I originally used an "IntMap Int" but then I realized how stupid that was and quickly switched to "Seq Int"
02:55:06 <jle`> IntMap Int isn't stupid D:
02:55:11 <iqubic> It isn't?
02:55:14 <iqubic> I thought it was.
02:55:21 <jle`> you must have very high standards
02:55:26 <iqubic> Oh. Well...
02:56:54 <dmj`> merijn: I guess it's an art not a science, depends on your inputs. It should be considered, true. Catting the file showed 100 numbers, so I wasn't too scared of the list monad.
02:57:46 <jle`> especially since intcode runtime is predictably O(n) in length of program (for reasonable inputs)
02:58:02 <iqubic> It is currently O(n)
02:58:08 <dmj`> almost reached for lens (ix) when setting a value on a list, but didn't want to write the import, used splitAt instead
02:58:23 <jle`> pls not too many spoilers here though D:
02:58:24 <iqubic> Who knows what op codes will be added in future days.
02:58:50 <iqubic> I don't even have Lens listed as a dependency in my cabal file.
02:58:59 <dmj`> I don't even have a cabal file :)
02:59:14 <iqubic> Oh?
02:59:16 <dmj`> nix-shell -p 'haskellPackages.ghcWithPackages (p: with p; [ vector ])'
02:59:20 <iqubic> Ah. I see.
02:59:28 <iqubic> I'm using nix-shell too.
02:59:29 <dmj`> voila, ad-hoc ghc-pkg lists 
02:59:42 <iqubic> But I'm using Cabal2Nix
03:00:00 <dmj`> too much work
03:00:08 <dmj`> you could use callCabal2nix too
03:00:09 * hackage ngx-export-tools-extra 0.1.0.1 - More extra tools for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-tools-extra-0.1.0.1 (lyokha)
03:00:31 <jle`> nixCablix2CabalCall
03:00:37 <dmj`> iqubic: I don't event set version bounds any more
03:00:38 <dmj`> jle`: lol
03:01:09 <dmj`> caNix2Call2bal
03:01:29 <iqubic> dmj`: I actually do use callCabal2Nix
03:01:33 <__monty__> You can add that nix-shell call as a shebang (almost verbatim) : )
03:02:05 <dmj`> jle`: I almost used a State [Int] a, since the VM is a stack machine
03:02:38 <iqubic> It's not really a stack machine.
03:02:40 <dmj`> that classic LYAH example ...
03:03:07 <iqubic> Which one?
03:03:07 <dmj`> iqubic: you're right, its more of a register machine
03:03:16 <dmj`> it's a machine, of sorts
03:03:16 <iqubic> I've not read LYAH.
03:03:26 <dmj`> @google learn you a haskell
03:03:28 <lambdabot> http://www.google.com/url?q=http://learnyouahaskell.com/
03:03:28 <lambdabot> Title: Уведомление о переадресации
03:03:31 <jle`> yeah, you could use MaybeT (State [Int]) and use 'many' to get the loop-until-failure behavior
03:03:36 <jle`> i mean um sorry no spoilers
03:03:45 <iqubic> I didn't do that.
03:04:13 <dmj`> jle`: if someone is reading this with the hopes of getting ahead in aoc, they're already out the race
03:04:44 <jle`> the point is more that they want to try to figure it out themselves D:
03:04:56 <__monty__> dmj`: Not all of us do AoC to compete.
03:05:20 <dmj`> that's fair
03:05:58 <__monty__> ##adventofcode-spoilers is great for such discussion if you can keep it language-generic. And you could always start a spoilerful #haskell-aoc.
03:53:35 <Putonlalla> I can't participate in these things, because I always overengineer the solutions so severely.
04:00:27 <__monty__> Putonlalla: Maybe participate using an obscure language? The difficulty of even getting a solution may offset that impulse.
04:04:16 <Putonlalla> It's even worse, because then I digress into writing a utility library for said language.
04:05:04 <boxscape> Maybe use a language that doesn't allow you to use libraries :)
04:06:06 <Putonlalla> In that case the first thing you would do is write a virtual machine for a stronger language.
04:06:06 <__monty__> *Or* use a language that's desperate for more libraries. At least the users will be grateful.
04:07:26 <Putonlalla> It's all fun and games until the more important things you delayed catch up to you. I made this mistake with Project Euler already.
04:27:23 <__monty__> AoC is a lot more fun tha PE though.
04:31:12 <jneira_> I like more when you have to fix / improve existing open source projects (with issues relatively simple and suited for newcomers) 
04:32:03 <jneira_> maybe too much changelling if you are an absolute beginner in the lang itself
04:33:29 <boxscape> I never noticed this before but it seems inconsistent that you can have regular function definition syntax with 0 parameters but not lambda expressions with 0 arguments
04:33:40 <boxscape> not that they would be particularly useful
04:37:02 <fpbgnr> Does Haskell have any alternative to head where you can specify a default value ([]) in case the list is empty?
04:39:22 <hpc> > foldr const "z" "abc"
04:39:25 <lambdabot>  error:
04:39:25 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
04:39:26 <lambdabot>        Expected type: [[Char]]
04:39:33 <hpc> :(
04:39:40 <dminuoso> fpbgnr: pattern matching.
04:39:56 <hpc> > foldr const 'z' "abc"
04:39:58 <lambdabot>  'a'
04:40:01 <hpc> > foldr const 'z' ""
04:40:03 <lambdabot>  'z'
04:40:04 <jle`> fpbgnr: i use listToMaybe
04:40:07 <lavalike> > let head' x xs = fromJust $ listToMaybe $ take 1 xs <|> [x] in (head' 7 [1..10], head' 7 [])
04:40:10 <lambdabot>  (1,7)
04:40:15 <dminuoso> Haha. This is so #haskell
04:40:34 <merijn> lavalike: What's the point of using listToMaybe if you're just going to use fromJust? >.<
04:40:36 <lavalike> hpc: neat
04:40:50 <amx> fpbgnr: protolude has headDef :: a -> [a] -> a ; prelude does not
04:40:51 <merijn> Just use head, then
04:40:52 <lavalike> merijn: I am providing the invariant it's ok!
04:41:11 <merijn> lavalike: Sure, but you're just using head with more steps
04:41:23 <merijn> lavalike: Could just as well do "head $ take 1 xs <|> [x]"
04:41:28 <merijn> And it'd be exactly as safe
04:41:40 <fpbgnr> dminuoso: That's an option, of course, just wanted to know whether there is a more elegant inline version (which one could write by themselves, of course) :D
04:41:48 <lavalike> merijn: O_O doh, you're right
04:41:49 <merijn> Or, you know "fromMaybe x (listToMaybe xs)"
04:41:59 <lavalike> I cornered myself there
04:42:04 <merijn> Which is both simpler and more obvious
04:42:11 <lavalike> gotta agree!
04:42:18 <merijn> > listToMaybe [1..]
04:42:21 <lambdabot>  Just 1
04:42:23 <merijn> > listToMaybe []
04:42:26 <lambdabot>  Nothing
04:42:31 <hpc> whatever larger problem you're trying to solve can probably be rephrased to not require this operation, as well
04:43:01 <dminuoso> fpbgnr: Move it out into a where binding, and not worry about it.
04:43:06 <lavalike> :t (. listToMaybe) . fromMaybe
04:43:08 <lambdabot> c -> [c] -> c
04:43:25 <boxscape> @unpl (. listToMaybe) . fromMaybe
04:43:25 <lambdabot> (\ x x0 -> fromMaybe x (listToMaybe x0))
04:43:35 <dminuoso> fpbgnr: f y = ... t ... where t = case y of x:_xs -> ...; [] -> ...
04:43:52 <jle`> @. unpl pl \x xs -> fromMaybe x (listToMaybe xs)
04:43:53 <lambdabot> (\ x x0 -> fromMaybe x (listToMaybe x0))
04:44:30 <fpbgnr> hpc: right, didn't think about foldr
04:44:46 <boxscape> oh I didn't know you could compose lambdabot commands
04:45:08 <hpc> fpbgnr: fun fact, you can write any function on lists using foldr
04:47:16 <dminuoso> % :t foldr
04:47:16 <yahb> dminuoso: Foldable t => (a -> b -> b) -> b -> t a -> b
04:47:30 <dminuoso> Take a good long peak at this, and then look at church lists from lambda calculus. :)
04:48:26 <merijn> hpc: You can write most (all?) recursive functions using foldr + helper :p
04:48:44 <merijn> hpc: Something, something Universality and Expressiveness of Fold
04:48:57 <hpc> oh, that's neat
04:49:05 <merijn> hpc: It's a very neat paper
04:49:22 <merijn> hpc: https://www.cs.nott.ac.uk/~pszgmh/fold.pdf
04:49:23 <hpc> i only know about the "write a function that's shaped like the type's data constructors" bit
04:49:34 <hpc> *bookmarked*
04:50:20 <fpbgnr> hpc: In my case I have to get "head a", where a is an array (which may be empty) of Integer arrays.
04:50:24 <merijn> dminuoso: Isn't fold Scott encoding instead of Church encoding?
04:50:31 <merijn> I always forget which is which
04:51:37 <sleblanc> how can you get foldr to return [x] for (x:xs) and [] for [] ?
04:51:38 <fpbgnr> hpc: "concat (take 1 a)" does the trick, it's not very beautiful, though
04:52:07 <sleblanc> > foldr const 0 [1..]
04:52:10 <lambdabot>  1
04:52:14 <sleblanc> > foldr const 0 []
04:52:17 <lambdabot>  0
04:52:35 <hpc> > (foldr const [] [1,2,3], foldr const [] []) -- sleblanc
04:52:38 <lambdabot>  error:
04:52:38 <lambdabot>      • No instance for (Num [()]) arising from a use of ‘e_1123’
04:52:38 <lambdabot>      • In the expression: e_1123
04:52:52 <hpc> ugh what
04:53:03 <hpc> oh right
04:53:09 <sleblanc> you would have to wrap every elem in a list
04:53:30 <hpc> > (foldr (pure . const) [] [1,2,3], foldr const [] []) -- sleblanc
04:53:33 <lambdabot>  error:
04:53:33 <lambdabot>      • Couldn't match type ‘b0 -> Integer’ with ‘[a]’
04:53:33 <lambdabot>        Expected type: Integer -> [a] -> [a]
04:54:12 <hpc> > (foldr (\x _ -> [x]) [] [1,2,3], foldr const [] [])
04:54:16 <lambdabot>  ([1],[])
04:54:33 <sleblanc> > (foldr (const . pure) [] [1,2,3], foldr const [] [])
04:54:36 <lambdabot>  ([1],[])
04:55:25 <hpc> ah yep, that's what it is
04:55:32 <sleblanc> this example really opened my eyes to the use of pure
04:56:42 <jonathan_> I remember hearing about a datatype that is to Either, as OR is to XOR
04:56:42 <sleblanc> > foldr const [] $ map (\x -> [x]) [1..]
04:56:45 <lambdabot>  [1]
04:56:52 <jonathan_> anyone know it's name?
04:57:34 <sleblanc> jonathan_, tuple?
04:57:36 <sleblanc> (a,b)
04:57:41 <boxscape> Tuple is AND
04:57:48 <hpc> a union type
04:58:03 <hpc> haskell doesn't have those, but something like say typescript does
04:58:04 <fpbgnr> hpc: oh, and a comes from a recursive call to (x : concat (take 1 a)), so the function probably be rewritten using fold completely, right? :D
04:58:30 <boxscape> The best I can come up with would be something like `type XOR a b = Either (a, b -> Void) (a -> Void, b)`
04:58:31 <hpc> fpbgnr: that's usually how it goes
04:58:41 <hpc> haskell has a nice way of solving these sorts of XY problems
04:59:21 <jonathan_> It was a lib linked in this chat some time ago
04:59:27 <fpbgnr> I'm quite new to Haskell, but I'm really beginning to enjoy it... :D
04:59:37 <hpc> jonathan_: you're referring to something like where Union Int String is equivalent to Either Int String, but Union Int Int is equivalent to Int?
04:59:40 <merijn> jonathan_: These
04:59:46 <merijn> @hackage these
04:59:47 <lambdabot> http://hackage.haskell.org/package/these
05:00:07 <jonathan_> merijn: Thanks :)
05:00:24 <merijn> You guys all need to step up your psychic skills :p
05:00:43 <boxscape> Oh I misinterpreted the question as having XOR and OR swapped
05:00:54 <merijn> boxscape: But Either is *already* XOR :p
05:01:16 <sleblanc> jonathan_, that's what I was thinking about, with (a,b). you can have (undefined,b) or (a,undefined)
05:01:21 <boxscape> merijn in howard-curry it corresponds to OR though, doesn't it?
05:01:21 <sleblanc> not very typesafe though…
05:01:32 <hpc> bottoms are perfectly valid values
05:01:38 <hpc> sometimes ;)
05:01:51 <hpc> they're typesafe, at the very least
05:01:57 <merijn> Just pretend bottoms don't exist!
05:02:12 <merijn> Something about fast and loose and morally correct
05:02:15 <sleblanc> hpc, yes, but you'd have to encode it in your code that you should not peek at one side or the other, so you would be better off using These a b
05:02:19 <hpc> in any event, if you have (undefined, b) you'd never know it
05:02:23 <sleblanc> or a constant
05:02:28 <hpc> not without solving the halting problem
05:03:11 <sleblanc> isLeft = True, then later if isLeft then a else b
05:03:24 <boxscape> well, the halting problem doesn't say you can never know when something doesn't hold, just that you can't know it for all possible programs
05:03:47 <sleblanc> boxscape, for all non-trivial programs, no?
05:04:45 <boxscape> sleblanc no, programs can be quite complex and you can still figure out that the exact state in RAM repeats every 100 cycles or things like that, indicating an infinite loop
05:04:48 <hpc> boxscape: how about instead of (undefined, b) you have (brute-force a famous unsolved problem, b)
05:05:34 <hpc> that problem might be reducable to the halting problem
05:05:50 <sleblanc> boxscape, well, that's not what I mean. I'm trying to say that a trivial program can be decidable
05:06:44 <sleblanc> boxscape, it's actually what you said (you can't know it for all possible programs)
05:07:28 <boxscape> hpc to be fair undefined might be bad enough because if you want to figure out if it's bottom or not you have to potentially crash  the program (if you look past catching exceptions for control flow)
05:07:53 <hpc> detecting a crash is the easy part
05:08:01 <hpc> infinite loops are bottom as well, that's the unsolvable part
05:08:25 <boxscape> oh, right, I suppose (undefined, a) is standing in for all bottom values
05:08:33 <sleblanc> hpc, if it crashes, just wrap it in a systemd service with Restart=always ;-)
05:09:05 <fpbgnr> hpc: However, I've not yet got any idea on how to rewrite functions like these :D
05:09:39 <fpbgnr> currently, I have: myF xs n = n : concat (take 1 [myF xs (n*x) | x <- xs, myCond n x])
05:16:07 <fpbgnr> hpc: I mean I can't think of any way to change this to a fold(l,r) expression, I hope that's normal coming from the imperative programming world... - I'd be very grateful for any tips here in my case :D
05:17:48 <fpbgnr> Any good resources for learning would be appreciated too, of course :D
05:29:41 <nil> oh my god i just realised you can bind operators just like any other variable name
05:29:58 <jle`> @src on
05:29:58 <lambdabot> (*) `on` f = \x y -> f x * f y
05:30:09 <nil> > let f (.) a b = a . b in f (+) 1 2
05:30:12 <lambdabot>  3
05:30:17 <nil> jle`: nice
05:30:33 <Ariakenom> > let 1+1=3 in 1+1
05:30:36 <lambdabot>  3
05:30:44 * nil squints
05:31:28 <nil> oh, right.
05:31:32 <nil> damn.
05:31:46 <haveo> I mean the problem isn't that you can bind operators
05:31:51 <Ariakenom> it's a tricky one :D
05:31:52 <haveo> it's shadowing and partial patterns
05:32:08 <sleblanc> oof
05:33:25 <sleblanc> > let f (,) a b = (a,b) in f (+) 1 2
05:33:28 <lambdabot>  error:
05:33:28 <lambdabot>      • The constructor ‘(,)’ should have 2 arguments, but has been given none
05:33:29 <lambdabot>      • In the pattern: (,)
05:33:39 <nil> that's a reserved one i fear
05:33:51 <sleblanc> why!? :-(
05:34:08 <Ariakenom> [a,b] (a,b)
05:34:12 <Ariakenom> commas are special
05:34:12 <nil> just like i'd be surprised if you can bind (:)
05:34:19 <nil> > let f (:) a b = a:b in f (+) 1 2
05:34:22 <lambdabot>  error:
05:34:22 <lambdabot>      • The constructor ‘:’ should have 2 arguments, but has been given none
05:34:22 <lambdabot>      • In the pattern: (:)
05:36:00 <boxscape> let f (:+) a b = a :+ b in f (:+) 1 2
05:36:04 <boxscape> > let f (:+) a b = a :+ b in f (:+) 1 2
05:36:07 <lambdabot>  error:
05:36:07 <lambdabot>      • The constructor ‘:+’ should have 2 arguments, but has been given none
05:36:07 <lambdabot>      • In the pattern: (:+)
05:36:10 <Ariakenom> % :set -XRebindableSyntax
05:36:10 <yahb> Ariakenom: 
05:36:23 <Ariakenom> % let f (:) a b = a:b in f (+) 1 2
05:36:23 <yahb> Ariakenom: ; <interactive>:82:7: error:; * The constructor `:' should have 2 arguments, but has been given none; * In the pattern: (:); In an equation for `f': f (:) a b = a : b; In the expression: let f (:) a b = a : b in f (+) 1 2
05:36:38 <boxscape> nil any operator beginning with ':' counts as an "uppercase identifier" if you will, afaik
05:36:51 <boxscape> so can only be used as constructor, not as function
05:37:27 <boxscape> though I did copy it wrong
05:37:38 <nil> right
05:37:42 <haveo> : is built-in syntax anyway
05:37:52 <Ariakenom> ah ofc. but can be rebound by data Foo = Int : Int maybe
05:38:16 <haveo> no, because it's built-in
05:38:37 <boxscape> % data Foo = Int : Int
05:38:37 <yahb> boxscape: ; <interactive>:83:12: error: Illegal binding of built-in syntax: :
05:39:21 <haveo> not sure why it is though
05:39:49 <Ariakenom> :set -XOverloadedLists
05:39:51 <Ariakenom> % :set -XOverloadedLists
05:39:52 <yahb> Ariakenom: 
05:40:43 <Ariakenom> ah no that's via IsList
05:40:44 <sleblanc> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overloaded-lists
05:40:47 <Ariakenom> % :t IsList
05:40:47 <yahb> Ariakenom: ; <interactive>:1:1: error:; * Data constructor not in scope: IsList; * Perhaps you meant one of these: `List' (imported from Control.Lens), variable `S.toList' (imported from Data.Set), variable `IS.toList' (imported from Data.IntSet)
05:41:04 <haveo> % :k IsList
05:41:04 <yahb> haveo: IsList :: * -> Constraint
05:41:51 <Ariakenom> % :t 1:[]
05:41:51 <yahb> Ariakenom: Num a => [a]
05:42:03 <Ariakenom> % :t [1]
05:42:03 <yahb> Ariakenom: (IsList l, Num (Item l)) => l
05:42:11 <Ariakenom> still no : overload
05:42:24 <boxscape> % :t [1]
05:42:24 <yahb> boxscape: (IsList l, Num (Item l)) => l
05:42:25 <haveo> actually I'm assuming that : is built-in because list syntax like [1,2,3] gets rewritten using :
05:43:01 <boxscape> probably true, although you could do that without building it in
05:43:13 <haveo> yeah but you have to be more careful when rewriting
05:43:56 <boxscape> (:) is still imported even if you have NoImplicitPrelude
05:44:08 <haveo> I'm assuming you don't want [1,2,3] not to type-check just because someone binded : to something else
05:44:32 <boxscape> Personally that's exactly what I want :)
05:44:38 <haveo> eww
05:44:52 <boxscape> I believe that's how Idris does it
05:44:59 <cdepillabout> Is there a page that lists the versions of all the built-in packages shipped with each version of GHC?  Ideally I'm looking for a big table all the way to 7.10.3
05:45:00 <Ariakenom> I believe so too
05:45:52 <Ariakenom> I confused rebindable syntax with idris :p
05:57:28 <dmwit> cdepillabout: https://wiki.haskell.org/Base_package covers base
05:57:30 <dmwit> (but only base)
05:57:53 <dmwit> It links to https://gitlab.haskell.org/ghc/ghc/wikis/commentary/libraries/version-history which may also interest you.
06:04:37 <cdepillabout> dmwit, thanks.  The wiki page on gitlab is exactly what I am thinking of.  What google terms did you use to find it?  (I'm guessing you found the base_package page, and just followed the link to the page on the gitlab wiki?)
06:08:53 <jle`> i usually search for ghc boot libraries or boot library versions
06:09:12 <dmwit> cdepillabout: No Googling. I had a bookmark to the first one.
06:09:25 <dmwit> I learned about it by needing it and asking in here and somebody else had a bookmark.
06:09:30 <dmwit> Who knows how many layers back that story goes.
06:09:58 <cdepillabout> haha :-)  Well it does look like "ghc boot libraries" is the magic google phrase.
06:10:17 <cdepillabout> I'll add it to my bookmarks though, so I can hopefully pass it on one day to a young Haskeller.
06:10:24 <dmwit> ^_^_^
06:33:09 * hackage pretty-simple 3.1.1.0 - pretty printer for data types with a 'Show' instance.  https://hackage.haskell.org/package/pretty-simple-3.1.1.0 (cdepillabout)
07:16:58 <boxscape> are the backslashes here because of interaction with CPP? https://github.com/vincenthz/hs-cryptohash/blob/master/Crypto/Hash.hs#L125-L132
07:17:11 <boxscape> I'm somewhat surprised that ghc doesn't try to parse them as lambdas
07:17:50 <boxscape> But I suppose it's because the CPP macro handling removes them before the ghc parser ever sees them
07:23:44 <boxscape> also, https://haskell-code-explorer.mfix.io is neat. It does what I often use hackage for a bit better, it seems
07:24:42 <Cale> boxscape: Yeah, that's just CPP string continuation.
07:24:48 <boxscape> ok, thanks
07:26:08 <Cale> boxscape: Also, wow, this code explorer thing looks fantastic
07:26:50 <boxscape> Cale indeed. I found it though the ghc hacking page, where it's linked https://gitlab.haskell.org/ghc/ghc/blob/master/HACKING.md
07:29:04 <Cale> The public server seems to be missing a lot of packages, sadly, but maybe I can find a way to integrate this into our CI server.
07:39:53 <maralorn> How impractical is it to stack the same monad transformer twice?
07:41:38 <maralorn> Something like stacked runReader or something. Is it reasonably doable with typeapplications or something?
07:42:20 <kuribas> maralorn: the typeclass will just target the outermost then.
07:42:43 <kuribas> maralorn: but you can use lift
07:43:18 <kuribas> maralorn: but why would you do that?
07:44:05 <maralorn> (MonadReader a m, MonadReader b m) => m () ; ask :: m a just works?
07:44:13 <Cale> no
07:44:39 <Cale> But also, you should avoid using ask from outside of primitives that you're implementing.
07:45:47 <Cale> If you really need the polymorphism, I would recommend adding your own class -- usually you can make the operations more meaningful than just getting some arbitrary value as well, but even if not, they'll at least be more descriptive than "ask" that way.
07:46:30 <maralorn> kuribas: When I locally need another Monad then more globally. Like on Reader is the system environment and the other on is a certain local environment I want to add without using a completely other monad.
07:47:19 <kuribas> maralorn: create your own newtype, rename ask to getSystemEnv or something like that.
07:48:20 <maralorn> kuribas: Cale: That makes sensce.
07:48:24 <merijn> I can't directly construct a mutable vector from a list?
07:48:37 <maralorn> Thanks
07:48:58 <jle`> merijn: probably have to thaw . fromList
07:49:22 <jle`> or ... you could even unsafeThaw :o
07:49:36 <merijn> jle`: That seems very inefficient, though, since you'd construct it only to immediately copy...
07:49:44 <jle`> if you unsafeThaw there is no copy
07:49:53 <merijn> That's true
07:49:55 <jle`> but yeah, there should be a safe operation that wraps unsafeThaw . fromList
07:57:31 <boxscape> what is the backslash here doing? https://github.com/MarcWeber/hasktags/blob/master/testcases/testcase10.hs#L16
07:58:51 <geekosaur> that looks like a typo. possibly deliberate given that it's a test case of some kind
07:58:52 <merijn> Be an error? >.>
07:59:03 <boxscape> Ok, I suppose that makes sense
07:59:06 <boxscape> thanks
08:09:10 <sm[m]> g'day all
08:09:21 <sm[m]> if I've got a import Control.Monad.Except, and I want to know once and for all what package it's coming from, how could I find out in GHCI ?
08:10:37 <sm[m]> turn on PackageImports and try writing package names before it ?
08:12:28 <sm[m]> if I do :m +*The.Module, and :show imports, most of the things it imports aren't listed, I'm not sure why
08:13:24 <Rembane> Does :i help in this case? 
08:14:35 <sm[m]> no, it doesn't seem to know anything about imports
08:14:45 <boxscape> hm, using CPP to automate writing of instances seems like a pretty common pattern. That doesn't seem like the sort of thing you should have go to CPP for. Though maybe I'm only looking at old packages.
08:15:28 <Rembane> Ach.
08:16:22 <geekosaur> boxscape, most of those I'm aware of are version differences, which are hard to handle in other ways
08:17:28 <Cale> boxscape: It's often something we do with Template Haskell
08:17:43 <boxscape> Cale ah, yeah that sounds a bit more reasonable
08:17:57 <sm[m]> seems it's coming from mtl, as long as mtl is >= 2.2.1
08:18:28 <boxscape> Just grepping hackage for lines that end with a backslash and like half of the results are people defining macros to make defining instances a one-liner
08:19:09 <geekosaur> CPP and TH are basically the only options there. each has its own shortcomings and problems
08:19:32 <boxscape> hm, fair enough
08:23:52 <dmwit> DefaultSignatures sits in that space these days.
08:24:15 <boxscape> Ah, right
08:25:21 <boxscape> I suppose DeriveGeneric might also fill some of those usecases
08:25:26 <dmwit> sm[m]: ghc-pkg find-module Control.Monad.Except
08:25:55 <dmwit> sm[m]: Possibly with a cabal v2-exec up front if appropriate.
08:26:14 <sm[m]> dmwit: thanks! useful!
08:26:40 <sm[m]> that would be a nice thing for ghcide etc. to show
08:32:44 <spydon> Can I rebuild a package and add flags in stack somehow?
08:35:52 <jle`> in that order?
08:36:12 <jle`> hm, are you asking if you can do those two things separately?
08:37:13 <jle`> if you're talking about them together, then adding flags would automatically trigger a rebuild of a package that uses those flags
08:49:10 <greymalkin> Is there an elegant structure for progressive nested if/elses? In my case, "look up entity, if not exists finish1 else check entity hash if hash equal finish2 else check attribute3 if ...
08:50:06 <greymalkin> Using an Except monad seems like a bad fit, though it could be done; I've considered using something like an EitherT, but still the block has the capability of returning a right value (which isn't what I want)
08:50:14 <c_wraith> greymalkin: that's roughly what the monad instance for Maybe is good for.
08:50:24 <dsal> greymalkin: maybe monad?  Hard to tell without more code
08:50:53 <c_wraith> I've written code that starts "fromMaybe False $ do" on more than one occasion.
08:50:56 <greymalkin> Roughly, yes. Unfortunately, I typed `finish1` twice, rather than incrementing it.  Each step can produce a different output.
09:05:24 <jle`> greymalkin: if you paste some code we might be able to get a better idea of what you are trying to clean up :)
09:05:55 <yingw787> Hello?
09:06:02 <jle`> at this point the best we can do is assume based on what we are not sure about :)
09:06:07 <jle`> yingw787: hi!
09:06:39 <yingw787> Woah first time really using IRC...this is cool :) Hi @jle!
09:06:49 <jle`> welcome to freenode ~
09:08:00 <yingw787> I'm going through "The Haskell Book" 1.0-rc4 right now: https://haskellbook.com/ and I might have some questions..
09:08:18 <yingw787> But first I wanted to ask, is there a resource on IRC best practices?
09:08:53 <jgt> yingw787: I haven't heard of one, but I can give you a couple of tips
09:08:56 <dsal> yingw787: thanks for asking.  Mostly, just ask questions.  Don't paste large swaths of code (link to a pastebin like gist or similar)
09:09:04 <jgt> yingw787: you don't need to prefix a user's handle with an @ symbol to address them
09:09:15 <sm[m]> yingw787: lots, search each on site:freenode.net
09:09:21 <jgt> yingw787: and it's also frowned upon to paste a bunch of lines of anything
09:09:22 <sm[m]> s/each/eg/
09:10:18 <sm[m]> https://freenode.net/changuide
09:10:32 <jgt> yingw787: oh and also, remember that IRC is like shipping channels in the ocean. It's how hackers communicate online.
09:10:43 <jgt> https://www.youtube.com/watch?v=O2rGTXHvPCQ
09:13:29 <yingw787> jgt dsal sm[m] thanks for the resources! I think one friend I met at PyCon said he ran an IRSSI daemon on a raspberry pi and connected to it whenever he needed to access the chat so that he can persist the chat logs during that time; is this a thing
09:14:41 <dsal> yingw787: I use irccloud as my client.  It does lots of magic including giving me seamless mobile and desktop transitioning.  There are tons of ways to do irc, though.
09:15:57 <ChaiTRex> yingw787: I have a shell running in the cloud because my main laptop is dead and iOS doesn't really support IRC well (it can kill the IRC client if you switch apps).
09:16:30 <jgt> yingw787: yeah, that's a thing. I _think_ it's called an IRC bouncer
09:16:51 <jgt> yingw787: I don't use one; I'm too much of a neophyte
09:18:37 <yingw787> cool, thank you everybody! I'll post questions I have when reading through the book as I go along, and look at setting up my personal tooling / infrastructure with your advice in mind
09:19:57 <yingw787> one question I had off the bat is around currying; my understanding of currying is that its to destructure functions with multiple arguments into partially applied functions each with a single argument
09:20:37 <yingw787> the author had an example `curry f a b = f (a, b)`, I thought it should be `curry f (a, b) = f a b`
09:20:53 <yingw787> the author lists the latter as the method def for uncurry though
09:21:39 * hackage releaser 0.2.1.0 - Automation of Haskell package release process  https://hackage.haskell.org/package/releaser-0.2.1.0 (domenkozar)
09:26:46 <ChaiTRex> @type curry
09:26:48 <lambdabot> ((a, b) -> c) -> a -> b -> c
09:27:40 <ChaiTRex> yingw787: You'll have 'curry' followed by a function that needs to be curried.
09:28:03 <ChaiTRex> yingw787: That input function will take (a, b) or whatever as its argument.
09:28:39 <ChaiTRex> yingw787: However, after currying, it should take a b as its argument.
09:28:53 <ChaiTRex> yingw787: So, (curry f) a b should work.
09:29:06 <ChaiTRex> yingw787: That's the same as curry f a b
09:31:24 <yingw787> ChaiTRex: Ah that makes sense. The parentheses help in my understanding; the author is trying to write out the definition of the default curry method
09:31:39 * hackage profunctor-arrows 0.0.0.2 - Profunctor arrows  https://hackage.haskell.org/package/profunctor-arrows-0.0.0.2 (cmk)
09:31:50 <ChaiTRex> yingw787: The main insight to avoid confusion is that curry f by itself should produce for us a nice curried function.
09:37:00 <maralorn> How can I tell cabal to (temporarily) use a local checkout instead of a hackage package?
09:37:04 <yingw787> ChaiTRex: Cool, just wanted to make sure I didn't get it backwards by accident
09:37:40 <yingw787> mmm is there a way to elide maintenance logs in IRC? Like user has quite after ping timeout
09:39:49 <yingw787> it could help in increasing signal / noise ratio
09:41:12 <Entroacceptor> yingw787: depends on the client.
09:42:07 <greymalkin> https://pastebin.com/uW0jkRXq This is the function that's starting to feel the most bloated. Especially since I want to add a new case here.
09:42:42 <yingw787> Entroacceptor: Do you elide maintenance logs for your IRC client? Which one do you use?
09:47:55 <Entroacceptor> yingw787: irssi with the smartfilter script
09:49:09 * hackage profunctor-optics 0.0.0.2 - An optics library compatible with the typeclasses in 'profunctors'.  https://hackage.haskell.org/package/profunctor-optics-0.0.0.2 (cmk)
09:52:49 <pertl> I am trying to understand typeclasses and get stopped by some weird error:
09:52:50 <pertl> https://gist.github.com/pertl/abee968eab157338181626a569c89f32
09:53:04 <pertl> haskell does not seem to accept 'String' as a type argument
09:53:10 <dsal> greymalkin: Well, you could guard away that existence check just to avoid the if/else.  I don't like if/else much.  :)
09:53:27 <yingw787> Entroacceptor: thanks
09:53:29 <pertl> I also tried [Char] to no avail
09:53:41 <dsal> pertl: String isn't a number.  What are you trying to do?
09:53:56 <pertl> why number?
09:54:01 <dsal> :t (+)
09:54:03 <lambdabot> Num a => a -> a -> a
09:54:06 <pertl> ah ok
09:54:07 <pertl> wow
09:54:09 <pertl> thanks
09:54:17 <pertl> so string concat is different?
09:54:28 <pertl> ok I see it really is
09:54:37 <dsal> Yes, they're not very similar concepts.  :)
09:54:48 <pertl> of course
09:54:50 <dsal> string concatenation is basically monoidal append.
09:54:53 <pertl> I am spoiled by other languages
09:54:54 <dsal> :t (++)
09:54:56 <dsal> :t (<>)
09:54:56 <lambdabot> [a] -> [a] -> [a]
09:54:57 <lambdabot> Semigroup a => a -> a -> a
09:55:05 <pertl> nice thanks :-)
09:55:07 <dsal> Spoiled by?  Precision is a huge feature of haskell.  :)
09:55:23 <pertl> spoiled by languages NOT being haskell
09:55:36 <pertl> actually, any language != haskell => spoil
09:55:48 <dsal> Yeah, I see it the other way around.  Any time I have to use another language, I'm sad because I can't do basic things.
09:56:12 <dsal> But you *can* make a Num instance for String and decide what you want it to do.  It's probably a bad idea, but you could do it.
09:56:22 <pertl> everything looks ridicuously bloated in other languages
09:56:31 <pertl> I just assumed (+) to concat strings, too
09:56:49 <dsal> + means really complicated things in a lot of languages.
09:56:53 <pertl> actually you join lists when you concat strings, I get that now
09:57:05 <dsal> I generally just use <> for everything concatenatey
09:57:23 <pertl> ah, semigroup, thanks @dsal 
09:57:24 <dsal> ++ works for lists (and thus Strings), but not Text or *ByteString or whatever.
09:57:44 <dsal> E.g., it's easy to write code where    "a" ++ "b"   suddenly  stops compiling.
09:58:33 <dsal> Most real haskell code tries to avoid String.  I generally answer to nobody, though.
09:58:38 <dmwit> It's... easy not to write code where "a"++"b" suddenly stops compiling, too.
09:59:55 <dsal> I'm not saying it's unavoidable.  But when you start migrating away from String, you suddenly have concatenations you have to rewrite.  ++ is more of a wart at this point.
10:00:04 <greymalkin> dsal: guards invoke `fail`. If the file exists, then that is a particular success case, though.
10:00:24 <dsal> greymalkin: I don't mean Control.Monad.guard -- I just mean a function head guard.
10:02:44 <dsal> greymalkin: something like https://pastebin.com/JNh0fP5X
10:03:00 <dmwit> greymalkin: https://stackoverflow.com/q/33005903/791604 may be related
10:03:09 * hackage dhall-fly 0.2.1 - Translate concourse config from Dhall to YAML  https://hackage.haskell.org/package/dhall-fly-0.2.1 (axeman)
10:03:48 <dmwit> You say you considered using Except but didn't. But I don't understand your reason for not using it.
10:03:56 <greymalkin> Ah, you don't mean the existence check, you mean the path check.
10:05:59 <dsal> It doesn't seem to have a lot of conditions, though.  There's like... that one.
10:06:17 <greymalkin> dmwit: 1st: having "throwError" for a success case feels like a semantic violation 2nd: the result can still be a Right... but a Right of what?
10:06:26 <dmwit> dsal: There's the "did lookupEntity succeed" one.
10:06:34 <dmwit> dsal: And presumably entityFromFile could also fail.
10:07:28 <greymalkin> three nested conditions, lookup=>already there? pathcheck=>same file? and, in progress check old file exists=>duplicate?
10:07:35 <dmwit> greymalkin: Using throwError for a short-circuit case is not a semantic violation. But I don't understand your 2nd objection.
10:08:56 <dmwit> The Right is... whatever you're going to return at the end of this computation. So `ImportMoved old entry` or whatever.
10:10:07 <greymalkin> So it's an ExceptT ImportResult ImportResult ... still doesn't feel right.
10:10:30 <dmwit> Only in the internal implementation.
10:10:47 <dmwit> The top-level runs the ExceptT to interpret it appropriately.
10:11:20 <dmwit> But here's another idea.
10:15:13 <greymalkin> Yes, but I have to read this code again :)  I get what you're saying, and I would probably be better with using an EitherT rather than a ExceptT (yes, functionally identical, but without the implication that an error occurred.)
10:15:41 <dmwit> greymalkin: https://gist.github.com/dmwit/20b885f189e037df6c3e5eeba91774e8 <- another idea
10:19:18 <dmwit> (Of course, if you do this split, the names ImportAdded and ImportMoved might no longer be the best, since they imply action has already been taken and we're splitting that out. But that's easily fixed.)
10:22:27 <greymalkin> That's actually not a bad idea.  Unfortunately, it would need to be a bit different now that I'm adding `ImportDuplicate` if the path for `old` still existed.  (Technically, everything that this reports has already happened, as its just detecting changes between its internal database and the filesystem.
10:23:09 <greymalkin> But I do like this better -- the function is broken into detection and backend changes very nicely.
10:26:15 <djanatyn> phantom types with DataKinds and Symbol are so lovely!!!
10:27:04 * dmwit . o O ( runLoop :: ExceptT (m a) m a -> m a; return :: a -> ExceptT (m a) m b; return = throwError . pure )
10:35:07 <yingw787> I have a question about polymorphism vs. generics
10:35:33 <yingw787> the author discusses polymorphic type variables allowing expressions to be written once and applied to multiple types
10:35:48 <yingw787> this is akin to object-oriented generics right, and less so object-oriented polymorphism?
10:35:55 <yingw787> https://stackoverflow.com/a/2423355
10:36:03 <ChaiTRex> yingw787: No, this is like an interface in Java.
10:36:36 <ChaiTRex> yingw787: You have a set of functions that can apply to any of several types. The types each implement the set of functions.
10:38:21 <yingw787> ChaiTRex: So what you're saying is that the method definition you write is resolved to concrete types by all types that exist under those polymorphic constraints?
10:38:43 <yingw787> And that the method you're writing is not actually being run, it's a different method evaluated at compile-time?
10:39:20 <ChaiTRex> Well, it's resolved to concrete functions.
10:39:33 <yingw787> I am using GHCi to run everything at the moment, which is why my understanding of compile-time / run-time stuff may be a bit wonky
10:39:58 <ChaiTRex> Nothing is evaluated at compiletime.
10:39:59 <dsal> Ghci muddies a few concepts, yeah
10:40:18 <ChaiTRex> You have a set of functions you want to be able to use with a set of types.
10:40:42 <ChaiTRex> That's a typeclass. It has functions you can apply to any type that implements the typeclass.
10:41:18 <ChaiTRex> The types themselves each have concrete versions of those functions.
10:41:44 <dmwit> yingw787: Both forms of polymorphism -- generics, and object-oriented-like -- are available, via different mechanisms.
10:42:21 <dmwit> yingw787: Typeclasses are a bit like Java interfaces, and is what ChaiTRex is telling you about. But I suspect what your book is talking about at the moment is parametric polymorphism, where no typeclass constraints appear.
10:42:25 <dmwit> For example,
10:42:25 <dmwit> :t length
10:42:27 <lambdabot> Foldable t => t a -> Int
10:42:35 <dmwit> well
10:42:48 <dmwit> It used to be that `length :: [a] -> Int` and then it was a better example for what I'm talking about. =P
10:42:55 <dmwit> Let's suppose `length :: [a] -> Int` for now.
10:43:28 <yingw787> dmwit: Okay cool, yes this foldable stuff is a bit confusing, but please continue :)
10:43:29 <dmwit> Since `a` as a type variable is completely unconstrained, this is a lot like generics: `length` works on any list, no matter what type of elements are inside.
10:44:05 <dmwit> Compare, say, (+)
10:44:06 <dmwit> :t (+)
10:44:09 <lambdabot> Num a => a -> a -> a
10:44:53 <dmwit> There is a constraint here -- `Num a` -- which essentially says that (+) may only be applied to values of a type that is an instance of `Num` -- that is, the compiler will dispatch to one of many possible implementations to decide what to do.
10:45:11 <dmwit> length has just one implementation, and that same implementation is used no matter which type is contained in the list.
10:45:31 <dmwit> (+) has many implementations, each written by a programmer, and the compiler chooses between them.
10:46:09 * hackage pandoc-pyplot 2.3.0.1 - A Pandoc filter to include figures generated from Python code blocks  https://hackage.haskell.org/package/pandoc-pyplot-2.3.0.1 (LaurentRDC)
10:46:19 <dmwit> Dunno if that helps or not.
10:47:21 <yingw787> dmwit: So if I was to repeat what I think I understand from you and ChaiTRex's explanations
10:47:33 <dmwit> (FWIW, Haskell folks call this "parametric polymorphism" for things like `length` that OO folks call "generics", and "ad-hoc polymorphism" for things like `(+)` that OO folks call "polymorphism".)
10:49:26 <yingw787> When you're defining a method that uses constrained polymorphism, you're defining an interface
10:49:57 <yingw787> And that runtime, that interface resolves to the concrete types defined by the data passed into those methods
10:50:34 <yingw787> And the runtime has those methods implemented for concrete types already, either by you or somebody else
10:50:51 <EvanR> hmm
10:51:00 <yingw787> and the runtime can dispatch the correct implementation of the interface for the passed-in data
10:51:18 <dsal> yingw787: what you're describing sounds more like compile time than runtime.
10:51:19 <dmwit> (Up to some minor quibbles, that's basically right so far.)
10:51:32 <EvanR> there is an oleg paper which expains type classes in 3 ways
10:51:39 <EvanR> it's pretty good
10:51:53 <dmwit> dsal: Sometimes, as part of optimization, the dispatch is done at compile-time. But it is not always possible.
10:52:33 <yingw787> I guess my follow-up questions would be: how does Haskell help avoid type translation errors at run-time if the dispatch happens at run-time?
10:52:52 <dmwit> What is a "type translation error"?
10:53:11 <yingw787> And what happens if the concrete methods are not available? Or do they have to be available? Can the runtime automatically generate them somehow?
10:53:27 <yingw787> dmwit: If you're adding two different concrete operators for example
10:53:31 <dmwit> If the methods are not available, you get a compile-time error.
10:53:33 <yingw787> concrete classe*
10:53:39 <yingw787> classes*
10:53:48 <dmwit> (+)'s type clearly markes that its arguments must have the same type.
10:53:49 <yingw787> like an Integer and a Double, but your method takes in Num
10:53:54 <EvanR> resolution of where to get the implementation from happens at compile time
10:54:03 <dmwit> If it is not obvious to the compiler that you gave two arguments of the same type to (+), you get a compile-time type error.
10:54:17 <dmwit> Num is not a type.
10:54:22 <dmwit> Num is a constraint on types.
10:54:35 <dmwit> Some types satisfy the constraint, some don't; but you can't have "a Num".
10:54:43 <EvanR> the concrete type is not necessarily picked at that point, and sometimes there is no concrete type because it's an instance like instance Ord a => Ord [a] where
10:55:17 <dmwit> > (3 :: Integer) + (3 :: Double)
10:55:20 <lambdabot>  error:
10:55:20 <lambdabot>      • Couldn't match expected type ‘Integer’ with actual type ‘Double’
10:55:20 <lambdabot>      • In the second argument of ‘(+)’, namely ‘(3 :: Double)’
10:55:27 <dmwit> Sort of a trivial example of the kind of error you can expect.
10:56:18 <dmwit> or, for your first question...
10:56:25 <basic> hello
10:56:29 <dmwit> > ('a' :: Char) + ('b' :: Char)
10:56:31 <lambdabot>  error:
10:56:31 <lambdabot>      • No instance for (Num Char) arising from a use of ‘+’
10:56:31 <lambdabot>      • In the expression: ('a' :: Char) + ('b' :: Char)
10:56:37 <basic> if i have a list of constructed things, how do i map it to a component of that type
10:57:05 <basic> lol, i got the answer by asking the question
10:57:11 <dmwit> yay!
10:57:12 <EvanR> yingw787: have you heard of 'dictionary passing' implementation of type classes
10:57:28 <EvanR> or dictionary passing intuition
10:57:37 <basic>  map (\(Turn pl _) -> pl) (availableTurns [])
10:57:41 <basic> is there a short version of this?
10:57:46 <yingw787> EvanR: I haven't heard about 'dictionary passing', please enlighten me :D
10:58:27 <EvanR> a constraint on a function can be viewed as a normal argument where the thing passed in at runtime is a dictionary with the method implementations in it
10:58:47 <boxscape> basic if you can make Turn into a record then you can do something like `map player (availableTurns [])`, assuming the first record field of Turn is called "player"
10:58:53 <EvanR> since the programmer doesn't explicitly pass this around, it's the job of the compiler to arrange for where to get this dictionary from
10:59:15 <basic> boxscape: oy
10:59:17 <EvanR> it can come from many places, but if it can't find any place it's a compile time error
10:59:18 <basic> will test that
10:59:33 <basic> because for a record each "field" gets a function, right?
10:59:34 <EvanR> or if it is clearly ambiguous where to get it
10:59:40 <boxscape> basic yeah
11:00:09 <EvanR> that would be a compile time error
11:00:46 <boxscape> yingw787 `data Eq a = Eq {(==) :: a -> a -> Bool}`, then instead of having a function like `f :: Eq a => a -> a -> Int` it would be `f :: Eq a -> a -> a -> Int`
11:01:49 <EvanR> i think this picture goes a good way toward explaining some of the type class related error messages
11:02:36 <basic> how do i get the first of an enum :p
11:02:48 <boxscape> basic if you derive Bounded you can use minBound
11:03:02 <basic> why isn't that default, i mean isn't everything bound?
11:03:07 <EvanR> or toEnum 0 ?
11:03:22 <boxscape> basic take Integer for example
11:03:28 <boxscape> > toEnum 0 :: Integer
11:03:31 <lambdabot>  0
11:03:33 <boxscape> > minBound :: Integer
11:03:33 <basic> EvanR: well that works
11:03:35 <lambdabot>  error:
11:03:35 <lambdabot>      • No instance for (Bounded Integer)
11:03:35 <lambdabot>          arising from a use of ‘minBound’
11:04:07 <basic> why is toEnum 0 without a type unit?
11:04:12 <basic> is there a clever reason?
11:04:20 <boxscape> because ghci defaults things to () if it can
11:04:22 <yingw787> okay cool thanks guys! This is very informative
11:04:33 <basic> boxscape: well that is what happens, but why 
11:04:47 <EvanR> defaulting to () is silly
11:04:49 <yingw787> also do you guys know how to pipe the scroll-off stuff in irssi to a log file of some sort (like tail -f)
11:05:04 <EvanR> it's causing basic confusion!
11:05:10 <EvanR> and not helping anyone
11:05:28 <boxscape> EvanR I think it might be to have things of type `IO a` default to `IO ()`?
11:05:49 <EvanR> that's also weird
11:07:05 <basic> if i have a type that has 2 values how would i alternate between those cleverly
11:07:08 <basic> sorry for stupid questions
11:07:22 <boxscape> > cycle [minBound..] :: [Bool]
11:07:25 <lambdabot>  [False,True,False,True,False,True,False,True,False,True,False,True,False,Tru...
11:07:29 <boxscape> I'm not sure if that's what you mean
11:07:35 <basic> hm, i mean a function that inverts the value
11:07:42 <basic> data x = y a | y b
11:07:52 <basic> sure, i could hardcore it
11:07:58 <ChaiTRex> basic: Write a function that alternates to the other given one of them.
11:08:01 <basic> kinda like what is not to true
11:08:44 <boxscape> I mean if you really wanted to you could do something weird like (toEnum . (1-) . fromEnum) but I think pattern matching is probably the best way. That's how `not` is coded, as well
11:08:47 <boxscape> @src not
11:08:48 <lambdabot> not True  = False
11:08:48 <lambdabot> not False = True
11:09:10 <basic> well
11:09:11 <basic> okay
11:14:25 <aveltras> what would be the current best learning material about lens ?
11:14:51 <basic> can i use these record "getters" inside pattern matching somehow?
11:15:42 <EvanR> f MyJunk{field=x} = ... x ...
11:16:08 <EvanR> aveltras: i'm enjoying the optics library docs
11:16:47 <EvanR> the jargon seems to carry over to lens the big kahuna
11:17:01 <aveltras> EvanR: this http://hackage.haskell.org/package/optics-0.2/docs/Optics.html ?
11:17:29 <EvanR> yeah
11:17:44 <aveltras> ok i'll read that, thanks
11:18:26 <dsal> aveltras: There's a book coming out soon that looks promising.
11:19:15 <aveltras> do people who are familiar with the concepts then use it all the time ? or are there drawbacks ?
11:20:44 <EvanR> if you can do something without lenses (and prisms and etc oh my) then you win a larger pool of people who can read your code
11:21:32 <boxscape> aveltras lens is a big library, so having it as a dependency can be annoying. However, using microlens instead helps with that. I don't know how optics fares with respect to that
11:22:14 <EvanR> optics has a core library with few dependencies
11:22:20 <EvanR> optics-core
11:23:00 <EvanR> optics pulls in many other packages for the sake of giving many things instances
11:35:31 <basic> to get back into haskell im writing a silly game, if i have a function that returns all possible turns for a player.. how do i get a tree of all possible games?
11:35:55 <basic> do { initialTurn <- availableTurns []; return (availableTurns [initialTurn]); }
11:36:04 <basic> how would i do that until availableTurns is empty?
11:36:13 <basic> (the game is represented as list of turns)
11:37:35 <EvanR> if a game is a list of turns, and you want all possible games, that would be a list of list of turns
11:41:03 <gentauro> is there a way to put a constraint to `a` in: `newtype Foo a = Foo a`?
11:41:23 <dmwit> aveltras: I liked "Lenses Over Tea".
11:41:23 <gentauro> as for example it should only be a number (context `Num a => ...`)? 
11:41:36 <dmwit> https://artyom.me/lens-over-tea-1
11:41:53 <gentauro> `A newtype constructor cannot have a context in its type`
11:42:45 <aveltras> dmwit: bookmarked this one too, thx
11:42:58 <boxscape> gentauro that probably wouldn't do what you want, datatype contexts are generally considered a misfeature. Typically you'll want to add the constraint to functions that use the type instead of to the type itself. Possibly you might want to add a constraint to a GADT constructor instead.
11:43:51 <dmwit> basic: if `moves :: GamePos -> [GamePos]` or similar, then `gameTree :: GamePos -> Tree GamePos; gameTree pos = Node pos (map gameTree (moves pos))`.
11:44:23 <juri_> Egad, programming in haskell for a year has made my embedded C very weird.
11:44:44 <boxscape> That's better than the other way around
11:44:50 <dmwit> gentauro: https://stackoverflow.com/q/40825878/791604
11:45:11 <dmwit> (Currently cannot be done with newtype. Watch the GHC changelogs.)
11:45:30 <juri_> boxscape: digit=((c1&16)?3:0) + ((c1&8)>>3) + (((c1&4)&&(c1&8)&&(c1&2)&&((c1&16)||(c1&1)))?2: (((c1&4)&&((c1&8)||(c1&2)||(c1&16)||(c1&1))))?1: (((c1&8)&&((c1&2)||((c1&16)&&(c1&1)))))?1:0);
11:45:39 <boxscape> oh, nice
11:45:39 <gentauro> dmwit: thx :)
11:46:19 <boxscape> I don't do bitwise stuff but you can't extract c1 out of (c1&a)&&(c1&b)&&...? That seems like a shame
11:46:47 <dmwit> You can.
11:46:57 <boxscape> ah, good
11:46:58 <dmwit> c1&(2+4+8+16) == 2+4+8+16
11:47:06 <juri_> not when you are checking truth of each item seperately.
11:47:18 <boxscape> hmm
11:47:49 <dmwit> (Then constant-fold. I just wrote it that way to be clear about what transformation I was doing.)
11:48:14 <EvanR> man what is && doing in a bitmunging computation
11:48:26 <EvanR> or is this C
11:48:34 <juri_> sorry. it's C.
11:48:38 <dmwit> This `(c1&8)||(c1&2)||(c1&16)||(c1&1)` stuff can be simplified in a similar way.
11:48:38 <EvanR> oh
11:48:46 <juri_> wrong channel. just jammed in my brain.
11:48:49 <dmwit> c1&(8+2+16+1) != 0
11:49:12 <juri_> dmwit: good point.
11:49:16 <dmwit> or !(c1&(8+2+16+1))
11:53:39 * hackage protocol-buffers 2.4.13 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/protocol-buffers-2.4.13 (TvH)
11:53:59 <dmwit> ...but I think I'd probably do, like, {0,0,0,0,0,1,1,1,0,0,1,1,1,1,1,2,0,0,0,0,1,1,1,1,0,1,1,1,1,1,2,2}[c1%32]
11:54:10 <dmwit> or whatever
11:54:40 * hackage protocol-buffers-descriptor 2.4.13, hprotoc 2.4.13 (TvH): https://qbin.io/junk-fonts-alz1
11:55:33 <dmwit> oh my god
11:55:39 <dmwit> I just worked out the actual lookup table.
11:55:52 <EvanR> is it full of stars?
11:55:58 <dmwit> digit = c1/5
11:56:34 <dmwit> (c1%32)/5 if you're being pedantic
11:58:10 <dmwit> juri_: y tho
11:58:37 <juri_> dmwit: itoa on an architecture with no divide for 16 bit numbers.
11:59:21 <juri_> what'll really drive you insane is i made it three digits in before i gave up, and wrote a divide function.
11:59:31 <juri_> too. much. haskell.
11:59:51 <boxscape> I don't think there is such a thing
11:59:52 <pta2002> is there any function that runs a function with parameters from a list and stops once it find a desired solution, giving you the parameters
11:59:56 <pta2002> basically a brute force function
12:00:17 <EvanR> :t find
12:00:19 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
12:00:33 <EvanR> % :t find @[]
12:00:33 <yahb> EvanR: (a -> Bool) -> [a] -> Maybe a
12:01:02 <dmwit> ...but, in my opinion, better is
12:01:03 <dmwit> :t filter
12:01:04 <lambdabot> (a -> Bool) -> [a] -> [a]
12:01:22 <boxscape> "better" in what sense? Seems like it's just useful for different use cases
12:01:33 <EvanR> well, filter is more flexible
12:01:42 <EvanR> and doesn't sacrifice anything really
12:01:44 <dmwit> Better in the sense that it is exactly as expensive to use in the use cases where find is possible, and it has the nice property of being a homomorphism.
12:02:05 <novum> hello. consider that there is major deadline, things crashed and the world is on fire. What is the best framework for web development if there are major time constraints? Yesod was used before crash, now it impossible cuz it sucks. If it is the best foot forward still, we are going to have to switch langauge. apologies for curtness. no sleep
12:02:09 <dmwit> filter (f <&&> g) = filter f . filter g
12:02:16 <dmwit> (<&&>) = liftA2 (&&)
12:02:30 <EvanR> again with the operators!
12:03:21 <dmwit> (predicates are a semigroup under (<&&>), endofunctions are a semigroup under (.), filter is a homomorphism from the first to the second)
12:04:09 <dmwit> Under threat of major deadline, I advise not restarting from scratch.
12:04:10 <EvanR> and Maybe messed that up somehow?
12:04:38 <dmwit> Yes. Because later results are not available, find f . find g may report no results where find (f <&&> g) reports one.
12:05:14 <dmwit> (exactly when the first thing matching g does not match f, but there are things that match f <&&> g)
12:05:22 <basic> dmwit: hm no, im not having a tree yet
12:06:22 <basic> i have type Game = [Turn]
12:06:36 <saml> that's nice
12:06:39 <basic> and availableTurn gives me [Turn], but is not a gamestet, just a set of turn
12:07:01 <saml> it's a list of Turn
12:07:10 <basic> so is the gamestate, tho
12:07:19 <dmwit> Does the [Turn] you get from availableTurn represent choices, or a single next Game?
12:07:27 <basic> choices
12:07:36 <EvanR> confusing :)
12:07:41 <dmwit> Okay. So availableTurn :: Game -> [Turn].
12:07:46 <EvanR> set of choices, vs list of previous moves made
12:07:48 <basic> well, yes, i mean that they're both [Turn] is confusing, yeah
12:08:05 <basic> both ways have their (dis)advantages
12:08:08 <saml> is Game gamestet?
12:08:12 <dmwit> And then we can implement `moves :: Game -> [Game]` in terms of that; e.g. by `moves g = map (\turn -> g ++ [turn]) (availableTurn g)`.
12:08:21 <dmwit> And then you are back to where I answered.
12:08:29 <basic> hm, i think i get that
12:08:55 <dmwit> Perhaps not the best idea, but then you're the one that chose `type Game = [Turn]`, not me. =P
12:09:25 <basic> just trying to learn the basics
12:09:30 <dmwit> yeah
12:09:46 <novum> we switch
12:09:56 <EvanR> type Game = [Turn] makes sense
12:09:59 <novum> I hate everything
12:10:06 <EvanR> or [Move]
12:10:28 <dmwit> It makes sense. But it's almost certainly not the most useful type for folks trying to manipulate Games.
12:10:46 <EvanR> hmmm
12:10:53 <EvanR> really
12:11:04 <dmwit> Sure. Think of, say... monopoly.
12:11:21 <basic> but what dmwit says doesnt go deep, does it?
12:11:30 <basic> i mean, i want all games (it's tictactoe, not many)
12:11:33 <dmwit> Would you rather have a description of all the moves all the players made, and then it's your responsibility to fold over it, or a record that had a nice field you could pick out that said how much money each player had?
12:11:38 <basic> i can paste my current code
12:11:51 <basic> http://dpaste.com/258BYGY
12:12:29 <EvanR> oh you mean it's a bad way to represent game state, not move history
12:12:35 <dmwit> I do.
12:12:56 <asheshambasta> why is ghcid not able to find `main` when I do `ghcid -T ":main"`
12:13:05 <EvanR> tell this to temporal databases :)
12:13:23 <basic> why would that be a bad way to represent game state
12:13:29 <basic> surely not for tictactoe but for something more evolved
12:13:32 <dmwit> Move history can also be useful. But `availableTurn` almost certainly wants a game state, not a move history.
12:14:25 <dmwit> basic: Imagine writing availableTurn for chess.
12:14:41 <basic> yeah, not possible there
12:14:46 <dmwit> Probably the first thing you do, if handed a history of the moves, is build an 8x8 array of what pieces are in each position.
12:14:58 <basic> but having the gamestate in another way tha ta turnlist
12:15:02 <basic> doesn't change that fact
12:15:14 <basic> dmwit: i disagree
12:15:17 <dmwit> Yes, it does change that fact: you separate out concerns.
12:15:39 <basic> i really can't follow that, they're pretty much equivalent to me
12:16:06 <basic> either way, i would like to see how the function looks that makes all games from t hat
12:16:08 <dmwit> Let's say you have separate type-level concepts for "move history" and "current game state".
12:16:20 <dmwit> You can compute the game state from a move history. But it's not free.
12:16:48 <dmwit> But you can incrementally update the game state as you take turns.
12:17:21 <dmwit> So that instead of the process "compute state from moves, choose move, add move to history, recompute state from longer list of moves, choose move, add move to history, recompute state from even longer list of moves, ..."
12:17:39 <dmwit> You get "start from initial state, choose move, update state, choose move, update state".
12:17:57 <dmwit> You do O(n) state updates instead of O(n^2).
12:18:35 <EvanR> a game state can be computed from move history, there's really no way they are equivalent
12:18:45 <EvanR> like, you can go from game state back to move history
12:18:47 <EvanR> cannot*
12:19:03 <dmwit> (For most interesting games, anyway.)
12:19:31 <EvanR> a game where this is possible would be interesting!
12:19:40 <EvanR> think forward and backward in time
12:20:01 <dmwit> EvanR: I think I might actually define a game to be interesting iff you can't do this. =P
12:20:13 <EvanR> example game, basketball :)
12:20:19 <dmwit> Here's an example of a game where you can compute the move history from the current state: the state is a number, and the only move you can make is increment it.
12:20:37 <EvanR> given reversible laws of physics, and a game state (physical state), you can go back and get the game's past!
12:20:43 <EvanR> people like basketball
12:21:09 <dmwit> Ah... we are using an unusual definition of "you" here that involves more computing power than the universe has. Great!
12:21:12 <dmwit> ^_^
12:21:22 <EvanR> this is all on paper on course
12:21:38 <dmwit> I suspect to the watcher that has the requisite computing power, basketball does indeed qualify as uninteresting.
12:21:49 <EvanR> yes they know the past and the future
12:21:54 <EvanR> like dr manhattan
12:22:40 <juri_> dr manhattan only knows his past and future.
12:22:57 <juri_> like a pure function applied crosswise against time.
12:23:10 <EvanR> ok mr relativity
12:24:22 <EvanR> so basketball is not a solved game for the same reason chess isn't, computing power? heh
12:25:13 <dsal> I've got a thing running in ST and I want to be able to pass in operations to perform within that ST.  Is that even a thing?  The s is getting in my way.
12:25:47 <EvanR> operations that work for any s should work
12:25:53 <EvanR> which excludes IO
12:26:38 <basic> well :p but how would i make that function tho
12:26:39 <dsal> Yeah, it works when I call out from the ST, but I want to be able to pass these things *in* to the ST.
12:26:44 <merijn> dsal: You can only use operations that are unconstrained in S
12:27:00 <merijn> dsal: Are you putting them inside a datastructure?
12:27:20 <EvanR> pass what things exactly
12:27:22 <dsal> Yeah.  That works fine if I declare the data structure outside, e.g.   defaultSet :: InstructionSet s   -- but I can't pass that value  into a function.
12:27:47 <merijn> dsal: That's because you can't have a "forall s . " inside a data structure
12:28:01 <dsal> Heh, yeah, the compiler told me that.
12:28:10 <merijn> That requires ImpredicativeTypes which you can't use
12:28:40 <merijn> (because (limited) working ImpredicativeTypes are in progress for 8.10 or 8.12)
12:28:43 <dmwit> dsal: `foo :: ST s Int -> ST s Int; foo x = x` works fine here.
12:28:46 <leo__> "if a conduit produces too much output for the receiving sink to handle, some of it may be lost."
12:28:48 <EvanR> you can use a wrapper to do exactly this, but the real question is if it would make anyway sesne
12:28:50 <basic> well it.s simple
12:28:57 <EvanR> if it doesn't make sense, you'll get a different error later
12:28:58 <basic> boardrepresentation is easier to compute
12:29:02 <leo__> I don't understand it. When should it happen?
12:29:05 <basic> and that for a reason: it holds less information
12:29:14 <dmwit> dsal: Can you show us the smallest thing you tried that didn't work?
12:29:14 <merijn> leo__: If the sink stops, but there is still input upstream
12:29:39 <leo__> merijn: My generative tests indicates that I'm losing data with conduit.
12:29:42 <leo__> Very simple functions.
12:29:46 <leo__> Trying to find to culprit.
12:29:49 <merijn> leo__: Example?
12:29:49 <leo__> the*
12:29:54 <leo__> Can send you.
12:29:58 <dsal> dmwit: my function is basically      doStuff = runST $ ...      I want to pass in things that run inside that ST.  I think I just need to separate these parts.
12:30:09 * hackage libarchive 2.1.0.1 - Haskell interface to libarchive  https://hackage.haskell.org/package/libarchive-2.1.0.1 (vmchale)
12:30:28 <merijn> dsal: Yes, but it's very particular *how* you can pass them in
12:30:29 <dmwit> dsal: That's not complete enough for me to replicate your problem.
12:30:48 <merijn> dsal: Function arguments are fine, ST actions inside data structures are not
12:30:52 <leo__> https://dpaste.de/bi39
12:31:43 <leo__> First I thought it might be CC.peek. Now I'm thinking it's takeWhile?
12:31:45 <leo__> But wtf.
12:32:11 <dmwit> dsal: e.g. `doStuff :: (forall s. ST s Int) -> Int; doStuff x = runST $ x` works fine here.
12:32:27 <leo__> https://dpaste.de/bzRF
12:32:31 <leo__> This is the test.
12:32:41 <merijn> leo__: It's the takeWhile
12:32:43 <leo__> The lenghts differ.
12:32:48 <merijn> leo__: On line 29, for example
12:32:51 <leo__> I thought so.
12:32:53 <leo__> But why?
12:33:08 <dmwit> I don't understand what merijn's "function arguments are fine, ST actions inside data structures are not" means. It's probably wrong, though.
12:33:14 <merijn> leo__: Once the takeWhile finish and returns chunk your conduit stops consuming items from upstream
12:33:32 <EvanR> (forall s . ST s Int) can be an argument, but can't be stuffed into a record
12:33:59 <dmwit> e.g. `doStuff :: (forall s. Identity (ST s Int)) -> Int; doStuff x = runST $ runIdentity x` works fine here.
12:34:09 <leo__> merijn: Yeah, but that's the point.
12:34:17 <leo__> Then the peekForever kicks in and it's called again.
12:34:34 <EvanR> ok, nevermind :)
12:34:39 * EvanR rewriting the issue
12:34:41 <merijn> leo__: What? No
12:35:02 <merijn> leo__: Once sortIntervalByQuoteAcceptTime hits line 42 and completes that it stops
12:35:21 <merijn> leo__: Anything receiving items for further down the pipeline doesn't see anything
12:35:43 <merijn> leo__: "foo .| bar .| baz" once bar stops, baz gets nothing
12:35:52 <dsal> OK, I got it working by splitting my function in two.  The part that is inside ST and the part that splits things apart.  When I want to parameters the actions with a data structure of actions, that works fine as long  as I'm doing it within ST.
12:36:19 <leo__> merijn: Hm... Trying to follow.
12:36:30 <dsal> I'm doing AoC junk and guessing on what I'm going to have to do in the  future. https://www.irccloud.com/pastebin/Ut48LgE8/spoilers.hs
12:36:59 <merijn> dmwit: "It works once you explicitly quantify every single data structure with RankN and manually propagate that elsewhere" isn't "it just works", though
12:38:10 <merijn> leo__: "foo" yields 10 elements, "bar" consumes 5 via takewhile (and yields the sorted 5 elements downstream to baz), then bar terminates, leaving 5 unconsumed elements from "foo", "baz" only interacts with yields from "bar" so when "bar" finishes yielding it's 5 elements, "baz" gets no more items from upstream
12:38:47 <merijn> leo__: If you want "baz" to get all 10 initial elements then you need to modify bar to *also* yield the remaining 5 after the sorted yields are done
12:38:52 <monochrom> "It works once you explicitly quantify every single data structure with RankN and manually propagate that elsewhere" applies equally to both function arguments and record fields.
12:39:06 <leo__> merijn: I want to sort the whole stream, chunk by chunk.
12:39:21 <merijn> leo__: Then you need to loop bar
12:39:27 <monochrom> Especially for example in the case of function arguments you can't even rely on type inference, it just never works.
12:39:33 <merijn> leo__: Wrap the entire thing into "forever" for example
12:39:41 <leo__> It is into peekForever.
12:39:56 <leo__> line 73 and 74
12:40:37 <merijn> hmm, then I don't immediately know and am too tired to investigate further
12:41:03 <leo__> hehe no problem
12:41:33 <leo__> Maybe it's a problem with takeWhile leftover
12:41:38 <leo__> That's what I thought initially.
12:41:45 <leo__> Gonna investigate it further. .-.
12:44:04 <EvanR> "sort the whole stream" sounds like a hypercomputation or something
12:44:13 <leo__> xd
12:44:17 <leo__> It's simple actually.
12:44:25 <leo__> But for a newb ...
12:44:37 <leo__> *Like myself
12:44:51 <leo__> It's challenging.
12:45:07 <monochrom> Therefore it is not simple.
12:45:39 <monochrom> Or, it can be simple if you don't need efficiency.
12:45:45 <leo__> Yeah.
12:45:58 <monochrom> good, fast, cheap --- pick two.
12:46:31 <EvanR> reading in a huge file into memory to sort it and stream it out again kind of seems like defeating the purpose of streaming
12:47:45 <leo__> Hm.
12:48:12 <leo__> I've seen some interesting solutions to do that.
12:49:07 <leo__> Ah, into memory, I thought you said to the FS
12:49:19 <leo__> Yeah, I don't wanna do that.
12:57:37 <LolWaffer> Im trying to read all the lines of a text file ..   readModuleMasses :: String -> IO [String]readModuleMasses path =      (readFile path) >>= (\s -> lines s)
12:58:03 <dsal> lines <$> readFile Path
12:58:14 <LolWaffer> thanks
12:58:32 <LolWaffer> isnt >>= supposed to work as well?   
12:58:44 <dsal> readFile path >>= pure . lines
12:58:53 <dsal> What's the error you're getting?
12:59:12 <LolWaffer>     • Couldn't match type ‘Char’ with ‘[Char]’      Expected type: IO [String]        Actual type: IO String    • In the expression: (readFile path) >>= (\ s -> lines s)      In an equation for ‘readModuleMasses’:          readModuleMasses path = (readFile path) >>= (\ s -> lines s)
13:00:09 <LolWaffer> ok so (readFile path) >>= pure . lines   worked
13:00:33 <dsal> I'm not entirely sure how it's interpreting that, but the problem is that you have an IO action and you need to place your value into that monad.
13:00:54 <dsal> @undo do { x <- readFile path;  pure $ lines x }
13:00:55 <lambdabot> readFile path >>= \ x -> pure $ lines x
13:00:59 <dsal> @undo do { x <- readFile path;  lines x }
13:01:00 <lambdabot> readFile path >>= \ x -> lines x
13:01:10 <dsal> Hmm...  I don't actually know  what that does.  heh
13:01:36 <LolWaffer> @dsa
13:01:36 <lambdabot> Maybe you meant: msg do ask
13:02:22 <EvanR> place the square value in the square monad
13:02:39 <EvanR> round value in the round monad
13:02:41 <LolWaffer> @dsal thanks the pure . lines  thing worked.. im very new to haskell    ..      i thought that the    >>=  operator would allow me to operate on the sucessful result of the IO operation
13:02:41 <lambdabot> Maybe you meant: keal eval
13:03:05 <LolWaffer> and in case there was an error just return the IO monad as it is
13:03:29 <EvanR> the function passed to >>= needs to return an IO action 
13:03:41 <EvanR> that's your issue
13:04:08 <LolWaffer> ah i see now thanks EvanR
13:04:09 <EvanR> it's getting the result like you think, but then you need to abide by the export rule too
13:04:22 <EvanR> IO a -> (a -> IO b) -> IO b
13:05:20 <EvanR> `pure .' just means turn a value into an IO action that does no I/O (and just returns the value)
13:06:53 <LolWaffer> EvanR thanks that makes sense. Is pure the best way to wrap data in to an IO monad?
13:07:46 <EvanR> the only reason you needed it was because lines is not an IO function, has nothing to do with IO
13:07:47 <merijn> LolWaffer: Define "best" :p It's good enough
13:08:01 <EvanR> yet you needed it to satisfy the type sig
13:08:33 <EvanR> in other situations you will not need it, and putting it would be redundant. Then it's not very best or even good
13:09:53 <LolWaffer> is this correct:  pure is a function that is composed '.' with lines to wrap the result from the lines function in to an IO monad
13:10:05 <monochrom> The absolutely best is when you hire me to do it for 1000 bitcoins.
13:14:27 <Cale> LolWaffer: Note that the word "monad" refers to the type-level thing -- there is only one IO monad
13:15:02 <LolWaffer> Cale Thanks
13:15:17 <Cale> pure is the same thing as return (except with a slightly more general type)
13:15:41 <Cale> In the case of IO, it constructs an IO action which, if executed, will do nothing except to return that value as its result
13:16:29 <Cale> e.g. pure 5  or  return 5  is the action which does nothing, and produces 5 as its result, each time you run it.
13:16:51 <LolWaffer> Cale aha now i think i understand it better...   is this something related to Effects  that IO Action is a value ?
13:17:38 <Cale> Well, yeah, IO actions are things which can describe effects to be performed, in addition to producing a result at the end (assuming they actually finish running)
13:17:49 <Cale> for example, getLine :: IO String
13:18:11 <Cale> Is a value which describes the action of prompting the user for a line of input
13:18:29 <Cale> and its result each time you run it will be the text that the user typed
13:19:24 <LolWaffer> @Cale excellent now i think i understand.  Before i thought that IO was aresult of an IO but now i understand that IO is the actual operation
13:19:25 <lambdabot> Unknown command, try @list
13:19:26 <Cale> We combine together a bunch of IO actions in order to define 'main', which is the action which is run when you execute the compiled Haskell program.
13:20:12 <amalloy> how do i "publish" a stack project locally, as a private library for use in my other stack projects?
13:20:52 <LolWaffer> Cale cool that makes sense ..  i think i will like Haskell  ..      need to split.  Thanks for the help   Cale EvanR dsal
13:20:52 <Cale> Yeah, it's a common mistake to think that IO String means something like "this is a String, but it was produced by doing I/O", but really, it's the difference between String and IO String is like the difference between a list of files in your home directory, and /bin/ls
13:20:56 <dsal> amalloy: you can reference a local path or git repo or whatever.
13:22:38 <EvanR> A -> IO B meaning 'a function that does IO and returns a B' would be precisely nonsensical enough for people to believe computer people came up with
13:22:54 <EvanR> we've been trained to accept nonsense in computer languages
13:23:37 <EvanR> int f(int x, int y)
13:23:50 <EvanR> f returns an int, so we state it first
13:24:39 <monochrom> And that's wrong because...?
13:25:11 <EvanR> -> x x+1, lambda takes x as argument so we state it in the middle
13:26:36 <monochrom> IIUC you're saying that one of the following has to be nonsense: "obtain Y from X", "from X obtain Y".
13:26:38 <EvanR> monochrom: returning is a thing you often do last in C
13:26:39 * hackage xeno 0.3.5.2 - A fast event-based XML parser in pure Haskell  https://hackage.haskell.org/package/xeno-0.3.5.2 (ocramz)
13:27:12 <EvanR> julia version
13:27:40 <EvanR> function g(x::Int, y::Int)::Int 
13:28:25 <monochrom> Watch https://www.youtube.com/watch?v=Yz9u-oG3BgM and learn how it's legit to state something first even if it's the last thing to do.
13:28:40 <monochrom> "listen carefully"
13:29:44 <EvanR> i have to stop at 1 minute out of 5 to make sure you sent me a cookie monster video
13:29:50 <EvanR> intentionally
13:30:20 <monochrom> And what's wrong either way?
13:31:12 <EvanR> the 5 minute part
13:31:50 <monochrom> And what's wrong with 5 minute?
13:32:03 <geekosaur> now waiting for the arguments over "monads are a sometimes food"
13:32:16 <monochrom> haha
13:32:44 <amalloy> dsal: tbh i don't know how to create a public library either, so "make a public library but refer to its path instead of publishing it" is not necessarily enough for me. is https://www.haskell.org/cabal/users-guide/developing-packages.html#editing-the-cabal-file the set of instructions i want to follow, more or less?
13:33:46 <dsal> amalloy: For stack, it's basically mostly done.  The stuff in your src directory becomes  the library.  You  can upload  it to hackage and reference it like any other lib (almost, it's not automatically in LTS, but it's easy enough to add to stack.yaml)
13:33:49 <EvanR> monochrom: yeah and germans put the verbs last for some unknown reason, you're not making a case against nonsense here!
13:34:00 <merijn> EvanR: Only the 2nd verb
13:34:09 <merijn> EvanR: That's germanic languages in general, though
13:34:26 <dsal> amalloy: e.g., 3 of my libs that are published, but not in LTS that I'm using in this program: https://github.com/dustin/tesladb/blob/master/stack.yaml#L40-L43
13:34:34 <monochrom> So Yoda speaks nonsense, you say.
13:34:42 <EvanR> basically
13:34:56 <Cale> He's only a baby, cut him some slack
13:35:00 <monochrom> haha
13:35:01 <dsal> amalloy: And before I published the lib: https://github.com/dustin/tesladb/blob/a5497233a21457aa99325fb15e02c503a3a1071f/stack.yaml#L43-L44
13:37:28 <svipal> I'm currently just STUCK with megaparsec, tokens and stuff
13:38:16 <amalloy> dsal: thanks, i'll give it a try
13:38:56 <[exa]> monochrom: he speaks forth, what's wrong?
13:39:12 <monochrom> Nothing wrong. My point.
13:39:45 <[exa]> +1
13:39:46 <EvanR> in forth the last think you do is also last
13:40:08 <monochrom> No, in Forth the last thing I do is switching to Haskell.
13:40:26 <dsal> The last thing a forth programmer wants to do is switch to Haskell.
13:40:48 <EvanR> the last thing in an infinite list is
13:40:55 <Cale> but it is on the stack
13:41:16 <dsal> I assume stack is written in forth.
13:41:34 <[exa]> EvanR: you thunk you almost got it
13:42:21 <[exa]> svipal: are you stuck or literally stuck?
13:42:52 <svipal> I'm not using literate haskell, so just stuck
13:43:02 <svipal> *badum tss*
13:43:18 <[exa]> :]
13:43:28 <merijn> svipal: Stuck how? What are you trying to do? What's not working?
13:44:05 <monochrom> Perhaps it's just the "the prof requires megaparsec" kind of stuck.
13:44:09 <svipal> w8... generating smallest possible reproductible.. 
13:44:28 <svipal> It 's the 
13:44:33 <svipal> super tired kind of stuck
13:44:47 <dsal> Sleeping solves a lot of super-tired-kind-of-stuck problems.
13:45:12 <svipal> you know what, yeah
13:45:18 <svipal> will try again tomorrow morning
13:46:06 <[exa]> svipal: compendium of #haskell inhabitants demands a megaparsec problem to solve
13:46:49 <monochrom> How to solve the halting problem with megaparsec?
13:46:53 <dsal> I replaced one of my megaparsec things with dhall and it was pretty nice.
13:47:04 <dsal> NoProblem <$ "halting"
13:47:45 <dsal> I may be getting attoparsec and megaparsec confused. 
13:49:06 <nshepperd1> First wrap your megaparsec parser around a rotating black hole
14:00:39 * hackage hw-rankselect-base 0.3.2.4 - Rank-select base  https://hackage.haskell.org/package/hw-rankselect-base-0.3.2.4 (haskellworks)
14:00:56 <basic> so, i changed my code so it has a "gamesFrom" method now
14:01:06 <basic> that takes a game, and the result is a new game
14:01:14 <basic> (all games that can happen in the next step)
14:01:33 <basic> but how would i create the recursive structure that does that until there are no games left
14:03:30 <monochrom> That also depends on what you want to produce at the end.
14:03:51 <basic> well, in the end there should be a list of all possible games, just for the kicks
14:04:00 <basic> iterate (concatMap gamesFrom) $ gamesFrom []
14:04:16 <basic> that works.. but it will keep genereting the lastgame, since availableTurns will be [] at some point
14:04:20 <basic> (no place left on the board)
14:05:06 <basic> so that doesn't terminate, really
14:05:39 * hackage buffet 0.3.0 - Assembles many Dockerfiles in one.  https://hackage.haskell.org/package/buffet-0.3.0 (evolutics)
14:09:22 <basic> hm
14:13:39 * hackage tmp-postgres 1.27.0.3 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.27.0.3 (JonathanFischoff)
14:18:05 <fpbgnr> Hey guys, have you got any ideas on how to write this using fold/iterate? :)
14:18:08 <fpbgnr> myF xs n = n : concat (take 1 [myF xs (n*x) | x <- xs, myCond n x])
14:18:39 * hackage tmp-postgres 1.27.0.4 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.27.0.4 (JonathanFischoff)
14:19:32 <stilgart> basic: maybe with unfoldr instead of iterate
14:19:45 <basic> i gonna post my code in a sec
14:27:09 * hackage reflex-libtelnet 0.1.0.0 - Reflex bindings for libtelnet  https://hackage.haskell.org/package/reflex-libtelnet-0.1.0.0 (jack)
14:27:33 <basic> well i won't bcause im slow af
14:38:46 <dmwit> basic: if `moves :: GamePos -> [GamePos]` or similar, then `gameTree :: GamePos -> Tree GamePos; gameTree pos = Node pos (map gameTree (moves pos))`.
14:38:50 <dmwit> (to repeat myself from earlier)
14:39:04 <basic> yeah but i don't have a tree yet, that confuses me more than it helps
14:39:13 <dmwit> You get a tree by running that.
14:39:32 <basic> yes, but i don't need trees, imean there is a way without that
14:39:47 <dmwit> If you haven't solved the problem you have, how do you know what you need?
14:40:03 <Gurkenglas_> :t NE.unfoldr $ \n -> (n, (n*) <$> find (?myCond n) ?xs)
14:40:04 <lambdabot> (Num t1, Foldable t2, ?myCond::t1 -> t1 -> Bool, ?xs::t2 t1) => t1 -> NE.NonEmpty t1
14:40:10 <basic> well, because i solved it already.. but it doesn't terminate
14:40:19 <dmwit> Therefore you haven't solved it yet.
14:40:35 <basic> yeah.. and i want to solve it the way i started it before adding more stuff
14:40:36 <Gurkenglas_> (fpbgnr)
14:40:39 <basic> to not overwhelm my head
14:40:44 <basic> it's confusing enough already
14:40:52 <basic> if i add trees in the mix, i promise you, i won't see anything
14:41:02 <shachaf> Certainly not the forest.
14:41:08 <basic> good one
14:41:47 <koz_> Phyx-: Ping if you're around - I need some help figuring out why this Win32 refuses to stop when I close its main window.
14:43:07 <Phyx-> koz_: ?
14:43:18 <koz_> Phyx-: Let me just gist it up for you.
14:43:47 <Gurkenglas_> :t fromJust . last . takeWhile isJust . iterate (>>= \n -> (n*) <$> find (?myCond n) ?xs) . Just -- fpbgnr, if you insist on iterate
14:43:48 <lambdabot> (Num c, Foldable t, ?myCond::c -> c -> Bool, ?xs::t c) => c -> c
14:44:39 <fpbgnr> Gurkenglas_ Thanks! Okay, I thought it wouldn't be possible without Maybes with iterate, but I didn't think about unfoldr
14:44:50 <koz_> Phyx-: https://gist.github.com/kozross/9a5ae31cf41b10f16ee2aa7151fab88d
14:45:10 <koz_> Basically, this raises a window, but when I close the window, the program keeps going, instead of ending like I want.
14:45:37 <koz_> I've followed the MSDN tutorial(s) for building graphical stuff as far as I can tell, but for some reason, I'm not getting the right behaviour here.
14:45:39 <dmwit> I'm reminded of a go proverb about a student who kept taking games to his teacher and saying, "I think I screwed up here, here, and here, right?". The teacher would just nod, say "hmmm, hmm", agree, and send the student on his way. Until finally one day, the student said, "What do you think of this game?", and got an hour-long lecture on how to improve.
14:46:19 <dmwit> I am in favor of simple. I am in favor of not confusing students.
14:46:31 <dmwit> But when the programming task calls for a game tree... a list simply will not do.
14:47:06 <koz_> Don't send a list to do a tree's job.
14:47:30 <dmwit> If you ask questions, you may get excellent advice. But if you continue telling us we are doing it wrong... well. =)
14:48:38 <fpbgnr> Gurkenglas_ What does the ? mean in the unfoldr-version? Just for lambdabot?
14:50:57 <basic> is there a function that tells me if all elements of a list are equal?
14:51:17 <dmwit> fpbgnr: The search term you want is "implicit parameters".
14:51:27 <boxscape> fpbgnr https://downloads.haskell.org/ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-ImplicitParams
14:52:15 <dmwit> basic: Not in the standard libraries. It's relatively easy to write.
14:53:39 <basic> oh wow i wrote a cool function
14:53:42 <basic> im impressed
14:53:43 <phadej> :t ?f ?x
14:53:45 <lambdabot> (?f::t1 -> t2, ?x::t1) => t2
14:54:17 <phadej> it's ImplicitParams language extension
14:54:26 <fpbgnr> Oh, I see, thanks!
14:54:50 <dmwit> % data AllSame a = AllSame Bool a
14:54:50 <yahb> dmwit: 
14:55:00 <dmwit> % data AllSame a = AllSame Bool a deriving (Eq, Ord, Read, Show)
14:55:01 <yahb> dmwit: 
14:55:35 <dmwit> ...ah
14:55:38 <dmwit> No good.
14:56:02 <phadej> :t case ?xs of [] -> True; (x:xs) -> all (x ==) xs
14:56:03 <lambdabot> (?xs::[a], Eq a) => Bool
14:56:47 <dmwit> % data AllSame a = AllSame a | Different deriving (Eq, Ord, Read, Show)
14:56:48 <yahb> dmwit: 
14:57:24 <dmwit> % instance Eq a => AllSame a where AllSame x <> AllSame x' | x == x' = AllSame x; _ <> _ = Different
14:57:25 <yahb> dmwit: ; <interactive>:96:44: error:; Ambiguous occurrence `<>'; It could refer to either `Text.PrettyPrint.HughesPJ.<>', imported qualified from `Text.PrettyPrint.HughesPJ'; or `<>', imported from `Prelude' (and originally defined in `GHC.Base')
14:57:29 <dmwit> heh
14:57:33 <dmwit> Okay, I yield.
14:58:09 <koz_> dmwit: I don't think you'll get the Monoid instance (I guess) you want - the only mempty candidate is Different unless a is a Monoid already.
14:58:22 <phadej> Different wouldn't be a monoid
14:58:26 <phadej> 's mempty
14:58:35 <dmwit> Yeah, you can attach a mempty.
14:58:42 <dmwit> Ah, in fact, you have to. Okay.
14:58:43 <phadej> you'd need to use Option (AllSame a)
14:58:49 <dmwit> right
14:58:50 <phadej> or add a constructor
14:59:07 <phadej> or just use that small case expression, if you deal with lists
14:59:25 <dmwit> AllSame has the advantage that it can report the value that's the same.
14:59:26 <koz_> sconcat could also work if you have a NonEmpty.
14:59:40 <phadej> dmwit: well, that case would report it trivially too
15:00:14 <dmwit> Yep, not hard to fix up.
15:00:57 <basic> woaahhh it breaks my brain
15:01:02 <dmwit> True->Nothing, and toss an x <$ guard (...) in the other branch.
15:01:32 <dmwit> It's definitely how I'd write it if I only cared about lists ior wanted a nice simple codebase.
15:03:24 <phadej> there's still philosophical question, are all values of an empty lists equal?
15:03:33 <phadej> > all ('x' ==) []
15:03:35 <lambdabot>  True
15:03:37 <phadej> after all
15:03:54 <phadej> that "equal to" element is just not unique!
15:03:58 <dmwit> :t and [x==y | x <- ?xs, y <- ?xs] -- the specification, in my opinion
15:03:59 <lambdabot> (?xs::[a], Eq a) => Bool
15:04:32 <phadej> that gives True
15:04:38 <dmwit> (and what you wrote is certainly a correct optimization of that spec, assuming a sensible Eq instance)
15:04:51 <phadej> > and [x==y | x <- [], y <- [] :: [Int]]
15:04:54 <lambdabot>  True
15:05:04 * dmwit nods agreeably
15:05:11 <[exa]> for each thinkable pair the (==) holds right?
15:09:54 <basic> woah what does unfoldr do
15:10:36 <Axman6> :t unfoldr
15:10:38 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
15:10:51 <basic> yeah im playing around with it right now, but don't quite understand it
15:10:58 <basic>  unfoldr (\x -> if even x then Just (5,x) else Nothing) 2
15:11:00 <Axman6> what don't you understand?
15:11:03 <basic> my experiment
15:11:07 <basic> everything?
15:11:08 <iqubic> I have finally found a use for a do block in the Either monad.
15:11:24 <Axman6> I assume that gives you back repeat 5?
15:11:30 <basic> yes
15:11:37 <basic> src> unfoldr
15:11:41 <basic> :(
15:11:47 <iqubic> @src unfoldr
15:11:48 <lambdabot> unfoldr f b = case f b of
15:11:48 <lambdabot>     Just (a, b') -> a : unfoldr f b'
15:11:48 <lambdabot>     Nothing      -> []
15:12:20 <basic> so b is the thing which it keeps going with
15:12:24 <basic> and a is appended
15:12:29 <Axman6> > unfoldr (\(a,b) -> if a > 100 then Nothing else Just (a,(b,a+b))) (0,1)
15:12:31 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89]
15:12:41 <basic> co0l
15:14:09 * hackage gitlab-haskell 0.1.4 - A Haskell library for the GitLab web API  https://hackage.haskell.org/package/gitlab-haskell-0.1.4 (RobStewart)
15:16:31 <dmwit> So there's one really stupid implementation of unfoldr's type (\_ _ -> []). Making all the arrows linear eliminates that implementation.
15:16:51 <dmwit> err
15:16:58 <dmwit> Making just the right arrows linear eliminates that implementation. =P
15:17:05 <dmwit> (The first function should be duplicable, I guess.)
15:17:23 <dmwit> But there are still stupid implementations. Like it might decide that if it *would* produce a 2-element list, it will produce it in reverse.
15:17:34 <dmwit> Or generally could pick a permutation based on the result length.
15:17:58 <dmwit> Is there a type system variation that isn't too unnatural that would prevent that kind of stupidity?
15:18:02 <dmwit> (Probably not?)
15:18:37 <glguy> dmwit: If the types of the future elements were dependent upon the types of the previous ones you could ensure they were in the right order
15:18:49 <dmwit> Oh, I like that!
15:19:20 <basic> unfoldr (\b -> if b == 0 then Nothing else Just (b, b-1)) 10 
15:19:25 <basic> why does this use 2 parameters for Just
15:19:29 <basic> confuses me
15:19:35 <Axman6> it's a tuple
15:19:36 <glguy> There's the "next state"and the "output"
15:19:39 <Axman6> :t unfoldr
15:19:40 <basic> what is the first b in "Just (b,b-1)
15:19:40 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
15:19:42 <boxscape> basic it's just one argument
15:20:00 <dmwit> One is the list element to produce, the other is the next b value to iterate on.
15:20:11 <basic> oh, sure, yes
15:21:35 <iqubic> I'm looking for a function of the type: [Either a b] -> Either a [b]
15:21:39 <iqubic> Does it exist?
15:21:49 <glguy> sequence
15:22:05 <glguy> > sequence [Right 'a', Right 'b', Right 'c']
15:22:07 <lambdabot>  Right "abc"
15:22:12 <glguy> > sequence [Right 'a', Left 'b', Right 'c']
15:22:14 <lambdabot>  Left 'b'
15:22:24 <glguy> > sequence [Right 'a', Left 'b', Left 'c']
15:22:26 <lambdabot>  Left 'b'
15:22:35 <koz_> > sequenceA [Right 'a', Right 'b', Right 'c']
15:22:36 <iqubic> Can't I also use traverse?
15:22:38 <lambdabot>  Right "abc"
15:22:50 <koz_> iqubic: Yeah, but traverse id is sequenceA.
15:22:53 <koz_> :t sequence
15:22:54 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
15:22:57 <koz_> :t sequenceA
15:22:59 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
15:23:04 <koz_> Observe the similarity.
15:23:14 <basic> how does all that fit into a head, jeebus
15:23:28 <koz_> basic: It comes with practice - you start seeing the common features.
15:23:39 <basic> it took me month to understand (list) monad and sequenceA
15:23:47 <basic> and i already forgot what sequence (without a) is
15:24:05 <basic> im still doubting really hard that haskell in real world application is feasible
15:24:14 <basic> but i really like it.. kinda like a puzzle
15:24:23 <koz_> basic: A lot of organizations would beg to differ on that.
15:24:26 <basic> i wish it was useful (to me)
15:24:29 <koz_> Some of which are of considerable size.
15:24:39 <koz_> Haskell isn't something that can be learned in a day.
15:24:40 <iqubic> I want traverse here.
15:24:51 <basic> koz_: also years..if you don't do it every day
15:24:52 <basic> as it seems
15:24:58 <Phyx-> koz_: don't think your msgloop ever exits but don't know off top of my head. I'll take a look tomorrow for you. Gotta go to bed. Need to wake up in 5h for my flight 
15:25:07 <amalloy> i'm kinda surprised that hoogle doesn't turn up any results for [Either a b] -> Either a [b]. i thought it knew about unifying types with something like sequence
15:25:08 <basic> because im still struggling to make a tree of all possible tictactoe games :D
15:25:10 <koz_> Phyx-: Thanks - much appreciated!
15:25:24 * basic shouldn't have said tree
15:25:26 <koz_> I suspect that this is the issue, but I'm not too sure how to check.
15:25:28 <basic> that will make dmwit mad
15:25:30 <iqubic> I'm doing "sequence $ map f xs" which is clearly traverse, I think.
15:25:52 <amalloy> iqubic: yes, that is traverse (or mapM if you've got old habits)
15:25:59 <iqubic> :t sequence . map
15:26:01 <lambdabot> Traversable ((->) [a1]) => (a1 -> a2) -> [[a1] -> a2]
15:26:03 <koz_> iqubic: If your goal is just [Either a b] -> Either a [b], then sequenceA will do.
15:26:10 <dmwit> :t (sequence .) . map
15:26:12 <lambdabot> Monad m => (a1 -> m a2) -> [a1] -> m [a2]
15:26:12 <dmwit> :t traverse
15:26:14 <iqubic> It isn't though.
15:26:14 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
15:26:31 <dmwit> :t sequence $ map ?f ?xs
15:26:31 * koz_ mumbles something about the essence of the iterator.
15:26:32 <lambdabot> (Monad m, ?f::a1 -> m a2, ?xs::[a1]) => m [a2]
15:26:36 <dmwit> :t traverse ?f ?xs
15:26:37 <lambdabot> (Traversable t, Applicative f, ?f::a -> f b, ?xs::t a) => f (t b)
15:26:46 <iqubic> koz_: What's an iterator?
15:27:18 <koz_> iqubic: In general, it's a way of 'doing stuff' with 'elements' of a 'container', without specifying what 'doing stuff', 'elements' and 'container' are too precisely.
15:27:20 <dmwit> phew, `?f::a -> f b`
15:27:50 <koz_> I was referring to the paper with that name that talks about Traversable. A lot.
15:28:02 <iqubic> my goal is '[Either a b] -> Either a [b]' but the initial list comes from 'map f xs'
15:28:14 <basic> unfoldr (\g -> Just (g, filter (not.finished) $ concatMap gamesFrom g)) [[]]
15:28:19 <basic> does that make ANY sense :D ?
15:28:40 <basic> im too tired to know
15:29:16 <koz_> iqubic: I guess f is of type c -> Either a b or something?
15:29:20 <iqubic> Yes.
15:29:22 <iqubic> It is.
15:29:29 <koz_> Yeah, traverse is the entirety of the ticket here.
15:29:51 <koz_> 'traverse f xs' should do the trick.
15:30:13 <koz_> (one not-very-exact way of looking at traverse is that it's an 'effectful fmap')
15:30:23 <iqubic> I have (Int -> Either ErrorType Int) -> [Int] -> Either ErrorType [Int]
15:30:29 <iqubic> Which is a traverse.
15:30:41 <basic> holy shit it does make sense
15:31:00 <iqubic> koz_: This is for advent of code right now.
15:31:02 <basic> i just need to return nothing now when the game is finished
15:31:12 <koz_> iqubic: Ah.
15:31:26 <iqubic> I'm working on adding error handling to my Intcode interperter.
15:31:35 <basic> i don't know how this works, but it does, what is this magic
15:32:32 <iqubic> koz_: For the first time ever, I have a reason to use the Either monad.
15:32:48 <koz_> Yay!
15:33:07 <iqubic> step :: Memory -> Either IntcodeError (Bool, Memory)
15:33:31 <iqubic> type Memory = (Int, Seq Int)
15:34:00 <iqubic> Where the first element is the instruction pointer's location, and the second element is the tape.
15:37:45 <basic> is that what haskell is like? sometimes just putting stuff in as types suggest
15:37:47 <basic> and see that it works?
15:38:55 <iqubic> Yes.
15:39:02 <iqubic> It is magical.
15:39:14 <basic> that would be really impressive if i understood this correctly
15:39:26 <basic> because i have no clue what i did, and seemingly have the solution lol
15:39:48 <hpc> sometimes that's just how it goes
15:39:58 <hpc> for a good time, check out callCC
15:40:27 <hpc> it's the only definition matching its type without using any bottoms, but it's still rather non-obvious
15:42:45 <iqubic> Yeah.
15:43:50 <hpc> the more general lesson here is get your types right and everything else tends to just fall right into place
15:44:10 <hpc> that's probably helped me more outside of haskell than anything else
15:45:35 <boxscape> that process has been really helpful in helping me understand recursion schemes the other day
15:45:51 <boxscape> made me imagine how it would be to learn recursion schemes in python or javascript
15:50:05 <basic> @src concatMap
15:50:05 <lambdabot> concatMap f = foldr ((++) . f) []
15:52:36 <basic> i remember seeing another implementation hmpf
15:53:12 <boxscape> one without foldr?
15:53:23 <basic> yes
15:53:27 <basic> it used map
15:53:57 <boxscape> hmm, seems like that would less efficient (unless there's some rewriting rules to do fusion of map and whatever else was used)
15:53:58 <basic> well.. was it concat (map f smth)
15:54:03 <basic> or is that not equivalent?
15:54:07 <boxscape> it does the same thing
15:54:09 <dsal> @src fold
15:54:09 <lambdabot> Source not found. I am sorry.
15:54:12 <boxscape> but you traverse the list twice instead of once
15:54:18 <boxscape> with concat and map instead of foldr
15:54:24 <basic> yeah i understand that, but im traing to grasph it
15:54:35 <iqubic> Today I learned:
15:54:49 <iqubic> x :: (Int, (Char, Bool))
15:54:50 <basic> but concatMap f m = concat (map f m)
15:54:51 <basic> ?
15:54:57 <boxscape> semantically, yes
15:54:58 <dsal> I just assume there's always list fusion and it doesn't matter how many operations I do because they're small anyway.
15:55:29 <iqubic> x = (1, 'a', True) :: (Int, (Char, Bool)). Didn't know that worked like that.
15:55:46 <boxscape> > x = (1, 'a', True) :: (Int, (Char, Bool))
15:55:48 <lambdabot>  <hint>:1:3: error:
15:55:48 <lambdabot>      parse error on input ‘=’
15:55:48 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
15:55:56 <boxscape> > let x = (1, 'a', True) :: (Int, (Char, Bool)) in x
15:55:58 <lambdabot>  error:
15:55:58 <lambdabot>      • Couldn't match expected type ‘(Int, (Char, Bool))’
15:55:58 <lambdabot>                    with actual type ‘(Integer, Char, Bool)’
15:56:02 <boxscape> ?
15:56:06 <boxscape> explain yourself iqubic
15:56:29 <boxscape> (it does work like that in Idris fwiw)
15:56:46 <shachaf> Hmm, I also didn't know that, because it's not true.
15:56:57 <boxscape> also Constraints I would think more or less work like that
15:57:15 <iqubic> Right, I'm just wrong.
15:57:27 <boxscape> % undefined :: (Eq a, (Show a, Num a)) ~ (Eq a, Show a, Num a) => ()
15:57:28 <yahb> boxscape: ; <interactive>:97:14: error:; * Couldn't match type `(Eq a0, (Show a0, Num a0))' with `(Eq a0, Show a0, Num a0)'; * In the ambiguity check for an expression type signature; To defer the ambiguity check to use sites, enable AllowAmbiguousTypes; In an expression type signature: (Eq a, (Show a, Num a)) ~ (Eq a, Show a, Num a) => (); In the expression: undefined :: (Eq a, (Show a,
15:57:33 <boxscape> okay guess not
15:57:36 <boxscape> or wait
15:57:43 <boxscape> % :set -XAllowAmbiguousTypes
15:57:43 <yahb> boxscape: 
15:57:45 <boxscape> % undefined :: (Eq a, (Show a, Num a)) ~ (Eq a, Show a, Num a) => ()
15:57:46 <yahb> boxscape: ; <interactive>:99:14: error:; * Couldn't match type `(Eq a0, (Show a0, Num a0))' with `(Eq a0, Show a0, Num a0)'; * In the ambiguity check for an expression type signature; In an expression type signature: (Eq a, (Show a, Num a)) ~ (Eq a, Show a, Num a) => (); In the expression: undefined :: (Eq a, (Show a, Num a)) ~ (Eq a, Show a, Num a) => ()
15:57:49 <boxscape> well never mind
15:58:16 <basic> @src iterate
15:58:16 <lambdabot> iterate f x = x : iterate f (f x)
16:00:28 <boxscape> % :t fix (\f g x -> let y = g x in y : f g y)
16:00:28 <yahb> boxscape: (t -> t) -> t -> [t]
16:00:52 <boxscape> just got inspired because the source of iterate looks so similar to that of fix
16:01:14 <iqubic> "(f >>= g) >>= x" == "f >>= g >>= x" right?
16:01:34 <shachaf> If the question is whether >>= is left-associative, the answer is yes.
16:01:43 <shachaf> You can also ask ghci that question with :info.
16:01:53 <iqubic> boxscape: Those two give different results.
16:02:01 <boxscape> hmm darn
16:02:09 <basic> well, thanks for your help
16:02:09 <basic> gn
16:02:12 <iqubic> It's just the first element that's different.
16:02:16 <boxscape> right
16:02:34 <iqubic> iterate gives x as the first element, yours gives f x as the first element.
16:03:26 <boxscape> % fix (\f g x -> x : f g (g x)) (+1) 1
16:03:33 <yahb> boxscape: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127
16:03:38 <boxscape> the correct solution is actually slightly simpler than my incorrect one
16:03:47 <boxscape> arguably
16:04:25 <shachaf> @src iterate
16:04:25 <lambdabot> iterate f x = x : iterate f (f x)
16:04:58 <boxscape> @src fix
16:04:58 <lambdabot> fix f = let x = f x in x
16:05:00 <shachaf> You don't get any benefit from the "let x = f x in x" pattern in fix anyway.
16:05:06 <boxscape> oh, alright
16:05:07 <shachaf> (For iterate, I mean.)
16:05:15 <nshepperd1> :t \g -> fix (\k x -> x : k (g x))
16:05:17 <lambdabot> (t -> t) -> t -> [t]
16:05:30 <boxscape> ah, yeah, that's better
16:06:26 <boxscape> pl \g -> fix (\k x -> x : k (g x))
16:06:32 <boxscape> @\g -> fix (\k x -> x : k (g x))
16:06:32 <lambdabot> Maybe you meant: wn v rc pl msg id do bug bf @ ? .
16:06:36 <boxscape> @pl \g -> fix (\k x -> x : k (g x))
16:06:36 <lambdabot> fix . (ap (:) .) . flip (.)
16:06:45 <boxscape> I got it eventually
16:09:57 <amalloy> "Maybe you meant: wn v rc pl msg id do bug bf @ ? ." is indistinguishable from printing uninitialized memory
16:11:48 <boxscape> @bug
16:11:48 <lambdabot> https://hackage.haskell.org/trac/ghc/newticket?type=bug
16:11:52 <Axman6> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
16:11:52 <lambdabot>   Hello World!
16:11:54 <boxscape> hm that's a 404
16:33:17 <dsal> This lens AoC thing is nuts.
16:33:43 <ChaiTRex> What lens AoC thing
16:33:54 <iqubic> Yeah It is.
16:34:03 <iqubic> Has day 2 been uploaded?
16:34:37 <dsal> ChaiTRex: https://chrispenner.ca/posts/advent-of-optics-02
16:34:38 <ChaiTRex> iqubic: Day 2 was last morning. Day 3 is coming in about 4.5 hrs
16:34:57 <ChaiTRex> dsal: Thanks
16:35:15 <iqubic> ChaiTRex: I was asking about the blog post for Day to of Advent of Optics.
16:36:05 <ChaiTRex> iqubic: Ahh, OK.
16:36:15 <iqubic> What does guard do in a do block?
16:36:23 <boxscape> :t guard
16:36:25 <lambdabot> Alternative f => Bool -> f ()
16:36:31 <iqubic> Right.
16:36:33 <iqubic> I see.
16:36:47 <boxscape> I was just doing it to help myself understand :P
16:36:59 <hpc> @src guard
16:36:59 <lambdabot> guard True  = pure ()
16:36:59 <lambdabot> guard False = empty
16:37:17 <hpc> empty is going to be something like Nothing or []
16:37:18 <iqubic> I want something like that, but for either, with an option tag the failure with a given value.
16:37:37 <hpc> in list comprehensions, predicates end up being passed to guard
16:37:42 <iqubic> Ah. I see.
16:37:51 <boxscape> > do a <- [1,2,3]; guard (a < 3); pure a
16:37:52 <hpc> and it does the same thing in do-notation
16:37:53 <lambdabot>  [1,2]
16:38:38 <iqubic> I have a do block in the either monad.
16:39:35 <iqubic> One of my lines is "x <- f y".
16:40:28 <iqubic> I want to be able to use guard, but instead of just returning a default value in the Left, I want to supply my own value.
16:40:49 <amalloy> you probably can't use guard very well inside of Either, because there's no place to specify the result that should go in Left
16:41:24 <iqubic> Ah. So what should I use?
16:41:33 <amalloy> if is pretty good
16:41:43 <iqubic> How so?
16:41:47 <amalloy> you have a condition you want to test, and two different values you want to use depending on the result
16:42:23 <amalloy> do {...; if illegal x then Left "illegal" else do {...}}
16:42:44 <hpc> you can also use the semigroup instance, i think
16:42:58 <hpc> wait no, that swallows Left
16:46:38 <amalloy> i supposed you could factor out something like: predicate `orElse` failMsg = if predicate then Left failMsg else pure ()
16:47:17 <amalloy> hm, orElse's name is backwards there
16:47:35 <amalloy> then you could write: do {...; illegal x `errorsWith`"illegal"; ...}
16:48:01 <amalloy> but that's not really making the call site much clearer than just using if IMO
16:48:19 <iqubic> I'm not going to use `errorWith`
16:48:40 <iqubic> I'm just going to do:
16:49:29 <iqubic> val <- if illegal x then Left error else f x
16:53:06 <heebo> hello im using hspec to compare doubles , in other languages they have a tolerance when comparing floating point numbers, should i be using the same for haskell?
16:57:27 <amalloy> if you want useful answers, epsilon comparisons are much better than raw float equality, in any language
16:58:26 <amalloy> https://stackoverflow.com/q/6038740/625403 has some useful answers
16:59:54 <dsal> heebo: see https://github.com/dustin/haprs/blob/72f5c9f1eb684f84b5a02f48362257d1e8557021/test/APRSTests.hs#L386 for an example
17:05:49 <dsal> I.e., hunit supports it via magic, but whether it makes sense for your application is a different question. :)
17:39:10 <dmwit> iqubic: when (illegal x) (throwError whatever)
17:39:22 <iqubic> I'm not doing that.
17:39:31 <iqubic> I've got a system that works for me.
17:39:31 <dmwit> Why not?
17:39:43 <dmwit> Okay then.
17:40:40 <jle`> iqubic: fwiw 'error' doesn't really work, heh
17:41:01 <jle`> you're not really supposed to use it in actual code, except as a hacky temporary sort of thing
17:41:43 <amalloy> jle`: from context i think `error` is supposed to be a variable referring to a string, whose definition just wasn't shared with #haskell
17:41:55 <amalloy> rather than the actual prelude function `error`
17:42:42 <jle`> ah, i see
17:42:49 <iqubic> jle`: It was.
17:42:59 <iqubic> It was just a placeholder for a variable.
17:44:50 <dsal> iqubic: I use undefined as a placeholder for a variable.
17:45:10 <iqubic> I see.
17:46:20 <boxscape> % if { | True -> () }
17:46:21 <yahb> boxscape: ; <interactive>:1:1: error: Multi-way if-expressions need MultiWayIf turned on
17:46:30 <boxscape> % :set -XMultiWayIf
17:46:30 <yahb> boxscape: 
17:46:32 <boxscape> % if { | True -> () }
17:46:32 <yahb> boxscape: ()
17:46:35 <boxscape> hmm
17:46:44 <boxscape> oh I see why it didn't work in my ghci
17:47:01 <boxscape> or actually I don't
17:47:04 <boxscape> if { | True -> (); | False -> () }
17:47:06 <boxscape> % if { | True -> (); | False -> () }
17:47:07 <yahb> boxscape: ; <interactive>:5:18: error: parse error on input `;'
17:47:08 <boxscape> why doesn't this work?
17:47:27 <amalloy> the semicolon is nonsense. | is the separator you want already, no?
17:47:36 <boxscape> % if { | True -> () | False -> () }
17:47:36 <yahb> boxscape: ()
17:47:38 <boxscape> hm, I guess so
17:55:27 <boxscape> I assumed ; was inherently linked to explicit layout with { but I guess it's just inherently linked to `do` and `let` and such
18:04:57 <dmwit> It is linked to explicit layout. But MultiWayIf doesn't use layout.
18:05:47 <dmwit> Ignore me. I'm saying things without knowing them to be true again.
18:16:30 <d34df00d> Hi!
18:16:44 <d34df00d> I asked about optimizing calculating levenshtein distance the other day.
18:16:50 <d34df00d> Just wanted to share some of my own findings.
18:17:16 <d34df00d> So I had the inner (tight) loop of the form `forM_ [0..n - 1] $ \(!j) -> do ...`
18:17:42 <d34df00d> I rewrote it as
18:17:46 <d34df00d> let go j | j == n = pure ()
18:17:50 <d34df00d>       | otherwise = do ...
18:17:55 <d34df00d> (with tail recursion)
18:18:05 <d34df00d> and it gave an immediate speed up by a factor of two.
18:18:09 <d34df00d> Which I find quite cool.
18:18:45 <d34df00d> So now my version is only twice slower than a corresponding C version (but already looks equally ugly).
18:25:24 <dsal> d34df00d: why forM_ ?
18:26:11 <d34df00d> dsal: it's in a monad (ST) and forM represents the notion of looping over all indices the best I think.
18:26:18 <d34df00d> What else could be suitable here?
18:26:40 <dsal> Oh... Yeah, I was wondering what monad you meant.
18:27:31 <d34df00d> I'm sort of positively pleased tail recursive call at the end of a big do block still makes a difference and faster code.
18:27:46 <d34df00d> On the other hand, I wish ghc did this for me with the original forM_-relying implementation.
18:28:26 <d34df00d> Anyway, 0.48 s on some test data for Haskell vs 0.33 s on that data for C++.
18:28:32 <d34df00d> Much better than original 1.6 s for Haskell.
18:29:01 <dsal> Yeah, nice.  Criterion and core.
18:29:15 <d34df00d> Yeah, will do more benchmarks later on.
18:29:27 <d34df00d> Against edit-distance and text-metrics too.
18:29:31 <d34df00d> And against FFIying to C.
18:29:43 <dsal> I was trying to speed up a particular part of proto lens recently and went as far as to FFI the thing with a tight implementing.  It wasn't much faster.
18:29:46 <leo__> merijn: It was leftovers. xd
18:30:03 <d34df00d> (though that shouldn't be a big difference vs raw C++, since the string is huge so the relative cost of FFI shall be small)
18:30:14 <d34df00d> dsal: what's proto lens?
18:30:17 <leo__> takeWhile leftovers making me lose data with conduit. :|
18:30:36 <dsal> Protocol buffet lenses
18:30:41 <d34df00d> Ah.
18:30:48 <d34df00d> capnp plox.
18:31:53 <dsal> I do a lot of proto at work.  Added a couple features so far.  Very rich coat on that yak.
18:32:19 <d34df00d> Hehe.
18:32:30 <d34df00d> My place uses capnp a lot, hence my previous post.
18:32:35 <hololeap> @src fix
18:32:35 <lambdabot> fix f = let x = f x in x
18:32:41 <d34df00d> > fix error
18:32:43 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
18:32:45 <dsal> Need to write some data to a file. Better learn how to make ASTs for ghc code generators...
18:37:00 <iqubic> I'd love to have an indexed map for lists.
18:37:25 <dsal> What to you mean?
18:37:43 <iqubic> So that the function I pass to this indexed map can be of type (Int -> a -> b).
18:37:59 <iqubic> Or rather what I need is an indexed traversal.
18:38:10 <dsal> Oh.  Oh, that map
18:38:36 <dsal> @hoogle ixmap
18:38:36 <lambdabot> Data.Array ixmap :: (Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e -> Array i e
18:38:36 <lambdabot> Data.Array.IArray ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
18:38:36 <lambdabot> Data.Array.Lens ixmapped :: (IArray a e, Ix i, Ix j) => (i, i) -> IndexPreservingSetter (a j e) (a i e) i j
18:39:27 <iqubic> But I actually need this Applicative f => (Int -> a -> f b) -> [a] -> f [b]
18:39:43 <iqubic> :t traverse
18:39:44 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
18:39:50 <iqubic> I need an idexed traverse.
18:39:59 <dsal> Zip?
18:40:13 <iqubic> How would zip help me?
18:40:32 <dsal> :t traverse f . zip [0..]
18:40:33 <lambdabot> (Applicative f, Show b1, FromExpr (f b2)) => [b1] -> f [b2]
18:41:01 <iqubic> That didn't quite work.
18:41:14 <iqubic> :t \f -> traverse f . zip [0..]
18:41:16 <lambdabot> (Applicative f, Num a, Enum a) => ((a, b1) -> f b2) -> [b1] -> f [b2]
18:41:21 <shachaf> :t itraverse
18:41:22 <lambdabot> (TraversableWithIndex i t, Applicative f) => (i -> a -> f b) -> t a -> f (t b)
18:41:37 <iqubic> What library provides itraverse?
18:41:50 <shachaf> Probably lens.
18:41:59 <iqubic> I like the zip version better.
18:42:19 <iqubic> Because I want to have the indexs start at a point other than l.
18:42:30 <iqubic> *other than 1.
18:42:32 <dsal> Array is good for that.
18:43:15 <iqubic> I know dsal, but I'm not using arrays here.
18:46:02 <dsal> If it helps you, you could consider it. *shrug*
18:46:51 <dsal> I used arrays a few times last year and found it made things that were very difficult pretty easy.
18:51:44 <iqubic> What does zip do if one list is longer than the other?
18:51:51 <glguy> There's no way to know
18:52:32 <dmj`> > zip [1,2] ['a']
18:52:34 <lambdabot>  [(1,'a')]
18:52:42 <dmj`> iqubic: it does a little choparoo
18:52:53 <shachaf> I think that's one of the Millennium prize problems.
18:52:54 <dmj`> glguy:  :P
18:53:01 <shachaf> But my bet is that it's unknowable.
18:53:03 <iqubic> What does hackage mean when it says that zip is right lazy?
18:53:22 <iqubic> Does that mean that if one input is an infinite list, that should come first?
18:53:29 <glguy> > zip [] undefined
18:53:33 <lambdabot>  []
18:53:33 <shachaf> It probably means exactly the thing that it says after the ":" after "right-lazy".
18:53:37 <glguy> > zip undefined []
18:53:39 <lambdabot>  *Exception: Prelude.undefined
18:53:48 <iqubic> I see.
18:54:55 <shachaf> Assuming you're talking about http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-List.html#v:zip
18:55:00 <iqubic> Yes
18:55:42 <shachaf> But why read that when it's not even on the same line?
18:57:21 <dmj`> iqubic: are you ready for tonight
18:57:54 <iqubic> Yes.
18:58:02 <iqubic> I have my template all set up.
18:58:18 <iqubic> I have been slowly adding more robust generality to my intcode interperter.
19:04:08 <dmj`> iqubic: hah, yea?
19:04:17 <iqubic> Yeah.
19:04:26 <dmj`> what'd you do
19:04:29 <iqubic> case opCode of
19:04:33 <iqubic> 1  -> op 2 [Pointer, Pointer, Pointer] (\xs -> (product $ init xs, last xs))
19:04:37 <iqubic> 2  -> op 2 [Pointer, Pointer, Pointer] (\xs -> (product $ init xs, last xs))
19:04:48 <iqubic> op is a function that modifies the tape.
19:05:10 <iqubic> I did that, plus a whole bunch of error handling.
19:05:36 <iqubic> I can also chose Literal, instead of Pointer.
19:05:38 <dmj`> should that be `sum` instead of `product`
19:06:12 <iqubic> Yes.
19:06:53 <iqubic> Shit, well.
19:06:57 <iqubic> I broke something.
19:07:22 <dmj`> it's ok, just trying to help make things robust
19:07:27 <dmj`> what do you think about a state monad
19:07:34 <dmj`> and using lenses defined in terms of MonadState
19:07:38 <iqubic> That sounds like a large refactoring.
19:08:05 <iqubic> Also, my code no longer works.
19:08:58 <dmj`> iqubic:  I did that for a virtual machine implementation project https://github.com/dmjio/LC3/blob/master/src/Main.hs#L499 , it was very pleasant
19:09:31 <dmj`> you basically make a lens for each register you care about
19:09:52 <dmj`> then .= will set it in the state monad
19:09:55 <iqubic> I should learn lenses.
19:10:10 <iqubic> I don't use them, but it might be a pleasent way to do this.
19:11:48 <iqubic> dmj`: Do you use that approach for your intcode interperter?
19:12:10 <dmj`> > over both (+1) (1,1)
19:12:12 <lambdabot>  (2,2)
19:12:23 <dmj`> iqubic: no, for intcode I just used lists
19:12:42 <iqubic> I used Data.Sequence.
19:13:17 <dmj`> iqubic: did you consider using a list at all
19:13:28 <iqubic> No.
19:14:50 <dsal> Seq seems weird for that.
19:16:52 <iqubic> Why?
19:17:28 <dmj`> iqubic: list is tricky because there isn't a good insertAt function 
19:18:18 <dmj`> I used case \v -> splitAt idx list of { (ls,_:rs) -> ls ++ v : rs }
19:18:36 <iqubic> Ah.
19:19:41 <iqubic> I now have a nice 76 line long intcode interperter
19:19:50 <iqubic> Fully general too.
19:20:21 <dmj`> mine is 35 lines if you remove imports and comments
19:20:40 <iqubic> Mine is 76 with imports, comments and newlines
19:20:41 <dsal> Having an instruction set you can plugin is helpful.
19:21:24 <dmj`> iqubic: mine is 49 w/ imports comments and newlines, the whole enchilada module
19:21:27 <iqubic> I now have that.
19:21:48 <iqubic> dsal: I also have good error reports.
19:21:50 <dsal> I don't know how long mine is.  Can't reach it from the driver seat.  I think it fits on a page, though.  I had to do termination checking so I can solve the halting problem.
19:22:09 <dsal> I think I can do better. I used maybe instead of either.
19:22:28 <iqubic> You can solve the halting problem on yours?
19:22:48 <iqubic> Infinite loops will mess me up a lot.
19:23:21 <dsal> Nah, just erlang-style reduction counter.
19:23:32 <iqubic> Ah.
19:24:00 <iqubic> If we get jump commands later in the month, and have to find the first state that is repeated, I'll be a bit screwed.
19:27:21 <dsal> Hmm. Yeah, I'm not carrying and state through the execution.  I should fix that.
19:28:17 <iqubic> I could fix that, but it seems like a simple thing to do.
19:32:07 <dsal> I wonder if running StateT over ST would be expensive.
19:32:24 <iqubic> No idea.
19:32:28 <dsal> It I could just make a variable at that point.
19:33:16 <iqubic> mutable variables??!?! In my haskell??!?! Burn it all to the ground.
19:33:21 <leo__> dsal: Had the same doubt just now. xd
19:34:52 <dsal> iqubic: there's a place. I delved deep into ByteString recently.  It's bizarre.
19:41:18 <dmj`> just use the C FFI
19:41:26 <dmj`> it's very good
19:46:45 <iqubic> No. Hell no.
19:46:55 <dsal> It's still fine Haskell code, just with a box of effects
19:49:22 <dsal> Mainly, I just have less garbage.
19:49:31 <dmj`> iqubic: only way to get speed fast really
19:51:47 <dmj`> or just use libraries that have already done the optimization for you
19:53:56 <oats> @pl \(x, y) -> (x, y + 1)
19:53:56 <lambdabot> second (1 +)
19:54:05 <oats> which function 'second' is lambdabot referring to?
19:54:13 <dsal> That's what surprised me in proto lens.  The code looked pretty naive with its ByteString builder junk.  I couldn't make it consistently much faster.
19:54:27 <dsal> :t second
19:54:28 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
19:54:34 <oats> the one from Control.Arrow or Data.Tuple.Extra?
19:55:19 <dsal> I've seen the arrow one.
19:55:50 <jusss> now I wonder what is a `continuation'?
19:56:21 <oats> I feel even more afraid of Arrows now ol
19:56:25 <oats> *lol
19:56:48 <jusss> based on the wiki, if a language support `closure' and `TCO' then it can implement `callcc'
19:58:00 <pavonia> Total cost of ownership?
20:01:34 <dsal> Tail call optimization
20:02:48 <dmj`> iqubic: 1 hour left
20:06:34 <dmj`> literally cannot wait
20:06:45 <dmj`> I feel christmas inside of me
20:07:04 <iqubic> I want it to come now.
20:07:47 <jusss> ...
20:08:04 <jusss> do you want Jesus Christ come again now?
20:08:24 <dmj`> yes
20:08:44 <jusss> then it comes with the judgement
20:09:04 <jusss> the judgement day
20:09:54 <dmj`> ok
20:12:50 <jle`> i aint got anything to hide
20:13:02 <jle`> it's all about that reverential transparency
20:13:31 <iqubic> Oh god that was good.
20:16:18 <dmj`> judgement day is kind of like garbage collection in some sense
20:16:20 <dsal> I'm gonna be driving in snowy mountains when the next thing comes out.
20:19:43 <d34df00d> Wow, first time I'm seen such profit from -fllvm.
20:19:58 <d34df00d> 0.48s → 0.28s on my stupid benchmark!
20:20:05 <d34df00d> That's faster than C lol.
20:21:12 <dmj`> dsal: what's your strategy then
20:21:21 <dmj`> dsal: travel forward in time?
20:21:25 <dsal> "hold the wheel"
20:23:25 <dmj`> loool
20:35:51 * dmj` feeds his pet monad
20:37:24 <vaibhavsagar> ChaiTRex: is your handle a reference to the Hugs extensible records system
20:50:43 <ChaiTRex> vaibhavsagar: No, just T. rexes.
20:51:19 <vaibhavsagar> ah
21:14:39 * hackage jmacro 0.6.17 - QuasiQuotation library for programmatic generation of Javascript code.  https://hackage.haskell.org/package/jmacro-0.6.17 (GershomBazerman)
21:36:51 <rifkik> Hey everyone I migrated my code to Parsec and now it's broken
21:37:02 <rifkik> t's giving me the following errors.
21:37:02 <rifkik> https://pastebin.com/VGHiYSfS
21:37:30 <rifkik> The code can be found here https://github.com/IamRifki/segno
22:06:57 <jusss`> can I say (+1) is a continuation?
22:07:14 <jusss`> inC `bind` fn = \out -> inC (\inCval -> (fn inCval) out)
22:07:54 <jusss`> f = \x -> (\y -> x + y)
22:08:15 <jusss`> k3 = (+2) `bind` f
22:09:00 <jusss`> k3 2 1 raise an error, No instance for (Num (Integer -> Integer))
22:09:03 <jusss`> why?
22:09:11 <dmj`> vaibhavsagar: that was quit the doozy
22:09:14 <dmj`> for day 3
22:09:21 <dmj`> quite*
22:10:06 <jusss`> inC is the continuation k1, and fn contain another continuation k2
22:10:31 <jusss`> inC `bind` fn will get a new continuation k3
22:10:57 <vaibhavsagar> <dmj` "for day 3"> dmj`: I think the mapping between days and difficulty is somewhat arbitrary at this point
22:11:05 <jusss`> where I'm wrong?
22:11:16 <dmj`> manhattan distance was something like day 10 last few years iirc
22:11:27 <dmj`> doesn't matter I guess
22:11:35 <dmj`> vaibhavsagar: want to see my gross code
22:11:35 <vaibhavsagar> dmj`: IIRC one of the years had a spiral in day one
22:11:47 <vaibhavsagar> dmj`: of course I do
22:11:52 <dmj`> it's actually beautiful, in its own way
22:12:04 <dmj`> ok, but show me your code too
22:12:29 <dmj`> vaibhavsagar: https://github.com/dmjio/advent-of-code-2019/blob/master/3/3.hs
22:12:44 <jusss`> manhattan reminds me the dr.manhattan, a blue naked giant
22:12:52 <vaibhavsagar> <dmj` "ok, but show me your code too"> https://github.com/vaibhavsagar/advent-of-code/blob/master/2019/notebooks/Day03.ipynb
22:13:28 <dmj`> woa
22:13:42 <vaibhavsagar> dmj`: dang this code is great
22:13:44 <dmj`> attoparsec ??
22:13:52 <dmj`> bro u really be stuntin' this year
22:13:53 <vaibhavsagar> dmj`: my one true love
22:14:25 <vaibhavsagar> <dmj` "bro u really be stuntin' this ye"> it's the only parser combinator library i know how to use
22:14:48 <dmj`> vaibhavsagar: your code is great
22:14:50 <bahamas> is it a good idea to use List's set-like operations or better to just use Set?
22:15:06 <dmj`> none of us is glguy, but we do our best to get by as hard working blue collar haskell slobs
22:15:06 <vaibhavsagar> dmj`: aw, shucks
22:15:23 <dmj`> I'm going to hang this code up on my fridge
22:15:37 <dmj`> I didn't know github could render notebooks lol
22:15:39 <vaibhavsagar> another day in the lambda mines
22:16:08 <vaibhavsagar> dmj`: you would have learned this if you were at Compose this year
22:16:26 <vaibhavsagar> I did a talk about IHaskell
22:17:20 <dmj`> yea I know, I should've would've could've
22:18:30 <dmj`> I'm just an old emacs ghci guy
22:19:46 <vaibhavsagar> dmj`: you can still watch it at https://youtu.be/nYBW4ExtNvo
22:20:17 <vaibhavsagar> also what is emacs
22:21:10 <dmj`> its a small animal
22:22:08 <heebo> is there a command for comparing floating point numberrs with an epsilon/tolerrance in hspec?
22:22:41 <dmj`> @package ieee754
22:22:42 <lambdabot> http://hackage.haskell.org/package/ieee754
22:22:51 <dmj`> heebo: is what you want... Data.AEq
22:22:58 <dmj`> ~==
22:23:05 <heebo> thank you
22:23:09 <dmj`> https://hackage.haskell.org/package/ieee754-0.7.8/docs/src/Data-AEq.html#~%3D%3D
22:23:52 <dmj`> code is great, I have no problems with code
22:30:54 * dmj` sings, "Santa code is coming, to town"
22:36:13 <dmj`> I just think linked list is my favorite data structure
22:57:54 <koz_> dmj`: Interesting perspective.
