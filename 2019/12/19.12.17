00:00:01 <EvanR> it sounds like the important part of the procedural algorithm doesn't apply "when you do it wisely" so... what
00:00:32 <chambln> The objective is to minimise the makespan (completion date of last job) and mean flow time (average date at which the jobs are finished).
00:01:04 <Solonarv> okay, so I'm going to ask you a third time:
00:01:20 <Solonarv> after we schedule a task, we have to increase the current date
00:01:29 <Solonarv> yes or no?
00:01:31 <chambln> The full procedural algorithm is quite verbose, but I could type it up here if that helps.
00:01:37 <chambln> Solonarv: Not really
00:01:43 <chambln> There is no 'current date'
00:01:47 <dminuoso> So I have a large vector `Vector Interface` which I want to efficiently partition into `Map DevId Device` where `data Device = Device { devInterfaces :: V.Vector Interface }`
00:01:50 <EvanR> fax us the original assignment and get it over with 
00:01:53 <Solonarv> yes
00:02:18 <cipharius> the deadline is in relative time since the process has been run?
00:02:36 <cipharius> *assigned i guess
00:02:40 <EvanR> i love those deadlines
00:02:41 <Phyx-> koz_: did you figure out the GetWindowLong thing?
00:03:06 <koz_> Phyx-: I did. I'm on holiday at the moment though, so I can't test it, since it's for work code.
00:03:14 <koz_> Might find out if I actually got it in the new year. :P
00:03:17 <EvanR> also deadlines set relative time less than processing time wouldn't even make sense
00:03:23 <Solonarv> dminuoso: presumable 'Interface' is some sort of record with a 'DevId' field?
00:03:28 <Solonarv> *presumably
00:03:31 <chambln> The due date is the time since the first job started.
00:03:47 <dminuoso> Solonarv: Right
00:03:49 <chambln> Well okay the 'current date' is the datetime since the first job started.
00:04:15 <EvanR> so due date is in absolute time and time 0 is beginning of the schedule
00:04:22 <chambln> Yes
00:04:24 <EvanR> in other words
00:04:36 <EvanR> no surprises there
00:04:41 <dminuoso> Solonarv: Right now I have some MDevice data type that has a mutable version of that vector instead (it might be a HKT too, doesnt really matter), and I create a map which all keys/values are prepopulated, but with empty mutable vectors.
00:04:58 <dminuoso> But I throw useful information away with this approach
00:05:07 <Phyx-> koz_: ah ok, cool.
00:05:12 <Phyx-> holidays sounds nice...
00:05:44 <Solonarv> hmm, I'm not sure that those empty mutable vectors are all that helpful anyway
00:05:49 <Solonarv> let's see...
00:06:18 <chambln> http://mathb.in/38818
00:06:37 <dminuoso> Another approach I was thinking about, was using edkmetts discrimination to first partition/group that vector into sub-lists for each Devid
00:07:04 <Solonarv> yeah, and at that point turning this into a Map is fairly trivial
00:07:12 <Solonarv> can be done in linear time using fromAscList
00:07:17 <Solonarv> since it is already sorted
00:07:40 <dminuoso> Solonarv: Here comes the next catch: I could presort that list according to DevId already.
00:07:58 <Solonarv> ooh, so the input could already be sorted? even better
00:08:04 <dminuoso> Is there a sort of groupWith that works with presorted input?
00:08:11 <dminuoso> Or would I have to roll my own?
00:08:19 <Solonarv> hmm, I'm not sure
00:08:39 <Solonarv> but! actually this is very convenient because you don't even have to do any copying
00:08:42 <EvanR> :t groupBy
00:08:44 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
00:08:58 <Solonarv> oh right I'm a dummy
00:09:09 <dminuoso> Mmm
00:09:09 <Solonarv> group(With) doesn't do any sorting anyway
00:09:19 <dminuoso> Ahh, of course it doesn't.
00:09:24 <dminuoso> % :t group
00:09:41 <Solonarv> unfortunately there doesn't seem to be a groupWith for Vector
00:10:13 <Solonarv> but it should be a relatively simple matter to walk over the sorted Vector Interface and shove slices of it into a Map
00:10:30 <dminuoso> Solonarv: Lists dont perform that horribly if I have to linearly scan through them anyway
00:10:50 <Solonarv> true
00:10:58 <dminuoso> I mean locality of reference is gone already because my vectors are not unboxed
00:11:03 <Solonarv> I thought your input was already a Vector, is all
00:11:15 <Solonarv> and I don't know how big it is
00:11:40 <Solonarv> yeah basically just sort + partition, then shove into Map
00:11:45 <dminuoso> Solonarv: Right now it's on the order of 100,000 elements. 
00:11:55 <Solonarv> * shove into Map with a linear scan
00:12:03 <dminuoso> mmm
00:12:57 <Solonarv> you could use discrimination for the initial sort + partition step
00:15:38 <dminuoso> Solonarv: Maybe I should explain a bit on the details. I have a database where devices have many interfaces, and interfaces mave many IP addresses. Right now Im loading these data sets as three separate queries
00:16:40 <dminuoso> And then I want to reassociate these three database results inside a sort of graph
00:18:59 <Solonarv> yeah, makes sense
00:20:36 <EvanR> (man wouldn't it be nice if databases had this reassociation feature built in, before you get your results)
00:20:48 <Solonarv> heh
00:21:05 <EvanR> (without having to pay a fortune)
00:21:32 <dminuoso> The IP addresses I address differently because most interfaces dont have an IP address, so Ill just have some `IntMap IP` where I use the primary key of the ip address as the key.
00:21:35 <Solonarv> failing that, my approach would be: sort the input vector by devId, then write some complicated Vector.ifoldr (...) to insert slices of it into a map
00:22:10 <Solonarv> or possibly ifold{r,l}'
00:27:32 <Solonarv> let hd = devId (inputs ! 0) in Vector.ifoldl' (\(i,l,m) j e -> if devId e == l then (j,l,m) else (j, devId e, Map.insert l (Vector.slice (i+1) (j-i+1) inputs) m)) (-1,hd,Map.empty) (Vector.drop 1 inputs)
00:27:39 <Solonarv> something like this
00:27:53 <Solonarv> might be an off-by-one error or something
00:35:48 <aplainzetakind> My newtype for a (non-transformer) State monad complains that it's not an instance of MonadFail when I use pattern matching inside. I can't seem to derive it, ghc says it can't derive MonadFail because Identity has no instance.
00:36:49 <aplainzetakind> But I suspect it shouldn't be this inconvenient to use a pattern match in a newtype for State s.
00:39:03 <Solonarv> aplainzetakind: that is a feature, not a bug
00:39:48 <Solonarv> if you use a pattern bind that may fail (e.g. 'Just x <- foo') then the monad you are working in needs to have some notion of failure too
00:40:24 <aplainzetakind> I understood that, but I expected it to Just Work.
00:40:38 <aplainzetakind> Anyway I went around it by moving the match into a let.
00:40:44 <Solonarv> it used to "just work" by sneakily calling 'error' instead
00:41:00 <Solonarv> if you really want a runtime exception you can still do that, of course
00:41:02 <EvanR> what does State do ?
00:41:10 <EvanR> or can it not actually fail
00:41:18 <EvanR> ah because Identity can't fail
00:41:36 <Solonarv> State s a = StateT Identity s a ~R s -> (a, s)
00:41:37 <EvanR> nice
00:42:04 <dminuoso> EvanR: Well postgresql sort of has it..
00:42:22 <EvanR> that spoonful of "right afterall" medicine tastes so good
00:42:24 <dminuoso> EvanR: With PostgreSQL you can use aggregation functions and construct jsonb.
00:42:44 <dminuoso> It's what I already do in case of "interfaces (rarely) have multiple IP addresses"
00:42:44 <EvanR> json.. b?
00:42:58 <Solonarv> I think the 'b' stands for "binary"
00:43:07 <Solonarv> more compact I guess
00:43:18 <dminuoso> https://www.postgresql.org/docs/9.4/datatype-json.html
00:43:50 <dminuoso> EvanR: So what I do is, I have a CTE which does something like `SELECT array_agg(id), interface_id FROM ipam_ipaddress GROUP BY interface_id`, essentially
00:44:04 <dminuoso> EvanR: And then I just do a left outer join and grab that list of IDs.
00:45:47 <EvanR> postgres can do it, good
00:45:51 <EvanR> everyone use that
00:50:23 <fendor> Phyx-, I am not getting any error, we tried to help someone else who used cabal 2.4 and cabal install or something like this to install the library.
00:53:05 <merijn> Oh, oh, do I get to bet on "it's cabal-install 3.0 and someone as trying to use "install" as if it's v1-install"?
00:53:34 <dminuoso> EvanR: Well it's just not very performant, sadly.
00:53:59 <dminuoso> EvanR: You lose much of postgresql performance if you start encoding records into JSON, so its much faster to do this in Haskell
00:55:50 <sicklorkin> Are there any logging packages gear towards program analysis? Ekg is the closest thing I can think of that that resembles what I'm looking for.
00:56:05 <sicklorkin> s/that//
00:56:06 <Solonarv> Debug.Trace
00:56:08 * Solonarv ducks
00:56:14 <sicklorkin> lol
00:56:14 <dminuoso> sicklorkin: What exact program analysis do you intend to do?
00:56:27 <aplainzetakind> I want a function which takes a list, outputs a bunch of things, among which is another list. The output list is produced term by term (each term of the input produces one output). I put the "bunch of things" in a state, but it seems I can't access the list field lazily.
00:56:43 <aplainzetakind> Is State s inherently unsuitable for this.
00:56:44 <aplainzetakind> ?
00:56:50 <sicklorkin> dminuoso: for starters logCounter, logLabel, logGauge, logDisribution would be nice
00:56:57 <dminuoso> sicklorkin: There's a great prometheus package
00:57:15 <Solonarv> aplainzetakind: I think you can do it using lazy pattern matches?
00:57:31 <Solonarv> ~(Record listField _ _) <- get; ...
00:57:49 <sicklorkin> dminuoso: I want to log my bot, and during simulations it would be nice to see how things looked while it was running 
00:57:58 <Solonarv> there are two different State 's actually
00:58:05 <Solonarv> the one in Control.Monad.State is the lazy one
00:58:16 <dminuoso> sicklorkin: Is prometheus instrumentation an option?
00:58:33 <sicklorkin> *instrumentation sounds nicek, i'll have a look
00:58:38 <merijn> sicklorkin: You want online? i.e. profiling doesn't work?
00:59:00 <dminuoso> sicklorkin: https://hackage.haskell.org/package/prometheus-client-1.0.0/docs/Prometheus.html is what we use to instrument our programs with, it's quite nice
00:59:31 <sicklorkin> merijn: i wanna log mmopre complex types in the future
01:00:05 <merijn> I can't wait for 8.10 to launch with proper speedscope support :>
01:00:25 <sicklorkin> dminuoso: Thank you..
01:00:36 <jusss> data Maybe a = Just a';   this a' :: a
01:00:42 <dminuoso> sicklorkin: Wait, do you want to do *logging*?
01:01:03 <jusss> data Cont r a = Cont (a->r) -> r,  what have a?
01:01:09 <sicklorkin> fwiw winery is a perfect use case for what I want - but it would be nice to ahve some support for general metrics
01:01:15 <merijn> jusss: Nothing
01:01:29 <aplainzetakind> Solonarv: I am using Control.Monad.State.
01:01:36 <jusss> merijn: Cont r should be the monad?
01:01:38 <sicklorkin> dminuoso: yes, offline logging and post analysis of those logs
01:01:56 <jusss> merijn: so they can match to m a ?
01:01:56 <Solonarv> aplainzetakind: okay, then I can't guess what your problem is :/
01:02:09 <aplainzetakind> It could be the way I'm building the list.
01:02:13 <Solonarv> I can only tell you that it is sufficiently lazy for this to be doable
01:02:18 <Solonarv> alas, I have to go now
01:02:41 <merijn> jusss: Yes
01:02:43 <aplainzetakind> I'm applying a (. (x :)) to an [Int] -> [Int] field.
01:02:51 <aplainzetakind> Solonarv: OK, thanks.
01:02:54 <sicklorkin> dminuoso: the pipe line would be; start sim ; process logs as it runs; generate a report when it finishes
01:03:27 <merijn> jusss: If you have "Cont f :: Cont r a"", then "f :: (a -> r) -> r"
01:03:45 <jusss> merijn: I don't get it, in the do notation, a <- m a;    x <- Just 3; x would be 3, x :: a in m a
01:04:13 <jusss> merijn: so Cont (a->r) ->r  in the do notation, r <- Cont (a->r)->r, r is the a in m a?
01:04:24 <sicklorkin> dminuoso: I do plan to archive these logs for some period of time incase I notice a regression and want to compre metrics over different commits
01:06:40 <merijn> jusss: That's the problem with do notation, you don't magically "get" the result type
01:06:44 <merijn> :t (>>=)
01:06:44 <sicklorkin> maybe i should dig deeper into ekg, it may be simple enough to tie in a logger (if it deoson't already have some support)
01:06:47 <lambdabot> Monad m => m a -> (a -> m b) -> m b
01:07:14 <fenedor> merijn, yeah, exactly 
01:07:30 <merijn> jusss: Do notation is just sugar for >>=, you don't really "get" an 'a', you just give it an 'a -> m b', and that gets combined into 'm b'
01:08:28 <merijn> jusss: "do { x <- foo; bar x }" -> "foo >>= \x -> bar x" 
01:08:36 <jusss> merijn: Just 3 >>= \x -> ...  bind 3 to x
01:08:59 <merijn> jusss: To understand what it does for Cont you'll have to try and implement the Monad instance yourself
01:09:12 <jusss> merijn: Cont f >>= \x _. ... bind what to x if f :: (a->r)->r?
01:09:16 <merijn> Which is the only real way to understand Cont anyway, tbh
01:09:35 <jusss> ok...
01:09:39 <iqubic> "Most optics are really just `traverse` wearing different pants." -- Chris Penner
01:09:50 <merijn> jusss: You don't know what 'x' binds too, it depends on the continuation you're working with
01:20:00 <jusss> (Cont inC) >>= fn = Cont $ \out -> inC (\a -> (runCont (fn a)) out)
01:32:46 <jusss> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
01:53:56 <dminuoso_> Huh. Why is this giving me a parse error? https://gist.github.com/dminuoso/f8d680193f668071018f57e36ff8893b
01:54:26 <dminuoso_> Ohh!
01:54:31 <dminuoso_> Nevermind! Heh.
01:54:37 <dminuoso_> 5 minutes of staring didn't help
01:55:11 * EvanR sits there like a rubber duck
01:55:36 * Solonarv_ quacks silently
01:57:03 <RSWilli> did anybody find an algorithmic approach to todays (day 17) advent of code part 2? do I really have to write the code myself?
01:58:05 <sicklorkin> RSWilli: Have ou tried #adventofcode on functionalprogramming.slack
01:58:17 <Solonarv_> ...or ##adventofcode here on IRC ;)
01:58:23 <sicklorkin> nice
01:58:46 <sicklorkin> Solonarv_: are they synced?
01:59:06 <Solonarv_> not as far as I know
01:59:21 <yushyin> there is also ##adventofcode-help
01:59:34 <Solonarv_> but I have never been on the FP slack, so what do I know?
02:00:07 <sicklorkin> Solonarv_: good question
02:00:48 <Solonarv_> well, I know more abstract algebra than I did this morning
02:02:25 <sicklorkin> progress is good
02:10:33 <lavalike> @src foldM
02:10:33 <lambdabot> foldM _ a []     = return a
02:10:33 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
02:11:31 <Solonarv_> "fax", hehe
02:11:37 <lavalike> so I guess that can't be a foldA
02:11:49 <Solonarv_> :t foldM
02:11:52 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
02:12:22 <Solonarv_> hm, no I don't think so
02:13:03 <paraban> Hello! Maybe I'm missing something but how is the notion of binary operators represented in category theory? Also I would like to have some notion of homomorphic functions with functors when mapping one category to another?
02:13:34 <Solonarv_> newtype EndoM m a = a -> m a; instance Monad m => Monoid (EndoM m a) where (<>) = (<=<), mempty = pure
02:13:46 <amir_> hi all
02:13:47 <Solonarv_> now foldM is just foldMap @(EndoM m b)
02:14:12 <Solonarv_> which clearly needs Monad m
02:15:13 <Solonarv_> paraban: it depends on what kind of binary operator we are talking about and what you want to say about it
02:15:37 <Solonarv_> often they are just written like a binary function usually is in math: A x B -> C
02:17:30 <paraban> Say exponentiation or even monoidal `+`. And I want something like `F(a^e) == F a ^ F e`
02:18:51 <Solonarv_> ah, I see
02:19:17 <Solonarv_> so in this case you have categories C, D and a functor F: C -> D
02:20:04 <Solonarv_> as well as binary operations (^_C): C x C -> C, (^_D): D x D -> D
02:20:28 <paraban> Exactly.
02:21:06 <Solonarv_> then the property "F (x ^_C y) = F x ^_D F y" might be succintly stated as "F and ^ commute"
02:21:44 <Solonarv_> or to be slightly more precise you might draw a diagram and say "this diagram commutes| 
02:22:04 <paraban> And that's all? Nice, thank you!
02:22:20 <Solonarv_> yeah, you can pretty much just say what you mean there
02:26:01 <paraban> I've also been wondering how the notion of binary operators is represented in categories at large. Say "A monad is a monoid in the category of endofunctors" and then we can pick two morphisms `eta` and `mu` to represent "values" over which monoid operates. But it still doesn't tell me much
02:27:26 <Solonarv_> in this case you first need to pick a tensor product on that category of endofunctors
02:28:24 <Solonarv_> a common choice is the cartesian product (with _ -> 1 as the unit)
02:28:30 <paraban> And this tensor product is a binary operator? 
02:28:56 <Solonarv_> yep, a binary operator on the objects of the category
02:29:24 <Solonarv_> and it needs to be associative, and have a left/right identity
02:29:49 <paraban> And how do those operators differ for `Monad` and `Applicative`?
02:30:11 <paraban> And should those two morphisms (`eta` and `mu`) still be the same? 
02:30:29 <Solonarv_> to get Monad, you pick *composition* as the tensor product (and o -> o as its identity)
02:30:39 <nil> in the case of sets, the usual tensor product is the cartesian product: A × B is the set of all pairs (a, b) with a in A and b in B. then you define binary operators over sets as morphisms from A × B to C
02:31:07 <Solonarv_> to get Applicative you actually have two choices which turn out to be equivalent in Hask
02:31:27 <Solonarv_> you can pick the cartesian product with (_ -> ()) as the identity
02:32:03 <Solonarv_> then you get class Functor f => Cartesian f where unit :: f (); pair :: (f a, f b) -> f (a, b)
02:32:59 <Solonarv_> or you can pick Day convolution, which looks like data Day f g a = forall x y. Day (f x) (g y) (x -> y -> a)
02:33:34 <Solonarv_> then (after some fiddling) you get the usual Applicative
02:35:49 <paraban> I'm not exactly sure what "Cartesian product with `_ -> ()` as the identity" means
02:36:12 <Solonarv_> right, let me write it in more Haskelly terms
02:36:33 <Solonarv_> the cartesian product is just 'type Product a b = (a, b)'
02:37:09 <Solonarv_> and '_ -> ()' is 'type Unit a = ()' or, as a standalone datatype, 'data Unit a = Unit'
02:37:50 <Solonarv_> and we are only working up to isomorphism, so we consider '(a, (b, c))' and '((a, b), c)' to be the same
02:38:47 <Solonarv_> ah, actually the cartesian product is more like: 'data Product f g a = Product (f a) (g a)'
02:40:38 <paraban> So we get something like `a <> e == (,) <$> id <*> unit == (a, ()) ~ a` 
02:40:46 <paraban> Or did I get it all wrong?
02:40:53 <svipal> does GHC differentiate between functions and variables ?
02:41:38 <Solonarv_> svipal: not visibly, no
02:41:46 <Solonarv_> it does internally so it can optimize better
02:42:08 <Maxdamantus> I'd say it differentiates between definitions and bindings.
02:42:39 <Solonarv_> paraban: I wouldn't use that notation, as it is confused with the value-level Monoid
02:43:22 <Solonarv_> % 
02:43:22 <yahb> Solonarv_: 
02:43:40 <aplainzetakind> Are calls to error somehow ignored in a monad which is not an instance of MonadFail?
02:43:55 <nil> no
02:44:07 <Solonarv_> aplainzetakind: do notation doesn't change anything about 'error' calls
02:44:09 <paraban> That means it's correct? In a sense. 
02:44:15 <aplainzetakind> Interesting.
02:44:18 <paraban> And what are other notations then
02:44:24 <nil> error causes a runtime error whenever it's evaluated, regardless of the context. but it still needs to be evaluated
02:45:03 <paraban> aplainzetakind you will get a compile-time error, no? 
02:45:19 <Solonarv_> no, 'error' calls aren't a compile-time error
02:45:50 <paraban> Because do notations desugars into `fail` as well as `>>=` and `return`. And there is no instance for `fail` if itsn't not MonadError
02:45:58 <Solonarv_> MonadFail
02:46:00 <paraban> *nottation
02:46:02 <aplainzetakind> I have a function, if i write it as f :: m (Maybe a), and use it as f >>= someLoop, where someloop halts on Nothing, things work as expected.
02:46:03 <paraban> Yes
02:46:04 <Solonarv_> MonadError is something else
02:46:32 <aplainzetakind> But if I use f :: m a, trying to error out when a Nothing would be returned, the loop hangs.
02:46:36 <nyc> Is hpaste still around?
02:47:23 <Solonarv_> aplainzetakind: well, clearly your 'error' call isn't being evaluates
02:47:26 <boxscape> nyc both lpaste and hpaste aren't :(
02:47:29 <Solonarv_> can you show your code?
02:47:52 <day> looks like lpaste sold out to centos 
02:47:54 <boxscape> nyc oh wait, lpaste is, it's just a different pasting site now
02:48:09 <nil> % error "hi" >>= print
02:48:10 <yahb> nil: *** Exception: hi; CallStack (from HasCallStack):; error, called at <interactive>:74:1 in interactive:Ghci27
02:48:21 <aplainzetakind> I have to be away for a bit, I will when I get back, hopefully you'll be around.
02:48:26 <nyc> https://pastebin.com/8KGQBnV9
02:48:31 <day> hm maybe not :|
02:48:31 <Solonarv_> I will also be away for a bit, actually
02:48:36 <day> thought they relinked
02:48:56 <Solonarv_> will definitely be here again in 2-3 hours
02:52:46 <fendor> is there a difference between cabal build --only-configure and cabal configure? 
02:53:02 <fendor> besides that configure saves config changes
02:53:13 <fendor> *project config changes
03:05:03 <nyc> https://pastebin.com/dJajs1Bz
03:06:34 <nyc> I'm sure it could be golfed.
03:14:06 <t7> Does the Char type really make sense in a unicode world ?
03:14:19 <t7> String as a List of Chars is broken too
03:14:39 <t7> it should be a list of graphemes or something, but at that point its a List of List of codepoints
03:15:03 <paraban> `Char`s in Haskell aren't like `char` in C
03:15:36 <t7> yeah they are 4 bytes, right?
03:15:36 <paraban> `ghci> maxBound @Char`
03:15:38 <paraban> `'\1114111'`
03:15:57 <paraban> :t maxBound
03:15:58 <lambdabot> Bounded a => a
03:16:11 <paraban> Yes
03:16:56 <t7> but combining characters are not of much use on their own
03:17:47 <paraban> And `String` is sure broken. It's better to always use `Text` and `ByteString`
03:18:23 <t7> cool
03:23:01 <tdammers> String isn't broken, just misnamed
03:23:31 <tdammers> it's a non-strict singly-linked list of unicode code points; if that's what you need, then it works like a charm
03:31:27 <__monty__> paraban: You should clarify that ByteString is almost *never* the right choice for text.
03:32:40 <paraban> You are right, thank you
03:44:47 <Guest70> Hey can someone answer what I'm sure is a really stupid question for me?
03:45:30 <Guest70> I've fallen at the first hurdle of the CIS 194 homework.
03:47:27 <yushyin> Guest70: ask away
03:48:13 <Guest70> So I'm doing homework one I have to take Integer input and convert it to an Integer separated list 1234 -> [1,2,3,4]
03:48:50 <Guest70> I know I can use show to convert 1234 to a string and use read to convert it back to a integer but I have no clue how to iterate over the invididual items 
03:49:58 <__monty__> Guest70: Does it help to know that String = [Char]?
03:50:48 <shachaf> String sounds like a red herring.
03:51:04 <shachaf> There's nothing about either 1234 or [1,2,3,4] that has to do with String or Char.
03:51:43 <__monty__> shachaf: Doesn't matter. It's *a* way to solve it. Repeated modulos aren't better per se.
03:51:55 <boxscape> shachaf I would be pretty surprised if the intended solution wasn't to convert the number to a String
03:52:06 <__monty__> Yeah, it's more interesting.
03:52:29 <__monty__> I.e., more functional thought provoking that repeated modulos.
03:52:52 <haskell``> Are there some general guidlines and agreements on how to order the parameters of a function or is this handled rather inconsistently having only potential currying in mind? E.g. something like simple types before container types or the like?
03:53:13 <shachaf> No, it's a worse way to solve it. If someone is already trying to do it that way that's one thing, but pushing them down that path isn't helpful.
03:53:32 <cdunklau> eh, discrete math is good to know
03:53:41 <__monty__> They literally just said that's how they're trying to solve it.
03:54:55 <cdunklau> haskell``: looks like https://wiki.haskell.org/Parameter_order discusses it pretty extensively
03:55:20 <shachaf> That's not what I see.
03:55:44 <seishun> is there a utility function that turns a nested list into a list of ((x, y), element), where x and y are the indexes of the outer and inner list?
03:55:44 <cdunklau> shachaf: it was the fourth thing they said
03:55:47 <haskell``> cdunklau: Ah, perfect. Thanks for the link!
03:56:02 <__monty__> shachaf: "I know I can use show to convert 1234 to a string and use read to convert it back to a integer
03:56:05 <__monty__> "
03:56:18 <shachaf> Yep, I saw that message.
03:56:57 <cdunklau> haskell``: np, thanks for provoking my search. that question has been vaguely simmering in the back of my head for a bit
03:57:27 <shachaf> I see, "iterate over the invididual items" of the string.
03:58:10 <cdunklau> seishun: kinda sounds like you might want an array instead
03:58:20 <nil> seishun: no, but you can make it yourself:  flattenWithCoords l = [((x, y), a) | (x, row) <- zip [0..] l, (y, a) <- zip [0..] row]
03:58:26 <haskell``> cdunklau: I noticed I am going by feeling for the most part and realized I should probably make conscious and informed choiced in this regard.
03:58:45 <cdunklau> haskell``: bah, that sounds boring :D
03:59:03 <seishun> nil: thanks, I think it'll be more readable as a do-block
03:59:46 <boxscape> hm I'm going to have to take back my statement about the intended solution because it looks like the intro lesson of cis194 doesn't introduce the read function
04:00:18 <__monty__> boxscape: Does it introduce either quotRem or divMod?
04:00:38 <boxscape> it introduces div and mod __monty__
04:01:41 <__monty__> Now we know what the intended solution probably was. Still doesn't make the conversion through String a bad solution though, imo.
04:04:40 <shachaf> It's certainly a worse solution because it doesn't involve understanding how integers work, it can't be meaningfully changed, it's less efficient, etc.
04:04:52 <shachaf> It's just having someone else already write the program for you.
04:05:23 <__monty__> I disagree. It's more general since it works properly for any number.
04:07:03 <Guest70> Sorry I got dragged into something at work I've read through the previous messages.
04:07:18 <Guest70> so the aim is to do [toDigits should convert positive Integers to a list of digits]
04:07:34 <Guest70> in python which is what I'm useful I'd convert to str and then for x in str append to list 
04:08:23 <Guest70> that would be my usual logic I know I'm more than likely approaching it wrong so I'm happy to take suggestions on how it should be approached also ELI5 logic be great, I'm not overly technical and not paticularly strong in mathmatics :)  
04:09:35 <cdunklau> Guest70: as __monty__ mentioned, you can do this in haskell too. a String is a [Char], that is, a list of Char
04:09:57 <cdunklau> Guest70: but you can solve it another way, with just path
04:09:59 <__monty__> Guest70: Maybe try finding both solutions : ) In your approach you now have a [Char], so let's write a function that takes a [Char] and returns a [Integer].
04:10:00 <cdunklau> err math
04:13:04 <xenon-> Guest70, use show to convert Int to a String, then map over the characters with digitToInt
04:14:05 <__monty__> xenon-: Telling someone the answer teaches them nothing. You should've given them the chance to get there by themselves step by step.
04:16:37 <xenon-> __monty__, Guest still has to write that out in valid haskell
04:16:57 <__monty__> I assume they're trying to learn more than just syntax.
04:17:17 <xenon-> __monty__, there's more than one of them?
04:17:55 <xenon-> anyway, given the line of questions, and the level Guest is currently at, I doubt I spoiled all the fun of discovering the solution
04:19:19 <Guest70> Okay I've got to into a meeting unfortunately but thank you for all your comments.
04:19:32 <Guest70> I'll take a look and see if I can work it out and more than likely be back
04:20:00 <nil> https://en.wikipedia.org/wiki/Singular_they
04:20:35 <xenon-> nil, I know what it is. it is almost as ridiculous as writing he/she. but that's a topic for a different channel
04:21:41 <tdammers> clearly, we need to adopt a constructed language that is free of any and all social constructs
04:22:01 <nil> i vote for haskell
04:22:05 <evelyn> or just don't get worked up when someone uses they/them
04:22:07 <fendor> is it possible that cabal configure does not even call Cabal the library?
04:22:36 <merijn> fendor: What makes you ask?
04:23:26 <[exa]> nil: +1, let's lambda abstract any social constructs to the front of each sentence
04:23:33 <[exa]> software engineering yay!
04:23:47 <fendor> cabal build --only-configure -v shows some flags that are passed to Cabal, while cabal configure -v doesnt. In particular, I want to tackle https://github.com/haskell/cabal/issues/2209
04:24:50 <merijn> fendor: Are you using cabal-install 3.0?
04:24:53 <evelyn> [exa]: I have seen people write VSO English in comments just to obfuscate the code some more
04:25:05 <fendor> merijn, yes
04:25:41 <merijn> fendor: I'm guessing it only runs the Cabal code path for configure if the configuration has actually changed
04:26:18 <fendor> merijn, i dont think so, I deleted dist-newstyle, it should call Cabal then, right? Maybe cabal configure does not what I expect
04:26:28 <fendor> I suppose, it also does not install dependencies, right?
04:27:00 <fendor> it doesnt
04:27:24 <[exa]> evelyn: by VSO you probably don't mean "very superior old"?
04:27:29 <merijn> I don't know
04:27:39 <merijn> fendor: Honestly, it is very well possible that nobody knows
04:27:45 <day> [exa]: and then we can drop it straight into /dev/null!
04:28:06 <merijn> [exa]: Verb Subject Object ordering
04:28:17 <evelyn> [exa]: verb subject object like "Like me thon lambdas"
04:28:35 <merijn> fendor: The Cabal library code can be described as..."extremely legacy" >.>
04:29:02 <fendor> I think, it means that cabal configure is mainly used to configure state, such as cabal.project.local. And everything now just happens via the cabal build command
04:29:12 <merijn> fendor: And how it (eventually) ends up getting invoked is...tricky to find out
04:29:25 <[exa]> oh so, thanks
04:29:46 <fendor> this I already found out when trying to implement show-build-info support. It execs itself as if it was an executable
04:30:05 <merijn> fendor: Trigger warnings, please :(
04:31:02 <fendor> trigger warnings for what?
04:31:23 <merijn> fendor: Talking about Cabal internals >.>
04:33:18 <svipal> LOL
04:34:05 <fendor> luckily, I am not that deep into the internals yet
04:34:17 <merijn> svipal: You only think we're joking because you haven't worked on them >.>
04:34:35 <svipal> I don't think you're joking
04:36:01 <svipal> True that I only heard tales ! But I think I legit get some anxiety thinking about using TH to do nontrivial stuff now, so maybe I get the feeling lol
04:36:42 <svipal> What makes it that bad ?
04:37:05 <fendor> Cabal definitely doesnt need TH to be confusing. In fact, it is not even allowed to use TH due to cyclic dependencies on ghc, right?
04:37:52 <merijn> svipal: The entire control flow goes through some weird inversion of "configuring via API, then calling itself via commandline arg parsing that's very opaque"
04:38:29 <merijn> svipal: So to trace "the code I wanna change" to "the code I need to change to affect that" gets super confusing
04:38:32 <fendor> I would not even say that this is the most confusing part :D 
04:40:20 <fendor> I dont think it is really that bad. It is just a lot of code that is not well documented, so it very hard to find the places you actually care about
04:40:38 <fendor> missing orientation in this big code-base is for me the hardest part
04:41:41 <svipal> fendor - I was talking about my own PTSD with TH, not cabal :P
04:41:48 <fendor> sorry :D
04:42:07 <fendor> got confused
04:49:32 <rmorrison> Is there a way to stop infinite execution in ghci without closing ghci itself? 
04:50:00 <__monty__> rmorrison: Doesn't ^C do that?
04:50:17 <cdunklau> rmorrison: doing `show [0..]` and then ctrl+c works for me
04:50:19 <tdammers> it should
04:50:25 <rmorrison> For some reason after reboot ghci starts behaving strangely and I need to restart my console 
04:50:31 <rmorrison> I use `stack ghci` maybe that's why
04:51:12 <cdunklau> rmorrison: if you need to restart your _console_, that makes me think something is dumping binary crap to stdout
04:52:29 <__monty__> Yes and a `reset` issued on the commandline would probably suffice.
04:52:45 <rmorrison> __monty__ here https://paste.debian.net/1121378/
04:52:45 <__monty__> ^L may clear it up if it's just rendering issues.
04:53:29 <__monty__> That *is* strange.
04:57:17 <merijn> Oh, oh!
04:57:24 <merijn> 10 dollars says misconfigured locale
04:57:42 <merijn> Which OS?
05:01:50 <cdunklau> so ghci appears to dump errors to stderr. looks like the console might be unbuffered or something?
05:03:09 <cdunklau> hmm or not. thought it was interleaving, but i guess not
05:16:39 <rmorrison> Oh, sorry, my PC crashed when I was out, I'll read the logs
05:19:07 <rmorrison> merijn windows 10
05:20:54 <rmorrison> I also get this error 
05:20:56 <rmorrison> https://paste.debian.net/1121385/
05:25:00 <boxscape> I seem to get similar behavior with cmd in windows 10
05:25:59 <boxscape> rmorrison I sometimes use git bash with 'winpty stack ghci', but that still doesn't make Ctrl-C work properly. The only real solution I've found is to install haskell in the Windows 10 subsystem for linux, but of course that comes with other drawbacks
05:26:20 <boxscape> But there might be another solution for cmd
05:28:28 <rmorrison> boxscape I tried to use cygwin now, but it simply crashes after Ctrl-C
05:28:34 <phadej> chicolatey packages work nicely in powershell
05:28:47 <phadej> that though requires to not use stack
05:31:07 <AWizzArd_> phadej: if I want one route in Servant that acts as a proxy, how can I achieve that? I just want to receive a ByteString by doing myself an http request and stream it out to my own client. Independent of the Content-Type that was specified. I also would like to tell my client that I am sending JSON.
05:32:41 <phadej> if you don't want to do content(-type)/accept negotiation with servant, you have to implement own variant of Verb combinator
05:32:51 <phadej> or you can use Raw
05:32:58 <rmorrison> It actually works with `winpty`, thank you!
05:33:06 <phadej> both are ugly; because you do something shady
05:33:53 <boxscape> ah, good
05:35:07 <AWizzArd_> phadej: it is indeed a little bit shady, but in my case it is a microservice (that we have control over) which delivers json. But I don’t want to parse it first and then send it out. I trust my colleagues that they send valid json. I just want to forward it to a web client.
05:35:37 <phadej> you can make own TrustedJSON content typee
05:35:52 <phadej> MimeUnrender TrustedJSON ByteString where ...
05:36:04 <phadej> the content negotiation will still be done, but parsing not
05:36:07 <tdammers> AWizzArd_: in-depth security says you can't trust that json
05:36:29 <tdammers> AWizzArd_: point is, you need to trust not only your colleagues, but also every single bit of software and hardware that can touch the chain in any way
05:37:18 <phadej> but if you feel adventurous, you can use (unreleased) https://github.com/phadej/saison
05:37:26 <tdammers> AWizzArd_: you may trust your colleagues, but do you also fully trust the hardware that your services run on, the entire stack of software installed on both ends, the certificate chain securing the communication between them (you *are* using TLS between your services, yes?), etc.
05:37:38 <phadej> it's quite quick way of validation that JSON bytesting is well formed
05:37:53 <phadej> as is, quicker that parsing into full Value
06:56:12 <Putonlalla> Is there a package that implements the CIEDE2000 ΔE*?
07:09:27 <yasar> I am getting a type error at line 28
07:09:28 <yasar> https://gist.github.com/yasar11732/35caeaad2ce4b2bd2cc396cec30ae698#file-recursivecontents-hs-L28
07:10:10 <f-a> yasar: get used to paste the error in the gist, it helps receiving more answers
07:11:56 <yasar> pasted errors here: https://gist.github.com/yasar11732/35caeaad2ce4b2bd2cc396cec30ae698#file-error-log
07:12:20 <yasar> Appearantly I was just seeing the last error :/
07:12:31 <yasar> There are others
07:13:13 <f-a> I mean haskell errors are very easy
07:13:27 <f-a> e.g. for line 26
07:13:27 <f-a> Expected type: IO (IO [FilePath]) Actual type: (IO [FilePath], IO [FilePath])
07:13:42 <sm[m]> yasar: running ghcid in another window is great. It will always show you the first error, so you can focus on that
07:14:35 <yasar> sm[m] I am using `stack build` because I was stuck using cabal. Can I use ghcid with stack?
07:14:42 <f-a> yasar: I am very unconvinced by myFilterM
07:15:04 <sm[m]> and sometimes a good strategy is: comment out code until the errors go away. Then uncomment things v e r y  s l o w l y until you get one, and try to understand it
07:15:08 <f-a> most likely you wanted        myFilterM :: (Applicative m) => (a -> m Bool) -> [a] -> m ([a], [a])
07:15:28 <sm[m]> yasar: yes, ghcid will use stack automatically
07:15:49 <yasar> f-a it is supposed to work like filterM, but should return dropped items in seperate list
07:16:04 <f-a> if you want to use `(m [a], m [a])`, you need to pattern match on that and bind each one
07:16:50 <f-a> yasar: still the result should probably be m ([a], [a])
07:17:06 <f-a> think about it, when you use <- you need an `m a`
07:17:09 <dminuoso_> Is there some elegant way to generate a closed sum type out of an arbitrary number of *different* types?
07:17:14 <f-a> here you have no `m a`
07:17:38 <dminuoso_> Ideally some mechanism, allowing me to specify `x :: AnyOf [Int, Char, Bool]` with appropriate functions to discriminate on it?
07:17:40 <day> are where statements evaluated right away if i add them below a few pattern guards?
07:17:59 <dminuoso_> day: where statements are not evaluated at all
07:18:11 <merijn> where statements don't exist :p
07:18:22 <dminuoso_> day: where introduces *bindings* just like *let* does.
07:18:29 <merijn> There are where blocks that contain bindings :p
07:18:33 <dminuoso_> day: In fact where desugars into let. :)
07:18:37 <day> hm im getting an out of bound error which im trying to filter with the first pattern guard
07:19:10 <sm[m]> I'm trying to visualise day's code in my mind
07:19:16 <day> good
07:19:20 <rmorrison> day: indentation? 
07:19:59 <day> http://paste.debian.net/1121402/
07:20:31 <day> well the code *works* it just errors if i pass indices that are too high
07:20:54 <dminuoso_> day: What does that even do?
07:21:38 <day> it checks if a certain cell is surrounded with # 
07:22:18 <day> theres probably a much nicer way to do this but...
07:22:23 <sm[m]> !! is a partial function that gives errors
07:22:27 <sm[m]> yup
07:22:45 <day> which shouldnt be a problem because it should only be invoked where its safe
07:23:01 <rmorrison> `(inp!!0)` you may want to use `head` instead. `listToMaybe` is even better though
07:23:06 <boxscape> % let {f x | True <- x = 0 | True <- y = 1 where y = undefined} in f True
07:23:07 <yahb> boxscape: 0
07:23:12 <dminuoso_> day: Clearly your math is wrong. So its not safe.
07:24:20 <sm[m]> I think to answer your original question: the where bindings are evaluated lazily, as needed. Yours is getting evaluated when you didn't intend it to be, it seems
07:24:38 <dminuoso_> Anyway. Regarding my union, surely there's some library implementing `AnyOf '[Int, Char, Bool]` - this problem feels like there's libraries. :(
07:25:34 <sm[m]> a common error in that kind of code is a blank line in the input, trailing newline, or lack of trailing newline..
07:26:15 <sm[m]> traceShow can help debug it
07:29:58 <solonarv> dminuoso_: haskus-utils-variant ?
07:30:08 <solonarv> vinyl has something as well, I think
07:30:41 <solonarv> ah yes, vinyl has CoRec
07:34:16 <yasar> f-a Following your suggestions, I got rid of most error, but some persists : https://gist.github.com/yasar11732/35caeaad2ce4b2bd2cc396cec30ae698
07:35:42 <dminuoso_> solonarv: Mmm, the interface looks complicated
07:36:41 <solonarv> dminuoso_: which one? vinyl? that one tends to be a bit cumbersome to work with, yeah
07:36:50 <f-a> yasar: post the new version
07:36:51 <day> dminuoso_: your cookiecutter answer proved, against all odds, correct! i needed -2 not -1 :P
07:36:51 <dminuoso_> solonarv: Yeah vinyl
07:37:21 <solonarv> if you don't need the fancy HKD thing vinyl does, haskus-utils-variant is probably easier
07:38:07 <yasar> f-a it is here: https://gist.github.com/yasar11732/35caeaad2ce4b2bd2cc396cec30ae698#file-recursivecontents-hs
07:39:13 <f-a> yasar: why do you indent imports and everything else?
07:40:01 <yasar> vscode did that, so I thought I was supposed to indent whole module :)
07:40:56 <travv0> nope, but i just learned that you apparently *can* indent the whole module
07:40:58 <f-a> yasar: add a type signature to myFilterM' and the error should be self-evident
07:41:17 <geekosaur> technically everything following the module declaration "should" in some sense be indented
07:41:19 <solonarv> yasar: you *can* indent the whole module, but people almost never do
07:41:20 <merijn> travv0: Sure, it's inside a where block
07:41:41 <geekosaur> practically this is rarely done, but I've noticed editors indenting after the "where" of "module ... where"
07:41:41 <solonarv> I mostly just get annoyed at that auto-indent
07:41:57 <solonarv> I suspect they just naively indent anything following a 'where'
07:45:09 <boxscape> apparently (at least some of) the examples in the Haskell 2010 report put an indentation there
07:45:40 <boxscape> never seen it anywhere else though
07:46:08 <boxscape> and they don't do it with all examples, either
07:46:47 <solonarv> consistency? in MY language report?
07:46:54 <solonarv> it's less likely than you think!
07:48:17 <boxscape> % f (+) = 3 + 4 where infixr 5 +
07:48:18 <yahb> boxscape: ; <interactive>:80:30: error:; The fixity signature for `+' lacks an accompanying binding; (The fixity signature must be given where `+' is declared)
07:48:25 <boxscape> I am somewhat annoyed that you cannot do this
07:48:38 <boxscape> is there no way to supply a local fixity declaration for operator parameters
07:48:45 <solonarv> unfortunately, no
07:48:48 <solonarv> it would be nice
07:48:49 <boxscape> hm
07:49:50 <rmorrison> I have this big datatype. And I want to convert it to `ByteString`. Which is the most ergonomic way to do so? https://paste.debian.net/1121407/
07:50:22 <solonarv> rmorrison: do you just want to convert it and don't care about the exact output format?
07:50:39 <rmorrison> I care 
07:51:52 <Phyx-> 13:24:38 < boxscape> I seem to get similar behavior with cmd in windows 10 <-- that's because stack uses ghcii.sh which will launch a cygwin process
07:51:59 <Phyx-> so regarless if you're in cmd or not it doesn't matter
07:52:01 <dminuoso_> rmorrison: Do you understand what ByteString is?
07:52:02 <boxscape> I see
07:52:22 <solonarv> in that case you should probably write the conversion explicitly and should not rely on auto-deriving it
07:52:38 <Phyx-> anyway, cygwin 3.2 will have conpty support, so whenever msys2 updates to that it should work
07:52:54 <boxscape> ah, nice
07:52:59 <Phyx-> at least for any up to date Windows 10.
07:53:15 <dminuoso_> rmorrison: Anyway, you can use libraries like `cereal` to write serializers into bytestrings.
07:54:27 <solonarv> note that 'cereal' can auto-derive a conversion for you, but you can also write one yourself
07:54:43 <solonarv> using https://hackage.haskell.org/package/cereal-0.5.8.0/docs/Data-Serialize-Put.html
07:55:39 <rmorrison> dminuoso_, okay, thank you. Then If I shouldn't use `byteString` what is the best way to simply create big url, send GET, and get a body of a response?
07:56:02 <solonarv> ah, so that's qhat you were trying to do!
07:56:12 <solonarv> there are like 3 different libraries for that task
07:56:38 <solonarv> my go-to is
07:56:41 <solonarv> @hackage req
07:56:41 <lambdabot> http://hackage.haskell.org/package/req
07:57:34 <rmorrison> Thank you!
08:00:48 <merijn> Wait, is cereal still relevant?
08:01:02 <merijn> I thought it had pretty much been entirely obsoleted by binary?
08:01:08 * solonarv shrugsd
08:01:26 <dminuoso_> merijn: It's sort of a mixed story
08:01:36 <merijn> The main reason to use it was for strict ByteString, but binary supports those now too
08:01:38 <dminuoso_> merijn: cereal replaced binary because binary was lacking... lazy and strict bytestring stuff, and binary then added it?
08:01:41 <dminuoso_> Right
08:02:01 <merijn> I would also recommend not using the auto-derived serialisation of either binary of cereal
08:02:49 <f-a> why not?
08:03:02 <merijn> They're not guaranteed to be stable and not interoperable with other languages
08:03:25 <Amras> what's a good data structure for storing (Time, Value) pairs and searching within a specific time interval?
08:03:41 <Amras> I'm thinking just binary tree, but that's logn and I'm wondering if there's anything faster
08:03:45 <merijn> Amras: An SQLite database? :>
08:03:48 <Amras> heh
08:03:51 <dminuoso_> f-a: Also they are likely to not be what you want.
08:03:59 <merijn> Amras: Not even really joking, tbh
08:04:04 <merijn> Amras: Depending on the amount of data
08:04:10 <Amras> I want to keep things in-memory
08:04:16 <solonarv> sqlite can do that!
08:04:17 <merijn> Amras: SQLite can run in-memory
08:04:19 <geekosaur> interval trees, for searching within such
08:04:21 <Amras> til
08:04:51 <merijn> Amras: It supports both persistent file-based databases and ephemeral in-memory only ones (no ACID for those, obviously ;))
08:05:45 <merijn> Amras: Of course, once you dump it in SQLite anyway there's usually not much reason *not* to persist it too
08:05:46 <solonarv> oh apparently there is this:
08:05:51 <solonarv> @hackage IntervalMap
08:05:52 <lambdabot> http://hackage.haskell.org/package/IntervalMap
08:05:52 <ziman> traversing a contiguous interval of a binary tree is O(1) per step amortised, isn't it?
08:06:12 <merijn> Amras: How much data are we talking?
08:06:15 <Amras> solonarv, that's pretty much what I was looking for, thanks :)
08:06:37 <Amras> merijn, only a few MB; I just need really efficient access
08:06:47 <Amras> both for reads and writes
08:06:52 <solonarv> a few MB? that sounds like a reasonable size for sqlite actually
08:07:38 <boxscape> Amras that's still O(log n) though
08:07:44 <Amras> right
08:07:59 <Amras> I guess sqlite would be closer to O(1) because of indexing magic?
08:08:04 <solonarv> yes
08:08:04 <boxscape> (i.e. the IntervalMap is)
08:08:31 <merijn> solonarv: Anything from 1MB through several tens of gigabytes is reasonable for SQLite :p
08:08:54 <Amras> hm... I'll try the interval map first and if I'm getting performance issues I'll try and migrate to sqlite.
08:09:03 <merijn> solonarv: I was talking to a guy in ##sqlite who was handling terabyte sized database files daily >..
08:09:32 <solonarv> merijn: yes exactly
08:09:55 <solonarv> I initially thought the dataset might be too small for sqlite to make a useful difference
08:10:22 <merijn> solonarv: Sure, if it was like "100 entries" it's probably overkill
08:10:36 <merijn> Then again, with 100 entries it really doesn't even matter what you do ;)
08:10:48 <solonarv> yeah, which means you go for the thing with the easiest API
08:10:54 <solonarv> and that's probably IntervalMap, tbh
08:11:15 <merijn> Until you wanna do more than just query intervals, but also filter, etc.
08:11:34 <merijn> Experience has taught me that once you can easily query things, you magically start wanting too ;)
08:13:36 <rmorrison> `ghcid` requires restart each time I add a new package. Can I somehow automate it? 
08:14:21 <f-a> rmorrison: don't think so
08:14:27 <boxscape> Seems like you should be able to add your .cabal file to the files ghcid watched?
08:14:29 <f-a> (you mean, when you modify cabal, right?)
08:14:32 <boxscape> not sure how to add files to that though
08:14:39 <f-a> *.cabal
08:14:46 <boxscape> s/watched/watches
08:14:56 <merijn> You can, but I forgot how
08:15:24 <boxscape> rmorrison try --restart=mypackage.cabal
08:15:31 <boxscape> where mypackage is the name of your pacakge
08:16:50 <boxscape> at least that should work if you use something like `cabal repl` as the command for ghcid
08:17:30 <boxscape> so `ghcid --command='cabal repl' --restart=mypackage.cabal`
08:17:39 <rmorrison> Thank you, it works
08:17:46 <boxscape> nice
08:19:50 <yasar> I am making progress I guess, but I still can't figure it out :(
08:19:52 <yasar> https://gist.github.com/yasar11732/35caeaad2ce4b2bd2cc396cec30ae698#file-error-log
08:20:06 <yasar> https://gist.github.com/yasar11732/35caeaad2ce4b2bd2cc396cec30ae698#file-recursivecontents-hs
08:20:30 <f-a> yasar: which book are you following?
08:20:53 <boxscape> yasar try using pure instead of return, which is the less restrictive version of the same function but only requires an Applicative instance, not a Monad instance
08:20:54 <f-a> yasar: on line 9
08:21:17 <yasar> I diverged from tutorials a little, making my own exercises
08:21:34 <boxscape> yasar you didn't define pred anywhere
08:21:48 <f-a> predResult <- pred x <-- x is not wrapped in monad
08:21:53 <boxscape> yasar so it's just using the default definition
08:21:55 <boxscape> > pred 5
08:21:59 <lambdabot>  4
08:22:28 <boxscape> (or rather the Prelude definition)
08:23:15 <yasar> ohh, originally `myFilterM'` was part of where clause, but I separated it from main function to give it a type signature, I forgot about `pred` 
08:23:17 <boxscape> yasar in myFilterM' that is. You did define pred as argument in myFilterM (without prime), but myFilterM' can't see that
08:23:21 <boxscape> right
08:23:38 <boxscape> yasar you can still give it a type signature if it's in a where clause
08:24:09 <f-a> yasar: you can have type sigs in `where` too
08:24:56 <boxscape> yasar you also need the Applicative constraint in the type signature of myFilterM'
08:32:07 <yasar> I got it working : https://gist.github.com/yasar11732/35caeaad2ce4b2bd2cc396cec30ae698
08:32:16 <Amras> oh, seems I misspoke earlier
08:32:21 <boxscape> good
08:32:51 <Amras> what I'm looking for is something that stores points, but can be searched by intervals
08:32:55 <Amras> rather than storing intervals
08:33:04 <boxscape> yasar though I would generally advise to prefer pure over return if you don't need the Monad constraint for something else
08:33:11 <Amras> sqlite solves that problem too, though
08:33:12 <yasar> Control.Monad version of `filterM` works with Applicative, but I made it using Monad because I wanted to leverage do notation
08:33:26 <boxscape> ah
08:33:39 <yasar> Couldn't figure out how to make it work without `do`
08:33:43 <boxscape> the extension ApplicativeDo might work for that
08:33:57 <boxscape> it desugars do notation into Applicative functions where possible
08:34:25 <geekosaur> I think the if breaks ApplicativeDo here?
08:34:41 <boxscape> quite possible, I'm not really sure what works and what doesn't with it
08:35:29 <geekosaur> you can write that without do notation but it's annoying. don't worry about it too much
08:36:15 <geekosaur> it's good to learn how do notation is desugared, but avoiding do completely is often masochism
08:36:50 <boxscape> tbh I don't find desugared do notation *that* much worse
08:36:58 <yasar> I am trying to decypher this right now: http://hackage.haskell.org/package/base-4.12.0.0/docs/src/Control.Monad.html#filterM
08:37:13 <boxscape> (usually, anyway)
08:37:18 <geekosaur> you can simplify that a little, also: do (taken, dropped) <- wrapped; ...
08:46:10 <yasar> I am reading the type definition for `liftA2` , I think it converts a regular function to work inside an applicate, am I right?
08:46:37 <dminuoso_> % :t liftA
08:46:37 <yahb> dminuoso_: Applicative f => (a -> b) -> f a -> f b
08:47:10 <dminuoso_> % :t liftA2
08:47:10 <yahb> dminuoso_: Applicative f => (a -> b -> c) -> f a -> f b -> f c
08:47:58 <dminuoso_> yasar: One possible answer is: Functor lets you lift an unary function, Applicative generalizes this to work with n-arity functions.
08:48:41 <lavalike> I think that's a decent approximation yasar, I think that's why it's called a lift, it lifts the function into the applicative
08:49:48 <dminuoso_> yasar: So `Functor` lets you lift 1-ary functions, whereas `Applicative` lets you lift functions of arbitrary arity.
08:53:18 <suzu> wait what, is that true?
08:53:29 <dminuoso_> suzu: Yes.
08:53:35 <suzu> if you can lift a 1-ary function then you can lift arbitrary arity. can't you?
08:53:40 <suzu> 1-ary and n-ary are the same
08:53:52 <dminuoso_> suzu: In the sense of currying.
08:54:05 <suzu> i thought the distinction is that functor doesn't let you lift "into" it at all
08:54:08 <dminuoso_> suzu: For the matter of that statement, Im considering `a -> b -> c` a 2-arity function
08:54:20 <suzu> you can work /over/ it but can't go /into/ it
08:54:20 <dminuoso_> % :t fmap
08:54:21 <yahb> dminuoso_: Functor f => (a -> b) -> f a -> f b
08:54:26 <suzu> that is, you get fmap but not pure
08:55:50 <rmorrison> % :t fmap (+)
08:55:51 <MarcelineVQ> pure is liftA0, functor is liftA1, <*> is liftA2, which is enough to build liftAN
08:56:01 <yahb> rmorrison: (Functor f, Num a) => f a -> f (a -> a)
08:56:11 <rmorrison> % :t liftA2 (+)
08:56:12 <yahb> rmorrison: (Applicative f, Num c) => f c -> f c -> f c
08:56:25 <MarcelineVQ> er, I didn't mena to say <*> is liftA2, but hopefully the idea came across
08:57:23 <lavalike> > pure (\x y z -> x * y + z) <*> Just 10 <*> Just 3 <*> Just 2
08:57:26 <lambdabot>  Just 32
08:57:27 <MarcelineVQ> In fact none of that was worded well :>
08:57:42 <lavalike> > pure (\x y z w -> x * y + z * w) <*> Just 10 <*> Just 3 <*> Just 2 <*> Just 20
08:57:44 <lambdabot>  Just 70
08:57:55 <lavalike> n-ary in this sense
08:58:34 <suzu> the idea i have in my head is `functor lets you only transform what's in it` and `applicative lets you inject and work inside it`
08:58:58 <suzu> which both fall short tbh
08:59:30 <suzu> i have no real good way of abstracting these ideas in english. just looking at the typeclass defn and examples of what is/is not each is how i really /really/ think of it
08:59:32 <suzu> :?
09:00:43 <rmorrison> `Applicative` lets you combine actions, `Functor` does not
09:01:27 <suzu> yes
09:11:26 <yasar> `f a b = a + b; liftA2 f $ (Just 2) (Just 3)` -> doesn't work
09:11:54 <yasar> % :t liftA2
09:11:55 <yahb> yasar: Applicative f => (a -> b -> c) -> f a -> f b -> f c
09:12:37 <MarcelineVQ> liftA2 f $ (Just 2) (Just 3)   is   (liftA2 f) ((Just 2) (Just 3))    in other words you're applying (Just 2) to (Just 3) which is an error becuase Just 2 isn't a function
09:12:39 <yasar> % :t f = a + b
09:12:39 <yahb> yasar: ; <interactive>:1:3: error:; parse error on input `='; Perhaps you need a 'let' in a 'do' block?; e.g. 'let x = 5' instead of 'x = 5'
09:13:55 <MarcelineVQ> the $ isn't needed there in the first place though so it's an easy fix
09:34:50 <yasar> I implemented `myFilterM` like `Control.Monad.filterM` , I feel like a wizard now :)
09:35:03 <yasar> myFilterM https://gist.github.com/yasar11732/35caeaad2ce4b2bd2cc396cec30ae698#file-recursivecontents-hs-L11
09:43:41 <yasar> is there monadic version of `$` ?
09:44:01 <glguy> :t (=<<)
09:44:05 <lambdabot> Monad m => (a -> m b) -> m a -> m b
09:44:09 <solonarv> :t (<$>)
09:44:10 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:44:44 <Putonlalla> :t (<*>)
09:44:45 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
09:46:57 <yasar> https://gist.github.com/yasar11732/f2aa32eb21a6b05d055f734d02d7172d
09:47:10 <yasar> I am trying to get rid of `contents` variable here
09:49:18 <phadej> getRecursiveContents "." >>= mapM_ putStrLn -- I assume you know how `do` is desugared?
09:50:55 <yasar> phadej I have a vague idea :)
09:52:39 <phadej> so your do is desugared to `getRecursiveContents "." >>= \contents -> map_ putStrLn contents`
09:52:44 <phadej> and you can start golfing from that
09:52:57 <phadej> mapM_*
10:07:37 <dmwit> ?let inject p a = let b = p a in ([a | b], [a | not b])
10:07:40 <lambdabot>  Defined.
10:07:55 <dmwit> :t \p -> getAp . foldMap (Ap . pure . inject p)
10:07:58 <lambdabot> (Foldable t, Applicative f) => (a -> Bool) -> t a -> f ([a], [a])
10:08:30 <dmwit> yasar: ^
10:08:39 <dmwit> yasar: Also, this should be called partitionM, not myFilterM!
10:10:07 <dmwit> Oh no, this is no good, it doesn't allow the predicate to be effectful.
10:10:27 <deech> Does anyone if there is some nice way in Cabal to have caches that don't trigger rebuilds if you're continually switching branches? https://www.haskell.org/cabal/users-guide/nix-local-build.html#caching
10:10:36 <dmwit> ?let inject p a = (\b -> ([a | b], [a | not b])) <$> p a
10:10:38 <lambdabot>  .L.hs:181:14: error:
10:10:39 <lambdabot>      • Couldn't match type ‘([a], [a])’ with ‘[a]’
10:10:39 <lambdabot>        Expected type: ([a], [a])
10:10:41 <dmwit> ?undefine
10:10:42 <lambdabot> Undefined.
10:10:42 <dmwit> ?let inject p a = (\b -> ([a | b], [a | not b])) <$> p a
10:10:44 <lambdabot>  Defined.
10:10:51 <dmwit> :t \p -> getAp . foldMap (Ap . inject p)
10:10:53 <lambdabot> (Foldable t1, Applicative f) => (t2 -> f Bool) -> t1 t2 -> f ([t2], [t2])
10:11:06 <dmwit> Much better. ^_^
10:12:51 <dmwit> deech: Perhaps you could have a script which does, roughly, `git checkout <branch> && ln -sf dist-newstyle.<branch> dist-newstyle`
10:13:16 <dmwit> Perhaps toss a `mkdir dist-newstyle.<branch>` in there just in case it doesn't exist yet.
10:13:28 <deech> dmwit: Thanks! I have something similar, just wanted to check if there Cabal had something I was missing.
10:13:37 <dmwit> Not that I know of.
10:17:16 <dsal> I was thinking about using dhall for a project, but I need great circle.  Doing that in dhall would be a bit hard since it doesn't have sin, etc...  I can implement those, but it also doesn't have any other Double operations.  I can implement those...  The hard part usually seems to be figuring out how to represent the thing I want to do.
10:31:21 <Guest52904> ciao
10:33:54 <zzz> if i have a recursive function that adds a list of values to an accumulator on every iteration, how can I avoid (++) ?
10:34:07 <zzz> as in: `go (x:xs) (y:ys) acc = go xs ys $ [(x',y') | x' <- [x..99], y' <- [y..99]] ++ acc`
10:36:58 <Chai-T-Rex> zzz: You can probably do a fold.
10:36:59 <Philonous> zzz, As long as you only prepend the concatenations will be O(n), not O(n^2), as the tail can be shared, so it's hard to do better without using different data structures
10:39:43 <zzz> Philonous: ths was my intuition but wasn't sure if for some reason prepending a list comprehension would have weird side effects
10:39:50 <zzz> thanks
11:02:39 <cdunklau> i'm finding it incredibly hard to google haskell stuff :/
11:03:02 <Rembane> cdunklau: What are you trying to find?
11:06:46 <cdunklau> is there a builtin thing for carried succ? like, triSucc :: (Enum a) => a -> (a, a, a)  triSucc a = a -> (a', a'', a''') where a' = succ a \n a'' = succ a' \n a''' = succ a''
11:07:17 <cdunklau> i feel like i'm missing something obvious
11:07:51 <cdunklau> Rembane: ^
11:08:03 <amalloy> returning a 3-tuple is weirdly specific. would you be happy with (iterate succ :: Enum a => a -> [a])?
11:10:11 <Zipheir> Hi all, is there some variant Maybe in which I can use Nothing as a unit element?  e.g. I'd like to be able to have something like: sequence [Nothing, Just 5] -- => Just [5]
11:10:12 <cdunklau> amalloy: because lines 5-8 irritate me :) https://bpaste.net/show/3QP7A
11:10:32 <solonarv> Zipheir: are you perhaps looking for catMaybes?
11:10:35 <solonarv> :t catMaybes
11:10:38 <lambdabot> [Maybe a] -> [a]
11:11:36 <dsal> cdunklau: You can do that with lenses, but it's a bit weird.
11:11:40 <Zipheir> Yes, that works.
11:11:42 <dsal> > over each succ (1,2,3)
11:11:44 <lambdabot>  (2,3,4)
11:11:48 <amalloy> cdunklau: (_:xAdAd:yAdAd:instrPtr':_) = iterate succ instrPtr
11:12:11 <cdunklau> dsal: that doesn't look very weird to me
11:12:14 <MarcelineVQ> What is the task triSucc is assisting with?
11:12:17 <cdunklau> amalloy: is... that safe?
11:12:17 <dsal> I mean what you're doing is weird.  :)
11:12:37 <amalloy> why wouldn't it be?
11:12:47 <amalloy> or i guess instead of iterate succ x, you can write [x..]
11:12:55 <solonarv> unfortunately, it isn't safe
11:13:00 <solonarv> > iterate succ False
11:13:02 <lambdabot>  [False,True,*Exception: Prelude.Enum.Bool.succ: bad argument
11:13:08 <dsal> solonarv: nobody  died!
11:13:11 <cdunklau> lol
11:13:13 <amalloy> solonarv: we've linked to https://bpaste.net/show/3QP7A, which uses Int
11:13:28 <solonarv> Int has a max bound too!
11:13:40 <solonarv> > iterate succ (maxBound - 2 :: Int)
11:13:42 <lambdabot>  [9223372036854775805,9223372036854775806,9223372036854775807,*Exception: Pre...
11:13:47 <cdunklau> MarcelineVQ: https://bpaste.net/show/3QP7A
11:14:03 <amalloy> it's as safe as anything else that uses succ 3 times
11:14:26 <cdunklau> you have a point there
11:18:11 <cdunklau> amalloy: what's the (_:xAdAd:yAdAd:instrPtr':_) thing do? i'm confused about the _ on the ends
11:19:33 <rihardsk[m]> hi, am i right in thinking that defining an `instance Num a => Num (Inf a)` for `data Inf a = NegInf | Only a | PosInf` is imposible? it seems to me that it's impossible to define multiplication, because i can't get to know if the underlying number is negative or positive - `NegInf * (Only a) = ... NegInf or PosInf?`
11:19:35 <rmorrison> Is there a way to make GHC less verbose? For instance this, while sometimes useful, takes too much space. https://paste.debian.net/1121433/
11:19:45 <rihardsk[m]> i got the idea from this SO thread https://stackoverflow.com/questions/2354707/in-haskell-is-there-infinity-num-a-a
11:22:11 <rmorrison> rihardsk[m]  `Num a` has  a `signum` function, so you can use it to check whether a number is positive or negative
11:22:58 <rmorrison> Oh, sorry, you asked the other thing
11:23:11 <cdunklau> amalloy: i mean, i can imagine it does (xAdAd, yAdAd, instrPtr') = (x + 1, x + 2, x + 3), but i don't know why. i'd appreciate a link if you don't want to explain it
11:23:27 <rmorrison> No, you asked exactly that
11:24:19 <evelyn> it's just syntactic sugar  - it means you don't have to write the first element or whatever list is yet to come after intstrPtr'
11:25:08 <rihardsk[m]> rmorrison: `signum :: a -> a` gives me another number. but it doesn't exactly tell me if it's positive or negative. that's the underlying issue here  
11:25:09 <evelyn> because they're not the elements used in the function to come, so no need to write the whole thing out
11:25:49 <rihardsk[m]> rmorrison: or am i missing something here?
11:27:43 <cdunklau> evelyn: oh, right, because [x..] starts with x.
11:27:45 <cdunklau> thanks!
11:28:03 <rmorrison> rihardsk[m], no, you are right. As an ad-hoc solution. You can also make it also an instance of `Integral` and then write something like `toInteger . signum`. 
11:28:09 <cdunklau> and thanks to the rest of you :)
11:29:34 <amx> can I derive a class but still override one method?
11:30:08 <evelyn> actually syntactic sugar it may well not be. That has a particular meaning.
11:30:12 <amalloy> cdunklau: iterate succ x produce an infinite list, which we pattern-match on. the first item is x, so we ignore that with _
11:30:24 <amalloy> we want the next three items, so we name them; and items after that should be ignored
11:30:26 <cdunklau> yep, i didn't recognize it as pattern matching at first
11:30:31 <cdunklau> ty
11:30:33 <rmorrison> @amx no. What exactly are you trying to achieve? 
11:30:33 <lambdabot> Maybe you meant: thx ask arr
11:31:23 <amx> rmorrison: I have a newtype on (Fixed E3) and want to derive pretty much everything except fromInteger, because I don't like the one in Fixed. It's not a big deal, just a bit of boilerplate I have to keep.
11:32:22 <rihardsk[m]> rmorrison: oh, thanks, hadn't thought of adding another constraint. `Integral` won't do for me because i need this for `Data.Decimal` but i'll think of something else
11:32:40 <rihardsk[m]> not pretty but there's no other way i guess
11:34:46 <rmorrison> amx, does this help? https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-GeneralizedNewtypeDeriving
11:40:33 <amx> rmorrison: I don't think so, because I still have to derive Num or don't. Unless I'm missing something I can't derive Num and then override fromInteger, but it's ok.
11:49:25 <seishun> is there a pattern to simplify this kind of code? https://gist.github.com/seishun/426c76918b6532dc900e4b575b36de8c
11:55:59 <solonarv> rihardsk[m]: the simplest solution IMO is to add an (Ord a) constraint to the instance
11:57:27 <solonarv> rihardsk[m]: the simplest solution IMO is to add an (Ord a) constraint to the instance, so you can write NegInf * Only a = case a `compare` 0 of GT -> NegInf; EQ -> error "∞ * 0"; LT -> PosInf
11:57:42 <solonarv> whoops, double post
12:00:36 <yasar> I wrote this program to print out all the filenames that have a particular extension recursively : https://gist.github.com/yasar11732/1ad19f9f93fa6534252019613e4b00f2
12:01:00 <yasar> it works but, it hangs until it walks all the directories and print results at once
12:01:11 <rihardsk[m]> solonarv: yeah, `Ord` should do the trick, thanks! should have thought about this more - i already started implementing my own `Signed a` typeclass :D
12:01:18 <yasar> can I make it print filenames as it is traversing_
12:07:17 <lyxia> seishun: I replied in your link.
12:08:43 <seishun> oh cool thanks
12:11:01 <lyxia> yasar: instead of returning a list of paths in getRecursiveContents, maybe you want to add an argument (FilePath -> IO ()) that you call on each file you find.
12:12:13 <yasar> lyxia I was assuming that Haskell would produce and consume the list of paths simultaneously
12:15:08 <lyxia> If IO were that lazy it would be really hard to work with.
12:17:48 <rmorrison>  Because of the laziness errors get intertwined. Should I somehow force full evaluation? https://paste.debian.net/1121443/
12:19:17 <dsal> :t evaluate
12:19:20 <lambdabot> a -> IO a
12:19:31 <lyxia> rmorrison: use pattern-matching instead of let with either/fromMaybe
12:19:34 <dsal> There's always evaluate.  I'm not sure that's the solution to your problem, though.
12:27:19 <rmorrison> lyxia, didn't help. I'll try to change the implementation then https://paste.debian.net/1121445/
12:28:29 <rmorrison> Oh, maybe it's because the next function uses `catch`? 
12:29:59 <dsal> You probably don't want error.  I don't think that's the key to your confusion, but I'm missing some context.
12:33:54 <rmorrison>  dsal, here is the whole module then. https://github.com/RowanMorrison/torrent/blob/master/src/Torrent.hs#L76
12:36:56 <dsal> Hmm...  What do you want to happen?  error is kind of bad and catching all exceptions is kind of bad.  But I don't understand what behavior you want.
12:37:10 <lyxia> rmorrison: http://paste.debian.net/1121446/
12:38:02 <lyxia> My guess is rmorrison doesn't want the parse error to appear inside the "can't create directories" error.
12:38:33 <rmorrison> dsal, if I can't parse the file, then I should simply die with an appropriate error message
12:38:40 <dsal> Doesn't it?
12:39:18 <rmorrison> lyxia, thank you, but should I really write code like this with nested `case`s?
12:39:21 <dsal> I mean, the error message is 'empty'  which could be improved, but that's a different problem.
12:40:14 <rmorrison> This is the error message "Can't create directories: Can't parse Failed reading: empty"
12:40:22 <dsal> What would you want it to say?
12:40:34 <rmorrison> "Can't parse Failed reading: empty" for now
12:41:03 <dsal> Oh, yeah.  You shouldn't catch SomeException
12:42:43 <monochrom> This sounds like a deep stack of XYZBBQ problems.
12:42:46 <dsal> But forcing the evaluation before that would also help, which the case statements should do.
12:42:58 <lyxia> rmorrison: http://paste.debian.net/1121447/
12:43:29 <monochrom> So unright, such unjust.
12:43:36 <monochrom> and impure and unclean :)
12:43:43 <lyxia> :)
12:43:58 <dsal> unRight doubleplus
12:45:01 <dsal> You could also just use BangPatterns
12:45:08 <monochrom> If you want exceptions, at least define your own exception type and throw it knowingly and catch it targettedly.
12:45:17 <dsal> let !bValue = ...
12:45:49 <dsal> > let !x = undefined in "this is fine"
12:45:51 <lambdabot>  "*Exception: Prelude.undefined
12:45:56 <dsal> > let x = undefined in "this is fine"
12:45:58 <lambdabot>  "this is fine"
12:46:54 <monochrom> OK, here is why I said this looks like a deep stack of XYZBBQ problems.
12:48:04 <monochrom> First XY problem: I want my parser to report failure, I think I can do that by the "error" function.  (Correct solution: parser uses Maybe or Either.)
12:49:17 <monochrom> Second XY problem: I want to receive that failure report, I think I can do that by catching exceptions, since the "error" function works by throwing an exception.  (Correct solution: receive a Maybe value or an Either value, use pattern matching on it.)
12:49:44 <rmorrison> monochrom, but my parser does return either. But that's a top-level function: I should either kill the program (because I can't do anything anymore) or loop it and ask for other file
12:50:08 <dsal> libraries shouldn't kill programs.
12:50:10 <monochrom> Third XY problem: I think lazy evaluation is delaying the failure report, I think I can fix it by forcing evaluation.  (Correct solution: If you use the correct solutions above, lazy evaluation will not get into your way.)
12:50:10 <dmwit> Mmm. The parsers are already returning Maybes and Errors. IMO the XY problem is "I want to convert my Either to a value, I will use error.". (Correct solution: use `die` or `throwIO`.)
12:50:27 <rmorrison> dsal, it's not a library
12:50:44 <dsal> module Torrent where -- that's not Main
12:51:02 <monochrom> Fourth XY problem: I want to catch one specific exception type, I think I can do that by first catching all exception types.  (Correct solution: Go back to square 1.)
12:51:03 <dmwit> In other words, instead of `let foo = either (error "bar") id baz`, use `foo <- either (die "bar") pure baz`.
12:51:32 <dmwit> Similarly, instead of `let foo = fromMaybe (error "bar") baz`, use `foo <- fromMaybe (die "bar") baz`.
12:51:45 <EvanR> fifth XY problem, want to kill program on parse failure
12:51:50 <rmorrison> My `Main` looks like this: `main = start`
12:51:54 <amx> rmorrison: are you writing a torrent client for school? for fun?
12:51:56 <EvanR> or is this Z
12:52:18 <rmorrison> amx, for fun
12:52:23 <dmwit> Don't put `error` in your `catch` clause, either.
12:52:30 <dmwit> Just don't put `error`. =P
12:52:49 <amx> awesome, carry on :)
12:52:57 <rmorrison> thank you :3
12:53:44 <monochrom> Well I still hit the other 3 XY problems.
12:53:50 <EvanR> :t Control.Exception.die
12:53:51 <lambdabot> error:
12:53:51 <lambdabot>     Not in scope: ‘Control.Exception.die’
12:53:51 <lambdabot>     Perhaps you meant one of these:
12:53:59 <EvanR> what is die
12:54:17 <rmorrison> Also I'm not sure which exceptions I should catch when I call this function https://hackage.haskell.org/package/directory-1.3.4.0/docs/System-Directory.html#v:createDirectoryIfMissing
12:54:35 <monochrom> IOException
12:54:50 <rmorrison> Oh, that's true, thank you
12:55:02 <dsal> Yeah, haskell's a little bad at letting you know what exceptions might be thrown and when.
12:55:13 <Athas> A *little* bad?
12:55:21 <EvanR> should you really catch exceptions from createDirectoryIfMissing?
12:55:48 <solonarv> depends on what your program is doing
12:55:56 <Athas> EvanR: how else will you handle failure?
12:55:58 <yasar> lyxia I have changed my implementation as you suggested, it works fine now. But I now I am confused how IO is processed
12:56:00 <rmorrison> It's not specified anywhere that it doesn't throw anything. Or am I blind?
12:56:20 <solonarv> if, say, you are creating a directory to cache some intermediate results, then perhaps in case of failure you can just carry on without caching
12:56:37 <yasar> to be exact, why wasn't my original approach executed lazily?
12:56:41 <monochrom> Yes it's poorly documented.
12:56:44 <dsal> If the failure handling is "program exits with error on condition that can't be handled" then not doing anything is probably a shorter path  to the same result.
12:57:13 <solonarv> yes, you would usually do this with some sort of top-level exception handler
12:58:16 * dsal needs SomeExceptionThatIsn'tSIGINTOrLikeMaybeSIGTERM
12:58:31 <dmwit> :t System.Exit.die -- EvanR
12:58:34 <lambdabot> String -> IO a
12:58:42 <EvanR> ok so IO version of error
12:59:50 <EvanR> i'll write that one down in my giant list of words to give out to teach all of haskell instantly, and also claim it should be in prelude
13:02:11 <monochrom> I have a feeling that someone seeing that list will ask "is this for an ESL class?" :)
13:02:37 <EvanR> btw i just noticed createDirectory and so createDirectoryIfMissing source code has a bunch of "how this can fail" comments in the source
13:03:03 <EvanR> ah it's haddocks
13:04:44 <EvanR> and i'm dumb, clearly you can provide a bogus path to where you want the dir, and it should fail and you might want to save
13:05:14 <EvanR> isDoesNotExistError
13:09:50 <aplainzetakind> <possible AoC day 15 spoilers> I can't figure out why test1 outputs the trace messages but test1' does not. So test1' seems to never even call popOutput'. The difference is that in the plain versions of the functions I use a safeHead to grab a list item, and halt the loop if it's Nothing, in the ' versions, I runtime error on empty lists.
13:09:56 <aplainzetakind> https://gitlab.com/aplainzetakind/aoc2019/blob/master/days/Advent19/Day15.hs
13:10:28 <aplainzetakind> Why popOutput' is not being called is a mystery to me.
13:12:51 <wildtrees> dependent maps with lens support, what should I use, is there examples online? trying Data.Dependent.Map and can't figure out the boilerplate to make my Key a class work 
13:13:26 <[exa]> aplainzetakind: traceM doesn't help?
13:15:07 <aplainzetakind> [exa]: Isn't traceM s the same thing as trace s (pure ()) anyway?
13:15:33 <solonarv> I think so
13:15:34 <[exa]> hopefully
13:15:47 <aplainzetakind> So, no change in behaviour there.
13:27:51 <[exa]> aplainzetakind: is there anything that would explicitly force the rest of the state monad to get evaluated?
13:28:51 <[exa]> aplainzetakind: like, you return () and are only interested in the '1' from putInput. Except I'm totally missing something
13:29:56 <aplainzetakind> I'm interested in the inputBuilder field of the state.
13:30:05 <[exa]> oh the putInput is hidden inside, missed that one
13:30:35 <aplainzetakind> I don't think anything else would be forced in this toy case.
13:31:18 <aplainzetakind> (btw inputBuilder is also incorrectly designed, but I conuldn't even get to tackling that)
13:31:48 <[exa]> and the loop terminates only by getting into error?
13:32:09 <Hopppz> Can I ask a n00b question?
13:32:21 <dsal> Just did
13:32:23 <[exa]> Hopppz: very yes
13:32:28 <solonarv> @where justask
13:32:28 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
13:32:39 <aplainzetakind> In the plain version, when it receives a Nothing, in the ' case, popOutput is supposed to break when the outs list is exhausted.
13:32:55 <[exa]> aplainzetakind: yeah the two are basically same except for the 'error'
13:33:01 <aplainzetakind> By break I mean runtime error.
13:33:03 <aplainzetakind> Yes.
13:33:07 <aplainzetakind> So I'm baffled.
13:33:40 <amalloy> aplainzetakind: is `use` from lens, or what? there are kinda a mountain of unqualified imports
13:33:50 <[exa]> aplainzetakind: and you expect the traces getting printed before the error message?
13:34:13 <aplainzetakind> Yes use is lens. It's get composed with the field accessor.
13:34:47 <aplainzetakind> Yes, in the plin version I get the traces before the resulting list being printed.
13:34:53 <aplainzetakind> s/plin/plain
13:35:06 <aplainzetakind> The ' version hangs completely.
13:35:15 <Hopppz> I was struggling with cis 194 part 1 I knew I needed to div and mod but couldn't recurse it correclty so I looked at a solution but I'm not sure why it works
13:35:18 <Hopppz> https://pastebin.com/YeXh2JQh 
13:35:34 <aplainzetakind> Fills up the memory even.
13:36:01 <[exa]> aplainzetakind: well
13:36:07 <dsal> Hopppz: can you work it out manually?
13:36:16 <dsal> i.e., what does that function do if it gets 37 as input?
13:36:19 <Hopppz> does n not get divided by 10 before the mod of it gets appended to the list 
13:36:30 <Hopppz> I see it gets the right output but I'm not sure why
13:36:51 <dsal> n isn't changed by div
13:38:05 <Hopppz> ah so the mod gets append to the list and then toDigits is called again with 123 as the div is applied
13:38:29 <dsal> That function is written in kind of a strange way.
13:38:47 <Hopppz> what would be the best way to structure it ?
13:39:06 <Hopppz> or how would you structure yours?
13:39:26 <[exa]> aplainzetakind: can you try passing 'loop' inside putOutput' to serve as a continuation?
13:40:21 <aplainzetakind> [exa]: "to serve as a continuation" is a technique I am so not familiar with that I don't understand what you mean.
13:40:28 <dsal> Hopppz: I just would make two heads instead of a guard.
13:40:31 <dsal> > let toDigits 0 = []; toDigits n = toDigits (n `div` 10) <> [n `mod` 10] in   toDigits 42
13:40:34 <lambdabot>  [4,2]
13:40:40 <dsal> Only slightly strange.  heh
13:40:43 <[exa]> aplainzetakind: where loop = popOutput' >>= putInput loop
13:40:51 <[exa]> aplainzetakind: and call loop (optionally) from putInput
13:41:10 <dmwit> Hopppz: Doesn't look strange to me. Inefficient, without a standardish trick, but a pretty straightforward naive implementation.
13:41:21 <dmwit> Hopppz: The answer to your question is: everything is immutable (never changes), including n.
13:41:53 <[exa]> aplainzetakind: my best guess is that the bottom somehow messes up evaluation order, but it would certainly not explain why you're getting infinite loop
13:41:55 <dmwit> Hopppz: So, no, the (n `div` 10) call does not change n before the mod gets appended.
13:42:30 <aplainzetakind> [exa]: So is putInput to receive another argument?
13:42:45 <dsal> It depends on your needs.   The version I gave isn't defined for negative numbers, vs. that one just returning [].
13:43:05 <Hopppz> thanks for the help guys
13:43:33 <[exa]> aplainzetakind: oh that would require to go to popOutput', which isn't going to help much here anyway
13:46:32 <aplainzetakind> [exa]: I put a trace statement in putInput.
13:46:39 <aplainzetakind> Even that is not being called it seems.
13:47:40 <aplainzetakind> How come.
13:49:27 <[exa]> aplainzetakind: and there's no output even from the error?
13:49:37 <amalloy> i suspect that popOutput' is somehow "too lazy", in that it can produce one step's worth of state without having to look at the previous state
13:50:31 <aplainzetakind> [exa]: No.
13:50:35 <[exa]> amalloy: it needs to patternmatch the result of unsafeHead to loop, which should force it into consuming the list
13:50:43 <[exa]> *safeHead
13:53:46 <[exa]> aplainzetakind: well
13:54:11 <[exa]> aplainzetakind: is there any reason for State to terminate when presented with let loop = whatever >> loop ?
13:54:29 <aplainzetakind> Well, I prepended the the stuff in alwaysNorth with `traceM "alwaysNorth" >>`, and even that didn't get output.
13:54:32 <aplainzetakind> Nothing is being called it seems.
13:54:41 <aplainzetakind> What sort of reason would that be.
13:54:44 <[exa]> since state is just constructing a function I guess the "whatever" can be very easily optimized out
13:54:45 <aplainzetakind> ?
13:56:09 <[exa]> aplainzetakind: in particular, when you finally execState, it will need to find the state transforming function, which is most defined by the last loop in the cycle
13:56:22 <aplainzetakind> But "whatever" is changing the state.
13:56:22 <amalloy> [exa]: i don't see that pattern-match. it calls safeHead on the output, but doesn't use that to decide what new state to use
13:56:28 <[exa]> aplainzetakind: there's no state
13:56:56 <aplainzetakind> ?
13:57:49 <[exa]> aplainzetakind: just to be sure, can you try popOutput' >>= (\a -> putInput a >> loop) ?
13:57:59 <[exa]> (>>= and >> are infixl)
13:58:22 <aplainzetakind> This is a new definition for loop right?
13:58:42 <[exa]> aplainzetakind: yes
13:58:51 <aplainzetakind> Still hangs.
13:58:52 <[exa]> but it won't help much IMHO
13:59:07 <[exa]> yes ofc, it's still looking for the last loop
13:59:19 <[exa]> aplainzetakind: did you see how State looks from inside?
13:59:34 <aplainzetakind> You mean its implementation?
13:59:37 <[exa]> yes
13:59:48 <aplainzetakind> Once upon a time I think?
14:00:07 <aplainzetakind> Isn't it a newtype around f :: s -> (a, s)
14:00:17 <solonarv> it is indeed
14:00:36 <[exa]> yes; in your case you don't need 'a', so you just paste together functions (s -> s)
14:00:54 <aplainzetakind> So you're saying it would go backwords from the end, but there's no end to be found?
14:01:03 <aplainzetakind> s/backwords/backwards
14:01:16 <[exa]> exactly, trying to find how to (lazily) produce the final result first
14:01:56 <aplainzetakind> Hmm.
14:02:37 <[exa]> in short, it doesn't know that it needs the value from 'error', so it doesn't trigger it
14:02:41 <aplainzetakind> Wouldn't that make sequencing infinite lists [State s a] impossible in general?
14:04:19 <solonarv> correct
14:04:36 <aplainzetakind> Is that the case?
14:04:38 <solonarv> this is why streaming libraries (conduit, streaming, pipes, etc) exist!
14:07:16 <[exa]> aplainzetakind: anyway, except for generating a finite state transform, you can help yourself a bit with various short-circuiting transformers (like MaybeT) that can kill the computation in the middle as you need
14:07:59 <aplainzetakind> > take 3 $ execState (sequence ((\n -> get >>= (\s if s == 10 then error "foo" else (s . (n :)))) <$> [1..])) []
14:08:02 <lambdabot>  <hint>:1:50: error:
14:08:02 <lambdabot>      Parse error in pattern: if s == 10 then
14:08:02 <lambdabot>                                  error "foo"
14:08:36 <[exa]> missing -> ?
14:08:41 <aplainzetakind> > take 3 $ execState (sequence ((\n -> get >>= (\s -> if s == 10 then error "foo" else (s . (n :)))) <$> [1..])) []
14:08:43 <lambdabot>  error:
14:08:43 <lambdabot>      • Couldn't match type ‘[a]’ with ‘[Integer] -> c0’
14:08:43 <lambdabot>          arising from a functional dependency between:
14:09:15 <aplainzetakind> Anyway shouldn't write such things into the channel off the top of my head. Let me go to ghci.
14:11:08 <[exa]> aplainzetakind: how do you know that the last item in the sequenced list won't reset the state completely?
14:12:04 <wildtrees> aplainzetakind, I use /msg lambdabot > 2+2  -- to get a private message window with lambdabot and I work out complicated lambdabot expressions there! 
14:12:36 <aplainzetakind> wildtrees: Nice, thanks.
14:12:38 <solonarv> instead of sending a dummy message you can also do /query lambdabot 
14:12:45 <wildtrees> ")
14:12:47 <wildtrees> :)
14:13:10 <solonarv> I also occasionally use this to fiddle with imports and flags for yahb
14:13:22 <aplainzetakind> [exa]: That's something I would get to.
14:13:39 <aplainzetakind> So this approach is generally wrong?
14:14:10 <[exa]> aplainzetakind: not generally, but you need a more 'visible' way to terminate the State
14:14:22 <wildtrees> solonarv, didn't know that works as well, thanks!
14:14:26 <aplainzetakind> Are you doing AoC?
14:14:35 <aplainzetakind> [exa]: ^
14:14:46 <[exa]> I ended at ~12 b/c lots of pre-christmas deadlines
14:15:07 <aplainzetakind> OK, I'm basically trying to interface with my lazy intcode computer.
14:15:45 <aplainzetakind> So I have to do things to its output and feed back to its input lazily, without seeing/producing the end of either list.
14:15:53 * [exa] silently hopes there's going to be diagonalization of the intcode machines at the end
14:16:25 <aplainzetakind> It sounds like this approach is just not going to work unless I turn it into something like StateT s Conduit or something.
14:17:18 <[exa]> aplainzetakind: what about just `let allInputs = 1:intCodeOutputOn allInputs` ?
14:17:41 <[exa]> (it worked for me)
14:19:19 <aplainzetakind> It worked for me too on previous days, but here I think I need to keep track of more things, that's why I reached for State.
14:21:26 <aplainzetakind> If I put the input not into the state, but to the side effect value (how should I call a in State s a), and sequence them, then it would work lazily I presume?
14:22:49 <[exa]> oh get it now
14:23:53 <glguy> If you're not doing Advent of Code, it's not too late to get in on the fun. If you are doing it in Haskell, jump onto my #haskell themed leaderboard: 43100-84040706
14:24:40 <glguy> aplainzetakind: What AoC day are you working on?
14:25:40 <aplainzetakind> 15
14:26:01 <[exa]> aplainzetakind: btw why not use Writer? (or some combo with State)
14:26:37 <[exa]> aplainzetakind: output of list Writer can be consumed lazily, even for infinite Writers AFAIK
14:27:04 <aplainzetakind> Probably only because I never used Writer. I also remember reading somewhere to never use it ever, I son't remember the reasoning.
14:27:16 <aplainzetakind> Let me look into it then if you say it's suitable.
14:27:18 <loli> base MTL writer tends to waste resources
14:27:30 <loli> if you want a non memory wasting version look at the capability library
14:27:41 <loli> https://hackage.haskell.org/package/capability
14:28:04 <[exa]> >  take 10 $ execWriter (sequence [tell [n] | n <- [1..]])
14:28:06 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
14:28:07 <[exa]> aplainzetakind: ^
14:28:50 <glguy> loli: it only wastes resources if you use it in a context that you shouldn't, it's not blanket "wrong"
14:29:03 <aplainzetakind> Hmm. Would this also work for the intcode computer?
14:29:10 <loli> hence tends, glguy 
14:29:29 <glguy> without being more specific about when that is it's not so useful to mention
14:29:45 <loli> well that is probably what aplainzetakind read, as to why he should "never" use it
14:30:21 <glguy> I found the intcode interpreter was easier to get right not trying to use monad transformers
14:30:29 <[exa]> aplainzetakind: yes (you won't have to make the list builder yourself). Also, there's RWST which nicely wraps Writer+State (for your map) (+Reader, which you probably won't need)
14:31:04 <loli> for those situations where you still want a writer interface, capability is a really nice library. At least I find it so
14:32:10 <glguy> If you decide to go with a monad-interface to your interpreter then I'd recommend using something like conduit, pipes, conduino, etc
14:32:41 <aplainzetakind> glguy: I ended up using IOArrays with Conduit then lazyConsume'ing the conduit the unsafePerformIO so it was obviously bad, but I couldn't get around to finding out how to do it properly while tring to keep up.
14:32:43 <[exa]> glguy: if I got it correctly it's not for the interpreter but for the thing that uses the robot to search through a map
14:33:12 <aplainzetakind> [exa]: Correct.
14:33:36 <glguy> If you're doing things in conduit, then I'd stay inside conduit and do the search there
14:33:51 <glguy> rather tha trying to do any kind of lazy consume or unsafe perform IO
14:34:08 <aplainzetakind> I used conduit in the interpreter.
14:34:19 <glguy> OK, then you can also do the search from conduit, too
14:34:30 <aplainzetakind> I'm trying to hook the robot to the computer with State only, but that didn't really work.
14:34:58 <aplainzetakind> Hmm.
14:35:21 <glguy> If you want to look, I wrote an example that maps out the maze inside conduino on top of ListT: https://gist.github.com/glguy/56e4ec4e88d70c5ca79465f54f3f8533
14:35:22 <aplainzetakind> So would Conduit invade all the code where the interpreter is used?
14:36:10 <glguy> run running the Pipe on (ListT (State (Set Coord))) you can build up a permanent (doesn't backtrack) map of the maze with doing a backtracking search of the interpreter execution
14:36:48 <glguy> That doesn't solve the question directly, but should give you a hint about how you could do the search
14:37:04 <glguy> another way would be to not backtrack with ListT and to write your robot to just retrace its steps
14:40:11 <aplainzetakind> I couldn't get to thinking about the actual exploration. I was thinking something like keep going to the nearest unvisited points (which neighbour visited ones), and when O2 is found, do something like A* back to the origin through whatever fog may be intervening.
14:41:36 <aplainzetakind> But first I got hung up on creating a convenient interface with the computer where I can exress whatever algorithm cleanly. And failed at that stage.
14:41:50 <[exa]> aplainzetakind: A* is overkill, just "steepest descent back home" will work I guess
14:44:00 <aplainzetakind> Last year I got to day 24 not even knowing how to use transformers, and quit only because the question was just annoyingly tedious but not hard. This year I'm choking.
14:44:22 <glguy> A* doesn't apply to day 15
14:45:29 <aplainzetakind> glguy: That would be because you don't even know the territory right?
14:45:35 <glguy> So far I haven't needed any monad transformers to solve an AoC'19 puzzle, I've only used them for playing around with fun alternative solutions
14:45:59 <glguy> aplainzetakind: Yeah, you can't compute a useful heuristic function to an unknown destination
14:46:59 <aplainzetakind> glguy: Yes, I think I'm dragging myself into situations I'm not entirely fluent in because I know more Haskell but am not good at with those new things I know.
14:47:11 <aplainzetakind> s/with//
14:47:28 <dsal> aplainzetakind: heh, I've not used any transformers in AoC.  I did use State on day 15, I think.
14:48:21 <dsal> I did use A* on day 15, though.  Only because my own graph stuff didn't have a monadic interface and the astar library did.  I should go back and fix that.
14:49:00 <aplainzetakind> I reach for Reader whenever more than two functions refer to a static input.
14:49:25 <glguy> aplainzetakind: If your interested in alternatives to structuring the interpreter and you want to look over https://github.com/glguy/advent2019/blob/master/common/Advent/Intcode.hs and chat about it later I'll be around. If you think it would spoil your implementation you can hold off of course :)
14:49:46 <dsal> intcode seems like a neat way to learn polysemy
14:50:35 <aplainzetakind> glguy: I have been meaning to look at your code, but I'm all caught up in catching up.
14:50:56 <dsal> Every time I try to look at glguy's code, I can't find it.
14:51:18 <aplainzetakind> Click through the leaderboard?
14:52:35 <dsal> No, I mean like... here's day 15:  https://github.com/glguy/advent2019/blob/master/execs/Day15.hs
14:52:47 <dsal> There's no code there...
14:53:05 <MarcelineVQ> your browser playing tricks on you
14:53:23 <dsal> It's like a data structure and done.
14:58:09 <infinity0> has anyone seen mokus0 (maintainer of dependent-sum and dependent-map) lately
14:58:17 <infinity0> there is several outstanding issues on github for a few years now
15:05:55 <dsal> Man.  I hope someone considers some of my issues outstanding.
15:06:43 <amalloy> i am kinda surprised to see that Prelude.^ has its own implementation of exponentiation by repeated squaring. is there a reason it can't use Product and mtimes? i expect the newtype juggling to be free, and indeed a simple criterion run suggests it would perform the same
15:10:19 <Axman6> probably because (^) has been around for a lot longer than Product
15:12:19 <amalloy> could it be retrofitted in, or is there a bootstrapping issue? it seems like it would be a nice cleanup to not have this algorithm in base twice
15:12:32 <shachaf> It's a few lines of code, who cares?
15:12:44 <shachaf> There's a note about inlining, maybe it's that.
15:12:44 <glguy> shachaf: amalloy does!
15:13:05 <shachaf> There are a bunch of rewrite rules and things too.
15:13:57 <shachaf> Man, newtype noise is uglier than writing the same function twice.
15:14:34 <shachaf> Here's my alternative proposal: newtype Foo a = Foo { unFoo :: a }; instance Monoid a => Num (Foo a) where { Foo x * Foo y = Foo (x <> y); fromInteger 1 = Foo mempty }; timesN n = unFoo . (^ n) . Foo
15:16:50 <shachaf> (^) also has a bunch of rewrite rules. The definition is a small part of the implementation.
15:17:02 <shachaf> It has a special version for Rational and so on.
15:17:18 <glguy> so if we got rid of it then we'd have a lot fewer lines because we could get rid of the rewrite rules and special rational version, too?
15:17:49 <glguy> I like where you're head's at
15:20:02 <amalloy> where is the special one for rational?
15:20:38 <amalloy> ah, it is called (^^)
15:21:33 <dsal> That one's cute.
15:22:27 <dsal> Too bad you can't write    8 `(^^)` 8
15:24:10 <shachaf> No, it's called (^%^).
15:25:19 <amalloy> i see
15:27:23 <amalloy> this seems like a useful special case which would want to be around regardless of how (^) were implemented, and wouldn't actually care if (^) changed
15:31:14 <oats> Is there a way to tell brittany to skip over formatting an expression?
15:43:21 <flatmap> can somebody help what the „~“ means in this expression?        unzip    =  foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
15:43:33 <flatmap> ~( … )
15:44:04 <[itchyjunk]> I hear music comming out of the printer. i think the papers jamin again
15:45:38 <EvanR> flatmap: it means lazy pattern match
15:45:50 <pounce> hmm, speaking of `` syntax.. why can't you do 1 `(,)` 2
15:46:10 <flatmap> thanks EvanR 
15:46:10 <EvanR> usually a pattern match causes evaluation to the extent necessary to check the match. But lazy patterns are defered until even later
15:46:58 <dmwit> pounce: Answer level 1 is "because only prefix identifiers may go inside backticks, and (,) is a section of an infix identifier, not a prefix identifier".
15:47:36 <pounce> it is infix? but 1 (,) 2 doesn't work only (,) 1 2 
15:47:36 <dmwit> pounce: Answer level 2 is "because backticks don't differentiate between starting and ending, so to avoid parsing ambiguities, only simple things may go inside".
15:48:20 <pounce> is this one of those haskell is context free™ shenanigans
15:48:21 <dmwit> pounce: Answer level 3 is "yes, it might occasionally be nice to have a variant of backticks which did differentiate between starting and ending, so that arbitrary expressions could go inside, and nothing technical is stopping this from happening".
15:48:42 <dmwit> pounce: , is infix, (,) is a section of the infix operator ,
15:48:58 <dmwit> pounce: (Up to some quibbles about , specifically needing extra parentheses to be used infix.)
15:49:05 <pounce> oh, hm
15:49:12 <dmwit> pounce: (But without those quibbles, the same answer applies to, e.g., `(+)`.)
15:49:18 <pounce> sure..
15:54:52 <pounce> what about the opposite: (`div`)
15:57:00 <EvanR> > (`div` 2) 102
15:57:02 <lambdabot>  51
16:09:51 <oats> https://paste.xinu.at/QbQzs5/ Advent of Code day 5 solution. This intcode machine stuff is super fun. Got to use Monad, Applicative, State, Lenses...
16:25:01 <iqubic> All of that is great.
16:35:54 <rmorrison> Hello. Does anybody know whether `HTTP.Req` has something similar to `queryParam` but when passed `Nothing` does not include an option at all. http://hackage.haskell.org/package/req-3.0.0/docs/Network-HTTP-Req.html#v:-61-:
16:36:40 <rmorrison> Now it creates a `Flag` without a value, which is not I want 
16:37:49 <rmorrison> I can put everything into a list, and use something like `catMaybes` but maybe there is a better way
16:41:07 <jchia> rmorrison, can you just use mempty for the option if you don't want any option?
16:41:45 <jchia> I.e. call req, but use mempty for the 'Option scheme' argument
16:42:27 <rmorrison> yes, that should work, thank you
17:00:15 <rmorrison> `(=?:) text = maybe mempty (text =:)`
17:03:03 <mynameisbrian> whoa! there's more people in here than ruby, I didn't think haskell was that popular 
17:05:02 <rmorrison> mynameisbrian, https://youtu.be/re96UgMk6GQ?t=940
17:06:20 <jle`> mynameisbrian: ruby people may be busy congregating at cooler watering holes than ancient ol' irc :)
17:06:39 <jle`> mynameisbrian: freenode irc somehow turned out to be one of the major community hubs in haskell
17:07:50 <jusss> jle`: also for other things like #archlinux :)
17:08:02 <mynameisbrian> ahh interesting. and yeah that's what I thought, a lot of younger people/beginners learn ruby for Rails and they don't hang out in places like IRC
17:08:09 <jusss> and #emacs
17:08:20 <mynameisbrian> im installing haskell now and seeing if I like it
17:08:39 <jle`> mynameisbrian: welcome, hope you have a great time :)
17:08:44 <jusss> I think younger people may perfer python
17:09:31 <jle`> yeah i asked my cousin (19yr/old CS major at university) if he knew what irc was and he said no
17:09:55 <jusss> jle`: I wonder did you ask him about newsgroup?
17:10:05 <jle`> heh, i didn't bother
17:10:37 <jusss> usenet is that really old stuff, 
17:10:38 <Axman6> NEwgroups are where all the cool kids do their piracy
17:10:56 <jle`> but for me (~30yr/old), i hung out on IRC socially before i ever used it for anyhting technical
17:11:04 <jle`> i remember joining RP communities about Pokemon and stuff
17:11:20 <jle`> it's probably what filled the role that tumblr filled around 2010-ish
17:11:49 <jle`> why did i use a slash for yr/old
17:11:52 <Axman6> I think I always used it for technical stuff, I've been an op in #macosx for well over a decade (though never really chat there any more)
17:12:01 <jle`> but yeah i reckon i was probably around 10 at the time, so this would have been late 90's
17:12:02 <jusss> jle`: I use IRC since 2010, I joined a channel for #ubuntu
17:12:05 <Axman6> years per old
17:12:54 <mynameisbrian> I discovered IRC on a forum. They had a web interface and I learned I could connect with a better program (mIRC at the time), and it went from there. 
17:13:03 <jle`> ah, same :)
17:13:46 <jusss> there's a IRC call efnet? I started on there
17:14:03 <jusss> they provide a website interface
17:14:55 <Axman6> I used irssi for a very long time
17:15:15 <jusss> and then freenode, there even is a java program running in symbian s40, I used it to connect the world
17:15:54 <jusss> yeah, irssi, me too, and then ERC
17:17:45 <glguy> Then glirc *nod*
17:18:48 <MarcelineVQ> the last great irc client humanity would invent
17:18:48 <jusss> the tab indentation in haskell-mode doesn't work well...
17:19:07 <Axman6> Yes, then glirc
17:19:20 <Axman6> <3 glguy
17:19:25 <jusss> MarcelineVQ: you world sounds like the way of Apple...
17:19:29 <jusss> words
17:19:57 <jusss> the best phone we ever made
17:26:56 <fragamus> Hi how to these memoization functions store anything? It seems like they must do something naughty
17:27:34 <EvanR> there's good naughty and bad naughty
17:27:58 <fragamus> Don’t I know it
17:28:33 <glguy> Laziness is mutation!
17:30:54 <wildtrees> glguy, explain? ;) 
17:36:00 <shachaf> Does the winky face mean you're joking or something?
17:36:21 <shachaf> Anyway, if you think mutation is naughty, just wait until you hear what kind of code GHC generates.
17:36:25 <wildtrees> didn't want to come off as too demanding with "explain" 
17:37:06 <wildtrees> is there a lens for getting values out of the Identity Functor? 
17:37:23 <EvanR> more to the point, memo combinators work using just laziness. But laziness is implemented with mutation behind the scenes
17:37:41 <shachaf> _Wrapped probably?
17:38:24 <Axman6> to runIdentity -- or not to runIdentity
17:42:07 <wildtrees> can I compose runidentity into a composition of lens?
17:42:37 <Axman6> yes, with to
17:42:47 <Axman6> :t to runIdentity
17:42:49 <lambdabot> (Profunctor p, Contravariant f) => Optic' p f (Identity a) a
17:43:39 <Axman6> but _Wrapped is also a good option, and allows you to use it as a lens, not just a getter
17:44:37 <wildtrees> to Identity seems to wrap the result in another Identity 
17:46:06 <rmorrison> How to generate a random `Text` of ASCII-characters? 
17:46:08 <Axman6> that's why I said to runIdentity =)
17:46:11 <Axman6> :t to
17:46:12 <lambdabot> (Profunctor p, Contravariant f) => (s -> a) -> Optic' p f s a
17:46:54 <julianleviston> @rmorrison I think the random package has an instance for Text, IIRC
17:46:55 <lambdabot> Unknown command, try @list
17:47:12 <julianleviston> rmorrison: I think the random package has an instance for text, IIRC
17:48:04 <dsal> @package random
17:48:04 <lambdabot> http://hackage.haskell.org/package/random
17:48:17 <rmorrison> julianleviston, but then I would also need to cull `Text`, to get only ASCII characters 
17:48:38 <julianleviston> rmorrison: there’s a function that implements a ranged random. You could use that? :)
17:48:55 <rmorrison> Now I thought to generate `[Word8]` and then pack it.
17:49:09 <rmorrison> Oh yeah, that should be enough, thank you
17:51:08 <dsal> > take 12 $ randomRs ('a', 'z') (mkStdGen 42)
17:51:10 <lambdabot>  "xnpoyvibqxfn"
17:53:01 <jusss> > randomRs ('a','z') (mkStdGen 42)
17:53:03 <lambdabot>  "xnpoyvibqxfnomwxzhnkawaqcimclowlmsijyewjusaaucjmlsumkcxpanuabupqdmctgjzzblg...
17:53:05 <julianleviston> Writing a parser… I’d like to parse PEGs (Parsing Expression Grammars) from a String/Text into a data type (I’ve written one for them) and then subsequently parse and interpret “texts” written in those grammars them… in some bizarre meta-bootstrapping move, I’ve been using Frisby to try to do that - because I’d quite like accumulated error reports, and parse-attempts. I keep ending up with infinite 
17:53:06 <julianleviston> recursion. Is there a way I can get it to tell me in advance when it’s going to infinite loop?
17:54:19 <julianleviston> … or even better, side-step the whole thing :) I gave parsec a bit of a shot, but it just fails or succeeds, without telling me the path of combinators it was in when it failed.
17:55:43 <julianleviston> dsal: thanks for the reminder to “show don’t tell” BTW ;-) I always forget that one.
17:57:45 <dsal> > let rs a = (`S.elemAt` a) <$> randomRs (0, length a - 1) (mkStdGen 104) in take 12 $  rs (S.fromList $ [c | c <- [minBound..], isAscii c]) -- rmorrison 
17:57:48 <lambdabot>  "\tc$?7]T[;(\bx"
17:57:55 <dsal> Kind of neat that Set has numeric indexing.
17:58:31 <julianleviston> I think it has to be indexed, otherwise it’s not efficient.
17:58:53 <dsal> That's not what it's doing.
17:59:44 <julianleviston> What’s not what what’s doing?
18:00:16 <dsal> > S.elemAt 4 . S.fromList $ ['n'..'z']
18:00:18 <lambdabot>  'r'
18:00:51 <julianleviston> I was just saying Set has to have an Ord instance. Nevermind :)
18:01:10 <dsal> Yeah, but this is a Set Char
18:01:27 <EvanR> most of the operations on Set use the Ord instance but not all of them
18:02:05 <dsal> In the random example, it means I can construct a set of all ASCII characters and then extract a random number of them efficiently.
18:02:25 <dsal> (er, random elements from the set... whatever I mean.  I woke up too early)
18:02:47 <julianleviston> sure
18:03:40 <glguy> wildtrees: when thunks are evaluated they are mutated to be the result of evaluation
18:03:41 <rmorrison> dsal, thank you! I also wrote it, but somewhat differently https://paste.debian.net/1121470/
18:04:28 <dsal> rmorrison: note that isAlphaNum isn't ASCII
18:04:51 <dsal> > let rs a = (`S.elemAt` a) <$> randomRs (0, length a - 1) (mkStdGen 104) in take 42 $  rs (S.fromList $ [c | c <- [minBound..], isAlphaNum c]) -- rmorrison 
18:04:54 <rmorrison> Yes, but wouldn't `Word8` insure that
18:04:55 <lambdabot>  "\36262\52976\155199\37456\176887\46962\47749\148582\139290\170485\43275\142...
18:05:11 <dsal> You should use Char if you want chars.  :)  Just get the ones you want.
18:05:21 <dsal> > let rs a = (`S.elemAt` a) <$> randomRs (0, length a - 1) (mkStdGen 104) in take 42 $  rs (S.fromList $ [c | c <- [minBound..], isAlphaNum c, isAscii c]) -- rmorrison 
18:05:24 <lambdabot>  "J5UfBjulfyQY87BCnsyDvrW9dUEhSi93OUOe50hT2U"
18:05:25 <wildtrees> glguy, ok thank you 
18:05:45 <Axman6> I recognise that hash!
18:06:26 <dsal> Axman6: I like repeatability, so I tend to always initialize my random number generators with the same value.
18:07:33 <EvanR> function rand(){ return 4; // guaranteed random } -- also repeatable :)
18:08:47 <dsal> rmorrison: Wait, do you want UUIDs?
18:09:05 <wildtrees> Axman6, the head1 lens seems to work fine
18:09:18 <wildtrees> for dealing with the contents of identity
18:09:28 <dsal> rmorrison: e.g. https://github.com/dustin/net-mqtt-rpc/blob/master/src/Network/MQTT/RPC.hs#L33
18:09:37 <rmorrison> dsal, no, just a random identifier for a torrent-tracker
18:09:45 <julianleviston> bgamari: if I wanted to ask questions about Frisby, would it be ok to bother you with such things?
18:10:09 <dsal> I use the UUID package for generating mqtt topics and correlation IDs in my MQTT RPC package.
18:12:20 <Axman6> wildtrees: there's a very large number of options - traverse would also work, probably each as well
18:12:38 <Axman6> or the best one, coerced
18:12:42 <Axman6> :t coerced
18:12:44 <lambdabot> (Profunctor p, Functor f, Coercible s a, Coercible t b) => p a (f b) -> p s (f t)
18:13:11 <Axman6> which should have zero runtime overhead, which is what we all want
18:13:26 <dsal> Man, the bots don't know uuid.
18:13:37 <Axman6> > Identity True ^. coerced :: Bool
18:13:41 <lambdabot>  True
18:14:02 <iqubic> I love that Iso so much.
18:14:07 <dsal> λ> UUID.toText <$> randomIO  → "86c720e9-eca5-4b96-a6f5-7642c16fa101"    (a Data.Text value)
18:14:14 <dsal> rmorrison: ^   much easier.  :)
18:14:45 <rmorrison> Thank you!
18:15:08 <wildtrees> gotta run thanks for all the help and tips! night
18:15:13 <iqubic> Axman6: The source for coerced is awesome: "coerced = iso coerce coerce"
18:15:41 <iqubic> Or, "let involuted f = iso f f in involuted coerce"
18:16:11 <dsal> involuted is a word I'm going to remember next time I need something involuted.
18:17:27 <iqubic> dsal: In lens terms, involuted builds an iso from a function wher the function is it's own inverse "f . f == id"
18:17:29 <Axman6> I bet you won't
18:17:57 <iqubic> Like the excellent reversed iso.
18:23:47 <rmorrison> After I changed `GHC` version to `8.8.1` (one library required me to) my project started linking for 5-7 minutes.
18:23:54 <rmorrison> Why? 
18:24:32 <dsal> That's a lot of linking.
18:26:00 <Axman6> what were you using before? and do you have any flags enab;ed which affect linking, like split-objects or split-sections?
18:26:02 <rmorrison> "Linking .stack-work\dist\c9315887\build\torrent-test\torrent-test.exe ...Progress 0/2"
18:26:07 <rmorrison> And I wait and wait and wait
18:26:16 <Axman6> windows -_-
18:28:03 <rmorrison> Axman6, that's pretty much all ` stack test --fast --file-watch `
18:34:27 <jusss> is there good linux distros for haskell?
18:37:44 <julianleviston> I’m curious if there’s a way to accumulate a stack of context in a parser as I’m parsing for when I get to an error. Do parsers ever do that?
18:39:44 <rmorrison> Sorry, my PC also takes more than 10 minutes to reboot. I'll read the logs
18:40:00 <Axman6> out of disk space?
18:40:12 <Axman6> julianleviston: Aeson's parser does that
18:40:20 <rmorrison> 4Gb RAM + Win10
18:41:18 <julianleviston> Axman6: oh nice. I’ve never noticed that in my usage of it. Isn’t it only for JSON, tho? 
18:41:32 <julianleviston> I wish all parsers did it.
18:41:50 <dsal> julianleviston: aeson's parser is attoparsec.
18:42:08 <julianleviston> Ah okay.
18:42:31 <dsal> megaparsec generally gives pretty good errors, but I've not tried doing anything fancy enough to need contextual errors.
18:42:32 <julianleviston> I might go check that out! thanks :)
18:42:43 <julianleviston> I’ve tried Frisby and Parsec so far.
18:42:46 <Axman6> it's context tracking is build on top of the attoparsec parser
18:43:19 <dsal> I don't know [nameless]parec, but I use both attoparsec and megaparsec to good result.
18:43:31 <julianleviston> I mean I’ve used parsec for lots of things in the past, too… but yeah. Cool :) Hopefully I can build up some combinators with the equivalent of <?> from Parsec and have attoparsec build a stack of context on failure. :)
18:44:12 <Axman6> I wouldn't be surprised if trifecta did something like what you want (use it via the parsers package)
18:44:15 <julianleviston> It’s the sort of thing that now I’ve started to need I’m kind of like… I *never* want to go back to the other way, where I end up guessing what anything is.
18:44:53 <julianleviston> I think I was reading that there were problems with trifekta the other day. I should quote my source but I don’t know it was on a blog or reddit to do with parsing PEGs
18:45:08 <Axman6> trifecta will also let you annotate errors, with colours and stuff
18:45:10 <julianleviston> oh yeah here I think http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
18:45:13 <dsal> I keep wanting to use dhall, but I also want to do non-trivial things, and it seems to not be super great at that.
18:46:14 <Axman6> I look at dhall like I look at most things Gabriel writes, beautiful, well founded, and unusable. I never managed to write anything using pipes
18:46:31 <julianleviston> Does anyone know if there’s a PEG parser that will behave like this? 
18:48:03 <julianleviston> I have a feeling Frisby *could* work like this, but I just don’t understand enough about its choice operator.
18:48:14 <julianleviston> thanks for the chats anyway.
18:48:19 <dsal> I used dhall in a project once and it was pretty helpful.  I replaced a custom megaparsec thing and it was just better.  Now I'm trying something new, which you'd think would be easier.
18:54:55 <dsal> I think you summed up dhall pretty well in general, though, Axman6   Some things are great.  Some things are a little too hard (you want a function that takes two arguments? lol).  I think the standard format is one of the worst I've seen, though.
18:55:12 <dsal> Like... it's OK to use horizontal space. https://www.irccloud.com/pastebin/tAVpolSQ/config.dhall
18:55:45 * dsal halfs-ass-up another language
18:56:15 <DigitalKiwi> https://www.dropbox.com/s/7mrxij6fehbbued/2019-12-17%2018.02.43.jpg?dl=0 my latest haskell art. it sparkles!
18:57:13 <Axman6> jesus, wtf is that dsal
18:57:59 <dsal> dhall rhymes with tall
18:58:10 <Axman6> seriously, that makes me want to puke
18:59:00 <EvanR> tell us how you really feel!
18:59:29 <dsal> Yeah, it's surprisingly bad.  I like the language and it's helpful.  Has a couple downsides, though.
19:24:28 <suzu> Axman6: dhall looks useful for like, kubernetes yaml
19:24:31 <glguy> If you just want some config files: config-schema
19:24:53 <suzu> nix is my favourite unusable FP project
19:26:58 <maerwald_> FP?
19:27:09 <glguy> Floating point
19:27:32 <ChaiTRex> First place
19:27:45 <iqubic> Functional Programming
19:28:02 <dmwit> first principles
19:28:05 <ChaiTRex> Fine pewter
19:28:08 <MarcelineVQ> fortnight party
19:28:14 <dmwit> frog pottery
19:28:15 <glguy> Function pointer
19:28:17 <maerwald_> forget I asked....
19:28:27 <suzu> financial post
19:28:36 <MarcelineVQ> forgotten puzzelment
19:28:46 <suzu> false positive
19:28:58 * glguy tries to remember why things are being listed
19:29:01 <MarcelineVQ> faux pas
19:29:17 <suzu> fool's paradise
19:29:24 <suzu> nix is tragically beautiful
19:29:30 <dmwit> glguy: Forget everything you know about mattress covers.
19:29:31 <suzu> it's a great idea and i've used it a lot
19:29:33 <dsal> we were discussing suzu's favorite project
19:29:42 <suzu> but it's honestly so much work for something so brittle and badly documented
19:29:49 <MarcelineVQ> suzu: seen guix? it uses scheme
19:29:55 <glguy> dmwit: way ahead of you
19:29:58 <suzu> i tried really hard to like it and.. i just gave up. im on docker now
19:30:02 <suzu> MarcelineVQ: yeah that sounds awful
19:30:21 <glguy> jared-w started Advent of Code in nix!
19:30:25 <monochrom> I don't even know mattress covers.
19:30:37 <dsal> I tried using kubernetes for a small project I have running in google cloud.  It was more complicated, but in the end it would just cost more.
19:30:38 <dmwit> monochrom: They're like subset covers, but sleepier.
19:30:47 <suzu> funny story at work today: a coworker of mine is on a carnivore diet. that means they eat only meat. they think it's a serious diet that should really be looked into. okay.
19:31:04 <maerwald_> suzu: it is, but if you also it greens
19:31:04 <monochrom> w00t compactness
19:31:10 <MarcelineVQ> funny story no one you know that does keto is doing keto
19:31:10 <maerwald_> *eat
19:31:11 <dsal> But I want a little config language with stuff like loops.  I have a list of things and want to configure a list of stuffs up.  My one case worked pretty well.  Also had some string interpolation.
19:31:38 <suzu> so they're eating catered lunch today - removing everything that isnt meat and just eating the meat. and they say, "why does everyone think my diet is a joke? i think its a real thing with benefits"
19:31:40 <monochrom> loops usually spin out of control pretty quickly
19:31:46 <suzu> so i reply -- now you know what it's like to tell people that haskell is good
19:31:53 <suzu> badum tss
19:32:00 <dsal> monochrom: to be fair, that's a thing dhall's supposed to be good at.
19:32:14 <monochrom> as in, both a pun and referring to easily getting into the Turing tarpit
19:33:22 <EvanR> i've long considered "wanting loops" to be a red herring
19:33:40 <MarcelineVQ> don't you usually want a map anyway, your config thing sounded map-like
19:33:48 <EvanR> you almost never use loops in ruby on rails, the most procedural language ever
19:33:50 <maerwald_> loops or recursion... what's the difference
19:34:02 <MarcelineVQ> dhall should have maps, its restriction is just termination right? not that I know
19:34:23 <EvanR> you basically mapM_ over a collection
19:34:24 <monochrom> The difference: loops spin out of control, recursion spirals out of control >:)
19:34:41 <maerwald_> in the end it's an actual loop
19:34:48 <glguy> Agda has a termination checker, but I can still write "programs" in it that don't terminate in any amount of time I'm willing to wait
19:35:01 <maerwald_> at least in GHC
19:35:07 * EvanR squints at maerwald_ way over there away from the point
19:35:28 <EvanR> which is having literal loops in your user-facing language
19:35:29 <MarcelineVQ> maybe, but they're at least doing things while you wait :> 'being producitive'
19:35:45 <z0> hey. do we see any practical difference between running `go wtv acc = go (f wtv) (g wtv:acc)` and `go wtv acc = go (f wtv) (g wtv) : acc`?
19:35:58 <maerwald_> EvanR: what's the difference, all bits and pieces in the end *jumps out the window*
19:36:34 <EvanR> ya
19:36:35 <c_wraith> z0: well, they're entirely different things...
19:36:40 <EvanR> it's all 1's and 0's
19:36:55 <monochrom> What if I'm using a text console in a basement bunker so there is no window.
19:36:58 <dsal> glguy: you don't need to see it terminate.  Knowing it would is enough.
19:37:13 <EvanR> don't mind QAM-256 and things like this, we want to think in binary
19:38:29 * maerwald_ pictures monochrom in an old military bunker on his console
19:38:46 <dsal> The thing I'm looping with dhall is generating a bunch of influxdb queries to export snapshots to mqtt.  I have N sensors in a particular site and I have a set of query patterns I want to run against them.  If I add a sensor (which I realize I just did) I can add one little string and five more data points show up.
19:40:22 <monochrom> OOHHH then the answer is you get sucked into the console the TRON way!
19:41:07 <maerwald> I wish there was no software, it just causes problems...
19:41:14 <monochrom> General computing theorem: Eventually you either jump out of the window or get sucked into the console.
19:41:34 <MarcelineVQ> *jmp
19:41:39 <monochrom> heh
19:41:57 <glguy> maerwald: a software free world starts with you and your is provided disk formatter
19:42:17 <glguy> OS*
19:42:31 <dsal> unless your disk formatter is also software.
19:42:34 <EvanR> if you take away my weaponized software someone will figure out how to weaponized hardware
19:42:43 <maerwald> glguy: nice try ;D
19:42:50 <monochrom> Help Tony Stark develop GHC Ultron so it deletes every program that doesn't use dependent types.  That should be practically all software. >:)
19:43:36 <dsal> I've been doing a weekly agda thing for a couple months now.  All I really know is that addition commutes.
19:43:49 <c_wraith> tell that to floating point
19:44:00 <monochrom> disk formatter is irrelevant if people put their software on USB flash, CDROM, and the cloud.
19:44:01 <EvanR> bzz it actually does commute
19:44:07 <dsal> Oh, these are just natural peano type numbers.
19:44:58 <maerwald> telegraphy is where we should have stopped, it was entirely sufficient
19:45:07 <dsal> . to that
19:48:00 <MarcelineVQ> dsal: I bet you also know that ≡ is transitive and reflexive
19:48:01 <glguy> maerwald, stop
19:48:08 <MarcelineVQ> So hey, there's a couple things
19:48:23 <glguy> (telegraph joke)
19:48:23 <dsal> almost all the code we write is 'refl = refl'
19:48:30 <maerwald> xD
19:48:36 <glguy> Err, telegram?
19:48:51 <EvanR> refl :: a = a
19:48:52 <MarcelineVQ> telegram is just a printed and delivered telegraph
19:49:07 <dsal> with music
19:49:30 <EvanR> refl = refl :: (a = a) = (a = a)
19:49:34 <MarcelineVQ> da-da-da dadada, I, AM, your singing telegram *BANG*
19:50:12 <dsal> EvanR: I almost thought you knew agda, but too many colons.
19:50:34 <MarcelineVQ> EvanR knows agda, the chess being played is that you think he doesn't
19:50:46 <dsal> Ah.  Spot the bug.
19:51:00 <MarcelineVQ> besides, real agda is most _  not refl
19:51:32 <MarcelineVQ> refl's to the left _ to the right, here I am = in the middle with refl :: a = b
19:51:51 <MarcelineVQ> aww, bad clipboard :(   "here I am = in the middle with μ"
19:52:23 <EvanR> when in #haskell, :: as the haskellers
19:55:05 <dsal> A good percentage of the class is, "how do you type that character?"
19:55:15 <MarcelineVQ> dsal: You get over that
19:55:57 <MarcelineVQ> I mean what even is ⊎, what even is that, but you'll pick up how to write it pretty fast
19:56:26 <MarcelineVQ> whose's house is this? ⟰ it's your house dsal, it's yours now.
19:56:31 <dsal> Yeah, I don't have a problem typing stuff that's up on the screen.
19:57:04 <jared-w> I like how pretty agda looks
19:57:41 <jared-w> And yes, I started Advent of code in Nix and promptly ran into the "it's a general purpose programming language that's absolutely designed to never be used as one"
19:58:45 <jared-w> (otherwise known as "manipulating anything over 8k in size without using purely the built-in functions is probably going to start causing segfaults or running out of memory")
19:59:25 <dsal> The same podcast from which I learned about dhall was talking about how great nix is.
19:59:47 <jared-w> But it's damn cool what you can do with a completely pure language if you're willing to rewrite the world in a perversely consistent and coherent manner.
19:59:47 <jared-w> That's really nix's greatest strength. The sheer momentum of stuff out there you can take advantage of because of that.
19:59:47 <dsal> I've no experience with nix.
20:00:47 <maerwald> jared-w: consistent and coherent? what?
20:00:58 <jared-w> You can use it for a few different things. I find it awfully useful as a ultra convenient on-demand chroot/direnv as steroids.
20:01:02 <MarcelineVQ> dsal: I want to make acme packages for agda with things like   data _🏡_ (🐕 👪 : Set) : Set where ...
20:01:21 <maerwald> the only thing that applies to it is 'expressive', but consistent and coherent doesn't
20:02:22 <jared-w> maerwald: I didn't mean that in a formal sense. I was more talking about nixpkgs. It's a package repository with over 30k packages, and an entire operating system configuration DSL
20:03:04 <maerwald> yes and most of it is a mess
20:03:40 <maerwald> if you have enough time and energy going through that mess, you might find it useful, but... that's your time there ;)
20:07:24 <jared-w> Eh, have you seen packages in other distros? Nixpkgs is certainly coherent and consistent compared to the competition :p
20:09:34 <maerwald> I disagree
20:10:27 <jared-w> What distro would you say has the best packaging then?
20:10:37 <maerwald> Fedora and gentoo
20:10:50 <maerwald> they have proper policies, QA, review workflow
20:11:35 <maerwald> the amount of QA and review in gentoo is in no comparison to nixpkgs
20:12:05 <maerwald> I'm not sure NixOS has any policies for packaging, because configuration diverges quickly
20:12:14 <maerwald> there is no consistency whatsoever
20:12:22 <maerwald> except for the very core (networking, etc)
20:13:54 <maerwald> as a distro, it ranks lower than archlinux imo (and that's very low). A good package manager alone doesn't make a distro
20:14:34 <maerwald> the quality of packaging is what matters
20:14:45 <maerwald> (and that's a surprisingly hard job)
20:22:49 <dsal> I've never tried arch.  I mostly know about it because people come in here unable to write software on it.
20:23:00 <dsal> That's really all I want out of a computer.
20:25:16 <maerwald> Their contribution workflow is kinda broken, that's why people just write their own stuff and dump it on AUR. They don't have mentors, they are not trying to expand the circle of core devs...
20:25:30 <maerwald> And then you get lots of low quality packages.
20:25:39 <iqubic> So, I just wrote this thing, using plenty of lens combinators: http://dpaste.com/068RBP2
20:26:04 <iqubic> It works, and does basically exactly what you think it should.
20:26:21 <maerwald> looking at it, I'm thinking "wat?"
20:26:30 <iqubic> Looking at what?
20:26:34 <iqubic> What I just wrote?
20:26:37 <maerwald> yes
20:27:04 <iqubic> I see. It uses some cool tricks I learned about in Chris Penner's new book.
20:27:40 <dsal> Will you remember what it does in an hour?  :)
20:27:52 <iqubic> dsal: Yes. Probably.
20:30:32 <maerwald> Do 10 more of those things, then the answer is probably "no"
20:30:43 <iqubic> I think not.
20:30:50 <maerwald> I question that :)
20:31:59 <iqubic> maerwald: Do you use lenses?
20:34:51 <maerwald> yes
20:47:20 <dsal> I sprinkle lenses in where it's helpful.  I'm not doing his advent-of-lenses thing.
20:51:11 <iqubic> Ah. I see.
20:51:21 <iqubic> I'm also not doing advent of lenses.
21:06:18 <Arahael> What is this function called? (A a -> B a) -> A a -> B a
21:06:47 <Arahael> (Does that make sense?  An example of how it would be used is to basically allow transofrming, say, a `Maybe a` to a `List a`.
21:06:51 <Arahael> )
21:07:16 <Axman6> natural transformation?
21:07:25 <iqubic> it's a natural transformation
21:08:55 <suzu> http://hackage.haskell.org/package/natural-transformation-0.4/docs/Control-Natural.html
21:12:48 <Arahael> Ah, interesting. I should read up on those.
21:13:08 <suzu> do you need it for something?
21:14:03 <Arahael> I'm just curious, really.  Basically, in Swift, I had an optional, and I was wanting a better, more elegant way of doing htis. I thought, "if this were haskell, it's just a...", then I realied I didn't quite know what it was in Haskell either, except that I'd have probably used a fold.
21:14:24 <Arahael> As I am effectively doing a bunch of Maybe's to Lists.
21:16:11 <dibblego> @type (^.. _Just)
21:16:13 <lambdabot> Maybe b -> [b]
21:18:28 <Arahael> Nice lens.  That's a lens, right?
21:21:29 <Axman6> Well, _Just is a prism, (^..) is a function for returning all values pointed to by an optic and returning them as a list
21:28:24 <rotaerk_> I thought (^..) was a one-eared cat looking down
21:38:17 <Axman6> (^.) one eyed kitty will only give you one thing
21:38:49 <MarcelineVQ> rotaerk_: it's kirby scratching his head while looking at something perplexing
21:51:56 <rotaerk_> heh
22:31:42 <fragamus_> who was the sneaky bastard who came up with memoization combinators
22:32:30 <Axman6> Probably conal
22:32:47 <fragamus_> looking at the type signatures I would have thought it impossible
22:46:50 <dminuoso_> suzu: Axman6  Heh. I think of `^.` as a face missing a monocle, so I just insert the optic into the monocle place so the face can look at things..
23:28:49 <Arahael> Axman6: Ah, nice, so that's clearly list-specific, then.
23:56:13 <Athas> Does the .cabal format support wildcards for exposed-modules yet?  It does for extra-source-files, right?
