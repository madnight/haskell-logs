00:01:28 <pounce> ohno
00:02:37 <Gcf> Anyway, does anyone have an idea of what might be up with my code, or ghc?
00:04:19 <iqubic> Where is you code?
00:04:44 <Gcf> gist posted above (https://gist.github.com/GiantCowFilms/57f30fabef6d6ae95070ea3d28a7d79a).
00:12:24 <JayJr87> hello
00:13:25 <aplainze1akind> To extend an MArray (for obvious reasons) do I need to deconstruct it to an association list, then extend that list, then create an array from that one?
00:13:30 <aplainze1akind> Is there a more direct way?
00:14:33 <amalloy> Gcf: what happens if you add: import Data.Lens.At ()? 
00:15:04 <amalloy> it sounds like ghc isn't getting a type family instance, and that instance apepars to live in Data.Lens.At
00:17:12 <c_wraith> aplainze1akind: looks like that's the best you can get with array
00:18:42 <aplainze1akind> Is it stupid to insist on array? I figure the gain in using seq to extend the memory space won't be worth the loss in random access and the work to majorly overhaul my intcode computer.
00:19:12 <c_wraith> I just used Map Int Int.  Well, until today, when I made it Map Integer Integer
00:20:05 <dsal> I used a mutable array.  I just threw it all away and did Map Integer Integer
00:20:14 <dsal> I miss my mutable state.  :(
00:20:47 <c_wraith> and I got to have fun with lenses to handle extended reads
00:20:50 <c_wraith> :t non
00:20:53 <lambdabot> (Eq a, Profunctor p, Functor f) => a -> p a (f a) -> p (Maybe a) (f (Maybe a))
00:21:14 <aplainze1akind> For mysterious reasons, my IOArray Int Int does not break with the large number examples.
00:21:18 <aplainze1akind> How come?
00:21:44 <c_wraith> probably because their "large numbers" are just bigger than 32 bit, but on 64-bit systems Int is 64 bits
00:21:53 <aplainze1akind> Ah, right.
00:22:12 <c_wraith> I considered that, but decided to just go to Integer anyway
00:26:52 <Gcf> amalloy: I get a module not found error... what package is it from?
00:27:14 <Gcf> Ah, Control.Lens.At
00:27:27 <iqubic> Gcf: Yeah. It's in Lens.
00:27:32 <Gcf> Nope, still doesn't fix it.
00:30:42 <Gcf> To clarify, I got the import working, but the type error remains.
00:30:56 <Gcf> Hmm, maybe compiler flags....
00:32:32 <c_wraith> ...  is there any chance you have two different versions of containers installed?
00:33:02 <Gcf> ghci and ghc are both 8.6.5
00:35:41 <bahamas> is the ghci debugger currently integrated in any ide or editor?
00:35:46 <c_wraith> does the command "ghc-pkg list containers" show more than one installed?
00:36:06 <Gcf> I did some setup work for debugging in vscode, although I never actually made it work
00:36:52 <Gcf> Yes, I see two containers. One is for 0.6.2.1, the other for 0.6.0.1
00:37:37 <c_wraith> well, that's the problem.  lens is compiled against one, ghc is preferring the other when you try to compile it
00:37:52 <Gcf> Ahh
00:40:13 <Gcf> Two google queries into this and I'm getting the sneaking suspicion that Haskell's package management system is terrible.
00:40:29 <c_wraith> this is the main reason the old cabal v1 ecosystem is considered flawed.  You have to manage it very carefully to not break things
00:41:23 <Gcf> What ecosystem should I be using?
00:41:50 <c_wraith> if you were writing real programs, I wouldn't hesitate to say use the cabal v2 commands.
00:42:06 <c_wraith> But with stuff like the aoc, those are still a bit inconvenient.
00:43:08 <bahamas> Gcf: you could try nix and write the haskell file as a nix-shell script
00:43:21 <c_wraith> ...  that's not a quick project. :P
00:44:01 <Rembane> I think cabal v2 is worth it for AoC.
00:44:25 <bahamas> c_wraith: theoretically, it's just: step 1. install nix. step2: fill in this file https://gist.github.com/travisbhartwell/f972aab227306edfcfea
00:44:37 <c_wraith> it means you need cabal files, because the v2 commands still don't work correctly without one.
00:44:41 <c_wraith> and that's annoying
00:44:53 <bahamas> but a question comes to mind: how do you specify the version of ghc?
00:45:06 <bahamas> which you can't do easily
00:45:09 <Rembane> I use the system one 
00:45:15 <Rembane> Or maybe ghcup, I don't know by now...
00:45:24 <Rembane> I have a frankensystem.
00:45:54 <bahamas> but, the latest nix probably comes with ghc 8.6, so you don't need to specify the version
00:46:55 <koz_> -w /path/to/whatever/you/want/ghc in my case. :P
00:47:17 <Gcf> What should I do to fix this. I tried googling but I don't see anything promising.
00:49:36 <c_wraith> My usual fix is to delete ~/.ghc and reinstall packages more carefully.  No letting cabal install a package if it's already installed.
00:50:07 <Gcf> It seems like I somehow have two installs of ghc or something.
00:50:32 <Gcf> Specifically, I have ghc packages installed in both AppData and Program Files/Haskell Platform.
00:50:49 <Gcf> I'm kinda wondering if I can just delete one of them...
00:50:56 <c_wraith> that's just that ghc uses two package install locations by default.
00:51:05 <c_wraith> One for things that came with ghc, one for things you installed
00:51:05 <Gcf> Oh
00:51:37 <c_wraith> the advantage of that is that a ghc installation can be shared between users without stepping on each others' package sets.
00:51:54 <Gcf> I see...
00:52:32 <svipal> Are there any facilities to construct do notation functions in TH
00:52:48 <Ariakenom> c_wraith: the v1 solution seems more inconvenient than writing a cabal file
00:53:20 <c_wraith> Ariakenom: it's really not, when amortized over 25 days of needing different packages each day
00:53:32 <c_wraith> Ariakenom: I install the packages I need once, and I'm done.
00:54:43 <Ariakenom> I have all of the days in one cabal file. I add a 3 line section for each executable
00:54:44 <maerwald> cabal new-repl allows to specify deps
00:54:50 <maerwald> you don't need a cabal file
00:54:59 <boxscape> so, both Void and undefined are sometimes called _|_. Are they related? Because they seem very different to me, other than the fact that you can implement `absurd :: Void -> a` with undefined.
00:55:16 <dminuoso> boxscape: To call Void _|_ is incorrect.
00:55:30 <dminuoso> boxscape: One could say that bottom _|_ is the sole inhabitant of the type Void.
00:55:44 <Gcf> I'm thinking that cabal file might not be that bad. Added benefit that lang server features will actually work.
00:55:48 <c_wraith> maerwald: it lets you specify them, but you can't import them.  ghci gets confused
00:56:17 <boxscape> dminuoso huh, wikipedia only says that the empty type is called bottom and doesn't talk about non-termination or such at all wrt "bottom"
00:56:29 <Gcf> It worked!
00:56:41 <Gcf> Thank you so much c_wraith and everyone else!
00:56:43 <dminuoso> boxscape: There's two perspective of the type Void. One is, that its the completely devoid/empty type - so the connection to logic is that `absurd` gives you Ex Falso Quodlibet.
00:56:50 <Ariakenom> boxscape: link?
00:56:57 <c_wraith> Gcf: glad you're making progress
00:56:58 <iqubic> :t absurd
00:57:00 <lambdabot> Void -> a
00:57:04 <boxscape> Ariakenom https://en.wikipedia.org/wiki/Bottom_type
00:57:15 <boxscape> (it does mention undefined here but doesn't say it's called "bottom
00:57:19 <boxscape> ")
00:57:30 <c_wraith> haskell doesn't have a bottom type
00:57:36 <c_wraith> It has a bottom value, though
00:57:45 <dminuoso> And that bottom value inhabits *all* lifted types.
00:57:49 <boxscape> ah, right, Void and Void# aren't empty
00:57:50 <dminuoso> Including the, otherwise, empty type Void.
00:57:54 <c_wraith> (well, a bunch of them, but they're denotationally indistinguishable)
00:59:24 <koz_> c_wraith: I think Conor McBride calls them 'interesting types'. :P
00:59:36 <koz_> (whereas () and friends are 'boring types')
00:59:37 <[exa]> anyone else get the feeling that AoC final this year will be reimplementing the x86 assembly with all 9000 addressing modes of mov?
00:59:43 <maerwald> c_wraith: you can
01:01:15 <kuribas> There is no relation between Monoid and Alternative/MonadPlus, or is there?
01:01:21 <pavonia> [exa]: No spoilers please!
01:01:54 <dminuoso> [exa]: There is an established rule that we hack off peoples hands for uttering spoilers for AoC and Terminator movies.
01:02:06 <dminuoso> Everything else is fair game though.
01:02:15 <kuribas> In particular mempty versus empty
01:02:23 <dminuoso> kuribas: There is.
01:02:55 <[exa]> dminuoso pavonia: not spoiling! I just looked at today's first task :]
01:03:13 <dminuoso> kuribas: With a bit of squinting MonadPlus form right near-semirings. So they are related in the sense that both are algebraic structures.
01:03:14 <maerwald> c_wraith: what problem do you have with imports?
01:03:44 <kuribas> hmm Alternative: A monoid on applicative functors.
01:04:10 <MarcelineVQ> surely there's some realation Alt and Ap are Monoids
01:04:14 <dminuoso> kuribas: But then again, applicative functors themselves are monoids too.
01:04:14 <kuribas> does empty == mempty always?
01:04:26 <dminuoso> But that brings us back to the universal truth: Monoids are everywhere.
01:04:32 <dminuoso> kuribas: No.
01:04:38 <dminuoso> kuribas: It's generally expected, but I wouldn't rely on it.
01:04:39 <koz_> dminuoso: Yep, it's all monoids, all the way down.
01:05:05 <c_wraith> maerwald: oh, right.  the problem isn't imports, it's using :load
01:05:18 <maerwald> also works fine
01:05:42 <c_wraith> https://github.com/haskell/cabal/issues/5665
01:05:46 <c_wraith> I assure you, it does not
01:05:53 <koz_> Monoids are, apparently, like turtles.
01:06:19 <kuribas> is f <$> empty == empty?
01:06:51 <maerwald> c_wraith: I can specify dependencies and load a source file that uses those and run the functions
01:07:34 <c_wraith> are you running a ghc newer than 8.8.1?
01:08:31 <kuribas> It seems logical, but I don't see any such law in the docs
01:08:45 <maerwald> c_wraith: no
01:08:49 <maerwald> I suspect this is a user error
01:09:11 <jle`> kuribas: hm maybe you can say that pure f <*> empty = empty
01:09:13 <c_wraith> it is a cabal+ghc bug
01:09:20 <jle`> kuribas: but actually there are no Alternative laws really, only MonadPlus laws
01:09:46 <maerwald> c_wraith: the source file is not a proper module
01:09:57 <maerwald> so it's a user error
01:10:04 <maerwald> https://gist.githubusercontent.com/chowells79/05ded443ba5e5d9e2eeab2f2882c2eca/raw/2f1fd2264efa477c15389952e0fd790947252759/AoC0818.hs
01:10:13 <kuribas> jle`: but then the monadplus laws would imply the alternative laws
01:10:22 <c_wraith> maerwald: it's valid haskell
01:10:24 <jle`> kuribas: only if your type is a Monad
01:10:25 <maerwald> if you add 'module Main where' it works
01:10:37 <maerwald> c_wraith: *shrug*
01:10:49 <c_wraith> maerwald: since "module Main where" is explicit specified to be implied
01:11:00 <maerwald> not really an important bug imo
01:11:16 <maerwald> easy fix
01:11:27 <kuribas> mzero >>= f  =  mzero  then mzero >>= pure . g = mzero   then g <$> mzero == mzero
01:11:47 <kuribas> jle`: weird how Alternative is such a lawless beast
01:11:55 <c_wraith> But that's not a fix, it's working around the bug.  that's totally different.
01:12:00 <jle`> kuribas: the weirdnes comes from the fact that Applicative is a superclass
01:12:15 <jle`> but yeah, it stands to reason that there should be laws for it w.r.t. Applicative
01:12:29 <kuribas> jle`: like it suddenly becomes lawful when there is a monadplus instance
01:12:29 <jle`> and a typeclass like Alt from semigroupoids become the 'higher-kinded monoid' class
01:12:33 <maerwald> c_wraith: my point is... using modules in cabal new-repl works, importing dependencies works, coding works
01:12:51 <maerwald> that bug is an edge case
01:12:53 <c_wraith> unless you expect the language spec to be upheld
01:13:09 <maerwald> GHC violates it already :)
01:13:34 <c_wraith> but it doesn't violate that
01:13:45 <c_wraith> that part works according to spec everywhere else
01:14:02 <maerwald> your remark in the beginning was way broader than that bug report though
01:14:06 <maerwald> :load works 
01:14:19 <maerwald> except for that edge case
01:14:52 <c_wraith> That edge case is the single most common use case when you're not using a cabal file
01:15:10 <maerwald> I doubt that, but ok
01:15:35 <maerwald> I wasn't even aware you can omit 'module X where' at all ;)
01:15:56 <haskeldjiq_> guys what's going to happen if you just call forkIO with some action (for which action's result you don't care)
01:15:58 <maerwald> probably because ghci then loads everything line by line instead of treating it as a module
01:16:03 <haskeldjiq_> it's going to get cleaned up eventually, right?
01:16:22 <haskeldjiq_> I'm talking if you don't use bracket
01:16:35 <c_wraith> It will run until the action completes, or the program's main thread exits
01:16:53 <haskeldjiq_> perfect
01:16:57 <haskeldjiq_> thanks
01:17:33 <haskeldjiq_> and if the action throws an exception
01:17:54 <haskeldjiq_> thread just dies?
01:18:50 <maerwald> c_wraith: where does the spec say you can omit it?
01:19:19 <maerwald> "A Haskell program is a collection of modules, one of which, by convention, must be called Main and must export the value main."
01:19:58 <c_wraith> maerwald: https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1 last paragraph of section 5.1
01:20:32 <maerwald> interesting
01:22:44 <dminuoso> Mmm, when using aeson encode the order of the fields is not tthe one as they appear in the data type. 
01:23:12 <c_wraith> aeson uses unordered-containers and therefore gives you the hash order, iirc
01:23:16 <dminuoso> Ahh!
01:23:21 <dminuoso> c_wraith: Gotcha! :)
01:25:06 <dminuoso> That's more than annoying, heh
01:25:17 <maerwald> maybe check what waargonaut does
01:28:01 <dminuoso> Well in my case I could just use aeson-pretty, and then define some fancy way to construct an ordering like: "foo" :>: "bar" :>: "baz"
01:35:27 <aplainze1akind> Am I wrong to think that the terminology of AoC is inconsistent for write instructions.
01:36:07 <aplainze1akind> Writing to the adress which is literally written in tht position is called "Position mode", that seems pretty immediate to me.
01:36:49 <shachaf> Which formulation? I don't think "every epimorphism splits" talks about write instructions.
01:37:46 <aplainze1akind> shachaf: ?
01:37:47 <jle`> dminuoso: it sort of keeps you honest
01:38:02 <jle`> dminuoso: you aren't allowed to distinguish different json strings based on the ordering of the keys
01:38:45 <jle`> dminuoso: if you are relying on ordering of keys, you are using unspecified behavior that could backfire
01:39:06 <dminuoso> jle`: It's just for legibility.
01:39:30 <dminuoso> jle`: Concretely, I have some big record, and I really want to keep the `ifName` field at the top to make it easier to verify data more quickly.
01:40:01 <maerwald> dminuoso: how do you derive the ToJSON instance?
01:40:10 <kuribas> is there a better way to write if someTest then Just <$> val else pure Nothing
01:40:25 <maerwald> with Generics, I get exactly the order of the data type
01:40:30 <jle`> kuribas: i do `val <$ guard someTest`
01:40:32 <dminuoso> Im using generics as well.
01:40:35 <maerwald> weird
01:40:36 <dminuoso> maerwald: I think it may be coincidental.
01:40:41 <c_wraith> aplainze1akind: yeah, I agree.  at the moment, my code is treating modes differently for reading vs writing
01:40:47 <maerwald> waargonaut in fact doesn't preserve the order^^
01:40:55 <kuribas> jle`: it's not a Monad
01:41:04 <jle`> what is 'it'
01:41:08 <aplainze1akind> c_wraith: Yes that's what I feel forced to do. Annoying.
01:41:12 <kuribas> jle`: my applicative
01:41:14 <kuribas> :t guard
01:41:15 <lambdabot> Alternative f => Bool -> f ()
01:41:27 <c_wraith> aplainze1akind: I see a way I can unify the treatment, but I'm not going to do that rewrite unless there is another massive change required
01:41:35 <dminuoso> jle`: On the basis that JSON is human readable data, I'd say it'd be a valid requirement to control the order of keys.
01:41:42 <kuribas> jle`: note that my one never fails
01:41:45 <jle`> kuribas: ah, i misread
01:42:03 <maerwald> at least JSON schemas don't care about the order, while that's a different story for XML
01:42:51 <kuribas> jle`: maybe with a MaybeT
01:42:51 <jle`> kuribas: mapM (const val) (guard someTest), but that's a little uglier heh
01:42:52 <c_wraith> aplainze1akind: basically, you can split the mode use into separate "address calculation" and "address use" stages, and then share the address calculation stage between both reading and writing.  Only the address use stage would work differently
01:43:14 <jle`> kuribas: Alternative for MaybeT requires Monad iirc
01:44:24 <jle`> forM (guard someTest) $ \_ -> val     -- maybe not so great either, heh
01:44:35 <kuribas> jle`: ah, it does
01:45:14 <kuribas> jle`: I suppose a bit of verbosity is fine in this case then
01:45:16 <jle`> sequenceA (val <$ guard someVal)
01:45:31 <jle`> maybe there could be something nicer if there is more context
01:45:33 <jle`> but maybe not :)
01:45:42 <aplainze1akind> c_wraith: I'm tempted to translate to the sensible modes in the decoding stage.
01:45:51 <aplainze1akind> But that would be very hackish.
01:46:44 <aplainze1akind> I can pretend 0xy01 is in fact 1xy01 and vice versa at that stage.
01:47:28 <MarcelineVQ> kuribas: what is offensive about your original forumation?
01:47:58 <kuribas> MarcelineVQ: nothing really :)
01:48:17 <kuribas> MarcelineVQ: probably I am over-abstracting
02:07:20 <bahamas> in ghci, what's the difference between single-stepping and simply running `main` and then using `:continue` to continue the execution until the next breakpoint?
02:50:25 <iqubic> liftA2 is like magic
02:50:47 <merijn> iqubic: Applicative is magic ;)
02:51:58 <iqubic> Well, actually, I'm using traversals, and they are magic.
02:56:50 * hackage mmsyn6ukr 0.5.1.0 - A musical instrument synthesizer or a tool for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.5.1.0 (OleksandrZhabenko)
03:28:51 * hackage diagrams-rasterific 1.4.2 - Rasterific backend for diagrams.  https://hackage.haskell.org/package/diagrams-rasterific-1.4.2 (BrentYorgey)
03:29:35 <pablo[m]> hey peeps
03:30:27 * pablo[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/FwFkxPBIGcmlnBvBgzBaZwBT >
03:33:52 * pablo[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/oVHsEKhinfEooxuQdMXtrizU >
03:36:07 <kuribas> IMO the ghci debugger is to much like an imperative program.
03:37:29 <kuribas> stepping doesn't make much sense in haskell
03:37:40 <kuribas> it would be much nicer if you could guide "evaluation"
03:37:41 <iqubic> I've never used the ghci debugger.
03:37:48 <kuribas> iqubic: exactly :)
03:37:54 <kuribas> nobody uses it
03:38:08 <kuribas> like exploring the expression tree
03:38:40 <[exa]> ghci isn't the debugger?
03:39:00 <kuribas> in any case, the order of evaluation isn't even specified, so "stepping" is wrong IMO
03:39:17 <kuribas> [exa]: no, Debug.Trace is ...
03:39:40 <iqubic> I use Debug.Trace a ton.
03:40:02 <iqubic> That's what I used to debug my Intcode interpreter from today.
03:42:10 <kuribas> it would be nice to have a tree debugger with a good UI interface.
03:42:51 <kuribas> where you click on a thunk and it gets (partially) evaluated.
03:46:53 <boxscape> pablo[m] you're going to want to use the Monad functionality of Maybe. Are you familiar with do notation?
03:48:03 <boxscape> although admittedly I'd have to think about it for a bit to see how to thread the differing Nothing branches into there, hmm
03:48:14 <pablo[m]> <boxscape "@pablo you're going to want to u"> I've only ever used it in the context of the `IO` monad
03:50:20 <boxscape> pablo[m] if you do something like `do {sa <- lookup a; sb <- lookup b; sab <- lookup (a + b); pure sab}`  it would return `Just sab` if everything is successful and Nothing if any of these fail. This isn't the full code for what you have but might get you started
03:51:16 <boxscape> pablo[m] if you don't know about pure and (>>=) (i.e. Applicative and Monad) you might want to learn about them first, since they are used to desugar do notation
03:53:28 <boxscape> pablo[m] actually hold on the code I wrote isn't quite right I think...
03:53:52 <boxscape> no never mind it is right :)
03:54:21 <boxscape> ugh no it's not -.-
03:54:23 <boxscape> should be
03:54:34 <boxscape> do {sa <- lookup a; sb <- lookup b; sab <- lookup (sa + sb); pure sab}
03:54:50 <boxscape> (sa + sb instead of a + b)
03:55:29 <pablo[m]> <boxscape "@pablo if you don't know about p"> I'm familiarized with then in the context of the `Maybe` monad
03:55:40 <boxscape> okay
03:56:31 <boxscape> pablo[m] the do code I wrote above will be desugared into `lookup a >>= \sa -> lookup b >>= \sb -> lookup (sa + sb) >>= sab -> pure sab`
03:57:40 <pablo[m]> <boxscape "do {sa <- lookup a; sb <- lookup"> How would it recover if `lookup a` returns `Nothing`? Like, when this happens, it should calculate `sum' a` and insert it into `sums`.
04:00:01 <pablo[m]> <boxscape "@pablo the do code I wrote above"> makes sense
04:01:32 <pablo[m]> I tought about doing this, but the `>>=` wont work, cuz I don't want to propagate `Nothing` if `lookup _` returns it...
04:01:54 <boxscape> pablo[m] Ah, since retry is always called with the same arguments as lookup when lookup fails, it probably makes more sense to put this into the lookup function directly, i.e. write `lookup a = case Map.lookup x sums of {Just a -> Just a; Nothing -> retry x}`  or something like that
04:02:03 <pablo[m]>  * I thought about doing this, but the `>>=` wont work, cuz I don't want to propagate `Nothing` if `lookup _` returns it...
04:02:45 <pablo[m]> <boxscape "@pablo Ah, since retry is always"> humm
04:02:47 <pablo[m]> makes sense
04:03:41 <pablo[m]> but `Just a` has the `Maybe Int` type, and `retry x` returns a `Maybe (Map Natural Int)`
04:04:01 <pablo[m]> should I use `Either` then?
04:05:03 <boxscape> I think simply using Either would force you into basically the same syntax, let me think for a minute...
04:08:53 <boxscape> pablo[m] my first idea would be to have (instead of lookup) some function of type "Natural -> (Maybe Int -> Maybe (Map Natural Int)) -> Maybe (Map Natural Int)", whose second argument tells it what to do in the Just case, but there could be a better solution
04:09:26 <phanimahesh> Either is a perfectly acceptable solution.
04:09:37 <phanimahesh> I just went through the logs.
04:09:55 <phanimahesh> You want to do a computation that might fail and handle failure.
04:10:27 <phanimahesh> That smells like a Maybe monad, with do notation code will look nice and clean.
04:10:29 <phanimahesh> However,
04:10:54 <phanimahesh> you also want to distinguish the failures based on the reason they happened. You only care about the first failure.
04:11:04 <phanimahesh> That's exactly the either monad.
04:19:40 <pablo[m]> humm
04:19:46 <pablo[m]> i'll try it out
04:20:20 * hackage bindings-portaudio 0.2.1 - Low-level bindings to portaudio library  https://hackage.haskell.org/package/bindings-portaudio-0.2.1 (FumiakiKinoshita)
04:20:23 <pablo[m]> how does the `do` notation works for `Either`
04:20:27 <pablo[m]>  * how does the `do` notation works for `Either`?
04:20:43 <merijn> pablo[m]: The same as it works for any monad? ;)
04:20:54 <merijn> pablo[m]: Do you know how do notation desugars?
04:21:57 <pablo[m]> <merijn "@pablo: Do you know how do notat"> yep
04:22:18 <pablo[m]> I actually don't know how `>>=` works for `Either`
04:22:27 <merijn> :t (>>=)
04:22:31 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:22:31 <phadej> try!
04:22:34 <phadej> open GHCi, and try!
04:22:41 <phadej> it's one of the best ways to learn
04:22:43 <merijn> :t (>>=) `asAppliedTo` (undefined :: Either String Int)
04:22:46 <lambdabot> Either String Int -> (Int -> Either String b) -> Either String b
04:22:56 <phadej> > Right 'x' >>= Right . Data.Char.toUpper
04:22:59 <lambdabot>  Right 'X'
04:23:07 <phadej> > Left 123 >>= Right . Data.Char.toUpper
04:23:10 <lambdabot>  Left 123
04:23:14 <phadej> etc.
04:24:23 <phanimahesh> Either behaves very similar to maybe. Success value gets propogated, failure short-circuits the block and returns the failed value.
04:24:42 <phanimahesh> Right is the success, Left is failure for Either
04:25:51 <phanimahesh> (That's not the most accurate way to look at monads, but for simple types like Maybe and Either the easiest to understand.)
04:26:14 <dminuoso> I want two modes for errors. I want one where I can collect non-critical errors (allowing me to gather as many errors as I can) as well as critical errors that will short circuit the entire calculation. 
04:26:27 <dminuoso> Is there a library that provides me with such error handling for an arbitrary monad stack?
04:27:33 <merijn> dminuoso: these?
04:27:52 <dminuoso> merijn: Ah. Is there a transformer version of these?
04:27:52 <merijn> Or ChronicleT/whatever
04:27:58 <merijn> dminuoso: ^^
04:28:08 <dminuoso> merijn: Gotcha! I was already thinking of these, but couldn't find a TheseT
04:28:10 <dminuoso> That helps. :)
04:28:54 <Ariakenom> I was thinking of chronicle. these names are awesome
04:29:33 <dminuoso> that pun.
04:29:41 <Ariakenom> :)
04:30:34 <Ariakenom> this is great
04:31:21 <dminuoso> that is not funny.
04:32:14 <Ariakenom> https://hackage.haskell.org/package/monad-chronicle-1/docs/Control-Monad-Chronicle.html
04:32:15 <phanimahesh> :t these
04:32:18 <lambdabot> error: Variable not in scope: these
04:32:33 <phanimahesh> Point me to this these please? worst search term ever
04:32:49 <dminuoso> Why is there both these and monad-chronicle?
04:33:05 <dminuoso> phanimahesh: https://hackage.haskell.org/package/these
04:33:12 <phadej> why there is ExceptT and Either
04:33:27 <phadej> because ExceptT Identity is not Either
04:33:29 <dminuoso> phadej: Ah no. I was staring at https://hackage.haskell.org/package/these-0.7.3/docs/Control-Monad-Chronicle.html
04:33:41 <pablo[m]> <merijn ":t (>>=) `asAppliedTo` (undefine"> Just looked at the source code: https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Either.html#line-155
04:33:56 <dminuoso> phadej: And confused why there were two packages with ChronicleT. hoogle sometimes sends you towards old versions, confusingly
04:34:26 <Ariakenom> phanimahesh: searching on hoogle works https://hoogle.haskell.org/?hoogle=these&scope=set%3Astackage
04:34:32 <phanimahesh> I mean this works, but could there have been better names?
04:34:35 <phanimahesh> data These a b = This a | That b | These a b
04:34:42 <phadej> No.
04:34:55 <phadej> as in, what would these better names?
04:34:55 <merijn> phanimahesh: What name would be better, according to you?
04:35:27 <dminuoso> I think it's great for the same reason `data Either a b = Left a | Right b` is great, the names aren't really supposed to tell you anything.
04:35:39 <phanimahesh> Ariakenom: yeah, should've done an online hoogle.
04:35:49 <phanimahesh> I don't have a better suggestion
04:36:06 <merijn> phanimahesh: Neither does anyone else, which is why they're named that ;)
04:36:16 <merijn> And I agree with dminuoso
04:36:22 <boxscape> well, in chronicle the names are kind of supposed to tell you something more than that, the docs specifially say it's a combined error/writer Monad
04:36:38 <boxscape> s/combined/hybrid
04:36:42 <boxscape> or wait
04:36:48 <boxscape> does chronicle even use These
04:36:57 <boxscape> or does it just offer conversion functions
04:37:18 <boxscape> hm, it newtypes These
04:37:26 <phanimahesh> In fact I had a very hard time wrapping my head around a few types because the names indicated things which they weren't doing. Completely random names might not be so bad. it's just the expectation of having meaningful names..
04:37:39 <dminuoso> boxscape: monad-chronicle offers you a These-based transformer as well as an mtl-style interface
04:37:41 <merijn> boxscape: it newtypes "m (These a b)", the same way ExceptT newtypes "m (Either a b)"
04:37:50 <merijn> dminuoso: these has that too
04:38:09 <merijn> dminuoso: Control.Monad.Chronicle and Control.Monad.Trans.Chronicle in these
04:38:12 <dminuoso> merijn: Not anymore
04:38:28 <merijn> ah
04:38:56 <dminuoso> merijn: Its sort of why I asked in the first place. I looked into `these` but didn't find any transformer. :)
04:39:30 <seishun> is there a standard function that does `\x -> length . filter (== x)`?
04:40:03 <merijn> seishun: Not really, that seems awfully specific to have a dedicated function for?
04:40:14 <dminuoso> seishun: https://hoogle.haskell.org/?hoogle=Eq+a+%3D%3E+a+-%3E+%5Ba%5D+-%3E+Int&scope=set%3Astackage
04:40:20 <dminuoso> seishun: Hoogle is great for searching by type signature.
04:40:50 <phadej> heh, missingH
04:41:13 <seishun> yeah but sometimes it finds the wrong thing or there's a similar thing with a different signature
04:41:33 <dminuoso> seishun: For something that specific it would give you an appropriate result though. 
04:41:38 <seishun> yeah I guess
04:41:51 <dminuoso> % :t \x -> length . filter (== x)
04:41:51 <yahb> dminuoso: Eq a => a -> [a] -> Int
04:42:11 <dminuoso> There's not many ways this type signature can be meaningfully implemented *and* end up in base (if at all).
04:42:45 <boxscape> I wouldn't put it past base to have a partial function that returns the index of an element :^)
04:42:54 <merijn> boxscape: It does
04:42:56 <merijn> :t find
04:42:59 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
04:43:01 <boxscape> that's not partial
04:43:05 <merijn> oh, not partial
04:43:12 <dminuoso> merijn: And it doesn't give you the index.
04:43:17 <merijn> :t findIndex
04:43:19 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
04:43:25 <merijn> dminuoso: remembering names is hard!
04:46:37 <boxscape> odd inconsistency with Foldable vs [] but I admit it could be a bit odd to use the foldable instance of something to find an index
04:47:24 <dminuoso> boxscape: Foldable might not have the notion of an index.
04:47:36 <dminuoso> boxscape: Foldable doesn't say you can *index* into it.
04:47:42 <dminuoso> That is
04:47:51 <dminuoso> If you find an element inside a tree. What is its index exactly? ..
04:52:17 <bwe> [(Int, Maybe Int)] -> [(Int, Int)] -- how can I make this transformation in a simple manner?
04:52:38 <merijn> bwe: Well, what's it supposed to do?
04:53:29 <dminuoso> % :t \xs -> [(l, r) | (l, Just r) <- xs]
04:53:29 <yahb> dminuoso: [(a, Maybe b)] -> [(a, b)]
04:53:31 <Rembane> map (second (const 7))
04:53:41 <bwe> merijn: XY-Problem discrimination: wider goal: [(Int, Maybe Int)] -> Map.Map Int Int
04:53:54 <dminuoso> bwe: Again, what should that do?
04:54:04 <bwe> dminuoso: Reasonable. Thanks
04:54:31 <bwe> dminuoso: I want to store values in a Map but only the values and not the Nothings
04:54:40 <merijn> bwe: Just fold with alter?
04:54:42 <Rembane> bwe: mapMaybe is a good start imo 
04:55:43 <bwe> merijn: I discarded alter earlier as it take (Maybe a -> Maybe a) as argument??
04:57:34 <merijn> bwe: The input maybe is "the current element for that key" (i.e. Nothing = no value, Just = value)
04:57:42 <merijn> bwe: So you can just do "const val"
04:58:07 <merijn> bwe: Which ignores the current value and just sets via the Maybe
04:58:42 <merijn> Alternatively, convert (Int, Maybe Int) to Maybe (Int, Int) and mapMaybe that function
05:00:42 <Putonlalla> Hey, that's `sequenceA`.
05:01:09 <Putonlalla> Are you really looking for `traverse`?
05:05:58 <phanimahesh> Avoid creating (Int, Maybe Int) if possible, that's an ugly type.
05:06:53 <phanimahesh> I was having almost the exact same problem about a month ago. turns out by traversing I can avoid going through the weird intermediate type.
05:08:09 <davve> ~/17
05:20:25 <bwe> merijn: that was the approach that worked for me well, appreciated.
05:41:21 * hackage cabal-rpm 1.0.2 - RPM packaging tool for Haskell Cabal-based packages  https://hackage.haskell.org/package/cabal-rpm-1.0.2 (JensPetersen)
05:45:18 <yasar> This is my implementation of second exercise in cis 194 -> https://gist.github.com/yasar11732/78005ddd663903eeed55e8a76e6f3070
05:45:44 <yasar> I feel like reversing the list twice is not the way to go here
05:46:23 <yasar> Here is the exercise: https://www.seas.upenn.edu/~cis194/spring13/hw/01-intro.pdf
05:47:20 <f-a> yasar: if you don't want to reverse twice, you could zip the list with [1,2...] (but I don't know if zip has been introduced yet in your notes)
05:47:54 <f-a> also there are some redundant parentheses in the first example
05:48:18 <f-a> why not (x:y:zs)
05:48:37 <f-a> and why not [x] instead of (x:[])
05:48:43 <yasar> I am not very familiar with syntax :)
05:48:52 <yasar> Was following an example
05:50:02 <f-a> in any case yasar , doubleEveryOther' seems a fine way of solving it
05:50:15 <yasar> f-a, I don't think zip approach would work because I must double every other element from right
05:50:40 <yasar> So, last element won't be doubled, second to last should be doubled etc.
05:51:03 <yasar> Hence, I reverse, use doubleEveryOther' and reverse again
05:51:22 <boxscape> double reverse seems fine in that case to me
05:51:30 <f-a> well, if you don't know if the list length is even or odd...
05:51:34 <boxscape> doing things from the right just isn't something list is very well suited for
05:57:23 <amx> you could get by with one `reverse`, if you make doubleEveryOther' construct the output list reversed
05:58:16 <boxscape> > foldr (\x el -> case el of Left xs -> Right (x : xs); Right xs -> Left (2*x : xs)) (Right []) [1..10]
05:58:21 <lambdabot>  Right [1,4,3,8,5,12,7,16,9,20]
05:58:22 <boxscape> but you probably don't want a foldr solution
05:59:00 <amx> http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.List.html#reverse    for inspiration
05:59:46 <yasar> I will go with my original solution for now, to not to make things too complicated
06:00:20 <yasar> My attempt to use currying is also failing me :)  https://gist.github.com/yasar11732/78005ddd663903eeed55e8a76e6f3070
06:00:54 <yasar> I tried to write sumDigits  without arguments
06:01:30 <boxscape> why are you using `sum` twice?
06:01:49 <boxscape> oh because toDigits produces a list, eh
06:02:24 <jpcooper> Given a 2-parameter type class C x y which is transitive, and three types s, t and u with C s t, C t u, how can I convince the type checker that C s u without carrying around proofs? I'm not even sure how I would make such a proof
06:02:55 <boxscape> yasar the last . shouldn't be there - right now it's equivalent to "sumDigits xs = sum (sum (map (toDigits xs)))"
06:02:56 <yasar> boxscape, this is the aim: sumDigits [16,7,12,5] = 1 + 6 + 7 + 1 + 2 + 5 = 22
06:03:05 <jpcooper> I want Haskell to know thta C s u whenever C s t and C t u
06:05:04 <boxscape> jpcooper this might not be the cleanest solution but maybe you could write `instance {-# OVERLAPPABLE #-} (C a b, C b c) => C a c`
06:05:05 <jpcooper> I was thinking of defining a class TransitiveC s t u which has an instance only when C s t and C t u
06:06:08 <jpcooper> boxscape: So will that get rid of the "ambiguous type b" issue?
06:07:15 <boxscape> uhm I'm not 100% sure without context
06:07:20 <amx> yasar: what you try to do fails at sum.map.toDigits
06:07:21 <boxscape> I would guess that it does
06:07:28 <jpcooper> Okay. Thanks
06:07:56 <jpcooper> The issue I had was that the class defines a function (rightly) only over s and u, and not t. So t becomes ambiguous
06:08:23 <boxscape> oh, right
06:08:27 <boxscape> that might still be an issue
06:32:40 <Zemyla> You know, I just had a thought for an alternate version of how IntSet might work.
06:36:14 <Zemyla> Basically, it'd be rather like the IntervalMap here https://hackage.haskell.org/package/fingertree-0.1.4.2/docs/Data-IntervalMap-FingerTree.html but it'd contain intervals of Ints, and would merge neighboring or overlapping intervals together.
06:36:20 * hackage clckwrks 0.25.4 - A secure, reliable content management system (CMS) and blogging platform  https://hackage.haskell.org/package/clckwrks-0.25.4 (JeremyShaw)
06:48:26 <yasar> https://gist.github.com/yasar11732/78005ddd663903eeed55e8a76e6f3070 -> why the type error :(
06:48:40 <yasar> in hanoi function
06:49:20 <Thinh234> hello
06:50:42 <f-a> yasar: remember that function application (i.e. space) has precedence on everything
06:50:48 <f-a> (n-1) will do
06:51:39 <heebo> if in doubt add parens, haskells dirty secret is that it can be made to look a bit like lisp 
06:52:41 <heebo> im running hie against template haskell and , sometimes (not always ) my code compiles , other times it complains about multiple declarations that dont exist , does anyon e have an idea how to fix?
06:58:43 <ethan_> hey so where do i go to learn how to read cabal errors?
06:59:22 <ethan_> googleing normally works for most of my errors but doesnt seem to work great for cabal ones
07:00:33 <f-a> ethan_: which specific errors?
07:01:08 <ethan_> backjump limit reached
07:01:20 * hackage clckwrks-plugin-page 0.4.3.19 - support for CMS/Blogging in clckwrks  https://hackage.haskell.org/package/clckwrks-plugin-page-0.4.3.19 (JeremyShaw)
07:02:51 * hackage clckwrks-plugin-media 0.6.16.8 - media plugin for clckwrks  https://hackage.haskell.org/package/clckwrks-plugin-media-0.6.16.8 (JeremyShaw)
07:03:48 <ethan_> when i increased the limit it just said killed?
07:03:51 * hackage clckwrks-cli 0.3.0.1 - a command-line interface for adminstrating some aspects of clckwrks  https://hackage.haskell.org/package/clckwrks-cli-0.3.0.1 (JeremyShaw)
07:05:50 * hackage clckwrks-theme-bootstrap 0.4.2.2 - simple bootstrap based template for clckwrks  https://hackage.haskell.org/package/clckwrks-theme-bootstrap-0.4.2.2 (JeremyShaw)
07:11:38 <yasar> Couldn't make pattern matching work? https://gist.github.com/yasar11732/fc4c2692dcd6d356658b807182af34c6
07:14:32 <geekosaur> you can't match a string that way because for example "E" becomes 'E':[]
07:16:28 <geekosaur> so you'd need parentheses. it's a  bit of a corner case because it's a list with a list (string) within
07:16:59 <geekosaur> ("E"):... should work so it doesn't run the lists together
07:19:18 <yasar> geekosaur, still not working -> https://gist.github.com/yasar11732/fc4c2692dcd6d356658b807182af34c6
07:19:43 <geekosaur> can you add the error message to the paste?
07:22:09 <yasar> LogAnalysis.hs:7:1: error: Parse error in pattern: parseMessage'
07:23:26 <geekosaur> oh, sorry, tat's a  common error. parentheses also needed around the rest of it, because patteerns are parsed the same way as expressions
07:23:59 <geekosaur> so it sees: (parseMessage' ("E")):...
07:25:07 <geekosaur> needs to be: parseMessage' ("E":severity:timestamp:rest) = ...
07:25:26 <geekosaur> and I'm not sure if the extra parens are actually needed since it should know the string is complete, hm
07:25:35 * geekosaur has been away too long :(
07:27:09 <Zemyla> But yeah, an interval-based IntSet would allow for a complement operation.
07:29:01 <bl4ckb0ne> is zip the adequate function to generate every possible pair of 2 lists ?
07:29:29 <f-a> zip? why zip you mean list comprehension?
07:30:29 <merijn> bl4ckb0ne: No, zip only computes N pairs, rather than NxN pairs
07:30:47 <merijn> bl4ckb0ne: The applicative instance of lists is cartesian, though
07:30:53 <merijn> > zip [1..3] [1..3]
07:30:59 <lambdabot>  [(1,1),(2,2),(3,3)]
07:31:02 <bl4ckb0ne> [(x, y) | x <- [0..9], y <- [0..99]] was what I was looking for
07:31:03 <merijn> > (,) <$> [1..3] <*> [1..3]
07:31:06 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
07:31:10 <f-a> bl4ckb0ne: excellent
07:31:13 <bl4ckb0ne> thanks!
07:32:20 * hackage tmp-postgres 1.30.0.1 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.30.0.1 (JonathanFischoff)
07:34:00 <boxscape> > sequence [1..3]
07:34:03 <lambdabot>  error:
07:34:03 <lambdabot>      • Ambiguous type variables ‘m0’,
07:34:03 <lambdabot>                                 ‘a0’ arising from a use of ‘show_M11291770324...
07:34:15 <boxscape> > sequence [[1..3], [1..3]]
07:34:17 <lambdabot>  [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
07:34:34 <merijn> boxscape: That's not tuples, though
07:34:50 <boxscape> true, but extendable to an arbitrary arity, which can be nice
07:35:05 <merijn> boxscape: So is the applicative one, though :)
07:35:20 <merijn> > (,,) <$> [1..3] <*> [1..3] <*> [1..3]
07:35:27 <lambdabot>  mueval-core: Time limit exceeded
07:35:32 <merijn> aww, come on
07:35:34 <merijn> > (,,) <$> [1..3] <*> [1..3] <*> [1..3]
07:35:39 <merijn> You can do better, lambdabot
07:35:39 <lambdabot>  [(1,1,1),(1,1,2),(1,1,3),(1,2,1),(1,2,2),(1,2,3),(1,3,1),(1,3,2),(1,3,3),(2,...
07:36:36 <boxscape> Yeah, although you have to use one fixed tuple constructor, so you can't use the same function for different arities. Admittedly that's probably not that often useful
07:37:42 <boxscape> > map sequence [[[1..3], [1..3]], [[1],[2],[3]]]
07:37:44 <lambdabot>  [[[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]],[[1,2,3]]]
07:39:21 * hackage boltzmann-brain 1.6 - Analytic sampler compiler for combinatorial systems.  https://hackage.haskell.org/package/boltzmann-brain-1.6 (mbendkowski)
07:41:51 * hackage amqp-utils 0.4.1.0 - Generic Haskell AMQP tools  https://hackage.haskell.org/package/amqp-utils-0.4.1.0 (woffs)
07:43:52 <bl4ckb0ne> would it be possible to "unpack" the values of a tuple?
07:44:00 <bl4ckb0ne> i have test :: Int -> Int -> Int
07:44:04 <merijn> bl4ckb0ne: Just pattern match?
07:44:24 <merijn> > case (2,3) of (x, y) -> show x ++ " " ++ show y
07:44:28 <lambdabot>  "2 3"
07:44:35 <bl4ckb0ne> and filer test [(x, y) | x <- [0..10], y <- [0..10]]
07:44:56 <bl4ckb0ne> this might not be the best approach
07:45:09 <boxscape> :t uncurry
07:45:11 <lambdabot> (a -> b -> c) -> (a, b) -> c
07:45:39 <boxscape> ^ bl4ckb0ne `uncurry test` will have type (Int, Int) -> Int
07:49:01 <Zemyla> [(x, y) | x <- [0..10], y <- [0..10], test x y]
08:19:06 <voyons_osti> using parsec, i wrote an expression parser that i would like to run from my "main" parser. the expression parser keeps some state around that the rest of the language doesn't need (a stack) and my main parser keeps state that my expression parser doesn't need (name bindings)
08:19:36 <voyons_osti> but using one parsec parser from another means things like line numbers are all messed up
08:19:41 <voyons_osti> and error messages are not very useful
08:20:11 <voyons_osti> i looked through the docs for parsec: https://hackage.haskell.org/package/parsec-3.1.13.0/docs/Text-Parsec-Error.html
08:20:29 <voyons_osti> some of these (like mergeError) look like they could help me, but i don't understand how to use them
08:20:38 <voyons_osti> or... should i just not be doing this? x)
08:21:42 <heatsink> Should the parsers leave the unused part of the state unchanged?
08:40:41 <svipal> pattern splices WHEN
08:41:06 * svipal cries in template haskell
08:45:57 <Putonlalla> I just noticed that if you define `(||||) :: (a -> b) -> (m (Free m a) -> b) -> Free m a -> b` and `(&&&&) :: (a -> b) -> (a -> m (Cofree m b)) -> a -> Cofree m b` in the obvious way, you get definitions for `histo` and `futu` that look just like the definitions of `para` and `apo` via `(|||)` and `(&&&)`.
08:46:55 <Rembane> Putonlalla: Do you combine arrows with Free? 
08:47:51 <Putonlalla> No, I just treat `Free` and `Cofree` like `Either` and `(,)`, Rembane.
08:48:29 <Rembane> Putonlalla: Sweet! 
08:54:40 <voyons_osti> heatsink, yes, i believe so
08:57:20 <heatsink> You could make some of the parsers generic in the state and use a typeclass to project out the part that they need
08:58:38 <heatsink> You could make a function that changes a parser's state type.  Parsec doesn't have helper functions for that, so you'd need to work with the low-level interface to do that
08:59:24 <solonarv_> IIRC parsers have MonadState so you could use that + lens to easily modify only the parts of state you care about
09:06:18 <zincy_> How should I unit test queries written using postgresql-simple?
09:06:41 <zincy_> do I need to use mtl style plus something like monad-mock?
09:07:14 <zeta_0> hello guys, a couple of weeks ago i purchased a raspberry pi 4 model B and installed raspbian os on it, anyways, when i connected the pi to a tv using hdmi, the one thing that i noticed was that the screen brightness is way to bright, is there a setting somewhere in raspbian where i can adjust the screen brightness?
09:07:34 <ysangkok> zeta_0: wrong channel?
09:09:24 <zeta_0> ysangkok: i just asked here to see if anyone knows, i'll go back to checking #raspbian
09:10:06 <svipal> `The exact Name ‘defer_a1Mua’ is not in scope. Probable cause : you used a unique Template Haskell name (perhaps via newName,) but did not bind it`
09:10:08 <svipal> :)
09:36:04 <svipal> `Splices within declaration brackets not (yet) handled by Template Haskell` 
09:36:06 <svipal> ;D
09:37:09 <ornxka> in haskell mode ive got f [] _ = blah blah, when my cursor is at f_, and i hit control right, it goes to blah_ instead of []_
09:37:15 <ornxka> why
09:37:36 <svipal> What I'm trying to do is to to declare a datatype, call makeLenses and then create instances (which depend on lenses being there) in a q [Dec] function
09:37:52 <svipal> all of that in the function, to be clear
09:38:38 <solonarv_> most likely your editor does not handle ctrl+right specially in haskell code, and so it just jumps to the beginning of the next "word"
09:38:41 <svipal> just doing  dataDec <- dataD (return []) typeName [] Nothing constructors clauses;   lensDec <- makeLenses typeName
09:38:45 <svipal> yields a 
09:39:03 <svipal> ‘TypeName’ is not in scope at a reify
09:39:04 <solonarv_> "word" in the usual meaning, that is: one that is made of letters
09:39:15 <solonarv_> so it skips over punctuation
09:39:23 <svipal> and trying to do call makeLenses within a [d||] doesn't work as shown
09:39:29 <svipal> should I just declare my lenses manually
09:39:36 <svipal> or is there a way somehow ?
09:39:50 <svipal> I feel like no one even uses templatehaskell lol so not holding my breath there
09:40:15 <Jinna> What is the difference between a boxed value and an unboxed value? Is a boxed one a pointer into the heap which first needs to be defreferenced? Can only primitive values be unboxed? Or can a Text value too be unboxed?
09:41:08 <solonarv_> svipal: I'm feeling a bit lost, could you perhaps post your code in a single gist.github.com (or the like) rather than scattered across several IRC messages?
09:41:50 <solonarv_> Jinna: you got the basic idea right, yes: a boxed value is a pointer to some heap object, an unboxed value is just the actual "raw" value
09:42:25 <solonarv_> as to your second question, that depends on what you mean by "primitive"
09:42:58 <Jinna> solonarv_: objects of 1 to 8 bytes, i.e. the C values.
09:43:28 <c_wraith> boxing values is actually extremely important. it's how parametric polymorphism is implemented. everything has the same representation, so everything can be passed to the same functions
09:43:39 <svipal80> solonarv_ : will do, although the messages were just the error messages
09:43:43 <solonarv_> hmm, in that case the answer is no: you can define arbitrary unboxed values / data types
09:43:55 <solonarv_> syntax and usage are clumsy though
09:44:11 <solonarv_> unboxed tuples: (# Int#, Word# #)
09:44:55 <Jinna> solonarv_: what is an unboxed String? Isn't a String a pointer to some contiguous sequence of bytes in RAM? What is the difference between a boxed and an unboxed String then?
09:45:04 <solonarv_> this is basically the same as struct { long long x, unsigned long long y}
09:45:22 <solonarv_> Jinna: in Haskell, String is just an alias for [Char], i.e. a list of Char
09:45:28 <Jinna> In case of an unsigned long I can understand that the 8 bytes can fit into a 64 bit register and be interpreted as a single number.
09:45:32 <c_wraith> you can't arbitrarily unbox random types.
09:45:43 <svipal80> I'm sorry, I don't know how to "minify" it at this point
09:45:56 <svipal80> it depends on a lot of other code and might be very hard to understand
09:46:22 <svipal80> https://pastebin.com/x8dAmkMA
09:48:00 <svipal80> the function i was asking about is constructNode. 
09:48:02 <solonarv_> Jinna: you cannot arbitrarily unbox existing types
09:48:10 <solonarv_> however you *can* define "new" unboxed types
09:48:14 <svipal80> the basic idea is that I want to do a data dec, a lens dec and an instance dec that depends on a lens being there
09:48:34 <c_wraith> I'm assuming that in your real code, that's in a different file?
09:48:55 <solonarv_> (they are not really "new", as they are simply a combination of unboxed sum / tuples alongside other existing data types)
09:49:03 <c_wraith> if not, that's probably your issue
09:49:07 <svipal80> yeah it 's real code
09:49:19 <c_wraith> template Haskell has staging issues.
09:49:59 <svipal80> it's all in the same file
09:50:34 <Jinna> solonarv_: in C, when I "have" a struct... doesn't this mean that I have a pointer to the struct?
09:50:38 <svipal80> the issue I feel is that the lens declaration is actuall *made* before the other decs
09:50:39 <c_wraith> in order to call  constructNodes in the splice, it has to interpret it.
09:51:08 <c_wraith> and it can't interpret a file with unresolved splices.
09:51:52 <c_wraith> so it creates a circular dependency problem to have constructNodes defined in the same file as it is used to generate a splice.
09:52:20 <solonarv_> Jinna: no, it does not; you actually have a bunch of values on the stack (or wherever the struct lives)
09:52:23 <solonarv_> at least I think so
09:52:26 <solonarv_> I am no C expert
09:52:39 <Jinna> ok
09:53:10 <svipal80> ah, I understood it poorly
09:53:12 <solonarv_> but surely the fact that people take pointers-to-a-struct as arguments all the time suggests that they are not already pointers
09:53:18 <svipal80> I am calling constructNode in another file, yes
09:53:40 <c_wraith> oh, ok. good! :)
09:54:59 <c_wraith> why don't you just call makeLenses instead of trying to put it in a splice?
09:55:09 <amalloy> solonarv_: in fairness, pointer-to-pointer-to-struct is also a not-uncommon argument type, and that already was a pointer
09:55:11 <c_wraith> you're already working in Q
09:55:28 <c_wraith> you can just bind its results and use them
09:55:37 <svipal80> cause it doesn't work ~
09:55:57 <svipal80> I get " ‘MidiInputNode’ is not in scope at a reify "
09:55:59 <solonarv_> amalloy: ah yes, but that is done so you can malloc() space for the struct and then write the pointer to the newly allocated struct into the ptr-to-ptr-to-struct
09:56:02 <solonarv_> right?
09:56:22 <solonarv_> and again, if structs were already pointers you would only need a *struct for this, not a **struct!
09:56:24 <svipal80> that's why I said I felt that it was somehow making the lens declaration before the data dec
09:56:51 <svipal80> if I remove the lens dec from the function, it works fine , so I know it 's causing that error message
09:56:55 <svipal80> that, and the traces
09:57:11 <solonarv_> perhaps there is a variant of makeLenses to which you can just pass a DataD so it does not have to call reify ?
09:57:24 <svipal80> hmmm
09:58:39 <svipal80> that's a really good idea actually. 
09:58:56 <svipal80> Thank you 
09:59:32 <amalloy> solonarv_: i'm just saying, you can't conclude "struct foo must not be a pointer because people create pointers to it"
09:59:37 <svipal80> and thanks c_wraith for looking into my awful code as well
10:00:01 <amalloy> indeed you are right that it is not a pointer, but since you were saying svipal80 could have guessed i thought i'd point this out
10:00:14 <c_wraith> good luck getting this figured out. :)
10:00:19 <amalloy> er, no, saying jinna could have guessed
10:00:54 <svipal80> right, I was confused
10:01:21 * hackage niv 0.2.8 - Easy dependency management for Nix projects  https://hackage.haskell.org/package/niv-0.2.8 (nmattia)
10:03:15 <voyons_osti> <heatsink> You could make some of the parsers generic in the state and use a typeclass to project out the part that they need
10:03:24 <voyons_osti> ^ how could this work? i'm not sure i understand
10:05:24 <flexv> I'm looking for an old haskell library: "futility-0.1.8.tar.gz" from https://web.archive.org/web/20060709041652/http://ofb.net:80/~frederik/futility/. Does anyone happen to have a copy? (Old announcement: https://mail.haskell.org/pipermail/haskell-cafe/2006-April/015396.html)
10:12:26 <svipal80> Is there a way to force the import of functions from modules that don't import the
10:12:40 <svipal80> besides dling and modifying the package locally
10:19:03 <amalloy> is there an article somewhere describing the operations in Control.Monad.Trans.Signatures? i understand what lift (from C.M.T.Class) does, but i don't know what is special about CallCC, Catch, Listen, and Pass
10:19:43 <ornxka> why has nobody fixed arithmetic in haskell yet
10:21:00 <ornxka> foldl (\a n -> a + ((floor (n / 3)) - 2)) 0 ns this gives a type error for example
10:21:07 <ornxka> for ns :: [Integer]
10:22:59 <zincy_> How do you marshal a Haskell Text value from a UUID postgres type with postgres-simple?
10:23:40 <lavalike> zincy_: in other contextes I would do value::text in the query to get the text out
10:24:31 <amalloy> ornxka: LGTM. the type system is making you improve your code by using `div` instead of combining `floor` and (/)
10:25:12 <zincy_> lavalike: Thanks!
10:26:38 <zincy_> lavalike: Do you happen to know how one would would marshal a join result to a tuple? Do you need to define a custom ADT or will the FromRow derivation figure it out?
10:28:34 <lavalike> zincy_: that one I don't know!
10:29:51 <zincy_> lavalike: No worries :)
10:37:01 <t7> is there a minimum function like this: (a -> b) -> [a] -> Maybe b
10:37:20 <t7> (a -> b) -> [a] -> Maybe a    sorry
10:37:42 <amalloy> t7: what's it supposed to do with the function? 
10:37:55 <t7> use it to sort
10:38:07 <dsal> @hoogle (a -> Ord) -> [a] -> Maybe a
10:38:09 <lambdabot> No results found
10:38:09 <t7> Ord b => ...
10:38:21 <dsal> @hoogle [a] -> Maybe a
10:38:23 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
10:38:23 <lambdabot> Test.Framework.Providers.API listToMaybeLast :: [a] -> Maybe a
10:38:23 <lambdabot> Distribution.Compat.Prelude.Internal listToMaybe :: () => [a] -> Maybe a
10:38:44 <dsal> lambdabot hoogle isn't the best hoogle
10:38:47 <amalloy> dsal: Ord isn't a type. do you mean Ordering?
10:38:54 <dsal> @hoogle (a -> Ordering) -> [a] -> Maybe a
10:38:55 <lambdabot> No results found
10:39:06 <dsal> Yeah, I get Ord and Ordering confused...
10:40:30 <dsal> @hackage listsafe
10:40:31 <lambdabot> http://hackage.haskell.org/package/listsafe
10:40:42 <dsal> ^ that has it.  It works with more than just Maybe
10:42:01 <dsal> ...except it uses throwM, which doesn't seem very useful.
10:43:21 <solonarv_> I am not sure if there is a ready-made funciton of that type
10:43:27 <solonarv_> I just wrote it myself
10:43:49 <dsal> λ> Data.List.Safe.minimum [] :: Maybe Int
10:43:49 <dsal> Nothing
10:44:05 <dsal> I guess I don't understand throwM...
10:48:35 <dsal> It also does this, which is nice:
10:48:37 <dsal> λ> Data.List.Safe.minimum [] :: Either SomeException Int
10:48:37 <dsal> Left EmptyListException
10:50:21 * hackage cache 0.1.3.0 - An in-memory key/value store with expiration support  https://hackage.haskell.org/package/cache-0.1.3.0 (hverr)
11:07:20 * hackage hinterface 1.0.0 - Haskell / Erlang interoperability library  https://hackage.haskell.org/package/hinterface-1.0.0 (SvenHeyll)
11:13:40 <dmwit> t7: http://hackage.haskell.org/package/safe-0.3.18/docs/Safe.html#v:minimumByMay
11:14:13 <dmwit> t7: The naming convention that folks seem to be using these days would call the one you asked for "minimumOnMay". The safe package doesn't have it, but I suspect would gladly accept a patch to add it.
11:16:15 * dmwit ponders the wisdom of `data ByFromOn a = ByFromOn a (a -> Ordering); instance Ord (ByFromOn a) where compare (ByFromOn _ f) (ByFromOn a _) = f a`
11:28:21 <heebo> hello does template haskell create caches anywhere?
11:31:12 <merijn> Why do you ask?
11:31:56 <heath> i'm running into a build error when attempting to build examples/haskell-miso.org in github.com/dmjio/miso https://gist.github.com/heath/76356c5bf7d3c519105db9369284c409
11:31:59 <heath> anyone have an idea on how I might attempt to resolve this issue?
11:36:26 <heebo> merijn: Im trying to compile some code using Frames and i keep on getting multiple declaration errors
11:36:53 <merijn> heebo: You can use -ddump-splices to get GHC to output the generated TH file so you can look at it
11:37:52 <heebo> thanks, so is that stack build -ddump-splices
11:40:43 <voyons_osti> ornxka, that's not really a typeerror. if that fails, it's because you haven't provided instances of RealFrac and Fractional for Integer
11:42:08 <merijn> heebo: It's a ghc option, so you need to give it to whatever option makes stack give it to ghc
11:43:06 <flexv> I'm trying to use Data.Matrix.Static: "fromList [1..9] :: Maybe(Matrix 3 3 Int)", but I get "*** Exception: <stdout>: hPutChar: invalid argument (invalid character)"
11:47:51 <flexv> seems to be a problem with winghci
11:53:51 * hackage smcdel 1.1.0 - Symbolic Model Checking for Dynamic Epistemic Logic  https://hackage.haskell.org/package/smcdel-1.1.0 (m4lvin)
12:16:17 <kevinsjoberg> I'm reading Get Programming with Haskell and in the end of Lesson 3 they demonstrate that the lambda counter will works while the let counter will not they fail to explain why though. See https://gist.github.com/KevinSjoberg/e8979bd64aea0cdd9f28ae02ed910e15.
12:16:43 <kevinsjoberg> Since the chapter clearly demonstrates you can use both let and a lambda for lexical scoping I'm a bit confused why the former function does not apply.
12:20:07 <m4lvin> kevinsjoberg: not sure, but the problem might be that in let x = ... in ... you can already use x in the first ...
12:20:43 <m4lvin> so "let x = x + 1 in x" is valid haskell but never terminates
12:21:02 <m4lvin> in contrast in a lambda function you cannot "selfreference" to the function you are defining
12:21:37 <m4lvin> at least that's how I understand the difference, someone else can probably explain this better
12:22:28 <kevinsjoberg> m4lvin: I'm still not following quite, I understand you're talking about self referencing the variable x causing a loop.
12:22:39 <m4lvin> yes
12:23:01 <kevinsjoberg> Where is the self-reference taking place, I'm clearly not seeing it right now. :P
12:23:08 <merijn> m4lvin: All three x's in his example are the same
12:23:17 <merijn> s/m4lvin/kevinsjoberg
12:23:44 <kevinsjoberg> merijn: Why, care to elaborate? I read it as x is x + 1 where x is x + 1 where x is the argument.
12:23:52 <merijn> kevinsjoberg: There is no assignment
12:24:02 <merijn> No argument either
12:24:07 <kevinsjoberg> Even more confused :P
12:24:14 <merijn> kevinsjoberg: Consider the following (somewhat more useful and simpler) example:
12:24:21 <merijn> > let ones = 1: ones in ones
12:24:24 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
12:25:05 <merijn> kevinsjoberg: You're defining ones to be the list starting with '1', followed by itself
12:25:19 <merijn> kevinsjoberg: So you end up with an infinitely recurring list of 1s
12:25:23 <kevinsjoberg> I just began learning haskell, is that an inline expression? what does `ones in ones` do? Sorry for asking all these questions, just trying to wrap my head around it.
12:25:42 <merijn> The "x = x + 1" is the same, with the only difference that the infinite recursion doesn't produce anything useful
12:25:52 <statusfailed> kevinsjoberg: it's let <variable> = <expression> in <other expression>
12:26:05 <merijn> kevinsjoberg: It's 'let { ones = 1 : ones } in { ones }'
12:26:06 <statusfailed> e.g., let x = 1 in x + 1 
12:26:11 <statusfailed> ^^^
12:26:43 <merijn> kevinsjoberg: So we define a variable ones (recursively), using itself, and then "return" the variable we just defined
12:26:43 <solonarv_> let { a bunch of local definitions } in { use these local definitions here }
12:27:22 <kevinsjoberg> I really must be tired. Because I'm still not seeing it. In a example earlier in the book we redefined x using let multiple times, the difference was that we gave it a different value every time without referencing x.
12:27:26 <merijn> kevinsjoberg: Do you know C?
12:27:34 <kevinsjoberg> So I understand that let x = x + 1 is the culprit.
12:27:39 <kevinsjoberg> merijn: a bit, yes.
12:27:53 <merijn> kevinsjoberg: Ok, so my ones example would be somewhat comparable to this
12:28:23 <m4lvin> (was the example earlier in the book using "let x = ..." without "in" maybe?)
12:28:27 <merijn> "struct int_list { int val; struct int_list *next; }; struct int_list foo = { 1, &foo };"
12:29:14 <merijn> kevinsjoberg: You see/get how that 'foo' list is effectively an infinite linked list of ones?
12:29:30 <merijn> kevinsjoberg: Since every time you dereference the "next" pointer, you just end up back at 'foo'
12:30:12 <merijn> "let ones = 1 : ones" is rather similar, we define 'ones' to be self-referential (i.e. the tail of our list just points back at itself)
12:32:46 <kevinsjoberg> merijn: The previous example was https://gist.github.com/KevinSjoberg/da4f265d216314748eb397a102441c19
12:33:05 <kevinsjoberg> As I mentioned, I can see why this work since we never reference x after =.
12:35:21 <merijn> kevinsjoberg: Those two x's shadow eachother, i.e. you're just defining a new x (similar to say "int x; void foo(int x) {}" where the function parameter hides the outer 'x' in the function body of foo
12:35:43 <kevinsjoberg> merijn: I think I get it now. The `x` in `x + 1` references the expression `x = x + 1` causing it just to reference itself over and over?
12:35:56 <merijn> kevinsjoberg: Correct
12:36:07 <kevinsjoberg> Wow, now it clicked.
12:36:10 <kevinsjoberg> What a feeling. :)
12:36:21 <kevinsjoberg> I guess, that's enough Haskell for today.
12:36:35 <zincy_> kevinsjoberg: :)
12:36:38 <kevinsjoberg> Thanks a lot for all the help merijn. Appreciate it. :)
12:36:41 <merijn> kevinsjoberg: We can blow your mind a bit further to close the day ;)
12:36:47 <kevinsjoberg> And everyone else who helped out.
12:36:58 <merijn> > let fibs = 0 : 1: zipWith (+) fibs (tail fibs) in fibs
12:37:00 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
12:37:24 <zincy_> nice
12:37:31 <kevinsjoberg> Haha. I'm not going to even try to disassemble that.
12:38:05 <m4lvin> ;-)
12:38:08 <merijn> kevinsjoberg: You got all the pieces you need, it's like the ones example, except referencing itself twice :)
12:38:09 <kevinsjoberg> Well, now I have to. This is my take coming from Ruby.
12:38:10 <int-e> that one is fairly straightforward
12:38:32 <merijn> (tail is just "drop 1" i.e., skip the first element
12:38:37 <int-e> > fix ((0:) . scanl (+) 1) -- compare to this
12:38:37 <kevinsjoberg> zipWith adds two numbers from the list together I guess?
12:38:39 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
12:39:17 <int-e> > zipWith (+) [1,2,3] [30,20,10]
12:39:20 <lambdabot>  [31,22,13]
12:39:20 <merijn> kevinsjoberg: zip fuses two lists into a list of tuples, zipWith replace the "to tuple" bit with an arbitrary binary function
12:39:35 <kevinsjoberg> I see, that actually makes sense.
12:39:59 <merijn> kevinsjoberg: So you just zip the list with itself offset by one
12:40:11 <kevinsjoberg> Yeah, that's damn neat to be honest.
12:40:24 <int-e> > zipWith (+) [0,1,1,2,3] [1,1,2,3,5]
12:40:30 <lambdabot>  mueval-core: Time limit exceeded
12:40:35 <int-e> > zipWith (+) [0,1,1,2,3] [1,1,2,3,5]
12:40:39 <lambdabot>  [1,2,3,5,8]
12:40:42 <merijn> lambdabot is a bit laggy today for some reason
12:41:06 <hyiltiz> hello all
12:41:15 <zincy_> hyiltiz: Hi
12:41:48 <kevinsjoberg> Alright, time to get some sleep before my 2 year old wakes up. Goal is to do two chapters per day. So more questions inc tomorrow.
12:41:55 <kevinsjoberg> Thanks again, bye! :)
12:42:41 <boxscape> % foreign import ccall "exp" c_exp :: Double -> Double
12:42:41 <yahb> boxscape: 
12:42:44 <boxscape> % 1
12:42:44 <yahb> boxscape: 1
12:42:46 <boxscape> huh
12:42:49 <boxscape> oh wait
12:42:51 <boxscape> % c_exp 1
12:42:51 <yahb> boxscape: 2.718281828459045
12:43:00 <boxscape> I just typed this into ghci and was actually really surprised when it worked
12:43:06 <boxscape> I expected you would have to p
12:43:12 <boxscape> specify* some C libary or whatever for the linker
12:43:14 <xkcd14> If you have a list of pairs "Eq a => [(a, Integer)]", is there any efficient way to remove duplicates (duplicate if fst equal), taking the element with the highest snd?
12:45:14 <boxscape> xkcd14 sort by fst, and by snd if fsts are equal, then use head . groupBy fst 
12:45:17 <boxscape> I think that should work?
12:45:50 <boxscape> uh not quite `groupBy fst` but something similar, groupBy expects an equivalence relation as argument
12:46:12 <boxscape> and `map head` instead of `head`
12:46:51 <boxscape> :t groupBy ((==) `on` fst)
12:46:53 <lambdabot> Eq a => [(a, b)] -> [[(a, b)]]
12:51:34 <boxscape> not actually sure if there's standard library functions that allow you to elegantly sort by two different criteria
12:53:35 <amalloy> boxscape: you mean, sort by f, and if f x == f y, then secondarily sort by g?
12:53:41 <boxscape> yes
12:54:26 <amalloy> Ordering is a Monoid, so you can combine two ordering functions to yield a new ordering function that uses the first non-Equal item
12:54:26 <solonarv_> ...but that's already how the Ord instance for tuples works?
12:54:38 <boxscape> oh, both of those are pretty good poitns
12:55:20 <boxscape> the actual problem here is that I thought I was remembering seeing a solution at some point but then realized what I had been thinking of was Java's Comparator, so I was only looking for solutions similar to that :D
12:55:39 <dmwit> :t M.fromListWith max
12:55:42 <lambdabot> (Ord k, Ord a) => [(k, a)] -> M.Map k a
12:55:45 <dmwit> xkcd14: ^
12:57:00 <amalloy> :t comparing length <> comparing sum
12:57:01 <dmwit> If you need to remember the order that "keys" occurred in, you could use the ordered-containers package's equivalent.
12:57:02 <lambdabot> (Foldable t, Ord a, Num a) => t a -> t a -> Ordering
12:58:11 <amalloy> > sortBy (comparing length <> comparing sum) [[9], [1,2,3], [4,5,6], [0]]
12:58:14 <lambdabot>  [[0],[9],[1,2,3],[4,5,6]]
12:59:17 <boxscape> dmwit that's O(n*log n) also, right?
12:59:36 * dmwit nods
12:59:48 <boxscape> ok
13:03:00 <zincy_> Can anyone shed light on what this postgres-simple error means?
13:03:01 <zincy_> Incompatible {errSQLType = "record", errSQLTableOid = Nothing, errSQLField = "row", errHaskellType = "Text", errMessage = "types incompatible"}
13:03:53 <zincy_> Does that mean a SQL Record has fields which are Rows? I am confused
13:04:17 <amalloy> as someone who knows nothing about postgres-simple, to me it sounds like you have an entire row, and are trying to convert that to Text
13:04:29 <amalloy> where you probably meant to convert only a single column of that row
13:05:31 <sleblanc> Jinna, I'm a bit of a C expert and solonarv_ is right, although it is extremely common to pass structs by pointer instead of pushing on the stack, as structs of significant size can quickly fill up a stack
13:05:32 <zincy_> hmm thanks
13:05:51 <zincy_> Perhaps because I am returning many rows I need to marshall it myself into a list
13:11:02 <EvanR> zincy_: a row is like a record. To get a single Text you probably have to also choose a field
13:11:21 <EvanR> even if your result only has 1 column
13:12:14 <zincy_> Evan: I have a product type and the table has multiple fields
13:12:35 <zincy_> Most of the data constructors are of type Text
13:12:49 <EvanR> good
13:13:17 <EvanR> perhaps you were trying to convert the row into a haskell record of text fields?
13:13:37 <svipal> is there any way I can make my names non garbled in the end using the [d| funcName = {-stuff-}|] syntax in TH ?
13:13:38 <EvanR> screw it, just pastebin some code
13:14:14 <svipal> to really have funcName and not funcName_s3ndH3lP  
13:18:11 <hyperisco> There was an article somewhere about implementing other moands with ContT. Anyone know where that is?
13:18:24 <zincy_> https://pastebin.com/GVafn8fA
13:19:15 <svipal> solonarv_ : making a version of makeFieldOptics that directly receives a datatypeinfo instead of reifying worked
13:19:27 <svipal> for my previous issue
13:19:28 <amalloy> hyperisco: there've probably been loads of such articles, but the one i think of when i hear that is https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/the-mother-of-all-monads
13:20:29 <hyperisco> amalloy, ah thanks! Lost it in my bookmarks. Was searching for "one monad to rule them all" for some reason
13:23:27 <nshepperd1> And in the continuation bind them...
13:23:35 <solonarv_> svipal: oh, great!
13:23:40 <EvanR> zincy_: well what is throwing the error
13:23:59 <zincy_> EvanR: A runtime error with the query
13:24:20 <zincy_> Incompatible {errSQLType = "record", errSQLTableOid = Nothing, errSQLField = "row", errHaskellType = "Text", errMessage = "types incompatible"}
13:29:08 <zincy_> EvanR: Ahh SQL doesn't like parenthesis around the columns in the query
13:29:14 <zincy_> silly me
13:29:45 <dsal> It doesn't seem to mind it, it just seems that it means something else.  That's kind of neat.
13:31:05 <zincy_> dsal: Yes
13:38:11 <EvanR> yeesh
13:38:31 <EvanR> parentheses for grouping terms and or "doing stuff"
13:44:06 <koz_> I have a winmain.c with a WinMain function as an entry point. I want it to call a Haskell main :: IO (). I can't seem to find out how to do this, nor any documentation explaining this in detail. Could someone direct me to some appropriate literature?
13:44:50 * hackage stack2cabal 1.0.5 - Convert stack projects to cabal.project + cabal.project.freeze  https://hackage.haskell.org/package/stack2cabal-1.0.5 (tseenshe)
13:45:51 * hackage brittany 0.12.1.1 - Haskell source code formatter  https://hackage.haskell.org/package/brittany-0.12.1.1 (lspitzner)
13:46:38 <koz_> This is what I have so far, based on what I could cobble together: https://gist.github.com/kozross/86953b73f2134474c7611ca06e08dde8
13:47:57 <dsal> PASCAL 
13:48:22 <koz_> dsal: I have no idea what I'm doing here - this is me cargo-culting the various examples I've found, some of which are quite old.
13:48:35 <koz_> I am more than happy to learn, but I can't even find anything explaining any of this.
13:48:37 <dsal> I assume it means pascal calling conventions.
13:48:49 <koz_> The only example I can find involves calling a _non_-main function.
13:49:00 <koz_> From a standard int main (...) entrypoint.
13:50:03 <monochrom> Yeah Windows API uses the pascal calling convention, you have to declare it at every C function.
13:50:19 <jpcooper> Is there a global ordering over types in Haskell?
13:50:29 <monochrom> No.
13:50:43 <monochrom> Or yes but the discrete degenerate order.
13:50:52 <jpcooper> In other words, does a type family exist which maps types to (o :: Ordering)?
13:50:59 <geekosaur> I think you need to foreign export main as something like hsMain, so you can invoke it
13:51:01 <monochrom> No.
13:51:02 <jpcooper> Okay
13:51:24 <amalloy> monochrom: now i'm excited to hear what the discrete degenerate order is
13:51:43 <jpcooper> Can I get a symbol from a type?
13:51:44 <koz_> geekosaur: OK, that much I can try.
13:51:47 <monochrom> The trivial partial order that simply says "no one is less than anyone"
13:51:52 <jpcooper> These types are actually Typeable
13:51:57 <amalloy> oh, for a partial order, sure
13:52:22 <monochrom> I am evil and facetious :)
13:52:25 <geekosaur> %% :i TypeRep
13:52:25 <yahb> geekosaur: http://qp.mniip.com/y/24
13:52:54 <geekosaur> well, that was helpful :/
13:52:58 <jpcooper> Data.Type.Set in type-level-sets defines a Cmp t u :: Ordering type family. I would like to define Cmp generally over all Typeable types
13:53:11 <geekosaur> % import Data.Typeable
13:53:12 <yahb> geekosaur: 
13:53:19 <geekosaur> %% :i TypeRep
13:53:19 <yahb> geekosaur: http://qp.mniip.com/y/25
13:53:46 <koz_> geekosaur: How do I then call this from winmain.c?
13:53:52 <geekosaur> this is going out of its way to be "helpful". I think there might be Ordering for TypeRep
13:54:14 <geekosaur> koz_, same way you'd call a non-main function.
13:54:38 <jpcooper> That would be nice
13:54:49 <geekosaur> I think there's an internal API ghc normally uses for this, which you can't rely on
13:57:51 <jpcooper> geekosaur: Nothing GHC.Generics might provide?
13:58:25 <monochrom> Do you have a type-level set too?
13:58:40 <monochrom> Or are you doing type-level sorting?
14:00:14 <jpcooper> type-level sorting will happen when I define the Cmp instances for the types in question
14:00:19 <koz_> geekosaur: OK, I've added winmain.c to c-sources, but when I cabal new-build, it seems to completely ignore it.
14:00:24 <monochrom> SomeTypeRep is an Ord instance.
14:00:38 <koz_> Is it because I have a main-is? Can I even have an executable stanza without a main-is?
14:00:54 <geekosaur> that I can't help with, especially on windows
14:00:59 <monochrom> Also you can import it from Type.Reflection
14:01:10 <koz_> Phyx-: ^
14:01:18 <koz_> (this is my 'halp I'm on Windows' signal :P)
14:01:28 <koz_> But thanks anyway.
14:01:38 <jpcooper> monochrom: I need the ordering as a type, though
14:02:32 <boxscape> % instance Eq Type where
14:02:33 <yahb> boxscape: ; <interactive>:29:10: warning: [-Wmissing-methods]; * No explicit implementation for; either `==' or `/='; * In the instance declaration for `Eq *'
14:02:38 <boxscape> :^)
14:03:05 <boxscape> (just a warning :)
14:05:43 <EvanR> use axiom of choice to get a well ordering of Type
14:06:01 <monochrom> But GHC doesn't have axiom of choice.
14:06:22 <EvanR> also name this flavor of incompatibility error
14:06:37 <EvanR> this incompatibility
14:06:48 <EvanR> axiom of choice has nothing to do with Type, whatever it is
14:07:03 <boxscape> Universe error? In a sound language Type and the type of Type would be in different universes, or something similar
14:07:37 <EvanR> i guess with sufficient preambles everything is a type error
14:07:54 <monochrom> This is why I don't understand the question.
14:08:55 <EvanR> also is it impossible for ghc to have an axiom of choice
14:08:59 <jpcooper> Do you really need axiom of choice? The number of types must be finite in any programme. Also, types are defined by strings, on which there is an ordering
14:09:05 <EvanR> or is it just egregious
14:09:22 <EvanR> is the number of types really finite
14:09:32 <EvanR> haskell has an open world assumption
14:09:38 <jpcooper> Yes, as the memory on which any programme runs is finite
14:09:55 <jpcooper> Haskell runs only finite programmes
14:09:55 <EvanR> types don't even exist at runtime
14:10:01 <monochrom> No, statically you can use polymorphic recursion to get an unbouneded number of types.
14:10:36 <monochrom> Dynamically you can only claim that after a finite run time you have run into only a finite number of types.
14:10:47 <jpcooper> As far as I understand, at compile-time there must be a finite number of types
14:10:58 <jpcooper> Unless we live in separate dimensions
14:11:05 <EvanR> you can use finite number of types in a module, and someone is expecting to use your module with any number of their modules
14:11:11 <monochrom> We live in separate dimensions.
14:11:17 <koz_> Phyx-: Sorry, ignore that - I seem to have figured out how to do this, or at least the issue I was experiencing no longer bites.
14:11:20 <jpcooper> Well at least that is settled
14:11:57 <EvanR> the only runtime relevant thing i can see here is whether your ordering on types is consistent when people import your module into theirs
14:12:25 <jpcooper> Anyway, type in type is about Russell's Paradox specifically
14:12:49 * EvanR gets lost back at the non sequiter
14:13:17 <monochrom> Well you started it.
14:13:40 <EvanR> i guess. regretting it all!
14:14:12 <jpcooper> TH it is
14:15:10 <boxscape>  % instance Eq Type where {(==) = const (const True)}; instance Ord Type where compare = const (const EQ)
14:15:18 <boxscape> % instance Eq Type where {(==) = const (const True)}; instance Ord Type where compare = const (const EQ)
14:15:18 <yahb> boxscape: 
14:15:21 <boxscape> perfect
14:15:57 <jpcooper> Well, that was vacuous
14:16:10 <boxscape> the only value you could apply these functions to is bottom, anyway
14:16:20 <boxscape> and I'm not sure what the theory says but arguably bottom is equal to bottom
14:16:23 <EvanR> % compare Char Int
14:16:23 <yahb> EvanR: ; <interactive>:31:9: error:; * Data constructor not in scope: Char :: (); * Perhaps you meant one of these: `Chars' (imported from Data.ByteString.Lens), `Chr' (imported from Text.PrettyPrint.HughesPJ), variable `char' (imported from Text.PrettyPrint.HughesPJ); <interactive>:31:14: error:; * Data constructor not in scope: Int :: (); * Perhaps you meant variable `int' (imported from Tex
14:16:43 <boxscape> % compare (undefined :: *) (undefined :: *)
14:16:43 <yahb> boxscape: EQ
14:16:47 <jpcooper> boxscape: I would say the "bottom is equal to bottom" is not a valid sentence
14:17:12 <boxscape> well, with my Ord instance they are equal, evidently
14:17:13 <EvanR> this sentence is invalid
14:17:28 <geekosaur> today is the day of eyerolls, apparently
14:17:29 <monochrom> All is vanity.
14:17:58 <koz_> Phyx-: Nope, still doesn't work - I still get that console argh.
14:18:29 <EvanR> i'm still curious about the practicality of it
14:18:43 <boxscape> I don't think it's practical until we can refer to Types on the value level
14:19:02 <boxscape> (and have ghc not complain about it)
14:19:12 <jpcooper> Agda it is
14:19:27 <EvanR> that's won't be confusing to haskell novices at all!
14:20:56 <EvanR> it took a long time for me to understand lisp because there was a lack of precise language to talk about the concepts, at least on IRC. Haskell might end up like this when you combine the current lack of type level language with dependent types
14:21:09 <jpcooper> http://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-TypeLits.html. Symbol has a nice ordering. Give me something which takes a type and gives a symbol
14:21:54 <geekosaur> "takes a type" isn't currently thing unless you accept either a value of that type or a Proxy for it
14:22:17 <boxscape> geekosaur I think that's talking about type families
14:22:22 <jpcooper> geekosaur: This thing would be a type family
14:26:27 <jpcooper> http://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-Generics.html#v:MetaData smells quite good
14:27:18 <jpcooper> derive Generic and then get the symbol associated to the data type's name from the MetaData
14:31:38 <jpcooper> Actually I'm still not sure how to use this in a type family. Oh well
14:52:56 <lyxia> jpcooper: like this? https://hackage.haskell.org/package/generic-data-0.7.0.0/docs/Generic-Data.html#t:MetaDataName
14:55:13 <jpcooper> lyxia: Actually I think I need to define an ordering over (t :: Metadata ...). The Metadata can be obtained from the associated Rep type of any instance of Generic, but I'm not sure how to define a general type family over that
15:07:15 <jpcooper> I'll get me coat
15:07:51 * hackage downloader 0.1.0.0 - A small, low-dependency library that provides turn-key file download over HTTP and HTTPS.  https://hackage.haskell.org/package/downloader-0.1.0.0 (deech)
15:14:49 <phadej> jpcooper left :( https://gist.github.com/phadej/564059cffb136413bab75b0735e02a37
15:17:52 <boxscape> send him a lambdabot message
15:22:04 <phadej> not worth it
15:56:50 * hackage inline-c-cpp 0.4.0.1 - Lets you embed C++ code into Haskell.  https://hackage.haskell.org/package/inline-c-cpp-0.4.0.1 (FrancescoMazzoli)
16:43:20 * hackage bits-extra 0.0.1.5 - Useful bitwise operations  https://hackage.haskell.org/package/bits-extra-0.0.1.5 (haskellworks)
16:50:16 <ontop> I'm looking for a way to run ghci, and when code changes, to have it automatically :reload, is this possible? I looked around and can't find anything. ghcid seems much more like ghcd only giving errors/warnings afaict.
17:04:29 <jared-w> ontop: you'd want ghci to keep any state when you :reloaded right?
17:04:44 <ontop> Nope. Just the list of loaded modules. Same as when I type :reload
17:04:47 <ontop> All previous bindings could be lost.
17:05:00 <ontop> I literally just don't want to type :r after saving my code
17:05:00 <ontop> lmao.
17:05:10 <jared-w> You could do this in a super hacky fashion with a combination of xdotool and some file monitoring thing
17:05:31 <ontop> I'm currently looking if it's possible to write to the tty in some way
17:05:31 <ontop> :p
17:05:40 <jared-w> that's what xdotool can do :p
17:05:58 <ontop> Hm. That's probably good enough honestly.
17:06:30 <jared-w> https://www.semicomplete.com/projects/xdotool/
17:06:51 <ontop> Would be a bit nicer if it wasn't dependent on windowing mind you.
17:07:01 <jared-w> use something like `entr` or `watchman` to trigger a thing on file-change-in-directory and xdotool "select ghci && type in :r<CR>"
17:07:14 <ontop> Ya
17:07:23 <jared-w> ah do you want to run this sorta thing without X entirely?
17:07:29 <ontop> Would be easier/nicer yea.
17:07:55 <jared-w> In that case, just use entr/watchman to murder your current ghci session and respawn it :p
17:08:06 <ontop> I thought about that. It's okay but it's much slower than :r
17:08:25 <ontop> I appreciate all the suggestions mind you. Thank you :)
17:08:39 <jared-w> If GHCi could be programmed to interpret a HUP as :r that would also solve it, because you could send a HUP without actually killing the process
17:08:52 <ontop> Yea.
17:09:03 <ontop> I'm actually sort of shocked this isn't a solved problem directly in GHCI
17:09:29 <ontop> You'd think some lisp-developer-turned-haskell SOMEWHERE would have done this already.
17:10:02 <phadej> watching file-system is "not easy problem" to solve in platform independent way
17:10:33 <ontop> phadej: Receiving a signal isn't too bad cross-platform though.
17:10:52 <nxtooq> I like to say these following words: 1.tit balls 2.penis nipples 3.doodie poopy 4.pickleweasle 5.testicle poop 6.shit whore 7.shitless tit 8.penis shrimp 9.loomis 10.super weiner discharge
17:12:19 <phadej> ontop: that's true, HUP as :r sounds like a good idea 
17:12:44 <pie_> im having trouble remembering a concept
17:12:53 <ontop> If I had any ability in this language whatsoever I'd implement it as a hack lol.
17:12:58 <pie_> i think there was a name for a data structure involving a list of diffs or something like that
17:13:17 <pie_> and youd consider the current state as the sum of all diffs up to the current time
17:13:43 <hpc> zipper, maybe?
17:13:55 <jared-w> My bet is on a scanl
17:13:59 <phadej> yet, SIGHUP has a valid meaning for terminal apps, so there's argument to not abuse it
17:14:02 <wuwwew> excuse me, but i politely ask you to cease your torpid attempts at manifesting versimilitude through your crude preferences of internet lexicon. My comprehension of the english language is brobdingnagian, effortlessly micrifying your picayune and odious disposition, of which has already saturated me with a pullulating impression of ennui coupled with execration. good day.
17:14:03 <pie_> these arent in the right vein
17:15:04 <jared-w> Do you have an example?
17:15:07 <pie_> it might have had something to do with databases
17:15:22 <pie_> no i dont, im trying to pull this out of the depths of my brain-index
17:15:29 <pie_> 'x)
17:15:57 <hpc> like a journal?
17:16:09 <jared-w> event sourcing?
17:16:14 <pie_> jared-w: yes!
17:16:39 <pie_> weird name
17:17:16 <jared-w> comes from the common implementation. You send a stream of events into an append only DB and then you source the events to load up the memory
17:17:51 <pie_> aha
17:18:49 <pie_> for some reason CRUD popped into my head but i think i miht have been thinking of CQRS
17:19:08 <pie_> but thats just a side thing
17:19:41 <jared-w> lots of people use event sourcing to implement CRUD style apps, so that might be it?
17:21:43 <hpc> oh huh, that's the term for it
17:21:53 <hpc> when you combine it with a regular database you get journaling
17:23:32 <ontop> phadej: Hm. Perhaps there's a different signal we could use. Or -something- :D
17:27:15 <hpc> signal(7) mentions sigpoll/sigio which seems the most relevant
17:27:46 <ontop> My mind is gonna be blown if I try to look at the ghci source isn't it?
17:28:18 <hpc> i don't know what it normally is meant to use, but it also says some linuxes ignore it, hmm
17:30:39 <EvanR> wuwwew really pissed me off with that one
17:30:50 <EvanR> they better take it back
17:30:55 * ontop has his mind blown
17:30:56 <ontop> WHy did I look
17:30:58 <ontop> Oh god why
17:31:22 <EvanR> is it really that bad
17:31:29 <EvanR> would explain why it still doesn't have color
17:32:10 <ontop> No, I just suck at haskell.
17:32:17 <jared-w> lol
17:32:56 <EvanR> reading haskell source code is one of the ways i learned haskell. I found it surprisingly effective
17:33:18 <jared-w> https://github.com/ghc/ghc/blob/master/ghc/GHCi/UI.hs that's not monolithic at all
17:34:05 <EvanR> 4143 lines not bad. Probably not ready to be broken up
17:34:58 <EvanR> actually this might be the missing ghci manual i was looking for
17:41:06 <jared-w> It's honestly pretty clean. Looks like the simplest possible printing it could possibly be without being useless, which would explain the inability to support color or anything like that
17:43:58 <EvanR> it seems they used granular monad constraints
17:44:30 <EvanR> interesting
17:44:53 <EvanR> some of the utility functions work in any monad, crazy
18:10:24 <bl4ckb0ne> i dont get that kind of message     • Couldn't match expected type ‘(IO a6, b0)’
18:10:26 <bl4ckb0ne>                   with actual type ‘[(Int, Int)]’
18:11:06 <bl4ckb0ne> why does it have this IO qualifier?
18:16:29 <glguy> bl4ckb0ne: Because you put something with type IO in the first element of the tuple
18:16:34 <glguy> or didn't
18:16:57 <glguy> bl4ckb0ne: Do you have some code to put on a pastebin?
18:17:50 <bl4ckb0ne> yes hold on
18:18:51 <bl4ckb0ne> https://pastebin.com/yLSCbpSx
18:18:57 <bl4ckb0ne> im working on the advent of code challenge
18:19:18 <glguy> aren't we all :)
18:21:01 <bl4ckb0ne> i thought it would be a good opportunity to reuse haskell
18:21:04 <bl4ckb0ne> but im hecking lost
18:21:08 <glguy> blackbart: IOArrays use IO to read and write to arrays
18:21:20 <glguy> so any definition using read or writeArray will have IO in the type
18:21:32 <bl4ckb0ne> ive been told my code is very imperative-style
18:21:35 <glguy> For example: compute :: [Int] -> Int -> Int -> Bool  would be   compute :: [Int] -> Int -> Int -> IO Bool
18:21:51 <bl4ckb0ne> what is this IO thingy?
18:21:56 <glguy>  let opcodes = newListArray (0, length input) input    would be:  opcodes <- newListArray (0, length input) input
18:22:15 <glguy> If you haven't encountered IO yet you'll want to refer back to whatever tutorial or book you're using to learn Haskell
18:22:25 <glguy> it's a big topic at this point
18:22:34 <bl4ckb0ne> what's the diff between `let x = thing` vs `x <- thing
18:22:45 <bl4ckb0ne> im reading learn you a haskell
18:23:23 <bl4ckb0ne> im two chapiters away from IO
18:26:28 <pavonia> Loosely speaking, "x <- thing" executes "thing" and binds the result to "x"
18:44:02 <bl4ckb0ne> is this also about IO stuff? `Couldn't match expected type ‘m1 Int’ with actual type ‘Int’`
18:44:47 <amalloy> bl4ckb0ne: you might also stay away from arrays while you're still getting used to the language. their types are kinda complicated compared to, say, maps
18:45:06 <bl4ckb0ne> is this kind of problem solvable without arrays?
18:45:16 <bl4ckb0ne> the values inside of the list has to mutate
18:45:29 <amalloy> nothing really ever has to mutate
18:45:52 <bl4ckb0ne> i could copy into a new one with the modified value yes
18:45:57 <bl4ckb0ne> the array isnt really big
18:46:11 <amalloy> right, and maps do that efficiently (log(n) update time)
18:46:29 <amalloy> not as good as constant update time, but pretty reasonable
18:49:14 <amalloy> anyway, yes, that error message is complaining that you're trying to use do notation in a context that returns an Int, while it's only valid in a context returning some IO value
18:49:28 <amalloy> which is probably because you are trying to mutate your array
18:50:41 <bl4ckb0ne> yeah
18:50:57 <bl4ckb0ne> i kinda got lucky an managed to get part 1
18:51:12 <bl4ckb0ne> i dont want to redo the whole solution for part 2
19:01:05 <ontop> bl4ckb0ne: Which problem are you on?
19:02:10 <bl4ckb0ne> day 2 part 2
19:02:29 <bl4ckb0ne> https://github.com/Bl4ckb0ne/advent-of-code-2019/blob/master/day2/part1.hs
19:02:33 <ontop> Ah yes. I had to use arrays for that as well.
19:02:45 <ontop> Oh wow.
19:02:50 * hackage rainbox 0.24.4.0 - Two-dimensional box pretty printing, with colors  https://hackage.haskell.org/package/rainbox-0.24.4.0 (OmariNorman)
19:03:08 <ontop> This is very different to what I did :D
19:03:19 <ontop> Can I give you a small hint to make it easier?
19:03:29 <ontop> (Haskell related, not problem related)
19:03:54 <bl4ckb0ne> yes!
19:03:59 <ontop> I used this in my solution.
19:03:59 <ontop> https://hackage.haskell.org/package/array-0.5.4.0/docs/Data-Array.html
19:04:06 <ontop> This lets me get away from the IO monad completely
19:04:12 <ontop> And write my solution entirely in pure functions
19:04:23 <ontop> Which to me makes it much easier to deal with.
19:04:37 <ontop> It's not nearly as efficient, but it doesn't need to be. The inputs for these are not that big.
19:07:12 <ontop> Syntax was a bit strange at first but it worked really well for that exact problem you're doing :)
19:08:49 <bl4ckb0ne> ouh nice
19:09:01 <bl4ckb0ne> yeah this IO monad is 50% of my problem
19:09:52 <ontop> bl4ckb0ne: Hopefully that helps. Another tip is for my programs my main is generally one very short: contents <- readFile; callAPureFunction
19:10:00 <ontop> And the IO monad is gone for basically 100% of the code
19:10:04 <ammar2> bl4ckb0ne: I would suggest staying away from IO to begin with. Write out a solution to the problem with pure functions first
19:10:18 <ammar2> bl4ckb0ne: test it out, and then just read the file and pass it through
19:10:25 <ontop> callAPureFunction contents**
19:11:07 <bl4ckb0ne> yeah, i think i over did it
19:11:26 <ontop> jared-w: I managed to use Go to create a pty and be the proxy between "stack ghci" and the pty. All user input to the pty goes through the go program to ghci, which means I get to man in the middle it and inject :reload whenever I want!!!!
19:11:27 <bl4ckb0ne> so your main doesnt have the IO() type?
19:11:43 <ontop> bl4ckb0ne: I'm saying my main is the only thing in the code that does, and it's 2 lines long.
19:11:55 <ontop> Main immediately calls a pure function after it's read the file
19:12:01 <ontop> And all the problem solving is done there.
19:12:09 <ontop> In the pure functions (without IO)
19:12:34 <ontop> I can show you an example if you like
19:12:54 <ontop> Though it's fairly straightforward what I'm saying I think, and the example will be underwhelming :D
19:14:00 <harisamin> Hi there
19:14:28 <harisamin> anyone around?
19:15:28 <bl4ckb0ne> ontop: you used IArray or MArray?
19:15:57 <ontop> bl4ckb0ne: Neither. Data.Array (Array)
19:16:14 <ontop> IArray is supposed to be what I used but better in some way
19:16:18 <ontop> But it was giving me trouble for some reason.
19:16:35 <bl4ckb0ne> I dont get what I should import
19:17:14 <ontop> Data.Array or Data.Array.IArray - either should work but I used the first one.
19:17:36 <bl4ckb0ne> ah I missed Data.Ix
19:17:46 <bl4ckb0ne> its late and I skip reading parts
19:17:51 <ontop> > Since most array functions involve the class Ix, this module is exported from Data.Array so that modules need not import both Data.Array and Data.Ix.
19:17:53 <lambdabot>  <hint>:1:40: error: parse error on input ‘class’
19:17:56 <ontop> This is in the docs for Data.Array
19:18:15 <ontop> So I don't think you need Data.Ix imported explicitly
19:18:19 <ontop> I didn't use it anyway.
19:18:20 <amalloy> ontop: you might also enjoy the `interact` function. main = interact $ show . solve is a reasonable template for advent of code, if you use shell redirection to read your input instead of doing it with readFile
19:18:53 <ontop> amalloy: Aware of it. But I prefer to just have a main that reads all the input files, and outputs all the answers so I can run it easily without a make file or something to redir.
19:18:58 <ontop> Thanks for the suggestion anyhow.
19:19:14 <ontop> This might fall apart if any of them start to get slow
19:19:17 <ontop> But it's great for now :D
19:19:51 <ontop> God I'm so psyched about my auto :reload ghci program :D
19:20:54 <bl4ckb0ne> i compile it
19:27:35 <incertia> anyone can help me with some loeb weirdness? i have a loeb snippet that runs fine on [] but when i switch it to the corresponding Vector code i get an infinite loop
19:30:11 <incertia> specifically `loeb [ take 3 . (0:) . (!! 1), fmap succ . (!! 0) ]` vs `loeb $ V.fromList [ V.take 3 . V.cons 0 . (V.! 1), fmap succ . (V.! 0) ]`
19:32:57 <incertia> the former evaluates to [[0,1,2],[1,2,3]]
19:33:04 <jared-w> ontop: disgusting. I love it
19:33:12 <ontop> jared-w: ^_^
19:42:48 <dsal> bl4ckb0ne: I used an array in ST.  I rarely have any IO in AoC code.  Most of my stuff is in tests.
19:43:46 <dsal> That was my second version... I wouldn't recommend it as an initial approach.
19:45:47 <bl4ckb0ne> im trying with lists
19:46:06 <dsal> That'll work. My first version was vector.
19:48:18 <bl4ckb0ne> > Couldn't match expected type ‘Int’ with actual type ‘m0 b0
19:48:20 <bl4ckb0ne> not good so far
19:48:20 <lambdabot>  <hint>:1:25: error: parse error on input ‘type’
19:51:48 <bl4ckb0ne> https://pastebin.com/nXEeNrzU
19:51:53 <bl4ckb0ne> Array-less version
19:53:03 <bl4ckb0ne> still got complation issues tho
20:10:36 <monochrom> I think you greatly misunderstood "do".
20:11:17 <sarahzrf> incertia: hmm, might it just be a strictness thing
20:15:57 <incertia> seems like anything that iterates over a slice will bottom
20:16:17 <monochrom> Yeah, the issue may come down to simply "xs = 0 : xs" vs "v = V.cons 0 v"
20:24:47 <incertia> so this poses quite a conundrum for my "idealized" IntCode computer for AOC. i could just immediately discard inputs as i read them in which case [] would be ideal but if at any point i want to introspect any previous inputs for whatever reason i run into performance issues in large lists with !!
20:25:52 <suzu> don't use a list
20:26:17 <incertia> yeah but that makes day 7 ugly
20:26:39 <suzu> use a vector or an array
20:26:41 <suzu> lists are linked lists
20:26:42 <iqubic> Lists are good.
20:26:52 <suzu> random access of a list is terrible performance
20:26:54 <iqubic> I'm using a list for my input, and it's working well.
20:27:06 <incertia> so i guess i'm looking for some sort of lazy prepend with maximum O(log n) access
20:27:07 <iqubic> You never need random access of the input though.
20:27:24 <incertia> this is for some dumb super intcode computer
20:27:36 <suzu> if you'll want a lookback then you'll need a better data structure
20:27:49 <incertia> hence the question
20:28:00 <suzu> yeah. so you'll need a vector or array or something
20:28:31 <iqubic> suzu: You don't need a vector or an array for loop back.
20:29:34 <iqubic> At least if your definition of loopback is the same as mine.
20:34:03 <incertia> vector is no good, it does not loeb. array is also no good, it is not Monoid, unless `array (0, length v - 1) . zipWith [0..] $ v where v = elems a <> elems b` is lazy enough
20:35:31 <iqubic> Is there a simple way to use lenses to remove an element from a data structure that has an At instance?
20:35:40 <incertia> .~ Nothing
20:35:49 <iqubic> :t sans
20:35:51 <lambdabot> At m => Index m -> m -> m
20:35:55 <suzu> :t (.~)
20:35:56 <lambdabot> ASetter s t a b -> b -> s -> t
20:35:58 <iqubic> That also works.
20:36:02 <iqubic> sans works.
20:36:07 <iqubic> Delete the value associated with a key in a Map-like container
20:36:08 <suzu> i think the setter might not
20:36:25 <suzu> incertia: do you need loeb?
20:36:45 <iqubic> suzu: The setter works.
20:36:50 <incertia> loeb is good for day 7
20:36:51 <iqubic> sans k = at k .~ Nothing
20:37:04 <incertia> fromList [(1, 1)] & at 1 .~ Nothing ==> fromList []
20:37:44 <iqubic> fromList [(1,1)] & sans 1 ==> fromList []
20:39:14 <iqubic> fromList [(1,'x')] & sans 1 ==> fromList []
20:48:20 <glguy> > M.singleton 42 43 & at 42 . non 0 .~ 0
20:48:24 <lambdabot>  fromList []
20:48:30 <glguy> > M.singleton 42 43 & at 42 . non 0 .~ 1
20:48:34 <lambdabot>  fromList [(42,1)]
20:49:24 <iqubic> That's fairly cool.
20:54:32 <iqubic> I didn't know that non was a thing.
20:54:46 <dsal> Lens has a way of having things that you didn't know were them.
20:55:38 <dsal> Ugh.  I just did a bunch of refactoring of my (now two) intcode machines.  There was one big change I wanted to make to the mutable one so it could solve all the new problems, but time's up.
21:49:51 * hackage ucd 0.0.0.0 - See README for more info  https://hackage.haskell.org/package/ucd-0.0.0.0 (MatthewFarkasDyck)
21:50:26 <pdxleif> http://hackage.haskell.org/package/HiggsSet says it's deprecated - I'm wondering if it turned out to be a dead end, or the guy just didn't want to maintain it anymore?
21:52:40 <MarcelineVQ> can ask him :>
22:05:01 <iqubic> Is there a nice and simple way to create "xs::[Double]" where xs is the all the whole numbers from 0 to n?
22:06:37 <heatsink> let xs = [0..n]
22:06:53 <iqubic> But I want xs to be a list of doubles.
22:06:59 <c_wraith> works until n is greater than 2^53, anyway
22:07:02 <heatsink> let xs = [0..n] :: [Double]
22:07:19 <heatsink> if n is an Int, you need fromIntegral n
22:07:52 <iqubic> I see.
22:08:11 <heatsink> Also, beware rounding
22:08:14 <heatsink> > [0 .. 0.85]
22:08:18 <lambdabot>  [0.0,1.0]
22:12:10 <iqubic> I see.
22:14:33 <iqubic> Is there a way to turn an int into a double?
22:15:05 <c_wraith> :t fromIntegral
22:15:06 <lambdabot> (Integral a, Num b) => a -> b
22:17:13 <timokratia[m]> https://hoogle.haskell.org/?hoogle=Int%20-%3E%20Double
22:18:38 <iqubic> This is a really janky thing I'm doing.
22:19:16 <iqubic> And it turns out what I'm doing is totally wrong.
22:19:26 <suzu> what are you trying to do?
22:19:34 <c_wraith> advent of code
22:19:38 <suzu> oh
22:20:23 <iqubic> I'm trying to find/write a (V2 Int -> Double) to get the angle.
22:21:02 <iqubic> But I don't know if that's possible.
22:22:36 <iqubic> So I basically want the exact opposite of this "angle :: Floating a => a -> V2 a"
22:22:46 <suzu> V2?
22:22:55 <c_wraith> hint: you want the atan2 function
22:23:09 <iqubic> I do? Why?
22:23:19 <c_wraith> It takes two coordinates and gives you the angle to them
22:23:26 <c_wraith> err, that is, it takes an x and y
22:23:32 <c_wraith> and it handles all the edge cases
22:24:26 <iqubic> Will give different results for 1,3 and 1, -3?
22:24:36 <c_wraith> yes
22:24:45 <c_wraith> that's one of the special cases it handles
22:25:18 <c_wraith> along with handling when the slope is infinite
22:25:40 <iqubic> Good.
22:26:20 * hackage ucd 0.0.1.0 - Unicode Character Database — Predicates on characters specified by Unicode  https://hackage.haskell.org/package/ucd-0.0.1.0 (MatthewFarkasDyck)
22:26:23 <iqubic> Nice.
22:29:51 <iqubic> I feel like I'm doing such a janky thing here in for my solution.
22:32:01 <c_wraith> there's a way to do the comparisons without ever calculating angles.  I remember that much.  I don't remember what it is.
22:32:07 <c_wraith> I just calculated angles
22:32:15 <iqubic> Same.
22:32:29 <bahamas> can you see in ghci the definition of a particular instance? for example instance Foldable []
22:32:48 <c_wraith> no, ghci doesn't include that
22:33:07 <bahamas> ok
22:33:16 <c_wraith> even with :doc, that only gives you the docs, not the source
22:36:09 <jle`> bahamas: you can't really see any definitions in ghci, but for some things you can at least get the module where tehy are defined
22:37:23 <bahamas> jle`: yes, I noticed that :i shows where stuff is defined. I think I assumed you can see definitions, because I saw some type definitions
22:37:44 <bahamas> :i Maybe
22:38:12 * bahamas doesn't know how to talk to the bot
22:38:45 <jle`> bahamas: ah, yeah, :i sort of just shows the public interface, i suppose
22:38:54 <jle`> it isn't supposed to tell you the definition, just how to use it
22:40:32 <c_wraith> and sufficiently new versions of ghc do have :doc now
22:41:42 <bahamas> c_wraith: for which I'm glad
22:42:13 <bahamas> when I was learning Python I appreciated the dir function a lot. now I can have the same in ghci with :browse and :doc
22:56:20 <bahamas> I accidentally wrote `: (->)` and it seems that ghci inferred I wanted to write `:i (->)`. is that the default of `:`?
23:02:51 <int-e> bahamas: apparently it repeats the last command
23:24:00 <bahamas> int-e: ah, you're right
23:24:48 <bahamas> https://mpickering.github.io/ghc-docs/build-html/users_guide/ghci.html#ghci-cmd-:
