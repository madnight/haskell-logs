00:02:21 <yasar> :t (+ 2 4)
00:02:23 <lambdabot> (Num a, Num t, Num (t -> a)) => a -> a
00:02:30 <yasar> :t ((+) 2 4)
00:02:32 <lambdabot> Num a => a
00:02:42 <yasar> Why those two are different?
00:04:31 <propoton> Hello. Is there a way to make errors less verbose? I just need a line where something bad happened. I don't have enough space on the screen for anything else
00:04:59 <propoton> Also it would be useful to somehow enable `name shadowing` only for things with the same type. I just want to use identifiers like `length`, `id` or `last` sometimes
00:07:12 <lortabac> yasar: parentheses allow you to use an infix operator as a prefix function
00:07:32 <lortabac> so the second one is equivalent to '2 + 4'
00:07:47 <Lears> yasar: `(+)` is a value, whereas `a + b` is special operator syntax for `(+) a b`. `(+ foo)` is more special operator syntax called a section; it means `\x -> x + foo`. Since your `foo` is `2 4`, you also get a fairly funky type out of it.
00:09:54 <Ariakenom> % (/ 2) 3
00:09:54 <yahb> Ariakenom: 1.5
00:09:59 <Ariakenom> % (2 /) 3
00:09:59 <yahb> Ariakenom: 0.6666666666666666
00:10:11 <Ariakenom> (/) 2 3
00:17:41 <jusss> is that generator stuff kind of a delimited continuation?
00:19:08 <jusss> > (/) 2 3
00:19:11 <lambdabot>  0.6666666666666666
00:19:17 <jusss> > (/) 1 3
00:19:21 <lambdabot>  0.3333333333333333
00:29:54 <yasar> Lears, if `(+ foo) = \x ->x + foo`, then  `(+ 2 4) = (\x -> x+2) 4`, then isn't it just 6 anyways?
00:35:45 <Ariakenom> yasar: (+ 2 4) = \x -> x + (2 4)
00:36:04 <Lears> yasar: That would be if you had `(+ 2) 4`.
00:37:42 <Ariakenom> so 2 has to be a function, which it is not (although you can make it a function so you dont get an error)
00:37:56 <propoton> `(+ 2 4) -> (+ (2 4)) -> (+ ((fromInteger2) (fromInteger 4)))` 
00:38:30 <Ariakenom> propoton: `2 -> fromInteger 2` is circular, but yes
00:38:43 <propoton> > :t fromInteger
00:38:45 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
00:38:56 <propoton> Ohh
00:39:00 <propoton> :t fromInteger
00:39:02 <Ariakenom> 2 = fromInteger theIntegerTwo
00:39:03 <yasar> Lears, isn't space left associative? Why not `(+ 2) 4` but `+ (2 4)`
00:39:03 <lambdabot> Num a => Integer -> a
00:39:54 <Lears> > (+)(2)(4)
00:39:56 <lambdabot>  6
00:40:14 <Lears> Space isn't an operator, but function application is left associative.
00:40:41 <Ariakenom> yes, space isnt an operator. and function application binds tighter than that +
00:40:43 <Lears> `+`, however isn't a value, let alone a function. It's syntax.
00:41:05 <Ariakenom> example: 1 + sin 2
00:41:26 <iqubic> Lears: see this:
00:41:32 <iqubic> :t (+)
00:41:34 <lambdabot> Num a => a -> a -> a
00:41:44 <iqubic> + is clearly a function.
00:42:15 <propoton> > (+ succ 1) 2
00:42:18 <lambdabot>  4
00:42:20 <Lears> Yes, (+) is both a value and a function.
00:44:05 <maerwald> > :t +
00:44:08 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
00:44:46 <Lears> :t +
00:44:48 <lambdabot> error: parse error on input ‘+’
00:45:23 <propoton> `(+ 2 4)` is desugared into `flip (+) ((fromInteger 2) (fromInteger 4)) `
00:45:37 <propoton> :t flip (+) ((fromInteger 2) (fromInteger 4)) 
00:45:40 <lambdabot> (Num c, Num t, Num (t -> c)) => c -> c
00:45:43 <propoton> :t (+ 2 4)
00:45:45 <lambdabot> (Num a, Num t, Num (t -> a)) => a -> a
00:55:57 <TheCommieDuck> is there a name for the pattern of having an extendable sum type via parameterisation? i.e. data A a = A ... | B ... | C ... | Ex a and then each function taking A also takes a function when you pattern match on Ex
00:56:23 <TheCommieDuck> I ask this because the context I saw it was "this is a common pattern..." but I dunno if it has a name to google.
00:57:38 <dminuoso> TheCommieDuck: "[...] takes a function when you pattern match" - can you elaborate on what you mean by that?
00:58:01 <TheCommieDuck> I had found a gist but I lost it, I'll try and write one
00:58:12 <dminuoso> TheCommieDuck: Are you talking about continuations for pattern matching?
00:58:18 <dminuoso> i.e. like 
00:58:20 <dminuoso> % :t maybe
00:58:20 <yahb> dminuoso: b -> (a -> b) -> Maybe a -> b
01:00:12 <TheCommieDuck> https://pastebin.com/fuCEDxiR hopefully this is clear enough
01:00:29 <TheCommieDuck> sort of a partially defined sum type?
01:01:24 <dminuoso> TheCommieDuck: I'd say it's a form of continuation passying style
01:01:38 <dminuoso> TheCommieDuck: `f` acts as a continuation, it's quite like `maybe`
01:01:54 <TheCommieDuck> that rings a bell back to my undergrad
01:02:24 <dminuoso> TheCommieDuck: Though the example is a bit ill-conceived, in that the function is highly partial.
01:02:54 <TheCommieDuck> is it?
01:03:01 <dminuoso> Unless you carry a continuation for *each* constructor, or provide some other means of providing a value of type `x` is the constructor is not Ex.
01:04:13 <TheCommieDuck> if it's an A, B, or C, then I can define the function there and then
01:04:23 <dminuoso> TheCommieDuck: Not with that type signature
01:04:33 <dminuoso> Feel free to tr.
01:04:34 <dminuoso> *try.
01:05:07 <dminuoso> If they were not type variables, but monomorphic types, then sure.
01:05:15 <dminuoso> Perhaps you meant that?
01:06:47 <MarcelineVQ> "<TheCommieDuck> I ask this because the context I saw it was "this is a common pattern..." but I dunno if it has a name to google." what was the context?
01:06:51 <TheCommieDuck> https://pastebin.com/9EP3fFbn if I write it out more fully
01:07:16 <TheCommieDuck> the context was a blog post about extendable types
01:07:17 <dminuoso> MarcelineVQ: We have channel logs! :-p
01:07:30 <dminuoso> TheCommieDuck: Yes. This works.
01:07:40 <dminuoso> TheCommieDuck: It's continuation passing style in a slighly unusual form.
01:07:59 <dminuoso> A simple example of a continuation is the argument to this thing:
01:08:02 <dminuoso> % :t magicFun
01:08:02 <yahb> dminuoso: ; <interactive>:1:1: error: Variable not in scope: magicFun
01:08:19 <dminuoso> % :t magicFun
01:08:19 <yahb> dminuoso: (Char -> b) -> b
01:08:34 <dminuoso> A continuation is essentially just a way to state "how to continue/proceed"
01:08:38 <libertyprime> Hey guys. Random noob question: I know you can use regex in parsec (maybe not by default but there is a module you can import for this yes?) but is there anything out there to use parsec parsers inside regex where the parsers are subordinate to backtracking etc?
01:08:53 <TheCommieDuck> https://www.reddit.com/r/haskell/comments/6cglu0/extendable_data_in_haskell_part_2_an_unresolved/dhw6ee2/ this isn't the comment I was thinking of, but it's one that states "this is a common way..."
01:10:21 <dminuoso> TheCommieDuck: Im not sure whether this is a common idiom, its not something I see often.
01:10:33 <TheCommieDuck> gotcha, thank you
01:11:27 <TheCommieDuck> it's just that awkward branch of: I don't want an open type, so all those open sum type solutions aren't exactly what I want, yet it's not closed in that I want to define it in 2 separate places
01:11:50 <dminuoso> TheCommieDuck: You can glue them together using `Either`
01:12:09 <dminuoso> TheCommieDuck: Either gives you type level addition. :)
01:12:55 <TheCommieDuck> does Either Foo | Ex a where Foo is A/B/C give me much advantage over just having A | B | C | Ex a though? 
01:13:54 <dminuoso> TheCommieDuck: Well if the goal is to have a sum type from two data types in different locations..
01:13:54 <dminuoso> Then you could define data type A in module A, data type B in module B and then obtain a sum type by just using `Either A B`
01:14:01 <phanimahesh> yep. You can define the either independent of Foo
01:14:02 <dminuoso> (A sum of both of them)
01:15:42 <phanimahesh> Either is exactly what you need to stitch together a sum type out of two types you don't fully control/don't want to mess with/etc, even if one of them is a sum type.
01:15:48 <TheCommieDuck> maybe it's semantics, considering it as the sum type of two types versus a single sum type that I have a number of base cases for which I'm then appending with a couple more
01:16:35 <phanimahesh> you can technically define your own sum type out of the two components but with either you get lots of utility functions for free. if you don't like their behaviour by all means go define a new type.
01:17:01 <dminuoso> TheCommieDuck: Type level addition is associative up to isomorphism.
01:17:02 <TheCommieDuck> extra utility is what I wanted, I was just being overly roundabout in it. thank you all kindly :)
01:17:18 <dminuoso> TheCommieDuck: The bar | in creating sum types is essentially the same as using `Either` instead.
01:17:55 <dminuoso> That is, `data Foo = Foo | Bar` or `data Foo = F (Either () ())` are isomorphic
01:18:11 <dminuoso> Or equivalently `data Foo = Foo Int | Bar Char` is isomorphic to `data Foo = F (Either Int Char)`
01:18:51 <dminuoso> TheCommieDuck: Its mostly a convenience question. If the whole thing really is not open, it can be worth exploring. Things like lens/optics can give you convenient access without pattern matching into nested things
01:19:37 <TheCommieDuck> I suppose as a final thing: I'm trying to avoid the XY-problem here, but if I specialised my problem such that all of A/B/C and Ex a are of some Bar a type only differing in a, is there a special way of doing that? as in, a parametric type that is closed on what it can be parameterised with
01:19:53 <TheCommieDuck> (if the answer is "what are you asking" then don't worry about it)
01:20:05 <Solonarv> yes: that is exactly how GADTs work
01:20:28 <TheCommieDuck> I've seen so many things with GADTs and never clicked them for this usecase
01:20:49 <Solonarv> although I did not catch your original query, so I don't know what A/B/C and Ex a are supposed to be ;)
01:21:02 <TheCommieDuck> https://pastebin.com/9EP3fFbn here
01:21:32 <dminuoso> TheCommieDuck: Perhaps we should pierce the XY curtain and talk about what you are trying to do.
01:24:54 <TheCommieDuck> okay. I want a hierarchy of physical objects. They all share some common base data (e.g. a name) and then some additional information (e.g. a person has an age). The Y I've attempted is that I parameterise the type on what additional information each type holds; PersonData, LocationData, etc.
01:27:13 <TheCommieDuck> the issue with me trying to invert this to a function-first rather than OO-hierarchy is that I don't have any...functions? behaviours? in this, it's all just data. The "partial sum type" is that I want to be able to have generic things defined in one place (e.g. person) to reuse, and project specific things elsewhere
01:30:15 <phanimahesh> just data is useless. You are going to do _something_ with this data. That something would be done with functions. They guide the choices.
01:30:46 <phanimahesh> so, if I understand correctly, you have potentially multiple projects, each with their own set of metadata fields.
01:31:06 <TheCommieDuck> Yep, basically. Plus a standard library.
01:31:15 <phanimahesh> you want to share the functionality on some core types across projects
01:31:37 <phanimahesh> even if they end up having different assosciated metadata
01:32:09 <phanimahesh> I know the first rule of typeclasses is to not write them, but.. have you considered a typeclass based approach?
01:32:26 <phanimahesh> specifically, HasX style classes, like rio recommends
01:33:18 <phanimahesh> actually wait
01:33:27 <phanimahesh> why do you want a hierarchy at all?
01:34:04 <phanimahesh> you want a helper that for example displays name irrespective of whether it's a person or location or whatever else you pass in?
01:34:08 <TheCommieDuck> I had considered it, but I don't think it was a great solution at the time. and the hierarchy is /solely/ for avoiding code reuse. which I can do with composition, I suppose?
01:34:53 <phanimahesh> I don't like it particularly either due to the boilerplate, but reading the code it does communicate intent clearly
01:35:23 <phanimahesh> `displayName :: HasName a => a -> IO ()` is very clear in its intent
01:35:53 * Solonarv would prefer ... -> String
01:36:03 <Solonarv> don't hard-wire putStrLn into your functions!
01:36:08 <phanimahesh> Noted, I was just going with an example
01:37:34 <Ariakenom> Text though
01:38:27 <TheCommieDuck> I think the Either approach is by far the best so far though and on second thought, I dunno what the 'easier' alternative would be
01:38:43 <Solonarv> yes, Text is a better string type
01:39:10 <phanimahesh> now pick between lazy and strict
01:40:21 <phanimahesh> oh, did you mean a bytestring by any chance? who needs an encoding you say?
01:41:16 <phanimahesh> one of my biggest frustrations is juggling between the stringy types. ByteStrings don't technically count but still, they pop up in similar situations often enough.
01:41:26 <merijn> I should once again propose my idea of deprecating bytestring and releasing a bytes package which is just ByteString, but with Bytes as name :p
01:41:36 <dminuoso> Haskell type system I hate you. Making it impossible to have a STT.
01:41:49 <dminuoso> This specific problem clearly calls for a ST transformer!
01:42:35 <merijn> dminuoso: Wait, I recall seeing an ST transformer, I think?
01:42:38 * Solonarv quirks an eyebrow
01:42:54 <Solonarv> yes, you can write an ST transformer, but it is horrible and breaks things
01:42:55 <phanimahesh> yes, I would prefer that too. But will only hurt more with all the libraries that won't ever get updated
01:43:01 <merijn> In fact, there's apparently 2 separate packages implementing STT :p
01:43:07 <phanimahesh> what's an ST transformer?
01:43:14 <phanimahesh> and what's STT?
01:43:14 <dminuoso> phanimahesh: Something truly evil.
01:43:14 <Solonarv> with many monads it just gives you unsound nonsense
01:43:25 <dminuoso> And I kind of need it.
01:43:32 <Solonarv> whatever for?
01:43:34 <merijn> dminuoso: Why do you need it, though?
01:43:39 <phanimahesh> for world domination?
01:43:46 <Solonarv> are you sure MonadBase (ST s) won't do?
01:44:03 <Solonarv> or rather, PrimMonad
01:44:18 <merijn> Solonarv: MonadBaseControl is a trainwreck >.>
01:44:26 <Solonarv> MonadBaseControl is, yes
01:44:30 <Solonarv> MonadBase isn't
01:44:32 <jle`> PrimMonad is a bff of mine
01:44:51 <Solonarv> that's just MonadIO but it is generalized instead of being specialized to IO
01:44:52 <jle`> although! i can never remember if it is PrimMonad or MOnadPrim
01:44:58 <Solonarv> hehe
01:45:13 <merijn> jle`: MagicHash is my bff
01:45:44 <phanimahesh> here I am, an uninitiated plebian who never laid eyes on PrimMonad
01:46:02 <phanimahesh> I did read about it somewhere I think
01:46:13 <Solonarv> it's not so bad, really
01:46:20 <jle`> you can 'think of it' as MonadIO but for ST, and also IO
01:46:29 <jle`> ...this analogy is only useful if you are familiar with MonadIO
01:46:33 <Solonarv> it is just a way of saying "this monad is a stack of transformers that has IO or (ST s) at its base"
01:46:42 <merijn> phanimahesh: PrimMonad and co are all dirty, gory, internal bits of GHC
01:47:04 <merijn> phanimahesh: For people like me who like to sometimes throw out our sanity and write C in GHC ;)
01:47:13 <phanimahesh> I've read about internals of IO. now I remember.
01:47:22 <phanimahesh> https://stackoverflow.com/questions/17522198/defining-primmonad-instance-for-stt-st-transformer
01:47:35 <phanimahesh> found this on first page for a search on primmonad
01:48:48 <jle`> hm, i don't think PrimMonad is really that dirty, it's basically the same thing as MonadIO
01:48:49 <merijn> phanimahesh: The paper on ST "Lazy Functional State Threads" is quite relevant and readable here
01:49:15 <merijn> jle`: Well, they *are* rather low level implementation details of GHC
01:49:20 <jle`> it abstracts over the dirtiness in a way that is as clean as most other 'pure' abstractions
01:49:26 <jle`> merijn: PrimMonad, do you mean?
01:49:37 <jle`> as in, the implementation, or the interface?
01:49:43 <merijn> jle`: By dirty I mean "Not really meaningful in standard Haskell"
01:50:23 <jle`> the implementation is admittedly dirty but i think for the front user it's pretty much as clean as MonadReader, MonadState, MonadIO, etc.
01:50:26 <merijn> I get that we're all basically writing GHC-only code anyway, but some bits are considerably more GHC-only than others :)
01:50:31 <iqubic> jle`:
01:50:39 <iqubic> Aren't you going to be sleeping soon?
01:50:53 <jle`> that is true
01:51:03 <merijn> phanimahesh: That paper explains how (in GHC) IO and ST are just two different specialisations of the same underlying monad abstraction
01:51:15 <phanimahesh> are non ghc compilers in active development/use?
01:51:23 <Solonarv> not really
01:51:33 <merijn> phanimahesh: Which also explains the use of PrimMonad (i.e. unifying all abstractions built on top of that)
01:51:35 <phanimahesh> merijn: thanks. added to my evergrowing list
01:51:47 <jle`> i think even if IO and ST are not specialization, PrimMonad would still be useful as a front-facing interface
01:51:58 <jle`> but maybe it might not be possible to implement
01:52:00 <merijn> phanimahesh: There's the Utrecht Haskell Compiler, which supports all of Haskell2010 and is in active development, but not widely used and not really attempting to compete with GHC
01:52:03 <Solonarv> even the Haskell-to-X compilers (Eta, GHCJS, Asterius, ...) are mostly based on GHC
01:52:22 <merijn> phanimahesh: There's also the Mu dialect inside Standard Chartered, but the damn lawyers will never let us see that compiler
01:52:30 <Solonarv> also I think some financial company or something has a compiler for a strict dialect of Haskell
01:52:33 <Solonarv> ah yeah, that
01:54:31 <AWizzArd> Is there a way in Servant to specify "any" content type? I would like to offer a route to my server, do an external http server, and whatever this external server delivers, I want to stream as ByteString to my original client.
01:58:28 <opqdonut> AWizzArd: well there's the Raw endpoint...?
01:59:59 <opqdonut> kinda like this https://haskell-servant.readthedocs.io/en/stable/tutorial/Server.html#serving-static-files
02:04:47 <amx> AWizzArd: what I did in a similar situation is overwrite the Content-Type header manually
02:05:04 <amx> ugly, but works
02:22:14 <tabaqui1> Today I've heard about some monad related to probability
02:22:32 <tabaqui1> I am not sure about the actual world, but I recognized it as "jira" or something like
02:22:40 <tabaqui1> do you know what it could be?
02:22:54 <tabaqui1> s/world/word
02:27:08 <alp> there are a couple of those
02:27:34 <alp> http://www.randomhacks.net/probability-monads/ those few blog posts are a pretty smooth intro to the topic
02:34:55 <nickednamed> Hello all. I am new to Haskell, and programming in general, and I am working my way through some typical programming challenges (Euler, etc.), and for each challenge I would like not only to solve it, but also write tests, benchmarks, etc. I am using GHC 8.6.5, cabal 3.0.0, and hspec & Quickcheck for tests. So far so good. However, I would like to try the performance analysis steps listed here: 
02:35:01 <nickednamed> https://stackoverflow.com/questions/3276240/tools-for-analyzing-performance-of-a-haskell-program. I've added '-rts-opts' and '-with-rts-opts' to my *.cabal file, under ghc-options. But the output of `time cabal-run myProject' is just a one liner, not a decent amount of output like at StackOverflow. Sorry for the wall of text.
02:37:34 <merijn> nickednamed: You need to do "cabal run myProject -- +RTS -s" to get the output from stackoverflow ("+RTS -s" to enable the reporting of statistics and "--" to ensure the +RTS flag gets passed to your program and *not* to cabal)
02:38:26 <tabaqui1> alp: good paper, but is not close
02:38:31 <merijn> nickednamed: As for the other profiling, you'll want to use "cabal build --enable-project"?
02:38:43 <tabaqui1> another hint, they talked about practical useless of the monad
02:38:57 <tabaqui1> "it is funny, but noone knows how to apply it"
02:39:04 <tabaqui1> or where to apply
02:40:22 <nickednamed> ah... God I'm dumb. I didn't notice. Yes, that makes perfect sense. I'll give it a go right now.
02:41:48 <nickednamed> merijin: Yes, that did the trick. Thank you very much.
02:42:08 <alp> tabaqui1, hmm, that doesn't ring a bell. there are tons of posts and papers in that space, about representing distributions (finite or not), sampling from them, implementing Markov processes, and so on. but that particular hint doesn't ring a bell.
02:42:09 <merijn> eh
02:42:21 <merijn> nickednamed: --enable-profiling, not --enable-project >.>
02:46:51 <nickednamed> merijn: OK - I will use 'cabal build --enable-profiling' for the profiling methods. Is there any way to do this automatically, i.e. always build with profiling? Something I can add to 'ghc-options', for example? -fprof-auto? Is that the one?
02:47:29 <tabaqui1> alp: allright, thx anyway
02:47:53 <Solonarv> nickednamed: I think you can add it to cabal.project
02:48:21 <Solonarv> -fprof-auto tells GHC what profiling information to generate, but it does not actually enable profiling IIRC
02:50:28 <merijn>  nickednamed: You were using cabal-install 3.0, right?
02:51:16 <merijn> nickednamed: Then you can use cabal.project and cabal.project.local to configure that sort of thing, in this case creating a cabal.project.local file with the line "profiling: True" should work
02:51:50 <nickednamed> merijn: that's right. Ah, OK. I'm just reading the cabal user guide right now, looking for the right incantation.
02:55:12 <nickednamed> OK - it looks like I can add '--enable-profiling' or 'profiling: True', and both seem to have the right effect. I will try some other profiling methods to check.
02:55:25 <nickednamed> Solonarv, marijn: Thank you.
02:58:54 <nickednamed> OK - I see now that I should have familiarized myself better with 'cabal configure' and it's options in order to produce such a cabal.project.local file form the beginning.
03:02:37 <kuribas> is there a transformer which has reader on the inside?  like Monad m => m (r -> a)
03:03:34 <tdammers> kuribas: you can trivially construct one, sure
03:04:00 <kuribas> is it a monad?
03:04:13 <winny> / #gentoo-ch
03:04:18 <tdammers> oh wait, a plain monad, not transformer
03:04:23 <winny> typo, disregard
03:04:30 <tdammers> wait even more
03:04:43 <kuribas> tdammers: if it's a monad transformer, it's a monad of course
03:04:49 <tdammers> no
03:04:55 <tdammers> a monad transformer is not a monad itself
03:05:22 <tdammers> given MonadTrans t, Monad m, you get Monad instances for m and t m, but not for t
03:05:22 <kuribas> tdammers: it is if the inner thing is a monad
03:05:42 <tdammers> the transformer applied to a monad is a monad, but the transformer itself is not
03:05:59 <tdammers> just like succ applied to an integer is an integer, but succ itself is not
03:06:11 <kuribas> in that sense a Monad transformer isn't a type
03:06:16 <kuribas> but a kind
03:06:22 <tdammers> no it's not
03:06:24 <Solonarv> it is definitely not a kind
03:06:27 <tdammers> it is a type
03:06:38 <tdammers> it has kind (* -> *) -> (* -> *)
03:06:46 <Solonarv> it's a type, but it's not a Type ;)
03:06:59 <tdammers> that is it takes a type of kind * -> * and gives you a type of kind * -> *
03:07:15 <kuribas> is [] a type?
03:07:22 <tdammers> yes
03:07:23 <kuribas> or Identity
03:07:26 <kuribas> hmm
03:07:31 <tdammers> :k []
03:07:34 <lambdabot> * -> *
03:07:43 <tdammers> :k ReaderT ()
03:07:44 <kuribas> a type without value then
03:07:44 <lambdabot> (* -> *) -> * -> *
03:07:55 <Solonarv> yes, an uninhabited types
03:07:58 <Solonarv> *type
03:08:28 <kuribas> and a phantom type is something else?
03:08:33 <Solonarv> all types with a kind other than Type (aka *) are uninhabited
03:08:42 <Solonarv> a "phantom type" is not a thing
03:08:57 <Solonarv> a type parameter's or type variable's *role* can be "phantom"
03:09:02 <tdammers> "phantom types" describe how a type is used, not what it is
03:15:41 <kuribas> hmm, it doesn't look like m (r -> a) has a sensible bind operation
03:23:55 <tdammers> :t runReader . runStateT
03:23:57 <lambdabot> error:
03:23:57 <lambdabot>     • Couldn't match type ‘s -> m (a, s)’ with ‘ReaderT r Identity a1’
03:23:57 <lambdabot>       Expected type: StateT s m a -> Reader r a1
03:24:20 <tdammers> :t runReader (runStateT (pure ()) ())
03:24:22 <lambdabot> r -> ((), ())
03:24:29 <tdammers> there you go
03:25:45 <Solonarv> ReaderT r m a is r -> m a though
03:25:48 <Solonarv> not m (r -> a)
03:26:38 <Solonarv> the latter is less general because the monadic action can't depend on r
03:30:48 <tdammers> Solonarv: my example is StateT () (Reader ())
03:30:53 <tdammers> reader on the inside
03:31:01 <kuribas> tdammers: ah right :)
03:31:17 <Solonarv> oh, I hadn't quite caught that
03:31:18 <kuribas> tdammers: it's like state that doesn't mutate the state
03:33:42 <kuribas> tdammers: that doesn't have a bind, does it?
03:33:59 <tdammers> why wouldn't it?
03:34:16 <kuribas> tdammers: I couldn't find one
03:34:42 <Lears> @unmtl StateT s (ReaderT r m) a
03:34:42 <lambdabot> s -> r -> m (a, s)
03:34:45 <tdammers> > runReader (runStateT (ask >>= put) 0) 5
03:34:47 <lambdabot>  ((),5)
03:35:34 <tdammers> that stacks a state onto a reader, feeds 5 to the reader, intializes the state to 0, and then the monadic action inside pulls the value from the reader and sticks it in the state
03:35:39 <Solonarv> hm, I am trying to write a join but I too am becoming convinced it can't be done
03:36:10 <Solonarv> kuribas: "state that doesn't mutate the state" - isn't that just reader?
03:36:27 <kuribas> Solonarv: indeed, I was wrong
03:40:11 <kuribas> using StateT here doesn't help
03:50:29 <wikiemol> So I have constructed this function as a version of the "rho" operator  mentioned here https://en.wikipedia.org/wiki/%CE%9C-recursive_function#Definition `p g h n x = foldr (($ x) . ($)) (g x)  (map h (map (+(-1)) $ enumFromTo 1 n))`
03:50:43 <wikiemol> Is there a way to make this more elegant?
03:51:03 <wikiemol> It must use foldr, and it can't obviously use recursion
03:57:23 <dibblego> try this: foldr _cons _nil (enumFromTo 1 n)
03:57:28 <dibblego> then use the types to get to the answer
03:59:28 <wikiemol> dibblego, sorry, new to haskell, what do the underscores mean in this context?
03:59:37 <dibblego> they are type holes
03:59:45 <dibblego> ghc will tell you the type that belongs there
03:59:46 <Solonarv> type*d* holes
03:59:51 <Solonarv> holes that have a type
03:59:57 <dibblego> https://wiki.haskell.org/GHC/Typed_holes
04:02:22 <wikiemol> dibblego Oh I see, so _cons is a hole, not just the underscore then? 
04:02:41 <tdammers> yes
04:02:58 <dibblego> yes, the thing with which to replace (:) in the list
04:06:14 <wikiemol> dibblego Gotcha, well thats kind of where I started. I didn't know about the holes, which is extremely useful and probably would have saved me a lot of time and headache, but I found my current answer by doing it by hand essentially
04:07:40 <dibblego> here are some things:
04:08:11 <dibblego> map f = foldr ((:) . f) []
04:08:51 <yasar> Can I make ghc to compile my file without a main function? I just want to see compile error, don't need the .exe file
04:09:26 <wikiemol> ooh... dibblego I think I see where you are going with this
04:10:37 <tabaqui1> yasar: try to add "module Foo where" on top of the file
04:11:17 <tabaqui1> though, ghc have to have appropriate flag
04:11:21 <tabaqui1> *has to have
04:13:47 <wikiemol> dibblego p g h n x = foldr (($ x) . ($) . h . (-1 +)) (g x)  (enumFromTo 1 n)
04:14:12 <dibblego> lgtm
04:14:20 <yasar> tabaqui1, it works with `-c` switch
04:14:24 <yasar> Thanks :)
04:14:26 <lavalike> some good line noise
04:14:33 <dibblego> @type \f -> foldr (\a b -> foldr f b a)
04:14:33 <wikiemol> dibblego Thank you! 
04:14:36 <lambdabot> (Foldable t1, Foldable t2) => (a -> b -> b) -> b -> t1 (t2 a) -> b
04:14:59 <yasar> I am trying to make a custom List a member of Foldable class, but something is not right: https://gist.github.com/yasar11732/c1dcb381354877dcffaf3439b2c5e7ff
04:14:59 <dibblego> you can change (-1 +) to (subtract 1)
04:15:04 <yasar> error message in comments
04:15:17 <wikiemol> dibblego Thats probably better
04:15:45 <dibblego> yasar: have a look at the type for foldMap
04:16:24 <yasar> :t foldMap
04:16:26 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
04:16:39 <dibblego> that return type is clearly not going to be a (List a)
04:16:55 <dibblego> :i Monoid
04:23:50 <dminuoso> I have two top level functions `f :: Device -> Foo` and `g :: Device -> Bar`, and both use a third `h :: Device -> [VLAN]` - how would one sensibly do memoization of `h` such that f and g don't need to do repeated work?
04:24:25 <dminuoso> The way the code is structured I'd rather not precompute this [VLAN] list 
04:28:39 <MrAngel> Is https://gist.github.com/samcgardner/98c2bf2850e45b97a53dd9d7c0095504 an idiomatic use of parsec or should I always be generating a language def and using reservedOp and siblings?
04:30:03 <Lears> wikiemol: An equivalent but more curried and Haskelly way to define rho would be something like rho g h = f, where f 0 = g and f (n + 1) = h n (f n). If you try to write that with foldr it should be substantially more elegant.
04:31:46 <wikiemol> Lears Thanks, I was trying to avoid explicit recursion, but that is useful.
04:32:12 <merijn> MrAngel: I would probably recommend not starting new code using parsec and instead using Megaparsec (which I think drops the whole language def stuff anyway)
04:33:58 <wikiemol> Lears or maybe I am misunderstanding what you are saying?
04:34:08 <Lears> wikiemol: Right, I'm not saying write it explicitly recursively like this, I'm adapting the definition on wikipedia into one that fits Haskell better and will have a different (nicer) implementation through foldr.
04:34:08 <MrAngel> Hmm OK. Can you give me a one-line summary of the differences between megaparsec and parsec?
04:34:11 <merijn> MrAngel: The language def stuff is mostly about controlling what sort of error messages you get on failure anyway
04:34:36 <wikiemol> Lears Ooh I see
04:34:45 <merijn> MrAngel: parsec is old and while still maintained to keep things depending on it running, it is no longer actively developed and there's a few warts (like operators clashing with Applicative)
04:34:52 <wikiemol> hm
04:35:01 <merijn> That's mostly not parsec's fault, because it predates the existence of Applicative, but is annoying
04:35:05 <yasar> what does foldMap supposed to do?
04:35:52 <merijn> MrAngel: megaparsec started as a fork of parsec, dropping a lot of the cruft (i.e. replacing the operators with the ones from Control.Applicative, etc.) and then improving error messages, performance, etc. and generally just active development
04:36:13 <merijn> MrAngel: In terms of API/how to use they're pretty similar though, so porting parsec code to megaparsec should be trivial
04:36:43 <merijn> MrAngel: So I guess the one line summary is "megaparsec is parsec, but modern and actively improved"
04:36:55 <MrAngel> Alright cool, I'll give it a bash! Thanks very much
04:38:43 <merijn> MrAngel: As for the parsec itself, I'd probably instead write it like "asum [Add <$ char '+', Sub <$ char '-']"
04:38:43 <yasar> `fodMap f (Cons x xs) = f x <> foldMap f xs`
04:38:49 <merijn> :t (<$)
04:38:51 <lambdabot> Functor f => a -> f b -> f a
04:38:52 <merijn> :t asum
04:38:55 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
04:38:55 <yasar> am I understanding what foldMap supposed to do here?
04:39:20 <dminuoso> yasar: foldMap is arguably one of the most useful and coolest things we have! :)
04:39:30 <merijn> dminuoso: Correction, foldMap' is ;)
04:39:48 <dminuoso> merijn: If only that was in Prelude. ;)
04:40:08 <wikiemol> Lears This hurts my brain, but I think I see the fuzzy outline of a solution in the distance.
04:40:10 <dminuoso> yasar: foldMap is what foldr is trying to be. :)
04:40:50 <dminuoso> % foldMap Sum [1,2,3,4,5]
04:40:50 <yahb> dminuoso: Sum {getSum = 15}
04:40:53 <dminuoso> % foldMap Product [1,2,3,4,5]
04:40:53 <yahb> dminuoso: Product {getProduct = 120}
04:43:41 <boxscape> why didn't they put foldMap' into the Prelude when it was introduces
04:43:45 <boxscape> s/s/d
04:45:19 <MrAngel> merijn that's a very nice simplification, thank you :)
04:45:39 <Ailrun[m]> % getProduct . foldMap Product $ [1, 2, 3, 4, 5]
04:45:39 <yahb> Ailrun[m]: 120
04:45:56 <dminuoso> Ailrun[m]: Or better yet:
04:46:01 <dminuoso> % ala Sum foldMap [1,2,3,4,5]
04:46:02 <yahb> dminuoso: 15
04:46:35 <wikiemol> Lears Actually, Wouldn't  f (n + 1) = h n (f n) need to be something like f(n + 1, x) = h n (f n x)?   
04:46:40 <Ailrun[m]> Oh, that's way better.
04:46:55 <merijn> MrAngel: Gets rid of any warnings on partial patterns and much easier to read, imo. Also nicer if the list goes larger because line wrapping lists is easy ;)
04:47:08 <wikiemol> Lears do the types match up in f(n+1) = h n (f n) ?
04:47:16 <merijn> MrAngel: In general <$ is very nice for "I wanna parse some character/string, but return some constructor on success"
04:47:53 <MrAngel> Yeah I think it's very clearly better, I'm just not very good at Haskell-fu
04:48:00 <dminuoso> foldMap is right in the department of traverse-cool
04:48:49 <dminuoso> % getConst . forwards . traverse (Backwards . Const) $ ["foo", "bar", "quux"]
04:48:49 <yahb> dminuoso: "quuxbarfoo"
04:48:49 <e1fa> https://pastebin.com/eM9HmQuK
04:49:06 <e1fa> can someone help me understand why my two functions don't do the same thing?
04:49:18 <Lears> wikiemol: The wiki version is like f 0 x = g x, f (n + 1) x = h n (f n x) x. My adaption has different (simpler) types, but `h` is given `f n` and `x`, so it can make `f n x` if it wants it.
04:50:16 <dminuoso> e1fa: Can you include the output of both versions?
04:50:23 <wikiemol> Oooh so are you saying `h` itself now has a different type than the wikipedia version of h?
04:50:39 <wikiemol> Lears
04:50:41 <dminuoso> e1fa: Also, what is this trying to do?
04:51:09 <e1fa> dminuoso: it counts the number of elements that match the first argument, but only every third element in the list
04:51:33 <e1fa> they work for trivial inputs but one of my bigger tests is breaking
04:51:40 <dminuoso> e1fa: What does "breaking" mean
04:51:56 <dminuoso> e1fa: Does it error out? Does it give you a wrong result?
04:52:06 <e1fa> they don't both give me the same result
04:52:19 <Lears> wikiemol: Yeah, technically rho will have a differnt type too.
04:52:37 <e1fa> dminuoso: https://pastebin.com/J42XpS3Y
04:52:48 <wikiemol> Lears I see... very interesting, I will have to think about this
04:52:54 <e1fa> dminuoso: the first function gives 24 for this list, the second 258
04:53:15 <wikiemol> Lears That is very clever
04:53:34 <dminuoso> e1fa: Off by one error?
04:53:40 <yasar> I try to make my custom data type Foldable, but making some errors: https://gist.github.com/yasar11732/c1dcb381354877dcffaf3439b2c5e7ff
04:55:09 <boxscape> yasar should be `instance Semigroup (List a)`, same for Monoid
04:55:16 <wikiemol> Lears I have to go to work e_e but I will probably be thinking about this instead of the work I actually have to do
04:55:26 <wikiemol> Thank you for the help
04:55:44 <Lears> np
04:55:55 <dminuoso> e1fa: Ah no
04:56:00 <e1fa> dminuoso: i don't think so - i'm not doing any calculations, just filtering the list
04:56:41 <dminuoso> e1fa: Ah! How large are your non-trivial data?
04:56:49 <dminuoso> e1fa: Is it possible you are exceeding maxBound of Int?
04:57:45 <e1fa> dminuoso: the elements exceeding maxBound or the size of the list?
05:00:14 <e1fa> dminuoso: the maximum element in my non-trivial input is 41 and the size is 3024
05:01:53 <kuribas> e1fa: is the input a multiple of 3?
05:02:01 <e1fa> yes
05:02:51 <dminuoso> e1fa: Ah indeed, there's an off by one error in there
05:03:07 <kuribas> e1fa: also you compare the first element in one, and the third in the other
05:03:11 <dminuoso> e1fa: numThirdElem' starts with the 3third element, numThirdElem starts with the 0th
05:03:19 <yasar> What is wrong with `Nil` in lines 18 and 21? : https://gist.github.com/yasar11732/c1dcb381354877dcffaf3439b2c5e7ff
05:03:34 <dminuoso> % 0 `mod` 3 :: Int
05:03:34 <yahb> dminuoso: 0
05:03:38 <dminuoso> e1fa: ^- do you see why?
05:03:44 <e1fa> dminuoso: yeah i see that
05:04:02 <Rembane> yasar: What's the intended outcome and what do you get instead?
05:04:03 <e1fa> dminuoso: it doesn't explain why the results are off by 234 though
05:04:49 <yasar> Intended outcome is that it compiles, I am getting this error: https://gist.github.com/yasar11732/c1dcb381354877dcffaf3439b2c5e7ff#gistcomment-3110539
05:04:54 <kuribas> e1fa: it does
05:05:01 <kuribas> e1fa: you are comparing different elements
05:05:05 <e1fa> kuribas: i see it now
05:05:27 <Rembane> yasar: Oh. You need to give a type b back, you cannot give back a List. Nil is a constructor of List.
05:10:31 <yasar> Rembane, I get what you say about foldr, but what does foldMap supposed to return when given an empty monoid?
05:11:17 <Rembane> yasar: I think mempty is a good candidate there
05:13:19 <yasar> Hmm, converting Nil to mempty works, but I `mempty = Nil` anyways, so I am confused now
05:13:56 <boxscape> The Monoid that foldMap uses is (ususally) not the List instance, yasar
05:14:04 <boxscape> :t foldMap
05:14:06 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
05:14:19 <boxscape> it is the instance of m, whereas List is t
05:14:46 <yasar> Ahh, for some reason I thought I was supposed to return the instance of my class
05:15:07 <boxscape> yasar in fact you could make an instance for Foldable without making a List instance for Monoid
05:16:07 <yasar> My code works now, but I am curious if I got lucky, or if it is actually implemented correctly: https://gist.github.com/yasar11732/c1dcb381354877dcffaf3439b2c5e7ff
05:16:14 <yasar> can you guys have a look at it?
05:17:01 <boxscape> looks good to me
05:17:31 <Rembane> Looks good to me 
05:17:54 <Rembane> yasar: Are there any bits of it where you felt extra lucky?
05:20:09 <yasar> yasar: There are no particular bits, I was just guessing a lot while I was writing it :)
05:20:48 <Rembane> yasar: That's one of the nice things with having a reasonably powerful type system, it helps you guess correctly. :)
05:20:54 <Phyx-> @tell jusss 01:19:02 < jusss> ChaiTRex: it's really a pain to use haskell on windows or archlinux <--- citation needed
05:20:54 <lambdabot> Consider it noted.
05:21:36 <phadej> Phyx-: btw, is there an issue about cabal-install default locations?
05:21:51 <phadej> (on windows)
05:22:30 <phadej> it feels that there's increasing windows usage, as there _are_ windows related bugs reported (and also fixed!)
05:37:13 <bezirg> I really like that nowadays I can use the generic `Foldable.length` also for `Data.Map` and `Data.Set`, inplace of a specific `size` implementation. This does not hold though for the generic `Foldable.elem` impl. compared to the  specific `member`. I guess it is because of the constraint context `Eq` vs `Ord`. Theoretically, is there a way to fix this with a typeclass language extension?
05:38:19 <Solonarv> hmm
05:38:29 <Solonarv> it's certainly fixable with a different Foldable class
05:38:53 <Solonarv> but that would be less convenient in some other ways
05:39:06 <bezirg> Solonarv: would that break existing Foldable-dependent code you think?
05:40:25 <bezirg> Solonarv: I guess with an all-new class "Lengthable" :D
05:41:34 <Solonarv> actually I was thinking about a Foldable class where you are also allowed to say "elements must fulfill this constraint"
05:43:13 <Solonarv> class Foldable t where FoldableElem t a :: Constraint; foldMap :: ...; elem :: FoldableElem t a => a -> t a -> Bool; ...
05:43:35 <merijn> Solonarv: So...MonoFoldable?
05:43:49 <Solonarv> heh, I realized that as I was typing it
05:43:50 <merijn> @hackage mono-traversable
05:43:50 <lambdabot> http://hackage.haskell.org/package/mono-traversable
05:45:33 <Lears> That's quite different from MonoFoldable though.
05:45:50 <merijn> Lears: How so?
05:46:34 <dminuoso> MonoFoldable would be a degraded special case of what Solonarv is asking for.
05:46:36 <Solonarv> you can't write different instances for different type parameters
05:46:56 <Solonarv> and you can't write instances for e.g. ByteString, which doesn't have a type parameter at all
05:47:08 <dminuoso> Solonarv: MonoFoldable? Sure you can.
05:47:17 <dminuoso> Solonarv: That's the entire point of it.
05:47:24 <Solonarv> no, I meant of my special Foldable I defined above
05:47:46 <Lears> It's Foldable that lets you slip one constraint into one method (or more). It's not using the type family to replace the structure inherent to the class.
05:49:00 * Solonarv thinks about class Monoid w => Measurable a w where measure :: a -> w
05:49:57 * Solonarv and a convention to have instances like: instance Measurable [a] (Sum Int) where measure = Sum . Prelude.length
05:54:19 <opqdonut> surely "instance (Foldable t, Measurable a w) => Measurable (t a) w" :)
05:54:39 <opqdonut> I guess a "Monoid w" constraint as well
05:55:01 <Solonarv> that's already a superclass of Measurable a w, so not needed
05:55:15 <Solonarv> and well, I guess one can be written
05:56:32 <Solonarv> bah! let's just write lengthOf (_ :: Fold s a) so we know how many layers of nesting we are traversing ;)
05:57:50 <yasar> I am having problems with types again : https://gist.github.com/yasar11732/c1dcb381354877dcffaf3439b2c5e7ff
05:59:12 <Solonarv> yasar: okay there are actually two separate problems there
05:59:31 <Solonarv> the first one is a syntax mistake: you wrote (uncurry /)
05:59:47 <Solonarv> that is valid syntax, but it means: \x -> uncurry / x
06:00:13 <Solonarv> which does not make a lot of sense and is surely not what you meant!
06:00:28 <yasar> I wanted to uncurry division :)
06:00:50 <Solonarv> thought as much
06:01:05 <Solonarv> when you want to refer to an operator as a function, you have to surround it in parentheses
06:01:11 <Solonarv> like so: (/)
06:03:43 <yasar> Solonarv, following your suggestion, code is fixed only if I remove the type signature
06:03:58 <Solonarv> yes, that is the other problem
06:04:38 <Solonarv> namely: your type signature says the function accepts a List a, so long as Num a holds
06:05:06 <Solonarv> but then you try to perform division on values of type 'a'
06:05:11 <yasar> I was thinking you could only average numbers
06:05:25 <Solonarv> you can't do that; Num a doesn't provide division!
06:05:51 <Solonarv> the type of (/) is:
06:05:55 <Solonarv> :t (/)
06:05:56 <lambdabot> Fractional a => a -> a -> a
06:07:32 <yasar> I can call it with list of Num's though
06:07:48 <ChaiTRex> yasar: Try calling it with a list of Integers.
06:08:37 <Solonarv> your type signature promises that avgList works for all 'a', so long as 'Num a' holds
06:08:56 <Solonarv> but actually, the way you have written the implementation it only works if 'a' is exactly 'Float'
06:09:27 <ChaiTRex> > (5 :: Integer)/(6 :: Integer)
06:09:29 <lambdabot>  error:
06:09:30 <lambdabot>      • No instance for (Fractional Integer) arising from a use of ‘/’
06:09:30 <lambdabot>      • In the expression: (5 :: Integer) / (6 :: Integer)
06:10:23 <yasar> So, you can't divide an Integer in Haskell to get a float?
06:10:45 <boxscape> > fromInteger 5 / 7
06:10:46 <ChaiTRex> yasar: Only if you convert the Integer to a Floating type.
06:10:48 <lambdabot>  0.7142857142857143
06:10:57 <ChaiTRex> yasar: Sorry, Fractional type.
06:11:02 <boxscape> uh actually what I wrote is misleading
06:11:18 <boxscape> > fromIntegral (5 :: Int) / fromIntegral (7 :: Int)
06:11:22 <lambdabot>  0.7142857142857143
06:11:47 <Solonarv> yasar: correct, you have to explicitly convert the numbers to something float-ish first
06:12:27 <Solonarv> there are no implicit type conversions anywhere in Haskell
06:12:46 <boxscape> I can never remember what Fractional and what Floating is
06:12:53 <Solonarv> me neither tbh
06:13:17 <Solonarv> the numeric typeclass hierarchy is organized kind of weirdly and the names don't always make a ton of sense
06:13:22 <ChaiTRex> Fractional is better, since Rational works with (/) and it's not a floating point.
06:14:02 <Solonarv> anyway the conversion you probably want is
06:14:05 <Solonarv> :t realToFrac
06:14:07 <lambdabot> (Real a, Fractional b) => a -> b
06:14:39 <Solonarv> % :i Real
06:14:39 <yahb> Solonarv: pattern Real :: (Eq a, Num a) => a -> Complex a -- Defined in `Data.Complex.Lens'; class (Num a, Ord a) => Real a where; toRational :: a -> Rational; {-# MINIMAL toRational #-}; -- Defined in `GHC.Real'; instance forall a k (b :: k). Real a => Real (Const a b) -- Defined in `Data.Functor.Const'; instance Real a => Real (Identity a) -- Defined in `Data.Functor.Identity'; instance Real Int8 -- Def
06:15:01 <boxscape> hm, I'm not sure I've ever actually used realToFrac
06:18:32 <yasar> is there a typeclass for comparing monoids?
06:18:56 <boxscape> what does it mean to compare two Monoids?
06:19:20 <yasar> I have my own version of a list data structure
06:19:35 <yasar> I want to check if one instance is equal to another
06:19:58 <boxscape> That sounds like the sort of thing that's undecidable, considering you'd have to compare functions
06:20:00 <Solonarv> ah, you want to check that it matches the Monoid [a] instance?
06:20:39 <yasar> No, just MyList([1,2,3]) == MyList([1,2,3])
06:20:45 <boxscape> s/undecidable/undecidable in general
06:20:49 <Solonarv> it's undecidable in general, but in specific cases it is tractable
06:21:37 <Solonarv> uhh... that equality doesn't mean anything
06:21:55 <Solonarv> I mean, it's obviously true, because you just wrote the same thing twice
06:22:01 <Solonarv> obviously a thing is equal to itself!
06:22:35 * Solonarv grumbles: unless it's an IEEE 754 float that happens to be NaN...
06:22:56 <boxscape> do you want to make sure (toList (a <> b) == toList a <> toList b) for all Lists a and b or something like that?
06:23:00 <yasar> Hmm, it seems like I just want an instance of Eq (List a)
06:23:10 <boxscape> ah, yeah that sounds reasonable
06:23:51 <Solonarv> the cheeky answer is of course to just let GHC derive it for you by adding 'Eq' to your 'deriving' clause
06:23:54 <yasar> I was just thinking maybe there is an typeclass like MonoidComparable
06:24:18 <boxscape> What would that typeclass do?
06:24:21 <Solonarv> but that way you won't learn how Eq actually works (which is quite simple, really)
06:24:45 <boxscape> Solonarv not to mention that the same could be said about Foldable
06:25:18 <Solonarv> at least there I have the excuse of saying "oh, but you need t enable a GHC extension for that, how spooky!" :P
06:25:23 <boxscape> true
06:25:23 <yasar> It could be for container like things that can be compared
06:25:50 <ChaiTRex> yasar: Ord already does that, I think.
06:26:21 <Solonarv> there is also Eq1 / Ord1 but you don't really need to touch those and hopefully they will become obsolete eventually
06:26:57 <merijn> Ordering has a Monoid you can use
06:27:21 <Solonarv> you're jumping ahead
06:27:29 <boxscape> Solonarv what would make them obsolete?
06:27:51 <Solonarv> yasar: what are you trying to do? are you trying to make it so you can compare two 'List a' values using == and /= ?
06:28:06 <Solonarv> boxscape: QuantifiedConstraints
06:28:29 <boxscape> don't we already have -XQuantifiedConstraints?
06:28:53 <Solonarv> yes, but there are still a few vague issues with it IIRC and more importantly most code has not yet switched to using it
06:28:57 <boxscape> I see
06:30:41 <boxscape> Technically you could make an `instance (Foldable t, Eq a) => Eq (t a)` but it seems like that would be very annoying because often you'd want a different instance
06:30:43 <Solonarv> yasar: anyway, to "compare" things we have the 'Eq' typeclass (which only does equality) and the 'Ord' typeclass (which also does ordering: < > <= >= )
06:31:10 <Solonarv> boxscape: wouldn't you also need Applicative or something?
06:31:19 <boxscape> :t toList
06:31:21 <lambdabot> error:
06:31:21 <lambdabot>     Ambiguous occurrence ‘toList’
06:31:21 <lambdabot>     It could refer to either ‘F.toList’,
06:31:26 <Solonarv> oh, right
06:33:54 <boxscape> If we had a typeclass for zipping an instance for that might make more sense
06:34:04 <boxscape> though I could be missing something there
06:34:44 <yasar> I think I got it : https://gist.github.com/yasar11732/c1dcb381354877dcffaf3439b2c5e7ff#file-listadt-hs-L24
06:34:53 <boxscape> But I guess that's actually just kind of Applicative?
06:35:58 <Solonarv> yes, "zipping" is a valid Applicative
06:36:04 <merijn> boxscape: These had a typeclass for that
06:36:19 <boxscape> as in, the package `these`?
06:36:26 <merijn> Oh, that got split into the package semialign
06:36:29 <Solonarv> yasar: yup, looks good to me
06:36:31 <merijn> https://hackage.haskell.org/package/semialign
06:36:31 <boxscape> I see
06:37:51 <boxscape> ah, yeah in retrospect it's obvious why These would be helpful
06:39:20 <Ailrun[m]> :t Data.Map.toList
06:39:22 <lambdabot> M.Map k a -> [(k, a)]
06:42:44 <phadej> merijn: 2019 is a bit of "a package with a single module with a single type class with a single member" year for me
06:43:30 <phadej> searching for a good balance
06:43:35 <nil> consider this program:  main = print =<< (map read . lines <$> getContents :: IO [Integer])
06:43:54 <nil> i'm getting different results whether i run it with `runhaskell`, or compile it first and run the executable
06:44:23 <nil> with runhaskell, if i type a number and press enter, it starts displaying the list lazily
06:44:37 <nil> with the compiled executable, it only displays the entire list on EOF
06:44:57 <nil> what's going on?
06:45:06 <MarcelineVQ> probably the line buffering mode
06:45:14 <nil> *facepalm*
06:46:15 <nil> well, no, actually
06:46:47 <nil> oh sorry yeah, that was it.
06:46:58 <nil> stdout buffering
06:47:09 <Solonarv> lazy IO T_T
06:47:37 <nil> weirdly enough, setting the buffering to LineBuffering on stdout doesn't fix it, it has to be NoBuffering
06:47:38 <Cale> To be fair, it's not lazy IO's fault there.
06:47:52 <nil> yeah, my bad. totally forgot about buffering
06:48:36 <Solonarv> nonlazy IO would make it consistent at least: nothing would get printed in either case until eof is reached
06:48:40 <Solonarv> at least I think so
06:52:20 <black0range> Hey! I'm wondering if there's some way to do parital function application on the type level in haskell. More exactly. I'm trying to do Type level function composition. But ghc keeps telling me I haven't applied all arguments to the type
06:53:07 <Cale> black0range: Type synonyms can't be partially applied
06:53:20 <Cale> But actual types can
06:54:30 <black0range> Cale: It is also impossible with type families?
06:54:41 <Cale> Yeah
06:54:48 <merijn> phadej: My packages tend to be rather small too :p
06:55:04 <merijn> phadej: I have two that are literally just a single module :p
06:55:11 <Cale> Well, type families have to be applied at least to their explicit arguments
06:55:24 <merijn> Cale: Everyone *always* blames lazy IO for everything that isn't actually lazy IO >.>
06:56:22 <Cale> But you can have a type family which takes some parameter and gives a result of kind * -> * and then you're allowed to only apply it to the first parameter. It's just that the family can't then make choices based on the second parameter
06:57:55 <Cale> I love how in Linux Mint (and presumably anything ultimately based on Debian/Ubuntu), removing n kernel image packages is an O(n^2) operation.
07:00:00 <Cale> (after removing each one, it does a bunch of stuff where the amount of time it takes depends on how many kernels you have installed)
07:00:54 <Solonarv> I have a two-module package
07:01:03 <Solonarv> technically it could be split in two
07:01:13 <black0range> Cale: Hmm how would you go about to encode what I'm trying to do here? https://paste.ee/p/R62Kt
07:01:38 <Cale> I wouldn't use a type synonym
07:01:50 <Cale> data Compose f g x = Compose { getCompose :: f (g x) }
07:01:54 <Cale> this is already in the libraries
07:02:24 <black0range> Ohh, let me try it out! :)
07:02:36 <Cale> also, you can't write instances for type synonyms or families either, so that wouldn't help you -- but you can write instances for Compose
07:02:47 <yasar> Getting another type error in sortList : https://gist.github.com/yasar11732/c1dcb381354877dcffaf3439b2c5e7ff#file-listadt-hs-L54
07:05:05 <Cale> yasar: Can you add a type signature to sortList? If there isn't one already, adding one will probably make those errors clearer.
07:08:39 <yasar> Cale, adding type signature actually removes the error :/
07:10:26 <Cale> yasar: Yeah, those errors were basically complaining that GHC wasn't sure what type you wanted to use foldr at
07:10:36 <Cale> It's a combination of a couple of things
07:12:01 <Cale> There's a somewhat silly restriction on by default which means that pattern bindings (i.e. definitions of things which don't have an explicit function argument), which don't have explicit type signatures, are required not to be type class polymorphic
07:12:31 <Cale> (the reason for this is that they look like definitions of constants, but they will be recomputed each time they're used, like functions)
07:14:05 <Cale> and that, combined with the fact that foldr is now polymorphic in what type of container it acts on (it works not just for lists), means that GHC gets confused about which type it's supposed to use there
07:14:35 <Cale> Another way to fix the problem would be to add an explicit function parameter, GHC would be able to give sortList a rather polymorphic type then
07:14:54 <Cale> i.e.  sortList xs = foldr insertList Nil xs
07:14:54 <loli> the lovely monomorphism restriction
07:14:58 <Cale> yeah
07:15:14 <loli> sometimes i have to do that with my monads so I can place the inferred type in the file
07:15:26 <Cale> You can also just turn off the monomorphism restriction by adding {-# LANGUAGE NoMonomorphismRestriction #-} to the top of your file
07:15:57 <Solonarv> do type wildcards work?
07:16:03 <Solonarv> foo :: _; foo = ...
07:16:11 <Cale> Good question!
07:16:15 <Solonarv> GHC should tell you what it thinks _ is
07:16:17 <yasar> Cale, doing so, I can sort any foldable into my Monoid :)
07:16:22 <yasar> which is pretty good actually
07:16:22 <Cale> yeah
07:16:23 <loli> Solonarv: that is a thing?
07:16:26 <Solonarv> yes!
07:16:26 <loli> I can place holes in types now?
07:16:41 <loli> so if I don't know two arguments or end a -> early to place my effects ghc can do the rest?
07:20:50 <kuribas> loli: yes
07:20:51 <geekosaur> normally it throws an error which tells you the type of the hole; there's an extension to have it keep going with the inferred type
07:22:01 <loli> hmm it seems to yell at me if I have 'f :: EffectfulMonad m => _`
07:22:18 <geekosaur> PartialTypeSignatures?
07:22:23 <loli> let me enable that
07:23:07 <loli> even with that it yells me about effect constraints
07:23:16 <loli> • Could not deduce (HasThrow "err" Codegen.Errors m0)
07:23:18 <loli> what a shame
07:23:44 <loli> maybe aliases don't play nicely with it?
07:27:43 <geekosaur> it may be inferring too general a type. it can't infr *all* types for you
07:27:52 <geekosaur> or we would never need type signatures at all
07:28:39 <loli> well, without a type signature the function infers fine
07:28:54 <geekosaur> that sounds like a bug, then
07:29:08 <loli> often though, through argument changes (passing in HOF) I want to preserve my alias in the generated type
07:46:16 <dmwit> tired: foo :: _ -> Int
07:46:21 <dmwit> wired: foo :: _ String Int
07:51:10 <Ariakenom> fired :: String `_` Int
07:51:45 <boxscape> mired _ String -> Int
07:54:18 <boxscape> loli I think you can have inferred constraints as well, like `f :: _ => EffectfulMonad m => _`
07:54:37 <boxscape> though I'm not sure if it works in this usecase
07:55:07 <loli> well the EffectfulMonad here is the only monad I need for this case, though that is nice if it can do that
07:55:14 <boxscape> ah,I see
07:55:25 <loli> it seems to infer some M0 which should collapse into m
07:56:04 <loli> just a bit annoying, as if I don't alias my effects, there ends up with 5-6 lines of them
07:56:10 <loli> so I try to alias things before hand based on reasoning
07:56:26 <boxscape> loli by any chance, are you using m in a signature in the function body?
07:56:41 <loli> not in this case, only in the output
07:57:12 <boxscape> hm, okay. I was thinking maybe you need ScopedTypeVariables or forall but in that case probably not
07:57:33 <loli> addData ∷ Codegen.RetInstruction m ⇒ Operand.Operand → Operand.Operand → m ()
07:57:35 <loli> I was doing it on this IIRC
07:58:00 <boxscape> unicode arrows, fancy
07:58:13 <loli> yeah, our code formatters places them
07:58:26 <boxscape> interesting
08:00:07 <boxscape> I imagine what's happening is that ghc doesn't know it's supposed to be using m to fill the hole and so creates a new m0
08:01:30 <yasar> is there a prelude function in the form (a -> a -> Ordering) that compares numbers?
08:01:33 <loli> ahh and since I don't have a `_ =>` it fails?
08:01:53 <boxscape> loli I think so, yeah
08:02:02 <boxscape> :t compare
08:02:04 <lambdabot> Ord a => a -> a -> Ordering
08:02:07 <boxscape> ^ yasar
08:02:17 <geekosaur> yasar: compare is polymorphic. if you mean, does it allow different `a`s, then no
08:02:24 <geekosaur> and the type system wouldn't allow such
08:02:50 <loli> boxscape: quite a shame then, as I would mainly use it argument inferencing with set aliases
08:02:52 <geekosaur> well. I guess someone did one sort of, one of the silly acme modules that pretends iirc to be php
08:03:18 <boxscape> loli though I'm not entirely sure why it wouldn't just be able to make its own constraints on the other side, like _ => InferredConstraint => type, so maybe something more is going on
08:03:25 <geekosaur> you do not in general want implicit conversions because the compiler is not smart and will do unexpected things
08:03:38 <geekosaur> or it goes through Double and you get bitten by floating point, etc.
08:03:43 <boxscape> okay maybe that notation was confusing
08:05:24 <geekosaur> (or to put that in type terms: ((Num a, Num b) => a -> b -> Ordering) is a bad idea)
08:05:50 <geekosaur> but I'm not quite clear whether you were just asking for compare, or for that monstrosity above
08:14:01 <Pamelloes> I currently have a function of the form (m Int) -> m () where the first parameter is run periodically to provide input values for the computation. If I define `data Result = Done | Input (Int -> Result)`, can I turn the function into something with type Result?
08:15:59 <merijn> Pamelloes: Assuming the implication is that 'm' is a monad, not really
08:16:28 <merijn> Pamelloes: But I think we may need more details on waht you're doing
08:17:38 <Pamelloes> Yeah, m is a monad.
08:18:11 <merijn> Pamelloes: Why do you wanna turn it into that datatype?
08:19:52 <c_wraith> this looks like an introductory exercise for dealing with free monads
08:20:30 <Pamelloes> I'm working on Advent of Code. The function in question runs an int code program given input and output functions. Now, I need to run multiple programs in parallel, so I want to invert control over the program from this function to its caller, so I can switch contexts
08:21:04 <Pamelloes> I can easily accomplish this by just rewriting the existing function, but that would be less interesting :)
08:21:10 <merijn> c_wraith: That's where I was going, yes :)
08:41:56 <nil> i'm confused about how lazy IO works.
08:42:22 <nil> % let go n = (n:) <$> go (n+1) in print . head =<< go 0
08:42:27 <yahb> nil: [Timed out]
08:42:52 <nil> i'd expect this to lazily consume the first 0 and print it. i feel like i'm fundamentally misunderstanding something
08:43:56 <yasar> show doesn't type check: https://gist.github.com/yasar11732/c1dcb381354877dcffaf3439b2c5e7ff
08:44:12 <kuribas> nil: that doesn't look lazy
08:44:26 <nil> how would you make it lazy?
08:44:30 <kuribas> nil: unsafeInterleaveIO
08:44:38 <nil> oh
08:44:47 <kuribas> unsafeInterleaveIO print instead of print
08:45:51 <nil> % let go n = (n:) <$> go (n+1) in unsafeInterleaveIO . print . head =<< go 0
08:45:57 <yahb> nil: [Timed out]
08:46:11 <kuribas> nil: no dot between unsafeInterleaveIO and print
08:46:19 <kuribas> nil: also put parens around it
08:46:48 <nil> please do it, i don't see how you mean
08:47:42 <kuribas> % let go n = (n:) <$> go (n+1) in unsafeInterleaveIO print . head =<< go 0
08:47:43 <yahb> kuribas: ; <interactive>:1:33: error:; * Couldn't match expected type `Integer -> m b' with actual type `IO a0'; * Possible cause: `unsafeInterleaveIO' is applied to too many arguments; In the first argument of `(.)', namely `unsafeInterleaveIO print'; In the first argument of `(=<<)', namely `unsafeInterleaveIO print . head'; In the expression: unsafeInterleaveIO print . head =<< go 0
08:48:00 <nil> it's IO a -> io q
08:48:04 <nil> it's IO a -> IO a *
08:48:05 <kuribas> % let go n = (n:) <$> go (n+1) in (unsafeInterleaveIO . print) . head =<< go 0
08:48:10 <yahb> kuribas: [Timed out]
08:48:16 <kuribas> hmm
08:48:20 <nil> composition is associative.
08:49:45 <kuribas> nil: what's the type of go?
08:49:49 <geekosaur> isn't unsafeInterleaveIO more useful for input, anyway?
08:50:18 <kuribas> ah indeed
08:50:39 <kuribas> this tries to print the largest integer
08:50:40 <nil> kuribas: (once specialised,) IO [Integer]
08:50:46 <kuribas> which doesn't exist
08:50:52 <nil> what
08:51:10 <nil> the list that is being built is 0:1:2:...
08:52:02 <geekosaur> isn't it tacking numbers on the front, then taking the head?
08:52:15 <geekosaur> so max_int : ...
08:52:19 <yasar> Does it make sense for a Tree structure to be a Monoid?
08:52:36 <kuribas> :t let go n = (n:) <$> go (n+1) in go
08:52:37 <geekosaur> but the largest Integer is the largest one that fits in memory
08:52:38 <lambdabot> (Functor f, Num t) => t -> f [t]
08:53:15 <nil> geekosaur: no
08:53:16 <kuribas> I think it's something else...
08:53:24 <kuribas> nil: the type of go is weird
08:53:38 <Pamelloes> go is bottom
08:54:23 <kuribas> nil: go doesn't do any IO
08:54:32 <nil> ..fine
08:54:40 <kuribas> % let go n = (n:) <$> go (n+1) in go 0
08:54:46 <yahb> kuribas: [Timed out]
08:54:47 <nil> % let go n = do print "hi kuribas"; (n:) <$> go (n+1) in print . head =<< go 0 
08:54:53 <yahb> nil: "hi kuribas"; "hi kuribas"; "hi kuribas"; "hi kuribas"; "hi kuribas"; "hi kuribas"; "hi kuribas"; "hi kuribas"; "hi kuribas"; "hi kuribas"; "hi kuribas"; "hi kuribas"; "hi kuribas"; "hi kuribas"; "hi kuribas"; "hi kuribas"; "hi kuribas"; "hi kuribas"; "hi kuribas"; "hi kuribas"; "hi kuribas"; "hi kuribas"; "hi kuribas"; "hi kuribas"; "hi kuribas"; "hi kuribas"; "hi kuribas"; "hi kuribas"; "hi kuribas"; "hi kuribas"; "hi kuriba
08:55:30 <kuribas> nil: that's not the same function
08:55:34 <Pamelloes> nil: The issue is, you probably don't want `<$>`
08:55:46 <nil> Pamelloes: what should i use instead?
08:56:32 <kuribas> :t let go n = do print "hi kuribas"; (n:) <$> go (n+1) in go
08:56:35 <lambdabot> Num t => t -> IO [t]
08:57:14 <Pamelloes> nil: That depends, what are you trying to do?
08:57:33 <nil> solve AoC day 13
08:58:18 <Pamelloes> I guess, specifically, what are you trying to do with `go`?
08:58:23 <zeta_0> hello there, i would like to contribute to ghc, but i am not sure where to start, is there anyone here that wouldn't mind guiding me through the process?
08:58:27 <nil> i don't know if you're familiar with this year's challenges, but there's this "intcode" language that we need to simulate on some kind of virtual machine, and i'm implementing that as a [Integer] -> IO [Integer] function that takes a list of inputs and produces a list of outputs
08:58:51 <kuribas> % let go n = (n:) <$> unsafeInterleaveIO (go (n+1)) in  print . head =<< go 0
08:58:52 <yahb> kuribas: 0
08:58:57 <kuribas> nil: ^^^
08:59:00 <nil> the key thing is that this list needs to be "lazy", so that you can start reading output before having fed the entire input
08:59:29 <kuribas> nil: the unsafeInterleaveIO was in the wrong place
08:59:46 <nil> kuribas: i'll look into that
08:59:47 <Pamelloes> ^ That looks right :)
09:00:46 <kuribas> nil: by default IO is strict, even if you use pure values
09:01:46 <nil> what's incredibly weird is i did day 7 using my current implementation and it worked fine. day 7 also required some sort of lazy IO since we had to run 5 simulators in parallel and connect their inputs and outputs in a cycle
09:01:56 <nil> ( https://git.monade.li/aoc/tree/2019/7.hs )
09:02:14 <kuribas> % undefined >> pure 1 >>= \x -> pure (x+1) >>= print
09:02:14 <yahb> kuribas: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:2:1 in interactive:Ghci5
09:02:21 <nil> but for some reason something in day 13 breaks that laziness
09:02:41 <nil> % unsafeInterleaveIO undefined >> pure 1 >>= print
09:02:41 <yahb> nil: 1
09:02:46 <nil> i see.
09:03:27 <nil> i guess the use above (fmap f (unsafeInterleaveIO m)) is always safe? since we're not actually interleaving anything?
09:03:27 <__monty__> nil: It's doubtful you want lazy IO.
09:03:53 <nil> __monty__: my simulator runs in IO (it uses references and such https://git.monade.li/aoc/tree/2019/Intcode.hs)
09:04:05 <kuribas> nil: unsafeInterleaveIO is not really unsafe, it just makes the order of the IO unpredictable.
09:04:16 <nil> so the other choice is to completely refactor the interpreter, which isn't completely unreasonable, but i would still like to understand how lazy IO works
09:04:24 <nil> kuribas: ok
09:04:37 <kuribas> nil: it does the IO whenever the value of the thunk is requested.
09:04:43 <nil> yeah, got it
09:04:46 <kuribas> which can be never
09:09:13 <yasar> when I define `data Tree a = ...`, can I force `a` to be instance of  `Ord`?
09:10:29 <nil> you can enforce that on instances you define for Tree
09:10:40 <nil> (or functions)
09:11:13 <yasar> But tree doesn't even make any sense if `a` is not an instance of `Ord`
09:11:55 <nil> it doesn't have to make sense as Tree by itself doesn't have any functionality. it's just a data type
09:12:06 <Taneb> yasar: you used to be able to, but it wound up meaning you needed to add the constraint to every function, even those that don't use the Ord constraint at all (like "singletonTree", maybe)
09:12:14 <nil> you want Ord a when you start doing operations on trees
09:12:35 <loli> Wouldn't you have the construct be a GADT that constraints the constructor's domain?
09:13:42 <__monty__> Taneb: Isn't that still possible? It doesn't do what yasar expects but afaik it's still valid haskell?
09:14:53 <Taneb> __monty__: I thought you needed an extension now? I may be wishful thinking
09:16:19 <__monty__> No, you seem to be right. It's yelling at me to use DatatypeContexts.
09:17:01 <__monty__> I guess I presumed more adherence to the report.
09:20:09 <day> i know that ByteString is used for binary data but what do i need to use for individual bytes? my research tells me i should use 'Char' in combination with 'OverloadedStrings', is that correct?
09:20:34 <Taneb> day: no. It'd be a lot better to use Word8 from Data.Word
09:20:50 <Taneb> Char is a unicode codepoint (roughtly)
09:21:31 <day> yeah i wasnt sure how haskell would understand the difference between Char/String and Char/Bytestring
09:21:55 <Taneb> Generally using Bytestring for text is a bad idea, as well
09:23:23 <day> c taught me that it should be fine as long as you dont tinker around with it too much ^_^
09:23:58 <Taneb> It's a bad habit, because tinkering around with things too much is the most fun thing to do in the world
09:39:03 <koz_> And you never know when 'tinkering' is needed for your use case.
09:39:47 <Rembane> "Just one little piece of undefined behaviour..."
09:41:01 <koz_> In Haskell, there is (almost) no excuse to be unprincipled in this manner.
09:42:25 <Rembane> And if there is, others have been that for you so you don't have to. 
09:43:33 <dsal> What an unacceptably useless language. https://usercontent.irccloud-cdn.com/file/4wQcj36z/error.png
09:45:29 <sm[m]> dsal: curious.. what should it say ?
09:45:46 <dsal> It should say, "Hey, that's a nice character.  I will allow it."
09:45:55 <sm[m]> aha
09:46:16 <sm[m]> is it from a later version of unicode than ghc supports ?
09:46:17 <dsal> emoji in generally really wrecks that formerly-known-as ascii art though.
09:46:23 <dsal> Probably.
09:48:38 <dsal> Characters interfere with nearby characters in sad ways:  https://asciinema.org/a/LAs6JigTtwRYvAr5uRXOwXqSF
09:49:50 <dsal> I tried being festive and that was just a non-starter... https://usercontent.irccloud-cdn.com/file/BquBh6KD/christmas
09:50:37 <AWizzArd> amx: Where did you overwrite the Content-Type manually? On the client side or in your server side code?
09:50:41 <Rembane> dsal: What are you trying to be festive in? 
09:51:42 <dsal> Rembane: Last night's AoC.  I wanted to use Christmas trees as the block character.  But they're not as fixed width as I'd like.
09:52:58 <dsal> I'm using a smiley as the ball, but messes up the right wall by being just a little too wide.
09:53:28 <Rembane> dsal: Lovely! Can you count the character length in another way? 
09:53:39 <Rembane> dsal: Or is the problem in another place? 
09:54:15 <dsal> It's not the length, it's the glyph's width.  The real answer is pretty much "don't do that."
09:54:23 <Rembane> got it! 
09:54:33 <Rembane> And: Meh! 
09:55:05 <dsal> I should probably do a graphical graphics, but then I'd have to think harder.
09:55:09 <solonarv> obviously the solution is to put \t between the characters
09:55:28 <solonarv> ..and set tab width to something much smaller than it usually is
09:55:37 <dsal> It kind of sounds like you're joking...
09:58:21 <dsal> Heh, asciinema deals with it even worse than my terminal: https://asciinema.org/a/287842
10:00:19 <solonarv> I started out joking but then I remembered tab width is configurable
10:01:54 <dsal> Yeah.  I've done some pretty cool things that started out as jokes.
10:07:12 <glguy> jle`: What're the advantages of conduino over conduit? Few dependendencies? Other?
10:14:01 <dmwit> dsal: It gets even worse. Not all terminals agree on which characters are doublewidth.
10:14:18 <dsal> dmwit: Yeah.  I figure if I see one bad thing, I assume it's a dark path.
10:17:37 <dmwit> dsal: You might find this #xmonad snippet relevant to your interests: https://gist.github.com/dmwit/bd93424fa26e8aeb2dd0b4b30723ddf5
10:19:03 <dmwit> > generalCategory '\129521'
10:19:05 <lambdabot>  NotAssigned
10:20:23 <dmwit> Looks like that particular one is newer than the Unicode spec GHC uses.
10:20:58 <dmwit> Not sure whether the Report specifies a Unicode version. I'm not even sure whether I *want* it to or not. Probably... yes?
10:21:02 <dsal> I'm not a huge fan of putting color pictures in fonts in general.  Though reading "Because Internet" at least made me a little more sympathetic.
10:27:34 <t7> can i do more complex list patterns in haskell somehow? for instance    f (xs ++ [1] ++ zs) = ...
10:29:42 <solonarv> t7: not like that, no
10:29:42 <dsal> You can use a guard, but that effectively means "only match this if an infinitely long list has a 1 and possibly more stuff after it"
10:30:02 <solonarv> you can only use *constructors* in pattern matches
10:30:10 <solonarv> the list constructors are : and []
10:30:40 <solonarv> (when you write [x,y,z[ this is the same thing as (x:y:z:[]) )
10:31:17 <t7> I have clearly misrepresented my knowledge of haskell :)
10:31:41 <t7> is there a library or something 
10:31:49 <solonarv> hmm
10:32:01 <solonarv> well, you can do *some* things with ViewPatterns
10:32:04 <solonarv> those are pretty neat
10:32:08 <nil> what part of Haskell's (or GHC's) semantics guarantee that an IO action will not be evaluated twice? i understand that the sequencing is done using a state token, but that doesn't seem to force the compiler to only evaluate things once
10:33:10 <solonarv> vague off-the-cuff response: it doesn't *force* ghc to sequence things correctly, but it makes it much easier to ensure that it is sequencing things correctly
10:35:33 <nil> ok
10:35:59 <solonarv> t7: but that example pattern you gave is ambiguous
10:36:04 <solonarv> which is really inconvenient
10:36:38 <Phyx-> phadej: yes, you mean this one? https://github.com/haskell/cabal/issues/4597
10:36:45 <solonarv> how should [1,1] be matched against it? xs=[1] zs=[], or xs=[], zs=[1] ?
10:36:58 <Ariakenom> IO is built in. I don't really buy any explanation of it using the "normal" pure, lazy semantics.
10:37:43 <solonarv> also true
10:41:16 <phadej> Phyx-: ok, let me think about that. Maybe it's not going into 3.2, but having config (~/.cabal/config) and cache (~/.cabal/store) in the same directory feels wrong. We have an issue about using XDG directories on unixes (IIRC they are wrong for windows for directory too, I remember seeing some discussion)
10:42:37 <dmwit> t7: You want
10:42:42 <dmwit> ?hackage split
10:42:42 <lambdabot> http://hackage.haskell.org/package/split
10:43:01 <dmwit> t7: ...or just admit you're really doing parsing, and use a parser combinator library or happy. ;-)
10:44:25 <phadej> Phyx-: i.e. https://github.com/haskell/cabal/issues/680 (so nice to finally work on decade old issue); it would be very nice if you could open according issues in directory, I'd be happy to try to do it properly, fixing across the stack
10:44:38 <dmwit> :t \(break (1==) -> (xs, _:zs)) -> (xs, zs)
10:44:40 <lambdabot> (Eq a, Num a) => [a] -> ([a], [a])
10:44:54 <dmwit> t7: ^ or something like that, I guess.
11:00:32 <Phyx-> phadej: I'm not home this weekend but will do so when I'm back
11:12:23 <phadej> Phyx-: thanks!
11:26:02 <aplainzetakind> Where is the MonadState s instance of State s?
11:27:00 <merijn> aplainzetakind: State is a type synonym for StateT s Identity
11:27:07 <aplainzetakind> Yes.
11:27:21 <monochrom> package mtl, module Control.Monad.State maybe
11:27:32 <aplainzetakind> I'm importing Control.Monad.Trans.State as well as .Class
11:27:53 <monochrom> That one doesn't have it. And its package is transformers.
11:27:59 <aplainzetakind> Oh never mind.
11:28:12 <aplainzetakind> I forgot to derive stuff for my newtype, my bad.
11:28:13 <monochrom> transformers purposefully defines StateT but not the class or the instance.
11:28:18 <monochrom> Oh haha
11:28:54 <monochrom> and mtl purposefully just imports and re-exports StateT, adding only the class and the instance.
11:29:22 <monochrom> some kind of peace treaty arrangement back then when they agreed to be unified.
11:30:04 <monochrom> United Kingdom of Transformers And Classes
11:44:18 <t7> Can i pattern match on a qualified type constructor? eg     A.B c -> ...
11:44:33 <merijn> t7: I would expect so
11:45:10 <monochrom> type constructor? data constructor?
11:45:21 <t7> yeah Data constructor sorry
11:45:26 <monochrom> Yes.
11:45:38 <monochrom> But still need to be imported.
11:48:36 <zeta_0> i want to contribute to ghc but i am not sure where to start: https://gitlab.haskell.org/ghc/ghc/issues
11:48:50 <zeta_0> is there a beginners section with smaller problems?
11:49:03 <dsal> zeta_0: Do all the ARM things.  They keep getting in my way.
11:49:05 <dsal> Also, /j #ghc
11:49:27 * dsal notices the conversation is already happening over there
11:50:00 <zeta_0> dsal: i already posted on #ghc as well, they take a long time to respond
11:50:42 <dsal> But they're the ones with the answers.  :)
11:50:55 <dsal> What interests you?  That's how I find things to work on.
11:52:02 <zeta_0> dsal: well, parallelism and concurrency seems very interesting
11:52:17 <dsal> Haskell's pretty good at those things, yeah.
11:53:38 <dsal> Is working on the compiler itself important?  There's lots of interesting periphery.  I had an issue that required me to write an eventlog processor recently.  You can do fascinating stuff with that.
11:54:03 <dsal> (was looking for thread leaks / deadlocks)
11:55:16 <zeta_0> dsal: ya, i don't know much about the inner workings of compilers, i am just trying to find something good to start off with
11:55:51 <dsal> Might be better to start with something less advanced.  :)  I suspect you'll learn more writing a compiler than working on a mature one.
11:57:24 <zeta_0> dsal: i want to join an open source project to get some experience, could you help me find something good to work on? https://gitlab.haskell.org/ghc/ghc/issues
11:58:02 <aplainzetakind> type M = State s; initState :: s; I have [M ()]. I can do fmap ((`execState` initState) . sequence) . inits to obtain the list of all intermediate states while sequencing. Is there a more succinct/elegant way to do this?
11:58:24 <zeta_0> dsal: someone responded to #ghc, i'll come back to this channel in a bit
12:00:20 <dsal> zeta_0: there are thousands of libraries that will be easier to get going with and help you learn stuff.  With ghc in particular, you can do things with libraries that most other languages require massive internal changes to achieve.
12:00:23 <aplainzetakind> Also would the semantic "starting over for each step" situation be optimized away?
12:02:01 <sm[m]> zeta_0: you're welcome to join/help out at #hledger
12:02:02 <zeta_0> dsal: thanks for the tips, and someone on the other channel sent me a good link to get started: https://gitlab.haskell.org/ghc/ghc/wikis/contributing
12:02:23 <zeta_0> sm[m]: what's that?
12:02:32 <dsal> It's the ghost of Heath Ledger
12:02:57 <aplainzetakind> sm[m]: Is understanding of basic accounting principles a prequisite?
12:03:21 <sm[m]> not at all aplainzetakind . Heck we barely do
12:03:28 <sm[m]> all welcome
12:04:27 <dsal> zeta_0: Do you have any particular interests?
12:04:52 <dsal> I've only got a couple things I thought useful enough to push to hackage.  I get pull requests now and then, though, which is nice.
12:08:30 <zeta_0> dsal: well, i really like functional programming in general, i think ghc would be a good place to start for now, i also like category theory, i haven't learned any lambda calculus, or type theory though, parallelism and concurrency looks really cool as well
12:09:20 <zeta_0> dsal: i really liked gui programming in java so eventually i'll look to see how it is done on haskell
12:10:21 <dsal> You won't find much gui work in ghc. But I'm sure many would appreciate an updated threadscope
12:12:07 <zeta_0> dsal: threadscope?'
12:14:04 <dsal> GUI tool for visualizing concurrency and parallelism (and stuff) in event logs
12:15:12 <habbah> is there an editor plugin that would allow me to see where "vspace" is being pulled in from in this file: https://github.com/quchen/prettyprinter/blob/f4370b5ef4329d3870d139575954c3af2a54ab05/prettyprinter/app/GenerateReadme.hs
12:15:47 <zeta_0> dsal: cool, i am just reading the documentation now, that's a lot of information to digest
12:15:51 <habbah> it's defined at the bottom of the file, I see
12:16:05 <habbah> is there an editor plugin that would take me to the definition of vspace though?
12:16:56 <sm[m]> habbah: there are a bunch of them, if you're lucky they'll work but more likely they'll lead you down a rabbit hole of setup
12:17:04 <sm[m]> what's your editor ?
12:17:13 <dsal> zeta_0: you can start by processing some eventlogs.  The lib is good.
12:17:24 <sm[m]> habbah: a reliable way is to use ghci's :i command
12:18:03 <sm[m]> dsal: isn't mpickering working on an updated threadscope
12:18:24 <habbah> sm[m]: I use vim, but I'm open to emacs
12:19:04 * sm[m] defers to the vim advisory team
12:19:40 <aplainzetakind> Speaking of, does anyone know how to get auto-indentation/syntax highlighting for .lhs files in vim?
12:20:26 <sm[m]> well actually just making a standard ctags file (with exuberant-ctags or hasktags) and vim's jump to tag definition should work
12:20:30 <sm[m]> may work
12:23:13 <aplainzetakind> hasktags exists.
12:23:41 <aplainzetakind> Oh you mentioned it.
12:31:25 <zeta_0> sm[m]: i use emacs
12:32:15 <sm[m]> zeta_0: the same approach should work there
12:35:23 <zeta_0> sm[m]: sounds good
12:52:35 <merijn> mpickering: ping?
12:53:18 <amx> AWizzArd: on the server
13:55:58 <zeta_0> running some of these commands causes an error, why is that?
13:56:00 <zeta_0> [zeta@nixos:/ghc.nix]$ nix-shell ~/ghc.nix/ --run './boot && ./configure && make -j4'
13:56:11 <zeta_0> https://github.com/alpmestan/ghc.nix
14:06:41 <yasar> How can I test whether my `==` evaluated lazily or not?
14:06:48 <yasar> https://gist.github.com/yasar11732/c1dcb381354877dcffaf3439b2c5e7ff#file-listadt-hs-L113
14:07:00 <monochrom> sprinkle with some undefined's
14:07:08 <monochrom> Example:
14:07:25 <monochrom> > (1 : 2 : undefined) == (3 : undefined)
14:07:28 <lambdabot>  False
14:07:51 <monochrom> This shows the computer didn't bother with latter cons cells.
14:08:12 <solonarv> ...because if it had, there would have been an error message
14:08:16 <monochrom> I should have improved it to: (1 : undefined) == (2 : undefined)
14:08:29 <monochrom> Yeah, here is when the computer bothers:
14:08:39 <monochrom> > (1 : undefined) == (1 : undefined)
14:08:41 <lambdabot>  *Exception: Prelude.undefined
14:10:57 <yasar> According to that test, it is not being lazy :(
14:11:33 <Ailrun[m]> Because of how `treeToList` implemented, it will gives you `undefined` for `Node 1 undefined Empty == Node 2 undefined Empty`
14:13:12 <monochrom> Actually, who is "it"? You have a list type and a tree type.  Which one?
14:13:21 <Ailrun[m]> If you want child-lazy implementation of `==`, than you should use preorder tree traversal.
14:13:24 <yasar> Tree type
14:13:47 <Ailrun[m]> I mean, the Eq instance yasar implemented.
14:14:13 <monochrom> Actually why is (==) for tree based on converting to list in-order?
14:14:33 <monochrom> As in, is it some prof's requirement?
14:15:05 <yasar> I am just messing around with custom types to learn
14:15:11 <monochrom> OK!
14:15:55 <monochrom> Consider the fact that different tree shapes will be considered "equal" under your "equal", which could be controversial.
14:16:21 <monochrom> But if you really want it, then you can't make it any lazier.
14:16:39 <yasar> I thought if I ordered the list for (==), I can keep associativity requirement for a semigroup `<>` function
14:17:45 <Ailrun[m]> :t (==)
14:17:47 <lambdabot> Eq a => a -> a -> Bool
14:18:08 <yasar> currently, `(a <> b) <> c` and `a <> (b <> c)` results in Tree's with different shapes
14:18:15 <yasar> but same elems
14:18:39 <monochrom> IMO this means trees are not a monoid.
14:18:47 <nshepperd2> It appears to be a binary search tree. So == equating trees with different shapes is correct
14:19:03 <monochrom> Unless you have further conditions like "these are binary search trees" or something.
14:19:04 <yasar> so if Tree's with same elems but different shapes considered equal, Tree is a monoid :)
14:19:37 <monochrom> in which case, where are your comments?!
14:20:37 <dsal> yasar: If you're wanting to make a monoid, check out http://hackage.haskell.org/package/checkers
14:20:49 <monochrom> Usually we don't expect much laziness out of binary search trees, so there is nothing to worry about.
14:20:56 <yasar> I didn't write any comments because I was just trying out different things and seeing what happens
14:21:38 <monochrom> or more refinedly, operations on binary search trees.
14:22:55 <yasar> I like the fact that when you implement foldr for your type, you get length function for free :)
15:43:46 <jumper149> Is there any reason to stick to `Either ErrorType RealType` instead of `Except ErrorType RealType`?
15:44:12 <jumper149> When handling exceptions of course otherwise it would be misleading lul
15:44:33 <Rembane> jumper149: You can pattern match on the Either one 
15:44:42 <Rembane> jumper149: And that's quite neat 
15:45:30 <jumper149> Hmm yeah that is actually excactly why I am hesitating to use Except^^
15:46:36 <Rembane> jumper149: If you hesitate, you either don't need it or you don't know that you need it. 
15:48:06 <solonarv> jumper149: Either is simpler when you are just using it on its own
15:49:18 <jumper149> I will just give my `Either ErrorType` a type synonym to clarify but I dont need any extra functionality
15:49:31 <jumper149> s/but/because
16:35:21 <Ailrun[m]> `Except` is useful when you want to use your errors inside of other monads. However, if you are dealing with more pure functions, it would be better th use `either` for simplicity.
16:51:08 <suzu> using Except or Error lets you buy into all the features that the `safe-exceptions` package gives you
16:51:39 <suzu> ErrorT / ExceptT do almost the same thing
16:51:45 <suzu> but you get a lot of stuff for free
17:15:20 <Ailrun[m]> Either also has instances for MonadThrow, MonadCatch and MonadMask (for safe-exceptions package), doesn't it?
17:35:46 <paraplan> Hello! I'm reading "Functional programming with bananas, lenses, envelopes, and barbed wire" right now, and I'm not sure what `Arrow` represents here:
17:36:17 <paraplan> The operation `->` that forms the function space (what is a function space) `D -> D``
17:36:31 <paraplan> And `(f -> g) h = g . h . f` 
17:40:20 <paraplan> Also "Sectioning" and "Constants" are somewhat strange. 
17:40:55 <ricky_clarkson> If I understand the question, you're asking what -> is in Haskell - it represents function application. A function of type Foo -> Bar takes a Foo and delivers a Bar.
17:42:03 <paraplan> No, no, I know what it means in Haskell. But I'm not so sure what it means here: https://maartenfokkinga.github.io/utwente/mmf91m.pdf
17:42:56 <f-a> paraplan: can you be so kind to indicate the page
17:43:21 <paraplan> 7, last secion
17:43:25 <paraplan> *section
18:02:06 <paraplan>  Okay, I read this right now http://reasonablypolymorphic.com/blog/recursion-schemes/
18:02:45 <paraplan> I still don't understand what those arcane things meant, but at least I got the general gist of the paper
18:03:56 <day> parseInput :: String -> [Int]
18:03:57 <day> parseInput = map read . splitOn ","
18:04:19 <day> why does this function work without actually using the input?
18:04:57 <day> i would have expected something ala parseInput x = map read . splitOn "," x
18:05:39 <koz_> day: It does use it - it's the same as writing 'parseInput input = map read (splitOn "," input)
18:05:41 <koz_> '
18:06:29 <day> i know it is using it, i just don't understand why i can ommit it :|
18:06:29 <koz_> The type of parseInput is 'a function from strings to lists of Int'.
18:06:38 <koz_> map read . splitOn "," has that type.
18:06:48 <koz_> You're defining a function as a composition of two other functions.
18:07:10 <koz_> :t splitOn ","
18:07:12 <lambdabot> [Char] -> [[Char]]
18:07:25 <koz_> That, by itself, is a function from strings to lists of strings.
18:07:31 <day> so this works as long as it is clearly solveable? e.g. if there were two identical inputs you would have to define it?
18:07:54 <koz_> day: I don't understand what you mean by 'clearly solveable' or 'identical inputs' in that sentence, sorry.
18:08:17 <day> like Int -> Int -> Int   divide x y = `div` x y
18:08:22 <paraplan> `.` is a function
18:08:26 <paraplan> :t (.)
18:08:29 <lambdabot> (b -> c) -> (a -> b) -> a -> c
18:08:48 <koz_> > let divide = div
18:08:51 <lambdabot>  <no location info>: error: not an expression: ‘let divide = div’
18:08:55 <koz_> Argh.
18:08:58 <koz_> % let divide = div
18:08:59 <yahb> koz_: 
18:09:02 <koz_> :t divide
18:09:05 <lambdabot> error: Variable not in scope: divide
18:09:08 <koz_> % :t divide
18:09:08 <yahb> koz_: Integral a => a -> a -> a
18:09:13 <koz_> Seems fine to me.
18:09:17 <koz_> (aside from the more general type)
18:09:34 <paraplan> You can also start reading from here https://wiki.haskell.org/Eta_conversion
18:09:46 <koz_> paraplan: Lol, beat me to the punch. :P
19:25:20 <zeta_0> in what directory does mk need to be built in? https://github.com/alpmestan/ghc.nix
19:25:29 <zeta_0> [zeta@nixos:/ghc_development]$ ls -a
19:25:29 <zeta_0> .  ..  ghc  ghc.nix
19:51:42 <TheCommieDuck> so I was able to work out what I wanted more clearly. https://pastebin.com/bd9Nv12M
19:53:39 <c_wraith> TheCommieDuck: why are there 3 args to Bar in the pattern match on line 6?
19:53:50 <jle`> glguy: it was easy for me to write resumable trampoline-style combinators
19:53:53 <c_wraith> TheCommieDuck: oh, because I can't read.  nevermind
19:54:06 <TheCommieDuck> I probably didn't make it super clear when trying to be brief
19:54:08 <jle`> glguy: i needed that feature for santabot
19:54:43 <jle`> glguy: i couldn't find a way in conduit to write Conduit i Void m a -> m (Either a (i -> Conduit i Void m a))
19:54:53 <c_wraith> TheCommieDuck: ok, here's the real question...  line 8 has "Foo a", but Foo isn't defined with an argument.
19:55:06 <c_wraith> TheCommieDuck: what do you want to be happening with that?
19:55:11 <jle`> glguy: or Conduit i o m a -> m ([o], Either a (i -> Conduit i o m a))
19:55:16 <glguy> I looked into it more. You also don't have the generalized step Functor or a notion of left overs, which this use case doesn't seem to need
19:55:34 <jle`> glguy: which is "run this conduit and get the outputs until it either terminates or asks for input"
19:55:36 <TheCommieDuck> oh. there should be no a there. that was a remnant from a previous example when I realised it was more complex than I needed it to be.
19:56:15 <iqubic> jle`: What do you mean by trampolines-style?
19:58:18 <c_wraith> TheCommieDuck: Well...  There are a couple answers. The one involving the least code involves using GHC features that border on "too magical", like the Data and Typeable classes.  I say they border on "too magical" because they make it easy to silently do the wrong thing if you change a definition someplace.
19:58:27 <jle`> glguy: yeah, i don't have any two-way communication either
19:58:39 <jle`> glguy: it's basically sort of my own mini re-implementation of the parts of conduit that i liked
19:59:05 <glguy> You're making up for two way communication by communicating via State, right?
19:59:19 <jle`> glguy: and it was much easier (with the interruptable/resumable) to write Day 7 recursion using the simple structure
19:59:26 <jle`> with the resumable features
19:59:34 <jle`> glguy: yeah, it's basically like using IO
19:59:40 <jle`> the whole pipe reads from a global state
20:00:13 <glguy> I was thinking you could implement the feedback loop the same way
20:00:34 <TheCommieDuck> hmm, alright
20:00:51 <glguy> At the end you have a Pipe that awaits, saves to a queue stored in state, and then yields
20:01:20 <glguy> And the leading input pipe reads it's values out if the queue in state
20:01:22 <c_wraith> TheCommieDuck: unless you're getting to the upper end of the moderate experience level, I'd avoid that for now.  And I'd probably just write all the cases out.
20:01:22 <zeta_0> is there anyone here that uses nix, i am having trouble building ghc? https://github.com/alpmestan/ghc.nix
20:02:07 <c_wraith> TheCommieDuck: I will say it's uncommon to have a type with a bunch of constructors containing the same data.  When that happens, you usually factor that into a separate type that contains all the alternative parts that are different.
20:05:02 <TheCommieDuck> that was my aim by parametricisalising the type, but then I hit the issue that I needed to close it back again
20:06:22 <jle`> glguy: hm, it's probably possible, you're right. and now you're making me think that day7 could also be possible by using underlying State as well
20:07:07 <c_wraith> In this case (and I realize this will probably need some liberal adaptation to apply to your real problem), I'd re-arrange things like data Foo = Foo Int String Bar ; data Bar = Bar1 Int | Bar2 String | Bar3 Int | Bar4 Bool
20:07:10 <jle`> glguy: but the producer -> processor -> consumer pipeline conceptually is nice for its consistency, since i implement my vty-based interactive game the same way
20:07:19 <glguy> That's the one I was talking about, the feedback loop in 7
20:07:36 <jle`> ah
20:07:46 <jle`> yeah, that does make sense
20:08:04 <jle`> now that you mention it, that might be how i could implement day 7 with conduit
20:08:08 <TheCommieDuck> oh! yes, that does make sense
20:08:08 <jle`> that i didn't see before
20:08:15 <TheCommieDuck> the gears are clicking
20:08:15 <glguy> What's the other special case you were talking about? The bot?
20:08:17 <TheCommieDuck> thank you :)
20:08:25 <jle`> glguy: yeah, the bot.
20:08:33 <jle`> glguy: but also interface-wise conduino exposes awaitSurely
20:08:44 <jle`> so there's some nice usability things for me in that sense
20:08:58 <c_wraith> TheCommieDuck: you're welcome!
20:09:17 <jle`> glguy: the bot requires 'running' a `ConduitT i o m a` to get the `[a]` and either a halted conduit or a continuation awaiting/blocking for input
20:09:25 <glguy> I hooked my interpreter up to conduino and have been playing around with how to solve past problems
20:09:36 <jle`> glguy: essentially ConduitT i o m a -> m ([a], Either a (i -> ConduitT i o m a))
20:09:40 <jle`> that's what drives santabot
20:10:00 <jle`> i originally wrote things using conduit but, not being able to find it, i switched to conduino
20:10:07 <glguy> jle`: could you use Cont on the bottom and return the continuation as the final result?
20:10:14 <jle`> glguy: ah, thanks for tring it out :)
20:10:54 <jle`> glguy: you might like this collection of helper functions i'ave accumulated over this month https://github.com/mstksg/advent-of-code-2019/blob/master/src/AOC/Common/Conduino.hs
20:11:00 <jle`> basically to bring in the full conduit api
20:11:09 <jle`> er, not full, but more of the useful parts
20:11:26 <jle`> glguy: hm, can that be done? i would be interested in seeing how
20:11:39 <jle`> but i feel like it should be an important part of any streaming combinator library
20:11:46 <glguy> Oh, I've been poking through all your repo to see if you were solving the conduino challenges I was encountering
20:11:58 <glguy> We think a lot alike ;)
20:12:04 <jle`> maybe it's not available because of the leftovers thing you were talking about
20:12:39 <jle`> glguy: ah, i'll take that as a compliment :)
20:13:40 <glguy> Im pretty sure what I can do is make a newtype for a recursive type for pipes that run in cont that return pipes that run in cont that....
20:13:52 <jle`> if you find a way i would be very interested
20:13:55 <glguy> And then use callCC to suspend
20:14:06 <jle`> i spent a long time trying to figure it out before giving up and switching to conduino
20:14:17 <jle`> but i didn't think of using CondtT
20:14:17 <glguy> I'll try it in conduino
20:14:21 <glguy> Simpler :)
20:14:33 <jle`> i feel like it should be implementable just from the basic structure of conduit
20:14:39 <jle`> without needing anything extra
20:14:56 <jle`> like it is for conduino. but i don't know enough about the conduit internals to figure it out myself
20:15:08 <jle`> and in any case i'm sure it'd be a part of the internal implementation and not something 'easy to use' like the FreeT implementation of conduit
20:15:24 <glguy> This is my first foray into conduit-likes, so I don't have a good intuition about what the limits are yet
20:18:43 <jle`> glguy: i figured you might like it, since it's basically a FreeT :) and i think your intcode vm was based on that too
20:20:33 <jle`> ah, but you're trying to do it on top of some well-behaved external API, without needing to go internals
20:21:53 <TheCommieDuck> now I'm wondering.. if I have data Foo = Foo Int String Bar; data Bar = Bar1 Int | Bar2 String | Bar3 Bool | Bar4 Int...can I have some kind of type alias SpecificFoo = Foo Int String (Bar3 x)?
20:23:10 <monochrom> No. And you're conflating types with valus.
20:23:15 <monochrom> s/valus/values/
20:23:41 <TheCommieDuck> oops. Yes.
20:51:44 <glguy> jle`: https://gist.github.com/glguy/aa18ce8c3e67e6283f758bf8de4fa744
20:52:10 <glguy> jle`: Now that's a mess because I wanted to see some suspension working, but I think it could be packaged up reasonably
20:53:13 <glguy> monadLib's labelCC, jump, Label interface is just a nicer version of callCC
23:35:33 <yasar> I want to attempt exercise 9 here, http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html , but I don't know how to calculate turn direction
23:35:35 <yasar> any hints?
23:59:05 <opqdonut> yasar: the cross product can help
23:59:59 <opqdonut> or perhaps you can just compute the slopes of a->b and a->c and compare (you'll need a couple of cases for different quadrants)
