01:03:14 <rwmorrison> Why `Data.Vector` throws `ErrorCall` and not `ArrayException`? Also I couldn't find this documented anywhere, only that `safe` functions perform some kind of check, so I had to find an actual error manually. Somewhat annoying
01:41:22 <wonderC`> pure x cb = cb x
01:41:30 <wonderC`> bind amb ma cb = ma (\a -> amb a cb)
01:41:37 <wonderC`> lift2 f ma mb = bind (\a -> bind (\b -> pure (f a b)) mb ma)
01:42:07 <wonderC`> what this bind and lift2 mean?
01:43:58 <phanimahesh[m]> look at the types. They'll make some more sense.
01:44:45 <wonderC`> phanimahesh[m]: how I can get its type?
01:46:06 <nil> :t \ amb ma cb = ma (\a -> amb a cb)
01:46:08 <lambdabot> error:
01:46:08 <lambdabot>     parse error on input ‘=’
01:46:08 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
01:46:13 <nil> :t \ amb ma cb -> ma (\a -> amb a cb)
01:46:14 <lambdabot> (t1 -> t2 -> t3) -> ((t1 -> t3) -> t4) -> t2 -> t4
01:47:32 <nil> but more likely the intended type of your bind is `(a -> m b) -> m a -> m b`, where m is the continuation monad (m a ~ ((a -> r) -> r))
01:48:02 <phanimahesh[m]> What are the concrete types you're working with? This looks like a wierd mashup of continuation passing and generic monads.
01:48:55 <wonderC`> phanimahesh[m]: nil this is the original code https://paste.ubuntu.com/p/BJzRJ3VXKj/
01:49:50 <wonderC`> phanimahesh[m]: and yeah, it is the continuation monad
01:52:48 <phanimahesh[m]> But with the continuation callback included in the definitions. okay.
01:53:02 <phanimahesh[m]> You're trying to write the Cont monad in js?
01:53:48 <phanimahesh[m]> let's rewrite it slightly. I'm working this up as I go along, so I may make mistakes, please double check.
01:54:04 <wonderC`> phanimahesh[m]: not me, this is someone wrote, 
01:54:28 <wonderC`> I'm trying to understand it
01:55:06 <phanimahesh[m]> Okay.
01:55:34 <phanimahesh[m]> Pure is easy. `pure x = \cb -> cb x`
01:56:34 <phanimahesh[m]> I'll try rewriting/renaming the variables to make sense of bind.
01:56:42 <wonderC`> ok
01:58:19 <fdfgdfg> I'm trying to install via ghcup manually https://gitlab.haskell.org/haskell/ghcup/blob/master/README.md#manual-install The last step gives me the error https://pastebin.com/e3gXwEB9 What am I doing wrong?
01:59:41 <nil> using pseudo-haskell,  ma >>= \a -> mb = \c -> ma (\a -> mb c)
01:59:46 <maerwald> fdfgdfg: what is your current ghc?
01:59:52 <nil> where "mb" is some expression depending on "a"
01:59:55 <phanimahesh[m]> `bind amb ma` typically would be ` \cb -> amb (\x -> ma x cb)`
02:00:15 <phanimahesh[m]> From `    (Cont c) >>= f = Cont $ \k -> c (\a -> runCont (f a) k) -- i.e. c >>= f = \k -> c (\a -> f a k)`
02:00:38 <nil> as you can see, >>= for the continuation monad is roughly just function application, except you wrap it all in a \c -> ... c
02:01:24 <phanimahesh[m]> The js bind is just haskell continuation monad's bind flipped.
02:01:47 <fdfgdfg> maerwald: 8.8.1
02:06:22 <maerwald> fdfgdfg: cabal new-install --allow-newer=base cabal-install
02:06:54 <phanimahesh[m]> let's look at what bind does. Loosely speaking, bind takes a "monad", a function, "unwraps" the monad and applies the function
02:08:09 <fdfgdfg> maerwald: thanks a lot, it works now!
02:08:17 <phanimahesh[m]> Let's talk about `bind ma amb`. I've switched the argument order to make it match with typical haskell monadic bind
02:08:37 <wonderC`> ok
02:09:21 <phanimahesh[m]> so we first "unwrap" `ma`, and then `apply` `amb` to it. All loosely speaking
02:09:34 <phanimahesh[m]> Because that's what bind does, in a sense.
02:09:45 <wonderC`> how we "unwrap" 'ma'?
02:10:22 <phanimahesh[m]> This is the tricky part where we need to convince ourselves.
02:11:03 <phanimahesh[m]> "Wrapping" `a` is just turning it into a function that takes a callback and applies it.
02:11:14 <wonderC`> yeah
02:12:16 <phanimahesh[m]> Actually now that I look closer the wrap unwrap analogy might not be the best fit here. We don't "unwrap" in Cont like in Maybe.
02:12:50 <wonderC`> then how we think it?
02:13:30 <phanimahesh[m]> Let me see if I can find a good analogy. If not we dive in to Continuations itself.
02:13:37 <phanimahesh[m]> Actually let's just try that.
02:14:16 <phanimahesh[m]> ma is a continuation. Which means it is something like \p -> p a
02:14:34 <phanimahesh[m]> It "holds" the value a for use with a callback that will be supplied in the future.
02:15:09 <phanimahesh[m]> Does that look okay?
02:15:14 <wonderC`> yes
02:15:50 <phanimahesh[m]> now amb is a function of the type `a -> mb`
02:16:47 <wonderC`> amb :: a-> ((p->r)->r)
02:17:37 <phanimahesh[m]> Yep.
02:18:16 <phanimahesh[m]> Let's use q there to not conflict with types. `amb :: a -> ((q -> r) -> r)`
02:18:27 <wonderC`> ok
02:19:52 <phanimahesh[m]> Sorry, I'm taking this slowly since I don't want to say something stupid and continue both of us.
02:20:10 <phanimahesh[m]> Let's look at what `bind` means for the continuation monad.
02:20:28 <wonderC`> ok
02:21:12 <phanimahesh[m]> Reading from Haskell wiki All about Monads,
02:21:14 <phanimahesh[m]> > The Continuation monad represents computations in continuation-passing style. Cont r a is a CPS computation that produces an intermediate result of type a within a CPS computation whose final result type is r.
02:21:16 <lambdabot>  <hint>:1:48: error: parse error on input ‘in’
02:21:36 <phanimahesh[m]> The return function simply creates a continuation which passes the value on. The >>= operator adds the bound function into the continuation chain. 
02:25:18 <phanimahesh[m]> So amb is inserted into the continuation chain represented inside ma.
02:25:50 <phanimahesh[m]> Now looking at the haskell definition for bind writing the js eqquivalent is simple and it matches. How do we derive it though?
02:34:51 <phanimahesh[m]> If  `f = \cb -> cb x` is a continuation I'm kinda convinced that `\p -> f p` is the closest we get to "unwrapping" it.
02:35:13 <phanimahesh[m]> because if you "unwrap" a continuation with `id` you get back the intermediate value in it.
02:36:18 <wonderC`> ok, f id will "unwrap" the value x
02:36:23 <phanimahesh[m]> now inserting a new function that goes from an intermediate value to a continuation does look like the bind
02:36:50 <wonderC`> wait a sec, but \p -> f p is f
02:37:07 <phanimahesh[m]> oh damn. yes.
02:37:12 <wonderC`> f == \p -> f p,  eta-convertion
02:37:35 <phanimahesh[m]> but this still helps.
02:37:43 <phanimahesh[m]> somewhat.
02:38:10 <phanimahesh[m]> To "insert" a continuation in a chain, we need two things. Something that looks like a chain with an insertion point.
02:38:46 <phanimahesh[m]> And looking at f as `\p -> f p`, though identical, gives me an insertion point at p.
02:38:57 <phanimahesh[m]> Because look what bind does.
02:39:20 <phanimahesh[m]> `c >>= f = \k -> c (\a -> f a k)`
02:40:58 <phanimahesh[m]> Instead of taking an unwrappinf gunction like `id` and using it directly, it inserts the provided `f` to modify the unwrapping
02:41:21 <phanimahesh[m]> that looks and feels like a continuation chain that can be extended, to me.
02:41:28 <phanimahesh[m]> I don't know if I'm making sense.
02:42:25 <wonderC`> c is ma which (a->r)->r, f is a->(b->r)->r
02:42:54 <phanimahesh[m]> C is a continuation resulting in r, with an intermediate value of a
02:43:17 <phanimahesh[m]> so when binding, f is a function that takes a and..
02:43:27 <phanimahesh[m]> should'n't it be r b instead of b r?
02:43:59 <phanimahesh[m]> no wait you are probably right.
02:44:22 <phanimahesh[m]> > :t bind
02:44:25 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
02:44:36 <phanimahesh[m]> @t bind
02:44:36 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
02:44:52 <wonderC`> with the return definition, so we can think (a->r)->r is the type of a continuation, not that (a->r)
02:45:17 <wonderC`> we use (a->r) to "unwrap" our continuation, so we can get the result
02:45:50 <phanimahesh[m]> Yes. haskell Cont r a is defined as that.
02:46:06 <wonderC`> not just id :: a-> a can "unwrap" a continuation, any unary function can "unwrap" a continuation
02:46:46 <phanimahesh[m]> yes. `runCont f` in haskell "unwraps" with `f`
02:47:02 <wonderC`> so m a is waiting for a unary function
02:47:19 <wonderC`> and that unary function is producted by f
02:47:25 <phanimahesh[m]> yes. A continuation is waiting for a function
02:47:40 <phanimahesh[m]> f is the function we provide to "unwrap" or "resolve" the continuation
02:47:50 <wonderC`> f :: a-> m b, let's assume f :: a -> (b -> r) -> r
02:48:07 <wonderC`> `c >>= f = \k -> c (\a -> f a k)`
02:48:09 <phanimahesh[m]> No, swap r and b
02:48:37 <phanimahesh[m]> m a is a continuation with an intermediate value of a
02:48:46 <phanimahesh[m]> oops with a resulting value f a
02:48:59 <phanimahesh[m]> wait. let me read the types. sorry for the confusion.
02:49:16 <wonderC`> f a k :: r
02:49:22 <phanimahesh[m]> This is right: m a is a continuation with an intermediate value of a
02:49:28 <phanimahesh[m]> So yeah, your type was correct
02:49:38 <wonderC`> so (\a -> f a k) :: a -> r
02:49:56 <phanimahesh[m]> because m in haskell is `Cont r`, and `m a` is `Cont r a`
02:49:57 <wonderC`> and c is a continuation which wait for a unary a->r
02:50:03 <phanimahesh[m]> Yes.
02:50:08 <phanimahesh[m]> And it makes sense
02:50:32 <wonderC`> so we can get reuslt in c through give it (\a -> f a k)
02:52:48 <phanimahesh[m]> Now looking at it the insertion happening is even more obvious. Hindsight 2020
02:52:57 <phanimahesh[m]> `const bind = amb => ma => cb => ma(a => amb(a)(cb))`
02:53:11 <wonderC`> "<phanimahesh[m]> So amb is inserted into the continuation chain represented inside ma." this word help me
02:53:45 <phanimahesh[m]> Yeah. First time I looked at continuation monad in detail. This helped me too.
02:54:50 <wonderC`> I think the sequence is reversed, in other monads, >>= pass the previous value to the next, left to right
02:55:09 <wonderC`> but in the Cont Monad, >>= pass the right into left
02:55:18 <phanimahesh[m]> It is not reversed in haskell. The js snippet reverses the arguments
02:55:37 <phanimahesh[m]> No, even in Cont monad >>= works as usual.
02:56:20 <wonderC`> sorry, I just forget that JS code, I was looking at your `c >>= f = \k -> c (\a -> f a k)`
02:57:05 <phanimahesh[m]> Okay. Even there, it's moving left to right, even if it looks otherwise.
02:57:10 <wonderC`> you see, this f take a value and a continuation to "unwrap" its result in f
02:57:41 <wonderC`> and a function, not a continuation
02:58:15 <phanimahesh[m]> What does moving left to right mean? we want the effects of left monad to happen first. Right?
02:58:30 <wonderC`> so we can get a unary function, then we pass the unary function to the m a which the left part of >>=, so we can "unwrap" the m a
02:59:25 <phanimahesh[m]> It feels reverse because we are dealing with functions.
02:59:45 <wonderC`> let's assume f >>= g >>=t, I bet this must "unwrap" t first, then g, then f, we final "unwrap" f's result, not t's result
03:00:03 <phanimahesh[m]> Nope.
03:01:20 <phanimahesh[m]> Look at function composition, `(.)`
03:02:49 <wonderC`> f . g = \x -> f $ g x
03:03:48 <wonderC`> f . g "unwrap" g first, then f
03:04:05 <phanimahesh[m]> Moving left to right, the functions are still applied right to left
03:04:19 <phanimahesh[m]> It's somewhat a property of functions themselves.
03:04:42 <wonderC`> but look at Just 3 >>= return
03:04:46 <phanimahesh[m]> In a continuation, you do something, then wait for a function to continue it
03:05:24 <wonderC`> we think that 3 is passing through >>= to return
03:05:32 <phanimahesh[m]> so when you want to stitch two continuations together, you do work in 1, then do work in 2, then wait for a function to complete the chain
03:06:11 <phanimahesh[m]> The callbacks propogate in reverse order.
03:06:58 <phanimahesh[m]> If you want to remember it as continuation does the reverse, you can. But that might cause confusion with reading the types on bind, or observing effects.
03:07:03 <wonderC`> but the chain is do work 2 first, then work 1
03:07:11 <phanimahesh[m]> The effects are always stitched in the right order.
03:07:28 <phanimahesh[m]> No, the work does not happen in the callback.
03:08:06 <phanimahesh[m]> A continuation monad represents some work that gives an intermediate value of a, which is waiting for an a -> r to continue.
03:08:32 <phanimahesh[m]> The work happens in left to right order when you stitch continuations with bind.
03:09:17 <wonderC`> but based on the definition, it is the right one finished first
03:09:21 <phanimahesh[m]> The callbacks however must be applied in the reverse order. The last one in the chain is waiting, the others have been given next step to do
03:09:45 <phanimahesh[m]> The right one was given the callback first because it is the one waiting for the next step
03:10:41 <phanimahesh[m]> Don't read the written order. Look at the effects. Try writing some code to convince yourself.
03:11:34 <phanimahesh[m]> maybe *2 and +10. Look at the result.
03:12:10 <wonderC`> I barely know how to make a cont...
03:13:10 <phanimahesh[m]> Actually, yeah, you may think of it as reverse. It just happens to be the natural way for functions.
03:13:30 <phanimahesh[m]> just like in f.g, the value is given to g first then result to f
03:14:10 <phanimahesh[m]> similarly in continuation chain, the rightmost one is given the function first, then the result to its left one and so on.
03:14:11 <wonderC`> but with Maybe Monad, Just 3 >>= return, we do think 3 is passing to right return, not that return passing to the left 
03:14:38 <phanimahesh[m]> Because functions. Continuations are functions.
03:15:15 <wonderC`> but Just is a function too. Just :: a -> Just a
03:15:50 <phanimahesh[m]> Just is not a block of logic. A continuation is.
03:16:01 <phanimahesh[m]> I should have been more explicit.
03:16:38 <phanimahesh[m]> Continuation is a block of logic that has a placeholder at the bottom
03:17:53 <phanimahesh[m]> If you bind a continuation to a function returning another, they get stiched, by placing the second continuation in the placeholder, and the second's placeholder becomes the overall hole.
03:18:35 <phanimahesh[m]> The final function given to resolve the continuation fills the final hole.
03:18:45 <phanimahesh[m]> But the flow of logic is still top to bottom.
03:18:56 <phanimahesh[m]> If that explanation makes any sense to you
03:20:07 <wonderC`> "If you bind a continuation to a function returning another," more specific?
03:21:22 <phanimahesh[m]> `bind :: ma -> ( a -> mb)`
03:21:50 <phanimahesh[m]> Bind a continuation `ma` to a function returning another `a -> mb`
03:22:35 <phanimahesh[m]> .. bind also has -> m b, fast fingers, but yeah. the types of arguments to bind
03:24:09 <wonderC`> ok, I think we can pass the `bind` part, and focus on the `lift2`
03:26:28 <wonderC`> t = c >>= f,  this t takes a value and an unary function so we can "unwrap" value in c
03:27:13 <wonderC`> no
03:27:42 <wonderC`> t just takes an unary function
03:30:25 <phanimahesh[m]> t just takes a unary function, yes
03:32:11 <wonderC`> "c >>= f = \k -> c (\a -> f a k)" there's an interesting part
03:32:27 <wonderC`> if we flip f a k to f k a
03:32:42 <wonderC`> so \a -> f k a will be f k,
03:33:16 <wonderC`> we flip that f's parameter
03:38:12 <wonderC[m]> that lift2 is harder to think than bind...
03:39:10 <jacks2> it's just a fmap for two arity functions.
03:39:39 <jacks2> > liftA2 (+) (Just 10) (Just 20)
03:39:41 <lambdabot>  Just 30
03:43:36 <wonderC[m]> but when it's continuation , how it works?
03:45:45 <phanimahesh[m]> so liftA2 for continuations looks something like this
03:46:18 <phanimahesh[m]> first argument is a function to combine two functions.
03:48:00 <phanimahesh[m]> Second and third are continuations.
03:48:24 <phanimahesh[m]> Instead of stitching together the logic inside the continuations, like we did in bind,
03:48:43 <phanimahesh[m]> lift will stitch together their callbacks using the combining function
03:51:28 <phanimahesh[m]> In your js snippet, `const lift2 = f => ma => mb => bind(a => bind(b => pure(f(a)(b)))(mb))(ma)`
03:52:36 <phanimahesh[m]> Substitute `f a b = a` or `f a b = b` and look what happens in the two cases.
03:53:05 <phanimahesh[m]> * I'm sorry, lift will stitch together the intermediate values, not the callbacks
03:54:06 <phanimahesh[m]> we were looking at continuations as a block of logic with a placeholder at the bottom, right?
03:54:31 <phanimahesh[m]> The placeholder can't be anything. It must take the intermediate value as an input.
03:55:05 <phanimahesh[m]> so if you have two continuations - which is two blocks of logic with one placeholder each
03:55:24 <wonderC[m]> ok
03:55:39 <phanimahesh[m]> and instead of using two placeholder functions, you want to use just one, that takes both intermediate values and works on them
03:56:04 <phanimahesh[m]> scratch that, I'll rewrite my last line
03:56:17 <phanimahesh[m]> instead of using two placeholder functions, you want to use just one
03:56:43 <phanimahesh[m]> So you now need a way of combining the two intermediate values into one that can be given to this new placeholder
03:56:50 <phanimahesh[m]> that function is f
03:56:57 <phanimahesh[m]> and lift2 makes this happen
03:57:15 <phanimahesh[m]> makes sense?
03:59:05 <wonderC[m]> that a->m b in bind,take an unary funtion to construct another unary function for m a
04:00:18 <phanimahesh[m]> a -> mb takes a and returns a continuation mb. mb is a block of logic with an intermediate value b, and is waiting for a unary function b -> r
04:00:46 <wonderC[m]> sorry to reply slowly, I'm on the road
04:02:07 <phanimahesh[m]> That's okay, take your time.
04:12:03 <wonderC[m]> \a -> f a k, this with f and k, construct a unary function for m a
04:15:20 <phanimahesh[m]> Well, yes and no
04:16:57 <phanimahesh[m]> F a is mb. Applied to k, gives b.
04:18:06 <phanimahesh[m]> So you're constructing a function for b. Not ma
04:18:53 <wonderC[m]> f is a-> m b
04:19:09 <wonderC[m]> c >>= f
04:38:34 <jsomedon> Merry Christmas fellow haskellers
04:38:53 <insilications> Merry Christmas!
04:39:40 <Rembane> Merry christmas! 
04:39:44 <Rembane> And Happy holidays! 
04:39:53 <wonderC[m]> phanimahesh[m] and you were right, it is eval m a first then m b
04:41:16 <wonderC[m]> \a -> f a k, give f the unary k, this will be an unary function for m a, and that \a is the value that m a hold
04:41:37 <wonderC[m]> and yes, \a is the a in m a
04:43:42 <wonderC[m]> give f::a->m b an unary, so it becomes another unary function, pass that unary to m a, and that unary's parameter is the value that m a holding, so a in m a is the a in \a -> f a k
04:46:03 <wonderC[m]> f a k products the final result
04:46:24 <phanimahesh[m]> In Haskell the concept of arity is not the same as in other languages. All functions are unary technically. Due to currying a function of multiple arguments is technically a function of one argument that returns another function and so on
04:46:52 <phanimahesh[m]> So specifying unary function is kind of redundant.
04:56:49 <duairc> I'm in a nix-shell that provides all of my dependencies for a package, but cabal new-repl won't load it because it thinks all the version bounds of all the dependencies conflict with each other. But I want that to be nix's problem. Is there any way I can tell cabal, "forget everything you think you know about dependencies, just load the project".
04:56:54 <duairc> I mean i guess I actually just want ghci
04:57:05 <duairc> But it's nice how cabal new-repl will load all the modules at once
05:00:16 <duairc> I suppose cabal v1-repl actually fits this usecase better
05:01:13 <__monty__> duairc: You can try passing `--allow-older --allow-newer`.
05:03:21 <duairc> If I do that then cabal wants to rebuild everything. I think I answered my own question, the v1-* commands are actually what I want. Let nix do the nix thing rather than cabal
05:16:53 * hackage barbies-th 0 - Create strippable HKD via TH  https://hackage.haskell.org/package/barbies-th-0 (FumiakiKinoshita)
05:20:22 <fenedor> duairc, you could also try haskell.nix?
05:20:37 <fenedor> or dont you want that?
05:29:06 <__monty__> That wouldn't help in this case.
05:33:23 <ShalokShalom> https://github.com/typelead/eta
05:33:25 <ShalokShalom> https://wiki.haskell.org/Android
05:33:30 <ShalokShalom> i have no rights to change this page
05:33:59 <ShalokShalom> Eta is obviously the most direct/hastle free way to develop haskell on Android, so probably worth mentioning here
05:34:03 <ShalokShalom> And G+ is no more
06:02:28 <__monty__> ShalokShalom: Sounds probable. Note that what I've heard about Eta is it's not being actively pursued anymore : /
06:02:55 <ShalokShalom> its at least receiving commits
06:03:02 <ShalokShalom> and this could be a way to increase those ;)
06:03:28 <ShalokShalom> its compatible with a supported version of Haskell..
07:06:54 * hackage cobot-io 0.1.2.5 - Biological data file formats and IO  https://hackage.haskell.org/package/cobot-io-0.1.2.5 (zmactep)
08:10:56 <yasar> Can't find some extensions here: https://wiki.haskell.org/Language_extensions
08:11:07 <yasar> Are there more complete resource?
08:12:19 <yasar> I want to see what each extension here does: https://gitlab.haskell.org/ghc/ghc/raw/master/libraries/base/System/IO.hs
08:13:49 <amx> yasar: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/Cabal-3.0.0.0/Language-Haskell-Extension.html
08:16:35 <nil> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html
09:13:24 * hackage summoner 1.4.0.0 - Tool for scaffolding fully configured batteries-included production-level Haskell projects.  https://hackage.haskell.org/package/summoner-1.4.0.0 (shersh)
09:37:24 * hackage summoner-tui 1.4.0.0 - Tool for scaffolding fully configured batteries-included production-level Haskell projects using TUI.  https://hackage.haskell.org/package/summoner-tui-1.4.0.0 (shersh)
09:53:44 <yasar> How do you unhide packages in stack environmet?
09:54:27 <oats> yasar: add it to the dependencies list in package.yaml?
09:54:33 <oats> or do I misunderstand
09:55:31 <yasar> Hmm, my ide suggest I should expose the hidden package, but stack can link to it :)
09:55:54 <yasar> I think it is IDE issue
09:56:01 <sm[m]> stack exec -- ghc-pkg expose PKG  maybe
09:56:35 <sm[m]> in case you previously ran ghc-pkg hide.. but that would be unusual
09:57:25 <sm[m]> stack exec -- ghc-pkg list  to see if you have any parenthesised (hidden) packages
09:58:03 <sm[m]> I think other time "hidden" means "you forgot to add it to the build-depends list in the cabal file, or to regenerate the cabal file from package.yaml"
10:00:07 <oats> are there any versions of the State monad where it's possible to stop in the middle of a computation? that is, an early return?
10:00:24 <oats> I'd like to avoid ExceptT or MaybeT since I'd like to preserve laziness
10:00:57 <lyxia> probably a continuation monad
10:02:48 <lyxia> what do you mean exactly by "preserve laziness"
10:03:32 <oats> it was my understanding that if I use ExceptT, the computation can't be lazy anymore since the whole thing needs to finish before yielding either Left a or Right b
10:03:42 <lyxia> if you have any form of early exit then (>>=) must be strict
10:03:56 <oats> hmm
10:23:21 <suzu> 'strict' in that it needs to look at least at whnf
10:33:31 <Benzi-Junior> hey, I'm trying to get  Stack to work on RPi under arch linux, when I run stac setup I get "Unable to find installation URLs for OS key: linux-armv7-tinfo6", this error appears to be distinct from anything mentioned anywhere online, and  the documentation for the OS-keys or installation URLs is lackluster at best
10:35:31 <solonarv> Benzi-Junior: this basically means that stack couldn't find a binary distribution of GHC for that platform
10:36:31 <koz_> RPi is ARMv7 right?
10:36:39 <koz_> GHC for that platform is... lacklustre.
10:37:02 <solonarv> yeah
10:37:09 <solonarv> it can be done, but it's all sorts of inconvenient
10:39:57 <Benzi-Junior> I can't see why GHC would be a problem since I have a ghc installation, and told stack to use system ghc
10:41:28 <koz_> What was the exact command?
10:42:31 <Benzi-Junior> that produced the error ? "stack setup"
10:43:04 <koz_> If it's without any flags, then it's definitely _not_ using your system GHC.
10:43:18 <koz_> I think you have to do something like 'stack setup --with-system-ghc' to get the behaviour you want.
10:44:46 <koz_> (Disclaimer: I haven't used stack in something like years)
10:48:27 <Benzi-Junior> koz oh, I added system-ghc : true to the global stack project thought that should have worked 
10:49:19 <koz_> I'm not sure it works that way.
10:49:31 <koz_> But yeah, try my command and see if it helps.
10:49:37 <suzu> also try `stack info`
10:49:47 <suzu> it'll tell you what stack is thinking about where to find all the things it's going to use
10:50:01 <suzu> maybe it's `stack paths` actually
10:50:04 <suzu> something like that
10:51:33 <koz_> suzu: stack please-do-the-thing-i-want
10:54:08 <Benzi-Junior> stack path produces the same error
10:54:18 <Benzi-Junior> Unable to find installation URLs for OS key: linux-armv7-tinfo6
10:55:01 <koz_> Benzi-Junior: How did you install stack?
10:55:07 <koz_> Also, what does stack --version emit?
10:56:18 <Benzi-Junior> koz, with pacman 
10:57:04 <Benzi-Junior> version is 1.9.1
10:58:00 <suzu> can you try `which stack`
10:59:20 <Benzi-Junior> suzu, I get /usr/bin/stack
11:18:58 <suzu> i think you might be screwed
11:19:12 <suzu> https://github.com/commercialhaskell/stackage-content/issues/70
11:19:17 <suzu> https://github.com/commercialhaskell/stack/issues/2103
11:21:02 <Benzi-Junior> suzu, ye this was more or less what I got
11:21:43 <Benzi-Junior> I also found some info about how to do it from 2017 but it just assumes that stack setup gives you no problem
11:22:39 <suzu> what's it do with the system ghc flag?
11:22:51 <koz_> Yeah... GHC + ARMv7 is a world of pain and frustration.
11:22:56 <koz_> (I know, I've tried)
11:27:50 <alestane> Hello; I am learning Haskell from tutorials, coming from a background of more "typical" languages including C++ and Lua. I'm trying to define a type synonym that's only relevant in the context of a particular function, by putting the declaration in a let expression or where clause. In either case, I get the message "parse error on input 'type'."
11:28:14 <alestane> Is there some reason why a type synonym can't go here?
11:28:25 <koz_> alestane: Because the language doesn't work that way.
11:28:39 <koz_> Let and where are for values, not types.
11:28:59 <alestane> So type declarations can't be scoped?
11:29:23 <koz_> alestane: Not at that level. You can scope them at the module level (just don't export the synonym).
11:30:53 <alestane> That's going to require a lot of restating contexts, I suspect. But if that's how it is then that's how it is.
11:31:27 <koz_> Not to judge, but I dunno why you'd want to scope type _synonyms_ that way.
11:31:34 <koz_> I have literally never once seen cause for such a thing.
11:31:55 <alestane> Well, in this case I have a function defined in a context.
11:32:00 <jacks2> alestane, do you have an example of what you're trying to do? just to see if we are on the same page
11:32:19 <alestane> I wanted a shorthand for a typeclass with the context applied to it.
11:32:40 <kuribas`> alestane: you cannot scope types, why should you scope type synonyms?
11:33:19 <kuribas`> alestane: so a concrete type then?
11:33:29 <alestane> kuribas`, I had not yet found any documentation about whether types could be scoped. That's why I came here.
11:33:51 <koz_> alestane: I second the call for you to show us your code.
11:34:02 <alestane> Working on it.
11:34:02 <koz_> I suspect this is an example of the XY problem.
11:34:10 <koz_> gist.github.com is best plan.
11:38:44 <alestane> I'm probably misunderstanding something. I can usually follow tutorials, but when I try to find an explanation of WHY something works or doesn't, I usually seem to end up somewhere that requires two semesters of linear algebra to understand the terms they're explaining it in.
11:38:46 <alestane> https://gist.github.com/alestane/c330b4b8684674449dc589278ec25c22
11:39:33 <alestane> This was the eraly stages of an algorithm, mostly to test whether my approach was something Haskell understands.
11:40:30 <alestane> I suspect I'm mistaking typeclasses for C# interfaces.
11:40:44 <alestane> And contexts for constraints.
11:44:10 <alestane> The parse error is on line 9.
11:44:37 <kuribas`> alestane: the real question is, do you need a typeclass here?
11:44:54 <alestane> Well, I started out writing it without them.
11:45:36 <alestane> But it seemed like I was spewing out restatements of the same contexts on all the subfunctions I was writing, so I thought it might make things easier and more cohesive.
11:46:34 <kuribas`> typeclasses are not there to reduce contexts
11:47:09 <alestane> I originally wrote the plan function to take two functions and two values: a function that generated a list of neighbors for a node, a funciton that estimated the travel distance between two nodes, a start node value and a goal node value.
11:47:45 <kuribas`> alestane: sounds like a better way
11:48:28 <kuribas`> I wouldn't try to save on characters
11:48:33 <kuribas`> at least not while learning :)
11:48:47 <kuribas`> I find that often in haskell writing things out is better
11:49:43 <alestane> So my original signature was:
11:49:45 <alestane> plan    ::  (Eq node, Ord cost) => (node -> [(node, cost)]) -> (node -> node -> cost) -> node -> node -> Maybe [node]
11:50:13 <p0lyph3m> isnt there a name clash lines 3/11 with line 10 , the record field "estimate" ?
11:50:51 <kuribas`> alestane: looks better
11:51:30 <kuribas`> alestane: that's a rather small context, compared to many haskell libraries :)
11:51:38 <alestane> My experience in most languages is that when I have a lot of repetitive verbiage, either my approach is bad, or there's some language element or idiom I'm not aware of yet.
11:51:46 <kuribas`> :t _1
11:51:48 <lambdabot> (Field1 s t a b, Functor f) => (a -> f b) -> s -> f t
11:52:49 <kuribas`> alestane: in haskell you cannot hide anything in the types, so they tend to become more verbose
11:53:21 <kuribas`> alestane: but then the language is more concise for other things, so I find you still end up with less code
11:53:35 <kuribas`> even than clojure/lisp
11:54:24 * hackage mmsyn7h 0.2.1.0 - A program and a library that produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.2.1.0 (OleksandrZhabenko)
11:56:06 <alestane> I presume then that 'data' declarations are also illegal inside scope clauses?
11:56:45 <monochrom> right
11:58:23 * hackage mmsyn7ukr 0.3.0.1 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.3.0.1 (OleksandrZhabenko)
11:59:29 <alestane> I understand that a let-in is an expression.
11:59:51 <alestane> The documentation so far has been fuzzier about what exactly a where clause is.
12:02:13 <alestane> What syntax is it part of? Is it associated with a function definition, or with the guard set of the function definition?
12:03:08 <alestane> Aren't guards on function definitions really some sort of sugar for case or if expressions?
12:03:13 <solonarv> indeed!
12:03:26 <solonarv> and 'where ...' is sugar for 'let ... in'
12:03:46 <solonarv> @where report
12:03:46 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
12:04:10 <solonarv> the language spec is quite readable and should clear up syntax questions of that sort
12:04:21 <kuribas`> alestane: the difference with where and let is that where scopes over the whole function defintion
12:04:54 <alestane> What does the where identify as the part that should become the 'in' body, then?
12:05:47 <kuribas`> alestane: the function rhs and guards
12:06:17 <kuribas`> I'd say where is more idiomatic
12:06:44 <alestane> So, everything after the pattern match, basically.
12:07:37 <p0lyph3m> i think where condtruct is top down problem specification wheras let/in is buttomup
12:07:56 <p0lyph3m> s/condtruct/construct/
12:09:03 <kuribas`> alestane: you can refer to where bindings in guards, but you cannot do that with let
12:09:17 <alestane> I understand that part.
12:09:25 <alestane> I get why let does not do that.
12:10:22 <iqubic> So, I have a conduit question. Is it possible to IO with Conduits?
12:10:29 <kuribas`> I usually use where for subexpressions that scope over the function body, while let for subexpressions which need to be more local
12:10:45 <kuribas`> for example in a lambda I use let
12:11:19 <iqubic> I have a ConduitT Int Int m (Either VMError Memory). I want to be able to have the inputs to that pipe come from stdin, and the outputs from that pipe go to stdout. Is that possible?
12:12:12 <iqubic> The type (Either VMError Memory) doesn't need to be understood to answer this question.
12:12:14 <suzu> if you'll let m be some monad in MonadIO then yes
12:12:29 <iqubic> suzu: m can be any monad at all.
12:13:00 <iqubic> But what would the code to do that look like?
12:13:35 <iqubic> I understand I'll need read and show to do String -> Int and Int -> String. That's fine.
12:13:41 <suzu> make some producer in IO using yieldM
12:13:48 <suzu> yieldM :: Monad m => m o -> ConduitT i o m () 
12:13:54 <iqubic> But beyond that, I have no idea how to do it.
12:14:24 <suzu> fuse it to your conduit as the source
12:14:46 <suzu> then runConduit on that
12:14:49 <suzu> to get your output out
12:15:18 <iqubic> How do I pipe the outputs to stdout?
12:15:24 * hackage verismith 0.4.0.1 - Random verilog generation and simulator testing.  https://hackage.haskell.org/package/verismith-0.4.0.1 (ymherklotz)
12:15:30 <iqubic> I want to see the outputs in the terminal.
12:16:23 * hackage verismith 0.5.0.0 - Random verilog generation and simulator testing.  https://hackage.haskell.org/package/verismith-0.5.0.0 (ymherklotz)
12:16:59 <iqubic> Actually... Conduit has a print function.
12:17:04 <iqubic> print :: (Show a, MonadIO m) => ConduitT a o m ()
12:17:23 * hackage verismith 0.5.0.1 - Random verilog generation and simulator testing.  https://hackage.haskell.org/package/verismith-0.5.0.1 (ymherklotz)
12:17:43 <solonarv> and you can use 'forever (liftIO readLn >>= yield)' for the input
12:17:44 <suzu> that should work
12:18:04 <iqubic> solonarv: I can?
12:18:30 <suzu> i think it might be yieldM but that should be right
12:19:41 <solonarv> iqubic: of course! why wouldn't that work?
12:20:34 <solonarv> suzu: oh right, 'forever (yieldM readLn)' would also work
12:21:39 <iqubic> See, that's great, but not quite what I want.
12:21:54 * hackage verismith 0.6.0.0 - Random verilog generation and simulator testing.  https://hackage.haskell.org/package/verismith-0.6.0.0 (ymherklotz)
12:22:13 <solonarv> no? what do you want, then?
12:23:37 <iqubic> See, instead of readLn, I want to use getLine, then map ord over it, to get a list of Ints, and then yeild those ints one by one, then repeat.
12:23:47 <alestane> kuribas`, is this a reasonable summation? https://gist.github.com/alestane/e2d0d058ec13d72ac73728c2964fcbca
12:23:51 <solonarv> oh, I see
12:24:03 <iqubic> But I'm not sure how to do that.
12:24:22 <kuribas`> alestane: yes
12:24:58 <iqubic> well, it's mainly the "yeild a list of Ints one by one" that I'm struggling with
12:25:09 <solonarv> that's qhat yieldMany is for
12:25:16 <solonarv> it does precisely that
12:28:06 <iqubic> what is this nasty error I'm getting? http://dpaste.com/22DVB5M
12:30:13 <iqubic> How do I fix this?
12:38:52 <glguy> liftIO getLine
12:40:06 <myme> Not really used conduit much, but you're in IO, mostly. Need to run it with `runConduit`. To build your pipe, you can prolly use what's been mentioned with `yieldM $ map ord <$> getLine`.
12:40:18 <myme> Something like: C.runConduit $ (C.yieldM $ map ord <$> getLine) .| C.print
12:40:52 <iqubic> glguy: Where is liftIO defined? GHC is claiming it's not imported.
12:42:21 <ChaiTRex> iqubic: Check Hoogle: https://hoogle.haskell.org/?hoogle=liftIO
12:50:35 <oats> glguy: hey there, I'm the fellow you talked to about intcode machines and laziness the other day. Can I get some follow-up help? I just decided to strip out error handling all together for now, but my day 7 part 2 still goes into an infinite loop. Could you help me figure out if laziness is still my issue? https://paste.xinu.at/jLVOBq/
12:51:01 <oats> iqubic: LMHTFY :) https://hoogle.haskell.org/?hoogle=liftIO
12:51:19 <iqubic> Well, this is doing exactly what it should. But it's not quite what I want.
12:54:00 <iqubic> See, the print combinator puts each of the things it writes to the terminal on different lines. That's not what I want. I want each thing that gets printed to be on the same line.
12:58:15 <ChaiTRex> oats: You might be able to use Debug.Trace to show what instructions are being executed.
12:59:18 <iqubic> For those that care, here's what I ended up doing: http://dpaste.com/2RAFJHX
12:59:46 <iqubic> And yes, this is for Day 25 of AOC. I didn't have a good way to run my Intcode VM interactively, so I wrote this.
13:00:11 <oats> hehe
13:00:20 <oats> I'm resisting the temptation to rewrite my intcode VM in IO
13:00:24 <iqubic> There's got to be a more consise way to write output.
13:00:30 <oats> hope interactivity doesn't become a requirement
13:00:32 <iqubic> oats: My VM isn't in IO.
13:00:49 <ChaiTRex> oats: Debug.Trace uses IO, but doesn't require you to rewrite anything in IO. It uses unsafePerformIO in the background.
13:01:21 <ChaiTRex> oats: When you execute trace "Add" $ whatever, it evaluates to whatever and prints "Add" to the screen.
13:01:23 <iqubic> Is there a better way to write the output function that I'm using in my code linked above?
13:02:04 <iqubic> All it's doing is awaiting, and then printing a char to the screen.
13:04:51 <myme> iqubic: `stdout` from .Combinators?
13:05:19 <iqubic> Perhaps.
13:05:49 <iqubic> Well, except that stdout wants bytestrings as input.
13:05:55 <iqubic> And I'm giving it chars.
13:10:32 <iqubic> Ah. That works really well.
13:11:56 <tabaqui1> I'm building on macos with stack and hsc2hs, but the process seems broken to me
13:12:44 <tabaqui1> I have "build-type: Simple, ..., build-tools: hsc2hs", but still get errors like "Cabal-simple_mPHDZzAJ_2.4.0.1_ghc-8.6.5: can't find source for"
13:12:55 <tabaqui1> what should I change on macos to fix that?
13:13:11 <tabaqui1> (this build works well on linux, of course)
13:13:26 <iqubic> Alright.. I now want a function of type "ByteString -> [Int]" which will convert each character to its ASCII value. I also want the reverse of that, which will take a single integer, and turn in to the corresponding ByteString, using ASCII.
13:13:52 <merijn> iqubic: Don't you just want pack/unpack?
13:13:55 <tabaqui1> btw, I have such if-condition: "if os(linux) hs-source-dirs: posix", hmm
13:13:59 <tabaqui1> probably, it is here
13:14:03 <merijn> iqubic: Those are "Word8 -> ByteString" (and vice versa)
13:14:09 <merijn> eh
13:14:13 <merijn> [Word8], obviousl
13:15:11 <tabaqui1> yeah, right, nevermind :)
13:15:33 <yasar> is there a version of "forever" that I can "break" when a condition is met?
13:15:50 <merijn> @hackage monad-loops --yasar
13:15:50 <lambdabot> http://hackage.haskell.org/package/monad-loops --yasar
13:16:14 <iqubic> merijn: I want to use ASCII values to convert integers to and from ByteStrings. Not word8s.
13:16:37 <tabaqui1> yasar: try to use fixed point combinators
13:16:45 <iqubic> I don't want to convert Word8s.
13:16:51 <merijn> iqubic: What does "ascii value" mean
13:16:56 <tabaqui1> like "fix \go -> if cond then result else go smth"
13:17:17 <iqubic> merijn: It's like what ord and chr use.
13:17:19 <iqubic> :t ord
13:17:23 <lambdabot> Char -> Int
13:17:25 <iqubic> :t chr
13:17:28 <lambdabot> Int -> Char
13:17:28 <tabaqui1> or even "fix (\go arg -> ...) initial"
13:17:33 <ChaiTRex> iqubic: They use Unicode.
13:17:37 <merijn> iqubic: That's basically the same thing...
13:17:38 <wildtrees[m]> @type char
13:17:39 <lambdabot> Char -> Doc
13:17:56 <iqubic> ChaiTRex: Ah I see.
13:18:13 <merijn> iqubic: Converting integer values to ByteString make sense, converting integer values to Char and then converting that to ByteString is nonsense
13:18:22 <iqubic> merijn: I know.
13:18:35 <ChaiTRex> iqubic: If the values intcode is outputting are supposed to be ASCII characters, you can get that with conversion to Word8 and then convert to Int and then use chr.
13:19:15 <iqubic> Can you show me what that would look like with actual code?
13:19:22 <ChaiTRex> iqubic: It won't allow Unicode output, but it'll allow ASCII.
13:20:04 <iqubic> That's fine.
13:20:07 <ChaiTRex> iqubic: map (chr . fromIntegral) . BS.unpack $ bytestring :: String
13:20:10 <oats> yasar: check out the monad-loops package
13:20:12 <iqubic> I don't need Unicode output.
13:23:32 <iqubic> Alright... Now I need a conduit combinator of the type "ConduitM [a] a m r"
13:24:11 <iqubic> Actually, it's ConduitT, but it's the same thing.
13:29:48 <iqubic> How do I create that?
13:32:18 <merijn> iqubic: There's one like that using MonoFoldable somewhere in Combinators
13:32:46 <iqubic> Oh? Do you recall what it's called? Because hoogle isn't giving me anything.
13:34:04 <merijn> iqubic: https://hackage.haskell.org/package/conduit-1.3.1.2/docs/Data-Conduit-Combinators.html#v:concat
13:35:32 <iqubic> Well, that's not what I want...
13:36:08 <merijn> How so?
13:36:17 <merijn> It's literally what you asked for?
13:36:40 <iqubic> Yeah.
13:36:55 <yasar> I am having type errors with last line : https://paste.debian.net/1122689/
13:36:57 <iqubic> I just have my ".| C.map (`BS.append` "\n")"
13:37:02 <iqubic> In the wrong place.
13:37:10 <iqubic> It's my fault, and not yours.
13:38:16 <ChaiTRex> yasar: Seems the part after that $ needs to be a one-argument function. Is it?
13:38:26 <iqubic> Or actually, it's that stdin doesn't do what I want.
13:38:52 <ChaiTRex> :t forkIO
13:38:53 <lambdabot> error: Variable not in scope: forkIO
13:40:48 <ChaiTRex> yasar: Seems like the part after the $ isn't the one-argument function that it needs to be. It has no arguments.
13:41:30 <yasar> ChaiTRex, yes I turned it into "forM_ [1..numThread] $ \_ -> forkIO (workerThread que)" and type error disappeared
13:42:34 <monochrom> Don't use $. Use explicit parentheses.
13:42:45 <monochrom> Use parentheses to show that you understand.
13:43:16 <merijn> You probably want replicateM
13:43:26 <iqubic> So, it seems that "C.stdin", and "C.repeatM getline" do different things.
13:43:26 <merijn> :t replicateM
13:43:28 <lambdabot> Applicative m => Int -> m a -> m [a]
13:43:38 <merijn> Well, "replicateM_"
13:43:56 <monochrom> Most type errors are thinking errors.
13:44:32 <glguy> oats: You can't store the outputs in the MachineState
13:44:45 <glguy> oats: You'll never have one until the machine terminates
13:45:19 <iqubic> C.stdin seems to send chunks of length 1 ByteString, whereas C.repeatM getLine sends strings down the pipeline, where each string is exactly the length I want it to be.
13:45:41 <oats> glguy: will I have to move away from a `State` based vm, then, in order for this to work?
13:46:00 <oats> hmm
13:46:03 <merijn> iqubic: I'm not quite sure what your point is?
13:46:12 <glguy> you'd need to store the output in something like Writer that is capable of streaming outputs
13:46:20 <yasar> So, how do I wait for forkIO action to complete?
13:46:35 <merijn> yasar: You probably want to use the async library, tbh
13:46:53 <iqubic> Well, I now have this as my final pipeline: http://dpaste.com/063S27V
13:47:53 <merijn> iqubic: Why use concat and then C.map ord
13:48:04 <iqubic> What should I do?
13:48:08 <merijn> Instead of just, say "C.map (map ord)" (or BS.map, whatever)
13:48:23 * hackage lex-applicative 0.0.0.1 - See README for more info  https://hackage.haskell.org/package/lex-applicative-0.0.0.1 (MatthewFarkasDyck)
13:48:42 <iqubic> I see.
13:54:46 <myme> iqubic: Because this kind of noodling is fun: https://gist.github.com/myme/dd3c9adeab97bf7dc4ac804c82f71a5e
14:00:31 <ChaiTRex> Are there any types between Word64 and Integer in size?
14:01:18 <merijn> ChaiTRex: What would that even mean?
14:01:34 <merijn> Word64 is a fixed size, Integer is variable depending on the value...
14:02:23 <iqubic> myme: What does unlinesASCII do? And where is it defined?
14:02:42 <myme> https://hoogle.haskell.org/?hoogle=unlinesAscii
14:02:49 <myme> Is in .Combinators.
14:02:54 <ChaiTRex> merijn: Like more bits for representing each value.
14:02:56 <iqubic> I see.
14:03:19 <myme> iqubic: Just interspersing "\n" between chunks. You can use `intersperse ","` for e.g. a comma delimiter.
14:03:24 <merijn> ChaiTRex: Word64 is 64bits, Integer is 64 or more, depending on value
14:03:25 <iqubic> Ah. I see.
14:03:32 <merijn> ChaiTRex: So what would be "in between"?
14:03:45 <ChaiTRex> merijn: Well, I mean, Rust has u128.
14:04:20 <ChaiTRex> merijn: LLVM can support 128-bit unsigned integers, so I was hoping there might be something like that in GHC.
14:04:32 <oats> @unmtl WriterT [Int] (StateT Foo (Except String)) a
14:04:32 <lambdabot> Foo -> Except String (a, [Int], Foo)
14:04:37 <glguy> ChaiTRex: If you're trying to make the most correct solution you probably need a Map Natural Integer
14:04:46 <glguy> ChaiTRex: Word isn't big enough to hold all the valid addresses
14:05:36 <ChaiTRex> glguy: I'm cutting corners :)
14:06:13 <ChaiTRex> glguy: I figure there's little chance of exceeding 32-bit addressing, but there's a much larger chance of the relative base going negative.
14:11:34 <oats> glguy: is it possible to stack these transformers so that it reads something like "MachineState -> ([Int], Either Error (a, MachineState))
14:12:03 <oats> I feel like I don't fully understand monad transformers
14:12:43 <ClaudiusMaximus> @hackage largeword -- ChaiTRex 
14:12:43 <lambdabot> http://hackage.haskell.org/package/largeword -- ChaiTRex
14:13:22 <ChaiTRex> ClaudiusMaximus: Thanks
14:13:52 <glguy> ?unmtl StateT MachineState (ErrorT Error (Writer [Int])) a
14:13:52 <lambdabot> MachineState -> (Either Error (a, MachineState), [Int])
14:14:56 <oats> @unmtl ExceptT Error (WriterT [Int] (State MachineState)) a
14:14:56 <lambdabot> ExceptT Error (WriterT [Int] (State MachineState)) a
14:15:00 <oats> whaaa
14:15:36 <alestane> Is the best way to append something v to a list l just, l ++ [v] ?
14:15:57 <oats> alestane: that, or maybe use Data.Sequence (Seq) instead
14:15:58 <merijn> ChaiTRex: What's wrong with Natural/Integer, though?
14:18:04 <ChaiTRex> merijn: Not much, just wondering about more efficient stuff.
14:18:59 <merijn> tbh, Integer/Natural are already surprisingly efficient
14:20:23 <ChaiTRex> merijn: I know. GMP is pretty fast and GHC uses Ints anyway I think if the numbers are small enough, but I wanted to learn more about the state of fixed-width integers.
14:33:27 <alestane> Another weird little question: on line 3, it's complaining that it can't deduce the type of 'node'. Is there a way to tell it that I don't CARE about the type of 'node', since as long as 'cost' is a type that can be summed, I can figure out the order? https://gist.github.com/alestane/5cac456ca6a36de9e64d13d86a8b6f92
14:35:25 <ChaiTRex> alestane: Can you please add the error message?
14:36:55 <alestane> Added. The error offers a fairly clear correction, it just seems like it adds more information rather than ignoring it.
14:38:59 <ChaiTRex> alestane: What is the type of calc?
14:45:59 <ChaiTRex> alestane: Have you implemented Eq for Candidate cost node?
15:09:09 <alestane> ChaiTRex, I did, but I just realized I moved it down below the definition.
15:09:36 <alestane> Oh, no I didn't.
15:12:54 <alestane> Adding "Eq node, " to the context does eliminate the issue.
15:15:40 <ChaiTRex> alestane: The issue is that your (==) definition requires Eq node. Ord also uses (==), so it needs the same restrictions.
15:16:23 <ChaiTRex> alestane: You could alternatively eliminate the requirement for Eq node in your Eq (Candidate cost node) instance.
15:17:49 <alestane> No, because (==) works by comparing two node values.
15:18:07 <alestane> But I think I understand what you're saying.
15:18:15 <ChaiTRex> alestane: Sure, but you could make it work regardless of node values. Might not be a good idea for your usecase, though.
15:21:18 <alestane> That's pretty much literally my definition of equality for candidates: if they have the same node value.
15:23:54 <ChaiTRex> alestane: You might want instance Ord ... where compare a b = compare (f a) (f b) where f x = (something with node, something with cost)
15:24:27 <ChaiTRex> alestane: If your (==) only considers node and your Ord functions only consider cost, then it will work weirdly.
15:25:18 <alestane> Interesting idea.
15:26:11 <alestane> I think I see what you mean.
15:26:58 <alestane> Since a lot of the order operator definitions use (==).
15:27:38 <ChaiTRex> alestane: Yeah, you'll have equal things also being greater than at the same time, for example.
15:27:56 <alestane> I might just have to use a callback to things like sort functions instead of implementing Ord.
15:30:17 <ChaiTRex> alestane: If you implement that Ord instance with the compare function with the tuple comparison, you can use compare for your Eq instance.
15:30:30 <ChaiTRex> > compare 5 5
15:30:35 <lambdabot>  EQ
15:31:11 <ChaiTRex> instance Eq ... where a == b = compare a b == EQ
15:31:47 <ChaiTRex> So your Ord instance would define equality and you'd just pull from it.
15:32:18 <alestane> Node values are identities only, requiring them to be orderable would be a fairly arbitrary constraint.
15:32:41 <ChaiTRex> alestane: No, I mean Ord (Candidate ... ...) and Eq for the same.
15:32:57 <ChaiTRex> alestane: Ahh, I see what you mean.
15:33:30 <alestane> It doesn't make sense for order to depend on home values.
15:34:21 <ChaiTRex> alestane: In that case, I don't see how you can have an Ord instance that fulfills the Ord laws. If the nodes match, they're equal. But if the costs don't match, then one can be strictly greater than.
15:34:57 <ChaiTRex> alestane: But it can't be both equal to and strictly greater than.
15:35:18 <alestane> So I'm going to have to split those operations. Either Eq can be based on home and costs have to be compared without the Ord class, or Eq and Ord have to be both based on cost.
16:42:24 * hackage verismith 0.6.0.1 - Random verilog generation and simulator testing.  https://hackage.haskell.org/package/verismith-0.6.0.1 (ymherklotz)
16:44:10 <koz_> Ord _relies_ on agreement with Eq. Stuff that uses Ord can assume this, so if your Ord instance doesn't agree with Eq, you're asking for weird breakages on code you didn't see or write.
17:09:20 <solonarv> koz_: unfortunately alestane left just before you said that :/
17:18:16 <shapr> ooh I like that verismith thingy, I gotta check that out
17:33:24 * hackage verismith 0.6.0.2 - Random verilog generation and simulator testing.  https://hackage.haskell.org/package/verismith-0.6.0.2 (ymherklotz)
18:49:04 <pounce> whats templatehaskell
18:49:53 <solonarv> template haskell is a way to inspect and generate Haskell code at compile time
18:50:05 <solonarv> in less fancy words, a macro system
18:50:46 <pounce> ah
20:24:02 <wonderC> where I can find the definition of callCC?
20:24:20 <dsal> @hoogle callCC
20:24:20 <lambdabot> Control.Monad.Trans.Cont callCC :: ((a -> ContT r m b) -> ContT r m a) -> ContT r m a
20:24:20 <lambdabot> Control.Monad.Cont callCC :: MonadCont m => ((a -> m b) -> m a) -> m a
20:24:21 <lambdabot> Control.Monad.Cont.Class callCC :: MonadCont m => ((a -> m b) -> m a) -> m a
20:25:20 <wonderC> https://hackage.haskell.org/package/transformers-0.5.6.2/docs/src/Control.Monad.Trans.Cont.html#callCC
20:26:17 <wonderC> callCC f = ContT $ \ c -> runContT (f (\ x -> ContT $ \ _ -> c x)) c
20:26:42 <wonderC> is there more generic version? like "c >>= f = \k -> c (\a -> f a k)"
20:27:15 <wonderC> remove that constructor wrapper
20:28:47 <mniip> callCC is not >>=
20:29:07 <wonderC> yeah, I know, I mean like
20:29:48 <wonderC>  m >>= k  = ContT $ \ c -> runContT m (\ x -> runContT (k x) c)
20:30:31 <wonderC> equal to "c >>= f = \k -> c (\a -> f a k)"
20:36:32 <mniip> sure?
20:36:38 <mniip> so what is your question
21:06:20 <wonderC> mniip: a JS version of callCC
21:26:24 * hackage pg-transact 0.3.0.0 - A postgresql-simple transaction monad  https://hackage.haskell.org/package/pg-transact-0.3.0.0 (JonathanFischoff)
21:51:53 * hackage hoauth2 1.9.1 - Haskell OAuth2 authentication client  https://hackage.haskell.org/package/hoauth2-1.9.1 (HaishengWu)
23:05:54 * hackage pg-transact 0.3.1.0 - A postgresql-simple transaction monad  https://hackage.haskell.org/package/pg-transact-0.3.1.0 (JonathanFischoff)
23:19:16 <wonderC[m]> :t id
23:19:17 <lambdabot> a -> a
23:24:19 <iqubic> :t id `asAppliedTo` id
23:24:22 <lambdabot> (a -> a) -> a -> a
23:24:34 <iqubic> :t asAppliedTo
23:24:35 <lambdabot> (a -> b) -> a -> a -> b
23:24:49 <ChaiTRex> @src asAppliedTo
23:24:49 <lambdabot> f `asAppliedTo` a = f where _ = f a
23:24:49 <lambdabot> infixl 0 `asAppliedTo`
23:25:02 <iqubic> What the hell?
23:25:18 <iqubic> I know it's just a lambdabot trick, but how does that work?
23:25:29 <ChaiTRex> How does what work, @src?
23:25:37 <iqubic> No. asAppliedTo?
23:26:02 <ChaiTRex> It's a function defined in some library or another. Not sure how it works.
23:26:18 <iqubic> like that type signature and that implementation don't seem to make sense to me.
23:26:40 <iqubic> :t let _ = f a in f
23:26:41 <lambdabot> error:
23:26:41 <lambdabot>     Ambiguous occurrence ‘f’
23:26:41 <lambdabot>     It could refer to either ‘Debug.SimpleReflect.f’,
23:26:45 <pavonia> :t negate `asAppliedTo` True
23:26:47 <lambdabot> error:
23:26:47 <lambdabot>     • No instance for (Num Bool) arising from a use of ‘negate’
23:26:47 <lambdabot>     • In the first argument of ‘asAppliedTo’, namely ‘negate’
23:26:55 <pavonia> Err
23:27:11 <pavonia> :t show `asAppliedTo` True
23:27:13 <lambdabot> Bool -> String
23:27:34 <ChaiTRex> iqubic: Looks like it's a lambdabot-specific function https://hackage.haskell.org/package/lambdabot-5.0.2/src/State/Pristine.hs.default
23:27:39 <iqubic> I know.
23:27:57 <ChaiTRex> iqubic: asAppliedTo f _ = f
23:28:00 <pavonia> It just specializes the type for a function based on the argument
23:28:53 <ChaiTRex> Oh, I get it. It's a type system thing.
23:28:57 <pavonia> :t show `asAppliedTo` undefined
23:28:58 <lambdabot> Show a => a -> String
23:29:10 <ChaiTRex> iqubic: _ is unused lvalue.
23:29:21 <ChaiTRex> iqubic: But f a forces f to have a certain type.
23:29:29 <iqubic> Right. Makes sense.
23:41:24 <Goldcoin> Hello ppl!! OMG there is free Bitcoin here!! : https://freebitco.in/?r=599908
23:53:19 <hololeap> :t show `asAppliedTo` True
23:53:20 <lambdabot> Bool -> String
23:54:49 <hololeap> :t show @Bool
23:54:51 <lambdabot> error:
23:54:51 <lambdabot>     Pattern syntax in expression context: show@Bool
23:54:51 <lambdabot>     Did you mean to enable TypeApplications?
23:55:01 <hololeap> % :t show @Bool
23:55:02 <yahb> hololeap: Bool -> String
23:55:44 <ChaiTRex> @let {-# LANGUAGE TypeApplications #-}
23:55:46 <lambdabot>  Defined.
23:55:52 <ChaiTRex> :t show @Bool
23:55:53 <lambdabot> error:
23:55:53 <lambdabot>     Pattern syntax in expression context: show@Bool
23:55:53 <lambdabot>     Did you mean to enable TypeApplications?
