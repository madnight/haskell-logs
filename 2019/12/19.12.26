00:12:23 * hackage cobot-tools 0.1.2.2 - Biological data file formats and IO  https://hackage.haskell.org/package/cobot-tools-0.1.2.2 (ozzzzz)
00:17:18 <wonderC> callCC :: ((a -> m b) -> m a) -> m a 
00:17:27 <wonderC> f :: (a->m b) -> m a
00:17:35 <wonderC> callCC f = ...
00:17:55 <wonderC> callCC is just return the m b within f?
00:18:05 <wonderC> m a
00:18:23 <wonderC> extract the continuation within f?
00:19:12 <wonderC> give f (a->m b)
00:20:48 <yasar> I made a haskell question in SO: https://stackoverflow.com/q/59485584/886669
00:26:27 <wonderC> phanimahesh[m]: hi there, are you familiar with callCC?
01:04:24 <ChaiTRex> :t ($ 2)
01:04:26 <lambdabot> Num a => (a -> b) -> b
01:50:24 * hackage tidal 1.4.6 - Pattern language for improvised music  https://hackage.haskell.org/package/tidal-1.4.6 (AlexMcLean)
03:38:32 <rhylx> Hi :).
03:39:48 <rhylx> Do some of you know if waymonad is a dead project or if it is still in development?
03:42:25 <FantasyCookie17[> Looks quite dead to me. Last release was 2 years ago, and as it was called 0.1, it sure wasn’t ready back then.
03:42:48 <FantasyCookie17[> But of course someone could fork and continue it.
03:44:47 <__monty__> XMonad has no intention of supporting Wayland?
03:45:31 <rhylx> __monty__: this would be amazing :)
03:46:07 <ph88> anyone know of a library to do logistical regression that is still maintained ?
03:46:19 <FantasyCookie17[> That’d probably mean a rewrite (that Waymonad probably was), so afaik no. Same was true for i3, were they did Sway, instead of porting (rewriting) i3 to Wayland.
03:47:14 <FantasyCookie17[> A window manager is quite tied to X11. Wayland uses an entirely different architecture, with only a compositor and clients. No server, no windows manager.
03:47:27 <FantasyCookie17[> * A window manager is quite tied to X11. Wayland uses an entirely different architecture, with only a compositor and clients. No server, no window manager.
03:49:26 <FantasyCookie17[> (the Wayland compositor handles most of the tasks normally the X server, window manager and compositor would do, Wayland is generally a more straightforward approach)
04:23:01 <amx> maybe it's not dead, but merely perfect the way it is ;)
04:25:59 <FantasyCookie17[> Don’t think so. I’m quite sure that the Wayland protocol has had quite a few updates since the last release of waymonad, including some for security.
08:07:23 <tempate> Fun fact: I believe this is the first channel I joined when I first heard about freenode 4/5 years ago. Then fun part is I didn't know Haskell or what it was for that matter.
08:08:54 * hackage secp256k1-haskell 0.1.6 - Bindings for secp256k1 library from Bitcoin Core  https://hackage.haskell.org/package/secp256k1-haskell-0.1.6 (xenog)
08:11:03 <tempate> That said, whenever I declare a function in ghci I get this error: https://bpaste.net/NU6A . What am I missing?
08:12:50 <geekosaur> everything has to go on one line, because ghci ccan't see what you'll type next
08:13:23 <geekosaur> semicolons between virtual "lines" making up a binding group (here, a definition or group of definitions along with the type signature)
08:14:12 <geekosaur> so for a simplistic example:   f :: Int -> Int; f 0 = 0; f x = x + 2
08:15:20 <tempate> Oh, I see. Thanks
08:17:33 <solonarv> you can also use :{ to start a multi-line command (and :} to end it)
08:21:03 <tempate> splendid
08:22:00 <geekosaur> I wonder if an apparren t standalone type signature should be one of those cases that triggers multiline input in recentish ghci
08:22:16 <solonarv> definitely sounds like a good idea
08:48:54 * hackage bitstream 0.3.0.0 - Fast, packed, strict and lazy bit streams with stream fusion  https://hackage.haskell.org/package/bitstream-0.3.0.0 (MasatakeDaimon)
09:05:42 <monochrom> No, it encourages even more procrastination of switching over to a real editor.
09:10:54 * hackage pg-transact 0.3.1.1 - A postgresql-simple transaction monad  https://hackage.haskell.org/package/pg-transact-0.3.1.1 (JonathanFischoff)
09:30:43 <oats> if a reload (:r) fails, is there any way to have ghci not clear all bindings?
09:31:05 <oats> makes mocking things up kinda difficult
09:34:53 <monochrom> None. People mitigate it by -fdefer-type-errors and/or two-phase commit (run two ghci instances).
09:37:13 <glguy> Related, :reload! Is a reload that enables deferred type errors
09:38:45 <monochrom> Hrm, I might like it to be called :reload? instead. :)
09:41:04 <c_wraith> nah, it forces it to be loaded, even with type errors
09:41:29 <monochrom> oh!
09:47:43 <avp> i want to write a function (f :: Maybe a -> [a] -> [a]) which cons the first argument to the second if the first argument is Just, else returns Nothing - what's the most elegant way of doing this?
09:48:03 <avp> i can obviously just pattern match but that's boring, surely there's a better way
09:48:41 <avp> sorry: i meant "else returns second arg", not "else returns Nothing"
09:48:46 <oats> > fmap (5:) (Just [1,2,3])
09:48:50 <lambdabot>  Just [5,1,2,3]
09:48:53 <oats> > fmap (5:) Nothing
09:48:55 <lambdabot>  Nothing
09:49:00 <oats> avp: functors \o/
09:49:45 <avp> that's the other way though - i want (Maybe a -> [a] -> [a]), not (a -> Maybe [a] -> Maybe [a])
09:50:29 <oats> avp: you can't return Nothing if the type signature is (... -> [a])
09:50:33 <oats> that can't typecheck
09:50:47 <avp> oats: sorry yeah i typoed that - i want to return the second arg, not Nothing 
09:51:04 <oats> ah
09:51:08 <oats> sorry, I misunderstood :)
09:51:25 <avp> oats: i want the equivalent of    f (Just a) as = a : as ; f Nothing as = as
09:51:28 <oats> :t maybe
09:51:29 <lambdabot> b -> (a -> b) -> Maybe a -> b
09:53:02 <solonarv> overly fancy:
09:53:23 <amalloy> :t \m as -> maybe id (:) m as
09:53:25 <lambdabot> Maybe a -> [a] -> [a]
09:53:26 <solonarv> % :t appEndo . foldMap @Maybe (Endo . (:))
09:53:27 <yahb> solonarv: Maybe a -> [a] -> [a]
09:53:39 <oats> solonarv: lol that's dirty
09:53:41 <oats> I love it
09:53:50 <avp> solonarv: what on earth
09:54:15 <avp> solonarv: what's the @ for?
09:54:28 <avp> amalloy, oats: i like this, thanks!
09:54:28 <solonarv> that just specializes foldMap to Maybe
09:54:38 <oats> > maybe id (:) (Just 5) [1,2,3]
09:54:40 <lambdabot>  [5,1,2,3]
09:54:46 <oats> > maybe id (:) Nothing [1,2,3]
09:54:49 <lambdabot>  [1,2,3]
09:54:49 <solonarv> % :t appEndo . foldMap (Endo . (:)) -- same thing, more general
09:54:49 <yahb> solonarv: Foldable t => t a -> [a] -> [a]
09:54:51 <oats> I think that's what you want ^ :P
09:55:06 <solonarv> yeah, 'maybe id (:)' is the sane answer
09:55:26 <oats> :t maybe id (:)
09:55:27 <avp> TIL about `maybe`, thanks folks
09:55:29 <lambdabot> Maybe a -> [a] -> [a]
09:55:37 <solonarv> oh, even better:
09:55:40 <dsal> For a slightly longer answer, there's also maybeToList
09:55:45 <solonarv> :t ala' foldMap Endo (:)
09:55:47 <lambdabot> error:
09:55:47 <lambdabot>     • Variable not in scope:
09:55:47 <lambdabot>         ala'
09:55:54 <solonarv> % :t ala' foldMap Endo (:)
09:55:54 <yahb> solonarv: ; <interactive>:1:1: error:; * Variable not in scope: ala' :: ((a0 -> m0) -> [a0] -> m0) -> ((a1 -> a1) -> Endo a1) -> (a2 -> [a2] -> [a2]) -> t; * Perhaps you meant one of these: `ala' (imported from Control.Lens), `alaf' (imported from Control.Lens)
09:56:02 <solonarv> nyeeh
09:56:17 <dsal> > maybeToList (Just 5) <> [1, 2, 3]
09:56:19 <lambdabot>  [5,1,2,3]
09:57:43 <solonarv> @let import CoercibleUtils
09:57:44 <lambdabot>  .L.hs:43:1: error:
09:57:44 <lambdabot>      Could not find module ‘CoercibleUtils’
09:57:44 <lambdabot>      Use -v to see a list of the files searched for.
09:57:48 <solonarv> aw
09:57:57 <solonarv> % import qualified CoercibleUtils as CU
09:57:57 <yahb> solonarv: ; <no location info>: error:; Could not find module `CoercibleUtils'; It is not a module in the current program, or in any known package.
09:58:36 * solonarv throws up their hands
09:58:56 * dsal is kind of curious where that was going
10:10:41 <dsal> avp: actually, take a look at Data.Maybe in general. There may be something better suited to what you're trying to do, like mapMaybe
10:26:12 <mastarija> I have C function which returns a pointer to address containing bitmap image. How can I read data on that address into a ByteString? I've found that there are utility functions which can convert CString into ByteString but what I have is not a CString.
10:28:23 <mastarija> I would assume I'd also have to specify number of bytes to read from that pointer, but I can't find any function which does something like that.
10:29:02 <maralorn[m]> Is anyone from here at 36c3?
10:30:40 <monochrom> 36c3 = 36*35*34/2/3 ?  :)
10:35:51 <monochrom> mastarija: Data.ByteString.packCStringLen can help.  If you want faster, look into Data.ByteString.Internal
10:36:21 <monochrom> Oh nevermind, you don't have CString.
10:36:22 <mastarija> monochrom: yes, but what I have is not CString
10:36:25 <mastarija> :D
10:36:51 <mastarija> I thing I've found something of interest in Data.ByteString.Internal
10:37:10 <monochrom> You need to break that abstraction and know what "bitmap" means.
10:37:22 <mastarija> Just a pointer to a block of memory
10:37:49 <mastarija> I just want to collect all the bits in that block of memory and put them in a bytestring
10:38:19 <monochrom> At this point maybe pretend it's char*
10:38:49 <monochrom> No compilers are checking types at that level anyway!
10:40:50 <mastarija> Hm... maybe.. but then I risk stopping at null char if it occurs too early.
10:41:34 <nshepperd1> A pointer to a block of memory?
10:41:46 <nshepperd1> How do you know how long this block is
10:42:18 <mastarija> Let's say I return size along with the pointer
10:42:56 <mastarija> So I have pointer to a block of memory and size of that memory.
10:43:11 <nshepperd1> packCStringLen sounds like what you want then
10:43:28 <mastarija> I'll try that then
10:43:58 <mastarija> nshepperd1, ByteString shouldn't do any encoding, right?
10:44:25 <nshepperd1> It would be very silly if it did
10:52:11 <monochrom> I think the convention is that given CStringLen the functions don't stop at 0.
11:06:49 <maralorn[m]> monochrom: The 36th Chaos Communication Congress. (Can‘t tell if you know.^^)
11:34:24 <jacks2> ginger hackage page provides "Minimal example template", but I can't find haskell code that will read that template, either on hackage, or on ginger's github page. https://hackage.haskell.org/package/ginger
11:38:15 <pounce> can i have multiple patterns in a lambda?
11:38:38 <amalloy> pounce: with the LambdaCase extension
11:39:28 <jacks2> case would work too
11:48:38 <__monty__> monochrom: Combination of 3 out of 36?
11:50:53 * hackage ilist 0.4.0.0 - Optimised list functions for doing index-related things  https://hackage.haskell.org/package/ilist-0.4.0.0 (shersh)
11:57:55 <pounce> amalloy: how does that work?
11:59:14 <amalloy> pounce: what did you find unclear when you read the documentation for LambdaCase?
12:01:23 * hackage shortcut-links 0.5.0.0 - Link shortcuts for use in text markup  https://hackage.haskell.org/package/shortcut-links-0.5.0.0 (vrom911)
12:08:15 <Teknokratsevilla> hi 
12:08:57 <reallymemorable> how wuold i go about puttiing this online on a site? https://github.com/concurhaskell/concur-react-sortable-tree
12:09:02 <reallymemorable> there is a demo here: https://ajnsit.github.io/concur/examples/sortable-tree-example.jsexe/index.html
12:09:15 <reallymemorable> i forked it and want to create a different version
12:10:14 <Teknokratsevilla> I want to model a problem in category theory fashion. I have a set of persons, that can be grouped into bigger groups, and some properties that change when the groups become bigger. How can I do this ? Cartesian products and projections ? How can I mix the properties of 'objects' and the aggregation of objects ?
12:23:53 * hackage gscholar-rss 0.2.4.0 - scrapes google scholar, provides RSS feed  https://hackage.haskell.org/package/gscholar-rss-0.2.4.0 (fffaaa)
12:26:54 * hackage cabal-macosx 0.2.4.2 - Cabal support for creating Mac OSX application bundles.  https://hackage.haskell.org/package/cabal-macosx-0.2.4.2 (dfrancesconi)
12:32:54 <pounce> hmm, how would i parse a lisp-style expression? should i use something like a parsing library?
12:37:00 <ChaiTRex> pounce: Yeah, that's a decent way to do so.
12:39:00 <pounce> are lisps context free?
12:39:25 <pounce> not sure if it would be better to learn how to use a parsing library or learn how to do it by myself
12:42:24 <jacks2> I'd start with using a parsing library, megaparsec seems to be popular these days. then later you can have a better idea how you'd implement your own
12:43:51 <pounce> oki
12:47:53 * hackage gscholar-rss 0.2.4.1 - scrapes google scholar, provides RSS feed  https://hackage.haskell.org/package/gscholar-rss-0.2.4.1 (fffaaa)
12:50:24 <shapr> megaparsec is good stuff, I especially like the quality error reporting
13:08:10 <amalloy> pounce: every lisp i'm aware of is context-free. the grammar is famously simple
13:08:57 <amalloy> of course to evaluate/compile it you need a lot of context, but just turning source text into a parsed s-expression is easy
13:14:51 <dmj`> if using a context-free grammar, can vouch for happy + alex
13:15:54 <dmj`> pounce: you might be interested in s-cargot
13:15:58 <dmj`> @package s-cargot
13:15:58 <lambdabot> http://hackage.haskell.org/package/s-cargot
13:17:52 <dmj`> there's a good tutorial on implementing a parser too
13:17:53 * hackage xcffib 0.9.0 - A cffi-based python binding for X  https://hackage.haskell.org/package/xcffib-0.9.0 (TychoAndersen)
13:17:56 <dmj`> http://dev.stephendiehl.com/fun/002_parsers.html
13:18:10 <dmj`> @unmtl StateT String [] a
13:18:10 <lambdabot> String -> [] (a, String)
13:18:16 <dmj`> is the type of Parser he uses
13:20:30 <dmj`> could probably be extended with ExceptT
13:26:05 <monochrom> maralorn[m]: Ah, I didn't know.
13:34:06 <wildtrees> suppose I want instance Expression expr => Expression (bool -> expr) but expr has kind: * -> * , how would I go about doing that? can't? 
13:38:55 <jacks2> I think the actual goal is to learn how to parse in haskell, and parsing s-expressions is just a means to an end.
13:46:54 * hackage slick 1.0.1.1 - A quick & easy static site builder built with shake and pandoc.  https://hackage.haskell.org/package/slick-1.0.1.1 (ChrisPenner)
13:52:55 <dmj`> wildtrees: Expression (expr a)
13:53:21 <dmj`> wildtrees: what is the kind of Expression ? (* -> *) -> Constraint ?
13:57:07 <pounce> dmj`: ok thank you i'll check it out!
13:59:43 <dmj`> jacks2: write yourself a scheme in 48 hours isn't bad for that
13:59:50 <dmj`> @google write yourself a scheme in 48 hours
13:59:51 <lambdabot> http://www.google.com/url?q=https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
13:59:51 <lambdabot> Title: Уведомление о переадресации
14:01:05 <ChaiTRex> Ahh, good ol' Уведомление о переадресации.
14:06:41 <wildtrees> dmj' that seems to end up all miskinded 
14:06:48 <Uniaika> no idea why it says "Call forwarding notification" in Russian.
14:06:58 <wildtrees> this doesn't work instance Expression (expr a) => Expression (Bool -> expr a) where 
14:07:06 <wildtrees> expression takes a * -> * 
14:07:10 <wildtrees> Expression that is 
14:08:48 <wildtrees> I am kind of emulating Gadts like Term a using Expression expr => expr a , and trying to work out the pattern matching from tagless final paper by Oleg that does something like Expr repr => Expr (Ctx -> repr) but my repr is * -> * not * 
14:10:05 <wildtrees> :kind Expression
14:10:05 <wildtrees>   ===>   Expression :: (* -> *) -> Constraint
14:13:04 <dmj`> ChaiTRex: lol 
14:14:17 <dmj`> @google typeclassopedia
14:14:18 <lambdabot> http://www.google.com/url?q=https://wiki.haskell.org/Typeclassopedia
14:14:19 <lambdabot> Title: Уведомление о переадресации
14:14:40 <dmj`> lambdabot was hacking elections
14:15:32 <wildtrees> @google haskell 
14:15:34 <lambdabot> http://www.google.com/url?q=https://www.haskell.org/
14:15:34 <lambdabot> Title: Уведомление о переадресации
14:15:45 <wildtrees> whats with the Russian? 
14:22:25 <evelyn> Does Google think lambdabot is in Russia?
14:22:58 <evelyn> geoip... :(
14:23:24 * hackage safe-json 1.1.0 - Automatic JSON format versioning  https://hackage.haskell.org/package/safe-json-1.1.0 (nideco)
14:23:28 <dmj`> wildtrees: instance Expr f => Expr ((->) (f a)) where
14:24:15 <dmj`> ламбдабот ис спи
14:24:24 * hackage streaming-events 1.0.1 - Client-side consumption of a ServerEvent.  https://hackage.haskell.org/package/streaming-events-1.0.1 (fosskers)
14:44:52 <wildtrees> dmj' thank you for your help thus far, but I don't think that is exactly what I am looking for , I end up having things like plus :: expr Integer -> expr Integer -> expr Integer in the typeclasse Expression expr 
14:54:08 <dmj`> that's no good
15:00:40 <pounce> what's @unmtl do
15:03:27 <pounce> humm are there any tutorials for megaparsec?
15:06:04 <pounce> or can i just rely on it being close enough to parsec
15:10:10 <dmj`> pounce: its like unmtl
15:10:15 <dmj`> un-mtl
15:10:27 <dmj`> where mtl is monad transformers library
15:10:29 <pounce> ah... it seems that megaparsec has a list of tutorials at the top of the doc page...
15:17:40 <javjarfer[m]> Hi everyone, I think I have found a deadlock bug in ghc, I just wanted to ask here first in case someone sees something obvious I'm doing wrong
15:18:06 <iqubic> What's the best way to find the first index of a value in a list?
15:18:44 <Axman6> @hoogle a -> [a] -> Maybe Int
15:18:45 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
15:18:45 <lambdabot> GHC.OldList elemIndex :: Eq a => a -> [a] -> Maybe Int
15:18:45 <lambdabot> Data.List.Utils elemRIndex :: Eq a => a -> [a] -> Maybe Int
15:19:45 * javjarfer[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/TMAmVmTXJUfuZmDNulqrAeLE >
15:20:06 <javjarfer[m]> and it resulted in ```thread blocked indefinitely in an mvar operation```
15:20:09 <jacks2> pounce, if you are relatively new to haskell, and/or parsing in haskell, this may be easier to follow. http://akashagrawal.me/beginners-guide-to-megaparsec/
15:20:15 <amalloy> :t (<<=)
15:20:17 <lambdabot> error:
15:20:17 <lambdabot>     • Variable not in scope: <<=
15:20:17 <lambdabot>     • Perhaps you meant one of these:
15:20:50 * javjarfer[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/UOLwPqsPIEDdGiCNAFcewiwO >
15:21:06 <javjarfer[m]> amalloy: sorry, typo, it was =<<
15:21:09 <amalloy> javjarfer[m]: that error message doesn't sound like a deadlock in ghc. it sounds like a deadlock in the io code your program uses
15:21:53 <javjarfer[m]> It's weird, I have been able to make it work, with the use of pseq
15:22:19 <javjarfer[m]> like this ```pseq (putStrLn =<< ioRes) ioRes```
15:22:46 <Axman6> o.O
15:23:02 <javjarfer[m]> weirdly, changing the order of the parameters to pseq, makes it deadlock again, and also the same with `seq`
15:23:11 <Axman6> that shouldn't have any effect - pseq <some IO action> shouldn't really _do_ anything
15:23:49 <javjarfer[m]> Axman6: maybe that's why it doesn't deadlock, it really doesn't do anything
15:23:49 <amalloy> Axman6: a `pseq` b should do something very different from a!
15:24:17 <javjarfer[m]> but it confirm that the deadlock is induced by the putStrLn operation
15:24:19 <amalloy> so putting the problematic code on the left side of a pseq will obviously "fix" things by just not executing the problematic code
15:28:54 * hackage haskellish 0.1.2 - For parsing Haskell-ish languages  https://hackage.haskell.org/package/haskellish-0.1.2 (dktr0)
15:34:14 <javjarfer[m]> amalloy: so, you think it's because `runSqlPersistMPool`? And that ghc has nothing to do with this?
15:36:46 <amalloy> it's hard to say. the code you claim you are running does not typecheck, because ioOperation should have type ReaderT backend (NoLoggingT (ResourceT IO)) a, not IO a
15:37:34 <amalloy> but it looks to me like the value you have denoted ioRes has a deadlock in it, and ghc is helpfully informing you of this rather than making you wait until the end of the universe to find out
15:38:27 <amalloy> or anyway (putStrLn =<< ioRes) has a deadlock. i don't quite see how this could have a deadlock while iores itself does not, but it sorta seems that way
15:38:39 <javjarfer[m]> amalloy: oh, yes of course, the type is the one you pointed out, but the 'a' is String, I just simplified it with IO String
15:39:10 <javjarfer[m]> that's the thing that makes me think about GHC
15:39:38 <javjarfer[m]> I mean, why only when I make putStrLn is when a deadlock is produced? Why not when the variable itself is evaluated?
15:41:47 <amalloy> perhaps runSqlPersistMPool produces its output string lazily, and printing forces it, uncovering the error. i'd be interested to see if something like length ioRes `seq` pure () also fails
15:42:44 <pounce> where do i get the `Text` stream for parsec
15:43:33 <pounce> ah, is it just Data.Text.Text
15:46:28 <javjarfer[m]> amalloy: well, this `return <$> length =<< ioRes `seq` pure ()` work perfectly 
15:49:29 <amalloy> why have you changed it to fmap return into the length? return x `seq` pure () doesn't evaluate anything interesting
15:49:54 * hackage svgcairo 0.13.2.1 - Binding to the libsvg-cairo library.  https://hackage.haskell.org/package/svgcairo-0.13.2.1 (HamishMackenzie)
15:51:15 <javjarfer[m]> amalloy: just followed from ` length ioRes `seq` pure () ` into something that typechecked
15:51:23 <amalloy> ioRes has a very confusing type. runSqlPersistMPool returns an IO a, and your example code is "ioRes <- runSqlPersistMPool ...", so ioRes does not seem likely to be a value of type IO a
15:51:30 <amalloy> what is the type of ioRes in your program?
15:51:49 <javjarfer[m]> amalloy: "IO String"
15:54:06 <amalloy> okay, so that explains why printing it can fail: it hasn't actually done any work yet, just returned an IO action that, if you performed it, would do some work
15:54:12 <Axman6> is it IO STring or String?
15:54:55 <javjarfer[m]> IO String
15:55:19 <amalloy> javjarfer[m]: i suspect that if you wrote: {ioRes <- runSqlPersistMPool; realRes <- ioRes}, you would get the same deadlock
15:56:04 <Axman6> sounds like you're definitely trying to run code that should only be run inside a transaction outside a transaction to me
15:56:13 <amalloy> yeah
15:56:50 <amalloy> whatever you are passing to runSqlPersistMPool looks like it has a "wrong" type: it is technically valid for it to be an IO (IO a), but it's unlikely to be very useful
15:57:21 <javjarfer[m]> that's sounds totally right
15:58:43 <javjarfer[m]> then... I think I should rethink how to execute some IO actions that I have, that I wanted to execute inside the transactions
15:59:04 <javjarfer[m]> since it looks like I can't use the returned values as regular ones
16:09:03 <javjarfer[m]> amalloy: Axman6 , well, `{ioRes <- runSqlPersistMPool; realRes <- ioRes}` this doesn't deadlock, but this does `{ioRes <- runSqlPersistMPool; realRes <- ioRes; putStrLn realRes}
16:09:23 <javjarfer[m]> also, any other operation that tries to deal with realRes, also ends in a deadlock
16:20:15 <iqubic> Alright, I want to split a list into 2 different lists. I want all the elements at the odd indexes to be in one of the output lists. I want all the elements in even index to be in the other output list.
16:21:09 <iqubic> How would I do that.
16:21:16 <iqubic> ??
16:21:44 <Rembane> iqubic:  unzip . zip . (id &&& tail)
16:21:54 <wildtrees> this is my initial guess, pattern match on like (a:b:cs) and uses two accumulators that you reverse each and return inside a helper function 
16:22:00 <wildtrees> or something like that 
16:22:02 <Rembane> That's also good 
16:22:19 <iqubic> Rembane: can you write that without using &&&??? I don't like that notation.
16:22:21 <amalloy> alternatively, transpose . Data.List.Split.chunksOf 2
16:22:27 <wildtrees> @type unzip 
16:22:29 <lambdabot> [(a, b)] -> ([a], [b])
16:22:54 <Rembane> iqubic: Sure: \xs -> unzip (zip xs (tail xs))
16:23:37 <amalloy> that doesn't look like an implementation of what iqubic was looking for
16:24:02 <Rembane> amalloy: Why not? 
16:24:07 <ChaiTRex> Seems like zip would kill the last element of an odd-length list.
16:24:17 <amalloy> > (\xs -> unzip (zip xs (tail xs))) [1..6]
16:24:19 <lambdabot>  ([1,2,3,4,5],[2,3,4,5,6])
16:24:21 <ChaiTRex> Maybe not.
16:24:25 <wildtrees> isn't unzip after a zip sort of id? 
16:24:43 <iqubic> No.
16:24:45 <amalloy> iqubic wanted 2 lists of size N/2
16:24:52 <amalloy> not 2 lists of size N-1
16:25:02 <amalloy> (transpose . chunksOf 2) [1..6]
16:25:08 <amalloy> > (transpose . chunksOf 2) [1..6]
16:25:11 <lambdabot>  [[1,3,5],[2,4,6]]
16:25:26 <ChaiTRex> > (transpose . chunksOf 2) [1 .. 7]
16:25:28 <lambdabot>  [[1,3,5,7],[2,4,6]]
16:25:31 <iqubic> amalloy: I did. But I want one list to have all the even numbers, and the other list to have all the odd numbers.
16:25:42 <iqubic> Which it seems like we have.
16:25:55 <wildtrees> iqubic, is it specific to list element values? 
16:25:57 <Rembane> amalloy: I'm a bit tired, so I might have fudged this 
16:26:00 <amalloy> yes, i suggested this implementation because it works
16:26:08 <iqubic> This will be very helpful on AoC 2015, Day 3, Part 2.
16:26:15 <iqubic> wildtrees: Yes.
16:26:29 <amalloy> tbh i wasn't sure if it would work for lists of odd length. glad to see it does
16:26:33 <wildtrees> then order might matter, and you probably want to use filter twice 
16:26:58 <amalloy> iqubic asked about list indices, not element values
16:27:38 <wildtrees> > let f1 ls = filter odd ls in let f2 ls = filter even ls in let f3 ls = (f1 ls,f2 ls) in f3 [1..17] 
16:27:40 <lambdabot>  ([1,3,5,7,9,11,13,15,17],[2,4,6,8,10,12,14,16])
16:27:48 <wildtrees> oh
16:27:54 <MarcelineVQ> ChaiTRex: what are you doing there? :>
16:28:03 <dsal> > partition odd [1..17] -- ^ wildtrees 
16:28:05 <amalloy> wildtrees: to implement what you're talking about, we would use partition
16:28:06 <lambdabot>  ([1,3,5,7,9,11,13,15,17],[2,4,6,8,10,12,14,16])
16:28:17 <ChaiTRex> MarcelineVQ: Just checking that it works for odd-length lists.
16:28:20 <wildtrees> is partition kinda new? 
16:28:27 <amalloy> no
16:28:31 <amalloy> :i partition
16:28:41 <amalloy> okay i don't know how to use :i in lambdabot
16:28:49 <ChaiTRex> lambdabot has failed us for the last time!
16:28:52 <wildtrees> % :i partition 
16:28:53 <yahb> wildtrees: partition :: (a -> Bool) -> [a] -> ([a], [a]) -- Defined in `base-4.12.0.0:Data.OldList'
16:28:53 <MarcelineVQ> you don't, yahb can though
16:29:08 <amalloy> but the point is it's in Data.OldList apparently? what the heck is that package?
16:29:33 <wildtrees> @hoogle partition 
16:29:33 <lambdabot> Data.List partition :: (a -> Bool) -> [a] -> ([a], [a])
16:29:34 <lambdabot> Data.List.NonEmpty partition :: (a -> Bool) -> NonEmpty a -> ([a], [a])
16:29:34 <lambdabot> GHC.OldList partition :: (a -> Bool) -> [a] -> ([a], [a])
16:29:36 <amalloy> oh, i was looking for the one in Data.List
16:30:11 <MarcelineVQ> > foldr (\x ~(ys,xs) -> (xs,x:ys)) ([],[]) [1,2,3,4,5] -- ChaiTRex: a favorite that I've seen
16:30:14 <lambdabot>  ([2,4],[1,3,5])
16:30:58 <iqubic> Well, that works.
16:31:37 <wildtrees> MarcelineVQ, is that ~ for lazy pattern matching necessary there? 
16:31:40 <MarcelineVQ> yes
16:31:46 <MarcelineVQ> well yes, for infinite lists.
16:31:58 <wildtrees> oh ok 
16:32:14 <amalloy> it's a good idea for finite lists too
16:32:25 <MarcelineVQ> > take 12 . fst $ foldr (\x ~(ys,xs) -> (xs,x:ys)) ([],[]) [1..]
16:32:26 <amalloy> otherwise both halves of the output depend on both halves of the input, so you can't produce values lazily
16:32:28 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24]
16:32:30 <MarcelineVQ> > take 12 . fst $ foldr (\x (ys,xs) -> (xs,x:ys)) ([],[]) [1..]
16:32:36 <lambdabot>  mueval-core: Time limit exceeded
16:33:19 <iqubic> If I need to find the number of unique elements in a list, is it faster to do (length . nub) or (S.size . S.fromList)?
16:33:57 <amalloy> :t nubOrd
16:33:59 <lambdabot> error: Variable not in scope: nubOrd
16:33:59 <MarcelineVQ> generally the latter
16:34:17 <amalloy> @hoogle nubOrd
16:34:18 <Rembane> > partition id (zip (cycle [True, False]) [1..10])
16:34:18 <lambdabot> Data.Containers.ListUtils nubOrd :: Ord a => [a] -> [a]
16:34:18 <lambdabot> Data.List.Extra nubOrd :: Ord a => [a] -> [a]
16:34:18 <lambdabot> Extra nubOrd :: Ord a => [a] -> [a]
16:34:20 <lambdabot>  error:
16:34:20 <lambdabot>      • Couldn't match type ‘(Bool, Integer)’ with ‘Bool’
16:34:20 <lambdabot>        Expected type: [Bool]
16:34:26 <Rembane> Huh
16:34:26 <iqubic> Well, actually, in this case I have two lists, and I want the number of unique items across both lists. So I turned them both into sets, then took their union, and then took their size.
16:34:43 <Rembane> > map snd (partition fst (zip (cycle [True, False]) [1..10]))
16:34:47 <lambdabot>  error:
16:34:47 <lambdabot>      • Couldn't match expected type ‘[(a0, b)]’
16:34:47 <lambdabot>                    with actual type ‘([(Bool, Integer)], [(Bool, Integer)])’
16:34:53 <Rembane> Too tired. Nevermind.
16:35:46 <MarcelineVQ> Rembane: use the forbidden technique fortold on an ancient scroll of testing the solution in private and seeming to get it first try in public ;>
16:36:03 <monochrom> Please don't overwork yourself for a detailed exact answer :)
16:38:19 <iqubic> Is there a good library I can use to calculate MD5 hashes in Haskell. I'm working through old Advent of Code puzzles and I've come to this one.
16:38:50 <iqubic> It's 2015 day 4 if anyone cares.
16:39:01 <MarcelineVQ> monochrom: detailing about nub being O(n^2) and length being O(n) while size is O(1) and fromList being O(n*log n) resulting in less time complexity in nearly all possible cases?
16:39:08 <koz_> iqubic: http://hackage.haskell.org/package/cryptohash-md5 <-- this perhaps?
16:39:13 <Rembane> MarcelineVQ: That's a very good and very forbidden technique, thank you. When my brain works I have no problem getting it right on the first try, and when it doesn't work I'm too stupid to try it out in private. 
16:40:20 <Axman6> does cryptonite not not also have MD5?
16:40:40 <koz_> Axman6: It probbo does, but I suspect it's easier to use cryptohash-md5 because there's less to learn.
16:41:13 <iqubic> koz_: How do I use cryptohash-md5?
16:41:19 <koz_> iqubic: Read the docs?
16:41:30 <koz_> It's basically a one-file library, so I suspect it's not hard.
16:41:47 <koz_> There's even an example at the top.
16:42:50 <iqubic> The only thing I don't understand is the update function.
16:42:54 <iqubic> What does that do?
16:44:00 <koz_> iqubic: It works like mutable state - you init, then 'update in' everything the hash ought to contain, then finalize.
16:44:11 <iqubic> I see.
16:44:12 <koz_> It lets you do something similar to folds where the data is delivered incrementally.
16:44:18 <koz_> (you can tell from the example and the text right above it)
16:44:25 <iqubic> I'm just going to use the single pass functions.
16:48:22 <iqubic> Is there a way to convert a ByteString into a regular String?
16:50:08 <wildtrees> BS.unpack 
16:50:13 <wildtrees> @hoogle unpack 
16:50:14 <lambdabot> Data.ByteString unpack :: ByteString -> [Word8]
16:50:14 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
16:50:14 <lambdabot> Data.ByteString.Lazy unpack :: ByteString -> [Word8]
16:50:18 <wildtrees> hmmm
16:50:39 <wildtrees> the one from Data.ByteString.Char8 must be what I am using for an unpack that does that 
16:50:49 <ChaiTRex> iqubic: Search Hoogle for the type of the function https://hoogle.haskell.org/?hoogle=ByteString%20-%3E%20String
16:51:04 <ChaiTRex> iqubic: It has things like UTF8 supporting functions, for example.
16:51:27 <dsal> Note that ByteString and String aren't exactly the same sort of thing.
16:51:44 <iqubic> Well.. this isn't working.
16:51:50 <fog> how are instances written using the new type level dot ?
16:53:03 <iqubic> Using Data.ByteString.Char8 and "hash = BS.unpack . MD5.hash . BS.pack" is giving me nonsense.
16:53:09 <iqubic> -- >>> hash "abcdef609043"
16:53:12 <iqubic> -- "\NUL\NUL\SOH\219\191\163\165\200:-Pd)\199\176\SO"
16:53:32 <Axman6> you need to turn it into base16
16:53:36 <ChaiTRex> iqubic: The hash will be in binary.
16:53:41 <Axman6> that "nonsense" is the actual hash data
16:54:10 <dsal> The :-P should've given it away.
16:54:21 <iqubic> How do I do that???
16:54:41 <Axman6> bloody hell iqubic, when will you learn to use Google? just once in your life
16:54:42 <dsal> What do you expect to see there?
16:55:13 <iqubic> dsal: I'm trying to do Advent of Code 2015, Day 4, Part 1.
16:55:14 <avp> i want to write a function (f :: Map a a -> a -> [a]) which takes a Map and a starting point, and then constructs a list of associations by following key -> value paths until a value is not a member of the map - what's an elegant way to do this without manually writing the recursive function and casing on Map.lookup?
16:55:14 <MarcelineVQ> https://hackage.haskell.org/package/cryptohash-md5-0.11.100.1/docs/Crypto-Hash-MD5.html does happen to mention how one can do that
16:55:14 <Axman6> seriously, you've been doing this for months and months, asking questions which would be answered much quicker if you just googled them
16:55:33 <fog> does yahb use the new GHC that includes type level dot ?
16:55:48 <Axman6> avp: unfoldr would work well for that
16:56:02 <MarcelineVQ> % :! ghc --version
16:56:02 <Axman6> :t unfoldr
16:56:03 <yahb> MarcelineVQ: The Glorious Glasgow Haskell Compilation System, version 8.6.0.20180620
16:56:04 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
16:56:30 <iqubic> Wat is the new type leve dot?
16:56:52 <avp> Axman6: hah pretty cool (never occurred to me to call that "unfold")
16:57:06 <shachaf> iqubic: Axman6 is making a good point and you should think about it rather than ignore it.
16:58:08 <fog_> % :! ghc --version
16:58:08 <yahb> fog_: The Glorious Glasgow Haskell Compilation System, version 8.6.0.20180620
17:03:05 <fog> i guess i should be able to write an instance of a class eg, ListNesting, which is satisfied if a type of kind * -> * is made from [] composed together using (.) to some depth 
17:03:33 <dsal> I ran out of time just as I have    root </> formatTime ... </> printf "/x"    deciding my file should be named "/x"   This mystery will haunt me for hours.
17:04:02 <fog> by having a recursive instance that calls the constraint on the tail of the [] . [] . [] .... sequence, matching the head (.)
17:04:15 <fog> and a basecase where [] is an instance
17:05:44 <fog> i cant find the type level (.) documentation though
17:07:07 <fog> this says it was planned; ctrl-f #39 https://gitlab.haskell.org/ghc/ghc/wikis/status/ghc-8.8.1
17:14:43 <fog10> im running 8.8.1 but :set -XTypeOperators does not enable type level (.)
17:15:08 <fog10> type Lists = ([] . [])
17:15:22 <fog10> Not in scope: type constructor or class `.'
17:16:31 <ChaiTRex> fog10: I think you have to define it with: type (f . g) x = f (g x)
17:16:41 <ChaiTRex> fog10: See https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0173-dot-type-operator.rst
17:18:47 <fog> is it a special language option which enables type level (.) ?
17:19:13 <fog> or did this milestone just not get included in 8.8.1 ? how could I check?
17:19:27 <ChaiTRex> fog: I think you have to define it with: type (f . g) x = f (g x)
17:19:31 <ChaiTRex> fog: See https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0173-dot-type-operator.rst
17:19:46 <fog> oh, on the lhs of the = 
17:19:48 <fog> strange
17:20:32 <fog> wait, why do you have to define it, want the plan to release it as part of the language? or did it just enable that to be written?
17:20:38 <fog> couldnt that be written before?
17:20:51 <fog> wasnt*
17:21:22 <fog> % type (f . g) x = f (g x)
17:21:22 <yahb> fog: ; <interactive>:41:9: error:; Illegal symbol '.' in type; Perhaps you meant to write 'forall <tvs>. <type>'?
17:22:04 <fog> aha, ok, it just dissalows you from writing that in versions before 8.8.1
17:22:06 <fog> thanks!
17:22:30 <fog> it just allows me to define type level (.) now.
17:23:28 <fog> was there any advance on defunctionalisation, for partially applied type families and type level functions as "first class types"?
17:37:54 * hackage greskell-core 0.1.3.0 - Haskell binding for Gremlin graph query language - core data types and tools  https://hackage.haskell.org/package/greskell-core-0.1.3.0 (debugito)
17:39:24 * hackage greskell-websocket 0.1.2.0 - Haskell client for Gremlin Server using WebSocket serializer  https://hackage.haskell.org/package/greskell-websocket-0.1.2.0 (debugito)
17:40:54 * hackage greskell 1.0.0.0 - Haskell binding for Gremlin graph query language  https://hackage.haskell.org/package/greskell-1.0.0.0 (debugito)
17:44:17 <iqubic> @pl \x -> map (== x) ["ab","cd","pq","xy"]
17:44:18 <lambdabot> flip map ["ab", "cd", "pq", "xy"] . (==)
17:44:22 <iqubic> Eww...
17:49:09 <Clint> what were you hoping for?
17:51:29 <avp> what does @pl do?
17:51:59 <ChaiTRex> @help pl
17:51:59 <lambdabot> pointless <expr>. Play with pointfree code.
17:52:11 <ChaiTRex> avp: It removes lambda arguments.
17:52:21 <Axman6> makes code pointfree (pl is short for "pointless", a pun on it not being something you should really spend much time doing)
17:54:46 <MarcelineVQ> see also   eta conversion
17:55:55 <phanimahesh[m]> wonderC: yep, I used callCC. My response is probably a day late
17:58:20 <avp> MarcelineVQ: yeah that's what i'm used to calling it
17:59:05 <wonderC> phanimahesh[m]: callCC f cc = f (\x _ -> cc x) cc
17:59:43 <wonderC> phanimahesh[m]: what this f should be like?
18:00:17 <wonderC> callCC :: ((a->m b)->m a) -> m a
18:00:26 <wonderC> f :: ((a->m b) -> m a)
18:01:22 <shachaf> f takes a continuation and produces a value of type "a".
18:01:32 <fog>     * The type synonym `.' should have 3 arguments, but has been given 2
18:01:37 <shachaf> It can either do that by returning it the usual way, or by calling the continuation.
18:02:06 <fog> should have a Functor f constraint too..
18:03:24 <fog> so while now type level (.) allows Free to be written as a synonym, it cannot be pattern matched over at type level
18:03:55 <fog> in instances that are written over these synonyms 
18:54:55 <fog> why wont this compile? https://pastebin.com/raw/qcqGEesd
18:58:03 <heatsink> I suppose it doesn't expand type families when checking if a GADT is valid
19:01:04 <amalloy> i'm confused: where is toNesting defined? i see lots of ToNesting but only one toNesting
19:02:25 <iqubic> fog: you need to make the T capital in the type signature for Nesting.
19:12:38 <hololeap>  @hoogle when
19:12:49 <hololeap> @hoogle when
19:12:50 <lambdabot> Control.Monad when :: Applicative f => Bool -> f () -> f ()
19:12:50 <lambdabot> System.Directory.Internal.Prelude when :: Applicative f => Bool -> f () -> f ()
19:12:50 <lambdabot> Distribution.Compat.Prelude.Internal when :: Applicative f => Bool -> f () -> f ()
19:18:03 <hololeap> how is applicative pronounced? :D
19:19:24 * hackage exceptions 0.10.4 - Extensible optionally-pure exceptions  https://hackage.haskell.org/package/exceptions-0.10.4 (ryanglscott)
19:20:38 <MarcelineVQ> depends what part of the UK you're from
19:27:15 <wonderC> shachaf: f :: ((a->m b) -> m a)  should be f take a function, that function take a and return a continuation m b?
19:27:27 <wonderC> m b and m a are continuations?
19:29:15 <shachaf> No, (a -> m b) represents the continuation.
19:40:24 * hackage Set 0.0.0.0 - See README for more info  https://hackage.haskell.org/package/Set-0.0.0.0 (MatthewFarkasDyck)
19:41:13 <shachaf> Good README.
19:43:25 <dsal> Giant classes seem like a bad idea.
19:44:54 * hackage Set 0.0.1.0 - See README for more info  https://hackage.haskell.org/package/Set-0.0.1.0 (MatthewFarkasDyck)
19:46:58 <EvanR> see source code for more info
19:53:52 <wonderC> shachaf: but Cont r a = Cont (a->r)->r
19:54:25 <wonderC> that (a->r)->r is m a
20:05:23 * hackage Set 0.0.2.0 - See README for more info  https://hackage.haskell.org/package/Set-0.0.2.0 (MatthewFarkasDyck)
20:11:14 <dsal> Every commit message is exactly one word, but five commits in he's already got three releases and has used the same commit message twice.
20:11:29 <dsal> I don't think I can trust a set that has duplicates like that.
20:11:52 * Clint chokes.
20:15:11 <EvanR> lol
20:15:12 <Clint> there's already a deprecation
20:15:50 <pavonia> Oh no, I followed the advice given in the README and am now stuck in an infinite recursion  D:
20:20:31 <dsal> @hoogle (∘∘)
20:20:33 <lambdabot> RIO exitFailure :: MonadIO m => m a
20:20:33 <lambdabot> RIO exitSuccess :: MonadIO m => m a
20:20:33 <lambdabot> Universum.Lifted.Env exitFailure :: MonadIO m => m a
20:20:44 <dsal> That is that and why is it looking at me like that?
20:22:14 <dsal> @package util
20:22:14 <lambdabot> http://hackage.haskell.org/package/util
20:22:24 <ponyIWant> Hello! How to incrementally parse `ByteString` using attoparsec? I tried to use `parseWith`. But I always get `not enough input` error.
20:23:07 <ponyIWant> I use it with `Network.Socket` library, messages may be up to 16KB in length
20:23:35 <ponyIWant> And I somehow need to resupply a parser if there is not enough
20:23:50 <ponyIWant> And it seems `parseWith` calls `IO` action only once
20:24:18 <dsal> As a rancher, I appreciate whatever (<₪>) is supposed to represent.
20:24:32 <ephemient> þrd3
20:25:24 <ephemient> ah, thorn... hardly see you outside of icelandic anymore
20:25:32 <dsal> ponyIWant: you can do it with partial data, but I've had great luck just using conduit when I need to do whatever it is you're trying. :)
20:26:03 <dsal> Otherwise, you need to get data, feed it, and deal with partial state yourself.
20:26:38 <ponyIWant> I tried to, but for some reason I don't get partial result but a `not enough input` error
20:27:00 <dsal> Hmm..  can you show some code?
20:27:23 <ponyIWant> `res <- parseWith (SB.recv sock (Net.blockSize)) parser leftovers`
20:27:46 <ponyIWant> That's pretty much it. Then I use `case` to check whether it's an error or partial or result
20:28:02 <ponyIWant> And it always returns an error with that message
20:28:20 <pavonia> What does you parser look like?
20:28:24 <pavonia> *your
20:30:15 <ponyIWant> pavonia, https://paste.debian.net/1122833/
20:31:15 <shachaf> wonderC: Yes, that's true.
20:32:57 <wonderC> shachaf: f ::(a->m b) -> m a,  can you give a function that like f? concret
20:34:38 <pavonia> ponyIWant: Does it work if you parse incomplete messages with `parse`, i.e. is it returning Partial results?
20:35:14 <ponyIWant> I didn't try that, but I will right now, thank you 
20:41:20 <shachaf> wonderC: If you're talking about callCC, you can imagine that b is Void.
20:41:24 <shachaf> And you probably should.
20:41:47 <ponyIWant> It always takes minutes for GHC to link everything. Can I speed this up somehow?
20:42:54 * hackage reg-alloc-graph-color 0.0.0.0 - Register allocation by graph colorization  https://hackage.haskell.org/package/reg-alloc-graph-color-0.0.0.0 (MatthewFarkasDyck)
20:42:56 <c_wraith> get enough RAM so that ld doesn't swap.  or set GHC up to use gold instead of ld
20:44:06 <ponyIWant> pavonia, it seems returned continuation can't return another one
20:44:26 <ponyIWant> Because it first returns it, and then fails with `not enough input` message
20:46:50 <pavonia> ponyIWant: Is that with messageID == 5?
20:47:21 <ponyIWant> Oh, I see, it seems `recv` returns 0-len `bytestring` and it fails because docs say "To indicate that no more input is available, pass an empty string to the continuation."
20:47:33 <ponyIWant> I need to see why is this
20:50:53 * hackage markov-realization 0.3.3 - Realizations of Markov chains.  https://hackage.haskell.org/package/markov-realization-0.3.3 (alexloomis)
21:21:17 <pounce> how do i set a language thing like `-XOverloadedStrings` in a haskell file
21:21:52 <heatsink> {-# LANGUAGE OverloadedStrings #-}
21:23:11 <pounce> tyy
21:52:18 <iqubic> pounce: That has to go at the very top of the file.
21:56:53 <ephemient> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pragmas
21:57:22 <ephemient> can have comments and other pragmas before, but before `module`
21:59:52 <pounce> is there any way for a parser to consume nothing in megaparsec? is that juts `empty` from applicative?
22:04:48 <amalloy> pounce: per https://hackage.haskell.org/package/megaparsec-8.0.0/docs/Text-Megaparsec.html#t:ParsecT "empty is a parser that fails without consuming input."
22:05:02 <pounce> ah... sorry dumb
22:05:17 <amalloy> generally anything produced by pure will work, because in any applicative (pure x) is a do-nothing action that produces x as its value
22:58:30 <wonderC> callCC f = (\c -> f (\a k -> c a) c)
22:58:48 <wonderC> is there a f's definition? without it I don't understan callCC...
23:01:29 <iqubic> f isn't defined anywhere in that function definition. It's the argument to callCC.
23:02:39 <wonderC> iqubic: what's the argument f should like? 
23:02:49 <wonderC> a concret definition
23:03:07 <wonderC> what's the effect of callCC?
23:03:18 <wonderC> it's not like call/cc in scheme?
23:09:02 <iqubic> actually, I think you'll find that it is the same sort of thing.
23:12:31 <wonderC> iqubic: in Scheme, that call/cc is primitive implemented, they can store that whole continution into a global variable, so they can call it anywhere anytime, but in this case it's a function
23:12:36 <wonderC> in haskell
23:12:57 <wonderC> that cc should be an unary funciton 
23:14:33 <iqubic> Ah. See. callCC in haskell is a unary function.
23:14:38 <iqubic> :t callCC
23:14:39 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
23:14:54 <iqubic> Only one argument.
23:16:01 <iqubic> that source above is just wrong.
23:16:17 <wonderC> iqubic: an unary I assume has (a->a)
23:16:37 <wonderC> iqubic: what's wrong?
23:17:26 <pavonia> iqubic: I think it's just an unwrapped version of what Cont does internally
23:17:39 <iqubic> pavonia: Yes, that is right.
23:17:49 <iqubic> wonderC: Nothing is wrong.
23:18:13 <wonderC> pavonia: iqubic callCC f cc = f (\x _ -> cc x) cc  this is right?
23:18:39 <iqubic> I'm not sure right now.
23:18:53 <pavonia> I would say yes
23:19:13 <iqubic> I don't think callCC is supposed to be a two argument function.
23:19:16 <wonderC> this is right? callCC f = (\c -> f (\a k -> c a) c)
23:20:55 <wonderC> pavonia: what's the effect of callCC ?
23:21:25 <pavonia> It goes on processing the f continuation, but when f's parameter is called, it goes "back" to the old one
23:22:22 <pavonia> c is the current continuation here, f the new one
23:22:36 <pavonia> or f applied to something
23:25:14 <wonderC> pavonia: is there an example to help understanding.
23:25:36 <wonderC> based on the type callCC :: ((a -> m b) -> m a) -> m a 
23:25:55 <wonderC> or forget the type
23:25:59 <wonderC> just use functions
23:26:31 <shachaf> Why do you want to understand callCC? Are you trying to do something with it? Do you already understand it in another context?
23:27:28 <teleirc> <S​chmollCatto> a
23:27:33 <wonderC> shachaf: I'd like to use 'goto', I knew it in scheme
23:28:00 <iqubic> haskell doesn't have 'goto'. GOTO is bad. Never use it.
23:28:28 <shachaf> wonderC: Maybe you can write your Scheme example.
23:28:29 <wonderC> iqubic: callCC can do a part of 'goto'
23:30:42 <shachaf> Goto is evil, a sinner's tool, and if you use it you forfeit your soul. That's what the good book tells me.
23:30:56 <shachaf> Remember, programming is dogma.
23:36:57 <amalloy> iqubic: have you read "lambda the ultimate goto"?
23:41:06 <wonderC> shachaf: shaf
23:41:13 <wonderC> shachaf: https://paste.ubuntu.com/p/8kbQq8cKSk/
23:43:25 <shachaf> wonC
23:43:39 <shachaf> I suggest an example that doesn't also use mutable state, to make it simpler to understand.
23:44:08 <wonderC> shachaf: that's easy to understand in scheme
23:44:16 <wonderC> just a loop to print 10
23:47:33 <shachaf> I don't think that Scheme example is easy to understand, but at any rate it'll be more complicated in Haskell for the reason I said.
23:52:58 <int-e> shachaf: Oh is that the idea? People are so afraid of going to hell that they try to avoid the mere act of "going to"?
23:53:45 <wonderC> that callCC implement, is same in haskell and scheme?
23:55:29 <int-e> Isn't it built into scheme? In Haskell it's a function associated with the continuation monad(s).
23:56:37 <wonderC> yes, so basicaly it's not the same implement
23:56:46 <shachaf> int-e: That must be it.
