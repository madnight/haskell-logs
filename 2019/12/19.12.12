00:01:13 <yasar> I am trying to implement sieve of sundram: https://www.wikiwand.com/en/Sieve_of_Sundaram
00:01:34 <yasar> I have generated the list of numbers to cross with: `toBeCrossed n = sort $ filter (<= n) [i + j + 2*i*j | j <- [1..n], i <- [1..j]]`
00:01:48 <yasar> I have no idea how to do the crossing :)
00:02:22 <EvanR> crossed?
00:03:24 <Ailrun[m]> :t foldl
00:03:26 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
00:05:30 <yasar> EvanR, elements of the list generated by `toBeCrossed` should be removed from the list `[1..n]`
00:06:23 <iqubic> @quote jle` sleep
00:06:23 <lambdabot> jle` says: let sleep = pure "zzz" in getSum sleep
00:06:57 <EvanR> if the removals list is ascending, then you can remove them from [1..n] more efficiently
00:07:47 <yasar> EvanR, I thought soo too, therefore I sort in `toBeCrossed`
00:07:58 <yasar> but couldn't implement the remove algorithm
00:08:28 <EvanR> well, you know the 4 cases of the removal algorithm
00:08:34 <EvanR> to start
00:09:22 <EvanR> (x:xs) (y:ys), (x:xs) [], [] (y:ys), [] []
00:10:07 <EvanR> the first case is the only one that is non trivial, i think
00:22:58 <yasar> EvanR, I think I got it: https://gist.github.com/yasar11732/5c32906c38a5dcae174ee81557b1a408#file-hw4-hs-L31
00:40:55 <maerwald> how to find unused dependencies in cabal files?
00:41:09 <jle`> maerwald: i usually use 'weeder'
00:42:34 <maerwald> doesn't that require stack?
00:45:00 <maerwald> also, is there a way to list all test targets in hspec?
00:45:07 <bahamas> maerwald: looks like it does http://hackage.haskell.org/package/weeder
00:46:39 <bahamas> maerwald: but weeder recommends this which doesn't require stack https://github.com/joshuaclayton/unused
00:46:57 <bahamas> although that might not cover cabal files
00:51:17 <iqubic> :t traverse sequenceA
00:51:19 <lambdabot> (Applicative f, Traversable t1, Traversable t2) => t1 (t2 (f a)) -> f (t1 (t2 a))
00:51:29 <iqubic> HOW THE HELL?!?!
00:54:18 <koz_> Follow the types.
00:54:34 <koz_> :t traverse traverse
00:54:36 <lambdabot> (Traversable t1, Traversable t2, Applicative f) => t1 (a -> f b) -> t2 a -> t1 (f (t2 b))
01:01:44 <iqubic> :t traverse
01:01:47 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
01:02:43 <iqubic> I don't get how traverse traverse works.
01:03:40 <Solonarv> :t traverse traverse
01:03:41 <lambdabot> (Traversable t1, Traversable t2, Applicative f) => t1 (a -> f b) -> t2 a -> t1 (f (t2 b))
01:03:54 <Solonarv> hm, that doesn't look super useful
01:04:47 <iqubic> Yeah.
01:08:49 <nil> :t traverse
01:08:50 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
01:10:08 <nil> So traverse traverse is using Applicative ((->) t a) for the first traverse, I think
01:11:30 <nil> Well t2 a
01:12:43 <boxscape> :t traverse . traverse
01:12:45 <lambdabot> (Applicative f, Traversable t1, Traversable t2) => (a -> f b) -> t1 (t2 a) -> f (t1 (t2 b))
01:13:42 <Solonarv> yes, composing 'traverse' with itself yields something much more reasonable
01:21:49 <boxscape> % (traverse . traverse) Just [[1..5],[1..6],[1..3]]
01:21:49 <yahb> boxscape: Just [[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3]]
01:21:53 <boxscape> % (traverse . fmap) Just [[1..5],[1..6],[1..3]]
01:21:53 <yahb> boxscape: [[Just 1,Just 1,Just 1],[Just 1,Just 1,Just 2],[Just 1,Just 1,Just 3],[Just 1,Just 2,Just 1],[Just 1,Just 2,Just 2],[Just 1,Just 2,Just 3],[Just 1,Just 3,Just 1],[Just 1,Just 3,Just 2],[Just 1,Just 3,Just 3],[Just 1,Just 4,Just 1],[Just 1,Just 4,Just 2],[Just 1,Just 4,Just 3],[Just 1,Just 5,Just 1],[Just 1,Just 5,Just 2],[Just 1,Just 5,Just 3],[Just 1,Just 6,Just 1],[Just 1,Just 6,Just 2],[Just 1,
01:23:16 <iqubic> > maxBound (1::Int)
01:23:19 <lambdabot>  error:
01:23:19 <lambdabot>      • No instance for (Bounded (Int -> ()))
01:23:19 <lambdabot>          arising from a use of ‘e_11’
01:23:25 <iqubic> :t maxBount
01:23:27 <lambdabot> error:
01:23:27 <lambdabot>     • Variable not in scope: maxBount
01:23:27 <lambdabot>     • Perhaps you meant ‘maxBound’ (imported from Prelude)
01:23:29 <merijn> iqubic: maxBound is not a function
01:23:39 <merijn> > maxBound :: Int
01:23:42 <lambdabot>  9223372036854775807
01:23:44 <iqubic> I see.
01:23:49 <boxscape> % maxBound @Int
01:23:49 <yahb> boxscape: 9223372036854775807
01:24:07 <iqubic> Why doesn't that look like 2^31?
01:24:14 <boxscape> % 2^31
01:24:14 <yahb> boxscape: 2147483648
01:24:18 <boxscape> % 2^63
01:24:18 <yahb> boxscape: 9223372036854775808
01:24:26 <Solonarv> maxBound has to be *at least* 2^31
01:24:28 <boxscape> because 64-bit systems are standard nowadays
01:24:32 <iqubic> Ah. I see.
01:24:38 <Solonarv> it is allowed to cover a wider range
01:24:42 <iqubic> ah. I see.
01:24:57 <iqubic> > 2^63 - 271442326847376
01:25:00 <lambdabot>  9223100594527928432
01:25:29 <iqubic> Alright. My number of steps until repeat was nowhere near being close to overflowing on my 64 bit machine.
01:26:17 <iqubic> The powers of 2 get so big so fast.
01:27:26 <boxscape> % (sequence . sequence) $ (traverse . fmap) print [[1..5],[1..6],[1..3]]
01:27:28 <yahb> boxscape: *** Exception: heap overflow
01:27:30 <boxscape> hm
01:27:32 <haskelllisp[m]> instance GValidate (K1 a (Maybe k)) (K1 a k) where
01:27:55 <iqubic> haskelllisp[m]: This seems like the wrong place for that.
01:28:34 <haskelllisp[m]> http://reasonablypolymorphic.com/blog/higher-kinded-data/
01:28:57 <haskelllisp[m]> i can't understand `GValidate`
01:29:10 <merijn> haskelllisp[m]: That's normal :p
01:31:09 <haskelllisp[m]> So hard
01:32:55 <bahamas> haskelllisp[m]: what part of it don't you understand?
01:34:54 <haskelllisp[m]> class GValidate i o where
01:34:57 <boxscape> % (sequence . sequence) (["ab","xyz"]) -- this does something completely different from what I would have naively guessed
01:34:57 <yahb> boxscape: ["aaabbb","aaabbz","aaabyb","aaabyz","aaaxbb","aaaxbz","aaaxyb","aaaxyz","aazbbb","aazbbz","aazbyb","aazbyz","aazxbb","aazxbz","aazxyb","aazxyz","ayabbb","ayabbz","ayabyb","ayabyz","ayaxbb","ayaxbz","ayaxyb","ayaxyz","ayzbbb","ayzbbz","ayzbyb","ayzbyz","ayzxbb","ayzxbz","ayzxyb","ayzxyz","xaabbb","xaabbz","xaabyb","xaabyz","xaaxbb","xaaxbz","xaaxyb","xaaxyz","xazbbb","xazbbz","xazbyb","xazbyz","xa
01:35:49 <lavalike> it looks like add-with-carry
01:36:00 <iqubic> The hell is that doing?
01:36:57 <bahamas> haskelllisp[m]: yes, I saw the article. what part of that class you don't understand?
01:36:58 <boxscape> It's taking the cartesian product, and then the cartesian product of the cartesian product
01:37:14 <boxscape> % sequence ["ab","xyz"]
01:37:14 <yahb> boxscape: ["ax","ay","az","bx","by","bz"]
01:37:17 <bahamas> haskelllisp[m]: it takes two types as arguments rather than just one
01:37:31 <bahamas> :i Functor
01:38:18 <iqubic> Alright, that's cool.
01:39:24 <haskelllisp[m]> bahamas:  Can you give me a `gvalidate` signature example, use `Person`
01:40:09 <haskelllisp[m]> `gvalidate :: Person' Maybe -> Maybe Person`  Like this？
01:42:32 <merijn> gvalidate doesn't operate on Person', it operates on "the Generic representation of Person"
01:46:08 <haskelllisp[m]> merijn: 
01:46:41 <haskelllisp[m]> https://downloads.haskell.org/~ghc/7.4.2/docs/html/users_guide/generic-programming.html Do I need to take a look at this knowledge first？
01:47:25 <jusss> https://hackage.haskell.org/package/network-3.1.1.1/docs/Network-Socket-ByteString.html#v:recv
01:47:32 <jusss> For TCP sockets, a zero length return value means the peer has closed its half side of the connection.
01:47:55 <jusss> the result type is  IO ByteString Data received
01:48:11 <jusss> how I can get the length?
01:48:52 <MarcelineVQ> result type is  IO ByteString so you can use https://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString.html#v:length
01:49:45 <jusss> MarcelineVQ: aha, 
01:50:11 <jusss> MarcelineVQ: I thought IO has a lenght 
01:50:28 <merijn> jusss: The "IO ByteString" is the action that wil read from that socket
01:51:16 <jusss> merijn: if the connection is disconnected, `recv' will get zero length, right?
01:51:51 <merijn> "It Depends" on, for example, when you consider a connection disconnected :)
01:54:59 <lavalike> is it possible to make a cabal target that will build and run a bunch of executables or is it out of the scope of cabal?
01:55:19 <lavalike> it's some sort of test in a way
01:55:31 <Solonarv> sounds vaguely out of scope to me
02:02:28 <MarcelineVQ> sounds like a good scope for make though
02:05:20 <jusss> if a connection is disconnected, how I can handle that https://pastebin.com/9sVD8RrN
02:05:44 <jusss> I use forkIO and a loop function in `main'
02:06:30 <jusss> if recv get zero lengh in the forkIO, how I can terminate another function recvMsg and call a new main
02:08:39 <lavalike> MarcelineVQ: reasonable
02:33:30 <bahamas> haskelllisp[m]: do you understand kinds?
02:33:46 <bahamas> for example, what is the kind of Maybe?
02:36:49 <maerwald> how do you recover the 'a' in 'newtype SpecM a r'
02:37:20 * hackage venzone 1.0.0.4 - ASCII platform-adventure game  https://hackage.haskell.org/package/venzone-1.0.0.4 (fffaaa)
02:42:15 <MarcelineVQ> What does recover mean? it's present on both sides of  the =
02:43:51 * hackage pandoc-crossref 0.3.6.0 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.3.6.0 (lierdakil)
02:55:21 * hackage typed-digits 0.1.0.0 - Digits, indexed by their base at the type level  https://hackage.haskell.org/package/typed-digits-0.1.0.0 (arran)
03:09:07 <enoq> do you always need to implement Traversable or do you get it for free for applicatives?
03:10:44 <mniip> I'm pretty sure traversables are stronger than applicatives
03:10:58 <mniip> traversables are some sort of approximation to polynomial/analytic functors
03:11:24 <mniip> Reader on an infinite domain is not traversable, but is applicative
03:15:34 <enoq> mniip ah, you are right
03:15:59 <enoq> thank you
03:16:36 <enoq> I suppose the infinite applicative stuff is useful when it's lazy
03:17:02 <enoq> so you could just select the first 5 results from a generated sequence and apply a function that takes 5 parameters into it
03:18:08 <mniip> it's very tricky categorically
03:18:39 <mniip> most applicatives don't work well in infinite <*> chains
03:19:20 * hackage simple-cmd 0.2.1 - Simple String-based process commands  https://hackage.haskell.org/package/simple-cmd-0.2.1 (JensPetersen)
03:20:27 <mniip> > head $ traverse (:[]) [1..]
03:20:33 <lambdabot>  mueval-core: Time limit exceeded
03:20:48 <enoq> hehe
03:20:53 <mniip> this is because it can't know whether some latter "multiplicand" won't be an empty list
03:21:55 <mniip> basically you need a lazy <*>
03:22:17 <mniip> lazy in the RHS for a right-infinite traverse, and vice versa
03:24:10 <mniip> @let data P a = P a a deriving Show; instance Functor P where fmap f ~(P x y) = P (f x) (f y); instance Applicative P where pure x = P x x; ~(P f g) <*> ~(P x y) = P (f x) (g y)
03:24:10 <lambdabot>  Parse failed: Parse error: instance
03:24:18 <mniip> @let data P a = P a a deriving Show
03:24:20 <lambdabot>  Defined.
03:24:24 <mniip> @let instance Functor P where fmap f ~(P x y) = P (f x) (f y); instance Applicative P where pure x = P x x; ~(P f g) <*> ~(P x y) = P (f x) (g y)
03:24:25 <lambdabot>  Parse failed: Parse error: instance
03:24:27 <mniip> dammit
03:24:46 <enoq> mniip tl;dr: the applicative instance must be implemented lazily
03:24:52 <mniip> but yeah note the ~
03:24:54 <mniip> wouldn't work otherwise
03:25:02 <mniip> > traverse (join P) [1..]
03:25:06 <lambdabot>  P [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
03:25:40 <[Leary]> You want `where { ... };`.
03:26:49 <mniip> you can't put instance declarations in where-clauses
03:26:52 <mniip> at least in GHC haskell
03:27:03 <mniip> oh
03:27:05 <mniip> I see what you mean
03:27:10 <mniip> instance ... where {...}
03:35:53 <boxscape> % f :: Typeable a => TypeRep; f = typeOf (undefined :: a)
03:35:53 <yahb> boxscape: ; <interactive>:52:33: error:; * Could not deduce (Typeable a0) arising from a use of `typeOf'; from the context: Typeable a; bound by the type signature for:; f :: forall k (a :: k). Typeable a => TypeRep; at <interactive>:52:1-26; The type variable `a0' is ambiguous; * In the expression: typeOf (undefined :: a); In an equation for `f': f = type
03:35:58 <boxscape> why doesn't this work?
03:36:33 <boxscape> oh
03:36:34 <boxscape> I need forall
03:37:06 <boxscape> % f :: forall (a :: Type) . Typeable a => TypeRep; f = typeOf (undefined :: a)
03:37:06 <yahb> boxscape: 
03:37:21 <boxscape> though for some reason it doesn't work without the kind annotation
03:37:26 <boxscape> % f :: forall a . Typeable a => TypeRep; f = typeOf (undefined :: a)
03:37:26 <yahb> boxscape: ; <interactive>:56:65: error:; * Expected a type, but `a' has kind `k1'; * In an expression type signature: a; In the first argument of `typeOf', namely `(undefined :: a)'; In the expression: typeOf (undefined :: a)
03:38:36 <boxscape> Appears to be because of PolyKinds
03:38:50 <boxscape> I didn't know it changes the default kind of type vars
03:39:42 <boxscape> % f @(IO Int)
03:39:42 <yahb> boxscape: IO Int
03:41:07 <boxscape> Maybe ghc should show a hint that you might want to use forall if you're trying to use a type variable from the signature with ScopedTypeVariables
03:42:01 <boxscape> how would one go about suggesting a change to an error message? Is a proposal necessary for something like that?
03:44:11 <__monty__> Seems like an MR would do.
03:45:07 <boxscape> I'll see if I can figure out how error messages work
03:45:21 <mniip> I suspect this might be really complicated
03:45:34 <boxscape> yeah it's definitely possible
03:59:26 <aplainzetakind> AoC day 11 is killing me.
03:59:30 <aplainzetakind> https://gitlab.com/aplainzetakind/aoc2019/blob/master/days/Advent19/Day11.hs
03:59:41 <aplainzetakind> This is probably correct, but absurdly slow.
04:00:54 <aplainzetakind> Taking 100 steps takes 0.13s, 100 steps takes 13s, I would expect this to be about n log n, and I don't know what's up.
04:01:06 <aplainzetakind> Can someone enlighten me?
04:01:50 <aplainzetakind> s/100 steps takes 13s/1000 steps takes 13s/
04:03:42 <jollygood2> can someone recommend me a html template/layout library? I'd prefer if it used external html file as a template
04:06:11 <tdammers> jollygood2: why do you want external HTML as your template?
04:06:55 <tdammers> jollygood2: do you actually need to edit templates at runtime? or are you fine with parsing HTML at compile time and turning it into templates that get compiled into your binary?
04:07:03 <jollygood2> tdammers, familiarity, I don't have to learn new way of writing HTML. also ability to update the page without recompiling the server
04:07:14 <tdammers> ah, OK
04:07:33 <tdammers> for the first part, I'd recommend blaze-html, with the html2blaze tool that converts HTML into Blaze templates
04:07:42 <tdammers> but it does require recompilation to make template changes visible
04:08:06 <tdammers> if you really must, I have written a Haskell implementation of most of Jinja2, called ginger
04:08:14 <tdammers> https://ginger.tobiasdammers.nl/
04:09:37 <tdammers> downsides are that it's not typesafe, not DOM-aware (i.e., it will happily produce horribly malformed HTML for you if you ask it to), and parses and interprets templates at runtime
04:09:57 <tdammers> you can of course still compile template source code into your application with, say, the file-embed package, if you want to do that
04:10:31 <hpc> shakespeare is pretty okay
04:10:38 <tdammers> there's also https://hackage.haskell.org/package/mustache, a somewhat more minimalist but otherwise similar template language
04:10:58 <Rembane> I'm very fond of Lucid even though it is not the requested solution in this case. 
04:11:12 <hpc> it uses TH but sometimes writing your html inline is more convenient
04:11:25 <tdammers> yeah, shakespeare / lucid also sits in the "compile-time" corner
04:11:41 <tdammers> I don't think they can consume templates without recompilation
04:12:15 <tdammers> one thing I dislike about Shakespeare is that 
04:12:23 <tdammers> "Shakespeare believes logic should stay out of templates and has its own minimal Haskell parser."
04:12:28 <Rembane> It shouldn't be a too terrible workflow if ghc is asked to optimize wrt fast recompilation
04:12:28 <tdammers> which I think is a mistake
04:12:41 <Rembane> That seems painful
04:12:48 <tdammers> Rembane: depends on how complex and interdependent your codebase is
04:13:13 <Rembane> tdammers: Good point 
04:13:21 <tdammers> it's not logic in general that should stay out of templates, just logic that isn't presentation logic
04:13:32 <Rembane> That's much harder to separate 
04:14:05 <tdammers> the point is, the decision which logic goes in the template and which doesn't is for the programmer to make, a template library shouldn't be overly opinionated about that
04:15:00 <Rembane> Yes, I agree wholeheartedly
04:15:21 <aplainzetakind> So running the input program with just a constant stream of 0's produces an output of length ~20000 pretty much instantaneously, so the intcode computer shouldn't be the bottleneck.
04:15:56 <jollygood2> thanks for listing all the options. I'll have to explore them a bit to see which one suits me the most
04:16:17 <tdammers> so IMO there are two sweet spots - one is an EDSL like Blaze, where you trivially get the full power of a mature general-purpose language for free; the other is a template language that implements most of such a general-purpose language itself, but optimizes its design for the template use case
04:16:53 <tdammers> jollygood2: one last option maybe worth mentioning is to move the templating to the client
04:17:31 <tdammers> jollygood2: not sure what kind of web application you're building, but if an SPA model works for it, then you can just send JSON over the wire and render it straight into a DOM on the client
04:17:51 <jollygood2> thinking about it, I could have page written mostly in html-like template that's loaded at runtime, and then insert small snippets generated by haskell code in something like blaze-html, rendered as a string, and inserted into the html template? does that make sense?
04:18:34 <tdammers> That sounds like it would make your host code needlessly complex
04:18:53 <tdammers> you'd essentially have one template engine (blaze) feeding into another (the "simple html template" part)
04:19:12 <jollygood2> tdammers I'm not a web programmer, I'm mostly learning as I go, and I have no clue how that would work (end JSON over the wire and render it straight into a DOM on the client). part of the reason why I want to update html dynamically, is because I don't know what I'm doing, so I'm changing things a lot =)
04:19:45 <tdammers> note, specifically, that naively replacing HTML source isn't valid, that is, something like Data.Text.replace "$var" value html is going to get you some nice XSS vulnerabilities down the road
04:20:14 <svipal> what's your fav tool for non static webdev ? 
04:20:42 <jollygood2> but since I'm already dealing with JSON, that also sounds like a viable option. can you give me some keywords to google, haskell package names
04:21:25 <tdammers> jollygood2: keywords: AJAX, SPA (Single-Page Application), VDOM (virtual DOM), REST/RESTful API
04:22:43 <jollygood2> and what haskell package would one use for that? I'm using scotty for sever side
04:22:48 <tdammers> scotty is fine
04:23:07 <tdammers> servant if you need to up your game and go all-out on type-safe APIs and such, but at this point I'd say don't
04:23:58 <tdammers> a straightforward-ish starting point would be to build a React app on the client, and have it talk to a scotty API on the backend
04:24:13 <amx> does the holy grail of template compilation with type checking at runtime exist?
04:24:13 <tdammers> (plus some stuff to serve the static parts of the client-side app, obviously)
04:24:19 <jollygood2> using what? plain javascript?
04:24:43 <tdammers> plain JS works, but you may want to look into frameworks like React or Vue for SPA
04:24:58 <tdammers> you could also try PureScript (a Haskell-like language designed for the browser)
04:25:20 <tdammers> or even compile Haskell to JS using GHCJS - last time I checked, getting that to work was quite a rough ride though
04:26:05 <tdammers> amx: you mean a template engine that compiles templates at runtime, and performs type checking while doing so?
04:26:49 <amx> yes
04:27:09 <amx> I would be fine with defining what can be passed into them statically
04:27:20 * hackage cobot-io 0.1.2.3 - Biological data file formats and IO  https://hackage.haskell.org/package/cobot-io-0.1.2.3 (zmactep)
04:27:30 <amx> just check that I'm not using anything that's not defined and that syntax is valid etc.
04:30:48 <cocreature> Does anyone know what the `hClose_help h2_` case in the implementation of `hDuplicateTo` is supposed to do? https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.IO.Handle.html#hDuplicateTo My understanding is that dup2 already closes the handle so I don’t see what this is supposed to do.
04:31:44 <yasar> `take 50 fibs1` hangs after a while: https://gist.github.com/yasar11732/94f3527f312ca07ccdd91b4965a3afa6
04:31:44 <cocreature> I have some code that does (roughly) "newStdout <- hDuplicate stdout; hDuplicateTo stderr stdout" sometimes I seems to be getting EBUSY from dup2. This seems to go away if I remove the call to hClose_help.
04:31:58 <yasar> shouldn't memoization make that code fast?
04:32:15 <heebo> im getting some typelevel funk from GHC. can anyone interpret?
04:32:18 <heebo> Expected kind ‘(GHC.Symbol, *)’, but ‘a’ has kind ‘*’
04:32:21 <heebo>     • In the first argument of ‘ElField’, namely ‘a’
04:32:25 <heebo>       In the type signature:
04:32:28 <heebo>         f :: (Monoid a) => Compose Maybe (ElField) a -> ElField a
04:32:40 <tdammers> amx: valid syntax is given by a successful parse. the rest is problematic
04:33:02 <tdammers> amx: from a programming/authoring ergonomics point of view, you kind of do want to make things optional
04:33:56 <tdammers> amx: you are often in a situation where a template can consume a dozen things, but any of them may be absent; you want concise syntax to deal with this
04:34:28 <tdammers> amx: also, it is often better to have the template show *something* - *anything* - when facing missing arguments, than to have it bail out entirely
04:35:19 <phadej> zinza have type-checking at runtime!
04:35:23 <tdammers> amx: and finally, the added value of this compared to just running the bloody thing and letting it fail when it gets to the broken part isn't *that* big, compared to the benefits of full static checking
04:35:27 <phadej> or compile-time, depends what you want
04:36:37 <tdammers> phadej: we should join forces, combine zinza with ginger
04:36:43 <phadej> the type-errors are not the best possible, but at least they tell where https://github.com/phadej/zinza/blob/master/fixtures/error-string.hs
04:36:57 <phadej> tdammers: I consider zinza feature complete :)
04:37:16 <tdammers> phadej: "Expression syntax has only two structures" - I don't ;)
04:37:30 <phadej> yes, it's on purpose very dumb
04:37:32 <boxscape> heebo ElField takes something of kind (Symbol, type), but a has to be of kind * because of the Monoid instance
04:37:56 <tdammers> "it's dumb on purpose" is a lame excuse for "I don't want to deal with the complexities of a complete expression language"
04:38:12 <tdammers> (and it's worse when people say "logic doesn't belong in templates")
04:38:13 <phadej> I don't want to deal with syntax :/
04:38:17 <tdammers> haha
04:38:24 <tdammers> well, ginger has that part covered
04:39:16 <phadej> and yes, there's a nice point where I don't need anything fancy like unification to do type-checking
04:39:27 <phadej> but that's "easy"; syntax is harder
04:39:49 <tdammers> try type-checking ginger some time :D
04:40:02 <tdammers> ginger allows even addition to be overloaded by the host
04:40:24 <tdammers> you can provide an addition function that fires missiles and always returns the string "canned beef"
04:41:07 <tdammers> so when you then run the template "1 + 1 equals {{ 1 + 1 }}", it'll launch some missiles and print "1 + 1 equals canned beef"
04:41:33 <aplainzetakind> What's an acceptable frequency to re-ask something?
04:41:42 <phadej> on this channel?
04:42:08 <tdammers> aplainzetakind: if this is about your AoC question, I believe people won't answer that here because spoilers
04:42:30 <tdammers> aplainzetakind: there's separate AOC channels though, I believe
04:43:10 <yasar> Can anyone spot the type error here? `fibs2 = [0,1] ++ map (uncurry +) zip (drop 1 fibs2) (drop 2 fibs2)`
04:43:53 <jollygood2> uncurry + is syntax error
04:44:06 <jollygood2> try uncurry (+)
04:44:29 <aplainzetakind> tdammers: But it's specifically about understanding Haskell performance.
04:44:48 <aplainzetakind> So I don't think the general aoc help will be useful.
04:44:53 <MarcelineVQ> map (uncurry +) zip is also a problem, you probably meant to write (zip (drop 1 fibs2) (drop 2 fibs2))
04:45:15 <boxscape> jollygood2 not a syntax error, it's a section
04:45:15 <tdammers> aplainzetakind: you already told me that day 11 involves the intcode VM again. that's a bit of a spoiler already.
04:45:41 <boxscape> jollygood2 though certainly not what was intended
04:45:42 <tdammers> aplainzetakind: generally speaking though, my experience with AOC is that when your code is slow, it's not Haskell's fault, but yours
04:45:43 <jollygood2> boxscape, it's a section only if uncurry is a variable, rather than a function
04:45:51 <tdammers> aplainzetakind: as in, you're using the wrong strategy to solve the problem
04:46:07 <MarcelineVQ> jollygood2: it's a section, but Num is really permissive so it's +ing uncurry
04:46:12 <boxscape> jollygood2 uncurry is a variable even if uncurry is a funciton
04:46:40 <boxscape> MarcelineVQ even if Num weren't permissive it would be a section, it just would throw a type error
04:46:43 <jollygood2> but point taken, it's a valid syntax. just not valid syntax for the intended purpose
04:46:52 <tdammers> aplainzetakind: if you're expecting log n - ish performance but getting n (or n² instead of n log n), then the obvious answer is to go look for accidental quadraticness
04:46:55 <aplainzetakind> I think my strategy should be about n log n, but it seems to be n^2, so it's my misunderstanding of either how the code runs or my algorithm (I'm not blaming Haskell).
04:47:16 <aplainzetakind> I'm expecting n log n and getting n ^ 2.
04:47:17 <MarcelineVQ> I didn't say it wasn't a section :>
04:47:19 <tdammers> jollygood2: it is valid syntax, period. the errors it produces aren't syntax errors.
04:47:33 <boxscape> MarcelineVQ hm, I suppose that's true
04:48:01 <tdammers> aplainzetakind: I haven't done day 11 yet, so I'm not gonna look, sorry :D
04:48:03 <jollygood2> tdammers valid haskell syntax, but invalid syntax for passing (+) to uncurry
04:48:41 <tdammers> jollygood2: no. valid haskell syntax, period. it just doesn't mean "apply uncurry to (+)", it means "apply (+) to uncurry"
04:49:10 <MarcelineVQ> yasar: so in the end there's two syntax issues causing type errors there
04:49:11 <tdammers> (or, better, "(+) applied to uncurry" vs. "uncurry applied to (+)")
04:49:13 <jollygood2> tdammers, it's the wrong syntax to use if goal is to pass (+) to uncurry
04:49:16 <aplainzetakind> tdammers: OK, thanks anyway.
04:49:28 <tdammers> jollygood2: it's not syntax, it's semantics
04:49:41 <jollygood2> it's all syntax
04:49:48 <MarcelineVQ> *two use-of-syntax errors
04:50:19 <tdammers> jollygood2: you're saying the wrong thing in correct language. It's like saying "Vanilla ice cream would like to buy me". The sentence is syntactically correct, the grammar checks out and all, but the meaning is nonsense, because I have "me" and "vanilla ice cream" reversed.
04:51:16 <tdammers> jollygood2: you could say that it is a "use of grammar error", but that's not very helpful, because grammar is not the problem here, the mistake is a semantic one - I am not for sale, and vanilla ice cream can't buy things, let alone people
04:52:19 <jollygood2> tdammers, there's one syntax for sections, and another for passing (+) to a function. he picked the wrong one
04:52:55 <tdammers> and I picked the wrong grammar to say that I want to buy some ice cream, by that logic
04:53:10 <tdammers> which is technically correct, but not helpful
04:53:17 <__monty__> aplainzetakind: Have you tried ##aoc-help and ##aoc-spoilers? Plenty of people there use haskell for AoC.
04:53:20 <e> soon: all errors are syntax errors
04:53:25 <yasar> hlint kindly suggested zipWith, which makes the code much easier to read :)
04:53:41 <tdammers> e: welcome to Lisp, where we simply redefine "syntax" to mean whatever we want
04:54:01 <jollygood2> I don't think the analogy holds. anyway, was his question answered? I lost track =)
04:54:09 <boxscape> As I understand it, "syntax" generally refers to the set of rules that say whether or not a string is part of a language, rather than a specific rule for a specific feature of a language
04:54:39 <boxscape> So there's only one haskell syntax, not one syntax for sections and another for applications and so on
04:54:45 <amx> tdammers: I need to print invoices and would like to tell the accountant that their template is broken, because it uses unknown fields, at the time they try to add it to the system as opposed to when they run it
04:55:08 <boxscape> though there are specific syntactic rules that govern these features
04:55:21 <e> boxscape: it's common to talk about the syntax for specific parts of a language grammar too
04:55:28 <MarcelineVQ> boxscape: subsections of syntax are also called syntax
04:55:33 <boxscape> hm, okay
04:55:47 <MarcelineVQ> no one liked the sound of synticies
04:55:47 <jollygood2> boxscape, I don't think that is true, at least not colloquially. for example we can talk about C switch syntax, or ternary operator syntax
04:56:17 <boxscape> fair
04:56:18 <tdammers> amx: why does the accountant build templates? D:
04:56:53 <amx> the mysteries of organisational architecture
04:57:03 <tdammers> clearly, the correct plural form of "syntax" is "syntaxen"
04:57:08 * tdammers strokes his massive beard
04:57:25 <MarcelineVQ> oxes, oxen, boxes, boxen
04:57:44 <yasar> How come laziness and memoization doesn't work for fibs1 while it works for fibs2 here? https://gist.github.com/yasar11732/94f3527f312ca07ccdd91b4965a3afa6
04:57:46 <tdammers> child, children
04:57:51 <tdammers> English is a mess
04:58:22 <tdammers> man/men, but can/cans
04:58:23 <yasar> `take fibs1 50` hangs, while `take fibs2 50` gives results immediately
04:58:39 <MarcelineVQ> tdammers: well that's only because ken was taken, ye ken?
04:58:52 <e> well, it all makes sense when taking the history into account
04:59:11 <tdammers> e: sure, blame our ancestors, not like they're gonna fight you over it
04:59:12 <boxscape> yasar can you try adding a type signature to fibs1?
04:59:16 <boxscape> like [Integer]
04:59:39 <e> i'm not blaming them, i'm saying it made sense :P
04:59:53 <e> jollygood2: i know what you mean about using the wrong syntax for the thing you meant, but it's definitely not a syntax error
05:00:06 <tdammers> I think it never made sense, people just started adopting new language conventions but didn't really bother changing the existing ones
05:00:13 <aplainzetakind> __monty__: I briefly stated my situation but nobody expessed interest to delve into the code in -help. I'll try -spoilers too.
05:00:27 <jollygood2> it's user error for picking the wrong syntax =)
05:00:51 <e> tdammers: likely no natural language as a whole ever made sense but the changes mostly made local sense at the time
05:01:09 <e> the perils of evolutionary design. and yet the result is somehow vastly more effective than anything humans have ever invented :)
05:01:10 <tdammers> e, jollygood2: I think what happened is that OP didn't have a good enough grasp of Haskell syntax, and thus accidentally wrote something that, while valid syntax, doesn't mean what they think it means
05:01:11 <yasar> boxscape, even doing so, fibs1 extremely slow after `take 30 fibs1` or so
05:02:36 <boxscape> yasar hm, fibs1 does get memoized for me
05:02:45 <boxscape> or do you mean
05:02:48 <tdammers> e: yeah. and English has had a particularly wild history in that regard. Vikings and Celts, then Anglo-Saxons and a sprinkling of Latin, then Normans, then they kicked the Normans out, then they came back disguised as French scientists, and then some Latin again
05:02:56 <boxscape> why is the first call of `take 30 fibs1` slow?
05:03:09 <boxscape> (I'm not asking that, I'm asking if that's the question)
05:04:52 <jollygood2> did you add signature for fibs1, as suggested?
05:04:59 <yasar> boxscape I was thinking both version would have comparable performance, but fibs1 is really slow
05:05:12 <boxscape> yasar that's because fibs isn't memoized
05:05:35 <yasar> How come?
05:05:55 <boxscape> there is no automatic memoization of functions, by default. There is a package that can help you with it.
05:06:09 <jollygood2> fibs is not a function, though
05:06:19 <boxscape> uh I meant fib, not fibs
05:06:23 <boxscape> fibs doesn't even exist
05:06:34 <yasar> Hmm, then how come fibs2 works fast?
05:07:02 <boxscape> yasar because it doesn't repeatedly call a function to generate previous values, it just uses the previous values in itself
05:07:16 <boxscape> and it's not a function, just a regular (non-function) value
05:07:24 <boxscape> so it doesn't have to worry about not being memoized
05:07:37 <jollygood2> and I meant fibs1. values are recalculated because inferred type is Num a => a. with a more specific type, they should only be calculated once
05:08:15 <boxscape> jollygood2 I thought that at first too, but that's not it. The file should have MonomorphismRestriction enabled by default, anyway
05:08:37 <jollygood2> actuually, that's probably wrong? fib has type
05:08:56 <jollygood2> yes, inferred type is fibs1 :: [Integer]
05:09:39 <jollygood2> I just tested the code, and fibs2 is several orders of magnitude faster. I'm now curious why as well
05:10:17 <boxscape> because you're calling fibs 2^n times with each list element
05:10:23 <boxscape> s/fibs/fib
05:10:32 <boxscape> which is a lot of calls
05:11:59 <jollygood2> why? shouldn't fib1 replace thunks in the list with calculated values?
05:12:47 <phanimahesh> nope. An identical thunk appearing multiple times, when forced, is evaluated multiple times.
05:12:58 <boxscape> there's no reason for it to do so. Functions aren't memoized by default, and there's no let bindings or anything that would cause sharing of calulated values
05:13:00 <phanimahesh> unless it was the exact same thunk placed in multiple places
05:13:21 <jollygood2> but fibs1 isn't a function, it is [Integer]
05:13:48 <boxscape> but you're calling fib
05:13:54 <boxscape> which is a function
05:14:06 <phanimahesh> fibs1 is using fib. every call to fib is fully evaluated with no sharing between calls
05:14:34 <phanimahesh> so time(n) = time(n-1) + time(n-2)
05:14:54 <phanimahesh> Time required to calculate just the nth element is a fibonacci number
05:15:01 <boxscape> fib n = fibs1 !! (fromIntegral $ n - 1) + fibs1 !! (fromIntegral $ n - 2)
05:15:05 <jollygood2> oh, of course. definition of fibs1 doesn't reference fibs1's  values
05:15:08 <phanimahesh> * is a fibonacci like sequence
05:15:09 <boxscape> if you replace the last fib line with this it does a lot better
05:16:16 <boxscape> fibs2 still does a lot better than that though
05:16:59 <boxscape> fibs1 takes a few seconds to calculate the 30000th number if you do that, fibs2 less than 1
05:17:35 <absence> does anyone know why the exception handler in warp takes Maybe Request? what does it mean when it's Nothing?
05:18:25 <yasar> can you time function call in ghci without showing result in console?
05:18:45 <tdammers> there isn't really such a thing as a function call in haskell
05:19:20 <tdammers> there's function application, but in most cases, applying a function won't do much other than build a thunk wrapping its body parametrized over the thunk that represents its argument
05:19:39 <tdammers> you can, however, use cost-centre profiling in GHC to figure out where your CPU time and allocations end up
05:20:02 <tdammers> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html
05:20:08 <boxscape> % :set +s
05:20:08 <yahb> boxscape: 
05:20:11 <boxscape> % Just 4
05:20:12 <yahb> boxscape: Just 4; (0.03 secs, 154,280 bytes)
05:20:22 <boxscape> ^ yasar this might be helpful
05:20:38 <phanimahesh> 154 kb to essentially echo back?
05:20:47 <boxscape> % ()
05:20:47 <yahb> boxscape: (); (0.02 secs, 151,056 bytes)
05:20:53 <boxscape> yup
05:21:27 <phanimahesh> eh, fine. impractical micro benchmarks are meaningless anyway
05:21:33 <jollygood2> you can force evaluation of that thunk, though, and then time that
05:22:24 <boxscape> though it might be misleading unless you use deepseq
05:22:28 <jollygood2> I wrote a couple of functions for that,   time :: NFData a => a -> IO a   and  timeIO :: NFData a => IO a -> IO a
05:22:36 <tdammers> I'd start with cost-centre profiling. That's the most useful general-purpose performance information you can get for arbitrary Haskell programs.
05:22:36 <jollygood2> if you want I can paste them
05:23:31 <tdammers> the nice thing about cost centres is that they travel with thunks, so you actually measure the total cost associated with the expression, even if it gets evaluated at a later point
05:23:36 <tdammers> which is usually what you want
05:30:42 <dminuoso> Is there a way to write `context` in terms of lift? https://gist.github.com/dminuoso/c7117a0e8ee55aac87a0a55d263475dc
05:31:35 <dminuoso> Im thinking not because I have `ReaderT e m a` appearing in both negative and positive positions in context
05:32:43 <yasar> Trying to implement a custom list type, but I fail on type signatures: https://gist.github.com/yasar11732/94f3527f312ca07ccdd91b4965a3afa6
05:33:05 <yasar> it stays there is no type constructor or class Stream
05:33:10 <boxscape> yasar data should be lowercase
05:43:22 <yasar> I have creatad a custom type Stream, which is an infinite list. I want to implement Show type class by showing only the first 20 elems with no luck.
05:43:24 <yasar> https://gist.github.com/yasar11732/94f3527f312ca07ccdd91b4965a3afa6
05:45:55 <boxscape> yasar (show x) and (show y) must both be of type String, since `show :: Show a => a -> String`. But you're treating them as though the type of one was a list of the type of the other, by doing (show x : show y).
05:46:35 <boxscape> yasar maybe you could instead use your streamToList function to implement show
05:49:34 <yasar> boxscape, aside from horrible formatting, that worked :)
05:49:49 <boxscape> good
05:54:09 <jollygood2> > printf "[%s]" . intercalate ", " . map show $ [1..5]
05:54:13 <lambdabot>  error:
05:54:13 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M475945674491...
05:54:13 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
05:54:25 <jollygood2> > printf "[%s]" . intercalate ", " . map show $ [1..5 :: Int]
05:54:27 <lambdabot>  error:
05:54:27 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M579126962883...
05:54:27 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
05:55:33 <jollygood2> works in my ghci. I can't read lambdabot's errors, I see weird characters. is it utf8?
05:55:54 <boxscape> > printf "[%s]" . intercalate ", " . map show $ [1..5 :: Int] :: String
05:55:56 <lambdabot>  "[1, 2, 3, 4, 5]"
05:56:20 <jollygood2> ah, right. ghci defaults to IO
05:56:22 <boxscape> the only non-ASCII char I see in lambdabots output is a bullet at the start of the message
05:56:51 <boxscape> oh and special single quotes I suppose
05:57:22 <jollygood2> https://pastebin.com/bWhmA8xk
05:57:52 <boxscape> yeah those are the bullets and single quotes. Not sure what's going on with the encoding.
05:58:09 <EvanR> you might not be interpreting IRC as utf8
05:58:51 <jollygood2> regular quotes aren't good enough for lambdabot? =)
05:59:20 <EvanR> it helps to have many kinds of quotes
05:59:30 <EvanR> if they work
05:59:51 <EvanR> > show (show '\'') -- or would you like something like this :P
05:59:54 <lambdabot>  "\"'\\\\''\""
06:00:21 <EvanR> > show (show "\"")
06:00:23 <lambdabot>  "\"\\\"\\\\\\\"\\\"\""
06:00:36 <jollygood2> heh
06:00:36 <boxscape> I just don't like the `text' style you sometimes get with ghc because it messes with markdown
06:01:12 <EvanR> `this' style seems quite contrived
06:01:37 <EvanR> not enough bikeshedding
06:03:38 <boxscape> huh it drops the quotes when the quoted identifier ends with a prime
06:03:40 <boxscape> % a :: b = 5
06:03:41 <yahb> boxscape: ; <interactive>:79:1: error:; * You cannot bind scoped type variable `b' in a pattern binding signature; * In the pattern: a :: b; In a pattern binding: a :: b = 5; (0.01 secs,)
06:03:44 <boxscape> % a :: b' = 5
06:03:44 <yahb> boxscape: ; <interactive>:80:1: error:; * You cannot bind scoped type variable b' in a pattern binding signature; * In the pattern: a :: b'; In a pattern binding: a :: b' = 5; (0.01 secs,)
06:05:43 <EvanR> % a :: b'b = 5
06:05:43 <yahb> EvanR: ; <interactive>:81:1: error:; * You cannot bind scoped type variable `b'b' in a pattern binding signature; * In the pattern: a :: b'b; In a pattern binding: a :: b'b = 5; (0.01 secs,)
06:06:01 <EvanR> that's insane
06:06:33 <EvanR> sorry that’s insane
06:06:46 <boxscape> I think from a readability perspective it's alright but it's certainly no consistent
06:08:48 <fendor> > iterate show "\""
06:08:53 <lambdabot>  ["\"","\"\\\"\"","\"\\\"\\\\\\\"\\\"\"","\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\...
06:09:08 <boxscape> EvanR fun fact, this behavior only exists with ASCII output, with unicode output it always uses quotes
06:09:31 <EvanR> > show (iterate show "\"")
06:09:34 <lambdabot>  "[\"\\\"\",\"\\\"\\\\\\\"\\\"\",\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\"\\\"\"...
06:09:46 <EvanR> ok
06:09:57 <EvanR> > iterate show (iterate show "\"")
06:09:59 <lambdabot>  error:
06:09:59 <lambdabot>      • Couldn't match type ‘[Char]’ with ‘Char’
06:09:59 <lambdabot>        Expected type: String
06:10:02 <EvanR> dammit
06:10:49 <boxscape> > iterate show memtpy
06:10:52 <jollygood2> > concat $ iterate show "\""
06:10:53 <lambdabot>  error:
06:10:53 <lambdabot>      • Variable not in scope: memtpy :: String
06:10:53 <lambdabot>      • Perhaps you meant one of these:
06:10:55 <lambdabot>  "\"\"\\\"\"\"\\\"\\\\\\\"\\\"\"\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\"\\\"\"\...
06:10:56 <boxscape> > iterate show mempty
06:10:58 <lambdabot>  ["","\"\"","\"\\\"\\\"\"","\"\\\"\\\\\\\"\\\\\\\"\\\"\"","\"\\\"\\\\\\\"\\\\...
06:11:06 <EvanR> > iterate show (show (iterate show "\""))
06:11:09 <lambdabot>  ["[\"\\\"\",\"\\\"\\\\\\\"\\\"\",\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\"\\\"\...
06:11:12 <EvanR> oh yes
06:11:23 <EvanR> now to iterate that
06:11:56 <EvanR> :t fix (iterate show . show) 
06:11:58 <lambdabot> [String]
06:12:13 <boxscape> > fix show
06:12:15 <EvanR> > show (fix (iterate show . show) "")
06:12:16 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
06:12:17 <lambdabot>  error:
06:12:17 <lambdabot>      • Couldn't match expected type ‘[Char] -> ()’
06:12:18 <lambdabot>                    with actual type ‘[String]’
06:12:44 <EvanR> > show (fix (iterate show . show))
06:12:48 <lambdabot>  "[\"[\\\"[\\\\\\\"[\\\\\\\\\\\\\\\"[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"[\\\\\\\...
06:12:51 <EvanR> oh yes
06:13:27 <boxscape> > repeat '\'
06:13:31 <lambdabot>  <hint>:1:11: error:
06:13:31 <lambdabot>      unexpected end-of-file in string/character literal at end of input
06:13:38 <boxscape> ah well
06:14:44 <EvanR> > concat (fix (iterate show . show))
06:14:47 <lambdabot>  "[\"[\\\"[\\\\\\\"[\\\\\\\\\\\\\\\"[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"[\\\\\\\...
06:15:36 <boxscape> map length . filter (not . any (== '"')) . group . show $ fix show
06:15:38 <boxscape> > map length . filter (not . any (== '"')) . group . show $ fix show
06:15:45 <lambdabot>  mueval-core: Time limit exceeded
06:15:48 <boxscape> lame
06:15:53 <boxscape> % map length . filter (not . any (== '"')) . group . show $ fix show
06:15:54 <boxscape> save me yahb
06:15:58 <yahb> boxscape: [1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,262143,524287,1048575,2097151[Timed out]
06:16:08 <EvanR> the boxscape sequence
06:16:18 <EvanR> or powers of 2 minus 1
06:16:21 <nil> 2^n-1
06:16:40 <nil> A000225 on OEIS
06:16:48 <boxscape> I was about to look it up
06:16:51 <EvanR> ok so fix show was too easy. Now we need to read back in the result to get the original value
06:17:27 <EvanR> iterate read (fix show)
06:18:23 <EvanR> > fix read :: String
06:18:28 <lambdabot>  "*Exception: <<loop>>
06:18:33 <EvanR> yes!
06:21:05 <boxscape> where is the Read instance for String defined? It can't be the [] instance, right?
06:21:19 <c_wraith> Why not?
06:21:21 <EvanR> makes sense
06:21:50 <EvanR> > read "\\" :: Char
06:21:50 <jollygood2> > read "['a','b','c']" :: String 
06:21:53 <lambdabot>  "abc"
06:21:55 <lambdabot>  *Exception: Prelude.read: no parse
06:21:57 <boxscape> > read "\"1,2,3\"" :: String
06:22:00 <lambdabot>  "1,2,3"
06:22:04 <c_wraith> https://hackage.haskell.org/package/base-4.12.0.0/docs/Text-Read.html#v:readList
06:22:12 <c_wraith> Same hack Show uses
06:22:22 <boxscape> ah, thansk
06:22:32 <EvanR> > read "\\\\" :: Char
06:22:35 <lambdabot>  *Exception: Prelude.read: no parse
06:22:51 <EvanR> ugottabekiddinme
06:23:00 <c_wraith> you need the single quotes. :P
06:23:19 <boxscape> > read "'\\'" :: Char
06:23:24 <lambdabot>  *Exception: Prelude.read: no parse
06:23:34 <argent0> > read "\\" :: Char
06:23:39 <lambdabot>  *Exception: Prelude.read: no parse
06:23:40 <EvanR> > read "'\\\\'" :: Char
06:23:40 <c_wraith> but you still need 4 slashes.
06:23:43 <lambdabot>  '\\'
06:23:50 <boxscape> > read "'\\\\'" :: Char
06:23:56 <lambdabot>  '\\'
06:23:57 <boxscape> ah, makes sense
06:24:04 <c_wraith> because you have to do the in-string escaping and the read escaping
06:24:13 <c_wraith> double escaping!
06:24:19 <c_wraith> (didn't get away the first time)
06:24:25 <boxscape> > show . read $ '\\'
06:24:27 <lambdabot>  error:
06:24:27 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
06:24:27 <lambdabot>        Expected type: String
06:24:28 <EvanR> it's escaping all the way down
06:24:46 <boxscape> > read . show $ '\\' :: Char
06:24:52 <lambdabot>  '\\'
06:50:13 <yasar> This is my response to exercise 5 of https://www.cis.upenn.edu/~cis194/spring13/hw/06-laziness.pdf
06:50:18 <yasar> https://gist.github.com/yasar11732/94f3527f312ca07ccdd91b4965a3afa6#file-hw6-hs-L59
06:50:42 <yasar> exercise hints that I can construct `ruler` by interleaving 2 streams
06:50:58 <yasar> I can see that one of the streams has to be [0,0,..]
06:51:08 <yasar> Can anyone give a hint about other stream?
06:51:42 <nil> think recursively
07:01:49 <yasar> nil, I couldn't :)
07:02:43 <nil> try writing down the second stream by itself (that is, the ruler stream without 0's) and see if you notice anything
07:04:06 <yasar> Tried that until 50, I get `[1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1]`
07:04:34 <yasar> There seems to be a cycle, but it keeps growing
07:06:11 <nil> can you see a similarity between that and the ruler itself?
07:06:12 <yasar> Every two element is 1, is that the thing I must notice?
07:06:25 <nil> there's more than that
07:06:34 <nil> but that's a good start
07:06:45 <yasar> is it ruler + 1?
07:06:49 <nil> yes!
07:07:02 <boxscape> > let a | a == fromInteger 0 == 1 in a
07:07:05 <lambdabot>  <hint>:1:33: error: parse error on input ‘in’
07:07:56 <boxscape> > let {a | a == fromInteger 0 = 1} in a
07:08:00 <lambdabot>  *Exception: <<loop>>
07:08:03 <boxscape> huh
07:08:25 <nil> now i wonder what that desugars to
07:08:40 <boxscape> I actually wanted to find out what `0 = 1` desugars to
07:08:43 <boxscape> as in 
07:08:50 <boxscape> > let {0 = 1} in 0
07:08:53 <lambdabot>  0
07:08:57 <boxscape> but my first guess was clearly wrong
07:09:03 <nil> o_o
07:09:28 <nil> i think it treats 0 as a constructor and tries to match 1 against it
07:09:42 <nil> but since toplevel patterns in let-bindings are lazy, it doesn't fail
07:09:45 <MarcelineVQ> kinda, numeric literals in patterns desugar into guards
07:09:55 <boxscape> it needs a Num and an Eq instance
07:10:00 <Athas> And n+k patterns desugar into baloney.
07:10:04 <boxscape> so it uses fromInteger and guards
07:10:17 <boxscape> er
07:10:19 <boxscape> fromInteger and ++
07:10:22 <boxscape> ah
07:10:25 <boxscape> fromInteger and ==
07:10:44 <yasar> nil, so I need something like `interleaveStreams ruler (streamMap succ ruler)`
07:10:51 <yasar> do I hardcode initial values
07:11:00 <merijn> Athas: Did Clemens contact you yet or do I need to poke him some more? :)
07:11:03 <boxscape> is there a way to make ghci detect loops as well as lambdabot?
07:11:08 <Athas> merijn: he did, all is well.
07:11:13 <nil> yasar: the first stream isn't "ruler"
07:11:38 <merijn> Athas: Cool, then I'll start badgering colleagues in our GPU SIG to start registering ;)
07:11:41 <geekosaur> note that you can't write what it really desugars into since the integer is in internal format. (unless you import some internals)
07:12:02 <geekosaur> boxscape, only if you had a way to reset all expressions on every prompt like lambdabot does
07:12:37 <geekosaur> ghci keeps state, so there's more that can go wrong
07:12:42 <boxscape> I see
07:13:01 <nil> yasar: you had it right before: <yasar> I can see that one of the streams has to be [0,0,..] 
07:14:27 <dminuoso> merijn: I think it was you who introduced me to prettyprinter. It's making its way to my top favourite libraries.
07:14:37 <dminuoso> Right side along optparse-applicative and unliftio :)
07:15:27 <c_wraith> merijn: my friend finally got around to solving day 3.  Turned out he went to the same algorithm as I did, but didn't know about set data types.  So he ended up with something that took 20 seconds because it was O(n^2).  But it was correct and used the same idea.
07:15:50 <dminuoso> c_wraith: AoC spoiler channel? :<
07:16:24 <boxscape> > let {_ = case 1 of a | a == fromInteger 0 -> a} in 0
07:16:28 <lambdabot>  0
07:16:33 <boxscape> this might be close, I guess
07:16:56 <dminuoso> By the way, is there a way to pattern match using a field accessor?
07:17:02 <merijn> dminuoso: :)
07:17:07 <dminuoso> % data F = F { someF = Int }
07:17:08 <yahb> dminuoso: ; <interactive>:1:20: error:; parse error on input `='; Perhaps you need a 'let' in a 'do' block?; e.g. 'let x = 5' instead of 'x = 5'
07:17:18 <dminuoso> % data F = F { someF :: Int }
07:17:18 <yahb> dminuoso: 
07:17:31 <dminuoso> % f F{someF = 5} = True; f _  False
07:17:31 <yahb> dminuoso: ; <interactive>:3:24: error:; Parse error: module header, import declaration; or top-level declaration expected.
07:17:34 <boxscape> % Just {} = Just 45
07:17:34 <yahb> boxscape: 
07:18:50 <boxscape> dminuoso that does work but not if you write both on one line for some reason
07:18:50 <Ariakenom> my aoc day 7 a & b are quite similar thanks to lazy evaluation
07:18:52 <merijn> c_wraith: My girlfriend just finished up 5 and the first half of 7, which means she's now ahead of me >.>
07:18:52 <Ariakenom> https://github.com/Ariakenom/adventofcode/tree/master/2019/7
07:19:21 <dminuoso> boxscape: It gives a *parser* error in fact.
07:19:24 <geekosaur> dminuoso dropped a = also
07:19:31 <yasar> nil, my ruler causes infinite loop I guess: https://gist.github.com/yasar11732/94f3527f312ca07ccdd91b4965a3afa6
07:19:32 <dminuoso> Oh?
07:19:35 <geekosaur> `f _ False`
07:19:39 <merijn> dminuoso: Yes, there is
07:19:40 <boxscape> a yeah that would be why
07:19:46 <dminuoso> % f F{someF = 5} = True; f _ = False
07:19:47 <yahb> dminuoso: 
07:19:58 <dminuoso> geekosaur: Argh. There's some dust in my keyboard I really need to get rid of. :(
07:20:03 <boxscape> % f (F 6)
07:20:03 <yahb> boxscape: False
07:20:04 <merijn> You can even mix explicit matches + RecordWildCards
07:20:05 <boxscape> % f (F 5)
07:20:05 <yahb> boxscape: True
07:20:09 <Ariakenom> merijn: is she doing these in haskell or that other lang she was trying before?
07:20:51 <merijn> dminuoso: True horror: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/ingest-src/Jobs.hs#L115-L120
07:20:57 <merijn> Ariakenom: In Haskell
07:22:04 <dminuoso> boxscape: I just realized where my mistake was. I tried using `f t{someF = 5} = ...` essentially
07:22:23 <dminuoso> (that is, I didnt specify the data constructor)
07:22:23 <Ariakenom> merijn: great, like I said above, 7b is fun in haskell
07:22:57 <dminuoso> merijn: lens/optics? ;)
07:23:10 <Zemyla> I figured out a way to zip or align Traversals. https://pastebin.com/L0rhVxL1
07:23:18 <merijn> dminuoso: Mine don't even use lens :p
07:23:28 <merijn> dminuoso: Oh, you meant for that record?
07:23:41 <merijn> dminuoso: I don't think lens would improve that, tbh
07:23:51 <Zemyla> It only works with listlikes, though, not maps or whatever.
07:23:53 <dminuoso> merijn: well you seem to use it just to bind variables to deeply nested things.
07:24:07 <merijn> dminuoso: "deeply nested" -> one level
07:24:49 <merijn> dminuoso: If you can show me a lens example that's simpler than the current version, I'm curious, but skeptical :p
07:33:43 <nil> yasar: you need lazy pattern matches
07:34:12 <nil> specifically, your interleaveStreams function needs to be lazy in its second argument (so  ~(Cons bfirst brest)  )
07:34:32 <nil> i'm not sure if that's the intended way to do it, though
07:34:45 <yasar> nil, I made a question on SO, if you are interested to answer it there : https://stackoverflow.com/q/59307984/886669
07:35:09 <nil> Willem Van Onsem already has
07:36:29 <nil> an alternative solution might be  interleaveStreams (Cons afirst arest) b = Cons afirst (interleaveStreams b arest)
07:37:11 <Zemyla> Oh, also, is there a type which is Ix and Bounded, but where exists x. inRange (minBound, maxBound) x == False?
07:38:21 <Zemyla> Because that seems to encompass the entire type, and as long as rangeSize (minBound, maxBound) < (maxBound :: Int), you should be able to traverse a function from that type.
07:39:01 <yasar> nil, your alternative solution works, but I fail to understand how is it executed differently from my initial version
07:40:27 <geekosaur> you have a pattern that is strict, but the alternative has "b" which is lazy because it doesn't try to deconstruct a Cons node?
07:41:05 <yasar> Ahh, so a pattern matching forces it to evaluate?
07:41:17 <geekosaur> yes
07:41:25 <geekosaur> it's the primary mechanism to force evaluation, in fact
07:41:36 <yasar> nice to know :)
07:42:38 <c_wraith> In some ways, it's the *only* mechanism to force evaluation, other than IO stuff deep inside the runtime system
07:43:34 <c_wraith> Even seq doesn't do anything without a forcing mechanism applied to its output
07:44:18 <geekosaur> yeh. and thisisn't just "nice to know", it'll be essential to understand why things work as they do in Haskell
07:45:11 <nil> c_wraith: so what is it seq does exactly?
07:45:13 <maerwald> c_wraith: hmmmm?
07:45:59 <geekosaur> ensures that when something forces the expression it produces, it also forces the other expression you give it. something still needs to do that first forcing, though
07:46:00 <c_wraith> nil: seq links the evaluation of two expressions.  when you evaluate (seq a b), you know that you will have evaluated both a and b.
07:46:14 <yasar> to interleave regular list, should I use the interleave from `Control.Monad.Trans.Iter` ?
07:46:15 <nil> ok
07:47:15 <nil> yasar: that seems to be a specific function for the IterT monad transformer
07:47:51 <nil> i'd just define interleave myself as above
07:48:03 <nil> interleave (x:xs) ys = x:interleave ys xs
07:48:07 <nil> + base case
07:48:51 <nil> (not that you often actually need to interleave lists; zip is more often useful)
07:49:05 <yasar> is `<|>` reserved for anything? I am going to use it for my interleave 
07:49:13 <nil> :t (<|>)
07:49:14 <lambdabot> Alternative f => f a -> f a -> f a
07:49:16 <geekosaur> Alternative
07:49:29 <yasar> :t <||>
07:49:32 <lambdabot> error: parse error on input ‘<||>’
07:49:40 <nil> parentheses
07:49:45 <zincy_> Does flatmap rely on a functorial or monadic constraint?
07:49:50 <yasar> :t (<||>)
07:49:52 <lambdabot> error:
07:49:52 <lambdabot>     • Variable not in scope: <||>
07:49:52 <lambdabot>     • Perhaps you meant one of these:
07:49:52 <geekosaur> that one should be available unless you're working with xmonad :)
07:50:02 <c_wraith> :t (=<<)
07:50:05 <lambdabot> Monad m => (a -> m b) -> m a -> m b
07:50:18 <c_wraith> zincy_: ^ that operation is roughtly what scala calls flatmap
07:51:34 <zincy_> c_wraith: A thanks
07:52:23 <c_wraith> I wish I could spell.  Too early. :)
08:04:08 <jumper149> Hi, is it possible to sort of cache data in a conduit pipeline? Specifically I want to reorder the data within a specific time limit!
08:05:39 <chris__> Hopefully a quick question.. How can I get a `Int` from a `Scientific` (aeson's Number type)? I'm looking through all the typeclasses trying to make sense of it.
08:07:11 <heatsink> use one of the rounding functions
08:07:28 <heatsink> round, floor, ceiling
08:07:48 <solonarv> (those all belong to RealFrac)
08:08:35 <solonarv> you can also use floatingOrInteger, or toBoundedInteger
08:08:56 <solonarv> those will let you report an error if the number was not actually an integer
08:11:12 <chris__> heatsink: Thanks, seems to do the job. Though it does seem a bit clucky - I'm expecting an integer for a database record ID. 
08:12:04 <solonarv> chris__: the perils of using JSON as an interchange format!
08:13:13 <solonarv> but actually, you do not need to pattern-match on the Value directly - you can write a parser instead
08:13:51 <solonarv> all the integer types already have a FromJSON instance, so you don't need to do any manual conversion
08:16:02 <chris__> solonarv: oh right. That makes a lot of sense, would probably clean a lot of things up. Thanks!
08:18:08 <fendor> In advent of code, task 7 part 2, we tried to "wire" the input and output of the different intcode programs, hoping laziness would correctly stop and continue evaluation as needed, but ghc terminates the exection with a <<loop>> message
08:18:44 <fendor> should it be possible?
08:20:19 <solonarv> yes, it's possible - jle` did it that way for example
08:20:48 <fendor> so, not enough laziness potentially?
08:21:50 <fendor> can I debug that <<loop>> message somehow?
08:22:07 <solonarv> you can try stepping through the execution using ghci's debugger
08:22:21 <solonarv> or you can sprinkle some Debug.Trace functions over your code
08:22:53 <boxscape> you'd think if ghc can detect a loop there ought to be an easy way to have it tell you where it encountered it
08:23:34 <fendor> no one told me that I actually have to use debuggers :/
08:23:37 <solonarv> there is, actually
08:23:38 <c_wraith> It's not like error, something that comes from the source
08:23:53 <c_wraith> so you'd need to have the runtime call stack enabled
08:24:09 <solonarv> compile with -prof (if using cabal: pass --enable-profiling), and run with +RTS -xc
08:24:29 <boxscape> ah, nice
08:24:37 <solonarv> -prof makes sure there is information to build a call stack, and -xc causes a stack trace to be printed on exception
08:25:10 <boxscape> you don't need -fprof-auto or anything like that?
08:25:21 <solonarv> idk
08:25:28 <boxscape> fair enough
08:25:40 <solonarv> I compile via cabal and I think that passes -fprof-auto by default (if profiling is enabled)
08:26:00 <fendor> nice, will try the profilign as well, thanks!
08:27:24 <solonarv> it's also possible that you forgot to add some initial condition
08:28:04 <solonarv> like, for example, if you tried to write the classic: fibs = 0:1: zipWith (+) fibs (tail fibs)
08:28:11 <solonarv> but you forgot the 0: at the start
08:30:21 <merijn> boxscape: It's not obvious that it could detect where, though
08:30:34 <merijn> boxscape: Because that'd require the ability to attribute thunks back to source
08:35:55 <boxscape> hmm I guess
08:47:07 <fendor> thank you everyone, with the exceptions, we found the mistake and now it is working :)
09:00:10 <furaidoo> hi
09:00:38 <furaidoo> when i write a literal 1, why does it have type a typeclass, is it even possible ?
09:00:50 * hackage lambda-options 1.1.0.0 - Declarative command-line parser with type-driven pattern matching.  https://hackage.haskell.org/package/lambda-options-1.1.0.0 (ThomasEding)
09:03:17 <dsal> furaidoo: what do you mean?
09:03:25 <dsal> :t 1
09:03:27 <lambdabot> Num p => p
09:03:58 <dsal> Out of context, all we know about 1 is that it's a number.
09:04:20 <Ailrun[m]> It has a type "with a constraint", not a typeclasss itself.
09:04:26 <furaidoo> in the book learnyouahaskell, it's said that data Int = -2147483648 | -2147483647 | ... | -1 | 0 | 1 | 2 | ... | 2147483647  
09:04:46 <furaidoo> isn't 1 a value constructor for Int?
09:04:54 <furaidoo> how does it become Num
09:05:47 <Taneb> furaidoo: number types are a little special. Learn You A Haskell was simplifying things
09:06:04 <furaidoo> can you elaborate more
09:06:15 <furaidoo> I'm having a very hard time understanding
09:06:20 <Taneb> The literal "1" is read by Haskell as fromInteger (1 :: Integer)
09:06:27 <Taneb> Or a value equivalent to that
09:06:29 <dminuoso> furaidoo: Number literals are builtin data constructors.
09:06:36 <Taneb> :t fromInteger (1 :: Integer)
09:06:38 <lambdabot> Num a => a
09:06:42 <dminuoso> furaidoo: That is, you cannot implement them with Haskell itself.
09:06:43 <Taneb> :t 1
09:06:45 <lambdabot> Num p => p
09:07:01 <Taneb> > (1 :: Int, 1 :: Float, 1 :: Rational)
09:07:04 <lambdabot>  (1,1.0,1 % 1)
09:08:29 <furaidoo> ugh it seems so strange ...
09:08:38 <furaidoo> how does one read 1.0 then ?
09:08:56 <Taneb> That becomes I think fromRational (1.0 :: Rational)
09:09:05 <Taneb> :t fromRational (1.0 :: Rational)
09:09:07 <lambdabot> Fractional a => a
09:09:10 <Taneb> :t 1.0
09:09:13 <lambdabot> Fractional p => p
09:09:28 <Taneb> > (1.0 :: Float, 1.0 :: Rational)
09:09:30 <lambdabot>  (1.0,1 % 1)
09:09:37 <Taneb> It's a different rule
09:10:24 <furaidoo> it's unintuitive and the conversion is hidden from the user
09:10:28 <furaidoo> what's the reason for that?
09:11:12 <dminuoso> furaidoo: It's to make numbers pleasant to use.
09:11:17 <Taneb> To make Haskell easier to use in a principled way
09:12:12 <dminuoso> furaidoo: There's a great variety of numeric types, and it's reasonable to just want to write `f + 1` regardless of whether `f` is of type Int, Integer, Int64, Int32, Int16, Int8, Float, Word, Word8, ... etc
09:12:52 <dminuoso> Otherwise you have guaranteed clutter of `fromInteger`
09:14:15 <phadej> note that compiler warns when you do silly things like (1000 :: Word8)
09:14:54 <furaidoo> sorry, can you explain more how can a typeclass become type ?
09:15:09 <furaidoo> like what happens in :t 1
09:15:12 <dminuoso> furaidoo: It's the type variable that's the specialty, not the typeclass.
09:15:31 <dminuoso> furaidoo: A type variable (things starting with lower case letters in the type world) is something that the user/consumer/caller can decide.
09:15:49 <dminuoso> If you see a type signature: `f :: a -> a` it means the user of that thing `f` gets to decide what `a` is going to be.
09:16:02 <Taneb> furaidoo: it's saying it's some type, a, that satisfies the constraint "Num a", that is, there is an instance of a for the Num typeclass
09:16:40 <dminuoso> furaidoo: A typeclass serves as a constraint. So if you had `g :: Num a => a -> a` the user of `g` could pick any type for a, as long as there exists an `instance Num a` for whatever choice he is making.
09:17:15 <dminuoso> % :t 1
09:17:15 <yahb> dminuoso: Num p => p
09:17:31 <furaidoo> can something have a type a only ?
09:17:34 <dminuoso> furaidoo: In this case it means, the user/consumer of `1` gets to decide what `p` is going to be. You can pick any type, as long as there exists an instance Num for that type.
09:17:52 <dminuoso> For example, you can decide its going to be int:
09:17:55 <dminuoso> % :t (1 :: Int)
09:17:55 <yahb> dminuoso: Int
09:18:01 <dminuoso> You can also try something else:
09:18:11 <dminuoso> % :t (1 :: Char)
09:18:12 <yahb> dminuoso: ; <interactive>:1:2: error:; * No instance for (Num Char) arising from the literal `1'; * In the expression: (1 :: Char)
09:19:00 <dminuoso> Perhaps from this perspective the error message makes sense. You chose `Char` for that type variable, but there is no instance Num Car - that's why GHC complains.
09:19:10 <dminuoso> furaidoo: ^- does this make any sense?
09:21:20 <furaidoo> is the literal 1 a function? 
09:21:47 <dminuoso> furaidoo: No. It's just a value
09:22:15 <dminuoso> furaidoo: Though perhaps, in some abstract sense, you could think of it as a function that says "Give me a type, and you'll have a value".
09:22:27 <dminuoso> (Incidentally that's exactly how GHC implements polymorphic values, but that's another story)
09:25:47 <tdammers> dminuoso: except when it can specialize, but that's *yet another* story
09:26:24 <dminuoso> tdammers: How are those implemented?
09:27:23 <furaidoo81> so how does one define the data Int / Float ? 
09:27:32 <dminuoso> furaidoo81: You dont.
09:28:02 <dminuoso> furaidoo81: In principle you could implement Integer from hand though.
09:29:20 <dsal> You can make your own number types and the compiler will helpfully call your constructors as needed.
09:29:49 <dsal> It's only really confusing when you type 1 into GHCI and expect a concrete type.
09:31:48 <dsal> Someone last year pointed out `select :: [a] -> [(a,[a])]` which just kind of looked weird to me at the time, but I remembered it and then needed it for AoC.  I needed it for AoC again this year.  Super helpful.
09:44:16 <sm[m]> dsal, got a link for that ? There are a lot in hoogle
09:59:56 <boxscape> is there a concise way to get the "powerlist" of a list (as opposed to the powerset)?
09:59:59 <boxscape> the best I have so far is this:
10:00:02 <boxscape> % let xs = ['a'..'e'] in zipWith (catMaybes .: zipWith ($)) (sequence (replicate (length xs) [const Nothing, Just])) (repeat xs)
10:00:02 <yahb> boxscape: ["","e","d","de","c","ce","cd","cde","b","be","bd","bde","bc","bce","bcd","bcde","a","ae","ad","ade","ac","ace","acd","acde","ab","abe","abd","abde","abc","abce","abcd","abcde"]
10:00:26 <c_wraith> sm[m]: I don't think it's on hoogle. it's a two-liner.
10:01:22 <c_wraith> boxscape: how does the output differ from a powerset?
10:01:33 <boxscape> c_wraith it's [a], not Set a
10:01:53 <boxscape> I just wrote "as opposed to" to indicate what I mean with the word
10:02:00 <MarcelineVQ> c_wraith, sm[m]:  ye  select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
10:02:11 <c_wraith> > filterM (const [False, True]) [1..4]
10:02:13 <lambdabot>  [[],[4],[3],[3,4],[2],[2,4],[2,3],[2,3,4],[1],[1,4],[1,3],[1,3,4],[1,2],[1,2...
10:02:16 <boxscape> ah, nice
10:02:39 <boxscape> thanks
10:05:38 <c_wraith> just wanted to be sure you didn't want like permutations of each element of the power set, or something.
10:14:06 <sm[m]> MarcelineVQ: thx
10:51:47 <pounce> if i have Maybe and I have 2 computations a,b how do i take `a` if it is Just and `b` if a is `Nothing`. is that just Alterative?
10:52:45 <lavalike> > Just "think so" <|> Nothing
10:52:49 <lambdabot>  Just "think so"
10:54:17 <pounce> ah thats what i thought but i couldn't figure out what <|> in the docs
10:56:13 <pounce> dumb pounce confuses associativity with commutativity
10:56:59 <dminuoso> pounce: associativity is that which is you find almost everywhere.
10:57:03 <dminuoso> commutativity is that which is rare.
10:57:06 <dminuoso> :p
10:57:12 <koz_> So much this.
11:02:05 <pounce> (+ 1 n) => could not match type `n` with a -> a 
11:02:09 <pounce> ah, been writing too much lisp
11:06:20 * hackage ghcide 0.0.5 - The core of an IDE  https://hackage.haskell.org/package/ghcide-0.0.5 (cocreature)
11:08:26 <nil> ((+) 1 n)
11:09:07 <koz_> > succ n
11:09:09 <lambdabot>  succ n
11:09:18 <koz_> :t succ
11:09:21 <lambdabot> Enum a => a -> a
11:11:25 <sm[m]> cocreature: yay! thanks for the new release
11:12:35 <sm[m]> with "Initial support for TemplateHaskell" https://github.com/digital-asset/ghcide/pull/222
11:16:38 <pounce> hmm, this is not going as well as i would have hoped
11:17:43 <pounce> trying to write a function which finds the relative distance between two elements in an array, i.e. takes [-1,1,2,3] and [0,0,1] and returns 3 because the first common element is 1 with an index of 1 and 2
11:21:30 <pounce> tried writing this https://gist.github.com/4e554c4c/4bb84653e9503d21f25ea9b0736e8b08 bc im like "if the index is less in the first array try recuring on it and then try the second array, but then it often just goes too far down and returns a less common element. do i really have to use a min?
11:23:32 <pounce> not quite sure how to take the min between 2 Ord a => Maybe a either
11:25:41 <amalloy> seems like an underspecified problem. how do you intend to decide what is the first common element?
11:26:45 <pounce> the common element with the least total distance in both arrays
11:33:18 <amalloy> total distance from what? each other? the beginning of the list?
11:33:55 <tom__> How do I execute a multi row query using postgres-simple such as the following https://pastebin.com/3G6a2enJ
11:35:43 <tom__> The docs state that I can only have one (?,?,..) and there can be no other ? parameters anywhere in my query
11:44:18 <pounce> is there any better way to make a min on an alternative other than amin a b = (liftA2 min) a b <|> a <|> b
11:46:31 <MarcelineVQ> what does that do?
11:47:24 <MarcelineVQ> oh I think I see, I should think before talking
11:49:32 <MarcelineVQ> in terms of keystrokes savings there's  asum [liftA2 min a b, a, b]
11:50:11 <MarcelineVQ> but one key isn't so much
11:50:34 <MarcelineVQ> haha, actually mine's longer if you take out your redundant parens 
11:50:36 <pounce> hm
11:56:38 <MarcelineVQ> I'm imagining a cabal of haskellers skittering in the darkness currently trying to merge Alt and Ap and functions like op/ala to be clever about your problem.
11:57:41 <amalloy> i thought i remembered some Minimum newtype wrapper like the First/Last wrappers for Maybe, but i can't seem to find it. would such a wrapper even make sense? what class would it be in? 
11:58:27 <phadej> min <$> a <*> b <|> a <|> b isn't really that bad imho
11:58:52 <MarcelineVQ> amalloy: Data.Semigroup
11:59:28 <amalloy> oh, it is Min. i was looking for Minimum and missed it
11:59:59 <pounce> hehehe
12:00:19 <devalot> When using DataKinds, is there a way to write a type level function (or term level) that can take a promoted data constructor (now a type constructor) and use it as a data constructor again?
12:01:50 <pounce> hmm guess ill do that phadej
12:02:43 <devalot> Basically, given `data T = A | B` I want to write `(a :: T) -> T`
12:02:57 <c_wraith> devalot: you mean reflect from the type level to the value level? that's what the singletons library is about. it's... not pleasant, but it's possible.
12:03:44 <devalot> c_wraith: okay.  I guess I'll start there.  Thanks.
12:04:06 <phadej> I'd recommend to read the paper
12:04:12 <phadej> which explains what happens there
12:04:20 <koz_> Also jle`'s 'Introduction to Singletons'.
12:07:20 <tom__> So this is where I am on trying to get the postgres-simple query to work
12:07:20 <tom__> https://pastebin.com/f2C0jTFj
12:07:23 <jared-w> matter of fact, probably read jle's article and _then_ the paper
12:07:35 <koz_> I'd echo jared-w, at least from personal experience.
12:07:50 <tom__> Im not sure if I don't understand SQL or haskell well enough :/
12:07:52 <koz_> (plus, jle` is a very engaging author, and there are examples and exercises and stuff)
12:08:12 <devalot> Thank you everyone.  I'll do that.
12:08:16 <jared-w> Definitely. He's one of the best Haskell writers and an excellent technical writer in general; it's great to read his stuff :)
12:08:50 <koz_> Glad I'm not the only one who thinks so. :P
12:09:03 <tom__> Has anyone else tried to use postgres-simple's `executeMany` where parameters span multiple lines in the query?
12:10:45 <pounce> hmm is there any way i can make my code more parallel? like, have it try the different alternatives at once
12:11:26 <koz_> pounce: If they'll take a while to evaluate, monad-par may help.
12:12:16 <wikiemol> Is it possible to implement the primitive recursion operator using foldr / foldl? If so how? I feel like there is a way, but for some reason I can't wrap my head around it. https://en.wikipedia.org/wiki/%CE%9C-recursive_function#Definition
12:14:22 <svipal> pounce, take a look at Control.Concurrent.Async
12:14:40 <pounce> hmm nah i think my code's just bad it probably shouldn't be taking up gigabytes of memory
12:14:48 <jared-w> wikiemol: theoretically, every primitive recursive function on lists can be implemented as a fold
12:15:33 <wikiemol> jared-w But can the primitive recursion operator be implemented with fold and perhaps some other high level functions? 
12:16:52 <jared-w> ""the" primitive recursion operator", are you talking about the mu operator?
12:17:37 <wikiemol> jared-w no. the rho operator p
12:17:51 <jared-w> Gotcha. Didn't see that on the first read through of the page; I'm following you now :)
12:17:53 <koz_> wikiemol: You may find "Getting a Fix from the Right Fold" from here informative: https://wiki.haskell.org/wikiupload/1/14/TMR-Issue6.pdf
12:18:13 <koz_> (in general, that issue of TMR is an incredible goldmine of cool things)
12:19:08 <MarcelineVQ> it really is
12:19:12 <MarcelineVQ> all TMR
12:19:18 <koz_> That one I think is especially amazing.
12:19:30 <wikiemol> jared-w Haha yeah I have been trying a bunch of things. Whenever I feel like I've got it, I hit an infinite type error
12:19:41 <koz_> wikiemol: Yeah, _definitely_ read that thing I linked.
12:19:41 <wikiemol> koz_ That looks like a very informative read
12:19:47 <nil> i find it useful to add that you're not actually creating recursion out of simply foldr. the recursion comes from the fact that the list itself is infinite (and was defined recursively, using repeat)
12:20:05 <koz_> wikiemol: It should answer your questions, or at least give you enough to continue.
12:20:10 <wikiemol> What does TMR stand for?
12:20:16 <koz_> The Monad Reader.
12:20:20 <wikiemol> Ooh gotcha
12:20:23 <nil> foldr lets you transform the "list recursion" into a "function call recursion", which i think is the point of the article
12:20:45 <koz_> ReaderT Article Maybe Knowledge :P
12:21:30 <wikiemol> nil That seems like exactly the type of connection I am looking for to understand fold
12:21:32 <svipal> that feel when
12:21:44 <svipal> you realize you overengineered something that was actually quite simple
12:21:53 <koz_> svipal: Welcome to 'me, almost every day'.
12:22:20 <nil> wikiemol: see https://wiki.haskell.org/Fold#List_folds_as_structural_transformations
12:23:00 <nil> if the data structure is infinite, and you ignore its values, you get infinite application, i.e. fix
12:23:57 <nil> (note that  repeat = fix . (:)  )
12:25:54 <wikiemol> woah! nil very illuminating 
13:40:29 <boxscape> is it ill-advised to derive Show instances for types for which you don't really need it in production code? I've seen haskell code where "deriving Show" was behind #ifdefs, to only be enabled for debugging
13:43:15 <maralorn> boxscape: Might it influence compilation time?
13:43:55 <boxscape> hm, I suppose it would. Doesn't seem like it would be very significant, but I don't know much about ghc compilation times
13:44:05 <maralorn> Well in a strict sense it decreases type safety to implement more type classes.^^
13:44:44 <boxscape> that's true
13:45:03 <geekosaur> it depends on what else you're doing; for example, types which use a lot of generics can take unexpected amounts of time to derive even Show iirc, or deriving Show ccan conversely slow down the Generics machinery because it has more to wade through
13:45:16 <boxscape> I suppose it would prevent you from accidentally showing non-pretty printed values to users
13:45:21 <boxscape> ah, interesting
13:46:18 <geekosaur> this said I tend to derive Show on any type where it makes sense (and sometimes write manual instances for types which have non-Show-able components such as functions) just to ease debugging in ghci
13:46:31 <boxscape> that makes sense
13:46:32 <geekosaur> or with Debug.Trace
13:46:53 <geekosaur> there's no real standard here
14:04:23 <dsal> Can I do something like      x <$> [@A, @B]   with TypeApplications?
14:06:09 <boxscape> dsal no, see here https://gitlab.haskell.org/ghc/ghc/issues/12363
14:08:48 <dsal> This is mildly inconvenient, but I'm doing it to do something that's mildly inconvenient, so that's fine.
14:11:42 <argent0> Has anyone been lucky with https://repl.it/site/blog/github? (Running your github repository in a repl.it repl)
14:12:08 <argent0> mine times out on build :(
14:14:17 <boxscape> does makePrisms generate anything for constructors that are operators?
14:15:29 <boxscape> ah, it does. I can just use -ddump-splices to see it
14:23:26 <solonarv> boxscape: huh, what does it generate?
14:23:37 <boxscape> solonarv it prefixes it with . instead of _
14:25:00 <Ailrun[m]> :info Debug.Trace
14:26:41 <solonarv> boxscape: makes sense!
14:26:50 <solonarv> Ailrun[m]: this channel is not ghci ;)
14:27:32 <Ailrun[m]> at least it gives :t :)
14:27:34 <Ailrun[m]> :t foldl
14:27:36 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
14:28:00 <Ailrun[m]> solonarv: see :)
14:31:26 <dsal> % :info Debug.Trace
14:31:26 <yahb> dsal: ; <interactive>:1:1: error: Not in scope: `Debug.Trace'
14:31:40 <dsal> I think you want browse
14:32:16 <boxscape> join $ p ^? antecedent . to consequence -- is there a better way to do this than with join?
14:32:30 <boxscape> basically `to consequence` produces a Maybe again
14:34:18 <Axman6> . _Just?
14:34:57 <boxscape> oh, right
14:35:17 <Axman6> or .traverse, .each, and probably several other options
14:35:18 <madnight19> lets say I'm inside of IO IO  IO IO and so on, how can I get rid of all the extra IO layers? i know the function liftIO, but that lifts me only up the monad stack until I hit IO
14:35:50 <boxscape> :t join . join . join . join
14:35:52 <lambdabot> Monad m => m (m (m (m (m a)))) -> m a
14:36:03 <boxscape> ^ madnight19
14:36:47 <Axman6> there is a lot of confusion in that question
14:36:59 <madnight19> hmm okay i thought i could collapse all these extra IOs into one without multiple lifts
14:37:57 <Axman6> why do you have so many layers of IO?
14:38:04 <Axman6> that's not a common thing
14:38:34 <Axman6> generally I've only ever seen two layers, where you have an IO action which returns an action to be called later. IO (IO CleanUpResponse)
14:40:12 <madnight19> lets say you want to have an IO action which returns an action to be called later and that cached with CachedIO, this already results in 3 times IO
14:41:04 <Axman6> I don't know what CachedIO is
14:41:18 <madnight19> https://hackage.haskell.org/package/cached-io-1.1.0.0/docs/Control-Concurrent-CachedIO.html
14:43:00 <Axman6> but it also sounds like the situation I was talking about. there;s only two levels of IO, and combining them together with join makes no sense
14:43:29 <Axman6> since the action returned by the m (m a) is the action you need to call multiple time, and the outer m should only be executed once
14:43:41 <madnight19> ok thanks for help, ill do so
14:48:16 <fragamus> hi do we have something in some library that does this to a couple arrays of Integer:
14:48:16 <fragamus> fmap (\(a1,a2)->a1+a2) $ zip [1, 2, 3] [4, 5, 6]
14:48:50 <Axman6> :t zipWith
14:48:52 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
14:48:57 <fragamus> right
14:49:07 <Axman6> > zipWith (+) [1, 2, 3] [4, 5, 6]
14:49:09 <lambdabot>  [5,7,9]
14:49:17 <fragamus> thank you
14:53:50 <Axman6> fragamus: it's also worth keeping in mind that those are lists, not arrays
14:54:58 <monochrom> as in: singly linked list
14:55:53 <monochrom> Python is extremely toxic in polluting young minds in conflating the two and being unaware of inefficiency consequences.
14:56:29 <loli> monochrom: what do you think of dependently typed languages calling indexed lists arrays
14:56:32 <loli> vectors*
14:57:22 <monochrom> This is what's wrong with scripting languages aspiring to serious programming.
14:58:01 <monochrom> Perhaps some of their authors grew up with Python?
14:58:19 <loli> Well I wouldn't call Idris or F* python inspired
14:58:53 <Entroacceptor> Proper languages call that a string.
14:59:05 <loli> just something annoying I found, since it's a naming conflict between two different worlds
14:59:29 <monochrom> Oh I only claimed "grew up with Python", not "inspired by Python".
14:59:45 <monochrom> All of you grew up with smartphones.
15:00:17 <monochrom> It means you are biased in some way, but not inspired.
15:00:26 <loli> welll I can simply mention coq which was 1989 no?
15:00:31 <[Leary]> Isn't it weird to conflate vectors with arrays anyway? Vectors are fixed length (probably best /implemented/ as an array), arrays are packed rather than linked.
15:00:42 <loli> https://coq.inria.fr/library/Coq.Vectors.VectorDef.html
15:00:52 <[Leary]> So a fixed-length linked structure is a perfectly good vector.
15:01:07 <loli> [Leary]: I have weird expectations, as I always imagined it as a 1D array due to CL
15:01:29 <loli> languages tend to muddy the water with expectations of vector
15:02:11 <loli> another fun difference between communities is what polymorphism is assumed to mean
15:03:07 <monochrom> We need to up the game.  There are 3 kinds of "functor"s among programmers.
15:03:50 * hackage tasty-rerun 1.1.15 - Rerun only tests which failed in a previous test run  https://hackage.haskell.org/package/tasty-rerun-1.1.15 (Bodigrim)
15:04:00 <monochrom> I may have to dodge the "vector" issue and say "at least they didn't say 'array' or 'list'".
15:04:17 <d34df00d> Actually four kinds.
15:04:37 <nil> the haskell kind, the ocaml kind, the c++ kind... what else?
15:04:38 <monochrom> w00t, I know of Haskell's, C++'s, SML's.  What is the other one?
15:04:43 <d34df00d> (I'd discriminate between categorical functor and Haskell functor, although they are related)
15:04:48 <monochrom> OK!
15:04:57 <loli> what are the other two. Haskell's terminology is inspired from Category theory (sadly without better typing we can't the theorems about them in haskell too well), and the ML kind
15:05:04 <monochrom> Can we agree to the number 3.14159? :)
15:05:19 <loli> C++ has "functors"?
15:05:29 <d34df00d> I wanted to be a jerk and ask for a few more digits, but I don't remember them :(
15:05:29 <monochrom> "The average programmer knows of 3.14159 kinds of functors"
15:05:30 <nil> s/ocaml/SML/
15:05:36 <d34df00d> loli: that's basically any callable object.
15:06:01 <d34df00d> That is, any struct/class with an operator()
15:06:05 <loli> nil: if we really want to diverge them, then we can say OCaml's and SMLs are different since one is generative and one is applicative!
15:06:11 <monochrom> C++'s "functor" is "overload the function call operator"
15:06:12 <d34df00d> 5 functors!
15:06:14 <loli> d34df00d: that is a very odd definition
15:06:17 <nil> loli: i have no idea what that means
15:06:33 <d34df00d> loli: that's what C++ folks have.
15:06:36 <loli> it's technicalities in how the ML module functor system work
15:06:43 <d34df00d> Obviously "functor" is coined from "function" and "object".
15:06:47 <monochrom> "function operator" -> "func___ _____tor"
15:06:48 <loli> I don't know the nuances enough to explain them properly, I am sorry
15:06:50 <d34df00d> The "-or" comes from "object" obv.
15:07:03 <loli> d34df00d: how unfortunate
15:07:21 <nil> orject
15:07:21 <d34df00d> monochrom: haha, interesting! I never thought about that one.
15:07:56 <monochrom> I mean, they already do constructor -> ctor
15:08:03 <zincy_> So postgres-simple is giving me this weird error I cannot replicate in psql
15:08:05 <zincy_> https://pastebin.com/v3C0PzxE
15:08:16 <monochrom> ctor, dtor, etor, ftor
15:08:25 <zincy_> Also this is the schema http://sqlfiddle.com/#!17/5b433/4
15:08:56 <monochrom> loli: Is SML's the generative one?
15:09:02 <loli> yes, monochrom 
15:09:08 <loli> OCaml is the applicative one
15:09:22 <nil> does that only matter when compiling or is it actually different semantics?
15:09:33 <loli> different semantics slightly
15:09:42 <zincy_> is there a postgres-simple-simple
15:09:47 <loli> so it does reflect in some cases IIRC
15:09:52 <loli> I'd have to re-read some papers
15:09:59 <loli> since I've never touched SML
15:11:02 <loli> "For you SML fans, OCaml now has generative in addition to applicative functors."
15:11:08 <loli> huh I guess OCaml grew
15:11:24 <monochrom> d34df00d: I remember up to 3.141592653 (and that the digit after is >5, so I also know to round to 3.141592654)
15:11:57 * nil knows about 100 places
15:12:15 <nil> well, used to. probably down to around 80 now
15:12:15 <monochrom> If pressed, I ditch base-n expansions and go continued fractions.
15:20:01 <svipal> does anyone here use red
15:20:24 <monochrom> What's red? I'm monochrome :)
15:39:51 * hackage esqueleto 3.3.0 - Type-safe EDSL for SQL queries on persistent backends.  https://hackage.haskell.org/package/esqueleto-3.3.0 (parsonsmatt)
15:50:37 <propanoplan> Hello! There is a simple question: how can I write this code more elegantly (without parentheses) 
15:50:41 <propanoplan> `infoHash = fmap (hash . B.encode) . (M.lookup "info" <=< B.dictionary)`
15:55:29 <solonarv> propanoplan: honestly, I think this is pretty elegant already
15:55:44 <solonarv> trying to get rid of parentheses certainly won't improve it
15:57:00 <propanoplan> I see, thank you!
15:57:08 <monochrom> What's all the hate against parentheses?!
15:58:46 <dsal> /j #lisp
16:01:00 <bitmapper> you could violate the sacred laws and change the precedence of the operators
16:01:52 <monochrom> Actually I spoke of a plan to have multiple versions of the same operator so each version is at a different precedence level.
16:02:10 <solonarv> you could probably whup up something terrible using `infix` and &hacky infix$
16:02:12 <monochrom> So (x+y)*z can be written as x+y**z
16:02:36 <monochrom> Actually I designed it to be x+y.*.z
16:02:38 <solonarv> monochrom: precedence based on how much whitespace is to either side!
16:02:46 <monochrom> how many dots
16:02:59 <solonarv> but dots are valid as part of operators already
16:03:08 <monochrom> Oh yes whitespace is better, but hard to implement in Haskell
16:03:10 <solonarv> you would be conflicting with existing operators like .&. from Data.Bits
16:03:28 <solonarv> could be some other special character that isn't legal yet
16:03:31 <solonarv> not sure what that would be
16:03:56 <monochrom> x+y#*#z
16:04:14 <solonarv> also valid already, no good
16:04:44 <monochrom> MagicPrecedenceHash
16:05:50 * solonarv hears an Ed scream in the distance
16:12:03 <[itchyjunk]> xs is the function being defined but its getting called from within the list comprihension and i'm totally lost :s https://imgur.com/a/faRxQHU
16:12:24 <[itchyjunk]> wait xs is not the function
16:12:38 <monochrom> It says "Success!".  What's the problem?
16:12:41 <ChaiTRex> xs is almost always a list.
16:12:58 <[itchyjunk]> ah i see
16:13:28 <ChaiTRex> (or some list-like type)
16:13:35 <monochrom> Also why is it such a small picture with tiny characters?
16:13:41 <[itchyjunk]> i forget what <- is called but if i have [x | x <- [1..10]] it takes each element of that list and assigns it to the x
16:13:49 <devalot> Is there a way to constrain the result type of a type family so that GHC knows applications of a type family always return instances of some class?  I'm using a type family to create a wrapper around another library and I don't want to expose types/classes from the original library.
16:14:05 <[itchyjunk]> idk, i took a screenshot. i guess i could have linked to the link i am reading but its a large page
16:14:17 <ChaiTRex> [itchyjunk]: <- is taking the return value in a monad. It's like = only it turns m a into a.
16:14:34 <monochrom> Um, ChaiTRex, the context is list comprehension.
16:14:37 <[itchyjunk]> hmm
16:14:43 <ChaiTRex> [itchyjunk]: So, xs is a list. Lists are [] a, so it gives you an a.
16:15:03 <[itchyjunk]> hmmmm
16:16:03 <ChaiTRex> [itchyjunk]: You can also think of it as giving you a value, x, from the list xs.
16:16:06 <soeim> aren't list comprehensions just syntactic sugar for monads?
16:16:11 <monochrom> No.
16:16:32 <[itchyjunk]> do i need to understand monads first to understand this? :s this is like the first chapter in the book :<
16:16:38 <monochrom> But you could have designed a simple experiment to discover it yourself.
16:16:44 <ChaiTRex> [itchyjunk]: No, not really.
16:16:56 <glguy> No, you don't need to understand the general concept of Monad to understand a list comprehension.
16:17:19 <monochrom> Brings us right back to why mention "monad" in the first place.
16:17:32 <ChaiTRex> [itchyjunk]: Without monads, x <- xs in a list comprehension is like taking one element from the list and assigning it to the variable x.
16:17:59 <monochrom> "hi, note that foldr is catamorphism, but pretend you never heard that for now!"
16:18:14 <[itchyjunk]> i understand simple list comprihension like [2*x | x <- [1..10], x \= 5] it will pass 1 through 10 except 5 to x which then is multiplied by 2 for each one 
16:18:25 <glguy> monochrom: but do you feel smarter now having told me?
16:18:27 <bitmapper> i prefer to reference the GPT-2 monad tutorial whenever i need to brush up
16:18:30 <[itchyjunk]> ChaiTRex, right that i get
16:18:33 <monochrom> YEAH!
16:18:58 <ChaiTRex> [itchyjunk]: This is the same sort of thing, x <- xs gets the list item into x. odd x is a Bool value that filters out elements.
16:19:00 <glguy> monochrom: Well, I'm more of a dog person, so...
16:19:09 <evelyn> catamorphism is about the only sensibly-named of those godforsaken recursion schemes
16:19:20 <monochrom> In fact I now believe in an economic theory that says that and much more.
16:19:56 <monochrom> There are two motivations for people to answer questions for free on IRC.  Like why would they spend time for free, eh?
16:20:01 <soeim> saying that a list comprehension is a monad, while maybe not helpful to understand list comp., is useful for when they being introduced to monads, already understand the concept
16:20:23 <monochrom> One motivation is to prove you have abilities and knowledge.  Another motivation is to prove you can teach.
16:20:35 <ChaiTRex> [itchyjunk]: Then, it does the if then statement to give you one of two values. Like 2*x can take x and do stuff with it, so can an if then.
16:20:42 <[itchyjunk]> so its taking an element from xs passing it to x and if x is off and x < 10 then "BOOM!" else "BANG!" ?
16:21:04 <[itchyjunk]> s/off/odd/
16:21:09 <ChaiTRex> [itchyjunk]: No, the odd x completely removes all even values from consideration.
16:21:20 <[itchyjunk]> oh
16:21:22 <monochrom> This is an economic theory because next time you apply for a job, you can whip up your IRC logs and show your interviewer what you have proved.
16:21:24 <ChaiTRex> [itchyjunk]: Only odd x values get to the if statement in the first place.
16:21:30 <[itchyjunk]> ah i see
16:21:52 <[itchyjunk]> but i am wondering, if its taking elements from a list xs
16:21:58 <[itchyjunk]> but xs itself is this list
16:22:02 <monochrom> If you plan to apply for a developer job, you have an incentive to prove your abilities and knowledge, but not to teach.
16:22:09 <[itchyjunk]> isn't this some sort of circular hell?
16:22:15 <ChaiTRex> [itchyjunk]: No, xs is an argument to boomBangs function.
16:22:24 <[itchyjunk]> ohhhhhhhhhhhhhhh
16:22:25 <ChaiTRex> [itchyjunk]: It's a definition of boomBangs, not of xs.
16:22:27 <monochrom> If you plan to apply for a teaching job, you have an incentive to demo your teaching methods.
16:22:51 <[itchyjunk]> oh right, okay dang. this makes sense now
16:23:19 <monochrom> And it shows.  Most people here are developers, and they do prove here their knowledge.  I am teaching in a university, and I do show here my teaching methods.
16:23:56 <soeim> your poor students
16:23:57 <[itchyjunk]> you teach haskell in a uni?
16:23:58 <evelyn> teaching is really rewarding, it should be a part of any job
16:24:08 <[itchyjunk]> unis ive been to teach java
16:24:24 <[itchyjunk]> i didn't know taking haskell in uni was an option
16:24:38 <bitmapper> they only teach java here
16:24:41 <glguy> When it's Haskell it's a "Maybe"
16:25:10 <bitmapper> i never really learned haskell, to be honest
16:25:11 <hpc> glguy++
16:25:12 <monochrom> Take comfort in knowing that most universities don't teach category theory.
16:25:14 <[itchyjunk]> i have a "crypto" class next semester. it's a math department class so no coding required. but i imagine it would help if i can code. but i doubt i'll be able to learn enough haskell to implement stuff from the class
16:25:39 <[itchyjunk]> mine does have a cat theory class, but its a grad course
16:26:13 <bitmapper> i learned standard ml then most stuff carried over to haskell because i had a big library of monad + function composition/application operators
16:33:11 <evelyn> if it's a course about the mathematical principles behind cryptography, there could well be no coding involved whatsoever
16:35:10 <monochrom> Note that Ralf Hinze's paper "adjoint folds and unfolds" shows how to account for a large class of almost-catamorphism-but-not-quite functions by observing that they are just an adjoint functor away from a catamorphism.
16:35:24 <monochrom> But now pretend you haven't heard of that yet!
16:40:23 <nil> monochrom: what's wrong with teaching cat theory?
16:40:30 <solonarv> monochrom: well, it turns out that list comprehensions really are just do notation in a trenchcoat
16:40:41 <monochrom> Nothing wrong? Why?
16:40:49 <nil> <monochrom> Take comfort in knowing that most universities don't teach category theory. 
16:40:55 <nil> did i misinterpret this?
16:41:10 <monochrom> Oh it means don't feel bad if your school doesn't cover Haskell.
16:41:21 <nil> solonarv: are they? they seem to desugar directly into loops instead of calls to >>= and return
16:41:29 <monochrom> It means the world is flawed anyway
16:41:30 <nil> monochrom: oh ok
16:42:18 <monochrom> If you use >>= and return for lists, that probably compiles to the same loops too
16:42:39 <solonarv> nil: list comprehensions don't desugar to do notation, but they are equivalent to (a specialized form of) do notation
16:43:01 <solonarv> the [ expression | at the start turns into a 'return (expression)' at the end of the do block
16:43:06 <nil> i'm lucky enough to be in a school where they teach (some) category theory. no haskell though, the national language is ocaml. (guess the country)
16:43:14 <monochrom> But pedagogically it is unwise to bring up monads when you are still figuring out list comprehension.
16:43:23 <nil> solonarv: yes, it's an equivalence
16:43:29 <nil> monochrom: i agree
16:43:43 <solonarv> 'pat <- xs' just turns into 'pat <- xs', similarly 'let' turns into 'let' again, and booleans turn into calls to Control.Monad.guard
16:43:49 <monochrom> And technicality-wise you can't use comprehension on other monad types in Haskell 2010.
16:43:51 <d34df00d> What does "'b0' is untouchable" mean?
16:44:04 <nil> solonarv: actually i think >>= for lists is defined using list comprehensions, so you might as well say that "Monad [] is just list comprehensions under the hood"
16:44:05 <d34df00d> I don't easily have a minimal reproducing example, sadly.
16:44:55 <monochrom> Conjecture: Monte Carlo uses OCaml in casinos :)
16:44:56 <MarcelineVQ> d34df00d: I bet you have a longer error message though
16:45:15 <d34df00d> https://bpaste.net/show/SIU2W
16:45:22 <d34df00d> It doesn't even mention b0 anywhere else!
16:46:46 <d34df00d> Yeah, I pattern-match on the type that an existential type has been constructed with.
16:47:14 <d34df00d> (that is, I have smth along the lines of \(MkDV (_ :: a)) -> ...)
16:55:21 <[itchyjunk]> evelyn, the class wont require coding but im sure it makes sense to code stuff
16:55:37 <[itchyjunk]> course discription includes stuff like error correcding code and elliptical curves
17:13:48 <jusss> if I run hsdev in Windows Subsystem of Linux on windows 10, can I make sublime text editor to use it on windows 10?
17:18:34 <ChaiTRex> jusss: I think you need to run an X server or something that supports Windows 10 to run GUI programs on WSL (google for: run gui programs on wsl)
17:19:25 <jusss> ChaiTRex: it's really a pain to use haskell on windows or archlinux
17:19:25 <ChaiTRex> jusss: Unless you mean running the Windows version of Sublime, in which case I don't know.
17:20:02 <ChaiTRex> jusss: If I was stuck on Windows, I'd probably use VirtualBox or something with an Ubuntu VM.
17:20:27 <jusss> ChaiTRex: yeah
17:20:40 <ChaiTRex> jusss: Not sure how to get a Windows program to interface with WSL.
17:21:05 <ChaiTRex> jusss: Another alternative is X server for Windows 10 and WSL.
17:21:29 <ChaiTRex> jusss: Then run Sublime Linux version.
17:59:03 <alfianfuadi> can someone help, how to make a datatype whose value constructor return a typevariable with typeconstraint
17:59:30 <alfianfuadi> like :t 1 = (Num a)=>a
18:01:33 <Cale> alfianfuadi: 1 is polymorphic because it's a built-in feature of the language that it desugars to fromInteger (1 :: Integer)
18:01:49 <alfianfuadi> can i made some similar type like that?
18:02:10 <Cale> alfianfuadi: You could make a type class that has a similar operation which generalises from some data type
18:02:20 <Cale> But you'd still have to write that operation explicitly
18:03:53 <alfianfuadi> okay
18:03:55 <alfianfuadi> thx
19:09:31 <NemesisD> is anyone familiar with singletons' type equality? i can't quite understand why this doesn't work: `data Foo; instance PEq Foo; f :: ((x == Foo) ~ 'True) => proxy x -> ();`, when i call `f (Proxy @Foo)` i get `Couldn't match type ‘Foo == Foo’ with ‘'True’`
19:10:27 <NemesisD> actually it fails with `'False` as well
19:12:08 <Cale> Which == is that?
19:12:41 <Cale> Is it certain that it's the one from Data.Singletons.Prelude.Eq ?
19:13:31 <Cale> I guess it's hard for it to be something else, given that you're defining an instance of PEq there
19:13:47 <NemesisD> Cale: yeah, i'm importing it qualified, i just stripped that out for the paste but probably shouldn't have
19:17:16 <Cale> hmm
19:17:24 <Cale> NemesisD: What brings you to using singletons?
19:18:00 <NemesisD> Cale: i happen to have it in scope. i actually need to use its `Elem x xs` type family but that's implemented in terms of equality and was giving me similarly surprising errors
19:18:32 <NemesisD> i think i've implemented elem before but it seems like kind of a waste since its in scope and i think its meant for something like this
19:19:53 <Cale> (Usually I consider singletons to be a clear sign that one has gone a bit too far with the fancy types, haha)
19:20:09 <NemesisD> oh that ship has sailed lol
19:21:30 <NemesisD> in this case i think i'm justified. i'm adding a layer of safety over haxl. haxl lets you combine multiple query types into one program but if you don't carefully initialize each you'll get a runtime error. so i'm using type-level lists and newtypes to make sure that isn't possible
19:21:37 <Cale> I'm okay with stuff that can be encoded via GADTs, DSum and DMap, but when you get to type level lists and singletons and generally wanting to write expressions that do computation in your types, that's where Haskell's support for dependently typed programming starts to become a little too uncomfortable.
19:22:16 <Cale> But yeah, good luck :D
19:22:34 <NemesisD> i mean the solution here is to write a bespoke type family for type-level list membership that does the same thing that singletons is supposed to do
19:22:49 <Cale> Yeah, that might also do the thing...
19:23:11 <Cale> I haven't actually used the singletons library itself enough to know why it would have trouble with that
19:23:36 <NemesisD> ah no worries :) usually jle` (IIRC) chimes in eventually :P
20:17:32 <Alex53> Hi there, would someone mind helping me with encoding/decoding via cereal in haskell?
20:22:45 <maerwald> it seems -jx in hspec breaks tests, although there is no 'parallel' in front of them
20:51:43 <maerwald> in hspec, when you do https://gist.github.com/hasufell/37ac6a08d93ada2ccc59feab386e93cc ...the parallel tests start *immediately*
21:31:47 <zeta_0> has anyone here used nix with haskell to build/develop projects?
21:34:58 <wrunt[m]> zeta_0: yes, I have
21:40:07 <wrunt[m]> zeta_0: I've documented/automated the process I use here: https://bitbucket.csiro.au/users/cha748/repos/nix-haskell/browse (should be publicly accessible)
21:40:16 <zeta_0> wrunt[m]: cool, i plan on using nix with haskell and i heard a good method is to create a `default.nix` file to use in conjunction with your haskell project, and then use nix-shell so you can do your development in an isolated environment, does this sound correct?
21:41:46 <zeta_0> wrunt[m]: thanks, i am looking at these instructions as well: https://www.srid.ca/haskell-nix.html
21:41:51 <wrunt[m]> zeta_0: Yes, broadly correct. There are some other good practices you should use, such as pinning to a specific version of the nixpkgs repository so that your builds are repeatable into the future, and will work for others.
21:43:56 <wrunt[m]> There's also https://github.com/Gabriel439/haskell-nix
21:43:58 <zeta_0> wrunt[m]: so, i'm guessing pinning to the stable channel (currently 19.09) would be best
21:44:55 <zeta_0> wrunt[m]: i worked through the 1st chapter of that link, that stuff is still a little to over my head
21:45:21 <maerwald> wrunt[m]: what about security updates?
21:45:43 <wrunt[m]> zeta_0: It depends. The packages in the stable channel tend to lag behind Hackage, so if you need a recent version of any package then you may need a more recent snapshot of the unstable branch.
21:46:23 <wrunt[m]> IOHK also have https://input-output-hk.github.io/haskell.nix/ which looks interesting, but last time I tried it I failed to get it to work.
21:46:43 <zeta_0> wrunt[m]: but in unstable packages are more likely to break right?
21:47:30 <zeta_0> wrunt[m]: thanks for the links
21:47:34 <wrunt[m]> maerwald: I haven't got a good answer for that. The only way to do it would be to change your pinned snapshot and try to build. That gets you the latest security updates but also the bleeding edge.
21:48:38 <zeta_0> also i plan on using yesod with warp, is it yard to use these to tools? i heard converting haskell to javascript is very painful?
21:48:58 <Kk2> is it possible to stream audio to an output with haskell?
21:50:01 <maerwald> zeta_0: typescript or purescript for frontend is ok
21:50:19 <wrunt[m]> zeta_0: Yeah, maybe. I often find that there are a few broken packages, for which there are often other versions available in hackage-packages.nix, so I override the version in my haskell-package-overrides.nix, and unmark them as broken. Occasionally I even have to check out a package locally and point nix at that.
21:52:44 <zeta_0> oh, ok, that makes sense, thanks for the tips guys
21:53:36 <Cale> zeta_0: Where I work, we compile Haskell to Javascript all the time for our frontends. We've got a bunch of open source tools to help with that.
21:54:50 <zeta_0> Cale: sounds good, i am a self taught programmer getting into freelancing, so i am going to be applying all over the place
21:55:07 <jusss> Cale: with which tools?
21:55:14 <jusss> compile Haskell to JS
21:55:24 <Cale> https://github.com/obsidiansystems/obelisk/ is probably the friendliest entry point there, but it's a little bit opinionated, so if you want to build your own backend, you might just use reflex-platform, which is here: https://github.com/reflex-frp/reflex-platform/
21:55:30 <Cale> jusss: GHCJS
21:55:33 <zeta_0> is ther a good demand for haskell programmers in industry?
21:56:34 <Cale> zeta_0: There's certainly some. The proportion with the number of Haskell developers is reasonably good, I think.
21:57:01 <maerwald> zeta_0: not much, jobs are hard to find, especially for entry-level
21:57:05 <Cale> We've been expanding a bunch in the last few years and hiring lots of people
21:57:39 <jusss> FFI is easy in Haskell?
21:57:50 <jusss> I saw lots of bindings are FFI stuff...
21:57:57 <Cale> jusss: Yeah, relatively so
21:58:18 <zeta_0> Cale: well, if you guys need another haskell programmer let me know
21:58:29 <zeta_0> Cale: i am looking for remote work though
21:58:51 <jusss> Cale: this require good skills at C++ or C?
21:58:53 <Cale> Our office is based in NYC, but we're about half remote
21:58:57 <jusss> doing FFI
21:59:21 <Cale> jusss: Well, technically neither, but usually you'll be binding to C libraries
22:00:03 <jusss> Cale: Well, it means I still need to learn C 
22:00:10 <Cale> FFI to C++ libraries is theoretically possible, but usually requires some work on the C++ side as well, because C++ doesn't really have a totally consistent ABI
22:00:16 <zeta_0> also, what are the best websites to apply for haskell jobs, it feels like i am searching for a needle in a haystack?
22:00:31 <Cale> (FFI to C++ from any language is kind of brutal)
22:00:49 <maerwald> zeta_0: check out functional works hub
22:00:53 <jusss> Cale: but C++ support OOP, and lots of languages now support OOP
22:01:29 <zeta_0> maerwald: thanks
22:01:43 <Cale> jusss: That doesn't mean that it's easy to just call C++ code from another OOP language though.
22:01:55 <maerwald> remote is challenging though, especially for entry-level, most companies won't do it IME
22:02:59 <jusss> Cale:  this is a C++ lib I'd like to make Haskell work on, https://github.com/aldebaran/libqi
22:03:25 <zeta_0> maerwald: i have been programming for fives years so i think i am ready for industry, just getting my food in the door is the challenge
22:04:01 <maerwald> zeta_0: I mean haskeller without industry experience.
22:05:04 <zeta_0> maerwald: that's the chicken and the egg problem
22:05:34 <jusss> there're lots of bindings like libqi-java libqi-dotnet libqi-julia blabla, but no libqi-haskell
22:06:03 <maerwald> zeta_0: yeah and it's more challenging in haskell, because teams are usually not too big and in order to be comfortable to hire unexperienced people, you need a big team
22:07:35 <maerwald> and the big teams may just be far too advanced ^^ (like digital asset in switzerland)
22:07:40 <Cale> There have been some people we've hired without as much Haskell experience, but usually they were very strong at something else we needed at the time.
22:08:02 <zeta_0> maerwald: i guess my best bet would be to network with people through open source, i plan on contributing to ghc soon
22:08:26 <maerwald> if you're good at compilers, then that surely will get you attention
22:10:11 <maerwald> IME, what I value more than language choice though, is a professional and mature workflow. And surprisingly that's even harder to find than a job in a niche language :>
22:11:55 <zeta_0> maerwald: yeah, and i am glad i took the time to learn nix, it saved me from a lot of pain and suffering
22:12:13 <maerwald> well, I wasn't referring to that, but sure
22:12:31 <maerwald> (in fact I have the opposite experience)
22:12:43 <zeta_0> maerwald: sorry that i went off topic
22:14:39 <zeta_0> maerwald: opposite experience?
22:14:53 <maerwald> with nix
22:15:05 <maerwald> but it's one of the oldest flamewars, directly after vim vs emacs ;)
22:15:09 <Cale> zeta_0: We use nix for all our projects at Obsidian. It's the best thing that presently exists at what it does, but there are a lot of difficult things about using nix.
22:15:45 <maerwald> You need someone who has *very* deep knowledge about it. Basically someone who has done actual packaging and was exposed to all the quirks of the ecosystem, the PM etc.
22:16:08 <maerwald> And if you have only one such person, it's a bad bus factor
22:16:12 <Cale> Nix is *fantastic* if you have a bunch of coworkers who are good at nix and you don't have to actually write very much of it :D
22:16:26 <maerwald> Imagine they all leave ;)
22:17:17 <Cale> It makes things repeatable very well, and bugs will generally be reproducible the same way on every developer's machine and between dev machines and production.
22:17:28 <Cale> That's quite nice.
22:17:55 <zeta_0> agreed, when i used debian with aptitude, everything would just break(dependency hell, banging my head against my laptop), but when i switched to nix(os) everything worked much better
22:18:05 <maerwald> Hiring someone who has strong knowledge of nix AND nixops after your main infra dude left the company will be an interesting task for a small team. As a comparison... terraform and ansible can be learned in 3 days max
22:18:35 <maerwald> So you are committing to a pretty heavy stack
22:19:44 <Cale> The part where I struggle isn't so much with nix itself, but the fact that there's a culture in nix of making large associative maps ("attrsets") of packages and code for constructing packages, aggregating and transforming them in various ways, and you can end up having a really hard time tracking down where any particular key of those maps is really defined
22:20:13 <maerwald> Cale: well, yeah, in the end it's not really a configuration language
22:20:18 <Cale> You end up doing a lot of grepping through the entire source code of nixpkgs for example, hoping to find the places where your key is mentioned, which gets frustrating.
22:21:14 <Cale> Well, Haskell isn't really a configuration language either, but thanks to having a module system, at least if I know what module some definition came from, and I know which package that module is in, I can do find the file on disk that defines the thing.
22:21:25 <zeta_0> well thanks for the tips guys, i am going to keep trying, the struggle is real sometimes
22:21:49 <Cale> We don't have a lot of module-level metaprogramming where we're transforming the contents of modules a bunch, making the definitions therein spread out across many places.
22:22:02 <maerwald> IMO, nix is only useful if you want to share configuration, not results. For results, there are containers, binaries, ...
22:22:10 <Cale> (It hasn't been physically possible, though we have backpack now...)
22:22:35 <maerwald> And in the end, most companies are not sharing their configuration, they deploy a result to some nodes
22:22:42 <Cale> Nix isn't too bad at sharing results
22:22:55 <maerwald> It can be done with a lot less complexity though
22:23:16 <Cale> We have binary caches that are tied into our CI
22:23:34 <Cale> so that as soon as CI builds something, every developer can get it automatically without having to build it
22:23:47 <maerwald> we use cabal-cache, works well enough
22:24:30 <maerwald> deployment via containers is trivial, would be nicer with static binaries though (but then musl)
22:24:40 <Cale> Our deployment process basically just does a nix-copy-closure to the target machine, then ssh'es in, switches to the new configuration and restarts.
22:25:12 <Cale> (that's all done by ob deploy now)
22:25:37 <zeta_0> later guys
22:25:40 <Cale> later!
22:29:30 <Cale> My problems with nix aren't so much the experience of using it externally, it's just when you actually have to program stuff in the language, the library ecosystem for it is a bit of a mess, and I suppose the language doesn't help it stop being a mess very easily. It's a pure functional programming language, but it's untyped, making it difficult to refactor things, and the culture of how people get things done in it involves lots of 
22:29:30 <Cale> big fixed points involving transforming packages. Functions often take entire universes of packages as an argument, which just... kind of undermines a lot of the benefits of functional programming.
22:32:31 <Cale> If every function in your Haskell program took as an argument some sort of (dependent) map structure containing all the definitions in your Haskell program, that would be insane... but it's kind of how nixpkgs does things a lot of the time, because there's no module system.
22:34:23 <maerwald> that's why I don't want to use it as a configuration system
22:34:30 <maerwald> if someone manages to build something sensible on top, sure
22:34:44 <maerwald> (which should be fairly possible)
22:34:54 <Cale> Yeah, the core idea of it is great, I think
22:34:59 <maerwald> (and would probably be a separate ecosystem than nixpkgs)
22:35:29 <Cale> It's mostly just some details of how that's been executed which make it a bit of a pain for anyone who hasn't got large swathes of the nixpkgs code memorised.
22:36:30 <Cale> Better tooling might help some -- there are a bunch of people working on a Haskell implementation of the nix language (since that seems easier than contributing to the C++ implementation), and that will hopefully have a bunch of better tools for analysing what's going on.
22:36:47 <maerwald> Cale: but then we don't even have proper tooling for haskell xD
22:36:59 <Cale> But I think partly it's just that people need to do functional programming better in nix-land.
22:37:01 <maerwald> so I'm not sure if a reimplementation will improve tooling?
22:37:11 <maerwald> Cale: yes, that's called policies in distros
22:37:14 <Cale> There's a lot of cargo-culting of bad patterns
22:37:40 <maerwald> NixOS doesn't have any notable established policy or QA team like other distros
22:38:10 <maerwald> Because it's too hard to unify anyway, when everything is turing complete
22:38:29 <Cale> I don't know much about NixOS personally, but yeah, I haven't really been convinced to run it on my own machine.
22:39:34 <Cale> It seems like it might be really nice if people had already put the effort in to make the desktop experience reasonably nice, because it's really easy to copy machine configurations around and overlay them and such for my coworkers that do use NixOS.
22:40:01 <Cale> But... the baseline config seems much much worse than something like Mint.
22:42:11 <Cale> There are so many tiny, somewhat-insignificant problems to deal with that add up when it comes to making a really nice distro for desktop use -- I don't want to be screwing around with figuring out why icons that are supposed to be on buttons in some program are messed up.
22:43:03 <Cale> But yeah, Nix and NixOS are separate things as far as I'm concerned
23:19:07 <refusenick> Can HIE be built with "stack build", i.e. without invoking install.hs?
