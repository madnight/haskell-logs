00:03:37 <Arahael> Don't think so.
00:08:15 <maerwald> Athas: probably never will
00:12:06 <Athas> Too bad.  I might just have to bite the bullet on this one.
00:30:42 <mynameisbrian> I'm installing Haskell and it's setting things up in ~/.ghcup, how's come that's not going in /usr/local instead? 
00:32:13 <Solonarv> doesn't require root permissions and is less likely to interfere with other users
01:00:48 <mynameisbrian> So how's haskell in the job market, you guys use it personally at work or did you get hired for it?
01:04:09 <tdammers> I do haskell full-time
01:04:20 <tdammers> the job market is tiny, but it's tiny on both sides
01:04:51 <tdammers> so if you're good at it, your odds of finding a nice job aren't significantly worse than in any other language
01:05:06 <tdammers> however, the job market is slow-moving, so it can take years for a suitable opportunity to roll along
01:05:15 <tdammers> and it's biased towards the upper end of the quality and skill spectrum
01:05:22 <iqubic> Few people hiring Haskell devs. Few Haskell devs looking.
01:05:25 <tdammers> meaning that it's especially difficult for juniors
01:06:12 <tdammers> that's because haskell is kind of a niche language for the "high quality, high degree of confidence in correctness despite high intrinsic complexity" situation
01:07:47 <f-a> phttps://twitter.com/GabrielG439/status/1189610465560711168
01:07:58 <f-a> far more applicants than jobs
01:08:10 <f-a> this tweet seems to akwardly imply
01:08:54 <EvanR> https://twitter.com/GabrielG439/status/1189610465560711168
01:09:01 <EvanR> so i can click on it
01:09:05 <f-a> ouch sorry
01:10:11 <tdammers> haha... that's like how the most convenient way for me to move a picture from my phone to my computer is to send a Signal or Whatsapp message to myself, and then downloading it through the web interface
01:10:11 <mynameisbrian> ahh okay, I'm pretty much just learning it for fun but I was curious 
01:10:48 <EvanR> thank bob for bluetooth based "airdrop" (ios)
01:14:20 <iqubic> I personally use email for that sort of file transfer.
01:16:42 <EvanR> email :(
01:17:02 <MarcelineVQ> first response "How diverse are your applicants?" I can't wait for this decade to end
01:17:02 <ent> syncthing is pretty nice for that stuff
01:17:23 <ent> (p2p dropbox kind of thing)
01:18:43 <EvanR> i saw that
01:19:01 <EvanR> but didn't want the thread to extend into IRC
01:19:25 <EvanR> not only that how do you know how "diverse" an applicant is from a resume
01:20:11 <EvanR> nevermind!
01:28:28 <tdammers> MarcelineVQ: "every single one of them is highly diverse"
01:28:49 * tdammers hates how words don't mean what they used to anymore
01:30:01 <cdunklau> tdammers: and then they pat themselves on the back for being inclusive
01:31:13 <mynameisbrian> I noticed that, of course immediately following we got the buzzword privlege haha. I want everyone to have a chance in tech too but most of these people are just virtue signaling 
01:38:35 <EvanR> immediately after privilege we got buzzword virtue signaling. Buzzword mitosis
01:39:05 <cyan1> EvanR: everybody serves HR now
01:41:41 <mynameisbrian> haha! true, you got me there 
01:58:08 <tdammers> "recycle" now means "throw away". "sustainable" now means "less bad for the environment than what we were doing before". "diverse" now means "accurately mirrors the distribution of some arbitrary key properties of humans in the general populace" (or, often, simply "have enough gay, black, disabled, and female people on staff")
02:04:56 <Putonlalla> I thought I mixed #haskell and #haskell-offtopic again.
02:06:00 <cyan1> tdammers: depending on the culture you're stuck in, diverse also means actively limiting perceived majority
02:10:39 <mynameisbrian> any other functional languages you guys like that are similar to haskell? 
02:12:36 <amx> purescript
02:12:49 <cdunklau> python
02:12:53 <cdunklau> hey, it has list comps!
02:13:00 * cdunklau hides
02:13:49 <EvanR> i heard some good things about ocaml
02:13:58 <Solonarv> @slap cdunklau
02:13:58 * lambdabot pushes cdunklau from his chair
02:14:03 <Solonarv> :O
02:14:08 <Solonarv> that's not a slap!
02:14:20 * haskelllisp[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/YyjMEmITqOeCJjKzsEqsPQeR >
02:14:30 <mynameisbrian> do you guys dislike OOP or do you also tend to use that? 
02:14:32 <EvanR> also lambdabot that pronoun is not very diverse
02:15:08 <Solonarv> mynameisbrian: I don't like OOP but use it anyway ;)
02:15:15 <cyan1> which functional language has the best tooling?
02:15:39 <EvanR> record of IO actions or functions, instant OOP!
02:15:48 <merijn> cyan1: I'd say Haskell, because I think Haskell's tooling (ignoring editor integration) is much better than most other languages I've used
02:16:07 <mynameisbrian> I want a fun language that I can default to, like one I can master and really focus on instead of being a jack of all trades. 
02:16:13 <merijn> I'm honestly rather confused by people saying Haskell's tooling is shit. Like, have you ever tried using Python, C, C++, or Java tooling? >.>
02:16:23 <maerwald> merijn: yes.
02:16:30 <cyan1> Stack is fairly friendly, never used just cabal
02:16:34 <merijn> mynameisbrian: I think Haskell is one of the best languages for general purpose stuff
02:16:51 <merijn> mynameisbrian: Also, one of the easiest to hook into other languages when needed
02:17:27 <merijn> mynameisbrian: The Haskell FFI is amazing, underrated feature, imo'
02:17:58 <EvanR> C has the best C FFI though
02:18:05 <kuribas> merijn: indeed.  IDEs suck, but package management and documentation isn't worse IMO
02:18:06 <merijn> Disagree :p
02:18:11 <Solonarv> C doesn't have a C FFI!
02:18:26 <merijn> With EvanR, I mean
02:18:47 <kuribas> merijn: actually for reasonably documented libraries, I prefer haskell by far.
02:18:54 <EvanR> someone just said haskell documentation "isn't worse" ?
02:19:03 <merijn> kuribas: "Haskell documentation is shit" -> *me struggling 4 days to find documentation for a major Python library*
02:19:04 <amx> cabal 3 is awesome
02:19:07 <cyan1> EvanR: Ha Ha!
02:19:09 <cdunklau> Solonarv: the bot assumed my gender!
02:19:11 <kuribas>  instead of having to read walls of text I just look at the types.
02:19:18 <merijn> EvanR: Haskell's documentation is consistently amazing compared to python/ruby's
02:19:35 <kuribas> merijn, EvanR and add clojure to that list
02:19:39 <cdunklau> merijn: which python lib?
02:19:44 <EvanR> with it consistently exists, unlike ruby
02:19:49 <Solonarv> cdunklau: I noticed, and EvanR pointed it out already
02:19:52 <merijn> cdunklau: matplotlib, scikit-learn, pandas, numpy, the standard library
02:19:56 <cdunklau> Solonarv: yeah i was scrolled up
02:20:05 <EvanR> but python docs seem to contain untold leagues of text on each function
02:20:20 <merijn> EvanR: Sure, but that text never makes it easy to find the stuff you care about
02:20:33 <merijn> And often just straight up doesn't contain the info you want
02:20:35 <cdunklau> merijn: i mean... matplotlib is just awful, sure, but pandas and numpy have pretty great docs imo
02:20:35 <EvanR> that text is what people are complaining about wrt haskell
02:20:42 <EvanR> not being there
02:20:52 <EvanR> whether they should be or not
02:20:56 <cdunklau> EvanR: some examples would be nice
02:21:00 <cdunklau> in the haskell docs
02:21:18 <cdunklau> (i'm super new though, so my opinion is flawed)
02:21:33 <EvanR> i included examples on all my packages
02:21:42 <merijn> maerwald: I mean, the closest thing to C/C++ tooling is CMake and if I had to pick between supporting cabal or cmake I know what I'd pick >.>
02:21:47 <EvanR> optics (package) also has nice examples
02:21:47 <cyan1> cdunklau: So many times just a couple of dinky examples would have saved a lot of time!
02:21:51 <kuribas> EvanR: because they don't know how to read types?
02:22:04 <maerwald> merijn: I wrote more CMake than cabal, so ;)
02:22:25 <cdunklau> the type of a thing is not sufficient :D
02:22:36 <merijn> cdunklau: I'm not saying the docs can't be improved, and examples can be useful sometimes. That said I still find the docs of most semi-big libraries (and even lots of tiny things) very good
02:22:43 <maerwald> merijn: but I think it's generally more about editor support, which is awful in haskell
02:22:44 <merijn> maerwald: So did I, hence why I'd prefer cabal :p
02:22:47 <cyan1> kuribas: somewhat of a point : /
02:23:08 <merijn> maerwald: ghcide is slowly getting there :)
02:23:24 <kuribas> cdunklau: a lot of time it's all I need
02:23:28 <cdunklau> merijn: yeah i can't comment on haskell, i only started this week
02:23:38 <kuribas> cdunklau: together with a small description
02:23:38 <merijn> cdunklau: The number of times I've seen docs with just a type is fairly small, though
02:23:40 <maerwald> merijn: not sure it's getting there performance-wise, though
02:23:53 <merijn> maerwald: So far ghcide has been crazy fast for me
02:24:38 <maerwald> merijn: I man on large code bases, like GHC
02:24:51 <maerwald> I haven't found a single tool that works on ~315 module codebase properly
02:25:20 <cdunklau> kuribas, merijn: a small description of course is *enough*, but a simple example could clarify so many things
02:25:55 <haskelllisp[m]> kuribas: "Haskell documentation is shit" -> *me struggling 4 days to find documentation for a major Python library*
02:25:55 <haskelllisp[m]> http://dev.stephendiehl.com/hask/#hackage
02:26:03 <kuribas> cdunklau: having a few exmamples for common usecases is also nice to have
02:26:09 <cdunklau> kuribas: definitely!
02:26:17 <kuribas> cdunklau: much better than wall of text (like the sqlalchemy library)
02:26:56 <kuribas> cdunklau: don't get me wrong, I am not advocating against documentation!
02:27:14 <cdunklau> heh
02:27:34 <kuribas> it's just that dynamic languages end up describing types in ad-hoc ways, using verbose and confusing language
02:27:36 <cdunklau> kuribas: sqlalchemy is one of those things that's just so damn big
02:28:15 <kuribas> indeed, and it gives back relatively little
02:28:18 <merijn> I mean, many libraries I use just don't really need very big docs anyway
02:28:24 <cdunklau> it's *really good*, and the docs are at least decent, but it's so magical
02:28:39 <kuribas> cdunklau: yes, and the magic *will* bite you back
02:28:40 <merijn> For example, stuff like https://hackage.haskell.org/package/data-interval-2.0.1/docs/Data-Interval.html is totally adequate, IMO
02:28:56 <kuribas> cdunklau: I've been in a team doing an sqlalchemy app, and it was hell
02:29:06 <cdunklau> kuribas: ORM right?
02:29:10 <cdunklau> core is damn good
02:29:10 <kuribas> yeah :)
02:29:26 <cdunklau> ORM is, well, it's an ORM. SQLA's is probably the best, but it's still... an ORM
02:29:32 <kuribas> cdunklau: sure, if you pick a defensive subset of sqlalchemy, it's not too bad.
02:29:35 <merijn> SQL >> any ORM/tool for wrapping it >.>
02:29:46 <kuribas> cdunklau: like just use it as a wrapper for SQL
02:29:52 <cdunklau> right
02:30:00 <Netsu> Hello. Is it possible to enable `--enable-nix` for cabal in project configuration
02:30:02 <merijn> kuribas: So how's your library coming along? ;)
02:30:15 <kuribas> merijn: which one? :)
02:30:16 <merijn> Netsu: No clue...did you try? ;)
02:30:27 <merijn> kuribas: You were talking about the SQL quasi quoter thing, no?
02:30:43 <cdunklau> kuribas: ORMs have their place, but i think people are too quick to god-object their models. 
02:30:46 <kuribas> merijn: no quasi quoter, just monoid and applicative
02:31:02 <cdunklau> like, your models should *really not* be your core domain objects
02:31:03 <kuribas> merijn: I am going to code next week, in the holiday :)
02:31:24 <kuribas> cdunklau: indeed, that was the problem
02:31:34 <cdunklau> or even if they are, jesus, don't stuff everything in there!
02:31:35 <Netsu> merijn: can't guess which flag it require in `cabal.project.local`. Tried `nix: True` and `enable-nix: True`, cabal didn't recognize them
02:31:52 <Solonarv> have you tried looking in the documentation?
02:31:57 <kuribas> cdunklau: they had a sort of "static scheme", where each little element was a table.
02:31:59 <cdunklau> kuribas: i found myself writing a from_request method on my User model and was like... hol up
02:32:04 <merijn> Netsu: You can use "cabal configure --enable-nix" to have it generate a cabal.project.local with the commandline config
02:32:05 <cdunklau> this is *wrong*
02:32:12 <merijn> Netsu: (v2-configure if you use <3.0, of course)
02:32:13 <kuribas> cdunklau: the whole thing could have been just a xml value.
02:32:20 <cdunklau> kuribas: heretic!
02:32:47 <merijn> Mind you, I'm not sure v2-build actually has Nix support?
02:33:03 <kuribas> cdunklau: in haskell an ADT of course
02:33:36 <cdunklau> kuribas: yes. i know what that is. use them all the time, i'm the best at ADthings
02:34:06 <cdunklau> kuribas: i was complaining about XML though, to be clear
02:34:20 <kuribas> cdunklau: you don't have much choice in python, no?
02:34:29 <cdunklau> kuribas: huh?
02:34:46 <cdunklau> are you thinking java? :3
02:35:18 <kuribas> cdunklau: you could fake an ADT with lists and strings for tagging the types
02:35:45 <cdunklau> kuribas: oh, i guess you didn't catch my facetiousness
02:35:50 <cdunklau> i have no idea what that is
02:36:05 <kuribas> cdunklau: what is?
02:36:07 <cdunklau> ADT
02:36:14 <kuribas> cdunklau: algebraic datatype
02:36:26 <kuribas> cdunklau: sum of product
02:36:43 <kuribas> cdunklau: or unions and records/tuples, if you like
02:37:11 <tdammers> (tagged unions)
02:37:20 <kuribas> yeah
02:37:20 <cdunklau> kuribas: hm. i think i misunderstood what you meant by "static scheme"
02:37:33 <cdunklau> oh well
02:37:59 <cdunklau> not a big deal, don't want to waste your time with my natterings :)
02:38:01 <kuribas> cdunklau: static scheme like a template for a financial report
02:38:45 <cdunklau> kuribas: oh god they put that in the DB?!
02:38:52 <cdunklau> ew
02:39:34 <kuribas> cdunklau: yeah :)  Then it was too slow (no kidding), and they added even more tables to cache intermediate results
02:39:51 <tdammers> that's how we rolled in the 1990s
02:39:55 <cdunklau> yikes
02:40:00 <tdammers> it's not a crazy approach if you apply it tastefully
02:40:15 <tdammers> the idea being that you capture the constraints of your domain data in the database schema
02:40:18 <cdunklau> did they lose all their DBAs in a tragic gasoline fight accident or something?
02:40:33 <kuribas> tdammers: I'd expect in the 90s or before you'd make a binary format for the static scheme
02:40:48 <tdammers> kuribas: that would have been the 1960s
02:40:52 <cdunklau> kuribas: a *brand* *new* binary format, of course!
02:41:10 <tdammers> SQL databases were well established in 1990s enterprise programming
02:41:24 <tdammers> expensive though
02:42:13 <kuribas> tdammers: but you don't put every little thing in the DB?
02:42:36 <tdammers> yes you do
02:42:45 <tdammers> the database is the single source of truth
02:43:05 <cdunklau> kuribas: that sounds a little like "you don't put every little thing in VSC?"
02:43:21 <kuribas> tdammers: I mean, you can story binary data in blobs
02:43:25 <tdammers> the question is *how* you put it in the database
02:43:38 <kuribas> tdammers: or put XML in blobs :)
02:44:03 <cdunklau> https://www.schemaverse.com/
02:44:09 <tdammers> but the general idea then was to avoid having blobs and stuff that had any dependencies on any particular database client software
02:44:36 <tdammers> although invoice templates would be something that you would not typically express in terms of database tables and columns and rows
02:44:37 <cyan1> acid-state with ixSet was interesting to play with. No sql, haskell types as records stored on disk
02:45:52 <mynameisbrian> Is there anyone here who uses the braces in haskell? I really dont like when languages rely on whitespace 
02:46:11 <EvanR> stored as a series of update log entrties
02:46:24 <boxscape> I think some of the ghc source code might be using braces for do blocks
02:46:24 <EvanR> assuming nothing goes wrong
02:46:32 <boxscape> generally it's very rare though mynameisbrian
02:46:40 <tdammers> indeed, ghc uses them liberally, though not consistently
02:47:06 <tdammers> if your distaste for syntax-relevant whitespace comes from python, I have good news though - it's nowhere near as bad in haskell
02:48:09 <cdunklau> i don't get why people dis on python for that
02:49:00 <cdunklau> i mean, i'm super biased, so i'm not surprised that i don't understand that perspective.. but still
02:49:24 <merijn> Anyone that dislikes language enforced whitespace hasn't ever graded code by students >.>
02:49:29 <kuribas> tdammers: I think it's pretty bad in haskell
02:49:56 <Rembane> I think it's better in Python than in Haskell, but nowadays I generally put everything on the the same line and let Brittany fix it for me.
02:49:59 <boxscape> > (Just . id) 4
02:50:01 <lambdabot>  Just 4
02:50:02 <tdammers> cdunklau: whitespace in python causes diff noise and makes refactoring more difficult
02:50:04 <boxscape> > (Just.id) 4
02:50:04 <merijn> If you want to write code that's not accepted by GHC then I hate you anyway (which doesn't mean that any layout allowed by GHC is good...)
02:50:06 <lambdabot>  error:
02:50:06 <lambdabot>      Not in scope: ‘Just.id’
02:50:06 <lambdabot>      No module named ‘Just’ is imported.
02:50:07 <boxscape> does this count
02:50:25 <merijn> Rembane: boo
02:50:39 <merijn> Rembane: I only do handcrafted artisanal whitespace
02:51:03 <Rembane> merijn: That's good but I can't be bothered.
02:51:05 <cdunklau> tdammers: i don't buy it. it's the same issue with other languages unless you don't care about indentation and are therefore a terrible person
02:51:11 <cdunklau> :)
02:52:00 <kuribas> merijn: isn't that an automatic disqualify?
02:52:02 <cdunklau> boxscape: no, that doesn't count :D
02:52:06 <boxscape> :(
02:52:15 <kuribas> merijn: at least it should compile and typecheck, no?
02:52:51 <tdammers> cdunklau: no, it's not. In C, I can cut a chunk of code from a block and paste it somewhere else, and then my tooling can fix the indentation for me - it never fails, because the indentation can be unambiguously inferred from the code
02:53:05 <merijn> kuribas: Yes, but I'm just saying your problem is "GHC doesn't accept my code because of whitespace restrictions" then you are a terrible person and I don't want your code anywhere near me
02:53:12 <tdammers> cdunklau: you can't do this in Python, which means that moving code around requires more manual diligence
02:53:14 <cdunklau> tdammers: aha, that's fair, i guess
02:53:19 <cdunklau> good point
02:53:27 <tdammers> diff noise is another one
02:53:40 <tdammers> because indentation is relevant, you can't instruct your diffing tools to ignore whitespace
02:53:53 <tdammers> but some trivial refactorings do require whitespace changes
02:54:05 <tdammers> (irrelevant ones, that is)
02:54:19 <tdammers> also, there's `pass`, which leads to slightly misleading diffs
02:54:37 <tdammers> clearing out a block of code is no longer just "n lines deleted", it's "n lines deleted, 1 line added"
02:55:48 <cdunklau> tdammers: that example seems excessively trivial, though. how often do you add a `pass` back in?
02:56:02 <cdunklau> (i'm not disagreeing with your overall point, to be clear)
02:56:20 <tdammers> granted, it doesn't happen a lot, but `pass` *is* a terrible wart
02:56:58 <boxscape> is there a good alternative if you have significant whitespace?
02:57:22 <boxscape> I guess Haskell just does something similar with an empty layout
02:57:36 <boxscape> % :t \case -- like this
02:57:36 <yahb> boxscape: p1 -> p2
02:57:52 <tdammers> hmm, can you even have empty layout?
02:57:53 <cdunklau> tdammers: eh, super rarely necessary though. `class MyError(Exception): pass` is yikes because you forgot the docstring
02:58:06 <boxscape> tdammers isn't that what I entered there?
02:58:12 <cdunklau> (and adding a docstring obviates `pass`)
02:58:17 <boxscape> % :t \case {} -- alternatively 
02:58:17 <yahb> boxscape: p1 -> p2
02:58:25 <tdammers> boxscape: right, yes
02:58:32 <cdunklau> tdammers: oh and `...` is a thing now :D
02:59:05 <tdammers> cdunklau: I think the most terrible thing about python's relevant whitespace is that it's mandatory though
02:59:36 <cdunklau> tdammers: just go write ruby or something :D
02:59:58 <tdammers> cdunklau: I do think that ruby is, in many ways, "python done right". or at least "python with some of the warts avoided"
02:59:58 <cdunklau> but yeah, i can dig it
03:00:19 <tdammers> but fwiw, I'll stick with "Python 5" for the time being
03:00:20 <cdunklau> tdammers: i still can't get over no-paren calls :(
03:00:43 <tdammers> "no-paren calls"? you mean like haskell's function application syntax?
03:01:30 <cdunklau> tdammers: that's different though, haskell is too different for that to be surprising. because *everything* is surprising :)
03:02:01 <tdammers> frankly, once you accept that haskell is *different*, there are few actual surprises
03:02:03 <cdunklau> in my very limited personal experience of course
03:02:10 <cdunklau> tdammers: +1
03:02:36 <phadej> tdammers: heh, I think that Ruby is Perl done wrong (as perl is perfect :)
03:02:52 <yushyin> lol
03:03:03 <cdunklau> tdammers: i expect that the no-paren call thing in ruby quickly becomes not-surprising, and i just haven't used it enough
03:03:32 <cdunklau> like, i think my experience with ruby has been like 90% Vagrantfile, which is of course quite limited
03:03:40 <tdammers> phadej: I think Perl is fascinating, but not in a good way
03:03:47 <cdunklau> lol
03:04:04 <cdunklau> "huh. this code actually does something useful?! incredible!"
03:04:10 * Rembane hands out swords 
03:04:11 <Phyx-> 02:25:53 < Axman6> windows -_- <-- has nothing to do with Windows. 
03:04:12 <tdammers> phadej: it's like when you see an aircraft crash site with dead bodies and debris everywhere, and you simply can't look away
03:04:39 <cdunklau> tdammers: no, that's PHP
03:06:54 <tdammers> cdunklau: PHP is like that, except the aircraft had the engines mounted the wrong way, one pilot was blind and the other a deaf psychopath, the left wing is shaped differently than the right, the navigation equipment doesn't work on a Wednesday, and the landing gear is attached to the roof. But hey, it flies, what's the problem.
03:07:40 <cdunklau> tdammers: "But hey, it flies" -> not anymore!
03:08:32 <tdammers> cdunklau: that's just this one aircraft, all the others are still flying. we'll just add more wings and a third pilot (who is also a deaf blind psychopath, but we'll see about that when this one crashes too)
03:08:41 <cdunklau> tdammers: heh
03:08:52 <cdunklau> tdammers: i must always point this out when PHP comes up https://news-web.php.net/php.internals/70691
03:09:38 <tdammers> sure. but at least Rasmus never intended for PHP to be popular, he even tried to stop it. I don't blame him, he's the victim here.
03:09:47 <cdunklau> oh for sure!
03:11:40 <yushyin> cdunklau: but at least PHP evolved a bit with php7. I used to write a lot of perl and it is now for about 12 years the same old language with the same old quirks.
03:15:16 <phadej> that's imho not a bad thing for stuff I'd use perl for
03:15:21 <kuribas> yushyin: they did perl 5?
03:15:32 <Lycurgus> the people that matter (the end consumers that pay for it) don't care if a thing is done in php or hs
03:15:47 <kuribas> yushyin: or was it 6?
03:16:11 <phadej> Lycurgus: they care that thing work though
03:16:27 <Lycurgus> yes, but it's just as likely to do that in php
03:16:51 <cdunklau> yushyin: i've heard php7 is reasonable, but i doubt i'd willingly write it due to past trauma :D
03:17:26 <Lycurgus> except that it will be far more maintainable due to a vastly larger ready labor pool
03:17:51 <yushyin> kuribas: yeah raku (formerly perl6), but that's not perl anymore and has it own quirks. It is more like a different language in the perl language family. Similar to the many lisp-like languages.
03:18:10 <Lycurgus> is that hs based?
03:18:17 <Lycurgus> (raku)
03:18:32 <yushyin> no
03:18:35 <Lycurgus> perl6 was supposed to be at one point
03:18:54 <phadej> good programmer can write working software in many languages, but I wouldn't choose PHP if I had choice. With a sample size of 1 (= me), haskell versions is definitely more likely to work (and be maintainable)
03:19:02 <Lycurgus> before the zenith of practical hs in fact
03:19:05 <yushyin> Lycurgus: pugs was perl6 compiler
03:19:07 <phadej> (for the record, I have been paid for writing PHP)
03:19:14 <Lycurgus> yushyin, ah
03:20:07 <Lycurgus> phadej, yeah well ur not pointy headed capitalist boss
03:20:56 <Lycurgus> not that hs in lacking in those
03:21:31 <phadej> I wonder if capitalist bosses care about technology that much either
03:21:51 <Lycurgus> only insofar as managing labor is concerned
03:21:52 <phadej> except if it's their technology with license fees
03:22:31 <Lycurgus> if you can corral dupes on their idiotic enthusiasms, that's a good thing bottom line wise
03:24:04 <Lycurgus> or bizarre but commonplace and widely held attitudes such as that wage labor is done for the "fun" of the laborers
03:35:05 <Netsu> merijn: `cabal --enable-nix new-configure` didn't help. See nothing related to nix in project configuration :(
03:35:43 <Netsu> And yeah, can't find nothing related in docs
03:36:02 <Netsu> kinda weird: why can't add nix by default to setup
03:36:26 <Lycurgus> why would you think you necessarily could?
03:37:02 <Lycurgus> do you think nix is like a default or something? 
03:37:43 <Lycurgus> it's present on a best effort basis, with stuff expected to work on regular LSB systems
03:39:40 <Netsu> If it can use nix by passing the key `--enable-nix` I expet that should be able to store such behaviour as default, why not?
03:39:46 <Lycurgus> moreover, nix assumes much more than regular LSB that you are actively managing the env urself
03:40:12 <Lycurgus> including correcting deficiencies in various ports
03:40:41 <phadej> Netsu: it cannot use
03:40:53 <phadej> the flag is unfortunately accepted
03:41:04 <phadej> as a leftover from `v1-configure`
03:41:15 <Netsu> Lycurgus: all I need from `nix` is ghc and cabal-install itself to avoid OS be polluted by various binaries of conflicted versions for several projects. And for binary dependencies as well, for sure
03:41:58 <Lycurgus> Netsu, from my perspective that's a concocted concern
03:42:48 <Netsu> I'm ok, if cabal would manage haskell packages by itself (by it would be convenient if it could reuse already installed ones by nix, e.g. some development handy tools and libs not related to project itself)
03:43:22 <Lycurgus> better addressed by use of more facile and workable things like docker these days as well as being less of an issue than it was when nix started 15 ya
03:43:43 <Lycurgus> due to increased stability and updatability of major LSB distros
03:43:59 <merijn> I think Nix is (conceptually) much better than docker, tbh
03:44:12 <Lycurgus> yeah conceptually
03:44:36 <Lycurgus> except for the island effect
03:44:50 <Netsu> ough, docker such a big boilerplate itself, and much less elegant in configuration
03:45:05 <Lycurgus> elegance is not free
03:45:31 <Netsu> but in long term pay back =P
03:45:50 <phadej> bottom line, cabal-install v2-build doesn't really pollute the system, nor run into conflicts due using it in different projects
03:46:01 <phadej> and for managing c-deps or so, you can still run nix-shell
03:46:16 <phadej> so I don't see what `--enable-nix` would even do in v2-build
03:47:18 <Netsu> yeah, it is not clear for me what exactly integration it provide. I guess, it use binaries from shell.nix
03:47:34 <phadej> it *did* stuff for v1-build
03:47:35 <Lycurgus> if you are at the point of saying "all i want ..." or "i just need ..." the jedi advice is to go home and think about ur career
03:47:40 <phadej> v2- is completely different
03:48:18 <phadej> yet, to my understanding v1 nix stuff wasn't very polished part of cabal either
03:49:34 <phadej> I'd recommend you to run nix-shell yourself, and then run cabal commands inside
03:50:22 <phadej> (nix-shell on each cabal command would be super-slow with any shell.nix which actually does something)
03:50:25 <__monty__> Ironically nix is an excellent way to build docker images : )
03:50:37 <Lycurgus> :)
03:51:00 <Netsu> already do, because there's no cabal outside of it. So all `--enable-nix` do for this moment is let `cabal` wrap own commands into `nix-shell`, is it?
03:51:43 <__monty__> Netsu: Forget about --enable-nix, it's no longer relevant with the v2-*/new-*/non v1-* commands.
03:51:59 <phadej> Netsu: again, it does nothing
03:52:05 <phadej> I just speculating what it could do
03:53:00 <Netsu> __monty__: already did it for deploy. There are several workflow for nix, and there's nixops. But I don't care about ops's pain, so care about own developer's worflow, and docker is clumpsy overkill
03:53:08 <Lycurgus> also, anciently, cabal is cabal-install and not a pkg mgr
03:53:36 <__monty__> Netsu: I wouldn't use docker over nix either.
03:54:01 <Lycurgus> *is not cabal-install
03:54:30 <__monty__> Conventionally cabal *is* cabal-install and Cabal is cabal-the-library.
03:55:31 <Lycurgus> that's why I said "anciently"
03:55:44 <Netsu> welp, thanks for advice and explanations
03:55:53 <Lycurgus> stack otoh is a pkg mgr
03:56:07 <phadej> I opened the issue: https://github.com/haskell/cabal/issues/6444
03:57:05 <Netsu> Lycurgus: is there a reason to use stack yet, after the new cabal appearance?
03:58:59 <__monty__> Not if you're using nix imo.
03:59:16 <phadej> stack and nix is very weird combo
03:59:55 <Lycurgus> Netsu, I presume so.
04:01:15 <Lycurgus> i used nix/nixos in the '09-12 timeframe
04:02:08 <Netsu> __monty__: not for development project haskell dependencies, actually (because of required dependency list and versions maintenance)
04:03:17 <Solonarv> well, none of the haskell build systems will save you from having to list your dependencies somewhere
04:04:15 <Solonarv> and their versions should probably also be listed somewhere
04:04:18 <Netsu> but nice to do it just once)
04:04:48 <Solonarv> hm, you shouldn't need to duplicate them
04:04:59 <Solonarv> ...unless you are using stack with packages that aren't in the snapshot :P
04:07:48 <merijn> Everyone should just give me access to their repos and hackage so I can just merge and release my own PRs instead of prodding people constantly >.>
04:10:43 <boxscape> just make your own fork of all of hackage
04:11:08 <merijn> boxscape: ;)
04:11:42 <merijn> boxscape: I'm using my own forks right now with cabal.project, but I'd like to get rid of those and depend on the hackage version instead >.>
04:12:02 <boxscape> hm, fair
04:18:50 <AWizzArd> I remember that there _is_ such a function, but forgot its name... I can pass to `foo` a Foldable and a number `n`, and foo will return the nth element.
04:19:27 <Solonarv> foo xs n = Data.Foldable.toList xs !! n -- ;)
04:19:38 <AWizzArd> Solonarv: yes, I think that was it!
04:19:50 <Solonarv> be wary:
04:19:55 <Solonarv> > [1,2,3] !! 5
04:19:58 <lambdabot>  *Exception: Prelude.!!: index too large
04:20:11 <merijn> Easily solved
04:20:37 <merijn> foo xs n = listToMaybe . drop n $ Data.Foldable.toList xs
04:21:12 * Solonarv thinks listToMaybe is an annoying name
04:26:39 <int-e> what else would it be? takeOneAsMaybe
04:26:41 <int-e> ?
04:26:47 <boxscape> safeHead
04:26:49 <hpc> unsafeCoerce
04:27:19 <boxscape> % Unsafe.Coerce.unsafeCoerce [1..(5 :: Int)] :: Maybe Int
04:27:19 <yahb> boxscape: Just 1
04:27:31 <boxscape> % Unsafe.Coerce.unsafeCoerce ([] :: [Int]) :: Maybe Int
04:27:31 <yahb> boxscape: Nothing
04:27:33 <boxscape> neat
04:27:37 <int-e> hpc: that's all sorts of terrible
04:27:45 <hpc> :D
04:28:02 <int-e> hpc: But perhaps worst of all, the result will hold on to the tail during GC.
04:28:04 <Solonarv> hmm...
04:28:20 <boxscape> it relies on the order in which the constructors are written in the data definition, right?
04:28:21 <Solonarv> % Unsafe.Coerce.unsafeCoerce (Just (5 :: Int)) :: [Int]
04:28:21 <yahb> Solonarv: [5]
04:28:30 <Solonarv> huh.
04:28:31 <int-e> boxscape: sure
04:28:39 <dibblego> @type (^? _head)
04:28:41 <lambdabot> Cons s s a a => s -> Maybe a
04:28:56 <int-e> Solonarv: That seems lucky.
04:29:06 <Solonarv> yes, I was surprised
04:29:12 <Solonarv> I expected it to crash and burn somehow
04:30:21 <Solonarv> % unsafeCoerce (1 @Int, 2 @Int) :: (Int, Int, Int)
04:30:21 <yahb> Solonarv: ; <interactive>:100:15: error:; * Cannot apply expression of type `p0'; to a visible type argument `Int'; * In the expression: 1 @Int; In the first argument of `unsafeCoerce', namely `(1 @Int, 2 @Int)'; In the expression: unsafeCoerce (1 @Int, 2 @Int) :: (Int, Int, Int)
04:30:32 <Solonarv> % unsafeCoerce (1 :: Int, 2 :: Int) :: (Int, Int, Int)
04:30:32 <yahb> Solonarv: (1,2,[Segmentation fault]
04:30:32 <boxscape> % ((Unsafe.Coerce.unsafeCoerce id) :: a -> b) 64 :: Char
04:30:33 <yahb> boxscape: '@'
04:30:40 <Solonarv> aha! there we go ;)
04:31:15 <Solonarv> boxscape: I'm pretty sure 'unsafeCoerce id' is just 'unsafeCoerce' again
04:31:25 <boxscape> yeah looks like it
04:31:43 <int-e> % unsafeCoerce id :: Int
04:31:43 <Solonarv> after all unsafeCoerce *is* id, operationally
04:31:43 <yahb> int-e: 35909159806822400
04:31:56 <Solonarv> so operationally, you wrote 'id id'
04:32:11 <phadej> % unsafeCoerce id ('x' :: Char) :: Int
04:32:11 <yahb> phadej: 120
04:32:12 <Solonarv> s/operationally/after erasing types/
04:32:31 <Solonarv> % unsafeCoerce @_ @Int 'x'
04:32:31 <yahb> Solonarv: 120
04:32:49 <int-e> (I agree if you use `unsafeCoerce id` as a function)
04:32:59 <Solonarv> int-e: yes, I should have specified
04:33:05 <phadej> % ord 'x'
04:33:05 <yahb> phadej: 120
04:33:12 <phadej> unsafeCoerce is very efficient ord?
04:33:15 <boxscape> % unsafeCoerce id :: Int
04:33:15 <yahb> boxscape: 35909159806822400
04:33:26 <boxscape> oh you already typed that
04:33:59 <boxscape> efficient ord *and* efficient 
04:34:01 <boxscape> chr
04:34:10 <Solonarv> fastOrd :: Char -> Int; fastOrd = unsafeCoerce; {-# INLINE fastOrd #-}
04:34:42 <phadej> @src ord
04:34:42 <lambdabot> Source not found.
04:34:55 <boxscape> ord (C# c#) = I# (ord# c#)
04:35:33 <phadej> a primitive ord#!
04:35:44 <Solonarv> pfft, cheaters
04:35:57 <boxscape> (and ord# = ord#, unsurprisingly)
04:36:20 <phadej> I guess ord# can be better constant-folded than unsafeCoerce :)
04:36:26 * Solonarv was half expecting ord# c# = case ord (C# c#) of I# i# -> i#
04:36:29 <boxscape> didn't these primitives use to be defined as let x = x in x at some point?
04:37:18 <Solonarv> well, Char# is probably not equal to Int# on every machine
04:37:28 <Solonarv> that sounds like it would be architecture dependent
04:38:28 <username> hi
04:38:41 <boxscape> hi
04:38:46 <username> wow
04:39:12 <username> this is first time for me
04:39:33 <boxscape> I'm impressed that you managed to get the username "username"
04:39:50 <username> how to see people active in here?
04:40:27 <username> yea i used this username "username" because when i install ubuntu i cant type any word
04:40:39 <username> so i just copied haha
04:40:48 <boxscape> Depending on the client you using there may be various ways to see how many people are *in this channel*, but really the only way to see how many people are active is to see how many people are sending messages
04:41:01 <boxscape> s/you/you're
04:41:04 <username> ouh oke
04:41:53 <username> many people just joined but not even they join this chatting
04:42:06 <nil> i was just wondering, why doesn't GHC optimise (a ++ b) ++ c to a ++ (b ++ c)?
04:42:16 <nil> strictness issues maybe?
04:42:32 <merijn> nil: WHich logic would let it do so?
04:42:39 <int-e> boxscape: there's this, https://gitlab.haskell.org/ghc/ghc/blob/master/utils/genprimopcode/Main.hs#L354 (actually line 357, but at least here the anchored line is hidden behind the top bar)
04:42:56 <nil> merijn: i don't know much about ghc's internals, but i know it has rewriting rules
04:43:02 <nil> i don't know how powerful they are
04:43:13 <boxscape> int-e hm, thanks
04:43:20 <nil> (i'm talking about the RULES pragma)
04:43:33 <username> ouh i see
04:45:56 <nil> merijn: perhaps something like {-# RULES "rassoc (++)" forall a b c. (a ++ b) ++ c = a ++ (b ++ c) #-} ? is this outside the range of what rules allow?
04:47:13 <merijn> What's the goal behind this line of questioning?
04:47:26 <nil> "i was just wondering"
04:47:43 <Solonarv> nil: oh! I have a partial answer
04:48:29 <nil> i'll take it
04:48:45 <Solonarv> (a ++ b) ++ c is especially bad when deeply nested, as might be generated by e.g `foldl ( ... ++ ...) [] xs`
04:49:05 <kuribas> nil: I think you want DList
04:49:17 <Solonarv> but if it appears in this form, there is no `(a ++ b) ++ c` in the source, so a rewrite rule would have no effect!
04:49:22 <kuribas> https://hackage.haskell.org/package/dlist
04:49:28 <nil> kuribas: i'm aware of that
04:50:09 <nil> still, i think it shouldn't be the programmer's concern to know that (++) is most efficient when used right-associatively. at least in an ideal world, i guess
04:51:36 <boxscape> In an ideal world you would just specify that you need some sort of collection and the compiler would find you the one that's best suited to whatever you're doing with it
04:51:37 <nil> Solonarv: well, after evaluating the foldl's, you're left with a thunk that looks like (..(z ++ x0) ++ x1) ++ ..) ++ xn), right?
04:52:07 <nil> does ghc only perform rule expansion on the original source code, not on partially evaluated thunks?
04:52:08 <Solonarv> yes - but at the point where you have a thunk, you are running your compiled program
04:52:19 <nil> hm
04:52:19 <Solonarv> rewrite rules fire *during* compilation
04:52:46 <boxscape> so it would only work if the compiler unrolled some of those foldl recursive calls?
04:52:51 <kuribas> nil: yes, it is the programmers concern
04:53:02 <Solonarv> yes, it would work if GHC inlines and unrolled foldl
04:53:15 <Solonarv> but GHC does not inline recursive functions into themselves, for obvious reasons
04:53:48 <nil> i see
04:54:39 <bitmapper> my god, i just tried to join #haskal
04:54:41 <nil> kuribas: i said "shouldn't", not "isn't"
04:54:50 <Solonarv> to answer your other question: rewrite rules fire on GHC Core, which is an intermediate language that can be summed up as "haskell but with all the syntax sugar stripped away"
04:55:02 <nil> i've heard about that - the 9 constructors
04:55:19 <int-e> nil: are you sure it's not doing that? It's a bit convoluted, but the rewrite rules in GHC.Base will turn (xs ++ ys) ++ zs into xs ++ (ys ++ zs), along these lines: https://paste.ubuntu.com/p/Tj5mCWXhq5/
04:56:14 <Solonarv> ah, I figured the foldr/build fusion would take care of this
04:56:23 <nil> ah, so there are already rules for that. but the point Solonarv makes is that those rules are only used at compile time, so not useful if you're generating a left-associative (++) thunk at runtime
04:56:26 <int-e> nil: The left fold situation is different, of course.
04:56:41 <nil> my question was about runtime; i understand it's not possible now
04:56:54 <int-e> the runtime version of this is to use difference lists, I suppose...
04:57:48 <int-e> (which carry overhead in the form of extra thunks, but they do offer constant time concatenation)
04:59:00 <nil> yeah
04:59:26 <siers> barrucadu, can irc-client/irc-conduit do SASL?
05:07:01 <kuribas> nil: yes it is possible.  That's what dlist does.
05:07:24 <kuribas> nil: it defers the concatenation, so it can be done from right to left
05:08:51 <nil> kuribas: yes, i mean possible in a transparent way for the user
05:09:08 <kuribas> nil: dlist is transparant
05:09:19 <nil> ugh
05:09:36 <kuribas> you use mappend on the dlist
05:09:47 <kuribas> and convert it to a list when ready
05:11:13 <kuribas> nil: it cannot be more transparent then that
05:11:35 <kuribas> nil: because there is no way for the application to "magically" know when you want to convert it to a list
05:13:07 <kuribas> nil: another solution is just to make sure you append from the left
05:15:38 * nil nods
05:16:24 <boxscape> I think in principle there could be a way, it would just require a compiler that's much more sophisticated in some ways
05:17:36 <kuribas> the mythical "sufficiently smart compiler"
05:18:38 <boxscape> i.e. as long as it's something a human being can optimize, it should be possible to do for a compiler as well, in principle
05:19:25 <kuribas> it's a solution for a non-problem
05:24:35 <bitmapper> the great matrix exodus
05:25:26 <lortabac> kuribas: your argument could be applied to any optimization performed by the compiler. What makes this particular one different from the others?
05:25:28 <maerwald> the problem is: if the compiler is smart in optimising, the programmer has to be smart in picking the right data structure that is most optimised by the compiler in context X... requiring him to basically understand what the compiler does anyway
05:26:43 <Solonarv> bitmapper: matrexodus
05:27:06 <kuribas> lortabac: what argument?
05:27:40 <lortabac> kuribas: that's it's a non-problem because you can solve it with dlist
05:28:27 <lortabac> isn't it like saying "strictness analysis" is a non-problem because you can use bang patterns?
05:29:21 <boxscape> maerwald the trick is to get the compiler to pick the data structure as well
05:30:58 <maerwald> boxscape: well, haven't seen that in haskell ;(
05:31:10 <boxscape> yeah, me neither :/
05:37:56 <kuribas> lortabac: left append is inherently quadratic.  You cannot change that fact.  In some cases you could rearrange the operations, if they are known at compile time.
05:38:05 <kuribas> lortabac: or at runtime using dlist
05:38:45 <kuribas> relying on compiler magic to get the right complexity is dangerous
05:38:53 <kuribas> because you don't know if it would work or not
05:39:04 <kuribas> and DList is easy to use
05:42:36 <kuribas> So instead of making really complicated changes in the compiler which you don't know will work, you use the slight overhead of wrapping and unwrapping a DList.
05:43:37 <lortabac> ok, it's hard or maybe impossible, but personally I wouldn't call it a non-problem
05:47:49 <lortabac> dlists still require you to think about list concatenation associativity, while ideally one would not have to think about that at all
05:55:27 <phadej> the problem is using wrong datastrucutre for a problem
05:55:39 <phadej> lists is wrong if you do a lot of arbitrary concatenation 
05:55:54 <phadej> it's not like concatenating Vector is any more performant (it also copies stuff)
05:56:45 <phadej> and I haven't any language pick up data structures for a programmer, it feels to be very hard problem
05:57:04 <phadej> seen*
05:57:11 <maerwald> you could have something like "ListLike" and describe the minimal API you want and the compiler picks for you :P
05:58:10 <Solonarv> vector's stream fusion stuff actually does something sort of like this
05:58:22 <phadej> but it might or might not work
05:58:30 <phadej> there's no hard guarantee
06:07:12 <kuribas> knowing complexity should be basic knowledge for every professional programmer
06:07:34 <kuribas> Solonarv: but the thing is that if it doesn't work you're ok with the performance
06:07:34 <statusfailed> What's a fast way to construct a bitmask of N bits set to 1 with Data.Bits?
06:07:43 <statusfailed> I can't think of a way that doesn't also use Num (e.g., 2^n - 1)
06:07:58 <boxscape> kuribas other things were basic knowledge for programmers in the past but are now handled by compilers
06:07:59 <kuribas> Solonarv: or you inspect core and write loops if it doesn't :)
06:09:00 <kuribas> the compiler optimizations are linear optimisations
06:09:10 <kuribas> as it should be
06:09:27 <kuribas> or you have lazyness garanteeing you O(1) where strict is O(n)
06:10:25 <kuribas> boxscape: that's not relevant, what's relevant is that the programmer knows the semantics of what he writes.
06:10:28 <kuribas> including complexity
06:15:34 <statusfailed> nvm, complement + shift does the job!
06:16:08 <boxscape> complexity seems orthogonal to semantics
06:16:54 <haskeldjiq> hey guys
06:17:06 <haskeldjiq> any way to pattern match on a list regardless of the order of the arguments
06:17:41 <haskeldjiq> it smells a bit of ViewPatterns but I'm not sure
06:17:50 <haskeldjiq> is there an elegant way to do it
06:18:15 <kuribas> haskeldjiq: what do you mean?
06:18:40 <haskeldjiq> kuribas: pattern match on a list without caring about the order of the elements
06:18:52 <haskeldjiq> kuribas: e.g. pattern match on a list that contains 2,3 and 4
06:19:33 <haskeldjiq> kuribas: or pattern match on a list that contains just 2,3 and 4 e.g. [2,3,4] [3,4,2] [4,3,2] would all be valid
06:19:56 <boxscape> f xs | sort xs == [2,3,4] = ...
06:20:21 <kuribas> haskeldjiq: maybe you want Data.Set ?
06:20:26 <boxscape> admittedly requires Ord and Eq
06:20:38 <haskeldjiq> nah I can't use Ord or Eq
06:20:46 <haskeldjiq> I can actually but it won't make sense
06:20:55 <haskeldjiq> I have a data type for a predicate
06:20:57 <Solonarv> you can't use Eq? then I assert that it cannot be done
06:21:03 <Clint> case xs of { (2:3:4:[]) -> True; (3:4:2:[]) -> True; (4:3:2:[]) -> True } ?
06:21:03 <Solonarv> but, do keep going
06:21:07 <Solonarv> perhaps I am wrong
06:21:08 <haskeldjiq> lol
06:21:25 <haskeldjiq> you can freely disregard what I said but glad that I got your interest
06:24:30 <kuribas> haskeldjiq: HashSet then?
06:24:52 <haskeldjiq> kuribas: how would you pattern match on it
06:25:18 <haskeldjiq> kuribas: the way I do that when I have to is with ViewPatterns and toList, is there a smarter order-independent way?
06:25:27 <Clint> why do you want to pattern match on it at all?
06:25:41 <haskeldjiq> it's itching
06:26:24 <haskeldjiq> you know, we do Haskell, so spending an hour trying to get rid of a few lines of code is acceptable
06:27:09 <dmwit> HashSet also needs Eq
06:27:35 <haskeldjiq> of course I can use Eq guys, sorry for the mistake
06:27:46 <MarcelineVQ> if [2,3,4] [3,4,2] [4,3,2] are all valid then why isn't foo (a:b:c:_) = ... enough?
06:27:55 <haskeldjiq> just didn't want to use Ord
06:28:03 <haskeldjiq> MarcelineVQ: because I want to extract values out of the data types
06:28:11 <haskeldjiq> MarcelineVQ: I'm not really using ints
06:28:12 <dmwit> *Why* don't you want to use Ord?
06:28:19 <phadej> HashSet doesn't give you any order, btw
06:28:26 <phadej> so you still need to check all permutations
06:28:27 <haskeldjiq> I know, but this is about pattern matching
06:28:39 <haskeldjiq> yes, I'm hoping for a way to not have to check them
06:28:44 <phadej> use sort
06:28:56 <phadej> that'sthe simplest way
06:29:04 <haskeldjiq> seems like it
06:29:14 <boxscape> f (sort -> [2,3,4]) = ...?
06:29:40 <haskeldjiq> yes, with numbers it could work but for my scenario I'll just leave it as is
06:29:57 <haskeldjiq> dmwit: because the data type I have is an abstraction for a predicate, and I don't really feel you should be able to order predicates
06:30:06 <haskeldjiq> thank you guys
06:31:27 <phadej> I don't understand the problem, "pattern match on a list regardless of the order of the arguments", but if you don't have any notion of order, how would you say which one should before each other
06:31:40 <haskeldjiq> precisely because there's no notion of order
06:31:49 <haskeldjiq> is why I want to do this
06:31:51 <phadej> i.e. f [x,y,z] is a pattern match regardless of the order of the arguments
06:32:04 <haskeldjiq> yes, but I want to also extract values out of these
06:32:07 <haskeldjiq> sorry, I wasn't clear enough
06:32:10 <haskeldjiq> the real situation is I have
06:32:31 <haskeldjiq> data Predicate = Predicate { predicateType... predicateValue }
06:32:41 <kuribas> haskeldjiq: fromList [1, 2, 3] `isSubsetOf` set
06:32:50 <haskeldjiq> and a function [Predicate Something] -> m [Something]
06:33:00 <haskeldjiq> so I would like to be able to do
06:33:26 <haskeldjiq> function (Predicate.. value1:Predicate... value2:Predicate... value3:_) =
06:33:38 <phadej> fun (sortOn predicateValue -> [x,y,z]) = ?
06:34:05 <haskeldjiq> yeah that may work but it kind of ruins the elegance
06:34:15 <dmwit> What's stopping you from doing exactly what you wrote?
06:34:31 <haskeldjiq> if the order of the predicates
06:34:34 <haskeldjiq> is different
06:34:39 <haskeldjiq> it won't match
06:34:44 <dmwit> ...what?
06:34:47 <haskeldjiq> the data type is a bit more complicated
06:34:49 <haskeldjiq> than what I wrote
06:34:57 <evelyn> you should post the whole thing then
06:34:59 <dmwit> I think you had better cook up a proper MCVE.
06:35:00 <phadej> indeed
06:35:02 <phadej> evelyn: +1
06:35:16 <haskeldjiq> anyway I feel uncomfortable enough already :D
06:35:19 <haskeldjiq> thank you guys
06:35:25 <evelyn> we're all friends here...
06:35:57 <haskeldjiq> yes but I don't want to waste your time with something that doesn't really provide value
06:36:07 <haskeldjiq> it's just a more convenient syntax
06:36:42 <dmwit> Oh heck, making fun of other people's code in my head while I try to help them *is* the value I come here to be provided with.
06:37:07 <dmwit> Don't worry, all my judgment will be secret, you don't have to know.
06:37:37 <Solonarv> I will publicly judge you if you ask for help but do not provide code
06:37:45 <Solonarv> there! now you have to show us your code! :P
06:37:59 <haskeldjiq> hahahaha alright
06:38:05 <haskeldjiq> let me conjure up a pastebin
06:40:24 <haskeldjiq> https://pastebin.com/Q0i8wSgG
06:41:16 <yasar> If I get a file handle using a Windows API function, can I write to that file without using FFI?
06:42:15 <yasar> I am thinking of using this library: https://github.com/haskell/win32
06:42:36 <dmwit> haskeldjiq: Perhaps something like `querySomething ps = case ([v | Predicate _ SomeField1 v <- ps], [v | Predicate _ SomeField2 v <- ps]) of (v1:_, v2:_) -> ...`.
06:43:13 <haskeldjiq> dmwit: no idea how and why that works but I'll try
06:43:22 <haskeldjiq> dmwit: seems much better than what I have currently
06:43:47 <haskeldjiq> dmwit: oh yeah I got it, very clever
06:46:44 <Solonarv> yasar: well, you won't have to use FFI directly, but you will have to use functions from win32
06:46:57 <Solonarv> which is basically just a paper-thin wrapper on top of the FFI
06:47:01 <haskeldjiq> dmwit: that looks nice, and it compiles
06:47:08 <haskeldjiq> dmwit: permission granted to make fun of my code
06:47:20 <Solonarv> is there a reason you are using win32 specifically?
06:49:08 <yasar> Solonarv, I am currently exploring the possibilities. What I want to achive is that, "Create New File (only if it doesnt already exist) with Write Lock" -> Write to It
06:49:42 <yasar> I will use it to achive inter process synchronization
06:49:52 <Solonarv> okay, you *definitely* don't need to reach into the guts of win32 for this
06:50:20 <Solonarv> you can just withFile WriteMode $ \handle -> write to handle here
06:50:34 <Solonarv> (or AppendMode instead, depending on what the goal is)
06:51:48 <yasar> I am assuming that WriteMode would overwrite the file
06:53:52 <yasar> I need "open if not exist and lock it" as an atomic operation, which win32 api provides
06:54:18 <yasar> I think linux has similiar functionality, but I can't test it right now
06:54:46 <Solonarv> both WriteMode and AppendMode should simply fail if the file is already opened by another process
06:54:50 <Solonarv> that is what you want, right?
06:55:14 <Solonarv> (they will also create it if it doesn't exist yet)
06:55:49 <Solonarv> remember, the higher-level file functions are built on top of the low-level OS operations
06:56:46 <yasar> It is not exactly what I want. I want opening the function to fail, if it exist already, even if it is not currently open by another process
06:56:56 <yasar> opening the file*
06:57:12 <lavalike> @hoogle a -> f b -> f (a -> b)
06:57:13 <lambdabot> No results found
06:57:19 <lavalike> :/
06:58:05 <dminuoso_> Im using STM to implement mutexes sort of, but for reasons that are beyond me, this code is failing to unlock resource
06:58:07 <merijn> lavalike: That function isn't possible
06:58:09 <dminuoso_> https://gist.github.com/dminuoso/b03398c00a5b9353e724831c57f097b5
06:58:17 <dminuoso_> Is there something obvious Im doing wrong in this trivial STM code?
06:58:20 <merijn> lavalike: At least not in general
06:58:36 <lavalike> Monad f in my case
06:58:56 <haskeldjiq> lavalike: what would the function do
06:58:56 <Solonarv> yasar: ah, I see
06:59:35 <Solonarv> well, it's *possible*, but it isn't useful
06:59:48 <Solonarv> :t \_ fb -> const <$> fb
06:59:49 <lambdabot> Functor f => p -> f a -> f (b -> a)
07:01:24 <lavalike> was trying to squish some Justs
07:01:55 <yasar> Solonarv maybe I can open the file in append Mode and check if it is empty to figure out if it was created new
07:03:36 <lavalike> :t \famb ma -> ma >>= traverse famb
07:03:39 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> m (t a) -> m (t b)
07:03:53 <lavalike> @hoogle (a -> f b) -> f (a -> b)
07:03:53 <lambdabot> Data.Searchable assemble :: forall b f . (Finite a, Applicative f) => (a -> f b) -> f (a -> b)
07:04:50 <lavalike> that's the pattern I was wondering had a name
07:04:54 <MarcelineVQ> Finite? ​That's playing dirty :>
07:17:43 <dminuoso_> https://hackage.haskell.org/package/unliftio-0.2.12/docs/UnliftIO-Exception.html lists "extra async safety" on some combinators like bracket, does anyone know what they mean by that?
07:18:59 <AWizzArd> In `containers` there is a   fromSet :: (k -> a) -> Set k -> Map k a   – but is there also something for   (v -> (v -> k) -> k) -> Set v -> Map k v     ?
07:19:20 <MarcelineVQ> dminuoso_: regular bracket doens't use an uninterruptable mask
07:19:30 <AWizzArd> That is I have a Set of structs and want to make a map of structs, with keys that are (unique) elements of the struct values.
07:19:50 <AWizzArd> Or is M.foldr my best take here?
07:19:56 <MarcelineVQ> dminuoso_: https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Exception.html#g:13
07:20:37 <dminuoso_> MarcelineVQ: I take it you mean uninterruptableMask in the prepare/finalize parts?
07:20:48 <merijn> dminuoso_: Only the finalizer
07:21:07 <merijn> dminuoso_: See the million email long discussion on libraries@ I started in 2013 that never led anywhere
07:21:19 <dminuoso_> merijn: Got a link handy?
07:21:46 <merijn> Not really
07:26:37 <geekosaur> short version: you are apparently supposed to use the safe-exceptions package for bracket to actually do what it claims to do, it can leak if an exception occurs during the finalizer otherwise.
07:27:17 <merijn> Short version: I campaigned to fix bracket, but lots of people whined about theoretical breakage
07:27:58 <Rembane> Had the theoretical breakage something to do with laziness?
07:28:02 * geekosaur keeps being astonished by the incorrect behaviors the haskell community is willing to accept.
07:28:02 <merijn> No
07:28:23 <geekosaur> no, someone might somehow rely on finalizers being interruptible
07:28:31 <merijn> Theoretical breakage is "someone might intentionally use/rely on the fact that blocking operations in cleanup are interruptible"
07:28:34 <merijn> I say "fuck those people"
07:28:36 <phadej> merijn: does bracket from exceptions is also broken?
07:28:52 <phadej> as in genericBracket derived bracket
07:29:41 <Rembane> Got it. 
07:29:42 * geekosaur once thought of doing possibly mission critical stuff with haskell
07:29:56 <Rembane> And then you thought better of it?
07:30:00 <merijn> phadej: Yes
07:30:18 <geekosaur> not sure that's wise at this point, this is like the second "hi, this is provably wrong" "but someone might rely on the wrongness!"
07:30:43 <merijn> geekosaur: It's rather unlikely to break, though
07:30:51 <phadej> merijn: why it's not fixed, there were going back and forward with it recently? or was it more that "people weren't aware"
07:31:04 <phadej> because exceptions is going to be GHC boot lib
07:31:09 <merijn> geekosaur: I think in the end there was some form of consensus in favour of maybe fixing it
07:31:31 <merijn> But neither I nor Peaker could be bothered to fight the actual patch through, since we were both busy
07:31:32 <dminuoso_> geekosaur: The bane of technology. Consider it took 40 years for Intel to remove things like the A20 gate?
07:31:37 <phadej> and therefore one have to deal with broken thing for many years, or deal with boot library updates
07:31:43 <MarcelineVQ> the mask, the
07:32:23 <merijn> phadej: Well, the current broken one is in base, so...
07:32:55 <phadej> merijn: well, if you use one from exceptions which wouldn't be broken than it would "not so in your face"
07:33:00 <phadej> be*
07:33:04 <merijn> phadej: Surre
07:33:16 <merijn> Realistically someone should just pick up my crusade and just fix it
07:33:28 <yasar> Intel removed A20 gate?
07:33:28 <merijn> Until my thesis is done I can't be bothered
07:33:41 <phadej> it would be a bit easier indeed, if default answer for breaking changes would be "write a patch" and not "it will break everyone"
07:33:57 <phadej> because "everyone doesn't need to upgrade"
07:34:14 <merijn> It's even more nonsense
07:34:35 <merijn> Because 1) almost no one knows how this subtle corner case works, 2) everyone who does know knows better than to do something stupid like that
07:34:44 <merijn> This is not something you happen to accidentally rely on
07:35:25 <phadej> (you can argue about making the patch itself better, but not turning the idea off compeltely; that's demotivating ... as we can see)
07:36:15 <dminuoso_> yasar: Yes. It was this year I believe?
07:36:16 <phadej> I'm quite sure that the behaviour is unspecified, i.e. there isn't a test in ghc testsuite (or exceptions) which would break if the change is made
07:36:31 <phadej> so if someone relies on it now, it relies on implementation details
07:36:45 <dminuoso_> yasar: I mean in the grand scheme of things its highly irrelevant. But I suppose in case of a CPU vendor its more important than ever to ensure compatibility no matter what you do.
07:36:55 <phadej> so it's in a sense their fault too, to not doing anything towards at least documenting that behaviour properly
07:37:06 <merijn> Anyway, the patch is trivial to write
07:37:33 <merijn> So if someone feels motivated/outraged enough to shepherd it through would be a hero!
07:38:07 <merijn> Well "trivial"
07:38:09 <phadej> i used all my hero points for this year :(
07:38:12 <merijn> It requires some thinking
07:38:17 <merijn> phadej: Same
07:38:30 <Solonarv> fortunately the next year is only two weeks away! ;)
07:41:42 <Taneb> Hmm, in repa, why is "fromList" not exported by Data.Array.Repa?
07:43:20 <maerwald> geekosaur: oh, did you see the "IsString ByteString instance truncates unicode" bug report? :)
07:43:34 <geekosaur> ...
07:43:40 <maerwald> :D
07:44:15 <maerwald> now they want to change it (maybe), but what if someone already relies on it, hahaha
07:44:18 <glittershark> How do people usually pronounce `(***)` from control.arrow?
07:44:37 <glittershark> I'm implementing the equivalent function in another language and want to give it a name
07:45:04 <z0_> glittershark: i pronounce it with a silent 'h'
07:45:13 <Putonlalla> I'd say "split", glittershark.
07:45:24 <glittershark> hmm
07:45:39 <glittershark> split f g (x, y) = (f x, g y)
07:45:59 <Putonlalla> Another perspective is to consider it a specialization of `bimap`.
07:46:05 <glittershark> sure
07:46:50 <glittershark> https://ncatlab.org/nlab/show/cartesian+product just calls it "f" which isn't helpful
07:46:51 <merijn> Char8 has always been evil and there is no sane fix for IsString for ByteString
07:46:54 <Solonarv> well, it's both a specialization 'Bifunctor f *> f --> (,)' and a generalization '(->) --> Arrow p *> p'
07:46:59 <merijn> Actually, that's not true, there is a sane fix :p
07:47:04 <merijn> Which is "My library" :p
07:47:08 <Solonarv> "alongside" seems like a good name for it
07:47:36 <glittershark> I usually think of it in terms of the categorical limit on the discrete 2-diagram
07:47:50 <glittershark> like uh
07:48:00 <glittershark> one of the things that makes a product a product
07:48:08 <maerwald> merijn: there is, remove the instance
07:48:17 <merijn> maerwald: Fair enough, I'd support that too
07:48:37 <maerwald> feel free to comment https://github.com/haskell/bytestring/issues/140
07:48:52 <merijn> It's never happening though, many people use that instance
07:49:03 <maerwald> +1 for deprecation phases
07:49:22 <maerwald> give it 1-2 years, then tell those people who didn't read the messages "hey, sorry"
07:49:40 <glittershark> I'm going with "alongside", feels more evocative
07:49:55 <glittershark> f `alongside` g (x, y) = (f x, g y)
07:50:24 <tdammers> from a pragmatic point of view the IsString instance for ByteString makes a lot of sense
07:50:37 <c_wraith> I don't understand the issues people have with .Char8.  It does exactly what it says it does, and I don't see why it shouldn't.
07:50:39 <maerwald> tdammers: you mean the current one?
07:51:07 <tdammers> maerwald: I mean to have one at all, and to make it use ASCII for values 0 through 127
07:51:19 <tdammers> maerwald: above that, the behavior should be "unspecified"
07:51:26 <tdammers> (my $0.02 anyway)
07:51:34 <maerwald> I think the confusion comes from: 1. the ByteString instance needs explicit documentation in addition to the class documentation, 2. some people might not even know that OverloadedStrings uses this
07:51:43 <c_wraith> I can see protesting that IsString is a broken class, but given that it is, .Char8 is the best way it can handle it.
07:51:44 <maerwald> and imo it's just terrible API
07:52:04 <tdammers> I'd much prefer an explicit, separate string literal syntax for bytestrings
07:52:05 <Solonarv> oh yes IsString is definitely terrible
07:52:06 <Putonlalla> My advice with naming is to choose a bad one and use a thesaurus to improve it by following along the synonym tree, glittershark.
07:52:24 <glittershark> heh
07:52:27 <glittershark> yep
07:52:36 <maerwald> tdammers: instances should never have that much diverging semantics that you need to read the implementation of them before you are confident to use them
07:52:38 <merijn> maerwald: Good, now I can market my library there ;)
07:52:42 <Solonarv> unfortunately other alternatives involve template haskell/quasiquoters, which is rather heavy-weight
07:52:57 <glittershark> I was trying to figure out what it's usually called in category theory, but apparently they don't have a good name for it
07:53:00 <maerwald> even if there's a good argument for the behavior of the instance...
07:53:06 <merijn> Solonarv: I made implementing the quasiquoter easy, though!
07:53:09 <maerwald> it just makes classes unusable
07:53:21 <c_wraith> Solonarv: there's another option...  String -> Maybe a, with compile-time failure if it returns Nothing on literals.
07:53:27 <Putonlalla> This can be automated, since WordNet gives you common synonyms with the command `wn alongside -synsr`.
07:53:29 <merijn> @hackage validated-literals
07:53:29 <lambdabot> http://hackage.haskell.org/package/validated-literals
07:53:40 <merijn> c_wraith: Yeah, I literally already did that ;)
07:54:07 <merijn> c_wraith: I proposed adding support for that in GHC in 2013, but people were hesitant and thought "it should first be shown people want this by implementing it as a library"
07:54:21 <c_wraith> People want it without using a library
07:54:43 <merijn> c_wraith: I know, that's why I wanted it in GHC
07:55:12 <merijn> To be fair, it's only 1 module and has only two dependencies (base and template-haskell), so it's fairly lightweight to pick up :p
07:56:34 <dminuoso_> So I think I may have deadlocked my Haskell program some way or another. How can I sensibly figure out where it hangs?
07:56:53 <dminuoso_> (Luckily my colleague is, more or less, able to reproduce this reliably)
07:56:58 <merijn> dminuoso_: Thinking hard, prayer, and heavy drinking usually helps
07:57:05 <Solonarv> dminuoso_: run it with +RTS -xc and spam ^C when it hangs
07:57:31 <Solonarv> the exception generated by ^C will cause a stacktrace to be printed
07:57:43 <Solonarv> which should help figure out what it is doing at that time
07:58:09 <maerwald> heavy drinking++
07:58:23 <merijn> Debug.Trace
07:58:33 <merijn> I recommend a good Scotch for debugging deadlock
07:58:36 <maerwald> import Debug.Drunk
07:58:38 <merijn> Preferably single cask
07:58:42 <Solonarv> yeah, sprinkle some of those Debug.Trace around as well
07:58:57 <Solonarv> there is a trace function that prints a stack trace too
07:59:06 <maerwald> and then once you put those traces in there... the bug is gone xD
07:59:13 <Solonarv> (obviously to get stack traces you must compile the 
07:59:21 <Solonarv> (obviously to get stack traces you must compile with -prof)
07:59:24 <dminuoso_> Solonarv: Oh yeah that's fine! :)
08:01:56 <dminuoso_> Solonarv: Well I dont think ^C will help.
08:02:02 <dminuoso_> Not even a SIGTERM can bring my process down
08:02:07 <Solonarv> hmm
08:02:11 <merijn> dminuoso_: Nice!
08:02:12 <boxscape> SIGKILL?
08:02:16 <Solonarv> impressive!
08:02:16 <merijn> dminuoso_: -threaded or not?
08:02:21 <merijn> boxscape: SIGKILL always works
08:02:33 <boxscape> pretty sure I've had a zombie process where it didn't
08:03:03 <boxscape> but I suppose you probably don't get a stack trace with SIGKILL?
08:03:05 <merijn> boxscape: That's a problem with the linux kernel
08:03:06 <dminuoso_> merijn: Yeah its -threaded
08:04:06 <geekosaur> zombies are already dead, the parent process is the one that's stuck and not collecting the zombie
08:04:25 <boxscape> I see
08:04:29 <merijn> geekosaur: It is possible (on linux) to get zombie processes that can never get reaped
08:05:08 <geekosaur> that fails to surprise me these days
08:05:11 <merijn> geekosaur: When they die in the middle of blocking kernel calls, some obscure case like NFS driver dies when you do a remote read
08:05:19 <maerwald> another joy... signal handling in haskell (ever tried to ^C cabal when it's running --jobs=8?)
08:05:59 <dmwit> ...yes?
08:06:08 <dmwit> It's always worked just fine here.
08:06:13 <merijn> Signal handling in Haskell is about as convenient as in C, but as with C almost everyone messes it up
08:06:15 <maerwald> well, here it doesn't xD
08:06:18 <maerwald> it just keeps running
08:06:59 <merijn> maerwald: That's not really a Haskell issue and more of an application issue, though
08:07:12 <maerwald> true
08:07:35 <dminuoso_> merijn: I've had so many cases of "Network ddies while in the middle of NFS things going on" leaving me unreapable zombies..
08:07:37 <maerwald> https://github.com/ndmitchell/shake/issues/169 is also one of those
08:08:14 <maerwald> merijn: but it gets a little bit funny since SIGINT is an async exception...
08:08:35 <merijn> maerwald: SIGINT gets turned into an async exception to main, yes. It doesn't have to be
08:09:12 <dminuoso_> merijn: Ah heh! Indeed my signal handling might be responsible for SIGTERM not doing what it should.
08:09:13 <merijn> maerwald: That entire issue, as usual, doesn't have a single reference to the one true reference on how to handle signals properly
08:09:36 <merijn> Or really, the on true reference on how to do *anything* on POSIX
08:09:40 <maerwald> also, when you start your program with 'cabal new-run program' and then send SIGINT to cabal... nothing happens :>
08:09:48 <merijn> "Advanced Programming in the UNIX Environment"
08:09:52 <maerwald> most of the time, no one propagates any signals
08:10:02 <merijn> It should be mandatory for people to read that before writing software on posix >.<
08:10:08 <geekosaur> you shouldn't propagate it
08:10:20 <maerwald> geekosaur: in cases like 'make', yes
08:10:43 <geekosaur> and you shouldnt react to it when blocked on a child. kill the child, the parent unblocks and reaps it. parent ignores SIGINT because you don't want breakaage on ^C
08:11:02 <geekosaur> which is sent to the entire process group, there being no con cept of "currently running program" in a multitasking environment
08:11:14 <maerwald> ^C is not the same as SIGINT though
08:11:23 <geekosaur> it is after the tty driver processes it
08:11:34 <merijn> maerwald: ^C on all sane terminals produces SIGINT to the active process group
08:11:34 <maerwald> yes, but not if you send it manually
08:11:43 <merijn> ^C send manually doesn't do anything
08:11:50 <maerwald> I mean SIGINT
08:12:01 <geekosaur> so how do you plan to distinguish these?
08:12:08 <maerwald> that's basically what shake expects you to do, because it ignores SIGTERM
08:12:17 <geekosaur> the program gets SIGINT. it doesn't know why
08:17:50 <maerwald> and shake propagates SIGINT: https://github.com/ndmitchell/shake/blob/master/src/General/Process.hs#L137-L142
08:18:10 <maerwald> and weirdly enough, after that sends SIGTERM instead of SIGKILL
08:18:42 <geekosaur> shake runs the child in a separate process group (note interruptProcessGroupOf)
08:20:19 <geekosaur> this requires propagation since there's only one current process group and it's going to be shake so it can interrupt multiple running jobs
08:22:32 <maerwald> yeah, so the only way to terminate is sending SIGINT, because SIGTERM is completely ignored
08:24:18 <maerwald> but then you can't if you run it through cabal ;D
08:25:33 <geekosaur> seems to me cabal and shake are both build tools, they're going to conflict anyway. can't run cabal under stack either
08:26:09 <maerwald> well, cabal has this feature to run files as scripts (fake-package)
08:26:31 <maerwald> so you don't have to create an entire project just for a shake file
08:26:53 <maerwald> this isn't really a conflict
08:27:02 <merijn> geekosaur: I think you're misunderstanding. I think he's saying that he run shake as a cabal script, not shake running cabal
08:27:30 <maerwald> oh, and then add docker signal handling to the picture... 
08:27:35 <merijn> geekosaur: So he can't interrupt shake because cabal is handling it
08:27:52 <maerwald> jenkins -> shell -> cabal -> shake -> docker -> shell
08:28:00 <maerwald> who's going to get the signal?
08:28:00 <maerwald> :D
08:28:09 <geekosaur> I'd expect either direction to be problematic, is my point.
08:28:23 <maerwald> I don't see why. It's an explicit feature
08:28:48 <maerwald> I would expect new-run to behave like a shells "exec" and switch to the process
08:29:18 <geekosaur> except it has to clean up the temporary ghc package environment it sets up
08:29:26 <maerwald> yeah
08:30:33 <__monty__> I'd like to generate random numbers seeded with some Text. Does StdGen's `reads` consume a finite prefix of a string? (It guarantees to consume only a finite portion of the string.)
08:32:43 <__monty__> Hmm, looks like it either reads two unsigned decimal numbers or the first 6 characters. Guess I'll hash.
08:33:09 <Solonarv> yeah, hashing is what you are supposed to do
08:33:25 <Solonarv> it only really makes sense to seed with an integer (in some range) anyway
08:34:49 <merijn> *looks at unsafeCoerce :: a -> Int* "Is this a hash?"
08:35:37 <merijn> % unsafeCoerce (Data.Text.pack "foobar") :: Int
08:35:37 <yahb> merijn: 283482008264
08:35:57 <__monty__> % unsafeCoerce (Data.Text.pack "foobarbazqux") :: Int
08:35:57 <yahb> __monty__: 283505519264
08:36:06 <merijn> "Don't try this at home" >.>
08:36:31 <__monty__> Oh, it's probably using some of the String's length information?
08:36:45 <__monty__> % unsafeCoerce (Data.Text.pack "foobaz") :: Int
08:36:46 <yahb> __monty__: 283498388088
08:37:03 <__monty__> Maybe some pointers?
08:37:12 <__monty__> % unsafeCoerce (Data.Text.pack "foobaz") :: Int
08:37:13 <yahb> __monty__: 283489532456
08:37:24 <__monty__> Yah, need reproducability : )
08:38:04 <Solonarv> % :i Text
08:38:05 <yahb> Solonarv: ; <interactive>:1:1: error: Not in scope: `Text'
08:38:06 * geekosaur guesses it's a pointer
08:38:22 <Solonarv> % import Data.Text.Internal as TextInt
08:38:23 <yahb> Solonarv: 
08:38:29 <Solonarv> %:i TextInt.Text
08:38:35 <Solonarv> % :i TextInt.Text
08:38:35 <yahb> Solonarv: data Text = Text {-# UNPACK #-}Data.Text.Array.Array {-# UNPACK #-}Int {-# UNPACK #-}Int -- Defined in `Data.Text.Internal'; instance Eq Text -- Defined in `Data.Text'; instance Monoid Text -- Defined in `Data.Text'; instance Ord Text -- Defined in `Data.Text'; instance Semigroup Text -- Defined in `Data.Text'; instance Show Text -- Defined in `text-1.2.3.0:Data.Text.Show'; instance Read Text -- Define
08:38:45 <Solonarv> yup it's a pointer
08:38:57 <Solonarv> or, no, it's whatever Array is
08:39:02 <Solonarv> since it gets unpacked
08:39:26 <Solonarv> % import qualified Data.Text.Array as TextArray
08:39:27 <yahb> Solonarv: 
08:39:56 <Solonarv> % :i TextArray.Array
08:39:56 <yahb> Solonarv: data TextArray.Array = TextArray.Array {TextArray.aBA :: ByteArray#} -- Defined in `Data.Text.Array'
08:40:08 <Solonarv> okay, it is a pointer
08:40:47 <Solonarv> gotta go now
08:52:40 <fendor> what is the feature called when you have multiple libraries in your .cabal file and one of the libraries is named?
08:53:42 <asheshambasta> Is there a lens-ey way to simplify something like : `view (someListField . to (fmap (view someFieldOfEachElem)))`
08:57:34 <__monty__> Is there a safe way to convert a ByteString of length 8 to an Int? Or do I have to convert to [Word8], convert, scale and sum?
09:01:23 <lortabac> __monty__: what do you mean by convert to Int? Hashing?
09:02:05 <lortabac> @hackage hashable
09:02:05 <lambdabot> http://hackage.haskell.org/package/hashable
09:03:25 <__monty__> No, I get a ByteString from a hash function and I want to pass it to mkStdGen as an Int.
09:04:21 <fendor> __monty__, I dont think that this can be done safely, since Int is only garantueed to have 29 bits, right?
09:06:05 <__monty__> fendor: Does this hold for 64 bit platforms
09:09:28 <fendor> __monty__, no, afaik on a 64bit system int has 64 bits.
09:10:33 <__monty__> fendor: Ok, so a safe way for any implementation that has 64 bit Ints : )
09:13:40 <infinisil> How about first converting to Word64
09:13:53 <infinisil> Then just fromIntegral that
09:14:06 <infinisil> Should be good enough for a random seed
09:16:51 <davean> __monty__: you can use any binary deserialization too
09:41:46 <dminuoso_> infinisil: And that's different from directly coercing it into an Int how?
09:41:55 <dminuoso_> infinisil: If it doesnt fit it doesnt fit.
09:42:17 <dminuoso_> fromIntegral doesn't apply magic to somehow make 64 bits of information fit into 29 bits...
09:42:47 <dminuoso_> (It just gives you that impression because things type check. automatically. without any error handling)
09:43:15 <dminuoso_> fromIntegral is basically casts from C made explicit, but with the semantics *still* hidden
09:52:22 <jared-w> maerwald: that makes sense. It sounds like you're coming from more of a culture and procedure standpoint where I was thinking more of judging nixpkgs just in terms of the code and how the language allows everything to be treated consistently. Your viewpoint is more prudent when regarding the health of an ecosystem, though :p
10:26:27 <__monty__> maerwald: Fwiw, if you install shake you don't need a .cabal project either.
10:36:46 <hhefesto> Hello, Haskell Gurus <3
10:37:15 <infinisil> dminuoso_: Two well-known transitions instead of one who-knows transition
10:38:13 <infinisil> (8 bytes -> 64 bits -> whatever Int is) vs (8 bytes -> squeeze into Int somehow)
10:38:14 <hhefesto> I am trying to follow Graham Hutton's Haskell Programming to do a parser: https://gist.github.com/hhefesto/36aa669c76d21973f548f89dce5c4e51
10:38:52 <hhefesto> the parser type is: newtype Parser a = P ([Char] -> [(a, [Char])])
10:39:28 <hhefesto> so if there is an error, the parser will return an empty list
10:39:43 <hhefesto> that is all good
10:40:11 <hhefesto> but I want my parser to be able to give several interpretations of the same input
10:40:49 <hhefesto> and Graham Hutton supposes that if the parser succeeds, only a singleton list will be returned
10:40:55 <asheshambasta> any sound designers using Haskell to design sounds? Or full blown music composition? 
10:42:33 <hhefesto> For that purpose, an either response would be better since Hutton expects only one interpretation
10:42:57 <hhefesto> anyway, I want several interpretations, so I liked the idea of the list
10:43:17 <hhefesto> but I am having trouble defining my Monad instance
10:44:34 <hhefesto> I am trying to use concatMap and an auxiliary function (aux)
10:44:34 <day> does a splitOn for [Word8] exist?
10:45:27 <day> sec i may have found one already
10:45:43 <merijn> day: Well, any split functioning on [] would work, no?
10:46:33 <wildtrees> asheshambasta, I am not a  sound designer, occasional music creation newbie, but I found https://tidalcycles.org/index.php/Welcome which uses haskell to live code music to be decently easy to use once setup and it sounded really good 
10:46:56 <wildtrees> asheshambasta, it was a bit to setup and configure though a few years ago, that might have changed
10:47:42 <asheshambasta> wildtrees: ah; I've been looking into csound-expression that builds on top of csound and it seems pretty neat; setting it up was also trivial (barring a PulseAudio issue combined with nix-shell --pure)
10:48:43 <wildtrees> asheshambasta, I was enamored with nix at first, but kind of gave up when I couldn't get my webserver in haskell build timess down from like 12+ hours in a constrained domain 
10:49:41 <tdammers> fwiw, I tried to love nix, but it has given me nothing but agony and "wtf" moments, pretty much right out the gate
10:49:52 <asheshambasta> wildtrees: I've been using nix for my personal machine; I've not really used it to replace stack yet, but I hope to soon. 
10:51:02 <wildtrees> asheshambasta, I couldn't figure out overlays at all, which I was told I needed to disable testing and profiling for all the haskell packages, also I couldn't get packages requiring zlib to build outside of using nix as a package manager, which is quite a few 
10:52:59 <asheshambasta> wildtrees: the docs. in the nix world can be better; I've not really had much trouble with nix though. I did once in a while get stumped with something imperative going on with my system expecting nix to be "pure"; but apart from that, nothing too serious or blocking. 
10:53:32 <wildtrees> asheshambasta, you haven't used it for building haskell packages yet? 
10:54:36 <wildtrees> asheshambasta, do you want to do something like this with haskell and live coding? https://youtu.be/1OkqxPfKsh8?t=413 
10:55:12 <asheshambasta> wildtrees: only to some extent; nothing super advanced yet. At my company we're moving our services to build using nix; and my colleague is researching that. 
10:55:37 <hhefesto> FWIW Solved my problem :)  by removing my aux type signature
10:55:47 <asheshambasta> wildtrees: not really live coding, but  I'd like to compose music using Haskell. 
10:55:50 <hhefesto> sometimes writing your troubles helps you solve them
10:56:10 <wildtrees> asheshambasta, I wish you the best of luck with moving to nix! somethings seemed kinda of hairy to me and I didn't stick around long enough to master them 
10:56:14 <asheshambasta> (I've been a hobbyist musician for a while now, and electronic sound design interests me.)
10:59:02 <wildtrees> asheshambasta, outside of haskell for music, I used fruity loops years ago and it's opensource clone lmms 
10:59:27 <asheshambasta> wildtrees: I've been using a combination of Reaktor and Ableton Live for a while 
10:59:31 <wildtrees> might want to get your hands on something that can run vsts or whatever the latest is and tweak those and plug in a midi keyboard 
10:59:47 <wildtrees> ahh yea that sounds a bit better then what I was using, never heard of reaktor though 
11:01:19 <asheshambasta> wildtrees: https://www.native-instruments.com/en/products/komplete/synths/reaktor-6/
11:01:57 <MarcelineVQ> I hear ableton live is pretty great for mashups
11:02:27 <asheshambasta> MarcelineVQ: I djed a bit with Live but never really did mashups; did some remixes though. 
11:02:37 <wildtrees> I remember a guy ollie, writing his own beep boop sounds for an asteroids clone via FRP and modifying and SDL sound buffer, was posted around 2012 I think 
11:03:07 <wildtrees> like 8 bit old computer beep boop sounds he was doing 
11:04:37 <asheshambasta> I consider BT one of the pioneers of electronic music; and he's claimed to use Csound pretty extensively for music composition and design; and given that csound-expression looks like a decent binding to csound; that has really piqued my interest. What could be better than actually making Haskell my tool of the trade for making music as well. 
11:04:53 <saml> what's BT
11:04:56 <saml> bluetooth?
11:04:57 <asheshambasta> and the idea of pure FP and music is really appealing. 
11:05:17 <asheshambasta> saml: https://www.btmusic.com/ 
11:05:48 <saml> thanks
11:05:52 <wildtrees> saml, Brian Tr<something> an electronic music producer/artists from the late 90's early 2000's 
11:06:02 <wildtrees> I think that's what he is referring too 
11:06:24 <wildtrees> asheshambasta, https://ocharles.org.uk/blog/posts/2013-08-18-asteroids-in-netwire.html if you scroll down a bit he talks about a functional reactive sound design engine 
11:06:31 <asheshambasta> he's made some 'commercial' sounding stuff recently; but he's also made stuff like this https://www.youtube.com/watch?v=f7JiCZvJh5Q
11:08:32 <wildtrees> asheshambasta, video is blocked cause of copyright! for me at least 
11:08:32 <asheshambasta> wildtrees: thanks!
11:08:57 <glguy> Haskell is great for adventofcode.com this year! It's not too late to dive in if you're aren't already participating ^_^
11:09:09 <asheshambasta> wildtrees: ah, its BT - Dynamic Symmetry (This Binary Universe)
11:09:34 <wildtrees> I haven't listened to BT in ages :) 
11:10:12 <asheshambasta> the guy's a legend
11:10:58 <wildtrees> yea, he uses csound still? 
11:11:46 <asheshambasta> wildtrees: yes, AFAIK; although he probably uses a whole suite of other instruments too. 
11:29:04 <yasar> Can I find this presentation somewhere else? https://www.microsoft.com/en-us/research/video/compositional-data-access-and-manipulation/
11:29:10 <yasar> That page is not working for me
11:34:27 <yasar> nvm, found it here: https://www.bilibili.com/video/av9741532/
11:54:08 <hc> 30 days? that's nothing
11:57:39 <sierraDelta> What would be the equivalent `shell.nix` for this? `nix-shell --packages 'haskellPackages.ghcWithPackages (pkgs: [ pkgs.random ])'`. I keep on forgetting the packages that I've used for a given dir.
12:13:56 <__monty__> asheshambasta: Please hire me for your nix+haskell problems : )
12:16:49 <infinisil> sierraDelta: pkgs.mkShell { buildInputs = [ (haskellPackages.ghcWith ...) ]; }
12:16:50 <asheshambasta> __monty__: we'll be looking to hire soon; we're expecting to do that in the third or fourth quarter of next year 
12:23:08 <sierraDelta> infinisil: thanks!
12:25:24 <AWizzArd> Why is “forall” used to express existential quantification? Is this mathematically even correct?
12:26:09 <merijn> AWizzArd: "because it was there" and "yes"
12:26:43 <merijn> AWizzArd: Because the forall is on "the thing handling the existential", not the existential value
12:27:14 <AWizzArd> merijn: do you possibly have a link to some explanation of why it makes sense that forall is used for existentials?
12:27:39 <merijn> AWizzArd: "I have some a value of some type 'x', but you don't know which" vs "this constructor can work for *any* type (so necessarily also on one of some unknown existential)"
12:28:41 <merijn> "data Foo = Foo (exists a . a)" Foo has an argument of some unknown type "data Foo = forall a . Foo a" "Foo is a constructor that accepts *any* type 'a' to return a value of type 'Foo'"
12:29:04 <merijn> AWizzArd: Note that the forall is on the Foo constructor, not the 'a' type
12:29:53 <AWizzArd> I think I got the core idea.
12:30:52 <solonarv> this is clearer in GADT syntax
12:31:10 <solonarv> where you write: data Foo where Foo :: forall a. (a -> Foo)
12:31:21 <solonarv> (redundant parens for clarity)
12:32:01 <solonarv> and forall x. (x -> R) ~ (exists x. x) -> R
12:36:59 <nil> just like `t -> (x -> r) ~ (t, x) -> r`, but with dependent typing
12:37:25 <rmorrison> Hello. I'm using `HTTP.Req` library and I want to pass `ByteString` (representing hash value) as a query parameter (those things after ? in URI). What is the best way to do so? 
12:38:02 <AWizzArd> solonarv: why can you say that those are equivalent? Are there not some steps left out? I.e. some proof steps?
12:41:19 <EvanR> nice matrix kicks people idle for 30+ days. Take that mysterious lurkers
12:41:42 <Rembane> It destroys the idler culture :(
12:42:20 <dminuoso_> rmorrison: A ByteString is just binary data.
12:42:26 <MarcelineVQ> exactly how much culture can there be with a people who don't act
12:42:53 <dminuoso_> Rembane: URL is ASCII data, so you have to specify what it means to serialize that ByteString into that URL.
12:42:56 <dminuoso_> Err rmorrison ^-
12:43:12 <dminuoso_> rmorrison: Is the serialization format specified by the server providing the HTTP endpoint?
12:43:33 <rmorrison> dminuoso_ urlencoded 20-byte SHA1 hash 
12:43:56 <dminuoso_> rmorrison: Endianess?
12:43:56 <rmorrison> I just need to escape some elements with % 
12:44:26 <EvanR> endianness doesn't apply when you're doing just bytes
12:45:20 <EvanR> since luckily bytes are presented as numbers 0 to 255 not bits
12:45:21 * Ailrun[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/QgRtXtHcFgPLovrAspAUfmtN >
12:46:07 <dminuoso_> EvanR: The byte order surely matters when transmitting binary data over the wire.
12:46:14 <Ailrun[m]> Oh, the second last line has a formatting issue.
12:46:27 <merijn> Ailrun[m]: The entire message was too long :p
12:46:31 <EvanR> when your 'binary data' involveds word32s and word16s yeah
12:46:42 <merijn> Ailrun[m]: Which results in matrix sending a link that almost no one bothers to open
12:46:43 <rmorrison> I also can't convert it to `String` nor to `Text` because that would imply encoding and all 128 > bytes would imply something else
12:46:58 <dminuoso_> EvanR: Huh? It's a 20 octet bytestring.
12:47:20 <EvanR> a 20-word8 string doesn't involve byte order at all
12:47:49 <EvanR> the i/o APIs take word8 strings as is
12:47:56 <Ailrun[m]> I mean
12:47:56 <Ailrun[m]> ~ (Type + P) -> Q (When + means dependent product)
12:47:56 <Ailrun[m]> (I used an asterisk, but it formats the text italic.)
12:48:08 <dminuoso_> EvanR: Say it's `\1\2\3\4\5\6...` do you encode that as "%01%02%03..." or "%20%19%18..." 
12:48:21 <dminuoso_> EvanR: Both are perfectly valid.
12:48:23 <EvanR> you're confused!
12:48:28 <merijn> dminuoso_: That's not how endianness works...
12:48:59 <dminuoso_> I think Im confused.
12:49:45 <geekosaur> dminuoso_, endianness only applies when the string is composed of larger chunks than bytes. such as utf16 which treats it as 2-byte words, but now you must specify the order in which those words are transcribed into bytes in the string
12:49:50 <merijn> dminuoso_: endianness deals with the bytes within a single 2, 4, 8 (more?) byte word and which is most significant
12:49:58 <geekosaur> but with word8. the given order is the specified order
12:50:17 <nil> AWizzArd: in case you didn't see it because matrix is weird, Ailrun[m]'s "long message" was for you
12:50:21 <merijn> dminuoso_: For octect streams there's just "a sequence of bytes" and writing a sequence in reverse makes no sense, so no one bothered to name that
12:51:30 <dminuoso_> merijn: There sure is. The reason network byte order is a thing has to do with early networking equipment attempting to make longest prefix matches faster by receiving more significant octets first.
12:51:45 <rmorrison> Is it polite or common to email a library author and ask how things work?
12:51:50 <EvanR> network byte order involves an encoding of word32s and word16s as word8s
12:52:05 <EvanR> which you aren't doing if you started with word8s
12:52:06 <dminuoso_> EvanR: Does it matter whether its a word32 or a word
12:52:11 <geekosaur> dminuoso_ but that still aplies to the fact that it's working with multibyte sequences
12:52:20 <merijn> rmorrison: Common, no? But polite emails seem fine, provided you're prepared to accept long response times
12:52:22 <dminuoso_> EvanR: *or a word160
12:52:28 <geekosaur> there *can* be bit order there, but that's only significant if you're directly altering bits and otherwise that level is generally handled by the device driver so the computer sees things in native bit order
12:52:31 <EvanR> there's only 1 way to choose how order the word8s in a word8 string
12:52:35 <merijn> dminuoso_: Sure, but practically speaking those don't exist
12:52:59 <merijn> dminuoso_: And we don't consider "an octect stream" a "wordX" we consider it a stream of octets
12:53:50 <sm[m]> rmorrison: I usually file a polite bug report, saying I read all docs and what I'm still confused about
12:53:53 <merijn> You could argue "we should treat it as a wordX", but then we're solidly in "hypothetical land" and not the real world
12:54:04 <dminuoso_> EvanR: But thats the thing. A fixed 20 octet string is not really some "word8 string"
12:54:11 <rmorrison> sm[m], I see, thank you
12:54:15 <EvanR> even with the bits of a word8 you can't tell what order the bits 'are' in because all the bit operations act like you're talking about the corresponding number
12:54:37 <EvanR> a 20 word8 string is totally a word8 string
12:54:42 <EvanR> you could sent it backwards but why
12:54:48 <dminuoso_> EvanR: By that logic a word32 is really just a word8 string.
12:55:00 <merijn> dminuoso_: Except that, by convention, it is not
12:55:03 <EvanR> unfortunately no because word32 is a number not a string
12:55:31 <EvanR> one billion as opposed to hundred hundred hundred hundred
12:56:01 <EvanR> making it a string is where endianness happens
12:56:14 <Clint> i think dminuoso_'s point is that you can encode a word160 in many insane ways
12:56:32 <merijn> Sure, but no one does that, so the point is moot
12:56:38 <EvanR> Word160 yeah
12:56:51 <EvanR> but i thought we were talking about Vect 20 Word8
12:56:56 <merijn> We could treat a fixed length octet stream as a WordX, but we don't
12:57:16 <merijn> "but what if we did?" is a rather pointless discussion
12:57:34 <EvanR> some crypto libs do present a Word160 type
13:04:27 <geekosaur> https://en.wikipedia.org/wiki/Endianness#Middle-endian
13:04:41 <geekosaur> thankfully it's historical at this point
13:04:57 <merijn> My favourite thing is that the endian terminology comes from Gulliver's Travels :>
13:05:03 <geekosaur> (PDP11 used middle-endian for 32-bit values)
13:05:10 <merijn> Coined in the paper with one of the best titles ever :)
13:05:48 <Rembane> Aren't american dates middle-endian?
13:05:57 <geekosaur> yes, a point made by the link
13:07:07 <EvanR> us military internalizes little endian dates
13:08:20 <monochrom> which paper?
13:09:25 <merijn> monochrom: "On Holy Wars and a Plea for Peace"
13:09:48 <monochrom> haha that's neat
13:10:15 <merijn> monochrom: Gulliver's Travels has the civil war between "little endians" and "big endians" (over which side to eat/open an egg from)
13:10:27 <monochrom> Yeah, that one I know.
13:10:53 <merijn> The conclusion in Gulliver's Travels is "it doesn't matter, so everyone should do what they like", the paper argues "in our case it doesn't matter, therefore we should all pick the same thing"
13:11:38 <monochrom> I wonder if "we should all pick the same thing" was a joke.
13:11:47 <merijn> No
13:12:01 <merijn> it doesn't matter, but interoperability demands a single standard
13:12:29 <EvanR> i disagree with the paragraph about "little endian is only backwards for left-to-right languages"
13:12:33 <monochrom> The author ought to know that it's exactly why there is a holy war.
13:13:11 <EvanR> at least with their example of encoding "Wiki" as a word32
13:13:43 <EvanR> little endian would also be "backwards" if you are right to left, and wrote addresses increasing left
13:13:59 <monochrom> Oh this gets subtle. We now also have a divide on what "little endian" means. :)
13:13:59 <MarcelineVQ> I truly can't keep track of what end big endian and little endian even refer to
13:14:26 <ChaiTRex> Big endian and little endian refer to what part of the number gets put in which address.
13:15:02 <monochrom> little little endian = transmit the LSB first.  big little endian = LSB is on the left.
13:15:49 <evelyn> ppc64 can be little endian OR big endian. I assume not at the same time.
13:15:52 <EvanR> left and right are not welcomed, your second version of little endian should be in LSB in lowest address
13:16:06 <monochrom> I'm just having fun.
13:16:06 <EvanR> then people can drawn lower addresses wheverever they want
13:16:15 <EvanR> up down sideways
13:16:34 <monochrom> I draw my addresses along a Peano space-filling curve.
13:16:56 <monochrom> My LSB is left right and centre and all over the place.
13:17:21 <merijn> <3 SQL
13:17:50 <monochrom> Why suddenly bring up SQL?
13:17:51 <EvanR> that paragraph also implicitly slides us into the confusion that right to left languages still write numbers left to right big endian
13:18:22 <merijn> monochrom: Because I'm hacking on it in between procrastinating here
13:18:55 <monochrom> If you write SQL in Arabic, is it backwards? >:)
13:19:05 <merijn> monochrom: And I don't think I ever truly appreciated its elegance during university
13:19:28 <monochrom> Or maybe "it is not backwards, it is postfix dammit" :)
13:19:46 <geekosaur> EvanR, mostly they borrowed the numbers. like, in Hebrew the numbers are "natively" written as letters, sort of Roman numeral style
13:19:48 <monochrom> Yes it's pretty neat.
13:20:13 <Rembane> Arabic numbers makes so much more sense in arabic
13:20:15 <geekosaur> and in RTL
13:20:41 <Rembane> Yes
13:20:46 <monochrom> Wait, so "12345" in Arabic is little endian? :)
13:20:53 <EvanR> wth
13:20:58 <MarcelineVQ> "<EvanR> that paragraph also implicitly slides us into the confusion that right to left languages still write numbers left to right big endian" 123 (one-hundred-twentythree) is big endian?
13:21:12 <EvanR> yes 123 is big endian
13:21:16 <MarcelineVQ> so the left end is the end?
13:21:24 <EvanR> big end first
13:21:25 <monochrom> OK at least "44444" is unambiguous :)
13:21:48 <EvanR> where first means left to right here
13:21:49 <MarcelineVQ> gosh. I write 3 last so I would call 123 little endian. this shit is boggling
13:22:04 <EvanR> "_ end first" is how i remember it
13:22:31 * geekosaur always has this problem with "least/most significant _"
13:22:32 <EvanR> you can throw left and right out and think of lists
13:23:29 <Nolrai> So I want a data structure for morphisms that can be composed sequentially (.), alternatively (+), and parallelly (*),  and I would really like "(a+b) . (c+d)" to be _equal_ to "(a . c) + (b . d)" and similarly for (*).
13:23:52 <EvanR> a monoidal category give you the +
13:24:05 <EvanR> a ring-y category gives you * on top of that?
13:24:10 <Nolrai> Yes.
13:26:18 <Nolrai> In particular I am trying to do stuff with the* category of reversible boolean computations. * well a representation of such that can be compiled down to c-swap gates.
13:27:33 <Nolrai> But like what _data structure_ do I use?
13:28:17 <EvanR> an AST ?
13:28:49 <Nolrai> I am having a brain fart, what is an AST?
13:29:23 <monochrom> abstract syntax tree
13:29:32 <Nolrai> Ah.
13:30:09 <monochrom> ASTs will never know or represent extra equations like yours.
13:30:31 <Nolrai> Right. Thats why I am not just doing that.
13:31:22 <Nolrai> I mean I basicly want to represent the "rectangle diagrams" from the math papers about this.
13:32:30 <yasar> What does `forall` mean in `type` declaration?
13:33:21 <monochrom> The user chooses how to instantiate the type variables.
13:34:04 <monochrom> For example suppose you give me a function and you write its type sig as "foo :: forall a. a -> [a]"
13:34:09 <monochrom> So I'm the user.
13:34:09 <solonarv> AWizzArd: oops, didn't see that mention; it's exactly analogous to the de Morgan law for the exists/forall quantifiers in logic, remember that the function arrow -> corresponds to implication
13:34:31 <solonarv> AWizzArd: in short: blah blah Curry-Howard correspondence handwave
13:34:40 <monochrom> I can use it as "foo False" so I'm choosing a=Bool.  I can use it as "foo 45" so I'm choosing a=Integer for example.
13:35:51 <yasar> monochrom, how is it different then `f :: a -> [a]`
13:36:02 <monochrom> No difference.
13:36:04 <solonarv> it isn't
13:36:14 <merijn> yasar: It's not. In Haskell all type variables implicitly have "forall" on the left
13:36:26 <solonarv> if you write 'f :: a -> [a]', GHC inserts an implicit 'forall' at the start
13:36:27 <merijn> yasar: So "id :: a -> a" is the same as "id :: forall a . a -> a"
13:37:06 <yasar> Ohh, I was following a presentation online and thinking it was an new concept :)
13:37:10 <merijn> yasar: Some extensions (re)use the fact that GHC internally uses forall as convenient syntax (ScopedTypeVariables, RankNTypes, etc.)
13:37:57 <merijn> yasar: ScopedTypeVariables uses explicit forall to "share" type variables with bindings inside a where block, whereas RankNTypes allow "forall" in more places than only "entirely on the left"
13:38:41 <MarcelineVQ> does it matter that type was in quotes earlier?
13:39:16 <solonarv> MarcelineVQ: three IRC users, three quoting styles ;)
13:39:40 <monochrom> Sometimes you even get 5 quoting styles.
13:39:50 <MarcelineVQ> No​ I mean was the question about 'type'. e.g. type Bib f r = forall d. f d -> r
13:40:09 <solonarv> oh, I see
13:40:24 * solonarv shrugs
13:40:37 <monochrom> I have considered that. It still doesn't change my statement.
13:41:38 <yasar> so, `type Lens' s a = forall f. functor f => (a -> f a) -> (s -> f s)` means, values of type `Lens'` are functions that changes a functions type signature?
13:42:04 <solonarv> no, because "functions that changes a functions type signature" is a nonsense statement
13:42:16 <merijn> yasar: This is an example of a Rank2Type
13:42:23 <monochrom> The fallacy of plain English explanation.
13:42:31 <solonarv> values of type Lens' s a are functions, yes
13:42:41 <solonarv> they take a function and produce another function
13:42:45 <merijn> yasar: It's basically a way to force a function argument to be polymorphic
13:43:12 <solonarv> but, 'type' is a very non-mysterious keyword
13:43:15 <merijn> yasar: The simplest example of the use of RankNTypes is something like: https://gist.github.com/merijn/77e3fa9757658e59b01d
13:43:37 <monochrom> Eh? Lens' isn't rank-2.  You reach rank-2 when you use it like "Lens' x y -> ..."
13:44:20 <yasar> So, Lens' kind of resembles the decorators in Python?
13:44:27 <solonarv> here is how to interpret that 'type' declaration: wherever you see `Lens' Foo Bar`, replace it with the right hand side of that definition: `(forall f. Functor f => (a -> f a) -> s -> f s)`
13:44:32 <merijn> monochrom: Ok, fine, but that doesn't change the answer to "what does forall do?"
13:44:45 <solonarv> no, it is not usefully comparable to decorators
13:44:51 <merijn> yasar: That depends, is "map" a decorator?
13:45:23 <solonarv> you *could* use it like a decorator, if Haskell had such a feature
13:45:30 <solonarv> but that would be extraordinarily useless
13:46:08 <monochrom> python doesn't have types.  Lens' is not going to resemble anything in python.
13:46:22 <monochrom> But try C++ or Rust.
13:46:58 <solonarv> actually Rust's type system is too weak to concisely and simply implement Functor
13:47:09 <monochrom> Oh, oops, yeah.
13:47:30 <solonarv> C++'s is powerful enough (of course), but it will be inscrutable
13:47:50 <monochrom> Actually how would you do it in C++?
13:47:59 <solonarv> I don't know exactly
13:48:00 <merijn> monochrom: template templates!
13:48:12 <solonarv> but template parameters can be other templates, so that lets you have HKTs
13:48:23 <monochrom> Yikes haha OK
13:49:28 <solonarv> you can probably impleent lenses in python without too much trouble (apart from syntax being clunky, and FP in python being slow)
13:49:41 <solonarv> the type system won't help you, but at least it won't get in your way either
13:49:46 <monochrom> On the bright side C++ has type-level integers and their textbook example is even the "array of statically known length" example that all of you dependent type fanboys love so much so you should all be switching over to C++.
13:49:48 <merijn> "template<template<typename> F, typename A, typename B> F<B> fmap(std::function<B(A)> f, F<A> as) {...}"
13:50:00 <merijn> Something along those lines
13:50:54 <merijn> oh, probably needs "class" before F
13:50:58 <merijn> but you get the gist
13:51:08 <monochrom> yeah no worries
13:51:28 <merijn> monochrom: That's comparably clean to some of the atrocities I have committed :p
13:51:57 <EvanR> wait, C has had array of static length since cane and abel
13:52:04 <merijn> EvanR: No
13:52:11 <merijn> EvanR: Well, yes, but not usefully so
13:52:11 <monochrom> Dependently typed programs are inscrutable.  Change my mind.
13:52:30 <merijn> EvanR: For one, you can't pass those arrays to any function in a useful manner
13:52:40 <solonarv> EvanR: the problem is that it forgets about the length as soon as you do basically anything to the array :(
13:52:41 <EvanR> you can't pass them at all 
13:52:52 <solonarv> just decays to a pointer
13:53:05 <EvanR> so basically for some value of "has" 
13:53:51 <EvanR> C has functions, but they don't have closure support. So i guess C doesn't have functions :)
13:54:13 <monochrom> How about this. C++ has enough support for type-level integers that you can write type-level prime factorization.  You can't say that of Haskell, and you wouldn't do that in Agda either.
13:54:44 <EvanR> you wouldn't download a type level prime factorization in agda?
13:55:46 <dmwit> (You can probably say it of GHC, though.)
13:56:31 <EvanR> next C++ will have algebraic data types
13:57:41 <solonarv> EvanR: yes, but they will be incredibly verbose and have some strange semantics
13:57:52 <solonarv> this is C++ we are talking about after all! ;)
13:58:02 <merijn> To be fair, C++ lambda's are super reasonable
13:58:14 <solonarv> (by "verbose" I really mean "symbol heavy", of course)
13:58:18 <merijn> More so than they have any right to be, considering the backwards compat restrictions
14:05:26 <atif> I don't understand why  % (.) putStrLn show "a"  works but  % putStrLn . show "a"  doesn't.
14:05:51 <merijn> atif: function application always has higher precedence than operators
14:06:09 <merijn> atif: So the latter is equivalent to: (putStrLn) . (show "a")
14:06:10 <monochrom> ((.) putStrLn show) "a" doesn't work. This is the explanation.
14:06:10 <atif> ah...
14:06:57 <merijn> % ((.) putStrLn show) "a"
14:06:58 <yahb> merijn: "a"
14:07:04 <merijn> monochrom: Seems fine to me :p
14:07:47 <monochrom> Oh haha I see.  s/doesn't/does too/
14:08:30 <monochrom> I need more tea.
14:08:54 <merijn> atif: This precedence makes it actually mostly simple to reason about complex expressions, but if you're not used to it you get confused when you try to directly apply a composed function
14:09:20 <merijn> % (putStrLn . show) "a" -- this also works, since parentheses break the application of 'show' to "a"
14:09:20 <yahb> merijn: "a"
14:09:28 <monochrom> Yeah normally you would like "sin x + cos y" to mean (sin x) + (cos y).
14:09:38 <solonarv> I waffle between `(foo . bar . baz) x` and `foo . bar . baz $ x`
14:09:41 <merijn> % putStrLn . show $ "a" -- and of course trusty $
14:09:41 <yahb> merijn: "a"
14:10:04 <monochrom> Then someone says that for the sake of parser simplicity, let's do that for all infix operators, including (.)
14:10:18 <merijn> "Encountered an unepxected exception "Shouldn't happen"" <- welp...back to work
14:10:32 <monochrom> maybe s/for all/to all/  # I hate prepositions
14:10:34 <solonarv> merijn: boo, get better errir nessages!
14:10:51 <monochrom> oh actually "for" is not a preposition.  I hate English.
14:11:00 <atif> but the whole idea of (.) is (f.g)(x) = f(g(x))
14:11:30 <merijn> atif: Plenty of cases where you want to compose a 'g' that happens to be a partially applied function
14:12:17 <monochrom> Yeah, map f . filter p
14:12:49 <atif> merijn:  Not sure I understand.
14:13:08 <merijn> atif: Take monochrom's example, how should that be parenthesised
14:13:27 <atif> map f (filter p)
14:13:38 <merijn> atif: Keep in mind that "compiler psychically knows what you intended" is not an implementable answer
14:13:45 <merijn> atif: That doesn't type check
14:14:07 <monochrom> (\x -> map f (filter p x)) = map f . filter p
14:14:16 <wildtrees> can I a get a function or Data.Map like structure from String -> Parser a where 'a' could vary and be different types? 
14:14:17 <monochrom> and I really like it that way
14:14:35 <merijn> wildtrees: Depends on how complex you wanna get
14:14:37 <wildtrees> just need one of elon musks neural links to be perfected 
14:15:19 <monochrom> Elon Musk is untyped. Use python. :)
14:15:36 <wildtrees> I want to use the function/map to construct a parser that would parse different fields into type different types 
14:15:49 <wildtrees> python is typed?? you mean unityped? 
14:16:14 <monochrom> No no, use untyped python for untyped elon musk.
14:16:58 <wildtrees> Left "error no parse" ;) 
14:17:11 <monochrom> As for x:String -> Parser (F x), that's emphatically dependent typing.
14:17:37 <wildtrees> does haskell support something like that yet if I use the right combination of extensions? 
14:18:25 <merijn> wildtrees: You could use TYpeFamilies to control return type based on input types
14:18:25 <monochrom> I bet no.
14:19:29 <nshepperd2> Python is untyped because you have to handwrite it
14:19:51 <monochrom> Hey I said that of untyped lambda calculus!
14:20:53 <monochrom> Typed lambda calculus is when you use a typewriter.  Untyped is when you write by hand.
14:21:24 <monochrom> This is why untyped lambda calculus comes with recursion. You write cursive. :)
14:26:35 <wildtrees> oic :)
14:33:02 <solonarv> but I don't write cursive!
14:33:24 <solonarv> unless it's a lowercase L or a \mathcal letter
14:33:50 <atif> so what I've got is `f = map (*2) . filter odd; f [1,2,3]. --> [2,6]` so it's equivalent is `(map (*2) . filter odd) [1,2,3]`
14:33:59 <solonarv> wildtrees: yes it can be done
14:34:19 <solonarv> but you need type-level strings and a handful of other type-level nonsense sprinkled in
14:34:39 <wildtrees> !!! solonarv , sounds like a bit 
14:35:42 <pounce> how do i implement Monad for a data type
14:36:05 <solonarv> pounce: how far have you gotten?
14:37:00 <pounce> ive created a data type, trying to figure out the `instance` syntax
14:37:24 <solonarv> do you have any sort of reference material to look at?
14:37:49 <pounce> im looking at the implementation for array right now https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#line-984 not sure if that's a good idea
14:37:58 <solonarv> it's not the best idea
14:38:02 <pounce> ah—
14:39:32 <monochrom> If your trouble is just syntax of "instance", you can start with Functor first.
14:39:53 <solonarv> yes, since you have to implement that anyway
14:40:02 <pounce> so is it that i have to do functor/applicative for monad?
14:40:10 <solonarv> btw a good resource to look up separate things is:
14:40:13 <solonarv> ?where wikibook
14:40:13 <lambdabot> http://en.wikibooks.org/wiki/Haskell
14:40:26 <monochrom> Yes. And Functor is less work, fewer moving parts, therefore less distracting.
14:40:47 <solonarv> in this case the page you want is: https://en.wikibooks.org/wiki/Haskell/Classes_and_types
14:40:56 <pounce> trying to think about how terrible of an idea this is
14:41:01 <EvanR> why are there no Functor tutorials
14:41:22 <monochrom> Higher ambition is usually more terrible.
14:41:32 <pounce> yeah lol
14:41:32 <EvanR> it's a pretty substantial subject
14:41:57 <solonarv> there are Functor tutorials though
14:42:02 <EvanR> really
14:42:02 <pounce> ok maybe i should say what im doing then
14:42:23 <solonarv> yes, but Functor seems to be more understandable even to FP newbies
14:43:05 <pounce> so i was doing advent of code day 5 , and i made this little emulator using emulator which used the IO monad to print/input results
14:43:08 <solonarv> so there is no sense of "oh! I have found the one true analogy that let me understand the great mystery of Functor! I must share this insight with others!"
14:43:13 <EvanR> i mean 'mappable' might be, but Functor carries some non trivial baggage
14:43:38 <monochrom> Everyone thought they understood functor and had trouble with monad.  Everyone is wrong.
14:44:03 <pounce> so i knew this is probably not what you have to do.. bc you could pass inputs in.. but anyway decided to do it to get exp. but now im doing something else with it and i have to string them together. so im like "oh" what if i make my own kind of IO monad with int inputs/outputs and use the same function with the different monad
14:44:20 <EvanR> that's what i'm saying, clearly everyone "gets" functor (even if they might be somewhat off) so why no rush to write up tutorials
14:44:50 <solonarv> pounce: that is actually a reasonable approach
14:44:53 <monochrom> They also envision that functor is too easy and unexciting to write a functor tutorial.
14:44:53 <EvanR> some kind of word inertia
14:45:09 <EvanR> monad is a thing that is hard to understand, functor is a thing in C++
14:45:12 <solonarv> EvanR: people do write tutorials, but they are quiet and unnoticed
14:45:25 <EvanR> example?
14:45:26 <pounce> and i was thinking you could probably generalize this as something like type IntIO a = [Int] -> ([Int],a) and implement the different functions but idk if it would work
14:45:35 <pounce> solonarv: oooh really 
14:45:35 <solonarv> I mean, https://en.wikibooks.org/wiki/Haskell/The_Functor_class
14:45:59 <solonarv> and I vaguely recall seeing some in passing
14:46:01 <monochrom> That's because it's a wikibook intended to be complete.
14:46:07 <solonarv> true
14:46:17 <monochrom> For the average bloggers they will skip functor any day.
14:46:42 <monochrom> "go to monad. don't pass functor, don't collect $200"
14:46:59 <solonarv> no! this is what we have the AMP for!
14:47:04 <EvanR> nice, it's the last chapter in intermediate haskell
14:47:09 <monochrom> heh
14:47:22 <EvanR> at least we can't claim "no respect"
14:47:57 <solonarv> pounce: and yes, that is a reasonable type to use
14:48:16 <solonarv> but if you want to write instances for it, you have to actually declare a new data type
14:48:33 <solonarv> you can't just use a type synonym
14:48:36 <pounce> ah makes senes
14:49:06 <pounce> oooh ok i didn't know if i was choosing a weird type, but i thought it might be something like State (and i know just _holding_ int arrays in the type won't work so it'd probably have to be an array)
14:49:32 <solonarv> important nitpick: [a] is not an array, it is a (lazy, linked) list
14:49:56 <monochrom> Yes it's similar to State.
14:50:02 <solonarv> and this is indeed what State looks like, but State is not precisely right for what you are doing there
14:50:15 <monochrom> You have a good idea, you just need the newtype technicality.
14:51:01 <monochrom> And your code will be full of unwrapping and rewrapping noise.
14:51:16 <solonarv> I would recommend going for a representation like: [Int] -> ([Int], [Int], a); one of the [Int]s in the return type is the "leftover" inputs, and the other one is the outputs produced by the intcode program
14:51:31 <pounce> ah good idea
14:51:33 <solonarv> you *can* do it without the "leftover inputs", but it will be much less convenient
14:51:46 <pounce> no that's what i was thinking i was just dumb
14:54:10 <pounce> ah, curious (a,b) is a functor but (a,b,c) isn't?
14:54:13 <wildtrees> pounce, sounds kind of like a parser 
14:54:38 <solonarv> eh, it's only very vaguely and abstractly like a parser
14:54:50 <jle`> pounce: not sure what you mean by your last question, but neither of those a Functors
14:54:56 <solonarv> pounce: (using pseudo-Haskell notation) (a, _) is a functor
14:54:58 <jle`> *are
14:55:03 <solonarv> so is (a, b, _)
14:55:15 <pounce> oh, hm
14:55:18 <jle`> > fmap (*2) (True, "hi", 3)
14:55:20 <lambdabot>  error:
14:55:20 <lambdabot>      • Could not deduce (Functor ((,,) Bool [Char]))
14:55:20 <lambdabot>          arising from a use of ‘fmap’
14:55:32 <jle`> huh, i guess there's no instance
14:55:33 <solonarv> oh really, it doesn't actually have the instance
14:55:35 <jle`> even though there could be.
14:55:38 <pounce> > fmap (*2) (1,2)
14:55:40 <lambdabot>  (1,4)
14:55:42 <solonarv> someone (who isn't me) should fix that :P
14:55:45 <pounce> that's what weirded me out
14:55:52 <solonarv> I mean, GHC even knows how to derive that instance!
14:55:53 <jle`> > fmap (*2) ("hi", 6)
14:55:57 <lambdabot>  ("hi",12)
14:57:35 <monochrom> > ("hell", sin) <*> ("o", 0.1)
14:57:38 <lambdabot>  ("hello",9.983341664682815e-2)
14:57:42 <monochrom> :)
14:58:25 <monochrom> But that's a digression.
14:58:41 <zeta_0> could someone send me a link to the ghc tickets?
14:58:44 <EvanR> > fmap (*2) (True, "h1", 3)
14:58:46 <lambdabot>  (True,"h1",6)
14:59:01 <monochrom> Hey should have done ("hell", sin) <*> ("fire", 666)
14:59:08 <EvanR> deriving instance Functor ((,,) a b)
14:59:09 <solonarv> zeta_0: this? https://gitlab.haskell.org/ghc/ghc/issues
14:59:31 <solonarv> EvanR: Warning [-Worphans]: ...
15:00:43 <zeta_0> i signed up for the ghc mailing lists but i haven't gotten any emails, how strange
15:00:49 <dsal> Who isn't a fan of worf?
15:02:23 <zeta_0> ok i found the link i was looking for nevermind
15:02:51 <monochrom> Most recent message on the ghc mailing list was December 12.
15:03:07 <monochrom> announcing 8.8.2 RC1
15:03:42 <phadej> ghc-dev isn't high traffic, that's nice
15:03:48 <solonarv> most recent email was december 15th, actually
15:04:09 <solonarv> still ~80 hours ago
15:04:11 <zeta_0> i subscribed to daily mail, maybe it takes a full day to send out mail, i don't know
15:04:57 <merijn> ghc-dev is super low traffic
15:05:12 <solonarv> yeah
15:05:18 <solonarv> as I said, last email was 80 hours ago
15:05:25 <pounce> hmm, would it be easier to implement <*> or liftA2
15:05:40 <monochrom> depends on you.
15:05:44 <zeta_0> oh, that's good do know
15:05:59 <monochrom> But looks like liftA2 is easier for most people
15:06:07 <pounce> oki
15:06:20 <solonarv> I personally tend to go for <*> because it is slightly shorter and I understand it well enough anyway
15:06:31 <solonarv> but liftA2 sure seems to be easier to wrap one's head around
15:07:10 <monochrom> The reason is that a lot of people still haven't coped with first-class functions.
15:08:10 <solonarv> when I was learning, I struggled to grasp why a container-full-of-functions was a relevant thing at all
15:08:26 <pounce> im having that thonk can u help explain
15:09:12 <pounce> is this kind of like >>= where im sequencing actions?
15:09:19 <solonarv> yes! exactly
15:09:24 <monochrom> Sometimes, a simpler thing is harder on most people, when the simplicity is caused by an abstraction --- most people can't do abstraction.
15:09:32 <solonarv> it is less general but does a similar sort of thing
15:10:22 <solonarv> (one might argue that it is *more* general, because you can implement it for more data structures)
15:11:00 <wildtrees> I often don't use containers of functions, am I missing out? 
15:11:08 <monochrom> No.
15:11:18 <solonarv> no, I don't often use them explicitly either
15:11:36 <EvanR> with Applicative you kind of can't avoid it (implicitly)
15:11:41 <solonarv> but they are an "intermediate" stage when you write f <$> foo <*> bar <*> baz <*> ...
15:11:52 <monochrom> The only requirement is that you don't freak out.
15:11:55 <wildtrees> often when I have a bunch of functions, they are usually of (slightly) different types and won't fit nicely into a container 
15:12:00 <solonarv> yep
15:12:49 <solonarv> oh no, it's late!
15:13:15 <EvanR> otoh when you have a function like a -> b -> c, and you map over a list of a's, you now have "a bunch of b -> c, all different, but same type"
15:13:39 <solonarv> yup, that's how you get a container of functions
15:13:41 <EvanR> and you probably proceed to map over b's
15:13:46 <EvanR> but you don't have to
15:13:50 * solonarv leaves now
15:14:29 <pounce> oh! ty for the help
15:16:25 <zeta_0> if i move a cloned git repository into another directory, everything should still work fine right?
15:18:27 <zeta_0> just double checking, it took me 40 minutes to build ghc, i don't want to have to do that again, for a while at least
15:20:02 <EvanR> only 40 ? wow
15:22:00 <zeta_0> EvanR: i built the Buildflovour = perf with 4 cores
15:23:34 <pounce> how's this look: https://files.catbox.moe/u0e9n7.png
15:24:10 <monochrom> why is it "catbox.moe" not "cabox.meow"? :)
15:24:33 <pounce> weebs
15:24:47 <pounce> also idk if there's a meow tld :?
15:28:01 <pounce> hmm maybe i should peek at how state does monad, not quite sure how to move forward
15:28:41 <monochrom> Your Applicative instance looks correct.
15:28:43 <pounce> \o/
15:28:57 <monochrom> IntIO is closer to RWS than State.
15:29:18 <monochrom> For example you have to do "o <> o'", that's what Writer does.
15:29:56 <pounce> makes sense
15:30:18 <monochrom> You just don't have the R part in RWS.
15:30:36 <pounce> oh, hm
15:30:39 <pounce> is the input not rs?
15:30:45 <pounce> r*
15:30:56 <pounce> or is that just the state
15:31:00 <monochrom> No, you have "inputlist -> (leftover, ...)", that's more like S.
15:31:08 <pounce> gotcha
15:34:35 <monochrom> Usually, if you survive <*>, then >>= is not too hard.
15:37:21 <zeta_0> could you guys help me find somthing good to start working on? https://gitlab.haskell.org/ghc/ghc/issues?label_name%5B%5D=newcomer
15:38:06 <zeta_0> this is my first time contributing to ghc so i am a little lost
15:38:22 <sshine> zeta_0, #ghc?
15:38:44 <sshine> zeta_0, not that you can't talk inhere, but maybe there will be more responses there. :)
15:39:07 <zeta_0> sshine: alright
15:44:00 <pounce> is there a way to "unbox" something i have in a newtype other than pattern matching
15:44:13 <Axman6> coerce
15:44:21 <monochrom> Aw, not so fast.
15:44:34 <Axman6> > coerce (IDentity True) :: True
15:44:37 <lambdabot>  error:
15:44:37 <monochrom> Write and name a simple function that does the unwrapping.
15:44:38 <lambdabot>      • Expected a type, but ‘True’ has kind ‘Bool’
15:44:38 <lambdabot>      • In an expression type signature: True
15:44:39 <Axman6> > coerce (Identity True) :: True
15:44:41 <lambdabot>  error:
15:44:42 <lambdabot>      • Expected a type, but ‘True’ has kind ‘Bool’
15:44:42 <lambdabot>      • In an expression type signature: True
15:45:06 <pounce> where can i get `coerce`?
15:45:22 <Axman6> > coerce (Identity True) :: Bool -- uh, obviously
15:45:28 <lambdabot>  error:
15:45:28 <lambdabot>      • Variable not in scope: coerce :: Identity Bool -> Bool
15:45:28 <lambdabot>      • Perhaps you meant ‘coerced’ (imported from Control.Lens)
15:45:33 <Axman6> -_-
15:46:49 <wildtrees> ok this snippet doesn't work, how would I use Equals? https://0paste.com/45143 
15:47:37 <Axman6> "doesn't work"?
15:48:07 <wildtrees> Expected a type, but `Equals Int Int' has kind `Bool' via loading a larger file into ghci 
15:48:19 <monochrom> Exactly what the error message says.
15:48:25 <Axman6> Tru Equals a a = 'True
15:48:34 <wildtrees> so how would or could I use Equals then? 
15:48:46 <wildtrees> so the kind needs to be * / Type? 
15:48:48 <monochrom> You cannot have a value of type Equals Int Int.  Wrong kind.
15:49:17 <monochrom> You can use it in another type sig.  And up to kind checking.
15:49:47 <monochrom> If you now say "that doesn't do anything", I agree.
15:50:21 <wildtrees> just munging something off of an old blog post, trying to figure out type families
15:51:32 <monochrom> If your goal is the simpler, humbler "I just want to learn type families", there are more elementary use cases than this.
15:52:05 <pounce> ooooh i think i finished Monad
15:52:09 <yasar> I am reading this : https://wiki.haskell.org/Calling_Haskell_from_C
15:52:11 <pounce> now i just gotta get printing/reading working
15:52:16 <monochrom> In fact there is a very convincing one in the GHC user's guide.
15:52:28 <yasar> I was wondering if you could only pass simple values between C and Haskell
15:53:10 <yasar> For example, can I a function like `lines` from C and get the list of strings back?
15:53:19 <yasar> call a function*
15:53:40 <monochrom> Only simple values, under an implicit assumption over your question.
15:53:43 <yasar> or does it have to be primitive types
15:54:14 <monochrom> The implicit assumption is "both the C side and the Haskell side can do much operations on the value passed".
15:54:49 <yasar> monochrom, for example, can I have an Haskell list converted to a C value?
15:55:08 <merijn> How much effort are you willing to invest?
15:55:10 <pounce> ooooh this part is actuallly not hard
15:55:12 <pounce> wooo
15:55:19 <monochrom> You will have to convert to a C array.
15:55:41 <monochrom> And subject to "can you convert individual elements?"
15:56:20 <monochrom> And I'm still speaking under the implicit assumption that no one has either confirmed or denied.
15:56:28 <monochrom> The usual disease of programmers.
15:56:54 <monochrom> Always talking about the data, never mentioning what you'll actually do (or don't) on them.
15:57:06 <monochrom> "how do I represent infinite sets?"
15:57:25 <monochrom> depends on what you will actually and what you won't actually do, no?
15:58:22 <monochrom> "how do I represent finite sets but OH SO EFFICIENTLY?"
15:58:44 <monochrom> "efficient" qualifies the operations, not the data structure or representation, no?
15:59:25 <monochrom> (and don't tell me "memory efficient" because seriously you didn't mean that.)
16:00:23 <monochrom> (you always mean "how to represent finite sets so the operations I have in mind are efficient BUT I WON'T TELL YOU WHICH")
16:01:35 <yasar> ok, for example, can I call a [String] -> String from C ? How would I represent [String] in C? How would haskell represent String in C?
16:02:28 <yasar> The thing I am curious is, how both world communicate data structures to each other
16:03:08 <monochrom> I learned these from the Haskell 2010 Report, the FFI chapter.
16:03:36 <monochrom> and also the docs of Foreign.C etc
16:04:57 <Axman6> Obviously there's going to need to be quite a lot of conversion. you'll probably need to convert to char ** and either put a null in the array at the end or pass the length as in int. the Strings wqill need to be packed, either into a char * or wchar* because String represents all unicide values, not just ASCII
16:05:05 <monochrom> I regret that there is no FFI tutorial you can search on the web that starts with the basics.  They all jump to the deep end and do advanced stuff on day 1.
16:05:23 <Axman6> generally, if you're going to work with C, then also working with [String] is probably a bad idea
16:05:35 <monochrom> Maybe I should write one, but I am already paid to do something else.
16:10:03 <wildtrees> I managed to get some basic ffi stuff working, with little experience in C and a few years of haskell, I found it easier then I thought, was a while ago though and windows specific 
16:10:38 <Axman6> monochrom: please write one, I will love you forever for it
16:15:21 <Axman6> I should get back to writing my cryoptonite bindings to WolfSSL
16:15:30 <Axman6> cryptonite*
16:20:18 <rmorrison> Why `isString` implementation of `ByteString` does not convert unicode characters? http://hackage.haskell.org/package/bytestring-0.10.10.0/docs/src/Data.ByteString.Internal.html#c2w
16:20:26 <rmorrison> https://paste.debian.net/1121618/
16:23:11 <Axman6> because ByteString isn't about unicode, it's about bytes. Text is about unicode
16:23:56 <Axman6> hmm, actually that usage is a bit confusing, I wouldn't have expected that either
16:24:18 <sshine> rmorrison, you can convert a ByteString that contains unicode using e.g. http://hackage.haskell.org/package/text-1.2.4.0/docs/Data-Text-Encoding.html
16:25:52 <Axman6> The comment under http://hackage.haskell.org/package/bytestring-0.10.10.0/docs/src/Data.ByteString.Internal.html#overflowError is amazing
16:26:52 <sshine> Axman6, I think that's an excerpt from the Necronomicon?
16:29:14 <pounce> im probably understanding list comprehensions wrong, but could i do other monadic computations in it? like l <- getLine
16:29:41 <rmorrison> pounce, you can with extensions, but you shouldn't
16:29:57 <pounce> oki
16:30:06 <pounce> what about in do forms
16:30:19 <pounce> like, c <- getContents; a <- arr
16:30:57 <Axman6> you can't mix differnt monads in a do block (or a list comprewhension, without an extension those are only for lists)
16:31:29 <pounce> okk sorry
16:31:44 <pounce> that makes sense tho
16:32:52 <rmorrison> pounce, you may want to read this to understand why https://en.wikibooks.org/wiki/Haskell/do_notation
16:42:27 <sshine> rmorrison, I guess IsString can't choose unambiguously what encoding to use.
16:46:11 <rmorrison> sshine, `isString :: String -> a` and `String` is UTF-32
16:47:53 <Axman6> I don't think that's an accurate charactisation of String. it is a linked list of unicode codepoints - UTF-32 is an encoding of unicode codepoints into bytes
16:54:22 <zeta_0> i am trying to print "hello world" n times, what is wrong with this code? https://gist.github.com/zeta-00/059a6121278703057225ad7b5d5637c7
16:55:45 <Axman6> Without an error, I have no idea
16:56:05 <MarcelineVQ> there is no error
16:56:18 <MarcelineVQ> did you mean to put n where 10 is?
16:56:59 <MarcelineVQ> I'd reccomend a 0 case for hello_worlds as well
16:58:26 <MarcelineVQ> or even a guard instead that checks if n is non-negative
16:59:46 <zeta_0> MarcelineVQ: how do i do that?
16:59:54 <MarcelineVQ> do which?
17:00:16 <zeta_0> MarcelineVQ: the guard
17:00:24 <pavonia> When it is negative, you have to input "hello world" |n| times to make it output nothing
17:01:02 <MarcelineVQ> https://en.wikibooks.org/wiki/Haskell/Control_structures
17:02:14 <MarcelineVQ> where your predicate is n > 0
17:02:18 <zeta_0> i could use haskells builtin functions, which would be much easier but i wanted to do it from scratch to get a deeper understanding
17:02:35 <EvanR> indeed utf-32 will necessarily involve endianness issues, for instance!
17:03:45 <EvanR> String decidedly doesn't
17:06:16 <zeta_0> something like this:
17:06:18 <zeta_0> hello_worlds n = | n <= 0 = Nothing
17:06:18 <zeta_0>                  | n >= 50 = Nothing
17:06:18 <zeta_0>                  | _ = do
17:06:18 <zeta_0>                      putStrLn "hello world"
17:06:18 <zeta_0>                      hello_worlds (n - 1)
17:06:36 <Axman6> Nothing is not IO
17:06:42 <Axman6> :t Nothing
17:06:44 <lambdabot> Maybe a
17:06:53 <Axman6> :t putStrLn "Hello world"
17:06:57 <lambdabot> IO ()
17:07:13 <Axman6> if you want a do- nothing IO action, you can use pure ()
17:07:14 <jle`> zeta_0: you imght want a "no-op" IO action
17:07:17 <jle`> *might
17:07:29 <jle`> which is pure x or return x, yeah
17:07:46 <jle`> zeta_0: Nothing isn't quite like null or etc. in other languages
17:08:01 <jle`> it's a constructor of a specific data type, like True or False 
17:08:04 <jle`> or [] or :
17:08:13 <ephemient> Left or Right :)
17:08:21 <pavonia> Do you still prefer `pure` when the context is clearly monadic?
17:08:22 <zeta_0> i think i will just stick to IO () , so what do i return in the 1st 2 cases?
17:08:39 <ephemient> return = pure
17:09:01 <jle`> zeta_0: reutrn ()
17:09:05 <jle`> * return ()
17:09:10 <jle`> zeta_0: you want "the no-op action"
17:09:18 <jle`> zeta_0: you're looking for the IO action that does nothing
17:09:34 <jle`> er, the IO action that represents "do nothing". in which case that's `pure _`, or `return _`
17:09:47 <jle`> where the _ is the result value you want that action to have
17:10:04 <jle`> zeta_0: basically, hello_worlds :: Int -> IO (), it is a pure function from Int to an IO action
17:10:15 <jle`> zeta_0: so you want helloWorlds 100 to evaluate to the IO action that does nothing
17:10:30 <EvanR> we don't need return and pure both, this side tangent proves it
17:10:46 <jle`> so hello_worlds 100 = return () literally means "the result of hello_worlds 100 is the IO action that does nothing"
17:11:04 <zeta_0> so something like this then?
17:11:06 <zeta_0> hello_worlds n = | n == 0 = "empty"
17:11:07 <zeta_0>                  | n < 0 = "negative"
17:11:07 <zeta_0>                  | n >= 50 = Nothing
17:11:07 <zeta_0>                  | _ = do
17:11:07 <zeta_0>                      putStrLn "hello world"
17:11:07 <zeta_0>                      hello_worlds (n - 1)
17:11:24 <Axman6> no, Strings and Nothing are not IO actions
17:11:34 <zeta_0> oh i forgot to change the 3rd case
17:11:39 <jle`> zeta_0: no, hello_worlds n | n == 0 = return ()
17:11:58 <jle`>    | n < 0 = return ()
17:12:00 <ephemient> it could be `return "empty"` if that's what you wanted
17:12:01 <jle`> etc.
17:12:07 <zeta_0> correction: n >= 50 = "too large"
17:12:21 <jle`> are you ... even reading anything we are writing, heh
17:12:23 <ephemient> although that's makes it not work great as a base case
17:12:34 <Axman6> Clearly not :\
17:13:08 <Axman6> zeta_0: if you're going to ask for help, the least you could do is read the help you're given :\
17:13:46 <zeta_0> sorry give me a second to catch up on the comments
17:15:50 <zeta_0> hello_worlds n = | n == 0 = return "empty"
17:15:50 <zeta_0>                  | n < 0 = return "too small"
17:15:50 <zeta_0>                  | n >= 50 = return "too large"
17:15:50 <zeta_0>                  | _ = do
17:15:50 <zeta_0>                      putStrLn "hello world"
17:15:50 <zeta_0>                      hello_worlds (n - 1)
17:16:15 <ephemient> that will type-check and run
17:16:25 <Axman6> I guess that works, but doesn't match what you said you wanted to do
17:16:29 <zeta_0> it's telling me parse error on |
17:16:37 <ephemient> `= |` is no good
17:16:58 <iqubic> Get rid of the "=" to the left of the | on line one
17:16:58 <ephemient> hello_worlds n | n == 0 etc.
17:17:10 <zeta_0> dam, sorry i missed that
17:17:13 <Axman6> | _ = do doesn't make sense. | otherwise = do willl work
17:17:38 <hpc> % otherwise
17:17:38 <yahb> hpc: True
17:18:00 <Axman6> buards must have a boolean expression
17:18:04 <zeta_0> https://www.hackerrank.com/challenges/fp-hello-world-n-times/problem
17:18:12 <Axman6> _ isn't an expression
17:18:17 <ephemient> also, you could write hello_worlds 0 = return "empty" {-new line-} hello_worlds n | n < 0 = ...
17:18:49 <zeta_0> i don't know if this solution is right for the hackerrank problem
17:19:02 <maralorn> Axman6: They could write "_ <- n" couldn‘t they?
17:19:40 <Axman6> probably, with ... pattern guards?
17:20:01 <maralorn> Yeah, that might be an extension.^^
17:20:19 <ephemient> pattern guards aren't part of the language yet?
17:20:51 <ephemient> yeah they're in Haskell2010, no extensions required
17:20:53 <zeta_0> https://gist.github.com/zeta-00/059a6121278703057225ad7b5d5637c7
17:21:43 <zeta_0> hackerranks compiler is throwing error, see my code is probably not correct
17:21:53 <Axman6> Are you sure you don't want hello_worlds n instead of hello_worlds 10?
17:22:01 <MarcelineVQ> Axman6: it's after that
17:22:35 <Axman6> oh
17:22:55 <MarcelineVQ> zeta_0: have you notice your indentation changes between your two versions? haskell is indentation-sensitive
17:23:00 <Axman6> I can;'t read that code without formatting
17:23:44 <zeta_0> the indentation is correct in emacs but when i pasted it in github gists, it did not paste correctly
17:23:54 <Axman6> you didn't paste it as code
17:24:19 <Axman6> you made a comment. oyu need to wrap the code in ```haskell\n<code lines here>\n```
17:24:33 <MarcelineVQ> or just add another file, or edit your original
17:24:44 <MarcelineVQ> reagrdless it's a good idea to include your error with your code
17:26:24 <Axman6> There is definitely too much code in that comment, but I can't tell what code it is without formatting. it looks like there's two definition of hello_world?
17:26:28 <zeta_0> in emacs it works but hackerrank doesn't like it
17:28:26 <zeta_0> https://hastebin.com/docatizaku.rb
17:29:53 <ephemient> ah, that won't exactly work because hello_worlds :: Int -> IO String while main :: IO ()
17:30:17 <Axman6> zeta_0: Imagine if I went to a mechanic bewcause my radio isn't working and said "my car doesn't work, please fix it" and they asked "What's wrong with it" and I just said "it doesn't work". The mechanic would spoend all their time trying to figure out what's wrong with the engine. you need to tell us what has actually gone wrong. We're trying to help you but you're not paying attention and not providing us with the information we need to hel
17:30:17 <Axman6> p you
17:30:58 <ephemient> there's a few solutions
17:31:05 <Axman6> we told you to just use return () and then you went off and started using return "empty" - what we told you to do would have worked, but you did something else which won't work
17:32:01 <ephemient> well it's illustrative, in a way
17:32:22 <ephemient> the type of a do { ... } block is the type of its last statement
17:32:57 <ephemient> so that alone should point you to a couple of ways to fix it, zeta_0 
17:33:24 <zeta_0> hackerranks error message: https://hastebin.com/ekagufuwop.coffeescript
17:33:27 <MarcelineVQ> zeta_0: The syntax issue you're having with hello_worlds has been addressed by Axman6 earlier so you should go back and read what's he's said so far
17:33:28 <zeta_0> Axman6: ^
17:34:01 <zeta_0> sorry guys, thanks for having patience
17:34:07 <MarcelineVQ> Oh it's not syntax issue, still that was addressed earlier
17:35:14 <Axman6> zeta_0: ok, new rule: if you get an error, you need to show us BOTH: ALL the code in the file, and all the errors, preferably in the same paste. Otherwise I'm done
17:35:57 <zeta_0> Axman6: ok, i'll show the code and error in hackerrank
17:37:34 <zeta_0> https://hastebin.com/okiwakoban.coffeescript https://hastebin.com/edumopekos.rb
17:38:17 <sshine> Axman6, every time I go to the doctor and think I have an idea of what's wrong with me, my doctor always tends to prefer that I shut up about my internet research theories.
17:39:00 <MarcelineVQ> sshine: time to upgrade to a new model
17:40:11 <zeta_0> so insteadof _ = do , i need to put: n = do
17:40:26 <dmwit> zeta_0: Literally the first suggest fix for that error is correct.
17:40:26 <zeta_0> that is where the error is pointing to?
17:40:27 <MarcelineVQ> is n a Bool?
17:40:39 <dmwit> The error *says* what to do to fix it.
17:41:19 <Axman6> sshine: I'm sure you usually say "I have a sore knee" or "I think I have a cold", not "help me, but I won't tell give you any information about what with"
17:42:51 <zeta_0> https://hastebin.com/ulunagojix.coffeescript https://hastebin.com/epabebebez.coffeescript
17:43:00 <zeta_0> i am making progress
17:43:33 <Axman6> n isn't a Bool
17:44:01 <Axman6> 12:16         Axman6: | _ = do doesn't make sense. | otherwise = do willl work 
17:46:05 <zeta_0> https://hastebin.com/vabaxefihu.rb
17:47:46 <Axman6> does it work?
17:48:22 <zeta_0> compiler message: wrong answer
17:50:35 <MarcelineVQ> that's not quite a compiler messages, hackerrank, but that'll be due to your guards, they're slightly too restrictive.
17:50:49 <zeta_0> 0 <= n<= 50, i think i messed up on the constraints
17:50:52 <MarcelineVQ> n is allowed to be anywhere from 0 to 50,but your guards don't allow 50
17:51:15 <iqubic> Ah I see the issue here.
17:52:11 <zeta_0> hello_worlds n | n < 0 = return ()
17:52:11 <zeta_0>                | n >= 0 = return ()
17:52:12 <zeta_0>                | n <= 50 = return ()
17:52:12 <zeta_0>                | otherwise = do
17:52:12 <zeta_0>                      putStrLn "hello world"
17:52:12 <zeta_0>                      hello_worlds (n - 1)
17:52:35 <Axman6> that looks wrong to me
17:52:53 <Axman6> just use n > 50 instead of n >= 50
17:53:05 <sshine> zeta_0, were you the guy who asked how to contribute to GHC earlier?
17:53:10 <MarcelineVQ> | n >= 0 = return ()   is going to be a bad time
17:54:07 <sshine> zeta_0, maybe you should check out https://exercism.io/my/tracks/haskell
17:54:37 <Gcf> Has anyone gotten the Haskell IDE Engine to work with multiple executables in a project?
17:54:52 <zeta_0> sshine: yes, there are tickets tagged beginner that i am going to contribute to, i clone ghc then cloned ghc.nix in ghc/ then built ghc without too much much problems but ya i am a little over my head
17:56:05 <zeta_0> i used to be really good with java(i built android apps) but learning haskell is very different, imperative to declarative forces the brain to think differently
17:57:12 <Axman6> zeta_0: FYI, the simple solution to the problem you've been given is: hell_world n | n > 50 = pure () | otherwise = replicateM n (putStrLn "Hello, world")
17:57:56 <Axman6> or simple helo_world n = guard (n <= 50) $ replicateM n (putStrLn "Hello, world"
17:58:18 <zeta_0> Axman6: yes, like i said earlier, i did not want to use the builtin functions, i wanted to do this from scratch with recursion
17:58:43 <Axman6> :thumbsup:
17:59:08 <zeta_0> Gcf: i got hie to work, but with nix
17:59:37 <zeta_0> Axman6: alright i'll use the simple solution so i can move on
18:00:23 <Axman6> make your solution work first
18:01:35 <MarcelineVQ> your solution was there, you just had too permissive a check for 50.   n is allowed to be 50 so    n <= 50 = return ()  is wrong which says if you're 50 or more return () instead of printing
18:02:38 <MarcelineVQ> I mistypes that :( I meant     | n >= 50 = return ()
18:03:16 <rmorrison> Can I do at least something with this thingy? `T.unpack . TE.decodeUtf8 . BL.toStrict . B.toLazyByteString $ B.char8 '?' <> opts `
18:04:19 <Clint> i imagine that you can
18:04:32 <rmorrison> `Text.Lazy` also has `unpack` I should use it, yep!
18:05:13 <Axman6> what is the type of  B.char8 '?' <> opts?
18:05:38 <Axman6> better question, what are you actually trying to do?
18:06:12 <Axman6> there's also Data.Text.Lazy.Encoding right?
18:06:35 <rmorrison> I'm building url from `ByteString`s and then convert it to `String` because library asks for it
18:09:52 <Axman6> any reason not to use one of the libraries for dealing with uris)?
18:10:42 <rmorrison> I did, but they all use `Text` and `decodeUTF8` inside
18:10:50 <rmorrison> And I need `decodeASCII` 
18:11:01 <rmorrison> (which is deprecated, so I have to emulate it anyway)
18:11:09 <Axman6> https://hackage.haskell.org/package/uri-bytestring-0.3.2.1/docs/URI-ByteString.html ?
18:12:06 <rmorrison> Oh, no, I meant libraries which build up on them. I haven't seen this one, thank you
18:14:04 <avp_> is there an equivalent to `read` for ints? like a typeclass that allows the type to be made from Integral instead of from String --- just curious mostly
18:14:25 <Axman6> fromInteger . read?
18:15:48 <avp> i don't think that's quite what I'm asking - what if i had `data Bit = Zero | One` ....is there a best-practice way to take 1 and 0 and turn them into a Bit?
18:16:24 <Axman6> fromInteger, if you want to work with literal integer values in haskell source code
18:16:41 <Axman6> > 1 :: Expr
18:16:43 <lambdabot>  1
18:17:25 <Axman6> % :info Num
18:17:26 <yahb> Axman6: class Num a where; (+) :: a -> a -> a; (-) :: a -> a -> a; (*) :: a -> a -> a; negate :: a -> a; abs :: a -> a; signum :: a -> a; fromInteger :: Integer -> a; {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}; -- Defined in `GHC.Num'; instance Integral a => Num (Ratio a) -- Defined in `GHC.Real'; instance Num Int8 -- Defined in `GHC.Int'; instance Num Int64 -- Defined in `G
18:18:14 <avp> ok so i guess the solution would just be to implement the Num typeclass for Bit
18:22:16 <EvanR> rmorrison: the encoding package has utilities to decode ASCII
18:23:06 <EvanR> (deprecated: use decodeUtf8 as stated is wrong)
18:25:51 <phadej> there is decodeLatin1
18:25:56 <phadej> decodeASCII is /wrong/
18:25:58 <EvanR> ascii package has utilities for remembering the data is ascii
18:26:23 <EvanR> how is decodeASCII wrong
18:26:25 <phadej> ascii is 7bit
18:26:44 <phadej> you probably want Latin1 / ISO-8859-1 which is 8bit encoding
18:26:46 <EvanR> so part of the decode process should verify the 8th bit is 0
18:26:59 <EvanR> the task of decoding can't choose what the source format is
18:27:10 <phadej> the wrong part of decodeASCII it's type, it implies it couldn't fail
18:27:24 <EvanR> the "use utf8 instead" part is also wron
18:27:51 <EvanR> use latin1 instead is wrong
18:27:54 <phadej> well, not really, you can decode as it were utf8 (as ASCII stream is valid utf8 stream), and then verify that there aren't codepoints over 127
18:28:16 <EvanR> that is entirely what decoding ascii is
18:28:39 <EvanR> and why you'd want it to be a library function
18:29:36 <phadej> maybe
18:30:06 <phadej> currently it's decodeASCII = decodeUtf8
18:30:10 <phadej> so I wouldn't use it :)
18:31:55 <nyc> What about nonstandard Unicode characters? Usually it's things carved out of the BMP PUA for UCSUR or applicants thereto.
18:32:42 <EvanR> i see no way for those unicode characters to appear in a supposed ascii stream
18:32:58 <Clint> UTF-7
18:33:45 <nyc> Oh, I was more concerned about things like the predicates as to whether things were capital or small case or other characteristics.
18:34:40 <rmorrison> Yay! It took me a couple of days of fighting with Haskell and now I finally can send correct `GET` requests 
18:34:52 <EvanR> those are features of Char
18:34:58 <EvanR> not encodings
18:40:21 <kronicmage> @free const :: a -> b -> a
18:40:21 <lambdabot> f . const x = const (f x) . g
18:41:46 <rmorrison> @free map :: (a -> b) -> f a -> f b
18:41:46 <lambdabot> Extra stuff at end of line
18:42:11 <rmorrison> @free map :: (a -> b) -> [a] -> [b]
18:42:11 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
18:42:57 <rmorrison> @free foldr :: (a -> b -> b) -> b -> [a] -> b
18:42:57 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
18:51:24 <Ailrun[m]> @pl \a b -> take b a
18:51:24 <lambdabot> flip take
18:53:17 <Ailrun[m]> @version
18:53:17 <lambdabot> lambdabot 5.2
18:53:17 <lambdabot> git clone https://github.com/lambdabot/lambdabot
18:55:58 <sm[m]> rmorrison: achievement unlocked! 👍🏻
19:03:19 <maerwald> is safe-exceptions still maintained or are people supposed to use unliftio?
19:06:36 <suzu> for exception handling, you should use safe-exceptions
19:07:24 <suzu> or so snoyman says
19:07:30 <Ailrun[m]> @listmodules
19:07:30 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
19:07:30 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
19:07:55 <Ailrun[m]> @list dice
19:07:55 <lambdabot> dice provides: dice roll
19:08:06 <Ailrun[m]> @help dice
19:08:06 <lambdabot>  @dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
19:08:18 <Ailrun[m]> @help roll
19:08:18 <lambdabot>  @dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
19:09:52 <Ailrun[m]> @roll 4d4+1
19:09:52 <lambdabot> Ailrun[m]: 10 + 1 => 11
19:10:09 <glguy> You can play with lambdabot in private message
19:15:14 <pounce> is there a functiowhich given a list yields all lists using those elements for a certain length
19:16:10 <pounce> i.e. something like [[a1,a2,a3,a4]|let l=[0..4],a1<-l,a2<-l,a3<-l,a4<-l] 
19:16:57 <ephemient> > take 10 $ replicateM 4 [0..4]
19:16:59 <lambdabot>  [[0,0,0,0],[0,0,0,1],[0,0,0,2],[0,0,0,3],[0,0,0,4],[0,0,1,0],[0,0,1,1],[0,0,...
19:18:35 <ephemient> guess I didn't need `take 10` if lambdabot was gonna truncate the output on its own, but anyhow
19:21:24 <ephemient> basically, replicateM n m = do a <- m; b <- m; ... (n times); return [a, b, ...]
19:22:20 <ephemient> if m is a list, then you see how this lines up with the list comprehension you just wrote
19:22:39 <pounce> hm
19:32:30 <pounce> why does it return a seq and not a list
19:39:54 <dmwit> It returns a list.
19:39:56 <dmwit> What is a seq?
19:41:16 <dmwit> Maybe it is best to ask: what evidence makes you conclude that it returns a seq?
19:43:20 <pounce> lol read the problem wrong i don't even need this lol
19:43:30 <pounce> :t replicateM
19:43:32 <lambdabot> Applicative m => Int -> m a -> m [a]
19:43:36 <pounce> huh
19:44:02 <monochrom> You can instantiate m to [] so you have Int -> [a] -> [[a]]
19:44:32 <monochrom> And you can easily test it to see what it does.
19:44:58 <dmwit> > replicateM minBound [1..]
19:45:01 <lambdabot>  [[]]
19:45:08 <dmwit> > replicateM 10 []
19:45:10 <lambdabot>  []
19:45:21 <dmwit> I conclude that it is a boring function that only does boring things.
19:45:32 <monochrom> All is boring.
19:45:50 <dmwit> > mempty :: All
19:45:54 <lambdabot>  All {getAll = True}
19:45:59 <dmwit> \bot agrees with you
19:46:17 <dmwit> I was sort of hoping the answer would print as "All True", which would have made for a better joke. Oh well.
19:46:29 <monochrom> And I was just watching the movie "All Is True" a couple of days ago.
19:46:53 <glguy> It's the Southern version, kind of like "all'get'all"
19:46:56 <monochrom> And yeah to hell with record syntax and do-gooder field names.
19:47:39 <glguy> cf. all y'all
19:47:44 <monochrom> especially those who can't make up their minds whether they are field names or getter names.
19:50:11 <suzu> all y'all are havin a ball, are y'all?
19:50:28 <suzu> say it ten times real fast
19:51:03 <monochrom> let's make it a rondo and fugue
20:06:35 <username> hi!
20:06:43 <username> anyone here?
20:08:23 <glguy> Yes, lots of people are here
20:08:49 <username> yea
20:10:42 <username> im new with linux, so when install ubuntu i chose small package,
20:11:01 <username> how to download normal package for now?
20:18:42 <glguy> username: What small package?
20:19:15 <username> when i installing ubuntu, they told me to chose one
20:19:44 <username> small package will contain less app
20:20:13 <glguy> You should register a nickname and join #ubuntu if you have Ubuntu questions
20:20:23 <glguy> This channel is about the progrmaming language "Haskell"
20:55:21 <Axman6> How do so many people stumble into this channel when they first join IRC
20:57:35 <iqubic> No idea. But that is a certain trend.
21:30:31 <nshepperd2> probably some irc client that shows a list of channels when you connect, sorted by number of users
21:31:25 <nshepperd2> so people just end up blindly clicking #haskell because it is (or was?) the biggest
21:31:45 <Axman6> one of the biggest, never been the biggest
21:31:50 <Axman6> IIRC
22:17:44 <olligobber> when you write [a+1..0] instead of [a+1,a..0]
22:19:02 <Axman6> @src enumFromTo
22:19:02 <lambdabot> Source not found. It can only be attributed to human error.
22:19:02 <ski> the former steps "upward", the latter "downward"
22:19:32 <olligobber> yeah, I was getting the empty list instead of what I wanted
22:20:08 <ski> unless `a' is negative
22:24:42 <ephemient> then it's counting up to 0, which doesn't look like what was intended (?)
22:28:58 <Axman6> enumFromTo calls succ on the first argument until the value is greater than or equal to the second. [a..b] = enumFromTo a b
22:45:54 <bahamas> this error message is wrong: https://bpaste.net/show/DRIS6. is this a known issue?
22:46:42 <Axman6> it's S.(!&)
22:46:55 <Axman6> annoyingly enough
22:47:11 <iqubic> What?!?!
22:47:45 <bahamas> Axman6: I made a typo there. the operator uses a pipe `|` rather than an exclamation mark
22:48:06 <bahamas> and this works :t (S.|&)
22:48:24 <Axman6> hmm
22:48:42 <iqubic> I guess the error message was right after all.
22:49:04 <bahamas> iqubic: in what way?
22:49:42 <iqubic> The error message suggeste that you might want to use S.|&.
22:49:48 <iqubic> Which turned out to be the case.
22:51:21 <bahamas> iqubic: yes, but it says after that "No module named ‘S’ is imported." which is wrong
23:23:56 <amalloy> bahamas: i suppose technically no single module named S is imported. it would be more useful to instead be told there are multiple modules named S
23:25:25 <iqubic> amalloy: Are you ever going to upload the rest of the AoC 2019 solution videos?
23:25:58 <jle`> bahamas: yeah i get it all the time, it's pretty annoying
23:26:08 <jle`> it seems to be only in ghci
23:38:34 <bahamas> jle`: I wonder if anyone reported it. it looks like a small enough bug for people not to find enough motivation to open an issue and/or fix it
23:38:58 <jle`> i wouldn't be surprised
23:39:00 <jle`> D:
23:41:05 <amalloy> iqubic: probably not. i'm not that excited about doing the remaining puzzles
23:48:00 <iqubic> amalloy: Do you care to explain why you don't want to continue AoC? I'd understand if it's personal though.
23:52:59 <opqdonut> are they super imperative again?
23:53:09 <opqdonut> (I'm skipping this year but that's definitely been the theme)
23:53:15 <iqubic> Not that I can tell.
23:53:35 <opqdonut> (the theme in previous years I mean)
23:54:50 <lavalike> int-e: I used your imperative trick in an advent of code program today: begin | y <- 50, Just x <- L.findIndex (act mem) [ (x,y) | x <- [0..] ] = (x,y)
