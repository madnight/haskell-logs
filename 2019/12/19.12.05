00:00:10 <evelyn> that is, we can't infer some type a from Char
00:00:30 <evelyn> if we leave out the Num from the second example, it can't infer Num either.
00:00:59 <maerwald> I'm still amazed that you cannot ctrl+c a cabal that has more than one job
00:01:48 <maerwald> it just keeps running, requires me to log in via a second terminal and kill the docker container
00:02:00 <evelyn> Now compare something like ["Hello", "World"] :: (forall a. IsString a => [a])
00:03:16 <bahamas> ovitus: look inside the cabal file for the executable section. then try to run the command again with tidal.<executable_name>
00:06:48 * haskelllisp[m] uploaded an image: image.png (232KB) < https://matrix.org/_matrix/media/r0/download/matrix.org/fRIpAiJhKWxRlWyDfbipOrXU >
00:07:02 <ovitus> don't see it
00:07:20 <ovitus> https://github.com/tidalcycles/Tidal/blob/master/tidal.cabal
00:11:22 <haskelllisp[m]> evelyn: because of  `Char` isn't really polymorphic?  use `Num` or `IsString` can success
00:11:53 <boxscape> haskelllisp[m] only the empty list or a list of bottom values can be of type `forall a . a`
00:12:39 <boxscape> or rather
00:12:40 <iqubic> What does a thing of type "State (Int, Seq Int) Int" mean?
00:12:43 <boxscape> forall a . [a]
00:12:52 <bahamas> ovitus: ok. it doesn't have an executable, which makes sense because it seems to be a library
00:13:10 <boxscape> @unmtl State (Int, Seq Int) Int
00:13:10 <lambdabot> Int -> Seq Int -> (Int, Int, Seq Int)
00:13:22 <boxscape> more or less this with added data constructors
00:13:26 <bahamas> ovitus: that means you want to create a project of your own and import tidal and do whatever
00:13:48 <bahamas> ovitus: or maybe it has an example project somewhere in the repo. you can run that with v2-run
00:13:48 <iqubic> Nevermind, I figured it out.
00:15:48 <haskelllisp[m]> 雲裡霧裡
00:16:23 <ovitus> [awright@t460 Tidal]$ cabal v2-run Tidal.cabalResolving dependencies...cabal: Could not resolve dependencies:[__0] trying: tidal-parse-0.0.1 (user goal)[__1] next goal: tidal (dependency of tidal-parse)[__1] rejecting: tidal-1.4.5, tidal-1.4.4, tidal-1.4.3, tidal-1.4.2,tidal-1.4.1, tidal-1.4.0, tidal-1.3.0, tidal-1.2.1, tidal-1.2.0,
00:16:23 <ovitus> tidal-1.1.2,tidal-1.1.1, tidal-1.1.0, tidal-1.0.14, tidal-1.0.13, tidal-1.0.12,tidal-1.0.11, tidal-1.0.10, tidal-1.0.9, tidal-1.0.8, tidal-1.0.7,tidal-1.0.6, tidal-1.0.5, tidal-1.0.4, tidal-1.0.3, tidal-1.0.2, tidal-1.0.1,tidal-1.0.0, tidal-0.9.10, tidal-0.9.9, tidal-0.9.8, tidal-0.9.7, tidal-0.9.6,tidal-0.9.5, tidal-0.9.4, tidal-0.9.3,
00:16:24 <ovitus> tidal-0.9.2, tidal-0.9.1, tidal-0.9,tidal-0.8.2, tidal-0.8.1, tidal-0.8, tidal-0.7.1, tidal-0.7, tidal-0.6,tidal-0.5.3, tidal-0.5.2, tidal-0.5.1, tidal-0.5, tidal-0.4.36, tidal-0.4.35,tidal-0.4.34, tidal-0.4.33, tidal-0.4.32, tidal-0.4.31, tidal-0.4.30,tidal-0.4.29.1, tidal-0.4.29, tidal-0.4.28, tidal-0.4.27, tidal-0.4.26,tidal-0.4.24,
00:16:24 <ovitus> tidal-0.4.23, tidal-0.4.21, tidal-0.4.20, tidal-0.4.19,tidal-0.4.17, tidal-0.4.16, tidal-0.4.15, tidal-0.4.14, tidal-0.4.13,tidal-0.4.12, tidal-0.4.11, tidal-0.4.10, tidal-0.4.9, tidal-0.4.8,tidal-0.4.7, tidal-0.4.6, tidal-0.4.5, tidal-0.4.4, tidal-0.4.3, tidal-0.4.2,tidal-0.4.1, tidal-0.4, tidal-0.3.9, tidal-0.3.8, tidal-0.3.7,
00:16:25 <ovitus> tidal-0.3.6,tidal-0.3.5, tidal-0.3.4, tidal-0.3.3, tidal-0.3.2, tidal-0.3.1, tidal-0.3,tidal-0.2.13, tidal-0.2.11, tidal-0.2.10, tidal-0.2.9, tidal-0.2.7,tidal-0.2.6, tidal-0.2.4, tidal-0.2.3, tidal-0.2.2.8, tidal-0.2.2.7,tidal-0.2.2.6, tidal-0.2.2, tidal-0.2.1, tidal-0.2, tidal-0.1.0.1, tidal-0.1(conflict: tidal-parse => tidal>=1.4.6)[__1] fail
00:16:25 <ovitus> (backjumping, conflict set: tidal, tidal-parse)After searching the rest of the dependency tree exhaustively, these were thegoals I've had most trouble fulfilling: tidal-parse, tidal
00:17:00 <ovitus> that's after I ran cabal init -n --is-executable
00:19:22 <bahamas> ovitus: if you have output that is more than a few lines long, please use a pastebin service, because you're flooding the channel. you can use bpaste.net, for example
00:20:52 <bahamas> ovitus: I assume you ran that inside the Tidal repo, right?
00:21:32 <ovitus> yeah inside the git repo
00:34:51 <bahamas> ovitus: I don't think cabal init works for projects that already have a cabal file
00:35:33 <bahamas> ovitus: I want to see, it looks like you don't know Haskell and are trying to find your way around. what are you actually trying to achieve with this tidal library?
00:35:50 <bahamas> *I want to say
00:37:09 <ovitus> true, I'm new to Haskell and am far from proficient with it
00:38:44 <ovitus> trying to fix an issue with these shared/state variables
00:39:13 <bahamas> ovitus: have you followed the documentation here https://tidalcycles.org/index.php/Userbase
00:39:16 <ovitus> might just need to modify some types in the source code, that's why I wanted to make some modifications
00:39:29 <bahamas> I assume it gets you on your way to have a running project with an executable
00:39:43 <bahamas> ovitus: yes, but if you don't know Haskell, that's very likely going to be hard
00:40:05 <bahamas> because you can't modify types without modifying the rest of the code that deals with them
00:40:08 <ovitus> I've read through Haskell Book, gotta start somewhere
00:40:20 <ovitus> true, i'd like to see if that's the case though
00:41:55 <hansbrom> Whats the best way to install a private hackage-server? I am currently trying to install via ghcup (ghc 8.0.2, cabal 3.0.0) and cabal install hackage server but, cabal tells me it cant resolve dependencies.
00:42:10 <hansbrom> stdout is: https://gist.github.com/rmeis/d40e7499f4cbd38ebdf87f6ffe444ab6
00:43:07 <sclv> 8.0.2 is too old
00:43:20 <sclv> Use 8.6
00:45:15 <hansbrom> thanks, will give it a try
00:47:15 <bahamas> ovitus: well, if you're just trying to modify the library, make your changes to the code and then run cabal new-build to compile
00:47:20 <bahamas> then follow the trail of errors
00:52:55 <ovitus> looks like it just loads ghci and imports a module "import Sound.Tidal.Context"
00:53:12 <ovitus> but why can't I find that module in any of my directories?
00:57:14 <hansbrom> sclv unfortunately does not solve the dependency issue
00:58:23 <sclv> has
00:58:37 <sclv> hansbrom: wait are you installing from hackage!?
00:58:45 <sclv> that version is ancient
00:58:53 <sclv> You need to use the github repo
01:00:20 <hansbrom> yes from hackage, OK, i will try the github repo
01:01:15 <boxscape> is there a Traversal for lines? so you can do something like `str $ lines' %~ drop 1` instead of `unlines . drop 2 . lines $ str`?
01:12:12 <Solonarv> there is one for 'words', namely 'worded'
01:12:18 <Solonarv> so maybe there is a 'lined'?
01:12:37 <Solonarv> otherwise you can build it yourself: lined = iso lines unlines . traverse
01:12:49 <boxscape> lined does exist, thanks
01:37:57 <merijn> Aww...today is going make me ruin my nicely pure AoC computer with IO :(
01:42:03 <bahamas> in ghci, :{:} seems to be more versatile, isn't it? I mean, I can use any kind of syntax to define a sum type
01:42:24 <bahamas> with multiline mode on the other hand, putting `=` on a newline causes an error
01:42:41 <iqubic> Do indexed lenses for Data.Sequence exist?
01:43:55 <EvanR> merijn: perhaps this is a lesson for hypothetical app developers in haskell
01:44:03 * bahamas bahamas wonders if the lack of symmetry in :{ :} is an accident of history or there's some reasoning behind it
01:44:05 <merijn> EvanR: Hmm?
01:44:25 <EvanR> got the requirements, let's write it all without IO. requirements change... dammit :)
01:44:48 <merijn> EvanR: Oh, rewriting it is trivial
01:44:50 <iqubic> I would really like to have some indexed lenses for my sequence here right now.
01:45:06 <boxscape> bahamas every command in ghci starts with :
01:45:08 <merijn> EvanR: Like, 0 effort probably a lot less than any other language
01:45:18 <EvanR> i kind of believe you
01:45:26 <bahamas> boxscape: yes, that part is clear. I mean, why isn't it :{ }: ?
01:45:38 <boxscape> bahamas because then the second command wouldn't start with :
01:45:45 <merijn> EvanR: The problem is that I need to add input/output instructions and wrapping my pure evaluator with IO modes is more work than inlining the IO in the interpreter (as opposed to the current ST)
01:46:02 <bahamas> boxscape: ah, :} is a closing command. that makes sense. thank you!
01:46:45 <lavalike> can one use ghcid to build and run the program so that it shows its errors instead of ghci's errors?
01:47:07 <merijn> lavalike: Yes, but don't ask me how :p
01:47:12 <lavalike> well....
01:48:18 <boxscape> bahamas the syntax is also already taken: typing the lines :{ // do {a <- Just 4; pure a // }: // :} is currently valid (\\ meaning new line)
01:49:05 <boxscape> uh, // meaning new line
01:50:05 <boxscape> oh I did it wrong
01:50:17 <boxscape> it should be :{ // do {a <- Just 4; pure a // }: [] // :}
01:52:09 * hackage mason 0 - Fast and extensible bytestring builder  https://hackage.haskell.org/package/mason-0 (FumiakiKinoshita)
01:53:47 <bahamas> boxscape: that makes sense. the ending of the do block and the list constructor
01:53:54 <boxscape> exactly
01:54:11 <bahamas> I'm glad I expressed my curiousity regarding this :)
01:54:31 <boxscape> that's generally a good thing to do :)
01:55:39 <bahamas> I agree :)
02:02:29 <earthy> why would you actually need true IO rather than some way of injecting an stream of input?
02:04:28 --- mode: karatkievich.freenode.net set +o Sigyn
02:15:12 <__monty__> bahamas: Reason is probably consistency. It's :load and :m +Mod, not load: or m: +Mod.
02:16:02 <bahamas> __monty__: yes, it makes sense. I just didn't look at :} like a command that tells ghci to stop multiline mode
02:16:29 <bahamas> I was seeing it more in the sense of html for example or the syntax that ends a multiline comment
02:17:43 <boxscape> it would actually be enough to have one command instead of two, since you can't use :{ inside of a multiline block and can't use :} outside of it
02:19:44 <bahamas> boxscape: and signal the end of the multiline block with a newline?
02:20:33 <__monty__> No, end it with :{ again.
02:20:54 <__monty__> Though you could make a double blank line special but that's uglier.
02:22:26 <boxscape> though I would chose a different name for the command in that case
02:23:35 <bahamas> boxscape: what name?
02:24:17 <boxscape> hm, I'm not sure. Something less asymmetric than :{.
02:25:07 <bahamas> I find that if you gave to :{ both the "start" and "end" meaning, it would be harder to distinguish visually where you're in multiline mode and where you're outside
02:25:15 <boxscape> that's fiar
02:25:15 <bahamas> if you wrote this in a file.
02:25:20 <boxscape> s/fiar/fair
02:25:36 <boxscape> though I have never seen someone write multiline ghci blocks in a file
02:45:50 <iqubic> I have a lens question that I need help with. How can I use an indexed setter to set a particular value in a Sequence. From Data.Seq in containers.
02:48:17 <__monty__> bahamas: Easily solved by indenting the blocks.
02:51:32 <boxscape> or you could just use indentation to signify a multiline block, which means you don't need any commands :)
02:54:23 <nil> is there a MonadIO/liftIO equivalent for ST?
02:54:41 <infinity0> nil: PrimMonad from primitives
02:54:59 <nil> thanks
02:58:11 <nil> or MonadST from monad-st, i guess
03:05:48 <infinity0> nil: one of my ex-colleagues who was more familiar with the haskell ecosystem told me that PrimMonad is newer and preferred over MonadST, so that's what we had used
03:06:33 <infinity0> iirc he told me that ekmett (the author of MonadST) recommends people use PrimMonad instead
03:07:33 <nil> ok
03:14:30 <absence> how can i factor out the repetition in the last three lines here? https://pastebin.com/v1m2qrp1
03:14:58 <absence> it uses the composite libraries, but i'm guessing/hoping this can be done in a non-library-specific way
03:32:39 * hackage mmsyn6ukr 0.4.0.0 - A musical instrument synthesizer or a tool for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.4.0.0 (OleksandrZhabenko)
03:38:56 <iqubic> I'm loving this combination of lens and state right now. It's the most awesome thing ever.
03:40:29 <boxscape> last time I did that I ended up terribly overusing `zoom`
03:46:00 <nil> iqubic: i'd like to see what that looks like
03:52:28 <boxscape> nil here are some Stateful lensic functions I wrote a few years ago (didn't use zoom as much as I thought, actually) https://github.com/JakobBruenker/assembler/blob/master/app/Main.hs#L361-L432
03:55:02 <iqubic> nil: What do you mean?
03:55:47 <iqubic> I've been working on Day 5 of advent of code. Here's what I've got so far.
03:56:46 <iqubic> Here's another section of the same file: http://dpaste.com/2A0KX47
03:57:44 <iqubic> I love where this is going.
03:59:16 <nil> boxscape: thanks, that looks interesting
03:59:33 <jpcooper> Hello. How can I define the kind, "All type-level lists of all types which satisfy a constraint C"?
03:59:39 <nil> iqubic: just curious what the most awesome thing ever looks like
04:00:25 <iqubic> I'm just finding this code so simple to write.
04:01:29 <iqubic> I never have to worry about manually manipulating the values in the record explicitly.
04:01:48 <Ariakenom> absence: you can probably factor out "coRec @FCaseX" and make a function of the rest
04:02:42 <boxscape> sounds like maybe you want a constraint rather than a kind? i.e. something like `AllHave :: (Type -> Constraint) -> [Type] -> Constraint`?
04:03:13 <jpcooper> boxscape: I defined a type family which defines the constraint I want, but I was wondering whether I could define a kind for that instead
04:04:15 <jpcooper> So that I could define a GADT as follows: data G (t :: SPECIALKIND) where ...
04:05:36 <aplainzetakind> iqubic: Why is input a list? In anticipation of future puzzles?
04:05:44 <jpcooper> It's not too important. I will just use constraints where needed
04:06:52 <boxscape> I suppose you could have `data SpecialList :: Constraint -> [Type] -> Type where MkSpecialList :: AllHave c l -> SpecialList c l` and then use `data G (t :: SPECIALKIND)`, jpcooper. Not sure if that would be better.
04:07:22 <boxscape> uh, then use `data G (t :: SpecialList c l)`, I mean
04:07:46 <boxscape> (also not 100% if this works at all)
04:07:53 <boxscape> s/100%/100% sure
04:09:07 <jpcooper> That might be a bit too complex. Will stay with the first
04:09:38 <boxscape> (Also I meant to say `AllHave c l =>` instead of `AllHave c l ->`. But yeah, using a constraint is probably fine)
04:42:12 <infinity0> for haddock, is there a way to document re-exports
04:42:45 <infinity0> i tried adding docstrigns to the "exported symbols list" but it generates those comments as html elements disassociated from the actual re-export and gives me a doc error about "no documentation for (re-exported)"
05:08:09 * hackage op 0.2.0.0 - Common operators encouraging large-scale easy reading  https://hackage.haskell.org/package/op-0.2.0.0 (infinity0)
05:13:09 * hackage op 0.3.0.0 - Common operators encouraging large-scale easy reading  https://hackage.haskell.org/package/op-0.3.0.0 (infinity0)
05:17:08 <boxscape> % 16 &div$ 2
05:17:08 <yahb> boxscape: 8
05:17:25 <boxscape> just figured out that this is an alternative to backticks
05:17:39 <boxscape> (though not for all cases, of course)
05:19:19 <boxscape> Actually though this could be genuinely useful, I've often wished to be able to do something like 0 `foldr (+)` [1..5]
05:19:33 <boxscape> % 0 &foldr (+)$ [1..5]
05:19:33 <yahb> boxscape: 15
05:20:01 <boxscape> (and I imagine I'm far from the first to say something about this)
05:20:34 <boxscape> maybe a better example:
05:20:45 <boxscape> % Just 4 &liftA2 (+)$ Just 12
05:20:45 <yahb> boxscape: Just 16
05:22:09 * hackage free-category 0.0.4.0 - Free category  https://hackage.haskell.org/package/free-category-0.0.4.0 (coot)
05:30:22 <iqubic> Is it possible to modify the environment of a Reader?
05:30:50 <nil> :t local
05:30:53 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
05:31:18 <iqubic> Right, but that doesn't modify the environment for the original Reader.
05:31:29 <iqubic> I just creates a new reader of sorts.
05:31:50 <nil> then i don't know what you mean
05:31:54 <lavalike> it sort of does if you call yourself recursively with the `local` in between
05:32:05 <kuribas> iqubic: you want state
05:32:10 <kuribas> iqubic: not reader
05:34:02 <iqubic> I know.
05:34:04 <iqubic> I know that.
05:34:23 <iqubic> Now I have to figure out how to combine State and Writer.
05:34:47 <boxscape> > (Just 4 <&> (+)) <*> Just 12
05:34:48 <nil> StateT s (Writer w)
05:34:50 <lambdabot>  Just 16
05:34:56 <boxscape> this would be so nice if it didn't require parentheses
05:35:11 <iqubic> nil: Will that work?
05:35:25 <iqubic> And am I sure I want the composition in that order?
05:36:00 <nil> State and Writer commute
05:36:04 <boxscape> @unmtl StateT s (Writer w) ()
05:36:04 <lambdabot> s -> ((), s, w)
05:36:09 <boxscape> @unmtl WriterT w (State s) ()
05:36:10 <lambdabot> s -> ((), w, s)
05:36:29 <iqubic> I see.
05:36:41 <phadej> :t \f m k -> ReaderT $ \r -> runReaderT m r >>= \x -> runReaderT (k x) (f r)
05:36:43 <lambdabot> Monad m => (t1 -> r) -> ReaderT t1 m t2 -> (t2 -> ReaderT r m a) -> ReaderT t1 m a
05:36:47 <iqubic> What is that last () for there?
05:37:03 <boxscape> iqubic the result type of the operation. Otherwise @unmtl complains.
05:37:15 <phadej> % :i RWST
05:37:15 <yahb> phadej: type role RWST representational nominal nominal representational nominal; newtype RWST r w s (m :: * -> *) a = RWST {runRWST :: r -> s -> m (a, s, w)}; -- Defined in `Control.Monad.Trans.RWS.Lazy'; instance [safe] (Monoid w, Functor m, MonadPlus m) => Alternative (RWST r w s m) -- Defined in `Control.Monad.Trans.RWS.Lazy'; instance [safe] (Monoid w, Functor m, Monad m) => Applicative (RWST r w s m)
05:37:37 <lavalike> > runReader (fix $ liftA2 (:) ask . local succ) 0
05:37:43 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
05:38:52 <iqubic> What does tell do for MonadWriter?
05:39:36 <phadej> mappends new thing to already told ones
05:39:51 <phadej> tell x >> tell y == tell (x <> y)
05:39:56 <iqubic> But how do the types work out there?
05:42:51 <infinity0> i've thought of using RWST but always in the back of my mind there's a worry "what if i do actually want to modify parts of the env later" and so i end up just shoving it into a part of the state
05:43:25 <iqubic> Yeah. I know what you mean.
05:43:37 <phadej> or you could think, "if i need to to modify an environment, than something is really wrong"
05:44:02 <infinity0> well it's hard to say sometimes
05:44:07 <phadej> e.g. I have "whether terminal supports ANSI escapes"
05:44:15 <phadej> its' very unluckily it would change
05:44:37 <infinity0> maybe it does, maybe you want to write something where the state can be reloaded onto a different computer
05:45:50 <lavalike> I just used RWST today, also empty env hehe
06:21:37 <merijn> hmm, may AoC input seems to have some weird junk in it...
06:21:40 <merijn> s/may/my
06:22:41 <merijn> Ah, someone didn't strip whitespace in their files >.<
06:27:59 <solonarv> whitespace on the ends?
06:28:30 <solonarv> I ran into issues with that end just tossed a `dropWhile isSpace . dropWhileEnd isSpace` into my framework
06:29:37 <boxscape> :t strip
06:29:39 <lambdabot> error: Variable not in scope: strip
06:29:42 <boxscape> % :t strip
06:29:42 <yahb> boxscape: ; <interactive>:1:1: error: Variable not in scope: strip
06:29:47 <boxscape> % :t Data.Text.strip
06:29:47 <yahb> boxscape: Data.Text.Internal.Text -> Data.Text.Internal.Text
06:29:50 <merijn> My interpreter is solidly over engineered, though ;)
06:29:50 <boxscape> why not just that
06:31:54 <solonarv> because I am reading the input as a String
06:32:11 <solonarv> I'll probably switch it to Text on the weekend when I redo the framework
06:32:13 <solonarv> needs doing anyway
06:32:23 <boxscape> Oh I hadn't realized dropWhileEnd is defined for lists
06:54:08 <aplainzetakind> Without thinking much, I went with IOUArray for those interpreter questions. Is there any obvious reason to choose either of IOUArray and STUArray?
06:54:35 <merijn> aplainzetakind: I would say "neither" and use Vector :p
06:57:26 <merijn> solonarv: Is your code online somewhere? I'm curious what other people's interpreter looks like :)
06:58:05 <solonarv> merijn: yeah, it's on https://github.com/Solonarv/adventofcode-2019
06:58:16 <solonarv> my interpreter isn't finished yet though
06:58:37 <solonarv> well, it works now - I found the error
06:58:43 <solonarv> it was really dumb
06:59:41 <solonarv> I was doing repeated (`divMod` 100) to find the parameter modes
06:59:50 <yasar> hi
07:00:12 <yasar> is this a good resource for haskell beginners? http://learnyouahaskell.com/
07:00:17 <merijn> solonarv: heh, where is opInput defined?
07:00:29 <merijn> solonarv: oh, not finished, that explains xD
07:01:00 <merijn> solonarv: I just converted the ST based one I had to IO, because inlining the IO into the interpreter was simple
07:05:14 <aplainzetakind> merijn: https://gitlab.com/aplainzetakind/aoc2019/blob/master/days/Advent19/Day05.hs
07:05:50 <glguy> There are generic methods that work on io and St arrays, so you don't really have to commit
07:07:36 <merijn> glguy: Yeah, but that looks far more ugly
07:07:46 <solonarv> merijn: further down in the file, unless I committed a non-working file
07:08:01 <solonarv> which is entirely possible since I started on my laptop and now finished on my PC
07:08:31 <merijn> glguy: I'm trying to keep my solutions clean, readable and correct so I can use them as examples
07:08:40 <merijn> glguy: So they're also much larger then need be
07:08:48 <solonarv> merijn: pushed the working solution now
07:08:52 <solonarv> if you want to have a look
07:09:52 <merijn> aplainzetakind: Ah, you use State to keep an actual instruction pointer, I was considering modifying mine to do that
07:10:00 <glguy> I went with an immutable memory https://github.com/glguy/advent2019/blob/master/execs/Day05.hs
07:11:03 <solonarv> I just have a bunch of ST-mutable things to store state
07:11:15 <solonarv> the instruction pointer isn't part of that, though
07:11:22 <aplainzetakind> merijn: Is yours viewable somewhere?
07:11:24 <merijn> aplainzetakind: https://github.com/merijn/AdventOfCode2019/blob/master/Day5.hs
07:11:58 <solonarv> mine is here: https://github.com/Solonarv/adventofcode-2019/blob/master/haskell/day05/Day05.hs
07:12:01 <merijn> There's room for some cleanup (actual instruction pointer) and cleaning up the param decode
07:12:36 <solonarv> all my solutions are IO-free by design
07:15:35 <aplainzetakind> glguy: Why is ins a list? To future proof it?
07:16:16 <glguy> Yeah, figured I would need multiple inputs later
07:16:21 <solonarv> same
07:16:33 <merijn> Same, hence IO inlined into interpreter :p
07:17:00 <solonarv> are you just typing in the given input?
07:17:05 <merijn> Yes
07:17:15 <solonarv> hmm
07:18:09 <solonarv> well, I made a Solution record with fields like {decodeInput :: Parser a, solvePart :: Part -> a -> b, showOutput :: b -> String}
07:18:20 <solonarv> so no IO allowed
07:20:38 <aplainzetakind> solonarv: Mine is the opposite. All my stars are FilePath -> FilePath -> IO () printing the answer.
07:20:52 <yasar> What is the most commonly recommended resource for learning haskell for beginners?
07:21:17 <aplainzetakind> Which was a decision I quickly came to regret as lame, so I envy your setup now, but feel to lazy to change everything.
07:21:25 <merijn> yasar: There's Haskell from First Principles, Graham Hutton's Programming in Haskell, and a bunch more here: https://github.com/bitemyapp/learnhaskell
07:21:32 <aplainzetakind> Besides optimizing day 3 has higher priority.
07:21:40 <solonarv> aplainzetakind: don't envy it too much, I need to rip it out and redo basically all of it
07:21:42 <aplainzetakind> @where cis194
07:21:42 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
07:21:55 <aplainzetakind> yasar: ^
07:23:14 <yasar> huh, that look like an actual college course
07:23:24 <merijn> yasar: Because it is :p
07:23:29 <aplainzetakind> It is.
07:23:58 <aplainzetakind> But the homework questions are a nice progression and also very instructive.
07:24:22 <aplainzetakind> If you do them all that would be a solid (and quick) start.
07:24:30 <aplainzetakind> @where fp-course
07:24:31 <lambdabot> I know nothing about fp-course.
07:24:35 <aplainzetakind> :/
07:24:40 <yasar> is `.lhs` format similar to python notebooks ?
07:26:32 <solonarv> yasar: ehhh, sort of
07:27:02 <solonarv> it basically just means everything is a comment by default and code has to be marked specially
07:27:14 <solonarv> whereas normally it's the other way around
07:29:11 <aplainzetakind> merijn: Why newtype Interpreter?
07:29:37 <merijn> aplainzetakind: As opposed too?
07:32:05 <aplainzetakind> type
07:32:26 <yasar> would you suggest haskell platform or stack for a newcomer?
07:32:42 <merijn> aplainzetakind: Because there's no reason for anything except a handful of primitive operations to know how the Interpreter is implemented
07:32:44 <solonarv> yasar: haskell platform includes stack :P
07:32:51 <merijn> aplainzetakind: Which makes refactoring easier later on
07:32:54 <solonarv> it kind of depends, what OS do you use?
07:32:59 <yasar> windows
07:33:08 <maerwald> yasar: chocolatey
07:33:14 <maerwald> it has well maintained packages
07:33:38 <solonarv> seconding this recommendation
07:33:44 <merijn> aplainzetakind: I can completely replace/change the implementation of Interpreter and only 4 trivial methods need to be updated
07:34:12 <merijn> Only runInterpreter/readOffset/writeOffset/errorMsg know about the implementation details
07:35:52 <aplainzetakind> What more could break otherwise?
07:37:41 <merijn> aplainzetakind: It's easy to start randomly using mtl operators inside your interpreter implementation, which means now you have to fix that too when you refactor and it's much harder to decide whether you're breaking something in that code
07:38:52 <aplainzetakind> aplainzetakind: So a way to contain yourself?
07:38:54 <aplainzetakind> I see.
07:47:01 <merijn> aplainzetakind: Basically, yeah. Especially since I expect I'll be seeing this interpreter again later this month :p
07:47:16 <solonarv> heh, yeah, me too
07:47:43 <merijn> Hence why I considered adding an explicit instruction counter too :p
07:48:18 <yasar> I am guessing there are tools to convert .lhs files to .html or .pdf?
07:48:45 <solonarv> there are
07:48:52 <solonarv> although I don't remember what they are
07:48:59 <merijn> yasar: Usually you'd go lhs -> (La)TeX -> PDF
07:49:07 <merijn> There's probably also something for pandoc
07:49:19 <merijn> solonarv: lhs2tex :p
07:49:38 <solonarv> is there also a markdown variant? we have markdown-unlit after all
07:51:15 <solonarv> ah right, if you use markdown-unlit you can just throw the file at pandoc or any other markdown-to-X converter
07:51:58 <phadej> yes, that's how my blog posts are written (some of them "compile")
07:58:00 <greymalkin> Well, after working in scala for the past couple months, I can attest that it is a very warty language. I keep getting tripped up by having "functions" that have two kinds of implicit paramaters: The ones which make up members of the class on which the function is called, and a horde of others labeled "implicit" and otherwise completely unrelated.
07:58:52 <greymalkin> Still a hands-down win for haskell in my opinion.
07:59:32 <Cale> Yeah, the coherence of instance resolution in Haskell is a big deal
07:59:37 <greymalkin> Oh, and I miss hoogle dearly.
08:03:09 <boxscape> scoogle would be a nice name for a scala hoogle
08:04:56 <int-e> mmm scrooge
08:17:09 * hackage libarchive 2.1.1.0 - Haskell interface to libarchive  https://hackage.haskell.org/package/libarchive-2.1.1.0 (vmchale)
08:18:09 * hackage genvalidity-text 0.7.0.1 - GenValidity support for Text  https://hackage.haskell.org/package/genvalidity-text-0.7.0.1 (Norfair)
08:21:22 <dminuoso> Mmm, I want to efficiently do concatMap for vectors. I was originally thinking of using mutable vectors in ST - is there no high level mutable access to say append to a vector? Am I supposed to just maintain an index, grow it one element at a time and write to it?
08:21:59 <dminuoso> errr *catMaybes
08:22:35 <lyxia> the vector library is indeed pretty poor in algorithms
08:26:30 <dminuoso> Yeah.. I mean at first glance Im thinking about implementing such an interface myself. Grow by a chunk, write to it until the chunk is depleted, and repeat. And then shrink at the end. But that's really things I dont want to concern myself with. :(
08:27:19 <geekosaur> isn't that more or less compact regions?
08:27:38 <solonarv> no, compact regions are something entirely unrelated
08:27:45 <nshepperd> there's a package on top of vector that does that
08:27:49 <nshepperd> dynamic-mvector
08:29:38 <dminuoso> nshepperd: Oh that's exactly the glue I was missing. I'll have a look at the source code and evaluate it.
08:29:40 <dminuoso> Thanks! :)
08:31:24 <dripstylish> Hello?
08:31:32 <solonarv> dripstylish: hello!
08:31:51 <dripstylish> Oh, it worked! Sorry, first time using irssi
08:32:34 <solonarv> ah, another irssi user
08:32:36 * solonarv waves
08:33:34 <dripstylish> Must say, it's slightly confusing the first time around ^^'
08:42:47 <aplainzetakind> If I wrote a Parser (Set a) like a fold which inserts as it parses, then converted the set to a (sorted) list, that would be pretty much the same performance-wise as parsing to a list then sorting it due to list fusion right?
08:43:39 <vaibhavsagar> I don't think that's right
08:43:58 <vaibhavsagar> list fusion gets rid of intermediate lists
08:44:12 <vaibhavsagar> but I don't see how parsing to a list creates intermediate lists
08:44:45 <vaibhavsagar> I suspect the first approach would be faster, because Set sorts as it goes
08:45:23 <vaibhavsagar> but even if the performance is about the same, I don't think that would have anything to do with list fusion
08:46:09 <aplainzetakind> Input to List to SortedList =? Input to Set to SortedList (the implicit assumption is converting the list to a set then to a sorted list costs the same as just sorting the list).
08:46:13 <geekosaur> parsing into a list would usually fmap over a list, not generate new ones
08:46:40 * ocharles waves to vaibhavsagar 
08:46:41 <geekosaur> unless you do it with (++) instead of (:), but you're sorting afterward so why?
08:47:03 * vaibhavsagar waves back to ocharles
08:47:35 <geekosaur> and even the (++) one doesn't creaate temp lists, it just iterates the same list over and over
08:48:22 <dminuoso> Where does this magic Typeable constraint come from? https://gist.github.com/dminuoso/e98e0200945275ced67242de568525cf
08:48:23 <geekosaur> it'd be possible to generate a parser which did create temporary lists, but it's not the way most Haskellers would write it
08:48:51 <dminuoso> I mean... field :: FromField a => RowParser a 
08:48:58 <aplainzetakind> I have something (specifically AoC Day 3 input), which I can parse to a list then sort. I wonder if I stand to gain anything by writing an elaborate fold-like parser which directly creates a Set first.
08:50:48 <geekosaur> depends on how big the list is. for AoC I'd suspect probably not big enough to justify it. that said, in most cases I'd write the Set and list ones the same way, fmapping insert vs. (:), so.
08:50:57 <geekosaur> but I haven't looked at the AoC
08:51:07 <dminuoso> Argh! Okay, I think this is a weird diagnostic bug. I feel that GHC could tell me more about this.
08:51:26 <aplainzetakind> geekosaur: OK, thanks.
08:51:28 <lyxia> dminuoso: there are instances of FromField with Typeable constraint
08:52:46 <habbah> is it not possible perform IO inside of m? https://gist.github.com/mcbahson/77ad78fa83dbd4d9b56840cef1483519
08:53:17 <geekosaur> generally? only if you know m is IO, or if you know it has a MonadIO instance and use liftIO
08:53:45 <dminuoso> lyxia: Mmm. It would have been helpful if GHC had told me about the instance it selected.
08:54:18 <Taneb> habbah: the "correct" answer here is use Control.COncurrent.Classy.Chan, which dejafu is built on top of
08:54:18 <dminuoso> That is, if it told me about `instance (FromField a, Typeable a) => FromField (Vector a)` 
08:59:09 <Bish> @src zipWith
08:59:09 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
08:59:09 <lambdabot> zipWith _ _      _      = []
09:09:39 * hackage haskellish 0.1.1 - For parsing Haskell-ish languages  https://hackage.haskell.org/package/haskellish-0.1.1 (dktr0)
09:14:22 <solonarv> zipWith f = curry (unfoldr ((fmap (uncurry (f `on` fst) &&& (snd *** snd)) . uncurry (liftA2 (,)) . (uncons *** uncons))))
09:16:20 <solonarv> hmm, not quite right
09:18:24 <solonarv> here we go: zipWith f = curry (unfoldr ((fmap ((liftA2 f (fst.fst) (fst.snd)) &&& (snd *** snd)) . uncurry (liftA2 (,)) . (uncons *** uncons))))
09:18:29 <solonarv> Bish: ^
09:18:34 <solonarv> is this what you were looking for? :P
09:59:14 * jgt waves to vaibhavsagar and admires his extreme lifting prowess
10:00:44 <vaibhavsagar> I have been known to liftA2 on occasion
10:48:15 <Guest_8> Guys, how should I go about to fix my haskell setup with Spacemacs on Archlinux?
10:48:38 <Guest_8> I use stack and I am using lsp in Spacemacs with Haskell but some things are broken
10:49:10 <Guest_8> Eg -> Doc viewer or the ghci window in spacemacs (, s b)
10:52:05 <glguy> If you're doing Advent of Code in Haskell and aren't already on my leaderboard, there some room now: 43100-84040706 :)
10:52:51 <glguy> 108 people have started it; 45 are caught up with the most recent exercise
10:58:59 <sm> thanks glguy.. not doing it this year alas, but curious: leaderboards with limited size, is that new ? Is your leaderboard the main haskell leaderboard ? I guess it doesn't have a permalink ?
10:59:28 <solonarv> private leaderboards aren't that new
10:59:44 <solonarv> they were there last year and probably before too, though I don't remember that
10:59:46 <glguy> sm: They cut off at 200 people
10:59:51 <sm> aha
10:59:57 <sm> silly
10:59:59 <glguy> I've been advertising mine as the #haskell leaderboard since 2015
11:00:11 <sm> we need more room than that obviously!
11:00:25 <glguy> I asked for more room but I haven't heard back
11:02:06 <sm> cool. And I see leaderboard memberships persist from year to year. So I'm taking up a space, even though not coding. But I still want to watch it :)
11:02:39 * hackage libarchive 2.1.2.0 - Haskell interface to libarchive  https://hackage.haskell.org/package/libarchive-2.1.2.0 (vmchale)
11:03:10 <sm> I guess this works as a permalink, if you're logged in and have already joined the leaderboard: https://adventofcode.com/2019/leaderboard/private/view/43100
11:10:32 * jgt is currently working through Advent of Struggle-with-NGINX
11:15:09 * hackage util 0.1.14.1 - Utilities  https://hackage.haskell.org/package/util-0.1.14.1 (MatthewFarkasDyck)
11:18:39 * hackage Map 0.1.3.2 - Class of key-value maps  https://hackage.haskell.org/package/Map-0.1.3.2 (MatthewFarkasDyck)
11:20:38 <solonarv> those are some impressively short package names
11:22:54 <evelyn> I was thinking, it's not like they have a monopoly on those particular names.. but in fact, they do. :/
11:23:10 <merijn> Now I'm curious, which names?
11:23:33 <nil> util and Map
11:25:10 <solonarv> yes, I was responding to the hackage posts
11:33:18 * EvanR quickly uploads packages named a, b, c, ..., and z
11:33:25 <EvanR> like freenode nicks
11:54:47 <zeta_0> how do i import the sqrt function into my haskell program?
11:55:26 <Geekingfrog> zeta_0, it's in the standard library (Prelude). It should be in scope automatically
11:55:42 <jle`> > sqrt 3
11:55:44 <lambdabot>  1.7320508075688772
11:57:14 <zeta_0> no i am getting an error that it is not being recognized? https://hastebin.com/ideduyedeb.pl
11:57:37 <zeta_0> sqrt 3
11:57:42 <zeta_0> > sqrt 3
11:57:44 <lambdabot>  1.7320508075688772
11:58:01 <zeta_0> i have never done that before
11:58:21 <zeta_0> cool
11:59:03 <amalloy> zeta_0: read the error message more carefully: it doesn't say that sqrt can't be found
11:59:13 <jle`> zeta_0: your error isn't that it isn't recognized, but it's being applied to something of the wrong type
11:59:20 <jle`> namely you can't apply it to integers
11:59:29 <zeta_0> here's code: https://hastebin.com/itojikacey.pl
11:59:48 <amalloy> jle`: perhaps more precisely, it can't return an integer
12:00:01 <jle`> indeed :)
12:00:12 <jle`> zeta_0: sqrt returns something of the same type it takes in
12:00:16 <jle`> zeta_0: and sq takes an Integer
12:00:26 <jle`> zeta_0: so the problem is you can't sqrt an Integer
12:00:39 <jle`> zeta_0: try changing sq to be Double -> Double instead
12:01:45 <zeta_0> jle`: cool, what about Num, or Int, or would Double be best?
12:02:36 <zeta_0> if i understand correctly Num is a superset of Int, Integer, Double, Float, etc?
12:02:56 <jle`> zeta_0: Num is a typeclass so it can be used to make sq polymoprphic, yeah
12:03:01 <jle`> sq :: Num a => a * a
12:03:03 <jle`> sq x = x * x
12:03:07 <jle`> whoops
12:03:10 <jle`> sq :: Num a => a -> a
12:03:12 <jle`> sq x = x * x
12:03:37 <jle`> that should work as well, now sq can take any type implementing the Num typeclass, so it can be used for DOuble and Float
12:04:41 <zeta_0> jle`: so if i am unsure what to use, going with Num would be best because it is more general, right?
12:06:06 <zeta_0> jle`: anyways, thanks, its making more sense now
12:06:08 <amalloy> zeta_0: it's the type ghc would infer if you didn't specify a type
12:07:12 <jle`> zeta_0: there is no 'best' way, it only depends on what you want to use with it
12:07:38 <jle`> zeta_0: if you only intend to ever use it with Double then there is no reason to generalize it to all Num
12:07:54 <jle`> if you intend to use it on double's, floats, ints, etc., then yeah you would need to keep it polymorphic like that
12:09:38 <zeta_0> oh, ok, and ya its telling that it defaults to type Double, thanks for clarifying this stuff
12:12:59 <zeta_0> do any of you guys understand this error? `12:36:58:743: [error] ein:ml-lang-setup: kernelspec language ’haskell’ unsupported @#<buffer *ein: http://127.0.0.1:8888/Untitled58.ipynb*>`
12:13:39 * hackage niv 0.2.6 - Easy dependency management for Nix projects  https://hackage.haskell.org/package/niv-0.2.6 (nmattia)
12:36:53 <iqubic> I just need to loop haskell function around and around until I get a True, and then I need to get the output from the Writer.
12:37:03 <iqubic> step :: (MonadState Memory m, MonadWriter [Int] m) => m Bool
12:38:03 <dmwit> ?hackage monad-loops
12:38:04 <lambdabot> http://hackage.haskell.org/package/monad-loops
12:39:00 <iqubic> obviously I also want to chose the initial state.
12:39:54 <iqubic> I have function called "execProg :: Memory -> [Int]" should use it's argument as the initial state, and the writer's output as the final output.
12:40:27 <iqubic> But yeah, just keep looping over and over until I get True.
12:41:10 <iqubic> I've never used the monad loop library, so I don't know which loop I want.
12:41:17 <iqubic> Is there an untilM?
12:41:35 <merijn> iqubic: AoC? ;)
12:41:38 <iqubic> Yes.
12:41:55 <iqubic> This is the final thing I need for part 1 of Day 5.
12:42:01 <iqubic> Well, that and testing.
12:42:20 <merijn> Wait, why do you need "loop until True"?
12:43:08 <iqubic> My step function uses the returned Bool to indicate if the intcode program has halted or not.
12:43:31 <merijn> iqubic: Why not make your step function recurse and then not recurse on Halt?
12:44:03 <iqubic> Because... Because... I didn't think about that.
12:44:08 <merijn> :)
12:45:02 <iqubic> Now all I need is a way to run the computation.
12:46:04 <nil> probably a combination of (run|eval|exec)(Writer|Reader|State)(T|)
12:46:13 <iqubic> I know.
12:47:45 <iqubic> Writing this interperter with lenses over the state monad has been a godsend.
12:48:31 <f-a> hello, If I have a .cabal with 2 `executable` section, I can run a specific one with cabal new-run <name>
12:48:39 <f-a> does that work the same with stack
12:48:49 <f-a> i.e. can I invoke `stack run <name>`?
12:50:36 <lyxia> yes
12:51:02 <f-a> thanks
12:53:06 <zeta_0> ?
12:53:12 <iqubic> @unmtl StateT Int (Writer [Int]) ()
12:53:13 <lambdabot> Int -> ((), Int, [Int])
13:03:02 <iqubic> step :: StateT Memory (Writer [Int]) ()
13:03:06 <iqubic> execProg :: Memory -> [Int]
13:03:10 <iqubic> execProg mem = execWriter $ runStateT step mem
13:03:19 <iqubic> That just typechecks.
13:03:39 <solonarv> :D
13:03:44 <iqubic> I don't quite understand why though.
13:04:47 <solonarv> the result of `runStateT step mem` is `Writer [Int] ((), Memory)`
13:04:52 <solonarv> yes?
13:05:26 <iqubic> Yes.
13:05:51 <solonarv> now `execWriter` plucks out the `[Int]` and throws out the `((), Memory)` entirely
13:06:17 <iqubic> Also, I changed step to recursively call itself until it finds the halt instruction.
13:06:21 <leo_> Hey, I have a soft question for you guys.
13:06:34 <iqubic> So no need for a bool to signal halting.
13:06:47 <iqubic> When the function returns, it will halt on it's own.
13:07:11 <merijn> @quote didn't.you.write.that
13:07:12 <lambdabot> autrijus says: * autrijus stares at type Eval x = forall r. ContT r (ReaderT x IO) (ReaderT x IO x) and feels very lost <shapr> Didn't you write that code? <autrijus> yeah. and it works <autrijus> I
13:07:12 <lambdabot> just don't know what it means.
13:07:16 <leo_> I'm from Brazil and here almost no one even heard of generative tests.
13:07:32 <leo_> Almost no company is applying it.
13:08:01 <leo_> If it gets mentioned, it's like alien novelty.
13:08:19 <leo_> Is that the state of things abroad? Or it it commonly used?
13:08:35 <leo_> In the US, Europe... I don't know.
13:08:58 <solonarv> leo_: do you mean property tests that generate a bunch of sample inputs, like QuickCheck?
13:20:39 <leo_> solonarv: Yes.
13:24:55 <zincy_> property based testing is awesome
13:25:26 * f-a nods
13:29:19 <shapr> hedgehogs go faster
13:32:03 <iqubic> Why is debugging Haskell code such a pain?
13:32:16 <merijn> That depends on the code >.>
13:32:18 <iqubic> I'm so close to a solution for Day 5 Part 1, but not quite.
13:32:26 <f-a> iqubic: use debug
13:32:29 <f-a> ?debug
13:32:29 <lambdabot> https://hackage.haskell.org/trac/ghc/newticket?type=bug
13:32:36 <f-a> mhh, no
13:32:51 <iqubic> @hackage debug
13:32:51 <lambdabot> http://hackage.haskell.org/package/debug
13:32:54 <iqubic> That?
13:32:57 <f-a> th- yeah
13:33:11 <f-a> it gives you a visual representation of the intermediate steps
13:33:14 <f-a> I find it useful
13:33:56 <iqubic> I see.
13:34:34 <f-a> I admit I abuse `traceShow` as a first step
13:34:39 <iqubic> Same.
13:34:45 <Rembane> It's a lifesaver
14:05:16 <dasli> Is there a way to make GHC ignore ambiguous types of values that are clearly never evaluated?
14:06:24 <dasli> The only appearance of a value is as an argument to a constant function, who cares if its type is ambiguous?
14:07:54 <wildtrees> I think there might be a language extension for that, but I forget it's exact name, might just be for typeclasses 
14:08:19 <monochrom> dsal: Perhaps -fdefer-type-errors will do?
14:08:48 <monochrom> I even got it to forgive variable-not-found errors.
14:11:11 <dasli> monochrom: ah yeah, that works
14:11:53 <solonarv> out of curiosity... if you *know* that it is only being used as an argument to a constant function, why is it even in your program?
14:12:02 <dasli> it might be kind of heavyhanded, but it's good to know
14:13:04 <solonarv> it is definitely heavy-handed
14:13:19 <merijn> What does "constant function" mean?
14:14:04 <dasli> solonarv: It's this kind of thing: fmap . const :: b -> Maybe a -> Maybe b
14:15:01 <dasli> I have a value of type Maybe a, and if its constructor is Just, then I replace the argument with something else.
14:15:54 <amalloy> dasli: fwiw that's <$
14:15:56 <dasli> But `a` is an instance of a class with an associated type, and GHC was complaining that it can't infer that type even though it doesn't seem like it should care
14:17:13 <monochrom> Maybe NoMonomorphismRestriction will nudge GHC into not caring.
14:17:34 <monochrom> Because sometimes GHC cares because of the monomorphism restriction.
14:18:45 <monochrom> But NoMonomorphismRestriction is heavy-handed in some other way.
14:20:00 <dasli> monochrom: NoMonomorphismRestriction doesn't change anything in my case
14:20:20 <monochrom> Ah oh well
14:22:49 <dasli> I have an instance of my class defined, so I just added an annotation saying "yeah, make one of those before you throw it away and forget about it"
14:22:52 <dasli> :)
14:23:03 <geekosaur> ghc for example cares about fixing the x in Either x Int even if you only ever use Right with it
14:23:39 <geekosaur> ExtendedDefaultRules should help because it will then be able to infer ()
14:24:18 <geekosaur> or just add a default declaration: default (Integer, Double, ())
14:26:04 <geekosaur> although if a typeclass is involved you may need the full power of ExtendedDefaultRules to pull it off
14:29:18 <dasli> geekosaur: I'm finally reading about default declarations
14:30:04 <dasli> I spent years trying to bind things to "default" only to have it pop up in bold in my editor :)
14:30:19 <dasli> And I thought "I'll look at that later."
14:30:51 <koz_> I want Haddock docs to display a UNIX path (/foo/bar/baz) in monospaced test (i.e. like code). How would I format that?
14:32:01 <hpc> use @/foo/bar/baz@
14:32:06 <hpc> see https://haskell-haddock.readthedocs.io/en/latest/markup.html#markup
14:32:26 <hpc> er, with backslashes for the slashes
14:34:08 <koz_> Yeah, that was the issue I was having. So it'd have to be @\/foo\/bar\/baz@?
14:34:25 <hpc> yeah
14:34:34 <koz_> Best directory separator.
14:35:20 <hpc> should have used one of those old apples where it was ':'
14:36:10 <koz_> hpc: \/ is the union of the UNIX and Windows convention.
14:36:25 <koz_> Therefore it makes the maximum number of people happy (or unhappy, depends on perspective).
14:36:47 <koz_> o o O ( utilitarianist's file separator choice )
14:38:24 <monochrom> I know! \/ is maximum, /\ is minimum.  >:)
14:38:48 <hpc> turn that /\ upside-down
14:39:31 <koz_> I always forget which one is meet and which is join.
14:39:56 <monochrom> I don't know how I managed to, but I rote-memorized that \/ is join, /\ is meet.
14:40:11 <wildtrees> lattice alone, will ya? 
14:40:32 <monochrom> I think I know. \/ is inspired by union ∪, /\ is inspired by intersection ∩
14:41:54 <monochrom> bacon lattice tomato
14:42:03 <koz_> monochrom: \/ is 'lower bound of both', /\ is 'upper bound of both'?
14:42:34 <monochrom> But lower bound is meet, not join.
14:43:06 <koz_> OK, now I think I know why I always get those confused.
14:43:10 <monochrom> :)
14:44:05 <monochrom> Yeah if you compute a meet on a Hasse diagram you see a picture like \/
14:45:00 <monochrom> Unfortunately they wanted \/ to look like ∪
14:45:41 <monochrom> Perhaps they were pointy hair bosses.
14:46:22 <monochrom> OK here is my favourite symbol, it gives you maximum confusion. \∩/
14:46:54 <koz_> I'm trying to weld together fsnotify and streamly. fsnotify requires a 'cleanup routine', which currently means I have to return (IsStream t, MonadAsync m) => m (Cleanup, t m a). Is there a better way I can do this, or do I have to leave it to the user to manually call the release routine, even if they're using streamly streams?
14:47:32 <koz_> I checked out ResourceT (and its mtl-like equivalent), but that just seems to kick that can down the road.
14:54:32 <koz_> My main concern is that calling the 'cleanup routine' could potentially break a whole pile of 'downstream' streams from the one originally doing the watching, which feels... wrong somehow.
15:00:28 <MarcelineVQ> koz_: how doe streamly handle closing files?
15:00:46 <koz_> MarcelineVQ: Very good question.
15:00:52 <koz_> I don't know if it provides file pipes.
15:01:27 <merijn> koz_: How does "ResourceT" kick the can down the road?
15:01:51 <koz_> merijn: It gives you a 'token' to give to release, whereas fsnotify just gives you an IO () to call.
15:02:00 <koz_> I basically see these as pretty damn close to analogous.
15:02:22 <merijn> I think I'm not following the problem
15:02:46 <merijn> What are you trying to handle/prevent and how is ResourceT insufficient?
15:03:35 <koz_> merijn: I'm not saying it's insufficient - I'm more unsure whether there's a way to do this where I can just return the stream and have the cleanup dealt with automagically, instead of kicking it to the user.
15:03:42 <koz_> I suspect the answer is 'no'.
15:03:56 <maralorn> Can someone please point me in the direction on how to tell cabal that it should get a certain package not from hackage but a certain local path?
15:04:03 <merijn> koz_: ResourceT cleans up everything when the at the end of the ResourceT monad
15:04:19 <koz_> merijn: I think you accidentally some words there.
15:04:20 <merijn> koz_: The release key is just for early release
15:04:31 <merijn> koz_: s/when the//
15:04:40 <maralorn> The cabal documentation is not that bad. But still I never stuff in it and reading it from on end to the other is not really something I want to do.
15:04:56 <maralorn> I never *find stuff …
15:05:03 <merijn> maralorn: cabal-install 3.0?
15:05:25 <koz_> MarcelineVQ: To answer your question, streamly punts the whole problem.
15:05:30 <maralorn> merijn: Yeah
15:05:34 <merijn> maralorn: https://cabal.readthedocs.io/en/latest/nix-local-build.html#configuring-builds-with-cabal-project
15:05:40 <koz_> (namely it doesn't even handle the whole 'opening and closing of external resources' thing)
15:06:01 <merijn> maralorn: Specifically packages and optional-packages
15:06:41 <incertia> sequencing an infinite list is a bad idea right? e.g. x <- take 10 $ sequence $ return <$> [1..] because sequence is supposed to execute all the monadic actions right?
15:06:53 <merijn> koz_: When you do "runResourceT act" to unwrap ResourceT all resources are cleaned up on 1) (async) exceptions or 2) on 'act' returning/finishing
15:07:02 <koz_> incertia: Welcome to 'why there are about a dozen different streaming libraries in Haskell', lol.
15:07:24 <koz_> merijn: So I guess in the context of streamly, that _should_ correspond to the stream being drained or folded?
15:07:26 <merijn> koz_: The release key just permits "early release" when you are done with a resource
15:07:27 <maralorn> merijn: Thanks!
15:07:45 <merijn> koz_: It exists, for example, for ConduitT
15:07:52 <koz_> Which bodes well.
15:08:08 <merijn> koz_: You can't properly implement a bracket in conduit (because of the CPS transformation stuff)
15:08:29 * maralorn would really like to remember how to use the karma function of the lambdabot.
15:08:35 <koz_> merijn: Yeah, I remember Alexis mentioning this exact problem recently.
15:08:41 <merijn> koz_: But when you are done streaming from e.g. a file, you want to clean it up immediately, instead of waiting for the entire pipeline to complete
15:09:29 <koz_> (in another context)
15:09:39 <merijn> koz_: So you do "streamFromFile >> release fileKey" regardless of how it ends (by streaming completing, which will call release and release early) or on exception (which triggers the surrounding cleanup in runResourceT) you will get cleanup
15:09:57 <koz_> OK, that makes sense.
15:10:00 <incertia> koz_: my use case is more like (a:b:c:_) <- sequence $ doSomething <$> [1..] and i'm too lazy to put bounds on the list so whenever i need another element i just pattern match another one
15:10:12 <incertia> but yeah i think that should cause an infinite loop
15:10:22 <merijn> koz_: Mind you, streamly seems to run pipeline parts in parallel so that would make it tricky business to share a resource across streamly stages
15:10:36 <koz_> Which is probably why its so non-committal vis a vis external resources.
15:11:04 <koz_> I think I definitely need to learn about ResourceT, but at the same time, I think I'm justified in keeping my current design.
15:11:26 <merijn> koz_: tbh I found streamly's API rather complicated compared to conduit
15:11:56 <koz_> That's fair - it is pretty involved.
15:12:26 <koz_> Thanks for filling me in though - it was insightful and useful.
15:14:05 <merijn> koz_: I mostly know this because I've got my own code to parallelise/async stuff in conduit which required me to dive into it :p
15:14:21 <koz_> Sounds like both fun and frustration.
15:14:38 <merijn> koz_: Well, now that I've done it once I can use it forever, so that's good :p
15:14:53 <koz_> Yep, that is true.
15:16:01 <koz_> Welp, time to publish my library.
15:16:20 <koz_> (and then use it in my project instead of my one-time hack)
15:17:01 <maralorn> Is there a non whitespace sensitive equivalent of every whitespace sensitive syntax in Haskell? (As in I know that I can write do-blocks with { ...; ... }.)
15:17:46 <merijn> maralorn: all layout based syntax can be rewritten using { and ;
15:18:10 <merijn> This includes: let-in, case-of, where
15:18:27 <maralorn> Nice
15:18:47 <maralorn> Can I tell brittany to always format to that?
15:19:27 <merijn> No clue, I don't use auto-formatters on account of "being an artist" and making up my layout as I go :p
15:20:46 <maralorn> I often fall into the trap of having a wrong indention somewhere and then getting very weird syntax errors often in strange positions.
15:21:01 <merijn> maralorn: Have you read: https://en.wikibooks.org/wiki/Haskell/Indentation
15:22:23 <merijn> The rules are fairly simple. Keywords introduce layout based on the next non whitespace and insert a {, lines with bigger indent are line continuations, lines with same indent insert ; and lines with shorter indent introduce }
15:25:28 <koz_> merijn: I don't think I've heard that referred to as 'being an artist' before. :P
15:28:02 <maralorn> merijn: Yeah, I think I know the rules. I just believe that I would be quicker in writing and refactoring code if I would use the {..;..} syntax.
15:42:58 <ephemient> so... what could make GHCi run something 10x faster than the same code compiled with -O
15:43:21 <paulasdf> Does anyone know any tutorials on the mtl library? I always forget how to use it...
15:46:28 <ephemient> do start <- getCPUTime; readFile "day3.txt" >>= print . day3a; end <- getCPUTime; print $ fromIntegral (end - start) / 1000000000000 -- 0.5s
15:46:34 <ephemient> stack bench --ba '"Day 3/part 1"' # 5s
15:46:44 <ephemient> https://github.com/ephemient/aoc2019/blob/hs/src/Day3.hs
15:46:59 <merijn> CPUTime doesn't measure actual time
15:47:04 <merijn> It measure, well, CPU time
15:47:09 * hackage random-fu 0.2.7.3 - Random number generation  https://hackage.haskell.org/package/random-fu-0.2.7.3 (DominicSteinitz)
15:47:17 <ephemient> I get that, but it lines up with actual stopwatch time
15:47:32 <ephemient> as measured by me in reality
15:48:01 <ephemient> GHCi returns a result quick, `stack run 3` returns a result slow
15:53:04 <NemesisD> is it possible to use Generic to introspect the constructors of a type? If I've got `data AB = A Int Char | B Bool deriving (Generic)` and i've got `class Foo a where gen :: a` with Foo instances for Int, Char, and Bool, i want to use Generic to give me `[A gen gen, B gen]`
15:53:33 <glguy> yeah, that sounds like something you can do
15:53:52 <NemesisD> it seems like i'd want to do something with `Rep`, like reflect it on the value level
15:54:30 <glguy> You'll write a class with instances for (:+:), (:*:), M1, K1, U1, V1
15:55:01 <glguy> map to :: Generic b => [Rep b x] -> [b]
15:55:14 <glguy> to get back from the list of generic stuff to your actual type
16:04:06 <NemesisD> glguy: would that class with those instances return a list or something? the part i'm struggling to wrap my head around is where i'm getting the list of the different constructors from nothing
16:04:24 <koz_> NemesisD: That is part of Rep.
16:04:35 <glguy> yeah: genericThing :: [Rep b x]   would be the class method
16:04:42 <koz_> You can think of Rep as a 'canonical' representation of your type in terms of (:+:), (:*:) and so forth.
16:05:04 <glguy> You'll know what to put in the list because you know what type you're working with for each instance
16:08:33 * merijn sighs
16:08:48 <merijn> A deterministic algorithm is non-deterministically failing...yay
16:09:10 <koz_> merijn: Uhh, wat.
16:09:17 <merijn> koz_: Exactly
16:11:15 <merijn> koz_: I have an algorithm that finishes in a deterministic number of steps determined by the input, and that always does so when I run it manually, but somehow inserts garbage into my data when run by code...so I'm left to work out why
16:11:33 <koz_> Oh, delightful.
16:11:46 <merijn> At this point I'm considering "hardware failure"
16:11:53 <koz_> This is exactly the kind of thing you wanna be dealing with on an [insert any day] [insert any time of day].
16:17:04 <ammar2> merijn: run by code vs run manually?
16:17:39 <merijn> ammar2: yeah
16:18:41 <ammar2> merijn: how are you running it manually?
16:20:15 <merijn> ammar2: It's the exact same code/commandline, just being run by a program, as opposed to me running it in the shell, but further debugging will have to wait until some other time, it's getting way too late
16:21:04 <ammar2> okay that makes more sense, i dunno why I was imagining you running the algorithm on paper
16:21:13 <ammar2> and then writing code and being like "why doesn't it work"
16:22:23 <merijn> Time to sleep and despair in my dreams...
16:22:53 <koz_> merijn: Hope that nobody throws an async exceptions at you.
16:23:13 <koz_> s/exceptions/exception/
16:31:59 <amalloy> ammar2: fwiw that's exactly what i imagined
16:47:35 <AWizzArd> About compact regions. How do they work? When I have some value, say a linked list or a map, then this is essentially a pointer to the root of a tree, where all leaves are scattered in RAM.
16:47:39 <AWizzArd> Does a `compact` call now traverse this whole thing and copy everything into a (C) byte array, without gaps? I.e. compacted?
17:03:06 <dmwit> AWizzArd: yes
17:03:21 <dmwit> I don't know why you put (C) in there, and I don't agree with it, but yes to the rest.
17:09:12 <ephemient> oh. my earlier question about GHC being slower than GHCi
17:09:20 <ephemient> +RTS -n is what makes it 10x slower
17:09:51 <ephemient> not sure why yet
17:10:57 <AWizzArd> dmwit: I am only guessing that under the hood some manual malloc’ing takes place, and I just called it C byte array.
17:12:08 <dmwit> I don't know whether it calls malloc. Without knowing for sure, my a priori guess would be no, and that GHC has implemented all its own allocators and stuff.
17:14:12 <AWizzArd> So that way the name “compact” really makes sense. It is just one byte array and a linked list is still a linked list, only that it is this time not pointing far away, because the next cell really IS a neighbour, in RAM.
17:14:51 <AWizzArd> dmwit: but then what is `compactWithSharing`?
17:15:47 <dmwit> The docs seem like they describe the difference pretty well to me. Which bit of it did you find tricky?
17:16:52 <ephemient> ok, +RTS -N -qg is also fast
17:17:03 <ephemient> so parallel GC makes it slow for some reason
17:23:28 <oscarvarto> How can I make https://paste.gnome.org/p2rijygsc to compile?
17:23:49 <oscarvarto> I have an error because of ambiguous implicits
17:24:05 <oscarvarto> I would like to hide Prelude definitions
17:25:30 <dmwit> What is the error?
17:26:19 <dmwit> Oh, do you have some custom Data.Eq module? Perhaps look at the PackageImports, then?
17:26:45 <ephemient> did you mean: instance (DEq.Eq a, DEq.Eq b) => DEq.Eq (a, b) where (a1, b1) == (a2, b2) = (a1 DEq.== a2) && (b1 DEq.== b2)
17:26:48 <dmwit> Or... yeah, I don't know what you want. Probably that plus add more DEq qualifications to things. But I don't know.
17:27:13 <dmwit> ephemient showing you how to add more qualifications there ^_^
17:29:21 <oscarvarto> A minimal example: https://paste.gnome.org/pp0fgv57l
17:29:28 <ephemient> hmm, so +RTS -N -qg1 is still fast, but +RTS -N -qg0 is slow
17:30:20 <oscarvarto> the error is Duplicate instance declarations
17:31:48 <zeta_0> how would i insert a double quote in after M-  , i might have to disable smartparens while i do this?
17:32:10 <zeta_0>                 , ("M-", windows $ W.greedyView "2")
17:32:10 <zeta_0>                 , ("M-S-", windows $ W.shift "2")
17:32:13 <oscarvarto> https://snipboard.io/jq2SnP.jpg
17:32:42 <zeta_0> i am doing this for xmonad?
17:32:54 <dmwit> You cannot choose not to import instances.
17:33:05 <dmwit> Instances are global.
17:33:24 <oscarvarto> OK
17:33:46 <oscarvarto> So, that means I got the exercise right
17:34:00 <oscarvarto> but would not use that in actual code
17:34:40 <oscarvarto> Thanks
17:34:59 <dmwit> zeta_0: You can see the complete list of supported special keys here: http://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Util-EZConfig.html#v:mkKeymap
17:35:36 <dmwit> Double-quotes are not in there, from a quick scan, so you may have to use the raw interface rather than EZConfig for those bindings.
17:35:44 <dmwit> You may also like the #xmonad channel.
17:36:52 <zeta_0> like this?
17:36:56 <zeta_0>                 , ("M-'"'", windows $ W.greedyView "2")
17:36:56 <zeta_0>                 , ("M-S-'"'", windows $ W.shift "2")
17:37:06 <Clint> what kind of keyboard is that?
17:37:49 <zeta_0> put a double quote between a pair of single quotes? https://stackoverflow.com/questions/19630973/printing-a-double-quote-in-haskell#19631260
17:38:11 <zeta_0> or does that have to do with something else?
17:38:58 <zeta_0> i remember someone showed me how to insert characters but i completly forgot
17:39:05 <dmwit> zeta_0: No, not like that.
17:39:15 <dmwit> Like I said: cannot be done with EZConfig.
17:39:19 <dmwit> You need to use the raw interface.
17:40:16 <dmwit> The Haskell string syntax for the string M-S-" is "M-S-\"".
17:40:39 <dmwit> But it doesn't matter, because what matters here is what EZConfig supports, and I believe that isn't included.
17:41:26 <zeta_0> dmwit: ok i remember doing that let me try it again to see if it works
17:41:46 <dmwit> Okay, from reading the source, it seems I am wrong.
17:41:53 <dmwit> "M-S-\"" should work.
17:42:16 <dmwit> The source claims to work for ['!' .. '~'].
17:42:21 <dmwit> > ['!' .. '~']
17:42:23 <lambdabot>  "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghi...
17:43:22 <zeta_0> dmwit: cool, one second
17:47:14 <zeta_0> dmwit: could you repost that one more time, i can't seem to find the logs
17:50:22 <zeta_0> can someone paste a link to todays logs please, thanks
17:50:39 <dmwit> "M-S-\""
17:52:14 <ysangkok> zeta_0: http://tunes.org/~nef/logs/haskell/19.12.05
17:52:58 <zeta_0> thanks guys
17:54:24 <maralorn> Is there something that can derive Maybe getters vor Sumtypes? Like for data A = Number Int | Label Text, I get numberMay :: A -> Maybe Int for free?
17:55:31 <maralorn> (While asking that question I realize, that I will read the words lens or prism in the next few seconds …)
17:59:58 <zeta_0> `
18:00:14 <zeta_0> dmwit: it worked, thanks
18:05:04 <bl4ckb0ne> is there a way to print an IOUArray?
18:15:41 <glguy> You can freeze it and print that
18:19:02 <infinity0> hoogle can't find the S combinator s x y z = x z ( y z )
18:19:18 <infinity0> in all these years of haskell existing seriously no-one uploaded it?
18:21:36 <Clint> :t ap
18:21:38 <lambdabot> Monad m => m (a -> b) -> m a -> m b
18:21:51 <iqubic> Just use fmap.
18:22:12 <nshepperd> the S combinator is ap. also known as <*>
18:22:34 <iqubic> How is that the same as S?
18:22:58 <nshepperd> :t \x y z -> x z (y z)
18:22:59 <lambdabot> (t1 -> t2 -> t3) -> (t1 -> t2) -> t1 -> t3
18:23:10 <infinity0> ah, using the applicative instance for (-> c)
18:23:20 <iqubic> Ah.
18:28:22 <habbah> mapM_ (putStr . show)   =<<   runConduit $ yieldMany [1..10]   .|   mapC (\_ -> randomRIO (1,6))   .|   sinkList) -- results in No instance for (Show (IO Integer)) arising from a use of ‘show’
18:29:09 <habbah> I meant to type ... ( runConduit ...
19:17:09 * hackage lzlib 0.3.0.1 - lzlib bindings  https://hackage.haskell.org/package/lzlib-0.3.0.1 (vmchale)
19:25:39 * hackage taskwarrior 0.1.1.0 - Types and aeson instances for taskwarrior tasks  https://hackage.haskell.org/package/taskwarrior-0.1.1.0 (maralorn)
19:43:39 * hackage dhall-lsp-server 1.0.3 - Language Server Protocol (LSP) server for Dhall  https://hackage.haskell.org/package/dhall-lsp-server-1.0.3 (GabrielGonzalez)
19:44:39 * hackage dhall-json 1.6.0 - Convert between Dhall and JSON or YAML  https://hackage.haskell.org/package/dhall-json-1.6.0 (GabrielGonzalez)
19:46:09 * hackage dhall-bash 1.0.25 - Compile Dhall to Bash  https://hackage.haskell.org/package/dhall-bash-1.0.25 (GabrielGonzalez)
19:47:09 * hackage dhall-nix 1.1.10 - Dhall to Nix compiler  https://hackage.haskell.org/package/dhall-nix-1.1.10 (GabrielGonzalez)
19:48:09 * hackage dhall 1.28.0 - A configuration language guaranteed to terminate  https://hackage.haskell.org/package/dhall-1.28.0 (GabrielGonzalez)
20:40:56 <dmj`> advent of code day 5 really separated the men from the boys
20:41:36 <iqubic> Yeah.
20:41:54 <dmj`> hopefully today will be better
20:41:57 <dmj`> easier
20:47:21 <iqubic> jle`: 15 minutes
20:49:28 <dmj`> cannot wait
20:49:47 <iqubic> Neither can I.
20:50:22 <dmwit> bet you can
20:51:03 * dmwit slaps a $20 on the table
20:54:02 * glguy takes the $20 as payment for waiting. Thanks dmwit!
20:55:14 <dmwit> hol up
20:55:37 <glguy> There's a $5 hol up fee...
20:56:02 <glguy> It's a slightly discounted rate for a slightly shorter wait
20:56:27 <dmwit> are you saying i'm fat. i get my wait from my parents
20:58:33 * ephemient https://i.redd.it/dpd21clhca331.jpg
20:59:24 <glguy> <<04battlestations!>>
21:10:39 <iqubic> is it just me or is DAG broken?
21:10:51 <iqubic> @hackage daf
21:10:51 <lambdabot> http://hackage.haskell.org/package/daf
21:10:57 <iqubic> @hackage dag
21:10:58 <lambdabot> http://hackage.haskell.org/package/dag
21:11:01 <iqubic> Is that broken?
21:11:39 <koz_> iqubic: What precisely about it is broken?
21:11:51 <iqubic> Nix is complaining that it is broken.
21:13:59 <koz_> I dunno nix, so no comment on that I can sensibly make.
21:14:19 <iqubic> Ah.
21:14:33 <dmwit> ephemient: Oh, that's good. That's very good.
21:17:05 <doyougnu> I use nixos, typically if nix is saying the package is broken it means the nix build of the package, not the hackage library. Not sure if that's what you mean iqubic 
21:19:17 <iqubic> Yes that is what I mea.
21:19:23 <iqubic> The nix build is broken.
21:20:35 <doyougnu> you could try to allowBroken in a nix-shell to hack on your project in the meantime
21:20:49 <doyougnu> probably a bad idea...but its there :p
21:38:49 <iqubic> Can someone help me with megaparsec?
21:43:16 <iqubic> I have an input of the form "dsa)34d" and I want to parse that into "(String, String)", and I don't know how to do that.
21:44:46 <c_wraith> they're actually going to be all-caps, but that doesn't change much. :)
21:45:55 <pavonia> iqubic: There are infinitely many ways to do that, you need to be more specific
21:46:24 <c_wraith> something like (,) <$> many alphaNumChar <$ char ',' <*> many alphaNumChar
21:46:56 <c_wraith> err.  char ')'
21:48:01 <pavonia> Hhm, perhaps I'm missing context
21:48:07 <c_wraith> aoc day 6
21:48:15 <pavonia> Ah okay
21:51:33 <c_wraith> blah, I messed up the use of (<$).  Shouldn't have tried to be clever.
21:55:05 <c_wraith> Oh.  Just needed (<*) instead
22:00:38 <monochrom> I never bothered to learn (<$)
22:04:24 <MarcelineVQ> mostly it's like <* but with $ instead of *
22:11:39 * hackage pandoc 2.8.1 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-2.8.1 (JohnMacFarlane)
23:03:01 <dmj`> I never knew you could append +RTS -s -RTS when invoking ghc itself , never tried, but makes perfect sense
23:03:59 <dminuoso> dmj`: Matthew held an interesting talk about profiling ghc itself in London
23:05:12 <pounce> >map: if you don't care about ordering you should use `HashMap` >hashmap: this is depreciated, use Map
23:10:22 <pavonia> Conclusion: you should care about ordering
23:16:15 <sim590> Does anyone have comments about how I could simplify this depth first search implementation https://paste.debian.net/1119724/ ? The function also creates a spanning tree of the graph during depth first search.
23:26:07 <nshepperd> is there a runghc-like thing that compiles with optimizations
23:26:26 <nshepperd> runghc itself seems to behave exactly like ghci on my benchmarks
23:26:51 <dminuoso> Ah its a shame, skillsmatter is on administration. :( 
23:27:32 <dminuoso> kosmikus: Do you know whether skillscasts are still available somehow?
23:36:00 <maerwald> how does cabal new-run propagate signals to the invoked program?
23:43:04 <dmj`> dminuoso: do youhave a link ?
23:44:24 <dminuoso> dmj`: It's on a skillscast, but skillsmatter is on administration and their webservers have an administration notice. :*
23:44:26 <dminuoso> :(
23:46:56 <pounce> hhmm, is there a thing that's like a Map but from keys to multiple values instead of unique?
23:47:20 <jle`> pounce: i'd just use Map k (Set v) for that situation
23:47:41 <jle`> or Map k [v] is ok too depending on what you are using it for
23:48:04 <pounce> just feel weird about Map k [v] because then i'd have to map the maybe monad to a [] or something
23:48:10 <pounce> same w set
23:49:39 <nshepperd1> :t toList :: Maybe a -> [a]
23:49:42 <lambdabot> error:
23:49:42 <lambdabot>     Ambiguous occurrence ‘toList’
23:49:42 <lambdabot>     It could refer to either ‘F.toList’,
23:49:54 <nshepperd1> Sad
23:51:56 <haskeldjiq_> guys it may be a dumb question but
23:52:01 <pounce> :t msum' :: Maybe [t] -> [t]
23:52:03 <haskeldjiq_> would it be possible to print a scoped type variable
23:52:04 <lambdabot> error:
23:52:04 <lambdabot>     • Variable not in scope: msum' :: Maybe [t1] -> [t1]
23:52:04 <lambdabot>     • Perhaps you meant ‘msum’ (imported from Data.Foldable)
23:52:23 <pounce> https://hackage.haskell.org/package/monadplus-1.4.2/docs/Control-Monad-Plus.html would that work? <-
23:53:32 <[Leary]> % :t fold @Maybe
23:53:32 <yahb> [Leary]: Monoid m => Maybe m -> m
23:53:57 <pounce> ooh
23:53:59 <pounce> ok!
23:54:10 <pounce> so i just compose the map operations with fold and then it works lol
23:56:47 <jle`> haskeldjiq_: like the name of the type the variable is instantiated with?
23:56:52 <jle`> haskeldjiq_: or like, the name of the variable
23:57:02 <haskeldjiq_> jle`: the name it's instantiated with
23:57:24 <jle`> haskeldjiq_: only if you have a Typeable constraint
23:57:36 <haskeldjiq_> jle`: oh thanks, forgot about Typeable
23:57:46 <jle`> % typeRep @Int
23:57:46 <yahb> jle`: ; <interactive>:120:10: error:; * Expected kind `k0 -> *', but `Int' has kind `*'; * In the type `Int'; In the expression: typeRep @Int; In an equation for `it': it = typeRep @Int; * Relevant bindings include it :: Int a -> TypeRep (bound at <interactive>:120:1)
23:57:52 <jle`> % typeRep @_ @Int
23:57:52 <yahb> jle`: ; <interactive>:121:1: error:; * No instance for (Show (w0 Int -> TypeRep)) arising from a use of `print'; (maybe you haven't applied a function to enough arguments?); * In a stmt of an interactive GHCi command: print it
23:57:58 <jle`> oh it's from the wrong module
23:58:16 <haskeldjiq_> jle`: nevermind I got you, thanks!
23:58:23 <jle`> % Type.Reflection.typeRep @Int
23:58:23 <yahb> jle`: Int
