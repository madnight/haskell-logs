00:01:37 <ggole> call/cc in scheme is very different
00:01:49 <ggole> Scheme continuations aren't really functions at all
00:02:18 <amalloy> my imperfect understanding is that the one built into scheme is an undelimited continuation, sorta, while the haskell continuations are bracketed by calls to runCont or something
00:07:45 <shachaf> Yes, but they work the same way.
00:08:28 <fraktor> I'm trying to write a solver for nonograms, and I'm getting stuck on a function that, given a total amount of space and some block sizes, will generate a row-column of cells.  Here's my code so far: https://0paste.com/45937#hl
00:09:12 <fraktor> I'm not able to get it to compile for some reason; it's saying that there should be some additional lists around the return value for genRasters (I think? I'm not 100% sure).
00:11:38 <shachaf> If there's an error message, you should post it, rather than hoping people can guess.
00:15:25 <fraktor> Oh oops, thought I had.  https://0paste.com/45938
00:26:37 <qualiaqq> fraktor: The map in the `otherwise` part of the genRasters function is returning a `[[Maybe [Cell]]]`, but according to the type of genRasters it should be  `[Maybe [Cell]]`.
00:30:59 <qualiaqq> You could use `join` from Control.Monad to flatten the list. That will at least get rid of the error.
01:25:34 <javjarfer[m]> amalloy, Axman6 just for your interest I traced down the deadlock from yesterday, turns out that the deadlock is being produced by the `hmac_sha1` from the [crypto|http://hackage.haskell.org/package/Crypto-4.2.5.1/docs/Data-HMAC.html] library, each time I want to use the hash produced by that function, I hit the deadlock, it doesn't happens with `hmac_md5` tho
01:58:01 <siers> Is it possible to combine two monad readers (from libraries, not mine) with IO as inner monad?
02:03:46 <Geekingfrog> siers, not with mtl. You can only have something like ReaderT Env IO a. The `Env` record could contains two fields with the related env, and then you manually derive the corresponding MonadReader instances required by your libs.
02:04:09 <[exa]> siers: IO doesn't combine very well but if these are just readers it should kindof work
02:04:21 <[exa]> siers: you might want to try polysemy or something similar instead
02:45:30 <jusss> callCC :: ((a->m b) -> m a) -> m a
02:45:41 <jusss> callCCex1 = callCC $ \exit -> exit True
02:45:58 <jusss> exit :: ?
02:46:15 <jusss> exit :: (a->m b) -> m a?
02:46:23 <jusss> or exit :: a-> m b
02:51:13 <jusss> \exit -> exit True :: (a->m b) -> m a
02:55:48 <jusss> exit :: a -> m b
03:17:24 <fog> I want a Tree that can store values in different containers at each level
03:17:47 <fog> but then the Containers need to be stored in a HTree
03:18:07 <fog> but where only the containers and not the nodes change value
03:18:16 <fog> leafs*
03:18:25 <fog> s/nodes/leafs
03:18:58 <fog> then it seems like a version of a Tree that just inserted the value () at each leaf would do
03:19:14 <fog> but this would create a cyclic subgroup of a type defined using itself
03:20:05 <fog> since the type parameters that are the trees of container types, would need to be of the kind of this datatype
03:21:41 <fog> how can i represent the tree like kind of the parameter to the definition of this datatype
03:22:59 <fog> in a way which isnt recursive...
03:23:44 <__monty__> Why do you need a tree to represent the types? Wouldn't an HList suffice if it's one type per level?
03:24:15 <fog> the types themselves as they are hetrogenous need a lower nesting level of the Tree
03:24:22 <fog> as parameters
03:24:43 <__monty__> That's not an answer.
03:25:13 <__monty__> I can only see a use for a tree if every node can have a different container type and if so the typetree would need the same dimensions afaics.
03:25:45 <fog> its not a HList though, its something similar, as it takes type parameters corresponding to each value
03:26:15 <fog> and its the storage of these different parametrised HList-like things that is supposed to be stored somehow
03:26:32 <__monty__> A list can store a type for every level of a tree.
03:26:42 <fog> it could be like a HGraph, taking a HGraph of the same shape but full of types
03:26:49 <fog> the types of the values at the nodes
03:27:15 <fog> its not one type per level of a tree, as the lists that represent the branches at each level are hetrogenous 
03:27:19 <__monty__> So the HTree is of the same dimension as the Tree?
03:28:37 <fog> a HTree has a Tree of Type as its type parameter
03:29:20 <fog> calling this a VTree, as there is vertical heterogeneity of the containers through the depth 
03:29:42 <__monty__> I'm lost again.
03:29:48 <fog> a VTree has a "restricted" VTree of Type as its parameter
03:30:06 <fog> where this restriction is that only the containers at each level is hetrogenous
03:30:18 <fog> while the leafs are fixed to contain Type
03:31:24 <__monty__> Tree has nodes containing a different type of container at every level -> HList of types of the containers suffices afaics. Tree has nodes each containing a different type of container -> need a tree of types of the same dimension to represent these.
03:32:03 <fog_> but its not a tree! it has not got lists at each level
03:32:08 <__monty__> You can fix the type of the leaf nodes, just have an HList as type parameter for internal nodes.
03:32:45 <fog_> its not a HList! whatever it is is what we are trying to store
03:33:18 <__monty__> The HList would contain the *type* of the container at each level starting from the root.
03:33:18 <__monty__> The containers don't have to be lists.
03:34:32 <fog_> but they are horizontally as well as vertically hetrogenous
03:34:49 <fog_> so they need type parameters
03:35:10 <fog_> you want to have a HList at each level
03:35:47 <__monty__> An HList of HLists could do that. But it sounds like you want an HTree of the exact same dimensions as the Tree, either with fixed leaf nodes or skipping leaf nodes.
03:35:53 <fog_> you cant use a HList to represent eg the values of a HNonempty
03:36:02 <fog_> the types of the values of*
03:36:57 <fog_> you have to have the type of the container being used at that level also as the container used for the hetrogenous types, ie for the kind of the type parameter
03:37:10 <fog_> which ends up needing to refer to itself as that kind 
03:37:46 <__monty__> Why? You don't need an HList if you store a [] at a node.
03:38:21 <fog_> if it were a Tree it would have HList at every level, with a [] of types
03:38:38 <fog_> if it could instead eg have Nonempty at one of the levels, then it would need a Nonempty of types
03:39:03 <fog_> the [] of types at each level is just a Tree
03:39:30 <fog_> so a HTree, with HLists at every level, has a regular Tree of types for its type parameter
03:39:48 <__monty__> I don't think I'm gonna understand this without an example of a Tree that needs such types.
03:40:41 <fog_> but if there are changing hetrogenous containers at each level, then its not a Tree for the parameters, but instead the version of VTree which is fixed to have * at the leafs
03:41:08 <thblt> Hey #haskell, do you have a simple example of application-specific monads? I think I understand them reasonably well as generic ‚Äúcontainers‚Äù, but I fail to see why you'd need to create a higher-kinded datatype for a concrete application. I had a look at XMonad's X, but the definition is a bit too complex for me.  Thanks!
03:41:15 <fog_> ie, HTree corresponding to Tree was HList corresponding to its parameters being lists
03:42:04 <fog_> when we sought there the version of HList that was not hetrogenous, this is because there was * at every leaf
03:42:12 <fog_> so it didnt need to be hetrogenous anymore
03:43:00 <fog_> but when trying the same thing for this horizontally and vertically hetrogenous thing (different containers at each layer, and different types at the leafs)
03:43:38 <fog_> then it is only being made horizontally hetrogenous when we use it to represent Type at the leafs 
03:43:56 <__monty__> thblt: I think they're usually just shorthand for a particular stack of monad transformers. I.e. your application uses ReaderT to read its configuration, RandomT for some random numbers and IO to render information.
03:44:18 <fog_> so as we need to keep the vertical hetroginaity we cant break the cyclic reference
03:44:20 <thblt> (There's something subtly ironic in the fact that Google interprets a search for real world monads as a typo for real world NoMads)
03:44:30 <thblt> __monty__: thanks!
03:44:33 <__monty__> fog_: Could you give an example tree and its type in a paste?
03:44:38 <fog_> HTree could use Tree, not cyclic reference, but VTrees params need to be a VTree
04:46:29 <royal_screwup21> what's the semantics for the rhs of this syntax? 	foo:= src.(Source64)
04:54:20 <merijn> Needs context
04:54:23 <heebo> haskellers, I have a Producer a IO and I want to make it into a Producer a (MonadSafe x) , i think i need to hoist?
04:55:03 <merijn> Presumably you mean "MonadSafe m => Producer a m"? In which case, yes, hoist
04:59:34 <cdunklau> royal_screwup21: where did := come from?
04:59:50 <cdunklau> doesn't appear to be a built-in thing
05:02:03 <merijn> It's not
05:02:18 <merijn> This is either 1) not haskell or 2) intentionally written to be inscrutable >.>
05:03:02 <EvanR> can it be an infix constructor
05:03:40 <EvanR> for purposes of a row in an extensible record perhaps (library defined)
05:04:39 <heebo> hello merijn , how do i hoist IO into (MonadSafe m) ?
05:07:13 <kuribas> merijn: that's valid haskell
05:08:11 <kuribas> Source64 can be a constructor, := an infix constructor, and src a function
05:08:35 <nil> bah, they probably meant to ask in a go channel (Source64 seems to be a go thing)
05:08:43 <kuribas> nil: ah :-)
05:10:40 <cdunklau> kuribas: don't you mean :=)
05:11:00 <kuribas> := cannot be a constructor
05:11:33 <kuribas> but (:=) can
05:11:40 <merijn> kuribas: It is
05:11:50 <merijn> kuribas: Hence option 2
05:11:50 <kuribas> erm :=) cannot be a constructor
05:12:16 <heebo> oh i got it , hoist liftio
05:12:46 <merijn> And you *could* theoretically wrap a constructor named Source64 with (), but it seems unlikely anyone would write Haskell like that, unless intentionally being inscrutable
05:13:26 <hseg> Hi. In a project with random as a transitive dependency, cabal new-repl and cabal install random succeed, but ghcid fails with a -Wtab warning on System.Random
05:13:31 <hseg> How do I fix this?
05:18:07 <Ariakenom> merijn: I stumbled into some uninterruptibleMask in bracket discussions from 2014. Boy people had a lot to say. But was there no change in the end? 
05:18:47 <merijn> Ariakenom: I couldn't be arsed to fight it through in the end, when I finally slay my thesis somewhere next year I might try again
05:23:17 <Ariakenom> merijn: haha makes sense, I didn't even have the energy to read through it all :D
05:38:22 <kuribas> for my DB library, what would be better, replaceWhere (replaceJoin, etc...), or emptyWhere (emptyJoin, etc...) ?
05:38:53 <hseg> Hrm. Playing with the cabal invocation ghcid generates, the sticking point seems to be --ghc-options=-fno-code 
05:39:40 <kuribas> replace<Clause> would replace the clause by another one, empty<Clause> would just remove it.
05:40:07 <kuribas> with Clause being any SQL clauses (join, where, groupBy, etc).
05:41:21 <kuribas> so `replaceWhere ("age" >. 18)` would be the same as: `emptyWhere <> where_ ("age" >. 18)`
05:50:47 <kuribas> I'll keep the second
06:03:35 * polyphem 533z 7h3r3 4r3 1337 m4ny h4x0rz 0n #h45k311
06:29:58 <kuribas> hm, there always seems to be a tension between typeclassitis and having many similar named functions.
06:35:57 <kuribas> either you have messy type signatures, or you have a proliferation of functions
07:02:33 <maerwald> kuribas: why similarly named? Can have the same names
07:02:51 <kuribas> maerwald: only with typeclasses
07:03:21 <maerwald> why
07:03:46 <kuribas> you cannot have add :: Double -> Double -> Double and add :: Int -> Int -> Int
07:03:57 <maerwald> why not
07:04:03 <maerwald> https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Set.html#v:map
07:04:45 <kuribas> > let f :: Int -> Int; f x = x; f :: Double -> Double; f x = x in f 2
07:04:47 <lambdabot>  error:
07:04:47 <lambdabot>      Duplicate type signatures for ‚Äòf‚Äô
07:04:47 <lambdabot>      at <interactive>:1:5
07:04:49 <maerwald> use modules
07:05:45 <maerwald> I don't mind the idea of having ~10 different 'map' functions in different modules
07:06:13 <phanimahesh[m]> Name shadowing?
07:06:20 <maerwald> qualified imports
07:08:53 <__monty__>  Yes, containers is a very good example of how nice an approach this is.
07:09:58 <maerwald> in case of Data.Set, the decision was forced, because you can't write a Functor instance, but still
07:10:28 <maerwald> fromList is more common as a cross-module function I guess
07:11:01 <maerwald> and I don't see any benefit pulling it into something weird, like IsString
07:12:45 <maerwald> how often do you significantly change the core data types of your application and then say "thank god there are typeclasses, that made refactoring so much easier"
07:13:09 <maerwald> Chances are, that's exactly what you don't want, because performance behavior changes too significantly anyway and you'll have to wade through all your stuff manually anyway
07:13:14 <kuribas> __monty__: don't know if you are being ironic or not
07:13:39 <kuribas> maerwald: a lot
07:14:00 <kuribas> I just build a newtype over a monadstack, and get all the right typeclasses for free
07:14:17 <kuribas> same with Monoid/Applicative etc...
07:14:39 <kuribas> that only works because of typeclasses
07:14:42 <maerwald> I wasn't thinking of monad stacks, but containers etc
07:15:07 <maerwald> where changing the underlying data type most certainly has huge implications on performance and other details you'll have to go through
07:15:08 <kuribas> having traversable in containers is pretty much indespensable
07:16:13 <maerwald> this is one of the things I find uncomfortable: instances can have extremely wide raging different semantics
07:16:27 <maerwald> in some cases, that's what you want
07:16:31 <maerwald> in others: no
07:16:52 <kuribas> can have, but typically haven't.  It's up to the programmer
07:17:05 <kuribas> It's usually a good idea to have some laws.
07:17:48 <maerwald> well, we don't have performance laws :P
07:18:21 <kuribas> you can have good performance with typeclasses
07:18:30 <maerwald> what does that mean?
07:19:31 <maerwald> Typeclasses can make performance prediction of your codebase harder, because, depending on the instance that is chosen in the end, your control flow may have significantly different behavior if it's highly polymorhpic
07:20:39 <kuribas> What I mean is that in general, performance in haskell is "good enough", as in you don't have to worry about it.
07:20:44 <kuribas> Even with typeclasses.
07:21:01 <maerwald> Well, my experience is different, but ok
07:21:02 <kuribas> Order of magnitude better than Python/PHP
07:21:35 <__monty__> kuribas: I wasn't being ironic. How do I get an empty X? X.empty. How do I get an X of one element? X.singleton. Where X is Set, Map, etc. It's much nicer than `singletonSet`, `insertMap`, etc.
07:21:35 <kuribas> I do good design first, then optimizing for performance.
07:21:46 <kuribas> __monty__: right :)
07:21:55 <kuribas> it's nice, but can be annoying sometimes
07:22:04 <kuribas> especially with the multitude of ByteString versions
07:22:05 <maerwald> kuribas: well, most of the real-world problems I had with haskell were performance problems
07:22:25 <kuribas> maerwald: what kind of problem are you solving then?
07:22:38 <maerwald> and it wasn't "good enough" by default
07:23:02 <maerwald> required a lot of strictness analysation and reasoning about what the GC does and whatnot
07:23:11 <maerwald> kuribas: backend
07:23:56 <maerwald> maybe there will be a blog post about it at some point, from someone else who fixed half the codebases performance, hehe
07:24:08 <maerwald> and it wasn't trivial
07:24:10 <kuribas> your codebase?
07:24:15 <kuribas> sure, that would be interesting
07:24:20 <maerwald> kuribas: no, not mine
07:25:05 <maerwald> we used https://hackage.haskell.org/package/ixset-typed a lot also
07:25:23 <maerwald> which, I think, has performance problems on deletion
07:26:05 <kuribas> if you avoid some pitfalls, like using foldl, using lazy IO without consuming it directly, etc...
07:26:17 <maerwald> those were not the problems
07:28:59 <maerwald> application bootup time was beyond 2 hours at some point and it took a lot of time and knowledge until someone "accidentially" figured out the reason
07:29:26 <maerwald> it was laziness =)
07:37:56 <gambpang> What are the implications of using other-extensions in the cabal file?  The documentation is fairly vague about it.
07:39:01 <gambpang> For example, if you set TypeApplications in that field, but never use it, is it ignored?
07:39:33 <merijn> gambpang: The implications are nothing
07:39:49 <merijn> gambpang: The idea is that tooling can warn/report which extensions a package needs
07:39:51 <geekosaur> I'd expect that cabal would set a minimum ghc version based on its availability, at minimum
07:39:58 <merijn> gambpang: So it helps analyse hackage packages
07:40:32 <merijn> geekosaur: I don't think it does atm, but the idea is that it may in the future.
07:41:17 <merijn> Also, keep in mind that cabal does still support multiple compilers, not just GHC and this field can be used (unsure whether it is) to check compiler compatability (UHC for example implements some of the extensions GHC has, but not all)
07:42:48 <gambpang> The docs don't say what happens post 1.24, but your responses clarify that the current behavior is to ignore the field.
07:42:54 <gambpang> Thanks!
07:55:58 <cdunklau> i'm a bit confused with unfoldr... the docs say a is *prepended* to the list
07:56:43 <cdunklau> but `unfoldr (\b -> if b == 0 then Nothing else Just (b, b - 1)) 10` results in [10,9,8,7,6,5,4,3,2,1]... this looks like appending to me, not prepending
07:57:24 <cdunklau> since the output of the lambda is Just (10, 9)  the first time it gets called
07:58:14 <cdunklau> is that a doc bug, or am i massively confused?
08:00:21 <merijn> cdunklau: The *first* invocation has it's result prepended to the result of the recursive call
08:02:16 <merijn> cdunklau: You can view it as 'a' being prepended to the result of the recursive call or the recursive call being appended to 'a' (although the latter is more questionable since the 'a' is not a list)
08:14:44 <Amras> I'd like to be able to write an instance for a class which expects a * -> *, for an instance of Map (MyT a) a. I know I can do this with a newtype, I'm wondering if there's any way I can convince ghc that Map (MyT a) a is *->* with respect to a.
08:15:56 <glguy> newtype
08:28:24 <cdunklau> merijn: hm, i think i get it. `unfoldr f 10` winds up being `(fst (f 10)):(fst (f (snd prevResult))): ...` ?
08:29:06 <cdunklau> (ignoring the Maybe stuff)
08:30:16 <cdunklau> ooooh i think i get my confusion. `the resursive call` being the recursive call of unfoldr, not the provided function.
08:31:53 <merijn> cdunklau: Right
08:32:10 <cdunklau> sweet
08:32:11 <cdunklau> thanks!
09:02:28 <dmj`> have there been any projects related to building a traditional RDBMS in haskell
09:20:23 <tdammers> not that I know of, and I have a hard time imagining a situation where the value proposition of that would lead to viable economics
09:20:31 <tdammers> after all, PostgreSQL exists
09:21:11 <tdammers> so if you're going to write a new one from scratch, it would either have to beat PostgreSQL at its own game in at least some crucial aspects, or it would have to find a niche of its own
09:24:54 <polyphem> is there a theory for ADT-DB  ?!
09:27:37 <dmj`> tdammers: been reading some of Michael Stonebreakers papers, projects like c-store that evolved into Vertica and others. Column-oriented could have a niche
09:27:54 <dmj`> tdammers: also for pedagogy, performance could be had by doing a lot of it in C
09:29:02 <tdammers> dmj`: right, yeah, the pedagogical thing could be a valid reason. column-based wouldn't really be a "traditional RDBMS" in my book, and of course if you're building something in a different paradigm for which no production-ready solution exists yet, using Haskell isn't necessarily a bad choice
09:29:24 <dmj`> tdammers: lots of the work of building a DBMS fall into haskell's wheelhouse, parsing, virtual machine, data structures (B+ tree)
09:30:03 <tdammers> dmj`: absolutely. if I had to write one from scratch, I'd definitely evaluate haskell first.
09:30:18 <tdammers> dmj`: it's just that I don't see a situation where I would do that.
09:30:33 <dsal> It wouldn't necessarily need to be postgres.  It could try beating sqlite.
09:30:53 <tdammers> of course. but sqlite is hard to beat in its own arena too.
09:31:21 <dsal> Yeah.  Strangely, there are few things C isn't the best language for that we got the best implementations of things out of anyway.
09:32:19 <tdammers> hysterical raisins
09:32:38 <tdammers> even when better languages existed, C has been the least controversial choice for a long time
09:32:51 <dsal> The "nobody ever got fired" language.
09:33:23 <tdammers> for commercial dev, yes. and for open source, the one that everyone could make peace with somehow
09:33:54 <tdammers> everyone has strong opinions about C++, one way or another, but C is more likely to elicit a "meh, alright, I can make do with that" kind of reaction
09:34:46 <maerwald> tdammers: isn't that the same with C# for high level languages? I don't know people having strong opinions about it and even haskellers seem to be fine with it
09:35:47 <tdammers> maerwald: idk, I think C# has long suffered from being a "Windows-only" language, and even though it is not anymore, it's still a bit alien in large parts of the open-source world
09:36:00 <tdammers> maerwald: it's also quite similar to Java, and that one does provoke strong reactions
09:36:39 <dmj`> you could build a B+ Tree in C (or just use the one LMDB has), and then use Haskell to distribute it.
09:36:49 <dsal> I've never had to use C# for anything.  I met Erik Meijer a few years ago and he explained some neat theory.  I tried it and it made sense, but in a weird doesn't-fit-anything-I-touch kind of way.
09:38:00 <tdammers> my first proper professional programming gig involved C#, and also a lot of VB.NET. it was OK-ish, but not really super great either. at the time, it didn't feel very different from Java.
09:38:13 <dmj`> I met Erik Meijer many years ago and thanked him for writing LINQ (language integrated query), a monadic DSL for container types in .NET
09:38:23 <dmj`> it really makes C# incredible to use
09:39:01 <dsal> dmj`: Bryan Cantrill gave an interview where he described a significant performance increase in a codebase by porting it to rust because of how difficult it was to write the reusable structure in C.
09:39:02 <dmj`> C# does have first class functions now Func<Int,Int> = (x) => { ... }
09:39:07 <dsal> I kind of mangled that synopsis.
09:39:21 <maerwald> But I know what the GC in C# isn't really non-problematic either. A friend of mine worked on OpenRA, an opensource c&c engine and they had massive problems with memory leaks
09:39:24 <dsal> Hey, he described LINQ to me as a sort of pass-by-AST kind of thing.
09:39:40 <maerwald> (although not short of experienced C# devs)
09:40:57 * dsal is failing at English.  better just write some code
09:41:19 <dmj`> dsal: that's ... interesting. LINQ is kind of like SQL on datatypes, there's even an embedded DSL syntax that reads like a backwards SQL expression
09:42:08 <dmj`> but most people use the x.Select(x => x + 1).Where(x => x % 2 == 0) inline syntax (select = map, where = filter)
09:42:25 <dmj`> LINQ is what red-pilled me to get into F#, which red-pilled me to get into Haskell
09:44:40 <fragamus> argh I'm trying to use memoize on hackerrank and it seems like it is not really there even though they say it is
09:44:57 <fragamus> https://www.hackerrank.com/environment
09:46:10 <dmj`> LINQ-To-SQL was the best ORM out there back in 2010, worked on vanilla data types, nothing I've seen in Haskell comes close, maybe selda.
09:49:02 <tdammers> back when I used C#, LINQ was super new and not really used widely yet
09:49:13 <dsal> defunkt did something like this in ruby a long time ago (just looked at the repo, sigh)  https://github.com/defunkt/ambition
09:49:29 <tdammers> it was kind of cool, but also a bit useless in most actual situations
09:51:13 <dmj`> Always felt like 50% of the codebase for Java / C# was null checking...
09:52:09 <fraktor> dmj`: It's definitely gotten better with C#'s null-coalescing operators.
09:52:21 <dmj`> oh yea, was that ?? 
09:52:31 <fraktor> Yeah, and ?.
09:53:02 <fraktor> Sorry, that's not clear: `?.` It basically would only run the following function if the object is not null.
09:53:13 <fraktor> So it's literally >>= with Maybe.
09:55:03 <dmj`> that's nice, .SelectMany was >>= on [] in LINQ
09:55:15 <dmj`> basically flatMap
09:55:26 <dmj`> the rise and fall of flatMap in OOP
09:59:15 <dmj`> still think implementing a pedagogical DBMS in Haskell would be great
09:59:31 <dmj`> and surprised nobody has done it
09:59:43 <dmj`> downright disappointed actually
09:59:53 <fragamus> yeah im getting all misty
10:00:42 <dmj`> it's a lot to take in
10:15:14 <bitmapper> god
10:15:42 <bitmapper> i just searched through the internet, found old code, then proceeded to coax said old code into compiling
10:15:52 <bitmapper> and now i have a version of hugs that spits out GRIN
10:16:07 <bitmapper> somewhat
10:40:27 <wildtrees> bitmapper, what's GRIN? 
10:40:48 <bitmapper> a type of intermediate representation
10:46:56 <zeta_0> why is this piece of code throwing an error?
10:46:57 <zeta_0> mkYesod "Slash" [parseRoutes| / RootR GET /foo FooR GET |]
10:47:25 <zeta_0> the 1st `/` throwing an error?
10:57:54 <fweht> some question about monads that seems easy but i cant answer...  if i have an arrow f:C -> TD, with which law can i prove that f equals Œº(D) ‚àò T(f) ‚àò 1(C)?
11:12:00 <zeta_0> ?
11:14:06 <zeta_0> mkYesod "Slash" [parseRoutes| / RootR GET /foo FooR GET |]
11:14:59 <zeta_0> parse error input on the 1st `/` ?
11:18:54 * hackage call-alloy 0.2.0.0 - A simple library to call Alloy given a specification  https://hackage.haskell.org/package/call-alloy-0.2.0.0 (marcellus)
11:19:37 <polyphem> zeta_0: can you gist your code + error ?
11:20:24 * hackage bytesmith 0.3.2.0 - Nonresumable byte parser  https://hackage.haskell.org/package/bytesmith-0.3.2.0 (andrewthad)
11:36:11 <zeta_0> polyphem: i accidentally misplaced `module Main where` below the {- LANGUAGE -} pragma dsls, my mistake
11:36:18 <zeta_0> that error is gone now
11:37:21 <dsal> Yet again, I can't figure out why my program is so slow.  Forgot +RTS -N
11:38:56 <merijn> dsal: You mean it was slow if you forget -N or that is slow if you use -N?
11:39:30 <dsal> It was slow because no -N
11:39:49 <dsal> It's quite a parallel thing doing a bunch of IO.
11:39:53 <merijn> dsal: You know you can enable it at compile time and in code, so you can't forget? ;)
11:40:01 <dsal> Yeah, I should figure out how that works.  Weird build system.
11:42:26 <dsal> In the meantime, I'm now out of CPU.  Good time to get lunch.   :)
11:48:13 <glguy> maerwald: What do you think about a flag to ghcup that allows managing RCs as well as released GHC? (does it already do that?)
11:48:22 <fraktor> So I've written a nonogram solver (thanks for the help with that last night!) and I'd like to make the code more idiomatic.  I've got some if/then/else constructs, as well as explicit recursion.  Would anyone be willing to help me improve this code?  https://0paste.com/45996#hl
11:49:41 <maerwald> glguy: I haven't been able to find a simple solution for it yet. Would probably require some changes to the code
11:50:49 <maerwald> because a 8.8.1-rc2 installs ghc-8.8.1 binary, not ghc-8.8.1-rc1
11:51:01 <maerwald> that breaks some assumptions
11:52:17 <napo> could somebody give a little intuition re how `a -> m b` differs from `m (a -> b)` ?
11:52:56 <maerwald> napo: 'a' in the first example can decide what 'm' will be
11:52:56 <glguy> napo: (a -> m b) can generate a different m b depending on the a you provide
11:53:26 <maerwald> it's called dynamic effect flow vs static effect flow sometimes
11:53:33 <polyphem> fraktor: Check out csp package on hackage ...
11:53:45 <maerwald> napo: also check https://neilmitchell.blogspot.com/2019/10/monads-as-graphs.html
11:53:53 <glguy> :t \i -> replicate i True
11:53:55 <lambdabot> Int -> [Bool]
11:54:05 <glguy> :t [even, odd]
11:54:06 <lambdabot> Integral a => [a -> Bool]
11:54:21 <maerwald> napo: and https://stackoverflow.com/a/17412969
11:56:00 <scottyyy> I want to make a 3 part tetris program: Frontend, Backend, AI. The frontend communicates with the backend to render, the backend simulates the game, and the AI can send commands to the backend to play the game. Ideally I want the frontend to be on a website, the backend to be written in haskell, and the AI to be flexible (any language). What are my
11:56:00 <scottyyy> options?
11:56:21 <maerwald> scottyyy: options for what?
11:56:34 <scottyyy> Frameworks, libraries, etc
11:56:42 <scottyyy> Im not sure how to put everything together
11:56:59 <LKoen> scottyyy: you can create a protocol and require the ai to be an executable
11:57:08 <maerwald> frontend I'd go typescript every day
11:57:15 <LKoen> that communicates through its stdin/stdout
11:57:17 <jacks2> napo, "a -> m b" takes and and returns action, that will, when ran, return b. "m (a -> b)" is an action that, when ran, returns a functoin
11:57:18 <scottyyy> Im thinking there will be a common API for posting commands and getting information from the board
11:57:28 <jacks2> s/takes and/takes a
11:57:35 <scottyyy> Kind of like the HTTP protocol
11:58:15 <scottyyy> If i use typescript maerwald, how could I simulate the game on a website?
11:58:20 <scottyyy> That's where i'm stuck
11:58:53 <napo> ... these all make sense, thank you! 
11:59:10 <scottyyy> You go to a webpage, and it would need to launch the haskell backend so that the typescript can interface with it as well as any AI running locally
11:59:18 <dmj`> scottyyy: you should use miso, it's good for this sort of thing, you can share all the domain logic front and back, use websockets and deploy to AWS w/ nix
12:00:10 <scottyyy> I saw miso dmj` and was a bit overwhelmed by the build process (as well as setting up tooling). But if that's the best way then I can figure it out
12:00:11 <jacks2> napo, so if m is a Maybe, it is a difference between "a -> Maybe b"  and "Maybe (a -> b)". quite different
12:00:30 <amalloy> fraktor: some type synonyms would probably help. rasterize :: Int -> [Int] -> [[Cell]] doesn't make it easy to guess what the Ints are doing, whereas Int -> [BlockSize] -> [[Cell]] says a bit more
12:00:50 <dmj`> scottyyy: I have a setup that's decent, I should really make a blog post about this. 
12:00:52 <scottyyy> How would websockets come into play? (I'm not very familiar with the web ecosystem)
12:01:24 <dmj`> scottyyy: honestly, you could probably do it all on the frontend
12:01:31 <oats> scottyyy: just a way to communicate between the frontend and backend
12:01:46 <scottyyy> oh ok oats
12:01:47 <dmj`> scottyyy: human players don't communicate with other human players right
12:02:19 <oats> iirc websockets are just a standard for two-way communication over http(s)
12:02:24 <scottyyy> No, but the frontend should be flexible in the sense that it can either take inputs from a human or from an AI
12:02:49 <scottyyy> So if you wanted, you could just go to the website and play tetris normally no AI
12:03:04 <scottyyy> but, if you ran an AI locally, it could send commands to the game
12:04:19 <dmj`> oats: websocket protocol is initiated using an HTTP upgrade request, but the rest is handled over a TCP socket
12:04:33 <oats> oh, neat
12:05:14 <dmj`> scottyyy: you could probably swap out the function that sends commands based on whom you
12:05:19 <dmj`> 're playing against
12:05:43 <scottyyy> Oh I meant this is just for single-player
12:05:45 <dmj`> scottyyy: but what if you just start with an AI, no server, and build a tetris game, then add on networking / multiplayer / server afterward
12:05:55 <scottyyy> It's not vs
12:05:55 <dmj`> ah, ok
12:06:02 <dmj`> yea then that should be fine
12:06:23 <scottyyy> Hmmmm maybe I want to keep the possibility open though for bot vs bot or human vs bot
12:07:31 <scottyyy> I guess for now to avoid being overly ambitious, I'll just try and get it so that anyone can visit a public webpage that has a tetris client that can either take human input or input from a locally run AI
12:07:45 <scottyyy> I'm just not sure how to interface the game with a locally running bot
12:07:54 <scottyyy> Is that where websockets comes into play?
12:07:57 <fraktor> polyphem: Well yeah, that's the *smart* way to do it...
12:08:16 <fraktor> amalloy: That sounds like a good idea.
12:08:38 <dmj`> scottyyy: to watch an AI play tetris, you shouldn't need any websockets, or server for that matter
12:09:01 <scottyyy> ok so it would all be frontend
12:09:44 <scottyyy> I'm assuming I don't need HTTP because since the game is frontend all communications will be done locally
12:24:55 <polyphem> fraktor: its the wooosh (declrative way) not the tikitiki (value at a time) way
12:37:49 <heath> https://twitter.com/heathmatlock/status/1210659267709218818
12:38:35 <fenedor> does `$(stack path --compiler-exe) args` do more than `stack ghc -- args`?
12:40:17 <fenedor> e.g. probe the system somehow?
12:42:09 <__monty__> heath: Isn't visitor more like Traversable?
12:42:43 <heath> __monty__: I like ezyang's note on it: http://blog.ezyang.com/2010/05/design-patterns-in-haskel/
12:43:21 <heath> and there's https://github.com/thma/LtuPatternFactory/blob/master/README.md#visitor--foldable
12:44:29 <MarcelineVQ> fenedor: it probably does less, stack sets up packages and environment variables when it runs, the first one isn't running ghc via stack, it's asking where stack keeps ghc and running it directly
12:45:48 <fenedor> MarcelineVQ, for some reason `stack path --compiler-exe` fails in some instances which I did not expect... but it is a bit hard to explain the context.
12:45:58 <fenedor> I am currently trying if `stack ghc -- args` works better.
12:46:53 <fenedor> For some context, I am refactoring hie to be able to access the ghc version of a project. I thought, it would be smart to obtain the path of ghc once, and pass that around.
12:47:32 <fenedor> but it failed to create some packagedb for some unknown reason. 
12:47:44 <fenedor> at least for me unknown
12:57:24 * hackage mmsyn7ukr 0.3.1.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.3.1.0 (OleksandrZhabenko)
12:57:44 <MarcelineVQ> I, would guess, that stack needs to be the one to run things to have a valid packagedb set up. though I thought hie calls stack itself if it's run in a stack project so idk what could be at fault
13:05:29 <fenedor> yeah it does, so no idea why it is crashing
13:05:34 <fenedor> there seems to be some kind of race
13:05:45 <fenedor> since in ci, there are always different test-failures
13:10:40 <zeta_0> for some reason haskell-ide-engine is not recognizing some of the haskell packages that i am trying to import and i am getting an error: ghcmod could not find module, also it is telling me to add those packages as dependencies but i already have them installed? what is going on here?
13:12:08 <zeta_0> i am doing some web development with yesod, but for some reason hie is not recognizing any of the haskell web development packages?
13:14:04 <fenedor> zeta_0, did you add them to your package.yaml or cabal file?
13:21:04 <fenedor> does cabal v2-exec ghc only work when the project has been built?
13:21:42 <merijn> Define work
13:22:05 <fenedor> e.g. `cabal v2-exec ghc -- --numeric-version` returns `8.6.4` for my ghc-8.6.4
13:22:39 <fenedor> I guess, I can see why this question only makes semi-sense
13:23:40 <fenedor> before building project, or at least configuring it, makes it impossible to know the used ghc version
13:24:43 <zeta_0> fenedor: no just wrote some haskell code from the yesod book, so i need to do the cabal init command for these packages to be recognized by hie?
13:25:06 <fenedor> zeta_0, yes. 
13:25:19 <merijn> fenedor: cabal just uses whichever ghc is in your path unless you run configure with an explicit "-w" pointing at a specific ghc
13:26:17 <fenedor> merijn, yeah. Ok, so if the project has not been configured before `cabal v2-exec ghc -- --version` fails, but if I do `cabal v2-build --only-configure` before that, it works.
13:27:31 <merijn> fenedor: I guess exec only works if there's a plan.json that specifies the environment
13:28:00 <fenedor> yeah.. that is very unfortunate.
13:31:40 <fenedor> so, I guess there is no way to figure out the version of the ghc to build the project with before building it?
13:32:54 <merijn> fenedor: Eh..you just query the ghc in the path?
13:33:14 <fenedor> merijn, incorrect in general
13:33:16 <merijn> Since cabal just uses whatever is in your path, just running "ghc --numeric-version" will get you the version?
13:33:28 <hvr> merijn: unless there's a with-compiler: in some cabal.project
13:33:36 <fenedor> you can do `cabal v2-configure -w ghc-8.2.2` or something
13:33:48 <fenedor> and then `cabal v2-exec ghc -- --version` still doesnt work T_T
13:34:02 <merijn> hvr: Sure, but the question was "is there no way to get it before building the project" and the answer is "yes, you just run ghc --numeric-version"
13:35:10 <dmj`> just so hard to be happy this Christmas season knowing there isn't a DBMS written in Haskell
13:35:22 <hvr> merijn: fair enough -- if you know which ghc executable cabal would pick up :)
13:35:46 <__monty__> dmj`: At least there's project M36.
13:35:53 <hvr> dmj`: are you trying to nerdsnipe into writing one for you? ;)
13:36:14 <dmj`> hvr: that depends ... is it working? :)
13:36:56 <geekosaur> https://github.com/geekosaur/ghc-wrapper :p
13:38:33 <dmj`> __monty__: forgive me for not knowing more about project M36, but does it use an on-disk B+ Tree w/ a pager
13:39:01 <hvr> fenedor: fwiw, it'd be easy to write a 10-liner or so that useses https://hackage.haskell.org/package/cabal-install-parsers to tell you which `ghc` execucatble cabal would reach for...
13:40:41 <dmj`> hvr: if you were to do it, how would you do it ? I'd use alex + happy to parse the SQL, then some ADT for the VM instructions, and write the B+ tree in C, then FFI into it.
13:40:53 <fenedor> hvr, by only parsing the cabal.project and similar or does it also initializes some context?
13:41:26 <hvr> fenedor: merely parsing -- read only
13:41:44 <fenedor> And I would not have believed it, but this actually has dependencies that are not already in my dependency graph, lol *starts crying*
13:41:55 <fenedor> hvr, great, then it is the best solution for me, will give it a try
13:42:13 <fenedor> s/is/sounds like/
13:42:55 <hvr> dmj`: if you shell out to C ... can you still call it a "DBMS written in Haskell"? :)
13:45:06 <dmj`> hvr: yea, why not. Just newtype some C types, call it Haskell, nobody will be the wiser.
13:46:10 <hvr> aka postgresql-simple? =)
13:46:32 <hvr> or maybe a better example would be sqlite-simple as that doesn't require running an extra process
13:47:01 <dmj`> ok fine, do it all in Haskell first, but if its slow, then we can talk about the B+ tree being done in C.
13:48:04 <dmj`> could replicate sqlite first, sure.
13:48:23 <hvr> sure -- or let me rephrase, whats' the threshold of amount of "C backdoors" when you can't in good conscience call something a "Haskell" implementation?
13:48:25 <dmj`> maybe there is a way to use sqlite's test harness on this project...
13:49:18 <dmj`> hvr: as long as you're calling the main function from Haskell, we'll call it Haskell ;) 
13:49:50 <dmj`> just feel like dealing with pointers would be less verbose in C
14:01:18 <dmj`> just seems like such a good idea
14:01:28 <dmj`> lambda-lite
14:03:54 <jacks2> dmj' pointer stuff is less verbose in C. on the other hand, haskell has a lot more potential for abstracting commonly C idioms, than C itself
14:04:01 <jacks2> common*
14:06:48 <dmj`> jacks2: yea, tru tru
14:07:18 <dmj`> we could just swipe the LMDB B+ tree too... Howard Chu built a version of sqlite that used it and it was much faster.
14:27:53 * hackage mmsyn7h 0.2.2.0 - A program and a library that produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.2.2.0 (OleksandrZhabenko)
14:27:55 <wildtrees> how is this for using GADTs terms, where I can show the result of an eval https://0paste.com/46008 I had a simpler approach but Couldn't figure out how to show an unconstrained Term n from using a simpler Apply 
14:39:24 * hackage mmsyn7h 0.2.2.1 - A program and a library that produces a sound recording specified by the Ukrainian text.  https://hackage.haskell.org/package/mmsyn7h-0.2.2.1 (OleksandrZhabenko)
15:08:01 <jerry_jerry> Any comments to: I'm reading Lipovaca, M., 2011. Learn You a Haskell for Great Good! A Beginnerís Guide. No Starch.
15:22:52 <sm[m]> g'day all. Recently, show (toJSON (T.pack "a")) is showing "String \"a\"". I think it used to not have that String keyword. Am I right ? Any tips ?
15:23:15 <zeta_0> mkPersist [$persist| Entry
15:23:15 <zeta_0>                          title String
15:23:15 <zeta_0>                          day Day Desc
15:23:15 <zeta_0>                          content Html'
15:23:15 <zeta_0>                          deriving
15:23:15 <zeta_0>           |]
15:23:29 <zeta_0> parse error input `deriving` ?
15:24:45 <zeta_0> why is this piece of code throwing an error?
15:27:34 <zeta_0> i am missing the haskell package `sqlite` is this what is causing the error message ?
15:30:04 <MarcelineVQ> the error is a parse error, which mean that you've written/pasted something wrong or a required language extension isn't enabled
15:30:28 <Rembane> Enable TemplateHaskell, perhaps?
15:30:31 <MarcelineVQ> I'm bad at indentation rules so maybe you justneed to indent |] father, not sure
15:32:25 <zeta_0> i pasted this code then tried to fix the indentation: https://www.yesodweb.com/page/screencasts https://hastebin.com/cuvexiwuzi.rb
15:33:28 <zeta_0> haskell-ide-engine stops working after i do cabal init, so it is hard to spot errors
15:33:37 <dmj`> sm[m]: think its always been there
15:33:58 <ryn> What is the currently recommended  way to install/use haskell? stack?
15:34:22 <dmj`> ryn: heard about this thing https://www.haskell.org/ghcup/
15:34:37 <jackdk> I like nix, personally, but for getting started I think it's ghcup for GNU/Linux and macOS, and haskell platform core on windows
15:34:51 <dmj`> jackdk: nix is the future, that's for sure
15:35:18 <ryn> nope. i will check it out. thx.
15:35:28 <jackdk> a bit harder to onboard newbies, but yeah.
15:35:31 <dmj`> nix is the cure for the hatred of all other languages haskell brings, since you can at least build them reliably. 
15:35:32 <zeta_0> ryn: i would recommend the nix pacakge manager as well, no more dependency hell, things just work
15:35:58 <jackdk> depends on where you want to spend the learning budget though
15:37:27 <dmj`> nix is definitely harder to learn than haskell
15:38:11 <dmj`> but so worth it
15:38:22 <zeta_0> dmj`: they are both purely functional so i apply some of what i learned in haskell to nix
15:38:32 <zeta_0> to learn nix that is
15:38:57 <ryn> nix looks like it is a package manager? nothing to do with running haskell? am I looking at the wrong nix?
15:39:03 <dmj`> zeta_0: sure, but it's also not statically typed so harder to discover what stuff does w/o reading tons of source
15:39:09 <koz_> ryn: It can handle Haskell things too.
15:39:24 <koz_> It basically can set up isolated environments with _exactly_ the settings you want, down to what versions of everything.
15:39:28 <dmj`> ryn: its a language and a package manager
15:39:39 <MarcelineVQ> at this point I'd like to also vote to just use ghcup to get started
15:40:27 <zeta_0> dmj`: i agree
15:40:48 <ryn> hmm... i use pacman/yay... not sure if I want to add another package manager to my system. this it standard for managing haskell projects?
15:41:06 <koz_> ryn: You don't wanna use system packages for Haskell under Arch. Trust me.
15:41:06 <dmj`> ryn: if you just want haskell now, I wouldn't worry about nix until you want to deploy it to the cloud or something
15:41:11 <koz_> (and every other Arch user)
15:41:36 <koz_> So you're gonna have to manage that stuff with _something_, whether it's gonna be cabal, stack (which uses cabal) or nix (which I also believe uses cabal).
15:41:39 <zeta_0> ryn: nix will save you a lot of pain in suffering if you decide to use haskell, the nix infrastructure also has a lot of support for haskell, so that is another benefit
15:41:40 <koz_> Pick your poison essentially. :P
15:41:51 <MarcelineVQ> standard is to use cabal-install and let it retreive your project's dependencies, ghcup is to get you ghc and cabal-install
15:42:11 <zeta_0> debian + aptitude = dependency hell
15:42:17 <koz_> FWIW, what MarcelineVQ just described is what I use, except I don't use ghcup to get my GHCs.
15:42:36 <merijn> ryn: Arch maintainers have intentionally broken pretty much the entire Haskell environment and refuse to ship a sane configuration
15:43:51 <koz_> merijn: Is there any distro that does ship a sane configuration? Bonus points if you don't say 'NixOS'. :P
15:44:50 <ryn> hmm.. i just need to get re-acquainted with haskell  for a university class so I think I will start poking around with  ghcup and keep nix in mind if I run into problems and  need to go further with dependencies.
15:45:02 <merijn> koz_: afaik all the others just ship a regular GHC, so what's broken about that?
15:45:08 <koz_> merijn: Point taken.
15:48:23 <zeta_0> could you guys help me fix this code: https://hastebin.com/cuvexiwuzi.rb https://www.yesodweb.com/page/screencasts
15:49:21 <zeta_0> i think i am missing the haskell package `sqlite` for sqlite3 bindings, so that is probably one of the reasons why it is not working
15:53:24 <dmj`> zeta_0: did you try `sqlite-simple`
15:55:39 <zeta_0> dmj`: what is the difference between: `sqlite` and `sqlite-simple` ?
15:56:06 <dmj`> zeta_0: sqlite is deprecated in favor of sqlite-simple
15:56:07 <zeta_0> dmj`: the haskell packages of these that is ?
15:56:59 <dmj`> zeta_0: if you see Bryan O'Sullivan is the author, its safe to proceed
15:57:28 <zeta_0> dmj`: i did not know that, is this the case with other databases such as postgresql ?
15:57:58 <dmj`> zeta_0: yea, same exact situation
15:59:35 <zeta_0> dmj`: thanks for the information, also i just watched a video of that bryan o sullivan speaking yesterday, he is a very smart dude
16:00:04 <MarcelineVQ> Database.Persist.Sqlite is provided by   persistent-sqlite   not sqlite or sqlite-simple, but if you're getting a parse error that's not your issue
16:00:20 <dmj`> zeta_0: yea it's a crying shame Facebook has gobbled up all the best haskellers and taken them away from pushing forth the glory of Haskell into the next decade
16:01:45 <dmj`> just think of where we'd be if they weren't stuck working on implementing types in php 
16:03:53 <zeta_0> dmj`: yeah, i don't like proprietary anti-open source entities, anyways, functional programming is gaining momentum, so that is great, also other languages like idris look very promising
16:04:28 <dmj`> yea, idris needs to grow its ecosystem, but definitely looks promising
16:06:57 <zeta_0> dmj`: people have always trashed functional programming, eventually it is going to get to the point where you have to learn it
16:07:58 <jerry_jerry> https://learnyouashaskell.com (Learn You a Haskell for Great Good! A Beginnerís Guide, Lipovaca 2011)
16:08:17 <jerry_jerry> free
16:09:30 <sm[m]> ryn: "What is the currently recommended  way to install/use haskell? stack?" Since nobody cared to give you a simple answer, I will. Yes.
16:10:14 <MarcelineVQ> zeta_0: I suspect that $persist simply doesn't exist as a quasi-quoter anymore. could try a newer tutorial, this code is for the "Yesod Web Framework 0.4.0" video
16:10:40 <dmj`> zeta_0: yea, haters going to hate. I think we'll experience a bolshevik revolution of sorts, where programmers demand more functional langs from the big guys like google, fb, etc. 
16:11:07 <dmj`> zeta_0: my friend at FB says most people there he considers skilled programmers are learning haskell on their free time anyways
16:11:45 <dmj`> zeta_0: I dunno though, it's hard, GHC does need a large company to kind of work the kinks out of the RTS I'm sure
16:17:58 <zeta_0> dmj`: agreed, it's good that haskell is used in industry, but tools like ghc only have a little bit of support, so they need more manpower
16:19:22 <zeta_0> MarcelineVQ: ok, i'll look for a newer tutorial, i wish haskell was like java when it comes to backwards compatibility so you can run older code, oh well
16:19:49 <dsal> Are you sure more people would make ghc better?
16:20:47 <zeta_0> is yesod still the best for web development in 2019 or are there much better alternatives out there, the only haskell book for web development that i could find was yesod?
16:21:02 <dmj`> zeta_0: I might write a book for miso soon
16:21:56 <MarcelineVQ> zeta_0: well you probably could but you'd have to determine what versions of things are being used in the tutorial
16:21:58 <dmj`> zeta_0: having asterius out would be nice
16:22:25 <dmj`> zeta_0: web assembly will mean that stack will have support I think
16:23:25 <zeta_0> dsal: well whole industries are working on the c++ and java compilers as well as the open source, i would guess that ghc would benefit with more support, i plan on contributing soon, also i heard there was only 3 people contributing to ghc full time?
16:24:28 <dsal> What contributions are you planning to make?   I think platform support is the only thing that would be useful to try to keep up.
16:24:31 <dsal> (for me, that is)
16:25:20 <zeta_0> dmj`: i heard of that web assembly as well, but i heard that it is going to take some time before the haskell integration with web assmbly gets up and running
16:26:24 <zeta_0> dsal: i already build cloned ghc from gitlab and built it with ghc.nix, but i am still reading the documentation and trying to figure out a good place to start
16:26:41 <zeta_0> the internals of ghc look intimidationg
16:29:10 <zeta_0> there is a newcomers section but i am still trying to figure out which issue would be a good place to start: https://gitlab.haskell.org/ghc/ghc/issues?label_name%5B%5D=newcomer
16:30:40 <dsal> It's an interesting approach.  I'd normally expect someone to want to work on the thing that's the most personally needed or at least the thing one has the most experience with.
16:30:42 <zeta_0> sorry for the misspelled words
16:34:32 <zeta_0> dsal: what do you mean by that ?
16:36:09 <dsal> If there's nothing you particularly need out of GHC, then jumping into GHC seems like a strange way to contribute to the haskell ecosystem.  THere's plenty of stuff we all need.
16:36:30 <dsal> The only thing *I* need out of GHC is to maintain it on second-class platforms.
16:45:18 <jacks2> dsal what platform is that?
16:45:48 <yushyin> arm
16:54:25 <dsal> I have a lot of armbian.  8.8 supports aarch64 a lot better, but that's only some of the machines where I run Haskell code
18:33:06 <sammy0920> Is it necessary to have a very good knowledge of programming languages liks C, C++ etc to learn haskell?
18:34:10 <sammy0920> anyone?
18:35:16 <amalloy> dang, #haskell misses its 2-minute SLA yet again
18:38:28 <oats> is it possible to scroll through ghcid's output?
18:40:38 <sshine> hmm, Data.Monoid.Sum is a bit tedious for me right now.
18:44:00 <sshine> "getSum . foldMap (Sum . f)" doesn't feel much nicer than "foldl' (\acc x -> acc + f x) 0"
18:45:21 <glguy> using newtypes to select instances generally doesn't make very nice code, particularly for little one liners like that
18:45:26 <sshine> or even "sum . map f"
18:45:52 <glguy> And using foldMap you end up getting the wrong evaluation order like that
18:46:34 <koz_> ala Sum foldMap f works :D
18:47:52 <glguy> But gives the wrong evaluation order
18:48:25 <glguy> Actually the desired order will depend on what type you're folding, but it's wrong for lists
19:01:08 <oats> I've been translating little functions to point-free by hand for fun lately
19:01:14 <oats> (not actually using it in code, don't worry :P)
19:01:36 <oats> sshine's little lambda is equal to "(. f) . (+)"
19:02:05 <oats> it's kind of a satisfying little exercise
19:16:02 <audiofile> as a neophyte, which do I install - minimal, stack or haskell platform?
19:16:42 <c_wraith> what os?
19:17:05 <c_wraith> (regardless, probably not platform.  Unless windows, probably ghcup)
19:18:34 <audiofile> windows
19:24:07 <c_wraith> on windows I'd rather use WSL and then still use ghcup.  I don't know what people who actually develop on Windows do.
19:28:00 <audiofile> is wsl stable now?
19:31:16 <c_wraith> hasn't caused me any issues for about a year.  (The GHC runtime doesn't take minutes to start up on it anymore, either)
19:31:33 <oats> lol that's an important part
20:02:09 <sm[m]> stack just works, & includes lots of windows knowhow 
20:03:54 <pounce> just wondering, `lexeme sc (parser <* eof)` is a parser that consumes exactly one lexeme of input, right? (using megaparsec)
20:07:38 <heatsink> (<* eof) means that it fails if there's any unconsumed input remaining
20:08:09 <pounce> ye
20:08:38 <pounce> so this (<* eof) means that it must conseme 1 lexeme or fail, right
20:11:53 <heatsink> According to the documentation http://hackage.haskell.org/package/megaparsec-8.0.0/docs/Text-Megaparsec-Char-Lexer.html#v:lexeme
20:12:20 <heatsink> the code you gave will do the same thing as `parser` by itself
20:12:44 <fog> I'm still trying to defined HFree...
20:12:48 <heatsink> It will first check for eof, then check for any number of spaces, which will be zero because there are no spaces after end of file
20:13:20 <heatsink> `lexeme` parses a token followed by spaces and it ignores the spaces
20:13:40 <fog> https://pastebin.com/raw/1DDXuD0D
20:16:36 <fog> sorry there was an error it should have had;
20:16:40 <fog>   HFree :: fList HFree xs -> (HListOf fList) xs
20:18:13 <fog> the problem as it seems like it needs to have the containers in the HFree constrained 
20:18:46 <fog> but that maybe the version with an associated type to determine the hList from the fList is better than a functor constraint
20:19:10 <fog> because the function of the class should be at type instead of value level... 
20:19:50 <fog> otherwise it would be;
20:19:51 <fog>  HFree :: hList xs -> HFree (FMap UnHFree xs)
20:21:31 <fog> but that needs type level fmap... is that an ok thing to have as a constraint?
20:21:48 <fog> we seem to get that the containers have to be functors just because their types need to be
20:23:22 <fog> because they need to be when they are used as types*
20:26:11 <fog> i think i might prefer the type level requirement that an fList equivalent exists to the hList as a way to witness this Functorality
20:30:39 <pounce> how can i figure out the precedence of operators in haskell?
20:31:07 <hololeap> % :i (%)
20:31:07 <yahb> hololeap: (%) :: Integral a => a -> a -> Ratio a -- Defined in `GHC.Real'; infixl 7 %
20:32:19 <pounce> hmm, but it doesn't do that for me
20:32:30 <pounce> no im dumb it does
20:38:54 <fog> its like a backwards fmap, that type level args that have been mapped can be undone
20:39:49 <fog> i wonder why we dont have that at value level...
20:40:45 <fog> to be able to pattern match the function and original arguments from the result of a mapping
20:44:01 <fog> but you could demand that a function existed of type; [b] -> (a->b,[a]), which is the same as if it would instead return [(a->b),a] which is what you get if you had a version of a list with a smart constructor which took a function being mapped and the argument, which is just an fList
20:44:46 <fog> basically, if you have an fList and you can cast from it to a hList you have an inverse functor
20:45:23 <fog> "have an fList" ie, demand this type exists in correspondence with the hList
20:46:41 <fog> then instead of implementing fmap and trying to use inverse opperations to undo previous mappings, you implement a smart constructor for a corresponding fList
20:48:32 <fog> the fact the functions are left unapplied at the values means they can be canceled during the mapping of inverse opperations
20:50:37 <fog> and we seem able to pattern match on the type level functions when this reverse fmap is done at type level, whereas we cant pattern match on the functions being partially fmapped and left as thunks... 
20:51:58 <fog> which is probably why the FList GADT is more useful and apparent when type level programming 
20:52:21 <fog> because we can have inverse functors!
20:53:10 <fog> by being able to pattern match the type level functions stored in fLists
20:53:20 <fog> function*
20:54:35 <fog> but now I have the same problem with recursive subgroups!
20:54:36 <fog> type family HListOf (fList :: (k -> *) -> ((HListOf flist) k) -> * )
20:54:49 <fog> type family HListOf (fList :: (k -> Type) -> ((HListOf flist) k) -> Type)
20:55:13 <fog> Type constructor `HListOf' cannot be used here
20:55:34 <hololeap> what do you mean reverse fmap and inverse functors? do you mean a natural transformation to the identity functor?
20:56:26 <hololeap> you said undo
20:56:42 <fog> i just mean leaving maps as unapplied and being able to pattern match on these to cancel them
20:57:12 <fog> which is something we can only do at type level
20:58:11 <fog> im trying to express that an fList equivalent exists for each hList
20:58:47 <fog> which apparently requires recursive subgroup referencing 
21:04:04 <fog> the problem is that the fList takes as a type parameter its corresponding hList for the original values being mapped over. 
21:04:39 <hololeap> isn't what you said, leaving maps unapplied and pattern matching on them, basically what continuations can do?
21:05:22 <fog> maybe?
21:05:32 <fog> idk how
21:06:43 <fog> i want to be able to write;
21:06:43 <fog> data HFree t where HFree :: fList HFree xs -> (HListOf fList) xs
21:06:53 <pounce> anybody here know parsers and want to tell me im wrong
21:08:04 <hololeap> pounce: probably
21:08:13 <fog> i cant see how you could do that with continuations instead
21:08:46 <fog> its just to unmap the HFree arg "mapped" over xs by the fList's smart constructor
21:09:02 <fog>  FCons  :: f x -> FList f xs -> FList f (x ': xs)
21:09:22 <fog> (thats just for lists)
21:11:23 <fog> but i want to abstract over that for any other hetrogenous container that can have an equivalent smart constructor to represent that its values have been fmapped over
21:13:54 <fog> like, all functors should have this ability to leave the mapping unapplied
21:14:10 <fog> :t \f -> zipWith ($) (repeat f)
21:14:13 <lambdabot> (a -> c) -> [a] -> [c]
21:14:19 <fog> :t \f -> zipWith (,) (repeat f)
21:14:21 <lambdabot> a -> [b] -> [(a, b)]
21:16:22 <fog> and then to somehow commute this pair at the values into the constructor of the functor
21:16:47 <fog> the implementation of which is equivalent to an inverse-functor instance
21:17:03 <hololeap> fog: so i'm having a hard time following, but it seems like you are taking the idea of a heterogeneous list and trying to abstract it to a heterogeneous free monad
21:17:07 <dmj`> :t uncurry
21:17:08 <lambdabot> (a -> b -> c) -> (a, b) -> c
21:17:41 <dmj`> :t \f xs -> fmap (uncurry f) xs
21:17:43 <lambdabot> Functor f => (a -> b1 -> b2) -> f (a, b1) -> f b2
21:17:53 <fog> hololeap: the paste has HTree, HFree is closer to that; https://pastebin.com/raw/1DDXuD0D
21:19:51 <fog> dmj' its more like the Zip implementation of Applicative and using repeat, but without applying the functions
21:20:40 <fog> so using Zip instead of Zipwith in application of the repeated list of functions. i guess your trying to use fmap to avoid using repeat
21:21:34 <dmj`> https://github.com/rqlite/rqlite we need something like this, but in Haskell
21:21:36 <fog> hololeap: the connection is that different hLists are used at each level of a HFree
21:24:29 <hololeap> that's analogous to saying you need different lists to be used at each level of a Free, but that only makes sense for `Free []` (which is equivalent to your definition of Tree, btw)
21:26:20 <pounce> https://gist.github.com/4e554c4c/5652da81509490421af61af6200f0509 <- parser
21:27:36 <fog> different lists?
21:28:08 <fog> yeah hList/fList is a bit of a confusing name since really they are just Functors
21:28:34 <fog> different hetrogenous functors at each layer of the HFree
21:28:59 <fog> but each of them needs a type list of the types of its values, which are more HFrees
21:29:31 <fog> and we want to store this as the HFree but with all the HFree labels removed
21:29:54 <fog> ie, just the raw nested heterogeneous functors 
21:31:45 <pounce> idk probably going about everything all wrong though
21:50:07 <jchia_> I'm thinking of migrating my stack project to cabal v2-build. I know almost nothing about how to use cabal and I would like to learn how to use it with the "new style". Where's a good place to get up-to-date documentation on the "new style" of using cabal? I think there must be some tutorials and wikis out there that have old info and I would like to avoid them.
21:51:50 <jchia_> Is this where I should go if I don't care about "old style"? https://www.haskell.org/cabal/users-guide/nix-local-build-overview.html
22:10:58 <pounce> augh
22:14:03 <hololeap> pounce: what problems are you running into?
22:16:43 <pounce> it seems to have trouble with backtracking... but i think that's te <* eof
22:16:58 <pounce> but i don't know how to make it consume all its input otherwise
22:17:37 <amalloy> pounce: i imagine megaparsec's default behavior is to not backtrack
22:18:40 <hololeap> i looked at it recently and it's not very clearly stated
22:18:58 <amalloy> i would at least try something like: inDelimiters a = try . choice $ ...
22:19:20 <hololeap> from the docs for `try`:
22:19:23 <hololeap> "Please note that as of Megaparsec 4.4.0, string backtracks automatically (see tokens), so it does not need try. However, the examples above demonstrate the idea behind try so well that it was decided to keep them. You still need to use try when your alternatives are complex, composite parsers."
22:19:32 <amalloy> (relatedly, a delimiter is something that divides groups. a delimeter is what they weigh meat with at the deli)
22:20:37 <hololeap> i have hardly used megaparsec at all so i can't comment on this
22:20:41 <pounce> amalloy: well the thing is it works if i remove the eof
22:21:01 <pounce> humm, that's a good idea.. it tells you not to use try very often though
22:22:19 <amalloy> well, it reasonably wants you not to write parsers that require backtracking, but if you've written one that needs backtracking your choices are to use try or to refactor your grammar, i guess
22:23:31 <amalloy> regarding eof, are you sure there's not extra whitespace at the end of your input? a newline, say? if you can provide a concrete example of input working without eof but failing with it, that would be interesting
22:25:27 <pounce> amalloy: well i think that __excluding whitespace__ it should consume its input completely
22:25:57 <pounce> like, "(+ (*  1 2) 4) " should work but "(+ 1 2 3)" shouldn't
22:28:53 <pounce> humm or maybe lexeme does that already
22:30:57 <amalloy> i don't know how megaparsec differs from parsec either. i wrote a parser for scheme 6 in parsec 6 years ago and it looked a fair bit like yours, but without the lexing step
22:31:25 <pounce> hmmm
22:31:26 <amalloy> er, duplicate 6 there. i don't know what scheme 6 is, but i just parsed a very simple lisp grammar: https://github.com/amalloy/haskell-scheme/blob/master/Flatland/Scheme/Reader.hs
22:32:17 <glguy> megaparsec is like parsec; if in (p<|>q) p consumes any input then q is discarded
22:32:47 <glguy> try p does not consume any input if p fails
22:33:00 <glguy> Even if p consumed input
22:33:00 <pounce> ah makes sense
22:33:22 <pounce> but i don't want to do backtracking in `inDelimeters` because if a delimeter is hit there it'll always be a list
22:33:39 <pounce> at least where i call it
22:34:16 <amalloy> right, but you've written inDelimiters p <|> inDelimiters q <|> ...
22:34:42 <amalloy> instead of inDelimiters (p <|> q)
22:35:07 <pounce> ah
22:35:09 <amalloy> so the first one will consume the open paren and then fail, after which the rest will be unable to proceed
22:35:09 <pounce> yeah i just changed that
22:35:37 <pounce> that makes sense
22:36:02 <pounce> now i do (inDelimeters . choice) <all parsers for list structures>
22:36:33 <pounce> seems to be working better now. but it still fails if there's whitespace before the program and doesn't recognize text after it
22:36:48 <pounce> which i can reconcile with (space >> parseExp <* eof) but idk if that's good?
22:37:12 <amalloy> combining >> and <*. what a madman
22:37:25 <pounce> i-is it ok
22:37:39 <amalloy> i would write space *> parseExp <* eof instead, but of course it's equivalent
22:37:45 <pounce> oh
22:38:00 <pounce> sorry ;_;
22:38:34 <pounce> *>_<*
22:39:12 <pounce> humm, does >> operate in the same way as *> for monads?
22:39:34 <amalloy> yes, they are required to be the same
22:40:05 <glguy> With [mega]parsec you should consume whitespace at the end rather than beginning
22:40:23 <amalloy> that's interesting. why's that?
22:40:35 <pounce> that's why it failed, because i didn't consider whitespace at the beginning
22:40:46 <pounce> but i don't see any reason why " (+ 1 2)" should be invalid
22:40:58 <pounce> hmmm, or maybe it should be
22:41:30 <glguy> Because you want to avoid consuming inputs when possible so you can avoid using try all the time
22:41:41 <pounce> makes sense
22:41:56 <pounce> now i don't use try at all so i don't think i use backtracking except for strings
22:42:11 <amalloy> you don't even use it for strings
22:42:39 <pounce> updated gist: https://gist.github.com/4e554c4c/5652da81509490421af61af6200f0509
22:42:39 <amalloy> at any rate it looks to me like all of your string-based parsers never need to backtrack
22:42:51 <pounce> ah, i thought megaparsec just did that automatically
22:42:53 <amalloy> oh, i take it back
22:43:34 <amalloy> you do need to backtrack for strings, because "(lam f)" would otherwise get partially consumed in checking if it matches lambda
22:44:09 <pounce> ye
22:44:47 <pounce> okiii i think it's working now
22:44:49 <pounce> at least a bi
22:44:51 <pounce> bit*
22:44:54 * hackage repline 0.2.2.0 - Haskeline wrapper for GHCi-like REPL interfaces.  https://hackage.haskell.org/package/repline-0.2.2.0 (sdiehl)
22:46:33 <pounce> amalloy: supprised (lam f) parses correctly tbqh
22:48:02 <pounce> (lambda x) does not though... which im not sure if it's ok or not. probably shouldn't let `lambada` be a variable name since it's a keyword
22:49:25 <pounce> ok one more question since im going to bed (feel free to ping). i want to test all of this. i assume i should use HUnit whill i'll try to figure out; but how doi figure out if a parser has failed?
22:49:59 <pounce> oh‚Äîi guess `runParser` does that for me
