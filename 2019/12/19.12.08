00:58:36 <f8e3> hsell is a madhouse you dont wwant to get out of
01:11:49 <thevishy> Does docker-compose --scale automatically setup a load balancer?
01:12:34 <thevishy> Sorry, wrong window!
01:12:34 <koz_> thevishy: Sir, this is a Wendy's drivethrough^W^WHaskell channel. :P
01:12:39 <thevishy> :)
01:41:11 <paulasdf> Are computations in a state monad still considered "pure" if they are changing state? 
01:43:24 <shachaf> What is or isn't pure is up to you. Don't let other people's rules and definitions tie you down!
01:47:48 <jle`> paulasdf: yeah, pure or impure doesn't really make sense without a context/semantics of discussion
01:48:03 <[exa]> paulasdf: the computations are actually just chained into one giant pure function. So technically they are pure, although code doesn't look like that
01:48:19 <jle`> the giant function in the end is pure
01:48:29 <jle`> but conceptually/semantically, actions in the state monad represent impure actions
01:48:42 <jle`> it depends on what level you want to reason about your code in
01:50:06 <jle`> it depends on what you mean when you say 'computations in a state monad', pretty much, since how you interpret it will depend on what your goal is or what you want to use your conclusion to decide
02:46:50 <nil> any ideas how i might make this lazy in the output? https://git.monade.li/aoc/tree/2019/Intcode.hs#n16
02:47:12 <nil> so as to allow knot-tying using mfix, for example
02:48:49 <dminuoso> nil: Is there a chance you can reduce it to a simpler test case?
03:00:10 <smatting> Hi, I think I don't fully understand how dependencies of type class variables work - can somebody please give me some hints? My program (excerpt: https://gist.github.com/smatting/a01273035d5a84ed7f085be0f6db73ea) fails to compile with 'Could not deduce: r ~ '[Error ErrorMsg, State Program] ... ‘r’ is a rigid type variable'. If i replace "step" by "f" however it compiles. I guess the difference is that in
03:00:13 <smatting> "step" the type variable "r" is somehow "bound" and in "f" it is more "free"? How could this function be fixed?  I'm using the polysemy library here
03:01:43 <dminuoso> smatting: can you include the full compilation error you are getting?
03:02:23 <smatting> sure: https://gist.github.com/smatting/78cbcce14c80177636db65bf40d68b02
03:02:42 <dminuoso> I see.
03:02:50 <dminuoso> smatting: So in general a type variable means "callers choice"
03:02:52 <dminuoso> That means
03:03:00 <dminuoso> If you specify
03:03:06 <dminuoso> runProgramStep :: Members [State Program, Error ErrorMsg] r => Sem r () -> Program -> Program
03:03:20 <dminuoso> The caller/consumer of runProgramStep has the freedom to pick whatever `r` they want, as long as it satisfies the constraint.
03:05:09 <dminuoso> smatting: Can you include the type signatures for the bindings you are using?
03:06:21 <dminuoso> Ah well I guess the error is this
03:06:24 <dminuoso> % :t runError
03:06:25 <yahb> dminuoso: ; <interactive>:1:1: error: Variable not in scope: runError
03:06:35 <dminuoso> % import Control.Monad.Freer
03:06:35 <yahb> dminuoso: ; <no location info>: error:; Could not find module `Control.Monad.Freer'; Perhaps you meant; Control.Monad.Free (from free-5.0.2); Control.Monad.Error (from mtl-2.2.2); Control.Monad.Free.Ap (from free-5.0.2)
03:06:37 <dminuoso> Gah
03:06:51 <dminuoso> runError :: forall e effs a. Eff (Error e ': effs) a -> Eff effs (Either e a) 
03:07:04 <dminuoso> runState :: forall s effs a . s -> Eff (State s : effs) a -> Eff effs (a, s)
03:07:17 <smatting> https://hackage.haskell.org/package/polysemy-1.2.3.0/docs/Polysemy-Error.html#v:runError
03:07:29 <smatting> that's the one i'm using
03:08:01 <dminuoso> Okay, it's a similar case
03:08:29 <dminuoso> smatting: Let me construct a simpler example
03:08:34 <smatting> thank you
03:08:52 <dminuoso> % f :: Num a => a; f = (1 :: Int)
03:08:52 <yahb> dminuoso: ; <interactive>:189:6: error:; Not in scope: type constructor or class `Num'; Perhaps you meant one of these: `Sum' (imported from Control.Monad.RWS), `Nu' (imported from Data.Functor.Foldable); <interactive>:189:23: error:; Not in scope: `fromInteger'; Perhaps you meant `formatInteger' (imported from Text.Printf)
03:09:00 <dminuoso> smatting: ^- is it clear why this fails to type check?
03:09:35 <dminuoso> Oh gah
03:09:41 <dminuoso> What went wrong there
03:09:49 <dminuoso> % :q
03:09:49 <yahb> dminuoso: 
03:09:53 <dminuoso> % f :: Num a => a; f = (1 :: Int)
03:09:54 <yahb> dminuoso: ; <interactive>:1:23: error:; * Couldn't match expected type `a' with actual type `Int'; `a' is a rigid type variable bound by; the type signature for:; f :: forall a. Num a => a; at <interactive>:1:1-15; * In the expression: (1 :: Int); In an equation for `f': f = (1 :: Int); * Relevant bindings include f :: a (bound at <interactive>:1:18)
03:10:03 <dminuoso> There we go. Someone apparently fiddled a lot with yahb :)
03:11:53 <smatting> dminuoso: kind of... the value of f must be any forall a. Num a, but 1 is a concrete type?
03:12:00 <dminuoso> smatting: Not quite.
03:12:19 <dminuoso> Well, put it this way
03:12:35 <dminuoso> smatting: There's two perspectives for `f`. There's the caller perspective and the implementors perspective.
03:12:48 <dminuoso> (caller/consumer vs callee/implementor/provider)
03:13:17 <dminuoso> The caller/consumer sees `f` as having the type `f :: forall a. Num a => a`, so it means the caller/consumer can decide/pick the type a, as long as it satisfies Num.
03:13:39 <dminuoso> The implementor cant know which type its going to be in advance, he has to provide a polymorphic value. 
03:13:47 <dminuoso> Now, in a more interesting example:
03:13:52 <dminuoso> f :: Num a => a -> Bool
03:14:14 <dminuoso> In this case, the implementor doesnt even provide the value, he gets some type of which he doesnt even know the type of `a`, they dont have control over it.
03:14:21 <dminuoso> smatting: ^- does this make sense?
03:14:58 <smatting> dminuoso: yes. the implementor can only use what the typeclass "Num a" provides, nothing more
03:15:15 <dminuoso> smatting: Right. More to the point, he cant make any particular assumption about what `a` is.
03:15:18 <dminuoso> he cant pretend its Int.
03:15:26 <smatting> dminuoso: makes sense
03:15:28 <dminuoso> Good
03:15:47 <dminuoso> In your case:
03:15:59 <dminuoso> runProgramStep :: Members [State Program, Error ErrorMsg] r => Sem r () -> Program -> Program
03:16:12 <dminuoso> The *implementor* of runProgramStep cannot make any assumption about what `r` is.
03:16:24 <dminuoso> They just know it has to satisfy `Members [State Program, Error ErrorMsg] r`
03:16:29 <dminuoso> So far so good, smatting?
03:16:36 <smatting> dminuoso: yes
03:18:06 <dminuoso> smatting: runError :: Sem (Error e ': r) a -> Sem r (Either e a) 
03:19:09 <dminuoso> smatting: This is not polymorphic in its second argument, this makes a concrete assumption that you have a type list whose first element is `Error e`
03:19:41 <dminuoso> smatting: But your runProgramStep gives the *choice* of that type argument to Sem to the caller. At the same time the implementation starts making assumptions it cant make.
03:20:44 <dminuoso> Concretely, based on your usage of runError and runState and run, it deduces that it carries *exactly* the effect list of '[Error ErrorMsg, State Program]
03:21:05 <dminuoso> It's n different than say
03:21:28 <dminuoso> % f :: Num a => a -> Bool; f x = test x where test :: Int -> Bool
03:21:29 <yahb> dminuoso: ; <interactive>:2:45: error: The type signature for `test' lacks an accompanying binding
03:21:37 <dminuoso> % f :: Num a => a -> Bool; f x = test x where test :: Int -> Bool; test = odd
03:21:38 <yahb> dminuoso: ; <interactive>:3:37: error:; * Couldn't match expected type `Int' with actual type `a'; `a' is a rigid type variable bound by; the type signature for:; f :: forall a. Num a => a -> Bool; at <interactive>:3:1-23; * In the first argument of `test', namely `x'; In the expression: test x; In an equation for `f':; f x; = test x; 
03:22:07 <dminuoso> Internally you assume a fixed effect list, and from the outside you make it polymorphic and state "I dont care which type list, as long as it has these members"
03:22:57 <smatting> okay, that makes somewhat sense to me. but why does this slight variation of my program compile:? https://gist.github.com/smatting/47603b4c8a58a4d8a72d58b3a0471a8b
03:24:52 <dminuoso> smatting: That's a good question, really. 
03:24:55 <smatting> "myFancyStep" is still polymorphic, right? It just feels that "r" in "myFancyStep" is different than the "r" in "runProgramStep" that makes the difference
03:25:03 <dminuoso> Exactly!
03:25:13 <dminuoso> smatting: So type variables can have different behaviors.
03:26:20 <dminuoso> smatting: A type variable can be thought to have two behaviors. "metavariable" and "skolem" behavior
03:27:14 <dminuoso> smatting: Given my example of
03:27:18 <dminuoso> % f :: Num a => a -> Bool; f x = test x where test :: Int -> Bool; test = odd
03:27:18 <yahb> dminuoso: ; <interactive>:4:37: error:; * Couldn't match expected type `Int' with actual type `a'; `a' is a rigid type variable bound by; the type signature for:; f :: forall a. Num a => a -> Bool; at <interactive>:4:1-23; * In the first argument of `test', namely `x'; In the expression: test x; In an equation for `f':; f x; = test x; 
03:28:36 <dminuoso> smatting: This implementation cant work, because `f` has to be ready for any choce of `a` that the caller/consumer/user of `f` is going to make.
03:28:47 <smatting> dminuoso: yes, i think i understand that part
03:29:12 <dminuoso> smatting: otoh that means, I can supply `f` to any other function that works with *any* choice for that type (assuming it satisfies num)
03:29:44 <dminuoso> Because some other function `g :: Num a => a -> Bool` happens to work with any choice of `a (that satisfies Num)`, so clearly I could use this in `f`.
03:29:53 <dminuoso> So I could have:
03:30:14 <smatting> dminuoso: yes, i think i understand that caller choice thing. i think what i'm still missing is this "metavarible"/"skolem" thing
03:31:27 <dminuoso> smatting: https://gist.github.com/dminuoso/2b0ca024481a3f3a31e45f29b3f7d63d
03:31:56 <dminuoso> That's a slight formalization of the topic.
03:37:38 <dminuoso> smatting: Intuitively, runProgramStep can't make any assumption about what choice is made for `r`. They have to be ready for `any choice of it`. That enables them to use any code with it, that itself can deal with any choice for that type.
03:38:15 <dminuoso> myFancyStep itself is ready for any choice of that type. It's not a solution in your case, it's just a basic observation of "skolem behavior"
03:39:51 <smatting> dminuoso: but using "myFancyStep" works and runs as intended. What I want to do now is to introduce a paramter "step" that can be used in place of myFancyStep. There must be some way I can do this, right?
03:41:39 <dminuoso> smatting: No. The problem is of more fundamental nature.
03:41:56 <dminuoso> smatting: You would need something like
03:44:11 <dminuoso> runError :: Member e r => Sem r a -> Sem (r `Sub` e) a` with a suitable type family Sub that just removes `e` from r.
03:44:22 <dminuoso> smatting: And I think something that general cannot exist, because the ordering of effects might be relevant
03:44:50 <dminuoso> err
03:44:56 <dminuoso> runError :: Member e r => Sem r a -> Sem (r `Sub` e) (Either e a)
03:46:01 <dminuoso> smatting: I think you're not using polysemy right. You're trying to run interpretations in the middle of freer code.
03:49:55 <smatting> dminuoso: ah yes, maybe you're right. "runProgramStep" is to general, beaucse no concrete choice for "r" would be allowed by it's type definition, but of corse the interpratations need a concrete r
03:50:44 <smatting> dminuoso: this makes now more sense to me, i think. It's really as basic as you emplained to me with the caller/callee distinction
03:51:56 <smatting> dminuoso: even though the type signature of "runError" doesnt look like it makes any assumptions about r - but the whole interpretation stack needs to do
03:52:25 <smatting> dminuoso: thanks! I think i need to refactor my program a little bit
03:56:20 <smatting> dminuoso: yes, i really get it now. If i use "myFancyStep" the function "myProgramStep" becomes the caller for "myFancStep" and can make a concrete choice for "r" (based on the interpreation stack). That's why it works. Thanks again for you time, dminuoso!
04:00:17 <smatting> dminuoso: in the version with "myFancyStep" the arg "step" is never used, so you can remove it and have https://gist.github.com/smatting/47603b4c8a58a4d8a72d58b3a0471a8b - my whole idea of "same r" was misleading
04:15:40 <dminuoso> smatting: Indeed. :)
04:59:58 <jpcooper> I have a monoid-like type T, with a function `pure :: T u`, and a function `combine :: T u -> T v -> T (Combine u v)`, where `Combine` is some type family. What class of monoid-like objects is T in?
05:00:20 <jpcooper> And are there libraries for dealing with things like T?
05:01:20 <jpcooper> Also T is applicative-like: There is a function `apply :: T u (a -> b) -> T v a -> T (Combine u v) b
05:01:32 <kish> does all this coding make you a better thinker? 
05:03:42 <sm[m]> it makes you see the everything as a types puzzle I guess
05:03:42 <maerwald> kish: what?
05:03:46 <jpcooper> Actually u and v are type of a kind k which can also be thought of a monoid, with Combine being the binary operation
05:05:16 <jpcooper> kish: It's called "Hasochism"
05:18:32 <merijn> hmm, is there a convenient "read as much as possible without blocking" for Handle?
06:02:51 <sandman13> what other benefits does record syntax have other than being able to specify values in random order and not having to write separate functions?
06:03:59 <maerwald> being potentially partial :>
06:04:13 <merijn> Eh...being able to name the argument is a pretty strong benefit
06:04:57 <hpc> there's some generic stuff that uses the extra information from record syntax to generate useful things
06:05:35 <maerwald> and with some extensions, you can allow ambiguous names
06:05:47 <hpc> naming things is a form of documentation as well
06:06:25 <hpc> i'll take (Point {x = _, y = _}) over (Point _ _) in my pattern matching any day
06:07:59 <maerwald> hpc: well, if you have lenses, why would you even pattern match
06:08:41 <maerwald> which is another benefit... generating lenses
06:08:45 <hpc> :P
06:15:00 <merijn> A benefit of not having lenses is...not having lenses :p
06:15:40 * merijn resets his "Days since I last had a bounds and/or memory ordering error"-sign back to 0
06:18:28 <__monty__> merijn: From 0 though, right?
06:18:41 <merijn> __monty__: From 2 days :p
06:19:06 <merijn> Or rather, I suppose I have actually had that error for those 2 days as well, just without being aware :p
06:19:49 <__monty__> See.
06:20:09 <sandman13> can this be written in another form (not using Record syntax)? "newtype Parser a = Parser { parse :: String -> Maybe(a, String) }"
06:20:27 <merijn> sandman13: Sure
06:20:59 <merijn> sandman13: "newtype Parser a = Parser (String -> Maybe (a, String))" ?
06:21:23 <maerwald> or GADT syntax
06:22:09 <sandman13> hmm using GADT syntax
06:24:55 <merijn> sandman13: I guess the real question is "Why do you ask?" and "Why not record syntax?"
06:25:38 <sandman13> merijn: I just want to see how hard is to convert back
06:26:23 <sandman13> and primarily because I want to know when to use record syntax
06:26:36 <merijn> sandman13: The only conversion is really "remove all field names, replace {} with () and manually rewrite the extraction function"
06:27:46 <merijn> sandman13: newtypes like that parser are usually written with record syntax to avoid having to define a separate "unpacking function", since the 'parse' field will give you 'parse :: Parser a -> String -> Maybe (a, String)
06:28:57 <sandman13> oh
06:29:12 <sandman13> nice nice
06:29:30 <sandman13> I was missing Parser a in my code while testing it out
06:30:40 <sandman13> this sounds a bit similar to methods of an object in OOP
06:31:09 <merijn> sandman13: Kinda, with the difference that there's no mutable state inside the object
06:31:18 <sandman13> yeah
06:31:29 <merijn> sandman13: You can actually use this to do something that I usually call "OO" Haskell
06:33:08 <merijn> sandman13: Define a record that matches your interface and then share state by having a hidden MVar/IORef and then you do "newObject :: Foo -> Bar -> IO Object; newObject foo bar = do { cfg <- makeConfig foo bar; mvar <- newMVar cfg; return Object { method1 = xyzzy mvar; method2 = quux mvar }"
06:33:45 <merijn> sandman13: Now your object is a nice OO style interface that support many different implementations that share state between methods via an MVar (or STM, or whatever you want)
06:34:14 <sandman13> seems weird
06:35:53 <merijn> sandman13: It's not very common, but it can be a useful trick
06:36:58 <sandman13> I need to look into MVar and IORef first
07:10:43 <seishun> is there a function that does map and fold at the same time? something like `(b -> a -> c -> (b, c)) -> b -> [a] -> [c] -> (b, [c])`
07:11:28 <lavalike> :t foldMap
07:11:29 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
07:11:36 <lavalike> if that's not it, I'm out
07:24:59 <dmj`> seishun: foldl' is a fold that can be a map as well
07:25:28 <merijn> dmj`: By definition so can foldr, then :p
07:25:43 <dmj`> map can be implemented in terms of folds
07:26:32 <seishun> in terms of foldr sure, but with foldl you'd have to append to the end, right?
07:26:54 <dmj`> :t \f xs -> foldr (\y ys -> f y : ys) [] xs
07:26:56 <lambdabot> Foldable t1 => (t2 -> a) -> t1 t2 -> [a]
07:27:14 <dmj`> > (\f xs -> foldr (\y ys -> f y : ys) [] xs) (+1) [1..5]
07:27:18 <lambdabot>  [2,3,4,5,6]
07:28:33 <dmj`> seishun: yea, foldl' will return the list in reverse order
07:28:39 <dmj`> > (\f xs -> foldl' (\ys y -> f y : ys) [] xs) (+1) [1..5]
07:28:41 <lambdabot>  [6,5,4,3,2]
07:28:53 <dmj`> so in the accumulator you can (++) instead
07:29:06 <dmj`> > (\f xs -> foldl' (\ys y -> ys ++ [f y]) [] xs) (+1) [1..5]
07:29:09 <lambdabot>  [2,3,4,5,6]
07:29:27 <dmj`> @src
07:29:27 <lambdabot> src <id>. Display the implementation of a standard function
07:29:32 <dmj`> @src (++)
07:29:32 <lambdabot> []     ++ ys = ys
07:29:32 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
07:29:32 <lambdabot> -- OR
07:29:32 <lambdabot> xs ++ ys = foldr (:) ys xs
07:29:57 <dmj`> AoC got my fold game up
07:30:37 <seishun> would you rather reverse afterwards or use (++)?
07:32:02 <dmj`> @src reverse
07:32:03 <lambdabot> reverse = foldl (flip (:)) []
07:32:14 <cocreature> seishun: sounds like you are looking for mapAccumL
07:32:48 <seishun> ohh that looks interesting, taking a look
07:33:15 <dmj`> :t mapAccumL
07:33:17 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
07:33:45 <kartjon> I'm new to Haskell - Only know to type ghci to get Prelude> -- then do some maths and :quit ---to exit. Anybody explain what &where get saved and I will be good to start
07:37:17 <seishun> > mapAccumL (\a b -> (a + b, show b)) 0 [1,2,3,4]
07:37:20 <lambdabot>  (10,["1","2","3","4"])
07:37:30 <seishun> I can work with this, thanks cocreature 
07:38:31 <geekosaur> kartjon, there's a command history in ~/.ghc/ghci_history (unix; don't know offhand the windows path) and that's it
07:38:47 <geekosaur> ghci has no way to save a session
07:39:28 <kartjon> geekosaur thanks 
08:04:08 <wikiemol> Hello, is there a function defined like so  (a <*>) . pure anywhere in the prelude?
08:05:54 <wikiemol> I suppose the type signature would be something like `f (a -> b) -> a -> f b`
08:06:50 <hpc> https://hackage.haskell.org/package/lens-4.18.1/docs/Control-Lens-Lens.html#v:-63--63-
08:07:26 <hpc> it's defined in a few packages with various names, but that's probably the easiest to use because lens is a popular dependency
08:42:50 * hackage cabal-fmt 0.1.2 - Format .cabal files  https://hackage.haskell.org/package/cabal-fmt-0.1.2 (phadej)
08:56:21 <slack1256> Can someone clarify this form me? I think this module https://hackage.haskell.org/package/gi-gtk-hs-0.3.8.0/docs/Data-GI-Gtk-Threading.html used to be inside the package gi-gtk. If so, why was it split? and, is there an analogue on bare gi-gtk?
08:58:46 <gergap> hi
08:59:02 <gergap> I'm trying to write this simple game: https://pastebin.com/jLG03WbP using haskell
08:59:42 <gergap> but I'm not able to call the simple function with IO Integers and couldn't figure out how to make Integers from IO Integers
09:00:20 <geekosaur> you don't, as such. you work in an IO action, which will let you "get" the Integer with <- (or >>=) but you eventually have to put it back.
09:00:46 <comerijn> gergap: The real trick is to reformulate your question and instead ask "how do I make a function working on Integers work on IO?" Which is generally via fmap or >>=
09:01:32 <gergap> comerijn: I was already reading of >>= and do syntax in the docs, but I was not able to get this working
09:01:40 <ggreif> IO is confinement. Don't try to escape, do your job inside it.
09:02:22 <gergap> I still don't get it how I can make pure functions work with the real world.
09:02:46 <geekosaur> slack1256, looks to me like they just split them out and you depend on this package to get them back. there's no "replacement" as such. gi is supposed to be multiple small packages instead of a monolith like gtk2hs (which was its original form)
09:03:07 <geekosaur> gergap, you fmap over the IO in general, if you have a pure function
09:03:08 <ggreif> main = fmap such readLn
09:04:34 <ggreif> sorry,   main = fmap succ readLn :: IO Int
09:04:45 <gergap> ggreif: how would I apply this to my game function?
09:04:58 <slack1256> geekosaur: You seem to be right. The author of both packages is "inaki" and were release on hackage the same day. I thought this was an non-official side library by other authors as they didn't share the GH repo.
09:05:26 <ggreif> gergap: what is the signature of your game function?
09:05:33 <slack1256> But if what you tell about gi-gtk being multiple small packages, then I won't have problem depending on this. Thank for clarification.
09:05:51 <gergap> ggreif: game :: Integer -> Integer -> Result see  https://pastebin.com/jLG03WbP 
09:06:12 <geekosaur> it is. and this would, unlike most of them, not be makeable by wrapping the C functions, so it makes a certain amount of sense that it'd be independent
09:06:25 <geekosaur> since it needs to integrate with Haskell threading, not C threading
09:06:46 <geekosaur> and likewise ComboBox which I see in there needs to be done differently to fit Haskell vs. C
09:07:12 <geekosaur> that's what they were talking about with the "idiomatic" in the package description
09:07:50 * hackage xmobar 0.32 - A Minimalistic Text Based Status Bar  https://hackage.haskell.org/package/xmobar-0.32 (JoseAntonioOrtegaRuiz)
09:08:48 <ggreif> gergap: using the `do` syntax you can view the world from the pure side : `do a <- readLn; b <- readLn; pure (game a b)`
09:11:14 <gergap> ggreif: the mainloop uses already the do syntax, but still I get compile errors when calling game. what am I doing wrong?
09:11:34 <ggreif> gergap: `pure` funnels a value "back" to the imperative side.
09:14:45 <slack1256> Now ghci always prints "/home/slack/.ghc/x86_64-linux-8.6.5/environments/default". Where can I read about environments on cabal 3.0.0?
09:17:17 <gergap> does somebody know useful real world examples for doing such things? When you google you just find esoteric examples like quicksort, which don't interact with the real world. Now I try to write the most simple guessing game which I wrote in my first C lesson within one hour, but I'm failing with haskell...
09:18:16 <dmwit> ?google io monad for people who simply don't care
09:18:18 <lambdabot> http://www.google.com/url?q=http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html
09:18:18 <lambdabot> Title: Уведомление о переадресации
09:18:26 <ggreif> gergap: what does the error say? (don't paste here, read carefully)
09:19:42 <dmwit> gergap: ^ I really like that IO tutorial, though admittedly I first read it long after I understood it; so I have no evidence one way or the other of how well it works for people that don't.
09:20:04 <dmwit> s/I understood it/I understood IO/
09:20:40 <gergap> ggreif: https://pastebin.com/jkpQUfNb
09:20:52 <ggreif> gergap: `output <- mapResult result` is fishy, `mapResult` doesn't return an IO action that you can draw from
09:22:19 <gergap> dmwit: thx for the link
09:22:28 <ggreif> gergap: same for `result <- game guess secret`. `game` is returning a pure value.
09:23:06 <ggreif> gergap: use  `let` to bind it to a name.
09:23:08 <gergap> ggreif: yes, why not? it;s a pure function
09:24:33 <gergap> ggreif: you mean "let result = game guess secret"
09:24:36 <ggreif> gergap: You can only "draw" (i.e. `<-`) from "actions" of `IO <sthg>` type.
09:24:52 <ggreif> gergap: yeah
09:25:24 <ggreif> Then you'll probably need to `derive Show` for `Result`.
09:25:33 <gergap> ggreif: but the issue remains that guess expect pure Integers and I just have real world IO Integers
09:26:07 <gergap> ggreif: wait, the error is different now
09:26:21 <gergap> is Int short for Integer, or a differente type?
09:27:03 <ggreif> gergap: nope, by drawing them from the action they become pure: `secret` and `guess` are both pure numbers
09:27:40 <gergap> ggreif: I got something that compiles now (still don't really understand it)
09:27:48 <ggreif> gergap: `Int` is finite precision (e.g. 64 bits), `Integer` is bigint
09:28:17 <gergap> ggreif: now I have a logic problem ;-) secret is changed all the time
09:28:35 <gergap> I need to put it somewhere else
09:28:49 <sm[m]> gergap: that’s a very good exercise you’re doing. Yes it can take longer than you think the first time. Here’s another example FYI: https://hub.darcs.net/simon/guess-the-number/browse/guess-the-number.hs
09:29:03 <sm[m]> Spoiler alert
09:29:23 <gergap> smm[m]: thx ;-) that is what I was searching for
09:29:41 <ggreif> gergap: sounds like `main` is where to go, then pass to `maintop`
09:31:41 <ggreif> gergap: the point of the "action" `computeSecret` is that it varies the value that you draw from it.
09:31:47 <gergap> ggreif: yes, harder than I thought
09:32:52 <gergap> I moved secret generation to main and want to pass it as argument to mainloop
09:33:04 <gergap> in C I would simply write "void mainloop(int secret)" ...
09:33:20 <ggreif> gergap: so `mainloop` needs an argument 
09:33:30 <gergap> mainloop :: Integer -> void ?
09:33:41 <gergap> there is nothing like void I guess
09:33:50 <gergap> maybe () ?
09:34:02 <ggreif> gergap: `mainloop :: Integer -> IO ()`
09:34:34 <ggreif> gergap: `mainloop secret = do` ...
09:34:45 <gergap> ggreif: yes, it works
09:35:52 <ggreif> gergap: :-)  and now go through it reading out loud using proper words for `<-`
09:36:12 <gergap> lol
09:36:36 <gergap> My first working haskell program. I need to mark this in the calendar ;-)
09:38:39 <sm[m]> gergap: congrats!
09:38:58 <sm[m]> it's all just elaborations of this
09:41:19 <gergap> one more question
09:41:46 <gergap> I just added the correct program termination condition "unless (guess == 0 && result == Match) $ do mainloop secret"
09:41:57 <gergap> the part with result == Match does not work
09:42:11 <gergap> No instance for (Eq Result) arising from a use of ‘==’
09:42:14 <evelyn> did you define an Eq instance for Match?
09:42:18 <gergap> nope
09:42:20 * hackage OpenGLRaw 3.3.4.0 - A raw binding for the OpenGL graphics system  https://hackage.haskell.org/package/OpenGLRaw-3.3.4.0 (SvenPanne)
09:42:51 <gergap> why does == work in the game's function definition but not here?
09:44:41 <gergap> I guess this works similar to operator overloading in C++, I was just wondering why this was not necessary in the definition of game...
09:45:11 <jpcooper> Does Haskell provide a way of representing proofs that values or the same value as other values?
09:45:19 <jpcooper> values are*
09:45:49 <gergap> this is the current version of the program: https://pastebin.com/WbmQXLub
09:45:58 <evelyn> gergap: I can't load your paste right now but it's likely that where you used it before, whatever you used it with had an instance of Eq defined already
09:45:58 <sarahzrf> jpcooper: not really
09:46:09 <jpcooper> sarahzrf: I'm not really sure how that would work anyway
09:46:12 <sarahzrf> there can be hacks sometimes depending on what you're trying to do, but
09:46:17 <sarahzrf> what ARE you trying to do?
09:46:25 <gergap> evelyn: no, my fault
09:46:30 <ggreif> jpcooper: there is `Data.Type.Reflection`, but it Is advanced material.
09:46:35 <jpcooper> Oh yeah
09:46:41 <gergap> there was not comparison of Result, just of Int
09:46:51 <gergap> Result was the "result", so an assignment
09:47:03 <evelyn> you can trivially write one though, something like `instance Eq Match where (==) Match Match = True` (You should get the idea, I don't know what your constructors are for that)
09:47:05 <gergap> I think I'll figure it out by reading the docs
09:47:21 <gergap> evelyn: thx
09:47:54 <sarahzrf> ggreif: isn't that for equality of *types*
09:48:10 <evelyn> gergap: http://book.realworldhaskell.org/read/using-typeclasses.html
09:48:29 <evelyn> this should be helpful as a starting point, I think.
09:48:37 <jpcooper> Basically I am trying to write a function that takes two Sets (package type-level-sets) and provides a tuple of four sets, where the first two correspond to the parts over the intersection, and the other two are the respective complements of the intersection of the two sets. I want to provide a proof that the respective intersection parts unioned with the respective complement parts are equal to the respective original sets
09:49:31 <jpcooper> It's not too important though
09:51:14 <gergap> thx a lot for all your help.
09:51:15 <ggreif> jpcooper: Haskell has no proof machinery for inequalities. You'll have a tough tome
09:51:19 <gergap> I not to leave now, bye.
09:51:24 <jpcooper> Cheers
09:51:41 <sm[m]> gergap: append "deriving (Eq)" to your Result definition
09:51:42 <ggreif> gergap: see. you
10:20:13 <__monty__> Does runghc compile and run or interpret? And what's the difference with runhaskell?
10:20:34 <hpc> runhaskell and runghc are the same
10:20:47 <hpc> they do what ghci does when it doesn't have precompiled code
10:20:54 <hpc> it makes bytecode and interprets that
10:21:18 <hpc> or it will also use precompiled code if available
10:21:24 <svipal> hey. is there any way to declare a function that will return a passed variable in a TH declaration ?
10:22:10 <ptrcmd> What's the difference between using `IORef s -> IO a` and `s -> IO (s, a)` for state monads?
10:22:50 <svipal> like `thThing :: a -> Q [Dec]`  `thThing a = do { dec <- [d| func x =   <somehow a>|]; return [dec]}`
10:22:55 <__monty__> hpc: So it might use precompiled libraries but bytecode compile and run a .hs file you pass it? THanks.
10:24:01 <geekosaur> ptrcmd, practically? the IORef one can have the state shared across multiple threads or callbacks
10:24:25 <ptrcmd> geekosaur: yeah, practically
10:24:53 <ptrcmd> e.g. this definition uses IORef http://hackage.haskell.org/package/Agda-2.6.0.1/docs/Agda-TypeChecking-Monad-Base.html#t:TCMT
10:26:56 <geekosaur> I don't know enough about the Agda implementation, but usually you use an IORef across threads or callbacks as I mentioned. I don't know which would apply here (potentially both)
10:27:40 <ptrcmd> geekosaur: thanks :D
10:30:17 <svipal> dmwit ; I forgot to tell you : dec splices don't work in a class instance evenwith explicit {;}
10:36:01 <svipal> ah, solved my issue btw
10:48:42 * geekosaur btw specifically thinks you can't use a Dec there because that would let you nest instances, or put a class decl inside an instance
10:49:38 <dminuoso> ptrcmd: A relevant difference is that you can use the former in ReaderT and still have access to MonadUnliftIO ;)
10:50:12 <cocreature> geekosaur: given that the TH AST allows you to do this, it seems a bit weird to prevent it in splices
10:50:15 <dminuoso> The other one forces the bane of MonadBaseControl on you, if you ever need to unlift your monad. :)
10:51:20 <cocreature> thou shalt not mention MonadBaseControl
10:52:52 <dminuoso> By the way, is there some place where people share their golfed, fancy and mathematically pleasing solutions to AoC? Preferrably Haskell or similar?
10:53:02 <dminuoso> Want to compare my solutions. :)
10:53:06 <svipal> I still haven't begun AoC
10:53:29 <svipal> Do you like it so far this year ?
10:53:41 <lavalike> yes!!
10:59:42 <ptrcmd> dminuoso: thanks, will look into it :)
11:02:14 <nil> dminuoso: you might want to join ##adventofcode and/or ##adventofcode-spoilers
11:14:13 <maralorn> When I use a Map or HashMap, does every "insert" lead to a full copy of the Map?
11:14:55 <dmwit> No, only the part of the spine that needs to be modified.
11:15:03 <dmwit> This is why it is O(log n), not O(n).
11:15:32 <dmwit> (HashMap gets away with saying O(1) by putting an upper limit on n.)
11:17:11 <maralorn> And when I have a say State (Int,HashMap k v), then frequently changing the Int and just propagating the HashMap as is will not lead to a lot of copys?
11:18:26 <maralorn> I realize now that purity led my astray. I actually thought that would always get passed by value …
11:19:48 <geekosaur> purity in fact means it can pass pointers around, safely :)
11:19:50 <dsal> One effect of purity is that a compiler is free to make optimizations that can't be made when things might be changing.
11:22:41 <maralorn> cool
11:43:13 <tom__> Can anyone recommend an approach to testing queries made with postgres-simple?
11:44:50 * hackage tmp-postgres 1.29.0.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.29.0.0 (JonathanFischoff)
12:03:15 <Pamelloes> Is representing a tree via data Tree a = Node a [Tree a] a reasonable approach? Are there any major performance caveats I should be aware of?
12:05:15 <statusbot> Maintenance update: Hackage restarting for maintainance *now* -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5ded54cbf37e6c04b79fa49b
12:05:24 <dsal> Pamelloes: seems normal
12:05:34 <geekosaur> aside from it can't be empty
12:06:49 <dsal> Empty is just +1  :)
12:07:05 <bifunc2> Within IO monad (do notation):
12:07:05 <bifunc2> if somethingBad
12:07:05 <bifunc2>  then throwString "bad"
12:07:05 <bifunc2>  else do ...
12:07:07 <bifunc2> Can I make this more succinct? Does IO monad allow something similar to guard in Maybe monad (short-circuiting on Nothing)?
12:07:33 <Rembane> :t when 
12:07:35 <lambdabot> Applicative f => Bool -> f () -> f ()
12:07:35 <Rembane> :t unless 
12:07:37 <lambdabot> Applicative f => Bool -> f () -> f ()
12:07:46 <Rembane> bifunc2: Both when and unless are quite good for this use case 
12:07:52 <bifunc2> yes but i really want to throw, not just do  nothing..
12:08:14 <bifunc2> oh wait!
12:08:19 <bifunc2> lol
12:08:41 <bifunc2> when somethingBad (throw "bad")
12:08:43 <bifunc2> right?
12:08:49 <solonarv> yes
12:08:59 <Rembane> Bingo! 
12:09:04 <bifunc2> nice, thank you..
12:09:07 <bifunc2> :)
12:09:16 <solonarv> also, 'guard' *does* work in IO
12:09:25 <solonarv> it throws an exception
12:09:32 <Rembane> :t guard 
12:09:34 <lambdabot> Alternative f => Bool -> f ()
12:09:38 <Rembane> Nice
12:09:40 <solonarv> but the exception of course doesn't have any kind of helpful error message
12:15:14 <dmwit> Pamelloes: Just to double-check: you know Data.Tree has that type already, right?
12:15:35 <dmwit> No more major performance caveats than the ones you already know about for [], I guess.
12:16:08 <Pamelloes> Yep
12:17:04 <Pamelloes> I guess my follow up question is that if I want to make a tree with alternating data types, is there any difference between using one type with a GADT or two, mutually recursive types?
12:18:04 <Pamelloes> i.e Tree a where { BoolLayer :: Bool -> [Tree Int] -> Tree Bool; IntLayer :: Int -> [Tree Bool] -> Tree Int; }
12:19:19 <monochrom> That's in conjunction, not alternating.
12:19:31 <monochrom> Err no, misread.
12:20:01 <monochrom> OK, that works.
12:20:20 * hackage niv 0.2.7 - Easy dependency management for Nix projects  https://hackage.haskell.org/package/niv-0.2.7 (nmattia)
12:24:50 * hackage tmp-postgres 1.29.0.1 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.29.0.1 (JonathanFischoff)
12:27:00 <[Leary]> Pamelloes: Can't you do it with a regular ADT? Something like `data AlTree a b = Node a [AlTree b a]`?
12:27:56 <Pamelloes> Ooh, that seems more elegeant
12:28:04 <Pamelloes> *elegant
12:29:20 <statusbot> Maintenance update: Hackage maintainance completed; there shouldn't be... but if you notice any regressions... please let us know! -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5ded54cbf37e6c04b79fa49b
12:48:20 * hackage record-dot-preprocessor 0.2.2 - Preprocessor to allow record.field syntax  https://hackage.haskell.org/package/record-dot-preprocessor-0.2.2 (NeilMitchell)
13:04:08 <hpc> ooh, that's a neat package
13:05:46 <d34df00d> I have a question about flags and hackage.
13:06:07 <d34df00d> Let's say I have a library that really benefits from the LLVM codegen, so I added the corresponding flag (adding -fllvm to ghc-options) and defaulted it to 'true'.
13:06:21 <d34df00d> Now hackage cannot build my library. Shall I be worried? Should I do something differently?
13:10:05 <d34df00d> That's the build report: https://hackage.haskell.org/package/edit-distance-linear-0.2.0.1/reports/1
13:12:51 <geekosaur> I suspect the right thing to do is a cabal flag which defaults on, but you can turn off somehow for hackage builds
13:13:19 <geekosaur> dunno what conditionals cabal has for llvm version or whatever
13:13:25 * geekosaur has to go
13:13:51 <merijn> Or you know, accept that hackage can't build it, shrug and move on with your live
13:13:57 <hvr> we don't really have a way to specify a dependency on LLVM
13:14:33 <d34df00d> merijn: if that has no other implications than, well, hackage not building it, I'm totally fine with it.
13:14:54 <d34df00d> On a related note, if I want to be a shameless plug and push that to stackage LTS, should I do something with it?
13:15:17 <hvr> d34df00d: well, the problem though is that most users probably won't even an appropriate veriosn of LLVM isntaleld
13:15:37 <d34df00d> hvr: I tried with LLVM from 6 to 9, and all of them seem to work.
13:15:58 <d34df00d> (even the abomination I have locally that's built from their VCS)
13:16:12 * hvr doesn't even have llvm installed =)
13:16:25 <d34df00d> 50% less performance for you then!
13:16:57 <hvr> more like 100% less, cause it doesn't even build =)
13:17:15 <d34df00d> Why, you can --flag edit-distance-linear:-llvm or smth like that.
13:17:19 <hvr> here's a 2nd builder which also doesn't have LLVM installed: https://matrix.hackage.haskell.org/#/package/edit-distance-linear
13:17:46 <d34df00d> merijn: actually I just realized it probably means there will be no documentation there as well.
13:17:48 <hvr> it's more common to have LLVM-support opt-in rather than opt-out
13:18:53 <d34df00d> Yeah... that's probably the right solution, although it means that one will get suboptimal performance if they don't enable the flag in their build.
13:19:10 <d34df00d> Is there a way to specify a dependency on a package with a specific flag value in .cabal/package.yaml?
13:20:26 <f-a> d34df00d: can you write it in the docs?
13:20:49 <f-a> I mean a library user is expected to skim the description, ain't he?
13:21:13 <f-a> I recall having a similar problem with SDL
13:21:20 <hvr> d34df00d: well, otoh, people are easily discouraged if a package doesn't install easily on first attempt
13:21:41 <d34df00d> Alright, I'm convinced I shall default it to off.
13:21:43 <d34df00d> Thank you :]
13:21:46 <f-a> (about documentation) and the answer here was "deal with it"
13:23:03 <Pamelloes> f-a: You don't usually read documentation for transient dependencies, though
13:23:33 <hvr> f-a: I'd point out you can document the purpose of `cabal flags` including markup; see e.g.  http://hackage.haskell.org/package/zlib
13:24:19 <f-a> excellent
13:24:56 <literallyCrevice> I think I missed something really basic, if I define `newtype MyInt = MyInt Int`, how can I then transform a function (Int -> Int) to (MyInt -> MyInt)? My type isn't a functor.
13:25:12 <f-a> yeah Pamelloes , I didn't think about
13:26:28 <hvr> literallyCrevice: a Haskell98 compliant approach is e.g. via https://hackage.haskell.org/package/newtype  -- or if you have `Data.Coerce` you can "coerce" your function
13:27:50 * hackage venzone 1.0.0.2 - ASCII platform-adventure game  https://hackage.haskell.org/package/venzone-1.0.0.2 (fffaaa)
13:27:56 <literallyCrevice> hvr: Damn, that's way more effort / uglier than I imagined. I thought this kind of lifting would be handled by GHC/deriving quite easily.
13:28:00 <Pamelloes> literallyCrevice: You'll probably just want to create a function like `liftIntToMyInt :: (Int -> Int) -> MyInt -> MyInt; liftIntToMyInt f (MyInt i) = MyInt (f i)`
13:28:51 <Pamelloes> What's the standard way to produce Infinity :: Double? Google seems to suggest `1 / 0` or `read "Infinity"`, but both of those seem sketchy to me.
13:29:22 <svipal> they work tho
13:30:00 <merijn> 1/0 is the standard way
13:30:07 <hvr> 1/0 is quite fine IMO
13:30:14 <merijn> Since IEEE-754 requires anything /0 is infinity
13:30:19 <hvr> (also its cousings -1/0 and 0/0)
13:30:20 <merijn> Well, anything positive, anyway
13:30:38 <Pamelloes> 1 /0 it is, then!
13:31:35 <tom__> Is there a way I can convert a list of Rows to a Just if there is one element else Nothing with postgres-simple
13:31:36 <tom__> https://pastebin.com/L097M0Yv
13:32:34 <tom__> I kept getting confused with `Only` turns out it can only be used to specify that you have one field in your row not one row
13:34:40 <dmwit> Just to check: what don't you like about what you did in your paste?
13:35:07 <dmwit> There is an existing function named `listToMaybe` that does what you did; is that enough? Or are you hoping to reduce the DB communication traffic as well?
13:35:29 <dmwit> (...or is there some other concern you'd like to address?)
13:39:31 <tom__> dmwit: I am worried about having to add on the case of for every query that returns a result where I am expecting only one row
13:40:12 <tom__> I guess I could have my own listToMaybe variant and just compose it with all my query functions?
13:40:52 <tom__> Another question. If I want to just unit test my queries do I need to use something like monad-mock and mtl style
13:58:15 <Arranun> So ... someone working on anything interesting ?
13:58:20 * hackage reform-hsp 0.2.7.2 - Add support for using HSP with Reform  https://hackage.haskell.org/package/reform-hsp-0.2.7.2 (JeremyShaw)
13:58:47 <f-a> Arranun: which kind of interesting?
13:59:50 * hackage uuid-orphans 1.4.4 - Orphan instances for the UUID datatype  https://hackage.haskell.org/package/uuid-orphans-1.4.4 (DavidFox)
14:00:42 <Arranun> Kinda a shoot in the dark, I started working with haskell for the Advent of Code challenges this year and I wanted to have a look at stuff that more seasoned people try with haskell
14:02:09 <f-a> Arranun: I mean haskell is a general language, I just released a small game today
14:02:33 <Arranun> Sounds interesting, could I have a look ?
14:02:54 <f-a> sure, one sec
14:03:10 <f-a> http://ariis.it/static/articles/venzone/page.html far from pretty Haskell though
14:04:12 <f-a> I never tried AoC, what does it feel like? Like P. Euler?
14:05:28 <Arranun> Seems easier, and far less concentrated on mathematics.
14:05:29 <amx> less math
14:06:15 <Arranun> But really nice to learn a new language and it has alot of stuff which haskell isn't really suitable for haskell.
14:06:35 <Arranun> But because of that you have to try a lot of stuff outside of the standard library
14:06:54 <f-a> nice, I should try it one of those days
14:07:11 <Arranun> Also with the daily challenge it has alot of community support
14:07:59 <Arranun> If you want to try it at any point there are alot of private leaderboard
14:09:54 <amx> or just collect stars and ignore points
14:16:28 <sm[m]> f-a: what were the biggest challenges in making venzone (packaging aside) ?
14:17:01 <lavalike> f-a: it's the furthest you could think from project euler, it's actually fun (;
14:17:39 <f-a> haha lavalike 
14:18:10 <svipal> Arranun, what do you think is not suitable for haskell
14:19:05 <f-a> sm[m]: I always rush to writing code instead of doodling with ideas on paper, which is wrong when using Haskell (well when doing aything). Most of the pain-points I had were gone when I starte using microlens. All in all a very pleasant experience!
14:19:59 <cheater> is there a concise way to express [x, x+d, x+2d, ...] up to and including m?
14:20:27 <[exa]> cheater: [x,x+d..m] should kindof work
14:20:37 <[exa]> (not sure about the inclusion though)
14:20:53 <Axman6> > [3,5..20]
14:20:57 <lambdabot>  [3,5,7,9,11,13,15,17,19]
14:21:05 * [exa] sadfaces
14:21:19 <Axman6> > [3,5..20]++[20]
14:21:22 <lambdabot>  [3,5,7,9,11,13,15,17,19,20]
14:22:14 <f-a> sm[m]: and of course the choice of "database" (i.e. sum type vs. other possibilities); I wished I talked to you an EvanR earlier 
14:22:47 <svipal> f-a it' s not always wrong but definitely with haskell hahaha
14:22:50 * hackage Network-NineP 0.4.6 - High-level abstraction over 9P protocol  https://hackage.haskell.org/package/Network-NineP-0.4.6 (SergeyAlirzaev)
14:23:13 <lavalike> :t enumFromThenTo
14:23:15 <lambdabot> Enum a => a -> a -> a -> [a]
14:23:53 <koz_> How do I get cabal to compile C files that I need for my Haskell executable?
14:24:08 <f-a> svipal: I admire/envy people who can visualise stuff on paper. Choosing the appropriate types/topmost functions etc. Filling in the code should be a breeze then
14:25:36 <merijn> koz_: You have to list them as c-files
14:26:00 <koz_> merijn: In the executable stanza?
14:26:02 <merijn> koz_: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/benchmark-analysis.cabal#L123-L126
14:26:07 <koz_> Ah, thanks.
14:26:15 <merijn> koz_: In the "whatever they should be linked with" stanza
14:26:44 <koz_> OK, thanks - that example is _excellent_.
14:27:01 <koz_> First I have to update hlint and listen to my work computer doing its best aircraft engine impression.
14:34:50 * hackage aeson-filthy 0.1.4 - Several newtypes and combinators for dealing with less-than-cleanly JSON input.  https://hackage.haskell.org/package/aeson-filthy-0.1.4 (AlecHeller)
14:43:20 * hackage syb-with-class 0.6.1.12 - Scrap Your Boilerplate With Class  https://hackage.haskell.org/package/syb-with-class-0.6.1.12 (JeremyShaw)
14:45:20 * hackage edit-distance-linear 0.2.0.2 - Efficient implementation of the Levenshtein edit distance in linear memory.  https://hackage.haskell.org/package/edit-distance-linear-0.2.0.2 (0xd34df00d)
14:52:28 <sm[m]> f-a: that’s good to hear, and impressive; I’d have expected a bit more pain since you weren’t even using an existing game engine
14:53:05 <f-a> oh well, there is "having people break stuff on windows", but that was expected :P
14:53:15 <sm[m]> I shall take another look at venzone code
14:53:42 <sm[m]> Have you heard from people playing on all three platforms ?
14:54:02 <f-a> yes, I have testers on all three platforms
14:55:54 <f-a> cabal new-test runs 83 tests too, which gives me some peace of mind
14:57:28 <sm[m]> Awesome.. cross platform haskell games ++
14:57:41 <f-a> I would like to try Entity Component System approach next, seems promising
14:58:39 <f-a> sm[m]: of course another viable way is to use, e.g. threepenny GUI
14:59:04 <sm[m]> So now.. what is an Orcolat ? I feel like there might be some background I’m missing
14:59:31 <sm[m]> Does it carry a pole axe ?
14:59:59 <sm[m]> And what is a pole axe, really
15:00:11 <f-a> yup, and hits the montains when he's angry, causing a series of earthquakes
15:00:48 <f-a> or that's the legend, frequent earthquakes are real though
15:01:06 <EvanR> diablo would have us believe a pole axe is just a really large melee weapon you swing at stuff
15:01:20 <EvanR> i'm skeptical
15:02:47 <f-a> https://en.wikipedia.org/wiki/File:Alytus_County_COA.png sm[m] 
15:03:11 <f-a> does that look similar to Diablo's , EvanR 
15:03:20 <EvanR> ok that's much smaller than diablo
15:03:27 <EvanR> more realistic looking
15:04:30 <f-a> 1 line OT, if you liked Diablo, make sure to try FlareRGP, open source game, imho one of the best open source productions after Wesnoth
15:04:51 * hackage streamly-fsnotify 1.0.0.1 - Folder watching as a Streamly stream.  https://hackage.haskell.org/package/streamly-fsnotify-1.0.0.1 (koz_ross)
15:08:03 <sm[m]> Bookmarked
15:09:21 <f-a> also cloc'ing it is 2.4k LOC, which is pretty cosy considerig there is a parser and you can edit levels too
15:10:28 <koz_> :t (=<<)
15:10:31 <lambdabot> Monad m => (a -> m b) -> m a -> m b
15:10:51 <f-a> koz_: >>= if you are left handed :P
15:13:05 <koz_> I can never remember which way around which argument goes.
15:14:52 <monochrom> Maybe >>= points in the direction of data flow.
15:15:48 <koz_> monochrom: That's a good one - I will try to remember it.
15:15:57 <koz_> It's one of those obnoxious things I can't quite get into my brain.
15:16:04 <koz_> (probably because I write bind so infrequently)
15:16:47 <f-a> scrap using do notation for a while
15:17:35 <aplainze1akind> Is there something inherently strict about parsing into a Map or am I doing something wrong?
15:17:50 <koz_> aplainze1akind: What do you mean by 'inherently strict' and 'parsing'?
15:17:50 <c_wraith> are you importing Data.Map?
15:18:16 <dmwit> aplainze1akind: Most parsers are strict, because they must do all the parsing to know whether there is an error or not, and that's the top-level constructor.
15:18:33 <dmwit> aplainze1akind: But have a look at uuparsinglib if it's really important to you to get errors "online", so to speak.
15:18:50 <dmwit> Sorry, uu-parsinglib
15:18:54 <aplainze1akind> I have a 100MB challenge input for AoC day 6, I have a Parser Map String [String], and it just chokes.
15:19:22 <aplainze1akind> Parser (Map String [String]) that is.
15:19:26 <dmwit> String is a really, really bad representation for memory consumption.
15:19:37 <c_wraith> 100MB is tiny, though
15:19:43 <c_wraith> it really should be irrelevant
15:20:12 <aplainze1akind> I'm using Megaparsec btw.
15:20:35 <dmwit> 100 million Chars * 4 words per Char * 8 bytes per word is 3GB
15:20:44 <c_wraith> 3GB is tiny, yes
15:20:52 <dmwit> So... could be relevant, depending on what machine they have.
15:21:04 * f-a has 4gb ram
15:21:09 <dmwit> ^
15:21:29 <aplainze1akind> I have 8.
15:22:41 <merijn> Still, I'd definitely go with Text as soon as your input is more than, like, 5 lines. Just because it's almost no extra complexity and scales much better with input sizes
15:23:34 <aplainze1akind> Let me see what difference it makes.
15:24:06 <merijn> aplainze1akind: Text (for western/ascii text) ~2 bytes per character, String ~24 bytes per character ;)
15:28:33 <jle`> yeah if you're at the level that you want to use parser combinators, might as well just use Text ...
15:28:55 <jle`> idk the only reason String is ever useful is because of the unconsing/being able to use map and stuff
15:29:08 <jle`> so you could use String for easy simple parsing using pattern matching
15:29:19 <jle`> but if you're using parser combinators then there's pretty much no reason to use String i think
15:29:36 <ammar2> jle`: "unconsing"?
15:29:42 <jle`> ammar2: pattern matching on the first item
15:29:55 <jle`> simpleParser (x:xs) = ...
15:30:08 <ammar2> gotcha
15:30:13 <merijn> ammar2: The list constructor is often called "cons", so uncons is the opposite
15:30:16 <jle`> that's pretty much the only 'benefit' of using String over text ... making that thing syntactically clean
15:30:19 <f-a> aplainze1akind: which problem is it?
15:30:30 <jle`> but if you're not going to use that then might as well use Text, heh
15:30:50 <jle`> and even these days you can make a syntactically clean uncons in Text using pattern synonyms
15:30:57 <aplainze1akind> f-a: The orbit thing.
15:31:44 <aplainze1akind> Switched to Text, still choked (starting from 50% memory use, so roughly 4 gigs).
15:32:13 <jle`> it doesn't sound like strictness or laziness is your problem i think
15:32:30 <jle`> unless you're doing something very weird :)
15:32:48 <jle`> what does your parser look like?
15:33:20 <aplainze1akind> https://gist.github.com/aplainzetakind/c117568cb257d17b1e7d93fa3aaa9bb4
15:34:13 <aplainze1akind> Using this in: combineWith (\(p, o) -> M.insertWith (++) p [o]) orbit
15:34:33 <aplainze1akind> Where orbit parses the input into pairs.
15:34:42 <aplainze1akind> (Text, Text)
16:04:21 * hackage ixset 1.1.1.1 - Efficient relational queries on Haskell sets.  https://hackage.haskell.org/package/ixset-1.1.1.1 (JeremyShaw)
16:13:27 <iqubic> Is there a way to use parallelism in GHCi?
16:16:51 <koz_> iqubic: What are you trying to do?
16:19:15 <iqubic> I'm trying to see if I can speed up some of my AoC solutions by adding parallelism.
16:20:54 <koz_> There's several different things 'parallelism' can mean, and there's different Haskell stuff for that. Inhowfar any of them work in GHCi depends on which one you're after.
16:22:36 <iqubic> I'd like to use rpar and rseq in my code, and then run it in GHCi.
16:23:12 <koz_> Why not just make a small Cabal project?
16:23:27 <iqubic> I have a Cabal project.
16:23:40 <koz_> Why not cabal new-exec?
16:23:47 <iqubic> What does that do?
16:23:49 <koz_> (since I'm guessing you have an executable?
16:23:51 <koz_> )
16:23:58 <iqubic> I don't have an executable.
16:24:13 <iqubic> I should really make an executable.
16:24:36 <koz_> If I'm not much mistaken, you need to compile rpar-and-rseq-using code with a bunch of GHC options which enable parallelism which _only_ makes sense for executables.
16:24:42 <koz_> s/makes/make/
16:25:07 <iqubic> Ah.
16:25:10 <iqubic> I see.
16:25:16 <ephemient> I think GHCi is using threaded RTS now so in theory it could work
16:25:26 <ephemient> but it probably only has one capability (e.g. single thread)
16:25:44 <koz_> I really don't think 'performance' is a major concern for GHCi. :P
16:25:48 <iqubic> No.
16:25:55 <ChaiTRex> Can GHCi be run with RTS options?
16:26:19 <iqubic> I've decided to just make a Main module where I can run my code.
16:26:39 <ChaiTRex> Ahh, OK.
16:27:01 <iqubic> Now, on a different topic, does Criterion require any special GHC flags to be set?
16:28:00 <ephemient> if you want threads you do want -threaded
16:28:40 <ephemient> and +RTS -N at runtime, or see the documentation for how to set default rts opts
16:28:44 <iqubic> I don't need threads.
16:29:13 <iqubic> I've decided that I'm not going to be adding parallelism to my code.
16:29:26 <ChaiTRex> How can I finish writing (>>=) at https://gist.github.com/ChaiTRex/edc5d6a689f2c125fb67376a0a319f05? It seems like to know what data constructor to use, I need to already have the Machine to pass to execState or whatever, but I only have that at runtime.
16:29:51 <iqubic> But should I enable these flags for testing my code with criterion?
16:30:23 <koz_> ChaiTRex: Why does Error have the (Machine -> Machine)?
16:30:35 <koz_> Wouldn't it just be 'Error String'?
16:30:52 <ChaiTRex> koz_: For debugging purposes (see the machine state when it errored).
16:31:05 <koz_> Also, for Halted, wouldn't it make more sense to have 'Halted Machine'?
16:31:17 <koz_> Same for Error - Error String Machine.
16:31:25 <ChaiTRex> koz_: I don't think I can get a Machine before passing that through execState.
16:31:26 <koz_> Since you want a snapshot of the final/erroring state.
16:31:39 <koz_> Let me give it a whirl one sec.
16:31:54 <koz_> I need a break from the UI hell I'm in. :P
16:38:07 <koz_> ChaiTRex: What's the desired result if I do m1 <*> m2 where m1 is Halted?
16:38:17 <koz_> Should it just give a halted result?
16:38:38 <koz_> Or indeed, what kind of result can it give?
16:38:38 <ChaiTRex> koz_: Yeah, I think so.
16:39:08 <ChaiTRex> It's sort of like Nothing or Left.
16:41:02 <koz_> OK, thanks.
16:45:56 <koz_> ChaiTRex: Yeah, I can see your predicament lol.
16:46:34 * koz_ is gonna try this using join instead.
16:46:49 <iqubic> Will join be easier?
16:47:11 <koz_> iqubic: It can be sometimes.
16:50:06 <koz_> ChaiTRex: Is it essential that MachineState be a Monad specifically?
16:50:12 <koz_> Will Applicative suffice for your purposes?
16:50:27 <ChaiTRex> koz_: No, as long as it stops wasting time when a machine stops.
16:50:40 <ChaiTRex> koz_: Monads are nice for do notation, though.
16:50:51 <koz_> ChaiTRex: https://gist.github.com/kozross/39c77da26dbd6d6b6a428044352e5c96
16:51:08 <koz_> I think you will find this wastes fairly little time. :P
16:51:13 <ephemient> {-# LANGUAGE ApplicativeDo #-} is a thing
16:51:37 <koz_> It is!
16:52:39 <ChaiTRex> koz_: Thanks, I'll take a look :)
16:52:46 <ChaiTRex> ephemient: Thanks, I'll look at that.
16:53:09 <koz_> Also, is Memory like an infinite array or something?
16:53:21 * hackage emojis 0.1 - Conversion between emoji characters and their names.  https://hackage.haskell.org/package/emojis-0.1 (JohnMacFarlane)
16:54:28 <ChaiTRex> koz_: It's supposed to be pretty big (Int addressed, so not infinite)
16:54:44 <koz_> I mean it more in a usage sense - like, you need arbitrary size _and_ random-access?
16:54:52 <ChaiTRex> koz_: Yeah.
16:55:13 <koz_> ChaiTRex: OK, and the other components of Machine are meant to be what?
16:56:05 <ChaiTRex> koz_: The [Integer]s are input and output as lazy lists.
16:56:22 <ChaiTRex> koz_: The Int is the instruction pointer.
16:56:29 <koz_> An.
16:56:32 <koz_> ah*
16:59:50 <koz_> Wait is this AoC Day 2?
17:01:18 <average-user> koz_: why?
17:01:37 <iqubic> koz_: And day 7 too. But yes. That's what it looks like.
17:01:37 <koz_> average-user: Looked kinda similar. Upon further inspection, I was mistaken.
17:02:02 <iqubic> It's Day 2 and 5.
17:02:08 <average-user> iqubic: ohh yeah, and don't forget day 5
17:02:10 <iqubic> That's what it looks like.
17:02:16 <iqubic> Day 5 was hell.
17:02:39 <average-user> I wander how many opcode-related problems will be this year
17:02:59 <iqubic> I used an existential type trick to allow my code to work with variadic opcodes.
17:03:42 <average-user> I'm doing it in Clojure so no types for me
17:04:50 <koz_> Woo, day 2 is self-modifying code.
17:05:05 <koz_> I might just hack together something right now for it.
17:05:19 <iqubic> koz_: It only gets harder on Day 7.
17:05:28 <glguy> koz_: Does it self-modify an instruction that it later executes?
17:05:40 <iqubic> glguy: It might.
17:05:44 <iqubic> It might do that.
17:06:03 <glguy> iqubic: Yes, that's the question
17:06:18 <iqubic> koz_: Once you have a solution to day 2 part 1, then you can go on and do day 5, parts 1 and 2.
17:06:22 <iqubic> It's harder.
17:06:36 <iqubic> Day 5 will break some of your assumptions.
17:06:49 <average-user> but not that much
17:07:15 <glguy> based on the previous years 5 and 7 matched my expectations
17:07:40 <iqubic> Really?
17:07:48 <average-user> I really liked how some of you solved day7 with lazyness, I was wondering how could I do that in Clojure
17:08:11 <average-user> I didn't worked out nothing though
17:08:21 <glguy> iqubic: Yeah, it was basically the same pattern, even the same additions and extra challenge
17:09:06 <iqubic> Ah. I see.
17:09:39 <average-user> I have to admit I do not like problems like day 2,5,7
17:10:03 <iqubic> I loved them.
17:10:06 <iqubic> So cool.
17:11:43 <average-user> Did anyone watch the talk that aoc's creator gave?
17:13:23 <glguy> average-user: how come?
17:13:37 <average-user> https://www.youtube.com/watch?v=bS9882S0ZHs
17:16:43 <glguy> I watched it
17:22:21 <qualiaqq> Does anyone know how one would go about getting the latest index-state timestamp that hackage has available?
17:35:50 <qualiaqq> Actually, nevermind. `cabal new-update` seems to output it.
17:45:53 <f-a> Ok, I solved a multipart AoC problem. Is there a place where Haskell solutions are discussed?
17:46:41 <glguy> Here, or ##adventofcode-spoilers work
17:47:43 <jle`> f-a: if you're looking at haskell in specific we also discuss it on the FP slack
17:47:57 <f-a> thanks you both
17:50:35 <ChaiTRex> koz_: Yes, I have an ugly solution to days 2, 5, and 7 (https://github.com/ChaiTRex/advent-of-code-2019), but now I'm trying to improve it to something nice and I need to learn more to figure out how to implement it with some ergonomics. I'm thinking that a state-either hybrid is impossible, in which case I'll try to understand why and then implement it in applicative or arrow or something.
17:51:53 <ChaiTRex> Or I'll learn that it's possible and figure out how to implement it.
17:52:01 <ChaiTRex> Either way, I learn something :)
17:54:00 <asthasr> Hi guys. Question: i have enabled OverloadedLists and am using vectors. I am trying to use pattern matching (x:xs) -- but I get errors. Do OverloadedLists not handle that syntax?
17:54:26 <asthasr> similarly "element : vector" is not working.
17:54:44 <jle`> asthasr: it doesn't, no
17:54:46 <asthasr> Do I need to enable another extension? Or is there something I"m missing?
17:54:51 <asthasr> ah, I see.
17:55:07 <jle`> asthasr: it only kicks in for parsing of literals, [ ... ] syntax
17:55:20 * hackage tmp-postgres 1.30.0.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.30.0.0 (JonathanFischoff)
17:55:20 <jle`> it should really be OverloadedListLiterals
17:58:20 <ephemient> if vector provided pattern synonyms then you could use them in pattern matching
17:58:38 <jle`> yeah, you can use them in pattern matching. but it just would be different from (x:xs)
17:58:54 <jle`> it would be (x :& xs) or something, however vector defines its pattern
17:59:18 <d34df00d> What should I do if some package that hasn't been updated since 2014 doesn't build with ghc 8.8, complaining about lacking MonadFail instance for ((->) String)? I mean, can I expect the fix to reach hackage reasonably quickly (if I volunteer to do the fix but assuming unresponsive maintainer), or I better off migrating to some other package?
17:59:44 <jle`> d34df00d: it depends on the package
17:59:50 <d34df00d> http://hackage.haskell.org/package/command-qq-0.3.0.0
17:59:55 <d34df00d> jle`: ^
18:00:00 <jle`> if you're building an application, then you can use your own fork of it with the fix
18:00:25 <jle`> d34df00d: i meant to say, it depends on the package maintainer ;)
18:00:41 <d34df00d> I heard hackage has revisions or something. Can I use them for this sort of stuff?
18:01:11 <jle`> d34df00d: no, revisions are for package maintainers to change the metadata (like cabal file fields)
18:01:18 <d34df00d> Got it.
18:01:35 <jle`> package maintainers can accept PR's and submit to hackage instantly
18:01:41 <d34df00d> Yeah, I'll need to make a fork anyway to fix the package, so why not point my stack to it.
18:01:44 <jle`> or they can be busy and take weeks or years
18:02:06 <d34df00d> Is there any procedure for pushing fixes in case of unresponsive maintainers?
18:02:27 <jle`> you won't be able to push it to hackage unless the maintainer hands over the rights
18:02:31 <jle`> or grants permission
18:02:50 <jle`> if you're writing an application, it doesn't matter too much because you can just build against your own fork
18:03:00 <jle`> if you are writing a library then things get a little more messy potentially
18:03:35 <Athas> d34df00d: there are procedures for taking over maintenance.
18:04:07 <d34df00d> jle`: in any event, I can live with the fork for now.
18:04:17 <d34df00d> I just don't want to accrue the technical debt of depending on unmaintained libraries.
18:04:53 <jle`> such is the nature of OSS :'(
18:04:56 * d34df00d also takes this as a chance to learn about hackage infrastructure and social interactions.
18:05:06 <jle`> d34df00d: i would submit a PR anyway
18:05:10 <d34df00d> Sure.
18:05:13 <d34df00d> Won't hurt.
18:05:31 <d34df00d> And given the existence of the procedure Athas mentioned, it might not necessarily be in vain.
18:05:31 <jle`> who knows, they might log on and push to hackage before suppertime
18:05:59 <jle`> well, Athas's procedure is to transfer maintanence. so it's not quite advisable unless you are willing to become the new maintainer
18:06:12 <jle`> but, maybe that's you :)
18:06:20 <d34df00d> Why not :]
18:06:30 <jle`> :]
18:31:51 <lancap> Why does haskell use these weird data constructors instead of the structs I'm used to? What are the differences?
18:32:27 <lancap> I'm kind of having trouble understanding why I cant just do User.name, and have to do this weird pattern matching thing instead
18:33:05 <ChaiTRex> lancap: You can use records syntax to get a function to get the name (or write it manually: name (User _ n _ _) = n)
18:33:26 <ChaiTRex> lancap: That'll allow you to easily access that field.
18:33:49 <ChaiTRex> lancap: There's also lenses for more advanced stuff, but I've never used them personally, so I can't provide much guidance.
18:33:51 <c_wraith> why would you want to learn a language that's just like the ones you already know?
18:34:33 <lancap> But then I have to remember what order the fields are in and how many there are. There's no easier way to get a field by name?
18:35:20 <lancap> I can't tag the String `name` and reference it by that tag, so I know what it is?
18:35:21 <ChaiTRex> lancap: You don't. name (User _ n _ _) = n produces a function name that takes a User and produces a name. You use it like name u to get the name of User u.
18:35:44 <ChaiTRex> lancap: It's like u.name, only it's written name u.
18:36:08 <lancap> Ah. So "records syntax" provides me with the `property parent` functions
18:36:13 <jle`> lancap: if your record has a name, you can do `name u`
18:36:19 <jle`> record field
18:36:22 <lancap> That makes sense. Thanks!
18:36:30 <jle`> @let data User = User { name :: String }
18:36:32 <lambdabot>  Defined.
18:36:40 <jle`> > name (User "luigi")
18:36:45 <lambdabot>  "luigi"
18:37:12 <jle`> lancap: but it might be worth mentioning that (User "luigi").name syntax is also coming potentially soon
18:37:21 <ephemient> https://gitlab.haskell.org/ghc/ghc/wikis/records/declared-overloaded-record-fields/dot-postfix
18:37:29 <c_wraith> "soon" being at least a year out...
18:38:18 <jle`> i suppose by 'soon' i mean "there is somewhat of a consensus that it's a good idea and we're moving towards it"
18:38:22 <jle`> fsov consensus
18:39:33 <ephemient> looking at that proposal ^ I wouldn't call it consensus, but... it's not stalled
18:40:21 <c_wraith> I have a pretty serious semantics problem with that proposal.  I feel like the issue about the desugaring details wasn't ever really addressed.  "hand it off to the committee" doesn't make me feel any better.
18:41:28 <lancap> I just had a thought. Records syntax sounds like it collides names a lot
18:41:39 <c_wraith> it does.  
18:41:50 <lancap> If I have two datatypes with a name string subfield, does it still work?
18:42:19 <c_wraith> not really.
18:42:36 <ephemient> with {-# LANGUAGE DuplicateRecordFields #-} it can work, for some values of work
18:42:49 <jle`> lancap: yeah, it's somewhat of a wart that's been around in haskell for a while. these days if you plan on using record fields for acessing it's common to give them a prefix for the type they are for
18:42:57 <jle`> lancap: data User = User { userName :: String, userAge :: Int }
18:43:20 <lancap> Oof, that seems pretty bad
18:43:25 <c_wraith> these days I'll just use OverloadedLabels along with generic-lens.  It's a bit ugly syntactically, but everything works.
18:43:28 <jle`> but you can forego this if you don't plan on using the accessors directly and instead use some of the alternative accessing tools
18:43:44 <jle`> like there are some libraries that allow you to write
18:43:49 <jle`> get #name :: User -> String
18:43:56 <jle`> get #age :: User -> Int
18:44:08 <jle`> assuming you have User { name :: String, age :: Int }
18:44:19 <jle`> still nothing built-in to the language though
18:44:54 <jle`> it's kind of interesting that haskell compiler feature implementation tends to fast track low-level features that enable us to write usability-focused abstractions like this
18:45:06 <jle`> instead of the actual front-facing features
18:45:16 <jle`> s/haskell compiler/ghc
18:45:48 <lancap> Yeah, I don't even understand yet how writing a library like that is possible
18:46:22 <jle`> i suppose it's a testament to how powerful haskell's generic programming and reflection features are
18:46:32 <jle`> that you can implement it 'within the language' instead of via patching the compiler
18:46:46 <lancap> That is pretty nice
18:46:55 <c_wraith> the craziest thing is all the work csonger put into generic-lens to make it compile down to identical core as doing things by hand.
18:47:54 <jle`> but the problem with having it as a library instaed of having it as a language feature is things like the paralysis of choice, assembly-required issues
18:48:06 <c_wraith> and the general fear of lens. :)
18:50:16 <lancap> sounds a lot like the problem scheme has
18:50:53 <f-a> *feature
18:50:58 * f-a smiles
19:10:09 <leifm> https://gist.github.com/leifmetcalf/6f18b115fbf498b7b1ad6d50d3c47354
19:10:31 <leifm> Why does `f $ Just 1 : Nothing` not terminate?
19:11:15 <shachaf> Are you sure it type-checks?
19:11:48 <leifm> whoops, that should be `repeat Nothing`
19:12:03 <leifm> I've updated the gist
19:12:33 <shachaf> > let f :: [Maybe a] -> [a]; f (Just x : xs) = x : f xs; f _ = [] in f $ Just 1 : repeat Nothing
19:12:36 <lambdabot>  [1]
19:13:14 <leifm> uh...
19:15:48 <leifm> oh I'm very silly, I wrote `f'` instead of `f` in the body of the definition
19:23:35 <blackbart> I have several modules: Site.A, Site.B, implementing the same functions: url, title. In my main program I would like to operate on each of those functions mapped over each Site module. I know this type of thing is a strength of Haskell, but I'm having trouble putting together the right search terms to figure out how to implement this.
19:27:12 <jusss> is there a point to implement callCC in languages that don't support TCO?
19:33:39 <koz_> jusss: Are you referring to call-cc for delimited continuations or undelimited ones?
19:33:46 <koz_> Also, those two things seem really damned orthogonal.
19:34:06 <jusss> koz_: full continuation, not the delimited continuation
19:34:32 <koz_> jusss: I am not aware of any languages which have undelimited first-class continuations _without_ having TCO.
19:35:34 <jusss> koz_: it's sad that most languages don't support TCO
19:36:21 <jusss> Scheme Haskell do, Python Java Javascript don't
19:37:42 <jusss> is that too hard to implement?
19:38:09 <koz_> jusss: It's not hard to implement. In the case of Python specifically, it was _deliberately_ not done.
19:38:26 <c_wraith> Guido had some funny ideas about functional programming.
19:38:49 <koz_> Java is a performance crapshoot anyway, so I'm not even sure if the OpenJDK's JVM does TCO, or even if it did, whether it would matter any.
19:39:06 <koz_> JavaScript is so hellish I'm surprised anyone implements a compliant anything for it.
19:39:19 <koz_> c_wraith: Yeah... 
19:40:16 <jusss> but they're so poplular now...
19:40:35 <koz_> jusss: Popularity and quality are not equivalent.
19:43:01 <jusss> koz_: when we should use Cont Moand?
19:43:21 <koz_> jusss: Given the context, I feel I should mention that Cont represents _delimited_ continuations.
19:43:44 <koz_> I think an easy example of when Cont is useful is JavaScript style 'pyramid of doom' callback chains.
19:43:47 <monochrom> popularity and quality are reciprocal >:)
19:43:53 <koz_> monochrom: :P
19:44:48 <monochrom> Cont is delimited or full, depending on which side you're on.
19:44:58 <jusss> koz_: to implement delimited continuations, TCO is not required?
19:45:05 <koz_> jusss: Orthogonal concepts.
19:45:21 <koz_> I'm not sure why you see them as related.
19:45:39 <monochrom> If you keep jumping inside and out, it is delimited.  If you stay inside, it's full, insofar as inside.
19:45:49 <jusss> koz_: they have the same name in it...
19:45:59 <koz_> jusss: Wat.
19:46:04 <koz_> TCO = tail call optimization
19:46:13 <koz_> I don't see the word 'continuation' anywhere there.
19:46:31 <jusss> koz_: I mean `full continuation' and `delimited continuation' have the same 'continuation'
19:46:45 <monochrom> Generally, if you stay inside MonadCont polymorphically, you only have the callCC method, so you have full inside.
19:46:57 <koz_> jusss: Yes, but you earlier asked about TCO + continuations, delimited or otherwise. That is what I was referring to.
19:47:08 <jusss> and 'full continuation' need TCO, so I wonder if 'delimited continuation' need TCO or not
19:47:25 <koz_> jusss: Why do you believe undelimited continuations need TCO?
19:47:34 <monochrom> Why does full continuation need TCO?  Who made that up?
19:47:37 <jusss> koz_: I don't, so I asked
19:47:53 <koz_> jusss: And nobody said that thing you are claiming anywhere.
19:48:11 <koz_> My response was that I'm not aware of any TCO-lacking language with support for first-class undelimited continuations.
19:48:19 <koz_> There is no law of the universe stating this to be impossible as far as I know.
19:48:37 <koz_> Much as the fact that I haven't ever seen smoked salmon flavoured ice cream doesn't mean that you can't make such a thing.
19:49:07 <monochrom> Hey I would want that!
19:49:21 <jusss> monochrom: no one, languages don't support TCO, then do CPS is pointless, and full continuation?
19:49:28 <koz_> monochrom: You'd be the first person I've seen who's keen on the idea of smoked salmon flavoured ice cream.
19:49:45 <jusss> no one say full continuation need TCO
19:49:48 <monochrom> Let's muddle the water by bringing up that C doesn't require TCO but does require setjmp-longjmp which gets close to full continuation.
19:50:41 <jusss> yeah, you're right
19:50:50 <shachaf> setjmp isn't full continuations, it's one-shot continuations only up the stack.
19:50:56 <jusss> we can do full continuation in python even js, 
19:50:58 <lancap_> why does haskell like linked lists so much
19:51:21 <koz_> lancap_: Hysterial raisins mainly.
19:51:31 <koz_> They were all the rage in the functional programming community back in the 80s.
19:51:33 <monochrom> CPS is not required for first-class continuation.
19:51:55 <shachaf> C compilers use something similar to CPS anyway to compile C code.
19:52:01 <monochrom> In fact CPS is done by hand when you don't have first-class continuation and you want to fake it, e.g., Cont.
19:52:29 <shachaf> Oh, sometimes people say "CPS" to mean the code humans write, and sometimes to mean the code compilers generae.
19:52:54 <monochrom> If you use call-with-current-continuation in Scheme you don't CPS your code and you don't know and don't care how the Scheme compiler does it for you.
19:53:16 <jusss> that's right
19:53:47 <monochrom> Unless you're stretching it broadly and say "broadly speaking if you have a call stack then you are CPSing".
19:53:53 <mycroftiv> lancap_: i think theres a deep reason, lists are the prototypical inductive data structure and the functional approach naturally fits with inductive structures you can map functions across
19:56:58 <monochrom> I need to write a paper called "gosub: the ultimate lambda" to troll Guy Steele >:)
19:57:40 <jusss> monochrom: what Guy Steele is working on?
19:57:58 <monochrom> Look for "lambda: the ultimate goto"
19:58:42 <jusss> oh, just use C's goto would be fine?
19:58:59 <jusss> why bother
19:59:26 <monochrom> Hint: If you haven't spent a week reading that paper, you have no idea what I'm referring to.
19:59:43 <monochrom> Hint: Corollary, you're making it up.
20:00:54 <jusss> I'm not good educated, paper isn't for me
20:01:30 <monochrom> It is OK if you don't know what I'm referring to, or aren't interested, etc.
20:01:45 <monochrom> You just need to stop making things up as if you knew.
20:03:20 <jusss> ok, I should stop, but I am interested about lambda 
20:25:24 <pounce> heck, wish i knew how to use the state monad
20:25:41 <Clint> just click your heels together three times
20:30:39 <pounce> ;-;
20:31:24 <maerwald> I've never used the state monad xD
20:31:29 <maerwald> I mean, in a real codebase
20:31:39 <maerwald> one of those things that are only theoretically useful
20:33:22 <pounce> hum
20:33:28 <pounce> is it just too clunky
20:33:36 <pounce> maybe i'll just pass around the values instead
20:34:59 <EvanR> state can be used hyperlocally to do a task that requires just a state and some pure computation
20:35:04 <EvanR> State that is
20:35:49 <jle`> the main reason to use State is to hijack monad-polymorphic abstractions
20:36:00 <jle`> if you aren't using any then it isn't suuuper useful i think
20:36:11 <pounce> hum
20:36:16 <pounce> but what if i think it's pretty
20:36:48 <jle`> yeah, some cases it can increase readability :)
20:38:00 <EvanR> hijack monad-polymorphic abstractions... wut
20:38:22 <jle`> like replicateM
20:38:33 <jle`> traverse
20:38:52 <jle`> do notation
20:38:57 <jle`> monad transformers
20:39:06 <jle`> mapM_
20:39:22 <pounce> ye i kinda want that too
20:39:54 <pounce> how do i create a state monad tho
20:40:01 <[Leary]> > let action = do x <- get; put (f x); return (g x) in runState action (x :: Expr) :: (Expr, Expr)
20:40:04 <lambdabot>  (g x,f x)
20:40:13 <[Leary]> There's not much more to it than get and put.
20:40:16 <jle`> State (not 'state monad') has two primitives you can use
20:40:24 <jle`> get :: (State s) s
20:40:27 <jle`> put :: s -> (State s) ()
20:40:37 <jle`> and from there you just sequence it actions
20:40:58 <pounce> hmm
20:41:59 <pounce> too much work i think my gf beat me writing this in ruby
20:42:07 <jle`> > runState (traverse_ put [1..10]) 0
20:42:10 <lambdabot>  ((),10)
20:42:23 <jle`> put 1, then put 2, etc., overwriting the state and then put 10 last
20:42:53 <pounce> :t traverse_
20:42:55 <lambdabot> (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
20:43:07 <jle`> here traverse :: (a -> State s b) -> [a] -> State s ()
20:43:20 <jle`> it sequences an action over every item in a container
20:43:21 <pounce> makes sense
20:47:49 <jle`> for me it's easiest to think of `State s` as an abstract data type, with actions you can sequence using *>/>>=/etc.
21:15:15 <iqubic> How does the ixed instance for Data.Seq work if I try to get or set a value that that is out of bounds?
21:16:26 <iqubic> Like if I have a sequence of length 10 and I try to do (ix 100)?
21:17:37 <shachaf> I wonder whether it's possible to find out?
21:17:46 <shachaf> I think it's one of those undecidable things unfortunately.
21:29:23 <koz_> shachaf: You mean bounds checking?
21:47:53 <lancap_> Can I buffer overflow a haskell program?
21:50:28 <sshine> lancap_, yes
21:57:33 <iqubic> I want to have this inside a do block:
21:57:46 <iqubic> let x = case y of
21:57:55 <iqubic> Nothing -> 0
21:58:02 <iqubic> Just n -> n
21:58:08 <iqubic> But haskell isn't liking it.
21:59:14 <[Leary]> You probably need to indent the cases deeper.
21:59:31 <lavalike> definitely
21:59:43 <iqubic> The hell is this error: http://dpaste.com/2NT8XPK???
22:02:17 <olligobber> I found my new favorite combinator, P=(\xy.xx)(\xy.xx)
22:02:44 <iqubic> I now have a quadruple nested do block.
22:05:17 <koz_> iqubic: https://i.imgflip.com/3iuzju.jpg
22:06:00 <monochrom> What is "factoring option"?
22:06:17 <koz_> As in, factor out some of those nested do-blocks into their own functions.
22:06:30 <monochrom> Oh, that.
22:06:41 <koz_> 'You could factor those do-blocks into their own functions' would have been a bit long.
22:07:53 <monochrom> I thought "factoring option" was a Matrix thing.
22:08:05 <koz_> monochrom: No, I was just trying to be funny with that meme.
22:08:10 <koz_> I can't always use doge.
22:08:19 <monochrom> Then again, what if I told you, you could LU-factor the Matrix.
22:08:41 <koz_> There was a Twitter thread a while back about how the Matrix was clearly written in JavaScript.
22:08:48 <koz_> I was laughing so much I was crying by the end of it.
22:08:49 <monochrom> haha
22:14:59 <infinisil> Argh, how can i make cabal's data-files include a whole subdirectory?
22:15:35 <infinisil> Any of data-files: subdir, subdir/, subdir/*, subdir/**/*, subdir/*/ don't work
22:47:57 <dmwit> infinisil: Can't, for security reasons.
22:49:08 <dmwit> infinisil: You can make all the files with a specific extension available.
22:49:18 <dmwit> subdir/**/*.png for example
22:49:32 <dmwit> https://cabal.readthedocs.io/en/latest/developing-packages.html#pkg-field-data-files has the full details
22:52:20 <infinisil> Huh, what security reasons?
22:52:35 <infinisil> Accidentally including sensitive files?
23:24:08 <iqubic> Is there a way to get the last element in a traversable?
23:24:57 <jle`> iqubic: foldMap (Just . Last)
23:25:08 <jle`> or just last . toList
23:25:32 <iqubic> Nice.
23:30:05 <pounce> ugh, wish racket had Maybe and >>= i want to be done with this class so i can get back to hs
23:31:38 <ammar2> implement your own?
23:37:50 * hackage hasbolt-extras 0.0.0.25 - Extras for hasbolt library  https://hackage.haskell.org/package/hasbolt-extras-0.0.0.25 (ozzzzz)
23:39:03 <pounce> ammar2: been thonkin about it
23:39:19 <ammar2> Maybe should be easy
23:39:20 <pounce> implemented some operators, but i don't want to get too distracted from my project
23:39:50 <pounce> well the language im working in has some/none but there isn't really a good way to sequence them
23:40:40 <ammar2> oh so you need the Maybe Monad
23:42:19 <pounce> ye
23:45:52 <iqubic> How do I apply a function to the first element of a tuple?
23:46:04 <lavalike> :t Data.Bifunctor.first
23:46:06 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
23:46:24 <iqubic> Ugh. I don't want to install bifunctors right now.
23:46:30 <Gcf> I have a bizzare issue where code that works fine in ghci does not work when ran with runghc. Specifically, the error is a type error. Any thoughts? Details here: https://gist.github.com/GiantCowFilms/57f30fabef6d6ae95070ea3d28a7d79a
23:47:26 <lavalike> :t (Control.Arrow.*** id)
23:47:28 <lambdabot> (b -> c) -> (b, b') -> (c, b')
23:48:02 <lavalike> but bifunctor is in base
23:51:08 <iqubic> It is?
23:51:35 <ammar2> so many people doing advent of code here 
23:51:57 <pounce> lol
23:52:12 <Gcf> :P
23:53:11 <Gcf> Haskell is one of those "I've always wanted to try that but don't have a project that needs it language," which makes it very popular for AoC.
23:54:12 <koz_> iqubic: For quite a while now.
23:54:18 <koz_> Data.Bifunctor is what you want.
23:56:51 <pounce> i think at this point haskell is just my aoc lang
23:57:34 <jle`> that's how it starts
23:57:35 <jle`> ;)
23:58:04 <ammar2> D:
