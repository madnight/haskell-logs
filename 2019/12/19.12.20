00:00:54 <kangyu> :i Monad
00:01:44 <dminuoso_> kangyu: Try prefixing it with % so you use yahb instead.
00:02:06 <dminuoso_> kangyu: lambdabot is a special interface, whereas yahb gives you an IRC-GHCi interface. :)
00:06:52 <olligobber> wait, the order of characters in portal names matters??
00:07:23 <olligobber> I just noticed I have three portals with characters X and J
00:08:07 <olligobber> ugh, which matches to which?
00:08:14 <nil> olligobber: a bunch of haskellers are in ##adventofcode{,-help,-spoilers}
00:08:40 <olligobber> ty nil
00:08:48 <olligobber> I'll try and figure it out myself though
00:11:32 <olligobber> ugh, there's a typo in one of the samples
00:15:34 <kangyu> %i Monad
00:15:41 <kangyu> %:i Monad
00:18:02 <olligobber> nope, it's just confusing input
00:21:12 <olligobber> ugh, I blame whoever wrote the problem / generated the input
00:21:58 <olligobber> probably the same person
00:24:04 <Ailrun[m]> kangyu try @listmodules, @list, and @help. @version would also be useful.
00:24:15 <iqubic> olligobber: I see that this isn't going to work for part 2: http://dpaste.com/3KSJ52S
00:24:25 <kangyu> @help
00:24:25 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:24:32 <kangyu> @list
00:24:32 <lambdabot> What module?  Try @listmodules for some ideas.
00:24:40 <kangyu> @listmodules
00:24:40 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
00:24:40 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
00:25:15 <Ailrun[m]> list requires a specific module name, and help requires a specific command name.
00:25:28 <olligobber> iqubic, that wouldn't work for my input either, since I had a portal pairs labeled "BB", "XJ" and "JX"
00:25:48 <olligobber> as in, there were 4 portals using 'X' and 'J'
00:25:50 <kangyu> @list base
00:25:50 <lambdabot> base has no visible commands
00:26:08 <Ailrun[m]> @list hoogle
00:26:08 <lambdabot> hoogle provides: hoogle hoogle+
00:26:20 <kangyu> ...
00:26:41 <iqubic> olligobber: Yeah, I see.
00:26:48 <Ailrun[m]> @version
00:26:48 <lambdabot> lambdabot 5.2
00:26:48 <lambdabot> git clone https://github.com/lambdabot/lambdabot
00:27:03 <olligobber> iqubic, and somehow I got the right answer to task 1 without realising that XD
00:27:18 <kangyu> @type
00:27:19 <lambdabot> <no location info>: error: not an expression: ‘’
00:27:26 <kangyu> @type Monad
00:27:28 <lambdabot> error: Data constructor not in scope: Monad
00:27:34 <olligobber> @kind Monad
00:27:37 <lambdabot> (* -> *) -> Constraint
00:28:25 <Ailrun[m]> And you can also use lambdabit commands in a private chat room, so if you want to do some experiments, it would be better to do it in the private room.
00:28:51 <Ailrun[m]> s/lambdabit/lambdabit/
00:29:16 <kangyu> get it
00:29:17 <Ailrun[m]> damn autocorrection
00:29:49 <olligobber> should have made my code error if there were too many portals with the same id
00:30:03 <olligobber> rather than just keeping one of them and throwing the other away
00:44:02 <olligobber> I will never use Map.fromList again
00:44:32 <int-e> olligobber: why?
00:44:57 <olligobber> int-e, it throws away duplicated keys
00:45:29 <int-e> I have to admit that I usually use fromListWith.
00:45:29 <olligobber> instead I'll use Map.fromListWith (error "Duplicate key") or some other combining function
00:45:34 <Rembane> olligobber: what should it do otherwise? 
00:45:58 <int-e> But I have not really been bitten by this, I think. Lucky me, I suppose.
00:46:08 <olligobber> I just spent like an hour debugging code because fromList threw away duplicate values
00:46:56 <olligobber> I feel like I just got really unlucky with the test case generator, but still
00:47:11 <Rembane> Oh :/
00:54:42 <ggole> Seems like it would be ok if it had a more descriptive name
00:55:32 <ggole> fromListSilentlyDiscardingDuplicatesAndKickingPuppies
01:00:14 <olligobber> I should probably stop using Map.! too, but it's just so useful
01:25:05 <toast52> Does anyone know whether mapAccumL suffers the same problems as foldl?
01:33:04 <Franciman> Hello
01:33:24 <Franciman> I have a chunked conduit stream: ConduitT ByteString o m r
01:33:44 <Franciman> I would like to split the input on \r\n
01:33:52 <Franciman> but I can't find an easy way to do it
01:34:10 <Franciman> is there any library to do this?
01:34:17 <Franciman> library function
01:53:40 <zincy> Has anyone here set up a Haskell layer with Spacemacs?
01:55:34 <Franciman> solved
01:55:43 <dminuoso_> zincy: Instead of asking a meta question, ask your question directly.
01:55:51 <dminuoso_> (And note, the problem is most likely spacemacs)
01:56:06 <dminuoso_> Most spacemacs problems disappear if you just use emacs directly.. :)
02:00:47 <nil> say i want an ST computation to return a function `\x -> doSomethingWith x`, where doSomethingWith is an ST computation that takes place in the same state thread. this is impossible, right?
02:05:10 <dminuoso_> nil: What do you mean exactly?
02:05:34 <dminuoso_> nil: Do you want to have some `doSomething :: ST s (ST s T)` ?
02:05:47 <dminuoso_> That's perfectly possible.
02:06:11 <nil> is it? with the same s on both ST's?
02:06:23 <dminuoso_> nil: Sure. In fact, that's sort of how the Monad instance works (conceptually)
02:06:33 <dminuoso_> nil: If we think of Monad as being describable by `return` and `join`
02:06:38 <int-e> :t join
02:06:39 <lambdabot> Monad m => m (m a) -> m a
02:06:41 <nil> wait, of course
02:06:49 <nil> this is too simple, it can't be what i want
02:06:58 <int-e> (join :: ST s (ST s a) -> ST s a)
02:08:13 <dminuoso_> nil: The only limitation with ST is that you can't leak ST. So something like `runST pure` is impossible
02:08:27 <nil> basically i want `foo :: ST s (Foo -> Bar)`, where the `Bar` is the result of an `ST s` computation
02:08:43 <dminuoso_> nil: Monad, still.
02:09:02 <dminuoso_> foo = do { bar <- someComputation; ... }
02:09:07 <nil> foo = return $ \x -> ??
02:09:20 <dminuoso_> nil: No, rather:
02:09:37 <dminuoso_> nil: do { bar <- someComputation; pure (\x -> ... bar) }
02:09:47 <nil> but the computation depends on x! that's the key thing
02:09:55 <nil> sorry if this wasn't clear
02:10:21 <dminuoso_> % :t (>>=)
02:10:21 <yahb> dminuoso_: Monad m => m a -> (a -> m b) -> m b
02:10:28 <Ailrun[m]> Then do it in the lambda.
02:11:41 <nil> > foo = do r <- newSTRef 42; return $ \x -> (+x) <$> readSTRef r
02:11:41 <nil> foo :: Num b => ST s (b -> ST s b)
02:11:45 <lambdabot>  <hint>:1:5: error:
02:11:45 <lambdabot>      parse error on input ‘=’
02:11:45 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
02:11:54 <nil> sorry lambdabot, didn't mean to trigger you
02:11:56 <Ailrun[m]> do {- Something .. -} pure $ \x -> do v <- someComp; return res
02:12:14 <nil> so, i have `ST s (b -> ST s b)`, how do i convert that to `ST s (b -> b)` ?
02:12:33 <nil> i'd need another runST in there, but the types don't match
02:12:55 <nil> (the whole point is to ultimately use `runST foo` to get a pure `b -> b` function
02:12:57 <nil> )
02:14:00 <dminuoso_> nil: That's not possible
02:14:11 <nil> indeed
02:14:23 <dminuoso_> nil: You are trying to sneak out a state thread.
02:14:31 <nil> yeah, that's what i was fearing
02:14:47 <nil> yet i don't see how such sneaking out might lead to unsafe behaviour
02:14:57 <dminuoso_> nil: Consider the analogy with: trying to turn `IO (a -> IO b)` into `IO (a -> b)`
02:15:33 <dminuoso_> It's ill-conceived for the same reasons
02:16:29 <ephemient> well with `runST .` you *can* turn `forall s. a -> ST s b` into `a -> b`
02:16:46 <dminuoso_> ephemient: Sure, but they specifically said it must be in the same state thread
02:16:46 <ephemient> but that's not what you have inside an `ST s (a -> ST s b)`
02:16:54 <nil> yeah, i don't have that forall
02:17:36 * Ailrun[m] sent a long message:  < https://matrix.org/_matrix/media/r0/download/matrix.org/ZWTYGumKwTgLOCuYMkxvQyEi >
02:18:02 <dminuoso_> nil: The only mechanisms to make some `ST s` disappear is runST or join
02:18:13 <Ailrun[m]> (y is your ST s (b -> ST s b))
02:19:20 <ephemient> unsafePerformIO . unsafeSTToIO
02:19:37 <ephemient> sounds pretty dubious ;-)
02:19:45 <Ailrun[m]> Haha :)
02:19:49 <dminuoso_> What could possibly go wrong.
02:20:01 <dminuoso_> unsafe after unsafe makes it safe again, right?
02:20:13 <nil> ununsafe
02:20:39 <Solonarv> nil: ah, but if you have a 'forall s. ST s (b -> ST s b)` you *can* turn that into a pure `b -> b`
02:20:41 <ephemient> throw an unsafeCoerce in there just to be sure
02:20:43 <Ailrun[m]> ununsafe does not imply safe! from constructive logician.
02:20:54 <dminuoso_> ephemient: But that gives us three times unsafe, that gives us unsafe again.
02:21:04 <dminuoso_> ephemient: Gotta have an even number of unsafes.
02:21:05 <nil> Solonarv: how?
02:21:09 <dminuoso_> Perhaps accursedUnutterablePerformIO?
02:21:11 <dminuoso_> That's not unsafe.
02:21:34 <nil> accursed, unutterable sounds a lot more friendly than unsafe
02:21:50 <Solonarv> % :t \m b -> runST (join (($ b) <$> m))
02:21:50 <yahb> Solonarv: ; <interactive>:1:16: error: Variable not in scope: join :: f b -> ST s a
02:21:56 <Solonarv> ...really?
02:21:59 <iqubic> dminuoso_: have you looked at Chris Penner's new Optics book?
02:22:00 <Solonarv> % import Control.Monad
02:22:00 <yahb> Solonarv: 
02:22:03 <Solonarv> % :t \m b -> runST (join (($ b) <$> m))
02:22:03 <yahb> Solonarv: ; <interactive>:1:32: error:; * Couldn't match expected type `ST s (p1 -> ST s a)' with actual type `p'; because type variable `s' would escape its scope; This (rigid, skolem) type variable is bound by; a type expected by the context:; forall s. ST s a; at <interactive>:1:9-34; * In the second argument of `(<$>)', namely `m'; In the first argument of `j
02:22:06 <nil> HAH!
02:22:12 <Solonarv> heck
02:22:24 <dminuoso_> nil: Heh. Except accursedUnutterablePerformIO is so massively dangerous that you can properly corrupt memory left and right with it.
02:22:34 <dminuoso_> unsafePerformIO is totally safe, in comparison
02:22:38 <Solonarv> oh, maybe it just can't infer the type
02:22:53 <Ailrun[m]> :t \m b -> runST (join (($b) <$> m))
02:22:55 <lambdabot> error:
02:22:55 <lambdabot>     • Couldn't match expected type ‘ST s (p1 -> ST s a)’
02:22:55 <lambdabot>                   with actual type ‘p’
02:23:25 <iqubic> I have used unsafePerformIO in all of my AoC solutions from the past week.
02:23:29 <nil> Solonarv: what's `b`, even?
02:23:47 <Solonarv> % :t let foo :: (forall s. ST s (a -> ST s b)) -> a -> b; foo m a = runST (join (($ a) <$> m)) in foo
02:23:48 <yahb> Solonarv: (forall s. ST s (a -> ST s b)) -> a -> b
02:23:53 <Solonarv> there!
02:24:12 <Solonarv> it was indeed just a failure to infer the type
02:24:22 <nil> oh. well let me study this
02:25:08 <ephemient> iqubic: just for input? or more
02:25:16 <Solonarv> this has the downside that the outer ST computation will also be re-run every time
02:25:25 <Solonarv> and not just the inner one
02:25:27 <iqubic> Just for grabbing input.
02:25:30 <Solonarv> but I don't think that's avoidable
02:25:52 * Solonarv would recommend not using unsafePerformIO for reading input
02:26:13 <nil> unsafeInterleaveIO is enough, right?
02:26:25 <Solonarv> you don't need that either
02:26:30 <nil> nevermind that, i guess it depends what you're trying to do
02:26:40 <Solonarv> it's not like the inputs are so huge you have to stream them
02:27:16 <ephemient> iqubic: why not just read the inputs in `main :: IO ()` and pass them off to pure puzzle code?
02:28:25 <Solonarv> exactly!
02:30:39 <boxscape> Really don't understand how people can manage using dynamic languages. I use unsafeCoerce *once* and already I'm accidentally coercing an Integer into an Int in the process
02:31:24 <__monty__> Most of those languages don't have unbounded ints so readily available afaik? So there's no truncation because that already happened.
02:31:36 <iqubic> that's a major loss of data.
02:31:57 <boxscape> __monty__ fair, but the same argument applies to Double et al.
02:33:13 <__monty__> Those bugs probably slip under the radar most of the time because no one understands floats : )
02:33:20 <iqubic> Java has compiler warnings telling you about potential lossy conversion, but still lets you do the unsafe thing.
02:33:31 <Solonarv> __monty__: or the converse, the default integer type is unbounded and you have to jump through hoops to get bounded ones (e.g. python)
02:33:37 <boxscape> I can luckily get rid of the unsafeCoerce if I use singletons, that's how I noticed the bug in the first place
02:33:57 <__monty__> Solonarv: TIL
02:34:06 <boxscape> huh I didn't know that either
02:34:41 <Solonarv> >>> 2**128
02:34:41 <Solonarv> 340282366920938463463374607431768211456
02:34:45 <__monty__> Oh, that's py3. I stopped caring about python at that point : /
02:34:49 <Solonarv> heh
02:35:15 <Solonarv> I am currently forced to use it again for the scientific computing stuff
02:35:47 <boxscape> I wish more libraries (looking at you, numpy) had type annotations for python, then at least sing mypy might make sense
02:35:51 <int-e> __monty__: python 2 is the same? (though it adds an L in the output...)
02:36:40 <boxscape> s/sing/using
02:36:41 <__monty__> int-e: Not really though. It implicitly converts from int to long but that's still bounded afaik?
02:37:09 <int-e> >>> 2**256
02:37:09 <int-e> 115792089237316195423570985008687907853269984665640564039457584007913129639936L
02:37:17 <int-e> that's what I get in Python 2.7.17
02:37:29 <Taneb> Does anyone know a good type for 2D arrays with fast update of an arbitrary position and fast lookup?
02:38:37 <int-e> __monty__: I suppose it's fairly easy to accidently convert to double though.
02:39:26 <int-e> __monty__: because that conversion (long, which is unbounded integers, to double) is implicit.
02:40:53 <__monty__> Hmm, so python2's long is actually unbounded? TIL
02:41:23 <int-e> python tends to be amazingly sane for an untyped language.
02:41:46 <infinisil> int-e: it's still typed
02:41:53 <infinisil> Just not statically
02:42:05 <int-e> infinisil: we are in #haskell ;)
02:42:21 <infinisil> !
02:42:27 <yushyin> here we go again :D
02:42:29 <iqubic> Is Nix typed?
02:42:29 <boxscape> Oh wow if you bind a variable with forall, but only use it via ScopedTypeVariables and not in the type signature, you get an unused forall binding warning. That's terrible.
02:42:44 <boxscape> (with -Wall)
02:43:30 <iqubic> -Wall is my favorite.
02:43:34 <Solonarv> Taneb: a 1D array with index mangling?
02:43:45 <Solonarv> er, actually
02:44:03 <Solonarv> do you want a pure-functional or a mutable data structure?
02:44:20 <Taneb> Pure-functional ideally
02:45:12 <Solonarv> okay, then a plain old Map is going to do a pretty good job
02:45:24 <Solonarv> using e.g. V2 Int as the key
02:46:01 <Solonarv> hm, you could also use a IntMap if your bounds are small enough that you can wrangle the 2D index into a single int
02:46:04 <Solonarv> might be faster
02:46:56 <Solonarv> for a pure-functional data structure you won't really get faster than the log n insert/lookups of those maps
02:47:31 <Solonarv> Vector/Array has O(1) lookup, but (using the pure interface) inserting is terrible as the entire array has to be copied, so it is O(n)
02:47:53 <int-e> infinisil: Also, can you name a real-world language that is dynamically untyped? I'm having trouble... note that even a "pure OO" language is typed in that some objects will fail to accept certain method invocations (i.e., I consider duck-types to be types).
02:48:07 <boxscape> x86 \assembly
02:48:13 <boxscape> s/\\//
02:48:51 <Solonarv> shell also: the only type is string
02:49:03 <Solonarv> well, there are arrays and dictionaries, but they are not used much AFAIK
02:49:37 <nil> i've reduced my problem to a minimal example. the goal is to have this program output (45, 49): https://gist.github.com/niiiil/4152fc6f586e89369390c76562649333
02:49:46 <nil> this doesn't compile, for various reasons
02:49:52 <boxscape> "High-level untyped languages include BCPL, Tcl, and some varieties of Forth", says wikipedia
02:50:22 <int-e> boxscape: Good point, I should've tried Wikipedia.
02:50:32 <nil> i think what i'm trying to do with getThread and runSTWith could be accomplished with the unsafe* functions for ST, somehow?
02:51:04 <nil> (just fixed a typo in the gist)
02:51:21 <Solonarv> nil: remember that the state token doesn't actually do anything
02:51:37 <Solonarv> it is there as a guide to make it easier to not mess up
02:51:58 <nil> right
02:52:09 <int-e> I thought of TCL but it has lists, associative arrays, strings, and probably ints and doubles as well?
02:52:27 <int-e> Sorry, Tcl.
02:52:38 <Solonarv> as in: you can look at the intermediate Core, see that state tokens don't get duplicated or dropped, and feel confident that it isn't doing anything horrible
02:54:08 <int-e> infinisil: Anyway... my point here was that "dynamically untyped" is so uncommon that subsuming "dynamically typed" under "typed" makes the latter term almost meaningless. So I prefer not to do that.
02:54:24 <Solonarv> if they are being slung around willy-nilly then all bets are off
02:56:05 <int-e> infinisil: And I hope that makes a better argument than "this is #haskell" :-)
02:57:02 <nil> Solonarv: still i think what i'm doing is safe since i'm basically just trying to have the state token "jump over" the lambda abstraction
02:57:12 <Solonarv> that doesn't sound safe to me.
02:57:14 <nil> (and the Input and Output constructors)
02:57:23 <Solonarv> but I have to go now
02:57:39 <nil> well it's not duplicated or dropped. the only thing is it might make the computation lazy, but i already plan on using ST.Lazy
02:58:39 <nil> the only error left is "Couldn't match a lifted type with an unlifted type"
02:59:31 <nil> it seems that using the newtype ST from ST.Lazy would fix this as the state token is boxed, unfortunately the constructor isn't exported from Control.Monad.ST.Lazy :'(
03:03:18 <int-e> nil: What is supposed to happen if f' is called several times? Because the type of f' certainly allows that...
03:03:40 <nil> ah. hm.
03:04:26 <nil> i see
03:16:03 <int-e> nil: a possible design for this could be based on the type  run :: ... -> [Reply] -> [Request] ... which ensures that you have to run everything from scratch if you want to change a reply.
03:16:58 <int-e> nil: But it's not the most pleasant type of function to interact with... knot-tying can be very confusing.
03:17:19 <nil> sure, that's one possibility. but my use case requires interleaving replies and requests, so i need to have that Effect type
03:17:54 <int-e> (And if you have user interaction in the loop you'll need to jump through hoops like storing the reply in a Chan-type data structure that can be filled after it has been read (lazily).)
03:17:55 <nil> i don't find knot-tying confusing
03:18:54 <Solonarv> it looks to me like you are just reinventing conduit/pipes/streaming
03:19:03 <nil> maybe
03:45:43 <jle`> nil: note that conduit/etc. are essentially equivalent to free monads over that effect type
03:45:54 <flatmap> can somebody give me an pracical example of this (instance Monoid b => Monoid (a -> b)) ?
03:46:04 <jle`> nil: if you change to data Effect a = Input (Int -> a) | Output Int a
03:46:09 <flatmap> I interpret it as a monoid of a function
03:46:14 <jle`> nil: then Free Effect == Conduit Int Int
03:46:33 <jle`> > mconcat [reverse, take 2, drop 3] "hello world"
03:46:35 <lambdabot>  "dlrow ollehhelo world"
03:46:46 <jle`> ^ flatmap 
03:46:48 <flatmap> ah nice thanks
03:46:55 <flatmap> actually pretty cool
03:47:01 <jle`> > mconcat [reverse, take 2, drop 5] [1..10]
03:47:03 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,1,2,6,7,8,9,10]
03:47:04 <jle`> for a better example maybe
03:47:28 <jle`> nil: if you parameterize your effect on inputs and ouput types
03:47:49 <jle`> nil: data Effect i o r = Input (i -> a) | Output o a
03:48:00 <jle`> nil: then you can do type Conduit i o = Free (Effect i o)
03:48:07 <jle`> your effect type as a free monad is essentially Conduit
03:48:31 <jle`> but remember that all Free does is add recursion and a Pure base case
03:48:37 <jle`> so if you add a 'Pure' case to your effect ...
03:48:52 <jle`> nil: data Effect i o a = Input (i -> Effect i o a) | Output o (Effect i o a) | Pure a
03:49:00 <jle`> then Effect is literally Conduit :)
03:49:15 <jle`> and that's "all there is" really
03:50:26 <jle`> the main conceptual difference is that Conduit is actually the 'free monad transformer' over data Effect i o r = Input (i -> r) | Output o r
03:50:33 <flatmap> just started with haskellbook after somebody here recommended it and it’s just super nice
03:50:43 <flatmap> so thx again :-)
03:51:10 <jle`> flatmap: happy to hear you are enjoiyng your Haskell experience :)
03:51:17 <flatmap> oh yesssss
03:51:19 <flatmap> for sure
03:51:49 <flatmap> I am stuck in conventional languages at my daytime job but haskell gives me the great picture what languages really should deliver
03:52:10 <jle`> flatmap: ah yeah, they do say that one major downside of learning haskell is you grow to resent your day job ;)
03:52:22 <flatmap> yeah, functional curse lol
03:52:55 <flatmap> I am already missing sum types in the other languages
03:53:18 <flatmap> and just made it halfway through the book 
03:55:02 <tdammers> I'd call it "typed curse" - I think Haskell being a (mostly) properly typed language contributes vastly more to its efficiency and pleasantness than it being a functional language
03:55:24 <tdammers> of course the two go hand in hand; you can't really be fully committed to the functional paradigm without a type system to guard it
03:56:16 <flatmap> you also start to hate any kind of non-immutable structures
03:56:21 <tdammers> mwah
03:56:22 <flatmap> and for loops with indices
03:56:33 <tdammers> haskell has mutable structures too, they're a great tool to have in your repertoire
03:56:42 <flatmap> yuk
03:56:46 <tdammers> they're nice
03:56:50 <tdammers> nothing yuck about them
03:57:01 <tdammers> some things are in fact best solved with mutable data structures
03:57:31 <tdammers> the "yuck" part is when a language insists on making *all* data mutable, and doesn't even give you a reliable way to opt out and contain those effects
03:57:38 <flatmap> I mean the kind of mutability that is distributed all over the code and makes any kind of reasoning almost impossiblw
03:58:01 <Solonarv> jle`: also, Conduit specifically has extra nonsense for leftovers and handling termination of the "upstream" conduit
03:58:14 <tdammers> right, yeah - shared mutable state
03:58:30 <flatmap> it’s the same guys that use dependency injection containers to hide their global state
03:58:31 <Solonarv> especially *global* mutable state
03:58:36 <tdammers> but again, the real benefit haskell brings to the table is that it forces you to make both the sharing and the mutability explicit
03:58:58 <flatmap> I fully agree
03:59:20 <tdammers> "dependency injection" is great, and in Haskell, it happens naturally, without any formalisms or "frameworks"
03:59:47 <tdammers> what those "dependency injection frameworks" do, however, isn't really dependency injection so much as it is the "service registry" (anti)pattern
04:00:21 <tdammers> you have a bunch of services, and when you need one of them, you ask the Great Benevolent Service Factory for the right instance
04:00:48 <flatmap> I have seen more uglyness in spring frameworks than somebody should ever have to take in a lifetime
04:01:03 <flatmap> things that cannot be unseen
04:02:22 <tdammers> but of course that means that your Great Benevolent Service Factory now becomes your source of truth on everything; essentially, you have created an Inner Platform, and instead of programming in, say, Plain Old Java or Plain Old Python or Plain Old PHP or whatever, you're now doing some of your programming in the actual language, but the higher-level programming is done in the (shitty, because it's ad-hoc
04:02:23 <tdammers> and done in something like YAML or XML or JSON or something similar that was never meant as a substrate for a full-blown programming language) mini-EDSL that drives your Great Benevolent Service Factory
04:03:13 <flatmap> oh yes, and you trade in compile time safety for a total disaster at runtime
04:03:15 <tdammers> so from an architectural point of view, you're back to spaghetti, except that your spaghetti code is now written in FrankenXML From Hell, and it's driving a massively baroque collection of Extremely Verbose Java Classes
04:03:42 <flatmap> ack
04:04:31 <flatmap> best is. they try to explain it with being enterprisey
04:08:04 <tdammers> don't get me wrong, a service registry can be a good thing, at some architectural level
04:08:24 <tdammers> but please just call it that, don't confuse it with "dependency injection"
04:08:33 <tdammers> if you want dependency injection, it's trivial in Haskell
04:08:42 <tdammers> it's called "passing arguments"
04:09:32 <tdammers> getUserByID :: Connection -> UserID -> IO (Maybe User) -- whoa, I just performed dependency injection for the database connection dependency
04:10:14 <tdammers> if you don't like passing the Connection around all the time, you can instead build a MonadApp that has the connection in its MonadReader context somewhere, then you get:
04:10:26 <tdammers> getUserByID :: UserID -> App (Maybe User)
04:11:46 <tdammers> and if it turns out that the kind of contexts in which you may need to go to the database are too diverse, and you don't want to clutter a single App monad with all that diversity, you can define a class MonadDB that has withDB :: MonadDB m => (Connection -> m a) -> m a
04:12:06 <tdammers> and then you go: getUserByID :: MonadDB m => UserID -> m (Maybe User)
04:13:13 <flatmap> still 14 chapters to go until I can fully apply that knowledge :-)
04:13:57 <tdammers> anyway, the point being, if you design your Haskell applications like this, there will be a natural place to set up your dependencies, and it'll even happen without any conscious design
04:14:14 <tdammers> the types kind of guide you to it
04:15:04 <flatmap> yeah, call it type driven design
04:15:59 <tdammers> this is something I love about haskell in general
04:16:07 <tdammers> through the types, you can set yourself up for success
04:16:59 <tdammers> a very common development cycle is that you write down the constraints of your problem in the types, then you just make the f*ing change, and then you follow the trail of compiler errors, and when they're all fixed, your code will do what you set it up to do
04:18:32 <tdammers> for example, when I want to change my design from the explicit argument passing style (Connection -> ... -> IO User) to having the connection baked into the App monad, I would just change the top-level code that kicks off my application from something like `app db` to `runApp app db`
04:19:02 <tdammers> that will produce a compiler error telling me that runApp expects "App ()" as its first argument, but "app" has type "Connection -> IO ()"
04:19:14 <tdammers> so I go to the definition of "app" and change its type to "App ()"
04:19:40 <tdammers> now it complains that the type has zero arguments, but the definition has one. so I remove the "db" argument.
04:20:16 <tdammers> now a bunch of queries that my app function wants to call fail, because "db" is no longer in scope - but I now have a withDB function I can wrap those queries in, so I do that
04:21:12 <tdammers> "query db sql params" becomes something like "withDB $ \db -> query db sql params". A fairly mechanical conversion still, and if I get it wrong, the compiler will tell me.
04:21:36 <tdammers> and once I have fixed all those type errors, I'm done, and I can be quite confident that everything works
04:21:44 <tdammers> now imagine making a similar refactoring in Python
04:25:11 <flatmap> I do a similar approach in non-haskell languages but the stronger the typing the better it works
04:25:27 <flatmap> put many things in interfaces and such
04:25:34 <flatmap> in java/kotlin/scala
04:25:59 <flatmap> but not having the beauty and elegancy of haskell
04:26:52 <flatmap> I coined the term „error driven design“ for that
04:27:14 <flatmap> which basically sound like the way you described
04:27:28 <flatmap> I guess this will be a lot more natural and nicer in haskell
05:00:08 <LevyElara[m]> tdammers: There's type annotations and mypy
05:01:21 <tdammers> LevyElara[m]: not the same thing though.
05:53:01 <LevyElara[m]> tdammers: you can get somewhere close to safety with it if you litter your code with annotations and make refactoring safe though code will be next to impossible to follow from a reading standpoint. It is the same thing with static checkers as long as they're capable of checking constraints in some form.
05:53:39 <boxscape> problem is not all libraries have type annotations
05:55:51 <LevyElara[m]> yep, it's the same as dealing with FFI
06:34:23 <tdammers> exactly. and so the type system has to make concessions.
06:41:30 <nil> jle`: thanks, that's very interesting
06:41:47 <boxscape> % class Class caps where method :: a
06:41:47 <yahb> boxscape: 
06:41:52 <boxscape> % instance Class () where method = undefined
06:41:52 <yahb> boxscape: 
06:41:58 <boxscape> % method @_
06:41:59 <yahb> boxscape: ; <interactive>:99:1: error:; * Ambiguous type variable `w0' arising from a use of `method'; prevents the constraint `(Class w0)' from being solved.; Probable fix: use a type annotation to specify what `k0', `w0' should be.; These potential instance exist:; one instance involving out-of-scope types instance [safe] Class () -- Defined at <interactive>:98:10; * In the expr
06:42:23 <boxscape> You need AllowAmbiguousTypes for this class, but it seems odd that ghc cannot get the right type here considering there's only one instance
06:42:27 <boxscape> % method ()
06:42:27 <yahb> boxscape: ; <interactive>:100:1: error:; * Ambiguous type variable `caps0' arising from a use of `method'; prevents the constraint `(Class caps0)' from being solved.; Probable fix: use a type annotation to specify what `k0', `caps0' should be.; These potential instance exist:; one instance involving out-of-scope types instance [safe] Class () -- Defined at <interactive>:98:10; * I
06:42:34 <boxscape> % method @()
06:42:35 <yahb> boxscape: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:98:34 in interactive:Ghci43
06:43:17 <Solonarv> 'method @_ :: forall w a. Class w => a'
06:43:40 <Solonarv> that constraint is not a substitution instance of 'Class ()'
06:44:06 <boxscape> I'm not sure what a substitution instance is
06:44:42 <Solonarv> "X is a substitution instance of Y" means "by taking Y and substituting things for its variables, we can get X"
06:45:05 <boxscape> I see
06:45:20 <Solonarv> for example 'Just 3' is a substitution instance (SI) of 'Just x', by choosing x=3
06:45:29 <boxscape> okay
06:45:39 <Solonarv> 'Show [Char]' is a SI of 'Show [a]' by choosing a=Char
07:10:45 <Amras> what's the new-cabal best practice for including a local, non-hackage library, what with new-sandbox not existing?
08:12:25 <jgt> in a WAI application (like Yesod), how would you achieve the equivalent of nginx's proxy_pass?
08:13:38 <jgt> I know there's the http-reverse-proxy package, but I'm not yet sure exactly how to use it, or if perhaps there's a simpler way like a WAI middleware, or even just some initial Warp settings
08:23:21 <boxscape> % do ;;;;;;;;;;;;;;;;;; putStrLn "hi"
08:23:21 <yahb> boxscape: hi
08:23:23 <boxscape> neat
09:04:09 <boogiewoogie> clever: rebuilding fails for me with https://hastebin.com/recareboho.bash
09:05:00 <boogiewoogie> oh wait
09:05:05 <boogiewoogie> maybe I messed up
09:05:44 <boogiewoogie> I did, okay
09:05:49 <boogiewoogie> now let's see
09:29:06 <_deepfire> kosmikus: do you know if there are ways to make ghc infer "All c (Tail xs)" from "All c xs"?
09:29:58 <jollygood2> @hoogle Integral a => a -> Ptr
09:29:59 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
09:29:59 <lambdabot> Test.Hspec.Discover fromIntegral :: (Integral a, Num b) => a -> b
09:29:59 <lambdabot> Distribution.Compat.Prelude.Internal fromIntegral :: (Integral a, Num b) => a -> b
09:29:59 <_deepfire> It's a bit annoying that one has to perpetually propagate the truisms around, in context of stronger evidence..
09:30:43 <jollygood2> how do I convert pointer address literal to Ptr?
09:30:54 <jollygood2> ie, 0x.....
09:33:01 <_deepfire> jollygood2: there's intPtrToPtr :: IntPtr -> Ptr a, whereas IntPtr is a newtype around Int
09:33:30 <jollygood2> thanks
09:33:54 <_deepfire> that's in Foreign.Ptr
09:37:40 <jollygood2> works, thanks. I half expected just 0x... :: Ptr to work
09:38:13 <jollygood2> but there's usually no need to do that
09:46:00 <kosmikus> _deepfire: the way All is defined in sop-core, All c (x : xs) implies All c xs, so I don't understand the problem, I'm afraid
09:49:05 <solonarv> _deepfire: I think the problem is that Tail xs can't be reduced because xs isn't known
09:49:24 <solonarv> this can probably be fixed with a typechecker plugin
09:52:08 <_deepfire> kosmikus: that implication is what I would expect, indeed, however
09:52:45 <_deepfire> 1. I have an incoming constraint that establishes All c xs, and also xs ~ x:xss
09:53:07 <solonarv> oh huh, so ghc really should be able to reduce (Tail xs)
09:53:11 <solonarv> I wonder why it doesn't
09:53:40 <_deepfire> 2. An expression that requires All c xss -- still requires me to add the All c xss -- or All c (Tail xs)
09:54:02 <_deepfire> I probably should make an isolated test case
09:54:15 <kosmikus> yes, that might help
10:02:38 <toast52> hi, is there any way to use unsafeInterleaveIO / unsafeInterleaveST in a monad transformer with IO / ST at the base?
10:04:43 <nil> liftIO/liftST?
10:06:07 <kosmikus> _deepfire: as a first approximation, https://gist.github.com/kosmikus/b58ab97e2cd26d34cd1f06c588ff86fd works
10:06:18 <toast52> but unsafeInterleaveIO is an `IO a -> IO a` whereas liftIO is `IO a -> m a` right?
10:07:00 <_deepfire> http://pastebin.com/K5JPYUHZ
10:08:06 <kosmikus> _deepfire: that's because as the error message says, c is ambiguous
10:08:09 <nil> yes, you want the composition
10:08:15 <nil> :t liftIO . unsafeInterleaveIO
10:08:17 <lambdabot> error:
10:08:17 <lambdabot>     Variable not in scope: unsafeInterleaveIO :: a -> IO a1
10:08:20 <kosmikus> _deepfire: you either need to add a proxy or a type argument to fix it
10:08:21 <nil> % :t liftIO . unsafeInterleaveIO
10:08:21 <yahb> nil: ; <interactive>:1:1: error:; * Variable not in scope: liftIO :: b0 -> c; * Perhaps you meant one of these: `liftM' (imported from Control.Monad), `liftM2' (imported from Control.Monad), `liftM3' (imported from Control.Monad); <interactive>:1:10: error: Variable not in scope: unsafeInterleaveIO :: a -> b0
10:08:24 <nil> ugh.
10:08:55 <_deepfire> kosmikus: ah, thank you a lot!
10:09:15 <nil> toast52: liftIO . unsafeInterleaveIO :: IO a -> m a
10:09:32 <_deepfire> Indeed, I've been already adding proxies to resolve ambiguities before, but not for the constraint..
10:09:34 <toast52> nil: ok yeah I get it. Now it seems obvious
10:09:38 <toast52> thanks!
10:10:50 <_deepfire> Interestingly, my paste also hangs GHC when I run GHC 8.6.4 directly on it, but works fine from ghci.
10:14:10 <toast52> oh wait that wasn't what I wanted.. I want to be able to use unsafeInterleaveST on the transformer stack, i.e. I'm looking for a function `(ST s a -> ST s a) -> (t (ST s a) -> t (ST s a))`
10:14:37 <toast52> which i dont think is possible actually
10:15:21 <nil> i don't get it
10:16:07 <kosmikus> _deepfire: hmm, I just got an infinite loop for your paste as well. that looks like a bug to me.
10:16:24 <kosmikus> _deepfire: anyway, the "corrected" version seems to work for me.
10:16:36 <toast52> I basically have a ReaderT over ST for convenience. But now I want to use unsafeInterleaveST but I can't use it on my ReaderT (ST s) monad
10:17:49 <solonarv> toast52: it's possible for "sufficiently nice" transformer stacks
10:17:54 <nil> aah, maybe you want mapReaderT
10:18:00 <nil> :t mapReaderT
10:18:02 <lambdabot> (m a -> n b) -> ReaderT r m a -> ReaderT r n b
10:18:12 <solonarv> yeah, if the stack is known you can just use mapReaderT
10:19:38 <nil> something something functor in the category of monads
10:20:16 <toast52> ooooh right
10:20:47 <toast52> First time I've had the use for mapReaderT, so never thought about it. Thanks a lot!
10:22:47 <solonarv> nil: well, MFunctor only lets you transform the "next layer down"
10:23:12 <_deepfire> kosmikus, indeed, thank you again!
10:27:44 <kosmikus> _deepfire: you're welcome.
10:32:46 <ocharles> Can anyone suggest a package to me on Hackage that has only a few dependencies, and also has exactly one test-suite?
10:32:55 <ocharles> Weirdly I am struggling to find one that matches that criteria :)
10:33:13 <ocharles> Diff and diff3 were candidates, but nixpkgs seems to have tests disabled for those
10:38:17 <phadej> ocharles: tree-diff
10:38:53 <phadej> or fin
10:39:15 <phadej> `fin` is very light dependency wise, hashable and QuickCheck
10:39:45 <phadej> (and testsuite has tagged and inspection-testing, which are also relatively light)
10:41:40 <phadej> or even https://hackage.haskell.org/package/some-1.0.1/some.cabal, that one don't have dependencies at all, with recent enough GHC
10:43:14 <ocharles> phadej: perfect, thanks!
10:43:17 <ocharles> I thought you'd have one :)
10:43:41 <phadej> the exactly one test-suite narrows done them quite well though
10:44:02 <phadej> (I often have some example as a test-suite)
11:11:34 <facundominguez> Hello Alp! I'm facing a challenge here using nix to setup some CI for inline-java that uses a specific branch of GHC.
12:21:48 <oats> I defined a MonadFail instance for a type synonym I created after ghc complained about a pattern match I did in a do-block, but now ghc complains that there's overlapping instances of MonadFail! What's going on here?
12:22:00 <oats> here's the type, btw: "type Machine = StateT MachineState (Except MachineError)"
12:26:04 <nil> there's already an instance MonadFail (StateT m), so yours overlaps
12:26:28 <nil> you'd need to wrap your monad stack in a newtype to be able to define instances for it
12:27:53 <nil> (actually there's an instance `MonadFail m => MonadFail (StateT m)`, and an instance `MonadFail m => MonadFail (ExceptT m)`, and finally an instance `MonadFail Identity`, which is why there's an instance for your type)
12:31:54 <bifunctor35> https://stackoverflow.com/questions/59421562/unable-to-add-classy-prelude-dependency?noredirect=1#comment105030361_59421562
12:32:03 <bifunctor35> would be nice, if someone could helo
12:32:06 <bifunctor35> help
12:35:05 <MarcelineVQ> bifunctor35: is that the package.yaml ? if so, what's the cabal file look like?
12:35:38 <bifunctor35> yes it is package.yaml
12:35:55 <wildtrees> bifunctor, I don't use stack alot, but I think if you want stack to work with ghci, there is a way you call ghci using the stack command. are you doing that bifunctor ? 
12:36:10 <wildtrees> I could be mistaken 
12:36:30 <bifunctor35> I
12:36:39 <bifunctor35> I've deleted the folder ~.stack
12:37:05 <oats> nil: yeah, but ghc's initial error suggested to me that there wasn't an instance
12:37:11 <bifunctor35> and am trying again
12:37:16 <oats> and then when I creat an instance it says there's 2??
12:37:47 <bifunctor35> Now it works
12:37:57 <bifunctor35> delete ~.stack help
12:38:10 <evelyn> You want help deleting ~/.stack?
12:38:19 <MarcelineVQ> evelyn: no, it helped
12:38:36 <bifunctor35> yes
12:38:44 <evelyn> oh.. :)
12:38:54 <bifunctor35> sorry for my mistake
12:39:21 <MarcelineVQ> I wouldn't call it your mistake, it's a pretty myserious error
12:40:33 <MarcelineVQ> you might have just needed to delete .stack/indices since that's where pasckage index are stored so if it happens again try that
12:40:48 <bifunctor35> ;->
12:40:53 <bifunctor35> thanks a lot guys
12:41:52 <oats> nil: also, I can't find the MonadFail Identity instance
12:42:53 <MarcelineVQ> MonadFail is for pattern matching failures,​ Identity only has one pattern, would it have an instance?
12:43:14 <MarcelineVQ> *MonadFail is used for pattern
12:43:46 <oats> oh wait
12:43:58 <oats> it's pulling in the mysterious instance from the `transformers` package
12:44:11 <oats> I didn't add that one, that must be a dependency of something else
12:44:18 <oats> I don't want to use that instance
12:44:21 <oats> I'm using mtl
12:45:09 <MarcelineVQ> mtl uses transformers
12:45:30 <oats> can I tell ghc to only use my instance?
12:47:13 <MarcelineVQ> not if you're using mtl and mtl exposes conflicting ones from transformers
12:58:27 <nil> hm, weird. seems like there's no MonadFail Identity indeed
12:59:13 <nil> i thought such an instance would be useful for monad stacks somehow
12:59:37 <wildtrees> nil, how can you make Identity fail though? 
12:59:56 <jle`> nil: a MonadFail Identity sounds like a bad idea ...
13:00:01 <nil> you can't, but you might make FooT Identity fail
13:00:25 <jle`> nil: in fact I'd probably say that preventing MonadFail Identity is the entire reason why MonadFail exists in the first place
13:00:34 <wildtrees> nil, but that would be outside of Identity! 
13:00:34 <nil> but then i guess the instance would be `MonadFail (FooT m)` and not `MonadFail m => MonadFail (FooT m)`
13:00:46 <nil> jle`: hm?
13:00:46 <jle`> nil: it depends on what FooT is
13:00:58 <jle`> nil: the reason why we split MonadFail out of Monad was so that we wouldn't have to implement fail for monads like Identity
13:01:06 <nil> ah
13:01:08 <jle`> that's the entire reason for the existance of MonadFail in the first place
13:01:18 <jle`> existence
13:01:21 <jle`> (?)
13:01:40 <jle`> if there was an instance MonadFail Identity then there would be no reason for MonadFail existing ;)
13:03:06 <jle`> we do have instance Monad m => MonadFail (MaybeT m)
13:03:18 <jle`> the meaning of that instance is that MaybeT handles the failure, not m
13:03:52 <jle`> so we do have an instance of MonadFail (MaybeT Identity) :)
13:03:59 <jle`> > fail "hi" :: MaybeT Identity ()
13:04:01 <lambdabot>  error:
13:04:01 <lambdabot>      Not in scope: type constructor or class ‘MaybeT’
13:04:01 <lambdabot>      Perhaps you meant ‘Maybe’ (imported from Data.Maybe)
13:04:08 <jle`> @let import Control.Monad.Trans.Maybe
13:04:10 <lambdabot>  Defined.
13:04:11 <jle`> > fail "hi" :: MaybeT Identity ()
13:04:14 <lambdabot>  MaybeT (Identity Nothing)
13:04:44 <jle`> similarly this is also the main reason why MaybeT exists in the first place
13:04:56 <jle`> to provide failure semantics to monads that might not have them
13:05:25 <jle`> so if MaybeT can only add failure semantics to monads that already have their own failure semantics. ... there's no point for MaybeT existing :)
13:06:56 <oats> I'm just confused about why ghc doesn't see this existing MonadFail before I create my own
13:07:25 <oats> full error: https://paste.xinu.at/6cXo5k
13:08:19 <jle`> oats: i'm not sure what you mean by ghc seeing the existing monadfail instance
13:08:27 <jle`> since it does see it
13:08:32 <jle`> that's why there is an overlapping instance error :O
13:08:45 <oats> jle`: if I remove my implementation, it cannot find a MonadFail instance for my type
13:09:15 <jle`> hm, what is the error?
13:09:21 <bifunctor35> https://stackoverflow.com/questions/59431359/default-extension-noimplicitprelude-does-not-work
13:09:32 <bifunctor35> would be nice, if someone could help me again
13:09:36 <oats>     • No instance for (MonadFail Identity)
13:09:38 <oats>         arising from a do statement
13:10:14 <jle`> ah, it finds the instance, but the constraints are not satisfied
13:10:30 <jle`> so it found the instance for Machine, but it sees that the MonadFail instance for Machine requires a MonadFail instance for Identity
13:10:38 <jle`> it's like how the Show instance for [Int] requires a Show instance for Int
13:10:46 <jle`> > show [id]
13:10:48 <lambdabot>  error:
13:10:48 <lambdabot>      • No instance for (Typeable a0) arising from a use of ‘show’
13:10:48 <lambdabot>      • In the expression: show [id]
13:10:53 <jle`> > show [id :: Int -> Int]
13:10:56 <lambdabot>  "[<Int -> Int>]"
13:11:02 <jle`> ah whoops that was a bad example
13:11:20 <nil> <jle`> we do have instance Monad m => MonadFail (MaybeT m) 
13:11:21 <jle`> but if you did something like that in GHC, the error wouldn't be "cannot find Show instance for [Int -> Int]", it would be "cannot find SHow instance for Int -> Int"
13:11:23 <nil> why the constraint?
13:11:33 <jle`> nil: probably because the implementation requires Monad m
13:11:34 <MarcelineVQ> bifunctor35: default-extesion: isn't spelled right, I've no idea why that isn't giving you an error itself though. look for something like "package.yaml: Ignoring unrecognized field $.default-extesion"
13:11:40 <oats> jle`: so even though the instance from transformers doesn't have its constraints satisfied, it doesn't like the overlap
13:11:42 <oats> hmm
13:11:45 <MarcelineVQ> as in idk why that's just a warning and not an error
13:11:53 <bifunctor35> ok
13:11:55 <nil> jle`: oh sorry, i read the constraint as MonadFail m
13:11:57 <jle`> oats: yeah, that's how typeclass constraints work
13:11:59 <bifunctor35> I am stupid
13:12:03 <nil> yeah, it's `fail _ = MaybeT (return Nothing)`
13:12:20 <oats> jle`: really feels like I should be able to create my own then in that case ._.
13:12:23 <jle`> oats: the constraint is on the "instance head", the constructors you can match on
13:12:39 <jle`> and then once it identifies the constructors, it goes to work on finding the constraints on the variables
13:12:51 <oats> if I make Machine a newtype instead of a synonym, will I be able to create my own instance?
13:13:01 <jle`> oats: it's tricky because what you are suggesting can breka the type system because of how typeclasses work
13:13:01 <bifunctor35> MarcelineVQ: Thanks a lot
13:13:09 <jle`> oats: yeah, making a newtype is the normal way of doing something like this
13:13:15 <oats> gotcha
13:13:17 <MarcelineVQ> np, that should really be an error, it's dumb that the tool ignores it
13:13:29 <oats> jle`, nil: thanks for the help
13:13:35 <oats> this was really confusing me :>
13:14:30 <jle`> oats: np :)
13:14:43 <nil> (i caused more confusion than help, lol)
13:14:51 <jle`> yeah, just remember, the thing is that the MonadFail instance is an instance for "all" StateT s m, not an instance for any specific s or m
13:15:14 <jle`> or, it is supposed to be
13:20:25 <bifunctor35> Does scotty support HTTP2
13:20:32 <bifunctor35> https://hackage.haskell.org/package/scotty
13:23:28 <rihardsk[m]> hi, what do people usually do when they have a REST API in Servant (if that matters), they have a GET endpoint from which they want to return a JSON object *with* an ID, and they have a POST endpoint to which they want to receive the same JSON object *without* the ID?
13:23:28 <rihardsk[m]> am i suposed to just duplicate the data types and do some name mangling with aeson so that they both serialize to the same thing? E.g., `data ItemGET = ItemGET { g_id :: String, g_name :: String }` and `data ItemPOST = ItemPOST { p_name :: String }`. or is there some less laborious alternative?
13:24:38 <rihardsk[m]> the reason is that the API generates the ID so the user shouldn't supply it in POST, but i want to return it to the user on GET requests
13:32:07 <lukelau> Is it possible to derive a ToJSON instance for the GADT Foo in this example, or at least write it without having to manually case iterate over all possible constructors? https://gist.github.com/351929e6059ec8d5932a05fcd2be95b8
13:32:30 <lukelau> My actual case for this has a GADT with 50+ constructors, and I would like to avoid manually writing out the ToJSON instance as much as possible
13:32:57 <phadej> ghat gist has a link, not a gadt
13:33:09 <lukelau> woops
13:33:21 <lukelau> https://gist.github.com/8b23263a99e7918f9e0fd4efc3efd57f
13:33:48 <phadej> take a look at https://hackage.haskell.org/package/aeson-gadt-th
13:34:36 <peterder72> good evening to y'all
13:38:42 <peterder72> i just started with haskell, and got a question to more experienced people
13:38:56 <peterder72> how long did it take you to feel confident in what you do in haskell?
13:39:29 <jle`> peterder72: hm, for me maybe a half year to a year?
13:39:38 <jle`> 6-12mo around
13:39:41 <jle`> it was a gradual process
13:40:05 <jle`> peterder72: it's sort of similar to the time it took you to get confident in your first programming language
13:40:09 <jle`> if you want a sense of scale
13:41:25 <koz_> I would say even more than that.
13:41:33 <koz_> But I suspect I'm a slow learner.
13:41:48 <lukelau> phadej: just tried it out, it seems to wrap things up in an array
13:42:11 <lukelau> I don’t want the json to be tagged at all
13:42:24 <lukelau> i.e. I don’t care too much for decoding
13:48:05 <jollygood2> I already have this $PSHOME\Microsoft.VSCode_profile.ps1
13:48:12 <jollygood2> wrong channel!
13:50:03 <peterder72> jle`, seems like an interesting process! I'm just theory + hello world level in, absolutely enjoying the concept of functional programming
13:50:16 <peterder72> And yes, it does seem like re-learning to program
13:53:39 <sm[m]> hmm.. I thought the Daedalus cryptocurrency wallet was built with haskell, but it seems all javascript except for the installer, am I right ? https://github.com/input-output-hk/daedalus
13:54:24 <sm[m]> excluding the cardano node itself, which I guess is bundled with it
13:59:23 <sm[m]> and on that topic, FYI the haskell-built Cardano cryptocurrency began live testing in true decentralised mode this week.. a pretty big milestone. Users have been notably positive about the rate of improvement of the software recently
14:00:45 <sm[m]> it was notable to me anyway. Haskell looked good.
14:01:31 <jle`> peterder72: glad you are enjoying the process so far :)
14:02:01 <jle`> peterder72: yeah, the major pitfall a lot of people run into is expecting to pick up haskell the same way they picked up their third or fourth language (which can often take as little as like a week)
14:02:10 <jle`> so managing expectations is an important thing
14:04:08 <peterder72> jle`, I initially started haskell as something entirely new, like a breeze of fresh air into a deep cave of c and assembly. And now I'm getting a hang of it :)
14:05:20 <peterder72> and do you you haskell a lot for normal day-to-day programming tasks?
14:05:45 <peterder72> for me this "normal" language has always been python
14:10:30 <evelyn> some of us grew up writing lisp :/
14:13:00 <sm[m]> hmm.. or maybe the current cardano testnet is rust-based, with the haskell one still coming. 
14:13:27 <hc> evelyn: what do you mean ":/"? lisp is a great language to grow up with :)
14:14:17 <sm[m]> https://www.youtube.com/watch?v=aVUU5EWuBQI 5:50: "rust for rapid experimentation, haskell for quality and stability"
14:16:52 <bifunctor35> which http-client library is recommended to use?
14:21:56 <dsal> I have had good luck with wreq
14:30:47 <ChaiTRex> :t nub
14:30:49 <lambdabot> Eq a => [a] -> [a]
14:34:25 <ChaiTRex> Is there a way of making nub work as it does for Eq types but for it to automatically work faster for Ord types through keeping an already-seen Set?
14:36:59 <monochrom> What would be the type of it?  Note that it could not be "Eq a => [a] -> [a]" and it could not be "Ord a => [a] -> [a]".
14:37:20 <ChaiTRex> It would be Eq a, but if the type was Eq a and Ord a, it goes faster.
14:37:47 <monochrom> No, free theorems bans "automatic detection of 'oh it's less general'"
14:38:29 <ChaiTRex> How are free theorems used? Why are they important to Haskell?
14:38:34 <monochrom> In very much the same way "foo :: a -> a" cannot say "foo 2 = 4, foo x = x for other types"
14:39:01 <ChaiTRex> Ahh, I see.
14:39:18 <monochrom> free theorems are a very formal way of saying "the implementer is never told what the actual type is".
14:40:28 <monochrom> the formal equations say that the implementer has to do type-indepedent things, i.e., uniformly over all types.
14:40:59 <monochrom> very indirectly but that's the gist.
14:41:19 <ChaiTRex> Yeah, but that's violated with...is it RULES or the old version of SPECIALIZE or something, isn't it?
14:42:05 <monochrom> it is SPECIALIZE. but IIRC for concrete types not subclasses.
14:42:41 <monochrom> you can possibly use SPECIALIZE for a=Int, then for a=Char, then...
14:43:44 <ChaiTRex> Why is it allowed for types but not whole subclasses?
14:44:10 <monochrom> that would be either insufficient demand or insufficient supply
14:44:10 <ChaiTRex> Does that prevent something in one case that's not a problem in the other?
14:44:16 <ChaiTRex> Ahh, I see.
14:44:44 <ChaiTRex> Thanks
15:10:31 <dsal> Why is Foldable  * -> *  ?  It seems to be inconvenient for reasons that aren't immediately obvious.
15:11:30 <dsal> Wait...  Set is Foldable.  I must be confused in a different way than I thought I was.
15:11:46 <matheus> Is there a function for [ [ x, y, z ], [ x', y', z' ], ... ] -> [ x <> x', y <> y', z <> z' ]? All the lists of the input have the same length, if that helps.
15:12:40 <ChaiTRex> matheus: You can probably fold.
15:12:52 <dsal> Oh, nevermind.  Set doesn't need to care that the values are ordered when folding.  I need an extra constraint on my type because I can't access values without Ix.
15:12:57 <ChaiTRex> matheus: Maybe with zipwith (<>).
15:12:59 <monochrom> Does it do [ [ x, y, z ], [ x', y', z' ], [x'', y'', z''] ] -> [ x<>x'<>x'', y<>y'<>y'', z<>z'<>z'' ] ?
15:13:06 <matheus> yeah
15:13:36 <monochrom> I think you can start with transpose to get [[x,x',x''], [y,y',y''], [z,z',z'']]
15:13:46 <dsal> Similar to array... `Array i` is foldable.  Lame.
15:15:21 <matheus> "map (sconcat . NonEmpty.fromList) . transpose" does what I'm thinking of
15:15:23 <matheus> thanks, monochrom
15:17:05 <monochrom> Does your element type have mempty?  Because "map mconcat" is much shorter :)
15:17:33 <matheus> it does not, unfortunately
15:28:09 <_deepfire> monochrom: might be worth mentioning how Typeable breaks free theorems..
15:28:30 <monochrom> Yeah!
15:29:28 <_deepfire> id :: Typeable a => a -> a -- isn't guaranteed to be (\x -> x) anymore..
15:29:36 <monochrom> "foo x = x+1 for Integer, foo x = x otherwise" can be done with "Typeable a => a -> a"
15:30:16 <monochrom> In PL literature, this is discussed under "typecase"
15:30:39 <_deepfire> curiosly it's called exactly "typecase" in Common Lisp : -)
15:31:07 <monochrom> Ah, someone stole someone's terminology!
15:31:40 <_deepfire> http://clhs.lisp.se/Body/m_tpcase.htm
15:32:05 <monochrom> but basically a PL textbook has a chapter on parametricity and its nice properties, then reminds you that typecase ruins it.
15:33:06 <monochrom> the formality and actual proofs are daunting, but the spirit of "free theorems iff no typecase" is easy to grasp.
15:33:35 <_deepfire> You could argue that type classes are essentially "typecond" (sequence of conditional tests, instead of outright equality)
15:34:10 <solonarv> except that with typeclasses you can't really observe a condition to be false
15:34:29 <_deepfire> well, true, but the non-uniformity is still there, regardless
15:34:43 <monochrom> type class is an interesting middle ground.  ingenious that Phil Wadler thought it up.
15:35:12 <evelyn> now he does blockchain... and stand-up
15:35:28 <_deepfire> Plutus, yeah..
15:35:41 <monochrom> because the criterion is "you have (<)" rather than "you are Int or Bool or Char"
15:35:56 <solonarv> yes, typeclasses are an interesting middle ground
15:36:18 <monochrom> to a large extent you dictionaryize your class constraint and you are free again
15:36:28 <ricky_clarkson> Wouldn't it have been thought up anyway? Even in Java I've done similar things, but named them FooMetadata<T extends Foo> and nobody seemed to wince.
15:36:36 <monochrom> "Ord a => [a] -> [a]" -> "(a -> a -> Bool) -> [a] -> [a]"
15:36:40 <solonarv> but I think the recent-ish proliferation of things like GND/DerivingStrategies/ApplyingVia shows that type classes are not really the best approach
15:36:46 <solonarv> ricky_clarkson: but in java you have typecase!
15:36:53 <solonarv> (instanceof)
15:37:02 <solonarv> so everything is ruined anyway and we have no free theorems
15:37:09 <_deepfire> monochrom: I'd say it's not "you have (<)" -- I'd rather say it's a series of pattern-matching instead of an equality test.
15:37:30 <_deepfire> jumbled sentence, sorry
15:37:34 <monochrom> Java got <T extends Comparable<T>> from the same Phil Wadler.
15:37:49 <solonarv> which is quite nice!
15:37:55 <ricky_clarkson> If I use instanceof, I'll change my username before committing.
15:38:31 <solonarv> but interfaces still have things they can't do: importantly, constructors/static methods
15:38:32 <monochrom> Actually you can't use instanceof on your T type.
15:38:48 <monochrom> Wadler was not easily fooled!
15:38:59 <solonarv> you can't check 'thing instanceof T', no
15:39:16 <_deepfire> No subtyping, huh? : -)
15:39:27 <amalloy> monochrom: usually it's <T extends Comparable<? super T>>
15:39:29 <ricky_clarkson> I can get a Class<T> as a parameter, but it's possibly more direct and reliable to accept a FooMetadata<T extends Foo>
15:39:30 <_deepfire> (in this particular subsection of the language)
15:39:31 <solonarv> but if you are implementing something that is generic over T and you have a 'T foo', you can do 'foo instanceof Whatever'
15:42:12 <ricky_clarkson> 10 years ago I blogged about doing typeclasses in Java, and since then I've done it exactly once in production, and have never been paid to write Haskell code :(
15:42:15 <ricky_clarkson> http://rickyclarkson.blogspot.com/2009/01/typeclass-pattern.html
15:43:39 <monochrom> This is why you should blog on Haskell instead. :)
15:44:20 <_deepfire> +1
15:44:30 <dsal> How proud of his java contributions is Wadler?
15:46:10 <monochrom> I think proud.
15:47:27 <monochrom> And I'm grateful too, people's mind got fixed because they now know "<T> T f(T)" is a stronger assertion than "Object f(Object)"
15:47:36 <_deepfire> It's also important to help people move from the other side of the imperativity continuum..
15:48:09 <_deepfire> imperativity-declarativity
15:48:22 <ricky_clarkson> Yeah, it's good that generics are everywhere now. Only the occasional language like Go pops up without them now.
15:48:39 <_deepfire> Go, I don't even..
15:49:27 <monochrom> https://twitter.com/mosheroperandi/status/856946180810354688
15:50:11 <ricky_clarkson> Holy UTF-8 Batman
15:50:24 <dsal> Eh, doing it with sed vs. doing it with the compiler.  *shrug*
15:52:41 <int-e> ricky_clarkson: It's worth noting that the reason Go has no generics is that the designers didn't come up with a design for them that they liked and it's one of the thing they really want to have in Go 2.0. e.g. https://go.googlesource.com/proposal/+/master/design/go2draft-generics-overview.md
15:53:06 <solonarv> oh, that is a much less dumb reason than what I had been assuming
15:54:09 <dsal> One of the reasons they kept the language simple was because compile times are just absurd in many other languages.   Haskell is pretty far on the other end of that part of the trade-off.  :)
15:54:24 <dsal> generics comparisons that don't mention haskell are weird to em.
15:54:44 <phadej> haskell is a research language no one uses ;)
15:55:02 <int-e> phadej: do you mean pascal?
15:55:11 <dsal> Well, if you're researching a language, I'd think you'd look at a research language.
15:56:02 <ricky_clarkson> Rust has similar goals to Go and just went straight off with an ML-based type system. I thought "we" had learned from Java 5 and C# 2 that adding generics later is difficult.
15:56:23 <dsal> Is the rust compiler fast at all?
15:56:31 <phadej> int-e: pascal should have been used more
15:56:35 <dsal> go in the wild compiles very fast relative to most other stuff I deal with.
15:57:07 <ricky_clarkson> For small things Rust seems fast but apparently it doesn't do incremental compilation very well/at all so it's difficult to scale to large projects.
15:57:08 <dsal> Someone in here was FFIing some haskell to like, Window C or something with pascal calling convention.  Pascal's ghost lives on, at least.
15:57:44 <dsal> go at work loses a lot of that benefit because you end up FFIng into some C++ and your linker ends up the bottleneck.
15:57:53 <monochrom> JVM is another Pascal ghost.
15:57:56 <dsal> the go code compiles fast.  But you still end up waiting.
15:58:08 <dsal> Is the JVM written in pascal?  I thought it was fortran or something.
15:58:15 <ricky_clarkson> C++
15:58:24 <monochrom> Just the idea of byte code VM :)
15:58:28 <int-e> phadej: Maybe. It's not really dead... if you count Delphi, which seems to be commercially successful still.
15:58:44 <dsal> I didn't know there were bytecode runtimes for pascal.  I never used it much.
15:58:48 <monochrom> There was one or several Pascal compilers compiling to "P-code" and using a VM to run it.
15:58:50 <phadej> fwiw, C++ is getting modules (reported 3x speed ups in compilation), and concepts (benefit in type-errors and also compilation speed)
15:58:53 <dsal> I was doing smalltalk stuff around the time I started doing java.  Had a pretty great vm.
15:59:09 <phadej> so C++ compilers are speeding up (given you are willing to rewrite your code)
15:59:18 <monochrom> Gosling et al. actually knew this and adopted this idea.
15:59:23 <phadej> int-e: is Delphi not dead?
15:59:36 <monochrom> oh w00t Delphi
16:00:23 <monochrom> (roast) You don't hear about Delphi on IRC because Delphi programmers actually have real jobs :)
16:00:53 <wildtrees> monochrom, I got something of what I wanted to do with "dependent" parsing working, using dependent sums https://0paste.com/45294 . the meat is in function parsePair
16:01:10 <wildtrees> thanks for your help with reasoning about the type of the codomain , it really helped 
16:01:32 <ricky_clarkson> I believe C++ can be fast to compile but you have to be very disciplined about dependencies to avoid monster files after #include expansion to make that happen
16:01:43 <ricky_clarkson> whereas Go doesn't need that discipline
16:02:10 <solonarv> textual include/templates is such a terrible approach
16:02:10 <phadej> ricky_clarkson: well, that's exactly where C++20 modules will help
16:02:38 <phadej> AFAIK they are in gcc/clang/msvc
16:02:48 <phadej> already in a state that you can use them
16:03:39 <phadej> ah, maybe I should retrain myself to be a Delphi programmer, could write mobile apps with it!
16:04:08 <int-e> phadej: It may be mostly a case of vendor lockin... the Borland tools have found their home at a company called Emarcardero which still develops the language (it has generics now, for example), libraries, and the tooling.
16:04:25 <phadej> http://docwiki.embarcadero.com/RADStudio/Rio/en/Overview_of_Generics <- I'm just reading that
16:04:42 <monochrom> Don't worry, I know about P-code because I played a bit with UCSD Pascal on Apple II.
16:04:44 <ricky_clarkson> [Object] Pascal got generics before Go, nice. :)
16:05:30 <monochrom> Oh great, "the next 700 pascals"
16:05:43 <int-e> phadej: And obviously there's a huge amount of room for languages between "popular, or well-known", and "dead" :)
16:06:16 <monochrom> Some people and languages become famous after they're dead.
16:06:26 <phadej> I hope that Haskell will stay somewhere in between for next few decades
16:08:44 <fen> whats cofree with with different types at the nodes than the leaves?
16:10:01 <fen> i can make it with a singletons either and a cofree that supplies a type level Left or Right... but this seems like overkill
16:13:31 <fen> it could be used to abstract over;
16:13:32 <fen> data NodeTree a b = Node a [NodeTree a b] | Leaf b
16:14:35 <fen> data ??? a b = Node a (f (??? f a b)) | Leaf b
16:14:50 <fen> type NodeTree = ??? []
16:15:03 <fen> what is this `???' datatype?
16:19:55 <phadej> ins't that Cofree (Product (Const b) f) ?
16:20:03 <phadej> sorry, Const a
16:20:32 <phadej> or Free
16:20:38 <phadej> I mess them all-thetime
17:29:33 <boxscape> hm, I wonder if there's anything surprisingly difficult about adding guards to type families
17:29:57 <boxscape> specifically closed type families
17:30:06 <boxscape> guards on open ones seem weirder, but maybe not
17:30:29 <boxscape> s/not/they aren't
18:30:45 <fen> now I have a problem that the "node tree" (tree with values at the branches) needs to be heterogeneous 
18:30:55 <fen> I dont know how to make the phanotm type arguments...
18:31:38 <fen> basically, each of the branches has a String (homegenous) but each of the leafs needs a different type arg
18:31:49 <fen> (heterogeneous) 
18:32:19 <fen> so then its like a tree but instead of having a list of branches it needs a HList
18:33:04 <fen> and then each of the args (type level list of types being the phantom type to HList) needs to be a tree of types!? (list of lists)
18:33:18 <fen> can anyone understand how to write that?
18:35:34 <fen> i guess it needs to be kind of combined with a type family to map over the type level args corresponding to the leaves 
18:35:47 <pavonia> If you can only have different types at the branches and leaves, you can just use two type parameters
18:36:38 <fen> i guess since the branches have values that are are all of the same type it might be easier just to consider the regular Tree and then extend it
18:37:28 <fen> pavonia: no the point is that each value at the leaves should be a different type, so the type parameter needs to be of kind Free [] *
18:37:53 <EvanR> for a tree with leaves of different types you need a tree of types for the type
18:37:57 <pavonia> Ah yeah, that makes it more complicated
18:38:03 <fen> and then to have a layer of this peeled off at each level going down in the tree
18:38:19 <fen> like kind of zipping the lists at each stage
18:38:40 <EvanR> what are you really trying to do though
18:38:43 <fen> EvanR: yeah, type Tree = Free []
18:39:31 <fen> EvanR: i am doing an linux style ls -r command, but where it has a different field of a Sum type for each different file extension
18:40:15 <EvanR> that doesn't seem to require heterotyped lists or trees
18:40:17 <fen> so the resulting datatype needs the tree of file extensions as its type parameter
18:40:24 <EvanR> all the results have an Extension field
18:40:50 <EvanR> "file type" may be a red herring
18:41:08 <EvanR> the file extensions don't really ensure anything about a file anyway
18:42:05 <fen> here was the code so far; https://pastebin.com/raw/HWqxdU6d
18:42:44 <fen> it was just to have all the files that were not .hs or .lhs be copied without editing, but to be able to refactor the hs files
18:43:14 <fen> so it would take a type parameter for if it was LHS, HS or Misc
18:44:27 <fen> seems like NodeTree needs to hetrogenous
18:45:28 <fen> maybe just HFree would be a good start, just not really sure how to write it... I guess it needs HList, ill write that, one sec
18:45:42 <EvanR> first of all
18:46:09 <EvanR> the results of ls aren't known until runtime
18:46:26 <fen> yeah they are just polymorphic until then
18:46:33 <EvanR> are you trying to write a parser to ensure a particular order of results
18:46:45 <fen> the type family mapped over them can take any of the options when they are determined
18:46:50 <EvanR> at which point you can apply the types
18:47:28 <EvanR> i guess i'll shut up and revert to "what are you really trying to do"
18:50:58 <fen> hang on, its faster to write the code first, then when the application is written it will be more obvious
18:51:15 <fen> otherwise the easierst way to describe it which is write in in code doesnt work because it doesnt typecheck
18:51:56 <fen> https://pastebin.com/raw/YSwhGDGq
18:52:22 <fen> thats HList and FList (the version which "maps" a type family over the hetrogenous contents)
18:52:36 <fen> I guess the HFree and FFree would need to be made of these somehow
18:53:04 <fen> but i cant figure out how to do the layer by layer construction ziping of the tree of args to the HLists at each layer
18:54:40 <fen> EvanR: what im really trying to do is write this FFree type... the application is just a test case more or less. I have tried to write this type a few times and not have not managed yet because it is confusing, so thought it would be worth asking here about
18:56:10 <fen> i guess HTree is actually easier because it doesnt need to abstract over the parametrised heterogeneous functor (!?)
18:56:32 <fen> like HFree would, where HTree = HFree HList
18:59:15 <fen> this is about as far as I can get; https://pastebin.com/raw/7jVSnHx4
19:03:23 <fen> hmm, this is almost it; https://pastebin.com/raw/KjC552Ld
19:04:27 <fen> Tree * has kind equal to * though right?
19:04:42 <fen> oh wait no, its confusing
19:06:04 <fen> does it need to be; 
19:06:55 <fen> so the type level list of types that is the parameter to the HList can be full of Trees of * instead of just *
19:13:59 <fen> if I just shuffle round the code until it compiles it ends up as;
19:13:59 <fen> https://pastebin.com/raw/A1Z3ZPJW
19:14:07 <fen> but I still cant understand it...
19:14:12 <fen> does that seem correct?
19:24:41 <monochrom> What does "understand" mean?
19:24:51 <Clint> when you stand under something
19:25:07 <glguy> It's before you stand it
19:25:18 <glguy> eventually you overstand it
19:25:23 <heatsink> It's the opposite of derstanding
19:25:56 <glguy> Are we playing https://en.wikipedia.org/wiki/Balderdash right?
19:28:10 <monochrom> Hmm, a player is assigned the role of "dasher".  So why is the game not called Balddasher?
19:28:31 <glguy> Presumably you don't lose your hair when you play
19:28:47 <monochrom> I think I would!
19:29:09 <glguy> In that case I'd call you a bladdasher for sure
19:29:20 <monochrom> "Why does player #6 supply a clearly fecetious definition! I'm pulling out my hair!"
19:31:54 <fen> seems ok
19:31:56 <fen> https://pastebin.com/raw/acKmr5xE
19:32:14 <fen> can make a HTree which seems to be what would be expected of such a thing
19:32:16 <glguy> We're in the AoC home stretch! I'm about ready to be done for the year :)
19:32:27 <fen> now HFree!?
19:34:10 <fen> what the heck is a hetrogenous functor!?
19:35:54 <fen> i guess it needs to be FFree, which kind of maps a datatype constructor which takes a type parameter (like a singletons thing for eg) to make it hetrogenous and then to fmap over that datatype...
19:36:29 <fen> otherwise your trying to fmap over several different types at the same time
19:36:39 <fen> maybe if they all satisfied the same constraint
19:37:35 <fen> I feel like this is going to end up being Biplate, which I have never nderstood and feel like I probably should
19:45:10 <fen> actually wait, isnt the point that its supposed to be able to be flattened to just a HList?
19:45:21 <fen> like, as a Monad with join....
19:45:26 <fen> "free monad"
19:45:39 <fen> so then whats the equivalent with a HFree monad?
20:23:14 <hololeap> i'm trying to write a class that shows a type `data t (x :: k)` has an existential wrapper `type ExWrapper t :: Type` and a constructor `exWrapper :: t x -> ExWrapper t`
20:25:18 <hololeap> but when i have something like `data Foo (s :: Symbol) where ...` and `data SomeFoo where ; SomeFoo :: KnownSymbol s => Foo s -> SomeFoo` it falls apart
20:33:57 <glguy> best to put actual code and error messages on the pastebin
20:39:10 <moet> hello! is there some way to enable `--enable-executable-dynamic` but for test suites?
20:39:16 <hololeap> here's the closest i've gotten: https://gist.github.com/f2c93f161439a74a6fc02cde42b2f752
20:45:33 <glguy> Try this: matchCode t = exWrapper @Symbol @KnownSymbol t <$ fromCode t
20:46:56 <hololeap> glguy: huh, yeah that works!
20:49:01 <hololeap> but where is the ambiguity coming from?
20:50:37 <glguy> Nothing was specifying that you meant KnownSymbol
20:51:10 <hololeap> well, i have `... KnownSymbol code => t code ...`
20:51:28 <glguy> no?
20:51:29 <glguy> err
20:51:30 <glguy> so?
20:51:39 <glguy> You can throw whatever constraints you want up there
20:52:28 <glguy> It doesn't matter what constraints are in scope when determining how exWrapper is being instantiated
20:53:47 <hololeap> hmm... i feel like i'm missing something here
21:03:06 * hololeap updated the gist
21:03:18 <hololeap> i feel like there is enough info there for the compiler to infer what `c` is for `exWrapper :: c x => t x -> ExWrapper`, since i have (HasExWrapper KnownSymbol t)
21:03:46 <hololeap> but i honestly don't know why i feel that way... :p
21:03:57 <hololeap> i guess i don't know the theory well enough
21:20:21 <zeta_0> i cloned ghc and built it using ghc.nix, so where is the compiler located so i can launch it? the ghc wiki says it should be located in `./inplace/bin/ghc-stage2` but i can't seem to find it?
21:22:26 <zeta_0> ok, think i found it, but it only has ghc-stage1
22:36:15 <jle`> i do feel like i need at least one more register to compile a CNF boolean expression
22:36:19 <jle`> ah, wrong window sorry
22:41:28 <pounce> i ok i have a lil problem. im trying to make a function count the number of elements matching soe element in an array, so i called this `countElems :: Eq a => a -> [a] -> Int`
22:41:57 <jle`> pounce: a reasonable goal :)
22:42:40 <pounce> so i started out with getting only the elements which match. so `filter . (==) :: a -> [a] -> [a]` is a good match
22:42:59 <pounce> but then i need to take the length of that and im not quite sure how to compose it with length that will take both curried arguments
22:43:14 <jle`> hm, not sure what constraints you are using
22:43:29 <jle`> but usually i'd just write countElems x xs = length (filter (== x) xs)
22:43:40 <pounce> ye that'd work
22:43:47 <pounce> is it silly to try to write it point-free?
22:43:59 <jle`> it might be readable to get rid of one of the points
22:44:04 <hololeap> :t toSing @Symbol
22:44:05 <lambdabot> error:
22:44:06 <lambdabot>     Pattern syntax in expression context: toSing@Symbol
22:44:06 <lambdabot>     Did you mean to enable TypeApplications?
22:44:09 <jle`> countElems x = length . filter (== x)
22:44:24 <jle`> but getting rid of all the points would make it completely unreadable imo
22:44:52 <pounce> oh, i didn't know that worked
22:44:55 <pounce> tyy lol
22:44:58 <hololeap> what was the way to get an interpreter in this channel besides ":t" ?
22:45:07 <jle`> yeah, \x -> f (g x) is the same as f . g
22:45:22 <jle`> and here we are doing \xs -> length ((filter (== x)) xs)
22:45:35 <jle`> imo i find the single-point version the most readable about of the three options
22:45:38 <pounce> i thought i tried writing a function with some points before and it didn't work but i think im just dumb
22:45:41 <pounce> yeah same thanks
22:45:51 <jle`> the one with all points is probably the easiest to write
22:46:28 <jle`> if you want the completely pointless version, there's @pl
22:46:37 <pounce> hmm
22:46:39 <jle`> @pl \x xs -> length (filter (== x) xs)
22:46:39 <lambdabot> (length .) . filter . (==)
22:46:54 <jle`> which i'm sure nobody would ever want :)
22:48:35 <pounce> tfw try to remove all the points but get more .s
22:49:49 <hololeap> not ":t"... i meant ">". isn't there another bot that provides an interpreter that has more modules imported and extensions enabled?
22:50:05 <jle`> hololeap: yahb has stuff too
22:50:09 <jle`> % putStrLn "hello"
22:50:10 <yahb> jle`: hello
22:50:30 <hololeap> thanks jle`
22:50:36 <hololeap> % :t toSing @Symbol
22:50:36 <yahb> hololeap: ; <interactive>:1:9: error: Not in scope: type constructor or class `Symbol'
22:50:56 <hololeap> % import GHC.TypeLits
22:50:57 <yahb> hololeap: 
22:50:59 <hololeap> % :t toSing @Symbol
22:51:00 <yahb> hololeap: ; <interactive>:1:1: error:; * Cannot apply expression of type `t1'; to a visible type argument `Symbol'; * In the expression: toSing @Symbol
22:51:25 <hololeap> toSing @Symbol :: Data.Text.Internal.Text -> SomeSing Symbol
22:51:42 <hololeap> is what's in my ghci. why this internal Text instead of String?
22:53:11 <suzu> import `Text` and it'll fix that
22:53:25 <suzu> that's because that's where the `Text` datatype is defined
22:53:32 <suzu> and it's a module that isn't in scope
22:53:55 <suzu> so it gives you the full, long, internal path to Text
22:54:00 <hololeap> i see
22:54:24 <suzu> so in ghci do :m +Data.Text and try again
22:54:34 <suzu> and the type will look proper
22:54:37 <hololeap> yeah i see that
22:55:39 <hololeap> i'm still a bit surprised by the choice of Text instead of String, considering that symbolVal still gives you a String. it seems like unnecessary conversion
23:01:41 <suzu> @instances SingKind Symbol
23:01:42 <lambdabot> Couldn't find class `SingKind Symbol'. Try @instances-importing
23:01:47 <suzu> @instances-importing SingKind Symbol
23:01:49 <lambdabot> Couldn't find class `Symbol'. Try @instances-importing
23:01:52 <suzu> hm
23:03:02 <hololeap> @instances-importing Data.Singletons.TypeLits
23:03:04 <lambdabot> Couldn't find class `Data.Singletons.TypeLits'. Try @instances-importing
23:03:14 <hololeap> % import Data.Singletons.TypeLits
23:03:14 <yahb> hololeap: ; <no location info>: error:; Could not find module `Data.Singletons.TypeLits'; It is not a module in the current program, or in any known package.
23:04:11 <suzu> @type Demote Symbol
23:04:13 <lambdabot> error:
23:04:13 <lambdabot>     Data constructor not in scope: Demote :: t0 -> t
23:04:13 <lambdabot> error:
23:04:33 <suzu> what's the type of that in your ghci?
23:04:56 <suzu> % import Data.Singletons
23:04:56 <yahb> suzu: ; <no location info>: error:; Could not find module `Data.Singletons'; It is not a module in the current program, or in any known package.
23:05:03 <suzu> @import Data.Singletons
23:05:03 <lambdabot> Unknown command, try @list
23:05:06 <suzu> @list
23:05:06 <lambdabot> What module?  Try @listmodules for some ideas.
23:05:28 <hololeap> suzu: type instance Demote Symbol = Text
23:05:42 <suzu> guess it was a deliberate choice
23:05:50 <suzu> and isn't OverloadedStrings doing something funny
23:06:02 <hololeap> usually
23:07:31 <hololeap> how would i search for a type instance in ghci? for that i just did `:i Demote` and read through the list
23:08:43 <suzu> :t Demote Symbol would work
23:08:44 <lambdabot> error:
23:08:44 <lambdabot>     Data constructor not in scope: Demote :: t0 -> t1 -> t2 -> t
23:08:45 <lambdabot> error:
23:08:49 <suzu> or :k! Demote Symbol
23:09:12 <hololeap> :k gives Demote Symbol :: *
23:09:13 <lambdabot> error: parse error on input ‘::’
23:09:41 <hololeap>   :t Demote Symbol complains that Demote isn't a data constructor
23:10:03 <hololeap> (or Symbol)
23:11:08 <suzu> try :kinds!
23:11:12 <suzu> err :kind!
23:11:18 <suzu> :kind! Demote Symbol
23:11:21 <suzu> like that
23:11:57 <hololeap> Demote Symbol :: * = Text
23:12:11 <suzu> yep, there's the answer
23:12:19 <hololeap> what does the '!' do?
23:12:30 <hololeap> oh, i see it in the help
23:12:38 <hololeap> (!: defer type errors)
23:12:48 <suzu> prints the normalised type
23:12:55 <suzu> as well as printing the kind
23:12:59 <hololeap> oops... (!: also print the normalised type)
23:13:08 <suzu> so the kind is *, and the normalized type is Text
23:13:52 <hololeap> and normalized type just has to do with type families?
23:14:43 <suzu> yeah, it fully applies the type down
23:14:59 <suzu> so rather than saying Demote Symbol = Demote Symbol, it evaluates it down to Text
23:16:10 <hololeap> alright. good to know
23:20:49 <ullbeking> Does anybody here know of any efforts to use Cloud Haskell on a cluster of ARM SBC's, e.g., an RPi comoute cluster?
23:22:35 <suzu> i think the last time haskell worked on arm it was 7.8.6
23:22:37 <suzu> ghc
23:23:57 <hololeap> that's surprising... isn't arm like the second most used architecture besides x86-64?
23:44:54 <lavalike> I just installed ghc 8.8.1 on an arm pinebook pro two weeks ago!
23:59:55 <DigitalKiwi> i have ghc 8.4.4 (i think, possibly newer, can't check right now) on my rpi
