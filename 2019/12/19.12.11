00:02:13 <maybefbi> Imagine if Java did not have static System.out and you had to dependency inject or autowire the PrintStream inside objects we needed them in. Now imagine no nulls and Optional<T> instead everywhere. Aside from higher kinded polymorphism which provide default implementations, such a Java is almost like Haskell already.
00:05:52 <svipal> what am I reading
00:06:02 <tdammers> maybefbi: IME, Java's mandatory pass-everything-as-mutable-references convention is just as harmful as the everything-is-nullable thing
00:06:38 <maybefbi> haskell has mutable references in IO too. but i agree we can make things immutable like String is alreday
00:06:43 <maybefbi> *already
00:06:45 <tdammers> foo(bar); // we have to expect bar to have been manipulated inside that call
00:06:58 <svipal> Scala has Option[Type] everywhere, parameter groups for partial applications, but it doesn' t feel like Haskell imo
00:07:20 <tdammers> haskell has mutable references in IO, but 1) you can only mutate them within IO, and 2) they are opt-in, if you don't use one of the mutable types, things are immutable by default
00:07:54 <tdammers> oh, and maybe this isn't obvious, but it should be: option<a> and nullable a are not isomorphic. optionals can nest, nullables can't.
00:08:06 <Ariakenom> type inference is also an important difference
00:08:06 <tdammers> there is no nullable equivalent of Just Nothing
00:08:19 <tdammers> Ariakenom: type inference is mostly an ergonomics thing
00:08:31 <maybefbi> hehe yeah. dint think of that Optional<Optional...
00:08:37 <Solonarv> also, haskell *has* static System.out
00:08:53 <tdammers> Ariakenom: you can still write the same code if you have to annotate everything, it's just annoying
00:09:01 <Solonarv> % :t System.IO.stdout
00:09:02 <yahb> Solonarv: Handle
00:09:55 <Ariakenom> technically yes. I still consider it an important difference. it is a lot nicer
00:09:56 <tdammers> Solonarv: yes. one advantage we have in Haskell, though, is that we can construct our own application monads that hide general IO from most of our application code
00:10:04 <tdammers> Ariakenom: oh, defs
00:10:23 <tdammers> Ariakenom: it's just nowhere near as much of a show stopper as nullability or mandatory mutability
00:11:53 <tdammers> appMain :: (MonadDatabase m, MonadLogging m, MonadHTTP m) => m () -- look Mom, no IO
00:12:28 <Ariakenom> I suppose we havent included typeclasses. but with those we'd have to annotate each + right?
00:13:29 <tdammers> Ariakenom: we're talking about a hypothetical language here; a polymorphic + and polymorphic numeric literals in a language without type inference would indeed be cumbersome
00:14:04 <Ariakenom> yes I was about to say. literals would be the worst.
00:14:31 <tdammers> point in case, most languages don't overload numeric literals
00:14:47 <tdammers> C cheats a little by injecting implicit conversions
00:15:39 <Ariakenom> in C-esque languages 3 has the exact type int and the rest of the expressions types flows _from_ that
00:17:06 <Ariakenom> ex char c = 3; is an int casted to a char
00:21:02 <tdammers> it's a bit more complicated
00:21:20 <tdammers> 3 + 3.0 // is what type exactly>
00:22:58 <maybefbi> tdammers: if we are going to create an App monad that has all the features of every monad ever, and then use :: (...) => to select only sometypes of monadic behavior inside functions. that is like dependency injection in Java
00:23:28 <Solonarv> it is "like dependency injection" in the sense that it solves a similar problem, yes
00:23:28 <tdammers> maybefbi: not all the features of every monad ever. just the exact operations our app needs
00:23:29 <maybefbi> we are reducing what behaviors are possible within a certain context
00:23:49 <tdammers> it is trivially dependency injection in the sense that everything in haskell is
00:23:59 <tdammers> or well, almost everything
00:24:33 <tdammers> because you can't have mutable globals (at least not in a way that doesn't involve the dark side)
00:24:33 <Solonarv> % let thingy f = do f "hello"; f "world"
00:24:34 <yahb> Solonarv: 
00:25:04 <Solonarv> % let { thingy :: Monad m => (String -> m ()) -> m ()); thingy f = do f "hello"; f "world" }
00:25:05 <yahb> Solonarv: ; <interactive>:3:52: error: parse error on input `)'
00:25:11 <Solonarv> % let { thingy :: Monad m => (String -> m ()) -> m (); thingy f = do f "hello"; f "world" }
00:25:11 <yahb> Solonarv: 
00:25:17 <tdammers> so yeah, we "inject dependencies" in haskell all the time, we just prefer to call it "passing arguments to a function"
00:25:37 <Solonarv> % thingy putStrLn -- oh look, dependency injection, complicated1
00:25:38 <yahb> Solonarv: hello; world
00:25:46 <tdammers> :t hPutStrLn
00:25:48 <lambdabot> error:
00:25:48 <lambdabot>     • Variable not in scope: hPutStrLn
00:25:48 <lambdabot>     • Perhaps you meant one of these:
00:25:59 <tdammers> @let import System.IO
00:26:00 <lambdabot>  Defined.
00:26:01 <tdammers> :t hPutStrLn
00:26:04 <lambdabot> Handle -> String -> IO ()
00:26:18 <tdammers> ^ the "Handle" is a dependency that we're "injecting" here
00:26:33 <Solonarv> and *because* we can just pass functions without some big ceremony and do it all the time, we mostly do not feel the need to slap a fancy label like "dependency injection" on it
00:26:53 <maybefbi> hmm
00:27:21 <tdammers> like many "design patterns", "dependency injection" is stupid obvious in haskell and doesn't even deserve a proper name
00:27:32 <maybefbi> yeah
00:27:39 <tdammers> or take the "visitor pattern"
00:29:01 <tdammers> in haskell, the "visitor" is just a function, and the thing being visited is a function that takes the visitor as an argument
00:29:17 <tdammers> you could say that this is an example of the visitor pattern:
00:29:27 <tdammers> % mapM_ print [1..10]
00:29:27 <yahb> tdammers: 1; 2; 3; 4; 5; 6; 7; 8; 9; 10
00:29:48 <tdammers> print is our "visitor", and the [1..10] list is the data structure being "visited"
00:30:23 <tdammers> print doesn't care what it is that it visits, it just takes an argument and prints it; the visitation mechanism, mapM_, doesn't care what the visitor does, as long as it takes the right kind of argument
00:30:46 <maybefbi> separation of algorithm and data structure
00:31:54 <maybefbi> so in haskell it seems like design patterns emerge from more fundamental language design decisions, and require no explcit gang of fours to tell us what to do
00:32:40 <tdammers> frankly, I've always thought that "design patterns" are just the logical consequence of applying common sense to programming
00:32:41 <maybefbi> but there is still discussion of antipatterns over more trivial things
00:32:52 <maybefbi> like why exceptT is bad
00:33:08 <maybefbi> and how it restricts what exceptions can be thrown
00:33:09 <tdammers> it's just that OOP languages tend to obscure these things more, and require more ceremony to do the right thing
00:33:25 <tdammers> ExceptT is bad? How so?
00:34:01 <maybefbi> tdammers: https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell
00:34:15 <maybefbi> myFunction :: String -> ExceptT MyException IO Int
00:36:11 <Ariakenom> tdammers: 3 + 3.0 = ((double)3) + 3.0; 3.0 is a double and 3 is an int that is then implicitly casted
00:37:09 <Solonarv> ExceptT *over IO* is misleading because IO already has exceptions, so you have two "layers" that provide throwing/catching/handling exceptions
00:39:13 <maybefbi> ok but having design pattern debates about ExceptT when we just established Haskell doesnt need such conventions because they trivially emerge from haskell constructs
00:39:58 <maybefbi> seems to point to the idea that because we made dependency injection and visitor pattern trivial we instead have to discuss how to do exceptions
00:40:05 <Solonarv> ExceptT is not a "design pattern" any more than (say) a hashmap is a design pattern
00:40:05 <f-a> that might or might not have been oversold maybefbi :P
00:40:14 <maybefbi> noted
00:40:44 <maybefbi> anyways im already sold on haskell. im just armchair philosophizing
00:40:51 <Axman6> ExceptT + classy prisms = typed exceptions with visible scope
00:41:39 <Axman6> getFromDatabaseAndSendToSQS :: (AsDatabaseError e, AsSQSError e) => ExceptT e IO Result
00:43:15 <Ariakenom> perhaps more unknown would be unsigned char a = 128; a+a+a = a; if unsigned char overflows at 256, is that expression true?
00:43:47 <Ariakenom> a+a+a==a I mean
00:44:19 <f-a> maybefbi: this might interest you https://markkarpov.com/post/the-monads.html
00:44:39 <maybefbi> f-a: checking
00:50:24 <maybefbi> f-a: liked it.
00:50:54 * f-a nods
00:51:55 <maybefbi> Solonarv: any constraint that has to be imposed by programmers preaching and bullying programmers is a design pattern.
00:52:33 <maybefbi> Solonarv: if we have to preach the evils of ExceptT to cheap programmers from india then we are preaching design patterns.
00:53:32 <maybefbi> im on the lookout for systems that will not work if the best practices are not followed
00:54:21 <maybefbi> its ok if they dont exist
00:54:34 <maybefbi> or are impossible
00:57:41 <bahamas> the "text" package's readme says: "An efficient packed, immutable Unicode text type...". does packed refer to memory like it's described here: https://forums.alliedmods.net/archive/index.php/t-90735.html?
00:58:08 <jpcooper> I have defined an instance of an open type family F which relies on an associated type CT of another type class C. This requires UndecideableInstances, as I am mapping a general type t to X (CT t), where X is another type family. Is there any way I can help the type checker a bit? I would like to enforce that the instance is defined only for t which satisfy C t. As far as I understand, I cannot define an instance of the type family F
00:58:08 <jpcooper> inside an instance definition of another class
01:00:40 <jpcooper> I will give context: the type family CompareTypes in https://github.com/jpcooper/generic-type-ordering/blob/master/src/Data/Type/Ordering.hs relies on the associated type family Rep of the class Generic, but CompareTypes is defined over all types (m :: *) and (n :: *)
01:01:26 <Ariakenom> bahamas: it is chunks of utf16. which has no padding afaik
01:02:21 <bahamas> Ariakenom: I was more curious if "packed" means memory efficient. I'll take your answer as a "yes"
01:02:40 <bahamas> I haven't met the term "packed", so that's why I'm asking
01:02:57 <ammar2> bahamas: it's a similar notion to that thread, yeah
01:03:26 <ammar2> the packing refers to the fact that all of the text is in one blob of memory rather than a bunch of different objects like [Char]
01:03:31 <ammar2> I think
01:03:39 <Ariakenom> the text description reads "The Text type represents Unicode character strings, in a time and space-efficient manner"
01:05:33 <bahamas> ok, thank you.
01:05:50 <dminuoso> bahamas: Another not so obvious implication is that you get far better locality of reference
01:06:22 <dminuoso> So things like text will have better cache and CPU prefetching characteristics
01:06:32 <Ariakenom> its not important but that post uses packed to mean something different. the following is not true of text   "A packed string can only hold characters from a single-byte character set, such as ascii or one of the extended ascii sets
01:06:32 <Ariakenom> "
01:07:25 <ammar2> yeah...that post is very specific to SourceMod and its language SourcePawn
01:07:36 <ammar2> don't read into it much beyond the efficient memory-usage part
01:08:00 <Ariakenom> yeah the post probably use packed and unpacked to refer to 2 specific string implementations rather than anything general
01:08:07 <bahamas> yeah, I just wanted to know what packed/unpacked means
01:08:31 <bahamas> there's another term I see a lot that I don't understand: boxed/unboxed. an example here https://hackage.haskell.org/package/text-1.2.4.0/docs/Data-Text-Array.html
01:09:35 <dminuoso> bahamas: packed/unpacked have no clear well defined meaning.
01:09:40 <merijn> bahamas: So, consider the following problem: I want to compile a function like "id :: a -> a"
01:09:50 <dminuoso> bahamas: Consider every usage to have some implicit definition that might vary from place to place.
01:10:03 <merijn> bahamas: id works on any datatype, however different datatypes have different sizes, so how do I generate assembly for that?
01:10:16 <merijn> bahamas: There are, effectively, only 2 solutions to that problem
01:10:40 <merijn> bahamas: 1) generate different code for every use of 'id' (which bloats the size of generated code)
01:10:42 <Maxdamantus> I can think of three.
01:10:56 <merijn> bahamas: 2) make sure everything has the same size and just use the same code for everything?
01:11:04 <merijn> Maxdamantus: Now I'm curious what your third solution is :p
01:11:12 <Maxdamantus> 3) pass the size of the argument
01:11:35 <merijn> Maxdamantus: That works in the simple case of 'id', but might not work in general
01:12:28 <merijn> bahamas: The simplest way of implementing (2) is "never pass things by value, just pass a reference/pointer to values instead"
01:12:46 <Maxdamantus> merijn: I think it should work in general. You might need to also pass the alignment if your system cares about that. It does mean that type-level functions might turn into actual functions that transform size/alignment.
01:12:55 <Ariakenom> dminuoso: it refers to if there's padding or not.
01:13:07 <merijn> bahamas: This is usually referred to as "boxing" as you stuff all values into a box with a fixed size (i.e., a pointer)
01:13:56 <merijn> bahamas: This is, for example, also what distinguishes Java objects from its primitive types (int, char, etc.) Java objects are boxed (passed by reference, and therefore allowed inside generic datatypes) and int (unboxed, can't be put inside generic containers)
01:14:24 <Maxdamantus> er, the references are passed by value.
01:15:01 <merijn> bahamas: The downside of course is that boxing incurs additional indirections which can hurt speed, so you have (for example) in GHC (and also javacc) a strictness analyser that will try to detect repeated unboxing/reboxing and turn it into unboxed code (which is faster due to less indirections)
01:15:06 <Maxdamantus> to put it simply: boxing is just when you use a pointer to an object that stores the value, instead of just passing around the value directly.
01:15:12 <absence> i saw some articles that recommended using the async library instead of forkIO. "race" and "concurrently" are certainly quite useful in many cases, but what do i do if i don't want to wait for a thread?
01:15:32 <tdammers> Maxdamantus: what's a reference then, other than a (somewhat) type-safe managed pointer?
01:15:36 <merijn> absence: You can simply fork an async without ever waiting for the result
01:15:45 <tdammers> Maxdamantus: "pass by reference" and "pass a reference by value" is the same thing
01:15:58 <merijn> absence: The main reason to use async is that detecting errors in threads you spawn is tricky business
01:16:09 <Ariakenom> absence: look at withAsync
01:16:18 <Maxdamantus> tdammers: I didn't mean to distinguish between references and pointers, I just meant to point out that "pass by reference" is very much the wrong way to describe Java.
01:16:37 <Maxdamantus> "pass by reference" already has an established meaning which is quite different to "passing a reference" or "passing a pointer".
01:16:46 <jpcooper> merijn: You may be interested about the Road to Valhalla: http://cr.openjdk.java.net/~briangoetz/valhalla/sov/01-background.html
01:17:06 <dminuoso> Ariakenom: Sure. Im merely saying that two people using the words "packed" and "unpacked" in different conversation might have different notions for the wordl.
01:17:18 <merijn> bahamas: C++ templates, for example, take the other road and duplicate/reinstantiate "generic" code for each type you use
01:17:33 <Maxdamantus> "pass by reference" basically means where a function is able to change the value of a variable denoted in the call site. Instead of the variable being evaluated to the value and that value being passed, a reference to the variable itself is somehow passed.
01:18:13 <Maxdamantus> eg, in C++ you can do something like: `int x = 4; foo(x);` and `foo` will be able to modify `x` if `foo` is denoted as having its first argument passed by reference.
01:18:17 <merijn> Maxdamantus: this distinction is entirely irrelevant to the entire conversation, which had the point of explaining boxed/unboxed, not subtle details of java's semantics
01:18:37 <Ariakenom> dminuoso: definitely. but it isnt entirely vague :)
01:18:40 <Maxdamantus> merijn: sure, just wanted to clarify though that "pass by reference" already means something else.
01:20:04 <absence> Ariakenom: hmm. it looks like the return value of withAsync depends on the result of the handler function. can the program really continue before withAsync finishes?
01:20:22 <absence> merijn: what do you mean by forking an async?
01:20:30 <bahamas> merijn: Maxdamantus so an unboxed array is more efficient space wise or also time wise?
01:20:58 <merijn> absence: async just spawns a thread via forkIO
01:21:07 <Ariakenom> absence: well the continuation of the program is the argument. are you familiar with "with" in haskell or python?
01:21:13 <merijn> bahamas: Most likely both
01:21:40 <Maxdamantus> bahamas: it depends. It might actually be worse in both cases, particularly with arrays.
01:21:42 <ammar2> bahamas: potentially...every time you tried to get an element in a boxed array, you'd incur the overhead of opening the box
01:21:48 <merijn> bahamas: A boxed array of Int is an array of "pointers to actual ints" which means each access goes through 2 indirections (array + boxed pointer)
01:22:01 <absence> Ariakenom: i'm familiar with "with" for reading files and stuff like that. i don't think that pattern will work here, because if i understand correctly, the thread has to finish before the with call completes
01:22:04 <merijn> bahamas: Unboxed array of Int is an array of actual Int values, which means only 1 indirection
01:22:18 <merijn> bahamas: Additionally, getting rid of the indirection leads to better cache behaviour
01:22:18 <Maxdamantus> bahamas: eg, if you have a large unboxed array, you would potentially be copying that entire array when passing, instead of just passing copies of a pointer to the same array object.
01:22:46 <merijn> Maxdamantus: Eh, unboxed array/vector generally refer to an array/vector *containing* unboxed values, not the array itself being unboxed :)
01:22:47 <absence> merijn: so i can just "async myAction" and forget about it?
01:22:51 <Ariakenom> absence: ok yes
01:23:01 <merijn> absence: Well, what should happen if myAction crashes?
01:23:04 <dminuoso> absence: Well you should probably check for exceptions at some point.
01:23:34 <absence> ah right, they can't be automatically propagated to the parent thread without me checking for them
01:23:37 <Ariakenom> it does limit the life of the thread to the IO argument. so it only fits that pattern
01:23:41 <dminuoso> absence: Sure they can.
01:23:52 <merijn> absence: Async lets you control that sort of thing :)
01:23:54 <dminuoso> Ariakenom: Check the section `Linking` as well as the section `Waiting`
01:24:00 <dminuoso> absence ^-
01:24:10 <merijn> absence: Which is why it's recommended over using forkIO directly
01:24:13 <dminuoso> absence: Both provide mechanisms to deal with this.
01:24:43 <dminuoso> absence: Also `withAsync` is a particularly interesting utility
01:25:05 <dminuoso> absence: Because there's another edge case not mentioned: asyncs left running unintentionally
01:25:41 <Ariakenom> Maxdamantus: if you pass a list into a function in Java you can change the list. I think your example is special because Integer is immutable. at least thats the case in python
01:25:44 <absence> ack, i have to run to a meeting, but this linking stuff looks interesting, unless i can refactor to use withAsync
01:25:54 <absence> thanks a bunch for the pointers
01:26:03 <absence> i'll read more about it afterwards
01:26:04 <dminuoso> absence: linking and withAsync are somewhat opposite
01:26:27 <merijn> bahamas: This is why, for example, Vector.Unboxed incurs an Unbox constraint on the element type and can't be used for just anything, whereas regular Vector (which is boxed) can store basically anything, for it gets to be Traversable, etc.
01:26:28 <Maxdamantus> Ariakenom: the reason you can change the list is because the list is not contained in a variable. It is contained in some object that might be pointed to by the value in a variable.
01:26:30 <dminuoso> absence: linking is about what happens if the async fails prematurely with an exception, withAsync is rather about cleaning up Asyncs in the right places.
01:27:03 <Ariakenom> Maxdamantus: I dont think that is different from a variable pointing to an int object
01:27:11 <Maxdamantus> Ariakenom: the important thing is that in Java when you call `foo(x)`, it is evaluating that `x` expression to a value and passing that value.
01:27:30 <Maxdamantus> Ariakenom: so eg, `{ foo(x); }` in Java is equivalent to `{ var y = x; foo(y); }`
01:27:46 <Maxdamantus> Ariakenom: those would be different in a call/pass-by-value setting.
01:28:43 <Maxdamantus> Ariakenom: eg in C++ if you have `void foo(int &x){ x++; }`, `foo(x);` does *not* evaluate `x` to a value.
01:29:08 <Maxdamantus> Ariakenom: and so `{ foo(x); }` is not the same as `{ int y = x; foo(y); }` there.
01:29:42 <ammar2> Ariakenom: I think an easier to understand example might be: "Object x = new Object(); foo(x)", foo can do whatever it wants to the actual object, but it couldn't for example make x a null pointer after its execution
01:29:56 <dminuoso> Maxdamantus: How does that relate to changing lists? The argument here is not really about boxed vs unboxed. If you have a boxed vector or ints and you want to update the first element, you have to copy the entire list anyway
01:30:03 <Maxdamantus> Ariakenom: note that given `void foo(int &x){ x++; }` in C++, it is invalid to write `foo(4)`
01:30:28 <dminuoso> Maxdamantus: That is, the reason why list can do cheap updates without full copying is not because of boxing/unboxing, but because the spine *itself* uses boxing.
01:30:31 <Maxdamantus> dminuoso: I think it's just about the meaning of pass-by-reference.
01:31:13 <dminuoso> Maxdamantus: I was referring to this statement: "10:26:06 Maxdamantus | Ariakenom: the reason you can change the list is because the list is not contained in a variable. It is contained in some object that might be pointed to by the value in a variable."
01:31:58 <Maxdamantus> dminuoso: right, and that was in response to something about Java, where a list variable is really just holding a pointer value.
01:32:18 <dminuoso> Maxdamantus: But that's mutation vs non-mutation then.
01:32:22 <Maxdamantus> dminuoso: a list variable (eg, `List<String> a;`) in Java does not contain a list.
01:32:26 <Ariakenom> yes I see. that's right. it's been too long since I was in the wondrous world of c++
01:33:22 <Maxdamantus> dminuoso: immutable lists are not really treated differently in this sense.
01:34:02 <Maxdamantus> dminuoso: until Java has its "value types" functionality, a variable can only hold a pointer, or some number/boolean value.
01:34:24 <dminuoso> 10:21:56 Maxdamantus | bahamas: eg, if you have a large unboxed array, you would potentially be copying that entire array when passing, instead of just passing copies of a pointer to the same array object.
01:34:32 <dminuoso> Maxdamantus: ^- can you elaborate how that connects to this statement?
01:34:37 <bahamas> merijn: ok. so having a container of unboxed types gives you the benefit of reducing the level of indirection. this brings its own benefits. the downside is that it can hold fewer types than a boxed container
01:34:52 <dminuoso> Maxdamantus: Oh! You meant the an boxed array in the sense that the array itself was unboxed?>
01:35:04 <Ariakenom> Maxdamantus: thanks
01:35:15 <Maxdamantus> dminuoso: right, I guess "unboxed array" already means something else in Haskell.
01:35:20 <Ariakenom> ammar2: good example
01:35:33 <dminuoso> Maxdamantus: Okay that explains my confusion. Nevermind. :)
01:35:35 <Maxdamantus> I was thinking more of something like a statically-sized array, which could be unboxed.
01:35:49 <Maxdamantus> (as you would expect in Go for example)
01:36:21 <dminuoso> Maxdamantus: Well that'd be a compiler optimization though, wouldn't it?
01:36:25 <merijn> bahamas: Right
01:36:59 <dminuoso> Maxdamantus: At least in GHC we can talk about boxing and unboxing as sort of being implementations for lazyness.
01:37:01 <merijn> Maxdamantus: Well, you can have those too, but they're less commonly used and more in -XMagicHash territory so that's not usually what you'd talk about/refer to :)
01:37:03 <Maxdamantus> dminuoso: sure, the compiler could try and optimise it so it doesn't copy large values, but there's some heuristic involved there.
01:37:26 <dminuoso> Maxdamantus: There's a particularly interesting case of ByteArray#
01:37:35 <dminuoso> Maxdamantus: Which in GHC Haskell is both boxed but unlifted.
01:37:48 <dminuoso> So its not lazy, cant contain bottom, but its boxed
01:37:54 <ammar2> merijn: where on the "box everything" vs "duplicate everything" spectrum does GHC live in general?
01:38:01 <dminuoso> (Because the ByteArray# has to exist on the heap)
01:38:26 <merijn> ammar2: GHC does "box everything" but there is support for writing unboxed code directly if you want
01:39:03 <merijn> ammar2: In fact, the STG paper talks quite a bit about how to support both boxed and unboxed code in the same compiler :)
01:39:14 <Solonarv> and optimizations can eliminate unnecessary un/re-boxing, too
01:39:23 <merijn> ammar2: But all the unboxed stuff isn't "standard" Haskell
01:39:33 <dminuoso> I think GHC has support for passing things as immediates in registers too, right?
01:39:37 <merijn> Yeah, the strictness analyzer will unbox Int if it can
01:39:40 <dminuoso> (Things that would, otherwise, be boxed)
01:39:53 <Solonarv> e.g. if you write foo a b c = a * (b + c) :: Int
01:40:13 <merijn> ammar2: If you like low level details like this I can highly recommend taking a stroll through the ghc-prim documentation :)
01:40:38 <Solonarv> this will compile to basically the same code as: foo (I# a#) (I# b#) (I# c#) = I#( a# *# (b# *# c#))
01:40:56 <merijn> ammar2: Which will show, for example, that Int is a boxed datatype defined as "data Int = I# Int#" (i.e. a wrapper around an unboxed Int#)
01:41:18 <merijn> @hackage ghc-prim
01:41:18 <lambdabot> http://hackage.haskell.org/package/ghc-prim
01:41:25 <Solonarv> er, the second *# should be a +# of course
01:42:19 <ammar2> merijn: Solonarv: aah, thank you!
01:43:01 <Ariakenom> Solonarv: + * isnt strict though? so that doesnt look right
01:43:14 <merijn> ammar2: Despite popular propaganda on the safety of Haskell, if you want to write "basically C" and don't mind being GHC specific, you can easily enough ;)
01:43:28 <Solonarv> really, they are not strict even on Ints?
01:43:32 <merijn> ammar2: ghc-prim has lots of neat stuff, primitive byte arrays, SIMD/vector instructions
01:43:39 <merijn> Ariakenom: + and * are strict
01:43:39 <Solonarv> I thought they would be strict
01:43:51 <merijn> Ariakenom: How could they not be
01:44:07 <Solonarv> I suppose * could be non-strict in one argument when the other is 0
01:44:10 <ammar2> is the reason that GHC implements Haskell through boxing that "duplicate everything" would be significantly worse in a language like Haskell where the same functions are applied to different types all the times?
01:44:19 <ammar2> s/that/rather than/
01:44:36 <Ariakenom> uh yeah im not making sense
01:45:06 <ammar2> or are there Haskell implementations out there that do specialize `id` for every type? :)
01:45:06 <merijn> ammar2: I think there's several reasons, one of which is "making everything boxed makes a lot of things much simpler"
01:45:18 <Solonarv> for example you can easily define recursive data types
01:45:34 <merijn> ammar2: The main problem of not doing boxing is with modules/libraries
01:45:48 <merijn> ammar2: Suppose package foo defines a polymorphic function that I wanna use in my code
01:45:53 <ammar2> merijn: aah yeah, you don't know in advance all the usages
01:46:02 <Ariakenom> there are some things you cant do with copy everything that you can do in haskell
01:46:08 <merijn> ammar2: Right, so you end up having to have access to the original source
01:46:17 <ammar2> merijn: what if you had source for everything, is it viable then?
01:46:18 <dminuoso> Mmm, I have some large monad in which I process a complicated configuration. What mechanisms might one use to track context in such a way that I can annotate regions like `withContext "inside a house" (do { ... }) >> withContext "in the garden" (do { ... })`
01:46:26 <merijn> ammar2: It also becomes very slow (as anyone, like me, who's used C++ templates can tell you)
01:46:58 <dminuoso> (in order to facilitate better error diagnostics, so I can report exactly where an error occured)
01:47:03 <merijn> ammar2: Sure, there are compilers that do that. No Haskell compilers, but I'm pretty sure there's several (S?)ML compilers that do
01:47:24 <Ariakenom> it is possible to write code where the type isnt known at compile time.
01:47:38 <merijn> ammar2: OTOH, "box everything" is a rather well-studied battle-tested approach since many industrial compilers do the same (Java, C#, etc.)
01:47:48 <tdammers> re Haskell safety: the general approach, I think, is not to make the unsafe impossible, just inconvenient
01:47:55 <dminuoso> Ariakenom: Types in the type theory sense cannot be known at runtime because they are inherently a compile time construct.
01:48:20 <Solonarv> dminuoso: stick the "context" inside a ReaderT and use 'local'?
01:48:23 <dminuoso> Ariakenom: There are things like `Dynamic` though if you want this "dynamic typing" behavior of other languages
01:48:39 <dminuoso> Solonarv: oh! that's downright perfect!
01:48:47 <dminuoso> Solonarv: ReaderT I dont mind because MonadUnliftIO. :)
01:49:00 <Ariakenom> dminuoso: it is known to be the right type but not a specific type
01:49:04 <Solonarv> withContext :: MonadReader [String] m => String -> m a -> m a
01:49:04 <Solonarv> withContext msg = local (msg :)
01:49:06 <merijn> ammar2: I've read a few papers on Java compilers and the whole discussion of boxing vs unboxing, strictness analysis and optimising repeated unboxing/reboxing is basically the same as it is in GHC :)
01:49:18 <dminuoso> Might wrap it as ContextT/MonadContext as to avoid misuse of local
01:49:25 <ammar2> merijn: makes sense. so in general most languages go with "box everything" and then try to specialize the common stuff like numbers?
01:49:41 <Maxdamantus> Rust is also known for monomorphising everything, so there's no need for boxing.
01:49:42 <Solonarv> well, you are just giving it a different name so it does not clash with MonadReader / local
01:49:43 <merijn> ammar2: Yeah, or they just don't support generics (like C)
01:49:45 <Solonarv> but it is still the same thing
01:49:46 <dminuoso> Ariakenom: what does that even mean?
01:50:07 <tdammers> ammar2: C++ doesn't go with "box everything"
01:50:10 <dminuoso> Ariakenom: Do you mean like... coproduct types with pattern matching?
01:50:31 <Solonarv> non-regular recursive data types
01:50:54 <Solonarv> e.g. data ExpTree a = Tip a | Branch (ExpTree (a,a))
01:50:57 <ammar2> tdammers: right, any other notable examples of languages that specialize the code per type?
01:51:23 <Maxdamantus> Should probably also be pointed out if it hasn't already that you kind of need boxing where you have laziness as well.
01:52:11 <Ariakenom> dminuoso: no just a type variable ... I think. I dont remember what exactly but I remember boxing was needed for something. polymorphic recursion comes to mind
01:52:18 <Maxdamantus> actually, I guess you don't *need* it due to laziness, but it makes things easier.
01:52:48 <Maxdamantus> (you'd need it to support cyclic lazy datastructures, at least)
01:53:06 <dminuoso> Maxdamantus: You dont either.
01:53:18 <dminuoso> Maxdamantus: Boxing is just one particular mechanism that enables you to define cyclic data structures.
01:53:28 <merijn> Boxing certainly makes it easier, though :)
01:53:36 <Solonarv> boxing makes it so a function's arguments are always pointers, which always have the same size, so you can generate the same code for all argument/return types
01:53:38 <dminuoso> merijn: fair.
01:53:57 <merijn> Solonarv: Yeah, we covered that part quite a bit back ;)
01:54:07 <Solonarv> if arguments/return values are unboxed, then the size depends on the type, so you need to know what the type is :D
01:54:14 <Maxdamantus> dminuoso: well, an unboxed cyclic data structure would be unconstructable.
01:54:35 <merijn> Maxdamantus: I'm not conviced, why would it be?
01:55:05 <dminuoso> Maxdamantus: The cyclic nature is a matter of an interface.
01:56:00 <Ariakenom> dminuoso: you'd need it for `length` here? https://en.wikipedia.org/wiki/Polymorphic_recursion
01:56:05 <Maxdamantus> merijn: well, unless you have a variant type in it, you won't be able to construct the value in order to construct the value.
01:56:08 <merijn> I mean, you could introduce a Fix constructor that does boxing for any recursive datatypes. That'd be unnecessarily complicated, but I think it could be done
01:56:25 <Maxdamantus> merijn: aiui that would require laziness.
01:56:25 <dminuoso> Maxdamantus: Consider a simple C approach to the problem without a linked list. 
01:56:46 <Maxdamantus> dminuoso: C doesn't allow cyclic unboxed datastructures: struct foo { struct foo x; };
01:56:57 <dminuoso> Maxdamantus: You are mixing implementation with interface.
01:57:46 <tdammers> ammar2: it's not really about specializing the code; it's about having a pointer/reference indirection
01:57:55 <dminuoso> Maxdamantus: You could just maintain a buffer, some location containing the length of the buffer, and then you just do modulo arithmatic when indexing into the buffer
01:58:09 <Ariakenom> dminuoso: since you can create arbitrarily many applications of [] from user input
01:58:14 <tdammers> ammar2: you can, in principle, have unboxed unions - I believe some Lisps use this approach
01:58:40 <Ariakenom> the type []
01:59:12 <Maxdamantus> dminuoso: it's not unboxed if you're pointing to it.
01:59:28 <tdammers> typedef union value_t { int as_int; float as_float; cons as_cons; ... } value_t; // something like this
01:59:37 <Maxdamantus> dminuoso: if you have an actual unboxed linked list, I would expect it to have an infinite size.
02:00:13 <Solonarv> actually Haskell has them too, but they are tagged
02:00:38 <tdammers> you'd probably tag them, yes
02:00:52 <Ariakenom> tdammers: -XUnboxedSums is real
02:00:55 <tdammers> *especially* in a lisp, because those are generally untyped, so you can't use compile-time type information to resolve things
02:02:07 <Solonarv> % decons x = case x :: (# Int | Bool #) of (# i | #) -> i == 42; (# | b #) -> b
02:02:07 <yahb> Solonarv: Error: bytecode compiler can't handle unboxed tuples and sums.; Possibly due to foreign import/export decls in source.; Workaround: use -fobject-code, or compile this module to .o separately.
02:02:13 <Solonarv> ah heck
02:02:35 <boxscape> % :set -fobject-code
02:02:35 <yahb> boxscape: 
02:02:42 <boxscape> % decons x = case x :: (# Int | Bool #) of (# i | #) -> i == 42; (# | b #) -> b
02:02:42 <yahb> boxscape: Error: bytecode compiler can't handle unboxed tuples and sums.; Possibly due to foreign import/export decls in source.; Workaround: use -fobject-code, or compile this module to .o separately.
02:02:46 <boxscape> eh
02:03:06 <Solonarv> hm, that error message could use some improving
02:03:26 <Solonarv> but unboxed sums are fairly new and kind of obscure
02:03:48 <boxscape> I've never heard of them, which surprises me some considering they've existed since 8.2
02:04:11 <Solonarv> they might start seeing more use when UnboxedNewtypes lands
02:04:16 <Solonarv> it might even be in 8.8, I forget
02:05:04 <boxscape> it's in 8.10 apparenlty
02:07:30 <Maxdamantus> I guess the way to define an unboxed linked list would be: newtype List = List (# () | (# Int, List #) #)
02:07:31 <boxscape> % undefined (undefined :: (# Int #))
02:07:31 <yahb> boxscape: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:13:12 in interactive:Ghci8
02:07:34 <Maxdamantus> which doesn't work
02:08:16 <boxscape> % type List = (# () | (# Int, List #) #)
02:08:17 <yahb> boxscape: ; <interactive>:14:13: error:; * Expecting a lifted type, but `(# () | (# Int, List #) #)' is unlifted; * In the type `(# () | (# Int, List #) #)'; In the type declaration for `List'
02:08:21 <boxscape> unfortunate
02:08:25 <Solonarv> Maxdamantus: actually, that still has indirections
02:08:57 <Solonarv> you can do: newtype List = List (# (# #) | (# Int, List #)
02:09:05 <Solonarv> you can probably even make it polymorphic
02:09:26 <Solonarv> note that this list is necessarily spine-strict
02:09:35 <Maxdamantus> Ah, didn't think of the `()`, but that will surely also be considered invalid for the same reason.
02:09:52 <Solonarv> yes, and type synonyms aren't allowed to be recursive anyway
02:10:04 <Ariakenom> % loop :: Show a => Int -> a -> String; loop 0 x = show x; loop n x = loop (n-1) [x];
02:10:04 <yahb> Ariakenom: 
02:10:06 <Solonarv> so you need UnboxedNewtypesto do this
02:10:15 <Ariakenom> % loop 3 "ok"
02:10:15 <yahb> Ariakenom: "[[[\"ok\"]]]"
02:10:19 <Ariakenom> % loop 15 "ok"
02:10:19 <yahb> Ariakenom: "[[[[[[[[[[[[[[[\"ok\"]]]]]]]]]]]]]]]"
02:10:20 <boxscape> type families can be recursuve
02:10:23 <boxscape> recursive*
02:10:33 <Solonarv> yes, but they are expanded eagerly
02:10:38 <Ariakenom> dminuoso: the precise type isnt known until runtime
02:11:04 <Solonarv> so if you define type family List where List = (# (##) | (# Int, List #)) the typechecker will still explode
02:11:16 <boxscape> % type family List where List = (# (##) | (# Int, List #))
02:11:16 <yahb> boxscape: ; <interactive>:18:56: error: parse error on input `)'
02:11:23 <boxscape> % type family List where List = (# (##) | (# Int, List #) #)
02:11:23 <yahb> boxscape: ; <interactive>:19:31: error:; * Expecting a lifted type, but `(# (# #) | (# Int, List #) #)' is unlifted; * In the type `(# (# #) | (# Int, List #) #)'; In the type family declaration for `List'
02:11:42 <dminuoso> 10:58:50 Maxdamantus | dminuoso: it's not unboxed if you're pointing to it.
02:11:46 <Ariakenom> ghc also cant infer the type of loop :)
02:11:46 <dminuoso> Maxdamantus: You have to point at it either way.
02:12:00 <Solonarv> hm, true
02:12:13 <Solonarv> so I guess that unboxed newtype I wrote above shouldn't be legal
02:12:16 <dminuoso> Maxdamantus: If we get down to implementation details, then true unboxing would mean storing it in SIMD registers.
02:12:30 <dminuoso> Its either that, or you are somehow working with references.
02:12:50 <Ariakenom> so you cant generate loop code for each type. since it can be used with any number of nested lists
02:12:51 <Solonarv> this makes sense when you look at its kind: k ~ 'SumRep '['TupleRep '[], k]
02:13:03 <Solonarv> which is obviously wrong! that's an infinite type
02:13:16 <dminuoso> phadej: How responsible are you for postgresql-simple? Do you just maintain the package or would you be open to new ideas?
02:13:25 <Maxdamantus> dminuoso: you need to point to it eventually, at least. Unboxing as far as I'm concerned just means "the thing that the value is part of isn't just pointing to it"
02:13:44 <dminuoso> Maxdamantus: The notion of "value" needs to be clearly defined here.
02:14:24 <dminuoso> Maxdamantus: Even an unboxed array is boxed by notion of having a memory address pointing at its starting location. Your CPU cant deal with it.
02:15:03 <phadej> dminuoso: I'm open to listen the new ideas, but also reject them if they would change the (on purpose vaguely defined) "spirit of postgresql-simple"
02:15:10 <Maxdamantus> dminuoso: the point is that you can put the "unboxed array" inside another array and not introduce a pointer.
02:15:39 <Maxdamantus> though I think sometimes when I'm saying "unboxed" I might be meaning "unlifted" in the Haskell sense. Not sure.
02:21:27 <wikiemol> So I think I am somehow misunderstanding the primary use case for creating Type classes in Haskell. Coming from an OOP background, I think I can't help compare them to Interfaces/OOP Classes. How are they different? What problems do Type Classes solve that Interfaces don't? And vice versa What problems do interfaces solve that type classes don't?
02:21:53 <dminuoso> phadej: There's two orthogonal ideas Im having. One is a mild addition of `queryR_ :: Connection -> RowParser p -> Query -> IO [r]` (plus queryR equivalent), the purpose of which I hope is self-evident. Another line of thought goes into parametrizing Query with either a type list (representing the columns), or at the very least some type `r`
02:21:55 <Ariakenom> so `loop` can't be written in C++ or rust
02:22:54 <phadej> there is queryWith :: ToRow q => RowParser r -> Connection -> Query -> q -> IO [r]
02:23:06 <phadej> and for latter, no, doesn't quality as "simple"
02:23:20 <phadej> (and queryWith_ :: RowParser r -> Connection -> Query -> IO [r])
02:24:11 <tdammers> my $0.02: query type safety down to the column type / table type level should not ever be the responsibility of postgresql-simple
02:24:19 <dminuoso> phadej: Wow Im stunned. Im unsure how I even missed that.
02:25:11 <phadej> tdammers: yes, there is IsString Query, which throws all safety out of the window
02:25:29 <tdammers> phadej: that safety would be an illusion anyway
02:25:44 <phadej> tdammers: it would, I agree.
02:25:52 <merijn> wikiemol: So, there's a couple of things
02:26:07 <dminuoso> phadej: What if FromRow was added with some method `class FromRow r => ... sql :: Proxy r -> Query`? One of the things I find really annoying is that the way FromRow works, is that you have to keep two deeply linked pieces of information (the deserialization and the query) in separate places.
02:26:28 <wikiemol> merijn I will hear as many of these things as you are willing to tell 
02:26:29 <tdammers> another reason why I'm opposed to having such a type-safe query API in a -simple library is because there is absolutely no benefit in that over putting it in a separate library
02:26:30 <dminuoso> (I mean ultimately queryWith solves this problem in a different, but adequate way)
02:26:32 <merijn> wikiemol: First of all, with interface inheritance you can only decide which interfaces are implemented when the datatype is defined, so 3rd party libraries defining new interfaces can't be supported by your datatype without changing
02:26:55 <merijn> wikiemol: Secondly, let's take an interface like Comparable in Java (or whatever it's called nowadays)
02:27:29 <phadej> dminuoso & tdammers, yes if you want more type-safety, use beam or opaleye or esqueleto or persistent or your own thing
02:27:36 <merijn> wikiemol: Suppose I write "bool equals(Comparable a, Comparable b);", there's no way to enforce 'a' and 'b' have the same type, they could be two entirely unrelated types that both happen to implement Comparable
02:27:59 <tdammers> phadej: my point. a key observation with these libraries is that they are a lot more opinionated than the -simple libs, and this is inevitable
02:28:22 <merijn> wikiemol: Compare this with Haskell's "(==) :: Eq a => a -> a -> Bool" which takes two values of the same type (which *also* has to implement the Eq typeclass)
02:28:31 <dminuoso> phadej: Fair enough. Ill probably write my own thin layer ontop of postgresql-simple - overall I like the interface, I just want a thin layer of safety ensuring you dont mismatch queries with rowparsers.
02:28:39 <merijn> wikiemol: Thirdly, interface inheritance can't really handle polymorphic returns
02:28:39 <boxscape> % loop :: forall f . Show f () => (); loop = id @f
02:28:39 <yahb> boxscape: ; <interactive>:21:20: error:; * Expected kind `* -> Constraint', but `Show f' has kind `Constraint'; * In the type signature: loop :: forall f. Show f () => ()
02:28:49 <boxscape> gives me an internal ghc error in 8.8
02:28:55 <boxscape> guess I'll report a bug
02:29:01 <jle`> whoops
02:29:10 <merijn> wikiemol: Consider: "readMaybe :: Read a => String -> Maybe a", there's no way to write something similar using interface inheritance
02:29:33 <Ariakenom> wikiemol: I will be going so I will just give an example: a Runnable<X> interface in Java would be a `IO x` type in haskell. other things that would be an interface in java are also just types.
02:29:35 <__monty__> merijn: Wouldn't the java equivalent of the second point be a generic parameter?
02:29:57 <merijn> __monty__: Sure, but you can't have Generic interfaces, I think?
02:30:12 <merijn> It's been ages since I did Java though, so who knows
02:31:16 <jle`> Ariakenom: hm ... interfaces ar ecloser to typeclasses, but something like IO would be closer to a class, not an interface
02:31:27 <merijn> wikiemol: And the final thing happens when we move into the territory of extensions like MultiParamTypeClasses, and define something like "convert :: Coercible a b => a -> b" the typeclass constrains two different types at the same time, which is certainly not possible with interfaces
02:32:04 <wikiemol> merijn I see, I never considered this stuff before, but it makes sense now that you mention it explicitely
02:32:07 <wikiemol> *explicitly 
02:32:24 <merijn> wikiemol: Those are the technical details and there's also some cultural ones
02:32:39 <merijn> wikiemol: i.e. the insistence that most typeclasses have laws that define what they mean
02:32:43 <wikiemol> merijn I would also like to know some cultural differences
02:32:49 <Ariakenom> jle`: the point i tried to make was that more things are done without interfaces|typeclasses. 
02:33:01 <Ariakenom> |superclasses
02:33:22 <wikiemol> So these are all examples where Type classes are "better" than interfaces, are there also situations where an OOP programmer might use an interface, but using a type class for in that situation would be a bad idea?
02:33:49 <merijn> wikiemol: Lots of interface usually have some meaning associated with their name and some vague/ad hoc notion of what it should do, while in Haskell it's fairly common to insist there's a law that strictly defines what it means (consider Semigroup and Monoid for simple examples)
02:34:56 <DigitalKiwi> who enforces the laws
02:34:57 <merijn> wikiemol: There's some examples where it's a bad idea (usually related to "trying to get inheritance style functionality) but it's hard to think of a concrete example
02:35:11 <merijn> DigitalKiwi: Public opinion and the threat of riots ;)
02:35:21 <wikiemol> Ariakenom This is a good half of what I want to understand. I find that I keep implementing Type classes that end up becoming spaghetti in a way, but its also hard to think of a concrete example
02:35:29 <boxscape> merijn you can have generic interfaces
02:36:13 <merijn> wikiemol: I would say err on the side of not defining typeclasses, most people starting out with Haskell define way too many of them, but it's hard to explain why until they run into "my code has become spaghetti" problems ;)
02:36:24 <DigitalKiwi> https://joannetailele.files.wordpress.com/2014/04/screen-shot-2014-04-28-at-7-37-41-pm.png s/rules/laws/
02:36:45 <wikiemol> boxscape You can definitely do the specific example that merijn used for 2 in Java, but I think merijn's point was the way it was done. Which is very conceptually different
02:36:52 <jle`> i think culturally typeclasses are used for a different 'purpose' than interfaces in java, even though their mechanics seem sort of similar
02:37:13 <boxscape> wikiemol I was responding to merijn saying "Sure, but you can't have Generic interfaces, I think?"
02:37:17 <jle`> so you can use typeclasses to fake interfaces in a way, but it wouldn't really be stylistically clean
02:37:29 <jle`> usually the general law of typeclasses is "don't make your own typeclasses"
02:37:46 <jle`> and then later when you get more experience it's "don't make your own typeclasses unless you know why you shouldn't"
02:38:29 <merijn> wikiemol: For example, a quick grep of my codebase of 10k LOC gives me 3 classes I defined myself. 1 of which is slated for removal once I get around to it :)
02:38:58 <jle`> because of things like parametric polymorphism, the role of typeclasses in haskell culture generally is to write generic code that can be 'reasoned' with, and not as a 'method name overloading' thing like it's used in OOP often
02:39:17 <solonarv-p> gah, I really need to find a better place to sit
02:39:19 <merijn> And 1 of those is, essentially, an abstract API for a monad transformer stack
02:39:38 <wikiemol> jle` So what is the replacement in Haskell? Like here is an example I ran into recently. I tried to make a "StateMachine" type class made for parsing/accepting different regular grammars. Which in hindsight I think may have been a bad idea. But I can't really put my finger on why or what I would have done to make it better.
02:39:49 <__monty__> Round TUITs are in such short supply.
02:40:04 <merijn> __monty__: Tell me about it
02:40:05 <jle`> wikiemol: parameterized types or sum and product types, sometimes maybe
02:40:08 <jle`> it's kind of situational too
02:42:09 <wikiemol> jle` So you are saying often type and newtypes are often the better choice?
02:43:47 <jle`> eh, it's not really directly translatable like that
02:43:55 <jle`> but sometimes you can restructure your program so that these problems go away
02:44:55 <__monty__> Learned about Max, Last, Any, Sum, etc. yesterday. Can anyone tell me when these are preferable over maximum, last, any, sum, et al.?
02:45:15 <merijn> __monty__: They're composable with other Monoids
02:46:06 <merijn> __monty__: So you can use "a -> (Max Int, Sum Double, Last Char)" together with foldMap to do quite complex things easily
02:46:51 <wikiemol> jle` That is also what I have been noticing. That sometimes I just had to think about the problem harder and it would become extremely elegant, more so than when I think about the problem harder in OOP. But I am not sure why. Its hard to know when a solution is inelegant because its necessarily complicated, or when its inelegant because I am doing
02:46:51 <wikiemol> it wrong. 
02:47:48 <wikiemol> In OOP I feel like I can know when my solution is hacky and dumb, but that may just be because I have more experience in it... I want a shortcut to mastery :)  
02:47:56 <merijn> wikiemol: That's where asking here for tips comes in ;)
02:47:59 <solonarv3> you can write functions that work for any monoid and use them with Max, Last etc
02:48:01 <solonarv3> rather than writing 12 specialized versions
02:48:37 <merijn> @quote that's.just
02:48:37 <lambdabot> jcreigh says: I've found learning Haskell makes me feel vastly inferior to Haskell coders. ("Oh,", they say, "That's just a fold over the hyper-monad fluxbox list. Here's the one-line replacement
02:48:37 <lambdabot> for your entire program.")
02:51:50 * hackage pagure-cli 0.1 - Pagure client  https://hackage.haskell.org/package/pagure-cli-0.1 (JensPetersen)
02:51:59 <__monty__> Hmm, maybe the reverse question. Are there good reasons to use the lower case max, last... rather than the upper case Max, Last, etc.? Maybe just the degenerate case where you're doing `getMax . map Max`?
02:52:39 <solonarv-p2> exactly
02:52:44 <merijn> __monty__: That degenerate case can be optimised by Coerce :p
02:52:55 <solonarv-p2> which admittedly is most of the time that you use them
02:53:06 <merijn> > getMax . mconcat . coerce $ [1..5]
02:53:11 <lambdabot>  error:
02:53:11 <lambdabot>      • Variable not in scope: coerce :: [Integer] -> [Max c]
02:53:11 <lambdabot>      • Perhaps you meant ‘coerced’ (imported from Control.Lens)
02:53:29 <merijn> > getMax . mconcat . Data.Coerce.coerce $ [1..5]
02:53:32 <lambdabot>  error:
02:53:32 <lambdabot>      Not in scope: ‘Data.Coerce.coerce’
02:53:32 <lambdabot>      No module named ‘Data.Coerce’ is imported.
02:53:35 <merijn> lame
02:53:47 <merijn> % getMax . mconcat . Data.Coerce.coerce $ [1..5] -- third time lucky?
02:53:47 <yahb> merijn: ; <interactive>:22:1: error: Variable not in scope: getMax :: b0 -> c
02:53:54 <merijn> oh, come on...
02:54:33 <solonarv-p2> ala foldMap Max -- ;)
02:54:39 <merijn> solonarv-p2: That's slower
02:54:47 <merijn> Well, in some cases anyway
02:54:52 <solonarv-p2> hmm, I think this might just yell about ambiguous types anyway
02:55:14 <merijn> % Data.Coerce.coerce [1..5] :: [Max Int]
02:55:14 <yahb> merijn: ; <interactive>:23:31: error:; Not in scope: type constructor or class `Max'; Perhaps you meant `M.Map' (imported from Data.Map)
02:55:22 <merijn> *facepalm*
02:55:25 <merijn> I give up
02:58:00 <solonarv-p2> oh, right
02:59:06 <solonarv-p2> well it's basically just 'coerce (fold @_ @(Max Int))'
02:59:24 <solonarv-p2> ... but with even more type applications
02:59:57 <wikiemol> merijn You're right. I suppose here is another example of something which is somewhat unrelated to type classes (maybe), but I often feel like I am trying to "force" my recursion to be like an imperative for loop. This is I think another main source of inelegance in my code. This is maybe of a very broad question, but how do I get better at
02:59:58 <wikiemol> breaking that habit and thinking in terms of Haskell’s composable list functions (like map, and filter)? Currently, specifically loop related solutions to problems that I could solve in 5 minutes in an imperative language take like 30-40 mins in haskell because I struggle to convert these solutions to idiomatic haskell. 
03:01:22 <merijn> wikiemol: If it's any consolation I spend an entire semester struggling to do those conversions in uni and now it's just become obvious. It's just a matter of practice
03:01:28 <merijn> Anyhoo, lunch time
03:02:26 <wikiemol> However, the up side is that after 30-40 minutes of thinking a 10 line method in an imperative language ends up being like 10 characters in haskell haha
03:07:25 <wikiemol> Anyways I have to get up in 2 hours for work :(  My only consolation is that Java 8 has streams and lambdas now 
03:10:20 * hackage llvm-tf 3.9 - Bindings to the LLVM compiler toolkit using type families.  https://hackage.haskell.org/package/llvm-tf-3.9 (HenningThielemann)
03:11:39 <tdammers> IME, "imperative" doesn't necessarily imply "verbose"
03:12:11 <tdammers> Java's verbosity is more due to its particular flavor of OOP, and to other design choices that have nothing to do with programming paradigms at all
03:12:45 <solonarv-p2> > (tdammers) IME, "imperative" doesn't necessarily imply "verbose"
03:12:47 <lambdabot>  <hint>:1:15: error: parse error on input ‘,’
03:13:07 <solonarv-p2> yes, I write terse imperative code in Haskell all the time! :P
04:01:51 * hackage llvm-extra 0.8.3 - Utility functions for the llvm interface  https://hackage.haskell.org/package/llvm-extra-0.8.3 (HenningThielemann)
04:03:47 <yasar> Getting type error in line 36: https://gist.github.com/yasar11732/78e04bec0a722596ec7fb83677836a1d
04:03:52 <yasar> Error message is in comments
04:05:30 <merijn> yasar: On line 41 you use 'x' as argument to !!
04:05:32 <merijn> :t (!!)
04:05:35 <lambdabot> [a] -> Int -> a
04:05:55 <merijn> yasar: Which requires Int, so 'histogramcount' gets an inferred input type of [Int]
04:06:15 <tdammers> I do suspect though that verbosity is more harmful in FP than in imperative code
04:06:16 <merijn> yasar: However, you're calling it from 'histogram' on a list of [Integer]
04:06:42 <merijn> yasar: If you add a type signature for histogramcount this will become more obvious
04:07:06 <tdammers> having written parser-combinators in functional C++, I can testify that it is an order of magnitude more difficult than in Haskell, and that's mostly due to the amount of ceremony and boilerplate associated with writing in that style in C++
04:10:14 <Solonarv> yes, it sounds painful
04:13:09 <Solonarv> really, liftA2 isn't in Prelude??
04:20:20 <merijn> Solonarv: Remember that Applicative wasn't even in Prelude until AMP :p
04:20:44 <Solonarv> yes but <*> is in there! liftA2 is equally fundamental and should really be there too
04:20:54 <Solonarv> ah well, it will probably be added at some point
04:23:32 <Rembane> If I want to add something to the prelude, where do I send my patch? 
04:24:18 <boxscape> I'd like it if we had map = liftA, map2 = liftA2, map3 = liftA3, and so on. 
04:24:29 <boxscape> Rembane the core libraries committee, I would think
04:24:32 <Solonarv> core libraries committee, I think?
04:24:41 <phadej> to Prelude? discuss the change first at https://mail.haskell.org/mailman/listinfo/libraries 
04:24:47 <Solonarv> I do not mind the liftAn naming convention
04:25:30 <phadej> changes to Prelude are controversial, CLC will indeed decide whether it's ok
04:25:40 <boxscape> I don't like the aesthetics of the single-letter camel case in combination with a digit
04:26:14 <boxscape> would be nice if they had a setup similar to the steering committee, with github
04:26:45 <EvanR> :t liftA4 -- would be nice
04:26:47 <lambdabot> error:
04:26:48 <lambdabot>     • Variable not in scope: liftA4
04:26:48 <lambdabot>     • Perhaps you meant one of these:
04:26:48 <dminuoso> 13:20:22    Solonarv | yes but <*> is in there! liftA2 is equally fundamental and should really be there too
04:26:54 <dminuoso> Solonarv: I don't agree.
04:27:20 <dminuoso> In general I'd say <*> is more fundamental, and you dont get into edge cases like "why isnt liftA3, liftA4... in Prelude"
04:27:24 <Rembane> phadej, boxscape, Solonarv: Thank you! 
04:28:20 <EvanR> liftA4 isn't even anywhere
04:28:46 <boxscape> @hoogle liftA4
04:28:46 <lambdabot> Control.Applicative.HT liftA4 :: Applicative f => (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e
04:28:47 <lambdabot> Util liftA4 :: Applicative p => (a -> b -> c -> d -> e) -> p a -> p b -> p c -> p d -> p e
04:28:47 <lambdabot> Rank2 liftA4 :: Apply g => (forall a . p a -> q a -> r a -> s a -> t a) -> g p -> g q -> g r -> g s -> g t
04:28:51 <Solonarv> nono, liftA2 is actually equally powerful: <*> and liftA2 can be defined in terms of each other, and when writing an Applicative instance you can provide either of them
04:29:11 <boxscape> oh I didn't know liftA2 was a method of Applicative
04:29:15 <EvanR> dot HT?
04:29:38 <Solonarv> I think it might have been added somewhat recently
04:30:04 <boxscape> EvanR Henning Thielemann
04:30:11 <MarcelineVQ> "<Solonarv> ah well, it will probably be added at some point" It's part of Applicative, yet not in Prelude, kind of interesting, like some of the things from Foldable.
04:30:16 <EvanR> lol
04:30:39 <Solonarv> yes, I am also sometimes surprised when I remember that I have to import e.g. traverse_ or fold
04:31:15 <MarcelineVQ> or guard
04:31:21 <Solonarv> yes, that one too!
04:31:52 <boxscape> maybe we'll get join in the Prelude once we have better roles
04:32:20 <boxscape> (because then it can become a method of Monad)
04:33:08 <EvanR> can we just overhaul prelude please
04:33:19 <EvanR> two choices, "classic" and "sane"
04:33:49 <tdammers> I think the problem is that it's a bit unclear where sanity ends and a new kind of insane begins
04:33:53 <boxscape> seems like at that point it's not that different from just using a third-part prelude
04:33:56 <phadej> fwiw, guard needs MonadPlus, which is a stretch
04:33:58 <tdammers> hence the flood of alternative preludes
04:34:07 <EvanR> custom prelude doesn't cut it for several reasons
04:34:22 <Solonarv> :t guard
04:34:24 <boxscape> and then you have tradeoffs between different kinds of incompatible insanities
04:34:26 <lambdabot> Alternative f => Bool -> f ()
04:34:30 <MarcelineVQ> EvanR: did someone say Classy
04:34:33 <Solonarv> ^ actually Alternative
04:36:23 <Rembane> I like the concept of a classic and sane prelude
04:36:27 <Rembane> +a 
04:37:03 <EvanR> we just overhaul prelude please
04:37:24 <EvanR> my connection is a new kind of insane
04:37:59 <merijn> phadej: guard doesn't require MonadPLus anymore
04:38:08 <merijn> phadej: It changed during "The Great Upheaval" ;)
04:38:11 <phadej> Alternative isn't in Prelude either, for better or good
04:38:17 <phadej> but best prelude is no prelude
04:38:18 <dminuoso> Solonarv: Sure, but just because two things are equal in power/isomorphic, doesn't mean you have to provide both interfaces in a module.
04:38:20 <phadej> IMHO
04:38:55 <merijn> I for one don't wanna live in a world where my dependencies use 5 different Prelude's
04:39:07 <dminuoso> merijn: That world is already real! :p
04:39:10 <merijn> Just import what you need and get on with life
04:39:16 <haskeldjiq_> is there an alternative world
04:39:17 <merijn> dminuoso: Not for the stuff I use mostly :p
04:39:25 <Solonarv> yes, that is annoying mostly because custom preludes tend to have a wide dependency footprint
04:39:35 <EvanR> to write idiomatic basic haskell you need to import 8 different things for 1 function each
04:39:46 <dminuoso> But yeah. There's only two ways to write haskell: No prelude or prelude.
04:39:52 <EvanR> or any custom prelude except the default one
04:39:56 <dminuoso> Anything else is not worth the trouble.
04:40:11 <merijn> EvanR: Just import that 8 things and get on with life
04:40:18 <haskeldjiq_> Prelude is also arguably worth the trouble
04:40:21 <EvanR> i've done that at length, for years
04:40:24 <dminuoso> You lose the ability to reason about code, when you dont even know what `fmap` does.
04:40:27 <EvanR> i can't get that time back
04:40:29 <boxscape> merijn typically the recommendation I've heard is to only use alternative preludes for applications rather than libraries, so you don't run into the problem of depending on them
04:40:31 <dminuoso> (Because who knows what your custom Prelude *really* imports)
04:40:33 <EvanR> meanwhile other languages don't have that issue
04:40:44 <Solonarv> I know that is how Java does it, but they have great IDEs that write the imports for them
04:40:46 <dminuoso> EvanR: Sure they do.
04:40:51 <EvanR> some d
04:40:51 <merijn> boxscape: But then you don't really have a Prelude and more of a "module reexporting stuff"
04:40:56 <EvanR> some don't
04:40:57 <Solonarv> I don't think I have seen a working tool that does this for Haskell
04:40:57 <merijn> EvanR: Name one
04:41:04 <dminuoso> EvanR: boost in case of C++, JavaScript has plenty of similar "prelude-style" of libraries.
04:41:07 <Solonarv> and frankly, typing imports does get annoying eventually
04:41:18 <haskeldjiq_> Solonarv: intellij-haskell is pretty good at that
04:41:20 <dminuoso> EvanR: Or qt for C++ too
04:41:21 <EvanR> agreed on C++ and javascript
04:41:29 <Solonarv> haskeldjiq_: too bad it only works in stack projects!
04:41:37 <haskeldjiq_> Solonarv: :(
04:42:13 <Solonarv> and anyway, while my laptop can just barely run some jumped-up text editor like vscode it cannot comfortably run IDEA
04:42:14 <dminuoso> EvanR: Scalaz for Scala..
04:42:21 <boxscape> are we talking about automatically adding imports?
04:42:29 <EvanR> merijn: why even have a prelude if you are importing 8 things for even the most basic program
04:42:32 <boxscape> hie does that I think
04:42:40 <dminuoso> EvanR: This notion of "We're going to fix all the standard library bugs" is very prevalent in most languages.
04:42:41 <EvanR> just make no prelude the default
04:43:23 <dminuoso> From the top off my head I cant think of a single language that doesn't have the spiritual equivalence of a custom prelude, in fact.
04:43:31 <EvanR> dminuoso: php, ruby, perl ime can get more traction without importing anything
04:43:44 <dminuoso> EvanR: The ruby world is filled with ActiveSupport.
04:43:51 <EvanR> a basic program may import 1 thing or 0 things
04:43:52 <Solonarv> that is because they have a large implicitly-imported prelude
04:44:01 <haskeldjiq_> dminuoso: for example in .NET you'd basically never use an alternative "System"
04:44:11 <dibblego> I do.
04:44:31 <haskeldjiq_> why would you do that?
04:44:34 <EvanR> i don't even think examples of other languages is my point
04:44:49 <dibblego> coz it's broken
04:45:07 <EvanR> a prelude that coincides with commonly needed things would be amazing, we don't we need to refuse to imagine that world
04:45:09 <haskeldjiq_> no I get that but how would you convince your team/company to do that
04:45:31 <EvanR> er s/don't/do/
04:45:37 <merijn> EvanR: How is no Prelude better? Then you need to import even more
04:45:50 <dibblego> I don't do convincing. The same way I got this country writing Haskell instead of Java
04:46:05 <haskeldjiq_> which country
04:46:07 <Solonarv> "country"?
04:46:13 <EvanR> merijn: well, at least then you don't need to go through a custom prelude dance, a custom prelude is just "my module with all my imports"
04:46:26 <merijn> EvanR: But you can already do that?
04:46:33 <EvanR> there would be conflicts
04:46:34 <dibblego> yes, this one
04:46:35 <haskeldjiq_> sounds like a nice business (or country) where you don't have to convince anyone lol
04:46:45 <merijn> EvanR: Like?
04:46:53 <dibblego> you might call it convincing, but it isn't
04:47:17 <haskeldjiq_> dibblego: I didn't understand any of that
04:47:26 <EvanR> merijn: you win, everything is great
04:47:29 <Solonarv> default-extensions: NoImplicitPrelude -- ;)
04:47:36 <merijn> EvanR: The only real conflicts I run into is from traditionally qualified modules like containers, which I don't use that often anyway
04:47:51 <dibblego> the thing to do so as to achieve the goal, is not what is commonly called convincing — it is something else
04:47:55 <EvanR> keep importing 8 or 9 modules for 1 thing that should be in prelude
04:48:02 <EvanR> every single time
04:48:12 <Solonarv> I always import containers like: import Data.Map (Map); import qualified Data.Map.Strict as Map
04:48:20 <Solonarv> I think something like this is fairly common
04:48:34 <merijn> EvanR: No, my point is literally "What are you importing that you can't trivially reexport without qualifying"?
04:48:55 <dibblego> this state and federal government fund writing haskell today. Back when I started, I found the only other Haskell programmer in the country because I appeared on television in an unrelated thing, and that other person recognised my name from the mailing list. Now there are two.
04:48:56 <merijn> EvanR: I mean, if you can import those 8 things independently without conflict how does reexporting them magically make them conflict?
04:49:03 <EvanR> without Data.Map or Data.Hashmap you are writing C with a built in list type
04:49:14 <haskeldjiq_> dibblego: which country is that
04:49:22 <Solonarv> dibblego: whoa, that's pretty cool
04:49:23 <dibblego> .au
04:49:29 <dibblego> http://qfpl.io/
04:49:30 <merijn> EvanR: Arguing "Data.Map should be in Prelude" is a whole other step beyond "liftA2 should be in Prelude"
04:49:49 <tdammers> Data.Map is way too opinionated a choice to be in prelude IMO
04:49:54 <haskeldjiq_> dibblego: as in Australia?
04:49:59 <dibblego> yes that one
04:50:02 <merijn> Solonarv: tbh, I do think we should have "import qualified Data.Map (Map) as M" importing Map without qualification
04:50:06 <tdammers> if your project uses Data.Map a lot, make a custom prelude for that project
04:50:08 <dibblego> Queensland is a state in Australia
04:50:08 <EvanR> i don't think Data.Map (or .Strict) should be in prelude
04:50:27 <merijn> EvanR: Right, so what do you use often that conflicts, then? I'm genuinely curious
04:50:38 <Solonarv> merijn: yes, that would be a nice bit of syntax sugar
04:50:59 <tdammers> on a side note, I'm not at all a fan of single-letter module aliases
04:51:01 <EvanR> everything in Data.Map is one example
04:51:02 <Solonarv> the thing is that I never want to import Data.Map.{Strict,Lazy} unqualified anyway
04:51:06 <Solonarv> tdammers: likewise
04:51:59 <merijn> EvanR: Because anything that doesn't conflict with Prelude can be trivially reexported from a single module in your library and you get the advantage of your 'custom prelude' and the regular one. Sure, Data.Map conflicts, but you just said you didn't think it should be in Prelude anyway, so that seems unrelated, then
04:53:09 <EvanR> i wanted to make the point that a better prelude that everyone agrees on and expects is better than 100 custom preludes + your own homebrew
04:53:27 <merijn> EvanR: There will literally never be a Prelude that everyone agrees on
04:53:27 <EvanR> and no, because java sucks is not a reason to pretend this is impossible
04:53:34 <tdammers> the problem lies in the "everyone agrees" part
04:53:40 <EvanR> i don't agree
04:53:42 <merijn> I think it's impossible because of people
04:53:56 <merijn> EvanR: Well, I honestly wish you success accomplishing that
04:53:59 <EvanR> someone said 'join' someone said 'liftA2'
04:54:02 <merijn> But I don't believe it will ever happen
04:54:05 <dibblego> it's possible; just don't call it a prelude
04:54:08 <EvanR> find someone who thinks those are bad ideas
04:54:25 <tdammers> point in case, I believe the majority of those 100 custom preludes ventured out on the idea of being that one custom prelude that everyone could agree on
04:54:39 <merijn> $20 says you will get someone disagreeing on liftA2 within 24 hours of suggesting it on the mailing list
04:54:51 <merijn> Actually
04:54:54 <Solonarv> that's a sucker bet
04:55:05 <EvanR> all 100 custom preludes are incorrect because they are custom preludes, you do a dance to set them up and no one expects to see it by default
04:55:08 <merijn> Make that like 6 hours, assuming you don't game the submission time
04:55:19 <EvanR> i want to know the reasoning
04:55:59 <merijn> EvanR: If you browse the libraries mailing lists you will find 10s if not 100s of arguments against changing/extending Prelude (mind you, I'm not endorsing those arguments)
04:56:06 <xenon-> should liftA3 be in Prelude?
04:56:19 <EvanR> yes
04:56:39 <EvanR> (,,) is in prelude
04:56:40 <kevinsjoberg> I'm learning Haskell and playing around with recursive functions. I implemented my own version of cycle using myCycle (x:xs) = x : myCycle (xs ++ [x]). My understanding is that it's not tail recursive, how come it does not error when I just let it run?
04:56:54 <tdammers> should Text be in prelude? what about most (all) of Control.Monad?
04:56:58 <merijn> kevinsjoberg: Tail recursion is mostly irrelevant in Haskell
04:57:04 <f-a_> why should it error kevinsjoberg ?
04:57:12 <kevinsjoberg> f-a_: Stack overflow?
04:57:14 <merijn> kevinsjoberg: You've probably been told about "tail call optimisation" being needed to avoid stack overflow
04:57:22 <Solonarv> not a problem n Haskell
04:57:23 <kevinsjoberg> merijn: Exactly.
04:57:24 <merijn> kevinsjoberg: Yeah...GHC Haskell doesn't have a function call stack :)
04:57:30 <Solonarv> Haskell does not use a call stack in the usual sense
04:57:44 <EvanR> tdammers: solving the conflicts is the 'overhaul' part
04:58:09 <EvanR> having strings that work out of the box would be amazing
04:58:13 <merijn> kevinsjoberg: So there is no function call stack to overflow :)
04:58:26 <EvanR> yes other languages have that
04:58:39 <merijn> EvanR: I think backpack-ified string types would be better for base, tbh
04:59:04 <merijn> EvanR: That actually would let most of base be backwards compatible too
04:59:06 <tdammers> I actually like strings implemented as library features
04:59:20 <tdammers> if anything, I think that String is the oddball here
04:59:30 <EvanR> String is oddball
04:59:31 <tdammers> I'd be fine with a Prelude that doesn't have any strings at all
04:59:33 <kevinsjoberg> merijn: I'm a bit confused. So given I implement reverse using myReverse (x:xs)  = (myReverse xs) ++ [x] and a pattern for the empty case, is it any "worse" in performance than a reverse function implemented using an accumulator?
04:59:37 <Bish> how do haskellers build code that allows "plugins" i mean there is no datastructure you can "insert" yourself intoo
04:59:40 <Bish> just out of curiousity
04:59:55 <tdammers> Bish: what do you mean, there is no data structure that you can insert yourself into?
05:00:06 <kevinsjoberg> In my experience, people would lean towards using the accumulator implemention due to it being "tail recursive".
05:00:07 <haskeldjiq_> I think he's looking for higher order functions
05:00:14 <tdammers> Bish: you very much can. You just expose an API that accepts functions as arguments (or even IO actions, if you want)
05:00:18 <EvanR> a function is a thing you can insert yourself into
05:00:27 <merijn> kevinsjoberg: Well, that version ends up repeatedly appending to the back of the list, which involves copying the whole thing
05:00:35 <boxscape> hmm do you suppose `x :: forall a . Maybe; x = x :: a` should complain about `a` not matching `a0` without ScopedTypeVariables? 8.6 does, but for some reason 8.11 doesn't. But both do if you replace Maybe with Int
05:00:36 <Bish> tdammers: and how does the program that i "extend" know that i am here?
05:00:59 <Solonarv> same as any other program: it looks for plugin files in appropriate directories, for example
05:00:59 <haskeldjiq_> Bish: it doesn't know
05:01:00 <tdammers> Bish: depends what exactly the plugin loading mechanism looks like.
05:01:03 <merijn> kevinsjoberg: That version would actually be quite good if you used DList to handle the repeated appending
05:01:09 <kevinsjoberg> merijn: I'm not sure I understand why it's any different that prepend as I do in cycle?
05:01:11 <tdammers> haskeldjiq_: it has to know, otherwise your stuff won't run at all
05:01:15 <merijn> kevinsjoberg: http://h2.jaguarpaw.co.uk/posts/demystifying-dlist/
05:01:22 <Solonarv> one approach is to simply embed a scripting language (e.g. lua) into your haskell application
05:01:23 <haskeldjiq_> tdammers: I misunderstood
05:01:40 <EvanR> i'm not sure if lua is what Bish is asking about
05:01:46 <merijn> kevinsjoberg: That bit is inefficient in your myCycle too ;)
05:01:48 <Bish> it isn't 
05:01:48 <Solonarv> and then your application looks for .lua (for example) files in some blah/plugins directory
05:01:52 <tdammers> anyway, the problem isn't fundamentally different in Haskell than it is in any other language
05:01:56 <EvanR> or dynamic loading
05:02:08 <Solonarv> caveat: than in any other *compiled* language
05:02:13 <merijn> kevinsjoberg: The problem is that since data is immutable appending at the end of a list requires copying every element from the original
05:02:15 <tdammers> how do you do plugins in C? same problem.
05:02:27 <EvanR> with void* pointers and function pointers!
05:02:34 <EvanR> haskell can do that... better
05:02:39 <Solonarv> it is actually a bit simpler in an interpreted language, where you can be sure that you have an interpreter on the user's system too
05:02:52 <xenon-> merijn, you don't need dlist to avoid that
05:02:53 <Bish> yeah what does that i mean? i did that in C a ölong while ago
05:03:01 <Bish> and i would call function that i know that are there
05:03:10 <merijn> xenon-: Well, it'd be hard to avoid it otherwise with reverse
05:03:12 <dminuoso> 13:45:15       merijn | EvanR: How is no Prelude better? Then you need to import even more <- one motivating reason might be a complete base-style interface that uses Text instead of String.
05:03:15 <Solonarv> you can do this with haskell too
05:03:19 <Bish> would i dynamic load a .so as a module? or how would that look
05:03:24 <Bish> i don't really have pointers, do i?
05:03:24 <merijn> xenon-: I don't actually know how you'd avoid it
05:03:34 <xenon-> merijn, recurse to the end, use (:)
05:03:34 <merijn> Bish: dons' wrote his thesis exactly on this topic ;)
05:03:39 <Solonarv> you can compile haskell to a .so, and you can call functions from a .so
05:04:00 <Solonarv> and we actually do have pointers
05:04:01 <Solonarv> !
05:04:04 <Bish> Solonarv: and how does that look? i mean i certainly never saw a pointer with my limited haskell knowledge
05:04:20 <EvanR> ok i'm wrong Bish is asking about dynamic loading
05:04:22 <Bish> so that's what i would do? extract functions (that i know that will be available) 
05:04:23 <f-a> https://downloads.haskell.org/ghc/latest/docs/html/users_guide/glasgow_exts.html#deriving-representations <-- GHC docs skirt around that `p` parameter as if it were useless/not-important. Is that so?
05:04:23 <Solonarv> that is because you only touch pointers if you explicitly need to do stuff with pointers
05:04:25 <EvanR> haskell can do that
05:04:33 <Bish> EvanR: what would be an alternative to that?
05:04:37 <Solonarv> f-a: that is for Generic, yes?
05:04:39 <Bish> except interpreting other languages
05:04:41 <EvanR> if you want to do that
05:04:44 <EvanR> just do that
05:04:49 <f-a> Solonarv: you guessed right
05:04:57 <Solonarv> f-a: I think the 'p' is an artifact of the same typeclass/associated type being used for Generic1
05:05:07 <Solonarv> and/or more nebulous hysterical raisins
05:05:17 <f-a> christmas appropriate
05:05:22 <xenon-> basically, do this with manual recursion if doing it manually is part of the excercise)
05:05:25 <f-a> I take it as a "care not"
05:05:27 <xenon-> > foldl' (flip (:)) [] [1..10]
05:05:30 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
05:05:30 <Bish> merijn: do you have a link to that thesis?
05:05:42 <Solonarv> Bish: haha I was typing the exact same message
05:06:10 <Bish> im guessing dynamic loading in haskell would be cool to switch code without restarting the application right?
05:06:15 <amx> http://hackage.haskell.org/package/plugins-1.6.0      this is probably relevant
05:06:20 <merijn> Bish: https://pdfs.semanticscholar.org/92f6/f7b25a91eba0fb7ac981a9a3e7f8ac8155aa.pdf
05:06:22 <Solonarv> yes, that is one thing you can do with it
05:06:23 <Bish> immutability helps there, i guess
05:06:35 <dminuoso> Bish: Simon Marlow held a really interesting talk on Haskell Exchange 2018 on how they do hot code reloading with Haskell at Facebook.
05:06:38 <Solonarv> not as much as you might think
05:06:46 <EvanR> xenon-: hmm, the prime there doesn't seem right
05:06:51 <Bish> Solonarv: why?
05:07:00 <Solonarv> when you are dynamically loading something you cannot even be sure that it was written in Haskell
05:07:08 <Bish> dminuoso: uhm, was that a haxl talk? i think i saw them all
05:07:17 <Solonarv> .so's have no concept of purity or immutability
05:07:17 <dminuoso> Bish: No, it was not Haxl.
05:07:25 <Bish> dminuoso: okay, cool will look into it
05:07:30 <dminuoso> Bish: The talk was just about hot code swapping in Enigma.
05:07:46 <dminuoso> Bish: Mind you, skillsmatter is in administration, so bye bye skillscast,.
05:07:51 <Bish> merijn: thank you
05:08:03 <Bish> dminuoso: i don't know any of these words
05:08:11 <Bish> Enigma is nazicrypto to me
05:08:26 <davve> dota 2 for me
05:08:38 <Bish> well, sure 
05:08:48 <Bish> davve: how do you like "sideshops"
05:08:49 <Bish> :D
05:08:50 <ooo_miguel> hello, Can i somehow easily convert a function from "ExceptT Err (ReaderT Ctx IO) Foo" to "ReaderT Ctx (ExceptT Err IO) Foo" ?
05:08:55 <dminuoso> Bish: The talk was held at Haskell eXchange, which was held by a company called Skillsmatter. Recordings of these talks by Skillsmatter were called skillcasts, and they were hosted on their website.
05:09:00 <davve> Bish: R.I.P sideshops
05:09:23 <Solonarv> @unmtl ExceptT Err (ReaderT Ctx IO) Foo
05:09:23 <lambdabot> ExceptT Err (ReaderT Ctx IO) Foo
05:09:24 <Bish> davve: i was thinking about going to TI 2020, now im not sure sure </offtopic>
05:09:32 <Solonarv> ...what?
05:09:37 <Solonarv> @unmtl ErrorT Err (ReaderT Ctx IO) Foo
05:09:37 <dminuoso> Bish: And skillsmatter filed for insolvency (which is what being placed into administration means)
05:09:37 <lambdabot> Ctx -> IO (Either Err Foo)
05:09:40 <Solonarv> aha!
05:09:44 <Bish> dminuoso: :(
05:09:48 <davve> Bish: where is it going to be?
05:09:53 <Solonarv> @unmtl ReaderT Ctx (ErrorT Err IO) Foo
05:09:53 <lambdabot> Ctx -> IO (Either Err Foo)
05:09:54 <Bish> davve: stockholm
05:10:00 <davve> oh. cool. i may g too then
05:10:08 <davve> if i can get tickets
05:10:15 <Solonarv> ooo_miguel: as you can see, both of those are just 'Ctx -> IO (Either Err Foo)' in the end
05:10:24 <Solonarv> so yes you can indeed convert between them
05:10:31 <EvanR> with a safe coercion?
05:10:38 <Solonarv> yes, that would work
05:10:42 <EvanR> nice
05:11:22 <ooo_miguel> Solonarv: I have to call a function with the first signature inside one with the second but ghc complains If I just call it.
05:11:28 <Solonarv> % :t Data.Coerce.coerce :: ExceptT err (ReaderT ctx IO) foo -> ReaderT ctx (ExceptT err IO) foo
05:11:28 <yahb> Solonarv: ExceptT err (ReaderT ctx IO) foo -> ReaderT ctx (ExceptT err IO) foo
05:11:54 <Solonarv> ooo_miguel: yes, I said you can easily *convert* between them because they have the same underlying representation
05:12:02 <Solonarv> they are not actually, literally identical
05:12:13 <EvanR> two different types
05:12:41 <ooo_miguel> heh, ok so you answered my first question. right. Second question is. *how* can I easily and elegantly convert between them?
05:12:58 <EvanR> coerce from Data.Coerce
05:13:05 <Solonarv> I actually already answered that too, yes ;)
05:13:08 <Solonarv> 'coerce'
05:13:22 <EvanR> which should be in prelude!
05:13:29 <Solonarv> its type is very general, so you might need to add some type annotations
05:13:45 <Solonarv> but apart from that little wrinkle it will just work
05:15:05 <ooo_miguel> Solonarv: allright. I Will give it a try. thank you very much
05:18:23 <boxscape> from the hackage page on Data.Coercible: `class a ~R# b => Coercible (a :: k0) (b :: k0)` what is ~R# and where is the haddock source for this snippet?
05:18:23 <EvanR> coerce satisfies two criteria for being preludable. Maybe three. It's a single useful function with a name that doesn't conflict with anything identified as preludable (that i know of). And it's safe unlike unsafePerformIO and unsafeCoerce.
05:19:39 <EvanR> and unlike the entirety of Data.Text and Data.Map
05:19:56 <Solonarv> ~R# is a specific equality constraint which is wired into GHC
05:20:11 <dminuoso> Solonarv: Thanks again, Ive got my own `newtype ContextT t m a = ContextT { runContextT :: [t] -> m a }` now. This is beautiful :)
05:20:21 <Solonarv> dminuoso: :D
05:20:58 <dminuoso> Solonarv: I considered ReaderT too brittle, because you'd have the freedom to lie by manipulating the context arbitrarily with `local`
05:21:10 <Solonarv> sensible
05:21:19 <boxscape> % undefined :: Int ~R# Sum Int => a
05:21:19 <yahb> boxscape: ; <interactive>:32:19: error: Not in scope: type constructor or class `R#'
05:21:25 <boxscape> can this be made to work somehow?
05:21:56 <dminuoso> boxscape: That looks a bit garbled.
05:22:00 <Solonarv> I'm not sure if there is a way to refer to ~R# directly in source haskell
05:22:07 <EvanR> % undefined :: Coercible Int (Sum Int) => a
05:22:07 <yahb> EvanR: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:33:1 in interactive:Ghci11
05:22:19 <dminuoso> What is ~R#?
05:22:29 <Solonarv> the magic behind Coercible
05:22:43 <boxscape> is it usable or is it just something in the docs?
05:22:44 <dminuoso> Huh what deep black magic..
05:22:51 <dminuoso> boxscape: Probably just in the docs.
05:22:58 <boxscape> hm, okay
05:23:01 <dminuoso> boxscape: https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Coerce.html
05:23:06 <dminuoso> boxscape: There's nothing there.
05:23:18 <dminuoso> % :i Coercible
05:23:18 <yahb> dminuoso: {-; Coercible is a special constraint with custom solving rules.; It is not a class.; Please see section 9.14.4 of the user's guide for details.; -}; type role Coercible representational representational; class Coercible a b => Coercible (a :: k0) (b :: k0); -- Defined in `GHC.Types'
05:23:24 <boxscape> well, you'd have to look at GHC.Types. There's not much there either though
05:24:00 <dminuoso> boxscape: Well Data.Coerce is where that weird superclass appears in.
05:24:19 <dminuoso> boxscape: GHC.Types documents it as `class Coercible a b`
05:24:41 <boxscape> that's true, but it's on the documentation of Coercible. The haddock is (in regular cases) taken from where something is defined, isn't it?
05:25:57 <Solonarv> this is not a regular case
05:26:31 <dminuoso> boxscape: GHC has several places where the haddock is specially crafted
05:26:35 <boxscape> I see
05:26:44 <dminuoso> boxscape: Consider that many features are not implementable in regular Haskell.
05:26:56 <dminuoso> Coercible is definitely deep magic
05:27:11 <dminuoso> (In the sense that the fact that it appears a typeclass is a hack)
05:27:26 <boxscape> I thought the way they did that was to define the data types in the source code and then just ignore that definition in the actual compiler, like with data [] a, but I guess it differs form case to case
05:27:42 <boxscape> (i.e. put the docs on that dummy definition)
05:27:43 <merijn> dminuoso: How does it appear as a typeclass?
05:28:15 <phadej> boxscape: it's done that way
05:28:24 <merijn> Or do you just mean "it's written as a Constraint"?
05:28:48 <dminuoso> merijn: Haddock tells you its a typeclass. GHCi says its a typeclass (I know the comment says differntly, but it ends up saying that there's `class Coercible a b => Coercible (a :: k0) (b :: k0); -- Defined in `GHC.Types'`
05:29:39 <boxscape> phadej I'm not seeing the docs from `Data.Coercible` on the dummy definition of Coercible in `GHC.Types`. Then again, I was wrong about [], it doesn't have any docs there either
05:29:48 <phadej> https://hackage.haskell.org/package/ghc-prim-0.5.3/docs/src/GHC.Types.html
05:29:54 <EvanR> "this class is not a class"
05:29:59 <phadej> there's both data [] a and class Coercible
05:30:25 <boxscape> phadej but it doesn't contain a reference to ~R# 
05:30:30 <boxscape> which is in the Coercible haddock
05:31:28 <dminuoso> boxscape: What I find really interesting is that it doesnt appear anywhere in the ghc repository
05:31:34 <boxscape> huh
05:31:40 <dminuoso> I mean its mentioned in plenty of source files, but I dont see where the constraint comes from
05:31:46 <dminuoso> Or rather that haddock page
05:31:58 <phadej> boxscape: ~#R is compiler internal, which you cannot write in the source
05:32:26 <dminuoso> phadej: How is that haddock page created though?
05:32:36 <phadej> the class Coercible definition is GHC.Types is not "ignored", it's amended by the compiler
05:32:47 <phadej> and haddock works with compiler representation of modules, not the raw source text
05:32:52 <dminuoso> Ahh
05:32:53 <boxscape> Ahh
05:34:30 <EvanR> not a class, but surely a constraint
05:35:00 <dminuoso> phadej: I take it the class is just written out such that haddock has something to latch onto?
05:35:06 <EvanR> maybe discussion on "what are type classes really" are really talking about constraints instead
05:35:12 <dminuoso> Or is there a different reason for that?
05:35:34 <dminuoso> EvanR: Well I suppose each typeclass induces a constraint. It makes sense to talk about them in isolation.
05:35:48 <dminuoso> instances are written for typeclasses, and constraints can exist without typeclasses
05:35:58 <phadej> dminuoso: I'm not sure, it's probably written so the compiler internals don't need to do manually that much stuff
05:36:26 <phadej> dminuoso: i.e. there's module with "class Coercible", but what that class actually represents is filled by compiler
05:36:26 <EvanR> and some instances are written (or generated by the compiler) for no class
05:36:52 <phadej> it's all very GHC specific
05:37:01 <phadej> another compiler might implement that differently
05:37:08 <dminuoso> % instance Coercible F F
05:37:08 <yahb> dminuoso: ; <interactive>:41:10: error:; * Illegal instance declaration for `Coercible F F' Manual instances of this class are not permitted.; * In the instance declaration for `Coercible F F'
05:37:22 <dminuoso> I feel cheated. :)
05:37:52 <EvanR> it would overlap anyway
05:38:12 <EvanR> if it wouldn't overlap it wouldn't be correct anyway
05:38:13 <dminuoso> EvanR: That wont stop me. Im always equipped with IncoherentInstances!
05:38:25 <boxscape> % instance Coercible a (IO a)
05:38:25 <yahb> boxscape: ; <interactive>:46:10: error:; * Illegal instance declaration for `Coercible a (IO a)' Manual instances of this class are not permitted.; * In the instance declaration for `Coercible a (IO a)'
05:38:40 <dminuoso> Perhaps its enough to pierce that shield!
05:38:44 <dminuoso> % :set -XIncoherentInstances
05:38:44 <yahb> dminuoso: 
05:38:46 <dminuoso> % instance Coercible F F
05:38:46 <yahb> dminuoso: ; <interactive>:48:10: error:; * Illegal instance declaration for `Coercible F F' Manual instances of this class are not permitted.; * In the instance declaration for `Coercible F F'
05:38:48 <dminuoso> Shame.
05:39:06 <dminuoso> Clearly an extension ManualCoercibleInstances is in order.
05:39:11 <EvanR> IncoherentInstances is like a rocket launcher for the type system :)
05:39:36 <dminuoso> EvanR: I have yet to see a single case where it would genuinely be useful
05:41:39 <EvanR> probably for bog standard wild abuse of type class mechanisms
05:47:21 * hackage dhall-yaml 1.0.0 - Convert between Dhall and YAML  https://hackage.haskell.org/package/dhall-yaml-1.0.0 (GabrielGonzalez)
05:48:18 <dminuoso> Fancy, I've never tripped into this functional dependency diagnostic before: https://gist.github.com/dminuoso/26cc115493d4763d5762b2bc8a549223
06:01:25 <EvanR> actually i take it back, going through the entire prelude, there is so little in it, it's almost like prelude is already empty
06:01:52 <EvanR> unlike clojure's prelude
06:02:05 <Ariakenom> hm, should I write an AoC Intcode computer in a bit twiddling, pointer poking style of Haskell?
06:02:26 <EvanR> you monster
06:05:08 <Ariakenom> I did the first day with Seq. But that was easy maybe I should learn "Haskell as a better C"
06:05:44 <boxscape> Ariakenom if it's too easy do it with typelevel prolog haskell by implementing everything just through classes and instances
06:06:18 <Solonarv> I did it with an STVector at first but switched to a pure Vector later
06:08:03 <Ariakenom> so ... type level C?
06:14:52 <EvanR> for a real challenge do the challenges in actual C
06:15:52 <EvanR> s/challenge/hairshirt/
06:18:21 <merijn> Solonarv: I did it with STVector and switched to IOVector :p
06:19:06 <dminuoso> Heh I too started with STVector..
06:19:19 <dminuoso> And was planning to switch to IOVector as well
06:19:43 <merijn> I heard I need to couple them in parallel later (I haven't caught up yet after last weekend) so now I feel justified in that being super simple now :p
06:20:16 <Solonarv> why did you switch to IO?
06:20:25 <merijn> Solonarv: For the input/output assignment
06:20:44 <Solonarv> ah, I just wrote it as a Conduit
06:21:03 <merijn> Solonarv: I figured it'd be only a small time before those had to be interleaved arbitrarily :p
06:21:13 <Solonarv> grabbing input / sending output is as simple as await/yield
06:21:45 <Solonarv> btw there is ##adventofcode and ##adventofcode-spoilers too
06:22:57 <merijn> Solonarv: Oh, that's also a neat idea
06:23:20 <dminuoso> But yeah, please move the spoilers and possible soluitions to the AoC spoiler channels
06:24:41 <tdammers> I generalized my intcode vm over the host monad and the input and output operations
06:25:17 <Solonarv> where is host from?
06:27:28 <tdammers> what I mean is you can run the VM in any monad you like, as long as the input and output operations can be written in terms of that monad
06:27:39 <Solonarv> oh, I see
06:28:13 <tdammers> programs that don't use input or output can be run against the Identity monad
06:28:33 <tdammers> but in the end, my host monad always ends up being IO
06:28:53 <merijn> tdammers: Ah, nice, but I think that'd quickly defeat my goal of being simple and understandable for intermediate Haskellers :p
06:29:20 <Bis1n1dem> hi
06:29:51 <tdammers> it's not that complicated really
06:31:01 <tdammers> runVMWith :: MonadVM m => (m Int) -> (Int -> m ()) -> m a -> VM -> m (ExitCode, VM, a)
06:31:02 <Zemyla> I have no idea why, but part of me likes the idea of abstracting input and output, like newtype InpOut a = InpOut { runInpOut :: forall r. (a -> r) -> (Char -> r -> r) -> ((Maybe Char -> r) -> r) -> r }
06:31:11 <tdammers> run-of-the-mill if you ask me
06:31:23 <tdammers> wait it's not actually that
06:31:41 <tdammers> runVMWith :: (MonadVM m Int) -> (Int -> MonadVM m ()) -> MonadVM m a -> VM -> m (ExitCode, VM, a)
06:33:12 <EvanR> what is the Maybe Char thing
06:33:55 <Zemyla> EvanR: That's the input combinator. It returns the next Char if there is one, or Nothing on EOF.
06:34:57 <EvanR> oh. and (a -> r) ?
06:35:09 <yasar> is there an inverse version of map? I need to apply list of functions to single argument and get a list of results
06:35:48 <Solonarv> you don't need a separate function for that, map can already do it
06:35:52 <EvanR> :t map ($ x)
06:35:53 <f-a> :t ($)
06:35:53 <MarcelineVQ> yes indeed, you can use map for this, just think on your description a bit :D
06:35:55 <lambdabot> [Expr -> b] -> [b]
06:35:56 <lambdabot> (a -> b) -> a -> b
06:35:56 <MarcelineVQ> ohno
06:36:14 <EvanR> #haskell-spoilers
06:37:46 <EvanR> ok (a -> r) is like Done
06:38:35 <MarcelineVQ> tho I like (\f -> f x) more than $ for this sort of spoiler since one doesn't need to wonder what $ is or ask what  ($ x) syntax means, unless that's part of your lesson :>
06:38:59 <EvanR> mo $ more problems
06:39:21 <tdammers> .oO(let apply f x = f x)
06:39:42 <tdammers> .oO(let appliedTo x f = f x)
06:39:59 <EvanR> map (`apply` x) -- now we're all sons of bitches
06:40:44 <f-a> > map _ [(+1), id]
06:40:46 <MarcelineVQ> now I am the son of the bitches!
06:40:50 <lambdabot>  mueval-core: Time limit exceeded
06:40:59 <f-a> > :t map _ [(+1), id]
06:41:02 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
06:41:05 <MarcelineVQ> tdammers: when I see those I think of like, a frog, blowing a bubble in stages that expands at the end and has that text inside of it, they're not whimsicle enough for thought bubbled :>
06:41:05 <f-a> :t map _ [(+1), id]
06:41:11 <lambdabot> error:
06:41:11 <lambdabot>     • Found hole: _ :: (Integer -> Integer) -> b
06:41:11 <lambdabot>       Where: ‘b’ is a rigid type variable bound by
06:41:44 <EvanR> smoke rings
06:43:31 <EvanR> tdammers: should be in prelude!
06:44:18 <yasar> histogram function is supposed to return String representation of an histogram -> https://gist.github.com/yasar11732/78e04bec0a722596ec7fb83677836a1d
06:44:25 <yasar> it just returns empty string
06:45:31 <f-a> > [10..0]
06:45:35 <lambdabot>  []
06:45:36 <f-a> yasar: ^
06:45:44 <f-a> > [10,9..0]
06:45:47 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0]
06:45:57 <yasar> ohh :)
06:46:25 <f-a> I hate .. syntax
06:48:03 <boxscape> john degoes suggested that we shouldn't use syntax in his talk on what the next great functional language might be like
06:48:45 <EvanR> we shouldn't use syntax? in his talk?
06:48:51 <EvanR> or at all
06:48:52 <dminuoso> Heh. mtl-style classes really gives you expotential growth in instances..
06:48:59 <dminuoso> *exponential
06:49:03 <f-a> audience on lsd
06:49:12 <boxscape> EvanR in the next great functional language
06:49:24 <EvanR> no syntax, so lisp?
06:49:31 <boxscape> no lisp has too much syntax
06:49:51 <boxscape> he was thinking of some sort of structured programming environment
06:50:00 <boxscape> I think sort of like lamdu if you've heard of that
06:50:34 <EvanR> earth isn't ready to leave the cradle of ascii grids
06:50:47 <boxscape> we could at least move to 3d grids at some point
06:51:51 <EvanR> raining down and green
06:52:46 <tdammers> MarcelineVQ: I'm fine with the frog image
06:52:54 <MarcelineVQ> yes
06:53:16 <tdammers> lisp has too many notions of "syntax" (and they're all wrong)
06:58:07 <dansho> i thought lisp syntax was extremely simple
07:01:56 <tdammers> dansho: it is, but what everyone else calls "syntax" is not what lispers call "syntax"
07:02:19 <maerwald> lisp in haskell: [f, [g, x]]
07:02:21 * hackage synthesizer-llvm 0.8.2.1 - Efficient signal processing using runtime compilation  https://hackage.haskell.org/package/synthesizer-llvm-0.8.2.1 (HenningThielemann)
07:02:39 <tdammers> runLisp :: Dynamic -> IO Dynamic
07:02:54 <EvanR> maerwald you are making my brain melt + explode
07:03:34 <yasar> Anyone up for a code review? https://codereview.stackexchange.com/questions/233877/cis-194-homework-3-histogram
07:04:41 <f-a> yasar: you can run hlint on it
07:04:47 <boothead> Hey folks - anyone know what dialect the xml output that hpc report --xml-output is? It looks a bit sparse to be supplying all the info a Jenkins coverage plugin might expect...
07:04:57 <maerwald> f-a: that gives mostly fishy suggestions :P
07:05:22 <f-a> http://www.ariis.it/link/t/paste22934-0 maerwald seems ok this time
07:05:24 <yasar> f-a How does it work? I am a new to this :)
07:05:32 <f-a> (turn off eta reduction)
07:05:50 <f-a> yasar: install hlint (I use cabal, so cabal new-install hlint, idk about stack)
07:05:52 <Ariakenom> hey fish, the shell, gives excellent suggestions
07:06:06 <f-a> then go hlint somefile.hs or hlint folder
07:06:14 <f-a> he gives some style and reduction suggestions
07:06:29 <maerwald> most of which are semi-interesting
07:06:34 <f-a> if you do not like what hlint says, you can turn off some kind of suggestions
07:06:44 <f-a> (I turn off eta reduce)
07:08:10 <f-a> yasar: also I think I found useful is
07:08:17 <f-a> solve a project euler problem
07:08:33 <f-a> and go on the wiki to check the solutions
07:08:56 <merijn> I think project euler makes for fairly bad Haskell practice
07:08:58 <f-a> a cosy way to see how other people approached the problem, and you might pick up a function or two ktp.
07:09:09 <merijn> it forces you to focus on the ugliest/most annoying parts of base/Prelude
07:09:12 <f-a> *etc.
07:09:12 <merijn> @where exercises
07:09:12 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems https://github.com/bitemyapp/learnhaskell http://www.reddit.com/r/dailyprogrammer/ http://www.reddit.com/r/programmingchallenges/
07:09:24 <f-a> 99 haskell problems are extra nice too
07:09:24 <merijn> Those have better/more programmy exercises
07:11:34 <c_wraith> if you're looking for exercises, the advent of code is running now, too.  They're designed to be short but not-totally-trivial programming problems.
07:13:09 <maerwald> yasar: use liquidhaskell to prove that 'histogram' is never called with numbers higher than 9 :P
07:13:52 <merijn> c_wraith: tbh, the difficulty of those ramps up rather rapidly if you're completely new to Haskell :)
07:15:43 <yasar> I installed hlint using cabal, but I am getting command not found error. Should I add something to PATH? (I am using Windows)
07:16:00 <f-a> mhhh yes but I am not sure which folder
07:16:06 <c_wraith> It's felt smoother this year than previous years, but the stats page shows cliffs in places I didn't expect.  Like, geometrical problems seem to result in much bigger drops than I'd expect
07:16:50 <Ariakenom> I thought I was gonna be brave and write some haskell on windows, then I tried.
07:17:34 <MarcelineVQ> Phyx- can save you, you need only reach out your hand when you fall
07:17:42 <merijn> c_wraith: Are you sure drops actually correlate with exercises? :p
07:18:15 <c_wraith> I expect a drop-off every day, as people get too much stuff to do
07:18:28 <merijn> c_wraith: If geometrical problems refers to the orbit thing, I didn't do that yet either due to having a busy life in the weekend and not having time to catch up this week :p
07:18:39 <c_wraith> No, the orbits thing was really easy.
07:18:50 <f-a> yasar: https://wiki.haskell.org/Cabal-Install#Windows found this, is the program there? (not a win user)
07:18:51 <c_wraith> the ones I'm looking at were days 3 and 10
07:19:21 <merijn> c_wraith: You underestimate how tricky the wires one is for people who don't see the "obvious" solution :)
07:19:24 <c_wraith> the orbits thing was just a graph traversal
07:20:17 <c_wraith> and it had a very small drop from the previous day.  Looks like people didn't have trouble with it, just the normal "life happens" stuff
07:20:20 <Solonarv> yasar: yes, by default binaries go to %APPDATA%\cabal\bin\
07:20:50 <Solonarv> which is usually C:\Users\YOUR-USER-NAME\AppData\Roaming\cabal\bin\
07:21:11 <Taneb> Re: advent of code, I'm currently in an "I need to catch up" position
07:21:46 <merijn> Taneb: Join the club ;)
07:21:55 <yasar> There is no hlint in %APPDATA%\cabal\bin\, I am trying to reinstall
07:22:16 <f-a> yasar: which command did you invoke
07:22:22 <c_wraith> merijn: actually I have a friend who is not an experienced programmer working through these.  He got to day 3 last night and expressed an almost complete lack of ideas, except one he called "very brute-force".  Didn't hear how well it worked out, but I told him to at least try it and see if it gave him any ideas.
07:22:29 <yasar> cabal new-install hlint
07:22:41 <yasar> it looked like it worked, but can't find hlint.exe
07:22:46 <f-a> :s
07:23:02 <c_wraith> merijn: so I expect I will soon have a better understanding of how difficult it is to inexperienced people
07:23:49 <aplainzetakind> > head . snd $ fmap (0:) (undefined :: (Int, [Int]))
07:23:53 <lambdabot>  *Exception: Prelude.undefined
07:23:58 <aplainzetakind> :(
07:24:03 <merijn> c_wraith: My girlfriend is working through them with very limited programming experience, she's at day 5 or 6 now. But the main reason she figured out how to do it is because last year's AoC had one that involved computing overlapping tile sets and I showed her to do it using Set
07:24:10 <aplainzetakind> > head . snd $ fmap (0:) (undefined, undefined)
07:24:13 <lambdabot>  0
07:24:25 <aplainzetakind> Can I get as lazy as the former example somehow.
07:24:26 <aplainzetakind> ?
07:24:27 <merijn> c_wraith: I think she would've been entirely lost without that solution to crib from
07:24:33 <boxscape> yasar personally in those cases on windows I use voidtool's "everything" program to find where hlint.exe is
07:25:11 <aplainzetakind> I'm writing a go pattern where I want to compute an (a, [b]), but I want the [b] to be lazily available.
07:25:57 <aplainzetakind> I thought of recursing by go ... = (n :) <$> go ... and bottoming out with (...,[]).
07:26:03 <aplainzetakind> But it seems it won't do.
07:26:10 <c_wraith> fmap is too strict.
07:26:24 <c_wraith> it does a case match on the tuple
07:27:35 <aplainzetakind> Have to think of something else then.
07:27:42 <nil> i solved that by using [(a, b)] instead
07:28:00 <MarcelineVQ> nothing too different, just write your own lazier fmap,  tmap f ~(a,b) = (a,f b)
07:28:30 <aplainzetakind> MarcelineVQ: Without involving paterns, how?
07:28:49 <boxscape> % tmap f ~(a,b) = (a,f b)
07:28:49 <yahb> boxscape: 
07:28:57 <boxscape> % head . snd $ tmap (0:) (undefined :: (Int, [Int]))
07:28:57 <yahb> boxscape: 0
07:29:31 <aplainzetakind> What's the ~? This is entirely new to me.
07:29:42 <Solonarv> note that this tmap breaks the functor law: tmap id /= id
07:29:42 <boxscape> it makes the pattern irrefutable
07:29:55 <Phyx-> yasar: make your life easier.. https://chocolatey.org/packages/cabal
07:30:00 <Solonarv> because tmap id undefined = (undefined, undefined) /= undefined
07:30:13 <Solonarv> that's why it is not the implementation for fmap
07:30:35 <boxscape> aplainzetakind it has to take that pattern, and since it doesn't need to decide *whether* to match on that pattern, it doesn't need to know whether the constructor is actually there
07:30:50 <aplainzetakind> I see.
07:30:54 <aplainzetakind> Thanks all.
07:31:08 <boxscape> aplainzetakind a pattern in let like `let t@(a, b) = undefined in t` always works this way (unless you prefix the pattern with !)
07:31:17 <Phyx-> yasar: but yes, if you download it from the cabal website you need to configure your path and also update cabal config manually
07:31:19 <boxscape> % let t@(a, b) = undefined in t`
07:31:19 <yahb> boxscape: ; <interactive>:58:31: error: parse error (possibly incorrect indentation or mismatched brackets)
07:31:27 <boxscape> well, bad example
07:33:47 <c_wraith> merijn: did she figure out that it could be solved with a set intersection by herself? that's the part that felt a little like a trick.
07:33:56 <merijn> c_wraith: Yeah
07:35:02 <merijn> c_wraith: Although I guess we're now talking spoilers >.>
07:35:39 <c_wraith> I'm trying to be indirect about it, so someone really has to intend to be spoiled. :)
07:35:47 <Solonarv> hey I did it that way too
07:36:12 <Solonarv> sets are a cool trick
07:36:14 <lavalike> which problem are you talking about?
07:36:20 <Solonarv> day 3
07:36:26 <Solonarv> intersecting wires
07:36:32 <lavalike> oh yeah
07:37:00 * Phyx- really wishes cabal wouldn't store in %APPDATA% but that ship has sailed I guess
07:37:03 <lavalike> I was surprised to see people talking about simulating running the traces
07:37:49 <merijn> Phyx-: There was a ticket on remedying that, I think?
07:38:34 <Solonarv> I'm not very familiar with where stuff is supposed to be stored, where do you think it should store instead?
07:39:06 <merijn> Phyx-: https://github.com/haskell/cabal/issues/4597
07:39:22 <dminuoso> Why doesn't `nest` in this example nest the word "lorem" as well? https://hackage.haskell.org/package/prettyprinter-1.5.1/docs/Data-Text-Prettyprint-Doc.html#v:nest
07:40:24 <merijn> dminuoso: Nesting takes effect on the next newline
07:40:38 <merijn> dminuoso: for e.g. line continuations in source code
07:41:34 <merijn> dminuoso: See the "see also" section of its docs?
07:42:09 <merijn> dminuoso: Docs even mention "indentation of the following lines"
07:45:50 <merijn> Phyx-: So it looks like there's good will to move that folder, but someone who cares (as in, personally, as opposed to the abstract "yeah, we should fix that sometime") has to hunt down and manouver that change through all the various parts (i.e. fixing directory, updating cabal-install, etc.)
07:51:51 <dcoutts> Phyx-: you can configure it's location locally
07:53:13 <Solonarv> yes, but most people stick with the defaults
07:53:24 <Solonarv> so there is much value in having correct defaults
08:13:51 <aplainzetakind> I really thought snd . consumeOutput would work lazily but it doesn't (and I don't see why not): https://gitlab.com/aplainzetakind/aoc2019/blob/master/days/Advent19/Day11.hs
08:13:53 <seishun> is there a simple way to define a type for 4 directions and two functions to turn 90 degrees right or left?
08:14:25 <seishun> that is without writing 8 patterns
08:14:50 <opqdonut> seishun: you can cheat a bit with Enum, succ and pred I guess?
08:15:01 <opqdonut> well maybe not cheat
08:15:02 <phadej> succ won't wrap around
08:15:05 <f-a> opqdonut: they don't cycle
08:15:07 <phadej> the generated one
08:15:07 <opqdonut> yeah you need one case for that
08:15:20 <opqdonut> so maybe 4 cases in total instead of 8?
08:15:36 <opqdonut> dunno, I've just written out the cases usually
08:15:42 <aplainzetakind> toEnum . (`mod 4`) . (+ 1) . fromEnum
08:15:47 <aplainzetakind> Something like this.
08:15:56 <phadej> + 1 is succ :)
08:16:00 <opqdonut> if you represen the direction as (xdiff,ydiff) you could get by with just one case I think?
08:16:07 <opqdonut> mod+fromEnum seems nice
08:16:20 <f-a> right = left . left . left
08:16:30 <boxscape> % data Dir = N | E | S | W deriving (Enum, Show)
08:16:30 <yahb> boxscape: 
08:16:43 <aplainzetakind> opqdonut: I really don't think it's worth the loss of clarity. I myself wrote out the 8 cases.
08:17:09 <Solonarv> I just used a V2 0 1 to start with and modified it with by with 'perp' for left turns or '-perp' for right turns
08:19:07 <boxscape> don't need to hardcode `mod 4` if it's bounded, you can use `mod maxBound`
08:19:14 <boxscape> or wait
08:19:25 <boxscape> that would be completely wrong
08:19:41 <Solonarv> &mod (fromEnum maxBound)$
08:19:41 <Taneb> boxscape: that should generally be id
08:20:12 <Solonarv> and of course you now need a type annotation to specify which maxBound you mean
08:20:35 <boxscape> right.. this is starting to get annoyingly verbose. I'd still prefer it over hardcoding though
08:21:10 <Solonarv> I feel the same, that is why I ditched 'Dir' and just used a vector
08:21:15 <boxscape> you also need to do +1 I think because fromEnum maxBound for 4 possibilities is 3
08:21:57 <Solonarv> oh, yes
08:23:11 <seishun> I think I'll go with succ and prev + 2 special cases
08:23:57 <aplainzetakind> Isn't there a finite cyclic group library or something?
08:24:25 <jle`> aplainzetakind: there's finite-typelits
08:26:54 <yasar> Can I get pre-built version of hlint somewhere? cabal complains that I don't have MinGW+msys although I have it installed with haskell platform
08:26:57 <Solonarv> unfortunately the Enum (Finite n) instance is not cyclic
08:27:10 <Solonarv> the Num instance is, though
08:27:25 <Solonarv> so you could use (+1) but *not* succ
08:27:38 <jle`> yeah, you succ is kind of weird for numeric types anyway
08:27:50 <jle`> s/you succ/succ
08:28:09 <jle`> sorry, that wasn't meant to come off so aggressively :)
08:28:18 <Solonarv> :>
08:29:01 <phadej> Solonarv: it's actually a "law" of Enum
08:29:02 <phadej> The calls succ maxBound and pred minBound should result in a runtime error.
08:29:12 <phadej> in https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Enum
08:29:23 <merijn> phadej: Atrocity, that >.>
08:29:35 <phadej> i.e. either you cycle or you are not bounded
08:29:45 <phadej> argh, if you cycle, you are not bounded
08:29:55 <phadej> sounds like something dutch person would say
08:30:10 <boxscape> yasar what I'm doing on WIndows - though I wouldn't really recommend it for most people - is using the nix package manager inside the Windows subsystem for Linux, and nix has prebuilt binaries for the hackage packages
08:31:36 <dminuoso> merijn: Mmm fair enough. 
08:32:05 <boxscape> > succ (maxBound :: Int)
08:32:08 <lambdabot>  *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
08:32:26 <boxscape> succ{Int}, haven't seen that notation before
08:32:34 <dminuoso> % :t succ
08:32:34 <yahb> dminuoso: Enum a => a -> a
08:32:43 <dminuoso> % :t maxBound
08:32:43 <yahb> dminuoso: Bounded a => a
08:32:48 <dminuoso> Wow magic.
08:32:56 <boxscape> presumably the consistent way to write it would be succ @Int
08:33:10 <dminuoso> How does the RTS know `maxBound` was used?
08:33:16 <boxscape> does it?
08:33:27 <phadej> boxscape: yeah, I do write that in some partial class implementations (but I never to that, except sometimes)
08:33:31 <boxscape> > succ ((maxBound :: Int) - 1)
08:33:36 <lambdabot>  9223372036854775807
08:33:41 <boxscape> it does, huh
08:33:46 <boxscape> wait
08:33:52 <boxscape> > succ $ succ ((maxBound :: Int) - 1)
08:33:56 <lambdabot>  *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
08:33:59 <boxscape> it doesn't
08:34:01 <boxscape> that makes more sense
08:34:42 <geekosaur> this is specific to the Int implementation of succ. and nobody updated it to use TypeApplications syntax.
08:34:55 <geekosaur> it's not wired into the compiler or anything like that
08:35:04 <boxscape> fair, though it's Core syntax as well, right?
08:35:15 <dminuoso> % (maxBound :: Int)
08:35:15 <yahb> dminuoso: 9223372036854775807
08:35:22 <geekosaur> I don't think so. TypeApplications came from Core syntax
08:35:29 <boxscape> that's what I meant
08:35:45 <geekosaur> {} around a type is sometimes used as an annotation in a comment, iirc
08:36:41 <dminuoso> boxscape: It's just some hardwired error text as far as I can tell
08:37:07 <boxscape> yeah I figured, just interesting to me that they chose to write the error in this way
08:37:10 <Solonarv> > succ (255 :: Word8)
08:37:15 <lambdabot>  *Exception: Enum.succ{Word8}: tried to take `succ' of maxBound
08:37:35 <Solonarv> haha, it's not even consistent
08:37:46 <Solonarv> Prelude.Enum.succ vs. Enum.succ
08:37:47 <Lycurgus> y not?
08:37:57 <boxscape> % succ W
08:37:57 <yahb> boxscape: *** Exception: succ{Dir}: tried to take `succ' of last tag in enumeration; CallStack (from HasCallStack):; error, called at <interactive>:5:36 in interactive:Ghci5
08:38:17 <Lycurgus> it's logically the same
08:38:21 <boxscape> so it *is* built into the compiler, in a way - deriving generates it
08:39:19 <Solonarv> yes, I am merely complaining that the error message is slightly different
08:39:20 <dminuoso> boxscape: It's a relict from 2002 introduced by simon marlow.
08:39:28 <boxscape> Ah, interesting
08:39:42 <dminuoso> boxscape: From the looks of it, it was just part of when GHC.Word was introduced.
08:39:47 <dminuoso> boxscape: So it was never refactored ever since.
08:39:48 <boxscape> ok
08:39:56 <dminuoso> At least not the format.
08:40:11 <dminuoso> boxscape: refer to f478c5a402171458caf35b5cf4b53de6723bc212
08:40:22 <boxscape> thanks
08:40:36 <dminuoso> Is it possible that this was supposed to be some latex thing?
08:41:59 <Solonarv> I doubt it
08:42:03 <Solonarv> there's no backslash :P
08:52:39 <zincy_> Does Base have some built in  (Show a) => [a] -> Text
08:54:09 <boxscape> zincy_ the Text type is defined in the text package, not in base
08:54:33 <zincy_> Oh thanks
08:54:36 <boxscape> nonetheless it doesn't seem obvious to me what this function should do
08:54:40 <zincy_> There is a package called text-show
08:55:08 <zincy_> T.pack . showList?
08:55:09 <boxscape> there's also showText in the text pacakge zincy_
08:55:30 <zincy_> boxscape: Thanks
08:55:39 <boxscape> (but it doesn't take a list)
08:56:16 <yasar> Figured out what was wrong with my cabal, it turns out I was missing a semicolon in my PATH variable
08:56:33 <yasar> Therefore, it couldn't find mingw executables
09:01:40 <dminuoso> % :t inRange
09:01:40 <yahb> dminuoso: Ix a => (a, a) -> a -> Bool
09:01:51 <dminuoso> Gah! This is terribly named. :(
09:02:00 <dminuoso> someRange `inRange` 10
09:02:43 <c_wraith> not named for infix use
09:03:23 <dminuoso> c_wraith: Yeah I assumed as much. The order makes sense when partially applied
09:04:37 <c_wraith> that's actually one of the worst parts of Haskell. no really. naming conventions only make sense for one of prefix or infix use for non-commutative operations!
09:05:35 <boxscape> they could have made it so that `function` implicitly flips the arguments of the function :)
09:07:30 <svipal> was gonna yell but that would have been coolos if it was done at the start
09:07:55 <day> im trying to remove and reinstall all haskell packages on arch because its a giant mess
09:08:20 <day> any hints? it's a huge dependency hell :|
09:08:27 <c_wraith> on Arch, I'd strongly recommend just not using anything Haskell from the package manager.
09:08:46 <day> so no cabal?
09:09:02 <day> ah misread 
09:09:26 <day> yes i can see why now~ however what is done is done, now i need to purge it
09:09:34 <maerwald> c_wraith: at this point, I'd have so little confidence that arch maintainers do a better job at a given different package... 
09:09:48 <maerwald> that it's probably better to install ubuntu even :P
09:11:28 <maerwald> most traditional PMs can't handle haskell packages well though
09:11:30 <f-a> day: maybe folks in #archlinux know someting?
09:11:53 <day> yeah they suggested pacman -Qs haskell | pacman -R - but that doesnt work :{
09:11:54 <c_wraith> so... if you're rebuilding it all anyway, why not uninstall everything Arch installed, then switch to using ghcup and cabal or stack?
09:12:21 <day> c_wraith: the problem is the 'uninstall' part
09:12:43 <c_wraith> ah. I don't know Arch enough to help with that.
09:12:49 <svipal> does anyone here one use nix on debian ?
09:12:54 <f-a> can you concot something from pacman -Qs haskell?
09:13:05 <day> the dependencies look like an inverted tree
09:13:15 <tdammers> svipal: I have a nixos vm on a debian host, I don't think that counts :D
09:13:23 <svipal> hahaha
09:14:56 <svipal> I still haven't been able to build leksah on a non NixOs distrib
09:16:43 <f-a> well done day 
09:17:40 <f-a> for the *install* part, I suggest forgetting about arch
09:25:49 <jonatan> day: what do you mean by doesnt work? -Qs outputs more than just package names, and you'd have -R complaining about the input its getting
09:26:44 <jonatan> so you'd get some pretty self-evident messages like: "error: target not found:     Deriver for Data.Vector.Unboxed using Template Haskell"
09:26:45 <day> jonatan: well it was something someone suggested yesterday
09:27:24 <day> i know what Qs outputs, so i figured i knew what would get deleted, but how the | -R - magic was supposed to work i didnt question ^_^
09:27:40 <jonatan> and if so you could ask pacman -Q to only output the package names instead of descriptions
09:53:51 <Phyx-> merijn: Yeah I know, I'm the one who raised it :) but the issue is backwards compatibility
09:54:20 <Phyx-> dcoutts: yes It's not an issue for me.. but my problem is those who don't know..
09:55:30 <Phyx-> yasar: installing platform *still* requires you to point cabal to msys2 or work only in the msys2 branch. (I think the latest platform may not need this but not sure)
09:55:58 <Phyx-> but essentially, if you use chocolatey it's all automatic. just install `haskell-dev` and you will get everything configured from top to bottom
09:56:06 <phadej> Phyx-: I'm open to changing the cabal location defaults
09:56:45 <phadej> Phyx-: iirc directory does the wrong thing, but it's not like we have to be restricted by that
09:56:49 <Phyx-> phadej: yeah I think the problem we encountered last time was how to migrate, especially for users that have libraries and exes installed in the old paths
09:57:25 <Phyx-> and we didn't have a good answer for that at the time...and I missed the boat to change it for new-build (was too busy :( )
09:57:32 <phadej> Phyx-: solution is to not migrate, they can copy over the config file with old paths to new place
09:58:10 <phadej> Phyx-: the new windows users won't notice anything, old will notice and decide whether "libraries and exes in the wrong place" are really that important to keep
09:58:25 <phadej> tl;dr, i'm not afraid to break windows users
09:58:36 <Phyx-> phadej: yeah, that seems sensible. but how do we commmunicate that change?
09:58:49 <phadej> Phyx-: if people don't read changelog, all is lost anyway
09:58:58 <Phyx-> tbh, I don't think the break would be that bad. new-build will just do some extra building the first time
09:59:04 <phadej> yes
09:59:31 <phadej> users would need to adjust PATH I guess?
09:59:36 <phadej> or something like that
09:59:48 <phadej> as new installed things won't appear
09:59:53 <Phyx-> yeah, I can adjust it automatically through chocolatey though
10:00:12 <phadej> and if you leave old one there, things would "work"
10:00:50 * hackage fastsum 0.1.1.1 - A fast open-union type suitable for 100+ contained alternatives  https://hackage.haskell.org/package/fastsum-0.1.1.1 (patrick_thomson)
10:01:22 <phadej> the people who have custom configuration will be annoyed, but if they configured once, they know what to do :)
10:01:39 <phadej> maybe they are the people who are annoyed with wrong defaults to begin with!
10:01:45 <Phyx-> phadej: oh and I still need to take a look at that temp file issue you raised.. I'm afraid that may be a GHC bug though.... I've noticed a potential for that to go wrong a while ago but since it's code that's been unchanged for years so I didn't chnage it.. looks like I'll have to
10:02:58 <phadej> Phyx-: it looked to be very transient, as it's not happening now on appveyor; yet if it can be fixed, that's better
10:04:14 <Phyx-> phadej: I believe it's another race condition.. I think Microsoft must have changed something in process handlings in recent updates.. it's pointing out things that we just happen to get away with all these years but that are wrong..
10:04:22 <Phyx-> same cause as what broke hsc2hs
10:08:04 <int-e> > let f x | x <- x+1, x <- x*2 = x in f 4
10:08:07 <lambdabot>  10
10:09:11 <int-e> Haskell is an imperative programming language with variable updates... not really, but with code like that it starts to feel like it!
10:09:27 <lavalike> haha
10:09:51 * hackage haskey 0.3.1.0 - A transactional, ACID compliant, embeddable key-value store.  https://hackage.haskell.org/package/haskey-0.3.1.0 (hverr)
10:11:20 <int-e> And actually I find this oddly appealing... much easier on the eyes than adding a prime for every new "updated" value.
10:11:31 <lavalike> gotta agree
10:11:48 <int-e> and shadowing the old value is actually helpful too
10:13:16 <lavalike> and you can use those matches to bail out of the particular branch of 'f'!
10:13:38 <dsal> I don't quite understand that syntax.  What's the <- ?
10:14:37 <int-e> dsal: It's a pattern guard
10:15:07 <lavalike> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-460003.13
10:15:07 <dsal> I get the |, but I didn't know you could put a <- there.  It looks like the same thing as a list comprehension, but I guess I considered that a bit more special.
10:15:31 <int-e> > f x | Just y <- lookup x [(1,2),(3,4)] = y | otherwise = 42 in map f [1..3]
10:15:38 <lambdabot>  <hint>:1:5: error: parse error on input ‘|’
10:15:41 <int-e> > let f x | Just y <- lookup x [(1,2),(3,4)] = y | otherwise = 42 in map f [1..3]
10:15:45 <lambdabot>  [2,42,4]
10:16:05 <dsal> Neat.
10:16:44 <int-e> dsal: It was meant to be used like this... pattern matching the result of a function (in this case, checking a successful lookup). But one can put any pattern there including ones that never fail.
10:17:24 <dsal> I didn't know I could <- there.  That's pretty helpful because I've been annoyed at my inability to do that. heh
10:17:43 <int-e> it's the same syntax as in list comprehensions
10:17:44 <dsal> I do patterns that always fail as a trace hack.
10:17:59 <int-e> (minus lets)
10:18:45 <int-e> oh... even lets are allowed. that's wild.
10:18:53 <int-e> > let f x | c <- 1, let q = 42, otherwise = q
10:18:55 <lambdabot>  <no location info>: error:
10:18:55 <lambdabot>      not an expression: ‘let f x | c <- 1, let q = 42, otherwise = q’
10:19:05 <int-e> > let f x | c <- 1, let q = 42, otherwise = q in f 0
10:19:08 <lambdabot>  42
10:19:28 <nitrix> Hello. If anyone is aware of a way to compile a language with first-class environments, could they point me to good literature on the subject?
10:19:38 <int-e> wild, because I don't revall ever seeing a let in a guard context.
10:19:44 <int-e> v->c
10:20:28 <lavalike> oh yeah it's right there, local declarations too
10:32:56 <svipal> Wooow you can do that ??
10:33:06 <svipal> `let f x | x <- x+1, x <- x*2 = x in f 4`
10:33:49 <svipal> is this monad comprehension ?
10:34:10 <dsal> It's pattern guard.  See link above.  :)
10:35:10 <svipal> amazing
10:43:37 <day> when recursively creating a list ala  `(x:xs) = x : func xs` where `func xs` returns Nothing | Just, how do i only add the Just's to my list, while skipping the Nothings?
10:43:50 <lavalike> :t catMaybes
10:43:52 <lambdabot> [Maybe a] -> [a]
10:47:27 <day> curious, does this cause the program to actually create the nothing,just list and then filter it, or will the actual program create the final list right away?
10:47:39 <boxscape> @src catMaybes
10:47:40 <lambdabot> catMaybes ls = [x | Just x <- ls]
10:48:22 <boxscape> Unless some optimization is going on it will have to construct the list and then filter it
10:48:26 <lavalike> I think there are chances for optimization but I wouldn't rely on it
10:48:32 <boxscape> or rather, you're giving it a list to begin with
10:48:46 <day> :(
10:49:01 <dsal> day: What are you trying to do?
10:49:17 <lavalike> you could write your own pattern matching if it turns out it is actually spending time and memory on that I guess
10:49:44 <boxscape> day what is the type of func in your example?
10:49:48 <day> just tinkering around a little with advent of code and haskell
10:49:54 <dsal> :t mapMaybe
10:49:56 <lambdabot> (a -> Maybe b) -> [a] -> [b]
10:50:11 <lavalike> yay AoC, it's been so much fine this year for me
10:50:40 <day> not a fan of these multi day challenges but aside from those yes it is great
10:51:02 <dsal> Just do them all at once.  No need for multiday.
10:51:10 <lavalike> I'm biased because my approach turned out to be very well suited for the next ones so they made me extra happy
10:51:46 <day> idk it becomes more an implementation challenge than an actual solving challenge
10:52:23 <dsal> The biggest challenge for me is reading comprehension.  I'm a lot better at reading/writing code than English.
10:52:57 <day> with all the examples he is giving i find the comprehension part quite easy
10:55:30 <boxscape> what is the time complexity of `head . sort`?
10:55:55 <koz_> boxscape: I don't believe sort defers to partial sorting, so it's Theta(n log(n)) most likely.
10:56:20 <koz_> (you might have to sort the entire list before you know the first element.
10:56:21 <koz_> )
10:56:28 <boxscape> hm, okay
10:56:33 <day> the head part shouldnt even matter right?
10:56:43 <boxscape> day it could due to lazinesss
10:56:49 <koz_> boxscape: Not in general.
10:56:56 <dsal> :t minimum
10:56:59 <lambdabot> (Foldable t, Ord a) => t a -> a
10:56:59 <koz_> If you want 'give me the minimal element' just say so.
10:57:06 <boxscape> right, by that I meant, that was my motivation for asking
10:57:09 <koz_> That's Theta(n) guaranteed.
10:57:29 <dsal> A rule could rewrite `head.sort` to `minimum`, but that's not reasonable.
10:57:34 <boxscape> yeah it doesn't make sense in this case but it gets more interesting once you have `take k . sort`
10:57:42 <day> is Theta == 'big O' notation?
10:57:53 <dsal> theta is more like, "expected"
10:58:15 <boxscape> Theta is big O combined with big Omega, so bounded above and bounded below
10:58:38 <koz_> I think giving Theta bounds is more useful.
10:58:52 <koz_> Because I could, for example, say 'bucket sort is O(2^n)'.
10:59:00 <koz_> Or 'bucket sort is Omega(1)'.
10:59:09 <koz_> Both are factually correct statements, but they're pretty useless.
10:59:33 <boxscape> eh, upper bounds can be useful
11:00:20 <koz_> boxscape: As for the 'take k . sort' situation, you're still Theta(n log(n)) for the same reason.
11:00:31 <koz_> (you might have to sort the whole list before you know the first k)
11:00:40 <boxscape> okay, yeah, that makes sense
11:00:41 <day> not sure how lower/ upper bounds matter if you are merely talking about the scaling though
11:00:57 <koz_> day: I can correctly state that array indexing is O(n^n).
11:01:06 <koz_> There is nothing factually wrong with that statement.
11:01:15 <day> yeah that's what i mean
11:01:18 <koz_> Nor with the statement that brute-force SAT solving is Omega(1).
11:01:24 <koz_> Both are correct, but utterly worthless.
11:01:29 <boxscape> I've never seen anyone use Omega bounds
11:01:42 <koz_> If you just give me an upper (same with lower) bound, I have no idea whether they're 'tight' or not.
11:01:49 <koz_> Give me Theta? I know instantly.
11:01:57 <koz_> boxscape: I have a few times for hardness proofs.
11:01:58 <day> when you ask 'how long does it take' then there are best/worst case upper/lower bound situations
11:02:07 <boxscape> ah, yeah for proofs I can see it
11:02:07 <koz_> (for instance, that you can't beat n log(n) for comparison sorting)
11:02:25 <koz_> (thanks, Stirling approximation!)
11:02:41 <koz_> boxscape: If you're interested in partial sorting, I happen to have a degree in it. :P
11:02:45 <koz_> (no seriously)
11:02:46 <Ariakenom> in order to use theta instead of O you'd need to prove it isn't better. which you may not want
11:02:52 <boxscape> oh, neat
11:03:13 <koz_> Ariakenom: For a problem, sure. For a specific algorithm?
11:03:56 <koz_> day: The default analysis is worst-case asymptotic RAM.
11:04:05 <Solonarv> in order to use Theta instead of O you need to figure out how to type it, which is why people get used to just typing O
11:04:15 <koz_> Solonarv: Yes, that is annoying. :P
11:04:28 <koz_> Something about mathy types are their Greek letter fetish. :P
11:04:29 <Ariakenom> koz_: true, that's harder for problems
11:04:32 <koz_> s/are/and/
11:05:00 <Ariakenom> you can also use theta when you want to say how bad something is and O when saying how good something is
11:05:02 <boxscape> frankly I'm glad mathematicians managed to mostly resstrict themselves to just two major alphabets
11:05:11 <boxscape> (plus symbols)
11:05:14 <koz_> boxscape: Greek and which?
11:05:18 <boxscape> Latin
11:05:24 <koz_> There's some use of Hebrew among set theorists.
11:05:37 <boxscape> ah, right, like aleph 0 and such
11:05:43 <koz_> Yeah, and the beth numbers.
11:05:48 <Ariakenom> Solonarv: I think I  did some statistics course where Ordo and Theta were reversed. quite annoying
11:05:52 <koz_> (well, 'numbers')
11:06:01 <Solonarv> fortunately, I have a compose key :>
11:06:18 <Solonarv> ...or I just write TeX
11:06:25 <koz_> At least for me, in the context of algorithms, I prefer to give Theta bounds where I can.
11:06:35 <koz_> (which, for common stuff, is usually quite possible)
11:06:47 <koz_> (unless it's my Master's research with board-fulls of log-based series...)
11:06:52 * koz_ shudders.
11:07:32 <dsal> I do agda stuff on Wednesdays...
11:07:44 <koz_> dsal: Is Wednesday Agda day now? :P
11:07:56 <koz_> (Agday?)
11:08:04 <dsal> haha.  Yeah, in < an hour.
11:08:10 <dsal> We write stuff like this:  cong-app : ∀ {A B : Set} {f g : A → B} → f ≡ g → ∀ (x : A) → f x ≡ g x
11:08:24 <dsal> Or...  cong₂ : ∀ {A B C : Set} (f : A → B → C) {u x : A} {v y : B} → u ≡ x → v ≡ y → f u v ≡ f x y
11:08:59 <Solonarv> I'm quite pleased that that all rendered correctly for me
11:09:07 <Solonarv> no missing glyphs here!
11:09:13 <koz_> Solonarv: Nor here.
11:09:21 <koz_> We take Unicode coverage seriously in the koz_ household.
11:10:43 <koz_> Also, dsal, am I misunderstanding, or is cong-app a fancy restatement of the functor law?
11:11:15 <dsal> That's a function signature.  The implementation is   cong-app refl = λ x → refl
11:11:59 <dsal> I missed last week's class.  It's a proof language.  We build tools to build proofs of things.
11:20:33 <boxscape> koz_ it doesn't look like any functors are involved?
11:21:17 <dsal> "Set" is Agda for "Type"
11:25:29 <boxscape> it's the complement of the usual congruence theorem (using Haskell syntax) `cong :: forall a b (f :: Type -> Type) . a :~: b -> f a :~: f b`
11:27:47 <boxscape> (with the implementation `cong Refl = Refl`)
11:34:40 <Ailrun[m]> koz_: cong-app looks more like the converse of function extensionality...
11:34:54 <koz_> Good to know, thanks folks.
11:42:58 <boxscape> ugh there are too many haskell-related things I want to do for the time I have
11:43:08 <Clint> yes
11:58:06 <koz_> Much yes.
11:59:50 * hackage tree-sitter 0.7.1.0 - Unstable bindings for the tree-sitter parsing library.  https://hackage.haskell.org/package/tree-sitter-0.7.1.0 (patrick_thomson)
12:43:22 <AWizzArd> https://github.com/parsonsmatt/servant-persistent/blob/master/src/Config.hs – AppT derives Monad, MonadIO and others. Why then are there such constraints in lines 63 and 67?
12:44:50 <amalloy> AWizzArd: the derived instance depends on a constraint
12:45:20 <dmwit> AWizzArd: The constraints are about m, not AppT m.
12:45:46 <amalloy> try compiling with -ddump-deriv and you will see something like: instance Monad m => Monad (AppT m) where ...
12:52:43 <AWizzArd> thx amalloy and dmwit
12:54:20 * hackage pandoc-citeproc 0.16.4.1 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.16.4.1 (JohnMacFarlane)
12:54:31 <sshine> is there a reason why there's no Data.List.unfoldl?
12:55:06 <monochrom> What would "unfoldl" mean?
12:55:10 <Solonarv> yes: there is no way for it to be any better than reverse (unfoldr ...)
12:56:16 <pie__> is there a typical use case for bind in parser combinators?
12:56:23 <pie__> im trying to justify it to someone
12:56:37 <iqubic> pie__: Yes. It makes the do notation work.
12:56:39 <MarcelineVQ> pie__: do syntax is readable
12:56:40 <sshine> pie__, bind as in (>>=)? as opposed to what, applicative parsers?
12:56:51 <Athas> pie__: you need it for context-sensitive grammars.
12:57:00 <pie__> erk- yeah so im using a combinator library in python xD
12:57:03 <pie__> so no do notation
12:57:16 <Solonarv> a simple use case where you actually need bind:
12:57:16 <Solonarv> parseInt >>= \n -> replicate n parseChar
12:57:23 <Solonarv> this parses a length-prefixed string
12:57:30 <Solonarv> without bind, you can't write that
12:57:34 <pie__> ah that sounds simple enough!
12:57:53 <pie__> thanks, i think thats a great illustrative exmaple
12:59:40 <Solonarv> and length-prefixed strings are a real data type that is actually used, so that helps :D
12:59:55 <sshine> monochrom, I suppose it might strictly accumulate the result in a list. I don't know if I'd need it, I just wondered why there's a foldl and a foldr, but only an unfoldr. :)
13:00:14 <Solonarv> oh, IIRC you also need it for indentation-sensitive parsing
13:00:22 <Solonarv> which should make sense to a python programmer ;)
13:00:31 <sshine> hehe, good example.
13:01:00 <Solonarv> you can do it in the tokenizer first, so the actual parser can be context-free, but then your tokenizer needs to be monadic
13:01:59 <Boarders> if I have a list and a pipe that takes ints and produces Ints does anyone know how I can use it to produce a list of all the outputs it gives before stopping?
13:02:27 <monochrom> OK that sounds like you don't have a specification, you're just looking for symmetry over names, names poorly chosen and more accidental than meaningful to begin with.
13:03:34 <Solonarv> Boarders: sandwich it between 'yieldMany inputs' and 'toList', the runConduit the whole thing
13:04:02 <monochrom> Especially since there is a mathematical point of view that supports a symmetry between catamorphism (foldr if cons lists) and anamorphisms (unfoldr if cons lists), in which so-called "foldl" has no place, no reason to exist at all in the first place.
13:04:03 <Solonarv> the same thing (but with different names) should work with any of streaming libraries
13:04:20 <sshine> monochrom, was that for me? I defined it, and I accept that it's nothing more than 'reverse (unfoldr ...)'. perhaps I should rather ask why it won't be any better than 'reverse (unfoldr ...)'; what if it were strict-by-default? wouldn't that be like picking between foldr and foldl'?
13:04:20 <iqubic> The hell is this type error?!?!? http://dpaste.com/0BC1222
13:04:42 <sshine> monochrom, ok.
13:05:32 <monochrom> OK when I asked "what would it mean?" you should have shown the definition rather than vague word game like "strictly accumulate a list" (wth does that mean, mathematically?)
13:05:49 <sshine> iqubic, looks like you're mixing strict StateT and lazy StateT. they come from each their module.
13:05:51 * hackage primitive-containers 0.4.1 - containers backed by arrays  https://hackage.haskell.org/package/primitive-containers-0.4.1 (andrewthad)
13:07:36 <sshine> monochrom, I'll retract my question as it surely is as warranted as "foldl". :-P
13:12:27 <sondr3> anyone here using cabal2nix? I get a `Missing (or bad) header file: zlib.h` when doing `cabal new-build`, it works fine with `nix-build` but because of the build failure HIE crashes
13:13:22 <sondr3> how would I add the missing dependency to my nix-shell? With cabal2nix --shell it overwrites my shell.nix file, do I just make a (say) dependencies.nix file, import it in shell.nix and add the buildinputs there?
13:14:00 <lally> I get around this via stack2nix, and put in extra-deps for zlip
13:14:05 <lally> s/zlip/zlib/
13:14:26 <sondr3> I'll try to zlip it in there and see what happens
13:19:44 <sondr3> lally: thanks, pointed me in the right direction, it worked with `extra-libraries` in my .cabal file
13:22:10 <flatmap> can somebody help me what that means:
13:22:11 <flatmap> instance Functor ((->) r) -- Defined in ‘GHC.Base’
13:22:11 <flatmap> instance Functor ((,) a) -- Defined in ‘GHC.Base’
13:22:32 <flatmap> arrow and comma - this is weird :-P
13:22:40 <monochrom> Do you mind working over "instance Functor (Either a)" first?
13:23:06 <flatmap> I know either but I don’t get what the arrow and comma means
13:23:14 <flatmap> either -> Either
13:23:41 <monochrom> OK so it is a secret that "X -> Y" is syntax sugar for "(->) X Y", "(A,B)" is syntax sugar for "(,) A B"
13:24:10 <monochrom> So now they are on par with "Either U V" and we say "instance Functor (Either a)" not "instance Functor Either".
13:24:58 <monochrom> Example:
13:25:01 <flatmap> „X -> Y“ is part of a function type right?
13:25:24 <monochrom> > let { foo :: (,) Int Bool; foo = (,) 4 False } in foo
13:25:27 <lambdabot>  (4,False)
13:25:41 <ephemient> well also because the type syntax doesn't allow for sections
13:25:45 <monochrom> "X->Y" is the full function type.
13:26:09 <ephemient> e.g. can't write (r ->)
13:26:19 <iqubic> I'd love tuple sections.
13:26:49 <monochrom> But imagine a language that hates infix notation and makes you write "FunType X Y" whenever you would write "X -> Y" in Haskell.
13:26:50 <ephemient> tuple sections work fine in value-land
13:27:02 <monochrom> In that language we would have "instance Functor (FunType X)".
13:27:09 <flatmap> honestly I don’t get it … what exactly does comma and arrow mean …. I don’t even know how to google / hoogle for it. I found it by accident when typing „:i Functor“ in ghci :-)
13:27:22 <monochrom> Err "instance Functor (FunType x)"
13:27:46 <monochrom> If you understand "(Either a)" you understand "(FunType a)" and "(->) a"
13:28:00 <flatmap> FunType, ok :-)
13:28:03 <monochrom> So tell me you confess you don't understand "(Either a)" after all.
13:28:27 <flatmap> Either -> contains a left or right item, mutually exclusive
13:28:36 <ephemient> Either a b = (Either a) b, a -> b = (->) a b = ((->) a) b
13:28:43 <flatmap> that’s my understanding
13:28:52 <flatmap> left usually being „the error"
13:28:53 <monochrom> No, the part about why it is "Either a", not "Either" alone, and not "Either a b".
13:29:01 <ephemient> flatmap: not wht the values are
13:29:04 <ephemient> the types
13:29:47 <monochrom> In fact it sounds like you know "Either a b" but not "Either a".
13:29:58 <flatmap> yes, exactly
13:30:01 <maralorn> flatmap: (->) r is the Functor where "fmap f g x = f (g x)"
13:30:45 <monochrom> OK, another secret is what ephemient just said, "Either a b" is syntax sugar for "(Either a) b".
13:31:28 <monochrom> And maybe you also need to go back to working on "instance Functor Maybe" first.  Or rather, why it is not "instance Functor (Maybe a)"
13:31:48 <maralorn> And the Functor "(,) a" has the instance "fmap f (a,b) = ((f a),b)"
13:32:17 <monochrom> Do you already know the answer to that?  Why "instance Functor (Maybe a)" is wrong.
13:32:35 <flatmap> nope … I need to read further :-)
13:32:37 <maralorn> (I actually didn‘t know that there is a functor instance for tuple.^^)
13:32:59 <monochrom> It will be the same answer for why it is "Either a" and "FunType r", no more no less.
13:33:26 <monochrom> maralorn: Nooooo!!!!! f is applied to b.
13:33:37 <ephemient> maralorn: err, fmap f (a, b) = (a, f b)
13:33:43 <ephemient> oh, monochrom just said that
13:34:14 <tinga> Hi. When using the Maybe monad, and given a function that doesn't return Maybe, how can I adapt it? I've written this, guess something like this already exists?: intoMaybe :: (t -> a) -> t -> Maybe a; intoMaybe f v = Just $ f v
13:34:19 <svipal> does anyone here use the (->) monad to use the do notation in interesting places?
13:34:20 <ephemient> because it's fmap :: (b -> c) -> (,) a b -> (,) a c
13:34:22 <tinga> Feel free to tell me what to read up on :)
13:34:27 <svipal> similar to the comonad do trick
13:34:41 <dsal> tinga: s/Maybe// is just pure
13:35:09 <svipal> tinga, what's your use case ? usually I do Just.f 
13:35:10 <ephemient> join (,) a = (a, a) is a handy trick sometimes
13:35:17 <svipal> Just. f sorry
13:35:22 <svipal> space very important
13:35:33 <tinga> svipal, good point
13:35:39 <c_wraith> svipal: sure, when I have a combinator that works with any Monad, sometimes the function Monad does what I want.
13:36:08 <svipal> I need to expand my mind a bit regarding that usage
13:36:16 <c_wraith> svipal: that has come up more than once working with lenses, too, and their Functor/Applicative constraints.
13:36:46 <c_wraith> "oh, hey, I can pass a function here and things will just work!"
13:36:50 <solonarv> it does not actually require Monad (Applicative is enough), but I use liftA2 relatively frequently
13:36:50 <tinga> dsal, not sure how you would use `pure` here.
13:37:03 <dsal> :t pure . succ
13:37:05 <lambdabot> (Applicative f, Enum a) => a -> f a
13:37:29 <shachaf> "sometimes the function Monad does what I want" -- monad is my favorite function too!
13:37:32 <shachaf> @quote shachaf monad.*function
13:37:32 <lambdabot> shachaf says: Hmm, so is monad a useful function?
13:37:33 <maralorn> monochrom: Yeah, true. Just when writing that I was like: That’s weird, why is there a functor instance. It‘s very likely that people will swap the arguments …
13:37:50 <dsal> > let ps = pure . succ in   ps 5 :: Maybe Int
13:37:50 <solonarv> shachaf: yes, it parsed that way in my head too
13:37:53 <lambdabot>  Just 6
13:38:23 <tinga> dsal, thanks
13:38:36 <dsal> > let ps = pure . succ in   ps 5 :: Either String Int
13:38:39 <lambdabot>  Right 6
13:38:53 <dsal> "pure" adapts a pure value into your context.
13:39:15 <monochrom> Mocking Jay's heart is pure, just, and right. >:)
13:39:56 <dsal> > let ps = pure . succ in   ps 5 :: [Int]
13:39:59 <tinga> dsal yes, makes sense
13:40:00 <lambdabot>  [6]
13:40:01 <dsal> And contained in a little box.
13:40:30 <solonarv> monochrom: nice ;)
13:40:55 <monochrom> Why didn't I think of that earlier!
13:42:00 <flatmap> I am scared … how long are you guys doing haskell ?
13:42:13 <Rembane> Forever. 
13:42:53 <iqubic> I've only been doing it for like 3 years.
13:43:09 <monochrom> I don't know why it should matter.
13:43:23 <flatmap> what are the companies that actually use haskell… I would expect insurance companies and academia first
13:43:46 <dsal> Time doesn't matter as much when you're properly lazy.
13:43:50 <monochrom> When I started learning physics I did not worry about "how long has Feynman being doing physics?!"
13:43:57 <loli> startups also tend to use Haskell, at least a subset of them
13:44:01 <dsal> monochrom: how long has physics been doing?
13:44:48 <monochrom> When I started learning Chinese I did not worry about "how long has humanity been doing Chinese?!"
13:45:00 <monochrom> Granted, that was also when I was not thinking at all.
13:45:23 <monochrom> But the bliss is you'll do fine iff you don't worry about it.
13:45:28 <dsal> Til that one day you raised your hand in class to ask how to say "what was I thinking?" in Chinese.
13:45:42 <monochrom> The more you worry the more you'll fail.  Just get on with it.
13:45:53 <svipal> I want haskell, but with good metaprogramming
13:45:54 <flatmap> lol right … I just wanted to get an idea … since I am trying and still missing the point where I really feel productive with haskell and not the language but the problem I want to solve receives the main focus
13:46:05 <dsal> There is that sad feeling when learning something that's really great that you didn't learn it a long time ago.
13:46:17 <dsal> flatmap: how are you learning?
13:46:30 <svipal> I would honestly drop some dependent type fuckery just to get good metaprogramming
13:46:32 <Rembane> In Soviet Russia Chinese learns you 
13:46:44 <Rembane> svipal: What is good metaprogramming for you?
13:46:48 <EvanR> no i think monochrom learned chinese as a baby. I will be emersing my first child in haskell tyvm
13:46:51 <flatmap> from time to time e.g. on afternoon when trying to get something new that does not suck
13:47:02 <dsal> flatmap: Not when.  how? 
13:47:09 <d34df00d> svipal: elaborator reflection in Idris? :]
13:47:26 <monochrom> My secret is also that I didn't worry about applications early on.
13:47:27 <flatmap> reading haskell books, playing around with ghci, trying to understand things
13:47:54 <d34df00d> Do you become a seasoned haskeller once you start hating Prelude?
13:47:56 <dsal> flatmap: I found haskellbook.com pretty helpful.  I have a lot of projects, though.  That helps.
13:48:03 <monochrom> And lo and behold I was still faster to getting a small application done.
13:48:27 <flatmap> thanks for the link :-)
13:48:27 <iqubic> I'm finding advent of code to be a good way to learn Haskell.
13:48:31 <monochrom> (than people who learned application-orientedly)
13:48:39 <svipal> Rembane : I'm not too demanding, I just want No staging issues. no absurd restrictions, let me splice patterns  
13:48:44 <dsal> Yeah, I did about half the haskellbook, an AoC, and then the rest of the haskellbook.
13:48:55 <d34df00d> iqubic: I go to sleep about 30 minutes before a new AoC day, and that's pretty demotivating.
13:49:04 <svipal> d34df00d : can I choose just how lazy I want my values to  be in Idris 
13:49:19 <d34df00d> svipal: sure, just wrap them in Delay as needed.
13:49:27 <d34df00d> http://docs.idris-lang.org/en/latest/tutorial/typesfuns.html#laziness
13:49:33 <svipal> is the C ffi as simple as haskell ?
13:49:46 <svipal> will look into it
13:49:51 <EvanR> idris uses javascript instead of C for FFI :)
13:49:57 <d34df00d> Looks simple, but I don't have much experience neither with Haskell C FFI nor with Idris C FFI.
13:50:12 <d34df00d> Idris has JS FFI as well though (just in case you'd want to go in browser).
13:50:25 <svipal> And here I was almost sold
13:50:31 <EvanR> lol
13:50:38 <MarcelineVQ> erm js is a backend but the default backend is c
13:50:45 <svipal> Hahah jk I don't mind JS but I really need C FFI for my use cases
13:50:53 <svipal> and inline-c is just godly
13:50:59 <MarcelineVQ> IO is polymorphic over your chosen FFI
13:51:02 <d34df00d> I think you can have something inline-c-like.
13:51:09 <d34df00d> But I'm not aware of any readily available libraries.
13:51:40 <svipal> I will give the scheme family a chance before I dive into Idris. 
13:51:48 <d34df00d> I'm curious, though, what's the state of package management in Idris?
13:51:56 <d34df00d> I know there were some competing projects, but how are they going?
13:52:29 <MarcelineVQ> there's options but I'd be inclined to use nix or something if I wanted anything serious at this time
13:52:39 <d34df00d> > serious
13:52:40 <d34df00d> > idris
13:52:41 <lambdabot>  error: Variable not in scope: serious
13:52:43 <lambdabot>  error: Variable not in scope: idris
13:52:46 <svipal> lmao
13:53:00 <MarcelineVQ> They say the same about haskell you know.
13:53:27 <iqubic> nix is great.
13:53:30 <iqubic> I love Nix.
13:53:33 <iqubic> I use Nix.
13:53:39 <monochrom> I wonder if one day there is a language community that has the gut to stand up and say "we won't re-invent package management, just use nix or something".
13:54:18 <monochrom> every language does not need its own homemade package management system
13:54:18 <loli> haskellbook was a great resource for me, I read that and wrote an IRC bot when I started learning
13:54:28 <d34df00d> monochrom: but it's _fun_!
13:54:39 <Rembane> monochrom: I think writing a package management system is a rite of passage. 
13:54:46 <d34df00d> Or that, yes.
13:54:56 <EvanR> language 700 will have evolved to understand this point. Which is why it used existing leverage of NPM
13:55:06 <loli> dependent types ends up feeling like a nice LISP system, I'm still trying to understand F*'s metaprogramming however
13:55:36 <iqubic> monochrom: Haskell has hackage, Python has Pip, Node has NPM, Emacs has Melpa, Ruby has Gems, Rust has Crates.
13:55:47 <d34df00d> C++ has... ugh...
13:56:01 <EvanR> that list is too long to continue sorry
13:56:05 <Rembane> Come to think of it, PureScript used bower for quite a long time, still does.
13:56:12 <monochrom> OK great.  For every language X, ask "what is the most prominent application of X?", the answer is "its homemade package management system"
13:56:18 <iqubic> And every Linux distro has their own Package manager.
13:56:37 <svipal> > java tooling
13:56:41 <lambdabot>  error: Variable not in scope: java :: t0 -> terror: Variable not in scope: t...
13:56:53 <EvanR> java terror
13:57:09 <svipal> maven =)
13:57:26 <monochrom> haha how did you manage to get "terror" there?
13:57:42 <EvanR> join newlines
13:57:46 <d34df00d> Is there anything for elementwise Num derivation?
13:57:58 <svipal> such is the raw fear factor of java tooling
13:57:58 <d34df00d> I have (a, b, c, d) all implementing Num, and I want Num for the tuple of them.
13:58:15 <EvanR> > (1,2,3,4) + (4,3,2,1)
13:58:19 <lambdabot>  error:
13:58:19 <lambdabot>      • No instance for (Num (Integer, Integer, Integer, Integer))
13:58:19 <lambdabot>          arising from a use of ‘e_112344321’
13:58:22 <monochrom> I think no one has done that.
13:58:23 <EvanR> dangit
13:58:31 <iqubic> Debian has Apt, Fedora has Dnf, OpenSUSE has Yum, Arch has pacman, NixOS has Nix, GuixSD has Guix.
13:58:45 <iqubic> Each distro has it's own package manager.
13:58:53 <evelyn> and they're all slow
13:59:05 <MarcelineVQ> especially aura
13:59:20 <iqubic> How do I install 'X' on Linux? depends on which distro are you using.
13:59:23 <sm[m]> why doesn't someone rewrite nix in haskell ?
13:59:31 <xenon-> d34df00d, you can implement Num for 4-tuple yourself
13:59:33 <MarcelineVQ> we could call it huix
13:59:35 <sm[m]> since we all love nix and haskell so much..
13:59:44 <dibblego> http://hackage.haskell.org/package/hnix
13:59:51 <MarcelineVQ> guix with haskell instead of scheme
13:59:51 <evelyn> someone did! or rather they made it interpret nix-lang
13:59:56 <d34df00d> xenon-: that's boring.
13:59:57 <EvanR> d34df00d: linear (package) has V4
14:00:00 <svipal> huix
14:00:13 <d34df00d> As a russian-speaking, I strongly vote for huix.
14:00:16 <evelyn> hijinx
14:00:16 <sm[m]> using haskell as the configuration language, of course
14:00:18 <iqubic> V4 is the closest you'll get.
14:01:57 <d34df00d> I could probably write something that derives Num instances for products of Num types Generically.
14:02:06 <d34df00d> Or is there a library that it would fit?
14:02:36 <EvanR> another standard answer is "don't implement Num" and use Applicative instead
14:02:45 <d34df00d> Wat.
14:03:49 <monochrom> Applicative won't do element-wise.
14:03:59 <Clint> did you mean Monoid
14:04:15 <d34df00d> That's sort of funny.
14:04:21 <d34df00d> Because I need Num for Monoid.
14:04:22 <loli> but what if you have two monoids? Canonicity is no fun there
14:04:53 <d34df00d> So I basically want to do `data Foo = Foo { f1 :: Int, f2 :: Double } deriving (Semigroup, Monoid) via (Sum ????)`
14:05:16 <monochrom> Don't worry, you newtype-wrap with Sum or Product to choose the monoid operator you want
14:05:24 <EvanR> ok that's why V4 won't work
14:06:26 <d34df00d> Hmm.
14:06:28 <EvanR> d34df00d: Generics...
14:06:43 <d34df00d> The compiler won't Coerce that Foo to (Int, Double).
14:06:49 <d34df00d> Are there fundamental reasons for that?
14:06:58 <loli> deriving via is fun, i remember writing having Functor derive from applicative and applicative derive from Monad
14:07:13 <d34df00d> EvanR: I'm curious what would be the minimal amount of handwritten code I'll need to do to get this done.
14:07:20 <d34df00d> (looks like it would also be what would take the most time)
14:07:38 <EvanR> for just (Int,Double) probably the actual Num instance
14:08:01 <iqubic> > (1,2) + (2,3)
14:08:03 <d34df00d> But I can't do `via (Sum (Int, Double))` there can I?
14:08:04 <lambdabot>  error:
14:08:04 <lambdabot>      • No instance for (Num (Integer, Integer))
14:08:05 <lambdabot>          arising from a use of ‘e_11223’
14:08:22 <d34df00d> (assuming (Int, Double) is already a Num)
14:08:27 <monochrom> Oh hey I have a crazy idea for default implementations of Ord methods!
14:08:39 <iqubic> Oh???
14:08:53 <iqubic> d34df00d: It isn't. :(
14:09:06 <EvanR> we pivoted to a nother question about deriving via
14:09:22 <monochrom> Currently you just have to provide one of "compare" or "<=", and the default implementations will take care of the rest.
14:09:27 <d34df00d> But I can't coerce single-constructor records to tuples anyway (sadly).
14:09:59 <EvanR> that does seem odd
14:10:19 <monochrom> But I notice that Ord is a subclass of Eq, so "x <= y = min x y == x" and "x <= y = max x y == y" are implementable too.
14:10:58 <iqubic> Well, yes. But then you need to implement either max or min.
14:11:02 <monochrom> Oh wait we can't have two default implementations for the same (<=), eh?
14:11:15 <monochrom> So nevermind!
14:11:48 <ephemient> I mean, I guess you could have free a function "lessThanOrEqualViaMin"
14:12:03 <ephemient> oh wait, but you can't redefine min
14:12:08 <monochrom> Wait, is it OK for Prelude to import spoon?  Of course don't re-export it...
14:12:16 <ephemient> that would have to belong in the class also
14:12:49 <monochrom> Because the best of both worlds is "x <= y = spoon (compare x y /= GT) (min x y == x)"
14:13:14 <iqubic> The hell does spoon do?
14:13:39 <c_wraith> evil, useful things
14:13:45 <iqubic> spoon :: NFData a => a -> Maybe a
14:13:49 <c_wraith> it violates Haskell semantics!
14:13:50 <iqubic> Why would you want that?
14:13:56 <c_wraith> but in a useful way.
14:14:05 <monochrom> Why do I do that?  So that if you provide one of "compare" or "min", your <= is covered!
14:14:25 <monochrom> Oh darn it wants NFData.
14:14:25 <c_wraith> it converts a lot of exceptions to Nothing
14:14:32 <EvanR> yeah why can't i coerce data Two a b = Two a b to (a,b)
14:14:35 <iqubic> Yeah.
14:15:00 <iqubic> :t spoon
14:15:01 <lambdabot> error: Variable not in scope: spoon
14:15:15 <EvanR> spoon should not be in prelude
14:15:39 <MarcelineVQ> I wouldn't worry, EvanR, after all...
14:15:51 <iqubic> monochrom: How are you able to pass two arguments to spoon?
14:16:04 <monochrom> OK it should be umamb
14:16:07 <monochrom> err, unamb
14:16:17 <iqubic> unamb?
14:16:19 <c_wraith> unamb makes more sense.
14:16:22 <ephemient> monochrom: depending on <<loop>> if compare loops back to <=?
14:16:34 <monochrom> Oh unamb doesn't need NFData \∩/
14:17:00 <dmwit> monochrom: Bool has an NFData instance anyway.
14:17:04 <monochrom> <<loop>> is an exception, spoon and unamb will do fine.  I want unamb.
14:17:08 <EvanR> is the jury out on if unamb is bug free
14:17:10 <c_wraith> unamb gives you the "most defined" value between two different ways of calculating the same thing.
14:17:22 <monochrom> Ah right I just need Ordering and Bool.
14:17:30 <c_wraith> for a very precise definition of "most defined"
14:17:38 <conal> Use lub rather than unamb. unamb is lub only for flat types.
14:18:08 <c_wraith> conal wrote these things on the first place, so believe him.
14:18:10 <monochrom> x <= y = (compare x y /= GT) `unamb` (min x y == x) `unamb` (max x y == y)
14:18:17 <conal> And, of course, use lub only on compatible arguments, ie arguments with a common upper information bound.
14:18:30 <conal> meaning that the arguments don't have to agree, but they cannot disagree.
14:19:09 <conal> s/cannot/must not/
14:26:20 * hackage dino 0.1.2 - A convenient tagless EDSL  https://hackage.haskell.org/package/dino-0.1.2 (EmilAxelsson)
14:27:19 <solonarv> monochrom: actually, we could probably have four default declarations forming a loop, which is broken by defining any one of them
14:33:25 <ChrisPenner[m]> Hey everyone! I just launched Optics By Example, a comprehensive guide to optics in Haskell. It's full of examples and exercises and teaches optics all the way from beginner to advanced. You can grab a copy here: https://leanpub.com/optics-by-example/
14:42:58 <iqubic> I'm going to have to check it out.
14:43:15 <iqubic> Lenses over MonadState is literally the best thing ever.
14:43:33 <sm[m]> ChrisPenner: congrats! That looks really nice.
14:44:03 <iqubic> Writing my IntCode interpreter with Lenses over state has been awesome.
14:44:14 <sm[m]> chapter 2 just inspired me to bump this up my todo list
14:50:19 <yasar> In this function -> fun1 = product . map ((-) 2) . filter even
14:50:38 <yasar> hlint suggest I replace ((-) 2) with (2 -)
14:50:47 <yasar> doesn't that change what the function does?
14:51:06 <ephemient> nope, that is what (-) 2 means
14:51:18 <ephemient> did you want subtract 2?
14:51:21 <yasar> yes
14:51:56 <ephemient> > product . map (subtract 2) . filter even $ [5..10]
14:52:00 <lambdabot>  192
14:52:10 <ephemient> > product . map ((-) 2) . filter even $ [5..10]
14:52:13 <lambdabot>  -192
14:52:23 <Gcf> iqubic: Would you be willing to share your result? I also did something with lenses over state for my Intcode computer, and it was not so awesome, so I am curious to see if I can pick up some insights from your work.
14:52:35 <wildtrees> > -1
14:52:38 <lambdabot>  -1
14:52:50 <wildtrees> > -1 + -1 
14:52:54 <lambdabot>  error:
14:52:54 <lambdabot>      Precedence parsing error
14:52:54 <lambdabot>          cannot mix ‘+’ [infixl 6] and prefix `-' [infixl 6] in the same infi...
14:53:07 <wildtrees> > (-1) + (-1) 
14:53:10 <lambdabot>  -2
14:53:25 <ephemient> > :set -XNegativeLiterals
14:53:30 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
14:55:17 <boxscape> % :set -XNegativeLiterals
14:55:17 <yahb> boxscape: 
14:56:18 <boxscape> more importantly though https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0229-whitespace-bang-patterns.rst will introduce -XLexicalNegation
14:56:24 <boxscape> which I believe allows writing -1 + -1
14:59:50 * hackage tree-traversals 0.1.1.0 - Functions and newtype wrappers for traversing Trees  https://hackage.haskell.org/package/tree-traversals-0.1.1.0 (NoahEasterly)
14:59:52 <aplainzetakind> https://gist.github.com/aplainzetakind/216ec7ab327e308c9e7211d609c7e7c2 both consumeOutput and unsafeRunIntCompL produce lists lazily, as I can verify in the repl, but for some reason runRobot just hangs, consuming all the memory until killed.
15:08:23 <ephemient> doesn't look like you're actually tying the knot there
15:13:06 <aplainzetakind> ephemient: How?
15:13:11 <ephemient> aplainzetakind: this would actually make a self-referential value > runRobot p = consumedOuts where consumedOuts = consumeOutput (initialState, 0) outs; outs = ...
15:14:28 <ephemient> where you replace (runRobot p) wih (consumedOuts)
15:15:22 <ephemient> or use `fix`
15:20:34 <aplainzetakind> :t fix
15:20:37 <lambdabot> (a -> a) -> a
15:23:02 <aplainzetakind> ephemient: Still getting a loop with what you suggested. I'm trying to figure out fix now.
15:26:52 <monochrom> Use your own recursion first.  Then fix is just a mechanical translation from that.  And that's the best explanation of fix---a mechanical translation of recursion.
15:27:33 <monochrom> http://www.vex.net/~trebla/haskell/fix.xhtml
15:28:41 <boxscape> what's the difference between traverse and folded? They seem to be doing the same thing, but the types are quite different
15:29:24 <boxscape> oh, they just look that different because folded replaces the (->) with a more general variable
15:31:08 <EvanR> fix should be in prelude!
15:31:21 <monochrom> At least it's in base.
15:31:43 <EvanR> i blame lambdabot with the feeling that prelude is incomplete
15:31:51 <EvanR> it has many things already imported, all the time
15:32:10 <EvanR> it's like, why are we not writing scripts and stuff in lambdabot instead
15:32:28 <Lycurgus> in effect you are if using ghci
15:32:40 <boxscape> ghci doesn't have stuff imported by default though
15:32:47 <boxscape> okay, it has everything imported qualified
15:32:51 <EvanR> only if you keep ghci running forever with imports
15:33:14 <EvanR> ah the .ghci file
15:35:18 <aplainzetakind> monochrom: I can't figure out why my own recursion doesnt work.
15:35:38 <monochrom> Someone should write a package and a module name Finale.  It would import all of hackage.  >:)
15:35:53 <Clint> isn't there an acme package for that
15:36:09 <monochrom> haha but does it use the name "Finale" or equivalent?
15:36:19 <Clint> i'm almost certain it does not
15:36:22 <EvanR> acme-everything
15:36:40 <EvanR> crescendo
15:36:41 <monochrom> Because the point is a pun on being the opposite of "prelude".
15:37:30 <monochrom> "the import that ends all imports"
15:37:40 <aplainzetakind> The first term of the result of consumeOutput is its first parameter, so unsafeRunIntCompL is given some (0 : _), which is enough to know it outputs (1 : 0 : _), why does this not start and keep going?
15:37:53 <EvanR> it should also be the opposite of prelude in the sense that prelude is auto imported
15:38:00 <EvanR> but with finale, you must import it all manually
15:38:28 <EvanR> i.e. does nothing
15:39:29 <d34df00d> Does it make sense to publish applications to Hackage? Or shall they stay at github?
15:39:53 <monochrom> It makes sense to publish applications on hackage.  pandoc is one of them.
15:39:53 <d34df00d> The only upside I see is that this way somebody interested can just do `stack install myapp` instead of `git clone ... && stack install`.
15:39:58 <EvanR> aplainzetakind: did you post scrutizable code? your last paste seems incomplete at least
15:39:59 <monochrom> xmonad is another.
15:40:12 <d34df00d> Pandoc is also a library isn't it?
15:40:14 <d34df00d> But xmonad is a good example, yes.
15:40:28 <EvanR> there's a few useful apps on hackage
15:41:14 <Lycurgus> pandoc and xmonad are mature products not random hackage pkgs
15:41:14 <Clint> are there any useful haskell apps that aren't?
15:41:28 <monochrom> stack? >:)
15:41:35 <EvanR> geordi?
15:41:43 <aplainzetakind> EvanR: https://gitlab.com/aplainzetakind/aoc2019/blob/master/days/Advent19/Day11.hs
15:41:46 <EvanR> GHC
15:41:58 <monochrom> onoes stack is on hackage too.
15:42:51 <EvanR> aplainzetakind: so here is one avenue to investigate
15:42:52 <monochrom> Someone should put ghc on hackage to confuse the hell of of people. >:)
15:43:26 <boxscape> like this? https://hackage.haskell.org/package/ghc
15:43:39 <monochrom> heh
15:43:46 <EvanR> aplainzetakind: in consumeOutput' your first argument is a pair, which you pattern match. Because of that, whatever the first argument is will be evaluated before the body of consumeOutput'. Even though we know it will be a pair. You can avoid this using a lazy pattern match
15:44:18 <Clint> well, no wonder tons of libraries don't work with ghc 8.8 if the latest version on hackage is 8.6.5
15:45:21 * hackage persistent-iproute 0.2.4 - Persistent instances for types in iproute  https://hackage.haskell.org/package/persistent-iproute-0.2.4 (MaxGabriel)
15:46:13 <boxscape> even the base library for ghc 8.8 isn't on hackage yet
15:47:11 <aplainzetakind> EvanR: Changing s@(ss, i) to ~s@(ss, i) didn't work, if that's what you meant.
15:47:25 <monochrom> s@~(ss, i)
15:47:36 <monochrom> ~s is the same as s
15:47:49 <EvanR> s@~(ss,i) is what i meant
15:48:02 <EvanR> beyond that i can't really follow the code
15:48:37 <monochrom> Actually I wonder why ~s@... is allowed.
15:48:58 <boxscape> why shouldn't it be allowed?
15:49:34 <iqubic> Alright... I rewrote my intcode interperter to work with conduits.
15:49:35 <iqubic> http://dpaste.com/19CY3DW
15:49:35 <monochrom> It makes no semantic change, but it gives people a false impression that they're changing semantics.
15:49:37 <MarcelineVQ> To let you know something isn't doing what you think it is
15:49:58 <aplainzetakind> s@~(ss, i) produces a parse error.
15:50:10 <iqubic> First 3 ">>>" prefixed lines are GHCi input. Final line is the output.
15:50:17 <monochrom> Actually I wonder whether it is allowed! :)
15:50:17 <EvanR> maybe s@(~(ss,i))
15:50:42 <aplainzetakind> s@ ~(ss, i) worked.
15:50:47 <EvanR> heh
15:50:58 <boxscape> monochrom no ssemantic change compared to what?
15:51:12 <monochrom> <monochrom> ~s is the same as s
15:51:27 <boxscape> but that doesn't have an @-pattern
15:51:28 <monochrom> But probably the grammar and the parser is simpler if it's allowed.
15:51:33 <amalloy> monochrom: i assume support for ~s just falls out naturally from support of ~anything
15:51:41 <amalloy> and there's no compelling reason to make it illegal
15:51:45 <monochrom> ~s@pat is the same as s@pat.
15:51:55 <aplainzetakind> Still loops though.
15:52:01 <EvanR> id . f is the same as f, should be illegal!
15:52:13 <boxscape> % case Nothing of j@(Just a) -> a; Nothing -> False
15:52:13 <yahb> boxscape: False
15:52:16 <boxscape> % case Nothing of ~j@(Just a) -> a; Nothing -> False
15:52:16 <yahb> boxscape: ; <interactive>:18:35: warning: [-Woverlapping-patterns]; Pattern match is redundant; In a case alternative: Nothing -> ...; *** Exception: <interactive>:18:1-50: Non-exhaustive patterns in j@(Just a)
15:52:18 <boxscape> no it's not?
15:52:28 <EvanR> (arguably, id opens up other cool things you can do, while patterns might not really expand much)
15:53:09 <boxscape> (^^ monochrom)
15:53:25 <monochrom> Hrm, I was wrong, ~s@pat is not the same as s@pat
15:54:11 <EvanR> aplainzetakind: hmm. it's possible to narrow down where looping occurs using the debugger or Debug.Trace
15:54:11 <nil> why not?
15:54:12 <d34df00d> Uh, why isn't there a monadic fold over ByteStrings?
15:54:27 <d34df00d> I want to fold over a ByteString all while in ST.
15:54:38 <EvanR> well, you can fold over a list of Word8
15:54:42 <boxscape> nil you're asking why they're not the same?
15:54:46 <nil> yes
15:54:54 <boxscape> see my yahb example a few lines up
15:54:55 <d34df00d> EvanR: hmm... I wonder if performance will suffer.
15:55:03 <d34df00d> List is a good control flow structure, but still.
15:55:05 <EvanR> at least it's lazy
15:55:15 <aplainzetakind> I think I figured it out.
15:55:15 <nil> boxscape: oh, sorry, i thought "pat" was literally just a single variable
15:55:20 <EvanR> and potentially fusing
15:55:23 <boxscape> nil yeah in that case they are the same
15:55:37 <EvanR> (cocofusing?)
15:55:50 <boxscape> that's just confusing
15:55:52 <Axman6> d34df00d: foldX ... . BS.toList will never actually produce a list
15:56:02 <aplainzetakind> Before consumeOutput can know what it will do, it needs to match on what outs is on line 74
15:56:10 <d34df00d> Axman6: you mean it'll never materialize more than one element of it?
15:56:14 <aplainzetakind> Outs is waiting for runRobot though.
15:56:14 <d34df00d> (at the same time)
15:56:22 <Axman6> yes
15:56:40 <EvanR> aplainzetakind: oh...
15:56:43 <Axman6> it'll be equivalent to just idexing into the bytestring
15:56:49 <aplainzetakind> So consumeOutput forces outs to be evaluated, and so on.
15:57:06 <aplainzetakind> Probably building some sorts of infinite thunks along the way.
15:57:11 <aplainzetakind> Does this make sense?
15:57:28 <EvanR> runRobot p = .... something with runRobot p ... does seem suspect
15:57:30 <d34df00d> Axman6: glad to hear I can rely on that!
15:57:59 <aplainzetakind> I think the problem is with lines 59-60
15:58:01 <EvanR> you take the snd of it
15:58:12 <EvanR> i.e. the final answer
15:58:15 <aplainzetakind> It should be consumeOutput s xs = s :  case xs of ...
15:58:30 <aplainzetakind> So that it can retrive the head without knowing what outs will be.
15:59:46 <EvanR> this kind of thing is why many people suggest not using manual recursion
15:59:54 <EvanR> esp with this amount of steps
16:00:49 <iqubic> Oh dear me...
16:01:55 <iqubic> So my hull painting robot is returning to me this: "M.Map (V2 Int) Color" where "Data Color = Black | White"
16:02:06 <iqubic> How the hell do I render that?
16:02:27 <EvanR> you can use juicy pixels to output a picture
16:02:38 <iqubic> Of that?
16:02:43 <EvanR> or show it real time with SDL
16:02:45 <koz_> Yeah, it's a mapping of coordinates to colours.
16:02:55 <iqubic> I see.
16:03:11 <iqubic> I've never used JuicyPixels before.
16:03:44 <EvanR> it's pretty easy
16:03:48 <koz_> No time like the present. :D
16:03:49 <boxscape> woah, how is (<<) not a thing
16:04:09 <amalloy> iqubic: you can also just compute the bounding box and restrict drawing to that area
16:04:22 <boxscape> we have >>=, =<<, >=>, <=<, even <* and *>, but >> is all alone
16:04:27 <EvanR> output with juicy pixels is even easier than reading in
16:04:34 <iqubic> Really?
16:04:37 <EvanR> as usual
16:05:23 <iqubic> I want the background to be black, and then I want to set certain pixels to white as dictated by my map. That also has some black in it, but that's fine. Black on black is still black.
16:05:43 <EvanR> do it
16:05:50 <boxscape> oh I didn't realize `a *> b` is different from `b <* a`
16:06:28 <iqubic> EvanR: I would, but I have no idea how juicy pixels works.
16:06:50 <EvanR> :|
16:08:30 <koz_> iqubic: Do you wanna dump it to an image?
16:08:49 <aplainzetakind> EvanR: It works now.
16:09:07 <aplainzetakind> But I get the wrong answer, so need to hunt down a logic bug.
16:09:11 <iqubic> koz_: yeah.
16:09:12 <iqubic> I do.
16:09:33 <iqubic> I know that's like, the most basic thing ever, but I'm stil lost.
16:09:35 <monochrom> There is always a first time.
16:10:06 <aplainzetakind> iqubic: Why not just print it to the terminal?
16:10:08 <koz_> iqubic: http://hackage.haskell.org/package/JuicyPixels-3.3.4/docs/Codec-Picture.html#v:generateImage
16:10:15 <koz_> Try starting there, and working backwards from the types.
16:10:27 <koz_> It should be fairly straightforward given the coordinate map you've got going.
16:10:37 <iqubic> aplainzetakind: If I do that, I'd get a big list of coords and colors.
16:10:54 <koz_> Then use this: http://hackage.haskell.org/package/JuicyPixels-3.3.4/docs/Codec-Picture.html#v:saveJpgImage
16:11:13 <koz_> (or some other save*Image function, depending on what format you want)
16:11:15 <aplainzetakind> No I mean, convert it to lines of "...#..#."
16:11:25 <aplainzetakind> First filter the ones which are black.
16:11:28 <iqubic> aplainzetakind: I can also do that.
16:11:47 <aplainzetakind> Then determine the boundaries, it should be straightforward.
16:12:33 <EvanR> yeah imean there is aalib and libcaca for ascii art output but
16:12:38 <EvanR> really
16:12:57 <EvanR> i don't think it would be as easy as juicy pixels
16:13:09 <koz_> Yeah, those two functions will work just fine given that you have a coordinate map.
16:13:27 <koz_> Like, you might have to do some light interpolation, but given that you have black and white only, and don't care about anti-aliasing...
16:13:32 <aplainzetakind> I really wish there were an example input today.
16:13:46 <iqubic> Same.
16:16:58 <amalloy> aplainzetakind: i wrote my own tiny example input that was enough to find a couple of my bugs. you can repeat a string like 3,100,14,1,14,1 a few times to draw a 2x2 white patch on the ground
16:17:29 <amalloy> oh, i guess it needs to be 14,1,1. i don't have my repo handy so i was trying to reinvent it just now
16:19:43 <aplainzetakind> amalloy: Good advice, thanks.
16:19:47 <aplainzetakind> 104,1 probably.
16:20:17 <amalloy> ah, indeed
16:22:13 <iqubic> So, m :: M (V2 Int) Color. "any (\(V2 x y) -> x < 0 || y < 0) $ M.keysSet m"
16:22:33 <iqubic> Looks like I have some negative points in my keyset.
16:23:08 <EvanR> guess you have to get the min x and y, then shift everything over
16:23:31 <iqubic> I just changed both comparisons to <= and it still returns true.
16:23:58 <iqubic> This is hard.
16:24:31 <iqubic> I just want to get a pretty picture.
16:24:42 <iqubic> Or really any picture at all.
16:26:34 <amalloy> yeah, like i said, find the bounding box
16:26:36 <nshepperd2> Just get the minimum and maximum x and y from your map, then iterate from miny to maxy printing out a line consisting of the values between minx and maxx
16:26:56 <nshepperd2> You don't need a fancy library to print stuff to the terminal
16:27:12 <EvanR> ok but the values are colors
16:27:31 <iqubic> Yeah. I can write a Color -> Char function.
16:27:38 <iqubic> It's just black and white.
16:27:42 <EvanR> oh
16:31:57 <aplainzetakind> Assuming you have filtered your map to include only the white panels. unlines [ [ f i j | i <- [minx..maxx], let f i j = if M.member (i, j) then '#' else ' ' | j <- [miny..maxy] ]
16:32:10 <aplainzetakind> Something like this should do.
16:33:19 <aplainzetakind> M.member (i, j) theMapOfWhites, of course.
16:39:42 <iqubic> So, this does the row at Y = 0. I have no idea how to do all rows.
16:39:43 <iqubic> [[pointToChar (V2 x 0) | x <- [minX..maxX]]]
16:39:57 <iqubic> I have minY and maxY defined too.
16:41:56 <iqubic> I think this works. [[pointToChar (V2 x y) | x <- [minX..maxX]] | y <- [minY..maxY]]
16:47:48 <iqubic> But this is getting confusing, to I'm switching to nested do blocks.
16:48:58 <dsal> > [(x,y) | x <- [0..3], y <- [7..9]]
16:49:00 <lambdabot>  [(0,7),(0,8),(0,9),(1,7),(1,8),(1,9),(2,7),(2,8),(2,9),(3,7),(3,8),(3,9)]
16:49:42 <dsal> > (,) <$> [0..3] <*> [7..9]
16:49:45 <lambdabot>  [(0,7),(0,8),(0,9),(1,7),(1,8),(1,9),(2,7),(2,8),(2,9),(3,7),(3,8),(3,9)]
16:53:15 <iqubic> Here's the code I used to create my image.
16:54:24 <iqubic> http://dpaste.com/2B0AAFN
16:54:39 <iqubic> Here's the image itself: http://dpaste.com/0A3MRRW
16:56:08 <dsal> I made this thing and a few related bits that have been useful a few times:   class Bounded2D a where bounds2d :: a -> ((Int,Int), (Int,Int))
16:56:21 <iqubic> I see.
16:56:27 <dsal> Then I've got a PNG and a text thing that can take a thing and draw it.
16:56:45 <dsal> draw :: Bounded2D a => FilePath -> a -> PixelFun -> IO ()    and   drawString :: Bounded2D a => a -> CharFun -> String
16:57:00 <dsal> PixelFun and CharFun are (Int,Int) -> whatever the drawing primitive needs.
16:57:16 <iqubic> I see.
16:57:37 <iqubic> I basically just wrote this right now, for viewing my letters.
16:57:56 <dsal> Isn't this the second one of these we've had this year?
16:58:45 <dsal> Oh yeah, I've used this on 3, 8, 10, and 11.
16:58:50 <iqubic> I'm sad that enumFromTo returns an empty list when first arg > second arg.
16:59:13 <iqubic> > [20..0]
16:59:16 <lambdabot>  []
16:59:27 <dsal> > [20,19 ..]
16:59:30 <lambdabot>  [20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-...
16:59:36 <iqubic> Ah I see.
16:59:49 <dsal> :t enumFromThenTo
16:59:51 <lambdabot> Enum a => a -> a -> a -> [a]
16:59:59 <iqubic> > [20,19..0]
17:00:02 <lambdabot>  [20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0]
17:00:09 <iqubic> Oh, that actually works. Neat.
17:00:11 <dsal> > enumFromThenTo 20 19 0
17:00:14 <lambdabot>  [20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0]
17:00:49 <iqubic> See, in this: http://dpaste.com/2B0AAFN
17:01:04 <iqubic> I'd love for the ys to count downward, to save a reverse.
17:01:12 <dsal> 'return' makes me sad.
17:01:27 <dsal> I just reversed the direction in the painter.
17:01:42 <iqubic> Why does return make you sad?
17:02:00 <dsal> It's a wart that should be excised, but it'd break more code than MonadFail
17:03:10 <iqubic> I see. Makes sense.
17:03:23 <iqubic> y <- [maxY,(maxY-1)..minY]
17:03:31 <iqubic> Now ys counts down.
17:05:55 <iqubic> I just realized that (∀ k :: Type, v :: Type, m :: Map k v) => Data.Map.Size m == length m
17:06:05 <dsal> > let maxY = 9; minY = 5 in  ("workin " <>) . show <$> [maxY, pred maxY .. minY]
17:06:08 <lambdabot>  ["workin 9","workin 8","workin 7","workin 6","workin 5"]
17:06:46 <iqubic> pred is cool.
17:06:52 <iqubic> I should use it more often
17:07:20 <dsal> minimumBy (comparing $ \(V2 x _) -> x)    Isn't that approximately   minimumOn snd
17:07:27 <iqubic> Yes.
17:08:39 <iqubic> But I don't have Extra installed
17:08:59 <dsal> @src minimumOn
17:08:59 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
17:09:09 <iqubic> So, I'm not going to be doing that.
17:09:11 <dsal> lame.  It's easy enough to write.
17:09:57 <iqubic> Also, V2 doesn't really have snd function.
17:10:55 <aplainzetakind> I wonder if day 9 can leave some bugs undetected.
17:10:57 <dsal> I don't know what V2 is.  But it's easy enough to have a fst/snd x/y sort of thing
17:11:37 <iqubic> dsal: It's from Data.Linear.
17:11:44 <iqubic> @hackage Linear
17:11:44 <lambdabot> http://hackage.haskell.org/package/Linear
17:12:38 <dsal> Looks like it's got lenses for x and y.
17:13:27 <iqubic> Yes. I know. I can clean up my code a bit.
17:13:31 <iqubic> I'm not going to.
17:19:05 <dsal> The bots don't know about linear.
17:22:49 <dsal> I made a Min monoid in ghc and then did this:  vs = [V2 x y | y <- [0..5], x <- [7..11]] :: [V2 Int]
17:23:10 <dsal> which let me do this:    vs ^. folded . _x . to Min    -->   Min {getMin = 7}
17:24:38 <dsal> Of course, you could do better with a bounds monoid...  I should make that.
17:25:53 <Lears> % mempty <> Min 2 <> Min 4
17:25:53 <yahb> Lears: ; <interactive>:37:1: error:; * Ambiguous type variable `a0' arising from a use of `print'; prevents the constraint `(Show a0)' from being solved.; Probable fix: use a type annotation to specify what `a0' should be.; These potential instances exist:; instance Show a => Show (ZipList a) -- Defined in `Control.Applicative'; instance Show NestedAtomically -- Defined in 
17:25:58 <Lears> % mempty <> Min 2 <> Min 4 :: Min Int
17:25:58 <yahb> Lears: Min {getMin = 2}
17:26:15 <Lears> We already have a Min Monoid in base.
17:26:21 <dsal> in base?
17:26:30 <dsal> Oh.  I made this for nothing!
17:27:45 <dsal> Oh, it's a semigroup, but not a monoid.
17:27:59 <iqubic> What did you use as mempty?
17:29:19 <boxscape> % vs = [V2 x y | y <- [0..5], x <- [7..11]] :: [V2 Int]
17:29:19 <yahb> boxscape: 
17:29:22 <Lears> % (mempty, maxBound) :: (Min Int, Int)
17:29:23 <yahb> Lears: (Min {getMin = 9223372036854775807},9223372036854775807)
17:29:27 <boxscape> % vs ^. folded . _x . to Min
17:29:28 <yahb> boxscape: ; <interactive>:1:1: error:; GHC internal error: `Ghci6.$trModule' is not in scope during type checking, but it passed the renamer; tcl_env of environment: []
17:29:33 <boxscape> internal error, nice
17:29:37 <Lears> It is a Monoid with a Bounded constraint.
17:30:30 <dsal> instance (Ord a, Bounded a) => Monoid (Min a) where mempty = Min maxBound
17:31:04 <dsal> Tell yahb to keep its errors to itself.
17:32:48 <dsal> oooh.
17:32:52 <dsal> % foldMap (\x -> Bounds (x,x)) ([3..14]::[Int])
17:32:52 <yahb> dsal: Bounds (3,14)
17:33:31 <boxscape> % foldMap (join $ uncurry Bounds) ([3..14]::[Int])
17:33:31 <yahb> boxscape: ; <interactive>:53:10: error:; * Couldn't match type `((a0, a0), b0)' with `Int'; Expected type: Int -> m; Actual type: ((a0, a0), b0) -> m; * In the first argument of `foldMap', namely `(join $ uncurry Bounds)'; In the expression: foldMap (join $ uncurry Bounds) ([3 .. 14] :: [Int]); In an equation for `it': it = foldMap (join $ uncurry Bounds) ([3 .. 14] :: [Int]); <in
17:33:36 <boxscape> % foldMap (join $ curry Bounds) ([3..14]::[Int])
17:33:36 <yahb> boxscape: Bounds (3,14)
17:33:51 <dsal> I can never remember that join
17:34:16 <boxscape> I'm not sure I've ever used join for anything other than functions
17:35:02 <boxscape> (though in this case your version is both clearer and shorter)
17:37:53 <dsal> I'd probably make a helper.
17:39:29 <dsal> % let enbound (x::Int) = Bounds (x,x)  in  foldMap enbound [3, 1, 4, 1, 5, 9]
17:39:29 <yahb> dsal: Bounds (1,9)
17:43:10 <dsal> % let enbound :: Int -> Bounds Int; enbound x = coerce (x,x)  in  coerce (foldMap enbound [3, 1, 4, 1, 5, 9]) :: (Int,Int)
17:43:10 <yahb> dsal: (1,9)
17:43:15 <dsal> I need to use coerce more.
17:45:06 <boxscape> performance-wise, I don't think it makes a difference in this case
17:45:21 <boxscape> since you're not coercing whole collections
17:45:36 <dsal> Yeah, that's a good point.
17:54:14 <dmwit> (Re: "I'd probably make a helper") I'd probably make Bounds just have two fields instead of a tuple.
17:55:56 <dmwit> % foldMap (\x -> (Min x, Max x)) [3,1,4,1,5,9 :: Int]
17:55:56 <yahb> dmwit: (Min {getMin = 1},Max {getMax = 9})
17:58:01 <Axman6> the foldl package is also quite nice for these sorts of things
17:59:01 <Axman6> % :t (,) <$> Control.Foldl.min <*> Control.Foldl.max
17:59:01 <yahb> Axman6: ; <interactive>:1:9: error:; Not in scope: `Control.Foldl.min'; No module named `Control.Foldl' is imported.; <interactive>:1:31: error:; Not in scope: `Control.Foldl.max'; No module named `Control.Foldl' is imported.
17:59:19 <Axman6> % import Control.Foldl
17:59:20 <yahb> Axman6: ; <no location info>: error:; Could not find module `Control.Foldl'; It is not a module in the current program, or in any known package.
17:59:23 <Axman6> :'(
18:01:02 * dmwit . o O ( :! cabal install foldl )
18:01:10 <dmwit> (No, that won't work, even if it were allowed.)
18:01:25 <boxscape> hm, why not
18:01:36 <dmwit> You'd need a way to tell ghci to reload the package database.
18:01:36 <Axman6> I was tempted to try though
18:01:48 <dmwit> And there isn't one, as far as I know.
18:01:58 <boxscape> you can run arbitrary bash commands in yahb
18:02:02 <boxscape> so just start a new ghic
18:02:08 <dmwit> You can restart ghci, but in yahb restarting ghci also kills all the local state -- including the package database, probably?
18:02:13 <boxscape> ah
18:02:27 <dmwit> Like I'm pretty sure it just tears down the whole sandbox and builds a new one.
18:02:37 <boxscape> you could have that new ghci use files as input and output instead of stdin and stdout and leave the primary ghci running
18:03:09 <dmwit> Interacting with it would be an incredible pain. -_-
18:03:18 <boxscape> I won't dispute that
18:03:39 <dmwit> % :! ghc -e putStrLn "hi"
18:03:39 <yahb> dmwit: target `hi' is not a module name or a source file
18:03:48 <dmwit> % :! ghc -e 'putStrLn "hi"'
18:03:48 <yahb> dmwit: hi
18:03:51 <dmwit> amazing
18:04:11 <boxscape> I think there's also something other than % to directly run bash commands (instead of running them through ghci), but I don't remember what it is
18:04:24 <boxscape> %list
18:04:24 <yahb> boxscape: List of sandboxes: % %hs %lua %! (% = %hs)
18:04:32 <boxscape> %! ghc -e 'putStrLn "hi"'
18:04:32 <yahb> boxscape: /var/lib/xsbot/sandbox/root/usr/lib/ghc-8.6.0.20180620/bin/ghc: error while loading shared libraries: libHShaskeline-0.7.4.2-ghc8.6.0.20180620.so: cannot open shared object file: No such file or directory
18:07:36 <Ailrun[m]> https://medium.com/@fommil/why-not-both-8adadb71a5ed
18:50:08 <mniip>  %hs sets up some environment variables that %! does not
18:51:15 <mniip> dmwit, no it doesn't "rebuild" the sandbox in the FS sense
18:51:18 <mniip> just the process
18:53:13 <tinga> How would I pattern match for an empty Data.Set ?
18:53:50 <tinga> There's the null predicate function, but that would require a guard clause or whatever it's called.
18:54:05 <f-a> use a guard, yeah
18:54:29 <tinga> Meh. Feels like I do when coding Scheme :)
18:54:52 <EvanR> you can pattern match on abstract types by using a view, and view patterns
18:55:03 <EvanR> view patterns being extra sugar
18:55:19 <tinga> Aha.. so I should google haskel view patterns?
18:55:54 <tinga> This? https://gitlab.haskell.org/ghc/ghc/wikis/view-patterns
18:56:21 <EvanR> well, you don't really need that 
18:56:36 <EvanR> :t Data.Set.minView
18:56:38 <lambdabot> S.Set a -> Maybe (a, S.Set a)
18:57:06 <EvanR> Nothing means empty, Just (x, xs) is non empty
18:57:18 <tinga> Aha. So you convert the Set to a view and pattern match that?
18:57:39 <EvanR> minView is called a covering function, i think. Useful to pattern match on types whose implementation is hidden
18:57:57 <tinga> OK. Thanks!
18:58:48 <tinga> Is that one of the things that with a sufficiently smart compiler have no overhead?
18:58:52 <EvanR> however, minView takes work. Using a bool test for emptiness is more efficient
18:59:00 <tinga> :)
19:00:00 <EvanR> elems :: Set a -> [a] could be used instead, in case True and False are too easy to mix up
19:00:05 <EvanR> as a view
19:00:37 <EvanR> if you don't use any of the elements when non-empty, it doesn't really take any work
19:00:49 <tinga> I'll just make a predicate function. I'm already wrapping the Set in my own type, so the pattern matching would have to be yet more involved.
19:01:08 <tinga> I'm just surprised that the grail of pattern matching isn't as holy as I thought.
19:02:02 <tinga> (Or others who looked down on me not using pattern matching in Scheme thought.)
19:02:16 <EvanR> if you really want to be free from bool tests, check out dependent types
19:03:03 <tinga> Yeah, will continue to study Idris when I'll get that time present I've always wished for.
19:03:25 <tinga> Or do you mean the ones in Haskell?
19:03:36 <EvanR> not haskell, yet
19:08:13 <gentauro> is there a way to `override` GHCi default output?
19:08:41 <gentauro> I'm working with strings containing `unicode` and it doesn't seem readable with current output :(
19:08:56 <gentauro> but if I just add the `putStrLn` it looks good
19:09:28 <gentauro> so I would like to just be able to `hook` the `putStrLn` to whatever GHCi doing, on ad-hoc basis
19:09:33 <EvanR> you mean, the show instance for strings?
19:09:50 <EvanR> that is what inserts escape sequences 
19:10:28 <gentauro> EvanR: I'm lloing for something like: `λ>:set NiceOutPut=putStrLn` ish
19:10:37 <gentauro> EvanR: it's just related to GHCi
19:10:43 <gentauro> not Haskell as such
19:10:49 <EvanR> i'm not sure that's true
19:11:02 <gentauro> EvanR: what is not true?
19:11:19 <EvanR> ghci prints out the result of `show'
19:11:27 <gentauro> EvanR: Yes
19:11:33 <EvanR> you can verify by writing a standalone program which does putStrLn (show x)
19:12:04 <gentauro> EvanR: I'm guessing it uses: `print :: Show a => a -> IO ()`
19:12:05 <EvanR> it doesn't make a special case for strings
19:12:22 <gentauro> but I would like it to use: `putStrLn :: String -> IO ()`
19:12:22 <EvanR> print = putStrLn . show
19:12:23 <gentauro> :)
19:12:33 <EvanR> how would that work for Int ?
19:13:18 <gentauro> λ>[ 1 .. 10 ]
19:13:18 <gentauro> [1,2,3,4,5,6,7,8,9,10]
19:13:30 <EvanR> > putStrLn [1..10]
19:13:35 <lambdabot>  error:
19:13:35 <lambdabot>      • No instance for (Num Char) arising from the literal ‘1’
19:13:35 <lambdabot>      • In the expression: 1
19:13:59 <EvanR> % print [1..10]
19:13:59 <yahb> EvanR: [1,2,3,4,5,6,7,8,9,10]
19:14:00 <gentauro> EvanR: Yes, it should be `putStrLn . show`
19:14:08 <EvanR> that's what it is slready
19:14:13 <gentauro> but I don't want to type `print` everytime`
19:14:21 <gentauro> I just want to se a parameter in GHCi
19:14:34 <gentauro> so whenever I type in the REPL (the unicode string)
19:14:51 <gentauro> they output nicely instead of a sequnece of: `\123,\1324, ...`
19:14:57 <EvanR> it puts print for you, which works on any Showable
19:15:02 <gentauro> which is pretty much useless
19:15:08 <gentauro> (unless you are a robot)
19:15:29 <gentauro> 04:13 < gentauro> I just want to se a parameter in GHCi -> se = set
19:15:45 <EvanR> set a parameter?
19:16:06 <gentauro> EvanR: something like: `λ>:set NiceOutPut=putStrLn . show` ish
19:16:16 <gentauro> if that is possible (my initial question)
19:16:39 <EvanR> uhm
19:16:45 <pavonia> Again, that's what it already does
19:17:12 <EvanR> that's what it does for you and writing print would not even work
19:17:25 <pavonia> What you actually seems to want is to handle strings differently from all other values
19:17:31 <EvanR> % print "é"
19:17:31 <yahb> EvanR: "\233"
19:18:14 <gentauro> pavonia: you are right
19:18:17 <gentauro> λ>"□■■□■□■□□"
19:18:17 <gentauro> "\9633\9632\9632\9633\9632\9633\9632\9633\9633"
19:18:17 <gentauro> λ>putStrLn . show $ "□■■□■□■□□"
19:18:17 <gentauro> "\9633\9632\9632\9633\9632\9633\9632\9633\9633"
19:18:17 <gentauro> λ>putStrLn $ "□■■□■□■□□"
19:18:19 <gentauro> □■■□■□■□□
19:18:22 <gentauro> λ>
19:18:25 <gentauro> Hmmm
19:18:43 <EvanR> putStrLn skips show and dumps the data to the output (through an encoder)
19:18:47 <EvanR> that's how it displays correctly
19:18:51 <gentauro> 04:17 < pavonia> What you actually seems to want is to handle strings differently from all other values
19:18:56 <gentauro> I guess this is what I want :)
19:18:59 <EvanR> the terminal doesn't use utf32
19:19:43 <EvanR> also unicode rendering is even more complicated than picking the right glyphs 1 by 1
19:19:57 <EvanR> adjacent characters can influence the display
19:22:21 <gentauro> I think I will just wrap my `String` type like this:
19:22:21 <gentauro> λ>newtype Foo = F String
19:22:22 <gentauro> λ>instance Show Foo where show (F x) = x
19:22:22 <gentauro> λ>F "□■■□■□■□□"
19:22:22 <gentauro> □■■□■□■□□
19:22:35 <gentauro> that will at least give a usefull output :)
19:22:41 <gentauro> thanks for the help
19:23:24 <EvanR> that makes too much sense
19:24:04 <gentauro> :)
19:50:40 <dsal> p = putStrLn
19:50:58 <dsal> Then you can prefix them with p instead
19:52:27 <dsal> I would like it to do the thing I want by default, though.  That'd be convenient.
21:12:42 <monochrom> Gosh, the obsession with using show and print, therefore mucho workarounds are invented just to continue to use print.
21:13:48 <monochrom> Instead of, you know, creating another function so you have full control rather than looking for ways to fool print.
21:25:32 <monochrom> http://www.vex.net/~trebla/haskell/string-print-show-read.xhtml
21:29:51 <koz_> Something something Show is not a pretty-printer something.
21:30:30 <EvanR> in this case it was boiling down to most unicode characters being escaped
21:30:47 <EvanR> instead of just the non-printable
21:32:09 <EvanR> you could leave many unicode characters as is, but monochrom's article proves you at least need to escape quotes
21:48:21 * hackage ucd 0.0.1.2 - Unicode Character Database — Predicates on characters specified by Unicode  https://hackage.haskell.org/package/ucd-0.0.1.2 (MatthewFarkasDyck)
21:51:38 <iqubic> :t zipWith
21:51:40 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
21:51:59 <iqubic> I really would like a version of that that work on any two foldables.
21:52:20 * hackage ucd 0.0.1.3 - Unicode Character Database — Predicates on characters specified by Unicode  https://hackage.haskell.org/package/ucd-0.0.1.3 (MatthewFarkasDyck)
21:52:34 <dibblego> can't, need applicative
21:52:51 <iqubic> Well, my data type has Applicative.
21:52:57 <dibblego> go nuts
21:53:30 <dibblego> @type (liftA2, ZipList, getZipList)
21:53:32 <lambdabot> Applicative f => ((a1 -> b -> c) -> f a1 -> f b -> f c, [a2] -> ZipList a2, ZipList a3 -> [a3])
21:54:04 <iqubic> I'll just use liftA2.
22:13:51 * hackage pandoc 2.9 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-2.9 (JohnMacFarlane)
22:18:49 <tinga> I've got a haskell program that loops endlessly somehow. How do I find out where?
22:27:42 <monochrom> Test individual functions.
22:30:03 <kronicmage> @free fmap :: (a -> b) -> (F a -> F b)
22:30:03 <lambdabot> g . h = k . f => $map_F g . fmap h = fmap k . $map_F f
22:30:41 <kronicmage> has anyone had experience compiling lambdabot recently?
22:30:55 <kronicmage> alternatively, does anyone know where I can get binaries for it on arch linux
22:31:21 <kronicmage> seems like I have to downgrade my ghc if I want a local copy and that's a bit of a pain :(
22:31:27 <wrunt[m]> tinga: https://wiki.haskell.org/Debugging has a section on Infinite loops at the bottom. It's 12 years old but it may still work?
22:35:30 <kronicmage> @free foo :: (a -> b) -> f a -> f b
22:35:31 <lambdabot> Extra stuff at end of line
22:35:46 <tinga> wrunt[m], thanks. Actually I found it with {-# OPTIONS_GHC -Wall -Wno-missing-signatures -Wno-name-shadowing #-}
22:36:02 <kronicmage> @free foo::(a >b)->f a->f b
22:36:03 <lambdabot> Plugin `free' failed with: src/Lambdabot/Plugin/Haskell/Free/Type.hs:(153,17)-(161,45): Non-exhaustive patterns in case
22:36:11 <tinga> Still, runtime debugging is something I'll probably "want".
22:36:18 <kronicmage> @free foo::(a->b)->f a->f b
22:36:18 <lambdabot> Extra stuff at end of line
22:36:46 <kronicmage> @free foo::(a->b)->F a->F b
22:36:46 <lambdabot> g . h = k . f => $map_F g . foo h = foo k . $map_F f
22:37:01 <yasar> I am getting the error in the comments -> https://gist.github.com/yasar11732/5c32906c38a5dcae174ee81557b1a408
22:39:12 <kronicmage> yasar try subbing your n/2 with div n 2
22:42:18 <yasar> kronicmage, thanks, that works
22:51:20 <bahamas> % split . onSublist $ ".." "a..b...c....d."
22:51:20 <yahb> bahamas: ; <interactive>:120:21: error:; * Couldn't match expected type `[Char] -> [a]' with actual type `[Char]'; * The function `".."' is applied to one argument,; but its type `[Char]' has none; In the second argument of `($)', namely `".." "a..b...c....d."'; In the expression: split . onSublist $ ".." "a..b...c....d."; * Relevant bindings include it :: [a] -> [[a]] (bound at <int
22:51:50 <bahamas> hm, I think it's calling a different `split`
22:51:54 <MarcelineVQ> that's  (split . onSublist)  (".." "a..b...c....d.")
22:52:50 <MarcelineVQ> the error saying "The function `".."' is applied to one" is the red flag
22:53:17 <bahamas> MarcelineVQ: strange. in ghci, I get a different error
22:53:50 <yasar> I have no idea where to start at exercise 2, any pointers? https://www.cis.upenn.edu/~cis194/spring13/hw/04-higher-order.pdf
22:55:45 <bahamas> this is the error https://bpaste.net/show/QFVMW
22:57:22 <bahamas> yasar: do you understand how to use foldr?
22:58:12 <yasar> I know it takes and accumulator and function to apply to a list
22:58:30 <bahamas> yasar: what is the accumulator that you pass to foldr and what does the function do with the accumulator in this case?
22:59:28 <yasar> accumulator should be leaf node and function should be insert but, how do I know if I will get a balanced tree?
23:01:04 <MarcelineVQ> bahamas: You have OverloadedStrings enabled so the error is different but the root issue is the same. you're applying a list to a list, you can only apply functions. OverloadedStrings turns "stringliteral" :: [Char] to "stringliteral" :: IsString a => a, so it's looking for an 'a' instance with a function type since you're using ".." like a function.
23:02:58 <bahamas> yasar: I haven't implemented an algorithm that constructs a balanced binary tree, so I don't have an intuition for it. you could look at an example in a different language for inspiration
23:04:37 <bahamas> MarcelineVQ: but doesn't happen if you also wrap the two strings in parentheses?
23:04:52 <MarcelineVQ> what do you mean?
23:04:55 <haskelllisp[m]> http://reasonablypolymorphic.com/blog/higher-kinded-data/
23:04:55 <haskelllisp[m]> i don't understand `class GValidate i o where`
23:05:01 <bahamas> actually, it doesn't because I tried
23:05:24 <bahamas> MarcelineVQ: so space is the function application operator, right?
23:05:54 <tinga> I try this in a file and it gives a type error, I do it in ghci with "let " prependet to tests and it works, why?: import Data.Dynamic (toDyn, Dynamic); tests :: [Dynamic]; tests = [ toDyn 1 ]
23:06:15 <MarcelineVQ> Essentially
23:08:04 <MarcelineVQ> split . onSublist $ ".." "a..b...c....d."  =  (split . onSublist)  (".." "a..b...c....d.")    both are wrong as (".." "a..b...c....d.")  doesn't generally make sense, what does it mean to apply ".." to "a..b...c....d."
23:08:45 <bahamas> MarcelineVQ: yes, that's what I wanted to say. that wrapping them like that in parentheses doesn't help
23:08:56 <bahamas> % split (onSublist "..") "a..b...c....d."
23:08:56 <yahb> bahamas: ["a","..","b","..",".c","..","","..","d."]
23:09:17 <bahamas> that, I discovered, is the right way
23:10:53 <kronicmage> @free iterate :: (a -> a) -> a -> [a]
23:10:53 <lambdabot> f . g = h . f => $map f . iterate g = iterate h . f
23:12:20 <bahamas> MarcelineVQ: and only now I understood that when you said (split . onSublist) (".." "a..b...c....d.") you simply translated what I wrote above with the `$` operator
23:12:37 <bahamas> I thought you were giving me the correct answer.
23:18:51 <dminuoso> Is there an obvious way how to do something like `asum [Foo <$ str "foo", Bar <$ str "bar", Quux <$ str "quux"]` with optparse-applicative?
23:20:04 <dminuoso> More specifically, I want to do this on an argument, such as to parse `--type foo` into `Foo`, `--type baz` into `Baz`, etc..
23:21:02 <iqubic> What is impredictive polymorphism?
23:24:33 <c_wraith> iqubic: being able to put a forall inside any type constructor.  It's an extension of RankNTypes, which let you put a forall inside a (->)
23:25:50 <c_wraith> iqubic: a common place one might run into it is attempting to store lenses in a list.  That would have a type like [forall f. Functor f => (a -> f a) -> s -> f s]
23:26:14 <c_wraith> iqubic: that is an impredicative type because the forall is inside the [] type
23:30:46 <yasar> This is supposed to be equivalent to standard map function: map' f = foldr (\x y -> (f x):y) []
23:30:52 <yasar> is it correct?
23:31:54 <bahamas> :t foldr
23:31:56 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
23:32:40 <iqubic> Right. I see,
23:33:09 <iqubic> I don't like or understand this error: http://dpaste.com/1S5SJZH
23:34:32 <opqdonut> iqubic: [(Num m) => (m,m)] is a pretty useless type anyway
23:34:40 <opqdonut> why not just "type Planet = (Integer, Integer)"?
23:36:01 <opqdonut> iqubic: how could `energy` even turn a `Num m => m` into an `Integer`?
23:37:29 <MarcelineVQ> yasar: looks legit
23:43:24 <yasar> is there an infix "not equals" function?
23:43:40 <mniip> /=
