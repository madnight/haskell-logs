00:04:09 * hackage advent-of-code-api 0.2.6.0 - Advent of Code REST API bindings and servant API  https://hackage.haskell.org/package/advent-of-code-api-0.2.6.0 (jle)
00:21:39 * hackage advent-of-code-api 0.2.6.1 - Advent of Code REST API bindings and servant API  https://hackage.haskell.org/package/advent-of-code-api-0.2.6.1 (jle)
01:12:53 <jpcooper> Hello. Let's say I have a build system which builds the same Haskell module with the same interface, but with a number of combinations of different compiler arguments. I would like to run benchmarks and tests over the separate compilations of this same module in an automated way. What are the alternatives for doing this? I could do some template haskell stuff, appending a hash to the module name, generating an import stanza and so on,
01:12:53 <jpcooper> or maybe there is another, nicer alternative. I could also use the ffi and use dynamic loading, but that would be a bit silly. Does anyone have some suggestions?
01:14:10 <merijn> jpcooper: How are you building the haskell code?
01:15:02 <jpcooper> Currently I am building C code with Make. I want to compare it with Haskell code too, all under the same interface, hooking it up to Criterion and Quickcheck. I plan to build all of this with Shake
01:15:27 <merijn> jpcooper: You don't have the shake bits yet?
01:15:47 <jpcooper> I don't. I just want to set off in the right direction if possible
01:17:03 <merijn> Personally I'd just setup your makefile to call cabal-install (which is what I do in my codebase right now), which would actually tie in to my recommendation of "how do I test different flag set ups?". With the v2-build interface you can specify flag configurations in project files and then just tell it with which project file to build
01:17:42 <merijn> jpcooper: So I'd just make a projectfile per configuration to test and setup make to compile the same project with each different config?
01:18:02 <jpcooper> I would like an automated interface. There are quite a few combinations I am testing right now
01:18:20 <jpcooper> I have my Makefile doing a nice cartesian product over the separate alternative sets
01:18:35 <merijn> jpcooper: You could have a small script "jit" generate a project file to build with
01:18:44 <merijn> The syntax of those is trivial enough
01:18:45 <archonest> Hello
01:18:47 <jpcooper> Sometimes I learn about a new alternative set, such as "parallel or not parallel", and want that to work "seamlessly"
01:18:56 <jpcooper> That's true
01:19:21 <jpcooper> merijn: How would I import the separate compilations into one module?
01:20:45 <merijn> hmm that's gonna be painful anyway
01:21:17 <merijn> If you wanna lick everything into the same executable I think any approach you take is gonna be painful
01:21:24 <merijn> s/lick/link
01:22:53 <jpcooper> In the C case I have been using dlopen with RTLD_NOW, which has worked quite nicely. Are there no mirrors of this in Haskell?
01:23:35 <jpcooper> Hi archonest 
01:23:51 <archonest> jpcooper: Hi, how are you doing?
01:24:14 <jpcooper> See above :)
01:25:01 <merijn> jpcooper: Are there mirrors? Sure. But you run into the inconvenient issue that module names must be unique and filenames must match module name in GHC and cabal
01:25:37 <merijn> jpcooper: So there's no easy way to accomplish what you want/suggest without generating a bunch of different files to reprsent each combination of flags if you want to link them into the same Haskell benchmark framework
01:26:47 <merijn> jpcooper: Alternatively, you can look into dons' plugins stuff, but that's not exactly a "well travelled and polished road", 3rd alternative would be, foreign export your Haskell function to C and have your Haskell testing framework foreign import it again, but this will limit the API of your function to the C ABI
01:27:02 <merijn> In the latter case you can just use dlopen
01:27:17 <jpcooper> I wondered whether there was a way of dyanmically linking Haskell files without the alternative you just suggest using dlopen
01:27:26 <merijn> On the bright side, the advantage of the 3rd approach is that you could now easily test/benchmark your C code from Haskell too :p
01:27:37 <archonest> jpcooper: you seems to be busy :) 
01:27:40 <jpcooper> I might well just do that though. Thanks for the ideas
01:28:11 <merijn> jpcooper: GHC Haskell doesn't have a stable ABI, so no there's no real way to dynamically (in the dlopen sense) link a library and get something sensible
01:28:44 <jpcooper> Do you mean that it is not stable when changing GHC versions, or that it is not stable given a fixed GHC version?
01:30:35 <merijn> jpcooper: It's definitely not stable across GHC versions, I don't know about a specific GHC version, but I also am not aware of a dlopen like primitive for GHC (since dlopen obviously doesn't understand GHC's ABI at all)
01:33:59 <jpcooper> Understandable. Thanks
01:36:07 <merijn> Anyway, now that I thought about it, the idea of unifying both the C and Haskell code behind the same C ABI interface and using quickcheck/criterion for both seems like a pretty reasonable approach
01:37:23 <jpcooper> Yes. I want to move away from self-generating Makefiles and shell scripts ASAP
01:50:28 <haskelllisp[m]> http://dev.stephendiehl.com/hask/#phantom-types
01:50:29 <haskelllisp[m]> why `example4 = combine b c`
01:52:09 <boxscape> it's an example to illustrate that type errors occur if the types don't match
01:53:47 <haskelllisp[m]> why `t` can match `()`....
01:54:05 <boxscape> because `t` is a type variable rather than a concrete type, it can match any type
01:54:14 <boxscape> Void can't match () because both are concrete types
01:54:33 <boxscape> uh or wait
01:54:41 <boxscape> one second
01:55:16 <jpcooper> The reason is that t cannot remain polymorphic. Void should take the place of t for example4 to compile
01:55:45 <boxscape> right, the direct reason for the type error is the type signature
01:57:32 <boxscape> (well maybe it is - I thought `b :: Foo Void Int` but it's actually `Foo t Int`
02:00:49 <haskelllisp[m]> What does `remain polymorphic` mean? Must be an explicit type?
02:02:45 <boxscape> haskelllisp[m] type variables (like `t`, `a`, `b` etc.) or types containing them are (typically) polymorphic. They can be made into concrete types by replacing each type variable with a concrete type. Types not containing any of them are monomorphic.
02:04:25 * merijn mumbles something about 'concrete type' being incredibly ill-defined
02:04:29 <haskelllisp[m]> ok thanks
02:05:01 <jle`> merijn: no need to mumble :)
02:05:14 <jle`> in this case concrete doesn't really add anything new either because 'monomorphic' is already in the conversation
02:05:22 <boxscape> that's fair
02:06:04 <merijn> @hoogle Bifunctor p => p a b -> p b a
02:06:05 <lambdabot> Control.Invertible.BiArrow invert :: BiArrow a => a b c -> a c b
02:06:05 <lambdabot> Data.Bifunctor.Braided braid :: Braided f => f a b -> f b a
02:06:05 <lambdabot> Data.Groupoid inv :: Groupoid k => k a b -> k b a
02:06:12 <merijn> hmm
02:06:28 <merijn> Oh, wait I guess I just want "either Right Left"
02:06:35 <jle`> it's not possible 'in general', but it's possible for pretty much every Bifunctor instance in Haskell
02:06:44 <jle`> since all haskell bifunctors are pretty much just either (,) or Either
02:06:51 <boxscape> it's annoying to me that forall is typically not taught to haskell beginners
02:08:19 <merijn> Ugh, no that's not good enough
02:08:36 <merijn> bleh, I just wait traverse that returns the first Right
02:08:42 <merijn> s/wait/want
02:08:44 <merijn> Typing is hard
02:09:12 <boxscape> It's not possible with Const, right?
02:09:44 <jle`> boxscape: ah, good point
02:09:58 <jle`> merijn: if only 'asum' worked
02:10:13 <jle`> and we didn't have that weird story with either's orphan Alternative instance
02:10:30 <merijn> oh!
02:11:01 <jle`> you can use rights and safeHead maybe
02:11:30 <merijn> Why isn't Either an instance of Alternative, actually?
02:12:16 <jle`> as far as i know, the main reason (besides 'nobody cares enough') is that there is an oprhan instance for Either that exists in a popular library
02:12:43 <jle`> but i'm not sure if that actually matters, since adding an instance for Either in base would just mean having to require a base bounds i guess on that other library
02:12:57 <haskelllisp[m]> boxscape: I still don't understand everything about `forall`
02:12:58 <lavalike> the-library-that-shall-not-be-named
02:13:15 <jle`> you can trust me when i say you've probably used this library :)
02:13:32 <merijn> haskelllisp[m]: Well consider the constructor "Nothing", what type does it have?
02:13:34 <lavalike> next it'll turn out I wrote it!
02:13:55 <jle`> and pretty much all haskell-in-production systems import it and use it
02:14:11 <merijn> This lack of instance is ruining my educational version of AoC >.<
02:14:13 <jle`> it permeates the fabric of the haskell ecosystem to its core
02:14:35 <jle`> merijn: maybe see if the orphan instance is usable in your case
02:14:41 <merijn> Where is it?
02:14:58 <jle`> Control.Monad.Trans.Except
02:14:59 <haskelllisp[m]> Nothing :: Maybe a
02:15:37 <jle`> oh wait no that's not where it is
02:15:56 <jle`> it's in Control.Monad.Either
02:16:00 <jle`> and actually you're not going to like it
02:16:12 <jle`> instance Error e => Alternative (Either e)
02:16:23 <jle`> i don't even know how this happened
02:16:40 <merijn> Christ
02:17:13 <merijn> Fuck it, I'll just use validation
02:17:24 <jle`> ooh ooh🇮
02:17:31 <jle`> remember that 'transformers' exports its own version of Validation
02:17:58 <jle`> oh wait nvm it doesn't have the right Alternative instance either
02:18:06 <merijn> o.O
02:18:08 <merijn> Since when?
02:18:59 <jle`> since 0.3.0.0 in 2012 apparently!
02:19:08 <jle`> it's one of those little known things
02:19:09 <merijn> I don't see a validation at all?
02:19:13 <jle`> they call it Errors
02:19:23 <lavalike> where is Control.Monad.Either ?
02:19:46 <lavalike> stackage doesn't find it
02:20:22 <jle`> but yeah it has no Alternative instance
02:20:28 <jle`> lavalike: whoops i meant Control.Monad.Except
02:20:30 <jle`> from 'mtl'
02:20:44 <merijn> jle`: Validation does have an alternative, so there's that
02:20:53 <jle`> yeah, i suppose that's a win
02:21:36 <merijn> Is there a foldMap for Alternative?
02:22:10 <merijn> Guess not
02:22:11 <jle`> this is something i've always wanted for a while too
02:22:24 <merijn> jle`: I'm so happy that 8.8 has foldMap' :>
02:22:59 <jle`> you'll have to `getAlt . foldMap Alt`
02:23:07 <jle`> getAlt . foldMap (Alt . f)
02:23:10 <jle`> merijn: ooh, what does that do?
02:23:17 <merijn> jle`: foldMap, but strict
02:23:28 <merijn> jle`: So you can actually sensibly foldMap stuff like Sum/Product
02:23:30 <jle`> ah neat :o
02:23:44 <jle`> i feel like there's so much neat stuff in 8.8 that i don't know about
02:23:48 <jle`> because the documentation is still not online
02:23:52 <merijn> I know
02:24:25 <boxscape> jle` if you didn't know, there's docs here, fwiw https://downloads.haskell.org/~ghc/8.8.1/docs/html/libraries/index.html
02:24:40 <jle`> boxscape: :O
02:24:52 <jle`> this changes my life
02:25:13 <boxscape> I got it from here :) https://gitlab.haskell.org/ghc/ghc/issues/17246
02:25:37 <jle`> i guess what i really wanted was a changelog for base, but that's always been available in the repo
02:27:07 <jle`> woo hoo http://git.haskell.org/ghc.git/blob_plain/HEAD:/libraries/base/changelog.md
02:27:14 <jle`> i've been too lazy this whole time to find it
02:27:34 <jle`> oh, there isn't that much actually
02:28:15 <jle`> the base coming with ghc 8.10 though .... that one is a game changer
02:28:22 <jle`> we'll finally have getDown :O
02:28:37 <jle`> footloose wins
02:29:13 <jle`> also Monad instances for (,,) ... 
02:29:31 <jle`> and finally A Monad instance for Kleisli which always felt like an odd omission
02:30:13 <jle`> the main thing i'll be using probably is getDown
02:30:30 <merijn> Monoid typeclass, best typeclass
02:30:37 <shachaf> A monad instance for Kleisli? What's that for?
02:31:18 <jle`> i feel like literally nobody will benefit from it
02:31:31 <jle`> but it always felt weird that it was missing
02:31:59 <jle`> i suppose you could start using it as a `ReaderT` that's in base
02:32:22 <jle`> with do notation
02:32:28 <jle`> if that's your thing
02:33:17 <jle`> lifting would be awkward but that's something you can manually write as a helper function. incompatibility with do notation can't be fixed with a helper function
02:33:45 <jle`> but i don't know why anyone would want to avoid importing transformers anyway
02:35:09 * hackage nonempty-containers 0.3.3.0 - Non-empty variants of containers data types, with full API  https://hackage.haskell.org/package/nonempty-containers-0.3.3.0 (jle)
02:36:49 <boxscape> perhaps someone at some point has had a university assignment where they were only allowed to use bindings from base
02:37:04 <boxscape> though that doesn't seem common
02:40:01 <moritz55> hey guys! Would be awesome If you could help me with two beginner questions. why is the type of `f :: (Ord a, Num b) => a -> b -> a` when invoked like `f 1 (2 :: Integer)` `Num a, Ord a` and NOT `Integer`. And the second question: given a signature of `f2 :: (Ord a, Num b) => a -> b -> a` and then applied with `f2 (1 :: Integer) 2` is apparently of
02:40:02 <moritz55> type `Integer` and NOT `Num a, Ord a`) thx!!``
02:41:07 <boxscape> does f2 have a definition as well or just a type signature?
02:42:19 <boxscape> looks like it doesn't matter, actually
02:42:32 <__monty__> Then how would you infer the Num a?
02:42:45 <merijn> Ugh, why is vector only 1 dimensional? Now I have to actually think about today's problem >.>
02:42:48 <__monty__> Surely that's because a Num operation is performed on a and b?
02:43:01 <__monty__> Thinking's the worst.
02:43:06 <merijn> __monty__: I know!
02:43:09 <boxscape> __monty__ I'm not sure but I gave it undefined as definition and the type of the application is Integer
02:43:26 <boxscape> oh
02:43:30 <boxscape> maybe ghci defaulting somehow?
02:43:33 <merijn> Oh, I did just have an epiphany on how to tackle it
02:43:56 <moritz55> boxscape the actual function is `undefined`
02:44:02 <moritz55> doesnt matter
02:44:13 <moritz55> no operations applied whatsoever
02:45:29 <moritz55> __monty__ no Num operations provided. the actual function definitions are just `undefined`
02:45:55 <boxscape> moritz55 okay, so in the first case, you're matching `b` with `Integer`, but you're not actually matching any concrete type with `a`
02:46:00 <boxscape> % :t 2
02:46:00 <yahb> boxscape: Num p => p
02:46:19 <boxscape> so the Constraint that integer literals have is applied to `a`
02:46:32 <boxscape> there's no reason to make it more specific
02:47:48 <boxscape> moritz55 in the second case, b doesn't appear anywhere in the return type of f, the return type is just `a`. So any constraints on b don't need to appear either, though by default ghc will match b with Integer (it just doesn't show up anymore)
02:48:21 <boxscape> (gotta go)
02:55:11 <moritz55> boxscape thanks a lot. and why is it actually not of type `Num a => a` ? 
02:56:12 <__monty__> moritz55: The example boxscape showed? That's the exact same type, the names don't matter.
02:56:49 <__monty__> I assume it's just using the name in the definition of the class or something.
02:57:49 <__monty__> Nope, it's defined in base with `a`. Not sure why it chooses `p`.
02:57:49 <moritz55> __monty__ the type is `(Num a, Ord a) => a ` but I would have thought it's just `Num a => a`
02:58:07 <__monty__> But you have the Ord a constraint in your definition.
02:58:21 <__monty__> It's just carrying that information forward.
02:59:10 <moritz55> __monty__ yes, but just for `b` I thought
02:59:44 <__monty__> No, you defined the function with Ord *a*, not Ord b.
03:02:53 <moritz55> __monty__ sorry, yes. so given the type (Ord a, Num b) => a -> b -> a for `f` and applied with `f 1 (2 :: Integer) ` I would have thought the type is `Num a => a`
03:03:09 <moritz55> __monty__ but it's `(Num a, Ord a) => a`
03:04:06 <__monty__> Your definition says the output is constrained with `Ord a`, and your usage of the function adds the information that it's also constrained with `Num a`.
03:04:47 <__monty__> The `Ord a` doesn't just apply to your "input" `a` if you will. But also to your "output" `a`.
03:05:02 <moritz55> __monty__ :facepalm ... now it made "click" THANK YOU, __monty__ and boxscape
03:05:11 <__monty__> np
03:09:28 <rifkik> https://i.imgur.com/UaxizlZ.png I have some issues with my code, the subject matter is in the image
03:13:06 <__monty__> rifkik: I think you want to add `return (Left "Your error message.")` to the end of the choice list in `element`.
03:13:40 <__monty__> Please add type signatures to at least your top level bindings though. Makes things way more understandable.
03:14:33 <rifkik> Explain please?
03:14:40 <rifkik> I'm sstill very new to Hasskell
03:15:58 <__monty__> (Are you sure you want to use Parsec, btw? Megaparsec's pretty nice.)
03:16:18 <rifkik> What's the difference
03:16:49 <__monty__> Megaparsec's not as old. It aims to be more performant and have better error reporting.
03:17:13 <rifkik> ok
03:17:47 <__monty__> Ignore my previous solution btw. You'd probably want to use `<?>`.
03:17:47 <lavalike> yeah now there's a whole spectrum of parsers to choose from depending on use case, for binary formats all the way up to optimized for human
03:19:23 <rifkik> I did this
03:19:24 <rifkik> let m1 = tr1 >>= notes 1 <?> "Error"
03:19:26 <rifkik> but
03:19:36 <rifkik> Couldn't match type ‘[]’ with ‘ParsecT s u m’
03:19:36 <rifkik>   Expected type: ParsecT s u m [(Ticks, Message)]
03:19:36 <rifkik>     Actual type: [[(Ticks, Message)]]
03:20:37 <dminuoso> rifkik: Some might take offense in hopping into multiple channels and asking the same question at the same time.
03:24:16 <__monty__> rifkik: `notes 1` isn't of type ParsecT... so you're using `<?>` wrong.
03:24:54 <rifkik> So, what should it be?
03:25:38 <__monty__> Maybe add all the missing type signatures first. Might clear things up for you.
03:26:39 * hackage neat-interpolation 0.3.2.5 - A quasiquoter for neat and simple multiline text interpolation  https://hackage.haskell.org/package/neat-interpolation-0.3.2.5 (NikitaVolkov)
03:28:43 <svipal> pleased to announce the very tired kind of megaparsec problem was indeed solved by sleep
03:29:00 <rifkik> Nice
03:29:15 <hwabyong> :q
03:39:37 <lavalike> do you happen to have a link to an example of how to configure cabal to run tests? I have no experience with the whole thing but I did notice the command "cabal test" is available
03:39:55 <lavalike> the user's guide shows that there are configuration options but I'm unsure as how to set it up altogether
03:41:06 <__monty__> lavalike: The tasty readme has an example: http://hackage.haskell.org/package/tasty (Shameless plug ; ))
03:42:32 <lavalike> thanks!
03:44:52 <fendor> where is the location of the .ghci script that stack uses to load a package?
03:45:43 <dminuoso> fendor: .ghci script?
03:47:16 <fendor> dminuoso, iirc, stack repl uses a .ghci script to add targets so that it can load a component
03:55:00 <__monty__> Are you sure that script is stored and not temporarily generated from stack.yaml et al?
03:55:36 <dminuoso> fendor: What exactly are you talking about?
03:55:43 <dminuoso> Im just curious.
03:56:44 <dminuoso> fendor: Are you talking about the .ghc.environment type of files that cabal v2-* generates?
03:57:03 <merijn> dminuoso: He's talking about stack, so no?
03:57:55 <dminuoso> merijn: Im aware, I was wondering whether they meant something comparable to them.
03:59:38 <lavalike> __monty__: since it's yours, do you think the correct way to go about this is to have one test-suite entry for each binary in my multiple-binaries repo?
04:00:18 <__monty__> lavalike: Oh, no. I have no hand in tasty. I just like it : ) That's entirely up to you. Sounds reasonable.
04:07:39 * hackage hedis 0.12.10 - Client library for the Redis datastore: supports full command set,pipelining.  https://hackage.haskell.org/package/hedis-0.12.10 (k_bx)
04:13:08 <merijn> Anyone know where to send things for inclusion in Haskell Weekly?
04:15:00 <merijn> Found it, Github issue apparently
04:15:39 <boxscape> merijn maybe you was it but website says email is possible as well
04:15:45 <boxscape> s/was/saw
04:21:51 <merijn> Relatedly, for anyone in the vicinity of the Netherlands now's the chance to register for the NL-FP day: https://sites.google.com/view/nl-fp-day-2020/home
04:39:39 * hackage hOpenPGP 2.9 - native Haskell implementation of OpenPGP (RFC4880)  https://hackage.haskell.org/package/hOpenPGP-2.9 (ClintAdams)
04:51:26 <boxscape> It seems odd that `map` still only works for lists when other list functions have been generalized to Foldable
04:52:43 <merijn> boxscape: map can't work on Foldable
04:52:51 <merijn> What would it do?
04:53:06 <boxscape> merijn I mean generalize it to Functor
04:53:19 <boxscape> like other list functions have been for Foldable
04:53:23 <bahamas> boxscape: there's fmap
04:53:36 <boxscape> yeah
04:53:39 <bahamas> or you mean simply generalizing map
04:53:50 <boxscape> I'm suggesting map = fmap which is common in custom Preludes
04:53:56 <dminuoso> bahamas: The choice for `map` being specialized to list is a historical choice. It was intended to simplify diagnostics for beginners.
04:54:13 <boxscape> dminuoso right, but couldn't you make that same argument for foldr, for example?
04:54:19 <bahamas> dminuoso: that makes sense and I agree with the intention
04:54:32 <bahamas> boxscape: that's true
04:54:50 <boxscape> IIRC foldr used to only work for lists at some point
04:55:02 <merijn> boxscape: Lots of people objected to the generalisation of foldr
04:55:08 <boxscape> hm, okay
04:55:20 <Putonlalla> Talking about `foldr`, I have a vague question.
04:55:23 <Putonlalla> What would be the recursion scheme of choice for comparing two trees for nonstructural equality?
04:59:52 <Putonlalla> The usual way of using a hylomorphism to build a difference tree and searching it for changes doesn't work.
05:09:25 <bahamas> boxscape: one reasoning could have been that map is a lot more common than fold.
05:09:39 * hackage mmsyn6ukr 0.3.3.0 - A musical instrument synthesizer or a tool for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.3.3.0 (OleksandrZhabenko)
05:09:41 <boxscape> I suppose
05:12:43 <bahamas> it's less meaningful, but I would rename `dropWhileEnd` to `dropFromEndWhile`. 
05:26:51 <svipal> Please infuse me with the courage to build software cleanly and properly
05:27:24 <svipal> instead of piling up clunk that works fast
05:28:00 <merijn> svipal: Just pile up clunk first, then refactor until clean
05:28:09 <svipal> that's what I do
05:28:16 <svipal> but I am in the refactoring phase
05:28:21 <merijn> Most of that very clean Haskell code out there in the world didn't *start* clean :p
05:29:12 <Rembane> svipal: You're in Haskell you need no courage, refactor without fear and go forth into the code! 
05:35:34 <bahamas> what the order of evaluation of function arguments? does it depend on the function? I'm asking in relation this https://wiki.haskell.org/Foldr_Foldl_Foldl%27
05:35:51 <bahamas> as far as I understand, in the case of (+), the second argument is evaluated first
05:38:25 <boxscape> > undefined + error "test"
05:38:27 <lambdabot>  *Exception: test
05:38:33 <boxscape> looks like you're right
05:38:54 <boxscape> I think for (+) it purely depends on the implementation
05:39:02 <dminuoso> bahamas: Haskell has no defined order of evaluation, in general.
05:39:05 <dminuoso> bahamas: However! 
05:39:32 <dminuoso> bahamas: If you write a function with pattern matching in arguments, with multiple definitions, then it will work left to right, top to bottom.
05:40:08 <boxscape> % undefined +# error "test"
05:40:08 <yahb> boxscape: ; <interactive>:8:1: error:; * Couldn't match a lifted type with an unlifted type; When matching types; () :: *; Int# :: TYPE 'GHC.Exts.IntRep; * In the first argument of `print', namely `it'; In a stmt of an interactive GHCi command: print it
05:40:19 <boxscape> % I# (undefined +# error "test")
05:40:19 <yahb> boxscape: *** Exception: test; CallStack (from HasCallStack):; error, called at <interactive>:9:18 in interactive:Ghci6
05:40:23 <dminuoso> % let f False False = (); f _ _ = () in f True undefined
05:40:23 <yahb> dminuoso: ()
05:40:29 <dminuoso> ^- this is guaranteed to never produce bottom.
05:40:40 <dminuoso> And likewise
05:40:52 <dminuoso> % let f True _  = (); f _ False = () in f True undefined
05:40:52 <yahb> dminuoso: ()
05:40:58 <dminuoso> This too is guaranteed to never produce bottom
05:41:31 <boxscape> are error and undefined specified in the haskell report?
05:42:13 <dminuoso> boxscape: Yes
05:42:14 <boxscape> they are
05:42:16 <boxscape> okay
05:44:49 <dminuoso> Im having trouble finding the argument why its left to right..
05:45:08 <dminuoso> But the top-to-bottom derives from the fact that multiple function definitions desugar into a case-of, and thats defined to work sequentially from top to bottom.
05:45:50 <bahamas> after reading that article about folds, I feel like you need to know by heart the implementation of each and what their implications are. is that so, or it's just the article being conservative in its recommendations?
05:46:11 <bahamas> another way of asking: do you have different, more simple rules of thumb than what it says there?
05:47:34 <dminuoso> Ah there we go. It's derived from the semanatics of pattern matching (3.17.2)
05:49:16 <boxscape> % let f ~False False = (); f _ _ = () in f True undefined
05:49:16 <yahb> boxscape: *** Exception: Prelude.undefined; CallStack (from HasCallStack):; error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err; undefined, called at <interactive>:16:47 in interactive:Ghci10
05:50:47 <boxscape> bahamas I think generally speaking it's probably enough to know what they do rather than the implementation, but especially for foldr it can be useful to know the (or an) implementation if you want to make use of how general it is, for example as described in https://ertes.eu/tutorial/foldr.html
05:52:12 <boxscape> otherwise I think it's usually enough to just have the picture where `foldr f z $ a : b : c : []` gets converted into a `f` b `f` c `f` z
05:52:31 <boxscape> or rather
05:52:42 <boxscape> a `f` (b `f` (c `f` z)) for foldr
05:53:34 <boxscape> > foldr f z $ a : b : c : []
05:53:37 <lambdabot>  f a (f b (f c z))
05:53:53 <boxscape> > foldl f z $ a : b : c : []
05:53:56 <lambdabot>  f (f (f z a) b) c
05:54:10 <bahamas> boxscape: I have the feeling that someone new to functional programming will only see fold as an alternative to the for loop. for that use case, foldl' is best, no?
05:54:58 <boxscape> hm, I suppose it depends on exactly what kind of loop, but usually I think that sounds right
05:55:07 <int-e> bahamas: I'm not sure; I'd argue that explicit recursion is best.
05:55:25 <boxscape> some argue against explicit recursion
05:55:45 <bahamas> int-e: you mean rather than using fold? if so, I agree that it feels clearer to me to see explicit recursion rather than a fold
05:56:14 <bahamas> maybe it was also because until I read the page I linked above (which happened just know), I couldn't tell you the difference between all the folds
05:56:41 <int-e> bahamas: Yes, that's what I'm saying. Learning to recognize folds is useful though, for fusion and the like.
05:57:04 <boxscape> folds (and recursion schemes in general) have the advantage that if you're familiar with them, it's easier to see at glance what a function does than with explicit recursion, and in fact it can improve code reuse. The disadvantage is that if someone is not familiar with them, it can be a lot harder to understand.
05:57:53 <kuribas> boxscape: it's a little gain, but a large drawback.  IMO it only makes sense when you have a team that is all interested in this stuff.
05:58:00 <bahamas> boxscape: to me folds are advanced territory. it's probably why Foldable is one of the last type classes taught in general
05:58:03 <sandman13> isn't fold{r,l,l'} the stuff you learn early on?
05:58:36 <int-e> Don't get me wrong, I *do* use folds. But I normally don't go out of my way to shoehorn recursion into a fold when it's not convenient.
05:58:48 <kuribas> bahamas: a Foldable is a structure whole values you can reduce to a single value.
05:59:01 <bahamas> it looks like you also need to understand laziness to understand folds, and laziness is another concept which people have trouble with
05:59:19 <kuribas> bahamas: the different ways to folds are just variations.
05:59:29 <boxscape> int-e sure, there are definitely cases where folds are really annoying compared to explicit recursion
05:59:34 <bahamas> kuribas: yes, that sounds simple enough. if you read the page about the different folds, it doesn't sound so simple any more
05:59:39 <kuribas> bahamas: do fold from the left, from the right, or using a monoid.
05:59:40 <int-e> Also I susepct foldr is more common thant foldl' in my code.
05:59:50 <sandman13> if they don't understand laziness, you can say they are *drum rolls* lazy
06:00:48 <kuribas> bahamas: it helps to unroll the folds
06:01:23 <kuribas> > foldr (@@) a [b, c, d]
06:01:26 <lambdabot>  b @@ (c @@ (d @@ a))
06:01:29 <bahamas> int-e: probably for the short-circuiting logic. as far as I understand, that's one of foldr's biggest selling point
06:01:34 <boxscape> :t (@@)
06:01:36 <lambdabot> Expr -> Expr -> Expr
06:01:44 <kuribas> > foldl (@@) a [b, c, d]
06:01:46 <lambdabot>  ((a @@ b) @@ c) @@ d
06:02:49 <bahamas> kuribas: for non short-circuiting situations, foldr seems to be the most space consuming. so I would recommend avoiding it
06:03:01 <Raito_Bezarius> Is there a way to define two arrays recursively which uses each other?
06:03:03 <kuribas> bahamas: it depends
06:03:08 <bahamas> but if you do know that you have a short circuit, it's the recommended approach
06:03:17 <sandman13> isn't foldr preferred to foldl because it does lazy evaluation?
06:03:18 <opqdonut> bahamas: doesn't need to be short-circuiting
06:03:30 <opqdonut> e.g. foldr (++) is way better than foldl (++)
06:03:31 <bahamas> sandman13: see this page https://wiki.haskell.org/Foldr_Foldl_Foldl%27
06:03:32 <boxscape> sandman13 often you don't actually want lazy evalutaion
06:03:45 <kuribas> sandman13: for lists foldr is more general.  You can implement foldl in terms of foldr, but not the other way around.
06:04:18 <bahamas> opqdonut: I think the argument is between foldr and foldl' when it comes to space efficiency
06:04:27 <sandman13> I see
06:05:07 <boxscape> sandman13 for something like sum, where you know you'll need to see what all the list elements are, the fact that foldr can handle infinite lists doesn't help you
06:05:33 <sandman13> it depends on the type of the operation I am performing as it seems
06:05:46 <boxscape> sandman13 and because you know that you'll need all list elements, the strict foldl' is preferred over the non-strict foldl and foldr
06:06:18 <bahamas> that's why I said it's more complicated than it first seems
06:07:07 <sandman13> I was under false impression
06:07:23 <sandman13> that foldr is the way to go
06:07:28 <boxscape> I don't really think that's much of an advantage of explicit recursion - you still have to worry about these things if you want performance, you just have to handle it manually
06:07:53 <int-e> bahamas: it's also a result of working with lists as iterators... foldr can transform an iterator into another one without ever producing the whole underlying list at any point.
06:07:55 <kuribas> sandman13: as a general rule, if you need to be lazy, use foldr, otherwise foldl or foldl'
06:08:08 <sandman13> will keep that in mind kuribas 
06:08:09 <bahamas> boxscape: I think that the argument is that, if you don't want performance, explicit recursion is easier to reason about
06:08:13 <sandman13> thanks
06:08:25 <int-e> bahamas: Note that this ties into opqdonut's  foldr (++)  example.
06:08:49 <bahamas> int-e: you mean that's an example of a list as iterator?
06:08:52 <kuribas> bahamas: It's the other way around
06:08:58 <boxscape> boxscape again, depends on how familiar you are with the concepts. I could tell you immediately that sum with foldr is `foldr (+) 0`, with explicit recursion I'd have to think about it a few seconds
06:09:13 <boxscape> I replied to myself...
06:09:17 <int-e> bahamas: It applies to lists as generators.
06:09:19 <boxscape> I meant bahamas
06:09:36 <merijn> I'm just baffled why the hell sum and product are still foldl, rather than foldl'
06:09:43 <boxscape> oh wow I had no idea
06:09:56 <merijn> It's a travesty
06:10:07 <bahamas> boxscape: I agree. what I'm saying is that fold hides behind it's name several concepts. if you're familiar with its meaning, than it's probably easier to understand because it's more terse
06:10:24 <bahamas> boxscape: but explicit recursion is, well, explicit
06:10:29 <int-e> bahamas: More generally, foldr f tends to be preferable to foldl (flip f) when f can produce partial results based on its first argument (and the order of elements in the processed lists doesn't matter or can easily be reversed).
06:10:44 <merijn> As is the use of foldMap in the default definitions of Foldable
06:11:15 <boxscape> bahamas that's actually just an incidental consequence of the decisions behind haskell as a language - if we were using Church encodings for datatypes, folds would be the fundamental way to traverse a list (or other recusive data structures)
06:12:22 <bahamas> boxscape: can't argue with you about that, because I don't know what Church encodings are
06:13:50 <boxscape> bahamas a way to encode algebraic data types - for example, instead of defining `data List a = Nil | Cons a (List a)`, you could have `data List a = List (forall a b . (a -> b -> b) -> b -> b)`, which you might notice looks a lot like the type of foldr
06:14:53 <boxscape> (uh, almost. The a shouldn't be part of the forall)
06:15:26 <boxscape> % data List a = List (forall b . (a -> b -> b) -> b -> b)
06:15:26 <yahb> boxscape: 
06:17:15 <bahamas> boxscape: there's one more thing I want to say. I'm writing all this from the perspective of an imperative programmer. someone who has had some exposure to recursion. I imagine that for someone coming from mathematics, fold will look more intuitive
06:18:11 <boxscape> quite plausible, depending on what kind of math they've been exposed to. Though there are some classic recursive definitions in mathematics as well.
06:18:22 <boxscape> or well
06:18:44 <boxscape> it will probably look more intuitive to a mathematician than to an imperative programmer, I would agree with that
06:19:22 <bahamas> here's what I'm curious: if you were to make a decision tree that helps someone decide which fold to use, how would it look like?
06:20:41 <boxscape> my first attempt would be: need infinite lists ? use foldr : building up large structure ? use foldl : use foldl', but I might be missing some subtleties
06:22:47 <merijn> boxscape: I don't see any reason you'd ever have foldl as valid result from the decision tree
06:23:14 <boxscape> merijn I read the other day that for something like reverse it makes sense, but I'm not sure if it's actually better than foldl'
06:24:23 <merijn> boxscape: That is predicated on the assumption that "implementing reverse with foldl is reasonable"
06:25:22 <boxscape> hm, I think it says that rather than assuming it?
06:26:09 <boxscape> would you implement it with foldl' or some other way?
06:28:18 <boxscape> ^ merijn
06:31:02 <merijn> I wouldn't use fold at all
06:32:17 <gentauro_> naming convention in Haskell (I don't really understand the Hungarian notation ...). Is it `MonadRandom` or `RandomM`?
06:32:35 <gentauro_> are there some official guidelines or best practices when it comes to naming "stuff"?
06:32:50 <Raito_Bezarius> is there a way to write floor (n / 2) when n :: Int ?
06:32:59 <boxscape> > 7 `div` 2
06:33:02 <lambdabot>  3
06:33:14 <Raito_Bezarius> do div perform a floor?
06:33:17 <boxscape> yes
06:33:20 <Raito_Bezarius> thanks!
06:33:23 <boxscape> np
06:33:27 <int-e> > (-7) `div` 2
06:33:30 <lambdabot>  -4
06:33:47 <int-e> > 7 `div` (-2) -- also a fun case
06:33:50 <lambdabot>  -4
06:34:01 <boxscape> > 7 `quot` (-2)
06:34:03 <lambdabot>  -3
06:34:32 <int-e> ceil (n/2) = (-n) `div` (-2)
06:34:33 <merijn> gentauro_: MonadX is generally for a typeclass defining an interface for a monad that implements functionality X
06:35:40 <gentauro_> merijn: roger that
06:36:27 <Raito_Bezarius> Is there a test framework where I can do IO to load fixtures?
06:36:38 <Raito_Bezarius> (I know of Test.Framework, but unsure if I can pull it with this)
06:36:47 <merijn> Raito_Bezarius: Most of them, I think?
06:38:11 <dminuoso> Raito_Bezarius: You can always do IO ahead of time for loading. Depending on your use case, lazy IO might also be an option.
06:38:34 <Raito_Bezarius> Alright, I was not sure if the test framework provided a hook to do some IO
06:38:54 <dminuoso> Raito_Bezarius: You should pick your test framework according to the testing semantics you need.
06:39:35 <dminuoso> Raito_Bezarius: Loading fixtures is not as relevant to testing itself, as you could do it outside your framework if need be.
06:40:16 <dminuoso> Though it depends a bit on what you mean by "fixtures"
06:40:29 <Raito_Bezarius> Basically, I have files which contains parameters to pass to a function
06:40:38 <Raito_Bezarius> And I have a static mapping between filenames and result
06:40:57 <Raito_Bezarius> But if IO is doable using most of the test frameworks, I guess I'm fine
06:41:04 <Raito_Bezarius> I have randomized property checks & hardcoded tests cases
06:41:06 <dminuoso> Raito_Bezarius: Or just do it outside the test framework.
06:41:36 <dminuoso> Raito_Bezarius: data Expectation = Expectation { input :: Int, output :: Char }; loadExpectations :: FilePath -> IO [Expectation]
06:41:49 <Raito_Bezarius> I have already done something like this
06:42:07 <Raito_Bezarius> I was not sure I could pass [Expectation] to my unit tests
06:42:11 <dminuoso> Raito_Bezarius: Sure you can.
06:42:16 <Raito_Bezarius> Hmm, you're right
06:42:27 <dminuoso> Raito_Bezarius: You just make it a function. :)
06:42:28 <Raito_Bezarius> I could just do [Expectation] × Callable → [UnitTest] for example
06:42:31 <dminuoso> Right. 
06:42:37 <Raito_Bezarius> Makes super sense, thanks
06:43:48 <dminuoso> Raito_Bezarius: This trick of moving IO out of the equation is pervasive throughout Haskell, by the way.
06:44:18 <dminuoso> Instead of trying to find a way to sneak IO in, you get much better results by doing the IO somewhere else and feeding the data in a pure manner through your code.
06:44:28 <dminuoso> It keeps your pure functions predictable (and testable)
06:44:44 <kuribas> works with logging too
06:45:42 <Raito_Bezarius> dminuoso: Yeah, purer functions are so simple for me to reason about so I try to reduce the IO part as much as I can
06:46:19 <kuribas> I find that the adagium that most of the program is doing IO is false.
06:46:58 <kuribas> even in a IO intensive app it's usually less that half.
06:47:19 <kuribas> But that's hard to see in java.
06:58:29 <arianvp2> How do I differentiate between  " This field is absent" and "This field is explicitly set to null by the user" in Aeson? This is extremely important for implementing PUT correctly for HTTP REST APIs
06:58:35 <arianvp2> and I can't figure it out from the aeson docs :/
07:01:35 <kuribas> arianvp2: omitNothingFields and a nested Maybe
07:01:44 <kuribas> arianvp2: or derive your own instance
07:01:51 <boxscape> wasn't that the difference between .:! and .:? I haven't used Aeson much
07:01:51 <dminuoso> That's for Generic derived.
07:02:11 <kuribas> .:? returns a Nothing if the field doesn't exist
07:02:20 <dminuoso> boxscape: Yes. 
07:02:30 <dminuoso> boxscape: I believe arianvp2 just wants to use (.:!)
07:04:32 <kuribas> right, .:! seems more appropriate
07:04:44 <sm[m]> g'day all
07:05:13 <sm[m]> would anyone know what's going on with https://github.com/GaloisInc/json/issues/11 ? Is there any ghc 8.8-compatible alternative to json ?
07:05:55 <boxscape> like, a library to parse JSON into haskell values and convert haskell values into JSON?
07:06:56 <sm[m]> yes.. on second look at http://packdeps.haskellers.com/reverse/json, I guess json is deprecated and people are moving away from it
07:07:07 <sm[m]> so I need to ferret it out from my deps somehow
07:07:11 <boxscape> sm[m] aeson is what you want
07:09:40 <sm[m]> boxscape: thanks. Having trouble seeing why I thought json was required, have to retest
07:11:12 <maerwald> boxscape: or waargonaut
07:11:32 <boxscape> ^ sm[m]
07:13:31 <sm[m]> I can't just pick anything unfortunately, just trying to satisfy the deps I care about.. hledger-web depends on json somehow, but it's not so easy to see how..
07:15:23 <boxscape> Seems like there must have been someone at some point who made a tool to visualize hackage dependencies
07:16:11 <sm[m]> indeed
07:16:48 <sm[m]> but can I find it and make it work, quicker than staring at package lists by eye
07:19:26 <sm[m]> doh, there it is.. I depend on it directly. I shall expunge it!
07:19:38 <Raito_Bezarius> why can't I do data X = { y :: A } and data Y = { y :: A } ?
07:19:43 <Raito_Bezarius> it says multiple declarations of y
07:19:56 <Raito_Bezarius> isn't this supposed to be namespaced by the datatype?
07:20:03 <c_wraith> records put accessor functions into the module namespace
07:20:19 <Raito_Bezarius> aaah, can't I avoid it?
07:20:50 <c_wraith> Only if you want to go into areas that aren't well-supported yet, like the DuplicateRecordFields extension
07:21:02 <c_wraith> Work is still ongoing there.
07:21:48 <Raito_Bezarius> hmm, I see
07:22:28 <c_wraith> the normal solutions are manual namespacing (xY and yY) or using multiple modules
07:24:11 <c_wraith> The experimental solutions include extensions like DuplicateRecordFields and OverloadedLabels, but their type inference story is pretty sketchy.
07:25:35 <c_wraith> the super-experimental version combines those extensions with lens and generic-lens and actually gets a pretty good user experience including inference and error messages, but at the cost of code that looks very weird to people who aren't familiar with those.
07:25:53 <boxscape> you don't even need generic-lens, I think
07:26:05 <boxscape> as long as you're willing to use template haskell
07:26:17 <c_wraith> yeah, but if you can avoid template haskell, it's a win
07:26:38 <boxscape> true
07:26:58 <boxscape> (I posted this example in the current proposal thread about record syntax https://github.com/ghc-proposals/ghc-proposals/pull/282#issuecomment-542841956 )
07:27:50 <c_wraith> also generic-lens has really nice error message generation.  (custom type errors is one of the best GHC changes in a long time)
07:29:24 <c_wraith> from a test session I have lying around:  > b & #foop +~ 7    <interactive>:32:5: error: • The type B does not contain a field named 'foop'.
07:29:45 <boxscape> neat
07:46:17 <merijn> Ugh, sometimes it sucks that Left/Right are already taken as constructors >.<
07:47:01 <boxscape> how are multiple patterns in function definitions desugared, considering case can only inspect one value? Unboxed tuples?
07:47:36 <boxscape> I guess I could just generate some Core and look at it, unless you can still have more than one equation for a function in Core
07:47:39 <merijn> boxscape: Or, you know, just nested case-of
07:48:12 <merijn> boxscape: The fact that you write compound patterns for functions in no way requires actual simultaneous matching
07:48:36 <boxscape> Oh, yeah I thought that required code duplication but I guess not actually
07:48:52 <merijn> boxscape: What's wrong with duplicating code?
07:49:06 <boxscape> ...good point
07:49:20 <merijn> It's all pure anyway
07:49:24 <Ariakenom> is -threaded default yet?
07:49:45 <merijn> Ariakenom: Definitely not in 8.6, don't think so for 8.8 either?
07:49:50 <geekosaur> I think even case desigars to multiple, when a pattern is complex
07:50:07 <geekosaur> ie. has multiple constructors, the desugaring is to nested core case
07:50:13 <boxscape> makes sesne
07:50:40 <Ariakenom> merijn: :(
07:50:42 <merijn> Anyone got good synonyms to replace Left/Right in "data Dir = Down | Left | Up | Right"? >.>
07:51:03 <boxscape> north west east south?
07:51:04 <Rembane> merijn: D | L | U | R 
07:51:13 <geekosaur> D | L | U | R? or prefix all of those with D
07:51:19 <Rembane> Or what geekosaur said
07:51:29 <merijn> I suppose, but that kind ruins the nicety of using a sum type over Char >.>
07:51:30 <Rembane> geekosaur: Hvae you implanted brain wave reading devices in my head? 
07:52:00 <geekosaur> the whole thing seems reasonably obvious :)
07:52:14 <Rembane> ^^
07:52:40 <merijn> I'm trying to keep the AoC code somewhat clean and nice looking to show to inexperienced haskellers and I think using single letters kinda underminds that >.>
07:53:09 <Ariakenom> use angle in radians :p
07:53:19 <Ariakenom> :: CReal
07:54:42 <maralorn> import Prelude hiding (Left, Right)?
07:55:03 <merijn> maralorn: I was considering that, but I might need those later for errors :\
07:55:05 <geekosaur> there's always DDown | ...
07:55:14 <geekosaur> or DirDown if you want to be verbose
07:55:26 <merijn> geekosaur: Yeah, I guess I'll do something like that, but it's a little sad
07:55:27 <geekosaur> maybe with a comment about Either sitting on the namespace
07:56:04 <Putonlalla> Add `ward` to the end, merijn.
07:56:20 <glguy> Hiding the normal Left and Right is going to be more confusing if the goal is clear code. I think the single letter direction names are the clearest. People immediately recognize them. Longer names would just clutter the code
07:56:24 <geekosaur> kind of a pity there's no way to rename imported names
07:56:34 <maralorn> Perhaps on should do Error = Prelude.Left; Ok = Prelude.Right anyways?
07:57:07 <geekosaur> import Prelude (Left -> ELeft, Right -> ERight); import Prelude hiding (Left, Right)
07:57:17 <glguy> How about Fore Aft Starboard Port?
07:57:19 <geekosaur> maralorn, may also need pattern synonyms
07:57:24 <boxscape> % data Dir = (:↑) | (:←) | (:→) | (:↓)
07:57:24 <yahb> boxscape: 
07:57:31 <merijn> glguy: That doesn't match the AoC names :p
07:57:50 <merijn> glguy: Else I'd just use NWSE
07:58:03 <maralorn> Uh, I vote for boxscapes Solution.
07:58:16 <boxscape> I appreciate it
08:03:37 <sm[m]> when running a doctest suite, stack test sees required packages but cabal test doesn't:  https://github.com/simonmichael/hledger/issues/1139 . How could I fix that (in a way that tests will pass with standard CI, eg hackage's matrix builder) ?
08:03:56 <merijn> sm[m]: "cabal test --enable-benchmarks"
08:04:54 <merijn> sm[m]: Alternatively, set "tests: True" in cabal.project/cabal.project.local
08:05:43 <merijn> (or cabal run, whatever you use)
08:05:44 <nshepperd2> D | L | U | R has the nicety that parse = read . pure :p
08:05:54 <sm[m]> merijn: these don't help with the issue
08:06:10 <sm[m]> well, the first one, I haven't tried the second yet
08:06:28 <merijn> sm[m]: eh..."enable-tests" of course, dunno why I wrote benchmarks there...
08:06:29 <sm[m]> doctest is a bit different
08:06:51 <sm[m]> I can build the doctest suite, but it needs to have packages importable in its runtime environment
08:06:55 <Raito_Bezarius> how can I fill two arrays A, B recursively which uses each other values?
08:06:59 <sm[m]> the linked issue describes it
08:07:24 <merijn> sm[m]: I was mostly guessing based on corner cases I know
08:07:37 <sm[m]> gotcha
08:08:12 <merijn> sm[m]: The doctests use what, ghci?
08:08:17 <maralorn> Raito_Bezarius: Do you mean Lists or Arrays?
08:08:21 <Raito_Bezarius> maralorn: Arrays
08:08:27 <Raito_Bezarius> like I would like to edit multiple times the same index
08:08:36 <Raito_Bezarius> I don't know if that's easily feasible without recreating a new array
08:08:42 <merijn> Raito_Bezarius: You probably want mutable Vector?
08:08:43 <sm[m]> yes I believe so
08:08:47 <glguy> sm: there's a cabal-doctests package that wraps everything up
08:08:51 <Raito_Bezarius> merijn: Something like this
08:09:18 <Raito_Bezarius> merijn: is it possible to do it without IO?
08:09:22 <sm[m]> thanks! checking out http://hackage.haskell.org/package/cabal-doctest
08:09:31 <merijn> Raito_Bezarius: Vector also supports mutable Vector using ST
08:10:02 <maralorn> So now I have nested runReader and get tons of AmbiguousTypes.
08:10:27 <merijn> Raito_Bezarius: ST lets you mutate while within an "ST" action but, unlike IO, ST has a "runST :: ST s a -> a" function
08:10:53 <Raito_Bezarius> Very nice
08:11:06 <maralorn> Is AmbiguousTypes an extension I willl regret enabling?
08:11:14 <boxscape> depends on why you're enabling it
08:11:15 <merijn> Raito_Bezarius: I actually have an example of this I used for Advent of Code (spoilers, obviously!) https://github.com/merijn/AdventOfCode2019/blob/master/Day2.hs#L30-L52
08:13:00 <merijn> Raito_Bezarius: The only restriction with ST is that you can only mutate things within a single ST block. So that example calls "thaw" to copy the immutable Vector into a new mutable one, then runs a bunch of mutating changes on the copied vector before returning a result
08:13:57 <boxscape> maralorn if you're using TypeApplication you sometimes can't get around it (except by using Proxy instead), if not and ghc tells you that you can enable it, it can sometimes make the error message clearer, though in that case I would disable it after that issue is solved
08:14:35 <sm[m]> hmm, cabal's doctest situation is more complicated than I can understand right now. Maybe I can disable that test suite for cabal only
08:15:04 <Raito_Bezarius> merijn: quick question, how can I do a for i in range(1, n) using Control.Monad?
08:15:10 <Raito_Bezarius> It seems like I want to use forM_ but I'm unsure
08:15:24 <merijn> forM_ works
08:15:25 <solonarv> you are correct!
08:15:27 <[exa]> Raito_Bezarius: forM_ [1..n]  ?
08:15:33 <Raito_Bezarius> wow it was so intuitive
08:15:42 <Raito_Bezarius> I thought it was a trap but nice
08:15:50 <boxscape> @src forM_
08:15:50 <lambdabot> forM_ = flip mapM_
08:16:20 <solonarv> the only "trap" is that there are like 8 near-identical and largely interchangeable variants of that function ;)
08:17:07 <solonarv> monadic versions: mapM, forM, mapM_, forM_; applicative versions: traverse, for, traverse_, for_
08:17:08 <Raito_Bezarius> can I nest them?
08:17:18 <solonarv> of course! why wouldn't you?
08:17:20 <Raito_Bezarius> forM_ [1..n] (\i -> forM_ [1..m] (\j -> …)) ?
08:17:27 <solonarv> yup
08:17:32 <Raito_Bezarius> worried about the out type but it seems like it's fine
08:17:40 <boxscape> :t forM_
08:17:42 <lambdabot> (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
08:17:58 <sm[m]> I think I'm right in saying https://www.haskell.org/cabal/users-guide/developing-packages.html#conditions don't allow distinguishing between build tools like cabal and stack
08:18:25 <merijn> sm[m]: They can't because stack uses Cabal
08:18:46 <sm[m]> between cabal-install and stack
08:18:47 <solonarv> stack uses Cabal but not cabal-install
08:19:11 <solonarv> (Cabal is the library, cabal-install is the executable program)
08:19:53 <merijn> sm[m]: stack only controls which packages are visible, Cabal is still responsible for building and it doesn't specify an interface for checking which build tool (and I hope that never happens)
08:20:11 <merijn> sm[m]: You could just have the doctest flag default to off and explicitly toggle it on in stack.yaml?
08:20:36 <solonarv> I was about to suggest something along those lines too, just set the flag in stack.yaml
08:21:21 <sm[m]> good idea, I'll try it - thanks
08:22:16 <boxscape> is there a reason behind some of ghc's flags (like --version) having two dashes but then others (like -ddump-prep) having one?
08:22:43 <Nycatelos> Is there way to apply a bind n times (e.g. bindN init 2 = <Initial value> >>= b >>= b)
08:23:36 <Putonlalla> Are you looking for `replicateM`, Nycatelos?
08:23:51 <Raito_Bezarius> I have this line:
08:24:03 <Raito_Bezarius> forM_ [1..n - 1] (\i -> forM_ [1..m -1] (\j -> VM.write lc j (dist_prog_dyn_value ((VM.read ll j) (VM.read lc (j - 1)) (VM.read ll (j - 1)) (x !! i) (y !! j)))) VM.move lc ll)
08:24:03 <Putonlalla> Possibly even `iterateM` from some utility library.
08:24:06 <Raito_Bezarius> but it's throwing an error
08:24:12 <Raito_Bezarius> an insane one
08:24:21 <Raito_Bezarius> dist_prog_dyn_value returns Int
08:24:49 <Raito_Bezarius> and lc and ll are VM[Int]
08:25:25 <boxscape> what error is it throwing?
08:25:42 <Raito_Bezarius>     • Couldn't match type ‘Int’ with ‘m0 Int -> Char -> Char -> Int’
08:25:45 <Raito_Bezarius>       Expected type: m2 (Int -> Int -> Char -> Char -> Int)
08:25:47 <Raito_Bezarius>                      -> m0 Int -> Char -> Char -> Int
08:25:49 <Raito_Bezarius>         Actual type: m2 (Int -> Int -> Char -> Char -> Int) -> Int
08:26:54 <Raito_Bezarius> hmm
08:27:12 <Raito_Bezarius> I guess I can find the error
08:27:17 <Raito_Bezarius> I'll ping you if I don't find it
08:27:20 <arianvp2> oh yeh .:! seems what I am looking for
08:28:48 <Raito_Bezarius> Can we define anonymous function over multiple lines?
08:29:16 <boxscape> you mean with multiple equations or just one equation that stretches multiple lines?
08:30:20 <arianvp2> im still not sure if I fully understand
08:30:35 <arianvp2> so  .:! _fails_ on `Null` but how do I catch that?
08:30:59 <arianvp2> I would expect some type  data MaybeThere a =  Null | Nothing | Just a      for `.:!`
08:31:19 <arianvp2> can I use `<|>` in aeson?
08:31:28 <Raito_Bezarius> boxscape: https://paste2.org/y23I08U5
08:31:31 <Raito_Bezarius> like this
08:32:01 <boxscape> Raito_Bezarius you can do that but you have to indent the last line once more
08:32:26 <boxscape> Raito_Bezarius otherwise ghc will think you're trying to start a new action in the do block
08:34:00 <Raito_Bezarius> boxscape: hmm, even when I align it, it seems it not's the real cause
08:34:02 <Raito_Bezarius> Like for instance
08:34:11 <Raito_Bezarius> dist_prog_dyn_value :: Int → Int → Int → Char → Char → Int
08:34:19 <Raito_Bezarius> But when I do VM.read ll j I get a m2 Int
08:34:25 <Raito_Bezarius> which makes sense, but how can I "unbox" it?
08:34:58 <boxscape> do {a <- VM.read ll j; someFunction a}
08:35:46 <boxscape> you'll probably want to wrap `VM.move lc ll` in parentheses, though I'm not sure
08:36:09 <Phillemann> https://0bin.net/paste/F5FiQufDbIg0Ind4#2nxP9-y/NU+RCafc4ARkzFhhszyyTq0h4RQwfFGbzql - is this something that's (easily) rewritten without explicit recursion using, say, foldr/foldl?
08:36:31 <solonarv> arianvp2: I think so, but it would have been faster to just try to use it ;)
08:37:00 <Raito_Bezarius> boxscape: it works like this
08:37:01 <arianvp2> yeh ill try something out. I'm a bit worried as there is an issue with exactly my problem in `aeson` which has been opened for 4 years now :P  https://github.com/bos/aeson/issues/376
08:37:03 <Raito_Bezarius> indeed
08:37:26 <Raito_Bezarius> my issue is when I'm in a do statement
08:37:43 <Raito_Bezarius> do action1 X1 … Xp action2 Y1 … Yq
08:37:50 <Raito_Bezarius> how do Haskell knows I'm calling another function?
08:38:00 <Raito_Bezarius> and not passing action2 Y1 … Yq to action1 as a param?
08:38:13 <Raito_Bezarius> (it's trying to pass VM.move … to the rest of forM_)
08:38:35 <Raito_Bezarius> it seems like just adding some space is working
08:40:02 <boxscape> Raito_Bezarius the way you wrote it, you're calling one function action1 with a lot of arguments. If you have a newline between Xp and action2, you're calling two functions, more or less independently. If you want to pass the result of one to the other, you have to write result <- action1 X1 ... Xp <newline> action2 Y1 ... Yq result
08:40:08 <kuribas> I was thinking about the lens giant UML diagram of doom.  Wouldn't it be possible to explain it in simple terms?  Like lens = getter+setter for 1 value, traversal = getter+setter for zero of more values, etc...
08:40:29 <Raito_Bezarius> Alright
08:41:07 <boxscape> Raito_Bezarius but you might want to try to learn about the Monad functions >>= and `pure` and how to use them before you use do, since do notation is desugared into those
08:41:32 <solonarv> Raito_Bezarius: I usually like to format my forM_ / do blocks like this: https://gist.github.com/Solonarv/06a7ac58a0a80d33deb3f83e6d303f00
08:41:55 <Raito_Bezarius> Thanks solonarv !
08:41:59 <Raito_Bezarius> boxscape: I'll look into this
08:42:07 <lavalike> I copy glguy's style with the do on the next line even tho then the block is indented by 3 spaces to line up with "do " :D
08:42:09 <solonarv> it is definitely a good idea to learn about >>= / pure first, though; ideally with a less complex example program
08:42:09 * hackage hledger-lib 1.16.1 - Core data types, parsers and functionality for the hledger accounting tools  https://hackage.haskell.org/package/hledger-lib-1.16.1 (SimonMichael)
08:42:14 <Raito_Bezarius> Moreover, do VM.move a b copies b into a ?
08:42:19 <Raito_Bezarius> I don't understand well how this function works
08:42:49 <solonarv> I have no idea what the VM. functions are or even where they come from, so I can't help you there
08:43:03 <Raito_Bezarius> VM = Vector.Mutable
08:43:09 * hackage hledger-web 1.16.1, hledger-ui 1.16.1, hledger 1.16.1 (SimonMichael)
08:43:15 <solonarv> note that to format code the way I did, you need the BlockArguments extension
08:43:22 <Raito_Bezarius> :t Data.Vector.Mutable.move
08:43:24 <lambdabot> Control.Monad.Primitive.PrimMonad m => Data.Vector.Mutable.MVector (Control.Monad.Primitive.PrimState m) a -> Data.Vector.Mutable.MVector (Control.Monad.Primitive.PrimState m) a -> m ()
08:43:47 <Raito_Bezarius> I just don't understand the direction
08:44:01 <solonarv> otherwise you have to write: `forM_ [1..n] $ \i -> ...` or: `forM_ [1..n] (\i -> ...)`
08:44:47 <boxscape> Raito_Bezarius according to the docs, if the vectors don't overlap, move behaves like copy, and `copy a b` copies b's contents into a https://hackage.haskell.org/package/vector-0.12.0.3/docs/Data-Vector-Generic-Mutable.html#v:copy
08:45:00 <Raito_Bezarius> okay
08:45:15 <Raito_Bezarius> is there a way to debug-print Vector.Mutable array during a run of ST? or does it require to have a IO?
08:45:21 <kuribas> or `forM_ [1..,] do` with an extension
08:46:06 <solonarv> kuribas: the same extension, in fact; but I'd wager that most of the time you don't want to use the Monad ((->) _) instance there
08:46:19 <solonarv> especially not as a do block
08:46:30 <boxscape> Raito_Bezarius traceShow from Debug.Trace allows you to print debugging values without the IO monad
08:46:45 <kuribas> solonarv: right, I didn't see the backlog
08:47:56 * solonarv really likes BlockArguments
08:50:02 <Raito_Bezarius> is it normal that MutableVector do not implement Show?
08:52:47 <boxscape> MutableVector or MVector?
08:53:55 <Raito_Bezarius> Vector.Mutable
08:54:01 <Raito_Bezarius> (what's the difference?)
08:54:51 <boxscape> MVector is a class, Data.Vector.Mutable is a type
08:54:56 <phadej> the same reason why e.g. MVar or IOref doesn't have Show
08:55:03 <phadej> you cannot get the valu in the pure context
08:55:06 <phadej> to be shown
08:55:24 <Raito_Bezarius> So is there a way to debug print it?
08:55:44 <Raito_Bezarius> In ST context
08:55:49 <boxscape> you should still be able to read values from the vector in the ST monad and then print them using traceShow, without using the IO monad, I would think
08:56:41 <Raito_Bezarius> I imagine I could collect using read, but is there an elegant way to do it?
08:58:15 <boxscape> I'm not all that familiar with Data.Vector but I'm not seeing a better one I'm afraid
08:59:42 <phadej> freeze :: (Unbox a, PrimMonad m) => MVector (PrimState m) a -> m (Vector a)
08:59:46 <phadej> e.g.
09:00:05 <boxscape> ah, yeah that makes sense
09:00:09 <phadej> freeze mutableVec >>= traceShowM
09:00:36 <boxscape> ^ Raito_Bezarius
09:01:58 <Raito_Bezarius> oh nice
09:03:33 <Raito_Bezarius> phadej: in which module freeze is?
09:04:00 <phadej> go to https://hackage.haskell.org/package/vector; defocus search field, and press `s` key
09:05:25 <Raito_Bezarius> got a nasty Exception: Data.Vector.Mutable: uninitialised element during runtime
09:06:26 <phadej> don't use `new`, use `replicate` so it's initialized
09:07:23 <phadej> (hopefully you tried to do whatever yo try to do without ST first)
09:07:35 <Raito_Bezarius> Yes
09:08:17 <Raito_Bezarius> It seems like my Vector.Mutable.write have no effect during the monadic action
09:08:25 <phadej> I doubt that
09:08:25 <Raito_Bezarius> so when I traceShowM I just get the initial value repeated
09:09:03 <Raito_Bezarius> Okay I see changes
09:09:06 <Raito_Bezarius> It must be my algorithm
09:09:29 <Raito_Bezarius> do you know how can I preprend a string when I do "freeze tab >>= traceShowM" ?
09:09:38 <Raito_Bezarius> ("something:", freeze tab) >>= traceShowM ?
09:09:39 <phadej> it's more probable that bug is in your code, then in `vector` or `compiler`
09:09:46 <Raito_Bezarius> Yes it must be my code
09:09:54 <phadej> look what's in the https://hackage.haskell.org/package/base-4.12.0.0/docs/Debug-Trace.html
09:10:17 <phadej> (hint: no, you have to do it yourself)
09:10:27 <Raito_Bezarius> hmm
09:10:43 <phadej> but there's last hing, freeze >>= traceShowM . ("tag",)
09:10:56 <phadej> from now on, you have to solve your problems yourself :)
09:11:09 <phadej> s/hing/hint or trick/
09:12:08 <Raito_Bezarius> phadej: hahaha thank you :)
09:12:10 <Raito_Bezarius> very much
09:15:52 <Raito_Bezarius> it works fine ™
09:24:12 <kw> @let after f g = seq f (seq g (\x -> f (g x)))
09:24:13 <lambdabot>  Defined.
09:24:33 <kw> @type after
09:24:35 <lambdabot> (t1 -> t2) -> (t3 -> t1) -> t3 -> t2
09:25:07 <kw> > seq (after undefined id) ()
09:25:09 <lambdabot>  *Exception: Prelude.undefined
09:25:25 <kw> > seq (after id undefined) ()
09:25:26 <phadej> seq for fucntiosn does nothing
09:25:32 <lambdabot>  mueval-core: Time limit exceeded
09:25:44 <phadej> or "little"
09:26:11 <kw> hmm...
09:26:11 <phadej> f `seq` g `seq` \x -> f (g (x)) -- did you meant to write <-
09:26:38 <phadej> @let after f g =  `seq` g `seq` \x -> f (g (x)) -- did you meant to write <-
09:26:39 <lambdabot>  Parse failed: Parse error: `
09:26:45 <phadej> @let after f g = f `seq` g `seq` \x -> f (g (x)) 
09:26:48 <lambdabot>  .L.hs:159:1: error: [-Woverlapping-patterns, -Werror=overlapping-patterns]
09:26:48 <lambdabot>      Pattern match is redundant
09:26:48 <lambdabot>      In an equation for ‘after’: after f g = ...
09:27:13 <phadej> @let after2 f g = f `seq` g `seq` (f . g)
09:27:16 <lambdabot>  Defined.
09:27:32 <phadej> > seq (after id undefined) ()
09:27:34 <lambdabot>  *Exception: Prelude.undefined
09:28:01 <kw> > seq (after2 undefined id) ()
09:28:03 <lambdabot>  *Exception: Prelude.undefined
09:28:15 <kw> Cool, thanks, phadej.
09:29:30 <kw> Just wanted to see if strict composition could distinguish `\ x -> undefined` from `undefined`.
10:49:14 <dmwit> > seq (after id undefined) ()
10:49:16 <lambdabot>  *Exception: Prelude.undefined
10:49:35 <dmwit> phadej: What's the difference between yours and kw's?
10:49:58 <phadej> :i seq
10:50:12 <phadej> % :i seq
10:50:12 <yahb> phadej: seq :: a -> b -> b -- Defined in `GHC.Prim'; infixr 0 `seq`
10:50:20 <phadej> infixr...
10:50:36 <dmwit> so?
10:50:37 <phadej> well, I don't know. Mine owkrs :P
10:50:41 <dmwit> So does kw's.
10:50:57 <dmwit> (Up to lambdabot timing out randomly these days.)
10:51:49 <phadej>  @let after f g = seq f (seq g (\x -> f (g x)))
10:52:00 <phadej> @let after f g = seq f (seq g (\x -> f (g x)))
10:52:01 <lambdabot>  .L.hs:159:1: error: [-Woverlapping-patterns, -Werror=overlapping-patterns]
10:52:01 <lambdabot>      Pattern match is redundant
10:52:01 <lambdabot>      In an equation for ‘after’: after f g = ...
10:52:11 <dmwit> It's already in there, with that definition.
10:52:20 <phadej> > seq (after id undefined) ()
10:52:22 <lambdabot>  *Exception: Prelude.undefined
10:52:37 <phadej> ok, so that time limit exceeded was some transient failure
10:52:41 <dmwit> yep
10:52:45 <phadej> unfortunate
10:55:39 * hackage cabal-install-parsers 0.2 - Utilities to work with cabal-install files  https://hackage.haskell.org/package/cabal-install-parsers-0.2 (phadej)
11:11:50 <Raito_Bezarius> Sorry I come back, I fixed most of my problems
11:11:52 <Raito_Bezarius> I have a curiosity
11:12:03 <Raito_Bezarius> I have a read_instance :: FilePath → IO X
11:12:21 <Raito_Bezarius> and I want to create a function load_all_instances :: [FilePath] → IO [(FilePath, X)]
11:12:26 <Raito_Bezarius> So what I tried is something like
11:12:37 <Raito_Bezarius> load_all_instances = sequence . map (\x -> (x, read_instance x))
11:12:40 <Raito_Bezarius> Obviously, it won't work
11:12:52 <Raito_Bezarius> Because (x, read_instance x) is of type (FilePath, IO X)
11:13:05 <Raito_Bezarius> So I tried to use a zip-like approach
11:13:14 <Raito_Bezarius> but the problem is that how can I box FilePath into IO FilePath ?
11:13:43 <Raito_Bezarius> Ideally, I would like to unbox/lift the IO of X but I'm unsure on how to do it
11:13:59 <Raito_Bezarius> Is it better to unbox IO X into X and zip it, or is it better to box FilePath into IO FilePath?
11:14:01 <dsal> Raito_Bezarius: first make the thing that does one, then use traverse
11:14:13 <Raito_Bezarius> that does one ?
11:14:15 <ephemient> load_instance :: FilePath -> IO (FilePath, X)
11:14:16 <Raito_Bezarius> sequence . map read_instance ?
11:14:19 <Raito_Bezarius> Oh OK
11:14:21 <ephemient> try that first
11:14:22 <Raito_Bezarius> Yeah, makes sense
11:14:51 <Raito_Bezarius> In this case, sequence . map load_instance will work
11:14:58 <dsal> :: FilePath -> IO (FilePath, X)
11:15:13 <dsal> sequence.map == traverse
11:15:20 <Raito_Bezarius> Ohhh
11:15:21 <Raito_Bezarius> Nice :D
11:15:31 <Raito_Bezarius> Okay
11:16:03 <Raito_Bezarius> guess I can do
11:16:17 <Raito_Bezarius> load_instance fname = do inst <- read_instance fname; return (fname, inst)
11:16:23 <Raito_Bezarius> and it works!
11:16:48 <ephemient> does hlint pick `sequence . map == traverse` or does it pick `mapM`
11:16:53 <dsal> both f = (f,) <$> readOne
11:17:41 <dsal> Er, I left out an f
11:17:51 <dsal> both f = (f,) <$> readOne f
11:18:05 <ephemient> {-# LANGUAGE TupleSections #-}
11:18:26 <dsal> Yeah. Complier is nice about telling you how to do what you want to do. :)
11:18:55 <infinity0> suppose you have a type t with a finite number of elements like Bool = {True, False}, how would I express a constraint over all members of the type, like (forall v :: t . c v ) ?
11:19:05 <infinity0> and is ghc actually able to check this forall v :: t
11:20:02 <solonarv> well, you *can* just write that constraint
11:20:14 <solonarv> e.g. 'forall b :: Bool. Foo b'
11:20:27 <solonarv> but I don't think that will actually get solved, unless there is a catchall instance
11:22:21 <infinity0> hm ok i guess the alternative is to write some constraint like (Elem v t) and pass t around as a data-structure-kinded type..
11:30:00 <ephemient> so, on a different note... https://github.com/ephemient/aoc2019/blob/95090bab9978fe77add7235dbdc6b51dbcf64218/src/Day3.hs#L50
11:30:07 <ephemient> `go x = getMin $ runST $ execWriterT $ intersections f $ map (, ()) <$> x`
11:30:24 <ephemient> if I replace the $ with . it doesn't typecheck
11:30:50 <ephemient> can't pointfree-ify :(
11:31:12 <merijn> ephemient: That's because of runST
11:31:28 <merijn> ephemient: It has a Rank2 type which can't be inferre by GHC
11:31:29 <dmwit> ?let read_instance :: FilePath -> IO Bool; read_instance = readFile >>= readIO
11:31:32 <lambdabot>  .L.hs:160:17: error:
11:31:32 <lambdabot>      • Couldn't match expected type ‘IO String’
11:31:32 <lambdabot>                    with actual type ‘FilePath -> IO String’
11:31:37 <dmwit> ?let read_instance :: FilePath -> IO Bool; read_instance = readFile >=> readIO
11:31:39 <lambdabot>  Defined.
11:31:58 <merijn> ephemient: There's a builtin hack in the typechecker that recognises $ and makes it work with ST, because it actually shouldn't
11:32:07 <dmwit> :t traverse (\fp -> sequence (fp, read_instance fp))
11:32:09 <lambdabot> Traversable t => t [Char] -> IO (t ([Char], Bool))
11:32:16 <dmwit> Raito_Bezarius: ^
11:32:30 <ephemient> ah, I was wondering about that.
11:32:34 <dmwit> or:
11:32:43 <dmwit> :t traverse (\fp -> (,) fp <$> read_instance fp)
11:32:45 <lambdabot> Traversable t => t [Char] -> IO (t ([Char], Bool))
11:32:58 <dmwit> :t traverse (liftA2 (<$>) (,) read_instance) -- not recommended
11:33:00 <lambdabot> Traversable t => t FilePath -> IO (t (FilePath, Bool))
11:33:16 <merijn> ephemient: That seems like an overkill amount of extenions for this solution xD
11:33:51 <Raito_Bezarius> :D
11:33:54 <Raito_Bezarius> dmwit: awesome!
11:34:08 <Raito_Bezarius> Now I have a question regarding performance
11:34:16 <ephemient> it's not even *good* overkill, it still runs inexplicably slow
11:34:20 <Raito_Bezarius> When you do (drop x y) where x :: Int and y :: String
11:34:26 <ephemient> nothing jumps out at me in the profile though
11:34:28 <Raito_Bezarius> Do Haskell performs a copy?
11:34:40 <dmwit> Haskell doesn't say. GHC does not create a copy.
11:34:48 <ephemient> Raito_Bezarius: type String = [Char]
11:35:04 <Raito_Bezarius> So basically it's just playing with pointers internally?
11:35:15 <dmwit> More or less.
11:35:17 <ephemient> [a] is composed of cons cells, e.g.
11:35:26 <merijn> ephemient: I can show you my version, which is rather snappy
11:35:31 <ephemient> "str" == 's' : 't' : 'r' : []
11:35:53 <Raito_Bezarius> I see
11:36:02 <ephemient> so `drop` can just return the tail structure
11:36:11 <Raito_Bezarius> so I already have this nice optimization, GHC is awesome
11:36:35 <dsal> String and "nice optimization" aren't usually used together.  heh
11:36:55 <Raito_Bezarius> :'D
11:37:20 <merijn> ephemient: https://github.com/merijn/AdventOfCode2019/blob/master/Day3.hs
11:37:44 <glguy> I liked using a Map over an array https://github.com/glguy/advent2019/blob/master/execs/Day03.hs
11:37:53 <merijn> glguy: So did I
11:38:19 <merijn> glguy: I was gonna do a fancy quadtree, but I'm lagging on the company leaderboard so I just did the simple thing so I can knock it off the list
11:38:26 <Raito_Bezarius> I have this code: https://paste2.org/IdZDOEKO which is a bit slow (don't know if I can improve it), (ADNInstance = (String, String) and c_del, c_ins are constants, c_sub is a constant time function (just a mapping)
11:38:37 <Raito_Bezarius> Do you think I'm doing something wrong in terms of Haskell-style?
11:39:06 <glguy> Raito_Bezarius: stick with pastebins that don't throw ads on them
11:39:17 <Raito_Bezarius> glguy: Sure
11:39:22 <ephemient> I did have a temporary step using an STArray but it ran out of memory during my benchnark
11:39:38 <Raito_Bezarius> http://ix.io/23tk
11:39:53 <Raito_Bezarius> "" got swallowed by bash
11:40:07 <Raito_Bezarius> but anyway line 2, it is aux ("", "")
11:40:56 <dsal> glguy: Huh.  I wonder why I made a type to represent the direction instead of using a character.  I guess mine would fail a little earlier, but I had a whole extra line just to map those in.
11:41:00 <dsal> (also, thanks for the free online course)
11:41:13 <merijn> dsal: Better error reporting!
11:41:13 <dmwit> Raito_Bezarius: I expect you're going to have a much better time if i and j count up from 0, and you iterate through x and y rather than using (!!).
11:41:26 <glguy> dsal: I think having the type for directions is a good choice
11:41:34 <dmwit> Raito_Bezarius: You can call reverse once (or twice) at the end to fix things up if the result comes backwards from how you want it.
11:41:35 <glguy> I skipped it for getting my code working faster
11:41:45 <glguy> but I certainly would not discourage doing it
11:41:59 <dsal> Yeah, it makes sense.  I just like the mind expansion from reading other people's code.
11:42:30 <merijn> I'm trying to keep my versions clean so my girlfriend can study my implementations and maybe use them as neat examples to show off Haskell, so I'm trying to avoid any shortcuts/unsafe things
11:42:53 <Raito_Bezarius> dmwit: alright, makes sense
11:43:16 <dsal> merijn: I used a thing with unsafe in the name!
11:43:40 <Raito_Bezarius> dmwit: what do you mean by iterating through x and y?
11:43:43 <dsal> That's a good point, though.  I wanted to learn ST for the computer thing, but it's my third implementation, and then a lot of revisions on that.
11:43:46 <Raito_Bezarius> ah t : x
11:43:48 <ephemient> wait why does `foldl1' (Map.intersectionWith (+))` work
11:43:49 <Raito_Bezarius> yes
11:43:55 <merijn> dsal: I did too, but I remove them later
11:43:56 <dmwit> Raito_Bezarius: Aside: What happens if c_ins == c_del? Or c_ins == c_sub 'a' 'b'?
11:44:02 <amalloy> ephemient: why wouldn't it?
11:44:08 <ephemient> do all the intersections line up?
11:44:09 <Raito_Bezarius> dmwit: nothing?
11:44:09 <glguy> dsal: I've fixed my solutoin
11:44:13 <dmwit> Raito_Bezarius: (Yes, that's what I meant by "iterating through x and y".)
11:44:25 <merijn> ephemient: What does "line up" mean?
11:44:33 <dsal> Oh hey, I had that same thing in mine:   overlaps = Map.keys . foldl1 Map.intersection
11:44:35 <Raito_Bezarius> dmwit: I mean, when it happens, we can provely obtain the same solutions
11:44:38 <Raito_Bezarius> So it does not really matter
11:44:53 <dsal> Mine didn't have a ' though
11:44:53 <ephemient> foldl1 intersection [[1, 2], [1, 3], [2, 3]]
11:44:59 <ephemient> would be [] wouldn't it?
11:45:00 <Raito_Bezarius> (this is the algorithm I'm trying to implement: https://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm)
11:45:02 <merijn> dsal: I wrote a custom Ord so I could solve the first one by just taking the lowest key/value
11:45:14 <glguy> ephemient: Yes it would, in that case no entries were common to all the paths
11:45:23 <dsal> merijn: Oh nice.  
11:45:27 <ephemient> did I misunderstand the problem then
11:45:39 <glguy> ephemient: There were only two paths in the input file
11:45:46 <ephemient> oh.
11:45:52 <amalloy> am i the only one who turned the coordinates into (Sum Int, Sum Int) so that i could use scanl (<>) mempty to find all the places visited?
11:46:00 <ephemient> that.... would be part of why mine is so over-engineered
11:46:07 <ephemient> that cuts down on the requirements a ton...
11:47:16 <dmwit> Raito_Bezarius: Glad you've thought about that problem. =)
11:49:50 <glguy> amalloy: I used a scanl to generate the list, but not via a semigroup instance
11:50:07 <dmwit> Raito_Bezarius: In case it's not easy to count up from (0,0) instead of down from (length x, length y), you could alternately continue to count down, but iterate along reverse x and reverse y.
11:50:40 <dmwit> Raito_Bezarius: Anyway, the point is that (!!) is O(n), so calling it O(n) times makes this costlier than it needs to be.
11:50:54 <Raito_Bezarius> ah !
11:50:57 <Raito_Bezarius> that explains a lot of thing
11:52:15 <glguy> amalloy: I like the idea of partial sums of a list of vectors like that, but I would prefer to see it not be done via semigroup instances
11:52:31 <glguy> scanl addPair start vectors
11:52:43 <solonarv> dsal: I defined an entire AST for the input (though a simple one) and threw a Megaparsec parser at it
11:52:47 <solonarv> merijn: oh, I did that too!
11:53:13 <dsal> ephemient: I didn't assume only two lines.
11:53:28 <solonarv> I parsed to a NonEmpty of lines
11:53:44 * hackage hlrdb-core 0.1.5.0 - High-level Redis Database Core API  https://hackage.haskell.org/package/hlrdb-core-0.1.5.0 (identicalsnowflake)
11:54:05 <solonarv> which is actually smoother than a tuple, since you can use fmap and fold to combine them
11:55:04 <merijn> I just build sets (later maps) of path nodes immediately
11:56:14 <merijn> ephemient: You also have Writer which is generally rather slow/thunk-build-up-y
12:06:32 <solonarv> my solution is here: https://github.com/Solonarv/adventofcode-2019/blob/master/haskell/day03/Day03.hs
12:07:20 <solonarv> I actually build a list of path nodes (since there would be an intermediate list anyway, whether it ends up being converted to a map or a set) and pass it to Map.fromList or (Set.fromList . map fst)
12:25:54 <Nikos12> Hello all. I'm new to Haskell and I was told I would find extremely nice and patient people here :)
12:26:42 <Nikos12> It's my first time here so I'm not sure how this goes. It certainly looks like I'm the only noob here.
12:26:52 * dmwit waves
12:27:24 <Nikos12> Hi!
12:27:30 <dmwit> The way it typically goes is you come up with a problem that's preventing you from making progress, minimize it to a couple lines of code, put your code on a pastebin, and send us a link.
12:27:33 <dsal> Nikos12: state your demands!
12:27:54 <dmwit> Then we tell you way more advanced techniques for solving it than you can handle, until some generous soul takes pity and tells you the easy, simple way. ;-)
12:28:43 <Nikos12> I haven't got any code problems yet. (thankfully :)). I'm going through the Learn You a Haskell Tutorial. I'm still at the beginning and I have three questions.
12:28:44 * hackage nerf 0.5.4 - Nerf, a named entity recognition tool based on linear-chain CRFs  https://hackage.haskell.org/package/nerf-0.5.4 (JakubWaszczuk)
12:30:34 <Nikos12> 1. Can somebody explain simply what we mean by Haskell is lazy? I mean I've got functions on the screen and if they need to be used they're used. Isn't that the same with all languages?
12:32:19 <dsal> Nikos12: in many languages, expressions are evaluated before they're passed to functions.
12:32:40 <dsal> In Haskell, things are evaluated as needed.
12:33:20 <dsal> So you can do things like build an infinitely long list and pass it to another function.
12:34:07 <dsal> > sum (take 10 [1..])
12:34:10 <lambdabot>  55
12:34:56 <nil> > (const "hi") (error "this would cause an error if evaluated")
12:34:58 <lambdabot>  "hi"
12:35:09 <Nikos12> Sorry it's not clicking I'm afraid. 
12:35:19 <dsal> It will. :)
12:35:26 <dsal> :t cycle
12:35:29 <Nikos12> Are things evaluated in other languages without a reason?
12:35:30 <lambdabot> [a] -> [a]
12:36:02 <solonarv> Nikos12: yes!
12:36:17 <solonarv> they are indeed evaluated even if they might not be needed
12:36:19 <nil> things are often evaluated for their side-effects, in imperative languages. but evaluation in Haskell has no side-effects
12:36:39 <solonarv> are you perhaps familiar with any other languages which we might use to make comparisons?
12:36:53 <Nikos12> Right OK. What's an example of a piece of code that may have side effects in imperative languages?
12:37:11 <solonarv> (python): print("hello world")
12:37:27 <Nikos12> Yeh. Used C#, Java, VB.net 
12:37:31 <Nikos12> or Python :)
12:37:44 * hackage nerf 0.5.4.1 - Nerf, a named entity recognition tool based on linear-chain CRFs  https://hackage.haskell.org/package/nerf-0.5.4.1 (JakubWaszczuk)
12:37:47 <Nikos12> OK so what does that print do that is unnecessary?
12:38:15 <solonarv> oh no, it's quite necessary to the function of the program
12:38:35 <solonarv> you asked for a piece of code that has side effects, and I gave an example of that
12:38:48 <Nikos12> You did indeed. Can you explain it though?
12:39:26 <solonarv> if you evaluate this, you get None - a dumym value that contains no information
12:39:43 <solonarv> but in the process of evaluating it, something has been output to the user's screen
12:39:47 <solonarv> that's a side effect
12:40:03 <monochrom> I hate side effects.  Either you have an intended effect or you have a bug.
12:41:06 <Nikos12> What's the dummy value exactly? When I run that code I get hello world. Wasn't I supposed to?
12:41:49 <dsal> Nikos12: for a lot of code, you want notice the difference.
12:42:01 <solonarv> try running: foo = print("hello world"), so you can see what is the side effect and what is the value
12:42:20 <djanatyn> I have a monad transformer stack and I notice I'm always returning (m (Maybe a)), so I was thinking of adding MaybeT. I know that as I add more monad transfomers to my stack, I need to look into performance considerations. Are there other things I should consider before adding MaybeT (from transformers in this case)? like maybe, I should default to ExceptT?
12:42:43 <Nikos12> Still getting hello world
12:42:52 <Nikos12> Can I suggest something?
12:42:57 <solonarv> sure
12:43:39 <Nikos12> Let's leave the code examples I probably shouldn't have asked for them. I've read that Haskell is lazy which means that Haskell evaluates when needed. 
12:44:20 <solonarv> yeah, I was going to say it seems like we're running down unproductive tangents
12:44:42 <Nikos12> Can I say for example, a do while loop of an imperative language, evaluates everything without needing to?
12:44:56 <dsal> :t repeat
12:44:57 <lambdabot> a -> [a]
12:45:10 <dsal> > repeat "hi"
12:45:13 <lambdabot>  ["hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi","hi",...
12:45:20 <solonarv> hmm, you can say that but I don't think it's really accurate
12:45:36 <solonarv> let's try a direct comparison
12:45:42 <dsal> > (print . head . repeat) "hi"
12:45:42 <Nikos12> Sure
12:45:45 <lambdabot>  <IO ()>
12:45:56 <dsal> Heh.  Damn
12:46:07 <monochrom> yahb can do that.
12:46:23 <iqubic> @src (.:)
12:46:23 <lambdabot> Source not found. Take a stress pill and think things over.
12:46:30 <iqubic> Where is that function found?
12:46:39 <nil> @hoogle (.:)
12:46:40 <lambdabot> Data.Aeson (.:) :: FromJSON a => Object -> Text -> Parser a
12:46:40 <lambdabot> Data.Aeson.Types (.:) :: FromJSON a => Object -> Text -> Parser a
12:46:40 <lambdabot> Data.Yaml (.:) :: FromJSON a => Object -> Text -> Parser a
12:46:40 <solonarv> (java) int quadrillionthPlusNDigitOfPi(int n) { /* math here */ } ; (haskell) quadrillionthPlusNDigitOfPi n = -- math here
12:46:55 <solonarv> let's consider these example functions
12:46:56 <nil> (ask the real hoogle for more)
12:48:40 <solonarv> (java) int mightIgnoreSecondArg(int x, int y) { return x > 0 ? x * 2 : y - x }; (haskell) mightIgnoreSecondArg x y = if x > 0 then x * 2 else y - x
12:48:41 <Nikos12> OK. So is part of the comparison here that Haskell uses equality and Java jumps into a body of code without that code necessarily doing anything?
12:48:53 <solonarv> no, I just wasn't done typing yet :P
12:49:11 <solonarv> do you agree that these haskell/java definitions will compute the same thing?
12:49:14 <Nikos12> Gotcha
12:49:38 <iqubic> instance Monoid a => Monad ((,) a) where
12:49:47 <iqubic> What does that do, and is it useful?
12:50:07 <Nikos12> Java may ignore y yes but won't Haskell if the if evaluates to true?
12:50:20 <solonarv> yup!
12:50:25 <Nikos12> You may never hit the else 
12:50:28 <nil> iqubic: that line alone doesn't do a lot, but you might wanna look at the definitions in that instance.
12:50:30 <dsal> iqubic: gives you monoid for tuples of monoid snd
12:50:55 <iqubic> dsal: The rhs says MONAD
12:50:57 <solonarv> and you can see how this might be useful if 'y' is something expensive to calculate, like quadrillionthPlusNDigitOfPi(42)
12:51:26 <iqubic> Nikos12:
12:51:37 <iqubic> Haskell will only evaluate y if needed.
12:51:53 <iqubic> Java will always evaluate y, even if unneed.
12:52:02 <iqubic> *unneeded.
12:52:18 <nil> iqubic: note that this instance is identical (up to newtype wrappers) to the Writer monad
12:52:30 <iqubic> Oh. Right. It is.
12:53:15 <Nikos12> Got it ok. 
12:53:24 <Nikos12> Can I go to my next question?
12:53:28 <dsal> solonarv: oh, sorry. On the phone
12:53:57 <solonarv> Nikos12: sur4, go ahead!
12:54:35 <Nikos12> I'm using WinGHCi. I've declared a list in the code window. 
12:54:53 <iqubic> How?
12:55:01 <Nikos12> like this
12:55:02 <Nikos12> let myList = [1,2,3,4,5]
12:55:08 * solonarv nods
12:55:09 <iqubic> Looks good.
12:55:11 <Nikos12> I then say myList
12:55:16 <Nikos12> and my list appears!
12:55:26 <iqubic> That is how a REPL works.
12:55:38 <Nikos12> But, when I click CTRL-s and clear my screen and write myList again
12:55:42 <Nikos12> my list appears!
12:55:57 <solonarv> I have never used winghci, but
12:56:00 <Nikos12> So, how does this happen if I've cleared my screen? Where is that list stored?
12:56:09 <nil> o_ô
12:56:11 <dmj`> the ghost of List-mas past
12:56:22 <Nikos12> Nice one that!
12:56:23 <solonarv> it looks like ctrl-S only clears *the screen*, and doesn't reset the interpreter
12:56:47 <dmj`> Nikos12: thanks
12:56:53 <iqubic> I just learned that scanl and co only work for lists. Not any generic foldable.
12:56:58 <Nikos12> Yes possibly. So where was my list stored and how can I clear that memory?
12:57:21 <iqubic> why do you want to clear the memory?
12:57:34 <Nikos12> I don't. I'm not sure if I should though.
12:57:40 <dmj`> it might be your buffering mode
12:57:45 <dmj`> you gotta the flush the buffer
12:57:56 <solonarv> nothing to do with buffering
12:57:56 <Nikos12> If I don't have to, I can leave it.
12:58:03 <Nikos12> I'm not bothered.
12:58:12 <dmj`> solonarv: ok
12:58:26 <Nikos12> Cool. Last question?? :)
12:58:30 <solonarv> you don't really need to get rid of it, unless yuo have some huge data structure that is eating all your RAM
12:58:43 <Nikos12> In which case I flush the buffer right?
12:58:57 <solonarv> and then you can just restart the interpreter (close winghci and reopen it?), which will reset it
12:59:05 <Nikos12> Cool thanks.
12:59:13 <solonarv> no, buffers are just a technical detail of how text input/output works
12:59:13 <Nikos12> OK. Got a last question.
12:59:27 <solonarv> go ahead, if this one is answered to your satisfaction
12:59:35 <Nikos12> Yes it is thanks.
12:59:44 <Nikos12> Right, the debugger....
12:59:58 <Nikos12> I've searched and Googled. How the hell can I use the damn thing?
13:00:09 <Nikos12> I just want to step through my code see what Haskells doing.
13:00:33 <Nikos12> I heard about installing modules, loading modules but no information was clear enough.
13:00:50 <solonarv> hm, I must say I can't help you much with the debugger since I have never really used it
13:01:00 <Nikos12> I can't even find a button that says debug
13:01:52 <Nikos12> Basically, I want to use it because I want to see how the code is run. Yesterday I wrote out a recursive function that calculates factorials (first time ever somebody did that hey!) )
13:02:12 <solonarv> if you type ':help' (without the quotes) into ghci you will get a list of available commands, including those for debugging
13:02:12 <Nikos12> And I wanted to see how it reads it
13:02:22 <Nikos12> A. Nice.
13:04:53 <dmwit> Nikos12: https://downloads.haskell.org/ghc/latest/docs/html/users_guide/ghci.html#the-ghci-debugger
13:05:07 <solonarv> damnit! you were 30 seconds faster than me ;)
13:05:32 <dmwit> git gud
13:05:33 <dmwit> ;-)
13:06:01 * solonarv git: 'gud' is not a git command. See 'git --help'.
13:06:54 <Nikos12> Thanks
13:07:03 <dmwit> I'll be honest, though: I think you're making a mistake.
13:07:18 <dmwit> I've got a pretty good handle on how Haskell evaluation works, and even so the debugger regularly confuses the heck out of me.
13:07:45 <dsal> > let myList = [1,2,3,4,5] in myList -- Nikos12 
13:07:48 <lambdabot>  [1,2,3,4,5]
13:07:59 <dsal> Oh man, my client just caught up   *sigh*
13:12:42 <dmwit> > 2^16 `div` 5
13:12:44 <lambdabot>  13107
13:13:03 <dmwit> > map (\x -> x*13107 `mod` 2^16) [0..31]
13:13:05 <lambdabot>  [0,13107,26214,39321,52428,65535,13106,26213,39320,52427,65534,13105,26212,3...
13:14:03 <dsal> > unfoldr (\x -> Just $ (product [1..x], x+1)) 1  -- a list of all the factorials so you never have to calculate them again!
13:14:07 <lambdabot>  [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87...
13:14:22 <dmwit> > scanl (*) [1..]
13:14:26 <dsal> damn
13:14:26 <lambdabot>  error:
13:14:26 <lambdabot>      • No instance for (Num [Integer]) arising from a use of ‘e_11’
13:14:26 <lambdabot>      • In the expression: e_11
13:14:31 <dmwit> > scanl (*) 1 [1..]
13:14:35 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
13:14:42 <dsal> > scanl1 (*) [1..]
13:14:44 <lambdabot>  [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87...
13:15:57 <dsal> > let allFactorials = scanl1 (*) [1..] in    sum (takeWhile (< 100000) allFactorials)  -- Going back to Nikos12's question about laziness.
13:16:00 <lambdabot>  46233
13:16:50 <dmwit> juri_: Does your embedded system have 32-bit multiplication?
13:17:03 <dmwit> juri_: Because if so...
13:17:14 <dmwit> > map (\x -> shiftR (x*13107) 16) [0..31]
13:17:17 <lambdabot>  [0,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4,5,5,5,5,5,6]
13:18:46 <dmwit> Even if it has only 16-bit multiplication, that's good enough for the first 256 entries or so:
13:18:54 <dmwit> > map (\x -> shiftR (x*51) 8) [0..31]
13:18:57 <lambdabot>  [0,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4,5,5,5,5,5,6]
13:20:17 <dmwit> (I am mildly ashamed this didn't occur to me whenever we were first discussing this.)
13:26:31 <Nikos12> dmwit yes I see that the debugger is quite confusing actually.
13:28:21 <Nikos12> Thanks people for all your help.
13:30:10 <dmwit> ?check \x_ -> let x = x_ .&. 0xff :: Word16; xdiv5 = shiftR (x*51) 8 in xdiv5 `elem` [x`div`5, x`div`5-1]
13:30:12 <lambdabot>  +++ OK, passed 100 tests.
13:34:14 * hackage mmsyn6ukr 0.3.4.0 - A musical instrument synthesizer or a tool for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.3.4.0 (OleksandrZhabenko)
13:44:52 <Raito_Bezarius> is there an easy way to have an Array Char from a String?
13:44:57 <Raito_Bezarius> I'm looking at the doc but I don't find one
13:45:31 <nil> same way you get an Array a from an [a]
13:46:33 <nil> :t listArray
13:46:35 <lambdabot> Ix i => (i, i) -> [e] -> Array i e
13:46:36 <Raito_Bezarius> thanks
13:46:43 <Raito_Bezarius> I was not sure listArray was the thing I was looking for
13:49:04 <gentauro_> I'm looking into implementing a Monad (Functor + Applicative as well) for a newtype -> https://pastebin.com/mU4DQKE7
13:49:40 <gentauro_> I provide my assumption on how to do it as comments, but I'm not really sure it's that "simple" ..
13:50:15 <gentauro_> (the only one I don't seem to know how to do it it is `pure` in the Applicative type-class)
13:50:59 <Cale> gentauro_: pure x = Foo (pure x)
13:53:16 <nil> gentauro_: defining `fmap f m` as `fmap f m` isn't gonna go well.
13:53:27 <Lears> gentauro_: you want Functor, Applicative etc constraints on `m` in your instances, then you use them to do all the work.
13:53:28 <nil> same for (<*>) and (>>=)
13:54:06 <EvanR> fmap f m undeniably = fmap f m
13:55:06 * nil . o O ( https://ro-che.info/ccc/18 )
13:55:11 <gentauro_> Cale: `No instance for (Applicative m) arising from a use of ‘pure’`
13:55:14 <gentauro_> hmmmm
13:55:40 <nil> see Lears's comment
13:55:41 <gentauro_> I'm trying to do it without any language extensions :)
13:55:47 <Cale> Well, yeah, you'll have to put that inside an instance like  instance Applicative m => Applicative (Foo m) where
13:56:16 <gentauro_> Cale: oh, my bad
13:57:16 <gentauro_> forgot about the context of `m`
13:57:18 <gentauro_> gosh
14:00:49 <gentauro_> gosh
14:19:49 <gentauro_> OK, now it give sense :) -> https://pastebin.com/E8RVv9Xn
14:21:45 <nil> congrats on redefining IdentityT :)
14:22:53 <yingw787> :info Eq
14:22:58 <yingw787> :i Eq
14:23:11 <gentauro_> nil: me?
14:23:57 <yingw787> > take 5 [1..]
14:24:00 <lambdabot>  [1,2,3,4,5]
14:24:02 <nil> gentauro_: yes
14:24:20 <gentauro_> :D
14:24:25 <gentauro_> could you elaborate?
14:24:34 <EvanR> can't IdentityT instances be generalized newtype derived
14:24:58 <amalloy> glguy: sorry, i stepped away shortly after asking about (Sum Int, Sum Int). i'm glad you agree scanl is the way to generate partial sums, but what don't you like about doing it with semigroup?
14:25:14 <glguy> I think it's unnecessarily indirect
14:25:15 <nil> gentauro_: well, your Foo (resp. foo) is identical to IdentityT (resp. runIdentityT) from the transformers package
14:26:02 <glguy> amalloy: I consider it better to be explicit about the function you want than to add layers of newtypes to happen to get the right function by writing (<>)
14:26:27 <gentauro_> nil: https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Identity.html#t:IdentityT
14:26:30 <gentauro_> :o
14:26:34 <gentauro_> you are absolutely correct
14:27:06 <EvanR> yeah if you see semigroup code doing something non-polymorphic, now you need to figure out what semigroup it is
14:27:30 <gentauro_> nil: if it was part of `base` I would use it
14:27:47 <nil> why do you need such a type?
14:27:59 <gentauro_> just trying stuff out :D
14:28:10 <glguy> amalloy: https://github.com/glguy/advent2019/blob/master/execs/Day03.hs#L125-L126 I think this is better than a version that wraps/unwraps newtype wrappers and uses (<>)
14:28:35 <nil> transformers is part of the GHC libraries, fwiw
14:32:25 <merijn> gentauro_: Why would it have to be part of base?
14:32:57 <gentauro_> merijn: I try to limit the amount of used packages to a minimum so I don't mimic the `npm style`
14:33:25 * EvanR shits uncomfortably in their chair
14:33:26 <gentauro_> `npm style = if it isn't in somebody elses package, the code isn't good enough`
14:33:28 <EvanR> er shifts
14:34:55 <EvanR> it's crazy how different languages have different ways of living with their libraries
14:35:44 <merijn> gentauro_: transformers is part of GHC so it's installed anyway
14:36:17 <merijn> gentauro_: Also, it's literally impossible to write any non-trivial Haskell program without ending up with transformers in your dependencies
14:36:25 <gentauro_> EvanR: in Haskell `npm style` is actually using extensions -> https://twitter.com/edwinbrady/status/1163816732902883329
14:36:28 <gentauro_> xD
14:36:55 <gentauro_> merijn: I understand that
14:37:03 <gentauro_> but I want to write some Haskell code on my own
14:37:22 <gentauro_> if that means that it maps to something well defined
14:37:38 <gentauro_> well then I learned something by doing instead of just using
14:37:39 <siraben> Anyone know of papers on parsing whitespace sensitive languages (e.g. python, haskell)
14:37:44 * hackage Rasterific 0.7.5 - A pure haskell drawing engine.  https://hackage.haskell.org/package/Rasterific-0.7.5 (VincentBerthoux)
14:37:45 <siraben> In using indentation to denote some scope
14:38:03 <gentauro_> (my brain tends to store better in memory if I actually try stuff out instead of just reading)
14:39:08 <EvanR> in C you rewrite all the code you need, in js you don't write any of your own code, in haskell it's really surprising how many libraries you can effectively use for leverage. But you still have to write a lot of code
14:40:10 <Raito_Bezarius> in order to create multidimensional Vector.Mutable, can I just do Vector.Mutable.replicate N (Vector.mutable.replicate M myval) ?
14:40:56 <EvanR> gentauro_: so basically, reimplement it yourself, but then use the library. Sounds sane
14:41:39 <Raito_Bezarius> it appears to me I should use Vector.Mutable.replicateM N (VM.replicate M myval)
14:41:41 <Raito_Bezarius> but I'm unsure
14:41:50 <gentauro_> EvanR: for PROD that is pretty obvious
14:42:18 <gentauro_> for hobby projects, I don't mind using my own stuff :D
14:42:19 <EvanR> Raito_Bezarius: replicateM (N * M), with some indexing wrappers?
14:43:41 <Raito_Bezarius> EvanR: is there a real gain to do this?
14:44:11 <EvanR> well, it would improve locality
14:44:19 <Raito_Bezarius> convinced :D
14:44:33 <EvanR> but beyond that i'm not sure
14:55:24 <mikel> Hi - is this a reasonable place to ask (probably stupid) syntactic questions and/or advice on best practices for simple coding?
14:56:40 <[exa]> mikel: very yes
14:56:47 <mikel> ok cool
14:56:56 <mikel> I am curious if there is an idiom in Haskell to reduce repetition from the left hand side to right hand side of a pattern match
14:57:31 <[exa]> can I have a simple example where the repetition is obvious?
14:57:35 <koz_> Raito_Bezarius: If you want _multi-dimensional_ arrays, use massiv.
14:57:49 <koz_> It makes it much easier to do, and handles all this 'locality-oriented' wrapping for you.
14:57:52 <mikel> e.g. handleSituation MyComplexType input1 input2 input3 STATE = MyComplexType input1 input2 input3 STATE
14:58:13 <mikel> whereas I might have some other match that looks like
14:58:24 <amalloy> handleSituation s@(MyComplexType input1 input2 input3 STATE) = s
14:58:24 <[exa]> mikel: oh, either eta-reduce, or use a state/reader monad to pass arguments automatically for you
14:58:35 <EvanR> handleSituation = MyComplexType
14:58:43 <amalloy> oh, it's not a single object. my mistake
14:58:45 <mikel> handleSituation MyComplexType input1 input2 input3 OTHER_STATE = MyComplexType (change input1) input2 input3 NEW_STATE
14:58:52 <EvanR> ah
14:58:55 <EvanR> makes more sense
14:59:23 <EvanR> handleSituation (MyComplexType in1 in2 in3 s0) = MyComplexType (change in1) in2 in3 s1
14:59:53 <amalloy> yeah, this must be missing some parentheses somewhere. how many of those arguments are part of MyComplexType?
15:00:00 <mikel> yep, but if I have some cases where the input and output are going to be the same...
15:00:06 <EvanR> personally that kind of repetition is pretty clear and good. But you can also use lenses instead
15:00:20 <mikel> sdf
15:00:29 <mikel> oops, sorry, trying to see how line breaks work on this editor...
15:00:50 <[exa]> (linebreaking in IRC is not very welcome)
15:00:57 <mikel> handleSituation MCT inp1 inp2 inp3 S1 = MCT inp1 inp2 inp3 S1
15:01:13 <EvanR> you're missing parens
15:01:14 <mikel> handleSituation MCT inp1 inp2 inp3 S2 = MCT inp1 inp2 (inp3+1) S3
15:01:18 <mikel> sorry again
15:01:35 <EvanR> f x y z = is a function with 3 args
15:01:37 <mikel> handleSituation (MCT inp1 inp2 inp3 S1) = (MCT inp1 inp2 inp3 S1) -- if S1 comes in, nothing changes
15:02:12 <amalloy> mikel: in that case, my first suggestion works very well
15:02:12 <mikel> handleSituation (MCT inp1 inp2 inp3 S2) = (MCT inp1 inp2 (inp3+1) S3) -- S2 comes in, we do some manipulationa nd change states
15:02:14 <mikel> etc
15:02:20 <[exa]> mikel: perhaps pattern guards + record syntax combination? lemme put together an example
15:02:22 <EvanR> if you paste an entire real code example then someone here can probably help stylize the whole thing, with more information it's easier
15:02:23 <amalloy> handleSituation s@(MyComplexType input1 input2 input3 STATE) = s
15:02:37 <mikel> Yes, I think that is what I want
15:02:51 <amalloy> in the case where part of it changes, a record update is often good
15:02:57 <mikel> I was looking for something like (MCT inp1 inpt2 inp3 S1) "as" s
15:03:07 <amalloy> mikel: that's s@(...)
15:03:49 <[exa]> mikel: https://gist.github.com/exaexa/94b1fef8c3aba0e34362c698d4621b69
15:03:49 <mikel> Great, thank you I will look up docs on that and play around with it to make sure I know what I am doing
15:04:17 <mikel> I also have another idiomatic/design-y type question
15:04:17 <amalloy> [exa]: case instead of ==, though
15:04:21 <amalloy> ideally
15:04:25 <[exa]> record syntax is great for small updates. I guess you will even be able to group the inputs so that the state==S1 check doesn't need to occur everywhere
15:04:29 <[exa]> amalloy: ^ yes.
15:05:34 <mikel> Is it normal(ish) to define types that just encapsulate a single/simple value...
15:05:43 <mikel> Say, for example, you were modeling an Elevator system
15:05:53 <EvanR> definitely
15:05:55 <mikel> And you have a numeric identifier for floors, but also for cars
15:06:12 <mikel> I had initially gone the route of trying data Floor = Floor {number :: Int}
15:06:22 <mikel> but that got me into trouble as soon as I had two things with "numbers"
15:06:31 <mikel> Was I right to move to doing something more like
15:06:34 <mikel> type Floor = Int
15:06:34 <mikel> ?
15:06:40 <EvanR> newtype Floor = MkFloor { getNumber :: Int }
15:06:45 <[exa]> mikel: there's newtype just for that purpose
15:07:11 <[exa]> mikel: it's just a type tag, the value is the same as the inner Int at runtime
15:07:15 <EvanR> now Int and Floor can't be mixed
15:08:14 <devalot> I have a Church encoded Free monad where some of the constructors take a data family.  When I pattern match on the constructor in my interpreter I get a type error about a rigid type variable.  I'm pretty stuck at this point: https://gist.github.com/pjones/d35e720a2b66aabb051a737c42e6068b  Any help would be awesome.
15:08:18 <mikel> ^ that is what I was trying to achieve
15:08:26 <EvanR> this kind of thing can be good for huge projects where you want a lot of help from the type system. But for quick and dirty programs it has some carpal tunnel overhead
15:08:30 <mikel> (not mixing accidentally)
15:09:00 <mikel> I'm just taking the proverbial car out for a test drive at the moment and trying to understand the idioms
15:09:11 <mikel> And, well, I also want to get more mileage out of the error messages when I do screw things up
15:10:11 <mikel> And right now ghci ends up sptting out a lot of things that look like Int -> Int -> Int rather than telling me it got a CarID when it should have gotten a Floor#
15:10:14 <[exa]> the nice thing about typed functional programming in general is that if you design the types right in a "tight" way around the data, writing programs is easy&safe
15:10:27 <[exa]> because you just look at the types and the program is straightforward
15:10:58 <mikel> Thanks [exa] - I'm familiar with typed f'n programming and its benefits - just not particularly with Haskell...
15:11:10 <[exa]> ok great :]
15:11:34 <mikel> And I was probably zooming through LearnYouAHaskell too quick and passed over newtype
15:11:45 <[exa]> regarding the error debugging, it's beneficial to sometimes add a type signature in the code and see if ghci really thinks the same
15:11:50 <boxscape> if you align patterns in function definitions, do you align them towards the left or towards the right? i.e. in something like `f (x:xs) = x; f _ = undefined`
15:12:24 <boxscape> hm actually I think you have to align to the left in case expressions
15:12:49 <EvanR> "typed f'n programming"
15:13:08 <mikel> EvanR - I swear I didn't mean it badly ;)
15:13:18 <koz_> That's pretty hilarious.
15:13:25 <mikel> f'n isn't the traditional lingo for functional?! :D
15:13:35 <EvanR> it is now
15:14:06 <[exa]> lovable
15:16:37 <[exa]> mikel: also, try a typed hole (type eg. `concatMap _ [1,2,3]` into ghci)
15:16:40 <hpc> /topic Welcome to #hs'kl
15:17:15 <[exa]> international conference on f'n programming now sounds lot cooler
15:18:43 <mikel> I'm not following what concatMap _ [1,2,3] is supposed to do...
15:18:58 <mikel> I feel like something must be missing from that... [exa]?
15:19:07 <dsal> % concatMap _ [1..3]
15:19:08 <yahb> dsal: ; <interactive>:1:1: error:; GHC internal error: `Ghci10.$trModule' is not in scope during type checking, but it passed the renamer; tcl_env of environment: []
15:19:16 <dsal> Works better in ghc/ghci
15:19:37 <mikel> Prelude> concatMap _ [1..3]<interactive>:6:11: Pattern syntax in expression context: _
15:19:39 <mikel> ?
15:19:49 <dsal> It should describe a typed hole.
15:19:57 <dsal> With suggestions of what you can put in  the hole.
15:20:46 <[exa]> mikel: what ghci do you have?
15:20:49 <mikel> It didn't do that ;D
15:21:03 <[exa]> mikel: basically it tells me:  Found hole: _ :: Integer -> [b]
15:21:04 <mikel> GHCi, version 7.6.3: http://www.haskell.org/ghc/  :? for help
15:21:35 <mikel> Totally makes sense and would be useful
15:21:40 <mikel> ghci just didn't do it
15:21:59 <[exa]> perhaps 7.x didn't support holes yet
15:22:17 <EvanR> did you do :t concatMap _ [1,2,3]
15:22:18 <amalloy> typed holes by default are only...what, a couple years old now?
15:22:32 <[exa]> mikel: you might eventually want to go to 8.x, there's a lot of new stuff
15:22:38 <EvanR> remember the :t
15:22:49 <Raito_Bezarius> I'm benchmarking a function using Criterion, I tried to see how can I change how the charts are reported, I have a function X :: (String, String) -> Y and I'd like to use the length of the first param as the X-axis for the charts
15:22:50 <glguy> 7.6.3 came out in 2013
15:23:08 <mikel> EvanR - :t didn't help
15:23:17 <amalloy> 2013 is definitely before typed holes
15:23:25 <glguy> 7.6.1 was from Sept 2012; it's time to update your GHC
15:23:56 <EvanR> who is providing people with these ancient ghc's
15:24:56 <glguy> Maybe AOL is bundling them in the CDs they send out?
15:25:10 <svipal> AOL bundling haskell, that would be something
15:26:00 <EvanR> 1025 free hours!
15:26:34 <amalloy> i probably have a pretty old ghc on my macbook
15:28:17 <jle`> i brushed off an old ruby project the other day and it was witha  ruby from around 2013
15:29:14 <shachaf> Why do people say typed holes instead of holes?
15:29:31 <shachaf> They used to call them type holes, which was even odder.
15:29:47 <amalloy> jle`: i only recently finally gave up my 2010-era SLIME setup for clojure
15:30:09 <amalloy> it's still better than the modern thing imo, but it's just unreasonable to hold on that long
15:30:32 <dsal> amalloy: It's sad when technology doesn't seem to move forward sometimes.
15:32:32 <EvanR> to differentiate from untyped holes... if this isn't a thing it should be!
15:33:08 <jle`> i think historically the name caught fashion because the thing we cared about the wholes were their types
15:33:16 <jle`> so typed holes = holes where we care about the types, maybe
15:33:21 <jle`> but nowadays we use holes for so much more
15:34:21 <jackattack825> anyone online rn that can help me with a basic recursion syntax issue
15:34:34 <jle`> jackattack825: just ask your question, and you will find out :)
15:34:57 <jackattack825> would it be easier if i posted my code directly in here or linked to my post on github?
15:35:09 <jackattack825> https://stackoverflow.com/questions/59166919/haskell-recursive-adding-function-not-working
15:36:06 <Axman6> tail list + x doesn't make sense
15:36:09 <Axman6> :t (+)
15:36:12 <lambdabot> Num a => a -> a -> a
15:36:23 <Axman6> you can't ass a number and a list
15:36:26 <Axman6> add*
15:37:30 <Axman6> > [1,2,3::Float] + 7
15:37:32 <lambdabot>  error:
15:37:33 <lambdabot>      • No instance for (Num [Float]) arising from a use of ‘+’
15:37:33 <lambdabot>      • In the expression: [1, 2, 3 :: Float] + 7
15:38:16 <jackattack825> doesnt tail return the last value in the list
15:38:25 <jackattack825> so 'tail list + x' would be a float
15:38:42 <Axman6> no, that's last
15:38:49 <Axman6> :t tail
15:38:51 <lambdabot> [a] -> [a]
15:38:57 <Axman6> :t last
15:38:59 <lambdabot> [a] -> a
15:39:23 <jackattack825> oh fantastic, ill make that fix and see what happens
15:40:07 <int-e> shachaf: It's not hard to trace... a) there's the -fwarn-typed-holes that enables printing warning containing holes' types when -fdefer-type-errors is set. b) "type holes" was the original title in the wiki page https://wiki.haskell.org/index.php?title=GHC/Typed_holes&oldid=54322 which was written very early in the feature's live; perhaps even before it was properly documented.
15:40:44 <shachaf> But why do GHC people say typed holes?
15:40:58 <shachaf> The whole history seems bizarre to me. Or should I say the hole history?
15:41:12 <glguy> there are typed holes and type holes!
15:41:25 <EvanR> Axman6: in before [a] Num when a Num... by making integers becomes infinite lists and adding is done with zipWith
15:41:37 <jackattack825> i got it to compile now but its still not working as intended
15:41:43 <int-e> And nowadays we have type holes with PartialTypeSignatures.
15:41:56 <int-e> glguy: I was getting to that actually, I'm just slow :)
15:42:22 <glguy> maybe better to have value holes and type holes?
15:43:12 <jackattack825> Axman6 do u see any other issues?
15:45:26 <shachaf> Value holes would make a lot more sense.
15:46:27 <int-e> shachaf: I really blame early writing on the topic, together with the fact that while the "typed holes" terminology is redundant, it's not so much wrong as redundant.
15:46:40 <int-e> Uhm, redundancy is redundant.
15:46:48 <EvanR> when is "typed _" not redundant?
15:46:51 <glguy> untyped holes?
15:47:23 <int-e> Yeah I do wonder whether untyped holes could make any sense here.
15:47:32 <int-e> :t let x = _ in x == (x == ())
15:47:39 <lambdabot> error:
15:47:39 <lambdabot>     • Found hole: _ :: t
15:47:39 <lambdabot>       Where: ‘t’ is a rigid type variable bound by
15:48:04 <shachaf> Why aren't they called typed holes and kinded holes?
15:48:43 <shachaf> pity this busy hole, typeunkind,
15:48:44 <glguy> shachaf: Because then what would we call the holes in kids?
15:48:49 <glguy> kinds* sorted holes?
15:48:54 <dolio> Why aren't they called sheds?
15:49:01 <int-e> dolio++
15:49:15 <glguy> dolio: Because we don't want to have to argue of their color, of course
15:49:40 <dolio> Hmm.
15:49:51 <nshepperd> I prefer handwritten holes
15:49:51 <dolio> I can't remember what color sheds were. Brown maybe?
15:49:59 <int-e> shachaf: This is not a good question. Terminology evolves, but usually only when a new concept is introduced (that happened) or when people constantly miscommunicate because of bad terminology. (apparently that has not happened here much).
15:50:22 <dsal> At least it's _ and not ⊥
15:50:44 <glguy> Oh yeah, that's another dimension we could bikeshed
15:54:09 <jackattack825> if anyone can find the problem here it would be incredible, I am sure it won't take much time https://stackoverflow.com/questions/59166919/haskell-recursive-adding-function-not-working
15:55:34 <int-e> Hrm, why does let x = undefined in x == (x == ()) type-check with MonoLocalBinds?
15:55:46 <dolio> Apparently no one took screenshots of epigram 1 in xemacs.
15:56:13 <Axman6> jackattack825: something seems to be wrong with your GHCi
15:56:14 <glguy> int-e: monolocalbinds is magic and treats things that could be lifted to top level differently iirc
15:56:57 <jackattack825> Axman6 does it work when you try it on your system?
15:57:37 <nil> jackattack825: works fine for me. those errors don't match anything in the code you've shown
15:58:11 <jackattack825> nil thanks, thats really bizarre I guess I will turn it in as is
15:59:18 <svipal> I wish haskell had dirtier macros sometimes
16:00:00 <Axman6> LANGUAGE CPP
16:02:35 <int-e> I guess the reason is that "undefined" already has a general type... there's no more explicit "generalization" to an explicitly higher-order type that MonoLocalBinds could perform here.
16:03:33 <int-e> (Or rather, not perform.)
16:03:59 <nshepperd> despite its name, i think monolocalbinds mostly just means "don't generalise let bindings which refer to local free variables"
16:04:20 <glguy> > let f i = let x = undefined (i::()) in x == (x == ()) in f
16:04:22 <lambdabot>  error:
16:04:22 <lambdabot>      • Couldn't match expected type ‘()’ with actual type ‘Bool’
16:04:22 <lambdabot>      • In the second argument of ‘(==)’, namely ‘(x == ())’
16:04:36 <glguy> You have to make it so x can't lift out to the top level
16:05:04 <glguy> or something like: let f i = let x = i `seq` undefined in x == (x == ()) in f, whatever
16:05:42 <int-e> Okay. That is confusing.
16:14:24 * joep
16:14:25 <svipal> >
16:14:30 <svipal> >Declaration splices are allowed only at the top level
16:14:52 <svipal> Very angry face.jpg
16:15:11 <EvanR> what are you going to declare at the non-top level
16:17:05 <Raito_Bezarius> I'm using criterion with nf and I have this polymorphic function which causes issues with normal form computation
16:17:06 <Raito_Bezarius>  Ambiguous type variable ‘b0’ arising from a use of ‘dist_naif’
16:17:09 <Raito_Bezarius>       prevents the constraint ‘(Num b0)’ from being solved.
16:17:11 <Raito_Bezarius>       Probable fix: use a type annotation to specify what ‘b0’ should be.
16:17:26 <Raito_Bezarius> dist_naif :: X1 → X2 → Xp → a
16:17:53 <Raito_Bezarius> where a implements Show a, Num a, Eq a, Ord a for example
16:18:09 <Raito_Bezarius> I'm not sure how to implement the probable fix mentioned
16:18:16 <Axman6> you'll need to pick somew type for it to return
16:18:39 <glguy> svipal: does this help? http://hackage.haskell.org/package/template-haskell-2.15.0.0/docs/Language-Haskell-TH-Syntax.html#v:addTopDecls
16:18:41 <Raito_Bezarius> how to perform this?
16:18:51 <nshepperd> i've a few times wished that you could define type synonyms in a let/where clause
16:18:57 <Axman6> add a type annotation
16:19:01 <Raito_Bezarius> Axman6: where?
16:19:07 <Raito_Bezarius> on dist_naif ?
16:19:15 <Axman6> where you're calling your function
16:19:21 <Raito_Bezarius> I'm calling here:
16:19:25 <Raito_Bezarius>   bench "dist_naif" $ nf dist_naif inst,
16:19:31 <Raito_Bezarius> I'm not sure how to add a type annotation there
16:19:36 <svipal> glguy : it doesn' t but nice to know it exists
16:19:36 <Raito_Bezarius> I tried nf (dist_naif inst :: Int)
16:19:39 <Raito_Bezarius> but it didn't work
16:19:47 <boxscape> int-e it also works with -XMonomorphismRestriction
16:20:16 <Axman6> you'll probably need  nf (dist_naif :: X -> Int) inst
16:20:24 <Raito_Bezarius> hmm okay
16:20:48 <Axman6> remember that dist_naif and inst arearguments to nf
16:20:52 <Axman6> arguements*
16:20:58 <Axman6>  urgh
16:21:26 <MarcelineVQ> arugulas
16:22:39 <nshepperd> x = undefined is unaffected by MonomorphismRestriction because its type variable is unconstrained
16:22:45 <boxscape> ah
16:27:39 * hackage advent-of-code-api 0.2.6.2 - Advent of Code REST API bindings and servant API  https://hackage.haskell.org/package/advent-of-code-api-0.2.6.2 (jle)
16:28:17 <sondr3> boy, pandoc sure do take a while to compile
16:28:56 <Axman6> it's the import Every,Document.Known.To.Man that takes a while
16:29:41 <sondr3> it just feels so slow, GHC is using ~10% of my available CPU, I can take more
16:30:33 <sondr3> I need the heat in these cold Norwegian winters
16:30:41 <jle`> yeah, whenever i switch to a new stack resolver or fresh install, the first thing i do to make sure i install everything in the haskell ecosystem is is pandoc. then lens.
16:30:59 <jle`> and lens is the light one of those two :)
16:31:43 <Axman6> sondr3: I often throw in a --ghc-options "-j +RTS -A128m -n2m -RTS" to amke GHC do more at once
16:32:09 <sondr3> thanks, I'll keep that in mind for the next time
16:32:26 <Axman6> the -j is the important but, but the rest can help with compile times. This advice brought to you by the cargo cult of "Googling: Why are my haskell compiles so slow"
16:32:26 <glguy> lens doesn't really have any big dependencies you wouldn't already have
16:32:59 <sondr3> no offense to Haskell, but it is by far the language with the highest "how do I do ..." of any language I've used
16:33:42 <jle`> even more than your first language? :o
16:34:21 <sondr3> fair, might be, can't remember anymore
16:34:36 <sondr3> though you started so simple, print something, a simple if check, a small for loop
16:34:37 <jle`> sondr3: the thing is that almost all the mainstream languages are almost identical
16:34:52 <jle`> so once you learn one, the rest become fairly straightforward
16:34:55 <Axman6> sondr3: you started with simple, bad habits though :)
16:35:00 <shachaf> i,i but some are more identical than others
16:35:08 <jle`> *mainstream imperative languages
16:35:12 <sondr3> haha, Haskell is continously blowing my mind
16:35:17 <jle`> yes, they are all varying degrees some somewhat-different
16:35:25 <sondr3> and then I read some answers for Advent of Code in Haskell and it's like they're not even using the same language I am
16:35:31 <glguy> For me that's python and JavaScript. Trying to hunt through documentation when it exists to know what methods things have and what arguments those methods accept trying to glean the information from a couple of provided examples
16:36:34 <koz_> I agree with glguy.
16:37:14 <Axman6> types are the best form of documentation
16:38:44 <MarcelineVQ> If you're not going to include any documentation, types are the best documentation :X
16:38:57 <ammar2> ^^
16:38:59 <MarcelineVQ> But in all other cases I don't mind a bit more to go on
16:39:32 <ammar2> the combination of a good name, brief description and type are usually pretty solid
16:40:27 <infinity0> https://repl.it/repls/ArcticSteelblueElement with this DataKinds unification issue, i can fix it by changing the type of impl but it's not ideal
16:40:31 <infinity0> does anyone have any better ideas
16:41:02 <infinity0> i'm trying to unify () with t :: '()
16:41:08 <EvanR> considering how straightforward most haskell functions are in terms of allowed arguments, docs should be easy! Documentation of lisp, php, ruby at least gives them an excuse to avoid documenting
16:41:18 <hololeap> can anyone recommend a good modern library that fits this description: https://wiki.haskell.org/Applications_and_libraries/Mathematics#Dynamic_precision_by_lazy_evaluation
16:42:47 <EvanR> ok, real numbers implementing using stream of digits 0 to 9 doesn't seem compatible with "always correct"
16:43:09 * hackage hopenpgp-tools 0.23 - hOpenPGP-based command-line tools  https://hackage.haskell.org/package/hopenpgp-tools-0.23 (ClintAdams)
16:43:27 <infinity0> equality over reals is known to be undecidable, it's expected not to always be able to give an answer
16:43:39 <EvanR> using that implementation you can't even do addition!
16:44:02 <EvanR> i also would like to see someone use lazy evaluation for reals somehow
16:45:08 <jle`> infinity0: i suppose the problem is that it's forall (t :: ())., but impl only works with t ~ '().
16:45:16 <jle`> infinity0: but it's weird that the second version compiles now
16:45:56 <infinity0> jle`: sorry i mis-edited, the cosntraint needs to be deleted for it to compile
16:46:11 <hololeap> i want to solve kepler's equation with dynamic, lazy evaluation. so it starts out with a low precision but can compute higher precision on demand...
16:46:24 <infinity0> so impl :: X t -> X t works, but impl :: (t ~ '()) => X t -> X t doesn't work
16:46:25 <jle`> infinity0: ah, that makes sense then
16:46:30 <EvanR> without recomputing everything, right?
16:46:36 <nshepperd> real numbers aren't real
16:46:37 <EvanR> which is what people usually do
16:46:42 <jle`> infinity0: yeah, it's because you need `ps t -> ps t`
16:47:04 <infinity0> well in this case the only possible value for t is ()
16:47:06 <jle`> but impl :: X '() -> X '(), or impl :: (t ~ '()) => .., only works for t ~ '()
16:47:14 <EvanR> nshepperd stop pointing out the emperors lack of clothes
16:47:16 <infinity0> but i suppose it wouldn't generalise if the kind of t was not ()
16:47:23 <jle`> infinity0: yes, but are youe xpecting ghc to do a search on all inhabitants of a type?
16:47:43 <jle`> *of a kind
16:48:04 <infinity0> i guess not :( i had hoped it might have special logic for kinds/types it knows are finite
16:48:12 <jle`> like a special-case?
16:48:16 <jle`> that sounds gross D:
16:49:04 <infinity0> it means i have to have extra type params floating about in my code even though it'll always be () for this particular case :(
16:49:06 <jle`> you can also think of a parametricity thing too, i suppose. there's a semantic difference between a forall (p :: ()) :: X p -> X p, and an X '() -> X '()
16:49:32 <jle`> just like the difference between forall a. Maybe a -> Maybe a, and Maybe Int -> Maybe Int
16:50:19 <jle`> i wonder if also 'TypeError' might behave differently in either case
16:50:31 <jle`> since TypeError (Text "hello") is an inhabitant of '()
16:50:35 <jle`> * is an inhabitant of ()
16:51:26 <infinity0> well for the xxx0 stuff at the top, ghc is able to unify (x ~ ()) with ()
16:51:59 <jle`> infinity0: yeah, that's because you constrain p
16:52:04 <jle`> or, the parameter
16:52:09 <jle`> to have to be equal to ()
16:52:15 <jle`> but if there's no counstraint, it could be "anything" :O
16:52:26 <jle`> the same situation works if you use something like Bool
16:52:41 <jle`> if you constrain (~) 'True, then an X 'True -> X 'True will work
16:53:51 <infinity0> hm ok
16:54:01 <infinity0> i wonder if i can work around this with GADTs or something
16:54:40 <jle`> anything that will bring t ~ '() would work
16:54:47 <jle`> so like a singleton or any type of GADT as a parameter
16:55:06 <jle`> but also why would impl :: X '() -> X '() be bad, if it describes what it's doing?
16:55:15 <jle`> er wait that was the opposite question
16:55:34 <jle`> but yeah, if you take Sing t -> X t -> X t, you could get it to work with X '() -> X '()
16:55:36 <infinity0> yeah i want impl to have the type X '() -> X '() but ghc is forcing me to type it as X t -> X t
16:55:54 <infinity0> ah ok yes, maybe i'll have to finally start using singletons
16:56:00 <jle`> you need some sort of way to bring into scope the constraint that t ~ '()
16:56:20 <jle`> so if you had `intf :: Proxy tt -> Sing t -> ps t -> ps t`
16:57:08 <jle`> then you could do intf _ STuple0 = impl
16:57:21 <jle`> since a match on STuple0 means that t ~ '()
16:57:57 <infinity0> ah right yes ok
16:58:52 <infinity0> in this case i don't even need the Proxy, ghc should be smart enough to deduce it from (Sing x) i hope?
17:00:25 <nshepperd> there's not really any such thing as a finite kind, i think, because there's an infinity of possibly stuck type families 
17:01:55 <jle`> infinity0: the proxy isn't needed even in your original situation
17:02:23 <infinity0> yeah i was trying to make it "look like" the stuff at the top, where "Proxy c" is needed
17:02:28 <jle`> infinity0: since tt can be inferred
17:02:43 <jle`> yeah, at the top the proxy is needed to infer what 'c' is
17:04:45 <infinity0> i mean, is ghc smart enough to infer x from Sing x, maybe by using TypeFamilyDependencies but i wasn't sure if that is working properly these days
17:07:03 <infinity0> well, seems to work over here anyways
17:10:09 <jle`> infinity0: it isn't inferring x from Sing x
17:10:15 <jle`> it's inffering x from the constructor you pattern match on
17:10:25 <jle`> so you have to actually match on the pattern for the inference to happen
17:10:32 <jle`> think of it as intf _ = \case STuple0 -> impl
17:10:43 <jle`> any other possible constructor and you might get something different
17:11:22 <infinity0> sure, i meant in the case at the top with Proxy c
17:12:01 <infinity0> in the general case i'm wondering if it's possible to replace Proxy c with Sing c assuming you have one of the latter, and i think it is just by playing with it
17:12:19 <infinity0> for example if i replace Proxy c with Y c and define 'type family Y (c :: * -> Constraint) = r | r -> c' it works
17:12:28 <infinity0> if i drop the '| r -> c' it complains
17:12:38 <infinity0> so i guess Sing x also has one of these dependencies annotated
17:13:11 <jle`> yeah, because if you use a value of type Y c, it won't know what c you used to get it
17:13:29 <jle`> without the injectivity annotation
17:13:46 <jle`> for example type MyFam Int = Bool; type MyFam String = Bool
17:14:06 <jle`> then if you ask for a `MyFam t` and you see that it is a Bool, that doesn't tell you what 't' is
17:29:40 <iqubic> Is everyone ready for tonight
17:29:59 <iqubic> tonight's advent of code. Is everyone reade?
17:37:09 <zeta_0> after installing ihaskell in nixos, emacs is throwing this error: [error] ein:ml-lang-setup: kernelspec language ’haskell’ unsupported
17:37:28 <zeta_0> here is the full debugging error: https://hastebin.com/udolawivox.m
17:38:05 <Axman6> vaibhavsagar: ping, you seem to be the iHaskell export these days
17:38:51 <jusss> jle`: is there a definition about the term `continuation'?
17:57:41 <infinity0> jle`: is there a way of doing intf with an implicit Singleton? i couldn't figure it out, the "cannot match" error keeps coming back :/
17:57:49 <EvanR> nice NumericPrelude exists and looks pretty existence, and all types are named T and all classes are named C which makes the documentation looks very interesting http://hackage.haskell.org/package/numeric-prelude-0.4.3.1/docs/NumericPrelude.html
17:58:03 <EvanR> looks pretty extensive...
17:58:40 <EvanR> we should switch to NumericPrelude as soon as everything is given proper naming
18:00:00 <int-e> EvanR: I suspect the maintainer won't budge on the naming and rather call for tool support (in haddock) for that programming style.
18:00:27 <EvanR> frightening
18:01:30 <infinity0> https://repl.it/repls/ArcticSteelblueElement
18:02:08 <EvanR> i dare ask why he didn't write the code within a module using a type synonym and a constraint synonym
18:02:56 <nshepperd> ah, henning types
18:03:01 <EvanR> which could also have been referenced from other modules the same way
18:03:14 <EvanR> Foo.T, but the type is not literally called T. For sane people
18:04:19 <EvanR> i guess sane people could make their own synonym...
18:17:37 <infinity0> oh i figured it out, you just need to type it carefully
18:20:19 <dmj`> people be like, "monadic parser combinators are great", I be like, "have you ever used 'read'?"
18:20:47 <iqubic> I'm using Megaparsec for all my parsing for AoC.
18:21:22 <dmj`> xs :: [Int] <- fmap read . splitOn ","  <$> readFile "input.txt"
18:21:33 <iqubic> I know. I know that works.
18:21:34 <dmj`> that's a "mega" read for me
18:21:42 <iqubic> mega?
18:22:00 <dmj`> a slight jab
18:22:06 <dmj`> why use a sledge hammer though
18:22:14 <dmj`> when all you need is a hammer
18:22:15 <int-e> > read ('"' : repeat ' ') :: int
18:22:18 <int-e> > read ('"' : repeat ' ') :: Int
18:22:18 <lambdabot>  error:
18:22:19 <lambdabot>      • No instance for (Read int1) arising from a use of ‘read’
18:22:19 <lambdabot>        Possible fix:
18:22:25 <lambdabot>  mueval-core: Time limit exceeded
18:22:33 <dmj`> > read "\"foo\"" :: String
18:22:36 <lambdabot>  "foo"
18:22:57 <iqubic> If you have a string, and need a string, just use that string.
18:23:02 <iqubic> > id "foo"
18:23:04 <lambdabot>  "foo"
18:23:10 <iqubic> No need to read a string.
18:23:16 <int-e> > read ('"' : repeat ' ') :: Int -- the timeout is real!
18:23:21 * Axman6 disagrees
18:23:23 <lambdabot>  mueval-core: Time limit exceeded
18:24:50 <dmj`> iqubic: yea, but reading an Int is great
18:24:58 <int-e> So it turns out that `read` is based on a lexer that recognizes an approximation of Haskell tokens. And that's a big part of the reason why `read` is quite slow for parsing integers.
18:25:00 <dmj`> ReadP is what the old timers used to be all about
18:26:22 <jusss> can someone help understanding continuation?
18:26:31 <dmj`> iqubic: but for AoC why use anything else but read
18:27:02 <talles> Hi guys, I'm trying to solve a problem of list in Haskell, given a list [1,2,3,4] and a parameter like 8, I need to return a list of list of the first parameter which are added and is equals to the second
18:27:26 <zeta_0> after installing the nix package ihaskell, when i try to run it in emacs(ein), it throws an error: `[error] ein:ml-lang-setup: kernelspec language ’haskell’ unsupported` ?
18:27:28 <talles> example: I have this list: 
18:27:35 <talles> somaN [1,2,3,4,5,7,8] and the 8 as second parameter
18:27:59 <talles> I need to return something like this [8],[3,5],[1,2,3],[1,7]
18:28:07 <talles> Anyone could help me?
18:30:43 <talles> as far as I understand, I have this:
18:30:58 <talles> https://gist.github.com/InluxBDX/02946bd9057fc2d544733aed14f49b18
18:31:37 <dmj`> > filter ((==8) . sum) $ subsequences [1,2,3,4,5,7,8]
18:31:40 <lambdabot>  [[1,3,4],[1,2,5],[3,5],[1,7],[8]]
18:31:43 <dmj`> merry christmas son
18:31:55 <talles> just this?
18:32:07 <doublex> > subsequences [1,2,3]
18:32:10 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
18:32:13 <dmj`> talles: yes
18:32:17 <zeta_0> here is the full debug error: https://hastebin.com/igucagoqeh.m
18:32:28 <dmj`> @src subsequences
18:32:29 <lambdabot> Source not found. I've seen penguins that can type better than that.
18:32:54 <dmj`> since when did lambdabot trash talk
18:33:15 <iqubic> For a long time that has been a feature
18:33:54 <iqubic> I'd prefer to put a space in there. (==8) looks a little wrong to me.
18:35:23 <dmj`> I like unconventional haskell syntax
18:35:39 * hackage haskellish 0.1.0 - For parsing Haskell-ish languages  https://hackage.haskell.org/package/haskellish-0.1.0 (dktr0)
18:36:33 <Raito_Bezarius> For some reason, when I do cabal v2-build it fails asking for System.Random package to be installed
18:36:43 <Raito_Bezarius> But when I drop into ghci using the correct package db, I can import it
18:36:49 <Raito_Bezarius> (like cabal v2-repl <executable>)
18:39:19 <talles> I'm getting an error, of type
18:39:20 <talles> https://gist.github.com/InluxBDX/02946bd9057fc2d544733aed14f49b18
18:39:46 <talles> So the code means, filter everything that matches the filter (==8)?
18:40:49 <dmj`> @type filter ((==8) . sum) $ subsequences [1..8]
18:40:52 <lambdabot> (Eq a, Num a, Enum a) => [[a]]
18:41:04 <dmj`> sumofN :: [Int] -> Int -> [[Int]]
18:41:14 <dmj`> > filter ((==8) . sum) $ subsequences [1..8]
18:41:16 <lambdabot>  [[1,3,4],[1,2,5],[3,5],[2,6],[1,7],[8]]
18:41:27 <dmj`> talles: your return type should be [[Int]]
18:41:27 <talles> so, as I'm using the parameter, will be something subsequences [1...n]?
18:41:31 <dmj`> talles: is this homework?
18:41:51 <talles> Yes, and it's the most complex 
18:42:23 <dmj`> if this is considered complex, your teach might be surprised to find you used subsequences
18:42:28 <dmj`> teacher*
18:43:45 <Ra51> Hi
18:45:21 <Ra51> I am asked to implement substitution and evaluation of lambda calculus in Hasklell
18:45:32 <Ra51> how do I proceed?
18:45:52 <talles> it works, but I didn't get the subsequences and the . sum. In this, sum is a function? I'm googling right now about this
18:45:53 <Ra51> I am confused between Abstraction and App
18:46:22 <Axman6> Ra51: is this homework?
18:47:22 <Ra51> It is a part of a assignment I am trying to work
18:47:38 <Ra51> I just want to be clear with the concepts
18:47:45 <Ra51> I dont know where to start
18:48:22 <Axman6> We can help you with understanding but won't give you the answer. Do you have some more info about what you're trying to do? your question isn't very clear
18:48:46 <talles> Same there, I think I can solve a bunch of problems in the test using this filter and subsequences function 
18:48:56 <dmj`> talles: sum is a function yes
18:49:07 <talles> sum :: (Num a, Foldable t) => t a -> a
18:49:17 <talles> Prelude shows me this 
18:49:17 <talles> sum :: (Num a, Foldable t) => t a -> a
18:49:25 <talles> and this for subsequences 
18:49:26 <talles> subsequences :: [a] -> [[a]]
18:49:28 <dmj`> talles: if you're unsure about sum being a function, then definitely do not use subsequences on your homework
18:50:00 <talles> No, I understand that is a function, 
18:50:02 <dmj`> talles: I'd recommend you read through Data.List and try to implement each function on your own, and maybe a good part of the Prelyde too
18:50:05 <talles> and add numbers 
18:50:15 <dmj`> Prelude*
18:50:44 <dmj`> talles: is this a Haskell class?
18:51:09 <dmj`> talles: or are you just trying to flex by using Haskell on your homework, does your teacher know it ?
18:51:42 <talles> A Haskell class, I have a list of problems to solve using Haskell 
18:52:04 <talles> Yes, it Prelude really helps to understand the functions 
18:52:16 <dmj`> talles: is the curriculum online?
18:52:21 <talles> no, 
18:52:31 <talles> It's a very simple list 
18:52:35 <Axman6> Ra51: do you have any more infoirmation about the problem you're having? 
18:52:36 <talles> only with the basic of Haskkell 
18:52:39 <talles> *Haskell 
18:52:54 <dmj`> talles: is Ra51 in your class?
18:54:03 <talles> No, I'm from Brazil 
18:55:02 <talles> I'm studying Programming Languages Concepts, and Haskell is one of them.
18:55:24 <leifm> Maybe run through https://github.com/data61/fp-course/blob/master/src/Course/List.hs ?
18:56:13 <talles> But I liked Haskell, 
18:56:29 <talles> I'll get my imperative problems and implement them in Haskell 
18:56:39 <dmj`> talles: Haskell is great, keeps programming fun and the types really teach you a lot about the domain you're working in
18:56:54 <dmj`> it's the gift that keeps on giving
18:58:36 <talles> But I get stuck in things like (Num a, Foldable t) => t a -> a, I mean, understand the syntax just like sum (Int a, Int b) { return a + b} 
18:58:56 <talles> Yes, it's really great, a many possibilities
19:01:59 <EvanR> (Num a, Foldable t) => t a -> a  when t=[] means Num a => [a] -> a. Which is what sum was before Foldable existed
19:02:13 <EvanR> if that more specific type helps
19:05:47 <talles> when you said, "you have to implement the functions of Prelude by yourself" your mean, implementing for example subsequences or using subsequences to implement some custom function?
19:26:03 <dmj`> talles: implementing subsequences yourself
19:26:09 <dmj`> talles: try to do it without looking
19:26:13 <dmj`> talles: just observe its behavior
19:26:20 <dmj`> > subsequences []
19:26:23 <lambdabot>  [[]]
19:26:25 <dmj`> > subsequences [1]
19:26:28 <lambdabot>  [[],[1]]
19:26:31 <dmj`> > subsequences [1,2]
19:26:34 <lambdabot>  [[],[1],[2],[1,2]]
19:26:40 <talles> yes, every possible combination 
19:26:47 <talles> given a [] 
19:26:53 <dmj`> talles: no, just base case and a few inductive steps
19:36:17 <iqubic> > subsequences [1,2,3]
19:36:20 <lambdabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
19:41:52 <iqubic> I have decided to ditch my homemade point library in favor of Linear.
19:41:52 <iqubic> AoC is going to be easier.
19:48:12 <iqubic> cocreature: Are you the dual of a creature?
19:54:51 <guest625> hi guys
19:55:05 <heatsink> hi
19:55:11 <guest625> i was trying out some lamda calculus with haskell
19:55:42 <guest625> found a function ..but not getting the function call and arguments
19:55:46 <iqubic> have you got any questions, or just some comments on Lambda calculus in Haskell?
19:56:01 <guest625> subst :: Eq a => Term1 a -> Term1 a
19:56:30 <guest625> this is my question...glad if someone helps
19:58:03 <maerwald> tdammers: will you bet at the amsterdam fp meetup in january?
19:58:41 <guest625> guys...any idea?
19:59:40 <cole-k> is there a monoid wrapper for Maybe that behaves like All
20:00:03 <leifm> Probably just being pedantic, but `subst :: Eq a => Term1 a -> Term1 a` is a type signature, not a function.
20:00:06 <cole-k> ah i am foolish i see the error of my ways
20:01:02 <guest625> ok...but how do u call the subst function??
20:01:37 <cole-k> wait nevermind, i still have this question: I'd like a wrapper for Maybe over a semigroup such that Just x <> Nothing = Nothing
20:02:35 <Lears> cole-k: Ap
20:03:05 <cole-k> Lears: Thank you
20:03:29 <leifm> What?
20:03:51 <leifm> I thought I knew what was going on, but then they hit me with "This data type witnesses the lifting of a Monoid into an Applicative pointwise."
20:04:21 <guest625> leifm....any thoughts on that would be helpful
20:05:39 <leifm> guest625: have you read an introductory book on Haskell? `f a` applies f to a but if you were stuck on that a book or similar would help a lot.
20:20:13 <Axman6> glguy: I don't think you've even asked a question yet, what is your question? what is Term1? 
20:20:40 <Axman6> uhm, sorry glguy, that was for guest625 who left -_-
20:21:14 <glguy> Ok, I'll play. What's your favorite function?
20:21:44 <koz_> glguy: confusing.
20:22:31 <Axman6> confusing is actually an amazing function
20:23:53 <Axman6> I also feel like traverse is a pretty high power to weight ratio function, so it's definitely up there
20:28:11 <POGtastic> got a silly question. Say that I have a monad of type m a. I have a function of type (a -> b). currently, I've been defining a function `turnMonadic = (.) return` to change that function's type to (a -> m b). I *think* that I'm being silly. Is there a better way?
20:29:31 <dolio> What is worrying you about it?
20:29:44 <dolio> Is it that `(.) return` is shorter than turnMonadic?
20:30:28 <Axman6> POGtastic: Why do you need a function of type a -> m b?
20:30:30 <dolio> It is a little silly to invent a name longer than the definition.
20:30:40 <MarcelineVQ> it can depend what you are using  a -> m b  for. if you're doing it just to use >>= you can just use fmap in the first place for example
20:30:42 <POGtastic> Axman6: so that I can apply the >>= operator to that function
20:30:52 <Axman6> looks like you just want fmap then
20:30:58 <Axman6> :t fmap
20:31:00 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:31:11 <POGtastic> and monads are functors... gotcha
20:31:29 <Axman6> in fact, you're just restating one of the monad laws - m >>= return . f = fmap f m
20:31:34 <glguy> If anyone's doing Advent of Code in Haskell this year and hasn't joined my leaderboard, I've freed up some space: 43100-84040706
20:43:03 <POGtastic> Is there a straightforward way to use `fmap` with composition the way that I'm doing in this code with `turnMonadic` and >>=? https://repl.it/@pogtastic/Adjacent-Vowels
20:44:05 <POGtastic> (see `main`, ignore the rest of my silly code)
20:45:15 <Axman6> putStrLn =<< fmap (("Result: " ++) . onlyAdjacentToSet (Set.fromList "aeiou")) getLine
20:45:32 <POGtastic> :t (=<<)
20:45:35 <lambdabot> Monad m => (a -> m b) -> m a -> m b
20:45:47 <Axman6> @src (=<<)
20:45:47 <lambdabot> f =<< x = x >>= f
20:46:16 <Axman6> dat symmetry
20:46:22 <POGtastic> aha! that looks smarter. thanks a lot
20:46:56 <Axman6> you can also use <$> or <&> 
20:47:10 <POGtastic> i've seen <$> for fmap, but haven't seen <&>...
20:47:15 <POGtastic> :t (<&>)
20:47:17 <lambdabot> Functor f => f a -> (a -> b) -> f b
20:47:26 <Axman6> getLine <&>  onlyAdjacentToSet (Set.fromList "aeiou" <&> (("Result: " ++) >>= putStrLn
20:47:27 <POGtastic> oh, it's the opposite
20:47:45 <Axman6> (That may need some brackets)
20:52:37 <POGtastic> that (<&>) operator worked perfectly. thanks a lot Axman6
20:54:00 <POGtastic> now to complain to my professor for not introducing me to Data.Functor... :)
20:55:17 <Projectbarks> Hi all I am running GHCi, version 8.6.5 and trying to use AvlTree but it seems there are some syntax incompatibilities. I was wondering if anyone had any recommendations of AVL trees
20:55:32 <Projectbarks> libraries 
20:59:18 <Axman6> well, AvlTree hasn't been updated since 2008 so I'm not surprised
21:00:07 <Projectbarks> Me either I wasn't sure if it was my noobness that prevented me from finding a more updated librrary 
21:00:16 <Axman6> do you specifically need an AVL tree?
21:00:52 <Projectbarks> Not specifically but ideally some form of sorted key value store  
21:01:02 <Axman6> sounds like Data.Map then
21:01:16 <Axman6> which, IIRC, is a tree with bounded balance
21:01:22 <Axman6> whatever that means
21:01:35 <Axman6> https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Map-Strict.html
21:02:11 <Projectbarks> Amazing 
21:02:39 <Projectbarks> Thanks so much @axman6 thanks for accepting my noobness. By chance how did you find this 
21:03:42 <Axman6> I've probably used it hundreds of times. containers is the place to start with for most data structures. unordered-containers is what you use when performance and memory matter, and you don't need ordered keys
21:04:42 <Axman6> vector gives you immutable and mutable vectors. 
21:05:25 <Axman6> generally it's best to ask about the problem you're trying to solve, not about a specific solution you think is the right one. "I need an ordered map" gets better answers than "Where fo I find an AVL tree implementation"
21:06:01 <Projectbarks> Good point! 
21:08:04 <koz_> Axman6: I believe it's some kind of red-black tree.
21:08:21 <koz_> (Data.Map that is)
21:29:20 <dmj`> jle`: I did some naughty, naughty things with ViewPatterns this AoC
21:29:45 <shapr> I wanna see that
21:29:50 <shapr> but first I should sleep
21:31:35 <Projectbarks> @dmk`I used the bentley ottmann algorithm
21:31:35 <lambdabot> Unknown command, try @list
21:31:41 <Projectbarks> @dmj`
21:31:41 <lambdabot> Unknown command, try @list
21:31:51 <dmj`> shapr: https://github.com/dmjio/advent-of-code-2019/blob/master/4/4.hs#L30
21:32:06 <dmj`> Projectbarks: I used the dmj view pattern abuser algorithm
21:32:08 <shapr> er, wow
21:32:20 <shapr> dmj`: that's impressive
21:32:23 <dmj`> got the answer real quick lol
21:32:27 <dmj`> did that last year
21:32:58 <shapr> I just did (show i == sort $ show i)
21:33:25 <dmj`> oh wow
21:33:28 <dmj`> that's even dirtier
21:33:39 <shapr> decades of Python experience :-/
21:34:30 <Projectbarks> dmj` how fast is your #3 
21:34:56 <dmj`> Projectbarks: not that good, like 25 mins
21:35:06 <dmj`> Projectbarks: I screwed up the (>=), should have been (<=)
21:35:15 <Projectbarks> 😂 patient 
21:36:14 <dmj`> shapr: your idea is brilliant
21:36:49 <shapr> heh, you sure about that?
21:39:38 <shapr> dmj`: https://github.com/shapr/aoc2019/blob/master/Main4.hs
21:43:18 <dmj`> so simple, so beautiful
21:43:23 <dmj`> and you probably got it right so fast
21:46:06 <nshepperd> shapr: ^5
21:46:09 * hackage hw-ip 2.4.0.1 - Library for manipulating IP addresses and CIDR blocks  https://hackage.haskell.org/package/hw-ip-2.4.0.1 (haskellworks)
21:46:17 <nshepperd> x == sort x is a good trick :)
21:47:13 <dmj`> shapr: ++
21:48:21 <shapr> :-D
21:51:56 <dmj`> shapr: I thought i was smart with this
21:51:59 <dmj`> @def increasing' xs = and $ zipWith (<=) xs (tail xs)
21:52:01 <lambdabot>  Defined.
21:52:10 <dmj`> > increasing' [1,2,3]
21:52:13 <lambdabot>  True
21:52:39 <dmj`> but x == sort x is next level
21:57:02 <dmj`> the simple tricks like that, pure gold
21:59:17 <pounce> what is the list comprehension "predicate" sugar look like in do notation
21:59:58 <jusss> where I can find the type Cont's implement for Monad? bind I mean
22:00:26 <jusss> as the instance of Monad, Cont's bind definition
22:00:51 <shapr> dmj`: I like your zipWith (<=) better
22:01:27 <dmj`> pounce: do { x <- xs; pure x }
22:01:48 <jle`> pounce: i think of it as 'guard'
22:02:19 <jle`> jusss: look in 'transformers'
22:03:17 <jusss> jle`: why it shouldn't be http://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Cont.html
22:03:29 <jle`> jusss: mtl doesn't have any monad transformers
22:03:35 <jle`> it only has typeclasses
22:03:40 <jle`> 'monad typeclass library' :)
22:04:04 <jusss> m >>= k  = ContT $ \ c -> runContT m (\ x -> runContT (k x) c)
22:04:23 <pounce> dmj`, jle` i mean the boolean ones
22:04:41 <jle`> [ blah | x <- blahblah, x == 1 ]
22:04:42 <jusss> oh, the name, mtl is not short for monad transformers libraries?
22:04:50 <jle`> do x <- blahblah; guard (x == 1); pure blah
22:05:04 <pounce> oh, hm
22:05:04 <jle`> jusss: that's a common misconception
22:05:08 <jle`> it's an unfortunate coincidence
22:05:28 <jle`> jusss: the monad transformers libraries is 'transformers'
22:05:34 <jle`> and mtl is the monad typeclass library
22:06:25 <jusss> but Cont is a monad, why it's defined in 'transformers'? not mtl
22:07:06 <heatsink> Cont is defined in terms of ContT
22:07:41 <heatsink> It's the Cont transformer applied to the Identity monad
22:08:12 <jusss> aha, type Cont r = ContT r Identity
22:09:08 <jle`> jusss: mtl only has typeclasses
22:09:35 <jusss> where do you learn about Cont Monad? 
22:10:00 <jusss> the wiki page is not easy to make me understand it...
22:10:09 <jle`> i never really learned about it tbh
22:10:49 <jusss> jle`: why? you're not interesting to continuation?
22:10:57 <jusss> interested
22:11:09 <heatsink> I thought Cont was hard to understand.  It's useful to learn continuation-passing style first
22:11:51 <jusss> heatsink: Cont as a Monad, it's related to continuation?
22:12:05 <heatsink> yes, it's an abbreviation of continuation
22:13:19 <jusss> continuation, it's something I still don't understand 
22:13:52 <jusss> I know how to use it with call/cc in scheme, but I don't understand it when it's in haskell
22:14:26 <jusss> it seems I need to know how to implement callCC so I can know it
22:15:11 <jusss> and no one talk about it here, so I'm stucked...
22:15:13 <heatsink> It's basically the same, but with types
22:17:56 <heatsink> So let's look at continuation-passing style.  Suppose I have the program
22:18:12 <heatsink> printNegative xs = case find (< 0) xs of { Just n -> print n; Nothing -> putStrLn "Nothing" }
22:19:49 <heatsink> Actually, let's just look at find
22:20:17 <heatsink> find f (x:xs) = if f x then Just x else find f xs; find f [] = Nothing
22:20:59 <heatsink> With continuation-passing style, find wouldn't return to its caller.  Instead, its caller would tell find what to do next.
22:21:20 <heatsink> find f (x:xs) cont = if f x then cont (Just x) else find f xs cont; find f [] = cont Nothing
22:22:55 <heatsink> Do you see how I converted find to continuation-passing style/
22:22:56 <heatsink> ?
22:25:22 <jusss> heatsink: yeah
22:25:30 <jusss> heatsink: it never be back
22:27:17 <heatsink> In direct style, I could define foo = print (find (<0) [1,-2]).  Can you convert that to continuation-passing style?
22:28:53 <jusss> heatsink: why it needs `print'?
22:29:18 <heatsink> I want to find something and then print the result
22:29:28 <jusss> foo would be an IO ()
22:29:38 <heatsink> right
22:30:13 <jusss> foo = find (<0) [1,-2] print
22:30:31 <heatsink> Almost.  foo should take a continuation also.
22:31:56 <jusss> foo x = x $ find (<0) [1,-2]
22:32:17 <jusss> no
22:32:41 <jusss> foo now is a continuation, but x is a function
22:32:50 <jusss> I don't think foo should take a continuation
22:32:59 <jusss> what I'm missing
22:33:36 <heatsink> Consider how you can call foo without continuation-passing.  You could write main = do { foo; putStrLn "Done" }
22:34:07 <heatsink> With continuation-passing, you need to pass (putStrLn "Done") to foo, as a continuation
22:35:00 <heatsink> Then foo needs to run the continuation at a suitable time
22:38:29 <jusss> heatsink: it seems I misunderstand the concept about continuation
22:39:17 <jusss> heatsink: I think continuation is a funciton f, which take another function g as its parameter, call g in f, and g never go back in f
22:39:28 <heatsink> That's right
22:40:16 <heatsink> Without continuation-passing, it was foo = print (find (<0) [1, -2])
22:40:20 <jusss> heatsink: so foo x = x $ find (<0) [1,-2],  foo is a continuation now, right?
22:40:44 <heatsink> With continuation-passing, it is foo cont = find (<0) [1, -2] (\x -> print x cont)
22:41:12 <jusss> aha
22:41:33 <heatsink> This means, call "find"; tell "find" that when it's done, it should call "print", and tell print that when it's done, it should call "cont"
22:41:38 <jusss> heatsink: wait, print x cont is ok?
22:41:58 <heatsink> I'm assuming that this "print" was also converted to continuation-passing style 
22:42:00 <jusss> it should be cont $ print x?
22:42:49 <heatsink> So this example is different from the standard library function "print"
22:43:35 <jusss> heatsink: ok
22:44:50 <heatsink> This was an example of writing in continuation-passing style
22:45:24 <heatsink> To make a continuation monad, you would need to write return and >>= for continuation-passing style
22:45:56 <jusss> heatsink: inC `bind` fn = \out -> inC (\inCval -> (fn inCval) out)  from https://jsdw.me/posts/haskell-cont-monad/
22:46:08 <jusss> this bind definition really make me confused
22:46:31 <nshepperd> aha! i have used a type checker plugin to work around the rule that typeclass instances can't have implicit parameter contexts. that that ghc! you can't stop me!
22:46:37 <heatsink> Let me change the formatting of bind
22:47:02 <heatsink> bind fn inC out = inC (\inCval -> fn inCval)
22:47:21 <heatsink> bind fn inC out = inC (\inCval -> fn inCval out)
22:48:46 <jusss> heatsink: inC is a continuation, so it takes a function right/
22:49:34 <jusss> (\inCval -> fn inCval out) will do something within inC
22:49:44 <heatsink> inC and fn are functions that are in continuation-passing style.  Their last parameters are continuations.
22:50:20 <jusss> so inC is not a continuation?
22:50:32 <heatsink> Right, it is not a continuation
22:50:39 <jusss> oh, god
22:51:12 <jusss> I thought it was a continuation, and a continuation bind a function to get a new continuation
22:52:14 <jusss> heatsink: so here inC and fn both are functions, they take continuation, and `out' is a continuation?
22:52:15 <heatsink> The call `inC cont` means to call inC and tell it to call cont when it's finished.
22:52:21 <heatsink> right
22:53:23 <heatsink> So, this will call inC.  When it's finished, it will call that lambda.
22:53:41 <heatsink> That lambda will call fn.  When fn is finished, it will call out.
22:55:41 <jusss> heatsink: but that lambda is a continuation?
22:55:54 <heatsink> yes
22:56:28 <jusss> heatsink: I'm a little fuzzy now
22:57:49 <jusss> heatsink: but based on the monad, if inC and fn both are not continuations, so it won't return a continuation, but it passing the continuations?
22:59:45 <jusss> inC is not a continuation, and inC >>= fn should have the same type with inC
23:00:13 <jusss> inC and inC >>= fn both need a continuation,
23:00:39 <jusss> what's the context now?
23:00:45 <jusss> what it's passing?
23:01:44 <heatsink> Cont values are not continuations.  They are continuation-passing functions.  The continuation-passing part is hidden inside the monad.
23:02:19 <jusss> inC is a Cont values right?
23:02:52 <doublex> @unmtl Cont r a
23:02:52 <lambdabot> (a -> r) -> r
23:03:12 <heatsink> right
23:04:04 <jusss> but a->r is continuation?
23:04:10 <jusss> no
23:04:21 <heatsink> The example that you showed is teaching about Cont.  So it is not actually using the Cont type, but it's basically doing the same thing as Cont.
23:04:39 <heatsink> (a -> r) is the type of a continuation
23:04:47 <jusss> aha
23:05:42 <doublex> if a direct-style function produces an `a`, a continuation-passing-style function instead passes an `a` to its continuation
23:06:15 <doublex> the Cont monad allows you to thread together CPS functions with >>=
23:11:23 <jusss> doublex: it means in the continuation-passing-style function, the function take a continuation, and pass its within value to its continuation?
23:12:02 <jusss> err. now I'm confused about continuation-passing-style function and continuation...
23:13:13 <haskeldjiq> guys
23:13:16 <haskeldjiq> https://pastebin.com/MpW2096b
23:13:20 <haskeldjiq> is this possible?
23:18:09 <nosewings> Do you want, e.g., getById :: [entityId] -> m [Maybe entity]
23:18:44 <maralorn> In the definition of MonadReader r m | m -> r, what does that "| m -> r" do? What language feature is that?
23:19:00 <nosewings> "Functional dependency"
23:19:16 <nosewings> It says that r is completely determined by m
23:19:45 <maralorn> Is it? How?
23:20:23 <jle`> maralorn: it means that for all legal instance, m must determine r
23:21:29 <haskeldjiq> nosewings: I can't really imagine how the function signatures would look like
23:21:35 <jle`> so instance MonadReader Int MyType is allowed, but not if you also add another instance MonadReader Bool MyType
23:21:50 <haskeldjiq> nosewings: but there should be some sort of a way to express a Store that is able to hold multiple types of entities
23:21:53 <jle`> maralorn: but not allowed is MonadReader a OtherType
23:22:31 <Axman6> nosewings: it prevents you having (MonadReader a m, MonadReader b m) wher a is not the same as b.
23:23:40 <maralorn> Aah
23:23:47 <maralorn> That’s sad.
23:23:58 <maralorn> Because that’s exactly what I need right now.
23:24:17 <nosewings> haskeldjiq: by "multiple types" do you actually mean _multiple types_, as in Haskell types?
23:24:54 <haskeldjiq> nosewings: exactly
23:25:45 <maralorn> I use a MonadReader Env m for my whole program. But in on Module I need a MonadReader (Env, LocalEnv) m, but I still want all functions defined on MonadReader Env m to work there.
23:26:24 <Axman6> There's a nice lensy way to deal with this. use classLenses, and then write things in terms of MonadReader r m, HasEnv r) => m a
23:27:01 <Axman6> classyLenses*
23:27:08 <nosewings> haskeldjiq: Are you familiar with how typeclasses work? They're not like OOP classes.
23:27:17 <Axman6> (uh, makeClassy, but the technique is usually called classy lenses)
23:27:46 <maralorn> > Classy Lenses - The world of KPOP in our eyes.
23:27:49 <lambdabot>  <hint>:1:27: error: parse error on input ‘of’
23:30:17 <maralorn> Axman6: So the idea is to have a "AsA r" typeclass on my environment?
23:30:33 <Axman6> HasA, but yes
23:31:02 <Axman6> (AsA is classy prisms, which i sort of the dual, losely)
23:31:44 <maralorn> Uh, I just invented that name.^^
23:32:25 <maralorn> I could do just do that myself without lenses, could I?
23:33:08 <Axman6> Id you like, you could jaue have class HasEnv a where getEnv :: a -> Env; instance HasEnv Env where getEnv = id
23:33:50 <Axman6> then you just use foo :: (MonadReader r m, HasEnv r) => m a; foo = do env <- asks getEnv ...
23:42:34 <maralorn> I just always read this recommendation "Only go lenses if you are ready to go all in."
23:45:01 <dsal> maralorn: you can totally lens a little.
23:46:13 <dsal> > [(1,2),(3,4)] & ix 1 . _2 .~ 5
23:46:16 <lambdabot>  [(1,2),(3,5)]
23:52:36 <Axman6> lens is one of those things you can start small and go deeper. you don't need lens for anything, but it is incredibly convenient
23:53:41 <maralorn> Okay, I am trying to do it with makeClassy, but my type AppState has a type parameter ti. So I get "Illegal instance declaration for ‘HasAppState (AppState ti) ti’"
23:54:08 <maralorn> That looks like the TH does not generate the code I want.
