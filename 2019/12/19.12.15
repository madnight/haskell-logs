00:17:10 <anurag> hello
01:37:18 <cheater> MarcelineVQ: thanks, i'll look at optparse-applicative
01:59:14 <cheater> why is throwIO a good idea? throwIO e `seq` x evaluates to x. why is this desirable? the error e has happened, so why do i want to squash it and instead go on to evaluate x like nothing had happened?
02:00:19 <Athas> cheater: you should not try to use throwIO outside of the IO monad, and 'seq' is a pure function.
02:00:34 <nshepperd2> The same reason you want print 3 `seq` x to not print anything
02:00:36 <Athas> throwIO is a good idea only when working in the IO monad.
02:01:13 <cheater> why is print 3 `seq` x not supposed to print anything?
02:01:21 <Athas> There is no very good way to report errors in pure code, because the point of pure code is to have no effects, and triggering an error is an effect.  'error' is the best we have.
02:01:57 <cheater> "The value of seq a b is bottom if a is bottom, and otherwise equal to b. In other words, it evaluates the first argument a to weak head normal form (WHNF). seq is usually introduced to improve performance by avoiding unneeded laziness."
02:02:01 <cheater> hm
02:02:39 <Athas> Neither 'print 3' nor 'throwIO e' are bottom.
02:02:48 <Athas> They both produce perfectly well-formed IO actions.
02:43:00 <cheater> Athas: thank you
02:43:05 <cheater> also nshepperd2 
02:45:05 <dminuoso> cheater: Remember that IO actions can be seen as as *lists of assembly instructions*. 
02:45:41 <dminuoso> cheater: `throwIO e` evaluates to a list of instructions. A list of instructions is different from what it produces
02:46:03 <dminuoso> It's sort of how evaluating `Recipe Cake` will *not* give you a cake.
02:51:29 <cheater> does errorIO msg also have the same property as fail (throwIO msg)? https://hackage.haskell.org/package/extra-1.6.18/docs/src/Control.Exception.Extra.html#errorIO
02:51:56 <cheater> dminuoso: right
02:53:10 <dminuoso> cheater: Yes. 
02:53:39 <dminuoso> cheater: You can test this:
02:54:04 <dminuoso> % errorIO = evaluate . error
02:54:05 <yahb> dminuoso: 
02:54:06 <phadej> remember, fail /= error
02:54:12 <dminuoso> % errorIO "foo" `seq` ()
02:54:13 <yahb> dminuoso: ()
02:55:31 <jle`> fail msg for IO is essentially throwIO (UserError msg) or something I thnk
02:55:50 <cheater> phadej: i know they're not the same function, not sure what the difference is in this usage
02:56:09 <dminuoso> cheater: `fail` is a method of MonadFail
02:56:15 <cheater> basically i want fail (throwIO msg) which doesn't prepend "user error: " to my error string.
02:56:20 <dminuoso> cheater: So what it does, depends on the instance.
02:56:31 <cheater> aha
02:56:36 <cheater> i want this only in IO though
02:56:42 <cheater> so no accidental monad instance
02:56:53 <cheater> i guess throwIO forces it into IO
02:57:16 <jle`> cheater: if you want that sort of behavior, you can create your own custom error type with a custom Show instance
02:57:22 <cheater> 11:53 <  dminuoso > % errorIO "foo" `seq` ()
02:57:22 <cheater> 11:53 <      yahb > dminuoso: ()
02:57:23 <jle`> and you can throwIO that
02:57:24 <cheater> thanks
02:57:29 <cheater> that demonstrated it well
02:58:14 <cheater> jle`: jesus.. no thanks :)
02:58:16 <dminuoso> cheater: If you want a comprehensive detail how exceptions can be structured in hierarchial ways similar to what you could do in say Java, put `An Extensible Dynamically-Typed Hierarchy of Exceptions, by Simon Marlow` on your reading list.
02:58:24 <cheater> i'll just use errorIO, seems to be doing what i want
02:58:40 <phadej> :t error
02:58:42 <lambdabot> [Char] -> a
02:58:43 <phadej> :t fail
02:58:45 <lambdabot> Monad m => String -> m a
02:58:48 <dminuoso> cheater: It's usually better to construct your own exceptions, and throw these.
02:58:50 <phadej> very different types
02:59:01 <phadej> it's IMHO worth trying to understand the difference
02:59:07 <jle`> cheater: it's not too tricy, just basically `data MyError = MyCustomError`
02:59:17 <dminuoso> phadej: Mmm, no MFP there?
02:59:18 <jle`> cheater: and then instance Show MyError where show MyCustomError = "this is the error"`
02:59:20 <dminuoso> % :t fail
02:59:20 <yahb> dminuoso: Monad m => String -> m a
02:59:22 <dminuoso> Huh
02:59:26 <jle`> then you can `throwIO MyCustomError` and get that message
02:59:45 <jle`> % data MyError = MyCustomError deriving Typeable
02:59:45 <yahb> jle`: 
02:59:53 <dminuoso> cheater: The benefit of creating your own exceptions is that you can *catch* them in sensible ways.
02:59:58 <jle`> % instance Show MyError where show MyCustomError = "this is the error"
02:59:58 <yahb> jle`: 
03:00:02 <phadej> % :t Control.Monad.Fail.fail
03:00:03 <yahb> phadej: Control.Monad.Fail.MonadFail m => String -> m a
03:00:08 <jle`> % instance Exception MyError
03:00:08 <yahb> jle`: 
03:00:15 <jle`> % throwIO MyCustomError
03:00:15 <yahb> jle`: *** Exception: this is the error
03:00:20 <phadej> I guess, yahb doesn't run 8.8.1
03:00:56 <jle`> ^ cheater 
03:01:16 <maralorn> I just read something about blocking in async in Rust or node.js. It's an easy trap to fall into. Is Haskell affected by this? could I hang my program by calling more forkIOs (which then e.g. wait for stdin) then the RTS uses threads?
03:01:34 <dminuoso> maralorn: Try? :)
03:01:58 <maralorn> ^^ Normally asking here is the much faster way to insight.
03:02:05 <cheater> jle`: no code is better than any code. why would i do this rather than use errorIO?
03:02:11 <dminuoso> maralorn: replicateM 1000 (forkIO getLine) 
03:02:21 <jle`> cheater: it's nicer if you want to handle errors :)
03:02:33 <dminuoso> maralorn: There you have 1000 threads trying to read from stdin.
03:02:41 <jle`> with errorIO you don't really have any nice capabilities for handling errors hbased on what sort of error it is
03:02:49 <jle`> exceptions, i mean, not errors
03:03:06 <jle`> cheater: it's basically the same thing as saying "why would I use Int instead of just "4" :: String"
03:03:09 <cheater> right, you're talking about structured exceptions vs string exceptions
03:03:14 <jle`> mhm
03:03:25 <jle`> or data Shape = Circle | Square instead of "Circle"/"Square" strings
03:03:26 <cheater> i don't need them here though. but it's a good point. thanks
03:03:27 <dminuoso> maralorn: Can you point me to the article/text you were reading?
03:04:05 <jle`> cheater: but also if errorIO doesn't get what you need in terms of formatting the resulting user-facing error string, then this can be a nice way too
03:04:21 <jle`> for example you might want a common prefix like fail "someprefix: this is the error"
03:04:34 <cheater> maralorn is talking about cooperative multitasking where a single callback takes a long time therefore blocking the event loop.
03:04:40 <jle`> and if you make a custom type like data MyError = TheError String, you can incorporate your custom formatter in the Show instance
03:04:49 <jle`> instead of directly inlining "someprefix:" every time you call errorIO
03:05:02 <jle`> so in that sense you get some code re-use
03:05:10 <cheater> as far as i understand this doesn't happen in haskell because functions are pure and can be hung up any time. meantime io actions happen through select or the like, and are therefore non-blocking.
03:05:22 <cheater> you could block yourself if you call out to C code using the FFI.
03:05:25 <dminuoso> cheater: It's not really a Haskell topic, its about the implementation.
03:05:30 <maralorn> dminuoso: I found it in Rust weekly. I doesn‘t mention node.js but it’s exactly the same problem there. https://stjepang.github.io/2019/12/04/blocking-inside-async-code.html
03:05:47 <cheater> yes and no. node.js does that and it's "a node.js topic"
03:05:52 <maralorn> cheater: Yeah
03:06:00 <dminuoso> maralorn: GHC Haskell uses green threads. We give you the *feeling* of doing blocking IO most of the time, while actually using select/epoll/etc.. behind the scenes.
03:06:03 <cheater> so since haskell (ghc) doesn't do that it's also a "haskell topic"
03:06:27 <cheater> it's not really about blocking vs non-blocking io
03:06:35 <cheater> node.js does non-blocking IO too
03:06:41 <cheater> it's about having a long callback
03:07:10 <cheater> in node you have to structure your code into short functions, because the only time a task switch can be done is when such a function is over (returns)
03:07:37 <cheater> so that's why if inside such a function you do something that's very cpu intensive and takes 5 seconds, your whole application, all its "threads", hang for 5 seconds.
03:08:00 <cheater> that's the issue maralorn was talking about. it doesn't exist in haskell even when green threads are competing for the same cpu.
03:08:26 <cheater> you can have contention due to data dependencies. but that's a bug you'd have to program into your code yourself.
03:09:03 <dminuoso> Well such issues exist all across Linux applications still.
03:09:36 <dminuoso> Most linux distributions default with a mixed cooperative/preemptive multitasking model that's usually way more cooperative than preemptive
03:09:45 <cheater> that's part of the assumed context and it's not the issue maralorn was asking about
03:09:57 <dminuoso> But that's a Linux topic rather.
03:10:10 <cheater> maralorn was talking about specifically the issue that nodejs brings to the table by virtue of its construction
03:10:22 <cheater> jle`: thanks!
03:14:54 <maralorn> Now I am kinda confused on what I was talking about.^^
03:15:34 <maralorn> I think for me a computation intensive calculation which does not yield to the event loop is "blocking".
03:17:43 <maralorn> My concrete question was, can you get in trouble when you don‘t "yield to the event loop" often enough in Haskell. My take away is: No, because that‘s not how the green threads work.
03:18:21 <seishun> is there a shorter or faster way to do something like `concatMap f $ Map.toList m`?
03:18:34 <maralorn> Or phrased differently: The runtime can "make the thread yield" at nearly every point, so no need to worry.
03:19:14 <maralorn> seishun: f :: a -> [a]?
03:19:19 <dminuoso> seishun: foldMap on the map? 
03:19:56 <seishun> maralorn: f :: a -> [Maybe a] but I might rethink that part
03:20:19 <phadej> dminuoso: foldMapWithKey
03:20:30 <dminuoso> phadej: Ah right.
03:20:38 <dminuoso> Though I think the version with concatMap might perform better
03:21:10 <phadej> maybe, foldrWithKey does exist too
03:21:21 <phadej> but isn't shorter anymore
03:22:20 <Ariakenom> maralorn: there is some special cases where you can make a loop that doesnt yield
03:23:00 <seishun> the only reason I'm using Maybe is to signal that a certain value has been found and to stop the search, which might not be the best way
03:24:48 <Ariakenom> maralorn: -fno-omit-yields removes those cases https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-optimisation.html#ghc-flag--fomit-yields
03:28:15 <Ariakenom> If anyone wants to fix the documantation for "default:" in that link I would be thankful
03:30:08 <evelyn> seishun: Arguably Either might be nicer - A 'Right' value vs incorrect 'Left' values
03:30:51 <seishun> evelyn: but I don't care about the value of the correct value, just whether it's present
03:30:56 <cheater> with stack, how can i run ghci in the Main module of an executable?
03:31:05 <jollygood2> stack ghci
03:31:49 <jollygood2> stack.yaml and cabal have to be in CWD
03:40:00 <seishun> evelyn: now that I've read part 2 I see that I should have used Either
03:42:55 <dminuoso> Ariakenom: Isn't that on by default already?
03:45:56 <Ariakenom> dminuoso: I can't tell. The default text is too bad!
03:46:29 <cheater> maralorn: no, you can't.
03:46:37 <Ariakenom> dminuoso: I think I asked in #ghc a month ago or so. If I recall correctly it wasn't
03:46:44 <cheater> maralorn: as said before: cheater > as far as i understand this doesn't happen in haskell because functions are pure and can be hung up any time. 
03:47:23 <cheater> Ariakenom provides an interesting exception to the rule
03:47:46 <cheater> jollygood2: it doesn't let me specify the executable. i have two.
03:47:54 <Ariakenom> purity doesn't seem relevant? Although I jumped into the middle of the discussion
03:48:00 <dminuoso> Ariakenom: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-optimisation.html
03:48:06 <dminuoso> Ariakenom: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-optimisation.html#ghc-flag--fomit-yields
03:48:12 <cheater> oh, it makes a dialog
03:48:13 <cheater> thanks
03:48:19 <dminuoso> Default: "yield points enabled"
03:48:21 <jollygood2> cheater IIRC it should ask you to pick one
03:48:27 <cheater> Ariakenom: it does, because purity is exactly what lets you force code to yield
03:48:28 <Ariakenom> dminuoso: that is literally the link I sent
03:48:31 <cheater> yes jollygood2 it does thanks
03:48:37 <jollygood2> np
03:48:49 <dminuoso> Ariakenom: Haha. That's a documentation bug then.
03:49:15 <dminuoso> Perhaps they meant to write "Yield point omission enabled" ?
03:49:45 <Ariakenom> ¯\_(ツ)_/¯
03:50:24 <Ariakenom> cheater: I disagree but have to go.
03:50:51 <cheater> ok
03:50:57 <cheater> have a nice day
03:51:12 <dminuoso> 12:48:05        cheater | Ariakenom: it does, because purity is exactly what lets you force code to yield
03:51:14 <dminuoso> Not really.
03:51:39 <dminuoso> I agree with Ariakenom in disagreeing with you.
04:14:24 <jollygood2> @hoogle [(Maybe a), b)] -> [(a, b)]
04:14:25 <lambdabot> package base
04:14:25 <lambdabot> package bytestring
04:14:25 <lambdabot> package containers
04:14:45 <jollygood2> @hoogle [(Maybe a), b)] -> [Maybe (a, b)]
04:14:46 <lambdabot> package base
04:14:46 <lambdabot> package bytestring
04:14:46 <lambdabot> package containers
04:14:59 <jollygood2> @hoogle Char -> Char
04:15:01 <lambdabot> Data.Char toUpper :: Char -> Char
04:15:01 <lambdabot> Data.Char toLower :: Char -> Char
04:15:01 <lambdabot> Data.Char toTitle :: Char -> Char
04:15:41 <jollygood2> @hoogle [(Maybe a, b)] -> [Maybe (a, b)]
04:15:43 <lambdabot> No results found
04:17:05 * nil is finally grokking lazy IO.
04:31:22 <maralorn> cheater: I am not sure which message you were refering to on "you can‘t".
04:34:24 <maralorn> But I also think that you can (in principle) yield in an impure calculation at nearly anytime. Of course if you're computation is pure you don‘t care about that at all. If you‘re computation is impure you can get race conditions if it happens.
04:35:21 <maralorn> But I think in most cases impure programs will be fine when they are interrupted. As is the practice on all our computers all the time …
04:53:59 <nil> what's the easiest way to force complete evaluation of a lazy list in IO, without using things like deepseq? what i'm doing now is `evaluate (length list)`, but that seems ugly
04:54:58 <Rembane> nil: Why do you want to force evaluation? 
04:55:06 <jollygood2> that won't force complete evaluation of a list
04:55:39 <Rembane> jollygood2: Will it only evaluate enough to get the length? 
04:55:43 <nil> jollygood2: true, i only need the list's structure to be evaluated
04:55:53 <nil> (it's a list of Integers)
04:56:26 <jollygood2> Rembane, no need to evaluate elements to know how many of them there are. but it appears that's what nil wants
04:56:32 <nil> Rembane: because i want the effects of evaluating it to happen
04:56:50 <Rembane> jollygood2: Indeed. 
04:57:07 <Rembane> nil: mapM_ is quite good for that imo
04:57:47 <nil> i don't actually need to run an action for each element of the list
04:58:19 <amalloy> what effects? you have an [Integer] where each item was created with unsafePerformIO or something?
04:59:13 <nil> unsafeInterleaveIO
04:59:33 <nil> (i know, it's terrible practice, i'm doing this to understand how lazy IO works)
05:01:27 <phadej> you can just write `forceSpine [] = (); forceSpine (_:xs) = forceSpine xs` and evalaute that
05:01:37 <phadej> there's no nicer function, AFAIK
05:01:47 <nil> yeah, or fold[rl] (const id) ()
05:02:13 <amalloy> traverse_ evaluate xs?
05:02:18 <phadej> I'm not 100% sure about foldr, as fusion/rewrites might make some magic to that
05:02:31 <phadej> amalloy: that one would evaluate elaments
05:03:16 <amalloy> i don't think nil has said that's a problem, only that evaluating the spine would be sufficient
05:04:15 <nil> yeah, both are fine
05:06:02 <phadej> well, than deepseq is just as fine
05:06:06 <phadej> and undrstandable
05:06:11 <phadej> evaluate . force $ xs
05:10:45 <ahri> I was looking for something like `class Serializable a b where { serialize :: a -> b; deserialize :: b -> a }` in `base` - does this exist or would I have to pull in a library? My hoogle skills seem to be lacking today
05:11:12 <phadej> check binary or serialise
05:11:25 <phadej> or aeson, if JSON is your thing
05:11:37 <merijn> ahri: It doesn't exist in base and the real question is "what do you want to serialise/deserialise into what?"
05:11:41 <phadej> (binary is bundled wwith GHC)
05:12:36 <ahri> merijn: ok, thanks. why is that the question? `a` and `b` answer that question where I choose to ask it
05:13:31 <razzy> hi, i am confused about how ghci load modules. it seems to search not only subdirectories, but even some upstream directories
05:13:54 <ahri> the generic concept of serialization is all I want to capture right now :)
05:14:14 <merijn> ahri: A typeclass that allows arbitrary to arbitrary type serialisations is extremely dangerous at best and nonsensical at worst, so you won't find it anywhere in any well-established library I'm aware off
05:15:00 <merijn> There are several somewhat related classes, but which is related depends on your exact goal
05:15:00 <ahri> phadej: I'll have a look at `binary`, thanks
05:15:13 <merijn> binary only does "ByteString -> a" and "a -> ByteString"
05:17:03 <ahri> given that `a` and `b` would have to line up to pass compilation I'm not clear on the danger - though that in itself sounds fun
05:18:45 <ahri> surely the danger (and the sense) lies in the instance, not the class
05:20:05 <phadej> you really want some concrete target serialisation type; you probably want some properties to be true for `b`, e.g. that you can read/write it to/from disk&write
05:20:18 <phadej> ByteString is a good option
05:21:01 <merijn> I cannot think of any real use case for "arbitrary conversions", it seems near impossible to write generic/sensible code using that notion. You'll almost always want to either 1) convert from a known input type or 2) to a known output type
05:21:34 <ahri> well, I wrote a simple event database, so in that case I agree; `Serializable a ByteString` would be what I'd go for (although of course Haskell requires me to reverse my preferred a, b order!)
05:23:06 <ahri> I suppose I like the simplicity of capturing the idea, and am happy enough to add extra constraints in the cases where a particular form is required
05:24:26 <benmachine> is there anyone around who is pedantic about the precise meanings of things like "non-strict" who can talk to me about in what sense (say) map f is non-strict? (despite map f _|_ = _|_)
05:25:38 <benmachine> it's clearly interesting that map f (_|_ : _|_) is not _|_, but I don't know how to fit that into the definition I know of strict semantics
05:25:42 <merijn> benmachine: non-strict means that GHC is not required to be lazy
05:25:51 <phadej> ahri: trust us, you don't want Serializable a b like class, it's not a very good idea
05:25:58 <merijn> benmachine: The thing is that "lazy" would specify a specific evaluation order
05:26:09 <benmachine> merijn: I know, that's not exactly the question I'm asking
05:26:16 <phadej> "everyone" thingks at some point that class Convert a b where convert :: a -> b would be great; but it's not
05:26:18 <merijn> benmachine: "non-strict" on the other hand just means "things that only work in lazy settings *should* work"
05:26:50 <merijn> benmachine: The reason *why* it underspecifies is that, for example, requiring laziness would mean GHC wouldn't be allowed to make Int computations strict (even if that's faster)
05:27:01 <benmachine> merijn: the question I'm asking is more about the right terminology to use for functions that are strict in that they preserve undefineds, but clearly are non-strict in some sense
05:27:09 <merijn> benmachine: So non-strict means "you *can* make things strict, as long as you guarantee the lazy case works"
05:27:24 <benmachine> merijn: stop explaining that for a sec :P
05:27:44 <merijn> benmachine: hmm, I'm not sure what you mean by that?
05:27:51 <ahri> phadej: can you elaborate a little more on why it's not? Before I just trust you, that is!
05:28:14 <benmachine> merijn: here's what I mean: semantically a function is strict if it preserves _|_, right?
05:28:30 <phadej> ahri: it's simply doesn't work at large, isomorphisms aren't unique
05:28:40 <phadej> instance Convert a b where convert = not
05:28:42 <benmachine> ahri: I'm not party to that whole conversation, but partially because there's often many conversions between a and b
05:28:49 <phadej> is valid one, but "not what would you expect"
05:28:55 <merijn> benmachine: Well, first of strictness of fnctions is related to specific arguments
05:29:09 <benmachine> merijn: all functions have one argument, so that's not a problem :P
05:29:15 <merijn> benmachine: So, for example, we'd say that "const" is lazy (or non-strict if you prefer) in it's second argument
05:29:36 <phadej> it would be quite arbitrary class, where you have to know what each individual instance does, i.e. you don't get any benefit from having that type-class, vs. using named functions
05:30:01 <merijn> benmachine: Anyway, generally we talk about strictness "up to WHNF"
05:30:17 <merijn> benmachine: So even "strict" functions are only "strict up to WHNF"
05:30:28 <merijn> benmachine: Which is exactly the 2nd case of your map example
05:30:29 <ahri> phadej, benmachine: that makes sense, thank you both :)
05:30:35 <benmachine> merijn: I see, so map toUpper is strict up to WHNF but not further than that
05:30:44 <merijn> benmachine: Since "_|_ : _|_" is in WHNF
05:30:51 <benmachine> wait
05:30:59 <benmachine> right, yes
05:32:16 <merijn> benmachine: So map is only strict in the spine, but toUpper is strict in each element. So a non _|_ list will produce a valid list and toUpper will preserve any _|_ in that list
05:32:45 <yasar> Can anyone spot my error in spread function? https://gist.github.com/yasar11732/deefb541bc005ca50d6b67f9c0a86096#file-ch04-hs-L51
05:33:35 <ahri> I wonder though, isn't this problematic for `Binary a` since `a` can likely be represented in a multitude of ways in binary form (LE/BE spring to mind)? So where's the line between `Convert a b` having too many instances of the same `a` being converted to the same `b`, versus many ways to convert the same `a` to `ByteString` ?
05:34:14 <ahri> (and is this part of a larger discussion around lawless typeclasses?)
05:34:26 <nil> yasar: i'd say you want (++) instead of (:), but it's hard to say without knowing what the function should do
05:34:42 <benmachine> merijn: so I think my terminological question is being answered as something like: in addition to saying "strict in the second argument" we can say something like "strict in the spine of the list" and that means something about which _|_s are preserved and which are (potentially) not
05:34:57 <benmachine> also strictness for higher-order functions is a bit of a mess anyway
05:35:00 <merijn> ahri: TBH I *do* think it's problematic with Binary and I *highly* recommend *not* using it's typeclass
05:35:01 <infinisil> ahri: I'm for not using type classes to do things like encoding, but rather functions
05:35:11 <merijn> I only use explicit Get/Put when using binary
05:35:25 <merijn> benmachine: Right
05:35:35 <yasar> nil, it take a list of things (x), and a list of list of things (y), it will append for element of x into first element of y, second element of x into second element of y etc.
05:35:56 <merijn> benmachine: You may also be interested in a rather famous paper called "Fast and Loose Reasoning is Morally Correct"
05:36:01 <phadej> ahri: Binary is about "some serialisation", general Convert is.. general. For Binary it's ok to choose just some representation (as long as it roundtrips), for convert it's very difficult to choose "canonical" convert; at least in general case
05:36:08 <nil> yasar: example input and output?
05:36:13 <benmachine> ahri: my take on this is that it's partly about how easy it is for the person reading your code to figure out what behaviour to expect -- so the more the class is clear about what the correct behaviour should be the better
05:36:18 <nil> also, your function is missing base cases
05:36:22 <yasar> "yasar" [[]]
05:36:35 <merijn> benmachine: Which basically argues "it's mostly correct to pretend you're programming in a total language while writing haskell"
05:36:48 <phadej> ahri: but feel free to try Convert, you might learn how bad it is the "hard way".
05:36:57 <yasar> "yasar [[],[],[],[],[]] -> ["y","a","s","a","r"]
05:37:04 <benmachine> merijn: it is not correct to pretend that while you're writing the HaskellWiki article on non-strict semantics :P
05:37:15 <merijn> benmachine: Fair enough ;)
05:37:36 <merijn> benmachine: Anyway, the discussion in that paper may help provide some extra insight :)
05:37:41 <nil> yasar: oh, then you want  spread (x:xs) (y:ys) = (y ++ [x]) : spread xs ys
05:37:42 <yasar> "yasar ["y","a","s","a","r"] -> ["yy","aa","ss","aa","rr"]
05:37:42 <benmachine> merijn: but thank you anyway. I've heard it and might even have read it years ago, but maybe it's worth another look
05:37:47 <nil> and you still need to cover base cases
05:37:51 <ahri> hehe @phadej I'm willing to trust you, mostly because of the lawlessness ;)
05:38:04 <nil> (i'd just use `zipWith`)
05:38:23 <ahri> I'll continue to use `a -> ByteString` in my database as I think it's clearest
05:38:46 <benmachine> ahri: another thing that makes me worry about super-polymorphic definitions is that sometimes it can hide dumb mistakes -- if there's too many types that can fit in your program, your compiler can no longer tell you when you get it wrong
05:39:19 <merijn> benmachine: The essential point is that "if code works in a total (strict or not) setting, then adding bottom will only ever affect those cases that actually encounter bottom, which will (in the worst case) stay bottom or (in the best case) behave correctly due to laziness
05:39:40 <benmachine> merijn: right, you can never change which total value you get
05:40:09 <benmachine> ahri: this is a general argument for using typeclasses less though, which some may argue is going too far :P
05:40:41 <infinisil> Idea: Type classes should only be used if there's an obvious unique implementation of them
05:40:42 <ahri> benmachine: that's a good point about losing the help of the compiler - despite coming to Haskell to avoid that stuff I still got bitten with JSAny from Haste
05:40:58 <yasar> nil zipWith is a good idea :)
05:41:30 <benmachine> I actually program in OCaml at my day job and think Haskell could maybe learn a thing or two about judicious use of monomorphism ^_^;;
05:42:27 <merijn> infinisil: Well, there's some cases where having them can make life easier
05:42:59 <ahri> is that easier in the short or long term though?
05:43:15 <ahri> or both? :)
05:43:17 <merijn> ahri: personally I rarely find myself reaching for them
05:44:44 <merijn> More than a 2-3 per several thousand LOC would already be more than average, I think
05:47:38 <phadej> blargh, travis is in maintenance, so no more hacking right now :S
05:48:15 <phadej> i wonder how much backlog they accumulate during the maintenance
05:55:06 <razzy> is there typical way of installing haskell program? i loaded some code from github, and i am trying to run it in ghci to see what is what. i was unable to load main.sh
05:55:41 <merijn> razzy: cabal-install or stack is the usual way
05:55:59 <razzy> main.hs
05:57:09 <razzy> cabal-install seemed like big(ugly) thing, i guess i will have to try 
05:57:23 <razzy> thx
06:03:54 <phadej> cabal-install is definitely ugly on the inside, but hopefully not so much on the outside
06:07:33 <[itchyjunk]> hey, i want a list x containing an element a such that a = 1+1
06:08:05 <[itchyjunk]> i tried a = [a | a = 1+1] which gave me errors and messing with the error i ended up with x = [a | a <- [1+1]]
06:08:05 <Clint> what
06:08:11 <[itchyjunk]> but i am not sure i understand what i am doing
06:08:21 <merijn> [itchyjunk]: Eh, you can just do [1+1]? :)
06:08:37 <Clint> or [2]
06:08:51 <[itchyjunk]> heh yeah but then how do i test my list comprehension knowladge?
06:09:07 <[itchyjunk]> i'm trying to play with list comprehension so i can do useful stuff with it later
06:09:34 <jollygood2> > [a | a <- [1+1]]
06:09:37 <lambdabot>  [2]
06:10:00 <jollygood2> > [a | a <- [1,2,3,4,5]]
06:10:05 <lambdabot>  [1,2,3,4,5]
06:10:13 <merijn> [itchyjunk]: Honestly, I rarely use list comprehensions
06:10:58 <[itchyjunk]> so my long term goal is to write a function that when called has a list of fibbanachi number. don't i need `fin x = [list comprehension to generate the sequence]` ?
06:11:57 <LevyElara[m]> parallel list comp might be better for that one
06:12:01 <[itchyjunk]> so why does <- want a list? [a | a <- 1 ] doesn't work right?
06:12:13 <[itchyjunk]> hmm i dont think i know what parallel list comp is
06:12:59 <nil> is fibbanachi the secret child of banach and fibonacci?
06:12:59 <LevyElara[m]> Try to desugar list comprehensions to regular functions
06:13:22 <LevyElara[m]> Then you'll start to get the gist of how they work
06:13:44 <jollygood2> [itchyjunky], it wants a list because they are list comprehensions, not int comprehensions. =)
06:13:59 <jollygood2> (not that 1 is necessarily an Int, but that's a different topic)
06:14:40 <nil> > ([a | let a = 1], [a | a <- [1]])
06:14:47 <lambdabot>  mueval-core: Time limit exceeded
06:14:59 <nil> uhm
06:15:01 <nil> % ([a | let a = 1], [a | a <- [1]])
06:15:01 <yahb> nil: ([1],[1])
06:16:54 <jollygood2> > [(x + y) | x <- [1,2,3], y <- [10,20,30]]
06:16:57 <lambdabot>  [11,21,31,12,22,32,13,23,33]
06:20:38 <dmwit> [itchyjunk]: "so my long term goal is to write a function that when called has a list of fibbanachi number. don't i need `fin x = [list comprehension to generate the sequence]` ?" No. There are many, many other ways to create lists.
06:22:09 <[itchyjunk]> oh let a = 1 works i see
06:22:11 <dmwit> (Sort of surprised nobody else actually answered your question.)
06:22:19 <[itchyjunk]> LevyElara[m], okay desugaring is what i will try i suppose
06:22:40 <[itchyjunk]> dmwit, wouldn't list comprihensions be the easiest way? :D
06:24:28 <razzy> phadej: story of my life, getting stressed by ugly insides :]
06:45:14 <LevyElara[m]> [itchyjunk]: list comprehensions aren't the best way for most things unless you really need notational convenience. For fib you can use regular recursion to build the list up and most other things `iterate`, `scanl`, or `cycle` some combination with `zipWith`
06:47:12 <LevyElara[m]> the less you rely on list comp the easier and clearer your code will become along with better composition
06:47:36 <srid> "Haskell, at its core, is simple: it is just a polymorphic lambda calculus with lazy evaluation plus algebraic data types and type classes." https://serokell.io/blog/why-dependent-haskell
06:49:07 <phadej> so many fancy words in one sentence
06:49:36 <merijn> Still not convinced Dependent Haskell isn't a mistake
06:49:37 <srid> The only words I don't fully understand yet is 'polymorphic lambda calculus'. Makes me want to read a bit on lambda calculus.
06:49:40 <benmachine> "simple" depends on the person :)
06:49:57 <srid> Note: simple != easy (cf. Rich Hickey)
06:49:57 <merijn> srid: Well, the Simply Typed Lambda Calculus doesn't have polymorphism
06:50:24 <LevyElara[m]> Dependent haskell is great
06:50:29 <merijn> srid: That pretty much relates to the Lambda Cube
06:50:47 <phadej> merijn: "is simple, it is polymorphic lambda calculus", not "simple polymorphic lambda calculus"
06:51:42 <phadej> for me, polymorphic lambda calculus is simple and natural construction, but indeed, ymmv
06:51:48 <LevyElara[m]> srid: it's really templates and unification
06:52:12 <benmachine> "polymorphic lambda calculus" feels like an odd phrase since polymorphism is a type system feature and lambda calculus doesn't necessarily come with types
06:52:26 <merijn> phadej: He asked about the polymorphism, so I'm just contrasting against non-polymorphic ones like STLC
06:52:48 <phadej> benmachine: on this channel every lambda calculus is typed by default.
06:53:19 <LevyElara[m]> it's extended from simply typed lambda calculus so not that odd
06:54:53 <dmwit> [itchyjunk]: No, list comprehensions are probably the hardest way to implement a fibonacci function.
06:54:58 <LevyElara[m]> linear types would be nice
06:55:45 <LevyElara[m]> dmwit: unless you turn on extensions
06:55:53 <merijn> The combination of linear + dependent Haskell frightens me
06:56:28 <dmwit> LevyElara[m]: It's true, if you use something that has superficially similar syntax but isn't actually a list comprehension, that is easier than what I claim is the hardest way. ^_^
06:57:20 <LevyElara[m]> merijn: it's type astronaut heaven
06:58:02 <dmwit> benmachine: I guess you'd prefer "polymorphic typed lambda calculus". But then, if it's polymorphic, it must be typed. So the typed is redundant, and suddenly we abbreviate it to "polymorphic lambda calculus". Tada!
06:58:03 <merijn> Not really
06:58:34 <merijn> I can see a language designed from the start to accommodate linear + dependent types as being nice, but so far from what I've seen retrofitting all that in Haskell is mostly just massive pain
06:59:09 <dmwit> srid: I encourage you to learn the lambda calculus. You'll take one look at it and go, "Oh! It's Haskell, but less good.". hehe
06:59:32 <LevyElara[m]> sure, that's what makes it interesting
07:00:58 <LevyElara[m]> dmwit: this might be a good start https://www.cs.rochester.edu/~brown/173/readings/LCBook.pdf
07:01:36 <phadej> merijn: I agree, if there were a language with deepndent and linear types, which Haskell could try to approach, retrofitting could work; but trying to be "the tip of the research" is IMHO a bit wrong for Haskell in that aspect
07:01:44 <benmachine> dmwit: well I'm not super educated on this, but my objection would be that "typed lambda calculus" is underspecified wrt what type system it is
07:02:16 <phadej> as is, no-one knows for sure what's the good enough way to combine dependent and linear types, and trying to do that in GHC produces a mess, as no-one have a clear vision
07:02:31 <phadej> either one would work, but both is tricky
07:02:48 <benmachine> dmwit: maybe I'm fine with "a polymorphic lambda calculus" but not "the polymorphic lambda calculus" or osmething
07:02:51 <benmachine> *something
07:03:20 <benmachine> oh but the original said "a" so I guess I should stop complaining
07:03:36 <dmwit> Yay, everybody wins!
07:07:20 <phadej> fwiw, I'd advice to not be too pedantic about articles, as e.g. myself as a non-native English speaker, is not very good at putting the right one
07:07:57 <phadej> i.e. don't read in too much into the "chat" messages
07:08:36 <benmachine> phadej: sure, my point was conceptual and not grammatical
07:08:46 <benmachine> phadej: but I appreciate it was less clear to non-native speakers
07:09:12 <phadej> benmachine: you mentioned "the" very late in the discussion, I didn't understand what you said
07:09:22 <phadej> especially as you said "polymorphic lambda calculus", without a or the
07:09:35 <benmachine> phadej: probably better to ignore what I said about the the/a distinction
07:10:11 <phadej> yes, pointing out (natural) language grammatical issues is unproductive
07:11:02 <benmachine> phadej: I was really just commenting on how it seemed weird to think of "polymorphic lambda calculus" as a thing because what polymorphism means might change depending on what type system you're using, and I didn't know of an obvious enough choice to leave it implicit
07:11:32 <phadej> I think it's quite well understood to mean System F like system
07:11:40 <phadej> with omega or without
07:12:19 <benmachine> phadej: fair enough, then it was clear to its audience and its audience was not me :)
07:12:31 <geekosaur> this is #haskell, after all
07:13:11 <benmachine> #haskell is many things
07:13:37 <phadej> but mostly haskell ;)
07:14:24 <merijn> So, how robust is the 8.10 RC? Since I think that's the one I need for speedscope :\
07:17:16 <phadej> well, it's not final, that's for sure :)
07:17:50 <phadej> but seems to work, for things I tried it for
07:18:19 <merijn> I'm also open to other tools for getting some useful out of GHC's profiling other than speedscope
07:18:20 <phadej> (also, it's alpha2, not RC)
07:19:04 <merijn> The GHC user guide talks mostly about how to gather profiling data, but not really how to turn it into something understandable
07:19:31 <phadej> yeah, it's left out to external tools, which you have to discover somehow
07:20:15 <merijn> phadej: Any suggestions?
07:21:02 <phadej> (and I really don't remember any myself either, hp2pretty is nicer than hp2ps, but still not good enough; also I don't remember what's different between profiteur and profiterole)
07:21:31 <merijn> phadej: Well, speedscope is nice, but according to mpickering it's results aren't actually accurate until his stuff that lands in 8.10 :\
07:22:46 <phadej> merijn: yeah, it seems nice, but if it needs 8.10, then it does
07:22:51 <mpickering> merijn: If you look at the eventlog you can get all the raw sample data from both profiling modes.. so you can do what you like with it
07:23:15 <merijn> mpickering: I...don't know what you mean by that, tbh :)
07:27:16 <juri_> hey, good name for a haskell based 3d printer slicer?
07:27:37 <merijn> mpickering: I have a profiling enabled executable and I want to load it into something that gives me some actionable information with the smallest amount of effort/intermediate steps. From what you told me in the past the only way to get correct speedscope output is to use 8.10 and pray all my dependencies build. I'm open to other suggestions
07:27:59 <mpickering> There is more nuance, as I explained before
07:28:06 <mpickering> the first view doesn't work but the other two views do work
07:28:12 <merijn> mpickering: Ok, only 1 of the 3 doesn't work :)
07:28:27 <merijn> But that happens to be the one most useful to me atm :)
07:29:04 <mpickering> then none of the tools will be that useful for you as they all do the same generalisation as views 2 and 3 of speedscope
07:30:25 <merijn> Right, so the answer is "try 8.10 and pray"
07:32:13 <[itchyjunk]> there is layers of sugar in list comprihension  i see
07:34:18 <phadej> merijn: head.hackage does help to get started
07:37:00 <geekosaur> there's layers of sugar everywhere in haskell :)
07:37:47 <hpc> mmmm, layers of sugar
07:39:47 <sm[m]> merijn: I just posted some 8.10 migration notes at https://www.reddit.com/r/haskell/comments/e9ayby/announce_glasgow_haskell_compiler_8101alpha2/fb0ahhf/ FWIW
07:41:46 <sm[m]> for profiling, I've had best luck with profiterole (lightweight, simplest output) plus the informative top section of the standard .prof output
07:42:01 <phadej> sm[m]: I hope you are aware of https://gitlab.haskell.org/ghc/ghc/wikis/migration/8.10
07:42:04 <Athas> Oh drat, I use file-embed.
07:43:16 <phadej> and e.g. file-embed has patch in head.hackage: https://gitlab.haskell.org/ghc/head.hackage/blob/master/patches/file-embed-0.0.11.patch
07:43:56 <sm[m]> phadej: hahaha I was not. It would have been nice if that had been mentioned in the announcements.
07:44:01 <phadej> maybe we should collectively convince ben to include links to migration guide and head.hackage in nanouncements
07:44:04 <phadej> yes
07:44:17 <sm[m]> bgamari ^
07:46:01 <MarcelineVQ> merijn: https://gitlab.haskell.org/ghc/ghc/wikis/migration/8.10 "This is a breaking change for users of TypeApplications." as was foretold!
07:46:28 <merijn> MarcelineVQ: I love being told I'm right :)
07:55:25 <sm[m]> phadej: that file-embed patch lives.. on head.hackage ? I looked in file-embed's issue tracker first
07:55:54 <phadej> sm[m]: read the repository README, it should explain stuff
07:56:06 <phadej> (if it doesn't, then I can help further)
07:56:14 <sm[m]> uh.. which repo ?
07:56:24 <phadej> 17:42  phadej and e.g. file-embed has patch in head.hackage: https://gitlab.haskell.org/ghc/head.hackage/blob/master/patches/file-embed-0.0.11.patch
07:56:37 <phadej> s/blob.*//
07:57:35 <sm[m]> I see, thanks. I wasn't aware of head.hackage
07:58:51 <sm[m]> what's the process for moving head.hackage's patches to their respective repos ? when would that normally happen ?
08:01:26 <mhasc> Is there any predefined function in Haskell checking whether an Int is not 0?
08:01:52 <mhasc> Like "notZero n = n /= 0"
08:03:12 <MarcelineVQ> Why do you want a predefined one?
08:03:37 <MarcelineVQ> Asking since if you're just wanting to get rid of the n there's  (/= 0)
08:04:02 <sm[m]> if I had found some issues/PRs in those repos, it would have saved me from wasting a bunch of time
08:16:20 <phadej> sm[m]: I have no idea, for repositories Ryan maintains (i.e. kmett-verse) he'll probably migrate them somehow (if not already done), for others - I don't know if anyone have plans to make prs, or whether should maintainers just be aware to look of how the pathces are made
08:16:51 <phadej> sm[m]: head.hackage might break package compiling with older GHCs, so those aren't always "proper patches"
08:17:26 <phadej> in other words there might be "quick 'n' dirty" / "make the thing compile" patches
08:21:59 <phadej> as an example: https://gitlab.haskell.org/ghc/head.hackage/blob/master/patches/sop-core-0.5.0.0.patch I'm not sure whether that would work for all GHCs sop-core supports
08:24:03 <merijn> I don't quite understand how head.hackage is supposed to work, tbh
08:24:57 <phadej> it's an overlay to regular hackage index
08:25:24 <phadej> but the processes of who and how contributes to it are indeed a bit unclear
08:26:31 <loli> is there an aeson like library for sexps?
08:26:42 <maerwald> phadej: do we get cabal-3.0.1.0 tarballs next week?
08:27:16 <drdo> loli: probably, but it's also really easy to just write a quick sexp parser
08:27:35 <loli> sure, but it's rather nice that I can just do instance FromAeson DataType
08:27:49 <loli> I've yet to do much template haskell hacking
08:27:56 <loli> maybe a deriving via would work well for me here
08:29:56 <phadej> maerwald: I have no idea about at, I'm not making the releases
08:30:03 <phadej> about that(
08:31:12 <phadej> I actaully hope that I didn't make any additional work for herbert and mikhail
08:32:54 <maerwald> I guess there's no CI for doing the releases and it's done manually?
08:35:51 <phadej> the actual binaries? yes, it's unfortunately manual
08:36:14 <phadej> (and also updating the downloads page etc.)
08:36:47 <phadej> but i guess automating that would require more work than manual releases for until some cloud service would require changes
08:37:53 <phadej> "somebody else's computer" keep changing more often than you'd use it :)
08:43:05 <merijn> phadej: Naah, I'm sure Travis is entirely stable an not going anywhere!
08:43:40 <maerwald> thought we're going to have our own infrastructure on the haskell gitlab?
08:44:06 <phadej> merijn: except if you want to deploy artifacts from there, you have figure your own s3 bucket or something like that
08:44:30 <phadej> merijn: feels to be "too difficult" (vs. e.g. gitlab artifcats, which  are built in feature)
08:44:54 <merijn> phadej: That was mostly sarcasm, since with being bought up and half their technical stuff disappearing I'm honestly not sure how much longer Travis will survive :)
08:44:58 <phadej> maerwald: honestly, travis and github feels to be a lot faster and stable than gitlab.haskell.org
08:45:06 <maerwald> faster true
08:45:24 <phadej> stable as in "stuff doesn't change"
08:46:40 <phadej> also, I understood that gitlab.haskell.org doesn't have that much CI resources, as one would like.
08:46:50 <phadej> so in the free travis is... free
08:47:05 <maerwald> is the org that low on budget?
08:47:12 <phadej> I have no idea
08:47:43 <phadej> my understanding that the CI workers are "machines in somenes closets"
08:47:54 <maerwald> spawning CI nodes via terraform and ansible on demand should be quite doable and economic
08:47:57 <merijn> hmm...is there anything about DeriveFunctor that may result in really slow fmap?
08:49:19 <phadej> maerwald: I think that on demand machines would be quite expensive, as there seems to be always some GHC pipelines building
08:49:33 <phadej> but I really don't know anything about that
08:50:09 <phadej> CI stuff is a time sink
08:50:21 <phadej> terraform would be one more moving part which may break, and require someone to know about
08:50:39 <maerwald> sure, but better than manually messing around on amazon web ui, hehe
08:50:40 <phadej> also, you cannot terraform OSX machines
08:50:58 <maerwald> haha
08:51:12 <phadej> or maybe you can, but managing windows or osx machines is something which terrifies me
08:51:19 <phadej> better to leave to someone who knows about that
08:55:13 <merijn> pffft...there's no, like, mutable zips for mutable vectors?
08:56:52 <merijn> No map either? pfft
09:05:43 <solonarv> merijn: yeah the API surface for mutable vectors is really small
09:05:49 <cocreature> merijn: "forM_ [0.. V.length v - 1] $" is your (only) friend when you’re using mutable vectors
09:06:35 <merijn> Well, I guess I can use imapM_ on the pure vector I have
09:21:23 <merijn> How can I mark functions in where blocks INLINE? Just write the pragma as normal? If I have 2 functions with the same name in separate where blocks of the same module, will that cause trouble somehow?
09:22:32 <geekosaur> I would expect that you write as normal and it can distinguish the multiple names by scope as usual
09:23:45 <geekosaur> but I would not be surprised if it does nothing because as a local binding it's already a candidate for inlining; that seems to apply more to exported names, which can't apply to names in let or where
09:24:17 <merijn> geekosaur: Sure, it's a *candidate*, but sometimes you just have to force something :p
09:38:27 <phadej> merijn: you just have the {-# INLINE #-} indented in the where block too
09:38:32 <phadej> intended
09:38:36 <phadej> indented
09:38:42 <phadej> argh, English is hard
09:38:52 <phadej> it was right first time
10:05:41 <merijn> Same for instance methods?
10:07:38 <geekosaur> I don't think INLINE works there since they are usually invoked via a dictionary
10:07:58 <geekosaur> which comes from outside and can't always be resolved to functions at compile time
10:10:42 <merijn> I suppose
10:11:03 <merijn> I have some cases that are fairly slow with statically known versions, though
10:12:40 <prove_this> Hi I'm a .NET dev looking to build a Haskell web app with microservice back end on AWS......can someone give me some advice on what frameworks have good performance/stability/maintainability for (a) a web service and (b) microservice back ends...probably communicating over a message bus or https if I can't find a gRPC type solution...it would be
10:12:40 <prove_this> greatly appreciated thanks
10:17:26 <prove_this> or just PM me if you don't want to talk in channel....I have 7 years professional experience and part of the app is already written in .NET Core/react.js but would like to port it over so....it'll be out there in the real world and not a noob project :)
10:20:37 <merijn> geekosaur: At least I've found a fun new game, randomly sprinkling INLINE around things that dominate the time profile and occasionally seeing massive chunks disappear :p
10:20:53 <hc> prove_this: i used yesod and servant in the past to build web applications in haskell
10:21:11 <prove_this> any preference between the two or were they used for different purposes?
10:21:31 <hc> servant is for building rest-services; yesod is used for building interactive (server-side generated) web sites
10:21:46 <prove_this> I have the yesod book...the main thing putting me off using it is the way it appears to be an everything-framework rather than letting me use react.js for the client side etc
10:22:05 <hc> oh, then give servant a try
10:22:18 <prove_this> ok so I could put my microservices up behind servant...would you recommend servant itself or suggest another library for that?
10:22:42 <hc> I personally build a (real world) webservice using servant which runs behind an nginx reverse proxy
10:22:50 <prove_this> I could use servant for the main app as well right? deliver some javascript to the home URL request and let that handle the rest requests?
10:23:32 <hc> you mean use servant to deliver the js files? should be possible, though probably easier to use something like nginx to deliver these files
10:24:28 <nicehaskell> HelloNow I am using VSCode for Haskell.
10:24:42 <prove_this> ok I will have a read on nginx and see if there's an AWS-native type solution as well...I think there's AWS approaches that will allow me to just deliver the javascript if I compile it out of react.js into normal js first
10:25:10 <prove_this> thanks, much appreciated
10:25:26 <prove_this> been playing with a start up in my own time but finding it hard to be motivated to do any more .NET code haha
10:25:29 <prove_this> Haskell to the rescue :)
10:25:37 <hc> haha, that's nice :-)
10:32:13 <sm[m]> prove_this: why couldn't you use react.js with yesod ?
10:33:30 <prove_this> hey - isn't the Shakespeare type DSLs an alternative approach to using react.js? I'm not clear how far they integrate into yesod but my impression was it would prevent me from using react.js ?
10:35:34 <hc> shakespeare is used to generate js, html, css code on the server side
10:35:46 <hc> it's not part of servant, that is used purely for building rest apis
10:37:51 <prove_this> sorry hc - I was replying to sm[m] on why I couldn't use react.js with yesod…………..I guess with yesod you could set a build step to compile the reactjs and include it all as script files in yesod?...…...either way I would probably be happier with the simplicity of a rest back end over yesod……..yesod feels very heavy handed
11:05:40 <sm[m]> prove_this: most parts of yesod are optional as I understand it. No reason you have to use hamlet templates
11:06:19 <prove_this> do you think there's a compelling reason to use it over servant+javascript payload from web server?
11:12:50 <fragamus> hi I want to specify an exact version in package.yaml. does anyone know how?
11:12:52 <fragamus> - comonad >= 5.0.4 && < 6
11:13:25 <sm[m]> not if you're happy! it's the most featureful solution which is useful when you need features
11:14:15 <sm[m]> - comonad ==5.0.4
11:14:55 <prove_this> yeah thanks - I had the same thoughts on it too...yesod a lot to learn but a lot of power....atm I would prefer simple and easy to get running on :)  might have to change it in the future but we'll see
11:15:04 <Athas> fragamus: if you're also using stack, then that pinning is not necessary.  If you're using cabal, then I have found 'cabal freeze' very useful for that kind of things.
11:16:11 <fragamus> my thing was working and now it isn't because a newer version was pulled in by stack
11:25:01 <lukelau> if i have a function `update :: MyRecord -> Maybe Int -> Maybe String -> MyRecord`, where `data MyRecord = MyRecord Int String`, what’s an idiomatic way to only update those fields if the maybes are Just?
11:26:19 <cocreature> lukelau: if both are Just or do you want to update whichever are Just?
11:27:32 <lukelau> cocreature: whichever are Just
11:28:09 <cocreature> lukelau: update (MyRecord a b) mbA mbB = MyRecord (fromMaybe a mbA) (fromMaybe b mbB)
11:28:53 <lukelau> That’s pretty much what I have at the moment
11:29:20 <cocreature> I don’t think it’s worth codegolfing it more than that :)
11:29:37 <lukelau> you’re right, was wondering if there was some funky way of doing it with record punning but the simpler the better
11:38:16 <dmj`> but codegolf is fun
11:50:04 <solonarv> you can do something kind of fancy using lens
11:50:13 <solonarv> :t maybe
11:50:15 <lambdabot> b -> (a -> b) -> Maybe a -> b
11:50:37 <solonarv> and it's nicer if you rearrange the arguments a bit
11:51:35 <solonarv> update :: Maybe Int -> Maybe String -> MyRecord -> MyRecord; myUpdate mbA mbB = maybe id (set _fieldA) mbA . maybe id (set _fieldB)
11:58:55 <dmwit> `maybe id . set` *has* to already have a fancy infix name somewhere
11:59:18 <cocreature> making it 7 characters shorter at the expense of requiring lenses and imho making it harder to read doesn’t seem like an improvement :)
12:11:52 <svipal> Ok
12:12:05 <svipal> I have a datatype with field stuff :: [Stuff]
12:12:24 <svipal> sorry, _stuff
12:12:41 <svipal> so I have a stuff lens over it, and a function f :: a -> IO stuff
12:14:16 <svipal> can I use the black magic known as traversals to do something like  g :: a -> Datatype -> IO Datatype; g a v =   v & stuff %~ fmap (f a)
12:15:41 <lyxia> does what you just wrote not work?
12:21:44 <svipal> nope
12:24:30 <solonarv> there *might* be a way to do this as a lensy oneliner, but I'd just write it like this:
12:25:02 <solonarv> ...actually I'm not entirely sure what you are trying to do
12:25:20 <solonarv> the types don't quite match up and I'm unable to guess how they are supposed to fit together
12:27:55 <svipal> Sorry, if I messed it up
12:28:53 <svipal> data Datatype = D { _stuff :: [Stuff], {-other fields-}} 
12:38:11 <ysangkok> hmmm i started using ExceptT, and I thought I could pattern match on runReaderT.runExceptT to test that Left values are as expected. but if i generate a Left, it program crashes with "user error". i tried enabling profiling but it is not really giving sufficient clues
12:40:14 <ysangkok> it is weird, because i don't have any "error" in my program anymore, so i must be using some wacky instance that uses "error"?
12:40:37 <ysangkok> i once read that Either had a weird MonadFail instance, but i think that has been cleaned up (i am using ghc 8.8)
12:44:23 <iqubic> So, I'm using both MonadError and MonadState. I'd love to be able to have some way to get the value of the state if/when errors are thrown with throwError.
12:44:52 <iqubic> I have no idea how to do that.
12:46:17 <geekosaur> is that T over IO? IO's MonadFail instance does that
12:46:30 <iqubic> What T?
12:46:32 <geekosaur> sorry. that was to ysangkok
12:46:35 <iqubic> Ah. I see.
12:47:19 * geekosaur was scrolled back and missed the later stuff, sorry
12:47:32 <ysangkok> geekosaur: aaaaaah yes. it is ExceptT String (ReaderT PrimEnv IO)
12:51:18 <Zer000> I want to kill a thread more gracefully. There is a part at the end that should complete if ThreadKilled is raised there.
12:51:23 <Zer000> I don't know how to do this though
12:55:25 <solonarv> Zer000: does 'finally' not do the trick?
12:55:38 <solonarv> or failing that, 'bracket'
12:57:06 <geekosaur> I think that's a "we won't fix that one" in bracket, actually
12:57:31 <geekosaur> but its the wrong thing anyway, that runs a finalizer when an exception is raised, not blocks an exception during cleanup
12:58:02 <geekosaur> need the lower level stuff, or the safe-exceptions package for the fixed bracket
12:59:56 <iqubic> what does conduit's catchExceptC do?
13:02:49 <Zer000> solonarv, I will try that thanks
13:03:24 <Zer000> geekosaur, I am already using safe-exceptions elsewhere
13:07:25 <ysangkok> hmmm what should i use instead of that IO now that there is no instance MonadFail (Either String) ?
13:09:52 <ysangkok> i am forced to use MonadFail. if i were to define that instance, it would be an orphan instance...
13:12:24 <iqubic> So I have a conduit of the following type: "step :: (MonadState Memory m, MonadError VMError m) => ConduitT Int Int m ()" I want to write a function that runs this conduit with a given set of inputs, and a given initial state, and gather all the outputs into a sinkList.
13:13:10 <iqubic> I want this auxillary runner function to return the final state, and the list of outputs. I.E. "(Memory, [Int])"
13:14:51 <iqubic> However, if any exception is thrown, via throwError from MonadError's typeclass, I want to catch it and be able to return the current state of the memory at the time when the error was thrown, as well as all the outputs produced before the error was thrown.
13:15:39 <iqubic> I have no idea if that's possible or not, or how I'd go about doing it.
13:18:00 <iqubic> Sorry for the long wall of text.
13:18:43 <geekosaur> isn't that kind of control what MonadChronicle is for?
13:18:52 <iqubic> what is MonadChronicle?
13:18:56 <iqubic> Never heard of it.
13:19:46 <geekosaur> http://hackage.haskell.org/package/monad-chronicle
13:20:00 <geekosaur> basically, with MonadError you get the error or the result, not both
13:20:28 <iqubic> Are you serious? I get the error or the result?
13:20:48 <svipal> I love the names of this package
13:21:03 <iqubic> I can't access the final state of the State Monad once throwError has thrown an error?
13:21:13 <geekosaur> the usual assumption is the error prevents the final result
13:21:28 <ysangkok> svipal: because "the chronicles of monad" :D ?
13:21:36 <solonarv> actually, you can get both with the right nesting of ExceptT / StateT
13:21:37 <geekosaur> and you don't want an incomplete intermediate state. you need the final state
13:21:44 <solonarv> I can never remember which it is, though
13:22:00 <iqubic> geekosaur: Actually, this time I do want an incomplete state.
13:22:06 <solonarv> @unmtl StateT s (ErrorT e m) a
13:22:06 <lambdabot> s -> m (Either e (a, s))
13:22:18 <solonarv> @Unmtl ErrorT e (StateT s m) a
13:22:19 <lambdabot> s -> m (Either e a, s)
13:22:30 <solonarv> iqubic: see the difference?
13:22:33 <iqubic> I do.
13:22:48 <iqubic> But in this case what I want is the final s there.
13:22:58 <Pamelloes> Is there any reason why hReady doesn't work on /dev/tty?
13:23:16 <iqubic> I want to be able to get the value of the 's' when throwError is called.
13:23:18 <solonarv> iqubic: yes, so with ExceptT on the outside you will always get that final s
13:23:39 <solonarv> (and by "final" I mean "whenever the computation exits", of course)
13:23:44 <iqubic> I also get it with ExceptT on the inside too, don't I?
13:24:01 <iqubic> Oh, wait... No I don't.
13:24:03 <solonarv> nope! look carefully at the return type
13:24:20 <iqubic> This is what I want.
13:24:22 <iqubic> s -> m (Either e a, s)
13:25:00 <iqubic> But I'm doing all of this in Conduit, so I have ConduitT as the outermost layer.
13:25:13 <iqubic> Which complicates things.
13:25:34 <geekosaur> Pamelloes, it looks like it should work. but needing it is a bit of a smell
13:25:51 <solonarv> iqubic: it doesn't complicate things *that* much
13:26:12 <solonarv> you just use the functions from Data.Conduit.Lift instead of the usual runStateT, runExceptT etc
13:27:42 <Pamelloes> geekosaur: Oh, this is definitely not producton-ready code. I'm trying to hack together a quick and dirty terminal interface for a program which has input piped in, so I can't use stdin.
13:27:58 <geekosaur> there's also a problem if /dev/tty is also stdin as the syste has to pick one place for the pending input to go
13:29:06 <iqubic> solonarv: do I want to bother with catchError?
13:29:34 <geekosaur> also a quick and slightly less dirty interface uses stdout or stderr as "stdin", at least in C; /dev/tty is best reserved for passwords and the like because of above confusion about input sources (unlike /dev/tty, the system will know they're attached to each other)
13:30:16 <Pamelloes> Interesting, I'll look into that
13:30:47 <solonarv> iqubic: idk, do you want to catch errors?
13:31:02 <solonarv> it doesn't look to me like there is any reason to catch an error in this task
13:32:46 <iqubic> No.
13:32:53 <iqubic> I have this: http://dpaste.com/07R368J
13:33:06 <iqubic> I'm not sure why step has the type it does.
13:33:30 <iqubic> s/step/stepVM/
13:33:41 <iqubic> step :: (MonadState Memory m, MonadError VMError m) => ConduitT Int Int m ()
13:33:53 <iqubic> step itself isn't going to be changing at all.
13:34:16 <iqubic> but stepVM's type confuses me.
13:35:49 <solonarv> what part of the type is it that confuses you?
13:40:35 <iqubic> solonarv: Why is it still a conduit?
13:42:16 <iqubic> Oh, I see. (run|exec|eval)(State|Except)c don't actually extract values from a conduit.
13:42:27 <solonarv> yeah, exactly
13:42:45 <solonarv> they just change the 'm' in 'ConduitT i o m r'
13:42:51 <iqubic> Right.
13:43:03 <iqubic> Well, they also modify the r too.
13:43:05 <solonarv> well, and they change the 'r' as well, which is why theye xist as separate functions
13:43:28 <iqubic> So, what is that doing currently?
13:44:57 <iqubic> Why the hell does this typecheck when I use runConduitPure? http://dpaste.com/08XYK9Q
13:45:13 <iqubic> I thought pure meant "do no effects".
13:45:37 <solonarv> you have already eliminated the effects
13:45:53 <solonarv> with runStateC / runExceptC
13:46:42 <iqubic> Ah. I see.
13:47:04 * merijn resets sign his "Days since I got screwed by someone not specifying correct upperbounds"-sign back to 0
13:47:22 <iqubic> So, what exactly is the return value I have here? ((Either VMError (), Memory), [Int])
13:48:28 <solonarv> let me ask a similar question to earlier: which parts of that type are unclear to you?
13:48:54 <iqubic> Well, I want to know the relationship between the VMError and the Memory.
13:49:03 <merijn> "None"?
13:49:09 <solonarv> hm
13:49:20 <iqubic> If an error is thrown via throwError, will I be getting the last known state of the Memory?
13:49:23 <monochrom> You would think that with PVP, setting a good upper bound is almost trivial.
13:49:30 <solonarv> yes, that should be what happens
13:49:51 <merijn> monochrom: Yes, but there is a sect of radicals, mostly in the stack corner of the ecosystem who are opposed to the notion of upperbounds
13:50:12 <merijn> monochrom: "Because they just make you fix/update things constantly with no benefit" or some bogus reasoning
13:50:29 <monochrom> They can set equality bounds.
13:50:46 <solonarv> they do
13:50:52 <merijn> solonarv: They don't
13:50:58 <solonarv> ...by way of specifying a stackage snapshot :|
13:51:17 <monochrom> Also with PVP, there is less need to "update things constantly".
13:51:28 <iqubic> What is PVP?
13:51:34 <merijn> @where pvp
13:51:35 <lambdabot> https://pvp.haskell.org/
13:51:42 <merijn> iqubic: The Package Versioning Policy
13:51:44 <monochrom> But hey, more just cause for me to bad-mouth stack!
13:51:46 <phadej> (Haskell) Package Versioning Policy
13:52:42 <monochrom> The stack ecosystem is a religious ecosysteem.  Change my mind.
13:53:37 <solonarv> monochrom: but I don't wanna ;)
13:53:52 <iqubic> Pepople should follow those guidelines.
13:53:57 <iqubic> They seem good.
13:53:57 <monochrom> :)
13:54:01 <merijn> iqubic: Agreed :p
13:56:45 <merijn> Anyone know where Numeric.Log is from?
13:57:21 <phadej> algebra, log-domain
13:57:53 <merijn> hmm, neither of those are dependencies of random-fu, though...
13:57:57 <merijn> Which is what's dying on me
13:58:18 <merijn> Ah, wait, looking at the wrong random-fu version
13:59:35 <phadej> random-fu  (^>= 0.2.6.2 && < 0.2.7.3)
13:59:41 <phadej> depends on log-domain
13:59:52 <merijn> Yeah, I 0.2.7.0 is the one that's broken
14:00:09 <phadej> https://matrix.hackage.haskell.org/#/package/random-fu, oh yes
14:00:12 <phadej> it looks like so
14:00:24 <merijn> It has a >= 0.9 && < 1.0 constraint on log-domain, but 0.13 broke the interface
14:00:25 <phadej> sad to see testing related library in such state
14:00:51 <merijn> Time to make trustee ticket to fix that bound
14:01:03 <phadej> yes, maybe "someone" will help you ;)
14:02:06 <merijn> actually, that's probably only useful for other people, since I'll need to update to get the revision, but that'd only affect me after I update which would fix it anyway >.>
14:03:04 <phadej> the deps fail on 8.8.1 is something which I'd like to look into too
14:03:11 <phadej> that might affect you somehow too
14:03:19 <merijn> phadej: I'm on 8.6 :p
14:03:33 <phadej> merijn: wasn't you hoping to move to 8.10 :)
14:03:48 <merijn> phadej: Only for profiling, not actual use :p
14:04:10 <merijn> I only update GHC once or twice a year unless I *really* need a new feature :p
14:04:23 <phadej> :) anyway, I'll take a look tomorrow, too late for today
14:04:46 <svipal> why, merijn ? 
14:04:57 <phadej> why update more often?
14:05:02 <merijn> svipal: So all the breakage has been fixed by the time I update :p
14:05:11 <phadej> I use 8.4.4 on my other machine, everything "works"
14:05:23 <merijn> svipal: What's the point of updating more frequently if you don't need a bug fix/feature?
14:05:25 <svipal> I just use a new version when I start a new project
14:05:32 <merijn> svipal: 8.4/8.6 don't magically stop working...
14:05:40 <svipal> I don't have a "always update to latest" policy
14:06:06 <svipal> but neither do I have a fixed update freq
14:06:20 <merijn> svipal: I don't either, 1-2 times a year is a rough approximate :p
14:06:27 <phadej> as a cabal user, it saves a lot of compilation to use the same ghc version, as dependencies are shared
14:06:33 <monochrom> Use ghcup so there is no "upgrade" or "downgrade".
14:06:43 <merijn> monochrom: I sidegrade anyway
14:07:16 <monochrom> Oh wait, ghcup uses a global mutable variable --- symlinks in the file system --- to remember a chosen version.
14:07:17 <merijn> monochrom: I install into separate directories in $HOME and have by .profile select the latest and I can always use -w to pick an older one
14:07:58 <monochrom> Sometimes I think it's a step backwards because playing with PATH is a much more localized way.
14:08:22 <monochrom> In these days of concurrency, all global mutable variables are bad.
14:08:30 <merijn> monochrom: I just have all of them in my path with latest first, so all the version tagged executables are in scope immediately without adjusting path :p
14:08:50 <merijn> monochrom: So "-w ghc-8.4" or whatever is all I need
14:08:52 <phadej> indeed, -w is way more convient than PATH alterations
14:09:08 <phadej> and default `ghc` is hadny when you want to install some exe
14:09:24 <phadej> or just play in ghci
14:09:54 <monochrom> Ah, I usually don't need cabal-install, I run ghci directly, that's why.
14:10:14 <merijn> monochrom: You're too cool for dependencies? :p
14:10:41 <monochrom> I'm in fact too cool for both sandboxing and the v2 way.
14:10:51 <monochrom> Hell I'm too cool for even --user.
14:11:04 <monochrom> Yes I want my "cabal install --global" back.
14:11:21 <phadej> bad habits die hard
14:11:31 <monochrom> No these are good habits in my context.
14:12:22 <monochrom> And v2 still suffers the problem of unpredictable local doc location.
14:13:09 <merijn> monochrom: Yea, that's the only downside I still feel
14:13:36 <merijn> Well, and ghcide's somewhat...shaky support for multi-component v2-build setups
14:13:39 <phadej> a lot of OSS suffers from the fact that only issues that contributors face themselves are fixed promptly :)
14:13:49 <merijn> But then, my largest project is broken in ghcide atm anyway ;)
14:14:32 <merijn> phadej: I can't hear you over the sound of v2-build no longer constantly rebuilding world due to warning flags ;)
14:15:00 <phadej> merijn: for example, yes.
14:15:52 <merijn> If I ever finish my phd thesis I will *finally* add support for $HOME in ~/.cabal/config >.>
14:16:26 <phadej> merijn: I was thinking about that the other day, when discussing with Tamar the issue of default cabal locations being quite bad on windows
14:16:45 <phadej> and maybe moving cabal to finally follow xdg
14:17:01 <phadej> then you would like to say storedir: $xdgcache/cabal/store
14:17:28 <monochrom> Yeah xdg would be nice.
14:17:37 <monochrom> If not $HOME
14:18:10 <monochrom> In fact xdg sounds like less code to maintain too.
14:18:28 <phadej> yet, my envisioned path (pun unintended) to that has quite a bit of steps :/
14:19:44 <phadej> monochrom: I don't think there will be any less code
14:20:11 <monochrom> oh well
14:20:42 <phadej> going via cabal/config is good design, but having "good" defaults, and allowing xdg/home variables as path roots is more flexibility
14:20:51 <phadej> for weird users who share configuration between different machines
14:21:07 <merijn> phadej: Who are you calling weird? >.<
14:21:10 <phadej> and for some reason might evne have different usernames on them, or otherwise different FS layout
14:21:20 <phadej> merijn: complement phadej
14:21:45 <solonarv> or even *horrified gasp* different operating systems!
14:22:02 <merijn> oh, yeah
14:22:16 <phadej> sorry, I actually have different username on one machine I have. So I'm weird too
14:22:27 <solonarv> I at least use the same username everywhere
14:22:29 <phadej> (but there I use default cabal config, so it's ok)
14:22:32 <solonarv> and I do mean *everywhere*
14:22:34 <merijn> I should check up my GHC issue to see if they fixed it, else I *still* can't share my config
14:22:42 <solonarv> I guess I'm not consistent with capitalization
14:22:51 <phadej> solonarv: sometimes you cannot choose, you kno w, universities or employers
14:22:59 <merijn> solonarv: So who did you bribe in your company/university's sysadmin staff? :p
14:23:05 <phadej> :)))
14:23:09 <monochrom> Don't worry, Windows and Mac aren't consistent with capitalization either!
14:23:42 <merijn> I tried to share my config modulo sed only to find out ghc breaks with "split-sections: True" on macOS (where it's a noop)
14:24:12 <solonarv> ah true, my uni username is not this one
14:24:16 <merijn> You'd think a no-op flag would "Just work" (or, at worst, warn) rather than just going "this is a noop, so we're just not gonna work"
14:24:27 <solonarv> and I don't think I have an email address with this username
14:24:51 <phadej> merijn: yes, maybe in some day in the future we will get conditionals to cabal.config or at least cabal.project files
14:25:29 <merijn> phadej: Better solution (hence my GHC ticket) is to make GHC not fail in the presence of split-sections
14:25:51 <phadej> merijn: yes, but e.g. old GHCs (which I occasionally use) will still freak out
14:26:19 <phadej> e.g. -j cannot be specified in cabal.config if you (occasionally) use old GHC too
14:26:35 <monochrom> No, you need a front to GHC, the front conditionally edits the flags.
14:26:49 <phadej> and that front is cabal ;)
14:28:53 <phadej> if only cabal internals around configuration were easier to change, it would be a joy
14:29:14 <phadej> every wish could be fulfilled
14:29:17 <merijn> phadej: ;)
14:29:59 <merijn> I like cabal's internals...it's like a single player Call of Chtulhu so I don't need other players to slowly go insane...
14:31:11 <phadej> well, it's a nice experience. A lot of things actually make sense, but not when you just glance at them; you actually have to stare for quite some time until "you get it"
14:31:21 <Phyx-> < merijn> phadej: Better solution (hence my GHC ticket) is to make GHC not fail in the presence of split-sections <-- hmm?
14:31:46 <merijn> Phyx-: GHC fails with split-sections on macOS "because split sections is a noop on this platform"
14:32:13 <phadej> one can argue it sould be s/noop/not implemented/
14:32:26 <phadej> i.e. you ask for something ghc cannot deliver
14:32:36 <Phyx-> merijn: right, Apple invented there own thing
14:32:46 <Phyx-> but I thought we disabled split-section on macos..
14:32:47 <merijn> Whoo!
14:33:13 <merijn> Strategic placement of unsafe foreign calls reduces runtime by two thirds!
14:33:22 <Phyx-> also need to fix library-for-ghci in cabal. which has been unusable since split-sections lol. but that should be an easy fix
14:34:26 <phadej>  /wg hpc 
14:34:34 <phadej> hmm, tab completion did weird thing
14:34:48 <Phyx-> lol
14:35:41 <EvanR> waggle gingerly at hpc
14:47:57 <hpc> sup
14:53:33 <phadej> ha, surprise. Investigating why cabal error, following the callstack, I find TODOs
14:53:50 <phadej> error as in "calls error"
15:02:56 <phadej> oh, find a porential reason
15:03:15 <phadej> oleg 1 - cthulhu 0
15:09:23 <infinity0> they say that pi types and sigma types are dual, implying that functions and products are dual, however they also say that products and sums are dual
15:09:39 <infinity0> something doesn't make sense here
15:11:15 <solonarv> functions and products are adjoint
15:11:55 <solonarv> oh! but also, pi/sigma types can be viewed as a product/sum
15:13:32 <mycroftiv> infinity0: the language and classifications here are really awkward, because of things like the fact that sum type is usually represented in dependent typed coding as a sigma type where the two parts are not actually dependent
15:14:37 <mycroftiv> as solonarv as saying, there is a categorical view where you look at locally closed cartesian categories and see the quantifiers as adjoint functors, but even though i can say those words, i dont quite understand them 
15:16:57 <merijn> Man, why is Vector's API so inconsistent :(
15:20:32 <solonarv> a pi type pi (x :: k). F x looks like a product F x1 * ... * F xn, where x1 ... xn are all the possible values of x :: k
15:20:45 <robanan> Hello! I have a `Map` of type `Map ByteString MyType` and I want to create another map out of it of type `Maybe (Map FilePath MyValidatedType)`. What would be the best way to do so? I can't use `mapM` because I need an access to the keys as well
15:20:57 <solonarv> similarly a sigma type sigma (x :: k). F x looks like a sum F x1 + ... + F xn
15:21:17 <solonarv> robanan: traverseWithKey
15:21:36 <robanan> I'll look into that, thank you
15:21:50 <solonarv> (it's in Data.Map.{Strict,Lazy} like all the other Map-related functions)
15:22:14 <mycroftiv> infinity0: heres a link which may or may not help depending on whether you like the abstract math http://perso.ens-lyon.fr/pierre.clairambault/tlca11.pdf
15:22:34 <robanan> Oh, but I need something like `Applicative t => (k -> a -> t (l, b)) -> Map k a -> t (Map l b) `
15:22:42 <infinity0> merijn: just use lens? :)
15:22:47 <infinity0> mycroftiv: thanks, will have a look
15:23:12 <robanan> `(Ord l, Applicative t) => (k -> a -> t (l, b)) -> Map k a -> t (Map l b) `
15:23:20 <merijn> infinity0: Lens solves none of the problems I have
15:23:47 <iqubic> If I use throwError in a conduitT pipeline, with the underlying Monad being MonadError, will that halt the computation?
15:23:50 <infinity0> it gives you a consistent api for deal with data
15:24:03 <infinity0> mycroftiv: sadly i don't have enough background to understand that link :(
15:24:58 <merijn> infinity0: It gives me extra dependencies, extra boilerplate, and it certainly won't make anything faster. The solution is to fix vector so that it doesn't forget to export some functions for some of the vector types
15:25:23 <solonarv> robanan: oh you need to change keys as well? hmm
15:25:23 <mycroftiv> infinity0: i dont understand too much of it either. there is a lawvere paper "adjointness in foundations" that is really influential and important. those slides say sigma types are left adjoints and pi types are right adjoints
15:27:18 <infinisil>  
15:27:29 <robanan> solonarv `fold` with `traverse` should work. But it would require two traversals (to build it and then to traverse a map)
15:27:50 <infinisil> Don't mind me, I just came to mess with your auto-completes
15:29:02 <infinity0> lol
15:29:29 <infinity0> merijn: what functions do you need
15:30:27 <merijn> infinity0: Vector.Storable doesn't export imapM/imapM_, but Unboxed and Data.Vector do
15:30:56 <robanan> I can do it with one simple `foldWithKey` and then check whether `Map` is empty or not. Should work well enough
15:33:43 <infinity0> honestly lens is probably just the easiest thing, don't need to worry about data structure authors forgetting to export simple tweaks of various utility functions
15:34:04 <d34df00d> Hi!
15:34:43 <d34df00d> Is there a nicer way of writing `foo <- liftIO (traverse readFile maybeSomething) >>= traverse parse` ?
15:38:42 <c_wraith> is this better (didn't compile, double-check me on this one)?  traverse (parse <=< liftIO . readFile) maybeSomething
15:43:43 <koz_> Yay fish.
15:44:03 <d34df00d> c_wraith: yeah, lots better! Thanks!
15:48:58 <yasar> I reimplemented `group` function as an exercise, how does it look? https://gist.github.com/yasar11732/da6e7462fc584377b5fbd44ccf1ec0ad
15:58:04 <heatsink> yasar: You can use @ patterns to avoid repeating a term from a pattern match
16:00:14 <heatsink> Instead of foo (x:xs) | f x = x:xs, you can write foo xs@(x:_) | f x = xs
16:01:47 <koz_> heatsink: Anything is possible if you add enough pattern matching shenanigans.
16:02:04 <solonarv>  @-patterns aren't really shenanigans, are they
16:02:19 <solonarv> abuse of ViewPatterns!
16:02:25 <solonarv> that's shenanigans
16:02:44 <d34df00d> No such thing as "ViewPatterns abuse".
16:02:46 <koz_> solonarv: ViewPatterns and PatternSynonyms qualify as shenanigans, agreed.
16:02:58 <Axman6> foo xs@(f -> True) = xs
16:03:06 <solonarv> haha
16:03:07 <solonarv> nice!
16:03:12 <Axman6> no :P
16:03:23 <solonarv> nice as in "clever", not "good" :P
16:03:36 <hexagoxel> > case 13 of x | ((+1) -> y) <- x + 1 -> y
16:03:39 <lambdabot>  15
16:04:12 <nil> this isn't confusing at all!
16:05:45 <d34df00d> There's that contest for the most obfuscated C program.
16:05:51 <d34df00d> Does Haskell community have something similar?
16:06:36 <Axman6> Wasn't the last obfuscated C contest a Haskell compiler?
16:06:44 <merijn> Axman6: One of the entries, yes
16:06:44 <Axman6> winner*
16:06:52 <merijn> One of the winners, even
16:07:03 <merijn> d34df00d: No, too easy :p
16:07:18 <merijn> d34df00d: Alternatively: Yes, lens ;)
16:07:20 <phadej> there was obfuscated haskell contents
16:07:36 <phadej> https://wiki.haskell.org/Obfuscation
16:08:19 <d34df00d> Oooh lens, yes.
16:08:25 <d34df00d> My next question was a lens one.
16:18:08 <d34df00d> So let's say I have foo :: Maybe Data.Aeson.Value and I have the prism _String :: Prism' Value Text (roughly speaking).
16:18:14 <d34df00d> How do I combine the two so that I get Maybe Text?
16:18:24 <d34df00d> `foo ^? _String` obviously doesn't work.
16:18:42 <d34df00d> IIRC there is an operator that collapses such Maybes but I wasn't able to easily find that.
16:21:00 <infinity0> d34df00d: join collapses multiple levels of monads
16:21:34 <d34df00d> The problem is that ^? expects a ty, not a Maybe ty, and at that point there's nothing to collapse yet.
16:21:53 <d34df00d> And I really don't want to write `join $ (^? _String) <$> foo`
16:22:10 <d34df00d> Or `foo >>= (^? _String)` for that matter.
16:23:19 <slack1256> What is the go to library for machine learning on haskell? I just need something for tutorials and learning.
16:24:57 <Axman6> Not sure if it's the goto, but grenade is quite cool
16:25:21 <infinity0> foo >>= (^? _String) seems ok to me tbh
16:25:42 <Axman6> :t preview
16:25:45 <lambdabot> MonadReader s m => Getting (Data.Monoid.First a) s a -> m (Maybe a)
16:26:04 <Axman6> I'd prefer preview _String personally
16:26:43 <slack1256> Axman6: Mmmm looks fine.
16:27:07 <infinity0> or perhaps foo ^? _Just . _String
16:29:43 <d34df00d> Oh!
16:29:47 <d34df00d> _Just . _String is good.
16:29:51 <d34df00d> Thanks!
16:44:16 <iqubic> This Advent of Code stuff is a lot of fun.
16:44:45 <iqubic> I can say that I have learned a lot about conduit, Monad Transformers and the Lens library. I've also gotten a lot of use out of the Container's package
16:51:06 <Henson> iqubic: is this on adventofcode.com?
16:53:33 <dmwit> Henson: yes
16:53:43 <sm[m]> iqubic: it is. It’s great for both the individuals and I think it’s impacting haskell itself
16:57:23 <sm[m]> getting more of us hammering on unfamiliar packages, thinking about ergonomics and performance, building up best practices etc. It’d be great if there was something like it happening more regularly
17:31:05 <dsal> I spend more money on Haskell books than I do on like, any other entertainment media. heh https://usercontent.irccloud-cdn.com/file/QExqH3Ad/books.png
17:57:59 <svipal> the lens book is too pricey for ;e
17:58:05 <svipal> sadly
18:13:11 <iqubic> I now own the Lens book.
18:13:59 <iqubic> I shall view it, then review it
18:21:13 <EvanR> zing!
18:21:43 <koz_> ... that took me longer than I am proud to admit.
18:23:06 <iqubic> It's a lens joke.
18:23:22 <iqubic> And I might fail to review it properly.
18:24:14 <adamwespiser> How is the lens book?
18:26:05 <iqubic> I've only gotten a little ways into it.
18:26:42 <Axman6> iqubic: you can also preview it, but it might not work
18:27:08 <iqubic> I see.
18:36:25 <jusss> does `killThread' kill the thread forked by forkIO?
18:37:06 <jusss> https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Concurrent.html#v:killThread
18:42:39 <Axman6> yes
18:43:31 <Axman6> will, I think more precisely it throws the ThreadKilled exception to the thread, which it could catch and ignore
18:44:31 <dsal> jusss: killThread seems like a super awkward thing to be using.
18:44:50 <dsal> Async gives a nice, easy-to-use interface.
18:45:00 <maerwald> Async is pretty bad for signal handling
18:45:39 <maerwald> imo, it should never have been mixed
18:49:37 <jusss> dsal: this is the code, reading from 177 line please, https://github.com/jusss/code/blob/bla2/Haskell/I2T4.hs
18:50:33 <jusss> dsal: recvMsg is a non-blocking loop function, and `recv` need to be into a loop function, this two loop functions share the same variable socket
18:51:06 <dsal> recvMsg is not a function if you're running it in its own thread.
18:51:21 <dsal> But the abstractions in Async likely be a lot cleaner.
18:51:36 <jusss> if I turn this into `async` way, I have to change that recvMsg to a non-recursive function and put it into the loop function of recv
18:52:00 <dsal> I don't understand what you mean by that.
18:52:46 <jusss> dsal: let me explain this, this recvMsg read message from telegram and send it to irc
18:52:48 <dsal> async :: IO a -> IO (Async a)  vs.  forkIO :: IO () -> IO ThreadId
18:53:35 <dsal> You have more *options* to do things in async, but you shouldn't have to change much.
18:53:44 <jusss> dsal: 'cause we don't use global varaibles, so I use recursive to pass the variable chatId that every time changed when it runs
18:54:06 <dsal> What's the difference between `IO a` and `IO ()`   ?
18:54:07 <iqubic> "Well that was easy! We probably don’t need to actually define this as a whole new function, but I’vegotta fill up this book somehow right?"
18:54:13 <iqubic> Best quote ever.
18:54:32 <jusss> "do { h <- async (recv socket 1024); do some other stuff; answer <- wait h ; do stuff with answer }"
18:54:36 <iqubic> It's from Optics By Example
18:54:49 <[itchyjunk]> Is "haskell 98" what I am using? this book says the version its talking about is "Haskell 98" :s
18:55:02 <dsal> Nobody uses standard haskell . heh
18:55:13 <dsal> jusss: What does any of this have to do with async?
18:55:18 <jusss> dsal: I should change recvMsg to a non-recursive function and put into `do some other stuff` block I assume
18:55:21 <[itchyjunk]> does it matter if the book is about haskell 98?
18:55:24 <dsal> You could literally replace forkIO with async and make almost no changes.
18:56:00 <dsal> You'd just get `cancel` instead of `killThread`, but you'd also get some better abstractions such as `withAsync` to avoid leaks.
18:56:01 <jusss> that recvMsg should return chatId every time
18:56:49 <zzz> iqubic: i challange your quote with this one: "While functions being unable to change state is good because it helps us reason about our programs, there's one problem with that. If a function can't change anything in the world, how is it supposed to tell us what it calculated? In order to tell us what it calculated, it has to change the state of an output device (usually the state of the screen), which then 
18:56:51 <dsal> Related:  I'd recommend adding toplevel type signatures.  It's not obvious what `recvMsg` is.
18:56:55 <zzz> emits photons that travel to our brain and change the state of our mind, man.
18:57:22 <dsal> I am become StateT
18:57:27 <maerwald> zzz: wait, you wanna change the state of my brain with functions? >(
18:57:49 <jusss> dsal: recvMsg :: IO ()
18:58:10 <dsal> That won't compile.
18:58:27 <jusss> oh, 
18:58:32 <dsal> I'd recommend `-Wall` to get a feel...  As a bonus, it'll offer you up some type signatures for things  that you don't get right.
18:59:16 <dsal> But none of this has anything to do with async
18:59:44 <dsal> Wait... you're calling `main` recursively?
18:59:52 <jusss> dsal: yeah...
18:59:58 <dsal> It seems like it'd be far more reliable to just exit and let systemd do that.
19:00:19 <dsal> Then you don't have to worry about thread cancelation.
19:01:17 <dsal> But in general, coupling those  two threads with `withAsync` would give you what you want.  When one exists, the other goes with it.
19:01:27 <jusss> dsal: yeah, you're right, I should use systemd
19:02:04 <specialunicorn[m> hi
19:02:06 <dsal> You also get stuff like `mapConcurrently` which I use quite a bit in network junk.
19:02:10 <specialunicorn[m> are you guys from IRC
19:02:19 <dsal> You come in to my home and ask me if I live here?!
19:02:21 <specialunicorn[m> oh  yes
19:02:56 <specialunicorn[m> I can if we were married
19:03:06 <specialunicorn[m> could*
19:06:29 <jusss> dsal: does this `async` stuff related to continuations?
19:06:54 <dsal> According to the documentation: This module provides a set of operations for running IO operations asynchronously and waiting for their results.
19:07:19 <dsal> It continues: It is a thin layer over the basic concurrency operations provided by Control.Concurrent. The main additional functionality it provides is the ability to wait for the return value of a thread, but the interface also provides some additional safety and robustness over using threads and MVar directly.
19:07:21 <jusss> it sounds like Promise in Javascript
19:07:26 <dsal> How so?
19:07:29 <jusss> or Future in Java or Python
19:07:37 <Axman6> Async is just a library that makes Control.Concurrent easier to use safely
19:07:41 <dsal> Or promise in scheme as they all seem to  have been based on?
19:08:47 <jusss> scheme doesn't implement Promise I think
19:09:10 <jusss> scheme provide full continuation and delimited continuation
19:09:22 <jusss> call/cc and shift/reset stuff to capture  continuations
19:10:10 <jusss> but I think python's generator is a kind of delimited continuation, right?
19:10:19 <jusss> that yield/next stuff
19:10:36 <dsal> scheme has had promises forever.  And call/cc
19:10:58 <dsal> But anyway.  I'd recommend getting familiar with the async library if you want to do concurrency.
19:11:14 <jusss> those concepts, make me confused...
19:11:15 <dsal> There's also some friendly variants  that work with UnliftIO which is handy for doing concurrency in the middle of transformer stacks.
19:11:48 <jusss> dsal: IORef is not recommend to use ,right?
19:12:09 <dsal> If you're doing concurrency, just use STM.
19:12:22 <dsal> It's pretty easy to get right and many dumb things are impossible.
19:13:29 <dsal> async to make concurrent tasks.  STM transactions to manage state across them.  Super easy.
19:13:39 <flebron> Hi folks. Is there a name for "a >>= b >>= b >>= b >>= b ...", repeating ">>= b" k times? It's not quite replicateM, or if it is I'm not seeing it. I could manually foldr, but maybe this is A Thing :)
19:13:47 <jusss> dsal: which module provide STM?
19:14:01 <dsal> @package stm
19:14:01 <lambdabot> http://hackage.haskell.org/package/stm
19:15:40 <jusss> dsal: do we have shift/reset or next/yield in haskell?
19:15:52 <jusss> for delimited continuation
19:16:06 <flebron> (Namely, "replicateM 10 step :: State -> [[State]]", but "initials >>= step >>= step >>= step :: [State]".)
19:16:07 <dsal> what do they do?  What language are you referring to?
19:16:32 <iqubic> juss: the monad-transformers has those functions.
19:16:49 <jusss> shift/reset in Scheme, next/yield in Python, capture part of a continuation
19:16:57 <iqubic> https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Cont.html
19:17:54 <jusss> iqubic: ok...
19:19:40 <dsal> flebron: it sounds rather like foldM
19:25:57 <nil> flebron: i think you could implement it in terms of replicateM_ over StateT
19:26:13 <nil> it's probably a better idea to use foldM though, or define your own helper function
19:27:02 <iqubic> well, I found a typo in optics by example and promptly notified ChrisPenner[m] about it.
19:27:41 <iqubic> He's got this nifty Google Forms thing where he accepts feedback.
19:29:52 <jusss> is there a way to check socket is available to use?
19:30:43 <jusss> when socket is disconnected, recv will read a zero length , what about sendAll ? raise an exception?
19:31:32 <jusss> is there a function to check it's available or not? so we can avoid exceptions?
19:33:45 <banapana> Hello! I have an UTF-8 encoded `ByteString` of a path to file so I need to transform it into `String`
19:33:53 <banapana> But I couldn't find such a function
19:34:13 <banapana> I can do it like that `(T.unpack . T.decodeUtf8)`
19:34:33 <banapana> But that's not exactly what I want (`ByteString` -> `Text` -> `String`)
19:36:20 <Axman6> That is probably the best option though (and stream fusion should avoid the intermediate Text ever actually existing)
19:36:49 <banapana> I see, thank you!
19:38:32 <Axman6> There may be more direct ways, but that will work with libraries you're probable going to need anyway
19:44:56 <dsal> > [1, 2, 3, 4] & traversed . bitAt 1 %~ not  -- <-- was it that one?
19:44:59 <lambdabot>  [3,0,1,6]
19:45:14 <dsal> jusss: In general, you know a socket is broken when reads fail
19:45:52 <dsal> banapana: it's trying to encourage you not to use String.  :)
19:46:30 <banapana> @dsal, I would like to, but `FilePath` is `String`
19:46:30 <lambdabot> Unknown command, try @list
19:47:01 <Clint> well, one of them is
19:48:19 <banapana> Also I have [this](https://paste.debian.net/1121217/) function. I want to write at least some comments for my future self, but it annoys me that they are written "backwards". 
19:48:35 <banapana> How can I simplify it?
19:48:39 <jusss> dsal: can I know it when sends fail?
19:50:46 <koz_> banapana: The two fmaps can be combined into one.
19:51:01 <koz_> fmap (foldr1 (</>) . fmap (T.unpack ...))
19:51:17 <koz_> If it's just the direction you dislike, there's >>> instead of . and >=> instead of <=<.
19:51:36 <dsal> jusss: that's not really a thing... The read tells you. The write *might*, but it's usually not very timely
19:52:04 <jusss> dsal: ok...
19:53:08 <jusss> dsal: the code I show, you said it needn't to change a lot, can you change a few? switch forIO to async, I'd like to see your way :)
19:53:31 <jusss> https://github.com/jusss/code/blob/bla2/Haskell/I2T4.hs
19:54:19 <dsal> You can replace kill with cancel.
19:54:33 <banapana> koz_, I actually tried `>>>` before but for some reason it didn't compose monads. I'll check it one more time. Also there two `fmap` are separated on purpose: they represent different steps, and for me it's slightly easier to read.
19:54:51 <koz_> You need >=> to compose functions of type a -> m b.
19:54:56 <banapana> *these
19:54:57 <dsal> But the program should exit instead of calling main
19:55:00 <koz_> >>> won't work unless they're pure.
19:55:26 <koz_> (well, sorry, my bad, it'll work for m a -> m b, or a -> b, but not a -> m b)
19:55:42 <jusss> dsal: how to exit the whole program :)
19:55:43 <banapana> So `>>>` is a synonym for `flip (.)`?
19:55:53 <koz_> banapana: No. It's more complicated than that.
19:55:55 <jusss> sys.exit() in python I know ）
19:56:06 <koz_> If you just want a synonym for flip (.), there might be one, or you can write it yourself.
19:56:29 <ephemient> Data.Function.&
19:56:44 <koz_> :t (&)
19:56:44 <ephemient> :t (Data.Function.&)
19:56:48 <lambdabot> a -> (a -> b) -> b
19:56:48 <lambdabot> a -> (a -> b) -> b
19:56:54 <dsal> jusss: when the main thread exits, the program should exit.  There's Die and similar to throw an exception and exit non-zero
19:57:00 <koz_> Yeah, that's not flip (.), that's flip ($)
19:57:15 <banapana> I saw its type (something with categories). But can't Kleisli category also be represented with `>>>` then?
19:57:24 <jusss> dsal: yeah, exit code from 0 to 255, POSIX 
19:57:25 <koz_> banapana: Yeah, but you can't mix the two like that.
19:57:34 <ephemient> oh right
19:57:56 <jusss> I wonder when POSIX will support exit with String or other stuff
19:58:09 <koz_> jusss: The answer is 'never'.
19:58:16 <dsal> Heh.  It will not
19:58:23 <jusss> koz_: and the reason?
19:58:45 <koz_> Because POSIX is backwards-compatible to a fault and allowing arbitrary stuff out of exit would require the whole OS spec to be retrofitted to handle it.
19:58:58 <dsal> The time to propose that would be decades ago.
19:58:59 <koz_> This is a bit like asking 'when will C's standard library provide red-black trees generic to any type?'.
19:59:01 <ephemient> you want string exit codes, go try plan9?
19:59:04 <maerwald> because case matching on a string is.... infinite?
19:59:50 <jusss> haha
19:59:51 <dsal> If it were proposed today, exit codes would be memes anyway.
20:00:12 <maerwald> fixed set of up-to-date memes sounds ok
20:00:25 <koz_> EDOGE
20:00:31 <koz_> EXZIBIT
20:00:32 <dsal> We could map them to numbers!
20:00:33 <koz_> Etc.
20:00:50 <maerwald> dsal: .... see, our forefathers were wise
20:01:22 <dsal> EXZIBIT is great.  jusss' program calls main on error...
20:01:43 <jusss> I wonder what OS that lisp machines was running ?
20:01:50 <koz_> ESHUTUPANDTAKEMYMONEY
20:01:53 <jusss> do they have the same problem?
20:02:00 <koz_> jusss: It was a custom thingo that was nothing like UNIX.
20:02:03 <koz_> (I forget the name)
20:02:09 <dsal> Kind of like smalltalk
20:02:13 <iqubic> Well, that's two minor issues found in "Optics By Example" that have been reported.
20:03:30 <dsal> jusss: in async, your exit code is `a`
20:03:43 <jusss> dsal: it's not recommended to call `main' in main?
20:04:27 <iqubic> No it is not.
20:06:05 <dsal> jusss: it's not the worst thing you can do, but it's not a good error recovery mechanism.
20:07:03 <dsal> By the time you add all the error reporting, backoff, clean up all your thread, descriptor, and space leaks, you're still behind the OS on its one job.
20:08:19 <jusss> dsal: if I use capture the continuation and when it runs into some errors, call the continuation is a good way?
20:10:24 <zzz> "forward compose" and related functions: https://hoogle.haskell.org/?hoogle=%28a+-%3E+b%29+-%3E+%28b+-%3E+c%29+-%3E+a+-%3E+c&scope=set%3Astackage
20:21:11 <wikiemol> I am very tired, hopefully I don't fall asleep before someone answers this... but is there a way to define a data type that represents a 2d array such that none of the elements of the 2d array are the same?
20:21:29 <koz_> wikiemol: If you want the _type system_ to guarantee element uniqueness, you're gonna have a bad time.
20:21:37 <wikiemol> :(
20:21:43 <koz_> If you just want a wrapper around a structure which gives uniqueness, that's considerably easier.
20:21:59 <wikiemol> I was hoping for some haskell type system magic
20:22:13 <koz_> wikiemol: What you're asking for is a fairly tall order.
20:22:23 <koz_> (not just in Haskell for the record)
20:24:15 <wikiemol> Thats fair.  I suppose a wrapper is probably the best way anyways
20:25:07 <koz_> Yeah. I have just the thing for you: http://hackage.haskell.org/package/bimap-0.4.0/docs/Data-Bimap.html
20:25:32 <iqubic> More excellent quotes from Chris Penner's new book "Optics By Examples": "Great! Now we can change a promo for a really delicious Peach into a promo for a whole list ofmint-condition Buffy the Vampire figurines. Don’t ask me why; I just follow the laws of supply anddemand..."
20:25:45 <koz_> LOL
20:26:15 <iqubic> He had just introduced polymorphic lenses and made this lens: item :: Lens (Promotion a) (Promotion b) a b
20:26:26 <koz_> iqubic: I guess it's not an Iso?
20:26:27 <wikiemol> koz_ Does Bimap maintain order?? 
20:26:45 <iqubic> koz_: No.
20:26:46 <koz_> wikiemol: It does. Check the type for member.
20:26:52 <koz_> iqubic: Disappoint. :P
20:26:54 <iqubic> I don't think so.
20:27:04 <iqubic> Why would you want it as an iso?
20:27:29 <koz_> iqubic: I like Isos.
20:27:41 <iqubic> Do you want to trade your Peaches for Buffy figurines, and back, with no loss of monetary value?
20:27:48 <wikiemol> koz_ :D  This is great! Thanks!
20:27:48 <koz_> iqubic: Yes.
20:27:52 <koz_> wikiemol: You're welcome.
20:28:28 <koz_> To have it mimic a 2D array, key on (Int, Int). Or (Finite n, Finite m). Or (Finitary a, Finitary b) => (a, b). :P
20:29:15 <iqubic> koz_: The next thing Chris does is show that you really can change from a promo on Peaches to a promo on Buffy figurines.
20:31:43 <iqubic> He does this in a GHCi session.
21:20:04 <iqubic> So, I have a list of functions, and a list of values. I want to apply the first function to the first value, and the second functiono to the second value and so on and so forth.
21:20:41 <iqubic> If one list is longer, I'll stop when I exhaust the shorter on.
21:22:03 <EvanR> zipWith ?
21:23:16 <iqubic> Doesn't quite work.
21:23:36 <EvanR> :t zipWith ($)
21:23:55 <EvanR> % :t zipWith ($)
21:23:56 <yahb> EvanR: [a -> c] -> [a] -> [c]
21:25:55 <iqubic> I just used this: http://dpaste.com/37ZZK11
21:26:07 <EvanR> since it exactly matches your problem description what doesn't work is your problem description
21:27:00 <iqubic> EvanR: I can switch to that. I think that looks more elegant.
21:27:25 <EvanR> @djinn [a -> b] -> [a] -> [b]
22:36:14 <bananaplan> Hello! Can I rewrite this without actually using `if`?
22:36:21 <bananaplan>             if M.null files              then Nothing              else Just files
22:36:27 <bananaplan> Err
22:36:51 <bananaplan> `if M.null files then Nothing else Just files`
22:38:06 <nil> why not just use `files`? it already contains the "is empty" information, you don't need to wrap it in Maybe
22:39:01 <EvanR> perhaps bananaplan wants to indicate the presence of a non-empty list, in which case you need to want NonEmpty or (a,[a])
22:39:23 <bananaplan> `files` should always contain at least one file. And I want my builder to fail, when there is no files at all 
22:39:34 <bananaplan> *are
22:39:48 <EvanR> Just aNonEmpty doesn't really save you from dealing with the empty case later
22:40:04 <EvanR> when it is supposed to be impossible
22:40:57 <Axman6> bananaplan: your question reminds me of https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/
22:41:45 <bananaplan> I used to use `NonEmpty` but `Map` feels more natural for directories and files
22:42:01 <bananaplan> And there is no `NonEmptyMap` 
22:43:00 <bananaplan> I guess `justified-containers` can solve the problem (I read the paper), but I never actually used them, so dunno
22:43:13 <EvanR> the cheapo equivalent of (a,[a]) for Map is ((k,v), Map k v)
23:34:58 <yasar> I am trying to do this exercise -> Load the `Control.Arrow` module into ghci, and find out what the `second` function does
23:35:37 <yasar> I can only see that it is member of Arrow type class
23:35:53 <nil> its type signature should tell you things
23:36:28 <yasar> :t second
23:36:56 <yasar> second :: a b c -> a (d,b) (d,c)
23:37:24 <yasar> `a` looks like a type constructor
23:37:52 <yasar> `b` and `c` are probably type variables?
23:38:06 <yasar> I have no idea where `d` come from
23:38:56 <nil> these are all implicitly forall-qualified type variables
23:39:09 <nyc> d is a free type variable for the first component of the pairs.
23:39:27 <nil> `a` has kind `* -> * -> *` (you can tell because it's applied to two types), `b`, `c` and `d` all have kind `*`
23:40:03 <nil> the type might be clearer if we specialise it to `a ~ (->)`:
23:40:15 <nil> second :: (b -> c) -> (d, b) -> (d, c)
23:41:09 <yasar> so, second gets a function from type b to type c, and a tuple (d,b) and returns a (d,c)?
23:41:33 <yasar> apply a function to second argument of a pair?
23:42:14 <nil> right, except it can work on any Arrow, not just functions
23:43:23 <yasar> nil, original type definition of second consists of two part 1) a b c 2) a (d,b) (d,c)
23:43:29 <yasar> Your version has three parts
23:43:42 <nil> let me rewrite it
23:43:46 <nil> second :: (b -> c) -> ((d, b) -> (d, c))
23:44:46 <yasar> so, second gets a function from (b->c) and gives a function from (d,b)->(d,c) ?
23:44:46 <nil> this can be seen as a function that takes a function (b -> c) and that returns a function on pairs ((d, b) -> (d, c)), OR as a currified function that takes a function (b -> c), a pair (d, b), and returns a pair (d, c)
23:58:21 <maerwald> wasn't there an alternative to 'cloc' written in haskell?
