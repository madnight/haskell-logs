00:54:16 <bahamas> when would you use DiffTime and when NominalDiffTime from the time package?
00:58:39 <maerwald> bahamas: https://i.imgur.com/g6rTcZK.png
01:02:51 <bahamas> maerwald: thanks!
01:08:02 <chloekek> http://www.well-typed.com/blog/2019/10/nonmoving-gc-merge/ mentions “use of the new collector must not require recompilation” as one of the goals. But when switching GHC versions I need to recompile my code anyway, so what is the point of this requirement?
01:09:07 <lortabac> chloekek: I understand it as "you can switch between the two garbage collectors without recompiling"
01:09:37 <chloekek> Ah of course, thanks!
01:09:49 <phadej> maerwald: oh, who made that picture
01:09:55 <phadej> it should be in the docs of Data.Time
01:10:17 <EvanR> @where time
01:10:43 <phadej> i mean, someone should add it there
01:10:58 <EvanR> i made the picture but i'm not sure it's really up to quality level for this core lib
01:11:13 <EvanR> it's on the haskel wiki page for Data.Time
01:12:12 <phadej> It does cut corners, but it nicely enough shows what's there in `time`
01:12:33 <phadej> is Ashley (the time maintainer) aware of it?
01:13:29 <EvanR> probably not
01:13:41 <EvanR> i sent him an email a million years ago about it no response
01:13:57 <maerwald> maybe stuck in a quantum anomaly or time loop
01:14:13 <maerwald> (as you would expect from a *TIME* maintainer)
01:14:15 <phadej> he does respond on github
01:14:23 <phadej> so it might be it just got lost
01:14:31 <phadej> it = the email message
01:15:00 <jgt> is it possible to write a Yesod subsite which brings its own Persistent models, and references a type defined in the master site?
01:15:09 <EvanR> so far no one has pointed out to me an errors either... though it ought to be checked for accuracy
01:15:20 <EvanR> any errors*
01:15:32 <jgt> I'm essentially trying to reference a UserID defined in the master site from the subsite
01:15:46 <phadej> EvanR: yes, that's where ashley's expertice would be good
01:16:52 <phadej> it's kind of good that you don't have UTCTime -> Day arrow, even there's trivial function to go into that direction (as it's most likely non-sense operation)
01:17:02 <jgt> and it looks like I can't do something like `Thing\n  userId MySubsiteAuthId a`
01:17:08 <EvanR> indeed
01:18:43 <EvanR> though, the Day in a UTCTime could be extracted directly, or apply the +0 TimeZone to get local time in a UTC locale, and then forget the time of day
01:19:11 <EvanR> but yeah i expect doing that to probably be a mistake
01:22:18 <dminuoso> phadej: Can you elaborate why such a function would be ill-conceived?
01:22:37 <EvanR> dang that really is a lot of time types. I imagine people think haskell people are crazy (as far as time goes)
01:23:17 <tdammers> my guess would be because UTC represents a timezone-agnostic point in time, while Day is supposed to be a calendar day in an unspecified local timezone
01:23:49 <tdammers> getting the calendar day in the UTC timezone is rarely what you want
01:24:13 <tdammers> TimeZone -> UTCTime -> Day, now that would make more sense
01:24:16 <EvanR> if your database has utc timestamps in it, and someone asks what day something happened on, showing them the date part of that timestamp will probably be a disaster
01:24:18 <dminuoso> tdammers: Oh I see. So something like `TimeZone -> UTC -> Day` would be fine then?
01:24:21 <dminuoso> Ah heh
01:24:30 <dminuoso> tdammers: Well yeah, that's what I was implicitly already thinking about.
01:25:25 <phadej> (timezone, utctime) = ZonedTime, from where you can go to localtime and day, if you see the evan's imgur picture slightly above
01:25:38 <tdammers> yes
01:26:23 <phadej> EvanR: I was positively surprised when starting with haskell, that time doesn't try to cut all the possible corners
01:26:37 <phadej> as it really never works with time issues
01:26:55 <EvanR> clojure's time lib doesn't have all these types, but it does seem premeditated at least
01:27:32 <EvanR> ZonedTime seems kind of like a cut corner to me
01:27:58 <phadej> it is, but there's an issue to have proper olsey support in time
01:28:33 <phadej> olson*
01:28:46 <phadej> and before that, tz & tzdata or timezone-olson
01:28:48 <EvanR> timezone-series does exist not sure if Data.Time leads you there though
01:29:35 <phadej> at least via issue tracker: https://github.com/haskell/time/issues/89
01:29:36 <phadej> :)
01:30:32 <EvanR> progress, interesting
01:30:46 <tdammers> relevant: https://www.youtube.com/watch?v=-5wpm-gesOY
01:31:42 <phadej> timezone-series has some wrong API, imo though
01:31:51 <phadej> utcToLocalTime' :: TimeZoneSeries -> UTCTime -> LocalTime is wrong type
01:31:57 <phadej> it should be -> [LocalTime]
01:32:08 <phadej> or NonEmpty LocalTime (I'm not sure)
01:32:21 <tdammers> it can be empty
01:32:31 <phadej> can it be in that direction?
01:32:35 <tdammers> ah no wait, it can't
01:32:47 <EvanR> there ought to be a function in there with multiple (or zero) results
01:33:44 <phadej> the localTimeToUTC' :: TimeZoneSeries -> LocalTime -> UTCTime can clearly be empty, as local time may have jumps
01:33:47 <tdammers> hmm, but I'm pretty sure it also doesn't produce more than one result per timezone
01:33:49 <EvanR> a list is annoying, it's 1 or 2 results 
01:34:10 <tdammers> at any given moment in time, there is one unambiguous local time for a given timezone, isn't there
01:34:11 <EvanR> i guess you can alway take the first 2
01:34:24 <EvanR> no tdammers unfortunately
01:34:31 <tdammers> EvanR: how?
01:34:53 <EvanR> uhm dang
01:35:11 <phadej> maybe that mapping is surjective
01:35:23 <EvanR> not surjective definitely
01:35:24 <phadej> case in point, time is tricky
01:35:28 <EvanR> spring forwards
01:36:07 <phadej> oh true, surjective is a wrong word
01:36:49 <phadej> "projection like", every UTCTime can be mapped to some localtime, but some different utctime's are mapped to the same localtime
01:36:50 <EvanR> yeah there is 1 right answer when mapping UTC into a local time (in the past, to an extent) using a series
01:37:14 <EvanR> ^
01:37:28 <EvanR> when you have collisions in local time, it seems ambiguous :)
01:37:56 <phadej> but I won't be surprised if some place in the world had the same local time thrice
01:38:17 <tdammers> well, watch that video
01:39:06 <phadej> i have watched that, but forgot, it's packed with content :)
01:39:18 <iqubic> Well, today's AoC challenge, and specifically part 2 showed me that I don't know a damn thing about optimizing haskell code for speed.
01:39:21 <tdammers> I love how he gets increasingly more agitated as the video progresses
01:40:10 <EvanR> the myriad time systems weren't meant to be understood by people... wait
01:40:39 <iqubic> tdammers: I assume you are referring to that one Computerphile video with Tom Scott. If I am wrong, I'd love a link to the video you are actually discussing.
01:40:59 <tdammers> iqubic: you are right, that's the one. https://www.youtube.com/watch?v=-5wpm-gesOY
01:41:36 <iqubic> Nice. I've seen it over a dozen times.
01:41:43 <EvanR> i can only read the synonypsis right now. "a web app that tells you how many seconds ago something happened" man that sounds like a trick question inside of a fake enigma
01:42:06 <tdammers> EvanR: the crux is that most time and date systems were designed by humans who didn't fully understand how time works, and with each new insight into the matter, people had to somehow retrofit that insight onto the existing systems
01:42:53 <tdammers> like for example the insight that a solar year does not equal 12 lunar cycles exactly
01:42:58 <EvanR> so time was the original web programming?
01:43:06 <tdammers> heh
01:43:23 <iqubic> I also love the Computerphile and Tom Scott video about the horrors of localization. It's the same sort of rant style video, but on a different topic
01:43:40 <tdammers> haha, yeah, localization is just as bad
01:44:30 <tdammers> except that it's bad for different reasons
01:44:54 <tdammers> date and time, you could actually do that right if only humans worldwide could agree on saner conventions
01:45:18 <EvanR> luckily they will get it right with the clean slate that is mars... wait
01:45:35 <tdammers> but localization is at the mercy of cultural and linguistic diversity, and trying to unify that is kind of a bad thing to want
01:45:41 <iqubic> tdammers: He goes into some slightly sensitive topics about how, if you have a social media account, and want to translate the phrase "iqubic likes this" in French, or Spanish, or Germany, you need to know the gender of the person doing the liking. iqubic in this case.
01:46:02 <iqubic> And what do you do if someone's gender can't be easily quantified?
01:46:08 <tdammers> German, at least, can avoid gendered language somewhat, though it can be awkward
01:46:31 <iqubic> That's just one of the many problems that exist.
01:46:44 <iqubic> RTL vs LTR text is a massive pain.
01:46:51 <EvanR> Lambdamoo had 6 at least pronoun forms, and this is just for english
01:47:27 <Solonarv> english has it easy, because there is not a lot of twiddly knobs that parts of a sentence have to agree on
01:47:52 <tdammers> there are also cultures that don't recognize gender at all, or at least not as a concept in its own right - it is intertwined with other social attributes of a person
01:48:09 <AWizzArd> In many languages `and` or `&&` are evaluated from left to right. In Haskell I don't have this guarantee, correct?  if (not (null list)) && (head list == 15) then ...    <= this could still throw an exception?
01:48:30 <iqubic> Also, if you don't support have good Unicode support, you might piss off tons of Arabs/Chinese/anyone else who has to use that sort of language.
01:48:34 <tdammers> it's also funny when programmers make subconscious assumptions about how all languages work, and then it turns out that it's actually just English that works that way
01:48:34 <EvanR> && short circuits
01:48:42 <EvanR> > True && undefined
01:48:42 <merijn> AWizzArd: You do, because && is documented as such
01:48:53 <Solonarv> AWizzArd: in Haskell, this is not a guarantee built into the compiler but rather just the way && is defined
01:48:53 <EvanR> undefined
01:48:57 <EvanR> > False && undefined
01:48:59 <EvanR> False
01:49:00 <merijn> AWizzArd: Of course, that code is a crime, so should never be written >.>
01:49:02 <tdammers> iqubic: most European languages also won't work right without proper encodings
01:49:03 <iqubic> AWizzArd: Let's get back on topic. && and || are both evaluated from left to right.
01:49:24 <iqubic> merijn: Yeah. Just use a pattern match.
01:49:26 <AWizzArd> Okay, interesting.
01:49:49 <EvanR> what... no
01:49:52 <iqubic> Pattern matching is a lot better in this case than that sort of guard condition.
01:50:00 <tdammers> español, français, can't even spell the names of the languages correctly without using non-ascii characters
01:50:02 <iqubic> Are you disagreeing with me?
01:50:23 <merijn> I can't even write my name right, due to freenode banning non-ASCII in nicknames >.>
01:50:35 <EvanR> && and || are strict in the first argument, evaluates left to right seems misleading or wrong
01:50:35 <iqubic> Oh, that really sucks.
01:50:48 <iqubic> Ah. Yes. That makes sense.
01:51:22 <tdammers> merijn: point in case, your name gets spelled incorrectly by Dutch people 90% of the time too
01:51:49 <tdammers> merijn: who, these days, takes the time to type "ĳ" when you can just go "ij"?
01:51:56 <merijn> tdammers: I blame the US cultural hegemony restricting us to ASCII inputs and keyboards!
01:52:11 <tdammers> merijn: sure, but Dutch pragmatism is a thing too.
01:52:12 <iqubic> EvanR: Being strict in the first argument, and being left associative would be a better way of describing && and ||.
01:52:15 * Solonarv shakes a fist
01:52:22 <Solonarv> % :i &&
01:52:22 <yahb> Solonarv: (&&) :: Bool -> Bool -> Bool -- Defined in `GHC.Classes'; infixr 3 &&
01:52:34 <Solonarv> that's right associative, not left1
01:52:36 <merijn> tdammers: I've actually seen people write Ijselmeer, and I think we should deport them >.>
01:52:38 <EvanR> this being where i spend most of my time, i installed a ĳ key so i can talk to merĳn
01:52:42 <iqubic> Oh?
01:52:44 <tdammers> merijn: blame MS Word
01:53:08 <tdammers> merijn: but yes, deport them. to South Africa, then they can spell it "Ysselmeer"
01:53:09 <merijn> tdammers: Last time I used Word (admittedly, over a decade ago) it did the right thing...
01:53:09 <EvanR> iqubic: right assoc!
01:53:26 <iqubic> I did not know that.
01:53:30 <EvanR> yeah you did!
01:53:36 <iqubic> Right.
01:53:47 <Cydonia7> I'm trying to learn Haskell, can someone review this small snippet that gets files ordered by last modification date and suggest improvements? I feel like it is not very idiomatic: https://pastebin.com/embed_iframe/SfkRDGFt
01:53:50 <Cydonia7> Thank you so much :)
01:53:52 <EvanR> (x && y) && z wouldn't make sense
01:54:00 <EvanR> given how we know it works
01:54:01 <iqubic> Why not?
01:54:03 <merijn> EvanR: What? Why not?
01:54:21 <EvanR> we expect x to take priority
01:54:28 <merijn> EvanR: It does?
01:54:29 <Solonarv> and so it does
01:54:40 <merijn> EvanR: Like, that doesn't affect the semantics at all
01:54:46 <iqubic> @check \x y z -> (x && y) && z == x && (y && z)
01:55:00 <iqubic> I guess the bot is down.
01:55:06 <iqubic> I was expecting that to work.
01:55:06 <Solonarv> we are interested in strictness, so @check won't help anyway
01:55:08 <merijn> @botsnack
01:55:15 <merijn> :O
01:55:27 <iqubic> Ah. I suppose you are right.
01:55:32 <EvanR> youre right
01:55:36 <iqubic> > 1 + 1
01:55:52 <iqubic> Alright guys, the bot is well and truely down.
01:56:30 <EvanR> trying again, (x && y) && z would require extra thunks
01:56:34 <Solonarv> Cydonia7: okay, some suggestions to follow
01:56:50 <Solonarv> 'foo >>= return . f' is just 'fmap f foo' or 'f <$> foo'
01:58:49 <Cydonia7> Thank you
01:59:20 <Solonarv> second, you can eliminate that 'reverse' by sorting on a different key
01:59:30 <Solonarv> % :i Down
01:59:30 <yahb> Solonarv: newtype Down a = Down a -- Defined in `Data.Ord'; instance Applicative Down -- Defined in `Data.Ord'; instance Eq a => Eq (Down a) -- Defined in `Data.Ord'; instance Functor Down -- Defined in `Data.Ord'; instance Monad Down -- Defined in `Data.Ord'; instance Monoid a => Monoid (Down a) -- Defined in `Data.Ord'; instance Ord a => Ord (Down a) -- Defined in `Data.Ord'; instance Semigroup a => Semigroup (
01:59:37 <Solonarv> % 5 < 3
01:59:37 <yahb> Solonarv: False
01:59:43 <Solonarv> % Down 5 < Down 3
01:59:43 <yahb> Solonarv: True
02:00:15 <infinisil> MONAD DOWN, I REPEAT, MONAD DOWN!
02:00:45 <Solonarv> % sortOn (Down . snd) [(1, 4), (2, 3), (3, 1)]
02:00:46 <yahb> Solonarv: [(1,4),(2,3),(3,1)]
02:01:10 <Solonarv> infinisil: huh, it really does have a Monad instance
02:01:16 <Solonarv> how pointless!
02:01:23 <Cydonia7> nice!
02:01:24 <Solonarv> I wonder if anyone's ever needed that...
02:02:02 <infinisil> Oh huh
02:02:23 <Solonarv> Cydonia7: also: sequence . map f = traverse f
02:03:42 <EvanR> Functor Applicative and Monad instancs were added later, there must have been a reason
02:04:08 <EvanR> + Semigroup and Monoid
02:04:33 <EvanR> but those make sense in terms of underlying semigroup and monoid
02:06:11 <iqubic> > 1 + 1
02:06:18 <lambdabot>  2
02:06:22 <iqubic> The bot is now slow.
02:06:27 <iqubic> @botsnack
02:06:32 <lambdabot> :)
02:06:41 <iqubic> @botsmack
02:06:46 <lambdabot> :)
02:07:00 <Solonarv> I guess the reason was just: there is one unique valid instance and it's obvious, so might as well add it
02:07:22 <Cydonia7> For some reason, if I import `import Data.Ord (Down)`
02:07:42 <Cydonia7> It says :  * Data constructor not in scope: Down :: UTCTime -> b0\r\n    * Perhaps you want to add `Down' to the import list\r\n      in the import of `Data.Ord'\r\n 
02:07:43 <Solonarv> Cydonia7: that only imports the type
02:07:53 <Cydonia7> oh right
02:07:54 <Cydonia7> Down(..)
02:07:57 <Cydonia7> I believe
02:08:04 <Solonarv> to also import the constructors you need import Data.Ord (Down(Down))
02:08:07 <Solonarv> or Down(..)
02:08:39 <Cydonia7> Thank you for your help, it already looks better
02:09:33 <bahamas> speaking of time, I can't tell from looking at the docs how to use formatTime. does anyone have examples?
02:09:51 <Solonarv> Cydonia7: oh, you actually have 'foo >>= return . f' twice
02:09:59 <Solonarv> did you change both of them to fmap / <$> ?
02:10:12 <Cydonia7> https://pastebin.com/embed_iframe/NetaDdn0
02:10:25 <Cydonia7> I wonder how to parenthesize it then
02:10:28 <Cydonia7> Maybe :
02:10:57 <Cydonia7> (\a -> (x, a)) <$> getModificationTime 
02:11:05 <Cydonia7> it looks like it removes the need for the lambda
02:11:14 <Solonarv> unfortunately it doesn't
02:11:20 <Solonarv> (where does x come from now?)
02:11:33 <Cydonia7> \x -> (\a -> (x, a)) <$> getModificationTime x
02:11:34 <bahamas> ok, I misunderstood what each argument means
02:11:43 <Cydonia7> Maybe like this then?
02:11:50 <Solonarv> yeah, that would work
02:11:58 <Solonarv> kind of unwieldy unfortunately
02:12:07 <Cydonia7> also I was trying to use (x,) to replace the lambda
02:12:07 <Solonarv> I might actually write it with do notation
02:12:22 <Cydonia7> but  it says I need to import something like FlexibleTuples
02:12:26 <Cydonia7> don't remember the exact name
02:12:26 <Solonarv> \file -> do t <- getModification file; pure (file, t)
02:12:29 <Cydonia7> should I do it?
02:12:42 <iqubic> \x -> (\a -> (x, a)) <$> getModificationTime x is the same as (,) <$> getModificationTime
02:12:43 <Solonarv> TupleSections
02:12:46 <Cydonia7> right
02:12:50 <iqubic> But you don't need that.
02:12:59 <Solonarv> iqubic: no it isn't
02:13:13 <iqubic> Oh. Right. I'm just wrong here.
02:13:26 <Cydonia7> I just "wowed" at your answer :')
02:13:31 <Cydonia7> It would be so good if it worked though
02:13:34 <iqubic> My answer is wrong.
02:13:37 <Solonarv> you *can* write it in point free style but I would not recommend it
02:13:40 <iqubic> Don't use it.
02:13:44 <Cydonia7> sure :)
02:13:58 <Solonarv> @pl \x -> (\a -> (x,a)) <$> gmt x
02:13:58 <lambdabot> liftM2 (<$>) (,) gmt
02:14:12 <Solonarv> don't do that :P
02:14:12 <Cydonia7> what's pl ?
02:14:18 <Cydonia7> okay :)
02:14:20 <Solonarv> @help pl
02:14:20 <lambdabot> pointless <expr>. Play with pointfree code.
02:14:30 <Cydonia7> okay :)
02:14:36 <Cydonia7> indeed that's not readable
02:14:42 <__monty__> Note the jocular but apt name of the command.
02:14:51 <Solonarv> takes an expression and transforms it to "point-free" style, where no function arguments are mentioned explicitly
02:15:25 <Cydonia7> I think \file -> do t <- getModification file; pure (file, t) will be just fine
02:15:31 <Solonarv> yes
02:15:34 <Cydonia7> it looks maintainable
02:15:49 <Solonarv> or you could use \file -> (file,) <$> gmt file
02:16:04 <Cydonia7> And import TupleSections then
02:16:13 <Solonarv> not import, enable
02:16:19 <Solonarv> it's a language extensions
02:16:21 <Cydonia7> okay :)
02:16:21 <Solonarv> not a module
02:16:26 <Cydonia7> from your perspective what looks better?
02:16:38 <Cydonia7> monad or applicative here?
02:16:56 <Solonarv> hm, I think the tuple section ordo block are both fine
02:17:16 <Cydonia7> ordo?
02:17:20 <__monty__> I'd prefer tuplesections if they weren't a language extension : )
02:17:35 <Solonarv> just a typo, I meant "... or do block ..."
02:17:36 <Cydonia7> are there cons to using language extensions?
02:17:48 <Cydonia7> alright thank you
02:17:59 <Solonarv> mostly cognitive load in that you need to remember they exist
02:18:00 <Cydonia7> you're so helpful, thanks for taking the time
02:18:09 <__monty__> Not this one. Except you have to make sure to enable it in every file you use it.
02:18:26 <Cydonia7> okay so no big deal, I'll enable it :)
02:18:51 <Solonarv> yeah TupleSections falls square in the category of "harmless syntax extension"
02:19:17 <Solonarv> other stars of this category are LambdaCase and the new kid on the block (heh), BlockArguments
02:19:28 <merijn> TupleSections fall square in "should have been in the report from the start"
02:19:29 <jusss> why Cont Monad is so difficult to learn
02:19:40 <merijn> jusss: Because it's confusing as fuck :p
02:19:43 <__monty__> Reason I avoid it is you step out of the haskell any haskeller knows and can run on any implementation of the language.
02:19:46 <Solonarv> because Cont is an evil beast from an eldritch dimension
02:20:00 <Solonarv> (especially ContT. *shudder*)
02:20:02 <jusss> merijn: where and when it's used?
02:20:05 <merijn> jusss: I've written several things that heavily rely on using Cont/ContT and I *still* don't understand them
02:20:13 <Solonarv> jusss: as little as possible ;)
02:20:23 <merijn> @quote didn't.you.write
02:20:23 <lambdabot> autrijus says: * autrijus stares at type Eval x = forall r. ContT r (ReaderT x IO) (ReaderT x IO x) and feels very lost <shapr> Didn't you write that code? <autrijus> yeah. and it works <autrijus> I
02:20:23 <lambdabot> just don't know what it means.
02:20:43 <jusss> yeah, I just ignored ContT, even Cont is defined by ContT
02:20:58 <jusss> that is insane
02:21:08 <merijn> jusss: I think the best example of ContT is complex bracket nesting
02:21:35 <merijn> jusss: See: https://stackoverflow.com/questions/26436095/what-are-good-haskell-conventions-for-managing-deeply-nested-bracket-patterns
02:21:40 <Cydonia7> https://pastebin.com/embed_iframe/CLRNUYsx there with the modifications
02:21:47 <Solonarv> does Codensity work for that too?
02:22:02 <merijn> jusss: Which has the advnatage of also nicely handling "unknown nesting of brackets"
02:22:09 <Solonarv> I tend to think of it as ContT's saner sibling that can actually fit into a mortal mind
02:22:43 <jusss> merijn: did you see this article about Cont https://jsdw.me/posts/haskell-cont-monad/
02:22:44 <merijn> Solonarv: Well, the Codensity I see via hoogle don't seem to fit that
02:23:03 <merijn> jusss: Not yet?
02:23:09 <jusss> I read it for a few time, but that show me that Cont like Reader
02:23:26 <jusss> pass the continuation to Cont value
02:23:28 <Cydonia7> Can hlint detect some of the modifications you suggested? I couldn't get it to work on this computer
02:24:07 <Solonarv> it probably can, but I haven't used it in forever
02:24:31 <__monty__> Not the parenthesizing of lambdas though.
02:24:38 <jusss> twoC' = return 2; helloC' = return "hello"; twoHelloC'' = twoC' >>= \two -> helloC' >>= \hello -> return $ (show two)++hello
02:24:46 <jusss> (runCont twoHelloC') id == "2hello"
02:24:49 <Cydonia7> Well you seem knowledgeable enough so it should not matter much 
02:25:10 <Cydonia7> I guess it's more oriented towards beginners
02:25:19 <jusss> this id will apply on twoC' and get 2, then id apply on helloC' then get "hello"
02:25:30 <jusss> id is passing in the >>= chain
02:25:38 <__monty__> Cydonia7: It's very opinionated but that's not necessarily bad. Consistency can help readability.
02:25:46 <jusss> like the parameter passing in the Reader chain
02:27:34 <Cydonia7> thank you for your help, I like the resulting code
02:29:03 <Cydonia7> It's just using applicatives now in each subfunction, which does help to understand what's going on
02:29:32 <__monty__> Cydonia7: <$> = fmap, hence Functor, not Applicative.
02:29:59 <Cydonia7> I do find the <$> syntax more readable in most cases
02:30:32 <Cydonia7> Is it defined by Functor or by Applicative TypeClass-wise?
02:30:50 <Cydonia7> Maybe I can ask the bot for this :)
02:30:51 <Cydonia7> !help
02:31:02 <__monty__> @hoogle <$>
02:31:02 <lambdabot> Prelude (<$>) :: Functor f => (a -> b) -> f a -> f b
02:31:02 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
02:31:02 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
02:31:30 <Cydonia7> it's strange it is defined in both modules
02:31:46 <__monty__> That's historical. The one you're using is probably from prelude.
02:31:54 <Cydonia7> you're right
02:32:11 <Cydonia7> So only thing an applicative must define is probably <*> then
02:32:18 <Cydonia7> @hoogle Control.Applicative
02:32:19 <lambdabot> module Control.Applicative
02:32:19 <lambdabot> Control.Applicative class Functor f => Applicative f
02:32:19 <lambdabot> module TextShow.Control.Applicative
02:33:15 <Cydonia7> and pure obviously
02:33:32 <Cydonia7> I wonder why pure and return are not reused by default when you define a Monad
02:33:37 <__monty__> Yes, pure and <*> or ap is what applicative adds. *> and <* as well as convenient shorthand.
02:33:42 <Cydonia7> aren't they the same in most cases?
02:33:54 <__monty__> They have to be if you want lawful instances afaik?
02:34:15 <Cydonia7> makes sense, so it is strange that this is not a default, right?
02:34:15 <__monty__> That's more historical happenstance.
02:34:22 <Cydonia7> okay :)
02:34:39 <Cydonia7> is there a place to submit RFCs or suggestions to the language?
02:35:09 <Cydonia7> also, *> and <* are so good for parsers I found
02:35:15 <__monty__> Applicative came way later than Functor and Monad and was only quite recently really assimilated into the hierarchy with the AMP proposal.
02:35:21 <Cydonia7> parsec makes such a good use of this
02:35:35 <Cydonia7> what does AMP stand for?
02:35:37 <__monty__> Maybe the language steering committee?
02:35:44 <__monty__> Applicative Monad proposal.
02:35:56 <__monty__> It made Applicative a superclass of Monad.
02:36:00 <dibblego> they aren't the same function
02:36:34 <Cydonia7> :hoogle pure
02:36:38 <__monty__> And just fyi, if you want to suggest something like "drop return in favor of pure." Don't kid yourself it's definitely been discussed at length : )
02:36:43 <Solonarv> Cydonia7: actually, pure *is* reused as the default definition for Monad
02:37:02 <Cydonia7> __monty__ I don't doubt it ;)
02:37:06 <Solonarv> recent GHCs will even warn you if you define it differently
02:37:14 <Cydonia7> this language has so much to offer that I don't know
02:37:27 <Cydonia7> I'm far for proposing things yet :')
02:37:34 <__monty__> Cydonia7: That will remain a fact for years to come ; )
02:37:41 <Cydonia7> I sure hope so
02:38:04 <Cydonia7> How do you make progress after the two main books? LYAHFGG & real world haskell?
02:38:09 <Cydonia7> trial and error?
02:38:37 <Cydonia7> hanging out in IRC too I suppose?
02:39:20 <Solonarv> actually doing things with the language helpsa lot ;)
02:40:15 <Cydonia7> for sure, I try it a lot on my side projects and sometimes ended up dropping it because I sometimes spent a lot of time on small things
02:40:32 <Cydonia7> I'm weak :')
02:40:57 <Cydonia7> but I get better over time I guess, even if I don't make full programs
02:41:48 <Solonarv> it's maybe a bit late, but there is advent of code going on right now
02:41:53 <Solonarv> maybe you've heard of it?
02:43:52 <__monty__> A slightly less hardcore version of AoC would be one of the many coding sites out there like codewars.com, the later exercises are pretty interesting, just skip over the levels you feel like don't teach you anything.
02:44:36 <Cydonia7> AoC looks cool
02:45:06 <tdammers> it is
02:46:12 <jusss> AOC?
02:46:22 <Cydonia7> advent of code
02:46:47 <jusss> haha, it's a brand of monitor, also a famous woman
02:47:03 <jusss> too famous
02:49:10 <__monty__> In the US maybe.
03:01:48 <Cydonia7> Now getting something to work is one thing, I often get it to work without too much trouble
03:02:02 <Cydonia7> My big trouble is improving code so it is more readable and stuff like this :)
03:02:21 <Cydonia7> I try to use hoogle a lot for this purpose but sometimes I think I look for too specific stuff
03:03:16 <[itchyjunk]> What is the simplest example of a function returning a function?
03:03:20 <__monty__> hlint might help with that. It forces you to be consistent.
03:03:42 <__monty__> [itchyjunk]: `id id`? : )
03:03:53 * [itchyjunk] googles id
03:04:00 <__monty__> `id = \x -> x`
03:04:25 <[itchyjunk]> ah identity function
03:04:33 <__monty__> That was a tongue-in-cheek answer though. It's probably not what you meant.
03:04:59 <__monty__> But for example, `const` takes an argument and returns a function.
03:05:06 <__monty__> :t const 1
03:05:08 <lambdabot> Num a => b -> a
03:05:15 <[itchyjunk]> I in like pre-chapter 1 of a book that says haskell is a higher order functional language and it can take function as input and spit functions as output
03:05:27 <[itchyjunk]> so was curious about examples
03:05:50 <[itchyjunk]> hmm thats returning a function?
03:06:09 <__monty__> Yes, because all haskell functions are curried.
03:06:22 <tdammers> all haskell functions are unary
03:06:27 <__monty__> > let newF = const 'a' in newF 'b'
03:06:30 <lambdabot>  'a'
03:06:32 <tdammers> "curried" is a bit misleading in this context
03:06:40 <tdammers> but anyway
03:06:49 <tdammers> an example of a function that takes a function as an argument is `map`
03:06:51 <tdammers> :t map
03:06:53 <lambdabot> (a -> b) -> [a] -> [b]
03:06:56 <__monty__> tdammers: It's the more useful term to google though : )
03:07:07 <tdammers> see that first argument? that's a function (a -> b)
03:07:19 <tdammers> now, map is also an example of a function that returns a function
03:07:36 <tdammers> again, all haskell functions are unary, so when we say that map takes two arguments, that is technically a bit of a white lie
03:07:43 <[itchyjunk]> oh okay the first term is a function that takes an argument a and maps it to b ?
03:07:51 <tdammers> yes
03:07:56 <tdammers> that's what a -> b means
03:08:19 <tdammers> now, you can rewrite map's type as (a -> b) -> ([a] -> [b])
03:08:41 <tdammers> that is, map is a function that takes a function (of type a -> b), and returns a function of type [a] -> [b]
03:08:50 <__monty__> :t let f = map const in f
03:08:52 <tdammers> a.k.a., map is a unary function
03:08:53 <lambdabot> [a] -> [b -> a]
03:09:31 <tdammers> map reverse ["hello", "world"] is equivalent to (map reverse) ["hello", "world"]
03:09:51 <tdammers> that is, we apply map to the reverse function, which gives us a new function, and then we apply *that* to the list ["hello", "world"]
03:10:30 <tdammers> in a language where functions can actually take multiple arguments, e.g. JavaScript, we could write map as taking two arguments, a function and a list
03:10:46 <tdammers> something like function map(func, list) { ... }
03:10:53 <[itchyjunk]> right
03:11:11 <tdammers> but we could also do the same thing we do in Haskell, write a function that takes the first argument and returns a function that takes the second argument
03:11:21 <tdammers> function map(func) { return function(list) { ... } }
03:11:59 <tdammers> "currying" means to transform a function from the former (multi-argument) form into the latter (single-argument returning another function to consume the next argument)
03:12:18 <[itchyjunk]> ah heh
03:12:25 <tdammers> but Haskell doesn't have multi-argument functions, so we cannot truly curry functions in haskell
03:12:45 <tdammers> and saying that all Haskell functions are curried is kind of trivially true, but also somewhat confusing
03:12:59 <[itchyjunk]> oh. but i see people say "curry" in context of haskell. i wonder why?
03:13:08 <tdammers> it can mean two things
03:13:24 <merijn> Honestly, people should just stup saying curry
03:13:34 <merijn> It's completely irrelevant and never helps
03:13:36 <[itchyjunk]> but they taste good :s
03:13:47 <tdammers> one thing is what __monty__ meant, that all Haskell functions are trivially "in fully-curried form", because Haskell can't represent any other form
03:14:14 <tdammers> the other thing is that, confusingly, people sometimes consider taking a tuple as an argument a reasonable way of writing multi-argument functions
03:14:29 <tdammers> e.g., in this style we could write map's type as ((a -> b), [a]) -> [b]
03:14:32 <__monty__> I disagree. It's the right term to google and therefor useful for newcomers. "Functions in haskell can't take multiple arguments" gives the wrong impression and isn't helpful when googling.
03:15:10 <tdammers> and the Prelude has a pair of functions, curry and uncurry, that can convert between this "fake multi-argument" form and the usual nested-unary form
03:15:12 <tdammers> :t curry
03:15:14 <lambdabot> ((a, b) -> c) -> a -> b -> c
03:15:19 <tdammers> :t uncurry
03:15:21 <lambdabot> (a -> b -> c) -> (a, b) -> c
03:15:30 <merijn> __monty__: It's the wrong term to google, because it will just lead to more utterly unhelpful blogposts
03:15:45 <tdammers> but that's kind of confusing, because, again, all Haskell functions are unary, and the curry and uncurry functions don't change that
03:16:21 <__monty__> merijn: Wiki is the first hit for "currying" and the first sentence on that page is this: "In mathematics and computer science, currying is the technique of translating the evaluation of a function that takes multiple arguments into evaluating a sequence of functions, each with a single argument."
03:16:52 <merijn> __monty__: But the former doesn't exist in Haskell, so contrasting with it is mostly unhelpful
03:17:33 <__monty__> I disagree again, people might be motivated to ask "How do I write a function that *really* takes two arguments in haskell then?"
03:17:38 <[itchyjunk]> whats the advantage of not having functions that can take multiple arguments?
03:17:53 <__monty__> [itchyjunk]: What's the advantage of having functions that take multiple arguments?
03:18:24 <tdammers> in a language where all functions are pure and unary, it becomes easier to reason about them
03:18:32 <__monty__> The most immediate advantage is it avoids needing partial evaluation.
03:18:38 <tdammers> it also becomes easier to write a compiler for them, though that is a secondary concern
03:18:40 <[itchyjunk]> say i want to add two number, intuitivelt i'd think i need some function that need 2 arguments? like sum(a,b) that will return a number
03:19:41 <__monty__> [itchyjunk]: let increment a = (a +) in (increment 1) 2
03:19:42 <tdammers> ultimately, the idea traces back to lambda calculus, and the notion of keeping the core of the language and its theoretical underpinnings as small as possible
03:19:48 <[itchyjunk]> but as i understand a + b applies + to be and returns a new function, lets say b_+ and b_+ is applied to a ?
03:20:11 <[itchyjunk]> tdammers, ah i see
03:20:19 <__monty__> [itchyjunk]: You can still add any two numbers, but now you can also easily pass around a function that increments a value by another specific number, often 1.
03:20:36 <tdammers> the observation is that while you think you might need a binary function, it turns out that as long as we have functions that can accept and return functions, we don't need them, we can instead construct binary-function semantics using only unary functions
03:20:47 <tdammers> this is part of what the lambda calculus formalizes
03:20:58 <tdammers> and it turns out that doing it this way makes all sorts of things easier to prove
03:21:02 <[itchyjunk]> ah i see
03:21:12 <[itchyjunk]> oh, prove?
03:21:56 <tdammers> yes. haskell programs don't usually get subjected to formal proof, but many of the concepts that went into the design of the language were / are
03:22:34 <tdammers> haskell takes occasional liberty, but in generally, it is built on a fairly solid theoretical foundation
03:22:42 <tdammers> s/generally/general/g
03:23:02 <tdammers> that's part of what makes it a productivity superweapon in the right hands
03:23:13 <[itchyjunk]> ah
03:23:28 <tdammers> you've probably seen examples of types that only suggest a very small handful of possible implementations
03:23:49 <tdammers> e.g., given this type :: Maybe a -- how many expressions can you write that would typecheck?
03:24:22 <tdammers> (keeping in mind that "a" is a type variable, which means the other side gets to pick, and any of their choices must be valid)
03:24:55 <[itchyjunk]> hm
03:24:59 <tdammers> the answer is that, apart from bottom / _|_ / undefined, there is only one that really works
03:25:36 <tdammers> we can only implement this as "Nothing" - the only other constructor from Maybe is Just, but Just needs an argument, and without knowing anything about a, we cannot get an a value from anywhere, so we cannot use Just
03:28:20 <__monty__> `id :: a -> a` and `const :: a -> b -> a` are similarly uniquely defined by their types.
03:30:16 <tdammers> so this kind of theoretical rigor is eventually super helpful in reasoning about code
03:30:33 <tdammers> and "all functions are unary" turns out to be a useful ingredient to that
03:30:50 <tdammers> because it keeps the number of rules in the system small
03:33:53 <[itchyjunk]> i see. benifits are not immidately obvious but in the long run you get a system built on fewer axioms and such i guess
03:35:06 <__monty__> [itchyjunk]: Some benefits are. Like the free "partial evaluation".
03:35:38 <[itchyjunk]> hm
03:36:47 <pragma-> look at what ni-semicolon is doing.
03:36:48 <pragma-> smh
03:37:35 <jle`> [itchyjunk]: note that 'functions only take one arguments' is only "mechanically" true, but not 'denotatively' true, in terms of how you interpret your values
03:37:54 <jle`> os it's easy to make a function in haskell that represents, mathematically, a function with two arguments
03:37:57 <jle`> *so
03:38:01 <jle`> @let plus (x,y) = x + y
03:38:03 <lambdabot>  Defined.
03:38:04 <jle`> > plus (1,3)
03:38:07 <lambdabot>  4
03:38:34 <jle`> so while the mechanics we use to implement 'plus' only requires "one argument" mechanics from Haskell ... arguably the function we are trying to describe, and the fucntion as any human would interpret it as, is two-argument
03:38:38 <tdammers> yes. that's what I was talking about when I said "use tuples to emulate multi-argument functions in Haskell"
03:38:45 <[itchyjunk]> ah you're using tuples to cheat?
03:38:46 <[itchyjunk]> right
03:39:08 <tdammers> note however that the following would still "mechanically" be unary, but "denotatively" binary:
03:39:16 <tdammers> @let plus' x y = x + y
03:39:18 <lambdabot>  Defined.
03:39:21 <jle`> but even curried functions i would consider denotatively binary
03:39:23 <tdammers> > plus' 1 3
03:39:28 <lambdabot>  4
03:39:30 <jle`> (ah, just echoing exactly tdammers's point)
03:39:34 <tdammers> jle`: :D
03:39:40 <jle`> you don't need to use a tuple to basically *interpret* plus' as a two-argument function
03:39:51 <jle`> the mechanics to implement plus only requires single-argument syntax
03:40:02 <jle`> but to a human using plus' it is interpreted as a two-argument function
03:40:17 <jle`> there's a difference between the tools you need to implement something vs. the idea of the thing you  are trying to implement
03:41:03 <jle`> so in haskell we can represent the idea of a two-argument function no problem ... it's just a neat thing that we don't need any extra support for two-argument functions in the language itself
03:49:01 <[itchyjunk]> so i could say that thing you did was a sugar for actually using a unary function
03:53:24 <tdammers> not really, no - it was using a unary function (at the "mechanical" level) to represent a binary function (at the "denotative" or "interpreted" level)
03:54:07 <jle`> [itchyjunk]: you don't relaly need the sugar, you could write plus = \x -> \y -> x + y and it would still represent a binary function
03:54:17 <jle`> it's just using the language mechanics of single-argument functions to do it
03:54:58 <[itchyjunk]> hmm
03:55:09 <jle`> an example of this in another language is old fashioned C
03:55:17 <jle`> oldschool C doesn't have a boolean type
03:55:25 <jle`> but it has an int type
03:55:38 <jle`> so why make a new type when you could just use 0 to mean false, and 1 (or non-zero) to mean true?
03:56:00 <jle`> basically int is used as an underlying mechanic to represent the denotative idea of a boolean
03:56:53 <jle`> the difference here is that we have a 'perfect fit' kind of case, where the size of two-argument functions and the size of curried two-argument functions are identical
03:57:08 <jle`> whereas in C, int is much bigger than bool. so that's unfortunate for them.
03:57:15 <jle`> s/the/a
03:57:18 <[itchyjunk]> ah i see
03:57:54 <jle`> so here the underlying mechanic is 'single argument function', used to represent the idea of a binary function
03:58:02 <jle`> but the neat thing is that the type of both are identical in size, and isomorphic
03:58:57 <jle`> which makes it a bit theoretically nicer than my example in C. not to bash C or anything :)
04:04:35 <[itchyjunk]> hmm right
04:32:23 <merijn> Anyone know how inline-c/inline-c-cpp decide which compiler to use?
04:48:25 <boxscape> merijn maybe it just uses ghc as compiler? Though I'm not sure if ghc can compile C++
04:52:39 <boxscape> merijn it can, so I would assume that's what it does
05:09:20 <merijn> boxscape: ghc pre-8.10 doesn't know about C++ though, so it's just guessing :\
05:09:43 <merijn> ugh, I wish they'd just have provided a context that can specify which compiler to use
05:14:46 <boxscape> merijn hm, I seem to be able to at least get pretty far with compiling a hello world file in C++ with ghc 8.6.5 (though it eventually fails because it expects a different main)
05:15:26 <merijn> boxscape: That's because it blindly assumes that the gcc compiler it knows about is also a reasonable C++ compiler
05:15:50 <merijn> boxscape: Which may be the case on your system, but certainly isn't on mine
05:15:59 <boxscape> I see
05:16:43 <phadej> merijn: I guess it's not case for you to use some own wrapper around "gcc / c++ compiler"
05:16:59 <phadej> which would be a hack, but something you could live with
05:18:23 <merijn> phadej: Not if I want other people to compile this somewhat reliably
05:21:04 <phadej> yeah :/
05:21:11 <phadej> sharing hacks it tricky
05:32:54 <merijn> phadej: FYI, the 8.10 alpha doesn't seem to explicitly detect the C++ compiler in its configure script either
05:35:36 <merijn> phadej: Looks like there's no pgmcxx either, only optcxx
05:43:10 <phadej> non-excited "jei"
05:43:12 <specialunicorn[m> if everyone here is from irc, why is there a matrix bridge
05:43:35 <phadej> merijn: I guess you should open issue about that then
05:44:09 <merijn> phadej: Yeah, I was already bugging people in #ghc :p
05:46:41 <phadej> opening issue, and pinging there the authors & committers of optcxx patch would leave better trail :)
05:47:02 <phadej> after all, ghc-8.10 is still in alpha, and you can say "this is not good enough"
05:48:20 <phadej> using different C and C++ compiler is non-common, but I can see why you sometimes might want that
05:48:22 <maerwald> anyone knows when 8.8.2 will hit?
05:48:47 <phadej> maerwald: it got RC, so I guess "soon"
05:49:04 <maerwald> the compacting bug made us roll back to 8.6.5
05:50:09 <yasar> Assume I have found a library module function for downloading http resources. If I map that function over a list of 1000 urls, will they be downloaded all at once, or one at a time?
05:51:00 <merijn> phadej: Yeah, I was already opening a ticket for it too :p
05:51:31 <merijn> phadej: Our university cluster still ships clang 3.4 and gcc 4.8 :(
05:52:37 <merijn> So I can't even rely on reasonable things like -std=c++11 without overriding the compilers >.>
05:53:33 <maerwald> the oldest clang on my distro is 8, lol
06:01:12 <yasar> There is one such function in here: https://hackage.haskell.org/package/HTTP-4000.3.12/docs/Network-HTTP.html
06:07:35 <yasar> For example, if I do `map (\x -> simpleHTTP (getRequest x)) [list of urls]`
06:07:50 <yasar> will I be starting lots of requests at the same time?
06:08:52 <boxscape> yasar that would only produce a list of un-executed IO actions, you probably want something like mapM
06:10:34 <yasar> boxscape, aside from that issue, how can I manage the execution of those IO actions? I don't want to look like I am DDOS'in servers
06:10:42 <day> has anyone done the AoC16 quiz? http://paste.debian.net/1121250/ Task1 works, but task2 seemingly doesn't, i am guessing that haskell isnt optimizing it properly and things blow up resource wise
06:10:52 <boxscape> yasar imagine it would start as many requests as you have items with mapM, and wait with the second one until the first one is finished, and so on. Though I'm not sure.
06:11:00 <boxscape> s/imagine/I imagine
06:12:11 <nil> day: you need to be a bit smarter about the approach for part 2
06:12:29 <day> in general or in haskell?
06:12:39 <nil> in general
06:12:52 <day> hm i see.
06:13:15 <nil> your algorithm for part 1 performs in O(n^2) (roughly). part 2 involves n = 6500000, so n^2 = a lot
06:17:02 <day> i guess it was obvious~
06:17:59 <day> but being on a raspberry and using an unknown language makes seeing things in perspective difficult
06:20:12 <day> nil: i assume i can reduce it to O(n) n log(n) ? 
06:21:09 <merijn> boxscape, yasar: I actually wrote something to handle rate limiting like that :p
06:21:36 <merijn> https://hackage.haskell.org/package/broadcast-chan-0.2.1/docs/BroadcastChan.html#g:4
06:21:49 <merijn> There's also a conduit version which is nicer
06:22:17 <boxscape> nice
06:23:20 <merijn> https://hackage.haskell.org/package/broadcast-chan-conduit-0.2.1/docs/BroadcastChan-Conduit.html#v:parMapM
06:38:17 <yasar> Executable for this program is 15MB in size: https://gist.github.com/yasar11732/d2c5e0a583bd68ed4b0eb6dfed8f4016
06:38:30 <yasar> Isn't that too much for a simple program like that?
06:38:38 <f-a> yasar: strip it/
06:40:04 <yasar> Stripping reduces it to 5MB
06:40:29 <yasar> Still looks large, is that expected?
06:40:41 <nil> try dynamic linking if executable size is a concern
06:40:56 <dmwit> Haskell executables are generally large. Dynamic linking and -fsplit-objs can help.
06:41:25 <f-a> f@x60s:/tmp$ ls -lh prova
06:41:26 <f-a> -rwxr-xr-x 1 f f 632K Dec 16 15:40 prova
06:41:30 <f-a> you are on win, right yasar /
06:41:31 <f-a> *?
06:41:43 <yasar> yes
06:42:04 <f-a> I just released a small game, and for some reason linux exe was 1.6 and win more than double
06:42:14 <f-a> macOS being the lighter one
06:43:02 <yasar> Hmm, maybe windows doesn't support some of the features and replacement had to be statically linked into exe
06:46:04 <[exa]> yasar: passing -dynamic to the ghc here reduces exe size from ~2MB to ~25kB on the program you sent
06:47:22 <yasar> Mine says -> Perhaps you haven't installed the "dyn" libraries for package `bytestring-0.10.8.2'?
06:47:51 <nil> smells of arch linux
06:48:06 <yasar> Haskell Platform on Windows
06:48:13 <nil> wait no, arch is the opposite
06:49:02 <MarcelineVQ> the arch error is also a little more obscure, it complains about missing files in packages despite the error being a dyn/static one
06:53:28 <[exa]> yasar: may you check whether 'cabal install bytestring' went okay? (i.e. whether the files are really there)
07:04:45 <yasar> [exa] I didn't install it manually, it came with haskell platform I suppose
07:11:35 <Phyx-> yasar: Windows GHC doesn't support dynamic linking yet
07:11:52 <Phyx-> my local copy does but haven't had the time to clean it up and upstream it
07:11:54 <yasar> Phyx- Ohh
07:36:27 <yasar> is there a way to step through code in ghci?
07:36:35 <enus[m]> When using Bootstrap in a Scaffold project in Yesod; Do you need to rewrite the Bootstrap snippets into Hamlet?
07:36:49 <f-a> yasar: yes, :step
07:37:30 <f-a> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#single-stepping 
07:37:40 <f-a> or even better, use the `debug` package, very useful
07:38:46 <geekosaur> stepping through code is complicated somewhat by Haskell tending toward complex expressions (even if they look like separate "commands")
07:39:31 <f-a> oh and of course you can use traceShow, if you are not already using it
07:44:04 <Rembane> Is there a smallest unit of evaluation in GHC? 
07:44:15 <yasar> I am getting "Qualified name in binding position" error on line 10: https://gist.github.com/yasar11732/f766cdd46995c74d0f16ce49bcad860e#file-highestclose-hs-L10
07:44:39 <Rembane> yasar: Should there be L.Empty instead?
07:46:16 <yasar> Supposed to be `empty` I guess : https://hackage.haskell.org/package/bytestring-0.10.10.0/docs/Data-ByteString-Lazy-Char8.html#g:2
07:47:39 <geekosaur> Rembane, the easiest such is function entry points
07:48:02 <geekosaur> hypothetically one could instrument bytecode instructions in ghci, but I suspect that's too fine-grained
07:48:31 <geekosaur> also hypothetically I could see it using SCCs (profiling hooks)
07:48:42 <Rembane> geekosaur: It's a good start, but I don't think that's fine-grained enough, so something between bytecode instructions and function entry points. Does that level of grain exist?
07:48:47 <geekosaur> but SCCs default to function entry points and one would need to annotate
07:49:05 <geekosaur> I dont think so, that was my point about expressions
07:49:28 <geekosaur> you'd have to, for example, rebuild Prelude.map to get detail about what it's doing internally
07:50:10 <Rembane> Got it. 
07:50:31 <geekosaur> (that kindof thing is why the mention in the documen tation for the debug package that they never got Hat working; it was relying on ghc internals that kept changing on it, and also had to rebuild the Prelude and other libraries to trace them)
07:50:34 <Rembane> Trusting the semantics and using traceShow when the trust fails sounds like a much better approach imo 
07:51:34 <Rembane> yasar: You cannot pattern match on functions, so you first need to run the function and then pattern match on the result 
08:18:39 <dminuoso> Mmm, is there some idiom to partition a vector/list of things into *multiple* vectors/lists?
08:19:25 <Rembane> dminuoso: partition? Or partition on speed? 
08:19:31 <Rembane> :t partition
08:19:33 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
08:20:05 <MarcelineVQ> dminuoso: a sort of splitOn ?
08:20:29 <solonarv> if you don't mind working with just lists, there is
08:20:31 <dminuoso> No rather like partition, but instead of partitioning into two things, I rather want to partition into 5 buckets.
08:20:34 <solonarv> @hackage split
08:20:34 <lambdabot> http://hackage.haskell.org/package/split
08:20:49 <phadej> dminuoso: discrimination by ekmett
08:21:16 <phadej> i'd try if it fits your problem
08:21:42 <Rembane> dminuoso: I do it recursively until I have enough partitions.
08:23:29 <boxscape> discrimination sounds vaguely magical with its nub in linear time and such
08:23:53 <phadej> but it works :)
08:24:32 <phadej> watching the video about it also uncovers some of the magic
08:24:48 <boxscape> that makes sense
08:24:51 <boxscape> I should do that
08:26:15 <solonarv> phadej: link?
08:26:51 <boxscape> https://www.youtube.com/watch?v=sz9ZlZIRDAg is linked on the hackage page
08:27:30 <solonarv> ah, thank you
08:31:22 <boxscape> is there a difference in usage between "value-level" and "term-level"
08:33:13 <dminuoso> phadej: Thanks! It seems to be exactly what I was looking for.
08:33:24 <dminuoso> Or at least very close, it's usable for my case.
08:33:54 <dminuoso> (Though curious discriminators must have some restrictive dependencies, as it caused recompilation of quite a few dependencies)
08:34:02 <dminuoso> *discrimination
08:34:02 <boxscape> (Whoops have to log off actually but I'll check the logs later to see if anyone responded)
08:40:02 <dminuoso> phadej: Yes its superb! Thanks.
08:54:26 <phadej> cheers
08:55:00 <phadej> discrimination doesn't seem to allow hashable-1.3, so that prolly caused the recompilation
08:55:37 <phadej> let me see, if I can help that
08:55:47 <bahamas> is there any haskell library that would allow me to quickly get the headers and subhearders out of an epub file? maybe pandoc?
08:58:01 <bahamas> looks like it might
09:01:08 <maralorn> I got told that I should favor Map over HashMap (in most cases). So I wanted to switch my library to that, but realized I get my data as a Aeson.Object which already is a HashMap. So now I wonder. Is it worth converting it?
09:03:09 <MarcelineVQ> Did they tell you why?
09:06:33 <bahamas> maralorn: ^
09:10:36 <oats> when doing a destructuring binding in do notation (like: "[foo, bar] <- someAction"), is it required that MonadFail be implemented?
09:12:34 <phadej> oats: with 8.8, yes
09:13:35 <phadej> if GHC thinks that pattern match may fail
09:14:04 <solonarv> MonadFailDesugaring is on-by-default in 8.6 already, isn't it?
09:14:16 <oats> phadej: is that when the MonadFail proposal was fully implemented?
09:15:02 <phadej> solonarv: you're probably right, in 8.8 fail was removed from Monad; so in GHC-8.8 MFP is fully implemented, yes
09:15:19 <solonarv> just checked and indeed it is on by default in 8.6
09:15:26 <phadej> I don't remember the details, as MonadFailDesugaring is quite old extension already
09:15:45 <solonarv> my test consisted of typing some code that should fail wih MFD into ghci ;)
09:32:49 <maralorn> MarcelineVQ: My takeaway was that Map is quite efficient for not huge structures and as long as my keys are Ord it‘s actually more efficient to not do the hashing. Which sounds reasonable to me: a HashMap always feels like it has a big fixed cost.
09:50:22 <amx> maralorn: this smells like premature optimization anyway
09:51:09 <maralorn> amx: In every direction?
09:51:17 <maralorn> It‘s true.
09:57:47 <amx> with algorithmic complexity being the same the answer to 'is a faster than b' almost invariably requires profiling/benchmarking, otherwise it's just a guessing game
09:58:51 <amx> and on a personal note: life is short. if it ain't broke, don't fix it :P
10:00:34 <Nico25> can someone experienced with haskell look over these 5 lines of code to say what is wrong with them? https://gist.github.com/KSKNico/a48c2a8f21ed2b0fea5a9d614671fbb4
10:02:52 <nil> this code runs fine in my ghci
10:03:04 <nil> what's on line 85?
10:03:31 <Nico25> really?
10:03:50 <Nico25> sorry, i think you have to run it with rotate' -1 [1,2,3]
10:03:50 <nil> yes, there's nothing wrong with it
10:04:00 <nil> you need parens around (-1)
10:04:07 <Nico25> fug
10:04:09 <Nico25> ok thank you
10:04:10 <Nico25> lol
10:05:41 <phadej> amx: one can argue that Map is better default
10:05:59 <phadej> the fact things are ordered, makes things behave more deterministically
10:06:15 <pepzi> exit
10:06:17 <pepzi> exit
10:06:19 <pepzi> :q
10:06:20 <pepzi> :q
10:06:35 <phadej> /quit
10:13:16 <shafox> anyone using hie with emacs rather than haskell-mode ? What are the advantages/disadvantages ?
10:14:09 <pepzi> lol, sorry about that.. I was in a tmux session that was 2x2 characters large.. was trying to exit vim.. :)
10:14:34 <pepzi> i do know how irc works, but thanks phadej :)
10:17:05 <solonarv> phadej: good point
10:17:15 <solonarv> also, Map just has a larger API
10:17:39 <solonarv> on a few occasions while using HashMap I have found myself reaching for a function that Map has but HashMap doesn't
10:53:32 <amx> phadej: I don't disagree :)
10:55:40 <yasar> when I try `:m +Text.Regex.Posix` I am getting `Couldn't find module` error.
10:55:49 <yasar> isn't it part of the standart libraries?
10:56:20 <dsal> That doesn't sound like it should be anywhere near stdlib.
10:56:36 <dsal> Yeah, it's in http://hackage.haskell.org/package/regex-posix
10:56:59 <dsal> I've used one of the regex things before.  I'm glad I'm using fewer now.  :)
10:57:45 <yasar> is there a way to list all the modules that I can import?
10:58:22 <dsal> Hmm...  Not that I know of.  There are lots of dependencies in third party packages you can add.  I just list the deps per project as I go.
10:58:28 <amx> yasar: IIRC you are using haskell platform, it should be part of that
10:58:32 <dansho> how can i write a function (g -> (a, g)) -> g -> [a]
11:02:22 <yasar> I only seem to have `Text.Read` and `Text.Show`
11:03:33 <amalloy> dansho: that looks like an unfold without a stopping condition
11:04:20 <dsal> amx: const []    ?
11:05:01 <amx> yasar: you can list modules with :m +<TAB>. I have no experience with the platform, I just add a dependency to the cabal file of my current project, cabal build, cabal repl and go on.
11:05:17 <dsal> Oh, sorry.  dansho   But yeah, you cold unfold forever.
11:05:19 <dsal> Which is fine.
11:07:08 <heebo> depends who is answering
11:09:49 <tabaqui1> do you know a function with such signature (I cannot find it via hoogle): "(Monad m, Monad n) => (a -> m (n b)) -> n a -> m (n b)"?
11:10:00 <dsal> > let unfolderate f g = let (a,g') = f g in a : unfolderate f g'  in take 5  $ unfolderate (\n -> (n+1,n+2)) 3 -- dansho  ?
11:10:03 <lambdabot>  [4,6,8,10,12]
11:10:19 <tabaqui1> like, I want to iterate over a list in monadic way, but with side effects from other monad
11:10:55 <dsal> What do you mean "iterate in a monadic way"?  If it's just a list, you can use transverse.
11:11:02 <dsal> er, traverse
11:11:50 <tabaqui1> I want that first argument would be like (\x -> print x; if x == 2 then [] else [x]) or somewhat
11:12:08 <tabaqui1> traverse doesn't change the inner structure
11:13:15 <tabaqui1> I dunno, it is not a complicated function, but I was sure that it already exists
11:13:21 <dansho> dsal: thanks, i ended up with this https://hastebin.com/kexiyukebu.hs
11:14:52 <dsal> > let unfolderate f = unfoldr (Just . f)   in take 5  $ unfolderate (\n -> (n+1,n+2)) 3 -- dansho yeah, if you want  to  use unfoldr, that's   `Just . f`
11:14:55 <lambdabot>  [4,6,8,10,12]
11:15:36 <tabaqui1> \f -> foldM (\a b -> (a <>) <$> f b) mempty
11:15:41 <dsal> tabaqui1: it seems a little odd mixing effects from different things.  You can stack them, but separating them makes sense.
11:15:41 <tabaqui1> %t \f -> foldM (\a b -> (a <>) <$> f b) mempty
11:15:56 <tabaqui1> >:t \f -> foldM (\a b -> (a <>) <$> f b) mempty
11:16:38 <Clint> do you just want to run concat on the output of mapM?
11:16:39 <tabaqui1> % :t \f -> foldM (\a b -> (a <>) <$> f b) mempty
11:16:39 <yahb> tabaqui1: (Foldable t1, Monad m, Monoid b) => (t2 -> m b) -> t1 t2 -> m b
11:16:57 <tabaqui1> Clint, mapM doesn't change inner structure
11:17:03 <tabaqui1> you cannot resize the list, for example
11:17:19 <heebo> im giving up on using Vinyl its too frigging confusing!
11:18:38 <tabaqui1> ah, nevermind, this one does the thing
11:21:07 <Clint> % print =<< concat <$> (mapM (\x -> do print x; return (if x == 2 then [] else [x])) $ [1,2,3])
11:21:07 <yahb> Clint: 1; 2; 3; [1,3]
11:22:13 <Clint> % print =<< catMaybes <$> (mapM (\x -> do print x; return (if x == 2 then Nothing else Just x)) $ [1,2,3])
11:22:13 <yahb> Clint: 1; 2; 3; [1,3]
11:23:19 <tabaqui1> dunno, I thought about using "join" here
11:24:05 <tabaqui1> so it is "\f l -> join <$> mapM f l"
11:24:10 <tabaqui1> % :t \f l -> join <$> mapM f l
11:24:10 <yahb> tabaqui1: (Traversable m, Monad m, Monad f) => (a1 -> f (m a2)) -> m a1 -> f (m a2)
11:25:10 <tabaqui1> right, this one is nicier, thanks
11:29:57 <fendor> can I install an executable with `--enable-profiling`? e.g. `cabal install exes --enable-profiling` and then invoke the executable with `+RTS -xc`? 
11:30:37 <dsal> I don't bother installing when I'm doing that, but I don't see what would stop you.
11:32:12 <fendor> I think it doesnt work. when I only do install, then it says the executable has not been built with -fprof
11:33:09 <dsal> I don't know the cabal tools well, but you can have a profile-enabled executable installed in general.
11:33:19 <fendor> ok, thanks!
11:34:06 <cocreature> fendor: cabal new-run should work afaik, not sure what installing changes
11:35:01 <fendor> cocreature, yeah, running does work, but I would prefer an executable on my path
11:35:37 <cocreature> fendor: maybe just copy it? at least if it’s statically linked and doesn’t use data-files that tends to work
11:37:13 <fendor> unfortunately, the project has data-files
11:38:52 <fendor> welp: https://github.com/haskell/cabal/issues/5982
11:39:21 <cocreature> :(
11:39:39 <fendor> I can probably just create a symlink into my dist/ folder
11:40:16 <yasar> I can install regex-posix with stack, but using cabal I get conflicts
11:40:34 <yasar> If I don't want to use stack, should I update my ghc version?
11:41:23 <fendor> yasar, depends on the error message
11:42:46 <fendor> I do not get a conflict when installing regex-posix
11:43:52 <oats> Is there a quick way to convert from a Seq to a Set without an intermediate list?
11:45:01 <ChaiTRex> oats: I haven't used Seqs. Are there folds defined on them? If so, you could insert each element into a Set.
11:45:15 <oats> ChaiTRex: yeah, they're foldable
11:45:23 <Clint> fold 'em
11:45:48 <yasar> fendor, this is the full error message: https://gist.github.com/yasar11732/9d6cc16ebd0f289e3644eb9276cbaba7
11:47:09 <fendor> yasar, oh you are on windows? what are your versions for ghc and cabal? And why do you want to install regex-posix?
11:48:02 <yasar> I was trying to follow this tutorial: http://book.realworldhaskell.org/read/efficient-file-processing-regular-expressions-and-file-name-matching.html
11:48:18 <yasar> my ghc version is 8.6.5
11:48:34 <yasar> cabal version 2.4.1.0
11:49:12 <yasar> I also can't install regex-base or regex
11:49:30 <sclv> where dies
11:49:31 <sclv> Mm
11:49:47 <sclv> where does that “directory” constraint come from
11:50:02 <fendor> yasar, that is new enough. You should probably create a project for that, e.g. `cabal init` and modify your `*.cabal`, such that the build-depends contains regex-posix
11:50:13 <fendor> but i have to go, will be back soon
11:50:39 <oats> mmmm
11:50:43 <yasar> sclv, I am very new to this. I have no idea what is going on :)
11:50:43 <oats> foldMap Set.singleton
11:50:46 <oats> that's nice
11:51:33 <oats> :t foldMap Set.singleton
11:51:36 <lambdabot> error:
11:51:36 <lambdabot>     Not in scope: ‘Set.singleton’
11:51:36 <lambdabot>     Perhaps you meant one of these:
11:51:47 <oats> hmm
11:51:55 <ChaiTRex> @let import qualified Data.Set as Set
11:51:58 <lambdabot>  Defined.
11:52:10 <oats> how long do those last?
11:52:23 <ChaiTRex> oats: The @lets until someone runs @somethingIforgot
11:52:34 <oats> hehe
11:52:40 <oats> :t foldMap Set.singleton
11:52:42 <lambdabot> (Foldable t, Ord a) => t a -> Set.Set a
11:52:57 <sclv> hrm looks like there’s an artificially high bytestring constraint screwing things up
11:53:21 <sclv> yasar: my advice is to learn to use new-build
11:53:41 <sclv> or figure out where the bytestring constraint comes from
11:53:56 <yasar> sclv I was playing with bytestrings earlier, I probably installed newer version
11:54:01 <yasar> can I downgrade it
11:54:37 <sclv> you can ghc-pkg unregister it
11:54:42 <sclv> or just hide it
11:54:48 <sclv> The old one is still there too
11:58:56 <dsal> :t foldr Set.insert mempty
11:58:58 <lambdabot> (Foldable t, Ord a) => t a -> Set.Set a
12:00:10 <dsal> oats: ^
12:00:57 <dsal> Though who knows what that <> ends up doing.  For all I know both of these work the same way.
12:01:22 <yasar> sclv, `ghc-pkg unregister bytestring-0.10.10.0` -> `ghc-pkg: cannot find package bytestring-0.10.10.0`
12:01:32 <oats> guess what, "foldMap Set.singleton" is faster than "foldr Set.insert Set.empty"
12:01:33 <olligobber> Pretty sure <> does set union, which on a singleton would be the same as insertion
12:01:34 <oats> that's interesting
12:01:41 <olligobber> ok I'm wrong
12:02:08 <dsal> oats: As usual, intuition is a failure.
12:02:24 <dsal> The foldMap can be parallelized, I suppose.
12:02:42 <oats> dsal: I thought ghc doesn't automatically do parallelization
12:04:10 <dsal> *shrug* it wouldn't be ghc, but whatever mconcat is doing.  I'm kind of curious how they differ.
12:06:27 <ChaiTRex> There are probably cool tricks for creating a union quickly. Like if Sets are trees, then you can perhaps insert an entire branch somewhere and be done with that part of the tree.
12:07:27 <dsal> Intuitions seem to be wrong a lot.  I should get better ones.
12:12:14 <sclv> yasar: so something is demanding that vers of bytestring, idk what?
12:12:37 <sclv> is yr command just ‘cabal-install regex-posix’?
12:14:36 <yasar> sclv, I jusr remove %HOME%/.ghc directory and %APPDATA%/cabal/config files. It seems to be working now.
12:15:04 <sclv> ok, good
12:15:28 <yasar> For future reference, was it an error on my part?
12:24:29 <dmwit> :t Set.fromList
12:24:31 <lambdabot> Ord a => [a] -> Set.Set a
12:25:33 <dmwit> This is likely another case where foldb will be better than foldr.
12:26:06 <dmwit> https://gist.github.com/dmwit/6dce178eab1988fc7219153534ad8788
12:26:13 <dmwit> For exactly the reasons ChaiTRex was saying.
12:28:45 <yasar> Now I can find the regex-posix package in cabal's store directory. But can't load it into`ghci`
12:32:29 <dmwit> One way is to use `cabal install --lib` to install it to a GHC environment, then start ghci with that environment. Another is to create a cabal package that depends on it, and use `cabal repl` to load an instance of ghci that has access to all the dependencies.
12:32:40 <dmwit> er
12:32:59 <dmwit> `cabal v2-repl`, if you don't have the newest cabal
12:33:32 <dmwit> (and v2-repl will succeed on the newest, so it's safe to use that if you're not sure)
12:37:36 <fendor___> dmwit, yasar said that their cabal version was 2.4, so, they should use the v2-* prefixes
12:43:11 <cdunklau> Hi folks, I'm having trouble forming this question to be googlable, so i hope you'll forgive the probably basic question: say i have oper = (a -> a -> a -> a) and i have a three-element list (or, heck, a triple). how do i shove the list/triple in as args? uncurry does it for pairs... this seems kinda like a map
12:45:01 <cdunklau> that is, the end result i want is... with the list [3, 5, 7], i want (oper 3 5 7)
12:45:12 <ephemient> :t Data.Tuple.Extra.uncurry3
12:45:15 <lambdabot> (a -> b -> c -> d) -> (a, b, c) -> d
12:45:40 <amalloy> yeah, you want to do it for tuples, not lists
12:46:07 <amalloy> the operation on a list can't be type-safe, because a list can't be known to have exactly 3 elements at the type level
12:46:14 <cdunklau> amalloy: makes sense
12:46:16 <cdunklau> ephemient: thanks!
12:47:50 <RSWilli> hey guys, I'm pretty new to haskell, and I'm trying to get hie with vscode on linux to work. my problem is, that I upgraded cabal to v3, and hie doesn't support that. How do I properly downgrade cabal with ghcup? i tried `ghcup install-cabal 2.4.0.0` but the cabal-install was not installed to the specified folder
12:48:31 <fendor___> RSWilli, I would not suggest downgrading your cabal-install
12:49:20 <RSWilli> so what do I do to downgrade cabal then?
12:50:35 <RSWilli> @fendor what else do you suggest?
12:50:35 <lambdabot> Unknown command, try @list
12:51:15 <fendor> RSWilli, I am thinking :D We currently have an experimental branch that supports cabal 3.0 and will be merged soon into haskell-ide-engine
12:51:44 <fendor> I am hesitant to suggest it to you, though, since there might be hiccups that are frustrating for you 
12:51:56 <fendor> and with soon, I mean by the end of the week
12:52:56 <fendor> so, maybe it would be indeed better to downgrade cabal-install for some time...
12:53:29 <Zer000> How do I make my script print "Done. Returning."? http://dpaste.com/3ABK52V
12:55:25 <fendor> Zer000, in your script, you are killing the thread before printing "Done.". So, you could increase the sleep time in your main?
12:56:03 <RSWilli> fendor I would rather wait until the end of the week, my tiny AOC 2019 programs wont be upset I think, thanks!
12:56:41 <fendor> RSWilli, ok, should I send you a message when support has been added?
12:57:54 <Zer000> fendor, that is intentional. Is there a way to suppress the ThreadKilled exception for a block of code?
12:58:37 <Zer000> In my actual code, it is ok for a thread to be killed while waiting for a TCP message, but once it has and started processing it, it should finish processing it.
12:59:53 <fendor> ok, I think you can mask an all exceptions in a certain code block, but I think this is not suggested. 
13:00:25 <Zer000> Well in my case even uninterruptibleMask didn't work neither did mask
13:00:30 <Zer000> so what are my options?
13:01:35 <Zer000> I can't just used a shared variable (like TVar) to tell my thread to close because it is hanging there, busy reading from TCP
13:01:58 <fendor> I suppose it should have worked...
13:02:13 <fendor> I think a cleaner solution would be to send a close message to the socket
13:02:57 <Zer000> fendor, from another thread?
13:03:05 <fendor> so when your thread reads the close operation it knows to terminate and if it is currently processing something from tcp, then the connection will be closed after it
13:03:06 <fendor> yeah
13:03:09 <Zer000> Hmm... I can't do that
13:03:14 <Zer000> I might still need to send on it
13:03:25 <RSWilli> fendor I would love that! Is there any repo I can watch to see the progress?
13:04:01 <fendor> RSWilli, the PR is https://github.com/haskell/haskell-ide-engine/pull/1126
13:04:23 <dsal> Zer000: If kill doesn't kill in general, that's a problem.  A soft signal would be much better.  i.e., the thread can ask whether it should exit.
13:04:37 <dsal> Something like STM listening for a work to do or a quit signal would be easy to model.
13:05:46 <Zer000> dsal, The thread in question can die, but there needs to be some guaranteed resource cleanup
13:06:01 <dsal> That's what bracketing is for.
13:06:35 <RSWilli> fendor thanks!
13:07:29 <Zer000> yes but my case is a little bit different. I don't want to exit from a block of code and run something else on exception, I want it to FINISH and then rethrow the exception
13:08:17 <fendor> Zer000, in my opinion, you can achieve this by splitting the logic up into a thread that only reads from the tcp stream and sends the messages via a channel to some other thread that processes stuff
13:08:58 <fendor> and when the tcp thread dies, it sends a final message via the channel
13:09:15 <fendor> and the thread reading from the channel can finish the work and exit then
13:10:02 <Zer000> fendor, Ok. I was starting to think that even more threads might be the answer. Thanks
13:10:44 <fendor> it is just an idea which I have implemented before. maybe it is helpful?
13:11:00 <Zer000> well haskell threads are cheap so its no big deal
13:11:06 <fendor> exactly
13:11:38 <dsal> This is what I meant by "doing work" vs. "receiving signal".  async makes some of this easier, but it's still a lot easier in erlang.
13:19:21 <Zer000> I wonder if in Python, if you put code in a "finally" block another thread can still kill it
13:19:59 <dsal> :t finally
13:20:01 <lambdabot> IO a -> IO b -> IO a
13:22:20 <dsal> Zer000: I think a lot of your answers are in http://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Exception.html -- but I'd still consider  a different model.  Running much of your work masked is going to lead to different kinds of problems.
13:30:05 <wildtrees> Ok trying Data.Map.lookup with traverse over a list of keys, thought one nothing seems to make the whole thing fail, is there a way around that? or do I need something other than traverse for that?
13:31:05 <ChaiTRex> wildtrees: What code is failing on one Nothing?
13:31:18 <RSWilli> wildtrees you could try Data.Map.findWithDefault
13:31:31 <RSWilli> :t Data.Map.findWithDefault
13:31:32 <lambdabot> Ord k => a -> k -> M.Map k a -> a
13:31:52 <wildtrees> no traversing a list, one nothing will cause the whole result to be nothing 
13:36:23 <wildtrees> mmm catMaybes . fmap seems to work like how I wanted 
13:36:49 <__monty__> Sounds like a fold more than a map.
13:38:26 <ButIWantedAPony> Hello! I have a thread which should call a specific function every, say, 30 minutes. But there is also another thread which can raise an event to force first thread calling this function earlier. What is the best way to represent this with `STM`?
13:39:33 <ChaiTRex> :t traverse
13:39:36 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
13:40:56 <glguy> ButIWantedAPony: You can use a TVar for setting things off early and registerDelay for the timer. read from both in a single transaction
13:41:43 <wildtrees> > let lookie key = lookup key [("a",1),("b",2),("c",3)] in let list = ["a","b","d"] in (traverse lookie list,catMaybes . fmap lookie $ list) 
13:41:45 <lambdabot>  (Nothing,[1,2])
13:42:00 <wildtrees> just playing around trying to learn more about traverse 
13:42:26 <ButIWantedAPony> I see, thank you!
13:43:37 <amalloy> wildtrees: mapMaybe f = catMaybes . map f
13:45:36 <ChaiTRex> > let lookie key = lookup key [("a",1),("b",2),("c",3)] in let list = ["a","b","c"] in (traverse lookie list,catMaybes . fmap lookie $ list)
13:45:39 <lambdabot>  (Just [1,2,3],[1,2,3])
13:46:01 <wildtrees> amalloy, never knew about mapMaybe, thank you 
13:48:00 <xenon-> :t mapMaybe
13:48:02 <lambdabot> (a -> Maybe b) -> [a] -> [b]
13:48:04 <ChaiTRex> Looks like the return type of traverse there is Maybe [b] rather than [Maybe b], so I think it would naturally return Nothing if you get any Nothings. Otherwise, the result would never be Nothing, it would be Just [...] in all cases and then there's no need for the Maybe.
13:48:55 <solonarv> wildtrees: catMaybes . fmap f = mapMaybe f
13:49:17 <solonarv> oh, I see that was already suggested ;)
13:49:25 <wildtrees> solonarv, thank you , and yes :) 
13:49:53 <amalloy> wildtrees: i only know about it because hlint always complains when i write catMaybes . map f $ xs
13:51:41 <untseac> hey. Silly question. Why doesn't stack have binaries instead of compiling every time?
13:51:51 <untseac> because it's more compatible that way?
13:52:30 <xenon-> > map (lookup "foo") [[("foo", "bar")], [("foo", "baz")], [("bar", "baz"]]
13:52:33 <lambdabot>  <hint>:1:71: error: parse error on input ‘]’
13:52:48 <xenon-> > mapMaybe (lookup "foo") [[("foo", "bar")], [("foo", "baz")], [("bar", "baz")]]
13:52:50 <lambdabot>  ["bar","baz"]
13:54:11 <untseac> btw this is the best haskell "book" I've found: http://dev.stephendiehl.com/hask/
13:54:11 <wildtrees> thats kinda confusing when you first look  at it xenon- 
13:54:36 <xenon-> yeah. I've used catMaybes + map often. didn't know about mapMaybe
13:54:37 <tdammers> untseac: it's great, though I wouldn't recommend it as the first/only resource for an absolute beginner
13:54:48 <xenon-> not sure how I feel about it yet =)
13:56:40 <wildtrees> xenon-, meant more with having foo twice and baz twice 
13:58:24 <xenon-> oh, I see. I can see how that could be confusing. I was focused more on the types
13:59:00 <wildtrees> thought the lookup of foo, was happening twice returning two different results at first 
13:59:09 <wildtrees> till I stared at it 
14:26:36 <thenexd_> Is there a method turning [1, 2, 2, 2, 2, 4, 4, 1, 1, 1, 0] into [1, 2, 4, 1, 0]? (Removing equal adjacent elements)
14:27:18 <Rembane> thenexd_: head . group 
14:27:45 <Rembane> Oh no, I forgot! 
14:27:48 <Rembane> thenexd_: map head . group 
14:27:55 <DylThi> was about to say :P
14:28:37 <wildtrees> > nub [1,2,2,2,2,4,1,1,1,0] 
14:28:39 <xenon-> safe use of head, too
14:28:40 <lambdabot>  [1,2,4,0]
14:28:55 <wildtrees> > nub . sort $ [1,2,2,2,2,4,1,1,1,0] might be more what you want 
14:28:59 <lambdabot>  error:
14:28:59 <lambdabot>      • Variable not in scope: might
14:28:59 <lambdabot>      • Perhaps you meant one of these:
14:29:08 <wildtrees> > nub [1,2,2,2,2,4,1,1,1,0,2,2,2] 
14:29:10 <lambdabot>  [1,2,4,0]
14:29:18 <wildtrees> oh guess not 
14:29:22 <xenon-> nub returns all duplicates, not just adjacent ones
14:29:33 <xenon-> nub REMOVES all duplicates, not just adjacent ones
14:37:19 <EvanR> wait wait ... foldb (<>) on singleton Sets is better than fromList ?
14:38:12 <oats> could I get some criticism for my advent of code day 3 solution?
14:38:17 <oats> https://paste.xinu.at/uWUfQ/hs
14:38:22 <EvanR> also i have been wondering about a typeclass or something which comprehends a data structure by splitting it instead of unconsing it
14:53:32 <DylThi> oats: I think your solution looks real nice
14:53:59 <DylThi> Mine had a bunch of messy explicit recursion instead of the scanl and Linear.V2
14:55:32 <amalloy> yeah, overall quite good. i don't love the conversion from 2-lists to 2-tuples, though
14:55:55 <DylThi> Two nitpicks: 1. separating the parsing code from the IO and 2. replacing foldMap Set.singleton with Set.fromList, since the latter is much faster, at least on my machine
14:56:28 <DylThi> If you really wanted to keep the Foldable typeclass, you could use Data.Foldable's toList anyways and get the best of both worlds
14:56:30 <dsal> I didn't assume just two lines.  I don't think I suffered that much for  it.
14:57:33 <amalloy> i'm not sure whether Set.map is really all that great either - might as well just turn it into a list and then map the list
14:57:41 <dogweather> thenexd_: here's a functional ruby version that'd be easy to translate to haskell: https://gist.github.com/dogweather/09c305ba32db6787902aa68f43492bb2
14:59:01 <dogweather> (De-duping adjacent list elements)
14:59:45 <EvanR> functional ruby, this i gotta see
15:00:00 <dogweather> lol, it can be done
15:00:41 <EvanR> yeesh what is the performance of that
15:00:50 <dsal> I'm a bit surprised Set isn't a functor.
15:01:05 <EvanR> indeed it's not a functor by technicality
15:01:22 <dmwit> dsal: It is a functor, just not a Functor.
15:01:40 <dmwit> Specifically: it is a functor on the Ord subcategory of Hask.
15:01:41 <dogweather> :-) no idea about the performance - i use it on small web page lists of items. E.g., de-duping a user's browsing history
15:02:06 <dmwit> dsal: As witnessed by Data.Set.map.
15:02:36 <EvanR> ruby also comes with a de-duping method on array, .uniq
15:03:16 <dogweather> Yep. Key here, is -adjacents-. So not a full de-dup
15:03:41 <dsal> What prevents Set from having a Functor instance?  Is it that  stuff could be dropped in compositions?
15:03:50 <EvanR> in which case, map head . group :)
15:03:56 <dmwit> dsal: There are types which have no Ord instance.
15:04:32 <dmwit> dsal: (Think about, say, `fmap (+)`.)
15:04:33 <dsal> Oh, yeah, I see.  You can't add constraints.
15:04:51 <EvanR> rebuilding a Set possibly with fewer elements requires Ord
15:05:29 <EvanR> which means MultiSet might work for Functor
15:06:12 <amalloy> not just that it requires ord, but if you had ord you'd be breaking the functor laws: (fmap f . fmap g) may remove more elements than (fmap (f . g))
15:06:51 <dmwit> amalloy: Do you have an example that does not include breaking the Ord laws?
15:07:01 <amalloy> are there Ord laws?
15:07:02 <EvanR> hold the phone
15:07:07 <dmwit> amalloy: Yes.
15:07:23 <solonarv> the ord laws are: (<=) defines a total ordering
15:08:12 <EvanR> i could have sworn mapping between sets satisfies a homomorphism-like law
15:08:23 <dmwit> It does.
15:08:28 <EvanR> so what is amalloy saying
15:09:01 <solonarv> the breakage amalloy suggests happens only if the Ord instance for the intermediate type does quotienting and f observes differences between elements that compare equal
15:09:04 <amalloy> yeah, i think if you have an actual well-behaved Ord instance with a total ordering then what i say is untrue. i was imagining an Ord instance where there are observable differences between two values which compare EQ
15:09:24 <EvanR> that'd be weird
15:09:33 <EvanR> EQ but not ==
15:09:37 <EvanR> or something
15:09:41 <solonarv> nono, they are ==
15:09:45 <dsal> Some instances are more equal than others.
15:09:46 <EvanR> == but not EQ
15:09:53 <solonarv> they are both EQ and --
15:09:55 <solonarv> * ==
15:09:59 <solonarv> but not actually identical
15:10:19 <solonarv> imagine the following: instance Ord a => Ord (a, b) where compare = comparing fst
15:10:19 <EvanR> ok, then you could also restrict what f and g can know
15:10:21 <dmwit> (The Ord laws say total ordering, and (==) means EQ. And in my opinion, there are also Eq laws, saying x == y => f x == f y.)
15:10:36 <ChaiTRex> All my types implement (--)
15:10:41 <EvanR> quotients are too much brain candy
15:10:56 <solonarv> but Set itself is a quotient
15:11:07 <EvanR> uh what
15:11:18 <solonarv> well, the implementation in Data.Set is
15:11:21 <dsal> ChaiTRex: It's neat you get that for free without having to add an instance of something.
15:11:24 <solonarv> it's a balanced binary tree
15:11:33 <EvanR> sure
15:11:38 <solonarv> but equality checks etc. on it never observe the exact shape of the tree
15:11:46 <solonarv> which might vary depending on insertion order
15:12:04 <EvanR> that seems like a separate topic
15:12:05 <kronicmage> @free [a] -> a
15:12:05 <lambdabot> Try `free <ident>` or `free <ident> :: <type>`
15:12:11 <kronicmage> @free foo :: [a] -> a
15:12:11 <lambdabot> f . foo = foo . $map f
15:12:14 <monochrom> If Set is a functor, then size is not a natural transformation.  This is a formal way to say "fmap f may drop duplicate elements".
15:12:24 <dmwit> ?quote sprynge
15:12:25 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
15:12:38 <solonarv> ah, but in Ord-Hask the morphisms are strictly increasing functions
15:12:51 <kronicmage> @free foo :: (forall a. [a] -> a)
15:12:52 <lambdabot> f . foo = foo . $map f
15:13:00 <solonarv> and for those, Set is indeed a functor
15:13:05 <monochrom> strictly increasing? or just monotonic?
15:13:11 <solonarv> strictly
15:13:25 <solonarv> at least, I think
15:13:29 <dmwit> My Ord-Hask is a full subcategory of Hask.
15:13:48 <EvanR> now we jumped the shark
15:13:51 <solonarv> the law I am going for is f x `compare` f y = x `compare` y
15:14:10 <solonarv> perhaps this is more stringent than is strictly (heh) required
15:14:18 <MarcelineVQ> you darn kids and your extentionality
15:14:24 <EvanR> spryngent
15:14:33 <solonarv> but that way f can never introduce duplicate elements i.e. it must be injective
15:14:45 <solonarv> so $map f commutes with size
15:14:48 <dmwit> But why do you want to avoid duplicate elements?
15:15:07 <dmwit> Okay, Set can be a functor with mapMonotonic, too, I guess.
15:15:08 <monochrom> To rationalize size.
15:15:26 <dmwit> But, like... why is that preferable to the functor with map?
15:15:34 <dsal> mapMonotonic seems a bit caveat-laden
15:15:40 <solonarv> I don't know, I'm tired :>
15:15:42 <monochrom> I don't have an opinion here, I just want to point out that you have to make great sacrifices.
15:15:59 <solonarv> dsal: mostly because it is hard to write down "strictly increasing" at the type level
15:16:18 <monochrom> Greater sacrifices than "need (Ord a, Ord b)"
15:16:19 <dsal> And super easy to get wrong.
15:16:32 <dmwit> monochrom: ...do you?
15:16:46 <EvanR> sets amazing ability to dedup gets you some hilarious constructive math
15:17:00 <monochrom> Sorry, do I what?
15:17:09 <dmwit> Do you need to sacrifice more than "need (Ord a, Ord b)"?
15:17:53 <monochrom> Yes, as pointed out by everyone.  Accept "size is not a natural transformation", or accept "I only allow these special morphisms".
15:17:57 <EvanR> let's use multiset and call the whole thing off, until someone asks for "size"
15:18:14 <dmwit> monochrom: But it is not a sacrifice, if "size is not a natural transformation" was never an assumption or expectation in the first place.
15:18:25 <dmwit> And I don't understand who was assuming that.
15:18:28 <dmwit> I think nobody.
15:18:37 <dmwit> So the whole argument is bizarre.
15:18:47 <EvanR> if you assume no one wanted any operations this gets a lot simpler. size is a basic one
15:18:51 <monochrom> I am asssuming it.  BITE ME.
15:18:57 <dmwit> hm =)
15:19:07 <solonarv> operations are for people who want to actually do things!
15:19:13 <dmwit> EvanR: I assume size exists. But I do not assume that everything that exists is a natural transformation.
15:19:18 <solonarv> I don't know why people would want that
15:19:26 <EvanR> or for any structural interpretation of your theory
15:19:49 * solonarv flees into the bed
15:20:00 <monochrom> So I guess I have an opinion after all.  IMO size is structure-preserving so we should make it a natural transformation.
15:20:33 <monochrom> Or rather, IMO size is blind-to-elements.
15:20:34 <EvanR> structure preserving, i.e. fmap (const ()) ?
15:20:42 <monochrom> Yeah
15:20:51 <haskell`> I have three functions f :: Foo -> [String], g :: Foo -> [String], h :: Foo -> [String]. What is the most elegant way to combine them to a function r :: Foo -> [String], that runs the three functions sequencially and concats their result?
15:21:03 <dmwit> haskell`: mconcat [f,g,h]
15:21:34 <haskell`> I have `liftA3 (\x y z -> x ++ y ++ z) f g h` but I think there must be a more elegant way
15:21:44 <monochrom> @type \f g h -> mconcat [f, g, h]
15:21:46 <lambdabot> Monoid a => a -> a -> a -> a
15:22:06 <EvanR> Foo -> [String] is itself a Monoid
15:22:22 <monochrom> Ah I see how.
15:22:27 <monochrom> Yeah.
15:22:29 <dmwit> I don't know. Some people might thing `f<>g<>h` is more elegant than `mconcat [f,g,h]`.
15:22:38 <dmwit> Anyway, both are pretty elegant, I think.
15:22:46 <MarcelineVQ> almost as elegant as fold [f,g,h]
15:22:53 <haskell`> Ok, thanks! :)
15:23:04 <EvanR> you'd wonder why linked lists don't appear more often in maths :)
15:23:07 <EvanR> if they are so elegant
15:23:13 <dmwit> Sequences appear all the time.
15:23:21 <d34df00d> Natural numbers are basically linked lists without annotations.
15:23:27 <monochrom> "most elegant" and "best" and even "fastest" are explicitly subjective so you're entitled to an opinionated answer!
15:23:45 <amalloy> monochrom: in that case, i demand the opinionated answer to which i am entitled
15:23:48 <monochrom> I think we need to do that more so people learn to stop asking for these false extremities.
15:23:52 <EvanR> ok i guess i meant, a short list of 3 things
15:23:59 <EvanR> rather than f <> g <> h
15:24:31 <EvanR> wait who asked this, are they satisfied
15:24:41 <dmwit> haskell`, yes
15:24:41 <DylThi> I'd hope so
15:24:56 <EvanR> nice
15:25:11 <monochrom> In the eyes of mathematicians, linked list is an unnecessary implementation detail for sequences.  Arrays too.
15:25:20 <d34df00d> Speaking of folds, I'm surprised `min a (min b c)` is insanely faster than `minimum [a, b, c]`.
15:25:33 <d34df00d> I'd expect them to be compiled to the same code, especially with enough bang patterns around.
15:26:05 <dmwit> Perhaps someday somebody will finish the superoptimization work, and then they will be.
15:26:06 <monochrom> This is why some math-oriented languages conflate linked lists and arrays, and just say they give you a sequence type.
15:26:18 <dmwit> But for now, inlining recursive functions is not really done.
15:26:29 <monochrom> The converse is not true though.  Some anti-math languages also do that.  Just look at python.
15:26:29 <EvanR> that sounds funny to a haskeller, because "infinite array" ?
15:26:37 <dsal> d34df00d: How much insanely faster?  The list version has to do more work unless you're expecting it to tree [a,b,c] as a tuple and roll it out at compile time.
15:26:38 <dmwit> inlining+unfolding, I guess
15:27:22 <d34df00d> dsal: let's just say replacing them here: https://github.com/0xd34df00d/edit-distance-linear/blob/master/src/Text/EditDistance/Linear.hs#L33 improved the run time by about 30%.
15:27:25 <EvanR> @src minimumBy
15:27:25 <lambdabot> Source not found. Do you think like you type?
15:27:28 <EvanR> @src minimum
15:27:28 <lambdabot> minimum [] = undefined
15:27:28 <lambdabot> minimum xs = foldl1 min xs
15:28:26 <d34df00d> And yeah, I'd expect that to be unrolled. C++ compilers do that all the time!
15:29:04 <EvanR> i wonder if repeated use of a rewrite rule minimum (x:y:xs) = min x (minimum (y:xs)) could work
15:29:19 <EvanR> or if that's even true
15:29:26 <dmwit> Come to think of it, now I'm surprised that `[x]++y` becomes `x:y`, a fact I know and have checked many times. It does not mesh with my prior explanations of why `minimum [a,b,c]` does not become `min a (min b c)`.
15:31:08 <monochrom> unroll unroll unroll your code / gently fuse the stream / merrily merrily merrily merrily / speed is but a dream
15:31:11 <monochrom> https://en.wikipedia.org/wiki/Row,_Row,_Row_Your_Boat
15:31:20 <dmwit> Ah, the (++) one is because of buildr/foldr fusion. Perhaps the minimum one would work, too, if minimum used foldr instead of foldl!
15:31:45 <EvanR> funny, foldr wins again
15:31:56 <EvanR> flawless victory
15:32:48 <dmwit> I think you unwisely take my speculation as fact.
15:33:18 <monochrom> Every speculation is a fact in some mental model.
15:33:25 <EvanR> it's my haskell forecast for tonight
15:33:44 <EvanR> 80% chance of optimization
15:43:08 <monochrom> Oh, 8.8.2 is already RC2ing
15:45:14 <monochrom> Time flies like an arrow. Version flies like an exponential.
15:46:00 <d34df00d> -XDependent when
15:46:31 <monochrom> never!
15:46:50 <hpc> eventually!
15:47:35 <d34df00d> :(
15:48:02 <wildtrees> > over traverse (^2) [1,2,3] 
15:48:05 <lambdabot>  [1,4,9]
15:48:23 <wildtrees> !!! I am wondering how over is using traverse to do that 
16:00:05 <phadej> it's (ab)using the encoding used by lens-library
16:01:18 <phadej> as in, it's special to `lens` library, not to "lenses" concept
16:08:25 <Axman6> traverse is a valid Traversal
16:17:48 <amx> the one function I cannot believe is not part of some widespread, basic library like Prelude is `f p a b = if p a then a else b`. 
16:18:02 <amx> It's trivial, yet I find myself reaching for that several times a day
16:18:04 <dsal> :t bool
16:18:05 <lambdabot> a -> a -> Bool -> a
16:18:51 <hpc> if bool is what i think it is, it's got the extra fun of being bool f t p
16:18:58 <hpc> backwards from what you may expect
16:19:41 <amx> ah, arguments other way round. That's how it hid from me on hoogle. Thanks!
16:19:54 <glguy> amx: It's in Data.Bool, but using it won't make your code clearer
16:20:25 <dibblego> it's \p -> bool >>= p
16:21:41 <dsal> > let amx p a b = bool b a $ p a in    (amx even 3 4, amx odd 3 4)
16:21:44 <lambdabot>  (4,3)
16:21:44 <dsal> > False < True
16:21:48 <lambdabot>  True
16:22:05 <dsal> False is before True.  How could anyone get that confused?
16:22:10 <dsal> It's if that's backwards!
16:22:49 * dsal just noticed 'p a in' in that example.   How appropriate.
16:22:52 <dibblego> and also takes three arguments
16:29:00 <EvanR> False is like 0, which is obviously before 1
16:32:39 <kronicmage> @free bind :: m a -> (a -> m b) -> m b
16:32:39 <lambdabot> Extra stuff at end of line
16:33:09 <kronicmage> @free bind :: Monad m => m a -> (a -> m b) -> m b
16:33:09 <lambdabot> Extra stuff at end of line
16:33:21 <kronicmage> @free bind :: [a] -> (a -> [b]) -> [b]
16:33:22 <lambdabot> $map g . h = k . f => $map g (bind xs h) = bind ($map f xs) k
16:36:49 <pavonia> EvanR: In VB True = -1, so it comes clearly before False!
16:38:45 <EvanR> if bool is defined with two ctors called b0 and b1 then b0 < b1 can't be avoided!
16:39:16 <EvanR> i dare you to name b1 False and b0 True
17:35:28 <slack1256> On swift we got the `guard` statements which lets me bind a name to the real value of an optional, if it can't do that does something on a specified on a else branch. How close can I get to that on haskell?
17:36:01 <slack1256> The niceness of it is that it keep the good path on a single indented level and the rest of error as branches.
17:37:27 <haskell`> I have a function `Foo -> [String]` that I want to turn into a list of functions `[Foo -> String]`. Is there an elegant way to achieve this? Maybe along the lines of sequenceA?
17:38:03 <EvanR> slack1256: Maybe monad with do notation?
17:38:15 <EvanR> or whatever monad that can fail
17:40:05 <slack1256> EvanR: as 'MaybeT IO a'? Yeah, is there a standard way to map IOExceptions to 'return Nothing'?
17:40:25 <EvanR> hmm doesn't sound right
17:40:34 <slack1256> Or a way to know at compile time I catched every possible exception that IO could throw.
17:40:42 <EvanR> you also want to handle IO exceptions?
17:40:44 <dibblego> haskell`: no, since how would it work?
17:41:05 <EvanR> instead of catching every possible IO exception you might want to use async 
17:41:34 * EvanR points out to himself that this convo is no longer about Maybes
17:41:36 <slack1256> EvanR: I want to handle either Nothing or exceptions, but not *both*. So I would like to either map IOExceptions to Nothing or just check I checked every exception possible.
17:42:03 <EvanR> so you want to convert Nothing to an exception
17:42:10 <haskell`> dibblego:
17:42:11 <slack1256> Backwards.
17:42:18 <EvanR> i'm skeptical
17:42:26 <slack1256> Probably.
17:42:46 <slack1256> For now I will throw exceptions and see how far I go.
17:43:00 <EvanR> wherever Nothing is happening, convert to exception. Then handle exceptions later (or don't, example use async or something)
17:43:40 <EvanR> the innovation of exceptions was NOT handling them, or most of them
17:43:52 <slack1256> EvanR: async? isn't that a library for async concurrent threads?
17:44:10 <slack1256> EvanR: I thought I should handle them all, at least for cleaning up resources.
17:44:18 <EvanR> yeah, but it definitely encapsulates the idea of run this IO computation and tell me if it succeeded or failed
17:44:31 <EvanR> oh cleaning up?
17:44:32 <slack1256> EvanR: !!!! true!
17:44:40 <EvanR> that's `finally'
17:45:00 <EvanR> or bracket
17:47:33 <EvanR> if you don't need any concurrency i guess `try' also works
17:48:50 <slack1256> Anyway to know what exceptions an expression of type IO () will throw?
17:49:04 <slack1256> To at least know what to handle and what let crash.
17:49:49 <sm[m]> having trouble finding this.. how might I convert Decimal to Double ?
17:49:58 <sm[m]> https://hackage.haskell.org/package/Decimal-0.5.1/docs/Data-Decimal.html
17:50:08 <slack1256> @type fromIntegral
17:50:09 <lambdabot> (Integral a, Num b) => a -> b
17:50:30 <EvanR> Decimal isn't Integral
17:50:33 <EvanR> try realToFrac ?
17:50:54 <EvanR> slack1256: unfortunately no
17:51:14 <slack1256> ;_;
17:51:15 <EvanR> and that's not even taking account of potential asynchronous exceptions
17:51:23 <sm[m]> yes!! thanks EvanR
17:51:24 <slack1256> EvanR: Thanks EvanR
17:51:39 * sm[m] high-fives slack1256 
17:51:56 <EvanR> hence the slip toward async for doing exceptions
17:52:38 <slack1256> EvanR: So that is what it connects to the async recomendation.
17:52:38 <MarcelineVQ> realToFrac is  fromRational . toRational  fwiw :> barring any rewrite rules it could have
17:52:54 <slack1256> async for single threaded programs, what nice concept.
18:04:05 <iqubic> Optics By Example is a wonderfully excellent book.
18:10:58 <dsal> iqubic: how far along are you?
18:12:59 <iqubic> I just finished reading the section about Folds.
18:13:14 <iqubic> I've yet to start on the Traversal section.
18:13:59 <dsal> Ah.  I read most of that over lunch.
18:16:08 <iqubic> It's a great book. I've been reading through it with GHCi open in the other window.
18:17:22 <dsal> > (3,4) & both %~ (* 2) -- I've wanted to do this kind of thing a lot.  There are a few ways to do it. I don't guess any is great.
18:17:25 <lambdabot>  (6,8)
18:18:26 <shachaf> What's wrong with "over both (*2)"?
18:19:04 <glguy> over both (times 2)
18:19:12 <iqubic> > over both (*2) (3,4)
18:19:17 <lambdabot>  (6,8)
18:20:03 <glguy> shachaf: maybe throw in a couple uses of $ so it still has that operator appeal?
18:20:45 <shachaf> ($) (over both (*2)) (3,4)
18:20:53 <shachaf> You're right, that's better.
18:22:02 <iqubic> I legitimately used "zipWith ($)" in my AoC solution last night.
18:25:59 <koz_> iqubic: (<*>) wasn't suitable?
18:26:55 <iqubic> No.
18:27:37 <dsal> I've found myself writing zipWith (&) or like, zipWith (,)
18:27:38 <iqubic> > [+1, *3] <*> [1,2,3,4,5]
18:27:41 <lambdabot>  error:
18:27:41 <lambdabot>      A section must be enclosed in parentheses thus: (+ 1)error:
18:27:41 <lambdabot>      A section must be enclosed in parentheses thus: (* 3)
18:28:01 <iqubic> > [(+1), (*3)] <*> [1,2,3,4,5]
18:28:03 <lambdabot>  [2,3,4,5,6,3,6,9,12,15]
18:28:22 <iqubic> > zipWith ($) [(+1), (*3)] [1,2,3,4,5]
18:28:25 <lambdabot>  [2,6]
18:28:35 <iqubic> koz_: Notice the difference?
18:28:50 <koz_> iqubic: Something something ZipList.
18:29:23 <koz_> > :t ZipList
18:29:24 <alexbrown> hi all
18:29:27 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
18:29:34 <iqubic> :t ZipList
18:29:35 <lambdabot> [a] -> ZipList a
18:30:02 <koz_> > (ZipList [(+ 1), (* 3)]) <*> (ZipList [1,2,3,4,5])
18:30:05 <lambdabot>  ZipList {getZipList = [2,6]}
18:30:08 <koz_> :D
18:30:16 <iqubic> That would have worked too.
18:30:25 <alexbrown> i'm learning Haskell. 
18:30:37 <alexbrown> I've this code `Binder.hs:14:25: error:    • Expected kind ‘* -> Constraint’, but ‘Bool’ has kind ‘*’    • In the type signature:        decomposing2 :: (Num a, Bool b) => (a, b) -> (a, b)   |14 | decomposing2 :: (Num a, Bool b) => (a,`
18:31:24 <koz_> alexbrown: Bool is a type. Was your goal something like (Num a) => (a, Bool) -> (a, Bool) perhaps?
18:31:39 <alexbrown> this is my code https://dpaste.org/SgBh
18:31:59 <alexbrown> but when build i got this error https://dpaste.org/e4WQ
18:32:09 <alexbrown> can anyone help me understand.
18:32:09 <dsal> Ah, yeah. Types vs. constraints can be confusing.
18:32:38 <koz_> alexbrown: Bool is a type just by itself. 'Bool a' isn't something that makes sense.
18:32:40 <alexbrown> yes koz_
18:32:55 <koz_> Also, \x -> (fst x, snd x) is id.
18:33:07 <koz_> It's not 'decomposing' anything.
18:34:16 <koz_> alexbrown: What's your goal here?
18:34:27 <koz_> I don't understand what you're trying to do.
18:34:42 <alexbrown> so how can i define a function that take a tuple that has different types 
18:35:11 <dsal> alexbrown: tuples often have different types.
18:35:45 <dsal> dsal: if you don't want to do anything with the values, it doesn't matter what the types are, though.
18:35:53 <koz_> alexbrown: (a, b) can mean a tuple whose left and right components are the same, or different.
18:35:56 <alexbrown> Can you give me an example of function that take a tupe with different types and how to use that function?
18:36:03 <koz_> :t swap
18:36:05 <lambdabot> (a, b) -> (b, a)
18:36:12 <koz_> > swap (1, "foo")
18:36:14 <lambdabot>  ("foo",1)
18:36:16 <dsal> @src swap
18:36:16 <lambdabot> Source not found. You type like i drive.
18:36:16 <koz_> ^
18:36:30 * dsal *sigh*
18:36:39 <koz_> Implementation-wise, it's something like 'swap (x, y) = (y, x)
18:36:41 <koz_> '
18:37:21 <dsal> alexbrown: i.e., you don't limit it to types you don't care about. swap can work with any two types without caring what they are.
18:37:54 <koz_> In fact, by its type, it _can't_ care about what they are.
18:38:06 <koz_> Since that would involve knowing something more about a and b.
18:38:44 <dsal> You could write it as (Num a) => (a, Bool) -> (Bool, a)
18:39:21 <koz_> dsal: Yeah, but that's a lot more restrictive than swap.
18:39:27 <dsal> But the implementation would be the same as not caring about the types
18:39:34 <koz_> Since a lot of non-swap functions could also have this type.
18:40:25 <dsal> If you want to only work work those two types you can.  Still a little hard to understand the goal.
18:40:59 <koz_> Yeah - what exactly are you trying to do here, alexbrown?
18:41:49 <alexbrown> oh, now it works https://dpaste.org/Y3uy my `decomposing2`
18:42:04 <alexbrown> many thanks good guys
18:42:58 <iqubic> I still think decomposing is a useless function.
18:43:01 <koz_> alexbrown: You're welcome. For the record, 'decomposing' is 'id', and 'decomposing2' is 'swap', just with more specific signatures, so you could just use those.
18:43:14 <koz_> iqubic: id is of limited use, but it is of _some_ use.
18:43:29 <alexbrown> I'm learning Haskell here http://learn.hfm.io/first_steps.html 
18:43:31 <iqubic> I think id is a great function.
18:43:58 <iqubic> I just don't think you need to rewrite it and give it a more specific type.
18:43:58 <alexbrown> this is the first time i touched to Haskell it seems good and also difficult. 
18:44:18 <alexbrown> how about that resource? does any one give advise when learning Haskell?
18:45:03 <koz_> I have no idea about that specific resource. I favour the Haskell wikibook, followed by the Typeclassopedia, many, _many_ times, including exercises.
18:45:04 <dsal> alexbrown: I really liked haskellbook.com
18:53:13 <ysangkok> just sad that it is still not marked as finished, and not updated for MonadFail either...
19:02:14 <dsal> I think for the book to be finished, Haskell would have to be finished.
19:05:24 <alexbrown> many thanks
19:16:17 <z0> i feel like haskell would become useless if it was finished
19:16:32 <koz_> [insert joke about avoiding success at any cost]
19:17:03 <z0> [or immutability]
19:18:46 <maerwald> I wish it was finished
19:18:55 <maerwald> languages should not constantly evolve
19:19:45 <maerwald> it's fine to have Haskell2 with semi-backwards compatibility (e.g. maybe strict by default, with dependent types and whatnot)
19:20:08 <EvanR> haskell can be finished if 5 seconds later tony stark reveals "GHC mk2" secretly in development the entire time
19:21:10 <z0> at some point we might have it as an extension {-# LANGUAGE FinishedHaskell #-}
19:21:35 <oats> how do I do a view operation with lenses that returns 2 parts of a data structure into a tuple?
19:26:46 <kevinyins> what is the result of (bimap g id) . (bimap id f) ? what if (bimap id id) ? how to find the end of  dependent resursive ? like bimap ,first,second.in bifunctor.
19:29:57 <pavonia> kevinyins: The documentation states several laws which you can derive the results from
19:30:20 <pavonia> So (bimap g id) . (bimap id f) = bimap g f; bimap id id = id
19:32:20 <kevinyins> pavonia: I will try to see the doc
19:39:08 <Axman6> I don't understand what " how to find the end of  dependent resursive" means
19:41:01 <kevinyins> Axman6, just like two funs's definition rely on each other.
19:42:07 <Axman6> are any of those functions recursive?
19:43:02 <kevinyins> Axman6, B: return A();A: return B() .  bimap used first ,then first also use bimap.
19:43:05 <MarcelineVQ> sounds like the questions is about default definitions in typeclasses
19:44:49 <MarcelineVQ> by default bimap = first f . second g    by default  first f = bimap f id, but you break this cycle when you defineeither bimap or both first and second for your own particular type
19:45:22 <kevinyins> MarcelineVQ, yeah ,i lack of some fundementals of haskell.
19:46:33 <MarcelineVQ> due to the default definitions: when you define bimap, first and second come for free since they're defined in terms of bimap   you'll see similar in a simpler class like Eq which has == and /= defined in terms of each other, you only need to write one of them and the other you now get for free
19:47:56 <kevinyins> MarcelineVQ, I will check Eq
20:03:34 <MarcelineVQ> Though now that I look the darn hackage docs don't link to the definitions for Eq :(
20:13:39 <kevinyins> MarcelineVQ, I also not find it in hoogle
20:16:54 <kevinyins> :i Eq  get it 
20:28:31 <monochrom> Tony Stark built "GHC Ultron" which, in its infinite wisdom, unilaterally decided that every program that doesn't use dependent types must be deleted. >:)
20:29:30 <z0> class Eq a where  
20:29:30 <z0>     (==) :: a -> a -> Bool  
20:29:30 <z0>     (/=) :: a -> a -> Bool  
20:29:30 <z0>     x == y = not (x /= y)  
20:29:33 <z0>     x /= y = not (x == y)  
20:37:45 <kevinyins> wa thank you
20:45:19 <kevinyins> I sense some directions
22:16:29 <dsal> > fromEnum 'A' -- iqubic 
22:16:32 <lambdabot>  65
22:22:47 <jle`> > ord 'A'
22:22:49 <lambdabot>  65
22:22:56 <jle`> > chr 64
22:22:59 <lambdabot>  '@'
22:23:02 <jle`> > chr 65
22:23:04 <lambdabot>  'A'
22:25:31 <maerwald> monochrom: just the program? Would also delete the source code
22:25:38 <maerwald> And the users github account.
22:27:49 <maerwald> seems cabal does not propagate SIGINT to the subprocess... 
22:28:11 <maerwald> when you do cabal new-run
22:42:16 <bahamas> I'm looking for uses of different functions in real-world codebases and I thought of using github search. the problem is that I'm only getting results of the definition of the function not its application. is there anything I could do to get more of the latter?
22:42:39 <bahamas> in this particular case, I'm searching for uses of `toOrdinalDate`, but it's just a random example
22:50:00 <bahamas> can at least ghc give you this information? namely, you give it the name of a function and it gives you all the places in a codebase where it's used
22:51:21 * dsal uses fromEnum and toEnum entirely too much...
22:54:42 <haskell``> Is there a function `[a] -> Int -> Maybe a` that works similar to (!!) but returns Nothing if the index exceeds the length of the list?
22:56:35 <heatsink> yes
22:57:35 <haskell``> Would you mind telling me its name? :D
22:58:37 <nil> @hoogle [a] -> Int -> Maybe a
22:58:38 <lambdabot> Safe atMay :: [a] -> Int -> Maybe a
22:58:38 <lambdabot> Protolude atMay :: [a] -> Int -> Maybe a
22:58:38 <lambdabot> Protolude.Safe atMay :: [a] -> Int -> Maybe a
22:59:02 <heatsink> Sorry, I couldn't remember the name
22:59:11 <dsal> I don't think I've used any of those.
22:59:14 <dsal> @package safe
22:59:14 <lambdabot> http://hackage.haskell.org/package/safe
22:59:34 <dsal> There's another one...  I can't remember.
23:01:01 <haskell``> Ah, thanks for the hint to the safe package
23:01:07 <haskell``> That one seems very useful
23:01:46 <haskell``> I wonder why it's not part of the standard library
23:02:03 <c_wraith> because indexing in general suggests you have the wrong data type
23:03:01 <haskell``> So it's unsafe on purpose to discourage its use?
23:03:38 <dsal> It's very old and occasionally useful.
23:03:38 <c_wraith> well, there's lots of unsafe stuff in prelude.  It's that there's no safe alternative to discourage using indexing
23:06:47 <EvanR> the 'unsafe' version can really only be used when you are sure it will work
23:07:10 <c_wraith> which is more or less "on the output of iterate.  too bad there isn't an iterate'"
23:07:11 <EvanR> the Maybe version means you're not sure it will work, and i think that probably means you have the wrong structure
23:08:00 <EvanR> it's two different situations
23:22:11 <chambln> Can I sort a list [a] using a function [a] -> a that simply picks the 'next' item? In other words, I think I'm looking for some function f :: ([a] -> a) -> [a] -> [a].
23:23:13 <Solonarv> I mean... technically yes, you could write such an 'f'
23:23:29 <Solonarv> but it would not be efficient at all, and I would hesitate to call it "sorting"
23:23:57 <chambln> What should I be doing instead? I know how to choose the next item, but I don't know how to phrase it as a way of sorting [a].
23:24:10 <Solonarv> well, I don't know what you are actually trying to accomplish
23:24:13 <Solonarv> I can't read your mind
23:25:41 <chambln> I'm trying to implement a scheduling algorithm. It sorts by processing time but is constrained by due dates.
23:26:07 <cipharius> Also that couldn't work as sorting algorithm, that is more of a min function, since you discard the rest of the elements
23:26:37 <Solonarv> so why not just sort by processing time, and then maybe use 'filter' or something to keep only the tasks that are still valid?
23:26:57 <EvanR> how do you know when the "picking" is over?
23:27:03 <Solonarv> cipharius: I think the idea was to repeatedly apply that '[a] -> a' function to build the output
23:27:05 <EvanR> check the length first?
23:27:11 <Solonarv> I agree it isn't terribly well-defined
23:27:17 <Solonarv> and fragile in all sorts of ways
23:27:37 <Solonarv> for example, what should this output: f (\_-> 0) [1 .. 10]
23:27:41 <chambln> Solonarv: That's right. Build up the list by repeatedly choosing the next one.
23:27:57 <cipharius> also, since it sounds like you'll dynamically keep adding new processes, maybe you could use some binary search tree structure instead, so that it remains sorted at the addition phase
23:27:59 <EvanR> a similar but better shot idea would be, provide the indexes of the items to pick
23:28:11 <Solonarv> from your problem description, it sure sounds like the "next" element is the smallest by some metric
23:29:07 <chambln> Solonarv: Yeah, the 'next' is that job which has the shortest processing time (of those not yet 'added' to the schedule)
23:29:16 <EvanR> then you can sort both lists to get the result
23:29:25 <Solonarv> okay, so this is *definitely* a sort
23:30:18 <EvanR> note to self, the picker is choosing a minimum
23:30:34 <EvanR> so you will want to remove it from the urn at each step
23:31:02 <Solonarv> :t sortOn
23:31:05 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
23:31:13 <EvanR> better idea keep your process list sorted all the time, like a priority queue
23:31:50 <Solonarv> > sortOn snd [("sweep the floors", 20), ("clean the kitchen", 10), ("dust the shelves", 5)]
23:31:52 <lambdabot>  [("dust the shelves",5),("clean the kitchen",10),("sweep the floors",20)]
23:32:09 <EvanR> inserting doesn't just append, it does work to keep it sorted
23:32:31 <cipharius> yeah that sounds like the way to go
23:34:14 <chambln> Solonarv: Each job has a due date, i.e. [("sweep the floors", 20, 30), ("clean the kitchen", 10, 40), ("dust the shelves", 5, 24)]
23:34:21 <EvanR> (basic way, Data.Set.insert and Data.Set.minView)
23:34:40 <Solonarv> okay. what does this "due date" signify? how are you supposed to take it into account?
23:35:48 <chambln> I want to schedule the jobs such that none are late, and so as to reduce the average time of completion.
23:38:11 <chambln> My lecturer gave me a very procedural algorithm for doing this
23:39:02 <jakalx> sounds like earliest deadline first or something like that?
23:39:31 <EvanR> schedule jobs such that none are late, so hard real time, and not necessarily possible
23:40:16 <chambln> I'm to assume that there exists at least one schedule for which no jobs are late.
23:40:29 <EvanR> ok, necessarily possible
23:40:43 <EvanR> now i'm imagining the tile packing search game heh
23:40:52 <Solonarv> and just to be clear, you were given some procedural algorithm and are simply supposed to implement it?
23:41:10 <chambln> I'm trying to rewrite it functionally for fun!
23:41:48 <Solonarv> ah, I see
23:41:48 <EvanR> procedural algorithms usually have a direct translation to functional, often ways to make some aspects more functional
23:42:19 <EvanR> which sometimes sheds some light on the original procedure
23:42:20 <Solonarv> "pick the 'best' task, do it, repeat for the remaining tasks" is definitely a sort
23:42:39 <Solonarv> and it seems to me like this [a] -> a function is supposed to pick the 'best' task
23:42:48 <chambln> Solonarv: That's right
23:45:42 <Solonarv> so, we simply have to figure out some way to write a "key" by which to sort
23:46:10 <Solonarv> obviously I can't do that without seeing the algorithm, though!
23:48:29 <chambln> For example, [a] might be [(20, 30), (10, 40), (5, 24)] 
23:48:46 <chambln> I think the important part of the procedural algorithm is this:
23:48:59 <chambln> Consider those jobs not yet scheduled.
23:49:24 <chambln> Of those whose due date exceeds their total processing time, schedule next the one with the least processing time.
23:50:01 <chambln> next :: [a] -> a
23:50:11 <Solonarv> note: that function signature is a lie
23:50:17 <Solonarv> what if I pass it an empty list?
23:50:52 <EvanR> a tear in the space time continuum opens
23:50:56 <Solonarv> but okay, I see now what my problem is with this: what of the tasks whose total processing time exceeds the due date?
23:51:06 <cipharius> the other problem with `next :: [a] -> a` signature is that you will lose the list that has the a removed
23:51:24 <Solonarv> well, I suppose you could filter (/= x) to remove it...
23:51:30 <cipharius> Also, Data.Set could be more appropriate than list, wouldn't have to move around all elements to keep them ordered, then you can just pick the first element and delete it
23:51:54 <cipharius> just have to implement Ord for your process data type
23:52:15 <EvanR> next :: [a] -> [a] which returns the input list with the desired element moved to the front :)
23:52:20 <Solonarv> actually it sounds like there is a part of the algorithm that you didn't specify:
23:52:35 <Solonarv> surely, after picking a task we have to somehow increment the "current date"?
23:52:47 <cipharius> although i feel like the order of tasks will change depending on newer task deadline
23:53:23 <Solonarv> (or decrement the due dates of everything else, same thing)
23:54:39 <EvanR> (20,30) represents what again?
23:54:51 <bahamas> is anyone familiar with streamly? I'm curious how much its use case overlaps with that of typed-process.
23:55:07 <chambln> (<processing time>, <due date>)
23:55:35 <EvanR> well there you go
23:55:51 <EvanR> :t sortBy
23:55:53 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
23:56:00 <Solonarv> :t sortOn -- better
23:56:02 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
23:56:07 <EvanR> yeah that
23:56:38 <cipharius> yeah but there is additional condition, overdue tasks have higher priority over tasks with lowest processing time
23:56:49 <Solonarv> there are no overdue tasks
23:56:58 <Solonarv> chambln: from what you have said, it sounds like we can just sort by processing time and ignore due dates entirely, since we are told that we have no overdue tasks
23:57:02 <Solonarv> surely this can't be right
23:57:03 <chambln> There might be overdue tasks if you don't schedule wisely
23:57:13 <Solonarv> are you sure you didn't forget to specify something?
23:57:32 <Solonarv> do we have to increment the "current date" or something after scheduling a task?
23:57:43 <EvanR> but, overdue seems to be impossible if you schedule wisely
23:57:57 <chambln> Yeah, it's possible to schedule wisely and have no late jobs
23:57:58 <EvanR> so whats up with that contingency
23:58:20 <cipharius> what if instead of looking at the processing times, you could look at metric (dueDate - processingTime) and sort by that? Processes with bigger time freedom shouldn't be as rushed as ones with smaller or overdue time
23:58:52 <Solonarv> look, this is clearly pointless if you aren't going to clarify anything about the problem statement
23:59:28 <Phyx-> fendor: the new version of regex-posix should work fine with v2-build, what's the actual errror you're getting?
23:59:34 <cipharius> that's true, feels like incompletely defined problem, so there are multiple viable, different solutions
