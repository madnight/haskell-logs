00:25:34 <Ailrun[m]> For anyone still interested in reversed state, I found this post from the past :).
00:25:34 <Ailrun[m]> https://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/
00:51:24 * hackage cobot-tools 0.1.2.3 - Biological data file formats and IO  https://hackage.haskell.org/package/cobot-tools-0.1.2.3 (ozzzzz)
00:57:24 * hackage cabal-rpm 1.0.3 - RPM packaging tool for Haskell Cabal-based packages  https://hackage.haskell.org/package/cabal-rpm-1.0.3 (JensPetersen)
01:56:59 <Phyx-> 21:53:50 < maerwald> "popularity quickly growing" is unfortunately an overstatement <--- personally I feel that that's due to inconsistencies in the policies of haskell.org
02:03:10 <phadej> Phyx-: as in what's on https://www.haskell.org/downloads/ ?
02:04:03 <phadej> one could say it overpromotes stack (as in giving impression that stack is the only tool)
02:05:24 <phadej> and by not mentioning chocolotey, hvr-ppa or even ghcup it maybe makes page clearer (= less options), but otoh, not even mentioning is not cool either
02:05:50 <phadej> yet, I'm not brave enough to propose any changes to that page
02:13:15 <Phyx-> phadej: well, I don't want to rehash the discussion, but yes because of political reasons it overpromotes slack. me and angerman once proposed adding a small link with "alternate" methods to install for macos and windows and that was denied as it would "confuse" users. yet for linux the recommendation of platform was replaced by ghcup
02:14:09 <Phyx-> phadej: then the last time I asked I was told because chocolatey didn't install msys2, where platform did (but didn't configure it, so you had that step 2 that most people don't read and so end up wth a half broken install).
02:14:40 <phadej> (there isn't platform installer for linux atm, so that's why it mentions ghcup, iirc)
02:15:21 <Phyx-> and the platform released for windows is ancient
02:15:38 <Phyx-> well, 8.6.5 based
02:15:47 <phadej> honestly, as your chocolotey setup works very nicely, I'd propose to retire haskell platform
02:16:09 <phadej> ghcup works on linux and macOS
02:16:47 <phadej> having installer on windows is "windows-y", but it would be one less thing to maintain
02:17:20 <Phyx-> tbh, soe implications was made that they don't trust chocolatey because it's not maintained by haskell.org. If that's the case I'm perfectly fine with ceeding control of the packages if that's what it takes
02:18:43 <Phyx-> phadej: yes but the installer isn't msi based. So it's half windows-y. Without it being msi you don't get the protections and features a typical installer is supposed to give. like protection against file corruption, automatic install repair, deployment over AD etc
02:19:10 <phadej> I see
02:19:52 <phadej> but yes, having haskell.org "owned" chocolatey feed -> problem solved IMO
02:20:44 <phadej> if the ownership is the problem there (which I understand, from bus-factor perspective)
02:21:16 <Phyx-> yeah, though all the sources are on github and all the scripts to build them
02:21:40 <nil> Ailrun[m]: that's interesting
02:22:12 <Phyx-> so it's not like it was ever hidden if they wanted to continue it without me :) and I'm perfectly fine adding them to upstream maintainers of the chocolatey pages
02:23:20 <Phyx-> phadej: fyi, I don't mind doing that for the cabal package as well :)
02:24:08 <phadej> Phyx-: related to that, can I build 32bit cabal on 64bit windows machine (i.e. github actions Windows Server 2019?)
02:24:29 <Phyx-> phadej: yes just need a 32-bit ghc
02:24:49 <Phyx-> and a 32-bit cabal to "bootstrap" it with
02:24:52 <phadej> which I can install from chocolatey with --forcex86 ?
02:24:57 <Phyx-> yup
02:26:07 <phadej> good. I spend holidays setting up GitHub actions and it already produces (some) artifacts for linux and osx
02:26:38 <Phyx-> ah cool, yeah I noticed hvr had done some experimenting with that too
02:28:51 <Phyx-> phadej: you'll want a ghc >= 8.6.5, any older you'll trigger a liveliness analysis bug that will trigger a stack allaction bug on the 32-bit compilers when compiling Cabal.
02:28:51 <phadej> yet, I haven't tried windows yet; our current appveyor setup is simple & quite reliable
02:29:07 <phadej> (and yes, we do use 8.6.5 there)
02:30:11 <Phyx-> yeah, I need to look at the manual work for github actions. The packages currently recognize appveyor and travis-ci and configure themselves accordingly
02:30:25 <Phyx-> didn't look at github actions or azure pipelines yet
02:32:22 <phadej> Phyx-: https://github.com/haskell/cabal/blob/wip/ghactions2/.github/workflows/haskell.yaml <- doesn't look like it needs much configuration (I don't see anything which isn't in a basic travis script)
02:38:48 <Phyx-> phadej: hmm curious about the PATH update though
02:40:22 <Phyx-> phadej: I think there's also an issue that if msys2 isn't installed I add the path I expect msys2 to be installed at to extra-lib-dirs. so that if you install msys2 later it just picks it up.
02:40:45 <Phyx-> unfortunately the GHC runtime linker will error out on the non-existent paths
02:41:01 <Phyx-> I can fix this for never GHCs but released ones are an issue..
02:42:08 <phadej> so it's better to choco install msys2 ghc cabal-install ?
02:42:09 <Phyx-> so I have two options, either not add the path,in which case you have to reinstall cabal to get it to work after installing msys2. or make cabal not pass non-existent lib dirs to GHC. both are a bit unfortunate
02:43:12 <phadej> github actions have this mechanism to add paths: https://help.github.com/en/actions/automating-your-workflow-with-github-actions/development-tools-for-github-actions#add-a-system-path-add-path
02:43:16 <Phyx-> phadej: or if you need all tree `haskell-dev` has the proper order. I haven't changed the package yet, so right now order doesn't matter
02:43:46 <phadej> haskell-dev doesn't allow to specify individual ghc version, does it?
02:45:06 <Phyx-> phadej: no, it only takes latests, after it's installed you're free to change any of the components though. I could add a parameter to allow you to do this though...
02:46:23 <phadej> for CIs, both cabal and ghc versions are somewhat important (so they don't change underneath by itself, it's different for desktop usage obviously)
02:47:59 <Phyx-> phadej: yeah, I think my target for haskell-dev is more end users. CIs should stick to individual components, like appveyor has msys2 installed already, no need installing a second copy etc
02:48:29 <Phyx-> my goal was for haskell-dev to be for console mode, and haskell-dev-ide for those that want an IDe
02:48:43 <phadej> so back to PATHs, I don't know if refreshenv works well in github actions; the individual steps e.g. reset the working dir (which is nice, but OTOH I haven't found in docs what is persisted and what's reset)
02:48:50 * Phyx- just didn't have the time to finish the vscode configuration scripts
02:49:43 <Phyx-> that indeed entirely depends on how they execute individual commands
02:50:23 <Phyx-> though if `$Env:PATH="C:\ProgramData\chocolatey\lib\ghc\tools\ghc-${env:GHCVER}\bin;"+$Env:PATH` works, refreshenv *should* have
02:50:59 <phadej> last-resort option would be to cabal&ghc package to echo the magic string as above (during install), to reconfigure paths
02:51:39 <Phyx-> yeah I can easily do that, if they have a way to detect the environment. travis and appveyor set an environment variable
02:52:14 <phadej> https://help.github.com/en/actions/automating-your-workflow-with-github-actions/using-environment-variables <- plenty of
02:52:31 <phadej> GITHUB_ACTIONS ... always set to true . ..
02:52:41 <phadej> You can use this variable to differentiate when tests are being run locally or by GitHub Actions.
02:53:50 <Phyx-> ah, cool, I'm making some changes to the packages anyway so I'll add these as well this weekend. They'll be in the nightlies first
02:58:24 * hackage websockets 0.12.7.0 - A sensible and clean way to write WebSocket-capable servers in Haskell.  https://hackage.haskell.org/package/websockets-0.12.7.0 (JasperVanDerJeugt)
02:58:26 <phadej> I'm not 100% sure those are required, maybe refreshenv just works too
02:58:53 <phadej> (that cabal branch is wip, so cannot be sure the path setting is actually required)
02:59:36 <phadej> ... yet the linux/macos builds seems to run so each step has separate bash instance, so that explains what's preserved and what not
02:59:50 <phadej> maybe windows setps are run with individual powershells too
03:00:44 <phadej> https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepsrun <- has some info
03:02:01 <phadej> implies that my reasoning is correct
03:04:07 <Phyx-> yeah, that would explain why the refreshenv doesn't persist
03:04:48 <Phyx-> chocolatey modifies the PATH in the registry, but the service runner never refreshes so it just keeps using the old paths. and probably why they need that extra output
03:05:25 <Phyx-> too bad they don't just have a ::refresh or something
03:09:36 <phadej> maybe that's something to fill request ticket, preserving PATH (whether it's linux or windows) does make sense
03:10:02 <phadej> (it won't be ::refresh though, also ::add-path doesn't add path to current runner)
03:11:22 <phadej> a bit like ::set-env name=PATH=$PATH -- but a abit more abstracted
03:12:37 <phadej> (I actually don't know PowerShell syntax at all, even how to use variables properly there)
03:13:31 <phadej> anyway, outputting add-path is quite robust, as it would work even ifsomeone uses bash on Windows on GitHub Actions (as that's possible too)
03:13:40 <Phyx-> close enough, for environments it's $Env:PATH, the 'map' is Env and you're looking up PATH in it
03:15:04 <phadej> (I don't know why anywone would use pwsh on linux, but that's possible too :)
03:15:11 <Phyx-> lol
03:37:28 <maerwald> Phyx-: yeah, the download page directs to haskell platform, which directs to other things
03:41:27 <maerwald> but even haskell platform doesn't direct to chocolatey
03:43:34 <Phyx-> maerwald: no, only cabal mentions chocolatey https://www.haskell.org/cabal/download.html
03:53:27 <maerwald> just created an issue https://github.com/haskell-infra/www.haskell.org/issues/12
04:00:04 <Phyx-> lets see how this one goes :)
04:01:39 <maerwald> 2 years of bikeshedding? :>
04:02:04 <maerwald> (and then someone forking the haskell homepage -- haha)
04:02:54 * hackage Win32 2.8.5.0 - A binding to Windows Win32 API.  https://hackage.haskell.org/package/Win32-2.8.5.0 (TamarChristina)
04:12:44 <Phyx-> maerwald: nah, I don't negotiate with people holding guns to their heads :) 
04:15:34 <TMA> it looks like msys2 will get ghc package soon(ish) that would be another one to consider 
04:16:14 <Phyx-> they already had one years ago. the problem is it's hard to maintain
04:16:43 <Rembane> Does it break when ghc gets new versions?
04:16:54 <Phyx-> an msys2 ghc would need to use the package manager's toolchain and not the pre-packaged compiler with the ghc tarballs
04:17:37 <Phyx-> but ghc doesn't support this, so they need to modify the config files and for some changes change SysTools. which is fragile since SysTools changes frequently
04:18:16 <Phyx-> I added a configure flag to support the first part, but never got around to wiring this through to SysTools
04:18:58 <Phyx-> Rembane: potentially, it's the reverse that's more likely though, it'll break when new GCC versions are released
04:19:39 <Rembane> Phyx-: Got it. That also sounds painful. 
04:19:49 <Phyx-> anytime we bump new the GCC, binutils etc in GHC we may need to patch a lot. e.g. supporting GCC 9 required non-trivial changes
04:31:47 <_nam_> completely new to haskell here -- why is sin sin 0.5 not 'well-formed' but sin (sin 0.5) works ok? using GHCi
04:33:26 <Rembane> _nam_: Because the interpreter is trying to apply the function sin to the function sin and then apply that to 0.5. 
04:33:50 <Rembane> _nam_: Using parentheses you can change that order to the opposite which works. 
04:36:34 <_nam_> I see, thanks
04:36:45 <Rembane> _nam_: No worries. 
04:52:54 * hackage network-transport-tests 0.2.4.3 - Unit tests for Network.Transport implementations  https://hackage.haskell.org/package/network-transport-tests-0.2.4.3 (FacundoDominguez)
05:02:59 <izohask> test
05:17:46 <fog65> https://pastebin.com/raw/wtqq0ZYz
05:17:52 <fog65> i cant figure out this error
05:43:24 * hackage network-transport-tcp 0.7.0 - TCP instantiation of Network.Transport  https://hackage.haskell.org/package/network-transport-tcp-0.7.0 (FacundoDominguez)
05:51:29 <bitmapper> what's up with this type signature? readHFile :: FilePath -> IO (FilePath,HoHeader,forall a. Binary a => ChunkType -> a)
05:58:54 * hackage network-transport-tcp 0.6.1 - TCP instantiation of Network.Transport  https://hackage.haskell.org/package/network-transport-tcp-0.6.1 (FacundoDominguez)
06:01:13 <bitmapper> it works in ghc 7.x but not in 8.x
06:07:28 <statusfailed> I need to do some adding and comparison of type level naturals, what's a good library for that?
06:08:59 <Uniaika> bitmapper: can't it be because of the inner forall?
06:09:16 <Uniaika> isn't there an extension always activated since 8.x that changes the behaviour?
06:09:19 <bitmapper> it was because of a change in the typechecker that broke impredicativetypes, apparently
06:09:34 <bitmapper> why on earth this code uses that, i don't know
06:11:12 <fog> bitmapper: why not just commute the constraint to the far left of the type signature
06:11:17 <Uniaika> the last example of this pages has convinced me not to use them https://wiki.haskell.org/Impredicative_types
06:11:54 <fog> Uniaika, its the constraint not the forall that makes it impredictive
06:12:14 <Uniaika> oh I see
06:12:43 <Uniaika> so wait, then why is the wiki page only focusing on the foralls?
06:13:00 <Uniaika> like there's not a single occurence of => in the page?
06:13:03 <fog> well, maybe both, but it can put the forall to the far left (the explicit forall can be ommited)
06:14:01 <fog> huh, ok I must be confused... I guess its that the forall in the constraint is preventing the comutation somehow
06:28:37 <phanimahesh[m]> I can't even parse that type signature properly. How do I interpret it?
06:39:14 <Axman6> phanimahesh[m]: what type signature?
06:49:17 <Ailrun[m]> bitmapper: It uses ImpredicativeTypes since it contains `forall` inside of a type wrapper.
06:49:25 <bitmapper> yeah, i know
06:54:11 <bunnyocto> There be some tool to format haskell code nicely automatically
06:54:14 <bunnyocto> like gofmt would
06:54:29 <bunnyocto> I ain't fixing thousands of tabs/spaces problem by hand
06:54:34 <bunnyocto> not getting paid to do that by hand
06:55:30 <Ailrun[m]> brittany or stylish-haskell, or ormolu
06:55:52 <Ailrun[m]> brittany, sty...*
06:56:01 <phanimahesh[m]> I can work with ordinary polymorphism. Rank n types are stretching it. Impredicative types might as well be golfed perl.
06:56:43 <Rembane> albel727: I use Brittany and I'm very happy with that, but as usually YMMV.
06:56:47 <Rembane> -ly
06:57:41 <phanimahesh[m]> Ailrun: the one being discussed above, and also the one on the Impredicative types wiki page
06:58:29 <Ailrun[m]> phanimahesh (@phanimahesh:matrix.org): I'm not the one who asked it :) I think you mean Axman6.
06:58:58 <bunnyocto> I also like to use not just vertical tabs but also horizontal tabs
06:59:03 <bunnyocto> <- true coder over here
06:59:08 <Rembane> albel727: Sorry, mischat. 
06:59:20 <phanimahesh[m]> Oh. Yeah. Sorry
06:59:23 <Rembane> bunnyocto: I see that you need a 2d-programming language. 
06:59:39 <phanimahesh[m]> We should file a bug on matrix irc bridge. The nick handling is ridiculous
07:00:06 <bunnyocto> no. I need ln:L[zi{^pWDcyj!!}m[wD
07:00:14 <bunnyocto> that's actual working code
07:00:53 <Rembane> What does it do? 
07:04:05 <tamme> ?src ($)
07:04:05 <lambdabot> f $ x = f x
07:04:20 <bunnyocto> Rembane: https://cutt.ly/Jryt4ly <- see there
07:04:54 <Rembane> bunnyocto: Lovely! Thank you.
07:04:55 <tamme> ?src (.)
07:04:55 <lambdabot> (f . g) x = f (g x)
07:05:42 <bunnyocto> (it picks the nth word of the nth line)
07:06:34 <Rembane> The code has a certain APL flavour 
07:06:36 <Rembane> ...about it 
07:21:58 <bunnyocto> parse error:"Encountered -XCPP. Aborting."
07:22:00 <bunnyocto> so much for brittany
07:22:11 <bunnyocto> britain is one more time failing me
07:22:59 <bunnyocto> wtf is XCPP even
07:23:02 <bunnyocto> never heard of that
07:23:20 <bunnyocto> is that {## LANGUAGE CPP ##}?
07:23:30 <geekosaur> yes, it's the command line form of it
07:23:38 <geekosaur> -X specifies a language option
07:24:31 <bunnyocto> ah. darnit.
07:25:07 <geekosaur> also multiline cpp expansions make parsing and formatting significantly more difficult
07:40:00 <reactorpriest> I've got an ADT with an annotation type variable, and a Recursive instance from recursion schemes. Which function should I use to add an annotation via where I need the annotations from the child nodes as well? 
07:42:05 <Ailrun[m]> -XCPP is non-goal of brittany, and I don't think there is a formatter supporting -XCPP reliably.
08:24:31 <lyxia> reactorpriest: cata?
08:27:39 <reactorpriest> lyxia, refold (embed . alg) project seems to have the type sig I'm looking for 
08:27:48 <reactorpriest> Maybe prepro? 
09:54:03 <zeta_0> could you guys explain to me what this piece of code does?
09:54:06 <zeta_0> applyTwice :: (a -> a) -> a -> a
09:54:06 <zeta_0> applyTwice f x = f (f x)
09:54:58 <geekosaur> computes (f x), then applies f again to the result
09:55:51 <geekosaur> maybe you're confused by the fact that we don't write f(x) to apply f to x, we write (f x) (and leave off the parentheses if they're not needed)
09:59:36 <zeta_0> geekosaur: so if i understand correctly, the function f represents the 1st parameter function (a -> a), x represents the 2nd parameter a, and f (f x) represents the final result that is returned `a` ?
09:59:58 <geekosaur> where "a" is a type, yes.
10:00:19 <geekosaur> it's not specified what type, but the same type must be used throughout
10:00:55 <dsal> > let applyTwice f x = f (f x) in   applyTwice (+1) 0
10:00:57 <lambdabot>  2
10:01:21 <geekosaur> so you could use applyTwice with an (Int -> Int) function and an Int value, or a (String -> String) function and a String value, but not a (String -> String) function and an Int value
10:02:55 <iqubic> > let applyTwice f x = f (f x) in   applyTwice reverse [1,2,3,4,5]
10:02:57 <lambdabot>  [1,2,3,4,5]
10:03:22 <zeta_0> ok, now that understand the function's type signature and definition, i am still confused about the mechanics of the implementation(with arguments passed), could you guys walk me through the steps?
10:03:30 <iqubic> Using it with a function of type ([Int] -> [Int])
10:03:31 <Vendruza97> Hi, I am Live. Come and watch me. Send me your username to receive a free invite to my VIP room, 10 people max. Let's have fun together::: http://svel.to/1geq
10:04:19 <iqubic> Vendruza97: This is not the right place to advertise you adult content.
10:05:04 <dsal> > let applyTwice f x = f (f x) in   applyTwice (Debug.SimpleReflect.f) 0  :: Expr
10:05:06 <lambdabot>  f (f 0)
10:05:20 <iqubic> Why is #Haskell the first place newcomers to IRC arrive?
10:05:21 <dsal> (someone overwrite f)
10:05:33 <iqubic> dsal: How so?
10:05:37 <dsal> :t f
10:05:39 <lambdabot> error:
10:05:39 <lambdabot>     Ambiguous occurrence ‘f’
10:05:39 <lambdabot>     It could refer to either ‘Debug.SimpleReflect.f’,
10:05:46 <Uniaika> iqubic: it's a bot
10:05:52 <Uniaika> and #haskell is a public channel
10:05:55 <dsal> Someone did a @let of f
10:05:57 <iqubic> I know.
10:06:02 <iqubic> @undefined
10:06:02 <lambdabot> Undefined.
10:06:07 <geekosaur> no f comes from simple-reflect
10:06:08 <geekosaur> :t f
10:06:08 <iqubic> @undefine
10:06:08 <lambdabot> Undefined.
10:06:09 <lambdabot> FromExpr a => a
10:06:22 <dsal> > let applyTwice f x = f (f x) in   applyTwice f 0  :: Expr
10:06:24 <lambdabot>  f (f 0)
10:06:26 <dsal> yay
10:06:28 <iqubic> dsal: There. No longer overrwitten.
10:06:28 <Uniaika> iqubic: so it just /list'ed all the channels and sent the same message 
10:06:31 <dsal> zeta_0: ^ does that help?
10:06:41 <Uniaika> it's not really a matter of being a newcomer on IRC
10:07:11 <iqubic> :t applyTwice
10:07:12 <lambdabot> error: Variable not in scope: applyTwice
10:07:13 <dsal> I mean, I don't exactly understand what you need to walk through since that's basically the same thing as the definition.
10:07:31 <iqubic> @let applyTwice f = f . f
10:07:32 <lambdabot>  Defined.
10:07:39 <iqubic> :t applyTwice
10:07:40 <lambdabot> (b -> b) -> b -> b
10:07:59 <iqubic> Alright.. So, my definition is slightly different, but it still does the same thing.
10:08:01 <zeta_0> so the 1st parameter function takes the second parameter value x(which in this case is (f x))? and is recursion being used?
10:08:11 <dsal> I'm not certain "f . f" helps anyone understand.
10:08:16 <geekosaur> neither am I
10:08:20 <iqubic> dsal: It doesn't.
10:08:29 <iqubic> > applyTwice (+1) 0
10:08:30 <lambdabot>  2
10:08:46 <dsal> zeta_0: It's not recursing.
10:08:59 <iqubic> I just wanted to define it so you could stop doing "let ... in ..." in your examples.
10:09:02 <dsal> It just receives a function and calls that function on its input.  And then it calls that function one more time on the output of the first call.
10:09:17 <iqubic> It's a higher ordered function.
10:10:00 <lavalike> > applyTwice (\x -> log $ (exp x + 1) / (exp x - 1)) 3.1337
10:10:02 <lambdabot>  3.1337
10:11:14 <geekosaur> applyTwice (+1) 0   ->   (+1) ((+1) 0)   ->   (+1) (0+1)   ->   (+1) 1   ->   (1+1)   ->   2      ...hm, I'm not sure using a section helps with understanding, either
10:12:48 <dsal> If you're used to reading succ, it might help?
10:13:25 <zeta_0> ok i wrote out an example by hand, i think it makes sense now:
10:13:26 <zeta_0> applyTwice (+3) 10 = (+3) ((+3) 10)
10:13:27 <zeta_0>                    = (+3) (13)
10:13:27 <zeta_0> 		   = 16
10:13:36 <dsal> > let applyN x f i = foldl' (const . f) i [0..x] in  applyN 3 f 0 :: Expr
10:13:38 <lambdabot>  f (f (f (f 0)))
10:14:30 <dsal> heh, off by one.
10:14:35 <zeta_0> thanks for the help guys, it was much simpler than i thought, the syntax just tripped me out there for a bit
10:14:54 <dmwit> > let applyN x f i = iterate f i !! x in applyN 3 f x :: Expr
10:14:56 <lambdabot>  f (f (f x))
10:14:56 <dsal> Yeah.  I find simple things to be the hardest things to think about.
10:15:59 <zeta_0> i am starting to get used to the abstraction of haskell
10:16:10 <dsal> You mean "function"  >
10:16:28 <dmwit> Don't worry, every time you get used to an abstraction level, somebody will show you there's another.
10:16:32 <zeta_0> dsal: agreed, missing the tiny details can cause confusion
10:19:19 <zeta_0> dmwit: yeah, i watched all of the videos of bartosz milewski's category theory for programmers, and climbing the ladders of abstraction blew my mind
10:21:56 <zeta_0> but after learning some category theory haskell is starting to make much more sense
10:23:26 <dsal> It all just sort of melts together.
10:26:06 <geekosaur> betting it's more the background that helps; there isn't that much CT in haskell
10:47:29 <heath> anyone able to build the morpheus-graphql examples with cabal new-build? git clone https://github.com/morpheusgraphql/morpheus-graphql.git && cd morpheus-graphql/examples && stack build --dry-run  && cabal new-build
10:48:05 <heath> here's the error I keep receiving: https://gist.github.com/heath/eb3ac6925e65417abecd0bf670bef446
10:55:20 <d34df00d> I'm going through somebody else's benchmark.
10:55:34 <d34df00d> And I'm trying to understand the evaluation model of a function:
10:55:57 <d34df00d> https://gitlab.com/gasche/gc-latency-experiment/blob/master/Main.hs
10:56:10 <d34df00d> What purpose does `Exception.evaluate` on line 20 serve here?
10:56:38 <d34df00d> Or, rather, writeArray doesn't evaluate the value to WHNF, does it?
11:03:56 <solonarv> d34df00d: it does not, no
11:04:08 <solonarv> that's why the 'evaluate' call is needed
11:04:43 <solonarv> it makes sure that the bytestring is in WHNF (and therefore in NF, because it's a strict bytestring)
11:24:10 <oats> is it possible to "lift" a function ([i] -> [o]) into a conduit type? ConduitT i o m a
11:26:51 <dmwit> Without knowing conduit at all I'm going to say no.
11:27:22 <dmwit> I would expect a streaming library to want to observe things about how the streaming is done that the type [i] -> [o] doesn't give you access to.
11:27:56 <dmwit> Like "is this enough inputs to produce an output yet?".
11:28:37 <oats> mmm
11:29:03 <dmwit> Also [i] -> [o] lets you write functions that are not (semigroup) homomorphisms. I suspect conduits force that property.
11:29:50 <dmwit> Or at least that f (xs ++ ys) = f xs ++ g xs ys for some g.
11:30:48 <dmwit> (This is more general than being a semigroup homomorphism: a homomorphism picks g _ = f.)
11:35:49 <oats> to be blunt, I don't know about any of that stuff. it's all greek to me :P
11:36:00 <oats> does it change if `i` and `o` are the same type?
11:42:33 <Ailrun[m]> oats: You can do something with `traverse yieldM . traverse f . sourceToList` if your monad for ConduitT is also a traversal. However, I doubt this is what you really want...
12:13:59 <solonarv> Ailrun[m]: yeah, that will just consume the entire upstream and pass it to f all at once
12:17:24 <solonarv> oats: the short answer is: it's *possible*, but you give up the actual "streaming" part of conduit
12:17:39 <solonarv> % impoqrt qualified Data.Conduit as C
12:17:39 <yahb> solonarv: ; <interactive>:33:19: error:; Not in scope: data constructor `Data.Conduit'; No module named `Data' is imported.
12:17:43 <solonarv> % import qualified Data.Conduit as C
12:17:43 <yahb> solonarv: ; <no location info>: error:; Could not find module `Data.Conduit'; It is not a module in the current program, or in any known package.
12:17:48 <solonarv> >.>
12:19:35 <Ailrun[m]> solonarv: if you want to see types, lambdabot has Conduit modules
12:20:17 <Ailrun[m]> (Though you need to use it in a qualified way)
12:21:06 <e2> happy new year!!! 2020
12:26:34 <solonarv> how odd
12:26:44 <solonarv> I can use Data.Conduit.*, but not import it
12:27:16 <MarcelineVQ> maybe the real * was the implicit modules we met along the way
12:28:17 <solonarv> :t \f -> fmap f Data.Conduit.Combinators.sinkList >>= Data.Conduit.Combinators.yieldMany
12:28:18 <lambdabot> (Monad m, Data.MonoTraversable.MonoFoldable mono) => ([a] -> mono) -> conduit-1.3.1.1:Data.Conduit.Internal.Conduit.ConduitT a (Data.MonoTraversable.Element mono) m ()
12:28:53 <solonarv> okay, so that works
12:29:01 <solonarv> but it's not pretty and not efficient
12:29:03 <solonarv> oats: ^
12:32:09 <MarcelineVQ> fmap f . m >>= g   ==   m >>= g . f   if you want prettier
12:34:16 <dmwit> oats: Without Greek: For a conduit, if I hand it some i's, and it responds with some o's, it has committed to those o's and can never unproduce them.
12:34:36 <dmwit> But if I have `f :: [i] -> [o]`, and I hand it `[i1, i2, i3]`, and it produces `[o1, o2, o3]`, say...
12:35:02 <dmwit> ...then later I might hand it a longer list like `[i1, i2, i3, i4]`, and it's possible it would completely change its answer to not have `o1`, `o2`, or `o3` in the result.
12:35:10 <dmwit> So it can "unproduce" them, in one sense.
12:35:36 <oats> ah, that makes sense
12:35:51 <dmwit> (In another sense, that's not really fair, because you'd really hand it `i1:i2:i3:undefined` or something. ;-)
12:35:52 <oats> this sounds kinda like linear systems from my signals & systems EE class
12:36:05 <oats> I could be completely misremembering what that means though
12:36:11 <dmwit> (...but then you get to my other comments about being able to observe how many inputs is "enough" to get an output.)
12:39:16 <geekosaur> iirc you can do this but you need scaffolding to tell conduit what the chunks are. which isn't possible for an arbitrary function, only for known functions (that are well behaved)
12:40:08 <geekosaur> it ends up being easier to just reimplement them as conduit combinators
13:13:02 <iqubic> Why is there no "instance Enum a => Enum [a]"
13:13:12 <iqubic> That would really help me here in my coding problem.
13:14:09 <solonarv> iqubic: surely 'Bounded a' would also be needed?
13:15:07 <iqubic> Why?
13:15:25 <geekosaur> what's the point of the list if it's not Bounded?
13:15:26 <iqubic> Oh. Right, because that's how Enum works.
13:15:34 <iqubic> Bounded is needed too.
13:16:10 <iqubic> But that is what I want.
13:16:50 <hololeap> :t [minBound..maxBound]
13:16:51 <lambdabot> (Bounded a, Enum a) => [a]
13:17:22 <dsal> You don't need maxBound there
13:17:24 * hackage mmsyn7ukr 0.4.0.0 - A simple basic interface to some SoX functionality or to produce a voice that can be used by mmsyn7h  https://hackage.haskell.org/package/mmsyn7ukr-0.4.0.0 (OleksandrZhabenko)
13:18:04 <hololeap> dsal: wouldn't it throw an error at the end then, when you call succ on maxBound?
13:18:22 <iqubic> So that I can do things like ["aaa"...] and get ["aaa","aab","aac"..."aaz","aba","abb","abc"..."aza","azb"..."baa","bab"..."zzz"]
13:18:33 <dsal> > let allOf = [minBound..] in allOf :: [Bool]
13:18:35 <lambdabot>  [False,True]
13:18:46 <geekosaur> no, enumFrom will stop at maxBound
13:18:50 <iqubic> I wish there was a clean way to do that sort of thing, with the strings.
13:19:17 <dsal> Oh, that's not even what you want.
13:19:30 <iqubic> No. Not at all.
13:19:47 <dsal> I mean the thing you said isn't what you want.  That you want that is false.
13:19:48 <hololeap> didn't know that
13:19:54 <iqubic> I want something that works in the way that Excel orders their columns.
13:20:00 <iqubic> dsal: How do you know?
13:20:08 <iqubic> Do you know what I'm working on?
13:20:13 <geekosaur> sounds like perl magic autoincrement. problem is, it's called magic for a reason
13:20:18 <dsal> > succ 'z'
13:20:20 <lambdabot>  '{'
13:20:25 <iqubic> Oh. I see.
13:20:29 <iqubic> That's unfortunate.
13:20:49 <iqubic> Basically I'm trying to do Advent of Code 2015, Day 11, Part 1.
13:20:56 <iqubic> https://adventofcode.com/2015/day/11
13:21:29 <iqubic> And my first thought is to enumerate all the possible passwords starting with the one I've been given as input.
13:21:43 <dsal> Yeah.  It's easier to write the code than to try to specify the new type of char that only gives you 'a'..'z' and then wraps around, but is still a string.
13:21:48 <hololeap> > let cs = pure <$> ['a'..'z'] in (\x y z -> x ++ y ++ z) <$> cs <*> cs <*> cs
13:21:50 <lambdabot>  ["aaa","aab","aac","aad","aae","aaf","aag","aah","aai","aaj","aak","aal","aa...
13:22:13 <solonarv> yes, that is a sensible thing to do; why does it have to be done using a special magic 'Enum [Char]' instance?
13:22:34 <dsal> It's just a base 26 add with carry.
13:22:59 <iqubic> hololeap: That's great. Now make it work with strings of length 8.
13:23:15 <iqubic> dsal: Yeah, I know. It just sorta seems hard to implement.
13:24:28 <iqubic> And Ideally I'd like the list of potential passwords have no 'o' or 'i'
13:24:52 <Ailrun[m]> >  fold (replicate 8 (Alt ['a'..'z']))
13:24:54 <lambdabot>  Alt {getAlt = "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghi...
13:25:13 <iqubic> That's not quite right.
13:25:24 <Ailrun[m]> Oh, I put Alt on a wrong place
13:25:43 <dsal> Yeah, I special-cased the three bad letters in my incr function.
13:25:43 <Ailrun[m]> I mean I need Ap, not Alt
13:25:46 <iqubic> Oh? Care to correct it?
13:26:24 <iqubic> >  fold (replicate 8 (Ap ['a'..'z']))
13:26:26 <lambdabot>  error:
13:26:26 <lambdabot>      • No instance for (Monoid Char) arising from a use of ‘fold’
13:26:26 <lambdabot>      • In the expression: fold (replicate 8 (Ap ['a' .. 'z']))
13:26:32 <iqubic> nope.
13:26:42 <iqubic> Ailrun[m]: Can you fix this up?
13:28:45 <dsal> I don't think that's getting you closer to "next password"
13:28:46 <hololeap> > foo 1 b e = pure <$> [b..e] ; foo n b e = (:) <$> [b..e] <*> foo (n-1) b e
13:28:48 <lambdabot>  <hint>:1:11: error:
13:28:48 <lambdabot>      parse error on input ‘=’
13:28:48 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
13:28:56 <hololeap> % foo 1 b e = pure <$> [b..e] ; foo n b e = (:) <$> [b..e] <*> foo (n-1) b e
13:28:56 <yahb> hololeap: 
13:29:03 <hololeap> % foo 1 'a' 'z'
13:29:03 <yahb> hololeap: ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"]
13:29:08 <hololeap> % foo 2 'a' 'z'
13:29:08 <yahb> hololeap: ["aa","ab","ac","ad","ae","af","ag","ah","ai","aj","ak","al","am","an","ao","ap","aq","ar","as","at","au","av","aw","ax","ay","az","ba","bb","bc","bd","be","bf","bg","bh","bi","bj","bk","bl","bm","bn","bo","bp","bq","br","bs","bt","bu","bv","bw","bx","by","bz","ca","cb","cc","cd","ce","cf","cg","ch","ci","cj","ck","cl","cm","cn","co","cp","cq","cr","cs","ct","cu","cv","cw","cx","cy","cz","da","db"
13:29:14 <hololeap> % foo 8 'a' 'z'
13:29:20 <yahb> hololeap: ["aaaaaaaa","aaaaaaab","aaaaaaac","aaaaaaad","aaaaaaae","aaaaaaaf","aaaaaaag","aaaaaaah","aaaaaaai","aaaaaaaj","aaaaaaak","aaaaaaal","aaaaaaam","aaaaaaan","aaaaaaao","aaaaaaap","aaaaaaaq","aaaaaaar","aaaaaaas","aaaaaaat","aaaaaaau","aaaaaaav","aaaaaaaw","aaaaaaax","aaaaaaay","aaaaaaaz","aaaaaaba","aaaaaabb","aaaaaabc","aaaaaabd","aaaaaabe","aaaaaabf","aaaaaabg","aaaaaabh","aaaaaabi","aaaaaabj","aa
13:29:38 <iqubic> How does that work?
13:29:53 <iqubic> Oh I see how that works.
13:30:09 <iqubic> Nice.
13:30:19 <hololeap> it just leverages how the applicative instance for lists works
13:30:50 <iqubic> Cool.
13:31:40 <iqubic> Now, how do I trim out the first couple thousand elements so that the first element in the list is "vzbxkghb"
13:32:05 <dsal> That sounds cheaper than just incrementing...
13:32:10 <iqubic> Is there a way to do it in a not lame way?
13:32:21 <hololeap> % dropWhile (/= "vzbxkhb") $ foo 8 'a' 'z'
13:32:21 <yahb> hololeap: ; <interactive>:1:28: error:; * Variable not in scope: foo :: Integer -> Char -> Char -> [[Char]]; * Perhaps you meant `for' (imported from Data.Traversable)
13:32:23 <dsal> incr :: Password -> Password
13:33:28 <Ailrun[m]> iqubic: > getAp . fold . replicate 8 . Ap . fmap (:[]) $ ['a'..'z']
13:33:36 <Ailrun[m]> > getAp . fold . replicate 8 . Ap . fmap (:[]) $ ['a'..'z']
13:33:38 <lambdabot>  ["aaaaaaaa","aaaaaaab","aaaaaaac","aaaaaaad","aaaaaaae","aaaaaaaf","aaaaaaag...
13:33:43 <iqubic> dsal: Should I use hololeap's function, or just write my own incer function?
13:33:56 <iqubic> What does Ap do?
13:33:57 <dsal> You could calculate the search space and decide.
13:34:37 <pablo[m]3> guys
13:34:37 <Ailrun[m]> Ap is for making monoid for applicative functor
13:34:55 <pablo[m]3> where is the `Rational` type declared at?
13:35:04 <dsal> @index Rational
13:35:04 <lambdabot> Prelude, Data.Ratio
13:35:07 <Ailrun[m]> i.e., mconcat is <*>, and mempty is pure mempty.
13:35:26 <iqubic> Ailrun[m]: Cool.
13:37:55 <pablo[m]3> <lambdabot "Prelude, Data.Ratio"> thanks!
13:42:07 <dsal> iqubic: I think you're thinking too hard about this.  On its face, the problem just calls for one tiny function with two cases.
13:42:27 <dsal> (though in my case, I did special case the three characters as well)
13:42:48 <iqubic> I'm not sure I see how.
13:43:02 <dsal> > succ 'x'
13:43:04 <lambdabot>  'y'
13:43:29 <dsal> It's mostly that, but I made a similar function that special cases the cases we want to skip.
13:43:55 <iqubic> Right. But what do I do if I get 'z'?
13:44:08 <iqubic> "aaz" -> "aba" seems hard.
13:44:17 <dsal> That's one of the two cases.
13:44:27 <dsal> The two cases are:  it's 'z'.  It's not 'z'
13:44:41 <iqubic> Right.
13:45:02 <dsal> Would "zaa" -> "aba" be easier?
13:45:09 <iqubic> Maybe.
13:45:22 <iqubic> Actually yes.
13:45:53 <wildtrees> is there something that does this, (a -> f a) -> f (a -> a) where f is some typeclass like functor, applicative, or monad? 
13:46:12 <iqubic> incr [] = []
13:46:14 <iqubic> incr ('z':rest) = 'a':incr rest
13:46:38 <iqubic> incr (x:rest) = succ x:rest
13:46:44 <dsal> @hoogle (a -> f b) -> f (a -> b)
13:46:45 <lambdabot> Data.Searchable assemble :: forall b f . (Finite a, Applicative f) => (a -> f b) -> f (a -> b)
13:47:03 <iqubic> dsal: Something like that ought to work.
13:47:32 <dsal> I didn't use a list, but that's probably fine.  Just need to reverse twice.
13:48:32 <iqubic> Actually, make the base case be incr [] = "aaaaaaaa" and you get automatic rollover from "zzzzzzzz" to "aaaaaaaa"
13:48:42 <hololeap> wildtrees: i don't think those two things are semantically the same. (a -> f a) creates a new `a` within a context `f` from an `a`. `f (a -> a)` is a function from `a` to `a` within the context of `f`
13:49:02 <iqubic> dsal: What did you use as the data structure?
13:49:07 <dsal> type Password = Seq Char
13:49:17 <iqubic> Why?
13:49:39 <dsal> So I don't have to reverse twice.
13:49:45 <iqubic> Right.
13:49:51 <dsal> Seq.adjust succ i p
13:50:48 <iqubic> Right, but you also need carryover too.
13:51:06 <hololeap> wildtrees: the point is that with (a -> f a) the context is dependent on that first `a`, but with `f (a -> a)` the context is already there
13:51:38 <solonarv> hololeap: foo n b e = replicateM n [b .. e], no?
13:52:07 <wildtrees> yea trying to convert a lambda calculus eval function I got off of stack overflow, to not runtime error but wrap it's result in Either, it uses some sort of higher order abstract syntax for evaluation representation 
13:52:39 <iqubic> Oh. So it's an XY problem. I see.
13:52:43 <iqubic> @where xy
13:52:43 <lambdabot> http://xyproblem.info/
13:53:11 <hololeap> @where my keys
13:53:11 <lambdabot> I know nothing about my.
13:53:17 <hololeap> drat
13:57:42 <LarryTheCow> Yoooo I just found a way to find permutations (with repetition) using applicatives
13:57:46 <LarryTheCow> perm n = replicateM n [1..n]
13:57:53 <LarryTheCow> It's pretty cool
13:59:32 <iqubic> dsal: http://dpaste.com/0BEQ6CR
14:00:42 <dsal> Oh nice.  I didn't even use the pattern thing.
14:01:00 <iqubic> The Empty Case is just handling 'zzzzzzzz' -> 'aaaaaaaa' Which may or may not ever be needed.
14:01:23 <dsal> I'm just using adjust.
14:02:08 <iqubic> Replaced the first case with this: "incr Empty = Seq.replicate 8 'a'"
14:04:56 <hololeap> solonarv: good call
14:05:16 <hololeap> i didn't realize replicateM just used applicative combining
14:05:29 <iqubic> I don't know if I'll ever need to the wrap around from all 'z's to all 'a's, but I can now do that.
14:06:06 <hololeap> but it makes sense
14:06:16 <hololeap> should be replicateA
14:07:24 <iqubic> Yes. That is a thing that many people wish would be fixed.
14:07:30 <dsal> replicateEh
14:08:13 <iqubic> Sequence is like list, but you can cons and snoc and get the head, tail, init, and last in O(1) time.
14:08:22 <iqubic> Why don't we use Sequence everywhere?
14:10:02 <hololeap> list is still useful for a lot of things and its implementation is simpler. but probably hysterical raisins are to blame, yet again
14:10:14 <dsal> List is very simple.  Simple is often a good idea.
14:10:34 <dsal> Not all O(1)s are the same.
14:10:45 <iqubic> Actually, the base case only needs to be: "incr Empty = Empty"
14:11:00 <loli> constants often matter, also a more restricted data structure gives insight into data structure usage
14:11:44 <iqubic> http://dpaste.com/1SDC0NV
14:11:55 <iqubic> That does "zzz" -> "aaa" just fine.
14:13:41 <iqubic> I think the second line there, with the carryover is the coolest thing ever.
14:18:06 <iqubic> dsal: Can I see what you did?
14:18:17 <iqubic> for the incr function only.
14:18:26 <iqubic> Don't spoil the rest of the puzzle.
14:21:38 <dsal> https://www.irccloud.com/pastebin/DhCN4K7G/incr.hs
14:22:32 <dsal> Might be good  to benchmark the two and see if there's a material difference.  I think they're both OK.
14:23:46 <iqubic> That looks ugly.
14:26:04 <dsal> OK, thanks.
14:27:48 <iqubic> Sorry, I just think it's easier to understand my thing.
14:27:58 <dsal> It's not.
14:28:16 <iqubic> Also, does your function handle "zzzzzzzz"?
14:29:35 <dsal> What does the specification say to do when you increment "zzz" ?
14:30:21 <iqubic> It's undefined.
14:30:56 <dsal> Then I'd rather have an error than infinitely loop with an assumed next case.
14:31:20 <iqubic> Really, I see.
14:32:42 <dsal> Partial functions are kind of bad, but silent errors are worse.
14:34:24 <iqubic> Yeah.
14:52:21 <erisco> What was that particular meaning of "functional"? Pure, denotational, and referentially transparent?
14:53:25 <Ailrun[m]> Considering functions as 1st class citizens
14:53:39 <dsal> functional usually means "the set of things that I, as someone who identifies as a functional programmer, care about right now"
14:54:10 <erisco> There is a specific meaning I am looking for
14:54:18 <Ailrun[m]> LoL
14:59:13 <erisco> Eh well I think that was it. Someone of import gave a list of necessities, whatever else FP is, but I forget who and what the list was
15:33:04 <dmwit> > foldr (\c ~(done, cs) -> (c /= 'z' || done, (if done then c else case c of 'h' -> 'j'; 'k' -> 'm'; 'n' -> 'p'; 'z' -> 'a'; _ -> succ c):cs)) (False, []) "zzz"
15:33:07 <lambdabot>  (False,"aaa")
15:33:18 <dmwit> > foldr (\c ~(done, cs) -> (c /= 'z' || done, (if done then c else case c of 'h' -> 'j'; 'k' -> 'm'; 'n' -> 'p'; 'z' -> 'a'; _ -> succ c):cs)) (False, []) "abcdzzz"
15:33:20 <lambdabot>  (True,"abceaaa")
15:33:46 <dmwit> > foldr (\c ~(done, cs) -> (c /= 'z' || done, (if done then c else case c of 'h' -> 'j'; 'k' -> 'm'; 'n' -> 'p'; 'z' -> 'a'; _ -> succ c):cs)) (False, []) ['a'..] -- laziness, wow
15:33:48 <lambdabot>  (True,"abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\13...
17:44:57 <wildtrees> Happy New Years | Happy New Decade! 
17:52:54 * hackage discord-haskell 1.2.0 - Write bots for Discord in Haskell  https://hackage.haskell.org/package/discord-haskell-1.2.0 (Aquarial)
18:08:45 <Axman6> wildtrees[m]: you're at least 14 hours too late :P
18:12:35 <tydeu> Why is the definition of `(>>)` in base `m >> k = m >>= \_ -> k` instead of `m >> k = m >>= const k`?
18:19:08 <ChaiTRex> tydeu: Because the former is in the style of using >>=, which generally has a \ arg -> after it.
18:19:55 <ChaiTRex> tydeu: Like do { a <- f; ... } has f >>= \ a -> ...
18:20:52 <tydeu> Makes sense, I just wanted to verify it was for optimization reasons
18:21:02 <tydeu> *was not
18:31:17 <Axman6> they should be exactly equivalent definitions 
18:36:40 <halogenandtoast> Is there a good way to check if Html/Markup from blaze contains a specific element
18:58:38 <alucard0> import Control.Monad.Trans.Cont
18:59:02 <alucard0> callcc $ \out -> let fn = out fn in return fn
18:59:42 <alucard0> g = callcc $ \out -> let fn = out fn in return fn
18:59:52 <alucard0> g :: m a
19:00:06 <alucard0> what's the value :: a in g?
19:00:31 <alucard0> fn is a fixed-point on out
19:01:41 <alucard0> (callcc $ \out -> fn) :: ContT r m a
19:06:13 <iqubic> Are we still trying to learn callCC?
19:06:42 <alucard0> can we?
19:09:19 <iqubic> Totally fine by me.
19:10:42 <alucard0> out :: (a-> ContT r m b)   fn :: a-> ContT r m a, right?
19:20:40 <dmwit> out's type is definitely going to be X -> X for some X. Dunno what that X is, but we know it has to be that, because it takes fn as an argument and produces fn as a result, so the input and output types have to be the same.
19:23:01 <alucard0> but callCC :: ((a -> ContT r m b) -> ContT r m a) -> ContT r m a
19:23:23 <alucard0> callcc $ \out -> fn
19:24:46 <alucard0> if (callcc $ \out -> fn) :: ContT r m a, so (\out -> fn) :: (a-> ContT r m b) -> ContT r m a
19:25:20 <alucard0> where was wrong?
19:26:24 * hackage exception-hierarchy 0.1.0.3 - Exception type hierarchy with TemplateHaskell  https://hackage.haskell.org/package/exception-hierarchy-0.1.0.3 (YoshikuniJujo)
19:26:38 <dmwit> alucard0: Why do you believe some part of that was wrong? I don't.
19:33:24 * hackage persistent-template 2.7.4 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.7.4 (MaxGabriel)
19:38:48 <alucard0> dmwit: g = callCC $ \out -> fn;  g >>= \a ...  this a is that a in out?
19:39:03 <alucard0> just a normal a, not a function a->r
19:41:17 <alucard0> I was wrong
19:41:26 <alucard0> g = callCC $ \out -> let fn = out fn in return fn
19:41:32 <alucard0> g :: ContT r m (ContT r m b)
19:42:09 <alucard0> but why?
19:54:28 <alucard0> 'cause return in return fn?
19:59:21 <iqubic> I wish Data.Sequence had a group function.
20:05:26 <dsal> Seems easy enough to write if you need such a thing.
20:06:26 <iqubic> Is there a better way to check for: "Passwords must contain at least two different, non-overlapping pairs of letters, like aa, bb, or zz." other than grouping up the chars?
20:24:30 <dsal> You don't need to group, you just need the counts.
20:32:33 <iqubic> Right. I suppose that's right.
20:32:55 <iqubic> Wait... No I don't.
20:33:46 <iqubic> I need to turn "aabbcd" into "[2,2,1,1]" I think.
20:34:19 <iqubic> But I have no idea how to do that.
20:37:22 <suzu> > "aabbcd"
20:37:25 <lambdabot>  "aabbcd"
20:37:28 <suzu> > group "aabbcd"
20:37:30 <lambdabot>  ["aa","bb","c","d"]
20:37:37 <suzu> > length <$> group "aabbcd"
20:37:39 <lambdabot>  [2,2,1,1]
20:39:37 <iqubic> suzu: That's great. But I can't use group on a Sequence from Data.Sequence.
20:39:53 <iqubic> Which is why I asked for help in here in the first place.
20:40:30 <suzu> oh right
20:42:22 <suzu> hmm, you could perhaps zip the sequence with it's tail?
20:42:49 <iqubic> How would that help?
20:43:11 <suzu> > Empty :: Seq a
20:43:13 <lambdabot>  error:
20:43:13 <lambdabot>      Not in scope: type constructor or class ‘Seq’
20:43:13 <lambdabot>      Perhaps you meant one of these:
20:43:26 <suzu> > import Data.Sequence
20:43:28 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
20:43:44 <dsal> :t group . F.toList
20:43:46 <lambdabot> (Eq a, Foldable t) => t a -> [[a]]
20:44:20 <iqubic> Should I do it that way?
20:44:48 <iqubic> I don't like doing toList all the time, but that might be the best way of doing it.
20:45:04 <iqubic> :t map length . group . F.toList
20:45:05 <lambdabot> (Eq a, Foldable t) => t a -> [Int]
20:45:21 <dsal> You could implement group, you could use group, or you could write a custom count function.
20:45:37 <iqubic> :t sum . map (`div` 2 . length) . group . F.toList
20:45:38 <lambdabot> error:
20:45:39 <lambdabot>     • Couldn't match type ‘[a]’ with ‘t1 a1 -> c’
20:45:39 <lambdabot>       Expected type: t a -> [t1 a1 -> c]
20:45:43 <iqubic> Huh?
20:45:58 <iqubic> :t sum . map ((`div` 2) . length) . group . F.toList
20:45:59 <lambdabot> (Eq a, Foldable t) => t a -> Int
20:46:00 <suzu> how you do this has ramifications for your runtime btw
20:46:05 <iqubic> There we are.
20:46:10 <iqubic> suzu: I know that.
20:46:18 <suzu> ok good
20:46:38 <iqubic> dsal: How would I write a good count function?
20:47:00 <iqubic> Because I want "aaba" to count as one group and not two.
20:47:16 <iqubic> I also want "aaa" to count as one group only.
20:50:24 <dsal> It'd be straightforward with manual recursion.  It's probably not hard as a fold.  Just a little annoying because the first character is a special case if you're not just grouping.
20:50:37 <dibblego> fwiw, password composition rules go against NIST recommendations for password policies. https://nakedsecurity.sophos.com/2016/08/18/nists-new-password-rules-what-you-need-to-know/
20:54:08 <iqubic> dsal: Why do you have to special case the first few if you are folding?
20:56:42 <ephemient> you could Nothing <| (Just <$>  seq) or something like that to avoid the special case
21:03:31 <iqubic> How so?
21:05:51 <ephemient> \s -> zipWith (/=) s (drop 1 s) finds all the transitions but doesn't count the first group; if you stick a fake element before it all, that's the one that'll be ignored and all of your actual list will be counted
21:06:34 <iqubic> I have no idea how that's supposed to work.
21:07:03 <ephemient> (ditto with something fancier folding the count in place of the zip)
21:07:16 <suzu> it zips the sequence with the tail
21:07:22 <suzu> using /=
21:07:40 <iqubic> What will that do?
21:07:54 <suzu> so "abc" is zipped with "bc"
21:08:13 <zeta_0> do any of you guys use yesod? i want to know all the packages, and configurations, i will need to develop with it, i am setting up a default.nix script to install and configure everything in a nix-shell environment
21:08:18 <iqubic> > let foo s = zipWith (/=) s (drop 1 s) in foo "aabbaacc"
21:08:20 <lambdabot>  [False,True,False,True,False,True,False]
21:08:25 <suzu> making [(a,b), (b,c)]
21:08:31 <suzu> and then those are `/=`'ed
21:08:39 <zeta_0> is there some yesod documentation that goes in to detail with these things?
21:08:48 <iqubic> Hoe the hell does that help me?
21:08:53 <suzu> zeta_0: yesod has a book online
21:08:54 <ephemient> where it's True, is where a new group starts
21:08:59 <iqubic> Ah. I see.
21:09:01 <ephemient> because it was /= the previous
21:09:56 <iqubic> > let foo s = zipWith (/=) s (drop 1 s) in foo "aaaccdd"
21:09:58 <lambdabot>  [False,False,True,False,True,False]
21:10:12 <iqubic> I think a fold might help me more.
21:10:38 <ephemient> I mean, you'd use fold . zip in place of zipWith, that was just for demonstration
21:11:03 <ephemient> but honestly recursion would be easier
21:11:18 <iqubic> How would recursion be easier?
21:11:18 <ephemient> s mentioned earlier
21:11:41 <ephemient> I dunno what I could say without spoiling the whole thing
21:13:08 <zeta_0> suzu: i think i found the right link for yesod installation/configuration instructions
21:16:16 <iqubic> ephemient: Feel free to spoil it then.
21:16:48 <ephemient> > let f (x:xs) = let (eq, neq) = break (/= x) xs in length eq + 1 : f neq; f _ = [] in f "aaaccdd"
21:16:50 <lambdabot>  [3,2,2]
21:18:04 <iqubic> I see.
21:18:20 <ephemient> pretty much exactly what the `group` function does, just with `length` thrown in there
21:18:34 <iqubic> Right. I see
21:19:25 <ChaiTRex> > map length . group $ "aaaccdd"
21:19:27 <lambdabot>  [3,2,2]
21:22:21 <iqubic> :t let f (x:xs) = let (eq, neq) = break (/= x) xs in length eq + 1 : f neq; f _ = [] in f
21:22:22 <lambdabot> Eq a => [a] -> [Int]
21:22:25 <iqubic> I see.
21:24:45 <iqubic> What's up with the plus 1 there?
21:25:57 <ChaiTRex> iqubic: length eq gives the number of characters equal to x that occur after x, so I'd assume the + 1 is to add in one for the original x.
21:26:45 <ChaiTRex> iqubic: Well, that occur after without any /= x in between
21:33:55 <iqubic> Right. I see.
21:38:40 <iqubic> Well part2 was dead simple.
21:38:44 <iqubic> part2 = nextPasswd $ nextPasswd input
21:38:56 <sm[m]> Happy New Year! 🎈
21:39:18 <iqubic> Not for me 2 hours and 45 minutes for me.
21:39:23 <iqubic> I'm in PST.
21:39:37 <sm[m]> Me too !
21:40:04 <dsal> date +%G-%m-%d
21:40:12 <sm[m]> 9.37pm but I’m calling it!
21:41:45 <iqubic> dsal: If you use that format, then you will have been in the new year for three days already.
21:42:07 <dsal> Yeah.  I don't like waiting.
21:42:11 <nyc> Happy New Year!
21:51:16 <ephemient> re: strftime("%G"), https://youtu.be/D3jxx8Yyw1c
21:51:36 <ephemient> I was at Twitter and that is exactly what happened
21:55:22 <dsal> Oh nice.
22:11:52 <iqubic> Time to use Deep to make a super hard puzzle stupidly simple.
22:18:48 <ChaiTRex> iqubic: What is Deep?
22:23:06 <iqubic> It's a lens thing.
22:23:26 <iqubic> :t deep
22:23:28 <lambdabot> (Conjoined p, Plated s, Applicative f) => Traversing p f s s a b -> Over p f s s a b
22:24:09 <iqubic> part1 input = sumOf (deep _Number) input
22:24:41 <iqubic> And that's it. _Number is a prism from Aeson.Lens
22:39:45 <dsal> Heh, you should try it without having lens do it for you if you think it's super hard.  It's a fairly straightforward recursive find.
22:40:30 <iqubic> I know.
23:04:54 * hackage postgresql-simple-opts 0.6.0.0 - An optparse-applicative and envy parser for postgres options  https://hackage.haskell.org/package/postgresql-simple-opts-0.6.0.0 (JonathanFischoff)
23:42:24 * hackage layout-rules 0.1.0.2 - A collection of different layout implementations  https://hackage.haskell.org/package/layout-rules-0.1.0.2 (TrevorElliott)
