00:54:54 * hackage net-spider 0.4.0.0 - A graph database middleware to maintain a time-varying graph.  https://hackage.haskell.org/package/net-spider-0.4.0.0 (debugito)
00:55:54 * hackage net-spider-cli 0.2.0.1 - CLI option parsers for NetSpider objects  https://hackage.haskell.org/package/net-spider-cli-0.2.0.1 (debugito)
00:56:40 <hololeap> are there nice facilities for doing incremental input (a la conduit) with megaparsec?
00:57:24 * hackage net-spider-pangraph 0.2.0.0 - Conversion between net-spider and pangraph  https://hackage.haskell.org/package/net-spider-pangraph-0.2.0.0 (debugito)
00:58:53 * hackage net-spider-rpl 0.4.0.0 - NetSpider data model and utility for RPL networks  https://hackage.haskell.org/package/net-spider-rpl-0.4.0.0 (debugito)
01:00:54 * hackage net-spider-rpl-cli 0.1.2.1 - CLI executable of NetSpider.RPL.  https://hackage.haskell.org/package/net-spider-rpl-cli-0.1.2.1 (debugito)
01:16:05 <f-a> cabal-install ./bootstrap.sh freezes my 2g-ram lappy. Is there a way around that?
01:52:19 <kuribas> merijn: morning
01:52:48 <kuribas> merijn: what should I use for streaming the result in my library?  I could return a lazy list, but that's unsafe.
01:53:05 <kuribas> merijn: (my SQL library)
01:53:23 <kuribas> perhaps streamly, because it's light and performant
01:59:56 <kuribas> I wanted to name the library hasqly, but there is already a library named hasql
02:00:03 <kuribas> could be causing confusion
02:06:13 <day> when using createProcess (proc "program" ["arg1", "arg2"]) i have the problem that arguments with a space break the program. switching out the 'program' with echo shows that it seemingly looks correct, but the 'program' complains about 'no such option' 
02:06:59 <day> this is fixable by doing the following. instead of ["--arg1 foo"] you can do ["--arg1", "foo"] which miraculously works
02:08:14 <day> wrapping the whole argument  ["\"--arg1 foo\""] also works, but is that intended?
02:10:20 <day> nvm i take it back the 'wrapping' doesn't work, which leaves the nasty splitting solution
02:36:54 * hackage yx 0.0.4.3 - Row-major coordinates  https://hackage.haskell.org/package/yx-0.0.4.3 (mtth)
02:38:23 * hackage yx 0.0.4.2 - Row-major coordinates  https://hackage.haskell.org/package/yx-0.0.4.2 (mtth)
03:38:31 <Phyx-> @tell audiofile On Windows use chocolatey. `choco install haskell-dev` gives you a working environment that's correctly configured
03:38:31 <lambdabot> Consider it noted.
03:42:26 <nil> day: what's miraculous about that?
03:43:02 <nil> --arg1 is a valid argument for your command, "--arg1 foo" isn't
03:44:29 <nil> to go from a single string like "--arg1 foo" to a list of arguments, you need word splitting, which is usually the shell's job
04:06:53 * hackage servant-auth-server 0.4.5.0 - servant-server/servant-auth compatibility  https://hackage.haskell.org/package/servant-auth-server-0.4.5.0 (domenkozar)
04:50:58 <heebo> pipes or conduit?
05:13:24 * hackage template-haskell-compat-v0208 0.1.2 - A backwards compatibility layer for Template Haskell newer than 2.8  https://hackage.haskell.org/package/template-haskell-compat-v0208-0.1.2 (NikitaVolkov)
05:17:54 * hackage contravariant-extras 0.3.5.1 - Extras for the "contravariant" package  https://hackage.haskell.org/package/contravariant-extras-0.3.5.1 (NikitaVolkov)
07:36:37 <nyc> k4m1: Thank you much.
08:33:55 <reallymemorable> https://gist.github.com/reallymemorable/f5a8bf8cf93fe0f476a61dfec60809cd — how would i go about using the (x:xs) pattern to iterate through the list of [MyRecord]?
08:34:37 <merijn> reallymemorable: Well, that's rather hard to say without knowing what "MyRecord" is?
08:36:03 <reallymemorable> data MyRecord = MyRecord {_myRecord_yield :: Int, _myRecord_month :: Text}
08:36:21 <reallymemorable> i just want to thruogh and sum all the _myRecord_yield values
08:40:54 * hackage graphql-w-persistent 0.7.0.1 - GraphQL interface middleware for (SQL) databases.  https://hackage.haskell.org/package/graphql-w-persistent-0.7.0.1 (jasonsychau)
08:42:23 * hackage graphql-w-persistent 0.8.0.0 - GraphQL interface middleware for (SQL) databases.  https://hackage.haskell.org/package/graphql-w-persistent-0.8.0.0 (jasonsychau)
09:02:27 <unyu> I'm reading the Servant tutorial in which a Hackage client is quickly put together: https://www.servant.dev/client-in-5-minutes.html , and some functions seem to have their definitions missing. Moreover, the link at the end of the page says that the whole code is available in servant's repo, under the servant-examples/hackage directory, but no such directory exists in the repo.
09:03:39 <sm[m]> unyu: file a bug report
09:04:20 <unyu> In particular, regarding the functions “getUsers”, “getUser” and “getPackages”, I am not sure whether the definitions are missing because they can be somehow inferred automatically (seems implausible) or because they are supposed to be obvious and easily inferred by the reader of the tutorial.
09:07:19 <unyu> Oh, apparently there is a dedicated Servant channel. Sorry for the annoyance. Moving there.
09:09:28 <unyu> Also, apparently the problem is just that I don't understand the Haskell language. Apparently, you can have three type signatures in three different lines, and then a single body in which all three symbols are defined together.
09:11:09 <merijn> unyu: Sure, why not?
09:20:58 <unyu> merijn: Pattern matching anything other than function arguments on the left-hand side is just something I didn't do too often, because fear of inexhaustive matches.
09:24:12 <__monty__> I haven't seen this before either fwiw.
09:24:32 <__monty__> Is it getting the implementations of the functions from hackage?
09:24:38 <unyu> No, no.
09:24:53 <unyu> I just failed to understand the immediately following line in the tutorial.
09:25:04 <__monty__> Well I'm failing too.
09:25:42 <unyu> There is a type constructor “data a :<|> b = a :<|> b”.
09:26:07 <unyu> So the left-hand side “getUsers :<|> getUser :<|> getPackages” is just pattern-matching a triplet.
09:26:16 <__monty__> Yeah but how do the names get bound at the top-level?
09:26:34 <__monty__> Variables in a pattern match don't usually live past the function body, no?
09:26:41 <unyu> These are not function arguments.
09:26:58 <__monty__> Yeah they're constructor arguments. Which is already weird.
09:27:16 <unyu> Have you seen a definition like “(foo, bar) = ...” ?
09:27:29 <unyu> It is not fundamentally different from that.
09:27:43 <__monty__> Only in a let binding. It's weird at the top-level imo.
09:27:55 <unyu> Except for the fact that :<|> is a custom data constructor, rather than the built-in tuple data constructor.
09:27:58 <zeta_0> could you guys help me with a haskell problem that is related to emacs, no one on the #emacs channel is responding?
09:28:28 * unyu would help, but is not really an expert in haskell-mode...
09:29:22 <zeta_0> i want to change this setting in my .emacs file, scroll all the way to the bottom: https://github.com/millejoh/emacs-ipython-notebook/issues/636
09:32:29 <unyu> Ah, sorry, I know even less about Jupyter... haskell-mode at least I use, Jupyter I don't. :-|
09:32:51 <zeta_0> if you guys can't help it's alright, i'll wait for a response in #emacs
09:45:54 * hackage tmp-postgres 1.34.0.1 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.34.0.1 (JonathanFischoff)
09:50:34 <hololeap> are there nice facilities for doing incremental input (a la conduit) with megaparsec?
09:59:55 <dsal> I've had good luck with Data.Conduit.Attoparsec.  I"m not sure if there's a megaparsec equivalent, though.
10:00:29 <solonarv> I don't think megaparsec is resumable at all, actually
10:00:32 <solonarv> it might be, let me check
10:01:34 <Rembane> It is, throw more content at it. 
10:01:44 <Rembane> If you get one of the result types 
10:05:09 <hololeap> yeah i'm using attoparsec right now
10:06:02 <solonarv> oh I see, runParser' lets you specify a starting state
10:06:05 <solonarv> that might do it?
10:06:38 <hololeap> solonarv: i looked at that and it looks like the mechanism is there, but it's really not very nice to work with
10:07:20 <hololeap> for instance the initial state that they use for runParser is not exported by the module
10:10:00 <hololeap> if you look at the results of an incomplete parse, the intermediate state is really arcane. the only thing that could be used to communicate its "incompleteness" is buried in an error type, and it seems prone to implementation chnages
10:17:16 <hololeap> % import Text.Megaparsec
10:17:16 <yahb> hololeap: ; <no location info>: error:; Could not find module `Text.Megaparsec'; It is not a module in the current program, or in any known package.
10:18:26 <hololeap> runParser' @_ @ByteString "abcd" (initialState "test" "abc")
10:18:38 <hololeap> (State {stateInput = "abc", stateOffset = 0, statePosState = PosState {pstateInput = "abc", pstateOffset = 0, pstateSourcePos = SourcePos {sourceName = "test", sourceLine = Pos 1, sourceColumn = Pos 1}, pstateTabWidth = Pos 8, pstateLinePrefix = ""}},Left (ParseErrorBundle {bundleErrors = TrivialError 0 (Just (Tokens (97 :| [98,99]))) (fromList [Tokens (97 :| [98,99,100])]) :| [], bundlePosState =
10:18:40 <hololeap> PosState {pstateInput = "abc", pstateOffset = 0, pstateSourcePos = SourcePos {sourceName = "test", sourceLine = Pos 1, sourceColumn = Pos 1}, pstateTabWidth = Pos 8, pstateLinePrefix = ""}}))
10:19:12 <hololeap> i think that result speaks for itself ;)
10:20:46 <geekosaur> there's a conduit-parser package, but it's out of date (conduit 1.2, if nothing else, granting there are back compat shims) and may assume Parsec
10:24:32 <hololeap> *sigh* ok
10:26:01 <hololeap> since i'm parsing a stream that needs to be broken into individual lines anyway, i suppose i wouldn't need incremental input per se. i could just parse each line from linesC
10:29:24 * hackage elm2nix 0.2 - Turn your Elm project into buildable Nix project  https://hackage.haskell.org/package/elm2nix-0.2 (domenkozar)
10:55:24 * hackage persistent-mysql-haskell 0.6.0 - A pure haskell backend for the persistent library using MySQL database server.  https://hackage.haskell.org/package/persistent-mysql-haskell-0.6.0 (naushadh)
11:09:02 <unyu> Is there a Servant-like framework for making IRC bots?
11:10:17 <dmj`> @package irc-core
11:10:17 <lambdabot> http://hackage.haskell.org/package/irc-core
11:10:31 <unyu> Thanks, checking.
11:11:57 <merijn> __monty__: It seems perfectly logical/consistent to allow pattern matches at the top level if you're going to allow them in where/let/etc.
11:12:13 <merijn> __monty__: Special casing the top level to be different is just inconsistency for no reason
11:12:45 <merijn> And with single constructor records it can be quite useful/convenient to bring several things in scope that way
11:12:57 <__monty__> It's already special-cased for not requiring a let : >
11:13:23 <merijn> __monty__: It's not, though. Modules start with "where" :p
11:14:06 <__monty__> Ok, so only an implicit Main module is special-cased I guess.
11:14:39 <geekosaur> that just pretends you wrote: module Main where
11:22:40 <wildtrees> using readFile, how do I find out the file doesn't exist, like which exception is that to catch? 
11:23:12 <maerwald> wildtrees: NoSuchThing
11:23:36 <maerwald> well, may depend on which haskell library you use
11:23:50 <maerwald> if using proper POSIX functions, that should be the one
11:26:36 <maerwald> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.IO.Handle.FD.html#openFile
11:27:05 <maerwald> yes, it's NoSuchThing
11:27:55 <merijn> wildtrees: Use readFile from Text
11:28:10 <merijn> maerwald: That doesn't do the same thing, though. That just opens a Handle
11:28:19 <maerwald> merijn: readFile uses openFile.
11:28:48 <merijn> maerwald: Sure, but the problem is the the String readFile uses lazy IO which means the exception may happen at weird times and thus be tricky to catch
11:28:57 <maerwald> yes, lazy IO is crap
11:29:13 <maerwald> check out streamly 
11:29:23 <merijn> readFile from strict Text doesn't have that problem, though
11:29:50 <merijn> maerwald: Just using the strict readFile works for lots of problems without requiring people to dive into streaming libraries :)
11:29:53 <maerwald> https://hackage.haskell.org/package/streamly-0.7.0/docs/Streamly-FileSystem-Handle.html
11:29:56 <maerwald> this is pretty cool
11:30:04 <maerwald> merijn: yeah
11:30:15 <maerwald> or just the unix package
11:39:25 <Solonarv_> unix package isn't as portable, though
11:39:39 <Solonarv_> it obviously doesn't work on windows ;)
12:06:44 <evelyn> windows services for unix and its many tortured descendants say hi
12:24:52 <jpcooper> Is there any sort of compilation profiler? I'd like to figure out where type-checking is taking so long
12:25:18 <jpcooper> (apart from profiling GHC itself)
12:26:33 <[exa]> jpcooper: any specific large package that you use?
12:27:13 <[exa]> otherwise I'd just try some extra verbose debug output with timing
12:27:22 <jpcooper> No, just a small library I've written that is maybe a bit too fancy when it comes to type things
12:27:43 <jpcooper> [exa]: Can you suggest specific flags?
12:28:06 <[exa]> good question. :]
12:30:30 <[exa]> maybe -ddump-tc-trace but that's a wild guess
12:33:48 <[exa]> hm yes, I get quite reasonable output from `ghc -ddump-tc-trace file.hs |ts -i`
12:34:11 <[exa]> except you'll probably want to have a bit better time resolution than from default ts
12:34:57 <jpcooper> Thanks. Will have a look
12:36:10 <[exa]> this looks great: ` ghc -ddump-tc-trace ... |ts -i "%.s" `   (anyway the ts utility is from moreutils IIRC)
12:38:39 <jpcooper> Didn't know about ts
13:05:04 <dsal> I just had to explicitly INLINE something.  That feels like a failure.
13:05:44 <koz_> dsal: Lol.
13:05:48 <geekosaur> that sounds like a known issue that has been discussed recently in #ghc
13:06:20 <geekosaur> (within the past week or so)
13:06:30 <dsal> I refactored some duplicated code like this.  It took twice as long.  With the INLINE, it was back to the original speed. https://www.irccloud.com/pastebin/Og4EKCrM/inline.hs
13:17:07 <ajdajdjksfe> Hello, my code is accepted by ghc but not by cabal, it complains with empty "Empty 'do' block" even if it works fine with ghc(i), is this behavior normal ? Here is the ugly fragment of code https://paste.ofcode.org/g2rv9q2Vpv6N5VzKV7w4Ei, it complains with the line with only "else do"
13:17:29 <dsal> ghc?
13:18:27 <ajdajdjksfe> Yes when I compile with ghc it doesn't complain, maybe cabal is doing extra work when checking the syntax ?
13:19:57 <merijn> What's the error?
13:20:43 <merijn> ajdajdjksfe: Unrelatedly: "if (isNothing foo)" and later "fromJust" makes baby jesus cry
13:21:48 <ajdajdjksfe> I'm using Debian so my cabal/ghc version is behind, I'm on ghc 8.4.4 and cabal 2.2.0.0, the error is just "Empty 'do' block" followed by the line related
13:22:30 <merijn> ajdajdjksfe: Something like this would be much nicer (same for the isJust later on): https://paste.debian.net/1122983/
13:23:37 <merijn> oh, I know
13:24:17 <geekosaur> I see some questionable indentation there. hm, and being specific about language in cabal config turns off NondecreasingIndentation
13:24:42 <merijn> cabal defaults to using Haskell98 (unless explicit default is specified), GHC defaults to Haskell2010, and that broken/weird indenting I think was part of the relaxation of do notation in 2010?
13:25:04 <geekosaur> which would affect how those lines are parsed (for example line 12/13)
13:25:30 <merijn> Anyway, the way the indentation is written right now is super questionable and should be fixed (and ideally the use of isNothing/isJust gets eliminated too, because that's just as awful
13:25:38 <solonarv> this looks like it should really just be a big MultiWayIf tbh
13:25:55 <merijn> solonarv: It looks like it should be 1 or 2 cases on Maybe, combined with some guards
13:26:05 <solonarv> yeah
13:26:19 <solonarv> I was going to suggest pattern guards for matching on the maybe's
13:26:40 <oats> Is there a reason that popular data structures like Set, Map, Seq, etc. can't have a generic constructor from anything that's Foldable?
13:26:45 <oats> `fromFoldable` or something
13:27:02 <solonarv> guess it just hasn't come up
13:27:10 <merijn> oats: Fairbairn threshold, probably
13:27:14 <solonarv> you can always just fromList . Data.Foldable.toList anyway
13:27:34 <solonarv> or 'foldMap singleton'
13:27:57 <monochrom> You would need another type class to generalize over the target typee (Map, Set, Seq etc)
13:28:13 <solonarv> technically,GHC.Exts.IsList counts!
13:28:39 <monochrom> The exact detailed design of that type class is going to be yet another hairsplitting and/or bikeshed colouring. (E.g., MPTC vs type family)
13:28:42 <oats> monochrom: well, I would imagine there could be a Seq.fromFoldable, Map.fromFoldable, etc.
13:29:49 <monochrom> Ah OK that's better.
13:29:51 <ajdajdjksfe> @merijn Haskell2010 is enabled in my cabal file, I think it must be related to some ghc options indeed. Anyway I must refactor this ugly pile of code.
13:29:51 <lambdabot> Unknown command, try @list
13:30:28 <ajdajdjksfe> Thank you guys for the response
13:30:40 <solonarv> (on IRC, it isn't customary to use an @ when mentioning people; just the name is enough)
13:31:15 <monochrom> Why is it called Fairbairn?
13:31:19 <geekosaur> again, if you *explicitly* select a specific language, NondecreasingIndentation gets turned off. we tracked this down some time ago
13:31:26 <geekosaur> it's annoying
13:31:27 <oats> ajdajdjksfe: odds are, if you type the first few letters of someone's handle and then press <Tab>, your client will complete it :)
13:32:01 <monochrom> geekosaur: Again, some people need to be told 3 times before they hear you :)
13:32:09 <Taneb> monochrom: I presume after Jon Fairbairn, who was in the Haskell committee way back when
13:32:10 <geekosaur> so try commenting that out and see if it works… but I'd still fix the indentation, because it's asking for trouble anyway
13:33:40 <monochrom> Delete completely and rewrite from scratch.
13:34:12 <geekosaur> also I am not sure I believe cabal defaults to Haskell98 simply because it's broken. (by the Num and AMP changes, among others, which can't be made H98-compatible. probably the same with MonadFail)
13:34:54 * hackage gi-gdkx11 4.0.1 - GdkX11 bindings  https://hackage.haskell.org/package/gi-gdkx11-4.0.1 (inaki)
13:34:55 <monochrom> Up to some versions cabal defaulted to Haskell98, explicitly adding -XHaskell98.
13:35:10 <merijn> Cabal defaults to Haskell98 because the field for specifying the default language was only added later
13:35:36 <merijn> So the only backwards compatible option is to default to Haskell98 (since older code couldn't define that field, since it didn't exist)
13:35:40 <monochrom> I think I heard that since some version the new default was Haskell2010
13:35:56 <merijn> Defaulting to the latest Haskell version in cabal would break older package that don't explicitly give a default
13:36:10 <merijn> monochrom: Haskell2010 is the default of *ghc*, not of cabal
13:36:32 <merijn> (at least, I don't recall any change in cabal related to that)
13:37:34 <monochrom> OK I'm too lazy to test now, but is it possible that "cabal-version: >= number" can also control the 98vs2010 default?
13:38:31 <merijn> monochrom: >= number is no longer valid syntax ;)
13:39:20 <merijn> Anyway, in the CABAL spec change notes there's no mention of default-language changing since 1.12. But yes, with the new cabal-version notation changing the default on a version basis would be possible without breaking things
13:42:15 <ajdajdjksfe> webchat also do completion when using @ and I don't use IRC often, I should install a real irc client
13:50:10 <hseg> Hi. Design question: I have a record type, where two of the fields determine all the others. Is there a nice way of taking this into account?
13:50:36 <Rembane> hseg: I would use a sum type for that.
13:50:59 <hseg> ?
13:51:38 <Uniaika> hseg: do you mean that your record is progressively filled according to the content of the first two?
13:51:41 <hseg> I basically want to be able to construct/destruct the same set of fields two ways
13:51:46 <Uniaika> *first two fields
13:51:52 <jle`> hseg: if two of the fields determine all others, then maybe you can just have two fields
13:51:58 <jle`> and then have the others be projection functions
13:52:37 <jle`> like data SumOf = SO { soA :: Int, soB :: Int, alwaysAPlusB :: Int }
13:52:37 <hseg> hrm... on second look, I'm misrepresenting the problem
13:52:43 <jle`> you can just have only the soA and soB fields
13:52:50 <jle`> and get getAPlusB :: SumOf -> Int
13:52:53 <Ailrun[m]> Or you can use view patterns if computation for those derived fields is not so expensive
13:52:55 <jle`> getAPlusB (SO x y) = x + y
13:52:57 <Ailrun[m]> (hseg)
13:56:09 <hseg> I have fields (dim, rank, order, symm, delta2). order and delta2 depend on the value of rank, symm and delta2 should technically have the dependent type `Vec dim a -> a`, dim and rank can be computed from each other
13:56:49 <hseg> (use case: doing some classical lie group stuff)
13:59:31 <hseg> Crazy idea: could use a typeclass with three parameters, one for selecting the actual record I want and two others encoding dim and rank. Use fundeps to guide inference.
14:00:00 <merijn> That sounds like it'd be a PITA to use?
14:00:31 <hseg> Don't have enough experience to tell
14:01:44 <hseg> Basically idea would be to have class Lie t d r | t d -> r, t r -> d where {order;symm;delta2}, with instances having some equality constraint between d and r
14:01:57 <hseg> (dim and rank are restricted to Nat)
14:05:02 <wildtrees> class (Eq r, Eq d) => Lie t d r | t d -> r, t r -> d where ... perhaps, hseg? 
14:06:37 <hseg> A bit permissive. Is class Lie t (d::Nat) (r::Nat) | t d -> r, t r -> d where ... grammatically correct?
14:06:47 <solonarv> it is!
14:07:15 <solonarv> you can even add a `r <= d` constraint or whatever the actual ordering relationship should be
14:08:20 <solonarv> generally speaking, in Haskell we tend to model "some algebraic structure" (e.g. Monoid, Group, Ring, etc) as a typeclass, and particular examples of that kind of structure as plain old data types which are instances of that typeclass
14:08:30 <solonarv> this seems to be what you are doing as well
14:08:35 <hseg> Nice! So instances like instance (dim ~ 2 * rank + 1) => SO dim rank would work, right?
14:09:28 <hseg> Yeah. Complication is that the classical lie groups can be named by two different naming schemes, emphasising different aspects
14:10:02 <hseg> (specifically, the number of "roots" they act on vs the dimension of the space they act on)
14:10:39 <solonarv> well, really if dim and rank determine each other you should only have one of them
14:10:52 <solonarv> (only one of them as a typeclass parameter, that is)
14:10:58 <UndefinedIsNotAF> Hey
14:11:03 <hseg> Yeah, but neither of them is more important than the other
14:11:12 <UndefinedIsNotAF> I have a question related to Haskell and Gentoo, can i ask?
14:11:13 <hseg> Or special in some way
14:11:20 <solonarv> UndefinedIsNotAF: yes, ask away!
14:11:43 <hseg> This is basically the old question re how to define Complex in disguise
14:12:02 <UndefinedIsNotAF> Both Haskell coders and Gentoo sysadmin wear a barb. But my question is does Gentoo user have longer beards than Haskell coder?
14:12:12 <UndefinedIsNotAF> solonarv: any idea?
14:12:47 <solonarv> oh wait, did you type sloppily and actually meant: instance (dim ~ 2 * rank + 1) => Lie (SO dim rank) dim rank
14:12:51 <solonarv> ?
14:13:12 <solonarv> UndefinedIsNotAF: I have no beard, so surely every gentoo user must have a beard at least as long as mine!
14:13:26 <hseg> No, meant what I wrote. SO ~ ()
14:13:40 <hseg> and is basically just used as an index
14:14:05 <solonarv> oh, so `instance ... => Lie SO dim rank` ?
14:14:09 <hseg> A more accurate design would have instance (dim ~ 2 * rank + 1) => Lie (SO dim) (B rank)
14:14:15 <hseg> Yes
14:15:10 <solonarv> then yes, that's valid
14:17:38 <UndefinedIsNotAF> solonarv: ok :)
14:18:02 <solonarv> UndefinedIsNotAF: so really, your premise is false: I, a Haskell coder, am unbearded ;)
14:18:02 <hseg> Even better, this simplifies the design somewhat: class Lie g r | g -> r, r -> g
14:18:25 <hseg> (assuming injectivity of the type families SO and B above)
14:19:33 <UndefinedIsNotAF> solonarv: friends told me that. I trusted them. They are my sysadmins... :/
14:19:53 <hseg> s/type families/types
14:20:04 <UndefinedIsNotAF> solonarv: my apologies to every Haskell coder which is unbearded :)
14:21:30 * Uniaika was introduced to Funtoo by her girlfriend at the time, that was a fun experience 
14:22:10 <solonarv> hseg: they *must* be injective if you want to write instances for them, because you can't write instances for type families
14:22:34 <solonarv> and any other sort of "type function" is always injective
14:23:08 <hseg> right. So declarations of the form newtype SO (n::Nat) = SO will be injective at the type level
14:23:19 <solonarv> yes
14:23:58 <hseg> And therefore I can have nonoverlapping instances Lie (SO (2*r)) (B r) and Lie (SO (2*r + 1)) (D r)
14:24:51 <hseg> (well, swap B and D for mathematical correctness there)
14:25:08 <solonarv> I don't even know what B and D stand for !
14:25:19 <solonarv> it might be a good idea to choose names that aren't one letter ;)
14:26:35 <hseg> https://en.wikipedia.org/wiki/Root_system#Explicit_construction_of_the_irreducible_root_systems
14:26:40 <hseg> Those are their names
14:26:51 <hseg> Because someone was feeling unoriginal
14:27:30 <hseg> Annoyingly, it goes A,B,C,D :: Nat -> (), E 6, E 7, E 8, F 4, G 2
14:28:02 <hseg> At least the last five are sensibly called the "exceptional" root systems
14:29:32 <hseg> BTW, is there a way to add a haddock to an instance declaration?
14:37:06 <solonarv> yes, same as any other declaration I believe
14:37:21 <hseg> OK
14:38:29 <hseg> Hrm. Getting error: Expected kind ‘* -> Nat -> Nat’, but ‘2 :: Nat’ has kind ‘Nat’
14:38:45 <hseg> regarding the constraint dim ~ (2::Nat) * rank
14:38:59 <hseg> (added the signature to try forcing the matter
14:39:01 <hseg> )
14:39:28 <hseg> Oh, is it parsing * as TYPE?
14:40:25 <flatmap> I am trying to solve an exercise in haskellbook that drives me nuts - the taks is to define a „Functor“ instance for :        newtype Mu f = InF { outF :: f (Mu f) }
14:40:57 <flatmap> any help will be greatly appreciated?
14:41:01 <flatmap> ? => !
14:41:52 <flatmap> this whole definition seems to be recursive and that’s probably the reason I don’t get it
14:41:58 <[exa]> flatmap: I'd start by writing the proper type of fmap for that
14:42:36 <flatmap> yeah, but I can’t even write the „instance … where“ line 
14:42:57 <[exa]> worry not, it will become apparent
14:43:01 <hseg> flatmap: instance Functor (Mu f) where ...
14:43:08 <flatmap> ok cool
14:43:11 <flatmap> I will try ...
14:43:17 <hseg> You'll probably discover you need some restrictions on f for that to work
14:43:25 <hseg> disregard that
14:43:43 <hseg> had a brain fart, sorry
14:43:48 <flatmap> np 
14:43:49 <flatmap> :-)
14:50:49 <hseg> Aha! Needed NoStarIsType
14:51:07 <hseg> That error message _sucks_
14:51:23 <hseg> No indication that that might be the problem whatsoever
14:52:54 * hackage cabal-helper 1.0.0.0 - Give Haskell development tools access to Cabal project environment  https://hackage.haskell.org/package/cabal-helper-1.0.0.0 (DanielG)
14:56:09 <solonarv> there is supposed to be some parser hackery to allow * to be used as multiplication *and* to mean Type
14:56:17 <solonarv> but I would guess it doesn't work all that well
14:57:49 <hseg> Well, to repro, :set -XDataKinds -XTypeOperators, then :k 2 * 4
14:58:08 <hseg> And this on GHC 8.6.5
15:00:21 <shachaf> Or :k 2 GHC.TypeNats.* 4 or something.
15:00:42 <hseg> OK, that works
15:01:17 <solonarv> yuck, qualified operators
15:01:18 <hseg> But that's really not obvious from the error message
15:03:11 <hseg> I suppose I should report this as a documentation issue?
15:03:17 <solonarv> yeah
15:03:30 <solonarv> might want to check if it isn't already fixed/improved in 8.8, first
15:03:59 <hseg> Do you have it installed? Not in the mood atm
15:04:14 <solonarv> I do, actually
15:05:14 <solonarv> nope, same behavior as 8.6.5
15:05:36 <hseg> omg precedence at type level is seriously not wherer it should be. (dim ~ 2 * rank) parses as ((dim ~ 2) * rank)
15:05:39 <hseg> :facepalm:
15:06:14 <solonarv> eve with NoStarIsType? oof
15:06:42 <hseg> Yep
15:07:02 <hseg> At least NoStarIsType makes it parse the * correctly
15:07:28 <hseg> ... and after all that:
15:07:42 <hseg>     • Illegal instance declaration for ‘Lie (Sp dim) (C rank)’
15:07:44 <hseg>         The coverage condition fails in class ‘Lie’
15:07:45 <solonarv> huh, :i ~ errors and :i (~) doesn't show a fixity declaration
15:07:46 <hseg>           for functional dependency: ‘g -> r’
15:07:48 <hseg>         Reason: lhs type ‘Sp dim’ does not determine rhs type ‘C rank’
15:07:50 <hseg>         Un-determined variable: rank
15:07:51 <hseg> instance (dim ~ (2 * rank)) => Lie (Sp dim) (C rank) where
15:08:17 <solonarv> oh right, I think that happens because the fundep checker doesn't look at instance constraints
15:08:43 <solonarv> you cuold just write 'instance Lie (Sp (2 * rank + 1)) (C rank)', I think
15:08:48 <hseg> ... OK, so it's back to the drawing board with a bunch of bug reports generated
15:08:52 <hseg> Let's try that
15:09:02 <hseg> Luckily my constraints aren't that complex
15:09:40 <hseg> Requires FlexibleInstances...
15:10:34 <hseg> And you're not allowed to use type synonyms in instances
15:11:26 <hololeap> TypeSynonymInstances?
15:11:43 <hseg> no dice
15:11:57 <hseg> ... maybe patterns might work better here?
15:12:07 <hseg> instead of working with classes?
15:15:04 <solonarv> maybe
15:15:12 * solonarv still doesn't know much about Lie groups
15:16:24 <hseg> All I'm doing is abstracting over an integration formula for functions defined on compact lie groups. I need to keep track of certain data, with the dependencies sketched above.
15:17:05 <hseg> ... and I've been stumbling over roadblock after roadblock
15:24:19 <hseg> solonarv: mind if I mention you by nick in the bug report?
15:24:38 <solonarv> sure, go ahead
15:24:45 <hseg> OK. Posted: https://gitlab.haskell.org/ghc/ghc/issues/17621
15:25:52 <Uniaika> one more reason to deprecate the * symbol to signify Type! :D
15:26:11 <hseg> yup
15:26:13 <JazzyEagle> Hello, all.  I'm having some issues with building a project that uses Haskeline.  I keep having an error that says "haskeline> /usr/bin/ld.bfd: cannot find -ltinfo"...
15:26:52 <JazzyEagle> Research shows need a link from the current libncurses libs to libtinfo.so.5, which I double checked, and it does exist in /usr/lib and /usr/lib64.  I'm not sure where to go from here, since that didn't seem to work.
15:27:18 <JazzyEagle> Any ideas?
15:27:52 <maerwald> does libtinfo.so exist?
15:27:58 <hseg> BTW, is there a reason not to parse (a ~ b * c) as (a ~ (b*c)) when ((a~b)*c) clearly fails to kind-check?
15:28:27 <JazzyEagle> maerwald: Not libtinfo.so, just libtinfo.so.5.
15:28:32 <JazzyEagle> Do I need that as well?
15:28:44 <Uniaika> JazzyEagle: yeah, sometimes the tooling is stupid and will complain 
15:28:51 <Uniaika> just make a soft link
15:28:55 <solonarv> I'm guessing it's just due to ~ having some sort of default "binds most tightly" fixity
15:29:08 <solonarv> since there doesn't seem to be a fixity declaration for it
15:29:09 <JazzyEagle> Ok.  Will give it a try.  Thanks, maerwald & Uniaika.
15:29:15 <hseg> That's dumb. It should clearly be infix 0
15:29:19 <Uniaika> JazzyEagle: keep us updated
15:29:23 <solonarv> (meanwhile * is infixl 7)
15:29:25 <maerwald> well, there could be arbitrary many libtinfo.so.<num>, how does the linker know which one to pick?
15:30:28 <JazzyEagle> It appears that fixed the issue.  I'll let you know, though, if I get it again.
15:30:31 <Uniaika> maerwald: UPDATE-ALTERNATIVES(8) with sane defaults would be a nice way to avoid this kind of hackery
15:30:35 <Uniaika> JazzyEagle: great :)
15:30:39 <JazzyEagle> Any idea why Haskeline continues to use libtinfo?
15:30:40 <maerwald> Uniaika: huh?
15:30:49 <JazzyEagle> Why it hasn't been updated to link to libncurses?
15:31:03 <JazzyEagle> Yeah, it looks like that did the trick.
15:31:08 <maerwald> update-alternatives serves a totally different purpose
15:32:03 <maerwald> well, if you manually change system lib stuff, it's good to know about how such libs are to be installed
15:32:39 <maerwald> the libtinfo stuff keeps annoying distro packager since a long time
15:32:52 <maerwald> and breaks cross-distro compatibility
15:33:11 <maerwald> GHC bindists have that problem too
15:34:24 <JazzyEagle> It does annoy folks, which is why I'm wondering, since libncurses 6 has been out for years now, why the package continues to reference libtinfo 5?
15:35:02 <JazzyEagle> I don't know if the developer is in here.  It looks like tickets were opened for this, but the developer closed it, pointing to this solution instead of fixing the code to resolve the issue permanently.
15:35:19 <JazzyEagle> Maybe I'll open another one and specifically ask the code be updated accordingly.
15:36:36 <hseg> solonarv: The plot thickens: ("foo" ~ AppendSymbol "foo" "bar") *does* kind-check
15:37:04 <JazzyEagle> Well, it appears Haskeline built fine now.  I'm onto another completely unrelated error now.  Thanks again for your help, maerwald & Uniaika!!
15:37:21 <maerwald> building from source is amazing! haha
15:38:00 <Uniaika> JazzyEagle: you're welcome :)
15:38:34 <hseg> OK, so this triggers for type-level operators
15:38:35 <Uniaika> < maerwald> the libtinfo stuff keeps annoying distro packager since a long time // yeah pretty sure I've never been spared by that. Except perhaps when I'm building stuff with Nix
15:39:06 <hseg> because checking at ErrorMessage, (foobar ~ foo :<>: bar) is also problematic
15:45:05 <solonarv> hseg: that's what I figured
15:45:29 <solonarv> you could try defining a bunch of type operators of varying fixity to investigate what exactly is happening
15:46:01 <hseg> yeah but it's late, I'm tired, and I want to get this code working before bed
15:46:12 <solonarv> fair enough!
15:46:26 <hseg> Also, I already posted the report: https://gitlab.haskell.org/ghc/ghc/issues/17622
15:46:28 <solonarv> just vomit parentheses all over it, I guess :S
15:46:36 <hseg> Yep
15:46:46 <hseg> except as we've established, that doesn't suffice :/
15:47:22 <solonarv> oh, right, that too
15:48:23 <hseg> Is it reasonable to ask that equality constraints be used when determining coverage conditions of fundeps?
15:49:29 <solonarv> yes, but perhaps there is some more-or-less good reason why that isn't done
15:49:41 <solonarv> I'm not familiar with the intricacies of the typechecker
15:50:00 <hseg> OK. Then I might as well open the feature request. Worst case, I'll be proved an idiot
15:53:03 <hseg> Wait. Would bringing in equality even solve the problem? Is GHC smart enough to realize that the sections of + and * are injective? 
15:54:55 <solonarv> I don't know anymore T_T
15:56:34 <hseg> Oh well. Opened enough tickets for one night, in any case
16:00:33 <hseg> Hrm. Toy example, just to make sure I have the design down. We have some isomorphism f :: A -> B with inverse f' :: B -> A, and want two patterns on (A,B) using them
16:01:20 <hseg> so that would be pattern FromA a <- (a,b) where FromA a = (a,f a), right?
16:01:45 <hseg> and pattern FromB b <- (a,b) where FromB b = (f' b, a)
16:02:21 <hseg> And then I'd be able to say e.g. foo = FromA a :: (A,B)
16:04:15 <hseg> dammit
16:04:23 <hseg> my design is all wrong
16:05:00 <hseg> bc while dim and rank can be determined from each other, the isomorphism between them differs for each instance
16:07:52 <solonarv> this typeclass is supposed to associate a Lie group and its Lie algebra, right?
16:08:22 <hseg> lie group and the root system associated to it
16:09:37 <hseg> Hm. Checking my code, I only seem to need two different constructors for the same datum...
16:12:36 <hseg> So I could Haskell98-ly write b-so :: Int -> Int -> LieStats, and then have b = b-so . (dimFromRank &&& id); so = b-so . (id &&& rankFromDim)
16:12:49 <hseg> That's probably the cleanest and easiest solution
16:21:15 <jle`> b 1
16:32:04 <hseg> jle`: ?
16:33:33 <jle`> wrong window, sorry :)
16:34:00 <MarcelineVQ> when you have a Battleship plugin for emacs
16:34:07 <hseg> :)
16:36:21 <jle`> MarcelineVQ: it helps pass the time while ghc is compiling :)
16:41:15 <hseg> hrm. dislike brittany's autoformatting. alternative recs?
16:42:12 <solonarv> stylish-haskell and ormolu/ormulu (?) are the other two I remember existing
16:44:00 <hseg> which do you use?
16:44:14 <MarcelineVQ> ormolu's formatting can be surprising but there's a tutorial about why it does what it does so you'll want to check that out before trying it
16:45:15 <hseg> MarcelineVQ: This https://github.com/tweag/ormolu/blob/master/DESIGN.md ?
16:45:17 <MarcelineVQ> e.g. https://www.tweag.io/posts/2019-05-27-ormolu.html
16:51:05 <solonarv> I haven't bothered setting up any of them so far
16:52:00 <solonarv> I think a while ago when I last tried stylish-haskell (or was it brittany?) it was not bleeding edge enough and choked on BlockArguments
16:53:07 <hseg> Yeah. Brittanny is giving me weird results wrt math expressions, and doesn't support pragmas and decls
17:00:00 <fragamus> is there an idiomatic way to express these: pairToList (a1,a2) = a1:a2:[]      listToPair (a1:a2:[]) = (a1,a2)
17:00:07 <fragamus> or a library
17:00:34 <ChaiTRex> fragamus: That looks fine.
17:00:55 <ChaiTRex> fragamus: Though the listToPair can be listToPair [a1, a2] =
17:01:08 <dibblego> https://hackage.haskell.org/package/linear-1.19.1.3/docs/Linear-V2.html
17:01:12 <ChaiTRex> fragamus: Similarly with the = [a1, a2] on the pairToList.
17:01:21 <fragamus> okie thanks
17:01:47 <dibblego> depends what you're doing on []
17:02:21 <ChaiTRex> fragamus: Take note, though that the types of both elements in the tuple must be the same. If they're different, pairToList won't work out.
17:02:45 <fragamus> yeah thats why i named them a1,a2 instead of a,b
17:03:37 <fragamus> im using traverse to generate some permutations and then calling a library that wants tuples
17:04:01 <fragamus> so I need this isomorphism
17:38:08 <dmwit> (It's not an isomorphism.)
17:44:05 <jle`> fragamus: if we got list sections, we could write it as `uncurry [,]` heh
17:44:43 <fragamus> nice
17:51:09 <shachaf> Good thing there are no list sections.
17:55:54 * hackage lsp-test 0.10.0.0 - Functional test framework for LSP servers.  https://hackage.haskell.org/package/lsp-test-0.10.0.0 (luke_)
17:56:30 <solonarv> watch me! I have a GHC API and I'm not afraid to use it!
18:00:08 * suzu shakes
18:02:24 <dmj`> list sections? now I've heard it all.
18:11:54 * hackage net-spider 0.4.0.1 - A graph database middleware to maintain a time-varying graph.  https://hackage.haskell.org/package/net-spider-0.4.0.1 (debugito)
18:12:54 * hackage coinbase-pro 0.7.2.0 - Client for Coinbase Pro  https://hackage.haskell.org/package/coinbase-pro-0.7.2.0 (mdunnio)
18:12:56 * hackage net-spider-rpl 0.4.0.1 - NetSpider data model and utility for RPL networks  https://hackage.haskell.org/package/net-spider-rpl-0.4.0.1 (debugito)
18:13:54 * hackage net-spider-rpl-cli 0.1.2.2 - CLI executable of NetSpider.RPL.  https://hackage.haskell.org/package/net-spider-rpl-cli-0.1.2.2 (debugito)
20:20:04 <zeta_0> when i run: cabal init in newly created directory, when i open the haskell files, haskell-ide-engine and language-server-protocol throw a bunch of weird errors, is this normal?
20:43:39 <suzu> its more likely to work well if you use stack instead of cabal
20:59:00 <iqubic> So, I'm trying to do some parsing in megaparsec, and it isn't working at all.
21:00:27 <iqubic> I'm trying to write a parser that parses many letters in a row, until it reaches a space. I tried this, but it didn't work:  "identifier = letterChar `manyTill` space"
21:02:34 <iqubic> It just returns the empty string 100% of the time. Regardless of what input I give it.
21:04:30 <pavonia> Do you have a full example to reproduce the problem?
21:09:17 <iqubic> http://dpaste.com/2RVWTD7
21:09:21 <iqubic> Yes. Yes I do.
21:09:40 <iqubic> I have that one parser fuction, and those imports, and all.
21:10:38 <iqubic> I run the function (runParser identifier "" "asd") in a repl and get (Right ""). I want to get the result of (Right "asd")
21:11:18 <sm[m]> don't you need a space at the end
21:11:56 <iqubic> Even if I add a space at the end I still get Right ""
21:13:55 <sm[m]> Yes, I see. To debug, usually I try running the component parsers by hand, then adding more of them
21:13:59 <pavonia> I think this is because space already matches at the beginning, so manyTill stops before consuming any letters
21:14:02 <amalloy> iqubic: look at the definitino of space
21:14:42 <sm[m]> aha
21:15:11 <iqubic> I'll just use space1 then.
21:16:07 <sm[m]> or (space1 <|> eof)
21:16:19 <iqubic> Yeah.
21:19:28 <iqubic> What does asum do when used with parsers?
21:22:29 <pavonia> asum [p0, ..., pn] = p0 <|> ... <|> pn
21:22:47 <iqubic> It doesn't wrap any of the parsers in try?
21:23:00 <iqubic> Well, that's my issue.
21:23:48 <iqubic> I want try p0 <|> try p1 <|> try p2 <|> ... <|> try pn
21:24:22 <pavonia> asum . map try?
21:28:10 <sm[m]> I for one am confused about try with megaparsec. Does it add try automatically, or not ? 
21:32:17 <pavonia> Yeah, it does for most of the parsers, IIRC
21:33:52 <glguy> Megaparsec doesn't automatically add try
21:34:44 <glguy> There are some functions that use try in their implementations to get the documented behavior
21:36:12 <MarcelineVQ> https://hackage.haskell.org/package/megaparsec-8.0.0/docs/Text-Megaparsec.html#v:tokens is of interest to the subject
23:20:25 <LordBrain> hello
23:21:09 <LordBrain> what does it mean if cabal spits out something with a colon in after a package name and the word setup followed by a dot and a library name?  like this:
23:21:53 * hackage tmp-postgres 1.34.1.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.34.1.0 (JonathanFischoff)
23:30:15 <LordBrain> I was dcd.. i didn't see if anyone responded to me
23:30:28 <iqubic> No one responded.
23:30:34 <MarcelineVQ> your paste didn't arrive
23:30:42 <LordBrain> whats the last line you got?
23:30:49 <MarcelineVQ>  like this:
23:31:35 <LordBrain> [__1] next goal: ApiGen:setup.Cabal (dependency of ApiGen)
23:31:35 <LordBrain> [__1] rejecting: ApiGen:setup.Cabal-2.2.0.1/installed-2.2... (conflict: ApiGen
23:31:35 <LordBrain> => ApiGen:setup.Cabal>=0 && <1.25)
23:32:12 <LordBrain> I don't know what this is telling me?  That cabal needs to be compiled linking against a newer version of the Cabal library or what?
23:32:49 <LordBrain> actually since it says >=0 and <1.25 that seems doubtful
23:33:45 <LordBrain> this ApiGen.cabal package comes with gtk2hs
23:34:20 <LordBrain> i was just trying to build it from github
23:35:12 <sclv> LordBrain: this ticket may help https://github.com/haskell/cabal/issues/5278#issuecomment-384102000
23:36:00 <sclv> it may be that gtk2hs hasn't updated that apigen stuff to work with newer cabals where more deps need to be explicitly specified
23:36:08 <sclv> for custom build types
23:37:28 <sclv> indeed it looks like the apigen dir of gtk2hs hasn't been touched in 5 years
23:37:32 <sclv> so its probably somewhat rotted
23:38:08 <LordBrain> oddly the ApiGen.cabal file doesnt have a buildtype specified
23:39:15 <LordBrain> here's the whole cabal file via github: https://github.com/gtk2hs/gtk2hs/blob/master/tools/apiGen/ApiGen.cabal
23:40:44 <LordBrain> i thought build-type was a required field
23:40:51 <sclv> it is, in modern cabal syntax
23:41:05 <sclv> its an ancient file so cabal is falling back to try to deal with it by assuming it has an ancient version
23:41:47 <LordBrain> well i'm willing to try my hand at updating... i guess i'd assume build-type simple
23:41:59 <LordBrain> maybe that'll just make it work?
23:42:10 <sclv> yeah i think it needs a bit more than that
23:42:15 <sclv> it needs a cabal version stanza, etc
23:42:25 <sclv> `cabal check` might warn you about what else
23:42:35 <sclv> or you could just move the file, and try to `cabal init` a fresh one with all the trappings
23:43:18 <LordBrain> oh thats a good idea
23:43:58 <LordBrain> before i saw your suggestion tho i just tried adding a single line wiht build-type: Simple, and it actually configured
