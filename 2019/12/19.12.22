00:44:18 <dmwit> What an odd thing to be sure of.
01:08:46 <glguy> Whatever happened to Monoid's mtimes?
01:12:48 <toast52> Data.Semigroup has a stimesMonoid
01:22:57 <nil> stimes is enough, isn't it?
01:23:29 <nil> oh, stimesMonoid 0 is mempty
01:31:54 <jle`> glguy: yeah, i vaguely remember mtimes ... existing
01:32:02 <jle`> maybe some mandela effect sort of thing
01:32:15 <glguy> there's even mtimesDefault to help you implement it
01:33:26 <jle`> that's just a leak from a parallel universe
02:03:36 <jle`> glguy: ah, 'groups' as pow
02:03:38 <jle`> https://hackage.haskell.org/package/groups-0.4.1.0/docs/Data-Group.html
02:04:10 <ytrog[m]> :wave:
02:04:22 <ytrog[m]>  * üôã‚Äç‚ôÇÔ∏è
02:04:42 <iqubic> why not just use (foldr1 (<>) $ replicate n x)?
02:06:21 <jle`> iqubic: you don't get repeated squaring
02:06:31 <jle`> so it's O(n) instead of O(log n)
02:07:11 <jle`> ie foldr-ing (<>) takes n applications of <>
02:07:14 <iqubic> Oh. I see. But it is the same result, right? It's just that the foldr1 version takes longer to compute right?
02:07:17 <jle`> but stimes/mtimes/pow only take log-n applications
02:07:21 <jle`> yeah
02:07:36 <jle`> longer by an exponential amount :)
02:08:00 <jle`> it's one of the common examples of the advantages of monoids/semigroups as an abstraction
02:08:13 <iqubic> Right. I might use stimes in my code for AoC. I'm not sure.
02:08:56 <iqubic> It's just that I already have a monoid for my ShuffleFunc datatype.
02:08:59 <iqubic> data ShuffleFunc = SF Integer Integer deriving Show
02:09:29 <iqubic> What is the s in stimes supposed to stand for? semigroup?
02:09:30 <jle`> iqubic: if you're using it for today's AoC, it basically takes the number of multiplications from 101741582076661 (one hundred million million) to essentially ~47 multiplications
02:09:35 <jle`> yes
02:10:32 <iqubic> Oh. I see.
02:10:35 <jle`> sorry for spoiling to anyone here D:
02:10:40 <jle`> please do not read if you are doing AoC :)
02:11:43 <iqubic> This is what I'm doing for generating the single polynomial that represents my 100 shuffle instructions: http://dpaste.com/0GZ9BTD
02:12:51 <jle`> ##adventofcode-spoilers D:
02:15:31 <Glaucon_> Hello
02:15:38 <olligobber> oh, does stimes do the logarithmic trick? cool!
02:20:33 <Glaucon_> I want to map a function (f :: a -> Maybe b) over a list and return Just [b] if f succeeds for all elements of the list. If f fails for an element, then I want the map function to return Nothing. What's the most neat way of doing this?
02:20:53 <jle`> Glaucon_: probably traverse
02:21:04 <jle`> traverse :: (a -> Maybe b) -> [a] -> Maybe [b]
02:21:24 <Glaucon_> That will probably work
02:21:27 <Glaucon_> Thanks
02:28:54 <dibblego> what is AoC? (Air Operator Certificate)
02:29:02 <olligobber> Advent of Code
02:29:15 <dibblego> ah thanks
02:42:36 <lyxia> Axiom of Choice
02:53:33 <nil> appellation d'origine contr√¥l√©e
02:55:15 <int-e> iqubic: you can make a Num instance and use (^).
02:59:48 <int-e> (Or maybe not; the instance will be dirtier than I thought, since fromInteger will only work properly for 1.)
03:04:45 <nil> fromInteger = SF 0  ?
03:15:46 <olligobber> is that a shuffle?
03:30:00 <bifunctor> https://github.com/commercialhaskell/stack/issues/5128
03:33:27 <nil> how do i solve this? i'm not sure where n0 is coming from https://up.monade.li/dcD939.hs
03:34:44 <jle`> nil: you need ScopedTypeVariables
03:35:07 <nil> i was about to say i think the `n` in my fromInteger type signature isn't bound
03:35:10 <jle`> nil: n0 comes from the n in Mod n, but ghc adds extra number at the end to emphasize that it's not the same 'n' as the n in KnownNat n => ...
03:35:19 <nil> ok
03:36:07 <nil> it works, thanks
03:36:16 <jle`> np!
03:36:43 <jle`> nil: fwiw it might be a little cleaner to use (Proxy :: Mod n) instead of making a throwaway value like Mod 0
03:37:05 <jle`> nil: another trick some people do is fromInteger i = x where x = Mod (i `mod` natVal x)
03:37:07 <nil> i got a kind error when i did that
03:37:10 <jle`> nil: that way you don't need ScopedTypeVariables
03:37:14 <nil> since Proxy expects a * but i have a Nat
03:37:17 <jle`> nil: ah you might need PolyKinds
03:37:36 <nil> er, wait, it works now
03:37:45 <jle`> at this point might as well use -XTypeInType, which implies DataKinds and PolyKinds
03:38:02 <nil> ScopedTypeVariables solved this, as a side effect, for some reason
03:38:13 <nil> i'll research all these extensions lol
03:38:16 <jle`> ah, that's interesting
03:38:28 <jle`> i guess it's just that they turn each other on and off in weird interconnected ways
03:39:16 <nil> TypeInType seems to be deprecated
03:41:20 <nil> i've got a weird idea.
03:41:36 <bifunctor> Do you guys use docker?
03:41:41 <nil> fromInteger i = let this = Mod (i `mod` natVal this) in this
03:42:02 <nil> THAT WORKS
03:42:04 <nil> AHAHAHAH
03:42:24 <nil> who needs Proxy
03:43:23 <bifunctor> I am using Stack to build my Haskell project
03:43:59 <bifunctor> In my app, I read an environment variable
03:44:18 <bifunctor> I've described my situation here https://www.reddit.com/r/haskellquestions/comments/ee3rqf/fooserviceexe_port_getenv_does_not_exist_no/
03:50:56 <bifunctor> how do to build your Haskell application?
03:51:46 <bifunctor> with Stack or Cabal?
03:52:00 <jle`> nil: ah yeah, that's what i sent a bit earlier too :)
03:52:12 <jle`> nil: but with a 'where' instead of 'let'
03:52:15 <jle`> i learned that trick from mniip 
03:52:32 <nil> oh, i missed that
03:52:42 <nil> good to discover it on my own i guess
04:04:47 <nil> why doesn't Fractional have a default definition `fromRational (a :% b) = a / b` ?
04:07:04 <nil> nevermind, that makes absolutely no sense
04:07:29 <nil> i think i meant `fromRational (a :% b) = fromInteger a / fromInteger b`
04:18:30 <__monty__> Maybe because people couldn't agree on the conversion? Usually if you use Rational you do it for the precision so you may be particular about the precision you lose when converting?
04:32:08 <nil> yeah, probably
05:28:45 <mtl123> hi is there something like unlift? I use "startEvalMemoT" together with scotty (web framework): (startEvalMemoT $ lift . scotty 3000 $ do) and 
05:29:03 <mtl123> now i want to unlift 
05:29:20 <__monty__> return?
05:32:07 <mtl123> __monty__ ah okay that works and now I have this problem: "No instance for (aeson-1.4.6.0:Data.Aeson.Types.ToJSON.ToJSON                         (MemoT String Quote IO Quote))"
05:32:45 <__monty__> Yeah, you can't just wrap the value you need to unpack it first and then `return` the proper thing.
05:33:10 <__monty__> This is just a guess based on your somewhat vague question though.
05:37:43 <mtl123> __monty__https://pastebin.com/iAs07AKG
05:47:27 <__monty__> mtl123: Hmm, maybe you want startEvalMemo rather than return?
05:47:39 <__monty__> I'm not sure what the outer startEvalMemo is trying to do though?
05:48:17 <__monty__> If that's the way you want it you probably want to fmap the entire block over the getQuote call.
05:51:35 <mtl123> The problem is if I put the startEvalMemo in place of the return, then I have no caching mechanism (memoize), because the Memo is evaluated every time the route is called (GET request)
05:52:36 <__monty__> Then you'll want to fmap.
05:57:19 <mtl123> __monty__ hmm okay I have to think about that, thx. I will be back if I have further questions.
05:59:18 <__monty__> mtl123: Think about how you'd do it if startEvalMemo was `fromJust` and getQuote returned a Maybe.
08:30:44 <fulaphex> so I'm trying to install stack, but I'm stuck at error: cabal: Failed to build pantry-0.2.0.0.
08:33:26 <fulaphex> I just tried installing pantry-0.1.1.2, it also failed, so I'm having this weird feeling, that something is broken on my side, but I'm not really sure where to begin troubleshootng
08:35:30 <fulaphex> the command I used - `cabal install pantry-0.1.1.2`
08:35:45 <fulaphex> or previously `cabal install pantry`
08:36:21 <__monty__> fulaphex: Could you provide the full error when trying to install stack?
08:37:12 <ysangkok> fulaphex: i typically install stack before everything else, even ghc. since stack fetches ghc, you only really need to build stack if you are developing it
08:37:14 <fulaphex> http://ix.io/258k
08:38:11 <ysangkok> they have binary builds for windows and "most un*x"
08:38:24 <ysangkok> (which includes macOS)
08:39:24 <fulaphex> hmmm, so I should start with installing stack rather than installing stack through cabal?
08:40:14 <__monty__> Looks like stack requires an older version of the Cabal library than Cabal-3.0.0.0 comes with.
08:40:30 <__monty__> So we'd be talking about downgrading Cabal to then install Stack.
08:41:46 <fulaphex> but installing stack first, and then through that installing ghc and cabal is also a correct thing to do? 
08:45:07 <__monty__> You wouldn't have to if all you want is stack. It'll fetch a GHC whenever necessary. If you want all of them the haskell platform may be the simplest way to get them.
08:45:50 <fulaphex> __monty__: I know how it sounds, but I don't really know what I want. I need stack because IDE tooling requires that
08:51:17 <sshine> does anyone here use the 'doctest-discover' package?
08:51:53 <sshine> or perhaps some alternative package that aims for something similar?
09:07:35 <sm[m]> sshine: I just search for .hs files and pass that list to doctest... is there something smarter to do ?
09:09:07 <sshine> sm[m], I think doctest-discover does that for you. it says it was inspired by hspec-discover, so an automatic pass over all .hs files (except those you ask to omit).
09:09:10 <sm[m]> @freenode_fulaphex:matrix.org: how are you trying to install stack ? Manually installing pantry with cabal is not usually something you would be doing for that
09:09:10 <lambdabot> Unknown command, try @list
09:09:59 <sshine> sm[m], *-discover testing modules typically have that "scan the project directory" approach. I use tasty-discover similarly.
09:10:32 <sshine> sm[m], I'm trying to strike the ideal convenience/hipster ratio here. :-P
09:11:42 <sm[m]> sshine: cool. Here's what I do, it seems easy enough: https://github.com/simonmichael/hledger/blob/master/hledger-lib/test/doctests.hs
09:12:00 <Rembane> sshine: QuickCheck uses some Template Haskell stuff to find their properties. 
09:14:03 <sshine> Rembane, tasty-discover finds QuickCheck/Hedgehog properties by scanning for prop_/hprop_ top-level definitions.
09:14:51 <Rembane> sshine: How boring. :D
09:15:33 <sshine> Rembane, I guess the different test libraries come bundles slightly different. e.g. Hspec has direct support for embedding properties into your Spec values, which looks pretty neat :) unfortunately, Hspec and Hedgehog don't have that kind of integration (the hspec + hedgehog interop libraries are all deprecated or broken)
09:15:49 <sshine> but it doesn't really matter, since Tasty has that.
09:16:04 <sshine> Rembane, and yes, it's very boring! ;-P
09:16:27 <Rembane> sshine: Indeed, I'm a big fan of tasty, it just works and things seem to be implemented in a boring but reasonable way. :)
09:16:30 <sshine> Rembane, it's hardly even hipster-like! I feel like I should have more discovery packages added, ha.
09:18:39 <__monty__> sm[m]: They were probably trying that as a troubleshooting step. P.S. This is what your mentions look like, it's verry jarring on the IRC side of the bridge: "@freenode_fulaphex:matrix.org:"
09:19:26 <Rembane> sshine: Yes! Add them all! :D
09:19:53 <sm[m]> monty: ah thanks for letting me know. Riot's IRC/matrix nick translations break down some times. I'll remember not to click on nicks when replying.
09:20:26 <sshine> sm[m], is matrix.org good?
09:20:28 <sm[m]> it also translates your underscores into markup/junk chars. I'll have to avoid that too.
09:20:38 <sm[m]> yes, very good
09:20:58 <sshine> sm[m], do you run your own matrix server?
09:21:06 <sm[m]> no, not yet
09:22:00 <sm[m]> I'm using it as a modern mobile IRC client (and it has kind of taken over on desktop as well)
09:22:25 <sshine> sm[m], ah, I could really use a mobile IRC client.
09:22:56 <sshine> I just haven't gotten around to finding an "IRC bouncer". the ones I remember seemed so 90s hacker-like.
09:23:02 <sm[m]> I can recommend Riot
09:23:23 <evelyn> it's the only client that supports encryption :(
09:24:02 <sshine> sm[m], I'll write that down.
09:24:08 <sm[m]> evel	yn: are you sure ? I heard weechat-matrix does too
09:24:50 <evelyn> I didn't know that! That's interesting
09:25:03 <sshine> ugh, weechat. having used irssi for nearly two decades, it feels hard to sit in something that *almost* works like you're used to. :)
09:25:06 <evelyn> at least for a while riot was the most feature-complete one
09:25:40 <sm[m]> Riot tends to be ahead feature wise, I think it's developed by some of the same folks maybe
09:27:03 <sm[m]> so fulaphex, I was wondering if you had tried stack's install script
09:31:25 <evelyn> i think they left the channel :/
09:33:53 <sshine> yes
09:34:13 <sshine> (although I cannot see when, either)
09:39:22 <sshine> https://gist.github.com/sshine/ea2046d5488aa9c2eff6a996b60ba2f7 <- why do I get a 'Property' vs. 'PropertyT m0 ()' discrepancy here?
09:40:54 <sm[m]> Doh! Right you are evelyn.
09:41:45 <evelyn> :(
09:41:47 <sshine> if I comment out the type signature, I get "Ambiguous type variable ‚Äòm0‚Äô arising from a do statement prevents the constraint ‚Äò(Monad m0)‚Äô from being solved."
09:44:59 <sshine> I've tried with 'PropertyT (Either WhoisError) ()' and 'PropertyT (GenT (Either WhoisError)) ()', but at this point it feels more like guessing.
09:49:53 <sshine> okay, 'property $ do ...' fixes this.
09:51:05 <sshine> ah, I thought 'Property' was a fancy alias for 'PropertyT ...', but apparently it also contains a PropertyConfig.
10:46:10 <oats> sshine: RevolutionIRC is a really nice FOSS android irc client
11:39:16 <Uniaika> hello everyone
11:39:51 <koz_> Uniaika: Haiii.
11:41:01 <Uniaika> I am in the process of writing a Forth interpreter, for whose stack I have a Vector. Most of the operations I've implemented were stack manipulation ones, but now I'm hitting the "output" functions. I thought about using MTL and instead of returning a `Stack` datatype from my 2nd-to-top level function, I'd return a `(MonadIO m) => m Stack`. 
11:41:28 <bitmapper> anyone know what's going on with haskell-ide-engine
11:41:40 <Uniaika> However I have a top-level function that folds over the buffer of instructions and calls the proper functions for stack manipulation
11:41:45 <Uniaika> bitmapper: it's ghcide now
11:41:59 <bitmapper> ?
11:42:09 <Uniaika> bitmapper: https://github.com/digital-asset/ghcide
11:42:14 <bitmapper> i use emacs though
11:42:18 <Uniaika> so what?
11:42:21 <bitmapper> oh nice
11:42:22 <bitmapper> huh
11:42:27 <Uniaika> :)
11:43:10 <bitmapper> why is hie still getting worked on then?
11:44:31 <Uniaika> bitmapper: idk
11:44:35 <fendoer> Uniaika, no, ghcide and hie are different projects
11:44:42 <yushyin> https://github.com/digital-asset/ghcide#history-and-relationship-to-other-haskell-ides
11:44:52 <Uniaika> fendoer: I was told by the community that ghcide was meant to take hie's place
11:45:13 <fendoer> Uniaika, there is consens to merge effort
11:45:19 <fendoer> but they are different projects
11:45:24 <Uniaika> ah yeah, ghcide was previously called hie-core
11:45:32 <Uniaika> must have been the reason why I mixed them up
11:45:50 <fendoer> yeah, confusing naming is speciality of the haskell ecosystem
11:45:57 <bitmapper> hmm
11:46:04 <fendoer> it never was the core of hie.
11:46:05 <bitmapper> i don't get why emacs is not working with hie
11:46:17 <fendoer> but maybe it will in the next months
11:46:32 <fendoer> bitmapper, sorry, I have no experience with emacs :/ otherwise I could probably hel
11:46:56 <bitmapper> same issue that's happening here, it was working before i rebuilt it https://github.com/emacs-lsp/lsp-haskell/issues/56
11:49:22 <fendoer> in vscode it seems to work atm. not using emacs myself.
12:06:06 <Uniaika> nah it's emacs-lsp's fault
12:12:12 <bitmapper> hmm?
12:13:46 <iqubic> Modular Arithmetic in Haskell is so very nice.
12:15:01 <Rembane> iqubic: Do you have an example? :)
12:18:51 <moet> hello, i'm a longtime user of haskell who used to build with cabal ~5 years ago and used stack in the interim.. i'm trying to migrate back to cabal for the v2- (nix-style) builds, but encountering problems with the preprocessor doctest-discover ...
12:19:28 <Rembane> moet: Which problem do you encounter? 
12:20:11 <moet> running `cabal v2-test` builds happily and ends with `ghc: could not execute: doctest-discover`
12:21:31 <moet> i tried doing `cabal v2-install doctest-discover` ... that installed to some in-store path, so i manually copied the executable out to my `.local/bin/` which is on $PATH and then got a _different_ error... 
12:22:44 <moet> so with the `doctest-discover` executable manually installed, when i run `cabal v2-test` i get: `doctest-discover: src: getDirectoryContents:openDirStream: does not exist (No such file or directory)` and `doctest-discover: src: getDirectoryContents:openDirStream: does not exist (No such file or directory)`
12:23:26 <phadej> moet: you don't need to install doctest-discover (i.e. it doesn't need to be in PATH)
12:23:55 <moet> phadej: yes, that's been my experience with stack, but i was unsure of whether cabal v2-* would be the same..
12:23:59 <phadej> probably you have some doctest component which should simply specify build-tool-depends: doctest-discover:doctest-discover >= version
12:24:25 <phadej> See https://cabal.readthedocs.io/en/latest/developing-packages.html#pkg-field-build-tool-depends
12:24:35 <seishun> what does '@' before type mean? like here https://github.com/glguy/advent2019/blob/master/execs/Day22.hs#L129
12:24:48 <moet> ooh... hmm, that wasn't in the readme for doctest-discover so i missed it! thank you phadej 
12:25:28 <phadej> moet: I think that doctest-disover author isn't aware of v2-build (based on stack.yaml in https://github.com/karun012/doctest-discover)
12:26:14 <phadej> so it might or might not even work
12:26:46 <phadej> probably it won't if you have https://cabal.readthedocs.io/en/latest/nix-local-build.html#cfg-field-write-ghc-environment-files disabled (which you probably do, as default is never)
12:27:13 <phadej> also, PROJECT NO LONGER MAINTAINED. MIGHT CONSIDER A REWRITE IN THE FUTURE
12:28:21 <phadej> so I'd recommend two alternatives, either using cabal-doctest (which I wouldn't recommend at that time) or cabal v2-install doctest and using environment files and testing manually
12:28:41 <phadej> later workflow is also supported by https://github.com/haskell-CI/haskell-ci
12:28:43 <Solonarv> seishun: that's a type application (to give you a term you can search for)
12:28:54 <phadej> (see generated .travis.yml there, it uses doctest too)
12:29:30 <Solonarv> briefly, if you have e.g. 'map :: forall a b. (a -> b) -> [a] -> [b]' then 'map @Int' says "okay, 'a' should be 'Int'"
12:29:35 <phadej> sorry for a wall of text, but tooling around is in a sad state; but there are just too good "good enough" workarounds, so e.g. myself don't do anything with those
12:29:44 <phadej> around *doctest
12:30:18 <seishun> Solonarv: thanks, looks similar to template arguments in C++
12:30:30 <Solonarv> seishun: yes, it's sort of comparable
12:31:19 <moet> ah, thanks phadej .. that's a lot of goot options.. i'll write them down and then come back to this as i have to go now
12:31:22 <moet> thank you!
12:31:54 <phadej> Maybe that's something I should write a blog post about
12:32:40 <Solonarv> normally of course the type can be inferred, but sometimes it can't (artificial example: show (read "123")) and you have to specify
12:33:12 <Solonarv> TypeApplications can make this more convenient because you only have to specify the part of the type that is ambiguous
12:57:50 <seishun> http://hackage.haskell.org/package/arithmoi-0.10.0.0/docs/Math-NumberTheory-Moduli-Class.html#v:getNatVal the description says "always between 0 and m-1 inclusively" but it seems to return m. what am I missing?
13:01:18 <koz_> seishun: As in, at runtime?
13:02:13 <seishun> koz_: I mean looking at the source code
13:02:22 <koz_> seishun: It definitely doesn't do that.
13:02:35 <koz_> The 'm' in 'Mod m' is a type-level label.
13:02:49 <koz_> It doesn't have any bearing (in a direct sense) of the _value_ inside a Mod m value.
13:02:55 <koz_> http://hackage.haskell.org/package/arithmoi-0.10.0.0/docs/Math-NumberTheory-Moduli-Class.html#t:Mod
13:03:22 <koz_> You see how it says 'data Mod (m :: Nat)'? That means that the type variable 'm' has kind 'Nat', which is the kind of type-level natural numbers.
13:03:41 <koz_> The fact that a Mod _value_ happens to contain something isn't really anything to do with that.
13:03:56 <seishun> but then what does "between 0 and m-1 inclusively" mean?
13:04:05 <koz_> What Mod guarantees is the thing inside it will have this property.
13:04:12 <koz_> It's being a bit glib, because it's blending type-level and value-level.
13:04:16 <koz_> What it should say is more like
13:04:34 <nil> (well, it guarantees the thing returned by getNatVal will have this property)
13:04:39 <koz_> "between 0 and (fromIntegral . natVal $ Proxy @m) -1.
13:04:40 <koz_> "
13:05:03 <glguy> seishun: @ is used for Type Application
13:05:06 <koz_> That 'm' in Mod m's type is a type-level tag - the value in there need not necessarily have anything to do with it.
13:05:41 <glguy> Oh, it looks like this topic is being handled :)
13:05:52 <koz_> glguy: :D
13:07:23 <MarcelineVQ> iiuc   getNatVal :: Mod m -> Natural; getNatVal (Mod x) = x   applied to      (3 :: Mod 10)     m is 10, x is 3
13:08:10 <koz_> And it's worth pointing out that the kinds of m and x are different here.
13:08:20 <koz_> The kind of m is Nat, but the kind of x is Type.
13:09:02 <koz_> So they're different 'kinds' (hurr hurr) of thing.
13:10:50 <nil> literally
13:11:37 <koz_> seishun: If this distinction confuses you, I recommend jle`'s Introduction to Singletons, part 1. You only need to read about half of it for that to become clear.
13:11:44 <koz_> (it uses a slightly less confusing example)
13:12:06 <MarcelineVQ> seishun: you might ask "so how do we ensure that x is less than m for some Mod m?" By only letting you construct them in a way that gurantees this. Either using modulo or fromInteger
13:13:59 <bifunctor> Hi all
13:14:05 <koz_> bifunctor: Wazzup?
13:14:14 <MarcelineVQ> fromInteger is what directly does the mod operation on your input. There's no way to make ‚Äãa Mod directly yourself as the constructor for Mod is not exported
13:14:45 <bifunctor> What is your recommendation cabal or stack?
13:15:06 <sclv> cabal
13:15:16 <bifunctor> why?
13:15:20 <bifunctor> what is nix?
13:15:28 <sclv> more flexible, more powerful
13:15:40 <LevyElara[m]> cabal has been less of a pain
13:15:49 <bifunctor> really
13:15:55 <sclv> nix is an os, that can manage all deps for you systemwide across all tools
13:16:08 <sclv> Very powerful but high startup cost to learn
13:16:17 <sclv> Best for production systems imho
13:16:36 <nil> well, nix is a package manager. nixos is the os
13:16:47 <bifunctor> So I should learn cabal nix and cabal?
13:16:47 <nil> </pedantic>
13:17:01 <sclv> just learn cabal at first
13:17:08 <koz_> Yep.
13:17:39 <sclv> either make sure you‚Äôre using cabal-install 3.0 or use the v2- commands with prior versions
13:17:41 <LevyElara[m]> isn't cabal enough on it's own now?
13:17:46 <moet> phadej: ok, so i added the build-tool-depends directive to my cabalfile and that worked (now v2-test correctly runs the doctest-discover executable) .. it fails somewhere internally.. i've tracked that down and fixed it (i didn't pass it a config, so it tried to scan files in src/ but i didn't have such a directory) .. all fixed! thanks
13:17:59 <MarcelineVQ> You need to understand more (non-haskell things) to use nix or stack than you do with cabal-install, as they both are going to be using cabal files anyway, to that end if you can use cabal-install you probably should. stack is nice because it can manage ghc versions for you, nix is good for doing that and fetching non-haskell dependencies you might need, cabal-install is all you need to use haskell comfortably
13:18:44 <seishun> koz_: thanks, will take a look
13:20:05 <glguy> managing ghc versions is easier now that we have ghcup
13:21:07 <bifunctor> When I run `stack build`, then I will get the binary right?
13:21:24 <nil> why would anyone want to manage ghc versions though
13:23:09 <MarcelineVQ> bifunctor: yes, if building was successful
13:24:00 <bifunctor> @MarcelineVQ: So I do not need any VM right?
13:24:00 <lambdabot> Unknown command, try @list
13:24:08 <bifunctor> it is a binary 
13:24:11 <bifunctor> right?
13:24:37 <MarcelineVQ> Yes it should be a native binary
13:25:28 <MarcelineVQ> nil: it can be simpler than patching dependencies yourself
13:26:14 <nil> why doesn't everyone just agree to use the latest version
13:26:38 <nil> does ghc really introduce breaking changes that often? and is it so hard to fix them?
13:27:28 <bifunctor> So guys 
13:27:33 <bifunctor> I have to learn about packaging 
13:27:39 <bifunctor> I have to use cabal
13:27:48 <geekosaur> breaking changes happen a lot, yes. currently we have MonadFail working its way through
13:27:57 <bifunctor> How should I start
13:28:05 <bifunctor> Or any goods ressources?
13:28:51 <MarcelineVQ> nil: sometimes things simply aren't updated that rapidly
13:29:15 <geekosaur> (actually it's live as of 8.8, which breaks enough code that I don't think there's a stack LTS for it yet)
13:29:23 <geekosaur> also, ghc changes rapidly
13:30:08 <geekosaur> there's a new release every couple months. 8.10 is in prerelease cycle already, and the ecosystem is still catching up with 8.8‚Ä¶
13:30:09 <sm[m]> stackage nightly is ghc 8.8
13:30:23 <moet> bifunctor: after installing a GHC and cabal-install, do `mkdir foo && cd foo && cabal init foo` will make a directory, change to it, and set it up with the necessary package files ... you have to answer a few questions
13:30:34 <sm[m]> Ah.. what you said
13:30:58 <bifunctor> does cabal support docker?
13:31:09 <bifunctor> Or nix is going to do it?
13:31:28 <bifunctor> I mean build a docker image
13:31:36 <moet> bifunctor: i don't think cabal does, but stack does.. that said i've never used the integration
13:32:19 <bifunctor> I am coming from scala world and it has https://sbt-native-packager.readthedocs.io/en/stable/formats/docker.html
13:32:21 <moet> bifunctor: most of the time with haskell you're building a statically linked binary and don't need anything else for deployment .. eg, you just deploy the binary and you're done
13:32:50 <moet> bifunctor: so docker images aren't necessary for most production uses of haskell
13:32:57 <bifunctor> @moet: I am using kubernetes,
13:32:57 <lambdabot> Unknown command, try @list
13:33:05 <bifunctor> that is why I need it
13:33:45 <moet> bifunctor: ok, i don't know anything about kubernetes, but if the unit of deployment for kubernetes is a docker image, then you could write a dockerfile that slurps up your compiled haskell binary and then deploy the resulting image?
13:34:36 <moet> ie. it would be an image with almost nothing but the binary .. you'll need to experiment with it referencing docker documentation to get that right.. sorry i can't help more with that
13:45:50 <bifunctor> @moet any goods resource to learn cabal?
13:45:50 <lambdabot> Maybe you meant: more let leet
13:48:43 <moet> bifunctor: i'd start with the official docs .. https://cabal.readthedocs.io/en/latest/ ..it's been a very long time since i was a beginner with cabal, so i'm not sure what resources are best for that
13:49:15 <moet> bifunctor: asking questions where when you're blocked and google isn't helping is a good way to make sure you keep progressing
13:50:47 <moet> bifunctor: actually, you start with the "5. Nix-style local builds" section of that 
13:51:04 <moet> bifunctor: https://www.haskell.org/cabal/users-guide/nix-local-build-overview.html
13:51:38 <bifunctor> ok
13:52:50 <moet> bifunctor: also, this video & accompanying documentation is a good start https://haskell-at-work.com/episodes/2018-05-13-introduction-to-cabal.html
13:53:09 <habbah> import Control.Category; import Data.Sequence; cons = (<|); snoc = (|>); snoc 1 <<< snoc 2 <<< singleton 1 -- why does this fail?
13:53:50 <habbah> I understand that singleton 3 |> 2 |> 1 will work
13:56:22 <bifunctor> @moet thanks a lot
13:56:23 <lambdabot> Maybe you meant: more let leet
14:04:06 <moet> habbah: i'm not sure what you're trying to do exactly.. are you trying to compose a couple of partial snocs together and then pass a value in at the end to get out a sequence of three items?
14:05:39 <habbah> moet: I want the equivalent of [3,2,1], and I know I can use function application, but I thought composing with <<< or >>> could work as well
14:07:52 <Solonarv> it can, but you have to keep the precedence in mind
14:08:24 <Solonarv> snoc 2 <<< singleton 1 parses as (snoc 2) <<< (singleton 1)
14:08:36 <Solonarv> but (singleton 1) isn't a function! so that is an error
14:09:25 <moet> habbah: i see two problems: 1) snoc's first argument is the list, not the element to prepend ... and 2) is what Solonarv said; since `singleton 1` is a value, not a function, you need to apply it to your composition pipeline
14:10:31 <moet> so this works .... (`snoc` 1) <<< (`snoc` 2) $ singleton 3 ... but it returns the list in the wrong order 
14:11:25 <moet> ah, it's the correct order... snoc appends; not prepends
14:12:39 <moet> if you swap out the snocs for cons, your original attempt is almost correct
14:13:07 <habbah> (|> 1) <<< (|> 2) $ singleton 3 -- thanks moet!
14:13:12 <habbah> and Solonarv 
14:51:44 <hololeap> is there a way to use something similar to RecursiveDo with a monad that does not have a MonadFix instance?
14:51:49 <hololeap> here's an example: https://gist.github.com/a9f8d3d20d1b5bcb6b0ad0a0ec5e1a1a
14:54:34 <hololeap> the constructor has a phantom Symbol which is matched first in the input string, but the constructor needs two parameters which are matched later in the input string
14:58:11 <hololeap> so ideally the constructor could be passed to fromCode even though it's parameters aren't available yet, because fromCode doesn't need that part
14:58:39 <hololeap> `fromCode $ Barb undefined undefined` works but it is ugly
15:02:12 <hololeap> (it looks like megaparsec has a MonadFix instance for its ParserT, but parsec and attoparsec do not)
15:02:20 <lyxia> that... sounds very much like MonadFix
15:04:41 <nshepperd2> Just hardcode the symbol?
15:06:26 <nshepperd2> Or make your parser have type Parser (Foob "BARB") and recursively refer to the parser itself, not its result
15:15:06 <dmwit> proxyFor :: Parser (Foob c) -> Proxy c; proxyFor _ = Proxy; foo :: KnownSymbol c => Parser (Foob c) -> Parser SomeFoob; foo p = SomeFoob <$> fromString (symbolVal (proxyFor p)) *> p; parseBarb = foo (liftA2 Barb decimal decimal)
15:15:13 <dmwit> hololeap: something like this, perhaps ^ ?
15:15:37 <dmwit> no recursion needed
15:16:16 <dmwit> (And you can `parseBazb = foo (pure Bazb)`.)
15:17:54 <dmwit> I dunno. Up to fixity of <$> and <* I guess.
15:18:18 <dmwit> I want SomeFoob <$> (fromString ... *> p); whether the parens are needed or not I'm uncertain.
15:20:03 <hololeap> hm... ok it sounds like the elegant solution i'm looking for needs MonadFix. i could just switch to megaparsec, i suppose
15:36:18 <phadej> dmwit: <$> and <* and friends are all infixl 4
15:36:46 <phadej> i.e., the same left as in function application
15:36:49 <phadej> (((f x) y) z)
15:37:20 <phadej> so if you want to skip some argument you can omit the >
15:37:41 <phadej> Constructor <$ skipped <*> notSkipped <* skipped-again <*> notSkipped
15:38:50 <phadej> or alternatively, if there's things you want to skip at the front, skip *> skip2 *> (mk <$> a <*> b <*> c)
15:40:05 <phadej> :i *>
15:40:08 <phadej> %% :i *>
15:40:09 <yahb> phadej: http://qp.mniip.com/y/26
15:40:11 <phadej> % :i *>
15:40:11 <yahb> phadej: class Functor f => Applicative (f :: * -> *) where; ...; (*>) :: f a -> f b -> f b; ...; -- Defined in `GHC.Base'; infixl 4 *>
15:48:42 <phadej> Phyx-: ghc not installed. The package was not found with the source(s) listed. Source(s): 'https://chocolatey.org/api/v2/;https://www.myget.org/F/mistuke/api/v2'
15:48:54 <phadej> Phyx-: is something wrong on appveyor?
15:51:12 <davve> haskell looks soo cool
15:55:17 <phadej> hmm, https://status.chocolatey.org/ looks like I'm not the only having problems
15:57:52 <dsal> davve: Most of us like it.
16:05:39 <Axman6> > let primes = 2 : filter isPrime [3,5..]; isPrime n = any (\d -> n `rem` d == 0) . takeWhile (\d -> d*d < n) $ primes in primes !! 100
16:05:43 <lambdabot>  *Exception: <<loop>>
16:05:52 <Axman6> > let primes = 2 : filter isPrime [3,5..]; isPrime n = any (\d -> n `rem` d == 0) . takeWhile (\d -> d*d <= n) $ primes in primes !! 100
16:05:56 <lambdabot>  *Exception: <<loop>>
16:09:27 <Axman6> > let primes = 2:3:5:filter isPrime [7,9..]; isPrime n = all (\d -> n `rem` d /= 0) . takeWhile (\d -> d*d <= n) $ primes in primes !! 100
16:09:30 <lambdabot>  547
16:09:37 <Axman6> > let primes = 2:3:5:filter isPrime [7,9..]; isPrime n = all (\d -> n `rem` d /= 0) . takeWhile (\d -> d*d <= n) $ primes in primes !! 10000
16:09:40 <lambdabot>  104743
16:09:50 <Axman6> > let primes = 2:3:5:filter isPrime [7,9..]; isPrime n = all (\d -> n `rem` d /= 0) . takeWhile (\d -> d*d <= n) $ primes in primes !! 1000000
16:09:56 <lambdabot>  mueval-core: Time limit exceeded
16:10:09 <Axman6> > let primes = 2:3:5:filter isPrime [7,9..]; isPrime n = all (\d -> n `rem` d /= 0) . takeWhile (\d -> d*d <= n) $ primes in primes !! 1000000 :: Int
16:10:16 <lambdabot>  mueval-core: Time limit exceeded
16:21:49 <int-e> Can't blame lambdabot for that one... it really is slow.
16:22:34 <phadej> let primes = 2:3:5:filter isPrime (concatMap (\n -> map (n * 30 +) [7,11,13,17,19,23,29,31]) [0..]); isPrime n = all (\d -> n `rem` d /= 0) . takeWhile (\d -> d*d <= n) $ primes in primes !! 10000
16:22:38 <phadej> > let primes = 2:3:5:filter isPrime (concatMap (\n -> map (n * 30 +) [7,11,13,17,19,23,29,31]) [0..]); isPrime n = all (\d -> n `rem` d /= 0) . takeWhile (\d -> d*d <= n) $ primes in primes !! 10000
16:22:41 <lambdabot>  104743
16:22:44 <phadej> > let primes = 2:3:5:filter isPrime (concatMap (\n -> map (n * 30 +) [7,11,13,17,19,23,29,31]) [0..]); isPrime n = all (\d -> n `rem` d /= 0) . takeWhile (\d -> d*d <= n) $ primes in primes !! 100000
16:22:49 <lambdabot>  mueval-core: Time limit exceeded
16:22:54 <phadej> > let primes = 2:3:5:filter isPrime (concatMap (\n -> map (n * 30 +) [7,11,13,17,19,23,29,31]) [0..]); isPrime n = all (\d -> n `rem` d /= 0) . takeWhile (\d -> d*d <= n) $ primes in primes !! 20000
16:22:58 <lambdabot>  224743
16:23:01 <phadej> > let primes = 2:3:5:filter isPrime (concatMap (\n -> map (n * 30 +) [7,11,13,17,19,23,29,31]) [0..]); isPrime n = all (\d -> n `rem` d /= 0) . takeWhile (\d -> d*d <= n) $ primes in primes !! 40000
16:23:07 <lambdabot>  mueval-core: Time limit exceeded
16:23:12 <phadej> > let primes = 2:3:5:filter isPrime (concatMap (\n -> map (n * 30 +) [7,11,13,17,19,23,29,31]) [0..]); isPrime n = all (\d -> n `rem` d /= 0) . takeWhile (\d -> d*d <= n) $ primes in primes !! 30000
16:23:18 <lambdabot>  mueval-core: Time limit exceeded
16:23:29 <phadej> > let primes = 2:3:5:filter isPrime (concatMap (\n -> map (n * 30 +) [7,11,13,17,19,23,29,31]) [0..]); isPrime n = all (\d -> n `rem` d /= 0) . takeWhile (\d -> d*d <= n) $ primes in primes !! 25000
16:23:35 <lambdabot>  mueval-core: Time limit exceeded
16:23:42 <int-e> wtf
16:24:11 <ChaiTRex> phadej: lambdabot takes requests in private.
16:24:23 <phadej> ChaiTRex: that's definitely less fun
16:24:31 <ChaiTRex> phadej: OK :)
16:25:32 <ysangkok> not at all embarassing to trial-and-error code with 1286 attendees :P
16:26:55 <phadej> > let primes = 2:3:5:filter isPrime (scanl (+) 7 $ cycle [4,2,4,2,4,6,2,6]); isPrime n = all (\d -> n `rem` d /= 0) . takeWhile (\d -> d*d <= n) $ primes in primes !! 10000
16:26:57 <lambdabot>  104743
16:27:01 <phadej> > let primes = 2:3:5:filter isPrime (scanl (+) 7 $ cycle [4,2,4,2,4,6,2,6]); isPrime n = all (\d -> n `rem` d /= 0) . takeWhile (\d -> d*d <= n) $ primes in primes !! 20000
16:27:06 <lambdabot>  224743
16:27:11 <phadej> > let primes = 2:3:5:filter isPrime (scanl (+) 7 $ cycle [4,2,4,2,4,6,2,6]); isPrime n = all (\d -> n `rem` d /= 0) . takeWhile (\d -> d*d <= n) $ primes in primes !! 25000
16:27:17 <lambdabot>  287137
16:27:23 <phadej> profit, slighly faster
16:28:29 <phadej> > let primes = 2:3:5:filter isPrime (scanl (+) 7 $ cycle [4,2,4,2,4,6,2,6]); isPrime n = all (\d -> n `rem` d /= 0) . takeWhile (\d -> d*d <= n) . drop 3 $ primes in primes !! 25000
16:28:34 <lambdabot>  *Exception: <<loop>>
16:28:38 <phadej> > let primes = 2:3:5:filter isPrime (scanl (+) 7 $ cycle [4,2,4,2,4,6,2,6]); isPrime n = all (\d -> n `rem` d /= 0) . takeWhile (\d -> d*d <= n) . drop 2 $ primes in primes !! 25000
16:28:42 <lambdabot>  287137
16:28:48 <phadej> > let primes = 2:3:5:filter isPrime (scanl (+) 7 $ cycle [4,2,4,2,4,6,2,6]); isPrime n = all (\d -> n `rem` d /= 0) . takeWhile (\d -> d*d <= n) . drop 2 $ primes in primes !! 30000
16:28:54 <lambdabot>  mueval-core: Time limit exceeded
16:28:57 <phadej> nope
16:29:18 <phadej> > let primes = (2 :: Int):3:5:filter isPrime (scanl (+) 7 $ cycle [4,2,4,2,4,6,2,6]); isPrime n = all (\d -> n `rem` d /= 0) . takeWhile (\d -> d*d <= n) . drop 2 $ primes in primes !! 30000
16:29:23 <lambdabot>  350381
16:29:29 <phadej> > let primes = (2 :: Int):3:5:filter isPrime (scanl (+) 7 $ cycle [4,2,4,2,4,6,2,6]); isPrime n = all (\d -> n `rem` d /= 0) . takeWhile (\d -> d*d <= n) . drop 2 $ primes in primes !! 40000
16:29:35 <lambdabot>  479939
16:29:48 <phadej> Int is faster than Integer, and we are not even close to the limit
16:29:57 <phadej> > let primes = (2 :: Int):3:5:filter isPrime (scanl (+) 7 $ cycle [4,2,4,2,4,6,2,6]); isPrime n = all (\d -> n `rem` d /= 0) . takeWhile (\d -> d*d <= n) . drop 2 $ primes in primes !! 100000
16:30:03 <lambdabot>  mueval-core: Time limit exceeded
16:30:17 <phadej> still, interpreted code has a limit
16:35:24 <RedNifre> > let fibs = 1 : 1 : (zipWith (+) (fibs (tail fibs))) in fibs !! 100
16:35:27 <lambdabot>  error:
16:35:28 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚Äò[a1] -> [c]‚Äô
16:35:28 <lambdabot>                    with actual type ‚Äò[Integer]‚Äô
16:35:42 <RedNifre> > let fibs = 1 : 1 : (zipWith (+) fibs (tail fibs)) in fibs !! 100
16:35:46 <lambdabot>  573147844013817084101
16:38:45 <axv21710[m]> let factorials = scanl (*) 1 [1..] in factorials !! 100
16:39:04 <axv21710[m]> > let factorials = scanl (*) 1 [1..] in factorials !! 100
16:39:07 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
16:41:01 <phadej> let primes = (2 :: Int):3:5:7:filter isPrime (scanl (+) 11 $ cycle [2,4,2,4,6,2,6,4]); isPrime n = all (\d -> n `rem` d /= 0) . takeWhile (\d -> d*d <= n) . drop 3 $ primes in primes !! 35000
16:41:05 <phadej> > let primes = (2 :: Int):3:5:7:filter isPrime (scanl (+) 11 $ cycle [2,4,2,4,6,2,6,4]); isPrime n = all (\d -> n `rem` d /= 0) . takeWhile (\d -> d*d <= n) . drop 3 $ primes in primes !! 35000
16:41:10 <lambdabot>  414991
16:41:15 <phadej> > let primes = (2 :: Int):3:5:7:filter isPrime (scanl (+) 11 $ cycle [2,4,2,4,6,2,6,4]); isPrime n = all (\d -> n `rem` d /= 0) . takeWhile (\d -> d*d <= n) . drop 3 $ primes in primes !! 40000
16:41:21 <lambdabot>  479939
16:41:28 <phadej> > let primes = (2 :: Int):3:5:7:filter isPrime (scanl (+) 11 $ cycle [2,4,2,4,6,2,6,4]); isPrime n = all (\d -> n `rem` d /= 0) . takeWhile (\d -> d*d <= n) . drop 3 $ primes in primes !! 100000
16:41:34 <lambdabot>  mueval-core: Time limit exceeded
16:41:37 <phadej> nope :(
16:41:48 <RedNifre> > let fibs = 1 : 1 : (zipWith (+) fibs (tail fibs)) in fibs !! 1000
16:41:50 <lambdabot>  7033036771142281582183525487718354977018126983635873274260490508715453711819...
16:42:28 <RedNifre> Anyway, has anybody done anything practical in Idris yet? I did a toy project, but I could have done it in Haskell just as well because I couldn't find a place to use Idris' features :|
16:52:33 <int-e> % let f n = runSTUArray $ do { a <- newArray (0 :: Int,n) True; forM_ [3,5..round (sqrt (fromIntegral n))] $ \x -> readArray a x >>= \b -> when b $ forM_ [3,5.. n `div` x] $ \y -> writeArray a (x*y) False; return a }; a = f 10000000 in length $ (2:Prelude.filter (\n -> a U.! n) [3,5..10000000])
16:52:38 <yahb> int-e: 664579
16:53:21 <int-e> (not quite 1 million (and it does time out soon after this point.)
16:55:01 <koz_> I'm looking at the code sample under 'One simple data structure' here: https://crypto.stanford.edu/~blynn/lambda/pts.html. What does the S data constructor represent in the Term data type? All the others are explained below, but not that one as far as I can see.
16:55:06 <int-e> The real answer to enumerating primes is to take a package that implements the sieve of Atkin. (arithmoi comes to mind, but there are probably quite a few others)
16:55:35 <Axman6> phadej: I'm guessing those numbers have a lot to do with https://www.youtube.com/watch?v=EK32jo7i5LQ
16:58:05 <Axman6> int-e: I just like that example as a nice demonstration of laziness and mutual recursion
16:59:17 <int-e> Axman6: sure, and it's great if you need a hundred or a thousand primes
16:59:36 <Axman6> or you have a lot of time
16:59:40 <dmwit> koz_: I would guess string literals.
17:00:17 <koz_> So... something analogous to a generalization of string literals and Symbols, then?
17:00:18 <dmwit> Oops, seems no.
17:00:31 <dmwit> "The type of a Lam is a Pi. The type of a Pi is an S."
17:00:53 <dmwit> So S is for sorts.
17:01:05 <dmwit> There's more on it in the "Pure Type Systems" section, I guess.
17:01:11 <koz_> Ah, so the String is in it is the sort's name?
17:01:19 <koz_> s/is in it is/in it is/
17:01:30 <MarcelineVQ> S is also used for kinds
17:01:41 <dmwit> koz_: yes
17:01:45 <d34df00d> dmwit: "Pure type systems" which book?
17:01:48 <koz_> OK, that makes a world more sense.
17:01:52 <koz_> https://crypto.stanford.edu/~blynn/lambda/pts.html
17:01:57 <koz_> d34df00d: ^
17:02:07 <d34df00d> Ah cool, thansk.
17:03:31 <koz_> OK, yeah, 'Pure Type Systems' makes that make more sense.
17:03:58 <koz_> Does Haskell have an analog of box, as described there?
17:04:08 <koz_> Like, I get *, but box not so much.
17:06:51 <koz_> Oh wait, doesn't Type :: Type mean that * and box are the same (at least for GHC)?
17:09:48 <MarcelineVQ> it's pretty confusing, but the gist is "The type of the type of a term is * and the type of the type of a type is ‚ñ°."
17:10:05 <koz_> So * is what GHC (now) calls Type?
17:10:27 <koz_> And box is the type of Type?
17:10:35 <MarcelineVQ> I mean for this page, I'm not relating it to ghc because I've no idea what TypeInType really does
17:10:45 <d34df00d> koz_: have you seen "type theory and formal proof"?
17:10:55 <MarcelineVQ> Box isn't even a ghc thing anymore iiuc
17:11:00 <d34df00d> I liked the treatment of different formation rules and sorts/kinds in general there.
17:11:22 <koz_> d34df00d: No, I haven't - link?
17:11:32 <RedNifre> I thought * was called kind?
17:11:40 <d34df00d> koz_: it's paywalled, sadly, but worth it IMO.
17:11:41 <koz_> MarcelineVQ: TypeInType (the extension) only enables a few other extensions now. Type :: Type is always on.
17:11:46 <d34df00d> https://www.amazon.com/Type-Theory-Formal-Proof-Introduction/dp/110703650X
17:11:57 <d34df00d> (you scan sci-hub it tho)
17:11:58 <koz_> RedNifre: Nope. * is _a_ kind. Nowadays, we call it 'Type'.
17:12:02 <koz_> There are other kinds too.
17:12:06 <koz_> (for example, Constraint)
17:12:11 <koz_> (or Type -> Type)
17:12:12 <MarcelineVQ> Always on for ghc, users opt-in afaik
17:12:33 <koz_> d34df00d: Thanks for the link.
17:12:46 <RedNifre> Oh, I thought kind was like String : *, List Int : * -> *, Map String Int : * -> * -> * and so on...
17:12:48 <koz_> It might be just what I need honestly.
17:13:04 <koz_> RedNifre: INothing you said there is incorrect.
17:13:32 <RedNifre> okay, but what is "Box" about?
17:13:32 <koz_> (except we now tend to call * as 'Type')
17:13:56 <koz_> RedNifre: In GHC, as far as I can tell, it's not a thing, so don't worry about it.
17:14:35 <Axman6> Map :: * -> * -> *, Map String :: * -> *, Map String Int :: *
17:14:39 <MarcelineVQ> that and you've applied List and Map so you'd have List Int : *   Map String Int : *
17:14:40 <RedNifre> If "*" is now called "Type", what are concrete things like "String" and "Integer" now called?
17:14:56 <koz_> RedNifre: They're types.
17:15:04 <koz_> Also, nice catch by Axman6 and MarcelineVQ.
17:15:05 <RedNifre> types vs. Types?
17:15:16 <koz_> There isn't such a thing called 'Types'.
17:15:21 <amalloy> Integer's kind is Type,  which means that Integer is a type
17:15:25 <koz_> There's Type, and there's types, and there's _a_ type.
17:15:57 <koz_> It is entirely correct to say 'Int, Map String Int, and 'f a b c' are types'.
17:16:00 <RedNifre> ah, thanks Axman6 and MarcelineVQ, looks like I missunderstood it.
17:16:05 <MarcelineVQ> "call it Type, they said, it'll be less confusing, they said"
17:16:10 <koz_> It is also entirely correct to say 'Int :: Type'.
17:16:31 <MarcelineVQ> Type is just a literal text replacement for *.  * = Type   Type = *
17:16:50 <RedNifre> So Int is of type Type?
17:17:07 <RedNifre> what does of kind Type mean then?
17:17:23 <koz_> As far as GHC is now concerned, there is no distinction between types and kind.
17:17:26 <koz_> s/kind/kinds/
17:17:37 <RedNifre> I thought * and * -> * and * -> * -> * were three different "kinds"
17:17:40 <koz_> That's what the whole Type :: Type business is all about.
17:19:08 <koz_> d34df00d: Dat book is dedicated to de Bruijn. I _know_ I'm in the right place. :P
17:19:10 <RedNifre> So if Map is of type "Type -> Type -> Type" or "* -> * -> *", what is the type of "Type -> Type -> Type"?
17:19:17 <koz_> RedNifre: Type.
17:20:19 <MarcelineVQ> % :kind (* -> * -> *)
17:20:19 <yahb> MarcelineVQ: (* -> * -> *) :: *
17:20:21 <RedNifre> "Type -> Type" and "Type -> Type -> Type" seem to be somewhat different. If they are both of type Type, is there a different category that differentiates them?
17:20:42 <RedNifre> I thought kind was now called type?
17:20:56 <koz_> RedNifre: "Int" and "Bool" seem to be somewhat different. If they are both of type Type, is there a different category that differentiates them?
17:21:20 <koz_> (can be made more emphatic by replacing "Int" with "Map String Bool")
17:22:18 <RedNifre> What I really love about this channel is that you can come here without questions, wait a moment, and then have many questions =)
17:22:41 <koz_> RedNifre: Yup, it's a great place to learn.
17:23:26 <koz_> The reason I started chasing all this is because I found a paper showing that you can unify the language of modules and non-modules in ML, demonstrated by showing how both can be jammed into System F_omega. It implicitly assumes Type :: Type.
17:23:29 <yushyin> I learned a lot here by just reading along
17:23:37 <koz_> So I'm like 'huh, I ought to read up on this a bit because it seems cool'.
17:23:46 <RedNifre> Do you think that dynamically typed FP languages like Clojure have their place?
17:23:54 <koz_> 'But I would rather see it presented in Haskell because it makes more sense to me that way'.
17:24:03 <Axman6> #haskell voyeurism is quite profitable
17:24:06 <koz_> RedNifre: You can write Haskell with everything of type Dynamic.
17:24:16 <koz_> Then ask yourself under what circumstances you would want to.
17:24:23 <koz_> I believe that is answer enough to that question.
17:25:24 <monochrom> No, Haskell with Dynamic is still very different from Clojure.
17:25:35 <koz_> monochrom: In what way?
17:26:00 <koz_> d34df00d: Not only do they dedicate that book to de Bruijn, they also decided on the power move of having Barendregt write the intro.
17:26:11 <monochrom> In Haskell with Dynamic, you always explicitly downcast to Integer (for example) before you can add.  In Clojure, you just go ahead and add.
17:26:45 <koz_> monochrom: I forget - when you downcast Dynamic, you get back a Maybe?
17:27:05 <monochrom> And then you fromJust.
17:27:10 <koz_> Ah.
17:27:40 <monochrom> You have such much boilerplate and line noise for downcasting and fromJust, it simply isn't the same code as Clojure.
17:28:00 <RedNifre> Well, I have this problem that I wrote a compiler in Idris and ended up with a type safe but sillily nested AST because when you parse according to the BNF you end up with number expressions inside multiply expressions inside add expressions inside AND expressions and so on... so I thought that parsing it in a Lisp to a non-typesafe AST might be easier to work with.
17:28:14 <monochrom> And don't forget our IO vs Clojure I/O.
17:28:26 <koz_> monochrom: Yeah, that second thing is a big point of difference definitely.
17:29:46 <monochrom> Will you have getChar :: Dynamic such that you have to use it like "(fromJust (downcast to IO Dynamic) getLine >>= \c -> ..."?
17:30:09 <RedNifre> Or maybe I should just have a look at template Haskell. E.g. check out the show code after around line 100 here, there should be a simpler way to do this, right?: https://gitlab.com/michaelzinn/voyc/blob/master/src/Parse/AllCommands.idr
17:30:44 <koz_> RedNifre: For questions regarding Idris, I suggest asking in #idris.
17:30:52 <koz_> There is non-trivial overlap, but Idris /= Haskell.
17:31:02 <koz_> (both in terms of concepts and in terms of people)
17:31:53 <RedNifre> koz_ it's not an Idris question, while the project is technically in Idris, it's basically just Haskell.
17:34:52 <d34df00d> koz_: haha, glad you liked it :)
17:35:04 <koz_> d34df00d: I'm having a read of it right now, and it's damn good so far.
17:35:12 <koz_> (obviously started from the beginning)
17:35:40 <d34df00d> They don't _prove_ much there (so I wish TAPL and TTFP got married and had a kid), but it's still a great book.
17:36:04 <d34df00d> I mean, don't prove much about the metatheory.
17:39:37 <ysangkok> RedNifre: is this just the expression problem?
19:03:23 <jusss`> :t (>>=)
19:03:24 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:03:59 <jusss`> _ >>= f   this f is a function, right? not an action
19:05:05 <MarcelineVQ> f is a function, its type is (a -> m b)
19:06:24 <EvanR> i think of it as a result handler
19:07:38 <MarcelineVQ> there's been enough analogies imho, best to keep to what things are :>
19:08:08 <EvanR> how results are handled depends on the Monad
19:08:25 <EvanR> this is kind of not analogy
19:12:57 <jusss`> should it be f :: (a->m a) -> m a?
19:14:16 <jusss`> Cont r a :: Cont (a->r) -> r
19:14:28 <jusss`> likely?
19:15:12 <MarcelineVQ> If you supply the first argument to >>= you get    (a->m a) -> m      but f is   (a -> m b) 
19:15:23 <MarcelineVQ> * you get    (a->m a) -> m a
19:15:29 <MarcelineVQ> % :t (Just 3 >>=)
19:15:29 <yahb> MarcelineVQ: Num a => (a -> Maybe b) -> Maybe b
19:15:52 <MarcelineVQ> I am not helping with these typos.   * you get    (a->m a) -> m b
19:16:41 <MarcelineVQ> gosh I did it again, ignore me, my brain's clearly not working tonight.   * you get    (a -> m b) -> m b
19:20:45 <jusss`> this Cont stuff really make me sad...
19:21:32 <EvanR> the good news is you probably don't need to mess with Cont if you don't want to
19:26:05 <suzu> in fact you can ignore half the language and still be productive
19:36:17 <dsal> I've still not even learned half the language, but have a lot of useful software written in it.
19:37:25 * glguy .oO( fact can half language still productive )
19:44:26 <arsdragonfly> fmap >>= id
19:46:42 <arsdragonfly> > fmap >>= id
19:46:45 <lambdabot>  error:
19:46:45 <lambdabot>      ‚Ä¢ No instance for (Typeable a0)
19:46:45 <lambdabot>          arising from a use of ‚Äòshow_M608975243982982151814815‚Äô
19:47:29 <moet> :t fmap >>= id
19:47:30 <lambdabot> (a -> a) -> a -> a
19:47:41 <arsdragonfly> why is it so?
19:48:33 <arsdragonfly> what is the monad here
19:48:49 <int-e> (a -> a) -> _
19:50:00 <int-e> :t fmap :: (a -> a) -> (a -> a) -> (a -> a)
19:50:02 <lambdabot> (a -> a) -> (a -> a) -> a -> a
19:50:54 <glguy> Are you aware that: instance Monad ((->) r)
19:50:59 <int-e> (the functor for fmap is a -> _)
19:51:38 <moet> and (->) is a type constructor of two arguments 
19:52:27 <arsdragonfly> wow
19:53:13 <int-e> > (fmap >>= id) succ 1
19:53:15 <glguy> to narrow things down (>>= id) is join, and join for the  ((->) r) monad instance is (\f x -> f x x)
19:53:16 <lambdabot>  3
19:53:16 <arsdragonfly> what's the best resource to learn how type inference works?
19:53:29 <glguy> so we can look at (join fmap) or \x -> fmap x x
19:54:39 <arsdragonfly> I thought the monad on the outside was ((-> ((->) a b)) but I didn't expect the functor to be what it is
19:54:44 <moet> arsdragonfly: i like this source becuase it gives an intuition for what's happening.. though it's not factually correct about several important details https://eli.thegreenplace.net/2018/type-inference/
19:55:20 <moet> once you get the intution from this post, it might be fine to dive into the microsoft research papers
19:55:33 <arsdragonfly> thanks!
19:57:05 <moet> arsdragonfly: this is another accessible source, but i'd read Eli's post first before Stephen's: http://dev.stephendiehl.com/fun/006_hindley_milner.html
19:58:14 <moet> (eli's post has some code that goes along with it, which is available here: https://github.com/eliben/code-for-blog/tree/master/2018/type-inference)
19:59:15 <ephemient> personally I came from having used SML before Haskell
19:59:54 <ephemient> I think it's a fairly good path to take - it's a smaller, simpler language, but plenty of things carry over (like H-M type inference)
20:00:44 * dsal shops for types at H&M
20:01:32 <ephemient> and with backpack we even have modules that work like what SML calls functors :)
20:02:25 <ephemient> (I don't know why they're called that ¬Ø\_(„ÉÑ)_/¬Ø)
20:03:30 <dsal> Is that like ocaml functors?
20:03:41 * dsal doesn't know what backpack is
20:04:08 <moet> arsdragonfly: here's one of the original HM types papers .. Hindley doesn't even show up .. this isn't really good for getting an intuition, but if you like typing-rules and incomprehensible math, this can also be helpful maybe .. https://web.cs.wpi.edu/~cs4536/c12/milner-damas_principal_types.pdf
20:04:36 <ephemient> dsal: OCaml's in the ML family so I expect so
20:04:45 <fragamus> hi im doing a calculation using iterate and i want to get the first result that matches a previous result
20:05:16 <fragamus> is there an idiomatic way or should i write it using recursion
20:05:19 <dsal> fragamus: I did a thing for that in my AoC lib:  findCycle :: Ord b => (a -> b) -> [a] -> (Int,Int,a)
20:05:25 <ephemient> https://gitlab.haskell.org/ghc/ghc/wikis/backpack is pretty much that for Haskell
20:05:56 <fragamus> Aoc?
20:06:08 <koz_> fragamus: Advent of Code.
20:06:19 <koz_> It's a local annual obsession.
20:07:46 <fragamus> nice
20:08:26 <dsal> fragamus: I wrote that with plain recursion.  It returns the position of the beginning of the cycle, the length of the cycle, and the item that's cycling.
20:08:53 <fragamus> nice I am just trying to get the stable value
20:09:00 <moet> i'm newly returning to cabal from stack ... and separate build plans for build/bench/test is biting me :(
20:09:03 <ephemient> I've just open-coded a loop with Map every time it comes up (which hasn't been that often)
20:09:08 <fragamus> but the other stuff can't hurt
20:09:31 <dsal> I just needed all those things, so i did them.
20:09:57 <moet> can i override dependencies' dependency version constraints at the command line?
20:10:08 <fragamus> that is super nice
20:12:39 <dsal> fragamus: what do you mean by "get the first result that matches a previous result"  What's the desired signature of this function?
20:14:55 <moet> under what circumstances would somebody want `cabal v2-configure` without `--enable-tests`? ... like, i guess if your project has no tests..?
20:15:38 <ephemient> :t \xs -> fmap fst . find (uncurry Set.member) . zip xs $ scanl (flip Set.insert) Set.empty xs
20:15:40 <lambdabot> error:
20:15:40 <lambdabot>     Not in scope: ‚ÄòSet.member‚Äô
20:15:40 <lambdabot>     Perhaps you meant one of these:
20:16:01 <ephemient> well anyway, something like that should do in a pinch
20:16:25 <dsal> :t S.member
20:16:27 <lambdabot> Ord a => a -> S.Set a -> Bool
20:16:35 <fragamus> [a]->a
20:16:40 <dsal> :t \xs -> fmap fst . find (uncurry S.member) . zip xs $ scanl (flip S.insert) mempty xs
20:16:43 <lambdabot> Ord a => [a] -> Maybe a
20:17:22 <fragamus> a is an infinite list
20:17:26 <fragamus> [a]
20:17:36 <fragamus> rather
20:17:52 <dsal> > let loopy xs = fmap fst . find (uncurry S.member) . zip xs $ scanl (flip S.insert) mempty xs  in   loopy $ cycle [1..100]
20:17:55 <lambdabot>  Just 1
20:18:05 <ephemient> infinite works just fine :)
20:18:51 <dsal> > let loopy xs = fmap fst . find (uncurry S.member) . zip xs $ scanl (flip S.insert) mempty xs  in   loopy $ iterate ((`mod` 1000) . succ) 3
20:18:52 <lambdabot>  Just 3
20:19:27 <fragamus> niiiice
20:19:35 <iqubic> What is this doing?
20:19:54 <fragamus> its looking for repeats in a list
20:20:11 <iqubic> > let loopy xs = fmap fst . find (uncurry S.member) . zip xs $ scanl (flip S.insert) mempty xs  in loopy $ iterate ((`mod` 1000) . succ) 100
20:20:13 <lambdabot>  Just 100
20:20:19 <iqubic> I see.
20:20:33 <dsal> > take 5 $ iterate ((`mod` 10) . succ) 3
20:20:33 <iqubic> I don't like this pointfree stuff.
20:20:37 <lambdabot>  [3,4,5,6,7]
20:20:44 <ephemient> it's not really pointfree?
20:20:51 <dsal> I was just using that as an example of an infinite function that cycles.  And that take was useless.  heh
20:20:53 <dsal> > take 25 $ iterate ((`mod` 10) . succ) 3
20:20:55 <lambdabot>  [3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7]
20:21:00 <fragamus> I liked Forth
20:21:30 <Axman6> you can implement a type safe forth in Haskell quite easily
20:21:41 <ephemient> :t liftM2 ((fmap fst . find (uncurry Smember)) .) zip (scanl (flip Sinsert) mempty)
20:21:43 <lambdabot> error:
20:21:43 <lambdabot>     ‚Ä¢ Data constructor not in scope: Smember :: b -> b0 -> Bool
20:21:43 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
20:21:53 <ephemient> blah, I can't type, but that would be pointfree
20:22:04 <fragamus> I think someone did make a functional language that was Forth like
20:22:08 <ephemient> or pointless :p
20:22:19 <moet> "free of points"
20:22:35 <dsal> All you need is fix  (altogether now)
20:25:18 <moet> ok, i'm starting to like cabal new-build/v2-build ..
20:25:42 <moet> if any of you contributors are here, i want to say thank you
20:28:56 <qualiaqq> Is there a difference between new and v2?
20:32:43 <moet> functionally, i don't think so .. "new-" is a mnemonic which i think will be removed once that mode is made the default .. "v2-" is a permanent prefix meant to be used in scripts ..?
20:34:38 <ephemient> IIRC the roadmap has build -> v1-build, v2-build -> build renames coming in the next major version bump
20:35:16 <ephemient> (though v2- is still supposed to keep working even when v1- goes away)
20:37:37 <qualiaqq> Ah makes sense.
20:39:13 <koz_> @unmtl StateT s Maybe a
20:39:13 <lambdabot> s -> Maybe (a, s)
20:39:22 <koz_> @unmtl MaybeT (State s) a
20:39:22 <lambdabot> s -> (Maybe a, s)
20:39:55 <koz_> Thanks @unmtl.
20:40:07 * koz_ gets an odd sense of dejavu about that.
21:13:38 <dibblego> mniip: yo
21:13:52 <dibblego> mniip: are you trying to read UTC zone files on archlinux? https://github.com/ygale/timezone-olson/issues/7
21:15:29 <dibblego> (and do you have any workarounds?)
22:23:28 <jusss``> where I can find the origin link about the mother of all monads?
22:23:44 <jusss``> that fp complete website is 404
22:26:39 <Axman6> jusss``: trhis one? http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
22:26:45 <Axman6> this*
22:27:53 <jusss``> Axman6: thanks
22:30:45 <CsT36> Anyone here
22:31:35 <koz_> CsT36: Lots of folks.
22:32:16 <jusss``> Axman6: this is a very good article about Cont 
22:32:30 <CsT36> Dushon and other or Spike sounds on phone ore device
22:32:31 <jusss``> I suddently know it a little
22:32:46 <CsT36> What is called
22:33:16 <CsT36> And other is there all in one
22:35:01 <CsT36> Hello
22:36:06 <Axman6> CsT36: is this a question about the programming language Haskell?
22:36:29 <CsT36> Deep web Haskell
22:36:44 <Axman6> I have no idea what that is
22:36:55 <CsT36> Street ratZz rapeing
22:37:15 <CsT36> Trojan virus 
22:37:33 <Axman6> you're definitely in the wrong place then
22:38:06 <CsT36> It's called justanotheruser
22:38:17 <CsT36> All in one
22:38:21 <CsT36> Beat
22:38:43 <CsT36> justanotheruser.mp3
22:39:06 <MarcelineVQ> bet
22:39:26 <CsT36> Aman come home
22:39:35 <MarcelineVQ> lawdy
22:39:37 <CsT36> Missing your ass
22:39:48 <MarcelineVQ> Do you have any questions about the Haskell programming language?
22:39:50 <koz_> Could someone please summon some mods?
22:39:56 --- mode: ChanServ set +o monochrom
22:39:57 <Axman6> @where ops
22:39:58 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
22:40:03 --- mode: monochrom set +b *!*@ool-4572d12d.dyn.optonline.net
22:40:03 --- kick: CsT36 was kicked by monochrom (CsT36)
22:40:09 <MarcelineVQ> :<
22:40:12 <Axman6> <3 monochrom
22:40:17 <koz_> Yup, confirmed.
22:40:29 --- mode: monochrom set -o monochrom
22:40:37 <cesc> much appreciated
22:40:39 <MarcelineVQ> ops list getting small
22:40:54 <koz_> The efficiency of functional programming at work.
22:41:11 <cesc> (:
22:45:50 <Axman6> that was a pretty fun way to out justanotheruser as a deep web trojan author
22:46:28 <MarcelineVQ> somehow, I always knew
22:47:07 <Zer000> onException from safe-exceptions re-throws the exception after running your handler right?
22:49:05 <jusss``> this article is wonderful!
22:49:31 <jusss``> the mother of all monads
22:51:31 <Zer000> jusss``, link to article?
22:51:44 <MarcelineVQ> Zer000: Looks like it to me
22:53:09 <jusss``> http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
22:53:16 <jusss``> https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/the-mother-of-all-monads
22:54:07 <iqubic> Why is "singleton :: a -> [a]" not in base?
22:54:11 <MarcelineVQ> Zer000: though it might eat the exception your handler could raise, if I'm following this code
22:54:26 <Axman6> iqubic: it's just pure
22:54:32 <Axman6> and return
22:54:38 <Axman6> and (:[])
22:54:39 <iqubic> It is? I suppose it is.
22:54:44 <Axman6> it doesn't need a fourth name
22:54:56 <MarcelineVQ> Zer000: if by handler you mean m b of  onException :: MonadMask m => m a -> m b -> m a
22:56:47 <Zer000> MarcelineVQ, ok thanks. I wasn't sure what's happening there 100%
23:03:52 <jackdk> I have an MPTC with two type parameters, and the relationship is truly many-to-many so I can't use fundeps. Are there any common idioms people use to make type inference easier in such cases?
23:39:15 <jackdk> Alternatively, is there a way to check if a data type is Typeable? something like `ifTypeable :: (Typeable a => b) -> b -> b`, where `ifTypeable t f = t` if there is a `Typeable` instance for `a`, but evaluates to `f` otherwise?
23:40:19 <jackdk> Those are the Ys of my X-Y problem, and this is the X: https://github.com/qfpl/semialign-extras/issues/3
23:40:33 <jle`> jackdk: no, there isn't really a way to check if a type is an instance that doesn't break the entire type system
23:40:41 <jle`> jackdk: that's because instances may be introduced later down the line in other modules
23:41:27 <jackdk> "breaking the entire type system" is not a cost I'm really willing to pay
23:56:47 <mniip> dibblego, right now it's only an issue in development. One workaround is to downgrate tzdata. It looks like ygale has fixed it in HEAD but I haven't tested it. Currently we use https://github.com/mniip/timezone-olson/commit/e8372bf5d54eb8bf207374c58a85173bb13b1b50 in production
23:57:04 <dibblego> ah ok, cheers mate
23:58:04 <mniip> ah yes the fix in HEAD seems to be the same modulo formatting
23:58:39 <mniip> I should retract my PR then. Confront about making a new hackage release perhaps?
23:58:54 <dibblego> ya
23:59:05 <dibblego> and then xmobar as well
