00:01:48 <MarcelineVQ> idk about with ctrl+c but you can use the threadid forkIO gives you and use killThread on it
00:02:35 <kaol> I'm hoping to avoid that.
00:04:01 <kaol> I would need quite a few changes to my code just to facilitate that. Right now, it's easier to quit ghci between test runs.
00:04:18 <c_wraith> oh.  ghci overrides the SIGINT handler
00:04:27 <c_wraith> you can...  re-override it.
00:04:30 <c_wraith> But that's ugly
00:04:36 <c_wraith> and you'd better restore it before returning
00:06:42 <kaol> I think I'll file a bug on GHC. This is inconvenient, perhaps they'd have a better idea.
00:07:31 <MarcelineVQ> bracket  (forkIO (forever $ threadDelay 1000000 >> putStr "a")) killThread  (const $ forever $ threadDelay 1000000 >> putStr "b")   :>
00:11:03 <kaol> That's workable. Though I wouldn't want to put that in my production code since it doesn't need it.
00:11:49 <MarcelineVQ> should your production code be relying on the behavior of ctrl+c in ghci :X
00:12:05 <MarcelineVQ> Oh I get it hehe, nvm
00:12:20 <kaol> That's a stand alone binary, killing it kills anything forkIO did.
02:08:05 <berndl> Hello #haskell. I was wondering if anyone can help me with the following code: https://hastebin.com/woyoneseki.cpp
02:21:21 <[Leary]> berndl: taking polymorphic arguments is what RankNTypes is for; rather than taking an `(f a -> a)`, you want to take a `(forall x. f x -> x)`.
02:22:23 <lavalike> say you have multiple binaries in the same cabal package, how do you use cabal test to run just tests regarding one specific binary? is it up to you to figure out a program that will accept a parameter or is there something cabal can do with its targets?
02:23:19 <berndl> [Leary]: Right. I was trying to reimplement this guy (https://hackage.haskell.org/package/free-5.1.3/docs/src/Control.Monad.Free.html#iter), which just be doable if my final encoding of free and the normal one are isomorphic.
02:23:32 <berndl> s/just/should/
02:25:41 <berndl> [Leary]: Maybe the final encoding is not isomorphic to the normal one?
02:34:28 <jpcooper> How can I define a `class C (t :: v) with an associated `type X t :: v` and a function `f :: t -> X t` without ghc complaining that it expected a type at the `X t` position of the function, but it instead got something of kind `v`? Is there any way to enforce that `v` is a kind of types?
02:36:28 <jpcooper> When `type X t` is defined as a type family outside of `class C`, the code compiles, but I need that type inside the class
02:37:15 <berndl> X t has to be a type in order to define f :: t -> X t.
02:37:38 <jpcooper> It will be for all instances of that class
02:37:55 <jpcooper> `v` will be a DataKind
02:38:23 <jpcooper> TypeInType and DataKinds are subsets of Type
02:38:43 <berndl> jpcooper: Maybe you need to add the C t constraint to f?
02:39:04 <jpcooper> `f` is a function of the class
02:39:52 <berndl> Ah, OK.
02:45:32 <mheinzel> jpcooper: Is there a reason why you can't say `type X t :: Type` instead?
02:46:28 <jpcooper> I want to ensure that `X t` is the same kind as `t`
02:47:08 <jpcooper> Of course, this can be left to the instances
02:48:36 <mheinzel> But if the function returns `X t`, it has to be a `Type`. Not sure what you mean by `TypeInType and DataKinds are subsets of Type`.
02:49:11 <jpcooper> A type can still be part of a DataKind
02:49:52 <jpcooper> Let K be a DataKind. X t :: K :: *
02:52:19 <mheinzel> But you know for all instances that `X t :: Type`?
02:52:41 <jpcooper> That is also true
02:52:55 <jpcooper> I just wanted to enforce it in the class definition
02:56:42 <mheinzel> To make sure there is not misunderstanding, what do you mean by `X t :: K :: *`?
02:56:47 <mheinzel> "`X t` is a `K` and `K` is a Type"
02:57:05 <mheinzel> or "`X t` is a `K` and also a type"
02:57:50 <jpcooper> Are those two claims not the same?
02:58:38 <jpcooper> No
02:58:41 <mheinzel> I don't think so.
02:58:47 <jpcooper> I mean the first one
02:58:55 <jpcooper> But doesn't the first also imply the second?
03:00:16 <mheinzel> No.
03:01:01 <mheinzel> If you have `data Foo = A | B`, then `A :: Foo` and `Foo :: Type`, but not `A :: Type`.
03:01:14 <jpcooper> If we have DataKinds, does the first not imply the second if K is a DataKind?
03:03:30 <mheinzel> What you get through DataKinds is that `A :: Foo` (where A is a value and Foo a Type) gets lifted by one level to `'A :: Foo`, where A can appear on the type level and has kind Foo, but it is not `A :: Type`.
03:05:40 <jpcooper> Is it wrong that if we have DataKinds and `data C = D | E`, then `C` is lifted to a kind, and each constructor `D` and `E` are lifted to types. Then both: `D :: C` and `D :: Type`
03:06:15 <jpcooper> Well, `'D :: C` and `'D :: Type` (with the apostrophe)
03:06:30 <mheinzel> `'D :: Type` is not true.
03:07:04 <jpcooper> Okay. Then are all kinds disjoint?
03:07:10 <mheinzel> You could informally say that D is a type now, since DataKinds allows you to use it on the type level, e.g. `X D`, but it still has a different kind.
03:07:27 <jle`> jpcooper: 'all kinds are disjoint' in the same way all types are disjoint
03:07:33 <mheinzel> Yes, they are not sets.
03:07:42 <jpcooper> I understand. I thought that TypeInType allowed `D :: C` and `D :: Type`
03:08:20 <jle`> ah, no. the story with kinds just because more or less the story with types
03:08:34 <jle`> so True :: Bool, and nothing else
03:08:38 <jle`> just like 'D :: C, and nothing else
03:08:51 <jpcooper> Thanks mheinzel and jle` for clarifying
03:09:31 <jle`> jpcooper: Type isn't really any more special of a kind than C and Bool, etc.
03:09:52 <jle`> in terms of like the rules at the type level
03:10:09 <jle`> the only thing that makes Type unique is that it is the 'link' between the term level and the type level
03:10:47 <jle`> er, the link between the type level and the kind level
03:10:56 <jpcooper> Could you clarify that?
03:11:27 <jle`> yeah, you can imagine having kinds like Bool, C, MyKind, Type, etc., and they're all more or less equal in terms of how the rules work between them
03:11:38 <jle`> Type is just sort of a "built-in" kind
03:12:06 <jle`> because all terms have types, and those types all have the same kind.  we have to give that kind a name, so we call it Type
03:12:47 <jle`> so just the fact that we have typed terms means that the types of terms must have the same kind
03:13:07 <jle`> so this unique "same kind" just exists on its own spontaneously, arising from the fact that terms exist
03:13:20 <jle`> so it's a 'built-in' of the type system, so to speak
03:13:36 <jpcooper> And we also have terms being the single inhabitants of the "things" of a given datakind
03:13:48 <jle`> but if we did not have terms in haskell, then presumably Type wouldn't exist, and if it did, it wouldn't be unique from any other kind
03:14:07 <jle`> jpcooper: we don't have terms inhabiting lifted kinds, but we have types inhabiting lifted kinds
03:14:17 <jle`> for example we have the type 'D of kind C
03:14:32 <aplainzetakind> If f is a list that is produced by successive (:)'s, would last f lazily grab the first thing that comes out?
03:14:41 <jpcooper> Okay. Makes sense
03:14:46 <jpcooper> Thanks a lot
03:15:03 <jle`> jpcooper: but yeah, all data kinds-lifted types have a kind, and all those kinds have the same 'sort'
03:15:25 <jle`> but in haskell we squash that hierarchy
03:15:31 <jle`> if -XTypeInType  is on
03:15:52 <jpcooper> aplainzetakind: It depends on how f is defined. To obtain the first element of the result of (++), all the (:) constructors must be evaluated
03:15:53 <jle`> aplainzetakind: i'm not sure what you mean, but last usually gets the first thing
03:15:59 <jle`> *gets the last thing
03:16:09 <jle`> 'last' looks for the nil/[] before returning anything
03:16:20 <jle`> > last (undefined:undefined:undefined:7:[])
03:16:24 <lambdabot>  7
03:16:42 <jpcooper> jle`: What is the one thing that TypeInType allows that wasn't before? Kinds appearing in type positions of constructors?
03:17:29 <jle`> jpcooper: i think it is kinds appearing in the same places syntactically as types essentially
03:17:34 <jle`> but there are still some restrictions in ordering
03:17:37 <aplainzetakind> jle`: Specific concern: Transfering AoC intcode computers outputs from one to the other.
03:17:46 <jpcooper> Okay
03:18:15 <aplainzetakind> Since by specification they may keep spitting outputs and not even terminate.
03:18:30 <aplainzetakind> And I just want to get the first one that comes out.
03:18:46 <jle`> aplainzetakind: if you want to get the first one, use head
03:19:19 <aplainzetakind> No the first one that is produced, the ones produced will keep getting cons'd to the output list.
03:19:40 <aplainzetakind> I want a lazy fifo thing basically.
03:20:23 <jle`> lists are no fifo, they're filo :o
03:20:40 <aplainzetakind> I know, that's my sticking point. What should I use?
03:20:51 <aplainzetakind> Seq.viewl/r are strict I suppose.
03:22:08 <jle`> Seq is a good queue type yeah
03:22:12 <jle`> but it's strict on spline
03:22:27 <jle`> but the typical way to do this knot-tying is to restructure it so your head is the item that you want
03:23:49 <jpcooper> Is there a functional, non-template-haskell version of this "select (2)" idea?
03:24:13 <jpcooper> Over an arbitrary number of input lists
03:24:54 <aplainzetakind> That brings me back to the initial concern with last replaced by head. head probably can't be lazy without knowing how its agument is produced?
03:25:16 <jpcooper> Could you not just recurse over the tuple of lists?
03:25:35 <aplainzetakind> Tuple? Each list being what?
03:27:09 <jpcooper> Are you trying to choose a tuple of elements from a tuple of lists, or are you trying to choose the first available element from a tuple of lists?
03:27:57 <kuribas> lazy IO is perfectly fine if you consume what you produce right away, right?  For example read from a file, then save it in the database.
03:28:15 <phadej> yes, and no
03:28:18 <aplainzetakind> I'll have a function which produces a potentially infinite stream of numbers, and I want to grab the first one without waiting for the rest (but not necessarily losing them).
03:28:38 <jle`> kuribas: the more important thing is that you throw away right away
03:28:50 <aplainzetakind> OK ignore the last parenthesized thing, it's pretty vague.
03:28:59 <kuribas> jle`: yes indeed
03:29:13 <jpcooper> aplainzetakind: Do you have an ordered list of lists? 
03:29:18 <jle`> kuribas: er, i suppose both are important
03:29:21 <kuribas> jle`: though if the thing you produced is fully evaluated, you don't need to
03:29:55 <jle`> kuribas: hm, i think if you hold on to items you pull out, then even the produced thing being fully evaluated wouldn't help
03:30:23 <jle`> for example x <- readFile; evaluate (sum (take 10 x); ...
03:30:33 <aplainzetakind> jpcooper: Hmm, on closer consideration my specification would also require being able to call last on an infinite list. So that's impossible.
03:30:39 <jle`> you're still holding on to x even though the thing you produce (sum (take 10 x)) is evaluated
03:31:04 <jpcooper> aplainzetakind: Okay
03:31:27 <jle`> ignore the fact that i am summing char's :)
03:31:59 <jle`> kuribas: if you evaluate the thing you want out of x, but still hold on to the reference for usage later, then you can leak a handle
03:32:26 <aplainzetakind> The only way out I can think of is using Chan's and writing functions in IO.
03:32:38 <kuribas> jle`: in that case you could use withFIle
03:32:49 <jle`> kuribas: also in that case you will have the whole file in memory
03:32:55 <jle`> if you use the x more than once
03:33:15 <jle`> so it makes lazy IO 'fine' in the sense that it won't explode, but un-fine in the sense that it isn't what you want
03:33:18 <jpcooper> aplainzetakind: Why do you need to call last? Why not just keep iterating over the infinite list of lists, and take the first element that is present?
03:33:28 <jpcooper> Or do you care about fairness?
03:33:28 <kuribas> jle`: no, withFile returns a handle
03:33:42 <kuribas> jle`: or rather, takes a callback that takes a handle
03:33:55 <lavalike> haddock doesn't generate docs for executables? I'm missing something
03:34:23 <kuribas> lazy IO also puts more stress on the garbage collector.  
03:34:26 <jle`> kuribas: it's the reference to x that drives the IO and the handle closing
03:34:43 <aplainzetakind> jpcooper: I'm not sure what you mean. I have one list/stream/sequence of numbers I want to model.
03:35:16 <jle`> kuribas: er, sorry, withFile will close the handle
03:35:17 <kuribas> jle`: if you deepseq the thing your return, or have it already evaluated (by writing to another file for example), it doesn't matter if the handle gets closed.
03:35:22 <kuribas> jle`: yeah :)
03:35:43 <jle`> i suppose if you deepseq *all* the things that you want to ever use
03:36:02 <jle`> but still, it could get the whole file into memory, which might not be 'fine' depending on your situation
03:36:12 <kuribas> jle`: why?
03:36:15 <jle`> you just at least won't get I/O errors from closed handlers if you don't evaluate right away
03:36:24 <jle`> *if you evaluate right away
03:36:35 <jle`> kuribas: why would you get the whole file into memory, or why would it not be fine?
03:36:54 <kuribas> jle`: it would only happen if you have a space leak somewhere
03:37:05 <jle`> consider:
03:37:10 <jle`> x <- readFile blah
03:37:11 <aplainzetakind> OK since it's possible to call head on [1..] this should be doable, I just need to set up the recursion of how the numbers are produced in the right direction.
03:37:21 <jle`> y <- evaluate $ hash1 x
03:37:23 <jle`> z <- evaluate $ hash2 x
03:37:51 <jle`> even if hash1 and hash2 were lazy and streaming, this would pull all of blah into memory
03:38:45 <jle`> so in the sense of "using lazy IO as if you had strict IO", then yeah, consuming/evaluating the items right away should be ok
03:39:03 <jle`> but in the sense of "using lazy IO for the purpose it is lazy for in the first place", the consuming/evaluating right away won't help
03:39:49 <jle`> but i would argue that if you just want to be able to use lazy IO as if it were strict IO, you might as well just use strict IO and not worry about it at all
03:39:58 <dansho> is it usual that training a model with backprop takes longer and uses more CPU with -threaded and rtsopts=-N?
03:40:00 <jle`> hm, or a cleaner example maybe
03:40:03 <jle`> x <- readFile blah
03:40:06 <jle`> writeFile blah x
03:40:14 <jle`> *writeFile blah2 x
03:40:17 <jle`> writefile blah2 y
03:40:27 <jle`> wow i botched that up completely didn't i
03:40:34 <kuribas> jle`: I get your point
03:40:41 <kuribas> lazy IO requires more care
03:40:42 <jle`> do x <- readFile "file1"; writeFile "file2" x; writeFile "file3" x
03:40:54 <jle`> that will pull all of "file1" into memory
03:41:07 <lavalike> anybody knows how to get the haddock of a Main module?
03:41:12 <jle`> so lazy IO would not be 'fine' in that situation, if your goal is to be smart with memory usage by utilizing lazy IO
03:41:38 <jle`> dansho: hm, backprop the library is single threaded, so maybe there's some overhead introduced?
03:43:25 <kuribas> jle`: more like witFile "myFile" $ \h -> writeResult =<< (process <$> hGetContents h)
03:43:54 <kuribas> jle`: assuming process doesn't hold on the beginning of the list
03:44:17 <jle`> kuribas: yeah, that's because you never hold on to the name of the result
03:44:22 <dansho> jle`: ah, sounds like threaded wouldn't help then
03:44:52 <aplainzetakind> Instead of producing [n1,n2..], I will produce out = [(n1 :), (n2 :)..], and when the program halts the output will be output = foldl (.) id out $ []. Can I then call head on output lazily?
03:45:30 <kuribas> jle`: it seems the readFile function is worse than hGetContents.
03:45:56 <kuribas> jle`: as it holds on to the handle indefinitely (depending on the garbage collector).
03:46:13 <jle`> yeah, there are a lot of things to think about heh
03:46:48 <jle`> in the simplest of simple cases it should do what you want, but everything else takes a bit of mental gymnastics to figure out
03:47:00 <kuribas> indeed
03:47:13 <kuribas> anyway, gtg
03:48:52 * hackage cache 0.1.2.0 - An in-memory key/value store with expiration support  https://hackage.haskell.org/package/cache-0.1.2.0 (hverr)
03:51:15 <dansho> jle`: when i profiled the profiler pointed me to my loss function, i guess that makes sense since that's where the final gradient is computed, i think: https://hastebin.com/uloroyukof.hs
03:51:54 <dansho> about 70% of the time according to the profiler
04:03:21 * hackage termonad 3.0.0.0 - Terminal emulator configurable in Haskell  https://hackage.haskell.org/package/termonad-3.0.0.0 (cdepillabout)
04:03:26 <dansho> does anyone know why 'unId' (a newtype constructor) has so many "entries" (second numeric column)? https://hastebin.com/okehifomet.prof
04:04:31 <dansho> i kind of thought newtypes would be gone at runtime, but maybe entries doesn't mean it was actually called that many times, the other numbers all show 0.0 for time
04:15:57 <[Leary]> @tell berndl If you take a polymorphic extraction function, `iter` can be written for both versions of `Free f` /without imposing any constraints on `f`/. I might be missing something, but this looks like the way it should be. Otherwise, you can still write `iter` for your version of `Free f`, but you incur a `Monad f` constraint. Try writing `run :: Monad f => Free f a -> f a` first.
04:15:58 <lambdabot> Consider it noted.
04:16:46 <Franciman> Hi
04:16:49 <Franciman> I'm trying to use ghcup
04:16:52 <Franciman> on trisquel
04:17:10 <Franciman> the issue is that it wants to install ghc, but can't find libtinfo.so.6
04:17:20 <Franciman> I installed it, but the name of the so is libtinfo.so
04:35:10 <gentauro> hmmm I just realized that both `<$>` and `<*>` read from right to left, while `>>=` reads from left to right. Shouldn't `=<<` be the used one? (just for consistency)?
04:39:43 <ziman> i usually prefer =<<, indeed
04:39:50 <ziman> works well with (.), too
04:40:24 <ziman> (or >>= with & in some cases)
04:40:40 <ziman> but i'm not sure precedence works right there
04:48:59 <aplainzetakind> I'm tangled up in the use of s in ST s: https://gitlab.com/aplainzetakind/aoc2019/blob/master/days/Advent19/Day07.hs
04:49:46 <aplainzetakind> line 169, runProgram: I can't compose this with runST to actually get the value, because the s in Array' s interferes somehow.
04:50:32 <aplainzetakind> I probably need some explicit forall somewhere but I'm not sure how these all fit together (first time using ST).
04:53:14 <nil> you probably want runProgram to get a pure array or list instead
04:55:59 <aplainzetakind> Then turn it into Array' s somewhere?
04:56:42 <aplainzetakind> OK I think I understand.
05:04:03 <aplainzetakind> Actually no, I'm at a loss as to how I should put an Array' s in the environment of ReaderT (or StateT), as ST is innermost.
05:25:46 <maralorn> gentauro: ziman: There was a time when the permanent switch of flow direction drove me crazy. Now I mostly decided to ignore it. I mean the fundamental problem is actually the we write function application from right to left (and doing that differently would be confusing as heck). But in a multiline program we would actually want the flow to go from top left to bottom right (or something like
05:25:48 <maralorn> that).
05:27:05 <nil> aplainzetakind: runProgram l i = do a <- newArray ..l..; ... `runReaderT` (a, i) ...
06:02:54 <aplainzetakind> nil: That works, thanks.
06:05:22 <aplainzetakind> Ah no that got me out of some other type error, but it still complains when I try runST.
06:07:16 <merijn> aplainzetakind: are you composing things with the runST? (i.e. with (.))
06:10:19 <aplainzetakind> I enabled RankNTypes and changed the output from (ST s ...) to (forall s. ST s ...) and now it works.
06:15:54 <aplainzetakind> I'm perplexed. runProgram l n = runST $ program l n
06:15:58 <aplainzetakind> works.
06:16:07 <merijn> aplainzetakind: And if you use . it doesn't? ;)
06:16:48 <merijn> aplainzetakind: It's because GHC is screwing with you :)
06:17:04 <aplainzetakind> ..with type [Int] -> Int -> ([Int], ProgState)
06:17:06 <merijn> aplainzetakind: The one with $ is *also* not supposed to work
06:17:07 <aplainzetakind> Yes.
06:17:26 <merijn> aplainzetakind: But the GHC type checker has a specific hack to detect a combination of runST and ($) to make it work
06:17:38 <aplainzetakind> I put fst . before the right hand side and it fails with quantification errors.
06:17:53 <merijn> aplainzetakind: Basically, RankN types cannot be inferred, so mixing ($) or (.) with a function like runST breaks
06:18:06 <merijn> aplainzetakind: Because it's unable to properly infer the 2nd argument of (.) (or ($))
06:18:32 <merijn> aplainzetakind: But as I mentioned, GHC's type checker actually has a hack inside it to specifically fix the $ case to make it work, because it's so common
06:20:43 <aplainzetakind> Hmm.
06:20:55 <aplainzetakind> I need to better understand the type system apparently.
06:30:35 <merijn> aplainzetakind: This is a really obscure corner case, though :)
06:30:59 <tom__> I am getting this error when running a directory migration with postgresql-simple-migration 
06:31:00 <tom__> Migrate.hs: SqlError {sqlState = "42P01", sqlExecStatus = FatalError, sqlErrorMsg = "relation \"schema_migrations\" does not exist", sqlErrorDetail = "", sqlErrorHint = ""}
06:31:33 <Arkeln> Hey there, so small question, I was wondering is there a slightly better abstraction than always doing something like a >>= (\ b -> pure ... b) ? I just see it happen so often in my code I figure there has to be a better way to do that than always declaring lambdas like that 
06:31:48 <merijn> Arkeln: Eh, fmap? :p
06:32:11 <merijn> Arkeln: "a >>= pure . f" == "fmap f a"
06:32:24 <Arkeln> let me give it a whirl
06:32:39 <merijn> Arkeln: Or, sometimes nicer "f <$> a"
06:40:45 <Arkeln> I got it, I was being very dumb for a moment and not realizing that pure was no longer required. That helped a lot, thanks merijn
06:40:55 <merijn> Arkeln: np :)
06:45:43 <lavalike> at a fundamental level how does let a' = map f a:c'; b' = map f a'; c' = map f b' in [a',b',c'] work? I thought intuitively it should and it does but now I fail to see how
06:46:14 <lavalike> meant map f (a:c')
06:46:21 <lavalike> it's just lazyness isn'ti t
06:46:26 <merijn> lavalike: Yes
06:47:00 <merijn> lavalike: Essentially you're creating a reference/pointer (named a') that points to "where the result of "map f (a:c')" will be"
06:47:13 <merijn> lavalike: the same for the other two
06:47:18 <lavalike> ok good enough
06:47:29 <lavalike> it doesn't happen often to me to write explicitly recursive bindings like that
06:47:44 <merijn> lavalike: And they all get evaluated to WHNF bit by bit as needed
06:48:05 <merijn> lavalike: So as long as you're not too strict (i.e. the next value in a' requires itself to compute) it all just works
06:48:14 <lavalike> > let odds = map (+1) evens; evens = 0 : map (+1) odds; in zip evens odds
06:48:16 <lambdabot>  [(0,1),(2,3),(4,5),(6,7),(8,9),(10,11),(12,13),(14,15),(16,17),(18,19),(20,2...
06:48:22 <lavalike> it's the same as this I guess
06:48:37 <merijn> yeah
06:48:40 <lavalike> alrighty then
06:49:08 <lavalike> > let odds = map (+1) evens; evens = map (+1) $ (-1) : odds; in take 10 $ zip evens odds
06:49:10 <lambdabot>  [(0,1),(2,3),(4,5),(6,7),(8,9),(10,11),(12,13),(14,15),(16,17),(18,19)]
06:49:11 <lavalike> this is the reason it looked odd to me
06:49:26 <lavalike> didn't look like something was always produced before mapping
06:50:33 <Arkeln> So, one more question that's been on my mind a few hours now, what's an idiomatic way to generate a list until a condition is true? Specifically, based on previous values. Sort of like takeWhile except more... like produceWhile, you know? or applyWhile. I've seen scanl/scanl1 but I think there is probably a better way to do it 
06:51:08 <Arkeln> I could write a recursive function for it also, but I feel like there is definitely a better way to do it
06:54:05 <lavalike> :t ((. iterate) . (.)) . (dropWhile . (not .))
06:54:07 <lambdabot> (a -> Bool) -> (a -> a) -> a -> [a]
06:54:18 <lavalike> *takeWhile
06:54:42 <jacks2> > takeWhile (< 10) $ map (*2) [1..]
06:54:45 <lambdabot>  [2,4,6,8]
06:55:47 <lavalike> > let produceUntil = ((. iterate) . (.)) . (takeWhile . (not .)) in produceUntil (>(2^10)) (2*) 1 
06:55:49 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024]
06:56:08 <lavalike> sorry for the pointless nonsense
06:56:28 <Arkeln> iterate is definitely what I am looking for 
06:56:35 <Arkeln> thanks very much :) 
06:56:54 <lavalike> (:
07:01:23 <infinity0> ghc isn't able to infer the quantified constraint (forall t. SingI (f t)) in the general case so I've had to define my own typeclass which is like a promoted version of SingI, class SingF (f :: k -> *) where singF :: f t -> Sing t, where the instance definition is usually just singF (pattern-match) = sing
07:01:32 <infinity0> i was wondering if this already existed in the singletons library
07:18:25 <Franciman> how can I ask ghcup to download ghc for a specific distro?
07:18:31 <Franciman> different from the one I am running upon
07:30:08 <yasar> In the first example, what is the reason for "let as = ["<a>", "b"] in" ? I am confused because it doesn't look like it is used in any way. https://www.stackage.org/haddock/nightly-2019-12-07/heterocephalus-1.0.5.3/Text-Heterocephalus.html
07:30:24 <yasar> I am very new to haskell syntax, so I am probably misreading it
07:31:37 <lavalike> Franciman: there is no such concept
07:32:50 <lavalike> yasar: there's no reason for it to be there for the code in the in .. expression, it's just there to make the examples similar
07:32:51 <geekosaur> yasar, there's a quasiquote and a Template Haskell splice involved, so things are happening behind the scenes. The quoted "as" probably tells a Template Haskell quasiquote handler to look at `as`.
07:33:09 <lavalike> glad we agree xD
07:33:31 <lavalike> the binding is outside the quasiquote tho
07:34:02 <geekosaur> but inside the TH splice. my point there was that the $( ... ) and the [| ... |] are a warning that Strange Things may happen
07:34:14 <lavalike> what's the delimited by?
07:36:07 <geekosaur> now, I'm unfamiliar with the package so don't know what exactly is going on there, but the `"as"` is suspicious and makes me think `compileTextFileWith` uses it to access the binding
07:36:30 <geekosaur> sorry, setDefault is using "as"
07:37:47 <geekosaur> the earlier one indeed seems to be just to make them look similar (I didn't even notice the `let` in that one at first, sorry).
07:39:08 <geekosaur> hm, actually I suspect there's some kind of template expansion for `as` in the sample text file; I'd have to dig.
07:39:48 <yasar> https://github.com/arowM/heterocephalus/blob/master/templates/sample.txt
07:39:50 <geekosaur> yeh, all the examples have that key: ... stuff in them
07:40:22 <geekosaur> right, that seems to explain `as`
07:40:27 <yasar> I am confused how the .txt file and haskell variables are related :)
07:40:30 <geekosaur> and it's the point of the package
07:40:39 <geekosaur> that's what Template Haskell is doing
07:41:21 <geekosaur> a sequence `$( ... )` is run while compiling the Haskell program. in this case it opens the text file and looks for code in `%{ ... }` blocks
07:41:58 <geekosaur> and expands any variables it finds in it, so it uses the `as` in the `%{ forall a <- as }`.
07:42:15 <geekosaur> TH is generally confusing that way
07:43:31 <yasar> Can any of you suggest a template engine for a beginner? I want to create a latex file template and fill it with values using haskell.
07:44:06 <geekosaur> a TH splice runs Haskell code at compile time, which outputs what amounts to Haskell code (in internal format) that gets compiled in place of the splice
07:44:30 <geekosaur> that code can be an expression, or a declaration depending on where the splice is. it's fairly powerful but also confusing
07:44:53 <geekosaur> sorry, I can't; I don't generally work in that area
07:45:13 <yasar> So, is it the Haskell way of doing templating? Like a de facto standard?
07:45:25 <geekosaur> I don't think there's a standard as such
07:45:37 <lavalike> I have some experience working with this and it has been good to me https://github.com/unclechu/haskell-qm-interpolated-string
07:45:45 <lavalike> your mileage may vary
07:45:47 <[Leary]> yasar: Do you really need an "engine"? I would suggest just writing functions that produce String or Text values, and combining them however you please.
07:45:52 <Franciman> ok, thanks lavalike 
07:46:29 <geekosaur> there are a bunch of templating ebngines, many of which use TH or quasiquotes because it can expand stuff at compile time and the resulting program is faster. and it's often more convenient, if brain-bending
07:46:54 <Franciman> my issue is that I run trisquel linux
07:47:10 <Franciman> and ghcup doesn't recognize it. It should use debian builds
07:48:01 <lavalike> Franciman: you could hack it in the script itself and see if it works!
07:48:13 <Franciman> it works
07:48:19 <Franciman> but now if I want to update ghcup
07:48:22 <Franciman> I need to repeat the hack
07:48:34 <lavalike> you could send it upstream and see if they merge it
07:48:41 <Franciman> good idea, thanks
07:57:41 <yasar> So, does Template Haskell require templates to be built into exe file?
07:58:37 <heatsink> templates run at compile time
07:58:38 <yasar> Because my templates will be given as an argument to the program
07:59:21 <heatsink> What are you using templates for?
07:59:52 <c_wraith> making that work would require digging through the GHC api and using it to compile them.  Not impossible, but probably not what you want
08:00:57 <yasar> I will give the path to a latex template and a csv file, it will create a page for each line of the csv file using the latex template
08:01:12 <c_wraith> oh.  that's fine.  that's also not what template haskell is for
08:01:27 <c_wraith> template haskell is for generating *haskell* code programmatically
08:02:12 <yasar> Do you know any good library to do what I need?
08:03:06 <c_wraith> Generating latex?  I don't know of anything specialized for that.  But you could use just about any string-templating system that's not designed for a single purpose
08:04:23 <c_wraith> There's this section of hackage:  https://hackage.haskell.org/packages/#cat:Template
08:04:38 <Rembane> yasar: I use Dhall to do that 
08:04:41 <c_wraith> I have not used any of them
08:05:44 <Gurkenglas> Why isn't there MonadState s (ST s)?
08:09:03 <yasar> There is an (.=) operator in here: http://brendanhay.nz/ede/Text-EDE.html#syntax
08:09:11 <yasar> Searhing hoogle give multiple results
08:09:38 <c_wraith> it's the aeson version of the operator
08:10:00 <c_wraith> You can tell because it talks about Aeson several times in the docs
08:10:30 <gentauro> maralorn: That's one of the reason that I like F# and their pipe operator (page 16) -> http://blog.stermon.com/assets/talks/2017-11-06_OEredevDeveloperConference.pdf
08:10:38 <c_wraith> Gurkenglas: that wouldn't work at all.  that s is never instantiated to a concrete type
08:10:47 <gentauro> maralorn: but what I like more, is consistency
08:10:59 <solonarv> Gurkenglas: if anything it would be `MonadState (State# s) (ST s)`
08:11:01 <gentauro> and Haskell lack a bit of that :)
08:11:19 <solonarv> the reason that instance doesn't exist is because there is only one sort of thing you could use it for: breaking everything horribly
08:12:22 <c_wraith> Gurkenglas: anyway, despite the similar names, ST and State have basically entirely different purposes.  It turns out ST is bad for the things State is good at, and vice versa.
08:12:45 <solonarv> much like it's probably a bad idea to work directly with the `State# RealWorld -> (# State# RealWorld, a #)` representation of IO, it is probably a bad idea to work directly with the `State# s -> (# State# s, a #)` representation of ST
08:13:43 <e1fa> can someone tell me the recommended way to split long lines up into multiple lines?
08:14:14 <e1fa> like if i have a line like this:
08:14:15 <e1fa>  let input = M.fromList $ zip [0..] $ Prelude.map (read :: String -> Int) $ words [if x == ',' then ' ' else x | x <- contents]
08:14:27 <e1fa> but it's more than 80 characters
08:14:42 <c_wraith> use some named subexpressions in a let or where binding
08:16:28 <e1fa> can i use where bindings inside of where bindings?
08:16:40 <c_wraith> you can
08:17:09 <c_wraith> you can attach a where clause to any equation or branch of a case expression
08:17:30 <e1fa> cool
08:17:43 <c_wraith> (where, for some reason, guards are not considered to form separate equations)
08:23:22 <yasar> if I do (if/then/else) within a _do block_, do I need another _do block_ for body of the conditions?
08:28:12 <Cale> yasar: yes
08:28:20 <Cale> (provided you're combining multiple actions)
08:53:22 * hackage tptp 0.1.1.0 - A parser and a pretty printer for the TPTP language  https://hackage.haskell.org/package/tptp-0.1.1.0 (EK)
08:59:14 <nil> any idea how i might make this work? https://gist.github.com/niiiil/1c929778b2ca05f956e69efeb803c29e
08:59:28 <nil> i get "ambiguous type" errors unless i add a :: Parser String annotation on "foo"
08:59:56 <nil> but this works fine with Megaparsec, i'm not sure what it does differently
09:03:59 <Cale> nil: You might try  instance (t ~ String) => IsString (Parser t) where ...
09:04:24 <Cale> nil: This will cause the instance to match immediately, but then insist that t is equal to String
09:05:28 <nil> Cale: i see, thanks
09:06:34 <ian_1363> Hello
09:07:13 <Cale> ian_1363: hi!
09:10:32 <nil> Cale: why does such an equality constraint require either GADTs or TypeFamilies?
09:11:19 <Cale> Equality constraints didn't exist in Haskell 98/2010
09:11:38 <Cale> and both of those extensions require type equalities to work
09:11:56 <geekosaur> there's no separate extension just for equality constraints, in other words, so any extension that brings them in will work
09:12:30 <nil> ok
09:12:45 <nil> i guess there should be
09:12:59 <geekosaur> I suggested it a few years ago but there didn't seem to be much interest
09:13:21 <geekosaur> that said, if someone gives them a patch they might take it
09:59:01 <militia> if I want my type to take a list of anything, can I not do the below:
09:59:04 <militia> printResults :: String -> [a] -> IO ()
09:59:44 <militia> if I don't specify the the type I think it's inferring it's [DataTypeA] when actually it could be [DataTypeA] or [DataTypeB]
10:01:21 <geekosaur> that sounds wrong; it should either take a list of anything or complain that you broke the contract by requiring a specific type in the implementation, not infer a type
10:01:39 <militia> yeah I get:
10:01:40 <militia>     • Couldn't match expected type ‘TotalCount’ with actual type ‘a’
10:01:40 <militia>       ‘a’ is a rigid type variable bound by
10:02:06 <geekosaur> then you need to verify that you didn't actually require a TotalCount somewhere
10:02:10 <militia> perhaps i'm saying it should be TotalCount somewhere, but I can't see where i'd be doing that
10:02:20 <militia> i'll have another look
10:02:40 <geekosaur> note that you can't test the type and do something different based on it; if you said `a` meaning any type, you must accept any type there
10:03:22 * hackage hoogle 5.0.17.13 - Haskell API Search  https://hackage.haskell.org/package/hoogle-5.0.17.13 (NeilMitchell)
10:05:45 <c_wraith> militia: that type looks sketchy anyway.  Are you sure you didn't want a (Show a) constraint or something?  Basically all you can do with an argument of type [a] in that signature is get its length.
10:10:40 <giuliohome> hi all, may I ask a question about haskell, stack and aoc2019?
10:11:07 <geekosaur> based on what little I've seen, it might be Integral a — but there's an awful lot missing here, and I'd be wary of using a numeric typeclass
10:11:13 <geekosaur> one may always ask
10:12:50 <Cale> giuliohome: Sounds good -- generally you shouldn't need to ask to ask here, so long as it's related to Haskell.
10:15:19 <giuliohome> @cale I shouldn't ask here for haskell? ... anyway my question was that I have stack don't know ho to build/run this repo https://github.com/glguy/advent2019
10:15:20 <lambdabot> Sorry, look up one word at a time please.
10:15:46 <Cale> giuliohome: I mean you should just ask the question and not ask whether asking is okay
10:16:23 <giuliohome> ok, good, the point is that using stack is difficult for me because he is assuming a different package manager...
10:16:26 <Cale> There are instructions for how to build that repo in the README there
10:16:47 <giuliohome> sure, but not for stack, if I understand it right
10:16:51 <Cale> right
10:17:07 <giuliohome> so, it is not even worth to try with stack?
10:17:11 <Cale> There are no stack configuration files provided, so I'm guessing if you wanted to use stack, you'd have to write one
10:17:12 <dsal> Is your question "Why does glguy not use stack?"
10:17:31 <giuliohome> no, it is: can I use it even if it is not documented
10:18:20 <geekosaur> you can use it but you'll need to do more work. in particular you need a stack.yaml that selects a resolver that uses ghc 8.8.1, and may need extra-packages for some dependencies if they're not in the resolver
10:18:28 <sm[m]> giuliohome: yes, it should be pretty easy for a project like this. Check out the stack init command.
10:19:47 <giuliohome> I've done stack init ... then I resolved the error by choosing the ghc version, then I followed the suggestion to compile cabal in the path with stack-install cabal install
10:20:20 <giuliohome> now do I have to run cabal build?
10:20:52 <giuliohome> and how can I instruct cabal to use stack ghc ? sorry I'm a beginner and I'm confised
10:20:55 <giuliohome> and how can I instruct cabal to use stack ghc ? sorry I'm a beginner and I'm confused
10:21:38 <geekosaur> if you are using cabal, you can't easily use stack's ghc. but if you have stack init done, stack build should work
10:21:55 <giuliohome> stack init done... now..
10:22:22 <giuliohome> Error parsing targets: The specified targets matched no packages.
10:22:34 <giuliohome> this is the result of stack build
10:23:17 <giuliohome> let me retry a "stack init --resolver ghc-8.8.1"
10:23:50 <sm[m]> giuliohome: I tried it also, and followed a different suggestion - I had to do stack init --omit-packages (since glguy's using latest megaparsec that's not in stackage); then fix up the stack.yaml by hand, uncommenting packages: - . and extra-deps: megaparsec-8.0.0
10:24:07 <geekosaur> are you inside the project?
10:24:37 <giuliohome> do you mean in the folder?
10:25:30 <geekosaur> yes
10:26:04 <giuliohome> yes I'm in the folder 
10:26:47 <sm[m]> https://termbin.com/pw06
10:26:57 <giuliohome> ok, I try what you did if it was succesful so now I go with "stack init --omit-packages"
10:26:58 <geekosaur> this may be the `packages: - .` thing
10:28:47 <giuliohome> now I have to edit stack.yaml...
10:29:05 <dsal> OK, this seems like an easy question.  How do I traverse with parTraversable?
10:32:27 <giuliohome> I don't understand how to write the "packages:" part in my stack.yaml :-/
10:33:39 <sm[m]> giuliohome: I pasted mine above, did you see ?
10:34:40 <sm[m]> or, shorter: https://termbin.com/l5rt
10:34:55 <giuliohome> this line "uncommenting packages: - . and extra-deps: megaparsec-8.0.0" ?
10:36:29 <giuliohome> ok, now I see it
10:38:04 <giuliohome> thank you... it is working...
10:38:23 <giuliohome> it is in progres... :-)
10:38:33 <militia> c_wraith: i'm trying to do something like this essentially: https://pastebin.com/mKK0yGe2
10:39:08 <militia> hence why I want it to take a general list [a]
10:39:45 <sm[m]> stack init could have been more helpful there (adding the extra deps for you)
10:39:49 <e1fa> has anyone done aoc day 7 yet? 
10:40:02 <e1fa> i just finished mine but it makes me want to puke in my mouth a little
10:40:44 <solonarv> mine will probably be very clean once I get my new intcode interpreter to run
10:40:46 <c_wraith> militia: that's not going to work.  You cannot use a String to describe a type
10:41:27 <militia> yeah otherwise I want to pattern match a certain type of list
10:41:29 <c_wraith> militia: and even if you could, there's nothing proving that String describes the type of the other argument
10:41:30 <militia> not sure if that can be done
10:42:05 <militia> the argument z is just an argument to match what type it is
10:42:15 <c_wraith> right, but that doesn't work, because Haskell is typed
10:42:44 <c_wraith> You can't just pass an argument saying "pretend the other argument has this type".  The compiler has to be able to prove it has that type.
10:42:46 <geekosaur> from earlier: note that you can't test the type and do something different based on it; if you said `a` meaning any type, you must accept any type there
10:43:09 <Cale> militia: It looks like you want D1 and D2 to be constructors of the same type
10:43:21 <geekosaur> you cannot pattern match to determine the type, nor can you usefully ask about that type
10:43:40 <Cale> You could have something like: data D = D1 { one :: String, two :: String } | D2 { three :: String, four :: String }
10:43:43 <militia> yeah i'd like to do something like printResults (D1 x:xs) = ...
10:43:45 <e1fa> solonarv: how are you dealing with input and output?
10:43:48 <Cale> and then pattern match
10:44:01 <militia> i don't think multiple constructors will work given how my actual program is set out
10:44:11 <militia> they are all pretty distinct types
10:44:22 <Cale> If you still need the single types, it's possible to construct a separate sum type
10:44:23 <militia> i just want one function to print things i'm getting out
10:44:26 <Cale> like
10:44:38 <militia> at the moment i need a separate printResults function for each type
10:44:53 <Cale> Or if the *only* thing you're going to do is print the list of things out, it might as well be a list of Strings to begin with
10:45:26 <Cale> You could also make printResults into a class method
10:45:41 <solonarv> e1fa: my interpreter is a ConduitT (from the 'conduit') package
10:45:46 <Cale> class Printable t where
10:45:53 <militia> and the class method will allow me to define different behaviour based on type?
10:45:54 <Cale>   printResult :: t -> String
10:45:56 <Cale> yep
10:45:56 <solonarv> I'm not sure if I would recommend it though, since I haven't gotten it to work yet
10:45:57 <militia> that sounds like what I want
10:46:27 <Cale> militia: Of course, in the end, any usage will have to occur at some particular type, though this choice can be deferred arbitrarily
10:46:38 <e1fa> solonarv: hmm. looks complicated
10:46:39 <militia> i'll have a look, thanks all
10:46:41 <Cale> It's still not going to let you put values of different types into a list
10:47:03 <e1fa> i made a state type with input and output lists, but it gets really annoying for part 2
10:47:03 <militia> no my lists will all be either [D1] or [D2] for example
10:49:01 <Cale> militia: You should also note that because of mapM, it's enough just to figure out how to print a single element
10:49:26 <Cale> (or mapM_)
10:50:06 <militia> right, the minimal definition
10:50:14 <militia> sounds promising, i'll have a go
10:54:20 <fresheyeball> hey out there
10:54:33 <fresheyeball> I am trying to cargo cult a bit of python into haskell
10:54:40 <solonarv> uh oh
10:54:42 <solonarv> what specifically?
10:54:50 <fresheyeball> I am using hask torch
10:54:59 <fresheyeball> and looking at a py torch example
10:55:24 <fresheyeball> x.view(-1, 16*6*6)
11:18:33 <habbah> where should I go to ask questions about conduit?
11:18:58 <fresheyeball> habbah: this is a good place I think
11:22:19 <dsal> sequenceA over parMap works, but sequencing a traversable just doesn't seem to parallelize.  This is kind of annoying.
11:32:01 <habbah> okay, I've managed to put it all into a gist: https://gist.github.com/mcbahson/98ab6a7e298103958e9be185260f55bd
11:38:18 <habbah> replacing sinkList with sinkNull results in an error where I need to be specific on the type generated by randomRIO and when I give it a Random Integer type annotation, it says that it was expecting an a
11:38:48 <habbah> seems like I should pay someone to help me get past this
11:39:27 <koz_> habbah: You may have to wait a moment. Not everyone uses conduit, and not everyone who does may be around.
11:39:55 <dsal> I use conduit.  I just got really hungry.
11:40:44 <dsal> habbah: It's not completely clear what you want to happen here.
11:41:25 <habbah> ultimately, I want to generate a list of random integers and print them
11:41:53 <koz_> dsal: Conduit causes munchies send tweet?
11:42:34 <dsal> habbah: Well, it might be easier if you separate those two things.  Right now, with sinkList, you're trying to make a list, but main is IO ()
11:42:55 * dsal tries to figure out how to build that project
11:43:45 <aplainzetakind> I'm stuck with part 2 of AoC because I can't make my interprete which runs in ST produce its output lazily.
11:43:48 * dsal just made a stack project because cabal was super angry
11:43:54 <dsal> aplainzetakind: Hey, that was my problem!  :)
11:44:05 <aplainzetakind> Did you solve it?
11:44:26 <dsal> Yeah, but not using that type of strategy.
11:44:37 <habbah> dsal: I tried sinkNull after realizing that was the issue
11:45:50 <aplainzetakind> dsal: But it shouldn't be technically impossible to make it lazy right?
11:46:04 <dsal> aplainzetakind: I couldn't figure out a way, so I can't say either way.
11:47:20 <dsal> habbah: part of your problem is that it's too generic to figure out what you want.
11:49:13 <dsal> aplainzetakind: do you want a ##adventofcode-spoilers  ? 
11:49:53 <aplainzetakind> dsal: I actually want to make this work lazily as a matter of principle.
11:50:12 <dsal> aplainzetakind: Please let me know if you do.  This was my first time actually trying ST for anything.
11:50:14 <aplainzetakind> I mean non-halting programs should produce output.
11:50:15 <habbah> I imginatewhy is randomRIO (1,6) too generic?
11:50:23 <aplainzetakind> Iwill.
11:50:28 <dsal> :t randomRIO
11:50:30 <lambdabot> Random a => (a, a) -> IO a
11:50:36 <dsal> :t print
11:50:38 <lambdabot> Show a => a -> IO ()
11:50:43 <dsal> habbah: Nothing ever figures out what a is.
11:50:51 <dsal> So  you can declare your range as an (Int,Int) and it works fine.
11:51:21 <habbah> that worked
11:51:44 <aplainzetakind> dsal: I think the trick may be in the way the output list is constructed.
11:51:56 <iqubic> Is there a good way to make this function point free:
11:52:01 <iqubic> execProg prog inputs = execWriter $ evalStateT step $ initialMem prog inputs
11:52:18 <dsal> @pl \prog inputs -> execWriter $ evalStateT step $ initialMem prog inputs
11:52:18 <lambdabot> ((execWriter . evalStateT step) .) . initialMem
11:52:32 <aplainzetakind> I accumulated the output by composing (lastOut :)s on the right, so it would act like a fifo.
11:52:47 <dsal> And then reverse?  I started out  that way.
11:52:55 <dsal> Using <> didn't help me, at least.
11:53:12 <aplainzetakind> No not reverse.
11:53:42 <aplainzetakind> The output would accumulate [Int] -> [Int]'s.
11:53:54 <aplainzetakind> Int the form (o1 :) . (o2 :) . ...
11:54:05 <dsal> My current output is:   V.unsafeFreeze vram >>= \r -> pure $ Right (FinalState r vout)
11:54:50 <aplainzetakind> When it was time to halt accumulatedFunc [] would be output.
11:56:14 <aplainzetakind> But compositions still wait for the argument to come and then be evaluated from the right I guess.
11:58:03 <dsal> My brain is tiny and weak, but finishing ST seems like a laziness barrier.  It acts like I'm actually able to build a sort of (cycle []) in there somewhere, so my lists aren't actually stitched together.
12:00:24 <aplainzetakind> Control.Monad.ST.Lazy exists, and the documentation of array notes that STUArray is strict while STArray is not.
12:00:56 <aplainzetakind> So I think the obstacle is not inherent to ST, but rather to the structure of the output.
12:09:57 <aplainzetakind> > head $ (1 :) . undefined $ undefined
12:10:00 <lambdabot>  1
12:10:14 <aplainzetakind> So much for that theory.
12:10:20 <fresheyeball> anyone know how to flatten a Tensor in ATen?
12:10:31 <fresheyeball> in pythong this is just x.view
12:10:35 <fresheyeball> I can't find it in haskell
12:10:55 <solonarv> aha! I got my fancy conduit thing working
12:14:11 <aplainzetakind> solonarv: Is that also about what I've been troubling over?
12:14:50 * hackage doctemplates 0.8 - Pandoc-style document templates  https://hackage.haskell.org/package/doctemplates-0.8 (JohnMacFarlane)
12:22:10 <solonarv> aplainzetakind: if you are doing advent of code, then yeas
12:22:49 <dsal> I'm interested in knowing how well that works with conduit.
12:24:36 <solonarv> mostly quite well
12:25:01 <solonarv> I did end up cracking open Data.Conduit.Internal to write two new combinators, but that was not actually very difficult
12:25:13 <aplainzetakind> I was just looking into pipes.
12:25:18 <fendor> @oeis 3 5 8 13
12:25:20 <lambdabot>  https://oeis.org/A000045 Fibonacci numbers: F(n) = F(n-1) + F(n-2) with F(0)...
12:25:20 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
12:25:22 <dsal> part 2 in particular.  :)  I'm a somewhat casual conduit user.  Though I guess getting my mqtt client working via websockets did take some tinkering.
12:25:30 <aplainzetakind> Do you know how they compare?
12:25:42 <dsal> I've not tried pipes.
12:36:58 <lavalike> dsal: what do you use mqtt for?
12:37:07 <dsal> Lots!
12:38:13 <dsal> I've got a thing that monitors my car and shoves state into mqtt (and sqlite).  I've got subscribers that store data in influxdb, some that monitor to let me know when things aren't updating.  I built an rpc-over-mqtt thing that lets me sync my local data via mqtt to a local sqlite.
12:38:41 <dsal> I also added the ability to interact with my IoT-car.  I can honk my horn and set my seat heater temperatures via mqtt.
12:56:05 <iqubic> @src fix
12:56:05 <lambdabot> fix f = let x = f x in x
13:00:30 <Zemyla> > fix error
13:00:34 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
13:00:50 <dsal> @src mfix
13:00:50 <lambdabot> Source not found. Do you think like you type?
13:02:06 <iqubic> :t fix
13:02:09 <lambdabot> (a -> a) -> a
13:02:14 <iqubic> What is mfix?
13:02:35 <iqubic> Monad m => (a -> m a) -> m a
13:07:23 <dmwit> That's not the correct type.
13:07:35 <dmwit> Anyway, it's like fix except it can do side-effects in the loop.
13:08:42 <dsal> :t mfix
13:08:44 <lambdabot> MonadFix m => (a -> m a) -> m a
13:09:27 <tom__> How do you utilise all your CPU cores whilst compiling with 8.6.5
13:10:51 <geekosaur> ghc +RTS -N -RTS ... — this said, ghc itself doesn't seem to parallelize well
13:11:35 <tom__> geekosaur: Cheers
13:12:10 <cocreature> is there a difference between GHC’s -j and passing +RTS -N -RTS to GHC?
13:13:13 <geekosaur> hm, -j may do that and attempt to make use of it. I vaguely recall something about how it manages in-core .hi files defeating parallelism though
13:14:15 <tom__> So I tried -j 
13:14:32 <tom__> It works a bit faster but still isn't taking advantage of real parallelism
13:15:11 <dsal> I'm looking forward to a sufficiently fast compiler.
13:15:35 <dmwit> tom__: The usual way people get a speedup is by compiling a bunch of packages in parallel with cabal.
13:15:48 <dmwit> Parallelism within a single package is still not great, I believe.
13:16:07 <tom__> Ah right
13:16:27 <dmwit> (So, multiprocessing rather than multithreading. As usual, easier when it's possible.)
13:16:28 <tom__> So I should use Local Modules then
13:19:16 <dmwit> ...I don't know what that means.
13:19:38 <aplainzetakind> Isn't there something that does                         , _outF :: [Int] -> [Int]
13:19:40 <svipal> Why can ' t I use declaration splices in a typeclass instance
13:19:47 <aplainzetakind> Pff, garbage clipboard.
13:19:53 <svipal> this makes me genuinely sad
13:19:59 <svipal> I'm legit tearing up
13:20:04 <aplainzetakind> I meant ConduitT () a m () -> [a]
13:20:16 <aplainzetakind> I meant ConduitT () a m () -> m [a]
13:23:00 <svipal> When is Hackett with seamless Haskell interop releasing, seriously
13:23:08 <svipal> s e r i o u s l y 
13:23:17 <svipal> TemplateHaskell is torture
13:23:43 <lexi-lambda> svipal: I am gladly accepting offers of research funding ;)
13:24:23 <svipal> The most I can do right now is believe in you very, very hard
13:26:01 <svipal> Are you still working on it ?
13:26:28 <lexi-lambda> Not really; I haven’t had the time.
13:27:28 <cocreature> :t \x -> Data.Conduit.runConduit $ x Data.Conduit..| Data.Conduit.List.consume
13:27:30 <lambdabot> Monad m => conduit-1.3.1.1:Data.Conduit.Internal.Conduit.ConduitM () b m () -> m [b]
13:27:41 <cocreature> ^ aplainzetakind
13:27:50 * hackage mmsyn6ukr 0.5.0.0 - A musical instrument synthesizer or a tool for Ukrainian language listening  https://hackage.haskell.org/package/mmsyn6ukr-0.5.0.0 (OleksandrZhabenko)
13:27:54 <cocreature> oh they left
13:30:07 <geekosaur> they rejoined
13:30:36 <dmwit> aplainzetakind: While you were gone, cocreature suggested:
13:30:42 <dmwit> :t \x -> Data.Conduit.runConduit $ x Data.Conduit..| Data.Conduit.List.consume
13:30:44 <lambdabot> Monad m => conduit-1.3.1.1:Data.Conduit.Internal.Conduit.ConduitM () b m () -> m [b]
13:31:44 <dmwit> svipal: I'm pretty surprised. Perhaps for now you can work around it by making a top-level splice, then writing `instance Foo Bar where baz = topLevelBazForBar` or whatever.
13:32:16 <geekosaur> or splicing the whole instance decl, which I think works?
13:32:33 <svipal> dmwit yep, will do that. 
13:32:45 <svipal> I can' t splice the whole instance decl it ' s too beefy
13:33:16 <dmwit> What goes wrong with splicing in an instance? It seems like a pretty shocking oversight for that not to work. Is it a layout thing? Does explicit {;} syntax make it work?
13:34:22 <geekosaur> doesn't seem shocking to me, seems like just an oversight because it checks the context of the splice and doesn't consider that one a decl context (or it is one but isn't wide enough for full declarations, or something)
13:34:34 <hseg> Hi. I'm using hmatrix, which pulls in random. However, with -fno-code, for some reason random fails to build. Ideas?
13:35:24 <hseg> ghc complains that it finds tab characters, then ar complains it can't find dist/build/System/Random.o
13:36:30 <geekosaur> I suspect -fno-code isn't expected to work with transitive dependencies
13:37:21 <hseg> Hrm. I'm only picking up the -fno-code because I'm using ghcid
13:37:59 <hseg> Not too attached to hmatrix
13:38:22 <geekosaur> I'd install random separately then
13:38:47 <hseg> Don't need random myself -- only need a linear algebra library
13:38:49 <dsal> :r keeps reminding me why OverloadedLists isn't always convenient.
13:39:16 <hseg> (In fact, all I need is something that can compute a maximal linearly independent subset of a set of vectors)
13:40:20 <hseg> (have a family of vector spaces I'm generating, want to see how dimensions grow and possibly find a nice basis)
13:40:57 <hseg> Tried installing random separately as cabal install random, but cabal complains random has no executables
13:41:18 <svipal> dmwit one sec, will try ;
13:42:12 <aplainzetakind> dmwit: Thanks.
13:42:31 <aplainzetakind> cocreature: And thank you :)
13:42:43 <hseg> and even when I pass --lib, that still doesn't fix the ghc --fno-code problem
13:43:15 <aplainzetakind> I found lazyConsume in Data.Conduit.Lazy
13:43:15 <aplainzetakind> But that forces me to be use IO Arrays it seems.
13:43:21 <aplainzetakind> s/be//
13:46:15 <dsal> I was kind of hoping Control.Monad.ST.Lazy would do some magic, but it doesn't seem to help.
13:53:54 <hseg> ... recommendations for a linear algebra library that can compute the rank of an arbitrary-dimensional matrix? `hmatrix` breaks bc of the `random` dep, `linear` works out-of-the-box up to 4d, don't see many alternatives
13:54:21 <hseg> nm, just saw https://stackoverflow.com/questions/47953036/how-to-create-matrices-with-the-linear-library-in-haskell
13:56:42 <hseg> Though I'm not seeing any rank computations or decompositions in `linear`...
14:02:32 <tom__> Is it a good idea to use the QuasiQuoter for creating queries with postresql-simple?
14:07:35 <hseg> ... really don't want to have to bash my head against numpy here, but it feels like that's where I'm being pushed to.
14:07:46 <hseg> *numpy/sympy
14:08:16 <hseg> eh, have a couple other approaches to try anyway
14:08:22 <hseg> thanks anyway!
14:16:01 <d34df00d> Hi!
14:16:11 <d34df00d> Does it make sense to add -fllvm to ghc options for a library package?
14:50:51 * hackage edit-distance-linear 0.2.0.1 - Efficient implementation Levenshtein distance in linear memory.  https://hackage.haskell.org/package/edit-distance-linear-0.2.0.1 (0xd34df00d)
15:16:21 * hackage tmp-postgres 1.28.1.0 - Start and stop a temporary postgres  https://hackage.haskell.org/package/tmp-postgres-1.28.1.0 (JonathanFischoff)
15:20:50 <dsal> I see that package a lot.  Does a be package roll out for every database restart?
15:30:23 <hpc> the dark side of CI/CD
16:46:20 <infinity0> jle`: thanks for your blog posts on singletons, they've been very useful and educational!
16:48:17 <jle`> infinity0: glad it was helpful :)
17:06:31 <iqubic> So, let's say I have two infinite lists, x::[a] and y::[a] is it possible to make a third infinite list z::[a] where I take the first value from x, then the first value from y, then the second value from x, then the second value from y, and so on?
17:06:39 <iqubic> So basically: z !! 0 = x !! 0, z !! 1 = y !! 0, z !! 2 = x !! 1, z !! 3 = y !! 1
17:07:18 <iqubic> x !! 0, y !! 0, x !! 1, y !! 1, x !! 2, y !! 2, ...
17:07:39 <shachaf> I feel like that description is longer than writing a description in Haskell that's also an implementation.
17:09:20 <shachaf> Anyway, the answer is yes.
17:09:34 <iqubic> so if x == [1,3..] and y == [2,4..] then z == [1..]
17:09:43 <iqubic> I have no idea how you'd do that.
17:09:58 <jacks2> can you do it with basic recursion?
17:10:10 <solonarv> yes you can
17:10:21 <jacks2> I mean, can iqubic do it
17:10:32 <solonarv> let's wait and see ;)
17:10:52 <shachaf> Probably not, because someone will type out the implementation in here soon.
17:11:31 <MarcelineVQ> what if we obfuscate it :>
17:11:54 <solonarv> what if we just don't *gasp*
17:11:57 <iqubic> http://dpaste.com/2HW06JB
17:12:01 <iqubic> I did it.
17:12:24 <solonarv> nice!
17:12:33 <iqubic> shachaf:  You were right. I could do it.
17:13:48 <solonarv> :t (:) . (:[])
17:13:50 <lambdabot> a -> [[a]] -> [[a]]
17:13:59 <solonarv> hm, no
17:14:42 <iqubic> Are you trying to write my function as a one liner?
17:15:03 <solonarv> yes
17:15:15 <iqubic> Ah. I'm not sure that's possible.
17:15:49 <solonarv> @let interweave2 = (concat .) . zipWith (flip (:) . (:[]))
17:15:51 <lambdabot>  Defined.
17:15:55 <solonarv> :t interweave2
17:15:56 <lambdabot> [a] -> [a] -> [a]
17:16:14 <iqubic> You can try it with non infinite lists too.
17:16:15 <solonarv> > interweave2 [1,3,5] [2,4,6]
17:16:18 <lambdabot>  [2,1,4,3,6,5]
17:16:30 <solonarv> bah, need one more flip
17:16:36 <iqubic> Well, I wanted the flipped version of tha.
17:16:51 <iqubic> How the hell does that work?
17:17:38 <iqubic> @let interweave2iqubic = (concat .) . zipWith (\x y -> [x, y])
17:17:41 <lambdabot>  Defined.
17:17:57 <solonarv> @let interweave2 = (concat .) . zipWith ((. (:[])) . (:))
17:17:58 <lambdabot>  .L.hs:167:1: error:
17:17:58 <lambdabot>      Multiple declarations of ‘interweave2’
17:17:58 <lambdabot>      Declared at: .L.hs:165:1
17:18:04 <iqubic> > interweave2iqubic [1,3,5] [2,4,6]
17:18:07 <lambdabot>  [1,2,3,4,5,6]
17:18:08 <solonarv> @let interweave2' = (concat .) . zipWith ((. (:[])) . (:))
17:18:10 <lambdabot>  Defined.
17:18:13 <iqubic> There we are.
17:18:24 <solonarv> > interweave2 [1,3,5] [2,4,6]
17:18:28 <lambdabot>  [2,1,4,3,6,5]
17:18:29 <solonarv> > interweave2' [1,3,5] [2,4,6]
17:18:34 <lambdabot>  [1,2,3,4,5,6]
17:18:36 <iqubic> Mine works too, and is arguably clearer.
17:18:43 <solonarv> oh of course
17:18:55 <solonarv> I would even argue the original version you wrote is clearest
17:19:01 <iqubic> Yes. I know.
17:19:20 <iqubic> I don't actually understand how yours works.
17:20:20 <iqubic> And I don't really have time to analyze it right now.
17:20:32 <jacks2> @pl \x y -> [x, y]
17:20:32 <lambdabot> (. return) . (:)
17:21:38 <iqubic> I get that return = (:[]) for lists. But nothing else there.
17:22:16 <iqubic> Oh, actually, I do get it now.
17:22:26 <jacks2> > ((concat .) . zipWith ((. return) . (:))) [1,3,5] [2,4,6]
17:22:29 <lambdabot>  [1,2,3,4,5,6]
17:22:30 <solonarv> oh neat, @pl understands lists
17:22:35 <iqubic> thinking about it more makes it make sense.
17:22:36 <jacks2> do ya? =)
17:22:47 <iqubic> I do.
17:22:58 <iqubic> (. return) . (:) x y
17:23:10 <solonarv> I also used @pl to generate that '((.(:[])).(:))` expression; I just wrote (:[]) instead of return
17:23:22 <shachaf> "thinking about it more makes it make sense."
17:23:24 <iqubic> (. return) (x:) y
17:23:26 <shachaf> That's the real moral of this story.
17:23:37 <iqubic> (x:) . return y
17:23:45 <iqubic> (x:) [y]
17:23:53 <iqubic> [x, y]
17:24:15 <iqubic> I understand it now.
17:39:36 <[Leary]> :t flip (foldr (.) id) [] &fmap.fmap$ zipWith ((.) `on` (:))
17:39:38 <lambdabot> [a] -> [a] -> [a]
17:39:55 <[Leary]> Slightly less insane, just as pointless.
17:40:26 <solonarv> oh hey you used the &foo$ trick
17:43:38 <[Leary]> I saw someone mention it in here the other day, can't remember who. It's a nice discovery though; stops me from having to bind a new name just to have an operator.
17:45:12 <solonarv> yeah, pretty neat
18:08:30 <nshepperd> o_O
18:08:38 <nshepperd> is that homebrewed `backticks`
18:09:13 <MarcelineVQ> with some section-like-ness
18:49:39 <adamwespiser> Is there an easy solution for using "runhaskell" with stackage/hackage libraries that require download? I'd like to be able to play around with short snippets of code, and so far the only easy way to do it is to make a new stack/cabal project!
18:49:51 <f-a> adamwespiser: there are cabal scripts
18:50:21 <f-a> or just cabal new-install --lib 
18:57:15 <glguy> If you've been doing AdventOfCode.com in Haskell and you're not already on my leaderboard: 43100-84040706 ; Join in!
19:02:51 * hackage tibetan-utils 0.1.2.0 - Parse and display tibetan numerals  https://hackage.haskell.org/package/tibetan-utils-0.1.2.0 (vmchale)
19:45:20 * hackage ansi-terminal-game 1.0.0.0 - sdl-like functions for terminal applications, based onansi-terminal  https://hackage.haskell.org/package/ansi-terminal-game-1.0.0.0 (fffaaa)
19:56:41 <sm[m]> adamwespiser: stack scripts
19:56:55 <sm[m]> 1.0! congrats f-a
19:57:04 <f-a> :) sm[m] 
19:58:36 <jchia_> What's a simple unceremonious way to read 8 bytes from a file into an Int64. Endianness doesn't matter. I know how to do it in a ceremonious way. I'm just looking for a simple way that involves simple code. Performance doesn't really matter.
20:00:45 <adamwespiser> @sm[a] thanks, working this solution now
20:00:45 <lambdabot> Unknown command, try @list
20:00:53 <adamwespiser> sm[m]: thanks
20:01:02 <dsal> jchia_: https://hackage.haskell.org/package/binary-0.8.5.1/docs/Data-Binary-Get.html is really pretty easy.
20:02:19 <jchia_> Is there a shorter way? The background is that I'm just trying to read a random Int64 from /dev/urandom so that my program gets random number at startup. I'm not sure how the global RNG is seeded but I fear it's based on the current number of seconds since Epoch, which is too predictable, so I'm not using it. Calculating my own seed from something else is equally ceremonious.
20:02:46 <dsal> shorter?  Not really.  You can do the math yourself.
20:02:53 <dsal> Read a byte, shift it over, repeat.
20:05:13 <dsal> It's basically    runGet getInthost getWord64be
20:05:18 <dsal> It's basically    runGet getWord64be
20:05:47 <dsal> feed it a bytestring.
20:06:44 <sm[m]> adamwespiser: I tend to have the script compile itself , then I run the compiled version to do actual work
20:06:54 <jchia_> dsal: Int64 is Storable. I was hoping for a shortcut that lets me read from a binary file to a Storable
20:06:57 <jchia_> just like that
20:08:02 <dsal> % BG.runGet BG.getWord64be (fromString "aaaieifjeijgiwjgijigjwigjwiegj")
20:08:02 <yahb> dsal: 7016996799720810090
20:08:21 <adamwespiser> sm[m]: thats smart, downloading and building is too slow, my problem is that I want to try out new libraries and am too lazy to make a new stack project and edit 3 files 
20:10:02 <glguy> cabal repl --build-dep newlibrary 
20:10:05 <glguy> is pretty good for hat
20:10:08 <glguy> that*
20:37:49 <iqubic> 22 minutes left.
20:39:50 * hackage venzone 1.0.0.0 - ASCII platform-adventure game  https://hackage.haskell.org/package/venzone-1.0.0.0 (fffaaa)
20:40:59 <sm[m]> hurrah! venzone is here
20:41:51 <f-a> \o/
20:46:29 <sm[m]> Krampuses!
20:47:43 <f-a> yup, and river-witches
20:48:00 <f-a> and a couple of endings
20:49:10 <sm[m]> f-a: it's great. Feels like plenty of action
20:49:56 <sm[m]> my play time is up, tomorrow I shall attempt the mountain again
20:50:08 <sm[m]> congrats
20:50:37 <f-a> thanks and thanks for support + suggestions/patches
21:06:19 <jchia_> dsal: Strictly speaking Get is about parser that does not tell you how many input bytes are needed for a given target type (e.g. Int64). I think I prefer to use Data.Store
21:17:21 * hackage venzone 1.0.0.1 - ASCII platform-adventure game  https://hackage.haskell.org/package/venzone-1.0.0.1 (fffaaa)
21:21:56 <avp> is there an easy way to rewrite (\a b -> compare (f a) (f b)) or is that the most elegant way to do it? I want to use this function in minimumBy
21:22:22 <f-a> avp: maybe `on`?
21:22:24 <f-a> :t on
21:22:26 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
21:22:29 <glguy> :t comparing
21:22:31 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
21:22:37 <glguy> :t on compare
21:22:39 <lambdabot> Ord a1 => (a2 -> a1) -> a2 -> a2 -> Ordering
21:23:07 <glguy> > minimumBy (comparing length) ["eight","nine","ten"]
21:23:09 <lambdabot>  "ten"
21:23:26 <avp> very nice, thanks
21:37:07 <nfd9001> Hey, I want to sort a list by an effectful computation, and I can't seem to find a way to make all the types work out properly
21:37:51 <koz_> nfd9001: So what you want is something like (Ord b) -> (a -> f b) -> [a] -> f [a]?
21:38:10 <koz_> Sorry, (Ord b) => ...
21:38:27 <nfd9001> i assume that first -> is a =>
21:38:40 <koz_> nfd9001: Yep, typo on my part.
21:38:43 <nfd9001> but yes
21:38:48 <f-a> hoogle finds nothing, weird
21:39:38 <nfd9001> err, not sure what happened there
21:39:56 <nfd9001> koz_: yeah; just (Ord b) => (...)
21:40:09 <koz_> Hmmm.
21:40:46 <nfd9001> i've been trying to fmap various different parts of sortBy, but it's not really working out too well
21:42:39 <nfd9001> i guess I could use sortOn and provide an f a -> f b -> Ordering...
21:43:28 <jle`> nfd9001: it doesn't quite work because sortBy 're-runs' the comparing function in every case
21:43:54 <nfd9001> oh, sorry, i transposed the two names
21:43:54 <jle`> nfd9001: depending on what your requirements are, you can probably traverse your function to get f [(a, b)]
21:44:04 <jle`> nfd9001: and then fmap sortBy (comparing snd)
21:44:11 <jle`> * fmap (sortBy (comparing snd))
21:44:29 <nfd9001> been using sortOn, sortBy doesn't seem quite right
21:44:41 <jle`> fmap (map fst . sortOn snd), if you like sortOn better
21:45:04 <jle`> so effectfulSort f = fmap (map fst . sortOn snd) . traverse (\x -> (x,) <$> f x)
21:45:15 <nfd9001> it would be somewhat inefficient to rerun that effect
21:45:32 <jle`> well, the inefficiency isn't the bad part
21:45:37 <jle`> it's the semantics and duplication of effects
21:45:44 <jle`> so for example a second 'getLine' might give a different result
21:45:52 <koz_> jle`: Doesn't that traverse avoid that though?
21:45:52 <jle`> if you sort on `getLine`'s results, for instance
21:46:00 <jle`> yeah, the way i gave would only run each effect once
21:46:00 <nfd9001> it would only be somewhat inefficient to rerun that effect
21:46:20 <jle`> nfd9001: yeah, i'm saying that the inefficiency isn't the bad part
21:46:22 <nfd9001> i'm using an IOArray, but I might as well be using one in ST
21:46:44 <jle`> nfd9001: the bad part is that because you're generating something effectfully, using the same function twice could get you a different result
21:46:49 <jle`> like for example getLine
21:46:50 <nfd9001> as a matter of doing it all in general, yes, you don't want to rerun effects
21:47:03 <jle`> but yeah, the version I gave won't rerun any effects
21:47:14 <jle`> sortOnA f = fmap (map fst . sortOn snd) . traverse (\x -> (x,) <$> f x)
21:48:11 <jle`> :t \f -> fmap (map fst . sortOn snd) . traverse (\x -> (x,) <$> f x)
21:48:13 <lambdabot> (Ord b1, Applicative f) => (b2 -> f b1) -> [b2] -> f [b2]
21:48:14 <koz_> I don't think you can do this with an IOArray though.
21:48:23 <koz_> They're not Traversable.
21:48:30 <jle`> i think they want it on lists
21:48:35 <nfd9001> the computation uses an IOArray, but yeah
21:48:38 <nfd9001> I want it on lists
21:48:45 <jle`> IOArrays might just be what the (a -> IO b) is using
21:48:51 <koz_> What do you need the IOArray for?
21:48:58 <nfd9001> i'm doing AoC day 7-1, basically
21:49:00 <koz_> Do you need to do any other IO?
21:49:22 <nfd9001> no, not really. i have some other IO writes commented out, but those are only useful for debug data
21:49:37 <koz_> So you just want mutable state that happens to be an array?
21:50:10 <nfd9001> Yeah
21:50:24 <nfd9001> And I have an entire little VM written in IOArray
21:50:41 <nfd9001> s/in/using/g
21:51:58 <nfd9001> so, this particular assignment needs you to use all permutations of [0..4] as inputs to a chain of these VMs
21:52:49 <nfd9001> that is, you're chaining 5 machines together, and each one takes one of [0..1] as an input without replacement
21:53:37 <nfd9001> then you also pass 0 as an input to the first machine. the second machine takes the output from the first machine as its second input, ..., and you need to find an ordering of those first inputs that maximizes the last output
21:54:02 <nfd9001> jle`: thanks; i'll try that in a bit
22:11:18 <ChaiTRex> Is there some way to make a state monad that can ignore future computations like the maybe monad when it goes from Just to Nothing?
22:11:49 <koz_> ChaiTRex: I'm not quite sure what you mean.
22:14:01 <ChaiTRex> koz_: I want to have something like Whatever m a = More { runState :: m -> (a, m) } | Ended m
22:14:16 <koz_> @unmtl MaybeT (State s) a
22:14:17 <lambdabot> s -> (Maybe a, s)
22:14:30 <koz_> @unmtl StateT Maybe s a
22:14:30 <lambdabot> Maybe -> s (a, Maybe)
22:14:36 <koz_> Lol, nope.
22:14:52 <koz_> @unmtl StateT s Maybe a
22:14:52 <lambdabot> s -> Maybe (a, s)
22:15:00 <koz_> Kinda like that?
22:15:16 <ChaiTRex> I've never used MTL, so I'm not sure :)
22:15:30 <adamwespiser> you could make type a something like { data a = Continue a | Ended a }
22:15:34 <koz_> It's not to do with mtl. It's just showing you what that stack is similar to.
22:15:37 <adamwespiser> or just another sum type
22:15:48 <koz_> And I'd say StateT s Maybe a sounds like what you're after.
22:15:53 <koz_> Since that's basically s -> Maybe (a, s)
22:16:26 <ChaiTRex> OK, thanks. They type s -> Maybe (a, s) gives me something to go off of.
22:19:31 <ChaiTRex> adamwespiser: The issue I get is that writing the instance for Ended a >>= _ is easy, but how to get Continue a >>= f or whatever to be able to output data with either constructor?
22:20:03 <koz_> ChaiTRex: If you wanna go that way, you wanna do
22:20:25 <koz_> Endable s a = More s a | Done s
22:20:26 <koz_> Or something.
22:21:14 <koz_> Actually no, more like
22:21:30 <koz_> Endable s a = More (s -> (a, s)) | Done (s -> s)
22:25:25 <nfd9001> jle`: there a reason you're doing (x,) <$> fx over (x, f x)
22:25:26 <nfd9001> >
22:25:28 <nfd9001> ?
22:26:25 <koz_> Imagine if fx :: Maybe a
22:26:27 <adamwespiser> :koz_ yes, that should work, where the function for 'Done' just doesn't return an a. The only weird thing, is that the ergonomics of deciding you are "done" are going to be decided via bind composition
22:26:31 <koz_> And x :: b
22:26:55 <koz_> (x,) <$> fx :: Maybe (b, a), but (x, fx) :: (b, Maybe a)
22:27:34 <adamwespiser> and there should probably be a "finishComputation :: s -> Endable s a" that can be used by anywhere
22:37:14 <nfd9001> alright, I added the appropriate ghc extension
22:37:23 <nfd9001> and now it just looks like I have a VM bug to iron out!
22:39:09 <nfd9001> thanks
22:46:06 <jle`> nfd9001: you want the f (a,b)
22:46:15 <jle`> not the (a, f b)
23:47:14 <dmj`> jle`: you finished 7 and 8 fast
23:51:59 <jle`> going for speed is pretty stressful D:
23:52:16 <koz_> jle` is speedrunning AOC.
23:52:22 <koz_> (AoC?)
23:52:38 <jle`> aOc
23:53:27 <koz_> AdCode.
23:57:04 <dmj`> too fast to code, to young to die
