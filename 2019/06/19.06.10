00:17:24 <MasseR> kaol: warning, 8.4 has some bugs related to them. 8.6 and 8.2 work fine
02:04:43 * hackage higgledy 0.2.1.0 - Partial types as a type constructor.  https://hackage.haskell.org/package/higgledy-0.2.1.0 (i_am_tom)
02:18:13 * hackage conduit-connection 0.1.0.5 - Conduit source and sink for Network.Connection.  https://hackage.haskell.org/package/conduit-connection-0.1.0.5 (slomo)
02:26:55 <mikx> @pl g f x y=(f x,f y)
02:26:55 <lambdabot> g = flip =<< (((.) . (,)) .)
02:27:26 <mikx> @unpl g=flip =<< (((.) . (,)) .)
02:27:26 <lambdabot> g b0 y x0 = ((,)) (b0 y) (b0 x0);
02:32:39 <solonarv> mikx: still here?
02:33:13 <solonarv> g f x y = (f x, f y)
02:33:24 <solonarv> g f = (,) `on` f
02:33:36 <lavalike> nice one
02:33:44 <solonarv> g = ((,) `on`) -- or: g = on (,)
02:39:44 * hackage lens-regex-pcre 0.2.0.0 -   https://hackage.haskell.org/package/lens-regex-pcre-0.2.0.0 (ChrisPenner)
03:08:26 <mikx> @pl g = (.).(.).(.)
03:08:26 <lambdabot> g = (.) . (.) . (.)
03:08:32 <mikx> @unpl g = (.).(.).(.)
03:08:32 <lambdabot> g x g0 x0 x2 x3 = x (g0 x0 x2 x3);
03:09:09 <Taneb> @unpl ap
03:09:10 <lambdabot> (\ m1 m2 -> m1 >>= \ x1 -> m2 >>= \ x2 -> return (x1 x2))
03:09:28 <Taneb> @unpl ap (*) (+1)
03:09:28 <lambdabot> (\ a0 -> return (a0 * (a0 + 1)) a0)
03:10:08 <Taneb> That can be simplified, return a b ~ a
03:10:31 <Taneb> (because it forces m ~ ((->) x))
03:10:55 <Taneb> So it should be "\ a0 -> a0 * (a0 + 1)"
03:44:44 <edwardk> that lens-regex-pcre lib is pretty nice even if the traversals are illegal =)
04:12:49 <[exa]> hm guys, is there some simple gui library (like imgui) for gloss?
04:25:13 * hackage dprox 0.1.1 - a lightweight DNS proxy server  https://hackage.haskell.org/package/dprox-0.1.1 (BinJin)
05:45:06 <kritzefitz> What are the parentheses for combining constraints (e.g. `(Show a, c ~ b)`) called in TH? Specifically, how can I construct an empty constraint (i.e. `()`)?
05:45:30 <kritzefitz> I tried TupleT, but then I get complaints, that it has the Kind * instead of Constraint.
05:46:57 <Taneb> kritzefitz: constraints are I belive Cxt = [Pred] so []
05:48:08 <kritzefitz> Only in constructs that actually expect a context out of the box, but I'm trying to define a type synonym with Kind Constraint.
05:48:59 <kritzefitz> And TySynD expects a Type, not a Cxt.
05:49:18 <Taneb> Do you have the ConstraintKinds extension enabled?
05:50:06 <kritzefitz> Yes
05:50:32 <Taneb> Looking at the docs I'd expect it to be TupleT
05:50:58 <Taneb> If that's not working I don't know
05:51:06 <lyxia> can you show your code
05:52:14 <lyxia> the problem might be that type inference will default to Type in case of ambiguity, so you would need an annotation
05:55:55 <kritzefitz> lyxia, yes that was apparently the problem. `tupleT 0` is inferred as `*`, but `sigT (tupleT 0) ConstraintT` works.
06:15:14 <hjozwiak> Is there a master package for unicode symbols that pulls in base-unicode-symbols, containers-unicode-symbols, and friends?
06:18:21 <Ariakenom> . o O (default (Type, (), Integer, Rational))
06:24:44 * hackage greskell-core 0.1.2.6 - Haskell binding for Gremlin graph query language - core data types and tools  https://hackage.haskell.org/package/greskell-core-0.1.2.6 (debugito)
06:31:46 <cocreature> hackage: there only seems to be base-unicode-symbols and containers-unicode-symbols (and unicode-symbols which is deprecated in favor of the other two) so I‚Äôm not sure a master package that reduces the number of packages that you need to depend on from 2 to 1 is particularly useful
06:40:53 <Ariakenom> cocreature: you mean hjozwiak not hackage
06:42:28 <cocreature> oops :)
07:35:56 <snakemasterflex> exit
07:40:16 <basic> how big is the ghcjs overhead?
07:40:26 <basic> https://mario.haskell-miso.org/ i see this and thing, oh that's great
07:40:29 <basic> but one freaking mb?
07:42:23 <hyperisco> basic, gotta get the RTS in there
07:42:32 <hyperisco> Mario in a snowstorm?
07:44:24 <basic> hyperisco, yeah that's what i am asking: how big is the rts part and how does that sacle up?
07:44:48 <hyperisco> I don't know how big it is, but it is a constant cost.
07:45:14 <hyperisco> This is analogous to complaints that a "Hello World!" binary is too big.
07:45:15 <basic> yeah and how much sloc until i overtake that constant cost?
07:45:24 <basic> hyperisco, well, is it?
07:45:31 <hyperisco> I guess about 1MB worth, lol.
07:45:38 <basic> oh, lol
07:46:05 <hyperisco> It isn't worth talking about until you gzip it
07:47:21 <hyperisco> maybe a minifier/obfuscator can squeeze a few bytes out too
07:49:28 <hyperisco> You're never going to get a fashionably minimal script size, though, so factor that into your plans.
08:00:15 <cocreature> just remove one gif from your website and it will be a mb smaller
08:00:18 <tdammers> yeah. if you want small binaries, try purescript. there's still some overhead, but it's much smaller, and its output also lends itself better to things like tree shaking
08:00:39 <basic> searching for a single language solution
08:01:09 <basic> cocreature, but the gif isn't mandatory for seeing anything
08:01:22 <__monty__> JS shouldn't be either.
08:01:39 <tdammers> ah. I like to think of that as mildly fallacious. different priorities suggest different languages, and people routinely overestimate the mental and organizational burden of mixing languages within a project
08:02:59 <Taneb> (I've mixed Agda and assembly with relative ease, but that was for fun)
08:03:06 <__monty__> tdammers: There's undeniable code duplication though.
08:03:26 <basic> __monty__, that's opinion though, what i said is fact.
08:04:09 <__monty__> basic: Wat are you saying? I'd much rather browse the web without JS than without content.
08:04:23 <basic> __monty__, yeah, you, i don't, case closed i guess
08:04:29 <Taneb> The gif is mandatory for seeing the gif itself
08:04:46 <basic> Taneb, but it's not the main feature of the website, js *might* be
08:07:43 <hyperisco> I tried the "no JS" thing on my phone, because if websites are slow they're definitely slow on a mobile processor. Ultimately was too annoying.
08:08:10 <hyperisco> Faster loads yes, but often because I couldn't load what I actually wanted to read.
08:08:15 <basic> __monty__, whats your alternative when all web can do is displaying things?
08:09:11 <basic> i mean, what if you want a website that actually can do stuff
08:09:26 <__monty__> basic: What do you mean? The only parts of the web I rely on are information. I can deal with bare html without styling and fancy misfeatures.
08:09:42 <basic> an editor of some sort is not a misfeature
08:09:56 <__monty__> Sure, but vim doesn't need to run on the web.
08:10:09 <basic> yeah, but some sort of wysiwyg editor
08:10:51 <__monty__> I'm not against online editors, I just don't fancy them which conveniently allows me to not care very much about JS.
08:10:53 <hyperisco> I would appreciate some better delineation of web capabilities
08:11:43 <__monty__> basic: Also, you *could* have an editor fall back to an kludgy plain old forms based interface : )
08:12:00 <hyperisco> bbcode and all
08:12:03 <basic> well, no i am talking about something graphic, positioning things
08:12:36 <__monty__> basic: Still, form input, rendering server-side and just displaying a plain old jpg.
08:13:12 <__monty__> I'm talking about a fallback here, not the main marketable interface. A terrible fallback's still better than no fallback at all.
08:15:27 <cocreature> can we please not turn a question about ghcjs into yet another JS debate
08:15:37 <basic> it's not a js debate
08:15:56 <basic> it's a "should web be display only" debate
08:16:03 <__monty__> basic: Feel free to continue discussion in #haskell-offtopic if you think it's at all productive.
08:16:09 <cocreature> either way it seems entirely irrelevant to your original question and to this channel
08:16:22 <basic> agree
08:17:29 <cocreature> going back to your original question, GHCJS definitely has a significant overhead. Whether the benefits (code sharing, working in a language you‚Äôre familiar with, ‚Ä¶) outweigh that overhead is something that depends very much on your specific project.
08:19:16 <cocreature> I was quite happy when I was able to take a lot of tooling written for the backend, and turn it into a client-side typechecker that gives live feedback in an editor. Would I use GHCJS if I were to write a relatively small frontend that does not heavily rely on existing code? probably not but others might disagree.
08:20:08 <basic> well im already tired of writing models on both sides, i want to make it stop qq
08:21:16 <hyperisco> oh you want an isomorphism
08:21:25 <basic> yes
08:21:46 <cocreature> there is also a middleground where you share your data models, e.g., via some generic data schema definition or something like servant‚Äôs code generation for various languages
08:22:46 <hyperisco> by my estimation this is a minor problem, and I certainly don't worry about it, but I get that some are incredibly sensitive to a perceived duplication
08:24:19 <__monty__> hyperisco: What if seperate teams work on front- and backend?
08:24:41 <basic> cocreature, those data schema definition things tend to suck, do you have something specific in mind?
08:24:59 <hyperisco> *shrug* I don't know how that relates
08:25:02 <cocreature> not really, I‚Äôd probably go the servant route if I wanted to go that way
08:25:16 <basic> the "servant route" ?
08:25:43 <hyperisco> You just have to agree to the communication protocol.
08:26:02 <__monty__> hyperisco: Well, you'd have seperate teams making changes to the data models and having to keep them synchronized. That's not trivial.
08:26:19 <cocreature> there are servant libraries for various languages to codegen models in other languages from your Haskell types
08:26:24 <Boarders> At the start of my cabal project it says: Build profile: -w ghc-8.6.5 -O1
08:26:27 <hyperisco> No, you'd have them making changes to the communication protocol, which should be a joint decision.
08:26:36 <Boarders> even if I do --ghc-options="-O2"
08:26:50 <Boarders> am I doing something incorrect or what does it mean when the build profile says that?
08:26:56 <cocreature> Boarders: use -O2 not --ghc-options=-O2
08:26:56 <hyperisco> They're free to change their data models however they so please without affecting the other end!
08:27:19 <__monty__> hyperisco: Not when the data needs to be sent from the backend. It doesn't magically appear.
08:27:31 <Boarders> cocreature: thanks
08:27:49 <hyperisco> I don't know how that relates at all. If you have an agreed communication protocol, that is all that matters.
08:28:49 <basic> would just love it, if i created a migration, a model, and the client already knows whats up
08:29:51 <__monty__> hyperisco: In any case that just displaces the point of synchronization. It doesn't make it any easier.
08:30:58 <hyperisco> I don't disagree. My only point is that I don't think having to define some data models separately at both ends is a big problem.
08:32:49 <hyperisco> That's a freedom which can help teams work independently.
08:35:13 * hackage tree-sitter 0.1.0.0 - Unstable bindings for the tree-sitter parsing library.  https://hackage.haskell.org/package/tree-sitter-0.1.0.0 (patrick_thomson)
08:36:41 <jerv> I have a CLI that has an optional JSON flag. If it's set, output is printed in JSON rather than pretty printed. Should I do an if/else in the beginning and then pass a printing function around?
08:36:59 <jerv> Or what's the advised / idiomatic way to handle this pattern? 
08:37:30 <hyperisco> jerv, a Reader for the output format which is then read by the layer which is responsible for printing.
08:37:51 <hyperisco> So, yes, passing a parameter around.
08:38:59 <jerv> hyperisco: but would the printing layer then have to do a check every time it has to print something rather than calling the appropriate printing fn?
08:39:14 <jerv> Or is the value that we are passing around not boolean but indeed the appropriate printing fn?
08:39:29 <jerv> Reading up on the Reader monad, new to Haskell
08:40:04 <hyperisco> There's many ways to do it. You could pass a media type, and the view layer switches on this media type to select an appropriate formatter for the data.
08:40:44 * hackage OpenGLRaw 3.3.3.0 - A raw binding for the OpenGL graphics system  https://hackage.haskell.org/package/OpenGLRaw-3.3.3.0 (SvenPanne)
08:51:16 <boothead> Anyone had any experience buying a refurbished workstation for local haskell dev...? My existing desktop machine is starting to get a bit glitchy. Any suggestions for what I might look for in the dual xeon processor market?
08:52:51 <hyperisco> I don't think Haskell has much to do with dual Xeon servers. If that's what they need to do their work then cool, but I don't think Haskell weighs into it.
08:55:17 <hyperisco> You can buy used servers. Just Google for someplace local (to save on shipping).
08:56:25 <hyperisco> And if the model was released in, say, Q2 2014, then assume it has seen hell the last 5 years ;)
08:58:14 * hackage GLUT 2.7.0.15 - A binding for the OpenGL Utility Toolkit  https://hackage.haskell.org/package/GLUT-2.7.0.15 (SvenPanne)
08:58:29 <boothead> hyperisco: I'm just wondering what sort of spec I should look at if I'm going to get something refurbished. Is there a haskell on X hardware comparison anywhere?
09:01:12 <hyperisco> I don't know. You might be able to find compilation benchmarks, possibly for another language, and maybe that is analogous.
09:04:26 <boothead> I guess its a question of whether the extra cores are worth it or not. It's been at least a decade since I was current on anything hardware related, so I thought I'd ask here :-)
09:04:51 <hyperisco> The extra cores compared to what?
09:05:43 * hackage OpenAL 1.7.0.5 - A binding to the OpenAL cross-platform 3D audio API  https://hackage.haskell.org/package/OpenAL-1.7.0.5 (SvenPanne)
09:06:04 <boothead> Compared to an i7 or something
09:06:23 <hyperisco> Nah man you're paying for ECC memory support
09:07:23 <mpickering> How do I find out why Cabal is trying to build a package?
09:07:46 <hyperisco> If you wanted to save a buck on a lot of cores I'd suggest AMD
09:08:02 <cocreature> mpickering: the info spit out by cabal-plan can sometimes be useful
09:08:15 <mpickering> cocreature: How do I invoke that?
09:09:01 <cocreature> it‚Äôs a separate executable, it‚Äôs on hackage
09:09:14 <cocreature> it parses some files created by new-build
09:09:20 <mpickering> err ok
09:09:21 <hyperisco> Does https://www.reddit.com/r/haskell/comments/a5vnjy/intel_cpus_30_faster_than_amd_at_compiling_haskell/ suggest ghc doesn't parallelise well? I dunno.
09:09:39 <mpickering> ok I can look at the plan.json file that gets generated 
09:09:56 <cocreature> right, that‚Äôs the one parsed by cabal-plan
09:10:38 <mpickering> so I opened that and could see that `happy` depends on `Cabal` for an unknown reason
09:10:43 * hackage ALUT 2.4.0.3 - A binding for the OpenAL Utility Toolkit  https://hackage.haskell.org/package/ALUT-2.4.0.3 (SvenPanne)
09:10:53 <mpickering> I removed that and it was removed from the build plan
09:10:55 <mpickering> thanks a lot
09:11:05 <cocreature> mpickering: my guess would be custom setup
09:11:25 <cocreature> yep that seems to apply
09:11:34 <hyperisco> I wouldn't be stunned if GHC was more dependent on single core performance. A lot is.
09:12:36 <hyperisco> In which case, you don't want high core counts, you want a new 8th or 9th gen consumer Intel processor (those have hardware fixes for their security whoopsie)
09:13:33 <hyperisco> Because from all the numbers I'm seeing in benches, Intel still takes the cake on single core perf.
09:14:19 <boothead> hyperisco: Thanks - Just just had a read and that does indeed seem to be the case.
09:16:14 * hackage tree-sitter-go 0.1.0.0 - Tree-sitter grammar/parser for Go  https://hackage.haskell.org/package/tree-sitter-go-0.1.0.0 (patrick_thomson)
09:31:13 * hackage tree-sitter-typescript 0.1.0.0 - Tree-sitter grammar/parser for TypeScript  https://hackage.haskell.org/package/tree-sitter-typescript-0.1.0.0 (patrick_thomson)
09:37:14 * hackage hkgr 0.0 - Simple Hackage release workflow for package maintainers  https://hackage.haskell.org/package/hkgr-0.0 (JensPetersen)
09:44:45 <tabaqui> do you have working example of System.Win32.DLL?
09:45:25 <tabaqui> I need to use runtime linker on Win, but documentation is not really well
09:48:44 * hackage tree-sitter-java 0.1.0.0 - Tree-sitter grammar/parser for Java  https://hackage.haskell.org/package/tree-sitter-java-0.1.0.0 (patrick_thomson)
09:51:42 <cocreature> tabaqui: the Win32 package is a very thin layer on top of the underlying Win32 API so I would recommend that you look at the official docs for that/look for non-Haskell example code
09:52:59 <cocreature> tabaqui: GHC also provides some custom wrappers that might be useful, e.g., https://hackage.haskell.org/package/ghc-8.6.5/docs/GHCi.html#v:loadDLL although it‚Äôs probably harder not easier to find documentation for those
09:53:54 <tabaqui> cocreature: thanks, probably, I will use custom wrappers
09:55:58 <tabaqui> GHCi.loadDLL doesn't seems easier although
09:56:12 <tabaqui> *seem
10:00:42 <cocreature> tabaqui: what exactly are you confused about in loadDLL?
10:01:01 <tabaqui> cocreature: HscEnv argument
10:02:00 <tabaqui> fast looking doesn't show any method to directly get current HscEnv
10:02:32 <tabaqui> so I assume that it can be retrieved in some monad, but probably it will be easier to call LoadLibrary directly
10:02:44 <cocreature> huh, last time I used those functions, they didn‚Äôt require a HscEnv but that has been quite a while ago
10:03:27 <tabaqui> and loadDLL returns just a library, so I still have to retrieve a function, and make all checks on null pointer
10:04:14 * hackage tree-sitter-json 0.1.0.0 - Tree-sitter grammar/parser for JSON  https://hackage.haskell.org/package/tree-sitter-json-0.1.0.0 (patrick_thomson)
10:07:31 <hc> Hey all, GPU question: If I implement a certain algorithm with arrayfire and am using vectors for everything, generate random data on the gpu, etc...
10:07:40 <hc> And I manage to get a factor 4 speedup compared to a 4GHz 8core CPU
10:07:54 <hc> Is that bad or very bad? And where to look for the bottleneck?
10:08:43 * hackage tree-sitter-php 0.1.0.0 - Tree-sitter grammar/parser for PHP  https://hackage.haskell.org/package/tree-sitter-php-0.1.0.0 (patrick_thomson)
10:10:44 <hololeap> is there something like finite-typelits, but allows a only a specific range of Nat's?
10:10:58 <stephenmac7> Hello, I'm trying to use the tomland library to parse a toml file, but there is one part of the specification where I don't know the keys in advance. I would like to just get a hash map for that part, but am not sure how.
10:15:43 * hackage tree-sitter-tsx 0.1.0.0 - Tree-sitter grammar/parser for TSX  https://hackage.haskell.org/package/tree-sitter-tsx-0.1.0.0 (patrick_thomson)
10:17:14 * hackage tree-sitter-haskell 0.1.0.0 - Tree-sitter grammar/parser for Haskell (with GHC extensions)  https://hackage.haskell.org/package/tree-sitter-haskell-0.1.0.0 (patrick_thomson)
10:18:14 * hackage tree-sitter-ruby 0.1.0.0, tree-sitter-python 0.1.0.0 (patrick_thomson): https://qbin.io/life-ks-wisz
10:19:48 <hololeap> i just whipped something up that works, so nvm
10:24:18 <infinisil> Hey, I have this data type that looks like `data Algorithm r = forall s . Algorithm (forall i . [i] -> Sem (State s ': r) i)`
10:25:04 <infinisil> Now I want to write a function like `runAlgorithm :: Algorithm r -> Sem r ()` (plus some output reporting)
10:25:45 <infinisil> Problem is, I can't really access the type `s` within the implementation easily
10:26:35 <infinisil> What I'm currently doing is something like `runAlgorithm (Algorithm f) = runAlgorithm' f  where runAlgorithm' :: (forall i . [i] -> Sem (State s ': r) i) -> Sem r ()`
10:27:14 * hackage tree-sitter-python 0.1.0.1 - Tree-sitter grammar/parser for Python  https://hackage.haskell.org/package/tree-sitter-python-0.1.0.1 (patrick_thomson)
10:27:51 <infinisil> Is there some way to get existential types into scope?
10:28:31 <infinisil> Such that I can use the algorithms payload directly?
10:29:07 <hyperisco> You'll only be able to use it if you don't care what it is, i.e. you need some  (forall s. s -> R)
10:29:27 <hyperisco> or  (forall s. State s -> R)  or whatever
10:30:21 <hyperisco> the variable will come into scope when you pattern match on Algorithm
10:30:21 <cocreature> infinisil: not atm, there is a GHC proposal for binding type variables in existential pattern matches. I don‚Äôt remember the status of it but I‚Äôm pretty sure it hasn‚Äôt made it into a released version of GHC so far
10:30:56 <cocreature> so for now, a separate helper definition is your best option
10:30:58 <infinisil> hyperisco: The type variable doesn't
10:31:08 <infinisil> cocreature: Ah good to know it's not just me then
10:31:23 <hyperisco> sure it does‚Ä¶ doesn't mean there is a way to refer to it though, lol
10:31:38 <infinisil> If something is in scope but you can't refer to it, is it really in scope?
10:31:51 <hyperisco> do lonely trees make noise?
10:32:31 * infinisil ponders
10:33:18 <infinisil> It's just a bit annoying, because actually my Algorithm type doesn't only have a single payload, but it's a record with 4 fields, each of them depending on s
10:33:25 <hololeap> is `Monad m => m (a -> b)` semantically the same as `Monad m => a -> m b`?
10:33:47 <infinisil> So I actually need to duplicate almost the whole types in the helper function
10:34:02 <cocreature> infinisil: https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0031-type-applications-in-patterns.rst 
10:34:06 <hyperisco> a helper definition‚Ä¶ so we can use type equality to make  s  equal to some other type variable we are able to refer to
10:35:58 <infinisil> cocreature: Nice thanks
10:36:23 <infinisil> hyperisco: Not sure what you mean to say by that
10:36:48 <hyperisco> Well, we know  s  comes into scope, because it is part of the type of  f  in the pattern  Algorithm f
10:36:59 <hyperisco> So then it is just a matter of extracting that variable from the type of  f
10:37:37 <infinisil> Oh it's merged :o
10:37:55 <cocreature> yeah but it hasn‚Äôt made it into a release afaik, probably 8.10
10:38:59 <infinisil> How would I see where this is implemented?
10:39:07 <infinisil> Or whether it's implemented at all
10:39:38 <cocreature> there is an "implemented" field at the top
10:39:59 <cocreature> which is empty so that means either someone forgot to update it or more likely it hasn‚Äôt been implemented :)
10:40:13 <infinisil> Gotcha
10:40:25 <infinisil> There is a ghc ticket
10:40:33 <cocreature> hololeap: no, consider a = String, b = (), m = IO. The second one could be putStrLn. you can‚Äôt implement putStrLn as IO (String -> ())
10:40:56 <hololeap> cocreature: thanks for the example
10:41:33 <hyperisco> :t asTypeOf
10:41:34 <lambdabot> a -> a -> a
10:41:45 <hyperisco> > top `asTypeOf` (0 :: Int)
10:41:47 <lambdabot>  error:
10:41:47 <lambdabot>      ‚Ä¢ Variable not in scope: top :: Int
10:41:47 <lambdabot>      ‚Ä¢ Perhaps you meant one of these:
10:41:53 <hyperisco> > maxBound `asTypeOf` (0 :: Int)
10:41:55 <lambdabot>  9223372036854775807
10:42:30 <hololeap> although... `putStrLn' (s :: String) (f :: IO (String -> ())) = f <*> pure s`
10:42:33 <hyperisco> infinisil, like that
10:43:28 <infinisil> hyperisco: I don't have s my scope though, so I can't do :: s
10:43:37 <infinisil> And I also don't know any value of s
10:43:41 <cocreature> hololeap: I‚Äôm not sure what you‚Äôre trying to demonstrate with that? That has type "String -> IO (String -> ()) -> IO ()" so it‚Äôs a completely different beast
10:43:44 <hyperisco> infinisil, you don't have to do  :: s  and yes you do, you have  f
10:44:58 <hyperisco> infinisil, you can constrain any value you want to have any type that is a function of s
10:46:26 <hyperisco> asTypeS :: s -> ([i] -> Sem (State s ': r) i) -> s  for example
10:46:40 <hyperisco> mySValue `asTypeS` f
10:47:06 <cocreature> so now you‚Äôre back to writing helper definitions
10:47:09 <hyperisco> if you want to get  s  as a type variable that is also possible
10:47:09 <infinisil> Yeah
10:47:19 <hyperisco> well yes, that is what I said, and acknowledged it is what you said oO
10:47:43 <infinisil> Yeah I guess that works, but it's not any more compact than my current helper function :)
10:49:33 <hyperisco> typeS :: ([i] -> Sem (State s ': r) i) -> Proxy s; typeS = Proxy
10:49:43 <hyperisco> typeS f :: Proxy s
10:50:06 <hyperisco> typeS _ = Proxy
10:50:42 <hyperisco> you can use a type family if really needed
10:51:13 <hyperisco> typeS :: a -> Proxy (GetTheS a)
10:51:52 <aveltras> anyone using vscode + ghcid + direnv ?
10:52:17 <aveltras> + ghcid extension in latest version
10:52:40 <infinisil> hyperisco: Yeah but again, I have multiple records in my type and each of them has an s in it, I'd have to write such a function for each
10:52:50 <hyperisco> just a type function
10:53:45 <infinisil> I already have only a single helper function which specifies each of its fields as a type
10:53:55 <infinisil> With a single forall s around all args
10:54:40 <hyperisco> okay, I don't know what else to suggest then
10:55:12 <dhun> Why does the following 4 line Programm need $ Gbyte of Ram? https://pastebin.com/SbDTyyUt
10:55:31 <dhun> oh I meant 4 gbyte of ram
10:55:44 <infinisil> hyperisco: Thanks anyways though
10:56:03 <hyperisco> the cost of loading lines of code into memory is usually not the problem
10:56:06 <glguy> dhun: Because you didn't compile it with optimizations
10:56:29 <dhun> which optimization do I need to use?
10:56:39 <glguy> You can turn them on with the -O flag
10:56:43 <dhun> I try bang pattern and unboxing but didn't help
10:56:45 <glguy> ghc -O ThatFile.hs
10:57:23 <dhun>  ghc --make test.hs -O didn't help
10:57:24 <cocreature> *sigh* I really wish `sum` wouldn‚Äôt leak space for basically all instances of Num without optimizations
10:58:12 <glguy> dhun: https://gist.github.com/glguy/d51ee3960957a7b940851109b98428e8
10:58:26 <blankhart> i want an efficient way to determine whether a set of regular expressions are compatible (i.e., there exists a string s matching each of them).  anyone seen anything like this?
10:59:17 <hyperisco> blankhart, intersect the languages then just take path through the DFA
10:59:21 <hyperisco> take any path
11:00:32 <koala_man> assuming it's a proper regular expression without backreferences and lookaheads/behinds
11:00:49 <hyperisco> oh, all bets off if we're not talking regular languages
11:00:51 <dhun> glguy: I got time real	0m7.100s thats really strange i3 4 GHhz 2 core
11:00:55 <blankhart> thank you hyperisco, i will study. yes proper.
11:03:58 <dhun> ghc --version : version 8.0.2
11:05:03 <hyperisco> or if you just want to know yes/no if there is such a string, you can just see if the DFA is empty or not after minimisation
11:05:41 <hyperisco> or test for equality with the empty language
11:07:18 <hyperisco> constructively though that just isn't as satisfying :P
11:08:47 <hyperisco> all regular languages are enumerable, so you can also check if the language is empty or not (and if not, you know a satisfying string) several options
11:11:17 <blankhart> cool, i get the idea. do you have a preferred reference?
11:11:45 <hyperisco> Hm, I think I just read Wikipedia for a reference on how to compute the intersection
11:12:30 <dhun> glduy: thanks anyway for yours ideas so far
11:12:31 <hyperisco> once upon a time I was working on a sane lexer that used proper regular language
11:12:33 <dhun> exit
11:15:45 <dhun> no I know what happend I just ghc didn't recompile because the output file was there and the source didn't change
11:15:57 <dhun> now everything works. Thank you
11:17:10 <cocreature> dhun: -fforce-recomp if you want to force recompilation.
11:17:35 <cocreature> dhun: newer versions of GHC will automatically recompile if you change the optimization level afaik
11:22:43 * hackage hsemail 2.1.0 - Parsec parsers for the RFC2822 Internet Message format  https://hackage.haskell.org/package/hsemail-2.1.0 (PeterSimons)
11:30:18 <dhun> now I again went one step close to the real world problem, an so the optimization seems to have stopped working see https://pastebin.com/cdLx0hgg
11:58:44 * hackage haskell-gi-base 0.22.2 - Foundation for libraries generated by haskell-gi  https://hackage.haskell.org/package/haskell-gi-base-0.22.2 (inaki)
11:59:44 * hackage haskell-gi 0.22.4 - Generate Haskell bindings for GObject Introspection capable libraries  https://hackage.haskell.org/package/haskell-gi-0.22.4 (inaki)
12:11:13 * hackage gi-wnck 3.0.5 - Wnck bindings  https://hackage.haskell.org/package/gi-wnck-3.0.5 (inaki)
12:12:13 * hackage gi-notify 0.7.19, gi-javascriptcore 4.0.19, gi-handy 0.0.4, gi-gtksource 3.0.20, gi-gtk 3.0.30, gi-gstvideo 1.0.20, gi-gsttag 1.0.19, gi-gstpbutils 1.0.19, gi-gstbase 1.0.20, gi-gstaudio 1.0.19, gi-gst 1.0.20, gi-gobject 2.0.20, gi-glib 2.0.21, gi-girepository 1.0.20, gi-gio 2.0.23, gi-ggit 1.0.6, gi-gdkx11 3.0.7, gi-gdkpixbuf 2.0.21, gi-gdk 3.0.20, gi-dbusmenugtk3 0.4.6, gi-dbusmenu 0.4.5, gi-cairo 1.0.21, gi-atk 2.0.19 (inaki)
12:13:13 * hackage gi-xlib 2.0.6, gi-webkit2webextension 4.0.22, gi-webkit2 4.0.23, gi-vte 2.91.23, gi-soup 2.4.20, gi-secret 0.0.9, gi-poppler 0.18.19, gi-pangocairo 1.0.21, gi-pango 1.0.20, gi-ostree 1.0.10 (inaki)
12:45:19 <gobby> Currently getting this error while building with stack `The program 'happy' is required but     it could not be found.`
12:46:12 <gobby> a dependency of `pretty-show`. Not sure why stack isn't getting the dep
12:54:34 <glguy> gobby: What resolver?
12:56:17 <gobby> glguy: lts-13.16
12:58:41 <glguy> gobby: Does this command work outside of a stack project? stack --resolver=lts-13.16 ghci --package pretty-show
13:08:44 <gobby> glguy: That worked
13:09:19 <gobby> glguy: I fixed it, pretty-show was being constrained to 1.8.2. Although I don't understand why it needed happy
13:43:44 * hackage registry-hedgehog 0.2.0.3 - utilities to work with Hedgehog generators and `registry`  https://hackage.haskell.org/package/registry-hedgehog-0.2.0.3 (etorreborre)
13:52:10 <edwardk> hrmm
13:52:24 <edwardk> it looks like pattern synonyms can make unboxed sums actually not suck to use
13:52:37 <edwardk> https://www.irccloud.com/pastebin/q083zgiS/tiny-parser.hs
13:52:57 <edwardk> i just went through the core that came out of that fmap and its the same as the other
13:53:11 <edwardk> pleasantly surprised
13:54:19 <infinisil> Compiling GHC from master with Nix.. Wish me luck
13:54:28 <edwardk> good luck!
13:54:50 <infinisil> :)
13:55:41 <edwardk> that code above will need a State# RealWorld threaded through it to actually work, but i think its viable
13:55:54 <__monty__> infinisil: I haven't succeeded getting ghcHEAD to work for me fwiw.
13:56:17 <infinisil> __monty__: Hm darn, did you get any clues as to why?
13:56:58 <__monty__> infinisil: Don't quite remember, think it had something to do with happy and cabal 2.4.0.1
13:57:21 <__monty__> Or the monadfail proposal or something.
13:57:40 <__monty__> It's probable it only happened because I was using ghcWithPackages though.
13:57:40 <infinisil> Well we have the logs here actually https://hydra.nixos.org/job/nixos/trunk-combined/nixpkgs.haskell.compiler.ghcHEAD.x86_64-linux
13:58:03 <infinisil> But I'm hoping just updating to the latest master version will fix it..
13:59:15 <infinisil> Ah yeah that is a happy error
13:59:47 <infinisil> A happy little error
14:02:33 <__monty__> infinisil: Why are you trying to build it btw? mpickering has a great nix expression to set up an environment to build ghc.
14:02:51 <infinisil> Oh neat, didn't know that
14:03:14 <infinisil> __monty__: I'd like to try out isovector's patch to see polysemy's full speed
14:04:03 <__monty__> Oh, it's actually alp's https://github.com/alpmestan/ghc.nix
14:04:30 <__monty__> mpickering made ghc-artefact.nix which can grab any ghc built by CI.
14:06:21 <infinisil> __monty__: Hm a shell won't be enough for me though, I need to use that GHC then to build dependencies and stuff trhough nix
14:07:00 <__monty__> infinisil: If CI built a ghc with that patch then this may help: https://github.com/mpickering/ghc-artefact-nix
14:07:54 <mpickering> There is also the very similar - https://github.com/mpickering/old-ghc-nix
14:09:44 <infinisil> Neat
14:10:04 <infinisil> I'll just try to build ghcHEAD the normal nixpkgs way for now
14:10:17 <infinisil> If I can fix the error I could also PR it
14:10:30 <infinisil> (if there is an error)
14:11:23 <infinisil> And if not I can open an issue with the error and ping some people :)
14:13:11 <solonarv> hololeap: no; to convice yourself of this, try turning 'm (a -> b)' into 'a -> m b' (easy) and vice versa (impossible)
14:13:20 <solonarv> (late reply, but perhaps still helpful)
14:14:32 <__monty__> infinisil: üëç 'd love a stable way to run ghcHEAD : )
14:23:43 * hackage hlint 2.1.24 - Source code suggestions  https://hackage.haskell.org/package/hlint-2.1.24 (NeilMitchell)
14:24:13 <edwardk> i'm sad, i'd hoped implicit params could have an unlifted type. nope.
14:24:26 <solonarv> :(
14:24:43 <edwardk> if so i had a really nice trick for performance
14:24:59 <solonarv> what about using a similar trick to 'reflection'?
14:29:28 <edwardk> solonarv: i figured out the trick
14:29:42 <edwardk> I've been using implicit parameters as better 'Given' constraints that can't go wrong
14:29:49 <edwardk> as you can't make classes depend on them
14:30:26 <edwardk> https://github.com/ekmett/codex/blob/master/watch-directory/src/Data/Watch/Directory.hs#L122
14:31:05 <edwardk> by combining this with francesco's "readert design pattern" i can remove basically all the state overhead from a larger application
14:31:05 <infinisil> __monty__: mpickering: It built successfully!
14:31:26 <edwardk> this is something i'm not sure i like the style of
14:31:28 <edwardk> just experimenting
14:32:14 <edwardk> but i was trying to see if i could make the parser i sketched above able to extract current position by pasing an implicit parameter for the base of the parse and getting it plumbed to the right place since very rarely in the parse do you use the 'pos' info
14:32:29 <edwardk> but i can't make ?base :: Addr#
14:32:34 <edwardk> so i have to box it and pass it as a Ptr ()
14:32:54 <edwardk> but i can make the use site open it with a case and get it in local context
14:34:23 <edwardk> basically i'm seeing if i can get a parser that is almost entirely unboxed that just needs the ptr to the current data and the length of what is left
14:34:35 <edwardk> no foreignptr like in a bytestring, etc.
14:34:48 <edwardk> so you'd flay open a bytestring with withForeignPtr and feed its guts to this
14:35:18 <dmwit> Think of the poor garbagemen whose job it is to collect up after the mess you leave behind!
14:36:12 <edwardk> nah, enough acid, and the goo that results are the sewage folks' job
14:40:47 <dmwit> Semi-seriously, though: if you're ripping the guts out of a ForeignPtr how the heck does GHC's garbage collector cope?
14:41:05 <dmwit> How can it know when to foreign collect that?
14:42:24 <dmwit> Okay, I answered my own question. At the top level you use withForeignPtr to get the Ptr to hand to your parser.
14:42:35 <edwardk> dmwit: a Foreignptr is two things, it is an Addr, and another structure that holds onto the finalizer and/or a pinned mutablebytearray#
14:42:51 <dmwit> When that withForeignPtr action is done you assume the parsing finished up with the guts.
14:42:52 <edwardk> as long as you withForeignPtr fp $ \p -> ... inside that body you can use the Addr# just fine
14:43:10 <dmwit> assume/assure
14:43:11 <edwardk> the parser here is just something that has to live inside that withForeignPtr block
14:43:15 <edwardk> yeah
14:43:45 <edwardk> this isn't the worst thing i've done to foreignptrs this week
14:44:01 <dmwit> If you even do it it seems downright benign.
14:44:07 <edwardk> sure
14:44:16 <dmwit> I just had forgotten what the interface to ForeignPtr's looked like.
14:44:33 <dmwit> I was thinking you were doing some manual constructor unwrapping.
14:44:37 <edwardk> the thing where i repurpose half of one foreignptr and another and frankenstein themtogether into another one to avoid using stableptrs to hold things alive is a much more serious hack ;)
14:44:52 <dmwit> But if the unwrapping is mediated by the library then it's easy to see how to cope.
14:45:18 <edwardk> https://github.com/ekmett/codex/blob/master/freetype/src/Graphics/FreeType.hsc#L459
14:45:28 <edwardk> that one i'm particularly proud of
14:45:42 <edwardk> the bytestrings i get usually are "PlainPtr"s which mean you can't attach finalizers to them
14:45:56 <edwardk> and i need to make sure they stay alive until the freetype face is freed
14:46:17 <edwardk> but i can't use the freetype "generic data" mechanism, because they free the damn thing before they go look in the data for parts!
14:46:50 <edwardk> i really want to make sure that the foreign ptr that i have managing the face keeps the bytestring alive. which i can totally do with a stableptr
14:46:56 <lavalike> :t (<&>)
14:46:58 <lambdabot> Functor f => f a -> (a -> b) -> f b
14:47:03 <edwardk> and then have the finalizer free the stableptr, but that is super slow
14:48:16 <edwardk> but what i can do is take the foreignptr from bytestring which has a MutableByteArray# associated with it for its backing store and no ability to attach finalizers and the one from my newForeignptr call and frankenstein together a new foreignptr with my address, but which claims to be a MallocForeignptr with my finalizers, and the bytestring's backing store.
14:48:24 <lavalike> what is the C.exp $foo:bar stuff?
14:48:27 <dmwit> Huh. Hackage doesn't have docs for GHC.ForeignPtr.
14:48:43 <dmwit> I always assumed that meant you couldn't import that module, but that seems not to be the case.
14:48:44 <edwardk> now holding either foreignptr alive enough to ensure the backing store of the bytestring doesn't get freed
14:49:03 <edwardk> nah it probably just has the haddock flag set for no docs/not-home or whatever
14:50:18 <dmwit> Man, there's all kinds of good stuff in these undocumented modules!
14:50:31 <edwardk> lavalike: its a combinator that i introduced in lens, which is nice to use because (\big -> do long lambda; with many parts) <$> something short .       is way uglier than something short <&> \big -> do long lambda; which i can now break up across lines
14:50:43 <edwardk> lavalike: you use it like >>= \big -> pure ...
14:51:11 <dmwit> edwardk: I think they're asking about the TH a few lines up in your link.
14:51:25 <dmwit> Or QQ or whatever. I can never keep those straight.
14:51:37 <edwardk> lavalike: the C.exp stuff is inline-c which is a library by bitonic which makes it easy to write c FFI
14:52:14 <edwardk> lavalike: basically [C.exp|some c type { some c expression }|]  -- lets me execute a snippet of c source without explicit FFI
14:52:50 <edwardk> [C.block|void { foo(); bar(x,y,z); baz(); }|] can execute a whole block of code
14:52:56 <lavalike> so $library:library is a C expression?
14:53:11 <edwardk> $library:library is a trick to use a custom quasiquoter to marshal that library variable from haskell
14:53:45 <edwardk> $(some c type haskellvariable) sends the haskell variable over as a given c data type using a mapping between c types and haskell types you supplied when creating the C.context line way early in the module
14:54:15 <edwardk> $someantiquoter:x    lets you specify a custom anti-quotation mechanism
14:54:19 <edwardk> in this case it turns that into
14:55:06 <edwardk> withForeignPtr (coerce library) $ \plibrary ->    around the call itself, and pasing plibrary as if it was a $(FT_Library plibrary) splice
14:55:22 <lavalike> cool
14:55:27 <edwardk> where FT_Library    is a c type synonym for struct FT_LibraryRec_ *
14:55:29 <lavalike> never seen that before; I'm about to embark into a journey to write some FFI (possibly) so I'm intrigued
14:55:34 <edwardk> way shorter to say $library:library
14:55:54 <edwardk> but i have to set up an index of those types in an internal module before this
14:56:17 <edwardk> https://github.com/ekmett/codex/blob/master/freetype/raw/Graphics/FreeType/Internal.hsc#L755
14:56:23 <edwardk> is me setting up that antiquoter
14:56:33 <lavalike> I see
14:56:45 <edwardk> https://github.com/ekmett/codex/blob/master/freetype/raw/Graphics/FreeType/Private.hs#L29 is the combinator that i use there
14:57:17 <edwardk> it makes an implementation of the antiquoter type that bitonic has in inline-c for a given c type, given haskell equivalent and given withWhatever equivalent
14:57:41 <edwardk> he offers a generic antiquoter that lets me do somehting like
14:57:52 <edwardk> $fptr-ptr:(FT_Library library) -- but that is more verbose =)
14:58:12 <lavalike> (:
14:58:20 <masaeedu[m]> does it make sense to have invariant mfunctor instances for various things?
14:58:45 <masaeedu[m]> for example cont is not a covariant mfunctor, but it could be an invariant mfunctor
14:59:04 * masaeedu[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/akAtMchgRPSoJzLLNkaWleFt >
14:59:49 <edwardk> mfunctor?
14:59:56 <masaeedu[m]> which i think satisfies the functor laws (mapping the identity natural isomorphism is an identity natural transformation, mapping the composition of two natural isomorphisms is equivalent to the composition of mapping each isomorphism)
15:00:26 <masaeedu[m]> sorry, these things
15:00:27 <edwardk> you mean a functor in the category of monads on haskell like a monad transformer that you can map out the base of as long as you have an isomorphism?
15:00:31 <masaeedu[m]> https://hackage.haskell.org/package/mmorph-1.1.3/docs/Control-Monad-Morph.html
15:00:35 <edwardk> yeah
15:00:38 <edwardk> figured that out after
15:00:46 <masaeedu[m]> that's right, yes
15:01:20 <edwardk> that package is somewhat busted, IIRC, as it doesn't include the Monad m :- Monad (t m) notion, which is why so many of the combinators are a bit crippled
15:01:29 <edwardk> i gave a talk on the topic at zurihac a couple years back
15:01:50 <edwardk> IIRC you can see it by trying to define
15:01:54 <masaeedu[m]> i opened an issue about quantified constraints earlier, i think Gabriel doesn't want that for compatibility reasons
15:02:06 <edwardk> newtype Tensor s t m = Tensor (s (t m) a)
15:02:13 <edwardk> yeah, which is enough to stop me from thinking about the library ;)
15:02:30 <edwardk> he can be compatible with his existing users, i just won't be one
15:02:41 <masaeedu[m]> ok, do you know of any better ones?
15:02:51 <masaeedu[m]> imo the idea is good enough that the instances should be in base
15:03:05 <edwardk> i don't have one packaged, though you can use Lifting Monad in constraints to cover part of it
15:03:05 <masaeedu[m]> the "return" is already there in the form of `MonadTrans`
15:03:20 <solonarv> that's not in base
15:03:26 <solonarv> it's in transformers
15:03:45 <solonarv> (which does ship with GHC, so I suppose that's pretty close to being in base)
15:04:04 <edwardk> we moved MonadIO into base, not MonadTrans
15:04:07 <masaeedu[m]> whoops, sorry. wherever the transformers themselves are defined, not in base
15:05:26 <edwardk> basically you can think the thought about mfunctors, etc. just keep the Lifting Monad t constraint around when you get stuck and assume it should morally be a superclass or part of MonadTrans
15:06:03 <edwardk> ok, back to unboxed parsing
15:06:17 <masaeedu[m]> i'm not familiar with the `Lifting Monad t` constraint you're referring to
15:06:52 <masaeedu[m]> isn't something like `class (forall m. Monad m => Monad (t m)) MFunctor t where` enough?
15:07:20 <edwardk> that's what the quantified constraints version would be
15:07:28 <masaeedu[m]> sorry btw, didn't mean to intrude if you were having a different conversation. we can drop this
15:07:31 <edwardk> Lifting is just the manual version from before quantified constraints went in
15:07:48 <edwardk> if quantified constraints actually worked, i'd use your version ;)
15:08:37 <masaeedu[m]> interesting, i wasn't aware there was anything wrong with quantified constraints. do you have any pointers to where i can read about this?
15:08:47 <edwardk> consider something like
15:08:57 <edwardk> instance Show a => Show [a]
15:09:22 <edwardk> now work with some kind of constraint like (forall a. Show a => Show (f (f a)))
15:09:38 <edwardk> the former when self-composed matches the latter
15:09:52 <edwardk> but they get used as if they are normal instances or classes, not compositions of them
15:10:06 <edwardk> so the lack of backtracking, etc. is actually a way to easily get in blind alleys
15:10:20 <edwardk> there is a sort of category error in how they are handled in the compiler
15:10:48 <edwardk> i had one example come up when i did a twitch stream on authenticated computation
15:11:56 <edwardk> i remember now
15:12:26 <edwardk> class ( forall a. Evident t (t a) , forall a. (Show a, Read a) => Evident t a) => Authentic t where .  -- was the original example
15:12:31 <edwardk> that doesn't work for 2-3 reasons
15:12:42 <edwardk> Evident t needs to be replaced with a non-type synonym to make it actually reduce
15:12:52 <edwardk> er with a non-type family
15:13:14 * hackage tptp 0.1.0.3 - A parser and a pretty printer for the TPTP language  https://hackage.haskell.org/package/tptp-0.1.0.3 (EK)
15:13:34 <edwardk> (forall s. s ~ Evident t, forall a.  s (t a), forall a. (Show a, Read a) => s a) => Authentic t where -- would be a head i'd expect to reduce better
15:13:49 <edwardk> but those two right hand sides .   s a          and s (t a) overlap
15:13:53 <masaeedu[m]> hmm
15:13:55 <edwardk> but the instances they come from are all sound
15:14:01 <masaeedu[m]> but does this apply to monad transformers, which are invariably newtypes?
15:14:07 <edwardk> quantified constraints get confused
15:14:10 <masaeedu[m]> or am i misunderstanding the example?
15:14:13 * hackage webdriver 0.9.0.1 - a Haskell client for the Selenium WebDriver protocol  https://hackage.haskell.org/package/webdriver-0.9.0.1 (AdamCurtis)
15:14:26 <edwardk> you're misunderstanding the issue
15:14:42 <masaeedu[m]> (newtypes as opposed to type synonym)
15:14:45 <edwardk> the issue is about when you need multiple quantified constraints with overlapping "heads" because they shouldn't have "heads" in the classical sense
15:14:48 <masaeedu[m]> ok, i guess i need to play around with your example to understand it
15:15:32 <edwardk> https://github.com/ekmett/auth/blob/master/old/src/Auth.hs#L37 i think is the variant of the auth code that i switched to manual dictionary manipulation when quantified constraints puked
15:16:00 <edwardk> the main branch is now using a thing where i lie and say that Evident a = (Show a, Read a) -- all the time
15:16:04 <edwardk> but that is a lie
15:16:51 <edwardk> on one side, the verifier, it is, but on the prover it is only show
15:17:14 <edwardk> this is important because i can "show" proof, but not "read" proof
15:18:20 <edwardk> but all those https://github.com/ekmett/auth/blob/master/old/src/Auth.hs#L46 like lines are morally unnecessary if i can get quantified constraints to work
15:21:05 <masaeedu[m]> so is this salvageable, or should we just not use quantified constraints?
15:21:34 <masaeedu[m]> i've only been using it lightly, and haven't run into these situations (although I admit I'm still trying to wrap my head around reasons 2 and 3 you've outlined)
15:22:30 <masaeedu[m]> for the most part specifically to model this mfunctor business, where it comes in pretty handy
15:22:41 <edwardk> i basically ignore them for, unless i have simple usecases
15:23:14 <edwardk> been using them for zero-overhead Const ptrs
15:23:15 <edwardk> https://github.com/ekmett/codex/blob/master/const/src/Data/Const/Unsafe.hs#L75
15:24:04 <edwardk> because i use the quantified constraint there to let me just coerce the operations from the normal type to the 'possibly const' version.
15:24:05 <edwardk> https://github.com/ekmett/codex/blob/master/const/src/Foreign/Const/Ptr.hs#L52
15:24:22 <edwardk> no eta expansion from composing with the newype wrappers/unwrappers
15:24:48 <edwardk> means even if the optimizer goes out to lunch it still turns out nice
15:25:31 <monochrom> That's some progressive labour movement if you let the compiler go out to lunch. :)
15:26:18 <edwardk> if you worked as a compiler, you'd understand ;)
15:38:07 <a__> can someone help me figure out what's up with the return type in this function: f :: TL.Text -> (TypeOne TypeTwo (), [TypeThree ()]) Is it a tuple where the first element can be a TypeOne or a TypeTwo?
15:40:03 <monochrom> At the outer level it's a tuple.
15:40:24 <solonarv> however the first element is not "a TypeOne or a TypeTwo"
15:40:37 <monochrom> Wihtout further information it is anyone's guess what "TypeOne TypeTwo ()" models.
15:41:01 <solonarv> well, there is no way it means "a TypeOne or a TypeTwo", because that's a kind error
15:41:20 <monochrom> Apart from the tautological: TypeOne is parametrized by two parameters, and someone decided to use TypeTwo for the 1st type parameter, () for the 2nd.
15:43:28 <a__> monochrom: ah that makes sense thanks for your help!
16:07:59 <Zer000> How can I add {-# INLINE <> -#} for an infix operator definition? Literally, this throws a parse error
16:10:45 <iqubic> Try {-# INLINE (<>) -#}
16:11:04 <iqubic> add brackets around the operator
16:12:42 <Zer000> Thanks, I'll try that
16:14:32 <iqubic> by brackets, I mean parentheses.
16:15:05 <Zer000> iqubic, thanks, I had an indentation syntax error as well so I originally didn't think (<>) would work, but it seems to be building
16:16:51 <iqubic> Then it look like it has worked.
16:20:42 <jle`> phadej: thank you for releasing a new these with the lenses split off :)
17:15:54 <edwardk> someone in here a few weeks ago was asking me about issues with magicDict
17:16:05 <edwardk> it turns out magicDict's rule in core is hardcoded to the number of arguments
17:16:10 <edwardk> that is why it wasn't working for them
17:16:18 <edwardk> i went to use it for a custom form of reflection just now
17:18:24 <edwardk> i was able to hack it with a Proxy# though, so it didn't waste anything
17:20:37 <Axman6>  /grep tells me it could have been mniip
17:21:07 <edwardk> might also have been in #qfpl or something, i remember whomever it was was surprised that i had something to do with reflection
17:31:44 * hackage tracing 0.0.3.0 - Distributed tracing  https://hackage.haskell.org/package/tracing-0.0.3.0 (mtth)
18:23:05 <edwardk> https://github.com/ekmett/codex/blob/master/parsnip/old/Sum.hs is my work in progress
18:23:07 <edwardk> it actually works
18:23:45 <edwardk> the fewest moving parts i can ask for
18:23:50 <edwardk> its a parser where the state is a pointer
18:24:07 <edwardk> and an unboxed sum result that is whether it succeded
18:27:31 <dolio> I can't believe no one came up with that name before.
18:27:55 <edwardk> hah
18:29:04 <edwardk> wanted something for the ghc trac at zurihac
18:29:39 <edwardk> this should simplify the parser in parsnip which i'm using in my toy graphics enginy thing here for some silly include parsing
18:30:14 <edwardk> i previously had so much state. an address and a length.
18:30:29 <edwardk> now the length/end of the storage gets pushed around by reflection
18:30:55 <edwardk> and none of the monad operations, etc. ever touch it, so the compiler is free to lift it out because its buried on the left of a =>
18:31:38 <edwardk> will benchmark once i bring the rest of parsnip in
18:34:07 <sm[m]> gobby: pretty-show needed the happy tool installed in $PATH. This is something stack doesn't handle for you
18:34:19 <ShYGirl99> Hello. I am new and I decided to try making a Live in a Cam site. Hope you will like my idea. The idea of being watched makes me really horny. Enter now: https://bitlylink.com/f4Bui
18:37:53 <kmb> Can someone help me understand the 'try' function in the Parsing typeclass used by Text.Trifecta? I can't understand what it does, and I have not been able to find documentation for it
18:43:47 <Xaurx> hello
18:43:59 <Xaurx> is anyone here
18:44:10 <Xaurx> @chanserv
18:44:10 <lambdabot> Unknown command, try @list
18:44:14 <Xaurx> @list
18:44:15 <lambdabot> What module?  Try @listmodules for some ideas.
18:44:22 <Xaurx> @listmodules
18:44:22 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
18:44:22 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
18:44:30 <Axman6> Xaurx: stop
18:44:39 <Xaurx> c
18:44:45 <Xaurx> @listmodules
18:44:45 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search
18:44:45 <lambdabot> slap source spell system tell ticker todo topic type undo unlambda unmtl version where
18:45:22 <Axman6> koala_man: generally, if you want to use trifecta, you should use it via the parsers library
18:45:44 <Axman6> uh, kmb, who's left -_- sorry koala_man
18:50:13 * hackage hw-balancedparens 0.2.1.0 - Balanced parentheses  https://hackage.haskell.org/package/hw-balancedparens-0.2.1.0 (haskellworks)
19:09:44 * hackage hmatrix-gsl-stats 0.4.1.8 - GSL Statistics interface  https://hackage.haskell.org/package/hmatrix-gsl-stats-0.4.1.8 (VivianMcPhail)
19:32:44 * hackage conduit-vfs 0.1.0.0 - Virtual file system for Conduit; disk, pure, and in-memory impls.  https://hackage.haskell.org/package/conduit-vfs-0.1.0.0 (RobertFischer)
19:35:45 * hackage conduit-vfs 0.1.0.1 - Virtual file system for Conduit; disk, pure, and in-memory impls.  https://hackage.haskell.org/package/conduit-vfs-0.1.0.1 (RobertFischer)
19:38:14 * hackage conduit-vfs 0.1.0.2 - Virtual file system for Conduit; disk, pure, and in-memory impls.  https://hackage.haskell.org/package/conduit-vfs-0.1.0.2 (RobertFischer)
19:52:42 <qwebirc23716> Where do I find the dependencies needed to install and run haskell-platform
19:53:50 <maerwald> qwebirc23716: g++ gcc gmp make ncurses python3
19:54:02 <maerwald> may also need libffi
19:55:43 <maerwald> https://gitlab.haskell.org/haskell/ghcup/blob/master/.requirements/ghc/default this is a lazy list (lol) and this is more comprehensive but includes building https://gitlab.haskell.org/ghc/ghc/wikis/building/preparation/linux
20:05:29 <monochrom> You forgot curl
20:06:33 <monochrom> I guess a couple others too and probably intentional, so nevermind!
20:10:40 <qwebirc507> Following commands are required, but missing, please install:  xz
20:11:04 <monochrom> Yeah that would be xz-util on the "lazy list".
20:11:46 <maerwald> Luckily, every distro has a slightly different name :)
20:24:28 <glguy> maerwald: Does mac actually need a separate xz command? Does /usr/bin/tar use that?
20:30:56 <maerwald> glguy: https://gitlab.haskell.org/haskell/ghcup/issues/97
20:31:16 <maerwald> I don't run mac, so no one provided a PR. Mac-specific unpacking is doable
20:35:02 <glguy> As far as I'm aware the built-in tar supports xz on its own. I'll have to test a bit and get back to you with a PR
20:35:57 <glguy> so unpacking the official bindist was just: tar xf ghc*.tar.xz
20:36:50 <maerwald> https://gitlab.haskell.org/haskell/ghcup/blob/master/ghcup#L1015 then utilise the output of $(get_distro_alias "$(get_distro_name)")
20:37:06 <hololeap> i'm having a hard time grokking how to use existential types. for instance, i don't understand why this fails to compile: http://dpaste.com/3VTQYFS
20:37:20 <glguy> maerwald: I don't use a separate xz command when I install ghc on linux, either
20:38:49 <maerwald> glguy: possibly, but not in POSIX afaik https://pubs.opengroup.org/onlinepubs/007908799/xcu/tar.html
20:38:53 <maerwald> so might break on freebsd or whatnot
20:39:25 <maerwald> even ubuntu sometimes ships overly posix things
20:45:31 <glguy> hololeap: Are you trying to shadow n in ObjectStore?
20:47:18 <hololeap> i'm not sure what you mean by shadow. i agree that using the same type variable inside the function is confusing. i tried changing it to (forall s. ...), but it didn't change anything
20:47:46 <glguy> you're redefining n in that definition and it isn't clear what the goal of the code is, so it's hard to recommend the right fix
20:49:46 <hololeap> essentially, i have different "objects" which are tagged using a Symbol. these objects contain a store of internal objects which use different tags. i'm trying to implement it using a DMap with a KnownSymbol as the key
20:50:31 <hololeap> i was trying to reproduce the error i was running into with the minimum amount of code
20:51:10 <Nukeops> hello
20:51:17 <hololeap> so, the ObjectStore resides in an Object, and both share the same ObjectName. the ObjectStore contains more Objects with arbitrary ObjectNames
20:52:10 <Nukeops> how to see when user registred on irc?
20:52:30 <hololeap> the NameProxy idea was given to me in #reflex, when i asked how to create a DMap which is keyed by Symbols
20:53:32 <hololeap> but i need to be able to insert new Objects into the ObjectStore
20:54:20 <hololeap> another major reason why i am using DMap is because i need to use the `fan` function in the reflex library
20:55:43 <hololeap> i renamed some of the type variables here, to be less confusing: http://dpaste.com/3WRVBZ1
20:57:31 <hololeap> the reason for tagging everything with a Symbol, is that i am passing around lots of Floats and other types, which need to be owned by an Object and not interchangable with other Objects.
20:58:30 <glguy> hololeap: did you just want: data ObjectStore (n :: ObjectName) t m = forall s. KnownSymbol s => ObjectStore (DMap (NameProxy (Object s t m)) Identity)
20:59:15 <hololeap> glguy: is that different than what i have semantically?
20:59:18 <glguy> yes
20:59:57 <hololeap> maybe i should just stick to defining it with a GADT
21:01:05 <hololeap> so, what exactly did i create with my ObjectStore, and how is your ObjectStore different?
21:09:43 <hololeap> i'm mostly curious as to what the type that i created means semantically. i get that what glguy made is a proper existential type
21:10:27 <glguy> What you wrote says that the value contained in the ObjectStore will work for any symbol a user might want
21:11:02 <glguy> What I wrote says the value in the ObjectStore will only work with some hidden symbol and the only thing you know about that symbol is that it's an instance of KnownSymbol
21:12:24 <hololeap> alrighty. i wish there was different syntax for existential types. the forall before the constructor isn't that clear
21:12:54 <glguy> You can use the GADT syntax you used earlier in the file
21:13:21 <glguy> NameProxy also uses an existentially quantified variable
21:20:08 <isovector1> anyone know what's going on with data-reify?
21:25:39 <jle`> hm, has there been some recent news on it?
21:26:12 <isovector1> no, just trying to wrap my mind around writing an instance
21:26:31 <jle`> ah
21:26:47 <jle`> my go-to example reference for that library has been ad
21:27:07 <isovector1> in particular, given `instance MuRef Foo`, i want `instance MuRef [Foo]`
21:27:42 <isovector1> where `DeRef [Foo] = Compose [] (DeRef Foo)`
21:29:23 <jle`> any troubles writing a typechekcing mapDeRef ?
21:30:22 <isovector1> all sorts
21:30:40 <isovector1> the existential `u` is doing my head in
21:31:17 <jle`> afaik the u is not existential, it's universal
21:31:20 <jle`> right?
21:31:30 <jle`> it seems to have the same role as 'b' in the type of traverse
21:31:31 <jle`> :t traverse
21:31:33 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
21:32:21 <isovector1> you might be right
21:32:40 <jle`> the implementation here seems to be very similar to an implementation of traverse
21:32:41 <jle`> https://github.com/ekmett/ad/blob/c3d9599030f7e4793896013c69ab6b19ce403906/src/Numeric/AD/Internal/Kahn.hs#L87
21:32:51 <isovector1> think i can call mapDeRef @Foo in the def of mapDeRef @[Foo]?
21:33:35 <jle`> yeah, you would need to pass in the mapping function, but probably pre-mapped
21:33:41 <jle`> or traversed
21:34:49 <hololeap> lets say you have an existential type  data Foo = forall b. Bar b => Foo b
21:35:13 <hololeap> in order to use it, do you always have to set up a function like withFoo, or is that just a convenience?
21:35:33 <hololeap> withFoo :: (forall b. Bar b => b -> r) -> Foo -> r
21:36:22 <isovector1> hololeap: yeah, you always do
21:36:32 <isovector1> well, i guess you can pattern match on it somewhere else
21:36:35 <jle`> well, in order to use it, you'd have to pattern match
21:36:40 <jle`> in fact pattern matching is how you'd implement withFoo
21:37:17 <isovector1> jle`: it's late so maybe my brain isn't working. but i think the constraints `(forall b. (MuRef b, DeRef a ~ DeRef b) => b -> f u) ` mean I can't just pass this func as a mapDeRef to someone else
21:38:55 <isovector1> alternatively, i'm trying to write a monad in which i can observe sharing
21:39:02 <isovector1> if this is already a solved problem that's good enough for me
21:39:24 <jle`> i do some observable sharing with my backprop library, which is also similar to one of the ad methods
21:39:55 <jle`> i think data-reify basically does the same thing too
21:40:51 <isovector1> yeah it does
21:41:04 <isovector1> i am trying to hack hylogen into being a c code generator
21:41:32 <isovector1> right now it produces great shareable expressions -- hoping to get it to also be able to generate statements
21:41:52 <jle`> the main idea is just to do pull out a unique id for every binding
21:42:45 <isovector1> oh DANG i need to do that in my other project too. been searching for a solution
21:43:19 <jle`> overall the method is to have your actions be in some ReaderT (IORef BindingMap) IO
21:44:04 <jle`> but using reflections you can fake it, to be thing :: Reifies s BindingMap => .. -> .. -> IO (Binding s) 
21:45:01 <jle`> er sorry, Reifies s (IORef BindingMap) => ... -> IO (Binding s)
21:45:18 <isovector1> this stuff makes my brain hurt
21:45:24 <isovector1> maybe i should stop cargo culting and dig into it properly
21:45:57 <isovector1> also: not even liberal uses of unsafeCoerce will convince ghc to let me use my `mapDeRef`'d func as a call to another `mapDeRef`
21:46:20 <jle`> let me see if i can write your lifty mutref instance
21:46:36 <isovector1> i would love you forever
21:46:58 <isovector1> i've been bashing my head against this for a few hours now
21:47:45 <jle`> perhaps i have just been elegantly nerdsniped
21:50:13 <isovector1> this is the last big piece before i can generate arduino programs with free monads :)
21:50:32 <jle`> :O
21:51:13 <isovector1> i want to add a state machine to some arduino thing, and the thought of doing that in C made me sad... thus this
22:00:50 <iqubic> I just got a Raspberry Pi.
22:01:33 <iqubic> I'm hoping I can write a FFI interface to the library that manipulates the various pins I have on the Pi's board.
22:03:27 <jle`> isovector1: i got one that typechecked, but there is a somewhat questionable choice i made
22:03:36 <isovector1> jle`: hit me
22:04:01 <isovector1> it's not "push the thing into the `[]` functor and then just call yourself recursively on it" is it?
22:05:46 <jle`> https://gist.github.com/mstksg/13919be0176a82d64699ce5c34df3e28
22:06:03 <jle`> i'm also not 100% sure that Compose [] (DeRef a) is right
22:06:18 <isovector1> yeah looks pretty questionable to me
22:06:23 <isovector1> i am reasonably sure this is bottom?
22:06:32 <jle`> hm, why would it be bottom?
22:06:35 <jle`> there is no recursive call anywhere
22:07:00 <isovector1> sure there is --- you're calling `mapDeRef @[b]` from `mapDeRef @[b]`
22:07:14 <isovector1> oh are you not?
22:07:16 <jle`> i'm calling mapDeRef @a
22:07:26 <isovector1> interesting.
22:07:30 <isovector1> let me give it a go and see what happens
22:17:40 <isovector1> jle`: thanks! i think it works --- though the next step is just as inscrutable to me
22:17:42 <isovector1> maybe it's time to sleep
22:18:30 <isovector1> mind doing a quick sanity check for me before i do?
22:19:26 <jle`> assuming i can answer the question :)
22:19:29 <isovector1> i have some things of the form `Expr a`, where `a` is a phantom type + some singleton magic to turn it into the string name of a c type.
22:20:02 <isovector1> eg `Expr Int` maps to `int` in C. I have a num instance for `Expr Int` that just glues strings together to make a c expr that would do the addition
22:20:30 <isovector1> i can successfully turn an `Expr Int` into the C string via my `MuRep Foo` instance. 
22:21:45 * hackage hw-balancedparens 0.2.2.0 - Balanced parentheses  https://hackage.haskell.org/package/hw-balancedparens-0.2.2.0 (haskellworks)
22:21:45 <isovector1> but this corresponds to a single value in C. now i want to model statements, so i was thinking i could do something stupid and just take `[Expr a]`s and do the same logic, ideally preserving sharing for all of their subexprs
22:22:17 <isovector1> in particular i want to model things of the form `fiddleMyPointers(&something)`
22:23:48 <isovector1> such a thing needs to be run in a deterministic time relative to other statements/ let bindings in the c source; otherwise i'd just stick it into the sharing dependency graph i already have that works
22:24:20 <isovector1> SO the question: does it make sense to try to murep `[Expr a]`s, or am i doing something obviously stupid here
22:25:42 <jle`> hm, i think it depends on what you want to do with the sharing in general. i'm not familiar/comfortable enough to give solid advice here
22:26:59 <isovector1> fair enough
22:27:05 <isovector1> anyway, thanks for the instance
22:33:05 <MarcelineVQ> isovector1: think you'd be aware of this but linking anyway http://okmij.org/ftp/tagless-final/sharing/index.html Probably not relevant to your task immediately but relevant in general
22:33:13 <MarcelineVQ> you left, why did you left
22:58:40 <Mrbuck> I am banned in Hskell offtopic I got a offtopic now
23:05:13 <MarcelineVQ> if you have an on-topic this is a good spot for it
23:05:49 <Mrbuck> MarcelineVQ:  I have some off topic question but rlated to technology
23:06:24 <Mrbuck> I got banned in offtopic many months back for some debate and nsulting some guy I think
23:06:32 <glguy> Mrbuck: Then you'll need to find a different channel to ask your questions
23:07:07 <Mrbuck> glguy:  i need to be unbanned in haskell-offtopic I am not sure what is clear reason too
23:07:56 <Mrbuck> I am assuming I had fight with welkins or some one over some language war
23:08:35 <glguy> It doesn't matter, this isn't the channel to figure out it out. You'll need to work with the op that originally banned you if you want to chat in #haskell-offtopic
23:08:50 <Mrbuck> okay leeave it
23:10:28 <Mrbuck> Okay this is my question what are some cool startup ideas one can start with haskell in particular if not using any stack
23:10:44 * hackage registry 0.1.6.1 - data structure for assembling components  https://hackage.haskell.org/package/registry-0.1.6.1 (etorreborre)
23:17:23 <Mrbuck> foolish question ?
23:19:15 <Axman6> yes
23:20:16 <Axman6> that is not how startups should start. you think of a problem that needs solving and use the right tools for that job. "I'm going to start a startup and use Haskell" is doing things completely backwards
23:20:40 <MarcelineVQ> he left after asking
23:21:30 <MarcelineVQ> a more general answer for things like that is "just tacking haskell onto a question doesn't make it a haskell question"
23:21:51 <Axman6> -_-
23:27:31 <nshepperd> all great startups begin with asking a question in a chat room then leaving before anyone can respond
23:31:37 <MarcelineVQ> You guys wanna make a startup together? I'm thinking the logo should be a pink pear but the stem is a lambda symbol. I'm not sure about the rest of it but it should be fine.
23:36:05 <nshepperd> excellent idea
23:36:41 <nshepperd> it'll be a food delivery company that exclusively uses those galois inc drones to deliver fresh fruits and vegetables, mainly pears
23:39:25 <MarcelineVQ> I'm not feeling the food angle, let's 3d print concrete castles on mountaintops
23:40:03 <MarcelineVQ> Think about it. They're not making more of those.
23:41:01 <MarcelineVQ> castles or mountaintops. it's double-rarity
23:51:48 <tdammers> point in case, finding a problem that allows you to play your strengths isn't necessarily a dumb idea
23:52:29 <tdammers> I'm totally down for 3D-printing castles though
23:52:37 <tdammers> or mountains, for that matter
23:58:44 <phadej> jle`: you are welcome
