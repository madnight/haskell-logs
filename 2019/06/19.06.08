00:07:41 <jle`> nshepperd: ah, that's interesting
00:07:51 <jle`> definitely as scary and unsafe as i had hoped
00:10:13 * hackage rg 1.4.0.0 - A dynamic/unbounded alternative to Bounded Enum  https://hackage.haskell.org/package/rg-1.4.0.0 (ChrisDornan)
00:14:30 <jle`> nshepperd: actually that line of thinking lead me to some code in the constraints library that did exactly what i was looking to do
00:14:31 <jle`> https://hackage.haskell.org/package/constraints-0.11/docs/Data-Constraint-Unsafe.html
00:14:40 <jle`> as usual an edwardk library already implemented the functionality
01:17:02 <Mo0O> Hi there
01:18:21 <Mo0O> Do you know if there's something to split shell command string ? like `sh -c "ls -la"` -> ["sh", "-c", "ls -la"]
01:27:18 <Mo0O> I've found this one https://hackage.haskell.org/package/Cabal-2.4.1.0/docs/Distribution-Simple-Setup.html#v:splitArgs
01:31:28 <maerwald> You don't want to depend on Cabal :P
01:33:02 <maerwald> @hackage cmdargs
01:33:02 <lambdabot> http://hackage.haskell.org/package/cmdargs
01:33:06 <maerwald> maybe that has something
01:43:13 * hackage network-simple 0.4.4 - Simple network sockets usage patterns.  https://hackage.haskell.org/package/network-simple-0.4.4 (RenzoCarbonara)
02:06:15 <jellyb> hello, is haskell from first principles recommended for beginners?
03:23:44 * hackage haskell-gi-base 0.22.1 - Foundation for libraries generated by haskell-gi  https://hackage.haskell.org/package/haskell-gi-base-0.22.1 (inaki)
03:23:59 <tdammers> jellyb: I have heard only good things about it, so I'd go with a resounding "yes"
04:06:13 * hackage gi-atk 2.0.18 - Atk bindings  https://hackage.haskell.org/package/gi-atk-2.0.18 (inaki)
04:06:32 <atk> hmm
04:06:36 <atk> I have bindings?
04:07:14 <hackage> ACTION gi-xlib 2.0.5, gi-wnck 3.0.4, gi-webkit2webextension 4.0.21, gi-webkit2 4.0.22, gi-vte 2.91.22, gi-soup 2.4.19, gi-secret 0.0.8, gi-poppler 0.18.18, gi-pangocairo 1.0.20, gi-pango 1.0.19, gi-ostree 1.0.9, gi-notify 0.7.18, gi-javascriptcore 4.0.18, gi-handy 0.0.3, gi-gtksource 3.0.19, gi-gtk 3.0.29, gi-gstvideo 1.0.19, gi-gsttag 1.0.18, gi-gstpbutils 1.0.18, gi-gstbase 1.0.19, gi-gstaudio 1.0.18, gi-gst 1.0.19, gi-gobject 2.0.19, gi-glib 2.0.20,
04:11:18 <Rembane> atk: you do, now you can program yourself in Haskell.
04:11:27 <atk> But I don't know Haskell.
04:16:55 <Rembane> atk: this will make the programming much harder.
05:07:39 <Amras> This is a question about category theory more than haskell, but this still feels like the best place to ask.
05:07:39 <Amras> http://conal.net/papers/essence-of-ad/essence-of-ad-icfp.pdf on page 9 of this paper, there's a Monoidal class definition and associated instance, containing a single morphism (in this case called ×). My (admittedly very limited) understanding of monoidal categories is that the monoidal morphism should be accompanied by an identity object I such that I×A ~ A. 
05:07:39 <Amras> My initial thought is that since no such identity is explicitly specified, it is somehow derivable from the Category class's definition - or else trivial to find for the instances talked about in the paper.
05:07:41 <Amras> That said, I am struggling to find a good identity candidate even for the example Monoidal (→) instance. For a start, if we type `f::a→b`, `I::c→d`, then `f×I::(a,c)→(b,d)` doesn't seem to want to "relate" to `f` in any reasonable measure whatever specific types I choose.
05:07:45 <Amras> So: am I misunderstanding the definition of Monoidal Categories? Is there a trivial identity that I've missed here? Or is the identity derivable from Category, perhaps from id?
05:20:42 <phadej> Amras: the key to understanding is
05:20:42 <phadej> More generally, a category k can be monoidal over constructions other than products, but cartesian
05:20:45 <phadej> products (ordered pairs) suffice for this paper.
05:23:02 <phadej> Amras: so the identity object is () (unit); and there shoul be morphisms k (a, ()) a; k a (a, ()); k ((), b) b; k b ((), b)
05:23:12 <phadej> which are simple for k ~ (->)
05:24:21 <phadej> (note, it's less powerful than Cartesian  described in section 4.3)
05:30:45 <Amras> I see. That clears things up a lot. I know there are supposed to be isomorphisms between I×f and f, but it didn't occur to me that the isomorphisms in question didn't have to be equality.
05:34:10 <Amras> If I understand correctly, a "proper" definition of a Monoidal instance would have to explicitly define the `k` isomorphism, but the paper omitted that for brevity?
05:36:28 <phadej> prove inverses? yes, one should do that; but for (->) it's quite obvious
05:37:49 <phadej> # A strict monoidal category is one for which the natural isomorphisms α, λ and ρ are identitie
05:38:16 <phadej> one have to show naturality too, but in haskell parametric functions are natural too
05:40:21 <Amras> "identities" here meaning the same thing as Category's `id`?
05:41:11 <phadej> equalities
05:41:26 <akr> Is there any way to have a NFData instance derived for a library-defined type? I tried `instance Generic JSValue; instance NFData JSValue`, but that doesn't compile
05:41:52 <phadej> akr: then you have to follow error messages to find out what's missing
05:43:11 <akr> oh wait what
05:43:23 <akr> looks like it compiles with `stack ghci` but not in emacs with intero
05:43:58 <akr> no nevermind, my bad
05:45:47 <akr> unfortunately it looks like it needs some internal thing of DeepSeq: https://pastebin.com/uD1UDx3U
05:50:10 <Amras> so in a strict monoidal category, IxA=A. But since Monoidal (->) is non-strict, λ and ρ are defined as different isomorphisms; specifically (and by fortunate coincidence) similar to Cartesian's exl and exr.
05:51:14 * hackage lie 0.1.0.0 - Lie Algebras  https://hackage.haskell.org/package/lie-0.1.0.0 (jumper149)
05:52:46 <phadej> akr: `deriving instance Generic JSValue`
05:52:59 <phadej> just `instance Generic JSValue` defines an empty instalce
05:53:02 <phadej> instance
05:53:10 <phadej> (turn -Wall on, it would warned you)
05:56:21 <akr> phadej: ah I see, thanks
05:56:32 <akr> (hmm I did think I had -Wall on, will check)
06:05:01 <akr> hmm apparently you can only derive instance of a data type if all constructors are in scope
06:05:09 <akr> anything I can do if the library doesn't export a constructor?
06:05:36 <akr> other than patching the library to just do all the deriving there
06:05:43 <jackdk_> complain to the maintainer? use deepseq-magic to write an orphan instance?
06:06:16 <akr> oh I did not know about deepseq-magic
06:06:27 <akr> is that safe?
06:06:35 <akr> why are there no docs :/
06:07:10 <akr> hmm seems kinda abandoned
06:10:32 <fendor> can i convert `(Maybe a, Maybe b) -> Maybe (a,b)`?
06:10:41 <fendor> with a builtin function, btw. not manually
06:11:44 <[Leary]> :t uncurry (liftA2 (,))
06:11:45 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
06:13:21 <fendor> [Leary], thanks! would not have thought about that function
06:14:38 <fendor> with function signature Maybe a -> Maybe b -> Maybe (a,b) it becomes clearer
06:40:21 <jgt> is there any easy way to see what GHC is spending most of its time doing, with a view to reducing compile times?
06:43:21 <z0> what does the command :kind! do in ghci? I can't find it in the docs
06:43:41 <dolio> Gets the normalized kind.
06:43:44 * hackage indent 0.0.3 - Fix your indentation.  https://hackage.haskell.org/package/indent-0.0.3 (vapourismo)
06:54:48 <z0> dolio: what does it mean for a kind to be normalized?
06:55:17 <dolio> They are reduced as much as possible. So, aliases are expanded and such.
06:57:30 <z0> oh thanks
06:59:00 <z0> hum... :kind! String goves me String :: * = String
06:59:13 <z0> *gives
07:00:30 <dolio> Oh, I guess I was off in two ways.
07:00:49 <dolio> It's not getting the normalized kind, because that probably wouldn't do much most of the time.
07:00:55 <dolio> It's normalizing the type.
07:01:12 <dolio> Also I guess it doesn't necessarily expand aliases, just type families, probably.
07:01:12 <jackdk_> so it will evaluate type families and such
07:01:43 <jackdk_> if you have DataKinds turned on and GHC.TypeNats in scope, :kind! 3 + 4 will tell you that it's 7 :: Nat
07:02:36 <z0> ok that makes sense
07:02:38 <z0> thank you
07:03:01 <z0> i just came across it and had never seen it mentioned before
07:17:57 <jackdk_> Is there a way to specify conditional sections in cabal.project files? I want to use source-repository-package stanzas, but I'm also using reflex-platform, which is still on GHC8.4 and can't understand them.
07:18:34 <jackdk_> (and I can't just get everything from mainline nixpkgs because reflex is marked broken there, and I wasn't able to track down the multiple-depends-on-same-package problem)
07:18:46 <dolio> There are definitely conditionals.
07:21:37 <jackdk_> in cabal.project? my search-fu is failing me; do you have a documentation link or example?
07:22:30 <dolio> Oh project. Not sure about that.
07:22:46 <dolio> My knowledge of project files is pretty weak.
07:24:07 <maerwald> conditional on what?
07:24:13 <maerwald> I don't even understand the problem
07:24:36 <alx741> hello all. I'm wondering whether neural nets libraries in haskell (granade for instance) have comparable capabilities in terms of the expresable networks and performance with common libraries such as tensorflow. In particular, can grande (or other haskell library) train networks taking full advantange of the GPUs in the system?
07:26:00 <alx741> Or more generally, what is possible with non-haskell neural nets libraries, that is currently not possible with haskell ones?
07:26:57 <jackdk_> maerwald: If I add source-repository-package stanzas to my cabal.project, then cabal that comes with ghc-8.4 doesn't know them and dies. I use nix for my development environment, but providing cabal.project support for my non-hackage deps would be nice
07:28:01 <jackdk_> maerwald: the package I'm developing depends on reflex, which is broken in nixpkgs, so I'm forced onto reflex-platform (GHC 8.4), and even if I wasn't, I'd run into https://github.com/haskell/cabal/issues/5586#issuecomment-479576084
07:29:39 <maerwald> so what would be the "conditional"?
07:29:48 <maerwald> ghc version?
07:30:00 <jackdk_> maerwald: current thinking: if cabal.project supports conditionals, hide the source-repository-package stuff so it's fine with cabal-install 2.2. otherwise, give up on source-repository-package for now since the only package I want on hackage has no non-hackage-deps
07:30:09 <jackdk_> probably cabal-install >= 2.4
07:30:15 <maerwald> why cabal-install?
07:30:21 <Zemyla> I AM SUPER HAPPY I went with an extremely cute girl to LGBT prom and now we're together and we cuddled and kissed so much an aaaaaaaa~!
07:30:28 <Zemyla> Wait, crap, wrong channel.
07:30:55 <jackdk_> I'm pleased for you mate, but not exactly haskell :P
07:31:19 <jackdk_> because that is the tool that's reading the cabal.project file
07:31:27 <maerwald> Err
07:31:52 <maerwald> You are saying cabal-install 2.2 cannot read your project file?
07:32:32 <jackdk_> if I add source-repository-package stanzas, then yes, cabal-install 2.2 chokes on it with "cabal: TODO: add support for fetching and reading local tarballs, [...]"
07:32:54 <maerwald> Ok, why not say that from the beginning
07:33:01 <maerwald> Don't think that's possible no
07:33:06 <Zemyla> Well, on the topic of Haskell, I've been kind of cranking at a library for unboxed Seqs. It'd be like unboxed vectors, except that they'd have O(log n) search and concatenation.
07:33:38 <maerwald> You mixed in all sorts of unrelated info to your question...
07:34:17 <maerwald> You probably would have to write a bash wrapper or something
07:34:50 <maerwald> You can have multiple project files and tell cabal which one to use
07:34:58 <Zemyla> Also, unlike unboxed vectors, there's totally a derived instance for (UnboxSeq a, UnboxSeq b) => UnboxSeq (Either a b).
07:35:02 <maerwald> so you could maintain *some* backwards compat
07:35:43 * hackage haskell-gi 0.22.2 - Generate Haskell bindings for GObject Introspection capable libraries  https://hackage.haskell.org/package/haskell-gi-0.22.2 (inaki)
07:36:30 <maerwald> for example we use different project files for local development and production, all possible
07:37:08 <jackdk_> that's probably the best move for now, since the nix tooling isn't yet great at handling cabal.project either
07:39:17 <jackdk_> thanks for the pointer to --project-file. Now I'm up waaay too late, and I should fix that.
07:40:22 <Zemyla> The way UnboxSeq (Either a b) works is that data instance Seq (Either a b) = SeqE !(Seq Bool) !(Seq a) !(Seq b), and the Seq Bool has a monoid that tracks both the number of elements and the number of True elements, so it can search on that. The Seq Bool has n elements, the Seq a has k elements, and the Seq b has n-k elements.
07:43:10 <Zemyla> Similarly, Seq [a] = SeqL !(Seq Bool) !(Seq a) (Seq [a]), kind of holding them in parallel.
07:47:23 <Zemyla> I'm most hoping that an unboxed Seq of Char is at least vaguely competitive with Text in terms of uncons and prefix search and map/filter/foldr. It'll definitely be faster at cons and mappend.
07:50:43 * hackage wordify 0.1.0.0 -   https://hackage.haskell.org/package/wordify-0.1.0.0 (happy0)
08:16:14 * hackage irc-conduit 0.3.0.3 - Streaming IRC message library using conduits.  https://hackage.haskell.org/package/irc-conduit-0.3.0.3 (barrucadu)
08:20:44 * hackage irc-client 1.1.0.7 - An IRC client library.  https://hackage.haskell.org/package/irc-client-1.1.0.7 (barrucadu)
08:30:44 * hackage ginger 0.9.0.0 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.9.0.0 (TobiasDammers)
08:31:38 <Amras> conal: do you mind if I clarify one equation in the essence of AD paper?
08:32:04 <conal> Amras: go for it.
08:33:22 <Amras> where you define the NumCat instance for D, mulC is defined in terms of the numeric (·). Wouldn't it make more sense to use Num's mulC here, so it's fully compositional?
08:35:26 <conal> Amras: by "fully compositional", do you mean something about generality?
08:36:23 <conal> Amras: hm. i see that my use of negateC and addC in that instance is inconsistent with the definitions of mulC, sinC, cosC, and expC.
08:36:48 <conal> would have been more consistent to use negate and uncurry (+).
08:37:53 <conal> Amras: i'm looking at the instance definitions near the end of section 4. you also?
08:38:10 <Amras> yes, those
08:39:22 <Amras> D's negateC and addC would both be defined if the arguments were of type (NumCat (->) a) => a. D's mulC is only defined if a and b are Nums
08:40:31 <conal> Amras: oh. and those conditions are equivalant, iirc, but maybe i didn't say so in the paper.
08:40:58 <conal> Amras: oh. i did say so near the beginning of section 4.6.
08:41:00 <Amras> oh, no, you did
08:41:12 <Amras> yeah, that was an oversight on my part
08:41:47 <Amras> that answers my question then :)
08:41:57 <conal> still, i could improve consistency & readability by using negate and uncurry (+) in the NumCat D instance. thanks!
08:41:57 <habbah> Axman6: When you asked "what is ProcessContext," were you giving me a hint? 
08:45:41 <d34df00d> I'm having a set of nested functions that pass PGS.connection to the DB between each other (where PGS is Database.PostgreSQL.Simple).
08:45:53 <d34df00d> Would it be nicer and more idiomatic to wrap them into MonadReader PGS.Connection m?
08:46:13 <d34df00d> PGS.Connection, of course — that's a type.
08:47:44 * hackage futhark 0.11.1 - An optimising compiler for a functional, array-oriented language.  https://hackage.haskell.org/package/futhark-0.11.1 (TroelsHenriksen)
09:02:40 <Athas> Are there automatic bots that regularly download Hackage packages?  The download stats for my package seem implausible.
09:14:00 <shapr> futhark is pretty neat
09:15:06 <Athas> Actually, all of my packages (even old abandoned ones that nobody should ever use) seem to be downloaded every other day.
09:15:32 <Athas> I don't believe that many people are interacting with X11 resource databases in Haskell, so it must be a bot.
09:16:09 <int-e> Athas: on average or can you see any detailed statistics?
09:16:43 <Athas> I can only see the numbers on https://hackage.haskell.org/package/X11-rm-0.2
09:17:36 <shapr> I was grabbing all the X11 packages recently to dig through them and try to learn stuff
09:17:53 <shapr> cause I don't know how to translate key events into other key events in X
09:18:08 <shapr> Athas: perhaps there are many inquisitive people in this community?
09:18:44 <Athas> X11 is horrifying.  Bad place to allocate one's curiosity budget.
09:18:55 <shapr> Athas: ah, but I want a certain thing to work a certain way
09:19:15 <shapr> Athas: I want this to work in X https://github.com/shapr/markovkeyboard
09:19:31 <int-e> Athas: if you stay away from horrible thing you'll never become a programmer ;-)
09:19:37 <int-e> *things
09:19:40 <shapr> true that
09:20:37 <shapr> I've been paid for years of telephony (VoIP) work, but it's likely worse than dealing being paid to deal with X those same years.
09:21:19 <int-e> Heh, I've never seen this error before: https://hackage.haskell.org/package/tslib (it says: Unavailable For Legal Reasons)
09:21:57 <int-e> (I was trying to find an unpopular package.)
09:22:30 <__monty__> I guess most 451 pages are styled?
09:22:49 <shapr> wow, what was tslib?
09:23:34 <lavalike> Data.TimeSeries https://web.archive.org/web/20160321210802/https://hackage.haskell.org/package/tslib
09:23:44 <Athas> Something that was uploaded without proper legal rights.
09:23:46 <int-e> Athas: https://hackage.haskell.org/package/escoger has only 7 downloads in the last 30 days. :)
09:24:03 <phadej> `cabal info tslib`
09:24:11 <int-e> shapr: it was the only package in the - category, that's how I found it.
09:24:19 <shapr> oh interesting
09:24:21 <int-e> so, no clue.
09:24:32 <lavalike> you can even download the code from the wayback machine there
09:25:05 <int-e> Athas: but I have no clue how to find unpopular packages systematically, so perhaps there's something that has been downloaded even less frequently.
09:26:21 <Athas> That tslib code looks very industrial.
09:26:38 <Athas> The license is "All rights reserved".  My guess is that someone ran 'cabal upload' by accident.
09:27:15 <shapr> oh interesting
09:27:30 <int-e> Athas: hmm, it has 4 revisions though, that doesn't seem accidental.
09:27:56 <Athas> int-e: my guess is that revisions and deprecations were attempted to scrub it off Hackage.
09:28:01 <int-e> anyway, I think it's not worth spending (more) time on :)
09:28:04 <Athas> At some point, they asked the Hackage maintainers to step in.
09:28:42 <lavalike> the mystery! the intrigue!
09:28:52 <sm[m]> Athas: I think downloads are inflated, yes - #hackage will know
09:29:04 <Athas> This is like studying the ruins of an ancient settlement.  What caused this calamity?
09:29:41 <Athas> sm[m]: at least it looks like they are roughly equally inflated, so I can still use the download counts as a proxy for popularity (my tie-breaker when picking libraries).
09:30:16 <int-e> lavalike: I know!
09:31:08 <Athas> shapr: I think markovkeyboard could be done in X11 by registering an X Input Manager (XIM) to intercept keypresses, and then using the X Keyboard extension (XKB) to dynamically remap it.
09:31:42 <shapr> Athas: oh wow! I've been in the floundering stage for hours.
09:31:51 <Athas> But the XIM thing is probably super painful.  I think there is some other way of snooping on keypresses, but I don't remember what it is (and it's obviously a security vulnerability, so it may have been locked down).
09:32:19 <Athas> Also, some poorly written applications (unfortunately including xmonad) will not go through the XIM API, and so their key activity will not be visible.
09:33:41 <shapr> so, XIM grabs keypresses, then run xmodmap to remap?
09:34:13 <shapr> Athas: Is there XIM and XKB bindings for Haskell?
09:34:16 * shapr digs around on hackage
09:37:24 <Athas> shapr: XIM yes, not sure about XKB.
09:37:46 <Athas> But they are likely outdated.
09:37:49 <Athas> http://hackage.haskell.org/package/x11-xim-0.0.9.0
09:38:52 <Athas> I mean, X11 never changes, but Haskell does.
09:39:51 <shapr> welp, time to find out
09:41:01 <jcowan> Given a function of type [Maybe a] -> [a] that quietly discards any Nothings in the input, what would be a good name for it, anybody?
09:42:03 <lavalike> :t catMaybes
09:42:05 <lambdabot> [Maybe a] -> [a]
09:42:08 <jgt> jcowan: catMaybes
09:42:17 * jgt is too slow
09:42:40 <lavalike> not sure it's "good" but it's what it's called in base
09:43:31 <jgt> I'd argue sticking with it, since it's become part of the furniture
09:43:46 <jgt> I mean, "return" is a somewhat unfortunate name, but I don't think we should rename it now
09:45:41 <int-e> :t nub -- best name of all
09:45:42 <lambdabot> Eq a => [a] -> [a]
09:45:56 <dmwit> "malign" still gets my vote
09:46:06 <jcowan> Right, but `cat` is generally a function of type [a] -> a
09:46:28 <dmwit> [[a]] -> [a] surely
09:46:35 <int-e> jgt: I'm sure people are thinking of deprecating 'return' in favor of 'pure' :)
09:46:44 <dmwit> Or perhaps you meant [A] -> A for some type A.
09:46:48 <dmwit> Okay.
09:46:49 <jgt> int-e: in practice I see that a lot
09:46:51 <jcowan> It's certainly not a name I would replicate in another language.  But thanks for the quick answer.  (I wish Hoogle understood regexen or at least glob patterns.)
09:47:09 <jgt> jcowan: the type signature you provided initially does work in hoogle
09:47:23 <dmwit> What glob would you have put in?
09:47:24 <jgt> https://hoogle.haskell.org/?hoogle=%5BMaybe%20a%5D%20-%3E%20%5Ba%5D
09:47:32 <jcowan> Yes.  But I wanted to find other operators with "cat" in their names
09:49:04 <dmwit> You can just type "cat" for that.
09:49:18 <dmwit> The real complaint is that it only shows one page of results and doesn't have a "next page" link.
09:49:33 <lavalike> stackage will find those, on a search for cat after 4 pages of "cat" it finds catMaybes catch catchJust catches catchSTM catching ...
09:49:35 <jcowan> Ah.  I was thinking it found only cat and Cat
09:49:41 <dmwit> But if you e.g. "cat package:base" you'll see that it does indeed match names that just have "cat" as a substring.
09:49:48 <jcowan> Gotcha.
09:50:26 <jcowan> Anyway, if furnishing a new room, what would you call this piece of furniture then?
09:50:42 <lavalike> catMaybes I like old furniture
09:51:04 <dmwit> foldMap (foldMap pure) -- ;-)
09:51:52 <argent0> dropNothing... better not
09:51:54 <jgt> I'd call it theSameCollectionWithAllTheNothingsRemovedAndTheJustsUnwrapped, and begin my new career as a "software craftsman" at 8th Light
09:52:11 <dmwit> I dunno. I might actually call it `concat` and generalize it suitably.
09:52:31 <jgt> allTheThingsThatAreGood :: [Maybe a] -> [a]
09:53:03 <dmwit> concat :: (Foldable f, Foldable g) => f (g a) -> [a]
09:53:35 <dmwit> (Hey, neat, this is just `coerce toList`!)
09:54:03 <dmwit> % :t coerce @(Compose _ _) toList
09:54:03 <yahb> dmwit: ; <interactive>:1:10: error: Not in scope: type constructor or class `Compose'; <interactive>:1:23: error:; Ambiguous occurrence `toList'; It could refer to either `Data.Foldable.toList', imported from `Data.Foldable'; or `GHC.Exts.toList', imported from `GHC.Exts'
09:58:13 * hackage simple-cabal 0.0.0 - Cabal file wrapper library  https://hackage.haskell.org/package/simple-cabal-0.0.0 (JensPetersen)
09:59:25 <jcowan> I think the essential point is not stripping the Nothings out but unwrapping the Justs.
10:00:10 <int-e> I keep coming up with "justice" as a name.
10:00:36 * jcowan laughs
10:01:50 <dmwit> :t foldMap toList
10:01:52 <lambdabot> error:
10:01:52 <lambdabot>     Ambiguous occurrence ‘toList’
10:01:52 <lambdabot>     It could refer to either ‘F.toList’,
10:01:53 <jgt> stripping the Nothings out is _quite_ essential
10:01:57 <dmwit> :t foldMap F.toList
10:01:59 <lambdabot> (Foldable t2, Foldable t1) => t1 (t2 a) -> [a]
10:02:04 <jgt> given that lists are homogenous
10:02:43 <int-e> :t foldMap maybeToList
10:02:44 <lambdabot> Foldable t => t (Maybe a) -> [a]
10:03:23 <int-e> (because maybeToList is much better than catMaybes)
10:05:26 <jgt> I mean, if we're going to complain about names, surely snoc gets an honourable mention
10:06:17 <jgt> and if snoc isn't a reverse cons like I imagine it is, I swear I will turn this car around
10:06:37 <jcowan> Oh, it is.  That comes from the Lisp tradition.
10:07:06 <jcowan> An alternative would be [Maybe a] -> a -> [a], but Haskell brings up nothing for that; it's unwrap-with-default-value.
10:07:20 <jcowan> s/Haskell/Hoogle
10:07:27 <jgt> I thought as much. Still, I get the impression that we — collectively, as programmers — are amused with snoc and yet frustrated about esac and fi in bash
10:07:58 <dmwit> jcowan: fromMaybe. But no need to bring lists into the picuter.
10:08:00 <int-e> :t (=<<) . fromMaybe
10:08:02 <lambdabot> Monad m => m b -> m (Maybe (m b)) -> m b
10:08:11 <dmwit> :t fromMaybe
10:08:12 <int-e> uh, not quite :)
10:08:12 <lambdabot> a -> Maybe a -> a
10:08:24 <dmwit> :t map . fromMaybe
10:08:25 <lambdabot> b -> [Maybe b] -> [b]
10:08:47 <int-e> :t ((=<<) .) . fromMaybe -- this?
10:08:48 <lambdabot> Monad m => (a -> m b) -> Maybe (a -> m b) -> m a -> m b
10:09:06 <int-e> I guess I can't @pl today.
10:09:23 <jcowan> esac and fi go back to Algol 68, because Bourne was an A68 fan and brought it to the Labs.  I wonder what would have happened if a compiler small enough for the PDP-11 had caught on?
10:09:24 <dmwit> int-e: You could use the monad law that (\f -> (>>= return.f)) = map f if you wanted.
10:09:24 <int-e> ah
10:09:44 <int-e> the fromMaybe does the flattening already, stupid me.
10:16:17 <dmwit> :t asum
10:16:19 <lambdabot> (Alternative f, Foldable t) => t (f a) -> f a
10:17:39 <dmwit> I often want to fill the hole in fold : foldMap :: asum : _
10:19:57 <jcowan> I have probably asked this before, but my logs are missing it:  how do you define apply in terms of pure and sequence, and sequence in terms of pure and apply?
10:20:11 <dmwit> :t apply
10:20:12 <lambdabot> error: Variable not in scope: apply
10:20:19 <dmwit> apply ?= (<*>) 
10:21:00 <dmwit> Anyway, I suspect the answer is "you don't".
10:21:12 <dmwit> But if you have a specific instance in mind then we can talk about that instance.
10:21:52 <dmwit> (Perhaps lambdabot still has the list instances lying around.)
10:21:53 <dmwit> ?src sequence
10:21:53 <lambdabot> sequence []     = return []
10:21:53 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:21:53 <lambdabot> --OR
10:21:54 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
10:22:21 <dmwit> Those are spelled with Monad abstractions, but `liftM2` can be `liftA2` there.
10:22:34 <dmwit> (and `return` can be `pure`)
10:31:46 <jcowan> I distinctly remember being told that pure and sequenceA were a minimal basis for Applicative
10:32:57 <dmwit> If you have sequenceA for the right instance, that might even be true, though you'd definitely also need fmap.
10:33:29 <dmwit> (Where "the right instance" = "any instance that can hold exactly two elements". The list instance, e.g.)
10:34:48 <dmwit> (Here I mean "the right Traversable instance", not "the right Applicative instance", obviously.)
10:51:08 <dmj`> If I have two file paths, [ ["a","b","data1.csv"], ["a","b","data2.csv"] ], what's the easiest way to unfold this [[String]] into a Tree String
10:55:54 <dmj`> for a single path this works great, but Data.Tree doesn't allow one to merge tree paths
10:55:56 <dmj`> https://gist.github.com/dmjio/ff5d5cce2b5845ab1ba523a128643430
11:01:15 <dmwit> dmj`: Maybe take a look through the search results for "trie" on Hackage.
11:11:37 <dmj`> dmwit: ah, yea guess a Trie could work for this, thanks :) 
11:19:09 <dmj`> I wrote a Trie 3 years ago, but I think it might be incorrect, and it only operates on Char right now
11:19:19 <dmj`> https://gist.github.com/dmjio/9138ab859bd04656cf1c
11:19:35 <dmj`> only a pretty printer will tel
11:19:38 <dmj`> tell*
11:22:24 <dmj`> it seems right, ship it
11:23:34 <jcowan> Sorry, I meant fmap and sequenceA after all.  I was trying to discover some nested dolls: it's a functor if it has fmap, an applicative if it also has sequenceA, and a monad if it also has bind or join.
11:27:13 * hackage indent 0.0.4 - Fix your indentation.  https://hackage.haskell.org/package/indent-0.0.4 (vapourismo)
11:55:20 <zcombinator> Hi, I'd like to ask a question regarding the Z combinator
11:56:13 <zcombinator> I was going through chapter 9 in The Little Schemer, which has a great exposition on the applicative-order Y combinator (which I understand to be also referred to as the Z combinator)
11:56:39 <zcombinator> actually no scrap that
11:58:14 * hackage porter 0.1.0.2 - Implementation of the Porter stemming algorithm  https://hackage.haskell.org/package/porter-0.1.0.2 (LauraDietz)
11:58:43 <jcowan> Y is lazy, Z is eager, but people doing eager languages often refer to Z and Y, and this may be historically sound.
11:58:55 <jcowan> s/Z and Y/Z as Y
11:59:43 <yyworks> @jcowan welp I'm so sorry I rejoined under a different nick
11:59:43 <lambdabot> Unknown command, try @list
12:00:00 <jcowan> dumb bot
12:00:46 <yyworks> given a fixed point combinator naively defined as ` y f = f (y f) `, I was wondering why ` y y ` fails
12:01:11 <yyworks> in ghc I get the following type error: `Expected type: t -> t , Actual type: (t -> t) -> t`
12:01:46 <yyworks> which I think I somewhat understand? but was hoping someone might shed some more light on the details if possible?
12:02:58 <jle`> yyworks: that's basically all there is to it: it's a type error
12:03:26 <jle`> yyworks: but to see more as to why, try looking up how unification works
12:03:44 <jle`> when you try to apply a polymorphic function, ghc/haskell will try to figure out what type variables go where
12:04:16 <jle`> for example, if calling `map :: (a -> b) -> [a] -> [b]` with a function (Int -> Bool), HM will try to figure out what 'a' and 'b' are by matching (a -> b) with (Int -> Bool)
12:04:17 <yyworks> jle`: thank you so much!
12:04:32 <jle`> and it'll see that a ~ Int, and b ~ Bool
12:04:40 <jle`> so we have map :: (Int -> Bool) -> [Int] -> [Bool]
12:04:57 <jle`> try looking up hindley milner type inference for the full step by step details of how the algorithm works
12:05:05 <jle`> but you should be able to do it by hand most of the time
12:05:14 <jle`> for 'y y', try doing the unification with that
12:05:35 <jle`> y :: (a -> a) -> a, and you are applying it to a (b -> b) -> b
12:05:41 <jle`> so try to unify (a -> a) with (b -> b) -> b
12:05:46 <yyworks> jle`: having a go at it right now :)
12:06:17 <jle`> the main rule that is important here is that if (X -> Y) unifies with (P -> Q), then X has to be P, and Y has to be Q
12:08:07 <jle`> also, a minor unrelated note, the thing you defined is actually not the Y combinator, in case you were trying to define the y combinator in haskell
12:09:49 <yyworks> oh, in that case, what is it actually?
12:11:52 <jle`> i'm not sure if it has a specific name, but it's just a fixed-point combinator
12:12:04 <jle`> the y combinator refers to a specific fixed-point combinator, out of the many possible
12:12:46 <jle`> it's more of an implementation thing
12:12:58 <yyworks> ah I see! thanks for the clarification
12:13:00 <jle`> kind of like how you can make cars with gas engines or electric engines, but they're both still cars
12:13:41 <erisco> I need some combinators to describe every possible  A -> A  where A is an ADT (and comprised of ADTs) and all a :: A are finite.
12:14:03 <jle`> yyworks: np :) it's probably not too important in the long run, but it might help with looking up more follow up information
12:14:08 <erisco> I guess that still isn't as constrained as I mean to say. Hrm.
12:14:25 <jle`> erisco: you probably can do it if A is enumerable
12:14:28 <jle`> like with the universe package maybe
12:14:41 <erisco> All nonrecursive  A -> A
12:15:22 <jle`> erisco: actually yes, the universe package has that exact thing
12:15:40 <erisco> okay, looking at the universe package
12:15:52 <erisco> what music do I listen to while doing that?
12:16:01 <jle`> universeF :: (Ord a, Finite a) => [a -> a]
12:16:07 <jle`> it will enumerate all possible [a -> a]s
12:16:16 <jle`> * (a -> a)s
12:16:50 <jle`> oh i suppose you can just do universe :: (Ord a, Finite a) -> [a -> a]
12:17:39 <erisco> so, I am specifically looking for combinators, so that I can describe all these functions
12:18:18 <erisco> something less than combinator logic is the hope
12:18:29 <jle`> ah, you mean lie a data structure that can specify a single A -> A?
12:18:35 <erisco> yes
12:18:52 <erisco> so you can interpret it as an A -> A
12:18:59 <jle`> in that case you can probably do `Map a a`, as long as it has all the keys
12:19:29 <erisco> hrm
12:20:53 <erisco> I think "finite" was misunderstood
12:21:19 <erisco> A is not finite, but all  x :: A  are finite in size.  A is not Stream, for example.
12:22:38 <erisco> though upon reflection, I think that becomes unnecessary… because what I really should have said was that  f :: A -> A  is nonrecursive, so even if x :: A is infinite in size, f can only touch some finite part of it.
12:23:34 <erisco> does that make sense?
12:24:09 <erisco> jle`, f is like a diff between files.
12:24:54 <erisco> So I have to add some other complicated to describe constraint… but I was hoping to get some suggestions without having to formulate that XD
12:25:44 <erisco> if  f x = y  then y must use as much of x as possible (how to formalise that I don't know yet)
12:26:37 <erisco> though in this context we're talking ∃f, i.e. if f = g then this condition isn't also necessary for g
12:27:05 <erisco> i.e. it must be possible to have an efficient diff but not necessary
12:32:39 <erisco> @tell ski Paths are profunctors. I know what the next problem is. Maybe you can help!
12:32:39 <lambdabot> Consider it noted.
12:40:49 <John_Ivan> probably a stupid question, but does haskell compile it's code such that at runtime it already knows what kind of value will go each function at compile time?
12:41:07 <John_Ivan> scrapping away the other code for other cases in pattern matching and guards?
12:42:32 <erisco> it knows the types of values
12:42:59 <John_Ivan> (I guess I'm asking if Haskell does what c++ would do in constrexpr)
12:43:23 <John_Ivan> and template metaprogramming.
12:43:45 <erisco> I don't know what that is but GHC includes several optimisations
12:43:59 <John_Ivan> hmm. ok
12:46:43 <erisco> You can check the Core output to see what GHC did
12:47:43 <John_Ivan> It'll have to wait until I learn haskell properly I suppose. but thanks.
12:47:43 * hackage graphite 0.10.0.1 - Graphs and networks library  https://hackage.haskell.org/package/graphite-0.10.0.1 (alx741)
12:56:44 * hackage tracing 0.0.1.0 - Distributed tracing  https://hackage.haskell.org/package/tracing-0.0.1.0 (mtth)
13:00:36 <__monty__> John_Ivan: GHC inlines aggressively so I'd be surprised if it didn't specialize functions when possible.
13:08:14 * hackage sbv 8.3 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  https://hackage.haskell.org/package/sbv-8.3 (LeventErkok)
13:11:44 * hackage tracing 0.0.1.1 - Distributed tracing  https://hackage.haskell.org/package/tracing-0.0.1.1 (mtth)
13:17:46 <rfold> It won't inline recursive functions and this can be a major pain for higher-order recursive functions.
13:22:59 <__monty__> What if you use the specialize or inline pragmas?
13:27:10 <c_wraith> Specialize lets things get inlined *into* recursive functions.
13:27:29 <c_wraith> Inlining a recursive function into its environment requires some trickery.
13:34:27 <jle`> John_Ivan: in some cases it's not possible to know in advance. so while you might not know if a Bool is True or False until runtime, you will at least know that it's a Bool at compiletime
13:35:01 <jle`> John_Ivan: for example, consider a function that will be run on a Bool that is retrieved from the user at runtime
13:35:21 <jle`> it's not possible to know if it will be True or False at compiletime, without the assistance of some time travel
13:37:18 <jle`> so, GHC cannot compile its code to eliminate all case statements because of reasons like this
13:39:04 <Welkin> is there a release date for ghc 8?
13:39:12 <Welkin> 8.8
13:40:36 <dmj`> "culminating in a final 8.8.1 release in mid-May."
13:40:42 <dmj`> https://www.haskell.org/ghc/blog/20190405-ghc-8.8-status.html
13:41:04 <Welkin> but it's june
13:41:34 <Welkin> oh well
13:41:47 <Welkin> I almost never update to the x.x.1 releases anyway
13:41:55 <Welkin> wait until .2 or .3
13:42:53 <kostas> I'm trying to build a system where many threads send commands on a single thread. The single thread executes the commands, in a fifo way and sends back the results. I think I should use some channel, but how should I chose between all different implemenations?
13:45:05 <Welkin> that sounds reasonable
13:45:16 <Welkin> also look at Cloud Haskell/Distributed Haskell
13:49:54 <kostas> Welkin do you think cloud Haskell has advantages over something simpler like TChan for my use case?
13:50:09 <dmj`> cloud haskell sounds pretty heavy handed for this
13:50:12 <Welkin> if your system is fully asynchronous
13:50:17 <Welkin> and distributed
13:50:43 <dmj`> kostas: you can have the threads that write to the chan block on an mvar, waiting to receive the result of their computation from the processing thread
13:50:48 <Welkin> however, the actor model is great even for a single machine
13:51:03 <Welkin> you write the same code for one machine vs many machines
13:51:23 <zachk> kostas, if you can just send messages from each thread to a channel that runs them on a main thread, and get rid of returning the answer, it will greatly simplify it 
13:51:36 <dmj`> kostas: what is your applications use case?
13:53:23 <kostas> Everything will run on asingle machine (at least for now). I also need to return the answer and have threads wait for them.
13:54:10 <kostas> The use case is that the single thread will only have access to some files and be the only one which can modify them.
13:54:40 <dmj`> kostas: how long do the actions take to accomplish?
13:55:34 <kostas> miliseconds. Maybe seconds but very rarely.
13:57:23 <Welkin> I wouldn't call the actor model "heavy" in any way
13:57:32 <Welkin> haskell and erlang processes cost almost nothing
13:58:39 <dmj`> kostas: is it too slow to be done single threaded?
14:00:36 <dmj`> kostas: if the file paths are all unique, you could fork one thread to wait on each path
14:03:32 <kostas> There is a single file and I want to have a single thread which accesses it.
14:04:26 <dmj`> do { chan <- newChan; msg@(Msg mvar) <- Msg <$> newEmptyMVar; writeChan chan msg; void . forkIO $ do takeMVar mvar >>= \filePath -> putStrLn $ "received file path" <> filePath }
14:04:27 <kostas> so it's not a matter of speed, since al actions wil be serialized by this thread.
14:04:52 <dmj`> so this is the parent thread making the chan, adding a message to it, and spawning a child to receive the result of the processed message
14:05:01 <dmj`> the parent thread would do something like
14:05:58 <dmj`> do { forever $ readChan chan >>= \(Msg mvar) -> someAction >>= \filePath -> putMVar mvar filePath }
14:06:29 <dmj`> so the order in which the threads wake up and process the message is the order in which the messages were placed on the chan
14:07:07 <dmj`> s/parent/processing thread*
14:11:50 <dmj`> kostas: want to see an example?
14:12:19 <zincy> So I did some heap profiling and there seems to be a memory leak in this function https://pastebin.com/mksUUF39
14:12:37 <zincy> Where should I be looking to add strictness to stop the leak?
14:16:27 <c_wraith> there's no leak there
14:16:30 <c_wraith> It's just too strict
14:17:41 <c_wraith> well, I guess shuffle has to be pretty strict.
14:18:04 <kostas> dmj` I'm not sure why you have an mVar with a filePath in your example above
14:18:54 <zincy> c_wraith: When the program runs it keeps taking up more and more memory, is that a sign of a memory leak somewhere?
14:19:12 <dmj`> kostas: it's contrived, the point is to show you how to receive a callback from the processing thread. You haven't given me enough information to know what your application is, just that you want to be notified from a processing thread of the result
14:19:13 <c_wraith> zincy: probably.  but it's not there.
14:21:08 <zincy> Here is the heap profile graph https://imgur.com/a/raQrYud
14:21:47 <c_wraith> ah, the fun of h2ps
14:22:02 <c_wraith> the caption is giant and still useless!
14:22:33 <zincy> c_wraith: Is it ok that shuffle is taking up so much memory?
14:22:37 <c_wraith> the most notable thing to me there - *everything* is growing.
14:22:45 <zincy> yeah hehe
14:22:52 <c_wraith> That suggests to me that nothing is ever getting collected.
14:22:57 <c_wraith> Look higher up for retainers
14:22:59 <kostas> dmj`: I see. I thought the MVar should be sent together with the Command through the channel. Does this sound wrong?
14:23:18 <dmj`> kostas: that's correct, and that's exactly what happens
14:23:20 <zincy> How do you tell if something higher up is retaining memory?
14:23:50 <kostas> dmj`: ah ok I see, I managed to miss it :)
14:24:14 <dmj`> zincy: the call to "length" could be keeping around a reference to the old list. The last chapter of RWH haskell shows this with the function "mean"
14:24:40 <dmj`> kostas: I'll just show you a working example, putting an MVar onto the chan is a classic
14:25:03 <c_wraith> dmj`: nah.  the result of length is forced in an IO action.  It's not holding anything
14:26:02 <dmj`> c_wraith: yea, seems like that's the case. Maybe there is something else holding onto the old list, can't tell w/o more code
14:27:05 <c_wraith> zincy: it's notable in your heap profile that it's just a bunch of lines going up.  A classic space leak is a spike - huge memory use followed by the memory being reclaimed as things are eventually forced.
14:27:27 <zincy> Here is the repo https://github.com/therewillbecode/haskell-poker/tree/counter
14:27:27 <kostas> dmj` thank you! Should I consider using TMVar over MVar for this?
14:27:28 <c_wraith> zincy: that makes me suspect something is preventing GC of anything
14:27:58 <c_wraith> zincy: server?
14:28:02 <zincy> c_wraith: so not a space leak then?
14:28:12 <zincy> c_wraith: yes
14:28:38 <c_wraith> zincy: my suspicion is it's something else.  Maybe you're got some sort of report value that isn't ever being forced
14:28:50 <zincy> hmm
14:29:04 <c_wraith> (I've done that before)
14:30:13 * hackage hi-file-parser 0.1.0.0 - Parser for GHC's hi files  https://hackage.haskell.org/package/hi-file-parser-0.1.0.0 (borsboom)
14:30:52 <zincy> what do you mean by report value?
14:31:30 <c_wraith> In my case, it was keeping statistics on how many and what kind of requests the server was handling.
14:31:55 <c_wraith> It was never getting forced, though, so it was building up a giant chain of thunks that held on to the requests and responses.
14:31:59 <dmj`> kostas: https://gist.github.com/59a8e2f14a77d3343de515bc1b8af675
14:33:05 <zincy> could it be a channel which is getting written to but never read?
14:33:07 <dmj`> kostas: it should just print, (ThreadId 1,"done"), etc. 
14:33:17 <c_wraith> zincy: that is certainly a prime suspect
14:33:40 <dmj`> kostas: you don't need a TMVar for this
14:34:27 <zincy> it is hard to figure it if and where that is happening :/
14:34:33 <zincy> *out
14:35:16 <dmj`> zincy: you should check out profiteur
14:35:20 <dmj`> @package profiteur
14:35:20 <lambdabot> http://hackage.haskell.org/package/profiteur
14:35:41 <dmj`> it shows the allocations and time spent in certain functions
14:35:53 <dmj`> very useful
14:36:12 <shapr> ooh neat
14:36:13 <c_wraith> you can also check the retainer profile the profiling RTS generates.  *sometimes* it's useful.
14:36:43 <shapr> I'd love to have a full narrative on profiling and optimization for Haskell code
14:36:47 <shapr> (read, ghc)
14:37:15 <dmj`> shapr: I gave up, I just FFI into C and call it a day :)
14:37:15 <zincy> thanks
14:37:17 <MarcelineVQ> related: https://hackage.haskell.org/package/weigh
14:38:08 <dmj`> kostas: did that work for you
14:38:24 <John_Ivan> jle`, of course.
14:38:34 <John_Ivan> jle`, but in cases where it should/can, I expect it to do so.
14:39:10 <dmj`> zincy: also, there's a specific setting for hp2ps that can maximize the right hand side legend so you can see more information, very useful setting
14:39:49 <jle`> John_Ivan: that's related to something called 'inlining', and it's something that we can actually do in haskell because of purity and referential transparency :)
14:40:13 <jle`> John_Ivan: basically in Haskell, you can always subsitute a function body for its call site
14:40:53 <jle`> John_Ivan: for example, if you had myFunx x = x * x, and you had something like `3 * myFunc 7`, you can always inline myFunc to replace it with (and compile) `3 * (x * x)`
14:41:25 <jle`> inlining is usually always possible, but there are trade-offs
14:41:43 * hackage http-download 0.1.0.0 - Verified downloads with retries  https://hackage.haskell.org/package/http-download-0.1.0.0 (borsboom)
14:42:09 <jle`> inlining and constant folding are the two tricks that lead to situations like you describe
14:42:57 <jle`> but ghc doesn't inline all functions and fold all constants, because there are tradeoffs and potential costs in doing so
14:43:43 * hackage rio-prettyprint 0.1.0.0 - Pretty-printing for RIO  https://hackage.haskell.org/package/rio-prettyprint-0.1.0.0 (borsboom)
14:44:17 <zincy> when I run retaining profiling with the flags  +RTS -hr -hcb   
14:44:22 <zincy> I get a segmentation fault :/
14:46:21 <John_Ivan> jle`, I see. :)
14:47:27 <jle`> John_Ivan: the general attitude is that aside from extremely simple and predictable optimizations, it's usually leave it up to explicit optimization
14:47:46 <jle`> (on the user end)
14:48:16 <John_Ivan> alright. sec, I have a feeling some spider is crawling on me but can't quite tell.
14:48:27 <John_Ivan> or it's maybe just the sensation.
14:48:38 <John_Ivan> that's what I get for stepping one second outside in my garden, goddammit.
14:48:48 <jle`> so maybe the final answer is that "it can, but it's not always clearly better to do so" :)
14:48:55 <jle`> spiders can be like that
14:49:00 <John_Ivan> I'm happy with that answer.
14:49:03 <kostas> dmj`: yeap thank you! Also, what about the type of channel I should use? I think unbounded channels like TChan can sometimes be dangerous to use?
14:49:18 <zincy> Does a seg fault mean it is likely a ghc bug?
14:49:29 <jle`> ghc bug, or else a bug in a library that does unsafe FFI, like vectors
14:49:30 <dmj`> kostas: you probably want a TBQueue, bounded FIFO queue
14:50:03 <John_Ivan> jle`, I'm not exactly new to haskell, but not seasoned either. It's now I started to look into it in more depth
14:50:13 <John_Ivan> and I have. a ton of questions.
14:50:32 <jle`> also if you are curious in these sorts of optimizations, there's a way to check if these optimizations fire in code you write
14:50:38 <jle`> so you can test specific situations and caes
14:50:45 <dmj`> kostas: this should block writers and halt the application if the message count exceeds some threshold you set
14:51:05 <John_Ivan> I was just building a model previously.
14:51:09 <jle`> if you compile with -ddump-simpl, you can see if those ifs/cases really are otpimized away
14:52:32 <John_Ivan> I'm trying to exactly pinpoint how different haskell is from other languages.
14:52:46 <John_Ivan> aside from the obvious - being purely functional.
14:53:01 <kostas> dmj` what do you mean halt the application?
14:53:39 <kostas> dmj`: what do you mean halt the application?
14:53:52 <dmj`> kostas: the write will block until the size of the chan is n - 1, which means it will keep reading messages until that is the case
14:54:01 <John_Ivan> jle`, the optimization is what came in mind a while back, hence the question. but as I said, I was merely trying to build a model.
14:55:06 <John_Ivan> also, aside from design decisions.
14:55:16 <John_Ivan> at first, it came as buzz words such as "intelligent" type inference.
14:55:29 <John_Ivan> in my mind - "but... python/ruby/etc also do that."
14:55:54 <dmj`> kostas: if you leave it unbounded you could OOM
14:56:02 <John_Ivan> "static typing" - but you're allowed to dynamically define variables without being explicit
14:58:37 <kritzefitz> Is there a canonical way to define a type family instance that resolves to a constraint that always fails?
14:59:13 * hackage parser-combinators 1.1.0 - Lightweight package providing commonly useful parser combinators  https://hackage.haskell.org/package/parser-combinators-1.1.0 (mrkkrp)
14:59:35 <kritzefitz> I think I read a suggestion somewhere to use TypeError from GHC.TypeLits, though that seems to behave differently than returning a constraint that just happens to never hold.
14:59:47 <kostas> dmj`: I see. I wonder if it's possible to have some timeout or somehow to simulate it instead of blocking forever.
15:00:14 * hackage parser-combinators-tests 1.1.0 - Test suite of parser-combinators  https://hackage.haskell.org/package/parser-combinators-tests-1.1.0 (mrkkrp)
15:00:42 <dmj`> kostas: it won't block forever, just until there is an open slot to write to
15:01:24 <zincy> Is the build up of unevaluated thunks a example of a "space leak"? 
15:01:40 <kritzefitz> i.e. what I'm looking for is a nicer way to define a type family instance like `type instance Foo a = (int ~ Char)`
15:02:14 <kostas> If the parent thread is blocked for whatever reason then also all other threads will block after some time
15:03:01 <dmj`> kostas: the child threads can act autonomously of the parent thread. But if the main thread dies, they die with it. 
15:03:15 <dmj`> kostas: that's why I have the forever in there
15:07:11 <dmj`> kritzefitz: TypeError sounds like a better idea
15:07:28 <dmj`> kritzefitz: while type family Lol a where Lol Int = Int ~ Char; Lol a = () is valid, the error message when used is pretty opaque
15:08:19 <kritzefitz> dmj`, yes but see this example: https://gitlab.com/snippets/1864867 . The warnings given by ghc are sub-optimal when using TypeError.
15:08:41 <kostas> dmj` I see and thanks again. Very helpful.
15:11:21 <dmj`> kritzefitz: yea you probably want something like
15:11:24 <dmj`> type family NoInts a :: Constraint where NoInts Int = TypeError ('Text "YOU SHALL NOT PASS"); NoInts a = ()
15:12:04 <dmj`> kritzefitz: it seems you had that but it was commented out
15:12:18 <dmj`> why is it suboptimal?
15:12:42 <kritzefitz> When I use the TypeError GHC warns about incomplete pattern for the cases in main.
15:15:21 <kritzefitz> Also, when using TypeError, I can try to match `foo` against `PermissionDenied`, even though `foo` can't have that value, because it would trigger the TypeError.
15:15:25 <dmj`> kritzefitz: when I run your code with -Wall I receive no warnings
15:15:45 <kritzefitz> Huh, what version of GHC are you using?
15:15:50 <dmj`> 8.6.5
15:15:58 <kritzefitz> Ok, me too.
15:17:01 <dmj`> kritzefitz: ok, I had to uncomment the TypeError, now I see it
15:17:14 <kritzefitz> Ah, sorry. I haven't made that clear.
15:22:23 <kritzefitz> When I use the constraint (Char ~ Int) I can't compile a case where I match `foo` against `PermissionDenied`, which is IMO a good thing, because `foo` can never have that value.
15:29:35 <dmj`> kritzefitz: yea that is interesting, I'd expect TypeError to make the pattern match total despite not matching the last case
15:41:44 <dmj`> kritzefitz: this might be a bug
15:43:27 <kritzefitz> Yes, I think so. It allows you to write pretty strange code, like a case alternative where a variable `pd` is proven to have matched `PermissionDenied` and at the same type have a type like `ReturnCode '[ 'SuccessTag, 'NoCheeseTag]`, which is impossible.
15:44:16 <kritzefitz> It shouldn't be a big problem as that branch can never be executed, but I still is nonsensical code, which shouldn't compile at all.
15:49:32 <dmj`> kritzefitz: yes, very bizarre
17:20:41 <jle`> zincy: i think it depends on the original intent
17:20:58 <jle`> zincy: i'd consider a space leak to be something that you'd expect to take constant space, but actually doesn't for some reason
17:21:16 <jle`> and sometimes unevaluated thunks can be that.  other times they can be expected behavior
17:21:59 <jle`> @tell kritzefitz there is a "constraint that never holds", and that's 'Any'
17:21:59 <lambdabot> Consider it noted.
17:34:44 * hackage hedgehog-classes 0.2 - Hedgehog will eat your typeclass bugs  https://hackage.haskell.org/package/hedgehog-classes-0.2 (chessai)
17:37:18 <Amazonka98> I will start my Live Show in 10 minutes. Check my sexy body, ass, boobs and pussy. Fastest people will join my Private Live for FREE (First 5 only that message me "Free Invite" in the Cam site)! The fun is GUARANTEED. Join now ---> https://hec.su/g1iX
17:47:44 * hackage flags-applicative 0.0.4.5 - Applicative flag parsing  https://hackage.haskell.org/package/flags-applicative-0.0.4.5 (mtth)
17:52:05 <solonarv> < dmwit-> I often want to fill the hole in fold : foldMap :: asum : _ -- ala' Ap foldMap, using CoercibleUtils
17:52:14 <solonarv> % :t ala' Ap foldMap
17:52:14 <yahb> solonarv: ; <interactive>:1:1: error:; * Variable not in scope: ala' :: (f0 a0 -> Ap f0 a0) -> ((a1 -> m0) -> [a1] -> m0) -> t; * Perhaps you meant one of these: `ala' (imported from Control.Lens), `alaf' (imported from Control.Lens)
17:52:26 <solonarv> % import CoercibleUtils
17:52:26 <yahb> solonarv: ; <no location info>: error:; Could not find module `CoercibleUtils'; It is not a module in the current program, or in any known package.
17:58:58 <solonarv> erm, I mean:
17:59:11 <solonarv> % :t ala' Alt foldMap
17:59:11 <yahb> solonarv: forall k (t :: * -> *) (f :: k -> *) (a :: k) a' d. (Foldable t, Monoid (Alt f a), Coercible a' (f a)) => (d -> f a) -> t d -> a'
17:59:29 <solonarv> grr go away kind polymorphism
17:59:42 <solonarv> % :t ala' (Alt @Type) foldMap
17:59:42 <yahb> solonarv: ; <interactive>:1:1: error:; * Couldn't match representation of type a' with that of `*' arising from a use of ala'; a' is a rigid type variable bound by; the inferred type of it :: (d -> *) -> t d -> a'; at <interactive>:1:1; * In the expression: ala' (Alt @Type) foldMap; <interactive>:1:12: error:; * Expected kind `k0 -> *', but `Type' has kind `*'; * In the type `T
17:59:57 <solonarv> bah
18:00:19 <solonarv> % ala' (Alt @Maybe) foldMap
18:00:19 <yahb> solonarv: ; <interactive>:86:1: error:; * Couldn't match representation of type `a'0' with that of `Maybe a0' arising from a use of `it'; * In the first argument of `print', namely `it'; In a stmt of an interactive GHCi command: print it
18:00:31 <solonarv> grumble grumble
18:02:11 <solonarv> % ala' Alt foldMap (\x -> (x`div`2) <$ guard (x`mod`2==0)) [2, 3, 4]
18:02:11 <yahb> solonarv: ; <interactive>:87:1: error:; * Couldn't match representation of type `f a' with that of `f0 a0'; * In the ambiguity check for the inferred type for `it'; To defer the ambiguity check to use sites, enable AllowAmbiguousTypes; When checking the inferred type; it :: forall (f :: * -> *) a a'. (Alternative f, Integral a, Coercible a' (f a)) => a'
18:02:22 <solonarv> % ala' Alt foldMap (\x -> (x`div`2) <$ guard (x`mod`2==0)) [2, 3, 4] :: Maybe Int
18:02:22 <yahb> solonarv: ; <interactive>:88:1: error:; * Couldn't match representation of type `f0 Integer' with that of `Maybe Int' arising from a use of ala'; * In the expression: ala' Alt foldMap (\ x -> (x `div` 2) <$ guard (x `mod` 2 == 0)) [2, 3, 4] :: Maybe Int; In an equation for `it': it = ala' Alt foldMap (\ x -> (x `div` 2) <$ guard (x `mod` 2 == 0)) [2, 3, ....] :: Maybe Int
18:02:35 <solonarv> gah, Coercible errors are annoying
18:02:39 <solonarv> % ala' Alt foldMap (\x -> (x`div`2) <$ guard (x`mod`2==0)) [2, 3, 4 :: Int] :: Maybe Int
18:02:40 <yahb> solonarv: ; <interactive>:89:1: error:; * Couldn't match representation of type `f0 Int' with that of `Maybe Int' arising from a use of ala'; * In the expression: ala' Alt foldMap (\ x -> (x `div` 2) <$ guard (x `mod` 2 == 0)) [2, 3, 4 :: Int] :: Maybe Int; In an equation for `it': it = ala' Alt foldMap (\ x -> (x `div` 2) <$ guard (x `mod` 2 == 0)) [2, 3, ....] :: Maybe Int
18:02:44 <solonarv> eh fuck it
18:02:46 <MarcelineVQ> ok
18:03:00 <solonarv> that should be it but I had to copy/paste the definition from coercible-utils
18:03:12 <solonarv> so maybe I did something wrong there
18:03:23 <solonarv> sorry for the bot spam :/
18:03:44 * hackage tracing 0.0.1.2 - Distributed tracing  https://hackage.haskell.org/package/tracing-0.0.1.2 (mtth)
18:42:39 <dmj`> Does anyone have a pedagogical implementation of implementing an on-disk B-tree, can be in any language. Note I do not want in-memory, on-disk.
18:44:25 <Welkin> there must be a reference to a paper in this book https://dataintensive.net/
18:44:37 <Welkin> it talks all about B-Trees in databases
18:44:46 <Welkin> ith as hundreds of references too
18:56:41 <dmj`> It might talk about them in databases, but database implementation is woefully lacking, and all the examples are always in memory
18:56:46 <dmj`> this is the closest I've seen in C
18:56:48 <dmj`> http://chi.cs.uchicago.edu/chidb/assignment_btree.html
18:57:13 <dmj`> there is haskey which is sort of what I'm after, but its not that pedagogical
18:57:17 <dmj`> @package haskey
18:57:17 <lambdabot> http://hackage.haskell.org/package/haskey
18:57:36 <dmj`> @package haskey-btree
18:57:37 <lambdabot> http://hackage.haskell.org/package/haskey-btree
19:35:38 <Always_H0rny> You want to look at mе without clothes, sweetie (EXCLUSIVE FREE FOR NEXT 3 PEOPLE!!) ;-) follow the link and add me as a friend -----------> http://qt.ms/paFFFTS
21:25:44 * hackage polysemy 0.3.0.1 - Higher-order, low-boilerplate, zero-cost free monads.  https://hackage.haskell.org/package/polysemy-0.3.0.1 (isovector)
21:28:43 * hackage polysemy-plugin 0.2.0.2 - Disambiguate obvious uses of effects.  https://hackage.haskell.org/package/polysemy-plugin-0.2.0.2 (isovector)
21:34:43 * hackage tracing 0.0.2.0 - Distributed tracing  https://hackage.haskell.org/package/tracing-0.0.2.0 (mtth)
21:45:14 * hackage tracing 0.0.2.1 - Distributed tracing  https://hackage.haskell.org/package/tracing-0.0.2.1 (mtth)
22:50:43 * hackage notmuch 0.3.0.0 - Haskell binding to Notmuch, the mail indexer  https://hackage.haskell.org/package/notmuch-0.3.0.0 (frasertweedale)
23:08:44 * hackage ms-tds 0.1.0.2 - TDS Protocol implemented in Haskell  https://hackage.haskell.org/package/ms-tds-0.1.0.2 (tkmsm)
