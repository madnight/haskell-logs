01:55:28 <juri_> dumb question, i have a list with exactly four elements in it. how do i assign these elements to separate variable names?
01:56:15 <Rembane> juri_: [a,b,c,d] = xs
01:56:37 <Rembane> juri_: It will go boom if xs has a length not equal to four.
01:56:39 <juri_> ah. thanks. :)
01:57:09 <Rembane> No worries. :)
03:45:19 <sicklorkin> I'm upgrading to GHC 8.6.4 and need to write a MonadFail instance.. what are people doing here? `fail = error`? How am i supposed to sleep at night known that's there?
03:46:04 <sicklorkin> I realize it was always there (implicitly) but now that it's explicit i guess i now have to face the issue
03:46:59 <[Leary]> If there isn't an obvious MonadFail instance, don't write one. You should only need one if you're using failing pattern matches in do-block binds.
03:49:06 <juri_> ok, i don't much like the answer i got earlier, because it generates warnings.
03:50:03 <juri_> i have a list with exactly four elements in it. how do i pattern match against it, and assign a variable name to each element?
03:51:22 <sicklorkin> juri_: case fourElems of [a,b,c,d,e] -> f a b c d ; _ -> ...
03:51:44 <sicklorkin> (there are many ways to pattern match
03:52:04 <juri_> and if i'm doing it with guards?
03:53:38 <sicklorkin> I think you should check the doc for that.. 
03:55:28 <[Leary]> If it's PatternGuards, then failing the match will fail the guard and the next case will be tried. But iiuc the only way to make ghc believe that guards are complete is if one of them is `otherwise`.
03:58:37 <sicklorkin> juri_: maybe you want list comprehension?
04:00:00 <sicklorkin> [e |  p <- l , Q ]
04:01:12 <sicklorkin> e is you rexpression, p a pattern, l the list and Q the qualifer
04:02:07 <juri_> ah, it was pattern guards i was looking for.
04:02:13 <juri_> thanks. :)
04:44:52 <Peter_SQ> Hello. anybody around for some basic haskell tips Iḿ stuck with?
04:45:58 <sicklorkin> i can try
04:46:55 <Peter_SQ> ah thanks sicklorkin
04:47:06 <Peter_SQ> I have 2 strings
04:47:10 <Peter_SQ> ab___c
04:47:20 <Peter_SQ> __def_
04:47:34 <Peter_SQ> I want them to combine to 1 string, spaces replaced
04:47:42 <Peter_SQ> so it ends up with abdefc
04:47:51 <Peter_SQ> but I'm stuck :(
04:48:13 <sicklorkin> before telling you the answer, i'd like to know what you've done so far
04:48:35 <Peter_SQ> created a function like
04:48:47 <Peter_SQ> fun :: [String] -> String
04:48:48 <sicklorkin> and let's tings of strings not as string but as lists..
04:48:51 <sicklorkin> *think
04:49:30 <sicklorkin> Does it help you if you change your type? can you have two args instead of one?
04:50:06 <Peter_SQ> That might work, but in the end I want to do more then 2 strings so I tought I started with a list
04:51:13 <sicklorkin> wat about [1,2,4,6] and [0,3,5] what would you do there?
04:52:24 <Peter_SQ> those are numbers not letters?
04:52:31 <Peter_SQ> or should I convert them to numbers first
04:53:23 <sicklorkin> we can use letters..  my qustion was really about the spaces.. is that signficant?
04:53:39 <Peter_SQ> yes, spaces should be replaced with the letters
04:54:23 <sicklorkin> what about "a C G" "F E D B"
04:55:30 <sicklorkin> I uess to me this is just a (cons and sort) but maybe the problem is mean to make you look at it another way
04:55:30 <infinisil> sicklorkin: I'm not sure how being pedantic about possible inputs helps them to a solution. I think we can assume all strings to be of equal size, and only one of them having a non-space character at a given position
04:56:16 <Peter_SQ> its basicially a harder challenge I have to solve here and we are all very basic to haskell
04:56:23 <Peter_SQ> I can put it here if you like a sunday challenge
04:57:24 <infinisil> Peter_SQ: So what I suggest thinking about is: You have a matrix-like representation, where each row corresponds to a string, and each column to a letter position, does that make sense to you?
04:57:43 <Peter_SQ> yeah it does
04:57:47 <Peter_SQ> but there is one extra challenga
04:57:52 <Peter_SQ> the strings need to be off-set
04:57:59 <Peter_SQ> so I can have 2 inputs
04:58:02 <Peter_SQ> abc__d
04:58:05 <Peter_SQ> ef
04:58:22 <Peter_SQ> then the 2nd string needs to have 3 offset to it can combined to abcefd
04:58:29 <infinisil> Well that's a different problem..
04:58:30 <sicklorkin> would the correct output be abcefd? or?
04:58:47 <Peter_SQ> yes
04:59:24 <Peter_SQ> and we have a problem that we can use a max of 181 characters of haskell
04:59:30 <Peter_SQ> for the given function
04:59:54 <Peter_SQ> we think about this for 3 or 4hours now but its hard for us :(
05:00:34 <sicklorkin> you need to find some spaces an then replaces thos espaces with your replacement input?
05:00:55 <infinisil> So you have the first string that has a bunch of '_' in it, and a number of other strings which should be used to fill in the gaps in sequence?
05:00:56 <Peter_SQ> yes, the matching input
05:01:19 <Peter_SQ> all strings can have space gaps in it
05:01:26 <sicklorkin> your replacement text can be variable length?
05:01:31 <catern> what's the name of the subtyping-like feature in Haskell that allows a value of type "A x => x" to be used where a value of type (A x, B x) => x" is expected?
05:01:41 <Peter_SQ> For example, given the strings `"ha  m"` and `"ck e"`:  If you overlay them:      "ha  m"      "ck e"   Shift them by an appropriate offset:      "ha  m"        "ck e"  And combine them, you get `"hackme"`.
05:01:46 <infinisil> Peter_SQ: If you have a full problem description you should show that to us instead of us having to ask questions about it
05:01:51 <Peter_SQ> yes
05:01:54 <Peter_SQ> I can hold on
05:02:11 <sicklorkin> I think the function is called overlay..
05:03:15 <Peter_SQ> https://pastebin.com/bg30yGVd
05:03:22 <Peter_SQ> is the problem description
05:03:38 <Peter_SQ> if you like to use as your own haskell problem have fun with it :)
05:03:53 <Zer000> http://hackage.haskell.org/ is down?
05:04:34 <sicklorkin> looks like it
05:05:09 <infinisil> Peter_SQ: "or the data we're working with, the following rules seem to always hold:"
05:05:26 <infinisil> Can you show us this data? It's hard to get the gist of it without seeing a bunch of examples
05:07:02 <Peter_SQ> no this is the only example we get to give
05:07:04 <Peter_SQ> :(
05:07:20 <Peter_SQ> there is a online machine where you can submit your haskell function and it gives OK or not
05:08:18 <infinisil> What's this "data you're working with" then?
05:08:37 <Peter_SQ> its a puzzle data we are not aware off.  
05:08:59 <Peter_SQ> our challenge is to create the haskell fucntion :)
05:09:11 <infinisil> Hm I see
05:09:22 <Peter_SQ> part of a bigger hack competition
05:09:42 <infinisil> Peter_SQ: And it's okay to get external help?
05:10:07 <Peter_SQ> yes, we can enlist as much help as needed. And if other competitors are on this channel they can sneak in as well if needed
05:10:23 <infinisil> Hm alright
05:11:26 <infinisil> Peter_SQ: So one idea is to brute force it, by trying out all shift amounts of the second string
05:11:42 <Peter_SQ> https://capturetheflag.withgoogle.com/#challenges/
05:11:44 <sicklorkin> i would probably do uncurry (++) .ajoin *** splitOn (' ') a b
05:11:44 <infinisil> Have you tried out something like that?
05:12:00 <sicklorkin> oh there's a zip somewhere in there
05:12:23 <Peter_SQ> click misc / Code Golf
05:12:32 <Peter_SQ> there is the actual same challenge 
05:13:22 <infinisil> sicklorkin: I know we haskellers like to solve challenges, but in such a situation, giving small tips or nudges in the right direction is much better than just straigh up telling an almost-solution 
05:13:36 <Peter_SQ> get all strings -> count all charaters, make matrixes of all strings being padded with spaced to the total lengt. Then shift one by one by chekcing transposion if there is a fit
05:13:39 <dmwit> > filter(not.isSpace).concat.transpose$["ha  m","  ck e"]
05:13:41 <lambdabot>  "hackme"
05:13:47 <Peter_SQ> thats our though now
05:14:21 <andreabedini>  /set irc.look.buffer_switch_autojoin off
05:14:21 <Peter_SQ> we cannot win anything at all, we are in the low end of the teams there :)
05:14:23 <andreabedini>  /set irc.look.buffer_switch_join off
05:14:23 <dmwit> > [c|cs<-transpose["ha  m","  ck e"],c<-cs,c/=' ']
05:14:26 <lambdabot>  "hackme"
05:14:34 <andreabedini> opsie
05:15:09 <infinisil> dmwit: The problem changed meanwhile, you're giving the solution to the old one
05:15:29 * dmwit shrugs indifferently
05:15:50 <infinisil> Peter_SQ: I'd try just writing a function to combine 2 strings at first
05:15:54 <Peter_SQ> but those solution with the matrix and transpostion will give us more then 180 charachters we think
05:16:17 <Peter_SQ> We noticed that we are allowed to use Debug.SimpleReflect  but don't know how to use that
05:16:56 <Peter_SQ> yeah we'll go and write some more. I'll stay here for a while now :)
05:17:38 <infinisil> Peter_SQ: With 2 strings only this shift-until-it-fits thing should work fairly well, and then you should be able to use this to combine any number of strings
05:18:07 <Zvpun> I would like some help with my Parsec parser (https://pastebin.com/R4yTXw3Q). I would like to simplify it to make it less dense. Could you please have a look at it?
05:18:11 <infinisil> But it might not be the thing they're looking for, since it might not produce a solution
05:18:23 <infinisil> Depending on their problem inputs and expected outputs which we don't know..
05:18:37 <infinisil> I'd say that's a heavily underspecified problem
05:19:05 <sicklorkin> Zvpun: what are your delimiters?
05:19:31 <sicklorkin> Zvpun: is end eof or space?
05:20:24 <sicklorkin> Zvpun: I think you may want to look at usng cominators and simplifin what is is you're parsing.. i.e. many1 declimal <* eof
05:20:32 <Zvpun> sicklorkin: My `end = optional endOfLine *> eof`.
05:21:10 <sicklorkin> if yo're looking to parse a list then use the combinators for this
05:22:47 <sicklorkin> ints :: [Int] ; many1 decimal <*eof (or some if that's better).. or if you want words separated by spaces then just tweak the replace the decimal parser with a word parser..
05:23:33 <sicklorkin> If you are writing your parser by hand, good on ya.. if you are using a parckage parser then you may wanna use megaparsec.. iv'e found it very nice to work with.
05:23:41 <Zvpun> The full parser is here (https://pastebin.com/kMjdM8Z5). I was hoping it would not matter (just to ask a smaller question)
05:24:23 <Zvpun> If possible I would like to understand this particular recursive situation
05:25:20 <sicklorkin> I never think of parsers in terms of recursion..
05:25:21 <Zvpun> If a parser calls itself, there needs to be a terminating case. And so far I only know about `f = end <|> do ...; recurse <- f`.
05:25:40 <sicklorkin> this is what many1 or some is for
05:26:39 <Zvpun> as far as I understand it, those are for lists, but in more complex situations one might want to recurse
05:26:45 <sicklorkin> abc;abc;abc;abc; == sepBy parser $ some (char ';')
05:28:04 <Zvpun> yes, but my input is not a list.
05:28:23 <sicklorkin> no... parser input is always a string of bytes
05:28:34 <sicklorkin> starting from 0 ... N
05:29:05 <sicklorkin> you apply you rparsers to each block of input until your parser gives up
05:29:21 <Zvpun> I am also asking because in "Monadic Parsing in Haskell" (http://www.cs.nott.ac.uk/~pszgmh/pearl.pdf) on page 5 they have `string "" = return ""; string (c:cs) = do { char c; string cs; return (c:cs) }` and I want to know how I can emulate that particular pattern.
05:30:24 <Zvpun> Since my `p4` seems to work, I am looking for advice on how to simplify it (I don't see how I could apply sepBy, etc. in this case.)
05:30:48 <sicklorkin> what is P4?
05:31:04 <Zvpun> https://pastebin.com/kmxh72WT its defined here
05:31:23 <sicklorkin> no i mean what does this map to in the pearl paper you linke dto?
05:31:27 <Zvpun> and one smaller question I have is how to deal with the recursive situation, like `string` in the paper.
05:31:33 <Zvpun> ah
05:31:55 <Zvpun> I think p4 is similar to `string`
05:33:42 <Zvpun> `string` is a parser that calls itself and it has a terminating case. The only way of mapping this I know so far is the `f = end <|> do ... f`. Maybe there is nothing else one can do.
05:33:52 <sicklorkin> many 1 char <* char ' '
05:34:51 <sicklorkin> ssorry i couuldn't hep ya
05:35:35 * sicklorkin needs to get back to contest. 
05:39:41 <statusbot> Maintenance update: Downtime due to hardware migration within datacenter -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5d0f72db128dee0b723f9dc4
05:45:10 <Peter_SQ> :) thanks. we are working as well here
06:31:00 <kraem> I'm trying to learn FP through Haskell and http://learnyouahaskell.com - I'm trying to define a function in ghci with `removeNonUppercase :: [Char] -> [Char]` but I'm getting an error but can't understand the error. Is it not allowed to define a function in that way in ghci?
06:32:11 <infinisil> kraem: In order to input multiple lines, which you need for this, you should first type `:{` and press ender
06:32:13 <infinisil> enter*
06:32:33 <infinisil> Then input your multiple lines, like the type and the definition, and then type `:}` and enter
06:34:48 <kraem> infinisil: alright. so the function definition is not "complete" with the first line? the compiler is still considering the function declaration as uncomplete and needs the function body as well? am i understanding it correctly?
06:35:03 <geekosaur> alternately, enter on one line wiith semicolons between the "lines" if it's not a direct continuation (as here: first line is type signature, not the actual definition)
06:35:20 <geekosaur> also note that haskell doesn't require them to be together
06:35:52 <geekosaur> in  a file, one could be at the top and the other at the bottom, haskell doesn't care. but ghci has to care because it can't kno what you'll type later
06:43:31 <hpc> for extra fun, use CPP and put all the type signatures in a .h file
06:45:50 <kraem> thanks. got it working with ':{' and ':}'. geekosaur: did you mean like this 'removeNonUppercase :: [Char] -> [Char] ;'?
06:46:07 <geekosaur> yes
06:46:35 <geekosaur> but not if your definition extends over multiple lines without using do or let (those again require semicolons)
06:46:37 <geekosaur> but something like
06:46:43 <geekosaur> foo = some long expression ++
06:46:49 <geekosaur>     something else
06:46:57 <geekosaur> a semicolon would be an error there
06:47:40 <geekosaur> (look up Haskell layout, which is how one translates between multiline and flattened forms)
06:48:09 <kraem> geekosaur: ahh.. i needed to put the following line after the ';' on the same input-line :)
06:48:26 <geekosaur> right
06:48:33 <kraem> thank you :)
06:48:53 <geekosaur> >> foo :: String -> String; foo (x:xs) = ...; foo [] = ...
06:49:33 <geekosaur> (I used ">>" becuase the bot reads and evaluates lines starting with "> ". and the bot is expressions only
06:55:46 <kraem> thanks!
07:15:01 <qwebirc18043> Any update on the status of http://hackage.haskell.org/? I'm getting 503 for the last few hours. Is there a feed to follow for updates?
07:16:04 <cocreature> qwebirc18043: https://status.haskell.org/
07:16:27 <qwebirc18043> Thanks!
07:35:50 <Peter_SQ> We have a solution but way too long (>1000 chars) :(
07:50:49 <Phyx-> davean: that's not strictly true, there's a large part of the IO manager written in C in the RTS, particularly for non-threaded support
07:51:18 <Phyx-> c_wraith: well, IOCP support is coming soon :)
07:51:29 <davean> Phyx-: non-threaded is entirely different, and IMO is defactor broken :/
07:51:51 <davean> I don't even think of the single threaded runtime as a thing because hackage doesn't work with it
07:52:19 <davean> but yah
07:52:41 <davean> you are right about single threaded
07:54:16 <Phyx-> davean: well, we agree that it is broken, and I wish it wasn't there :(
07:56:10 <davean> I wish the way it was broken was at the very least apparenty at compile time
07:57:01 <Phyx-> there is a proposal to make GHC warn when a threaded primop is used such as forkOS
07:57:34 <Phyx-> but the non-threaded rts is just a giant hack on it's own right. And every platform has a different hack for it
07:57:45 <davean> it would help. I've lost a pile of time to debuging builds that were done single threaded that aren't working.
07:58:03 <davean> yah it should jsut go
07:58:17 <davean> It evectively doesn't exist already in a useful form
07:58:42 <davean> Theres no way to know which packages just won't work on it without looking under the hood
07:58:45 <davean> and many don't
07:59:03 <merijn> Many seems exaggerated
07:59:21 <Peter_SQ> we have some code now for the challenge, but way too long
07:59:29 <Peter_SQ> could a few help make it shorter?
08:00:27 <davean> merijn: I don't think I've ever had a non-trivial dependency tree free of one
08:00:51 <davean> merijn: when i've tried the single threaded run time I had to take extreme care and recode a lot of stuff
08:00:53 <merijn> You must write very different programs from me ;)
08:01:32 <davean> ok
08:02:05 <Peter_SQ> https://pastebin.com/pnnB2R8p
08:02:16 <Peter_SQ> our code for the challege but way too long
08:02:29 <Peter_SQ> could one of you see some optimalizations for a few functions to start with?
08:06:23 <geekosaur> davean, merijn, it's worse than that because forkProcess is broken in the presence of multiple threads (this is not a Haskell or ghc specific issue)
08:06:59 <davean> geekosaur: forkProcess doesn't seem a thing you can use without a lot of magic in Haskell :)
08:07:43 <geekosaur> it's just making explciit what's also true elsewhere
08:07:56 <geekosaur> process forking and OS threads are not compatible
08:08:16 <geekosaur> most languages, you can get away with it most of the time. haskell makes the problems more expliit
08:08:30 <davean> I'd say they're extremele complicated and require process global knowlege
08:08:32 <geekosaur> *explicit (twice, sigh)
08:08:51 <geekosaur> I'd have to dig for details, it's somewhat subtle but it's impossible to get 100% correct
08:09:23 <davean> Well, theres a lot of things one *linux* that are about impossible to get 100% correct with forking
08:09:40 <geekosaur> on any system with _fork_ as such
08:09:43 <davean> so which system call semantics are we talking about forkProcess under?
08:09:45 <geekosaur> (windows does not have fork)
08:09:55 <geekosaur> it has spawn which is a different thing
08:10:04 <[exa]> docs say "no other threads will be copied to the child process", that's pretty good isn't it?
08:10:12 <davean> [exa]: not really
08:10:18 <davean> [exa]: consider filehandles for example
08:10:19 <geekosaur> cloning a process, as opposed to creating a new one ex nihilo as it were
08:10:20 <merijn> [exa]: Sure, unless one of those threads holds a lock/mutex...
08:10:24 <geekosaur> ^
08:10:28 <geekosaur> that's a large prt of the problem
08:11:33 <[exa]> davean: it kills the open filehandles?
08:12:10 <geekosaur> they remain. but a filehandle is more than the global state
08:12:22 <davean> [exa]: Actually they're dup(2)ed-ish
08:12:38 <davean> [exa]: combine this with special filehandles like epoll file handles!@
08:12:47 <Peter_SQ> append_spaces :: (Int, [String]) -> [String] append_spaces (maxl, []) = [] append_spaces (maxl, (x: xs)) = (x ++ (replicate (maxl - length x) ' ')) : append_spaces(maxl, xs)
08:12:56 <Peter_SQ> this could be way shorter but we donno now
08:12:58 <Peter_SQ> how
08:13:00 <davean> filehndles absolutely can not be closed on fork
08:13:07 <geekosaur> there's OS global state (file descriptor), process global (*usually* the handle abstraction), thread local (current buffer state depends on what thread(s) have been doing what)
08:13:24 <[exa]> davean: well these need to get reinitialized, but certainly that's something you can't expect from runtime to get right
08:13:28 <Peter_SQ> we dont thing globe wave :(
08:13:48 <davean> [exa]: reinitialized? epoll handles?
08:13:52 <davean> uh
08:14:03 <[exa]> "taken care of in a special way"
08:14:23 <davean> [exa]: if you shut down events on them, you miss notifications
08:14:37 <davean> you can't fix missed notifications
08:14:39 <[exa]> like, if I close everything manually, then call forkProcess and then reopen everything, it should just work, right?
08:15:04 <davean> [exa]: if you close everything, theres a pile of applications that *can not be correct*
08:15:48 <[exa]> assuming that I am able to close everything correctly, ofcourse
08:17:02 <davean> [exa]: that is basicly equivilent to saying "If my process does nothing" because filehandles are how processes do anything on a POSIX based system
08:17:31 <davean> so there has to be a time period in which your process is litterly shut down in a semantic way
08:19:08 <davean> geekosaur: I know of nothing on *POSIX* that prevents you designing correct forking processes though
08:19:17 <davean> though you do have to design them from the ground up that way
08:19:41 <davean> I do know some cases one *linux* where you can't
08:20:12 <davean> (for a similarly extended system example, I do not know such cases on FreeBSD)
08:20:37 <[exa]> there's some low-level framework for making filedescriptors and similar stuff as dup-on-fork or with similar flags, right? (I can't find its name now though)
08:20:53 <merijn> You're thinking of CLOEXEC, which applies on exec, not on fork
08:22:36 <[exa]> oh so it was probably CLOEXEC. Thanks :]
08:23:02 <[exa]> replicating something like that in Haskell runtime isn't possible?
08:23:33 <davean> [exa]: it *is* possible, IMO, it requires a lot of global locks though and a careful design, and long pauses across the forks.
08:24:07 <davean> and it still wouldn't work on linux
08:24:19 <[exa]> why not?
08:25:15 <[exa]> btw could we design a better process-spawning primitive? forking _is_ weird in functional context
08:26:09 <Eduard_Munteanu> Um, I haven't seen true forks used much.
08:26:28 <Eduard_Munteanu> Because usually you use threading.
08:26:43 <davean> Eduard_Munteanu: threading is super modern, like post-2004 shit
08:26:51 <merijn> [exa]: posix_spawn already exists
08:26:53 <Eduard_Munteanu> Er, in Haskell, I mean.
08:28:49 <davean> [exa]: because linux choose a bunch of semantics for its extensions that it isn't clear how you could clean up on the other side of the fork without missing events. I've never heard of a solution but I also haven't looked hard because linux choose a bunch of semantics they mean you just can't do things correctly at all in the first place (see inotify) so it wasn't super worth trying to find a lawyery way
08:28:51 <davean> around that no one had ever tried before :)
08:29:39 <[exa]> davean: oh inotify and pals. I wouldn't worry about those
08:29:51 <davean> [exa]: they're damn important and work on every other system!
08:30:04 <davean> kqueue can do inotify's job without error
08:30:38 <[exa]> davean: agreed, I just want to point out that just supporting kqueue is a better option
08:30:57 <Eduard_Munteanu> This reminds me there's no exec()-like call in PHP. Apparently it's fine to muck with arguments to pass them as a shell expression. Which shell? I have no clue.
08:30:58 <davean> [exa]: sure, and it avoids the epoll fork issues and some other shit
08:31:31 <Eduard_Munteanu> There's even a very old bug that's not been fixed ever for that.
08:31:46 <davean> [exa]: but kqueue came well before epoll so its not like linux could have writen semantics at least as good as kqueue, io-completion ports, or any of the other predicesors
08:31:59 <merijn> Eduard_Munteanu: That just means it's system(2) instead of exec(2)
08:32:16 <merijn> davean: linux devs insists on reinventing the wheel poorly
08:32:25 <davean> merijn: Litterly no one else managed to fuck it up!
08:32:29 <[exa]> davean: you seem like you wouldn't like kdbus either. :]
08:32:33 <Eduard_Munteanu> merijn, yes, except it has some functions for shell escaping.
08:32:37 <davean> How can you be last to the game and be the worst?!
08:33:17 <Peter_SQ> Ok we are down but still need a few tips for map / filter shorter 
08:33:19 <Peter_SQ> https://pastebin.com/R3w96BuM
08:33:26 <Peter_SQ> hope anybody can give some hints
08:33:57 <davean> Like epoll was something like 10 years past when people had solved this problem
08:34:09 <davean> how do you get worse in 10 years of doing something sucessfully?
08:34:43 <davean> I actually have a haskell package the fails its tests only on linux due to its tests being complete enough to spot these issues.
08:35:14 <davean> (its inotify related)
08:37:15 <statusbot> Maintenance update: Hackage is up & operational again! -- http://status.haskell.org/pages/maintenance/537c07b0cf1fad5830000093/5d0f72db128dee0b723f9dc4
08:38:47 <Peter_SQ> infinisil: we have some solutions but we still need a lot of compression. anyt time?
08:39:10 <Eduard_Munteanu> Found it, yeah, this is old... https://bugs.php.net/bug.php?id=10937
08:39:15 <[exa]> davean: what system are you running btw? (guessing freebsd)
08:39:28 <davean> [exa]: I have some FreeBSD, I have some other stuff
08:39:33 <davean> I ahve some linux
08:39:57 <davean> onec you start assuming you might get byzantine failures at the system level you can use linux again
08:40:38 <[exa]> :]
08:42:19 <infinisil> Peter_SQ: You could write as as a fold
08:42:25 <davean> I use a mix of things though. I expect my single system stuff would be described as FreeBSD unless the software is specificly designed for linux
08:42:42 <davean> on the server side that is
08:42:49 <davean> on the client side I use linux exclusively
08:42:56 <infinisil> Peter_SQ: Same with cS I think
08:44:03 <Peter_SQ> infinisil: coud you give us an example, fold is not familiar with us :(
08:44:49 <infinisil> Peter_SQ: You can find it in the docs, functions foldl/foldr
08:45:11 <infinisil> You can reduce cS2 to `cS2 = cS . transpose`
08:45:40 <d34df00d> Hmm, why doesn't MonadIO m imply MonadBase IO m?
08:45:41 <Peter_SQ> ok well look into fold now :)
08:45:59 <d34df00d> And I just tried writing such an instance and got fundeps violations that I don't understand:
08:46:14 <d34df00d> https://bpaste.net/show/97d94e7dcf21
08:47:48 <lyxia> d34df00d: because not all m which might be the second parameter of MonadBase have IO as their base
08:48:10 <lyxia> and that is what this instance is saying
08:48:46 <d34df00d> But... Doesn't MonadIO m imply that IO is at the bottom of the stack m is representing?
08:48:48 <lyxia> it also overlaps with half of MonadBase's instances
08:49:20 <lyxia> m is not necessarily a stack of transformers
08:49:54 <d34df00d> Then I still don't understand.
08:50:17 <d34df00d> MonadBase IO m requires that IO actions could be lifted to m.
08:50:22 <d34df00d> MonadIO m says precisely that.
08:50:27 <lyxia> MonadBase's assumption is that m is of the form (t1 (... (tn m0) ...)), then it gives you an instance MonadBase m0 m
08:50:33 <d34df00d> So I don't follow why, in theory, I cannot write such an insatnce.
08:50:53 <d34df00d> Hmmm.
08:50:54 <lyxia> Half of the problem is about the way instance works
08:51:08 <d34df00d> But I've never seen any useful instances of MonadIO that don't have IO at their bottom!
08:51:20 <lyxia> it's not just about the fact that you can lift actions
08:51:36 <lyxia> the monads must have a very particular shape
08:51:52 <lyxia> and the instances must resolve in a very particular way
08:52:01 <d34df00d> Oh, so I guess it just wasn't immediately obvious to me from the type class definition alone.
08:53:01 <Peter_SQ> we think we can't do it in 181 bytes :(
08:53:15 <d34df00d> Ok, let's put it this way to avoid XY problems: is it possible to use lifted-base's exceptions (namely, handleJust) to work in a MonadIO (perhaps with some additional constraints to account for the Control part)?
08:53:26 <Eduard_Munteanu> I guess you could consider a restricted IOT applied to, say, Maybe, which isn't really IO at the very bottom.
08:53:46 <d34df00d> I have a monadic stack that has IO, Reader and some custom monad of mine, and I want the exception handler to work in that monad.
08:54:12 <Eduard_Munteanu> d34df00d, is your monad a transformer?
08:54:25 <davean> d34df00d: have you considered https://hackage.haskell.org/package/exceptions-0.10.2/docs/Control-Monad-Catch.html ?
08:54:39 <d34df00d> Eduard_Munteanu: yep.
08:54:55 <davean> d34df00d: will it always be? :)
08:55:03 <Eduard_Munteanu> The way it's usually set up, the outermost transformer possible catches the exception.
08:55:48 <d34df00d> davean: probably yes. And thanks for the link, I didn't know about that one!
08:56:23 <d34df00d> Right now I have https://github.com/0xd34df00d/cohabr/blob/master/app/Scraper/Main.hs#L68-L99 (note the `handler` at the bottom of the selection).
08:56:30 <davean> d34df00d: by removing the stack you often get better performance, by changing the stack but leaving the same interface you often get better testing ... etc
08:56:30 <d34df00d> SqlMonad is defined unsurprisingly as https://github.com/0xd34df00d/cohabr/blob/master/src/Cohabr/Db/SqlMonad.hs#L27
08:56:43 <d34df00d> Custom metrics nonsense is https://github.com/0xd34df00d/cohabr/blob/master/src/Cohabr/Metrics.hs#L162-L193
08:56:43 <davean> so basing it on assuming IO on the bottom can get annoying in practice
08:56:53 <Eduard_Munteanu> e.g. in EitherT e IO a, you'll get the failure in the EitherT component, and you could *choose* to throw it in IO or not.
08:58:13 <d34df00d> The problem is that runSqlMonad _must_ return IO, since that's how Database.Postgres.Simple works.
09:03:55 <Berengal> Does lazy evaluation recover the complexity lost to immutability /always/, or just for some problems?
09:06:43 <d34df00d> davean: yeah, that kinda works, I guess!
09:07:04 <d34df00d> I changed runSqlMonad's action type to forall m. (SqlMonad m, MonadCatch m) => m a, and that's it!
09:08:07 <lyxia> Berengal: what lost complexity? isn't immutability simpler than mutability, since it amounts to not using mutability
09:08:27 <Berengal> lyxia: I'm talking about algorithmic complexity
09:08:32 <d34df00d> Now I just need one more instance for my metrics monad transformer...
09:08:35 <Berengal> big-O
09:09:27 <lyxia> no lazy evaluation doesn't solve that
09:09:45 <davean> lyxia: it does in many cases
09:10:31 <Berengal> But does it for all?
09:10:41 <d34df00d> I believe Okasaki's Purely Functional Data Structures explains quite deeply on that.
09:10:50 <d34df00d> But I haven't got to that part yet :(
09:10:53 <davean> I've certainly never seen a proof of equivilency down to O(1) complexity, but that doesn't seem like an easy proof at all. I've also never seen a disproof. I wouldn't know.
09:11:10 <davean> d34df00d: it gives ways to recover the complexity but thats different than a proof of complexity eqivilence
09:11:29 <davean> Berengal: I expect thats an open problem
09:11:41 <Berengal> That's what I suspected
09:12:03 <Berengal> In a sense, lazy evaluation is just restricted mutability
09:13:37 <davean> Berengal: I've never done a lit search for it though.
09:15:07 <Berengal> I've only ever found Okasaki's PFDS and discussions around that, and as you said, it only solves some cases
09:16:03 <davean> Berengal: I mean thats algs work, not complexity proofs
09:16:33 <Berengal> exactly
09:16:46 <c_wraith> last I saw, the question was still open. on the other hand, it's easy to prove an upper bound of an extra log n factor. that's usually not too bad, if it's inescapable.
09:17:23 <davean> c_wraith: yah, we've had that proof I think my entire life
09:17:39 <davean> a log factor is moderately large in a proof though :)
09:17:49 <Berengal> And in a more practical sense there's always the ST monad
09:18:11 <davean> I think Berengal is asking a theoretical question, not a practical one
09:18:58 <Berengal> yes
09:36:45 <solonarv> if you are using purely functional data structures (i.e. you cannot lean on primitve arrays, only ADTs and functions) you can't have better than log n indexing
09:36:51 <solonarv> at least that is the current state of research
09:47:30 <lyxia> yes, lazy evaluation doesn't make the log factor disappear
09:48:16 <alx741> hello all. I was trying to `cabal v2-build` a project but got conflicts with base, is new to me that base's versions are fixed with GHC's versions (is this correct?), I switched to ghc-8.4.4 using `ghcup set 8.4.4` and the project compiles. How can I associate a compiler version to the project?  
09:48:35 <merijn> alx741: Base has always been a hardwired part of GHC
09:49:01 <merijn> alx741: You can use "v2-configure" with -w to specify a specific ghc
09:49:02 <alx741> cabal's `with-compiler` option seems the one (?) but I'm not sure where to put it in the .cabal file, and don't know how to verify it's taking effect either
09:49:32 <merijn> alx741: You don't put it in the cabal file, you put it in cabal.project (or cabal.project.local via v2-configure)
09:49:59 <merijn> alx741: so "cabal v2-configure --with-compiler=path/to/ghc" which will write a cabal.project.local and use that compiler from then on with v2-build
09:50:35 <alx741> merijn: oh! why is that though? I though cabal.project is for multi-package projects
09:51:22 <merijn> alx741: No, cabal.project is for persistent v2-build configurations, if there is no cabal.project it will simply use an implicit default one
09:52:11 <maerwald> conflicts with base, you mean upper bounds?
09:52:28 <merijn> alx741: Where cabal.project is for configuration that is for "everyone" (so should always be set and committed to the repo) and cabal.project.local is for, well, local development tweaks like "which ghc to use"
09:53:19 <maerwald> --allow-newer=base might work, most base upper bounds are incorrect
09:55:14 <alx741> merijn: hmm so `cabal v2-configure -w ghc-8.4.4` created a "cabal.project.local" file, should I move it to "cabal.project"?
09:55:39 <alx741> maerwald: going to try that out too
09:57:28 <merijn> alx741: No, you can just leave it
09:57:42 <merijn> alx741: It always looks for bot
10:00:04 <alx741> oh right! I should re-read the user guide... Thanks guys, I think I won't be needing stack anymore with this :) 
10:00:13 <davean> maerwald: Its not that they're incorrect, they're specified more than it turns out to be required.
10:00:55 <davean> maerwald: but that can't be known before a new base is released, and it can be incorrect to have them open.
10:04:20 <maerwald> davean: an upper bound is incorrect if it is too tight
10:04:43 <maerwald> so when projects, 6 months after a new ghc release, still have tight upper bounds, then they are incorrect
10:05:08 <davean> maerwald: under what semantics is it incorrect?
10:05:27 <maerwald> what I just said :>
10:05:43 <davean> Bounds say where the package is known to be correct
10:06:02 <maerwald> that's what they shouldn't do, but anyway
10:06:06 <maerwald> That's a different discussion
10:06:12 <maerwald> the point is that base upper bounds are often too tight
10:06:23 <maerwald> and it often helps to do --allow-newer=base
10:06:30 <davean> Often tighter than they *need* to be, I can't think of a sensible definition where overly tight is incorrect.
10:06:42 <Clint> i agree with maerwald
10:06:50 <davean> Clint: can you explain why?
10:07:12 <Clint> davean: if merely patching the .cabal file to loosen the upper bound results in a working build, the upper bound is incorrect
10:07:27 <davean> Clint: but how do you know the build ends up working?
10:07:33 <maerwald> you build it
10:07:33 <Clint> you build it
10:07:34 <davean> the cabal file informs you what is known to work
10:07:34 <maerwald> xD
10:07:38 <maerwald> hahaha
10:07:40 <davean> building does *not* tell you if it works
10:07:48 <davean> buildign tells you if it compiles
10:07:52 <davean> semantic changes are not covered
10:08:00 <davean> thats what version numbers in the first two positions cover
10:08:06 <Clint> this is not useful
10:08:24 <davean> Clint: its saved me a bunch of problems personally
10:08:28 <maerwald> davean: here is a secret: PvP allows people to break semantics of existing functions without renaming or changing signature or types... but in practice NO ONE does that, because no one tests his packages that in-depth
10:08:30 <maerwald> :)
10:08:53 <davean> maerwald: my packages are tested enough to not pass tests on linux but on all other platforms :-p
10:08:57 <merijn> maerwald: Eh, no it doesn't
10:09:01 <maerwald> if people did that, they would get yelled at a lot (imagine Aeson randomly breaking their stuff and then pointing out hey, PvP right?)
10:09:03 <davean> maerwald: I guess we have different standards for correctness
10:09:15 <davean> I have 100% branch coverage on most of my packages
10:09:25 <davean> and mroe tests than for that to cover platform semantics
10:09:48 <merijn> maerwald: Changing semantics is clearly a breaking change
10:09:59 <maerwald> merijn: yes and you bump version
10:10:13 <davean> Which covers it
10:10:21 <davean> every major verson change entails a code review
10:10:38 <maerwald> no one does that in practice
10:10:42 <davean> I do
10:10:48 <davean> And you can see it in my packages
10:10:58 <merijn> maerwald: Breaking changes are covered in the PVP, so saying that's allowed is just wrong. It's not clearly spelled out, but it's definitely wrong to change semantics without a PVP bump
10:11:02 <davean> I even do it on most of the packages I submit patches to
10:11:30 <maerwald> merijn: a PvP bump?
10:11:31 <davean> And I submit patches to a lot of packages
10:12:01 <merijn> maerwald: breaking change requires changing A.B >= previous A.B
10:12:06 <davean> This is really a minimal standard of care
10:12:12 <maerwald> merijn: yes, did I say something else?
10:12:17 <davean> and well covered by the PvP
10:12:27 <merijn> maerwald: you said changing semantics isn't covered by the PVP
10:12:32 <maerwald> merijn: no
10:12:40 <davean> merijn: no he didn't
10:12:43 <davean> he said it allowed it
10:12:51 <davean> which is correct - theys its job in those positions
10:13:22 <maerwald> my point is that --allow-newer is fine :) and I stand by that
10:14:09 <davean> maerwald: its fine with a code review 
10:14:22 <davean> base is one of the safer packages to do it on blind
10:14:38 <maerwald> no one does code review on his dependencies :P
10:14:54 <davean> I do
10:14:56 <maerwald> I knew you would say that
10:14:57 <davean> I always do
10:15:15 <davean> Its a critical part of being a reasonable maintainer
10:15:46 <maerwald> Not sure how that pans out on a big project :)
10:16:02 <maerwald> people generally just bump upper bounds, see if it builds, run test suite, maybe run the application (if any)
10:16:04 <maerwald> and push
10:16:08 <maerwald> which is reasonable
10:16:14 <maerwald> unless you're into crypto or whatever
10:17:01 <davean> Its really not that big a deal. Once you have done the first you just have to watch the commits below you
10:17:22 <davean> I tend to sit on top of lens, warp, reflex and their trees
10:17:35 <maerwald> I think it's a big deal on a 100k LOC codebase with a a few hundred dependencies
10:17:43 <davean> fsnotify for example is a problem and I have an internal patch set to fix its failings but not enoug for general release
10:18:20 <davean> its also why I sit on top of machines for example
10:18:22 <maerwald> wonder if people at Obsidian do that
10:18:26 <maerwald> or typable
10:18:28 <maerwald> I doubt it
10:18:42 <maerwald> you're probably the only one :P
10:19:59 <davean> If you use a package you own all its flaws on code paths you use
10:20:44 <maerwald> Well, I've never seen anyone do that, so...
10:20:55 <maerwald> And the ecosystem did not crash
10:21:05 <davean> It has for me, thats why I started doing it
10:21:18 <davean> for example I think tls is still remote crashable
10:21:24 <maerwald> Then you should know that PvP was a bad choice ;)
10:21:28 <davean> (foudn that one before it bit me)
10:21:41 <maerwald> tls is it's own problem, for different reasons
10:22:04 <davean> do you mean the protocol of the library? I'm refering to the haskell package here BTW
10:22:11 <maerwald> Yes me too
10:22:16 <davean> Ok good
10:22:32 <davean> just wanted to be clear
10:23:05 <maerwald> Since https://github.com/vincenthz/hs-tls/issues/117 I avoid it as much as possible
10:23:21 <maerwald> But I don't see how that relates to versionin
10:23:37 <davean> Getting all the important patches applied upstream is a major issue for getting packages released for me
10:24:01 <davean> but its important for the correctness and reliability of my software
10:24:04 <davean> so I can actually sleep at night
10:24:15 <davean> There is nothing I hate more than being woken up with a service outage
10:24:59 <davean> and if something goes down and doesn't recover its self and I'm offline for weeks? Which I do
10:25:21 <maerwald> Well, if you get paid for manually reviewing all your dependencies, that's nice
10:25:26 <maerwald> Most people probably are not
10:26:20 <basic> helloooo, im trying to build ghcjs right now
10:26:24 <maerwald> Demanding that as status quo from open source package maintainers is also a bit weird imo
10:26:46 <basic> and i get the message that happy of a certain version is required, but i have installed it via cabal, so what's the matter :o
10:28:39 <cocreature> basic: have you added ~/.cabal/bin to your PATH after installing it?
10:29:20 <basic> no
10:30:49 <basic> cocreature: now i did, and it doesnt work :(
10:31:00 <basic> if i do "which happy" it does locate it
10:31:38 <basic> configure: error: Happy version 1.19.4 or later is required to compile GHC.
10:31:49 <basic> happy -v gives me 1.19.9
10:32:42 <cocreature> basic: are you running these commands (i.e. which happy and whatever you use to build ghcjs) from the same terminal?
10:32:48 <cocreature> also how exactly are you trying to compile ghcjs?
10:33:09 <basic> yes, ofcourse
10:33:21 <basic> i am trying to execute the makePackages.sh as described in the github
10:34:32 <basic> https://ibb.co/kcWpvFX
10:36:14 <cocreature> hm not really sure what is going wrong here. maybe try something like a "make maintainer-clean" in the ghc directory
10:37:34 <alx741> It looks like .cabal now supports extracting out common dependencies... does this make hpack irrelevant now? 
10:38:46 <basic> cocreature: i did, same error remains
10:38:53 <basic> but i need to go for a second sorry ;;
10:41:51 <Athas> alx741: depends on your tolerance for manually populating the exposed-modules list.
10:43:44 <merijn> alx741: Basically, yes
10:47:59 <cocreature> the main differentiators of hpack at this point are YAML vs cabal’s syntax and globbing for modules. Whether those two things are crucially important or a terrible idea is up for debate :)
10:50:25 <monochrom> One person's crucially important is another person's terrible idea. Just look at C pointers.
10:51:05 <alx741> Athas: forgot about that
10:52:33 <cocreature> monochrom: and they will forever try to convince each other that their pov is the right one :)
10:53:25 <hyperisco> What if we argue both opinions can coexist and not interfere?
10:53:46 <c_wraith> then everyone hates you for not taking their side.
10:53:46 <monochrom> I wonder whether I should call them pointful debates or pointless debates.
10:54:05 <monochrom> Yes this is why everyone hates me.
10:54:29 <Rembane> Co-pointful.
10:58:17 <fendor> i can say, I prefer to write package.yaml, but I prefer to read .cabal and tooling is also better for cabal files 
11:06:04 <Athas> I wish I could just use .cabal.  YAML is an abomination, and it is silly to have two formats.
11:08:22 <fendor> Athas, maybe another splitting of the community will do the trick! get ready for dhall!
11:09:07 <Heffalump> surely you can just ignore yaml? Any valid package would have to generate a .cabal file anyway.
11:09:50 <solonarv> ah, but they might not check it into source control
11:11:16 <Heffalump> but how would they upload to hackage?
11:11:33 <Athas> I use 'stack upload', which uploads the .cabal generated from my package.yaml.
11:12:11 <solonarv> oh, sure - hackage ≠ source control
11:12:33 <solonarv> although there is a related problem of people not writing any version bounds, because stack pins all the versions anyway
11:12:55 <solonarv> this makes the package practically impossible to build with cabal
11:14:58 <Heffalump> the hackage curators are quite good about fixing that when it matters, though I don't know if the resulting workload is under control
11:17:01 <Rembane> The .cabal-file is added to .gitignore by default.
11:19:28 <sm[m]> oh goodie it's hpack debate time
11:19:59 <sm[m]> alx741: IIRC hpack can share other things besides dependencies - flags etc. - does cabal do that too ?
11:20:13 <solonarv> it does
11:20:22 <solonarv> cabal's common stanzas can share everything
11:20:27 <sm[m]> good
11:21:39 <monochrom> In the good old days people didn't debate over ghc vs hugs...
11:25:46 <fendor> monochrom, they didnt? some years ago I heard people argue for hugs. in fact, at our university, haskell is only taught with hugs
11:30:38 <infinisil> Does GHC eliminate function arguments of type ()?
11:31:24 <hyperisco> What do you mean by eliminate?
11:32:06 <infinisil> I mean, if I have a type `type F a = a -> Double -> Double`, and write `f :: F ()`, will it be as fast as just a Double -> Double?
11:32:41 <hpc> (() -> a) is observably different from a, with seq
11:32:53 <infinisil> AHh
11:33:04 <hyperisco> I think that depends on the definition of  f  and even then I think we're talking about niche circumstances
11:33:07 <hpc> i expect it causes recomputation as well
11:33:27 <hpc> you'd have to experiment
11:35:17 <cocreature> if it can inline the definition then it will often eliminate it
11:36:01 <infinisil> Hmm that makes sense
11:36:31 <infinisil> I guess it's generally not a bad idea to throw INLINEABLE all over the place
11:36:45 <hyperisco> Does that do anything?
11:38:44 <infinisil> I think it allows it to inline accross module boundaries or so
11:38:56 <hyperisco> There is an INLINE pragma
11:39:29 <hyperisco> Which causes the "is this function small enough" check to always say "yes"
11:40:09 <rfold> To understand INLINEABLE you first need to understand modules, object files, and interface files.
11:40:21 <hyperisco> https://downloads.haskell.org/~ghc/6.12.2/docs/html/users_guide/pragmas.html
11:41:10 <hyperisco> Less old https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#inline-and-noinline-pragmas
11:44:02 <cocreature> rfold: huh? what does INLINEABLE have to do with object files?
11:46:30 <hyperisco> The only success I had with optimising anything, at that level, is to go back and forth looking at the Core output. Just adding pragmas and thinking something good will happen is wishful.
11:47:47 <basic> hi im back again, still having the same problem!
11:47:50 <basic> https://ibb.co/kcWpvFX
11:50:07 <oats> rooky question, how do you decide which stack resolver to use?
11:50:31 <hyperisco> You'll need a chicken and an axe.
11:51:27 <Rembane> oats: The newest one IMHO.
11:52:31 <hyperisco> https://docs.haskellstack.org/en/stable/GUIDE/#resolvers-and-changing-your-compiler-version
11:54:39 <oats> alrighty then
12:21:56 <infinisil> Another question, this time regarding NFData: If I do `let (a, _) = force <some computation>`, does this make `a` strict? 
12:22:34 <infinisil> Because in order to pattern match it needs to evaluate the right hand side to WHNF, which in this case means evaluating it to NF
12:23:09 <MarcelineVQ> how might you test this?
12:23:40 <monochrom> MarcelineVQ++
12:24:04 <infinisil> Hmm, something with undefined, let me try..
12:24:45 <infinisil> > let (a, _) = force (undefined, ()); in ()
12:24:47 <lambdabot>  error:
12:24:48 <lambdabot>      Variable not in scope: force :: (a0, ()) -> (a, b0)
12:25:38 <infinisil> Well if I import Control.DeepSeq, and do it in ghci
12:25:40 <infinisil> It works
12:25:46 <infinisil> Which surprises me
12:26:17 <monochrom> That would mean a=undefined which is an uninformative test.
12:26:28 <merijn> infinisil: Well, but that SHOULD work if it evaluates to WHNF...
12:26:35 <infinisil> Ah
12:26:45 <infinisil> let (a, _) = force (undefined :: Int, ()); in seq a ()
12:26:55 <monochrom> Actually what merijn said is even better.
12:26:55 <infinisil> That throws undefined
12:27:43 <monochrom> If your test output doesn't vary by adding and omitting "force", your test is uninformative.
12:28:01 <infinisil> Ah darn
12:28:16 <monochrom> This is known as confirmation bias.
12:28:23 <infinisil> let (a, b) = force (undefined :: Int, ()); in seq b ()
12:28:24 <infinisil> There we go!
12:28:31 <infinisil> with force it throws, without it doesn't
12:28:31 <monochrom> Yeah!
12:28:54 <infinisil> But it's not strict I don't think
12:29:33 <infinisil> Or is this as strict as you can get in haskell?
12:30:07 <merijn> What does "strict" mean to you?
12:30:20 <infinisil> Hm, I'd have said that the seq wouldn't be needed if it were strict
12:30:40 <infinisil> But I understand that it doesn't work like that with thunks in haskell
12:31:02 <infinisil> I think at least
12:31:06 <nshepperd> > let (a, _) = undefined in ()
12:31:08 <lambdabot>  ()
12:31:18 <nshepperd> > let (a, _) = undefined in seq a ()
12:31:21 <lambdabot>  *Exception: Prelude.undefined
12:31:23 <monochrom> What happens if you replace "seq b ()" by "()"?  by "b"?
12:32:10 <infinisil> With () it doesn't throw, with b it does, which makes sense
12:38:52 <MarcelineVQ> infinisil: so what is the answer to your question?
12:40:22 <infinisil> Hm, the pattern match doesn't really have anything to do with whether this works or not, evaluating any part of a force'd result evaluates the whole thing
12:41:29 <infinisil> And strictness in haskell seems to always be in regards to some value, like "seq a b" means a is strict when you evaluate b
12:41:43 <infinisil> Does that sound about right?
12:42:19 <c_wraith> you should always thing of evaluation as dependency chains.
12:42:49 <c_wraith> When <expression1> is evaluated, it causes the evaluation of <expression2>
12:43:15 <c_wraith> seq lets you create an arbitrary dependency
12:46:51 <infinisil> Hmm I see
12:52:37 <dminuoso> infinisil: Strictly speaking no. `seq` has special semantics imbued by the Haskell Report. `seq a b` means that whenever `b` is demanded, `a` will be evaluated as well.
12:52:50 <dminuoso> The report carefully does not mandate any order in this.
12:53:46 <dminuoso> Oh wait. Ignore me.
12:53:54 <dminuoso> I misread something in there. :<
13:01:17 <infinisil> Alright then :)
13:10:09 * PoopSick[m] uploaded an image: 344zsx.jpg (95KB) < https://matrix.org/_matrix/media/v1/download/matrixim.cc/eNlJDuZEycYBCWyWKXwhstBn >
13:50:06 <dmwit> infinisil: You may use case instead of let for additional strictness.
13:50:26 <dmwit> case force (undefined, b) of (a, _) -> () -- undefined
13:50:56 <infinisil> Ahh nice
14:02:20 <jjk96> Hello, can anyone explain me why `(+) <$> (+3) <*> (*2)` takes only one argument? I have a basic understanding of Applicative Functors, but I would expect this one to take 2 arguments
14:03:20 <lavalike> :t (+) . (+3) . (*2) -- maybe you're thinking of this
14:03:21 <lambdabot> Num a => a -> a -> a
14:08:23 <lavalike> I guess the simplest explanation is this is the "(->) r" functor, and look at this type:
14:08:26 <lavalike> :t (<$>)
14:08:28 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:08:42 <lavalike> if you plug that functor, you see it takes a 2 arg fun, a 1 arg fun, and gives you a 1 arg fun
14:24:39 <dmwit> jjk96: Can you explain why you think it should take two arguments?
14:24:47 <dmwit> Maybe we can help you spot the error in your reasoning.
14:27:32 <dmwit> We can also just directly explain, I guess.
14:27:42 <dmwit> ?src liftA2
14:27:42 <lambdabot> liftA2 f a b = f <$> a <*> b
14:27:44 <dmwit> :t liftA2
14:27:46 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
14:28:01 <dmwit> So liftA2 is an abstraction of the pattern you're seeing there.
14:28:18 <dmwit> It expects a two-argument function as its first argument; (+) is one of those, so... so far so good.
14:28:46 <dmwit> Next it expects things that can serve well as arguments to (+), but wrapped in an applicative context of some kind.
14:29:02 <dmwit> Let's say for concreteness we're talking about (+) :: Int -> Int -> Int.
14:29:24 <dmwit> Now `(+3) :: Int -> Int` is a bit like an `Int` wrapped in the applicative context of `(->) Int`.
14:30:29 <dmwit> So `(->) Int` plays the role of `f` in liftA2's type signature (and `Int` plays the role of `a`).
14:30:48 <dmwit> Similarly for `(*2) :: Int -> Int`: it's an `Int` wrapped in an `(->) Int` context.
14:31:25 <dmwit> This means that `liftA2 (+) (+3) (*2)` should have type `f c` -- where `f` has been determined by the second and third arguments to be `(->) Int` and `c` has been determined by the first argument to be `Int`.
14:31:37 <dmwit> So `liftA2 (+) (+3) (*2) :: Int -> Int`.
14:31:49 <dmwit> This gives an explanation in terms of just matching up types.
14:32:20 <dmwit> If you want an explanation in terms of why functions are a good applicative context to think about, and how to understand intuitively what this construction *does*, we can talk about that, too.
14:35:17 <jjk96> dmwit:  Yeah, I get it now! Thx for the elaborate explanation!
14:41:47 <jjk96> Or are they both `(->) Int`?
14:42:54 <dmwit> What are the two things in "both"?
14:56:30 <jjk96> dmwit: > how to understand intuitively what this construction *does*
14:56:30 <jjk96> I guess I'm stuck on this part
15:03:59 <jjk96> dmwit: I think I've got it, the function `b = liftA2 (+) (+3) (*2)` creates a function `b` that applies (+) on the output of (+3) and (*2), The f is `(->) Int` where the Int is the argument that is eventually given to `b`.  Thanks for the help!
15:05:38 <ebutleriv> Is there a newbuild equivalent to `cabal sandbox add-source [local path]`?
15:05:54 <lavalike> :t (<$>)
15:05:55 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:06:09 <lavalike> @djinn (a -> b) -> (r -> a) -> (r -> b)
15:06:09 <lambdabot> f a b c = a (b c)
15:06:13 <lavalike> :t (<*>)
15:06:14 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
15:06:24 <lavalike> @djinn (r -> a -> b) -> (r -> a) -> (r -> b)
15:06:24 <lambdabot> f a b c = a c (b c)
15:06:34 <lavalike> now you can stick them together
15:08:45 <lavalike> @unpl \f g h -> (\x y z -> x z (y z)) ((\a b c -> a (b c)) f g) h
15:08:45 <lambdabot> \ f g y z -> f (g z) (y z)
15:09:19 <hexagoxel> ebutleriv: add more folders to the "packages" in your `cabal.project` file
15:09:41 <shapr> @remember xplat everytime you stop shaving that yak, you back into the yak bristles
15:09:41 <lambdabot> Done.
15:09:44 <lavalike> that is inlining (<$>) and (<*>) in \f g h -> f <$> g <*> h rewritten as \f g h -> (<*>) ((<$>) f g) h
15:09:55 <lavalike> you can put in your particular functions too
15:10:04 <lavalike> @unpl (\x y z -> x z (y z)) ((\a b c -> a (b c)) (+) (+3)) (*2)
15:10:04 <lambdabot> (\ z -> (z + 3) + (z * 2))
15:11:59 <lavalike> does that help?
15:15:17 <jjk96> :t I find it hard to follow, but I think I grasp the general idea
15:15:18 <lambdabot> error: parse error on input ‘,’
15:18:02 <lavalike> jjk96: where do you get lost?
15:21:56 <jjk96> But it's okay, I understand the function well enough now, I'm going to sleep, gn
15:22:44 <lavalike> night-o!
15:28:40 <ebutleriv> hexagoxel: ah, thanks
18:27:57 <hololeap> has anyone used the blank-canvas library? is there any way to get user input on the canvas using it?
18:31:08 <jackdk> there must be, because codeworld can do user input and that depends on blank-canvas. having not used blank-canvas directly, I do not know how to set it up to do so.
19:36:35 <slack1256> Is there a way to access profiling information on a running haskell program?
19:36:45 <slack1256> GHC.Profiling only enable options
19:45:02 <slack1256> Nvm, GHC.Stats is what I wante
19:45:06 <slack1256> wanted
20:13:12 <davean> go Dir
20:13:15 <davean> er sorry
20:13:22 <Axman6> no u
20:15:01 <MarcelineVQ> riD og
21:01:11 <devalot> hololeap: Have you looked at the blank-canvas wiki?  There are a lot of examples.
22:50:04 <dminuoso> Given an arbitrary adjunction L -| R, is L and R always free/forgetful in some sense? (to the point of trivially free and trivially forgetful given an equivalence)
22:54:30 <dminuoso> Or to rephrase my question: Is this statement right? iff L -| R then L is a free functor and R is a forgetful functor
22:58:46 <fresheyeball> hey out there
22:58:52 <fresheyeball> I am curious about Data.Void
22:58:55 <dminuoso> Hi fresheyeball o/
22:59:06 <fresheyeball> dminuoso: :)
22:59:16 <dminuoso> Data.Void is an interesting module, isn't it? 
23:02:55 <dminuoso> fresheyeball: Did you have any particular question about it?
23:05:33 <fresheyeball> yes sorry
23:05:41 <fresheyeball> baby needs a bottle
23:06:44 <Axman6> I've got one in the mean time, do we have a Void1 anywhere? data Void1 a, which is a functor, monad etc.
23:07:19 <dminuoso> Axman6: What would be the semantics of that?
23:07:58 <Axman6> I'm not sure, I don't have a need for it, just wondering if such a thing a) exists, and b) has any use
23:08:13 <nshepperd> it would be a functor but not a monad or applicative
23:08:29 <cocreature> in particular, "pure" definitely doesn’t work
23:08:30 <nshepperd> but it would be a comonad
23:09:22 <Axman6> data Void1 a; absurd1 :: Void1 a -> b, absurd1 = absurd1 (or error "The impossible happened!"); instance Functor Void1 where fmap = absurd1
23:09:49 <dminuoso> So I guess semantically `Void1` would be a functor from an empty category?
23:10:01 <Axman6> nshepperd: yeah I hadn't thought about pure, good point. Being a comonad is an interesting idea
23:10:06 <nshepperd> also foldable and traversable
23:13:34 <fresheyeball> ok back
23:13:37 <fresheyeball> ok
23:13:47 <fresheyeball> so I am writing a bunch of FromJSON instances
23:14:10 <nshepperd> Void1 is a functor from Hask to some sort of 'boring' category with exactly 1 morphism between every two objects
23:14:12 <fresheyeball> and I have some functions abstracted over the FromJSON constraint
23:14:34 <fresheyeball> and I want a way to say "decode this to.., you know what its fine"
23:14:37 <dminuoso> nshepperd: But that would invalidate the Functor instance, wouldn't it?
23:14:42 <fresheyeball> as in just `return ()` basically
23:14:52 <dminuoso> I mean an instance functor would be admitting that this thing is an Endofunctor in Hask.
23:14:56 <fresheyeball> I thought Void would be a good fit here
23:15:22 <dminuoso> fresheyeball: Void is the devoid data type, it has no inhabitants except bottom.
23:15:23 <fresheyeball> I could `parseJSON _ = return $ error "how did you evaluate void?"
23:15:28 <nshepperd> dminuoso: the 'target' is a subcategory of Hask
23:15:35 <fresheyeball> dminuoso: right
23:15:42 <fresheyeball> thats why I thought it might fit
23:15:47 <fresheyeball> I am asserting we do not eval the result
23:16:12 <fresheyeball> but then I saw `absurd`
23:16:26 <dminuoso> fresheyeball: `absurd` is the witness that bottom is inhabitated by every type.
23:16:46 <fresheyeball> dminuoso: so my idea doesn't work because of absurd
23:16:49 <fresheyeball> I can't do like
23:16:51 <dminuoso> fresheyeball: Sure it would.
23:17:09 <fresheyeball> _ :: Void <- obj .: "foo"
23:17:22 <fresheyeball> because absurd opens up a hole here
23:17:27 <dminuoso> It does not, really.
23:17:34 <fresheyeball> yes it does
23:17:37 <fresheyeball> look
23:17:37 <nshepperd> dminuoso: that's how it works with any Functor instance, really. a Functor is an functor from Hask to some subcategory
23:17:45 <nshepperd> which makes it an endofunctor too
23:18:05 <fresheyeball> obj .: "foo" >>= \(x :: Void) -> absurd x + 1
23:18:08 <fresheyeball> world broken
23:18:19 <fresheyeball> oh wait
23:18:26 <dminuoso> fresheyeball: `absurd` doesnt let you recover from bottom.
23:18:40 <dminuoso> fresheyeball: bottom inhabitates every type.
23:18:59 <dminuoso> fresheyeball: so you could think that it lets you convert this "raw bottom" to a "bottom of any other type"
23:20:55 <fresheyeball> dminuoso: yes it does
23:21:02 <fresheyeball> https://repl.it/@IsaacShapira/SpotlessOffbeatDecagon
23:21:26 <sarahzrf> nshepperd: no, the codomain of a Functor is Hask
23:21:30 <sarahzrf> *not* a subcategory
23:21:44 <dminuoso> sarahzrf: Sure it can be a subcategory
23:21:45 <nshepperd> well, you can view it either way...
23:21:53 <fresheyeball> sarahzrf: it's a sub category
23:21:55 <sarahzrf> a codomain is part of the data of a morphism D:
23:21:59 <dminuoso> sarahzrf: We can pretend that the image of a functor is a subcategory of its own.
23:22:11 <dminuoso> so perhaps we should differentiate between image and codomain here..
23:22:17 <sarahzrf> the image of a functor is certainly a subcategory
23:22:23 <fresheyeball> sarahzrf: we can call the image a subcategory
23:22:44 <dminuoso> fresheyeball: You never recovered from `bottom`
23:23:31 <fresheyeball> dminuoso: I want the bottom to be unreachable
23:23:36 <fresheyeball> is that possible?
23:24:13 <dminuoso> fresheyeball: It's still unreachable.
23:25:06 <fresheyeball> dminuoso: I just reached it in repl.it it crashes the program
23:28:25 <dminuoso> fresheyeball: The point is, you are already holding a bottom in your hand.
23:28:36 <fresheyeball> I know
23:28:46 <fresheyeball> but it's not an ordinary bottom
23:29:02 <fresheyeball> its a bottom that has no we to be evaluated as Void has no constructors 
23:29:10 <dminuoso> fresheyeball: there are not muliple bottoms.
23:29:20 <dminuoso> fresheyeball: bottom is simply a non-terminating computation.
23:29:22 <fresheyeball> so maybe Void is not the right thing
23:29:39 <fresheyeball> but something like Void where it has no constructors, but absurd does not exist
23:29:44 <dminuoso> fresheyeball: If you truly want to communicate "nothing here", dont return anything in its spot.
23:29:58 <dminuoso> fresheyeball: You cant have that because you can simply force it and watch it blow up.
23:30:16 <dminuoso> fresheyeball: Void says "here is bottom"
23:30:20 <fresheyeball> how would you force it?
23:30:45 <dminuoso> fresheyeball: The same way absurd is defined
23:31:44 <fresheyeball> it does a weird spin thing that is hard for me to understand
23:32:01 <dminuoso> fresheyeball: So lets say we make up our own empty data type
23:32:03 <dminuoso> % data Empty
23:32:03 <yahb> dminuoso: 
23:32:11 <fresheyeball> yes
23:32:15 <dminuoso> Now we have a type with no way to construct values from it, all great right?
23:32:25 <dminuoso> But you can still make values of it if you look closely
23:32:30 <dminuoso> % shouldnt = undefined
23:32:30 <yahb> dminuoso: 
23:32:34 <dminuoso> % shouldnt = undefined :: Empty
23:32:34 <yahb> dminuoso: 
23:32:47 <fresheyeball> right
23:32:49 <dminuoso> And we can force values of this type (which can do nothing but crash!)
23:32:59 <fresheyeball> how?
23:33:04 <dminuoso> Say by doing something like `f :: Empty -> (); f !x = ()`
23:33:08 <dminuoso> Or perhaps
23:33:24 <dminuoso> % foo :: Empty -> a; foo x = case x of {}
23:33:24 <yahb> dminuoso: 
23:33:28 <dminuoso> % :t foo
23:33:28 <yahb> dminuoso: Empty -> a
23:33:57 <fresheyeball> ok
23:34:10 <dminuoso> fresheyeball: The problem is not the existence of absurd, its that you produced a bottom to begin with.
23:34:25 <dminuoso> If you want something completely unreachable, dont write it.
23:34:27 <fresheyeball> so here is another option
23:35:04 <fresheyeball> data Always = Always
23:35:18 <fresheyeball> parseJSON _ = return Always
23:35:56 <dminuoso> fresheyeball: That's just `()` :)
23:36:43 <dminuoso> fresheyeball: I tend to use `Void` mainly for `Async Void` which communicates "this is a thread that never finishes"
23:37:05 <dminuoso> Or in some edge cases where `Either Void a` are produced, such that I want to communicate "there's no left side for some reason"
23:37:11 <fresheyeball> no its not
23:37:17 <dminuoso> fresheyeball: Yes it is.
23:37:19 <fresheyeball> aeson treats () as an empty array
23:37:24 <dminuoso> fresheyeball: it's isomorphic to it anyway
23:37:29 <fresheyeball> I know
23:37:51 <fresheyeball> cardinality is all that matters for isomorphism
23:37:57 <fresheyeball> 1 = 1
23:38:14 <dminuoso> fresheyeball: pretty sure its not :-p
23:38:21 <dminuoso> It would be in plain set theory
23:38:26 <fresheyeball> it is with data types
23:38:39 <fresheyeball> yeah
23:38:42 <fresheyeball> I agree
23:38:59 <fresheyeball> ok
23:40:08 <fresheyeball> data Always = Always
23:40:14 <fresheyeball> just seems so wasteful haha
23:40:23 <fresheyeball> given that it wont ever be used for anything
23:40:33 <fresheyeball> and should always be left unevaled
23:40:35 <dminuoso> fresheyeball: Use `Void` then.
23:41:11 <dminuoso> I mean I can write `f :: Always -> a` as well
23:41:14 <dminuoso> Its very easy in fact.
23:41:24 <dminuoso> `f _ = undefined` bringing you back to square one.
23:41:42 <dminuoso> So yeah, its a shame that you cant talk about totality in Haskell.
23:42:08 <fresheyeball> I guess as a developer if I see (_ :: Void) I know better than to force it
23:42:26 <dminuoso> fresheyeball: Right. It communicates "if you try and force this, you get bottom back"
23:42:31 <dminuoso> "There is no value here"
23:42:39 <fresheyeball> ok
23:42:48 <fresheyeball> thanks for helping me reason through this
23:43:03 <nshepperd> it's not like forcing a Void is a problem
23:44:07 <dminuoso> fresheyeball: absurd is mainly useful for situations where, for some reason, you are forced to provide a function but now it wont matter.
23:44:15 <nshepperd> if someone passed you an 'error' or a 'undefined' you're well within your rights to throw an error back
23:44:20 <dminuoso> Say you are getting an `Either Void a` and you are forced to supply two functions to `either`
23:48:04 <nshepperd> to me, receiving anything of type Void communicates "this isn't happening"
23:48:13 <nshepperd> all Voids are hypothetical
23:48:50 <fresheyeball> that's also not what this means though
23:50:03 <fresheyeball> here I am saying I am empty but successful
23:50:12 <fresheyeball> as in this is happening, but I am not
23:51:27 <nshepperd> what is 'this'
23:51:43 <fresheyeball> the parse
23:51:58 <fresheyeball> the monadic action the gives us a bottom is happening
23:52:31 <fresheyeball> its `do stuff; return $ error "no eval me"`
23:52:40 <fresheyeball> :: m Void
23:54:12 <nshepperd> are you saying that the json can be parsed but doesn't return any useful data?
23:54:37 <nshepperd> then you want () or Always
23:54:43 <fresheyeball> the json cannot be parsed into anything useful, but needs to be considered successuful
23:54:59 <fresheyeball> as in "I expect junk"
23:55:07 <fresheyeball> "junk means success"
23:55:31 <nshepperd> so you're validating the json or something?
23:55:51 <fresheyeball> in practice I want to leave this bit unevaluated
23:56:12 <fresheyeball> and I have only types to say so
23:56:19 <fresheyeball> since we are already abstracted over FromJSON
23:58:11 <fresheyeball> I just need the compiler to pick a FromJSON instance that is `parseJSON _ = return ()`
23:58:14 <fresheyeball> that would be great
23:58:33 <fresheyeball> but it's polymorpic, so I have to use a type annotation to tell the compiler to pick that
23:59:50 <nshepperd> i don't really get it, but ok
