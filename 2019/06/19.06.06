00:16:44 * hackage wai-cors 0.2.7 - CORS for WAI  https://hackage.haskell.org/package/wai-cors-0.2.7 (larsk)
00:29:17 <dminuoso> ski: So if I consider Russells terminology in which he calls the
00:29:29 <dminuoso> Oops, that was the enter key hit accidentally when tabbing.
01:18:00 <zincy> Is there anything I should be wary of when using websockets. Snoyman's blog says avoid lazy IO when streaming. An easy way to do this I think is to use something like conduit or pipes. Can anyone with more experience than me weigh in on the advantages of these streaming libraries vs regular old sockets.
01:19:59 <tdammers> you're still using regular old sockets
01:20:25 <zincy> yeah true
01:20:43 <Cale> Another way to avoid it is just to use straightforward strict ByteString/Text IO
01:20:47 <tdammers> you could also implement streaming using some sort of callback
01:21:38 <tdammers> so instead of send :: Data.ByteString.Lazy.ByteString -> Socket -> IO (), you could go send :: (IO (Maybe Data.ByteString.ByteString)) -> Socket -> IO ()
01:21:39 <zincy> Cale: Just passing everything around as those strict types will be enough to achieve strictness?
01:21:40 <Cale> But the various libraries like pipes can turn code which has pretty annoying control flow into something which looks pretty
01:21:59 <Cale> zincy: Yeah, "lazy IO" here refers to using hGetContents
01:22:05 <jgt> yikes… how do I get around this? Can I type an annotation? http://ix.io/1L3o
01:22:13 <Cale> Just don't use hGetContents
01:22:35 <zincy> tdammers: Why the Maybe?
01:22:45 <tdammers> zincy: to signal the end of the stream
01:22:56 <zincy> Ah right
01:22:59 <jgt> oh, turns out I can: {-# ANN validMonetaryChars ("HLint: ignore Use String" :: Text) #-}
01:23:09 <tdammers> you could also just pass in a strict bytestring, but then you're not really streaming anymore
01:24:13 <tdammers> because it means that either the caller can supply the entire bytestring immediately, and the send function will just "stream" all of it immediately; or it cannot provide it immediately, in which case the send function will only start streaming when the bytestring is available in full
01:24:43 <tdammers> so that's why you need the callback
01:24:54 <zincy> Is it streaming if the websocket connection is open for a while but each message is very small?
01:25:34 <tdammers> I don't think that question is going to yield a very insightful answer
01:25:54 <zincy> yeah
01:25:59 <tdammers> you could either say that yes, it's technically still streaming; or you could say no it's not, but because the messages are small you don't need to stream
01:26:13 <tdammers> but both boil down to the same consequences
01:26:18 <zincy> ah ok
01:26:59 <zincy> I am doing some pretty funky races with Tvar timeouts and I feel like they could be cleaned up somehow
01:27:12 <tdammers> hmm
01:27:14 <zincy> Just don't know if a streaming library will help me there
01:27:20 <zincy> seems like a lot of refactoring
01:28:07 <tdammers> a fairly straightforward design for this is to have one thread pull data from some sort of Chan, and send whatever arrives down the socket, blocking while nothing is available; and the main thread just shoves messages into the Chan when it needs to send anything
01:28:26 <tdammers> of course that doesn't work if you need some sort of request/response pattern, but if that's the case, then you can really just do it all in one thread
01:28:39 <zincy> yeah I am currently just doing that with a Tchan
01:28:43 * hackage async 2.2.2 - Run IO operations asynchronously and wait for their results  https://hackage.haskell.org/package/async-2.2.2 (SimonMarlow)
01:28:58 <zincy> I mean the main problem is disconnects and the buffer in a channel solves that
01:29:04 <tdammers> ^ it's as if Simon was listening in :O
01:29:11 <zincy> haha
01:29:50 <tdammers> the buffer doesn't actually solve that completely
01:30:01 <zincy> how come?
01:30:13 * hackage happy 1.19.11 - Happy is a parser generator for Haskell  https://hackage.haskell.org/package/happy-1.19.11 (SimonMarlow)
01:30:15 <tdammers> when the client disconnects, you want the producer to stop producing, otherwise it'll just keep filling the TChan forever, and it'll never be drained
01:31:01 <zincy> thank you. save me future headaches
01:31:06 <zincy> *saved
01:32:04 <zincy> so what is the best way of getting around disconnects?
01:33:18 <zincy> I guess you firstly use the bracket pattern to cleanup
01:34:19 <jgt> I wrote a custom monetary amount field for yesod-form, using safe-money, autonumeric.js, chosen.js, and jQuery. Does anyone want to take a quick look and tell me if I'm doing anything stupid?
01:34:37 <zincy> jgt: go for it
01:35:23 <jgt> zincy: https://gist.github.com/jezen/fe8ff782154a88785ffe5055c89a8edb
01:37:42 <zincy> Quick glance - don't see any stupid. But if you are dealing with money get someone with more experience than me to look at it
01:38:26 <jgt> well hopefully I can rely on the safe-money library to be well-principled
01:38:40 <zincy> you would hope it lives up to its name
01:38:45 <jgt> :)
01:38:53 <zincy> what are you making?
01:39:14 <jgt> I'm building a trading platform for the reinsurance industry
01:39:27 <zincy> Work or pleasure?
01:39:37 <jgt> work
01:39:52 <jgt> it's a startup that I'm running, together with two reinsurance guys
01:40:04 <jgt> it's funded too, so this is my full-time gig
01:40:12 <zincy> You hiring? :)
01:40:47 <jgt> not right now; I hired a few people recently who coincidentally all happen to be in Russia
01:40:58 <zincy> oh cool
01:41:03 <zincy> sounds like a fun project
01:41:07 <jgt> I probably _will_ be hiring again soon-ish, but it depends on the current funding round
01:41:29 <jgt> if you're interested, I'd be happy to keep in touch
01:42:22 <jgt> I'm actually *thrilled* that I haven't really had to go hunting for developers. I know people who run startups on Ruby and JavaScript in London, and they have to deal with so much drama; especially with recruiters
01:42:46 <zincy> jgt: Yeah recruiters are really hard to work with.
01:42:55 <zincy> I'll email you so you have my details.
01:43:11 <jgt> zincy: cool! I'm here: jezen@riskbookltd.com
01:44:44 <zincy> Great! Sent you an email just there.
01:47:25 <tdammers> recruiters are for the level-1 desperate
01:47:33 <tdammers> level 2 is monsterboard & craigslist
01:47:43 <tdammers> or maybe it's the other way around, but both are for the desperate
01:49:02 <tdammers> but if you have a decent operation, enough funding to pay reasonable salaries, a non-pathological software stack and codebase, at least average people skills, and a workflow that leaves you enough time to take hiring seriously, then you shouldn't need to resort to either
01:50:23 <jgt> zincy: got it. Thanks!
01:52:25 <jgt> tdammers: the approach is simple — use decent tools (Haskell, some Elm, Nix), pay people, let them work from anywhere in the world, and default to async communication. No middle managers or daily standups.
01:53:15 <libertyprime> hey guys. any way to simplify this to simply print out the expression and then execute it, to remove the repitition?
01:53:22 <libertyprime> trace "print $ head list" print $ head list
01:54:26 <Taneb> libertyprime: there isn't anything like that I'm afraid
01:55:11 <solonarv> I suppose you could use template haskell and write something like: [traceQ| print $ head list |], but that seems like a very cumbersome and silly thing to do
01:55:29 <solonarv> also, you're already working in IO (as indicated by the 'print'), why use trace at all?
01:56:07 <solonarv> why not just: do putStrLn "print $ head list"; print $ head list
01:56:30 <solonarv> then pick a more informative message and the repetition is also gone ;)
01:56:42 <tdammers> jgt: yep, that's pretty much how you attract haskellers ;)
01:58:42 <libertyprime> thanks guys. insightful. haha i should be flexing my racket skills to generate my haskell anyway
01:59:24 <solonarv> o-O
02:01:06 <solonarv> if you find yourself doing this a lot you could also write a helper function: printMsg msg val = putStrLn (msg ++ " = " ++ show val)
02:02:50 <jgt> zincy: here's the rendered version of that monetary amount field you looked at earlier btw: https://imgur.com/a/vP1cuRc
02:03:47 <zincy> jgt: Nice!
02:05:03 <zincy> jgt: monospaced font as well :)
02:11:13 * hackage pkgtreediff 0.2.1 - Package tree diff tool  https://hackage.haskell.org/package/pkgtreediff-0.2.1 (JensPetersen)
02:24:49 <zincy> I am trying to run a socket server using the Pipes library on localhost and can only connect through telnet but not through js. Any ideas on where to look?
02:25:45 <Rembane> zincy: When you try to connect through js, how do you do that?
02:26:30 <zincy> websocket.org/echo.html - an inbrowser echo service
02:27:19 <zincy> ws://localhost:5000 just gives me err_connection_refused
02:29:01 <Rembane> zincy: Do you use a Websocket library on the server side?
02:29:16 <Rembane> zincy: https://hackage.haskell.org/package/websockets
02:29:38 <Rembane> ...for instance
02:31:15 <zincy> Pipes uses Network under the hood
02:31:48 <merijn> zincy: Rembane's point is that websockets aren't REAL sockets
02:32:02 <merijn> zincy: So you can't use them like real sockets and connect to arbitrary ports
02:32:44 <merijn> (well, you can, it's just not very likely to work as expected :p)
02:33:06 <zincy> I am confused now :D
02:33:44 <merijn> zincy: websockets are a protocol to run a bytestream/TCP-like communication over an existing HTTP connection
02:33:46 <zincy> What is the point of the fromServe function in pipes.network then if it cant accept socket connections?
02:33:50 <Rembane> zincy: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers
02:33:57 <Rembane> zincy: It accepts socket connections
02:34:05 <merijn> zincy: Pipes.Network accepts TCP connections
02:34:13 <zincy> ahh
02:34:13 <Rembane> zincy: But you need to do quite some magic moves for it to understand websockets. 
02:34:14 <merijn> zincy: WebSockets /= TCP
02:34:29 <zincy> So telnet uses real sockets
02:34:34 <zincy> and browsers use http
02:34:50 <zincy> no wonder it didn't work as expected haha
02:34:52 <Rembane> Almost there, http are real sockets. Websockets are weird sockets in top of http.
02:34:57 <Rembane> *on top of
02:34:58 <merijn> zincy: Telnet uses the telnet protocol, but when used from the commandline like you did it's basically indistinguishable from raw bytes
02:36:18 <zincy> ok
02:36:28 <zincy> thanks for clearing up my confusion
02:36:29 <merijn> zincy: TCP sockets basically give you the abstraction of "a sequence of bytes coming in from the network", Pipes.Network exposes that, but it's up to you to figure out what to do with those bytes. If you wanna connect via websockets the answer is probably "interpret them as WebSockets communication", but that requires a library than can parse byte sequences into WebSockets
02:40:02 <zincy> I found a pipes-websocket package which seems to allow you to lift a normal websocket into a producer/consumer
02:40:13 * hackage higgledy 0.2.0.1 - Partial types as a type constructor.  https://hackage.haskell.org/package/higgledy-0.2.0.1 (i_am_tom)
03:41:12 <temp> Hello everyone, I'm a beginner/intermediate user of Haskell. I'm trying to use gloss-examples. But I don't know how to do it with stack. Any help will be appreciated.
03:43:30 <temp> I tried adding it to the dependencies section of packages.yaml but that wasn't the right way to do so
03:49:33 <elvishjerricco> Is there a way to make gloss's lines / circles / arcs not look so jagged?
04:03:13 <temp> Hello everyone, I'm a beginner/intermediate user of Haskell. I'm trying to use gloss-examples. But I don't know how to do it with stack. Any help will be appreciated. I tried adding it to the dependencies section of packages.yaml but that wasn't the right way to do so
04:03:27 <temp> Anyone knows how to do this?
04:05:11 <dminuoso> temp: Be patient. Your message is still readable for everyone. :)
04:09:01 <dminuoso> temp: https://github.com/benl23x5/gloss/blob/master/stack-8.6.yaml
04:09:10 <dminuoso> temp: It looks like its using stack already.
04:09:50 * ski looks at Russell
04:10:44 <temp> dminuoso: Okay, sorry
04:13:03 <dminuoso> temp: Oh I misunderstood. What do you mean by  "that wasn't the right way to do so"?
04:14:57 <dminuoso> temp: I think the appropriate way to use this, is to just use `cabal v2-install gloss-examples`, which would produce the various executables specified in the cabal package.
04:15:24 <dminuoso> temp: gloss-examples is not a library, it's just multiple executables.
04:15:48 <temp> but that's the problem. I wanted to use stack
04:15:49 <temp> Oh I see
04:16:41 <temp> stack build returned this ->     gloss-examples is a library dependency, but the package provides no library needed since fractals is a build target.
04:18:27 <dminuoso> temp: Presumably you could just do `stack install gloss-examples`
04:18:39 <dminuoso> Instead of adding it to your packages.yaml
04:19:10 <dminuoso> But that would place it into the global stack directory I think..
04:19:10 <temp> People have recommended against that.
04:19:39 <dminuoso> temp: Ah then `stack build --copy-compiler-tool gloss-examples`
04:19:39 <temp> But then I won't be able to 'uninstall it' as there is no uninstall command which is why people recommend against that
04:20:11 <temp> I'll try that
04:20:14 <dminuoso> Well actually that's done for a different reason.
04:20:28 <dminuoso> No ignore me, Im just talking nonsense.
04:21:13 <dminuoso> temp: You can uninstall it just fine after `stack install` using ghc-pkg
04:30:40 <Patrol02> Hi, I have a question about promoted kinds. If I have a type like "data Food = Meat | Milk | Salad", how do I express a function that takes some "Section Food" as a first parameter, and "Section of type of kind Food" as a second parameter?
04:30:55 <Patrol02> Here is a gist that doesn't compile: https://gist.github.com/AlexeyRaga/0fc62670036e3687d582cc1ab8515d9b
04:32:13 * hackage multistate 0.8.0.2 - like mtl's ReaderT / WriterT / StateT, but more than onecontained value/type.  https://hackage.haskell.org/package/multistate-0.8.0.2 (lspitzner)
04:36:50 <dminuoso> Patrol02: At least include the compiler error you are getting (or at the very least include the langauge pragmas needed to compile this)
04:37:59 <dminuoso> Patrol02: So the `openSub'` is wrong on multiple levels.
04:40:21 <dminuoso> Patrol02: What you are asking for requires TypeInType.
04:41:09 <temp> dminuoso: sorry, I had lost internet connectivity
04:41:14 <Patrol02> The error is "wrong kind". I will include pragmas that I used, thanks! Will try "type in type" now
04:41:17 <dminuoso> % data Section (a :: k) = Section {}
04:41:22 <yahb> dminuoso: [Timed out]
04:41:24 <temp> I did that and it worked. Thanks
04:41:26 <dminuoso> Patrol02: Well that one Im not sure you want.
04:43:18 <dminuoso> Patrol02: TypeInType basically collapses the tower of "Type : * : Box : ...` into `Type : Type : Type ...`,
04:43:43 <temp> I can see those files but I don't know how to run them
04:44:00 <dminuoso> Patrol02: In `openSub` you are using two *different* identifiers Food. You are using `Food` the type, and `Food` the lifted kind.
04:44:10 <dminuoso> Patrol02: In openSub' however you want to use `a` as both a type and a kind.
04:44:48 <dminuoso> TypeInType enables this because that tower is collapsed, so types of types are types too, which makes `Section a -> Section (k :: a)` a valid thing.
04:44:54 <temp> dminuoso: Oh, nevermind
04:45:23 * ski idly wonders what Patrol02 is really trying to do there
04:46:45 <Patrol02> dminuoso: I want my function to accept two parameters, and if the first one is of a type, then the second one must be a promoted constructor of that type. So if I have "Section Food" as a first parameter, the second one could only be "Section Milk", "Section Meat", etc., but not some "Section Hat"
04:47:02 <dminuoso> Patrol02: To what end?
04:51:06 <Patrol02> To what end? I just want to make a generic function that opens a given subsection of a given section such that relationship makes sense. Maybe it isn't the right way of modelling it, is that what you are saying?
04:52:20 <dminuoso> Patrol02: Probably not in the way you are trying to do it.
04:53:02 <ski> is it even possible to do what Patrol02 is doing there, transitively ?
04:53:20 <dminuoso> ski: transitively in what sense?
04:54:42 <Patrol02> dminuoso: can you suggest how it could be modelled more appropriately? 
04:55:43 <ski> hm, perhaps something like
04:55:44 <ski>   openSub grandParent parent >>= \parent -> openSub parent child
04:56:13 <ski> in any case, using `c :: b :: a', say
04:58:55 <Patrol02> ski: not sure that I understand... 
05:02:01 <ski> Patrol02 : first passing a `Section a' and a `Section k', where `k :: a', to `openSub', then passing a `Section k' (e.g. the same one), and a `Section t', where `t :: k'
05:02:26 <ski> iow, "opening" sucessively smaller subsections ?
05:02:46 <ski> Patrol02 : is that not what you'd e.g. want to enable ?
05:02:55 <Ariakenom> why isn't threadDelay this? (\sec -> threadDelay (ceiling (sec * 1000000))) :: RealFrac a => a -> IO ()
05:02:58 <ski> perhaps i misunderstood what the point of this would be
05:04:16 <Patrol02> I'll try that now, thanks!
05:08:57 <Axman6> Ariakenom: why should it be?
05:10:00 <merijn> Ariakenom: What if you want to delay for less than a second?
05:10:09 <Ariakenom> sleep 0.5
05:10:21 <Ariakenom> whenever I wanna sleep I want to specify in (fractional) seconds not microseconds
05:10:23 <merijn> Ariakenom: That's not very accurate due to how doubles work for smaller times
05:11:09 <Ariakenom> if so then :: Rational -> IO ()
05:11:47 <merijn> Ariakenom: You can just as easily wrap threadDelay with a second based sleep if you want it...
05:12:37 <Ariakenom> but it's surely accurate down to millionths. and if u want to compute with it an Int seems more problematic
05:13:49 <Ariakenom> merijn: yes, but I always want to wrap it. I find it odd that the wrapper isn't the standard approach
05:14:38 <dminuoso> Patrol02: You could use type families to encode the relation.
05:16:18 <Patrol02> dminuoso: I though of something like `class Subsection a where type Parent a` and instances, but hoped that it could be less boilerplate :)
05:16:55 <dminuoso> Patrol02: I dont know enough of the details, honestly.
05:18:33 <Ariakenom> merijn: afaik Double should be perfectly accurate as a literal unless one second in Int was more than 2^53
05:25:24 <dminuoso> Patrol02: Well you could rather have `class Rel (p :: k) (c :: l)` (possibly without the PolyKinds here, depending on how far you want this to go), and then specify `openSub' :: Rel p c => Section p -> Section c -> Section c
05:25:50 <dminuoso> MPTC can be thought of as relations
05:26:19 <dminuoso> Any potential boilerplate by `instance Rel Food Meat` shouldn't be a big issue.
05:26:30 <ski> `data' types (e.g. GADTs) can also be thought of as relations
05:27:10 <dminuoso> ski: In what sense?
05:35:47 <ski> dminuoso : well, e.g.
05:35:55 <ski>   data Sum :: Nat -> Nat -> Nat -> *
05:35:57 <ski>     where
05:36:32 <Patrol02> dminuoso: thanks! looks better than my example!
05:37:04 <ski>     SumZero ::              Sum  Zero    n  n
05:37:10 <ski>     SumSucc :: Sum m n o -> Sum (Succ m) n (Succ o)
05:37:27 <ski> this corresponds to the Prolog
05:37:51 <ski>   sum(zero   ,N,N      ).
05:38:03 <ski>   sum(succ(M),N,succ(O)) :- sum(M,N,O).
05:38:24 <libertyprime> im looking at the hackage documentation for replicateM. it seems the 4.7 version was easier to understand. why would monad have been changed to applicative? what are the benefits?
05:38:28 <libertyprime> http://hackage.haskell.org/package/base-4.7.0.0/docs/src/Control-Monad.html#replicateM
05:38:31 <libertyprime> http://hackage.haskell.org/package/base-4.12.0.0/docs/src/Control.Monad.html#replicateM
05:38:51 <ski> (in Twelf you're write the same thing, except prefixing the first clause with `sum/zero : ', and the second clause with `sum/succ : '. data type definitions and predicate definitions are the same thing, in Twelf)
05:39:07 <Ariakenom> I suppose sleep :: DiffTime -> IO () would be most correct
05:39:23 <dminuoso> libertyprime: It admits more instances.
05:40:06 <ski> of course, you don't get any automatic proof search with such a data type, in Haskell
05:40:10 <dminuoso> libertyprime: There are some things that are Applicative but not Monad. The reason you had a Monad constraint was because it came before Applicative was a thing.
05:40:27 <dminuoso> libertyprime: Since the introduction of Applicative a lot of code could be related from requiring Monad to Applicative.
05:40:32 <dminuoso> *relaxed.
05:56:57 <dminuoso> libertyprime: https://gitlab.haskell.org/ghc/ghc/issues/10168 this is the ticket
05:57:26 <libertyprime> mawesome. thanks guys
05:57:49 <dminuoso> libertyprime: It also describes the reason why the implication is different. :)
05:57:56 <dminuoso> *implementation
05:59:20 <yogeshagr> Hello wonderful people here! I have one question to ask. My sister asked me today that she wants to learn programming. She has just finished 1 year of her university and is undergoing graduation in computer science. Is it advisable to start learning programming directly with Haskell, when you have never programmed in your life. You don't know C/C++, imperative programming, data structures, algorithms. None of it. What would you ad
05:59:43 <dminuoso> yogeshagr: Absolutely, yes.
06:00:13 <ski> you could try
06:00:13 <dminuoso> yogeshagr: In some sense Haskell can be easier to pick up as your first language. The declarative notions tend to be easier if you do not have an imperative programming mindset equipped already.
06:00:16 <ski> @where HPFFP
06:00:16 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
06:01:30 <ski> yogeshagr : btw, message cut off near end : ".. You don't know C/C++, imperative programming, data structures, algorithms. None of it. What would you ad"
06:01:34 <dminuoso> yogeshagr: The main difficulty in Haskell appears to be mostly the "unlearning" and frustration you get, when learning Haskell is as slow as your first programming language.
06:01:54 <dminuoso> yogeshagr: But a newcomer won't know the difference. :)
06:02:26 <ski> well, there's certainly the same struggles with learning the syntax, and doing lots of syntactic mistakes, initially, as in any other language
06:02:53 <ski> and forgetting to pass parameters, passing them in the wrong order, &c.
06:03:33 <dminuoso> The GHC diagnostics could be intimidating as well, but C++ is much worse in that regard.
06:03:34 * ski assumes dminuoso meant "main difficulty in Haskell", as compared to learning other (imperative) languages, as first language
06:04:14 <ski> isn't "?SYNTAX ERROR ON LINE 130" a good run-time error message ?
06:04:22 <dminuoso> ski: I rather meant, some frustration appears to be coming from the fact that learning Haskell after 10 years of imperative programming feels so slow, giving the impression that Haskell is hard.
06:04:40 <ski> yes
06:05:00 <ski> you're learning a new programming paradigms, it is bound to feel a bit like learning to program from scratch, all over again
06:05:05 <dminuoso> When in fact that learning speed is not caused by Haskell being very hard itself. Instead it rather comes from learning a new language from beginning.
06:05:45 <yogeshagr> ski: dminuoso thank you very much for your input. Much appreciated. She also wants to do the certification. Could you also suggest an online course for this and one book. Both of which I can gift her, as a good brother :) 
06:06:01 <ski> hm, i think some monitors would only display "?", on error
06:06:01 <dminuoso> yogeshagr: ski has mentioned a good resource above.
06:07:43 <dminuoso> ski: I frequently managed to produce template errors with over 300 lines..
06:08:12 <ski> yogeshagr : (obviously) i dunno your sister, but personally i found it very helpful to have others to discuss troubles had when learning Haskell, such as in this IRC channel, e.g.
06:08:28 <dminuoso> yogeshagr: I would second the book mentioned by ski. It's specifically tailored to newcomers with little to no programming backgrounds.
06:08:40 <ski> yogeshagr : there's also mailing lists. and perhaps there's people around her university which she could present issues to
06:09:18 <dminuoso> yogeshagr: You could also gift her a trip to zurihac/munihac (depending on your budget...), they tend to have beginner tracks..
06:09:31 <ski> dminuoso : "You are lost in a maze of error messages, all subtly different."
06:10:06 <dminuoso> ski: That sounds like the beginning of a new rogue-like.
06:10:30 <solonarv> oh, this could be part of that Haskell-themed roguelike
06:10:53 * solonarv you encounter a wild EKMETT
06:10:58 <yogeshagr> dminuoso, haha, thank you! :D :D That would be too much for her, I want her to spend her free time in learning programming. If she does well. Then a trip to Munihac maybe, haha :D
06:11:03 * solonarv he s t a b s you with a Lens!
06:11:10 <ski> @where CIS194
06:11:10 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
06:11:25 <ski> yogeshagr : perhaps she could also try that ^ after a bit. it has exercises
06:11:44 <dminuoso> solonarv: And the realm is called Hask. Clearly.
06:14:14 <ski> @quote getting.a.stab
06:14:14 <lambdabot> byorgey says: <edwardk> @type (^.) <lambdabot> s -> Getting a s t a b -> a <byorgey> I would not like to be getting a stab, thank you
06:16:32 <yogeshagr> ski: I see, okay. Also would this course be good: https://www.udemy.com/learning-path-haskell-functional-programming-and-haskell/ to get a certificate and that would put her under schedule and a process
06:17:41 <kuribas> :t fmap pure
06:17:42 <lambdabot> (Functor f2, Applicative f1) => f2 a -> f2 (f1 a)
06:18:42 <kuribas> @hoogle (Monad m, Monad n) => (m a) -> m (n a)
06:18:43 <lambdabot> Data.ByteString.Streaming copy :: Monad m => ByteString m r -> ByteString (ByteString m) r
06:18:43 <lambdabot> Data.ByteString.Streaming.Char8 copy :: Monad m => ByteString m r -> ByteString (ByteString m) r
06:18:43 <lambdabot> Data.ByteString.Streaming.Internal copy :: Monad m => ByteString m r -> ByteString (ByteString m) r
06:18:53 <kuribas> is there a shortcut for fmap pure?
06:19:46 <ski> yogeshagr : i dunno about that course, nor about certificates
06:20:23 <ski> yogeshagr : being put under schedule and process might be good. depending on your personaolity, and how you prefer to learn
06:20:38 <kuribas> :t lift
06:20:40 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
06:20:45 <ski> that's different
06:20:48 <kuribas> that's what I want :)
06:21:24 <ski> perhaps you want something that can e.g. map from `State s a' to `StateT s m a'
06:21:45 <yogeshagr> ski: okay
06:21:49 <kuribas> ski: yeah
06:22:07 <kuribas> from Parser a to MaybeT Parser a
06:22:22 <ski> that's `lift'
06:22:42 <solonarv> indeed - t ~ MaybeT, m ~ Maybe
06:22:51 <solonarv> I mean m ~ Parser
06:23:34 <ski> @type MaybeT . fmap pure
06:23:35 <lambdabot> Functor m => m a -> MaybeT m a
06:23:52 <solonarv> @src lift MaybeT
06:23:52 <lambdabot> Source not found. The more you drive -- the dumber you get.
06:23:54 <solonarv> aww
06:23:57 <ski> that's the implementation of `lift', for `MaybeT'
06:24:07 <kuribas> yeah
06:24:33 <solonarv> no it isn't :P
06:24:34 <solonarv> https://hackage.haskell.org/package/transformers-0.5.6.2/docs/src/Control.Monad.Trans.Maybe.html#line-196
06:24:36 <kuribas> is there something for (maybe (pure Nothing)) ?
06:24:41 <kuribas> :t maybe (pure Nothing)
06:24:42 <lambdabot> Applicative f => (a1 -> f (Maybe a2)) -> Maybe a1 -> f (Maybe a2)
06:25:26 <solonarv> (it's MaybeT . liftM Just, which should be equivalent to MaybeT . fmap pure)
06:25:35 <ski> yogeshagr : possibly there are good certificates out there. but personally, i'm probably a bit skeptical about them. at least to what having got one signifies. but possibly one could take getting one as an opportunity for learning
06:25:47 <solonarv> micro-optimization: lift = MaybeT #. fmap Just
06:27:00 <ski> solonarv : aye, i was talking about the behaviour :)
06:27:52 <solonarv> :D
06:36:27 <yogeshagr> ski: okay. Sorry one more question and probably the last one for this :) I see the book you suggested: http://haskellbook.com/. Is there any online free ebook, themed "Haskell for beginners/Haskell as first langauge"
06:38:10 <kuribas> :t (MaybeT . liftM Just)
06:38:11 <lambdabot> Monad m => m a -> MaybeT m a
06:38:23 <dexterfoo> yogeshagr: you can check the links in the "Sidebar" here: https://www.reddit.com/r/haskell/
06:39:07 <solonarv> kuribas: it's the same thing, just a bit antiquated (due to the liftM)
06:39:57 <solonarv> also potentially a bit less efficient because liftM often involves more plumbing than fmap and theoretically has a higher chance to not inline-and-optimize-away
06:44:01 <yogeshagr> dexterfoo: got it. thank you! :)
06:46:37 <kuribas> solonarv: liftM = fmap?
06:50:01 <kuribas> :t fmap
06:50:02 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:50:06 <kuribas> :t liftM
06:50:07 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
06:53:26 <ski> yogeshagr : hm, i think most Haskell books assume some programming familiarity
06:59:31 <ski> kuribas : by law, yes
06:59:56 <kuribas> ski: so much in haskell has become obsolete
07:00:07 <ski> kuribas : if you have already implemented `(>>=)' and `return', then `liftM' is a cheap default implementation of `fmap'
07:00:13 <kuribas> return, liftM, liftM2, mapM
07:00:16 <kuribas> etc...
07:00:27 <ski> (ditto for `liftA', if you have already implemented `(<*>)' and `pure')
07:00:29 <nitrix> I second this. I wish the commitee would take the time to clean things up, even if it means backwards-incompatible changes.
07:02:05 <ski> it would possibly be nice not to have operations requiring `Monad', when `Applicative' is more appropriate
07:05:26 <sambo> hey guys, I'm working on a library called stm-actor which is a local version of the Erlang model and I would really appreciate comments and contributions. its hosted here: https://github.com/SamuelSchlesinger/stm-actor
07:10:43 * hackage czipwith 1.0.1.2 - CZipWith class and deriving via TH  https://hackage.haskell.org/package/czipwith-1.0.1.2 (lspitzner)
07:11:02 <solonarv> ski: sometimes the Monad-restricted versions are needed because of strictness and similar arcana
07:11:48 <ski> i suppose, yea
07:21:45 <newhoggy> I don't understand why I can't get the required/provided contexts to work for pattern synonyms
07:21:53 <newhoggy> https://www.irccloud.com/pastebin/SRpLMzLq/
07:22:14 <newhoggy> In the above I throw all the constraints into one constraint list.
07:22:20 <newhoggy> I thought I could do this:
07:22:55 <newhoggy> https://www.irccloud.com/pastebin/f2TMNKdD/
07:23:12 <newhoggy> Where I provide two separate constraint lists.
07:23:19 <newhoggy> But this version doesn't work.
07:24:30 <newhoggy> My error is:
07:24:43 <newhoggy> https://www.irccloud.com/pastebin/k5bXQOx7/
07:25:35 <newhoggy> Doesn't matter if I swap the constraint lists around:
07:25:42 <newhoggy> https://www.irccloud.com/pastebin/RSqxZQ0H/
07:26:02 <newhoggy> My code is here: https://github.com/haskell-works/hw-prim/pull/69
07:26:06 <newhoggy> Anyone can help?
07:35:07 <kuribas> Is there a strong precendence version of ($)?
07:35:22 <kuribas> @hoog a -> (a -> b) -> b
07:35:22 <lambdabot> Maybe you meant: hoogle hoogle+
07:35:25 <kuribas> @hoogle a -> (a -> b) -> b
07:35:26 <lambdabot> Prelude ($) :: forall r a (b :: TYPE r) . (a -> b) -> a -> b
07:35:26 <lambdabot> Prelude ($!) :: forall r a (b :: TYPE r) . (a -> b) -> a -> b
07:35:26 <lambdabot> Data.Function ($) :: forall r a (b :: TYPE r) . (a -> b) -> a -> b
07:35:44 <solonarv> hm, I'm not aware of one
07:36:23 <pie__> wouldnt that just be normal function application?
07:36:29 <solonarv> unless you want "stronger precedence than any other operator"; in which case: just write 'f x' instead of 'f $ x' ;)
07:36:37 <solonarv> s/other ///
07:38:57 <kuribas> pie__: yeah :)
07:39:33 <kuribas> sometimes I like something strong than >>=
07:39:40 <kuribas> :i (>>=)
07:42:14 <kuribas> what's a good example of the list Monad?
07:42:20 <kuribas> maybe some kind of search?
07:42:50 <ski> yes. e.g. Sudoku
07:43:25 <ski> or expressing relations
07:44:53 <kuribas> I have "check if the sum of two numbers are even", but it's a bit lame
07:46:12 <Pumble> hello!
07:46:53 <Pumble> ive been meaning to learn haskell for a while now, im fairly fluent in scheme and was wondering how useful haskell could be for me
07:48:22 <kuribas> Pumble: very useful :)  A lot will be familiar, but a lot will be strange as well
07:48:58 <kuribas> Pumble: for example, in scheme you'll likely use tail-recursion, while in haskell usually not.
07:49:11 <kuribas> And the static type system of course.
07:50:30 <Pumble> why does haskell usually not use tail recursion?
07:52:31 <tdammers> it doesn't?
07:52:40 <tdammers> or do you mean "why does haskell not have TCO"?
07:53:18 <Pumble> thats what i mean yeah sorry
07:53:50 <kuribas> tdammers: we don't?
07:53:59 <kuribas> Pumble: because of lazyness
07:54:24 <kuribas> Pumble: the execution model is much different
07:54:25 <glguy> tail-recursion is common in haskell and we have tail call optimizations
07:55:16 <kuribas> yes, but it is not always obvious when to use it, while it is more obvious in scheme
07:55:18 <tdammers> well, there are two ways to look at that - you can say that haskell doesn't do TCO because it doesn't need to (essentially because there is no call stack); or you can say that haskell does have TCO, but it's not implemented explicitly but rather a consequence of its evaluation model
07:55:20 <Pumble> im kind of unfamiliar with lazy evaluation, but i have heard  of it
07:55:40 <kuribas> I'd say you can use tail recursion when you know you are strict
07:55:44 <glguy> tdammers: What's important is that you aren't penalized for using it
07:55:55 <tdammers> glguy: yes, that's what both sides boil down to
07:56:10 <kuribas> but you can build up thunks with tail recursion if you aren't careful
07:56:29 <glguy> you can build up thunks if you aren't careful*
07:58:55 <kuribas> but unless you are optimizing, you don't use tail recursion?
07:59:08 <kuribas> or do you?
07:59:35 <solonarv> even when optimizing you don't just automatically reach for tail recursion
07:59:46 <solonarv> laziness means it is sometimes optimal to *not* be tail recursive
08:00:08 <solonarv> for example, look at foldr: it is not tail recursive
08:00:53 <solonarv> however if your folding function is such that you don't need to look at the entire list, foldr will not traverse the entire list, so it can be faster than foldl (which is tail recursive, and must always traverse the entire list)
08:02:21 <ski> it's better to talk about "proper tail recursion" (a misnomer, since it's not directly about recursion), than about TCO
08:03:23 <ski> kuribas : you can build up closures on the heap in Scheme too, if you naïvely do CPS translation in order to get (basically) all calls be tail calls
08:04:03 <ski> if you use tail recursion, that means your operation will automatically be bulky
08:04:22 <ski> if it's possible to be incremental, then usually you don't want to reach for tail recursion
08:05:21 <ski> "bulky" means that the answer is only delivered at the end, in one piece
08:05:51 <ski> "incremental" means that, as you go along your loop/recursion, you can "output" bits of information, pieces of the result
08:06:03 <ski> `map' is incremental, `reverse' is not
08:07:06 <ski> bulky operations will not terminate on infinite inputs. incremental operations can, since you can decide to just look at part of the out
08:07:51 <ski> incremental operations also often tend to be better for working on large inputs, where you can "stream / pipeline" the processing
08:09:38 <ski> (but you have to be careful not to keep around a reference to the start of the input, otherwise that will keep it from being GCed, preventing you from operating in memory on a small "window" of the data (like a huge file, or network stream))
08:24:55 <shapr> good morning!
08:25:48 * ski bounces a bit up and down on the chair
08:26:17 <shapr> oh hej ski!
08:26:31 <shapr> ski: have you seen github's semantic library? It does so much cool stuff!
08:26:40 <ski> i haven't
08:26:51 <shapr> but I hit a bug and I'm trying to create a good bug report ...
08:27:52 <shapr> ski: here's the examples doc for semantic - https://github.com/github/semantic/blob/master/docs/examples.md
08:36:59 <tabaqui> which public license do you prefer to see on hackage?
08:37:04 <tabaqui> bsd, mit, apache?
08:37:09 <ski> shapr : hmm .. reminds me a bit of my syntax for equality proofs
08:38:08 <ski> i wonder why the sexps for `Identifier' and `TextElement' doesn't show the symbol and the string contained ..
08:41:14 <jgt> today I wrote `concatMap show ([0..9] :: [Int]) <> ",."`
08:41:18 <jgt> and then felt very stupid
08:41:32 <jgt> I could have just written "0123456789,."
08:42:54 <pie__> yes but now you have the semantics ;PP
08:43:08 <pie__> what if 12345678 ever changes???
08:45:14 <ski> values in mathematics don't change, they are immutable
08:45:17 <c_wraith> > ['0'..'9'] -- jgt 
08:45:19 <lambdabot>  "0123456789"
08:45:34 <c_wraith> slightly shorter!  as if that matters :)
08:45:47 <c_wraith> especially with those extra two characters
08:46:01 <ski> > map intToDigit [0 .. 9]
08:46:03 <lambdabot>  "0123456789"
08:49:53 <jgt> yeah my colleague pointed out ['0'..'9'] which forced me to think about how silly my first attempt was
08:52:02 <epta> Does anyone use azure devops as a CI for haskell project? I'm curious how to set up caching to not rebuild all the deps all the time
09:03:49 <boj> epta: i do. currently i use a docker container with nix in it
09:04:12 <boj> experimented with building the cached libraries into the container, but it was faster to full from the nix cache than load a 20gb image
09:04:23 <boj> s/full/pull
09:04:24 <epta> boj: could you please share the azure_pipelines.yaml?
09:04:44 <boj> sure, let me see what i can do
09:07:20 <boj> epta: https://gist.github.com/boj/8aaa593242d7a480e0eaff0e4e73e3da
09:07:48 <epta> boj: great, thanks a lot
09:08:21 <boj> yep, happy to help
09:08:36 <nitrix> Can anyone knows of good material that would point out the merits of the continuous vs. discrete FRP approaches?
09:09:11 <tdammers> discrete FRP?
09:09:17 <boj> nitrix: google "connal eliot"
09:09:35 <ski> conal elliott
09:09:46 <nitrix> boj: conal is on the channel, I don't have to google it :P
09:09:49 <boj> two of everything
09:09:52 <conal> :)
09:10:14 * ski smiles
09:10:28 <boj> you can hear conal roll his eyes up here in alaska when people say "frp + discrete"
09:11:06 <nitrix> conal: I don't remember, were the initial denotational semantics discrete or continous? I'll definitely have to find those PDFs again :P
09:11:09 <conal> nitrix: you might start with http://conal.net/blog/posts/why-program-with-continuous-time . 
09:12:07 <conal> nitrix: also http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html, since the same arguments apply.
09:12:31 <conal> nitrix: continuous time was *the* founding idea of FRP.
09:12:59 <conal> nitrix: also explained here: https://github.com/conal/talk-2015-essence-and-origins-of-frp 
09:14:09 <conal> nitrix: continuous time and space have simpler precise semantics, more useful laws hold, and they're more composable, compared with discrete time and space.
09:14:17 <nitrix> This is encouraging because I'm currently struggling to design this messaging architechture on my project (it's about change propagation) and the discrete approach seems like it would allow for deadlocks, at least in my current design.
09:14:42 <nitrix> I'm not sure how continuous will do, I've heard of nightmare tales with "time glitches".
09:14:44 <conal> It's much of the same motivation as pure functional programming, and nonstrict/"lazy" pure functional programming in particular.
09:15:10 <nitrix> conal: That's good news :) I'm reading.
09:15:27 <conal> nitrix: i think those glitches arise when people aren't careful about specification/denotation.
09:15:49 <solonarv> hm, is there a simple way to read a 'Data.Vector.Unboxed.Vector Word16' from a file?
09:15:59 <solonarv> (in binary format)
09:16:27 <nitrix> conal: Breif summary, I want to make FRP visual. Like an actual graph were you see the information propagating.
09:16:32 <conal> nitrix: for instance, the idea of some sort of "now" that consults a clock. or they think frp is about graphs & propagation or dataflow or some operational notion.
09:17:09 <conal> hah. i wrote my remark about graphs & propagation before i saw your brief summar.
09:17:14 <conal> (summary)
09:17:31 <nitrix> Well... oh-oh ;-;
09:17:52 <conal> nitrix: you may have gotten an erroneous idea of what FRP is about. hint: it's not about graphs or propagation.
09:17:59 <nitrix> I guess that's why it's good to have your ideas validated, haha.
09:18:31 <conal> :)
09:19:21 <nitrix> Are the links going to correct that mistake or I need to gain deeper understanding of the intricacies of FRP to come up with that conclusion?
09:19:28 <conal> nitrix: start here and follow the links: http://stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language#5878525 , including that origins-and-essence talk and the related talks. i'm happy to answer questions here.
09:19:47 <nitrix> conal: Perfect. That might take a couple moments. I really appreciate :)
09:20:29 <Pumble> you guys are so friendly i really hope to learn haskell soon
09:20:56 <dmj`> Pumble: haskell learns you :)
09:21:04 <conal> nitrix: as i mentioned continuous time was the founding idea of FRP, exactly in order to address problems with discrete time similar to those that arise from discrete space. beginning with a precise denotation is even more fundamental as it relates to programming in general.
09:21:14 <ski> Pumble : you're welcome to stay here, and lurk, and ask more questions
09:22:00 <ski> @quote CCCP
09:22:00 <lambdabot> monochrom says: in Soviet Russia, you have current-continuation-calls-procedure (CCCP)
09:22:06 <JordanF> Pumble: Haskell really messes with your head for a week or so and then you get used to it
09:22:22 <tdammers> hmm, was more like a year for me
09:22:26 <tdammers> maybe that means I'm stupid
09:22:35 <JordanF> I mean I still don't get all of it
09:22:39 <tdammers> or maybe that's what 20 years of imperative programming do to it
09:22:47 <JordanF> But I was doing it for a university module course
09:22:48 <ski> @quote is.the.solution
09:22:48 <lambdabot> quicksilver says: head-explosion is the solution, not the problem.
09:22:50 <Pumble> the complexity gives my brain something to work with, so i love the challenge
09:23:02 <JordanF> So I was pretty time constrained
09:23:13 <Pumble> what kind of things are popularly made with haskell?
09:23:22 <maerwald> parsers
09:23:30 * ski heard people like Pandoc
09:23:32 <tdammers> Pumble: hint: it's not the complexity that makes your brain hurt, but the abstractness. The complexity is actually very low; it's just that your usual ways of trying to form intuitions for them don't work, because the concepts are too abstract
09:24:12 <JordanF> My lecturer managed to go from nothing to Monads and Type-level programming in 10 weeks 
09:24:23 <JordanF> Needless to say the course was pretty intense
09:24:23 <Pumble> tdammers: thats exactly how it felt for when i first was learning scheme in SICP. thats a really good way to word it!
09:24:25 <nitrix> conal: If I were to voice my fear about this, without knowing anything yet on the subject, is that computers currently are procedural (read von neumann) and while continuous time works mathematically, I'm worried this wont translate programatically.
09:24:27 <tdammers> if you look at "haskell in the industry", then I think the common denominator is "things for which correctness is important, but not important enough that you can throw performance and practicality out the window entirely"
09:24:55 <maerwald> JordanF: yeah, usually such courses don't allow you to build any intuition and you will forget most of it
09:24:57 <tdammers> Pumble: yeah. So the thing Scheme did to your brain, Haskell does it harder. But it's worth it.
09:25:00 <Taneb> nitrix: I think the idea is you don't need it to translate until the very end, when you can approximate how you like
09:25:35 <Pumble> tdammers: what do you use haskell for?
09:25:39 <ski> Pumble : SICP is nice
09:25:42 <tdammers> maerwald: I think the better courses just avoid suggesting any specific intuitions, because they invariably lead at least half the students to misunderstand the concept
09:25:59 <Pumble> ski: i love sicp. it was so good i coughed up and bought the physical book
09:26:42 <tdammers> Pumble: almost everything. Web dev, mathy things, compilers, data analysis, boring CRUD stuff, you name it.
09:26:54 <tdammers> maerwald: a.k.a. the Monad Tutorial Fallacy ;)
09:26:59 <conal> nitrix: yeah. i've run in to that perspective a lot. i don't think it holds up to much scrutiny. first note that digital computation is just an abstraction, not a real thing. second, that the digital abstraction no more thwarts with implementing continuous notions correctly than continuous reality thwarts implementing the digital abstraction correctly.
09:27:06 <ski> @where burrito
09:27:06 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
09:27:21 <maerwald> tdammers: I wasn't suggesting to give people a concept of inuition, but rushing through type-level programming in a 10 weeks course definitely doesn't allow you to build it
09:27:24 <Pumble> tdammers: i have heard functional programming used in web dev when people would use clojure for things
09:27:32 <jhrcek> Hi. Does anyone know if doctest supports running functions requiring terminal input? When I do `doctest interactive.hs` it freezes.. https://gist.github.com/jhrcek/e2bc7d7fe23075a13b4989df4df5a053
09:27:44 <Pumble> the end of me will be when i write a compiler in haskell, that stuff is super interesting
09:27:51 <conal> nitrix: note that math itself is packaged discretely into finite alphabets and inference systems, and yet we've been formulating and exploring continuous mathematics with it for centuries.
09:27:59 <maerwald> tdammers: and piling concept after concept on students while they are still struggling with building inuition for basic concepts...
09:28:05 <maerwald> well, is the nature of teaching, but...
09:28:11 <tdammers> maerwald: yeah, no, but with just 10 weeks, there's only so much you can do, and if the choice is to just present the material as accurately as possible, and leave the longer process of exercising and forming intuitions to the students, then that's a fair decision by my book
09:28:12 <nitrix> conal: People sure have! I'm an outsider :)
09:28:26 <JordanF> maerwald: TLP was an extra bit at the end for the particularly bright students, Most only went as far as monads and ignored the TLP stuff
09:28:31 <conal> nitrix: similarly, pencils and pens can write about more than graphite and ink.
09:28:45 <tdammers> sometimes, I think, just burying people with information, and then trusting them to digest it at some point in the future, is the best you can do
09:28:53 <maerwald> I know bright people who avoid TLP :P
09:29:10 <nitrix> conal: Alright. You gave me plenty to work with, I'll get back to you with something more concrete.
09:29:23 <ski> JordanF,maerwald,tdammers : <https://www.norvig.com/21-days.html> :)
09:29:34 <JordanF> It seems like most uni lecturers but their "hobby topic" at the end of a course
09:29:39 <JordanF> (at least where I go to uni)
09:30:01 <tdammers> ski: familar with that, it's gorgeous.
09:30:06 * ski nods
09:30:26 <ski> (i was thinking you'd be. perhaps it's new to JordanF, though)
09:30:31 <conal> nitrix: good luck, and enjoy!
09:31:02 <Messburn> Is there a good concurrent Pool type?   A bit like an MVar, which can be used like a pool of one item.
09:32:10 <maerwald> tdammers: I think it's the worst of options. Dumping information you've accumulated over years into a tight course and then being confused why the students can't even ask meaningful questions... once they get to the point they can ask questions, the course is already over
09:32:31 <conal> nitrix: suggestion as you're watching, reading, and noodling: when your mind rebels with an argument or question about continuous time, consider the analogous argument or question with space (e.g., vector vs bitmap graphics).
09:32:40 <maerwald> (which is usually when they are bored and have time for a proper project)
09:33:03 <maerwald> boredom!
09:34:03 <maerwald> different of course when you are teaching people who do that every day anyway
09:34:21 <tdammers> yeah, OK, but what else can you do
09:34:33 <maerwald> tdammers: revolution! ;P
09:34:39 <tdammers> in fact, I'm pretty convinced that you cannot teach people against their will
09:34:59 <tdammers> those who want to learn, you dump information on them, and they will do their best to digest it, and ask useful questions
09:35:10 <jle`> not without deception, maybe
09:35:10 <tdammers> those who don't truly want to learn, won't learn anyway
09:35:27 <maerwald> tdammers: I disagree, people learn all sorts of weird behavior, like using money. None of which is really their will.
09:35:35 <tdammers> there may be some leeway for tricking people into remembering a bunch of factoids, but that's not really teaching IMO
09:35:42 <tdammers> oh, but it is
09:36:04 <tdammers> people learn to use money because it's useful to them, or because it's simply something they need to do every day
09:36:44 <maerwald> Anyway, how did we get from TLP to an anti-civ discussion ;D
09:37:08 <tdammers> and also the concepts that form the basis for using money (i.e., the part that you have to actually "learn") are learned at a very early stage, and at that stage, the child positively wants to learn them, out of a instinct to participate in its social context
09:37:17 <tdammers> that's #haskell for you
09:37:32 <maerwald> tried to use safe-money package, but it had too much TLP hahaha
09:38:08 <tdammers> I hate it when TLP escapes the internals of a library :D
09:38:52 <maerwald> last time I thought you liked servant
09:39:28 <conal> nitrix: another resource (not by me) that might help with appreciating continuous time: https://futureofcoding.org/essays/dctp.html 
09:40:15 <Messburn> I implemented   readSpec :: FilePath -> IO (Either String Spec)  as  readSpec f = BL.readFile f >>= pure . eitherDecode
09:40:19 <Messburn> Is it possible to use =<< instead and express this pointfree without the explicit f?
09:40:59 <glguy> Messburn: Forgetting about point-free for a moment you can write that as: readSpec f = eitherDecode <$> BL.readFile f
09:41:37 <glguy> point-free isn't something to aspire to. To do it point free you can write: readSpec = fmap eitherDecode . BL.readFile
09:41:54 <glguy> <$> is the infix form of fmap
09:42:23 <Messburn> good thx
09:44:33 <ski> you should learn that `ma >>= return . f' is `fmap f ma'
09:47:50 <Messburn> ski: will remember this
09:48:54 <nitrix> conal: I'm reading on one of the links that "in the end", continuous time can be observed as discrete, which makes sense, it's some form of sampling if you will, and everything in the middle should stay continuous to allow easier composability. I'm on board with this, but that has serious implications. If it's truely contiguous, then there's now and only now. It cannot be a cyclic graph where messages comes
09:48:56 <nitrix> back to previous vertices; you don't have such messages and you also don't have such graph. "Alright", this is a good first step, throwing my existing mental model out of the window... though it makes things even more scarrier because now it seems FRP always terminates (halts, as in halting problem), is that right? How can that be useful.
09:49:03 <nitrix> Oh boy, that's long, sorry.
09:50:18 <solonarv> you can totally have messages going back and forth between nodes in the FRP network, they just can't go backwards in time!
09:51:45 * ski imagines some circuit described in VHDL, with explicit time delays
09:52:08 <nitrix> ski: That's actually what I'm visualizing right now.
09:52:10 <conal> nitrix: Yes, you got the point that continuous composes better than discrete, just as infinite composes better than finite (hence nonstrict functional programming)---and more generally exact composes better than approximate.
09:52:47 <conal> nitrix: but what makes you think that the "graph" (which doesn't really exist, btw) cannot be cyclic?
09:53:36 <conal> there really is no graph/network. there are behaviors, which simply denote functions of time.
09:54:22 <nitrix> conal: I kind of got an answer, but it's because I'm naively thinking there's only "now" and thus, if I were to ever implement this, any form of cycle would lead me to break that model.
09:54:31 <conal> sure, one can make a graph that corresponds to a syntactic expression, but that's true of arithmetic as well.
09:54:47 <nitrix> Then, ski and ski gave good insight. If I think of a circuit instead, with time _delays_, now it's interesting.
09:55:00 <nitrix> ski and solonarv *
09:55:30 <conal> nitrix: good! frp is not about "now", but rather about functions on *all* of time.
09:55:50 <conal> just as imagery is not about a single color at a single point in space.
09:57:48 <nitrix> I unfortunately need a concrete model to approach new unfamiliar ideas so this is the best I've got right now. Circuits are continuous and with diodes and time delays, you can have cycles and "re-evaluate" previous paths but with a different signal.
09:58:03 <nitrix> It's not great, but it's something to keep me afloat >.<
09:59:05 <conal> nitrix: yeah. thinking about _analog_ circuits can help. or just reality/physics (Newtonian style) more broadly.
09:59:48 <hyperisco> nitrix, feedback also moves forward in time, even in a circuit.
10:00:31 <conal> nitrix: and you don't need time delays for useful cyclic dependencies. instead, use ordinary differential equations.
10:00:48 <conal> i.e., cyclic integrals
10:01:55 <nitrix> hyperisco: I think I understand. Can you expand on feedback?
10:02:04 <hyperisco> I've been wondering where the analog programming language is. Why don't we have values with uncertainty? Dunno.
10:02:30 <nil> so the typeclassopedia mentions  zip.ap fmap.(id &&& wtf)  -- is this a purely fictional example, or could it actually do something useful? (provided "wtf" was defined)
10:02:43 <hyperisco> nitrix, feedback in a circuit is when you have the output of a circuit connected to its own input.
10:02:54 <zeta_0> hello guys, i plan on doing some web development in emacs, i am going to use haskell with the yesod web framework, does web-mode.el support yesod?
10:03:08 <conal> hyperisco: define as a simple category, and compile Haskell to it.
10:03:31 <conal> hyperisco: i've been playing with a few variations of this idea.
10:04:15 <hyperisco> conal, I read your work on that. That seems like a way to get to digital circuits. What I mean is, instead of having, say, IEEE floats, why don't we have a continuous voltage? (or whatever we choose to abstractly call it)
10:04:36 <hyperisco> Part of analog is noise, so that needs to be accounted for, but, it doesn't seem unreasonable
10:04:42 <conal> hyperisco: definitely with actual real numbers instead of IEEE floats.
10:05:44 <hyperisco> conal, essentially yes, plus some uncertainty.
10:05:45 <conal> hyperisco: choice of reals instead of floats follows from the same general principle as choosing nonstrict over strict, infinite over finite, and continuous over discrete, namely that exact composes well, while approximate doesn't.
10:06:05 <hyperisco> If you don't include uncertainty then I'd fear the program would be unimplementable as a real analog circuit, heh.
10:06:13 <conal> symptoms include the lack of simple and useful math properties of floating point.
10:06:48 <conal> hyperisco: we already have a form of uncertainty in nonstrict programming: partial information, of which bottom is an extreme case.
10:07:30 <nitrix> hyperisco: Great <3
10:08:01 <hyperisco> I am not sure how that would correlate. I don't have enough knowledge there. But I will say that in this perspective, digital is just a particular tolerance of uncertainty (thresholds)
10:08:20 <hyperisco> So, one could recover digital programming in that way.
10:08:30 <nitrix> Don't spend too much energy on me guys, I'm still reading through stuff :)
10:08:56 <qwebirc92334> To install and run GHC you need the following dependencies: Following commands are required, but missing, please install:  xz
10:09:05 <nitrix> Most of this is 10 feet above my head.
10:09:18 <glguy> qwebirc92334: What OS?
10:09:22 <qwebirc92334> what does this mean:
10:09:23 <qwebirc92334> To install and run GHC you need the following dependencies: Following commands are required, but missing, please install:  xz
10:09:54 <glguy> qwebirc92334: It means to install GHC you'll need to install xz
10:09:56 <conal> hyperisco: consider representing a real number as an infinite stream of bits in descending order (though there are practical reasons to tweak this representation). Then bottoms at any point in this representation (as a bit or a tail) denote all possible consistent values.
10:09:59 <conal> oops. gotta go.
10:10:22 <hyperisco> Be safe! Especially after leaving something in the margin like that.
10:11:26 <zeta_0> web-mode.el looks great but i don't know how i am going to use it with yesod, also there is the language server protocol but it uses npm(i'd prefer elisp instead), what would you guys recommend i use to do web development with yesod in emacs?
10:12:47 <hyperisco> Vaguely related… an evolved FPGA to distinguish 10kHz from 5kHz (iirc) included open circuits essential to its function, lol.
10:13:06 <hyperisco> There's a bit of the analog vs digital ideal battle in there.
10:18:22 <zeta_0>  i've decided to try out web-mode.el for web development, looks like a really great package
10:21:53 <ski> nil : looks like a type error, to me
10:23:57 <nil> well  ap fmap  means we're treating fmap's type as a monad, so one (the only?) instance that fits is Monad (r ->), but then there's (id &&& wtf) and i'm not familiar enough with arrows to know whether that can fit
10:25:19 <solonarv> well, let's start by asking for its type:
10:25:32 <solonarv> :t zip . ap fmap . (id &&& ?wtf)
10:25:33 <lambdabot> error:
10:25:33 <lambdabot>     • Couldn't match expected type ‘[a1 -> a2]’
10:25:33 <lambdabot>                   with actual type ‘(a0 -> b0) -> f0 a0 -> f0 b0’
10:25:42 <solonarv> yeah, that's a type error :>
10:26:24 <nil> i don't know whether i'm disappointed or relieved.
10:35:50 <hyperisco> ap :: f (a -> b) -> f a -> f b  so  ap fmap :: ((a -> b) -> g a -> g b) -> ((a -> b) -> g a) -> (a -> b) -> g b  is what I find
10:36:37 <hyperisco> The Monad isn't relevant to the type unification part of the problem
10:38:09 <d34df00d> Is there a type class representing a notion of a container into which values of a given type can be injected?
10:38:12 <ski> nil : "we're treating fmap's type as a monad" doesn't make any sense
10:38:32 <nil> i had a feeling it didn't
10:38:43 <d34df00d> I'd like to refactor `MonadError String m` into something more complex, but basic utility functions that only throw a single string probably don't care if it's MonadError String m or MonadError [String] m or what not.
10:38:48 <ski> nil : `id &&& f' is `graph f', where `graph :: (a -> b) -> (a -> (a,b))'
10:39:12 <ski> there's also `f ||| id' being `cograph f', where `cograph :: (a -> b) -> (Either a b -> b)'
10:39:26 <nil> ski: that's with the definition of (&&&) from Data.Tuple.Extra, what about the general Control.Arrow one?
10:39:32 <nil> generic*
10:39:51 <ski> `graph f' is the function `f', represented as a relation (via a subobject of the product of the domain and the codomain of the function)
10:40:08 <ski> nil : you can do that as well, if you prefer
10:40:20 <ski>   graph :: Arrow ar => ar a b -> ar a (a,b)
10:40:30 <ski>   cograph :: ArrowChoice ar => ar a b -> ar (Either a b) b
10:40:41 <ski> but you'll have to change `id' to `arr id'
10:40:44 * hackage rg 1.2.0.0 - A dynamic/unbounded alternative to Bounded Enum  https://hackage.haskell.org/package/rg-1.2.0.0 (ChrisDornan)
10:40:56 <ski> and this reminds us again of why `Category' is nicer than `Arrow'
10:41:57 <nil> you lost me at "relation"
10:42:14 <nil> i can see what graph does, but those words don't make sense to me
10:42:27 <ski> nil : anyway, "we're treating fmap's type as a monad" doesn't make any sense to me, because the type of a value, like `fmap', is always a concrete type. however, an instance of `Monad' is a type of kind `* -> *' (such that we have an implementation of `return' and `(>>=)' for it, satisfying laws)
10:43:01 <ski> (more generally, a monad must be a functor, even an endofunctor, on some category. can the type of a value be a functor ?)
10:43:07 <nil> sure.
10:43:40 <nil> i was putting myself in the shoes of the typechecker and saying "fmap's type must look like Monad m => m a, let's find a"
10:44:00 <ski> nil : consider this : given a function `f', we define a relation `R', such that `y = f(x)' is equivalent to `y R x' holding, for all `x' in the domain, and `y' in the codomain, of `f'
10:44:13 <ski> we can call the relation `R' the "graph" of `f'
10:44:23 <nil> (so instead of "a monad", i should have said "an applied instance of Monad i guess)
10:44:32 <nil> +"
10:44:52 <nil> ski: aaaah, i see
10:44:53 <ski> alternatively, we can associate the function `f' with a subset `{(y,x) | y = f(x)}' of the set `B * A', assuming `f : A >---> B'
10:45:15 <ski> this subset could also be called the graph of `f'
10:46:40 <ski> now, any subset `S' of a set `A' can be described categorically in terms of a morphism `i : S >---> A', which happens to be a monomorphism (an injective function)
10:47:30 <nil> why is it injective?
10:47:39 <ski> conversely, given any such morphism `i : S >>---> A' in `Set' (by the `>>' at the tail end i indicate that it's mono), we can "think" of this as specifying a subset (more generally, a subobject) of `A'
10:47:45 <hyperisco> Well, I worked out  ap fmap  twice and got the same answer, and it is wrong. Huh.
10:47:56 <dmwit> ski: This is a definition, not a theorem.
10:48:01 <dmwit> nil: I mean you, not ski.
10:48:16 <dmwit> nil: So "why is it injective?" is sort of a wrong question.
10:48:26 <ski> because when you include the elements of the subset into the enveloping set `A', you will never "confuse two elements"
10:48:43 <johnw> hyperisco: in `ap fmap`, which Monad is `ap` using?
10:49:01 <ski> e.g. consider
10:49:11 <ski>   i : |N >>---> |Z
10:49:14 <ski>   i(n) = n
10:49:19 <ski> each natural number is an integer
10:49:26 <dmwit> johnw: The ((a->b)->) monad, where the a and b are the ones from fmap :: (a -> b) -> ...
10:49:35 <ski> the inclusion `i' will map distinct natural numbers to distinct integers
10:49:38 <johnw> well, I know you would know, dmwit :)
10:49:43 <dmwit> ...oh
10:49:52 <ski> otherwise `i' wouldn't *just* be picking out a subset of `|Z'
10:49:53 <dmwit> I thought this was an actual question, not a pedagogical one. Sorry.
10:49:54 <hyperisco> johnw,  ap :: f (a -> b) -> f a -> f b  then  f = (->) (x -> y)  if  fmap :: (x -> y) -> g x -> g y
10:50:06 <hyperisco> somewhere along the line I am consistently seeing something the wrong way
10:50:12 <johnw> ok, hyperisco, just making sure this wasn't an aspect of the misunderstanding
10:50:29 <dmwit> hyperisco: (...and therefore g = ?)
10:50:49 <johnw> good followup q :)
10:50:50 <ski> if `i' is injective, then the only interesting part of how it maps into `A' (as long as we don't really care about the elements of `S') is *which* elements of `A' are "hit by" `i', and which aren't
10:51:01 <nil> ski: right
10:51:05 <ski> because `i' is injective, each element of `A' can be hit at *most* once by `i'
10:51:12 <hyperisco> why is g anything?
10:51:56 <ski> if we start with any injection `i : S >>---> A', then the image of `i', which is a subset of the codomain `A', is the subset associated with this injection
10:51:57 <dmwit> You're right. I asked the wrong question.
10:52:02 <hyperisco> (f (a -> b)) ~ (((->) (x -> y)) (g x -> g y))
10:52:03 <dmwit> hyperisco: (...and therefore a = ?)
10:52:13 <ski> and this subset is isomorphic to the domain, `S'
10:52:17 <hyperisco> dmwit,  a ~ g x, b ~ g y
10:52:39 * dmwit nods agreement
10:52:42 <nil> ski: ok, i see it
10:53:04 <hyperisco> ohhhh lmao
10:53:07 <hyperisco> I never did make a mistake lol
10:53:11 <ski> nil : so, in general, we can represent a subset (or a subobject) of a set (or object) `A', in category theory, by a pair `(S,i)', where `i : S >>---> A' is an injective function (or a monomorphism)
10:53:12 <hyperisco> I just misunderstood what I solved
10:53:21 <dmwit> yay!
10:53:21 <hyperisco> I was solving for the type of  ap  in  ap fmap
10:53:33 <hyperisco> and was confused why it didn't match the type of  ap fmap  lol
10:53:57 <ski> (nil : in some categories, injective (if it makes sense at all) doesn't coincide with being a monmorphism. also, in some cases, we'd prefer to have a stronger condition than merely being mono. but let's ignore that here)
10:54:06 <d34df00d> Ok, now I'm being really stupid. Let's say I have `class Foo base cont | cont -> base`. Why are `instance Foo base base` and `instance Foo base [base]` conflicting?
10:54:27 <hyperisco> d34df00d,  instance Foo base base  overlaps with everything
10:54:31 <glguy> d34df00d: base matches all types
10:54:50 <dmwit> d34df00d: Because `cont ~ [a]` could then mean `base ~ [a]` (from the first instance) or `base ~ a` (from the second instance).
10:54:54 <glguy> When you wrote | cont -> base, you were asserting that knowing base was enough to determine the instance
10:55:10 <d34df00d> Ah.
10:55:11 <dmwit> glguy: s/knowing base/knowing cont/
10:55:11 <glguy> errrr
10:55:12 <d34df00d> Hmm.
10:55:13 <glguy> yeah
10:55:23 <ski> nil : we call such a pair `(S,i)' a "subobject" of `A'. given another such pair `(T,j)', another subobject of `A', with `j : T >>---> A', we say they are equivalent if there's an iso (a bijection) `b : S >---> T', such that `i = j . b'
10:55:49 <d34df00d> So I'm effectively having instance for ([a], [a]) from the first one and for (a, [a]) for the second one.
10:55:50 <mclaren> 🎿 is that stronger condition split mono?
10:55:54 <d34df00d> And they obviously overlap.
10:55:56 <d34df00d> Thanks!
10:55:59 <dmwit> d34df00d: yep!
10:56:44 <d34df00d> So I presume there are no type classes encapsulating just the `pure` part of Applicative?
10:56:47 <ski> nil : and we say that the subobject `(S,i)' of `A' is included in the subobject `(T,j)' of `A', in case there's a `k : S >---> T' (not necessarily a bijection) with `i = j . k' (and `k' here must necessarily be an injection, so that `(S,k)' is a subobject of `T')
10:56:48 <nil> ski: got it
10:56:49 <d34df00d> I don't need the <$> part.
10:57:23 <dmwit> I think there's a Pointed class?
10:57:30 <ski> nil : so, to represent a relation between `A' and `B', we want a subobject of `A * B', iow some "base object" `R', together with a monomorphism `r : R >---> A * B'
10:57:37 <hyperisco> d34df00d, it exists somewhere but alone it is a dubious definition because there are no laws.
10:57:47 <dmwit> But it's... tough to write down laws that guarantee what you probably want from Pointed without also invoking (<*>) or similar.
10:58:02 <dmwit> https://hackage.haskell.org/package/pointed-5.0.1/docs/Data-Pointed.html#t:Pointed
10:58:09 <ski> nil : now, in the `graph f' case, with `f : A >---> B', we simply pick `R' to be `A' itself, and then `r' will be `<id,f>', or `id &&& f' in Haskell syntax
10:58:11 <d34df00d> I don't think I need much laws.
10:58:35 <dmwit> d34df00d: Okay. Then I write `instance Pointed [] where point x = replicate 42 x`. You are okay with this? ;-)
10:58:39 <d34df00d> Yeah, pointed looks good.
10:59:05 <hyperisco> What about  point x = []  ? heh
10:59:07 <dmwit> (If no, why no? Can you state why as a law? If you can't state it as a law, perhaps you start to see the problem.)
10:59:20 <d34df00d> In my code I'm ok with it.
10:59:32 <dmwit> Wow! Okay.
10:59:39 <dmwit> Then I think Pointed will be great for you.
10:59:46 * ski points
10:59:53 <d34df00d> I'm writing (Pointed p, MonadError (p String) m) => m MyStuff
10:59:58 <d34df00d> Feel free to replicate the error 42 times or 0 times!
11:00:01 <hyperisco> There is more than one use for type classes. I am willing to accept lawless classes for the purpose of overloading, for example.
11:00:19 * ski . o O ( lawless sequences )
11:00:46 <johnw> why use overloading, instead of taking a function as an argument?
11:00:48 <hyperisco> 'cause sometimes it is handy to not have to resort to C-style naming conventions :P
11:00:59 <hyperisco> And extra explicit arguments can be noisy.
11:01:08 <dmwit> johnw: Because it's handy for the compiler to insert that function for you.
11:01:11 <ski> nil : anyway, there's a dual concept of "quotient object", or "factor object", where you're representing a partition on `A' by an epimorphism (~ a surjection) from `A' to some object `F'
11:01:17 <johnw> overuse of typeclasses is an unfortunate thing
11:01:42 <johnw> it will seem like a great convenience in the beginning
11:01:57 <johnw> your readers will hate you for making it incredibly difficult to understand how your overloads are getting resolved
11:02:19 <hyperisco> As long as they hate me less than doing it the other way, whatever that way is, I'm winning.
11:02:44 <ski> nil : `cograph f : A + B >--->> B', given `f : A >---> B' is a factor/quotient object of `A + B'. imagine writing a table of input&output values of `f', and then putting corresponding inputs and outputs into the same equivalence class (so that inputs that map to the same output are also put in the same eq. class). that's a cograph
11:02:44 <johnw> I've found that boring, explicit code, is awesome for a much longer duration of time than the awesomeness of terse, exciting code
11:03:30 <hyperisco> If you're The Emperor of boring explicit code then I have to be Darth Vader.
11:03:41 <johnw> doesn't that mean we're allies for a long time?
11:03:56 <johnw> and that you'll end your life undoing me?
11:04:00 <hyperisco> Until you try and kill my son and I throw you into a pit, yes.
11:05:48 <hyperisco> Once in a blue moon it has made sense to me. That's all I'm saying.
11:06:21 <nil> ski: i don't get why the cograph's input is A + B (that is, "either" A or B)
11:06:40 <hyperisco> And the last time I thought I'd used lawless classes I decided that what would actually be better is conditional compilation. So, I don't like it either :P
11:07:06 <solonarv> d34df00d: at this point I would suggest writing your own monad transformer that is very similar to ExceptT and giving it a MonadError instance
11:07:17 <hyperisco> The testament there being that I found a way to value conditional compilation above something.
11:07:19 <solonarv> now your polymorphic code just has a 'MonadError String m' constraint again and all is well
11:07:47 <d34df00d> Hmm.
11:07:49 <d34df00d> Interesting.
11:08:13 <d34df00d> I'm having some places that do unwrapping/rewrapping like `liftEither . runExcept $ foo <|> bar`
11:08:42 <d34df00d> I could probably isolate my own transformer to those places for it to get a nice <|> semantics for collecting errors from both branches.
11:08:57 <d34df00d> Not exactly sure about pros or cons of this compared to my original design though.
11:09:31 <ski> nil : put all the inputs and outputs of `f' into the same bag, then carve out equivalence classes of that, where an input mapping to an output gets put into the same eq. class
11:09:52 <solonarv> something like: newtype AccumExceptT e m a = AccumExceptT { runAccumExceptT :: m (Either [e] a) } deriving (Functor, Applicative, Monad, MonadIO, <everything except MonadError>) via ExceptT [e] m; deriving MonadTrans via ExceptT [e]
11:09:56 <d34df00d> ...or maybe I could just do something like liftEither . first unlines . runExcept $ foo <|> bar.
11:10:09 <hyperisco> d34df00d, oh no you're not talking about collecting errors over both <|> and <*> are you?
11:10:15 <nil> ski: ok
11:10:16 <d34df00d> hyperisco: nope, just <|>
11:10:27 <d34df00d> I don't think I can reasonably collect over <*>
11:10:31 <d34df00d> That's why Validation is not a monad.
11:10:32 <hyperisco> d34df00d, oh, well in that case it exists, and I think it is called ValidateT or something
11:10:36 <solonarv> (the giant 'deriving' clauses there save you from having to write a billion trivial instances, instead you can just reuse ExceptT's instances)
11:11:11 <solonarv> (ghc 8.6+ only though)
11:11:13 <d34df00d> solonarv: how would you compare that to just doing `first unlines . runExcept`? Or `first mconcat` to be more generic.
11:11:31 <hyperisco> d34df00d, you can but you have to be particular about how you do it. Really you have to go back to your design requirements to figure out what is appropriate.
11:11:49 <solonarv> if you're doing string manipulation on your error messages that feels like a sign you've screwed up somewhere
11:12:06 <nil> ski: so, for e.g. f(x) = x%k , we'd get the quotient set Z/kZ
11:13:09 <d34df00d> solonarv: hm. That's very true.
11:13:19 <d34df00d> Indeed, I probably want to collect them as a list.
11:13:44 <hyperisco> Collect them as a DOC for pretty printing :D
11:13:57 <solonarv> a list of Doc's !
11:14:11 <d34df00d> Now I need a type class abstracting over all the pretty printers!
11:14:26 <solonarv> no, just pick one :>
11:14:38 <hyperisco> No, you just need to generalise to semigroups, heh, like Validate does. Why are you not using Validate again?
11:14:43 <d34df00d> But... not abstract enough...
11:14:51 <d34df00d> hyperisco: cause it's not a monad.
11:15:12 <d34df00d> How can I use Validate for code like `val1 <- parseVal1; val2 <- parseVal2BasedOnVal1 val1`?
11:15:20 <solonarv> also if we want Alternative we need a Monoid for the error type
11:15:23 <solonarv> d34df00d: you can't
11:15:33 <dmwit> ExceptT already has an Alternative instance with a Monoid constraint.
11:15:36 <hyperisco> d34df00d, the basic choices are Validate for <|> or Writer for <*> or >>=
11:15:39 <d34df00d> Although that's a shame.
11:15:53 <d34df00d> I want something like "early return, but proceed as much as you can" semantics.
11:16:04 <dmwit> d34df00d: Have you looked at ChronicleT?
11:16:14 <hyperisco> Both together are possible but, like I said, you have to be particular about it, and consider what your design requirements are.
11:16:17 <solonarv> oh, I remember that! it has funny names!
11:16:24 <d34df00d> So that I have `val1 <- parseVal1; val2 <- parseVal2; val3 <- parseDependent val1 val2` I get errors for val1 and val2 if either of them happens.
11:16:34 <solonarv> yeah, that's possible
11:16:37 <hyperisco> d34df00d, those seem at odds don't they? How do you exit early but also keep going as far as you can?
11:16:44 <dmwit> d34df00d: http://hackage.haskell.org/package/monad-chronicle-1/docs/Control-Monad-Chronicle.html
11:16:44 <solonarv> requires some finagling though
11:16:58 <d34df00d> hyperisco: I'm not sure. I'll have to think.
11:17:07 <ski> nil : well, the codomain there can be considered to be that factor set, yes. but that's not the cograph of `f'
11:17:12 <d34df00d> dmwit: hyperisco:  thanks for the Chronicle pointer, I'll follow it.
11:17:18 <solonarv> you can do it with a technically-law-breaking Applicative instance and ApplicativeDo if you want to retain the 'do' syntax
11:17:27 <hyperisco> d34df00d, if you want to go as far as you can you cannot use Monad, depending on what you mean by "as far as you can".
11:17:44 <d34df00d> solonarv: Iv'e considered ApplicativeDo early on, but won't it break with val3 as above?
11:17:46 <dmwit> ChronicleT lets you go as far as you can.
11:18:07 <dmwit> It supports both early-exit errors and accumulation of mere warnings.
11:18:08 <hyperisco> d34df00d, reason being that to keep going in a Monad you have to know the result of the last action to get the next action. So, if there is an error, you don't get the result, so you can't get the next action, so you necessarily have to stop.
11:18:15 <ski> nil : but, assuming we pick a codomain so that `f' is surjective, the cograph will be isomorphic to that factor set
11:18:36 <d34df00d> hyperisco: unless the next action doesn't depend on the previous result yet.
11:18:41 <hyperisco> d34df00d, it always does.
11:18:47 <d34df00d> I mean, semantically.
11:18:50 <hyperisco> It always does.
11:18:52 <d34df00d> I know how do desugars, but still.
11:19:05 <d34df00d> How does it for `val1 <- foo; val2 <- bar; pure (val1, val2)`?
11:19:10 <hyperisco> You have to decide from the beginning whether you stop on the first error or you keep going. No way around that.
11:19:12 <d34df00d> That's exactly (,) <$> foo <*> bar
11:19:48 <hyperisco> <*> has to work exactly the same way as ap, and ap is defined by >>=
11:19:51 <d34df00d> MonadChronicle methods are funny.
11:20:12 <d34df00d> hyperisco: yes, if you're a monad.
11:20:23 <hyperisco> You said you wanted a Monad.
11:20:28 <d34df00d> But if you forget the monad part then you cannot depend on previous results by definition.
11:20:50 <d34df00d> I want an applicative where I don't depend on the previous actions and monad otherwise.
11:20:51 <hyperisco> Alright, then don't make a Monad.
11:20:55 <d34df00d> Preferably in the same do block :)
11:20:58 <hyperisco> No, can't work like that :P
11:21:04 <d34df00d> But I don't know how to express that.
11:21:30 <d34df00d> ...except splitting the monadic parts out of applicative parts and annotating the constraints properly and using ApplicativeDo.
11:21:32 <hyperisco> I don't think you're letting the equivalence of ap and <*> really sink in
11:21:36 <d34df00d> But that's noisy.
11:21:37 <max___> q
11:22:12 <hyperisco> You cannot have these things behave differently unless you violate laws. And that's unadvisable.
11:29:17 <hyperisco> d34df00d, the short of it is that for dealing with the wild west, a Monad approach makes more sense because it can better adapt to whatever craziness you discover.
11:29:51 <hyperisco> If you know the domain well enough, and an Applicative works, then that is a better option.
11:32:02 <hyperisco> It is easy for a wrench to be thrown into the clockwork of a well-designed Applicative solution. Like, get this number, then that number is the number of foo-actions you have to do afterwards.
11:32:42 <hyperisco> Get this string, decode it, and that instructs on how to further dissect the rest
11:33:20 <hyperisco> These are Monad sorts of problems.
11:34:17 <hyperisco> d34df00d, what you can use is try/catch. This is an explicit usage, but it allows you to keep going in a Monad-based computation.
11:35:34 <hyperisco> In other words, if you can explain how to recover, then you don't need to stop when an action fails.
11:35:56 <hyperisco> Applicative of course never needs this in the first place because the next action is never contingent on the previous one.
11:44:45 <hyperisco> There is one trick though that I think I discussed with ski once… and that is that for commutative Alternatives, and for enumerable domains, you can just enumerate every possibility. So instead of  a -> f b  you can write  a_0 <|> a_1 ... <|> a_n
11:45:13 <hyperisco> If you're smart in your enumeration then maybe you do not need a commutative Alternative
11:45:45 <hyperisco> This can get you out of some jams if you find yourself with an Applicative system which needs to be adapted to new requirements
12:03:09 * ski smiles
12:16:03 <dmj`> Was miranda ever open sourced
12:16:59 <dmj`> Does anybody know?
12:22:18 <shapr> dmj`: not that I've ever found
12:23:59 <dmj`> shapr: sad day
12:24:24 <shapr> but I haven't looked in the past 5 or 10 years
12:34:44 <Boarders_> is there an easy way to write a function: subAt :: Int -> Vector a -> Vector a which takes an index and a vector to substitute at that index
12:44:28 <hyperisco> Boarders_, what are you substituting at the index? It probably depends on how you define Vector.
12:44:47 <Boarders_> what do you mean why am I substituting at the index?
12:45:02 <hyperisco> I am asking "what"
12:45:10 <Boarders_> oh sorry
12:45:35 <Boarders_> goot the type sig wrong
12:45:44 <Boarders_> subAt :: Int -> Vector a -> Vector a -> Vector a
12:46:08 <Boarders_> and is as one would expect: subAt 1 [1,2,3] [3,4,5] = [1,3,4,5,3]
12:46:34 <Boarders_> I can round trip into lists but don't know if there is a simpler way
12:48:32 <hyperisco> :t splitAt
12:48:34 <lambdabot> Int -> [a] -> ([a], [a])
12:50:43 * hackage semirings 0.4.2 - two monoids as one, in holy haskimony  https://hackage.haskell.org/package/semirings-0.4.2 (chessai)
12:53:39 <Boarders_>  I just manually wrote the list recursion myself
12:53:47 <Boarders_> but I would still be interested in something neater
12:54:04 <hyperisco> \n xs ys -> let (l, r) = splitAt n xs in l ++ ys ++ r
12:55:37 <Boarders_> I do want the tail of r but that is easier than the recursion, thanks!
12:56:41 <hyperisco> Hm, right, so drop 1
12:58:59 <solonarv> Boarders_: vectors have splitAt/drop too (they're ~zero-cost, even)
12:59:06 <Boarders_> yes, true!
12:59:12 <Boarders_> that is what I used ;)
12:59:41 <solonarv> so subAt c sub big = take c big <> sub <> drop (c+1) big
13:00:05 <Boarders_> it says on vector that split at is slightly more efficient than the take drop stuff
13:00:11 <Boarders_> not sure if that is true if I am doing tail too
13:00:24 <solonarv> that sounds very strange in the first place
13:00:29 <Boarders_> I agree
13:00:43 <solonarv> take/drop just do offset/length munging, they don't do actual work beyond that
13:00:58 <solonarv> I guess splitAt might have one fewer redundant bounds check
13:00:59 <hyperisco> I'm not familiar but that sounds a little concerning. If I take just a small part of a large vector, and that is zero cost, then it can't be creating a new vector for me. And if it isn't doing that, it is probably retaining the large vector.
13:01:11 <solonarv> hyperisco: that is exactly what happens
13:01:28 <solonarv> there's a function to explicitly copy the small part you sliced out into a fresh vector
13:01:35 <hyperisco> So, the empty vector could be mysteriously consuming 1Gig of memory :o
13:01:45 <solonarv> ByteString and (I think) Text do this too, btw
13:02:28 <solonarv> yes; on the other hand this means you do not thrash the allocator by constantly copying vector data unnecessarily
13:02:37 <hyperisco> Hrm. I have used something similar. However, I don't pretend one is the other, and to me that keeps the memory implications clear.
13:03:16 <solonarv> I mean, if you want the slice to not retain the big vector you just add in a call to 'force'
13:03:55 <solonarv> https://hackage.haskell.org/package/vector-0.12.0.2/docs/Data-Vector.html#v:force
13:05:02 <hyperisco> I am saying I'd have a Vector type which always consumes memory proportional to its size. Then I'd have a Slice type which is backed by a Vector, but I am not under the illusion that a Slice consumes memory proportional to its size.
13:07:11 <hyperisco> Maybe I could have a Slice type whose elements depend on which Vector you apply it to! That'd be interesting. I don't use that. But I can imagine it.
13:25:03 <Berengal> Does anyone know why in the llvm bindings the constant operand helper functions return operands inside an Applicative when they're just values?
13:45:05 <nil> i'm trying to connect the dots between monads in category theory and monads in Haskell. it seems like "return" must be a "natural transformation", that is, in Haskell, it must verify  fmap f (return x) = return (f x)  . what law guarantees this, on Haskell's side?
13:45:55 <Welkin> the functor one
13:47:00 <Welkin> your law is wrong though
13:47:01 <nil> i glanced over it, but i don't see how
13:47:13 <solonarv> nil: it might not be stated because it's a free theorem anyway
13:47:19 <solonarv> @free return :: a -> M a
13:47:19 <lambdabot> $map_M f . return = return . f
13:47:48 <nil> solonarv: i don't know what that means
13:48:13 <solonarv>  @free is a free theorem generator - you give it a type and it finds a free theorem for it
13:48:26 <solonarv> $map_M can be read as "fmap for M'
13:48:58 <nil> just googled that, seems interesting
13:49:14 <nil> Welkin: how is it wrong, and how do the functor laws give that?
13:49:23 <solonarv> so the free theorem for 'return :: a -> m a' is 'fmap f . return = return . f', or 'fmap f (return x) = return (f x)'
13:49:37 <Welkin> nil: I misread it, it's right
13:50:43 <nil> solonarv: do you know how this theorem is derived?
13:51:50 <polezaivsani> Is LYAHFGG still a good place to srtart with the language?  Anything particularly outdated language wise?
13:52:37 <solonarv> I don't know the exact derivation, but in general the reasoning for free theorems i salong the lines of: return doesn't know anything about 'a', so its behavior can't depend on the value you give it or even on the actual type chosen
13:54:27 <solonarv> all it can do is pass them around, or wrap them in something, and the like
13:58:22 <nil> the homomorphism law for Applicative looks very close to my thing
13:58:26 <nil> pure f <*> pure x = pure (f x)
13:58:58 <nil> combined with  fmap g x = pure g <*> x
13:59:27 <nil> the only missing piece of the puzzle is  pure = return
14:16:09 <halogenandtoast> polezaivsani: it's alright if you like the writing style. It definitely is still applicable to "most" of the language
14:16:30 <halogenandtoast> me personally, I hated it.
14:16:54 <halogenandtoast> my love is for Programming in Haskell by Graham Hutton
14:19:03 <polezaivsani> halogenandtoast: Thanks! I'll check it out.
14:19:36 <halogenandtoast> polezaivsani: LYAH has the benefit of being free, but I dislike th examples and find the writing impractical
14:20:02 <halogenandtoast> PIH on the other hand, had really neat examples and the writing wasn't as fluffy
14:20:27 <zeta_0> what is the difference between `ghci` and `cabal-new-repl`?
14:20:46 <halogenandtoast> zeta_0: cabal-new-repl loads your project into ghci iirc
14:21:37 <zeta_0> halogenandtoast: what does `iirc` mean?
14:21:47 <halogenandtoast> if i recall correctly
14:22:11 <halogenandtoast> I just tested it, it loaded GHCI along with my module
14:22:21 <halogenandtoast> *GHCi
14:23:01 <zeta_0> halogenandtoast: oh i see, thanks
14:23:06 <glguy> zeta_0: The more modern command is "cabal v2-repl" is what is does is make sure all that the dependencies you need are built and available 
14:23:10 <halogenandtoast> zeta_0: no problem
14:23:29 <glguy> and then opens a ghci session with those dependencies available
14:25:42 <zeta_0> glguy: so `cabal v2-repl` is the newest, not `cabal-new-repl`?
14:25:52 <glguy> new-repl is the old name for v2-repl
14:27:52 <zeta_0> glguy: so how would i change this then? https://hastebin.com/ecikukimub.sql
14:28:36 <glguy> zeta_0: You probably wouldn't change that. there cabal-new-repl is being used as an identifier that some emacs code expects to see
14:31:31 <zeta_0> glguy: i have cabal version 2.4, should i upgrade to cabal 3.0?
14:31:38 <glguy> no, 3.0 isn't released yet
14:34:24 <Welkin> so you're saying we can't upgrade to something that isn't released?
14:35:02 <glguy> More specifically that someone asking on IRC what version to use should be using the released version
14:36:10 <zeta_0> glguy: well, i want to be able to switch between haskell interactive processes ghci(M-`) and cabal-new-repl(C-c C-l) how do i add ghci process to my .emacs config? https://hastebin.com/ecikukimub.sql http://haskell.github.io/haskell-mode/manual/latest/Interactive-Haskell.html#Interactive-Haskell
14:36:13 <zeta_0> Here is a list of available process types:
14:36:13 <zeta_0>     ghci
14:36:13 <zeta_0>     cabal-repl
14:36:13 <zeta_0>     cabal-new-repl
14:36:13 <zeta_0>     cabal-dev
14:36:13 <zeta_0>     cabal-ghci
14:36:13 <zeta_0>     stack-ghci 
14:44:29 <zeta_0> so i am just trying to figure out what i need, i have cabal-new-repl setup with C-c C-l, i also want to setup ghci with M-`, and i am not sure if i need cabal-ghci?
14:44:44 * hackage jvm-binary 0.4.0 - A library for reading Java class-files  https://hackage.haskell.org/package/jvm-binary-0.4.0 (kalhauge)
14:45:10 <halogenandtoast> Can't help you with emacs issues, sorry :(
14:45:21 <halogenandtoast> I just use vim and ghcid
14:46:06 <zeta_0> halogenandtoast: could you at least explain to me what are the differences between these processes?
14:47:31 <halogenandtoast> ghci is the interpreter for ghc, cabal-new-repl is designed to be used in a haskell cabal new-project style project to launch ghci but also build and load the related modules in that project
14:47:54 <halogenandtoast> so cabal-new-repl just launches ghci with "some extra stuff"
14:48:01 <halogenandtoast> *cabal new-repl
14:50:27 <zeta_0> halogenandtoast: ok, i like cabal-new-repl because it has autocompletion and other features, but can only be opened when a .hs file is open, i am now trying to setup ghci process so i can open it anywhere
14:51:26 <zeta_0> maybe #haskell-emacs will be better
14:52:04 <halogenandtoast> :shrug: when in emacs I just M-x term and run what I want
14:53:13 <solonarv> nil: a bit late, but 'pure = return' is indeed a law (a law of Monad, specifically)
14:54:13 <nil> i found it under the laws for Applicative at https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Applicative
14:54:55 <solonarv> that's a misfile, it belongs to Monad :P
14:55:13 <zincy> https://github.com/therewillbecode/haskell-poker/blob/master/server/src/Socket/Msg.hs#L122
14:55:32 <zincy> ^ is there a better way of timing player actions in a game here?
14:55:45 <zincy> Because that is leading to all sorts of nasty concurrency bugs
15:38:13 * hackage dirtree 0.0.1 - A small library for working with directories.  https://hackage.haskell.org/package/dirtree-0.0.1 (kalhauge)
15:40:41 <Guest30255> @djinn (a->b) -> (Either (a->x) b)
15:40:41 <lambdabot> -- f cannot be realized.
15:41:42 <Guest30255> @djinn Void->Void
15:41:42 <lambdabot> f a = a
15:41:53 <Guest30255> @djinn a -> Void
15:41:53 <lambdabot> -- f cannot be realized.
15:42:21 <Guest30255> @djinn a -> b -> Either a b
15:42:21 <lambdabot> f a _ = Left a
15:42:40 <Guest30255> @djinn (a->b) -> (Either (a->Void) b)
15:42:41 <lambdabot> -- f cannot be realized.
15:43:30 <Guest30255> @djinn (Either (a->Void) b) -> (a -> b)
15:43:30 <lambdabot> f a b =
15:43:30 <lambdabot>     case a of
15:43:30 <lambdabot>     Left c -> void (c b)
15:43:30 <lambdabot>     Right d -> d
15:44:13 * hackage prometheus 2.1.2 - Prometheus Haskell Client  https://hackage.haskell.org/package/prometheus-2.1.2 (wraithm)
15:46:52 <solonarv> Guest56505: if you're looking for LEM (law of excluded middle), which it looks like you're doing, you can stop: that can't be done
15:47:13 <solonarv> Haskell's type system corresponds to intuitonistic logic, which does not have LEM
15:47:47 <nil> they left
15:48:05 <solonarv> dangit
15:50:31 <Welkin> god damn drive-by spammer
15:56:24 <newhoggy> Anyone know the answer to this pattern synonym question?
15:56:26 <newhoggy> https://github.com/haskell-works/hw-prim/pull/71
16:01:05 <guest__> @djinn (p,q) -> ((p,p),q)
16:01:05 <lambdabot> f (a, b) = ((a, a), b)
16:03:02 <Welkin> another one of those varmints!
16:03:12 * Welkin cocks shotgun
16:03:53 <Welkin> it was the same person
16:04:02 <Welkin> that is very annoying
16:12:32 <boj> at least they are doing something relevant and not spamming porn links
16:13:29 <nil> curry-howard porn
16:22:22 <hololeap> i'm having a hard time understanding the underlying problem behind an error i'm getting
16:22:34 <jle`> newhoggy: have you tried adding a type signature, like the error suggests?
16:22:44 <hololeap> i've been writing some code and using the Introduction to Singletons blog as a guide
16:23:00 <hololeap> here is what i have so far, which compiles: http://dpaste.com/0AKDT9D
16:23:41 <hololeap> but if i try to switch from `foo` to `foo_` (seen here on line 8) i get an error: http://dpaste.com/05ZD3PJ
16:24:46 <newhoggy> jle`: I don't know how to add one that compiles 😞
16:25:11 <jle`> hololeap: i take it you already see that the problem is that type inference can't figure out what 'b' is?
16:25:34 <jle`> and the problem is just figuring out how to tell ghc what 'b' is?
16:26:09 <hololeap> jle`: shouldn't foo_ be able to tell based on what is passed in as its first argument?
16:27:00 <jle`> ah, i'm just reading this directly off of the error message
16:27:03 <jle`> it says that b is ambiguous
16:27:58 <jle`> "could not deduce ... the type variable b0 is ambiguous"
16:28:24 <jle`> this type of error pops up in normal haskell often too (without any dependent types)
16:28:44 <newhoggy> For example:
16:28:53 <newhoggy> https://www.irccloud.com/pastebin/wc7tsPnF/
16:28:55 <jle`> usually i just add type annotations (or applications) until the ambiguity error disappears :)
16:28:57 <newhoggy> Doesn't compile
16:29:50 <jle`> newhoggy: what is the error?
16:30:11 <newhoggy> https://www.irccloud.com/pastebin/xKCLE4cF/
16:30:14 <hololeap> jle`: i was following a pattern i saw in your blog post, where you have `foo :: Sing i -> a -> b` and `(foo_ = foo sing) :: SingI i => a -> b`
16:30:46 <hololeap> i've tried to get this to work, but it just doesn't seem to unless i pass in (Sing i) explicitly
16:31:09 <jle`> try adding type annotations or type applications, like foo_ @??
16:31:24 <int-e> newhoggy: I think it want s a single type constructor there.
16:31:37 <jle`> hololeap: and, there's a good chance that if you can't figure out what goes there in the ??, then ghc might not be able to, either
16:31:51 <int-e> newhoggy: which means I don't see how to support your use case :-/
16:32:09 <newhoggy> That's what I feared.
16:32:20 <newhoggy> Thanks anyhow. :D
16:32:26 <jle`> hololeap: the situations where SingI i => works is where i can be inferred; it's an "implicit passing" form 
16:32:34 <jle`> if i can't be inferred, then it might be better to just do it explicitly
16:32:59 <jle`> hololeap: but, i think in your case, you should be able to figure out what the type variable is by using some scoped type variables in the patterns you match on, but i'm not 100% sure
16:33:50 <jle`> hololeap: hm, looking deeper, it looks like the type inference fails at the point where you return SomePair <$> rpf
16:34:05 <jle`> at that point, there is really no way to figure out what type variables rpf is instantiated with
16:34:20 <jle`> since you lose all of them once you stuff it into SomePair
16:34:44 <jle`> so you can either add a type signature to rpf's declaration, or you can just explicitly pass the singleton
16:34:56 <jle`> passing in the singleton here is equivalent to explicitly providing a type variable
16:35:22 <int-e> newhoggy: here's a smaller example with the same problem: http://paste.debian.net/1086673/
16:35:54 <jle`> hololeap: one big tool for type inference is that, by looking at the return type, ghc can infer what you want the input types to be.  this works for situations like fmap :: (a -> b) -> f a -> f b --- if you use the result as a list [b], then ghc knows that your input is also a list
16:36:00 <int-e> newhoggy: note that the stupid looking  {-# COMPLETE FTrue, FFalse :: [] #-}  allows 'f' to be accepted without pattern incompleteness warning...
16:36:20 <jle`> hololeap: but in this case, because you kill the type variables in SomePair, there is no return type for ghc to use
16:36:31 <int-e> newhoggy: I've also tried tricks like  type Id v = v; {-# COMPLETE FTrue, FFalse :: Id #-} to no avail
16:36:50 <jle`> this is like data Some = forall a. Some a, then then using `Some (read "6")`
16:37:07 <int-e> (that pragma is accepted, but ha no effect on the completeness check)
16:37:19 <jle`> hololeap: in that case, there is no way for ghc to know what instance of Read to use, and what type read "6" returns, because you never use it anywhere before you put it into the black hole of Some
16:37:19 <int-e> *has
16:37:43 <jle`> so either you can do Some (read @Int "6"), or Some (read "6" :: Int)
16:37:54 <jle`> or else some other way to give ghc help
16:38:03 <hololeap> jle`: thanks, i'll try that
16:38:31 <jle`> it seems in your case, the type variable is already hidden in some existential constructors, so you'd have to use type annotations in the patterns to recover them
16:38:59 <jle`> so it's probably simpler to just use the singleton you already have at this point, or some type inference trick using the singleton (like asTypeOf)
16:39:30 <jle`> unless i'm wrong, and the type variable is obvious in your situation :)
16:59:44 * hackage hw-prim 0.6.2.25 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.6.2.25 (haskellworks)
17:14:39 <hololeap> jle`: i would rather not have `meld` return both a `Sing b` along with `Product _ _ (RecPair b t u)`, but i can't seem to be able to recover `Sing b` from `Product _ _ _` by itself, so i suppose i have no choice
17:16:10 <hololeap> anyway, this is the working code so far... if you see a way that i can have `meld` _not_ return an explicit `Sing b`, please let me know: http://dpaste.com/2MD0VV9
17:17:43 * hackage dhall 1.24.0 - A configuration language guaranteed to terminate  https://hackage.haskell.org/package/dhall-1.24.0 (GabrielGonzalez)
17:18:44 * hackage dhall-bash 1.0.21, dhall-text 1.0.18, dhall-json 1.3.0 (GabrielGonzalez)
17:21:07 <hololeap> i suppose it has something to do with it being stuffed into an existential wrapper afterward. this is all still pretty hazy for me atm.
17:36:05 <jle`> hololeap: the type of meld is kind of weird right now, because it's universally quantified over 'b'
17:36:48 <jle`> which essentially means that the user can ask for a Sing of any b they want
17:37:29 <jle`> if you try writing an instance of Meldable, you'll see why that becomes a bit funky
17:37:50 <jle`> you *might* actually want existential quantification, not universal
17:38:07 <jle`> meaning that 'b' is determined by the 'meld' function's logic, and not universally choosable by the caller
17:42:22 <hololeap> jle`: that's exactly how it's supposed to work. meld needs to determine the path of the recursion
17:42:23 <jle`> that is, you might want (exists b. Sing b, Product (Base t) (Base u) (RecPair b t u))
17:42:38 <jle`> yeah, i thought so
17:43:22 <jle`> well, you can create a data type that existentially hides the b that you can use as the result of Meld, like data MeldResult t u = forall b. MR (Sing b) (Product (Base t) (Base u) (RecPair b t u))
17:43:59 <jle`> or you can use the singleton library's anonymous existential tuple type if you don't want to explicitly name the result
17:44:05 <jle`> *explicitly create a new data type
17:44:28 <hololeap> anonymous existential tuple?
17:44:40 <jle`> yeah, like how (a, b) is the anonymous tuple
17:44:49 <jle`> so you don't have to write data MyIntBool = MIB Int Bool
17:44:52 <jle`> you can just use (Int, Bool)
17:45:09 <jle`> *anonymous product, maybe, is a better word
17:45:27 <jle`> if you're just trying to get things to work/typecheck for now, it's probably easier to just make the explicit named data type
17:45:39 <jle`> and maybe use the anonymous version after refactoring, if you aren't already familiar with it
17:46:52 <hololeap> yeah, that seems like a good idea. what is the name of the anonymous product type you were referring to?
17:46:58 <jle`> it's in Data.Singletons.Sigma
17:47:06 <jle`> and it's not exactly the most "usable" tool, heh
17:48:00 <jle`> (as in, its usability leaves a much to be desired, but there's not much we can do now in current ghc)
17:50:47 <hololeap> jle`: what exactly is Σ referring to here? it seems like the idea was taken out of a textbook somewhere
17:53:22 <jle`> it's the typical notation for dependent sum
17:54:00 <jle`> the sigma comes from [S]um
17:54:42 <solonarv> roughly, if x1, x2, ... xn :: k, (and those are all the possible values) then Sigma k f ~ f x1 | f x2 | ... f xn
17:54:51 <solonarv> hence "dependent sum"
17:55:57 <hololeap> and f :: k -> *  ?
17:56:05 <solonarv> yes
17:56:57 <jle`> the implementation detail is that f in Data.Singletons.Sigma is actually k ~> *
17:57:24 <jle`> which means it's an actual type-level function
17:57:35 <jle`> or well, the defunctionalization symbol for a type-level function
17:58:04 <jle`> but that's really the only way to make it nice to use for something like \b -> Product (Base t) (Base u) (RecPair b t u)
17:58:14 <jle`> since we don't have type-level lambdas
18:00:12 <hololeap> so Σ takes a type level function from k to Type, and returns a Type
18:02:07 <hololeap> so, it's kind of like Data.Functor.Rep.tabulate
18:10:23 <jle`> tabulate is probably more related to Π, which has the same 'kind'
18:10:34 <jle`> i'm not sure why i put kind in quotes
18:11:28 <jle`> tabulate forms an isomorphism, but sigma is "one-way"
18:11:57 <jle`> but tabulate is pretty much literally the constructor for Π
18:13:50 <jle`> but yeah, i agree that the shape is similar :)
18:13:55 <solonarv> Pi is more like: Pi f = (f x1, f x2, ... f xn)
18:16:21 <jle`> right, that's essentially what tabulate is, too
18:19:14 * hackage network-byte-order 0.1.1.0 - Network byte order utilities  https://hackage.haskell.org/package/network-byte-order-0.1.1.0 (KazuYamamoto)
18:27:11 <hololeap> ok, i misunderstood. Σ is actually more like an exponential object
18:27:35 <jle`> ah i was thinking about it too and was thinking about the lower-order analogy
18:27:55 <jle`> if Π is like tabulate, Σ might be like ($)
18:28:05 <hololeap> and (@@) is like eval
18:28:09 <jle`> it takes an (a -> b) and an a and returns a b
18:28:28 <jle`> hm, that was confusing. it takes an `a -> b` and an `a` and returns a `b`
18:28:50 <jle`> hm, i guess that would be (@@)
18:29:02 <jle`> in this case it takes preserves the input as well
18:29:08 <jle`> sigma f x = (x, f x)
18:29:24 <hololeap> oh, ok
18:29:36 <jle`> so it applies the function, but also keeps the original argument for you to access later
18:29:51 <jle`> to make a lower-order analogy
18:34:25 <edrx> hi all... I am trying to run Agda here - on a Debian-ish box - and the "Hello world" failed, so now, after a few hours of work, I got several doubts about cabal... I just deleted all the debian packages with "agda" in their names and added ~/.cabal/bin/ to my PATH, but I'm getting some behaviours that are giving me the impression that some of the packages that I installed via cabal decided to use the libghc-agda in 
18:34:25 <edrx> /usr/share/libghc-agda-dev/lib/... is that possible? 
18:35:25 <edrx> is there a way to make cabal list all its installed packages?
18:36:51 <edrx> I can get a list - or sort of - by looking at ~/.cabal/logs/, but there may be a more elegant way...
18:42:32 <edrx> oh god =( "cabal install Cabal cabal-install" complained about the version of ghc... I'll try to install ghc from git...
18:42:58 <glguy> You shouldn't need to build GHC from git
18:44:36 <glguy> and Debian appears to package agda, so you shouldn't need to build that, either
18:45:22 <edrx> I tried to use the debian package for agda
18:46:03 <edrx> it seemed that the best way to deal with some errors was to install some things with cabal
18:46:40 <glguy> That probably isn't the way to deal with any errors generated from packages installed by Debian
18:47:25 <edrx> then trying to compiling hello.agda gave me errors like "Could not find module `Data.FFI'" (and also IO.FFI)
18:48:07 <edrx> well, I can either try to use the debian packages for everything
18:48:18 <glguy> Agda isn't really about running programs. Most of the fun is in just getting stuff to typecheck
18:48:51 <glguy> but fixing that error is something you ought to be able to do with-in debian
18:50:19 <glguy> Writing programs in Agda is actually a rather frustrating experience. If you're learning Agda now I'd put that off for a while
18:58:46 <edrx> I am mostly trying to show that all the nodes and arrows in the categorical diagrams that I used here - http://angg.twu.net/LATEX/2019notes-yoneda.pdf - can be typed in Agda...
18:59:21 <glguy> Perfect, you don't need IO for that
18:59:27 <edrx> I think that this will make my work look more solid
19:00:56 <glguy> You just need to encode your ideas in Agda and get the module to typecheck
19:03:01 <edrx> I couldn't find a PDF version of the Agda user manual online, so I downloaded Agda from git, discovered that I could do "make user-manual-pdf" and get it... and I somehow got the feeling that if I used versions from cabal and from git it would be easier to get docs and help... 
19:03:32 <glguy> https://agda.readthedocs.io/en/v2.6.0.1/ you already know about this?
19:04:45 <bofp> hey all, can anybody help me understanding zipWith?
19:04:46 <edrx> yes, but for me it's easier to keep links to pages of PDFs than to HTML pages (due to some emacs tricks that I use)...
19:05:18 <glguy> bofp: Feel free to ask questions; if someone knows the answer they'll jump in
19:05:31 <bofp> for some context: i'm trying to apply a function to every other element of a list using zipWith
19:05:57 <bofp> :t ($) shows that ($) :: (a -> b) -> a -> b
19:05:58 <lambdabot> error:
19:05:58 <lambdabot>     • Couldn't match type ‘[Char]’ with ‘(a1 -> b1) -> a1 -> b1’
19:05:58 <lambdabot>       Expected type: (a1 -> b1) -> a1 -> b1
19:06:14 <bofp> er, right
19:06:15 <bofp> anyway
19:06:18 <bofp> :t ($)
19:06:20 <lambdabot> (a -> b) -> a -> b
19:06:26 <bofp> :t zipWith
19:06:27 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
19:07:31 <bofp> so I'm trying `zipWith ($) (cycle [take 1, drop 1]) s`
19:07:39 <bofp> where s :: String
19:10:21 <pong> so you're trying to do (take 1) $ (head s)
19:14:39 <bofp> maybe? my understanding is that in (capitalizing the zipWith signature for clarity) `(A -> B -> C)`
19:14:58 <bofp> (a -> b) is my A, b is my B, and a is my C
19:15:41 <bofp> does that sound right?
19:16:01 <MarcelineVQ> bofp: zipWith takes two lists and combines the items pair-wise. If your first list has items that are functions from [a] -> [a] then to combine them the second list must have items of [a]. That is to say, it your second list must be a list [[a]]. String is [Char] but it is not [[Char]]
19:17:21 <bofp> MarcelineVQ: so I would be better off using (Char -> Char) functions instead of the take/drop
19:18:36 <MarcelineVQ> What's better depends on what task it is you're trying to accomplish
19:19:07 <bofp> good point -- ultimately get a new string out of every other character of a string
19:19:25 <bofp> e.g. "01234" -> "13"
19:20:44 <glguy> zipWith isn't for that
19:21:06 <bofp> hmm
19:21:42 <bofp> I've seen it used to apply functions to every other element of a list before, using `id` for the ones you don't care about... this just seemed like a similar pattern
19:21:53 <bofp> back to the drawing board
19:22:15 <glguy> > concat (zipWith take (cycle [0,1]) "example")
19:22:17 <lambdabot>  error:
19:22:17 <lambdabot>      • Couldn't match type ‘Char’ with ‘[a]’
19:22:17 <lambdabot>        Expected type: [[a]]
19:23:03 <glguy> > concat (zipWith (\i x-> take i [x]) (cycle [0,1]) "example")
19:23:05 <lambdabot>  "xml"
19:23:27 <glguy> But that's not something I'd save in a file
19:24:43 <ski> > [c | (c,True) <- "01234" `zip` cycle [False,True]]
19:24:46 <lambdabot>  "13"
19:26:17 <MarcelineVQ> bofp: is this for fun or are you doing the double every other from the right homework?
19:27:17 <bofp> it's for fun -- just trying to learn more haskell and fp
19:28:00 <bofp> this started off as a codewars problem
19:28:15 <MarcelineVQ> if it's for fun then this is a good time to learn about foldr, which has a cute solution to this task
19:29:57 <bofp> I started playing with folds but felt like a binary function was losing the context of the list (i.e. every other element)
19:30:15 <bofp> so it felt like the wrong path at the time but I'd love to be enlightened :)
19:30:19 <MarcelineVQ> allthough I'd like to hear what glguy would use instead of zipWith when faced with the task
19:32:26 <glguy> everySecond (_:x:xs) = x : everySecond xs; everySecond _ = []
19:32:40 <MarcelineVQ> :D
19:32:50 <glguy> I'd just write it out
19:33:35 <glguy> :t uncons
19:33:36 <lambdabot> [a] -> Maybe (a, [a])
19:33:44 <glguy> :t unfoldr
19:33:46 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
19:34:17 <glguy> :t \i -> unfoldr (uncons . drop i)
19:34:18 <lambdabot> Int -> [a] -> [a]
19:34:34 <MarcelineVQ> uncons is my favorite list-related function
19:35:06 <glguy> > unfoldr (uncons . drop 2) [1..10]
19:35:08 <lambdabot>  [3,6,9]
19:38:22 <MarcelineVQ> bofp: I'm not sure what you mean about context exactly. in the binary function of a fold, foldl or foldr, one of the arguments to that function is the new value you're creating as you traverse the list. have a gander here http://web.archive.org/web/20180522150722/http://ertes.eu/tutorial/foldr.html
19:38:43 <MarcelineVQ> Actually I think this exact problem has an example on that page, so work your way through it from the top
20:09:13 * hackage fixed 0.3 - Signed 15.16 precision fixed point arithmetic  https://hackage.haskell.org/package/fixed-0.3 (EdwardKmett)
20:11:44 * hackage http-directory 0.1.4 - http directory listing library  https://hackage.haskell.org/package/http-directory-0.1.4 (JensPetersen)
20:43:14 <newhoggy> int-e: Thanks!  I'm curious why pattern synonyms care that it is polymorphic.  Surely it is syntactic sugar for a different pattern match and completeness can be checked on the desugared code even if the error might be unintuitive.
20:56:13 * hackage pkgtreediff 0.3 - Package tree diff tool  https://hackage.haskell.org/package/pkgtreediff-0.3 (JensPetersen)
21:00:45 * hackage registry 0.1.5.5 - data structure for assembling components  https://hackage.haskell.org/package/registry-0.1.5.5 (etorreborre)
21:17:50 * ski idly wonders how newhoggy's `HW.Elem' is defined
21:45:30 <newhoggy_> Kinda disappointed `snoc` is defined as `snoc :: ByteString -> Word8 -> ByteString` instead of `snoc :: Word8 -> ByteString -> ByteString`
21:46:24 <jle`> newhoggy_: the latter would be pretty confusing, wouldn't it?
21:46:41 <delYsid``> the latter would be cons.
21:46:43 <jle`> snoc 'a' "bc" = "bca" ?
21:47:03 <jle`> 'a' `snoc` "bcde" => "bcdea" ?
21:47:18 <newhoggy_> I reckon the former is better for currying.  As in `f (snoc 'a')`
21:47:34 <jle`> the former probably makes more logical sense in terms of lexical ordering
21:47:47 <jle`> in how humans parse things
21:47:59 <ski>   f (`snoc` 'a')
21:47:59 <jle`> it'd  be weird if the left hand side were added to the right hand side
21:48:13 <jle`> er, the left hand were added on the right hand
21:48:27 <newhoggy_> If lexical ordering matters, then we should be using operators.
21:48:29 <jle`> as in, 1 `snoc` [2,3,4,5]  would return [2,3,4,5,1]
21:48:51 <jle`> i mean, it's unavoidable
21:49:04 <jle`> if you read `snoc 1 [2,3,4,5,6]`, it's kind of weird to expect it to be [2,3,4,5,6,1]
21:49:15 <jle`> just because the 1 comes before the 2,3,4,5,6
21:49:33 <jle`> honestly i feel like that behavior would lead to a lot of bugs
21:49:43 <ski> > (`snoc` 1) [2,3,4,5,6]
21:49:45 <lambdabot>  [2,3,4,5,6,1]
21:49:56 <newhoggy_> I think it's reasonable.  For example `prepend 1 [2,3,4]` and `postpend 5 [2,3,4]`
21:50:21 <jle`> postpend 5 [2,3,4] is still a little confusing, it makes you have to read the function name to know what's going on
21:50:25 <jle`> vs. postpend [2,3,4] 5
21:50:35 <delYsid``> newhoggy_: You can always use flip!
21:50:47 <jle`> and the glyphs that comprise prepend and postpend are easily confused/difficult to distinguish at first glance
21:50:48 * ski . o O ( `preprohend' )
21:50:49 <delYsid``> prepend = flip snoc
21:50:55 <newhoggy_> I know :D
21:51:12 <jle`> it just feels like inviting human error, heh
21:51:57 <jle`> prepend 1 [2,3,4] vs. postpend [2,3,4] 5, it's easier to tell at a glance what's going on
21:51:57 <newhoggy_> I breaks the very common convention, which is `blah :: argument -> argument -> container -> container`
21:52:36 <ski> two ?
21:53:00 <jle`> luckily we have a type system to prevent mixing containers and elements
21:53:39 <jle`> so those types of errors are much harder to come by
21:54:03 <newhoggy_> Just as well :D
21:58:32 <newhoggy> ski: You mean this?
21:58:39 <newhoggy> https://www.irccloud.com/pastebin/MkKSN1Ae/
21:59:12 <petersen> Anyone know of any package maintainer tool for maintaining Haskell packages?
21:59:44 <newhoggy> https://hackage.haskell.org/package/hw-prim-0.6.2.25/docs/HaskellWorks-Data-Container.html
21:59:48 <petersen> Nothing fancy, I just mean package release workflow: git tag, upload, etc
22:01:52 <jle`> petersen: do you need anything outside of cabal/stack ?
22:01:52 <ski> newhoggy : the problem was the `COMPLETE' pragmas, yes ?
22:02:15 <petersen> Currently I am copying a dumb Makefile file around for this... but it gets tiring
22:02:16 <jle`> or are you talking about automated deploys and stuff
22:02:34 <jle`> ah, are you just talking about developing a haskell package, managing dependencies and building and stuff?
22:02:47 <petersen> Maybe I should ask twitter - otherwise I probably just write something simple
22:03:06 <petersen> jle`: I meant upload to Hackage
22:03:31 <petersen> jle`: sorry missed your initial reply
22:03:48 <petersen> jle`: no :)
22:04:10 <jle`> yeah, 'stack' and 'cabal-install' are the two tools people usually use for development and deployment to haskell
22:04:20 <petersen> jle` yes I know
22:04:20 <jle`> you use them somewhat independently of each other, and choose one
22:04:27 <jle`> both of them have hackage deployment commands
22:04:30 <petersen> That is not what I am asking
22:04:36 <petersen> I know
22:04:45 <petersen> I want shorter command :)
22:04:49 <petersen> s
22:05:07 <jle`> do you mean like, automating git tag/pushing to github/sdist/upload ?
22:05:39 <petersen> myprojecttool tag; myprojecttool upload; myprojecttool push; myprojecttool publish
22:05:45 <petersen> exactly
22:06:08 <jle`> is that really less commands than just using git tag, git push, stack sdist, stack upload? ;)
22:06:30 <petersen> Maybe I should try stack hmm, but yes
22:06:42 <jle`> cabal would be the same: git tag; git push; cabal sdist; cabal upload
22:06:48 <petersen> Obviously myprojecttool is a really bad name...
22:07:15 <petersen> jle`: nope you need to pass the tarball name to cabal, at least for my version
22:07:28 <petersen> and get the tag right, etc
22:07:42 <petersen> Yes I know it is not very hard, but I am lazy 8-)
22:08:01 <jle`> ah, maybe the stack does simplify things? for me it's `stack sdist .; stack upload`
22:08:06 <jle`> verbatim
22:08:09 <petersen> okay
22:08:23 <petersen> But I don't use stack that much - ssssh ;o)
22:08:41 <jle`> that's fair too. but i feel like cabal should have a similar simple workflow, hm
22:08:44 <jle`> definitely worth asking :)
22:08:49 <petersen> True
22:09:00 <petersen> You are right should really be integrated
22:09:08 <jle`> just make sure you save at least one command before you make the switch :P
22:09:24 <petersen> hehe :)
22:19:44 * hackage hw-fingertree 0.1.1.0 - Generic finger-tree structure, with example instances  https://hackage.haskell.org/package/hw-fingertree-0.1.1.0 (haskellworks)
22:34:47 <trinity_> q
23:25:46 * dminuoso wonders why there is no acme-cocomonads
23:28:51 <tdammers> dminuoso: because you haven't written it yet. come on, show some responsibility.
23:29:20 <nshepperd> Ntrol.Comonad
23:34:26 <ski> @oeis 0 2 3 4 5 3 7 4 6 5
23:34:26 <lambdabot>  https://oeis.org/A064760 Variant of A002034 with initial term 0.
23:34:26 <lambdabot>  [0,2,3,4,5,3,7,4,6,5,11,4,13,7,5,6,17,6,19,5,7,11,23,4,10,13,9,7,29,5,31,8,1...
23:40:50 <c0nd13> hello
23:41:56 <ski>    hello
23:43:02 <dminuoso>       hello
23:44:07 <ben_m>          hello
23:45:01 <ski> (dminuoso, you have eight too many spaces, your space credit is overdrawn)
23:52:05 <dminuoso> 6 spaces used, charging me for 8. Spatial institutions taking advantage of regular folks once again.
