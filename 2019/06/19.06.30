00:30:29 <kaol> Is there some newtype for monads that has an instance Monoid?
00:32:56 <MarcelineVQ> shafox: https://hackage.haskell.org/packages/search?terms=lock kaol: https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Monoid.html#t:Ap
00:53:42 <kaol> I don't think Ap fits. I was thinking about how (return >=> return) 1 :: Maybe Int gives a Just 1. That is there some Foo such that (getFoo (Foo return <> Foo return)) 1 :: Maybe Int would also be a Just 1. If I try that with Ap I'll just get an error about missing Semigroup Int instance.
01:02:17 <kaol> I mean, if monads are just monoids in the category of endofunctors then how do you use (<>) on them?
01:06:38 <MarcelineVQ> for Maybe in particular you could use First or Last but idk in general. do the terms work like that? we're not in the category of endofunctors when we use haskell are we?
01:07:31 <MarcelineVQ> I don't know what the category of endofunctors is, that's as much a question as a prompt
01:08:26 <kaol> The monad laws are just the same as the monoid laws when written in terms of (>=>). I just feel that there's something missing if I can't replace it with (<>).
01:12:40 <marmulak> are those like the noahide laws
02:06:49 <sclv> the <> operates between `f f a` and `f a` so on the _endofunctor_ not on the value as a whole
02:07:03 <sclv> so that's not the haskell mappend operation, its monadic "join"
02:07:23 <sclv> the point is "chop off" the last bit, and just look at the chain of fs.
02:07:40 <sclv> then you have "return" to introduce one -- that's the unit of a monoid
02:07:53 <sclv> and you have `join` to merge two, which is the mappend
03:17:15 <Guest_44> I am trying to install ghc using ghcup as described on the Haskell website but I am getting the following error: Following commands are required, but missing, please install:  xz Following commands are required, but missing, please install:  xz
03:21:07 <lavalike> Guest_44: seems to me you have to install the program xz
03:22:31 <Guest_44> I downloaded xz from this link: https://www.haskell.org/ghc/download_ghc_8_6_2.html, but that didn't help..
03:23:08 <lavalike> Guest_44: xz is a compression format, and a program to work with .xz files, you are missing the program
03:23:23 <lavalike> what os are you on?
03:23:51 <Guest_44> where can I install it? I am using mac os
03:24:28 <lavalike> Guest_44: a good way is using Homebrew https://brew.sh
03:24:43 <lavalike> it'll let you do "brew install xz" and get it for you
03:24:46 <oo_miguel> I am trying to understand some very simple ghc core code and wonder why (+) is passed some additional argument named $fNumInt? I read that it is some kind of "dictionary" but do not understand what it is for and what it represents.
03:24:59 <lavalike> :t (+)
03:25:00 <lambdabot> Num a => a -> a -> a
03:25:32 <oo_miguel> it is passed 3 arguments: (+ $fNumInt acc_aVI x_aVK)
03:25:34 <Guest_44> Okay, I'll try that, Thank you :)
03:25:43 <lavalike> oo_miguel: my limited understanding is that you can squeeze your eyes and make => look like a -> that is the "Num a" is an actual parameter that gets passed, and in your case 'a' has been specialized to Int so you're seeing the NumInt dictionary in particular
03:26:08 <oo_miguel> ah
03:26:28 <lavalike> oo_miguel: if you look at the definition of Num you'll see it comes with a number of functions, that object has references to them
03:26:34 <lavalike> i.e. "dictionary"
03:26:48 <lavalike> I'm sure this is not the complete story but it should be close enough
03:27:10 <oo_miguel> so $fNumInt is "something" that lets (+) treat Int as a Num ?
03:27:46 <oo_miguel> guess this is enough to satisfy my curiousity at this point, thanx
03:27:52 <lavalike> it's like Map String (Int -> Int -> Int) if all of the Num a functions were 2-arg functions
03:28:07 <lavalike> $fNumInt "+" :: Int -> Int -> Int
03:28:25 <lavalike> at least conceptually, I'm not saying it is actually an haskell map and it uses strings, just to get the point across
03:29:30 <oo_miguel> just tested it with Doubles and get $fNumDouble instead. this begins to make some sense ;)
03:29:33 <lavalike> imagine  instance Num Int where { (+) = addTwoInts ... } then the code that uses + is transformed into using  $fNumInt "+"  which evalutes to  addTwoInts
03:31:18 <oo_miguel> lavalike: I understand it now (at least understand enough to be happy for now). thank you very much!
03:36:28 <oo_miguel> My other source of confusion is (I# 0#). Does this create an boxed Int from the unboxed 0? Can I do something similar explicitly myself within haskell or is this some notation reserved to core?
03:37:28 <fr33domlover> I constantly get bitten by missing record fields being a warning and not an error - is that a sign I should probably use strict fields? Or maybe it's time to fix the billion warnings I have? ^_^ (and then new warnings will be easy to spot)
03:38:01 <Rembane> fr33domlover: Turn all warnings into errors for a while. :D
03:38:07 <__monty__> fr33domlover: Most people enable at least -Wall.
03:39:08 <maerwald> for local development yes, not for shipping
03:39:12 <fr33domlover> __monty__, I already have -Wall :) Rembane, haha yeah maybe I should 
03:39:13 <lavalike> oo_miguel: it's explained here https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=hash#extension-MagicHash
03:39:30 <__monty__> fr33domlover: Hmm, maybe it's time for -Weverything?
03:40:03 <fr33domlover> __monty__, that would be even worse because I'd get even more warnings and miss the really important ones
03:40:21 <fr33domlover> I guess I should fix all the warnings
03:40:34 <fr33domlover> And then new warnings will be easy to notice
03:40:54 <oo_miguel> lavalike: ah allright. need to enable it, thanks
03:42:13 <__monty__> fr33domlover: -Weverything -Werror?
03:42:49 <fr33domlover> __monty__, -Wall -Werror will do :)
03:43:06 <__monty__> fr33domlover: Oh, actually, you could do specifically -Werror=Wmissing-fields.
03:57:52 <fr33domlover> __monty__, oh cool
06:01:07 <vaibhavsagar> how do I use cabal with a stack resolver?
06:01:43 <vaibhavsagar> I tried downloading the `cabal.config` from lts-13.26 and plopping it in my project root but cabal is complaining about a missing `vector`, which makes no sense
06:02:47 <geekosaur> stack manages its own ghc separate from what cabal can see, and you'll usually get a conflict trying to get not-stack to use stack's private copies. although you might be able to extract a path to its ghc and specify that in cabal.project.
06:03:03 <vaibhavsagar> I'm not having any issues with ghc
06:03:28 <vaibhavsagar> and I'm not trying to get cabal to use stack-provided dependencies
06:03:29 <geekosaur> ghc-pkg is part of the ghc "suite", not a separate tool (they must exactly match)
06:03:35 <vaibhavsagar> just the version bounds
06:03:39 <geekosaur> and it's looking for vector somewhere. think hard: where?
06:03:59 <vaibhavsagar> as opposed to thinking softly?
06:04:11 <vaibhavsagar> I have no idea, I don't actually use stack at all
06:12:46 <cocreature> vaibhavsagar: can you show us the full error?
06:15:40 <vaibhavsagar> cocreature: I'm trying to run `cabal install --only-dependencies` to see if that gets me past this particular failure
06:45:00 <janat08> I got JavaScriptFFI extension, and GHCJS.Types (JSVal), yet I get parse errors for foreign import
07:26:08 <kerbygys2> 4,01S0738x9y3L1216n4u7x 8r9u3l12e6s4!
07:26:14 * kerbygys2 4,01S0738x9y3L1216n4u7x 8r9u3l12e6s4!
07:28:43 <brookvoy6> 4,01S0738x9y3L1216n4u7x 8r9u3l12e6s4!
07:28:48 * brookvoy6 4,01S0738x9y3L1216n4u7x 8r9u3l12e6s4!
07:32:31 <marchallxno4> 4,01S0738x9y3L1216n4u7x 8r9u3l12e6s4!
07:32:37 * marchallxno4 4,01S0738x9y3L1216n4u7x 8r9u3l12e6s4!
07:41:15 <yorick> good times
07:52:33 <remexre> Is `lens id (\x -> seq (rnf x) x)` a reasonable construct?
07:54:24 <sarahzrf> remexre: thaaat is an interesting question
07:55:12 <mniip> seq (rnf x) x = force x
08:01:17 <phadej> remexre: http://oleg.fi/gists/posts/2017-11-17-composing-getter-and-setter.html
08:12:29 <remexre> phadej: I don't think that's exactly what I'm doing; I've got a field I always want to be deeply strict, and I want to try to enforce it by making the only (exported) accessor a lens that deeply evaluates its value before setting it
08:15:38 <fr33domlover> o/ anyone knows is there's a way in Hamlet to have a tag and then text attached without spaces? e.g. https://share.riseup.net/#kYZjzQ-dYRSwJZ24MPgd7g
08:15:58 <fr33domlover> I want to see "Joe's car" in the HTML, instead it's "Joe 's car"
08:16:08 <fr33domlover> And I want to get rid of that space ^_^
08:16:15 <sarahzrf> remexre: what problem are you solving?
08:17:55 <remexre> sarahzrf: I've got a big structure I want to be able to query fast
08:24:14 <infinisil> Hey, is it possible to have a single .cabal with a library, an executable that depends on the library, and a test-suite that tests modules from both the library and the executable?
08:25:02 <infinisil> Because when I try this by just adding the build-depends, cabal gives me an error: https://gist.github.com/339e22e04e88c83a4f4b3efe92e0f218
08:28:57 <infinisil> This seems like something so simple, yet cabal fails on it..
08:36:14 <d34df00d> I have a deep hierarchical data structure that's following the "Trees that grow" pattern (essentially being tagged by a dummy type parameter). Say it's `data Request f = ...`, where there are sub-objects tagged with `f` on the RHS, and so on.
08:36:32 <d34df00d> Now let's say I want to write a function `compile :: Request InputStage -> Request Compiled`
08:36:55 <d34df00d> It turns out that the only change needed is somewhere deep in the structure. Do I have better options than manually unpacking/repacking everything?
08:37:19 <janat08> im in ghcid, and I'm not sure what module I'm working in
08:38:37 <sarahzrf> remexre: can you just build it out of strict types?
08:39:17 <remexre> sarahzrf: possibly; is there something specifically wrong with the lens?
08:39:29 <sarahzrf> not sure
08:39:32 <dmwit> d34df00d: No, and it's important that you have no other choice. Otherwise how would the compiler check that you have actually compiled all the right subchunks?
08:39:40 <sarahzrf> im probably just being contrarian :(
08:40:01 <sarahzrf> well, i guess the lens just smells kind of ad hoc to me, whereas strict types are a pretty common thing to exist
08:40:03 <sarahzrf> that's all
08:40:07 <janat08> i was looking for :load command
08:40:20 <dmwit> d34df00d: Of course, anywhere you don't have a subchunk that doesn't need to change you can just copy it over. Because it doesn't have a tag, see? But if it does have a tag, it might need to change, so...
08:41:23 <d34df00d> dmwit: well, if the type instance for f1 is equal to type instance for f2, then presumably there is no need for any actual run-time actions, so the typechecker might coerce it for me, or some (TH?) library would reduce the boilerplate.
08:41:29 <d34df00d> Much like transformBi, but polymorphic.
08:41:46 <d34df00d> But I see your point and I totally agree. I'm just being lazy.
08:41:54 <dmwit> d34df00d: Yep, if the type instances are equal, then you can copy.
08:41:55 <d34df00d> Basically I want transformBi and the typechecker to do the rest for me.
08:41:59 <dmwit> Because the types are then also equal.
08:51:30 <d34df00d> Yay functor functors!
08:51:40 <d34df00d> I wonder if one can derive an instance of FFunctor automatically.
08:52:34 <d34df00d> ...not gonna work in my case though.
08:53:46 <solonarv> kaol: Monoid is too type-constrained for that to work the way you want to; it requires both its arguments to have the same type, so it would only let you compose (a -> m a) with the same a
08:54:09 <solonarv> I guess that is why there's no type with that Monoid instance; you could certainly write it yourself quite easily
08:54:17 <d34df00d> Hmm... I could maybe make a type class `Compile` with an `id` implementation for non-parametrized types, a recursive/Generic implementation for those types that only have subobjects, and so on.
08:54:30 <d34df00d> Dammit, why do I constantly overengineer.
08:55:21 <maerwald> Because you're doing haskell
08:56:25 <d34df00d> Lol, true.
08:59:00 <dmwit> d34df00d: You will probably eventually want it to be monadic instead of pure, so I recommend `pure` as your base case instead. You can always recover the pure version with `Identity`.
08:59:21 <dmwit> (e.g. error-reporting is a common choice of side effect)
08:59:39 <dmwit> (and reader or similar for scoping stuff)
08:59:44 <d34df00d> That's a good idea!
08:59:52 <d34df00d> More engineering!
09:00:03 <d34df00d> Thanks for the hint, would be more painful to change it later on.
09:00:16 <dmwit> This doesn't save you from "unpack/repack", though. It just means that code goes in a class instance instead of a standalone function.
09:00:34 <d34df00d> Yep, but I could maybe derive a meaningful instance automatically for quite some types via generics.
09:00:55 <d34df00d> (at least, those that don't depend on `f` themselves but just pass it on)
09:01:31 <d34df00d> I'll also have nice modularization since the compilation passes for different subobjects will be very explicit where needed.
09:01:57 <solonarv> you're just reinventing SYB/uniplate/biplate and the like, I think?
09:02:05 <d34df00d> Yep. But polymorphic.
09:02:08 <solonarv> although I'm not sure if any of these handle type-changing
09:02:15 <d34df00d> Nope, they don't.
09:02:19 <d34df00d> AFAIK
09:02:25 <d34df00d> But transformBi is surely my inspiration.
09:20:21 <d34df00d>     • Can't make a derived instance of ‘Generic1 RuleOptsT’: Constructor ‘RuleOpts’ applies a type to an argument involving the last parameter but the applied type is not of kind * -> *
09:20:23 <d34df00d> That sucks.
09:21:02 <mniip> higher kinded generics are kind of problematic
09:24:25 <d34df00d> Especially given I don't have much experience with generics...
09:25:37 <d34df00d> Now I question if something like `default compile :: (Generic (c RawInput), Generic (c Compiled), GCompile (Rep (c RawInput)) (Rep (c Compiled))) => ...` would make sense.
09:30:58 <lyxia> For higher-kinded generic programming, there's kind-generics
09:43:34 <d34df00d> So if the typechecker tries to satisfy the constraint `Compile (RuleT RawInput) (RuleT Compiled)`, why does it consider `instance (Functor f, Compile from to) => Compile (f from) (f to)` even if RuleT is not a Functor?
09:43:48 <d34df00d> I'm getting overlapping instances between this one and the proper one for RuleT.
09:44:42 <cocreature> d34df00d: GHC selects the instance by only looking at the instance head. the constraints are only taken into account once it has selected an instance
09:44:59 <d34df00d> Ah, right, forgot about that, thanks!
09:45:06 <d34df00d> Do I have any good workarounds in this case?
09:46:53 <cocreature> depends on what your other instance is
09:47:07 <cocreature> you might be able to use an OVERLAPPABLE/OVERLAPPING pragma if one is more specific than the other
09:47:25 <glguy> Even better is not to have the  Compile (f from) (f to) instance at all
09:47:43 <glguy> You can provide a default implementation for instances to use if they wanted the behavior of this instance
09:47:53 <glguy> for example how we have: fmapDefault and foldMapDefault
09:48:22 <d34df00d> That's very neat to have it for functors though.
09:48:39 <d34df00d> That covers both lists and (ty,) straight away.
09:50:05 <d34df00d> I vaguely remember tyVar ~ Ty is somewhat relevant to instances, but I haven't used that for a while and I can't write a proper google query.
09:50:22 <d34df00d> Where do I read about its semantics in this context?
09:50:31 <d34df00d> (I mean, the syntax
09:50:32 <d34df00d> )
09:51:01 <d34df00d> Is it "select this instance and then check that the instantiation of tyVar is actually Ty"?
09:54:23 <solonarv> if you write 'instance ty ~ Foo => Class (Blah ty)' then GHC will select this instance as soon as it sees a 'Class (Blah x)' constraint, and learn that 'x' is 'Foo'
09:54:51 <solonarv> if you instead write 'instance class (Blah Foo)', GHC will only select this instance if it already knows that 'x' is 'Foo'
10:06:13 <d34df00d> Ah I see, thanks!
10:07:26 <d34df00d> cocreature: yeah, OVERLAPPABLE worked like a charm.
10:07:52 <d34df00d> I feel like every time overlapping instances are used a kitten dies. So I killed three kittens today :(
10:12:04 <yoav_> How can I use replace (from Data.Text) with multiple pairs of text to replace all of them? I know I should use (uncurry replace :: (T.Text, T.Text) -> T.Text -> T.Text) but no idea where to go from here
10:19:08 <cocreature> yoav_: fold over the lists of pairs and call Text.replace at each step
10:23:23 <solonarv> although that will not give the same result if the search/replace pairs can lead into each other
10:23:34 <yoav_> cocreature: I tried that earlier, but since foldl1 takes (a -> a -> a) I'm not sure how to do that
10:23:50 <yoav_> solonarv: Yeah, that case doesn't really bother me here
10:23:53 <cocreature> yoav_: use foldl' not foldl1 :)
10:24:44 <cocreature> :t foldl' (\t (needle, replacement) -> Text.replace needle replacement t)
10:24:46 <lambdabot> error:
10:24:46 <lambdabot>     Not in scope: ‘Text.replace’
10:24:46 <lambdabot>     No module named ‘Text’ is imported.
10:24:51 <cocreature> :t foldl' (\t (needle, replacement) -> Data.Text.replace needle replacement t)
10:24:53 <lambdabot> Foldable t => Data.Text.Internal.Text -> t (Data.Text.Internal.Text, Data.Text.Internal.Text) -> Data.Text.Internal.Text
10:25:06 <yoav_> :t foldl'
10:25:08 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
10:25:16 <yoav_> :t foldl
10:25:18 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
10:25:28 <yoav_> What's the difference?
10:25:37 <cocreature> > foldl' (\t (needle, replacement) -> Data.Text.replace needle replacement t) "foobar" [("foo", "hello"), ("bar", "world")]
10:25:39 <lambdabot>  error:
10:25:39 <lambdabot>      Not in scope: ‘Data.Text.replace’
10:25:39 <lambdabot>      No module named ‘Data.Text’ is imported.
10:25:46 <cocreature> % foldl' (\t (needle, replacement) -> Data.Text.replace needle replacement t) "foobar" [("foo", "hello"), ("bar", "world")]
10:25:46 <yahb> cocreature: ; <interactive>:8:77: error:; * Couldn't match expected type `Data.Text.Internal.Text' with actual type `[Char]'; * In the second argument of foldl', namely `"foobar"'; In the expression: foldl' (\ t (needle, replacement) -> Data.Text.replace needle replacement t) "foobar" [("foo", "hello"), ("bar", "world")]; In an equation for `it': it = foldl' (\ t (needle, replacement) -> Data.T
10:25:58 <cocreature> % :set -XOverloadedStrings
10:25:58 <yahb> cocreature: 
10:26:00 <cocreature> % foldl' (\t (needle, replacement) -> Data.Text.replace needle replacement t) "foobar" [("foo", "hello"), ("bar", "world")]
10:26:01 <yahb> cocreature: "helloworld"
10:26:03 <solonarv> foldl' is stricter; foldl can build up thunks and lead to enormous memory usage and terrible performance
10:26:18 <yoav_> solonarv: Huh, good to know
10:26:21 <yoav_> cocreature: Thanks!
10:27:00 <cocreature> usually you want either foldr if you can lazily produce parts of the result or foldl'. foldl is almost always the wrong choice
10:30:26 <solonarv> you could also use regex-applicative-text and write:
10:31:10 <janat08> https://www.irccloud.com/pastebin/JuXOdfGW/
10:31:26 <solonarv> replace (asum ["hello" <$ string "foo", "world" <$ string "bar"]) "foobar"
10:31:51 <janat08> how am I losing context with fmap\
10:34:43 <lyxia> janat08: I think you cut out too much, this code doesn't make sense to me.
10:35:31 <janat08> https://www.irccloud.com/pastebin/LhY0toON/
10:36:01 <janat08> I checked the type of timer, it returns whats expected
10:36:43 <hololeap> does anyone know a library that will parse a query string into a (Map String String)?
10:37:14 <lyxia> janat08: what's the full error message
10:37:17 <hololeap> i've been trying to write one with parsec, but it tends to hang
10:37:19 <[exa]> hololeap: you mean the URL-style ?query string after
10:37:26 <hololeap> [exa]: yeah
10:37:30 <[exa]> oh, 'after ?'
10:37:46 <janat08> https://www.irccloud.com/pastebin/jtqCXkYW/
10:38:26 <[exa]> there certainly should be one; but perhaps show us your parsec one (making it not hang might be easier than pulling a dependency)
10:38:43 <hololeap> i'm using URI.uriQuery from the network-uri package to extract the query from a URI
10:38:44 <lyxia> janat08: I guess dynText takes a value of type Dynamic, and that's where the type mismatch comes from
10:38:59 <janat08> but timer returns that
10:39:35 <hololeap> [exa]: http://dpaste.com/2770PTF
10:39:39 <cocreature> hololeap: https://hackage.haskell.org/package/http-types-0.12.3/docs/Network-HTTP-Types.html#v:parseQuery
10:39:44 <janat08> or rather foldDyn does
10:40:15 <hololeap> i got it working until i realized that a key doesn't have to have a value e.g. "?keyWithV=v&keyNoV"
10:40:41 <cocreature> janat08: it looks like you might want to layers of fmap, one for "m" and one for "Dynamic"
10:40:49 <lyxia> janat08: it doesn't matter because the thing to the right of (=<<) is (formatS <$> _)
10:41:00 <hololeap> and i tried adding an extra keyNoV option, but now it hangs when i try parseTest
10:41:31 <hololeap> it seems like `many kNoV` is what makes it hang, but i'm not sure why
10:41:43 <lyxia> janat08: and formatS has type  _ -> Text  , so (formatS <$> _) has type  m Text  no matter what's to the right of (<$>)
10:42:03 <turion> Assume I have some type `Foo a` that I can morally make a monad. But to implement `fmap`, I need constraints on `a`. So I go ahead and do the free functor/Coyoneda construction: `data Foo2 a = forall a' . MyClass a' => Foo2 (Foo a) (a -> a')`. This has a `Functor` instance. But how do I implement `(>>=) :: Foo2 a -> (a -> Foo2 b) -> Foo2 b`? Because for `fooa >>= f`, the existential type `b'` inside `f a` depends on `a`!
10:42:05 <[exa]> hololeap: btw what does the 'pair' look like in query strings?
10:42:35 <hololeap> "key=val"
10:42:36 <janat08> lyxia: I actually layered the fmaps, and its working
10:42:55 <hololeap> or just "key" if there is no value (in which case it will point to an empty string in the Map)
10:42:56 <janat08> Don't know why one fmap worked, if two were required
10:43:27 <[exa]> hololeap: anyway, I'd avoid 'manyTill' completely, you're writing it like regex. what about using `sepBy` ?
10:44:24 <hololeap> [exa]: sepBy made sense to get the individual key-val pairs out ... something like `sepBy anyChar (char '&')`
10:45:04 <hololeap> but then it would have to nest another `sepBy anyChar (char '=')` to split those strings into the key and val
10:45:26 <hololeap> and i haven't figured out how to do that in Parsec, except to use `parse` and do everything in the Either monad
10:45:26 <[exa]> not at all, sepBy does 0-infinity results, here you want exactly 1 or 2
10:46:44 <hololeap> i'm MUCH more familiar with regex's after all :) i struggle to use parser combinators for certain problems
10:46:45 <[exa]> "not at all" for the latter case, it's perfect for separating by & though
10:47:10 <[exa]> parser combinators are 1 chomsky hierarchy level higher
10:48:22 <hololeap> isn't that only true if you use the monad interface?
10:48:42 <hololeap> i really don't know much about this stuff, but that was my impression
10:51:31 <[exa]> hololeap: I added my version here http://dpaste.com/0NSBWPQ
10:51:45 <[exa]> hololeap: you might require a bit of compile error catching but it should certainly not hang
10:52:44 <[exa]> oh and you will probably need to replace (,Nothing) by a lambda, I got confused about , operator again
11:14:00 <janat08> cocreature: btw did it become m(dynamic) as result of `let` binding?
11:14:30 <janat08> or rather m(dynamic(dynamic))
11:14:36 <janat08> or whatever it was
11:15:34 <janat08> or nm
11:15:43 <janat08> ty for help
11:43:22 <d34df00d> Suppose I have a pure function that has a bunch of pattern guards checking various computationally expensive conditions, and I need to lift both the function and at least some of the functions in the guards into a monad.
11:43:55 <d34df00d> Preferably preserving the same readability (so no nested ifs perhaps) and short-circuiting lazy behaviour.
11:44:01 <d34df00d> Is there any good way to do so?
11:49:49 <migge> I have a recursive function which I want to make use of multiple cpu cores. However my approach of: x ``
11:50:35 <migge> x `par` (xs `pseq` x:xs)
11:50:46 <migge> consumes all available memory
11:50:55 <migge> any idea how to fix this?
11:51:50 <migge> xs is the result of the recursive call
11:52:02 <cocreature> janat08: sorry it’s been too long since I’ve used reflex to have the types used in the API in my head and without that it’s hard to answer that.
12:08:36 <pavonia> d34df00d: Perhaps you could use the approach described here: https://stackoverflow.com/questions/49508856/pattern-matching-in-alternative/49518519#49518519
12:14:37 <d34df00d> pavonia: well, I ended up writing my own mwifM :: [(m Bool, m a)] -> m a
12:14:44 <d34df00d> Probably worth sending as a PR to the `extra` packagte.
12:18:07 <Welkin> my wife?
12:18:15 <Welkin> -M?
12:19:37 <d34df00d> multiway if, monadic!
12:21:13 * ski . o O ( `[m (Maybe (m a))] -> m a' )
12:21:23 <d34df00d> Yeah, I could msum that.
12:21:29 <d34df00d> But it's a bit harder to my eye, maybe.
12:22:38 <cocreature> % :t runMaybeT . asum . map (\(c, a) -> do r <- lift c; guard r; lift a)
12:22:38 <yahb> cocreature: ; <interactive>:1:1: error: Variable not in scope: runMaybeT :: t0 m a -> c
12:22:46 <cocreature> % import Control.Monad.Trans.Maybe
12:22:46 <yahb> cocreature: 
12:22:47 <cocreature> % :t runMaybeT . asum . map (\(c, a) -> do r <- lift c; guard r; lift a)
12:22:47 <yahb> cocreature: Monad m => [(m Bool, m a)] -> m (Maybe a)
12:23:37 <lavalike> good ole asum
12:25:18 <dminuoso> migge: can you show the surrounding code for context?
12:27:56 <Guest58003> 1
12:35:28 <migge> dminuoso: pasted at https://pastebin.com/VSGi77j6
12:37:27 <dminuoso> migge: What is the intention here exactly?
12:39:17 <Jiesema98> Hello. I decided to try something that I've never tried. I will go Live in a CAM site & I am sure it will be fun! The site gave me 5 Free Invites, so I am going to give them to 5 people that are interested. Join for FREE and send "Free Invite" in my CAM room ---> https://zap.buzz/O7X
12:39:55 <migge> it's a raytracer. i have a bunch of rays per pixel which are averaged to give the final color value for the pixel. each chunk represents the work for one pixel and is independent of all other chunks. so i would like to calculate them in parallel.
12:40:44 <dminuoso> migge: So step one, put that into documentation there. Saves you the trouble explaining it to the next person. :)
12:41:16 <migge> :)
12:43:21 <dminuoso> migge: So I would just use Control.Parallel.Strategies here, instead of trying to rig it yourself.
12:43:44 <dminuoso> e.g. parList
12:48:11 <dminuoso> migge: Or perhaps parListChunk even.
12:48:55 * dminuoso does not even know the semantics of GHC.Conc.par precisely
12:51:20 <migge> i stole the code from real world haskell. as i understand par evaluates the first agument (possibly in parallel) and returns the second.  i'll look into strategies.
12:52:16 <dminuoso> migge: Be that as it may, if you want to have deterministic concurrenct programming, use the Control.Parallel.Facilities. :)
12:52:48 <dminuoso> migge: There's an excellent book by Simon Marlow "Parallel and Concurrent Programming in Haskell" that you can obtain freely via archive.org, or in print I guess.
12:52:54 <dminuoso> It's definitely worth a read. :)
12:53:53 <ski> @where PCPH
12:53:53 <lambdabot> "Parallel and Concurrent Programming in Haskell" by Simon Marlow in 2013 at <http://community.haskell.org/~simonmar/pcph/>,<http://chimera.labs.oreilly.com/books/1230000000929/>,<https://web.archive.
12:53:53 <lambdabot> org/web/20180117194842/http://chimera.labs.oreilly.com/books/1230000000929>,<https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/>
12:56:26 <migge> dminuoso: thanks for your help
12:57:43 <migge> dminuoso: thanks for your help
13:34:28 <d34df00d> Is there anything preexisting that'd reduce the boilerplate for defining HasFoo when writing (MonadReader r m, HasFoo r)?
13:55:29 <fendor> do cabal run scripts work on windows?
14:01:15 <solonarv> hololeap: here is what I would use with megaparsec: parseQuery = Map.fromList <$> sepBy (liftA2 (,) (takeWhile1P Nothing (/= '=') <* optional (char '=')) (takeWhileP Nothing (/= '&')) (char '&')
14:01:26 <solonarv> parsec should be similar, just with slightly different names for things
14:01:32 <solonarv> fendor: sort of
14:01:57 <fendor> solonarv, sort of is sort of a no, right?
14:02:02 <solonarv> I ran into an issue where CRLF line endings would cause cabal to not recognize the {- cabal: -} bit
14:02:21 <solonarv> so you could try to wrangle your editor into using LF line endings
14:02:34 <solonarv> the bug is fixed in cabal head, so you could just install that
14:03:51 <solonarv> there are nightly windows builds of it somewhere, let me see if I can find them
14:04:20 <solonarv> ah, here - https://www.myget.org/feed/mistuke/package/nuget/cabal-head
14:05:20 <solonarv> fendor: I hope that is a sufficiently comprehensive answer ;)
14:05:36 <fendor> solonarv, thanks, it is a great and helpful answer :) 
14:05:49 <fendor> but I cant force every user of that script to use head for cabal, can I?
14:06:10 <solonarv> depends on who your users are
14:06:32 <fendor> solonarv, fair, developers, but I still dont think that THEY want to use HEAD.
14:06:34 <solonarv> if you make sure the line endings are LF and not CRLF I *think* it should work
14:06:58 <fendor> that is very valuable information, I will verify that I am using the right line ending
14:07:24 <solonarv> cabal-install-2.4 has another problem on windows (especially <10): v2-install doesn't really work, because it can only symlink and support for that is shaky in win <10
14:08:04 <solonarv> HEAD is also able to install by copying the binary (and you can specify which behavior you want)
14:08:20 <fendor> solonarv, yeah, I it luckily fixed on HEAD! I think, you are right, since cabal v2-install doesnt work, I dont need to bother to make it work on windows with cabal
14:08:44 <solonarv> 3.0 should be released Pretty Dang Soon Now anyway, I think
14:08:50 <fendor> with 2.4.1.0 it doesnt work
14:08:54 <solonarv> although I've been hearing and saying that for several months now
14:09:03 <fendor> i hope not, i desperately want my pr for it merged :/
14:10:11 <fendor> i will need to poke some people to make it happen
14:12:30 <fendor> then let's see why the stack script doesnt work
14:25:59 <fendor> on windows, when i write a stack script, can I depend on a local package?
14:34:46 <fresheyeball> anyone know where I can find `type family Foldr`?
14:36:08 <d34df00d> How do I write an instance with a polykinded type? Something like `instance forall k (ty :: k -> *). Ctx (ty Type) (ty 'Ctor) => TypeClass (ty Type) (ty 'Ctor)`
14:36:35 <d34df00d> I tried literally that, and I got:  Expected kind ‘k’, but 'Type’ has kind ‘*’
14:36:48 <fresheyeball> d34df00d: it can't be both at once
14:36:57 <d34df00d> fresheyeball: but... why?
14:37:01 <fresheyeball> you want a ranked poly kinded type
14:37:07 <d34df00d> What.
14:37:21 <fresheyeball> so that k is scoped to the whole function
14:37:31 <fresheyeball> and can't be both Type and 'Ctor
14:37:35 <fresheyeball> think about RankN
14:37:56 <d34df00d> So I don't even have the syntax to express that in Haskell?
14:38:09 <fresheyeball> try moving the forall inside the parens with ty
14:38:35 <d34df00d> parse error on input 'forall'
14:39:14 <fresheyeball> try this `insance forall (forall k. ty :: k -> Type).
14:39:14 <d34df00d> Ah, right, wrong scoping.
14:39:15 <d34df00d> Got it!
14:39:21 <fresheyeball> :)
14:39:22 <d34df00d> Nope, that doesn't work.
14:39:28 <fresheyeball> what worked?
14:39:30 <d34df00d> What works is
14:39:31 <d34df00d> instance forall m (ty :: (forall k. k -> *)).
14:39:45 <fresheyeball> cool, looks right to me!
14:39:49 <d34df00d> (disregard m, that's something else)
14:40:29 <d34df00d> Thanks for hinting!
15:08:37 <jvac> Hi
15:08:47 <jvac> I am reading the paper Giving Haskell a Promotion. The first example in this paper defines a type Vec of kind *->Nat->*. I ran ":kind VCons String VNil" in ghci, expecting it to return Vec * Nat but instead it returned Vec * ('Succ 'Zero). Isn't 'Succ 'Zero a type of kind Nat? Why is the type 'Succ 'Zero being passed to the kind constructor Vec *? 
15:11:49 <janat08> does recursivedo work across nested dos?
15:13:16 <fresheyeball> janat08: yes
15:20:18 <janat08> why is asdf not in scope then: https://www.irccloud.com/pastebin/T2IRKpV9/
15:22:01 <ski> jvac : try  :k VCons False VNil
15:24:00 <lyxia> jvac: Vec :: Type -> Nat -> Type  means the second argument of Vec has kind Nat.  'Succ 'Zero  has kind Nat.
15:24:48 <lyxia> Vec (_ :: Type) (_ :: Nat) :: Type
15:25:43 * ski . o O ( "Let's add a `DeclarationFollowsUsage' extension to GHC." )
15:26:11 <jvac> ski. I don't get it. VCons is promoted to a type constructor here, right? Why can we pass the value False to a type constructor?
15:27:02 <solonarv> because that False is also a promoted data constructor
15:27:05 <ski> jvac : the more appropriate questions ought to be : "Why can we pass the type `String' to `VCons' ?"
15:29:07 <jvac> solonarv: ok thanks. that makes sense
15:30:01 <jvac> ski: We can pass type String to VCons because VCons is a type constructor, right? WHy is that a more appropriate question?
15:30:54 <ski> jvac : try  :t VCons
15:31:24 <Lycurgus> janat08, that doesn't appear to be what's not in scope
15:32:26 <turab> @pl \x y -> succ x : y
15:32:26 <lambdabot> (:) . succ
15:32:33 <Lycurgus> rather ur monad things; btw fun fact windows power shell was originally named "Monad"
15:32:58 * ski nods solemnly
15:33:27 <jvac> ski: ok. that returns the type of the data constructor VCons. My question is about the type constructor VCons. VCons String VNil is a type expression
15:33:29 <turab> Lol why did the change it to power shell
15:34:07 <EvanR> why were they going to call it monad
15:34:16 <EvanR> so many questions
15:38:24 <butterth_> Any emacs users here, who can give me a rundown of the differences between haskell-ide-engine and inteero?
15:40:39 <isovector1> are there any primitives in ghc that have kind `forall k. k` and which aren't implemented as type families?
15:41:21 <jvac> ski: ig2g. sorry, thought I had more time. thanks for the help
15:49:00 <janat08> lycurgus: says ` elAttr "div" asdf $ do` not in scope
17:02:46 <Lycurgus> tunes.org should be taken out of the topic it's been down for a while
17:03:31 <Lycurgus> https://www.haskell.org/irc/ ditto for the one on that
17:19:21 <infinisil> common fields in cabal are pretty neat yo
17:19:38 <infinisil> https://www.haskell.org/cabal/users-guide/developing-packages.html#common-stanzas
17:36:51 <gabbiel> Can somebody explain sum types and product types to me?
17:37:48 <Axman6> product types are a collection of two or more things, like a struct in other languages. (Int, Bool), the product of an Int and a bool
17:38:33 <Axman6> Sum types are a choice between things: This si somewha like a union in other languages (or a tagged union). data IntOrBool = TheInt Int | TheBool Bool
17:39:04 <Axman6> something of type IntOrBool either contains an Int inside the the TheInt constructor or a Bool inside the TheBool constructor
17:39:14 <gabbiel> oh I see.
17:39:17 <Axman6> gabbiel: do you have experience with other languages?
17:39:24 <pavonia> See also https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/sum-types
17:39:37 <gabbiel> I have experience with Lisp.
17:40:06 <gabbiel> I just want to understand those before I get to ADTs and GADTs
17:40:17 <Axman6> I'm not familliar enough with lisp to be able to make a good analogy
17:40:22 <Axman6> well, those are ADTs
17:40:32 <gabbiel> I also know a little bit of C
17:40:59 <gabbiel> I know structs in C are a sum of the bytes of their components.
17:41:25 <shachaf> Your question would be better if it was of the form "I read X and I didn't understand Y" instead of "explain this thing to me".
17:41:46 <gabbiel> but do ADTs encompass more than product and sum types?
17:43:03 <Axman6> In haskell, our data types are defined as sums of products, so you can have data Foo = Bar String Bool | Baz Double Float. a Foo is either (read as "the sum of") the pair (product) of a String and a Bool OR the pair (product) of a Double and a Float
17:44:21 <gabbiel> shachaf: I dont understand, how so.
17:44:49 <EvanR> haskell allows recursive ADTs
17:45:11 <EvanR> that's more than just products and sums
17:45:40 <shachaf> There are many explanations of this thing on the Internet. Either you read one of them and got confused -- in which case you should say what was confusing -- or you didn't read any of them -- in which case you should do that first.
17:45:58 <gabbiel> so ADTs are when its just sum of products then
17:48:00 <hpc> https://en.wikipedia.org/wiki/Algebraic_data_type has a fairly approachable explanation
17:48:04 <gabbiel> im reading haskell from first principles 
17:48:21 <EvanR> just a sum of products makes it sound a bit more bland, like, this type is not just a sum of products,  Either A (Either B C, D), A + ((B + C) * D)
17:48:30 <EvanR> it's... a whole algebra of types
17:51:49 <gabbiel> oh I see, as long as I can construct something with the "+" and "*" operators then it shall be a type, whether the operands are a sum type or product type?
17:52:15 <shachaf> Oh, that book is terrible, no wonder.
17:52:39 <shachaf> They're called "product" and "sum" types based on counting the number of inhabitants (things that have that type).
17:53:21 <shachaf> If type A has n inhabitants and type B has m inhabitants, then a pair (A,B) has n*m inhabitants (this is like a struct in C, which is more or less a product type).
17:54:04 <shachaf> C doesn't have sum types, but in Haskell "Either" is an example: Either A B could be either an A or a B, so it has n+m inhabitants.
17:54:46 <chalkmonster> shachaf: what about C unions
17:54:56 <chalkmonster> the way I understand it is that haskell's sum types are basically Tagged Unions
17:55:06 <chalkmonster> accomplishes the same thing, but in a very, very unsafe way
17:55:09 <Axman6> how many possible values are ther of (Bool, Bool, Word8)
17:55:38 <Axman6> chalkmonster: C tagged unions are similar if one is very careful about how they are used
17:55:39 <heebo> 2 x 2 x 2^8
17:55:55 <chalkmonster> Axman6: C unions aren't tagged, is the point.
17:56:06 <chalkmonster> you don't know what you're getting
17:56:25 <shachaf> C unions without tags aren't sum types, they're a different thing.
17:56:32 <chalkmonster> which is what
17:56:43 <heebo> anyone studied category theory?
17:56:48 <shachaf> It's not about safety but about the amount of information a union value has.
17:57:01 <gabbiel> hmm: data Either a b = Left a | Right b. its a sum because of the or(|)
17:57:05 <chalkmonster> how are they not sum types is the question
17:57:44 <gabbiel> I get that one
17:57:46 <shachaf> Say types T1 and T2 are the same size. union { T1 a; T2 b; }; is also that size.
17:58:21 <chalkmonster> shachaf: so how are C unions *not* sum types.
17:58:24 <shachaf> Nothing to sum. It's only about accessing memory in different ways.
17:58:45 <chalkmonster> from my pov its accomplishing the exact same thing
17:59:05 <hpc> chalkmonster: algebraically, unions have the property that for all x, x + x = x
17:59:07 <chalkmonster> T1 | T2 is the same as union { T1: a; T2 b }
17:59:12 <chalkmonster> except that the union is tagged
17:59:15 <gabbiel> the c analogies aren't helping. I'd rather learn in terms of Haskell itself
17:59:43 <shachaf> "except that the union is tagged" -- it sounds like you already know how they're not the same thing.
17:59:49 <chalkmonster> hpc: I don't understand how c unions fail that
18:00:19 <chalkmonster> shachaf: yeah but its still a sum, I may be wrong
18:00:19 <hpc> that's the property unions have
18:00:47 <hpc> consider how it makes no sense if you consider it generically instead of as a type thing
18:00:58 <hpc> what if x = 2 (ie, Bool)
18:01:01 <shachaf> Nothing is being summed here.
18:01:12 <chalkmonster> hmm
18:01:15 <hpc> Bool + Bool = 2*Bool
18:01:19 <hpc> that's a sum type
18:01:22 <hpc> (Bool, Bool)
18:01:25 <shachaf> union { unsigned char x; signed char y; } u; has no more information than "unsigned char".
18:01:30 <hpc> or Either Bool Bool
18:01:35 <chalkmonster> I see
18:01:37 <hpc> (both have 4 values)
18:01:47 <hpc> in a union, Bool + Bool = Bool
18:03:16 <hpc> or converting back to numbers, 2 + 2 = 2
18:03:39 <EvanR> Either Bool Bool = (Bool,Bool) nice
18:04:43 <Axman6> = Bool -> Bool
18:04:45 <gabbiel> i have no idea whats going on
18:05:32 <shachaf> Fortunately 2+2 = 2*2 = 2^2
18:06:09 <EvanR> what about Sigma x . if x then Bool else ()
18:06:37 <chalkmonster> I don't think I see
18:06:49 <chalkmonster> Either Bool Bool is Left Bool | Right Bool
18:07:04 <chalkmonster> its still only going to be at most 1 Bool + a tag that tells you whether its Left or Right
18:07:16 <EvanR> the tag is like the other bool
18:07:22 <hpc> chalkmonster: you have a union {bool x; bool y}
18:07:26 <hpc> chalkmonster: how many values can it take?
18:07:26 <chalkmonster> a C union { bool a; bool b } is also going to be exactly 1 bool, minus the tag that tells you 
18:07:34 <hpc> > [Left False ..]
18:07:38 <lambdabot>  error:
18:07:38 <lambdabot>      • No instance for (Enum (Either Bool ()))
18:07:38 <lambdabot>          arising from a use of ‘e_1’
18:07:40 <chalkmonster> its still a sum type by definition
18:07:49 <shachaf> What's your definition?
18:07:58 <shachaf> You're just insisting it's a sum type without any definitions.
18:08:13 <chalkmonster> let me look a bunch of stuff up
18:08:18 <chalkmonster> I might be missing something obvious here
18:08:33 <chalkmonster> shachaf: not insisting, asking
18:08:33 <shachaf> Seems kind of pointless. If you want, you can decide on a definition -- there's a standard one -- and then say whether or not it matches the definition (it doesn't).
18:08:55 <hpc> i think you keep trying to think of C unions as if you've manually kept a separate tag field separately
18:09:29 <shachaf> If you define sum type to mean "C union", then C unions are sum types. If you define it to mean e.g. "tagged union", then of course C unions aren't that thing, because they're missing a tag.
18:09:35 <monochrom> At this rate, soon we're going to talk about product types in transistors too.
18:10:51 <hpc> monochrom: everyone knows computers operate on qbits, we just go through a lot of effort to keep them from entangling :P
18:12:49 <ski> (gabbiel left, fwiw)
18:14:01 <monochrom> More realistically, someone is going to define "parametric polymorphism = using void *"
18:20:18 <hololeap> heebo: a little
18:20:56 <hololeap> there are others here who are experts, but ask away
18:32:51 <remexre> Vectors support sharing if I create them as Data.Vector.replicate largeNumber bigExpr ?
18:33:02 <remexre> er, Do* vectors support...
18:34:39 <Axman6> what sort of sharing?
18:44:05 <remexre> like the vectors' entries will all point to a single thunk / single copy of the structure
18:44:09 <remexre> Axman6 ^^
18:44:31 <Axman6> remexre: all the elements will point to that same expression. as soon as one is evaluated they should all be
18:44:45 <remexre> okay, that's what I assumed...
18:45:34 <Axman6> if you want to be sure of that you could do let !expr = bigExpr in replicate largeNumber expr
18:45:34 <remexre> I've got a weird infinite loop / infinite space usage in a structure that relies on sharing, and "maybe it's not actually sharing" was the only thing I could think of :/
18:46:32 <Axman6> feel free to share some code
18:46:55 <remexre> there's a lot of it :P
18:47:34 <remexre> I've basically got a fixed-size tree with 2^48 leaf nodes, and I'm trying to set and then get a value from it
18:53:30 <Djingibi99> I am super horny & wet. Let's have fun together. The fun is guaranteed, boys! Join & watch my Live ---> https://t.co/TSM79nBBmt
18:53:42 <isovector1> anyone have a type family that can perform polykinded variable substitution?
18:54:12 <isovector1> looking for `Replace (Either SUB_ME Int) Bool = Either Bool Int`
18:54:25 <isovector1> and `Replace (SUB_ME Bool) Maybe = Maybe Bool`
20:07:47 <dmj`> isovector1: does that Replace not perform substitution ?
20:43:31 <isovector1> dmj`: i was looking for an implementation; but lyxia solved it for me :)
20:51:24 <dmj`> isovector1: ah, cool :)
20:58:50 <isovector1> has anyone gotten doctest working with a ghci packagedb?
20:59:18 <isovector1> my doctests fail on <= 8.2 saying "cannot satisfy package <some dependency>" 
20:59:37 <isovector1> the solution seems to be to pass in the correct `--package-db` path, but i'm not sure how to find out what that should be
21:27:52 <Nolrai> :t replicate
21:27:54 <lambdabot> Int -> a -> [a]
22:59:09 <Nolrai> :t foldl
22:59:11 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
23:01:53 <isovector1> how long does hackage take to build docs?
23:21:50 <jackdk> too long. I build them and upload them to hackage manually
23:22:45 <jackdk> I think it's `--haddock-for-hackage`
23:23:56 <jackdk> > let { (<$$>) = fmap . fmap ; fgab (<**>) fga = fmap (<*>) fgab <*> fga } in (+) <$$> [Just 2] <**> [Just 5]
23:23:59 <lambdabot>  error:
23:23:59 <lambdabot>      • Occurs check: cannot construct the infinite type: b1 ~ f b1
23:23:59 <lambdabot>        Expected type: a -> f (a -> b1)
23:24:41 <jackdk> > let { (<$$>) = fmap . fmap ; fgab <**> fga = fmap (<*>) fgab <*> fga } in (+) <$$> [Just 2] <**> 
23:24:43 <lambdabot>  <hint>:1:98: error:
23:24:43 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
23:24:52 <jackdk> > let { (<$$>) = fmap . fmap ; fgab <**> fga = fmap (<*>) fgab <*> fga } in (+) <$$> [Just 2] <**>  [Just 5]
23:24:54 <lambdabot>  [Just 7]
23:25:10 <jackdk> sorry for the noise. Do those <$$> and <**> functions exist anywhere?
23:25:49 <dminuoso> jackdk: I dont think they would pass the Fairbairn threshold.
23:26:29 <Lears> Really? <$$> is really easy to remember and I use pretty often. <$$$> too.
23:27:05 <Lears> I've also noticed other people binding them with the same names.
23:27:38 <Axman6> > getCompose ((+) <$> Compose [Just 2] <*> Compose [Just 5])
23:27:40 <lambdabot>  error:
23:27:40 <lambdabot>      Variable not in scope: getCompose :: f0 Integer -> terror:
23:27:41 <lambdabot>      • Data constructor not in scope:
23:27:50 <Axman6> % getCompose ((+) <$> Compose [Just 2] <*> Compose [Just 5])
23:27:50 <yahb> Axman6: ; <interactive>:16:1: error: Variable not in scope: getCompose :: f0 Integer -> t; <interactive>:16:21: error:; * Data constructor not in scope: Compose :: [Maybe Integer] -> f0 Integer; * Perhaps you meant variable `icompose' (imported from Control.Lens); <interactive>:16:42: error:; * Data constructor not in scope: Compose :: [Maybe Integer] -> f0 Integer; * Perhaps you meant variable
23:27:58 <Axman6> % runCompose ((+) <$> Compose [Just 2] <*> Compose [Just 5])
23:27:59 <yahb> Axman6: ; <interactive>:17:1: error: Variable not in scope: runCompose :: f0 Integer -> t; <interactive>:17:21: error:; * Data constructor not in scope: Compose :: [Maybe Integer] -> f0 Integer; * Perhaps you meant variable `icompose' (imported from Control.Lens); <interactive>:17:42: error:; * Data constructor not in scope: Compose :: [Maybe Integer] -> f0 Integer; * Perhaps you meant variable
23:28:06 <Axman6> u wot
23:28:10 <dminuoso> % import Data.Functor.Compose
23:28:10 <yahb> dminuoso: 
23:28:17 <dminuoso> % runCompose ((+) <$> Compose [Just 2] <*> Compose [Just 5])
23:28:17 <yahb> dminuoso: ; <interactive>:19:1: error:; * Variable not in scope: runCompose :: Compose [] Maybe Integer -> t; * Perhaps you meant one of these: data constructor `Compose' (imported from Data.Functor.Compose), `getCompose' (imported from Data.Functor.Compose)
23:28:23 <dminuoso> oh
23:28:28 <dminuoso> % getCompose ((+) <$> Compose [Just 2] <*> Compose [Just 5])
23:28:29 <yahb> dminuoso: [Just 7]
23:28:58 <jackdk> I find myself using 2-layer applicatives a lot in reflexy stuff
23:48:30 <Axman6> jackdk: needs a package pls
23:51:16 <Axman6> jackdk: preferably with as many levels as you can autp generate, a la https://github.com/mxswd/flip-plus
23:53:01 <Athas> If I want to include some extra files (documentation) in cabal source tarballs, how should I indicate that in the .cabal file?  extra-source-files?
