00:00:14 * hackage fast-logger 2.4.16 - A fast logging system  https://hackage.haskell.org/package/fast-logger-2.4.16 (KazuYamamoto)
00:12:44 * hackage wai-logger 2.3.5 - A logging system for WAI  https://hackage.haskell.org/package/wai-logger-2.3.5 (KazuYamamoto)
00:22:14 * hackage shower 0.2.0.1 - Clean up the formatting of 'show' output  https://hackage.haskell.org/package/shower-0.2.0.1 (int_index)
00:55:44 * hackage ast-path 0.1.2 - vocabulary representation for predicting program properties  https://hackage.haskell.org/package/ast-path-0.1.2 (ijaketak)
00:56:15 <MarcelineVQ> shapr: possibly of use for you http://web.mit.edu/15.053/www/AMP.htm
00:56:42 <MarcelineVQ> pretty good for '77
01:40:14 * hackage lsp-test 0.5.4.0 - Functional test framework for LSP servers.  https://hackage.haskell.org/package/lsp-test-0.5.4.0 (luke_)
01:43:05 <talqu> hi, i use lucid script_ to include my .js scripts. Now i need to embed some server side variables into the script? I can simple write a function with params and use <> to concat these values. If there something that you would use for these cases?
01:43:56 <jgt> no idea about lucid, but Shakespeare/Julius makes Haskell value interpolation pretty easy
02:10:14 * hackage bglib 1.0.0.1 - Implementation of the BGAPI serial protocol  https://hackage.haskell.org/package/bglib-1.0.0.1 (tamasFabian)
02:12:14 * hackage dprox 0.1.2.1 - a lightweight DNS proxy server  https://hackage.haskell.org/package/dprox-0.1.2.1 (BinJin)
02:18:49 <nimba> I've got a list of (input, expectedResult) (or similar, maybe add a description) to test a function against; is there something in hspec (or other place) that will run the tests for me and report *all* failures instead of stopping at the first failure?
02:19:52 <nimba> E.g. `shouldBe` from hspec stops processing, hence when writing a function myself based on shouldBe that goes over the list it will stop reporting the remaining failure cases from the list.
02:20:27 <fendor> nimba, sounds like you want multiple tests
02:20:52 <fendor> not just a single one
02:23:14 * hackage hprox 0.1.0.2 - a lightweight HTTP proxy server, and more  https://hackage.haskell.org/package/hprox-0.1.0.2 (BinJin)
02:26:45 <nimba> fendor, the list of test cases contains many entries (~hundred), and includes some generated ones
02:27:11 <merijn> So generate hundreds of tests from the list?
02:27:22 <fendor> in my opinion yes
02:27:35 <fendor> yes, generate hundreds of tests
02:28:09 <nimba> OK. Will have to study hspec more.
02:28:37 <fendor> forM_ may come in handy
02:28:38 <nimba> In case you can point me to any similar example out there, that would be cool.
02:29:31 <nimba> I'm currently "just" using a function that uses mapMaybe to collect failures in a list, then a failures `shouldBe` [] test case.
02:29:55 <nimba> (Works but was wondering if there isn't something better, hence was coming here.)
02:32:17 <merijn> nimba: tbh, I don't really like hspec. It's "human readable DSL" approach using typeclasses makes the API rather...opaque
02:32:52 <merijn> nimba: IMO it's investing too much effort in "make tests pseudo english" over "make it easy to programmatically generate complex test collections"
02:33:06 <nimba> What are you using instead?
02:33:47 <merijn> So far I've been using tasty
02:37:06 <merijn> Which you can plug/wrap various other libraries like quickcheck, hunit, etc. with
02:37:23 <merijn> In fact, I think there's even a tasty-hspec wrapper to include existing hspec tests into tasty
02:38:10 <nimba> OK, sounds interesting, will have a look if hspec turns out too bothersome for doing it.
02:40:28 <fendor> in my opinion, tests are often read by humans, so readability makes sense
02:41:06 <merijn> fendor: "pseudo english" doesn't guarantee readable and readability doesn't require pseudo english
02:42:43 <nimba> Is there a way to get show to do pretty-printing? I know https://monadfix.io/shower/ but seems like retro-fitting it onto hspec hasn't been done.
02:43:54 <nimba> Also it would be cool if ghci itself would do pretty-printing on results. So, why not just everywhere? Alright in cases where show is used to build fragments (i.e. column position is unknown) pretty-printing would hurt. So dunno. Anyway, ideas welcome.
02:44:33 <fendor> merijn, while I agree, I liked the appraoch of hspec so far.On the other hand, havent have to deal with a lot of generated tests so far
02:44:41 <fendor> nimba, there is a lib for that
02:45:48 <nimba> fendor, what library? to solve which part?
02:45:59 <merijn> fendor: I mean, this seems plenty readable with tasty: https://github.com/merijn/broadcast-chan/blob/master/broadcast-chan-tests/tests/Basic.hs
02:46:10 <fendor> nimba, such that ghci pretty prints results
02:46:43 <fendor> merijn, what does `@?` without knowing this operator, it rather complicated
02:47:06 <fendor> nimba, I cant recall right now, and I have to go, but in 40 min i am back and maybe i found it till then
02:47:22 <merijn> fendor: @? is just from hunit, that's unrelated to tasty
02:47:41 <nimba> Found: ghci --interactive-print=MyModule.prettyPrint
02:47:49 <fendor> then mayb e i dont like hunit, idk ;D
02:48:01 <nimba> Now how to do the same with hspec...?
02:48:23 <nimba> Does tasty have that capability?
02:48:41 <merijn> nimba: That only works in ghci, though
02:49:02 <merijn> If you really want pretty printed test failures you probably need to wrap/configure the test library to do that
02:49:04 <nimba> merijn, yes, but it's probably what fendor was referring to
02:50:14 <nimba> Found http://hackage.haskell.org/package/hspec-expectations-pretty
02:50:21 <nimba> will have a look.
02:53:12 <nimba> That requires types to implement (derive from?) System.Console.Terminfo.PrettyPrint; no good if that means a large diff for the code base I'm working on.
03:54:14 * hackage haskoin-store 0.16.4 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.16.4 (xenog)
03:59:24 <fendor> nimba, still interested in a pretty printing lib for ghci?
03:59:56 <nimba> Yes, although I think just hooking up shower via the command line argument is a solution?
04:00:14 <nimba> Ah you might have left before I commented on that.
04:00:46 * nimba afk
04:02:03 <dminuoso> So I would like to talk about _|_. We frequently pretend that you cannot catch it in a reasonable manner, but that means that Haskell programs are quite brittle, since you could provoke the crashing version of _|_ in quite a few ways (unsafe functions in particular) 
04:02:42 <dminuoso> Why do we tell people that trying to catch pure exceptions is a bad idea if that potentially promotes entire Haskell programs crashing if a transitive library uses `read`?
04:03:32 <dminuoso> Or is this the distinction between catching the exception implemented by error in GHC and catching bottom?
04:07:05 <int-e> dminuoso: You can catch ErrorCall if you like? But it's not necessarily predictable so it belongs in IO.
04:07:06 <fendor> dminuoso, i think it is perfectly reasonable to catch error and undefined in IO code.
04:07:30 <fendor> nimba, sounds reasonable to me as well
04:07:45 <lortabac> I think in that context "catching pure exceptions" means "using exceptions where Either would be more appropriate", that is, when you have control over the code producing those exceptions
04:08:16 <int-e> that's asking for trouble
04:09:17 <fendor> int-e, why is that asking for trouble?
04:09:33 <int-e> Pure code should not change behavior with different optimization settings, but if you start catching errors in pure code that may end up happening. Especially if you store or even inspect the error codes at some point.
04:09:42 <int-e> s/codes/messages/
04:10:29 <lortabac> int-e: is that possible at all (without unsafePerformIO)?
04:10:30 <dminuoso> int-e: Perhaps I should develop an understanding how exceptions are implemented exactly in Haskell.
04:10:59 <fendor> oh yeah, exceptions should almost exclusively be caught in IO
04:11:10 <int-e> lortabac: the compiler can change the evaluation order of values that it knows will be forced.
04:11:19 * dminuoso raises an eyebrow over fendor's use of the word "almost" there.
04:11:27 <dminuoso> (Im assuming we're ignoring STM and the likes of course)
04:11:37 <lortabac> I mean, AFAIK you can't catch exceptions in pure code
04:11:50 <fendor> dminuoso, I am not dealing in absolutes in this case, since there is bound to be an exception to that rule
04:12:09 <lortabac> you need unsafePerformIO for that
04:12:13 <int-e> lortabac: so you often cannot rely on getting a particular bottom from your code.
04:12:22 <int-e> lortabac: oh
04:12:33 <int-e> lortabac: yes, that's true
04:12:45 <dminuoso> int-e: I guess there's a major problem with catching ErrorCall. Since you cant know the provenance and exact cause of the error call, you cant possibly meaningfully recover.
04:13:20 <int-e> dminuoso: Yeah. You can start over from scratch (ghci does do well to catch all exceptions ;-) )
04:15:27 <int-e> Oh and how exceptions are implemented is fascinating... especially asynchronous exceptions. (Consider this: A thread starts evaluating some pure thunk. Then it receives an exception. So that computation needs to be interrupted... but in a way that another thread can pick up where the first thread left off and continue evaluating that value...)
04:16:29 <dminuoso> int-e: Do you know of any good resources about how exceptions are implemented in GHC? Would that be ghc wiki?
04:18:55 <int-e> dminuoso: there's the asynchronous exceptions paper, see https://gitlab.haskell.org/ghc/ghc/wikis/reading-list#io-and-related
04:19:31 <int-e> dminuoso: a lot of the relevant code is in rts/RaiseAsync.c
04:46:45 <merijn> dminuoso: What was th exception question? (assuming no one answered it while I was disconnected...)
05:40:08 <statusfailed> anyone have opinions on HSpec vs. Tasty ?
05:40:26 <statusfailed> (from what I understand, HSpec does a lot of automagical test case discovery, so less boilerplate?)
05:40:43 <merijn> statusfailed: Yes. I like tasty and dislike hspec :p
05:40:56 <merijn> statusfailed: There's a tasty library for automatic test discovery
05:41:19 <statusfailed> merijn: you've been in this IRC channel as long as I can remember so I'll just do what you say :p
05:41:22 <statusfailed> hohoho
05:41:42 <merijn> statusfailed: tasty is 1) more modular/extensible and 2) prefers non-typeclassed "regular function" API over "pseudo english DSL"
05:41:46 <merijn> statusfailed: https://hackage.haskell.org/package/tasty-discover
05:41:52 <[exa]> proof by irc idling, yay.
05:42:22 <merijn> tasty-golden also has it's own discovery stuff for golden tests
05:42:36 <statusfailed> I basically only need quickcheck tests tbh
05:42:51 <merijn> [exa]: I'm not idling, I'm just refactoring a tangled CMake mess that has 1 minute compile cycles, so lots of waiting for compilation :p
05:43:04 <statusfailed> relevant_xkcd.png
05:43:11 <statusfailed> how's your swordfighting coming along :D
05:43:16 <merijn> statusfailed: tasty-quickcheck ;) (notice a pattern?)
05:43:26 <statusfailed> hahah
05:44:02 <merijn> statusfailed: If you use TravisCI there's even my own tasty-travis for pretty colours (and folding!) of your test output on travis ;)
05:44:14 <[exa]> merijn: I referred to statusfailed's truth establishment method
05:44:14 <statusfailed> oh HELLO
05:44:45 <statusfailed> merijn: I don't yet, but this is open source so eventually that would be nice (and free) to set up
05:44:48 <statusfailed> i like free
05:45:42 <merijn> statusfailed: If you don't use travis yet: https://github.com/haskell-CI/haskell-ci
05:45:58 <merijn> statusfailed: For auto generating complex travis setups from cabal files or cabal.project ;)
05:46:11 <statusfailed> googling "tasty travis" gives a strange mix of results
05:46:42 <merijn> statusfailed: https://travis-ci.org/merijn/broadcast-chan/jobs/513511969 <- see the triangles on the left side near the test to unfold the testtrees
05:46:47 <merijn> @hackage tasty-travis
05:46:47 <lambdabot> http://hackage.haskell.org/package/tasty-travis
05:46:57 <statusfailed> it's too late
05:46:58 <statusfailed> I've seen things.
05:47:18 <statusfailed> oooooh that's really nice
05:47:20 <statusfailed> really nice
06:21:15 <kuribas> wouldn't it be nice to have a stringFields option for aeson, so extra fields raise an error?
06:21:26 <kuribas> strictFields, not stringFields
06:22:08 <hyperisco> Would that be nice? Questionable. Future proofing says no.
06:22:26 <merijn> hyperisco: Having it as option would be nice
06:22:55 <hyperisco> For who? :P
06:23:03 <hyperisco> m
06:23:04 <kuribas> hyperisco: for me
06:23:20 <merijn> hyperisco: For kuribas, apparently?
06:23:30 <hyperisco> Rhetorical question…
06:23:31 <kuribas> hyperisco: it would be off by default of course
06:23:54 <kuribas> how would that be more future proof?
06:24:16 <kuribas> haskell isn't a future proof language anyway
06:24:55 <hyperisco> If an additional check is done that there are no extra fields that prevents more fields from being added in the future.
06:25:34 <merijn> hyperisco: That's up to the user/person writing the parser to decide
06:25:59 <hyperisco> Don't have to make it easy for them to choose wrongly though. All I'm saying
06:26:10 <barrucadu> Why?  If you want whatever is consuming the json to accept more fields, you update that *then* you update whatever is producing the json
06:26:22 <barrucadu> Updating the producer before the consumer means the fields will be silently dropped
06:26:37 <hyperisco> That's what you want
06:26:42 <barrucadu> Silent data loss?
06:26:54 <merijn> hyperisco: I disagree that that's what people want in general
06:27:19 <merijn> hyperisco: There might be cases where that's what you want, but I couldn't say which is more common and the approaches don't have to conflict
06:27:23 <hyperisco> put it this way
06:27:59 <kuribas> hyperisco: because in, say, servant, someone sending a JSON with more fields may signify an misunderstanding of the API.
06:28:23 <hyperisco> If the consumer is persisting data for the producer, such as a database, then don't drop data. If the consumer is just reading data then do drop data.
06:28:54 <kuribas> hyperisco: if you are persisting, why go to an haskell datatype then?
06:29:00 <merijn> hyperisco: You're assuming that "consumer keeps functioning" is more important than "detecting an outdated consumer being deployed"
06:29:03 <kuribas> then you could just store JSON
06:29:11 <merijn> hyperisco: That's not a universally true assumption
06:29:37 <hyperisco> merijn, such as?
06:30:16 <kuribas> there are cases where I want to be lenient, like when parsing an external API, but I'd want to be strict when accepting JSON.
06:30:46 <merijn> hyperisco: An organisation that deploys internal daemons may want to loudly fail out of date consumer to detect misconfigurations
06:31:08 <barrucadu> That's what happens at my work, everything is strictly validated
06:31:40 <hyperisco> fortunate you don't have to deal with legacy then
06:32:08 <merijn> hyperisco: You seem to be arguing against the strawman of "everything should be strict fields"
06:32:14 <kuribas> hyperisco: no, the usecase is more for new APIs
06:32:35 <hyperisco> New becomes old at the speed of time ;)
06:32:43 <merijn> Whereas the remark was "it should be possible to enforce strict fields" (without affecting the existing API/instance that don't do so right now
06:33:00 <kuribas> hyperisco: if it's an option which is by default off, then it wouldn't change the existing behaviour.
06:33:08 <merijn> hyperisco: The fact that you need this behaviour in your specific situation doesn't seem a compelling reason not to support the alternative for other people in other situations
06:33:35 <hyperisco> I don't care about the library. I'm talking about programs you make with the library.
06:34:45 <merijn> hyperisco: Why do you think it's okay to define a single behaviour for all possible programs using JSON? Why not leave it up to said program's authors?
06:36:05 <hyperisco> That could be used to justify any sort of addition.
06:36:16 <barrucadu> hyperisco: There is legacy stuff we actively want to get rid of, but it's updated at the same time.  Unless by "legacy" you mean "unmaintained".
06:36:37 <lyxia> kosmikus: I seem to remember some generic ToJSON/FromJSON with type-level options for use with DerivingVia, was that yours? And is it usable or published on Hackage?
06:37:21 <hyperisco> barrucadu, yeah, I mean there are devices clients are using that you can't update.
06:37:53 <barrucadu> Right, no, we don't have that.  Some of our APIs are publicly exposed but they're explicitly "use at your own risk, we can change this at any time"
06:37:58 <merijn> hyperisco: Than you should develop around that, which is perfectly possible with the existing API, that's still no reason not to extend the API with functionality that is desirable in many other cases
06:38:51 <kuribas> hyperisco: my usecase is testing the API, so being strict makes a lot of sense.
06:39:25 <kuribas> expect an aeson patch soon :)
06:39:35 <kuribas> well, pull request
06:39:51 <hyperisco> Programs are being designed to be fragile. It is interesting.
06:40:59 <merijn> hyperisco: Fail fast is a feature in many environments
06:41:31 <hyperisco> I thought that was a mantra in product development…
06:42:04 <merijn> No, fail fast is major part of the UNIX philosophy
06:42:15 * Rembane waves the Erlang flag around
06:42:23 <merijn> And Erlang, yes
06:43:55 <kuribas> hyperisco: why should you allow an application to send you garbage?
06:44:08 <kuribas> (if you are the one controlling the API)
06:44:11 <hyperisco> Hm. Never heard of it and I don't know what it means. In product development it entails building the minimal product that can be tested for suitability.
06:44:29 <merijn> hyperisco: It means..."fail fast in case of error" as opposed to "try and workaround errors"
06:44:52 <hyperisco> I see. That's what I mean by designed fragility.
06:45:06 <merijn> Because trying to workaround/hide errors can make it orders of magnitude more difficult to correctly trace/attribute failures leading to overly complex and brittle systems
06:45:16 <merijn> hyperisco: It's about being robust on the meta level
06:45:42 <hyperisco> I disagree with every part of that.
06:45:54 <merijn> hyperisco: That's fine, but many people do not
06:46:04 <hyperisco> No it is just flawed
06:46:21 <kuribas> I agree with merijn
06:46:25 <hyperisco> Being tolerant of errors does not necessitate hiding them.
06:46:42 <merijn> See also "crash-only" software
06:47:07 <kuribas> btw, I am not against allowing deprecated fields
06:47:11 <hyperisco> And if you're not hiding errors, then it is not more difficult to trace or attribute failures, and so the system is not more complex or brittle.
06:47:26 <sarahzrf> how about: software which fails fast, but provides a continuation to continue as well as it can if you decide that it should continue
06:47:44 <sarahzrf> i believe i heard that common lisp had a feature like that
06:47:47 <hyperisco> sarahzrf, and possibly more than one, yes!
06:49:14 * hackage differential 0.1.2.0 - Finds out whether an entity comes from different distributions (statuses).  https://hackage.haskell.org/package/differential-0.1.2.0 (GregorySchwartz)
06:52:54 <monochrom> DOS did that when it said "B: not found. (A)bort? (R)etry? (C)ontinue?"
06:53:22 <monochrom> Err actually s/(C)ontinue/(I)gnore/
06:58:56 <hyperisco> Ever tried to save an RTF as a TXT or a DOCX as a DOC, etc? It warns of data loss.
06:59:14 * hackage weekdaze 0.0.0.1 - A school-timetable problem-solver.  https://hackage.haskell.org/package/weekdaze-0.0.0.1 (AlistairWard)
07:00:29 <kuribas> monochrom: I remember that one, none of them worked :)
07:33:49 <delYsid``> sarahzrf: Oh yeah, CL just dropped you in a sort of debugger, where you could retry, examine the stack, and even return a different value.
07:35:04 <delYsid``> Interactive death, so to speak.
07:35:36 <delYsid``> s/pped/ps/
07:35:45 <sarahzrf> delYsid``: oh, i thought i heard there was like a built-in feature as part of the exception system for resuming from where it was thrown?
07:36:26 <delYsid``> sarahzrf: resume was just one option, but yeah.
07:37:14 <delYsid``> You could also choose what to return instead, which was sort of spooky :-)
07:40:32 <delYsid``> Nothing beats the tooling of elisp though.  A pretty slow interpreter sadly, but developing code interactively never felt that nice again.  A REPL is just one part of the interactive experience.
07:41:50 <Welkin> developing with haskell in ghci is pretty damn good
07:41:57 <Welkin> it blows away any other language I've worked with
07:42:08 <Welkin> even python is terrible
07:42:25 <hyperisco> how have I been programming for the past year and half without using a REPL, wow
07:42:25 <Welkin> you can't even reload the file
07:42:33 <delYsid``> Welkin: Therre is no way to have :edit go to a warning, just for starters.
07:42:52 <Welkin> I haven't used the full power of SLIME or other lisp repls
07:42:59 <hyperisco> Maybe it isn't as important as I thought. Hrm.
07:43:13 <Welkin> but not including that, haskell is leagues beyond most popular languages
07:43:47 <Welkin> just basic editing and :r to reload makes a huge difference
07:44:03 <maerwald> ghci triggers the OOM killer eventually xD
07:44:06 <hyperisco> If you have to run it in a REPL then it must be too complicated to understand a priori
07:44:08 <delYsid``> hyperisco: It sure can be done, and it develops an important skill to just write code down withouth constant testing.  However, I still remember my lisp days fondly.
07:44:37 <Welkin> hyperisco: you run it to double check that it works
07:44:48 <hyperisco> Nah, that's test suites.
07:44:56 <Welkin> I don't write test suites
07:45:00 <Welkin> that's a waste of time
07:45:02 <hyperisco> Maybe REPLs are actually enabling programmers to write worse programs.
07:45:04 <Welkin> the type system is good enough
07:45:17 <hyperisco> That scares me Welkin.
07:46:15 <delYsid``> It certainly catches a lot of bugs which slipped when I was using more dynamic languages.  But I occasionally do stupid things which a test suite would catch.
07:46:18 <merijn> What kinda coddled and fuzzy world did you grow up in that code has things like tests? :p
07:46:20 <Welkin> tests are technical debt
07:46:35 <alx741> Welkin: how?
07:47:00 <Welkin> make a tiny change to your code that takes 5 seconds, and spend 15 minutes fixing the tests
07:47:07 <Welkin> in my experience working in ruby and javascript
07:47:09 <Welkin> it's a nightmare
07:47:20 <hyperisco> There's an economy to it.
07:47:31 <delYsid``> I learnt to write tests when I briefly tried to use Python for serious stuff.  Gave up pretty quickly, but the TDD idea sort of stuck.
07:47:36 <Welkin> the type system catches pretty much every error you would have
07:47:41 <Welkin> logical errors are easy to spot
07:47:48 <Welkin> the output will obviously be wrong
07:48:11 <alx741> ah, there's some trade off there yes
07:48:14 <hyperisco> How would you know?
07:48:49 <eviltwin_b> then there's fun stuff like a pefectly valid (and passing) test that tests the wrong thing
07:49:50 <delYsid``> You really learn how bad your unit tests were if you start to think about how to writequickcheck properties that actually DTRT.
07:50:00 <delYsid``> s/if/once/
07:50:37 <hyperisco> The nondifference of REPLs and writing tests should be salient right now.
07:54:02 <hyperisco> My heuristic is to wait for a code library to stop changing frequently before investing in testing it. If it hasn't seen a change in a month, that might be a good time.
07:54:18 <hyperisco> Which seems to be related to how many dependents it has.
07:54:27 <dmwit> Welkin: What is this nonsense? I've written plenty of well-typed programs with bugs in them.
07:54:54 <dmwit> Heck, GHC has one of the most comprehensive test-suites of any Haskell project, and it's not written by dumb idiots who don't know how to exploit a type system.
07:55:16 <hyperisco> And if you want to quickly figure out who the TDD advocates are in the room, say that and then look bulging eyeballs or facepalms
07:55:27 <hyperisco> look for
07:58:59 <hyperisco> delYsid``, If you're an avid TDDer then what is your assessment of the overhead of testing?
07:59:28 <merijn> dmwit: I'm all for testing, but all against TDD and "unit test everything"
08:00:24 <alx741> "unit test everything" fits in other languages though, say python, javascript, ruby...
08:00:33 <merijn> Testing is an investment where you should weigh the ROI of time spend on it. i.e. focus on testing for catastrophic scenarios (where the cost of failing is too high), likely areas of failure (likelihood of tests paying of is good)
08:01:09 <merijn> I think a mix of smoke tests, integration tests, property tests, and regression tests in general offers a better ROI than TDD does
08:01:21 <hyperisco> Okay, but in those languages it isn't necessarily about testing generally, it is specifically about "code coverage" so that you shake all the branches for errors
08:01:22 <alx741> there you either test even the stupid things or it will blow up on your face at run time. That isn't the case in haskell, hence the need to test orders of magnitud less
08:01:55 <hyperisco> Errors such as "myCat is not a variable" and "myCat does not have type Reptile"
08:02:14 <merijn> And a lot of the TDD propaganda downplays or downright ignores the concept of ROI when it comes to testing
08:02:29 <hyperisco> Which are statically ruled out in other languages
08:02:30 <sarahzrf> ROI?
08:02:33 <sarahzrf> oh
08:02:36 <merijn> sarahzrf: Return On Investment
08:03:46 <hyperisco> I can spend 10x the time devising tests for something than actually making the thing. Easy. That might be a fault of mine.
08:05:39 <Welkin> if someone mentiones TDD, my opinion of them plummets through the floor
08:06:06 <alx741> test coverage is a misguided metric, and it turns itself into the wrong objective to pursue
08:06:26 <Welkin> even the inventor of TDD himself, DHH, has denounced it
08:06:32 <Welkin> saying it was a mistake
08:07:32 <hyperisco> https://dhh.dk/2014/tdd-is-dead-long-live-testing.html
08:08:15 <dminuoso> Once you start considering types as tests, then TDD is what we frequently end up doing..
08:08:37 <dminuoso> hyperisco: dhh is not exactly the norm..
08:08:49 <alx741> buuut it could be kind of aproppiate (test coverage) for languages like python... if you don't excersice every tiny dumb thing, that thing will go boom even for a syntax error
08:09:00 <hyperisco> dminuoso, isn't that his point too?
08:09:11 <dminuoso> hyperisco: What exactly?
08:09:36 <hyperisco> His piece there is about how TDD turned into something other than he intended
08:10:10 <dminuoso> In my eyes "write out tests first, implement to appease the type checker" is the core essence of TDD.
08:10:17 <dminuoso> *write types first
08:10:20 <dminuoso> We practice it daily
08:12:14 <Welkin> but you don't write tests
08:12:19 <Welkin> you write the type, which takes a second
08:12:26 <alx741> to which extent are type driven development and test driven development similar
08:12:30 <Welkin> it's type driven development
08:12:43 <Welkin> they are not at all the same other than you have a metric for if the code is right
08:12:44 <hyperisco> I like that he mentions DI as a test-induced plague.
08:12:50 <dminuoso> alx741: A type can be viewed as a test.
08:13:15 <dminuoso> alx741: The type checker executes this test. It can fail or succeed. On success you have verified some properties about your program.
08:13:34 <Welkin> but it's not a test
08:13:35 <dminuoso> (Which properties kind of depend on what guarantees the type system gives you, and what you encode into it)
08:13:44 <Welkin> unit tests are error prone, unscientific, and could be totally wrong
08:13:55 <Welkin> they also break when you change the code
08:13:59 <Welkin> the compiler can infer all your types
08:14:03 <Welkin> you don't need to write them
08:14:36 <Welkin> it's mre compiler driven development than anything else, if you need a contrived marketing term
08:14:53 <dminuoso> hyperisco: But yeah, Ive read that article before. Usually I dont agree much with him, but its one of his better pieces.
08:15:59 <hyperisco> I recently decided that conditional compilation was smarter than parameter passing (a form of DI).
08:17:34 <hyperisco> Because the latter involves widespread complications, and the former doesn't and is simple.
08:18:16 <hyperisco> This because I cannot effectively test everything on the target hardware because… reasons. =\
08:29:27 <fendor> why cant stack install ghc 8.6.4 on "windows32" systems?
08:31:09 <alx741> are there value-logic bugs that are not at all obvious and that can't really be encoded by the type system (even with dependent types)? in which case testing that logic at value level by identifying invariants would make sense
08:31:33 <hyperisco> Even with DTs? That's a tall order. Hm.
08:33:18 <alx741> given the most precise type that we can currently encode, how many non-trivial inhabitants does it have? that would be the space of concern i think
08:33:28 <hyperisco> How about function equality.
08:34:59 <alx741> that's a good one
08:35:49 <alx741> but then it could be argued that testing is pushed outside practical every-day situations
08:36:18 <hyperisco> That's also DTs ;)
08:38:14 <hyperisco> No type system I have used describes time and space use.
08:38:30 <hyperisco> That's scantly found in tests either though.
08:39:23 <c_wraith> I have written tests for lack of space leaks in common patterns for one of my libraries
08:39:25 <alx741> hmmm
08:40:09 <c_wraith> it's not very automated though. run a command that loops forever watch process memory use in top
08:56:15 <dminuoso> alx741: So I recently had this case of `guard (c /= 0)` being mixed up with `guard (c == 0)`
08:56:30 <dminuoso> alx741: Inside STM mind you. Im not sure whether a type system can protect me against this sort of value level mistake.
08:57:29 <eviltwin_b> only if it can ensure the casecan't happen, implying you can't even write that
08:57:41 <eviltwin_b> (without raising a type error)
09:00:05 <dminuoso> Although I guess I could have encoded this into the type system with some trouble.
09:04:14 * hackage birch-beer 0.1.3.0 - Plot a colorful tree.  https://hackage.haskell.org/package/birch-beer-0.1.3.0 (GregorySchwartz)
09:13:15 <edwardk> dminuoso: boolean blindness
09:14:15 <edwardk> to avoid it, don't hold bools, hold the thing that lets you do what you want or proves the condition. it is easier in something like agda here you can't 'undefined' your way to glory
09:33:08 <bontaq> https://dev.to/rgeraldporter/building-expressive-monads-in-javascript-introduction-23b -- this seems very wrong to me, is it?
09:36:13 <fragamus_> I went loking to see where Profunctor fit into typeclassopedia. I thought it would be in there but it was not. 
09:44:59 <fernandomrtnz> I’m a beginner trying to implement an API server, and I’m running into a parse error due to incorrect top level declarations. My expectation is that the function I’m calling is part of the top level since it is immediately after the imports. The gist includes the relevant code and compiler error. The code is two files of less than 50 lines each.  https://gist.github.com/fernandomrtnz/3c3a575347e3e8532e6fac13879bdc98
09:48:49 <Geekingfrog> fernandomrtnz, you cannot run code directly from the top level. What is this useTPGDatabase function doing?
09:49:56 <Geekingfrog> fernandomrtnz, if you want to perform some kind of initialization (create a connection for example), you need to do that inside the `main` function, and pass the result to your `app`
09:51:13 <fernandomrtnz> Geekingfrog, http://hackage.haskell.org/package/postgresql-typed-0.5.3.0/docs/Database-PostgreSQL-Typed.html#v:useTPGDatabase. The function is to check types with my postgresql queries at compile time. The docs say it has to be called as a top level declaration and that it "produces no code". I'll have to dig around if you have a more specific question about what it does.
09:51:55 <Geekingfrog> ah, this is template haskell stuff.
09:52:33 <Geekingfrog> You need to enable the relevant pragma then: add {-# LANGUAGE TemplateHaskell #-} into your Main.hs file
09:53:38 <fernandomrtnz> Oh. Thanks.
09:54:14 * hackage pantry-tmp 0.1.0.0 - Content addressable Haskell package management  https://hackage.haskell.org/package/pantry-tmp-0.1.0.0 (borsboom)
09:58:21 <hyperisco> bontaq, what statement do you think is wrong?
10:09:34 <bontaq> "chain-like: methods that either return a different kind of monad, or a non-monadic value; it may or may not "exit" the monad pattern, which I like to refer to as "unwrapping" the monad value" -- for their definition of chain/bind/flatmap 
10:14:04 <nitrix> Comonads :3
10:14:10 <delYsid``> hyperisco: To my experience (which is pretty limited), it kind of depends on the actual project how useful unit tests are.  Case in point, I wrote a braille music to lilypond compiler once.  For that, nailing features with test cases was an absolute blessing to make progress without accidentally breaking things I already had covered.  However, I have had my share of projects where I didnt feel such a pressing need to work with unit
10:14:10 <delYsid``> tests.
10:15:35 <nitrix> You're probably tested manually the things you decided not to write tests for.
10:16:01 <nitrix> *'ve.
10:19:57 <delYsid``> That said, I am not surprised that GHC and clang (for instance) have pretty extensive test suites.
10:20:41 <nitrix> I will conjecture that every project eventually reaches the point where writing automated tests would save more time than manually testing your cases past some threshold and that people claiming they don't need tests are oblivious to how they manage their time. :)
10:21:26 <nitrix> I'll venture further and say that having to chose between a strong type system or tests, I'd chose the tests.
10:22:23 * nitrix bites the bullet >:D
10:24:07 <Batholith> so I thought I had a vague understanding of monads. turns out after hitting a problem with IO monad that I don't understand monads at all. so now I'm reading about it. but I'm curious, what helped you understand monads? like what did you read or hear that made it all click in your head?
10:24:56 <alx741> Batholith: what helped me was stop reading about monads and start using them
10:25:45 <koala_man> same. repeated use of individual monads made it way easier to understand the generalized concept
10:28:14 * hackage stack 2.1.1 - The Haskell Tool Stack  https://hackage.haskell.org/package/stack-2.1.1 (borsboom)
10:29:11 <Batholith> now that you understand it, do you think it's actually a fairly simple concept? I'm curious if it's similar to learning pointers in C and C++. it seems magical and really hard to wrap one's head around, but once you've used them for a while, you sort of get them and it's a really simple idea in the end
10:29:14 * hackage too-many-cells 0.1.7.0 - Cluster single cells and analyze cell clade relationships.  https://hackage.haskell.org/package/too-many-cells-0.1.7.0 (GregorySchwartz)
10:29:58 <alx741> Batholith: that would be a good analogy yes
10:31:21 <dmwit> Batholith: For me, the two resources that helped the most were You Could Have Invented Monads and All About Monads.
10:31:24 <dmwit> ?where ychim
10:31:24 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
10:31:25 <dmwit> ?where aam
10:31:25 <lambdabot> http://www.haskell.org/haskellwiki/All_About_Monads
10:31:43 <c_wraith> the point at which I finally understood monads was the point at which I went "oh, that's all"
10:31:49 <dmwit> But neither of them is about IO. If what you want to deal with is IO, then you should learn about IO.
10:32:19 <Batholith> ah thanks for the links!
10:32:22 <dmwit> I suspect (though I don't know for sure) that it is possible to use IO effectively without understanding the generalization of a tiny fraction of the IO API that we call Monad.
10:33:18 <jle`> Batholith: are you sure you had a problem with "the IO monad", or with IO itself?
10:33:48 <jle`> Batholith: keep in mind that almost all of the properties of IO that make it useful have nothing to do with it being a monad
10:34:26 <jle`> Batholith: so your problem with using IO might just be a problem with using the 99% of the functionality of IO that is unrelated to its monadness
10:34:43 <jle`> Batholith: in that case, you don't really have a problem with 'understanding monads' :)
10:35:09 <jgt1> functor helped me get monads
10:36:22 <jgt> and trying to fmap some function that returns a `Maybe a` over a `Maybe a` value
10:36:31 <Batholith> the problem I had was that I basically wanted to print in a pure function without having to return the IO monad that putStrLn returned, so I basically had `foo ls = case (putStrLn "oopsie") of _ -> ls` and I was stuck wondering for hours why nothing was printed
10:36:37 <jgt> and then it's like, oh crap, now I have some nested `Maybe (Maybe a)` value
10:36:41 <jle`> right, but i think there's a good chance that Batholith doesn't have a problem with monads, but a problem with IO
10:36:52 <jgt> yeah I think you're right jle` 
10:37:07 <jle`> Batholith: remember that a value of type `IO ()` is just a normal value
10:37:15 <jle`> like an Int or a Bool
10:37:24 <jle`> so that would be the equivalent of writing foo ls = case True of _ -> ls
10:37:25 <dmwit> Batholith: Half the point of IO is that you can't hide that you're doing it from the type system.
10:37:39 <dmwit> Batholith: So if you want to do IO, your type will have to say so. Can't do it from inside a "pure" type.
10:37:42 <jle`> Batholith: an IO is just a normal, 'inert' value.  evaluating a value of type IO does not trigger any IO
10:38:01 <jle`> if you 'evaluate' or 'check' it, it's no different than evaluating a Bool or a String or an Int
10:38:09 <jle`> and that's actually the reason why it's useful :)
10:38:45 <jle`> and yeah it looks like this is definitely not a problem with monads, but a problem with IO in specific
10:39:09 <jle`> and this confusion is one of the unfortunate results of everyone saying 'io monad' all the time :|
10:39:47 <dmwit> "the IO static analysis"
10:39:56 <dmwit> "the IO taint tracker"
10:40:03 <Batholith> yeah I had to learn that the hard way haha. like it seemed so magical to me it returns a value of type IO (), and if you don't chain it with main's value or make it main's value, it somehow stops working
10:40:28 <jle`> right, the fact that it returns a value of type IO () means that it's *not* magical
10:40:35 <jle`> the magical stuff happens in other languages
10:40:40 <jle`> in haskell, `putStrLn` is a pure function
10:40:50 <jle`> it takes a stirng, and returns *description* of IO that would print that string
10:41:17 <jle`> IO () is just a normal, non-magical data type
10:41:34 <jle`> it *describes* IO. it doesn't perform IO
10:42:32 <jle`> when you compile a haskell problem, ghc looks at the IO action that 'main' describes, and compiles that to IO-doing bytecode.  it reads a pure description, and returns the binary that would fulfil that description's requirements of IO
10:42:53 <jle`> but the whole time in haskell, you never actually perform IO. you're describing a specific IO action that you want ghc to compile for you
10:43:52 <Batholith> but what's magical to me is that a value of type IO () somehow carries information (meaning the description) onwards, and that you have to give it in main's value for the action to happen
10:44:16 <dmwit> Why is it magical that a value of type IO () carries information?
10:44:21 <dmwit> Values of *most* types carry information.
10:44:24 <jle`> Batholith: is it magical that a C source file carries information?
10:44:51 <jle`> it's just a file of ASCII text. but it somehow describes IO that you can compile to do
10:45:05 <jle`> a value of type `IO ()` is basically the same as an uncompiled source code file
10:45:39 <jle`> "giving it in main's value" is basically saying "main = my_source_file ... ok, compile that file please ghc"
10:46:09 <jle`> so it would make sense that "main = my_source_file; notmain = my_other_file" would *not* compile the other file
10:46:11 <machinedgod> If I may contribute my 2 cents to this - when I was learning IO, the confusing point was that IO values were called 'actions', so I assumed they're something special, and this 'specialness' was the result of them being monads.
10:46:34 <dmwit> I guess the magic is this: IO () is not the same as (). So even though () doesn't carry information, IO () can.
10:46:39 <dmwit> But that's not magical at all.
10:46:48 <Batholith> it was magical because I forgot how haskell types work. I just remembered that you can have type `Foo` and it can be constructed with `Bar Int Text` `Quux Text MagicMissileLauncher900` and you don't see it in the data type itself (meaning `Foo` alone doesn't tell you it carries those values)
10:46:52 <Batholith> it makes a lot more sense now
10:47:04 <dmwit> e.g. think of `data Magic a = Magic { n :: Int }`. Here a `Magic ()` carries information even though `()` still doesn't.
10:47:28 <jle`> Batholith: ah, how about something like `Int`, which can carry 0, 1, 2, 3, 4, 5, etc.
10:47:33 <jle`> but 0,1,2,3,4 are nowhere in the name of the type Int
10:47:48 <jle`> on a first glance you might think that a value of type Int might just contain the characters 'I', 'n', and 't'
10:48:06 <Batholith> yeah, everything makes a lot more sense now! thanks
10:48:25 <dmwit> yay
10:48:49 <jle`> part of the journey is realzing that haskell's IO is a lot less magical than compared to other languge's IO
10:49:07 <jle`> IO in haskell is just ... well, a boring value
10:49:15 <machinedgod> ^ this.
10:49:50 <jle`> in other languages it is somehow baked into the syntax of the language and leaks into the evaluation model
10:50:07 <jle`> maybe we are used to magical IO. and when we try haskell with unmagical IO, it is confusing
10:50:40 <jle`> we expect IO to be magical and special, like it is in other languages
10:50:59 <dmwit> What justifies the adjective "magical" about IO in, say, C?
10:51:17 <jle`> execution of IO effects is baked into the syntax
10:51:18 <nisstyre> file descriptors are just numbers
10:51:23 <jle`> sequencing occurs with ;
10:51:35 <dmwit> sequencing also occurs with ; in Haskell...
10:51:53 <jle`> with IO, but with also a lot of other types as well
10:52:14 <nisstyre> I'm not sure what file handles are on Windows though
10:52:16 <jle`> so ; is "first-class"
10:52:29 <jle`> IO is not special in terms of its ability to be sequenced with ;
10:52:54 <Batholith> to me, coming from C++ background, IO isn't special or magical at all. it's just a simple chain of calls, so when I call a function, it just does the action. and when I didn't have any idea about Haskell's way of IO, it just seemed off to me that when you call a function, nothing happens, unless you make it part of main's value by chaining it
10:53:19 <Batholith> if that helps makes sense of what was going through my head
10:53:37 <nisstyre> the hard part of IO in languages like C or C++ isn't that it's IO
10:53:52 <nisstyre> it's that those languages have global variables, null pointers, exceptions, and other things of that nature
10:54:27 <nisstyre> oh and the ability to alias references to them infinitely
10:54:31 <nisstyre> without knowing who owns them
10:55:30 <nisstyre> (I/O handles that is)
10:55:44 <jle`> Batholith: yeah, i see where you are coming from.  the fact that you "expect something to happen" when you call a function is the reason why IO is magical in C++
10:56:07 <jle`> it's just that you are used to it being that way
10:56:20 <Batholith> yeah even though reading C seems like a list of steps, there are so many "outside impacts" that change the flow sometimes even unpredictably, or even crash. in that sense C and C++ definitely work rather magically
10:57:09 <nisstyre> all Haskell does is make IO a distinct type
10:57:12 <Batholith> true jle`, and that's well put. instead of thinking with values, I was expecting it to rather magically make side effects happen out of the blue
10:57:16 <nisstyre> it doesn't actually do anything magical to make it "safe"
10:57:23 <nisstyre> you can still have race conditions and corruption
10:58:03 <nisstyre> if your functions are pure, then you won't have that of course
11:08:44 * hackage mega-sdist 0.4.0.0 - Handles uploading to Hackage from mega repos  https://hackage.haskell.org/package/mega-sdist-0.4.0.0 (MichaelSnoyman)
11:33:57 <sm[m]> woo! stack release
11:34:04 <jle`> :D
11:35:03 <saml> is everyone gave up on cabal?
11:35:29 <jle`> no, cabal-install is a pretty great tool now
11:35:58 <jle`> it's just a separate parallel option to stack for the most part, and works very well
11:36:16 <jle`> pepsi and coke sort of thing, i suppose
11:36:19 <cjay-> I've been using cabal new-commands for a long time exclusively
11:36:47 <cjay-> stack still doesn't support backpack, no idea why people are still using it :p
11:37:06 <jle`> presumably the people using it do not use backpack
11:37:15 <davean> jle`: Nah, because stack does everything via cabal so you can't just use stack
11:37:25 <jle`> davean: i'm comparing cabal-install vs stack
11:37:32 <jle`> Cabal is a library that both cabal-install and stack use
11:37:35 <jle`> but it is not a command line tool
11:37:42 <davean> jle`: Actually ...
11:37:49 <davean> jle`: look closer
11:38:43 <agael> started to install Haskell IDE Engine over 2h ago and it is still going...anyone has an idea how long this is supposed to take?
11:38:47 <jle`> i'm talking about the front-end usability; people can use either stack, or cabal-install, to access some sort of usable functionality
11:39:01 <jle`> it's the user-facing interface
11:39:06 <davean> jle`: yah, but when you use stack you still have to use cabal-install
11:39:15 <jle`> do you?
11:39:22 <sm[m]> oh, hello stack/cabal fans!
11:39:36 <davean> jle`: Yah, look how stack works
11:39:43 <subttle> agael: that's normal it may take another hour or so depending on your processor and how many GHC versions you are trying to install
11:39:44 <jle`> i haven't really had any problems working exclusively with one or the other on different projects
11:39:46 <davean> jle`: stack mostly hides if it you stick to stuff it handles well
11:39:53 <sm[m]> will the cabal-install/Cabal clarification ever end..
11:39:57 <davean> but if you get anything stack isn't smoth on you're dealing with cabal-install directly
11:40:06 <sm[m]> agael: can you see it making progress in the log pane(s) ?
11:40:07 <davean> Because stack runs cabal-install
11:40:08 <cjay-> sm[m]: you woke up the channel, it was very effective :)
11:40:15 <davean> and doesn't actually know how to deal with cabal-install's output
11:40:22 <agael> feels like every single one of them. thanks for the info
11:40:27 <davean> I kinda wish stack uses Cabal instead
11:40:38 <agael> yeah, just no percentage or anything
11:40:42 <sm[m]> \o/
11:40:50 <subttle> XD
11:41:29 <jle`> davean: ah, yeah, referring to edge cases where stack fails. at that point you're out what's "supposed" to happen, though. as the two tools are designed, they are meant to be used separately
11:41:50 <sm[m]> new stack's default build output seems unusually verbose
11:42:15 <jle`> yeah, it overflows my narrow tmux pane split
11:42:21 <jle`> (horizontally)
11:47:36 <sclv> i thought stack just gave up on the solver (the case where it actually ran cabal-install) and now there's... just no solver?
11:48:12 <sclv> so, y'know, if you want to use a package not on stackage... have fun solving that manually
11:52:51 <fr33domlover> Hi people! I'd like to share an insight. Maybe I'll blog about it. I'm developing a Yesod web app that is federated using ActivityPub, and I've been thinking about how to split the code into modules. I'm thinking something like the routes file, except instead of HTTP verbs you have activity types, and handlers are dispatched based on the object inside the activity. I'm basically Haskelling alone, so, have
11:52:53 <fr33domlover> nowhere else to share. That's all for now ^_^
11:53:59 <fr33domlover> I guess I'm going to organize things that way, except without TH stuff, just manually
11:54:22 <fr33domlover> Instead of 1 big pile of federation code
11:54:30 <sm[m]> fr33domlover: screenshot or that's just crazy talk!
11:54:39 <sm[m]> (hi :)
11:58:07 <fr33domlover> sm, I admit my UI sucks right now but don't judge by it, here are links to demo and to federation doc and to the web app hosting its own code and tickets https://socialhub.network/t/vervis-ticket-comment-federation-demo/599/2 https://dev.angeley.es/s/fr33domlover/r/vervis/s/FEDERATION.md https://dev.angeley.es/s/fr33domlover/p/vervis
11:58:14 <fr33domlover> Also, hi sm :)
11:59:03 <fr33domlover> sm, have you heard of ForgeFed by chance? ^_^
12:01:13 <sm[m]> fr33domlover: I haven't
12:02:25 <sm[m]> cool
12:03:26 <fr33domlover> sm, it's an ActivityPub based protocol and vocabulary for forge federation (websites like Darcs Hub yay) and it seems I'm kind of leading its development, using a custom forge written in Haskell
12:03:42 <fr33domlover> And with a few more people we are writing a spec
12:04:03 <fr33domlover> And hopefully making more implementations!
12:04:56 <MarcelineVQ> AcitivtyPub spec page overview uses advanced technical terms such as "pretty great" "cool linked data" "luckily" "don't worry" :>
12:05:54 <halogenandtoast> stack 2.1.1 was released if anyone still uses that.
12:06:38 <sm[m]> halogenandtoast: we know!
12:06:43 <MarcelineVQ> a couple people do :>
12:06:48 * sm[m] high fives halogenandtoast 
12:06:54 <fendor> yeah! new stack version!
12:07:14 * hackage heatitup 0.5.4.0 - Find and annotate ITDs.  https://hackage.haskell.org/package/heatitup-0.5.4.0 (GregorySchwartz)
12:07:44 <sm[m]> it's awfully verbose isn't it ? I can't seem to recreate the old verbosity level
12:08:14 * hackage heatitup-complete 0.5.4.0 - Find and annotate ITDs with assembly or read pair joining.  https://hackage.haskell.org/package/heatitup-complete-0.5.4.0 (GregorySchwartz)
12:10:33 <sm[m]> fr33domlover: is that supposed to be fully decentralised p2p-hosted, or is it more for easy syncing between centralised hubs ?
12:12:06 <fendor>  stack ships with cabal 2.4? that is not... latest and greatest
12:13:11 <MarcelineVQ> sm[m]: --versbosity INFO cuts it down quite a lot. any of the verbosity options are different than the default it seems, which is odd imo, one of the verbosity options should be the one for the default verbosity
12:14:08 <MarcelineVQ> oh..
12:14:49 <MarcelineVQ> uh nvm, apparantly INFO isn't the same as info, and there's no indication of that
12:14:59 <sm[m]> isn't info same as default ?
12:15:08 <sm[m]> argh
12:15:10 <fr33domlover> sm, it's not p2p distributed, just federated, it's like in Mastodon where there can be many servers and they all communicate , creating one big network that connects everyone 
12:15:17 <MarcelineVQ> So I'm passing something that doesn't actually does anything, and it doesn't tell me that
12:15:44 <sm[m]> logging style/verbosity seems a never ending hassle with stack[/cabal/ghc]
12:16:26 <sm[m]> I mean, I can never get it to do quite what I want
12:16:35 <MarcelineVQ> I don't mind the verbosity but the line breaking being off for a default console width isn't great
12:16:36 <sm[m]> not a major hassle.
12:16:54 <sm[m]> fr33domlover: nifty
12:17:24 <MarcelineVQ> I'm guessing when it lines up the > it indents them based on the longest package name
12:17:41 <MarcelineVQ> Which is causing wrapping issues in some cases
12:18:07 <sm[m]> what's the problem there ? Layout looks ok here
12:18:27 <sm[m]> well I'm in a wide window with long lines truncated, so I guess that's why
12:18:38 <solonarv> fendor: actually 2.4 is the latest release (well, 2.4.1.0 to be precise)
12:18:44 <MarcelineVQ> sm[m]: "<jle`> yeah, it overflows my narrow tmux pane split" similar issue here
12:19:06 <fendor> solonarv, oh, for some reason I thought, cabal 3 is already released. My bad then
12:20:05 <solonarv> nope! but HEAD is in a usable-ish state and fixes some really obnoxious bugs/shortcomings (especially relevant on windows)
12:21:01 <fendor> good! maybe it will be usable at all on windows then
12:21:07 <solonarv> yeah
12:21:51 <solonarv> the two big issues I ran into were 1) only being able to install executable by symlinking, which doesn't work well on older windows; and 2) an inscrutable error when trying to use a cabal script
12:22:17 <fendor> binary caching of executables was also missing, afaik
12:22:41 <solonarv> the fix to 1) is to also support installing by copying the executably into place, and the fix to 2) is simply a bugfix - turns out the error was related to CRLF line endings
12:29:20 <jle`> does anyone know if cabal.package files get uploaded in the tarball to hackage?
12:29:29 <jle`> trying to see if i can add some flags to affect how hackage builds haddocks
12:33:24 <solonarv> jle`: rough testing (running `cabal v2-sdist` and `tar xzf`ing the result) suggests no
12:33:42 <jle`> ah, i forgot that i could test this locally
12:33:45 <jle`> solonarv: thanks :)
12:33:47 <jle`> drat
12:33:54 <solonarv> you could make cabal include it using the extra-source-files field, but idk if the hackage builder will use it
12:34:13 <jle`> yeah, that does sound unlikely
12:34:21 <solonarv> fortunately you can test this without clogging the hackage namespace: simply upload a test package as a *candidate*
12:35:47 <solonarv> you can do this through the web interface, or I *think* cabal upload actually uploads as a candidate by default (at least --help indicates so)
12:41:42 <isovector1> test
12:41:44 * hackage polysemy-plugin 0.2.0.3 - Disambiguate obvious uses of effects.  https://hackage.haskell.org/package/polysemy-plugin-0.2.0.3 (isovector)
12:43:16 <dminuoso> bontaq: I dont put any faith into web blog articles about introducing "[Insert common Haskell idea] in JavaScript".
12:45:09 <boblehest> dminuoso: My favorite article about software architecture is using PHP. I don't know how I feel about that
12:45:56 <dminuoso> bontaq: For starters the whole article stinks of monad tutorial fallacy and not understanding monad at all. Not a good combination to try and explain something.
12:47:00 <hyperisco> bontaq, they are wrong when they say emit is a required method.
12:47:16 <hyperisco> bontaq, furthermore, they are missing pure/return.
12:47:57 <hyperisco> So, uh, without reading further, I don't think the author understands Monad.
12:48:33 <hyperisco> They think join is the same as extract, so…
12:48:43 <dminuoso> It seems to be an agglutination of fancy words the author has found, and writing some random JavaScript gibberish.
12:48:54 <jle`> ... do i even want to know what article this is
12:49:02 <isovector1> i do! please share
12:49:03 <dminuoso> jle`: Depends.
12:49:22 <jle`> do i feel like having a sad day
12:49:26 <dminuoso> jle`: Do you want a prime example of "fallen into monad tutorial fallacy"? 
12:49:40 <dminuoso> In a particularly bad way?
12:49:51 <jle`> i think i'll just move on and forget i heard about this ._.
12:49:51 <halogenandtoast>  Oh I do!
12:49:51 <hyperisco> It has 41 hearts
12:50:01 <dminuoso> I seriously do not understand why people that dont even understand a basic concept would be keen to writing an article about it.
12:50:38 <jle`> they have twisted "you don't really understand something until you are able to teach it" into "if you want to learn something, try to teach it"
12:50:48 <hyperisco> jle`, lol
12:51:00 <dminuoso> I dont feel competent enough to write an article about what a monoid is, because I have no idea how to pedagogically put it into words that will help a reader develop an intuition in a way better that hasn't already been done a thousand times.
12:51:05 <dminuoso> And monoids are simple.
12:51:11 <hyperisco> Charitably, it could have just been explained poorly to them from someone else.
12:51:14 <yushyin> isovector1: https://dev.to/rgeraldporter/building-expressive-monads-in-javascript-introduction-23b
12:51:36 <hyperisco> At any rate, I am leaving a comment.
12:51:40 <Rembane> This is my understanding of monoids: Set, objects, associative operator, identity element. Yeah.
12:51:53 <Rembane> Which is why my understanding fits better as a haiku rather than an article. :/
12:52:14 <isovector1> yushyin: thanks
12:52:29 <isovector1> does anyone have any good tips on being a maintainer? my CI skills are bad
12:52:37 <dminuoso> Rembane: It's an easy thing to say if you have developed intuition for it.. :)
12:52:53 <halogenandtoast> > A monad is best thought of as a container of a value
12:52:54 <halogenandtoast> *(
12:52:55 <lambdabot>  <hint>:1:25: error: parse error on input ‘of’
12:52:56 <dminuoso> Rembane: To me a monoid is a special case of a category.
12:52:58 <halogenandtoast> :(
12:53:12 <dmwit> Monoids are those things that mathematicians turn into big prefix operators. You know, \sum, \product, \cup, \cap (oh wait)
12:53:34 <Rembane> dminuoso: Well, yeah, but my intution is messy and fuzzy which makes it completely worthless for teaching people stuff. :D
12:53:37 <jle`> i mean the binary operatorness is a good intuition for semigroups
12:53:45 <hpc> isovector1: being a maintainer is trivially easy if you have no users
12:53:49 <dminuoso> jle`: But you still lack the associativity part.
12:54:04 <hpc> so i guess the main skill to learn is dealing with user problems
12:54:10 <jle`> by that i mean that usually the binary operators in math that are useful end up being associative
12:54:19 <jle`> because mathemeticians like to chain them
12:54:21 <hpc> being able to match a user's versions of ghc/cabal/etc and dive into weird issues
12:54:38 <dminuoso> jle`: I mean lets say I want to learn about Semigroup, and you tell me "its a set with a binary associative operation", and I ask you "why is associativity needed? what is so important about it?"
12:54:39 <jle`> so like thinking about what makes a binary operator 'useful'
12:54:40 <halogenandtoast> I liked the definition of "composable computation descriptions"
12:54:50 <dmwit> (mathematician jokes: "let \varepsilon < 0", "\cap_{S\in\{\}}S")
12:55:23 <jle`> yeah, associativity is useful in a notational sense because a lot of times we write things like 1 + 2 + 3 + 4 + 5 and don't want to bother with parentheses
12:55:31 <dmwit> dminuoso: Oh, that's easy. That's so you can distribute the computation across multiple machines and still get the right answer.
12:55:33 <jle`> it's useful for a different reason in a computational sense, though
12:55:53 <jle`> but for mathemeticians, who often care about notation, associative operators give rise to nicer notation
12:56:04 <dminuoso> So associativity is just for convenience?
12:56:17 <halogenandtoast> One could argue mathematics are just for convenience
12:56:18 <jle`> no, but convenience can be a motivation
12:56:20 <dminuoso> Its glued into category theory, so there must be something very fundamental about associativity.
12:56:24 <isovector1> this is a wild tutorial
12:56:32 <isovector1> hpc: that is unfortunately not the case :(
12:56:42 <jle`> it's a 'not even wrong' sort of situation so i don't know if there's anything you can really even say
12:57:04 <dminuoso> I mean a category does not need much at all. Associativity being part of it suggests to me that there's something almost philosophical about associativity.
12:57:29 <dminuoso> jle`: Mmmm.
12:57:48 <jle`> associativity can be thought of as a quotient, maybe
12:58:16 <jle`> if we're talking about why it's useful in general, and not in terms of unrelated motivations here and there
12:59:37 <dminuoso> Im trying to build intuition by thinking that associativity is a core essence of composability of a certain kind.
12:59:45 <isovector1> "Maybe: The Most Powerful Monad"
12:59:52 <dminuoso> A sort of "symmetric composability"
13:00:33 <dminuoso> isovector1: Yeah, Tardis is nothing in comparison!
13:01:11 <isovector1> anyone have an example of using travis to publish to hackage?
13:01:37 <hpc> ah, that kind of "being a maintainer"
13:02:33 <halogenandtoast> dminuoso: Tardis isn't a real monad until I see a white paper
13:02:39 <jle`> dminuoso: it's a 'full melding', so to speak.  like if you link two chains together, you now cannot tell which chains were linked together first
13:02:47 <isovector1> like all the day to day stuff; making sure my builds work, making sure bounds are up to date, make sure the tests pass, not forgetting to upload documentation, etc
13:03:01 <isovector1> doublechecking that my changelog was updated
13:03:28 <jle`> i've heard a lot of people like this "auto mashun" thing but i've always put it off
13:04:04 <jle`> i mostly just use CI and i get emails whenever build start breaking during the auto-runs
13:04:30 <jle`> good CI integration will run the tests for you every few weeks or so according to a schedule you decide
13:04:40 <jle`> and if things start building or bounds stop working then it'll send you an email
13:04:55 <halogenandtoast> one more hour until the final chapter in my Haskell interview
13:05:08 <jle`> that's been good enough for me so far. i manually update changelogs/versions/push and stuff though, but i sometimes consider having it more automated.
13:05:37 <isovector1> jle`: yeah, that's what i'm currently doing. but it still takes up a big chunk of my day
13:05:44 <hpc> that stuff is best done manually anyway
13:06:03 <hpc> unless you're from the future and know how to program something to detect api compatibility and breaking changes
13:06:17 <hpc> and then give a human-readable explanation of it
13:06:28 <gobby> Is is possible to export the data constructors in the `Table` instance in beam? I'm trying to create a primary key from a `Text` value and I can't do it without having that instance in the same file: https://tathougies.github.io/beam/tutorials/tutorial1/
13:06:31 <isovector1> that stuff i'm ok managing by hand. but still like, publishing releases and making sure there is a git release for them and that they're on hackage with the haddock....
13:07:18 <hpc> since you're using travis, have your build system pull from your git repo
13:07:31 <hpc> when doing a release, pull from a specific tag or github release
13:07:31 <dminuoso> gobby: I do not understand what you are asking. What are you trying to export into where?
13:07:48 <dminuoso> gobby: How does one "export a data constructor into an instance"?
13:08:02 <hpc> for making sure haddock is correct, your build system just runs the commands to include it
13:08:15 <hpc> and for editing it, it's part of the source code files
13:08:22 <isovector1> hpc: have an example repo I can cargo cult?
13:08:39 <dminuoso> gobby: Can you perhaps share a gist/pastie of your code and the error message you are getting?
13:08:40 <hpc> sadly no
13:08:49 <hpc> i am bad about actually finishing projects, so i don't release much
13:09:34 <gobby> one sec
13:09:35 <hpc> travis is basically just a bash server anyway
13:09:49 <hpc> so i guess work out doing it manually, then just drop your history into a job config
13:09:58 <dminuoso> jle`: So in some sense associativity isn't as much imposing something, as it is demanding that compositionality is free of extra baggage/structure.
13:10:22 <isovector1> hpc: yeah, but it's configured by yaml, and any syntax errors in your file will make it default to trying to build your project as ruby on rails....
13:10:32 <jle`> yeah. it's a 'quotient' in the sense that it removes things that you are allowed to worry about
13:10:42 <isovector1> i am not confident enough to get that right in a bounded amount of time
13:11:18 <dminuoso> jle`: Ah I see, the word "quotient" makes sense to me.. somewhat.
13:11:37 <hpc> the hell?
13:11:44 <hpc> i thought travis was just expensive jenkins
13:12:06 <hpc> i don't think i can help with that lol
13:12:09 <dminuoso> travis is also being run by a very respectable company with a very bright future for further development!
13:12:21 <hyperisco> Alright, hopefully we can see this article improved. I cast a line.
13:12:30 <dminuoso> hyperisco: You mean deleted?
13:12:33 <dminuoso> ;)
13:13:05 <hyperisco> I advised that too, but I'd also like to help fix it. Figure that is a more productive outreach.
13:13:09 <hpc> dminuoso: heh, i think they got bought and their old devs laid off, iirc
13:13:21 <hpc> companies in germany were going nuts competing to hire them
13:13:25 <gobby> So something like this: https://pastebin.com/wQU7Usz0
13:13:27 <dminuoso> hpc: Was the sarcasm too subtle there?
13:13:34 <gobby> dminuoso: 
13:13:35 <hpc> oh, hah
13:14:41 <gobby> dminuoso: That represents two modules and I would like to import the `DiffPackageName` constructor into `moduleInsertion.hs` to use in `testQuery`
13:15:12 <hpc> anyway i am going to out myself as a weirdo here and say that i like jenkins
13:15:36 <hpc> i have never encountered anything where it just plain wouldn't work
13:15:55 <hpc> meanwhile with something like gitlab ci there's only one right way to do it and it requires kubernetes
13:16:18 <dminuoso> gobby: And what exactly is the issue?
13:16:57 <gobby> How do I export that constructor? 
13:17:10 <gobby> It's not explicitly defined 
13:17:59 <dminuoso> gobby: Oh you mean how to export data constructor from associated data families?
13:19:06 <dminuoso> gobby: You don't need to, since you can refer to it by the data family.
13:19:25 <sm[m]> isovector1: I think there's no magic solution, it's a constant effort. But practice and document/automate one thing at a time and it adds up
13:19:52 <sm[m]> I haven't seen anyone automate hackage releases from travis, and I sort of doubt that's a good idea
13:20:24 <hpc> automating it as in CD, probably unwise
13:20:40 <hpc> automating it as in scripting it so doing it manually is easy, quite wise
13:21:39 <gobby> dminuoso: I just figured it out: I needed to export `PrimaryKey(..)`
13:22:27 <dminuoso> gobby: well you could just import Database.Beam.Table instead.
13:22:32 <dminuoso> gobby: That will give you the data family as well.
13:25:20 <sm[m]> isovector1: one tip: a fast release cadence helps
13:29:08 <jle`> hm neat, we can have absurdF1 :: Foldable1 f => f Void -> a
13:29:51 <jle`> i wonder if that's worth offering as its own function that displays an interesting property. rather than just writing it out from scratch every time you need it
13:33:35 <MarcelineVQ> isovector1: ask edwardk about his release process :>
13:34:26 <gobby> dminuoso: thanks
13:35:39 <dmwit> jle`: absurd.head?
13:36:35 <jle`> yeah, or absurd . fold1
13:36:51 <jle`> i just thought it was a neat property of non-empties
13:37:07 <jle`> the non-empty container of uninhabited items is itself uninhabited
13:37:49 <dmwit> (Is there a "arbitraryChoice" which, like head, returns an element, but unlike head, doesn't promise it's necessarily the first one? So that instances can choose whichever one is most efficient to return?)
13:39:23 <jle`> i don't see anything like that in Data.Semgrioup.Foldable
13:39:25 <hpc> that sounds like a different data structure than []
13:39:35 <hpc> how do you know which is the most efficient?
13:45:03 <dmwit> The instance writer must choose.
13:45:54 <dmwit> e.g. a snoc-list implementation would choose the last element; a Data.Map-alike would choose the root of its tree
13:46:53 <dmwit> I guess for all the instances where it might actually be useful it would also leak unfortunate implementation details. So it's probably not a really great method to have around in the balance of things.
13:47:55 <hpc> oh i see
13:49:00 <hpc> so it's like a traversal or fold without any promise of ordering
13:49:20 <dmwit> It's probably `foldMap1 First`. =P
13:49:38 <dmwit> Or, well... whatever the Semigroup analog of First is.
13:50:08 <dmwit> Or... no. You're righter than me in this case.
13:51:17 <dmwit> You could imagine making a class with a `foldMap` alike but for commutative monoids. And then using a type whose binary operator was not commutative illegally (gasp!). =P
13:57:53 <solonarv> foldMap1 First just gives you head
15:03:44 * hackage grab 0.0.0.1 - Applicative non-linear consumption  https://hackage.haskell.org/package/grab-0.0.0.1 (chris_martin)
15:05:14 * hackage grab-form 0.0.0.1 - Applicative parsers for form parameter lists  https://hackage.haskell.org/package/grab-form-0.0.0.1 (chris_martin)
15:07:15 <jackdk> the semigroup instance of First is also First, but from a different package.
15:11:34 <edwardk> MarcelineVQ: i used to have a bunch of scripts that i used but a series of laptop meltdowns ate my baseline environment. now i do it manually like a barbarian
15:12:22 <edwardk> given phadej and ryanglscott do most of the heavy lifting and THEY have scripts and stuff it still works somehow
15:12:39 <lavalike> edwardk: what is this doing? https://github.com/ekmett/codex/blob/master/parsnip/cbits/parsnip.c &7 on the pointer value escapes me
15:13:37 <edwardk> alignment to 8 byte boundary
15:13:54 <edwardk> so i can scan with uint64_ts
15:14:34 <edwardk> then the trick is to find if any byte in a word is c or null
15:14:52 <edwardk> pretty standard bithack crap
15:14:52 <nshepperd_> dmwit: foldMap1 (Any.pure), where data Any a = Any (RVar a) and (Any left <> Any right) randomly chooses between left and right
15:15:02 <edwardk> i didnt feel the need to SIMD it
15:15:21 <lavalike> doesn't ++s move 1 byte at a time?
15:15:31 <nshepperd_> dmwit: returns a value in O(1) for both cons and snoc lists!
15:16:03 <edwardk> the initial walk is one byte at a time til we hit a word boundary
15:16:15 <edwardk> the  i gallop 8 bytes at a time til i find the end
15:16:47 <edwardk> a better version would use 32 byte boundaries and avx instructions
15:16:55 <lavalike> I see
15:17:28 <edwardk> given this is not exactly a perf bottleneck yet i figured it was time to stop
15:17:55 <lavalike> how does one interpret line 13
15:19:21 <edwardk> as a constant i should have hand written
15:20:07 <lavalike> (:
15:22:34 <edwardk> it puts 0 bit gutters every 8 bits and at the top
15:22:59 <hpc> so 0b0111111101111111...
15:23:00 <hpc> ?
15:23:33 <edwardk> 0 6 ones 0 7 ones 0 7 ones 0 .... 0 8 ones
15:23:41 <edwardk> yeah
15:23:52 <hpc> ah
15:24:42 <edwardk> basically add that number to the number in memory and check to see if something fell in the hole
15:25:14 <edwardk> bit oversimplified
15:25:18 <edwardk> but that is the idea
15:25:21 <hpc> pun intended?
15:25:27 <jackdk> could some of your previous four messages go into the source as a comment, edwardk ?
15:26:03 <hpc> cool trick though, i can see how it's supposed to work
15:26:09 <edwardk> jackdk probably they are retroactive though. most of this code is from some 15 year old code i had in another project
15:26:20 <edwardk> it is a bunch of standard SWAR tricks
15:26:59 <edwardk> all i changed was that it reports location of the null rather than return a null on failure
15:27:22 <edwardk> same math is WAY easier in simd though
15:27:25 <lavalike> this finally makes sense
15:29:03 <edwardk> basically the two magic tests tell us if we _likely_ have a hit
15:29:42 <edwardk> i say likely because the gutters cover up some actual data so you need to confirm
15:30:14 <edwardk> so the scan at the end is to confirm
15:30:34 <edwardk> in theory i could do two scans one for null and one for c based on which magic test passed
15:30:51 <edwardk> simd version needs none of this
15:31:19 <edwardk> just chrcks byte by byte for match and takes the mask and can bsf directly to the hit when anything says yes
15:31:43 <qwebirc46224> hello?
15:31:53 <qwebirc46224> JOIN
15:32:03 <edwardk> skipTillChar is kind of a workhorse for other algorithms so it is worth getting somewhat right but perhaps i’m lost in the weeds :)
15:32:22 <qwebirc46224> I need help installing haskell compiler
15:32:49 <solonarv> qwebirc46224: which operating system are you on?
15:33:02 <qwebirc46224> macOS Mojave
15:33:08 <solonarv> @where ghcup
15:33:08 <lambdabot> https://www.haskell.org/ghcup/
15:33:10 <solonarv> ^ use that
15:33:59 <qwebirc46224> ITo install and run GHC you need the following dependencies:   curl g++ gcc gmp make ncurses python3 realpath xz-utils
15:34:03 <qwebirc46224> I'm getting this message
15:34:13 <solonarv> yes, you should make sure those are installed
15:34:28 <qwebirc46224> how do I install them? I tried but can't figure it out
15:34:59 <solonarv> I would assume they're available via homebrew, but I'm not a mac user so I can't help you in detail
15:36:14 <qwebirc46224> What exactly is it asking for? Tried looking in google but can't find anything
15:36:19 <edwardk> lavalike: any of the other parsnip code trip you up?
15:36:33 <qwebirc46224> To install and run GHC you need the following dependencies:   curl g++ gcc gmp make ncurses python3 realpath xz-utils
15:36:35 <edwardk> you’re probably the first person other than me to seriously read it
15:37:01 <solonarv> it's asking for a bunch of programs/tools to be installed, those are needed for the installation to work
15:38:08 <edwardk> i’ll replace magic with an explicit constant at least
15:44:53 <qwebirc46224> Can anyone help me with this message:
15:44:53 <qwebirc46224> curl g++ gcc gmp make ncurses python3 realpath xz-utils
15:45:03 <qwebirc46224> I need help installing those dependencies
15:45:07 <qwebirc46224> I'd appreciate any help
15:45:17 <qwebirc46224> I'm on macOS mojave
15:45:20 <edwardk> the other exercise in bit twiddling in codex so far isnt as significant https://github.com/ekmett/codex/blob/master/glow/src/Graphics/Glow/State.hs
15:45:46 <hpc> qwebirc46224: you were told to try homebrew above
15:47:25 <edwardk> download brew then let brew install everythjng you need
15:47:40 <boj> is there a field for adding the timestamp output of  cabal v2-update  to your  cabal.project  file?
15:48:57 <oo_miguel> From what I thought to understand using applicatives gives me less power as opposed to monads, which in turn lets me reason about my programs/constructs easier. On the other hand I can construct a "halting problem" using just a plain function (something as the collatz conjecture). Is there some class of computations which I can NOT express using "plain/pure" functions, or does the monadic or applicative
15:49:00 <oo_miguel> style only simplify the way I can write things down?
15:50:57 <oo_miguel> Maybe I should add that I used recursion in the "plain function" example above. 
15:51:14 <hpc> oo_miguel: strictly speaking, if you take away even the definitions in Applicative you still have a turing complete language
15:51:58 <hpc> but you can still contemplate based on types, what's possible in (a <*> b <*> c ...) vs (a >>= b >>= c ...)
15:52:53 <hpc> in very generic terms
15:54:07 <hpc> so say, a parser
15:54:46 <oo_miguel> ook, this makes sense. obviously the applicative is easier to contemplate about. I was looking for some strict example for: what I can NOT accomplish without monads/applicatives.... but since they are made up of the same building blocks as the rest of the langauge my question makes little sense.
15:55:36 <oo_miguel> guess it's mainly caused by the possibliity of recursion
15:55:49 <solonarv> recursion does muddle things a bit, yes
15:56:26 <hpc> if you restrict yourself a bit, there's a nice property of applicative parsers compared to monadic parsers
15:56:36 <solonarv> a parser-y example:
15:56:37 <hpc> say you have something like (,) <$> fooParser <*> barParser
15:57:06 <solonarv> monadically you can write: do n <- parseInt; replicateM n parseFoo :: Parser [Foo]
15:57:18 <solonarv> you can't write this applicatively
15:57:21 <hpc> the sorts of grammars that can be expressed in that style are fairly simple
15:57:30 <oo_miguel> yeah, parsers were my first encounter with applicatvie vs. monadic.
15:57:35 <solonarv> but actually you can, by making an infinite grammar
15:57:39 <oo_miguel> and last for now ;)
15:57:40 <hpc> there isn't a way you can make the structure of barParser depend on what value fooParser produces
15:57:54 <hpc> like if fooParser :: Parser Int
15:58:06 <hpc> you can't decide that if fooParser produces 5, don't run barParser
15:58:18 <hpc> meanwhile in a monadic parser, perhaps you have
15:58:24 <solonarv> like so: asum [ parseExactlyThisNumber n *> replicateA n parseFoo | n <- [0..]]
15:58:45 <solonarv> (asum just <|>'s together stuff in a container)
15:58:49 <hpc> do {x <- fooParser; if x == 5 then (x, some constant) else (,) x <$> barParser}
15:59:39 <hpc> the grammar in this case would be something complicated, and beyond say, BNF
16:00:28 <hpc> or maybe it could still work in specific cases, but you'd have to bake the notion of barParser and fooParser together in some way
16:00:34 <hpc> and they're no longer fully independent definitions
16:03:24 <oo_miguel> hpc: solonarv: ok guess I get it. thank you for the examples! In the end the "ease of reasoning" will apply only to some particular constructs I can look at. as the (,) <$> fooParse <*> barParse
16:04:04 <oo_miguel> but "fooParse" itself can be touring complete
16:04:52 <oo_miguel> in fact somebody (guess dmwit) told me here once upon a time, that even for parsing some simple string will require something more powerful than an applicative iirc
16:06:23 <c_wraith> most "Applicative" parsers are actually Applicative + Alternative
16:06:32 <oo_miguel> it seems I come back with the same question, and just reforumlate them in my head ;)
16:07:01 <c_wraith> you need something like Alternative to handle branching in the grammar.
16:08:34 <oo_miguel> c_wraith: ah right
16:24:39 <dmwit> nshepperd_: 1. Cool! 2. I don't believe your O(1) claim at all. 3. Why are you telling me this?
16:35:35 <_d0t> hi. I have a class with an associated type family. How do I find out which instance of that class is used for a particular application of the type family?
16:35:53 <_d0t> Is there some special ghci command for that?
16:36:42 <jle`> _d0t: do you mean, how can you tell what 'c' is if you know `MyFan c` ?
16:36:55 <jle`> like if MyFam c ~ Int, or something
16:37:03 <_d0t> jle`: no, the opposite
16:37:22 <_d0t> say, for MyFam Int I want to find out which MyFam instance is used.
16:37:24 <jle`> so you want to find a particular application of the type family, for an instance of that class
16:37:36 <jle`> _d0t: Int is the instance there
16:37:42 <jle`> if MyFam is the type family
16:37:42 <_d0t> Int is an argument
16:37:55 <jle`> yes, the argument of an associated type is always the instance of the typeclass
16:38:03 <_d0t> ugh...
16:38:03 <jle`> for example, class MyClass c where type MyFam c :: Type
16:38:20 <jle`> you can write an instance for Int, instance MyClass Int where type MyFam Int = Bool
16:38:39 <jle`> are you looking for the result of applying MyFam to Int ?
16:38:41 <_d0t> yeah, so I wanna find out where exactly that definition is.
16:38:59 <_d0t> In which instance or wherever.
16:39:11 <jle`> you want to evaluate the type family, you mean? so if you had 'MyFam', and the instance 'Int', you want to know what 'MyFam Int' evaluates to, right?
16:39:11 <_d0t> Having it just printed out would also work.
16:39:13 <jle`> to find that it is Bool?
16:39:21 <jle`> in that case in ghci you can use :kind! MyFam Int
16:39:28 <jle`>  :kind! <..> does evaluation of type families
16:39:55 <jle`> if you had that class, and an instance Int, you could do :kind! MyFam Int, and ghci will return 'Bool'
16:40:03 <_d0t> ok, thanks
16:40:06 <_d0t> got it
16:40:12 <jle`> np :)
16:51:13 <nshepperd_> dmwit: 1. :) 2. I should say O(1) expected. It has a 50% chance of choosing the first item in the list, 25% of choosing the second, 1/8 of choosing the third
16:51:22 <nshepperd_> Etc
16:51:51 <nshepperd_> Generally the average number of steps will be sum n/2^n which is 2
16:52:34 <nshepperd_> dmwit: 3. Because you were asking about choosing an arbitrary item 'cheaply' and this is a way :p
17:14:11 <c_wraith> nshepperd_, I think that's 1/2^n
17:18:44 * hackage Euterpea 2.0.7 - Library for computer music research and education  https://hackage.haskell.org/package/Euterpea-2.0.7 (DonyaQuick)
17:22:50 <dmwit> nshepperd_: I believe your O(1) claim now!
17:24:01 <dmwit> c_wraith: sum 1/2^n is 1, sum n/2^n is 2
17:24:39 <dmwit> (wild, right?)
17:25:02 <c_wraith> that is surprising, but also assumes you start at n=1
17:25:07 <dmwit> sure
17:25:20 <c_wraith> starting at n=0 would make both total 2
17:25:21 <dmwit> if you want to start at 0 then the two sums are 2 and 4
17:25:45 <dmwit> oh, yeah, I'm bad at arithmetic =)
17:27:29 <dmwit> c_wraith: If you want a quick argument, btw, 1/2+2/4+3/8+4/16+5/32+... = (1/2+1/4+1/8+1/16+...) + (1/4+1/8+1/16+...) + (1/8+1/16+...) = 1 + 1/2 + 1/4 + 1/8 + ... = 2
17:28:21 <dmwit> (one more " + ..." before that second equals sign, of course)
18:23:41 <jusss> jle`: I suddently get something from compose, reader monad and kleisli compose, they're all function compose!
18:23:55 <jusss> compose is one unary and one unary
18:24:08 <jusss> reader is one unary and another is binary
18:24:21 <jusss> kleisli compose is two binary compose
18:25:37 <jusss> f . g = \x -> f (g x) ;   f >> g = g (f x) x   ;   f >=> g = \x -> \y -> g (f y x) y
18:26:21 <jusss> the results,  f (g x), g (f x) x, and g (f y x) y
18:27:01 <jusss> are what we want to construct
18:27:12 <jusss> to the form
18:28:40 <jusss> so what about one unary with one three-parameter function?
18:29:45 <jusss> if we want passing two paramters to a bunch of functions, we need to construct those function with three parameters?
18:32:10 <Axman6> > (f >> g) x :: Expr
18:32:12 <lambdabot>  error:
18:32:12 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘f’
18:32:12 <lambdabot>        prevents the constraint ‘(FromExpr a0)’ from being solved.
18:32:50 <Axman6> > ((f::Expr -> Expr) >> (g::Expr -> Expr)) x :: Expr
18:32:52 <lambdabot>  g x
18:33:07 <jusss> Axman6: is this f >=> g     =     \x -> (\y -> g (f y x) y)   right?
18:34:03 <Axman6> > ((f::Expr -> Expr -> Expr) >=> (g::Expr -> Expr -> Expr)) x y :: Expr
18:34:05 <lambdabot>  g (f x y) y
18:34:29 <Axman6> Looks good to me, well done :)
18:40:57 <jusss> (1,1) -> 0 share,  (1,2) -> 1,  (2,2) -> 1,     in compose, unary and unary share 0 parameter, unary and binary share 1, binary and binary share 1, so I wonder (1,3) -> ? and if it exist?    
18:43:49 <Axman6> what's the type
18:43:59 <Axman6> always start with the types
18:44:00 <Welkin> what's *your* type?
18:44:03 <Axman6> ;)
18:44:28 <jusss> f>>=g = g (f x) x, this binary function g, we can construct an unary function to a binary and we can decide don't to use this result (f x), so we can use x in f and g
18:44:49 <jusss> g _ x
18:45:53 <jusss> Axman6: Welkin is there somebody has already did this?
18:46:14 * hackage skylighting-core 0.8.1.1 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-core-0.8.1.1 (JohnMacFarlane)
18:46:47 <jusss> I think there must be somebody have already do compose in three-parameter functions
18:47:21 <Axman6> What;s the type. 
18:47:39 <Axman6> if you can think of the type, you can use hoogle to see if someone has
18:48:14 * hackage skylighting 0.8.1.1 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-0.8.1.1 (JohnMacFarlane)
19:09:22 <Welkin> https://developer.apple.com/videos/play/wwdc2019/204/
19:09:42 <Welkin> video on SwiftUI that basically says "functional programming solves all of these things"
19:12:47 <maerwald> :>
19:14:11 <maerwald> I like the data flow primitives table
19:14:30 <elcaro> hi peoples... can I get some noob help
19:14:37 <suzu> where is empty :: Map k v in `relude`?
19:14:44 <suzu> does it just not exist?
19:15:35 <elcaro> i'm running into issue trying to convert large numbers between binary and decimal
19:15:38 <elcaro> https://glot.io/snippets/fd55wmop9t
19:15:46 <elcaro> I know the issue is the Int type has limited precision
19:16:17 <Welkin> use Integer
19:16:18 <elcaro> I can modify toBin to Integer -> String and that side works, but how to I modify toDec to return an Integer
19:16:19 <maerwald> Welkin: but Swift does refcounting right
19:16:28 <Welkin> maerwald: swift is a fine language
19:16:33 <Welkin> I have nothing against it
19:16:39 <Welkin> it has some nice features
19:16:46 <maerwald> I built an app with it once, it was terrible :D
19:16:50 <Welkin> and SwiftUI is a huge improvement over UIKit
19:16:51 <maerwald> But that was when it was fairly new
19:17:01 <Welkin> I built an iOS app too, and it was great
19:17:06 <maerwald> Interfacing with C was difficult because no macro support
19:17:09 <Welkin> the bad part was submitting to the app store
19:17:13 <maerwald> lol
19:17:22 <Welkin> yeah
19:17:26 <Welkin> I used swift back in 2015
19:17:44 <Welkin> when it was still version 1, or 2 just came out
19:18:18 <maerwald> I think GCed languages for mobile are challenging, unless they are heavily optimised for it (which is the case for the jvm on android right)
19:19:04 <maerwald> I could be fantasizing
19:19:06 <elcaro> Welkin: how can I make toDec return an Integer?
19:26:20 <Welkin> maerwald: I don't see why that would be the case
19:26:36 <Welkin> your phone is a super computer with tons of fast cores and tons of memory
19:27:04 <Welkin> only if the GC is plain bad, like it can be in java
19:29:00 <Welkin> SwiftUI is seriously making me want to build an iOS app again
19:30:08 <maerwald> Welkin: well, GC is especially difficult when laziness is involved
19:31:10 <Welkin> but none of these languages are lazy
19:31:24 <Welkin> haskell is the most popular lazy language there is
20:35:49 <dmj`> is there a way to do variadic functions w/o needing to explicitly give a type annotation
20:36:52 <dmj`> https://gist.github.com/dmjio/ddf46f1c3cb9950b44a2726c6de844a9
20:39:44 * hackage bimap 0.4.0 - Bidirectional mapping between two key types  https://hackage.haskell.org/package/bimap-0.4.0 (joel_williamson)
20:59:02 <jle`> jusss: yea :D
21:02:01 <Axman6> dmj`: printf manages it doesn't it?
21:08:39 <dmj`> Axman6: yea, I figured it out, was missing a fromIntegral
21:10:20 <jusss> jle`: are you familar with Promise in JS? a non-strict Monad
21:14:01 <dmj`> have a nice variadic api now
21:14:03 <dmj`> dimensions :: Dims = dims 1 2 3 4 5
21:15:24 <jle`> i have somewhat familiarity
21:23:44 * hackage bson 0.3.2.8 - BSON documents are JSON-like objects with a standard binaryencoding.  https://hackage.haskell.org/package/bson-0.3.2.8 (VictorDenisov)
21:26:51 <damoi1> yo guys
21:26:53 <damoi1> whats going on
21:32:58 <Axman6> yo bro not a lot
21:33:14 <Axman6> just gettin our haskell on
21:54:32 <mniip> how come I still get deprecation warnings if I use one deprecated function in another
22:01:44 * hackage unicode-transforms 0.3.6 - Unicode normalization  https://hackage.haskell.org/package/unicode-transforms-0.3.6 (harendra)
22:06:14 * hackage xls 0.1.2 - Parse Microsoft Excel xls files (BIFF/Excel 97-2004)  https://hackage.haskell.org/package/xls-0.1.2 (harendra)
22:48:44 * hackage nonempty-containers 0.3.1.0 - Non-empty variants of containers data types, with full API  https://hackage.haskell.org/package/nonempty-containers-0.3.1.0 (jle)
23:17:29 <maerwald> anyone using amazonka-s3? Cannot make a put with presigned url work. Always throws SignatureDoesNotMatch
23:43:01 <Axman6> just make the signature match
23:44:03 <maerwald> What signature
23:44:56 <maerwald> match what? There is nothing you match manually
23:44:57 <maerwald> https://docs.aws.amazon.com/AmazonS3/latest/dev/PresignedUrlUploadObject.html
23:45:02 <maerwald> Except haskell package has zero documentation
23:45:18 <Axman6> have you looked at the s3 docs?
23:45:29 <maerwald> Sure
23:45:43 <maerwald> None of them have haskell specific info :)
23:45:46 <Axman6> uh, sorry, thought that was the hackage url
23:50:22 <Axman6> does amazonka support presigned URLs? I can't see any way to use them
