00:03:56 <saurabhnanda> alanz, wz1000: is HIE good for huge project now? Or are space-leaks still a thing?
00:05:26 <Axman6> they're definitely still a thing sadly
00:06:28 <Axman6> I frequently find it using 6GB+ on our largest project
00:06:49 <fragamus> Hi I am away from my computer using my phone but I wonder if someone could run kmett’s expr.hs example from recursion schemes and post the output as a gist
00:16:27 <fragamus> Hi I’m back
00:17:03 <fragamus> Was there a gist posted in response perchance
00:18:19 <Axman6> There was not
00:18:26 <fragamus> Ok
00:21:14 <fragamus> Is there a website where I can run that code
00:30:48 <akr> is there some more general thing I can use to get a function `Maybe a -> Maybe b -> Maybe (a, b)`?
00:30:55 <akr> kinda like the dual to Applicative
00:31:08 <akr> ALternative*
00:33:16 <bassjacob> akr do you specifically mean something general for `liftA2 (,)` ?
00:33:34 <akr> bassjacob: yeah I just realized I can use that
00:33:45 <akr> is there something different / better?
00:34:02 <akr> with fancy infix syntax ideally :)
00:35:30 <Rembane> (<,>) = liftA2 (,)
00:35:59 <Rembane> Or, of course: (,) <$> a <*> b 
00:36:41 <Axman6> sadly (<,>) is an invalid operator name :(
00:37:16 <maerwald> :t (.!.)
00:37:18 <lambdabot> error:
00:37:18 <lambdabot>     • Variable not in scope: .!.
00:37:18 <lambdabot>     • Perhaps you meant one of these:
00:37:35 <akr> also, that <,> would not scale to higher arities
00:38:12 <Axman6>  either will any of the other options though
00:38:17 <Axman6> neither*
00:39:55 <akr> > (,,) <$> (Just 6) <*> (Just 7) <*> (Just 8)
00:39:57 <lambdabot>  Just (6,7,8)
00:40:58 <dminuoso> akr: There is a way to write a generic liftAn.
00:41:51 <akr> dminuoso: but it won't give us infix syntax, no?
00:42:46 <dminuoso> akr: Oh you mean something that automatically scales like `(Just 1) <,> (Just 2) <,> (Just 3)`?
00:43:11 <akr> yeah
00:43:21 <[exa]> you can overload <,> to provide all possibilities
00:44:10 <akr> hm, interesting
00:44:28 <dminuoso> akr: That's an interesting challenge.
00:44:46 <[exa]> not quite sure it will be easy though
00:45:08 <Rembane> What about monoids, are they useful here?
00:46:24 <[exa]> monoids have slightly harsh type restrictions
00:46:45 <Rembane> Oh. 
00:46:54 <Rembane> The Monoid is a harsh mistress. 
00:47:06 <dminuoso> I guess the problem is that the monoid in question only holds up to isomorphism.
00:47:32 <Maxdamantus> `mappend` expects its inputs and its output to all have the same type.
00:49:12 <dminuoso> akr: Oh wait I guess there is a way.
00:49:40 <dminuoso> % class Functor f => Monoidal f where <,> :: f a -> f b -> f (a, b); unit :: f ()
00:49:40 <yahb> dminuoso: ; <interactive>:2:37: error: parse error on input `<'
00:49:47 <dminuoso> % class Functor f => Monoidal f where (<,>) :: f a -> f b -> f (a, b); unit :: f ()
00:49:47 <yahb> dminuoso: ; <interactive>:3:39: error: parse error on input `,'
00:49:57 <dminuoso> % class Functor f => Monoidal f where (<.>) :: f a -> f b -> f (a, b); unit :: f ()
00:49:57 <yahb> dminuoso: 
00:50:04 <dminuoso> akr: ^- this is in fact isomorphic to Applicative.
00:50:23 <akr> oh!
00:50:24 <dminuoso> And in many ways its a more intuitive/natural way to think about what Applicative really means.
00:50:38 <akr> interesting
00:51:32 <dminuoso> akr: Do note that the monoid in question here satisfies its laws up to isomorphism. :)
00:52:21 <dminuoso> So `(a <.> b) <.> c ~= a <.> (b <.> c)` and `f <.> unit ~= f` and `unit <.> f ~= f`
00:52:46 <dminuoso> akr: Arent these laws nice and clean? They are equivalent to the Applicative laws.
00:52:58 <akr> yeah looks pretty good
00:53:01 <akr> I also found it in a library now https://hackage.haskell.org/package/invertible-0.2.0.5/docs/Control-Invertible-Monoidal.html#t:Monoidal
00:53:03 <dminuoso> (The applicative laws is what you get if you translate these monoid laws through the isomorphism)
00:54:33 <akr> thank you everyone :)
00:56:01 <dminuoso> I kind of wish Monoidal was in base at times. :)
00:57:47 <dminuoso> Curious, the haddock page suggests its not a true isomorphism, as there exist some Monoidal instances that cant be written as Applicative.
01:46:25 <ruffy_> I need to do some project using machine learning with tensorflow......and the problem is that I am really not amused about using python......do we have a good ML library for building a reasonable efficient and fast face recognition DNN?
01:47:19 <ruffy_> For this I would also need some low level functions to modify and work with individual neurons on specific layers
01:47:58 <bollu> there are tensorflow bindings in haskell. There's also hasktorch
01:50:36 <ruffy_> Yeah I have seen the bindings, but do they provide enough funtionality for something like I have explained above? I have never done something with ML nor tensorflow, that's why I thought it's maybe better to discuss first what the best option would be
01:53:40 <dminuoso> jle`: Fancy! I think I have spotted the connection between Applicative and Monad. The Yoneda lemma strikes again.
02:23:57 <dminuoso> jle`: Yoneda lemma gives us ⌜FA ~= nat(Hom(A,B), FB)⌝, as witnessed by ⌜(`fmap` g)⌝ in Haskell, so there exists a morphism FA -> B^A -> FB, which we can specialize as `FA -> F(B^A) -> FFB`. If we assume F to be a monad, it's equipped with μ : FFB -> FB, so we can construct a natural transformation `FA -> F(B^A) -> FB`.
02:24:09 <dminuoso> Flipping the arguments around you end up with F(B^A) -> FA -> FB
02:24:15 <dminuoso> % :t (<*>)
02:24:15 <yahb> dminuoso: Applicative f => f (a -> b) -> f a -> f b
02:31:37 <orzo_> Is there an idomatic way to add a static (no random data) test to an otherwise smoke-tested QuickCheck test-suite?
02:32:52 <merijn> orzo_: You'd usually use one of the various test frameworks to tie different types of tests together
02:33:01 * Ariakenom looks up smoke test
02:33:11 <merijn> orzo_: (since literally all of them support quickcheck)
02:33:33 <merijn> Ariakenom: "smoke test" just means "turn it on, see if there's smoke" ;)
02:33:57 <orzo_> yeah, i might not be using the word right, i just mean random generated test data
02:34:00 <merijn> Ariakenom: So they don't really test much, if anything, besides "is this environment remotely sane?"
02:34:43 <merijn> orzo_: Anyway tasty (my preference) and hspec are both libraries for tying various tests/testing libraries together (i.e. combining unit tests, quickcheck and golden tests)
02:34:55 <orzo_> hm
02:35:30 <Rembane> orzo_: Here's an example of me using hspec: https://github.com/Rembane/dbot/blob/master/test/Spec.hs
02:35:33 <orzo_> rather than learning a framework like that, i'm tempted to just write a quickcheck property that has no input
02:35:58 <merijn> orzo_: tbh, the name framework shouldn't be taken to mean "big complicated API"
02:36:16 <Ariakenom> merijn: Thanks for the etymology, I was about to look it up because it wasn't on wiki
02:36:32 <merijn> orzo_: They just provide a unified API for grouping/running tests that other libraries can then plug into
02:37:06 <merijn> orzo_: So you have, for example tasty-quickcheck that defines a few wrappers to turn quickcheck properties into tasty tests so you can group them
02:38:19 <merijn> Rembane: That code is using tasty... >.>
02:38:40 <merijn> Rembane: Maybe you're confusing hspec and HUnit?
02:40:06 <Rembane> merijn: I probably am, I switch between them. :D
02:40:28 <Rembane> merijn: Or it was a typo where I meant to write HUnit but wrote hspec instead.
02:40:53 <merijn> Rembane: hspec is the "pseudo-DSL" alternative to tasty, whereas HUnit is for writing unit tests :)
02:42:08 <Rembane> merijn: Got it! :D
03:15:12 <asheshambasta> http://hackage.haskell.org/package/amazonka-1.6.1/docs/Network-AWS.html#v:unsafeChunkedBody -- using this, what's the best way to ensure the correct ChunkSize is sent? I'm getting a response from another host that returns the `ConduitM ...` stream of bytes. Now I'd like to upload this response body as an S3 object. 
03:25:53 <asheshambasta> sorry, not really a haskell question. 
03:30:48 <maerwald> documentation indicates that you just set something and that it might not be enforced anyway
03:30:56 <maerwald> seems more like a performance optimisation
03:39:52 <dminuoso> asheshambasta: How do you determine what the correct ChunkSize is?
03:41:22 <dminuoso> asheshambasta: This is a rhetorical question, by the way.
04:48:59 <saurabhnanda> I'm trying to do make my app's main ReaderT monad polymorphic in the role/permission/auth that is required to run the underling action/s. This is a small gist that demonstrates what I'm trying. Why is the compiler tripping-up on the `auth` type-variable -- https://gist.github.com/saurabhnanda/04d18e93f0ded52c9055f8782b7f1e56#file-try2-hs  Error -- https://gist.github.com/saurabhnanda/04d18e93f0ded52c9055f8782b7f1e56#file-error
04:51:11 <merijn> saurabhnanda: You're shadowing the auth from the class declaration
04:51:18 <dminuoso> saurabhnanda: The scoping of `auth` is incorrect, leading to incorrect quantification.
04:51:43 <saurabhnanda> how do I tell the compiler that it's the same `auth` throughout?
04:51:58 <dminuoso> Presumably like this
04:52:01 <dminuoso> % instance forall a. Functor (Foo a)
04:52:01 <yahb> dminuoso: ; <interactive>:12:10: warning: [-Wmissing-methods]; * No explicit implementation for; `fmap'; * In the instance declaration for `Functor (Foo a)'
04:52:12 <dminuoso> (And ScopedTypeVariables of course)
04:52:12 <merijn> saurabhnanda: Delete the forall? :p
04:52:22 <dminuoso> Oh. Does that work merijn?
04:52:26 <merijn> dminuoso: The instance declaration should've already brought auth in scope
04:52:32 <saurabhnanda> put the forall in the instance declaration?
04:52:44 <dminuoso> merijn: Ah right, it should. Ive been using this feature for so long without thinking baout it..
04:52:53 <merijn> saurabhnanda: No, don't have a forall
04:52:56 <dminuoso> saurabhnanda: No, for instances it does the right thing (tm) already.
04:53:33 <saurabhnanda> okay, so if that's not the problem, how else can I do this?
04:53:59 <saurabhnanda> does my HasEnv class need to become a multi-param type-class?
04:54:37 <merijn> saurabhnanda: huh?
04:54:59 <dminuoso> saurabhnanda: Are you sure you want that method to have the type getEnv :: m (Env auth)
04:55:13 <Lears> You might want a fundep or as associated type family telling you what auth is, given m.
04:55:40 <merijn> saurabhnanda: What about it doesn't work if you delete the forall?
04:55:45 <saurabhnanda> dminuoso: why would `getEnv :: m (Env auth)` be a problem?
04:55:58 <saurabhnanda> merijn: different error
04:55:58 <merijn> oh, wait, yes
04:56:07 <merijn> dminuoso is right
04:56:32 <Lears> That's `forall auth. m (Env auth)`, meaning the caller decides independent of m.
04:56:34 <merijn> saurabhnanda: The return value of your HasEnv claims to be able to return *any* auth
04:56:39 <saurabhnanda> merijn: actually same error. just type-variable names are different
04:56:49 <merijn> saurabhnanda: But in reality you can only return *one specific* Env
04:57:23 <saurabhnanda> merijn: and that Env depends on the `m` -- because both share the same type-variable `auth`?
04:57:48 <merijn> saurabhnanda: There are no things sharing type variables in your code, that's the problem
04:58:07 <dminuoso> merijn: I find that the scoping/quantification of type variables is often very unclear in Haskell in the sense that its not very visible. 
04:58:07 <merijn> saurabhnanda: The "auth" in your class definition and your instance definition are completely unrelated
04:58:21 <dminuoso> You have to learn whether a given type variable is a skolem or quantified just by practice...
04:58:34 <saurabhnanda> so, conceptually that's the problem, right? how do I make `m` and `Env auth` "share" the same `auth`?
04:58:36 <merijn> dminuoso: Or just avoid those things ;)
04:58:51 <dminuoso> merijn: Hard to avoid unless you just never use typeclasses. ;)
04:58:55 <merijn> saurabhnanda: parameterise both over auth
04:59:14 <merijn> dminuoso: I hardly ever use my own classes and don't really run into those things when I do, tbh
04:59:35 <dminuoso> merijn: I mean `class ... Monad m where (>>=) :: m a -> ...` let's just stare at this real quick. We just give handwaving introductions into type variables to beginners usually.
04:59:41 <merijn> dminuoso: Mostly the things you mention are issues of using ExistentialQuantification (or GADTs using existential)
04:59:47 <dminuoso> It's not very clear that `m` and `a` are very different.
04:59:54 <saurabhnanda> merijn: would it make the HasEnv class something like -- class (MonadIO (m auth)) => HasEnv (m auth) where
05:00:07 <merijn> saurabhnanda: For example, yes
05:00:32 <asheshambasta> dminuoso: sorry was AFK; well currently I don't. 
05:00:36 <saurabhnanda> merijn: let me try, but I have a feeling it won't work...
05:00:52 <merijn> saurabhnanda: I'm not 100% sure, either, no :p
05:01:21 <asheshambasta> dminuoso: I just take the streaming response from one request and plug into `AWS.unsafeChunkedBody`; which unsurprisingly failed. 
05:01:39 <asheshambasta> dminuoso: the other option could be buffering the response into a temp. file and then streaming the file back up to S3. 
05:02:38 <saurabhnanda> unable to parse this -- class (Monad (m auth), MonadIO (m auth)) => HasEnv (m auth) where 
05:02:54 <saurabhnanda> Unexpected type ‘m auth’
05:03:49 <saurabhnanda> even this is not working -- class (Monad m, MonadIO m, m ~ (m1 auth)) => HasEnv m where
05:04:00 <dminuoso> asheshambasta: So know about the correct chunk size and enforce it.
05:05:16 <saurabhnanda> I think I need fun-deps
05:05:32 <saurabhnanda> `m` and `auth` are intertwined -- one decides the other
05:05:58 <merijn> Alternatively, just don't typeclass HasEnv? >.>
05:06:11 <merijn> Seems rather gratuitous anyway?
05:06:20 <asheshambasta> dminuoso: I'm not sure if there is a way to enforce the chunk size; I'm wondering if there's a way to coalesce chunks with Conduit? 
05:07:02 <asheshambasta> dminuoso: there's a good chance the chunk sizes aren't constant per request; especially because this is a host I don't control. 
05:07:23 <merijn> asheshambasta: Sure, there's rechunking combinators somewhere for conduit
05:07:30 <merijn> Probably in conduit-extra or something
05:07:40 <saurabhnanda> okay - fundeps worked
05:07:42 <asheshambasta> merijn: checking that, thanks 
05:07:48 <saurabhnanda> but I don't know what I'm doing now
05:08:01 <merijn> saurabhnanda: I mean, is there any particular reason this should be a typeclass?
05:08:11 <saurabhnanda> random type-level incantations. What if it's the wrong spell? And the simon's start haunting me...
05:08:21 <saurabhnanda> merijn: testing
05:08:53 <merijn> saurabhnanda: Why does that need a class?
05:09:05 <saurabhnanda> merijn: thinking...
05:09:29 <merijn> Anything you can do with a typeclass can (by definition) be faked by a record + some smart constructors
05:09:37 <asheshambasta> merijn: something on the lines of http://hackage.haskell.org/package/conduit-extra-1.3.3/docs/Data-Conduit-Binary.html#v:take 
05:11:28 <geekosaur> asheshambasta, if this is TCP, there's no chunk size
05:11:43 <geekosaur> unless you enforce one via a protocol with appropriate framing
05:16:33 <asheshambasta> geekosaur: yeah, that's what I'm concluding as well. Its better to go the rechunking route anyway. 
05:54:50 <asheshambasta>  https://stackoverflow.com/questions/25428065/rechunk-a-conduit-into-larger-chunks-using-combinators -- this works really welll. 
05:55:05 <asheshambasta> its almost trivial. 
06:30:45 <statusfailed> how does the containers library use deepseq?
06:33:33 <statusfailed> is it just for instances of NFData?
06:41:56 <lyxia> statusfailed: I would assume so.
06:57:40 <arrowd> Is there a function with type Text->Text that expands escape codes into characters? That is, for "asd\nasd" it would produce "asd\10asd"?
06:58:11 <merijn> Define escape codes and what characters they should expand in? :p
06:58:34 <arrowd> "\n" -> '\10'
07:00:33 <merijn> That's a single example, not even to specify what you mean.
07:00:38 <merijn> > '\10'
07:00:41 <lambdabot>  '\n'
07:01:07 <merijn> > text ['\10']
07:01:10 <lambdabot>  Terminated
07:01:15 <merijn> Oh! Fun :D
07:01:47 <arrowd> > :t text
07:01:49 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
07:01:55 <merijn> :t text
07:01:56 <lambdabot> String -> Doc
07:02:24 <merijn> Text is for making it actually show text directly, rather than using show
07:02:29 <merijn> > "☃"
07:02:32 <lambdabot>  "\9731"
07:02:34 <merijn> > text "☃"
07:02:39 <lambdabot>  ☃
07:04:47 <FedererChien> Hello everyone;( , my ghci can't find the file location of vim
07:05:10 <saml> why not
07:10:36 <FedererChien> Failed, no load module
07:11:01 <power-fungus> Can anyone tell me if there is a replacement for `stack path --local-bin` in `cabal`
07:13:24 <arrowd> power-fungus: Does `stack exec -- echo $PATH` suit you?
07:15:24 <geekosaur> n, they want to k bow how to ask cabal-install that question
07:15:52 <merijn> power-fungus: What does that do?
07:16:18 <geekosaur> FedererChien, afaik there is no Haskell module named "vim". what are you actually trying to do?
07:16:35 <fendor> merijn, it gives you the path to where `stack install` installs its binaries
07:16:41 <geekosaur> cabal's default install dir is ~/.cabal/bin
07:16:56 <geekosaur> dunno if you can sk it programmatically or just examine ~/.cabal/config
07:17:32 <fendor> geekosaur, on windows, it might be somewhere else, right?
07:19:01 <FedererChien> Thank you, I  try
07:19:29 <geekosaur> hm. pity cabal user-config doesn't have a print subcommand
07:19:37 <geekosaur> at least in the version I have installed
07:19:40 <power-fungus> I am looking for a solution without stack - there exist crybabies which resent any solution including stack.
07:19:55 <power-fungus> I want to find the directory cabal installs executables via `v2-install`
07:21:56 <geekosaur> FedererChien, you try _what_????
07:23:28 <geekosaur> I asked what you *had* tried, I did not give you something to try. because asking for ghci to load nonexistent Haskell source for the C program vim doesn't make a lot of sense. what are you trying to do?
07:29:18 <FedererChien> ok, I am trying to teach.
07:29:19 <FedererChien> doubleMe x = x   x
07:31:09 <geekosaur> so you want to run the editor from within ghci? that's :e
07:32:10 <FedererChien> yes
07:33:15 <geekosaur> you might instead want a way to use ghci from an editor; I don't know what's out there for vim though
07:34:51 <FedererChien> Yes, I want a way to use ghci from the editor
07:37:18 <tdammers> judging by my previous experiences with embedding repls into vim, I would say that anything beyond :!ghci is going to be too brittle to be worth it
07:38:46 <[exa]> FedererChien: kindof suggest going with emacs for that kind of stuff (they have nice Agda support also)
07:42:46 <tdammers> I love me my vim, but indeed as far as embedding fancy interactive stuff into your editor goes, emacs is where it's at
07:43:40 <Jinna> mac10688: okay good, I agree. It seems that JWT tokens are just base64-encoded but never encrypted.
07:43:49 <FedererChien> =* 
08:13:12 <tabaqui> monad-mock wasn't updated almost for two years
08:13:21 <tabaqui> and it is not presented on stackage
08:13:29 <tabaqui> do you know some fine replacement?
08:14:37 <tabaqui> it is not very complicated to implement by oneself, but probably this approach has further improvements
08:18:46 <tabaqui> yeah, and it doesn't solve the problem of forkIO/catch and similar functions "m a -> m b"
08:22:03 <zzz> i'm trying to grasp the concepts of anamorphism and catamorphism. if i understand correctly, an example of an instance of a catamorphism in Haskell is a fold because folds map functors into an underlying algebraic type. is this correct?
08:22:30 <sarahzrf> zzz: what do you mean by "folds map functors into an underlying algebraic type"?
08:22:56 <fendor> do i need to clean the cabal store from time to time? or does it make sense to clean it from time to time?
08:24:31 <zzz> sarahzrf: I mean something like Functor f => f a -> a
08:24:46 <sarahzrf> zzz: well, "a" need not be algebraic there
08:26:18 <zzz> sarahzrf: from my understanding, that depends on what the category you are considering is, right? if we're considering the category of haskell types, then you are correct, but that can be generalized. Is this a correct statement?
08:27:02 <sarahzrf> zzz: i don't think that statement really makes sense
08:28:01 <zzz> oh ok. I'm category theory illeterate. so does that mean that a function from Maybe Int -> Int is not a catamorphism?
08:28:09 <sarahzrf> nope!
08:28:15 <sarahzrf> that's what you'd call a "Maybe-algebra"
08:31:17 <zzz> i see
08:33:02 <josiah_sama> It's been a little while since I've researched this.  Has Haskell progressed much since 2015 in the way of libraries for interacting with SQL databases (especially ones that help to decouple from the particular SQL database being used, such as libraries like Python's SQLAlchemy do?)
08:33:53 <d34df00d> Hi!
08:34:06 <josiah_sama> I'd look around on Google, but on these sorts of questions, I've found that typically Google search and online blogs can be deceptive and the best source of truth is just to ask the community
08:34:09 <d34df00d> Let's say I'm writing a parser for adblock rules.
08:34:28 <d34df00d> Those rules can have options, and some options can only be applied to rules that are exceptions.
08:34:45 <d34df00d> So I have data RuleType = Normal | Exception, and I parametrize my Rule record with its type.
08:35:21 <Boarders> if I run my application with `stack exec myApp`, does anyone know how I use RTS options?
08:35:38 <d34df00d> Then currently I have an enumeration for the various options of the form `data FilterOpt ruleTys where FScript :: FilterOpt '[ 'Normal, 'Exception ]; FDocument :: FilterOpt '[ 'Exception ]`
08:35:49 <d34df00d> Is it a reasonable type-level representation of the domain constraints, or can I do better?
08:36:05 <geekosaur> stack exec -- myApp +RTS ...
08:36:20 <geekosaur> the "--" stops stack from eating the RTS opts or other program-intended options
08:36:29 <zzz> sarahzrf: I meant to say "is", not "is not". thanks for your help. Is there a good resource I should look to if I want to start learning more about this?
08:36:52 <sarahzrf> zzz: im not sure off the top of my head
08:36:55 <sarahzrf> i can explain some stuff tho!
08:37:06 <Boarders> geekosaur: thanks, I always get this wrong
08:38:22 <sarahzrf> zzz: in general, if F is an endofunctor C -> C and A is an object of C, then any morphism f : F A -> A is called an "F-algebra"
08:40:13 <zzz> sarahzrf: well my goal for now is to be able to parse some of the stuff I'm reading about functional programming that refer to category theory concepts, and I'm trying to understand the relationship between cat theory and functional programming
08:40:59 <zzz> ok
08:41:14 <zzz> what do we call A ?
08:41:27 <sarahzrf> umm, i guess you could call it the "carrier" of the algebra?
08:42:42 <zzz> ok so a carrier is something like a set of values of a specific type?
08:43:20 <tabaqui> % :t 1
08:43:20 <yahb> tabaqui: Num p => p
08:43:27 <sarahzrf> "carrier" is the term for A's supporting role in f being an F-algebra
08:43:30 <tabaqui> % :t unsafePerformIO . try . evaluate
08:43:31 <yahb> tabaqui: Exception e => a -> Either e a
08:43:31 <sarahzrf> it doesn't refer to what kind of object a is
08:43:33 <sarahzrf> *A
08:43:41 <tabaqui> what do you think?
08:44:09 <sarahzrf> the definition just given can apply in any category, so A could be just about anything
08:45:35 <Boarders> You could call A the underlying object of the F-algebra
08:45:58 <Lears> zzz: Honestly, you can just disregard any statements about functional programming that assume knowledge of category theory. Programming in Haskell only involves CT if you really want it to.
08:46:14 <sarahzrf> ^
08:46:44 <sarahzrf> zzz: category theory is fascinating, but i personally don't think you can really appreciate it fully unless you learn math seriously
08:47:07 <Boarders> I have a bug `pcg: Data.Vector.Mutable: uninitialised elementCallStack (from HasCallStack):  error, called at ./Data/Vector/Mutable.hs:188:17 in vector-0.12.0.2-JMWQggIZox12SqdnR4PU2C:Data.Vector.Mutable`
08:47:22 <Boarders> The bug does not seem to appear if I build with profiling even if I turn on -O2
08:47:29 <Boarders> any ideas what could possibly cause that?
08:47:38 <zzz> well, where should I start? :)
08:48:25 <Boarders> zzz: you could start here: https://www.goodreads.com/book/show/1511125.Conceptual_Mathematics
08:49:23 <tabaqui> zzz: https://en.wikipedia.org/wiki/Categories_for_the_Working_Mathematician
08:50:08 <zzz> thank you!
08:50:45 <sarahzrf> tabaqui: i wouldn't do that :P
08:50:57 <sarahzrf> zzz: don't follow tabaqui's link unless you're a working mathematician, imo
08:51:33 <tabaqui> sarahzrf: I wouldn't say this book is hard to read
08:52:18 <Boarders> tabaqui: I would, have you actually read it all?
08:52:28 <sarahzrf> zzz: what's your math background?
08:52:30 <tabaqui> Boarders: not till the end
08:53:01 <tabaqui> well, and I have master degree in mathematics actually :)
08:53:43 <tabaqui> but anyway the book is not really tough, as I think
08:54:04 <d34df00d> Let's say I have `class Choose (p :: Bool) where choose :: Choice p` and instances for both 'True and 'False.  Yet when I write `choose' :: forall (p :: Bool). Choice p; choose' = choose` the typechecker complains about no instance of Choose for p.
08:54:20 <d34df00d> Is there a way to tell it that both instances for 'True and 'False "cover the whole space"?
08:54:26 <d34df00d> Or perhaps express this differently?
08:54:35 <sarahzrf> tabaqui: if zzz does not have a masters in math, they may have a different opinion of it
08:55:02 <sarahzrf> d34df00d: this is not something that haskell is particularly good at, at the moment, iirc
08:55:44 <sarahzrf> d34df00d: actually, you shouldn't even expect this to work
08:55:48 <tabaqui> I've recently started to read "The Art of Computer Programming" and it is much harder
08:55:50 <sarahzrf> think about the runtime behavior - how should this compile?
08:56:15 <d34df00d> sarahzrf: I know `p` at compile time since it's a type (sorta), so why not?
08:56:39 <d34df00d> Especially given that `type Choice p = Either (p :~: 'False) (p :~: 'True)`
08:57:27 <sarahzrf> d34df00d: well, think about what code should be emitted for the "choose" function
08:57:29 <sarahzrf> it takes no arguments, right?
08:57:46 <sarahzrf> because it doesn't take any value inputs - only a type parameter, which gets erased - and it takes no typeclass dictionaries
08:57:50 <sarahzrf> so it must be constant
08:58:04 <d34df00d> If I were designing a language I probably wouldn't erase the type at this point.
08:58:14 <geekosaur> typeclasses are open, afaik there's no way to close them so no way to force it to see that p is complete. closed type families are intended for this kind of use case
08:58:20 <d34df00d> Or I'd create two different functions, one for the context where p ~ True, another one for p ~ False.
08:58:38 <d34df00d> geekosaur: I cannot possibly have term-level functions in type families can I?
08:58:46 <sarahzrf> d34df00d: haskell doesn't really have a way to enforce that a function can only be used at sites where a type is known in the program text, i think
08:58:54 <sarahzrf> modules are generally designed to always be independently compilable
08:59:08 <d34df00d> Uh. Now I'm really sure I'm having XY problem.
08:59:16 <d34df00d> But X is a bit longer to explain...
09:00:21 <sarahzrf> lol
09:00:22 <zzz> I dont have a formal education in maths. I have a master's in multimedia design and I love maths so I try to educate myself as much as I can. You can say it's a hobby I guess, for a lack of a better word.
09:00:23 <geekosaur> this is starting to sound like it wants singletons
09:00:36 <d34df00d> geekosaur: nope nope NOPE
09:00:44 <sarahzrf> d34df00d: i've run into this problem myself while fucking around, lol
09:00:44 <d34df00d> Though I already import Data.Singletons.Prelude.List
09:00:52 <geekosaur> (which are admittedly a workaround, for what ghc can't do as yet)
09:01:13 <d34df00d> Ok, so pardon me for a couple of links to github then, but I'd be really glad to discuss the design.
09:01:14 <sarahzrf> d34df00d: ive learned to, whenever i start to get lost in this stuff, immediately stop and think about whether my code has sensible runtime behavior
09:01:21 <sarahzrf> and if not: add typeclass constraints
09:01:46 <sarahzrf> that, or GADT arguments
09:02:23 <d34df00d> So, I have this GADT: https://github.com/0xd34df00d/monoblock/blob/gadts_yay/src/Web/Adblock/Rule.hs#L23
09:02:30 <d34df00d> Which is wrapped into this proof-carrying GADT: https://github.com/0xd34df00d/monoblock/blob/gadts_yay/src/Web/Adblock/Rule.hs#L50
09:02:39 <d34df00d> Which is a member of this thingie: https://github.com/0xd34df00d/monoblock/blob/gadts_yay/src/Web/Adblock/Rule.hs#L56
09:03:15 <d34df00d> And then here: https://github.com/0xd34df00d/monoblock/blob/gadts_yay/src/Web/Adblock/Parser.hs#L66-L69 I sorta want the behaviour of "if ruleTy from line 54 is in the list of supportedTys, then all is good, otherwise produce a parse error".
09:04:03 <d34df00d> I could sure resort to typeOf and TypeReps and all that, but that just feels unnatural and pythonish and I'd like to avoid that.
09:05:34 <sarahzrf> d34df00d: one lesson i've learned is that sometimes you just have to write python in haskell to save yourself from writing idris in haskell
09:05:41 <sarahzrf> it hurts but it's true
09:06:06 <sarahzrf> why are you doing all of this at the type level anyway :\
09:06:28 <d34df00d> Cause I want proofs!
09:06:32 <d34df00d> Dunno really.
09:06:35 <d34df00d> Showing off.
09:07:04 <sarahzrf> go write idris then >:P
09:07:15 <d34df00d> I have fizzbuzz in idris.
09:07:18 <d34df00d> It took 500 loc.
09:07:31 <d34df00d> But I've built my own naturals and provably terminating division.
09:07:39 <d34df00d> Was fun btw.
09:07:52 <sarahzrf> fyi, im being a huge hypocrite here ^_^
09:09:22 <d34df00d> Yeah, I could just stop trying to be clever and have a simple Haskell98 ADT with the filter options and then invertibleOpts :: [FilterOptions] and then exceptionOnlyOpts :: [FilterOptions] and then just do runtime `elem` checks.
09:10:05 <d34df00d> Dunno, getting the job done vs learning something fun. Though admittedly learning writing dependently typed code in haskell is not a skill that'd be relevant in the long run.
09:10:07 <d34df00d> Hopefully.
09:10:31 <d34df00d> s/in haskell/in current singletonish haskell/
09:11:25 <Lears> Sometimes dynamic typing and strong static typing actully go really well together to give you both ergonomics and safety. Like the HList I've been working with recently that has safe lookup-by-type. No crazy GADT indices to construct, pointless Maybes to unwrap or fragile positions to break after an insertion. Just good clean access.
09:13:07 <sarahzrf> d34df00d: you may also be able to just have different FilterOptions types and then have a sum type
09:13:19 <sarahzrf> er, rather, make FilterOptions a sum type of invertible & non invertible ones
09:13:23 <sarahzrf> well, that's kind of a pain
09:13:56 <d34df00d> Yeah, cause I have invertible vs non-invertible dimension and then exceptions-only vs all rules dimension.
09:14:01 <d34df00d> So it's already four combinations.
09:14:37 <sm> I wish https://www.borgbackup.org was built in haskell.
09:15:27 <Rembane> sm: Why? 
09:15:33 <sm> although it's really good, it's really disconcerting to see random python tracebacks from normal usage
09:16:09 <sm> I'd have more faith in a haskell version 
09:16:20 <Rembane> I haven't gotten any so far, but maybe you have a more interesting use case than I have.
09:17:12 <sm> currently I'm just trying to use borg recreate, and KeyError 'data' for no obvious reason
09:18:07 <sm> brings back my former life as a pythonista !
09:18:40 <Rembane> That sounds like a nerve wracking experience. 
09:19:22 <sm> well I'll get over it :) But backups are already stressful, ideally the tool would be bulletproof
09:20:04 <Rembane> Oh yes. If you have the time and courage, create an issue on the borgbackup bugtracker.
09:20:14 <Rembane> courage = energy, common typo. 
09:20:34 <sm> +1, I might
09:20:38 <solonarv> fendor: only to save disk space, or if you somehow managed to corrupt the store (perhaps your computer shut down gracelessly while building something)
09:24:00 <d34df00d> Lol, it typechecks.
09:24:06 <d34df00d> https://bpaste.net/show/89ddfcf1896b
09:24:12 <d34df00d> sarahzrf: ^ look how ugly it is.
09:29:15 <devalot> I need to build large look-up tables and store them so they can be used at run time.  It would be easy to generate a hs file that contained something like HashMap.fromList ... but I have a feeling there's a better way.  Any ideas?
09:30:26 <sarahzrf> d34df00d: lmao
09:34:06 <d34df00d>     • Could not deduce (Typeable (Elem ruleTy supportedTys)) from the context: forall (supportedTys :: [RuleType]). Typeable (Elem ruleTy supportedTys)
09:34:08 <d34df00d> wat
09:34:11 <d34df00d> Why?
09:37:28 <sm> Rembane: here I go, https://github.com/borgbackup/borg/issues/4651
09:37:39 <isovector1> any hackage trustees in the house?
09:39:28 <sarahzrf> d34df00d: well, how would it deduce it
09:39:42 <sarahzrf> d34df00d: try thinking about runtime behavior, as usual ;)
09:40:43 <d34df00d> I'm not sure I have the mental model yet to reason about runtime behaviour of QuantifiedConstraints.
09:40:49 <sarahzrf> hahahaha
09:40:58 <sarahzrf> oh shit i misread
09:41:31 <sarahzrf> okay yeah nvm i have no idea how that owrks
09:41:33 <sarahzrf> lmao
10:10:51 <solonarv> devalot: that's a pretty reasonable approach. you could also try embedding an external file into the binary (using something like 'file-embed') and load it at program start
10:26:57 <Edward23> Anyone know how to disambiguate a parametric type when using DuplicateRecordFields. Minimal example here https://gist.github.com/edwardb96/0821026af3dc5e3c4c10e347d27fad05 ?
10:27:46 <devalot> solonarv: I was thinking about the binary approach, but I can't find any Map types that support serialization. 
10:30:48 <xaltonon[m]> Hello again! I'm having a really hard time interpreting errors when using the `singletons` library: specifically, I'm not sure how to read errors when they involve "Let" type families, since they're hidden and I can't expand them with :info.
10:30:51 <xaltonon[m]> My code is here: http://ix.io/1N1A/hs, and I'm getting this error: http://ix.io/1N1B
10:30:56 <xaltonon[m]> The sorting is correct (with unsafeCoerce it works fine), but I can't quite get the typechecker to accept it.
10:33:11 <xaltonon[m]> From what I can tell from the singletons library source, the `Sort` type family has this implementation: `sort = foldr insert []`, which as far as I can tell should be structurally identical to what I have here?
10:42:49 <d34df00d> Edward23: try instead (thing :: Foo a -> String)
10:42:55 <geekosaur> I suspect you're hitting oen of those places where singletons's hack to work around Haskell not ding that has shortcomings
10:42:56 <d34df00d> Before that, try enabling DisambiguateRecordFields.
10:44:48 <geekosaur> er, mine was for xaltonon[m]
10:45:27 <xaltonon[m]> My problem is that I just have no way of seeing what's "inside" of `Let6989586621679940989Go`
10:45:47 <xaltonon[m]> It isn't exported, and it's something generated by TH so I have no real way of expanding its definition
10:48:09 <solonarv> devalot: eh? cereal and binary both support Map, and I would expect most other serialization libraries to be the same
10:48:32 <Edward23> d34df00d DisambiguateRecordFields didn't work but annotating thing instead of f worked. Thanks
10:50:39 <devalot> solonarv: I must have missed that.  Thanks for the help.
10:52:42 <solonarv> there's no serialization format privileged by the language or the compiler
10:52:44 <geekosaur> yes
10:53:16 <solonarv> so if you look at the documentation for (say) Map and don't see 'instance blah => Serialize (Map k v)' that doesn't actually mean anything
10:55:19 <devalot> solonarv: Totally makes sense.  I blanked for a minute but otherwise know how classes work.  Duh!
10:56:59 <Rembane> sm: Sweet! That discussion has the potential to become really interesting.
10:57:57 <geekosaur> xaltonon[m], https://blog.jle.im/entry/introduction-to-singletons-4.html search fr "The Problem"
10:59:16 <geekosaur> hm, maybe not the same issue
10:59:22 <geekosaur> I think they do hit that one witht he generated symbol though
11:02:43 <geekosaur> right,, not that one, it's noted as a bug that requires an upstream change to fix
11:04:45 <geekosaur> https://github.com/goldfirere/singletons/issues/339
11:04:49 <geekosaur> that one
11:05:30 <xaltonon[m]> Oh, that's definitely related! Thanks, I'll give this a read
11:05:30 <geekosaur> yu'll note their example is more or less the same problem you hit
11:09:09 <xaltonon[m]> Well, having access to the complete unfoldings of functions you want to prove theorems about is a usual "problem" with dependently typed programming, I just don't think GHCi is really well-equipped for it yet!
11:10:13 <geekosaur> right but the real problem is that there's a worker-wrapper transofrm going on behind your code's back (which is where Let<gensym>Go comes from)
11:11:56 <xaltonon[m]> You know what, I'm going to check out a local copy and remove the wrapper to see if that makes the type error more comprehensible
11:12:30 <xaltonon[m]> (Though ideally I'd like to be able to see the unfoldings of non-exported things in GHCi)
11:45:01 <xaltonon[m]> geekosaur: Well this is concerning. Unfolding the definition of `insertBy` to remove the foldr didn't clarify the type error, it fixed it...
11:45:30 <geekosaur> that would be what I'd expect
11:46:39 <xaltonon[m]> I don't understand it, maybe because I'm not very familiar with how singletons promotes recursion, but with/without foldr it should be structurally identical, right?
11:47:24 <geekosaur> structurally,, yes
11:47:58 <geekosaur> what you keep missing is that singletons is not promoting the original code. it is promoting code that ghc rewrote via a RULE pragma
11:48:33 <geekosaur> generally another RULEpragma un-rewrites it if needed before code generation, but that one doesn;t get a chance to fire when singletons is inspecting the result of the first
11:49:03 <geekosaur> so there is an extra function that is local, not exported or exportable
11:49:34 <geekosaur> and not introspectable. disable the rewrite and things work. read the issue I pointed you at, it goes into detail as to what's happening and why and what part ghc plays in it.
11:50:30 <geekosaur> (but disable the rewrite and normal folds, as opposed to promoted ones, generally get a lot slower; this is one of the major optimizations ghc does)
11:52:54 <Lears> d34df00d: https://gist.github.com/LSLeary/3c8e468e444bc928d188c1c5fadf1eee
12:31:18 <Boarders> Is there any way to debug Data.Vector.Mutable: uninitialised element without profiling?
12:31:30 <Boarders> If I build with profiling the error does not appear in my project
12:31:38 <Guest92818> Could anyone here explain the difference between Cabal & Stack & GHC?
12:31:54 <sclv> GHC is a compiler
12:32:04 <sclv> the other two are tools for building and developing packages that make use of the compiler
12:32:52 <sclv> you can use either of them but they provide different workflows. cabal chases down and solves dependencies. stack uses a fixed set ("stackage") of known-interacting dependencies
12:33:15 <merijn> Boarders: Grep for all functions that create uninitialised vectors? ;)
12:33:16 <Guest92818> Which one might be better for a newbie?
12:33:22 <Guest92818> Cabal or Stack?
12:33:36 <sclv> I personally use Cabal and think it works fine, with the v2 commands
12:34:12 <sclv> if you're just learning, then you might want to start without using external libraries and deps btw, just to learn how the language and tools work
12:34:16 <Guest92818> Alright. I thought I just read somewhere there is something called Cabal hell which is a situation Cabal might lead me into?
12:34:20 <sclv> in that case, you can just use ghc directly, and ghci
12:34:25 <sclv> Guest92818: the v2 commands solve that
12:34:34 <Boarders> merijn: none of my code is using mutable vectors any more :(
12:34:37 <sclv> "cabal hell" existed four years ago, not today
12:34:42 <Guest92818> Alright. So GHC alone will be fine for starters?
12:35:04 <sclv> yes, until you want to start using external packages. then you can create a project (either with cabal or stack) and give those packages as deps of the project
12:35:11 <merijn> cabal hell is even more than 4 years ago, that was when I was just starting haskell, so, like 2007-2008
12:35:45 <Uchu_98> Hello. I am going to start my Live show in a few minutes. I have 2 free vip invitations left (normally $14.99/30 minutes). Enter now if you are interested and write in the chat "Free Invite" ---> https://lur.us/rOWA6
12:36:21 <monochrom> Hell, even DLL hell is yesterdecade.
12:37:04 <Guest92818> So, I primarily come from a C++ background, in which our college pushed us to use OOP and OOP only. I never quite felt making classes for everything to be the right way. In my pursuits of alternatives, I found Functional Programming and in turn Haskell. But when I do read up about the immutability of data in FP, wouldn't you say it would be ineffic
12:37:05 <Guest92818> ient compared to an imperative language?
12:37:28 <josiah_sama> ^ can somebody delete that message since it's NSFW?
12:37:41 <merijn> josiah_sama: You can't delete messages on IRC
12:37:50 <monochrom> That message exists on your computer only.
12:37:52 <Guest92818> I'm sorry if it offended somebody.
12:37:58 <wildtrees> since its immutable , nodes are shared often shared in ghc 
12:38:01 <merijn> josiah_sama: And the person was disconnected already
12:38:02 <mitchellsalad> Guest92818: not your message :)
12:38:05 <sclv> Guest92818: not your message, the spam :-)
12:38:10 <monochrom> You can poweroff your computer for a clean erasure.
12:38:24 <sclv> as for your message, there's a lot of work on efficient functional data structures
12:38:28 <sclv> the classic book is okasaki
12:38:42 <sclv> but even without all the clever tricks in there, even the basics are decent
12:39:04 <monochrom> Inefficiency cannot be disccused independently from incorrectness.
12:39:11 <Guest92818> Makes sense. Are you talking about 'Purely Functional Data Structures'?
12:39:14 <sclv> I.e. typically the cost is dropping down from O(1) to O(log(n)) for certain lookup ops
12:39:32 <sclv> and that will tend to get drowned in the bigger asymptotic costs of interesting algos
12:40:00 <Guest92818> Oh I understand your point.
12:40:03 <josiah_sama> Ah, I didn't realize at first that this was a Matrix->IRC bridge.
12:40:06 <josiah_sama> not sure whether that's possible in Matrix, though, either
12:40:19 <sclv> And the okasaki magic is if you restrict your ops a bit you can get datastructures that give you back your big-O (but just not for all ops at once)
12:40:34 <monochrom> There are algorithms that benefit from immutable data structures, and if you give them mutable data structures instead they become either incorrect or a bother to fix.
12:40:49 <sclv> There are a very few important and specialized algos where immutability does get in the way of performance notably, and for those one can always drop to imperative
12:41:00 <sclv> we have locally mutable state in the ST monad, or just with IO
12:41:39 <Guest92818> Although I don't understand exactly what these things are, I'm getting the gist.
12:41:46 <sclv> (oh and the win from being able to just start doing multithreaded stuff without asking "is this datastructure synchronized" is huge)
12:41:48 <Guest92818> Lastly, what would be the best way to start learning Haskell?
12:42:03 <monochrom> That depends on you.
12:42:04 <Guest92818> By practice or by a book?
12:42:31 <sclv> I learned from practice and some shorter online tutorials (there weren't really books then :-P)
12:42:37 <sclv> but to each their own
12:42:44 <monochrom> But C also exists for escaping from OOP.
12:43:14 <sclv> there are a bunch of books and other resources listed here: https://www.haskell.org/documentation/
12:43:23 <Guest92818> Alright. Well, thanks a bunch lads. I'll come back here if I need further clarifications. This chat has been very friendly and welcoming.
12:44:14 <monochrom> However, for the seriously performnace-aware, I recommend Fortran over C.
12:45:17 <merijn> monochrom: Single Assignment C, for if you want Fortran but purely function (and with a dead project as a compiler...)
12:45:39 <Rembane> Futhark if you want something living. 
12:45:42 <monochrom> Hey, Hugs is just as dead and just as usable.
12:46:36 <merijn> Futhark is just GPUs
12:46:47 <dmwit> ?wiki tutorials
12:46:47 <lambdabot> https://wiki.haskell.org/tutorials
12:47:01 <dmwit> Oh. They're gone.
12:47:06 <Athas> Futhark is not GPU-specific at all!
12:47:10 <monochrom> Well, they get to say, "for the seriously performance-aware, use a GPU"...
12:48:53 <merijn> monochrom: Debatable :p
12:52:30 <d34df00d> Is there anything for sort of exploratory data analysis in haskell?
12:52:57 <d34df00d> Let's say I've parsed some records and now I'm curious to group them by some criteria, count the group sizes, see some samples from the groups, etc.
12:54:09 <wildtrees> d34df00d, groupBy , sortBy, length and some other stuff from Data.List perhaps? 
12:54:58 <fragamus> Hi I am away from my computer using my phone but I wonder if someone could run kmett’s expr.hs example from recursion schemes and post the output as a gist
12:54:59 <d34df00d> Yeah, I'm writing the compositions of those myself now, but it seems to become clunky soon, especially when done at repl.
12:55:03 <dmwit> I've spoken to some people who swear by dataframes and R. These people seem unsatisfied by Haskell's counterparts.
12:55:18 <dmwit> I've never quite understood the objections, but I've also not spent a lot of time in that space myself.
12:55:24 <d34df00d> And taking the random samples is, well, more complicated.
12:55:42 <dmwit> In any case, from talking to them, my short answer is "basically no, there's nothing really great for that in Haskell".
12:55:49 <wildtrees> > take 10 randoms 
12:55:52 <lambdabot>  error:
12:55:52 <lambdabot>      • Couldn't match expected type ‘[a]’ with actual type ‘g0 -> [a0]’
12:55:52 <lambdabot>      • In the second argument of ‘take’, namely ‘randoms’
12:56:02 <wildtrees> @type randoms 
12:56:04 <lambdabot> (RandomGen g, Random a) => g -> [a]
12:57:09 <d34df00d> Uh... I guess it's not gonna work in repl anyway.
12:57:32 <d34df00d> I've heard pandas-profiling is great in python, but I never used myself. And AFAIK it renders an HTML page or something.
12:57:40 <d34df00d> So you can click on stuff, group stuff, etc.
12:59:20 <d34df00d> wildtrees: randoms not going to give me a sample me from a list.
12:59:22 <Rembane> d34df00d: There's this: https://github.com/gibiansky/IHaskell
13:00:12 <d34df00d> Rembane: oh, that's interesting!
13:03:48 <solonarv> > take 10 $ randoms (mkStdGen 42)
13:03:51 <lambdabot>  [-3900021226967401631,6115732954341747105,-7802898033696815382,-668226775436...
13:04:10 <solonarv> there you go!
13:04:33 <d34df00d> Well, I could probably map (`mod` length array) $ take 10 $ randoms (mkStdGen 42) or something like that...
13:04:46 <fragamus> My computer is getting fixed at Apple and I had to leave it with them. I’m freeking out.
13:04:47 <dmwit> :t randomRs -- ...
13:04:48 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> [a]
13:04:55 <d34df00d> Or this :)
13:05:55 <fragamus> I decided to study Kmett’s recursion schemes while I wait for my beloved computer for four days
13:06:18 <d34df00d> dmwit: well, the objection by those folks might be that you have to spend your CPU cycles on thinking about how to take a random sample and reading System.Random docs and then mapping (list !!) over the indices or something.
13:06:23 <d34df00d> Which feels like a papercut of sorts.
13:06:55 <fragamus> Could one of you more fortunate people run that Expr.hs example and post a gist of the output
13:07:54 <solonarv> fragamus: you can run code online using repl.it
13:08:11 <solonarv> that seems like a better approach than begging people on IRC to run code for you :P
13:08:12 <fragamus> Ok
13:08:23 <fragamus> Yeah
13:08:57 <fragamus> I’m using my phone but I’ll go try it
13:16:45 <xaltonon[m]> idea: compile GHC for android in termux
13:25:39 <juri_> xaltonon[m]: that would be nice.
13:54:38 <fragamus> Well repl.it apparently does not allow Haskell packages to be installed
13:54:52 <fragamus> It has only base
14:03:04 <yoav_> I'm trying to decipher a class declaration but I'm not sure what I'm reading. What does `class ImageFormat format => Readable img format` mean? How come there's both img and format?
14:03:47 <remexre> how do people do logging?
14:09:41 <xaltonon[m]> yoav_: It might help to look at some of the class instances: the `img` varies over all the different image types it can be decoded into, and the `format` varies over all the different image formats being decode.
14:10:09 <EvanR> remexre: one possibility is to pass around a String -> IO () function to anything that needs to log, this could be a closure containing whatever resources necessary to make logging happen. To make logs transactional, String -> STM ()
14:10:18 <xaltonon[m]> There's a `Readable (Image VS YA Word8) PNG` instance for example, which says that you can decode a PNG into an 8-bit image with a luma and alpha channel
14:11:41 <remexre> EvanR: is this commonly done? I feel like there'd be a... "more polished" solution somewhere
14:11:54 <xaltonon[m]> Presumably there's both `image` and `fmt` because each format can be decoded into many different kinds of images (8-bit vs 16-bit, different colour channels, etc)
14:11:59 <EvanR> well, that is the holistic way : )
14:12:21 <EvanR> other ways are going to depend on what transformers the rest of your system is using
14:12:29 <EvanR> and what transformer glue you decided to go with
14:13:12 <remexre> I'm probably doing tagless-final for business logic, concrete stack probably looks like StateT Foo (ReaderT Bar IO) a
14:13:44 <EvanR> then you can keep the logging function i mentioned in the Bar and write a wrapper action to do logging
14:15:32 <remexre> I mean like, I know I could implement it myself, but once I want e.g. log levels, colors, teeing logs to files/syslog, etc. I don't wanna be implementing it myself, right?
14:16:07 <EvanR> yeah youre right
14:18:02 <EvanR> i've seen people mention fast-logger but it doesn't do any of that
14:20:19 <EvanR> if we're talking about best logging experience overall, maybe you want to integrate with one of those "host my logs" sites
14:20:26 <solonarv> there are a bunch of logging libraries around, I haven't used any of them though
14:26:37 <EvanR> remexre: for sake of reference is there a library or system in another language that does what you're thinking of
14:27:32 <remexre> maybe fern w/ rust?
14:28:23 <remexre> EvanR ^^
14:28:59 <remexre> I don't really want a host-my-logs site, since I otherwise don't need to touch the network
14:30:54 <EvanR> yeah i just checked it out
14:37:08 <EvanR> it looks like Katip has a lot of features including detailed payload filtering and color
14:37:40 <EvanR> and formatting
14:38:09 <EvanR> and integrations
14:46:55 <remexre> hm
14:47:03 <remexre> I'll check it out then, thanks!
14:47:06 <remexre> EvanR ^^
14:47:41 <EvanR> I'd like to hear how it goes
15:31:27 <devalot> Does cabal-install 2.4.0.1 automatically try to build projects in subdirectories?  I have a project with a tools directory that I don't want to build but cabal v2-build seems to be building it without being asked to.
15:33:53 <int-e> devalot: I thought it depends on what's in cabal.project.
15:46:25 <glguy> devalot: If you don't have an explicit cabal.project file the default one has optional-packages: */ 
15:46:44 <glguy> That means it's willing to use any packages that are immediate subdirectories of the current
15:46:53 <devalot> I don't have a cabal.project file, so that makes sense.
15:47:47 <devalot> Cabal 2.4 is super annoying.  First it was littering my projects with cabal.project files then .ghc.* files now it's magically building projects I don't want it to.
15:49:39 <glguy> The default v2-build optional-packages behavior isn't new in 2.4. The .ghc files are quite useful. It doesn't create cabal.project files on its own. It will create cabal.project.local files if you tell it to via v2-configure
15:52:40 <devalot> You're right.  But for those of us using Nix those files cause all sorts of problems.
15:53:57 <int-e> there's too much magic in this picture
15:54:27 <devalot> Anyone using Nix but doing incremental builds?  I'm thinking of using Setup.hs to do incremental builds and just dropping cabal altogether.
15:54:59 <infinisil> devalot: I'm just using the old-style builds with nix
15:55:02 <infinisil> Working decent
15:55:15 <infinisil> But I'll switch to new-build once HIE supports it well
15:55:37 <devalot> infinisil: I might go back to that.  I was just getting sick of the warnings from cabal about the old-style builds going away.
15:55:43 <infinisil> devalot: And I don't know what kind of trouble you're having
15:56:52 <devalot> Well, my current issue is that I have a project that has a sub directory with its own build system.  But cabal wants to go into there and build it when I build at the top level.
15:57:11 <devalot> But of course, cabal doesn't use the default.nix file in that sub directory.
15:58:13 <devalot> Perhaps I'll play around with Snack: https://github.com/nmattia/snack
16:00:25 <infinisil> devalot: I wouldn't recommend snack. It's a nice POC, but not really practical
16:01:39 <devalot> infinisil: I was just looking at it and it has it's own package format.  I prefer to use cabal2nix so that I can bring my packages into other projects easily.  So that tool is out.
16:05:16 <devalot> Looks like I have no choice except to have a cabal.project file so I can override optional-packages.  :(
16:11:04 <Arahael> what are the more popular web server frameworks?  yesod looks pretty good...
16:11:33 <hpc> or snap
16:11:37 <hpc> or servant
16:13:11 <Arahael> hpc: any particular considerations when picking them?
16:14:45 <hpc> servant is good at rest apis
16:15:14 <hpc> and apparently also good at ui but i missed it when i was looking over its docs
16:15:25 <hpc> snap's not bad
16:15:47 <hpc> i looked at yesod and decided to pass on it, but i forget why
16:16:10 <Rembane> Too much Template Haskell and magic?
16:16:15 <hpc> it was either it expected you to run commands during development that make packaging hard...
16:16:18 <hpc> or that
16:16:28 <hpc> or that it was made by the people who tried to do a hostile takeover of haskell.org a few years ago
16:17:00 <Rembane> Yeah, that is not a good property. 
16:17:52 <Arahael> interesting.  the template haskell looks ok, that hostile takeover isnt a technical considerstion though, but interesting, that would cause a bit of  distaste.
16:19:39 <hpc> oh yeah, the hackage docs are user-hostile as well
16:19:44 <hpc> the description just says to look at stackage
16:20:23 <hpc> i did end up using shakespeare
16:21:41 <Arahael> the yesod book is very good, its whats making me like it, but i havent really gotten into hackage or the other docs.
16:21:44 <hpc> it's still fairly magic, but manageable in small doses and i like knowing i send correct stuff to the browser
16:22:17 <hpc> the book does a good job of sucking you in, but it's missing a lot once you try to actually use it
16:22:54 <nshepperd> the description says to look at stackage, and stackage says to look at the yesod website
16:23:16 <hpc> oh, hah
16:23:38 <Arahael> hpc: thats unfortunate :(
16:24:07 <hpc> i didn't even look at the stackage page because it looks like someone made a bootstrap site and forgot to load the layout css
16:24:48 <hpc> i can't just glance at it to find the information i want
16:26:23 <nshepperd> yesod reminds me of RoR
16:26:34 <nshepperd> (in a bad way)
16:27:11 <Arahael> snap looks ok, i think i initially disregarded it because i had to use a project generator to get it up, and it doesnt seem to have as mich functionality as yesod did.
16:27:29 <Arahael> nshepperd: ror isnt remotely type safe though!
16:28:03 <hpc> having maintained some monster RoR stuff, it gives me hope that microsoft can survive in a linux-only world :P
16:28:09 <Arahael> snap doesn't use template haskell though, does it?
16:28:44 <hpc> snap and yesod are both rather modular
16:28:59 <hpc> so for example, i am using snap but i liked yesod's templating engine (shakespeare) better, and used that
16:29:13 <Arahael> hmm, snap does feel more welcoming - they even have a prominantly advertised irc presence.
16:29:15 <hpc> but i am otherwise using all snap components because they're easier to handle
16:29:54 <hpc> less noodly dependencies, and snap stuff doesn't tend to tie directly back to snap in a mandatory way
16:30:07 <Arahael> more people in #yesod thoug.
16:30:10 <hpc> the last thing i want to do is build yesod into my snap site
16:30:16 <hyperisco> hehe noodly
16:30:33 <hpc> noodly dependencies are how you write spaghetti code
16:31:13 <Rembane> All the dependencies! 
16:31:18 <Arahael> hpc: websites are often noodly though.  isnt this just giving you tools to manage that?
16:31:41 <hpc> module dependencies are a different layer from the site layout
16:33:04 <hpc> you want only the part that has to be messy to be messy (user interaction), and everything else being properly layered
16:33:19 <hpc> ask any italian chef and they'll tell you the right way to make spaghetti is a thin layer on top of an onion :D
16:33:33 <Arahael> heh.
16:34:45 <Arahael> The snap hackage page does seem very easy to read.
16:43:05 <Arahael> well, i have already started with yesod, so i think i'll stick with that for this project.  perhaps i'll use snap for the next one so i get both perspectives.
16:44:13 <thosgood[m]> i remember reading somewhere what monads, applications, and functions are in terms of category theory, but can’t remember where... any ideas?
16:44:26 <thosgood[m]> *applicatives and functors
16:44:51 <thosgood[m]> applicatives are lax monoidal with weight, or something like that
16:48:38 <phadej> does sound right
16:48:54 <phadej> doesn't*
16:49:49 <thosgood[m]> no, i can’t remember what exactly they all corresponded to
16:50:01 <thosgood[m]> was just being lazy and trying to avoid working it out myself
16:50:10 <shachaf> Monads are (a special case of) monads, and functors are (a special case of) functors.
16:50:23 <phadej> http://strictlypositive.org/Idiom.pdf describes applicatives /well/
16:50:25 <shachaf> Applicative functors could be several things depending on your formulation.
16:50:46 <phadej> it also have sentences "Fans of category theory will recognise the above laws as the properties..."
16:51:12 <thosgood[m]> <phadej "it also have sentences "Fans of "> will read that, thanks :)
16:51:57 <thosgood[m]> there are so many texts to learn category theory as a programmer but i can’t find any on how to learn haskell for a category theorist haha
16:52:33 <shachaf> The standard definition of Applicative works out to the same thing because Haskell functors are strong, but in other contexts it can be different.
18:06:24 <murkyswamp> I'm trying to use GLFW-b to create a window, but it segfaults for some reason, does anyone know why?
18:07:22 <murkyswamp> This is the line that crashesm <- GLFW.createWindow width height title Nothing Nothing
18:13:29 <jackdk> more info? OS, where you got your GLFW from, ...? I had segfaults with glfw-from-nix on ubuntu; you need the nixgl wrapper if that's your setup
18:14:08 <jackdk> can you get sensible output from glxinfo/glxgears?
18:17:58 <murkyswamp> Ubuntu, I'm not entirely sure which GLFW binding was installed (installed w/ stack and I'm kinda new to it)
18:18:36 <murkyswamp> I think this one? http://hackage.haskell.org/package/GLFW-b
18:22:15 <jackdk> yeah I'm using that library too. presumably stack links it against system GL libs without doing anything too crazy
18:22:45 <jackdk> next test: can you run other GL stuff on your machine? pastebin the output of `glxinfo` and/or test if glxgears runs?
18:24:32 <murkyswamp> https://pastebin.com/vYqPMK7S
18:24:38 <murkyswamp> glxgears runs
18:24:51 <solonarv> thosgood[m]: we can sort of pretend to be working in a category in Haskell; our objects are types, and arrows are functions
18:25:09 <solonarv> usually we call this Hask; it's somewhat similar to Set
18:25:44 <solonarv> also, it isn't actually a category because seq and bottoms get in the way, but you can sort of wave your hands, squint a bit, and pretend it's a category anyway
18:26:59 <solonarv> under that view, a Functor is an endofunctor in Hask
18:27:33 <solonarv> a Monad is a monoid object in the category of Hask-endofunctors, with composition as the tensor
18:28:20 <murkyswamp> Wait, it doesn't segfault when I manually compile it
18:28:22 <solonarv> an Applicative is a monoid object in the category of Hask-endofunctors with product or Day convolution as the tensor (these constructions are equivalent)
18:29:55 <jackdk> murkyswamp: I'm out of ideas then. it's possibly that some wrapping/unwrapping in stack run or cabal new-run or however you're building/launching it is messing something up
18:33:42 <murkyswamp> Found the issue; `-with-rtsopts=-N` is one of the default flags and it appears to not play nicely with GLFW for some reason
18:39:27 <jackdk> GL likes to only be called from one thread
18:40:18 <jackdk> is there a library that provides `(<$$>) = fmap . fmap`?
18:41:45 <dmwit> Well, there's Compose in base. =)
18:45:22 <jackdk> yeah, followed by a bunch of wrapping/unwrapping `:-(`
18:52:17 <murkyswamp> Whee I finally drew a circle!
18:52:36 <monochrom> "comes back full circle"
18:55:38 <jackdk> murkyswamp: \o/ I drew a triangle recently, I know the feeling `:-)`
19:40:21 <sarahzrf> whyyy isn't there a mapMaybe in Data.Set
19:40:23 <sarahzrf> >_<
19:40:27 <sarahzrf> for heaven's sake!
19:48:13 <Lears> devalot: Having a cabal.project file is the basics of using new-style cabal, which should be comfortable with nix once you're past the gotchas. In particular, you should filter .ghc.* files from your source, and any dependencies that need to be built by nix should be provided by nix in your shell, and excluded from cabal.project's packages field.
20:19:20 <jackdk> sarahzrf: there's no instance Filterable for it in `witherable`, either, though that's probably because `Filterable` requires `Functor`. I think your best bet is gonna be something like fromList . mapMaybe f . toList
20:19:48 <sarahzrf> :\
20:29:22 <jackdk> sarahzrf: https://hackage.haskell.org/package/containers-0.6.2.1/docs/src/Data.Set.Internal.html#map looks like map is no better, unless you can guarantee ordering with mapMonotonic. If you have time you might want to write a PR for mapMaybe and mapMaybeMonotonic?
20:42:03 <sarahzrf> jackdk: meh
20:42:33 <jackdk> I know that feeling
20:42:57 <sarahzrf> :D
21:13:16 <saurabh__> is it not possible to write functions with different-kinded types? For example -- `ensureFeatureFlagThrow :: (HasContextEntry auth ff) => ff -> AppM auth ()`
21:14:43 <g> saurabh__: What's HasContextEntry? What are the kinds of those types?
21:15:58 <saurabh__> g: HasContextEntry is from Servant - https://www.stackage.org/haddock/lts-12.1/servant-server-0.14.1/Servant-Server.html#t:HasContextEntry - it's basically for heterogenous list. Core data-type - https://www.stackage.org/haddock/lts-12.1/servant-server-0.14.1/Servant-Server.html#t:Context
21:16:16 <jle`> what about that function is 'different-kinded'?
21:16:40 <saurabh__> Expected a type, but ‘auth’ has kind ‘[*]’ In the first argument of ‘AppM’, namely ‘auth’
21:16:45 <saurabh__> ^ that's the error that I'm getting. So, I'm assuming [*] instead of * is what is throwing off the compiler
21:17:41 <jle`> well that depends on the kind of AppM
21:18:00 <monochrom> This is more about AppM than about functions.
21:18:11 <jle`> polykinded types are supported by haskell, but remember type inference depends on where you use it
21:18:16 <jle`> the kind of 'auth' will come from the kind of AppM
21:18:27 <jle`> just like how haskell we have polymorphism, but type inference depends on how you use the type
21:18:29 <saurabh__> type AppM auth = ReaderT (Env auth) IO 
21:18:35 <saurabh__> data Env auth = Env {...} -- auth is used for one of the fields
21:19:02 <jle`> so auth has to be * ?
21:19:27 <saurabh__> jle`: yes -- I have not explicitly given it any kind, so it must be *
21:19:29 <jle`> welcome to type inference :)
21:19:36 <jle`> saurabh__: that's not the reason why it's *
21:19:38 <monochrom> And kind inference.
21:19:44 <saurabh__> Env :: * -> * 
21:19:51 <jle`> the reason why it's * is because it's used as the type of a value
21:20:17 <jle`> for example, (True :) :: [Bool] -> [Bool]
21:20:23 <jle`> that's because you use (:) with a Bool
21:20:37 <jle`> so, there isn't any way you can make it (True :) :: [String] -> [String]
21:20:46 <jle`> it's not because haskell doesn't support polymorphism
21:20:49 <saurabh__> ˘AppM :: * -> * -> * 
21:20:51 <jle`> it's because that's just the type of (:)
21:21:17 <saurabh__> okay, so `auth :: *`
21:21:40 <saurabh__> ah okay....
21:21:46 <jle`> yes, we know that because it is used as the type of a value
21:21:52 <saurabh__> is lambdabot still around?
21:21:52 <jle`> if it was anyhting else, you can't have a value of that type
21:21:57 <saurabh__> :i HasContextEntry
21:22:13 <jle`> for example, '[True, False] is not a valid instantiation of 'auth'
21:22:18 <jle`> because you can't have a value of type '[True, False]
21:22:26 <jle`> saurabh__: lambdabot does not support :i
21:22:35 <saurabh__> so, because of the HasContextEntry constraint, it's expected auth :: [*], but auth :: *  -- therefore compiler is not happy
21:22:56 <jle`> well, the compiler is not happy because what you ask for does not make sense
21:23:05 <jle`> the kind error is a symptom, not a cause
21:23:11 <saurabh__> jle`: thanks .... that solves one part of my problem. 
21:24:20 <jle`> one thing you can do to make it kind-check is HasContext '[auth] ff => ..., but i'm not sure if that's what you want
21:25:41 <jle`> alternatively you can have Env not have an auth as a field
21:26:07 <jle`> if Env is under your control
21:31:46 <saurabh__> I think I'm trying to re-invent an effects system, but instead of effects, it is for permission/roles. For example, if I have the snippet (do ensureFeatureFlag 'FeatureA; ensureFeatureFlag 'FeatureB ; someAction) -- I want it's type to be `AppM (auth :: ['FeatureA, 'FeatureB]) a`
21:34:53 <jle`> if that's the case, you need to change Env
21:35:16 <jle`> but also i strongly recommend against the headache of re-inventing an effects system
21:35:18 <jle`> ;)
21:41:54 <saurabhn_> Trying to draw some inspiration from https://hackage.haskell.org/package/fused-effects -- is this library a replacement for mtl? Or can I keep my underling `type AppM = ReaderT Env IO` monad, and somehow use fused-effects to track roles and permissions?
21:50:59 <saurabhn_> wow -- so much dance around the type-system -- https://github.com/fused-effects/fused-effects/blob/master/docs/defining_effects.md
21:51:10 <orzo_> Where can I find a write up on interfacing c with haskell the *wrong* way, meaning accessing haskell types directly from C.  I know it's not a good idea for library code, but I'm curious.
21:51:31 <orzo_> using ghc internal data representation
22:13:35 <libertyprime> hey guys whats the easiest way to list all the classes inside a module?
22:22:58 <Arahael> grep?
22:33:29 <cjenn> is there a way to run single commands in ghci akin to 'python -c'? if there was you could do something like "ghci -c ':bro <module>' | grep class"
22:35:48 <marmulak> cjenn: I am looking at ghci's manpage and something like -e might work
22:36:09 <marmulak> although I don't know what :bro does since I just started using haskell yesterday
22:36:44 <cjenn> :bro=:browse. it lists all of the definitions in a given module
22:37:14 <libertyprime> thanks guys. thats really helpfyul
22:37:38 <cjenn> ghci -e :browse does print all the definitions
22:38:22 <marmulak> can you give me a module name for me to test it with
22:39:23 <cjenn> marmulak: running 'ghci -e ":browse Data.Foldable" | grep class' should return 'class Foldable (t :: * -> *) where'
22:39:48 <marmulak> seems to work for me
22:40:05 <marmulak> when I do ghci -e ':bro' I get the same what I get in interactive mode
22:40:18 <marmulak> pretty nifty
22:41:02 <cjenn> It's the best thing I can think of anyway.
22:41:19 <marmulak> did you have something better in mind
22:41:26 <cjenn> nope.
22:41:37 <marmulak> lol then we figured it out, yay!
22:41:45 <cjenn> it just feels like a bad idea for some reason
22:44:08 <marmulak> from what I can see, the output with -e has no difference whatsoever from running the command in interactive mode, and appears to be exactly like 'python -c' and such things
22:44:28 <marmulak> not that I've ever used python
22:45:07 <cjenn> i guess i just don't trust ghci to actually work properly. I don't use it anywhere near enough, so that's probably more to do with my not understanding things
22:45:49 <marmulak> ah maybe
22:46:22 <marmulak> I'm sure the ice will melt, once you get to know it better
22:46:39 <marmulak> I've been working primiarily with ghci and I rather like it
22:48:05 <marmulak> this might be a stupid question, but does haskell support objects or something similar? Any attempts to be multi-paradigm, or purely functional?
22:52:32 <cjenn> not really. there are ways to get various oop-like things, but that really depends on what you're looking for.
22:55:54 <marmulak> is there a function that provides the last index of a list (equivalent of length - 1)
22:56:12 <cjenn> the closest thing i've seen to oop in haskell is in ffi libraries like gtk2hs or eta
22:57:10 <cjenn> apparently oleg k has a paper+library, but i've never heard of it
22:57:43 <cjenn> for the function, i've never heard of one, and hoogle says no (https://hoogle.haskell.org/?hoogle=Traversable%20t%20%3D%3E%20t%20a%20%2D%3E%20Int)
22:58:07 <marmulak> well, length - 1 it is lol
22:58:28 <MarcelineVQ> length - 1 looks good, equivalently: length . drop 1
22:58:38 <cjenn> although length is on foldable not traversable
22:58:46 <marmulak> oh clever, I like that
22:59:31 <marmulak> wiat how would I write that
22:59:33 <MarcelineVQ> clever looking but probably wrong :> it depends on what the index of an empty list should be
22:59:44 <marmulak> length (x drop 1)
22:59:59 <MarcelineVQ> > drop 1 "foo"
23:00:01 <lambdabot>  "oo"
23:00:13 <cjenn> > drop 1 ""
23:00:16 <lambdabot>  ""
23:00:18 <marmulak> tnx
23:00:35 <marmulak> wouldn't doing length first and then subtracting 1 from the result be easier for the compiler
23:00:47 <marmulak> in terms of work
23:01:59 <cjenn> it's probably the same. ghc's usually pretty good with this sort of thing
23:02:13 <MarcelineVQ> No it's the same work in this case. We need to traverse the list entirely to find it's length, dropping the first element along the way isn't more work
23:02:33 <marmulak> I'm basically writing a simple practice program for my first haskell, which is a rewrite of some pice of crap I wrote in C 12 years ago
23:02:55 <cjenn> length - 1 is probably more legible, as much as i love pointfree stuff
23:03:08 <marmulak> MarcelineVQ: gotcha. I thought it would have the lengths of lists pre-indexed but I guess it doesn't do that unless forced to, per the lazy principle
23:03:35 <marmulak> so I'll let you guys know how I wrote this program
23:03:46 <MarcelineVQ> A ​list is a linked list, we can't know when it ends without going to the end, so there's no pre-indexing
23:04:27 <MarcelineVQ> importantly these things have different semantics which is why I mentioned the empty list. length (drop 1 xs) is not equivalent to length xs - 1, when xs is []
23:04:52 <marmulak> the program takes input of a chunk of text containing e-mail addresses, and I want to put those e-mail addresses into a neat list, so extracting them from the text. Since I'm not good at haskell I accept the simple constraint that all e-mails are enclosed by "< >" (makes the problem very easy)
23:05:17 <marmulak> MarcelineVQ: good point
23:05:21 <MarcelineVQ> so length . drop 1 might be cute but wrong, depending on what's right
23:05:35 <marmulak> anything might be wrong, depending on what's right
23:06:01 <MarcelineVQ> Absolutely, so it's good to think of what's right ahead of time :D
23:06:57 <marmulak> so to make my program work I wrote two functions, one that returns the indices of all occurences of a character in a string, and one that returns the portion of a list between two given points, or in this case a list of doubles
23:07:03 <MarcelineVQ> Interesting problem, why do you need to index? Is it part of deciding if you end with > ?
23:07:19 <marmulak> well consder idk what I'm doing
23:08:12 <marmulak> but my program works, just by finding all the '<' then all the '>' zip the results, then handing it to the function that gives me what's between each pair
23:08:44 <marmulak> probably unnecessary steps in there but I wanted it clean and readable
23:08:55 <Lears> Indexing into linked lists isn't really done in Haskell. I'd use something like `break` to find occurrences of '<' and '>', collecting the emails as I go.
23:09:28 <marmulak> definitely there has to be a better way than what I did lol
23:10:03 <marmulak> let me put the code in pastebin or soething so you can see how bad it is
23:10:16 <cjenn> this is the kind of thing where i just go look in data.list because there's probably something
23:10:34 <marmulak> I'll read up on break
23:11:00 <marmulak> I was thinking haskell probably has something built in that cant return parts of strings between two bounds
23:11:06 <marmulak> can*
23:11:44 <marmulak> I guess with regex I could probably solves this problem in a single line heh
23:11:45 <cjenn> at worst you could just use a fold
23:11:59 <marmulak> so what is a fold
23:12:00 <MarcelineVQ> cjenn: this particular one is nicely served by Data.List.Split but that's not in base
23:12:49 <cjenn> a fold just lets you iterate through a list one element at a time
23:13:23 <marmulak> ah hmm
23:14:00 <MarcelineVQ> I'd start with span/break and takeWhile/dropWhile
23:14:05 <cjenn> yeah
23:14:56 <marmulak> one possible solution I thought of that would have been harder but possibly more flexible than assuming < and > was to walk through the list and every time @ appears search backwards and forwards from that point until hitting an invalid character for an e-mail address, so they could be separated by anything like commas, quotation marks, etc
23:18:26 <cjenn> I'm not sure where you are in haskell, but my instinct would just be to use parsec here
23:19:09 <cjenn> it's worth figuring out parser combinators *eventually*, since they're pretty useful
23:19:22 <MarcelineVQ> marmulak: That's a valid option, though a little more mind-bendy depending on who you are, the problem would be writing it in a way that doesn't do a lot of redundant work since you can't quite walk back up a list directly, singly-linked lists tell you what's next in the list but not what came before.
23:21:24 <MarcelineVQ> I'd still suggest using span or break for this to learn on.
23:21:52 <marmulak> I will take note
23:21:58 <cjenn> i second the span/break thing for learning.
23:23:42 <marmulak> thanks cjenn 
23:24:01 <MarcelineVQ> dropWhile and takeWhile are pretty great too for simple parsing
23:25:04 <MarcelineVQ> > dropWhile (/='c') "abcde"
23:25:06 <lambdabot>  "cde"
23:28:41 <marmulak> so here we dropped everything until c
23:29:10 <marmulak> I am shocked /= is missing an operand
23:30:31 <dibblego> why? it takes one argument, like every haskell function
23:30:34 <MarcelineVQ> That's called an operator section, it's equivalent to (\x -> x /= 'c'), in this case x is 'a' and then it's 'b' and then it's 'c' where it then fails.
23:31:21 <marmulak> hm
23:34:41 <nshepperd1> Whenever i need to parse something i reach for either splitOn or parsec
23:35:08 <xacktm> TIL operator sections as syntactic sugar for partial application... thanks!
23:36:06 <marmulak> https://paste.fedoraproject.org/paste/x7ASQp9iqqvK6vruCqNvaQ
23:36:12 <xacktm> I would have written it as ((/=) 'c') but now I know a shorter way :)
23:36:24 <marmulak> this is my first haskell program, although rewritten a couple times
23:36:51 <marmulak> the fact that I was able to figure out how to write this proves haskell isn't as hard as people claim
23:37:04 <nshepperd1> (which is pretty weird. It's like instead of just having a hammer i have a hammer and an industrial bulldozer)
23:37:07 <marmulak> it was actually kinda friendly, just frustrating as any new thing is
23:37:17 <marmulak> where you can't do what you want
23:37:26 <marmulak> nshepperd1: indeed
23:38:34 <dibblego> my children both learned haskell (though have now grown up, at university now), and one day I introduced them both to destructive update programming — they were very confused. I recorded one of the discussions.
23:39:05 <marmulak> I can imagine
23:39:06 <sarahzrf> hahahaha
23:39:07 <dibblego> it's hard if that happened the other way around — a significant part of my job is reversing this
23:39:17 <dibblego> e.g. I was in Sydney all this week doing it
23:39:30 <marmulak> it's like me growing up driving with automatic transmission and then finding out about stick shift
23:39:50 <dibblego> other way around :)
23:40:05 <dibblego> it's like putting your foot on the clutch pedal and it isn't there, then claiming that automatics must be harder
23:40:23 <marmulak> good analogy
23:40:37 <nshepperd1> It's like regular programming, but everything's in iorefs for some reason
23:41:29 <dibblego> on day 1, I ask everyone to add up the numbers in a list — so they reach for a for loop, but just prior to that, we'd put a stake in the ground — no destructive updates. Now what? https://groups.google.com/forum/#!forum/nicta-fp
23:42:01 <marmulak> dibblego: your story makes me feel old because when I was a child I don't think haskell existed yet
23:42:15 <sarahzrf> marmulak: how old are you? :o
23:42:22 <dibblego> me neither, but John Backus' paper did, just
23:42:33 <marmulak> I was born in 86 lol
23:43:03 <sarahzrf> so you stopped being a child at 4 O:
23:43:09 <marmulak> hahaha
23:43:26 <marmulak> I just read yesterday that haskell development started in 87 but was not finalized until 2003?
23:43:29 <dibblego> https://www.cs.cmu.edu/~crary/819-f09/Backus78.pdf you were 9
23:43:37 <dibblego> wait no, I was 9
23:43:45 <marmulak> which is funny because 2004 onward was around the time my computer scientist friends started all telling me haskell was their favorite language
23:43:46 <sarahzrf> marmulak: i mean, what do you mean by "haskell development"?
23:43:58 <sarahzrf> >The first version of Haskell ("Haskell 1.0") was defined in 1990.[1] The committee's efforts resulted in a series of language definitions (1.0, 1.1, 1.2, 1.3, 1.4). 
23:44:06 <marmulak> by haskell development I mean the development of haskell :)
23:44:19 <marmulak> oh wow 1990
23:44:28 <marmulak> so where did this 2003 date come from
23:44:33 <marmulak> the last definition?
23:45:11 <sarahzrf> that's when the revised version of haskell 98 was defined, says wikipedia
23:45:20 <marmulak> interesting
23:45:57 <marmulak> if I get really smart at using haskell, will my programs run almost as fast as C programs?
23:46:39 <sarahzrf> ehhh, hard to say
23:46:48 <sarahzrf> you probably won't write the same programs in haskell as in C, i mean
23:47:01 <sarahzrf> are you asking, will you be able to solve the same problems as fast?
23:47:04 <sarahzrf> maybe not
23:47:16 <sarahzrf> some, maybe
23:47:21 <sarahzrf> i wouldn't count on it in general :P
23:48:10 <sarahzrf> if you really know what you're doing? quite possibly
23:48:16 <sarahzrf> it depends on a lot of factors
23:50:02 <sarahzrf> at the very least, ghc can optimize ultra-simple code into super-efficient machine language, so for example you can easily produce tight loops using tail recursion
23:50:26 <sarahzrf> but what produces fast machine langauge isnt always what's idiomatic
23:50:41 <sarahzrf> here's a relevant post btw https://donsbot.wordpress.com/2008/05/06/write-haskell-as-fast-as-c-exploiting-strictness-laziness-and-recursion/
23:50:51 <marmulak> I just meant runtime performance, since haskell seems pretty fast actually, and I assume it was designed with that in mind
23:51:38 <sarahzrf> haskell was designed with being a lingua franca for academic papers in mind :P
23:51:51 <marmulak> but the programmer would have to be aware of what the compiler really does to know which approaches are more fficient
23:52:18 <marmulak> oh, I don't write academic papers :(
23:52:35 <sarahzrf> well, that /was/ 30ish years ago
23:52:44 <sarahzrf> at this point we all write ghc haskell anyway
23:52:49 <marmulak> I thought haskell was designed to kick ass and take names
23:53:37 <sarahzrf> nah, taking reified names as arguments requires template haskell, which is an extension
23:53:40 <sarahzrf> /s
23:53:46 <marmulak> do you guys know why the variable name "xs" is so popular
23:53:49 <marmulak> lol
23:53:54 <marmulak> so kicking ass is built in
23:53:56 <sarahzrf> it's a plural
23:53:56 <marmulak> at least
23:54:05 <sarahzrf> you have one x, and several xs
23:54:17 <marmulak> ah so that's common practice to help the programmer
23:54:24 <sarahzrf> 👍
23:54:34 <sarahzrf> sometimes you may see xss for a list of lists
23:54:51 <marmulak> that second to last message of yours was blank on my screen
23:54:56 <sarahzrf> it's a thumbs up emoji
23:55:00 <marmulak> I'll have you know I'm using an ascii terminal
23:55:24 <marmulak> but I may switch back to matrix again soon
23:55:35 <sarahzrf> how anglocentric of you
23:55:50 <nineonine> is there a generic name for this law?  f ( g a ) = a
23:55:51 <nineonine> thanks
23:55:51 <marmulak> I was genuinely surprised/offended the first time I saw an emoji in IRC, and somehow gnome-terminal even displayed it correctly
23:56:08 <marmulak> I am not anglocentric, I prefer utf8
23:56:23 <sarahzrf> nineonine: you mean, the property of f and g that this is true for every a?
23:56:29 <nineonine> yes
23:56:32 <jle`> nineonine: it's difficult to say, unless you specify more
23:56:34 <sarahzrf> nineonine: "f is a left inverse of g"
23:56:36 <nineonine> exactly that
23:56:37 <marmulak> nineonine: the law of "f does nothing and g doesn't matter"?
23:56:40 <jle`> without any more info it's just an identity
23:56:52 <nineonine> yes i think it is identity
23:56:53 <nineonine> thanks
23:56:54 <jle`> ah yeah, if it's something true for all 'a', then you can say that
23:57:08 <jle`> no, i don't mean to say that it is identity, i mean to say that it's just an equation, heh
23:57:10 <jle`> like 1 + 2 = 3
23:57:21 <sarahzrf> marmulak: not sure why you'd be offended :o
23:57:27 <marmulak> hehe
23:57:30 <jle`> if you give it more interesting structure, like "for all x, f (g x) = x", then you have some sort of inverse relationship
23:57:46 <sarahzrf> geez i should get some sleep
23:57:58 <nineonine> interesting..
23:58:00 <jle`> nineonine: or, you can say "for all g, there exists an f such that for all x, f (g x) = x"
23:58:01 <marmulak> irc text is sacred, not to be defiled by graphical emojis
23:58:11 <nineonine> alright I will think about it
23:58:13 <nineonine> thank you
23:58:15 <jle`> that means that all functions in your domain are invertible
23:58:44 <jle`> just saying F (G A) = A is 'boring' in that you only say that it works for a specific f, a specific g, and a specific a
23:59:09 <jle`> but when you start quantifying, that's when things get interesting :)
