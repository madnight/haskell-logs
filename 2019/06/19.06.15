00:02:43 <jgt> I don't know optparse-applicative, but it seems like it's something specific to that library
00:02:49 <jgt> not part of the language
00:02:54 <MarcelineVQ> doesn't it also say in the example? the one I see does
00:04:47 <arahael> MarcelineVQ: No, it shows an example, though.  Is it just the use of the capitalized name? Ie, it's just a documentation thing?
00:05:02 <arahael> I'm using https://github.com/pcapriotti/optparse-applicative#quick-start
00:05:09 <MarcelineVQ> the help text of a parser --hello TARGET long "hello" <> metavar "TARGET" <> help "Target for the greeting" will look like: --hello TARGET Target for the greeting
00:05:41 <MarcelineVQ> oops *the help text of a parser long "hello" <> metavar "TARGET" <> help "Target for the greeting"
00:06:55 <arahael> I mean, what is the metavar *used* for?
00:07:13 <xacktm> pavonia: maybe an example can help, but I find explicit recursion and do-notation can bust through a lot
00:07:15 <MarcelineVQ> Showing in the help text. a metavariable stands in for a variable the user should supply, it exists to be more descriptive
00:07:38 <arahael> Ah, so it's literally just something that show as a metasyntatic variable?
00:08:40 <MarcelineVQ> I guess, idk what technical term is applicable :> in this lib this thing is called a metavariable regardless of other meanings
00:09:37 <arahael> Well, I actually see it as a fairly common thing - the python arg parser also had the same term, but I was still like, "What the heck is a "metavariable"?"
00:09:55 <arahael> I was thinking: "Is this a variable's variable?" :)
00:09:56 <MarcelineVQ> This is covered very lightly in the readme at https://hackage.haskell.org/package/optparse-applicative and a bit more plainly in the actualk metavar doc https://hackage.haskell.org/package/optparse-applicative-0.14.3.0/docs/Options-Applicative.html#v:metavar
00:11:17 <MarcelineVQ> heyyy, this quickstart thing does say what the metavariable does :< https://github.com/pcapriotti/optparse-applicative#parsers
00:11:17 <arahael> Thanks though - what you said was enough to clue me in :)
00:11:50 <arahael> Yeah, but: with long option name "hello", metavariable "TARGET", and the given help text...
00:12:07 <MarcelineVQ> if I wrote that section I'd have show what the help text looks like in full
00:12:09 <arahael> Just made me think: "Ok, great, so it has a TARGET metavariable, how does the user use that? Does it get exposed in fish-autocompletions or what?"
00:13:20 <arahael> Yeah, that'd probably help me too.  I did see some "descriptions" that used a TARGET metavariable (to use the term), but they did so explicitly, ie, `progDesc "Print a greeting for TARGET"`, so I was thinking: "Ok, it's not that, then".
00:22:55 <pavonia> xacktm: I'm trying a continuation based approach right now, which seems to work so far. The idea is to parse special LaTeX code in LaTeX comments as in this file: http://ftp.fau.de/ctan/macros/latex/contrib/l3kernel/l3flag.dtx
00:46:13 <arahael> With optparse applicative, how do I have an *optional* string parameter?
00:46:47 <arahael> Eg, I want to specify "--file foo.txt", but not require it. Eg, if I specify "--dir ./" instead, then Id on't want to have to specify --file.
00:46:49 <arahael> *don't.
00:47:11 <arahael> I thought changing the type of this argumetn to Maybe String would be enough, but it isn't.
00:52:50 <MarcelineVQ> Are those exclusive?
00:53:32 <arahael> MarcelineVQ: They can be, but I assumed that I should just parse the arguments firs,t and then apply business logic to how to interpret them.
00:53:37 <jgt> arahael: you might find better luck looking through code on GitHub. That's what I do when I'm not quite sure how to use some library/language
00:53:45 <Lears> arahael: It's been a while since I touched optparse-applicative, but I'd do something like `data Path = File String | Dir String; fileParser = File <$> ...; dirParser = Dir <$> ...; pathParser = fileParser <|> dirParser.
00:54:49 <MarcelineVQ> Lears' example is in the link you gave earlier so I was wondering if you meant something different
00:55:27 <arahael> MarcelineVQ: He's re-enforced that particular example, which is making me think that i need to compose these.  I can't just take the sample arg structure they give, and say: "This argument is an optional".
00:55:44 * hackage syb 0.7.1 - Scrap Your Boilerplate  https://hackage.haskell.org/package/syb-0.7.1 (SergeyVinokurov)
00:55:50 <arahael> Looks like I have to actually write somethign that results in a parser for a Maybe String, explicitly.
00:56:41 <Lears> You can do optional arguments with default values, but I don't know about making that depend on previously given arguments other than ... what are they called, sub-commands?
00:56:41 <arahael> I think after dinner, I need to look into writing a maybeStrOption, then.
00:56:44 * hackage hw-prim 0.6.2.27 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.6.2.27 (haskellworks)
00:56:59 <arahael> Lears: I don't want to use sentinel variables, though.
00:57:16 <arahael> Lears: Eg, I'd have to pick a default value that can't possibly be a valid name for a directory.
00:59:14 <arahael> So I think I need to do something like `Just strOption <|> nothing`
00:59:20 <arahael> (In very bad psuedo-code)
01:02:22 <arahael> I'll do that after dinner. :)
01:11:10 <MarcelineVQ> arahael: can make the value Maybe and use value Nothing as a parser option
01:12:08 <MarcelineVQ> so not providing the cli option simply places Nothing into your end datatype
01:12:29 <arahael> MarcelineVQ: Yeah, I gather that I can't naively use strOption, though, I'll have to wrap it.
01:12:41 <MarcelineVQ> option auto
01:12:53 <MarcelineVQ> was good enough for what I tried anyway
01:13:10 <arahael> Oh? auto unwraps the Maybe?
01:13:18 <arahael> I thought it just uses the Show interface, naively?
01:13:46 <arahael> (And by extension, would mean that I'd have to have the user provide: --dir 'Just "./"', which is rather sub-optimal.
01:13:47 <arahael> )
01:16:03 <MarcelineVQ> uinwrap? no, I don't think so. but strOption has an IsString constraint and my ghci didn't think Maybe Int was an IsString
01:16:58 <MarcelineVQ> why would you user have to provide 'Just
01:17:33 <MarcelineVQ> hang on, ehe, I didn't try a non-nothing, let's see what this takes
01:18:19 <MarcelineVQ> ah I see
01:23:16 <MarcelineVQ> arahael: looks a little silly, kind of expect there's another way: option (maybeReader (Just . readMaybe)) ...
01:24:44 * hackage hw-packed-vector 0.0.0.3 - Packed Vector  https://hackage.haskell.org/package/hw-packed-vector-0.0.0.3 (haskellworks)
01:24:59 <MarcelineVQ> Has a weird side effect of accepting Nothing and 2 as valid inputs :X
01:25:24 <MarcelineVQ> when the final type is to be Maybe Int
01:25:41 <arahael> MarcelineVQ: Yeah, I think i need to expicitly write a parser that copes with a Maybe.
01:25:56 <MarcelineVQ> Oh, right, that's because any string is Nothing wrong Nothing isn't special hehe
01:26:47 <arahael> Right. :(
01:50:11 <MarcelineVQ> oh, I wasn't fmapping
01:50:40 <MarcelineVQ> arahael: option (maybeReader (fmap Just . readMaybe)) should have more reasonable behavior
01:58:21 <arahael> Awesome, I'll try that!  I've been sucked into playing board games so will have to pause this for now.
02:09:21 <MarcelineVQ> arahael: ah, other programs use optional, to satisfy the datatype but let you parse as though there isn't Maybe. optional (strOption ...)
02:10:43 <gentauro> anybody using stack?
02:10:53 <gentauro> I just updated to 2.1.1 and now my script don't run anymore :(
02:11:14 <gentauro> I get this annoying message: "Cannot determine project root directory for Docker sandbox."
02:11:28 <gentauro> `stack --resolver lts-13.19 script Main.hs`
02:11:46 <gentauro> I mean, what the hech does Docker have to do with a script? (am I missing something?)
02:13:20 <Rembane> Is that command line everything you do? No stack.yaml? No global stack.yaml?
02:13:21 <gentauro> maybe it's worth saying that I don't even have Docker installed on my box ...
02:14:06 <gentauro> Rembane: yes, no local stack.yaml and global looks like this (several lines)
02:14:09 <gentauro> packages: []
02:14:09 <gentauro> resolver: lts-13.19
02:14:09 <gentauro> nix:
02:14:09 <gentauro>   packages:
02:14:11 <gentauro>     - zlib
02:15:08 <Rembane> gentauro: That is indeed a mystery.
02:16:36 <gentauro> Rembane: tried to add these lines to the global stack.yaml
02:16:37 <gentauro> docker:
02:16:38 <gentauro>   enable: false
02:16:43 <gentauro> but still same error ...
02:18:00 <Rembane> gentauro: can you use that option on the command line? And make it ignore all config files?
02:18:59 <gentauro> Rembane: all my script rely (relied?) on the `~/.stack/global-project/stack.yaml`
02:20:04 <gentauro> luckily all my script as just on my laptop and none is in PROD, otherwise I would be pretty busy ...
02:20:21 <gentauro> s/as/are/
02:20:27 <Rembane> gentauro: Got it. Will they stop work in another way when you don't use a config file?
02:20:54 <gentauro> Rembane: Sorry, I don't understand your question :( What do you mean with config file?
02:21:14 <Rembane> gentauro: Stack uses at least one config file per default and I wonder if some global version of it is broken in this new release.
02:22:23 <gentauro> Hmmm, I will try to rename the old folder to see if it creates a new "default" one
02:23:22 <gentauro> nope, didn't help :(
02:23:42 <Rembane> Then I'm out of ideas. Hopefully someone else knows something about this.
02:25:07 <gentauro> Rembane: Thx anyway :)
02:25:17 <Rembane> gentauro: No worries, good luck! ^^
02:25:28 <gentauro> Note: The only thing that is added to the new ~/.stack/config.yaml is the color thingy
02:26:22 <gentauro> Rembane: note to self, never update anything Haskell related before a conf (Monadic Party in Poland) xD
02:27:02 <Rembane> gentauro: :D
02:32:55 <ocharles> Is there anyway way to have GHC warn me when I write `instance Applicative M where pure = return` and `instance Monad M where x >>= f ...`? That is, my Monad instance has no explicit implementation of `return`, which means `return = pure`... but I just wrote that `pure = return` in the Applicative instance!
02:33:14 <arahael> MarcelineVQ: Thanks for that!
02:33:23 <arahael> MarcelineVQ: What program was that, btw, so I could use them as a reference?
02:33:34 <MarcelineVQ> stack
02:33:45 <Rembane> ocharles: Out of pure curiousity, what happens when you compile that? 
02:33:56 <ocharles> GHC is fine with it
02:33:59 <MarcelineVQ> in a couple places iirc Main.hs is where I saw first
02:33:59 <arahael> MarcelineVQ: Awesome :)
02:34:00 <ocharles> It just loops at runtime
02:34:05 <Rembane> Got it! "Fun!"
02:34:26 <oo_miguel> I am playing with mtl and wonder what is the difference between running "runState (runReaderT myFunc env) state" and "runReader (runStateT myfunc state) env". Both produce exactly the same result
02:34:43 <arahael> MarcelineVQ: Very very nice. :)
02:36:31 <Rembane> oo_miguel: AFAIK they are the same. Some of the monad transformers are commutative.
02:36:45 <Rembane> oo_miguel: Or rather some combinations of the monad transformers...
02:37:15 <oo_miguel> Rembane: ok I see. are there other combinations where it would make a difference?
02:37:17 <MarcelineVQ> arahael: they also use fromMaybe for a default value, I'm not sure why in particular
02:37:50 <Rembane> oo_miguel: ExceptT is known to behave in interesting ways, ContT too. 
02:38:08 <arahael> MarcelineVQ: Good tip.
02:38:16 <MarcelineVQ> But that could be just due to how they've got it set up, I've not looked at the datatypes
02:38:43 <arahael> Yeah, I intend to check it out.
02:38:52 <oo_miguel> Rembane: ok I will experiment with ExceptT and have a look at ContT (never used that one before). thank you
02:39:01 <arahael> Slowly getting used to obsessively keepign ghci open and doing :t on all the things. 
02:39:59 <MarcelineVQ> arahael: Config.hs has examples in a more digestable form, no fromMaybe though
02:40:16 <arahael> Awesoe - this in stack, too?
02:40:33 <MarcelineVQ> ye
02:40:56 <arahael> Thanks. :)  I should get focused on this game before my wife gets too annoyed with my inattention, but thanks heaps for all that!
02:41:06 * arahael is currently playing board games.
02:41:18 <arahael> And will get to the coding afterwards.
03:00:26 <oo_miguel> Just came across another mtl question. For instance given two functions that run in the context of two different environments (via MonadReader), how can I run a function that makes use of both of these? I tried "runState (runStateT fenv12 env1) env2" does not do what I expect (It does not even compile). https://paste.debian.net/1087911/
03:03:25 <Rembane> oo_miguel: Your pastebinned code will work better if you use runReaderT on it.
03:03:33 <oo_miguel> aaaaaa
03:04:00 <oo_miguel> how emberassing :)
03:04:38 <Rembane> It's a very easy mistake to make. :)
03:07:19 <oo_miguel> thanks :) .. still with "runReader (runReaderT fenv12 env1) env2" i am missing something.
03:08:08 <Rembane> oo_miguel: Do you have a complete minimal example? Then I can try it and ask my GHC for advice.
03:09:27 <oo_miguel> sure, just a minute....
03:12:16 <oo_miguel> https://paste.debian.net/1087913/
03:12:37 <oo_miguel> uncommented the line that causes GHC to complain.
03:12:46 <Rembane> Sweet! 
03:17:36 <oo_miguel> slightly improved version: https://paste.debian.net/1087914/ (There was an unrelated ghc error in the first one, after uncommenting the line in question)
03:19:46 <Rembane> Thnak you! 
03:20:41 <oo_miguel> You are the one helping ME, so I thank you ;)
03:21:28 <oo_miguel> also, maybe what I try to accomplish is not possible and I have to restrucutre fenv12... 
03:21:39 <oo_miguel> hmmm
03:21:46 <jgt> is there a way to see where GHC is spending most of its time?
03:22:26 <oo_miguel> jgt: when compling your code? Or do you want to benchmark the resulting binary?
03:22:36 <Rembane> oo_miguel: I think that might be the issue. :)
03:23:56 <jgt> oo_miguel: I'm interested in reducing compilation time. I think RTS is pretty well-documented.
03:25:00 <oo_miguel> yeah I am only familiar with RTS. thought I might help you... but in this case, sorry
03:25:34 <jgt> np :)
03:25:59 <Rembane> oo_miguel: https://gist.github.com/Rembane/9ac6e8b94388770ff5195c1370e7a5e6 what about this? 
03:26:29 <Rembane> oo_miguel: ...is that a useful solution to your problem?
03:27:18 <oo_miguel> Rembane: yeah, I was suspecting something similiar. but thank you for confirming this and giving a working solution! :)
03:27:35 <Rembane> oo_miguel: No worries. :) You could also put the environment of one reader into the environment of the other reader. 
03:27:59 <oo_miguel> However I do not fully understand the reason (the thing about functional deps).
03:28:48 <Rembane> oo_miguel: fundeps make it possible to automatically pick the right level in the transformer stack.
03:29:02 <Rembane> oo_miguel: compare with transformers where you have to do lift to the right level yourself.
03:30:54 <oo_miguel> ok, thank you very much. Your solution works fine for my use case. just a little extra boilerplate code. thank you!
03:31:02 <Rembane> No worries! Good luck! 
04:12:11 <arahael> MarcelineVQ: Ok, I'm back into it.  It's _better_, but isn't quite there yet.  I'm still looking into it but I think I have enough direction (unless you're super keen to help!)
04:12:22 <arahael> MarcelineVQ: Basically, I have to double-quote the arguments now.
04:12:33 <arahael> And I'd rather not quote it at all. :)
04:12:54 * arahael checks out the stack examples.
04:29:04 <arahael> MarcelineVQ: Ended up with `option (fmap strToMaybeText readerAsk)`, mostly by following hoogle, the code in https://hackage.haskell.org/package/optparse-applicative-0.14.3.0/docs/src/Options.Applicative.Types.html#ReadM, and following the types with type holes. :) Works beautifully!
04:30:02 <_zincy> Does anyone understand this servant error. I am struggling to add middleware to enable OPTIONS requests - https://pastebin.com/w34mBzrH    https://github.com/therewillbecode/haskell-poker/blob/options/server/src/API.hs#L35
04:34:18 <jgt> _zincy: does Servant not run in WAI?
04:38:23 <_zincy> jgt: I thiiink so
04:41:55 <jgt> _zincy: iirc there's some WAI middleware you can plug in that'll enable this stuff. I think it's in wai-extra.
04:42:23 <jgt> but then, I'm not sure if that's site-wide, or if you care about only enabling this in one place
04:47:16 <_zincy> jgt: The error seems to allude to there being a specification for requests with NoContent ? What do you think
04:47:26 <_zincy> *being no specification
04:48:58 <jgt> oh I didn't realise you're already using the middleware. Yeah, I don't know; I haven't spent any time with Servant
04:50:16 <_zincy> I am beginning to thank my past self for mucking around with type level stuff now I am reading the servant docs
04:58:33 <_zincy> I also wonder the extent to which code generation is possible for the front end from a servant back end. 
05:06:14 * hackage yesod-form-bootstrap4 2.1.2 - renderBootstrap4  https://hackage.haskell.org/package/yesod-form-bootstrap4-2.1.2 (ncaq)
05:51:14 <kuribas> what would be faster, floating point calculations, or Ratio Int?
05:51:36 <kuribas> I would think Ratio because it has to do more instructions...
05:57:00 <Heffalump> if I want to interact with a git repository from haskell (read it, create new commits) am I better off using one of the library bindings or just shelling out to git?
06:14:25 <__monty__> kuribas: Depends on what you need, if you can do without the headache of floats that'll save you a lot of trouble.
06:14:59 <__monty__> kuribas: And Rational is probably slower in most cases. Floats are weird because they're implemented in fast hardware.
06:15:29 <kuribas> yeah, floats are really slow, but they are fast because of the amount of money and manhours put into making them fast :)
06:16:40 <__monty__> That's not true, floats have never been "slow." Not much else even did "real" arithmetic afaik.
06:17:04 <kuribas> __monty__: slower than integers
06:17:27 <[exa]> Heffalump: probably depends on how complicated tasks you need and how much trouble you'll have parsing the output from command stdout
06:18:00 <kuribas> __monty__: on older hardware they are a large factor slower
06:18:02 <__monty__> kuribas: That's like saying a truck is slower than a car. They have different purposes.
06:19:22 <Heffalump> [exa]: I want to get the trees and metadata for existing commits and create new commits somehow
06:21:37 <kuribas> btw, does anyone what algorihm approxRational uses?
06:21:42 <kuribas> continued fractions?
06:21:48 <kuribas> :t approxRational
06:21:50 <lambdabot> RealFrac a => a -> a -> Rational
06:23:39 <kuribas> it's also broken...
06:24:05 <kuribas> > approxRational (1e-20/3) (1e-30/3)
06:24:08 <lambdabot>  1 % 299999999970000005078
06:24:14 <kuribas> 1 / 299999999970000005078
06:24:17 <kuribas> > 1 / 299999999970000005078
06:24:20 <lambdabot>  3.333333333666667e-21
06:24:39 <kuribas> 1 / 300000000000000000000
06:24:42 <kuribas> > 1 / 300000000000000000000
06:24:45 <lambdabot>  3.3333333333333333e-21
06:24:58 <kuribas> (1e-20/3)
06:24:59 <kuribas> > (1e-20/3)
06:25:02 <lambdabot>  3.3333333333333333e-21
06:25:50 <kuribas> So the right answer is 1 / 300000000000000000000, not 1 % 299999999970000005078
06:28:16 <taiite> :t (%)
06:28:18 <lambdabot> Integral a => a -> a -> Ratio a
06:28:39 <__monty__> I think you're not quite grasping what approxRational does.
06:29:10 <__monty__> I'm not sure those divisions don't default to Double, so I'm not sure what point you're trying to get across.
06:30:38 <__monty__> approxRational takes x-epsilon and x+epsilon and picks the "simplest" of the two, according to its simplicity criterion which is just "take the smaller if it's a perfect fraction."
06:32:27 <kuribas> __monty__: it doesn't pick the simplest in between the two?
06:33:07 <kuribas> > approxRational (1e-20/3) (1e-30/3)
06:33:09 <lambdabot>  1 % 299999999970000005078
06:33:51 <__monty__> Yes it does, hadn't read that case properly.
06:34:28 <kuribas> hmm, 299999999970000005078 is indeed smaller
06:34:40 <kuribas> so I guess it's right then...
06:37:53 <Lycurgus> df -h
06:38:00 <Lycurgus> sorry
06:47:28 <NotTyZeff> Heyllo
06:48:32 <NotTyZeff> hello
06:49:08 <NotTyZeff> before
06:49:14 <NotTyZeff> i go outside
06:49:20 <NotTyZeff> i need help
06:49:27 <NotTyZeff> ty
06:51:53 <NotTyZeff> Bonjour
06:53:47 <NotTyZeff> ....
06:54:01 <Rembane> NotTyZeff: What do you need help with?
06:54:13 <NotTyZeff> ha
06:54:16 <NotTyZeff> ty
06:54:35 <NotTyZeff> i want to join
06:54:54 <NotTyZeff> the chat #anonypous
06:56:49 <NotTyZeff> i want to join
06:56:59 <NotTyZeff> Anonymous
06:57:03 <NotTyZeff> ^^
06:57:10 <NotTyZeff> thiis is clear
06:57:14 <NotTyZeff> ?
06:57:34 <lyxia> @where ops
06:57:34 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw mniip monochrom quicksilver shachaf shapr ski
06:58:03 <NotTyZeff> @ops sleeping
06:58:03 <lambdabot> Maybe you meant: pl oeis docs
06:58:05 --- mode: ChanServ set +o glguy
06:58:13 <glguy> NotTyZeff: Can you stop that please?
06:58:26 <NotTyZeff> wwhat? sorry
06:58:33 <glguy> This channel is for discussing Haskell, not any of the stuff you're been writing so far
06:58:37 <NotTyZeff> i vneed information
06:59:23 <NotTyZeff> give me information, i will quit
07:00:26 <delYsid``> *PLONK*
07:00:55 <NotTyZeff> *OK*
07:03:23 <NotTyZeff> -Are you all , sleeping?
07:03:53 <NotTyZeff> Anonymous is just composed by cats?
07:04:00 <Lycurgus> no we are ignoring ur dumb ass except for me
07:04:05 --- mode: glguy set +q *!*@37.165.184.179
07:08:01 * [exa] remembers good old days when IRC wasn't vintage, cool, cyberpunk and matrix-ish
07:17:17 <Batholith> [exa]: implying that there ever was a time when IRC wasn't cool, cyberpunk and matrix-ish
07:29:05 <higherorder> Hello. Quick question: is a function of type `forall x. a -> r` in Haskell always constant? e.g. as part of the type signature `elimAny :: (forall a . a -> r) -> Any -> r`
07:30:57 <kosmikus> higherorder: yes
07:31:37 <higherorder> kosmikus: ty
07:31:40 <kosmikus> not quite sure why you're quantifying over x which then doesn't appear.
07:31:57 <[exa]> looks like a typo for 'a'
07:32:02 <kosmikus> but in the elimAny example, the argument must be a constant function
07:32:17 <kosmikus> (or undefined, which isn't even a function)
07:42:29 <higherorder> kosmikus: [exa] it was indeed a typo for "a"
07:43:20 <Zemyla> I wish there were a GADT type like :~: or Coercion that served as a witness that, if (m :: Nat) <= (n :: Nat), then a value of type LessThanEqual m n exists.
07:43:39 <Zemyla> It'd be a Category, since (a) n <= n for all n, and (b) if m <= n, and n <= p, then m <= p.
07:46:58 <infinisil> 06:51:24 <dmj`> infinisil: free monad could work, or make a binary instance of your AST 
07:47:08 <infinisil> dmj`: I mean Haskell's AST directly
07:47:40 <infinisil> Like, if I were to write a function `f n = n * n`, it would hash to a different value than `f n = n * n + 1`
07:48:50 <infinisil> Context: I want to hash a function implementation, so I can use that hash as a key to a cache of its results. If the function implementation changes, all previously calculated results become invalid then and it needs to be recomputed
07:49:45 <Welkin> use template haskell to grab the source as a string
07:50:22 <Welkin> what you are doing sounds convoluted though
07:56:01 <dmj`> infinisil: can you represent the hash function as a matrix
07:56:27 <infinisil> Welkin: Sure is, but I think it would be cool if it works
07:56:34 <infinisil> dmj`: Not sure what you mean
07:57:10 <infinisil> Ah yeah actually I was just looking into templateHaskell last evening, I think it should be possible by using Dec's Show instance to get a string and hash that
07:58:09 <infinisil> Hacky but I like it lol
07:58:13 <infinisil> Will try it out later
08:03:46 <zacts> is there still a haskell beginners channel?
08:06:55 <infinisil> zacts: Not sure, but I don't think anybody will mind if you ask beginner questions here
08:07:01 <zacts> ok
08:07:31 <zacts> ah it's still around
08:07:33 <zacts> too
08:07:35 <zacts> cool
08:07:50 <zacts> infinisil:  is haskellbook.com still recommended?
08:09:14 * hackage terminal-progress-bar 0.4.1 - A progress bar in the terminal  https://hackage.haskell.org/package/terminal-progress-bar-0.4.1 (RoelVanDijk)
08:09:26 <infinisil> No idea (and probably better to direct this question towards the channel, not me)
08:09:33 <zacts> ok
08:10:14 * hackage proto-lens 0.5.1.0 - A lens-based implementation of protocol buffers in Haskell.  https://hackage.haskell.org/package/proto-lens-0.5.1.0 (JudahJacobson)
08:15:07 <infinisil> Um what, ok then
08:15:26 <infinisil> I guess they probably got a response in the beginners channel
08:21:40 <Batholith> just smile and wave, bud. just smile and wave. I already put my hands in the air the first time he responded with "ok". there's something about people who respond with just "ok"
08:25:44 * hackage xmlbf 0.6 - XML back and forth! Parser, renderer, ToXml, FromXml, fixpoints.  https://hackage.haskell.org/package/xmlbf-0.6 (RenzoCarbonara)
08:54:53 <Kerfluffle> Hey, can someone remind me what the "@Type" syntax is called? Not binding pattern matches.
08:55:10 <monochrom> TypeApplication
08:55:34 <tdammers> https://gitlab.haskell.org/ghc/ghc/wikis/type-application <- Kerfluffle
08:55:45 <Kerfluffle> Thanks a lot! Just needed the name to look it up.
09:01:04 <solonarv> Axman6: YellowOnion: actually TMVar is implementas as 'newtype TMVar a = TVar (Maybe a)' ;) - it just exposes a different API
09:01:58 <solonarv> Zemyla: you could just write it yourself: data n :<=: m where LTE :: (n <= m) => (n :<=: m)
09:31:12 <jerv> I've got f :: [Int] -> IO Int and g :: Maybe Int -> IO Int. I'd like to create a function that returns one of both depending on a flag. I figured I can generalize on the fact that they're functors. However, I get rigid type variable exceptions. I tried continuation passing style but cannot get it to work. Snippet: 
09:31:16 <jerv> https://gist.github.com/jvaelen/4f9770722372982b05e9d1a558aa61cc
09:32:42 <jerv> It was my understanding that the continuation style allows me to get by the forall nature of f
09:32:51 <Welkin> use explicit forall
09:33:41 <jerv> Welkin: I also cannot get that right, let me send you an updated snippet. https://gist.github.com/jvaelen/4f9770722372982b05e9d1a558aa61cc
09:33:57 <jerv> Same compile error
09:34:16 <jerv> I would imagine this puts the question the caller, but it's the function itself that is not compiling
09:34:35 <Welkin> post the error
09:34:53 <Welkin> you may need to enable ScopedTypeVariables
09:35:25 <jerv> Welkin: added a comment: https://gist.github.com/jvaelen/4f9770722372982b05e9d1a558aa61cc
09:35:34 <jerv> Interesting
09:35:52 <Welkin> try it
09:36:45 <jerv> Same error
09:38:44 <Welkin> it is always an Int in your implementation
09:38:57 <Welkin> just make the a an Int
09:39:17 <Welkin> it's unclear why are you writing this code though
09:40:23 <Welkin> alternatively you can remove the type signature and ask the compiler what it is
09:40:44 <Welkin> typed holes can also help, though I don't recall how to use them
09:40:47 <jerv> Welkin: this is just a repro of a real problem
09:41:30 <jerv> In my actual code it's not functors but some other monad
09:41:44 * hackage git-annex 7.20190615 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-7.20190615 (JoeyHess)
09:41:55 <Welkin> I still don't get the point
09:42:01 <Welkin> why not apply the functions directly?
09:42:11 <Welkin> instead of all this extra work
09:42:45 <Welkin> you know you can partially apply functions
09:43:04 <Welkin> if you need to provide some standard interface, use a typeclass
09:43:56 <Welkin> even a type family could work here
09:44:10 <Welkin> I have no context for what you're trying to do though
09:44:15 <jerv> Welkin: let me try to make the repro a bit more contextual
09:49:50 <infinisil> jerv: You need to put the forall one level higher
09:50:05 <infinisil> jerv: Bool -> (forall f a . Functor f => (f a -> IO a) -> IO b) -> IO b
09:50:14 <infinisil> And include a in it too
09:51:39 <jerv> Holy smokes that does do the trick, thanks infinisil!
09:52:29 <Welkin> I didn't even notice that
09:56:32 <infinisil> Man, gotta love how expressive you can be with the type system in haskell
09:57:08 <infinisil> For a current project I'm able to guarantee algorithm correctness just with some clever forall's
10:00:07 <Welkin> you can go really crazy with it and using singletons for dependent types (not recommended) and use type-level lists, strings, etc
10:00:49 <Welkin> I tend to use as little as necessary to avoid over complicated solutions
10:00:57 <infinisil> Yeah I'm trying too
10:01:21 <infinisil> If I want to go crazy though, I'd try to use Idris. It's much nicer to work with type-level magic there
10:01:35 <Welkin> haskell is getting linear types too
10:02:02 <infinisil> Isn't that mostly orthogonal to dependent typing though?
10:02:07 <Welkin> not any more
10:02:18 <Welkin> there is a way to unify them that was discovered
10:02:32 <Welkin> or at least use them together
10:03:08 <Welkin> I haven't read the super long paper on it
10:03:32 <Welkin> I'm not the most knowledgable on the mathematical details either
10:03:55 <Welkin> https://gitlab.haskell.org/ghc/ghc/wikis/linear-types
10:03:59 <[exa]> Welkin: the 'super long paper' is the SPJ's one from last year or is there something new?
10:04:49 <Welkin> I'm trying to find it
10:05:36 <Welkin> yeah, the SPJ one
10:05:37 <Welkin> https://www.microsoft.com/en-us/research/wp-content/uploads/2017/03/hlt.pdf
10:08:41 <[exa]> wow the gitlab link is great
10:11:31 <infinisil> > Does this proposal improve performance? No.
10:11:34 <lambdabot>  <hint>:1:44: error:
10:11:34 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
10:11:48 <infinisil> But after that they mention how it can make things faster
10:12:14 <infinisil> So if libraries use linear types, everybody that uses them does get better performance
10:13:00 <Welkin> where parallelisation is used in my reading of it
10:13:22 <Welkin> instead of using ST to mutate an array
10:23:40 <nshepperd> it doesn't improve performance so much as allow more performant things to be implemented
10:23:56 <nshepperd> i suppose
10:27:01 * nshepperd doesn't really want linear types tbh
10:27:14 <gobby> does anybody have experience with deploying a haskell web app to heroku via a build pack?
10:27:38 <nshepperd> deciding whether every function should be linear and how seems like it'll be a lot of work for very little reward
10:27:48 <gobby> getting this error: `The current entry points to /app/ but no .cabal or package.yaml file could be found there.`
10:33:24 <Welkin> compile and push the binary over scp
10:33:44 * hackage haskell-gi 0.22.5 - Generate Haskell bindings for GObject Introspection capable libraries  https://hackage.haskell.org/package/haskell-gi-0.22.5 (inaki)
10:36:29 <jerv> infinisil: returning to Bool -> (forall f a . Functor f => (f a -> IO a) -> IO b) -> IO b ; is there a way to make the f type variable available in the body of the function here?
10:40:10 <Welkin> yes
10:40:18 <Welkin> using Scoped Type Variables
10:40:40 <gobby> Welkin: I would also need a `Procfile` to execute the binary right?
10:40:50 <Welkin> although it may not work because that forall is nested
10:41:05 <Welkin> gobby: I don't use heroku
10:41:19 <gobby> Welkin: What do you use?
10:41:27 <Welkin> most people use it to deploy scripting languages, which requires no compilation
10:41:31 <Welkin> for haskell you need to compile it first
10:42:13 <Welkin> nothing, I just deploy with a bash script, or use keter. there's lots of other options like nixops, or puppet, ansible
10:42:39 <Welkin> the procfile on heroku is basically a shell script
10:43:51 <gobby> Welkin: what cloud provider do you use?
10:45:43 <Welkin> who cares?
10:45:45 <Welkin> anything works
10:45:59 <Welkin> aws (pricey), digital ocean, linode, vultr, etc
10:48:35 <infinisil> jerv: That won't make any sense, in the `withFunctor` function, you're deciding what f should be
10:48:57 <infinisil> The implementation of the function can call cont with whatever f it wants
10:49:47 <infinisil> jerv: Where it would make sense to get f in scope is in the `\functor -> putStrLn "hello"` part
10:50:23 <infinisil> doIt :: forall f a . Functor f => (f a -> IO a) -> IO b
10:50:38 <infinisil> With ScopedTypeVariables you'll have f and a in scope
10:50:49 <jerv> infinisil: my next question might not make sense because I'm in over my head, but is there a way to use whatever we decide is `f` in the body as a type?
10:51:03 <jerv> Like Proxy :: f
10:51:08 <infinisil> jerv: The body of what?
10:51:43 <infinisil> The continuation? Yes, that's what I'm saying with the doIt thing
10:51:44 * hackage gi-atk 2.0.20 - Atk bindings  https://hackage.haskell.org/package/gi-atk-2.0.20 (inaki)
10:52:27 <jerv> withFunctor $ \functor -> f functor , f :: (forall f a. Functor f => (f a -> IO a)) in the body of f\
10:52:44 <hackage> ACTION gi-xlib 2.0.7, gi-wnck 3.0.6, gi-webkit2webextension 4.0.23, gi-webkit2 4.0.24, gi-vte 2.91.24, gi-soup 2.4.21, gi-secret 0.0.10, gi-poppler 0.18.20, gi-pangocairo 1.0.22, gi-pango 1.0.21, gi-ostree 1.0.11, gi-notify 0.7.20, gi-javascriptcore 4.0.20, gi-handy 0.0.5, gi-gtksource 3.0.21, gi-gtk 3.0.31, gi-gstvideo 1.0.21, gi-gsttag 1.0.20, gi-gstpbutils 1.0.20, gi-gstbase 1.0.21, gi-gstaudio 1.0.20, gi-gst 1.0.21, gi-gobject 2.0.21, gi-glib 2.0.2
10:52:47 <jerv> Anyway I need to first understand this stuff better, I'm just hacking on stuff I really do not quite understand fully right now
10:54:10 <jerv> The compiler complains when I use f that: Couldn't match kind ‘* -> *’ with ‘*’. Which confuses me because f should be a type ctor. It must be because of what you said that it is instantiated?
10:54:16 <infinisil> jerv: You mean without another `where` clause?
10:56:10 <infinisil> jerv: https://gist.github.com/da4965ac8a5b4f80842440c8a2e2a879
10:56:52 <jerv> Ah interesting
10:56:58 <infinisil> (Oh forgot the functor though)
10:57:35 <jerv> right
10:57:46 <infinisil> Note that you can't actually implement continuation there though
10:58:18 <infinisil> jerv: Should probably be this instead: https://gist.github.com/71a8c4bf2faa053c843f38b000356617
10:59:29 <infinisil> Still can't be implemented though
10:59:49 <infinisil> Well it can, but not in any useful way
10:59:58 <infinisil> And still, I have no idea where you're going with this :)
11:00:03 <infinisil> Or trying to go
11:02:58 <jerv> infinisil: your last gist got me to compile this thing!
11:03:33 <jerv> Sorry the repro is so cryptic, the reality is a server with different possible handlers, but it involves too much boiler plate to really make work for my question
11:03:51 <infinisil> Hehe I see
11:03:54 <jerv> Now I will actually dive in and try to understand all of this
11:03:59 <jerv> Thanks a lot!
11:06:46 <alanz> Any stack people here? 2.1.1. In tests for a  project I am getting "Loaded package environment from /tmp/stack14358/test-ghc-env". The dir is the same for a given run. Is there some command I can give to get that directory?
11:07:47 <alanz> oops, asked on #haskell-stack instead. Sorry
11:08:12 <infinisil> jerv: Np :)
11:27:03 <infinisil> Hm so the template-haskell thing to hashify a function implementation doesn't quite work
11:27:27 <infinisil> This is what a function `f x = x` gets stringified to: "VarI Arvy.f (ForallT [KindedTV a_6989586621679080940 StarT] [] (AppT (AppT ArrowT (VarT a_6989586621679080940)) (VarT a_6989586621679080940))) Nothing"
11:27:53 <infinisil> Those a_...'s there change all the time
11:29:55 <infinisil> Oh and actually, this doesn't even include the implementation, only the type
11:30:02 <infinisil> So that's not gonna work
11:39:21 <infinisil> "The Maybe Dec field contains Just the declaration which defined the variable -- including the RHS of the declaration -- or else Nothing, in the case where the RHS is unavailable to the compiler. At present, this value is _always_ Nothing: returning the RHS has not yet been implemented because of lack of interest."
11:39:40 <infinisil> All hope is lost
11:46:09 <mjrosenb> is template haskell packaged with ghc?
11:46:32 <glguy> Yes
11:49:16 <mjrosenb> iiinteresting.
11:49:30 <mjrosenb> how do I find out what version is bundled with a given ghc?
11:51:07 <glguy> ghc-pkg list template-haskell
11:51:22 <glguy> https://www.haskell.org/platform/contents.html is another good way
11:53:04 <mjrosenb> thanks!
12:03:36 <mjrosenb> hrm, I've mostly been asking in #nixos, but I'm trying to build some code with nix, and I'm running into issues because a library wich is a transitive dependency of my code depends on an older version of ghc
12:04:02 <mjrosenb> and I don't know how to tell nix to use a newer version of that package
12:08:02 <dminuoso> mjrosenb: Which library is that?
12:08:31 <mjrosenb> generics-sop: https://gist.github.com/mjrosenb/355dca220345585cd32eebdcc39db944
12:10:12 <kosmikus> mjrosenb: and what's the dependency that doesn't allow generics-sop-0.4.* or 0.5.* ?
12:10:31 <mjrosenb> kosmikus: nothing that I know of.
12:10:59 <dminuoso> kosmikus: I assume that version might come from his nixpkgs.
12:10:59 <kosmikus> then I don't understand
12:11:26 <kosmikus> current nixpkgs has 0.5.0.0
12:11:42 <dminuoso> kosmikus: My point is, perhaps his channel is far from up-to-date. :)
12:12:43 <mjrosenb> yes, I'm using this because ghcjs is a *royal* pain to get working from what I can tell: https://gist.github.com/mjrosenb/d79e861f9eba854a9ac672e61f9226d1
12:13:33 <MarcelineVQ> I think reflex comes with a nix environmen that sets up ghcjs
12:15:17 <mjrosenb> so, I'm trying to get the haskell integration for emacs working, which requires all of the dependencies to be present for x86 and javascript in the same environment.
12:28:50 <isovector1> has anyone gotten doctest working with custom type errors?
13:06:34 <__monty__> mjrosenb: You can override or overlay the package that depends on generics-sop with `doJailbreak`. That would allow a newer generics-sop. Or you could override generics-sop with callHackage.
13:06:49 <__monty__> mjrosenb: Actually, you might need to do both.
13:21:05 <vijaytadikamalla> hi
13:21:27 <vijaytadikamalla> i want to find a something in a map
13:21:36 <vijaytadikamalla> Map.lookup (Scalar _ b) map
13:21:59 <vijaytadikamalla> somewhat like this
13:22:27 <dminuoso> % :t fold
13:22:27 <yahb> dminuoso: (Foldable t, Monoid m) => t m -> m
13:22:31 <dminuoso> % :t find -- vijaytadikamalla 
13:22:31 <yahb> dminuoso: ; <interactive>:1:1: error:; Ambiguous occurrence `find'; It could refer to either `Data.Text.find', imported from `Data.Text'; or `Data.List.find', imported from `Data.List' (and originally defined in `Data.Foldable')
13:22:42 <dminuoso> % :t Data.Foldable.find
13:22:42 <yahb> dminuoso: Foldable t => (a -> Bool) -> t a -> Maybe a
13:27:26 <dminuoso> firef
13:47:46 <ggVGc> dminuoso: good job :)
14:08:11 <infinisil> mjrosenb: Got the trouble with Nix Haskell deps sorted yet?
14:20:02 <qwebirc61983> dubug
14:20:05 <qwebirc61983> debug
14:50:16 <lestrado> hello, how do you write the version bounds for a new package you start
14:50:36 <lestrado> do people actually test their package works with version bounds?
14:50:59 <lestrado> i am talking about dependencies
14:53:55 <dmj`> lestrado: stackage snapshots have kind of obviated this problem, but it's good practice to put upper bounds and lower bounds on the major versions of your package deps. 
14:54:03 <dmj`> lestrado: https://pvp.haskell.org/
14:57:02 <lestrado> dmj`: so do people not write cabal files when using stackage?
14:57:37 <solonarv> they do, but some people don't put version bounds in them
14:57:45 <dmj`> lestrado: stack automatically generates them using hpack if you use a package.yaml iirc
14:58:20 <solonarv> hpack doesn't add version bounds if you didn't specify them already
14:58:40 <solonarv> peronsally, I don't use stack
14:58:57 <lestrado> i don't really want to use hpack but i do use stackage and would like to make it work wihtout stack 
14:59:13 <lestrado> i think i am just going to put x.y.*
14:59:14 <solonarv> when I start a new package (or actually anytime I add a new dependency to a package) I run 'cabal gen-bounds' to have it figure out a conservative set of version bounds
14:59:55 <solonarv> I don't think that will work if you want to stick to a stackage snapshot, though
15:00:19 <dmj`> lestrado: nothing wrong with calling `cabal info <package>`, checking the upper bound and specifying it manually either
15:01:00 <lestrado> solonarv: i am just going to pick the versions in stackage currently
15:01:25 <solonarv> generally conservative version bounds look like this: foo >= x.y.z && < x.(y+1)
15:01:51 <solonarv> sometimes you omit .z, of course
15:02:07 <solonarv> you can also write this as: foo ^>= x.y.z
15:04:11 <lestrado> solonarv: nice, i am just going to use that for packages from stackage lts :)
15:05:14 <monochrom> Hey, "gen-bounds" sounds handy.
15:05:28 <monochrom> (I have always handwritten the conservative bounds myself.)
15:10:55 <solonarv> yes, it is very handy
15:11:38 <solonarv> I usually don't copy-paste the bounds directly because it outputs them in >= foo && <bar format, and I prefer ^>= foo for conservative bounds
15:11:59 <solonarv> but it still saves me from having to find out which version is even being used!
15:15:40 <dmj`> solonarv: very cool, never knew about gen-bounds
15:28:59 <oats> is there anywhere I can go to learn how to use the `tls` package or see examples of using it with `network`?
15:30:25 <Rembane> oats: What do you want to do?
15:30:35 <oats> Rembane: irc client
15:30:42 <oats> preferably with tls :P
15:35:29 <Rembane> oats: Cool! 
15:43:35 <dmj`> oats: acid-state's Remote module (which everyone who ever uses acid-state should use), has a TLS module (uses network + tls)
15:43:39 <dmj`> oats: http://hackage.haskell.org/package/acid-state-tls-0.9.2/docs/src/Data-Acid-Remote-TLS.html#acidServerTLS
15:45:14 * hackage extensible-effects-concurrent 0.26.0 - Message passing concurrency as extensible-effect  https://hackage.haskell.org/package/extensible-effects-concurrent-0.26.0 (SvenHeyll)
15:54:55 <oats> dmj`: that looks useful to me, thanks :)
15:56:42 <dmj`> oats: np ;)
15:56:47 <dmj`> @package acid-state-tls
15:56:48 <lambdabot> http://hackage.haskell.org/package/acid-state-tls
15:58:58 <solonarv> oats: you can also look at glirc, which is an IRC client written in Haskell :D
16:01:22 <sicklorkin> dmj`: do you have much experience with acid-state?
16:01:31 <dmj`> sicklorkin: yes, I help maintain it
16:02:03 <sicklorkin> is it production ready?
16:02:46 <dmj`> sicklorkin: define production ready
16:03:08 <sicklorkin> I have a bunch of telemetry data that I need to rebuild everytime i restart, and I'm wondering if this woul dbe a good usecase for uing acide state
16:03:31 * sicklorkin can't type today
16:05:04 <dmj`> sicklorkin: from a development perspective its bliss, native haskell datatypes, very fast in-memory lookups, migrations w/ safecopy are great
16:05:15 <sicklorkin> dmj`: by production ready, I mean is it resilient.
16:07:27 <dmj`> sicklorkin: A lot of industry uses I've seen of acid-state haven't separated out the acid-state db from the web server, which leads to a lot of heap usage, and additional GC. I've found isolating the acid-state db into its own process and putting ekg in front of it, tuning the RTS parameters to give good results. It obviously depends on your data. It's not as resilient as sqlite or postgreSQL obviously, but it should be as
16:07:27 <dmj`> resilient as any process managed by GHC
16:09:10 <dmj`> redis, postgresql all communicate over the network, treating acid-state like an in-process DB like sqlite I've found to be lethargic. I think hackage does it this way, but I also think most of hackage is delivered via cdn these days.
16:10:36 <dmj`>  sicklorkin: it will be hella fast, but I've seen *huge* memory spikes when snapshots are taken. This takes the entire state and serializes it to disk, as opposed to the incremental transactions that persisted
16:10:44 <dmj`> that are*
16:11:42 <sicklorkin> dmj`: so my market state is approx 1gb and i'd like to take regular snapshots - would this be problematic?
16:12:34 <sicklorkin> I think it's best if I experiment
16:13:19 <dmj`> sicklorkin: probably not, one thing that isn't good about acid-state is that it lacks arbitrary querability, like a SQL database. You can only query using the functions you've defined ahead of time. These functions exist in memory at runtime, if you remove one, you can have trouble replaying your state. So always snapshot before you do this, this way you want reply the transaction log with missing functions.
16:14:33 <dmj`> sicklorkin: you could in theory implement a query DSL on some in-memory data type ( a pure B-tree) to facilitate this, but now you've reinvented a database :) just in memory
16:15:57 <sicklorkin> oh.. am using ixset-typed data structure in my market state
16:16:10 <dmj`> sicklorkin: are you using happstack?
16:16:18 <sicklorkin> no
16:21:20 <reygoch> How do I know if haskell program is being compiled on windows? I've tried with #if defined (__WIN32__)
16:21:20 <reygoch> , but it doesn't seem to be working.
16:22:51 <dmj`> reygoch: you can set a CPP flag in the cabal file, if os(Win32) -DWINDOWS and then in your module enable CPP lang extension and do #ifdef WINDOWS .... #endif, etc. 
16:22:52 <solonarv> reygoch: the macro to look for is MINGW_HOST_OS
16:23:00 <solonarv> that one's defined by default
16:24:09 <MarcelineVQ> e.g. https://hackage.haskell.org/package/directory-1.3.3.2/docs/src/System.Directory.Internal.html
16:25:40 <reygoch> solonarv: Hmm... for some reason I'm not getting the effect. Even if I make error in MINGW_HOS_OS if branch compiler doesn't complain.
16:26:25 <solonarv> ah, I might have misremembered the exact spelling of the macro
16:26:45 <reygoch> I'm looking at the user guide but I can't find where such thing would be documented.
16:27:15 <reygoch> dmj`: can't remember, what is the name of the cabal field for flags?
16:27:33 <MarcelineVQ> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/phases.html?highlight=macro#standard-cpp-macros
16:28:04 <dmj`> reygoch: this is how process does it, http://hackage.haskell.org/package/process-1.6.5.1/process.cabal
16:28:15 <dmj`>  cpp-options: -DWINDOWS
16:28:34 <reygoch> ah cool, thanks MarcelineVQ, you too dmj.
16:28:44 <solonarv> I did indeed misrmember the spelling - it's mingw32_HOST_OS
16:31:17 <reygoch> Btw, does someone have experience with Setup.hs? I want to use a partial command as program, is that possible?
16:31:46 <reygoch> something like this : simpleProgram "perl -S somescript.pl"
16:32:07 <reygoch> https://hackage.haskell.org/package/Cabal-2.4.1.0/docs/Distribution-Simple-Program.html#v:simpleProgram
16:32:49 <reygoch> Right now I'm getting The program is "perl -S somescript.pl" required but couldn't be found.
16:33:52 <solonarv> simpleProgram deals with locating executables, not with arbitrary shell commands
16:36:28 <solonarv> I *think* you want to look for the 'perl' Program (which means that perl must be available), then you want to construct a ConfiguredProgram from that
16:40:34 <solonarv> er, right - after some more documentation reading it looks like the process is as follows:
16:42:06 <solonarv> 1) construct a Program value describing what program you want (in this case, perl); 2) make sure this program is configured; 3) invoke/run it, this is where you would pass ["-S", "somescript.pl"] as arguments
16:52:55 <reygoch> solonarv: thanks, that was the way. I'm trying to get the mysql package build on windows and it's a mess so I was hoping to take a shortcut without having to pass all those params.
17:02:44 * hackage traction 0.1.0 - Tools for postgresql-simple.  https://hackage.haskell.org/package/traction-0.1.0 (MarkHibberd)
17:31:15 <yoav_> Hey, I have a function (getComic :: Int -> Comic) and a function (saveComic :: Comic -> IO ()). How can I chain these together to create (getAndSaveComic :: Int -> IO ()) without do notation?
17:31:41 <dmwit> saveComic . getComic
17:32:08 <dmwit> or:
17:32:19 <dmwit> \comicID -> saveComic (getComic comicID)
17:34:27 <yoav_> dmwit: I was looking for ((saveComic =<<) . getComic), but thanks! Managed to find that using your ideas.
17:34:36 <yoav_> (wanted to go pointfree, forgot to mention that)
17:35:21 <dmwit> You might also like (<=<).
17:37:38 <yoav_> dmwit: Perfect, thanks! I forgot to mention that getComic returns an IO Comic, so sorry if that threw you off a little.
17:42:55 <solonarv> yep, you want (<=<) or (>=>)
17:43:14 <solonarv> (they're the same thing, just flipped: f >=> g = g <=< f )
17:58:59 <orzo_> anyone know how to make do a gtk liststore in haskell using gi-gtk?
17:59:29 <orzo_> I'm trying to adapt c examples, but listStoreNew takes a GType and I've no idea how to find haskell equivelents for thing ssuch as G_TYPE_STRING
18:07:01 <yoav_> I want to know where my error is here, I'm using Network.HTTP to download binary files (get :: URL -> IO String) but when writing them to an actual file they're corrupted. Is the issue here more likely to be in the GET or the write to a file?
18:14:20 <MarcelineVQ> where is get from?
18:15:46 <dmj`> mtl? 
18:15:55 <dmj`> binary?
18:15:56 <MarcelineVQ> dmj`: the get mentioned above
18:16:02 <yoav_> get is defined as (getBin url = simpleHTTP (getRequest url) >>= getRequest
18:16:08 <yoav_> fuck, wrong limne
18:16:17 <yoav_> get url = simplehttp (getrequest url) >>= getresponsebody
18:16:50 <dmj`> MarcelineVQ: ah
18:17:53 <yoav_> Looking at the Network.HTTP documentation I see that simpleHTTP can get me a Result (Request (ByteString)) but for that I need a Request ByteString and I'm not sure how to get one.
18:18:33 <MarcelineVQ> you'd probably want to use https://hackage.haskell.org/package/http-conduit-2.3.7.1/docs/Network-HTTP-Simple.html at that point
18:18:58 <yoav_> Looked at it, you'll probably make fun of me but I pacman -S'ed it and the amount of dependencies scared me away
18:19:02 <MarcelineVQ> Not that that's an answer to your question
18:19:53 <dmj`> yoav_: if you're doing a GET odds are your body is empty, you can probably construct a Request manually with an empty bytestring as the req body (mempty), http://hackage.haskell.org/package/HTTP-4000.3.13/docs/Network-HTTP-Base.html#t:Request
18:21:18 <yoav_> dmj`: I'll take a look, thanks
18:22:39 <dmj`> yoav_:  simplehttp (Request uri GET mempty (mempty :: ByteString)) >>= getRequest
18:22:41 <oats> glguy: just want to thank you for your 'hookup' package :)
18:34:14 * hackage mongoDB 2.5.0.0 - Driver (client) for MongoDB, a free, scalable, fast, documentDBMS  https://hackage.haskell.org/package/mongoDB-2.5.0.0 (VictorDenisov)
18:36:31 <yoav_> Alright, I did something a bit different in the end. I wrote 9simplehttp (Request uri GET mempty (mempty :: ByteString)) >>= getRequest
18:36:40 <yoav_> wait fuck
18:37:03 <yoav_> convToByteString r = r {rqBody = mempty} which makes the request an empty bytestring request
18:37:15 <yoav_> and I just passed the one that I got from getRequest to that
18:37:41 <yoav_> so thanks a lot everyone, it's 4:37 am so I'll keep working on that tomorrow.
18:38:10 <dmwit> Yeah, I would bet hard on the String version being an encoding problem, which ByteString should completely bypass.
18:38:33 <dmwit> s/String version/problem with the String version/
18:41:22 <da7niel> So I want all the square numbers less than 1000, so I say [x*x | x <- [1..], x*x < 1000] which gives me my result, but the computation never terminates. How do I ensure termination?
18:43:03 <Kokoshka98> Здравейте, пичове! Време е за моето Live шоу. Започвам след 10-тина минутки. Който има желание, нека да драсне "Безплатна покана" в сайта за Камерите (и нека да се забавляваме заедно). Линк: http://svel.to/19oy
18:43:51 <lyxia> da7niel: takeWhile (< 1000) [x * x | x <- [1 ..]]
18:44:41 <da7niel> lyxia: thank you for your help :)
18:46:42 <olligobber> the example of symmetricDifference is very broken on https://hackage.haskell.org/package/containers-0.6.1.1/docs/Data-Map-Merge-Strict.html 
18:48:02 <olligobber> I can fix it, but where do I push my fix?
18:48:29 <olligobber> huh, some of the other examples are wrong too
18:48:49 <solonarv> olligobber: the front page of the haddocks ( https://hackage.haskell.org/package/containers-0.6.1.1 ) links to the source repository
18:49:13 <solonarv> (the "Contents" link in the top right)
18:49:19 <solonarv> in this case that's http://github.com/haskell/containers
18:49:28 <olligobber> thanks solonarv 
18:53:47 <olligobber> hmm, I can't find the file that contains that documentation...
18:54:29 <dmwit> Should be next to the implementation of merge.
18:54:43 <dmwit> Which according to the existing docs is in Data.Map.Internal.
18:55:04 <olligobber> ok
18:55:09 <dmwit> (Click "Source" next to "merge" above the mention of symmetricDifference to see how I learned this.)
18:56:47 <dmwit> The only wrinkle that spoils the "scroll up to the last documented item and click 'Source'" technique is that haddock has a way to specify blocks of documentation that aren't attached to any declaration. But I think those don't float across module boundaries, so those are especially easy to find.
18:58:49 <dmwit> > scanl1 (+) [1,3..]
18:58:51 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
18:59:41 <solonarv> hey, neat!
19:00:37 <olligobber> :o
19:01:15 <olligobber> > (^2) <$> [1..]
19:01:17 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
19:07:15 <olligobber> my first pull request into a haskell repo :o https://github.com/haskell/containers/pull/646
19:10:45 <dmwit> olligobber++
19:10:52 <dmwit> level up!
19:13:42 <subttle> dmwit: nice :)
19:42:04 <nisstyre> olligobber: I love it when people take the time to check documentation for correctness
19:42:14 <nisstyre> it's a seriously underrated contribution
19:42:48 <olligobber> I wasn't checking it for correctness, I was trying to use it and getting confused that it didn't work
19:42:59 <nisstyre> olligobber: yeah, that's what I mean :p
19:43:09 <nisstyre> I've run into the same situation many times before
19:43:18 <nisstyre> documentation gets out of date and stops working
19:43:50 <nisstyre> very easy (unless you're doing literate programming maybe) to forget to test your example code
19:44:39 <dmwit> Okay, so suppose I've got a grid with some empty cells and some filled. I've got a shape -- say, the Z piece from tetris -- of cells that I'd like to stamp down as many times as I can. How would you go about trying to figure out how many times that was?
19:44:54 <dmwit> I'm worried that the naive search algorithm would take way too long.
19:45:54 <nisstyre> dmwit: what do you mean by "stamp down as many times as I can" ?
19:46:22 <olligobber> I assume you want to place as many non-overlapping copies of the shape as possible
19:46:24 <nisstyre> I feel like this is where a diagram or drawing would help
19:46:27 <dmwit> I overlay the shape on the grid. Everywhere the shape is should be empty cells before the stamp and full cells after.
19:46:41 <dmwit> olligobber has got the right of it.
19:46:58 <nisstyre> oh I see
19:47:10 <nisstyre> so is this like a knapsack problem basically?
19:47:31 <dmwit> Seems related, yeah.
19:47:36 <nisstyre> hmm
19:47:46 <olligobber> though knapsack only has the one parameter
19:47:48 <nisstyre> I feel like this is a good use case for dynamic programming
19:47:52 <olligobber> you could do network flow!
19:47:52 <nisstyre> 2d knapsack?
19:48:10 <nisstyre> Actually I just learned about incremental computation today and it seems like this would also be a good approach
19:48:11 <dmwit> Cool, what's network flow?
19:48:18 <olligobber> if you make the appropriate graph, max flow would solve it easily
19:48:24 <nisstyre> I think it might be similar to network flow
19:48:47 <nisstyre> it uses something called a "dependency computation graph"
19:49:09 <olligobber> oh, network flow won't work
19:49:11 <nisstyre> where you basically never recompute things that have already been computed, even in the face of changing state
19:49:24 <nisstyre> i.e. your board changes but you don't have to check cases that you know will never yield new results
19:49:38 <nisstyre> similar to DP
19:50:38 <olligobber> network flow is just a problem with super optimised algorithms to solve it, and a lot of problems reduce to it
19:51:10 <dmwit> Oh, these asymptotics look very promising (browsing the Wikipedia page for max-flow).
19:51:19 <nisstyre> I feel like you could do this in a logic language pretty nicely too
19:51:31 <nisstyre> there are probably lots of Haskell DSLs to do it
19:51:35 <dmwit> I don't see how it helps, but if it does I'm psyched.
19:51:48 <olligobber> yeah, pretty sure I could write a pretty fast program in souffle to solve this
19:51:55 <dmwit> A logic language would just do the naive search I'm trying to avoid though, no?
19:52:02 <nisstyre> dmwit: I don't know
19:52:10 <nisstyre> you could use "cuts" maybe
19:52:15 <nisstyre> but meh
19:52:49 <nisstyre> I'm just throwing that out there as a potential idea
19:54:25 <olligobber> actually, the variant of this problem but with arbitrary shapes is probably NP-complete, so that means any solution that works with arbitrary shapes isn't going to be fast
19:55:13 <olligobber> by arbitrary shapes I mean the input is a set of shapes, rather than being copies of the same shape
19:56:03 <olligobber> which is actually a good idea for an assignment/exam question *takes notes*
19:57:43 <nisstyre> olligobber: I feel like a solution to this could involve divide and conquer, i.e. split your board up into smaller and smaller squares, put shapes into each square, combine them somehow, and search for the square of size X with the largest number of shapes
19:57:49 <nisstyre> that would obviously be really inefficient
19:58:10 <nisstyre> but that's how my first naive approach would be
19:58:27 <dmwit> The trick is that shapes can cross the boundary that you've chosen to divide across.
19:58:28 <nisstyre> you could add DP to not recompute subsquares that you know won't change
19:58:35 <nisstyre> oh
19:58:39 <olligobber> my first naive approach would just be O(2^(w*h))
19:58:40 <nisstyre> yeah I don't know how I would solve that
19:58:57 <nisstyre> but if you had a nice way to "combine" smaller squares into larger ones, maybe that would work
19:59:03 <dmwit> I've been pondering whether I can coerce a SAT solver into answering this question for me.
19:59:04 <nisstyre> it would be tricky
19:59:24 <dmwit> (Well, the simplified question which is "can I fit 32 copies into the grid?". Then I can ask about 33. ;-)
19:59:54 <olligobber> you can get a SAT solver to do it since the problem is in NP
20:00:12 <dmwit> Oh, sure. Good point.
20:00:30 <nisstyre> I think it's still good to have a slow reference implementation that you know is correct
20:00:33 <nisstyre> which will work for small n
20:00:40 <nisstyre> then you can validate your SAT solver version with small n
20:00:47 <nisstyre> and at least have a good understanding of the problem
20:00:55 <olligobber> there should be an efficient solver though...
20:01:59 <olligobber> I'm gonna go back to implementing my SAT solver in haskell
20:02:14 <dmwit> =D
20:04:00 <nisstyre> olligobber: btw Souffle sounds interesting
20:04:20 <nisstyre> some things I haven't heard of there, like "Futamura Projections"
20:04:26 <nisstyre> I feel like that's some math thing
20:04:28 <olligobber> nisstyre, especially since I fixed its type system
20:04:37 <nisstyre> oh it has types?
20:05:03 <nisstyre> oh it's just another thing related to partial evaluation
20:05:19 <olligobber> yeah, though the old type system was completely broken; it allowed implicit downcasts
20:06:20 <nisstyre> olligobber: so like going from Number -> Float unintentionally?
20:06:57 <olligobber> yeah, which caused issues since you could do stuff like Integer -> Number -> Float unintentionally
20:07:06 <nisstyre> yeah I can see that causing problems
20:07:17 <nisstyre> that kinda destroys the point of having subtype polymorphism I guess
20:08:23 <olligobber> it made the type system kind of pointless, since its main purpose was to prevent data of different types mixing unintentionally
20:09:11 <nisstyre> ohh I see, yeah good job for fixing it :p
20:10:10 <olligobber> the fix still hasn't been merged into the master branch, but it should be soon enough
20:10:47 <olligobber> the issue is still open here: https://github.com/souffle-lang/souffle/issues/832
20:25:10 <olligobber> I want to extract an element from a set if one exists, so like `Set a -> Maybe a`, what's a good way to do this?
20:26:01 <olligobber> oh, lookupMin works, good
21:41:22 <arahael1> If I have an if then if then if then staircase, what's the ideal way for me to refactor it?
21:41:50 <dmwit> Make it pattern matching instead, probably.
21:41:56 <dmwit> Depends on the staircase.
21:42:18 <arahael1> I could transform the conditions to a tuple of bools, and pattern match on that, actually - yeah, that may make sense.
21:42:27 <dmwit> You might also like https://stackoverflow.com/q/33005903
21:42:44 <dmwit> What are the conditions in question?
21:42:59 <dmwit> (Can you just make them constructors of an ADT instead?)
21:43:22 <arahael1> dmwit: They correspond to argument flags.
21:43:59 <arahael1> They really represent a product type, I guess, so a tuple is probably the correct way to express it.
21:44:16 <arahael1> Incidentially, could I pattern-match on a record field?
21:44:22 <arahael1> (It's actually already in a record)
21:45:13 <dmwit> Yes.
21:45:35 <dmwit> > case Node 3 [] of Node { subForest = f } -> f
21:45:38 <lambdabot>  []
21:46:18 <dmwit> I find the syntax a bit noisy, though, in most cases.
21:46:56 <dmwit> I would push just a tad harder, though: what are the argument flags about?
21:47:11 <dmwit> (Can you make them be part of a more structured ADT instead of just a bunch of Bools?)
21:48:04 <dmwit> If they are really independent Bools, then there shouldn't be much nesting; since you say there's a lot of nesting, then that makes me think there's structure that relates them and invariants and stuff, and so maybe just a bunch of Bools isn't the best representation.
21:49:10 <arahael1> dmwit: Oh, nice.  Actually that does work quite nicely in my particular case.
21:49:24 <arahael1> dmwit: Well, -t means "Show types", so I then show the types.
21:50:19 <arahael1> Actually, that probably means that I should prefer the if-then-else, because I'll very likely want to test each condition, rather than just defaulting to the first pattern.
21:51:07 <arahael1> So I probably want something more like `Bool -> IO a -> IO ()`
21:51:23 <dmwit> :t when
21:51:24 <lambdabot> Applicative f => Bool -> f () -> f ()
21:51:29 <arahael1> Beautiful!
21:51:36 <dmwit> But now I'm way confused.
21:51:56 <dmwit> Do you have some code that's currently working but ugly that you could share?
21:52:08 <arahael1> dmwit: It's super super ugly.  One moment.
21:52:15 <dmwit> It's not at all clear to me why guard would help with deep nesting.
21:53:55 <arahael1> dmwit: The current approach I do to avoid nesting is this: https://gist.github.com/arafangion/027821714a06e928149e64a03a7e3038
21:54:37 <arahael1> dmwit: You could hypothetically set all such flags to true, in which case, I'd evaluate all of them, but I imagine you'll rarely choose to do that in practice.
21:54:55 <arahael1> dmwit: So, nesting on the 'then' branches would be acceptable.
21:55:28 <c4droid> Hi, the I set mirror to my stack config, why stack want key name: hackage-security
21:56:02 <arahael1> dmwit: The trouble i then have is that it's repetitive writing 'else pure ()' all the time.
21:59:50 <dmwit> But that's not a staircase at all!
22:00:04 <dmwit> That's mere crenellations!
22:01:00 <dmwit> Anyway, yes, `when` is the right solution to the complaint you have.
22:04:22 <arahael1> I like the way you use that word. :)
22:04:36 <arahael1> And yeah, I think `when` is the right solution - thanks for that!
22:05:03 <c4droid> emmm... 
22:07:04 <MarcelineVQ> or MultiWayIf
22:12:26 <dmwit> c4droid: I don't understand your question yet, for what that's worth.
22:12:58 <dmwit> I probably won't be able to help once I do understand it, because I don't know much about stack, but I suspect anybody who could help you will have the same trouble I am having.
22:13:43 <dmwit> You should share whatever config file you have, the exact command you are trying to run, and the exact contents of the error you get.
22:13:47 <c4droid> dmwit: Have any useful hackage mirror for stack? 
22:13:53 <dmwit> You can use an online pastebin and send us a link to it.
22:15:44 <dmwit> I think hdiff.luite.com has a mirror of Hackage, though I haven't tried to use it.
22:17:45 <dmwit> Googling for "Hackage mirrors" also seems to get some interesting results. Like https://guide.aelve.com/haskell/hackage-mirrors-unelnlt9
22:18:46 <c4droid> dmwit: I cannot bypass the firewall at my country, so I'm using my countrys hackage mirror. when I configure the hackage mirror at my stack config.yaml, at execute command stack setup, the stack hint me not hackage-security key in my stack config.yaml
22:23:16 <c4droid> here is my stack config.yaml: https://paste.ubuntu.com/p/Y5jYkT97YR/
22:24:20 <MarcelineVQ> no, come back, I have a response now that you've posted a file
22:25:01 <MarcelineVQ> c4droid: https://docs.haskellstack.org/en/stable/yaml_configuration/#package-indices shows the hackage-security key and the expected format for it, so you are missing it as the error you get says
22:25:26 <MarcelineVQ> I've never used a custom hackage so I have no idea where to get the keyids you need to put in there
22:26:22 <c4droid> but my mirrors help documents not say want use hackage-security key. That option I let me more confused.
22:27:13 <dmj`> c4droid: can you access cache.nixos.org in your country? nix uses stackage snapshots, with the added benefit the deps are prebuilt.
22:27:53 <c4droid> not, blocked by firewall
22:28:02 <MarcelineVQ> The help could be old, I don't know, is your mirror's help something I am able to see?
22:28:54 <dmj`> c4droid: which country, just curious
22:29:00 <c4droid> https://mirrors.tuna.tsinghua.edu.cn/help/hackage, The help is written in chinese, so.
22:30:27 <c4droid> dmj`: I'm from china
22:32:53 <dmj`> c4droid: shenzhen?
22:33:24 <c4droid> dmj: jiangxi nanchang
22:35:27 <c4droid> not shenzhen
22:37:07 <c4droid> emm.. 
22:39:07 <c4droid> I don't know why stack configure the hackage mirror want hackage-security key, that key is optional at before.
22:42:31 <c4droid> I'm going to contact the administrator and ask him to update the help document.
22:42:43 <c4droid> Anyway, thanks the help.
22:52:32 <MarcelineVQ> noo, come back :( seems like you can put: keyids: []
22:59:15 <MarcelineVQ> there is other issues happening after that though
23:00:34 <MarcelineVQ> here's a gist that seeems to work for me, let them know if they come back https://gist.github.com/MarcelineVQ/67e2e5cd273f04a3a846f340d0349b06
23:38:45 <Arahael> How do I do a pattern-match, but then refer to the full argument?
23:39:02 <Arahael> Eg, I want to define f a b = ..., but only if b matches a particular pattern.
23:40:08 <Arahael> I want to basically be able to do: f a (b | Just b) = a <> b
23:40:28 <Arahael> (Ie, refer to "b", if it is a Just)
23:40:52 <Arahael> Note: B isn't neccessarily a Maybe, it just happens to be one in that particualr example...
23:41:21 <[Leary]> b@(Just _)
23:47:39 <Arahael> Perfect - thanks!
23:47:55 <glguy> Or even b@Just{}
23:49:11 <Arahael> glguy: How does that one work?
23:50:52 <glguy> Just{} works the same as (Just _), you can use empty record patterns to match even not record defined constructors
23:51:31 <glguy> Handy for when you really do just want to match the constructor and but create maintenance work should the fields change
23:52:03 <Arahael> Very nice, that's actually exactly what i need.
