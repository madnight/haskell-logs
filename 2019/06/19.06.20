00:02:40 <janat08> it actually didn't have 8.6.5, but the stack didn't expose ghc in path
00:10:23 <tdammers> IIRC the idea with stack is that you run everything that needs stack's environment (including the GHC it installed) through stack exec
00:20:00 <erikd> getting an error "Expected a constraint, but ‘i <= (i + o)’ has kind ‘Bool’" is there some alternative comparison operatator i should be using?
00:21:44 <__monty__> erikd: Sounds more like you're trying to do the comparison in a type signature.
00:22:08 <erikd> in an instance declaration "instance (KnownNat i, KnownNat o, KnownNat (i + o), i <= (i + o) ....."
00:22:49 <__monty__> Yeah, that's not allowed. At least not straightforwardly.
00:24:16 <__monty__> What you're doing looks a lot like theorem proving btw. Haskell's not very ergonomic for such use.
00:26:36 <erikd> well, this code worked when using GHC.TypeLits (which is deprecated) but i'm trying to get it to work unsing the singletons library (which is supposed to replace it)
00:28:25 <__monty__> That's the not so straightforward approach I was talking about : )
00:30:26 <__monty__> erikd: If all you need is natural numbers Data.Nat would be a lot simpler.
00:32:30 <[Leary]> There may be a nicer way, but you can do something like `(i <= (i + o)) ~ 'True`.
00:33:00 <__monty__> You can?
00:38:07 <jusss> how to know a value's type?
00:38:26 <jusss> like python, we can use isinstance(x, int) to know if x has int type
00:39:25 <jusss> if x has  Either Int String, so how we know x is Left a or Right b ?
00:39:47 <winny> Interactively you can use :t , but since haskell is statically typed, you know types at compile time
00:40:56 <winny> https://wiki.haskell.org/Algebraic_data_type
00:40:59 <ski> jusss : "how we know x is Left a or Right b ?" -- pattern-matching. but that is not knowing type
00:40:59 <jusss> winny: I want to write a function, and its parameter has Either Int String,  if it's Left a then return Left (a+1), if it's Right b then return Right b
00:41:18 <ski>   foo :: Either Int String -> ...
00:41:27 <ski>   foo (Left  n) = ..n..
00:41:33 <ski>   foo (Right s) = ..s..
00:41:48 <ski> that's pattern-matching
00:42:15 <jusss> ski: aha, I see
00:42:34 <ski> you're checking which "shape" the input has. that is not checking its type
00:42:39 <jusss> we don't need to check the type of parameter, 'cause we have pattern matching!
00:43:14 <jusss> ski: another silly question, how we can reverse a string?
00:43:18 <jusss> "ab" to "ba"
00:43:23 <ski> > reverse "ab"
00:43:25 <lambdabot>  "ba"
00:43:39 <jusss> ...
00:43:58 <ski> or are you asking about how that is implemented ?
00:44:03 <jusss> no
00:45:04 <ski> `String's are lists of `Char'acters, in Haskell. this is sometimes not so good for performance, but it means that general list operations will also work on strings
00:45:23 <ski> > ['a','b']
00:45:27 <lambdabot>  "ab"
00:46:18 <winny> :t "abc"
00:46:19 <lambdabot> [Char]
00:49:32 <erikd> __monty__: fixed it. "instance (KnownNat i, KnownNat o, KnownNat (i + o), (i <= (i + o)) ~ 'True"
00:50:23 <__monty__> I didn't know addition and constraints on values was allowed, TIL.
00:50:50 <fuzzy_id> i'm trying to run a haskell exec on aws lambda and use HTTP to fetch the next invocation id.
00:51:15 <fuzzy_id> in the logs i see 'c_poll: permission denied (Operation not permitted)' and later 'ioManagerDie: write: Bad file descriptor'
00:51:21 <jusss> ski: about polymorphic, we can return any type in dynamic languages like python or javascript, and can we return any type in static languages?
00:51:32 <fuzzy_id> any ideas what this is and how to work around this?
00:51:52 <fuzzy_id> (i mean the HTTP library…)
00:52:28 <erikd> fuzzy_id: c_poll is not the HTTP library, its the haskell runtime system
00:53:43 <fuzzy_id> yeah
00:53:53 <__monty__> jusss: You can return any type you want from a function of course. But you can't have that type depend on the values of the parameters. Oftentimes Either is enough though, like your Either Int String example.
00:55:15 <ski> jusss : the question doesn't make sense to me
00:56:39 <ski> jusss : you can write e.g. `id :: a -> a; id x = x'. then `id' can return a value of any type you like (provided you call it with a value of that type) ..
00:56:51 <ski> .. but i suspect that's not what you meant
00:57:21 <ski> (instead of `id', you could take `(!!) :: [a] -> Int -> a', or other functions, if you want something less trivial)
00:57:40 <erikd> or "read :: Read s => String -> a"
00:57:47 * ski nods
00:58:26 <erikd> (even though i screwed up the type var names)
00:58:31 <ski> (also, nitpick. you don't return types from function. you return value, which belong to types)
00:58:46 <ski> @type read
00:58:47 <lambdabot> Read a => String -> a
01:02:54 <jusss> f = lambda x: x+1 if isinstance(x, int) else ( x[::-1]  if isinstance(x, str))
01:03:19 <jusss> f(3) get 4, and f("ab") get "ba", polymorphic
01:03:34 <ski> and `f("abc")' ?
01:03:41 <jusss> "cba"
01:03:54 <ski> you can do that, if you *really* want to
01:03:59 <ski> but why would you want to ?
01:04:21 <merijn> The solution to wanting that is to stop wanting bad things
01:04:38 <jusss> we already have f :: Either Int String -> Either Int String ; f (Left x) = Left (x+1) ; f (Right x) = Right (reverse x)
01:05:28 <jusss> how to implement a function that take x from Left x or Right x?
01:06:20 <jusss> 'cause x in Left x is Int, and in Right x is Str, so that one function may return two type
01:06:31 <Rembane> jusss: There's either from Data.Either IIRC.
01:06:33 <Rembane> :t either
01:06:34 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
01:07:51 <ski> > nonsense 3
01:07:53 <lambdabot>  4
01:08:01 <ski> > nonsense "abc"
01:08:03 <lambdabot>  "cba"
01:08:11 <ski> jusss : happy ?
01:08:22 <jusss> ski: yeah
01:08:29 <ski> @type either id id
01:08:30 <lambdabot> Either c c -> c
01:12:59 <jusss> @type nonsense
01:13:00 <lambdabot> Typeable a => a -> a
01:13:33 <jusss> I don't understand how your nonsense did that
01:14:49 <merijn> Via Typeable, which is basically a short way of saying "I absolutely hate knowing what my code does before I run it", so at least it's a good match if you like Python
01:20:41 <jusss>  f::Either a a -> a ; f (Left x) = x ; f (Right x) = x  
01:21:39 <ski> that's the same as `either id id', yes
01:26:21 <__monty__> jusss: Most common way to have function implementation depend on the type of the value they're applied to is through typeclasses. `class X a where f :: a -> a; instance X Int where f = (+1); instance X String where f = reverse` then you can do both `f 4` and `f "abc"`.
01:27:02 <__monty__> Hmm, that's not quite true, I guess the most common way is parametric polymorphism. But that doesn't get you what you want.
01:27:43 <jusss> and polymorphic result
01:32:42 <lortabac> jusss: it depends on what you mean by "polymorphic result". When you have a signature 'a -> a', the return type must be the same as the argument type
01:33:18 <lortabac> jusss: if you want the return type to depend on the argument type, you need more advanced stuff like associated types or functional dependencies
01:34:59 <__monty__> jusss: Read does this kind of. It's just that it infers the type *first* and then picks the right implementation of `read :: String -> InferredType`, rather than looking at the *value* and determining what that type should be.
01:36:49 <jusss> ok
01:42:33 <__monty__> jusss: Do note that even though this all may sound constricting to a pythonista there's generally good reasons for the limitations.
01:44:53 <ski> jusss : `id' is polymorphic, its result is not
01:47:21 <jusss> __monty__: ski I love type variables, I love polymorphic, but I'm still not good at it
01:47:33 <__monty__> ski: Though its result *could* be, right?
01:47:36 <tdammers> it is a limitation, but the trick is that by constraining what we allow ourselves (and the compiler) to do, we free ourselves from having to take a million things into account that we would never want to occur in the first plcae
01:48:37 <jusss> did type limite your image?
01:48:45 <jusss> or may?
01:49:13 <ski> __monty__ : with `ImpredicativeTypes', sure
01:50:27 <merijn> Friends don't let friends use -XImpredicativeTypes
01:50:33 <ski> constraining the implementor can mean giving more power to the user, and vice versa
01:50:34 <__monty__> ski: Hmm, I was talking about `id id` not familiar with impredicative types.
01:50:42 <ski> __monty__ : that's another thing
01:50:48 <merijn> That extension should really be deprecated and/or produce a HUGE ass warning
01:51:16 <ski> __monty__ : in that case, conceptually, the result returned by the `id' call is still not polymorphic
01:54:17 <__monty__> But it would be if ImpredicativeTypes was enabled?
01:54:36 <ski> both `id's are specialized to be monomorphic (as always with polymorphic values, except when there's higher-rank stuff going on). the first one having type `(_a -> _a) -> _a -> _a', the second having type `_a -> _a', so that the result has type `_a -> _a' .. then, depending on the context in which you use this result, either `_a' will be instantiated to some specifi type, like `Integer', or it would be generalized upon, so that e.g. the result gets assigned
01:55:15 <ski> (hrm, possible cut off near ".., or it would be generalized upon, so that e.g. the result gets assigned type `forall a. a -> a'")
01:55:25 <ski> __monty__ : it could be, at least
01:56:29 <__monty__> Hmm, does this mean `polyId = id id` would retain the polymorphism?
01:56:48 <__monty__> And would it still be lost if we'd dare use polyId?
01:57:12 <ski> i don't understand the question
01:57:58 <ski> the way to use a function is to call it
01:57:59 <__monty__> I'm trying to understand your "it would be generalized upon."
01:58:08 <ski> the way to use a polymorphic value is to specialize it
01:58:39 <ski> you can't (nontrivially) use a polymorphic value, without specializing it
01:59:05 <ski> (just passing something on, or storing it, doesn't count as "use", in a nontrivial sense of the term, here)
01:59:52 <__monty__> When I said use I did mean apply the function to a value.
02:00:04 <__monty__> Let's not get side-tracked by "use."
02:00:18 <ski> which function ?
02:00:22 <ski> `polyId' ?
02:00:25 <__monty__> Yes.
02:01:54 <ski> your `polyId' will be generalized, so that it's polymorphic. if you then call `polyId False', then that occurance `polyId' (as always, when using polymorphic values), will be turned to a monomorphic thing
02:02:25 <ski> (of type `Bool -> Bool', in this case, so that we can apply the resulting function to the value `False' of type `Bool')
02:02:56 <__monty__> Ah, so it's only when you apply `id id` to something that the result of the first `id` will not be polymorphic?
02:03:19 <ski> no
02:04:18 <ski> conceptually, it's this : (a) both uses of `id' are specialized, so that those occurances are monomorphic; (b) one is applied to the other, yielding a monomorphic result; (c) that result is generalized, so that `polyId' is/becomes a polymorphic value
02:04:57 <ski> (d) the call to / use of `polyId' is specialized, becoming monomorphic; (e) the resulting function is called with input `False'
02:05:57 <__monty__> Does this generalization mean haskell's inbetween predicative and impredicative polymorphism?
02:06:29 <ski> (strictly speaking, values like `id' or `length' aren't functions, but "polymorphic values". however, instead of saying "polymorphic values which when specialized will (always) yield functions" (which is a mouthful), we say "polymorphic function", often even dropping the "polymorphic" part, since specialization is implicit in the concrete syntax)
02:08:40 <ski> "impredicative polymorphism" means that one can instantiate a universally quantified type variable (iow `a' in `forall a. ..a..') with a type that is itself a `forall'-type
02:09:52 <ski> e.g. specializing `length :: forall a. [a] -> Int' to `length :: [forall b. Maybe b] -> Int', where `a' has been instantiated to `forall b. Maybe b'
02:14:43 <ski> __monty__ : generalization (aka `let'-polymorphism) is a standard part of Hindley-Milner type inference/checking
02:18:55 <__monty__> Yeah but it feels like it gets you part of impredicative polymorphism. For example, impredicative `id id` first `id :: (forall a. a -> a) -> (forall a. a -> a)`, predicative with generalization `id :: (a0 -> a0) -> (a0 -> a0)` `id id :: a0 -> a0` now we generalize `id id :: forall a. a -> a`, same result type, no?
02:21:40 <ski> __monty__ : yes, but consider `runST $ ...'
02:22:00 <__monty__> :t runST
02:22:01 <lambdabot> (forall s. ST s a) -> a
02:22:16 <ski> the `id id' example isn't a good example for showing off what impredicative can give you, that you can't get without
02:22:17 * __monty__ gasps
02:24:09 <ski> in this case, you need to specialized `($) :: forall x y. (x -> y) -> x -> y' into `($) :: ((forall s. ST s _a) -> _a) -> (forall s. ST s _a) -> _a', which requires impredicative polymorphism
02:24:49 <ski> (or the hack that GHC did to fake this particular case ..)
02:25:09 <__monty__> It's special-cased?
02:25:53 <merijn> Yes
02:26:16 <merijn> Which is why $ works with runST, but (.) often breaks
02:26:38 <ski> (yes, this is horrible)
02:28:21 <ski> luckily, now `BlockArguments' exists, so instead of `runST $ do ...', one can simply write `runST do ...'
02:28:34 <ski> <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#more-liberal-syntax-for-function-arguments>
02:29:23 <ski> (getting rid of another case of the ugly `$' is a bonus)
02:29:36 <merijn> I always kinda liked "$ do"
02:30:05 * ski smiles
02:30:31 <__monty__> I definitely don't like the withForeignPtr example.
02:31:43 <__monty__> So much hype around BlockArguments lately. Is the syntax only allowed in the last argument?
02:32:35 <kuribas> we finally have BlockArguments?
02:32:41 <kuribas> I wanted that for a long time
02:33:54 <ski> not just the last argument, you can write `(foo do ...) blah'
02:34:34 <Taneb> kuribas: yeah, that's in 8.6
02:35:48 <__monty__> I keep telling myself I should actually read the GHC user's guide some time...
02:37:52 <kuribas> Taneb: a but too cutting edge for using it know though...
02:38:38 <janat08> im trying to make obelisk project HIE compatible, is there a way to downgrade cabal?
02:39:50 <merijn> janat08: Cabal or cabal-install? And also, which version do you have now and which GHC do you have?
02:41:19 <janat08> 8.6.5, and i don't know. It says HIE doesn't support cabal new-* builds
02:45:34 <merijn> janat08: You can still use v1/old build with new cabals
02:46:07 <merijn> janat08: Your problem seems to be "you're using v2-build" in which case, downgrading cabal-install won't help you, since that will just break the current build setup
02:46:15 <janat08> so I should go ask obelisk people about hie compatibility.
02:47:16 <merijn> You can try, but that would involve them completely redoing their entire build setup, so seems unlikely to succeed
02:47:54 <janat08> So I take it there's no ide for cabal :D
02:48:00 <janat08> since intero uses stack
02:48:15 <janat08> Ill try intellij crap, their plugin seems to have abandoned use of intero
02:49:02 <merijn> The problem is that most tooling hasn't been updated to support v2-build, as it's relatively new and most of these tools are maintained by single persons in their spare time, so they haven't gotten around to it
02:53:37 <cocreature> janat08: Matthew Pickering’s hie-bios support has support for obelisk as far as I now
02:53:50 <cocreature> janat08: https://github.com/haskell/haskell-ide-engine/pull/1126
02:57:19 <kaychaks[m]> I want to concat a bunch of Rose Trees `[Tree a]` into a single tree `Tree a` while maintaining the heirarchies. I am sure of the fold but not sure of the balancing join operation that would take 2 trees and elegantly combine it to a tree with proper heirarchy. I have looked at many approaches concerning annotating Trees with some data about subforest but its getting complicated.
03:13:54 <lyxia> kaychaks[m]: what is that going to be used for?
03:15:37 <kaychaks[m]> you mean what the actual use case is ? I have a list of of DOM like nodes that I want to represent as Rose Trees and then I have to first join them all to form a single DOM node which ultimately I want to fold to some sort of string output (maybe HTML)
03:15:47 <kaychaks[m]> does that make sense or I got your question wrong lyxia 
03:30:42 <lyxia> that makes a bit more sense, but I still don't understand enough what that join is supposed to do.
03:31:41 <lyxia> Do you have some concrete examples of Rose trees combined in this way
03:35:39 <dibblego> wouldn't it take two [Tree a] (Forest a) and make a [Tree a] ?
03:39:35 <kaychaks[m]> no i don't. I want to encode a DOM like heirarchy as rose tree e.g. for this html fragment `<div id="1"> <div id="2"> </div> </div>`  I will have some thing like `Node 1 [Node 2 []]`. and for the fragment `<div id="1"><div id="3"></div><div id="4"></div></div>` I'll have `Node 1 [Node 3 [], Node 4 []]` then if I join these two tree I should have `Node 1 [Node 2 [], Node 3 [], Node 4[]]` mimicking a combined html fragment
03:39:35 <kaychaks[m]> `<div id="1"><div id="2"></div><div id="3"></div><div id="4"></div></div>`
03:40:39 <kaychaks[m]> dibblego: I did not get your point
03:41:41 <dibblego> I don't know what (Tree a -> Tree a -> Tree a) might be, but I do know what ([Tree a] -> [Tree a] -> [Tree a]) would be, as well as (Tree a -> [Tree a] -> Tree a)
03:42:08 <dibblego> also, Tree a -> Tree a -> [Tree a]
03:42:52 <dibblego> recall, you cannot go ([Tree a] -> Tree a) but you can (a -> [Tree a] -> Tree a)
03:43:19 --- mode: ChanServ set +o Sigyn
03:43:50 <dibblego> there is at least 1 (a) in Tree a, but not in [Tree a]
03:47:21 <lyxia> kaychaks[m]: from this example it looks like you want to check that the roots are equal and append their forests together
03:48:05 <dibblego> type Forest a = [Tree a]
03:49:58 <kaychaks[m]> dibblego: a -> [Tree a] -> Tree a make sense to me if I start with a root element and then fold the list of Tree
03:50:23 <kaychaks[m]> you meant that or something else
03:51:07 <dibblego> I'm not sure which of those operations you might want, or perhaps something else, but I don't think you can have Tree a -> Tree a -> Tree a, because now you have two roots, and which one is the new root? Unless you want to pick one.
03:51:34 <dibblego> are they the same root?
03:51:59 <lyxia> Honestly I wouldn't take types at face value at this point.
03:52:00 <dibblego> (a -> [Tree a] -> Tree a) is just the constructor
03:52:58 <dibblego> you could have Eq a => Tree a -> Tree a -> Maybe (Tree a) -- if the two roots are the same then Just 
03:53:03 <lyxia> Unless the asker shows that they're comfortable using precise types as specs, but most people aren't.
03:53:52 <kaychaks[m]> dibblego: yes I can have that  Eq constraint
03:54:09 <dibblego> yes, but what if the two roots are different values?
03:54:10 <kaychaks[m]> let me think a bit about it
03:59:07 <dibblego> also possible
03:59:07 <dibblego> merge' :: Semigroup a => Tree a -> Tree a -> Tree a; merge' (Node r1 f1) (Node r2 f2) = Node (r1 <> r2) (f1 ++ f2)
03:59:54 <dibblego> merge'' :: (a -> a -> a) -> Tree a -> Tree a -> Tree a; merge'' m (Node r1 f1) (Node r2 f2) = Node (r1 `m` r2) (f1 ++ f2)
03:59:59 <kaychaks[m]> If I want to add a new dummy root & make the two non equal nodes as child I might need some new data type isn't it to capture that 
04:00:31 <dibblego> well, you could use [Tree a]
04:01:00 <dibblego> you could use merge'' for that
04:01:22 <dibblego> merge'' (\a1 a2 -> if a1 == a2 then a1 else dummy)
04:02:50 <ski> @type let combine :: Tree a -> Tree a -> Tree a; combine (Node r ts) t = Node r (ts ++ [t]) in combine
04:02:51 <lambdabot> Tree a -> Tree a -> Tree a
04:02:53 <kaychaks[m]> But f1 ++ f2 won't recurse right
04:03:27 <dibblego> not sure what you mean by recurse
04:03:38 <dibblego> Tree is recursive in its definition
04:05:10 <kaychaks[m]> Oh sorry
04:05:35 <dibblego> you can do what ski suggests and push one of the trees down to a child
04:05:47 * ski . o O ( "Seven Trees in one" by Andreas Blass in 1995 at <http://www.math.lsa.umich.edu/~ablass/comb.html> )
04:06:39 <rsoeldner> Is there an easy way to use nix to generate a tags file for all packages which are in scope ?
04:06:52 <kaychaks[m]> And combine goes as foldr function to the list of trees
04:07:11 <ski> kaychaks[m] : that call to `(++)' won't recursively traverse the trees with  merge''  no
04:10:20 <dibblego> combine does this https://imgur.com/a/v7cdO56
04:31:58 <kaychaks[m]> dibblego: i thought merge'' would put a dummy like this
04:32:15 * kaychaks[m] uploaded an image: ima_b245c6b.jpeg (126KB) < https://matrix.org/_matrix/media/v1/download/matrix.org/ZVxFVYyLsDJdOtrayxcdbbvZ >
04:35:19 <dibblego> merge'' https://imgur.com/a/EKO5x5p
04:36:28 <dibblego> merge''' :: a -> Tree a -> Tree a -> Tree a; merge''' root t1 t2 = Node root [t1, t2]
04:36:36 <dibblego> this is what you drew ^^
04:38:17 <kaychaks[m]> yeah I got your point but merge'' is having the assumption that subforest only contains leaves but in case they dont then I need to some way traverse and merge'' the children as well isnt it
04:39:31 <dibblego> no, there are potential subtrees under those as well.
04:41:58 <dibblego> https://imgur.com/a/nVRdvnN
04:51:07 <kaychaks[m]> Hmm. My use case is something like this where I can put a eq constraint to combine & add sub forest of second tree to first I think 
04:51:16 * kaychaks[m] uploaded an image: ima_46e07e8.jpeg (57KB) < https://matrix.org/_matrix/media/v1/download/matrix.org/CWGqnFmLCAqdeIxMHlwqeYmT >
04:52:47 <merijn> kaychaks[m]: FYI, pasting images is going to drastically reduce the amount of people who bother to look what's going on
04:56:17 <dibblego> this assumes all roots are equal, what if they are not?
04:58:32 <kaychaks[m]> <merijn "kaychaks: FYI, pasting images is"> am sorry. will make sure to paste url going forward
05:03:40 <dminuoso> Why might `cabal new-exec` not pick up changes to source files while `cabal new-build` would?
05:05:48 <dibblego> maybe it only looks at files under executable and not library
05:06:32 <dminuoso> dibblego: Ahh spot on, thanks.
05:06:51 <dminuoso> dibblego: That seems annoying though.
05:07:07 <dibblego> I often have two different terminals in situations like that
05:07:13 <kaychaks[m]> <dibblego "this assumes all roots are equal"> data I will be getting as input will be a list of this structure that might start at a common root and then will have different elements as children. when I will combine them to form a single tree I can assume to have the top most root common and then traverse to match children and combine them appropriately. Or not ?
05:08:12 <dibblego> kaychaks[m]: if they came from the same place, I'd split into a single root value, and then the two different forests under it
05:09:08 <dminuoso> dibblego: But still, why does `new-build` consider the library, but `new-exec` apparently not?
05:09:37 <dibblego> dminuoso: I wouldn't know exactly, try #hackage ?
05:10:33 <fendor> can lambdabot be integrated into mattermost?
05:14:48 <__monty__> dminuoso: Maybe new-exec is just an easy way to run .result/.../.../.../bin/yourExe
05:15:24 <dminuoso> __monty__: ohh darn, I was fiddling too much with my build system. Of course I want new-run 
05:15:26 <dminuoso> Haha.
05:15:30 <dminuoso> Cheers. :)
05:16:49 <python476> hello $ \s
05:21:29 <janat08> is there ide engine/tool for new cabal
05:22:18 <__monty__> janat08: GHCId works fine with new-repl for me.
05:34:25 <gobby> I've sent my yesod app binary to a google cloud compute instance. I've changed my `Approute` to match the external ip (https://xx.xxx.xx.xx) but I still get nothing when I navigate to that ip with my browser
05:34:47 <gobby> It serves my JSON file when I test it localhost
05:35:16 <merijn> gobby: Define "nothing"
05:35:57 <gobby> site cannot be reached xxx.xx.xx.xx refused to connect
05:37:47 <Rembane> gobby: Which port does the server bind to?
05:38:24 <gobby> merijn: `settings.yml` has it set at 3000
05:38:36 <merijn> gobby: Are you pointing your browser at port 3000?
05:38:51 <merijn> Is the firewall setup right?
05:39:36 <gobby> merijn: I am. The developer console says pending
05:39:52 <gobby> merijn: When I navigate to port 3000
05:40:54 <gobby> merijn: My instance also has an internal IP, do I need to forward the request to that IP on my server?
05:43:34 <merijn> Yes, no, maybe, I don't know how google cloud compute instance are setup to handle networking
05:45:11 <warbo> hello, I'm playing with the GHC API, and want to get all of the instance methods defined in a (user-supplied) module
05:45:32 <warbo> these are given Core names like $fFooBar, which can't actually be used in Haskell
05:45:59 <warbo> I'm wondering it's I can recover them as simply as 'methodName @TypeName'?
05:46:27 <warbo> *if
05:47:05 <gobby> merijn: I just scanned my open ports, my yesod app runs on the internal IP so I probably have to do some kind of forwarding/redirecting
05:47:11 <gobby> merijn: thanks for trying :)
05:49:04 <merijn> gobby: Or bind it to the public IP ;)
05:59:38 <gobby> merijn: weirdly enough my Yesod app is using PPP according to nmap
06:00:06 <gobby> I launched an apache HTTP server and I could access it no problem
06:00:31 <Rembane> gobby: I think it is the PPP port, but still HTTP.
06:01:22 <gobby> Rembane: Hmmm I'll bind my yesod app to 80 (instance of 3000) and see what happens
06:01:29 <gobby> instead*
06:03:10 <Rembane> Do it! :D
06:06:47 <gobby> Rembane: I just needed to change the Approot and bind it to 80 :) Success!!!
06:07:26 <Rembane> gobby: Sweet! :D
06:31:15 <warbo> hmm, I can turn the 'show' implementation for Int into a "standalone function" by doing 'show @Int'
06:31:38 <merijn> warbo: You don't have to do that
06:31:48 <warbo> not so straightforward for '[]' though, e.g. 'show @[_]' has type 'Show w => [w] -> String' which still has a constraint
06:31:49 <merijn> warbo: You can just do "foo :: Int -> String; foo = show"
06:32:23 <merijn> warbo: Of course it still has a constraint, how would you print a list with unprintable items?
06:32:35 <merijn> warbo: More importantly, why do you want "no constraints"?
06:32:41 <warbo> merijn: yes, but I want to try extracting these automatically, which would be easier if I don't have to try parsing and unifying the types myself
06:33:07 <merijn> warbo: What does "extracting" here mean?
06:33:16 <warbo> some experimenting, which requires monomorphic functions
06:33:54 <warbo> I'm using the GHC API to extract type class method implementations from module interfaces
06:34:13 <merijn> hmm, there's no function for creating a file IFF it doesn't exist yet? directory doesn't seem to have, a function like "touch"
06:34:23 <warbo> I want to perform some automated analysis on the code
06:36:28 <warbo> interestingly, what I'm doing would be trivial with Core, since instances are explicit dictionaries at that point
06:37:45 <warbo> I want those dictionaries as first-class Haskell values though code
06:40:33 <higherorder> Is there a standard function / a way to describing a function which would have the type signature `compose :: (b -> Maybe c) -> (a -> Maybe b) -> (a -> Maybe c)` ?
06:40:56 <merijn> higherorder: You mean the fish operator?
06:40:59 <merijn> :t (>=>)
06:41:01 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
06:41:22 <higherorder> merijn: ah, exactly! thanks :)
06:41:53 <merijn> higherorder: Also, Control.Category.. for "Kleisli Maybe" :)
06:42:03 <merijn> :t (Control.Category..)
06:42:04 <lambdabot> forall k (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
06:42:29 <merijn> ugh...polykinds make that type ridiculously intimidating >.>
06:43:13 <merijn> hmm, am I really stuck with using "unix" to get O_CREAT | O_EXCL file opening and not something clean in base?
06:43:54 <Rembane> merijn: What are you trying to do? 
06:44:04 <merijn> Rembane: Create a file IFF it doesn't exist
06:44:41 <merijn> Rembane: All the open function in System.IO/System.Directory clobber the original file if it exists
06:45:01 <merijn> It's weird that it's missing, since opening with O_CREAT|O_EXCL is super common...
06:45:15 <Rembane> merijn: Do it the other way around. Open file, catch exception and create new file. 
06:45:32 <merijn> Rembane: That's wrong
06:45:38 <merijn> Rembane: That's a race condition
06:45:44 <Rembane> merijn: Does the same thing exist on Windows for instance? 
06:45:50 <merijn> Rembane: The entire point of O_CREAT|O_EXCL is to avoid a race condition
06:45:53 <Rembane> merijn: I like race conditions. Is it important in this case? :)
06:46:24 <merijn> Rembane: I can't imagine Windows *not* having a save way to open+create a file
06:47:03 <Rembane> merijn: Weirder things have happened though. I dare you to create a cleaner solution in base! :D
06:50:15 <merijn> oh, ffs
06:50:34 <merijn> Can't even do it with unix, because openFd only has an API for O_EXCL, but not for O_CREAT
06:51:20 <__monty__> So touchFile's not good enough?
06:51:42 <merijn> __monty__: touchFile succeeds if the file already exists
06:51:56 <merijn> __monty__: I want to atomically create a file IFF it doesn't exist
06:52:41 <merijn> Sometimes I am baffled how some downright common operations are missing from base/unix
06:54:25 <__monty__> merijn: You don't want to use it if it already exists?
06:54:51 <merijn> __monty__: If the file already exists something is wrong
06:55:14 <merijn> __monty__: And we shouldn't be executing this code path
06:55:28 <__monty__> How about doesFileExist?
06:55:28 <higherorder> Also, other question: is there such a thing as lenses which keep track (at runtime) of the current "path" in the data-structure? I would like to get able to compose accessor functions to get stuff from a deep data-structure, but also be able to return errors pointing at what data is erronous
06:55:40 <merijn> oh, looks like openFd automatically specifies CREAT if permissions are set
06:55:49 <merijn> __monty__: Any use of doesFileExist is basically an error
06:56:13 <merijn> __monty__: doesFileExist is a walking TOC-TOU race
06:56:45 <__monty__> What's the difference between the file getting created after the check and after you creating it though?
06:57:55 <__monty__> Like is the race really absent if you creat|excl?
06:57:56 <merijn> __monty__: Programs don't have exclusive access to the filesystem, so me checking if a file exists and then creating it if it doesn't goes wrong if something/someone else races you and creates it in between the check and the operation
06:58:23 <merijn> __monty__: Yes, the kernel/filesystem atomically checks and creates it with O_CREAT|O_EXCL, that's the point of having it
07:16:41 <tchakka> Do we have a canonical elasticsearch library?
07:18:07 <dminuoso> tchakka: bloodhound perhaps?
07:18:25 <tchakka> Hasn't been updated in a year, though. At least, the hackage version isn't.
07:18:48 <merijn> Is there any specific reason it should've been?
07:20:29 <tchakka> Dunno! I'm a bit wary of including non-stackage dependencies that haven't seen an update for a while. Might be the rare bug-free package, though, who knows :P
07:21:11 <merijn> Stackage doesn't guarantee much
07:22:12 <fendor> how can I read that error cabal conflict message? https://pastebin.com/WeA8Gjjp I read this as, brainfuck and base are conflicting, but the brainfuck version it tries to use seems like it doesnt exist on hackage and moreover, none of the versions on hacakge have the version constraint that is displayed in this error message
07:23:01 <tchakka> Guarantees more than bare hackage, but yeah, it's a conservative selection. Haven't migrated things to cabal new-stuff yet.
07:23:10 <tchakka> But cheers, will check out bloodhound.
07:23:12 <c_wraith> mjo-k\
07:23:13 <c_wraith> ]\
07:24:07 <merijn> fendor: Top line says: 'cabal.project.local' file already exists. Now overwriting it.
07:24:24 <merijn> fendor: So, I'm thinking maybe it's using a brainfuck version from a public repository, not Hackage
07:24:38 <merijn> fendor: But that's impossible to say without seeing the cabal.project
07:25:15 <fendor> merijn, repo is https://archives.haskell.org/code.haskell.org/lambdabot/
07:25:20 <merijn> tchakka: I meant there's plenty of stuff in stackage that's merely getting small maintenance updates, and just volume of maintenance doesn't say much
07:25:36 <dminuoso> fendor: You have a dependency on a different base package than you have installed.
07:25:37 <dminuoso> fendor: Or rather, brainfuck has a base dependency that your installed base cant be satisfied with.
07:25:44 <fendor> would make sense, but I dont know where this might be specified
07:26:04 <merijn> dminuoso: His question was about the fact that none of the Hackage brainfuck versions match that version and constraint
07:26:05 <fendor> dminuoso, brainfuck base has > 3 && < 5 so, that should work fine
07:26:40 <dminuoso> Ah.
07:27:25 <merijn> And brainfuck 0.1.1 doesn't exist on hackage
07:27:38 <fendor> i should proabbaly have read the readme first. maybe there is more information on how to build
07:27:43 <merijn> fendor: Is there a cabal.project(.local) in your current directory?
07:28:00 <fendor> no, there is no cabal.project, seemingly
07:28:07 <merijn> mmm
07:28:09 <dminuoso> fendor: any reason you are using that particular version of lambdabot instead of the one from github?
07:28:33 <fendor> dminuoso, I thought that is the most recent one, since haskell wiki links it T_T
07:28:48 <merijn> fendor: The haskell wiki isn't always...up to date either :p
07:28:49 <dminuoso> fendor: well the haskell wiki...
07:29:04 <merijn> dminuoso: Too slow ;)
07:29:26 <Phyx-> merijn: Rembane Windows has OPEN_ALWAYS for this situation
07:29:32 <dminuoso> merijn: wifi on the train, sometimes rather laggy :)
07:29:42 <fendor> yeah, github seems to have a cleaned up repo
07:29:44 <merijn> Phyx-: Like I said, I'm *sure* windows has something for this :)
07:29:48 <dminuoso> fendor: its orthgonal to your issue though, im still curious why you have that error.
07:29:56 <Phyx-> merijn: :)
07:30:03 <dminuoso> fendor: what happens if you crank up verbosity with `-v3`?
07:30:05 <merijn> I'm confused why it's even writing a cabal.project.local
07:30:11 <dminuoso> fendor: any potential insights?
07:30:12 <merijn> fendor: Which command did you run?
07:30:24 <fendor> merijn, i tried cabal new-configure, but the same happens with cabal new-build
07:30:42 <fendor> just without trying to create a cabal.project.local
07:30:51 <merijn> fendor: Can you first remove cabal.project.local and then retry new-build
07:31:30 <fendor> dminuoso, https://pastebin.com/U2Tx85sc that is a lot
07:31:33 <merijn> fendor: Also, might wanna start using v2-build and v2-configure instead for forward compatibility
07:32:15 <fendor> merijn, still same error message
07:32:25 <Synthetica> Does the O(min(n, W)) complexity on Data.IntSet operations mean that the operation is constant-time if I have more than 64 elements, or am I missing something here?
07:32:29 <fendor> after deleting cabal.project.local and cabal.project.local~
07:32:42 <merijn> Bingo!
07:32:50 <merijn> https://hackage.haskell.org/package/unlambda-0.1.2 <- wants base <4.6
07:33:09 <fendor> but that is not the conflict set, right?
07:34:04 <merijn> Synthetica: It means the complexity isn't impacted by set size if your set is >W
07:34:36 <merijn> fendor: That's a weird ass list of constraints passing by later, though...
07:35:07 <fendor> I still dont know where this version of brainfuck comes from
07:35:22 <merijn> fendor: Can you try running "cabal v2-update" and then retrying?
07:35:35 <fendor> already did that
07:35:40 <fendor> no difference
07:35:51 <Synthetica> merijn: I have no idea how they do that, I guess I'll read the linked paper 🤷
07:36:24 <merijn> Synthetica: Basically by abusing the fact that the structure of signed integers is bounded and known
07:36:40 <dminuoso> fendor: did you add the `cabal.project.local`? I dont see it in that archive
07:36:41 <dminuoso> fendor: So Im wondering whether we are looking at the same project.
07:37:01 <merijn> Synthetica: Are you familiar with radixes/radix trees?
07:37:08 <dminuoso> fendor: the version of brainfuck is shipped with it.
07:37:20 <fendor> dminuoso, I didnt, I think new-build did it, but I also tried new-configure, that might have generated it, too
07:37:35 <Synthetica> merijn: No
07:37:41 <fendor> dminuoso, hm, i used darcs clone to get it...
07:37:55 <merijn> Synthetica: Normal sets are (self-balancing) binary trees, so you do lookups by comparing the lookup vs current value and branching left or right on the result
07:38:04 <vaibhavsagar> is there a way to make ghcid exit with error code 0 after successfully building?
07:38:40 <vaibhavsagar> i.e. yes, ghcid worked as expected
07:38:47 <fendor> dminuoso,you are right, it ships its brainfuck version. alright, then i suppose, that is the problem
07:38:56 <merijn> Synthetica: With integers you can do funky things like first tree level compares the 1st bit, 2nd level compares 2nd bit, etc. in which ase tree depth is bounded by number of bits (you can never have more levels than bits)
07:39:18 <merijn> Synthetica: So checking for an element is AT MOST N comparisons where N is number of bits
07:39:24 <Synthetica> merijn: Right, that makes sense
07:39:42 <merijn> Synthetica: (Not sure that's what they do, but that's one way you can cheat)
07:40:13 <merijn> Synthetica: The problem with regular sets is that you only know "elements are comparable" and not what the structure of set elements is. IntSet does have that extra info
07:40:15 <dminuoso> fendor: there is a subdirectory brainfuck/ inside, Im thinking thats whats being picked up
07:40:15 <dminuoso> fendor: can you clean it again and run a plain `new-build`
07:40:15 <dminuoso> fendor: merijn probably knows better why it picks up on that
07:40:19 <dminuoso> fendor: I just see the library in there and made an educated guess, it'd be better to understand how cabal selects candidates for goals.
07:41:08 <merijn> dminuoso: If there's no cabal.project v2-build uses an (implicit) cabal.project, which probably picks up brainfuck in addition to the lambdabot cabal file
07:41:32 <fendor> very interesting, thank you! 
07:41:38 <fendor> i will use the github version, though :)
07:42:17 <merijn> dminuoso: But it should only pick up ./*.cabal
07:42:23 <merijn> oh
07:42:35 <merijn> optional-packages defaults to ./*/*.cabal
07:44:55 <merijn> So creating a cabal.project and explicitly setting optional-packages empty should fix it
07:47:24 <fendor> i dont think that is easily fixable, since then the real conflict arises that the local brainfuck lib needs base < 4
07:47:42 <merijn> fendor: Doing that stops trying to use the local brainfuck lib :p
07:47:55 <fendor> and that just works out of the box?
07:48:10 <fendor> however, github will be more up-to-date right? 
07:49:22 <dminuoso> fendor: well at any rate, picking the version from github should fix your issue...
07:49:43 <fendor> yeah, I think, I prefer that :)
07:50:22 <dminuoso> fendor: yes.
07:50:22 <dminuoso> fendor: if you feel inclined you could perhaps make a note in the haskell wiki
07:50:57 <fendor> i think I even made an account on the wiki... if i could only recall my pw
07:51:57 <dminuoso> merijn: That default seems a bit weird honestly
07:53:30 <fendor> I think that sounds like a resonable default. Since sub packages are often in the top-level of a project
07:53:31 <merijn> dminuoso: Why?
07:53:52 <dminuoso> merijn: Im not a big fan of "implicit"
07:54:15 <merijn> dminuoso: Well, the alternative is "v2-build doesn't work unless you write a cabal.project file first"
07:54:34 <merijn> dminuoso: As it is you can take any random cabal repo and run "cabal v2-build" in it and it will work
07:54:40 <dminuoso> merijn: No my point is the default behavior that cabal picks up ./*/*.cabal for optional dependencies
07:55:17 <merijn> dminuoso: The assumption is "if you vendor packages by including them completely in your repo, you probably want to prefer using those, else why include them"
07:55:41 <merijn> dminuoso: I mean, why is there a broken incompatible brainfuck package inside the lambdabot repo?
07:57:02 <dminuoso> merijn: Why do I have to specify all other-modules then?
07:57:52 <merijn> dminuoso: Because the CABAL spec is conservative and cabal-install (especially v2) is much less so
07:58:15 <dminuoso> merijn: Ah okay. That makes sense.
07:59:49 <nitrix> merijn: Why does Prelude's (>>=) has an explicit forall? `forall a b. m a -> (a -> m b) -> m b`? My understanding is that it isn't necessary, or perhaps because of {-# LANGUAGE ExplicitForAll #-}.
08:00:09 <merijn> dminuoso: I mean, I agree that it's annoying that it broke here, but OTOH "people have included (broken and) unnecessary cabal packages in their repos" seems like a rather niche failure case
08:01:02 <merijn> nitrix: Who knows? Check the commit that added it? :p
08:01:57 <fendor> I think so, too, it is normally the preferred behaviour. 
08:02:27 <fendor> weirdly, the github package does also not build after cloning. Had to fix the network constraint and bump lower version of the hoogle constraint
08:02:55 <fendor> then it tells me that I am on nixos, and nothing works on the first try.
08:02:56 <dminuoso> nitrix: There is a reason
08:03:05 <dminuoso> nitrix: it had to do with the desugarer.
08:03:17 <dminuoso> nitrix: (its to pin the order of type variables)
08:05:15 <merijn> So...basically to fix everyone's use of TypeApplications, copying my prediction of why that extension is a terrible idea to use
08:05:35 <janat08> where do I find what =: specifically means?
08:06:00 <merijn> janat08: Depends where you're getting it from?
08:06:23 <merijn> janat08: It's "just an operator", so what it means depends on how defines it
08:07:08 <janat08> i found out its data.map, but what if I didnt know
08:07:39 <merijn> I'm pretty sure Data.Map does not define =:
08:08:04 <dminuoso> merijn: Im not sure about that.
08:08:12 <dminuoso> merijn: The change is pretty much as old as Monad is.
08:08:16 <merijn> janat08: You can look it up in ghci, else you'll have to look at the docs of whereever you encountered it
08:08:19 <merijn> dminuoso: hmm
08:09:26 <phadej> fendor: I think of removing nix stuff from `github`s repository; i don't use it, so it simply bitrots
08:09:40 <phadej> where "use it" = "use nix"
08:09:53 <phadej> someone added it sometime ago, but ...
08:10:02 <fendor> phadej, understandable, I mainly complaining about my own incompetence
08:10:07 <fendor> *I am
09:05:13 <bartholin> Are there some exotic uses of functors in haskell? I mean something else than mapping some function inside a container.
09:05:56 <Rembane> Lenses! 
09:06:19 <Rembane> And this: https://blog.jle.im/entry/functor-combinatorpedia.html#.XQp9030KI8I.twitter
09:06:25 <Rembane> And this: https://blog.jle.im/entry/functor-combinatorpedia.html
09:06:43 <Rembane> Sorry, they are the same, but the last one doesn't track you from twitter.
09:07:12 <bartholin> thanks
09:15:59 <lyxia> bartholin: recursion schemes https://blog.sumtypeofway.com/an-introduction-to-recursion-schemes/
09:16:42 <lyxia> Functor-oriented programming http://r6.ca/blog/20171010T001746Z.html
09:18:01 <jle`> bartholin: by that do you mean 'some exotic functors'? or do you mean exotic functor-polymorphic abstractions?
09:18:55 <bartholin> something that implements the Functor typeclass
09:19:24 <jle`> ah, ok
09:19:53 <jle`> one of the 'non-container' functors people often learn about first is (->) r, function
09:20:34 <jle`> > (fmap show negate) 3
09:20:36 <lambdabot>  "-3"
09:21:47 <jle`> > (fmap (+3) (*2)) 7
09:21:49 <lambdabot>  17
09:22:14 <jle`> another one of my favorite non-container functors is `Const e`
09:22:21 <jle`> > fmap negate (Const "hi")
09:22:23 <lambdabot>  Const "hi"
09:23:23 <jle`> and of course another 'non-container' functor people usually run into very soon is 'IO', which is a very interesting Functor
09:23:48 <jle`> understanding the IO instance of Functor forces you to understand the concept of IO as an inert 'normal' data type
09:29:39 <jle`> and if you're going for 'exotic' as in the type itself is exotic, then certainly one of the weirdest ADTs is FunList (a "non-regular" data type), which is arguably a container, but the internal implementation is a bit mind boggling
09:29:57 <lavalike> :t Const
09:29:59 <lambdabot> forall k a (b :: k). a -> Const a b
09:30:09 <jle`> data Const e a = Const e
09:30:22 <lavalike> why is there a k in there just for b?
09:30:35 <jle`> because Const is poly-kinded
09:30:48 <jle`> you can have a value of type `Const Int Monad`, for instance
09:31:00 <jle`> so the k is a "kind parameter" here
09:31:25 <lavalike> 'e' instead needs to be '*' nothing more fancy, maybe a little variation but not * -> * or similar
09:31:41 <jle`> indeed, the 'a' (or 'e' in my example) is not poly-kinded
09:32:19 <lavalike> good enough
09:32:49 <jle`> if you have `Const Int String`, then k ~ Type, and b ~ String; if you have `Const Int Maybe`, then k ~ Type -> Type, and b ~ Maybe
09:54:26 <alx741> hello all. I have a package A in my host (not in hackage), and another project B that depends on A. I did `cabal v2-install --lib` in A, but then `cabal v2-build` in B complains because of an "unknown package: A". Am I procedding wrong?
09:54:53 <c_wraith> cabal v2 doesn't support that use case.
09:55:49 <alx741> c_wraith: hmm, how would I go about it then? v1?
09:57:08 <c_wraith> that'd work, though with all the associated issues. I think there's an alternative. I don't recall the details, but I think you can tell v2 to find a library locally. 
10:02:33 <alx741> c_wraith: is this something that v2 doesn't handle *yet*, or a change on how things work in general?
10:03:50 <c_wraith> it's intentional. unless you specify you want to work from a local source, it has no reason to believe that another installed package happens to be what you want to use.
10:04:05 <lyxia> alx741: perhaps something here is relevant https://www.haskell.org/cabal/users-guide/nix-local-build.html#developing-multiple-packages
10:07:01 <geekosaur> this is where cabal.project comes in, isn't it? to tell it which packages go together and how they do so?
10:07:52 <alx741> c_wraith: oh, got it
10:08:08 <alx741> lyxia: looks like, going to try it, thanks
10:10:19 <alx741> geekosaur: apparently, Have always used stack's feature of declaring packages given a location (local, from a git repository, etc) so I'm a bit lost
10:13:23 <sm[m]> you can't just specify the A dir on the command line ? was that cabal v1 only ?
10:14:53 <elliptic0> hi,
10:15:44 <alx741> sm[m]: was that possible in v1? how?
10:16:20 <sm[m]> I seem to remember doing cabal install ./A ./B where B depends on A
10:16:34 <elliptic0> Can anyone explain to me why Haskell did not implement Dependency Type?
10:16:50 <geekosaur> sm[m, v1 only because v1 installed all packages into the same place and you got to deal with their compatibility
10:17:03 <sm[m]> (and probably the ./ wasn't needed)
10:17:03 <geekosaur> elliptic0, because it's a pain?
10:17:15 <jle`> elliptic0: what is dependency type?
10:17:38 <jle`> are you thinking of dependency graphs, maybe?
10:18:00 <jle`> in which case there are a few graph implementations as a part of libraries
10:18:47 * geekosaur read as dependent types, and is looking for that paper
10:19:08 <sm[m]> https://wiki.haskell.org/Dependent_type
10:20:33 <elliptic0> I'm talking about like Agda.  Agda is fully Dependency Type.
10:20:52 <jle`> ah, Dependent Types
10:20:57 <alx741> aren't dependent types planed for GHC 8.10.* or something like that?
10:21:12 <geekosaur> planned for sometime in the not particularly near future
10:21:36 <jle`> honestly the jury is still out on whether or not dependent types are worth the extra complexity they bring
10:21:53 <geekosaur> ^
10:22:00 <jle`> if it's still uncertain now, it was definitely uncertain in 1990 when they wrote Haskell
10:22:23 <geekosaur> and I'm inclined to think anyone who could walk in and ask that question has not played with them yet...
10:22:31 <jle`> Haskell was sort of an incremental step from some established languages at that time
10:22:46 <jle`> it had a good idea of what it was meant to be, from what its influences were
10:22:47 <elliptic0> Haskell has Generialized Algebraic Data Type, GADT, but it is still not fully Dependent Type.
10:23:00 <jle`> that is a true fact
10:23:53 <monochrom> I think of the current trend as bolting on dependent typing to Haskell.
10:24:03 <jle`> if you're looking at 'why' in terms of the motivations of the haskell committee, the simple reason was that there was a list of languages that they decided early on would be haskell's close influences, and none of them had dependent types
10:24:57 <monochrom> As for history, dependent typing : haskell :: parametric polymorphism : C
10:25:15 <jle`> if you're looking at 'why' in terms of a hypothetical self-aware haskell that governs its own evolution, it is probably because we don't really know if it's worth it
10:25:24 <elliptic0> I just watched YOutube video on LiquidHaskell, It is pretty fascinated stuff. 
10:25:40 <nitrix> Can I get feedback on wether or not my reminder notes here are correct? https://notes.nitrix.me/programming/theory/forall
10:25:44 <jle`> if you're looking at 'why' in terms of why we don't have it now, it's mainly because it is very hard to implement and a bunch of really smart people have been trying to implement it for years and it's not ready even yet
10:26:00 <dmwit_> (Why didn't the languages on that list of languages have dependent types? Because we don't really know if it's worth it.)
10:26:09 <monochrom> Just yesterday a couple of us discussed that refinement typing fits more nicely.
10:26:10 <dmwit_> Underscore begone!
10:26:29 <elliptic0> you can declare a Int type  like    {n : In | 6 <= n <= 100}
10:26:39 <nitrix> And here I thought dmwit was growing another letter.
10:26:45 <jle`> elliptic0: yeah, refinement types are a nice space that probably has more 'definite' advantages that are worth the cost, compared to dependent types
10:27:09 <monochrom> dmwit is playing the Snake Game :)
10:27:10 <nitrix> Progeny o:
10:27:25 <dmwit______> HELP IT'S GROWING AND I CAN'T STOP IT
10:27:47 <jle`> 👻
10:28:43 <elliptic0> If we can declare a type like in LiquidHaskell,  {n: Int | 0 <= n && n <= 10} in C++ and Java, then, there are tons of bugs will be eliminated in the future.
10:29:55 <monochrom> They already do. Minority, but they already do.
10:30:01 <ski> monochrom : hm, which attempts to bolt on parametric polymorphism to C ?
10:30:25 <monochrom> No, I mean "why didn't Haskell has dependent typing at the beginning?"
10:30:38 <ski> oh
10:31:32 <monochrom> Over there in imperative land, "refinement type" is called predicate subtype or even simply assertions, and has been around for decades.
10:33:34 <monochrom> Formal methods began in imperative land, after all.
10:33:49 <ilikeheaps> Uh, it seems like a library I use doesn't export a type from its dependency that I want to include in a type annotation. Is there some magic way to bring it into the scope? Now I'm just using a partial signature
10:34:38 <monochrom> Anyway look for JML and ESC/Java.
10:35:15 <elliptic0> well, you can implement anything from C/C++/Java because they are all Turning-complete. But We are talking about whether the Language supports the feature.
10:35:20 <Cale> dmwit: We're still not really sure if it's 100% worth it -- there are lots of good things that can come of dependent types, but they require much more restraint on the part of the programmer to be used tastefully. They're also a powerful tool in the hands of someone who wants to make you work hard to prove things you don't actually care about.
10:36:52 <Cale> I think overall it will be beneficial, but there's more danger now of imposing meaningless structure than there was with Haskell 98's types.
10:40:23 <ski> monochrom : oh, clog was apparently away at the time
10:41:57 <ski> monochrom : what i understand as "refinement type" is sortof "anti-subtyping", or rather, instead of extending a variant or record type (possibly recursive), by adding alternatives / fields, you restrict it, by deleting alternatives/fields (more or less)
10:42:47 <ski> (which is something else than what LiquidHaskell offers)
10:45:21 <ski> (e.g. given `data List a = Nil | Cons a (List a)', you could imagine `data EvenList a :< List a = Nil | Cons a (OddList a); data OddList a :< List a = Cons a (EvenList a)', where `EvenList a' and `OddList a' becomes subtypes of `List a')
10:46:32 * ski . o O ( "Supertyping Suggestion for Haskell" by John Meacham at <http://www.repetae.net/recent/out/supertyping.html> )
10:48:10 <ski> (in Mercury, you wouldn't express `EvenList' and `OddList' as (sub)types, but rather as "inst(antiation state)s", <https://www.mercurylang.org/information/doc-latest/mercury_ref/Insts-modes-and-mode-definitions.html>)
10:48:56 <elliptic0> I'm sure those Dependent Type and Refined Type will help the programmer a lots. 
10:51:18 <elliptic0> Image I can write: myfun(Int n:{n % 7 == 0}, ...) in C++ or Java code.
10:52:40 <elliptic0> maybe myfun(Int n : {n % 7 /= 0}, ...).. whatever..
10:54:45 <dmwit> ilikeheaps: You have to also depend on the thing.
10:55:08 <dmwit> ilikeheaps: So if you depend on foo, and it depends on bar, and you want to mention a type from bar that foo doesn't re-export, you have to depend on bar.
11:10:58 <vijaytadikamalla> Hi, I want to apply a function on all pairs of a map. So how to do it without converting it to list? 
11:12:43 <kritzefitz> vijaytadikamalla, Data.Map has a `mapWithKeys function.
11:13:47 <vijaytadikamalla> thanks
11:16:01 <kritzefitz> I was just trying out the v2 commands of cabal-install (I have been mostly using stack before). I was trying out new-install in a project that builds one executable, but nothing seems to get installed anywhere. Is this a feature?
11:18:02 <kritzefitz> I was expecting the executable to show up in ~/.cabal/bin, but the directory is still empty.
11:18:21 <kritzefitz> I'm using cabal-install 2.2.0.0, built with Cabal 2.2.0.1 BTW.
11:19:46 <int-e> under linux I get something in ~/.cabal/store/ghc-<version> and additionally a symlink under ~/cabal/bin
11:20:53 <int-e> sorry, ~/.cabal/bin
11:20:57 <kritzefitz> int-e, there are packages in ~/.cabal/store/ghc-<version>, but my package is not among them.
11:24:38 <int-e> kritzefitz: maybe the problem is that new-install needs a target unless there's a cabal.project file? when compiling from a source directory, maybe try  cabal new-install .
11:25:17 <sclv> kritzefitz: i think new-install was not very wirking in 2.2
11:25:21 <int-e> kritzefitz: the final . is meant to be part of the command
11:25:46 <int-e> oh yeah I'm on version 2.4.1.0
11:25:59 <kritzefitz> int-e: The it says "[__0] unknown package: . (user goal)". The same happens when I specify "my-executable" or "exe:my-executable" as the target.
11:26:10 <kritzefitz> sclv: Hmm, okay. Maybe I should just try a newer version.
11:26:26 <int-e> kritzefitz: do you have a .cabal file at all...
11:27:10 <kritzefitz> int-e: Yes.
11:27:39 <kritzefitz> new-build and new-run worked just fine. I guess they wouldn't work without a .cabal file.
11:28:58 <dmwit> (correct)
11:29:28 <int-e> Ah yes, 2.2 doesn't work for me either :)
11:39:45 <nitrix> Every time I read your name I think of a little dragon.
11:40:14 <nitrix> It's burned in my memory :)
11:46:36 <kritzefitz> Ah, now it works with cabal-install 2.4.1.0. int-e, sclv, thanks for your help!
11:50:26 <int-e> nitrix: me? if so, first step towards world domination complete!
11:52:46 <nitrix> :]
11:54:26 <Rembane> Next step: Grow big!
11:57:03 <kritzefitz> According to the documentation v2-install doesn't create self-contained installations, because the data-files still reside in ~/.cabal/store. Is there some other "official" way to create a self-contained installation?
11:57:44 <kritzefitz> Copying the directory from ~/.cabal/store seems to work, but I feel like that's relying on undocumented behaviour and might break some day.
11:58:00 <sclv> no
11:58:33 <monochrom> This is why I still like the v1 commands. May them last forever.
11:59:07 <sclv> i mean v1 isn't self-contained either. it just sticks the data files somewhere else. arguably somewhere less likely to get wiped than store but...
11:59:20 <monochrom> But the cabal developer attitude seems to be that "if you want that, run Setup.hs directly, don't pass Go, don't benefit from auto dependency chasing".
11:59:40 <sclv> i don't think that's the attitude
11:59:45 <sclv> i jsut dont' know what the right thing to do is
11:59:48 <sclv> for datafiles
12:00:17 <monochrom> Well when they finally yank out v1 completely, that's the only choice left.
12:00:32 <sclv> as i said for v1 it doesn't "solve" the self contained datafile problem
12:00:32 <monochrom> And yes I infer attitude from actions.
12:00:42 <sclv> by definition they're in some other location than the executable
12:00:48 <sclv> i think we need to rethink the whole concept of datafiles
12:01:07 <sclv> and come up with a mechanism that bundles them directly into binaries, and make it part of the core system
12:01:15 <sclv> instead of just a "hack" that can be added on
12:01:21 <sm[m]> Sounds good!
12:02:00 <sm[m]> file-embed is always needed for easy-deploy things
12:02:37 <fragamus> ??
12:02:53 <kritzefitz> sm[m], yes it might be easier, but it doesn't actually solve the general problem data-files have to tackle, because some files may no only be consumed by the Haskell binary itself, but also get passed to other processes.
12:03:15 <xunsmdlo> a b = [(x1,y2) | (x1,x2) <- a, (y1,y2) <- b, x2 == y1]
12:03:16 <xunsmdlo> How can I define that extension of a list of pairs without using list comprehensions?
12:03:28 <sm[m]> Ah.. where would you want those to go ?
12:03:56 <fragamus> byorgey you here?
12:04:03 <sclv> kritzefitz: i don't think that's true.
12:04:09 <sclv> i think on startup the exe can unpack them
12:04:28 <sm[m]> ~/.local/share was the trend  I thought
12:04:29 <Boarders> is there a straightforward way to do getBytes :: Word64 -> [Word8]
12:05:45 <sm[m]> sclv: true, I remember doing that for something that needed a real file
12:06:46 <kritzefitz> sm[m], sclv, I don't think I fully understand the problem you have with the way data-files were handled with v1 (or raw Setup.hs still does it). I think putting the files wherever it was specified during compilation and making the path accessible via the Paths_ module was just fine.
12:06:49 <geekosaur> Boarders, do you need to worry about endianness? (if you answer is "huh?", you have already lost; stop now)
12:07:26 <geekosaur> kritzefitz, it wasn't because it needed an ugly hack: is this being run while development or as installed?
12:07:50 <Boarders_> geekosaur: I do not!
12:08:10 <geekosaur> so there is horrid code to figure out if the exectutable is under dist and should use a non-deployed location
12:08:40 <zachk> is there a nix haskell channel? 
12:08:41 <geekosaur> you still have to define what that's supposed to mean, though
12:08:49 <tabaqui> I'm wondering if I there exists some simple pointfree operator "combineUntilFail :: (\a -> b -> m c) -> b -> m a -> m c"
12:08:54 <kritzefitz> geekosaur, ah yes, I remember that being mentioned in a discussion around stack not having that feature.
12:09:12 <tabaqui> I want to combine attoparsec strings without WriterT transformers
12:09:33 <tabaqui> *not "m c" but "m b"
12:10:03 <tabaqui> *(\a b -> m b)
12:10:15 <tabaqui> oh, no "(a -> b -> m b)" :)
12:10:53 <geekosaur> tabaqui, on the one hand, if it does it's probably in monad-loops. on the other, the problem with it is strict monads, where that mens "combine until it throws an exception and then die"
12:10:56 <kritzefitz> Though I still think that both cabal-install-v2 and stack lacking that feature is really unfortunate, because producing a distributable binary package isn't exactly easy without being able to create self-contained installations.
12:11:38 <geekosaur> that said, I think, hm
12:12:34 <tabaqui> yeah, now I need to exit Parser monad gracefully
12:12:47 <tabaqui> geekosaur: interesting library, thanks
12:13:31 <sclv> kritzefitz: my objection to v1/setup.hs is that the executable goes in spot X, and the files go in spot Y. so if you want to give someone else the executable it still doesn't work unless the datafiles are transfered as well and put in the same place
12:13:57 <merijn> sclv: Basically, you want macOS's .app format? ;)
12:14:08 <sclv> you also get issues like https://github.com/haskell/cabal/issues/4379
12:14:24 <sclv> merijn: closer to file-embed functionality getting built directly into cabal
12:14:35 <merijn> sclv: new-run solves that issue, btw
12:14:56 <geekosaur> as soon as you need to share them with other non-haskell processes, you stop being able to build it into cabal
12:15:05 <geekosaur> you need something like OS X app format, etc.
12:15:11 <geekosaur> windows resources, etc.
12:15:19 <sclv> but does new-repl solve it?
12:15:23 <geekosaur> (plus streams)
12:15:34 <sclv> geekosaur: no i disagree. you can always write them back out to a tempdir on startup
12:15:51 <merijn> geekosaur: Yeah, I run into that issue with bundling python scripts as data files, because you need them as file to execute
12:15:54 <geekosaur> but now you need to tell it the tempdir. secirely
12:15:59 <geekosaur> and cross-OS
12:16:08 <sclv> we know how to do cross os tempdirs, its in the stdlib
12:16:27 <sclv> and cabal has a lot of machinery on top for tempdir handling stuff too
12:17:28 <kritzefitz> sclv, I don't see why that is such a grave problem. With v1-style installs you were able to install your application to some prefix, zip/tar/whatever that prefix and pass it around as a single file. I don't see how bundling data-files is much more comfortable than that.
12:17:57 <kritzefitz> Especially considering that bundling files into the executable produces so much headache in other cases.
12:18:27 <sclv> we could probably allow new-install into some prefix too -- it just hasn't been done yet
12:20:11 <sm[m]> sclv I do remember generating temp files/dir was unpleasant behaviour - they created clutter/hidden state etc.
12:21:17 <sm[m]> File permission dependence and so on
12:23:39 <sclv> kritzefitz: actually i'm curious about what you mean by how you can put them all in a prefix?
12:23:45 <sclv> aren't the generated paths absolute?
12:24:03 <merijn> The ones you get by querying getDataFile aren't
12:24:28 <merijn> sclv: Pretty sure the cabal docs mention overriding the location with an environment variable
12:24:44 <sclv> yes, but then you have to set the env variables before running the executable
12:24:57 <merijn> So you could make it relocatable by simply creating a shell script that sets that variable with the current location based then exec's the executable
12:25:09 <merijn> sclv: Yes, but that's trivially automatable
12:25:27 <kritzefitz> sclv, IIRC it depends on what your top-most prefix actually is. If your $bindir is below your $prefix, Cabal can generate relative paths to everything that is also under $prefix.
12:25:31 <merijn> sclv: I mean, the 'ghc' in your path isn't the ghc executable either, it's a shell script that tweaks things
12:25:33 <sclv> you can do that with v2 just as easily
12:25:43 <sclv> the override thing
12:26:29 <sclv> kritzefitz: so it generates relative or absolute paths depending on if your bindir is below prefix or not, just automagically? is this documented somewhere?
12:27:21 <kritzefitz> sclv, https://www.haskell.org/cabal/users-guide/installing-packages.html#prefix-independence
12:28:28 <kritzefitz> The documentation says that that it only works under windows. On Linux it should work too, but only as long as you don't symlink the executable or do really weird stuff with argv[0].
12:29:49 <kritzefitz> Ah, wait strike that last comment about that working on Linux. I'm not sure if there aren't more cases where this breaks.
12:30:30 <sm[m]> my test: it should be easy to generate exes that you can download or share, that run on double click (and this should be true for each platform). Then we’ll see an uptick in Haskell apps
12:30:58 <Kenzie98> I am super horny & already wet. Join & watch my Live and let's have fun together. The fun is guaranteed!! Link ---> https://shortn.pw/FvZZT
12:31:55 <kritzefitz> That's an interesting reaction to “an uptick in Haskell apps”.
12:32:14 <sclv> also it only works for datafiles for exes and not libs. it seems very partial
12:35:59 <kritzefitz> Right, I haven't considered library data-files yet.
12:46:46 <nicolasbourdon> hello can someone answer me a question about curry howard correspondance?
12:47:11 <geekosaur> to find out, you'll have to ask it
12:49:24 <nicolasbourdon> ok! thk! my question is how in practice create a program which a criteria, for instance output the number corresponding to th double that the input
12:50:38 <nicolasbourdon> I understood that coq or haskell can do that (more easily create a program for which input and ouput respects some criteria)
12:52:16 <nicolasbourdon> i undestand a little bit lanbda calculus, and curry howard correspondence,but don"t know how in practice create a program which check crietria
12:52:36 <sclv> numbers aren't reflected on the type level normally
12:52:53 <sclv> so a function Int -> Int doesn't correspond to a useful proof
12:53:00 <nicolasbourdon> ok
12:53:08 <sclv> you can do the whole thing with type level naturals though
12:53:09 <nicolasbourdon> but anykind of proof
12:53:14 <nicolasbourdon> about a program
12:53:47 <sclv> curry howard isn't about proofs of programs
12:53:56 <sclv> it says that programs are proofs of _types_ (interpreted as propositions)
12:54:16 <sclv> ?ty either
12:54:18 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
12:54:41 <sclv> so that function proves that if you know that a implies c and b implies c, then it suffices to know either a or b to know c
12:56:02 <mty> how do types correspond to propositions exactly?
12:56:13 <sclv> by curry howard
12:56:19 <nicolasbourdon> ok, thk, i believe it help to prove programs rightness
12:56:36 <ski> nicolasbourdon : (in general) you need to be able to quantify over values, to be able to express such a criteria/property. in terms of Curry-Howard, that corresponds to dependent types, which Haskell doesn't have
12:56:47 <sclv> to prove the correctness of programs with curry howard you need to reflect them in types. 
12:57:03 <sclv> you can sort of fake it in haskell as it stands, but it requires care
12:57:25 <sclv> here's a paper that proves some very impressive stuff about a haskell program using those techniques http://homepages.inf.ed.ac.uk/slindley/papers/hasochism.pdf
12:57:39 <sclv> mty: https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence
12:57:53 <sclv> or https://homepages.inf.ed.ac.uk/wadler/papers/propositions-as-types/propositions-as-types.pdf
12:58:05 <monochrom> Haha hasochism
12:58:14 <mty> thx sclv
12:58:36 <ski> mty : conjunction of `A' and 'B' correspond to the pair type `(A,B)' (cartesian product of sets, ⌜A × B⌝, in math). implication between them corresponds to the function type `A -> B' (set of functions from ⌜A⌝ to ⌜B⌝, in math)
12:58:45 <sclv> monochrom: yeah there's a lot of good example papers but i always remember that one because of the title
12:59:08 <ski> @where polymorphic-type-inference
12:59:08 <lambdabot> "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <https://cs.au.dk/~mis/typeinf.p(s|df)>,<http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.57.1493>
12:59:20 <ski> mty : i think that ^ paper also brings up CH
13:01:01 <nicolasbourdon> but if "conjunction of `A' and 'B' correspond to the pair type `(A,B)' (cartesian product of sets, ⌜A × B⌝, in math)" what does correspond the set A and the set B?
13:01:46 <sclv> () corresponds to the one element set
13:01:51 <sclv> Bool to the two element set
13:02:02 <ski> nicolasbourdon : a proposition `A' corresponds to the set/type of all proofs of `A' (upto a proof-equivalence relation)
13:04:12 <nicolasbourdon> so the carstesian product of set A x B correspond to the cartesian product of all the prof of 'A'  by all the proof of 'B'?
13:05:42 <sclv> not exactly
13:06:04 <sclv> types don't correspond to proofs. they just correspond to propositions
13:06:22 <sclv> terms that inhabit those types are proofs. you can't really relate the two beyond that
13:06:35 <nicolasbourdon> ok
13:08:12 <mty> A & B  means we have a proof of A and a proof of B  == AxB as a type means we have a value of type A and type B meaning both have proofs under the curry howard iso prior to == ?
13:09:14 <sclv> yeah, basically
13:09:15 <mty> so A & B as a proposition corresponds to the type A X B?
13:09:21 <sclv> yes
13:09:33 <sclv> and Either is or
13:09:36 <gobby> My yesod app crashes after a while of being idle. With the helpful error of "Something went wrong".
13:10:21 <mty> gotcha
13:10:30 <mty> and implications is functions applied to types
13:10:34 <mty> implication*
13:10:42 <sclv> gobby: you may want to try to instrument the app with logging. the logging should give a better error?
13:11:33 <sclv> curry howard can be seen as taking the bhk interpretation (https://en.wikipedia.org/wiki/Brouwer%E2%80%93Heyting%E2%80%93Kolmogorov_interpretation) or something similar and making it a full correspondence
13:11:45 <mty> so going back to nicolas' original question, since Int is not a type representative of the natural numbers it just contains them
13:11:58 <mty> he needs a type that is basically the natural numbers
13:12:04 <ski> mty : no. a *proof* of an implication `A => B' is function that turns proofs of `A' into proofs of `B'
13:12:27 <mty> ahh
13:12:47 * ski is being nitpicky, but it might help clear up some confusion
13:13:03 <mty> but a function of type A->B is not a proof of A => B?
13:13:15 <ski> it is
13:13:41 <mty> okay so when i say functions between types that's what i thought i meant 
13:14:02 <mty> ohh its the type of the function
13:14:03 <mty> that is the proof
13:14:08 <mty> not the function between types
13:14:10 <mty> i see
13:14:11 <ski> "functions between types" sounds very vague, unclear
13:14:33 <ski> "function types" would have been clear (and very different from "type functions")
13:14:53 <mty> gotcha
13:14:54 <mty> thx
13:15:23 <ski> implications correponds to function types
13:15:37 <ski> proofs of implications corresponds to functions (having function types)
13:16:23 <gobby> sclv: Will do.
13:17:21 <mty> so f: (a -> b) -> (c -> d) is the actual proof of what?  
13:17:52 <mty> g: a -> b, h: c -> d ?
13:18:23 <sclv> "if a implies b then c implies d"
13:18:34 <mty> okay that's more or less what i thought
13:19:22 <mty> so if i tried to prove it in a "natural setting"  i would assume ( a -> b and c ) then show d?
13:19:37 <mty> but in the setting of types
13:19:41 <mty> i have a construct a function
13:19:50 <mty> which i called f
13:20:08 <mty> I have to*
13:20:23 <sclv> yes, and curry howard sort of says that all the steps you take to show d correspond to constructing a function
13:20:24 <mty> that manipulates the types and converts g to h
13:20:32 <mty> gotcha
13:20:34 <mty> awesome
13:20:38 <sclv> it doesn't manipulate the types, it manipulates values of the type
13:20:46 <mty> ahh
13:20:46 <mty> right
13:20:55 <mty> instances of the type so to speak
13:21:43 <zwarag> What does `:: BTree (BTree Integer, String)` mean? I have trouble understanding what the , does. I'm trying to crate a BTree here but it does not work. https://gist.github.com/zwarag/f8c9b4e065743c717a77052af4f78e33
13:23:04 <mty> thx ski, thx sclv that really helps
13:23:42 <merijn> zwarag: The , isn't something, it's "(Foo, Bar)" that means something (specifically, a tuple of a Foo and Bar value)
13:24:57 <nicolasbourdon> thanks!
13:24:58 <zwarag> Ohh yeah a tuple of course!!!
13:25:19 <zwarag> merijn: thank you
13:26:09 <mty> so skimming through the paper of Wadler, for all and there exists correspond to dependent types in some manner so types of types?
13:26:57 <merijn> zwarag: np
13:27:07 <solrize> mty if you want to understand how that works you should probably read martin-lof's paper
13:27:09 <sclv> well they can either correspond to dependent quantification or you can do the weaker thing and have parametric quantification
13:27:38 <sclv> i.e. forall in logic also translates to the forall in haskell, for the most part
13:28:14 <mty> solrize, P. Martin-L ̈of.Intuitionistic type theory.  Bibliopolis Naples, Italy,1984. this one?
13:29:12 <sclv> this is more basic and i like this too https://ncatlab.org/nlab/files/MartinLofOnTheMeaning96.pdf
13:29:22 <sclv> and then there's "constructive mathematics and computer programming"
13:29:32 <sclv> the bibliopolis book is a full fledged introduction to dependent types
13:29:45 <sclv> which is great, if you want to go that far
13:30:31 <mty> okay thx
13:31:04 <mty> out of curiousity how much of haskell corresponds to these ideas?
13:31:50 <int-e> :t undefined -- in some sense, almost nothing at all
13:31:51 <lambdabot> a
13:32:16 <mty> does haskell have dependent types?  
13:33:22 <sclv> no haskell does not have dependent types
13:33:24 <mty> leightweight ones form what i can glean from google so far or simulating
13:33:27 <mty> i see
13:33:34 <sclv> you can sort of "fake it" a number of ways
13:33:35 <int-e> mty: there are plans in that direction... https://gitlab.haskell.org/ghc/ghc/wikis/dependent-haskell ...
13:33:38 <sclv> right
13:33:52 <sclv> eisenberg's papers are good for both the plans and some of them for "what you can do now"
13:35:17 <dmwit> Is there a crisp description somewhere of a thing you can do with dependent types but cannot do in Haskell?
13:35:23 <int-e> mty: it also depends on what you mean by "Haskell"... Haskell 2010 is still Hindley-Milner-typed + type classes... much closer to the simply typed lambda calculus
13:35:43 <sclv> it depends on how flexible you are about the "same thing" i think
13:36:06 <bartholin> also, the homotopy type theory book is nice
13:36:12 <sclv> but an example i always give is "try to write what J (equality elimination) means in haskell and see how far you get"
13:36:22 <dmwit> I mean "same up to the standard boilerplate we now know how to write for singletons stuff".
13:36:29 <int-e> bartholin: doesn't that start out with simplicial sets?
13:37:20 <int-e> (this put me off... I was interested in the logic at some point... not in a model)
13:37:23 <bartholin> int-e: no https://homotopytypetheory.org/book/
13:37:35 <dmwit> sclv: Can you say quickly what J means in some other language (say Coq or Agda)?
13:37:43 <dmwit> It's a bit tough to google for "j".
13:37:54 <int-e> (but I don't remember which source I tried to read)
13:38:58 <sclv> dmwit: https://homotopytypetheory.org/2011/04/10/just-kidding-understanding-identity-elimination-in-homotopy-type-theory/
13:40:28 <ski> dmwit : take a value (not necessarily of a singleton type) as input, and let the output type depend on that value ?
13:41:06 <sclv> ski: i think that doesn't count because the notion of "can't do in Haskell" is vaguely formed but has an implicit "allowing lifting things to singletons" clause
13:42:29 <ski> sclv : if i can't apply it to existing types, and existing code over those types, it doesn't seem "first-class", to me
13:43:28 <sclv> right. i agree its not "first class". the question is more in my mind "where does faking it break down"
13:43:39 <dmwit> ski: I agree it's clearly not first-class.
13:44:08 <dmwit> ski: I'm asking: in a hypothetical neighbor world, where we built the whole Prelude with singletons, what would we still be missing?
13:44:21 <sclv> with something like J i don't have a "proof you can't" but i don't even know how i'd start thinking about expressing it
13:44:28 <dmwit> Reading sclv's link is making me go "phew".
13:44:58 <sclv> and people that know dependent type theory well have all sort of agreed with me when i've posed it in person -- i.e. i consider it an open challenge
13:44:59 <dmwit> I'm not sure I find it enlightening about what Haskell is "missing" vs. full dependent typing.
13:45:23 <sclv> dmwit: in practice, proofs with dependent typing use j or "effectively j" ubiquitously
13:46:13 <bartholin> sclv: how would you express the equality type in haskell?
13:46:18 <sclv> i think in haskell we rely on some sort of external magic to detect type equality in the solver. so we just sort of rely on ~ to do it
13:46:46 <sclv> but ~ doesn't give you full J, and i'm not sure in what _simple_ cases you need the extra expressivity
13:47:20 <dmwit> It's also not clear to me that the J presented in your link is... guaranteed to "work" in all DT systems?
13:47:32 <sclv> bartholin: the standard way in haskell http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Type-Equality.html
13:47:34 <ski> dmwit : okay, hmm
13:47:52 <mty> to ya'lls knowledge, has anyone studied the relationship between types/propositions and integer programming feasibility?  (sorry going off on a limb...)
13:47:54 <sclv> dmwit: it absolutely is. K is stronger. J is shared in common by all MLTT-ish type theories
13:48:15 <dmwit> sclv: Like... it seems like the fact that `b M : C M N Refl` is allowed as a witness of the type `C M N P` is a special property of Agda's type system maybe?
13:49:04 <sclv> nope. Martin-Lof introduced J. Arguably it was the most important thing he introduced, since a lot of other stuff had actually been done by debruijn and howard earlier, in some version.
13:49:07 <dmwit> (I mean, `b M : C M M Refl` but this is fine because we have `Id M N` and can rewrite this to `C M N Refl`. But we don't have anything in scope of type `Id Refl P`, so...)
13:49:23 <kupi> hi
13:49:43 <Lycurgus> yello
13:49:48 <sclv> the whole point is exactly that -- you can _induct_ on equality.
13:49:48 <mty> hey
13:50:17 <kupi> I have found an inaccuracy in this http://learnyouahaskell.com/starting-out
13:50:26 <sclv> actually, the new "little typer" book spends a lot of time building up a good intuition for the strength of various sorts of equality induction and convincing you that the weaker thing you might think would be all you need is not enough
13:50:45 <kupi> [[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]] !! 2 is not [1,2,2,3,4]
13:50:48 <sclv> kupi: nobody here really maintains that book, so its not a good place to get it fixed
13:51:23 <dmwit> (Oh, no, we know `P` is `Refl` because we pattern matched on it. Okay.)
13:51:39 <sclv> > [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]  !! 2
13:51:42 <lambdabot>  [1,2,2,3,4]
13:51:51 <sclv> kupi: we start from 0, not from 1 :-)
13:52:24 <dmwit> kupi: `b` is not `[[6,6,6],...]`.
13:52:48 <sclv> oh i see the confusion
13:52:58 <dmwit> kupi: Or: what you say is true, but the book doesn't claim anything that contradicts it.
13:53:00 <sclv> once b is defined it stays defined. 
13:53:15 <kupi> how, now i see
13:53:19 <kupi> the value of b didn't change
13:53:22 <kupi> my bad
13:53:27 <dmwit> yay!
14:03:59 <mty> does anyone know of any work regarding program induction in a functional setting (functional programming language)?
14:06:36 <cjay-> what exactly do you mean with program induction?
14:07:03 <mty> say instead of defining a rigrouous rule for mapping inputs to outputs
14:07:09 <mty> i give examples of inputs and outputs
14:07:32 <mty> say 1000 and ask for a short program that can generate a function perfectly aligning with the input output examples (no noise)
14:08:07 <mty> does anyone do that type of stuff in a functional programming paradigm (have an algorithm autmatically generate functional code) based on input/output examples?
14:08:59 <mty> clearly there would be an infinite number of programs for finite examples but if we limit their complexity in some way
14:09:02 <monochrom> I know of this: https://www.youtube.com/watch?v=er_lLvkklsk
14:09:21 <mty> ahh
14:09:24 <solrize> mty yeah that's called program inference, like type inference in reverse
14:09:35 <mty> yes that type of thing in clojure interesting
14:09:35 <solrize> you write out the type and the compiler generates the code instead of the other way around
14:09:45 <mty> yes
14:09:57 <mty> which would be hard
14:10:05 <mty> and relates to my question about integer programming feasibility
14:10:14 <kupi> why does [3,6..20] return [3,6,9,12,15,18] but [0.1, 0.3 .. 1] return [0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]?
14:10:19 <mty> but they call it program inference, thanks
14:10:22 <solrize> mty yes it's undecidable :)
14:10:28 <mty> well in general yes
14:10:42 <kupi> 18 is smaller than 20 but 1.0999999999999999 larger than 1
14:11:03 <dmwit> kupi: However, 1.099999... is less than half of one step bigger than 1.
14:11:05 <glguy> kupi: Your upper end-bound on your list comprehension should try to be a multiple of the step value + the initial value if you want sensible results
14:11:07 <int-e> kupi: easy answer: because of the Haskell report
14:11:51 <dmwit> kupi: To avoid problems with rounding, the rule Float and Double is that it stops at the upper-bound plus half the step.
14:11:54 <glguy> even better is to not use [ .. ] syntax on floating point numbers
14:11:57 <int-e> kupi: the longer answer is that enumFromThenTo stops at the number that is closest to the provided "upper bound".
14:12:23 <dmwit> > [0.1, 0.200000001 .. 1]
14:12:26 <lambdabot>  [0.1,0.200000001,0.300000002,0.40000000299999994,0.5000000039999999,0.600000...
14:12:39 <dmwit> > [0.7, 0.8000001 .. 1]
14:12:42 <lambdabot>  [0.7,0.8000001,0.9000002,1.0000003]
14:12:56 <glguy> > take 4 (reverse [0.1, 0.200000001 .. 1])
14:12:59 <lambdabot>  [1.0000000089999996,0.9000000079999997,0.8000000069999997,0.7000000059999998]
14:13:02 <int-e> > [0.1, 0.4..0.7]
14:13:05 <lambdabot>  [0.1,0.4,0.7000000000000001]
14:13:17 <dmwit> Oh, I like int-e's example of why this is a good rule much better!
14:13:19 <dmwit> int-e++
14:13:53 <glguy> int minus the value of e with e then incremented...
14:14:46 <dmwit> Pop quiz: what does `int main() { int int; for(int i = 0; i < 10; i++) printf("%d\n", i); return 3; }` do?
14:15:01 <dmwit> Answer first, then consult your compiler. ;-)
14:15:02 <monochrom> IIRC "int" is reserved.
14:16:00 <dmwit> For the pedants: please #include <stdio.h>
14:16:12 <glguy> what should the non-pedants include?
14:16:18 <monochrom> I didn't try but I consulted K&R recently.
14:16:23 <dmwit> The non-pedants already included it. =)
14:16:42 <kupi> [0,5..29] returns [0,5,10,15,20,25]
14:16:51 <kupi> 29 is closer to 30 than 29
14:17:04 <glguy> kupi: integer arithmetic doesn't suffer from the same rounding errors
14:17:13 <int-e> kupi: what I said is only true for the floating point number instances, sorry.
14:17:23 * int-e could've been clearer.
14:17:31 <monochrom> > [0, 5 .. 29 ] :: [Double]
14:17:33 <lambdabot>  [0.0,5.0,10.0,15.0,20.0,25.0,30.0]
14:17:58 <dmwit> (The follow-up quiz has `typedef int x;` and then proceeds like the previous one, but with s/int/x/g.)
14:18:14 <monochrom> Oh, that's more fun.
14:18:29 <cjay-> mty: that sounds a lot like the stuff edward kmett is doing / talking about. keywords: coda, guanxi (not sure that's the right projects for what you are asking, he's doing a lot of stuff)
14:20:08 <int-e> dmwit: what does prxf do?
14:21:01 <int-e> but yeah, that's a fun one... experimentally, neither version works, but for different reasons.
14:21:33 <int-e> dmwit: (I discovered prxf only because I was actually doing search&replace in my editor... otherwise I would've missed it completely as well)
14:22:01 <dmwit> oh no!
14:22:06 <dmwit> sorry, x-e
14:22:11 <int-e> hah
14:22:20 <monochrom> Need semantics substitution.
14:22:45 <int-e> (I would change my nick but that wouldn't make sense on the half dozen other channels... so just imagine it, please :) )
14:22:50 <glguy> Substituting in different semantics could be fun
14:23:04 <monochrom> It's a trend. All problems are solved by prefixing "semantic".  Semantic versioning.  Semantic web.
14:23:15 <int-e> semantic monochrom
14:23:35 <glguy> Semantic antivirus
14:23:40 <monochrom> haha
14:23:46 <dmwit> omg
14:23:48 <dmwit> monochrome-e
14:24:06 <monochrom> Perhaps monochrom-e is better.
14:27:10 <int-e> . o O ( while we are at it we could simplify that other nick to t-dex )
14:27:50 <int-e> hmm, I should've written "int-nick" there :)
14:29:35 <int-e> int-index: no hard feelings. in fact I'm amazed by how little we seem to get confused for each other (though obviously I only see one side of that)
15:12:56 <statusfailed> hmmm
15:13:02 <statusfailed> I have a function that takes a long time to run in ghci
15:13:06 <statusfailed> but if I run it again, it's fast
15:13:08 <statusfailed> laziness?
15:21:59 <c_wraith> statusfailed, certainly sounds like something is getting held from one run to the next. what do you see if you :set +s
15:24:56 <statusfailed> c_wraith: (24.38 secs, 16,475,454,360 bytes)
15:24:59 <statusfailed> for first run
15:25:09 <statusfailed> (8.10 secs, 4,801,137,464 bytes)
15:25:10 <statusfailed> for second run
15:25:39 <statusfailed> that is a lot of bytes
15:27:06 <statusfailed> in a more extreme case, it gives 24s vs. 0.04s
15:27:25 <c_wraith> it's a lot less bytes the second time around. definitely suggests it's holding on to a shared value that is getting more evaluated
15:27:30 <statusfailed> (22.80 secs, 16,741,146,552 bytes)  vs  (0.05 secs, 24,114,792 bytes)
15:27:42 <statusfailed> c_wraith: how do you usually debug this kind of problem?
15:28:12 <statusfailed> I also tested by running on an "equivalently hard" problem on the same datastructure, which runs much faster after you solve the first problem
15:28:37 <statusfailed> which doesn't make sense unless it's something like laziness I guess
15:28:53 <c_wraith> look at the code. think about it. only really helps when you are very comfortable with the evaluation model... and with the occasional gotcha like the full laziness transform.
15:54:09 <jle`> how can i export [] ?
15:54:55 <jle`> well my actual problem is i want to export a pattern synonym bundled with [], so like [](MyPatternSynonym)
16:02:56 <sm> statusfailed: add a bunch of trace statements to see what's being evaluated
16:40:13 <gobby> I'm a little lost on how to make yesod use my generated SSL certificates
16:40:24 <gobby> I just generated them with certbot
16:41:04 <gobby> right now my yesod just serves a JS file
16:41:10 <gobby> yesod server*
16:44:46 <libertyprime> if stack build quits immedately without erroring, does that mean it finished building?
16:46:25 <monochrom> \∩/ -fdefer-type-errors also reliefs me from writing Functor instance when I write Monad instance!
16:51:58 <sclv> huh.. what happens when you try to use it
16:52:25 <monochrom> run-time type error
16:52:37 <monochrom> run-time "no instance" error
23:40:13 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
23:40:13 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
23:40:23 <suzu> plenty of reading for you about lens
23:41:38 <dminuoso> mrsbear: What do you want to learn about lens exactly? How to use them or how they work?
