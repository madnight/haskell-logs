00:10:04 <jle`> is there a bijection between (Map k a) and (Map k a, Bool)?  the other day i was stuck unless i could find a bijection between Nat and (Nat, Bool), and luckily one existed. i'm not sure if i am so lucky this time
00:10:37 <jle`> * Map Nat a, if it makes any difference
00:11:51 <mniip> you mean a computable bijection?
00:11:59 <mniip> the two types are clearly countable so
00:12:16 <jle`> computable ideally
00:12:25 <jle`> so i can write the two directions
00:12:51 <mniip> is 'a' a parameteric parameter?
00:12:59 <mniip> i.e do you want a bijection natural in a
00:13:06 <jle`> yes indeed
00:13:29 <jle`> really i wonder if i would be just as well off with talking about Set Nat <~> (Set Nat, Bool)
00:13:50 <mniip> doubt it then
00:13:54 <mniip> consider a~Void
00:14:01 <mniip> the lhs has 1 inhabitant, the rhs has two
00:14:41 <mniip> Set Nat <-> Set Nat x Bool  is probably bijective,
00:14:59 <mniip> but you have some kind of power series int terms of 'a'
00:15:15 <mniip> you need all coefficients to match up
00:15:19 <mniip> for a bijection to be natural
00:15:59 <jle`> hm, i was hiding this detail, but itmight make a difference: i'm actually talking about non-empty maps. with at least one (k, a) pair.  so in that case if a ~ Void, both sides have zero inhabitants
00:17:00 <mniip> then you need for every n to come up with a computable bijection from sets of n integers, to sets of n integers times a bool
00:17:27 <jle`> hm, that's definitely a known thing, right?
00:17:29 <mniip> s/integers/nats/
00:17:37 <mniip> not sure
00:18:21 <jle`> that sooounds like something that would be known
00:18:33 <jle`> a binjection between N^i and 2*N^i
00:18:38 <jle`> for any i
00:18:46 <jle`> i mean we know the case where i = 1, heh
00:20:11 <Batholith> so yesterday evening (in my time anyway) we talked about IO being magical in other languages, as opposed to Haskell where it's really just a value. it has really opened up my eyes on just how magical my "main" language C++ really is. if you want to be as amazed as I was at the magic of C and C++, look up Duff's Device
00:20:28 <mniip> not N^i
00:20:35 <mniip> sets not tuples
00:20:39 <mniip> (N choose i)
00:20:52 <jle`> mniip: ah, i see
00:21:01 <jle`> Batholith: thanks for the suggestion :)
00:21:26 <mniip> not sure what duff's device has to do with IO
00:21:53 <mniip> it's a neat optimization yes
00:21:58 <Batholith> you missed the point, mniip
00:22:21 <mniip> well I wasn't there for the conversation
00:22:44 <jle`> mniip: it's not too big a deal, it would be a "nice benefit", but if it ends up being impossible then that just means that a certain instance is not possible
00:22:55 <jle`> maybe i should just shelve this for another time
00:23:03 <mniip> it's likely doable
00:23:04 <jle`> thanks for helping me reduce the problem
00:23:16 <Batholith> the point was how magical other languages can be, compared to Haskell :p
00:25:05 <Rembane> Batholith: I have a tendency to just think of C++ as high level assembly, and in assembly I know that everything is a lovely, gritty mess. Maybe the IO abstractions of Haskell leak less though. I've just come to the conclusion that I'm just thinking aloud.
00:26:17 <jle`> mniip: or well, i guess it would be nicer than i stated, because it would allow me to get rid of a redundant type if the two were identical. but i should probably just move on anyway
00:26:53 <Batholith> that's how I also see C. like really it's just high level assembly. C++ just adds on top of that, adding syntactic sugar to make life easier, and a decent standard library
00:27:16 <Rembane> Yes. And some madness on top of that. 
00:27:41 <Rembane> The templating language for instance is a lambda calculus if you squint.
00:28:46 <mniip> jle`, do we know an iso between (N choose i) and N * (N choose i-1)
00:29:20 <Batholith> yeah I really think the madness simply comes from backwards compatibility. they try to improve the language whilst keeping old code from breaking whenever possible
00:29:29 <jle`> mniip: i can't say for sure off the top of my head
00:29:30 <mniip> I guess yes
00:29:40 <Rembane> Batholith: Totally. 
00:30:14 <mniip> given a set A we take <min(A), {x-min(A)-1 | x in A} >
00:30:54 <mniip> then we can go (N choose i) <-> Nx(N choose i-1) <-> 2xNx(N choose i-1) <-> 2x(N choose i)
00:31:20 <maerwald> Axman6: https://hackage.haskell.org/package/amazonka-1.6.1/docs/Network-AWS.html#g:17
00:35:10 <jle`> mniip: hm, this may work. it's a little more complicated than the original one so i might take notes and implement it in the future. thanks :)
00:35:24 <jle`> good to know that it might be possible
00:35:37 <mniip> definitely possible
00:35:57 <mniip> pretty sure my construction up there is solid
00:49:22 <fragamus_> its another beautiful morning in haskell land
00:59:36 <jgt> it sure is
01:53:52 <kuznero[m]> Hi All! Is there a way to generate low-level Haskell for a given C-api?
01:54:12 <merijn> kuznero[m]: To call an existing C api, you mean?
01:55:09 <kuznero[m]> merijn: to be able to call external library (that is a C-library for which I have a header file)
01:55:36 <merijn> kuznero[m]: Sure. I'd even go as far as saying it's pretty trivial if you're comfortable with C and linking :)
01:56:07 <kuznero[m]> I think I can figure out (it was rather long time ago)
01:56:20 <merijn> kuznero[m]: (Well, it depends a bit, if you want to pass structures by value (rather than as pointers) and/or mutate those structures from Haskell it's a little annoying. But if you only deal with pointers and primitive types its easy
01:56:23 <kuznero[m]> I was looking into `c2hs` but I it generates empty haskell
01:56:52 <kuznero[m]> Basically, I need to generate some Haskell for https://github.com/tensorflow/tensorflow/blob/v1.9.0/tensorflow/c/c_api.h
01:56:52 <merijn> kuznero[m]: If you don't need to mutate structs from within Haskell you don't even need c2hs
01:57:37 <merijn> Ah, if you wanna auto-generate for an existing API it's a bit more annoying, so I guess it depends on the size of API you have to wrap
01:58:04 <merijn> kuznero[m]: You'll wanna read Chapter 8 of the Haskell 2010 report (which covers the FFI design) and the GHC user's guide chapter on the FFI
01:58:07 <merijn> @where report
01:58:07 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
01:58:15 <merijn> @where userguide
01:58:15 <lambdabot> I know nothing about userguide.
01:58:18 <merijn> hmm
01:58:34 <merijn> @remember userguide https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/
01:58:34 <lambdabot> Good to know.
01:58:37 <kuznero[m]> Thanks
01:59:01 <merijn> kuznero[m]: For simple C functions it can be as simple as a single line + type signature: https://github.com/merijn/GPU-benchmarks/blob/master/benchmark-analysis/src/SQLiteExts.hs#L27-L59 :)
02:00:22 <merijn> kuznero[m]: To generate bindings for an entire complex API you might wanna ping edwardk since he has a setup to automatically generate bindings for all of OpenGL, but no clue how he does it :p
02:00:28 <kuznero[m]> merijn: I was trying to find a semi-automatic way of "translating" complex C-api such that I can take over new changes faster eventually (TensorFlow is not a slow project)
02:01:38 <edwardk> merijn: so much xml
02:02:17 <edwardk> currently i recommend binding just enough of it to get the types with inline-c or inline-c-cpp
02:02:25 <merijn> @quote xslt
02:02:25 <lambdabot> darius says: I imagine XSLT programmers say "It's a one pager" the way most other programmers say "It's a one liner".
02:02:38 <edwardk> and i’ll typically capture enums with hsc2hs by hand
02:02:54 <merijn> edwardk: CPP enums you mean?
02:03:04 <edwardk> that way my ffi is strongly typed and if i dont laboriously bind the whole library it is pretty robust
02:03:06 <kuznero[m]> ok, thanks!
02:03:08 <kuznero[m]> Sounds like a big task ;)
02:03:44 <edwardk> kunzero github.com/ekmett/codex has several subprojects that ffi a LOT using this
02:03:54 <edwardk> not exactly the minimal approach i advocated
02:04:03 <kuznero[m]> edwardk: great! thanks
02:04:04 <edwardk> but theyare what informed my current thinking
02:04:26 <edwardk> see harfbuzz, harfbuzz-*, fontconfig etc
02:04:35 <edwardk> anything with a “raw” subfolder
02:05:18 <kuznero[m]> Found it, thanks
02:05:22 <merijn> kuznero[m]: Anyhoo, do start with chapter 8 and the user guide, c2hs is a pretty straightforward tool for generating the boilerplate for Storable, etc. that's discussed in those chapters
02:06:51 <edwardk> i just wish i liked the the output of c2hs :)
02:07:23 <edwardk> if you look in the freetype project there i use custom hsc2hs scripting to generate structs
02:07:31 <merijn> edwardk: tbh, I mostly just handbind minimal sets of an API I need so I hardly use it anymore
02:07:41 <merijn> edwardk: I don't particularly like hsc2hs either :p
02:08:09 <edwardk> i use it for constants only
02:08:18 <edwardk> and i use inline-c for everything else
02:08:36 <merijn> edwardk: Why not CApiFFI for constants?
02:09:41 <edwardk> foreign import whatever?
02:10:17 <edwardk> because its like 6 times more verbose to make a pattern synonym bind to one of those constants and then it never can fully unbox inside
02:10:40 <merijn> ah
02:11:23 <edwardk> https://github.com/ekmett/codex/blob/master/bidi-icu/src/Data/Text/ICU/Bidi.hsc#L216
02:11:30 <edwardk> is the verbose way i use
02:11:39 <YellowOnion> I have a C function that wants to mutate an uint, how do I FFI with this?
02:12:39 <merijn> YellowOnion: If you wanna mutate a uint you're getting a pointer to it, right?
02:12:52 <edwardk> https://github.com/ekmett/codex/blob/master/freetype/raw/Graphics/FreeType/Internal.hsc#L468 is the slightly less verbose way with the let pattern def at the top
02:13:36 <edwardk> but https://github.com/ekmett/codex/blob/master/freetype/raw/Graphics/FreeType/Internal.hsc#L421 does the whole struct construction all the storable stuff etc
02:13:44 * hackage morley-prelude 0.2.0.1 - A custom prelude used in Morley  https://hackage.haskell.org/package/morley-prelude-0.2.0.1 (gromak)
02:13:45 <edwardk> it uses an AWFUL macro
02:14:20 <edwardk> https://github.com/ekmett/codex/blob/master/freetype/cbits/hsc-struct.h but i only had to write it once
02:14:44 * hackage morley 0.3.0.1 - Developer tools for the Michelson Language  https://hackage.haskell.org/package/morley-0.3.0.1 (gromak)
02:15:36 <YellowOnion> merijn, yeah the function is meant to be used like uint a; func(&a); <more stuff with a>;
02:16:57 <edwardk> right now my biggest beef with hsc2hs is that it isn’t hscpp2hs :)
02:17:23 <edwardk> binding glslang right now and had to make copies of headers with just the enuns i wanted ripped out of the namespaces
02:17:28 <YellowOnion> Do I not need to wrap the a in something so it doesn't violate functional laws?
02:17:31 <edwardk> er enums
02:17:38 <merijn> YellowOnion: "foreign import ccall "func.h func" c_func :: Ptr CUInt -> IO ()" to import the C function
02:17:55 <merijn> YellowOnion: You can't mutate the Haskell value you have anyway, since it's a value, not a pointer
02:18:38 <merijn> YellowOnion: You can use alloca from Foreign.Marshall to create a temporary allocation + pointer to it, then you store the Haskell value into that pointer, and call func with that pointer
02:19:00 <merijn> YellowOnion: But, see my earlier recommendation to read chapter 8 of the Haskell2010 report and the FFI section of the GHC user guide :)
02:19:41 <YellowOnion> Ahh okay. I just though there might be a IORef like object to make this more Haskelly
02:20:03 <edwardk> YellowOnion: https://github.com/ekmett/codex/blob/master/freetype/src/Graphics/FreeType.hsc#L720 is how i do something similar in code i wrote last week
02:20:30 <merijn> YellowOnion: Well, you certainly can write some higher level interface around it, but the easiest/most direct way of interfacing with C code is...pretty C like :p
02:20:43 <edwardk> the [C.exp| stuff there would become a call to your c ffi’d function but alloca before and peek after is a common ffi pattern
02:21:27 <YellowOnion> Ahh, I'm just trying to wrap some windows api calls that are missing from the win32 package.
02:21:58 <merijn> YellowOnion: I'm guessing most of the win32 works like what I said :)
02:22:26 <merijn> YellowOnion: Also, yes! Do that, there's a bunch of stuff that is possible on windows but base/unix-compat are lacking support for
02:22:54 <merijn> YellowOnion: And I don't develop windows enough to implement them properly, but it would be super nice to have more complete support :)
02:23:31 <YellowOnion> https://docs.microsoft.com/en-nz/windows/desktop/inputdev/using-raw-input#performing-a-standard-read-of-raw-input
02:28:24 <YellowOnion> edwardk, okay sweet, the peek/poke stuff was confusing me.
02:29:24 <edwardk> helps if you grew up with a computer where peek/poke were the ways you fiddled with memory
02:29:30 <merijn> YellowOnion: 'peek' = 'look at what's "behind" a pointer', 'poke' = 'change it to be this new value'
02:30:03 <edwardk> they were the command names used in many BASIC implementations
02:30:05 <merijn> YellowOnion: You're "peeking" at the bytes behind a pointer or "poking"(prodding) them into the shape you want
02:30:24 <edwardk> e.g. on the commodore 64 i first used as a kid
02:31:02 <YellowOnion> a simplier time.
02:31:47 <merijn> YellowOnion: i.e. "peek" is using "*foo" as a value in a computation ("int bar = *foo + quux;") and poke is using "*foo" to assign something to it ("*foo = bar + quux;")
02:53:44 * hackage line-bot-sdk 0.5.0.2 - Haskell SDK for LINE Messaging API  https://hackage.haskell.org/package/line-bot-sdk-0.5.0.2 (moleike)
03:07:02 <YellowOnion> Is there a tool that can just convert C structures etc to Haskell datatypes? writing all these types about by hand seems exactly like what a tool should do...
03:19:00 <dminuoso> YellowOnion: You mean like hsc2hs?
03:22:00 <YellowOnion> dminuoso, I mean a tool that would spit out an hsc file.
03:22:28 <dminuoso> YellowOnion: A text editor would do that, if you force it. :-)
03:26:01 <YellowOnion> I'm probably just too tired for this...trying to translate C types in to Haskell types when I'm not very familiar with C.
03:26:45 <dminuoso> YellowOnion: It's being talked about by the way https://gitlab.haskell.org/ghc/ghc/wikis/c-structures
03:33:57 <YellowOnion> dminuoso, kinda...I mean I just want a tool to translate the C form in to the Haskell form.
03:41:41 <YellowOnion> c2hsc or c2hs is probably more on the lines of what I'm talking about.
03:45:20 <merijn> YellowOnion: c2hsc? ;P
03:49:31 <dminuoso> merijn: Heh they just mentioned it. :)
03:49:38 <dminuoso> You should get a bouncer.
03:52:04 <merijn> The problem is the docking stations here shutting down my network when the laptop goes into powersaving >.>
03:52:16 <YellowOnion> I tried c2hsc, but it just failed to compile some random h file I had never heard of, so I think it was trying too much.
03:52:20 <merijn> dminuoso: I don't wanna get a bouncer, because that sounds like work to setup/maintain :p
03:52:56 <dminuoso> merijn: Ah not really. Took me perhaps a few minutes to install it on some VPS I already had, and then its "fire and forget yolo"
04:16:18 <Rembane> I want to build parsers in an inductive way that won't bite me, do you have any tips on where I should start? 
05:00:16 <duairc> I have a huge function that does loads of calculations on floats, but I just get NaNs every time no matter what. I can't figure it out but it could be anywhere. Is there anything like a magic GHC option (or a type I could swap out instead of Float/Double) to make NaNs runtime errors, or something, to give me a better idea of where this is happening?
05:01:24 <merijn> duairc: Not yet, but NaN generally means you're dividing by 0
05:01:58 <merijn> There are some ideas/plans on making trapping NaN possible in GHC, though
05:05:37 <duairc> I guess I'll just sprinkle Debug.Trace everywhere and see if I can figure it out
05:07:11 <__monty__> duairc: Maybe this is a good opportunity to refactor everything into smaller understandable pieces?
05:09:50 <duairc> __monty__: Haha, I know. That would be its own mess though. I've a lot of nested loops in where clauses that need the context from the other where cuases, passing all that around explicitly would be messy as well
05:13:49 <duairc> Okay, I got it! Debug.Trace saves the day
05:14:03 <merijn> @quote refreshing.desert
05:14:03 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
05:19:12 <quchen> Sooo how do I join the Zurihac Slack? (Why is this harder than joining IRC?)
05:20:07 <dminuoso> quchen: Uh https://slack.zurihac.info/ and register?
05:31:51 <YellowOnion> Couldn't match type `C.CIntPtr' with `Ptr C.CInt' Whats the difference...
05:32:10 <merijn> YellowOnion: intptr_t vs int*
05:32:20 <merijn> CIntPtr being the former
05:33:17 <YellowOnion> I've gone another route, I'm trying to use inline C to get my code working.
05:34:21 <YellowOnion> Seems like using that type works thanks.
06:04:14 * hackage stack 2.1.1.1 - The Haskell Tool Stack  https://hackage.haskell.org/package/stack-2.1.1.1 (borsboom)
06:23:34 <hyperisco> I learned something from JavaScript programmers about Monad
06:25:45 <dminuoso> For what its worth, JavaScript has a monadic interface for async, you even get do-notation for it...
06:26:54 <hyperisco> I learned why it is being misunderstood
06:27:01 <dminuoso> Oh do tell.
06:27:06 <hyperisco> It is being misunderstood because the types are being ignored
06:27:33 <hyperisco> This is how they're equivocating join and extract
06:28:07 <hyperisco> Because if you just look at the implementation, for some Monad instances, they're the same. Take Identity, for example.
06:28:34 <hyperisco> Fascinating isn't it?
06:29:34 <hyperisco> I also found this happening here https://medium.com/@_ericelliott/there-is-no-requirement-for-two-layers-of-wrapping-in-flatten-join-72b918a12dd3
06:31:06 <dminuoso> hyperisco: You mean in their mind it's about "removing a layer"?
06:31:40 <hyperisco> Yes, that is the line being passed around from author to author, it seems.
06:31:42 <YellowOnion> Could someone fill me in if I'm doing this ptr stuff correctly? I'm getting bogus data. https://gist.github.com/YellowOnion/1ec058fda938d1c24a19a9d2f1d1011a#file-main-hs-L58
06:31:57 <dminuoso> "In the context of Kleisli composition, the contained value in `M(a)` is itself a monad, so the signatures `M(M(a)) => M(a)` and `M(a) => a` are equivalent in that context. This is why Haskell’s join has the signature `M(M(a)) => M(a)`."
06:32:04 <dminuoso> That's just wow.
06:32:50 <hyperisco> I'm still digesting his extended argument about this.
06:33:23 <hyperisco> I am still holding out for some sensible way JS programmers have reimagined this.
06:34:05 <YellowOnion> merijn, I got some code working, thanks for the help, sadly it's giving me nonsense data.
06:34:55 <jgt1> ((...) => { return window.call(null, kleisli).bind(this); } probably
06:35:44 <dminuoso> hyperisco: So lets dissect this. "In the context of..." - argument ad sounding complicated. "The contained value [...] is itself a monad". "Equivalence between M(M(a)) => M(a)` and `M(a) => a". And that being the reason why haskell join has the signature M(M(a)) => M(a).
06:35:51 <dminuoso> That's a might amount of wrongs in just one sentence.
06:36:20 <hyperisco> I don't know, that part doesn't decode for me, but he has other responses on the subject. The commenters really pushed back against it.
06:36:56 <hyperisco> This article was offered as a source to justify a join-extract equivalence in another article by a different author. This stuff really does spread.
06:38:06 <hyperisco> I am sharing to encourage some (hopefully polite) activism. Lets put an end to monadic misinformation!
06:39:19 <dminuoso> @where burrito
06:39:19 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
06:39:33 <dminuoso> So we need another type of fallacy for this.
06:41:36 <merijn> dminuoso: There's already a term
06:41:41 <merijn> dminuoso: "fractal wrongness" :p
06:41:58 <hyperisco> "Just(a) is essentially the identity monad"
06:42:26 <dminuoso> hyperisco: See, so *that* part is actually close to something.
06:42:46 <merijn> dminuoso: When you're not merely wrong, but the entire reasoning for your wrong conclusion is ALSO wrong and the there's just an infinitely deep sequence of wrongness
06:42:56 <dminuoso> In the sense that Maybe a = Either (Const () a) (Identity a)
06:43:12 <merijn> Maybe we can fit some form of "wrongness self-similarity" in there too
06:43:17 <dminuoso> merijn: Interesting, it fits.
06:43:48 <hyperisco> dminuoso, I know what the author is saying, and it isn't that.
06:44:02 <dminuoso> :|
06:44:03 <hyperisco> I'll just reiterate what I learned
06:44:18 <dminuoso> I hope this is not contagious.
06:45:05 <hyperisco> (not all) JavaScript programmers are looking at the source code for some Monad interface or Monad instance and are not respecting the types or laws.
06:45:15 <hyperisco> In other words, whatever the code looks like, that is the only truth there is.
06:45:35 <hyperisco> Identity and Just become the same because in JavaScript these end up both as types with the same implementation.
06:45:54 <hyperisco> (Given a certain variety of encoding – JS doesn't have type classes or ADTs)
06:46:41 <hyperisco> So, step 1) take the source code and forget the types and laws / theory. step 2) derive facts from what the source code says
06:47:09 <hyperisco> This is happening over and over and over again. That's my advice for taking on these conversations, if you feel inclined.
06:48:00 <dminuoso> hyperisco: I guess if you dont have types, dont care about laws in general and have no background in theory.. that's the only thing you can do in fact.
06:48:32 <jgt> you can also hold onto bad analogies too tightly, like the guy on Twitter last year who was adamant that monads are just "smart pipes"
06:48:41 <hyperisco> There is no compelling force to make people write tutorials with mangled information on Monad.
06:48:53 <dminuoso> hyperisco: There is one.
06:49:04 <merijn> hyperisco: There is, the feeling of moral superiority when you bring light to your fellow JS programmers
06:49:12 <sicklorkin> does this function alrady exist somewhere? newb [[1,2],[2,1],[3,2]] == [[1,2],[],[3]]
06:49:32 <hyperisco> Alright, if compelling can be a reflexive act, then sure :P
06:49:43 <dminuoso> What merijn just said.
06:49:51 <dminuoso> I was trying to phrase it, but they put it better.
06:50:04 <merijn> hyperisco: status is what drives huge amounts of human behaviour
06:50:15 <hyperisco> sicklorkin, that function is known as  false
06:50:19 <merijn> And if you're not competent enough to realise you're clueless you don't hesitate
06:50:21 <dminuoso> The ones writing blog entries are the mentors. 
06:50:27 <jgt> sicklorkin: I can't even think of what that function does
06:50:35 <merijn> It's just Dunning-Kruger personified
06:50:53 <merijn> jgt: I'm *guessing* that sicklorkin only wants the ascending elements in each list
06:51:04 <jgt> yeah that's what I'm guessing too
06:51:06 <sicklorkin> lol its like nub but for lits of lsits
06:51:12 <sicklorkin> lists of lists.
06:51:23 <merijn> hyperisco: That function isn't false, unless you know what newb does :)
06:51:35 <hyperisco> merijn, Alright, well my purpose isn't to tear these people down. What actually bothers me is that learners are coming across these articles and being mislead.
06:51:41 <merijn> sicklorkin: Why do you want to keep the result as list of lists?
06:51:44 * hackage extensible-effects-concurrent 0.25.1 - Message passing concurrency as extensible-effect  https://hackage.haskell.org/package/extensible-effects-concurrent-0.25.1 (SvenHeyll)
06:51:53 <hyperisco> merijn, fair enough ^.^
06:51:56 <dminuoso> sicklorkin: So basically nub for trees?
06:52:00 <merijn> hyperisco: I know, I generally don't bother arguing with people like that
06:52:18 <jgt> sicklorkin: I'm not sure there's a function that exists specifically for that; I'd just build it myself, mapping some fold over that list
06:52:23 <merijn> hyperisco: I have decided that trying to fight that fight is a tiring and lost cause that will just run you out of energy
06:52:33 <sicklorkin> merijn: 'cause after newb comes some scary code I don't wanna rewrite right now ;)
06:52:35 <merijn> hyperisco: Better put that energy in educating those who will listen better
06:53:01 <hyperisco> merijn, minimally, some people may read the comments and become cautious. I've been through that several times.
06:53:08 <sicklorkin> jgt: yes, i thought i might spend 1min and see if i was missing something - mapAccumL
06:54:13 <sicklorkin> dminuoso: oh, yes a nub for tree.. Thanks everyone
06:54:16 <hyperisco> Like for example, I was watching a YT channel on engineering — and I know little about it — and several commenters objected to the video. If it wasn't for them, I wouldn't have had a clue how accurate the information was.
06:54:32 <dminuoso> sicklorkin: So I reckon it would rather be something like traverse, than fold.
06:54:37 <merijn> hyperisco: Sure, you can point out what's wrong and point to better resources
06:54:38 <dminuoso> Since you want to preserve some of the structure.
06:54:45 <merijn> hyperisco: I just meant that engaging directly is a lost cause
06:54:45 <sicklorkin> eqNub :: Eq a => Fold a [a] S
06:55:08 <hyperisco> merijn, like the point of public debate isn't to change the mind of the opponent. It is to persuade those who are still persuadable in the audience.
06:57:41 <Uniaika> hello folks!
06:58:09 <Uniaika> I have upgraded to Stack 2.1.1 and when trying to run `stack repl foo.hs`, I get an error message about Docker, namely "Cannot determine project root directory for Docker sandbox."
06:58:33 <Uniaika> considering that I have not activated Docker, and even deactivated it in the global stack configuration, I find this… quite peculiar.
06:58:37 <jgt> hyperisco: that's a point straight out of Thank You For Smoking
06:58:57 <merijn> hyperisco: Sure, I just don't have the energy :)
06:59:11 <hyperisco> And they didn't even pay my royalty!
06:59:48 <merijn> I prefer focusing my effort on people who actually care, because I get more personal enjoyment out of that than an unwinnable internet crusade :)
07:02:44 * hackage manifolds-core 0.5.0.3 - The basic classes for the manifolds hierarchy.  https://hackage.haskell.org/package/manifolds-core-0.5.0.3 (leftaroundabout)
07:03:44 * hackage manifolds 0.5.0.3 - Coordinate-free hypersurfaces  https://hackage.haskell.org/package/manifolds-0.5.0.3 (leftaroundabout)
07:09:44 * hackage manifold-random 0.5.0.3 - Sampling random points on general manifolds.  https://hackage.haskell.org/package/manifold-random-0.5.0.3 (leftaroundabout)
07:10:49 <aveltras> how would one go about creating a directory tree (boostrap a project structure for example) without repeating directory filepaths when creating subdirectories ?
07:11:24 <merijn> aveltras: Not quite sure what you mean by that?
07:12:53 <aveltras> merijn: i know the directory structure i want, i'm trying to implement a cli program with an "init command" to create the directories. I'm trying to implement the function to do this in the cleanest possible way. Not doing sth like this for example
07:12:56 <aveltras> https://www.irccloud.com/pastebin/9Xdrf9W4/
07:14:22 <merijn> aveltras: Is that as far as you'll nest or do you plan to nest arbitrarily deep?
07:14:23 <aveltras> i guess it would use something like StateT over IO but i don't really know how to code it
07:14:36 <aveltras> there will be sub-sub-directories
07:14:58 <merijn> I would probably user reader instead
07:15:07 <dmj`> aveltras: did something like this a few days ago with a trie. 
07:16:46 <aveltras> dmj`: you mean sth like this http://hackage.haskell.org/package/bytestring-trie ? i don't know what's a trie
07:22:04 <Rembane> aveltras: Say you want to create ["a/b/c/foo.txt", "a/b/d/README"] then you can split each path on "/", sort alphabetically and then by length and then split each list on the common prefix.
07:22:37 <merijn> aveltras: How about something like: https://paste.debian.net/1087842/ ?
07:22:56 <merijn> Add some newtype wrapping + GeneralizedNewtypeDeriving instead of the alias and done
07:23:19 <merijn> oh, wait, I forgot to actually make the new directory in makeWithDir, but that's pretty easy too
07:24:19 <aveltras> merijn: ye something like this :)
07:24:39 <aveltras> Rembane: thanks for the answer but merijn 's answer is more what i was looking for
07:25:02 <Rembane> aveltras: No worries. merijn's answer also strictly better. :)
07:26:08 <aveltras> merijn: thanks 
07:30:51 <solonarv> kuznero[m]: if you're still trying to bind to tensorflow, perhaps you'd want to know someone has already done that: https://hackage.haskell.org/package/tensorflow
07:45:24 <jinna> In main, during initialization, I want to read&parse my config file. If anything goes wrong I would like to quit the app with an error message. Which IO action is doing this for me?
07:45:55 <merijn> jinna: Exiting, you mean?
07:46:01 <jinna> si
07:46:04 <merijn> :t System.Exit.exitFailure
07:46:06 <lambdabot> IO a
07:46:24 <jinna> good thx
07:46:30 <eviltwin_b> well, tht exits the app. the error message is your problem
07:46:33 <solonarv> there's also a variant that lets you specify an exit code
07:46:46 <eviltwin_b> and depends on whether it's just text output to the console, or you expect a dialog box, etc.
07:47:07 <solonarv> and you can write an error message to standard error with: hPutStrLn stderr "kaboom"
07:47:40 <jinna> I would just like to write something to the console and exit the app.
07:48:39 <solonarv> there's no pre-made function for that (as far as I know) but you can just write to the console and then call exitFailure
07:49:16 <jinna> Or even    die :: String -> IO a    (also from System.Exit)
07:50:47 <merijn> jinna: you can roll that in two lines with exitFailure and hPutStrLn stderr
07:54:06 <dmj`> aveltras: something like this https://github.com/dmjio/trie
07:54:12 <dmj`> aveltras: and you use the fromList to fill it 
07:55:26 <dmj`> aveltras: fromList [ (["foo","bar"], "file1.txt"), (["foo","baz"], "file2.txt")] :: Trie String
07:55:42 <dmj`> aveltras: the trie would contain one parent node "foo" and two child nodes, bar and baz
07:59:01 <aveltras> dmj`: ye, i see, thanks for the answer
08:05:14 * hackage bglib 2.0.0.0 - Implementation of the BGAPI serial protocol  https://hackage.haskell.org/package/bglib-2.0.0.0 (tamasFabian)
08:07:51 <jinna> Does ghci catch exits? I was trying    `die "Bye!"`   in the repl and see as a result the printed message:    *** Exception: ExitFailure 1              
08:08:05 <dmj`> aveltras: can also use split package, splitOn “/“ to populate the keys of the entries in fromList. trie will merge the paths automagically
08:08:06 <jinna> And then I can happily continue to work. Not exited.
08:08:40 <solonarv> jinna: looks like it does catch them, then
08:09:59 <jinna> solonarv: yeah, in the bash it works. The exiting I mean.
08:10:09 <jinna> solonarv: but _how_ can ghci catch such an exit?
08:11:01 <c_wraith> you can think of there being a wall between ghci and the code it interprets
08:11:46 <c_wraith> Unless you interpret something that messes with external resources, your code isn't going to touch ghci.
08:12:13 <jinna> Oh okay, so this is done by some ghci magic, and not by „catching” exit attempts.
08:12:46 <c_wraith> but if you corrupt memory with bad ffi use, or mess with something at the process level, like closing stdout, ghci just isn't affected by the code you run.
08:12:55 <c_wraith> err. *unless
08:14:02 <jinna> c_wraith: as soon I mess with memory it’s the OS that kills me?
08:14:35 <c_wraith> not necessarily. sometimes it can stay running, but things will just work wrong.
08:15:05 <c_wraith> other times you trigger a fault the os notices and it immediately kills the process
08:15:56 <statusfailed> I once had a really "fun" bug where my haskell executable was expecting a newer version of glibc on the machine it was deployed to, and when it ran it just kept allocating memory without doing anything else until it was OOM-killed.
08:16:27 <statusfailed> still no idea why that happened
08:33:08 <hyperisco> Technically the CPU notices and the OS kills the process :D
08:33:31 <aveltras> is there a maintained and lightweight quasiquotes packages that handles indentation based on the first string of a multiline string + variable interpolation ?
08:38:26 <Axman6> bgamari_: what's the status of https://tools.ietf.org/html/draft-bormann-cbor-time-tag-02? I notice it says "Expires: April 25, 2019"
08:38:46 <bgamari_> Axman6, that is a good question
08:38:54 <bgamari_> Axman6, I haven't heard from Carsten in quite a while
08:40:15 * hackage polysemy-plugin 0.2.1.0 - Disambiguate obvious uses of effects.  https://hackage.haskell.org/package/polysemy-plugin-0.2.1.0 (isovector)
08:41:58 <Axman6> I was having a look back at some of the older cbor issues I'd participated in and remembered that RFC was a thing. I don't really know what the process for RFCs though. I guess now there's IANA numbers it's sort of a thing?
08:42:25 <bgamari_> Axman6, I think so 
08:42:30 <bgamari_> I'm honestly a bit unsure myself
08:42:45 <bgamari_> Carten was really the one driving the formal RFC process
08:42:53 <bgamari_> in the case of that RFC at least
08:44:44 * hackage OrderedBits 0.0.2.0 - Efficient ordered (by popcount) enumeration of bits  https://hackage.haskell.org/package/OrderedBits-0.0.2.0 (ChristianHoener)
09:04:16 * hackage PrimitiveArray 0.9.1.1 - Efficient multidimensional arrays  https://hackage.haskell.org/package/PrimitiveArray-0.9.1.1 (ChristianHoener)
09:08:45 * hackage BiobaseENA 0.0.0.1 - European Nucleotide Archive data  https://hackage.haskell.org/package/BiobaseENA-0.0.0.1 (ChristianHoener)
09:09:44 * hackage BiobaseTypes 0.2.0.1 - Collection of types for bioinformatics  https://hackage.haskell.org/package/BiobaseTypes-0.2.0.1 (ChristianHoener)
09:18:44 * hackage BiobaseBlast 0.3.0.0 - BLAST-related tools  https://hackage.haskell.org/package/BiobaseBlast-0.3.0.0 (ChristianHoener)
09:19:44 * hackage BiobaseXNA 0.11.0.0 - Efficient RNA/DNA/Protein Primary/Secondary Structure  https://hackage.haskell.org/package/BiobaseXNA-0.11.0.0 (ChristianHoener)
09:21:44 <Boarders> I am currently failing to build with profiling because I don't seem to have a profile build of base 4.12, does anyone know an easy way to remedy that?
09:24:07 <glguy> How did you install GHC?
09:27:14 <Boarders> through apt-get and hvr's repository
09:28:12 <glguy> There's a package "ghc-$VER-prof" (contains profiling libs) you need to install
09:32:09 <Boarders> thanks!
09:36:07 <noipmusp> Is it possible to define something life "type level subset of datatypes"? Something like (in a non-valid syntax) "data Parity = None | Odd | Even" and "data Nat None = One | Two | Three | Four", "data Nat Odd = One | Three", and "data Nat Even = Two | Four".
09:37:20 <hyperisco> noipmusp, Not exactly like that but probably in another way, yes.
09:38:16 <hyperisco> noipmusp, One close option is to use a data family.
09:39:29 <noipmusp> hypersico: I totally forgot about them :).
09:39:37 <noipmusp> hyperisco: Thanks.
09:57:56 <solonarv> noipmusp: or a GADT
09:58:22 <noipmusp> solonarv: I don't have luck figuring this out using GADTs.
09:58:33 <solonarv> you can define: data Parity = Odd | Even; data Nat p where One :: Nat Odd; Two :: Nat Odd -- etc
09:59:12 <solonarv> then if you want no/unknown parity you just talk about a 'Nat p', with p being an unknown type variable
09:59:52 <noipmusp> Oh, make sense. Thanks.
10:00:24 <solonarv> for example: natToNatural :: forall p. Nat p -> Natural
10:00:26 <noipmusp> And what about case when I would like to "tag" i.e. every fourth number?
10:00:46 <noipmusp> …together with every even.
10:00:59 <solonarv> at that point you're probably better off using singletons or something
10:01:05 <solonarv> if you really must have it in the type
10:01:41 <noipmusp> Whoa, you mean this: http://hackage.haskell.org/package/singletons?
10:02:52 <solonarv> yep
10:03:04 <solonarv> but it's rather cumbersome to use
10:03:29 <noipmusp> I see :).
10:03:30 <solonarv> I'm not sure what your actual goal is; perhaps there's a better approach than tracking parity etc. at the type level?
10:06:19 <noipmusp> solonarv: I have an C code statement data type. Every C code statement can be side effect, return statement, conditional statement and while/for statement. The problem is that not every statement can contains variable declaration (e.g. "int foo = 2;"). I would like to encode this information in type level.
10:08:04 <hyperisco> noipmusp, where is that not allowed?
10:08:38 <noipmusp> if '(' <expr> ')' <expr>
10:08:41 <solonarv> ah, that's very different from tracking number parity or whatever!
10:09:08 <noipmusp> Basically condition without curly brackets.
10:09:08 <hyperisco> I am not sure how that is an example of where a variable declaration statement is not allowed.
10:09:11 <solonarv> you don't even really need fancy types for this, I think
10:10:37 <hyperisco> Also, statements go in blocks, and a block is what follows  if (…)  . Or is my memory of C deteriorated?
10:10:41 <solonarv> you can have something like: data CStmt = ExprStmt CExpr | ReturnStmt CExpr | IfStmt CExpr CStmt (Maybe CStmt) | BlockStmt [CStmt] | ...
10:11:01 <solonarv> a block is anything between braces { ... }, and a block is a statement
10:11:30 <hyperisco> So what I would expect is  if '(' <expr> ')' <statement>
10:11:33 <solonarv> 'if ( <condition> )' can be followed by any statement; often that's a block, and that is considered good code style, but it doesn't  have to be
10:11:44 <solonarv> yes
10:11:46 <noipmusp> hyperisco: Yes, my fault.
10:11:49 <hyperisco> And also for that whole construct to be a statement.
10:12:13 <hyperisco> Well, variable declarations are allowed anywhere a statement is allowed, as far as I am aware. Is that not so?
10:12:25 <solonarv> that does *sound* right to me
10:12:37 <solonarv> but I can't be bothered to look at a C standard
10:13:04 <dmwit> noipmusp: http://hackage.haskell.org/package/language-c
10:14:00 <dmwit> noipmusp: e.g. see http://hackage.haskell.org/package/language-c-0.8.2/docs/Language-C-Syntax-AST.html#t:CStatement vs http://hackage.haskell.org/package/language-c-0.8.2/docs/Language-C-Syntax-AST.html#t:CExpression which captures the distinction you are talking about
10:14:27 <solonarv> \o/
10:14:43 <solonarv> I forgot there would already be a library to point to here ;)
10:15:01 <solonarv> hm, I wonder if someone's written a C compiler in Haskell?
10:17:07 <dmwit> Bet you could extract one from CompCert. ;-)
10:20:44 <dmwit> (Anyway I don't know of one.)
10:25:44 * hackage polysemy-zoo 0.2.0.0 - Experimental, user-contributed effects and interpreters for polysemy  https://hackage.haskell.org/package/polysemy-zoo-0.2.0.0 (isovector)
10:25:56 <solonarv> isovector1: putting in the work!
10:26:14 <isovector1> solonarv: it's not going to do itself!
10:35:06 <dmwit> -fspecialise-aggressively # yikes
10:42:42 <eviltwin_b> Schwarzenegger as the Specializer?
10:45:56 <isovector1> c-rog: are you CRogers on github by any chance?
10:49:14 <infinisil> isovector1: Oh hello there :)
10:49:58 <isovector1> infinisil: hi!
10:53:32 <sm[m]> adius: haskellising taskwarrior, eh ?!
10:58:33 <dm9> Does anyone know why `fmap isSpace ['\x0085', '\x2028', '\x2029']` yields `[False,False,False]`? If I am not mistaken, they are whitespace characters according to the Unicode standard
10:59:49 <glguy> > map generalCategory ['\x0085', '\x2028', '\x2029']
10:59:51 <lambdabot>  [Control,LineSeparator,ParagraphSeparator]
11:01:16 <dm9> > generalCategory '\n'
11:01:19 <lambdabot>  Control
11:04:08 <glguy> I'm a little surprised; it looks like base defers to iswspace(3) for the Unicode cases
11:04:19 <glguy> and iswspace seems to return 1 for the characters in question
11:04:54 <glguy> > filter isSpace ['\0'..]
11:04:56 <lambdabot>  "\t\n\v\f\r \160\5760\8192\8193\8194\8195\8196\8197\8198\8199\8200\8201\8202...
11:05:09 <glguy> \8239\8287\12288"
11:06:21 <int-e> glguy: it's not using the C library version of those functions. libraries/base/cbits/WCsubst.c is where u_iswspace is implemented...
11:08:35 <talqu> Hi, how would approach this: data A = A x y z 
11:08:52 <glguy> dm9: I guess file a bug
11:09:12 <talqu> then p = (1,2,3). I want to apply A p. 
11:09:41 <dm9> glguy: oh, could this be my very first ghc contribution? ;-)
11:10:43 <glguy> >>> filter (\x -> Data.Char.isSpace x /= (0 /= iswspace (fromIntegral (Data.Char.ord x)))) ['\0'..]
11:10:43 <glguy> "\133\8203\8232\8233"
11:11:07 <int-e> so the upshot is that Unicode category: Separator, Line is not included in isSpace. (And the same goes for Separator, Paragraph)
11:11:58 <jle`> talqu: aToTuple (x,y,z) = A x y z
11:12:02 <jle`> * aFromTuple
11:13:29 <int-e> and the zero-width space is under "Other, Format".
11:13:38 <int-e> such fun :-(
11:14:20 <int-e> (the nice thing about standards is that there are so many to choose from?)
11:15:23 <dm9> int-e: see also https://en.wikipedia.org/wiki/Newline#Unicode
11:16:59 <talqu> jle`: thank you, i was doing it this way. Good to know
11:26:58 <int-e> > generalCategory '\x2062'
11:27:01 <lambdabot>  Format
11:52:14 * hackage polysemy-RandomFu 0.1.0.0 - Experimental, RandomFu effect and interpreters for polysemy  https://hackage.haskell.org/package/polysemy-RandomFu-0.1.0.0 (adamCS)
11:56:39 <freusque> how easily can we write fixed-length type-level lists?
11:57:02 <Boarders> if I do cabal new-build --enable-profiling and then try cabal new-run --ghc-options="+RTS -xc -RTS" I get an error ghc: the flag -xc requires the program to be built with -prof
11:57:07 <Boarders> does anyone know what I am doing wrong?
11:57:53 <dminuoso> Boarders: The +RTS flags dont belong to GHC.
11:57:59 <dminuoso> Boarders: They belong to the executable itself.
11:58:12 <freusque> Boarders: also did you try to cabal configure --enable-profiling
11:58:13 <dminuoso> Boarders: So try: cabal new-run yourapp -- +RTS -xc -RTS
11:58:17 <glguy> Boarders: I'd also give --enable-profiling to the v2-run command
11:58:31 <glguy> freusque: cabal configure is the old workflow, doesn't pertain now
11:58:43 <freusque> thanks glguy 
11:58:44 <dminuoso> Boarders: Otherwise its conceivable that the flags are considered as RTS flags for GHC itself.
11:59:09 <solonarv> freusque: hmm, I was about to say that's easy but I'm not actually sure anymore
11:59:14 <glguy> dminuoso: Is right that that's the right way to get the RTS flags to your executable
11:59:26 <solonarv> I don't think GADTs can be promoted via DataKinds right now
11:59:42 <dminuoso> glguy: Wait, this bakes RTS flags into the executable? Really?
12:00:05 <dminuoso> glguy: Or.. can you rephrase that? Im not sure I understand.
12:00:27 <solonarv> Boarder: you're passing those RTS options to *ghc*
12:00:37 <Boarder> solonarv: got it, thanks
12:00:43 <solonarv> so you are telling GHC to output profiling information about itself
12:00:44 <Boarder> thanks dminuoso
12:01:21 <Boarder> where would I put that stuff, if I have an executable called app
12:01:31 <Boarder> so I run it as: cabal new-run app
12:01:36 <solonarv> you would pass it to the app
12:01:52 <solonarv> like so: cabal new-run app -- +RTS <whatever> -RTS
12:02:10 <solonarv> (the -- is needed so cabal doesn't eat those options for itself)
12:02:47 <Boarder> ah, got it
12:02:50 <Boarder> thank you!
12:03:01 <solonarv> in fact dminuoso already suggested this ^^
12:03:15 <Boarder> I got disconnected so might have missed a message
12:03:29 <solonarv> oh yes, that was while you were gone
12:03:37 <dminuoso> Boarder: We keep a channel log. So its helpful to check with that if you drop out.
12:03:43 <Boarder> oh yes
12:04:06 <solonarv> or use a bouncer, I've been continuously connected for something like 2 weeks now :D
12:04:18 <dminuoso> solonarv: If only bouncers worked reliably for that.
12:04:30 <dminuoso> I sometimes have moments where messages disappear during disconnects.
12:04:43 <solonarv> my "bouncer" is just irssi+screen+ssh
12:04:56 <dminuoso> solonarv: You should use mosh rather than ssh then :)
12:05:22 <solonarv> what's that?
12:05:56 <dminuoso> solonarv: Do you ever get annoyed when ssh connections drop say because wifi is being bad, or you are on a train?
12:06:27 <sm[m]> mosh+dtach+emacs+erc ftw !
12:06:40 <solonarv> hm, I had some issues once but the wifi was so terrible *nothing* was working
12:06:48 <solonarv> and the connection didn't outright frop even then
12:07:10 <sm[m]> Or, the easy alternative: riot
12:07:51 <solonarv> if only riot wasn't a sluggish electron app :/
12:08:09 <solonarv> (hm, move to #haskell-blah ?)
12:09:44 * hackage birch-beer 0.1.3.1 - Plot a colorful tree.  https://hackage.haskell.org/package/birch-beer-0.1.3.1 (GregorySchwartz)
12:19:44 * hackage too-many-cells 0.1.7.1 - Cluster single cells and analyze cell clade relationships.  https://hackage.haskell.org/package/too-many-cells-0.1.7.1 (GregorySchwartz)
12:50:44 * hackage knit-haskell 0.5.0.0 - a minimal Rmarkdown sort-of-thing for haskell, by way of Pandoc  https://hackage.haskell.org/package/knit-haskell-0.5.0.0 (adamCS)
13:34:29 <reygoch> Does anyone have some experience with Windows API and FFI?
13:35:29 <reygoch> I want to get the title of current active window, but at the moment I'm stuck at figuring out how to cast response from FFI function call into appropriate type.
13:35:53 <cocreature> show us the function you’re ffi’ing to?
13:36:18 <reygoch> https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-sendmessage
13:36:56 <reygoch> It is returning LRESULT which should be cast into the appropriate type (string, bool or what ever is supposed to be returned)
13:37:43 <reygoch> in c I can just do something like LRESULT tmp = SendMessage(whatever); String result = (String *)tmp;
13:38:22 <reygoch> Not sure how to do it with FFI without writing a wrapper C function.
13:39:35 <crestfallen> hi while counting inhabitants of a adt, with data Maybe Bool the cardinality is 3. The possible return values (inhabitants, such as Just False) are adt's, right? I.e. we are counting the "inhabitants" as return values/objects  
13:40:59 <reygoch> crestfallen, I guess you could say that
13:41:44 <reygoch> crestfallen, for maybe Bool inhabitants are Nothing, Just True, Just False. But I'm not sure what you mean by ADTs in this case.
13:41:49 <hyperisco> crestfallen, an ADT is a type (it is in the name). You can just say that Maybe Bool has 3 inhabitants.
13:42:01 <cocreature> reygoch: 1. you might just want to use the Win32 package instead of writing the actual FFI call yourself. 2. In the Win32 package LRESULT is just a synonym for CIntPtr so you could use that in your FFI call and then turn it into a Ptr with something like "intPtrToPtr . fromIntegral"
13:42:13 <__monty__> Not quite though. `Just False` is a value of a certain Algebraic Data *Type*, specifically `Maybe Bool`.
13:42:17 <cocreature> and then peek that ptr or whatever to get the result
13:43:31 <crestfallen> right so you're counting an object that is a Maybe container(?) containing a Bool inhabitant
13:44:12 <reygoch> cocreature: Win32 doesn't implement this function, so I guess I'll have to go the intPtrToPtr. Thanks.
13:44:52 <hyperisco> No no. Maybe is a type constructor, Bool is a type, Maybe Bool is a type, and Maybe Bool has inhabitants. You can say that  Just False  is a value with type  Maybe Bool.
13:45:07 <cocreature> reygoch: https://hackage.haskell.org/package/Win32-2.8.3.0/docs/Graphics-Win32-Window.html#v:sendMessage
13:45:20 <hyperisco> You can say  Just False  inhabits  Maybe Bool . You can say  Maybe Bool  is inhabited by  Just False .
13:46:15 <reygoch> cocreature: ah, sorry. I was thinking of GetActiveWindow :D, but thanks for this as well.
13:47:00 <eviltwin_b> crestfallen, you can consider ome things like that to be containers. you cannot in general, and it's bad to get into that assumption
13:47:03 <isovector1> anyone have a solution for testing GHC.TypeLit.TypeErrors?
13:47:15 <isovector1> -fdefer-type-errors doesn't emit them at runtime, so `should-not-typecheck` doesn't work :'(
13:47:58 <cocreature> reygoch: https://hackage.haskell.org/package/Win32-2.8.3.0/docs/Graphics-Win32-Key.html#v:getActiveWindow :)
13:48:47 <reygoch> cocreature: how do you find those? Hoogle is not giving me anything, and I would never guess it would be in Key module.
13:49:11 <reygoch> cocreature: enlighten me please :)
13:49:28 <crestfallen> I see ok. so in the case of logical implication hyperisco   ,   could I ask about this git ? https://github.com/varreli/haskell/commit/4d8f239a6035eb7540d13a217687141388319232
13:50:09 <hyperisco> crestfallen, What is the question?
13:50:31 <cocreature> reygoch: Ctrl-F on https://hackage.haskell.org/package/Win32-2.8.3.0/docs/doc-index-All.html works pretty well
13:50:57 <cocreature> reygoch: or just grep through the repo either locally or via the github search (but that tends to be somewhat fragile ime)
13:51:17 <crestfallen> lines 18-37  has each line describing an inhabitant of Tri -> Bool   and   Bool -> Tri
13:51:21 <reygoch> cocreature: ooooo.... never used this index all feature, thanks for the tip :D
13:51:50 <crestfallen> my question is ..
13:52:53 <crestfallen> that these are lists of inhabitants but there is no structure to the return values, other than being types.
13:52:59 <crestfallen> correct?
13:55:04 <hyperisco> crestfallen, I suspect a disservice was done by using -> in two different ways. What they're saying on lines 18-25 with -> is "maps to",  Zelda -> False  means Zelda maps to False, or that an input of Zelda gives an output of False.
13:55:34 <hyperisco> In Haskell we'd say   f Zelda = False; f Trent = False; f Ganon = False
13:55:54 <hyperisco> f :: Tri -> Bool
13:56:02 <dmwit> The return values are not types. So I don't understand "there is no structure to the return values other than being types".
13:56:48 <crestfallen> let me process that thank you. I added the (->) because I thought it was a way to conceptualize it
13:56:58 <hyperisco> The other (usual) use of -> when they say  Tri -> Bool  is the type of functions (maps) from Tri to Bool
13:57:41 <crestfallen> but inherently it is logical implication right?
13:57:51 <hyperisco> What is the implication?
13:58:05 <hyperisco> Are you referring to ->?
13:59:00 <crestfallen> yes because the algebra used to count the inhabitants here is b^a , which is logical implication
13:59:28 <crestfallen> which indicates* implication
13:59:31 <crestfallen> as I understand it
13:59:35 <hyperisco> From the Curry-Howard correspondence, yes.
14:00:05 <hyperisco> Oddly that isn't specifically invoked that much around here oO
14:00:42 <crestfallen> but f Zelda = False is how you'd write it.
14:01:17 <hyperisco> That is how you'd write one clause of an inhabitant of  Tri -> Bool
14:01:27 <[exa]> the usual `maps to` is written with the tiny bar at the beginning to avoid confusion, like |-->
14:01:42 <hyperisco> [exa], thanks!
14:01:46 <[exa]> not sure if there's a good ascii counterpart
14:01:54 <[exa]> like, I'd love to know one
14:02:24 <crestfallen> [exa] do you mean when you're charting out the inhabitants that is the notation ?
14:03:02 <crestfallen> because I see how "maps to" doesn't fit
14:03:34 <[exa]> as far as I remember from math papers, -> is for writing "types" and |-> is for writing single mapped pairs
14:04:19 <[exa]> like,  not: 2 -> 2,  T |-> F, F |-> T
14:04:27 <[exa]> lemme dig an UTF symbol for that
14:05:11 <hyperisco> Seems I have more things to add to my compose key
14:05:32 <hyperisco> ⇥  is there though
14:05:34 <[exa]> yeah ↦
14:06:08 <hyperisco> Good luck, I'm out
14:06:35 <[exa]> cu
14:06:43 <crestfallen> thanks hyperisco
14:06:49 <crestfallen> [exa]:   ...
14:08:02 <[exa]> anyway sorry for jumping into the conversation like this, I still don't know what the original problem is about :]
14:08:58 <crestfallen> ok I'm a stickler for notation, thanks, but know zilch about editors .   so beginning line 18 we have ... what exactly would you call those with the proper notation? they're not types according to above , they are just all cases of Tri -> Bool or Bool -> Tri    ,   written conceptually [exa] 
14:09:48 <crestfallen> https://github.com/varreli/haskell/commit/4d8f239a6035eb7540d13a217687141388319232     << based on this page
14:10:13 <[exa]> better avoid any notation sticking with -> since it's overloaded for at least 4 different things in haskell :]
14:10:20 <[exa]> s/overloaded/reused/
14:10:42 <crestfallen> ok f Zelda = False seems fine.
14:10:55 <crestfallen> thank you kindly
14:10:57 <[exa]> otherwise yes, it would work if you wrote 'case of parameter' before that so you can probably leave it as is, I get it
14:11:32 <crestfallen> sorry where would you write case of parameter ? [exa]
14:12:14 <[exa]> 'case parameter of', sorry.
14:12:34 <[exa]> like, some notation that would actually trigger the correct meaning of ->
14:12:50 <crestfallen> not sure I follow
14:12:56 <[exa]> oh, don't worry about notation
14:13:12 <[exa]> especially if the point is combinatorics now
14:14:07 <crestfallen> are the comments on lines 4-16 correct ? I had some help on the math channel and that is verbatim [exa]
14:15:50 <[exa]> yes, seems correct
14:18:23 <[exa]> except for a minor technical detail, in Haskell each function has one extra possibility to fail, so if you have finite domains A and B, the count of valid implementable functions is in fact (B+1)^A
14:19:17 <[exa]> but you don't usually want failing functions anyway, so feel free to disregard that as well
14:20:49 <crestfallen> ok thanks kindly      lines 9-14 were from the math irc , not lines 4-7  ...
14:21:03 <[exa]> (mathematically, B is codomain, not domain, sorry)
14:21:13 <solonarv> isovector1: besides shelling out to GHC (as was suggested in #ghc), perhaps you could replace uses of TypeError with 'type family Err msg where Err msg = TypeError msg', and in the test suite run a typechecker plugin to rewrite that to something you can catch
14:21:32 <solonarv> (with -fdefer-type-errors)
14:22:24 <[exa]> crestfallen: 9-14 is correct, the set of functions from some domain that return Bool are isomorphic to the subsets of that domain
14:22:33 <[exa]> s/are/is
14:23:11 <crestfallen> thinking ...
14:23:54 <[exa]> crestfallen: look at eg. line 22, there is set {Zelda} written as a function
14:24:57 <crestfallen> you call that set Zelda ?
14:25:00 <[exa]> and all the functions list the subsets of {Zelda,Trent,Ganon}, which is, line-by-line: {}, {Ganon}, {Trent}, {Trent,Ganon}, ...
14:25:14 <[exa]> no, {Zelda} is a set that contains one Zelda
14:26:09 <[exa]> perhaps you're used to different set notation, here sets are denoted in {}, as ℕ={1,2,3,...}
14:26:41 * supersweetsweetc uploaded an image: tenor_gif3884147121698534658.gif (76KB) < https://matrix.org/_matrix/media/v1/download/matrix.org/HekCDkDiQluuDQvmodziUGzN >
14:26:50 <crestfallen> Zelda |-> True  , Trent |-> False , Ganon |-> True        3 sets , but one inhabitant ?
14:27:23 <[exa]> this what you have written implicitly defines a set of items where the function returns True
14:27:34 <[exa]> in this case, {Zelda,Ganon}
14:27:45 <[exa]> which is a subset of the whole {Zelda, Ganon, Trent}
14:27:46 <[exa]> ok?
14:28:54 <[exa]> % data Ppl=Zelda|Ganon|Trent   --let's try
14:28:54 <yahb> [exa]: 
14:29:47 <[exa]> % fff Zelda = True; fff Ganon = False; fff Trent = True
14:29:47 <yahb> [exa]: 
14:30:02 <[exa]> % deriving Enum Ppl
14:30:02 <yahb> [exa]: ; <interactive>:146:10: error: parse error on input `Enum'
14:30:13 <[exa]> oh noes
14:30:26 <[exa]> % filter fff [Zelda,Ganon,Trent]
14:30:26 <yahb> [exa]: ; <interactive>:147:1: error:; Ambiguous occurrence `filter'; It could refer to either `Data.Text.filter', imported from `Data.Text'; or `Prelude.filter', imported from `Prelude' (and originally defined in `GHC.List')
14:30:40 <[exa]> % Prelude.filter fff [Zelda,Ganon,Trent]
14:30:40 <yahb> [exa]: ; <interactive>:148:1: error:; * No instance for (Show Ppl) arising from a use of `print'; * In a stmt of an interactive GHCi command: print it
14:31:06 * [exa] should play with yahb somewhere else...
14:32:36 <solonarv> it works in /w too :D
14:32:53 <[exa]> I expected less surprises
14:33:14 <solonarv> yeah, that happens sometimes
14:33:21 <crestfallen> so one inhabitant can contain 3 False values. There's no subset that returns True, but it is a valid inhabitant
14:33:23 <solonarv> sometimes people incautiously import things
14:34:08 <[exa]> crestfallen: this is basically what I wanted to show https://pastebin.com/7keNFFYm
14:34:41 <crestfallen> ln 18 is a valid inhabitant, but it is an empty set    right?
14:34:50 <[exa]> you can use 'filter' to convert functions to the corresponding subsets of the whole domain, and reversely 'elem' to convert the subset back to function
14:35:31 <[exa]> crestfallen: yes, it's a valid function of that type, but returns False all time (which, translated to sets, means that it's equivalent to empty set)
14:36:10 <crestfallen> ok great thanks very helpful
14:36:14 <crestfallen> ...
14:37:07 <crestfallen> so this is why Bartosz said that adt's are really set theory
14:37:43 <[exa]> well, a very extremely simple beginning of the whole set theory, but basically yes
14:38:29 <crestfallen> for my next trick I'm going to study how certain graphs are adt's . any pointers appreciated
14:39:52 <dmwit> Bartosz said that ADT's are really set theory?
14:40:04 <[exa]> anyway the combinatory explanation of your problem here is probably easier; the function of type A->B can recognize |A| different inputs at most, and for each recognized input it has |B| possibilities what to return. Total amount of choices it has is thus |B|^|A|, which is also the number of implementable functions (each definition makes the choice once)
14:40:06 <dmwit> Is it possible you misunderstood them?
14:40:52 <crestfallen> dmwit I thought something like that .. I could have misheard video
14:41:36 <[exa]> dmwit: given the quantifiers on types you can mimic the whole ZF pretty easily so I'd believe that.
14:41:53 <[exa]> probably not at the level of this exercise tho.
14:42:18 <crestfallen> passes over my head   :)
14:44:05 <dmwit> [exa]: What is the ADT-equivalent of set union? Or, going the other way, what is the set-theroy equivalent of a -> a?
14:45:31 <dmwit> Neither theory is quite like the other one.
14:45:48 <dmwit> There's lots of parallels, sure.
14:48:06 <crestfallen> but understanding adt's is crucial to haskell right? I mean , if "everything in haskell is a list" that means it's crucial to understand L(a) = Nil | Cons a L(a)   and how it is derived to describe an infinite List . 
14:48:32 <dmwit> ADT's are pretty central to most Haskell programming. I do not agree with "everything in Haskell is a list".
14:48:55 <monochrom> If you s/haskell/lisp/ you may get better luck.
14:48:55 <crestfallen> hmm I just read it somewhere tis all
14:48:56 <[exa]> dmwit: good point, a->a are pairs of same items (not a set though, lol), and set union is, well, problematic
14:49:20 <[exa]> crestfallen: wasn't it about Scheme or Lisp?
14:49:48 <crestfallen> monochrom: HI !     I don't know [exa] I can't keep it all straight
14:50:25 * [exa] disappears afk
14:50:32 <monochrom> But more meta-level generally the problem with internet hearsay is the following.
14:51:36 <monochrom> As a beginner you are bound to distort everything you hear by let's say 30%.  In other words only 70% fidelity.
14:52:20 <crestfallen> in any case I really enjoyed learning about      L(a) = Nil | Cons a L(a)
14:52:30 <monochrom> And the internet is also full of noise and wrong people, so let's say they already come with 50% distortion.
14:52:34 <monochrom> > 0.7 * 0.5
14:52:36 <lambdabot>  0.35
14:53:14 <monochrom> This means every time you say "I heard so-and-so from the internet" it means that only 35% fidelity is left.
14:54:48 <crestfallen> I also study martial arts by watching youtube   :)
14:54:58 <Rembane> It's the best way to study martial arts. 
14:55:07 <crestfallen> yeah no injuries
15:28:30 <solonarv> set union is not really a thing, but disjoint union sure is!
15:34:33 * dmwit imagines some die-hard set theory fan saying "polymorphism is not really a thing!" and chuckles
15:43:14 * hackage stratosphere 0.39.0 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.39.0 (jdreaver)
16:17:58 <gobby> Which is the best provider to launch my haskell web app in a docker container?
16:18:11 <gobby> I guess I'm looking for beginner friendliness and ease of monitoring
17:07:36 <mort> why did jacobn and zeroxscape, two people who're only in #haskell, just message me when I'm just idling in here and have very little to do with haskell in general
17:48:44 * hackage flags-applicative 0.0.5.0 - Applicative flag parsing  https://hackage.haskell.org/package/flags-applicative-0.0.5.0 (mtth)
19:54:38 <dmoerner> Basic question about Stack: Does it work without super user privileges? I downloaded the 2.1.1 tarball on Fedora Linux x64, put it in ~/bin, but when I run stack I just get "stack: no process upgrade" for any command
19:56:06 <dmoerner> Sorry, it's conflict with stack from Plan 9 -- my mitsake
19:56:15 <dmoerner> And also sorry for my typing mistakes
19:56:33 <Welkin> plan 9 exists?
19:57:19 <dmoerner> In fact, there's a fresh rpm of plan9port that I just uploaded to copr
19:57:24 <Welkin> or you mean this
19:57:24 <Welkin> https://en.wikipedia.org/wiki/Plan_9_from_Outer_Space
19:57:53 <dmoerner> plan9's plumbing works beautifully with tools like hindent, pandoc
19:57:54 <Welkin> haha
19:58:02 <Welkin> it has bella lugosi and vampira
19:58:14 <Welkin> it's a monster/occult and scifi mashup
19:59:02 <Welkin> when you say plumbing, it makes me think of the euphemism used to describe gentalia
20:36:27 <Cristine98> I am super horny & wet. Join & watch my Live and let's have fun together. The fun is guaranteed, boys. Link ---> https://clc.to/user=Cristine98
20:54:21 <mac10688> I'm following Gabriel's guide on haskell + nixos workflow and there's an example about dependency management that should work but it's not. A dependency requires process and trasnformers-compat for a certain version. So I go through his steps to make nix versions to specify the process and transformers-compat that I want and it's like it doesn't recognize it when i go to rebuild.
20:54:26 <mac10688> I'm a bit lost
20:54:49 <mac10688> https://github.com/Gabriel439/haskell-nix/blob/master/project1/README.md
20:55:07 <mac10688> in project1. nix-build --attr project1 release3.nix
20:55:31 <mac10688> process >=1.0 && <1.5, transformers-compat >=0.3 && <0.6
20:56:09 <mac10688> so I run cabal2nix cabal://process-1.4.3.0 > process.nix and add it to the release3.nix file and do the same for transformers-compat and still the same thing
21:08:04 <infinisil> Weird question: Is there a way to hash an implementation of a function?
21:08:21 <infinisil> I'd like to save a cache of a computation
21:08:32 <infinisil> But I want it to be recomputed if I change the implementation
21:09:19 <infinisil> Just hashing the representation of the AST would even work for this
21:09:44 <infinisil> Oh, TemplateHaskell? That might work..
21:12:40 <YellowOnion> What's the point of having TVar and TMVar? is TVar faster or something?
21:13:59 <Axman6> they have different semantics
21:15:20 <Axman6> TMvar is a box which is either empty or full and can wake up waiting threads in FIFO order. TVar is a mutable transactional variable. Though it is a little less clear what the difference between TVar (Maybe a) and TMVar a is
21:16:41 <Welkin> trademark var
21:16:57 <Welkin> is there a copright var?
21:17:03 <Welkin> and a registered var?
21:17:10 <Welkin> what about a SMVar?
21:18:05 <Welkin> a TVar is an IORef, but in a single thread right?
21:20:00 <YellowOnion> OH wait I see, TVar is never empty, meaning you can promise it'll never block.
21:51:46 <dmj`> infinisil: free monad could work, or make a binary instance of your AST
22:28:49 <nshepperd_> I think TVar (Maybe a) is a little different from TMVar a in that whether the Maybe is a Nothing or Just can be lazily determined "after" you insert it
22:29:21 <nshepperd_> Or you could put in _|_ and have it be neither empty nor full
22:29:48 <nshepperd_> Not sure if that makes any practical difference to anything though
22:45:16 <pavonia> Is there a parsing library that provides saving the current parser state, switching to another parser temporarily and continue using the first one afterwards?
22:51:45 <pavonia> I'm trying to write a line parser where each line tiggers different actions based on certain prefixes. One of these prefixes mean "source code", so all these lines should be treated as if they where a long line of code splitted across several lines. I'm not sure what parsing process would be best suited for this, because it's basically two different parsers interleaved
22:53:51 <Axman6> that sounds like how most parser libraries work
22:54:58 <Axman6> nshepperd_: yeah I was assuming that accesses would do things like retry on Nothing/Just for read/write
23:01:25 <pavonia> Axman6: Think of a parser combination like `string "begin" *> many command <* string "end"`. My problem is that the switch to the other parser can occur at every position in that parser, so I would have to store how much of that parser has already been processed. I don't know how that could be done using, say, parsec or megaparsec
23:45:55 <arahael> Why does `stack exec foo --help` show help for stack, and not for foo?
23:46:26 <jgt> arahael: I think you have to separate it out with some more double hyphens, no?
23:46:46 <jgt> I don't remember, but something like stack exec -- foo --help
23:47:14 <jgt> I'm basically just guessing though from fuzzy memory; haven't used stack in a long time
23:47:50 <arahael> jgt: That works, and makes sense, following the gnu standard, I like it - thanks!
23:48:17 <jgt> np
23:59:44 <arahael> I'm trying to use OptParse Applicative, however, the example refers to "metavariables", and doesn't explain what they mean.  What are metavariables?
