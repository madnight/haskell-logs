00:08:23 <ski> (hm .. or perhaps that was actually a tab, which under normal exchange rates can be traded for eight spaces ?)
00:10:14 <merijn> ski: That's not the normal exchange rate, though :p
00:10:28 <merijn> ski: The normal exchange rate is "move to nearest multiple of 8"
00:10:48 <merijn> Tabs are like the bitcoin of whitespace...highly volatile
00:12:13 <ski> merijn : well, that would depend on whether you'd trade it in on the spot, or wait until you reach a more fortunate position, no ?
00:13:11 <c0nd13> how many tabs does it take to the moon?
00:13:41 <ski> (i suppose it's interesting to note that it counts started tab columns, rather than completed ones)
00:14:10 <merijn> ski: So we're going long on tabs? >.>
00:14:21 <ski> c0nd13 : may depend on whose tab we're talking about ?
00:15:37 <ski> merijn : are there short tabbers, as well ?
00:17:11 <merijn> ski: Manually typing spaces and having your IDE convert to tabs?
00:19:43 * ski . o O ( "Because it is longer than the other qualification tabs, it is called the \"Long Tab\". Personnel who have earned it are nicknamed \"Long Tabbers\"." )
00:21:03 <c0nd13> . o 0 ( I wish I had a long tab )
00:21:50 <ski> we ought to standardize its semantics
00:23:55 <c0nd13> It's not the size of the tab that matters, but how you use it.
00:24:54 <MarcelineVQ> the trick is to act fast enough to take advantage of the pricing fluctuations between the placing of spaces
00:27:22 <dminuoso> MarcelineVQ: Or you could do insider spacing. Knowing where others put their spaces before anyone else does.
00:30:59 <ski> dminuoso, related to Banker's Method, with acumulated debt, rather than credit ?
00:33:28 <nshepperd_> Prescient spacing is tightly controlled by the guild
00:33:43 <nshepperd_> You won't get away with that
00:39:25 * ski disappears into no chamber
00:45:14 * hackage inspection-testing 0.4.2.1 - GHC plugin to do inspection testing  https://hackage.haskell.org/package/inspection-testing-0.4.2.1 (JoachimBreitner)
00:58:13 * hackage discrimination 0.4 - Fast generic linear-time sorting, joins and container construction.  https://hackage.haskell.org/package/discrimination-0.4 (EdwardKmett)
01:00:45 <dminuoso> ski: Okay I dont get that one.
01:01:33 <dminuoso> My initial instinct was that you were referring to the Banker's algorithm by Dijkstra, but I was unable to connect it to the topic.
01:06:25 <ski> i was thinking about Okasaki, but it was perhaps a stretch
01:23:31 * Axman6 is excited to see edwardk wokring on discrimination
01:24:02 <edwardk> mostly just a quick release because i needed it =)
01:24:12 <Axman6> yeah I figured :(
01:24:22 <edwardk> same kinda thing as the 'fixed' release earlier
01:24:27 <Axman6> Did you see my issue the other day?
01:24:35 <edwardk> er.. which one?
01:24:46 * edwardk has been up to his elbows in font code
01:24:53 <Axman6> about hashing having slightly surprising behaviour
01:25:07 <Axman6> it's not really surprising though
01:25:37 <edwardk> https://github.com/ekmett/discrimination/issues/19 ?
01:25:51 <Axman6> I wrote some code that had instance Grouping Text where group = hashing and it probably should have been hashing <> contramap toList grouping
01:26:18 <edwardk> yeah you generally want hashing <> grouping
01:26:54 <edwardk> i think the hashing docs say as much
01:27:43 <Axman6> ah yes, I misunderstood what the implications of that comment were
01:27:54 <edwardk> it could definitely use a big scary scream-at-the-user comment about how it doesn't fully discriminate on its own
01:28:08 <Axman6> yeah.
01:28:52 <edwardk> i was using discrimination in some linear time nearest neighbor example code for an implementation of smawk i wrote earlier
01:29:00 <edwardk> i wanted the thing to be truly linear time
01:30:33 <edwardk> i really just want it to minimize the sum of squares of the raggedness of my line-endings in the text formatting for codex
01:33:04 <Axman6> is hashing <> contramap Text.unpack grouping as sensible implementation for grouping for Text?
01:33:06 <edwardk> in other news, it is basically impossible to search for bidirectional pretty-printing, in the unicode bidi sense, as all the merged parsing/pretty printing library jump to the front of any search
01:33:37 <Axman6> sounds like it's time for a new library!
01:33:56 <edwardk> Axman6: it'd work. it'll scan more of the text than contramap Text.unpack grouping though
01:34:06 <edwardk> which only needs to touch the prefixes of the strings needed to compare
01:34:16 <edwardk> in general 'hashing' breaks the library guarantees
01:34:30 <edwardk> in that we no longer touch the minimum amount of the structure to discriminaate
01:34:45 <Axman6> yeah, I thought about that, and thought that one potential common use would be texts with long common prefixes
01:34:57 <Axman6> like URLs
01:35:17 <edwardk> yeah there, if you expect most of your hits to be near the end it'll be a huge win
01:35:38 <edwardk> if you expect on the other hand, to be given many novels worth of text, then you'll go way way way over
01:36:08 <Axman6> I also thought of doing something like contraMap (T.take 64) hashing <> contramap T.unpack grouping as a middle ground
01:36:09 <edwardk> because give two novels you'd expect only log novel count characters worth of distinct common prefix
01:36:48 <edwardk> that starts to sound like a sensible next step
01:36:54 <Axman6> though that still degrades in the long common prefix case
01:37:05 <edwardk> this would get a lot better in general if we did the burst-sort improvements on discrimination
01:37:25 <Axman6> contraMap (T.takeEnd 64) hashing <> contramap T.unpack grouping as a middle ground -- >_>
01:37:44 <Axman6> uh, s/as a middle ground//
01:38:17 <Axman6> burst-sort?
01:38:41 <edwardk> burst-sort is generally the fastest stringsort. and its built on the same sort of underpinnings as discrimination
01:38:47 <edwardk> discrimination needs two things to really be fast
01:38:51 <edwardk> and i just haven't done them
01:39:15 <edwardk> 1.) i need a linear-probing hash table with simple tabulation hashing. the ioref holding a hashmap isn't cutting it
01:39:23 <edwardk> and hashable is a terrible hash code
01:39:49 <edwardk> simple tabulation hashing can be implemented as say a linked list of small hash tables for how to hash each byte in sequence that you xor the results of
01:40:05 <Axman6> ah I';d also thought of using a trie to do this, glad I was on the right track
01:40:05 <edwardk> and just build that hash table chain as a lazy list that gets threaded through the 'serializer'
01:40:28 <edwardk> the second thing is this burst-trie stuff where we try to recover temporal coherence for cache access
01:40:37 <edwardk> right now top down radix sort is almost maximally bad
01:41:08 <edwardk> if on the other hand what you did was batch up in buckets until you got ~8192 things to distribute then you'd have coherence again for the distribution step
01:41:27 <edwardk> this is what (the first version of) burst sort did
01:41:33 <edwardk> so you'd now have two passes
01:42:12 <edwardk> pass one would be dumping things into these buckets, which fill like water balloons, as you drip contents into them, bursting if they get too full, and building a larger and larger prefix of the trie
01:42:37 <edwardk> then we take the trie that has leaf level buckets and walk that trie in order
01:43:04 <edwardk> and for each bucket we can use a more specialized sort, e.g. multikey quicksort or something can be used locally
01:43:32 <edwardk> this is the "right" version of discrimination
01:43:48 <Axman6> I look forward to seeing it =)
01:43:57 <edwardk> not anywhere near the top of my todo pile
01:44:02 <edwardk> if you want it, build it ;)
01:44:07 <edwardk> i'll happily help give pointers
01:44:40 <Axman6> yeah I figured. I don't have anough need for it at the moment, but would be interested in building it if I could
01:44:45 <edwardk> simple tabulation hashing + linear probing was proven basically optimal for this by mihai patrascu
01:45:39 <Axman6> I feel like I've nerdsniped myself now
01:48:38 <edwardk> =)
02:14:15 <yorick> is there a way to have warp kill my computation when the http connection disappears?
02:15:13 <merijn> yorick: (async) exceptions?
02:15:14 <dminuoso> yorick: check `setOnClose`
02:16:42 <dminuoso> In combination with what merijn said. :-)
02:17:44 * hackage tls-session-manager 0.0.1.0 - In-memory TLS session manager  https://hackage.haskell.org/package/tls-session-manager-0.0.1.0 (KazuYamamoto)
02:18:01 <yorick> dminuoso: merijn: thanks
02:18:40 <yorick> I think warp reuses the worker threads by default?
02:19:45 <yorick> also, it's not easy to get the worker thread id from setOnClose
02:21:07 <dminuoso> yorick: I guess you could maintain a pool of current running threads in some TVar?
02:24:08 <merijn> @hackage resource-pool
02:24:08 <lambdabot> http://hackage.haskell.org/package/resource-pool
02:24:14 <merijn> Don't roll your own :p
02:24:53 <dminuoso> merijn: Mmm. How would that help?
02:25:00 <dminuoso> merijn: That seems to do exactly the opposite..
02:25:18 <merijn> oh, wait, yeah I see what you mean
02:28:08 <dminuoso> resource-pool is my favourite example for what an abstraction should be. :)
03:42:43 * hackage typed-process 0.2.4.1 - Run external processes, with strong typing of streams  https://hackage.haskell.org/package/typed-process-0.2.4.1 (MichaelSnoyman)
03:43:49 <jgt> is it possible to see the currently authenticated user in a request log in Yesod? Or is this impossible because the request is logged before it hits the application and does authentication?
03:44:14 * hackage unliftio 0.2.11 - The MonadUnliftIO typeclass for unlifting monads to IO (batteries included)  https://hackage.haskell.org/package/unliftio-0.2.11 (MichaelSnoyman)
03:44:27 <Mo0O> Hi there
03:44:47 * jgt waves
03:45:01 <Mo0O> Do you know if it's possible to ignore null value when rendering json?
03:45:07 <Mo0O> Hi jgt :)
03:45:27 <Mo0O> I never used Yasod so I cannot help that much, sorry :$
03:46:36 <Rembane> Mo0O: Are you using Aeson?
03:46:44 <Mo0O> Rembane: yes
03:47:29 <Rembane> Mo0O: When you render, do you go from Datatype -> JSON ? 
03:48:05 <Mo0O> I've got some Maybe values, if it's Nothing it is rendered as null JSON value
03:48:24 <Rembane> What do you want it rendered as instead of null?
03:48:51 <Mo0O> I just what the field to not be present in the rendered JSON
03:49:03 <Mo0O> ignored
03:49:06 <Rembane> Got it. 
03:49:20 <Rembane> Lets see if Aeson has that option or if you have to take care of this manually.
03:50:12 <dminuoso> Mo0O: https://hackage.haskell.org/package/aeson-1.4.3.0/docs/Data-Aeson.html#t:Options
03:50:24 <dminuoso> Mo0O: In particular the `omitNothingFields`
03:50:24 <Rembane> Mo0O: You can omit Nothing fields. 
03:51:06 <dminuoso> You could have a wrapper and use deriving via to make this comfortable to use.
03:51:07 <Mo0O> Great :)
03:51:13 <dminuoso> (That way you wont have to write out the instances)
04:00:44 * hackage binary 0.8.7.0 - Binary serialisation for Haskell values using lazy ByteStrings  https://hackage.haskell.org/package/binary-0.8.7.0 (LennartKolmodin)
05:03:51 <cocreature> does aeson have an option to use (.:!) for Maybe fields in derived instance?
05:05:03 <cocreature> e.g., I have a field of type "foobar :: Maybe (Maybe Int)" and I would like a derived instance that parses "{ foobar = null }" as foobar = Just Nothing
05:06:50 <dminuoso> cocreature: Obvious question, why not write out the instance for that single type?
05:06:59 <cocreature> dminuoso: because there’s more than one type :)
05:07:40 <cocreature> and it’s not my library so was hoping for a small change rather than “here, I’ve replaced all derived instances in your lib by handwritten instances to fix a bug
05:07:42 <cocreature> ”
05:08:27 <merijn> cocreature: Define a newtype, with correct instance, use that + unwrapper?
05:09:21 <cocreature> hm that seems about as cumbersome as handwriting the instances.
05:10:12 <dminuoso> cocreature: well we had that topic just an hour ago or so.
05:10:22 <dminuoso> cocreature: Perhaps a newtype wrapper for deriving via would be nice.
05:10:30 <dminuoso> cocreature: No, with deriving via it would not be cumbersome.
05:10:55 <cocreature> given that aeson already has options for how Maybe it is handled, it seems quite reasonable to have an option for this as well.
05:11:08 <merijn> dminuoso: That assumes using DerivingVia is acceptable in the library
05:12:25 <cocreature> I guess the number of instances that I need to handwrite is still quite small in this case, so I’ll just go for that.
05:12:39 <dminuoso> Mmm, is there a way to do this combinatorically, where you can say deriving via and then pick the various aeson options and "combine" them somehow?
05:54:14 * hackage hprox 0.1.0 - a lightweight HTTP proxy server, and more  https://hackage.haskell.org/package/hprox-0.1.0 (BinJin)
05:59:48 <trebuh> a ²/spell setdict en
05:59:56 <trebuh> oups
06:19:43 * hackage dprox 0.1.0 - a lightweight DNS proxy server  https://hackage.haskell.org/package/dprox-0.1.0 (BinJin)
06:43:43 <lyxia> dminuoso: it's possible, just not currently implemented.
06:44:03 <lyxia> It's one of the examples in the deriving via paper, or in its repository.
07:33:14 * hackage psqueues 0.2.7.2 - Pure priority search queues  https://hackage.haskell.org/package/psqueues-0.2.7.2 (JasperVanDerJeugt)
07:47:05 <turion> Are there any effect systems that restrict to *Applicatives*? Because it seems to me that if you stack different applicative effects on each other, they always ought to commute. That means it's much easier to handle one effect from the stack, right?
07:47:40 <merijn> :t Compose
07:47:41 <lambdabot> error:
07:47:41 <lambdabot>     • Data constructor not in scope: Compose
07:47:41 <lambdabot>     • Perhaps you meant variable ‘icompose’ (imported from Control.Lens)
07:48:04 <merijn> turion: You don't need transformers for Applicative's, since as you said, they always stack anyway
07:48:16 <merijn> turion: You're probably looking for Data.Functor.Compose
07:48:43 <merijn> turion: Which is for, well, composing Functors and provides an Applicative for the result
07:49:15 <merijn> turion: You can probably write some mtl style classes based on that
07:49:21 <turion> merijn: There are some endofunctors in the category of Applicatives that are not composition with an Applicative, e.g. ListT (done right)
07:51:51 <turion> merijn: True, that should be possible. I'm wondering about this conundrum: Given two Applicatives f and g, Compose f g is an Applicative again. Then I can define liftF = fmap pure :: f a -> Compose f g a, and liftG = pure :: g a -> Compose f g a.
07:53:18 <turion> Now I'm claiming that liftF foo <*> liftG bar is morally the same as liftG bar <*> liftF foo.
07:55:07 <turion> As in, if I execute both effects "separately" in some sense, it will always be the same result
07:56:06 <turion> E.g. if both are State, I can do runState on f and g in any order, it will always give an isomorphic result in the end. This wouldn't be the case if I'd allow Monads.
07:57:18 <turion> But I don't understand how to make this precise. E.g. if both are the same state type, and I simply join the effects, the order clearly matters
07:58:17 <turion> merijn: I was talking about this earlier: https://stackoverflow.com/questions/37761078/are-applicative-transformers-really-superfluous
08:07:05 <typetetris> Is there an option for ghc so it stops emitting those `.ghc.environment.*` files ?
08:07:32 <merijn> typetetris: There's an option in cabal to stop generating those, yes
08:07:38 <merijn> Don't ask me what it is, though :p
08:09:04 <d34df00d> Let's say I have a function that has several patterns on the left that translate into (syntactically) same expression on the right.
08:09:11 <d34df00d> Is there an extension that allows me to write the RHS just once?
08:10:19 <merijn> d34df00d: You can use case-of instead of directly pattern matching and then define the right hand in a where clause
08:10:50 <d34df00d> merijn: it's not entirely obvious to me, how would it look?
08:10:56 <d34df00d> If the RHS depens on the stuff matched on the left.
08:14:35 <merijn> d34df00d: Then it becomes trickier...you can simply define the RHS as a function and take the relevant arguments after pattern matching
08:15:30 <d34df00d> Probably not worth it in this case... Consider RB tree balancing routine, where there are like four patterns all of the form
08:15:32 <d34df00d> balance B (Node R (Node R t1 e1 t2) e2 t3) e3 t4 = Node R (Node B t1 e1 t2) e2 (Node B t3 e3 t4)
08:15:39 <d34df00d> It's just the LHS that changes.
08:15:58 <merijn> d34df00d: "case foo of Foo a b c -> doStuff a >> otherStuff b >> moreStuff c" can easily be turned into "case foo of Foo a b c -> myRHS a b c" "myRHS a b c = someStuff a >> otherStuff b >> moreStuff c"
08:16:23 <d34df00d> Would supporting some syntactic sugar for this  be GHC extension-worthy?
08:16:28 <d34df00d> I know some ML dialects support this.
08:17:12 <merijn> d34df00d: tbh I dislike the recent trend of adding a million tiny syntax extensions unless there's a REALLY compelling case for them
08:17:43 <merijn> So while I empathise with this code being a bit annoying, I think it's not annoying enough to add yet another syntax extension :)
08:49:46 <hjozwiak> What is the Haskell equivellent in unicode for ==? I tried <interactive>:142:3: error: Variable not in scope: (≡) :: Integer -> Integer -> t
08:50:13 <hjozwiak>  2 ≡ 2
08:52:30 <berndl> hjozwiak: there isn't any.
08:52:31 <Taneb> hjozwiak: == is a function, not syntax, so you'd need to import a different library
08:52:56 <d34df00d> Ok, I have what seems to be a GADTs question.
08:52:58 <Taneb> hjozwiak: there's the base-unicode-symbols package which defines (≡)
08:53:39 <d34df00d> I'm working with a library that defines records representing SQL tables in the form of records like `data PostFlag f = PostFlag { post :: TableField f Int SqlInt4 NN Req, flag :: TableField f String SqlText NN Req }`
08:53:52 <d34df00d> Now I want to define a data type that encapsulates "set this field to this value".
08:54:41 <d34df00d> Something like `data UpdateField tableRec where UpdateField :: valTy -> (tableRec f -> TableField f valTy sqlTy n r) -> UpdateField tableRec` seems reasonable.
08:55:05 <d34df00d> But it fails to typecheck, since the underlying TableField type family is not injective, so the compiler can't seemingly match sqlTy, n and r.
08:55:09 <d34df00d> How do I solve this?
08:55:46 <d34df00d> To be precise, the error is
08:55:51 <d34df00d> https://bpaste.net/show/892a0340d619
08:56:39 <d34df00d> I'm also not so sure I actually understand the error.
08:57:40 <hyperisco> d34df00d, I know almost nothing here, but perhaps you need a type annotation, or ScopedTypeVariables, or you need to pattern match something.
08:58:39 <d34df00d> hyperisco: I'm not sure I have anything that could be pattern matched on in the GADT definition.
08:59:02 <d34df00d> And I also tried explicilty quantifying sqlTy, n and r via forall (and now also with ScopedTypeVariables enabled after your suggestion) — no luck.
08:59:29 <d34df00d> What exactly is ambiguous in this case anyway?
08:59:33 <hyperisco> GADTs are all about pattern matching.
08:59:58 <d34df00d> hyperisco: but not at type definition point, right?
09:00:07 <hyperisco> I don't know what that means
09:00:31 <d34df00d> Yay AllowAmbiguousTypes actually helps... I wonder how will it explode and where.
09:00:50 <hyperisco> It will probably explode if you try and use your definition anywhere.
09:01:06 <d34df00d> Crap, I'm far from that still.
09:03:32 <hyperisco> I don't know anything about this library. However, the simplest fix if you're defining a GADT is to add the ambiguous types as parameters.
09:04:20 <d34df00d> This is probably not what I want.
09:04:45 <d34df00d> The type only cares about the table that it updates, not the specific SQL types of the fields in question.
09:04:48 <hyperisco> data UpdateField tableRec f where …  perhaps?
09:05:04 <d34df00d> I could probably wrap that into another GADT later on... But that seems ugly.
09:06:07 <hyperisco> What functional dependency does TableField have?
09:06:12 <d34df00d> Hmm, why do I need the selector function at all anyway? I could achieve the same effect by just having (tableRec f -> tableRec f) stored.
09:06:42 <d34df00d> hyperisco: it has none if I"m not mistaken.
09:06:57 <hyperisco> Then you need everything as a type parameter
09:06:59 <d34df00d> And it's indeed not injective. Several different sqlTy, n or r can correspond to every other parameter.
09:07:31 <d34df00d> hyperisco: but I fail to see why on the type theory level. Why isn't the type checker happy to accept what I've written above even without any fundeps?
09:07:38 <d34df00d> Or injectivity. Or what not.
09:08:07 <hyperisco> When you pattern match UpdateField, it has to determine what the types are
09:08:38 <d34df00d> But why doesn't it complain about valTy then?
09:08:40 <hyperisco> Given  TableField f valTy sqlTy n r  how is it to figure out what  f, valTy, sqlTy, n, and r  are?
09:08:53 <hyperisco> I am guessing because knowing  TableField f valTy sqlTy n r  determines  valTy
09:09:07 <d34df00d> Nope, not really, there are conflicting instances in this sense.
09:09:25 <d34df00d> And, moreover, how does type erasure work then? I can have `data Useless where MkUseless :: a -> Useless`, can I?
09:10:36 <hyperisco> How about we see what the definition of TableField is
09:11:25 <d34df00d> You will regret that.
09:11:27 <d34df00d> https://bpaste.net/show/faef3a9f89e9
09:11:37 <d34df00d> I'm not brave enough to go deeper.
09:13:54 <hyperisco> Oh, it is just doing lambda calculus at a type level, of course
09:15:24 <d34df00d> Ok, `data UpdateField tableRec where UpdateField valTy -> (tableRec f1 -> tableRec f2) -> UpdateField tableRec` is making the type checker perfectly happy as well.
09:15:51 <d34df00d> I don't know anything anymore. I don't know GADTs, I don't know haskell, I'd rather spend the rest of my life gardening.
09:16:35 <hyperisco> If you are using a type family it has to figure out the types, and if it isn't injective then it just means it can't infer backwards
09:16:54 <d34df00d> Ah.
09:17:01 <d34df00d> So let me spell this out loud.
09:17:17 <d34df00d> It needs to figure out the arguments to the type family to figure out what the RHS of my function is.
09:17:20 <d34df00d> Right?
09:17:34 <hyperisco> That's right
09:17:44 <d34df00d> And it does _not_ need to do this for the (tableRec f1 -> tableRec f2) part above because... why?
09:19:21 <hyperisco> There's no type family there is there?
09:19:29 <d34df00d> Nope, tableRec :: k -> *
09:19:50 <d34df00d> But, uh, doesn't it need to know f1 and f2 to figure out the exact type of the function?
09:20:00 <d34df00d> Or is it perfectly happy with the literal tableRec f1 and tableRec f2?
09:20:16 <hyperisco> Let me explain this again
09:20:34 <hyperisco> Type families want to go away, they need to get reduced to a type
09:20:51 <hyperisco> They can only do this if all the parameters are known well enough
09:21:32 <d34df00d> This is something I guess I understand yes.
09:21:39 <hyperisco> We aren't worried about this with just types
09:22:02 <d34df00d> But "just type" is something of the kind * (if we're talking about types in the context of terms).
09:22:05 <d34df00d> Right?
09:22:13 <d34df00d> So we'd need to reduce a type ctor to a type, don't we?
09:22:19 <hyperisco> Don't get distracted by what ghci tells you. It lies.
09:22:39 <d34df00d> Or, know the specific arguments to the type ctor, to be precise.
09:23:01 <d34df00d> ghci tells me nothing now, it's too happy with my current definitions, but I don't understand why anymore :*
09:23:02 <d34df00d> :(
09:24:10 <hyperisco> There are "Types" and there are "types".
09:24:49 <hyperisco> Types have kind Type, types have kinds. No one seems particularly consistent on making the distinction.
09:25:04 <hyperisco> A type family is not a type.
09:25:11 <hyperisco> Why? Because a type family does not have a kind.
09:25:27 <hyperisco> "But ghci tells me what the kind is!" Yes, well that is what I meant by ghci lies.
09:25:42 <hyperisco> It'll also tell you a kind for type aliases, and those aren't types either.
09:26:28 <hyperisco> ghci does this because nonetheless it informs you what parameters are appropriate
09:26:41 <d34df00d> I still fail to build a consistent picture (that's also in line with what I know about type theory and CoC), but I guess that's just something I'll have to get over in case of haskell.
09:27:16 <hyperisco> d34df00d,  (->)  is only defined on Types. How about that? And a type family is not a Type, so we must get rid of it.
09:27:44 <hyperisco> tableRec f  is a Type, so we're happy.
09:27:55 <d34df00d> It's a type only if you know f, right?
09:28:18 <d34df00d> One thing would be `UpdateField :: (forall f1 f2. tableRec f1 -> tableRec f2) -> UpdateField tableRec`
09:28:20 <d34df00d> This I understand.
09:28:25 <hyperisco> If  tableRec :: K -> Type  and  f :: K  then  tableRec f :: Type
09:28:37 <d34df00d> `UpdateField :: forall f1 f2. (tableRec f1 -> tableRec f2) -> UpdateField tableRec` I do not understand.
09:28:56 <d34df00d> hyperisco: but you don't know the specific f!
09:29:16 <hyperisco> so what
09:32:26 <hyperisco> d34df00d, for every f, tableRec f is a Type, so it doesn't matter.
09:33:07 <hyperisco> If pattern match on UpdateField we'll never learn what f actually is, and that is okay.
09:34:47 <Rakete1111> what does 1 % 2 do? Apparently it's a fraction, is this correct? Because I can't print the result (infinite loop) in ghci. :m +Data.Ratio doesn't help
09:35:15 <d34df00d> Hmm.
09:35:25 <d34df00d> hyperisco: so if I do the reduction myself, that's gonna be fine?
09:35:31 <d34df00d> In the type families case.
09:35:43 * hackage rg 1.3.0.0 - A dynamic/unbounded alternative to Bounded Enum  https://hackage.haskell.org/package/rg-1.3.0.0 (ChrisDornan)
09:35:49 <hyperisco> Well you literally can't if the types are ambiguous, heh.
09:35:57 <d34df00d> Like writing UpdateField :: valTy -> (tableRec f1 -> valTy) -> (valTy -> tableRec f2) -> UpdateField tableRec or something.
09:36:14 <d34df00d> It just means I don't care what are the specific n, r and sqlTy in that TF.
09:36:22 <d34df00d> I only care what Haskell type can I get from it.
09:36:41 <d34df00d> It just means I'm doing the type family reduction at the point where I create the UpdateField.
09:36:43 <d34df00d> Sorta.
09:36:44 <solonarv> Rakete1111: there is certainly a '%' defined in Data.Ratio, and it is used for constructing rations (as in: rational numbers)
09:36:47 <solonarv> > 3 % 5
09:36:49 <lambdabot>  3 % 5
09:36:54 <hyperisco> If that works then go for it.
09:36:56 <d34df00d> Also profunctors.
09:37:05 <d34df00d> Lurk. Somewhere. Here.
09:38:07 <hyperisco> I am not sure why you're inclined to use this library if it is this complicated for you. I think it would be complicated for me too. I would need some strong motivation to accept a library that does type level lambda calculus.
09:38:33 <Rakete1111> solonarv: Why can't I use it? or why doesn't it work for me?
09:39:13 <d34df00d> hyperisco: well, the library itself is kinda neat. What I'm trying to do right now is separating some of the business logic from some of the SQL. I'm scraping a web page and I want to figure out what has been changed and what effects does it have on my DB.
09:39:30 <d34df00d> UpdateField is precisely just recording an effect on a single column.
09:39:55 <d34df00d> Frankly, I'm just playing around and learning, so I'm happy it's complicated :)
09:40:12 <hyperisco> Does it implement incremental relational queries?
09:40:18 <d34df00d> What's "incremental"?
09:40:37 <hyperisco> It means if the data changes a bit the result of the query changes a bit
09:41:09 <hyperisco> The objective being to do that without rerunning the whole query
09:41:20 <d34df00d> Ah. I guess it doesn't.
09:42:52 <hyperisco> opaleye: An SQL-generating DSL targeting PostgreSQL
09:45:06 <hyperisco> I approached this in the past by greatly limiting which sorts of queries I was interested in
09:45:18 <hyperisco> so I didn't need such an elaborate DSL
09:45:44 <hyperisco> I am wondering how well this copes with extensions
09:45:56 <d34df00d> Well... You can always run raw SQL.
09:46:21 <d34df00d> I wasn't able to do something like `select foo from values(1, 2, 3) where foo in (select distinct id from table)`, for instance.
09:46:38 <d34df00d> No big deal, I can do that in haskell: https://github.com/0xd34df00d/cohabr/blob/master/src/Cohabr/Db/Queries.hs#L25
09:46:52 <hyperisco> That doesn't seem like a valid query to me
09:47:13 <d34df00d> Well, I'm not an sql pro really.
09:47:17 <d34df00d> But I hope it communicates the idea.
09:57:21 <zeta_0> i have cabal-new-repl process setup up good but when i try to setup ghci process it loads with M-x run-haskell but the keybinding M-` is not working? https://hastebin.com/emamalezoy.sql
10:02:55 <zeta_0> when i add (setq haskell-process-type 'ghci), M-x run-haskell works but the keybinding M-` still does not work so how do i set the keybinding in use-package in that piece of code?
10:10:23 <zeta_0> C-c C-l loads .hs file using cabal-new-repl but when i press C-` ghci does not get loaded(i have to run M-x run-haskell to load ghci)?
10:12:19 <fendor> how can i view the haddock documentation that has been built from a project?
10:12:26 <fendor> with cabal, btw
10:21:26 <d34df00d> hyperisco: so I got to actually use that type finally.
10:21:40 <d34df00d> Unsurprisingly the compiler cannot derive f1/f2 in my case :)
10:47:36 <dmwit> fendor: It will print out the location of an index.html that you may open in your browser.
10:47:54 <fendor> dmwit, thanks! 
10:48:41 <dmwit> fendor: If you're talking about a library that you already installed, you can poke around in .cabal/share/doc
10:48:56 <dmwit> Dunno how that works with the v2-* stuff though.
10:49:12 <fendor> probably similar. 
10:49:19 <fendor> i mainly wanted to see if i got the haddock right
11:06:06 <akr> Hi! Can someone tell me if there's a semantic difference between force and force' here: https://pastebin.com/raw/7K70BWP9 ?
11:06:33 <akr> I mean force should desugar to force', right
11:06:53 <akr> hmm not exactly though
11:07:16 <akr> it will desugar to ` x >>= evaluate . rdeepseq >>= \_ -> x` I guess
11:09:54 <dmwit> Well those definitely can't mean the same thing. But let me read again closely, after mentally substituting `x` for `return x` in the first one.
11:10:27 <akr> oh yeah, sorry about that
11:10:37 <dmwit> Yes, I think they mean the same thing after that substitution. But I very much doubt either of them mean what you want them to mean.
11:11:01 <dmwit> I suspect what you actually want is `force x = do { y <- x; evaluate (rdeepseq y); return y }`.
11:11:50 <akr> what problem does the original definition of force have?
11:12:02 <dmwit> Your force runs x twice, and doesn't actually deepseq the value it "returns" after the second execution.
11:12:37 <akr> ahh I see
11:12:48 <akr> thanks a lot :)
11:14:25 <dmwit> e.g. try `ref <- newIORef (); force (do { v <- readIORef ref; putStrLn "yikes!"; writeIORef ref undefined; return v }); return ()`. You will see `yikes!` printed twice but no exception.
11:15:53 <akr> yup, that's right
11:36:06 <argent0> Hi, is there a way to rebuild all packages (including dependencies) with cabal?
11:45:10 <dmwit> argent0: Not really. Can you say a bit more about why you want to do that?
11:45:47 <dmwit> (N.B. I'm not saying you don't want it. Just that the alternatives/workarounds differ based on why you want it.)
11:48:44 * hackage vulkan-api 1.2.0.0 - Low-level low-overhead vulkan api bindings  https://hackage.haskell.org/package/vulkan-api-1.2.0.0 (achirkin)
11:49:44 * hackage dimensions 2.0.0.0 - Safe type-level dimensionality for multidimensional data.  https://hackage.haskell.org/package/dimensions-2.0.0.0 (achirkin)
11:50:43 * hackage easytensor 2.0.0.0 - Pure, type-indexed haskell vector, matrix, and tensor library.  https://hackage.haskell.org/package/easytensor-2.0.0.0 (achirkin)
11:51:03 <argent0> dmwit: I'm getting '<command line>: can't load .so/.DLL for: libz.so (libz.so: cannot open shared object file: No such file or directory)'. I'm using nix. I believe I have built something linking with the wrong file. Can cabal be used without nix now? (I've cabal on top of nix on top of archlinux. With pkg-config thrown in the mix. So many things can go wrong :()
11:51:55 <d34df00d> Is there any newtype over functions of the form a -> a with a Monoid instance with the obvious compositional semantics??
11:52:55 <d34df00d> Ah, right, Endo.
11:52:58 <d34df00d> Didn't see it as obvious.
11:53:13 * hackage easytensor-vulkan 2.0.0.0 - Use easytensor with vulkan-api.  https://hackage.haskell.org/package/easytensor-vulkan-2.0.0.0 (achirkin)
12:06:26 * argent0 the problem "goes away" if i comment lines like `makeLenses' Foo`
12:06:35 <fendor> what is the way to deal with threaded output in haskell? using the `say` package? 
12:07:45 <fendor> also, what may be a reason that `writeChan` does not return? The message I send can be printed
12:08:06 <fendor> maybe printing does not imply that I can send it?
12:08:15 <boj> fendor: am not familiar with the say package, but that sounds like a job for stm?
12:08:46 <fendor> boj, i mean printing, since side effects that can not be retried, are most likely not the right job for stm, rightß
12:08:50 <fendor> ?
12:08:57 <fendor> outed my keyboard layout
12:09:16 <boj> are you trying to use `print` directly? that might not work as expected
12:09:47 <boj> depending how lazy your code is it may never get called
12:10:45 <boj> if you are print debugging Debug.Trace would be ideal there
12:10:46 <fendor> yes, i want to print multiple lines that are not garbled. E.g. they should just lock the handle in linebuffering mode
12:11:20 <boj> hard to give a good answer without really understanding the problem
12:12:27 <fendor> two threads that print a line. Normally, the scheduler decides in which order the threads output a single character
12:14:22 <solonarv> fendor: ah, a fellow German?
12:15:13 <fendor> austrian to be precise, but yes
12:16:52 <solonarv> you can write something like: getPrint :: IO (String -> IO ()); getPrint = do lock <- newMVar (); return $ \str -> withMVar $ \_ -> putStr str
12:17:28 <solonarv> usage: write 'safePutStr <- getPrint' somewhere, and then pass this 'safePutStr' to everything that needs to print to stdout
12:17:47 <fendor> that sounds like the easiest way without pulling more libs in, thanks!
12:20:10 <solonarv> if you're writing some sort of REPL, you might be interested in haskeline, which provides a 'getExternalPrint' function that works similarly but also doesn't disrupt the prompt/user input
12:21:14 <fendor> it is just debugging of some issue with lsp-test on windows. just sprinkling in the good old prints
12:39:47 <dmwit> ?tell argent0 Huh. Do you definitely have a suitable libz.so around? Perhaps your nix derivation (?) needs to mention that it demands libz be installed.
12:39:47 <lambdabot> Consider it noted.
12:40:12 <dmwit> fendor: The usual way is to have a single thread be the one dedicated to printing. Anything else that wants to thread sends it a message saying what it wants printed.
12:41:05 <dmwit> msgs <- newChan; forkIO (forever (readChan msgs >>= putStrLn)) -- or similar
12:41:13 <fendor> dmwit, that sounds really inconvenient, is there a lib to do that?
12:41:20 <fendor> sounds like logging deamon
12:41:27 <fendor> which makes sense, when I say it like that
12:41:32 <merijn> monad-logger ? :p
12:41:54 <dmwit> Do you need a library? It's literally one line of code.
12:42:02 <fendor> so, the recommended way is a logger... now I feel stupid :)
12:42:22 <fendor> it is not just one line of code, since I'd have to pass the chan everywhere, right?
12:42:36 <dmwit> (Up to niggles about the possibility of sending messages with embedded exceptions, but like... maybe don't do that?)
12:42:43 <merijn> monad-logger is nice in that you can easily drop-in/replace the implementation later
12:43:18 <dmwit> Of course. You're going to have to pass *something* around for sure no matter what approach you use.
12:43:29 <merijn> fendor: monad-logger has an implementation with a logging channel that takes care of that for you
12:44:01 <dmwit> (How you gonna coordinate two threads without having some shared lock between them?)
12:44:13 <dmwit> (And how you gonna have a shared lock without having passed it to both threads?)
12:44:45 <fendor> well, `say` does it too, somehow?
12:45:00 <merijn> fendor: What's "say"?
12:45:08 <fendor> a package
12:45:10 <fendor> @hoogle say
12:45:11 <lambdabot> package say
12:45:11 <lambdabot> Say say :: MonadIO m => Text -> m ()
12:45:11 <lambdabot> module Say
12:45:11 <dmwit> fendor: No it doesn't?
12:45:29 <dmwit> fendor: "If larger messages are used, it is possible for interleaving with other threads to occur." from the very first line of the documentation
12:45:52 <fendor> ok, yes
12:46:02 <fendor> in this case, I just want to print lines without interleaving
12:46:15 <fendor> but I understand, that in general, your approach is way the way to go
12:46:34 <fendor> s/your/this
12:46:44 <d34df00d> How ugly is this? https://github.com/0xd34df00d/cohabr/blob/master/src/Habr/Diff.hs#L51-L61
12:46:47 <d34df00d> I wanted to have a kinda-polymorphic Lens here since the field is actually a type family instantiated with different types within the same function.
12:47:01 <d34df00d> I don't like AllowAmbiguousTypes and explicit type application.
12:48:24 <d34df00d> Is it not worth the effort, and should I just inline produceUpdateField where necessary, updating the record explicitly (in the argument to UpdateField)?
12:49:39 <dmwit> d34df00d: You might like this trick: produceUpdateField acc parsed = [UpdateField (...) | storedPost ^. acc == Just parsed]
12:49:48 <dmwit> d34df00d: (and then change `catMaybes` to `concat`)
12:50:15 <d34df00d> Oh, that's nice!
12:50:27 <d34df00d> dmwit: what do you think about the types and the signature of produceUpdateField?
12:50:41 <dmwit> They make my eyes bleed.
12:50:46 <d34df00d> Mine too.
12:50:51 <d34df00d> I wonder if something can be done to them.
12:50:57 <d34df00d> Otherwise this whole function is pointless.
12:51:10 <d34df00d> But I really don't want to duplicate this logic 4-6-10 times.
12:52:16 <dmwit> You could use the ALens+cloneLens trick. But I think I prefer my eyes to bleed to that.
12:52:42 <d34df00d> I'm not sure I even know what's that trick.
12:53:34 <dmwit> Oh, I misread!
12:54:00 <dmwit> Do you really use `acc` with two different choices of `f` in the body of `produceUpdateField`?
12:54:07 <d34df00d> Basically the problem is that storedPost is P.Post H, while UpdateField gets P.Post O.
12:54:11 <d34df00d> dmwit: yes.
12:54:21 <cocreature> the trick is to you clone dmwit sufficiently often, that there will be enough dmwit’s to fix all of your problems
12:54:21 <d34df00d> So f is different as the argument to P.Post.
12:56:32 <d34df00d> cocreature: that's a nice trick! I wish it was more well-knwon!
12:56:33 <dmwit> (Does record wildcards work for all record updates? Can I write both `Foo {..}` to mean "construct `Foo` with the fields that are in scope" and `foo {..}` to mean "update just the fields of `foo` that have names in scope?)
12:56:54 <dmwit> s/?/"?/
12:57:07 <d34df00d> Hmm, good question. Let me try.
12:57:16 <dmwit> no no
12:57:24 <dmwit> It won't help you. It was just some side speculation.
12:57:45 <d34df00d> Oh.
12:57:45 <ski> > let n = Node False []; rootLabel = True; subForest = () in n {..}
12:57:47 <lambdabot>  <hint>:1:60: error: You cannot use `..' in a record update
12:57:54 <d34df00d> Yep, I cannot pass the name of the field anyway.
12:58:04 <dmwit> ski: phew
12:58:05 <d34df00d> (unless TH, which is probably still worse than this signature)
12:58:15 <solonarv> oh, that's a very clear error message!
12:58:54 <dmwit> ?let data Wow = W { ow :: Int } | O { uchy :: String }
12:58:55 <lambdabot>  Defined.
12:59:03 <cocreature> -fpleaseletmeuserecordwildcardsinupdates
12:59:12 <dmwit> > W 3 { uchy = "whoa" }
12:59:14 <lambdabot>  error:
12:59:14 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘Wow’
12:59:14 <lambdabot>      • In the first argument of ‘W’, namely ‘3 {uchy = "whoa"}’
12:59:24 <dmwit> > (W 3) { uchy = "whoa" }
12:59:26 <lambdabot>  error:
12:59:26 <lambdabot>      • No instance for (Show Wow)
12:59:26 <lambdabot>          arising from a use of ‘show_M157728066482063040331348’
12:59:40 <dmwit> I'm dying of laughter over here.
13:00:01 <ski> % :set -fpleaseletmeuserecordwildcardsinupdates
13:00:01 <yahb> ski: Some flags have not been recognized: -fpleaseletmeuserecordwildcardsinupdates
13:00:14 <ski> seems yahb is running a too early version
13:00:17 <cocreature> disappointing!
13:00:22 <dmwit> Anyway it throws an exception, which seems about as sensible a behavior as I could imagine.
13:01:30 <ski> @let deriving instance Show Wow
13:01:31 <lambdabot>  Defined.
13:01:35 <ski> > (W 3) { uchy = "whoa" }
13:01:38 <lambdabot>  *Exception: <interactive>:3:1-23: Non-exhaustive patterns in record update
13:01:54 <dmwit> Anyway I suspect this kind of oddity is why .. isn't allowed in record update.
13:02:31 <ski> yea, the whole record syntax thing is odd
13:05:15 <d34df00d> I also wonder if lifting this to something like a type class or type family makes sense.
13:05:33 <d34df00d> The behaviour shall be different depending on whether the lens returns `TableField f a ty N Req` or `TableField f a ty NN Req`.
13:05:35 <dmwit> Is there prior art for the name pretext being what it is in lens?
13:06:05 <hyperisco> Perl?
13:06:47 <dmwit> X Doubt
13:08:17 <d34df00d> And I still don't understand why the typechecker can't just unify ty0 and SqlInt4 here:
13:08:20 <d34df00d> https://bpaste.net/show/48a0c43085a6
13:08:44 <d34df00d> It really has all the required information anyway, it seems like.
13:09:33 <dmwit> What it can't do is guarantee that SqlInt4 is the only choice for ty0 that makes those two types unify.
13:10:07 <dmwit> If you have a class constraint that mentions ty0, this choice can affect the actual runtime behavior of the code.
13:10:12 <d34df00d> ...and that's because it's a type family, so potentially different ty0's can map onto the type that happens to be here?
13:10:17 <dmwit> So it cowardly refuses to make an arbitrary choice that could affect the runtime behavior.
13:10:22 <dmwit> right
13:10:54 <d34df00d> So in reality the unifier already has a specific type, but it has sufficient info to track it back to the type family and produce a reasonable error message?
13:11:00 <dmwit> ?quote dmwit type.*famil
13:11:00 <lambdabot> dmwit says: Type families are not injective. Your first three inscrutable error messages with type families in them will be because you don't understand this rule.
13:11:27 <monochrom> haha
13:11:44 <d34df00d> If that's not the case then I still don't understand.
13:12:06 <monochrom> Mine would be: extensible, inferrable, sound --- pick two.
13:15:44 <dmwit> d34df00d: I think in reality the unifier does not already have a specific type.
13:16:13 <dmwit> A appears to have clauses that require the unifier to know f before it can reduce.
13:16:22 <dmwit> (From my glances at the opaleye docs.)
13:17:10 <d34df00d> Sooo... does this mean that, technically the unifier could potentially assume ty = SqlInt4?
13:17:12 <d34df00d> ty0
13:17:29 <dmwit> That would be a correct unification, but not a most general one.
13:17:31 <d34df00d> Since it operates in terms of type families now, not the types they map onto.
13:18:31 <dmwit> (That is, if you *told* it that ty0 = SqlInt4, it would accept your claim. But it won't make that choice itself because there may be other choices that you could make.)
13:18:58 <d34df00d> Yeah, this is what happens when I do @SqlInt4.
13:19:20 <d34df00d> I guess if I want to go deeper I'll have to actually read the theory behind this specific unification algorithm and type families as in haskell.
13:19:36 <dmwit> I think you don't need to learn much.
13:19:57 <dmwit> In short: when F is a type family, knowing `F a ~ F b` simply does not imply that `a ~ b`.
13:20:11 <dmwit> (This is an unfolding of the definition of injective in the sentence "F is not injective".)
13:20:14 <d34df00d> Yep, for non-injective type families I understand this.
13:20:17 <hyperisco> d34df00d, it can't unify because it is not injective. We went over that remember?
13:20:55 <d34df00d> hyperisco: yep. From dmwit's message above I derived that it tries to unify before knowing what a specific `f` in my type is.
13:21:06 <d34df00d> At this point it still has type families.
13:21:34 <dmwit> d34df00d: Okay. So define `type Foo f x = A f (TC ((Int, x, N), Req))`. Now apply your knowledge: the unifier has determined that `Foo f Int ~ Foo f ty0`. But from that it simply cannot determine that `Int ~ ty0` because that ain't necessarily true.
13:22:44 <d34df00d> Damn.
13:22:50 <d34df00d> I see the fallacy in my argument now.
13:22:52 <d34df00d> Thanks!
13:23:17 <dmwit> Wow, great!
13:23:30 <d34df00d> Going back to my original question, I guess I'll stick with the abomination I currently have. Still better than TH or duplication.
13:23:35 <dmwit> I... wasn't really expecting that to help, but to be the start of a discussion. I'm glad to be surprised in this way!
13:24:08 <d34df00d> dmwit: I've derived too much from "it has to know something about f to proceed".
13:24:13 <d34df00d> Wishful thinking, sorta.
13:24:50 <dmwit> Ah. That was something of a red herring, yeah. Sorry. Leftover from a bit of confusion in my mind about the definition of A that I cleared up by looking at the documentation but hadn't yet internalized properly.
13:25:10 <d34df00d> I wonder if this type family can be made in fact injective.
13:25:20 <d34df00d> But that'd require me to go through opaleye sources.
13:25:26 <d34df00d> Which I'd rather not.
13:25:34 <hyperisco> You can't retroactively do that
13:25:45 <d34df00d> hyperisco: why?
13:26:02 <dmwit> d34df00d: I really doubt it.
13:26:10 <dmwit> It seems to encode an SKI calculus at the type level!
13:26:21 <hyperisco> Yeah I also noticed that.
13:26:24 <d34df00d> Lol, hyperisco's reaction was similar.
13:26:26 <d34df00d> Yea.
13:26:27 <dmwit> That makes just about every stupid thing you might want to do completely undecidable.
13:27:54 <hyperisco> d34df00d, because the injectivity is part of the definition of the family. Otherwise, any noninjective instance can be made.
13:28:12 <d34df00d> hyperisco: I mean, does it make sense from the problem domain point of view.
13:28:19 <hyperisco> No clue.
13:28:24 <monochrom> . o O ( Those who give up type inference for type-level computing should deserver...? )
13:28:49 <d34df00d> Yeah, that's why I'd have to go through the sources or, at least, the existing instances to figure out.
13:29:10 <d34df00d> Cool library otherwise.
13:29:15 <d34df00d> Makes me ask a lot of stupid questions.
13:29:46 <dmwit> Anyway, here's a concrete counterexample to injectivity: `A (H HT) (C (True, True, NN)) ~ A (H HT) (C (True, False, NN))`
13:30:16 <hyperisco> I think it says something about the sanity of fully featured SQL DSLs
13:30:35 <d34df00d> I have an SQL DSL in C++.
13:30:38 <d34df00d> It's nice.
13:30:43 * ski is not a calculus
13:30:44 <d34df00d> Probably because I wrote it lol.
13:30:51 * dmwit is not a number
13:30:59 <monochrom> Does "fully featured" include stored procedures?
13:31:17 <d34df00d> Not that fully featured, but it's a matter of syntax.
13:31:18 <hyperisco> No because that uses a different language called PL/SQL
13:31:28 <monochrom> Ah OK.
13:31:29 <d34df00d> Which is painful in C++, so I'm lazy evaulating writing missing parts.
13:31:56 <hyperisco> Or I think in Postgres you can also use Python.
13:32:00 <monochrom> But sanity is inversely proportional to how many invariants you shoehorn into Haskell types.
13:32:10 <ski> (see <http://lambda-the-ultimate.org/node/533#comment-7712>)
13:32:24 <d34df00d> I wish this stuff was done in Idris or something.
13:32:26 <dmwit> monochrom: That can't be right. There must be some sort of bathtub curve thing going on.
13:32:27 <monochrom> which means it is not about SQL or fully featured, but type craze.
13:32:56 <hyperisco> ski, if someone could clearly delineate algebras from calculi from other mathematical incarnations then I'd try harder to use the correct term
13:33:04 <dmwit> monochrom: Or else Dynamic would be the sanest thing to use for everything! =D
13:33:04 <davean> hyperisco: you can use a lot of things. Stored procedures are a language, but not specifed which
13:33:11 <davean> hyperisco: you can also use scheme and a few others
13:33:21 <ski> hyperisco : did you see the comment ?
13:33:46 <hyperisco> davean, what do you mean it isn't specified? The Python support is a special extension
13:34:07 <ski> (quoting Haskell B. Curry, none the less !)
13:34:44 <hyperisco> I dunno maybe we're mixing specs like SQL from specific vendors like Postgres
13:35:03 <hyperisco> Guess that's PSQL or w/e? I dunno.
13:35:50 <monochrom> . o O ( Algebraic calculus = doing calculus in terms of free variables )
13:36:01 <hyperisco> lol
13:37:33 <hyperisco> ski, so lambda calculus, combinatorial algebra?
13:37:52 <hyperisco> Or what happens in the degenerate case where there are no variables?
13:37:52 <monochrom> For example instead of "derivative (\x -> x) = (\x -> 1)", do "dx/dx = 1"
13:37:56 <davean> hyperisco: so the SQL standard has SQL/PSM
13:37:58 <hyperisco> Is it both an algebra and a calculus?
13:38:18 <monochrom> You always have variables.
13:38:30 <hyperisco> But SKI
13:38:34 <dmwit> hyperisco: Then it's neither an algebra nor a calculus, as explicitly called out in ski's link. =P
13:38:36 <monochrom> Err nevermind, maybe you just have meta-variables.
13:38:58 <hyperisco> " Systems like combinatory logic which contain no variables do not come under either term. "
13:39:11 <hyperisco> Sometimes my answer is just one line further than what I've read. So when can I possibly stop reading?
13:39:24 <hyperisco> Only when I stop asking questions, I suppose.
13:39:41 <monochrom> This happens to my students all the time.
13:40:52 <hyperisco> In Curry's interpretation I think we could have given meaning to "algebraic calculus" as precisely systems with no variables.
13:40:53 <monochrom> One minute of reading one more line in the material I suggest them to read can be saved by an hour of Googling.
13:41:04 <hyperisco> It is both amusing and accurate!
13:41:13 <monochrom> Hell, add: Googling what I never suggested them to read.
13:41:40 <Rembane> For even more confusion
13:43:00 <monochrom> I wrote "algebraic calculus" because I wasn't sure how to adjectivize "calculus". But it is possible to say "calculi algebra".
13:43:27 <hyperisco> Wait, as worded, some calculi are algebras, because calculi are not forbidden to have free variables.
13:43:38 <hyperisco> Oh wait, no, because algebra are forbidden to have bound variables.
13:43:59 <hyperisco> And you can't be a calculus without bound variables, as per the footnote.
13:44:41 <hyperisco> Why not "calculaic"? After "algebraic".
13:45:03 <monochrom> Because "us" is not "a".
13:45:36 <hyperisco> It comes out as singular in my head. Am I thinking wrong?
13:45:44 <monochrom> And I had to pull off "deus -> agnus dei" to do "calculus -> calculi".
13:46:02 <ski> is "algebraic calculus" in the pullback, or in the pushout ?
13:46:04 <monochrom> deus is singular too. and agnus.
13:48:10 <monochrom> I don't know, because what about pullout and pushback?
13:49:13 <hyperisco> "calculic" then? Just, "calculi" is also the plural.
13:50:16 <monochrom> newtype Parser a = MkParser (String -> [(a,String)]);  pullout = MkParser (\(c:cs) -> [(c, cs)]);  pushback c = MkParser (\cs -> [((), c:cs)])
13:50:19 <slayd> If I use -Wall by default with ghci, but I want to load some scripts and suppress the missing-signatures warning, what would I need to add to the file to make that happen?
13:50:42 <monochrom> I am OK with calculic.
13:50:55 <hyperisco> calcufied?
13:51:21 <monochrom> calciate
13:51:51 <monochrom> slayd: Does the GHC user's guide say anything about this?
13:52:14 <slayd> oops. I'll check there
13:52:42 * ski . o O ( "calcified" ? )
13:53:01 <monochrom> I like "calciated" and "calciation".
13:54:38 <monochrom> Calciated algebra = doing algebra on sand ground, using stones to stand for free variables.  Pushing symbols around has never been so much like curling --- pushing stones around!
13:55:10 <monochrom> Except I guess I blew it with sand ground. No one plays curling on sand ground.
13:55:16 <Rembane> This needs a series of videos
13:56:11 <MarcelineVQ> that and sand is silicon not calcium
13:56:20 <jle`> calciated algebra is when you do algebra after drinking milk
13:56:37 <monochrom> BTW who is the go-to famous person when I want to cite one famous person as a representative of algebra?
13:56:40 <MarcelineVQ> Well, maybe on beaches made of shell breakdown, hmm..
13:56:47 <jle`> Albert Einstein
13:57:02 <nil> Emily Noether
13:57:31 <monochrom> Because I want to say "calciated/calfufied/etc algebra is when the algebra person saw Medusa".
13:57:38 <monochrom> Ah Noether!
13:57:48 <monochrom> Noether met Medusa...
13:58:00 <jle`> the conserved quantity became her position
13:58:09 <nil> but what was the symmetry?
14:00:00 * ski . o O ( perhaps it wasn't Medusa, but Stheno or Euryale ? )
14:01:34 <hyperisco> Oh, so PHP with register globals ON is an algebra, and with OFF is a calculus.
14:01:50 <monochrom> haha
14:02:19 <monochrom> Who says you don't need math for Haskell? Who says you don't need math for even PHP?
14:03:13 <Rembane> :O
14:04:10 <hyperisco> This reminds me of the Haskell programmer asking the Java programmer if their UML diagram commutes
14:04:24 <monochrom> haha
14:04:34 <jgt> my old boss — back when I was a rather junior web developer — said programming involves lots of maths
14:04:40 <jgt> I said it doesn't really
14:04:41 <monochrom> Someone gave a category theory of UML diagrams.
14:05:02 <jgt> he said "oh yeah? When you do CSS and you do some width minus some margin… That's not history or geography is it?"
14:05:03 <tdammers> retaliate by making a UML diagram of category theory
14:05:50 <monochrom> I thought edwardk did on the lens doc. >:)
14:06:01 <tdammers> touché
14:09:48 * ski . o O ( "Diagram" by Maria Kovalyova,Roman Cheplyaka in 2015-07-21 at <https://ro-che.info/ccc/29> ) 
14:11:33 <hyperisco> jgt, to be fair, CSS3 does have calc, and nth-child, and so forth ;)
14:12:08 <hyperisco> Someone implemented Game of Life with CSS, so it can't be completely bereft.
14:13:25 <monochrom> haha great
14:13:39 <monochrom> Who says you don't need CS for CSS?
14:21:57 <nn__> hello, is there a web framework that listens for http connection and serves html/js for local web app?
14:22:11 <nn__> like ocsigen for ocaml?
14:24:29 <dmwit> Yes, several.
14:25:01 <nn__> something you would recommend?
14:25:02 <dmwit> snap, yesod, scotty, warp, threepenny-gui
14:25:22 <nn__> can the js/html be bunclded with binary?
14:25:34 <dmwit> Sure, why not?
14:26:00 <nn__> i mean embedded
14:26:18 <dmwit> Yes.
14:26:34 <nn__> can you point me to a documentation please?
14:26:43 <hyperisco> There's a Template Haskell package for that which I've used.
14:26:57 <dmwit> https://hackage.haskell.org/package/file-embed-0.0.10.1/docs/Data-FileEmbed.html
14:27:04 <hyperisco> That one!
14:27:41 <nn__> thanks :)
14:27:43 <dmwit> It is the first result when you google "embed file haskell".
14:30:56 <hyperisco> Was thinking about static site generation… then I started thinking… why don't I just grab an HTML DSL and just write the thing as a Haskell program?
14:31:09 <hyperisco> Get the output with runhaskell, easy peasy.
14:32:18 <hyperisco> Maybe that gets too slow eventually but… bet it'll work for, like, 10 years of whatever I manage to write about
14:32:41 <hyperisco> Actually, with the rate of hardware improvements, it may never need to be improved, lol
14:33:26 <jle`> why do you think it would be slow?
14:33:35 <solonarv> but regenerating the same content over and over is so wasteful! :>
14:34:07 <jle`> if you're writing a blog, the annoying thing would probably be writing the post within a .hs file
14:34:15 <anrock> Hey guys, a quick question: I'm getting a big list of md5 hashes via web api and looking for a Set to store them in. Is there something tailored for md5 like IntSet tailored for ints?
14:34:19 <hyperisco> Hm, well if ghc can incrementally compile then that part wouldn't be slow if I had a module per page.
14:34:44 <hyperisco> But how would I prevent regenerating all the pages?
14:35:45 <jle`> i really don't think it would be that slow
14:35:53 <hyperisco> jle`, meh I am sure at worst I can grab some TH thing to improve string quoting
14:36:25 <jle`> at that point you've left the realm of html edsl
14:37:25 <jle`> and you might as well just write the posts as a separate text file or something. and that's exactly how haskell static site generators like jakyll work :)
14:37:25 <hyperisco> Really? I am not sure what multiline options are available for quoters, but I don't see why I couldn't have one that translates Markdown to an HTML EDSL
14:37:37 <solonarv> sure, that's entirely possible
14:37:39 <MarcelineVQ> Isn't it still that realm, now you've just addeda Raw : Text -> HTML to your dsl?
14:37:39 <jle`> if you're writing markdown then you might as well have it as a separate file
14:37:47 <hyperisco> Why?
14:37:56 <hyperisco> The problem is that they're horribly complicated to figure out
14:37:56 <jle`> what benefit do you have from embedding it in .hs ?
14:38:22 <solonarv> but if each .hs file is just 3 lines of metadata and then '[markdown| GIANT STRING HERE |]' what is the point of it being a haskell source file?
14:38:38 <jle`> that is the eventual goal of my line of questioning ;)
14:38:43 <hyperisco> You have to stick data into the header and sometimes footer, is why
14:38:59 <hyperisco> That's why they have some YAML or whatever header in their text files
14:39:09 <jle`> hyperisco: well, hakyll works by doing just that
14:39:16 <jle`> it assembles the full HTML page using an html edsl
14:39:21 <hyperisco> I know, I've used it, and the rest is really confusing
14:39:26 <jle`> but it allows you to inject parts that come loaded from files
14:39:35 <jle`> so what you are describing is exactly a static site generator
14:39:42 <hyperisco> … yes… that is the point lol
14:39:46 <hyperisco> that is what I said at the start oO
14:40:00 <jle`> ah, i thought you meant to say that this was a way to avoid using a static site generator, heh
14:40:21 <jle`> right, static site generation is basically exactly grabbing an HTML DSL and writing the thing as a haskell program
14:40:31 <hyperisco> nah, just an alternative to other ones, that just uses Haskell + ghc, really, instead of programming a site generator
14:40:42 <hyperisco> your program's output just is the website
14:40:43 <jle`> what are you doing if not programming a site generator?
14:40:53 <jle`> aren't you programming something that ... generates a site?
14:40:58 <solonarv> if your program's output is the website then you have written a site generator!
14:41:15 <jle`> "maybe we can avoid programming a site generator...by writing a program that generators sites"
14:41:17 <jle`> ;)
14:41:22 <jle`> *generates
14:41:34 <hyperisco> when you compile a Hakyll program it gives you a site generator
14:41:46 <hyperisco> when you compile my variation of program it gives you a site
14:41:55 <jle`> when you compile your program...it gives you a site generator
14:41:57 <hyperisco> (when you run it)
14:42:07 <jle`> it gives you generate_my_site.exe
14:42:13 <hyperisco> okay lets put it this way
14:42:17 <hyperisco> my variation has no input :P
14:42:23 <solonarv> the only difference I see is that your method embeds the site data into the binary
14:42:37 <hyperisco> yes, it does that
14:42:43 * hackage indent 0.0.0 - Fix your indentation.  https://hackage.haskell.org/package/indent-0.0.0 (vapourismo)
14:43:03 <hyperisco> I don't have to use any templating gadgets
14:43:08 <solonarv> which I guess is convenient if "deploy then urn a single binary" is somehow easier than "copy over this file"
14:44:21 <jle`> isn't using markdown->html a templating gadget?
14:44:27 <hyperisco> I was also looking at SitePipe but I am not sure it qualifies for simple either, but still looking
14:44:31 <jle`> unless you mean, no interpolation and stuff
14:46:33 <jle`> i guess what you're talking about is just a site generator where the markdown is written directly in the source file instead of read from the filesystem
14:46:49 <jle`> but what about things like css, static js? should that be written directly into the source file too?
14:47:20 <hyperisco> If I needed Markdown that is what I might do. I don't know how attached I am to it. Not that attached. Point is just that there isn't any need for all the fancy stuff if you just need a few pages.
14:47:42 <hyperisco> I spent many hours trying to understand Hakyll, mostly by having to read other Hakyll blogs and copying and pasting whatever they did.
14:48:06 <hyperisco> I'm sure for some elaborate scenario it becomes justified but I just didn't get it for my purposes.
14:49:35 <hyperisco> jle`, the only thing whatsoever helpful for a small site is being able to automatically copy and paste headers and footers with some minor values tweaked.
14:49:53 <Rembane> hyperisco: SSI! 
14:50:18 <hyperisco> There is some header, some footer, and probably some format an article follows, and everything there can just be parameters and arguments. No biggie.
14:50:59 <hyperisco> CSS and JavaScript probably doesn't need that. I don't need it, anyways.
14:51:07 <Rembane> Or create Haskell functions and see how terrible it becomes.
14:51:10 <hyperisco> Rembane, what is that?
14:51:30 <jle`> i mean, you're basically going to be writing a haskell script that just prints out straight .css from its source code
14:51:36 <jle`> which feels a little silly doesn't it?
14:51:44 <hyperisco> No, those will just be .css files :P
14:51:51 <jle`> ah, so you *do* take inputs
14:51:57 <hyperisco> No =\
14:52:09 <jle`> aren't the .css files a part of your website?
14:52:16 <hyperisco> link tag
14:52:31 <jle`> ah, so you're not going to have any .css files then
14:52:51 <hyperisco> Haskell is just acting as a macro system. Maybe I can do the whole thing in the C preprocessor! Hm.
14:52:53 <Rembane> hyperisco: Create a template in Haskell, maybe using Lucid https://chrisdone.com/posts/lucid/ or something, that template will take some arguments which you can give from some other place, so eh... more glue, done! 
14:53:02 <jle`> doesn't your site include .css files in its file directory?
14:53:11 <jle`> is it not a part of your website that is also going to be generated?
14:53:12 <nn__> hyperisco: you can use racket # lang :p
14:53:42 <Rembane> hyperisco: You colud also use sed.
14:54:05 <hyperisco> mm yes but I am such a bad bash programmer that that'd be worse :P
14:54:29 <jle`> fwiw the code to just make a few static pages in hakyll doesn't look too bad
14:54:33 <jle`> main = hakyll $ do
14:54:39 <jle`>   match "page1.html" $
14:54:49 <jle`>     route idRoute >> compile copyFileCompiler
14:54:51 <jle`> that's it :)
14:55:04 <jle`> repeat for "page2.html" and "page3.html"
14:55:14 <hyperisco> fwiw I have already written a Hakyll program that works
14:55:21 <hyperisco> it is just complicated and I don't understand half of it
14:55:42 <hyperisco> and it makes me sad every time I go to do something with it
14:56:06 <jle`> to me hakyll is basically just a fancy makefile
14:57:03 <jle`> just something that maybe automates the things you would normally do by hand anyway
14:57:13 <hyperisco> substitute "it is complicated" for "I don't understand it"
14:57:38 <jle`> hm. my point is that in writing your system, you're eventually going to be making some decisions and usability improvements
14:57:45 <jle`> and eventually you're just going to end up re-implementing hakyll
14:57:57 <jle`> granted, the advantage is that you'll have something you actually understand :)
14:58:05 <jle`> but my point is that hakyll isn't too different from the idea you already have in mind
14:58:13 * hackage indent 0.0.1 - Fix your indentation.  https://hackage.haskell.org/package/indent-0.0.1 (vapourismo)
14:58:20 <jle`> but i don't have anything against trying to implement it yourself to see how it's done
14:58:40 <hyperisco> Except I don't need to discover my pages and process them
14:59:02 <hyperisco> I can just write HTML strings to files
14:59:03 <davean> jle`: I replaced hakyll because I thought it didn't provide much :-p
14:59:18 <jle`> well, you stated some concerns a while back that you might have so many pages that it might overwhelm ghc
14:59:26 <jle`> that suggests that some discovery might be helpful
14:59:42 <hyperisco> I was saying that in 10 years I can see how this might eventually get slow
14:59:57 <jle`> because you'll continually keep on adding pages?
15:00:06 <hyperisco> provided I write enough to make it slow, which would be a fortunate problem to have
15:00:25 <davean> hyperisco: in what way do you expect the number of pages to increase?
15:01:14 <hyperisco> I don't know davean. Some days I just think it'd be nice to write something. But then I think that because I don't have anywhere to put it I ought not bother.
15:01:26 <jle`> do you mean "write enough" as in, keep adding something to the same three web pages that they get so big
15:01:33 <jle`> or do you mean, keep on adding enough web pages that it'll become slow
15:01:55 <hyperisco> The more content for the site means the bigger the program, which increases compile times and run times.
15:02:03 <davean> hyperisco: not true
15:02:11 <jle`> more content as in, more web pages?
15:02:18 <hyperisco> Does it matter? More anything.
15:02:24 <hyperisco> More <hr> tags could be.
15:02:29 <jle`> well, my point is that if you mean more web pages, then discovery might be useful
15:02:41 <jle`> because as you add more webpages, you won't have to manually register every one
15:02:49 <jle`> the discovery would handle adding them fore you
15:02:51 <davean> hyperisco: Unless you do it as strings in Haskell source files, no it won't change the compilation.
15:02:56 <hyperisco> No no no… I just joking to say how much of a non-problem this is.
15:03:29 <jle`> i'm just trying to imagine a situation where discovery would be useful for you. and such a situation is if you foresee yourself adding more pages in the future
15:03:41 <jle`> davean: that's exactly what we're talking about :)
15:03:51 <hyperisco> It just makes rebuild times faster because it can incrementally rebuild.
15:05:03 <hyperisco> Technically, could make every page a program, heh. Why not.
15:05:19 <hyperisco> That fixes the slowdown problem right there. Done.
15:06:10 <jle`> i'll mention also that there is some cognitive benefit in separating program from data
15:06:37 <jle`> you might run into some unexpected problems when your blog posts are turing complete
15:12:15 <sm[m]> g'day all. I'm looking for a graph library supporting labelled edges and shortest path finding. Are my best options fgl and algebraic-graphs ? With the latter being a bit new and unstable ?
15:15:36 <jle`> i think so, probably. also containers has a simple graph implementation too that might support what you're looking for
15:16:11 <sm[m]> thanks jle`. I think Data.Graph doesn't support labelled edges
15:16:21 <sm[m]> bonus points if I can specify my own node type.. I'm thinking fgl doesn't allow that
15:19:02 <sm[m]> it's got this NodeMap thing. A bit complicated for my needs
15:19:37 <jle`> ah yeah, the nodes can be labeled with any type, but internally they must correspond to some unique id
15:19:44 <jle`> it can be a bit awkward to use
15:20:54 <jle`> you can make a graph using mkGraph :: [(Int, nodetype)] -> [(Int,Int, edgetype)] -> Gr nodetype edgetype
15:21:26 <jle`> but i get that a lot of time, you want nodetype to be the actual "node", so uniqueness is enforced, like a set
15:22:24 <jle`> NodeMap lets you "monadically" generate your graph by associating an Int for every node, remembering the int it gave to a node if it comes up again
15:22:25 <sm[m]> exactly
15:23:09 <jle`> hm, well, i guess it'd be in `State (NodeMap a)` that you could monadically make it
15:23:30 <jle`> ah, that's NodeMapM
15:23:55 <jle`> hm, NodeMapM lets you basically forget that your nodes are anyhting but your actual node type, for the most part
15:24:42 <jle`> but it can be kind of awkward to get started, yeah.
15:25:11 <jle`> sm[m]: hm, well, one way you could mdo it that would make it the easiest would be to use whatever representation you already naturally have (like a Map N (Set N), an adjacency graph)
15:25:16 <jle`> *adjacency matrix
15:25:24 <sm[m]> I guess path (http://hackage.haskell.org/package/algebraic-graphs-0.4/docs/Algebra-Graph.html#v:path) means shortest path containing those nodes in that order ?
15:25:28 <jle`> and then convert it to an fgl type, and then query it with fgl functions
15:26:42 <jle`> sm[m]: the 'path' function there is actualyl function to *make* a graph, of a specific topology
15:26:48 <jle`> not to query a graph
15:26:56 <sm[m]> oops. Thanks :)
15:27:27 <jle`> the convert-my-rep-then-query-fgl is actually how i've mostly used it in the past
15:28:10 <jle`> once you have an adjacency matrix like Map MyNode (Set MyNode), it's not too tricky to translate it into an fgl graph type.  it's just constructing the fgl graph type directly that can be a headache
15:28:29 <jle`> * Map MyNode (Map MyNode MyEdge)
15:29:14 <sm[m]> phew.. well algebraic-graphs is not simpler than fgl, and has no shortest-path algorithm that I can find. fgl it is.
15:29:32 <sm[m]> I have a Map Text (Map Text Num), thanks for the tips
15:31:04 <sm[m]> though, maybe I'll drop that type and build the graph from the original [(Text, Text, Num)]
15:35:50 <Welkin> > read @Int "4"
15:35:52 <lambdabot>  error:
15:35:52 <lambdabot>      Pattern syntax in expression context: read@Int
15:35:52 <lambdabot>      Did you mean to enable TypeApplications?
15:36:08 <Welkin> > :set -XTypeApplications
15:36:10 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
15:36:11 <Welkin> @set -XTypeApplications
15:36:44 <Welkin> how should the exception be handled here for reading String -> a ?
15:36:53 <jle`> i usually use readMaybe
15:36:57 <jle`> :t readMaybe
15:36:57 <Welkin> `try` is only for IO
15:36:58 <lambdabot> error: Variable not in scope: readMaybe
15:37:01 <Welkin> okay
15:37:07 <jle`> @let import Text.Read
15:37:08 <lambdabot>  Defined.
15:37:08 <Welkin> that's better
15:37:09 <jle`> :t readMaybe
15:37:11 <lambdabot> Read a => String -> Maybe a
15:37:13 <zachk> :t maybeRead 
15:37:14 <lambdabot> error: Variable not in scope: maybeRead
15:37:43 <jle`> % :t readMaybe @Int
15:37:43 <yahb> jle`: String -> Maybe Int
15:41:28 <sm[m]> nice! mkMapGraph ["A","B","C","D","E"] [("A","B",1),("B","A",1.1),("C","D",10),("C","E",100),("B","C",2)] :: (Gr CommoditySymbol Quantity, NodeMap CommoditySymbol)
15:42:44 <jle`> :D
15:48:18 <ski> > (reads :: ReadS Int) "4"
15:48:21 <lambdabot>  [(4,"")]
15:48:41 <ski> % read @Int "4"
15:48:41 <yahb> ski: 4
15:51:02 <solonarv> % reads @Int "4"
15:51:02 <yahb> solonarv: [(4,"")]
15:51:28 <jle`> makes you wonder why 'read' is even a thing
15:52:23 <Rembane> I think it's an artefact from ancient times. 
15:53:01 <zachk> % reads @Int "42sup?"
15:53:01 <yahb> zachk: [(42,"sup?")]
15:55:13 * hackage indent 0.0.2 - Fix your indentation.  https://hackage.haskell.org/package/indent-0.0.2 (vapourismo)
16:07:29 <solonarv> % readMaybe @Int "42sup?" -- zachk
16:07:29 <yahb> solonarv: Nothing
16:07:52 <zachk> kinda different
16:09:37 <tipitip> waddup
16:19:24 <solonarv> tipitip: hello!
16:20:23 <tipitip> i know a bit of scala and was wondering if haskell is a good next step
16:20:45 <wltprgm> just read about haskell
16:20:49 <tipitip> the whole mixing oo with functional feels really weird in scala
16:21:11 <wltprgm> it looks like a fun way to write in haskell
16:21:27 <Welkin> they are nothing alike
16:21:30 <sm[m]> phew.. fgl is a workout. I have figured out how to look up a Node by label (fst . fst . mkNode nodemap). I'm currently stumped on how to look up an Edge (and its label) given two Nodes. Does that ring a bell for anyone ?
16:21:31 <Welkin> completely different
16:21:50 <tipitip> i thought they follow the same basic principles
16:21:54 <Welkin> no
16:22:10 <tipitip> well can you enlighten me
16:22:13 <Welkin> scala is java with even more convoluted syntax and ADTs
16:22:39 <tipitip> even when you use no vars and mutable structures?
16:24:09 <solonarv> if you're very disciplined and use only a certain subset of scala it can look a bit like Haskell
16:24:27 <solonarv> and some Scala libraries are inspired by stuff from Haskell/the Haskell ecosystem
16:25:18 <tipitip> i see
16:25:34 <tipitip> is there a standard toolchain you recommend to get going
16:25:45 <tipitip> or is it just text editor + shell
16:25:53 <wltprgm> do you guys use haskell for web development?
16:25:53 <solonarv> the latter
16:26:03 <solonarv> there is some IDE support for Haskell but it's rather shaky
16:26:05 <jle`> sm[m]: hm, perhaps you can find the intersection between 'out' and 'inn' ?
16:26:31 <jle`> sm[m]: your you can just filter the result of outt
16:26:50 <tipitip> ok thanks
16:27:00 <jle`> sm[m]: find (\(_,o,_) -> i == j) . (`out` i)
16:27:05 <jle`> find from Prelude
16:27:38 <solonarv> I recommend starting by using GHC (and cabal) directly, which you can install using ghcup on mac/linux or chocolatey on windows
16:27:40 <solonarv> @where ghcup
16:27:41 <lambdabot> https://www.haskell.org/ghcup/
16:28:19 <sm[m]> jle`: that works, thanks
16:29:02 <sm[m]> tipitip: text editor plus shells running ghcid and ghci
16:29:25 <Welkin> gh cup
16:29:51 <Welkin> :t find
16:29:53 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
16:31:28 <tipitip> huh so ghci is the repl
16:31:41 <tipitip> noice
16:33:18 <tipitip> @solonarv is there any upside to using ghcup as opposed to brew
16:33:18 <lambdabot> Unknown command, try @list
16:34:09 <solonarv> yes - you can easily have multiple versions of GHC installed (which is sometimes needed), and you don't have to wait fo rnew versions to be added to some package repository
16:39:34 <ski> tipitip : fwiw, it's not IRC custom to prefix nicknames with sigils like `@' :) just write the nickname. if you want to specifically address someone, you can start the message with their nickname, e.g. followed by a comma or colon, and the message. i think many IRC clients highlight/alert you when someone mentions your nickname, first thing in a message (and also when privately messaging you) (not as many do that if you mention it not at the start)
16:41:08 <ski> (also, `@' already means something else on IRC. namely that the person is an operator of the channel. IRC predates Twitter)
17:49:45 <jle`> ~>
17:50:07 <Clint> ~>
17:50:23 <jle`> me mistyping the SSH escape code :)
17:52:32 <Clint> jle`: excellent
17:52:58 <jle`> hm, is there super unsafe way to trick ghc into defining a local instance of something within a continuation.  like foo ::forall r.  (C X => r) -> r, where X has an instance of C only locally within the (C x => r)
17:53:47 <ski> jle` : hm, can you cast like in `reflection' ?
17:54:23 <jle`> reflection was the inspiration, but the best you can do is provide a local instance of C NewtypeOverX
17:54:47 <jle`> as in foo :: forall r. (forall s. C (NewtypeOverX s) => r) -> r
17:55:28 <jle`> that method sounds completely safe/sound, since it effectively traps the instance in the continuation, runST-style
17:55:56 <jle`> it's the reasonable way to do the unsafe thing i am looking for :)
17:56:20 <jle`> but i'm looking for the really morally bad way
17:56:46 <ski> a cast wouldn't work, then ?
17:57:50 <jle`> the user would have to manually cast and uncast every time they use X, with the reflection way
17:58:04 <jle`> but i don't think it's possible to provide just the (C X => r) -> r interface
17:58:13 <jle`> (by using the safe reflection interface)
18:01:23 <MarcelineVQ> are constraint kinds applicable to this
18:04:02 <jle`> they probably enable the solution (if any) to exist, but i don't think they themselves are a solution
18:04:06 <MarcelineVQ> wait, ConstraintKinds is since 7.4.1? What am​ I thinking of, I thought there was something newer about this..
18:04:28 <edwardk> it isn't usable until 7.6 iirc
18:04:34 <edwardk> in 7.4 you get segfaults everywhere
18:04:57 <edwardk> check the bounds on my constraints package to be sure
18:05:59 <solonarv> jle`: if you can get your hands on a type 'D' which has the same runtime rep as the dictionary for 'C X', you can unsafeCoerce 'C X => r' to 'D -> r' and pass in the dictionary
18:07:16 <MarcelineVQ> jle`, edwardk: oh it was Quantified Constraints I was thinking of, no idea of it's relevant
18:07:33 <MarcelineVQ> "A quantified constraint is a bit like a local instance declaration." https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0018-quantified-constraints.rst
18:07:56 <edwardk> MarcelineVQ: oh then in that case that isn't working until 8.10 at least ;)
18:08:04 <MarcelineVQ> hehe
18:30:00 <H0rny_Girl_98> I will start my Live Show in 10 minutes. Fastest people will join my Private Live for FREE! Be among the first 5 people to write me "FREE INVITE" on my CAM room: http://snip.li/Y9uLM
18:34:45 <Axman6> oh man, I wonder what she's coding!
18:39:40 <maerwald> xD
18:56:19 <nshepperd> jle`: unsafeCoerce :: Dict (C (NewtypeOverX s)) -> Dict (C X)?
19:00:31 <ski> what's `s' there ?
19:01:43 <solonarv> it's a phantom type parameter
19:02:07 <ski> oh
19:31:18 <Welkin> @djinn [a] -> [[a]]
19:31:18 <lambdabot> Error: Undefined type []
19:31:30 <Welkin> is there a function to group by an interval?
19:32:13 <Welkin> or insert a new element at every interval
19:34:07 <Welkin> better yet
19:34:25 <Welkin> is there a way to determine the "rows" in an Array using Ix?
19:34:32 <Welkin> for a 2-dimensional array
19:34:42 <Welkin> without having to manually count
19:35:07 <Welkin> so that I can do things like map over the rows
19:35:07 <glguy> :t chunksOf
19:35:09 <lambdabot> Int -> [e] -> [[e]]
19:35:23 <glguy> I'm less clear on your rows and Ix question
19:35:37 <Welkin> imagine a game board
19:36:00 <Welkin> and you want to print it out to the console, adding a newline after each row
19:36:25 <Welkin> but it is Array (Int, Int) Tile
19:37:36 <glguy> I'd think you'd have to do something like: for_ [1..rows] \row -> do { for_ [1..cols] \col -> ... ! (row,col) ; putChar '\n' }
19:37:53 <Welkin> yeah, that's what I was looking to avoid
19:38:34 <Welkin> at least I can use `bounds` to get the size
19:39:06 <Welkin> you mean forM_?
19:39:10 <Welkin> :t for_
19:39:11 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
19:39:15 <Welkin> :t forM_
19:39:16 <lambdabot> (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
19:39:21 <glguy> forM_ is old news
19:39:22 <Welkin> okay
19:44:13 * hackage registry 0.1.6.0 - data structure for assembling components  https://hackage.haskell.org/package/registry-0.1.6.0 (etorreborre)
20:07:47 <dmj`> long live forM_
20:22:19 <zeta_0> hello guys i just installed and setup hasklig-mode in emacs, but for some reason the ligatures are invisible so i can't see them, do you guys know why this is and how i can fix it? https://github.com/minad/hasklig-mode/tree/386c098c93a744f6b30ad937d193eebf0fd79e1b
20:23:13 <ski> Welkin : you want to curry an array, or what ?
20:31:06 <zeta_0> has anyone here had an issue in emacs where ligatures are invisible?
20:37:17 <dmwit> Welkin: You could consider `Array Int (Array Int Tile)` or so. Then you could `for_ (\row -> for_ (\tile -> ...) >> putChar '\n')`.
20:37:34 <dmwit> uh
20:38:25 <dmwit>     for_ board (\row -> for_ row (\tile -> ...) >> putChar '\n')
20:40:08 <ski> zeta_0 : hm, at least some common ligatures i tried work here. in terminal emacs, nonetheless
20:41:33 <iqubic> How does one use ligatures in Emacs?
20:42:00 <iqubic> Perhaps I can test out ligatures on my GUI emacs instance.
20:43:07 <zeta_0> iqubic: https://github.com/i-tu/Hasklig https://github.com/minad/hasklig-mode/tree/386c098c93a744f6b30ad937d193eebf0fd79e1b https://melpa.org/#/?q=hasklig-mode
20:43:19 <Welkin> you mean to ask "How do I use"
20:43:27 <Welkin> "one" is an asshole
20:44:13 <Welkin> dmwit: I've done that before. Also used a flat Vector with an indexing function (a trick I learned in C)
20:44:25 <Welkin> it's working great with Array though
20:44:28 <zeta_0> after installing and setting up hasklig-mode, when i type the ligatures they are invisible so i can't see them?
20:45:20 <Welkin> that's how invisible things work
20:45:21 <maerwald> they have the same size as the normal operators?
20:46:34 <iqubic> Where do you go to get the Hasklig font?
20:46:43 <Welkin> github
20:47:18 <zeta_0> look at the three links above ^
20:47:44 <Welkin> I don't bother with programming ligatures
20:47:51 <Welkin> they just end up causing confusion anyway
20:48:05 <maerwald> I find it annoying when it changes to code formatting
20:48:13 <maerwald> *the
20:48:33 <Welkin> you can easily type unicode in emacs
20:48:38 <Welkin> and haskell supports it
20:48:47 <iqubic> yeah. I don't think I'll be using the ligatures actually.
20:49:04 <glguy> If I'm going to have ligatures I either 1) don't want them 2) use fira code so they don't change the column widths
20:50:02 <dmj`> Welkin: you could also use Map (Int,Int) a
20:50:10 <Welkin> I thought about that too
20:50:27 <Welkin> Array seems best
20:50:33 <Welkin> no unwrapping Maybe
20:51:10 <iqubic> glguy: What is fira code?
20:51:18 <glguy> There's no way to know
20:51:19 <Welkin> a fork of fira mono
20:51:19 <dmj`> Welkin: https://github.com/dmjio/tripletown/blob/master/src/TripleTown.hs#L44
20:51:25 <dmj`> Welkin: you unwrap the maybe with for as well
20:53:02 <Welkin> you made a game with bears wearing onesies who steal diamonds from castles?
20:53:13 <dmj`> yes
20:54:05 <dmj`> Welkin: the core algorithm in the game is a breadth first search, it's actually similar to candy crush
20:56:40 <zeta_0> i give up, if i have some time tomorrow, i will try again
21:00:28 <Welkin> dmj`: "to play quickly" can be even shorter: cabal new-run main
21:00:29 <Welkin> :D
21:01:08 <dmj`> heh, I don't use cabal anymore
21:01:14 <ski> Welkin : "indexing function" ?
21:01:21 <iqubic> so who here actually uses ligatures when coding?
21:02:29 <Welkin> ski: row * columnWidth + column
21:02:49 <sadwqwqe[m]> hello
21:02:51 <pie__> "This recording has been archived" :(
21:03:28 <pie__> "This is an abridged version and is missing key features like bears and scoring"  aww ok i see :(
21:03:35 <Welkin> just download it
21:03:42 <glguy> pie__: I have a version with bears
21:03:44 <Welkin> I didn't play enough to find the bears
21:04:06 <glguy> https://github.com/glguy/TripleGame
21:04:10 * ski isn't even sure whether "ligatures" in this context means ⌜ÆŒĲæœꟹĳßﬀﬁﬂﬃﬄﬅﬆ⌝ or ⌜∷→←∀⧺≫⌝
21:04:10 <Welkin> is this a popular thing that I missed while I was away?
21:04:12 * glguy goes to see if it builds
21:05:05 <ski> Welkin : oh, you mean what custom indices in e.g. `Array' buys you
21:05:12 <ski> sadwqwqe[m] : hello
21:05:51 <dmj`> Welkin:  nix-shell -p 'haskellPackages.ghcWithPackages (p: with p; [random])' --run 'runghc -isrc exe/Main.hs'
21:06:07 <dmj`> Welkin: glguy's version is legit
21:06:17 <dmj`> bears were hard
21:07:00 <dmj`> Welkin: bear games are just super popular ;)
21:07:10 <ski> Welkin : hmm .. now i'm pondering finite well-orderings
21:07:13 <glguy> I didn't have it scale up though, so you get bears and ninja bears right from the beginning
21:17:50 <glguy> https://imgur.com/a/LQWceF7 Not the clearest UI, the cell art runs together, but there you go :)
21:19:23 <iqubic> So who here uses ligatures when coding?
21:20:03 <dmj`> iqubic: it's overrated
21:20:10 <iqubic> Why do you say that?
21:20:23 <dmj`> iqubic: it's cool for a bit, but just gets annoying
21:20:31 <iqubic> why does it get annoying?
21:20:54 <dmj`> you'll see
21:21:23 <iqubic> I'm not sure I will.
21:22:01 <iqubic> Why do you say it get annoying.
21:23:31 <dmj`> it's not good for collaboration, since everybody has different configs
21:23:40 <MarcelineVQ> They're fun to try once but the novely wears off quickly. You just end up with more symbols to parse mentally than you had before without a particular gain. People use ascii or they use unicode/latex, there's not really a place that ligatures fill in in that ecosystem, and limited font choices to support them if you do like to use them.
21:24:07 <ski> @remember André_Green (psychoanalyst) "A fruitful obscurity is worth more than a premature clarification."
21:24:07 <lambdabot> Okay.
21:30:19 <dmj`> iqubic: not to dissuade you, by all means try them
21:33:52 <iqubic> I don't really want to.
21:56:55 <habbah> On https://haskell.fpcomplete.com/tutorial/web-services there's a challenge: Exercise Write a function unsimpleApp :: SimpleApp -> Application.
21:57:21 <habbah> Does anyone have a tip on how to go about this?
22:12:01 <ski> habbah : start by expanding for yourself what this type signature means, in terms of what the type synonyms in it stand for
22:27:37 <habbah> SimpleApp{ saLogFunc :: !LogFunc, saProcessContext :: !ProcessContext}
22:27:39 <habbah> type Application = Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived
22:28:24 <habbah> Request is of type https://hackage.haskell.org/package/wai-3.2.1.2/docs/src/Network-Wai-Internal.html#Request
22:30:49 <habbah> data Response = ResponseFile H.Status H.ResponseHeaders FilePath (Maybe FilePart) | ResponseBuilder H.Status H.ResponseHeaders Builder | ResponseStream H.Status H.ResponseHeaders StreamingBody | ResponseRaw (IO B.ByteString -> (B.ByteString -> IO ()) -> IO ()) Response deriving Typeable
22:31:04 <habbah> data ResponseReceived = ResponseReceived deriving Typeable
22:31:46 <habbah> There's a defaultRequest
22:31:59 <ski> habbah : `Request' and `ResponseReceived' are not type synonyms
22:32:30 <ski> s/is of type/is the type/
22:33:39 <habbah> ski: I'm sorry, I don't understand that second message. Did I state they were synonmyms? Thanks for sticking with me a little while!
22:34:52 <ski> `Request' *is* a type. it doesn't have a type. so saying that it is "of type ..." is misleading, at best, and may be an indication of underlying conceptual confusion or conflation
22:35:37 <habbah> oh
22:45:43 * ski looks at habbah
22:51:35 <Axman6> habbah: what is ProcessContext?
23:06:33 <habbah> https://hackage.haskell.org/package/rio-0.1.9.2/docs/src/RIO.Process.html#ProcessContext
23:10:08 <habbah> I have realized that I don't know what respond is in the basic examples of using WAI, e.g.: https://github.com/yesodweb/wai/tree/master/wai#getting-started
23:23:34 <habbah> I guess that is (Response -> IO ResponseRecieved)
