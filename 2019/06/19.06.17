01:15:17 <fuzzy_id> i have to convert an image to greyscale and resize it. any library recommendations?
01:16:35 <paolino_> hello, is there a way to derive Semigroup for a product type using the tuple instance and deriving via ?
01:17:42 <Axman6> fuzzy_id: juicypixels come to mind. I feel there's another one I can't remember
01:20:17 <fuzzy_id> yeah, currently looking into JuicyPixels. resizing is easy to find. not sure about greyscale conversion
01:22:46 <Ariakenom> fuzzy_id: what about pixelMap?
01:25:23 <ruffy_> Anybody knows how I can create a bitvector of length 4 in SBV? At the moment the smallest one I can see has length 8.......https://hackage.haskell.org/package/sbv-8.3/docs/Data-SBV.html#g:5
01:25:35 <fuzzy_id> @Ariakenom: is that a library? can't find it on hackage
01:25:36 <lambdabot> Unknown command, try @list
01:26:02 <Ariakenom> fuzzy_id: no its a function in juicy
01:26:16 <ruffy_> I added a constraint that the bitvector of length 8 should be less equal to 15, but I think thats an ugly solution
01:29:36 <Ariakenom> ruffy_: Those looks to be machine sized so I guess not.
01:31:46 <Ariakenom> fuzzy_id: https://hackage.haskell.org/package/JuicyPixels-3.3.3/docs/Codec-Picture.html#v:pixelMap
01:32:43 <solonarv> mjrosenb: also, you can have multiple cabal.project{,.local,.freeze} files and specify which set to use (cabal.project is the default) - so you could have a cabal.project.ghc and a cabal.project.ghcjs, for example (and corresponding .local files would be produced by new-configure)
01:33:01 <solonarv> paolino_: not via re-using the tuple instance, but you can use the generic-data package
01:33:25 <solonarv> data MyProduct = <blah> deriving Generic; deriving (Semigroup, Monoid) via Generically
01:34:37 <paolino_> thanks solonarv , I didn't see that before
01:35:14 <solonarv> that package is basically the poster child for DerivingVia :D
01:38:32 <noipmusp> Hi, is there any "cleaner" approach to this: https://www.reddit.com/r/haskell/comments/164wmc/subsets_of_a_sum_type_as_types/?
01:42:39 <jchia1> stack question: After I stack build, I get executable files in "hs/.stack-work/install/x86_64-linux/f6a4545d63d8b42564f6194baced4036f237cefca0c36ff4249499bff4fd7c85/8.2.2/bin", where hs in the directory with my project. When I do the same on a different machine using the same git repo, the bin directory is put somewhere else, not f6a4545d...
01:42:42 <jchia1> Is this normal?
01:43:10 <jchia1> i don't want to use "stack exec" to run the executables, but it seems that i can't have predictable paths. what else can i do?
01:43:38 <jchia1> i used to use symlinks, but after i recently upgraded stack, the symlink approach seems to have stopped working
01:44:00 <jchia1> the same symlink works on one machine but not another
01:44:20 <Axman6> stack has commands for giving you the paths of things IIRC
01:44:28 <Axman6> possibly  stack paths
01:44:35 <fuzzy_id> jchia1: i think you can use 'stack path --local-install-root'
01:44:37 <jchia1> Axman6: I know at the very least I can do "stack exec which ...."
01:44:59 <Axman6> you can also specify the destination those binaries get put in
01:45:11 <jchia1> it means another step in my automated build-and-run system
01:45:16 <jchia1> Axman6: how?
01:45:17 <Axman6> I don't remember how, but we used to put ours in ./dist
01:45:38 <Axman6> it was something in the stack.yaml
01:50:36 <ruffy_> Ariakenom: Hmmmm thx, thats bad
01:50:38 <jchia1> Axman6: Did you specify install-bin-path as ./dist in your stack.yaml and then use stack install?
01:55:08 <Ariakenom> ruffy_: bad?
01:56:10 <ruffy_> Ariakenom: Yeah in my opinion it is ugly to control the length of the bitvector with using constraints
01:56:57 <ruffy_> I would have expected that there is also the possibility to have bitvectors with a custom length
01:58:10 <Ariakenom> ruffy_: Oh I actually thought this was another conversation :D. yeah I see.
01:58:12 <noipmusp> What's the default data type with cardinality 1? Data.Void?
01:58:35 <Ariakenom> noipmusp: morally? ()
01:59:03 <noipmusp> Sure, thanks...
01:59:33 * ski . o O ( "Mathematics, morally" by Eugenia Cheng in 2004-01 at <http://cheng.staff.shef.ac.uk/morality/morality.pdf> )
02:03:34 <ruffy_> Ariakenom: np :D
02:08:08 <Aleksejs> hello, is there a way to create a record with field name "type"? I'm parsing a JSON with Aeson and there's a field named type in that JSON
02:08:30 <merijn> Aleksejs: No, type is a reserved word
02:08:41 <merijn> Aleksejs: you'll have to do something like type_ or type' or something
02:09:42 <ski> or `typ'
02:10:54 <hexagoxel> Aleksejs: use an appropriate fieldLabelModifier to have Foo { _type :: Int } map to an object with field "type"
02:13:00 <hexagoxel> e.g. Aeson.defaultOptions { fieldLabelModifier = dropWhile (=='_') }
02:18:44 * hackage ast-path 0.2.0 - vocabulary representation for predicting program properties  https://hackage.haskell.org/package/ast-path-0.2.0 (ijaketak)
02:34:11 <jchia1> I just upgraded stack. Is it normal for stack to leave behind a file called 'stack.yaml.lock'?
02:35:54 <jchia1> seems like it is. now i'll just have to add it to my .gitignore
02:53:14 * hackage inline-c 0.8.0.1 - Write Haskell source files including C code inline. No FFI required.  https://hackage.haskell.org/package/inline-c-0.8.0.1 (FrancescoMazzoli)
02:54:29 <booghost123> >2+2
02:56:36 <ski> > "you need a space after the `>'"
02:56:38 <merijn> booghost123: Space after > for lambdabot
02:56:39 <lambdabot>  "you need a space after the `>'"
02:56:55 * ski smiles
03:33:23 <simon> > sum [1..]
03:33:30 <lambdabot>  mueval-core: Time limit exceeded
03:33:40 <simon> But I'm told this is -1/12!
03:34:22 <Arahael> I'm trying to do: instance Foo (Bar Text) where...  But that seems to be an illegal declaration? Why?
03:34:42 <solonarv> that reasoning has always seemed spurious to me, simon 
03:34:55 <solonarv> Arahael: how are Foo and Bar defined?
03:35:30 <Arahael> solonarv: class Foo a where... and 'data Bar a = ...'
03:35:45 <solonarv> huh. what's the error?
03:36:43 <Arahael> solonarv: https://gist.github.com/arafangion/c171a5a88d774864dd5dcb4f4627d68d
03:37:02 <solonarv> oh, of course, *that*
03:37:27 <solonarv> the Haskell report is more conservative than is really needed when it comes to what instances are allowed
03:37:36 <Arahael> Yeah?
03:37:41 <solonarv> just turn on FlexibleInstances, as the error suggests
03:37:59 <tdammers> indeed. FlexibleInstances is one of the more benign extensions
03:38:09 <solonarv> the report only allows instances of the form: Cls (TyCon tyvar1 tyvar2 ...)
03:38:57 <solonarv> presumably this would allow more naive instane resolution schemes to be used when implementing a compiler
03:39:05 <Arahael> What's the best way for me to understand what this does?
03:39:25 <solonarv> the best way to understand what this does is that it turns off a largely pointless restriction
03:39:52 <Arahael> I suppose it probably wants me to define it like this: instance PP (Lexeme (Text a b c)) where... ?
03:40:05 <Arahael> Rather than just: instance PP (Lexeme Text) where...?
03:40:23 <solonarv> no, that still not legal
03:40:48 <solonarv> because PP (Lexeme (Text ...)) also does not have the form Cls (TyCon tyva1 ...)
03:41:21 <solonarv> the only instance you are allowed to write without FI is 'instance ... => PP (Lexeme a)'
03:41:46 <Arahael> So how was this particular outcome done without flexible instances?
03:42:01 <Arahael> (I'll be using flexible instances, just to be clear, now! ;) )
03:42:19 <solonarv> I don't think it *was* done!
03:42:34 <solonarv> well, perhaps one might have written 'instance PP a => PP (Lexeme a)' instead
03:42:36 <Arahael> That's quite a limitation!
03:42:51 <solonarv> and maybe this even makes sense for your domain
03:43:07 <solonarv> indeed it is! there is a reason FlexibleInstances is so ubiquitous
03:43:09 <Arahael> I can actually do 'instance PP (Lexeme a) where...' without Flexible Instances.
03:43:14 <solonarv> yes
03:43:29 <Arahael> But I actually only care about it where a is a Text. :)
03:43:39 <solonarv> because that has the form 'Cls (TyCon tyvar1 ...)'
03:44:30 <Arahael> So quite restricted, then.  I guess I'd have to do further unwrapping in the pattern matching in the instance implementation.
03:45:13 <lyxia> Arahael: one benefit of the restriction is that it makes it easier to specify how instance resolution works, because instances can be identiied with instance heads
03:45:51 <Arahael> So it simplifies the type system implementation, potentially very significantly?
03:46:04 <solonarv> i.e. you only have to look at the 'Cls' and 'TyCon' parts of the template I wrote above
03:46:09 <solonarv> yes
03:46:28 <Arahael> Sensible. :)
03:46:29 <solonarv> but I'm not aware of any non-toy compilers that take this shortcut (GHC sure doesn't)
03:46:47 <Arahael> I'm glad people have clearly thought about it, though.
03:47:07 <Arahael> It's tedious using a language that sometimes take a full second to typecheck a single function, I'm guessing Haskell doesn't do that either.
03:47:18 * Arahael uses Swift at work
03:47:26 <lyxia> my understanding of the haskell reports is that they are quite worried about corner cases
03:47:46 <lyxia> otherwise there are quite a few features that would have made it through.
03:49:02 <Arahael> Considering the state of software, I think I rather like that stance.
03:51:03 <solonarv> Arahael: oh, you can write a function that takes millions of years to typecheck - but it won't be simple and will involve a bunch of type hackery
03:51:15 <solonarv> (you can even write one where typechecking will never terminate)
03:51:32 <solonarv> although I think you need some language extensions for that
03:52:09 <Arahael> solonarv: Last week, I managed to crash the swift *compiler*.
03:52:28 <solonarv> heh
03:52:48 <solonarv> GHC crashes rarely (IME) and it is always a bug when it happens
03:52:59 <Arahael> solonarv: Turns out, defining a lambda with a bunch of args, is considered a "complex closure", and depending on what that closure calls, results in a signal 11 if you don't define the type of at least two of it's argumetns or the return value.
03:53:35 <Arahael> And people looked at me funny!?
03:54:06 <Jinna> Essentially I am doing this race_ trick with an MVar, as shown here: https://stackoverflow.com/questions/45839972/how-do-i-cause-a-warp-server-to-terminate
03:54:10 <solonarv> okay that *is* weird
03:54:16 <merijn> solonarv: Depends on who you are
03:54:34 <merijn> solonarv: Iceland_Jack crashes GHC so regularly he has a warning/error calling him out for compiler torture :p
03:54:56 <Jinna> I create an empty MVar and store it in a config. In one of my handlers I ask for the config and put unit on it. But in my main function, where I am race_-ing I don’t see how the code quits.
03:54:57 <Arahael> solonarv: It turns out it is very easy to crash the swift compiler. :(
03:55:08 <merijn> https://twitter.com/Iceland_jack/status/949221173052747781
03:55:09 <Jinna> But it compiles.  Any ideas what might go wrong here?
03:55:13 <ski> @ghc
03:55:13 <lambdabot> CPR Analysis tried to take the lub of a function and a tuple
03:55:48 <solonarv> Jinna: does it work (i.e. does it correctly quit) /
03:55:49 <solonarv> ?
03:56:07 <merijn> Jinna: What do you mean "I don't see how the code quits"?
03:56:17 <solonarv> merijn: that is why I added "(IME)" ;)
03:56:33 <Jinna> It does not quit. One of my last lines in main:   race_ (takeMVar ks >> putStrLn "Ende Gelände!") (run 8080 (app conf))
03:57:05 <Jinna> And in the server thread, there I am doing     liftIO $ putMVar ks ()    -- ks is the killswitch
03:57:44 <solonarv> hm, could you post your whole code? 
03:57:51 <Jinna> I see a putStrLn _after_ the putMVar action working. But the   takeMVar does not fire.
03:58:00 <Jinna> solonarv: I can paste some of it, yes.
03:58:15 <merijn> Jinna: Did you use the threaded runtime?
04:00:52 <Jinna> https://pastecode.xyz/view/caa48225
04:01:10 <Jinna> merijn: is there a way to find it out in a running ghci/emacs/intero session?
04:01:26 <merijn> hmm, ghci is always threaded afaik
04:02:27 <merijn> nvm I see the error
04:02:39 <merijn> You're storing the IO action to create an MVar inside your config
04:03:11 <merijn> That's wrong
04:03:48 <merijn> You're basically creating 2 MVar's, one that you write the shutdown signal too and one you wait on a shutdown signal on, but obviously it's never going to get one, since you never write to it
04:04:11 <Jinna> Isn’t the    ks <- killSwitch    executing the IO?
04:04:29 <merijn> Jinna: newEmptyMVar allocates a, well, new empty mvar
04:04:52 <merijn> Jinna: So you're executing that (and allocating a new MVar) in both shutdownServer and main
04:05:15 <merijn> Jinna: You want to run the newEmptyMVar once in acquireConfig then use that same MVar in both shutdownServer and main
04:05:31 <Jinna> merijn: okay I see. I store the IO action and run it twice.
04:05:35 <dminuoso> Jinna: No.
04:06:08 <merijn> Jinna: So inside acquireConfig you want "mvar <- newEmptyMVar" and then store mvar inside your config
04:06:35 <merijn> Jinna: Think of newEmptyMVar as malloc/new (depending on the language you're familiar with) for creating MVars :)
04:06:54 <dminuoso> It's similar to newIORef if you are familiar with that. :)
04:09:03 <Jinna> merijn: Thx! That worked.
04:09:07 <Jinna> I see now my mistake.
04:09:41 <Jinna> If I want to activate the threaded runtime – would I have to specify    +RTS -N -RTS   ?
04:10:19 <merijn> Jinna: You need to tell ghc to compile with -threaded
04:12:35 <Jinna> merijn: okay I see, I will figure out of Stack is doing that implicitly.
04:12:57 <merijn> You'd normally include that under ghc-options in your cabal file
04:13:35 <sicklorkin> Jinna: stack.yaml define ghc-options
04:13:49 <merijn> Better to do it in the cabal file
04:14:01 <merijn> w
04:14:03 <sicklorkin> you are given "$locals", "$targets", and "$everything" directives if you want
04:14:36 <Jinna> merijn: do you mean  a) I should explicitly pass -threaded in    or  b) I should do it in the .cabal file instead of the stack.yaml?
04:14:55 <sicklorkin> merijn is right, slack isn't the best at making things simple sometimes.
04:14:55 <merijn> Jinna: I mean you should explicitly list it in the .cabal file over stack.yaml
04:15:10 <solonarv> (or package.yaml instead of .cabal, if that exists)
04:15:14 <merijn> sicklorkin: Not really because of simplicity, but because of portability
04:15:38 <merijn> sicklorkin: You should specify everything you can inside .cabal files because they are understood by both stack AND cabal-install
04:16:07 <cjay-> how do I tell haskell-ide-engine to use -fobject-code?
04:16:09 <merijn> Relying on stack.yaml or package.yaml means that no one using cabal-install can build your stuff without a lot of effort (incidentally, one of the reasons you should avoid package.yaml at all costs)
04:16:49 <merijn> solonarv: If package.yaml exists you should delete that first, THEN add it to the .cabal file :)
04:17:09 <solonarv> I agree. If you have built your code recently (presumably that is the case) you can simply delete package.yaml and edit the .cabal file from now on
04:17:15 <sicklorkin> merijn: you are essentialy saying don't use stack
04:17:19 <solonarv> (stack will use whichever is newer)
04:17:22 <merijn> sicklorkin: No
04:17:59 <solonarv> sicklorkin: the recommendation is "when given a choice, specify things in foo.cabal"
04:18:04 <merijn> sicklorkin: Stack works fine without package.yaml (i.e. hpack), hpack gratuitously breaks the ecosystem with a custom, underdocumented, non-portable, not feature completed ad hoc YAML based format
04:18:06 <sicklorkin> by doing this aren't you giving up all the build convinences of stack+hpack?
04:18:22 <solonarv> hpack doesn't really add any convenience at all tbh
04:18:36 <solonarv> just saves you from typing a few module names I guess
04:18:37 <sicklorkin> i totally agree
04:18:40 <merijn> sicklorkin: Name one convenience that hpack gives that you don't get in .cabal files? (I know of one, but it's SUPER niche and not worth the effort)
04:19:13 <sicklorkin> it just seemed like over kill for someone tyring to run their app with -threadeed
04:19:52 <solonarv> well there is not much difference in terms of effort between adding one entry to to stack.yaml, package.yaml or foo.cabal
04:19:56 <merijn> I (personally) don't like stack's workflow, but at least it just follow/adheres to the CABAL spec, so use what you like. hpack on the other hand gratuitously fractures the entire ecosystem for little to no real gain which annoys me endlessly
04:20:04 <solonarv> might as well do the one that's best practice overall
04:20:09 <sicklorkin> merijn: oh, i'm not arguing anything about convinence i dislike slack very much
04:20:50 <sicklorkin> but the last time I removed my package.yaml i was spinning in circles for a while trying to get a working build again
04:21:37 <merijn> sicklorkin: Just run it once to generate a .cabal file (that's what it does in the end) and *then* delete it ;)
04:21:39 <Jinna> merijn: I am also using the package.yaml and stack. Your suggestion about using the .cabal instead is to improve portability, si?
04:23:06 <Jinna> I find the idea of Stack+hpack pretty convincing. DRY.
04:23:11 <merijn> Jinna: package.yaml is actually from hpack, not stack. Stack automatically runs hpack for you, but as said above, I think that encourages poor behaviour :)
04:23:33 <merijn> Jinna: hpack is little more than "YAML syntax for cabal files", tbh
04:23:47 <Jinna> I found the .cabal format a bit too chatty, coming from Clojure and Leiningen.
04:23:48 <sicklorkin> wc -l lister.cabal package.yaml 
04:23:48 <sicklorkin>  1082 lister.cabal
04:23:48 <sicklorkin>   147 package.yaml
04:24:02 <Arahael> merijn: It certainly overcomplicated getting me used to stack, for a long time, I thought package.yaml *was* stack, and was blown over how simple it gets when you don't do that.
04:24:11 <sicklorkin> merijn: i'm not sure if I wanna start maining that cabal file. ;)
04:24:16 <sicklorkin> *maintaining
04:24:22 <merijn> sicklorkin: That might be due to poor writing of the cabal file :)
04:24:45 <merijn> sicklorkin: What are all those lines coming from?
04:25:08 <sicklorkin> exposed modules and build deps
04:25:32 <Arahael> sicklorkin: When you want to manipulate how you're compiling your stack-based application in more creative ways (eg, creating a library for use in a non-haskell application, perhaps), hpack becomes seriously tricky to navigate.
04:25:34 <merijn> sicklorkin: You know that Cabal now (actually for a while now) supports common stanzas for build deps?
04:25:48 <merijn> sicklorkin: i.e. if you wanna share build-deps lists across different executables
04:26:11 <merijn> sicklorkin: I know hpack was initially invented to deal with that, but support for that was added to CABAL fairly soon afterwards
04:26:40 <merijn> sicklorkin: exposed modules can be a bit annoying, but OTOH I generally don't have THAT many modules (and if you do, then I worry about how humanly graspable it is)
04:26:47 <sicklorkin> ftr i've used cabal for 10+ years, i decided to shoot myself in the foot w/this project and use stack.. it's been a very painful ride
04:27:24 <merijn> sicklorkin: https://cabal.readthedocs.io/en/latest/developing-packages.html#common-stanzas :)
04:27:39 <sicklorkin> merijn: thanks
04:27:43 <merijn> sicklorkin: Actually, looks like common-stanzas work for every field, not just build deps :)
04:28:03 <merijn> sicklorkin: So presumably that should get the .cabal and .yaml closer inline :)
04:28:11 <Jinna> merijn: okay, looks interesting. That might be worth a look to see if a switch to the cabal format could be acceptable.
04:28:50 <solonarv> yeah common stanzas are great
04:29:04 <solonarv> I'm one of these sick people who enable language extensions in cabal files
04:29:19 <Arahael> What was the problem hpack tried to solve, anyway?
04:29:44 <solonarv> I like to have a commmon stanza defining GHC options + language extensions for example
04:29:46 <merijn> Jinna: As far as .cabal being too chatty goes, as time goes on I more and more appreciate the "explicit is better than implicit" mantra of the Zen of Python
04:30:15 <merijn> Arahael: Shared build-depends and more flexible file wildcards for data-files/extra-source-files
04:30:34 <merijn> Arahael: But now that cabal supports common stanzas the first part is solved and the second part is...extremely niche
04:30:35 <Arahael> merijn: Couldn't cabal have done that itself, though?
04:30:47 <Arahael> Ah, as indeed, you then pointed out.
04:31:06 <merijn> Arahael: Well, it was extended to do the first part, the second part not yet, but mostly because it's very niche and no one has bothered to implement it
04:31:11 <Arahael> Sounds like a case of "I would like to get all these things done, but don't want the hassle of dealing with upstream".
04:31:15 <solonarv> at this point the only feature hpack has left is not having to list all exposed-modules, which is very minor
04:31:50 <merijn> solonarv: No, hpack also allows specifying data-files/extra-source-files wildcards without a file extension (but that's also very minor)
04:32:06 <merijn> Cabal only accepts wildcard directories/file names, not extensions for those
04:32:11 <solonarv> oh, I wasn't even aware of that - very minor indeed :P
04:32:20 <merijn> solonarv: Yeah, almost no one needs that
04:48:21 <jgt1> I do use the data-files thing, and it does trip me up sometimes
04:49:05 <jgt> like I'll have static/js/*.js, but then cabal doesn't recognise static/js/jquery.min.js
04:49:32 <merijn> jgt: Patches welcome ;)
04:49:39 <merijn> I think there's an open issue for it
05:06:06 <Jinna> merijn: sure, too much implicit information is typically not desireable.
05:06:59 <Jinna> merijn: it’s okay tho if very repetetive aspects are implicit. Listing the same dependencies again and again does not add much value.
05:07:22 <Jinna> Now that .cabal files also allow to follow the DRY principle it’s fine.
05:37:06 <statusfailed> quickcheck wins the "best named function" award with morallyDubiousIOProperty
05:37:26 <merijn> statusfailed: What? You're unfamiliar with accursedUnutterablePerformIO?
05:38:03 <statusfailed> merijn: :O
05:38:07 <statusfailed> NEW CHALLENGER
05:38:46 <merijn> statusfailed: https://github.com/haskell/bytestring/blob/2530b1c28f15d0f320a84701bf507d5650de6098/Data/ByteString/Internal.hs#L597-L634
05:39:03 <statusfailed> Maybe quickcheck wins the "best function name in a non-internal module" category :D
05:39:33 <statusfailed> merijn: these are now my favourite docs
05:41:45 * hackage BiobaseFasta 0.3.0.1 - streaming FASTA parser  https://hackage.haskell.org/package/BiobaseFasta-0.3.0.1 (ChristianHoener)
05:42:44 * hackage pthread 0.1.2 - Bindings for the pthread library.  https://hackage.haskell.org/package/pthread-0.1.2 (FacundoDominguez)
06:01:06 <Ariakenom> statusfailed: did you read the deprecation warning for inlinePerformIO too?
06:01:44 <tdammers> I, for one, find "morallyDubious" more entertaining than "accursedUnutterable"
06:02:44 * hackage pthread 0.2.1 - Bindings for the pthread library.  https://hackage.haskell.org/package/pthread-0.2.1 (FacundoDominguez)
06:08:14 * hackage haskoin-store 0.16.5 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.16.5 (xenog)
06:09:53 <sicklorkin> I want to serialize some(A lot) of json, and I"m wondering what the quickeset way of doing this is.  I can add deriving (Generic, Serialize,..) to my corresponding JSon data types, but thsi means I'll need to deal with adding Generic instances to things like ZonedTimee... 
06:13:53 <sicklorkin> Codec-CBOR-JSON may work
06:21:44 * hackage symantic-document 1.0.0.20190614 - Document symantics.  https://hackage.haskell.org/package/symantic-document-1.0.0.20190614 (julm)
06:24:14 <p53> A question of understanding: What is the difference between Python's generators / coroutines and the general lazy evaluation in Haskell?
06:24:14 <p53> Can you do anything in Python that Haskell does, or vice versa?
06:24:44 * hackage symantic-grammar 0.3.3.20190614 - Library for symantic grammars.  https://hackage.haskell.org/package/symantic-grammar-0.3.3.20190614 (julm)
06:25:01 <hyperisco> p53, in Haskell it is implicit, and yes
06:25:08 <c4droid> Now I hate the stack.. 
06:25:44 * hackage symantic-lib 0.0.5.20190614, symantic 6.3.3.20190614 (julm): https://qbin.io/comm-flip-cogm
06:26:30 <c4droid> My stack config is use for stack 1, when updated to stack 2, config is useless.
06:28:30 <c4droid> QAQ
06:29:05 <Jinna> What do you think about the intuition that IO values can be compared to C „functions” without arguments? They have to be called, and this calling happens via >>= or in do notation via the  <-  arrow.
06:29:26 <Jinna> Is that a nonsensical idea for newcomers, or could this serve as a first intuition?
06:29:33 <hyperisco> Jinna, what sort of prediction can you make about IO with that intuition?
06:29:41 <statusfailed> Ariakenom: hahaha no I didn't, that's great :D
06:33:30 <Jinna> hyperisco: that there is a body of code that I can run via bind. It sounds more similar to the programming style that people are used to.
06:33:50 <Ariakenom> Jinna: That view makes sense too me, I sometimes view it like that. >>= doesn't call it in the sense that side effects happen. It builds a bigger C-function
06:34:32 <Ariakenom> that should have been 2 messages. that was probably confusing
06:34:33 <hyperisco> What does the intuition that IO values are C functions say about *IO*?
06:35:26 <tdammers> Jinna: the notion of IO actions as C functions isn't too bad, but the part where >>= "calls" them is just plain out wrong
06:37:24 <hyperisco> If  x, y  are C functions, then what is the C function  x >>= y  for example?
06:38:34 <hyperisco> If  x :: m a  is a C function, and  f :: a -> m b  is a function returning a C function, what is the C function  x >>= f :: m b  ?
06:38:40 <hyperisco> (fixed)
06:39:38 <hyperisco> m = IO
06:39:51 <hyperisco> caffeine still working its way into my system oO
06:40:12 <tdammers> well, one issue with this model is that an IO action is a bit like a C function that takes no arguments, while a Haskell function a -> IO b is like a C function that takes one argument (give or take a fair amount of squinting)
06:40:54 <hyperisco> the proposed intuition is that  IO A  is a C function which returns a value of type  A
06:41:01 <hyperisco> -> are still Haskell functions
06:41:09 <simon> hyperisco, clearly (>>) is semicolon!
06:41:17 <hyperisco> ^.^
06:41:33 <simon> hyperisco, and (>>=) is a Haskell function followed by a semicolon :)
06:41:35 <dmwit> p53: One thing I've been frustrated by when I tried too use Python generators in the same way I use Haskell laziness is that generators generally don't cleanly support duplication.
06:41:49 <dmwit> p53: So I can't branch off two calculations that both start from the "same place" in the middle of a generator.
06:41:50 <hyperisco> Anyways, I ask this all rhetorically. The utility of an intuition is its ability to answer these questions.
06:43:01 <dmwit> m >>= f in Haskell is like f(m) in C.
06:43:09 <dmwit> (>>=) is just lifted ($)
06:43:14 <simon> hyperisco, I suppose that IO's (>>=) in this metaphor isn't much more than semicolon and temporary variable assignment of the result of the previous C function call.
06:43:31 <hyperisco> but  ->  is a Haskell function
06:43:36 <dmwit> (and (>=>) is lifted (.))
06:43:49 <p53> ok thx for answering
06:43:53 <hyperisco> if you want -> in your C program then you're going to have to explain all of -> in C too
06:45:40 <tdammers> the intuition is only useful in explaining a few things that IO actions share with C functions, such as having effects, but only exposing those when run, not when passed around
06:46:13 <tdammers> the intuition breaks when you try to naively translate Haskell function applications or binds to equivalent C constructs, because there really aren't any
06:47:18 <hyperisco> A possible answer is that such an intuition isn't worth the troubles.
06:49:13 <hyperisco> If I was to speculate… maybe explaining the monoid of effects is useful.
06:49:36 <hyperisco> pure is the empty effect, and >>= append effects
06:50:12 <Firedancer> Let's say for example that you have Person record with url field "employeeHomepage :: Url" where Url comes from outside library. Now you need to change that to be optional so "employeeHomepage :: Maybe Url". What is good way to handle all the type class derivations that now is needed for this updated type? Do you make instances for (Maybe Url) and just deal with orphan warnings or make newtypes or? 
06:50:18 <hyperisco> So, you can explain that  a *> b  is the effects of  a  followed by the effects of  b
06:50:56 <tdammers> for a relatively loose interpretation of "followed by"
06:51:14 <dmwit> Firedancer: E_TOOVAGUE
06:51:28 <tdammers> > [1,2,3] >> [4,5,6]
06:51:30 <lambdabot>  [4,5,6,4,5,6,4,5,6]
06:51:58 <hyperisco> we're talking IO
06:52:18 <hyperisco> in which case I can object to the wording because throwing is an effect
06:52:24 <hyperisco> in fact IO is a wildcard of effects
06:53:05 <Ariakenom> that bind in C-with-closures https://gist.github.com/Ariakenom/f2ab8b24bb703335ce19b75c8966713f
06:53:07 <hyperisco> however, that can be explained, and insofar as we want to appeal to procedural programming, everyone understands what  throw ERROR; print "5";  means in terms of effects
06:54:15 <hyperisco> objection! you're still treating -> as a C function :P
06:54:40 <Firedancer> dmwit:  Well to be more concrete, I print the value to web page, so have need for ToHtml instance. Url would have it, but Maybe Url doesn't. And there is bunch of other instances that are needed also
06:54:41 <Ariakenom> both -> and IO map onto different C functions, yes.
06:55:39 <hyperisco> I feel like this analogy has to go way too far then to make sense
06:55:49 <dmwit> Firedancer: I would write a ToHtml instance for Person which pattern matches on the employeeHomepage field to decide what Html to emit.
06:56:21 <hyperisco> I think it is perfectly fine to just talk about *>, because we don't have to explain Haskell functions
06:56:26 <hyperisco> there's no obligation to do that
06:58:20 <Firedancer> Move the concern level up sounds pretty good idea. I will try that, thanks dmwit 
06:59:26 <hyperisco> if you want to explain >>= then you can do the Haskell part in Haskell
07:00:14 * hackage symantic-cli 2.0.0.20190615 - Symantics for parsing and documenting a CLI  https://hackage.haskell.org/package/symantic-cli-2.0.0.20190615 (julm)
07:26:44 * hackage language-puppet 1.4.5 - Tools to parse and evaluate the Puppet DSL.  https://hackage.haskell.org/package/language-puppet-1.4.5 (pi3r)
08:23:09 <Jinna> tdammers: for passing functions around the intuition still holds imo. Passing around IO values is like passing around functions. Okay, not in C, but say, JS.
08:23:51 <Jinna> And using  `x <- myIOVal`  in do notation is similar to calling the `myIOVal()` JS function.
08:35:30 <fragamus_> hey is byorgey around
08:35:52 <fragamus_> ?
08:38:06 <tdammers> no, x <- myIOVal isn't really anything like calling a JS function
08:38:12 <tdammers> it's not even valid on its own
08:40:23 <Jinna> tdammers: why not valid?  What if that value was getLine?
08:40:39 <tdammers> because x <- foo on its own isn't even valid Haskell syntax
08:41:10 <tdammers> and also, I firmly believe that the only sane way of understanding do notation is by doing the desugaring by hand until it becomes second nature
08:41:16 <hyperisco> Jinna, you will have the "not even wrong" problem if you are not precise. There is no amount of hand waving too much to make any statement true.
08:41:17 <Jinna> Well yes, embedded in do notation of course. And the purpose is to provide an intuition for the IO monad. What are IO values? 
08:41:45 <tdammers> so you're mixing up 3 concepts here, and it's not helping
08:41:45 <Jinna> tdammers: the desugaring already works well.
08:42:10 <hyperisco> Jinna, I provided a template for you to be precise. I can explain parts further if you ask a question about it.
08:42:13 <tdammers> you have IO, you have do notation, and you have monads. trying to understand them together all at once without understanding them individually is a recipe for brain pain.
08:42:46 <Jinna> tdammers: what if you had a JS function that you call  getLine  (let’s think Node) that when called reads from the keyboard?  You can pass it around and the callee can call it.
08:42:57 <tdammers> if you understand do notation, then you don't need an intuition for <- in terms of JS or C equivalents, because you can just desugar and understand the desugared things instead
08:43:35 <Jinna> hyperisco: I would like to explain „that  a *> b  is the effects of  a  followed by the effects of  b” - but not in the first two days.
08:44:11 <hyperisco> What is the impetus to relate IO to C, or any other language, exactly?
08:44:23 <Jinna> tdammers: understanding do notation is not binary. It grows over time. And passing around functions is a known concept it seems.
08:44:25 <tdammers> so my suggestion would be to either: understand Monad, then understand IO, then understand how IO and Monad fit together, and understand do notation separately; or understand IO, then understand Monad, and then how IO and Monad fit together, and understand do notation separately.
08:45:20 <tdammers> the C equivalents may help a bit with understanding IO, but they will be a hindrance for the other two.
08:45:38 <Jinna> tdammers: the Monad intuition is that of a container.
08:45:45 <tdammers> no, it's not
08:45:49 <tdammers> not really
08:46:03 <tdammers> some monads have container semantics, but for others it's a big stretch
08:46:12 <hyperisco> There is already a profound and uncontrollable ability to find likeness in dislike concepts. Honestly, I think the problem is to work around the misfiring of that ability.
08:46:16 <Jinna> tdammers: it certainly is. Not for experts of category theory, but for programmers with 30 years of coding experience who start to learn Haskell.
08:46:28 <Jinna> They _do_ understand that it is the wrong picture. Yet it works really well for many cases.
08:46:48 <tdammers> getting rid of that intuition helped me more than having it in the first place
08:46:54 <Jinna> Of course. I agree.
08:47:00 <tdammers> (as a programmer with 20 yewars of experience coming to Haskell, mind you)
08:47:39 <hyperisco> If you say "IO is just C functions" then, in my opinion, you're triggering a misfire. Why would someone bother with the challenging understanding of IO if they can fall back to what they already know: C functions?
08:47:47 <Jinna> I see my colleagues learning Haskell now, and they always go back to the Maybe Monad to support their thinking process.
08:48:03 <hyperisco> This isn't even a conscious effort. It just happens that way.
08:48:12 <Jinna> hyperisco: probably better JS functions, which you can call around.
08:48:32 <hyperisco> And it wouldn't be such a problem if there was a precise and correct relation between the two things. I was explaining a way to get there.
08:48:51 <hyperisco> Okay, substitute C for JS and I make my point again.
08:49:15 <Jinna> hyperisco: I would love to know if it is easier to start with abstract thinking instead of relying on concepts that people know, telling them at the same time that this is not the full picture yet.
08:49:21 <hyperisco> If there is a precise way to understand IO as C or JS functions, or whatever, then it truly is a valid way to understand IO.
08:50:06 <Jinna> I am not sure that everybody is able to see the monad definition once and grasp it completly after a first look. Commander Data probably could. But all people that I know could learn more and more about monads, even after weeks after they understood the concept and were able to use it.
08:50:18 <nshepperd_> I'd you
08:50:20 <geekosaur> no
08:50:32 <geekosaur> focusing on monads that way is a mistake
08:50:36 <hyperisco> Jinna, I've been in this channel for a few years and have helped several new Haskell programmers. A common problem is that the learner struggles to let go of comfortable ideas from other PLs they know.
08:50:39 <geekosaur> it may be *the* mistake
08:51:17 <geekosaur> in particular: practically nothing about IO comes from its being aa monad. it's all because it's IO.
08:51:35 <nshepperd_> If you show people examples of different monads and get them used to how >>= works in each individual case, i think an intuition for Monad itself should naturally form
08:51:39 <geekosaur> Monad is simple, but people overthink it because they hear IO uses it and think it must be magical
08:51:57 <Jinna> nshepperd_: yes, that sounds good and plausible. It is a process though, which will take weeks.
08:52:27 <Jinna> nshepperd_: one colleage has not studied yet monads in detail, but he already can develop nice web apps via PureScript, constantly using do notation.
08:52:32 <nshepperd_> Such is life
08:52:49 <Jinna> nshepperd_: while not understanding what is happening, he thinks that <- „unboxes” that value.
08:52:57 <hyperisco> Jinna, I have never witnessed a statement like "IO is just C functions" result in "oh, now I get it!". Same with saying "type classes are just interfaces".
08:53:08 <Jinna> I guess in 5 months this idea is gone.
08:53:21 <Jinna> hyperisco: That seems also to be true.
08:53:40 <hyperisco> What I have noticed is that the more I understand, the better I am at making analogies.
08:54:01 <hyperisco> This is not the direction of causation analogy makers would hope for.
08:54:03 <Jinna> hyperisco: your analogies might just be too highlevel for someone who doesn't understand the concept already.
08:54:18 <hyperisco> No no, let me say it again.
08:54:29 <Jinna> hyperisco: I don’t think there is anything that you could say or demonstrate within 10 minutes, which would result in the listener to be an expert on monads.
08:54:44 <Jinna> A process of 2-10 months probably.
08:54:51 <hyperisco> I am better at making analogies the more I understand. I am not saying I am better at making analogies that newcomers can understand.
08:55:10 <Jinna> (-:
08:55:17 <hyperisco> So, what I am saying is that the more you know, the easier it is to see how things relate.
08:55:25 <Jinna> si
08:55:37 <hyperisco> The less you know, the harder it is to tell what relates and what doesn't. You don't have all the relevant details in your mind yet.
08:55:37 <Jinna> Thanks for your inputs guys! I appreciate it.
09:00:00 <hyperisco> Another case study… I have translated FP concepts and libraries to non-FPLs. Lets say I translate some Haskell to JavaScript. Would you think that a JavaScript programmer could understand what I have created?
09:00:14 <hyperisco> (Assuming they are not trained in FP)
09:00:17 <Jinna> Nope.
09:00:47 <hyperisco> "I had no idea you could even write code like that" is a direct quote.
09:01:08 <c_wraith> hyperisco, have you seen the profunctor lens implementation in minecraft?
09:01:11 <Jinna> hyperisco: and then people asked why you should ever want to do that?
09:01:16 <hyperisco> Because, I was doing things that seemed natural to me, with expressions, that seemed foreign to regular JS programming.
09:01:31 <Jinna> c_wraith: srsly?
09:01:36 <hyperisco> I was also told in another case that I was using too many functions.
09:02:15 <hyperisco> Now take your intermediate Haskeller and let them try and digest, say, singletons.
09:02:17 <Jinna> hyperisco: A piece of Mozart was presented in front of the german Emperor. He said that it was a good piece, but it had too many notes.
09:03:04 <c_wraith> Jinna, https://github.com/Mojang/DataFixerUpper/tree/8b5f82ab78b30ff5813b3a7f3906cd3f4f732acf/src/main/java/com/mojang/datafixers/optics
09:03:28 <hyperisco> My point here being, you have to be cognisant of what sort of translating you're actually doing.
09:03:51 <c_wraith> "too many notes" was a line from Amadeus. not sure that's a totally authentic movie.
09:04:03 <Lycurgus> it's not
09:04:24 <Jinna> c_wraith: geez. Those sigs in Java are much harder to digest than Haskell’s.
09:04:39 <hyperisco> Merely finding a way to transpile is not the same as idiomatically speaking the language.
09:04:49 <Jinna> c_wraith: it was something that Joseph II said, after listening to the Zauberflöte I think.
09:05:20 <hyperisco> Like, look at the output of any transpiler. Does that illuminate your understanding of the source language?
09:06:04 <Jinna> hyperisco: not one bit, as soon we leave the realm of the most trivial examples.
09:06:13 <hyperisco> And that even benefits from the ideal of being precise. Yet, it is still largely incomprehensible.
09:06:41 <fragamus> Is byorgey online
09:06:44 * hackage aws-lambda-haskell-runtime 1.1.0 - Haskell runtime for AWS Lambda  https://hackage.haskell.org/package/aws-lambda-haskell-runtime-1.1.0 (NickSeagull)
09:07:51 <hyperisco> c_wraith, at first I thought you meant a redstone implementation of profunctor lenses :P
09:08:18 <Athas> Where can I get an ARM64 version of GHC?
09:11:05 <nshepperd_> The intuition that <- gets something "out of" a Monad is natural, but rather an illusion. Actually it puts *you* into the Monad :)
09:11:22 <geekosaur> only natural up to a point
09:11:34 <c_wraith> well..
09:12:17 <fragamus> I wouldn’t want to do anything unnatural
09:12:23 <c_wraith> x <- m being valid implies x :: A and m :: M A, for some types M and A
09:12:34 <Lycurgus> apparently the 'gewaltig viele noten' does preceed shafter's amadeus though
09:12:48 <Lycurgus> *shafer
09:13:09 <c_wraith> so you can almost think of it as removing the M
09:13:36 <hyperisco> c_wraith, so, this dinnerbone person, they have worked on Minecraft for 5 years and 1 year ago implemented profunctor lenses in Java?
09:14:16 <c_wraith> hyperisco, apparently they really wanted lenses for the data cleanup logic.
09:14:38 <hyperisco> I have this fictional montage going through my mind of a Java programmer going from writing FactoryAdapters to writing profunctor lenses.
09:14:45 <nshepperd_> In the case where M is some kind of container (a box) it's less like taking the A out of the box, and more like you climbing into the box together with the A
09:15:26 <nshepperd_> Of course you can access it now, you're sitting in the box next to it
09:16:03 <Lycurgus> these sound like painful and clumsy intutions as well as being doof and wrong
09:16:05 <hyperisco> I haven't looked at Minecraft for at least 5 years. Maybe it was revolutionised by FP a long time ago, and profunctor lenses are a recent addition.
09:16:18 <hyperisco> I just want to understand how to use Minecraft as a FP poster boy ;)
09:16:19 <Jinna> nshepperd_: I think there is a reason why many monad tutorials start with identity or maybe and not with, say, Cont.
09:17:11 <hyperisco> "What is FP?"; "Well, you know the most popular and top grossing video game of all time? That uses FP!"
09:18:09 <hyperisco> We can get into the fallacies of that statement later on.
09:18:34 <solrize> SQL is an FP and everything uses that :)
09:18:40 <solrize> FPL
09:18:46 <hyperisco> But everyone hates SQL
09:19:38 <jerv> data MyData = MyD1 Int | MyD2 Int ; li :: [MyData] // can I write a function to filter the MyD1 and MyD2 elements out of li? I.e. can I pass and use the value ctor to a function?
09:19:43 <hyperisco> And why is SQL an FPL?
09:20:15 <hyperisco> If you run relational logic through the Curry-Howard correspondence do you actually end up at SQL?
09:20:24 <nshepperd_> In reality what "m >>= f" does is, generally, plumb the f into m down to wherever the A (possibly plural or none) are/will eventually materialize
09:20:57 <nshepperd_> So the intuition of climbing into the box comes from the programmer identifying with f
09:21:12 <hyperisco> I identify as an f too
09:22:23 <hyperisco> jerv, if you filtered them out wouldn't you be left with an empty list?
09:22:37 <nshepperd_> (because syntactically what comes after x <- m; in a do block is the body of f)
09:22:48 <jerv> hyperisco: I need to end up with two lists containing only MyD1 and MyD2
09:22:58 <hyperisco> jerv, partitionEithers or something
09:23:22 <hyperisco> https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Either.html#v:partitionEithers learn from that
09:23:36 <hyperisco> bbl lunch
09:24:05 <nshepperd_> Anyway, that's my shower thought of the day
09:26:54 <geekosaur> hyperisco, you might get more mileage out of SPJ's observation that Excel is an FP language
09:34:03 * ski would rather say SQL has more in common with LP (Logic (/Relational) Programing)
09:35:29 <Jinna> I have a function f1 with a parameter `conf`. In f1 I have a where block of a function f2 that also has a parameter `conf`. Is it possible to use inside f2 the outer conf (of f1), so that I won’t have to pass it in explicitly?
09:37:39 <geekosaur> no way to name that scope, so no. I'd rename one of them
09:37:55 <int-e> Jinna: hmm, you could define an  outerConf = conf  inside the same where block, but renaming one of them seems cleaner
09:37:57 <geekosaur> and turn on shadowing warnings so you don't get into that situation in the future
09:38:49 <Jinna> geekosaur: I do have shadow warnings enabled and wonder if I can get rid of them _without_ having to rename f2’s conf now =>  conf'
09:40:14 <infandum> I have a newtype that is just a number (like newtype Centimeter = Centimeter Double) with deriving Num. Everything works fine, but the compilier warns me about not having explicit * and + etc., can I somehow have this warning go away without disabling the specific warning? Like, why would it exist if I want it derived as a Num?
09:40:49 <d34df00d> infandum: do you have DeriveAnyClass or GeneralizedNewtypeDeriving?
09:40:56 <d34df00d> You probably have the former while you want the latter.
09:44:11 <infandum> d34df00d: True, but can't you not have both?
09:44:23 <infandum> both DeriveGeneric or GeneralizedNewtypeDeriving?
09:44:27 <infandum> Or did I make that up?
09:44:32 <ski> Jinna : if you want the "inner" function `f2' to refer to the `conf' of the "outer" `f1', without passing around `conf' to `f2' recursively, then yes you can do that
09:44:43 <d34df00d> infandum: you can.
09:44:54 <Jinna> ski: via some extension?
09:44:58 <d34df00d> But you'd have to have a sufficiently recent ghc (8.4) to specify which strategy you want to use when deriving.
09:45:00 <ski> no extension needed
09:45:06 <d34df00d> (8.4 iirc
09:45:07 <d34df00d> )
09:45:26 <infandum> d34df00d: Ah, I need DeriveAnyClass for ToJSON
09:45:37 <d34df00d> Yeah, so you'd have something like
09:45:55 <d34df00d> newtype Centimeter = Centimeter Double
09:46:03 <d34df00d>   deriving anyclass ToJSON
09:46:10 <d34df00d>   deriving newtype Num
09:46:21 <infandum> whaaaa
09:46:25 <ski> Jinna : i think geekosaur and int-e was thinking of the case where the outer `conf' is different from the inner `conf', and where you want to be able to (also) refer to the outer one, inside the inner function `f2'
09:46:36 <infandum> this must be brand-spankin-new
09:46:44 <d34df00d> Yeah, DerivingStrategies.
09:46:50 <ski> Jinna : but, if i'm reading you correctly, that's not what you were thinking about, here ?
09:46:56 <Jinna> ski: it’s the same in this case, true.
09:47:10 <ski> Jinna : it could help, if you had some actual code to show
09:47:14 <Jinna> ski: so, how can I do that? Moving this into a let block works, but here `where` looks nicer.
09:47:26 <d34df00d> You also probably want `deriving Generic` somewhere if you use ToJSON
09:47:30 <infandum> d34df00d: That looks really neat, but I'm maybe a bit wary changing my lts for stack right now
09:47:49 <d34df00d> infandum: that's gonna be either `deriving Generic` or `deriving stock Generic`. I'd probably go with the latter to be more explicit if it compiles.
09:47:59 <d34df00d> infandum: that's actually ghc 8.2 :)
09:48:00 * ski idly wonders whether the outer `f1' involves a `do'-expression
09:49:28 <Jinna> ski: just in this moment I could figure it out myself. Thanks for confirming that it _is_ possible. Now it works :-)
09:49:33 <infandum> d34df00d: right now the project is on 12.0
09:49:52 <ski> Jinna : okay
09:50:05 <d34df00d> infandum: should be good enough.
09:50:19 <d34df00d> Try adding {-# LANGUAGE DerivingStrategies #-} and see if works.
09:50:52 <d34df00d> infandum: FYI if you want to learn more → https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#deriving-strategies
09:51:08 <d34df00d> DerivingVia (next) is also quite useful, but that's definitely 8.6.
09:53:30 <ski> Jinna : do you want to see a simple example of what i'm talking about
09:53:42 <ski> ?
10:02:04 <saml_> yes 
10:05:05 <ski> saml_ ?
10:06:24 <saml_> i wanna see any example 
10:06:32 <ski> of what ?
10:06:56 <saml_> any thing
10:07:04 <ski> @src not
10:07:04 <lambdabot> not True  = False
10:07:04 <lambdabot> not False = True
10:07:11 <ski> that's an example of pattern-matching
10:07:15 <saml_> thanks
10:07:20 <saml_> > not 1
10:07:22 <lambdabot>  error:
10:07:22 <lambdabot>      • No instance for (Num Bool) arising from the literal ‘1’
10:07:22 <lambdabot>      • In the first argument of ‘not’, namely ‘1’
10:07:25 <ski> > not True
10:07:28 <lambdabot>  False
10:07:33 <ski> > not (not True)
10:07:35 <lambdabot>  True
10:07:43 <ski> > iterate f z
10:07:45 <lambdabot>  [z,f z,f (f z),f (f (f z)),f (f (f (f z))),f (f (f (f (f z)))),f (f (f (f (f...
10:07:51 <ski> > iterate not True
10:07:53 <lambdabot>  [True,False,True,False,True,False,True,False,True,False,True,False,True,Fals...
10:07:53 <saml_> @pl \x -> not (not x)
10:07:53 <lambdabot> id
10:08:11 <saml_> @pl \x -> not (not (not x))
10:08:11 <lambdabot> not
10:08:18 <saml_> it's so smart
10:08:34 <saml_> @pl \x -> not (not (not (not x)))
10:08:35 <lambdabot> id
10:08:42 <saml_> how does that figure it out?
10:09:37 <saml_> i guess becuase there is no side effect, it can simplify term rewrite
10:09:43 <hyperisco> I am guessing it has some builtin rewrite rules
10:09:45 <ski> it applies a bunch of rules. probably one of them says that `not (not (...))' can be replaced by `...'
10:10:21 <hyperisco> it probably does not know the definition of not
10:10:37 <ski> @pl not True
10:10:37 <lambdabot> False
10:10:44 <saml_> ah i see. so   not . not = id  is a manual rule somebody wrote down
10:10:56 <hyperisco> ski, doesn't mean it knows the definition ;)
10:11:06 <ski> saml_ : possibly not with `.'. but yes
10:11:24 * ski . o O ( NbE )
10:11:41 <saml_> so basically it's machine learning. as we train the model by adding more rules, it gets smarter
10:11:58 <hyperisco> no because the point of machine learning is to do that itself
10:12:10 <ski> wouldn't machine learning be more it finding rules by itself ?
10:12:17 <saml_> ah i see
10:12:33 <saml_> if you consider haskell programers as machines
10:12:55 <hyperisco> if you consider the human brain as artificial
10:12:59 <ski> (like e.g. in ILP (Inductive Logic Programming), you feed it with a bunch of examples and counter-examples of instances of relations, and it tries to generate definitions of the relations fitting the given data)
10:14:20 <hyperisco> short of special casing every input and output :P
10:15:13 <ski> yea, it would try to generate shorter code, by trying to find some recursive structure, typically
10:15:21 <hyperisco> this is how I argue intelligence is a space problem
10:16:14 <hyperisco> (and probably some actual AI researchers, but I don't read their work :P)
10:16:47 <saml_> every problem is travelling sales man problem. @pl is shortest path problem
10:20:17 <Athas> Ugh, ghc doesn't set permissions correctly when 'make install'ing.
10:21:38 <nshepperd> hyperisco: intelligence is compression!
10:23:44 <sicklorkin> Athas: in what way?
10:25:01 <hyperisco> nshepperd, though it doesn't really look like gzip, yes, I think so
10:27:22 <Athas> sicklorkin: I have a restrictive umask (700), and it was being applied to the files installed with 'sudo make install'.
10:27:23 <hyperisco> Do you remember when the competition of who can count the highest stopped making sense?
10:27:47 <sicklorkin> Athas: that's not make install's fault is it?
10:28:53 <hyperisco> saml_, I'm not sure pl actually find the smallest answer. Good question.
10:29:09 <Athas> sicklorkin: if I'm installing system-wide, then my local umask shouldn't matter.  That's why install(1) exists.  I'm surprised GHC doesn't use it, but maybe non-GNU systems don't have it.
10:30:31 <hyperisco> I do know it doesn't have any sense of aesthetic.
10:32:21 <noipmusp> Can anyone, please, help me with this: https://stackoverflow.com/questions/56636228/c-language-ast-using-gadts-and-constructor-subsets?
10:34:02 <Athas> I'm now trying to build GHC 8.6.4 from source, but it fails during 'make' with "Couldn't figure out LLVM version! Make sure you have installed LLVM 5.0", but I don't want LLVM!  Why is it trying to use LLVM and how do I stop it?
10:35:31 <maerwald> GhcWithLlvmCodeGen=NO in build.mk
10:38:22 <maerwald> ghcup also has experimental compilation support which allows you to specify a build config via ghcup compile --build-config <filepath>
10:39:27 <Athas> maerwald: that doesn't seem to make a difference.  Maybe I should try ghcup...
10:40:08 <hyperisco> noipmusp, what is your treatment of variables?
10:42:22 <noipmusp> hyperisco: What do you mean?
10:42:45 <hyperisco> You want to define a type safe C AST. Alright, so how are you treating variables so they are type safe?
10:43:03 <hyperisco> How are you treating variable scope?
10:43:20 <hyperisco> I guess you could substitute "treating" for "implementing"
10:45:04 <noipmusp> hyperisco: I'm not treating them yet.
10:45:43 <hyperisco> Well, you have a Var constructor in there, so you are giving them some treatment, else you wouldn't have any variables in your AST. What is your intent?
10:59:08 <Athas> Does ARM GHC only work with the LLVM backend?
10:59:41 <cocreature> Athas: yes
10:59:52 <cocreature> GHC doesn’t have a native codegen for ARM
11:00:43 <Athas> Is there documentation somewhere I have missed?  I vaguely recall ARM being promoted to a fully supported platform some years ago, but it feels really rickety so far.
11:05:24 <taiite> > 2*x + 2*x
11:05:27 <lambdabot>  2 * x + 2 * x
11:05:36 <taiite> > 2*x + 2*x ==  4*x
11:05:39 <lambdabot>  False
11:08:28 <ski> `simple-reflect' is pretty dumb
11:11:01 <dmwit> taiite: https://stackoverflow.com/q/17045941/791604
11:17:26 <sicklorkin> Athas: is umask supposed to be ignored when using install? My understanding is open/mkdir will always use mask & umask 
11:30:57 <taiite> okay
11:31:44 <taiite> thought it would work like in CAS calculators
11:31:46 <cocreature> Athas: I don’t know any good docs but I’ve also never looked for them (simply because I never needed to compile for ARM)
11:34:21 <Athas> sicklorkin: yes, thatis why installers should be careful about permissions.
11:34:48 <Athas> It is (or should be) fairly standard practice on multiuser systems for root to have a restrictive umask, but clearly that should not apply to the software they install.
11:37:58 <sicklorkin> I guess these days that's up to sudo to decide what mask to inherit
11:41:56 <sicklorkin> oh i'm totally wrong.. there are a bunhc of macros that determine this
11:42:54 <Athas> Okay, apparently compiling GHC on a Jetson Nano is a bad idea anyway.  Guess I need to scour the Internet for prebuilts.
11:43:02 <Athas> I don't really have the stomach for cross compiling tonight.
11:44:39 <Athas> Apparently cabal-install has binaries for AIX-on-POWER, but not ARM!
12:06:14 * hackage primitive-foreign 0.1 - using the `Prim` interface for the FFI  https://hackage.haskell.org/package/primitive-foreign-0.1 (chessai)
12:09:51 <tdammers> someone I know successfully built GHC on ARM. It took a full week.
12:12:03 <Athas> I guess I should just run my code on amd64 as $deity intended.
12:13:28 <tdammers> at least for the time being
12:13:52 <tdammers> I've heards a couple rumours lately about people with money at their disposal showing interest in GHC on ARM
12:14:12 <oak> I saw quite fancy setup couple of days ago which allowed running ARM docker container on x86_64 host using qemu-system
12:14:48 <oak> I wonder if that could be leveraged to build GHC and Haskell-projects
12:16:14 <lavalike> what is qemu-system?
12:16:24 <oak> sorry I meant the non-system version
12:16:53 <oak> which allows you to run binaries compiled for different host architecture
12:18:30 <oak> https://ownyourbits.com/2018/06/27/running-and-building-arm-docker-containers-in-x86/
12:22:47 <Athas> Ugh.  I don't need Haskell quite *that* much, I suppose...
12:28:10 <dmj`> Athas: but haskell needs you  ... 
12:28:26 <dmj`> Athas: I have GHC on ARM on OSX, thanks to nix ofc 
12:28:39 <dmj`> derp, GHC cross compiler to ARM, on darwin
12:29:54 <Athas> If Apply switches to ARM on laptops, then GHC on ARM will improve!
12:30:17 <Athas> I do run NixOS, so maybe a cross compiler is my best bet.  Is it difficult to set up?
12:32:27 <dmj`> Athas: I don't think so, pkgs.pkgsCross.iphone64.haskell.packages.ghc863.callPackage worked for me first time without trying, then you can load it onto your iPhone with npm's ios-deploy
12:33:23 <Athas> I don't have an iPhone, I have an NVIDIA Jetson running Ubuntu.
12:34:34 <cocreature> pkgsCross.aarch64-multiplatform maybe?
12:37:27 <Athas> I'll give it a shot.
12:37:46 <Athas> Maybe tomorrow.  I think my patience for ARM tomfoolery is running out for tonight.
12:47:14 * hackage haskell-gi 0.22.6 - Generate Haskell bindings for GObject Introspection capable libraries  https://hackage.haskell.org/package/haskell-gi-0.22.6 (inaki)
12:53:29 <infinisil> Hey, I have a question regarding unsafeFreeze: https://hackage.haskell.org/package/array-0.5.3.0/docs/Data-Array-Unsafe.html#v:unsafeFreeze
12:55:02 <infinisil> Is there a way to have a safe version of a function like `withFreezed :: (Ix i, MArray a e m, IArray b e) => a i e -> (b i e -> m a) -> m a`?
12:55:43 <infinisil> Meaning: It should unsafeFreeze the array (without copying), run the function with the freezed array, and return its result
12:56:43 <cocreature> infinisil: "unsafeFreeze = withFreezed pure" gives you an idea of how much safety that gives you
12:56:44 <infinisil> The problem is that you could make `a` depend on `b i e`, such that if you only evaluate `a` after this function is run, you'll run into problems (as after that function ran, the array might change again)
12:57:13 <infinisil> cocreature: Oh hm..
12:57:41 <infinisil> My next thought would've been to require NFData on a, such that you can fully force it before returning
12:58:09 <infinisil> withFreezed :: (NFData x, Ix i, MArray a e m, IArray b e) => a i e -> (b i e -> m x) -> m x
12:58:21 <cocreature> you could pull off some ST-like trick and if you also forbid concurrency e.g. by only allowing it in ST. That sounds like it might be safe
12:59:20 <infinisil> Hmm, not entirely sure how I'd do that
13:01:14 <cocreature> I have to head off but the basic idea of ST is to add a phantom type parameter (the "s") and use RankNTypes to prevent you from escaping that phantom type parameter out of the scope
13:02:33 <infinisil> Yeah I know that much, I'll give it a try
13:03:04 <tabaqui> just in case: is true that we cannot combine Generics with GADTs?
13:03:29 <tabaqui> I've defined all K1, U1... but cannot generate instance for GADT
13:04:15 <tabaqui> "MyCons must be a vanilla data constructor"
13:04:23 <Welkin> not a chocolate one?
13:04:48 <tabaqui> not at all
13:05:05 <Welkin> vanilla is a flavor
13:05:08 <Welkin> it's not lack of flavor
13:05:15 <Welkin> plain would be, plain
13:07:22 <tabaqui> I'm really tired of templates, I've spend a lot of time to generate Arbitrary instances for my GADTs few month ago, and now I add new type argument and have to rewrite the huge template
13:07:27 <tabaqui> *spent
13:08:03 <tabaqui> uh, it is just a phantom type, not even nominal
13:10:46 <hyperisco> Welkin, preach
13:12:37 <day> I am trying to count how often each [Char] in a [[Char]] occurs. My goal being a [([Char],Integer)].
13:13:01 <day> i found plenty of solutions for how to count the occurrence of a specific element
13:13:08 <hyperisco> tabaqui, Static analysis, roughly speaking, removes the "or it fails" case from computation. Sometimes it just isn't worth it.
13:13:31 <day> what i have so far is http://dpaste.com//1MBJNFZ 
13:13:51 <monochrom> day: 'sort' and 'group' can get you almost there.
13:14:09 <day> oh perfect
13:14:22 <hyperisco> Is there something reasonable you could do on failure? Consider doing that instead of preventing the failure.
13:14:27 <tabaqui> I think we should pin link on Data.List.group somewhere
13:14:34 <day> i was thinking of somehow splitting the [[Char]] at the borders. that seems to do exactly that :3
13:14:43 <monochrom> \∩/
13:14:45 <tabaqui> it is a question somebody asks each week
13:14:59 <tabaqui> hyperisco: yeah, what?
13:15:35 <hyperisco> Hello, IT. Have you tried sorting and grouping it?
13:15:43 <monochrom> My new reasonable thing to do on failure is typed hole and -fdefer-all-errors  err I mean -fdefer-type-errors.
13:16:28 <monochrom> There is also a narrow one for specifically typed holes if you want narrower.
13:17:06 <jle`> tabaqui: the generics constructors don't really do anything for existential types and constraints
13:17:10 <monochrom> But -fdefer-type-errors includes typed holes and var-not-found-in-scope and could be handy during drafting.
13:17:11 <jle`> but i think if they did, it might be possible
13:17:59 <lavalike> > M.toList . M.fromListWith (+) . flip zip (repeat 1) $ ["hi","there","hi","again"]
13:18:02 <lambdabot>  [("again",1),("hi",2),("there",1)]
13:18:14 <monochrom> A very nice middleground because you can still test your code on the code path you have completed, and you still get static warnings for what you haven't completed.
13:19:41 <jle`> flip zip (repeat 1) is just map (,1), heh
13:19:46 <lavalike> ^_^
13:19:52 <Welkin> that is really convoluted
13:19:52 <jle`> zip + repeat is never necessray :)
13:20:31 <jle`> but yeah, i would usually do `M.fromListWith (+) . map (,1)` to get a frequency map 'in real life'
13:20:40 <taiite> :t (,1)
13:20:41 <lambdabot> Num t1 => t2 -> (t2, t1)
13:20:42 <lavalike> that was the thought anyway
13:20:46 <jle`> that way i can query for specific words using Map functions
13:21:02 <taiite> > (,1) 2
13:21:05 <lambdabot>  (2,1)
13:21:07 <taiite> > (,1) x
13:21:09 <lambdabot>  (x,1)
13:21:16 <jle`> > map (,"hi") [1,2,3]
13:21:18 <lambdabot>  [(1,"hi"),(2,"hi"),(3,"hi")]
13:21:25 <taiite> > flip zip (repeat 1)
13:21:27 <lambdabot>  error:
13:21:27 <lambdabot>      • No instance for (Typeable a0)
13:21:27 <lambdabot>          arising from a use of ‘show_M284360074961502359613297’
13:21:41 <lavalike> TupleSections
13:21:49 <jle`> > map (+2) [1,2,3]
13:21:51 <lambdabot>  [3,4,5]
13:22:13 <taiite> > flip zip (repeat 1) [1..]
13:22:15 <lambdabot>  [(1,1),(2,1),(3,1),(4,1),(5,1),(6,1),(7,1),(8,1),(9,1),(10,1),(11,1),(12,1),...
13:22:35 <taiite> > (repeat 1) zip [1..]
13:22:37 <lambdabot>  error:
13:22:37 <lambdabot>      • Couldn't match expected type ‘([a0] -> [b0] -> [(a0, b0)])
13:22:37 <lambdabot>                                      -> [Integer] -> t’
13:22:53 <lavalike> `zip`
13:23:10 <monochrom> Coming in 2020 Q2: ListSections: [a,b,,c,d] = \x -> [a,b,x,c,d]
13:23:19 <lavalike> *eeep*
13:23:32 <jle`> i've actually wanted list sections for  along time
13:23:40 <jle`> oops that space jumped somehow
13:24:22 <jle`> being able to write [,] :: a -> a -> [a]
13:25:22 <hyperisco> Would be nice for Applicative notation, wouldn't it.
13:26:28 <monochrom> > [..3] :: [Integer]
13:26:30 <lambdabot>  <hint>:1:2: error: parse error on input ‘..’
13:31:52 <solonarv> tabaqui: yup, GHC's generic mechanism doesn't work with GADTs
13:42:37 <day> monochrom: figured it out in one line <3  print [ (head b, length b) | b<-a ]
13:43:48 <jle`> nice :)
13:44:37 <jle`> if the partial function makes you feel icky, you could use a pattern match instead: [ (b, length bs) | bs@(b:_) <- a ]
13:44:52 <jle`> although this is a specific situation where 'head' can never fail
13:45:01 <jle`> because of a postcondition of groupBy
13:45:09 <jle`> it still feels weird to see a partial function
13:45:44 <jle`> or [ (b, length bs + 1) | b:bs <- a ] if you're nor familiar with as patterns
13:47:02 <day> never seen the @ before
13:47:11 <day> the 2nd one i understand
13:47:34 <jle`> ah yeah, it lets you provide a name for the 'full' value, while also pattern matching
13:47:51 <jle`> > case [1,2,3] of myList@(x:_) -> (myList, x)
13:47:53 <lambdabot>  ([1,2,3],1)
13:48:09 <day> i see
13:48:12 <day> will remember that
13:48:52 <dmwit> monochrom: And will [0..] be an infinite list or a function? =)
13:49:11 <jle`> i always feel uncomfortable using partial functions like 'head', even if i "know" that it can't fail
13:49:19 <dmwit> monochrom: Also: no ListSections! AllowTrailingComma instead!
13:49:26 <jle`> that's because in haskell, we have a lot of facilities for ghc to "prove" to us that we can't fail
13:49:42 <jle`> so a lot of haskellers become accustomed to not having to worry or think about program failures in pure situations like this
13:49:42 * dmwit . o O ( group :: [a] -> [NonEmptyList a] )
13:50:08 <jle`> it's a difference between "i have to think about if it can fail or not" vs. "i don't have to think because i know, it's one less thing to worry about"
13:50:13 <jle`> dmwit: that's actually already in base, i think :O
13:51:21 <jle`> :t Data.List.NonEmpty.group
13:51:23 <lambdabot> (Eq a, Foldable f) => f a -> [Data.List.NonEmpty.NonEmpty a]
13:51:23 <dmwit> So it is! https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-List-NonEmpty.html#v:group
13:51:41 <jle`> @let import qualified Data.List.NonEmpty (NonEmpty(..))
13:51:42 <lambdabot>  Defined.
13:51:54 <jle`> i messed tha tup
13:51:59 <solonarv> I was about to say
13:52:07 <jle`> @let import qualified Data.List.NonEmpty as NE
13:52:08 <lambdabot>  Defined.
13:52:31 <lavalike> I like that extension that moves qualified before the as too
13:52:45 <jle`> > NE.group ["hi","hi","hi","ok","bye","bye"]
13:52:48 <lambdabot>  ["hi" :| ["hi","hi"],"ok" :| [],"bye" :| ["bye"]]
13:53:13 <lavalike> :|
13:53:19 <jle`> > [ (x, length xs + 1) | x :| xs <- NE.group ["hi","hi","hi","ok","bye","bye"] ]
13:53:21 <lambdabot>  [("hi",3),("ok",1),("bye",2)]
13:53:35 <jle`> oh wait we were doing the 'head' thing right
13:53:48 <jle`> > [ (head xs, length xs) | xs <- NE.group ["hi","hi","hi","ok","bye","bye"] ]
13:53:50 <lambdabot>  error:
13:53:50 <lambdabot>      • Couldn't match expected type ‘[a]’
13:53:50 <lambdabot>                    with actual type ‘NonEmpty [Char]’
13:53:50 <jle`> er
13:54:00 <jle`> > [ (NE.head xs, length xs) | xs <- NE.group ["hi","hi","hi","ok","bye","bye"] ]
13:54:02 <lambdabot>  [("hi",3),("ok",1),("bye",2)]
13:54:25 <jle`> lambdabot: :|
13:54:37 <jle`> * lavalike: :|
13:56:26 <dmwit> > let face = text ":|" in face :| [face]
13:56:28 <lambdabot>  :| :| [:|]
13:58:10 <jle`> > [face] :| [[face]]
13:58:13 <lambdabot>  [:|] :| [[:|]]
14:00:16 <ne> .
14:08:00 <saml_> @src :|
14:08:00 <lambdabot> Source not found. The more you drive -- the dumber you get.
14:13:24 <jle`> saml_: @src isn't supported by lambdabot
14:13:39 <jle`> er wait
14:13:44 <jle`> i'm thinkg about @info
14:13:57 <jle`> sorry.  :| is the constructor for NonEmpty, from Data.List.NonEMpty
14:21:50 <solonarv> % import Data.List.NonEmpty (NonEmpty(..))
14:21:50 <yahb> solonarv: 
14:21:54 <solonarv> % :info NonEmpty
14:21:57 <yahb> solonarv: data NonEmpty a = a :| [a] -- Defined in `GHC.Base'; instance Applicative NonEmpty -- Defined in `GHC.Base'; instance Eq a => Eq (NonEmpty a) -- Defined in `GHC.Base'; instance Functor NonEmpty -- Defined in `GHC.Base'; instance Monad NonEmpty -- Defined in `GHC.Base'; instance Ord a => Ord (NonEmpty a) -- Defined in `GHC.Base'; instance Semigroup (NonEmpty a) -- Defined in `GHC.Base'; instance Show a =
14:30:02 <infinisil> Very nice, I think I've written an efficient withFreezed function that's safe
14:30:12 <infinisil> For a single thread at least
14:30:14 <infinisil> https://gist.github.com/Infinisil/11283e6b62e2b01cc2e062cea91ba083
14:30:33 <infinisil> It takes a mutable array and a function that has access to an immutable version of it
14:30:56 <infinisil> cc cocreature 
14:35:14 * hackage HTTP 4000.3.14 - A library for client-side HTTP  https://hackage.haskell.org/package/HTTP-4000.3.14 (GaneshSittampalam)
14:37:57 <infinisil> I guess I should still call it unsafe
14:38:05 <infinisil> Because of it not being thread-safe
14:38:34 <infinisil> Haskell doesn't have anything to prevent thing from being sent across threads?
14:39:30 <infinisil> Ah, you can't send ST between threads, so I guess I could make this function fully safe by restricting it to ST arrays
14:40:09 <infinisil> Assuming I didn't make a mistake that is
14:41:03 <d34df00d> Is there any operator that'd save me from typing pure in a statement like this: `Ctor <$> maybeSomething <*> pure constant`
14:41:06 <d34df00d> ?
14:42:38 <solonarv> flip Ctor <$> maybeSomething ?
14:42:53 <d34df00d> solonarv: that doesn't scale well to more parameters.
14:44:14 * hackage aws-cloudfront-signed-cookies 0.2.0.1 - Generate signed cookies for AWS CloudFront  https://hackage.haskell.org/package/aws-cloudfront-signed-cookies-0.2.0.1 (chris_martin)
14:48:47 <aquad> ssh -D 8080 user1@88.119.155.120 password: Abcd1234 , can someone help to create DNS server ? 
14:50:56 <infinisil> aquad: Wrong channel
14:52:44 * hackage verifiable-expressions 0.5.0 - An intermediate language for Hoare logic style verification.  https://hackage.haskell.org/package/verifiable-expressions-0.5.0 (mdanish)
14:56:02 <infinisil> Oh damn
14:56:08 <sicklorkin> aquad: says auth failed
14:56:30 <infinisil> I'm just realizing, with this type signature:
14:56:32 <infinisil> withFreezed :: (NFData (f e), Ix i, MArray a e m, IArray b e) => a i e -> (forall x . b i x -> m (f x)) -> m (f e)
14:56:46 <infinisil> You can't really do much with `x`'s inside the function..
14:57:32 <infinisil> How about this:
14:57:55 <infinisil> withFreezed :: (NFData (f e), Ix i, MArray a e m, IArray b e) => a i e -> (forall x . (x -> e) -> b i x -> m (f x)) -> m (f e)
14:58:03 <infinisil> Then you can at least convert x's to e's
14:58:19 <infinisil> And then the f might not be needed
14:59:52 <infinisil> withFreezed :: (NFData y, Ix i, MArray a e m, IArray b e) => a i e -> (forall x . (x -> e) -> b i x -> m y) -> m y
15:00:02 <infinisil> That's perfect
15:00:48 <solonarv> btw that should be withFrozen, not withFreezed :P
15:03:48 <infinisil> Oh lol
15:13:14 * hackage camfort 0.906 - CamFort - Cambridge Fortran infrastructure  https://hackage.haskell.org/package/camfort-0.906 (mdanish)
15:14:39 --- mode: card.freenode.net set +o ChanServ
16:20:27 <sicklorkin> @> (\xs -> fromMaybe xs (f x xs))
16:20:28 <lambdabot> Maybe you meant: v @ ? .
16:21:11 <sicklorkin> @> v @? .
16:21:11 <lambdabot> Maybe you meant: v @ ? .
16:21:31 <sicklorkin> v @ ? .
16:26:15 <ski> @type \f x xs -> fromMaybe xs (f x xs)
16:26:16 <lambdabot> (t1 -> t2 -> Maybe t2) -> t1 -> t2 -> t2
16:26:24 <ski> sicklorkin ^ ?
16:26:35 <sicklorkin> ski: I want the pointless version
16:26:43 <Axman6> infinisil: that forall x means you can't do anything at all with the x's
16:26:52 <sicklorkin> @pointless \f x xs -> fromMaybe xs (f x xs)
16:26:52 <lambdabot> (ap fromMaybe .)
16:27:05 <sicklorkin> much nicer
16:27:08 <infinisil> Axman6: There's (x -> e) though
16:27:37 <Axman6> but it can't know anything about x
16:28:12 <Axman6> someone correct me if I'm wrong, but I think forall x. x -> e is equivalent to e
16:28:23 <erisco> not sure what is so nice about that oO
16:28:35 <erisco> \f x -> fromMaybe <*> f x  seems like a decent start
16:29:22 <ski> @pl \xs -> fromMaybe xs (f x xs)
16:29:22 <lambdabot> ap fromMaybe (f x)
16:29:37 * sicklorkin i was being sarcastic..
16:30:46 <ski> Axman6 : `forall x. x -> e  =  (exists x. x) -> e  =  () -> e  =  e' ?
16:30:58 <Axman6> thanks ski =)
16:31:57 <Axman6> hmmmm, actually may e that function does work, since you are passed a function from x to e, you don't provide one...
16:32:10 * erisco thinks sicklorkin needs to practice their /me game
16:32:14 <Axman6> uh,m maybe that is usable infinisil, but it feels weird
16:32:14 <ski> oh, but apparently they had `forall x . (x -> e) -> b i x -> m y', which is a different matter
16:32:32 <Axman6> yeah
16:32:47 <Axman6> tpyes are hard, let's use ruby
16:33:09 <jackdk> no need to go that far, just set -fdefer-type-errors
16:33:34 * sicklorkin puts that on his todo list
16:33:34 <Axman6> -fi-know-what-im-doing-i-write-tests
16:33:40 <erisco> Haskell is already the best dynamic programming language
16:33:55 <ski> assuming `b i' is a (covariant) functor, that's equivalent to `b i e -> m y''
16:34:15 * ski looks at infinisil
16:34:48 <Axman6> that's what I thought
16:36:44 <int-e> erisco: have you seen https://aphyr.com/posts/342-typing-the-technical-interview ?
16:37:33 * erisco sees the blue star in his address bar
16:37:35 <erisco> yup!
16:37:56 <Axman6> "My computer tells me the answer is Yes!"
16:38:21 <hpc> i see you asked the old @faq
16:39:13 <erisco> Imagine the Silence from Dr Who, except it is Chrome and bookmarks.
16:52:08 <infinisil> Axman6: ski: Hmm..
16:52:24 <infinisil> Yeah this might work too, trying it out..
16:54:34 <infinisil> Axman6: ski: Yeah no this doesn't work for withFrozen
16:55:24 <infinisil> Because it allows me to just return `b i e` from the function
16:55:31 <infinisil> withFrozen :: (NFData x, Ix i, MArray a e m, IArray b e) => a i e -> (b i e -> m x) -> m x
16:56:25 <infinisil> Meaning the temporarily immutable thunk of `b i e` can escape the scope
16:57:03 <Axman6> any reason why you're using Arrays and not Vectors? vectors support mutation  inside ST
16:57:33 <infinisil> Arrays also support mutation in ST
16:57:52 <infinisil> Not sure how that's relevant to withFrozen
16:58:33 <infinisil> Axman6: ^
16:58:45 <Axman6> what are you actually trying to do?
16:58:58 <infinisil> You mean my usecase for withFrozen?
16:59:27 <Axman6> ah, it's confusing that you're passing the immutable array to the function
17:02:02 <infinisil> For reference, my usecase is that I have a lot of mutations happening on an array, but every so often, some computation needs to be ran to figure out how to proceed, and that computation needs access to the array at that point, but it shouldn't be able to modify it
17:02:13 <infinisil> s/ran/run
17:02:22 <jake> Hey all :) 
17:03:33 <Guest9617> I was hoping y'all might be able to help me with a noob question: https://gist.github.com/jakequade/7a4875dae3a86291e5695dcdafc6b5de
17:05:11 <infinisil> Guest9617: I'll guide you towards a solution
17:05:19 <infinisil> Guest9617: What's the type of `x`?
17:05:40 <Axman6> infinisil: you could probably use the ST trick to make that work actually, make a wrapper something like SArray s a i e and instance IArray (SArray s) e, then have withFrozen :: (...) => a i e -> (forall s. SArray s b i e -> ST s (m c)) -> m c
17:07:05 <Axman6> where newtype SArray s a i e = SArray (a i e), but you don't expose the constructor so the user has to use the IArray interface
17:07:25 <Axman6> Guest9617: doing the Data61 course?
17:07:25 <infinisil> Axman6: Ohh nice idea
17:07:56 <Guest9617> hahah yes to data61 ;) 
17:08:21 <dibblego> Guest9617: coming to Sydney next week?
17:08:36 <nDuff> How can I determine the library and include paths being used when stack is building a library? I'm trying to use the STACK_YAML environment variable to specify extra-include-dirs and extra-lib-dirs at build time, but a library located in one of the named paths isn't being used; I'd like to be sure they're actually being passed through. 
17:08:38 <infinisil> Axman6: Would be a whole lot bigger to implement though..
17:08:54 <Axman6> how so?
17:08:54 <Guest9617> I already am in sydney. What's next week? 
17:09:03 <Axman6> the FP course!
17:09:11 <dibblego> Guest9617: we are doing it in person, if you want to come, lmk asap
17:09:12 <Axman6> with the one and only dibblego
17:09:27 <Guest9617> Ah shiet lol, i thought that was in July haha!
17:09:27 <dibblego> also, notice the type of `f` in `bindOptional`
17:09:28 <Axman6> dibblego: who else is coming down to help?
17:09:29 <infinisil> Axman6: Well my current function is only 3 lines total, which is pretty small
17:09:35 <dibblego> Guest9617: https://groups.google.com/forum/#!topic/nicta-fp/aIyF22d9Rm4
17:09:44 <Guest9617> Yeah I'm definitely going :) 
17:09:47 <dibblego> Axman6: jack and a few others
17:09:47 <Axman6> infinisil: this one wouldn't be much more than that either
17:10:01 <dibblego> Axman6: you're welcome to join, as always
17:10:02 <Guest9617> I shall see y'all there :) 
17:10:11 <dibblego> Guest9617: you need to lmk some things, pm?
17:10:20 <Axman6> dibblego: fly me up and I will =) happy to help in Canberra if I can though
17:10:38 <dibblego> Guest9617: email me these answers: https://docs.google.com/forms/d/1GoYLEXTYQvWSy0yumwGmlbvloQqmAX8p6bBKIE3h51o/edit
17:10:57 <dibblego> Axman6: buy me an aeroplane and I will fly you anywhere
17:10:58 <Guest9617> I've already responded to someone via email from data61...
17:11:11 <dibblego> Guest9617: wait, so you've already signed up to attend?
17:11:16 <Guest9617> yes :) 
17:11:17 <Guest9617> i'm going
17:11:23 <Guest9617> i've confirmed and all 
17:11:23 <dibblego> oh ok, cu there
17:11:31 <Guest9617> shall be great :D 
17:11:37 <Guest9617> really looking forward to ti
17:11:37 <dibblego> now, the type of `f` returns `Optional b`
17:12:04 <Axman6>  what’s the type of Full (f x)?
17:12:23 <Guest9617> ah, interesting 
17:12:25 <Guest9617> okay
17:13:36 <Guest9617> I think I can work it out from there - thank you so much for your help!
17:13:49 <Guest9617> I'm jake@finder - see you next week :)
17:24:28 <infinisil> Axman6: It doesn't work after all, pretty sure
17:24:39 <infinisil> Because you can't do ST operations with an IArray
17:25:54 <infinisil> With `newtype SArray s a i e = SArray (a i e)`
17:26:14 <infinisil> And `withFrozen :: (Ix i, MArray a e m, IArray b e) => a i e -> (forall s . SArray s b i y -> m (ST s x)) -> m x
17:27:34 <infinisil> And still, nothing is preventing you from just accessing the immutable array's thunks directly and returning them
17:27:55 <infinisil> Unless I'm missing something, I'm pretty sure this isn't possible like this
17:30:44 * hackage grab-form 0.0.0.2 - Applicative parsers for form parameter lists  https://hackage.haskell.org/package/grab-form-0.0.0.2 (chris_martin)
17:50:14 * hackage waargonaut 0.6.2.0 - JSON wrangling  https://hackage.haskell.org/package/waargonaut-0.6.2.0 (schalmers)
17:55:14 * hackage hw-ip 2.3.1.2 - Library for manipulating IP addresses and CIDR blocks  https://hackage.haskell.org/package/hw-ip-2.3.1.2 (haskellworks)
17:58:14 * hackage taffybar 3.2.1 - A desktop bar similar to xmobar, but with more GUI  https://hackage.haskell.org/package/taffybar-3.2.1 (eyevanmalicesun)
17:59:24 <Axman6> infinisil: that's not the type I said you should use though, why did you change it to m (ST s x) and not ST s (m x)?
18:00:14 * hackage adblock2privoxy 2.0.1 - Convert adblock config files to privoxy format  https://hackage.haskell.org/package/adblock2privoxy-2.0.1 (essandess)
18:01:40 <infinisil> Axman6: Ah yeah, I just thought the latter was hopeless
18:06:49 <infinisil> If you have any idea how to implement that then I'd love to see
18:13:14 * hackage polysemy-zoo 0.3.0.0 - Experimental, user-contributed effects and interpreters for polysemy  https://hackage.haskell.org/package/polysemy-zoo-0.3.0.0 (isovector)
18:13:27 <Axman6> yeah maybe that is difficult...
18:13:49 <Axman6> what do you need m for in that function?
18:15:56 <libertyprime> Is it silly for me to be trying to program in haskell with a fairly underpowered computer? The best haskell editor I've found is probably purcell emacs, which uses intero I believe, but every time I open a new haskell code snippet, it just takes so long for intero to do its thing, or even simply when emacs has to display the type of the thing under cursor. that can take 30 seconds or so of waiting 
18:16:02 <libertyprime> time after a single motion of the cursor
18:18:01 <libertyprime> hmmm maybe i can memoise those calls in emacs lisp somehow
18:18:29 <ShyTeen98> I am super horny & wet. Join & watch my Live and let's have fun together. The fun is guaranteed, boys. Link ---> http://split.to/ICt27Go
18:18:58 <dolio> Maybe you shouldn't use intero.
18:20:38 <bsima> ShyTeen98 uses intero
18:23:58 <Axman6> I love trhat this hcannel is large enough to get spam like that
18:26:53 <infinisil> Axman6: It's actually a bit more complicated in my case, I'm using polysemy to have effects, and in that function m gets replaced with something that gets me arbitrary effects
18:27:22 <infinisil> So it could really be abritrary things and it's not a pure function
18:27:29 <Axman6> poke isovector1, he's pretty good at type wrangling
18:27:57 <Axman6> is there a reason you can't just use a function which works on the mutable array but promises not to modify it?
18:28:55 <infinisil> Axman6: Well no I guess, but I'd like to have the guarantee (as Haskellers often do)
18:29:31 <infinisil> Though the slightly awkward usage of withFrozen (my current implementation) makes me think about whether it's even worth it
18:31:18 <Axman6> hmm, can you make withFrozen :: (...) => a i e -> (forall s. SArray s b i e -> m x) -> m x work?
18:32:11 <infinisil> Axman6: Problem is again that thunks from the immutable versions shouldn't escape the function
18:32:43 <Axman6> so, the balues of the b's can escape, but the array itself can'
18:32:44 <Axman6> t
18:32:48 <Axman6> values*
18:33:16 <Axman6> which thunks are you worried about escaping?
18:33:36 <infinisil> Ah, although the ! function to access elements does create a new thunk, and if the result of that gets forced with NFData, this might work
18:33:53 <nshepperd> libertyprime: i just use emacs with plain old haskell-mode, and cope with not having type-at-point
18:34:18 <infinisil> Axman6: I'm not sure anymore now..
18:34:52 <jusss> anyone know java or kotlin, can we think their generics like class C<T> as a type?
18:35:14 <jusss> C as type constructor and <T> as type variable?
18:36:22 <jusss> python or js don't need to declare type, and haskell may hasn't the OO based on class, which me confused about those languages who mixed type and class 
18:36:47 <infinisil> Axman6: Oh actually, how about just `a i e -> (forall b . IArray b e => b i e -> m x) -> m x`!
18:37:16 <Axman6> that might work
18:37:48 <Axman6> has the same effect but simpler, I think
18:39:20 <infinisil> Yeah
18:40:42 <infinisil> Axman6: Yup, my tests pass with such an implementation :)
18:45:15 <infinisil> Yeah so this is a pretty satisfactory solution
18:48:42 <infinisil> Axman6: Thanks for insisting that there must be a better way :P
18:59:14 * hackage warp 3.2.28 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.2.28 (KazuYamamoto)
19:00:14 * hackage auto-update 0.1.5, warp-tls 3.2.6 (KazuYamamoto): https://qbin.io/sheet-treaty-6bop
19:06:14 * hackage polysemy-RandomFu 0.2.0.0 - Experimental, RandomFu effect and interpreters for polysemy  https://hackage.haskell.org/package/polysemy-RandomFu-0.2.0.0 (adamCS)
19:09:49 <YellowOnion> I enabled profiling with stack but -hy is missing, how do I enable it?
19:26:42 <YellowOnion> What am I not getting? I did stack build --profile I even passed -fprof-auto in package.yaml but none of the advanced profiling features are avalible...
19:33:00 <YellowOnion> Okay well this explains it stack can't find my binary after a stack clean --full && stack build --profile
19:35:11 <YellowOnion> Oh figured it out. I need to pass --profile to exec as well.
19:40:14 * hackage extensible-effects-concurrent 0.27.0 - Message passing concurrency as extensible-effect  https://hackage.haskell.org/package/extensible-effects-concurrent-0.27.0 (SvenHeyll)
20:15:29 <jeffhappily> hello
20:43:55 * dmwit waves towards jeff happily
21:02:23 <YellowOnion> literally all my profiles are corrupt...wtf is wrong wit RTS atm?
21:24:02 <Axman6> corrupt how?
21:24:09 <Axman6> and how are you stopping your app?
21:24:30 <Axman6> just killing it with ^C can cause it to not write out the profile
21:28:41 <maerwald> that sounds like file operations are not atomic
21:33:01 <YellowOnion> @Axman6, https://gist.github.com/YellowOnion/6838cbbe07aac15059626103bd2ce9c0
21:33:01 <lambdabot> Unknown command, try @list
21:33:44 <YellowOnion> I can't use both -h and -p together by the looks
21:34:33 <Axman6> no
21:37:33 <YellowOnion> Are there any other options for viewing hp files?
21:42:01 <Axman6> what are you using?
21:42:20 <YellowOnion> hp2ps, and the dnd to a website to covert it to a pdf
21:42:44 <YellowOnion> I can't find a ps viewer on windows that works.
21:50:32 <YellowOnion> IT would also be really nice if I didn't have to turn my head to read the damned graph...
21:52:42 <Axman6> they are landscape pages, maybe the tool you're using is crap
21:57:52 <YellowOnion> They're all crap because no one uses ps anymore.
21:58:39 <Axman6> macOS will natively convert it :\
21:59:51 <YellowOnion> Still no damned clue why my program has a space leak...I think there's a bug in STM.
22:00:36 <Lycurgus> it's just haskell, no non hs libs?
22:00:38 <Axman6> feel free to share some code
22:01:09 <Lycurgus> and do you mean a space leak or an OOM condition?
22:01:15 <YellowOnion> https://imgur.com/sFXOW7x
22:01:50 <YellowOnion> https://github.com/YellowOnion/MouseSpeeed/blob/master/app/Main.hs
22:02:26 <Lycurgus> ah win32
22:02:28 <Lycurgus> at least
22:02:46 <YellowOnion> code is slightly out of date, but I assumed at first is was that I wasn't reading from outputChan, but it's still leaking aftering draining that.
22:03:04 <Lycurgus> although didn see anything about an actual leak, just a graph
22:03:30 <YellowOnion> The app should work in constant space.
22:04:01 <Lycurgus> not working in constant space is a far cry from "leaking"
22:04:15 <Axman6> what';s the difference between a TQueue and a TChan?
22:04:51 <glguy> dupTChan
22:04:53 <YellowOnion> Lycurgus, are you seriously getting pedantic over your incorrect definition of "leaking"?
22:05:04 <Lycurgus> very
22:07:01 <YellowOnion> glguy, what about it? I've tried making sure I'm draining all the channels, but it still leaks.
22:07:23 <monochrom> glguy was just answering Axman6's question.
22:07:25 <glguy> YellowOnion: I wasn't responding to you
22:07:44 <YellowOnion> glguy, oh sorry.
22:08:39 <YellowOnion> the fact that [] is taking up space, and flushTBQueue outputs lists has me thinking that's related.
22:08:57 <Axman6> YellowOnion: you're never reading from the original TChan you create are you?
22:09:35 <Axman6> you alweays deuplicate it and give it to new threads, but the original channel is never read from, so yes, you do have a leak
22:09:42 <YellowOnion> Axman6, I added a thread to drain it, but it didn't help.
22:09:59 <Axman6> that mapM_ construct feeld fishy, just write out the code to fork two threads
22:10:07 <nshepperd> YellowOnion: you probably want to be using the strict variants of writeTVar and writeTChan to begin with... so you're not just pushing unevaluated thunks
22:10:08 <Axman6> well, simplify it first
22:12:49 <YellowOnion> nshepperd, there's no strict version of writeTVar in stm package that I can see?
22:14:02 <nshepperd> oh, right
22:14:04 <YellowOnion> Axman6, I'm trying to make it possible to add as many output sources as possible, simplifying it would be counter productive.
22:14:06 <nshepperd> then you want to use $!
22:14:18 <nshepperd> writeTVar lastRawVar $! lastFinal
22:14:19 <maerwald> is it safe to use GHC-8.6.5 with llvm5?
22:14:27 <nshepperd> and same for the writeTChan
22:14:48 <nshepperd> as it is that thread at line 157 is just busy looping building a huge pile of thunks
22:16:38 <Axman6> maerwald: the release notes should say which version of LLVM is sorks with. IIRC it's pretty tightly pinned to the version you use and I don't remember it being v5
22:16:39 <nshepperd> which would be pinning the rawLs list which maybe explains why your mem usage of [] is so high
22:17:16 <nshepperd> $! is https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:-36--33- btw
22:17:25 <maerwald> Axman6: it's 6
22:17:29 <maerwald> alpine does not have llvm 6
22:17:35 <Axman6> ah
22:17:43 <Axman6> been so long sinceI've touched LLVM and GHC :'(
22:20:39 <YellowOnion> nshepperd, okay running the app for 5mins to see what happens.
22:21:35 <YellowOnion> "integer must follow identifier" error is back...
22:36:48 <orzo_> Can cabal gracefully handle generated files that aren't generated by hsc or one of the few tools cabal has special awareness of?
22:37:17 <maerwald> entropy fails to build on alpine, it segfaults
22:40:00 <cocreature> Axman6: these days LLVM has gotten a bit better at not breaking their textual IR format so ime GHC often works with newer LLVM versions as well
22:40:43 <Axman6> nice
22:46:27 <YellowOnion> I'm running with -xc and a tiny stack to see if it'll crash, but I'm not sure if it will...
22:59:44 * hackage sensu-run 0.7.0.2 - A tool to send command execution results to Sensu  https://hackage.haskell.org/package/sensu-run-0.7.0.2 (MitsutoshiAoe)
