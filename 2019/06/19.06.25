01:21:37 <MarcWeber> What is progress on haskell to .js and Webassembly talking about lazy loading ?
01:27:12 <merijn> MarcWeber: Haskell to .js there's ghcjs and (iirc) UHC has 2 different JS backends, GHC webasm is a work in progress, not sure about the current state
01:27:28 <merijn> I believe there's quite a lot of work needed to implement all the necessary primops in webasm
01:35:46 <tdammers> and to make it properly useful, a bunch of FFI-based libraries too
01:36:21 <merijn> Sure, but that's step one :)
01:47:42 <solrize> hey i upgraded ghc to 8.6 and interactive-haskell-mode in emacs stopped working.  do i need to upgrade haskell-mode.el and any idea how to do that?  M-x package-install haskell-mode doesn't even find the mode thanks.  
02:02:35 <_d0t> hi! How do I convert accelerate vectors to vectors from the vector package?
02:41:24 <bollu> merijn yeah the current state is getting the primops up and running
02:41:33 <bollu> merijn and also fixing bugs by running it against the GHC testsuite...
02:41:55 <bollu> merijn recently got most of the numerics/ tests working from the testsuite
02:59:09 <kaychaks[m]> I want to step down a level in a tree zipper based on the current index of a list that is being folded. I.e. for the fold `foldl' f (Tree a, Zipper Top (Tree a)) [a]` where I start with a tree and top zipper I want to do operation on the tree via the zipper as I fold each item of the list (`[a]`). what're some ways to pass on zipper across fold operation as the moment I step down zipper's type changes. saving it to the
02:59:09 <kaychaks[m]> tape is also not helping.
03:01:53 <kaychaks[m]> essentially each index of the folding list signifies the depth of the tree that I need to scan so at each fold I need to go one level down, look for any `rootLabel` that might be equal to `a` from the list. If it is then move on to the next level. If not then add a new sub-tree at that level with `rootLabel` equal to `a`
04:08:25 <ilmu> :t put
04:08:27 <lambdabot> MonadState s m => s -> m ()
04:29:00 --- mode: ChanServ set +o Sigyn
06:05:56 <noipmusp> Is there any more readable alternative to "fmap . fmap"?
06:06:34 <mniip> getCompose . fmap . Compose
06:09:08 <Taneb> noipmusp: \f -> fmap (fmap f) ?
06:09:35 <Taneb> What's more readable depends on circumstance
06:09:47 <noipmusp> I mean, "fmap . fmap" is not so obvious.
06:10:14 <lavalike> :t fmap fmap fmap
06:10:16 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
06:10:52 <hyperisco> noipmusp, lenses
06:10:59 <lavalike> (;
06:12:12 <guest-597> Is it possible to write a webapp in Haskell or are there easier alternatives? Want to give it a shot / learn a new language but don't know if it's the right tool for the job
06:13:02 <lavalike> quite possible!
06:13:17 <geekosaur> there are a number f packages whose goal is to help you write webapps of various kinds (and by various techniques some of which are more or less Haskell-specific)
06:13:30 <lavalike> https://wiki.haskell.org/Web/Frameworks
06:13:32 <tdammers> server-side is quite comfortable
06:13:44 <tdammers> client-side, you would have to go through ghcjs, which is still a bit thorny
06:13:56 <geekosaur> that is, you;re not doing things like servant's type level stuff in most languages
06:15:15 <tdammers> geekosaur: frankly, I'm still not 100% convinced servant's type-level magic actually pulls its weight - but you can still reap a lot of benefits from the type system with a less sophisticated approach, even with something like Scotty, the types help tons
06:17:03 <dmwit> Nik05: For what it's worth, I find `fmap . fmap` quite readable.
06:17:03 <geekosaur> I said nothing about pulling its weight, just that there are some tricks that are essentially Haskell-specific takes on it
06:17:16 <Zer000> I need a little bit of help. I'm getting "Encountered missing dependencies" when I build with nix-build (http://dpaste.com/0T7VRBF.txt), but if I use nix-shell and run cabal-build everything is fine. This is the cabal file I'm trying to build http://dpaste.com/0VKFZM5.txt and here is the default.nix http://dpaste.com/244AW20.txt
06:17:16 <dmwit> noipmusp: That was for you, not Nik05 (sorry Nik05!).
06:17:21 <geekosaur> or styles if you prefer
06:17:33 <guest-597> Ok I will give it a shot then. And is there a learning resource that's recognised as the best? I saw people on reddit mentioning the haskellbook or get programming with haskell quite often but in every other thread those were mentioned negatively again as being too long etc
06:18:25 <dmwit> noipmusp: If the instances have more familiar, more monomorphic names, you could consider using those for a slight readability boost (e.g. `map` instead of `fmap`).
06:18:41 <Zer000> What I really don't understand is why it would show "krpc" as a missing dependency when the package i'm trying to build is the only one relying on it and i've removed that dependency. https://packdeps.haskellers.com/reverse/krpc
06:18:44 <lavalike> WAI comes to mind too
06:18:53 <dmwit> guest-597: You know what they say about opinions.
06:19:39 <geekosaur> Zer000, nix has its own ideas of how things work, vs. using nix to provide deps but letting cabal-install decide how things work
06:20:53 <Lears> Zer000: Have a quick check there's no .ghc.env* file in there; cabal generates them and they confuse nix.
06:22:23 <Zer000> Lears, No there's no such file :(
06:24:13 <Zer000> geekosaur, I think it still calls cabal since that's where the exception originates
06:25:01 <geekosaur> it does but it constrains it as much as it can, because nix is a control freak
06:25:09 <geekosaur> that's more or less how nix works
06:28:40 <Zer000> ah ok. So I didn't have the src specified and it was somehow smart enough to get it from somewhere else rather than use my local version. that explains the phantom deps
06:28:52 <Zer000> stupid mistake, except I thought I checked for that already
06:38:45 <halogenandtoast> Is there a good way to change this to use the width lens for grid instead of the hard coded width here? https://gist.github.com/halogenandtoast/ae2ab9e13ede25d8c2cdfdfdc3cc2f0d
07:17:39 <bollu> When I use DataKinds, how do I "access" the value at the kind level in a computation? https://gist.github.com/bollu/0baea28d2c2889e14afc3b975d12f305
07:21:16 <hyperisco> bollu, you have to reflect it, so you will have some type class constraint on smax that contains a definition to obtain a value
07:21:57 <hyperisco> also you're trying to use smax at the value level
07:22:32 <bollu> yeah, I "just" want dependent types :)
07:22:38 <hyperisco> for Int specifically I think there's a builtin constraint but I don't rememberâ€¦ check the docs
07:22:43 <bollu> I see, OK, thanks
07:23:00 <Welkin> why not independent types?
07:23:07 <hyperisco> freedom types
07:26:48 <halogenandtoast> Is there a good way to change this to use the width lens for grid instead of
07:26:48 <halogenandtoast>                          the hard coded width here?
07:26:49 <halogenandtoast>                          https://gist.github.com/halogenandtoast/ae2ab9e13ede25d8c2cdfdfdc3cc2f0d
07:26:58 <halogenandtoast> sorry copy and paste failed hardcore
07:41:28 <halogenandtoast> or is making a traversal like that impossible?
07:45:27 <borkbork[m]> hello folks
07:45:31 <borkbork[m]> any rules for this room?
07:48:52 <mniip> borkbork[m], common sense
07:49:04 <mniip> this is a public channel for everyone, for haskell discussion
07:49:07 <mniip> that should be enough
07:49:19 <borkbork[m]> fair
07:49:49 <borkbork[m]> what kinda stuff are people working on?
07:50:04 <mniip> all kinds of stuff
07:50:09 <borkbork[m]> I wanna get more into Haskell but I'm not sure what I want to make yet
07:50:12 <mniip> haskell is a general purpose language, can be used in many areas
07:50:56 <mniip> I would say it particularly excels in syntactic computation
07:51:01 <halogenandtoast> borkbork[m]: I am replacing an API I wrote in rails with Haskell, as well as trying to make an implementation of the boardgame 1830
07:51:04 <mniip> from symbolic/automatic differentiation to compiler implementation
07:51:25 <mniip> but other than that - general purpose language
07:51:43 <nitrix> Currently, I'm trying to prove that detecting biconnected components in a graph can be O(1) if the graph has a specific lattice shape. Also, it stays O(1) as the shape changes.
07:52:02 <nitrix> The best known algorithm currently gives O(|V| + |E|).
07:53:11 <nitrix> It's for my little sandbox space game :>
07:53:33 <borkbork[m]> <nitrix "Currently, I'm trying to prove t"> That's neat. Have you identified a category or group that these lattices fall under?
07:55:22 <nitrix> My world is a 2D grid of 32x32 tiles. As long as it's a the vertices connects two adjacent tiles north/south/east/west, it seems to hold.
07:56:19 <borkbork[m]> oooooooo
07:56:29 <nitrix> What happens is some sort of concentric effect where the perimeter sometimes passes through the same tile, which tells you if removing the tile leads to disconnected components.
07:56:43 <borkbork[m]> That sounds fun - are you using a game engine with Haskell or are you just building from scratch?
07:56:53 <nitrix> Of course I'm using Haskell :)
07:57:19 <borkbork[m]> Oh yeah, I mean in addition to Haskell
07:57:41 <nitrix> I built it. The Haskell ecosystem isn't too great when it comes to game stuff. We have SDL bindings but that's pretty much it.
07:59:06 <nitrix> The language being pure forced me to re-think a lot of how you normally approach game development. You cannot just keep pointers and mutate anything willy-nilly, it's interesting.
07:59:22 <nitrix> Entity Component Systems (ECS) are also really fascinating when made pure.
07:59:35 <nitrix> They become some funny automata.
07:59:49 <nitrix> Anyhow :P
08:02:44 <borkbork[m]> interesting
08:02:54 <borkbork[m]> Is your project on github?
08:07:16 <nitrix> It /is/ but a lot of the code dates of 2 years ago and is an absolute mess, so I'd rather finish cleaning it up because sharing it :)
08:07:30 <nitrix> You learn an aweful lot of Haskell in 2 years.
08:07:48 <nitrix> s/because/become/
08:07:56 <nitrix> s/become/before/
08:08:56 <jgt> you learn a lot in two years, and the old code you revisit is always cringeworthy. And *then* you think "thank fuck GHC makes this actually feasible to change"
08:10:09 <borkbork[m]> fair cop
08:10:20 <borkbork[m]> well if you end up getting an updated commit posted, please do share
08:10:33 <borkbork[m]> sounds like a good project to check out
08:11:07 <maerwald> never understood why people want to "clean up" their projects before sharing it. We're not in school :P
08:11:20 <maerwald> no one is judging :)
08:11:53 <tdammers> idk, remove secret keys and such?
08:12:07 <maerwald> xD
08:12:13 <tdammers> (which is kind of idiotic, because you shouldn't have those in your repo in the first place, but here we are)
08:12:54 <maerwald> just revert the commit that added the secrets... done!
08:13:03 <monochrom> Add correct but relaxed bounds to *.cabal so it's more buildable by more people. Because we're not in school.
08:13:08 <[exa]> like, purge the most embarrasing parts a bit, can we?
08:13:23 <borkbork[m]> I feel like eitherway its the choice of the individual dev
08:13:33 <borkbork[m]> Some peeps just wana be sure before they share I guess
08:14:57 <maerwald> monochrom: code review all your dependencies before relaxing upper bounds?
08:16:22 <siraben> Can I write (forall (a : A), Op U a = Op a U /\ Op U a = a) with Haskell-style infix constructors? (i.e. a `Op` U)
08:16:31 <siraben> Oops, uh, wrong channel.
08:17:22 <monochrom> I don't actually do that, but my code are neither for security nor mission-critical. Also, I just mean relaxing from x==3.1.4.1 to x^==3.1.4 (or is it ^>=?)
08:17:26 <c_wraith> when I first get something working, it often is full of incomplete explorations of alternative ideas. when I want to clean something up before sharing it, it's to remove those bits so that what I share is actually the relevant part.
08:17:46 <monochrom> In many cases I don't even have *.cabal to begin with. Because you're not in school but I am!
08:18:05 <c_wraith> also, to remove ugly embarrassing uses of Debug.Trace :)
08:18:34 <dexterfoo> hi. there was a new error handling library released recently but I can't find it
08:18:46 <monochrom> There are also a whole lot of "Right x <- decodeJSON ..." I keep doing.
08:19:05 <c_wraith> hah, yes. those too.
08:19:08 <monochrom> Also in C when I call malloc I don't check for NULL.
08:19:27 <maerwald> savage!
08:19:30 <c_wraith> dexterfoo, what was unique/interesting about it?
08:19:49 <monochrom> You see, precisely you are not in school, I need to fix up my code being showing you! Because you may actually run it!
08:20:03 <monochrom> s/being/before/
08:20:08 <c_wraith> as opposed to your students?
08:21:05 <nitrix> maerwald: If you seen this code, you'd get nauseous. Lots of IORefs and other nonsense. I don't want to encourage others to walk in those steps :P
08:21:12 <monochrom> I already announce to my students "for simplicity I won't be checking NULL". And King's book does the same too, so I feel better.
08:21:34 <dexterfoo> c_wraith: it let you structure your code so that your error handling code is adjacent to the code you are calling. so i guess a nicer way to write try/catch
08:21:49 <c_wraith> doesn't glibc malloc never return NULL anyway?
08:22:17 <monochrom> Yeah I sometimes use that as rationalization too.
08:22:33 <maerwald> c_wraith: dude, portability.
08:22:35 <nitrix> Unless you exhaust the virtual memory space. Much harder than physical memory but still possible.
08:22:58 <c_wraith> dexterfoo, hmm. doesn't ring a bell. hopefully someone else remembers it. 
08:23:30 <mniip> nitrix, how does modern GHC handle soft realtime
08:24:33 <nitrix> mniip: I'm not an expect on the matter at all :P I know the GC is multicore, that probably helps.
08:24:54 <c_wraith> maerwald, I'm pretty sure no non-trivial C program is portable across the entire range of malicious compliance with the spec possible.
08:25:07 <nitrix> mniip: Afaik, the heaps are local to each thread.
08:25:36 <maerwald> c_wraith: I'm also wondering what level of OCD it would require to attempt that xD
08:26:44 <dmwit> mniip: I think the standard answer to that is "manually start GC often, and never put enough in memory that one GC overruns your budget".
08:27:12 <ocharles> edwardk: what ghcid options are using again?
08:29:57 <nitrix> mniip: Were you asking this because of the game thing? I'm getting a good framerate. Lots of garbage but they stay in the nursery, it's a non-issue. My real performance bottleneck was the IORef and Weak abuse I was doing.
08:30:20 <nitrix> Oh and stable pointers. Those seems to incur a really huge tax on the GC.
08:31:25 <nitrix> I have sinced moved to an entity ID system and appropriate data structures to look entities up, instead of doing pointer magic.
08:33:56 <dmwit> nitrix: I would bet that finding biconnected components in grid-like graphs is exactly as hard as finding biconnected components in planar graphs. Planar graphs are probably strictly more difficult to write proofs about, but might be easier to do literature search about.
08:34:30 <dmwit> (In case you didn't know that keyword for your searches yet. If you did, you can probably ignore me entirely.)
08:34:56 * nitrix scribbles down "Planar graphs". Thanks!
08:36:55 <dmwit> nitrix: https://link.springer.com/chapter/10.1007%2F3-540-54233-7_146 looks like exactly what you want, but ouch, SpringerLink
08:37:16 <[exa]> isn't the algorithm for biconnected components roughly the same as for strongly connected ones?
08:37:35 <nitrix> "This is the first sublinear-time algorithm known for this problem."
08:37:38 <nitrix> Challenge accepted >:D
08:38:17 <dexterfoo> c_wraith: i found it: "on-error". it was hard to find because it's not on hackage.  https://github.com/Simspace/on-error
08:38:39 <dmwit> [exa]: I think the goal here is to do better than the standard algorithm, given that we know the graph is planar.
08:38:49 <dmwit> (Well, grid-based, which is even more restricted than planar.0
08:39:58 <[exa]> well, some 4 years ago I went to a full semester course in school called "dynamic graph connectivity algorithms" where the guy was basically only describing the only known log-time algorithm for maintaining 2-connectivity information on a dynamic graph with delete and backtrack possible
08:40:40 <[exa]> as far as I remember planarity won't help a lot
08:41:03 <[exa]> gridness could, since you get quite a good guarantee on maximum vertex degree
08:41:26 <[exa]> (the dynamic algorithm was making "roundabouts" for converting the whole graph to max degree 3)
08:43:44 <nitrix> Correct. You get at most 4 vertex. Most updates is updating the current grid cell book-keeping information; when it degenerates, it may propagate to those 4 adjacent cells, but since you need to be connected to one of those to be considered part of the same component, it never propagates very far.
08:44:44 <nitrix> You do need a really interesting book-keeping method though, with something that's equivalent to pointers to propagate change in a way that stays O(1).
08:45:00 <[exa]> not sure it helps mathematically, since any planar graph can easily be "encoded" in a grid graph
08:45:33 <[exa]> I'll try to find an author of the article, IIRC it was the guy who wrote Simpsons btw
08:46:23 <[exa]> the structure was pretty brutal, there were additional graph levels for making the mass bookkeeping easy, and a 'telescoping induction' which was just pure magic
08:47:52 <nitrix> It does require a pretty crazy book-keeping strategy. I've simplified it a lot, but I have to prove I didn't break any of its properties.
08:48:07 <nitrix> Because it's no longer obvious that "it works".
08:48:39 <dmwit> Ah, good, here's a way to explode a node of degree n from a planar graph into something suitable for use in a grid graph without affecting biconnectivity: make a fully-connected 2xn rectangle.
08:48:42 <nitrix> Anyway, it's cool to know you guys care. When I'm done doing my proper homework on this I'll share :)
08:49:53 <dmwit> (This gives you n connection points on top, and any pair of them have two distinct paths from one to the other: go clockwise or counterclockwise around the rectangle.)
08:50:28 <nitrix> You're getting warmer to how I'm doing it :)
08:51:13 <nitrix> Except you have to account for holes in the rectangle.
08:51:32 <nitrix> e.g. your planar graph forms an "O" shape.
08:52:09 <nitrix> That gives it an inner perimeter and an outer perimeter.
08:52:11 <dmwit> Oh, no, I'm just trying to prove that solving this for grids is just as hard as solving it for planar graphs in general.
08:52:34 <dmwit> I expect there's a reduction in both directions, though, yes.
08:52:40 <[exa]> dmwit: convert planar graph to pixels, convert pixels to grid, win. :]
08:52:50 <dmwit> (Oh, sure, there's an obvious reduction in the other direction: the identity one. =)
08:53:24 <nitrix> I'm not particuliarly math savy and also am a big fan of Feynman. If I use rubber bands, it'll instinctively work :P
08:53:24 <dmwit> [exa]: Not quite. Because as you said nodes in the grid have degree at most 4. So you have to prove that whatever construction you use preserves biconnectivity.
08:54:45 <dmwit> [exa]: (Like, your construction doesn't make an isomorphic graph, even if you contract all the vertices of degree 2.)
08:55:37 <[exa]> dmwit: planar graphs may be converted to sequences of making "ears" on cycles (to recreate the 2-connected part of the graph) and adding the tree-ish rest, right?
08:56:17 <dmwit> That's more or less what I proposed, I think. The fully-connected 2xn rectangle is just a cycle with some extraneous edges that I didn't actually need.
08:56:23 <nitrix> If all else fails, is there such thing as "montecarlo" proof? Implement it (with some stats tracking), then randomly add/remove tiles and see if after billions of iterations the connectivity holds and the stats stayed as predicted?
08:56:39 <nitrix> ;-;
08:56:53 <[exa]> dmwit: you don't even need the full connection, just a cycle is enough (moreover full connection isn't griddish)
08:57:33 <dmwit> nitrix: Heh. That won't be proof, but it will be evidence. But see also that one paper whose summary is "the set of SAT problems that force you out of polynomial time is of measure zero even if P/=NP".
08:57:38 <[exa]> nitrix: "common in industry"
08:58:07 <[exa]> but it invites picky people who invent good counterexamples
08:58:08 <nitrix> Alright, I'll try to do better than that :]
08:58:31 <dmwit> [exa]: Not a clique of 2n nodes, but all the edges available in a 2xn grid. But yes, I agree the internal ones weren't needed; I just hadn't had that insight yet when I proposed it.
08:58:45 <nitrix> I can try to explain my idea quickly. I didn't think it'd grab such attention, might as well.
08:59:58 <[exa]> dmwit: np :] that's the direct method; I wanted the ears method because of formalizing the required movement in the grid that would be needed for formal inductive proof... but screw that. :]
09:01:28 <[exa]> nitrix: please do
09:02:29 <nitrix> My inspiration comes from looking at a rubber band. If you make a single cut, you notice that you're now left with an elastic rope, but thankfully it stays a single piece.
09:02:50 <nitrix> On the other hand, if you make two cuts, you end up cutting the rubber-band into two parts.
09:03:56 <nitrix> Now, suppose we have a quite different rubber band, the kind that's very abstract and somehow able to perfectly stretch around some 2D shape on a grid; you notice the band actually correspond to the perimeter of the shape.
09:05:21 <[exa]> oh yes, these are iirc called faces in planar graphs
09:05:45 <nitrix> So what you're actually interested in is to know when that perimeter traverses the same grid cell twice, because that tells you that removing what's in that cell would make "two cuts in the band".
09:06:22 <nitrix> Leading to disconnected components.
09:07:24 <nitrix> That's the basis; then you have to explain how you do the book-keeping of this perimeter. Which honestly isn't hard at all.
09:08:43 <[exa]> in a 4-vertex graph with 5 edges that looks like this: [/]   ("slashed cube"), in what order does the perimeter traverse the vertices?
09:09:56 <nitrix> You's have to draw it for me :S
09:10:18 <[exa]> vertices 1,2,3,4, edges 1-2, 2-3, 3-4, 4-1, 1-3.
09:10:45 <nitrix> Notice though that some tiles don't belong in the perimeter. Some participates once, and some participate twice.
09:11:01 <nitrix> Actually twice or more.
09:11:41 * nitrix reading
09:12:31 <nitrix> [exa]: Oh. In the grid of my game, tiles don't connect diagonally.
09:12:53 <Jinna> Can Intero tell me where all the callers of a certain function/symbol are?
09:13:23 <Jinna> I can M-. from a callsite into the function definition and also go back. But I want to do a reverse search.
09:13:36 <[exa]> nitrix: that can be easily simulated on more tiles but ok, what about this? https://pastebin.com/MANtXzsq
09:14:35 <nitrix> [exa]: An "O" shape?
09:14:55 <[exa]> nitrix: grid-ish O, with inner O connected by 1 edge
09:15:09 <[exa]> (I guess you can draw the same in the grid)
09:15:36 <nitrix> I see. Yes, that still works. I'll draw to you your shape and the invisible rubber band.
09:15:43 <nitrix> You'll immediately click.
09:16:34 <infinisil> Hey, I have some code that repeatedly reads multiple elements from an IOUArray, and updates the array with some computation of the read elements
09:16:58 <infinisil> However, after profiling, I'm noticing that each readArray allocates memory, making it suuuper slow because this happens so many times
09:17:38 <infinisil> It's just x <- readArray arr xi; y <- readArray arr yi; writeArray arr zi (x + y)
09:17:48 <infinisil> And I cannot for the life of me figure out why this allocates
09:18:28 <infinisil> Something surprising is that the same thing in an STUArray doesn't allocate, and is therefore as fast as I'd expect
09:20:36 <nitrix> [exa]: https://imgur.com/a/O6wWwBX
09:21:04 <nitrix> [exa]: The gray is the solid shape on the grid. I didn't bother drawing the whole grid, this is paint, it's painful.
09:21:17 <nitrix> [exa]: But you will see those perimeter bands colored in red, blue and green.
09:21:29 <[exa]> nitrix: yes, so basically tracking the euler faces
09:21:42 <nitrix> [exa]: I love when you give me new terms <3
09:21:54 <[exa]> now what about this: https://pastebin.com/3Rpjw2N9
09:23:10 <[exa]> nitrix: (esp. regarding the complexity of the update after someone removes the edge of the "large" cycle)
09:23:26 <nitrix> [exa]: I see where you're going, but it's actually a non-issue.
09:26:05 <[exa]> now we come to interesting property
09:26:17 <nitrix> [exa]: The first part of the algorithm is about dealing with those euler faces. If removing a tile has two bands of the same color (so the same euler face twice), you know you're disconnecting the components. If they are two different colors, you actually have to merge the two euler faces to mean only one face. And if there's only one band of one color, well, you remove the tile and stretch the band by
09:26:18 <nitrix> looking at the 3 adjacent tiles. Necessarily it'll connect to something else.
09:27:18 <nitrix> To make this tracking of faces efficient, I use two pointer indirection.
09:27:59 <infinisil> It's a bit faster with unsafeRead instead of readArray.. But allocations are still happening
09:28:23 <[exa]> nitrix: have you seen the union-find algorithm? it's one half of what you need for "merging" the faces
09:28:42 <nitrix> One from the euler face to a "intermediate group" and from the intemediate group to the final group. Merging faces is as easy as changing the intermediate group pointer and all your faces are properly updated.
09:29:16 <nitrix> Following the two indirections and you know what tile belongs where.
09:29:57 <nitrix> This is only necessary on certain updates and it's O(1) to update, also O(1) to lookup :P
09:31:01 <nitrix> [exa]: Either way, at this pointer is just a relational problem and C.S. has plenty of way to have constant time relationship systems.
09:31:11 <nitrix> I'm hopeful.
09:31:47 <[exa]> how do you split the faces in O(1) ?
09:32:05 <nitrix> HA!
09:32:08 <[exa]> like, the whole face has a pointer to a single element
09:32:15 <[exa]> you can rewrite that
09:32:21 <nitrix> Like an H shape where someone were to cut the little - in the middle?
09:32:52 <[exa]> but you need to change the pointers at |face|/2 elements in the worst case
09:33:05 <[exa]> which doesn't really count as constant-time, the face can be huge
09:33:55 <[exa]> infinisil: looking at the code, how can the readArray even trigger a reallocation?
09:34:30 <infinisil> No idea
09:34:45 <infinisil> One thing to note is that my indices are (Int, Int), but that shouldn't matter
09:35:03 <tabaqui> uh, Data.Hashable.hash preserve Ord instance of Bytestring but not of Text
09:35:23 <tabaqui> not a bug, just a funny note
09:35:28 <infinisil> And wow, it's 10 times faster if I freeze the mutable array, calculate the result purely with an STUArray, then thaw it again
09:35:38 <nitrix> So, one very large, skinny shape, with exactly one euler face, where someone happens to remove a joint. Yeah, you would have to walk one side of the cut and mark them as belonging to a new face :/
09:35:43 <nitrix> [exa]: ^
09:36:41 <[exa]> nitrix: good. also, on merging the faces, how do you rewrite the pointers at the face's vertices?
09:37:15 <[exa]> nitrix: (again, there's at least size-of-the-smaller-face amount of work)
09:38:36 <[exa]> tabaqui: how?? Q_Q
09:38:41 <nitrix> [exa]: That I don't. Since there are two levels are indirections for the pointer, A->B->C, I can mutate the B to point to another C and all of my As are indirectly modified.
09:39:23 <tabaqui> % hash ("45" :: ByteString)
09:39:33 <yahb> tabaqui: ; <interactive>:1:15: error:; Not in scope: type constructor or class `ByteString'; Perhaps you meant one of these: `BSL.ByteString' (imported from Data.ByteString.Lazy), `BS.ByteString' (imported from Data.ByteString), `IsByteString' (imported from Data.ByteString.Lens)
09:40:46 <[exa]> nitrix: so what happens if you take the original face (the one where C was) and connect it to something next?
09:41:23 <tabaqui> % let a = ["00" :: BS.ByteString, "45", "15", "57"] in map ((- (hash ("00" :: BS.ByteString)) . hash) a
09:41:23 <yahb> tabaqui: ; <interactive>:2:102: error: parse error (possibly incorrect indentation or mismatched brackets)
09:41:27 <tabaqui> % let a = ["00" :: BS.ByteString, "45", "15", "57"] in map ((- (hash ("00" :: BS.ByteString))) . hash) a
09:41:27 <yahb> tabaqui: ; <interactive>:3:10: error:; * Couldn't match expected type `BS.ByteString' with actual type `[Char]'; * In the expression: "00" :: BS.ByteString; In the expression: ["00" :: BS.ByteString, "45", "15", "57"]; In an equation for `a': a = ["00" :: BS.ByteString, "45", "15", ....]; <interactive>:3:33: error:; * Couldn't match expected type `BS.ByteString' with actual type `[Char]'
09:42:05 <[exa]> nitrix: or, rephrased, how to find all B's to modify on that change; that should include all three B's of all original faces
09:42:11 <tabaqui> uh, I'll play a little with a bot
09:42:13 <nitrix> [exa]: So you're telling me that in some cases, walking the shape and updating the book-keeping euler faces information is unavoidable ?
09:43:51 <[exa]> nitrix: I was basically trying to push you into reinventing this https://en.wikipedia.org/wiki/Disjoint-set_data_structure :]
09:44:10 <nitrix> [exa]: I hear you. So the merging of euler faces via my little pointer trick is problematic. The merges are convenient, but the future cuts are near impossible to deal with.
09:45:04 <nitrix> [exa]: HAHA. I was working on something similar >_<
09:45:53 <[exa]> nitrix: https://www.youtube.com/watch?v=0jNmHPfA_yE if you're not keen on reading wikipedia; the second video describes a trick to get a decent time complexity
09:46:02 <nitrix> [exa]: Good to know it's been figured out before me. That's bad news though, isn't it?
09:46:08 <[exa]> not at all
09:46:19 <nitrix> [exa]: This page says O(Î±(n))
09:47:27 <nitrix> The other paper earlier had O(n ^ 2/3)
09:47:54 <tabaqui> % let a = ["40", "45", "46", "47", "57"] in (\x -> x - hash (fromString "40" :: BS.ByteString)) . hash . (fromString @BS.ByteString) <$> a
09:47:54 <yahb> tabaqui: [0,5,6,7,16777588]
09:48:00 <tabaqui> [exa]: not really, but somewhat
09:48:10 <tabaqui> at least if first digits are equal
09:48:18 <[exa]> tabaqui: /me scared
09:48:28 <[exa]> but thanks for pointing that out
09:49:12 <tabaqui> yeah, I just changed the type of my data and unittests suddenly became broken
09:49:16 <[exa]> nitrix: the biggest problem is that union-find only works when adding edges, working with edge removal is quite complicated. But wiki has good references on that.
09:51:06 <nitrix> Oh. So I can keep tracking my euler faces, maybe this time with just an integer, and use union-find for managing the faces. That gives me this near constant time they're saying.
09:51:10 <nshepperd> i think that any hashing or random number library should accept some command line flag which changes everything to strong cryptographic primitives
09:51:40 <nshepperd> so you can test with both and fail if the behaviour of your program differs
09:53:33 <nshepperd> that would catch a lot of cases of accidentally relying on the behaviour of hashes, or randomness biases which break monte carlo simulations etc
09:54:55 <nitrix> [exa]: That gives me a lot to look into. I appreciate you giving me of your time :)
10:01:56 <protomaya> Hi everyone! Suppose that I have data Pair a b = Pair a b, is it possible to define a function mkPair :: a -> b -> Pair a b that will reject applications with arguments of similar type? E.g. mkPair (10 :: Int) (12 :: Int) will be invalid.
10:04:01 <mniip> protomaya, you can have `mkPair :: (a == b ~ False) => a -> b -> Pair a b`
10:04:09 <mniip> but you might have issues
10:04:18 <mniip> with proving that the types are actually apart
10:04:43 <protomaya> Ok, didn't know about `a == b ~ False`. Interesting.
10:05:45 <protomaya> mniip: Do you have any specific example where the issue may arose?
10:06:39 <mniip> mkPair 1 ()
10:07:03 <protomaya> mniip: fair enough
10:07:04 <mniip> you will have accumulated a constraint (Num a, a == () ~ False), and the type family doesn't reduce
10:07:29 <mniip> because surely elsewhere in the program you could have `instance Num ()`
10:08:12 <protomaya> mniip: makes sense, thank you
10:08:58 <protomaya> mniip: for my use case it should be good enough, because I don't plan on exposing this function out of module. I just want to have a convenient function to build exposed stuff. 
10:09:03 <protomaya> time to play with new toy
10:14:14 <protomaya> mniip: What extensions should I use? TypeOperators, DataKinds and what else? Or should I import something? Because == not found.
10:14:54 <lyxia> protomaya: import Data.Type.Equality
10:14:57 <hyperisco> https://hoogle.haskell.org/?hoogle=%3D%3D&scope=set%3Astackage
10:15:30 <hyperisco> Also RIP Hayoo? Bang pattern not working.
10:16:15 <protomaya> Thanks everyone!
10:17:33 <lyxia> hyperisco: doesn't look alive from here either
10:17:40 <hyperisco> Oh nice, I was going to ponder about thatâ€¦ whether it can figure out  F a == G b ~ False
10:18:50 <hyperisco> I cannot remember what generative + injective is, but it has that property as the first rule.
10:21:16 <hyperisco> What I am not sure about is the definition of &&â€¦ how can it short on either argument? Doesn't make sense to me.
10:21:58 <hyperisco> Particularly, if we have  f A == g B  then we don't care about  f == g  because it is already False, ideally
10:22:08 <hyperisco> But if we go to &&, https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Type-Bool.html#t:-38--38-
10:23:00 <hyperisco> The left argument is matched first, which means we cannot short on the right argument
10:23:37 <hyperisco> We have to wait around to figure out if  f == g  merely because of &&'s definitionâ€¦ hrm.
10:24:35 <lyxia> it does work IIRC
10:24:53 <hyperisco> What works?
10:24:54 <lyxia> all 4 instances can be used at any time
10:25:04 <hyperisco> there are no instancesâ€¦ it is closed
10:25:27 <lyxia> well you can still think of them as instances (5 of them actually)
10:25:46 <hyperisco> No, that just wouldn't make sense
10:25:59 <lyxia> why not
10:26:01 <hyperisco> If they could match out of order that would be a huge problem for several other definitions
10:26:23 <hyperisco> The matching order is a paramount reason for having closed families in the first place
10:27:14 <hyperisco> There is an analysis that can be done to determine that these rules can be matched in any order, yes
10:29:47 <lyxia> ghci> :kind! forall a. (a && 'False)      responds ...  = 'False
10:30:26 <lyxia> why even have 5 rules if they can't be matched out of order
10:31:00 <hyperisco> There is extra work being done if that is possible
10:31:12 <lyxia> yes there is extra work being done
10:31:23 <[exa]> nitrix: btw if you find something simple and consistent that solves the anti-union problem, let me know (I don't really remember the hopcroft/tarjan approach; filling that blank spot with something more ....concise.. would be cool)
10:31:49 <hyperisco> Frankly unsettling. I hope it is easily explained.
10:31:56 <lyxia> Haskell type families do not behave like Haskell functions with pattern-matching.
10:32:30 <nitrix> [exa]: I'm approaching this very much like Feynman would; out of familiar things. I'm lacking a whole lot on the academia side.
10:32:50 <nitrix> Something I'm slowly improving on ;-;
10:33:17 <lyxia> I think one of the papers on type families by SPJ (who else could it be) explains it well
10:34:34 <mniip> type families aren't matched in order
10:34:45 <mniip> there's incompatibility criteria between branches
10:35:13 <mniip> a branch can apply if all branches before it either fail to apply or are compatible
10:35:26 <mniip> in Data.Type.Bool.&& all branches are compatible
10:35:29 <mniip> so they apply in any order
10:35:49 <nshepperd_> Seems like ghc needs to unify the first three rules to justify making "forall a. (a && 'False) = 'False"?
10:36:22 <nshepperd_> Ie figure out that the result is False in each case
10:36:33 <dmwit> precisely correct
10:36:37 <mniip> :t undefined :: Proxy (a && False)
10:36:39 <lambdabot> error:
10:36:39 <lambdabot>     Not in scope: type constructor or class â€˜&&â€™
10:36:45 <mniip> :t undefined :: Proxy (a Data.Type.Bool.&& False)
10:36:45 <hyperisco> That is insane
10:36:47 <lambdabot> Proxy 'False
10:36:50 <mniip> that's what it does
10:36:57 <hyperisco> I trust you
10:37:04 <nshepperd_> Wow
10:37:15 <mniip> there are limitations of course
10:37:21 <hyperisco> Still though, how am I supposed to figure out when it can and cannot determine "compatibility"?
10:37:40 <hyperisco> Bool seems tractable because it is finite
10:38:23 <mniip> in fact I have a pull request related to this very issue
10:38:37 <mniip> adding an option that prints the inferred compatibility information
10:38:40 <mniip> in :info
10:39:12 <mniip> hyperisco, it doesn't depend on anything like that, no
10:39:18 <nshepperd_> It determines this compatibility statically?
10:39:34 <mniip> yes, at the time of interpreting the type family declaration
10:39:48 <nshepperd_> Ie. Without knowledge of the arguments
10:40:02 <hyperisco> Well I am sure it can generalise beyond that, but it is easy to see how compatibility can be checked for finite types.
10:40:29 <mniip> what it does is given 'F a1 b1 ... = r1' and 'F a2 b2 ... = r2' it checks whether (a1 ~ a2, b1 ~ b2, ...) implies  r1 ~ r2
10:40:44 <mniip> with some quirks but that is the gist
10:41:03 <mniip> if a1 and a2 are apart (provably unequal types) then the implication holds vacuously
10:41:46 <mniip> equations like 'And True b = b' and 'And a True = a' are compatible because (True ~ a, b ~ True) implies b ~ a
10:41:52 <mniip> et cetera
10:42:18 <hyperisco> Obviously the designer(s) of type families had some pet definitions they needed to make work :P
10:42:51 <nshepperd_> Well that's amazing
10:43:37 <mniip> the quirk is that checking r1 ~ r2 can trigger type family reduction and we can go into an infinite loop
10:43:47 <mniip> right now the r1 ~ r2 check does not do any reduction at all
10:44:06 <mniip> but there's some ideas by goldfire on how to improve this
10:57:13 <higherorder> Hi! Is there a function in Haskell that allows me to do the following?: If am within a `State (Int, Int) ()` (to keep things simple) context and I would like to update the first element of the state tuple by running `doubleState :: State Int ()` with it 
10:57:51 <Rembane> higherorder: Have you take a look at modify?
10:57:53 <Rembane> :t modify
10:57:55 <lambdabot> MonadState s m => (s -> s) -> m ()
10:58:05 <Rembane> higherorder: Ah, and then first.
10:58:11 <Rembane> :t first
10:58:13 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
10:58:23 <Rembane> That type signature...
10:58:27 <higherorder> Rembane: what I currently have is this: https://gist.github.com/hmaurer/370f8624c6ee4195516e42375edd643d 
10:58:32 <higherorder> but it seems a bit gross with `runState`
10:59:22 <Rembane> higherorder: You can replace the line that contains runState with something involving modify.
10:59:42 <higherorder> Rembane: I'll still need the `runState` though, right?
11:02:38 <nshepperd> :t zoom _1 :: State Int () -> State (Int, Int) ()
11:02:39 <lambdabot> State Int () -> State (Int, Int) ()
11:03:37 <solonarv> ah, nshepperd was faster :D
11:05:23 <higherorder> nshepperd: ah, brilliant; exactly what I was looking for. Thanks :) is zoom implemented in the same way as my gist? (with runState)
11:05:25 <Rembane> higherorder: When you want to get the value and state out of the monad, but not before. 
11:08:17 <nshepperd> higherorder: morally yes, but it works for different kinds of state monads using a typeclass
11:08:23 <nshepperd> :t zoom
11:08:25 <lambdabot> Zoom m n s t => LensLike' (Zoomed m c) t s -> m c -> n c
11:09:06 <higherorder> nshepperd: alright; I am not familiar with lenses at all so I think I'll just implement my dumbed-down version of zoom; implementing it with runState makes sense then?
11:09:36 <nshepperd> sure
11:10:08 <nshepperd> mind you, you don't really need to understand how zoom works to use it
11:13:27 <higherorder> nshepperd: fair enough, but I am just learning at the moment so I rather keep the building blocks simple and pull as few libs as possible
11:14:04 <higherorder> thanks :-)
11:14:05 <nshepperd> yep, that's a reasonable idea
11:23:51 <dmwit> higherorder: You might like execState.
11:24:24 <dmwit> :t \m -> modify (\(a,b) -> (execState m a, b))
11:24:27 <lambdabot> MonadState (s, b) m => State s a -> m ()
11:24:33 <higherorder> dmwit: oh neat, `execState = snd . runState`, right?
11:24:40 <dmwit> right
11:24:59 <dmwit> Doesn't help if you want to actually return the calculated result instead of throwing it away, though.
11:25:14 <dmwit> i.e. if you wanted `State Int a -> State (Int, Int) a`
11:25:45 <Jinna> What is the ReaderT design pattern in a nutshell?  Is it essentially a ReaderT over a TVar?
11:26:06 <dmwit> :t \m -> state (\(a,b) -> let (v, a') = runState m a in (v,(a',b)))
11:26:07 <lambdabot> MonadState (b1, b2) m => State b1 a -> m a
11:27:43 <dmwit> Jinna: I shouldn't be surprised if different speakers meant different things by "the ReaderT design pattern".
11:29:40 <Jinna> dmwit: if I want to hold multiple items and possibly modify some of them, should I then have a container type Context and _in it_ there would be a couple of TVars?  Or should there be an outer TVar that holds just one single Context value?
11:29:55 <boj> Jinna: i think it generally means ReaderT over IO as the only components in a monad transformer stack
11:30:31 <boj> if your Context is read-only then you wouldn't need a TVar
11:31:00 <ivegotasthma> hello, what's the preferred way to write haskell on nixos?
11:31:02 <Jinna> boj: the point should be that I do need mutable state. And instead of adding a StateT to the stack the suggestion was to simply have a simple ReaderT.
11:31:28 <boj> Jinna: in that case a TVar in a ReaderT would make sense, especially in a multi-threaded app
11:34:20 <Jinna> boj: so the TVar goes to the outside and that letâ€™s me replace everything in the Context. It would not make sense to have something immutable inside the ReaderT and that immutable value references a couple of TVars?
11:34:34 <talqu> hi, i want to overwrite instance Show (Maybe a). Is there some language extension that lets me do that?
11:35:11 <Jinna> talqu: why you want to overwrite it?
11:35:35 <boj> Jinna: ideally the ReaderT Context would contain immutable stuff like environment variables, config data, or even hold a reference to a database pool that internally tracks its own state
11:35:56 <boj> Jinna: on the other hand, you would maybe add a TVar inside it to track a Random Gen
11:36:43 <Jinna> boj: I would like to have the Context as a container and it will indeed hold env vars and the config, both being immutable. But it would also hold some server state, such as the logged in users, their permissions, etc.
11:37:59 <boj> Jinna: seems like a good use case then :)
11:38:24 <Jinna> I just wonder if there might be concurrency issues if I have, say, two TVars inside the Context, which is otherwise immutable.
11:38:34 <talqu> Jinna: just for learning purpose, i remember OverlappingInstances or something similar
11:38:51 <Jinna> The alternative would be to have only one single TVar in the ReaderT, and that TVar holds a Context.
11:39:03 <boj> Jinna: i wouldn't focus on the fact that Context itself is immutable
11:39:22 <Jinna> That second solution sounds not as clean, because I could swap one whole Context with another one. So it would seem that I can mutate everything inside the Context.
11:39:36 <tempeh> is there some way to generate traversals for custom sum types (like _Just) with microlens-th?
11:39:43 <Jinna> I just worry about concurrency issues, if multiple TVars are involved.
11:40:01 <lyxia> talqu: define your own data type and write a Show instance for it?
11:40:10 <Jinna> talqu: I guess the standard solution is to make a newtype wrapper and for it implement the Show class.
11:40:30 <talqu> yes
11:41:31 <dmwit> Jinna: I think multiple TVars is fine, and most people who consider a single TVar to be part of the ReaderT pattern would also consider a structure with multiple TVars to be a part of that pattern, too.
11:42:27 <dmwit> Jinna: As for "concurrency issues if multiple TVars are involved", uh... huh?
11:42:32 <Jinna> dmwit: for me the clean approach sounds like putting a Context into the Reader, and the Context has a couple of fields and some of them happen to be TVars.
11:42:49 <dmwit> The whole point of TVars and STM is that you can cook up transactions that are either completely done at once or not at all.
11:43:01 <dmwit> Jinna: I think that would be fine and quite normal.
11:43:06 <Jinna> dmwit: good good, thx for clarifying. I never used TVars so far.
11:43:22 <Jinna> That approach would clearly show which parts I intend to mutate (and which not).
11:43:56 <dmwit> Jinna: https://github.com/dmwit/mcmario/blob/master/src/mcmario.hs#L47 for example =)
11:44:13 <dmwit> Although I just used `Context -> whatever` instead of `ReaderT Context`.
11:44:25 <Jinna> dmwit: good, thanks for that link
11:44:33 <dmwit> I find it's a bit unusual for the overhead of having to `ask` everywhere to be worth the abstraction value.
11:44:46 <Jinna> By just using the Context you would have to pass it around. Also not bad perhaps.
11:45:54 <boj> dmwit: an app which needs Context in 2000+ functions :p
11:46:54 <Jinna> boj: I am not certain how to get the Context into the Servant handlers, if not via a ReaderT.
11:47:31 <boj> Jinna: i have a (poor) example of that, let me find it
11:48:14 <boj> Jinna: https://github.com/alasconnect/mtl-experiment/blob/master/src/App.hs#L36
11:48:45 <boj> that whole project is terrible, but that little bit is a good example of how to set it up
11:48:55 <Jinna> dmwit: btw, does this have anything to do with that Nintendo game?
11:49:06 <Jinna> boj: thx, will have a look
11:50:34 <dmwit> Jinna: It does have something to do with that Nintendo game iff that Nintendo game is Dr. Mario.
11:51:01 <Jinna> (:
11:51:30 <dmwit> It's a handicapper: you tell it who's playing, it suggests a handicap, you play your  game, then you tell it who won.
11:51:36 <dmwit> rinse and repeat
11:51:51 <dmwit> It learns ratings for each player from who won and what the handicap was when that happened.
11:52:40 <dmwit> It worked surprisingly well given how simple the statistical model is.
11:53:15 <tempeh> I'm having trouble figuring out how to define any traversals for custom types in microlens, any pointers or resources would be appreciated
11:53:30 <dmwit> tempeh: I recommend "Lenses Over Tea".
11:53:48 <dmwit> https://artyom.me/lens-over-tea-1
11:54:24 <tempeh> that's definitely on my reading list - but will that answer this question about microlens?
11:55:24 <dmwit> It will.
11:55:42 <boj> well, microlens and lens are fundamentally the same thing, just different implementations (micro lacking some of the advanced stuff]
11:56:06 <tempeh> okay, I'll have a look then. Thanks
11:58:15 <halogenandtoast> I am pretty sure this in impossible (probably breaks some lens law), but is there any way to be able to use the gridWidth lens instead of the hard coded width in https://gist.github.com/halogenandtoast/ae2ab9e13ede25d8c2cdfdfdc3cc2f0d
12:01:41 <shapr> Is there a faster way to do cabal init? Can I fill in most/all of the values from command line params or a config file?
12:02:02 <c_wraith> halogenandtoast, nothing unlawful required.
12:03:13 <halogenandtoast> c_wraith: I think the issue is that the lens allows me to traverse, so I can't traverse two paths and make one dependent on the other
12:03:25 <tempeh> dmwit: I did find some clarity thank you
12:03:48 <c_wraith> halogenandtoast, I think you're reading way more into the laws than they actually say.
12:04:21 <halogenandtoast> c_wraith: what guess what I mean to say is that I can't think of a single way to write this out (independent of the lens laws)
12:05:33 <c_wraith> halogenandtoast, if you forget there are tons of combinators for producing optics and just look at the type, you'll probably find it pretty easy
12:06:15 <c_wraith> halogenandtoast, it turns out its *really* easy to write a Traversal by hand.
12:06:55 <dmwit> shapr: summoner, haskeleton
12:20:32 <c_wraith> halogenandtoast, something like _xy (Pos x y) f (Grid w h c) = Grid w h <$> ix (x + y * w) f c
12:20:52 <c_wraith> halogenandtoast, not tested or type checked, but that's the basic idea. just write the code.
12:28:05 <juri_> ok, this is a more complicated one...
12:28:18 <c_wraith> halogenandtoast, though thanks to ghc's inlining policy, you may want to shift the last two args into a lambda so the definition only has one parameter syntactically
12:29:29 <juri_> I have a function, that expects to recieve as an argument a function for turning wrapped type to wrapped type. i have a function that takes unwrapped type, and returns unwrapped type...
12:30:02 <dmwit> juri_: Can you be a bit more specific?
12:30:13 <dmwit> (But... perhaps coerce is what you're looking for.)
12:30:15 <dmwit> :t coerce
12:30:16 <lambdabot> error:
12:30:16 <lambdabot>     â€¢ Variable not in scope: coerce
12:30:16 <lambdabot>     â€¢ Perhaps you meant â€˜coercedâ€™ (imported from Control.Lens)
12:30:21 <dmwit> % :t coerce
12:30:21 <yahb> dmwit: Coercible a b => a -> b
12:30:45 <dmwit> % :t coerce :: (Int -> Double) -> (Sum Int -> Product Double)
12:30:45 <yahb> dmwit: (Int -> Double) -> Sum Int -> Product Double
12:30:53 <dmwit> e.g.
12:30:56 <juri_> sure. i've got a newtype of a Map k a, and i'm using insert to create a function fit for StateC.
12:32:01 <dmwit> Map I think I know. StateC?
12:32:22 <juri_> i'm partially applying the insert, and i want the types of the partial application to be my newtype -> newtype, but insert partially applied gives me Map k a -> Map k a
12:33:48 <hyperisco> :t ala
12:33:50 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor f) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
12:34:03 <hyperisco> :t ala Sum
12:34:05 <lambdabot> Functor f => ((b1 -> Sum b1) -> f (Sum b2)) -> f b2
12:34:13 <hyperisco> :t alaF Sum
12:34:14 <lambdabot> error:
12:34:14 <lambdabot>     â€¢ Variable not in scope: alaF :: (a0 -> Sum a0) -> t
12:34:14 <lambdabot>     â€¢ Perhaps you meant one of these:
12:34:22 <hyperisco> okay not this language :)
12:35:10 <hyperisco> :t alaf Sum
12:35:11 <lambdabot> (Functor g, Functor f) => (f (Sum b1) -> g (Sum b2)) -> f b1 -> g b2
12:35:31 <dmwit> % newtype Foo k a = Foo (Map k a)
12:35:31 <yahb> dmwit: ; <interactive>:27:24: error:; Not in scope: type constructor or class `Map'; Perhaps you meant `M.Map' (imported from Data.Map)
12:35:35 <dmwit> % newtype Foo k a = Foo (M.Map k a)
12:35:35 <yahb> dmwit: 
12:35:48 <dmwit> % :t coerce :: (Map k a -> Map k a) -> (Foo k a -> Foo k a)
12:35:48 <yahb> dmwit: ; <interactive>:1:12: error:; Not in scope: type constructor or class `Map'; Perhaps you meant `M.Map' (imported from Data.Map); <interactive>:1:23: error:; Not in scope: type constructor or class `Map'; Perhaps you meant `M.Map' (imported from Data.Map)
12:35:57 <dmwit> % :t coerce :: (M.Map k a -> M.Map k a) -> (Foo k a -> Foo k a)
12:35:57 <yahb> dmwit: (M.Map k a -> M.Map k a) -> Foo k a -> Foo k a
12:36:01 <dmwit> juri_: ^
12:37:05 <dmwit> % deriving instance (Show k, Show a) => Show (Foo k a)
12:37:06 <yahb> dmwit: 
12:37:31 <dmwit> % coerce (M.insert "hi" "there") (Foo (M.singleton "what" "a day"))
12:37:31 <yahb> dmwit: ; <interactive>:32:1: error:; * Couldn't match representation of type `()' with that of `M.Map [Char] [Char]' arising from a use of `it'; * In the first argument of `print', namely `it'; In a stmt of an interactive GHCi command: print it
12:39:25 <dmwit> % coerce (M.insert "hi" "there") (Foo (M.singleton "what" "a day")) :: Foo String String
12:39:25 <yahb> dmwit: Foo (fromList [("hi","there"),("what","a day")])
12:43:15 <merijn> Whee! It's "the configure script in the GHC bindist is broken *again*"-day
12:44:39 <merijn> With the exact same freaking error I'm pretty sure I fixed months ago...
12:46:11 <monochrom> "what a day"
12:48:16 <merijn> ffs, I can even see my patch in there but someone broke it >.>
12:48:40 <merijn> Anyone happen to know where the configure script gets generated/copied from in the GHC repo?
12:49:21 <monochrom> What is the recurring error?
12:50:26 <c_wraith> halogenandtoast, any of that get through?
12:51:38 <merijn> monochrom: The configure script really naively grepped for the relevant "GccVersion" (really $CC version) and then horribly breaks when clang helpfully returns multiple lines including the word 'version'
12:51:45 <merijn> monochrom: Which it does whenever you have CUDA installed
12:52:11 <merijn> monochrom: So I added a sed command that only kept the first version, but the sed command that's currently in the configure script must have changed because it doesn't work
12:52:50 <halogenandtoast> c_wraith: sorry got paged, I will check the logs
12:52:52 <merijn> So I'm trying to figure out which change touched the sed expression and what happened to it (if anything)
12:53:16 <halogenandtoast> oof are the logs broken?
12:53:37 <shapr> phadej: does your github v3 API binding have "create repository" code?
12:53:51 <phadej> I don't know, maybe :)
12:54:05 <phadej> i only merge PRs and push releases!
12:54:15 <halogenandtoast> I just get Forbidden when I try to view them
12:54:30 <shapr> phadej: thanks for the quick answer, I'll keep digging into the source
12:54:46 <phadej> shapr: look at the documentation of GitHub module
12:54:52 <c_wraith> halogenandtoast, well, short summary then: something like this, but tested and type-checked _xy (Pos x y) f (Grid w h c) = Grid w h <$> ix (x + y * w) f c
12:54:53 <phadej> if it's not there, it's not anywhere lese
12:56:14 <c_wraith> halogenandtoast, and maybe moving some params into a lambda thanks to how ghc does inlining.
12:58:32 <merijn> monochrom: I swear, I have a gift for triggering config edge cases, this is umpteenth time I break it magically by doing nothing
12:59:52 <juri_> dmwit: thanks. I'll let you know how it goes. :)
13:04:42 <fendor> can I move cabal built binaries to other machines? Assuming same os, same arch, etc...? 
13:05:04 <fendor> Cant built it on the machine because of storage limitations
13:05:38 <fendor> s/built/build
13:05:39 <c_wraith> yes, provided you also move any data files that cabal hard codes paths for
13:05:55 <merijn> Also, any dynamically linked C libraries
13:06:11 <fendor> merijn, yeah, that should be fine since it is the same vm image, basically
13:06:27 <fendor> c_wraith, where is the library? there is nothing like stack path command in cabal, right?
13:07:04 <c_wraith> fendor, it depends on what libraries you are using. it's quite possible for there to be none.
13:07:50 <halogenandtoast> c_wraith: thanks I did not realize the "true" type of that function
13:08:02 <halogenandtoast> _xy :: Applicative f => Pos -> (a -> f a) -> Grid a -> f (Grid a)
13:08:07 <fendor> i meant the built binary. 
13:08:49 <c_wraith> halogenandtoast, yep. sometimes tearing down the type aliases really helps
13:08:54 <merijn> fendor: You're using v2-build?
13:10:24 <fendor> merijn, yes
13:10:52 <merijn> You can use v2-install to copy the binary or the cabal-plan executable to inspect the paths/config
13:11:31 <fendor> merijn, is that just a symlink in 2.4.1.0?
13:12:55 <merijn> fendor: There's a copy mode too
13:13:03 <merijn> (or is that not in 2.4 yet)
13:13:23 <fendor> i dont think that is in 2.4
13:16:43 <fendor> wait, I am trying to relocate lambdabot... does that make sense?
14:24:24 <nefple[m]> Is it fair to say that mempty is distinct from a "Default" for a type? I was discussing this some people who didn't see the distinction between an identity and a default.
14:29:50 <Welkin> only if it's a monoid
14:30:08 <monochrom> "default" is subjective and completely arbitrary.  Why is the "default" integer 0? Why not 1? Why not 2 (the smallest positive prime)?
14:30:20 <Welkin> Sum and Product :D
14:31:02 <nefple[m]> Right, the default for int should only be zero for sum, and 1 for product. Ok cool I'm right
14:31:02 <monochrom> mempty comes with at least a community expectation that it actually plays well with mappend.
14:31:32 <geekosaur> nefple[m], mempty is an identity for an *operation*
14:31:47 <geekosaur> consider that 0 is the identity for addition, 1 for multiplication
14:31:54 <geekosaur> across multiple numeric types
14:32:13 <monochrom> More contenders for "default": maxBound, minBound.
14:32:44 <jackdk> about the only time I consider Default instances sensible is for configuration structures. Almost always, I get value from considering "do you mean Monoid?" in response to the question "should we instance Default?"
14:32:44 <geekosaur> https://xkcd.com/221/
14:32:49 <monochrom> And don't even get me started with nice "defaults" for bitmasks.  This gives you two more.
14:33:29 <monochrom> Most configs are actually monoids, so go with monoid already, screw subjective "default".
14:33:33 <Welkin> what is the default for defaults!?
14:33:36 <nshepperd_> default can be anything, the only requirement is that it be "a convenient default" which is application dependent
14:33:46 <Welkin> and why is it a de-fault? What about the faults?
14:33:50 <Welkin> and what is the de-?
14:34:01 <nshepperd_> cofault
14:34:46 <monochrom> Even the PHP community wakes up and recognizes that numbers are not always sensible booleans, i.e., if the number represents temperature or calendar time, there is nothing special about "0".
14:34:48 <Welkin> foucault?
14:35:13 <dmwit> monochrom: foo is an identity for the (associative!) operation \x y -> x + y - foo
14:35:38 <monochrom> Wow everyone is special!
14:36:06 <nshepperd_> We all have our own identities :)
14:41:35 <steshaw> Mind blank. Can someone help? Trying to think of the name of the transformation: foo to \a -> foo a (and the reverse)
14:41:48 <monochrom> eta
14:42:06 <steshaw> tah and un-eta?
14:42:46 <monochrom> I ate a lambda
14:43:04 <steshaw> lol
14:46:04 <Welkin> eta reduction and eta abstraction
14:51:38 <Rembane> Good morning, when I run this parser using parseTest in Attoparsec I can't find an input that satisfies it. Do you have an example of inputs that should work or an explanation of why it shouldn't work? The parser in question: ((sepBy1 (takeWhile1 (/= ' ')) space))
14:52:54 <shapr> phadej: for the github v3 api library you maintain I created a "createRemoteRepo" sample, should I locate it under github/samples/Repos/ in the PR?
14:53:31 <glguy> Rembane: "A" and "A B" both work
14:54:11 <phadej> shapr: ideally the samples structure would follow GitHub.Endpoints structure
14:54:32 <Rembane> glguy: Like this? parseTest ((sepBy1 (takeWhile1 (/= ' ')) space)) (B8.pack "A")
14:54:35 <glguy> Rembane: They produce Partial, but partial doesn't mean failure
14:54:35 <shapr> phadej: ok, I'll try to match it up to that
14:54:47 <glguy> also: >>> parseTest  ((sepBy1 (takeWhile1 (/= ' ')) space)) "a  "
14:54:47 <glguy> Done "  " ["a"]
14:55:04 <steshaw> Welkin: thanks
14:55:14 <glguy> Rembane: If you use parseOnly then that tells attoparsec that there isn't any more input coming and it runs the final Partial with an empty string
14:56:10 <glguy> >>> parseOnly  ((sepBy1 (takeWhile1 (/= ' ')) space)) "a"
14:56:10 <glguy> Right ["a"]
14:56:19 <Rembane> glguy: Very good point. Okay, then I got what I need to continue. Thank you! 
15:03:03 <gabbiel> hello, I want to get into haskell but before I do I need to set up emacs to do so
15:03:15 <gabbiel> I already installed haskell-mode
15:03:26 <Welkin> that's all you need
15:03:33 <gabbiel> but I also want autocompletion
15:03:43 <Welkin> C-/
15:03:56 <Welkin> I mean, M-/
15:04:09 <gabbiel> what about ghc-mod and scion
15:04:23 <Welkin> I don't use anything other than haskell-mode
15:04:30 <Welkin> you don't need it
15:04:54 <Welkin> set it up if you want to, but it's overkill
15:05:26 <gabbiel> i'll try, its just cabal  keeps crashing
15:05:29 <shapr> phadej: PR is up, hope it's useful
15:05:45 <Welkin> run cabal in your shell
15:05:47 <Welkin> cabal new-build
15:06:11 <Welkin> you don't need cabal to learn haskell either
15:06:14 <Welkin> that is for larger projects
15:06:22 <Welkin> you should start with using ghc directly
15:06:52 <shapr> I sure do like using cabal, but I learned Haskell before cabal existed, so I'm not sure which way I lean.
15:06:54 <gabbiel> yeah I already have ghc installed, I just want to have everything set up so I can learn nice
15:07:31 <Welkin> you don't need a lot of stuff for haskell, just ghc, a highlighting mode for your editor, and cabal (for larger projects)
15:07:32 <gabbiel> so cabal is a package manager and system builder?
15:07:38 <Welkin> yes
15:08:01 <Welkin> start off just writing some functions and running them in ghci
15:08:28 <Welkin> also, install haskell using ghcup or haskell platform
15:09:06 <gabbiel> what is that
15:09:10 <gabbiel> ghcup?
15:09:15 <Welkin> ghcup is an installer, like rustup
15:09:32 <Welkin> https://www.haskell.org/ghcup/
15:09:57 <gabbiel> I installed it with my package manager. does ghcup have any benefits
15:10:02 <shapr> gabbiel: I think yes
15:10:04 <Welkin> don't use your package manager
15:10:10 <Welkin> it will be very old and possibly broken
15:10:19 <Welkin> either ghcup or haskell platform
15:10:19 <shapr> yeah, most package managers aren't keeping up with GHC releases
15:10:36 <gabbiel> i have ghc 8.6.5, is that old?
15:10:46 <Welkin> no
15:10:49 <Welkin> but is it arch?
15:10:52 <gabbiel> yes
15:10:54 <Welkin> okay
15:10:56 <Welkin> it will be broken
15:11:03 <Welkin> so remove that and use another option
15:11:20 <gabbiel> oh ok
15:11:54 <gabbiel> is the AUR ghcup good for this, or should I go to link provided
15:12:00 <Welkin> no idea
15:12:18 <Welkin> I use haskell platform and haven't tried ghcup yet, but it looks like it's just a script
15:12:32 <shapr> ghcup is really great
15:12:45 <gabbiel> just saw link, its just one line, so ill do that instead
15:12:50 <shapr> you can have several versions of ghc installed and switch between if you want, or just upgrade to the latest
15:12:56 <shapr> and it handles installing cabal for you
15:12:58 <gabbiel> should I give it super user privileges?
15:13:16 <shapr> I don't think I did, all my ghc versions are in my own user
15:13:53 <shapr> when I was teaching Haskell once a week, ghcup saved my hours of trouble with distro package managers
15:16:35 <gabbiel> hmm, it says it needs realpath and xz-utils for ghcup to work, how do I know if I have those
15:17:32 <shapr> gabbiel: realpath is part of the GNU coreutils, it's extremely likely you have that installed. xz-utils is probably something you can get from your package manager
15:17:32 <DigitalKiwi> if it works, you have them
15:19:19 <gabbiel> is xz-utils just xz, because I have xz installed 
15:20:21 <gabbiel> hopefully it works, now its downloading a bunch of stuff
15:20:39 <shapr> yay!
15:32:48 <gabbiel> ok, I've set my path and ghci works. am I done?
15:33:57 <solonarv> probably! is ~/.cabal/bin also on the path?
15:34:04 <gabbiel> yes, 
15:34:24 <solonarv> should be done then
15:35:35 <gabbiel> so from now on, only install packages using cabal?
15:37:01 <solonarv> it depends on the package: if it is a haskell library, I would not "install" it in the usual sense
15:38:26 <gabbiel> explain
15:38:37 <solonarv> if it's a haskell program I would probably use 'cabal v2-install' to install it
15:39:11 <shapr> gabbiel: for example, "cabal v2-install hlint"
15:39:29 <gabbiel> so you would install xmonad with cabal then? 
15:39:36 <solonarv> so, the problem with installing libraries is: what if you have multiple versions of the same library? worse, what if you need two *same* versions of a library, but you need different versions for its dependencies?
15:40:08 <solonarv> if you are just installing libraries to be globally available this can eventually lead to problems where Everything Is Broken
15:40:52 <gabbiel> two same versions?
15:41:03 <solonarv> fortunately we have shiny new 'cabal v2-*' commands, which avoid this and properly keep things separate
15:41:39 <solonarv> sure: imagine you have two projects which both depend on A-1.0, and A has a dependency on B >= 0.2 && < 0.4
15:42:00 <solonarv> and one of your projects depends on B-0.2, the other on B-0.3
15:42:20 <gabbiel> jesus christ
15:42:57 <solonarv> if you 'cabal install' the dependencies of the first project, you build B-0.2 and A-0.1 using B-0.2
15:43:46 <solonarv> now you 'cabal install' the dependencies of the second project: B-0.3 gets installed, but then cabal (old-style) sees you already have A-0.1 and does not rebuild it, even though it should
15:44:08 <solonarv> sometimes things work out and you don't notice right away; repeat a few times and everything is hell
15:44:29 <gabbiel> but v2 will notice?
15:44:33 <solonarv> one solution is sandboxes, so your two projects don't share anything
15:44:55 <solonarv> v2 is smarter than sandboxes: it properly tracks versions, versions-of-dependencies, and configuration flags
15:45:13 <solonarv> so if build results can safely be shared, they will be - but only then!
15:45:50 <solonarv> (it does this using a hash of version, flags etc, which also includes the hashes of the dependencies)
15:46:29 <solonarv> this allows it to keep a cache of already-built things and just make the right parts of it visible
15:47:51 <gabbiel> quick question, are libraries installed in cabal available on ghci and haskell programs automatically?
15:48:06 <solonarv> you can actually still install libraries, using 'cabal v2-install --lib whatever'; this builds 'whatever' (making sure it is in the cache) and then adds it to a list that GHC picks up by default
15:48:19 <solonarv> so, yes - just make sure to use v2-install
15:48:52 <solonarv> if you just want a quick GHCi session with a library you can also do: cabal v2-repl -b package1 -b package2
15:49:40 <gabbiel> so that will be a temporary session with the library, new sessions wont have that library avialable?
15:50:14 <solonarv> yup
15:50:17 <gabbiel> nice
15:50:53 <solonarv> for anything larger I recommend creating a project: 'cabal init' will help you do that (run it in a new directory)
15:51:53 <gabbiel> only that?
15:52:52 <solonarv> it will ask you a bunch of questions and create a package-name-here.cabal file, which you can then edit further if needed
15:53:13 <gabbiel> nice, never heard of interactive project creation 
15:54:11 <gabbiel> well, im off to start my haskell journey, thanks for the help solonorav & others.
15:54:36 <gabbiel> ill probably come back here if I'm really confused though
15:55:15 <solonarv> please do! I need to sleep, but I'm sure other people will be at least as helpful
15:58:55 <gabbiel> good night then
16:10:10 <shapr> gabbiel: got any questions as you start your Haskell journey?
16:17:04 <gabbiel> probably about if monads are as hard as people say it is
16:24:52 <boj> not hard, just not immediately clear
16:25:15 <boj> best thing to do there is just keep writing code until they click
16:25:41 <boj> i tend to suggest reading typeclassopedia over and over every couple weeks until it makes sense
16:32:01 <gabbiel> how many monads r there?
16:32:12 <wildtrees> gabbiel, understand fmap first, then fuctions being fmapped over m a which are a -> m b and then understand join 
16:32:54 <gabbiel> join is >>= ?
16:33:03 <wildtrees> gabbiel, alot, I would start out learning about Identity, Maybe, List and IO 
16:33:07 <wildtrees> no that is bind 
16:33:19 <wildtrees> a join after an fmap can be bind 
16:33:19 <gabbiel> hundreds?
16:33:33 <wildtrees> maybe there is a dozen or so that are commonly used 
16:33:41 <wildtrees> join . fmap is >>= 
16:33:48 <wildtrees> @type (>>=) 
16:33:50 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:33:54 <gabbiel> oh yeah cause anything can be a monad as long as some laws are followed
16:34:00 <gabbiel> so technically infinite
16:34:01 <wildtrees> @type (join . fmap) 
16:34:03 <lambdabot> error:
16:34:03 <lambdabot>     â€¢ Occurs check: cannot construct the infinite type: m ~ (->) (m a)
16:34:03 <lambdabot>       Expected type: (a -> a1) -> m (m a1)
16:34:30 <wildtrees> @type (\f s ->join . fmap f $ s) 
16:34:31 <lambdabot> Monad m => (a1 -> m a2) -> m a1 -> m a2
16:34:55 <wildtrees> the type signatures are almost the same for those, just flipped
16:35:03 <wildtrees> join is simple type signature wise
16:35:06 <wildtrees> @type join
16:35:07 <lambdabot> Monad m => m (m a) -> m a
16:35:23 <wildtrees> would let you turn a list of lists to a list
16:35:37 <gabbiel> how can join do anything if fmpa turns an M a to M b
16:35:37 <wildtrees> > join [[1..3],[4..10]] 
16:35:40 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
16:36:01 <wildtrees> the join has to be on an m (m a) where m is a functor that is also a monad 
16:36:15 <wildtrees> just learn fmap and functors for starters 
16:36:44 <gabbiel> functors seem simple because they are just a container, is it more than that?
16:38:45 <Axman6> functors are not just containers
16:38:46 <wildtrees> I tend to think of functors as containers, but they can be anything that obeys the Functor Law(s) 
16:39:24 <Axman6> functions aree functors, things which contain nothing are Functors (such a Proxy). There are containers which are not Functors (such as Sets)
16:39:49 <gabbiel> but most are containers?
16:39:54 <Axman6> data Proxy a = Proxy; instance Functor Proxy where fmap f Proxy = Proxy -- not a container
16:39:59 <gabbiel> I'll have to look at those laws again
16:40:10 <Axman6> it's a bad idea to limit yourself to thinking that
16:40:38 <gabbiel> wtf how can we fmap over a "container" containing nothing
16:40:55 <boj> that is the problem with the "container" analogy
16:40:57 <gabbiel> i have to go to walmart, ill b back in a sec
16:41:00 <Axman6> :t fmap
16:41:01 <lambdabot> Functor f => (a -> b) -> f a -> f b
16:41:09 <Axman6> :t fmap @Proxy
16:41:10 <lambdabot> error:
16:41:10 <lambdabot>     Pattern syntax in expression context: fmap@Proxy
16:41:10 <lambdabot>     Did you mean to enable TypeApplications?
16:41:22 <Axman6> %:t fmap @Proxy
16:41:31 <Axman6> % :t fmap @Proxy
16:41:31 <yahb> Axman6: (a -> b) -> Proxy a -> Proxy b
16:41:46 <Axman6> can you turn a Proxy a into a Proxy b?
16:42:03 <Axman6> it has one constructor, called Proxy, which has no other data in it
16:49:23 <solrize> anyone use haskell-mode.el and know whether recent ghc needs recent haskell mode?  i'm using an old-ish (11.2) haskell mode and it stopped working when i upgraded ghc
17:00:31 <shapr> solrize: you tried use-package? I think the ghci prompt has changed
17:00:58 <shapr> solrize: this might help? https://gist.github.com/shapr/d359a91c90419f5f5e99dfce338258e8
17:18:11 <solrize> shapr looking thanks
17:31:45 <solrize> is use-package no longer in use?
17:37:38 <solrize> i don't seem to have use-package and am having trouble finding it, looking around
17:42:41 <solrize> https://www.emacswiki.org/emacs/UsePackage  per this there are two of them and i don't know which one to want... will ask on #emacs
17:55:30 <gabbiel> hmm, so i have this type: data Rank a = Ace | Number a | Jack | Queen | King deriving (Show, Enum)
17:56:01 <gabbiel> How do I make sure that the a in Number a is an Integer from [2..9] ?
17:57:15 <Axman6> you can't easily - uoiu could hide the constructor and provide a smart constructor number :: Integer -> Maybe (Rank Integer)
17:57:40 <Axman6> or you could provide a completely new type for that range: data CardNumber = One | Two | Three | ...
17:58:01 <Axman6> uoiu = you*, not sure how I managed thaty
17:58:08 <Welkin> aeiou
17:58:54 <gabbiel> im confused
17:59:38 <gabbiel> I tried the second case
18:00:19 <gabbiel> Now how do I make sure a can only be a CardNumber? can I do a typeclass constraint?
18:00:55 <ddellacosta> what is the right way to describe kind *? Like, "singly-typed kind?"
18:01:25 <ddellacosta> unary?
18:01:43 <Axman6> well, you can remove the type parameter, data Rank = ... | Number CardNumber | ...
18:02:47 <shapr> user research: what are the past few research papers, theses, etc you read? I'm building a margin notes sharing app, and I want to test with some real documents
18:03:00 <shachaf> i,i newtype Rank = Rank Int
18:03:39 <shachaf> Haskell doesn't have a fancy way to have types for integer ranges like Ada.
18:04:06 <Axman6> sadly
18:04:40 <shachaf> If you want some type safety you can make a type, but I'm skeptical it's worth the trouble to do this data thing, especially nested types in that way.
18:05:56 <gabbiel> how else should I model this rank type then?
18:07:07 <Axman6> data Rank = Ace | Two | Three | ...
18:10:17 <solrize> i have to install cabal AND stack?  what is best way to install cabal if i already have stack installed?  still use ghcup?
18:10:25 <solrize> i.e. download and run ghcup?  that's not installed
18:10:33 <solrize> stack install Cabal doesn't seem to install cabal cli tool
18:10:48 <shapr> ghcup is outside of stack
18:10:52 <gabbiel> what is stack for
18:11:10 <sclv> Cabal is the lib. cabal-install is the executable
18:11:10 <shapr> stack is a different approach that wraps cabal into small slices of the library versions
18:11:19 <MarcelineVQ> cabal cli tool comes from cabal-install not Cabal
18:12:05 <gabbiel> is that necessary now that v2 exists for cabal?
18:12:11 <shapr> gabbiel: nope
18:12:13 <solrize> stlil trying to figure out how to install cabal-install then... otherwise haskell-mode complains about it not being available
18:12:27 <shapr> solrize: ghcup can install cabal for you
18:12:28 <solrize> i'm able to run ghci and stack ghc though
18:12:38 <solrize> ok so i'll run the ghcup installer then
18:12:48 <solrize> should i install haskell-platform and stack at the same time?
18:12:55 <shapr> for example, I setup ghc with "ghcup install 8.6.5 && ghcup install-cabal" after I'd grabbed the ghcup script
18:13:00 <shapr> solrize: no
18:13:04 <solrize> ok
18:13:10 <shapr> I would recommend ghcup only
18:13:10 <solrize> installing ghcup
18:13:52 <solrize> bunch of dependencies, installing
18:14:19 <solrize> it's installing ghc which is already installed!  :P
18:15:38 <solrize> anyway it's munching away, thanks
18:17:58 <MarcelineVQ> shapr https://arxiv.org/pdf/1804.02809.pdf http://neilsculthorpe.com/publications/safe-FRP-types.pdf http://okmij.org/ftp/tagless-final/course/lecture.pdf https://arxiv.org/pdf/1809.06336.pdf https://people.smp.uq.edu.au/YoniNazarathy/julia-stats/StatisticsWithJulia.pdf https://arxiv.org/pdf/1807.04085.pdf http://okmij.org/ftp/tagless-final/sharing/sharing.pdf https://arxiv.org/pdf/1808.09234.pdf
18:17:59 <MarcelineVQ> http://davidchristiansen.dk/david-christiansen-thesis.pdf https://arxiv.org/pdf/1904.01288.pdf
18:19:49 <shapr> MarcelineVQ: thanks! I'll add those to my test cases!
18:31:22 <monochrom> ghcup puts ghc under ~/.ghcup which is independent of any other installers.
18:32:10 <monochrom> Normally it also installs cabal-install. (Again under ~/.ghcup and independent of any other ways you installed things.)
18:33:13 <monochrom> I tell my students to just go with ghcup.  Plus it's also super transparent about what to do when you're done and what to erase everything. (Simply erase all of ~/.ghcup)
18:39:00 <solrize> monochrom, thanks, i did get ghcup installed and that seems to have installed cabal cli
18:39:08 <solrize> still trying to get haskell-mode working
18:39:30 <solrize> running cabal install cabal-install which may have been a mistake, it's installing tons of stuff ;)
18:40:02 <monochrom> Mostly a mistake unless you really need a "newer" version.
18:40:54 <solrize> well it's installing lots of stuff which i guess is good if it means i don't have to install it later
21:35:37 <isovector1> can i negate a condition in a cabal file?
21:44:07 <lyxia> if !impl(ghc-bar)
21:45:46 <isovector1> hmm. doesn't work in hpack
21:46:20 <isovector1> i just put in a dummy value for the true case /shrug
22:16:54 <lyxia> boo
23:13:30 <solrize> rsa:setup.Cabal-1.6.0.2, rsa:setup.Cabal-1.6.0.1, rsa:setup.Cabal-1.4.0.2,   <--- why is it complaining about those old versions of cabal, when I have 2.4.1 installed?
23:24:38 <solrize> killlowww
23:24:42 <solrize> oops sorry
23:42:38 <suzu> anyone here used beam?
23:42:54 <suzu> can i "runtime test" that my scheme is correct by.. selecting from a table with a limit of 1 and deepseq'ing the result?
23:43:03 <suzu> does that work / is there something better i can do
