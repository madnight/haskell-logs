00:13:29 <phaul> can someone shed some light on what's happening here? https://gist.github.com/phaul/2812dddbcbd64f5ca92987ce1bb8a445
00:14:47 <[exa]> phaul: you expect that `traceShow tr tr` always returns a singleton
00:14:58 <phaul> if it worked up to 'D' why does it stop there?
00:15:03 <[exa]> which is not the case when `tr` is an empty list
00:15:18 <[exa]> you can't feed empty list into pattern [a], nor [(a,b)]
00:15:34 <phaul> yeah but why? as I said it worked up to 'D'
00:16:28 <Rembane> The pattern [a] needs a list with exactly one element in
00:16:45 <Rembane> Zero elements or two elements won't match for instance.
00:18:55 <phaul> I say it  an other way. decode $ encode "ABC" works.
00:19:10 <phaul> as the length increased at some point it breaks
00:23:02 <Rembane> phaul: I don't really understand what the code does, but could (reads s) ever evaluate to something that isn't a list with one item in it?
00:25:29 <phaul> I don't see how. in this example it is fed with chunks of "1A1B1C1D... reading the 1 off as int, and leaving the tail. afaics there is only one way and always one way to read off an integer from the front of "1 followed by uppercase char"
00:25:53 <phaul> unless some hexa notation or scientific notation jumps in ! ??
00:26:03 <phaul> maybe that's it..
00:28:51 <tdammers> it's simpler than that
00:29:05 <phaul> by experiment I see that the char 'E' is the culprit 
00:29:08 <tdammers> [(i, s)] does not match on the empty list
00:29:26 <phaul> empty list is handled at top level definition
00:30:00 <phaul> also I can see that it works without 'E' and doesn't with it
00:30:00 <tdammers> no, it's not
00:30:02 <tdammers> empty input is
00:30:16 <tdammers> > reads "D"
00:30:19 <lambdabot>  []
00:30:53 <tdammers> > reads "1D" :: [(Int, String)]
00:30:54 <phaul> tdammers: if it was that how would it work with strings not containing 'E' ?
00:30:56 <lambdabot>  [(1,"D")]
00:31:13 <[exa]> phaul: are you encoding the numbers as 'prefix' or 'suffix' ?
00:32:16 <phaul> [exa]: I'm not sure what that means?
00:35:44 <phaul> > reads "1D1F" :: [(Int, String)]
00:35:46 <tdammers> ohh, I can see what the problem is
00:35:47 <lambdabot>  [(1,"D1F")]
00:35:52 <phaul> > reads "1E1F" :: [(Int, String)]
00:35:55 <lambdabot>  []
00:36:03 <phaul> here you go. these are different
00:36:14 <phaul> and I have no idea why
00:36:42 <tdammers> no wait, I can't
00:36:44 <tdammers> hmm
00:36:59 <Rembane> > 1E1
00:37:01 <lambdabot>  10.0
00:37:02 <Rembane> :t 1E1
00:37:04 <lambdabot> Fractional p => p
00:37:17 <Rembane> reads is way too cunning for us.
00:37:32 <tdammers> oh
00:37:33 <phaul> ok so it's trying scientific notation
00:37:34 <tdammers> oh dear
00:37:44 <tdammers> > reads "1E1" :: [(Int, String)]
00:37:46 <lambdabot>  []
00:37:46 <Rembane> phaul: Maybe you shouldn't use reads. What are you trying to do?
00:37:56 <dminuoso> > reads "1D1"
00:37:58 <lambdabot>  []
00:38:02 <dminuoso> > reads "1D1" :: [(Int, String)]
00:38:06 <lambdabot>  [(1,"D1")]
00:38:13 <Rembane> reads "E1"
00:38:20 <Rembane> > reads "1E"
00:38:22 <lambdabot>  []
00:38:23 <Rembane> > reads "E1"
00:38:27 <lambdabot>  []
00:38:31 <phaul> nm I will figure it out, but this confused the hell out of me :) 
00:38:55 <tdammers> personally, I'd probably use megaparsec for this
00:40:36 <tdammers> concat <$> many $ do { n <- read <$> some isDigit; c <- anyToken; pure $ replicate n c } -- untested, but you get the idea
00:48:58 <phadej> megaparsec also has stuff like `decimal`
00:49:03 <phadej> -- Parse an integer in decimal representation according to the format of integer literals described in the Haskell report.
00:49:38 <phadej> and scientific
00:52:58 <phadej> if nothing else, one can look how they are implemented :)
00:53:28 <phaul> guys. this was for small codewars exercise , no need for parser libraries here
00:53:38 <phaul> I ended up doing span isDigit
00:57:02 <phadej> i wonder how many non-haskell solutions are using regexps, which are just wrong
00:57:20 <phadej> (too often)
00:57:34 <phaul> https://www.codewars.com/kata/578bf2d8daa01a4ee8000046 take a look around :)
00:58:55 <phadej> that would be trivial with regexp or parser combinator
00:59:15 <phadej> lexing by hand is silly
01:00:04 <phadej> many (liftA2 (,) decimal anyToken) :: Parser [(Int, Char)] -- and from [(Int, Char)] it's trivial to reconstruct the string
01:01:12 <tdammers> well, the thing is, the usual economies of "ugh, parser libraries are a big hassle, it's going to take forever to set everything up" don't really apply to haskell
01:01:59 <tdammers> because (mega|atto|)parsec is super easy to add to your project and set up, and it pays off instantly
01:03:05 <tdammers> as to regexps; at least in PHP, the reason people use them for their parsers is because the language (and the de facto standard implementation) has a number of quirks that make hand-written recursive-descent parsers a no-go
01:03:26 <tdammers> for example, there is no TCO, so recursive parsers are basically out
01:06:21 <sm[m]> I love megaparsec, but the api is not memorable enough to hold in my head, like regexps are
01:07:06 <deltanull> mm ?
01:15:40 <tdammers> point in case, the popular haskell regex libraries don't really have a super memorable API either
01:15:56 <phaul> I have used many parser combinator libraries in the past and sometimes I roll my own applicative parser. I need no convincing if it's not about reading digits off from the front of a string. (this argument doesn't stand if the parser is already included). But it does if it involves adding it too cabal, building it, and importing it
01:16:05 <tdammers> let re = /^foo.*bar$/ in match re "foo or bar" -- doesn't work, unfortunately
01:18:04 <tdammers> idk, I already have parsec installed globally, don't remember how that happened, but probably from installing cabal itself, or maybe some other system-wide thing
01:18:14 <tdammers> which means it's also already built
01:18:20 <tdammers> and importing it is just one line
01:22:26 <phadej> tdammers: parsec is with GHC since 8.2 or 8.4
01:25:04 <phaul> since you are so determined in this argument I'll bite. The codewars kata is on 7.10.3. (yeah tell codewars.. it's crap). You can't controll what packages are available. Apart from all this what's wrong with https://gist.github.com/phaul/2812dddbcbd64f5ca92987ce1bb8a445
01:28:31 <tdammers> phadej: ah yes, right, haha
01:29:47 <tdammers> phaul: nothing wrong with it. it's just that I don't optimize my coding habits for golfing or "one hand tied on my back" style interview situations
01:50:37 <l8star> hi
01:50:40 <l8star> hi
01:52:03 <__monty__> Good morning l8star 
02:35:06 <solrize> my prog is fluctuating between around 30MB and 40MB memory usage... is that normal gc ups and downs or do i have a space leak?
02:36:26 <tdammers> hard to tell, but if it remains stable over long periods, then whatever space leaks you may have aren't running away
02:36:55 <tdammers> 40 MB isn't outrageous, but it depends what you're doing
02:36:56 <solrize> yeah i don't see it go over 40M
02:37:10 <solrize> 40M is fine i'm just trying to be better at spotting space leaks
02:37:40 <tdammers> I'm taking a more pragmatic stance here - as long as memory usage stays within reasonable limits, I'm fine with it
02:38:32 <solrize> yeah that's fine for this program 
02:38:34 <solrize> thanks
02:44:24 <dTal> I feel like whether 40 megabytes is impressively lean or hilariously bloated depends entirely on what you're doing
02:44:36 <dTal> strong AI? impressively lean
02:45:05 <dTal> reimplement 'cat'? hilariously bloated
02:45:40 <solrize> hmm  it's crunching bignums and using a dumb algorithm that keeps more of them on the stack than it has to
02:45:40 <tdammers> unless you're running on an architecture that has 40-megabyte wide CPU registers
02:45:47 <solrize> maybe i should rethink that
02:46:03 <solrize> yeah maybe i'll rewrite that bit tomorrow
02:46:05 <solrize> thanks
02:46:20 <solonarv> I would recommend profiling before doing any hasty rewriting
02:46:32 <tdammers> note that using more memory than you need to doesn't necessarily constitute a space leak ;)
02:46:37 <solrize> fair enough, doesn't hurt to be sure, but i have a pretty clear picture of what it's doing
02:46:48 <solrize> well it was the fluctuation that makes me suspect
02:47:04 <tdammers> also note that optimizing memory usage when you're not memory-constrained won't buy you anything useful
02:47:10 <solonarv> are you sure? you're talking about "keeping things on the stack", but the GHC runtime doesn't even have a stack in the usual sense
02:47:20 <solrize> well recursion depth
02:47:24 <solonarv> exactly
02:47:27 <solrize> not tail recursive
02:47:53 <solrize> it was simpler to implement non-tail-recursively but that's fixable with some hacking
02:47:54 <solonarv> the RTS does not use a call stack
02:48:08 <tdammers> recursion depth is not something to worry about in itself
02:48:20 <solrize> recursion depth where the args are bignums
02:48:26 <tdammers> but if your recursion fans out, or duplicates work, that's when you get into trouble fast
02:48:37 <solrize> nah it's just using some memory
02:48:46 <solrize> this machine has gigabytes so the 40mb doesn't make any difference
02:48:50 <tdammers> due to non-strict evaluation, you can even have infinitely deep recursions that run in constant memory
02:49:06 <solrize> this is doing an actual calculation, the args are evaluated
02:49:47 <solrize> anyway i better sign off.. it's late here... thanks for the advice
02:49:53 <tdammers> > let f (x:xs) = show x : f xs in f [1..] -- there you go, infinitely deep recursion running in constant memory, and it does actually evaluate the argument
02:49:55 <lambdabot>  ["1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17"...
02:50:43 <solrize> that's tail recursion sort of
03:08:54 <tdammers> yes it is
03:10:37 <lavalike> isn't (:) the tail call? i.e. not f
03:16:00 <tdammers> ah yes
03:44:22 <ocharles> Can anyone make sense of this super confusing QuantifiedConstraints error? https://gist.github.com/ocharles/bc38e459a721e9a16f85f55a93ec8f9a
03:44:49 <ocharles> Basically, GHC is saying "I wanted C (X y z), but I can't see that from the context forall y z. C (X y z)" which makes zero sense to me
03:47:03 <ocharles> Full file is at https://gist.github.com/ocharles/2dcaa49c411b76dcc70fee7a239bce90 if anyone wants to play. Will need the `kind-generics` package
04:11:51 <ocharles> https://stackoverflow.com/questions/56771446/ghc-cannot-deduce-an-instance-exists-despite-being-mentioned-in-a-quantified-con minimal repro on SO
05:05:07 <Jinna> https://www.fpcomplete.com/blog/2017/06/readert-design-pattern writes “If you have a runtime exception, you will lose your state in WriterT and StateT.”
05:05:34 <Jinna> What does this mean? What will the state be? How can I lose my state?
05:12:14 <geekosaur> Jinna, it means that any changes to it will be reverted to the original value, because the exception handler can't know about the state
05:12:18 <geekosaur> so it can't preserve it
05:13:30 <geekosaur> exception handling is a complex topic in any language. most just let you pretend it's not a problem, on the theory that all you can do is print a message and crash… which means lots of leaked resources and such these days when apps try to recover instead
05:13:55 <geekosaur> haskell, as usual, tends to make it more visible and force you to deal with it somehow
05:22:45 <dminuoso> Jinna: Think about how StateT actually works.
05:23:39 <dminuoso> Jinna: If we assume we are running `StateT Int IO ()`, which means there's an internal `Int -> IO ((), Int)
05:26:12 <dminuoso> Jinna: So that `Int -> IO ((), Int)`, if being provided with some `Int`, would give you some result `()` with the "current" state. If however that `IO` throws an exception, then you will never be able to obtain that resulting `Int` value.
05:26:54 <dminuoso> (Well strictly speaking it would give you an IO computatoin that if executed contained the resulting new state)
05:27:52 <dminuoso> It's kind of like `IO Int` could produce a runtime exception, the `Int` is "gone/not there"
05:40:21 <Jinna> Okay, I think I understand.
05:48:52 <delYsid``> Is there such a thing as an unlifted 64-bit word?
05:50:14 <Taneb> delYsid``: like GHC.Exts.Word64# ?
05:52:51 <delYsid``> hmm, maybe!
05:53:24 <delYsid``> How do I figure out which functions are defined for Word64#?
06:16:07 <cocreature> delYsid``: “not a lot” Word64#
06:16:14 <cocreature> oops, https://hoogle.haskell.org/?hoogle=Word64%23
06:19:19 <halogenandtoast> If I have _xy (Pos x y) f (Grid w h c) = Grid w h <$> ix (x + y * w) f c
06:19:32 <halogenandtoast> why does the a in _xy :: Pos -> Traversal' (Grid a) a
06:19:35 <halogenandtoast> have to be a monoid
06:20:49 <halogenandtoast> or I guess not a monoid, but a semigroup
06:20:53 <solonarv> it doesn't, because what you wrote there is actually a Lens and not merely a traversal
06:21:16 <solonarv> if you call it what it is the monoid constraint should disappear
06:21:51 <solonarv> or, wait, perhaps it isn't
06:21:55 <solonarv> didn't see the 'ix' in there
06:22:02 <halogenandtoast> solonarv: what do you mean? I want a generic Grid that can contain a's, but I want to be able to get to a specific a
06:22:34 <halogenandtoast> But maybe I am using it wrong, the error comes when I try to do view (_xy (Pos 1 1)) myMap
06:22:41 <solonarv> yes, that makes sense
06:22:46 <halogenandtoast> So I might be using it incorrectly
06:23:05 <solonarv> a Traversal can have zero, one, or many targets
06:23:26 <solonarv> if you try to 'view' these results they must be combined somehow, that's why the Monoid constraint appears
06:23:45 <halogenandtoast> Ah alright, should this just be a lens then, and not a traversal?
06:23:50 <solonarv> (or if there are zero, you just get back mempty)
06:23:56 <solonarv> if it can be a lens, yes!
06:24:10 <solonarv> however it looks like that isn't possible, what if the index is out of bounds?
06:24:16 <halogenandtoast> Right
06:24:22 <solonarv> lenses can't fail, they always have exactly one target
06:25:14 <solonarv> so you probably want to use an operator other than view: preview, perhaps, which returns 'Just' the first target or 'Nothing' if there aren't any
06:25:28 <solonarv> or toListOf, which gives you a list of them
06:26:05 <solonarv> in your case: preview (_xy (Pos 1 2)) myMap :: Maybe a
06:26:29 <halogenandtoast> Okay, that makes sense, a in this case is (Maybe Tile) so I might want to call join on that
06:27:08 <solonarv> yup, or you could instead use: preview (_xy (Pos 1 2) . _Just)
06:27:24 <halogenandtoast> oh good point
06:27:29 <solonarv> that "digs through" the Maybe in the optic you're building
06:27:30 <halogenandtoast> I forgot about _JUst
06:28:11 <solonarv> then you can also do something like: modify (_xy (Pos 1 2) . _Just) f -- to modify the tile at (1, 2) if there is one
06:29:08 <halogenandtoast> yup, I assume f there is just the Grid
06:29:12 <halogenandtoast> err
06:29:15 <halogenandtoast> nvm
06:29:25 <halogenandtoast> that's the modification function
06:29:36 <halogenandtoast> thanks solonarv!
06:30:37 <Jinna> https://www.fpcomplete.com/blog/2017/06/readert-design-pattern talks about “the Has trick”.
06:30:40 <Jinna> It shows a   class HasLog a where    getLog :: a -> (String -> IO ())
06:30:52 <Jinna> and with an  instance HasLog (String -> IO ()) where   getLog = id
06:30:59 <Jinna> Why this typecheck?
06:32:02 <geekosaur> a ~ (String -> IO ())
06:32:19 <solonarv> so when you write that instance, you can replace all the instances of 'a' with '(String -> IO ())'
06:32:21 <Jinna> Okay, so it finds its concrete type for `a` from the instance declaration?
06:32:33 <Jinna> Oki I see.
06:32:33 <geekosaur> that is, id :: x -> x, if you take x as (String -> IO ()), then getLog as id typechecks
06:32:35 <Jinna> Thx!
06:32:45 <solonarv> so you have 'getLog :: (String -> IO) -> (String -> IO)', and I think it's clear that that can be id
06:32:55 <solonarv> (oops, typo)
06:33:05 <Jinna> Yes, clear now, thanks you two.
06:34:49 <hyperisco> :t \f g x y -> f `id` g x `id` y
06:34:50 <lambdabot> (t1 -> t2 -> t3) -> (t4 -> t1) -> t4 -> t2 -> t3
06:35:01 <hyperisco> :t \f g x y -> f $ g x $ y
06:35:02 <lambdabot> (t1 -> t2) -> (t3 -> t4 -> t1) -> t3 -> t4 -> t2
06:35:08 <hyperisco> just sayin', go nuts
06:57:14 <Jinna> In https://www.reddit.com/r/haskell/comments/6gz4w5/whats_wrong_with_implicitparams/ I found this alias:   type App a = (?flag :: Bool, ?counter :: IORef Int) => IO a
06:57:20 <Jinna> What do the questionmarks mean?
06:57:44 <c_wraith> they're for an extension that is rarely used anymore.
06:58:21 <c_wraith> ImplicitParams
06:59:09 <c_wraith> basically they let you pass arbitrary values to a function from context. it's a kind of limited form of dynamic scoping.
06:59:33 <Jinna> Ah, like dynamic vars in CL?
06:59:38 <c_wraith> yep
06:59:42 <Jinna> okay, then it’s clear
06:59:44 <Jinna> thx
07:00:23 <c_wraith> you're welcome
07:31:05 <hyperisco> I want to make files of stubs. i.e. type signatures without implementations. Then I want to insert implementations based on a build configuration. Does that ring a bell for anyone?
07:31:43 <hyperisco> This is more disciplined and principled than conditional compilation.
07:32:44 <geekosaur> backpack maybe
07:33:15 <hyperisco> Uses… I can swap out platform specific implementations so that I can port code to different platforms.
07:34:24 <fendor> can i install ghc with ghcup only in userspace?
07:34:41 <fendor> no elevated priviliges?
07:34:56 <hyperisco> Backpack… parameterised modules… hmm.
07:39:12 <geekosaur> fendor, download the script manually and put it somewhere on your $PATH? which could be ~/.local/bin or ~/.bin or whatever
07:39:43 <fendor> geekosaur, did that, now I tries to install ghc to /usr/local/bin
07:40:28 <fendor> nah, not true
07:40:39 <fendor> but it fails in the configure step
07:44:05 <geekosaur> you have everything you need?
07:44:23 <fendor> not sure
07:44:45 * geekosaur just looked over "ghcup debug-info" and "ghcup print-system-reqs" (I normally use hvr's repo instead)
07:51:38 <fendor> welp. fuck me
07:51:43 <fendor> i mean, damn me
08:05:37 <jgt> the thing that most offended me was that you didn't capitalise the word 'I'.
08:07:38 <tdammers> so download the "generic Linux" tarball, untar, cd, ./configure --prefix=~/.local, make install?
08:20:22 <fendor> tdammers, yeah did roughly that, now it works, thanks :)
08:20:30 <fendor> jgt, sorry :/
08:31:02 <monochrom> ghcup has always been user-space, no?
08:38:25 <geekosaur> as long as its own requirements are met. there's a couple of things in that that might not always be installed, especially if one is e.g. stuck with rhel
08:39:15 <geekosaur> (especially since rhel still hasn't invented the concept of build-essential yet.)
08:39:17 <maerwald> geekosaur: rhel is now supported, kinda
08:39:28 <maerwald> the centos7 tarball works
08:39:38 <fendor> monochrom, not if you stupidly install it with sudo
08:40:17 <maerwald> fendor: ghcup never installs anything outside the home directory
08:40:49 <fendor> maerwald, it did when I installed the ghcup script with sudo, e.g. curl ... > sudo sh
08:40:54 <maerwald> no
08:40:59 <fendor> weird
08:41:06 <fendor> but it installed stuff to /usr/local/bin
08:41:06 <maerwald> I wrote it, I would know if it did :P
08:41:19 <maerwald> what stuff
08:41:33 <fendor> ghc-8.6.5, ghc-pkg, ghc, haddock...
08:41:53 <geekosaur> hm, was it itself installed somehow to /usr/local/bin? that said, the failure mode I'd most expect is /root/... not /usr/local
08:42:23 <fendor> yeah, i think that happened
08:42:37 <fendor> ghcup itself was also in /usr/local/bin
08:43:04 <fendor> it was definitely my mistake
08:43:52 <geekosaur> if it uses its own location to figure out where to install stuff, and you dropped it in a system directory, yes, that'd end up somewhat unfortunate
08:44:04 <geekosaur> the good news is, you fix it by copying it somewhere sane
08:44:15 <maerwald> ghcup does not install under /usr/local/bin under any circumstance. It would install into $HOME/.ghcup/bin
08:44:33 <maerwald> so even if your HOME env variable is messed up, stuff would not be in /usr/local/bin
08:46:26 <fendor> geekosaur, i nuked everything and started from new. I got into that mess because my home dir was mounted with noexec
08:46:54 <fendor> maerwald, sounds weird, but there definitely was stuff in /usr/local/bin that I did not copy by hand over there
08:47:07 <maerwald> reproduce or show logs
08:48:08 <fendor> ill see if I can reproduce it, but I am kind of out of memory on that vm
08:49:51 <fendor> oh, I think I have an idea what happened
08:50:57 <fendor> since the partition was no-exec, and I wasnt aware of it, i tried to untar the file in .ghcup/cache myself and executed configure and then make install, which failed. I bet that installed it to /usr/local/bin 
08:51:06 <maerwald> yes
08:51:33 <fendor> alright, makes sense
08:51:44 <fendor> now it correctly tried to install ghc to /root/.ghcu
08:52:14 <fendor> alright, learned somethign new
08:52:47 <njay> Hey! Do I have to limit myself to Haskell questions on this forum? A friend of mine encouraged me to ask any and all questions about compilers over here, because the crowd is super helpful. I'm trying to understand some code that was spit out by the Tensor Algebra Compiler. :P But if this isn't the forum, that's fine.
08:53:00 <maerwald> we check $HOME env variable and existence of ~/.ghcup and related directories before doing anything. The code is full of paranoia checks
08:53:37 <fendor> maerwald, ghcup is great, didnt have a problem so far, my main problem is the vm 
08:53:57 <maerwald> the worst thing you can do is overwrite GHCUP_INSTALL_BASE_PREFIX with /, but even then it will install into .ghcup subdir only ;)
08:54:26 <bollu> njay ping. 
08:54:43 <solonarv> what? why are there four of me!?
08:55:11 <bollu> njay that might be a question that's far too offtopic ;) But what's the code that was spit out?
08:56:35 <maerwald> fendor: well, you got me scared for a second ;)
08:56:45 <fendor> maerwald, sorry, my bad :(
08:57:11 <maerwald> (I prefer package managers)
08:58:13 <njay> Ugh, there doesn't seem to be a good way to format the code from my phone. I'm looking at the assembly loop generated by the expression `x(i) = y(i) + z(i)`. Here's the code generator: http://tensor-compiler.org/codegen.html
08:59:13 <bollu> mmhm, what about it?
08:59:25 <fendor> maerwald, debian9 ghc version is rather old. ghcup was the least amount of hassle
08:59:45 <solonarv> that's what hvr's ppa is for
08:59:48 <njay> The body of the nested loop seems to just initialize a value (`jA`) and that's it. Is it just caching values? What's going on there?
09:00:31 <solonarv> however I am not sure how good apt (or any other .deb-based package manager?) is at having multiple versions of a package installed
09:00:35 <bollu> njay what tab are you talking about?
09:00:38 <maerwald> yeah, the ppa also allows multiple versions and switching via update-alternatives
09:00:49 <maerwald> solonarv: seamless
09:00:54 <solonarv> cool!
09:00:55 <fendor> i will give it a try next time i have to setup a haskell dev environement in a vm
09:02:20 <bollu> njay I see reasonable code being generated from the "complete code" tab: https://gist.github.com/bollu/2827845c802ee21ffad7983ed87fcfe7#file-complete-code-c-L53
09:03:07 <njay> bollu network connection is getting real fuzzy, I'mma have to fix that and ping later. Sorry about this.
09:05:52 <tdammers> apt is very good at it, but only if the package repo cooperates (as in, offers those different versions under different names)
09:06:40 <tdammers> so you could, for example, have packages named ghc8.6.5 and ghc8.4.3 in the repo, and then point a virtual package ghc8 to ghc8.6.5
09:25:34 <Jinna> Both DeriveAnyClass and GeneralizedNewtypeDeriving are enabled Defaulting to the DeriveAnyClass strategy for instantiating Applicative  ==> how can I default to GND for my newtype?
09:25:51 <phadej> Jinna: DerivingStrategies
09:28:29 <Jinna> phadej: looks good, thx
09:31:29 <phadej> Jinna: https://github.com/ndmitchell/hlint/issues/690
09:46:16 <Jinna> Helpful, thanks.
09:46:29 <Jinna> I don’t understand this first code example here: https://ghc.gitlab.haskell.org/ghc/doc/users_guide/glasgow_exts.html#extension-DerivingVia
09:46:54 <Jinna> Where is `showHex` coming from?
09:47:22 <phadej> Numeric
09:49:08 <pagnol> what would be an idiomatic way to get something like (A -> A) -> A -> Int -> [A], where a function is recursively to a seed value and the successive results are accumulated?
09:49:25 <pagnol> * applied recursively n times
09:49:33 <lavalike> :t unfoldr -- could use this as a base
09:49:35 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
09:50:13 <nshepperd> pagnol: use 'iterate' to make an infinite list of the successive values, then 'take' the first n
09:50:23 <lavalike> :t \f x n -> take n $ iterate f x
09:50:25 <lambdabot> (a -> a) -> a -> Int -> [a]
09:50:40 <pagnol> thanks
09:50:51 <lavalike> > take 10 [1] -- beware
09:50:54 <lambdabot>  [1]
09:51:03 <nshepperd> > iterate (*2) 1
09:51:07 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
09:51:08 <pagnol> I actually didn't know about iterate
09:51:11 <nshepperd> > take 10 $ iterate (*2) 1
09:51:14 <lambdabot>  [1,2,4,8,16,32,64,128,256,512]
09:51:36 <hyperisco> takeNoMoreThan
09:51:50 <nshepperd> take it away, ernie
10:00:45 <fgaz> What was the best CIS 194 again? I remember that 2013 is good and 2014 is not. What about the latest (fall 2016)?
10:10:08 <saml> it's always the best
10:14:59 <hyperisco> "yes"
10:24:17 <geekosaur> @where cis194
10:24:17 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
10:28:06 <dada_cetacean> hello, i have something of type [IO String], how do i turn this into an IO String whose value is the concatenation of all the strings?
10:30:38 <hyperisco> dada_cetacean, fold
10:31:27 <fgaz> geekosaur: thanks
10:31:59 <dmwit> dada_cetacean: The easy way is `fmap concat . sequence`.
10:32:08 <dmwit> dada_cetacean: The cute way is `getAp . foldMap Ap`.
10:32:32 <hyperisco> If that is easy then how would you describe using fold?
10:32:47 <dmwit> dada_cetacean: But I bet you got this list as a result of a `map` in the first place, in which case you should use `traverse f` instead of `sequence . map f`.
10:32:57 <dmwit> hyperisco: not working
10:33:07 <hyperisco> Why =\
10:33:39 <nshepperd> :t fold :: [IO String] -> IO String
10:33:40 <lambdabot> [IO String] -> IO String
10:34:04 <dmwit> hyperisco: I am wrong. I thought the Monoid instance for IO was (>>) and throw an exception, but it's much better! Nice!
10:34:18 <hyperisco> :D
10:35:03 <dmwit> In that case, I agree with hyperisco, and my comment before about "this probably came from a map" should be updated to say "use `foldMap f` instead of `fold . map f`".
10:38:25 <hyperisco> Ap was a nice way to get it for free though if we didn't have that instance
10:42:57 <dada_cetacean> thanks for the answers
10:43:16 <dada_cetacean> where does `fold` live? i seem to only have `foldr` and `foldl` in scope
10:43:34 <hyperisco> https://hoogle.haskell.org/?hoogle=fold&scope=set%3Astackage
10:44:26 <hyperisco> Our deprecation error is called Whoops? lol
10:45:08 <dada_cetacean> aha, thanks :^)
10:46:05 <fendor> > fold [Just (Sum 3), Nothing]
10:46:07 <lambdabot>  Just (Sum {getSum = 3})
10:46:49 <fendor> > fold [Sum 3, Sum 4, Sum 7]
10:46:49 <adamCS> Is there some straightforward way to have "getDataFile" from the autogenerated module give the "v2-build"/"new-build" location where it installed things when doing a build?  I have an executable that uses a library which installs data files.  But when developing, say using ghcid, those data-files aren't found since they are installed in the dist-newstyle/store/XXX directory rather then where "getDataFile" thinks.
10:46:51 <lambdabot>  Sum {getSum = 14}
10:47:30 <hyperisco> > ala Sum foldMap [3, 4, 7]
10:47:33 <lambdabot>  14
10:47:53 <fendor> really cool
10:47:58 <fendor> @type ala
10:48:00 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor f) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
10:48:06 <hyperisco> You're not supposed to do that!
10:48:07 <fendor> alright...
10:48:39 <fendor> what is that? :O
10:49:40 <geekosaur> adamCS, no. cabal v1-style builds used an evil hack that was unreliable. the best you can do is an alternative that checks an envar or falls back to e.g. looking based on path to the executable, itself unreliable aand subject to e.g. whether you choose to follow symlinks or not
10:49:41 <edwardk> adamCS: no standard way, no. its somewhat frustrating, as i'd like to be able to have the test suite for instance look for test files but not install them in the data dir
10:50:23 <edwardk> you _can_ use a custom Setup.hs to extract the autogen dir, and export a module that you then use to get at the path info from build time
10:50:35 <edwardk> but that isn't compatible with the new separate incremental build stuff
10:51:19 <hyperisco> fendor, in this case, if you have a function  f' :: A' -> A'  and  A'  is a newtype of  A  then you can get  f :: A -> A  by wrapping the argument and unwrapping the result
10:52:03 <adamCS> geekosaur, edwardk: Oy.  Okay.  I guess I'll just make local copies when developing that way.  Is that something that's on anyone's radar to fix?  Should I open an issue?
10:52:16 <edwardk> adamCS: http://hackage.haskell.org/package/cabal-doctest-1.0.6/docs/src/Distribution-Extra-Doctest.html is a descendant of the way i used to find everything in my custom Setup.hs files
10:52:31 <fendor> yeah, that makes sense, but what us the Rewrapped typeclass?
10:53:19 <geekosaur> adamCS, maybw you can think of a surefire works for everyone way
10:53:26 <edwardk> adamCS: you can look at the cabal-doctest documentation for how to run it, not sure if the extra module it builds is has what you'd need but its close
10:53:46 <hyperisco> fendor, A generic way to wrap and unwrap newtypes
10:54:00 <geekosaur> everybody else keeps running into stuff that wants to do it *their* way period
10:55:09 <adamCS> geekosaur, edwardk: Thanks!  I doubt I can figure out any way that's generic enough for everyone.  I don't really care how it works as long as the library can always find the data files as long as cabal was used to install the library.  That seems like the minimum?  But I only know my use case. 
10:55:41 <edwardk> adamCS: my usual compromise is to look for a relative dir and if i find it great, if not check for the data dir
10:55:50 <edwardk> that way for local single project builds it works
10:55:55 <edwardk> and for installed builds it works
10:56:21 <edwardk> but its not perfect, as if i have a top level cabal.project file and try to run cabal new-test some-sub-project it fails to find the files because they are relative to a subdirectory
10:56:23 <fendor> so, to have a function that transform f :: A -> A, into a f' :: A' -> A' and then back again, we need Rewrapped s t AND Rewrapped t s?
10:56:51 <adamCS> edwardk: But that still won't work for the local build of a project where the package that needs the data is a dependency, right?
10:57:17 <edwardk> my compromise there is to have everybody share a symlinked common test/data folder or whatever
10:58:04 <edwardk> e.g. in codex i've got a dozen subprojects that all want access to font files, etc. and its really repetitive to store several copies of them in the repo, but symlinking a data dir into each sub-project means they can use relative locations fine and share common data
10:58:21 <edwardk> works for mac/linux pretty well. not sure about git and symlinks on windows
10:58:27 <phadej> they ~work
10:58:36 <phadej> where ~ is really long and bumpy
10:59:07 <hyperisco> fendor, I am not sure what the motivation is for Rewrapped.
10:59:13 <phadej> https://github.com/git-for-windows/git/wiki/Symbolic-Links
10:59:15 <adamCS> edwardk:  Yeah.  I'm imagining a workflow where local builds might be the typical user experience and I'd rather they not have to install the files.  The library (also mine) is knit-haskell, a pandoc-wrapper that I am using to make data-science html output.  And my imagined use-case is someone just developing the executable that uses knit-haskell and builds an html as output and never needs to do a full install of their
10:59:15 <adamCS>  project.
10:59:38 <edwardk> hyperisco: 
10:59:47 <edwardk> > ala Sum foldMap [1..10]
10:59:50 <fendor> the motivation seems pretty clear, typeclass to access the data of newtypes. Looks kind of like a coerce, 
10:59:50 <lambdabot>  55
11:00:13 <adamCS> edwardk:  So I'm trying to figure  out how to get a user set up that way with minimal fuss.
11:00:22 <edwardk> adamCS: i feel your pain
11:00:25 <adamCS> But that might mean copying the files.
11:00:28 <hyperisco> edwardk, why Rewrapped?
11:00:41 <adamCS> edwardk: :)
11:00:53 <geekosaur> it's a "userspace" version of Data.Coerce.coerce (which relies on the compiler to track fake Coercible instances it autogenerates for newtypes)
11:00:54 <edwardk> hyperisco: originally it was a a 4 parameter typeclass
11:01:23 <edwardk> class Wrapped s t a b | s -> a, t -> b, s b -> t, t a -> s where ...
11:01:31 <edwardk> but this actually led to less than perfect type inference
11:02:11 <edwardk> so i split the class in two, which helps in some edge cases
11:03:18 <hyperisco> The question I think is why not just  ala :: (Wrapped s, Functor f) => (Unwrapped s -> s) -> ((Unwrapped s -> s) -> f s) -> f (Unwrapped s)
11:03:39 <edwardk> :t ala
11:03:42 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor f) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
11:03:42 <sm[m]> hey all. We found a windows issue with trailing periods in file paths that can cause data loss (https://github.com/simonmichael/hledger/issues/1056#issuecomment-505911528) - have you heard any discussion of this ? I'm wondering which upstream libs might care about it - base ?
11:03:59 <edwardk> because being able to change types is generally useful in lens-world?
11:04:06 <edwardk> why aren't _all_ lenses just Lens' s a?
11:04:18 <sm[m]> (or maybe it's not a general problem..)
11:04:54 <sclv> sm[m]: ugh!
11:04:58 <edwardk> :t auf
11:04:59 <lambdabot> Optic (Data.Profunctor.Types.Costar f) g s t a b -> (f a -> g b) -> f s -> g t
11:05:04 <sclv> maybe FilePath is the place to "fix" that?
11:05:05 <hyperisco> I don't know. That is what I was asking about XD
11:05:11 <geekosaur> sm[m], not sure that's a fixable tbh
11:05:15 <edwardk> er that combinator is 'xplatf' now
11:05:17 <sclv> i think base's notion of filepaths is os agnostic
11:05:30 <sclv> but FilePath does handle o.s. specific quirks to a certain degree...
11:05:30 <geekosaur> windows is windows, it has too much legacy stuff
11:05:56 <sclv> i.e. if you try to use it to build something with a trailing dot on windows it might as well just error or something
11:06:01 <hyperisco> If it is analogous to Lens vs Lens' then I just don't have the imagination to think of what else to use ala for.
11:06:16 <edwardk> :t au
11:06:18 <lambdabot> Functor f => AnIso s t a b -> ((b -> t) -> f s) -> f a
11:06:24 <nshepperd> :t ala Const
11:06:25 <sm[m]> I worked around it in the app by warning/failing when such a path is used.. I figure maybe filepath could at least include a check function to highlight the issue
11:06:25 <lambdabot> forall k1 k3 (f :: * -> *) a'1 (x'1 :: k1) a'2 (x'2 :: k3). Functor f => ((a'1 -> Const a'1 x'1) -> f (Const a'2 x'2)) -> f a'2
11:06:54 <edwardk> there should have been at least one type-changing example
11:06:59 <edwardk> it came up when we were writing the combinator
11:07:32 <sm[m]> like isWindowsUnsafeDotPath here: https://github.com/simonmichael/hledger/commit/014db152d922db00cfec29dbee912c3eda64c812#diff-90a42ccfdc974bb2089e85d6c70705e1R146
11:07:37 <edwardk> i guess all the current examples are boring foldMap ones
11:07:54 <hyperisco> Could add a traverse example :P
11:08:44 <nshepperd> :t ala Const `asAppliedTo` traverse
11:08:46 <lambdabot> (Monoid a', Traversable t) => ((a' -> Const a' x') -> t a' -> Const a' (t x')) -> t a' -> a'
11:09:22 <edwardk> hyperisco: > ala Identity traverse [1,2,3] -- is kinda boring =)
11:09:23 <nshepperd> that's an example of type changing
11:10:23 <edwardk> anyways the typechanging use shows up more clearly in the au/auf (now xplat/xplatf) case
11:10:40 <edwardk> where they turn lens-style isos into the 'two functor' style isos
11:10:49 <edwardk> :t xplatf
11:10:50 <lambdabot> error:
11:10:50 <lambdabot>     • Variable not in scope: xplatf
11:10:50 <lambdabot>     • Perhaps you meant one of these:
11:10:54 <edwardk> :t auf
11:10:57 <lambdabot> Optic (Data.Profunctor.Types.Costar f) g s t a b -> (f a -> g b) -> f s -> g t
11:11:14 <hyperisco> :t alaf Identity fmap
11:11:16 <lambdabot> (a -> b) -> Identity a -> Identity b
11:11:25 <edwardk> you give me an Iso s t a b         and i give you a function (f a -> g b) -> f s -> g s
11:12:45 <edwardk> anyways re Rewrapped, it tries to extract the maximal amount of information from the types involved
11:13:17 <edwardk> instead of s t a b | s -> a, t -> b, s b -> t, t a -> s     -- i want to learn from s ~ Product a     that t ~ Product something
11:13:30 <edwardk> which then helps fill in the rest
11:13:52 <edwardk> The Cons typeclass in lens could _probably_ do with something similar
11:14:23 <edwardk> so now we have _Wrapped' :: Wrapped s a => Iso s a
11:14:26 <edwardk> er Iso' s a
11:14:38 <edwardk> and from that and Rewrapped, we construct the final _Wrapped iso
11:14:46 <edwardk> which is maximally informative to the typechecker
11:15:22 <edwardk> and this dispelled the few issues we had filed against it
11:15:36 <edwardk> or that were imagined and carefully crafted on #haskell-lens
11:15:53 <nshepperd> ah, so 'instance (t ~ Const a' x') => Rewrapped (Const a x) t' for example is just saying 'infer that the outer type constructor of the result is a Const, dammit'
11:16:02 <hyperisco> Have you considered the route of constraint kinds? Combined with closed type families, I was able to improve type inference in certain situations. Not sure the exact set of problems you're tacking here.
11:16:13 <edwardk> nshepperd: yep!
11:16:37 <nshepperd> where the 'the result' is the output of a function like foldMap or a traversal
11:16:45 <edwardk> nshepperd: because we were getting tripped up in a few places where that much info about t wasn't implied from the info on hand
11:18:16 <edwardk> i basically sat there staring at the 4 argument version until i tried to use my informal reasoning about what information should be able to be inferred to find a set of classes i could stack on top of each other that would enable that sort of 'eta-like' shape info to flow
11:18:28 <adamCS> edwardk, geekosaur:  Okay, not that this solves all cases, but in my case the right paths are found if I run the exe via "cabal v2-run" rather than directly.  That way it finds the paths in the nix-style-build store.  You probably already knew but for anyone else who finds this conversation that might be useful! Thanks again!
11:18:56 <edwardk> adamCS: good to know!
11:18:57 <Roxanne_98> --- Control me during my Live. I've toys ready and I am already wet. I have 2 free VIP Invites left. Be quick and get 1 of them! Believe me, the fun is guaranteed! Enter now ---> http://iqi.su/Ta9Ty
11:20:19 <hyperisco> edwardk, I am referring to something like this which allows one to construct a Constraint from a type https://hackage.haskell.org/package/data-foldapp-0.1.1.0/docs/src/Data-FoldApp-Generic.html#line-55
11:20:42 <hyperisco> You might have done essentially the same thing with a type class
11:21:19 <edwardk> hyperisco: at the expense of shortening the window of ghc versions it works over, and making the class considerably harder to use
11:21:31 <edwardk> we had similar hacks we experimented with for contains
11:22:14 <hyperisco> Aw well we don't want to slander Haskell's type features as hacks do we? :P Just pointing that out in case you hadn't considered it.
11:22:14 <edwardk> but without the ability to cleanly talk about implication at the constraint level or talk about lub of constraints, you can quickly paint yourself into a corner with that approach
11:22:47 <edwardk> quantified constraints in theory will let us sort of solve one of those two problems, but not the lub-like one
11:26:02 <dada_cetacean> does anyone know why (readProcess "eval" ["echo", "hello world"] []) doesn't work?
11:26:09 <edwardk> i still go wishy washy about wanting to fix contains back to working as a fold for some instances, so you could use x^.contains key as a boolean to 'read' whether or not the key was in a map, but still write back to it in a set, but the cost is that users that want to use the full power of the lens suffer and we'd have to seriously raise the lower version bound on lens
11:27:14 <dmwit> edwardk, adamCS: I think v2-run is supposed to set up the right env vars for getDataFile to work, isn't it?
11:27:42 <dmwit> Oh, you discovered this already. Good.
11:27:48 <dmwit> I can't read fast enough. =P
11:27:51 <adamCS> dmwit:  Yeah.  I just figured that out.  Took a little bit of discovery...
11:28:03 <dmwit> Sorry I wasn't here when you asked to save you the time.
11:28:03 <adamCS> dmwit: Thanks, though!
11:28:43 <dmwit> dada_cetacean: eval isn't a process, it's a bash builtin.
11:28:46 <adamCS> dmwit: I did learn a lot about the v2-issues in general though.  So.
11:29:13 <dmwit> dada_cetacean: What's wrong with `readProcess "echo" ["hello world"] []`?
11:30:56 <dmwit> If you *must* have eval (you really shouldn't, so tell us why you think you need it) you can `readProcess "bash" ["-c", "eval echo \"hello world\""] []`.
11:31:23 <hyperisco> Also I want to remark that Constraint is the C++ programmer's template dream.
11:34:29 <pavonia> Is there a function in the base modules like groupBy that doesn't just look at adjacent elements but creates an actual partition?
11:34:47 <hyperisco> What because now you have higher order templates. Why talk about Functor when you can just talk about the type classes vaguely similar? :P
11:36:45 <hyperisco> We should do this so that traditional Functor code generalises to GFunctor ;)
11:36:56 <[exa]> pavonia: 'partition' as in 'buckets for elements of the same category' or some different meaning?
11:38:09 <pavonia> [exa]: Yes, that meaning
11:38:55 <pavonia> Like mapping with a certain function, and if the results are the same, collect all these elements in a list/set
11:41:47 <[exa]> pavonia: there's a bit of extra construction required to do that kind of bucketing right that depends on situation so I kindof doubt it will be in Base
11:42:17 <[exa]> but using Map that function should be easy
11:45:23 <pavonia> Hhm, I think a combination of sortBy and groupBy might work
11:45:31 <[Leary]> % (\f -> M.elems . foldr (\a -> M.alter (Just . maybe [a] (a:)) (f a)) M.empty) even [0..10]
11:45:31 <yahb> [Leary]: [[1,3,5,7,9],[0,2,4,6,8,10]]
11:46:08 <[Leary]> It's not too bad with Map. Might be a better way.
11:46:35 <geekosaur> pavonia, would probably work might be suboptimal
11:46:46 <geekosaur> do remember that lists are dumb
11:47:04 <hyperisco> > partition (\x -> x % 2 == 0) [1..10]
11:47:07 <lambdabot>  ([],[1,2,3,4,5,6,7,8,9,10])
11:47:14 <pavonia> % (\f -> M.elems . foldr (\a -> M.alter (Just . maybe [a] (a:)) (f a)) M.empty) (\x -> x `mod` 4) [0..10]
11:47:15 <yahb> pavonia: [[0,4,8],[1,5,9],[2,6,10],[3,7]]
11:47:17 * hyperisco shrugs
11:47:23 <pavonia> Nice, [Leary]
11:48:04 <hyperisco> > partition (\x -> x `mod` 2 == 0) [1..10]
11:48:07 <lambdabot>  ([2,4,6,8,10],[1,3,5,7,9])
11:49:01 <hyperisco> Oh, % is the Ratio constructor, heh.
11:49:11 <ddellacosta> is there anywhere to buy Haskell merchandise (logo stickers in particular) where the proceeds go to core team members or folks who are otherwise working on open source Haskell libraries/applications/etc.?
11:50:27 <hyperisco> For more buckets you have to extend Bool, I guess :)
11:52:22 <phadej> ddellacosta: there aren't "core team members" :(
11:52:44 <phadej> we are so nice, we give out stickers for free
12:01:32 <ddellacosta> phadej: I dunno, committee members, or what have you
12:02:03 <ddellacosta> basically just wanted money for a sticker to go to someone who contributes to the ecosystem more than just selling stickers
12:02:27 <ddellacosta> but sounds like there's nothing like that
12:02:52 <phadej> I'm not aware of :(
12:03:04 <phadej> ping georgew ^
12:03:15 <phadej> haskell.org could sell some merchandise indeed
12:03:17 <cocreature> ddellacosta: go to events like zurihac, you’ll get stickers for free and you and you can buy the people that are core contributors in some form a beer or another beverage of their choice :)
12:06:41 <ddellacosta> cocreature: I'd like to buy some stickers online ideall. I was kinda hoping to get some at Compose Conf. these past few days but either there weren't any or I didn't see them. 
12:06:46 <ddellacosta> *ideally
12:07:31 <ddellacosta> phadej: yeah, there's a wiki page linking to places to buy them to be clear, it just wasn't clear to me who benefits: 
12:07:36 <ddellacosta> https://wiki.haskell.org/Merchandise
12:08:09 <ddellacosta> anyways, thanks folks, I'll just grab some from one of these places for now, and keep my eyes out for more next conference I go to
12:08:19 <wildtrees> some new version cabal just yelled at me about update, whats the new style for updating my local hackage? 
12:08:41 <cocreature> yeah that’s totally fair, I was partially kidding although for zurihac that does seem to work quite well ime :)
12:08:56 <sclv> i think usually when they're at a conference its because someone pays for 'em and then gives them away for fun
12:09:04 <ddellacosta> cocreature: also I'd have to fly overseas to Switzerland, not that I'd mind :-D
12:09:23 <cocreature> ddellacosta: it’s worth it!
12:09:33 <ddellacosta> cocreature: that's what I hear!
12:10:47 <sclv> ddellacosta: it might be worth pinging committee at haskell.org to see if they'd want to set up an "official" sticker shop to get the funds going the right way
12:11:17 <sclv> (personally i think the redbubble ones are the nicest)
12:11:24 <geekosaur> wildtrees, recent cabal assumes any non-prefixed command is v1 and warns that v1 is becoming non-default
12:11:28 <geekosaur> v2-update will work
12:11:45 <geekosaur> cabal 3.x will default to the v2-commands instead of the v1-commands, iirc
12:12:27 <wildtrees> do I have to switch to all v2 stuff in the future or prefix everything I current know that is v1? 
12:13:08 <geekosaur> switch or prefix, yes
12:13:26 <tdammers> I'd recommend switch
12:13:30 <geekosaur> ideally you sunset any v1-specific usage. except theres' some things that still benefit from v1-style
12:15:47 <wildtrees> is there a good resource/url for the changes to cabal for migration? 
12:16:33 <phadej> wildtrees: unfortunately not really, but it's quite a massive change, so TL;DR 'everything is changed'
12:16:42 <phadej> wildtrees: but in most cases 'cabal v2-build' just works
12:16:56 <phadej> it just works very very differently
12:17:36 <phadej> so reading through https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
12:18:08 <sclv> note that _files_ don't need to be migrated, with certain exceptions. rather you just sort of change your workflow to use the new commands
12:18:24 <fragamus> anyone seen byorgey
12:19:15 <ddellacosta> sclv: thanks, I'll look into it!
12:39:07 --- mode: ChanServ set +o Sigyn
12:41:25 <dmwit> pavonia: https://stackoverflow.com/q/12398458/791604
12:41:47 <dmwit> > M.fromListWith (++) [(x `mod` 4, [x]) | x <- [1..10]] -- tl;dr
12:41:49 <lambdabot>  fromList [(0,[8,4]),(1,[9,5,1]),(2,[10,6,2]),(3,[7,3])]
12:43:35 <dmwit> Toss an elems on front if you want.
12:43:48 <dmwit> > M.elems $ M.fromListWith (++) [(x `mod` 4, [x]) | x <- [1..10]]
12:43:50 <lambdabot>  [[8,4],[9,5,1],[10,6,2],[7,3]]
12:44:24 <dmwit> But for most uses the non-elems version is more useful anywayp.
12:45:51 <dmwit> wildtrees: I liked http://blog.ezyang.com/2016/05/announcing-cabal-new-build-nix-style-local-builds/ as a very brief overview back when this stuff was brand new. I referred to the "old-style vs new-style" table many times while learning v2-*.
12:46:16 <pavonia> dmwit: Thanks
12:46:37 <dmwit> It's a bit outdated now, though; e.g. there's v2-run, v2-test, v2-benchmark, v2-haddock, v2-install counterparts for that table.
13:01:56 <deech> Is there a way to "cross-generate" Haddocks, for example, if I have a two functions one that only works on Windows and one for OSX?
13:09:33 <c_wraith> deech, if you really want to get into it, you can add CPP to replace the bodies with undefined when haddock is running, then add clear docs for each.
13:10:12 <c_wraith> deech, haddock does set a CPP flag when it runs, so that can be detected. I don't recall what it is, though.
13:10:22 <deech> c_wraith, that's clever!
13:11:07 <c_wraith> it's a bit ugly, to be honest. but it's the workaround we've got.
13:11:16 <dmwit> There's another workaround. It's also ugly.
13:11:46 <monochrom> The "filepath" package has System.FilePath.Posix and System.FilePath.Windows.  System.FilePath re-exports the "right" one.  You may like to take a look how they did that.
13:11:53 <dmwit> Which is to use cabal's conditional compilation to import the thing from one directory or another depending on which OS you're on, then document and re-export.
13:12:41 <c_wraith> that doesn't let you document both on a single system, if they have different interfaces.
13:12:55 <c_wraith> but it's certainly better when it's an option
13:13:01 <dmwit> As in `module Foo (foo) where import qualified Bar; -- | yay; foo :: Foo; foo = Bar.foo` and use hs-source-dirs to make Bar come from one directory or another.
13:13:13 <dmwit> c_wraith: See ^ for how to document the same on both systems.
13:13:48 <dmwit> Oh, well.
13:13:59 <dmwit> If they have different interfaces, you can't pull this trick, that's true.
13:14:11 <c_wraith> yeah, that's the case I was thinking of
13:14:13 <dmwit> But I think the sanest way is to encapsulate as much as possible so that you unify the interfaces.
13:14:19 <dmwit> Otherwise your CPP bleeds into literally everywhere.
13:15:03 <dmwit> (Using newtypes if necessary, also imported from Bar, to make the types be spelled exactly the same, even if the representation isn't the same.)
13:26:25 <phadej> how one invokes navigate to other page in reflex-dom
13:26:46 <phadej> something like `document.location.href = 'https://somewhere.else';`
13:44:18 <boj> phadej: you would use something like this https://github.com/reflex-frp/reflex-dom-contrib/blob/master/src/Reflex/Dom/Contrib/Router.hs
13:51:46 <[Leary]> Wow. I thought I was totally screwed when I needed to combine an HList of parsers into another that tries each one in order, but it turns out that with HSum it's a trivial one-liner. The interplay between those two types is just wonderful.
13:57:06 <hyperisco> So, when I end up with, like, 20 parameters, and lots of state… how do I untangle myself. I am going mad.
13:58:12 <phadej> boj: ok, so they use currentWindowUnchecked + getLocation window; thanks boj
13:58:19 <phadej> boj: I'm really navigating off-site
13:58:29 <phadej> you know, user clicks a button and then woosh ->
13:59:57 <shapr> MarcelineVQ: how do you discover new papers or theses to read? I'm trying to come up with a good unique id, I'm starting with arXiv:1804.02809 but I want to add doi: and others
14:06:58 <boj> phadej: perhaps - elAttr "a" ("href" =: "https://www.google.com") $ text "Google"
14:07:19 <phadej> than I cannot do stuff before navigation
14:07:31 <phadej> can I?
14:07:42 <boj> like, trigger some other cleanup event?
14:08:04 <phadej> yes
14:09:55 <boj> hmm, ctjohnston isn't sitting in here
14:10:06 <Synthetica> I'm using tasty-quickcheck and I have a collection of properties that I want to check for multiple types that all fit the same polymorhpic signature, what's the best way to go about that?
14:10:45 <boj> he says you can use jsaddle to do the location.href stuff you want. you just capture the click event on the "a", do cleanup, then call <some jsaddle thing> to send you along
14:12:00 <phadej> yes, I could do that; but I don't want to. My event might not be due a click
14:12:39 <boj> sure, you could use `leftmost` to capture different-but-relevant events
14:13:04 <phadej> but than those won't navigate away, will they, as navigation is a side-effect of cliking on <A>
14:14:11 <boj> rather than an <A> it could be a `button` maybe?
14:15:41 <phadej> and jsaddle doesn't have full docs on Hackage :/
14:19:09 <phadej> ghcjs programming is sadly grepping through existing code to find out clues how some things can be implemented
14:19:30 <boj> yeah, sadly it's a hard space to navigate around
14:22:37 <phadej> https://hackage.haskell.org/package/reflex-dom-core-0.5/docs/Reflex-Dom-Location.html !
14:31:36 <phadej> or then https://hackage.haskell.org/package/jsaddle-dom-0.9.3.1/src/src/JSDOM/Generated/Location.hs
14:31:40 <phadej> hmm
14:35:53 <boj> phadej: courtesy of ctjohnston (he sits in #reflex-frp) - https://gist.github.com/crappygraphix/8e06cfc7c16c14e0d6bedca0406dddba
14:36:41 <boj> i think he took some existing junk he was playing with, thus the weird header
14:47:30 <Th1b4ulT> hi
14:48:20 <f-a> hello
14:52:56 <wildtrees> is distributed-process (cloud haskell) still being developed? or anyone know when the hackage version of it will be fixed to work with the latest ghcs? 
15:00:00 <phadej> boj: thanks! eval looks like a hack :)
15:00:09 <phadej> i got it working with jsaddle-dom however
15:00:17 <phadej> which is a bit cleaner
15:00:31 <boj> cool, do you have an example to compare with? curious what you came up with
15:03:31 <phadej> boj: essentially, doc <- askDocument; location <- Document.getLocationUnsafe doc; Location.reload location -- I actually need to reload in this case, where 
15:03:42 <phadej> import qualified JSDOM.Generated.Document as Document
15:03:43 <phadej> import qualified JSDOM.Generated.Location as Location
15:04:09 <boj> neat! thanks :)
15:04:29 <phadej> location.reload stuff in performEvent
15:04:59 <phadej> (it's proprietrary codebase, so sorry for not pasting more complete example, there's some stuff around ...)
15:05:07 <boj> yep, no problem
15:12:25 <griddle> Is anyone having problems with `cabal install __` and linking errors on macOS?
15:12:43 <griddle> because its making it impossible to use haskell on this system
15:13:10 <dmwit> Snark mode on: with high confidence the answer is yes, because with high confidence you are having such problems.
15:13:24 <dmwit> Less snark: include some details, mate. Link us to a paste with the exact error.
15:13:31 <sclv> griddle: it really depends on the version of haskell, the version of os x, and if you have used homebrew
15:13:37 <sclv> (the last is the most important)!
15:13:43 <sclv> (also the provenance of the haskell install, etc)
15:14:00 <f-a> griddle: I stopped using install and switched to new-install, it was paradisiac(sp)
15:14:19 <dmwit> v1-install vs v2-install *probably* won't resolve whatever issue is happening here.
15:14:35 <f-a> oh yeah, linking errors
15:14:41 <sclv> almost psychically i'm guessing that it involves having some stuff from brew in the path and some stuff not from brew
15:14:41 <f-a> well griddle , paste something will ya
15:14:50 <griddle> working on it
15:14:58 <griddle> trying to see if new-install works
15:15:55 <dmwit> Like, definitely the new-* stuff is great. So yeah, switch to that. But it ain't gonna have an effect on this problem.
15:21:54 <griddle> hmm it seems to be that an object file in ~/.cabal was malformed  
15:22:22 <f-a> griddle: yeah sometimes I just go in the store and erase the specific package
15:22:38 <f-a> especially useful when computer freezes or the like
17:06:30 <sadlySequential> Hi, I have a concurrent program that works on files independently, but when I turn on `-threaded` I am not seeing any benefit. I'm unclear if it's a laziness issue, so I was wondering if I can do profiling of threads somehow.
17:06:54 <sadlySequential> I started looking into ThreadScope, but it sort of seems like it may not work with 8.6.*
17:07:11 <Axman6> Can you dshare some of the code?
17:07:22 <Welkin> dshare!
17:07:53 <hpc> can't tell if typo or web2.0
17:08:17 <hpc> sadlySequential: i bet you're IO-bound
17:08:50 <sadlySequential> It's a very large project, so it's hard to share to try to see some easy mistake.
17:09:05 <hpc> try observing your program with top/iotop/strace
17:09:20 <sadlySequential> Is that better than ThreadScope? Does anyone use that?
17:09:52 <sadlySequential> I have never done any "how many threads are running?" type stuff
17:10:06 <sadlySequential> It looks like you can compile projects to produce an "eventlog"
17:10:11 <Welkin> run with RTS
17:10:16 <Welkin> I think it has thread information too
17:10:28 <sadlySequential> It doesn't with -p or any of the -h variants
17:10:36 <sadlySequential> Not to the level I need at least!
17:10:58 <Welkin> okay
17:11:07 <sadlySequential> My worry is that somehow values are escaping from one forkIO to others through MVars, so I want to get an idea of where the work is happening.
17:11:07 <Welkin> try hpc's suggestions
17:11:22 <Welkin> you are sharing state between threads?
17:11:26 <Welkin> that's bad
17:11:51 <Welkin> what are you actually doing?
17:12:15 <sadlySequential> It's a compiler, so each file is compiled on a thread. It produces information that is needed by subsequent files.
17:12:36 <sadlySequential> So it's not that "state is shared" but that information is needed by other threads later on
17:12:57 <sadlySequential> The goal is that you can be "as concurrent as possible" so each thread wakes up when all of the MVars for its imports are done.
17:13:33 <sadlySequential> Something is going wrong though, it seems.
17:13:34 <hpc> ah, so you don't even know how concurrent your program is at any given time
17:13:58 <sadlySequential> Yeah, it depends on the project and the point along in compilation.
17:14:02 <hpc> there's a middle ground between intercepting syscalls and running with profiling
17:14:07 <hpc> and that's to just add more output
17:14:16 <hpc> Debug.Trace is your friend
17:14:37 <hpc> and maybe acme-now too :D
17:14:38 <sadlySequential> Is that thread safe?
17:14:45 <hpc> it's just output
17:14:51 <hpc> is stdout part of your api?
17:15:59 <sadlySequential> I print things out during compilation, and I have to have that on its own thread to make sure different putStr calls do not clobber each other. (I'm using \r to do some animations)
17:16:10 <jmorris> What library should I use for reading csv ?
17:16:10 <hpc> ah
17:16:29 <sadlySequential> It seems like https://wiki.haskell.org/ThreadScope should do what I need, but I'm not convinced it works these days
17:16:55 <sadlySequential> I'm getting stuck on an install failure like "After searching the rest of the dependency tree exhaustively, ..."
17:18:25 <sadlySequential> The alternative (printing things out manually) seems to require engineering a whole thing to try to get thread counts at various times though.
17:18:50 <Welkin> jmorris: cassava
17:18:50 <nshepperd> sadlySequential: you're running with -N, right?
17:19:01 <nshepperd> not just -threaded
17:20:41 <sadlySequential> Yeah, I put -N in my .cabal file but also try using `+RTS -N1` or `+RTS -N4` to see if anything will make a difference.
17:21:09 <sadlySequential> I double checked by printing out GHC.Conc.getNumCapabilities to see if it matched
17:21:27 <shapr> ugh, I'm gonna need plugins for this program
17:21:36 <sadlySequential> So I'm pretty sure it's enabled.
17:21:44 <sadlySequential> Has anyone used ThreadScope here successfully?
17:21:59 <shapr> what's the best way to compile in user-written plugins for a program? ooh, I should go look at xmonad
17:22:39 <shapr> oh, they just depend on the cabbage... that's not gonna work for me.
17:22:46 <Welkin> yes
17:22:48 <shapr> (cabbage = cabal+package)
17:22:50 <Welkin> threadscope works fine
17:22:55 <Welkin> have you read the fish book?
17:23:06 <Welkin> ?where parconc
17:23:06 <lambdabot> https://www.safaribooksonline.com/library/view/parallel-and-concurrent/9781449335939/
17:23:07 <shapr> isn't that book free?
17:23:09 <Welkin> yes
17:23:13 <shapr> happiness!
17:23:13 <Welkin> I bought it though
17:23:18 <Welkin> it's nice to have a paper copy
17:23:23 <shapr> I did at one point, but moved so many times ...
17:23:32 <Welkin> also it's the best haskell book available
17:23:39 <shapr> eh, lots of good ones
17:23:42 <Welkin> my favorite at least
17:23:43 <shapr> have you read Richard Bird's book?
17:23:45 <shapr> fair enough
17:23:54 <Welkin> I have graham hutton's
17:23:57 <shapr> oh I like that one
17:24:06 <Welkin> I read richard bird's sudoku exercise, which is great
17:24:06 <shapr> I bought the 2nd edition, but haven't read it yet
17:24:16 <shapr> like the 1st edition
17:24:46 <sadlySequential> Okay, perhaps I'm just running into some normal `cabal install` woes then. I'll keep trying to get it working. Thanks for the book rec.
17:24:47 <shapr> how the heck do I load user 
17:24:54 <shapr> er, user-written source code into a Haskell app?
17:24:58 <Welkin> cabal install?
17:25:02 <Welkin> you shouldn't be running that
17:25:14 <shapr> cabal v2-install
17:25:19 <Welkin> run `cabal new-build` or `cabal new-run`
17:25:32 <shapr> I look forward to new-install being the only install
17:25:35 <nshepperd> there's a cabbage called 'plugin's but i don't know much about it
17:25:52 <nshepperd> plugins
17:25:55 <shapr> nshepperd: thanks, I'll look at it.
17:26:02 <nshepperd> which wraps the ghc api, i think
17:26:05 <shapr> I wonder how Facebook is doing their runtime reloading?
17:26:18 <shapr> oh good, stepcut wrote it
17:26:58 <shapr> I wonder if I could use dhall instead? I just want some string munging
17:27:29 <shapr> ooh this is a good chance to dig into dhall
17:28:09 <Welkin> perl?
17:28:19 <shapr> Welkin: unlikely
17:28:24 <Welkin> perl6
17:28:50 <shapr> I'm writing this research paper annotation tool, and I want some way to turn a unique id into a URL for downloading a pdf
17:29:12 <Welkin> a link shortener service
17:29:15 <shapr> arxiv.org is easy: "arxiv:1804.02809" becomes https://arxiv.org/pdf/1804.02809
17:29:17 <Welkin> I did that before
17:29:31 <Welkin> base16 encoding is good enough
17:29:32 <shapr> Welkin: needs to be local and globally unique and consistent
17:29:45 <shapr> I plan on adding doi: and some others
17:29:52 <Welkin> doi?
17:29:59 <shapr> https://en.wikipedia.org/wiki/Digital_object_identifier
17:30:00 <Welkin> that's easy
17:30:03 <Welkin> use snowflake ids
17:30:11 <Welkin> instead of uuid
17:30:14 <shapr> I require unique globally agreed up IDs for research papers, theses, etc
17:30:45 <Welkin> you have several workers who give out ids that contain the time they are created along with the worker id
17:30:54 <Welkin> along with a sequential id
17:31:01 <Welkin> it fits in 64 bits
17:31:18 <Welkin> you don't need to sync time either
17:31:21 <Welkin> it doesn't matter
17:31:23 <shapr> scholar.google.com already supports DOI, so I need to support that, and arXiv has their own unique id
17:32:08 <Welkin> you can go to 128 bits if you want, since 64 bits will limit you to about 70 years I think
17:32:20 <Welkin> what software lasts 70 years though
17:32:21 <Welkin> haha
17:32:38 <Welkin> wikipedia has been around for something like 20 years
17:32:57 <shapr> Welkin: I'd like to use existing IDs as in https://en.wikipedia.org/wiki/Wikipedia:Authority_control
17:33:18 <Welkin> broken link
17:33:37 <shapr> hm, should work
17:33:49 <shapr> anyway, time for pizza and more thinking on this problem
17:55:24 <sadlySequential> Can someone help me get ThreadScope installed on macOS? I'll explain my current situation in a second.
17:55:56 <sadlySequential> This page says pre-built binaries are available: https://hackage.haskell.org/package/threadscope
17:56:10 <sadlySequential> So I follow that link to https://github.com/haskell/ThreadScope/releases
17:56:47 <sadlySequential> But upon unpacking the threadscope.osx.gz I am left with a threadscope.osx, and I'm not sure what kind of file that even is.
17:58:14 <sadlySequential> From there I try the build from source instructions. I was able to `brew install gtk+ gtk-mac-integration` but the `cabal new-build --constraint="gtk +have-quartz-gtk"` command fails
17:58:37 <sadlySequential> "After searching the rest of the dependency tree exhaustively,  ..."
18:00:01 <sadlySequential> Does anyone have any ideas?
18:02:56 <Axman6> sadlySequential: try running that binary from the command line
18:04:17 <sadlySequential> I did a `chmod +x` on it, and I guess that is what is needed... Still confirming!
18:17:42 <sadlySequential> I think it's working now!
18:22:47 <jjb1> rehi all!
18:27:47 <jjb1> i have been stuck for a bit trying to figure out if i can turn IO [IO [a]] into IO [a]. so far completely failed and i feel like it should either be easy or obviously impossible.
18:28:18 <jjb1> (so far, for me: neither ;))
18:28:39 <maerwald> :t join
18:28:40 <lambdabot> Monad m => m (m a) -> m a
18:29:23 <jackdk> jjb1: good news: it's possible. are you familiar with the join (above) , sequenceA and fmap?
18:29:39 <maerwald> :t mmh
18:29:41 <lambdabot> error: Variable not in scope: mmh
18:29:45 <maerwald> oops
18:29:57 <jjb1> yay! i have tried join and fmap in many combinations, and sequence, but not sequenceA!
18:30:22 <jackdk> sequenceA is just sequence generalised to Applicative instead of Monad, so you already have that tool in your mental toolbox. that's good
18:31:38 <Axman6> :t sequence
18:31:40 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
18:32:04 <jackdk> :t fmap sequence -- hint jjb1
18:32:05 <lambdabot> (Functor f, Monad m, Traversable t) => f (t (m a)) -> f (m (t a))
18:32:06 <Axman6> :t sequence `asAppliedTo` (undefined :: [IO [a]])
18:32:07 <lambdabot> [IO [a]] -> IO [[a]]
18:32:15 <jjb1> the mental toolbox is still organizing itself ;)
18:32:30 <Axman6> :t fmap sequence `asAppliedTo` (undefined :: IO [IO [a]])
18:32:31 <lambdabot> IO [IO [a]] -> IO (IO [[a]])
18:32:36 <jjb1> ah, that looks tractable!
18:32:41 <Axman6> :t join . fmap sequence `asAppliedTo` (undefined :: IO [IO [a]])
18:32:43 <lambdabot> IO [IO [a]] -> IO [[a]]
18:32:50 <Axman6> only one more step!
18:32:58 <jackdk> aw you gave the game away
18:33:17 <jackdk> oh, not completely :-)
18:33:19 <jjb1> looks like fmap . join at that point
18:33:30 <Axman6> nearly
18:33:34 <jjb1> oh wait, or maybe just <>
18:33:44 <Axman6> almost
18:33:58 <Axman6> fmap . join was closer, but too much
18:33:59 <jjb1> (switches to commandline in other window)
18:35:03 <maerwald> :t fmap join $ join $ fmap sequence $  (pure [pure []] :: IO [IO [a]])
18:35:04 <lambdabot> IO [a]
18:36:04 <jjb1> this is somewhat disturbingly like a puzzle game, and still fun ;)
18:36:16 <jjb1> thank you all for your assistance!
18:36:47 <jackdk> yeah, it's good stuff hey?
18:37:23 <jjb1> i keep finding out i still have a lot to find out
18:40:30 <jackdk> yeah. there are some deep holes you can run down, but you don't need to explore all of them to do Real Useful Work(TM)
18:41:44 <jjb1> most of the time it seems like i can make my way around okay, but also i frequently find things that would ordinarily be simple/automatic that i just don't know how to do
18:42:36 <jackdk> building new mental muscles
18:46:22 <dmwit> jjb1: Can't believe nobody else said this, but... I think you've screwed up before you made it to `IO [IO [a]]`.
18:46:35 <dmwit> jjb1: Probably you can avoid nesting `IO` in the first place.
18:47:48 <dmwit> jjb1: Can you share a little bit about how you got to wanting that operation?
18:51:05 <maerwald> how so? accumulating a list of IO actions to run isn't very uncommon
18:54:38 <jjb1> dmwit: good to hear, and yes!:
18:55:09 <jjb1> i have a directory of directories, about 3 levels of them, with files at the roots
18:55:23 <jjb1> i want to find the first file that exists, in a given ordering
18:55:44 <jjb1> so each time i list a directory, i have IO [x]
18:56:02 <jjb1> and then for each directory in there i have another one, and one inside that, and inside that i have files (putatively)
18:57:27 <jjb1> most of the time, the only directories which exist are the ones which actually have the file i want, but i can't count on it
18:58:18 <dmwit> (Please give us an "end of explanation" marker somehow at an appropriate time.)
18:58:32 <jjb1> heh, that's basically it
18:59:22 <dmwit> Okay. So you are going to use `listDirectory :: FilePath -> IO [FilePath]` or so.
18:59:32 <jjb1> yes
18:59:46 <dmwit> And you have some other piece that consumes a `[FilePath]` and produces... let's say, an `IO [NeatoResult]`?
18:59:52 <jjb1> and the ordering of exploration is important too
19:00:17 <dmwit> Sure. I assume that's the responsibility of the `[FilePath]` consumer.
19:00:57 <dmwit> And I guess you're doing something like `fmap consumer (listDirectory "foo")` or similar to get your nested `IO`s?
19:01:16 <jjb1> at the end this will still be IO [FilePath] where each FilePath is an actual file 
19:01:30 * dmwit nods agreeably
19:01:45 * dmwit jots down `NeatoResult = FilePath`
19:02:07 <dmwit> How on-target is the rest of my speculation?
19:02:08 <jjb1> i have `existingDirectories :: FilePath -> IO [FilePath]` whcih does that enumeration in order
19:03:27 <jjb1> right now (as of the above help i received) it's doing multiple levels of fmap existingDirectories <$> previousLevelExistingDirectories
19:03:47 <dmwit> Right.
19:03:57 <dmwit> So I recommend looking at `(>>=)` instead of `(<$>)`.
19:03:59 <dmwit> :t (>>=)
19:04:00 <jjb1> with `fmap join $ (join . fmap sequence)` to collapse the IOs
19:04:02 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:04:34 <dmwit> If it helps: `join (fmap existingDirectories (listDirectories "foo"))` would become `(>>=) (listDirectories "foo") existingDirectories`.
19:04:47 <dmwit> It collapses one layer of "nesting" immediately.
19:05:02 <jjb1> gotcha, i will explore that -- thank you!
19:05:13 <dmwit> (Though most would write it as `listDirectories "foo" >>= existingDirectories` of course!)
20:30:49 <a1243> hello, I'm going to stackage to look up package documentation, but I seem to be getting errors.
20:41:40 <a1243> It seems to be fixed now.
23:54:20 <myme> Using `cabal new-repl [component]` I don't seem to figure out how to type out the library or executable component if they're named the same. Having an "-exe" suffix on the exec has Cabal build the executable with "-exe", which I'd like to avoid.
23:55:12 <clever> myme: previously, it was lib:foo and exe:foo
23:55:22 <clever> before the new- commands existed
23:55:46 <dminuoso> myme: perhaps with a `colon`?
23:56:38 <myme> clever: Still works!
23:56:46 <myme> I /appended/ :exe
23:57:02 <myme> But didn't think of prepending it :p
23:57:11 <myme> Thanks.
23:57:20 <clever> i remember `cabal repl` giving an error, that said to prepend
23:57:52 <myme> "new" commands just give: cabal: Unknown target 'i3ws:exe'.
23:58:12 <myme> And defaults to the lib if there's no annotation.
23:58:12 <clever> what about with i3ws?
23:58:16 <clever> ahh
23:58:30 <clever> repl refuses to run if its not clear, and gives hints
