00:00:47 <sicklorkin> gonna try using shake
00:04:31 <dminuoso> sclv: Turns out if you specify a cyclic dependency that will cause this bizarre diagnostic.
00:04:33 <dminuoso> Probably should file that as a diagnistics bug.
00:04:55 <sclv> yeah! good find
00:06:26 <sicklorkin> maqbool: do you want the older tarball?
00:06:32 <sicklorkin> I found it.
00:06:38 <sicklorkin> `hie-0.7.0.0-x86_64-linux.tar.gz`
00:06:52 <sicklorkin> all versions included
00:07:09 <sicklorkin> ~250MB
00:07:30 <Axman6> don't worry about all the GPU compute it uses, that's just how HIE worksm definitely not crypto mining
00:10:38 <maqbool> sicklorkin, that will works too :)
00:12:25 <sicklorkin> maqbool: giv em a sec I gotta set up a webserver and punch a few holes in my wall
00:59:44 * hackage registry 0.1.6.2 - data structure for assembling components  https://hackage.haskell.org/package/registry-0.1.6.2 (etorreborre)
01:13:17 <dminuoso> What does the diagnostic "cannot apply expression of type `t1` to a visible type argument ServerError" mean exactly? https://gist.github.com/dminuoso/5a0218244202a39df5fbeda529282200
01:20:57 <dminuoso> Is that just https://gitlab.haskell.org/ghc/ghc/issues/13060?
01:21:15 <dminuoso> (It'd be confusing since the type of `try` is not inferred, but annotated)
01:34:28 <dminuoso> Oh ok. Coerce just wasnt in scope, so this was just a case of a bad diagnostic.
01:35:46 <solonarv> oh yeah, I've run into that before
01:39:32 <dminuoso> solonarv: Oh hah. Even `try` wasnt in scope!
01:39:44 <dminuoso> That is a true annoyance.
01:40:02 <dminuoso> % :t notDefined
01:40:02 <yahb> dminuoso: ; <interactive>:1:1: error: Variable not in scope: notDefined
01:40:04 <dminuoso> % :t notDefined @Int
01:40:04 <yahb> dminuoso: ; <interactive>:1:1: error:; * Cannot apply expression of type `t1'; to a visible type argument `Int'; * In the expression: notDefined @Int
01:41:41 <dminuoso> This is interesting. Why does Haskell infer a type for an identifier that is not in scope?
01:42:23 <solonarv> hmm, I'm not sure
01:43:03 <solonarv> perhaps ask in GHC? that certainly doesn't seem like the desired error message
01:43:08 <dminuoso> In part Im wondering that this is to enable mutually recursive bindings.
01:44:04 <solonarv> I don't think so - if you have mutually recursive bindings, they are in scope in each other's (and their own) definitions
01:45:29 <solonarv> ah, https://gitlab.haskell.org/ghc/ghc/issues/13834
01:46:40 <hexagoxel> hackage-bot still seems to miss package releases that were candidates previously, so:
01:46:41 <hexagoxel> hackage: brittany-0.12.0.0 - Haskell source code formatter https://hackage.haskell.org/package/brittany-0.12.0.0 (lspitzner)
01:46:45 <dminuoso> solonarv: Ahh cheers.
01:47:14 <Phyx-> hrm.. on the off chance... does anyone know of a library/script to reliably modify a cabal config file? I don't want to reinvent the wheel..
01:48:31 <solonarv> I suppose you could rip some code from cabal-install
01:48:40 <merijn> Phyx-: As in .cabal or as in cabal.project?
01:48:41 <solonarv> unfortunately it does not seem to expose anything as a library
01:48:54 <merijn> solonarv: Yes it does, it's called "Cabal" >.>
01:49:18 <solonarv> ah, but that's only the package description and building, no?
01:49:37 <merijn> Phyx-: What exactly is the end goal? Because committing to tying to Cabal is...a big commitment
01:50:06 <merijn> solonarv: Well sure, but the cabal file is just the package description?
01:50:12 <Phyx-> merijn: neither, as in the cabal global config file
01:50:18 <merijn> ah...
01:50:21 <solonarv> Phyx-: you're wanting to modify the file that's usually located at ~/.cabal/config, yes
01:50:25 <solonarv> ah, ninja'd
01:50:38 <merijn> Phyx-: Still, with what goal?
01:51:09 <Phyx-> yes, cabal-install has a "user-config" command, but that's broken in a number of ways. I can fix it for head but need something for existing versions.
01:51:30 <Phyx-> merijn: to modify it reliably during automated installs
01:51:56 <merijn> Phyx-: Of executables?
01:52:11 <merijn> Or did you mean of cabal-install itself?
01:52:23 <Phyx-> of cabal-install itself
01:52:23 <dminuoso> Phyx-: Mind my asking, to what end?
01:52:32 <dminuoso> Phyx-: What are you trying to modify in ~/.cabal/config ?
01:52:36 <merijn> Phyx-: Wouldn't it be easier to just keep a "correct" copy and install that?
01:53:02 <Phyx-> merijn: that would only work if all end users install to the same path, which is unlikely
01:53:04 <merijn> Like, why bother overriding instead of just writing the config that you want in the first place?
01:54:35 <Phyx-> dminuoso: I am programmatically configuring cabal-install to point to the right places to resolve include, library paths etc when installing cabal via chocolatey. I am currently using cabal user-config for this but as I mentioned it's not good enough.
01:55:47 <dminuoso> Phyx-: Sort of like nix?
01:56:22 <Phyx-> I couldn't tell you what nix does.. don't use it
01:56:41 <solonarv> sort of like any package manager, tbh - that's all chocolatey is
01:56:56 <solonarv> its main unusual feature is that it's made for windows and actually works reasonably well ;)
01:57:15 <dminuoso> Okay Im starting to grow my hate about cabal.
01:57:32 <dminuoso> It has some of the worst diagnostics. :\
01:57:41 <Rembane> What does it do? What should it do?
01:58:21 <sicklorkin> ghc --make works well
01:58:53 <dminuoso> I mean my hate is very specific. Just dont like the diagnostics when you make a mistake, this is the 4th time Im getting a cryptic diagnostic that doesnt tell me whats wrong. :(
01:58:59 <dminuoso> Today alone.
01:59:32 <solonarv> ghc --make works super well until you need to manage dependencies, then you need to somehow tell ghc where to find them and figure out the right versions and...
01:59:46 <solonarv> in fact cabal just calls ghc --make when building an executable!
01:59:49 <sicklorkin> solonarv: that what you use cabal for
01:59:51 <Phyx-> < solonarv> I suppose you could rip some code from cabal-install <-- oh sorry didn't see this. I could, but usually taking code from Cabal is not easy as it's all sort of tied together.
02:00:04 <sicklorkin> package dependancy graph
02:00:40 <solonarv> yes exactly
02:00:50 <sicklorkin> lol and i run cabal with ghc --make Setup.hs
02:01:15 <solonarv> ah but how do you make sure your dependencies are actually available?
02:01:34 <sicklorkin> fetch or whatever that comand is to puoll packages
02:03:58 <sicklorkin> solonarv: and if you want really fast builds you can geneate a bunch of make files on the fly and build in parallel - but just make sure you've figured out your graph
02:04:28 <solonarv> I'm still not sure what this buys you over cabal-install, tbh
02:04:34 <merijn> ghc --make has been redundant for well over a decade now, since it's the default >.>
02:04:42 <solonarv> it already builds things in parallel!
02:05:08 <merijn> sicklorkin: /sb goto -20
02:05:17 <merijn> irssi fail >.>
02:06:02 <merijn> dminuoso: Which cryptic diagnostic?
02:06:19 <sicklorkin> merijn: what does that do? 
02:06:40 <sicklorkin> scroll back?
02:06:43 <merijn> sicklorkin: That wasn't for you, I hit tab completion before typing something :)
02:07:41 <Rembane> dminuoso: Are you frustrated enough to create an issue on cabal's bug tracker? 
02:08:41 <merijn> Rembane: The real question is: are you frustrated enough to patch it? ;)
02:10:02 <Rembane> merijn: That's the followup question. :)
02:10:38 <Phyx-> well, no ticket no fix :)
02:11:11 <Rembane> > fix error
02:11:13 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
02:11:17 <Rembane> :D :D :D 
02:35:08 <higherorder> Hi! Quick question: what is the use of `someSymbolVal` (in GHC.TypeLits)? What would it be used for?
02:45:46 <dminuoso> higherorder: So consider SomeSymbol to be essentially `exists n. KnownSymbol n => n`
02:46:37 <higherorder> dminuoso: and what's this useful for?
02:46:49 <solonarv> dminuoso: not =>
02:46:59 <dminuoso> solonarv: Well yeah. *> is the more conventional notation there.
02:47:04 <solonarv> indeed
02:47:20 <dminuoso> solonarv: I didn't actually notice that mistake when proof reading. :)
02:47:22 <dminuoso> Cheers
02:48:12 <dminuoso> higherorder: SomeNat is a type level natural that is not known at compile time.
02:48:23 <dminuoso> Its known at runtime, so its expressed as an existential type.
02:48:49 <Batholith> a type with an existential crisis
02:49:02 <higherorder> dminuoso: but what can you do with a `SomeNat` then?
02:49:08 <dminuoso> higherorder: A SomeNat contains evidence for KnownNat.
02:49:31 <dminuoso> higherorder: And equivalently SomeSymbol contains evidence for KnownSymbol
02:49:58 <higherorder> dminuoso: but... at the risk of repeating myself, what's that evidence useful for? :D
02:50:08 <dminuoso> higherorder: For functions that demand that evidence.
02:50:11 <int-e> higherorder: you can pattern match it to extract the dictionary
02:50:38 <dminuoso> higherorder: For example, consider :~:
02:50:45 <int-e> higherorder: case ss of SomeSymbol (_ :: Proxy a) -> <some code using a and KnownSymbol a>
02:50:53 <dminuoso> sameSymbol :: (KnownSymbol a, KnownSymbol b) => Proxy a -> Proxy b -> Maybe (a :~: b) 
02:51:06 <dminuoso> This demands proof of `KnownSymbol a` and proof of `KnownSymbol b`
02:51:11 <dminuoso> It needs to be provided *somehow*
02:51:33 <dminuoso> But the function doesnt care whether the proof is supplied at runtime (via pattern matching) or at compile time (via using a type level literal)
02:51:59 <higherorder> int-e: the code using `a` won't know what symbol `a` is though, right? Since that's only known at runtime. It will just be a variable with kind `Symbol`?
02:52:14 <dminuoso> higherorder: it will because of the pattern matching.
02:52:23 <dminuoso> higherorder: pattern matching extracts the proof and makes it available
02:52:35 <dminuoso> SomeNat says "I contain proof for KnownNat inside"
02:53:05 <dminuoso> higherorder: So consider my example of `sameSymbol` (A somewhat confusing name, since `same` looks similar to `some`)
02:53:34 <int-e> higherorder: well the code can find out what the symbol is using symbolSing from the KnownSymbol class
02:54:26 <dminuoso> higherorder: Its important to note that most of the type level functions dont actually demand a type level literal.
02:55:08 <dminuoso> *well value level functions involving type level stuff
02:55:17 <dminuoso> % :t sameNat
02:55:17 <yahb> dminuoso: ; <interactive>:1:1: error: Variable not in scope: sameNat
02:55:22 <dminuoso> % import GHC.TypeLits
02:55:22 <yahb> dminuoso: 
02:55:23 <dminuoso> % :t sameNat
02:55:23 <yahb> dminuoso: (KnownNat a, KnownNat b) => Proxy a -> Proxy b -> Maybe (a :~: b)
02:56:07 <dminuoso> We could instantiate the type variable `a` at (Proxy "Foo") and `b` at (Proxy "Bar") of course. But we are not required to do so, perhaps you want to fiddle user input in here.
02:58:59 <neobrain> Is there anything about "concat $ map (const []) myList" that would slow down GHC's optimizer? My code compiles at (what feels like) quadratic complexity in the list size, and it seems that line is the culprit.
02:59:33 <neobrain> (this doesn't happen if I use stack's --fast flag, hence I'm assuming it's something in the optimizer)
02:59:52 <higherorder> int-e: assuming I could write a function that looked like this: https://gist.github.com/hmaurer/98472addb94d5a4b7b05cc92baa3af13 . Surely this couldn't be checked at compile time, right? Since, if I got what you said, `s` in `g1` is not known. 
03:01:05 <dminuoso> higherorder: You couldn't write that in particular.
03:01:22 <dminuoso> higherorder: You'd get a "escaped skolem" bla bla bla error.
03:01:46 <higherorder> dminuoso: yeah that's what I am getting. I just don't understand how GHC treats that `s` type variable in `g1`
03:02:33 <jgt> neobrain: I can't answer your question, but I am interested in the answer. I am looking for a way to see where GHC spends its compile time, and I haven't found anything yet.
03:02:35 <dminuoso> higherorder: So I tend to think of type variables as being "parameters" in the sense of a lambda. In that sense, what you are trying to do is taking a function `\x -> ... ` and trying to refer to `x` outside that function.
03:02:53 <dminuoso> (In some abstract sense its equivalent to that)
03:03:40 <dminuoso> higherorder: Essentially you cant let knowledge of that existential type escape that scope.
03:05:07 <int-e> higherorder: The problem isn't invoking g2... is that the type _ would involve s.
03:05:29 <int-e> hmm. is -> it's.
03:07:47 <neobrain> Hmm just tried a different approach: Instead of mapping my list to a nested list that I flatten immediately after, I just do a left-fold that accumulates all generated elements into a single list. I don't run into the quadratic complexity with that, so I'm assuming that's easier on the optimizer
03:09:03 <neobrain> (could also be something related to strictness analysis, considering that foldl' an additional level of strictness over concat)
03:09:28 <Taneb> It surprises me that Data.ByteString.hGetLine isn't deprecated lice hPutStrLn is, they both rely on ASCII encodings
03:09:52 <dminuoso> higherorder: Consider just the constraint KnownSymbol
03:10:46 <dminuoso> higherorder: `KnownSymbol n` is proof of some symbol. It doesn't say that it must be specified as a type. It being a constraint, it means you can write types `f :: KnownSymbol n => ...` and anyone using `f` must somehow supply proof for that KnownSymbol.,
03:31:21 <roflik> @pl \f g -> \x y -> f x $ g y
03:31:21 <lambdabot> flip . ((.) .)
03:31:43 <roflik> @pl \x y -> f x $ g y
03:31:43 <lambdabot> (. g) . f
03:33:45 <roflik> @pl \f g -> \x y z -> f x $ g y z
03:33:45 <lambdabot> flip . (((.) . (.)) .)
03:34:49 <roflik> @pl \x y z -> f x $ g y z
03:34:49 <lambdabot> (. g) . (.) . f
03:36:03 <roflik> @pl \f g -> \x y z -> f (x, g, y, z)
03:36:04 <lambdabot> (. flip (,,,)) . (.) . (.) . (.)
03:36:41 <roflik> @pl \f g -> \x y z -> f (x, g (y, z))
03:36:41 <lambdabot> (. (flip ((.) . (.) . (,)) . (. (,)) . (.))) . (.) . (.) . (.)
03:37:16 <roflik> @pl \f g -> \(x, y, z) -> f (x, g (y, z))
03:37:16 <lambdabot> (line 1, column 17):
03:37:17 <lambdabot> unexpected "z"
03:37:17 <lambdabot> ambiguous use of a non associative operator
03:37:33 * ski . o O ( pointless code is pointless )
03:38:20 <roflik> not when done well (the output from @pl is not "well" :)
03:38:58 <ski> you're refuting a tautology ? :)
03:39:00 <roflik> i'm trying to get a feel for how currying in haskell interacts with (.)
03:41:09 <roflik> ok then: if you're trying to suggest that pointfree is pointless, then i disagree.
03:42:00 <ski> nah, i'm just jesting :)
03:45:54 <ski> @let infixr 9 .:,.::,.:::; (.:) :: (c0 -> c1) -> (a -> b -> c0) -> (a -> b -> c1); (.:) = (.) . (.); (.::) :: (d0 -> d1) -> (a -> b -> c -> d0) -> (a -> b -> c -> d1); (.::) = (.) . (.) . (.); (.:::) :: (e0 -> e1) -> (a -> b -> c -> d -> e0) -> (a -> b -> c -> d -> e1); (.:::) = (.) . (.) . (.) . (.)
03:45:55 <lambdabot>  Defined.
03:54:16 <Jinna> __monty__: okay thx
03:59:09 <dminuoso> Is there any way to write a type annotation for `handler` int his? https://gist.github.com/dminuoso/4abed9f39e71ae5c4a395afe60305159
04:01:24 <ski> could you add a type ascription on `FreyjaM h' ?
04:02:35 <__monty__> Wouldn't a type hole help? `handler :: _`
04:03:29 <dminuoso> ski: It's a newtype
04:03:47 <dminuoso> Oh wait I see
04:04:03 <dminuoso> newtype FreyjaM a = FreyjaM { runFreyjaM :: LoggingT (ReaderT Env IO) a }
04:04:27 <dminuoso> __monty__: No, its rather a "How do I do ScopedTypeVariables in this sort of situation"
04:04:37 <dibblego> forall a. 
04:05:02 <ski> they don't want that
04:05:25 <dminuoso> I kind of want to state `handler :: IO`
04:05:35 <dminuoso> But that doesn't make much sense, obviously.
04:06:11 <dminuoso> `IO _` would work if I enable PartialTypeSignatures.
04:07:08 * ski wonders about how the ascription suggestion works out
04:13:34 <saulzar_> Seems I have managed to break GHC - has anyone run into this one before GHC 8.4.3? Loading temp shared object failed: /run/user/1000/ghc15456_0/libghc_1.so: failed to map segment from shared object
04:17:16 <saulzar_> This only occurs compiling one particular thing... not a broken install (which would seem more likely from such an error...)
04:19:38 <saulzar_> Wierd, seems it was to do the TMPDIR not being set to /tmp. I wonder why it only occurs on this one thing.
04:45:05 <geekosaur> Saulzar_, there's at least one linux dustribution that does evil systemd isolation things via $TMPDIR, so every rocess has its own privte TMPDIR. which breaks that usage in particular
04:47:00 <__monty__> Aren't the /run directories always per-process?
04:47:20 <merijn> __monty__: Yes
04:47:26 <merijn> Well, per session
04:49:13 <geekosaur> session vs. process is a bit more complicated. and slightly more likely to work since ghc doesnt use job control
04:49:22 <geekosaur> nor does make (in this sense)
05:04:10 <Ferdirand> what happened to hpaste ?
05:04:39 <merijn> Ferdirand: Chris didn't have time/energy to maintain it and keep fighting spam, so he shut it down
05:04:40 <hpc> it became lpaste, and then it became too much work to maintain iirc
05:05:04 <Ferdirand> :(
05:05:12 <merijn> People have offered to take it over, but apparently none of them came up with an offer that was convincing enough for him
05:05:29 <merijn> (easy to offer that in a reddit comment, more work to actually do in practice)
05:05:36 <merijn> Yeah, it's sad lpaste was great
05:06:21 <geekosaur> one of the things that made it great was why ti was a problem, though: it was immutable
05:06:36 <geekosaur> which complicates both spam and hosting (ever-growing database)
05:07:35 <Ferdirand> so, what's the proper etiquette for sharing code here now ?
05:07:46 <Lycurgus> so far I've found asking a simple question "what is the reason you are creating an account" has been sufficient to stop spammers
05:09:18 <merijn> Ferdirand: Pick a random non-sucky pastebin and use it
05:09:25 <hpc> the topic says gists
05:09:38 <Ferdirand> oh, right
05:09:43 <geekosaur> gist, bpaste, there's a lisp pastebin somewhere
05:09:55 <Ferdirand> sorry, the topic is all the way up to the top of my screen :)
05:09:55 * ski . o O ( <https://paste.debian.net/> )
05:10:00 <geekosaur> the problem with gist is github requires an account now, no anon gists any more
05:10:10 <hpc> :(
05:10:17 <ski> unfortunately, <paste.lisp.org> is closed
05:10:24 <geekosaur> pastebin.com has too many ads and syntax highlighting that makes haskell code unreadable
05:10:31 <geekosaur> oh :(
05:11:34 <ski> (old pastes and annotations are still available, but you can't make new ones)
05:12:36 <Ferdirand> i wanted to ask what's the canonical way to go through a datastructure that provide traversals and build a sequence of IO () from them
05:13:02 <Ferdirand> I started writing a ConstT a m b = ConstT (m a), but then realized that IO () is a monoid so Const would work already
05:13:46 <merijn> Ferdirand: Why const? Why not just, like, foldMap or something directly?
05:14:29 <solonarv> heh, looks like Ferdirand realized this already ;>
05:14:34 <Ferdirand> because my type is not foldable
05:14:38 <merijn> I guess it depends what you wanna do with the sequence, I suppose
05:14:54 <solonarv> if it's traversable it's also foldable
05:14:55 <Ferdirand> nor traversable
05:15:14 <solonarv> or do you mean you have a Traversal over it (as in lens) ?
05:15:20 <Ferdirand> yes, that
05:15:29 <solonarv> every Traversal is also a Fold
05:15:30 <Ferdirand> a composition of traversals actually
05:15:52 <solonarv> (and a composition of Traversal's just gives you another Traversal)
05:16:05 <solonarv> the function you're looking for is foldMapOf
05:16:25 <solonarv> foldMapOf :: Monoid m => Fold s a -> (a -> m) -> s -> m
05:16:35 <Ferdirand> ah, great
05:16:59 <Ferdirand> i haven't explored all of lens yet, that's the first time i'll have a non-trivial usage of folds
05:17:21 <solonarv> folds are basically "traversals that can't set"
05:18:01 <solonarv> or rather: traversals are folds that can also set/modify
05:21:14 <Ferdirand> i grok how constraining from a functor to an applicative generalizes a lens to a traversal
05:21:26 <Ferdirand> but that extra contravariant constraint on folds...
05:22:25 <solonarv> in combination with the existing Functor constraint, it basically says "this type parameter can't actually be used"
05:22:32 <Ferdirand> is there anything beyond Const that has these constraints ?
05:22:52 <solonarv> a handful of other things that are basically "Const in a trenchcoat"
05:23:04 <solonarv> for example: data Proxy a = Proxy
05:23:21 <solonarv> or newtype Forget r a b = Forget { runForget :: a -> r }
05:23:32 <Ferdirand> please hold on while i collect the pieces of my brain on the floor
05:23:42 <solonarv> (which is the same as a -> Const r b, so just Const again)
05:24:52 <Ferdirand> is there any point in passing a proxy to a traversal ?
05:24:57 <dminuoso> Ferdirand: It might be helpful to just look at what things have a Contravariant instance: https://hackage.haskell.org/package/lens-4.17.1/docs/Control-Lens-Combinators.html#t:Contravariant
05:25:12 <solonarv> I can't think of why you'd do that, but you can!
05:25:52 <solonarv> btw, the characteristic function to lookat is phantom :: (Functor f, Contravariant f) => f a -> f b
05:26:15 <solonarv> which says: the type parameter isn't actually used, so we can change it around freely
05:26:23 <Ferdirand> implementing this in terms of fmap and contramap sounds like a good exercise
05:27:35 <solonarv> it's shockingly short, and yes
05:29:31 <Ferdirand> oh, duh
05:29:32 <Ferdirand> amazing
05:29:45 <solonarv> :D
05:30:03 <Ferdirand> contramap (const ()) . fmap (const ()) ?
05:30:07 <solonarv> yup!
05:30:47 <solonarv> or more succintly: phantom x = () >$ (x $> ())
05:31:25 <solonarv> where x $> k = fmap (const k) x, k >$ x = contramap (const k) x
05:33:26 <roflik> uh, what does it mean to flip an unary function?
05:33:40 <roflik> \x y -> y x == flip id
05:33:57 <roflik> how does that work?  which part of the manual should i read?
05:34:03 <merijn> :t flip
05:34:05 <lambdabot> (a -> b -> c) -> b -> a -> c
05:34:06 <merijn> :t id
05:34:08 <lambdabot> a -> a
05:34:14 <ski> (function types are not a instances of `Eq')
05:34:22 <Ariakenom> roflik: you can work through the type of flip id by hand
05:34:23 <merijn> roflik: For simplicity let's say "id :: x -> x"
05:34:48 <merijn> roflik: You know how "a -> b -> c" = "a -> (b -> c)"?
05:35:02 <roflik> Ariakenom: the type is not the issue, the "construction" is perplexing me
05:35:18 <roflik> merijn: yep
05:35:29 <ski> > id not False
05:35:31 <lambdabot>  True
05:35:39 <ski> > flip id False not
05:35:41 <lambdabot>  True
05:35:48 <merijn> roflik: Right, so from filling in id's "x -> x" we get the following equation: "x = a" and "x = b -> c"
05:36:05 <merijn> So "a = b -> c"
05:36:39 <merijn> Back to flip "(a -> (b -> c)) -> b -> a -> c"
05:36:49 <merijn> Now, substitute "b -> c" for a and we get:
05:37:09 <merijn> "((b -> c) -> (b -> c)) -> b -> (b -> c) -> c"
05:38:12 <merijn> Apllying flip to id saturates the first argument "((b -> c) -> (b -> c))", so we lop that off and get "flip id :: b -> (b -> c) -> c"
05:42:00 <Ariakenom> roflik: in particular note id's type: x -> x = (b->c) -> (b->c) = (b->c) -> b -> c
06:02:44 <Jinna> I have a function   f :: String -> String   with the implementation   f s = show (read s)    – why does this not compile?
06:03:06 <merijn> Jinna: What type is it supposed to "read"?
06:03:36 <merijn> Jinna: You (should be) getting an ambiguous type error means "this type could be many things and there is not enough information to infer which I should use"
06:04:33 <Jinna> merijn: okay, so `read` is the original problem and the error about `show` is just a consequence.
06:04:35 <geekosaur> note also that ghci will probably compile it, possibly with a warning. but will pick () as the intervening type, which is not really helpful
06:04:36 <merijn> Jinna: Specifically "read" can read any type that is an insance of Read. And show can show anything that is an instance of Show. So the intermediate type between read and show can be "anything that is an instance of Read *and* Show", which happens to be "a lot of things"
06:04:55 <Jinna> Got it, thx.
06:05:10 <geekosaur> ExtendedDefaultRules is not always your friend
06:05:12 <merijn> Jinna: "ambiguous type" is telling you "please pick ONE specific type that is Read and Show"
06:05:24 <merijn> ExtendedDefaultRules is *never* your friend :p
06:05:36 <merijn> @check \l -> l == reverse l
06:05:38 <lambdabot>  +++ OK, passed 100 tests.
06:05:44 <geekosaur> enh. it can be fairly nice in ghci. but you should know what you're doing
06:05:46 <merijn> Brilliant!
06:06:07 <geekosaur> arguably the same applies to e.g. do notation and other such helpers
06:08:26 <solonarv> merijn: witchcraft!
06:08:37 <solonarv> @check (==) <*> reverse
06:08:40 <lambdabot>  +++ OK, passed 100 tests.
06:08:44 <solonarv> oooh of course
06:09:04 <solonarv> @check (==) <*> reverse `asAppliedTo` 5
06:09:07 <lambdabot>  error:
06:09:07 <lambdabot>  • No instance for (Num [()]) arising from the literal ‘5’ • In the second ar...
06:09:13 <solonarv> @check (==) <*> reverse `asAppliedTo` [5]
06:09:16 <lambdabot>  *** Failed! Falsifiable (after 4 tests and 4 shrinks):
06:09:16 <lambdabot>  [-1,3]
06:09:21 <solonarv> amazing :D
06:10:12 <Jinna> merijn: I intend to pass in the concrete type via Proxy, so now my sig is this:  f :: (Read a, Show a) => x a -> String -> String          and implementation:   f _ s = (show :: a -> String) (read s)
06:10:24 <Jinna> ghc still doesn’t like that
06:10:47 <solonarv> you need the ScopedTypeVariables extension for this
06:11:03 <solonarv> otherwise the 'a' in the body and the type signature are completely unrelated
06:11:12 <Jinna> solonarv: ok, let my try that.
06:11:31 <geekosaur> you also need an  explicit forall
06:11:43 <solonarv> also, you need either a 'forall x a. ' at thestart of the type signature or a signature on the pattern match, likeso: f (_ :: x a) s = ...
06:11:50 <Jinna> solonarv: the extension didn’t fix it.
06:11:51 <geekosaur> in effect declaring which type variables have the extended scope
06:11:59 <Jinna> geekosaur: why I need the explicit forall here?
06:12:03 <solonarv> Jinna: yep, see geekosaur's and my additional messages
06:12:12 <geekosaur> I just answered that
06:12:36 * ski . o O ( s/signature/ascription/ )
06:12:53 <solonarv> geekosaur: if you have an explicit forall it must mention *all* free type variables in the signature
06:12:58 <geekosaur> yes
06:13:08 <solonarv> so you are not choosing *which* type variables to bring into scop
06:13:09 <ski> Jinna : silly reasons (imho)
06:13:17 <geekosaur> but there's more than one type signature, and applying to every type signature can cause breajage
06:13:34 <geekosaur> (hypothetically. nobody knows how much code it would actually break, and everyone's afraid to ask)
06:14:39 <Jinna> If I don’t mention the explicit forall, what would the implicit forall look like?
06:14:40 <geekosaur> ghc devs are aware there's a lot of code that never sees hackage (internal code used by facebook, standard chartered, etc.)
06:14:57 <geekosaur> every type variable mentioned in the signature, at the very front
06:15:00 <Jinna> I would like to see the contrast between the explicit one that should be working here, and the implicit one, which fails.
06:15:19 <solonarv> oh the issue is not special magic that is lacking from the implicit forall
06:15:20 <geekosaur> there isn't one, actually
06:15:29 <geekosaur> the difference is that expliit forall is a declaration
06:15:41 <solonarv> merely an arbitrary decision that the implicit forall does not bring anything into scope
06:15:46 <geekosaur> implicit forall is not explciitly stating "I am using this name in a different scope than normal"
06:15:49 <solonarv> (which was made for backwards compat reasons)
06:16:09 <Jinna> So is the implicit forall an empty one in this case?
06:16:12 <geekosaur> ScopedTypeVariables means "explicitly declared type variables, wjich are declared with the "forall" keyword, have an extended scope"
06:16:36 <geekosaur> if you have f :: (a -> b) -> a -> b
06:16:52 <geekosaur> the explicit forall version is: f :: forall a b. (a -> b) -> a -> b
06:17:15 <geekosaur> means the same thing normally. with ScopedTypeVariables the explict one scopes the explicitly declared type variables over the binding as well as the signature itself
06:17:30 <geekosaur> or pattern itself, for the pattern one f (x :: a) = ...
06:17:53 <solonarv> actually pattern signatures are just not allowed at all without STV
06:18:09 <solonarv> which is a bit silly IMO, but that's how it is
06:18:28 <geekosaur> right, becuse they can't be given a meaning the way implicit tyvars can, becaue patterns are linear
06:18:40 <geekosaur> that is, you can't reuse the a in f (x :: a) ... = ...
06:19:08 <geekosaur> if you could, then there'd be a reasonable meaning for that (x :: a) in the absence of ScopedTypeVariables
06:19:17 <solonarv> oh, I know. but even signatures with no tyvars at all aren't allowed!
06:19:43 <solonarv> that is the puzzling part
06:21:19 <solonarv> e.g. can't write this (in a do block): x :: MyConfig <- decodeIO' "blah.yaml"
06:23:11 <Jinna> So, restating this all in my own words: in my implementation I said  `(show :: a -> String)`    but here this `a` was not the one for f’s type signature. It was a totally new/fresh a.
06:23:23 <Jinna> But I can extend the scope via the extension.
06:23:38 <geekosaur> correct
06:23:42 <Jinna> And now a consequece is that I _also_ have to specify x in the forall.
06:23:50 <Jinna> Good good, then I think it made click now.
06:23:55 <Jinna> Thx again guys.
06:24:21 <dminuoso> ski: Sorry perhaps I misunderstood then. What did you mean by type ascription exactly?
06:24:33 <dminuoso> I mean I know what a type ascription is, just cant connect it to my code.
06:30:00 <geekosaur> ususaly called a type signature, but there are obscure differences
06:30:18 <geekosaur> notably, a type signature can specify a different type, a type ascription can only *refine* a type
06:31:30 <geekosaur> that is, make it more or less specific but still compatible. compare C, where a type signature can specify a different type from the one inferred (e.g. pointer vs. int)
06:32:33 * geekosaur is curretnly trying to wrap his head around singletons. whee.
06:33:19 <geekosaur> solonarv, I think that limitation is just because ghc can't conditionally parse it.
06:33:35 <geekosaur> can't say "oh that syntax is ok only if it has no tyvars"
06:33:52 <solonarv> yeah I guess
06:34:00 <geekosaur> complicated by various other extensions that could make it open-ended, iirc
06:34:13 <geekosaur> (just think, eventualy we get dependent types and it really will be open-ended.)
06:34:14 <solonarv> I don't mind too much, certainly not enough to desire a new PatternSignatures extension!
06:34:27 <geekosaur> there used to be one, way back when
06:34:37 <geekosaur> it got folded in
06:38:26 <ski>   toHandler env (FreyjaM h :: FreyjaM a) = ..a..  -- dminuoso ?
06:44:02 <fendor> @pl Stk2 <$> ((,) <$> arbitrary <*> arbitrary
06:44:03 <lambdabot> (line 1, column 42):
06:44:03 <lambdabot> unexpected end of input
06:44:03 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator, "<*", "*>", "<$>", "<$", "<**>", "==", "/=", "<", "<=", ">=", ">", "`elem`", "`notElem`" or ")"
06:44:09 <fendor> @pl Stk2 <$> ((,) <$> arbitrary <*> arbitrary)
06:44:09 <lambdabot> Stk2 <$> ((,) <$> arbitrary <*> arbitrary)
06:53:30 <solonarv> that's already point-free, idk what you expected :P
06:54:53 <fendor> something that may remove these parentheseses :)
06:56:26 <hjt> where can i read about the bots in this channel? what there is, how to use, etc
06:58:01 <Ariakenom> fendor: Stk2 <$> liftA2 (,) arbitrary arbitrary
06:58:33 <fendor> Ariakenom, i thought the same, but hoped the lambdabot would be smart enough for that!
06:58:40 <fendor> Ariakenom > lambdabot 
06:59:34 <Ariakenom> :]
07:03:04 <ski> @wiki Lambdabot
07:03:05 <lambdabot> https://wiki.haskell.org/Lambdabot
07:03:14 <ski> hjt : that ^ has some info on lambdabot
07:04:41 <fendor> damn, djinn sounds insane
07:04:44 <defanor> i have something that looks like a memory leak here, with ghc 8.0.1, but not yet certain and it may take a while to reproduce/profile. it's not expected, say, for runtime system to grow from ~50 to ~500 MB (RES) in 6+ months just doing runtime things, is it?
07:04:54 <fendor> @djinn (a, b, c) -> b
07:04:54 <lambdabot> f (_, a, _) = a
07:07:07 <solonarv> @djinn [a] -> a
07:07:07 <lambdabot> Error: Undefined type []
07:07:38 <solonarv> @djinn (forall b. (a -> b -> b) -> b -> b) -> a
07:07:38 <lambdabot> -- f cannot be realized.
07:07:41 <hjt> <ski "hjt : that ^ has some info on la"> thanks!
07:08:05 <solonarv> who needs actual data types when you can just scott-encode them!
07:08:18 * ski doesn't understand why <matrix.org> does that ..
07:08:44 <ski> Djinn doesn't understand higher-rank
07:09:42 <hjt> @list
07:09:42 <lambdabot> What module?  Try @listmodules for some ideas.
07:10:43 <ski> @list dict
07:10:44 <lambdabot> dict provides: dict-help all-dicts bouvier cide devils easton elements foldoc gazetteer hitchcock jargon thesaurus vera wn world02
07:10:56 <solonarv> btw, you can play with lambdabot in PMs too
07:11:05 <solonarv> just do /query lambdabot
07:11:06 <ski> @yhjulwwiefzojcbxybbruweejw
07:11:06 <lambdabot> "\""
07:11:58 <Taneb> ski: um
07:12:38 <ski> ?
07:12:48 <Taneb> How did lambdabot understand that
07:12:59 <ski> it's a command
07:13:04 <Boarders> not really a haskell method but is there a way of taking a collection of strings and generating a new string which is not equal to any of them?
07:13:11 <Boarders> that is reasoably fast and so on
07:13:16 <Taneb> ski: how did you remember the command
07:13:25 <ski> i looked it up
07:13:39 <Taneb> OK
07:13:40 <hyperisco> Boarders, fascinating question! The easiest way is to just produce a string that is longer than any other string
07:13:56 <Boarders> method -> question*
07:13:58 <ski> @keal
07:13:59 <lambdabot> i dont really eat vegetables unless cheese is a vegetable
07:14:38 <fendor> hyperisco, method does not handle infinite strings
07:14:40 <geekosaur> diagonalization?
07:14:46 <dmwit> Boarders: You can use the standard diagonalization argument showing reals are not countable.
07:14:47 <geekosaur> heh
07:14:57 <geekosaur> more of the math smart___ version, I guess
07:15:08 <fendor> i also think diagonalization is the best way
07:15:12 <dmwit> Boarders: For character n, choose something inequal to strings!!n!!n
07:15:14 <hyperisco> you guys are insane
07:15:53 <Rembane> What is diagonalization when it comes to strings? 
07:16:02 <dmwit> Rembane: See my previous message. =)
07:16:51 <ski> dmwit : what if the empty string is in the collection ?
07:16:53 <hyperisco> So, lets say that we also want the shortest string which is unequal to all other strings. Is that fair?
07:16:58 <dmwit> ski: What if it is?
07:17:45 <dmwit> ski: (Just make !! total by picking any inhabitant of its codomain when the index is too big.)
07:18:09 <ski> i see
07:18:13 <merijn> hyperisco: Simple. Pick a single letter that's not the first letter of any string. If every character in your character set are used by your strings, pick a two letter combination, etc.
07:18:24 <Jinna> In the PGSimple lib I have a ConnectInfo. I get one of those in json format and want to Aeson.decode it. To do this I have a line `instance FromJSON ConnectInfo`.
07:18:26 * ski . o O ( searchable and omniscient sets )
07:18:28 <Jinna> Now however, when I compile via `stack build --pedantic` I get a warning „Orphan instance: instance FromJSON ConnectInfo”. Because I have no access to PGSimple’s source code I don’t know how to get rid of this warning other than turning --pedantic off.
07:18:32 <Jinna> Is there a way to mark this specific line `instance FromJSON ConnectInfo` and suppress the orphan warning only for that one?
07:18:37 <hyperisco> merijn, tell Boarders?
07:19:07 <dmwit> Boarders: You might also want to look at tries.
07:19:07 <geekosaur> Jinna, not presently
07:19:14 <Rembane> dmwit: Oh, I jumped too far in the backlog. Thank you! 
07:19:17 <merijn> Tries are cool :)
07:19:19 <geekosaur> finer grained warnings are a work in progress
07:19:46 <dmwit> Hm, maybe a trie won't help that much, actually.
07:20:00 <merijn> Jinna: Alternatively, define a newtype around ConnectionInfo in your own code and provide a FromJSON instance for that
07:20:02 <dmwit> (For the "shortest non-inhabitant" problem.)
07:20:26 <merijn> Jinna: Then you just have to "unwrap" the newtype before passing it to PGSimple
07:22:39 <Taneb> dmwit: how about a tree data structure which keeps track of the depth of the nearest whole at every node? I think you get logarithmic asymptotics for pretty much anything with that
07:23:50 <Boarders> dmwit: cute
07:24:11 <Taneb> Well, O(log(number of strings) * size of character set)
07:24:59 <Boarders> merijn: thanks
07:25:54 <hyperisco> Lets say the string length is proportional to the number of strings, how do we do this in less than quadratic time?
07:33:06 * ski looks at dminuoso
07:33:22 <dmwit> Taneb: Nice!
07:34:19 <maerwald> I feel like I'll be switching to vscode soon. HIE integration is best, typescript in vim is awful too
07:34:51 <Rembane> Do it! 
07:34:56 <hyperisco> At least with the diagonalisation-inspired approach the string will be at most one character longer than the longest string
07:35:28 <hyperisco> Though, that was also my approach which didn't look at the characters at all :P The difference is in the average and best cases
07:35:37 <maerwald> and vscode has a vim plugin to fix the broken editor this IDE ships with
07:35:44 <hjt> the QuickCheck manual says that "if g is a generator for type t then (four g) generates a quadruple of ts"
07:35:56 <hjt> but i can't seem to get this to work? the module doesn't offer any function called four
07:36:13 <fendor> hyperisco, I think you can create a string that is at most the size of the amount of strings or the smallest string
07:37:30 <hyperisco> Do you mean the length at most will be the smaller of the number of strings and the smallest string?
07:37:35 <fendor> nah, take it back, that sounds nonsensical
07:38:04 <ski> hjt : is it defined in the manual section ?
07:38:26 <hjt> <ski "hjt : is it defined in the manua"> yes
07:38:41 <ski> then use that definition ?
07:38:52 <geekosaur> make sure you're running a version that su[ports it, too
07:39:19 <hjt> oh sorry, no, it's not defined, just mentioned in passing, exactly as i quoted
07:40:37 <ski> perhaps you can use `four = vector 4' or `four = liftA4 (,,,) arbitrary arbitrary arbitrary arbitrary' (depending on which result type you want)
07:40:37 <geekosaur> hm. manual lists it, index doesn't
07:40:45 <geekosaur> hackage page says manual is out of date
07:41:05 <geekosaur> "The official QuickCheck manual. It's a bit out-of-date in some details and doesn't cover newer QuickCheck features, but is still full of good advice."
07:41:15 <hyperisco> Actually wondering if better than exponential time can be done now… hrm.
07:42:07 <hjt> i think i can use replicateM
07:43:55 <geekosaur> my probing says four and friends were QC 1.x
07:45:44 <hyperisco> We can choose any one-char string if one is not yet used. After that we have to look at two-char strings, and I don't see any shortcut to looking for them all.
07:46:57 <hyperisco> Granted, the length of list has to also grow exponentially to exhaust these combinations, so maybe once that is factored in the problem doesn't seem so bad.
07:47:29 <fendor> linear in the input sizes seems quite alright.
07:51:03 <ski> hjt : `vector' is basically `replicateM', yes
07:51:15 <hyperisco> Alright, say we had a list of two-char strings. How can we efficiently determine which string is missing, assuming exactly one is missing?
07:52:38 <hjt> vector or vectorOf ?
07:52:44 <tsahyt> is there a nonblocking version of readChan?
07:52:48 <tsahyt> i.e. tryReadChan
07:52:49 <hyperisco> Generally, we have to start with a store of all possibilities then cross them out
07:53:19 <ski> hjt : yes
07:53:35 <hyperisco> So, if we do that, in that example scenario our store is about the length of the list. However, lets now say the list is half the size. Our store doesn't get any smaller, does it.
07:54:58 <fendor> yeah... fair... then the list of candidates explodes pretty fast
07:55:08 <solonarv> hyperisco: easy: determine which first character is missing, and the same for the second character
07:55:12 <hyperisco> So, we can figure out the problem in linear time, but we need exponential memory. And practically speaking, we're not going to preallocate it, so it will then take exponential time to construct it.
07:55:37 <hyperisco> solonarv, what if no first character is missing?
07:55:57 <hjt> vectorOf works great, thanks
07:56:04 * solonarv durr
07:56:06 <solonarv> of course
07:56:13 <hjt> QuickCheck is really nice!
07:56:19 <solonarv> either all first characters are present and exactly one second character is missing, or vice versa
07:56:28 <solonarv> ...wait
07:56:28 <solonarv> no
08:01:58 <hyperisco> If the list is of length n, and the alphabet is of length m, then to exhaust all permutations of length l then m^l ≤ n
08:02:27 <hyperisco> combinations? I dunno
08:04:23 <hyperisco> Anyways, that means given a list of length  n  we know we can find an unused string of length  log_m(n)  (0 if n = 0, and rounded down)
08:05:55 <hyperisco> Excuse me, rounding up
08:09:53 <hyperisco> Meaning, our store only has to have size  m^ceil(log_m(n))
08:11:01 <hyperisco> n ≤ m^ceil(log_m(n)) ≤ m*n
08:11:26 <hyperisco> So… O(m*n)
08:12:57 <hyperisco> And best case linear… however that is noted ^.^
08:13:24 <hyperisco> I have no experience figuring out averages
08:19:54 <dminuoso> ski: So, that would only work if I capture `a` with explicit forall and ScopedTypeVariables wouldn't it?
08:20:47 <dminuoso> Oh wait this is truly interesting.
08:20:57 <hyperisco> How does complexity analysis usually treat memory allocation?
08:21:15 <merijn> hyperisco: It doesn't
08:21:20 <dminuoso> solonarv: https://gist.github.com/dminuoso/3d2dfd4db7b7a0924b8c26522eec8711 this works indeed.
08:21:31 <merijn> hyperisco: Also, most complexity analysis is hopelessly flawed wrt real world performance and complexity
08:21:34 <hyperisco> So, what, we just get whatever memory we want, in any state we want, for free?
08:21:37 <dminuoso> Err, I meant ski ^-
08:21:38 <ski> dminuoso : no explicit `foall'
08:21:45 <ski> s/forall/forall/
08:21:46 <dminuoso> ski: yeah I noticed, this is really surprising.
08:21:51 <hyperisco> I choose the memory state that is the answer to the question, so the solution is O(1)? lol
08:21:58 <merijn> hyperisco: Traditional complexity analysis assumes O(1) random access for memory, which is obviously bogus
08:22:16 <dminuoso> ski: So a type ascription in a pattern match introduces a type variable?
08:22:20 <solonarv> dminuoso: indeed
08:22:34 <solonarv> that is exactly what is happening
08:22:43 <hyperisco> I can reduce the time to  n  if I can allocate an initialised array of  m*n  bits
08:22:50 <merijn> hyperisco: Because complex cache effects mean that the ACTUALY complexity of a memory access is dependent on access pattern and you can get orders of magnitude difference between complexity and actual performance
08:23:05 <hyperisco> If I have to count the initialisation of that memory as time, then obviously I don't gain anything
08:23:27 <merijn> hyperisco: See phk's classical essay in the ACM Queue: https://queue.acm.org/detail.cfm?id=1814327
08:23:38 <dminuoso> solonarv: What if the type variable was buried in a function type?
08:23:43 <solonarv> still works
08:23:50 <hyperisco> yeah well I am making a consideration simpler than caching
08:24:03 <ski> "buried" ?
08:24:03 <dminuoso> Ah because its a refutable pattern match right. Its about the type annotation part, not actual pattern matching.
08:24:06 <dminuoso> *irrefutable
08:24:22 <solonarv> yes, it is because the pattern match has a type annotation.
08:24:31 <solonarv> it doesn't matter what sort of pattern it is
08:24:34 <dminuoso> ski: I dismissed the idea without comment at first because I didn't realize that this was a thing. :)
08:24:40 <dminuoso> So pardon me for that, thank you.
08:24:44 <merijn> hyperisco: If we're talking about the memory contents of allocated memory, then the answer is "it depends on how you define memory behaviour in your model"
08:24:53 <ski> dminuoso : yw :)
08:25:18 <solonarv> you can do this, too: case blah of Left (x :: a) -> ..a..; Right (y :: b) -> ...b..
08:25:23 <dminuoso> So I guess within this scope `a` is existentially quantified, isnt it?
08:25:57 <solonarv> no, it is simply a rigid type variable
08:26:05 <solonarv> equal only to itself, and not to any other type
08:26:31 <dminuoso> solonarv: Oh fair enough. I was just thinking this corresponding to some `toHandler env (FreyjaM h :: exists a. Freyja a) = ...` 
08:26:40 <solonarv> oh, it does correspond to that
08:26:40 <hyperisco> merijn, so, it is an out-of-band consideration, that's fine
08:26:43 * ski . o O ( once upon a skolem .. )
08:26:50 <solonarv> er, roughly anyway
08:26:59 <solonarv> (skolem is another word for rigid, IIRC)
08:28:08 <ski> dminuoso : if you had `foo :: Blah -> exists a. Foo a', then that `a' would not act like a skolem / act rigidly, inside the definition of `foo'
08:28:36 <ski> (and for this reason, i don't like to describe the situation as "existentially quantified")
08:29:11 <solonarv> instead, you would simply be able to pick some arbitrary 'a' inside the body and then "forget what you picked" by hiding it under the existential
08:29:38 <merijn> Does Travis seriously not have a reference or spec for .travis.yml? o.O
08:29:41 <solonarv> yahb: welcome back!
08:29:42 <ski> (something similar occurs in logic programming, where a variable which is universally quantified over a clause, or existentially quantified over a goal, acts in the same way; ..
08:29:58 <merijn> They just have snippets spread out over 20+ different pages with no global overview...
08:30:16 <ski>  .. and one which is existentially quantified over a clause, or universally over a goal, acts in the same way. but the former two cases act differently to the latter two cases)
08:30:35 <dminuoso> ski: I suppose I need to continue my path into logic if I want to understand this properly..
08:31:01 <ski> probably not that much
08:31:22 <dminuoso> ski: If I take a quick peek at skolemnization, I feel very intimidated.
08:31:32 <ski> then don't
08:33:01 <ski> but you should recall that the variable `a' in a value of type `forall a. ..a..' acts very differently depending on whether we view it from the perspective of the caller/user/consumer, or from the perspective of the callee/implementor/producer
08:33:24 <ski> and in the `exists a. ..a..' case, these two different roles are reversed
08:34:02 <dminuoso> ski: In `f :: forall a. ...; f = ... a` from the perspective of inside the definition of `f`, would `a` be a skolem type variable?
08:34:59 <dminuoso> ski: Okay I think I have a vague idea where you are headed.
08:35:04 <ski> if you call `foo :: forall a. [a] -> [a] -> [a]', then that means you can pick `a' to be whatever you like. if you implement `foo', then you can't assume anything about `a', it acts like it's an abstract data type. an opaque/hidden/forgotten. that is only known to be equal to itself
08:35:19 <ski> dminuoso : yes
08:36:57 <ski> if you implement `bar :: [Integer] -> exists a. (a,Integer -> a -> a,a -> Maybe (a,Integer))', then that means you can pick `a' to be whatever you like. if you call `bar', then you can't assume anything about `a', it acts like it's an abstract data type. an opaque/hidden/forgotten. that is only known to be equal to itself
08:37:33 <ski> in the `foo' case, `a' is a skolem to the producer. in the `bar' case, `a' is a skolem to the consumer
08:39:04 <ski> "skolem" here means "someone else's choice", while "metavariable" (called "logic variable" in logic programming) means "your choice"
08:39:32 <dminuoso> ski: But doesn't that correspond to `forall` and `exists` ?
08:40:08 <dminuoso> ski: I mean in Rank1Type, `forall` means "someone else's choice from the producer perspective" and `exists` means "your choice from the producer perspective"
08:40:27 <ski> if you call `foo', then that means you're instantiating the type `forall a. [a] -> [a] -> [a]' to become `[_a] -> [_a] -> [_a]', for some metavariable `_a', which sooner or later (wrt type inference/checking) has to be picked to be some particular type
08:41:03 <ski> s/ in Rank1Type,//
08:41:45 <dminuoso> ski: Well I was trying to avoid issues with `f :: (forall s. F(s)) -> T` from the perspective of the `f producer`
08:42:01 <ski> yes, it corresponds to `forall' and `exists'. but both "metavariable" and "skolem" corresponds to both of them, which you get depends on the role (producing or consuming) that you're having wrt the type
08:42:26 <dminuoso> Ahh I see.
08:42:35 <solonarv> if you're consuming a universal or producing an existential, you have a metavariable
08:42:38 <ski> well, that `f' isn't polymorphic, it doesn't have a type like `forall s. ..s..', so it doesn't apply to that `f'
08:42:50 <ski> (but it does apply to the parameter of `f', of course)
08:42:59 <solonarv> if you are consuming an existental or producing a universal, you have a skolem/rigid variable
08:43:27 <dminuoso> solonarv: And I am indeed producing a universal. :)
08:43:35 <ski> you could sortof say that skolem vs. metavariable is the xor of `forall'/`exists' and producer/consumer
08:43:37 <dminuoso> Since its just a function producing a natural transformation
08:43:49 <solonarv> note also that "consuming an existential" and "producing a universal" are in some sense the same thing: forall a. F a -> B ~ (exists a. F a) -> B
08:44:53 <solonarv> so it makes sense that they should behave similarly!
08:45:21 <ski>   length :: forall a. ([a] -> Int)  -- for all types `a', if you feed `length' with a list of elements of type `a', you get back an `Int'
08:46:11 * dminuoso just learned deeply that `length` is infact a natural transformation in disguise, if realize its isomorphism with `length' :: forall a. [a] -> Const a Int`
08:46:20 <ski>   length :: (exists a. [a]) -> Int  -- you'll get back an `Int', if there exists some type `a', where the type of the elements in the list you feed to `length' has type `a'
08:47:04 <solonarv> dminuoso: you flipped the parameters to Const, I think
08:47:07 <solonarv> but yes!
08:47:23 <dminuoso> solonarv: Oh. Well, to my defense Ive never actually used Const. :P
08:47:28 <ski> `exists' to the left of `->' isn't "interesting", because it can be explained in terms of the equivalent formulation with a `forall' over the `->'
08:47:33 <dminuoso> I guess it makes sense if one compares it to `const`
08:47:39 <ski> forall' to the right of `->' isn't "interesting", because it can be explained in terms of the equivalent formulation with a `forall' over the `->'
08:47:56 <ski> (`... -> (forall a. ..a..)' is `forall a. (... -> ..a..)')
08:48:07 <Taneb> length is also a monoid homomorphism from [a] to Sum Int
08:48:42 <ski> otoh, `exists' to the *right* of `->' *is* "interesting", as is `forall' to the *left* of `->' (which is rank-2)
08:48:46 <solonarv> or to (forall x. Endo (Endo x)) :P
08:49:30 * ski . o O ( `Const . length :: [] ~> Const Int' )
08:49:35 <dminuoso> ski: Do you know of a language where explicit existential quantification is part of its type system?
08:49:43 <ski> dminuoso : Mercury
08:52:15 <Ferdirand> solonarv: thanks for the earlier explanation about phantom
08:52:25 <Ferdirand> i stumbled upon an alternative definition
08:52:41 <Ferdirand> :t fmap absurd . contramap absurd
08:52:42 <lambdabot> (Contravariant f, Functor f) => f b1 -> f b2
08:52:55 <solonarv> yup, I thought of that while we werea talking earlier
08:53:17 <Ferdirand> i thought about it while reflecting on the nature of () as a terminal object
08:54:24 <dminuoso> Ferdirand: I came to the same conclusion by the way. :)
08:56:54 <solonarv> hey, that's how I got to it too!
08:58:10 <janat08> when running haskell build i get error: https://gist.github.com/janat08/8b21cc4b3c51e875f8cd27ea397c9b6f
08:59:10 <janat08> *stack build
09:01:50 <dminuoso> So let's say I have some `f :: LoggingT IO ()`, is there an eloquent way to hoist this into some `FooM ()` for which you have `MonadLogger FooM`?
09:02:35 <dminuoso> (I mean in my case I would unlift it into IO and lift it back, but I was hoping for something slightly more succinct)
09:25:44 <higherorder> Do all things of kind `Constraint` in Haskell have dictionaries?
09:29:12 <geekosaur> no. ~ produces a Constraint, but has no runtime representation
09:31:12 <Welkin> there are no types at runtime at all, I thought
09:31:21 <geekosaur> (which is also why there's no /~ version, since that requires a runtime inequality witness; ~ can be done as an annotation in the typechecker marking two tyvars as equivalent)
09:31:48 <geekosaur> no types, but type witnesses of sorts. for a typeclass, the witness is a dictionary of actions
09:31:51 <higherorder> geekosaur: why would /~ require a runtime witness?
09:31:51 <geekosaur> (methods)
09:32:28 <geekosaur> because you can say two tyvars are the same thing by aliasing them. to say they are different requires knowing what they are _at runtime_
09:32:41 <geekosaur> but types are erased, so you need a witness at runtime for the inequality
09:33:02 <higherorder> geekosaur: tyvar = type variable, right?
09:33:06 <geekosaur> yes
09:33:14 <geekosaur> sorry that's a ghc shorthand
09:33:42 <higherorder> geekosaur: "" to say they are different requires knowing what they are _at runtime_" but... tyvars don't exist at runtimes; they're resolved at compile time?
09:33:45 <ski> (also used elsewhere)
09:34:07 * ski didn't realize `/~' was meant as inequality, at first
09:34:27 <Welkin>  /~ is my home directory!
09:36:51 <geekosaur> higherorder, that is the point, but some things require runtime indicators.
09:37:02 <geekosaur> so we have, not types, but type witnesses
09:37:06 <adamCS> is there a "cabal v2-install" equivalent of "cabal install foo-0.1.0.0.tar.gz"?  When I try it directly, I get an "unknown-target" error. 
09:37:14 <geekosaur> for typeclasses, type witnesses ar einstance dictionaries.
09:37:41 <Welkin> an einstance!
09:37:58 <geekosaur> for type equivalens there's no builtin but you will find various SEq or etc. typeclases which use typeclass dictionaries as witnesses for type (in)equality
09:38:32 <geekosaur> beyond this you're getting into "fun" type level stuff I'm still learning about...
09:39:36 <geekosaur> the point being ghc can't do this "natively" so we use hacks
09:40:03 <geekosaur> mostly based around typeclasses, because they blur the boundaries. but you have to understand how they do so to understand why they work
09:40:34 <janat08> just to be clear, all it takes to get a cloned project good to go is stack build, even if nix is used?
09:43:01 <Welkin> cabal build
09:43:02 <Welkin> yes
09:43:11 <Welkin> no idea about stack, I don't use it anymore
09:43:16 <Welkin> cabal new-build*
09:43:21 <higherorder> geekosaur: silly question, but why do we need dictionaries at all for typeclasses? Couldn't you, at compile time, resolve which function should be called based on the types?
09:43:32 <Shoubit> janat08, depends on how Nix is used I think, you might have to configure Stack to use Nix.
09:43:35 <geekosaur> I thin stack needs to be used in a special nix mode, because it tries to do the same thing nix does in ways that conflict
09:43:53 <geekosaur> higherorder, sometimes they can
09:44:04 <geekosaur> but consder the typeclass Show, which can recursively invoke itself
09:44:10 <geekosaur> at a different instance
09:44:25 <geekosaur> (think: Show x => Show [x])
09:44:56 <geekosaur> these can't be resolved at compile time, they need to be passed a dictionary. otherwise you could not have that then work with [[x]] or [[[x]]] etc.
09:45:56 <janat08> a nix package won't install, https://nixos.org/nixos/packages.html#relative+time+pretty 
09:46:04 <janat08> its in nixos channel, so I can't find it with nix-env
09:46:13 <higherorder> geekosaur: but.. they could be resolved at compile-time, no? the compiler could generate a version of show for lists of lists, one for lists, and one for x (each specialised to a particular x). Unless I am missing something
09:47:06 <geekosaur> only i it knows for certain, which requires compiling the whole program all at once
09:47:23 <higherorder> geekosaur: doesn't it always know the whole program on compilation?
09:47:26 <geekosaur> if you use prebuilt libraries, those libraries do not know they wll be linked with yoru program later
09:47:46 <geekosaur> they cnnot generate code for your program that will be written a year later
09:47:47 <higherorder> ah! I wasn't aware you could pre-build librairies
09:48:07 <Shoubit> janat08, haskellPackages isn't exposed by default, you'd have to tell nix-env to evaluate it: nix-env -f '<nixpkgs>' -iA haskellPackages.pretty-relative-time, but even then you still can't use it because it's a library and won't be exposed globally.
09:48:17 <Shoubit> janat08, you'd have to use something like: nix-shell -p "haskellPackages.ghcWithPackages (pkgs: with pkgs; [pretty-relative-time])"
09:48:24 <higherorder> so if the compiler knew your whole program at once, then we could do away with dictionaries (at the cost of more code generation => larger binairies I guess?)
09:48:29 <higherorder> correct? 
09:48:31 <geekosaur> yes
09:48:42 <geekosaur> there used to be a compiler that did this, even (jhc)
09:49:02 <geekosaur> but whole-pprogram compilation has its own issues, including that it's slower
09:49:28 <higherorder> is the argument the same for /~? if the compiler knew your whole program at once then you wouldn't need a runtime witness?
09:50:09 <geekosaur> I'm not sure tbh.
09:50:57 <geekosaur> although probably yes because you can solve it with a typeclass
09:51:41 <geekosaur> and typeclasses can be resolved that way. although, aybe there are some specific pathological recursive uses that can't be, or that cause pathological compile-time behavior
10:01:05 <nshepperd_> You can write programs in haskell that use levels of lists-of-lists determined only at runtime
10:03:05 <ski> higherorder : even with whole-program compilation there are situations in which it can't know
10:03:14 <ski> (in general)
10:04:17 <nshepperd_> GHC sort of does that though (generics by specialisation) when it inlines typeclass instances
10:04:53 <davean> nshepperd_: takes more care than I'd like
10:04:59 <geekosaur> I think polymorphic recursion's still a problem though
10:05:02 <ski> yes
10:05:07 <ski> (and existentials)
10:05:12 <geekosaur> sometimes you can unwind, sometimes not
10:05:35 <davean> ski: existentials are an extension?
10:05:50 <ski> yes
10:05:55 <nshepperd_> That only happens when the inliner heuristics say it's a good idea, which sounds like the right way to do it to me
10:06:03 <ski> (but polymorphic recursion isn't)
10:06:09 <davean> ski: right
10:16:24 <dmwit> higherorder: https://stackoverflow.com/a/11422333/791604
10:25:18 * geekosaur thought something like that
10:44:35 <hyperisco> I was going to suggest higher rank types
10:45:28 <hyperisco> I assume you can construct some sort of halting problem trying to figure out every type a function is used at
10:47:28 <zwarag> I'm trying to understand what exactly the `(Ord a) =>` does on line 6. What is this called? (so I can google further). I understand it's not a type. Looks like some kind of inheritance. https://gist.github.com/zwarag/6417bf4aa6e4fe029a683299f3c679be 
10:47:45 <monochrom> "type class" and "constraint"
10:48:52 <monochrom> Also those "l == Empty" is unnecessary premature optimization.
10:49:26 <jgt> zwarag: that's a type constraint. It says "any `a`, as long as that `a` has an Ord instance"
10:49:47 <jgt> Ord being things that can have an order (can be sorted)
10:51:02 <jgt> jgt: it's also not one of the parameters in the type signature, so you shouldn't read addTree as taking three arguments (of course ignoring for a moment that all functions really only take one argument)
10:51:30 <hyperisco> Maybe I am brain farting but aren't those guards also wrong?
10:52:18 <jgt> those guards are sufficiently complex that I would delegate all reasoning about them to hspec
10:52:18 <Welkin> guards, sieze him!
10:52:25 <zwarag> jgt: just to rephrase that to see if I get it. I need (Ord a) => to make sure that addTree can only be called with Types that have an instance of Ord?
10:52:27 <hyperisco> If the left branch is empty, why are we throwing away the right branch?
10:52:34 <hyperisco> If the left branch is nonempty*
10:52:50 <jgt> zwarag: yeah
10:52:52 <zwarag> hypersico: yes net is wrong
10:52:56 <monochrom> The guards are right, the RHS's are wrong when l/=Empty or r/=Empty.
10:53:20 <hyperisco> Okay, one of the LHS or the RHS are wrong :P
10:53:40 <monochrom> In fact don't even bother caring about subtrees. Just let recursion handle them.
10:54:05 <monochrom> #1 mistake in student recursion is worrying one more step ahead instead of trusting recursion.
10:54:22 <monochrom> The more code you handwrite the more bugs you get.
10:54:30 <hyperisco> ^ That is what I was trying to elicit
10:55:24 <hyperisco> Though I reserve the right to disregard that argument so that I can indulge my NIH syndrome
10:55:46 <zwarag> man you guys are determined :) thanks for the feedback. I'm just started learning this langue so thank you for going a bit further than just directly answering the question.
10:55:59 <monochrom> You don't have to disregard it, you just have to tweak it :)
10:56:12 <Welkin> you have to worship it
10:56:20 <Welkin> get on your knees
10:56:29 <monochrom> For example you can say "no the #1 part is wrong it should be #0"
11:03:09 <jgt> I returned to the Haskell channel and saw "get on your knees", which is an odd thing to read in this channel without context
11:05:38 <higherorder> jgt: lol
11:21:56 <solonarv> dminuoso: where are LoggingT and MonadLogger from?
11:23:25 <Welkin> monad-logger
11:24:53 <Noughtmare[m]> > sizeOf (undefined :: Bool)
11:24:56 <lambdabot>  error:
11:24:56 <lambdabot>      • Variable not in scope: sizeOf :: Bool -> t
11:24:56 <lambdabot>      • Perhaps you meant one of these:
11:25:00 <Noughtmare[m]> Why isn't it 1?
11:25:04 <gobby> is there a way to specify an os build target  in cabal? eg "x86_debian"?
11:25:15 <solonarv> dminuoso: if you're okay upgrading your MonadLogger constraint to MonadLoggerIO this is very simple
11:25:58 <monochrom> Because lambdabot doesn't have sizeOf, as the error message says.
11:26:14 <higherorder> yet another question... what does "f instantiated" means in https://github.com/ghc/ghc/blob/master/compiler/basicTypes/MkId.hs#L1655 ?
11:26:16 <solonarv> then it's just a matter of plumbing runLoggingT and askLoggerIO
11:26:16 <Noughtmare[m]> > Foreign.Storable.sizeOf (undefiend :: Bool)
11:26:18 <lambdabot>  error:
11:26:19 <lambdabot>      Not in scope: ‘Foreign.Storable.sizeOf’
11:26:19 <lambdabot>      No module named ‘Foreign.Storable’ is imported.
11:26:32 <solonarv> % import qualified Foreign
11:26:32 <Noughtmare[m]> :(
11:26:43 <yahb> solonarv: 
11:26:55 <ski> @let import Foreign.Storable
11:26:56 <solonarv> % Foreign.sizeOf (undefined :: Bool)
11:26:56 <lambdabot>  Defined.
11:26:56 <yahb> solonarv: 4
11:26:57 <Welkin> % import Data.Primitive.Types
11:26:58 <yahb> Welkin: 
11:27:03 <ski> > sizeOf (undefiend :: Bool)
11:27:05 <lambdabot>  error:
11:27:05 <lambdabot>      • Variable not in scope: undefiend :: Bool
11:27:06 <lambdabot>      • Perhaps you meant ‘undefined’ (imported from Prelude)
11:27:12 <ski> > sizeOf (undefined :: Bool)
11:27:14 <lambdabot>  4
11:27:17 <solonarv> huh. 4, not 8? odd
11:27:21 <Welkin> % import Data.Primitive.Types as Prim (sizeOf)
11:27:22 <yahb> Welkin: 
11:27:43 <Welkin> why are you speechless!?
11:27:44 <stilgart> > sizeOf (undefined :: Int#)
11:27:46 <lambdabot>  error:
11:27:46 <lambdabot>      Not in scope: type constructor or class ‘Int#’
11:27:47 <lambdabot>      Perhaps you meant one of these:
11:28:23 <Noughtmare[m]> solonarv: Why would you think 8?
11:28:43 <Welkin> 64 bit arch
11:28:46 <monochrom> Bool is marshalled to C int. x86 and x86-64 use 4 bytes for C int.  Also the C "0 is false, non-zero is true" convention is followed.
11:29:19 <solonarv> oh right, Foreign.sizeOf doesn't tell you how big the Haskell in-memory representation is
11:29:22 <solonarv> thanks monochrom 
11:29:30 <monochrom> Unfortunately in this case the GHC convention of "vary by arch" is not followed.
11:30:52 <Noughtmare[m]> Now I need to write my coding using ugly Word8 to make it faster.
11:31:07 <Noughtmare[m]> (Or define my own storable instance for Bool)
11:31:14 <solonarv> why do you think that will be faster?
11:31:27 <Welkin> rewrite it in assembly!
11:31:36 <solonarv> stuff is generally 4/8-byte aligned anyway
11:31:45 <solonarv> (for 32/64-bit arch)
11:31:47 <monochrom> Word8 on the GHC side uses 8 bytes if x86-64. :)
11:31:51 <solonarv> indeed
11:31:58 <monochrom> No wait, actually 16 bytes.
11:32:03 <Noughtmare[m]> I benchmarked it.
11:32:27 <monochrom> Word8# is 8 bytes; Word8 is Word8# plus tag.
11:32:53 <solonarv> it should be noted that you don't *need* a storable instance: you can just write your own peek/poke functions
11:33:03 <glguy> data Word = GHC.Types.W# GHC.Prim.Word#
11:33:11 <glguy> It's not just a Word8#, it's a whole Word#
11:33:13 <Noughtmare[m]> Yeah, I'm using Ptr Word8.
11:33:18 <Noughtmare[m]> As an array.
11:33:31 <glguy> Whoops, I meant: data Word8 = GHC.Word.W8# GHC.Prim.Word# 
11:33:47 --- mode: glguy set -o glguy
11:34:03 <solonarv> that seems easy to mess up: I would've tried unboxed vectors first
11:34:28 <Noughtmare[m]> I've found a Ptr much faster than Unboxed Vectors once.
11:34:30 <monochrom> Yeah unboxed vector does the compact thing.
11:34:43 <Noughtmare[m]> with "much" i mean noticably.
11:35:01 <solonarv> your approach is ~equivalent to Data.Vector.Storable, though that probably has a nicer API than what you've cobbled together
11:35:30 <Noughtmare[m]> I've found Ptr faster than Data.Vector.Storable
11:35:34 <monochrom> No, write more asm. Skip C.
11:36:24 <monochrom> GHC experts agree. Go directly from Haskell to asm or llvm. Skip C.
11:36:29 <Welkin> forget assembly
11:36:35 <Welkin> program directly using a magnet and a steady hand
11:37:05 <Welkin> * may require nodejs to be installed *
11:37:33 <monochrom> I'm afraid a steady hand implies a stationary magnet implies no electric field implies defeating the whole point.
11:38:06 <monochrom> You need a deliberately shaky hand to generate an electric field!
11:38:07 <Welkin> the storage device is electrified
11:38:48 <gobby> is there a way to specify an os build target  in cabal? eg "x86_debian"?
11:38:59 <monochrom> But the storage device is SSD.
11:39:31 <solonarv> gobby: I *think* you do that by using a different compiler and/or passing some flags to GHC (both of which are things you can specify via cabal)
11:39:47 <solonarv> but also note that cross compiling Haskell is generally a bit shaky
11:40:40 <gobby> im currenrly using nix to cross compile and got this error: mycbl.cabal was modified manually, please use --force to overwrite.
11:40:55 <gobby> solonarv: currently*
11:41:21 <solonarv> ah, looks like maybe something computed some info based on the cabal file and now that you've modified it it's complaining
11:41:34 <solonarv> I don't really know much about nix though, so I don't think I can help youthere
11:43:13 <Welkin> silly hobbit, nix is for kids!
11:43:21 <cocreature> iirc that error comes from stack if you have a package.yaml and you modify the autogenerated cabal file
11:43:27 <cocreature> ^ gobby 
11:43:39 <gobby> cocreature: I forgot about this!
11:43:44 <gobby> cocreature: Thanks :)
11:49:34 <gobby> if I remove the package.yaml file I need to use a cabal.project file correcT?
11:50:13 <cocreature> gobby: no stack is perfectly happy reading your *.cabal file
11:50:37 <Welkin> dump stack, simplify your life
11:50:39 <Welkin> just use cabal
11:50:56 <Welkin> all you need is a .cabal file
11:51:04 <Welkin> cabal.project is for special settings
11:51:34 <solonarv> cabal.project is very roughly analogous to stack.yaml
11:52:57 <solonarv> you can use it to specify which compiler to use, where to find dependencies (including local folders, git, ...), flags for dependencies...
11:53:25 <geekosaur> stack uses package.yaml to write out a *.cabal file
11:54:15 <solonarv> yes - package.yaml is just blah.cabal in a patchy trenchcoat
11:55:57 <alx741> Welkin: I've been using stack without really thinking about it, what would be lost if I stop using it? cabal hell?
11:56:07 <Welkin> alx741: cabal hell hasn't been a thing for years
11:56:26 <Welkin> cabal init && cabal new-build
11:56:28 <Welkin> and it just works
11:56:36 <Welkin> cabal uses nix-style builds these days
11:56:53 <solonarv> yep, stick to the new-* commands and there will be no cabal hell for you
11:57:17 <solonarv> they will become the default with cabal 3.0, which is Soon(TM)
11:57:39 <hyperisco> I wish I owned that trademark. Would have made a lot of money in royalties by now.
11:57:50 <alx741> I did't really expirienced it, been using haskell only two years I think (only with stack), how did cabal hell got fixed?
11:57:59 <solonarv> I think Valve got to it first :P
11:58:03 <Welkin> alx741: nix-style builds
11:58:15 <Welkin> cabal hell was not common anyway
11:58:19 <Welkin> we used to use sandboxes
11:58:42 <jonh> are they not needed anymore?
11:58:51 <solonarv> alx741: the reason for cabal hell was that you cannot have multiple copies of the same package-and-version installed but with different versions of their dependencies
11:58:54 <Welkin> not with new cabal
11:59:27 <solonarv> cabal's nix-style builds use a hash of the dependencies' versions and flags to keep things properly separated
11:59:28 <alx741> oh! anything else I would be dropping if I stop using stack?
11:59:37 <Welkin> and by "new", I mean it's been out for almost 2 years now (?)
11:59:57 <solonarv> hm, not really
12:00:07 <alx741> Nice, will give that a go
12:00:12 <solonarv> I certainly can't think of anything I'm missing
12:00:27 <solonarv> for installing ghc+cabal I recommend ghcup if you are on linux/osx
12:00:40 <solonarv> or chocolatey if you are on windows
12:00:48 <hyperisco> How is having multiple versions of the same package in use possible anyhow?
12:01:12 <solonarv> not in use by the same package, no - we don't do that in the haskell ecosystem
12:01:13 <Welkin> solonarv always has to be a rebel and use windows
12:01:22 <solonarv> but installed? yes!
12:01:37 <dmwit> hyperisco: nix-style builds don't do that. But it *is* supported by GHC, and works by just versioning all the symbol names.
12:02:21 <solonarv> Welkin: actually I finally set up my desktop PC, which has linux (mint) on it
12:02:28 <dmwit> (old-style builds would occasionally do that, in fact.)
12:02:50 <hyperisco> Packages can reexport definitions, right? So if two packages export the same-name definition from two versions of the same-name dependency, what then?
12:02:59 <jonh> when ppl normally install these nice haskell tools like say hakyll, do they install them with cabal new-install ?
12:03:06 <solonarv> sometimes!
12:03:07 <alx741> solonarv: would ghcup be better than using arch's packages? in terms of cabal-install/ghc versions matching
12:03:12 <dmwit> hyperisco: Like I said: under the hood the symbol names are versioned.
12:03:16 <solonarv> alx741: yes, I think so
12:03:43 <solonarv> this *especially* applies to arch's packages, but in general I would not use distro packages
12:03:44 <hyperisco> Fine, but when I write my program… it is going to matter where I import the definition from?
12:03:45 <Welkin> which hood?
12:03:53 <dmwit> hyperisco: Correct.
12:04:01 <solonarv> hyperisco: you can use PackageImports to say which one you want, I think
12:04:12 <solonarv> import "bytestring" Blah
12:04:15 <cocreature> PackageImports are based on the name not the package id, right?
12:04:20 <alx741> I remember have played with sandboxes, but never really used them. Are the still relevant with cabal new-*? 
12:04:26 <cocreature> so if I have the same package with two versions that’s not going to help.
12:04:31 <solonarv> I don't remember if you can specify a hash or version with PackageImports, though
12:04:32 <Welkin> alx741: no
12:04:37 <dmwit> With PackageImports you can specify the package name and version.
12:04:38 <solonarv> no need for sandboxes
12:04:40 <hyperisco> Has the world given up on the idea of version numbers meaning anything in regards to compatibility?
12:04:45 <alx741> fantastic, thanks!
12:04:48 <Welkin> unless you like to build sandcastles
12:04:56 <dmwit> I don't think you can specify the hash, but GHC doesn't support linking two different hashes of the same-package-same-version currently anyway, as far as I know.
12:05:19 <dmwit> hyperisco: No. What makes you think it has?
12:05:50 <cocreature> dmwit: hm are you sure about the version? https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=packageimport#extension-PackageImports doesn’t mention it
12:06:07 <solonarv> alx741: the nice thing about nix-style is that it will actually share work properly, instead of reusing too much (old-style without sandboxes, cabal hell) or too little (sandboxes)
12:06:38 <dmwit> cocreature: ...no I am not sure.
12:06:59 <hyperisco> dmwit, if versions become part of the package name, then what is left semantically for version numbers?
12:07:26 <yushyin> alx741: I'm on arch and I don't use any arch haskell packages for dev-stuff
12:07:43 <dmwit> hyperisco: Dependency resolution, which attempts to not pick multiple versions of a package if that's possible.
12:08:06 <hyperisco> Okay, so it hasn't gone fully the route of package sets
12:08:13 <alx741> solonarv: ah! yes I remember that was some of the reasons why I just picked up stack, nice to know cabal handles that now
12:08:17 <solonarv> alx741: if you have two projects which need bytestring-0.10.8.2 with the same flags and versions of its dependencies, then both projects will indeed use the same build products
12:08:27 <solonarv> stack IIRC does a bit too much rebuilding
12:08:28 <alx741> yushyin: just haskellup
12:08:44 <solonarv> @where ghcup
12:08:44 <lambdabot> https://www.haskell.org/ghcup/
12:08:49 <solonarv> ^ there's a link btw
12:08:50 <alx741> yushyin: aren't there any conflicts with other packages that pull haskell stuff?
12:08:56 <solonarv> nah
12:09:08 <solonarv> ghcup and the stuff it installs just live in your home directory
12:09:15 <alx741> kkkkkkkkkk
12:09:26 <alx741> argh, sorry
12:09:34 <cocreature> dmwit: looks like https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/packages.html#package-thinning-and-renaming does allow you to specify versions so I guess you could use that to rename modules
12:09:35 <yushyin> same for stack (which I use)
12:09:35 <alx741> s/haskellup/ghcup 
12:09:38 <solonarv> ~/.ghcup and ~/.cabal by default, I think
12:09:53 <solonarv> yeah, our build tools are nice like that
12:10:20 <alx741> neat
12:11:40 <hyperisco> dmwit, I have been using a three-numbered system x.y.z where a change in z does not change the binary, a change in y does not functionally change definitions or remove symbols, and a change in x is for any backwards incompatible change
12:11:55 <hyperisco> Not sure what cabal is doing, but that is the sort of versioning semantics I am referring to.
12:12:04 <yushyin> alx741: sometimes I need different ghc versions, that won't work with arch's packages anyway
12:12:15 <solonarv> the default versioning scheme in our ecosystem is the PVP
12:12:25 <solonarv> @where pvp
12:12:25 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
12:12:33 <solonarv> er, wrong link
12:12:42 <solonarv> https://pvp.haskell.org
12:12:51 <solonarv> @where+ pvp https://pvp.haskell.org/
12:12:51 <lambdabot> Good to know.
12:19:32 <hyperisco> Alright, so I read half, and it looks like A and B could have been just A.
12:19:43 <hyperisco> Therefore, the reason they're distinct must be in the other half.
12:20:53 <python476> hi guys
12:21:06 <python476> I was wondering, you probably know about the cormen algo book
12:21:29 <vaibhavsagar> CLRS?
12:21:39 <python476> yeah this one
12:21:55 <python476> is there a similar one for FP problem solving ?
12:22:11 <vaibhavsagar> cool, I've seen it before
12:22:18 <vaibhavsagar> what about it?
12:22:28 <python476> is there a similar one for FP problem solving ? <= 
12:22:30 <vaibhavsagar> hmm
12:22:50 <Welkin> CLRS, the expensive doorstop
12:22:51 <python476> even if not straight up Haskell or ML, but at least sharing FP principles (immutable data, emphasis on recursive proofs)
12:22:58 <Welkin> no
12:23:00 <python476> Welkin: is it overblown ?
12:23:10 <Welkin> get Purely Functional Data Structures by Chris Okasaki
12:23:14 <python476> oh of course
12:23:18 <Welkin> CLRS is the book no one reads, but everyone talks about
12:23:19 <vaibhavsagar> the closest thing we have is Okasaki's Purely Functional Data Structures
12:23:25 <python476> should have thought about it ... #facepalm
12:23:26 <Welkin> if you are into super academic CS, fine
12:23:40 <Welkin> it's not a programming book
12:23:47 <vaibhavsagar> and 30 years of FP papers
12:24:04 <python476> Welkin: yeah I'm trying to get strong in algorithmic thinking not programming
12:24:07 <vaibhavsagar> Welkin: some of us are very much into super academic CS :)
12:24:18 <python476> vaibhavsagar: good point, I should collect ICFP and FP journals
12:24:38 <python476> I already have a large stack but it was more about interpreters 
12:24:50 <vaibhavsagar> python476: I recommend the functional pearls
12:24:57 <python476> ok
12:25:23 <python476> if someone here is inspired into making a FP counterpart to CLRS/Sedgewick, you'll have a fan :D
12:26:22 <cocreature> there is also Bird’s pearls of functional algorithm design
12:26:22 <vaibhavsagar> python476: those algorithms are still useful
12:28:00 <python476> cocreature: isn't it the same suggestion as vaibhavsagar just above ?
12:28:06 <python476> no offense, just asking to be sure
12:28:41 <python476> also, correct me if I'm wrong, but haskell has a tendency to lean on CT, are there new way of solving problems in this paradigm ?
12:28:48 <python476> adjunctions and all that 
12:28:57 <vaibhavsagar> no, it's a different book
12:29:03 <python476> ok, thanks
12:29:14 <python476> I remember Gershom Bazerman mentioning this in an old conf
12:30:59 <vaibhavsagar> python476: if you're interested in CT I would recommend https://github.com/hmemcpy/milewski-ctfp-pdf
12:31:15 <ski> @where FoP
12:31:15 <lambdabot> "The Fun of Programming" edited by Jeremy Gibbons,Oege de Moor in 2003-03-27 at <https://www.cs.ox.ac.uk/publications/books/fop/>
12:31:16 <cocreature> python476: not quite, the functional pearls are short papers that describe an individual algorithm. pearls of functional algorithm design is a book based on some of those papers but it goes beyond them and is written in a “book style” rather than a “paper style”
12:31:18 <ski> @where PFAD
12:31:18 <lambdabot> "Pearls of Functional Algorithm Design" by Richard Bird in in 2010-09 at <https://www.cs.ox.ac.uk/news/237-full.html>
12:31:42 <python476> oh ok thanks, all clear now
12:31:50 <python476> #haskell, lovely, as usual
12:32:07 <python476> btw, do you work with haskell as first language ? 
12:32:19 <Athas> Is there a guide to building static executables with cabal?
12:33:47 <Welkin> just run cabal new-build
12:34:31 <Athas> Doesn't that produce a dynamic executable?
12:34:48 <Welkin> dynamic in what way?
12:35:03 <Welkin> all your haskell dependencies are there
12:35:12 <Welkin> if you mean outside dependencies, then maybe
12:35:30 <sm[m]> static executables are default I think
12:35:39 <cocreature> Athas: https://github.com/nh2/static-haskell-nix is one of the better options ime
12:35:49 <sm[m]> more precisely, mostly static
12:35:58 <cocreature> if you mean fully static binaries, i.e., also link glibc and whatever statically
12:36:10 <Athas> I mean static, not partly-static.  As in, 'ldd' complains that it's not a dynamic executable.
12:36:15 <Athas> cocreature: thanks, that looks useful.
12:36:49 <sm[m]> nice
12:39:57 <Athas> I'm also trying out https://github.com/nh2/static-haskell-nix, but it seems quite fragile.
12:44:30 <solrize> if i wanted to write a straightforward compiler for a c-like language, is haskell an easy choice (yes! haskell can do that!) or should i consider something like idris?
12:45:13 <hyperisco> yes! haskell can do that!
12:45:13 <Welkin> use ook
12:45:25 <solrize> the idea of idris being to reflect the object language's types into the compiler's types
12:45:25 <Athas> solrize: Haskell is a way easier choice than Idris.
12:46:03 <solrize> i get into knots of existential wrappers and stuff when i try to use gadt's.... maybe it's even worse with idris
12:46:10 <solrize> Welkin, what's ook?
12:46:18 <geekosaur> nix is quite fragile once you step outside of canned recipes. haskell seems especially good at breaking it, but I may be biased by most nix I see being haskell related
12:46:29 <sm[m]> static-haskell-nix looks like a great initiative.. a few more opencollective backers will get them a CI machine
12:46:32 <Welkin> http://www.dangermouse.net/esoteric/ook.html
12:46:38 <sm[m]> perhaps leading to all haskell in nix-pkgs being fully static ? Anyway, sounds like that's the goal
12:46:59 <solrize> also what's the simplest way to upgrade my stack installation to the current gcc?  i think i'm 8.2 or something like that
12:47:19 <geekosaur> gcc, or ghc?
12:47:28 <geekosaur> if ghc, you need to specify a more recent resolver
12:48:05 <solrize> oops ghc
12:48:11 <dmj`> why doesn't Bool use the same Storable instance as CBool 
12:48:13 <solrize> yeah those version numbers overlap :)
12:48:57 <solrize> running stack setup
12:49:17 <solrize> 8.0.2, hmm
12:50:40 <dmj`> anybody know?
12:50:42 <solrize> hmm stack --resolver
12:51:25 <sm[m]> solrize: the resolve is usually specified by ./stack.yaml or ~/.stack/global-project/stack.yaml
12:51:28 <sm[m]> resolver
12:52:07 <Athas> cocreature: actually, I have no idea how to use the link you sent me.  Under "Building arbitrary packages", I'm pointed to a .nix file that contains something I don't understand, and instructions on how to statically build things that are already in nixpkgs.
12:52:50 <solrize> wyeah i found the .yaml, it was set to lts 9.2.  what is the current lts?
12:53:41 <solrize> ah 13.26
12:53:43 <solrize> setting to that
12:53:56 <solrize> stack build
12:54:17 <solrize> seems to be working, thanks!!
12:55:50 <solrize> had to re-run stack init then did stack build again, it didn't seem to do much but it finished
12:56:45 <sm[m]> np
12:57:03 <solrize> i remember when i first installed it downloaded a huge amount of stuff and compiled for an hour or so
12:57:16 <solrize> so i feel like i'm surely missing stuff
13:01:26 <solrize> yeah cabal wasn't there, re-installing it, 10000's of files
13:03:10 <sm[m]> stack/cabal will tend to re-use installed packages if they can (the output should say)
13:04:27 <solrize> it ran around 30 sec then said i probably wanted Cabal instead of cabal.  installing Cabal now and it's d/ling and compiling a lot
13:04:34 <solrize> i figure most of my hackage libs were probably out of date
13:04:55 <solrize> wonder if there's a -j option to use all my cores for compiling
13:05:01 <solrize> it's just using 1 right now and taking a while
13:05:47 <dmj`> why is Bool the black sheep of Storable instances
13:05:56 <solrize> what is Storable ?
13:06:21 <solrize> bool is a black sheep with c++ vector<bool> because it wants to be represented as a bit map
13:06:35 <solrize> which messes up the default implementations
13:07:08 <dmj`> solrize: it's a class for marshalling haskell types 
13:07:12 <dmj`> http://hackage.haskell.org/package/base-4.12.0.0/docs/Foreign-Storable.html
13:07:44 <solrize> aha, there ws some other thing for that a while back... anyway i wonder if it's because it wants to represent bool as 1 bit
13:07:46 <solrize> if it does
13:07:58 <dmj`> All other regular numeric types have parity between haskell and C regarding size, but not Bool, it has to do its own thing
13:08:13 <sm[m]> solrize: I think it'll automatically use all cores but sometimes package deps prevent it (one pkg is a bottleneck in the build plan)
13:08:48 <sm[m]> tip: use latest stack, you'll feel you're making more progress
13:09:21 <solrize> anyway it finished, it installed/compiled 220 packages 
13:09:30 <solrize> i think i'm using latest stack, 2.1.1
13:09:39 <ClaudiusMaximus> dmj`: Bool maps to C's HsBool defined by the haskell ffi header, CBool maps to C's bool (from stdbool.h, i think it might be a typedef for _Boolean or something funky)
13:10:04 <solrize> emacs interactive haskell mode is busted :(
13:11:56 <wayne> hi, is there a pointfree way to write this w/out an anonymous fn? let f a = a^2 + a^4
13:12:14 <wayne> in j i can do it like this: ((^&2)+(^&4)) a
13:12:21 <hyperisco> Do we have function Nums?
13:12:35 <hyperisco> > ((^2) + (^4)) 2
13:12:37 <lambdabot>  error:
13:12:37 <lambdabot>      • No instance for (Num (Integer -> Integer))
13:12:37 <lambdabot>          arising from a use of ‘e_1242’
13:12:57 <Rembane> > uncurry (+) . ((^2) *** (^4))
13:12:59 <solrize> you can't add functions together
13:13:00 <lambdabot>  <(Integer,Integer) -> Integer>
13:13:00 <hyperisco> What is j?
13:13:08 <Rembane> hyperisco: ASCII APL
13:13:13 <wayne> ^ jsoftware.com
13:13:28 <Rembane> > uncurry (+) . ((^2) *** (^4)) (5,4)
13:13:30 <lambdabot>  error:
13:13:30 <lambdabot>      • Couldn't match type ‘(Integer, Integer)’ with ‘a -> (c, c)’
13:13:30 <lambdabot>        Expected type: (Integer, Integer) -> a -> (c, c)
13:13:36 <hyperisco> solrize, would be nice though wouldn't it
13:13:40 <Rembane> :t uncurry (+) . ((^2) *** (^4)) 
13:13:41 <lambdabot> Num c => (c, c) -> c
13:14:04 <Rembane> > (uncurry (+) . ((^2) *** (^4))) (5,4)
13:14:07 <lambdabot>  281
13:14:20 <Rembane> wayne: The last line I wrote.
13:14:29 <wayne> thank you!
13:14:31 <hyperisco> > (lift2 (+) (^2) (^4)) 2
13:14:33 <lambdabot>  error:
13:14:33 <lambdabot>      • Variable not in scope:
13:14:33 <lambdabot>          lift2
13:14:39 <hyperisco> > (liftA2 (+) (^2) (^4)) 2
13:14:42 <lambdabot>  20
13:15:20 <Rembane> As usual there are more reasonable ways to do things than with arrows. :D
13:15:32 <hyperisco> @pl \a -> a^2 + a^4
13:15:32 <lambdabot> liftM2 (+) (^ 2) (^ 4)
13:15:43 <hyperisco> hey we agree for once
13:16:38 <solrize> that uses the monad instance for (->)  ?  i've never understood that
13:16:49 * geekosaur whispers Num instance for Applicativs
13:16:55 <geekosaur> *Applicatives
13:18:35 <solrize> https://github.com/haskell/haskell-mode/issues/1496  ugh
13:21:33 <dmj`> ClaudiusMaximus: it would be nice if there was a way to use the Storable for CBool for Bool
13:21:48 <dmj`> When designing APIs people expect to see a Bool but not a CBool
13:25:16 <solrize> i think i see a performance regression since 8.0.2.... one of my benchmarks is about 2x slower
13:26:29 <hjt> just got haskell-ide-engine working and it's so so lovely
13:26:33 <hyperisco> geekosaur, that's even more dastardly than Num for (->)
13:31:49 <hyperisco> Ah ha, with foldApp you can do  sumOf <$> f1 <*> f2 … <*> fn
13:32:14 <hyperisco> or stick in your favourite lift
13:33:23 <hyperisco> https://hackage.haskell.org/package/data-foldapp-0.1.1.0/docs/Data-FoldApp-Function.html#v:sumOf  hash tag shameless
13:44:11 <gobby> I'm building a haskell package with nix, I had to override the `base` package with a specific version and I
13:44:27 <gobby> I'm getting "annonymous function at .. called without required argument 'invalid-cabal-flag-settings"
13:44:55 <gobby> anybody with nix experience knows what flags I need to put?
13:45:04 <gobby> cabal/nix*
13:46:37 <hyperisco> The only help I can provide comes from my uneducated experience solving flag problems. And that is to binary search through the set of flags to identify the one which does the thing I need.
13:47:03 <gobby> hyperisco: I think I found what I need
13:47:23 <dmwit> hyperisco: Nope, A and B aren't distinct according to the PVP. It's up to the package author what distinction they want to draw with A and B, if any.
13:47:25 <hyperisco> If one flag undoes another nonobviously, this doesn't work so well.
13:47:26 <gobby> I found the base.cabal file and I'll try to feed that into my nix derivation
13:47:53 <Lears> Nix or not, trying to override base is a pretty bad idea. Use the right GHC and you'll get the right base.
13:48:42 <dmwit> :t ap (+) (^2)
13:48:44 <lambdabot> Num a => a -> a
13:51:00 <dmwit> > (ap (+) >>= fmap) (^2) 2
13:51:02 <lambdabot>  20
13:51:40 <dmwit> > (ap (+) >>= fmap) (^2) x
13:51:43 <lambdabot>  x * x + x * x * (x * x)
13:52:31 <hyperisco> @pl \x -> x * x + x * x * (x * x)
13:52:31 <lambdabot> ap ((+) . join (*)) (ap ((*) . join (*)) (join (*)))
13:52:46 <dmwit> ?pl \x -> x^2 + x^4
13:52:46 <lambdabot> liftM2 (+) (^ 2) (^ 4)
13:53:12 <hyperisco> QED, pl doesn't find the shortest pointfree expression. (This came up another day)
13:53:16 <dmwit> (But mine shares the result of x^2 with the calculation of x^4!)
13:54:32 <dmwit> `liftM2 (+) (^2) (^4)` and `ap ((+) . join (*)) (...)` in ?pl's equational theory.
13:54:41 <dmwit> `liftM2 (+) (^2) (^4)` and `ap ((+) . join (*)) (...)` aren't equal in ?pl's equational theory.
13:54:58 <dmwit> (It doesn't "look through" the (^) to see the (*)s inside.)
13:54:59 <hyperisco> I wasn't comparing it to that. I was comparing it to yours :P
13:55:18 <dmwit> > length "liftM2 (+) (^2) (^4)"
13:55:21 <lambdabot>  20
13:55:27 <dmwit> > length "(ap (+) >>= fmap) (^2)"
13:55:30 <lambdabot>  22
13:55:34 <hyperisco> No… still not what I was comparing lol
13:56:06 <dmwit> '(ap (+) >>= fmap) (^2)` and `ap ((+) . join (*)) (...)` aren't equal in ?pl's equational theory.
13:56:29 <dmwit> Probably `liftM2 (+) (^2) (^4)` isn't equal to mine, either.
13:57:02 <dmwit> You need to know facts about (^) that aren't generally true for all instances to invent mine.
13:57:25 <hyperisco> So does pl find the shortest expression?
13:57:30 <dmwit> Probably not.
13:57:37 <dmwit> But this isn't evidence of that fact.
13:57:47 <geekosaur> define shortest expression
13:58:12 <geekosaur> pl knows how to simplify some combinators. it does not, for example, know math operations can be done in different ways
13:58:20 <hyperisco> if we just replace (^2) with join (*) what do we get?
13:58:26 <dmwit> Well... it knows some facts about math operators.
13:58:29 <dmwit> ?pl \x y -> y*x
13:58:30 <lambdabot> (*)
13:58:55 <hyperisco> > (ap (+) >>= fmap) (join (*)) x
13:58:57 <lambdabot>  x * x + x * x * (x * x)
13:59:07 <hyperisco> so it is the same thing
13:59:32 <hyperisco> pl could have found it, and didn't
13:59:39 <dmwit> Great! This one is probably good evidence.
14:00:52 <hyperisco> Now to golf the evidence :P
14:08:46 <dmwit> > join (join (*)) x
14:08:49 <lambdabot>  error:
14:08:49 <lambdabot>      • Couldn't match type ‘Expr’ with ‘Expr -> t’
14:08:49 <lambdabot>        Expected type: Expr -> Expr -> Expr -> t
14:09:03 <dmwit> > join (.) (join (*)) x
14:09:06 <lambdabot>  x * x * (x * x)
14:09:13 <dmwit> ?pl \x -> x * x * (x * x)
14:09:13 <lambdabot> ap ((*) . join (*)) (join (*))
14:09:24 <solonarv> solrize: liftA2 (+) f g = \x -> f x + g x
14:10:13 <dmwit> > (length "join(.)(join(*))", length "ap((*).join(*))(join(*))")
14:10:15 <lambdabot>  (16,24)
14:12:23 <hyperisco> We should measure on expression size rather than character length
14:20:24 <solrize> where is liftA2?
14:20:29 <solrize> it's not in control.arrow
14:20:38 <solrize> @hoogle liftA2
14:20:39 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
14:20:39 <lambdabot> Protolude liftA2 :: Applicative f => a -> b -> c -> f a -> f b -> f c
14:20:39 <lambdabot> Diagrams.Prelude liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
14:20:43 <geekosaur> Control.Applicative
14:20:47 <solrize> ah thx
14:20:50 <geekosaur> it's not an arrow function
14:20:58 <solrize> yeah that makes sense
14:21:08 <Welkin> I see the easter egg here!
14:21:09 <Welkin> https://www.haskell.org/tutorial/arrays.html
14:21:30 <Welkin> I can tell the author really likes Jeniffer Lopez
14:21:37 <solrize> > liftA2 (+) (^2) (^3) 2 3
14:21:39 <lambdabot>  error:
14:21:39 <lambdabot>      • Could not deduce (Num t0)
14:21:39 <lambdabot>        from the context: (Num (t -> t1), Num t)
14:21:56 <Welkin> Jennifer*
14:22:06 <Welkin> does anyone pronounce that "yennifer"?
14:22:36 <Welkin> I always laugh when I hear someone pronounce gigabyte as "jigabyte"
14:22:54 <Welkin> mostly spanish speakers, like my friends or the people from Blender
14:23:07 <solrize> 1.21 jiggawatts
14:23:36 <solrize> i met a guy last night who said his name was gabe, but that it was ok with him if i called him "jabe" as long as i also said jiggabytes
14:25:38 <python476> Welkin: j ~ d'~g
14:38:21 <dmj`> > sizeOf (undefined :: Bool)
14:38:24 <lambdabot>  4
14:38:28 <dmj`> what a waste
14:38:52 <hpc> i agree
14:38:53 <dmj`> 3 extra bytes... really
14:38:53 <glguy> Yeah, what's C's deal??
14:38:54 <hpc> it should be 1/8
14:39:28 <jle`> 3.875 extra bytes :'(
14:39:31 <dmj`> > sizeOf (undefined :: CBool)
14:39:34 <lambdabot>  error:
14:39:34 <lambdabot>      Not in scope: type constructor or class ‘CBool’
14:39:34 <lambdabot>      Perhaps you meant ‘Bool’ (imported from Data.Bool)
14:39:41 <glguy> Welkin: Have you played Witcher 3 (regarding Yennifer)
14:40:00 <Welkin> oh yeah
14:40:08 <dmj`> >>> sizeOf (undefined :: CBool)
14:40:08 <dmj`> 1
14:40:09 <jle`> although i guess we do need all four bytes in order to represent a lazy bool
14:40:13 <Welkin> I stopped playing because I couldn't get past that Griffon
14:40:19 <jle`> s/lazy/boxed
14:40:27 <glguy> sizeOf tells us the C representation size
14:40:34 <Welkin> griffin*
14:40:35 <jle`> D:
14:40:35 <glguy> Nothing to do with Haskell values
14:40:50 <dmj`> glguy: that's what I'd like :) all other Storable's in Haskell are at parity with C for numeric types it seems
14:41:04 <dmj`> in regards to size
14:41:25 <jle`> what does the ffi do with the other 3.785 bytes then
14:41:34 <jle`> just leave them as undefined?
14:41:39 <glguy> C uses int for boolean things
14:43:21 <glguy> int main(void) { printf("%zu\n", sizeof(1==0)); }
14:43:21 <glguy> 4
14:44:29 <dmj`> well, the storable for Bool is giving me strange results when I call into this C api, that magically go away when I use CBool
14:44:36 <jle`> i wonder if in a CPU with fast bit-level operations, TRUE = 1 would be inefficient
14:45:19 <jle`> since we could just only ever look at the LSB, and so we could just allocate memory and only flip the last bit
14:45:53 <dmj`> why would the Storable for CBool show size of 1 if in C it shows 4
14:46:09 <glguy> No, bool in C is something else
14:46:36 <glguy> C uses int for boolean stuff and C99 also provides a small bool type you can use
14:47:08 <Welkin> bool is the same as int in C I  thought
14:47:14 <Welkin> same size
14:47:57 <glguy> No, C99's _Bool has size 1
14:48:16 <glguy> That's the thing stdbool.h aliases to bool
14:48:56 <dmj`> So CBool exists solely to support that type ? this C API is definitely using that small bool
14:49:19 <dmj`> Guess I'm keeping everything CBool then
14:49:21 <glguy> CBool: Haskell type representing the C bool type.
14:50:41 <dmj`> that's what I've been using, but its not as convenient to work with as Bool, but the Storable for Bool is based on Int, therein lies the frustration
14:51:14 <glguy> It doesn't really matter so much what's convenient; you have to pick the type that matches the CApi
14:51:45 <Welkin> keeping it CBool
14:51:46 <Welkin> haha
14:52:03 <dmj`> I'm almost tempted to make my own Bool type that is a sum type, that has a proper Storable instance (for c99). But then the API would look like a joke because I defined my own Bool type
14:52:16 <Welkin> make your own Bool that is one bit
14:52:17 <Welkin> :D
14:52:46 <dmj`> I want to just use the Bool that Prelude exports, but use the Storable based on CBool
14:54:18 <dmj`> I can't define my own instance and overlap it,  could use an associate type family, but then it kind of muddies the API with "well what does this type family resolve to", onus is on the user to figure that out
14:54:36 <dmj`> CBool it is
14:55:34 <Welkin> that's out new word
14:55:36 <Welkin> CBool
14:56:09 <dmj`> CBool is the new Bool
14:56:31 <Welkin> that so CBool
14:56:38 <dmj`> CBool you later
14:57:21 * ski . o O ( <https://en.wikipedia.org/wiki/Bol_loop> )
15:15:47 <dmj`> have an idea, when I get back the `Ptr CBool`, I'll mallocBytes a new `Ptr Bool` of the same length (just different size) and then just peek from one and poke into the other,  performing the conversion toEnum . fromIntegral in between
15:16:54 <dmj`> will need to unsafeCoerce to keep the API polymorphic
15:18:11 <dmj`> then pass that pointer to a storable vector
15:32:36 <dibblego> classy prism
16:06:05 <newbie_> hello does this signature look like a good idea ? rateLimitedApiCall :: (MonadReader (IORef RateLimit) m, MonadIO m, MonadThrow m) -> Request -> m (Response ByteString)
16:06:33 <newbie_> I am thinking more about how putting a IORef in a Reader is okay or not?
16:07:20 <jle`> putting an IORef in a reader is pretty common i think :)
16:07:50 <newbie_> but doesn't that mean i must have a IO somewhere in my transformer stack
16:10:51 <hpc> yes
16:10:53 <hpc> and that's fine too
16:14:50 <jle`> newbie_: you sort of already imply that with MonadIO m
16:16:22 <newbie_> jle`: yes that's why i was wondering if i need that MonadIO ?
16:16:38 <newbie_> i mean i kind of do
16:16:41 <jle`> whether or not you need it depends on what you do
16:16:59 <jle`> if you don't use it, then turning on -Wredundant-constraints will let you know if you don't need it
16:17:17 <jle`> i always turn it on :) even though it isn't included in -Wall
16:17:33 <newbie_> thanks
16:17:42 <newbie_> interesting how Wall doesn't mean all
16:18:13 <jle`> yeah, -Wall should be more like -Wusuallyreasonable
16:18:46 <jle`> but yeah, if you add the constraint, but you don't actually need it in your final code, -Wredundant-constraints will let you know, so you can remove it
16:30:00 <sicklorkin> does cse convert things like "x = 3*3" to x = 9 or "slen = length "XXX"" to slen = 3; 
16:30:21 <jle`> that would be constant folding, i think, not cse
16:30:26 <sicklorkin> jle`: thanks
16:30:39 <hpc> for other things, like say
16:30:45 <hpc> f x = x ** 10 + x ** 10
16:30:57 <hpc> it's going to do the exponentiation twice
16:31:24 <hpc> it behaves like other languages, if you don't want something recomputed give it a name and keep it in scope
16:31:32 <jle`> sicklorkin: i'm assuming you are asking a question about implementing a compiler, and not about ghc.  ghc doesn't really do cse
16:35:27 <sicklorkin> jle`: I'm parsing a bunch of JSON and my fields are prefixed with the data ctr name and am wondering what the costs is of say fieldLabelModifer = drop . length "foo" vs just `drop 3`..
16:36:07 <sicklorkin> i havnt' looked at the core yet, so i have zero idea how this actually works under the hood
16:42:53 <jle`> if you are worried about performance, i don't think there is any way to get around just benchmarking
16:44:09 <sicklorkin> jle`: yes, ofc. that's the plan.. 
16:48:58 <sicklorkin> hpc: thanks!
16:51:19 <solonarv> you can also try looking at intermediate representations and inspect them
16:52:06 <solonarv> -ddump-simpl for example makes GHC output Core after the Core-to-Core optimization passes have run
16:52:38 <solonarv> something like (length "foo") might well turn into 3, there is some compile-time evaluation happening
16:53:02 <solonarv> inlining, beta reduction, and case-of-known-constructor are the optimizer passes driving it
16:56:49 <solonarv> for the following code: fieldLabelModifier = drop (length "foo")
16:56:58 <solonarv> length "foo" does not get compiled to 3
16:57:17 <solonarv> however it does get floated out as a top-level thunk, so it will only be calculated once
16:57:50 <solonarv> so it should not really impact json parsing speeds much
16:57:57 <lavalike> does -On change that
16:58:06 <solonarv> I ran with -O2 already
16:59:38 <solonarv> if I write 'fieldLabelModifier2 = drop 3' I just get a top-level closure representing this 3
16:59:56 <solonarv> so I think after the first call they should be equivalent
17:07:58 <sicklorkin> solonarv: thank you!
17:08:10 <sicklorkin> solonarv: +1
17:14:25 <solonarv> sicklorkin: oh, if you're doing this yourself you probably also want -dsuppress-all to make the output more readable
17:15:00 <solonarv> and -ddump-to-file might be a good idea: -ddump-simpl with -O1 and especially -O2 can get pretty big
17:15:17 <sicklorkin> understood
18:01:53 <olligobber> @pl \x y -> do { a <- x; b <- y; if a == b then Just a else Nothing }
18:01:53 <lambdabot> (line 1, column 12):
18:01:54 <lambdabot> unexpected '{'
18:01:54 <lambdabot> expecting variable, "(", operator or end of input
18:02:45 <olligobber> @pl \x y -> if x == y then x else Nothing
18:02:45 <lambdabot> flip flip Nothing . (flip =<< (if' .) . (==))
18:42:23 <jusss> type variables have the ability to do polymorphism, then why we need typeclass?
18:43:38 <Welkin> parametic vs adhoc polymorphism
18:43:41 <Welkin> totally different
18:43:52 <Welkin> also nothing at all like oop polymorphism
18:43:54 <Axman6> type classes let you know what you can do with those type variables. what's the difference between foo :: a -> String and bar :: Show a => a -> String?
18:44:18 <Welkin> type classes are for function overloading
18:44:28 <Welkin> describing interfaces
18:44:59 <Axman6> in the first one, I know _nothing about a, so I can guarantee there is nothing in that String that came ferom a. in the second, I know that there is a way to turn an a into a String, so there;s ia good chance that there is information from a in the returned string
18:48:50 <oats> Axman6: so could it be said that the first example is a "useless" function?
18:49:13 <oats> since there's nothing of a that produces String, there's no mapping, no transformation happing
18:49:24 <oats> I'm guessing it'd have to be a constant function
18:49:27 <Axman6> )yep
18:50:03 <oats> neat
18:50:07 <oats> this language is so damn cool
18:50:09 <jusss> or let's talk about the monad typeclass
18:51:29 <jusss> it seems to me like typeclass force the instance to implement its method
18:52:07 <jusss> >>= :: m a -> (a -> m b) -> m b
18:52:30 <jusss> in Maybe, >>= :: Maybe a -> (a -> Maybe b) -> Maybe b
18:53:55 <oats> I think maybe "force" isn't the most accurate way to think of it here
18:54:56 <jusss> oats: and what's the more specific word to express?
18:55:16 <oats> you're guaranteeing to the compiler that values provided to the function fit in a "constraint"
18:57:03 <oats> if you don't provide a typeclass constraint, as with your (>>=) Maybe example there, you won't be able to compute any function of `a` that has a more "restricted" constraint
18:57:13 <oats> and the compiler will enforce that
18:58:28 <oats> for example, if you tried to do `show a` as a part of that (>>=) implementation for some reason, the compiler will remind you that you haven't guarunteed that your `a` can be turned into a String (via the Show typeclass)
18:59:40 <oats> please let me know if that was unclear, I'm still new to haskell and trying to reason through some of this stuff too :)
19:00:07 <oats> does that answer your question?
19:00:37 <jusss> I don't know, I'm still fuzzy
19:00:55 <Welkin> hi fuzzy
19:01:08 <jusss> think about why we need a typeclass or interface in other languages
19:01:42 <Welkin> having a standard API is very useful
19:01:56 <Welkin> you don't need to know anything about how it's implemented for different data types
19:02:03 <Welkin> you can fmap over a list, a tree, a graph
19:02:13 <Welkin> your custom data structure too
19:02:37 <jusss> all I see is that typeclass can make its instances to implement its function
19:03:08 <oats> typeclasses describe shared behavior that multiple types can have
19:03:45 <oats> continuing the `Show` example, there's lots of things that can be turned into strings
19:04:13 <oats> Bools, Integers, lots of stuff
19:04:45 <koala_man> is "haskell-on-mac" the thing to install with brew these days?
19:04:58 <koala_man> I mean haskell-for-mac
19:05:57 <oats> so when we implement `Show Foobar` for some imaginary type `Foobar`, we're telling the compiler, “This is a thing that can be turned into a string, with this neat function I have, `show`!”
19:06:55 <jusss> oats: "<oats> typeclasses describe shared behavior that multiple types can have" this is good
19:07:09 <y-a-k-i-m[m]> .
19:07:22 <oats> jusss: I hope that was helpful :)
19:08:32 <oats> and so when we declare a function `bar :: Show a => a -> BarBaz`, we're telling the compiler that the type variable has a constraint on it, `Show a`, and so the compiler will hold us to our promise that whatever value we give to `bar` will be a thing that can be turned into a string
19:08:50 <jusss> oats: and do wee need to use typeclass frequently?
19:09:02 <jusss> create we own typeclass I mean
19:09:08 <oats> typeclasses cut down on function clutter :)
19:09:27 <oats> are you familiar with a language like C that doesn't have typeclasses or interfaces?
19:09:57 <jusss> oats: I don't know if python counts
19:10:08 <jusss> python have abstract method
19:10:27 <oats> I am unfortunately unfamiliar with python
19:10:38 <jusss> or javascript, scheme?
19:11:01 <oats> I think this stuff mostly only applies to statically-type languages
19:11:03 <jusss> scheme doesn't have typeclass also declared type, I think
19:11:07 <jusss> also OO
19:11:14 <oats> but, since there's no way to describe shared behavior among types in C, we have to create a separate function with a different name for every type we want to be able to string-ify
19:11:28 <oats> for example, intToString(), boolToString(),...
19:11:42 <jusss> what about the simple function id
19:11:55 <jusss> idInt :: Int -> Int
19:11:57 <oats> jusss: what about it?
19:12:01 <jusss> idStr :: String -> String
19:12:05 <oats> ah
19:12:11 <jusss> that's what you want to talk?
19:12:22 <jusss> and now we have id :: a -> a
19:12:28 <oats> yes, that is how you'd have to do it in C
19:12:38 <oats> (we will pretend pointers don't exist :))
19:12:53 <oats> pointers makes things super fuzzy!
19:13:12 <oats> jusss: do you understand why the `id` function works in haskell?
19:13:26 <jusss> but the point here is that id :: a->a is just type variables or call generics in other languages
19:14:02 <nitrix> Ironically, if you were to use pointers and cast them to `void *` to implement a `void *(void *, void *)` function, you'd be re-implementing what Haskell does by boxing types and its parametric polymorphism + newtype.
19:14:02 <jusss> oats: actually no, or I can ask you do you know why the `id` function shouldn't work in haskell?
19:14:08 <Welkin> id :: forall a. a -> a
19:14:30 <oats> ah, yes, the hidden forall!
19:14:59 <jusss> actually, I did notice that keyword forall, but I haven't see a article tell me what it is
19:15:26 <Welkin> there is an implicit forall in every type that contains all type variables
19:15:39 <nitrix> Universal quantification. `a` being a type variable, it has to come from somewhere. Something introduces `a`.
19:16:52 <nitrix> This becomes more important when you start nesting polymorphic type signatures, they have their own scopes (:
19:19:56 <nitrix> e.g. `forall a. a -> (forall b. b -> b) -> a`
19:20:36 <Welkin> that's existential quantification then, right?
19:20:41 <Welkin> for the b -> b
19:20:55 <nitrix> Yeah. Going towards Rank-2 and such.
19:21:30 <gobby> how do you send a binary to a cloud instance to avoid building the binary on the instance?
19:21:48 <Welkin> scp or rsync
19:21:50 <gobby> I'm getting permission issues as I cloned the entire package folder and I'm trying to run `stack exec`
19:21:57 <Welkin> don't build on the server
19:22:03 <Welkin> that will take forever or fail
19:22:17 <Welkin> unless you have a really powerful server with lots of memory
19:22:26 <Welkin> never build in production regardless
19:22:58 <gobby> I built offline and then copied my repo to the instance
19:23:09 <gobby> but I'm getting weird permission errors running `stack exec`
19:23:18 <gobby> while trying to fetch GHC
19:24:05 <Welkin> don't copy your repo
19:24:07 <Welkin> copy the binary
19:25:00 <gobby> where is the binary
19:25:36 <gobby> Welkin: found i
19:25:40 <gobby> it*
19:30:38 <gobby> I'm trying to just use my executable from a stack build, I have chmod +x it and have tried using sudo
19:30:42 <gobby> it keeps on saying command not available
19:31:40 <Welkin> can you run it locally?
19:31:48 <Welkin> ./binary-file
19:32:24 <Welkin> you may not have all the libraries installed depending on what is in it
19:32:34 <Welkin> c libraries*
19:32:41 <gobby> its a yesod app
19:33:07 <Welkin> your server needs to be set up properly
19:33:57 <Welkin> libpq-dev if you are using postgres
19:34:01 <Welkin> and others
19:34:38 <gobby> Welkin: got it to work locally, but you are right, I'll need to install the relevant dependencies 
19:42:44 <nitrix> Welkin, when you have rank-2 functions like `foo :: forall a. a -> (forall b. b -> b) -> a`, you have both universal and existential quantification at play. The rank-2 refers to how many nested incompatible quantifications that cannot merge (2 here). Now, from the perspective of the caller of `foo`, it has the ability to choose any type it wants for `a`, which we call universal quantification, but, once that's fixed, `foo` will then invoke the 
19:42:44 <nitrix> callback (forall b. b -> b) by choosing a type for `b`, which still from the perspective of the caller, appears to have been determined for him, which we call existential quantification.
19:44:53 <d34df00d> Given a fileystem path, how do I know if it's a file or a directory?
19:45:22 <d34df00d> My best  bet right now is System.Directory.doesFileExist to know if it's a file or not, but that's ugly.
19:48:59 <nitrix> Welkin: In english, that reads as "for all types `a`" (therefore I can chose _any_ type that I want) vs. "there exists a type `b`" (therefore I have to handle _one_ type, whatever it might be).
19:49:29 <nitrix> Unfortunately, Haskell uses `forall` to describe both, but the nesting makes it pretty obvious.
19:50:29 <gobby> Welkin: is there a way to figure out what dependencies I had to install when building my app/
19:51:00 <gobby> Welkin: as in install manually via `sudo apt install`
19:52:57 <nitrix> Welkin, now the interesting part, if you've followed, is that from the point of view of `foo`, `a` is existentially quantified because the caller has determined the type, while the callback appears universally quantified, we can choose what we want.
19:53:20 <nitrix> So they are inverses, depending if you're looking from the point of view of the caller vs. callee.
19:53:34 <monochrom> d34df00d: I think there is an "isDirectory"?
19:54:27 <d34df00d> monochrom: that's good, thanks!
19:55:17 <monochrom> Hrm it's "doesDirectoryExist"
19:56:47 <Welkin> gobby: I don't know, but you likely need to install libc, pglib-dev, and maybe others. The erorr messages should be helpful
19:57:49 <Welkin> nitrix: that's intuitive
19:58:11 <Welkin> it's a cool thought experiment
19:59:22 <nitrix> (:
19:59:24 <gobby> Welkin: Got it to run
20:38:43 <qwebirc25918> anyone having issues installing ghcup via the curl command in macos 10.12.6 ?
20:46:15 <yaaase> anyone having issues installing ghcup on macos?
20:47:50 <dmj`> nix-shell -p ghc --run ghci works great on Darwin for me
20:48:35 <dmj`> go from no ghc to a ghci session in 10 seconds flat
20:49:14 <monochrom> Yeah, no issues here, thanks for asking!
21:04:28 <janat08> Can't see the version of ghc, and installing leksah doesn't work with error ghc864 not found (its ide installed via .sh). 
21:04:33 <janat08> i installed stack
21:23:17 <yaaase> sorry should have googled more lol. I am up and running
21:24:07 <jle`> yaaase: i see what you did there :)
21:25:19 <yaaase> jle`: happily haskelling now :) (well actually unhappily rubying at work, soon to be golanging, but doing my best)
21:25:33 <dansho> is there a preferred haskell pastebin ? lpaste seems to be bone
21:25:34 <dansho> *gone
21:25:39 <jle`> ah, i was referring to your 'gchup' and 'up and running' pun
21:25:44 <yaaase> =P
21:25:52 <jle`> dansho: yeah, rip lpaste :'(
21:26:10 <jle`> a lot of us use github gists now i think
21:29:39 <dansho> is one of these ways preferred to prepend an element to a vector using the hmatrix library?: http://dpaste.com/22AB84W
21:32:26 <jle`> probably the first one is 'better', prepending to vectors is always icky
21:33:56 <jle`> specially with immutable vectors
21:37:49 <yaaase> meta-question but is it possible to suppress join/leave messages in webchat.freenote.net? 
21:38:22 <jackdk> does there exist a good guide to writing GHC 8.8/MonadFail-compatible code without breaking backwards compat? I can never tell what's current for a proposal, between wiki, trac, ...
21:39:07 <jle`> jackdk: hm, maybe turn on -Wcompat ?
21:40:47 <wrunt> does Control.Lens.TH's `makeWrapped` give me a way of using my newtype's record accessor name? E.g. if I have `newtype Address = Address { _unAddress :: Text }; $(makeWrapped ''Address)`, then I know I can use `someAddress ^. _Wrapped`, but can I use `someAddress ^. unAddress` without having to manually define `unAddress = _Wrapped`?
21:43:06 <Axman6> makeLenses would do that
21:45:48 <jle`> iirc makeLenses should also give a Wrapped instance too?
21:48:22 <wrunt> changing all my `makeWrapped` to `makeLenses` breaks all my uses of `_Wrapped`
21:48:40 <wrunt> I guess I just have to do both?
21:50:23 <yaaase> this is a longshot, but anyone know why the #xkcd channel on foonetic is invite-only and/or where I can get an invite. sorry for the unproductive contributions here tonight
21:51:37 <dmj`> is it not possible to change the size of an image in haddock
21:56:07 <dmj`> I can't embed html in haddock?
22:16:44 <jle`> wrunt: ah, i guess it doesn't make a Wrapped instance. you might ahve to do both, then
22:32:46 <zacts> is GHC fully implemented in Haskell?
22:34:38 <jle`> zacts: some of the RTS is written in C i believe
22:34:50 <zacts> Ok
22:35:42 <Lycurgus> in short, no, not even
22:36:18 <Lycurgus> crazy in concept in fact
22:36:36 <jusss>  data T = Either Int String;   f :: T -> T;   f x = x;   f (Left 3) got an error , why?
22:36:42 <Lycurgus> hs just isn't that kind of lang
22:37:09 <jle`> data T = Either Int String
22:37:11 <jle`> defines a new data type T
22:37:17 <zacts> Lycurgus:  I'm totally curious. Racket is interesting to me too.
22:37:17 <jle`> with a single data constructor, 'Either'
22:37:21 <jle`> that has two fields: an Int, and a String
22:37:30 <zacts> mainly in that you can implement multiple programming languages on it.
22:37:31 <jle`> so you could write something like f (Either 3 "hi")
22:37:56 <zacts> So I guess I kind of have an interest in compilers/interpreters. Although, I'm a complete beginner programmer basically.
22:38:00 <jusss> jle`: oh, my fault, I should use Either on the right side
22:38:06 <jusss> without a value constructor
22:38:19 <jle`> fwiw this is a pretty confusing data type constructor, because 'Either' is commonly used as a type name from Prelude
22:38:20 <jle`> so you could write:
22:38:25 <jle`> data T = MkT Int String
22:38:36 <zacts> so I was curious as to if Haskell could fully implement a compiler like that.
22:38:39 <jle`> then you could call f (MkT 3 "hi")
22:39:21 <jusss> jle`: I should just use f :: Either Int String -> Either Int String
22:39:43 <jle`> if that's what you want :)
22:39:58 <jle`> that'd be a very different type, yeah
22:40:15 <jle`> but the only person who really knows what you want is you, yourself. so search inside your heart :)
22:40:38 <zacts> how well suited _is_ Haskell for implementing a compiler/interpreter for a language? I think that Perl6 had an interpreter at one time in Haskell.
22:40:41 <jusss> jle`: I want the either type, 'cause I'm not sure which type the paramter is
22:40:54 <zacts> and please let me know if this is the proper channel to ask these GHC/Haskell questions too. :-)
22:41:08 <jusss>  ff :: (Either Int String) -> (Either Int String);  ff x = x;   ff (Left 3)
22:41:18 <jle`> zacts: implementing a compiler/interpreter is often cited as the "killer app" for haskell
22:41:31 <zacts> jle`:  oh cool
22:41:40 <zacts> wait, what do you mean by that exactly?
22:42:03 <jle`> for a long time if you were to ask someone what specific domain haskell is especially suitable for more than any other language, they'd probably say language/compiler implementations
22:42:11 <zacts> oh cool
22:42:13 <zacts> nice
22:42:54 <jle`> haskell's feature set seems uniquely aligned to implement a language/compiler, in an uncanny way
22:43:00 <zacts> why don't I see many compilers/interpreters in production using haskell?
22:43:35 <jle`> hm, pandoc, elm, idris, purescript, etc. are implemented in haskell iirc
22:43:40 <jle`> and pandoc has some pretty wide industry penetration
22:44:12 <zacts> cool
22:44:14 <jle`> but as for other mainstream languages, a lot of people just program using what they already know
22:44:31 <zacts> I guess could I implement standard Ruby in Haskell?
22:44:33 <jle`> also the story behind haskell compiling to JVM isn't super smooth
22:45:15 <jle`> zacts: yeah, i don't see why not :)
22:45:19 <zacts> cool
22:45:38 <Athas> I'm not sure I'd say Haskell is "uniquely" suited for compiler implementation.  It has the same advantages as other functional languages.
22:46:01 <zacts> I guess, C seems to be very portable though.
22:46:10 <jle`> zacts: presumably matz just programmed using what he already knew.  and other ruby implementations (like iron ruby, jvm ruby) are more intended for interop with other language ecosystems/runtimes more than being actual C ruby competitors
22:46:11 <Athas> E.g. the first Rust compiler was in OCaml, and I think Facebook's Hack is also in OCaml.
22:46:23 <zacts> ok
22:46:36 <jle`> Athas: that's fair
22:46:57 <jle`> well, 'functional languages' is a bit vague; a lot of people would include lisp/scheme in that category
22:47:16 <Athas> ML-style functional language, then.
22:47:34 <Athas> It's mostly the static types, algebraic data types, and convenient pattern matching that helps you.
22:48:52 <zacts> I mean how portable is GHC compiled code?
22:49:17 <DigitalKiwi> jle`: "Haskell seems particularly suited to writing Haskell compilers" -- @glguy
22:49:17 <dminuoso> solonarv: monad-logger, but I think Ill just go for `hoist h = (liftIO .  runLoggerT h) =<< askLoggerIO`
22:49:50 <jle`> DigitalKiwi: heh. the irony there i guess is that there isn't any mainstrain haskell compiler written in haskell
22:50:09 <Athas> zacts: the code generated by GHC?  Not at all portable, unless you use the "unregistered" C backend, and I'm not sure how well that works.
22:50:15 <jle`> but i think that that quote is sort of a mischaracterization; lots of different types of language would benefit from being implemented in haskell
22:50:26 <dminuoso> Im thinking this should work without MonadLoggerIO, but honestly I dont need that level of abstraction anyway..
22:50:43 <jle`> it's just that in a lot of example projects, haskell programmers like picking 'implement haskell-likes' as a learning project
22:51:12 <zacts> How well does Haskell FFI with C?
22:51:18 <jle`> zacts: ah, that's also another data point.  in many college haskell courses, 'implement a programming language' is a midterm project :) which illustrates how the features sort of meld so well into this
22:51:19 <DigitalKiwi> jle`: you mean other than ghc?
22:51:21 <Athas> zacts: very well.  It's super smooth.
22:51:31 <zacts> nice
22:51:33 <jle`> DigitalKiwi: ghc isn't fully haskell
22:51:38 <Athas> It's still low-level, of course, but passing data to a C function and getting back some data is easy.
22:52:11 <jle`> zacts: haskell's C FFI is pretty usable; a lot of the trusted and performant standard libraries are actually built on it :)
22:52:34 <zacts> so Haskell could be used to extend lower levels of a compiler written in C. The C could allow for portability, and Haskell for the logic of the rest of it. Maybe? :-)
22:52:45 <dminuoso> zacts: The "well" depends on your notion of "well". You just open that can of worms labelled "crasheritis"
22:52:58 <zacts> :-P Ok
22:53:21 <Athas> zacts: that sounds like a bad design, and would really not make anything portable.  The Haskell part still forces you to only run on the platforms that GHC supports.
22:53:26 <dminuoso> zacts: The FFI part is not the problem mind you, but if you dwell in the safety of Haskell long enough then you kind of start forgetting that the slightest lack of attention in C leads you "seg fault", "does the wrong thing" or "whatever"
22:53:27 <Athas> What kind of portability are you looking for, anyway?
22:53:55 <zacts> Athas:  well, let's say I want something as portable as Ruby
22:54:34 <dminuoso> I dont know about the "portability part"
22:54:34 <zacts> Athas:  I'm not actually implementing a real project right now. I'm just trying to understand.
22:54:36 <Athas> Which platforms do you care about?
22:54:41 <dminuoso> Ruby is not really portable.. :)
22:55:00 <Athas> You can run Haskell code on whatever GHC has a backend for.  You can read up on what those are, and see if that's enough for you.
22:55:06 <tdammers> point in case, when I write C, it rarely segfaults
22:55:07 <Athas> Haskell-the-language is fully portable.
22:55:30 <dminuoso> tdammers: But does it UB in other funny ways? 
22:55:33 <tdammers> it's not as good as a type checker and high-level abstractions, but being religious about having conventions and following them goes a long way
22:55:58 <tdammers> and it probably does expose UB, that's almost a given in C
22:56:53 * DigitalKiwi is amused that 2.1% of GHC is makefiles
22:57:01 <tdammers> at least C doesn't pretend. it's basically an "it is what it is" kind of deal.
22:57:09 <dminuoso> DigitalKiwi: Haha, are those automake generated makefiles?
22:57:14 <zacts> Athas:  oh, so even if the low level code was written in C, if I extended it with Haskell, I'm still limited to the platforms that GHC supports?
22:57:22 <DigitalKiwi> dunno
22:57:33 <tdammers> depends how you extend it
22:57:36 <dminuoso> zacts: Of course. If you have Haskell code, that code eventually needs to run somewhere, doesn't it?
22:57:57 <tdammers> there are Haskell libraries that implement an EDSL for generating C in such a way that it feels almost like you're writing Haskell
22:57:58 <zacts> ah, makes sense
22:58:22 <tdammers> so with those, you can technically "extend" C with haskell, while never running any Haskell on the host that compiles or runs the C
22:58:52 <zacts> Are there any haskell compilers, for just the core standard language of haskell, written in C++ or something?
22:59:07 <zacts> something that just implements pure standard haskell without the GHC features?
22:59:29 <dminuoso> zacts: Well you'd still be limited by the actual Haskell implementation.
22:59:37 <dminuoso> Now GHC is not the only implementation of course..
22:59:39 <zacts> and then I have to go to bed soon.
22:59:55 * zacts searches for Haskell implementations
23:00:23 <zacts> hm... Like it might be an interesting idea to me to implement a mini-haskell compiler.
23:00:28 <DigitalKiwi> HUGS was written in C
23:00:36 <tdammers> hugs is dead though, isn't it
23:00:38 <zacts> or something haskellish.
23:00:46 <Axman6> uhc and jhc also exist(ed)
23:00:48 <zacts> like how big is just the core standard haskell?
23:00:50 <tdammers> there's uhc, and I believe people are trying to resurrect jhc
23:00:53 <dminuoso> 07:50:21         jle` | it's just that in a lot of example projects, haskell programmers like picking 'implement haskell-likes' as a learning project
23:00:59 * dminuoso smiles at jle` predicting zacts's desire
23:01:08 <zacts> https://www.haskell.org/onlinereport/haskell2010/
23:01:30 <zacts> heh, yeah
23:01:34 <tdammers> fun fact: GHC doesn't implement Haskell2010 correctly
23:01:50 <zacts> well, I'm thinking something like mruby but haskell
23:03:43 <zacts> anyway, I think my mind is going to ramble on this unless I go to bed. So, I'll be back another day. :-) Thanks for the info though.
23:03:43 <dminuoso> So let's say I have a stack of `(ReaderT F (ReaderT G ..) M _)` and I want to hoist a `ReaderT G M ()` into that, is there a preexisting way to do this automatically? 
23:04:43 <dminuoso> (The only layers I have are ReaderT or isomorphic to it)
23:06:58 <jle`> zacts: have a good night :)
23:07:09 <jle`> dminuoso: do you mean 'hoist' as in the mmorph terminology?
23:07:32 <dminuoso> jle`: I think so, yes.
23:07:45 <jle`> or do you mean 'lift' maybe
23:08:12 <dminuoso> jle`: For ReaderT only stacks those would be the same, wouldn't they?
23:08:20 <jle`> you want a function ReaderT G M a -> ReaderT F (ReaderT G M) a ?
23:08:35 <dminuoso> jle`: Well obviously any specific function is trivial.
23:09:04 <jle`> what other functions would you want this to be able to replace?
23:09:40 <cocreature> that sounds like you just want "lift"
23:10:47 <dminuoso> cocreature: Well I dont see how that would work. I mean lets say I had `ReaderT E1 (ReaderT E2 (ReaderT E3 (ReaderT E4 (ReaderT E5 M T)))), and I wanted to "lift" a `ReaderT E2 M ()` into that?
23:11:53 <jle`> ah okay, so that is another example of a function you would want this to be able to replace
23:11:53 <dminuoso> If that makes any sense to you.
23:12:26 <cocreature> dminuoso: first turn "ReaderT E2 M" into "ReaderT E2 …" using "hoist"
23:12:28 <cocreature> then "lift"
23:13:49 <jle`> dminuoso: one common solution is to have a single ReaderT polymorphic over some HasE1 r => ReaderT r m ...; this is facilitated well by lensy stuff
23:14:31 <jle`> another is you can have one giant type ReaderT MyBigType, but then use composable tools to lift ReaderT Thing m a -> ReaderT MyBigType, like 'magnify' in lens
23:14:41 <jle`> these all have their pro's and cons
23:14:55 <jle`> but usually if you're using ReaderT, you typically only want to have a single one in the stack for larger projects
23:15:40 <jle`> remember that ReaderT r (ReaderT s m) is just ReaderT (r,s) m
23:15:53 <jle`> (uncurry)
23:16:25 <dminuoso> jle`: Oh yeah, I just have this situation where I have `LoggingT (ReaderT Env IO ())` and `LoggingT IO ()` - realizing right now that my problem sort of disappears if I flip the layers around (then I can simply lift)
23:17:31 <dminuoso> jle`: But I was wondering more out of principle. The `lift . hoist` suggestion by cocreature captures what I was trying to do best. Ive been trying to not rely on `lens` too much.
23:18:02 <jle`> well, none of those solutions actually have anything to do with lenses per se
23:18:15 <jle`> it's that if you 'had' lenses (or lens th), you get them for free
23:18:30 <jle`> but you can write a ReaderT r m a -> ReaderT (r, s) m a without lenses
23:19:11 <jle`> it's `withReaderT fst`
23:19:49 <jle`> actually i guess in this case you don't really get much out of using lenses and magnify instead of just using `withReaderT f`
23:20:23 <jle`> if you had record fields you can just do `withReaderT (foo . bar . baz)` to "upgrade" through three layers of records using just normal accessors
23:20:40 <jle`> i suppose zoom/StateT has more benefit from integration with lens
23:39:35 <janat08> how do you install a ghc version with stack
23:39:53 <janat08> HIE is complaining that there's no system ghc
23:40:07 <Axman6> stack setup
23:41:37 <janat08> do just i just expose the sandboxed one?
23:41:40 <janat08> in path
23:48:06 <janat08> or I suppose you just install ghc
23:48:51 <Axman6> hie should be able to use whatever stack's using
23:58:47 <janat08> it looks for system intall. and now it can't switch from 8.6.4 to one of candidates that is matching the system install
