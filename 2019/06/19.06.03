00:04:19 <DigitalKiwi> https://qfpl.io/posts/intro-to-state-machine-testing-1/ maybe?
00:09:42 <jackdk> mankyKitty and I built https://github.com/qfpl/state-machine-testing-course , might be useful to you?
00:12:00 <magthe> Thanks DigitalKiwi and jackdk, I'll have to take a look at both. I'm particularly confused about how to deal with needing a piece of the `output` when calculating the next state, if only `Var a v` was a functor :/
00:27:12 <piyush-k`> google gods don't seem to be kind to me but how does one add the constructors and field elements of a "newtype family Foo Int = Foo { foo :: Bool }" into the export list of a module. 
00:31:39 <dminuoso> piyush-k`: See 5.2 in https://www.haskell.org/onlinereport/haskell2010/haskellch5.html
00:32:29 <dminuoso> piyush-k`: An algebraic datatype T declared by a data or newtype declaration may be named in one of three ways: [...]
00:38:31 <jackdk> magthe: hedgehog wants to generate the entire test plan before it runs anything, so you will have to rely on symbolic values, which are basically opaque tokens
00:42:48 <jackdk> magthe: https://github.com/qfpl/state-machine-testing-course/tree/master/level06 is the exercise that deals with vars
00:46:58 <magthe> jackdk: yes, I'm starting to realise that, and it makes my ideas of how I want to test break down :/ For instance, the execution of `POST foo` returns two things I want, the HTTP status (used in a test against acceptable values) and a UUID (the identity of the created thing, which I want to use in my state). It seems that hedgehog's design makes it impossible to do it that way, which means I'd have to
00:47:00 <magthe> redesign my state somehow, but I'm not sure how.
00:50:21 <jackdk> magthe: it depends on what you want to do with those values. You only need to use Var if the generator of another command depends on the output. Otherwise you can return them from the end of your commandExecute action and you will see them in an Ensure callback.
00:51:33 <jackdk> you won't be able to pick out the uuid from the result at generation time though, so that will push your fst/snd calls inside your other commands
00:54:47 <magthe> jackdk: yes, for the Ensure it's easy, but I only want one part in Ensure (the HTTP status), the UUID I want in the Update (to make sure that subsequent `GET foo/:uuid` uses the UUID of an existing foo (if that makes sense)
00:57:38 <magthe> the way I'm thinking ATM is that my execute function returns `(HTTPStatus, Maybe UUID)` (I always have a status, I only have a UUID if nothing went wrong), for the Update that translates into a `forall v. Var (HTTPStatus, Maybe UUID) v`, and I don't see a way of getting just the UUID (or even a `Var UUID v`) into my state :/
00:58:05 <jackdk> magthe: that sounds correct to me. what I would do here is split your command, so you have a command that means "create the thing and succeed", that stores a uuid in your model
00:58:20 <jackdk> then your other generators that test e.g. `GET foo/:uuid` can pull it out
00:59:10 <magthe> Hmm, I don't see how, only the execute function is in MonadIO, the Callbacks aren't...
00:59:52 <magthe> Maybe I should write up a tiny example.
00:59:54 <jackdk> Update doesn't need to be in MonadIO, it only needs to be able to fiddle with the model
01:01:12 <jackdk> your commandExecute actions often end up in both MonadTest and MonadIO, so you can put assertions in there without having to pass details around in Vars
01:02:11 <jackdk> so your execute step for a "post a thing that succeeds" will check response code in commandExecute and return the UUID. this means that its Update callback will see a Var UUID v as one of its args
01:02:23 <jackdk> which you can stuff into a map or whatever because it has a cheeky ord instance
01:02:56 <magthe> jackdk: hmm, so you regularly mix in tests in the commandExecute? I discarded that since it feels a bit... well, icky :)
01:04:24 <jgt1> is there any reason to use `!?` instead of `Map.lookup`?
01:05:57 <jackdk> magthe: depends on what you're trying to do. If you need to check against your model (what the haddocks call "state"), you need an ensure callback.
01:06:28 <jackdk> but sometimes you need to do stuff in execute, and having MonadTest there can help a lot (e.g., evalEither means you can deal with Eithers quickly)
01:06:43 <jackdk> > :t (Data.Map.!?)
01:06:46 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
01:06:54 <jackdk> :t (Data.Map.!?)
01:06:56 <lambdabot> Ord k => M.Map k a -> k -> Maybe a
01:07:27 <jgt> assuming no knowledge of `apply` or `rooms` in `maybe (pure Nothing) (apply rooms) $ rooms !? key`, can I assume that it can be rewritten as `apply rooms <$> rooms !? key`?
01:08:04 <jgt> or rather, with parentheses around everything after the fmap
01:08:10 <jackdk> jgt: (!?) is an alias for lookup
01:08:30 <jackdk> jgt: your transformation seems sound
01:08:36 <jgt> magthe: Hi Magnus! :D
01:08:37 <ski> jackdk : nope
01:08:52 <jackdk> ski: what did I miss?
01:08:58 <ski> types differ
01:09:05 <jackdk> ohhh there's a pure there
01:09:57 <ski> `apply rooms <$> ...' will always be a `Just', if `...' is a `Just' (assuming for the sake of argument that that would type-check)
01:10:39 <jgt> oh right, so it would only be suspicious if it's `maybe Nothing f ma`
01:10:46 <ski> however, `maybe (pure Nothing) (apply rooms) (...)' will be whatever `apply rooms x' wants to be, in case `...' is equal to `Just x'
01:11:05 <ski> `maybe Nothing (Just . f)' is equal to `fmap f'
01:11:32 <jgt> right
01:11:41 <ski> `maybe Nothing f' is equal to `(f =<<)'
01:13:28 <jackdk> magthe: I have to leave in a minute. any more questions?
01:15:43 <magthe> jackdk: yes, I guess I should relax my stance on separation of execution and state a little then :)
01:16:11 <magthe> No more questions at the moment, I have to play a little with this to see where it takes me.
01:16:36 <jackdk> okay, good luck.
01:17:08 <jgt> magthe: hispida?
01:18:14 <magthe> jgt: hi Jezen (?)
01:18:58 <jgt> Yes ;)
02:04:13 * hackage plots 0.1.1.2 - Diagrams based plotting library.  https://hackage.haskell.org/package/plots-0.1.1.2 (cchalmers)
02:09:29 <Messburn> I would like to M-. into function definitions of external Haskell libs in Emacs. Can I use Stack to make the sources available so that Emacs can find them?
02:12:51 <bahamas> why would cabal complain that it can't find a module, even though the library that provides the module is set as a dependency. this is part of the output https://bpaste.net/show/46d388933933
02:13:02 <bahamas> I'm assuming the call to Setup.hs is done by cabal
02:17:36 <bahamas> I have the feeling that this doesn't go through cabal, so the error message comes from ghc
02:19:52 <bahamas> maybe anyone more familiar with nix can confirm?
02:22:08 <cocreature> bahamas: can you point us to the package?
02:22:36 <cocreature> it looks like you imported that module from Setup.hs but haven’t added the dependency to setup-depends
02:25:13 * hackage trivial-constraint 0.5.1.0 - Constraints that any type, resp. no type fulfills  https://hackage.haskell.org/package/trivial-constraint-0.5.1.0 (leftaroundabout)
02:26:32 <bahamas> cocreature: hm, the library does fails to build does have that in setup-depends. it's this one https://github.com/tweag/inline-java/tree/master/jvm-streaming
02:27:24 <bahamas> you can see jvm-batching in its `setup-depends`
02:27:34 <cocreature> bahamas: what does your nix file look like? maybe cabal2nix broke
02:28:28 <Uniaika_> hohai! I cannot seem to find an example use of Aeson with default values for missing keys. All I find is when the key is set at `null` :/ Does anyone know the pattern that I need?
02:28:30 <bahamas> cocreature: which one do you want to see? I don't have a nix file for jvm-streaming, because it's a dependency of another project I'm trying to build
02:29:09 <cocreature> bahamas: then look at the definition of jvm-streaming in whatever nixpkgs snapshot you’re using
02:36:14 <bahamas> cocreature: you mean to look for the version of jvm-streaming? the derivation contains version 0.3.1, which is the latest release
02:42:04 <cocreature> bahamas: no the actual derivation somewhere in hackage-packages.nix
02:42:29 <cocreature> my guess would be that setupHaskellDepends isn’t set properly there.
02:42:43 * hackage rewrite-inspector 0.1.0.3 - Inspection of rewriting steps  https://hackage.haskell.org/package/rewrite-inspector-0.1.0.3 (omelkonian)
02:44:02 <bahamas> cocreature: this is what it looks like https://bpaste.net/show/c2c5b16928fe
02:44:30 <cocreature> bahamas: are you sure that is the derivation in the nixpkgs snapshot you’re using as opposed to the master branch?
02:47:38 <bahamas> cocreature: this is the nixpkgs commit I'm using https://raw.githubusercontent.com/NixOS/nixpkgs/1fa2503f9dba814eb23726a25642d2180ce791c3/pkgs/development/haskell-modules/hackage-packages.nix
02:50:21 <cocreature> bahamas: hm that looks fine, not sure what’s going wrong
02:53:13 * hackage rewrite-inspector 0.1.0.4 - Inspection of rewriting steps  https://hackage.haskell.org/package/rewrite-inspector-0.1.0.4 (omelkonian)
03:06:17 <Axman6> Uniaika_: are you after something like withObject "Foo" $ \o -> Foo <$> (o .: "fooField <|> pure default)?
03:06:43 * hackage constrained-categories 0.4.0.0 - Constrained clones of the category-theory type classes, using ConstraintKinds.  https://hackage.haskell.org/package/constrained-categories-0.4.0.0 (leftaroundabout)
03:06:51 <phadej> o .:? "fooField" .!= default
03:07:21 <Axman6> yeah I was pretty sure there was an operator for that
03:09:44 * hackage registry 0.1.5.3 - data structure for assembling components  https://hackage.haskell.org/package/registry-0.1.5.3 (etorreborre)
03:10:43 * hackage registry-hedgehog 0.2.0.1 - utilities to work with Hedgehog generators and `registry`  https://hackage.haskell.org/package/registry-hedgehog-0.2.0.1 (etorreborre)
03:12:43 * hackage registry 0.1.5.4 - data structure for assembling components  https://hackage.haskell.org/package/registry-0.1.5.4 (etorreborre)
03:18:42 <Uniaika_> thank you Axman6 and phadej :)
03:20:44 * hackage memdb 1.0.0.0 - Efficient in memory indexed database  https://hackage.haskell.org/package/memdb-1.0.0.0 (pkamenarsky)
04:16:10 <sambo> I saw some folks talking earlier about a function with an argument (forall a. f a -> a)
04:16:38 <sambo> and I just think that's an interesting type
04:17:12 <hpc> it's up there for sure
04:17:18 <ski> it means an "`f'-container" has at least one "element"
04:17:51 <sambo> right, I'm looking up the free theorems paper to figure out exactly what it tells you about f if you have such a function
04:18:44 <hpc> @free f a -> a
04:18:44 <lambdabot> Extra stuff at end of line
04:19:08 <hpc> i always forget the syntax for @free...
04:19:12 <ski> @free foo :: F a -> a
04:19:12 <lambdabot> f . foo = foo . $map_F f
04:19:40 <sambo> what is that? I'm new here
04:19:57 <fendor> is there somewhere a list of hoogle commands that are available? e.g. to search for exactly a term, I can use is:exact. 
04:20:00 <ski> but perhaps they were looking for a free theorem for rank-2 operations like `doubleGet' ?
04:20:04 <ski> @help free
04:20:04 <lambdabot> free <ident>. Generate theorems for free
04:20:32 <ski> @free shuffleMysteriously :: [a] -> [a]
04:20:33 <lambdabot> $map f . shuffleMysteriously = shuffleMysteriously . $map f
04:20:34 <sambo> @free foo :: forall a. f a -> a
04:20:34 <lambdabot> Extra stuff at end of line
04:20:41 <sambo> @free foo :: forall a. F a -> a
04:20:42 <lambdabot> f . foo = foo . $map_F f
04:20:44 <hpc> sambo: it finds free theorems for the things you give it
04:20:51 <ski> it doesn't accept the `forall' syntax
04:21:00 <sambo> It seems to actually
04:21:08 <sambo> @free foo :: forall a. F a -> a
04:21:08 <hpc> they tend to involve fmap in some way
04:21:09 <lambdabot> f . foo = foo . $map_F f
04:21:10 <ski> @free maybeSelectAnElement :: [a] -> Maybe a
04:21:11 <lambdabot> $map_Maybe f . maybeSelectAnElement = maybeSelectAnElement . $map f
04:21:17 <hpc> which it denotes as $map or $map_Something
04:21:25 <Messburn> Let’s say module Mod exports the symbols a, b, c, d and e.  I would like to import a and b so that they can be used unqualified. But I want to import c, d and e qualified. Will I need two import statements to get what I want?
04:21:32 <ski> oh, right. but it doesn't handle higher-rank, i think
04:21:39 <hpc> Messburn: yes
04:22:22 <ski> @free anythingGoes :: a -> b
04:22:22 <lambdabot> g . anythingGoes = anythingGoes . f
04:22:30 <ski> @free undefined :: a
04:22:31 <lambdabot> f undefined = undefined
04:22:41 <ski> hmm
04:22:43 <sambo> anyone know any good uses of existential quantification in Haskell?
04:24:00 <ski> one can use existentials to encode (e.g. recursive) object/record types
04:24:15 <sambo> how does one do that?
04:24:36 <ski> @free foo :: (forall a. F a -> a) -> F (F b) -> F b
04:24:37 <lambdabot> (forall g. g . x = y . $map_F g) => $map_F f . foo x = foo y . $map_F ($map_F f)
04:24:48 <ski> hm, maybe it actually can do that
04:25:35 <ski> sambo : `mu r. ..r..' is equivalent to `forall r. (..r.. -> r) -> r' (this is called "Church encoding")
04:26:04 <ski> sambo : `nu s. ..s..' is equivalent to `exists s. (s,s -> ..s..)' (this might be called "State encoding")
04:26:14 <hpc> heh
04:28:00 <ski> @quote separation.of
04:28:01 <lambdabot> GuySteele says: Some people prefer not to commingle the functional, lambda-calculus part of a language with the parts that do side effects. It seems they believe in the separation of Church and
04:28:01 <lambdabot> state.
04:28:06 <ski> @quote Church.and.State
04:28:06 <lambdabot> ski says: I'd rather say that in Haskell, Church and State are dual
04:28:15 <ski> @quote Church.and.State!
04:28:15 <lambdabot> shapr says: Haskell separates Church and state!
04:28:20 <sambo> mu country. nu religion. religion -> (country, religion)
04:28:33 <Lycurgus> didn get concerns
04:32:41 <ski> sambo : so .. the type of potentially finite streams of `a's can be encoded as `exists s. s * (s -> 1 + a * s)'
04:33:29 <ski>   unfoldr :: forall a s. (s -> Maybe (a,s)) -> s -> [a]
04:33:40 <ski>   flip unfoldr :: forall a s. s -> (s -> Maybe (a,s)) -> [a]
04:33:45 <sambo> Can't any data type be encoded in this way?
04:33:51 <ski>   uncurry (flip unfoldr) :: forall a s. (s,s -> Maybe (a,s)) -> [a]
04:34:02 <ski>   uncurry (flip unfoldr) :: forall a. (exists s. (s,s -> Maybe (a,s))) -> [a]
04:34:22 <ski> not sure what you mean by "any data type"
04:34:38 <sambo> anything definable via data in Haskell, I meant
04:34:44 <sambo> you just use s as the name
04:35:07 <ski> Haskell conflates the notion of `mu' vs. `nu'
04:35:27 <sambo> I know this, that's not what I'm talking about though
04:36:26 <ski> (a value of type `mu r. f r' is supposed to have all paths only passing through finitely many `f's, while for `nu s. f s', we allow also infinite paths)
04:36:28 <sambo> So you'd write s*(s -> case_1 + s -> case_2 + ...) where each case_i corresponds to the elements in the sum
04:36:58 <sambo> oh, I didn't think that's what you meant, what do you mean by paths here?
04:37:03 <merijn> sambo: Yes, you can encode every ADT as a function/lambda like that
04:37:05 <ski> could you bracket the `->' vs. `+' there ?
04:37:27 <merijn> sambo: In fact, there's multiple existing encoding schemes for that (Scott encoding and Church encoding being the most famous ones)
04:37:54 <sambo> yes, exists s. s*(s -> (case_1 + case_2 + ...))
04:38:08 <ski> merijn : i suppose we're more political than religious, atm
04:38:16 <sambo> right, I've actually built a library in Haskell for converting your types between them, never did anything with it though
04:38:27 <merijn> ski: I missed the original question, only saw the comments :)
04:38:39 <sambo> It is interesting to code with functions instead of data types, but not very useful
04:39:10 <sambo> the question was what can be done with the existentialquantification existention that is interesting
04:39:18 <ski> sambo : i think using State encoding can possibly allow for better loop fusion
04:39:59 <sambo> I am looking up state encoding and I cannot find it
04:40:03 <sambo> which one is it again?\
04:41:37 <sambo> ah, so the Scott encoding is like the "what can I do with this" and the Church one is like "how can I get these values out"
04:41:55 <sambo> and church is the one I was doing, yeah?
04:42:15 <sambo> or I guess its just a tad different
04:42:18 <ski> <ski> sambo : `mu r. ..r..' is equivalent to `forall r. (..r.. -> r) -> r' (this is called "Church encoding")
04:42:21 <ski> <ski> sambo : `nu s. ..s..' is equivalent to `exists s. (s,s -> ..s..)' (this might be called "State encoding")
04:42:24 <ski> sambo ^
04:42:38 <ski> i'm not sure if anyone else than me has called it "State encoding"
04:43:00 * ski thought it was an apt joke
04:43:17 <sambo> right, that's a nice way to see that they are dual
04:43:17 <hpc> it would only be an apt joke if it was about packaging
04:44:09 * ski gently packages hpc into a container type
04:44:45 <ski> sambo : "church is the one I was doing, yeah?" -- where ?
04:44:57 <ski> <sambo> yes, exists s. s*(s -> (case_1 + case_2 + ...))
04:45:04 <ski> would be "State encoding"
04:45:45 <sambo> thanks ski
04:45:50 <sambo> what are you working on these days?
05:28:14 * hackage contravariant 1.5.2 - Contravariant functors  https://hackage.haskell.org/package/contravariant-1.5.2 (ryanglscott)
05:53:04 <pie_> I dont have anything concrete in mind, but have you guys seen anything about data structures that maintain connectivity between pieces of data while being transformed?
05:53:25 <pie_> most ive done so far is messing with some sql tables where i kept some column information around
05:54:10 <pie_> my use case is something like exploratory data analysis, but once you find something interesting you can go back and look for connected stuff
05:56:30 <pong> just don't mutate in general?
05:56:43 <pong> (which is most of pandas api)
05:57:08 <pie_> i havent looked at pandas much yet, i _have_ been using r and dplyr
05:57:30 <pong> pandas is for python tho which is why I bracketed it
05:57:36 <pie_> ive been finding it a bit diffivcult though and was playing with the thought that maybe i just want my haskell and my maps and stuff (or haskellR maybe, idk)
05:59:02 <Rembane> Zippers and lenses come to mind, but they are not a perfect fit.
06:01:51 <gentauro> anybody know if there is a paper on "Optimal JavaScript minimization"? If yes, have anybody in here have knowledge if there is an implementation in Haskell of the algorithm? If not, why aren't there any ... (I would like to give it a go if there aren't any) :-) Sample: https://paste.ee/p/Tv0L8
06:02:59 <kuribas> why does stack downloads ghc, even when I have the same version on the machine?
06:04:01 <gentauro> kuribas: it doesn't. If you already have the version in your `~/.stack/..` folder, it will just "copy" the "cached" version
06:04:41 <kuribas> gentauro: not in ~/.stack, but in /opt/ghc/8.4.3
06:04:59 <merijn> kuribas: stack doesn't use system GHC(s)
06:05:00 <cocreature> kuribas: my default system-ghc is false
06:05:07 <merijn> At least not by default
06:05:10 <gentauro> kuribas: `stack` works with it's own version(s) of GHC
06:05:15 <kuribas> why?
06:05:17 <JappleAck> kuribas: i think the reason is that you could have ghc compiled with different flags on your machine
06:05:24 <gentauro> that way you can have several project with different `ghc` versions
06:05:29 <gentauro> it's pretty damn smart :-)
06:05:35 <merijn> kuribas: Because stack expects to manage GHC and packages
06:05:40 <gentauro> (if you actually work "pro" with many projects)
06:05:55 <gentauro> kuribas: look into `stack LTS`
06:05:55 <merijn> gentauro: That's easy enough with cabal-install too, tbh
06:06:01 <kuribas> so basically stack takes over the system?
06:06:12 <gentauro> best thing ever to happen to `Haskell` adoption in industry
06:06:16 <gentauro> :)
06:06:17 <kuribas> well, there is no choice then...
06:06:22 <merijn> kuribas: Stack more "ignores the system", but yes
06:06:25 <cocreature> kuribas: you can set system-ghc to true
06:07:00 <kuribas> I am hoping new-build will take over...
06:07:19 <cocreature> it doesn’t install things “globally” (neither in the sense of installing it for all users nor in some common location) so I wouldn’t say it takes over your system.
06:07:31 <cocreature> but yeah if you’re happy with new-build just use that :)
06:07:40 <merijn> v2-build now ;)
06:07:49 <gentauro> as I understand, `new-build` isn't a competetiro to `stack` nor `cabal`
06:07:49 <cocreature> new-build still works :)
06:08:00 <kuribas> cocreature: sadly some tooling only works with stack
06:08:09 <cocreature> I just avoid that tooling :)
06:08:14 * hackage mail-pool 1.0.0 - Preconfigured email connection pool on top of smtp.  https://hackage.haskell.org/package/mail-pool-1.0.0 (Jappie)
06:08:21 <merijn> gentauro: I think you mean 'cabal-install'? And new-build is just "the future build approach for cabal-install"
06:08:23 <kuribas> cocreature: my coworker uses it, and he's on windows
06:09:50 <cocreature> kuribas: I’ve used new-build two weeks ago on Windows :) but yeah I feel your pain, agreeing on tooling can be rather painful.
06:10:16 <gentauro> cocreature: as painful as `stack` on `NixOS`? :D
06:10:50 <kuribas> cocreature: well, that would impossible, as I am not on windows, and advocating emacs would be futile...
06:11:14 * hackage mail-pool 1.0.1 - Preconfigured email connection pool on top of smtp.  https://hackage.haskell.org/package/mail-pool-1.0.1 (Jappie)
06:12:34 <kuribas> cocreature: right now I am happy if they even consider haskell :)
06:17:50 <gentauro> kuribas: what's the setup of a `Haskell` + `Windows` user? Ide + "stuff". I'm a bit curios
06:18:47 <kuribas> gentauro: intellig I think...
06:20:00 <gentauro> kuribas: One of my friends says he uses `Haskero` which is `intero` for VSCode
06:20:04 <gentauro> he is happy about it
06:20:38 <kqr> hello, my favourite people who know how to structure code well! I have a function of two parameters `Alternative f => f a` (where `f` and `a` are the same for both parameters.) I want to return either the maximum of the two, or, in case either of the two are `empty`, the other one. is there such a function already? the empty cases are simply `<|>`, but when both are non-empty, that would pick the first of
06:20:40 <kqr> the two and not necessarily the maximum.
06:21:02 <kqr> one option might be to first construct a tuple where they are ordered correctly, and then apply an uncurried `<|>` to that tuple, but that feels unclean
06:21:10 <kuribas> gentauro: I'll let him know :)
06:21:46 <kuribas> kqr: so Num a ?
06:22:37 <kqr> kuribas, this particular case is actually probably closer to `(Num a, Alternative f) => f a`
06:22:46 <kuribas> kqr: liftA2 max a b  <|> a <|> b ?
06:22:50 <ziman> (max <$> x <*> y) <|> x <|> y ?
06:23:03 <kqr> now this seems reasonable, yes
06:29:19 <bwe> I want to check out the build time of a new laptop. Which package would I want to build for this benchmark?
06:30:14 * hackage registry-hedgehog 0.2.0.2 - utilities to work with Hedgehog generators and `registry`  https://hackage.haskell.org/package/registry-hedgehog-0.2.0.2 (etorreborre)
06:30:31 <ski> kqr : nitpick, the parameter type most probably isn't `Alternative f => f a', but `f a', where `Alternative f' is known to hold. (if you really want to, perhaps you could say that the parameter type is `Alternative f *> f a', hmm)
06:31:25 <ski> kqr : iow, presumably you have something like `maxA :: Alternative f => f a -> f a -> f a', not `maxA :: (Alternative f => f a) -> (Alternative f => f a) -> ...'
06:32:09 <ski> (oh, and with `Ord a => ' also added after the ` :: ', in this case)
06:35:45 <Ariakenom> gentauro: optimal minimisation is surely undecidable
06:39:47 <dminuoso> What does constraint/context correspond to in the curry howard isomorphism?
06:40:02 <dminuoso> Is => also implication?
06:40:45 <kqr> ski, yes, I was bothered by that in my own message (and felt like I had to clarify with the parenthetic remark I wrote.) it felt clumsy and uninformative to write it out as `Alternative f => f a -> f a -> f a` although perhaps that would have been more clear...
06:43:18 <ski> dminuoso : yes
06:44:06 <ski> kqr : ime, people easily confuse "`f a', with a presupposition `Alternative f'", with "`Alternative f => f a'"
06:45:15 <Phyx-> gentauro: I'll have a package soon that'll provide two toolings based around cabal + vscode, one will be vscode-simple based the other HIE
06:46:35 <Phyx-> and a core one, that provides no ide, just does all the plumbing for everything to work together
06:48:27 <halogenandtoast> Having an interview with a company that mainly does Haskell today, any suggestions on Haskell related prep I should do?
06:49:01 <kuribas> halogenandtoast: today is a bit late, isn't it?
06:49:34 <ski> (halogenandtoast isn't totally new to the channel)
06:50:08 <halogenandtoast> kuribas: I mean, I suppose that depends on the suggestion. I have 7 or so hours to prepare.
06:50:24 <halogenandtoast> ski: I have probably been around longer than you'd guess :p
06:50:56 <kuribas> halogenandtoast: my only haskell interview I did was a big flop, so I guess I am not a good one to answer :)
06:51:27 <ski> halogenandtoast : yea, i mostly meant that you weren't one of those last-day-join-a-channel-ask-for-help people
06:51:56 <halogenandtoast> kuribas: If you are willing to share, was it a flop because the company wasn't a good fit, or did they ask questions that were above your current level?
06:52:29 <kuribas> halogenandtoast: they kept asking if I thought haskell could be used for anything, and appartenly yes, wasn't the right answer...
06:52:41 <kuribas> halogenandtoast: they were a haskell and go company (and other stuff)
06:52:56 <halogenandtoast> kuribas: Yeah, I think they wanted you to highlight where Haskell isn't the best choice
06:53:02 <kuribas> halogenandtoast: pretty sure I could have handled any haskell question the threw at me...
06:53:15 <kuribas> halogenandtoast: I told them embedded, and real-time.
06:53:43 <kuribas> halogenandtoast: but the interviewer had this idea the anything with side-effects is a bad fit for haskell, and they used go for that.
06:54:05 <ski> sounds like their problem, in that case
06:54:08 <halogenandtoast> kuribas: :\ 
06:54:19 <halogenandtoast> yeah I agree, you might have saved yourself there.
06:54:24 <kuribas> yeah, probably good I didn't end up there :)
06:54:44 <fendor> can Hoogle give me the datatype to a datatype constructor? E.g. Can I search somehow for Just and get back Maybe a?
06:55:10 <ski> @hoogle Just
06:55:10 <lambdabot> Prelude Just :: a -> Maybe a
06:55:10 <lambdabot> Data.Maybe Just :: a -> Maybe a
06:55:10 <lambdabot> GHC.Maybe Just :: a -> Maybe a
06:55:20 <kuribas> @hoogle a -> Maybe a
06:55:20 <lambdabot> Prelude Just :: a -> Maybe a
06:55:21 <lambdabot> Data.Maybe Just :: a -> Maybe a
06:55:21 <lambdabot> GHC.Maybe Just :: a -> Maybe a
06:55:43 <kuribas> fendor: isn't that just the type?
06:55:46 <fendor> I need it programmatically somehow. Can it be done with the hoogle Api? 
06:55:47 <kuribas> :t Just
06:55:48 <lambdabot> a -> Maybe a
06:56:26 <ski> (as if side-effects (vs. effects) weren't a property of the "language level" you used to describe things, but some kind of "Ding-an-Sich")
06:56:48 <fendor> yes, but does that work in general? If i want to import a data constructor of a specific type, i need import Data.Maybe (Maybe(Just)) for example
06:58:35 <pie_> oops i got distracted
07:02:17 <kuribas> halogenandtoast: where are you situated?
07:03:27 <halogenandtoast> kuribas: I am currently in transit, just moved back from Japan, currently in Atlanta, Georgia, moving to Austin, Texas later this month for at least a year.
07:04:02 <kuribas> halogenandtoast: are there haskell jobs in texas?
07:04:11 <halogenandtoast> I applied to a company in NYC, and if things go well, maybe I can move next year.
07:04:27 <halogenandtoast> Position said remote ok.
07:04:33 <kuribas> ah I see
07:04:42 <halogenandtoast> So with only an hour difference between TZs I figured why not.
07:05:06 <kuribas> there's haskell position here in Europe.
07:05:52 <halogenandtoast> Yeah I am kind of pinned to the US now, I had a kid last year and moved back to be closer to family.
07:06:14 <kuribas> congrats!
07:06:17 <halogenandtoast> Thanks!
07:06:28 <halogenandtoast> I legit tried to name him Haskell, my wife did not let me...
07:06:50 <halogenandtoast> Not even as a middle name.
07:06:57 <ski> @where haskel
07:06:57 <lambdabot> <http://web.archive.org/web/20070703001910/http://www.cs.chalmers.se/~augustss/pics/haskel.gif>
07:47:14 * hackage constraints-deriving 1.0.4.0 - Manipulating constraints and deriving class instances programmatically.  https://hackage.haskell.org/package/constraints-deriving-1.0.4.0 (achirkin)
08:09:48 <sm> halogenandtoast: oh well, have some karma! halogenandtoast++
08:10:25 <lostbit> Hi I was doing cis194,2013,07,ex2,2 and was wondering if they are asking me to drop elements from a join list without updating the annotations?
08:11:50 <bahamas> anyone know if there's a way to pass the '-v' flag to ghc through nix? ghc is not finding a module that should be available, and I want to see where it's looking
08:14:40 <dminuoso> bahamas: You could add it to your cabal file, no?
08:15:09 <cocreature> bahamas: something like configureFlags = ["--ghc-option=-v"] might do the trick
08:16:21 <f-a> I am getting bitten by "Warning: Parsing the index cache failed (Unknown encoding for constructor). Trying to regenerate the index cache..." after a power outage. What do I have to rm -rf to get this warning out of the way?
08:16:33 <halogenandtoast> sm: I forgot about the karma system, I probably owe a few people.
08:16:52 <bahamas> hm, I realized that I probably need to make a nix file for that dependency as well, in order to be able to do that
08:19:50 <bahamas> cocreature: I don't know if it's the same thing, but I tried a different approach. I untared the archive with the source stored in the nix store. then I ran the ghc command in the decompressed archive and passed it Setup.hs. this is what I got https://bpaste.net/show/44271bf37d2a
08:20:15 <ski> lostbit : <https://www.seas.upenn.edu/~cis194/spring13/hw/07-folds-monoids.pdf> ?
08:20:31 <ski> lostbit : "The idea is that the annotation at the root of a `JoinList' will always be equal to the combination of all the annotations on the `Single' nodes (according to whatever notion of \"combining\" is defined for the monoid in question)." p.4
08:20:31 <bahamas> dminuoso: this is not my package, so I can't do that
08:21:36 <lostbit> ahh ski i think that explains it thank you. the root of nodes that makes sense, i was wondering how to subtract from a monoid but I just recalculate it
08:21:47 <lostbit> i was wondering how a monoid would have an inverse
08:22:13 <ski> it doesn't need to have any. it doesn't even need to be cancellable
08:22:25 <cocreature> bahamas: hm I wonder if the Cabal shipped with 8.2.2 might be broken wtr to setup-depends. it’s a relatively recent feature
08:22:37 <lostbit> yup it didn't make sense in my head according to the definition ski, i'll try now bye!
08:22:52 <ski> addition on natural numbers is cancellable. (inclusive) disjunction on booleans is not
08:23:08 <ski> lostbit : you're welcome to stay here and lurk, if you want to
08:23:56 <bahamas> cocreature: btw, this project does build but with stack + nix. do you know if stack uses the same cabal mechanics under the hood or bypasses them?
08:25:11 <cocreature> in generally it uses the same mechanism but I wouldn’t be surprised if it handles setup-depends slightly differently in particular on older versions of ghc/cabal/stack
08:27:37 <bahamas> cocreature: there's one thing I don't understand about the output I pasted. it says "locations searched" and lists the dirs. but where does it look for them? in the current working dir?
08:31:31 <cocreature> bahamas: probably, it looks like it doesn’t output that it couldn’t find it any of the dependencies
08:32:49 <cocreature> bahamas: I’d probably start by trying to see if you can reproduce this with the latest nixpkgs-unstable and ghc-8.6.5
08:33:23 <fendor> @hoogle Text -> Maybe Text
08:33:24 <lambdabot> Data.Text.Lazy.Manipulate stripWord :: Text -> Maybe Text
08:33:24 <lambdabot> Data.Text.Lazy.Manipulate toAcronym :: Text -> Maybe Text
08:33:24 <lambdabot> Data.Text.Manipulate stripWord :: Text -> Maybe Text
08:34:11 <fendor> @hoogle f a -> Maybe a 
08:34:12 <lambdabot> ClassyPrelude asMaybe :: Maybe a -> Maybe a
08:34:12 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
08:34:12 <lambdabot> Test.Framework.Providers.API listToMaybeLast :: [a] -> Maybe a
08:34:41 <bahamas> cocreature: I don't know how easy that will be, because the project has nixpkgs pinned to that older version. so something else might break. but if I don't find an alternative, I'll try that
08:36:31 <cocreature> bahamas: you don’t need to build your whole project. just build that one package to check if it changes anything
08:36:44 * hackage conduit-algorithms 0.0.10.1 - Conduit-based algorithms  https://hackage.haskell.org/package/conduit-algorithms-0.0.10.1 (luispedro)
08:36:45 <zincy> What do you recommend as a streaming library to manage messaging to and from networked sockets in a pub sub fashion?
08:38:52 <zincy> Pipes and Conduit are the main contenders but I am struggling to choose
08:40:42 <isovector1> anyone know of a good, easy-to-use, ipc implementation that uses bytestrings?
08:43:05 <o1lo01ol1o> zincy:  streamly also has good performance, though I've only earmarked it.
08:43:15 <zincy> thanks
08:43:19 <zincy> will take a look
08:45:38 <filedesless> /1
08:50:26 <Chobbes> In cmdargs I can specify arguments that should form a list, like in the example at the bottom of the page here: https://zuttobenkyou.wordpress.com/2011/04/19/haskell-using-cmdargs-single-and-multi-mode/ however, if i give this list a default value (e.g., all formats in this example), arguments supplied on the command line don't replace this default list, but are appended to the list. Does anybody know of a
08:50:27 <Chobbes> way to replace the list if the arguments are provided?
08:52:42 <solonarv> fendor: ghci can do it, try ':info Just' for example
08:52:48 <bahamas> cocreature: oh, right. I'll try that. thanks for the suggestions!
08:52:52 <solonarv> you can probably also go through the GHC API
08:53:32 <fendor> solonarv, currently, I am going the lazy approach, if I can find the dataconstructor, I get a result of `Just :: a -> Maybe a`. So, I split on "->" and take the first word
08:53:59 <solonarv> fendor: hah, that should work too :>
08:54:24 <solonarv> you can also try to 'reify' the constructor's name, if working in TH is convenient for you
08:55:04 <fendor> i dont think th is ever convenient :D
08:56:58 <solonarv> true! I just wanted to mention it for completeness' sake, since I'm not sure what you're doing
08:57:41 <fendor> i am trying to improve the import actions of hie
09:00:54 <solonarv> fendor: ah, so you have access to the GHC API right?
09:01:31 <fendor> solonarv, yes, but I obtain the potential imports from hoogle and the module to import is not necessarily already registered as a package
09:01:53 <solonarv> ah, I see
09:02:03 <fendor> e.g. aeson may not be a dependency, but I may still be interested in that import
09:03:05 <solonarv> the stringy method is probably alright then - i.e. parse the type and grab the datatype name from there
09:03:18 <fendor> it seems dirty :/ but a lot of this stuff is pretty dirty
09:04:11 <solonarv> simply splitting on -> isn't enough though - it breaks in the presence of GADTs/data families, where the return type of a constructor is not necessarily 'type constructor applied to some tyvars'
09:05:01 <fendor> solonarv, do you have an example what a hoogle query might return then in that case? 
09:06:43 <fendor> never worked with GADT's before
09:09:23 <solonarv> I don't have a concrete example in an extant package (and I can't be bothered to go find one), but something like this should trigger it: data SK t where (:$) :: SK (a -> b) -> SKI a -> SK b; K :: SK (a -> b -> a); S :: SK ((e -> a -> b) -> (e -> a) -> e -> b)
09:09:38 <solonarv> (a simple encoding of the SK(I) calculus)
09:10:07 <fendor> oh goodness...
09:10:32 <fendor> thanks, I will keep in the back of my mind! But I still aim to make it work in the simple case first
09:11:15 <solonarv> fair enough!
09:11:36 <solonarv> I think making it work for those GADTs might be as simple as tossing out everything that's in parentheses
09:12:00 <fendor> that would be great! ill try to find an example on hoogle, to see what results look like
09:12:53 * ski is not a calculus
09:12:53 <lostbit> ski are you named after the ski calculus?
09:13:01 <fendor> i was asking myself the same
09:13:31 <ski> see <http://lambda-the-ultimate.org/node/533#comment-7712>
09:14:15 * ski is named after the SKI combinators, yes
09:16:50 * ski . o O ( "SKI" by Maria Kovalyova,Roman Cheplyaka in 2010-01-01 at <https://ro-che.info/ccc/8> )
09:17:51 <int-e> yay, a skiing accident
09:24:41 <dminuoso> solonarv: There is a disturbance in the force. I sense your name being diminished..
09:26:43 <solonarv> nooOOoooooo...
09:26:45 <solonarv> why me?
09:28:14 * hackage haskell-gi-base 0.22.0 - Foundation for libraries generated by haskell-gi  https://hackage.haskell.org/package/haskell-gi-base-0.22.0 (inaki)
09:30:18 * hackage haskell-gi 0.22.0 - Generate Haskell bindings for GObject Introspection capable libraries  https://hackage.haskell.org/package/haskell-gi-0.22.0 (inaki)
09:47:43 * hackage gi-atk 2.0.17 - Atk bindings  https://hackage.haskell.org/package/gi-atk-2.0.17 (inaki)
09:48:44 * hackage gi-webkit2 4.0.21, gi-soup 2.4.18, gi-pangocairo 1.0.19, gi-pango 1.0.18, gi-javascriptcore 4.0.17, gi-handy 0.0.2, gi-gtksource 3.0.18, gi-gtk-hs 0.3.7.0, gi-gtk 3.0.28, gi-gstvideo 1.0.18, gi-gsttag 1.0.17, gi-gstpbutils 1.0.17, gi-gstbase 1.0.18, gi-gstaudio 1.0.17, gi-gst 1.0.18, gi-gobject 2.0.18, gi-glib 2.0.19, gi-gio 2.0.20, gi-gdkx11 3.0.5, gi-gdkpixbuf 2.0.19, gi-gdk 3.0.18, gi-cairo 1.0.19 (inaki)
09:49:44 * hackage gi-xlib 2.0.4, gi-webkit2webextension 4.0.19 (inaki): https://qbin.io/buyer-villa-402m
09:56:35 <tromp> i have a program using Data.Number.FixedPrec which runs under stack ghci, but way too slow. my ghc cannot find module ‘Data.Number.FixedPrec, and stack ghc gives errors about macro expansion of #if ZERO_SLOP_FOR_LDV_PROF || ZERO_SLOP_FOR_SANITY_CHECK
09:59:53 <monochrom> I don't know stack, but the standard thing to do is to completely projectize and stackify your source code so you can tell stack to build/install (the exe) so you get a compiled, optimized exe.
10:01:07 <monochrom> (This is why I don't use stack. Not even cabal-install in extremely simple cases. And this is also why even with cabal-install I still say "cabal v1-install". Everything does not need to be containerized.)
10:02:40 <monochrom> . o O ( Those who trade freedom for containerization should deserve ... ?  >:)  )
10:02:44 * hackage ghc-lib-parser 0.20190603 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-0.20190603 (shayne_fletcher)
10:03:08 <boj> we gain deterministic builds that can be shared among team members :p
10:03:24 <monochrom> Yes that sounds very nice.
10:03:56 <monochrom> Until I recall that my thesis supervisor wisely defined deterministic to be "0 or 1".
10:04:53 <boj> academic vs industry i guess
10:05:35 <monochrom> Oh industry is full of failures. They just try not to talk about them.
10:05:59 <monochrom> Pretty sure even you ran into build failures. You just don't talk about it.
10:06:12 * jgt is an industry failure
10:06:34 <boj> the new v2 stuff did break with that .ghc.environment file and multiple libaries/projects
10:08:52 <monochrom> I appreciate that in industry even though like 90% of the time you run into errors, you stay positive and fix them and get to the 10% time of success, and this is why you try to hire intelligent humans because you need them to fix problems. This is a healthy attitude, I agree with it.
10:09:18 <monochrom> But please don't speak like industry is 100% time success and any mention of possible failure is "theoretical academic talk".
10:09:46 <boj> i think you read a bit too deep into my comment, heh
10:10:07 <jgt> monochrom: that's far from the most annoying — or common — perspective
10:10:46 <jgt> the one I hear *all* the time is "Aha! You see! Haskell/Elm *can* be broken! Therefore it sucks and we may as well just use JavaScript."
10:11:18 <monochrom> Yeah people are full of selective bias.
10:11:43 * hackage ghc-lib 0.20190603 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-0.20190603 (shayne_fletcher)
10:15:20 <dminuoso> monochrom: I find it somewhat confusing. You don't hear anyone ever saying "This field of engineering/music/physics/medicine/mathematics is not applicable since its academic, not industry". You'd think that something well principled enough to attract the attention of academics would be of *particular* use to the industry..
10:17:15 <boj> dminuoso: without the academics we definitely wouldn't be using such an amazing language in industry. what tends to be annoying from this side is when they downplay stuff that tends to be practical (i.e. consistent build system for large teams/projects)
10:18:01 <dminuoso> boj: Programming wouldn't exist at all.
10:18:20 <boj> no disagreements there
10:19:09 <jgt> let's face it — most programming is pop culture
10:19:21 <monochrom> I used to hear "Haskell is academic, not applicable to industry" and "formal methods are academic, not applicable to industry" all the time. The latter was always said to+about Dijkstra.
10:19:55 <jgt> and I want to take every README.md that's filled with emoji, put them all in a bag, and hit that bag with a big stick
10:20:48 <monochrom> I did have a software engineering prof who emphasized consistent build. In fact to the point "you need to pin the compiler version, the OS version, even the hardware".
10:21:05 <jgt> monochrom: I do _almost_ that
10:21:07 <boj> i like this prof
10:21:38 <hexagoxel> jgt: there is an emoji for that, i think :bag-hit-by-club:
10:21:45 <jgt> like, if you use NixOps and you pin the nixpkgs version, it does this by default I think
10:22:33 <monochrom> Wait, there are README.md's full of emoji?!
10:22:46 <solonarv> monochrom: I'm sure you've answered this question before, but what's your use case for v1-install?
10:22:52 <dminuoso> monochrom: Just browse npm a bit.
10:22:53 <jgt> I had a colleague who flooded our docs with emoji, and wrote up instructions on how to install and use Git, on a README in our GitHub
10:22:57 <jgt> I wanted to shoot him
10:23:03 <dminuoso> solonarv: nix?
10:23:14 <monochrom> Such that I can just say "ghci" and have access to my libraries.
10:23:33 <solonarv> ah, v2-install can do that as well! you just need to say 'cabal v2-install --lib <whatever>'
10:23:41 <boj> monochrom: do you collaborate with people often?
10:23:43 <davean> jgt: pins the HW? Damn thats some some fancy nix expressions :)
10:23:44 <dminuoso> solonarv: Im starting to learn that v2 is an interesting breed. It's only nix inspired, but you gain none of the deterministic properties of nix weirdly.
10:23:48 <monochrom> And such that I have deterministic doc pathname.
10:23:55 <monochrom> No.
10:24:12 <jgt> davean: well, I'm not sure exactly, but you _do_ specify exactly which EC2 machine you want to use
10:24:15 <dminuoso> v2-* is only deterministic up to shared hackage states.
10:24:22 <dminuoso> up to shared system states
10:24:47 <jgt> davean: so this probably doesn't _actually_ mean "pinning the hw", but possibly near enough for my purposes?
10:25:11 <jgt> I'm fairly ignorant in this regard (and many others)
10:25:33 <monochrom> Ah the said prof retired long before EC2 became a thing. But I believe he would be please. :)
10:25:59 * jgt feels validated
10:26:57 <dminuoso> jgt: You could always ship your software as a qcow2 file...
10:27:16 <dminuoso> Who cares about performance when you can have true portability!
10:27:43 * hackage mattermost-api 50200.2.0 - Client API for Mattermost chat system  https://hackage.haskell.org/package/mattermost-api-50200.2.0 (JonathanDaugherty)
10:28:09 <monochrom> I think you can manually add some clauses to cabal.project to completely pin dependency versions and achieve reproducible build?
10:28:44 * hackage matterhorn 50200.4.0, mattermost-api-qc 50200.2.0 (JonathanDaugherty): https://qbin.io/bonus-qatar-57c8
10:28:52 <sclv> Indeed you can just pin the hackage state
10:29:24 <monochrom> I'm OK if you reply "too many manual clauses to add. stack is more automatic here."
10:29:27 <dminuoso> You still cant pin the system state (external libraries, build tols, etc) though.
10:29:29 <sclv> cabal v2-freeze
10:29:45 <sclv> it is automatic:-)
10:29:53 <monochrom> Ah OK!
10:30:10 <sclv> agreed that nothing but nix pins the whole system of course
10:30:12 <dminuoso> sclv: Ah I dont use it because I put my trust into PvP (and keep regretting it)
10:30:21 <dminuoso> *PVP
10:30:24 <monochrom> hehe
10:30:50 <sclv> I don’t use it either, and don’t regret it, but i only really build libs with v2. Work projects are all nix
10:31:12 <monochrom> PVP is cool but still need human cooperation. So you're trusting humans via PVP. I'm cynical about humans as you know... >:)
10:31:17 <boj> same, we drop to a shell with nix and build with v2
10:31:36 <dminuoso> I do a mix of nix and v2. The build environment is provided by nix, and the haskell project is built with v2-*
10:31:37 <sclv> The trustee/revisions process helps a lot
10:31:51 <jgt> I'm building with neither stack nor cabal-install, and I don't know what I'm missing
10:32:00 <dminuoso> jgt: How do you build?
10:32:06 <boj> jgt: manually passing it all to ghc?
10:32:11 <jgt> just with nix
10:32:22 <dminuoso> jgt: Ah but that's still using cabal-install
10:32:33 <monochrom> nix and v2 have a lot of overlap.
10:32:44 <jgt> dminuoso: is it? I know I'm using cabal (unavoidable), but I didn't know I'm actually using cabal-install
10:32:51 <dminuoso> jgt: Yes, but its not really an issue.
10:32:51 <jgt> I mean, I build expressions with cabal2nix
10:33:27 <boj> jgt: how are you doing incremental development?
10:33:51 <boj> surely not a full nix-build cycle?
10:33:59 <jgt> boj: GHCi seems to do this just fine, at least with the flags I'm using
10:34:04 <boj> gotcha
10:34:17 <dminuoso> Or wait.. nixpkg is all using Setup.hs, isnt it?
10:34:24 <monochrom> My attitude is don't worry about power tools until your unpowered tools become painful enough.
10:35:08 <monochrom> Like, I would freely admit I have never needed autoconf or automake, my "projects" have been small enough, I handwrite my Makefile.
10:35:18 <jgt> boj: my GHCi looks basically the same for all three of my projects, and it's like this: http://ix.io/1KPT
10:35:59 <boj> jgt: that is pretty slick
10:36:59 <jgt> oh and then I have a tweaked DevelMain.hs to serve the site locally. Basically I started out with yesod-devel, and then I realised this is almost the slowest way to work, and actually GHCi is muuuuch faster
10:37:23 <jgt> I should really write a blog post about my rather patchwork setup
10:37:55 <dminuoso> jgt: Ah I see where my confusion comes from. So it's not using cabal-install, but cabal the library.
10:38:05 <jgt> dminuoso: yes
10:38:18 <jgt> dminuoso: I think there's no way to not use cabal
10:38:38 <dminuoso> jgt: Sure there is. You could just run off with manual invocations to ghc...
10:38:41 <jgt> to avoid confusion, these days I always say cabal-install when I mean the build tool
10:39:08 <jgt> ah, ok, yes that is true
10:39:18 <jgt> but not really viable for my projects
10:39:38 <dminuoso> And to some degree, perhaps that's not *too* silly. I mean we've probably all done our share of Makefiles invoking CC directly..
10:39:40 <jgt> if I'm doing some little Advent of Code puzzle or something, then I'll just build with straight GHC
10:40:43 <boj> my team has about 10 projects and a dozen libraries we maintain, so we opted for the more heavyweight nix/v2 setup. using reflex kind of forced us into nix anyways (something i personally don't mind)
10:40:51 <f-a> cabal new-update is taking ages (more than half an hour), is this normal? I cannot see any problem on status.haskell.org
10:41:12 <boj> f-a: that is not common
10:41:13 * hackage configurator-pg 0.1.0.0 - Reduced parser for configurator-ng config files  https://hackage.haskell.org/package/configurator-pg-0.1.0.0 (vollmert)
10:41:46 <f-a> boj: I am admittedly using a very slow (56kbps) connection
10:42:07 <boj> f-a: ok, maybe that is normal in your case :)
10:42:21 <jgt> f-a: are you in Australia?
10:42:32 <f-a> jgt: italy
10:42:49 <jgt> oh
10:42:56 <jgt> well, then, the Internet speed matches the pace of life
10:42:58 <dminuoso> f-a: That sounds not unreasonable then.
10:43:02 <boj> f-a: the 01-index.tar.gz is about 77mb
10:43:30 <f-a> thanks boj , axing it while I was on a slow connection wasn't my smartest choice
10:43:45 <dminuoso> I was mildly annoyed when I was on the train, punching `nix-build foo.nix` into my terminal and watching it fail due to network issues...
10:43:58 <infinisil> That is a bit of a pain..
10:44:12 <jgt> I wish nixops ssh had an option to run over mosh
10:44:38 <boj> jgt: open a PR!
10:44:59 <boj> and forgo sleep
10:45:19 <jgt> I think it'd be easier for me to just drive to Slovenia and ask domenkozar[m] reeeeaaaaally nicely
10:46:14 <jgt> it's only a minor thing anyway; I'm generally thilled with nix. I even matched to deploy one of my projects from 36,000 feet!
10:48:11 <monochrom> jgt: Your virus project became airbourne...
10:48:13 * hackage debug-dump 0.1.1.0 - File-based debug output  https://hackage.haskell.org/package/debug-dump-0.1.1.0 (vmchale)
10:48:34 <jgt> :D
10:49:13 * hackage configurator-pg 0.1.0.1 - Reduced parser for configurator-ng config files  https://hackage.haskell.org/package/configurator-pg-0.1.0.1 (vollmert)
10:57:13 <d34df00d> Hi!
10:57:22 <jgt> Howdy!
10:57:36 <d34df00d> I'm trying to write some TH code. How do I see at REPL what, say, `reify` says about some sample type?
10:59:28 <d34df00d> I also tried `runQ @IO $ reify 'Foo`, but it fails, complaining about not being able to do reify in IO.
11:01:36 <dminuoso> d34df00d: You have to use a splice instead.
11:02:22 <dminuoso> % :set -XTemplateHaskell
11:02:50 <yahb> dminuoso: 
11:02:53 <dminuoso> % putStrLn $(stringE . show =<< reify ''Bool)
11:02:55 <yahb> dminuoso: ; <interactive>:3:12: error:; * Variable not in scope: stringE :: String -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp; * Perhaps you meant `storing' (imported from Control.Lens); <interactive>:3:31: error: Variable not in scope: reify :: Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.Q ()
11:03:13 <iqubic> Oops.
11:03:23 <iqubic> % :t stringE
11:03:24 <yahb> iqubic: ; <interactive>:1:1: error:; * Variable not in scope: stringE; * Perhaps you meant `storing' (imported from Control.Lens)
11:03:37 <dminuoso> % import Language.Haskell.TH
11:03:38 <yahb> dminuoso: 
11:03:39 <dminuoso> % putStrLn $(stringE . show =<< reify ''Bool)
11:03:41 <yahb> dminuoso: TyConI (DataD [] GHC.Types.Bool [] Nothing [NormalC GHC.Types.False [],NormalC GHC.Types.True []] [])
11:03:46 <dminuoso> d34df00d: ^-
11:03:58 <dminuoso> yahb is just a ghci interface by the way.
11:04:10 <d34df00d> Oh.
11:04:12 <d34df00d> That makes sense!
11:04:14 <d34df00d> Thanks!
11:04:20 <iqubic> I don't understand the inner workings of TH.
11:04:44 * hackage gi-vte 2.91.21 - Vte bindings  https://hackage.haskell.org/package/gi-vte-2.91.21 (inaki)
11:05:16 <dminuoso> iqubic: TH is just Haskell code executed during the parser that is meant to produce haskell code as output. :)
11:05:25 <iqubic> I know.
11:05:38 <iqubic> I understand that it's sorta like Lisp Macros.
11:05:55 <d34df00d> Also, why does reify not want to work inIO?
11:06:11 <iqubic> % :t reify
11:06:11 <yahb> iqubic: Name -> Q Info
11:06:13 * hackage gi-secret 0.0.7 - Libsecret bindings  https://hackage.haskell.org/package/gi-secret-0.0.7 (inaki)
11:06:14 <dminuoso> d34df00d: Presumably because it needs an environment to work in.
11:06:50 <d34df00d> But isn't runQ basically providing that environment and lifting Q into arbitrary` Quasi m`?
11:07:04 <d34df00d> (that is, IO or another Q)
11:07:14 * hackage gi-ggit 1.0.4, gi-girepository 1.0.18, gi-notify 0.7.17, gi-ostree 1.0.8, gi-wnck 3.0.3, gi-poppler 0.18.17 (inaki)
11:07:45 <dminuoso> % :t runQ
11:07:46 <yahb> dminuoso: Language.Haskell.TH.Syntax.Quasi m => Q a -> m a
11:08:14 * hackage gi-dbusmenu 0.4.3, gi-dbusmenugtk3 0.4.4 (inaki): https://qbin.io/morris-suse-xd3t
11:08:15 <c_wraith> reify doesn't work in IO because it looks up a bunch of current compiler state
11:08:24 <c_wraith> IO doesn't have current compiler state
11:12:40 <dminuoso> newtype Q a = Q { unQ :: forall m. Quasi m => m a }
11:13:02 <dminuoso> d34df00d: ^- runQ just unwraps this, so there's no lifting involved. It just allows you to make a pick of which Quasi instance you want to use.
11:13:24 <d34df00d> Ah, I see!
11:13:46 <d34df00d> It doesn't fully make sense for me yet, but what c_wraith said brings me closer to it.
11:14:15 <dminuoso> c_wraith: I presume that the IO instance provides for a poor mans quasi instance in which nothing compiler state related would work right?
11:15:33 <dminuoso> The thing that rather confuses me, is why there is both `unQ` and `runQ` which superficially look to be the same thing..
11:15:54 <dminuoso> I mean you could have written `newtype Q a = Q { runQ :: forall m. Quasi m => m a }`
11:16:43 <dminuoso> d34df00d: https://hackage.haskell.org/package/template-haskell-2.14.0.0/docs/src/Language.Haskell.TH.Syntax.html#runQ right above the source code you can find some hints by the way.
11:29:21 <zeta_0> in emacs, for haskell interactive C-c C-l works but not C-` , why? (13.4.2 Haskell-mode bindings): http://haskell.github.io/haskell-mode/manual/latest/Interactive-Haskell.html https://hastebin.com/qepiyejebu.pl
11:30:13 * hackage inline-c 0.8 - Write Haskell source files including C code inline. No FFI required.  https://hackage.haskell.org/package/inline-c-0.8 (FrancescoMazzoli)
11:31:00 <tromp> @monochrom i'm not that project happy either. why does every little one page program need to be a project
11:31:00 <lambdabot> Unknown command, try @list
11:31:08 <tromp> monochrom i'm not that project happy either. why does every little one page program need to be a project
11:32:12 <boj> tromp: i don't think anyone was saying that, it makes perfect sense to use the bare minimum for a small project
11:35:21 <tromp> nearly all my haskell programming tens to be small single-use single-page programs. so maybe a progr
11:35:31 <tromp> project oriented too is not for me
11:37:06 <tromp> ok, managed to install fixedpred through cabal install, and ghc happily compiles my code
11:38:07 <jgt> tromp: maybe stack scripting is useful for you?
11:38:14 * hackage simple-cmd 0.2.0 - Simple String-based process commands  https://hackage.haskell.org/package/simple-cmd-0.2.0 (JensPetersen)
11:41:34 <tromp> jgt: maybe but i would need time to study it. usually i'm in a hurry to get my little programs running
11:42:21 <tromp> trying yo hack together a solution to IBM's Ponder This May 2019 challenge
11:50:12 <Guest20194> this is supposed to be a place to chat but i have not encountered another person chatting. i have been googling for a while. can someone be helpful?
11:50:51 <jgt> tromp: honestly, it's not a lot to think about. It's like writing a bash script, but for haskell. I _think_ it's what you're after, and should take you all of 5 minutes to completely grok
11:50:54 <boj> Guest20194: if you have a haskell programming question this would be a great place to ask
11:51:13 <dminuoso> Or if you have a type theory question.. or if you have a category theory question...
11:51:15 <dminuoso> We are not picky.
11:51:47 <jgt> Guest20194: "can someone be helpful" sounds a little stand-offish, though I understand if English isn't your first language :)
11:51:55 <jgt> we _do_ chat here, in any case
11:52:07 <jgt> Guest20194: also, "don't ask to ask, just ask"
11:52:51 <Guest20194> what are the consequences for asking a bad question?
11:53:04 <jgt> a useless answer?
11:53:12 <__monty__> Flagellation
11:53:40 <dminuoso> I vote for flagetllation.
11:53:45 <dminuoso> Is it up to a vote?
11:53:45 <jgt> I ask stupid questions all the time and everyone is nice to me
11:54:32 <__monty__> Wait until you get within range of our cat o' nine tails : >
11:54:53 <MarcelineVQ> Guest20194: what is your questioin?
11:55:38 <d34df00d> Next TH question: let's say I have a Type that's a bunch of nested AppT's. What's the best way to replace one VarT that's deep inside with another one?
11:55:44 <d34df00d> uniplate comes to mind, but...
11:56:10 <d34df00d> In other words, I have this: AppT (AppT (AppT (AppT (AppT (ConT Opaleye.Internal.TypeFamilies.TableField) (VarT f_6989586621679124244)) (ConT GHC.Base.String)) (ConT Opaleye.SqlTypes.SqlText)) (ConT Opaleye.Internal.TypeFamilies.NN)) (ConT Opaleye.Internal.TypeFamilies.Req)
11:56:23 <d34df00d> And I want to get this: AppT (AppT (AppT (AppT (AppT (ConT Opaleye.Internal.TypeFamilies.TableField) (VarT $ mkName "a")) (ConT GHC.Base.String)) (ConT Opaleye.SqlTypes.SqlText)) (ConT Opaleye.Internal.TypeFamilies.NN)) (ConT Opaleye.Internal.TypeFamilies.Req)
11:56:59 <Guest20194> I don't even know what a monad is (i suppose it's danom backwards)
11:57:43 * hackage gi-gio 2.0.21 - Gio bindings  https://hackage.haskell.org/package/gi-gio-2.0.21 (inaki)
11:57:54 <qwebirc96382> Hi, I'm looking to set up Haskell in as simple a way as possible so I can play around with ghci and get my feet with with haskell.  Any recommendations for set up on Mac
11:59:49 <jgt> Guest20194: a monad is a typeclass. Do you know what a typeclass is?
12:00:11 <jgt> qwebirc96382: try installing Stack
12:01:12 <qwebirc96382> Do I need to create a new project in order to invoke Stack?  It seems like it comes with much more than I anticipate needing.
12:01:21 <lostbit> Guest2019 how come you mention danom?
12:01:35 <Guest20194> is it as simple as an interface?
12:02:19 <Guest20194> lostbit just saw it somewhere. not aware of any special meaning behind it.
12:02:21 <jgt> Guest20194: it's an abstraction. If you understand that a "number" is anything you can do numerical operations on, then you should understand this kind of abstraction
12:02:54 <jgt> e.g., you don't think of summing floats and summing integers as completely different concepts
12:02:57 <jgt> you just sum numbers
12:03:21 <jgt> in Haskell, things that share the same operations are grouped into "typeclasses"
12:03:26 <jgt> monad is a typeclass
12:03:43 <jgt> so, anything that you can do monad-y operations on is a monad
12:04:20 <jgt> and for practical purposes, you can think of it as anything that you can lift a function over, and also concatenate it with another monad
12:04:44 <Guest20194> Isn't this just overloaded operators that implicitly oeprate on different types of data?
12:05:30 <jgt> well it isn't _implicit_, but yeah that's the idea behind typeclasses
12:05:43 <jgt> they are tables of functions
12:05:51 <MarcelineVQ> qwebirc96382: no, you can type stack exec ghci --package somepackage to load up a ghci with a particular package available to try out
12:06:48 <MarcelineVQ> qwebirc96382: But anything more than that it's a good idea to make a project anyway, this is also true of using cabal.
12:07:12 <Guest20194> How does this tie into 'state'? My idea was that a monad was something to do with assignment. Thank you for the responses!
12:07:55 <qwebirc96382> thanks!
12:08:04 <jgt> Guest20194: monads — as a concept — don't directly have anything to do with state
12:08:36 <Guest20194> I see
12:09:08 * jgt is waiting for a real haskeller to tell me my monad explanation is completely wrong and dumb
12:09:08 <boj> there is the State monad, however, which threads a state variable through your computation
12:09:31 <boj> jgt: that was a decent explanation if you ask me
12:09:40 * jgt is flattered and delighted
12:10:47 <Guest20194> I'm delighted, too!
12:12:02 <Guest20194> What does haskell do differently than some other functional language? I am a little familiar with (pure) functional programming
12:12:24 <boj> purity/lazy evaluation are probably the bigger points
12:12:24 <lostbit> Guest20194 convenient infinite structures being lazy i suppose
12:13:30 <lostbit> my favourite is probably the syntax compared to other languages, subjective though
12:13:31 <Guest20194> lazy evaluation is not hard to do though, all you need is a langauge with lambdas (I think)
12:14:13 <jgt> I think it's hard to express just how fundamentally game-changing purity is
12:14:25 <jgt> in terms of being able to maintain software over time, especially
12:14:33 <nitrix> Other than purity and lazy evaluation, I find the type system to be very rigorous and advanced. Higher-kinded polymorphism is still poorly supported by many. The type-in-type or GADTs stuff is pretty cool too.
12:14:34 <c_wraith> just lambdas only gives you call-by-name. laziness (call-by-need) requires a bit more.
12:15:11 <int-e> Guest20194: with just lambdas you tend to lose sharing though... (a lazy value is supposed to be evaluated at most once)
12:15:50 <Athas> I don't think the laziness is that important.
12:16:10 <boj> i didn't grasp the merits of laziness until after using the language for awhile, so it can probably be safely ignored as a beginner
12:17:12 <lostbit> can also be a bad thing so maybe that is more of a neutral point
12:18:43 <monochrom> My meta-level gripe is that people don't going into ##c and start talking about "eager evaluation has its pros and cons..."
12:19:07 <jgt> Guest20194: related: https://www.youtube.com/watch?v=DebDaiYev2M
12:19:25 <Guest20194> Lazy evaluation is just making a very simple change in the evaluation strategy. The procedure body is evaluated first instead of the operands. I am asserting this, maybe I should ask instead :)
12:19:38 <jgt> monochrom: technologies are compared under completely unfair standards
12:20:51 <Guest20194> jgt thanks for the link
12:20:57 <nitrix> Maybe we can put the focus on the abstractions that can be built at every levels (value level / type level / kind level) while still maintaining purity.
12:21:25 <nitrix> To me, Haskell is sort of the DRY principle taken to the extreme.
12:21:45 <ski> jgt : nitpick. a monad isn't a type class. a monad (in Haskell terms) is something which is a instance of the type class `Monad' (satisfying laws)
12:21:49 <ski> jgt : also, you don't do "monad-y operations on" monads. monads aren't values you operate on. e.g. `getLine' (a value-level thing), of type `IO String', isn't a monad; `IO' itself (a type-level thing) (together with its associated implementation of `return' and `(>>=)') is a monad
12:21:55 <nitrix> Except that it has a mathematical elegance to it.
12:22:34 <boj> jgt: there you go, a real haskeller answer :p
12:22:50 * boj puts his imposter syndrome hat back on
12:23:08 <lostbit> might as well be the pythagorean cult over here
12:23:26 <monochrom> "there is no such thing as irrational monad".
12:23:29 <ski> Guest20194 : "lazy evaluation is not hard to do though, all you need is a langauge with lambdas (I think)" -- no, that's not the same thing. you can *simulate* laziness, sure. but that doesn't mean that the language (or an implementation of it) has a lazy (operational) semantics
12:23:38 * jgt is in the right room (if you're the smartest person n the room, you're in the wrong room, etc)
12:24:11 <monochrom> The smartest person in the whole world is always in the wrong room then. >:)
12:24:33 <monochrom> Also, if you are alone in a room, you are in the wrong room?
12:24:36 <ski> (lambdas doesn't give you by-name either. the question is simply wrong)
12:24:36 <jgt> …or they're outside!
12:24:58 <monochrom> ski: How doesn't lambda give you call-by-name?
12:25:06 <nitrix> jgt: I like that mentality. I compiled a list of things that I picked up while learning Haskell and intend to write about at some point. https://notes.nitrix.me/programming/ideas
12:25:19 <nitrix> jgt: It grew pretty large very quickly. You learn a lot here (:
12:25:20 <lostbit> by the way has anyone tried haskell like languages like Clean?
12:25:43 * hackage fedora-img-dl 0.4 - Fedora image download tool  https://hackage.haskell.org/package/fedora-img-dl-0.4 (JensPetersen)
12:25:50 <ski> monochrom : you can consider both by-value and by-name operational semantics for a language with lambda ?
12:26:11 <monochrom> Yes.
12:26:40 <ski> it's not lambda which gives by-name, it's the operational semantics you pick
12:26:49 <monochrom> OK are you just saying "using '\() -> ...' is an encoding not the real thing"?
12:26:58 <ski> yes
12:27:07 <monochrom> Ah OK no problem then.
12:27:10 <Guest20194> ski l) semantics
12:27:21 <ski> you could think of it as being a translation from one language to another (possibly sharing the same syntax)
12:27:26 <monochrom> As usual I am against all encodings. >:)
12:27:38 <Guest20194> ski -- messed up copy past. i don't understand what you mean about *simulate*
12:28:36 <ski> "people don't going into ##c and start talking about \"eager evaluation has its pros and cons...\"" -- possibly because they haven't heard of eager evaluation ? ;)
12:29:39 <Guest20194> "you can *sumulate* laziness, sure. . ."
12:29:55 <ski> lostbit : "might as well be the pythagorean cult over here" -- haha, ty :D
12:31:06 <ski> jgt : anyway, i don't think your explanation was that bad :)
12:31:33 <ski> lostbit : i've tried Clean a little bit. not in recent years, though
12:31:48 <ski> lostbit : uniqueness is cool (Mercury also has it)
12:32:58 <jgt> ski: I understand my explanation was not _correct_, in the sense that saying "a functor is basically anything you can map over" is also not _correct_, but it's at least useful for practical purposes (especially to a beginner)
12:33:21 <jgt> ski: was my monad explanation at least useful in that same sense? Or was it so wrong that it was potentially harmful?
12:33:34 <lostbit> ski thanks by the way are you a mathematician?
12:33:44 <jgt> (not being defensive, would just like to be better at explaining these things in very-layman terms)
12:34:07 <ski> Guest20194 : if you can't write something like `f(1/0)' (`f' being an ordinary function), where `1/0' is an expression that when evaluated aborts ("crashes") the program (perhaps by raising an exception / signalling a condition), and have that call terminate normally (returning a result as usual), then you can't claim having by-name or lazy / by-need operational semantics
12:35:37 <ski> Guest20194 : of course, you can *simulate* the desired behaviour, by something like `f(\() -> 1/0)' (using Haskell syntax for lambda expressions / anonymous functions / function abstractions/literals/aggregates, here)
12:35:40 <nitrix> ski: That makes me wonder, where would Lisp macros fall into in this case?
12:36:51 <ski> (or, perhaps wraping that lambda in something which will cache the result, like suspensions in SML/NJ. or even having an explicit `lazy' construct as in O'Caml)
12:37:13 <ski> nitrix : syntax applications aren't function applications
12:38:21 <ski> jgt : i think it was ok. it at least got some things right, focusing on some of the important points ;)
12:39:27 <ski> lostbit : i have some math education
12:39:29 <Guest20194> You can write a language evaluator in any turing complete language such that is essentially an interface for language. I feel like I'm missing your point. I am not experienced.
12:41:40 <ski> jgt : perhaps i'm sometimes a bit obsessively focusing on nitpicking on what can be, in the overall picture, minor points. my intention is to inform (and discuss), hopefully leading to a higher level of understanding for both parties
12:41:40 * jgt is relieved
12:42:38 <jgt> ski: I absolutely appreciate that; don't get me wrong. I'd never say that these details aren't important, and I encourage everyone to continue learning. I just think the learning curve has to start somewhere.
12:44:04 <ski> Guest20194 : the point is about what modes are *reasoning* are available in different languages. e.g. it doesn't matter that we can compile Haskell to C (though we no longer tend to do that), which has side-effects. that doesn't mean *Haskell* has side-effects
12:44:16 <ski> s/what modes are/what modes of/
12:45:42 <ski> Guest20194 : the power of a language isn't only measured in the "features" that it supports (how you can more easily write code to achive certain results), call this the "expressive power" (or "cavalier power") of the language
12:47:01 <ski> Guest20194 : but also it is measured in the modes of reasoning (e.g. used when refactoring, analyzing code, generally maintaining code, relating to composability and modularity) that it supports, call this the "reasoning power" (or "predictive power") of the language
12:47:14 * hackage haskell-gi 0.22.1 - Generate Haskell bindings for GObject Introspection capable libraries  https://hackage.haskell.org/package/haskell-gi-0.22.1 (inaki)
12:47:30 <ski> Guest20194 : typically, if you try to increase one of these two, then the other one will have to suffer. it's generally a trade-off
12:48:28 <ski> Guest20194 : in rare cases someone figures out a way to phrase/express a feature, such that "reasonability" isn't undue lowered
12:49:11 <Guest20194> ski I'm taking notes lol. I'll look into these terms
12:49:32 <ski> jgt : absolutely. i don't want to scare people having less time/experience with the language away from attempting to explain : it can be an important part of how you learn
12:49:43 <jgt> ski++
12:51:08 <ski> Guest20194 : i'm not sure the quoted terms here (apart from "expressive power", aka "expressivity") have been used much by other people (though i remember seeing a few people on #scheme coming to similar conclusions), than on this channel
12:53:44 * hackage text-show-instances 3.8.1 - Additional instances for text-show  https://hackage.haskell.org/package/text-show-instances-3.8.1 (ryanglscott)
12:53:49 <ski> Guest20194 : you could try "On the Expressive Power of Programming Languages" by Matthias Felleisen in 1990 at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.4656> (the PDF link)
12:53:56 <Guest20194> Paul Graham wrote about expressive power IIRC. That's the only place I remember it. I know a little Scheme (SICP exercises)
12:54:25 <Guest20194> Oh boy... that gave be goose bumps
12:54:38 <ski> yea, it's quite possible SICP mentions it
12:54:38 <Guest20194> The Little Schemer is probably my favorite book 
12:54:49 <ski> <https://en.wikipedia.org/wiki/Expressive_power_%28computer_science%29> seems to indicate so
12:54:50 <Guest20194> I will look up the title you mention
12:55:00 <ski> @where SICP
12:55:00 <lambdabot> "Structure and Interpretation of Computer Programs" <http://mitpress.mit.edu/sicp/>,<http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/>,<https://github.com/sarabander/sicp-pdf> | "
12:55:00 <lambdabot> Storage and Identification of Cabalized Packages" <http://www.vex.net/~trebla/haskell/sicp.xhtml>
12:57:04 <ski> yeah, the books "The Little Schemer","The Seasoned Schemer","The Reasoned Schemer" at <https://www.ccs.neu.edu/home/matthias/BTLS/>,&c. always looked interesting, to me
12:58:35 * ski twitches
12:58:40 <ais> can someone explain what this: https://github.com/github/semantic is used for?
13:00:06 <Tuplanolla> Apparently it's for "parsing, analyzing, and comparing source code".
13:00:16 <ski> Guest20194 : coming back to effects vs. side-effects. i don't care (in this context) about how things are implemented. i care about the reasoning laws that are valid to use, at the *level* of the language (Haskell, here), not at some implementation level
13:00:32 <Guest20194> The Little Schemer is maybe the best way to learn about recursion, repetition without state variables, all the goodies : )
13:00:48 <Guest20194> That makes a lot of sense
13:02:04 <ais> :Tuplanolla i got that part, but in what context. Is the diff command something like `git diff`, is it used stand alone, or with something else etc.
13:02:17 <ski> Guest20194 : an encoding of laziness that you do, by hand, is effectively a compiler that you run inside your head. it doesn't change how you can reason in the language you write (but then, when you reason in your head at the level of the language that you are encoding, then that has laziness, in this case. something similar happens with monads)
13:02:51 <Tuplanolla> I think it's supposed to be similar, but optionally blind to formatting, variable renaming and other superficial changes, ais.
13:03:26 <ski> Guest20194 : monads are basically DSLs for encoding various kinds of languages with side-effects, into Haskell, in a way that the corresponding Haskell code doesn't have side-effects, but merely *effects* (the difference being that they're explicit, not implicit, in interface, and implementation)
13:03:42 <ais> ah, ok 
13:04:22 <ski> Guest20194 : state in a state monad is just as hard to reason about, in Haskell, as state in a language with state side-effects. the difference is that you localize the damage done to when you're actually using state actions
13:04:50 <Guest20194> Ok this is very helpful
13:04:53 <ski> Guest20194 : one way of thinking about it is to say that one of the greatest points of monads in Haskell is that you know when you're *not* using one
13:07:16 <ski> a *side*-effect happens on the *side*, of evaluating some expression. it's not part of the main result. usually it's not declared / accounted for in the interface / signature / prototype. and you can't see the difference between a function call that computes an integer that might have a side-effect, and one which can't
13:07:53 <ski> by making effects explicit (in interface/types) and also in implementation (in expressions), we're removing the "side" part
13:10:34 <ski> if i write `let act = getLine in do act; act', i know this is the same as `do getLine; getLine', simply because `act' is a variable bound to the action `getLine', and one can always "replace equals with equals" in Haskell, it doesn't matter that we're talking about I/O actions here
13:10:43 * hackage digraph 0.1.0.2 - Directed Graphs  https://hackage.haskell.org/package/digraph-0.1.0.2 (fosskers)
13:12:20 <ski> so, by turning "side-effects" into "effects", by being explicit about them, we allow more modes of reasoning ("equational reasoning") in the language, which helps with the "reasoning power" part i mentioned
13:20:25 <Guest20194> the value of getLine will not always be the same at different points in time
13:21:16 <dminuoso> Guest20194: It will, that's the point.
13:21:16 <Guest20194> (posed as a question)
13:21:35 <Guest20194> How could getLine every be useful then, I am not understanding
13:21:54 <dminuoso> That question is actually a good one.
13:21:57 <ski> @quote recipe.is.not
13:21:57 <lambdabot> ski says: <ski> `getLine :: IO String' is a recipe for how to interact with the world to acquire a `String'  <ski> the recipe is not the cake
13:22:07 <dminuoso> Guest20194: How can a recipe be useful, if the recipe is always the same?
13:22:12 <ski> @quote /bin/ls
13:22:12 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
13:22:36 <dminuoso> Guest20194: getLine is not a String, this is the important part. It also doesn't give you a string.
13:23:00 <ski> "executing" `getLine' will give you a `String'. but execution is not evaluation
13:23:12 <dminuoso> You could, perhaps, think of it as a list of machine instructions that, if executed, were to give you a string.
13:23:23 <ski> evaluation of an expression does not trigger execution of actions
13:23:24 <dminuoso> So the list of machine instructions that getLine compromises will always be the same.
13:23:34 <ski> (but the other way around is common)
13:23:54 <ski> "a recipe for how to interact with the world"
13:23:57 <int-e> Haskell is pure, it leaves executions to somebody else.
13:24:36 <dminuoso> Guest20194: We get to have essentially the best of both worlds. We get to have effects and purity at the same time.
13:25:46 <ski> I/O actions only get executed by being made part of the `main' I/O action (the starting point of the program)
13:26:48 <ski> (well, in interactor, you can also type in actions, and they'll be executed by the interactor (conceptually after evaluating them to an action value. "determining which recipe to follow". in practice, the evaluation and execution portions of a program are typically interleaved)
13:27:25 <ski> (s/in interactor/in the interactor/. aka REPL (Read-Eval-Print-Loop). like e.g. GHCi)
13:28:25 <ski> merely having a function return an action (or a list, say, of them), doesn't cause the actions to execute
13:29:10 <dminuoso> Guest20194: If you consider the "think of getLine as a list of machine instructions", then evaluating what machine instructions the list is made up of does not cause any effects. It doesn't trigger any interaction with the kernel.
13:29:35 <ski> if you evaluate `length (reverse [getLine,putStrLn "help, i'm trapped inside a list !"])', then no I/O is performed
13:30:12 <dminuoso> Guest20194: Because after all, computing the instructions needed for an effect is vastly different from executing the same instructions.
13:34:02 <halogenandtoast>  One more hour until my first Haskell-related interview. Here's hoping I don't bomb it somehow.
13:34:24 <Guest20194> Good luck!
13:34:32 <int-e> leave the explosives at home
13:34:52 <halogenandtoast> int-e: It's an online interview, so I am at home as well.
13:35:06 <halogenandtoast> Maybe I should put them outside.
13:35:33 <halogenandtoast> Thanks Guest20194 
13:35:57 <Lycurgus> if you meant kids or loud dogs, a good idea
13:35:58 <ski> better hide away your bomb making instructions, so they're not visible
13:36:04 <dminuoso> 06:43:18 <ski> dminuoso : yes <- thank you. So I take it that ⌜withDict :: HasDict c e => e -> (c => r) -> r⌝ is modus ponens then?
13:36:10 <halogenandtoast> Lycurgus: I have both.
13:36:10 <ski> (and "The Anarchists Cookbook")
13:36:32 <halogenandtoast> ski: I think the most "questionable" book I have is Godel, Escher, and Bach
13:36:50 <Lycurgus> do you know what they call face tattoos? job killers. I find that funny.
13:37:04 * ski questions halogenandtoast choices in questionable books
13:37:07 <ski> ;)
13:37:27 <Lycurgus> GEB establieshed the hofstader franchise
13:37:27 <halogenandtoast> I am not saying it is questionable, but it does raise a lot of questions.
13:37:52 <Lycurgus> actually surfaces and essences is prolly most useful
13:38:05 <ski> now, that's that kind of statement that could get you into questioning
13:38:42 <halogenandtoast> I mean other than that, I have a lot of books about compilers and compiler related topics: Garbage Collection, Virtual Machines, etc.
13:38:57 <halogenandtoast> A book on TCP, Unix Programming, and the like
13:39:17 <dminuoso> Well I guess the older version ⌜withDict :: Dict a -> (a => r) -> r ⌝ is a bit more obvious.
13:39:35 <ski> dminuoso : i suppose so
13:39:48 * ski was just reconstructing that older version in head
13:40:17 <Guest20194> do u have a lot of experience with compilers halogenandtoast ?
13:41:06 <dminuoso> ski: Presumably the typeclass itself would be the proposition and instances would serve as proofs?
13:41:29 <ski> which type class ? `HasDict' ?
13:41:37 <dminuoso> ski: No, `a`
13:42:08 <ski> `a' is a constraint. values of type `Dict a' contain evidence for the constraint
13:42:27 <ski> so those values "are" (correspond to) proofs of `a'
13:42:41 <solonarv> dminuoso: so yes, that's about right - typeclasses are (parameterised) propositions, and instances are proofs for some particular choice of parameters
13:43:02 <imjacobclark> Hi, I am calling the Spotify API via WREQ and using Aeson to 'eitherDecode' into a series of data instances via FromJSON - the problem is, my first API call is to get the Tracks, but I need to make a second call to another Spotify API Endpoint to get the track genres, I'd like to modify my original Artist data type that was constructed in the first request with my new Genre, but I'm unsure how to d
13:43:03 <imjacobclark> o this. This is my Aeson data type parser: https://github.com/imjacobclark/Recify/blob/master/src/Types/RecentlyPlayed.hs - could anybody help point out a way?
13:44:14 <imjacobclark> I could create a totally separate data type for Genres, and construct it separately, and join the two data types via an fmap on the artist ID each time I need it, but not sure this is optimal...
13:45:33 <ski> dminuoso : i suppose you could also check out the type class `(:=>)'
13:49:23 <dminuoso> ski:  So I was thinking about (:-) and thought that this is just a different version of implication. Dict would give me reified proofs as values (so I can talk about things like ⌜a ∧ b ⌝ as ⌜(Dict a, Dict b)⌝ 
13:50:20 <dminuoso> ski: And the word "implication" is actually interesting since I've read some papers talking about type inference/typeclasses (SPJ?) that talk about these relationships of instance class/instance head and superclass/class using the word "implications"
13:50:47 <dminuoso> class Class b h | h -> b where cls :: h :- b 
13:50:59 <ski> hm, and `instance a => HasDict b (a :- b)'
13:51:05 <dminuoso> class b :=> h | h -> b where ins :: b :- h 
13:51:11 <mpickering> Are there some good maintained bindings to any javascript visualisation/plotting libraries?
13:52:12 <ski> yes, `a :- b' is basically `Dict (a => Dict b)', or expressing evidence for `instance a => b' as a value
13:52:40 <Rembane> imjacobclark: I'd go for creating a separate data type for Genres and then putting them in the right place. 
13:53:10 <Rembane> imjacobclark: The other way around would be to have promises/futures or something and that seems like a more painful solution.
13:53:11 <jgt>  
13:53:23 <imjacobclark> Rembane: "putting them in the right place" - is this as simple just an fmap join on ID?
13:53:36 <imjacobclark> Or create a compound data type RecentlyPlayedWithGenre later on?
13:53:46 <Rembane> imjacobclark: fmap over what?
13:53:54 <ski> dminuoso : being able to say things like `instance (forall a. Show a => Show (f a)) => Show (Fix f)' could be useful (cf. `Show1')
13:54:13 <imjacobclark> Sorry, I basically I have a list of [Songs] with an ID property in them, I will use this to collect the Genres of songs 
13:54:54 <ski> dminuoso : one could argue that the arrow in `class Eq a => Ord a' is pointing in the wrong direction, perhaps. or one could argue that it's about presuppositions, not an implication
13:54:58 <imjacobclark> Rembane: the genre of songs will effectivley be separate instances to my [Songs] array, but I can join the two by ID later on
13:55:14 <Rembane> imjacobclark: Yeah, that's the approach I would go for. 
13:55:19 <dminuoso> ski: Indeed. The class Class makes this obvious.
13:55:22 <imjacobclark> Rembane: Brill, thanks! 
13:55:24 <imjacobclark> Simple is best  :) 
13:55:28 <Rembane> imjacobclark: No worries. Good luck! 
13:55:29 <dminuoso> class Class b h | h -> b where cls :: h :- b
13:55:51 <solonarv> ski: ah, but if you lower typeclasses/instances/implication to records/dictionaries/functions the direction of => makes sense again
13:55:52 <dminuoso> Making it obvious that `h implies b` for `class h => b`
13:56:04 <dminuoso> Uhh hah. Mistake made there. `class b => h` of course.
13:56:06 <ski> dminuoso : in the second view, it's not that `Ord a' implies `Eq a'. it's that you can't even state/form `Ord a' without assuming `Eq a' as a presupposition
13:56:10 <solonarv> oh wait, you meant in 'class' declarations, mb
13:57:03 <ski> solonarv : yes, that's what i'm talking about. the `=>' in `instance Eq a => Eq [a]' doesn't seem to mean the same thing as the `=>' in `class Eq a => Ord a'
13:57:32 <dminuoso> ski: Even more confusingly, the implication order is flipped around
13:57:32 <solonarv> fair enough!
13:57:33 <ski> (doesn't seem to mean the same, or even a similar/analogue, thing)
13:58:01 <ski> dminuoso : *if* it's sensible to think of it as an implication in the first place. i'm not convinced of that
13:58:22 <dminuoso> ski: Well it allows me to formulate the implication. This is leveraged by the type inference.
13:58:41 <dminuoso> (Well Im thinking it might be)
14:00:37 <ski> if you formulate `1/x > 0 => x =/= 0', then the conclusion there isn't really a consequence (in a relevant way) of the antecedent. rather even the formulation of the antecedent forces an implicit assumption (a presupposition) that `x =/= 0', which obviously then proves the consequent
14:01:38 <ski> (well, obviously, if `1/x > 0', then also `x > 0', and so `x =/= 0'. but that conclusion is already available to you directly as an (implicit) assumption, is the point i'm making)
14:03:05 <ski> in general, to form an implication `A => B', you can say that you must (a) be able to form `A'; and (b) be able to form `B', under the assumption (presupposition) that `A' is *true*
14:03:41 <ski> and ditto, for forming `A /\ B'. you may freely use a presupposition that `A' is true, when forming `B'
14:03:53 <ski> ("forming" here basically means "type-checking", btw)
14:05:10 <ski> so, while `f(1/x) > 2' does have as a presupposition that `x =/= 0', the compound formulae `x > 2 => f(1/x) > 2' and `x > 2 /\ f(1/x) > 2' does *not* have that presupposition
14:05:28 <dminuoso> ski: https://www.microsoft.com/en-us/research/wp-content/uploads/1997/01/multi.pdf is the paper I was referring to by the way.
14:05:49 <dminuoso> ski: That one uses that concept of entail for a type inference schema.
14:06:09 <ski> sometimes, people say things like the function `(\\)' taking two arguments of type `Eq a => [a]' (and presumably result of same type ?)
14:06:44 <ski> however, it's better to say that the (common) parameter type is `[a]', with `Eq a' being a presupposition
14:07:13 <ski> (perhaps that can clarify to some extent what i mean by "presupposition")
14:08:40 <ski> dminuoso : oh, the note on page four
14:09:30 <dminuoso> ski: The context reduction there seems to reflect exactly what you say.
14:09:56 <dminuoso> ski: So `{Ord a, Eq a} -> {Ord a}` is equivalent to tossing away redundant information
14:11:37 <dminuoso> But I guess it's not just related to superclasses but any type of entailment
14:11:41 <dminuoso> I mean if you have `Q :- P` then any context reduction {Q, P} -> {Q} would be a valid.
14:11:54 <ski> dminuoso : .. there's also the difference between entailment and implication, but i was more or less glossing over that here
14:12:10 <dminuoso> Mmm.
14:12:33 <ski> (that's just a distinction from basic logic)
14:13:11 <dminuoso> I see.
14:15:18 <ski> an entailment is a relation in the meta-language, about object-level formulae. an implication forms a new formula/proposition out of old ones
14:16:23 <ski> an implication `A => B' is about expressing/imagining a situation where, if `A' were to hold, `B' would also have to hold
14:16:50 <ski> but we can form such a proposition, even if it can't actually happen
14:16:52 <iqubic> Looks like the Curry-Howard Isomorphism to be.
14:17:26 <ski> otoh, an entailment `A |- B' expresses that, in *fact*, `B' holds in all situations where `A' holds
14:17:43 <ski> an entailment is an assertion being made, by an agent
14:18:13 <ski> (an entailment is a kind of judgement)
14:18:47 <ski> inference rules (in logic) operate not on propositions, but on judgements. conjunction-introduction says that if `|- A' and `|- B', then `|- A /\ B'
14:19:18 <dminuoso> ski: What does `|- A` denote here?
14:19:41 <ski> (but often people leave out the `|-' part of `|- A', which could also possibly sometimes be expressed as `A true')
14:19:54 <ski> that we're *claiming* that `A' holds
14:20:12 <dmwit> A fun parable by the eminent logician Lewis Carroll: https://en.wikipedia.org/wiki/What_the_Tortoise_Said_to_Achilles
14:20:55 <dminuoso> ski: Ah so that's just an axiom?
14:21:29 <dminuoso> I mean.. is that just an ascii approximation, or would you write it exactly like that?
14:21:51 <ski> no. the rule says something like : if we're justified in claiming `A' holds, and also we're justified in claiming `B' holds, then we're justified in claiming `A /\ B' holds
14:22:15 <dmwit> "|-" is an ASCII approximation of ⊢
14:22:37 <dmwit> But it's not really important. You can call the relation |- instead of ⊢ if you want and nothing interesting changes.
14:22:47 <ski>   ⊢ A
14:22:50 <ski> in unicode
14:22:55 <ski> yes
14:23:05 <ski> dminuoso : you could try reading "On the Meanings of the Logical Constants and the Justifications of the Logical Laws" by Per Martin-Löf in 1996 at <http://www.ae-info.org/attach/User/Martin-L%C3%B6f_Per/OtherInformation/article.pdf>
14:23:36 <ski> it goes a bit into the history of the terms used, and the philosophy of it
14:23:46 <ski> (from a constructive standpoint)
14:25:12 <dminuoso> ski: Ah okay. Just not familiar with this writing. In HM I've seen a capital gamma used as "the environment" `Γ ⊢ ...`, is this equivalent? 
14:25:28 <dminuoso> Taking a look at the pdf now.
14:25:40 <ski> that's the "explicit", Gentzen-style version of Natural Deduction
14:25:55 <ski> i was referring to the "implicit", Prawitz-style version
14:25:58 <librehask> Is anybody else having problems installing hlint? It's failing with a long nasty rant from the compiler for me =(
14:26:00 <ski> (just for simplicity)
14:26:11 <dminuoso> ski: Alright, I guess the confusion is cleared up then.
14:26:58 <ski> with the explicit style, you have more explicit control of the environment, not leaving the handling of it up to the meta-logic
14:27:17 <ski> the implicit style is not as verbose, but is more meta-circular
14:28:13 <ski> in the explicit style, we have a rule saying that if `Gamma,A |- B', then `Gamma |- A -> B'
14:28:35 <ski> in the implicit style, we have a rule saying that if `|- A' implies `|- B', then `|- A -> B'
14:28:42 <dminuoso> ski: If only I had read this before TaPL (I suppose this is reason enough to go back) - this was a major source of confusion.
14:29:39 <dminuoso> ski: What does the comma denote there?
14:29:49 <ski> for type systems, usually the intension is more to implement in a program, rather than use them much by hand, and so the verbosity of Gentzen-style isn't as much of a problem
14:29:53 <bor0> dminuoso, I found this to be really helpful: https://bor0.wordpress.com/2019/02/21/coc-base-terms-type-and-prop/ - also, this might be useful before starting with TaPL: https://bor0.wordpress.com/2019/03/15/writing-a-simple-evaluator-and-type-checker-in-haskell/
14:30:38 <bor0> (on the first blog post you can only pay attention to the image, not the actual content)
14:30:48 <d34df00d> Flag-style representation of Gentzen-style deduction also aids a lot with verbosity IMO.
14:30:49 <ski> dminuoso : in the explicit style, you have a list (or bag, or set. it depends) of formulae to the left of `|-'. but you can think of `,' there as "and" (but not the object-level conjunction connective)
14:31:14 <ski> d34df00d : "Flag-style representation" ?
14:31:23 <Gurkenglas> Someone recommend me a library to write a web page buttons-and-simple-graphics game.
14:32:00 <d34df00d> I saw a reference to TAPL above, and it represents derivations in tree-style.
14:32:01 <Gurkenglas> (Ideally one that might at some point be extendable to allow online player interaction)
14:32:09 <ski> dminuoso : oh, and did i ever mention this paper to you :
14:32:11 <d34df00d> Which is verbose and requires a lot of repetitious drawing.
14:32:20 <ski> @where polymorphic-type-inference
14:32:20 <lambdabot> "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <https://cs.au.dk/~mis/typeinf.p(s|df)>,<http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.57.1493>
14:32:32 <d34df00d> A nicer way is flag-style, but I don't know how to show that via IRC :)
14:33:06 <d34df00d> https://en.wikipedia.org/wiki/Fitch_notation although that's ugly.
14:33:07 <dminuoso> ski: Not directly to me, but I have it downloaded already - you recently mentioned it to someone else.
14:33:15 <dminuoso> (I think)
14:33:23 <d34df00d> http://mirrors.rit.edu/CTAN/macros/latex/contrib/flagderiv/flagderiv.pdf has some examples.
14:33:34 <ski> dminuoso : oh, right. you basically mean the "nested boxes" thing, yes ?
14:33:36 <ski> er
14:33:39 <ski> d34df00d ^
14:33:41 <d34df00d> Yea.
14:34:00 <d34df00d> The transformation between the two is almost syntactical.
14:34:17 <ski> d34df00d : conceptually, i prefer the trees (but one can of course write them concretely, on the side, if one prefers, with indentation)
14:34:23 * ski nods
14:35:21 <d34df00d> Dunno, trees feel like having too much of overhead.
14:35:35 <d34df00d> Although it feels "safer" in some sense to meta-analyse the logic or type theory in question in tree format.
14:35:41 <d34df00d> At least, subjectively for me.
14:36:30 <ski> d34df00d : the "repetition" ("Rei") rule/justification (on page 9) is a typical idiosyncracy of this style
14:36:53 <dminuoso> ski: I appreciate the reading material, Ill take a closer look over the next few days. Thank you for the input as always, and have a good night!
14:37:04 <ski> good night, dminuoso, pleasant dreams
14:37:13 <d34df00d> When I did some exercises using this style I just dropped such obvious things.
14:37:35 <d34df00d> Although weakening rule in CoC would be uglier :)
14:37:46 <ski> elaborate ?
14:37:47 <d34df00d> (or is it thinning? I always confuse the two)
14:38:12 <ski> weakening is the same as thinning is the same as dilution (rare term to be used)
14:38:19 <ski> as least, afaik
14:39:13 <ski> i prefer the trees, from the conceptual standpoint, because they more clearly show how subarguments are independent of each other
14:39:27 <d34df00d> IIRC the base rule in the metatheory of the CoC allows adding a new binding to the end of the environment, and then a lemma could be proven that an extra binding can be put anywhere in the environment (assuming obvious conditions on name collisions in both cases).
14:40:12 <d34df00d> Re ugliness, IIRC the rule in the definition of CoC, you'd have to pull the extra item in the environment using O(|environment|) applications of the weakening rule.
14:40:32 <d34df00d> And the weakening rule requires essentially duplicating the existing derivation twice.
14:40:38 <d34df00d> (or thinning, see above)
14:40:48 <ski> (but then one can imagine proof graphs, e.g. in "Multiple-Conclusion Logic" by D. J. Shoesmith in 1978. or Girard's proof nets)
14:41:41 <d34df00d> But we're talking about the very basic derivation rules in the corresponding styles, which don't make a difference in practice — nobody uses those rules directly, instead resorting to obvious shortcuts.
14:41:53 <d34df00d> So that's a bit of a bikeshedding IMO :)
14:42:01 * ski smiles
14:51:13 * hackage inline-r 0.10.2 - Seamlessly call R from Haskell and vice versa. No FFI required.  https://hackage.haskell.org/package/inline-r-0.10.2 (MathieuBoespflug)
15:05:13 <bor0> I know I'm off-topic (not much activity in #pandoc), but has anyone successfully replaced the title page in pandoc (md+TeX)?
15:17:44 <Gurkenglas> first steps to a game prototype https://gist.github.com/Gurkenglas/d3de07ecadc1971117d0289395020e5f what library should I use to get horizontally, button and rectangle? Ideally there'd also be a way to get tooltips/mouseover graphics changes
15:21:38 <Gurkenglas> (aka you have ressources [Bool] -> Double where one part xs is equivalent to one part each of xs ++ [False] and xs ++ [True], and you can spawn random durability-limited machines that convert between [Bool] with profit, where durability grows more than double for each level of specialization.
15:25:16 <royal_screwup21> can I ask a logic question about petri nets (concurrency)? 
15:25:22 <gobby> I'm trying to update my cabal to 2.4.1.0. I have installed the binary but I cannot update my path so that when I run cabal in the terminal, it gives me the latest version
15:25:56 <gobby> I updated my path with its location ~/.cabal/bin/cabal without any success
15:26:01 <royal_screwup21> In resulting configuration at the bottom, I don't understand why there is only one token on the 2nd left place. I was expecting two, tokens since two tokens are passed through the transition https://prnt.sc/nx7s5e
15:29:40 <dmwit> Gurkenglas: I don't understand your question.
15:30:54 <dmwit> gobby: Hm. Perhaps you need to `hash -r` (bash) or `rehash` (zsh).
15:32:08 <dmwit> Gurkenglas: (...but I suspect the answer is "whichever of gtk, wx, opengl, or x11 you are already familiar with, use bindings to that".)
15:32:40 <Gurkenglas> dmwit, let's say, what library should I use to, say, make a clone of http://adarkroom.doublespeakgames.com/
15:34:22 <solonarv> gobby: $PATH is a list of *directories* to search in
15:34:42 <solonarv> so the PATH entry you want is ~/.cabal/bin, not ~/.cabal/bin/cabal
15:35:20 <gobby> solonarv: Yep this is in my .bashrc  `export PATH=~/.cabal/bin:$PATH`
15:35:30 <gobby> solonarv: still not working
15:36:15 <dmwit> Gurkenglas: Then you might also look at threepenny-gui.
15:36:40 <gobby> I think I fixed it
15:36:43 <gobby> I'm using zsh
15:36:49 <gobby> so I had to update .zshrc
16:33:22 <xcmw> Is there a type class that has a function:   f (Maybe a -> b) -> f a -> f b   ?
16:34:19 <jackdk> what are you trying to do? it smells a bit like a combination of a few things in witherable?
16:39:03 <xcmw> jackdk: I don't think it is like witherable. It would sample the 2nd arg as soon as the 1st arg is available
16:40:41 <jackdk> xcmw: what are you trying to do? Would fmapping Just over your f a , then using <$>/<*>  work?
16:42:47 <MarcelineVQ> xcmw: looks interesting, what is your current use of this?
16:43:07 <xcmw> I am making an frp library that has futures (values that occur at a time)
16:43:38 <xcmw> <*> returns the max of the two times
16:44:02 <xcmw> align returns the min of the two times
16:44:42 <xcmw> I was trying to figure out if there was a typeclass that worked for sampling the 2nd arg at the time of the 1st arg
16:45:33 <xcmw> The 2nd arg might have a time greater than the time of the first arg so Nothing would be applied to the function
16:46:52 <MarcelineVQ> how are you determining that, is the time in f?
16:47:46 <xcmw> Yes f a = (Nat, a)
16:48:12 <xcmw> In theory. The real implementation involves IO
16:48:19 <MarcelineVQ> Oh natural based time interesting
16:48:42 <xcmw> MarcelineVQ: How else would I do it?
16:48:44 <shachaf> Discrete time? That's unusual for this sort of thing.
16:49:21 <MarcelineVQ> usually it's Real because it's hard to put an event between S Z and S (S Z)
16:49:53 <shachaf> Rationals would work well enough for that.
16:49:56 <MarcelineVQ> by real I​ mean \fancyR not neccesarily some type called Real
16:50:14 <xcmw> Why would I need to do that?
16:50:28 <shachaf> I think classically FRP is actually done with the reals, though I don't quite know why.
16:50:48 <pie__> shachaf, now that you mention it rationals sounds "easier"
16:51:07 <xcmw> I will not have a behavior, just future so it will discrete
16:51:09 <pie__> question is which is more abstraction breaking
16:51:20 <pie__> rationals or reals
16:51:23 <pie__> :thinking:
16:52:59 <xcmw> My idea  was have an IORef at 0 and increment it for every future that is triggered
16:53:14 <ski> hmm .. is there some FRP operation where one would like to use limits ?
16:53:42 <xcmw> Not sure what you mean?
16:54:01 <ski> (i mean where rational time (being dense) wouldn't suffice)
16:54:10 <pie__> limits are one way (?) used to construct the real numbers
16:54:34 <shachaf> Limits are used to construct real numbers because completeness is a desirable property of the real numbers.
16:54:35 <conal> xcmw: I doubt you'll get a correct implementation (one that agrees with the specification/denotation) with that IORef technique.
16:54:58 <pie__> shachaf, which is the word i was looking for - being an object where limits are defined for every point?
16:55:14 <xcmw> conal: What would be violated?
16:55:15 <shachaf> I don't know what it means for a imit to be defined for a point.
16:55:22 <ski> (also, how about using infinitesimals ? would that make any sense ?)
16:55:27 <conal> ski: Rationals won't suffice for predicate-based events.
16:55:34 <pie__> shachaf, i dont know the words :p
16:55:43 <shachaf> hi conal
16:55:44 <ski> conal : ah. i see
16:55:57 <ski> (i think)
16:56:00 <conal> hi shachaf 
16:56:13 <shachaf> conal: I remember a talk a few years ago where you used computable equality of time, I think, which wouldn't work with the reals.
16:56:25 <shachaf> I don't remember the details anymore, though.
16:56:42 <shachaf> It seems plausible that computable equality isn't actually a desirable property of time.
16:56:43 <ski> pie__ : yes. cauchy sequences is one way. dedekind cuts is another
16:57:17 <shachaf> Google has a time API where you get an open interval instead of a single timestamp, which seems much more reasonable to me.
16:57:24 <ski> shachaf : for a point ?
16:57:37 <conal> shachaf: doesn't ring a bell. i don't think my FRP specification depends on computable equality on times. 
16:57:47 <xcmw> I am probably missing something obvious but when would using a natural fail?
16:57:53 <conal> xcmw: are you aiming for a correct implementation?
16:58:04 <ski> computable reals have observable apartness
16:58:20 <conal> xcmw: (as opposed to some vaguely FRP-like thing)
16:58:23 <shachaf> I think it might have been an off-hand remark rather than the main point of the presentation.
16:58:58 <xcmw> conal: I am aiming to implement Future and it be correct. I am not going to implement behavior.
16:59:13 <pie__> (Why are reals needed for predicate based events? (what are predicate based events?))
16:59:45 <Tuplanolla> I'm also curious about the relevance of real numbers.
17:00:38 <pie__> also computer reals are cheating anyway  right? :p
17:00:40 <xcmw> My goal is to make Future a Functor, Applicative, Monad, and Align (align would race).
17:01:19 <ski> pie__ : imagine a real signal/behaviour that denotes the square of the distance from current time to some base time point, measured in some unit, say seconds
17:01:40 <ski> pie__ : now wait for this signal to reach `2'
17:02:56 <ski> pie__ : "computer reals" being ?
17:02:58 <pie__> ok, so now you have a samopling problem
17:03:07 <pie__> a more technical term is i suppose computable reals
17:03:24 * ski isn't sure why it would be cheating
17:03:25 <pie__> which to my naive self sounds like relabeled rationals but i dont know :p
17:03:47 <ski> it's not rationals
17:04:38 <hpc> things like pi and sqrt(2) are computable reals
17:04:54 <shachaf> So are things like 1 and 2/3
17:04:58 <ski> > pi :: CReal
17:05:00 <lambdabot>  3.1415926535897932384626433832795028841972
17:05:11 <ski> > showCReal 50 pi
17:05:12 <pie__> yeah, nevermind, that was unfounded and i dont know enough about it anyway.
17:05:14 <lambdabot>  "3.14159265358979323846264338327950288419716939937511"
17:05:23 <pie__> but its never really pi! ;P
17:05:29 <ski> it is
17:05:29 <hpc> there are more computable reals than rationals, but their sets are the same size because they're computable
17:05:37 <conal> FRP could probably use a proper subset of the reals, but the rationals are much too small (missing solutions to many simple equations, as ski pointed out).
17:06:03 <shachaf> Really? What subset would be suitable?
17:06:20 <conal> for instance, computable or finitely describable reals.
17:06:21 <shachaf> (Other than things homeomorphic to the reals like the positive reals.)
17:06:32 <hpc> they're both countably infinite, but every rational is an element of the computable reals
17:06:38 <conal> but it wouldn't make it simpler.
17:06:39 <shachaf> Oh, well, sure.
17:06:39 <ski> hpc : i don't think you can prove they are the same size, constructively
17:06:40 <hpc> iirc
17:06:52 <pie__> i still dont see what in predicates makes computable reals actually necessary though, unless you want like "the time that is the square root of 2 seconds after now"
17:07:14 <ski> ("computable" is not the same as "algorithmic")
17:07:18 <hpc> i could easily be wrong, things get weird at the boundary of computability
17:07:43 <xcmw> This is way above my head
17:08:23 <MarcelineVQ> xcmw: try explaining your problem again now that there's more activity
17:08:27 <conal> pie__: exactly. a predicate event like time^2 == 2 has an irrational occurrence time, so the time type can't be limited to rationals.
17:08:55 <pie__> conal, my knee-jerk reaction (given that i dont have much else) is that thats not necessarily reasonable
17:09:08 <conal> xcmw: if you want to understand what FRP really is/means, see http://stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language#5878525 and follow the links there.
17:09:19 * pie__ follows the link
17:10:24 <pie__> though if you get to work with some fake "real numbers" maybe you dont need training in digital signals processing just to write some code :D
17:11:43 <dolio> Equality of computable reals is not computable, though. So that shows that it can't be the computable reals. :)
17:12:06 <pie__> ok so my basic thesis would be something like "sampling is unavoidable"
17:12:11 <xcmw> conal: I think I completely understand Future, Event, and Reactive. I just don't understand the point of Behavior or using reals. I feel that computers are inherently discrete by nature, but I am probably wrong.
17:12:14 <ski> hpc : "Constructive gem: double exponentials" by Andrej Bauer in 2009-10-12 at <http://math.andrej.com/2009/10/12/constructive-gem-double-exponentials/> is fun :) a bijection between `|N' and `2^(2^(|N))'
17:12:20 <conal> pie__: i think the FRP spec holds up to reason (is reasonable). if you don't understand something in the descriptions I linked above, i'm happy to try answering questions. it's all well-defined. not a matter of opinion. sadly, there are many implementations labeled as "FRP" that don't satisfy the precise spec (or usually any precise spec other than the implementation itself).
17:12:49 <pie__> conal, thanks. my network is acting up locally so i havent been able to actually open the page
17:13:03 <pie__> or....something network-adjacent at least...
17:13:06 <ski> hpc : perhaps also see "First Steps in Synthetic Computability Theory" by ibid at <http://math.andrej.com/data/synthetic.pdf>
17:13:31 <conal> dolio: i don't see the problem there. we have bottom in our denotations, and sometimes it's exactly the right choice, as in equality on computable reals.
17:14:14 <MarcelineVQ> pie__, xcmw: though I haven't finished it http://conal.net/papers/type-class-morphisms/type-class-morphisms-long.pdf helped me a lot to understand what it means to go from denotation to implementation
17:15:25 <hpc> ski: https://en.wikipedia.org/wiki/Computable_number#Properties says they are countably infinite
17:15:25 <shachaf> ski: Did anyone call that a topological gem before?
17:15:31 <xcmw> conal: Is the Future described in your push-pull paper an instance of Align where align races?
17:15:47 <shachaf> There is some corresponding topological theorem though now I'm not sure exactly what it is.
17:15:48 <conal> MarcelineVQ: i'm glad that paper helped you! more context at http://conal.net/papers/type-class-morphisms/, including a talk and some related talks.
17:15:49 <ski> shachaf : i dunno ? have you seen/heard that phrase somewhere before ?
17:15:51 <boj> xcmw: i think the point isn't that computers are discrete, but all problems are continuous
17:15:55 <dolio> Well, if the goal is to 'detect' time^2 = 2 and do something exactly at that time, you're out of luck, because you can't detect equality, you can only detect inequality.
17:15:59 <hpc> and the minsky definition further up looks like a double exponential, now that you mention it
17:16:06 <hpc> although i am probably really off base in that
17:16:11 <dolio> Equality is the case where you diverge.
17:16:32 <dolio> Probably you don't actually care about detecting the exact time, though.
17:16:39 <conal> dolio: the goal isn't to do something then. 
17:17:46 <hpc> actually nvm on that, i can't explain that intuition now that i try to think about it precisely
17:17:50 <hpc> i should just go to sleep lol
17:18:16 <ski> hpc : i'm pretty sure that's written from a classical POV. and possibly also assuming they are algorithmic (can be coded as a natural number)
17:18:45 <ski> hpc : also note that you can't prove constructively that a subset (or quotient set) of a countable set is countable
17:18:52 <dolio> Something like the smooth reals might be better than the computable reals anyway, though.
17:18:57 <ski> (ditto for s/countable/finite/)
17:19:06 * ski nods to dolio
17:19:22 <conal> BTW, computers are not discrete. Discrete/digital computation is an abstraction. And even if computers were discrete (or given that we're building on top of a discrete abstraction), that property wouldn't keep us from correctly computing with continuous types and more than classical math built on finite alphabets and finitely described inference systems prevented describing trig or calculus.
17:19:40 <MarcelineVQ> conal: It's on my short-list to make an frp library for idris as a learning exercise so I've been gawking at the relevant papers lately, that one stood out because it made the other ones make more sense hehe
17:20:38 <conal> s/and more/any more/
17:21:53 <conal> MarcelineVQ: Cool. 
17:22:47 <conal> xcmw: is the Align class defined somewhere? i've not encountered it.
17:22:49 <ski> "A computable number [is] one for which there is a Turing machine which ..." -- yes, this sounds like it's talking about what i termed (after Escardó) "algorithmic", rather than "computable"
17:22:59 <shachaf> ski: What's the difference?
17:23:32 <ski> shachaf : algorithmic means that we can finitely code it. computable just means that we have termination/productivity
17:23:57 <xcmw> conal: Align is https://hackage.haskell.org/package/semialign-1/docs/Data-Align.html
17:24:20 <conal> xcmw: thanks. looking.
17:24:36 <ski> shachaf : when adding two cauchy sequence, you don't need to know that they're algorithmic. it suffices to know that you'll eventually get to any of the rational approximations in the input
17:24:54 <shachaf> Are there any reals that aren't computable, then?
17:25:10 <shachaf> If you give me oracles for two non-computable reals I can presumably still add them.
17:25:52 <ski> if the oracles actually can give you the required approximations (subject to the convergence condition), then that would count as computable
17:26:10 <shachaf> Isn't that true of every real?
17:26:12 <shachaf> I must be confusil.
17:26:42 <ski> what about Chaitin's constant, e.g. ?
17:27:26 <shachaf> What's the problem with an oracle for that?
17:27:56 <ski> i don't know. how do you propose to implement it, physically ?
17:28:22 <dolio> You didn't say anything about that.
17:28:29 <c_wraith> um. the point of an oracle is "doesn't matter how"
17:29:24 <hpc> more to the point, the point of an oracle is "we can't, but let's pretend just this once"
17:29:24 <ski> one could view "all computable reals are algorithmic" as a physical hypothesis
17:30:36 <ski> istr Escardó considering both cases, deriving slightly different math depending
17:30:52 <shachaf> ski: An oracle is something provided externally, not something you implement.
17:30:59 <ski> right
17:31:47 <shachaf> I would have said that you can stipulate an oracle for any real, and that a real is computable if you can actually implement it.
17:31:48 <ski> so a temperature reading could be an example of something that could be considered computable, but not necessarily algorithmic
17:32:17 <shachaf> Oh, you're talking about interactions with the real world or something. That's not where I expected this to go.
17:32:22 <dolio> This notion of "computable" sounds like exactly the things that are _not_ computable in PCAs and modest sets.
17:32:40 <shachaf> PCAs?
17:32:46 <dolio> Partial combinatory algebras.
17:33:03 <conal> xcmw: I don't yet understand Align well enough to answer your question. The FRP semantics in the push-pull paper does use min on occurrence times, and it's crucial for this min to be "lazy", i.e., produce some information without the compared times being fully known.
17:34:24 <xcmw> conal: Is it possible to determine if two futures occur simultaneously in true FRP? 
17:34:29 <conal> The default definitions of min & max in terms of inequality tests don't suffice for this kind of laziness.
17:35:30 <conal> xcmw: are you asking whether simultaneity can be tested via the FRP api?
17:35:33 <typetetris> In this tiny conduit example https://pastebin.com/VK0Rh4ix I expected the whitespace around top level json values in the test.json to be dropped. But it doesn't do that. What am I doing wrong?
17:35:34 <dolio> The idea is that a PCA is a set U, a partial function U × U → U, and elements s, k ∈ U.
17:35:54 <dolio> With the 'obvious' meanings.
17:36:13 <dolio> (The function is application.)
17:36:20 <conal> xcmw: i'm wondering whether you're asking a question about the specification or about an implementation.
17:36:33 <xcmw> conal: Can you write a function: Future () -> Future () -> Future Bool  then is eventually yes or no at the min of the two arguments times
17:36:49 <dolio> Anyhow, you might also have a sub-PCA #U which is the 'computable' elements of U, and when you build a category of modest sets, the arrows are required to be in this computable subset.
17:38:40 <conal> xcmw: i don't think so via the api in that paper. and i didn't need that functionality on futures for building up FRP (behaviors and events).
17:39:01 <dolio> But the objects may take values in all of U, because there may be computable procedures for manipulating things that are at least not known to be computable.
17:39:44 <conal> xcmw: futures aren't necessary for FRP at all. they helped give a new refactoring of FRP, which seemed interesting at the time.
17:43:46 <dolio> And ski's example is exactly the one I use when talking about why the uncomputable part might be a conceptually useful thing. :)
17:46:18 * ski didn't much look into modesty
17:46:19 <dolio> (Actually, I've tried to come up with stuff that's more rigorous than that example, but it's a good starting point.)
17:46:39 <conal> xcmw: iirc Future is an applicative functor (and a monad), so one can define zip and zipWith in an applicative way. for liftA2/(<*>), you'd use max, not min.
17:49:16 <conal> xcmw: but maybe min would make sense for Align.
17:49:32 <zeta_0> does haskell-ide-engine not work well with haskell interactive? now when i open a haskell file lsp hie does not prompt me for the root of the project, why is this? here is my .emacs config: https://gist.github.com/zeta-00/2bdd5773296fde88a1473f7e57641768
18:19:58 <conal> On an earlier topic, another reason for using reals instead of rationals in FRP is to enable behaviors like 'sin time', which I used a lot in the early FRP days. Likewise for simple ODE-based behaviors.
18:31:45 <sm> hi all.. what's a nice way to convert [(a,b)], where all a's are the same, to Map a [b] ?
18:32:41 <Axman6> there';s a _really_ nice way to do it using the discrimination package, but generally you just want something like: fromListWith (++) . map (second (:[]))
18:34:58 <sm> Axman6: thank you!
18:36:19 <Axman6> though, IIRC that can lead to O(n^2) behaviour for the repeated list concatenation, so if you have a lot of values you might want to use a DList/Endo
18:40:26 <sm> I might indeed, noted
18:41:07 <Axman6> I wish there was a more general function for construction maps. Something like fromListWith' :: Ord a => (a -> b -> b) -> b -> [(a,b)] -> Map a b
18:41:13 <sm> this seems like one of those operations more easily done imperatively
18:41:33 <Axman6> hmm... there could actually be a foldl/foldr analogue
18:45:44 * hackage time-manager 0.0.0 - Scalable timer  https://hackage.haskell.org/package/time-manager-0.0.0 (KazuYamamoto)
18:46:22 <MarcelineVQ> :t unzip
18:46:23 <lambdabot> [(a, b)] -> ([a], [b])
18:48:06 <solonarv> :t fmap (`appEndo` []) . Data.Map.fromListWith (<>) . map (second (Endo . (:)))
18:48:07 <lambdabot> Ord k => [(k, a)] -> M.Map k [a]
18:48:18 <solonarv> ^ I think this is what you want
18:50:44 <infinisil> Oh Endo is just an unapplied function application?
18:50:57 <Axman6> @src Endo
18:50:57 <lambdabot> newtype Endo a = Endo { appEndo :: a -> a }
18:51:15 <infinisil> Neat
18:51:25 <solonarv> and: instance Semigroup (Endo a) where (<>) = (.) -- eliding newtype noise
18:52:07 <solonarv> and also: instance Monoid (Endo a) where mempty = id
18:52:14 * hackage lazyboy 0.2.2.0 - An EDSL for programming the Game Boy.  https://hackage.haskell.org/package/lazyboy-0.2.2.0 (rose)
18:52:38 <infinisil> Man, abstractions are just great
18:52:50 <infinisil> And category theory
18:52:51 <shachaf> Most abstractions are quite bad.
18:53:04 <shachaf> A few are good.
18:53:09 <infinisil> Examples of both?
18:54:12 <solonarv> of course I could've also written this without resorting to 'Endo':
18:54:12 <pie__> infinisil, ohai
18:54:28 <infinisil> pie__: o/
18:54:39 <solonarv> :t fmap ($ []) . Data.Map.fromListWith (.) . map (second (:))
18:54:41 <lambdabot> Ord k => [(k, a)] -> M.Map k [a]
18:55:17 <shachaf> Hmm. Functions are a pretty good abstraction.
18:55:28 <pie__> whellp thats unreadable to me xD
18:55:30 <shachaf> Numbers are good. Especially the natural numbers.
18:55:35 <pie__> mmm numbers
18:55:49 <infinisil> Numbers are an abstraction?
18:56:01 <pie__> how deep the rabbithole goes...
18:56:30 <shachaf> Definitely!
18:56:38 <pie__> infinisil, you know about peano numbers?
18:56:51 <infinisil> Yea
18:56:51 <pie__> (question is which way does the abstraction goo)
18:57:37 <infinisil> Zero Succ (that's what he said)
18:57:51 <pie__> wrong chan :P
18:59:39 <infinisil> No that's right, he said that, Giuseppe Peano!
19:00:01 <pie__> i need to get my mind out of the gutter
19:00:17 <MarcelineVQ> :t (\(as,bs) -> M.fromList (maybeToList (fmap (const bs) <$> uncons as))) . unzip
19:00:18 <lambdabot> Ord k => [(k, b)] -> M.Map k [b]
19:00:25 <shachaf> I gotta say this is pretty tiresome.
19:02:26 <MarcelineVQ> oh, ((bs <$) <$> uncons as))) :X
19:03:01 <solonarv> MarcelineVQ: that doesn't look right...
19:03:39 <infinisil> @pl (\(as,bs) -> M.fromList (maybeToList (fmap (const bs) <$> uncons as))) . unzip
19:03:40 <lambdabot> uncurry (((M.fromList . maybeToList) .) . flip ((<$>) . fmap . const) . uncons) . unzip
19:03:42 <infinisil> There we go
19:03:46 <solonarv> this looks like it'll build 'Map.singleton (fst (head xs)) (map snd xs)'
19:03:59 <solonarv> (assuming non-empty input)
19:04:36 <MarcelineVQ> yeah, what was the goal?
19:05:21 <solonarv> I think the goal was 'fromListWith (++) . map (second (:[]))'
19:06:00 <solonarv> it's just that that is pretty inefficient due to how it associates (++), so I gave a version using the difference-list technique
19:06:08 <MarcelineVQ> mm? that's not a goal that's a solution :> "<sm> hi all.. what's a nice way to convert [(a,b)], where all a's are the same, to Map a [b] ?"
19:06:28 <solonarv> oh wait, all a's are the same - somehow I missed thath
19:14:50 <infinisil> But that's pretty weird, if all a's are the same, then why do you have an [(a, b)] which clearly doesn't represent that?
19:15:01 <infinisil> You'd have to first assert the list isn't empty
19:15:15 <infinisil> And then assert that all a's are *actually* the same before you do anything with that assumption
19:16:25 <infinisil> And then it'd be a `(a, [b])` representing that, or even `(a, NonEmpty b)`
19:17:15 <infinisil> So then it's just a Map.singleton to get a `Map a [b]`
19:20:00 <MarcelineVQ> infinisil: it's okay, I trust sm
19:20:25 * infinisil wonders about how that [(a, b)] got to be
19:20:28 <MarcelineVQ> But not enough to avoid the empty as check
19:21:40 <MarcelineVQ> wait.. oh no, I'm dumb
19:22:48 <infinisil> MarcelineVQ: wdym?
19:24:44 * hackage scheduler 1.4.0 - Work stealing scheduler.  https://hackage.haskell.org/package/scheduler-1.4.0 (lehins)
19:26:55 <MarcelineVQ> any entry at all in [(a,b)] means ([as],[bs]) are non-empty as well so we can just check it there first. idk if that results in anything more succinct though
19:27:05 <sm> infinisil: it is a silly list, it was an intermediate step as I tried to convert a flat list of things into a categorised map for more efficient lookup
19:27:11 <MarcelineVQ> probably not, head is four letters :>
19:28:27 <sm> and, apologies to the room, I found a better way that avoids it
19:28:42 <MarcelineVQ> did it involve a let?
19:30:25 <sm> MarcelineVQ: it certainly did. Here's what I got compiling so far: https://termbin.com/rf54
19:30:36 <sm> just to make it concrete
19:30:50 <infinisil> sm: No need to apologize, this room likes challenges like this, it allows everybody to use all the nasty functions they know :3
19:31:28 <sm> I was going to thank solonarv for the efficient version, but then I saw they solved a different problem, so I have cancelled their funding
19:32:09 <pie__> XD brutal
19:32:46 <monochrom> You can also bot-snap them away.
19:32:56 <monochrom> @snap monochrom
19:32:57 * lambdabot secretly deletes monochrom's source code
19:33:06 <monochrom> Very reliable. :)
19:33:19 <solonarv> hey, my solution does work for your use case! it's just more general than you needed
19:33:36 <sm> ah! funding reinstated! Thank you!
19:33:51 <MarcelineVQ> sm: challenge mode, use TransformListComp to write pricesAtDate
19:34:45 <monochrom> They made TransformListComp too general. It admits many more arbitrary functions than SQL.
19:34:47 <sm> sounds fun, but I think that's one for the room!
19:36:18 <monochrom> https://mail.haskell.org/pipermail/haskell-cafe/2018-February/128607.html
19:36:51 <sm> I think I might have prematurely optimised this
19:38:38 <sm> there are a lot of rates over time, but on a given day, there aren't that many
19:39:07 <sm> unless you're tracking the whole stock market I guess
19:40:01 <sm> it's been working fine searching a flat list of rates. I thought I needed this map of maps thing. Maybe I will.
19:40:14 * hackage hkd-lens 0.0.1 - Generic lens/prism/traversal-kinded data.  https://hackage.haskell.org/package/hkd-lens-0.0.1 (trevorcook)
19:52:14 * hackage webdriver 0.9 - a Haskell client for the Selenium WebDriver protocol  https://hackage.haskell.org/package/webdriver-0.9 (AdamCurtis)
20:32:13 * hackage simple-cmd 0.2.0.1 - Simple String-based process commands  https://hackage.haskell.org/package/simple-cmd-0.2.0.1 (JensPetersen)
22:35:14 * hackage http-directory 0.1.3 - http directory listing library  https://hackage.haskell.org/package/http-directory-0.1.3 (JensPetersen)
22:51:43 * hackage gi-webkit2webextension 4.0.20 - WebKit2-WebExtension bindings  https://hackage.haskell.org/package/gi-webkit2webextension-4.0.20 (inaki)
23:14:53 <jackdk> Who was in here yesterday asking about hedgehog? If you are still here, did you get unstuck?
23:23:38 <MarcelineVQ> jackdk: could have been magthe or newhoggy
23:24:13 <jackdk> magthe, that was it.
23:24:14 <MarcelineVQ> magthe if it was one day ago for sure
23:24:34 <jackdk> tyvm MarcelineVQ. Not here right now, it seems.
23:24:45 <MarcelineVQ> ye
