00:02:34 <marmulak> haskell makes me feel like I need a degree in mathematics
00:02:50 <marmulak> I'm having flashbacks to college math lab where we had to use mathematica
00:03:35 <sarahzrf> marmulak: haskell's relationship to math is. complicated
00:03:43 <jle`> hm, i don't really think i feel that way day-to-day
00:03:52 <jle`> most of it is just `putStrLn "hello" >> putStrLn "world"`
00:04:06 <jle`> the common haskellism people say is "i use haskell because i'm not smart enough to use imperative languages"
00:04:24 <sarahzrf> jle`: yeah, but people know they're being a smartass when they say it, and they're being glib
00:04:32 <sarahzrf> they're overloading "smart"
00:04:45 <jle`> okay, the more accurate one might be "i don't have the attention span to be able to use..."
00:04:46 <sarahzrf> marmulak: honestly, a lot of the math talk used in the haskell community is kinda cargo culty
00:04:50 <sarahzrf> jle`: ;)
00:04:54 <jle`> but i don't think that's an unfair quote
00:04:59 <sarahzrf> no, i totally agree
00:05:10 <jle`> a lot of the math talk in the haskell community is...unrelated to haskell
00:05:30 <jle`> it's just a hobby we all happen to share, but 99% of it really isn't related to actually programming in haskell at all
00:05:50 <jle`> it's like if you joined a car mechanics club and every member just happens to like magic the gathering
00:06:03 <jle`> initially you might think that you need to be good at MtG to be a good mechanic
00:06:17 <jle`> but then eventually you realize that's it's just some bizarre coincidence that everyone in the club happens to like it
00:06:29 <jle`> and before you know it you're a fan too
00:06:42 <jle`> D:
00:07:17 <jle`> if you hang around haskellers and they start talking about math, just remember that it's unrelated to haskell. it's just some weird hobby we all share for some reason
00:07:31 <jle`> and if you hang around a community long enough you'll eventually pick up the hobbies
00:07:36 <sarahzrf> well, math talk used in the haskell community `asAppliedTo` haskell, perhaps
00:07:53 <jle`> is it really though?
00:07:57 <sarahzrf> [is kinda cargo culty, a lot of it]
00:08:54 <marmulak> part of why I chose haskell is I want to be elitist
00:08:56 <sarahzrf> i can tell you that ive contributed my fair share to it and i, for one, didnt even know the definition of observational equivalence until several months ago
00:08:59 <sarahzrf> marmulak: nice
00:09:07 <marmulak> lol
00:09:32 <sarahzrf> well, i say "the" definition, but more like "the proper notion of"
00:09:49 <marmulak> cool, I like math either way, just am rusty and not advanced in that area
00:10:13 <jle`> most people chose to use to stick with haskell because it's one of the only viable solutions for long-term maintainable code
00:10:20 <sarahzrf> also: people handwave laziness and strictness and totality and partiality like c  r  a  z  y
00:10:42 <marmulak> I thought pythonw as the language of long-term maintainable code
00:10:46 <sarahzrf> lol
00:10:51 <sarahzrf> i mean idk
00:11:05 <sarahzrf> i probably shouldnt pass judgment on that stuff since i dont rly have industry experience
00:11:14 <marmulak> is strictness different from strong typing, or are those related
00:11:19 <sarahzrf> entirely unrelated!
00:11:24 <sarahzrf> i'm talking about strict evaluation
00:11:24 <marmulak> uff
00:11:30 <jle`> of all the things people have used to describe python, maintainability isn't usually one of them :)
00:11:33 <sarahzrf> as opposed to lazy evaluation
00:11:45 <jle`> python is probably the opposite of maintainable code
00:11:53 <marmulak> jle`: but I guess next to perl python looks really good. Like taking your ugly friend to the party
00:12:12 <sarahzrf> not a very nice metaphor :\
00:12:20 <marmulak> yeah it's not fair to perl
00:13:02 <marmulak> but in all seriousness when I read language comparisons about how this language is maintainable, this language is readable, etc
00:13:09 <marmulak> or another language isn't
00:13:17 <marmulak> all that really just depends on if you are a good programmer or not
00:13:30 <jle`> my point is that a lot of people come to haskell for many different reasons, but the reason people eventually actually keep on using haskell is usually for things like maintainability, safety, guarantees, type-guided development, etc.
00:13:51 <jle`> marmulak: how good of a programmer doesn't have anything to do with that discussion, really
00:13:56 <jle`> it's not about how maintainable your code actually is
00:13:56 <marmulak> indeed, it helps you get where you want to go
00:14:01 <jle`> it's about what the language does to help
00:14:27 <marmulak> sure but I could probably write some clean and maintainable ASM and some gastly haskell that no one could understand
00:14:30 <jle`> that's like saying that seat belts are only important depending on how good the driver is
00:14:44 <marmulak> that is actually true though
00:14:49 <jle`> marmulak: yeah, i'm talking about what the language does to help, or how you can leverage the language to help
00:15:06 <sarahzrf> marmulak: there's a reason why the structured languages crushed asm et al
00:15:16 <marmulak> that is very true
00:15:19 <jle`> no driver is good enough to not need a seat belt, heh
00:15:28 <marmulak> something that this reminds me of
00:15:37 <jle`> that's because the road you're driving on can collapse and you can fall over a cliff, no matter how good a driver you are
00:15:37 <marmulak> because my first language was BASIC
00:15:54 <jle`> you can write maintainable code in ASM. but ASM didn't do anything to help you with that
00:16:01 <sarahzrf> jle`: can you actually
00:16:14 <marmulak> it reminds me of how, once I learned conditional loops, I never wanted to use goto ever again, and functional program seems to teach a similar lesson
00:17:06 <jle`> yeah, the step from goto's to while's is to abstract over a common design pattern in a way that makes the pattern more immediately recognizable, and closes off a large class of bugs
00:17:19 <sarahzrf> amusingly, i still find that at a small scale my thoughts tend to flip flop between imperative and functional thinking sort of?
00:17:20 <jle`> higher order functions can be considered a similar type of philosophy
00:17:30 <marmulak> so functional programming does the same for us, closes off classes of bugs
00:17:44 <jle`> in specific i am talking about higher order functions
00:17:49 <marmulak> imperative is deeply ingrained in my mind. It's how I learned programming
00:17:55 <sarahzrf> like, if i write python, im constantly moaning to myself "god i wish i had do notation... god i wish i had (.)... god i wish i had mapMaybe..."
00:17:56 <marmulak> like in a way it's what I think programming is
00:18:08 <sarahzrf> but if i write haskell, i still sometimes have moments where i just kinda go like
00:18:12 <jle`> "functional programming" is not well-defined enough for me to talk about any concrete advantages. but i can talk about specific aspects :)
00:18:35 <sarahzrf> "you know what. this would just be really pleasant to write as a really simple loop with an if in the middle."
00:18:57 <marmulak> heh yeah
00:19:04 <marmulak> choosing the right tool for the right job
00:19:18 <jle`> there's nothing necessarily inherently wrong with an imperative algorithm, it's just that people who only know imperative algorithms will use them in situations where they are not well-suited
00:19:38 <sarahzrf> maybe i should go play with ocaml
00:19:48 <sarahzrf> ive had real world ocaml open in a tab for like a year
00:19:49 <marmulak> what is ocaml even
00:19:59 <sarahzrf> a descendent of caml
00:20:02 <sarahzrf> with objects, i guess
00:20:05 <marmulak> I assume so
00:20:08 <sarahzrf> ;)
00:20:18 <marmulak> :D
00:20:25 <jle`> one of the more commonly used languages in the ML family of languages
00:20:32 <sarahzrf> as far as i am aware, standard ml and ocaml are the primary modern survivors of the ML family
00:20:35 <marmulak> ahh ML rings a bell
00:20:44 <sarahzrf> which is the primary sibling family to haskell
00:20:50 <marmulak> does lisp have a modern survivor, or did they stop at scheme?
00:21:06 <sarahzrf> clojure is fairly popular these days i think
00:21:15 <sarahzrf> and emacs lisp lives on always in emacs users
00:21:18 <jle`> clojure, yeah
00:21:21 <marmulak> also is scala as bad as I've heard
00:21:44 <marmulak> yeah emacs is immortal, though I regret to say I use vim primarily
00:21:45 <jle`> it has good and bad aspects :)
00:21:58 <marmulak> emacs has a few functions that apparently no other program can do
00:29:16 <dibblego> marmulak: https://www.youtube.com/watch?v=tRszt-AlKOc
00:29:22 <sarahzrf> it's 3:28 AM here, jesus
00:29:26 <sarahzrf> i'm going to sleep, good night
00:34:07 <marmulak> goodnight!
00:34:39 <Rembane> Does Racket count as a LISP or is it a Scheme? 
01:46:09 <marmulak> or something else entirely
01:47:54 <libertyprime> both and also something else
01:55:58 <marmulak> hmm so clojure is another one of those funky JVM things
01:58:03 <marmulak> guys, if I really wanted to make some datum mutable in haskell, could I still do it?
01:58:16 <jle`> yea
01:58:25 <jle`> people do it all the time :)
01:58:38 <jle`> it's very common in a lot of applications
01:58:45 <jle`> mutation can be pretty neat
01:58:53 <jle`> haskell supports it pretty well, out of the box
01:59:13 <jle`> in fact, a lot of people say that haskell is the best imperative language :)  because you get most of the benefits of the type system, etc., on top of your imperative algorithm
01:59:38 <jle`> mutation is a good way to model, say, database access and writes
02:00:32 <marmulak> right
02:01:25 <marmulak> one thing I tried to do yesterday was write an algo that would generate fibonacci numbers, but it was harder than I thought
02:03:49 <marmulak> and when I was learning the basic functions I was imaginging something like, I start with a list [1, 0] and just over and over use the : function to add to the head of that list the sum of the first two values of it
02:04:23 <marmulak> in theory this would be fast, but I couldn't figure out how to define it
02:04:56 <marmulak> I found a fibonacci solution online but the simplest one ran rather slow
02:06:06 <marmulak> of course the reason for that was obvious because I wanted a list of fibonacci numbers doing the recursion over and over for each element of the list except a longer one would kill efficiency
02:06:12 <Rembane> marmulak: Your first intuition is quite good, how far did you get? 
02:07:16 <marmulak> I got as far as writing some obvious but not-working code, lol... like let fibs = [1,0] and then something like (fibs!!0 + fibs!!1):fibs
02:07:23 <marmulak> which I can understand sort of why that wouldn't work
02:08:44 <Rembane> marmulak: Yeah, so create a function that does one step of the computation and we'll save the recursion bit for later.
02:10:02 <Rembane> marmulak: Another constraint is the type signature. Which I believe in your case is something like: fib :: [Int] -> [Int]
02:10:47 <jle`> marmulak: also note that your logic is a bit shaky because it describes fibs in the opposite order of how we usually think about it
02:10:57 <jle`> if we keep on consing to the head the next sums, then we get fibs in reverse
02:12:02 <Rembane> Haskell lists have a tendency to be in reverse. 
02:12:06 * Rembane waves his hands around
02:12:54 <jle`> try a simpler recurrent function, like f(n+1) = f(n)*2
02:13:01 <jle`> and see if you can build from there :)
02:13:54 <jle`> i can walk you through one possible solution of such a sequence if you are ok with spoilers
02:13:56 <marmulak> haha yeah
02:14:00 <jle`> in a way that can be generalized to fibs
02:14:22 <marmulak> well let me read your comments and play around a little
02:14:29 <jle`> in a denotative style you don't really talk about "start with something, then keep on adding something".  you say "this is how things are"
02:14:40 <jle`> so if i wanted to define powersOfTwo = [1,2,4,8,16, etc...]
02:14:53 <jle`> or powersOfTwo = 1 : 2 : 4 : 8 : 16 : 32 : ...
02:15:05 <marmulak> yes
02:15:10 <jle`> powersOfTwo = 1 : (  2 : 4 : 8 : ...)
02:15:18 <jle`> i don't say "do this, then that"
02:15:22 <jle`> i say "this is what it is"
02:15:39 <jle`> and for data types, you do that usually starting with constructors
02:15:55 <jle`> for lists, the two constructors are [] and : (cons), as in x:xs (head and tail)
02:16:03 <ocharles> Is there anyway to -ddump-simpl with all the $tr crap?
02:16:06 <jle`> so the first question you ask: is powersOfTwo created with [], or (:) ?
02:16:12 <ocharles> I imagine this is auto deriving typeable
02:16:19 <jle`> and if you pick (:), the second question you ask is "what goes on both sidse?"
02:16:35 <jle`> (if you pick [] then you are already done)
02:17:07 <jle`> and...i hope that the way i stated powersOfTwo earlier heavily implies which constructor is used ;)
02:17:21 <marmulak> hmm yes
02:17:47 <jle`> powersOfTwo = ?? : ??    (in case it wasn't clear, it is constructed with (:), which you can tell from the fact that it's not empty)
02:18:03 <jle`> can you guess what goes on the left side, then the right side?
02:18:56 <marmulak> I'm thinking something like x and x*2
02:19:08 <jle`> you might be overthinking it
02:19:13 <jle`> i kind of gave it away earlier
02:19:20 <jle`> when i wrote powersOfTwo = 1 : (2:4:8:...)
02:19:53 <jle`> so, powersOfTwo = ?? : ??
02:20:21 <marmulak> er 1 : powersOfTwo
02:20:30 <jle`> almost :)
02:20:51 <jle`> that gives us powersOfTwo = 1 : powersOfTwo, so powersOfTwo = 1 : (1 : powersOfTwo)... it's 1:1:1:1:1:... forever
02:21:11 <jle`> marmulak: on the left hand side is 1, yes
02:21:23 <jle`> but on the right hand side is not powersOfTwo. it's (2:4:8:...)
02:21:41 <jle`> that's not powersOfTwo, that's... powersOfTwo, but with every item doubled, right?
02:21:51 <marmulak> would it be powersOfTwo * 2
02:22:08 <jle`> yeah. or well, you'd have to write map (*2) powersOfTwo, but you have the right idea
02:22:17 <jle`> @let powersOfTwo = 1 : map (*2) powersOfTwo
02:22:20 <lambdabot>  Defined.
02:22:21 <jle`> > powersOfTwo
02:22:21 <marmulak> I haven't really learnd what map does
02:22:26 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
02:22:31 <jle`> map f [x,y,z] = [f x, f y, f z]
02:22:40 <jle`> it returns the list with f applied to every item
02:23:32 <jle`> so hopefully you see the process here: instead of thinking "start with this, then do that" etc., think about just saying what it is you want the result to be
02:23:55 <marmulak> ok I am starting to see how this works
02:24:08 <marmulak> I like how lazy this solution is
02:24:38 <marmulak> so I now have all the powers of two until infinity and can just arbitrarily ask for the 1000th one
02:26:21 <marmulak> does haskell tend to remember the results when it's been forced to calculate these values, like if I ask for the 100th one in theory it has to walk through 1 to 100 to get it, so if I ask for 99 next does it have it saved somewhere or it just does 1 to 99  all over again
02:32:24 <marmulak> jle`: in your example we start with 1 as our initial value, but what if I need two initial values, do I just write 0 : 1 : something
02:32:44 <jle`> did you install ghci yet? :)
02:33:08 <marmulak> oh yeah I use ghci all the time now
03:48:03 <marmulak> alright now I've rejoined through matrix
03:48:16 <marmulak> now I can do even more haskelly stuff more often
04:49:06 <higherorder> https://www.schoolofhaskell.com/user/bartosz/understanding-algebras ; could someone please explain to me what "precursor" means in the context of "Here's the non-recursive precursor of our grammar" in that article?
04:51:30 <geekosaur> it's not te grammar, it's a simpler example leading up to the grammar
04:52:01 <geekosaur> they'll be modifying the type to change it into the actual grammar later, hence this type is the precursor to the final type
04:53:08 <higherorder> geekosaur: ah, I see. thanks!
06:11:19 <marmulak> so which one of you wrote "learn you a haskell" ?
06:16:18 <hpc> BONUS, who used to be active here while he was writing it
06:16:58 <marmulak> 🤔
06:19:04 <marmulak> most curious
06:19:32 <cocreature> they haven’t been active here in the last few years sadly
06:20:50 <marmulak> no worries
06:20:59 <marmulak> I like the book though
06:27:32 <marmulak> I see you guys are looking to revive your Haskell Google+ page. Too bad Google+ is on its way out :)
06:28:51 <yushyin> do we?
06:31:54 <marmulak> It's written in the topic but this topic may be unique to matrix.org
06:33:03 <Lycurgus> few here pay any attention to matrix bridge
06:33:29 <marmulak> justifiably so
06:34:22 <higherorder> Does anyone have good examples of Data.Record used successfully in the wild? Or articles on it?
06:34:25 <Lycurgus> although I'm surprised how many there are in channecl right now
06:34:38 <Lycurgus> musta been an uptick at some point
06:35:06 <lyxia> higherorder: what's that
06:35:14 <marmulak> :)
06:36:51 <higherorder> lyxia: http://hackage.haskell.org/package/records-0.1.1.6/docs/Data-Record.html
06:54:22 <marmulak> while inside ghci is there something I can use to clear the screen
06:54:44 <marmulak> I have ACD about that
06:54:45 <phadej> c-L
06:54:48 <phadej> Control+L
06:55:13 <marmulak> perfect
06:55:15 <phadej> (works universally in about everything running in terminal)
06:55:38 <marmulak> yeah I know it as redraw
06:55:49 <marmulak> does all of ghci's hotkeys have a list somewhere
06:56:13 <marmulak> it seems like all the ones I've found so far are standard unix editing commands
06:57:42 <phadej> "emacs key-bindings yes"
06:58:02 <sandman13> marmulak: they are so because ghci uses readline
06:58:03 <phadej> I'm not aware if there's a comprehensive list
06:58:35 <phadej> sandman13: it doesn't
06:58:48 <phadej> https://hackage.haskell.org/package/haskeline
06:59:34 <marmulak> also another thing I noticed is that in the learnyouahaskell examples the output in ghci is very nicely colorized but I don't get that on my Ubuntu install
06:59:53 <marmulak> is that just an option that can be enabled like in vim, or is that something done at compile time
07:00:06 <phadej> probably when book was typeset
07:00:18 <phadej> i.e. output is postprocessed
07:00:31 <marmulak> darn
07:00:58 <phadej> (you can setup custom prettyprinters in ghci, but it's *very* tricky)
07:01:36 <sandman13> oh I didn't know that phadej 
07:01:38 <sandman13> thanks :)
07:03:36 <marmulak> well I'm learning haskell so you can reasonably assume that I like very tricky things
07:04:30 <phadej> marmulak: it's tricky in a "let's configure all the build systems" -way
07:05:22 <marmulak> the "not fun" kind of way
07:05:33 <phadej> yes
07:06:48 <phadej> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#using-a-custom-interactive-printing-function -- The function can reside in any loaded module or any registered package, but only when it resides in a registered package will it survive a :cd, :add, :load, :reload or, :set.
07:07:05 <phadej> which means that if you do something like that, you'll need to make a package with custom prettyprinter globally & always available
07:27:56 <higherorder> How does the Data.Record library (http://hackage.haskell.org/package/records-0.1.1.6/docs/Data-Record.html) allow to use identifiers such as `Surname` without definiting them first somehere?
07:31:01 <lyxia> higherorder: you have to define them first somewhere. See the Name class below.
09:09:05 <aveltras> for those using dante with emacs, do you enable haskell-mode interactive at the same time ?
10:03:40 <Gurkenglas> https://github.com/tweag/ghc-proposals/blob/linear-types2/proposals/0000-linear-types.rst#multiplicities <- "note that 0 is not smaller than one" :(?
10:04:23 <Welkin> it's the pickle man!
10:09:53 <Gurkenglas> So a variable with multiplicity p can be used any number of times that is less than or equal to p, but not zero times? But don't variables have multiplicity omega by default, forcing us to use anything at least once?
10:10:47 <phadej> Gurkenglas: _ <= omega
10:11:08 <Gurkenglas> that's for multiplicities, 0 is not a multiplicity, but okay if they meant that
10:12:20 <phadej> I don't know why "is smaller or equal then" -name was picked
10:12:24 <phadej> it's not so intuitive
10:13:33 <Gurkenglas> it seems to me that instead of omega they want to write the set of natural numbers, and instead of 1 the set containing only 1, and instead of 0 the set containing only zero
10:14:19 <Gurkenglas> and instead of smaller or equal than "subset"
10:15:19 <Gurkenglas> and A `op` B = [x `op` y | x <- A, y <- B]
10:18:30 <Gurkenglas> but why must 0 not be part of the foobarring? 0 is a useful number, there's probably something lensy you could do with that
10:20:51 <phadej> Gurkenglas: https://github.com/tweag/ghc-proposals/blob/linear-types2/proposals/0000-linear-types.rst#zero-as-a-multiplicity
10:21:19 <Gurkenglas> Oh, I was nowhere near the end of that document :D
10:38:00 <chalkmonster> make IRC great again
10:38:45 <turab> Lol this is my first IRC message
10:38:55 <chalkmonster> >_>
10:39:00 <turab> Teach me stuff
10:39:17 * chalkmonster teachers turab to hate on Slack users
10:39:28 <marmulak> ahlan ya abu turab
10:39:45 <turab> I know some of those words :D
10:39:50 <cocreature> turab: ask Haskell questions and there is a high chance that you will learn something :)
10:39:52 <marmulak> I'm absolutely against Slack
10:40:00 <fr33domlover> o/ what does the GHC flag -fwarn-tabs mean? I couldn't find it in the docs (I did find -Wtabs but are they same thing? Or reverse?)
10:40:13 <turab> cocreature: That's exactly why I joined this place :')
10:40:20 <glguy> chalkmonster: This channel is about Haskell specifically. Could you please stick to that topic here?
10:41:21 <cocreature> turab: great, welcome!
10:41:28 <fr33domlover> (The yesod scaffolding has that flag)
10:42:20 <turab> For starters, dante vs ghcid?
10:43:26 <cocreature> fr33domlover: it’s the same thing, all warning flags exist in both forms (for historical reasons afaik, the new and recommended version are the -W flags)
10:43:42 <marmulak> we're all about ghc here
10:44:42 <cocreature> turab: I would probably recommend ghcid just because editor setups can be somewhat fragile and hard to debug and when you’re learning a language you don’t want to spend your time fixing your editor setup.
10:45:41 <turab> cocreature: ghcid is definitely easy to use. I feel like I have more control. I guesss I will stick with that and ignore all the fancy dante stuff.
10:46:18 <turab> Also, what's the correct way to tackle "ambiguous module names" problem?
10:46:48 <turab> Sorry if it's a lot of questions haha, I have been doing things on my own but would love to learn the right way to do it.
10:46:52 <g> turab: If two packages export the same module there's a PackageImports extension
10:47:04 <marmulak> is ghcid an IDE or something? I thought everyone just used vim
10:47:26 <g> marmulak: You run ghcid in a separate window alongside vim
10:47:49 <g> It just automatically reloads your package in ghci to give you immediate feedback as you save
10:47:50 <marmulak> hmm I seem not to have that installed
10:47:59 <g> $ cabal v2-install ghcid
10:48:05 <fr33domlover> Thanks cocreature !
10:48:31 <turab> g: Beautiful. Thanks for the suggestion :)
10:48:33 <marmulak> ah that's nifty
10:48:38 <marmulak> like an auto :r
10:48:49 <turab> Already loving this. Should have joined this chat weeks ago
10:49:21 <cocreature> turab: hard to say without a bit more context. as g mentioned you can use PackageImports but ime that’s not really an issue you usually hit as a beginner so I wonder if it might be caused by something else.
10:50:11 <marmulak> turab: I know the feeling
10:50:33 <g> marmulak: and it works great with "typed holes". You put an _ in your file in place of an expression to get immediate type information about that spot
10:50:43 <turab> cocreature: I have a module name Lexer that I am testing and it is conflicts with ghc's Lexer module
10:51:12 <turab> g: YES! I don't remember whose blog post I read (Sandy's I think?) and learned how to utilize type holes. Beautiful stuff
10:51:45 <g> turab: It's much more common not to leave the "ghc" package hidden
10:51:50 <g> err, 
10:51:55 <cocreature> turab: if you turn your code into a cabal project and don’t put "ghc" in the build-depends then you shouldn’t get that error.
10:51:58 <g> turab: It's much more common to leave the "ghc" package hidden
10:52:18 <turab> g: Actually, dante added that for some reason so yes, I should be able to remove that dep
10:52:25 <turab> Thanks for the heads up!
10:52:43 <geekosaur> that'd be so it can do its IDE stuff, might be needed in that case
10:53:27 <cocreature> but you might also want to consider prefixing your module names an some way. modules that are at the top-level in the hierarchy are quite rare (with GHC being a notable exception)
10:53:39 <cocreature> geekosaur: iirc dante is just a wrapper around ghci so I would be surprised by that
10:54:18 <turab> cocreature: So instead of "Lexer", it is better to call it "Something/Lexer"?
10:54:44 <geekosaur> dpeneds on how fancy it gets with ghci. I could see it in effect building its own "primitives" within ghci
10:56:03 <cocreature> turab: I guess “better” might be up for debate (but I’d definitely agree). at least that’s far more common and avoids having to use PackageImports all the time
11:12:24 <olligobber> :commands
11:12:27 <olligobber> :help
11:12:29 <olligobber> .help
11:12:32 <olligobber> .commands
11:12:34 <olligobber> k
11:12:56 <marmulak> wrong window
11:13:19 <olligobber> doesn't that work in here?
11:13:49 <olligobber> I want the command that turns a lambda expression into a non-lambda one
11:14:14 <olligobber> I want to simplify \f g -> f . h . g
11:14:29 <olligobber> I hoped (. h .) would work but it doesn't
11:14:59 <geekosaur> @pl \f g => f . h . g
11:14:59 <lambdabot> (line 1, column 6):
11:14:59 <lambdabot> unexpected "="
11:14:59 <lambdabot> expecting pattern or "->"
11:15:03 <geekosaur> oops
11:15:08 <geekosaur> @pl \f g -> f . h . g
11:15:08 <lambdabot> (. (h .)) . (.)
11:15:14 <olligobber> ew
11:16:02 <cocreature> apparently geekosaur has written too much idris recently ;)
11:16:16 <geekosaur> you can't "chain" sections the way you were trying to
11:16:22 <geekosaur> no, just missed hitting the wrong key
11:27:48 <EvanR> i wonder if there is some similarity between stuff like the pointless version of \f g -> f . h . g and towers of hanoi
11:28:14 <d34df00d> Uh, I accidentally upgraded stack to 2.1.1. and I cannot profile my programs anymore. I used to do `stack build --profile && stack exec -- myfoo +RTS -p`, but now looks like myfoo doesn't get built with -prof.
11:28:22 <d34df00d> Are there any good solutions?
11:30:01 <cocreature> d34df00d: a quick search through the issue tracker reveals https://github.com/commercialhaskell/stack/issues/4863
11:30:11 <cocreature> which suggests using "stack exec --profile"
11:31:01 <d34df00d> Hmm, I dismissed that bugreport since the title said different symptoms... Thansk, I'll give it a try!
11:35:34 <d34df00d> Nope, doesn't work for me, it seems.
11:35:51 <d34df00d> Although stack exec does not complain about --profile, but it doesn't produce any .prof either.
11:36:29 <solonarv> perhaps the output is squirreled away in /.stack-work ?
11:37:00 <d34df00d> Well, I even did `find ./ -iname "*prof"`, no luck.
11:37:27 <d34df00d> And if I do stack exec --profile, it eats all my +RTS argument s:(
11:39:02 <solonarv> with an extra -- you can tell stack to stop eating arguments
11:39:12 <turab> EvanR: woke af but fr, good question
11:39:13 <solonarv> srack exec --profile blah -- +RTS ...
11:39:21 <d34df00d> Yeah, that's what I usually did even with stack 1.
11:39:32 <d34df00d> And that's what works with stack2 if I omit --profiling.
11:39:57 <d34df00d> The funniest part is that I upgraded stack hoping they fixed `stack solver`.
11:40:02 <d34df00d> And it's gone in stack2.
11:40:10 <d34df00d> I guess that's a way to fix things, indeed.
11:40:47 <d34df00d> I think I'll just downgrade to stack1.
11:42:36 <cocreature> Maybe insert a --RTS before
11:56:44 <olligobber> I'm implementing a small logic thing in haskell: https://gist.github.com/olligobber/ca1f7c293944d7888803fc99653634e0
12:28:15 <EvanR> hi what does 1p in log1pDouble mean here https://github.com/ghc/ghc/blob/f737033329817335bc01ab16a385b4b5ec5b3b5d/libraries/base/GHC/Float.hs#L1204
12:29:07 <phadej> EvanR: log1p is "logarithm of 1 plus argument"
12:29:14 <phadej> log1p x = log (1 + x)
12:31:24 <olligobber> why not just use log . succ then?
12:33:56 <nshepperd> log1p x is log (1 + x), but implemented in a way that is much more accurate
12:34:22 <olligobber> fair
12:34:29 <nshepperd> log (1 + x) just written like that loses a lot of accuracy when x is near 0
12:35:30 <g> Incidentally, succ isn't a good replacement for (+1) as it adds an extra test/exception to your code that you rarely wanted
12:35:37 <EvanR> i see
12:36:01 <olligobber> g: how do you mean?
12:36:14 <g> > succ maxBound :: Int
12:36:17 <lambdabot>  *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
12:36:30 <nshepperd> also in that list of definitions is expm1, which is exp x - 1, the inverse of log1p
12:36:34 <olligobber> > (+1) maxBound :: Int
12:36:36 <lambdabot>  -9223372036854775808
12:36:37 <nshepperd> which has the same accuracy problem
12:36:44 <g> Even if you wanted to test for overflow using succ generates an unhelpful error
12:37:10 <g> You should mostly forget that the Enum class exists other than as a helper for [ _ .. _ ] syntax for Int and Integer
12:37:11 <merijn> g: Yeah, the enum behaviour specified in the report is kinda bad
12:38:06 <olligobber> I've probably been using succ in lots of places without thinking about that...
12:39:11 <olligobber> yeah, I used it here: https://gist.github.com/olligobber/49c827ebb90c8c340919645edecabbb3
12:39:19 <EvanR> so succ is a polymorphic function, but so is (+1). But +1 is more likely to not trigger an error
12:39:44 <olligobber> yes EvanR 
12:39:51 <EvanR> i mean, if you "just want to add one to a number of fixed type", just use + 1 ?
12:43:39 <EvanR> also in this code "For values of large modulus calling out to C is slower than staying in haskell" i wonder why that would be
12:43:52 <EvanR> (talking about rounding doubles)
12:45:20 <EvanR> anyway i see there is no built in routine for doing a Float -> Float or Double -> Double floor 
12:46:24 <EvanR> i know you could use the FFI and bust open the F#'s, and there is probably a package for this. But I can't remember it's name
12:54:56 <dmwit> g: Double doesn't have a Bounded instance. I don't think its succ implementation does the check you're saying it does.
12:56:10 <glguy> Even in that case I'd continue recommending forgetting that it exists
12:56:37 <dmwit> I'm okay with that. But we should be right for the right reasons.
12:56:55 <glguy> Great
12:57:02 <merijn> The Enum instance for Double is even more ridiculously broken
12:57:09 <merijn> It's downright evil and should be banished
12:57:31 <juri_> yeah. don't enum double, if you can avoid it.
13:00:08 <janat08> Is there some transformer for getting around "Non type-variable argument in the constraint: MonadIO (Performable m)" in obelisk's Frontend. I can't even find obelisk in hackage.
13:01:27 <geekosaur> "transformer"? that should be suggesting an extension
13:01:52 <phadej> FlexibleContexts
13:02:02 <phadej> and yes, obelisk isn't on Hackage, it's only on github
13:02:29 <janat08> I don't know. How do I fix this without resorting to FlexibleContexts?
13:02:34 <phadej> you don't
13:02:52 <phadej> you just have to use flexiblecontexts
13:03:05 <bandali> hey phadej
13:03:11 <bandali> do you run your own web server?
13:03:23 <phadej> bandali: for my blog?
13:03:26 <bandali> yup
13:03:27 <janat08> Oh lol, so they entirely wrote Performable with expectation that people would use the extension?
13:03:36 <geekosaur> entirely possible
13:03:49 <phadej> bandali: kind of & but not really, why so?
13:03:59 <geekosaur> lots of programs expect you to use a whole bunch of extesions. type level stuff is all the rage currently and this is the least of what youd need in that case
13:04:17 <bandali> phadej, ha, i think the planet software is going to have problem indexing your feed, as i think your cert chain is broken (not complete)
13:04:34 <phadej> bandali: you can use http:// address to
13:04:56 <phadej> (or if you know how to fix let's encrypt chains, I'm all ears)
13:05:47 <bandali> phadej, true, but i’d prefer not to :)
13:05:58 <bandali> phadej, as for how, do you get a fullchain.pem file or something similar?
13:06:55 <bandali> cert authorities usually either provide a separate “intermediate” cert file to be included as well, or just combine it with the regular one and call it fullchain or something like that
13:08:03 <EvanR> in reference to my question about floor :: Double -> Double, there is a package called altfloat which binds to C routines and also addresses some gripes with Enum and Ord
13:08:40 <EvanR> or makes an attempt to
13:10:30 <janat08> https://www.irccloud.com/pastebin/ENg9OEVC/
13:10:50 <janat08> I get error about MonadIO
13:11:52 <janat08> added error message
13:13:36 <phadej> bandali: i'm not sure if acme-tiny (which i use to talk to let's encrypt) supports it
13:14:02 <EvanR> the Roundable class seems to make a lot more sense than the stdlib
13:15:15 <EvanR> but it has 44 downloads and was last updated in 2010
13:18:15 <phadej> bandali: there are intermediates in what acme-tiny generates
13:23:12 <bandali> phadej, hmm, are you sure? in that case i’d recommend checking with https://www.ssllabs.com/ssltest/ to make sure it’s being used, and see if there are any other problems
13:23:42 <phadej> bandali: thanks for the tip
13:24:29 <bandali> phadej, cheers. please feel free to ping me here or email me if you find anything interesting
13:24:55 <phadej> bandali: I honestly miss types in this ssl certificate business
13:25:06 <bandali> i’m really hoping this is the problem planet has been having with some of the feeds, and not some insanely hard to reproduce heisenbug
13:25:14 <bandali> phadej, ditto :)
13:25:15 <phadej> the file extensions are opaque and I have no idea what I do
13:25:51 <bandali> worse thing is, the extensions generally don’t mean much, or at least different ca’s and programs use them interchangeably
13:30:50 <phadej> bandali: is there some tool to dump what the contents of PEM files are?
13:31:24 <phadej> ssllabs indeed say that chain is incomplete, but I'm not sure what's is where
13:31:50 <geekosaur> the openssl command can do it
13:33:12 <bandali> ^
13:34:15 <bandali> phadej, in think openssl has a verify switch or subcommand i’d look into
13:34:31 <hpc> s_client and s_server are really useful too
13:34:31 <bandali> perhaps try searching around for openssl verify certificate chain or something like that
13:34:53 <hpc> run those locally and you can test an entire connection in isolation
13:35:02 <phadej> openssl x509 -in aaa_cert.pem -noout -text
13:35:27 <geekosaur> janat08, did you get this from somewhere? it looks to me like you never specify it needs to run in IO, so it defaults to something else (Identity probably) and can't run your widget which requires IO
13:37:39 <janat08> geekosaur: the original example used monadwidget, but I don't think youre meant to use that with obelisk
13:39:25 <janat08> it would error too
13:40:41 <geekosaur> er? obelisk is about deployment. the reflex app does what ti does, obelisk is about the stuff outside the program code that needs to happen for the program to be a usable web app
13:41:58 <phadej> bandali: I might found a problem, but as I cannot reboot web server, i'll only know tomorrow if it worked
13:42:02 <janat08> or if you're reffering to the Frontend part, that's what obelisk generates, the main.hs file won't even react to changes you make to it. Obelisk being multiplatform basically cant have some of reflex stuff thats only meant for ghcjs
13:42:03 <phadej> bandali: thanks for pinging, anyway!
13:42:49 <bandali> phadej, no problem! let’s check back tomorrow then. if this turns out to be the only issue i’d be *super* happy :)
13:44:38 <phadej> does everything fails if it fails to fetch my feed?
13:47:46 <bandali> no i think it continues trying to fetch the rest of the feeds
13:48:23 <bandali> though there are a large number of broken feeds, hopefully only because of similar misconfigured web servers
13:55:04 <janat08> geekosaur: you want to see the main.hs?
13:56:08 <janat08> https://www.irccloud.com/pastebin/BcQFkxlZ/
13:57:14 <fr33domlover> I'm wondering if there's some memory leak thing in GHC 8.6, or maybe just stuff changed; it's using tons of RAM for the build and it also slows it down very much because of the swap usage
13:58:30 <merijn> fr33domlover: Maybe someone in #ghc can help you determine if it's indeed a regression or something else is happening
13:58:48 <janat08> fixed the gist, and basically `ob run`  won't even read the contents of the file, it will just assume its unchanged
13:59:01 * fr33domlover probably needs a more powerful laptop regardless, for efficient development :p
13:59:14 <phadej> it helps
13:59:16 <fr33domlover> Thanks merijn :)
14:05:29 <fr33domlover> Btw anyone has recommendations for a laptop? That can run on fully free software. I have a currently-broken-needs-fixing Thinkpad T400 which Libreboot which is really nice except it's huge and heavy like a tank, and I wish I had something smaller and less sensitive (even if it didn't work with Libreboot; at least use fully free distro)
14:07:04 <fr33domlover> I want to be able to travel with it in my bag, and carrying such a heavy laptop is a pain. Actually anyone here is a tech nomad carrying a laptop and using it for Haskell development? ^_^
14:08:17 <duncan> When I'm using stack, extra-deps appears to fetch from Hackage automatically. How can I tell it to fetch it from stackage-nightly?
14:13:32 <phadej> duncan: that sentence doesn't make sence
14:13:43 <phadej> do you mean to automatically pick version as in stackage-nightly?
14:30:10 <duncan> Well, here's an example - the wl-pprint package doesn't appear in LTS-13.26. Verison 1.2.1 is however available from Hackage, and there's some version available in a certain snapshot of stackage nightly.
14:30:39 <duncan> If I specify 1.2.1 in my stack.yaml under extra-deps, where does it actually pull it from? Is there a way to specify I want to pull it from somewhere else?
14:32:56 <janat08> fr33domlover: buy some trash, and use some cloud service for virtualized development
14:40:04 <fr33domlover> janat08, I'm aware of that option and prefer not to, 1 reason being that it requires sane internet access and I don't want to be limited by that (needing to charge a laptop every few hours is already quite limiting by itself)
14:41:30 <fr33domlover> I suppose I can do with something like the T400, or even what I'm using right now (intel core 2 duo t6600 , 11 year old laptop), if it was smaller and battery held for longer etc.
15:27:58 <chalkmonster> fr33domlover: oh man, I had one of those c2d's. Best chip of the era
15:29:47 <fr33domlover> chalkmonster, haha the thing I love about it the most is that it's 11 years old, I used it for years 24/7 on as a little server in my apartment, it went through so much, it's my very first laptop and it's still alive and kicking ^_^
15:31:34 <fr33domlover> It's a bit weak for my current Haskell needs though, although I haven't tried ghcid yet (not sure if that's more demanding or less demanding than the heavy regular GHC builds)
15:42:15 <WurstBroHD> Hey - can someone help me with this error?
15:42:19 <WurstBroHD> https://gist.github.com/OliverHabersetzer/aa86bbadaa3c2f1108503dd44b1b81f6
15:43:08 <WurstBroHD> Basically - I'm trying to build a project with GTK on Arch but it doesn't work quite as well as I intended (as you can see in the log).
15:43:25 <WurstBroHD> On Ubuntu latest it works though...
15:45:35 <hpc> that looks like it's missing the error
15:45:42 <hpc> is that the whole log?
15:45:58 <WurstBroHD> I can use -v if that helps :)  1 sec
15:48:15 <WurstBroHD> https://gist.github.com/OliverHabersetzer/e11d62ed30a5b1b5393005be1fb5dd45
15:51:01 <hpc> hmm
15:51:42 <hpc> gtk2hs-buildtools-0.13.5.0 definitely has that module
15:52:01 <WurstBroHD> yeah I wondered that too
15:52:48 <WurstBroHD> I removed the dist directories just in case - same problem
15:53:45 <WurstBroHD> `cabal v2-install gtk2hs-buildtools-0.13.5.0 --reinstall --lib` sadly didn't help either
15:55:42 <hpc> if in your project's working directory, you ran 'find . | grep Gtk2HsSetup'
15:56:07 <hpc> i wonder if it shows up
15:56:20 <WurstBroHD> nope - nothing
15:56:43 <hpc> er, maybe i am thinking of how stack organizes things
15:56:52 <remexre> Is there an operator that's Lens' a b -> Lens' a c -> Lens' a (b, c) ?
15:57:06 <WurstBroHD> yeah I think too - cabal removes all temp files after build 
15:57:09 <remexre> also, a way to make hoogle nicer for lenses? :|
15:57:17 <WurstBroHD> ...not all but most
15:59:22 <WurstBroHD> remexre Hoogle is a constant point of frustration for me too - regardless of topic (most of the time anyways ^^)
16:01:12 <hpc> every time i get annoyed at hoogle, i remember that no other language has anything like it
16:01:52 <remexre> Idris has :search :P
16:02:08 <WurstBroHD> remexre how 'bout https://hackage.haskell.org/package/hs-functors-0.1.4.0/docs/Data-Profunctor.html#v:-38--38--38-
16:02:44 <remexre> WurstBroHD: Oh, that looks possible; I'll try it out; thanks!
16:04:28 <WurstBroHD> hpc not the search function by type sadly
16:04:42 <WurstBroHD> ...although that would be pretty easy to implement in most languages
16:05:55 <WurstBroHD> I mean there is npm, rust crates, nuget for c# and so on but all of these don't really help when searching for basic language features
16:06:05 <hpc> those only index package names as well
16:06:37 <WurstBroHD> yeah - that's what I meant
16:08:06 <WurstBroHD> but most other languages don't have two competing build systems nobody seems to agree on which is better :'D
16:08:46 <hpc> they usually have more than two :D
16:12:18 <WurstBroHD> yeah there are - but in most cases you can say "Use C/C++? gcc", "C#? Mono on linux, mscsharp on windows", "js? npm & node" and so on ;)
16:12:44 <WurstBroHD> Not even my professor has a real opinion whether to use cabal or stack
16:13:14 <monochrom> Wait, gcc is not a build system.
16:13:15 <hpc> once the cabal v2 stuff is unprefixed, there will be zero reason to use stack imo
16:14:25 <hpc> right now the only arguments for stack are "my distro's cabal isn't new enough" and "it looks weird in my bash history"
16:14:43 <WurstBroHD> ...fair point for gcc :''''DDD
16:15:47 <hpc> for C you have make, cmake, automake, choice of autoconf on top of it
16:15:51 <hpc> alternative make implementations
16:16:15 <monochrom> Wait, automark is a meta-build system...
16:16:19 <hpc> https://media.giphy.com/media/9QgdMczZy2u1q/giphy.gif
16:16:20 <WurstBroHD> why doesn't cabal check for self updates upon startup? even if it's periodically would suffice. I have to dl the package for arch, execute cabal-install, add to PATH, remove package again and hope it worked. That's lame
16:16:22 <monochrom> s/automark/automake/
16:16:28 <solonarv> remexre: that operator exists, but it's hidden away in Control.Lens.Unsound because it gives you a broken Lens if the inputs overlap, so it's unsafe
16:16:45 <monochrom> ("automark" is my program for running test cases on students!)
16:16:51 <hpc> heh
16:16:52 <monochrom> (err students' code!)
16:17:19 <solonarv> WurstBroHD: if your setup is that janky I would recommend just switching to ghcup
16:17:26 <hpc> i think when you rpmbuild C code it skips make entirely as well
16:17:26 <solonarv> @where ghcup
16:17:26 <lambdabot> https://www.haskell.org/ghcup/
16:17:36 <hpc> but don't quote me on that
16:18:09 <WurstBroHD> solonarv I actually did that :'D
16:18:16 <monochrom> I recommend #ifdef Windows \n chocolatey \n #else \n ghcup \n #endif
16:18:49 <solonarv> agreed!
16:27:25 <WurstBroHD> I tried investigating more - https://gist.github.com/OliverHabersetzer/9aeb8a5bc962b76e1e9de46746944b17
16:27:31 <WurstBroHD> maybe this is cause of my problem?
16:28:19 <WurstBroHD> whole bunch of `Warning: haddock-html: [...] doesn't exist or isn't a directory`
16:29:47 <solonarv> nah, it's just complaining that documentation isn't there
16:30:36 <solonarv> which doesn't matter unless you want to browse that documentation or maybe build documentation for your own packages
16:31:25 <WurstBroHD> not really - if that doesn't cause packages not to be found...
16:33:00 <remexre> solonarv: is there a sound version for getters?
16:34:54 <solonarv> remexre: it's certainly possible to write - and also that unsafe function is completely safe if you only use the result as a getter
16:36:04 <solonarv> the easiest implementation is: getterProduct l1 l2 = to (\s -> (s ^. l1, s ^. l2))
16:37:04 <dibblego> I have been working on this particular problem, but have hit a wall.
16:37:06 <oats> where can I put ghc options that I want all new stack projects to use by default?
16:40:32 <hpc> oats: in every stack project, if it's something significant
16:41:35 <hpc> (or a template so it's applied by 'stack new')
16:46:23 <oats> hpc: gotcha, thanks
16:48:14 <hpc> if it's something you want magically applied to all stack projects from outside the working directory, not sure
16:48:17 <hpc> never had to do that
16:53:07 <thosgood[m]> @pl \f g -> h . g . f
16:53:07 <lambdabot> ((h .) .) . flip (.)
16:53:58 <thosgood[m]> @pl \f g -> g . f . h
16:53:58 <lambdabot> flip (.) . (. h)
16:54:35 <thosgood[m]> @pl \f g -> g . h . f
16:54:35 <lambdabot> flip (.) . (h .)
16:54:53 <thosgood[m]> definitely some interesting pattern to be figured out there
17:04:30 <fr33domlover> /o/ I'd like to have a periodically running action but also be able to trigger it via user input, skip the waiting and do it now (and then again wait for the next periodic run). One way to do it: Catch async exception in the 'delay' part, moving straight to the action itself. Another way: Use an MVar with 2 writer
17:04:45 <fr33domlover> Oops sent before I finished typing
17:05:03 <fr33domlover> I guess I'll use the MVar option :)
17:05:33 <fr33domlover> (Hmm there's also STM and <|> allowing to wait on 2 different writers)
17:22:48 <glguy> fr33domlover: For waiting for either an mvar (or two or three) or a timeout I'd recommend STM
17:22:54 <glguy> see registerDelay
17:25:51 <fr33domlover> glguy, thanks! I forgot about that function ^_^ (was thinking about manually launching a thread that periodically set the MVar; I guess it's roughly the same thing)
17:43:59 <crestfallen> sorry I was disconnected my question is at http://sprunge.us/cqXUxq   It's the last function getNat
17:44:40 <crestfallen> what input does  all isDigit xs   take?
17:47:09 <crestfallen> this is an unbeatable ticTacToe game. I don't see what getNat prompt does, and the if statement after the && operator
17:51:29 <remexre> is there a version of `at` that's a prism instead of a Lens' _ (Maybe _) ?
17:53:10 <glguy> remexre: No, it doesn't quite make sense as a prism
17:53:13 <glguy> what are you trying to do?
17:53:29 <remexre> get from a map entry
17:54:31 <remexre> I guess prism is the wrong notion
17:54:33 <remexre> or 
17:54:35 <remexre> wait
17:54:41 <remexre> at key . _Just is what I want, innit
17:55:16 <andreabedini> remexre: that's the same misconception I had until ~ a month ago. A prism refers to the whole thing, while clearly a map can have more entries 
17:56:13 <andreabedini> having a Prism Map Entry would imply that a Map is one Entry
17:56:21 <shachaf> "at key . _Just" is also called "ix key"
17:56:23 <crestfallen> since isDigit returns a Bool whether one character is a single digit, how can you use all there? : ' all isDigit xs '
17:59:00 <crestfallen> any help appreciated
18:17:44 <dmj`> :t all isDigit
18:17:45 <lambdabot> Foldable t => t Char -> Bool
18:23:35 <MarcelineVQ> dmj`: he's not here just now
18:24:51 <dmj`> MarcelineVQ: thanks
18:47:53 <hololeap> how would you use parsec to check the end of a string, like if you wanted to match hostnames of foo.com or bar.com?
19:04:51 <turab> @pl \x y -> x ++ " " ++ y
19:04:51 <lambdabot> (. (' ' :)) . (++)
19:05:43 <turab> Ha, lambdabot smiled at me
19:07:19 <turab> @pl \x y -> " " ++ x ++ y
19:07:19 <lambdabot> ((' ' :) .) . (++)
19:10:01 <oats> turab: what does @pl do?
19:13:46 <oats> @pl \c -> isAlphaNum c || c == '-'
19:13:46 <lambdabot> liftM2 (||) isAlphaNum ('-' ==)
19:14:02 <oats> oh, is that point-free-ification?
19:16:07 <turab> I think so! I joined this channel today and just learned that lol
19:16:16 <oats> what monad is that one talking about
19:16:20 <oats> I'm confused
19:16:57 <turab> Reader?
19:17:01 <oats> @pl \c -> (isAlphaNum c) || (c == '-')
19:17:02 <lambdabot> liftM2 (||) isAlphaNum ('-' ==)
19:18:49 <oats> :t liftM2 (||) isAlphaNum ('-' ==)
19:18:51 <lambdabot> Char -> Bool
19:18:58 <oats> :t liftM2 (||) isAlphaNum
19:19:00 <lambdabot> (Char -> Bool) -> Char -> Bool
19:19:34 <oats> :t liftM2 (||)
19:19:36 <lambdabot> Monad m => m Bool -> m Bool -> m Bool
19:19:44 <turab> :t ('-' ==)
19:19:46 <lambdabot> Char -> Bool
19:20:02 <oats> I think it's in the function monad
19:20:06 <oats> that's interesting
19:20:12 <turab> Yea that's reader, right?
19:20:18 <oats> I haven't seen a use of the function monad before
19:20:30 <oats> turab: where are you getting reader from?
19:22:06 <turab> Reader instance is Monad ((->) r), which is what I think you have
19:23:51 <turab> I used to in a an interpreter to "read" the environment and that's usually how it is used I think
19:26:22 <turab> used it in an *
19:27:02 <oats> sorry, I still don't understand what readers have to do with this
19:28:10 <oats> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#line-828
19:28:22 <oats> instance Monad ((->) r)
19:28:52 <oats> @unpl liftM2 (||) isAlphaNum ('-' ==)
19:28:52 <lambdabot> (\ a0 -> return (isAlphaNum a0 || ('-' == a0)) a0)
19:29:15 <oats> heh, still using the function monad
19:29:39 <oats> @unpl ((' ' :) .) . (++)
19:29:39 <lambdabot> (\ x x0 -> ' ' : (x ++ x0))
19:32:44 <oats> “The @pl (point-less) plugin is rather infamous for using the (->) a monad to obtain concise code.”
19:32:49 <oats> heh, so its a known thing
19:32:52 <oats> fun
19:36:35 <turab> oats: https://eli.thegreenplace.net/2018/haskell-functions-as-functors-applicatives-and-monads/
19:36:47 <turab> Maybe that will explains it
19:37:10 <turab> Skip to the monad instance
19:49:22 <MarcelineVQ> "concise"
19:49:54 <MarcelineVQ> probably more terse than concise :>
20:01:31 <oats> @pl \a b -> return $ a && b
20:01:31 <lambdabot> (return .) . (&&)
20:03:07 <oats> @pl \c -> d $ e [f, c]
20:03:07 <lambdabot> d . e . (f :) . return
20:04:11 <oats> am I bad if I want to see an entire program rewritten in point free with this? lol
20:06:26 <turab> If you do, let me see that pls
20:07:17 <jackdk> oats: prepare to have your mind blown: https://www.youtube.com/watch?v=vzLK_xE9Zy8 . Not only does the talk do that, but it then reinterprets the program by swapping out the underlying category!
20:07:38 <jackdk> (not much CT is required, and all of it is covered in the talk, so fear not)
20:12:15 <oats> bookmarked, thanks :)
20:13:45 <oats> @pl \x -> f [a x, b x, c x]
20:13:45 <lambdabot> f . liftM2 (:) a (liftM2 (:) b (return . c))
20:13:55 <oats> that's horrifying
20:14:10 <oats> amusing, but horrifying
20:15:10 <turab> @pl \c -> all ($ c) [not . isSpace, (')' /=), ('(' /=), ('\"' /=)]
20:15:10 <lambdabot> flip all [not . isSpace, (')' /=), ('(' /=), ('"' /=)] . flip id
20:15:47 <oats> "flip id"
20:15:47 <turab> Lmao
20:15:51 <oats> lol what
20:15:56 <turab> hahaha
20:16:02 <turab> I didn't even realize
20:16:18 <jackdk> % :t flip id
20:16:18 <yahb> jackdk: b -> (b -> c) -> c
20:16:32 <jackdk> oh right, it's (&)
20:18:13 <turab> What does % do?
20:28:23 <slack1256> Has anyone done a blogpost using the retainer profiler on a worke example?
20:54:08 <hiptobecubic> Does anyone want to take a swing at explaining the intuition behind scott endcoding?
20:54:59 <hiptobecubic> I am working through https://www.codewars.com/kata/59c132fb70a3b7efd3000024/train/haskell and making progress via type-tetris, but I feel like I'm just blinding plugging things together
20:56:41 <hiptobecubic> Take 'newtype SPair a b = SPair { runPair :: forall c. (a -> b -> c) -> c }'  for example. It seems like we remember a and b in the runPair func, then feed it into the first argument. 
20:57:40 <hiptobecubic> So if we feed it (,)... it should fall back down to (a, b) type rather than SPair a b
20:58:12 <hiptobecubic> Fine, that doesn't seem insane. I don't see why we care, but it at least isn't completely crazy looking
20:58:29 <hiptobecubic> But now take newtype SList a = SList { runList :: forall b. b -> (a -> SList a -> b) -> b }
21:00:35 <hiptobecubic> If this is somehow analogous to [a], then what is b doing there? The second arg looks a *lot* like (:), but of course not quite, since we're consing to an SList and not a regular list...but still.. what is b? Some kind of base case? Why?
21:01:20 <c_wraith> because some lists are empty
21:01:24 <hiptobecubic> toList :: SList a -> [a]
21:01:27 <hiptobecubic> toList s = (runList s) [] (\x -> (x:) . toList)
21:01:55 <hiptobecubic> I came up with that and it works, but I'm still confused about the type signature
21:02:02 <c_wraith> that b is doing the exact same thing it does in a Church encoding
21:02:15 <hiptobecubic> I am also unfamiliar with church encoding
21:02:52 <hiptobecubic> is it somehow more intuitive? Did I just get unlucky in being randomly given this problem before some other one that models these types with church encoding first?
21:03:08 <c_wraith> I think it's slightly easier, but mostly the same
21:04:20 <hiptobecubic> I get that [] is somehow 'b'... but i just.. somehow it just doesn't seem concrete.
21:05:01 <hiptobecubic> [] :: [a] just like (x:[]) :: [a], so why is this base case for the scott encoded list a different type?
21:05:21 <c_wraith> the encoding is defined as a transition to an arbitrary type
21:05:32 <hiptobecubic> I guess it's somehow more general and if you use [] then b ~ [a]?
21:05:49 <hiptobecubic> "a transition to an arbitrary type" ...
21:06:25 <c_wraith> this stuff is easier to talk about, in a Haskell sense, with a Church encoding.
21:06:33 <c_wraith> mostly because of foldr
21:06:43 <hiptobecubic> Is there some illustrative example of using SList that isn't clearly more simple when just using [] ?
21:08:52 <johnw> hiptobecubic: When you define a data type, you specify the type of its constructors. When you define a Church encoding of a data type, you specify a function that takes functions having the same type as those constructors -- with any instances of the "data type" replaced by a universally quantifier.  For example, data Identity a = Identity a, and type ChurchIdentity a = forall r. (a -> r) -> r. If you pass the Identity constructor to
21:08:52 <johnw> the ChurchIdentity function, you'll get Identity. Likewise, if you pass [] and (:) to the Church encoding of a list, you'll get a list.
21:09:15 <johnw> as some may note, this isn't technically a Church encoding, but a Boehm-Berarducci encoding, but Church is much easier to type :)
21:10:00 <hiptobecubic> hmm
21:10:25 <c_wraith> anyway, Scott encodings are more awkward because they require a newtype when the type is recursive
21:10:32 <johnw> An upside to Church encodings is that they are just functions, so you can have data that exists only computationally, rather than represented in memory. However, you lose the ability to "walk" the structure of the data. Scott encodings give the ability to discriminate intermediate constructors back to you.
21:11:48 <c_wraith> :t \s -> runList s True (const $ const False)  -- eh, even this isn't simpler than pattern-matching, let alone using foldr
21:11:49 <lambdabot> SList b -> Bool
21:12:01 <johnw> hiptobecubic: btw, all of this stuff is entirely mechanical, once you notice the pattern. It requires zero creativity. The library https://hackage.haskell.org/package/recursors can auto-generate these so-called Church encodings for you from any regular data type.
21:12:31 <nshepperd1> The arguments to runList are instructions for processing the list. The first argument (b) is what to return if the list is empty. The second argument (a -> SList a - > b) is what to do if the list has a head and a tail
21:12:47 <hiptobecubic> I believe that it's mechanical. That's clear from the fact that I'm working my way through this challenge despite having no idea what's going on or why
21:14:04 <nshepperd1> sumSList :: SList Int -> Int; sumSList s = runList s 0 (\x ss -> x + sumSList ss)
21:14:06 <c_wraith> hiptobecubic: but my example above at least shows why it's forall b
21:14:12 <hiptobecubic> hmm, that makes sense i guess
21:14:33 <hiptobecubic> so we're specifying what to do in each case, rather than what values are present...?
21:14:59 <nshepperd1> When you call runList, yes
21:15:09 <hiptobecubic> But if you want to produce anything, then you need values somewhere... i suppose they are embedded via nested continuations?
21:15:16 <c_wraith> you should look at this from the other side
21:15:25 <c_wraith> create some SList values
21:15:33 <c_wraith> without using any helper functions
21:15:55 <c_wraith> Like, what's the SList for an empty list?
21:18:10 <hiptobecubic> hmm
21:19:13 <hiptobecubic> SList (\b fas -> b).... I guess
21:19:25 <hiptobecubic> which is (SList const)
21:19:52 <hiptobecubic> if the SList is "empty" then we don't use the function corresponding to processing the head and tail
21:20:23 <c_wraith> does that make it any clearer why any type at all is allowed for the first argument?
21:22:48 <hiptobecubic> I mean, I can see that any type should work fine. The same was you can slap a function "[a] -> b" on any normal list and get whatever b out
21:23:20 <hiptobecubic> I struggle to see why this is better than just doing that
21:23:24 <c_wraith> Now...  what's an SList corresponding to "hi" look like?  ("hello world" is *way* too long)
21:25:17 <hiptobecubic> Slist (\_ f -> f 'h' (SList (\_ f -> f 'i' (SList (const ""))))) ?
21:25:45 <c_wraith> that base case doesn't look like your previous base case...  :P
21:25:51 <hiptobecubic> err... const
21:25:55 <c_wraith> yeah
21:26:12 <c_wraith> now, this almost never leads to prettier code.
21:26:30 <hiptobecubic> Is there anything you can do with this that is useful at all?
21:26:35 <c_wraith> But sometimes it can be a huge improvement in performance
21:26:42 <hiptobecubic> ah
21:26:58 <hiptobecubic> Is difflist some special case of this?
21:27:57 <c_wraith> no.  It's more of a CPS-encoded list.  Which is an example of using functions as the top-level type, but they don't replace the list constructors
21:32:07 <c_wraith> Difflist still depends on [] to work.  All it does is take advantage of the way function calls work to automatically re-associate appends efficiently
21:32:24 <hiptobecubic> so... cons :: a -> SList a -> SList a
21:33:11 <c_wraith> you've basically already written that.  Just take advantage of what you did in translating "hi"
21:33:17 <hiptobecubic> yeah
21:33:52 <hiptobecubic> cons a as = SList (\_ f -> f a as)
21:40:26 <hiptobecubic> concat still doesn't seem obvious
21:40:49 <hiptobecubic> on [], it's easy enough by deconstructing the first arg with pattern matching
21:41:16 <hiptobecubic> c (r:rs) l = r : (c rs l)  -- and so on
21:41:19 <c_wraith> there's no difference except syntax.  Idees are the same.
21:41:50 <c_wraith> *ideas
21:49:19 <hiptobecubic> concat r l = SList (\_ f -> (runList r) l f)   ?
21:51:14 <hiptobecubic> when we get to the end of r, the "base case" list is l.. but when we get to the end of l we should still do something.. I guess that's passed in when this SList is run?
21:52:58 <c_wraith> that doesn't look right if both inputs are empty
21:53:43 <hiptobecubic> hm
21:54:53 <hiptobecubic> if r is empty, then we should just end up with l
21:55:38 <hiptobecubic> and likewise if l is empty..
22:04:18 <hiptobecubic> concat l r = SList (\b f -> runList r (runList l b f) f)
22:05:09 <hiptobecubic> "run through r with f and when you get to the end run through l with f and end with b" ?
22:07:13 <hiptobecubic> I need to sleep, but this was helpful
22:07:43 <hiptobecubic> Thanks c_wraith. Also johnw and nshepperd1 
22:09:19 <nshepperd> for concat i would start by destructing l
22:09:24 <nshepperd> just like how you do with []
22:09:45 <hiptobecubic> oh oops, yes.
22:09:55 <hiptobecubic> i had them backwards
22:10:09 <nshepperd> concat l r = runList l _foo _bar
22:11:20 <hiptobecubic> well it has to return an SList
22:11:26 <hiptobecubic> i suppose i could construct an empty one for the end
22:11:49 <nshepperd> yes, and it will do that as long as _foo and _bar return SLists
22:12:07 <nshepperd> _foo is the value for the case where l is empty
22:14:05 <hiptobecubic> yes, but by bother running through the second slist when we can just spit it back out?
22:14:48 <nshepperd> right, when l is empty, concat l r = r
22:15:04 <nshepperd> so now we have concat l r = runList l r _bar
22:15:25 <hiptobecubic> _bar is cons
22:15:57 <hiptobecubic> cona a s = SList (\_ f -> f a s)
22:16:32 <nshepperd> are you sure?
22:16:35 <nshepperd> what about r?
22:16:46 <nshepperd> concat l r = runList l r (\lhead ltail -> _)
22:18:30 <hiptobecubic> i'm confused. in "runList l r _bar", r is the basecase yes?
22:19:25 <hiptobecubic> and _bar is this \head tail -> ... func, but returning an SList, which seems like cons above
22:20:51 <nshepperd> it needs to be an SList with r on the end
22:21:20 <hiptobecubic> Hmm yes. definitely does not work as is
22:22:03 <hiptobecubic> i'm consued. if r is the basecase for running through l, why doesn't it appear on the end?
22:22:11 <hiptobecubic> confused*
22:23:03 <nshepperd> we've set r as the case for when l is empty
22:23:21 <hiptobecubic> ah yes
22:23:21 <nshepperd> I wouldn't call it a 'base' case, because we're not recursively calling concat yet
22:23:33 <hiptobecubic> cons ignores it anyway so clearly it's wrong
22:25:45 <nshepperd> i'll give a hint: it's exactly the same as the implementation for []
22:26:42 <nshepperd> except you need to write cons instead of :
22:41:20 <hiptobecubic> christ that was embarassingly simple
22:41:25 <hiptobecubic> obviously it's time for bed
22:41:28 <hiptobecubic> thank you
22:42:16 <hiptobecubic> concat l r = runList l r (\l ls -> cons l (concat ls r))
22:42:21 <hiptobecubic> night!
22:42:32 <nshepperd> night :)
22:43:40 <hiptobecubic> i think i was hung up on not being able to pattern match the cons to detect the empty case, but didn't realize that the two args to (runlist s) *are* the two matches
22:45:57 <nshepperd> yup!
23:30:45 <shafox> Is there a package that features in locking on file/dir when writing ? 
