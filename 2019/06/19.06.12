00:00:06 <Nevoic> i.e there's a reason that we want our values to be type specific and our functions to be general.
00:00:15 <Nevoic> I could be totally off base on that though, coming up with this on the spot.
00:01:41 <Nevoic> Can a "general value" even exist? Doing `pure 1` in the ghci just constrains it to an Integer.
00:01:56 <Nevoic> I'd imagine type inference would allow its value to be determined as different things at compile time?
00:01:58 <jgt> koz_: I love hysterical raisins
00:02:10 <MarcelineVQ> uh, I don't really follow. I'm saying that writing [1] is clearer than writing pure 1 when conveying that you're working with lists, ditto for map instead of fmap. Both in code and in errors.
00:04:02 <koz_> :t pure 1
00:04:03 <lambdabot> (Num a, Applicative f) => f a
00:04:09 <koz_> Nevoic: ^
00:05:23 <Nevoic> My point is that there's an actual, practical difference between map/fmap & pure/[] that you're not specifying.
00:05:31 <Nevoic> I could be wrong, but I think I'm right.
00:06:31 <Nevoic> Oh wait, nevermind. I think I'm wrong.
00:06:41 <Nevoic> I'll sit on it for a bit and come back if I think I'm right again.
00:06:42 <Nevoic> lol
00:07:04 <MarcelineVQ> Yes there is a difference. I'm not trying to specify anything of that form, my point is simply that when you want to be more clear to a reader you use something more specific.
00:07:46 <MarcelineVQ> This isn't some hard rule, but [1] vs pure 1 is to me a good example where the first one gives me more immediate information/meaning.
00:08:34 <MarcelineVQ> because "which pure?" isn't something you need to ask
00:08:59 <Nevoic> Are you saying `which map` is an actual question you'd be asking if `map` was general and there was no `fmap`?
00:09:37 <Nevoic> Because in all my usecases of `map`, I could've just as easily used `fmap` and not have lost information, maybe my functions are small and type information is pretty explicit though.
00:09:38 <MarcelineVQ> I would certainly ask that, I ask that with fmap all the time
00:09:50 <MarcelineVQ> "which <$> is this now.."
00:10:23 <Nevoic> How do you figure it out?
00:10:28 <Nevoic> You're talking about types right?
00:11:06 <Nevoic> I have `F2` bound to tell me the type of an expression, so when I'm over something and hit f2 it'll just tell me.
00:11:08 <MarcelineVQ> I would examine the types yes, as part of reasoning through each piece of the expression
00:12:11 <MarcelineVQ> Knowing the end type isn't hard, it's in the declaration, it's the intermediate stuff that you have to figure out when an error pops up
00:12:15 <jle`> Nevoic: using map code a lot more immediately readable
00:12:27 <jle`> er, using map can make code a lot more immediately readable
00:12:38 <jle`> it's also good for helping out type inference too if you're doing type tetris with typed holes
00:13:04 <Nevoic> MarcelineVQ: The tool I'm talking about lets you inspect the type of anything as long as the file is compiling. It can be in the middle of a 400 character long line.
00:13:18 <jle`> so it can be useful for reading code (you immediately know f ~ []), and it can be good for writing code (ghc can give you more helpful typed hole suggestions)
00:13:47 <jle`> you have to admit that map has at least some non-zero benefit in readability over fmap in most situations
00:13:55 <MarcelineVQ> That's great, and it's good to have such tools. But it's not really realted to the point I'm making
00:14:08 <jle`> it's the same reason why we use (.) instead of fmap  (aside from associativity)
00:14:52 <Nevoic> jle` honestly the only reason I have used map over fmap is because I came from OO languages and didn't understand what fmap was.
00:14:56 <koz_> Or (<<<).
00:15:13 <jle`> being able to immediately know the type from reading it as a human being is a lot less friction than having to use a tool to figure it out
00:15:22 <Nevoic> But I always thought "ah I wish I could "map" over a Maybe", not realizing that `fmap` was that.
00:15:41 <Nevoic> If someone asked me what fmap was, I'd literally just say "it's a more general map".
00:15:49 <jle`> you might not be able to reap the benefits of map vs fmap in *writing* code, unless you write in an interactive typed holes style
00:15:55 <jle`> but you'd definitely reap the benefits in *reading* code
00:16:04 <jle`> try reading code you wrote a week or a month (or a year) earlier
00:16:11 <jle`> the map version is going to be much easier to read than the fmap version
00:16:15 <Nevoic> Maybe my problem is more with the word choice than the fact that there exists a technically redundant function to improve readability.
00:17:05 <jle`> can you elaborate on your actual problem maybe, then?
00:17:13 <Nevoic> `fmap` reads to me as "functor map", as in `map but more general than map, instead for functors`.
00:17:16 <jle`> you see the value in having both 'map' and 'fmap', right?
00:17:16 <Cale> Somehow I wouldn't mind going back to having 'map' be the name of Functor's method, like it was in Haskell 1.4
00:17:33 <Cale> But I do mind the idea of discarding 'return' in favour of 'pure'
00:17:48 <Nevoic> I didn't realize that `fmap` was previously named `map`.
00:17:50 <Cale> The difference between the two is actually useful for readability
00:17:56 <Nevoic> That seems like a regression instead of a progression.
00:18:04 <Nevoic> I would prefer `map` and `listMap`
00:18:16 <Nevoic> Then you could also have `maybeMap` and other maps if you think having specific instances of it is helpful.
00:18:16 <jle`> yeah, that wouldn't be so bad too
00:18:20 <jle`> as long as there are two different ones
00:18:26 <Cale> Professors wanting to teach their students didn't want to have to introduce typeclasses before map
00:18:36 <Cale> and they were the main people who mattered at the time
00:18:49 <jle`> yeah, we definitely walked back on that priority as a community with the BBP
00:18:52 <Nevoic> Ah, that's something I haven't considered. Haskell is mostly academic.
00:18:57 <jle`> well, it used to be
00:18:58 <Nevoic> Or at least based in academics.
00:19:01 <nshepperd_> *fmap* is the sound of an introductory haskell textbook being dropped on a table
00:19:02 <jle`> for maybe ten or twenty years
00:19:11 <nshepperd_> And that's why i like the name
00:19:17 <jle`> in the past decade or so the priorities have definitely shifted within the haskell community
00:19:36 <Cale> Also, given that the distinction exists, I will tend to use 'map' when I know that the argument is a list
00:19:37 <jle`> case in point, the BBP, which made teaching haskell/academic haskell much harder, but pragmatic haskell easier
00:19:48 <Cale> because it provides the reader with information about types
00:20:08 <jle`> yeah. having map = fmap, and renaming list map to something like listMap, would have solved all of our problems at the time
00:20:08 <Nevoic> I would much rather use type annotations to give the reader information about types.
00:20:10 <Cale> whereas if you use fmap, someone's mental typechecker has to work a little extra
00:20:29 <jle`> Nevoic: it's not always possible to fit a type annotation in a nice way
00:20:32 <Cale> Well, the type annotations are already going to be there -- hopefully not in the expression, but up at the top level
00:20:43 <jle`> and also it's somewhat removed from the actual call site
00:20:46 <Cale> Annotating everywhere in the middle of expressions just makes an unreadable mess
00:21:03 <Nevoic> I didn't mean in the middle, you can break up expressions into tiny functions and stick them in where blocks.
00:21:09 <Cale> But if you can provide subtle hints, it can make things more readable if you have the option.
00:21:16 <Nevoic> If you think the expression isn't clear enough as is, that doesn't sound like a bad idea imo
00:21:24 <Cale> Use the least polymorphic thing that you can get away with
00:21:35 <Nevoic> I think it's either A. simple enough to not need type annotations or B. not simple enough to not need type annotations.
00:21:40 <Cale> (without hurting yourself)
00:21:46 <jle`> Nevoic: that sounds like an unneeded compensation/justification for a problem that's already easily solvable
00:21:48 <jle`> "just use map"
00:22:20 <Cale> I hate it when people use 'pure' when the functor in question is known and is an instance of Monad
00:22:33 <jle`> in the end we have a lot of readability improvement tools in Haskell at our disposable
00:22:36 <jle`> * disposal
00:22:44 <Nevoic> Monads still frustrate me.
00:22:46 <jle`> there isn't any reason to take one off the table, just because we can sometimes use another
00:22:51 <Cale> Because immediately I have to wonder what the Applicative level of abstraction is needed for
00:22:55 <Nevoic> I've read over the monadic laws and know, to some basic level, what they are.
00:22:56 <jle`> "we have two arms anyway so why not get rid of one"
00:23:11 <Cale> and then am annoyed when I find out that after all it's just Monad
00:23:26 <jle`> the moment monads stop frustrating you is the moment you stop caring
00:23:37 <jle`> honestly it's not something worth looking at as a separate abstraction for the most part
00:24:38 <Nevoic> Something interesting that I've noticed is that at a certain point between unityped languages like Python/Ruby and very safely/advanced type systems like Haskell, exist languages like Kotlin/Swift, where I seem to disregard types more often than I do in Python or Haskell.
00:24:43 <Nevoic> And that's something I've always valued.
00:25:19 <Nevoic> If I call a method, I often don't know what type it returns. I know it's some kind of iterable (like `names`) and I know I want to transform the names. I hit `.` and see map, and then call it.
00:25:22 <Cale> I like Haskell because it lets me ignore types unlike something like Python or Scheme where I have to be intensely aware of them all the time.
00:25:47 <Cale> If I'm wrong about the types, the compiler will let me know
00:25:50 <jle`> Nevoic: i use that same sort of workflow in haskell
00:25:52 <Nevoic> Same, but I feel like I have to pay more attention to types than in Kotlin, which is something I'm not appreciating. There are things I'm definitely appreciating (simple syntax, pure functions).
00:26:00 <jle`> especially now that ghc can suggest functions that fit the exact type you want
00:26:09 <jle`> not only based on the input type, but the return type
00:26:39 <Cale> Perhaps it's that in Haskell, type tetris works a little better.
00:26:41 <Nevoic> What's the command for that? I have hoogle locally installed and interop with ghci via :info, :t, :browse, :k etc.
00:27:07 <Cale> Though, really, it's not a substitute for thinking about what your program actually does.
00:27:12 <Nevoic> I wanted to find a function that had at least 1 input type, an unknown number of other parameters, and an unknown return type.
00:27:20 <Nevoic> And I couldn't figure out a way to do that without sifting through pages of documentation.
00:27:26 <Nevoic> So I sifted through pages of documentation.
00:27:28 <jle`> Nevoic: in naked ghc, you leave a _ where you want to fill in
00:27:30 <jle`> and try to compile
00:27:36 <jle`> and ghc will pop out a list of the functions that fit there
00:27:44 <jle`> presumably it can be made a bit smoother with editor support
00:27:50 <Nevoic> Ah, that doesn't sound good enough tbh for what I was looking for.
00:27:52 <Nevoic> Good to know though.
00:28:09 <MarcelineVQ> that criteria describes every possible function
00:28:37 <Nevoic> What?
00:28:38 <edwardk> > [0,0..]
00:28:39 <Cale> It would be nice to have editor support that was as good as Agda's
00:28:41 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
00:28:57 <MarcelineVQ> "<Nevoic> I wanted to find a function that had at least 1 input type, an unknown number of other parameters, and an unknown return type."
00:29:09 <edwardk> -- i'm trying to run that locally in ghc 8.6.5 and it is spinning forever
00:29:14 <Nevoic> 1 known input type*
00:29:16 <Nevoic> is what I meant.
00:29:19 <edwardk> can someone duplicate?
00:29:32 <Cale> edwardk: lol
00:29:57 <edwardk> Cale: it doesn't print a single character
00:30:12 <Cale> edwardk: I can confirm that it works okay in 8.6.4
00:30:45 <Cale> lemme see if I have a convenient 8.6.5 via nix somehow
00:30:56 <edwardk> figured out what is going on
00:31:03 <phadej> edwardk: https://imgur.com/a/kB39FeY
00:31:04 <cocreature> in ghci-8.6.5 it works just fine for me
00:31:06 <cocreature> on Linux
00:31:06 <phadej> edwardk: what it was?
00:31:08 <edwardk> my dumb fault
00:31:14 <phadej> obviously ;)
00:31:31 <edwardk> i have a silly little shell script i forgot about which colorizes my ghci output =)
00:31:40 <Cale> ahhh
00:31:52 <edwardk> and it apparently chokes on the infinite line or something
00:31:54 <phadej> edwardk: it waits for a newline feed? :)
00:32:03 <phadej> yeah, those are hard :/
00:32:29 <edwardk> https://www.irccloud.com/pastebin/aakUOaQN/ghcic.sh
00:32:37 <Cale> something something monoidal parsing
00:34:10 <edwardk> first time it actually caused a problem
00:34:48 <Cale> edwardk: Have you seen the rambleed stuff?
00:35:05 <edwardk> i heard the term, but not seen what it means
00:35:11 <edwardk> been head down in parsing guts
00:35:12 <Cale> https://rambleed.com/
00:35:32 <Cale> They're using rowhammer in their own address space to read bits from outside it
00:35:56 <edwardk> oh jeez
00:35:58 <Cale> and they managed to steal a 2048 bit RSA key from OpenSSH
00:36:11 <Cale> and it works on ECC ram, even if every bit flip is corrected
00:36:20 <Cale> because reads against flipped bits will be slower
00:36:56 <Cale> On the one hand, I'm horrified, on the other hand, it's so cool that they managed to pull this shit off
00:37:45 <edwardk> another reason to never let anyone run code on my boxes
00:38:02 <Axman6> Glad to see Data61 still doing good work in this area
00:38:07 <edwardk> i've not yet reached the point of locking them in a vault and not running power in
00:38:07 <Axman6> never run code
00:43:41 <Axman6> Moral of the story, all computers should have a single core, running a unikernal
00:43:49 <maerwald> are there any ghc flags to optimise the executable for memory footprint?
00:44:26 <edwardk> oh well, it looks like that coloring script is unsalvageable, even with a call to gstdbuf to try to force sed to nonbuffering, the regexes don't give up matching or somethinf
00:44:44 <Cale> I'm actually pretty surprised at how slow the error correction on ECC RAM is. Apparently if there's a correctable bit flip, the overhead incurred is on the order of hundreds of thousands of cycles
00:44:47 <edwardk> i'd need to write a thing with a bounded match length, replacing sed for that purpose
00:44:57 <edwardk> shame, because it was nice getting colored output from show, etc.
00:45:52 <edwardk> might be a fun afternoon project some time, but i have better things to do
00:46:32 <Cale> I naively would have expected something like a linear code being used which would provide a uniform cost whether there were errors or not, but then, that's probably far too wasteful of... everything.
00:50:34 <solonarv> something something hook into the GHC API to produce a custom ghci frontend
00:51:36 <Cale> edwardk: edwardk gave some good talks about how to do that kind of monoidal parsing a while back :D
00:52:08 <edwardk> good to know
00:52:16 <edwardk> i think i follow him on twitter
00:59:31 <[exa]> Cale: ECC correction needs to stop the whole bus for a while to actually do the correction, which takes time
01:00:08 <[exa]> Cale: having the correction wiring everywhere would make the RAM brutally big
01:19:52 <contrun[m]1> is there a release date for ghc 8?
01:20:20 <cocreature> contrun[m]1: you mean 8.8? the latest release is 8.6
01:22:34 <edwardk> ok, i think i have that horrible ptr based parser basically working
01:22:39 <contrun[m]1> cocreature: Yes. I just searched the chat history and find another person already asked when will 8.8 be released. This message is sent because I erroneously forward the question asked by another person. Sorry about that.
01:23:03 <edwardk> contrun[m]1: june 21 was the last word i heard
01:23:12 <edwardk> but that may have been for a final alpha
01:23:31 <edwardk> bgamari_ said something on a cabal issue i watch
01:24:00 <edwardk> afaict there needs to be a cabal 3 release before its fully ready to go
01:24:38 <tdammers> hopefully things look better after zurihac :D
01:24:46 <contrun[m]1> edwardk: Thanks. I really look forward to the new hie files.
01:25:03 <edwardk> i'm looking forward to multiple public library support
01:25:07 <edwardk> sooo much
01:25:40 <edwardk> will be able to start shipping more 'kitchen sink' libraries where people won't have to have kitchen sink dependencies all the time
01:25:56 <edwardk> but without unduly increasing my maintainer burden
01:26:41 <tdammers> pipe dream: cabal tree-shake
01:26:53 <ocharles> that's just -fsplit-objects, no?
01:27:03 <cocreature> or rather -fsplit-sections these days :)
01:27:17 <ocharles> that's the one
01:27:20 <ocharles> i'm showing my age
01:27:24 <tdammers> does that actually remove code you don't use?
01:27:36 <edwardk> e.g. whereas today i'd have to ship: harfbuzz, harfbuzz-opentype, harfbuzz-icu, harfbuzz-freetype, now i could ship 'harfbuzz' which provides multiple public sublibraries, one for the core, and the other 3, and then a top level library that hides this distinction from users who don't care
01:27:55 <edwardk> ocharles is a doddering old man
01:28:02 <tdammers> aren't we all
01:28:31 <ocharles> 30 this year, it could be true!
01:29:04 <ocharles> edwardk: I feel like you could do that if cabal.project's allowed uploading too though
01:29:08 <merijn> tdammers: split-* drops unused code, yes
01:29:16 <edwardk> https://www.irccloud.com/pastebin/pII8XTVL/Parsnip.hs
01:29:23 <ocharles> can multiple public libraries have their own versions? I don't like libraries that get major bumps just because a parent library did
01:29:49 <edwardk> ocharles: no separate versions, but the maintainer burden for me isn't just hackage side
01:30:07 <edwardk> its also things like having 50almost duplicate cabal files because i cant share common blocks across them
01:30:25 <edwardk> with common blocks i can common up everything within a cabal file
01:30:30 <edwardk> but not across a whole project
01:30:45 <ocharles> you could use dhall-to-cabal ;)
01:30:59 <edwardk> ah yes, and take me down from 2 users to 0 =P
01:31:01 <ocharles> i wrote it for a reason!
01:31:14 <ocharles> software is really easy to maintain when no one uses it
01:31:19 <edwardk> it is
01:31:20 <ocharles> consider it a freebie
01:31:49 <merijn> ocharles: If that were true my life maintaining this academic code wouldn't be so awful ;)
01:31:54 <ocharles> :)
01:32:21 <merijn> For all the complaining people do about cabal-install and Haskell tooling, I'd kill for replacing this entire buildsystem with cabal >.>
01:33:01 <Taneb> I've seen way too many cases of academic Haskell built with a makefile for my liking
01:33:21 * edwardk hides his makefiles
01:33:40 <edwardk> i use mine just to run ghcid, etc. with the right incantations
01:33:54 <merijn> Taneb: I do that >.>
01:34:02 <merijn> Taneb: Although, to be fair, the makefile just calls cabal
01:34:12 <merijn> I just have non-haskell stuff that needs to be build too
01:34:25 <ocharles> ghcid -c'cabal new-repl'
01:34:27 <Taneb> https://github.com/UoYCS-plasma/GP2/blob/master/Haskell/Makefile is what I had in mind
01:35:38 <edwardk> ghcid -p foo --color -c "cabal v2-repl foo:lib:foo --repl-options=-fno-code --repl-options=-fno-break-on-exception --repl-options=-fno-break-on-error --repl-options=-v1 --repl-options=-ferror-spans --repl-options=-j" --restart *.cabal .     just doesn't roll off the fingers like it used to
01:36:37 <ocharles> doesn't ghcid pass -fno-code and stuff? And what's the point about -fno-break-on-exception when it doesn't even run anything?
01:36:39 <edwardk> ocharles: that one doesn't get it to skip building code, turn on error spans get as many errors as it can, use parallelism, suppress code gen
01:36:56 <edwardk> if you pass -c yourownthing
01:37:00 <edwardk> nothing gets passed
01:37:05 <ocharles> i see
01:37:09 <edwardk> it runs what you told it to
01:37:27 <ocharles> i should use ghcid more than I do
01:37:47 <merijn> edwardk: Why not put those options in a config file and load that?
01:37:50 <edwardk> and when you have multiple libs in a project, you _need_ to pass it a custom option
01:37:55 <ocharles> I just `SPC p c` in emacs and run `cabal new-build`. But every time I use ghcid I'm blown away by how well it works
01:38:05 <edwardk> merijn: i do, it is called a makefile =)
01:38:05 <Taneb> ...or even just a library and an executable
01:38:24 <ocharles> tbh this is just another data point as to the poor state of haskell tooling. I feel we've done the important and easy 90%, but we lack a cohesive glue
01:38:58 <edwardk> i can't really live without ghc these days
01:39:13 <edwardk> other than it doing stupid things when .hsc files goes wrong its amazing
01:39:40 <ocharles> ghcid you mean?
01:39:42 <merijn> ocharles: I don't think "stuff has to be done explicitly" is indicative of "poor state of tooling", the problem with too much magic "it just works" is that it becomes impossible to fix when it doesn't
01:39:42 <edwardk> (it kind of ignores problems in .hsc files after it succeeds once)
01:39:43 <edwardk> yeah
01:40:03 <ocharles> merijn: i believe that dust settles though
01:40:11 <merijn> ocharles: See, my documented in -offtopic hell experience with CMake at the moment
01:40:14 <ocharles> this is wholly off putting to anyone new
01:40:26 <ocharles> heck, it's off putting enough to me i don't even bother, and I spend 8 hours a day writing haskell
01:40:31 <edwardk> anyways, there's something to be said for the node style of letting users write custom scripts and put them in the package.json or whatever equivalent.
01:40:38 <edwardk> and just invoke them with short command-lines
01:40:40 <merijn> ocharles: Sure, but I think that mostly needs "better documented examples" because there's too much outdated stuff
01:40:55 <ocharles> i shouldn't have to go find examples on how to run something idiomatically
01:40:57 <edwardk> which is basically what i use makefiles for, mostly 90% .PHONY targets to dwim for this subdir
01:41:19 <merijn> ocharles: I think the biggest issue right now is that none of the syntax checkers have been updated to deal with v2-build yet
01:41:31 <merijn> ocharles: Because that's really my only real problem I have with tooling atm
01:42:26 <merijn> So we have 10 different tools that were all designed pre-v2 or for stack and are incredibly brittle wrt the simplest/robust compilation workflows
01:42:27 <edwardk> wonder how long until we get a ghc-api based hlint. i switched an entire set of libraries over to BlockArguments today. Now hlint just rolls over and dies.
01:42:51 <merijn> edwardk: What do you use hlint for? I find that it mostly annoys me more than it helps me
01:43:17 <edwardk> merijn: i use it like a somewhat overly enthusiastic undergrad doing a code review for me
01:43:33 <edwardk> you tell them to shut up 95% of the time, but 5% of the time they have good insights
01:43:35 <ocharles> we use hlint as a CI step
01:44:02 <ocharles> with https://gist.github.com/ocharles/4c15d2a7e4939237e8fdb811e106686a as a hlint.yml
01:44:04 <maerwald> edwardk: you mean hlint is a troll? :P
01:44:10 <edwardk> and it is generally pretty good at spotting opportunities to eta reduce, etc.
01:44:43 <merijn> edwardk: Yeah, but generally if I wrote it without the eta reduction there's a reason
01:45:22 <edwardk> merijn: sure, and after it gives me a list of them i shut that warning off
01:45:26 <phadej> ocharles: +1, default hlint setup is rarely optimal
01:45:53 <edwardk> doing it as a first pass after i spit out 10kb worth of haskell untested is a worthwhile pass
01:46:01 <edwardk> afterwards for maintenance it hits diminishing returns
01:49:41 <edwardk> ok, it is 5am here, sleepy time. i'll finish up that parser thing and replace the guts of parsnip and my shader include parser tomorrow
01:50:02 <ocharles> edwardk: catch you on friday, I believe!
01:50:08 <edwardk> oh yeah!
02:00:31 <Taneb> I'm really excited for ZuriHac :)
02:01:30 <ocharles> Taneb: got a project?
02:01:42 <Squarism> Ive started using haskell/stack for a bunch of small adhoc tasks. Is there some approach use same LTS in every such project with some global setting? To avoid a complete download of GHC fore every little adhoc program
02:02:24 <Taneb> ocharles: not yet!
02:02:38 <Taneb> ocharles: advertising any?
02:03:15 <jgt> Squarism: maybe set the resolver in ~/.stack/config.yaml ?
02:03:36 <merijn> Squarism: tbh, that sounds like "I want a workflow different from stack" :)
02:03:51 <jgt> Squarism: or maybe you want to use stack scripting, and just set the resolver in the shebang
02:04:01 <jgt> I'd have to agree with merijn though
02:04:35 <merijn> Squarism: Like, I empathise because I like working that way too, but that's the entire reason I never switched to stack :)
02:04:55 <Squarism> jgt, merijn thanks
02:05:12 <merijn> Squarism: You could have a look at v2-build
02:05:48 <ocharles> Taneb: not so much advertising, but I will be working on https://github.com/ocharles/dhallql I think
02:06:02 <Squarism> merijn, yeah I understand its not a great match. I just hoped id be able to stick with stack as ive used it on my bigger projects
02:07:06 <merijn> Squarism: tbh, if you wrote a cabal file (instead of using hpack) with stack, it should be fairly trivial to build with v2
02:08:04 <Squarism> merijn, ill check that out. This time ill stick with stack though.
02:08:57 <Taneb> ocharles: looks interesting!
02:12:39 <Taneb> ocharles: can I get you to talk to me about it in person on Friday?
02:16:45 <ocharles> Absolutely! I'll be at the preparty too
02:18:05 <Taneb> ...there's a not insignificant chance we'll be on the same plane
02:20:17 <jgt> oh I didn't realise ZuriHac is free
02:20:31 <tdammers> Squarism: fwiw, I went from cabal to stack and back to cabal; now that the v2- suite of commands is usable, I really have no reason to look back, except when I need to make one of my packages work with stack for someone
02:20:33 <__monty__> ocharles: Does it compile to graphql or js or nothing specific?
02:20:34 <jgt> I'm so used to every conference costing a million million
02:21:25 <tdammers> jgt: there's even a "diversity budget", intended to help underprivileged participants cover their expenses
02:21:54 <Squarism> tdammers, it seems many have abandoned stack. I just havent made it a priority to switch back to cabal.  
02:22:27 <tdammers> Squarism: sure, never change a working system. Only reason I switched back is because stack ceased to qualify as a "working system" for me
02:23:46 <tdammers> specifically, things that should have been small, isolated changes ended up infesting the entire project - upgrading one small dependency meant I had to upgrade GHC, which meant I had to pick a newer resolver, which meant I had to upgrade a dozen other dependencies and find replacements for yet others, and essentially I ended up rewriting large parts of the codebase for no good reason whatsoever
02:24:37 <merijn> tdammers: That'll teach you to upgrade things...
02:26:30 <tdammers> merijn: yeah. "reproducible build", because you can never ever change anything again
02:26:34 <jgt> tdammers: …and people say the Haskell crowd aren't welcoming
02:26:37 <jgt> le sigh
02:26:48 <tdammers> jgt: whoever says that has never tried
02:26:56 <jgt> agreed
02:27:28 <tdammers> or maybe they're the kind who considers it rude to present people with things that require conscious thought
02:27:30 <merijn> I think a lot of the "newer" community places (i.e. reddit, various discords/whatever the fancy kids use these days...) are...considerably less welcoming and have more trolling than here and the mailing lists
02:27:42 <tdammers> yes
02:27:52 <tdammers> also discord is an incredible mess
02:27:58 <jgt> I was rather annoyed the other day when a user came in here and made this demand "will someone explain monads please"
02:28:07 <jgt> three people immediately jump in to begin helping
02:28:10 <jgt> asker just disappears
02:28:13 <tdammers> yeah
02:28:17 <merijn> So I think the dichotomy between "Haskell community is super nice" and "Haskell community is filled with toxic trolls" is just due to the fact that there no longer is a single community
02:28:39 <tdammers> I don't really believe in this concept of "a community" anyway
02:28:44 <jgt> neither
02:29:16 <tdammers> someone makes something, other people start using it, communication about it ensues, and this gives rise to all sorts of social dynamics, but there never really is such a thing as a well-defined "community"
02:30:32 <tdammers> "the community" is a simplification of complex social dynamics
02:30:34 <jgt> my take is more along the lines of: people have something in common (Haskell), subset of that group has other thing in common (potentially controversial, politically divisive), members of the subset then regard members of the original set "not part of the community"
02:35:05 <jgt> in a Yesod app, is there a way I can run some effectful thing in case of _any_ error?
02:35:24 <jgt> error meaning error, not meaning a Left value or something
02:36:22 <Taneb> __monty__: Dhall's currently meant as a configuration language, like a typed JSON with some programability, there's interpreters for it in Haskell and I think Clojure and Eta and some other work in progress, which can emit JSON or YAML or similar, very broadly
02:37:00 <__monty__> Taneb: Yes, I'm curious about dhallql specifically though.
02:37:00 <Taneb> __monty__: my understanding of ocharles's proposal is to use it as a replacement for things like GraphQL
02:37:39 <tdammers> afaik dhall doesn't quite sit in the same niche as graphql
02:37:59 <Rembane> Sidenote: Dhall can be used as a templating language too.
02:38:00 <__monty__> tdammers: For now, ftfy ; )
02:38:19 <__monty__> Rembane: Yes, that's what I use it for currently : )
02:38:39 <Taneb> tdammers: this is in reference to https://github.com/ocharles/dhallql
02:39:36 <Rembane> __monty__: I like that usecase, except for when it messes up the indentation. 
02:41:08 <__monty__> Rembane: Have to go afk for ~40min but I'd love to hear about that. Maybe over in #dhall?
02:41:48 <Rembane> __monty__: Sure thing, I'll create an example and post it in say 6h. 
02:42:11 <__monty__> 👍
02:49:44 * hackage stylish-haskell 0.9.2.2 - Haskell code prettifier  https://hackage.haskell.org/package/stylish-haskell-0.9.2.2 (JasperVanDerJeugt)
03:04:04 <ocharles> __monty__: it's more about exploring an interaction pattern between clients and servers, using Dhall as the medium
03:04:31 <ocharles> You send a Dhall expression, you get a normal form back, basically. But that normalising that expression might require hitting DBs on the server side, or doing authentication
03:06:04 <solonarv> so the expression you send to the server has some free variables which get filled in by hitting DBs/whatever?
03:08:09 <Taneb> Or you send a function with a domain the server can deal with
03:10:09 <ocharles> You send a function where the inputs is all the queries you could run, and you use that to assemble a function call that the server interprets
03:11:01 <ocharles> So I might send you `\( queries : { find-user : Text -> Some User }) -> queries.find-user "ocharles"` and the server might send back `Some { user-id = 42 }`
03:11:27 <solonarv> ah, I see!
03:27:48 <Nevoic> Does anyone know how to mimic a `-H` with a request in `req`? I can't seem to figure it out.
03:28:08 <Nevoic> I've used `basicAuth` and just flat out `header`. They both compile and run, and just return "unauthorized" (but it's authorized when I do the curl)
03:33:45 <Nevoic> https://bpaste.net/show/9148a17c1a60
03:34:28 <Nevoic> I'm able to successfully hit the URL, I'm just not authenticating properly.
03:45:34 <Nevoic> Tried turning them into bytestrings manually incase the overloading was causing encoding issues, that didn't help.
03:46:41 <merijn> Nevoic: What was the issue?
03:47:31 <Nevoic> Generally just HTTP requests are being a lot harder than I'm used to.
03:47:35 <Nevoic> Authorization isn't working as expected.
03:47:39 <Nevoic> I may have just found something though.
03:47:41 <Nevoic> Trying it out.
03:47:51 <merijn> HTTP request don't have an encoding, though?
03:48:15 <Nevoic> *shrug* I don't normally think about it, used to thinking at a high level about http requests.
03:48:31 <merijn> Nevoic: Let's rewind to: What do you wanna do and what are you trying to do it with?
03:48:32 <Nevoic> Haven't done a lot of http stuff in C.
03:51:32 <Nevoic> I figured it out.
03:52:04 <Nevoic> Apparently `basicAuth` in `Network.HTTP.Req` doesn't setup a header with `Authorization: username password`
03:52:37 <Nevoic> And I had to convert my strings to bytestrings, they were originally being autoconverted by OverloadedStrings which apparently causes some issues.
03:52:50 <Nevoic> I don't like the literally 3 different string types I'm managing in this one file.
03:52:53 <merijn> That library looks way to typeclassy for my tastes...
03:52:55 <Nevoic> Text [Char] and ByteString.
03:53:13 <Nevoic> Apparently wreq is dying or dead.
03:53:19 <Nevoic> And I wanted to find a maintainable library.
03:53:23 <Nevoic> I'm open to suggestions though.
03:53:24 <merijn> Nevoic: ByteString isn't a string, tbh. Pretend ByteString is just Bytes
03:53:36 <Nevoic> Alright, 2 is still too many kinds of strings.
03:53:42 <Nevoic> Every other language I've used has 1.
03:53:54 <tdammers> not really
03:54:07 <Taneb> C has two
03:54:15 <merijn> C arguably has zero >.>
03:54:19 <tdammers> you can implement linked-list-of-character in other languages too, it's just less convenient
03:54:23 <Nevoic> I should qualify "every othe language I commonly use"
03:54:30 <tdammers> name one
03:54:36 <Nevoic> Ha you're right.
03:54:42 <Nevoic> But you're just playing a game of semantics.
03:54:47 <merijn> Nevoic: Anyway, I've always liked http-conduit and http-client, but I've never done anything really complex
03:54:52 <Nevoic> Half the libraries I use return `Text`, the other half `String`.
03:54:57 <Nevoic> That's quite an uncommon problem.
03:55:08 <Nevoic> Nobody in Java/Kotlin/Python is going to use my made up linked-list-of-characters.
03:55:23 <tdammers> yes, but the problem is not that there are too many "string types", but rather that, for historical reasons, the effective default is the wrong one
03:55:27 <merijn> (http-client being just a slightly more featured wrapper around http-conduit
03:55:40 <Nevoic> Again, semantics. I'm not happy with the fact that there are two string types.
03:55:48 <Nevoic> If you want to say "well that's not you being upset that there are too many string types" go ahead.
03:56:00 <tdammers> no, I'm saying that you're upset about the wrong thing
03:56:01 <Taneb> (three if you count lazy and strict Text separately)
03:56:28 <merijn> Anyway, this discussion is not very constructive
03:56:29 <tdammers> if String weren't the default, then its existence wouldn't bother you the slightest, because nobody would be using it, except for the rare cases where "linked list of Char" really is the best choice
03:56:30 <Nevoic> How do you possibly come to the conclusion that something that annoying me is *wrong* to be annoyed about?
03:56:36 <tdammers> *sigh*
03:56:56 <merijn> Nevoic: My objection to the 'req' library is that the heavy use of typeclasses often leads to very opaque/tricky to debug issues (as you discovered)
03:57:00 <Nevoic> You seem to think that because it was good to introduce Text into Haskell, that it's wrong to be upset that there are two string types.
03:57:11 <tdammers> you are annoyed, but the cause of your being annoyed is not what you think it is. that's what I meant when I said "wrong thing"
03:57:22 <Nevoic> I understand the historical context.
03:57:26 <Nevoic> I really don't care at all about it.
03:57:28 <Nevoic> I want one string type.
03:57:33 <tdammers> you have one
03:57:34 <phadej> you won't get it
03:57:37 <tdammers> and then another
03:57:44 <Nevoic> I want *only* one string type.
03:57:47 <phadej> there willbe always multiple (even just) TExt type
03:57:51 <tdammers> or rather, a type alias for linked-list-of-Char that pretends to be a string type
03:58:04 <merijn> Nevoic: Tbh, that will never work because there's just no single string type that's good for all cases
03:58:07 <phadej> it's almost the same as ask "there should be only single container type" why we have [], Seq, Vector, ...
03:58:13 <Nevoic> Alright, I suppose I have to use very, very specific words to get meaning across that is pretty well understood.
03:58:35 <tdammers> no, you misunderstand what the problem is
03:58:41 <Nevoic> I'm the one with the problem.
03:58:45 <merijn> Nevoic: I agree that replacing most/all uses of String with Text would be nice, but it's just not going to happen for historic reasons
03:58:56 <Nevoic> My problem is that there are two string types I need to convert between.
03:58:58 <Nevoic> That's *the* problem.
03:59:01 <Nevoic> You can't change that.
03:59:17 <Nevoic> merijn: I understand that.
03:59:30 <Nevoic> I'm not happy about that, but I understand why it's not practical to expect one string type.
03:59:35 <Nevoic> But it's also fine to recognize that as a downside to the language.
03:59:38 <merijn> Nevoic: Anyhoo, have a look at http-conduit/http-client and see if that works better for you?
03:59:40 <Nevoic> People get quite defensive about this.
03:59:54 <solonarv> Sure. but this conversion is trivial and does not cause any encoding-related issues that I'm aware of
04:00:04 <tdammers> it's a problem; no serious haskeller will argue otherwise
04:00:05 <Nevoic> Or rather a downside to the current implementation of the language. I know when I say "the language" tdammers is going to think I may the syntax of Haskell and not like practical usage of said syntax.
04:00:25 <phadej> Nevoic: one can argue which type should be default, but there won't be single type to rule them all ever.
04:00:43 <tdammers> it's just that there is no obvious solution to it, other than "let's throw everything away and start a new language, or at least a new base library"
04:01:26 <Nevoic> solonarv: It's `OverloadedStrings` that causes the encoding problems I was referencing.
04:01:39 <Nevoic> Because that language pragma counts "ByteString`s as strings.
04:01:45 <Nevoic> Even though some people in here don't.
04:01:57 <merijn> Nevoic: tbh, that instance is absolutely horrendous, yes
04:01:58 <solonarv> yes - that can indeed cause problems
04:01:58 <Nevoic> So you can pass "yote" into a method that requires a ByteString.
04:02:18 <dminuoso> The IsString instance for ByteString is a gross mistake, since it squelches encoding bugs.
04:02:26 <dminuoso> But that's my point of view..
04:02:28 <solonarv> although it should be fine if your string literals are just plain ascii
04:02:29 <merijn> If typeclass instance could be tried for warcrimes IsString for ByteString is definitely a candidate
04:02:39 <tdammers> hmm, so apparently I decided to use `curl` and deal with the FFI dependency the last time I needed a fully-features HTTP client library
04:02:41 <merijn> solonarv: Even then...
04:02:54 <Nevoic> I had that enabled, because I don't feel like manually packing every single string into a `Text`, so I was implicitly/automatically converting "string" into a Bytestring without knowing about it.
04:02:56 <merijn> solonarv: But I've fixed that issue for you!
04:03:01 <Nevoic> Quite a uniquely Haskell problem.
04:03:23 <Nevoic> If there's some way to limit `OverloadedStrings` and get the advantage of not having to `pack "test"` every string but also not have to worry about implicit ByteString conversions I'm all ears.
04:03:27 <tdammers> Python has a very similar problem
04:03:38 <merijn> Nevoic: Booyah! https://github.com/merijn/validated-literals/blob/test/examples/ByteString.hs
04:03:39 <phadej> not more the crime then Num Natural ;)
04:03:41 <merijn> eh
04:03:42 <merijn> whoops
04:03:45 <tdammers> you have to be really careful to not accidentally trigger conversions between strings and bytestrings
04:03:50 <merijn> s/Nevoic/solonarv
04:03:57 <solonarv> "wrong string type" (or if you prefer, "confusing byte sequences and strings") is not a haskell-only problem - in fact I was also going to mention python there
04:04:02 <Nevoic> tdammers: I'm not at all aware of it, but Python is probably my least favorite language.
04:04:09 <merijn> phadej: tbh the whole conversion between numeric types is a godawful mess
04:04:11 <Nevoic> When I want to compare Haskell to something decent, it's Swift/Kotlin/Rust.
04:04:40 <merijn> phadej: It's such a mess that when I fixed a bug related to it and had multiple review my fix before committing it to base, the fix was still buggy!
04:04:42 <phadej> merijn: I'm not talking about conversion, but having `fromInteger :: Integer -> Natural` feels silly
04:04:53 <merijn> phadej: In fact, the fix for the buggy fix was ALSO buggy
04:05:03 <merijn> It was only the 3rd patch that hasn't surfaced a bug since then...
04:05:06 <solonarv> yeah, Num is a big pile of cruft
04:05:35 <merijn> Haskell needs a better way for dealing with integer sizes at compile time when doing conversions
04:05:38 <Athas> Don't use Haskell if you need numbers.  They're too slow and the typeclasses are crufty.
04:05:41 <solonarv> it mixes at least three different concerns together
04:05:58 <merijn> Athas: To be fair, Haskell's bignum performance is pretty great!
04:06:06 <solonarv> yeah, also it would be really nice to have polymorphic literals that are actually checked at compile time
04:06:20 <Athas> merijn: Oh yeah: if you really do need numbers, write them in another language and call that from Haskell.
04:06:21 <merijn> solonarv: Something along the lines of the stuff they worked on for Habit
04:06:35 <simon> did I misread a blog post at some point when I have the impression that the package 'haskell-src-exts' is made redundant by GHC's own parser library?
04:06:47 <Nevoic> merijn: http-client looks good, I'll give that a try in the future.
04:06:59 <solonarv> simon: I'm not sure about blog posts, but that is roughly accurate
04:07:03 <simon> ah, there it was: https://mail.haskell.org/pipermail/haskell-cafe/2019-May/131166.html
04:07:10 <simon> solonarv, I suppose that isn't a blog post. :)
04:07:33 * solonarv isn't actually subscribed to haskell-cafe
04:07:48 <solonarv> but I did see that announcement somehow
04:07:58 <merijn> solonarv: Reddit or haskell weekly?
04:08:11 <solonarv> probably reddit, yeah
04:08:13 <merijn> /r/haskell is good if you just avoid most of the comments :p
04:09:12 <solonarv> anyway, simon 's impression is essentially correct: haskell-src-exts ends up reimplementing GHC's own parser
04:09:32 <solonarv> which is a whole bunch of code duplication and also quite the maintenance burden
04:10:05 <solonarv> and GHC has become a lot more usable as a library in the recent past, so there really isn't as much need for a separate thingy anymore
04:10:58 <phadej> except of unfortunate mono-culture
04:11:18 <solonarv> well tbh we already have that, haskell-src-exts doesn't change that
04:11:22 <phadej> nope
04:11:30 <phadej> but tree-sitter-haskell could changed
04:11:40 <solonarv> huh?
04:11:44 <merijn> I'm sad UHC doesn't get more love
04:11:49 * solonarv can't parse that sentence
04:12:06 <merijn> I'm also annoyed that the SCB lawyers are such obnoxious people
04:12:14 <simon> SCB?
04:12:14 <phadej> solonarv: https://github.com/tree-sitter/tree-sitter has Haskell definitons, and haskell-src-exts-like could been made on top of it
04:12:21 <merijn> solonarv: Standard Chartered Bank
04:12:32 <merijn> eh
04:12:35 <merijn> s/solonarv/simon
04:12:46 <solonarv> phadej: oh, interesting!
04:12:50 <simon> more so than lawyers on average?
04:13:06 <merijn> simon: Because they're blocking the release of their internal strict Haskell compiler
04:13:25 <solonarv> yeah, they're not doing anything lawyers don't usually do :P
04:13:35 <phadej> I'd really like to have "in production" use Haskell parser, so for all syntax-only ghc-proposal there would be 2x implementation cost
04:13:59 <phadej> because syntax-only proposals are, duh, syntax-only
04:14:10 <merijn> simon: Lennart wrote a strict Haskell compiler for internal use. I asked him about open sourcing it once. He said he's tried, but lawyers kept mumbling "liability" in hush-hush intimidated voices and then didn't okay it
04:14:11 <phadej> and sometimes judged by "it's easy to implement in _GHC_ parser"
04:14:52 <simon> merijn, ah yes, I've heard him talk about that in some YouTube video.
04:40:14 * hackage indent 0.0.5 - Fix your indentation.  https://hackage.haskell.org/package/indent-0.0.5 (vapourismo)
04:48:43 <nimba> Is there a way to make the ghci prompt shorter when using many modules (via "stack ghci")?
04:49:06 <jgt> nimba: :set prompt "λ "
04:49:25 <jgt> run that inside GHCi, or add it to your .ghci file
04:49:43 <jgt> you can of course set it to whatever you want
04:49:56 <solonarv> you can even be fancy and use color codes
04:49:56 <jgt> doesn't have to be the cliché lambda
04:50:38 <nimba> OK. It might be cool to see some indication of the imported scope though, just not all modules.
04:50:54 <solonarv> hot tip: you can have newlines in the prompt!
04:51:08 <jgt> iirc there's also a command to show which modules are imported
04:51:08 <nimba> Like, when I issue ":set -package something" then it reverts back to Prelude only, and noticing that it does would be worthwhile.
04:51:29 <solonarv> here is my .ghci : https://gist.github.com/Solonarv/a90ac7c24a5b2dd8f4154b973ed428f3
04:51:54 <solonarv> my prompt shows all the imported modules but on a separate line
04:52:08 <jgt> it's written in hieroglyphics!
04:52:22 <solonarv> yeah, that's ANSI escapes for you :P
04:52:37 <solonarv> I didn't come up with it myself, but I don't remember where I cargo-culted it from
04:52:42 <nimba> That's better, solonarv; now it would be cool to have it shorten it with "..." at the end of the first line.
04:53:20 <solonarv> you can do that too - with ':set prompt-function' you can use a proper Haskell function to generate the prompt
04:53:43 <nimba> OK, cool, thanks.
04:53:45 <solonarv> but I haven't felt the need to do that myself; I actually like having all the modules visible
04:54:50 <solonarv> I have to go now, but I'm sure other people can help you as well
04:55:08 <lavalike> solonarv: I remember trying multiple times a couple years ago to incorporate \n in a prompt to no avail
04:56:56 <lavalike> "Can't parse prompt string. Use Haskell syntax." there goes the dream
05:21:00 <nimba> How do I close a process that I created via System.Process.createProcess ?
05:21:34 <nimba> hoogling for 'ProcessHandle -> IO ()' only shows me terminateProcess which sounds like it kills it?
05:21:46 <nimba> " This function should not be used under normal circumstances ", yep
05:22:14 <nimba> hm getProcessExitCode, waitForProcess. Odd, hoogle failure?
05:24:31 <merijn> nimba: Well, how would you expect to shutdown a process without killing it?
05:24:41 <merijn> nimba: On unix you could send a signal, but that's be almost the same
05:25:35 <merijn> You have three options: 1) wait for it to finish by itself, 2) kill it, 3) use some predefined communication method (sockets, files, signals, whatever) to communicate that it should shutdown and proceed to solution 1
05:25:50 <nimba> merijn, I was just looking for getProcessExitCode; I now realize that Hoogle didn't bring it up since I was asking for IO () wheras getProcessExitCode returns an exit code.
05:25:52 <Ferdirand> if you want to kill a process, just sit on the bank of the river and wait(), and soon you will see its return code
05:26:10 <Ferdirand> for some values of soon
05:27:01 <nimba> I was looking on Hoogle since searching System.Process docs for "close" didn't yield anything.
05:27:17 <merijn> nimba: Because you don't "close" process
05:27:22 <merijn> You kill them or you wait for them
05:27:51 <nimba> Close the filehandle to a process, shrug.
05:28:08 <merijn> nimba: But those are just file handles, so you close them with hClose
05:28:59 <nimba> I mean, ProcessHandle is really just a filehandle, too, in Unix anyway.
05:29:09 <merijn> No it's not
05:29:12 <nimba> I'm not a Windows programmer.
05:30:20 <nimba> Maybe its pid as well, fine. Anyway, wondering why Hoogle doesn't find waitForProcess ProcessHandle -> IO a
05:30:37 <nimba> * doesn't find waitForProcess for the search 'ProcessHandle -> IO a'
05:31:38 <bolverkr> does anyone know how to get the gdb stack trace when running a crashing 'cabal new-test'? I am getting crashes when I try to run the sv library tests in OSX Mojave
05:31:49 <bolverkr> I see this error when running it with -v3
05:31:50 <bolverkr> CallStack (from HasCallStack):
05:31:50 <bolverkr>   die', called at ./Distribution/Client/ProjectOrchestration.hs:1002:55 in main:Distribution.Client.ProjectOrchestration
05:32:30 <merijn> bolverkr: Can you explain what you mean by "gdb stack trace"?
05:32:38 <merijn> That just looks like a crash in cabal-install
05:32:46 <merijn> (Incidentally, which version are you using?)
05:32:47 <Ferdirand> well, if you search (a -> b) in hoogle, it doesn't come up with every function in the library either
05:33:14 * hackage haskoin-store 0.16.3 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.16.3 (xenog)
05:34:25 <avneeshchaddha> Hi can someone help me with this ==> https://www.reddit.com/r/haskell/comments/bzpyhc/incorrect_type_evaluation_causing_code_not_to/ . It's a little verbose, but basically I cannot seem to understand the type error I am getting(sorry if this is too dumb a question)
05:34:36 <hnfmr> how can i concat two strings in Haskell? e.g. "aaa-" ++ "bbb" doesn't work?
05:34:53 <merijn> > "aaa-" ++ "bbb"
05:34:53 <hnfmr> at least in GHCI
05:34:55 <lambdabot>  "aaa-bbb"
05:35:01 <merijn> Works just fine? :)
05:35:10 <hnfmr> i get weird errors like: <interactive>:8:1: error:     • No instance for (IsString (List ())) arising from a use of ‘it’     • In the first argument of ‘System.IO.print’, namely ‘it’       In a stmt of an interactive GHCi command: System.IO.print it
05:35:16 <hnfmr> sorry for the poor formatting
05:35:32 <merijn> hnfmr: You have OverloadedStrings enabled + some weird additional defaulting, by the looks of it
05:36:00 <bolverkr> merjin I am using cabal 2.4.1.0 and ghc 8.6.1 but I have also tried with the latest with no luck
05:37:01 <hnfmr> merijn: oh my bad...i have enabled that exension...thanks
05:37:09 <bolverkr> merijn I dont know i have been having this issue for a few days already and my only hypothesis now was that gcc is having some segmentation fault but i cant see the stack trace...
05:38:19 <bolverkr> i am not very experience with these kind of errors so i am just trying everything at this point
05:38:50 <Shoubit> hnfmr, you can specify the type of the data like `("aaa-" ++ "bbb" :: String)` or with TypeApplications `print @String ("aaa-" ++ "bbb")` if you'd still like to use OverloadedStrings
05:39:30 <bolverkr> there is kind of a similar issue here https://github.com/haskell/cabal/issues/5828 but there was no solution proposed there
05:40:25 <merijn> bolverkr: Looks like there is an issue with GHC and/or the linker
05:42:30 <bolverkr> what do you mean "the linker"? merijn
05:43:03 <bolverkr> also, i tried running it in a different computer with the same OS and ghc, cabal and it was succesful :(
05:43:04 <merijn> bolverkr: Eh, I mean the linker, I'm not sure what else I would call it?
05:43:31 <merijn> bolverkr: Wait, which OS are you on?
05:44:04 <bolverkr> merijn macOS Mojave 10.14.4
05:44:11 <MasseR> `System.IO.print` could this be as simple as `print "aaa-" ++ "bbb"` and replacing it with `print $ "aaa-" ++ "bbb"`
05:44:22 <merijn> And the other OS had the exact macOS version and GHC?
05:44:36 <bolverkr> yup
05:44:43 <merijn> hmmm, weird
05:44:50 <merijn> XCode is installed and up to date?
05:47:01 <bolverkr> merijn yes... there is a difference though. That other machine didn't have an existing ghc 8.6.1 installed and I just installed 8.6.5 on it... Is it possible that my ghc 8.6.1 is messed up and it is interfering with the new version in my computer...? sorry for the strange questions
05:47:33 <merijn> bolverkr: It shouldn't, ghc sandboxes it's database per GHC version
05:48:22 <bolverkr> i see...
06:04:14 * hackage simple-vec3 0.6 - Three-dimensional vectors of doubles with basic operations  https://hackage.haskell.org/package/simple-vec3-0.6 (DmitryDzhus)
06:15:40 <aveltras> is it possible to translate a .ghci file like that in ghci command line arguments only ?
06:15:44 <aveltras> https://www.irccloud.com/pastebin/0640zDCu/
06:25:06 <hnfmr> Shoubit: thanks, that's good to know!
06:25:11 <merijn> :O
06:25:20 <merijn> GHC is getting -Wunused-packages, that's amazing!
06:25:41 <tdammers> awesome
06:25:53 <merijn> https://twitter.com/mpickering_/status/1138749782720204801
06:25:55 <tdammers> combine that with errors in JSON format, and you can actually build meaningful tooling on that
06:41:45 * hackage polysemy 0.4.0.0 - Higher-order, low-boilerplate, zero-cost free monads.  https://hackage.haskell.org/package/polysemy-0.4.0.0 (isovector)
06:47:01 <isovector1> anyone know how long it takes for the stackage mirrors to update?
06:49:28 <phadej> isovector1: I'd say twice an hour based on "At least 30 minutes have passed since uploading to Hackage"
06:52:05 <isovector1> phadej: thanks! it's a little annoying trying to bump multiple packages at once on stack :)
06:52:27 <phadej> my solution: don't bother with Stackage, if someone cares, they'll do it
06:53:03 <isovector1> reasonable. so far being in the stack pipeline has pointed out a few bugs to me though!
06:53:04 <tdammers> ^^^ ++
06:53:37 <phadej> isovector1: you should improve your own QA practices ;)
06:53:53 <phadej> at least after the fact
06:55:14 * hackage polysemy-zoo 0.1.2.1 - Experimental, user-contributed effects and interpreters for polysemy  https://hackage.haskell.org/package/polysemy-zoo-0.1.2.1 (isovector)
07:02:14 * hackage mail-pool 2.0.1 - Preconfigured email connection pool on top of smtp.  https://hackage.haskell.org/package/mail-pool-2.0.1 (Jappie)
07:07:32 <isovector1> what's the serialization package du jour?
07:07:57 <merijn> isovector1: Depends on what you're serialising for and what your requirements are
07:08:31 <merijn> If the goal is "least effort with reasonable efficiency" then probably binary?
07:08:58 <isovector1> haskell objects; lots of strings. shooting them over the network, so ideally low latency / high efficiency
07:09:38 <merijn> isovector1: Will you be tied to this format for long time or is it just "I wanna get something work quick but can change over later"?
07:09:40 <isovector1> human readability not necessary
07:10:13 <isovector1> it's an in-progress RPC impl -- so ideally not changing it
07:10:52 <merijn> isovector1: Then you probably wanna sit down and define a protocol/wire format first, then implement said format afterwards
07:11:56 <merijn> binary via generic is nice for quick and dirty, but if you wanna be easily interoperable you probably wanna define an explicit format and write it yourself (I'd probably still use binary for that)
07:12:07 <isovector1> oh god. okay let's go back to "least effort / reasonable efficiency"
07:12:33 <merijn> isovector1: Binary + deriving (Generic) :p
07:12:35 <phadej> then binary/aeson/serialise/cereal/store all have Generic derivation
07:12:59 <isovector1> perfect, thanks :)
07:14:20 <merijn> isovector1: The generic derivation of binary is pretty reasonable, but it uses it's own internal format which might be annoying if you need to interoperate with other languages/implementations
07:14:37 <merijn> isovector1: So if that is a goal you almost always have to hand-write the serialisation
07:15:00 <isovector1> interop with other languages isn't a goal
07:15:40 <isovector1> it's an RPC implementation for an effects system; lets you invisibility turn effects into something you can handle on a different server
07:16:01 <isovector1> the other side also needs to be running a polysemy server, so no worries
07:16:30 <merijn> isovector1: You may also wanna look at safecopy
07:16:42 <merijn> That provides versioning for serialisations
07:16:49 <merijn> So you can migrate in the future
07:17:43 <isovector1> yeesh. nah. i'm just going to commit to "this is the way it's done"
07:17:53 <isovector1> if other people care they can fix it in the future :)
07:18:02 <merijn> isovector1: You're gonna regret that in the future ;)
07:18:18 <merijn> I swear, every single time I define a file/wire format without a version tag I always end up hating myself...
07:18:36 <isovector1> that is a reasonable point
07:18:58 <isovector1> i'm not sure how versioning should be done. by definition all of the things i want to send over the wire are user-code
07:19:02 <merijn> isovector1: Even if it's just "first word is a version number" so you can dispatch to different parsers on that will save you heartache
07:19:04 <isovector1> i can version th eprotocol
07:20:07 <isovector1> requiring all of my users to safecopy their data structures seems like an aggressive api choice
07:20:13 <merijn> isovector1: I recommend having a look at the ZeroMQ protocol RFCs, they're a nice example of relatively simple wire-format (and you can also see their "whoopsie" with versioning where they had to sorta work around insufficient detailed versioning)
07:20:22 <int-e> merijn: The first bit of every message is the "do I hate myself yet" bit.
07:20:29 <isovector1> rofl
07:20:40 <isovector1> out of batteries so gotta run. thanks for the tips!
07:25:46 * hackage tracing 0.0.4.0 - Distributed tracing  https://hackage.haskell.org/package/tracing-0.0.4.0 (mtth)
07:32:44 * hackage bglib 1.0.0.0 - Implementation of the BGAPI serial protocol  https://hackage.haskell.org/package/bglib-1.0.0.0 (tamasFabian)
07:37:44 * hackage conduit-extra 1.3.2 - Batteries included conduit: adapters for common libraries.  https://hackage.haskell.org/package/conduit-extra-1.3.2 (MichaelSnoyman)
07:53:14 * hackage mysql-simple-typed 0.1.2.0 - Typed extension to mysql simple  https://hackage.haskell.org/package/mysql-simple-typed-0.1.2.0 (tolysz)
07:55:44 * hackage load-env 0.2.1.0 - Load environment variables from a file.  https://hackage.haskell.org/package/load-env-0.2.1.0 (PatrickBrisbin)
07:58:14 * hackage lens-regex-pcre 0.3.0.0 -   https://hackage.haskell.org/package/lens-regex-pcre-0.3.0.0 (ChrisPenner)
08:40:18 <jinna> On top is the implementation of `transformers-0.5.6.2`, mine is below. Does my style lead to less efficient code? Is it less readable?   https://pastecode.xyz/view/197ed09c
08:40:34 <jinna> Is my version correct after all?
08:41:56 <merijn> jinna: Your version is different
08:42:09 <merijn> jinna: It always executes both effects, even if the first returns Nothing
08:42:29 <merijn> jinna: transformers only executes effects if all preceding ones return Just
08:42:46 <jinna> Good, makes sense. Thx!
09:02:54 <Axman6> isovector1: if it were me, I'd use serialise and generically derive the Serialise instances: https://hackage.haskell.org/package/serialise-0.2.1.0/docs/Codec-Serialise.html#t:Serialise
09:27:44 * hackage vulkan-api 1.3.0.0 - Low-level low-overhead vulkan api bindings  https://hackage.haskell.org/package/vulkan-api-1.3.0.0 (achirkin)
09:30:46 * hackage easytensor 2.0.1.0 - Pure, type-indexed haskell vector, matrix, and tensor library.  https://hackage.haskell.org/package/easytensor-2.0.1.0 (achirkin)
09:31:45 * hackage easytensor-vulkan 2.0.1.0 - Use easytensor with vulkan-api.  https://hackage.haskell.org/package/easytensor-vulkan-2.0.1.0 (achirkin)
09:51:56 <ahri> I'm having trouble with understanding why I can't compile the following code: `data Foo a b = Foo b; newtype Bar a b = Bar (Foo a b) deriving (Functor)` - I understand that there are two type params, but having tried to "partially apply" one; `deriving (Functor a)` GHC is still unhappy, I even tried placating it with `GeneralizedNewtypeDeriving` wi
09:51:56 <ahri> th no joy - can someone explain where I'm going wrong?
09:56:11 <dmwit> ahri: Have you given `Foo` a `Functor` instance?
09:58:33 <dmwit> (If not, you will probably have to, for either the stock or newtype-deriving strategies to work.)
09:59:14 * hackage sbp 2.6.3 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-2.6.3 (markfine)
10:11:34 <dmwit> ahri: (And of course you can always just write the instance by hand.)
10:12:59 <jle`> jinna: your version is actually the instance for Applicative f => Compose f Maybe
10:13:11 <jle`> jinna: er, Applicative f => Applicative (Compose f Maybe)
10:13:41 <jle`> jinna: so your instance is valid and legal for an Applicative instance. the problem is that because MaybeT f is a Monad, you also have to obey (<*>) = ap
10:14:03 <jle`> jinna: and `ap` has short-circuiting effects behavior, so this must be reflected in <*> for MaybeT f as well
10:14:26 <jle`> jinna: so on your own, the instance is legal. but if your type has a Monad instance, it breaks the (<*>) = ap assumption.
10:17:04 <ahri> dmwit: I hadn't, but actually my problem is not as simple as I described, I guess I can just write the instance by hand
10:17:45 * hackage mail-pool 2.1.0 - Preconfigured email connection pool on top of smtp.  https://hackage.haskell.org/package/mail-pool-2.1.0 (Jappie)
10:19:20 <lyxia> it might be a good idea to show the actual code and error
10:33:09 <ahri> https://gist.github.com/ahri/c8284c3d522110d901464ae1db40fdbc is the code and the error, it's very boilerplatey as well so if you have suggestions around that, that'd be good too :)
10:36:01 <ahri> essentially I have an event stream that I want to version so that I don't have to rewrite it - so I tried to break things out a bit in order to be able to upgrade and version different events
10:36:14 <hyperisco> ahri, for Event to be a Functor, PEvent has to be a Functor
10:36:25 <ahri> I've added a comment with the previous (working) data structure that did derive Functor
10:37:17 <hyperisco> ahri, and okay, they both are, but PEvent is only a Functor on its last parameter, which is childrenReordered
10:37:34 <hyperisco> similarly, Event can only be a Functor on its last parameter which is ct
10:37:49 <ahri> hmm. I do want them to be functors on ct
10:37:54 <hyperisco> And so the only place you can use  ct  with PEvent is on the last argument
10:38:00 <ahri> but not childrenReordered :)
10:39:17 <ahri> did you see my comment with my working structure? by introducing a polymorphic PEvent in-between with slots for everything I've ended up not being able to connect the dots through to the types it has slots for
10:39:22 <hyperisco> Why not  data PEvent str ct = ChildAdded (ChildAddedData_v1 str ct)  and so on?
10:41:27 <ahri> because I have another structure filling those PEvent slots with VChildAdded, VTitleEdited, etc. which are versioned sum-types containing all known versions of each event - this allows me to re-use PEvent as `CanonicalEvent  str ct = PEvent (VChildAddedData str ct) ...`
10:42:06 <ahri> so that ChildAddedData_v1 fits in VChildAdded_v1
10:42:53 <hyperisco> Well, I can't design your program for you, but I can tell you that an auto-derived Functor is only so smart. It will use other Functor instances as needed, but no Functor instance is going to map PEvent's as you need, as defined.
10:43:09 <hyperisco> You can manually define a Functor instance though.
10:43:20 <ahri> it's become unweildy because I wanted to avoid forgetting to fill a slot, which is perhaps not that important. My main aims are 1) to be able to deserialize all previous events and 2) to only have to deal with the latest event types in my program
10:44:39 <ahri> that's fair enough really, removing PEvent simplifies things a lot tbh; I was really just trying to do what I imagined was the "right thing" by re-using the structure, but it may not make sense anyway :)
10:45:14 <hyperisco> It is unlikely to miss a spot when defining a Functor manually. You'd have to ignore totality checking or use infinite recursion. Otherwise it is a type error.
10:50:14 <ahri> possibly a silly question, but is there a way to make `PEvent (ev1 str ct) (ev2 str ct) str ct = PEvent ...` - i.e. to require the params to be kind '* -> * -> *' and to get my derived functor instance over PEvent this way?
10:55:10 <lyxia> > data PEvent ev1 ev2 str ct = P1 (ev1 str ct) | P2 (ev2 str ct) deriving Functor
10:55:12 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
10:55:15 <lyxia> @let data PEvent ev1 ev2 str ct = P1 (ev1 str ct) | P2 (ev2 str ct) deriving Functor
10:55:17 <lambdabot>  Defined.
10:55:33 <ahri> oh, on the RHS, hmm
10:58:12 <ahri> that's really neat! thank you for teaching me that, I didn't guess the syntax myself for some reason :\
10:59:47 <lyxia> It's probably not that obvious before seeing it a few times
11:05:17 <jle`> yeah, we just stumbled onto a 'higher-kinded type'
11:05:33 <jle`> it's something that we're still having problems convincing people in other languages is a good idea, heh
11:11:02 <monochrom> Hell, after 100 years of lambda calculus, we still haven't convinced mathematicians that merely higher-order functions are a good idea.
11:11:29 <monochrom> Or even merely types.
11:11:57 <halogenandtoast> Is there a good resource for best practices for lenses and records?
11:12:14 * hackage conduit-vfs 0.1.0.3 - Virtual file system for Conduit; disk, pure, and in-memory impls.  https://hackage.haskell.org/package/conduit-vfs-0.1.0.3 (RobertFischer)
11:12:24 <Cale> monochrom: Mathematicians? Who?
11:13:00 <monochrom> Any mathematicians who aren't doing functional analysis?
11:13:36 <Cale> I'm not sure I agree
11:13:49 <monochrom> OK how about types.
11:14:18 <Cale> Informally, everyone cares about things typechecking.
11:14:27 <bandali> monochrom, check out the Lean prover
11:14:31 <bandali> and its users and contributors
11:15:20 <Cale> There's not a huge amount of traction for type theories, but then if you really look at it, while a lot of people will pay lip service to ZFC, there's not really a whole lot of traction for formalism at that level at all.
11:15:37 <Cale> Very little has *actually* been formalised in ZFC+FOL properly.
11:15:50 <ahri> lyxia, dmwit: thanks again for your help - my refactor seems to be in order now!
11:15:58 <monochrom> bandali, is that representative of, let's say, at least 80% of mathematicians?  Or are you just making a "there exists at least 1" statement?
11:16:35 <Cale> But I was more responding to the higher-order functions point. There are plenty of higher order functions going on in every branch of mathematics, as far as I could see.
11:16:44 <bandali> monochrom, neither to be honest. closer to the second one, sure, but it’s been gaining adoption
11:17:35 <bandali> I’ve heard many mathematicians being interested in tools like Coq or Lean
11:17:44 <monochrom> Like why don't you also consistently give a similar response to jle`'s statement? Because you could cite Idris as an existential example of "other languages".
11:17:48 <bandali> Or be persuaded to consider it rather than be dismissive of it right out the gate
11:18:37 <monochrom> Like why is everyone picking on me and me alone?!
11:19:18 <Cale> You don't see λ used notationally so much, but you do see a whole lot of the entirely equivalent ↦ notation.
11:19:20 <bandali> first, let me assure you: i’m not picking on you. if that’s what it looks like, it’s not at all my intention
11:19:33 <bandali> i thought i’d share my 2¢
11:19:43 <Cale> I didn't mean to pick on you though, I just saw your sentence (and wouldn't have seen jle's as it'd already scrolled past)
11:20:03 <bandali> regarding jle`’s statement, i didn’t see it. i’ll read it in a sec
11:20:10 <monochrom> Cale, I was saying you don't see "f :: (R -> Z) -> N" so much either.
11:20:28 <hyperisco> Programmers slap some lines together into a program, and it is what it is, and some mathematicians throw some symbols together, and it is what it is. Not all that different much of the time is it?
11:20:36 <Cale> Working with functions R -> Z is a really good way to run into the limitations of ZFC
11:21:11 <Cale> or you just mean the notation
11:21:23 <Cale> Yeah, you'd see that written Z^R -> N
11:21:25 <bandali> monochrom, what specifically in jle`’s statement would you expect/like me to address?
11:21:31 <monochrom> I don't mean the notation. I said "higher-order function". Do you know what that means?
11:21:39 <Cale> yes
11:21:44 <monochrom> "other languages".
11:22:31 <bandali> fwiw, i’m not a huge fan of how haskell does higher-kinded types
11:22:55 <bandali> so indeed, i could raise Lean/Coq with proper dependent types as a response to jle`, if that’s what you mean
11:22:59 <hyperisco> monochrom, I think they go the type classing sort of approach… function families… mathematicians like subscripts
11:23:02 <Cale> But higher order functions do practically arise -- often it's by way of definitions which construct elements of a set of interest via functions.
11:24:05 <Cale> For example, every time you're using formal power series, you're using a notational convenience for discussing functions N -> C with particular algebraic operations defined on them.
11:24:50 <Cale> (i.e. the function which gives the coefficient of x^n for each n)
11:26:54 <Cale> and then there are all the people who study things which happen to be Abelian categories or similar, who are constantly manipulating maps endowed with additional additional algebraic structure that is then higher-order
11:28:12 <Cale> Even the most basic stuff we introduce to first year students has higher order functions in it -- In linear algebra, the linear maps between a pair of vector spaces form a vector space, and then you're immediately discussing operations acting on maps.
11:28:43 <Cale> In Calculus, you have the derivative, and various notions of integration which consume maps.
11:30:10 <Cale> Representation theory is full of higher order stuff, a basic example would be the left-regular representation of a group.
11:31:16 <Cale> Maybe graph theory kind of manages to avoid higher order functions a lot of the time...
11:31:36 <Cale> But even there, not really entirely
11:31:47 <Cale> Often you're building graphs whose vertices are functions and stuff
11:33:48 <Cale> (and nevermind that it pretty quickly ties in with linear algebra and gets higher-order in all the same ways that linear algebra is)
11:37:34 <Cale> Differential equations.
11:55:01 <hyperisco> ski must be on vacation
12:04:35 <zachk> did he take a ski trip? 
12:04:57 <fendor> > read "C:\r\n" :: String
12:04:59 <lambdabot>  "*Exception: Prelude.read: no parse
12:05:10 <fendor> whhyy? 0.o
12:09:29 <zachk> > read @String "C:\r\n" 
12:09:31 <lambdabot>  error:
12:09:31 <lambdabot>      Pattern syntax in expression context: read@String
12:09:31 <lambdabot>      Did you mean to enable TypeApplications?
12:09:44 <zachk> % read @String "C:\r\n" 
12:09:44 <yahb> zachk: "*** Exception: Prelude.read: no parse
12:09:49 <zachk> :(
12:10:24 <fendor> somewhat weird. 
12:10:31 <fendor> > read "C:\r\n" :: Text
12:10:34 <lambdabot>  error:
12:10:34 <lambdabot>      Not in scope: type constructor or class ‘Text’
12:10:39 <fendor> > import Data.Text
12:10:41 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
12:10:47 <fendor> @import Data.Text
12:10:47 <lambdabot> Unknown command, try @list
12:10:55 <zachk> try % for yahb, fendor
12:11:06 <fendor> % import Data.Text
12:11:06 <yahb> fendor: 
12:11:16 <fendor> % read "C:\r\n" :: Text
12:11:17 <yahb> fendor: "*** Exception: Prelude.read: no parse
12:11:28 <fendor> zachk, thanks! 
12:12:18 <zachk> yahb is yet another haskell bot, iirc, fendor 
12:12:42 <fendor> a more advanced, i think
12:15:12 <nefple[m]> I'm curious how it handles sandoxing
12:15:40 <zachk> yahb is a true ghci , or so I have heard, where lambdabot is not a true ghci 
12:18:41 <fendor> what was the flag called to set another builddir for cabal? instead of newstyle-dist?
12:19:20 <fendor> maybe builddir is the winner?
12:20:31 <fendor> builddir seems to be the winner
12:31:06 <fendor> :t (</>)
12:31:08 <lambdabot> error:
12:31:08 <lambdabot>     • Variable not in scope: </>
12:31:08 <lambdabot>     • Perhaps you meant one of these:
12:34:44 * hackage morley-prelude 0.2.0 - A custom prelude used in Morley  https://hackage.haskell.org/package/morley-prelude-0.2.0 (gromak)
12:36:44 * hackage morley 0.3.0 - Developer tools for the Michelson Language  https://hackage.haskell.org/package/morley-0.3.0 (gromak)
12:40:56 <monochrom> </> is probably from filepath's System.FilePath and does \x y -> x ++ "/" ++ y for you (or "\\" on Windows)
12:42:12 <cocreature> monochrom: it’s not quite as simple. it behaves differently when y is absolute.
12:42:27 <fendor> monochrom, yeah, i am encountering a weird output bug, a and I wanted to test, what the output should be for something like "C:" </> "Program" should be on windows
12:42:28 <monochrom> Yeah.
12:43:15 <fendor> for some reason, the paths I get do not contain escaped backslashes but single ones. When trying to decode them into text, this naturally fails, since \k or something like that is not an valid utf-8 character
12:43:57 <eviltwin_b[m]> you are conflating internal and display format
12:44:25 <eviltwin_b[m]> > text "\\"
12:44:27 <lambdabot>  \
12:44:56 <monochrom> Escape stories are usually very complicated.
12:45:01 <fendor> i see...
12:45:10 <fendor> yeah, that makes sense
12:49:03 <fendor> how do I normally fix that? I have a FilePath and I want to print that filepath and want to parse it again, e.g. capture the output and parse it into a json value
12:50:25 <fendor> it should work fine if i write it to a file and then read it again, right?
12:51:17 <eviltwin_b[m]> depends on how you do it
12:51:27 <eviltwin_b[m]> putStrLn outputs it "raw" / in internal format
12:51:52 <eviltwin_b[m]> show uses Haskell-style escapes and read :: String -> String expects them
12:52:02 <eviltwin_b[m]> JSON will use JSON-style escapes both out and in
12:52:35 <eviltwin_b[m]> use the same / compatible mechanism on both sides and it should work. show but raw input, or show but json input, or etc., will cause problems
12:53:01 <fendor> alright, it uses putStrLn, the JSON lib is custom grown. I think the output is read a s a bytestring
12:53:13 <fendor> or string? probably converted to a string...
12:53:52 <eviltwin_b[m]> json input generally expects the JSON as a bytestring / raw network output
12:54:07 <eviltwin_b[m]> this isi the JSON itself, not what ti encodes!
12:55:49 <fendor> yeah, the output is converted to a String, so I only get a String. Then I decode it into a Text and decode it with aeson
12:56:18 <eviltwin_b[m]> this sounds confused, or at least incomplete
12:56:29 <eviltwin_b[m]> the output is, for example, ??
12:56:44 <eviltwin_b[m]> (show an input and a resulting output)
12:59:11 <fendor> wait a ec
13:00:01 <fendor> https://pastebin.com/Kt2cdfeL
13:00:03 <monochrom> aeson would do round-trip properly.
13:00:14 <fendor> monochrom, I am not allowed to add aeson to Cabal :/
13:00:46 <fendor> that is an example output that I would like to parse.
13:01:10 <monochrom> OK, how should I reconcile "I use aeson" and "I don't add aeson to Cabal"?
13:01:46 <fendor> monochrom, to test the output in the cabal-testsuite, I can use aeson, when producing the output, I may not 
13:02:23 <eviltwin_b[m]> so you are supposed to produce JSON without using a reasonable JSON library?
13:02:43 <eviltwin_b[m]> or do you think these things just somehow figure themselves out?
13:03:28 <eviltwin_b[m]> (even strngs are not trivial to handle: JSON's string escapes are not the same as Haskell's)
13:03:31 <monochrom> I wonder what \ means in JSON.
13:04:04 <monochrom> But yeah 100% sure neither show nor putStr would produce correct JSON.
13:04:33 <hyperisco> monochrom, \ is only a valid character in strings, and then only valid if followed by one out of a set of applicable characters.
13:04:33 <fendor> eviltwin_b[m], I am not exactly sure, if it doesnt work, I have to change the code. Lukcily, cabal has tets, because on linux, it worked fine.
13:05:14 * hackage conduit-vfs-zip 0.1.0.0 - Zip archive interface for the Conduit Virtual File System.  https://hackage.haskell.org/package/conduit-vfs-zip-0.1.0.0 (RobertFischer)
13:05:17 <eviltwin_b[m]> as long as you stick to simple paths, sure
13:05:21 <hyperisco> oh my bad, it has 4 digit unicode escape sequences too
13:05:36 <monochrom> I would really use a real JSON library. aeson is already the minimum requirement to me. (i.e. I am open to an even better library. But not to a more ghetto home-brew one.)
13:05:43 <eviltwin_b[m]> utf8, embedded newlines or control characters (perfectly legal in POSIX), and you lose
13:06:08 <monochrom> And if the decision is "not up to me", I would raise hell to whoever it's up to.
13:06:12 <fendor> what is the opinion of microaeson? It was discussed that may be possible to add microaeson
13:07:44 * hackage conduit-vfs-zip 0.1.0.1 - Zip archive interface for the Conduit Virtual File System.  https://hackage.haskell.org/package/conduit-vfs-zip-0.1.0.1 (RobertFischer)
13:08:17 <hyperisco> fendor, I am guessing you just have to replace backslashes with two backslashes
13:08:47 <fendor> not sure if that suffices...
13:09:02 <hyperisco> because?
13:09:48 <fendor> because escaping is complicated and I am not sure what a simple replacement might do to special paths.
13:09:53 <eviltwin_b[m]> you seem to be assuming we know your constraints, whre they come from, and why
13:10:10 <hyperisco> if you're trying to make a proper JSON codec that's one thing, but if you're just duct taping something together and can't use an off-the-shelf JSON codec then just the replacement is fine
13:10:27 <hyperisco> escaping is not complicated and the simple replacement will always work
13:10:31 <hyperisco> thumbs up hyperisco approved
13:10:49 <hyperisco> just don't make the fatal mistake of not decoding two backslashes as one backslash
13:10:50 <eviltwin_b[m]> ^
13:11:05 <eviltwin_b[m]> it's not clever but it should always be valid and safe
13:11:18 <fendor> eviltwin_b[m], I am sorry, I am often susceptible to the X and Y problem.
13:11:26 <hyperisco> why is it safe? because \ in JSON is \\, simple as that
13:12:11 <monochrom> I like hyperisco-approved. :)
13:12:16 <dmwit> Seems like replacing \ with \\ is a good move. But it surely isn't enough. You are going to run very soon into a new problem with something else that is supposed to be escaped but isn't.
13:12:39 <eviltwin_b[m]> right, the corner cases all come in during decoding when the generated string contains a \ which is not the start of a \ sequence
13:12:41 <eviltwin_b[m]> if you cannt generate that, it can't become a probem
13:12:49 <hyperisco> feel free to escape all the things https://json.org/
13:12:50 <fendor> alright... I mean, I can at least try it. When printing the output or after capturing the output of the command?
13:13:02 <hyperisco> but at some point may as well use a proper JSON codec :P
13:13:04 <dmwit> (And since we are dealing with filepaths here, you are then going to run into the whole collection of awful edge cases that is dealing with filepaths in a cross-platform way, I'm sure.)
13:13:13 <eviltwin_b[m]> hm, I have no idea how matrix mangled that. am not liking this much
13:13:46 <hyperisco> and my bad, there is no such thing as a backslash in JSON, it is a solidus
13:13:48 <eviltwin_b[m]> dmwit: but most of those JSON won't help with
13:13:50 <fendor> maybe Cabal has some functions for that already. Thanks for the help!
13:13:51 <hyperisco> REVERSE solidus
13:13:54 <dmwit> eviltwin_b[m]: Agreed.
13:14:08 <eviltwin_b[m]> if you feed it a filename "con" from linux, you lose on windows regardless
13:14:16 <dmwit> eviltwin_b[m]: As for "if you cannot generate [\ and then something that isn't \], it can't become a problem", this is my skeptical face.
13:14:18 <monochrom> Fortunately there are really only two platforms to cross now, for filepaths.
13:14:34 <dmwit> eviltwin_b[m]: e.g. what if your path has a quotation mark in it? Then just replacing \ with \\ everywhere ain't enough any more.
13:14:37 <dmwit> I'm sure there are more examples.
13:14:41 <dmwit> That's just off the top of my head.
13:15:14 <eviltwin_b[m]> true but you're just begging for trouble at that point nyway
13:16:29 <hyperisco> If I had $1000 for every Windows file path problem I could have afforded a developer to fix it for me.
13:18:56 <hyperisco> (This is a xplatform problem, not a Windows problem)
13:20:31 <monochrom> xyplatform problem >:)
13:20:51 <monochrom> "I'm on platform X, I need to interoperate with platform Y..."
13:21:04 <eviltwin_b[m]> splatform problem
13:21:57 <hyperisco> And since we're talking JSON, the JSON headache is numbers, and not because of the format but because of the codecs.
13:23:10 <hyperisco> You may read the advice to use JSON strings instead of numbers. This is a the sad reality of codecs.
13:23:29 <hpc> it's true, json encodes numbers with mp4
13:23:57 <hyperisco> They make you listen to the end to get the most significant digit! It is awful.
13:25:21 <MarcelineVQ> "<hyperisco> REVERSE solidus" :(
13:26:35 <hyperisco> Some people are confused as to which slash is forward and which is backward. Hopefully they're more understanding of reversed and unreversed solidi.
13:27:12 <hpc> https://sprignaturemoves.com/wp-content/uploads/2011/06/slash-backslash.png - how i remember
13:28:42 <hyperisco> Hopefully he donated himself to science so that he can be well preserved in Paris as a reference.
13:31:28 <crestfallen> he wears his guitar awfully low
13:32:31 <hpc> maybe it's a bass, those are lower than regular guitars
13:33:57 <crestfallen> he must generally prefer to slouch; also at the dinner table
13:35:58 <hpc> getting back on topic, i would like to see a better library than aeson but not for reasons related to json itself
13:36:12 <hpc> mostly having it be based on data instead of class instances
13:36:25 <MarcelineVQ> like https://hackage.haskell.org/package/hw-json ?
13:36:44 <MarcelineVQ> + https://hackage.haskell.org/package/waargonaut
13:38:23 <Phyx-> 21:13:46 < eviltwin_b[m]> if you feed it a filename "con" from linux, you lose on windows regardless <-- that's a broad statement
13:39:04 <Phyx-> \\?\C:\con is a perfectly valid Windows filename
13:39:16 <eviltwin_b[m]> it's not doing the same thing as on linux, that's for certain
13:39:36 <eviltwin_b[m]> no, "con", not that
13:42:18 <hpc> MarcelineVQ: ah, quite likely
13:42:35 <hpc> i think i remember being suggested waargonaut before, the api seems familiar
13:43:02 <eviltwin_b[m]> conversely that (and UNC-style paths in general) probably do not do what you hope  on linux)
13:43:32 <eviltwin_b[m]> filesystem cross-compatibility is a fractal-edged sword
13:43:37 <MarcelineVQ> hpc: reversable parsing comes up as a topic every once in awhile, wherein boomerang, invertible-syntax, and waargonaut are often linked
13:44:40 <MarcelineVQ> there's another one not coming to mind as well
13:45:45 <MarcelineVQ> well there's a few, but there's another common one that isn't coming to mind
13:47:12 <Phyx-> yes, absolute paths are not portable from one OS to another. I don't think there's anyone who thinks they are. but this is not exactly a "Windows" problem.
13:48:08 <eviltwin_b[m]> "not a windows problem" was like the second thing said on this topic
13:57:06 <crestfallen> hi I'm back trying to learn haskell. batten down the hatches. I'm wondering if Real World Haskell is prohibitively out-of-date.
13:57:17 <crestfallen> haskell *again
13:57:45 <crestfallen> I like how its written so far
13:58:02 <eviltwin_b[m]> I wouldn't say prohibitively, but it could get a bit painful at times (like all the exception handling changed between final copy and printing)
13:59:24 <crestfallen> thanks eviltwin_b[m]   I'm going to just use the same book by G. Hutton. the examples are large though I can't keep track.
14:03:13 <jle`> crestfallen: it's not too bad, i don't think, as long as you follow that list of updates/things to watch out for from that stack overflow post
14:04:47 <crestfallen> jle`: yeah I saw that it includes many updates thanks   ..  any comment on the Graham Hutton book? I am bogged down with it tbh
14:06:07 <crestfallen> I just don't think I will learn haskell from a book ->  crestfallen
14:06:47 <jle`> maybe not completely, but i'm sure a book would be helpful to some extent
14:07:05 <jle`> it's not an all or nothing kind of deal :)
14:08:20 <crestfallen> I need to be around people to express myself. the chat is very helpful but I am sort of slow-witted in this environment.
14:09:23 <crestfallen> *Everyone* I talk to says learn python first. 
14:09:55 <karetsu> you could talk to me, I would definitely not say that :3
14:10:21 <crestfallen> :)   !!
14:12:44 <crestfallen> karestsu   :   severe or stern ; Japanese
14:13:53 <hpc> if you talked to me, i wouldn't say it
14:14:00 <hpc> if you didn't talk to me, i still wouldn't say it :D
14:14:21 <crestfallen> I sincerely wish I could talk to you guys face to face
14:15:14 <jle`> come to one of the many haskell/fp conferences every year around the world :)
14:15:19 <jle`> or better yet, ask your boss to pay for you to come :3
14:15:53 <crestfallen> It seems that noone .. noone .. on the UC Berkeley campus knows haskell or is willing to teach it. how can that be?
14:16:21 <crestfallen> ivory tower bullshit elitism
14:16:35 <crestfallen> sorry just giving vent
14:16:45 <jle`> this is the first time i've seen someone complain about haskell not being ivory tower enough
14:16:57 <crestfallen> :)   !!
14:16:59 <sm[m]> crestfallen: how about @where HTAC
14:17:08 <crestfallen> what's that?
14:17:10 <duncan> Well, maybe you've not met them - you should put up some suitable posters with lambdas, bananas, barbed wire and stuff, and see what fish you catch.
14:17:26 <sm[m]> @where HTAC
14:17:26 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
14:17:28 <karetsu> crestfallen: yep, its my preferred pronounciation of my name in japanese ;)
14:17:37 <duncan> Honeestly can't believe there's nobody inteested, maybe they've just not found a nice cosy group?
14:18:57 <crestfallen> I put up one that said "any haskellers" with my needs and contact duncan ; in the CS and math buildings. These people have *no time* not even to politely say no.
14:19:26 <duncan> Planned events usually attract more interrested folks
14:20:01 <duncan> stand up in front of lectures and give a really passionate speech to students, you're bound to attract one or two and that's all you neec
14:20:05 <duncan> need*
14:20:37 * sm[m] would bet money there is an existing group somewhere around UCB interested in haskell
14:21:01 <crestfallen> ok thanks duncan. the professors are just like rock stars. they literally have bouncers/security at some lectures I'm not kidding.
14:22:12 <crestfallen> thanks sm[m]
14:22:19 <Tuplanolla> Big school problems, it sounds like.
14:22:23 <duncan> That's fine, you just need to email them and ask them if it would be OK if you could introduce a new group
14:22:30 <duncan> or catch them for coffee
14:22:40 <crestfallen> word Tuplanolla
14:23:07 <adius> Hi, if I have a multi package stack project, how can I specify `extra-deps` only for one subpackage?
14:23:39 <crestfallen> It's been interesting working at UCB. classism at it's absolute worst
14:24:11 <sm[m]> crestfallen: let me know how you find that book. You mentioned wanting to learn Haskell - another good way is to tackle clash of code/excercism/project euler problems one at a time and when you get stuck, paste and ask for help
14:24:58 <sm[m]> I know it's not the same as face to face. Have you found the directory of user groups/clubs/meetups ?
14:26:37 <sm[m]> adius: you have to declare it's availability in the stack.yaml, but you can specify the desired version of that package in each package.yaml
14:28:45 <crestfallen> sm[m]: thanks. you may be new. for a couple years I sort of over-taxed this chatroom. I was mis-interpreted a few times although I try to be precise in my communication
14:30:08 <crestfallen> karetsu  I just love Kanji. maybe that should be my study language of choice.
14:39:33 <adius> sm[m]: Mh ok, I seem to have problem because stack requires specified sub-packages to be available even though I'm not building them (which seems stupid ^^)
14:44:16 <sm[m]> adius: do they show up in the list when you do stack build --dry-run ?
14:47:54 <adius> sm[m]: Yeah sure, but if I run `stack build subpackage-1` then `subpackage-2` shouldldn't be touched, but somehow it is
14:48:48 <sm[m]> seems somehow it's depended on
14:48:50 <crestfallen> so a recursive list has the additive identity, 0.   L(a) = [] + [a] + [a,a] + [a,a,a]  ...         but when you see this in notation it's L(a) = 1 + a + (a*a) + (a*a*a)  ... so if this is an "infinite sum of products" , why is 1 , the identity for multiplication used in notation?
14:49:19 <jle`> 1 is unit
14:49:26 <jle`> it's the branch that has one possible value
14:49:34 <jle`> in this case, 1 corresponds to []
14:50:29 <jle`> in saying 1 + a + a^2 + a^3 + a^4, we mean that it is either the single 0-item list, one of the |a| single item lists, one of the |a|^2 two-item lists, one of the |a|^3 three-item lists, etc.
14:50:36 <jle`> |a| here referring to the cardinality of a
14:51:07 <jle`> for example, for [Bool], we either have the single possible empty list, one of the two possible single-item lists, one of the four possible two-item lists, one of the eight possible three-item lists, etc.
14:51:35 <jle`> here 1 is not used as the multiplicative identity, but as an actual useful concept on its own right
14:51:50 <crestfallen> jle`: so the single 0-item list is in math notation actually the identity 0 ?
14:52:03 <jle`> that question doesn't really make sense
14:52:10 <jle`> what identity?
14:52:32 <crestfallen> well I thought unit and identity were interchangeable so I'm confused
14:52:44 <jle`> unit here i'm referring to the specific type ()
14:53:00 <jle`> which is often pronounced 'unit' in spoken english
14:53:19 <jle`> so, i'm not talking about an abstract 'unity' element. just literally referring to () :)
14:54:35 <jle`> note that L(a) = 0 + 1 + a + a^2 + a^3 ... is just as valid as L(a) = 0 + 0 + 1 + a + a^2 + ...
14:54:43 <jle`> 1 is useful here because it's *not* the additive unit
14:54:55 <jle`> if it was the additive unit then there would be no reason to include it
14:54:57 <Tuplanolla> The infinite series is not a monoid construction, crestfallen. The `1` is not supposed to be neutral wrt `+`.
14:55:05 <MarcelineVQ> because you said unit was 1 and 1 corresponds to [] for your list example crestfallen is possibly confused about the correlation between () and []
14:55:25 <jle`> ah yeah, i do admit my terminology is a bit muddled
14:56:03 <crestfallen> ok , but this part of the math notation   L(a) = 1 + a  ...      that is not indicating the additive identity, right?
14:56:35 <jle`> yeah, 1 is not the additive identity there
14:56:48 <jle`> because if it was, there would be no reason to include it
14:56:56 <jle`> since 0 + a + ... is equivalent to a + ...
14:57:46 <jle`> maybe i don't mean 'because', but rather 'a clue that it is not is that' 
14:58:43 <crestfallen> thanks I'm watching this bartosz milewski video again...
15:00:37 <crestfallen> so 1 == [] == 0   ,   0 being the additive identity for that L(a) notation to be valid
15:01:48 <crestfallen> minute 1:04:33     https://www.youtube.com/watch?v=LkqTLJK2API
15:02:01 <MarcelineVQ> 1 == 0 should tigger alarm bells crestfallen
15:02:35 <Welkin> but it's true in javascript sometimes
15:02:35 <crestfallen> I know thanks MarcelineVQ   that's why I'm alarmed
15:03:55 <MarcelineVQ> crestfallen: can you tell me what is the cardinality of Bool?
15:05:03 <crestfallen> ||
15:05:18 <crestfallen> that takes 0 as the identity
15:05:50 <crestfallen> [a] is a singleton list, the first inhabited list
15:06:09 <MarcelineVQ> || is how we denote a cardinality |Bool| but what is bools caridnality? cardinality of a type is the count of values that type has, what are the values of Bool?
15:06:21 <crestfallen> 2
15:06:47 <MarcelineVQ> yes, and what are the values of Bool?
15:07:06 <crestfallen> True | False
15:07:14 <crestfallen> False | True
15:07:56 <MarcelineVQ> Right, so we know bool has a cardinality of 2 because it has two values True or False.
15:08:25 <crestfallen> what I don't see is that there is a subtle difference , I believe , if you're looking at the math notation.   
15:09:43 <MarcelineVQ> What difference is that?
15:10:31 <crestfallen> so if L(a) is an infinite sum of tuples, the notation begins with 1 and not 0. 1 is not the identity for Sum so that is where I'm stuck.
15:13:24 <hpc> crestfallen: there's two things going on - an outer sum, of inner products
15:14:04 <hpc> so you have the sum of (a series starting at n=0 of (product of n 'a's))
15:14:23 <hpc> when n = 0, the product is 1 because that's the identity for multiplication
15:15:43 <crestfallen> hpc    ...
15:19:41 <crestfallen> yeah so an empty list is actually 0 in math notation, but in CS that is the container for a list of increasing tuples, so it's functioning as the multiplicative identity   hpc
15:20:29 <crestfallen> I didn't say that well
15:22:14 * hackage network-simple 0.4.5 - Simple network sockets usage patterns.  https://hackage.haskell.org/package/network-simple-0.4.5 (RenzoCarbonara)
15:26:03 <crestfallen> hpc     i.e.    is 0:[]   functioning as () or 1  for the list of tuples ? 
15:27:39 <crestfallen> no that can't be how you write it.
15:31:00 <MarcelineVQ> the empty list does not count as 0. data Unit = Unit is cardinality 1, it's singular value is Unit. data Bool = False | True is cardinalty 2, it's 2 values are​ False and True. What is the cardinality of Maybe Bool? data Maybe a = Nothing | Just a
15:33:04 <MarcelineVQ> To add a missing piece, the cardinality of data Foo a = Foo a is the cardinality of a.
15:33:14 <crestfallen> 3 :   True, False, Nothing
15:34:12 <crestfallen> Just a in your example could be True or False , so Nothing makes 3
15:34:23 <MarcelineVQ> Yes, good that's right. Now the cardinality of a data List a = Nil | List a is?
15:34:37 <crestfallen> *Just True  or Just False or Nothing
15:35:49 <crestfallen> 1 (Nil) + a^n
15:36:01 <crestfallen> 1 + a^n
15:36:27 <MarcelineVQ> oop I forgot a constructor there, but you've got the pattern anyway
15:36:49 <crestfallen> please add it for me?
15:36:50 <MarcelineVQ> Nil is [], the empty list.
15:36:59 <MarcelineVQ> data List a = Nil | Cons (List a)
15:38:02 <MarcelineVQ> So the empty list has one inhabitant, Nil or [], it counts as 1 towards cardinality.
15:40:22 <crestfallen> excellent thanks. MarcelineVQ   so whatever a^n is , a^0 is one, so you could just count a^n to get the number of inhabitants, ie the cardinality starts with a^0
15:40:55 * nil is the empty list
15:42:08 <crestfallen> so you're beginning the count with a^0
15:43:09 <argent0> Hi, if I have something like. `Foo <$> either_e_a <*> either_e_b`. Is there a standard way of collecting all the errors in case both eithers fail?
15:43:52 <MarcelineVQ> "the cardinality starts with a^0" that seems like a reasonable way to think of it for list in particular
15:44:25 <crestfallen> that's very interesting thank you MarcelineVQ  et al 
15:44:27 <MarcelineVQ> I'm at my limit for what I know about the subject at this point.
15:44:51 <bsima> argent0: i think Data.Either.lefts is what you want
15:45:27 <bsima> or, something like that
15:45:59 <MarcelineVQ> argent0: Yes you use a sum type that has a semigroup left, like https://hackage.haskell.org/package/validation-1.1/docs/Data-Validation.html#t:Validation
15:48:03 <argent0> MarcelineVQ: bsima: Thanks. Validation seems to be what I was looking for
16:01:24 <adius> sm[m]: I'm getting the error `/subpackage-2/: getDirectoryContents:openDirStream: does not exist (No such file or directory)`, but it's not needed nor is it a dependency 🤔
16:02:18 <adius> It's just listed in the `stack.yaml`. Looks to me like stack scans the listed directories wether they are used or not
16:02:53 <sm[m]> You should probably paste the whole details
16:04:04 <fvr> can hie use new-build in projects now?
16:06:32 <adius> Uhm, that's all there is: A stack.yaml with several listed `packages` called `subpackage-1`, `subpackage-2`, … , but only `subpackage-1` really exists. When I then run `stack install subpackage-1` it apparently tries to read the `subpackage-2`, which doesn't exist and crashes 
16:35:13 <sm[m]> adius: you could share the stack.yaml and package.yaml/.cabal files if you want. I'm just saying, it'll increase the chances of one of us being helpful
16:39:07 <sm[m]> ..or understanding the problem.. but maybe you already have a pretty good handle on it, and would find something relevant in the stack issue tracker
16:46:05 <halogenandtoast> If I have a record type with some fields that aren't showable, is there an easy way to generate (or write) a Show instance that simply filters those out?
16:48:44 <MarcelineVQ> the ghost of haskell whispers, that's not what Show is fooo~rrr
16:49:22 <halogenandtoast> lol, I am willing to be educated on this, I just want to print out my record so I can see some details (just not all of them).
16:49:29 * shapr hops randomly
16:49:44 <lyxia> For debugging, use your best judgement. There is no stricter rule.
16:49:58 <lyxia> such Show instances are totally fine
16:50:03 <shapr> aw, was going to ask byorgey if there's an online interactive diagrams jupyter / ihaskell thingy
16:51:14 <lyxia> halogenandtoast: you can make dummy instances for those fields so that you can derive Show
16:51:30 <halogenandtoast> lyxia: yeah it's for debugging at this point, and in this particular case, I can work around my issue by calling print a little bit later than I was, but I was just wondering if I had a huge record type and one of the fields was a function, would there be an easy way to filter out the function field
16:52:04 <glguy> You could import http://hackage.haskell.org/package/base-4.12.0.0/docs/Text-Show-Functions.html
16:52:18 <halogenandtoast> heh fair enough
16:52:27 <lyxia> halogenandtoast: or you can do something like  "deriving instance (Show (IO X), Show (Y -> Z)) => Show Blah", that works without having to leak those instances, just import/define dummy instances for IO/(->) when debugging and those other instances will be automatically available.
16:53:19 <halogenandtoast> Yup makes sense
16:56:30 <halogenandtoast> lyxia: MarcelineVQ: glguy: Thanks for the info
16:56:35 <halogenandtoast> lyxia++
17:12:44 * hackage haskell-lsp-types 0.14.0.0 - Haskell library for the Microsoft Language Server Protocol, data types  https://hackage.haskell.org/package/haskell-lsp-types-0.14.0.0 (luke_)
17:13:44 * hackage haskell-lsp 0.14.0.0 - Haskell library for the Microsoft Language Server Protocol  https://hackage.haskell.org/package/haskell-lsp-0.14.0.0 (luke_)
17:34:07 <dmj`> think I found a bug with GHC https://gist.github.com/dmjio/d01e86c98bc6851e6f51b2aace3e192e, maybe someone can confirm
17:41:28 <lyxia> that does look wrong
17:43:19 <halogenandtoast> I thought that was a known issue that is fixed in 8.10 or something
17:43:44 * hackage lsp-test 0.5.3.0 - Functional test framework for LSP servers.  https://hackage.haskell.org/package/lsp-test-0.5.3.0 (luke_)
17:43:55 <nshepperd> i didn't even know the partialness checker could do that
17:49:44 * hackage haskell-lsp-types 0.14.0.1 - Haskell library for the Microsoft Language Server Protocol, data types  https://hackage.haskell.org/package/haskell-lsp-types-0.14.0.1 (luke_)
17:50:24 <int-e> dmj`: https://gitlab.haskell.org/ghc/ghc/issues/11503
17:50:39 <int-e> (so it's known, but there's no fix yet, by the looks of it)
17:51:39 <int-e> dmj`: I guess  IsIn x '[] = (TypeError ('Text "not here"), False ~ True)  is a workable compromise for the time being
17:51:50 <halogenandtoast>  int-e: lol I was watching a video by Richard Eisenberg trying to find out where he talked about this.
17:53:41 <dmj`> int-e: oh wow, very nice. Yea that did the trick. big thanks!
17:54:03 <int-e> dmj`: though perhaps it's not... does the error actually materialize that way?
17:54:25 <int-e> ah it does.
17:54:43 <int-e> (at least when trying to say  thingA = ThingB)
17:57:29 <dmj`> int-e: yea, works perfect
17:57:44 <dmj`> never thought to add multiple constraints in a type family like that
18:06:52 <jle`> does Any from GHC.Exts work as a bad-constraint ?
18:07:07 <jle`> (in this situation)
18:07:12 <jle`> Any :: Constraint
18:13:32 <dmwit> I feel like you have to have punctuation in your name to participate in this conversation.
18:27:48 <^|{`-}_{> I am totally qualified for that conversation. But you could perhaps enter too under d'mwit >:)
18:28:17 <monochrom> (Yes that was me.)
18:28:41 <jackdk> nice morse
18:29:41 <monochrom> I researched legal nick characters for freenode and came up with that extreme case.
18:30:01 <monochrom> (More precisely, I actually read their server source code.)
18:55:18 <iqubic> The #nixos server has a bot with this user name
18:55:21 <iqubic> {^_^}
19:13:46 * edwardk is finally done staring at fiddly little ghc primitives for the night.
19:14:01 <edwardk> but in theory, i now have the minimalist null-terminated string-based parser combinator library nobody ever asked for
19:14:18 <edwardk> now i can do fun stuff
19:15:03 <monochrom> Hey I'm teaching a course that uses C so maybe one day I may need that kind of parser. But in C. >:)
19:15:13 <edwardk> good luck with that =)
19:15:33 <edwardk> i was pretty pleased with how some parts of it turned out
19:15:39 <monochrom> Let me cast function pointers recklessly to recover >>=
19:16:24 <edwardk> i take the original input in as a bytestring, then i convert it to get a version with a null pointer at the end, but i make the parser with a region parameter, and use a reflectionstyle trick to push the original bytestring and the start/end of the null terminated string into that
19:16:51 <edwardk> now i can do most parsing combinators, like satisfy, skipUntilChar, etc. with no access to anything but the current poiinter
19:17:19 <edwardk> but if you _need_ the metadata it can be called up by writing a parser combinator that takes the constraint on its region parameter, in which case the typeclass mechanism plumbs it for you
19:17:35 <monochrom> I need a drink.
19:18:31 <edwardk> example
19:18:32 <edwardk> https://github.com/ekmett/codex/blob/master/engine/src/Engine/Shader/Include.hs
19:18:48 <edwardk> most of the combinators don't need any constraint on 's'
19:18:49 <edwardk> https://github.com/ekmett/codex/blob/master/engine/src/Engine/Shader/Include.hs#L209
19:19:32 <edwardk> and so they are just literally a combinator from Addr# -> State# s -> (#   (# a | (##) #), Addr#, State# s #)
19:19:34 <edwardk> which is noisy
19:19:57 <edwardk> but can be read as ptr and world to maybe a and a new ptr and world
19:20:12 <edwardk> but fully unlifted
19:20:19 <edwardk> so the only lifted thing there is 'a'
19:20:36 <edwardk> everything else isn't just hoping worker wrapper fixes it like in parsec/attoparsec, etc.
19:20:56 <edwardk> just a function from Ptr () -> Maybe (a, Ptr ()) -- with effects
19:22:04 <edwardk> but the last 4 combinators in that file https://github.com/ekmett/codex/blob/master/engine/src/Engine/Shader/Include.hs#L221 those do use the original bytestring to carve snippets off it
19:22:12 <edwardk> so only those get fed the bytestring
19:22:19 <edwardk> nothing else is getting plumbed unused arguments
19:23:05 <edwardk> i've yet to get anybody to care, but i'm rather stoked
19:24:20 <edwardk> this is morally the same kind of thing as Zepto in Attoparsec http://hackage.haskell.org/package/attoparsec-0.13.2.2/docs/src/Data.Attoparsec.Zepto.html#ZeptoT but with 'try' like semantics rather than attoparsec like semantics
19:25:48 <edwardk> the main win is that zepto carries around a full bytestring and has to keep flaying it open to access it. so its withForeignPtring every time it turns around to keep the ForeignPtrContents alive, and the bytestring consists of a foreignptr which is a pair of an address we really want and the foreignptrcontents to keep it alive, and a redundant offset which isn't needed and a length.
19:26:04 <edwardk> 4 things, where parsnip carries 1
19:31:59 <nshepperd> why does 'file' need KnownBase s?
19:33:29 <edwardk> file 'snips' the bytestring using tillChar
19:33:44 <edwardk> that shares the bytestring with the original text rather than forge a fresh one
19:33:51 <edwardk> i should make combinators that work both ways
19:34:06 <edwardk> to give you the option of sharing with the source or snipping a fresh copy in linear time
19:34:54 <edwardk> https://github.com/ekmett/codex/blob/master/parsnip/src/Text/Parsnip/Char8.hs#L158
19:35:22 <edwardk> which is built on https://github.com/ekmett/codex/blob/master/parsnip/src/Text/Parsnip/Internal/Mark.hs#L102 which needs the Base info
19:35:38 <clever> edwardk: i stumbled into https://github.com/ekmett/half/issues/22 a few days ago when helping somebody in here
19:35:40 <nshepperd> hmm, i see
19:36:46 <edwardk> clever: interesting
19:37:14 <clever> edwardk: i think 32bit x86 is normalizing multiple equivelant representations of NaN into a single form
19:37:22 <nshepperd> so you start with a ByteString, and convert it to a \0 terminated string in C land, then you parse entirely using pointers into the C string to remember your place
19:37:23 <clever> but its not entirely clear
19:37:26 <edwardk> clever: yeah. i'm not surprised that nans aren't roundtripping properly
19:37:42 <TurskaPanica98> Hello. I am new and I decided to try making a Live in a Cam site. Hope you will like my idea. The idea of being watched makes me really horny. Enter now ----> http://l2u.su/qcEw :)
19:37:42 <edwardk> nshepperd: yeah, i do all my parsing on the copy
19:37:53 <edwardk> but my snipping is mapped back into the original bytestring space
19:37:53 <clever> edwardk: some of the tests exclude NaN, but that one doesnt, but weirdly, it can roundtrip on 64bit just fine
19:38:09 <nshepperd> and KnownBase gives you back access to the original ByteString so that you can return ByteStrings to haskell land without copying anything
19:38:20 <edwardk> nshepperd: yep!
19:38:27 <clever> edwardk: ive also run into some very very strange bugs involving ByteString, let me get the numbers...
19:38:49 <edwardk> ByteString isn't really my wheelhouse, that is more of a dcoutts_  thing
19:39:22 <clever> edwardk: basically, i take something, run it thru cbor to make a bytestring, then just plain write it to a file
19:39:46 <clever> edwardk: and randomly (only once a year, over 100+ machines) it will gain an extra 8 byte prefix of nulls at the start of the file
19:39:49 <edwardk> anyways i think with half i'm willing to redefine success to make the test merely quotient and claim that nan becomes nan not that it preserves nan values for smuggling
19:39:52 <edwardk> as haskell generally doesn't
19:40:20 <clever> edwardk: the weird part, is that 100+ machines are encoding the same value, and writing to the same file, with the exact same binary, but only one messes up
19:40:32 <clever> and its so rare, that that only happens once a year or less
19:40:53 <clever> it has only occured twice so far, and its a different machine each time
19:43:00 <edwardk> what has you using half btw?
19:43:30 <clever> edwardk: i just stumbled into somebody in #haskell that was running into a half bug, on 32bit haskell
19:44:19 <edwardk> ah
19:47:26 <clever> edwardk: === also makes the errors in quickcheck a lot more obvious, once they do fail
19:47:59 <edwardk> yeah, i confess i mostly hspec and do a lot less quickchecking these days, so i'm no expert there. i have to page it in every time i do a quickcheck pass over code
19:48:09 <Axman6> edwardk: is this parer going to end up at Data.Attoparsec.Yocto?
19:48:14 <Axman6> parser*
19:48:42 <edwardk> Axman6: its one of two designs i've played with for my own use in the 2d sdf engine stuff
19:48:52 <edwardk> this one copies first and uses null termination
19:49:04 <Axman6> "Yocto- is the smallest official SI prefix." unless you can think of a way to pass around zero things, I feel that passing around one thing is as small as we're ever going to get =)
19:49:18 <edwardk> the other doesn't copy first, and uses an extra int or address to keep track of the end
19:49:36 <edwardk> i'm pretty much deciding to bail on that naming convention
19:49:41 <edwardk> hence 'parsnip'
19:50:17 <Axman6> heh, fair enough. is parsnipo supposed to be general purpose? (Haven't got to exploring beyond your first few links)
19:50:55 <edwardk> parsnip is currently good enough for me to parse for #include directives inside of a tiny 2d/3d engine thing, that is all i've got for it so far
19:51:08 <edwardk> but there are ~24 libraries so far that have accumulated as a side-effect of this effort
19:51:16 <edwardk> and most of them are intended to spin off
19:51:31 <Axman6> only 24? You're losing your touch mate
19:51:32 <edwardk> ~24 libraries in ~28 days so far is a bit much though
19:51:46 <edwardk> yeah i slipped by 4 days!
19:51:52 <edwardk> i blame dalaing
19:52:15 <edwardk> ever since i made him the boss of the ##coda project so i wouldn't have to do it, he's been making me do crazy things like take days off
19:52:47 <Axman6> jerk
19:53:01 <MarcelineVQ> what is coda? I read the readme but I don't think it went into that; you guys seem pretty excited about it
19:53:08 <Axman6> I blame dalaing for many things
19:53:18 <Axman6> HAskell++
19:54:01 <edwardk> MarcelineVQ: its a sort of catch-all for my current efforts to explore how to build a haskell-like language that scales better on a lot of different axes.
19:54:34 <edwardk> the codex sub-project while we're currently flailing around on is mostly presentation oriented stuff for coda
19:55:05 <edwardk> hence why i have a half-dozen sub-projects dealing with things like shaping glyphs, finding fonts, etc.
19:55:23 <edwardk> that's been a lot of the last couple of weeks
19:55:44 * hackage hw-prim 0.6.2.26 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.6.2.26 (haskellworks)
19:55:49 <Axman6> are we going to get macOS level font rendering out of this?
19:56:12 <edwardk> Axman6: on apple i already do opentype AAT and have corefonts integration...
19:56:50 <edwardk> but come on, apple doesn't really have good multiple master support, good opentype math support...
19:58:31 <edwardk> at the moment i'm shaping things with harfbuzz, which in theory handles things like LTR vs RTL vs vertical layout properly for lots of languages, and improves on the baseline 2-character kerning crap that freetype and the like support, and i'm playing with more advanced ways to produce signed distance fields for the fonts to draw them on screen
19:59:47 <edwardk> i can do an edtaa3 style signed distance field from antialiased source text, but msdfgen does median of 3 signed distance fields that look better for small textures, and GLyphy by the guy who did harfbuzz looks even better but has to approximate the splines with generalized circular segments to compute nice signed distance fields and at extreme blow up yields artifacts
20:00:51 <edwardk> i'm playing around with if it makes sense to flip the whole thing like i would a 3d scene, and store many signed distance fields in a shared batch of uniform buffers per tile, tiled shading style, just replace lights with glyphs, rays with signed distance field intersection for vector graphics
20:00:55 <edwardk> that has some weird benefits
20:01:03 <edwardk> one is you can do things like motion blur perfectly
20:01:12 <edwardk> not that motion blurring text is a big deal for most people =)
20:01:53 <edwardk> but it means i can draw the frame like i do in a raytracer, and all my usual tricks apply
20:01:56 <edwardk> so i have a lot to say there
20:02:21 <edwardk> and can do things like temporal antialiasing for mostly static stuff, and adaptive multisampling for the places that have changed
20:02:39 <edwardk> but its a lot to do, so i probably won't get there
20:02:52 <edwardk> reaching in that direction has kept me entertained for the last 3-4 weeks though
20:03:16 <edwardk> mankyKitty has been helping out a lot
20:04:49 <mankyKitty> <3
20:06:15 <edwardk> i'm kind of curious what perfectly crisp anti-aliased as all heck vector graphics with correct motion blur looks like in practice
20:06:46 <edwardk> when i stop mucking around with getting the perfect reloading stuff done, i should try that out
20:07:01 <edwardk> on some ball shapes or something
20:07:11 * mankyKitty considers the infinity gauntlet snap as the required animation for compilation/proof search
20:08:03 <Axman6> mankyKitty's a pretty cool dude
20:08:42 <edwardk> shh don't tell him. it'll go to his head and he'll make me double his salary.
20:09:19 <mankyKitty> Axman6: I'm mostly in clockwork orange eye-drop mode with the Ed firehose on full 
20:10:35 <Axman6> I hope jackdk is helping you with that
20:10:50 <mankyKitty> he's the one with the eye drops, so yeah I guess he is
20:10:59 <Axman6> Hid intoduction to Data61 was 13 hours of the kmett firehose =)
20:11:14 <Axman6> he's never forgiven me
20:11:35 <edwardk> He seems to have held up well
20:11:47 <Axman6> just barely
20:16:14 * hackage unix-time 0.4.6 - Unix time parser/formatter and utilities  https://hackage.haskell.org/package/unix-time-0.4.6 (KazuYamamoto)
20:23:07 <jackdk> that was when I became certain that moving was the correct decision
20:23:29 <Axman6> and now you've done it again
20:25:46 <Axman6> and left me. I'm not sure I'll ever recover
20:27:44 * hackage hw-eliasfano 0.1.1.0 - Elias-Fano  https://hackage.haskell.org/package/hw-eliasfano-0.1.1.0 (haskellworks)
20:37:26 <jackdk> I miss you too Axman6 
20:37:43 <Axman6> I guess I left you first
20:50:49 <jusss> what this Kleisli compose is used for?
20:58:46 <juliusdeane> Like the (>=>) type of composition?
20:59:02 <jusss> juliusdeane: yeah
20:59:07 <jusss> juliusdeane: what it's used for
20:59:22 <juliusdeane> It's like (.) but for monadic actions
21:00:21 <juliusdeane> As an example, you could do mapM uncons >=> mapM (return . fst) $ ["excuse", "this", "absurd", "example"]
21:00:31 <juliusdeane> And you'd get Just "etae"
21:02:37 <jusss> f >=> g = \x -> (f x >>= g)
21:03:03 <jusss> z >>= g = \x -> z (g x) x
21:05:19 <jusss> f >=> g = \x -> (f x) (g x) x
21:05:59 <jusss> ?
21:06:40 <juliusdeane> The first definition you had for (>=>) looks good, that's actually how it's defined in Control.Monad I'm pretty sure
21:06:52 <jusss> the second is not
21:06:55 <juliusdeane> Yeah
21:06:58 <juliusdeane> Same for (>>=)
21:07:09 <jle`> i use it sometimes when i have two (a -> Maybe b)'s i want to compose
21:07:27 <jusss> 'cause z >>= g , z::e->a  and g::a->(e->b)
21:07:27 <jle`> to "double-filter", so to speak
21:08:35 <jusss> those stuff beyond my comprehension, I have seen those Reader and Kleisli compose article enough, and I still don't understand it
21:08:38 <edwardk> jusss: i use it when i start refactoring code a lot
21:08:57 <juliusdeane> It's good for making stuff point-free, kind of like Control.Arrow
21:09:10 <jle`> jusss: what stuff exactly?
21:09:12 <edwardk> foo x = do x <- y; z                         then becomes foo x = y >>= z          then becomes foo = y >=> z
21:09:28 <edwardk> er
21:09:34 <jle`> jusss: specific usages of >=> like we are talking about, or its behavior with the (e ->) monad?
21:09:35 <edwardk> foo x = do w <- y; z
21:09:37 <jusss> jle`: I can't understand (e->) monad
21:09:47 <jusss> jle`: also >=>
21:10:02 <jle`> you don't understand how to use it, or how to implement it?
21:10:04 <edwardk> in general (>=>) is a tool for avoiding one use names
21:10:14 <jusss> I don't know what they're used for, what situation they would be help?
21:10:31 <juliusdeane> Like if you have lots of configuration data that you send through functions
21:10:36 <jle`> honestly nobody really uses (e ->)'s Monad or Functor instance
21:10:51 <jusss> jle`: I know how to implement it, I don't understand why it's look like that and what is it used for
21:10:51 <jle`> except in rare situations, and it's usually always more readable to pass values normally
21:11:07 <edwardk> jle`: i use the monad a lot actually
21:11:11 <jle`> jusss: well, one answer to "why it looks like that" is...that's the only way that will typecheck :)
21:11:13 <edwardk> :t join (,)
21:11:14 <lambdabot> b -> (b, b)
21:11:23 <juliusdeane> (e->) still works like a data constructor, it just looks wacky
21:11:23 <jle`> is join (,) really more readable than \x -> (x,x) ?
21:11:37 <edwardk> atomicModifyIORef foo $ join (,) . what i want to do to the foo
21:11:51 <edwardk> jle' now i don't have to name the temporary variables on either side
21:11:59 <edwardk> because that is a lot shorter than
21:12:00 <jusss> juliusdeane: jle` but (e->) is not like Maybe or List,
21:12:10 <jle`> you're shifting the cost from write-time to read-time
21:12:18 <jle`> jusss: that is also true
21:12:19 <edwardk> atomicModifyIORef $ \x -> let y = something complicated x in (y,y)
21:12:19 <jusss> Maybe or List are simple to image, like a wrapper or container whatever
21:12:32 <jusss> but functions're not
21:12:40 <juliusdeane> Think of (->) as an infix constructor
21:12:41 <jle`> it's difficult to imagine functions?
21:13:11 <jusss> jle`: no, it's difficult to put function in those pattern like bind
21:13:15 <edwardk> i mostly use it for the atomicModifyIORef case
21:13:24 <jusss> fmap is ok, but bind or >=> 
21:14:20 <jusss> put function in bind, like the monad you all called Reader Monad, that's not easy to understand, I don't understand what it's used for, what situation it would be help with which form, 
21:14:29 <juliusdeane> jusss it's easier to use (->) like a prefix constructor and then give it a normal name like `Arrow` in your head
21:14:35 <edwardk> the functor for ((->) e) matters for a bunch of things like the existence of setters in lens, it pretty much is the reason why linear can exist, because every monad i offer in there is isomorphic to reader for some basis.
21:14:43 <juliusdeane> So a -> b becomes Arrow a b
21:14:56 <jusss> juliusdeane: I wonder why (e->) is monad, and what `return` would like 
21:15:09 <jle`> jusss: edwardk's suggestion with something like join (,) was that you just use it as a useful utility function, without worrying about the fact that it is a monad
21:15:18 <jle`> for example, `join (,)` is the same as \x -> (x,x)
21:15:22 <jle`> and it's useful to have \x -> (x, x)
21:15:24 <juliusdeane> jusss There's lots of blog posts all about the (->) monad
21:15:25 <edwardk> jusss: join for (->) e isn't that bad. try to write it.
21:15:30 <edwardk> (e -> e -> a) -> e -> a
21:15:47 <jle`> jusss: it's just useful exactly because of what it does
21:15:51 <jle`> there is no 'deeper' reason
21:15:54 <jusss> I don't know how to construct this monadic function
21:15:57 <jle`> i think you might be trying to find a deeper reason than there actually is
21:15:59 <edwardk> you are given a function that needs 2 e's give you an a    and an e, you have no way to combine or manipulate the e so you have to pass it through unmolested
21:16:02 <jle`> don't construct it as a 'monadic function'
21:16:07 <jle`> just write a function (e -> e -> a) -> e -> a
21:16:19 <jle`> in the end, (e -> e -> a) -> e -> a is a useful function to have
21:16:22 <jusss> f >=> g     = \x -> f x >>= g    so this monadic function f, how to construct one?
21:16:26 <edwardk> @djinn (e -> e -> a) -> e -> a
21:16:27 <lambdabot> f a b = a b b
21:16:32 <jusss> f take a normal value and return a function
21:16:56 <jle`> jusss: for (>=>) and (e ->), the type is (a -> e -> b)
21:17:04 <jle`> jusss: that's just any two-argument function
21:17:08 <jusss> when monad is [], we know `return` would like [a]
21:17:09 <jle`> there are several in base that you can use
21:17:14 <jle`> one famous one is (+)
21:17:17 <jle`> another famous one is (,)
21:17:27 <jle`> in general you can write one as \x y -> ..., using lambda syntax, too
21:17:31 <jusss> and monad is Promise, `return` like _ => new Promise.resolve(_)
21:17:32 <edwardk> > join (+) 2
21:17:34 <lambdabot>  4
21:17:56 <edwardk> > join (*) 5
21:17:58 <lambdabot>  25
21:18:06 <edwardk> > join (-) 4 -- =)
21:18:08 <lambdabot>  0
21:18:09 <jle`> jusss: for (f >=> g) for the (e ->) monad instance, f is just any function (a -> e -> b).  there are bunches of these :)
21:18:20 <jle`> jusss: are you familiar with how to define functions?
21:18:32 <jle`> myFunc x y = x * y + 2, for example
21:18:52 <edwardk> (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
21:18:53 <jusss> jle`: wait a sec, you mean binary functions are monadic function?
21:18:58 <edwardk> when m = (e ->)
21:18:59 <edwardk> we get
21:19:13 <jle`> jusss: look at the type of a -> (e -> b)
21:19:16 <jle`> jusss: that's just the type of a binary function
21:19:24 <edwardk> (>=>) :: (a -> e -> b) -> (b -> e -> c) -> a -> e -> c
21:19:28 <jle`> the (a -> m b), where m ~ (e ->), is just a -> e -> b
21:19:29 <jusss> jle`: but I think it's a unary function
21:19:41 <jusss> jle`: it take a value and return a function value
21:19:52 <jle`> that's what a binary function is in haskell
21:19:57 <jle`> all binary functions in haskell are like that :)
21:20:01 <jle`> look at the type of (+):
21:20:06 <jle`> (+) :: Int -> (Int -> Int)
21:20:10 <edwardk> in english 'if you know how to turn an a into a b with the help of an e, and know how to turn b into c with the help of an e, you can turn a into c with the help of an e.
21:20:15 <Axman6> All functions take one argument
21:20:19 <Axman6> never forget
21:21:01 <jle`> jusss: a -> (e -> b) is equivalent to a -> e -> b
21:21:11 <jle`> just because that's how -> associates
21:21:42 <jusss> edwardk: so "<edwardk> (>=>) :: (a -> e -> b) -> (b -> e -> c) -> a -> e -> c" means >=> take two binary functions and return one binary functions ?
21:21:56 <jle`> you can think about it as taking two binary functions and returning a binary function
21:22:06 <jle`> (a -> e -> b) -> (b -> e -> c) -> (a -> e -> c)
21:22:31 <jusss> and this >>= :: (e->a) -> (a -> (e->b)) -> (e->b)  it means >>= take a unary function and a binary function then return a unary function?
21:22:36 <jle`> jusss: do you see how (a -> m b) turns into (a -> e -> b) when we set m ~ (e ->) ?
21:22:44 <jusss> jle`: I see
21:22:51 <edwardk> jusss: effectively, yes.
21:22:53 <jusss> jle`: 'cause m is (e->)
21:22:57 <jle`> yeah. follow the types :)
21:23:30 <jle`> earlier you asked how to construct the 'f'.  to do it, just look at the type, (a -> e -> b), and look back in your memory if you ever learned a way to construct an (a -> e -> b)
21:23:45 <jle`> :t ((+) >>=)
21:23:47 <lambdabot> Num a => ((a -> a) -> a -> b) -> a -> b
21:23:52 <jle`> oops
21:23:54 <jusss> wait a sec, this is really change my mind,   'cause think (a->(e->b)) as a binary function
21:23:56 <jle`> :t ((+) >=>)
21:23:57 <lambdabot> Num b => (b -> b -> c) -> b -> b -> c
21:24:06 <jle`> jusss: right, there are many ways to think of an a -> (e -> b)
21:25:31 <Axman6> jle`: strictly, in Haskell there is no such thing as a binary function. _all functions take one argument_ __always__
21:25:42 <Axman6> UH, jusss
21:25:51 <Axman6> I will assume jle` already knows this
21:26:03 <jle`> i don't mind hearing it again :)
21:26:10 <Axman6> ____always____
21:26:27 <jusss> so (+) is the (a->e->b)
21:26:34 <jle`> in fact, a -> e -> b might even be a "trinary function", if b is a function type
21:26:41 <Axman6> (+) is a -> (a -> a)
21:26:53 <jle`> > ((+) >=> (+)) 3
21:26:56 <lambdabot>  <Integer -> Integer>
21:27:05 <jle`> > (((+) >=> (+)) 3) 10
21:27:07 <lambdabot>  23
21:27:36 <jle`> that was less helpful than i had imagined
21:27:53 <jusss> jle`: wait a sec, how this >=> works in this example?
21:28:31 <jusss> this is really change my mind about the pattern of monad, think (a->e->b) as a binary function
21:28:52 <jle`> it's basically "plus ten" twice
21:29:12 <jle`> so 10 becomes the first argument to (+), it becomes:
21:29:25 <jle`> (10 +) ((10 +) 3)
21:29:42 <jle`> if we use useful names like f and g, we'd get
21:30:06 <jle`> ((f >=> g) 3) 10  ==> g 10 (f 10 3)
21:31:34 <Axman6> imagine 10 is some configuration both f and g need to access. now ou have a way to pass that config to both of them without having to do it explicitly
21:31:58 <jle`> and also remember that nobody really ever uses (>=>) for functions
21:32:11 <jle`> so if this is puzzling you...know it would puzzle most haskellers as well :P
21:32:26 <Axman6> but they do for Reader, which is just a newtype over functions which all need the same config
21:32:30 <Axman6> @src Reader
21:32:30 <lambdabot> type Reader r = ReaderT r Identity
21:32:30 <lambdabot> --OR
21:32:30 <lambdabot> data Reader r a = Reader { runReader :: r -> a }
21:32:49 <jle`> i have never in my life seen anyone use Reader
21:33:08 <jle`> but a lot of people do use ReaderT :)
21:33:35 <jusss> Axman6: wait a sec, in "<jle`> ((f >=> g) 3) 10  ==> g 10 (f 10 3)"  yes, we pass 10 to f and g both, but why g still need f's result ?
21:33:48 <jle`> the only time Reader ever is relevant is in teaching examples
21:33:50 <Axman6> There's a spiderman pointer at spiderman meme to be had here...
21:33:55 <jackdk> reader is good practice when teaching someone by helping him or her write out the instances. Though it's probably better to use (->) r for that
21:34:06 <jle`> jusss: that's just what >=> does
21:34:12 <jackdk> as in good-as-practice, not "good practice"
21:34:14 <jle`> that's like saying "why does (+) add two numbers together?"
21:34:17 <Axman6> :t (>=>)
21:34:18 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
21:35:03 <jle`> jusss: f >=> g is function composition, so you're eventually passing the result of f to the result of g
21:35:03 <jusss> is there another example for Reader Monad?
21:35:09 <jusss> pass value to two functions?
21:35:17 <jle`> try implementing join
21:36:22 <Axman6> :t join
21:36:23 <lambdabot> Monad m => m (m a) -> m a
21:36:28 <jusss> join (Just (Just x)) = Just x
21:36:40 <jle`> right, but join for (-> e)
21:36:50 <jle`> joinFunc :: (e -> e -> a) -> (e -> a)
21:36:50 <Axman6> :t join @((->) r)
21:36:51 <lambdabot> error: parse error on input ‘->’
21:37:20 <MarcelineVQ> % :t join @((->) _) -- Axman6
21:37:20 <yahb> MarcelineVQ: (w -> w -> a) -> w -> a
21:37:56 <Axman6> <3
21:38:14 <MarcelineVQ> @((->) _) isn't the most clear thing to a learner tho
21:38:15 <lambdabot> Unknown command, try @list
21:38:19 <MarcelineVQ> @botsnack
21:38:19 <lambdabot> :)
21:38:28 <jusss> this one I can't, 'cause we only can get the output by apply it on f
21:38:46 <jusss> join:: m(m a) -> ma
21:39:10 <jusss> if f:: m(m a),  we must f(x) get m a
21:39:28 <jusss> make something apply on f
21:41:08 <jusss> jle`: how you implement this ? when (e->) is m in join
21:41:10 <MarcelineVQ> jusss: jle is asking you to write joinFunc :: (e -> e -> a) -> (e -> a)
21:41:36 <jle`> jusss: plug in (e ->) for m, the same way you just did before
21:41:41 <jle`> join :: m (m a) -> m a
21:41:59 <jle`> join :: (e ->) ((e ->) a) -> (e ->) a
21:42:10 <jle`> join :: (e -> (e -> a)) -> (e -> a)
21:43:03 <jusss> I know it's look like join take a binary function and return a unary function, but hey, this is a function , not like List or Maybe that container is not changed , 
21:43:14 <Axman6> join e2e2a = ...
21:43:26 <jusss> [a] and Just a, that [] and Just are not changed, but not same for functions
21:43:51 <jle`> try writing it out
21:43:54 <jle`> join f = ....
21:43:56 <Axman6> jusss: if you have a function which takes two arguments, both of the same type, and you have one of those things, can you fet that function to return its result?
21:44:11 <jle`> note the type is join :: (e -> e -> a) -> e -> a
21:44:13 <jle`> so you can start out:
21:44:16 <jle`> `join f x = ....`
21:44:22 <Axman6> if I have f :: Int -> Int -> String, and I have x = 4 :: Int, can you give me a String?
21:44:36 <jle`> you want an 'a' as the result, right?  and you have an 'e' and an 'e -> e -> a'
21:46:06 <jusss> f:: e->e->a,   and f e:: e->a  so join f ... wait a sec , let me think
21:46:24 <jusss> I'm not sure the paremeter of join now
21:46:32 <jusss> f x or  f x y or f x y z
21:46:44 <jle`> `join f x = ???`
21:46:59 <jle`> right, giving x to f gives you an e -> a
21:47:11 <jle`> and you want an 'a' as a final result
21:47:15 <Axman6> jle`: you are join, I have given you f :: Int -> Int -> String, and x = 7, please give me a String
21:47:16 <jusss> but that x is e->a
21:47:23 <jusss> no
21:47:24 <jle`> jusss: no, that x is e :)
21:47:27 <Axman6> no, that x is e
21:47:37 <jusss> and f x is e->a
21:47:38 <Axman6> @quote stereo
21:47:38 <lambdabot> monochrom says: Welcome to #haskell, where @remember's are in majestic stereo!
21:47:39 <jle`> look at the type of join -- join :: (e -> e -> a) -> e -> a
21:47:56 <jle`> right, `f x :: e -> a`
21:48:00 <jle`> but you want an 'a' in the end
21:48:02 <jusss> join f = f x
21:48:10 <jle`> so, riddle me this:
21:48:13 <jle`> if you have an 'e -> a'
21:48:15 <jle`> and you have an 'e'
21:48:17 <jle`> how do you get an 'a' ?
21:48:24 <Axman6> join f e = ...
21:48:25 <jusss> but x is not in the left =
21:48:39 <jusss> wait a sec,  what yours f::?
21:48:40 <jle`> yes it is. witness:
21:48:42 <Axman6> look at the type: join :: (e -> e -> a) -> e -> a
21:48:44 <jle`>   `join f x = ....`
21:48:56 <jle`> the x here is on the left hand side of the =, as opposed to the right hand side
21:48:59 <jusss> jle`: what's your f 's type?
21:49:04 <jle`> (e -> e -> a)
21:49:05 <Axman6> join f returns a function of type e -> a
21:49:17 <jle`> jusss: i also wrote this a few times, but:
21:49:25 <jle`> the type of join is (e -> e -> a) -> e -> a
21:49:31 <jle`> so the first argument is (e -> e -> a), and the second argument is e
21:49:59 <jusss> jle`: but if f:: e->e->a and x:e  so join f = f x,
21:50:12 <jusss> and x can not be right if it's not in the left
21:50:20 <jusss> so this is confilicted
21:50:22 <jle`> right, good thing it's on the left
21:50:25 <jle`> join f x = ...
21:50:28 <jle`> see, it is on the left :)
21:50:35 <jusss> jle`: that would be join f x = f x x
21:50:35 <Axman6> join f = \x -> ...
21:50:39 <jle`> hooray :D
21:50:49 <Axman6> ues!
21:50:51 <Axman6> yes*
21:51:30 <jusss> based on point-free or whatever-expanse or expand?
21:51:57 <jusss> I don't know the name, put the same symbol both on the side of =
21:52:29 <Axman6> so... the pointfree implementation of join f x = f x x is... join
21:52:43 <jusss> so I'm think wrong
21:53:19 <jusss> a x = \x -> a
21:54:21 <jusss> I know what you means
21:54:32 <jusss> join f = \x -> f x
21:54:44 <jusss> we give f a x to get f's result 
21:55:24 <jusss> but still I don't know why this lambda can do this, 'cause x is not showing in the left of = and we can use it on the right part of =
21:55:44 <jle`> join f = (\x -> f x x)
21:55:56 <jle`> you can think of (\x -> f x x) as its own expression
21:56:16 <jle`> it's a self-contained lambda expression
21:56:32 <jusss> jle`: wait a sec, join f= \x -> f x x is right? not \x -> f x?
21:56:43 <jle`> right, because giving x to f is (e -> a)
21:56:49 <jle`> so you need to give x again to the (e -> a) to get the 'a'
21:58:23 <jusss> jle`: join f x = f x x, is right?
21:58:37 <jle`> yes
21:58:49 <jle`> remember that myFunc x = ... is just sguar for myFunc = \x -> ...
21:58:59 <jle`> so join f x = f x x is sugar for join f = \x -> f x x
21:59:44 <jusss> jle`: but apply one parameter on same function twice is really weird, not just join, bind and >=> too
21:59:55 <jusss> they all apply twice
22:00:07 <jle`> is that something you think is weird?
22:00:40 <jle`> you might be bringing in some preconceived notions of weirdness to the table :)
22:00:41 <jusss> in other languages, we may do f(g(x)) , 
22:01:02 <jusss> but not f(g(x), x)
22:01:09 <jle`> have you ever went out on the street and ask people for the easiest 'arithmetic question' they know?
22:01:13 <jle`> usually they will give you 1 + 1
22:01:16 <jle`> or 2 + 2
22:01:24 <jle`> applying the same value to a function twice is pretty normal :)
22:01:37 <jle`> jusss: you do f(g(x), x), sometimes. not all the time
22:01:44 <jle`> you aren't going to be doing f(g(x), x) for every function
22:01:48 <jle`> but sometimes, you do do it
22:02:05 <jusss> jle`: I don't remember I did this in other function programming, like js or python or scheme
22:02:24 <jle`> that's because you haven't needed it, right?
22:02:24 <jusss> what the situation I would do that?
22:02:40 <jle`> so, you rarely need it here, too
22:02:40 <jusss> yeah, I haven't needed it and I haven't seen it yet
22:02:46 <jle`> just because it *exists* doesn't mean that it's *useful*
22:02:58 <jle`> you seem to think that because (>=>) *exists* for functions, it means that it's *useful*
22:03:00 <jle`> but, it doesn't
22:03:24 <jle`> maybe your problem is that you are looking at (>=>) and asking "why is this function useful for (e ->)? i have enver used it before"
22:03:27 <jusss> I thought that >=> and Reader Monad are useful, 'cause they're functions
22:03:32 <jle`> functions are useful
22:03:34 <jusss> and functions are everywhere 
22:03:36 <jle`> but not every function combinator is useful
22:03:53 <jusss> they must be made for something
22:04:01 <jle`> nobody made (>=>) for Reader
22:04:02 <jusss> something I haven't met
22:04:06 <jle`> they made it for Maybe, [], etc.
22:04:12 <jle`> we get (>=>) for Reader as a mistake, an accident
22:04:25 <jle`> it was never meant to be used for Reader. it was meant to be used for other monads
22:04:59 <jusss> jle`: I mean bind pattern for Reader, and >=> for monadic values
22:05:50 <jusss> jle`: for example, Maybe can use for nullable detect, and Either can do some part of if-else(not all)
22:05:54 <jle`> i even mentioned earlier that pretty much nobody ever uses Reader
22:06:23 <jle`> just because it *exists* doesn't mean that it's *useful* :)
22:06:29 <jusss> so I thought that Reader should be used for something too, and I don't know that what is that yet
22:06:38 <jle`> you're out of luck, i'm afraid
22:07:44 <jusss> I hope I can understand them
22:07:51 <jle`> it looks like you do understand them already :) 
22:07:58 <jle`> but you might be stuck on finding a useful situation to use them
22:08:10 <jusss> that's right
22:08:12 <jle`> that part, i can tell you now, you won't really find
22:08:25 <jle`> just because the monad instance exists doesn't mean that it's useful
22:08:46 <jle`> also note that you might be giving 'Monad' a little bit more importance than it's due
22:08:54 <jle`> monad is only one small aspect of a type's interface
22:09:01 <jle`> usually it's maybe like 5% of what makes that type useful
22:09:08 <jusss> but all the articles said how them're important , how they changed something like corotine
22:09:10 <jle`> i made that number up, but it's probably lower :)
22:09:24 <jle`> maybe those articles were trying to sell you something. save your credit card number :)
22:10:39 <jusss> people are selling Functional Programming at every languages now
22:10:45 <jle`> functional programming is useful
22:11:01 <jle`> "the Monad instance for (->)" is much much much much less useful
22:11:28 <jusss> jle`: about free monad, they said it can seal the side effect 
22:11:35 <jle`> that's a property about the free monad
22:11:42 <jle`> that doesn't have to do with the specific Monad instance for Reader
22:11:49 <Axman6> monads are important because they are very simple, extremely general and very widely applicable to many problems.
22:12:11 <jusss> but Reader is a special case for me
22:12:11 <Axman6> they're important because people use them all the time in all languages but don't know it
22:12:31 <Axman6> it's no more special than State
22:12:41 <jle`> jusss: yes, Reader is an uninteresting special case
22:13:00 <jle`> jusss: here's an analogy: let's say somebody just invented the first ever car.  it's a great invention that can take you from city to city, for a very low cost
22:13:08 <jle`> you buy a car, and you look at it and say you want to learn how to drive it
22:13:20 <jle`> you look at a screw on the dashboard
22:13:30 <jle`> "this screw cannot take me anywhere. but i will spend ten years studying it"
22:13:47 <c_wraith> the only thing that makes reader special is that its Monad interface doesn't actually give more power than its Applicative interface.
22:13:50 <jle`> you are only looking at a very small part of functional programming. and furthermore, it is a specific part that is not useful at all
22:14:16 <jle`> so, what if someone comes up to you and says, "this screw on my dashboard is not very useful.  but, i have heard that cars are useful.  what is the deal?"
22:14:25 <jusss> I'm attracted by this special thing
22:14:34 <jle`> yes, it is okay to be attracted to it
22:14:38 <jle`> but just be aware that it is not useful
22:14:43 <Axman6> c_wraith: slightly mindblown. I had noticed that but never put into words
22:14:44 <jle`> this is the nature of life, in a way
22:14:52 <jusss> fine
22:15:22 <jusss> I hope one day I can find the useful way for it
22:15:23 <jle`> yes, you are attracted to it. that's a good thing, and a lot of us here share your fascination
22:15:36 <jle`> but, we also know that it is a more or less useless thing
22:15:54 <Axman6> spark plugs are pretty cool though
22:16:36 <jle`> jusss: so yes, functional programming is useful. functions are useful. but this is not. and that's ok
22:16:43 <c_wraith> jusss: it comes up sometimes.  Sometimes you have a function with the right shape and realize that you can use Reader to pass extra arguments.
22:16:50 <jusss> special but useless...
22:17:02 <Axman6> jusss: Reader by itself isn't very useful, but ReaderT gets used all the time in applications which need to pass configuration around to many different components
22:17:05 <jle`> just because functional programming is useful doesn't mean that every single minute function that exists ever, will be useful
22:17:05 <c_wraith> jusss: and that is fun!
22:17:19 <jle`> functional programming is about finding the useful functions, and using those :)
22:17:23 <jle`> it isn't about making all functions useful
22:18:02 <Axman6> @remember jle`: functional programming is about finding the useful functions, and using those.  it isn't about making all functions useful.
22:18:02 <lambdabot> Good to know.
22:32:49 <dibblego> but Reader is useful
23:03:18 <jle`> the problem was more that they believed that every single possible monad combinator in Control.Monad, as applied to Reader, must be generally useful
23:03:31 <jle`> or else it wouldn't have been included in Control.Monad
23:04:04 <jle`> generally useful as in, (>=>) for Reader would be something that is useful enough to use all the time
23:08:45 <Axman6> jusss: if you're still around, you might find dibblego's somewhat enlightening. It helped me a lot to stop thinking about what classes mean and focus on what the types mean: https://blog.tmorris.net/posts/20-intermediate-haskell-exercises/
23:09:01 <Axman6> uh, dibblego's 20 intermediate haskell exercises*
23:09:18 <Axman6> is that really 11 year old D: jesus
23:09:48 <Axman6> dibblego: it'd be great tpo update that post to add instance sigs
23:09:59 <dibblego> Axman6: PR accepted!
23:12:46 <dibblego> those exercises are part of what became data61/fp-course
23:14:17 <Axman6> I found them very useful to go through while sitting on IRC years ago. definitely more succinct than the course
23:15:11 <dibblego> I agree, but I found those successes to be outliers
23:16:14 * Axman6 is a happy outlier
23:18:48 <dibblego> I just got back from USA, after being bugged two years in a row by the same person, to write blog posts
23:50:14 * hackage wai-app-file-cgi 3.1.8 - File/CGI/Rev Proxy App of WAI  https://hackage.haskell.org/package/wai-app-file-cgi-3.1.8 (KazuYamamoto)
23:51:44 * hackage mighttpd2 3.4.5 - High performance web server on WAI/warp  https://hackage.haskell.org/package/mighttpd2-3.4.5 (KazuYamamoto)
