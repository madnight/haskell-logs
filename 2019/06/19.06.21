00:03:21 <qwebirc2712> Hello
00:03:42 <ski> hello qwebirc2712
00:04:05 <qwebirc2712> I'm having trouble installing Haskell on my mac computer
00:04:30 <qwebirc2712> I need some help
00:04:52 * ski doesn't know about Mac, sorry
00:05:26 <ski> if you stick around, possibly someone else will have some suggestions for help ?
00:06:07 <qwebirc2712> Ok, thanks anyway
00:06:43 <ski> .. or not :)
00:22:21 <hxxxrz> what implementation can it have? "a" is not Eq, so I can't check a and b for equality. Also "a" hasn't got any restriction, so (a -> b) there can be only.. (a = b) ?
00:22:23 <hxxxrz> chk :: Eq b => (a -> b) -> a -> b -> Bool
00:25:52 <ski> hxxxrz : `a' doesn't have to be `b'
00:26:36 <ski>   chk f x = ..f..x..
00:26:47 <ski> what's the type of `f', and the type of `x'
00:27:12 <ski> what's the expected type of `..f..x..', and how can you reach that, from the available information
00:27:15 <ski> ?
00:28:41 <hxxxrz> sorry, what does it mean ..f..x..
00:29:51 <ski> that's just a hole in the code, for you to fill in with some expression (possibly depending on `f' and `x')
00:30:24 <ski> you're to replace it with some actual Haskell expression
00:31:01 <ski> er, actually, it should have been
00:31:08 <ski>   chk f x y = ..f..x..y..
00:31:15 <ski> because there was yet another argument
00:31:35 <ski> if `x' and `y' had been of the same type (`b' say), then you could have done
00:31:41 <ski>   chk f x y = x == y
00:31:53 <ski> but as you noted, that doesn't work in this case
00:33:38 <ski> hxxxrz : clear now ?
00:36:08 <hxxxrz> ok i guess i understand where im wrong.. for example i can check ":i Eq" and choose functions for my `Eq b'. But `a' has no any restriction, but is there a bunch of functions for it?
00:36:31 <hxxxrz> because i thought if there are no any restrictions i can do only "a = b"
00:37:00 <dminuoso> hxxxrz: So frequently its useful to consider the "what do I know about my types"
00:37:19 <dminuoso> hxxxrz: If you have an unconstrained type variable, it means you cant know anything about it as an implementor.
00:37:25 <dminuoso> Since the choice of that type is deferred to the caller.
00:37:55 <dminuoso> So in `chk :: Eq b => (a -> b) -> a -> b -> Bool` you dont know anything about `a`. So the only "functions/values" that involve `a` you can possibly use, are what you are being handed to as arguments.
00:39:33 <dminuoso> And you dont know much about `b` either, since the actual choice for what that type `b` becomes is also deferred to the caller of your function.
00:39:55 <dminuoso> But you know *something*, namely that it satisfies `Eq b`, so you can use any methdods of the `Eq` typeclass on it.
00:40:29 <dminuoso> So the only things you can use are: The Eq dictionary for type b and the arguments you are being given.
00:41:07 <dminuoso> You cant use anything else, since again your implementation must work for *any* choice of types `a` and `b`, where `b` is at least constrained to `Eq b`.
00:41:50 <dminuoso> This might feel limiting, but its in fact liberating. You no longer need to consider all the functions that exist in Haskell, you only have 3 arguments that you can use, and the Eq dictionary.
00:42:03 <ski> hxxxrz : you're not allowed to assume `a = b'. the caller will pick `a' and `b', not you (the implementor of `chk'). `chk' can't assume `a' and `b' are the same type (they might, but they also might not. in general you have to treat them as if they are different, because they might be)
00:42:45 <dminuoso> hxxxrz: Let me emphasize on one bit ski implied. They are not required to be different either, they *can* be the same. :)
00:43:03 <ski> (from the POV of `chk', `a' and `b' acts as if they were abstract data types, about which you only know what dminuoso said)
00:44:37 <ski> (and .. it's not possible for `chk' to *check* whether `a' and `b' are the same. you're not being given that option. in terms of implementation, that information might not be available by the time `chk' is called ("type erasure"))
00:44:42 <dminuoso> hxxxrz: Now it should be said, that there exist 2 trivial implementations of that function. If you look at the return type you could cheat, since values of Bool can simply be produced out of nothing.
00:44:53 * ski looks at hxxxrz
00:46:21 <dminuoso> hxxxrz: But that's clearly not what you should do, it would be a silly think to add arguments that are not needed. So usually you would assume that all functions and values *must* be used.
00:46:34 <dminuoso> For such homework/practice tasks I mean.
00:49:37 <hxxxrz> thank you very much!
00:50:30 <dminuoso> hxxxrz: So from the implementor perspective of chk, let's replace the type variables with some metavariables representing some concrete, but unknown type, then `chk f x y = ...` in which `f :: _A -> _B`, `x :: _A` and `y :: _B`, and you are required to produce something of type Bool. The only additional thing you can know, is that you can compare two values of type _B for equality.
00:51:47 <dminuoso> Now in this pack of things you have, is there any value of type Bool or a function that can produce a Bool?
00:51:54 <ski> (iow, you also know `Eq _B', and hence `(==),(/=) :: _B -> _B -> Bool', and similarly for other operations that rely on `Eq', e.g. `elem :: _B -> [_B] -> Bool' and `filter :: (_B -> Bool) -> [_B] -> [_B]')
01:03:00 <hxxxrz> still don't know what a function can `f` be. Is there a list of functions i can use for unknown 
01:03:13 <dminuoso> hxxxrz: You dont care, its not defined by you.
01:03:24 <dminuoso> hxxxrz: You are given a function `f :: _A -> B`
01:03:25 <ski> `f' is any function the caller decides to pass to you
01:03:36 <dminuoso> hxxxrz: Its the caller that will have to hand you one.
01:03:40 <ski> you don't know which function this is, but you can still, possibly, call it
01:03:55 <dminuoso> hxxxrz: You can however presume that it must exist and work.
01:06:21 <dminuoso> hxxxrz: If you must write a function `f :: Int -> Bool` you dont have to make up an Int. It will be given to you.
01:07:55 <ski> if you must write a function `g :: (Int -> Bool) -> Bool', you don't have to make up an `Int -> Bool'. it will be given to you
01:12:00 <hxxxrz> chk :: Eq b => (a -> b) -> a -> b -> Bool
01:12:04 <hxxxrz> chk f x y = f (x) == y
01:12:30 <dminuoso> hxxxrz: Have you typechecked that function and tried it?
01:12:35 <dminuoso> hxxxrz: Does it work?
01:12:57 <dminuoso> Also note that the parens around `x` are optional, so you'd rather write this as: chk f x y = f x == y
01:17:26 <hxxxrz> i assume it should work with numbers, like `chk * 2 3`
01:18:07 <hxxxrz> but it doesnt
01:18:08 <ski> that would have to be `chk (*) 2 3', in order to pass `(*)' as an argument to `chk' (rather than passing `chk' and `2 3' as left and right operands to `*')
01:18:41 <ski> but `(*)' wants two inputs, while the function argument that `chk' expects is only assumed to accept one
01:19:32 <ski> perhaps you could try to find an example where the first argument to `chk' is some other function. e.g. `length' or `not' or `(2 *)'
01:19:55 <hxxxrz> it works with chk (+5) 2 3
01:20:06 <ski> > let  double = (2 *)  in  double 3
01:20:09 <lambdabot>  6
01:22:19 <sicklorkin> join #icfp-contest
01:23:54 <lavalike> sicklorkin: good idea
01:24:16 <hxxxrz> thanks that was really important for understanding
01:39:01 <bollu> Does one *actually* need all that category theory to define a topos?
01:45:30 <janat08> So im suppose to be able to ask hoogle what takes MonadWidget and puts it into Fronted( R FrontendRoute) for reflex-frp
01:45:35 <janat08> ?
01:47:55 <fdsadf> I haskell in demand?
01:49:32 <merijn> fdsadf: Define in demand
01:51:15 <fdsadf> I mean, Are there good job opportunities if one learns Haskell?
01:51:45 <involans> definitely, in certain places. London is quite active
01:52:22 <merijn> Are there good job opportunities (in languages other than Haskell) where Haskell knowledge will help? Definitely. Are there Haskell jobs (where Haskell is obviously mandatory) also yes, but less so and not as well advertised.
01:52:46 <merijn> Should you learn Haskell regardless of job opportunities: Also definitely ;)
01:53:13 <dminuoso> Even if you dont end up writing programs in Haskell, Id argue that for many folks it broadens their horizon considerably.
01:53:19 <dminuoso> For me it changed how I think about code.
01:53:37 <dminuoso> It had a strong impact on all my non-Haskell code.
01:53:44 <merijn> That, yes
01:54:37 <kaol> If it doesn't make you bitter and frustrated about the tools they make you use instead of something you know to be better.
01:54:38 <merijn> fdsadf: I mean, there are certainly more Java/PHP/C# jobs than Haskell jobs, but there's also the matter of "what kind of job do you want?"
01:55:25 <fdsadf> Your comments motivate me to learn Haskell. Thanks a lot, starting now.
01:56:26 <ski> fdsadf : you're welcome to ask questions here, as you learn
01:56:34 <merijn> fdsadf: tbh, if you like programming, I think the most important reason is that (at least for me) programming became A LOT more fun with Haskell (although, I will admit there's a substantial learning curve before I actually got productive)
01:57:47 <dminuoso> fdsadf: Your milage may vary (tm).
02:01:24 <henrik_> fdsadf: learning functional programming also has benefits that aren't restricted to any particular language
02:04:54 <henrik_> ah, basically what dminuoso said :)
02:56:50 <Ferdirand> I'm struggling to understand how to use traversals to make a stateful traversal of a sum type
02:58:46 <Ferdirand> say I have a Tree (Either a b), where tree is Traversable, and two functions (a -> State s a') and (b -> State s b'), and I want to assemble them to get (Tree (Either a b) -> State s (Tree Either a' b'))
03:00:23 <Ferdirand> is it possible to express this with _Left and _Right ?
03:01:43 <Ferdirand> or is there some standard traversal-like function, that would look like (Functor f) => (a -> f a') -> (b -> f b') -> Either a b -> f (Either a' b') ?
03:05:25 <Taneb> :t bitraverse
03:05:26 <lambdabot> error:
03:05:26 <lambdabot>     • Variable not in scope: bitraverse
03:05:26 <lambdabot>     • Perhaps you meant one of these:
03:05:40 <Taneb> @let import Data.Bitraversable
03:05:41 <lambdabot>  Defined.
03:05:42 <Taneb> :t bitraverse
03:05:44 <lambdabot> (Applicative f, Bitraversable t) => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
03:06:03 <Taneb> Ferdirand: is that helpful? Either is Bitraversable
03:06:05 <Ferdirand> i have to admit, for a short moment i thought you were joking
03:06:12 <Ferdirand> apparently it exists
03:06:23 <Ferdirand> that sounds very relevant, thanks
03:06:39 <Taneb> :)
03:07:47 <Ferdirand> but maybe i should ignore that and go the generics way, which is a bit scary
03:08:57 <Ferdirand> i'm trying to transform an AST in a stateful way, possibly also including context
03:09:46 <Ferdirand> but I guess i can also use bitraverse in a recursive definition, hmmm
03:18:47 <libertyprime> hey guys. any way to search for functions by type?
03:19:08 <ski> @hoogle Int -> [a] -> [a]
03:19:08 <lambdabot> Prelude take :: Int -> [a] -> [a]
03:19:09 <lambdabot> Prelude drop :: Int -> [a] -> [a]
03:19:09 <lambdabot> Data.List take :: Int -> [a] -> [a]
03:19:22 <ski> @where hoogle
03:19:22 <lambdabot> http://haskell.org/hoogle http://hoogle.haskell.org http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
03:19:30 <libertyprime> thats cool. cheers
03:19:39 <libertyprime> any way to do this on my local machine with hoogle?
03:20:38 <ski> hm, i think it's possible to access a local lambdabot in GHCi ?
03:20:45 <lavalike> if people don't know, this just started: https://icfpcontest2019.github.io
03:21:01 <lavalike> go and make haskell proud (:
03:22:02 <__monty__> You can install and run hoogle locally, libertyprime. Nix makes this a breeze if you're already using it.
03:22:21 <libertyprime> @hoogle [Milf]
03:22:22 <lambdabot> Data.List.Unicode ? :: [a]
03:22:22 <lambdabot> Data.String.Unicode ? :: [a]
03:22:22 <lambdabot> Prelude.Unicode ? :: [a]
03:22:31 <libertyprime> Just don't want to be searching for dodgy types publicly
03:22:51 <ski> you can also talk to lambdabot in private ..
03:23:11 <libertyprime> oh, that's awesome! ofc lol
03:31:14 <Phyx->  /win 1
03:57:19 <rackbot> Hello, world!
03:57:34 <libertyprime> that was me sorry
03:57:46 <libertyprime> building a bot to talk to the bot
03:59:29 <__monty__> libertyprime: #bottest is more suitable.
04:00:22 <libertyprime> thanks
04:25:55 <pronik> Does anyone use emacs with lsp-mode/lsp-haskell and haskell-ide-engine in Stack projects? Do you have any pointers on how to make HIE/ghc-mod use ghc-options from stack.yaml? In particular, I want to see -Wunused-imports in Emacs. `stack build` shows them, but apparently they are not output by HIE.
05:23:54 <AWizzArd> Is there an advantage of /not/ having ExplicitForAll activated per default? If yes, what is the advantage?
05:24:15 <AWizzArd> This is how it currently is. ExplicitForAll is not activated per default.
05:24:19 <geekosaur> mostly that "forall" becomes a valid binding name (function / varible)
05:25:11 <geekosaur> it's disabled by default because there may be existing code using it as a binding
05:26:03 <geekosaur> note that there's a lot of haskell code that is not on hackage; it's used internally by facebook, standard chartered, possibly morgan stanley given the one piece of haskell code they did release, etc.
05:26:55 <geekosaur> ghc dev team knows the code exists and informs the ones they know about of early access to release candidates so they can check for regressions / incompatibilities
05:33:20 <merijn> geekosaur: Target uses Haskell, I was contacted by another big bank in London for a new Haskell team they were starting (forget the name)
05:33:31 <merijn> Nowadays there's IOHK too, of course
05:34:36 <merijn> More relevantly, regardless of if ExplicitForAll breaks code, it is theoretically possible for it to do so, so is the benefit of having it on by default worth potentially breaking code
05:35:04 <int-e> Yeah most of the time the ghc developers and Haskell community are very conservative when it comes to breaking code.
05:35:04 <merijn> AWizzArd: And even more importantly GHC tries to adhere to Haskell2010 by default (tries, because there are several known/documented divergences)
05:35:06 <geekosaur> ^ is bascally the problem
05:35:21 <merijn> AWizzArd: And ExplicitForAll is simply not Haskell2010
05:35:32 <merijn> and tbh, I don't see many reasons it should be on by default
05:35:48 <int-e> With some notable exceptions... the MonadError/Either change was horrible, and the Applicative-Monad-Proposal was also pretty bad. (The former was worse because it broke code silently.)
05:36:38 <geekosaur> of course, there's a modern thing that breakage is good. I've run into ti in places where it really doesn't belong
05:37:06 <geekosaur> because there are some uses where breakage is never good and silent breakage is a lawsuit looking for a chance to happen
05:37:17 <int-e> Breaking code is okay-ish... (it's still annoying when it turns out that you rely on a broken package whose maintainer is unresponsive...). Breaking code silently is just evil.
05:38:58 <__monty__> MonadFail's another ongoing example.
05:39:41 <geekosaur> semigroup has had its moments too
05:40:14 <geekosaur> the Num one still bites people occasionally, especially newcomers since a lot of tutorials assume the old behavior
05:48:36 <merijn> geekosaur: Which Num one?
05:54:52 <geekosaur> merijn, Eq and Show no longer being prerequisites / "superclasses"
05:55:10 <geekosaur> a decent amount of H98 and H2010 code assumes they are
05:55:21 <lordcirth_> Oh, so that "deriving Num" no longer automatically derives them?
05:55:43 <geekosaur> including code that relies on the hack for pattern matching (foo 1 = ...; foo ... = ...)
05:56:04 <lordcirth_> How is that a hack? Because it requires Eq?
05:56:09 <geekosaur> yes,
05:56:11 <merijn> geekosaur: "no longer" <- has GHC ever required that?
05:56:21 <geekosaur> foo 'c' = .. is a constructor match, doesn't need Eq
05:56:36 <geekosaur> foo 1 = ... desugars to a guard using (==)
05:56:38 <merijn> I mean, it didn't require Eq as a Num superclass when I learned haskell and that was like 12 years ago
05:56:44 <merijn> geekosaur: Bad example :)
05:56:49 <lordcirth_> geekosaur, interesting, didn't know that
05:57:05 <ski> `deriving' never automatically derived classes you didn't ask for
05:57:12 <geekosaur> this is not about deriving
05:57:24 <merijn> ski: According to the report Eq is a superclass of Num
05:57:28 <merijn> ski: In GHC it is not
05:57:29 <geekosaur> ^
05:57:34 <ski> (that was in response to lordcirth_)
05:57:43 <geekosaur> yes
05:57:43 <ski> merijn,geekosaur : i'm well aware
05:57:49 <lordcirth_> I see, I must be misremembering
06:15:52 <AWizzArd> merijn: I realize that there is an external force, namely the Haskell 2010 standard, which prevents ghc from turning ExplicitForAll on by default.
06:16:19 <AWizzArd> Perhaps a future standard will try to avoid success at all costs and just make an incompatible change by activating certain extensions.
06:23:50 <sm> morning all. First public release of https://testnet.iohkdev.io/cardano/shelley out today (decentralised version of cardano)
06:24:27 <sm> I see they switched to rust
06:27:48 <geekosaur> AWizzArd, "avoid..." is dead
06:28:32 <geekosaur> and changes are driven by perceived need. considering the incompatible changes that have already happened, forall by default doesn't appear to have much of an itch driving it
06:38:57 <merijn> AWizzArd: Which problem would enabling it solve?
06:39:07 <merijn> AWizzArd: Like...I've never needed ExplicitForAll
07:20:57 <dmwit> merijn: I expect it mostly exists as a dependency extension. Like, STV and one of AAT or TA probably turn it on.
07:21:25 <merijn> dmwit: Sure, I know that
07:21:44 <dmwit> o
07:21:53 <merijn> dmwit: But if it's never useful on its own, then what purpose does turning it on by default have?
07:31:27 <dmwit> I think I was indirectly claiming it wasn't very useful on its own.
07:31:43 <dmwit> No, scratch that. I *definitely* was indirectly claiming it isn't very useful on its own.
08:06:19 <m__> A task from one of the former exams:
08:06:24 <m__> Consider the following definitions:
08:06:31 <m__> graf f xs = [(x, f x) | x <- xs]
08:06:36 <m__> s y = fst . head . filter ((== y) . snd) . graf f . from
08:06:45 <m__> What is the type of the function s?
08:06:58 <m__> I'm perplexed by this `from` here
08:07:08 <m__> AFAIK there is no `from` in Prelude?
08:07:48 <hyperisco> :t from
08:07:49 <lambdabot> (Functor f, Profunctor p) => AnIso s t a b -> p t (f s) -> p b (f a)
08:07:55 <hyperisco> probably not that
08:08:40 <ski> m__ : hur är `f' definierad ?
08:09:00 <m__> ski: ???? I can't understand a word ;/
08:09:06 <m__> Lemme use Google Translate ;/
08:09:17 <ski> sorry, i thought you might be a scandinavian :)
08:09:24 <ski> m__ : how is `f' defined ?
08:09:27 <Rembane> Good test. :)
08:09:43 <m__> ski: I'm Polish
08:09:49 <ski> ah, okay
08:10:01 <m__> f is defined indeed but below
08:10:22 <ski> you would need to know about the type of `f', to figure out the type of `s'
08:10:23 <m__> (so AFAIK the definition of f doesnt count when s is considered? or am i wrong?)
08:10:51 <m__> Anyway I think Ill post all definitions, in order as they appear in the task
08:11:00 <hyperisco> it takes the fst of the tuple, and f is just involved in the snd, so I don't think it actually matters
08:11:25 <ski> and presumably you have a definition of `from' somewhere as well ?
08:11:33 <ski> perhaps in an earlier problem on the exam ?
08:12:03 <ski> hyperisco : yes, but `y'
08:12:13 <m__> http://ideone.com/HIQldi
08:12:20 <hyperisco> yes
08:12:25 <m__> ski: No definition of from
08:12:48 <ski> ok `f' is the fibonacci function
08:12:51 <m__> f is defined, **below** s
08:13:01 <ski> (i saw it)
08:14:18 <m__> ah Im sorry I just tested my assumption that the definition of f is not visible above the line of the definition
08:14:24 <ski> perhaps `from' does the same as `enumFrom', possibly just for `Integer' ?
08:14:24 <m__> The assumption was wrong
08:14:30 <hyperisco> definition order does not matter
08:14:49 <m__> https://hoogle.haskell.org/?hoogle=from&scope=set%3Astackage
08:14:56 <ski> oh, is `from' the same as `n' ?
08:15:18 <ski> that could be an incomplete rename refactoring
08:15:42 <m__> Hoogle shows there is indeed a `from` in the base package
08:15:43 <m__> from :: Generic a => a -> Rep a x
08:16:06 <m__> But I don't remember anything about Generic from the course!!
08:16:16 <ski> i very much doubt that's the `from' that's used in that paste
08:16:20 <m__> (might've been in one of these lectures I skipped)
08:16:56 <ski> m__ : have you checked whether there's any exam errata available ?
08:17:43 <m__> I cant see any such thing 
08:17:58 <ski> m__ : is there any other problem (or part of problem) which asks about `n' there ?
08:18:10 <ski> (or mentions it at all)
08:18:34 <ski> m__ : it seems very likely to me that that `from' should really be `n'
08:18:55 <Taneb> m__: I'd ask the person who set the exam
08:19:31 <m__> ski: I'm looking for it but I can't see any mention of `n`
08:19:50 <m__> Perhaps you're right
08:20:38 <m__> Thank you
08:24:33 <ski> m__ : np
08:37:47 <d34df00d> Is there anything ready-to-use if I want to consume Data.Tree in a top-down fashion?
08:37:52 <d34df00d> foldTree looks to do this bottom-up.
08:38:11 <d34df00d> I can kinda express the former via the latter, but that's probably ugly and not that performant.
08:38:51 <lavalike> :t sum . levels
08:38:52 <lambdabot> Num [a] => Tree a -> [a]
08:39:15 <lavalike> :t join . levels
08:39:16 <lambdabot> Tree a -> [a]
08:39:32 <d34df00d> The problem I'm having at hand is that I have a tree of some entities and a predicate over the entities, and I want to extract all topmost subroots for which the predicate does not hold.
08:39:40 <d34df00d> All while preserving the tree structure.
08:40:07 <d34df00d> It's easy to write recursion by hands, of course, but I"ve heard manual recursion is the goto of FP.
08:40:38 <lavalike> :t traverse
08:40:40 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
08:40:49 <lavalike> must be a way to shove something into this (:
08:40:59 <d34df00d> Hmm, I haven't thought about traverse at all.
08:41:03 <d34df00d> Thanks  for the hint!
08:41:07 <lavalike> sure!
08:44:22 <d34df00d> Hmm, interesting.
08:44:23 <d34df00d> λ> :t traverse @Tree @[] @Entity @Entity
08:44:23 <d34df00d> traverse @Tree @[] @Entity @Entity :: (Entity -> [Entity]) -> Tree Entity -> [Tree Entity]
08:44:28 <d34df00d> Wonder what's the function shall be like.
08:49:17 <catern> If I have a value : A x => x -> y, can I pass it as an argument to something expecting a value : (A x, B x) => x -> y?
08:57:40 <kuribas> d34df00d: there's a library treetraversals
08:58:05 <kuribas> d34df00d: http://hackage.haskell.org/package/tree-traversals-0.1.0.0/docs/Data-Traversable-TreeLike.html
09:01:27 <d34df00d> kuribas: oh, that looks like a great library! Thanks!
09:06:20 <ski> > let foo :: (forall a. (Eq a,Show a) => a -> String) -> String; foo f = f "foo" in foo show  -- catern, seems so ?
09:06:23 <lambdabot>  "\"foo\""
09:07:36 <catern> ski: neat
09:08:02 <catern> so what's the proper term for that behavior? I'd call it subtyping but maybe there's a more precise term in Haskell
09:08:06 <NemesisD> does anyone use ghcid with cabal new-* commands? i don't see how its possible to set up ghcid to run tests after the library is changed
09:08:16 <NemesisD> since cabal new-repl doesn't support multiple targets
09:10:57 <ski> > let foo :: ((forall a. [a] -> [a]) -> String) -> String; foo f = f reverse in foo ($ "")
09:10:59 <lambdabot>  ""
09:11:46 <ski> > let foo :: ((((forall a. [a] -> [a]) -> String) -> String) -> String) -> String; foo f = f ($ reverse) in foo ($ ($ ""))
09:11:48 <lambdabot>  error:
09:11:48 <lambdabot>      • Couldn't match type ‘[a0] -> [a0]’ with ‘forall a. [a] -> [a]’
09:11:48 <lambdabot>        Expected type: ((forall a. [a] -> [a]) -> String) -> String
09:13:14 <ski> > let foo :: ((forall a. [a] -> [a]) -> String) -> String; foo = ($ reverse) in foo ($ "")  -- oh, even
09:13:16 <lambdabot>  error:
09:13:16 <lambdabot>      • Couldn't match type ‘[a0] -> [a0]’ with ‘forall a. [a] -> [a]’
09:13:16 <lambdabot>        Expected type: ((forall a. [a] -> [a]) -> String) -> String
09:15:11 <c_wraith> catern, it's a higher-rank type.
09:16:07 <c_wraith> catern, (which is entirely different from a higher-kinded type. similar names, unrelated features)
09:16:55 <catern> sure, I know it is, I'm referring to the fact that there's a subtyping relationship between values of two different types
09:17:13 <catern> oops do I know it is?
09:17:55 * ski wouldn't call it subtyping
09:17:57 <catern> er, yes, I think I still maintain that my question is unrelated to the fact that it's a higher-rank type
09:18:29 <catern> ski: that's why I'm asking what to call it :) it's a value of one type, usable as a value of a different type, so what is it?
09:18:57 <ski> you could say it's related to specialization of polymorphism. in this case constrained polymorphism
09:19:58 <d34df00d> I wish Data.IntMap and IntSet were expressed in terms of any type t that's Coercible t Int.
09:20:13 <d34df00d> I have a bunch of newtypes around ints for type safety, and having to unpack/repack is a pain.
09:20:43 <d34df00d> I wonder if this could be proposed as a change or something if the community deems it reasonable...
09:24:13 <catern> ski: it's definitely related, but you could have typeclass-based polymorphism without having this relationship where a "A x => x -> y" is a valid "(A x, B x) => x -> y", right?
09:26:04 <titusg> Hi, how do I get System.Process to evaluate bash vars? `readProcess "echo" ["$0"] "" >>= putStr' prints '$0'
09:26:51 <ski> catern : i wonder whether turning of higher-rank changes things
09:26:59 <ski> s/of/off/
09:37:48 <geekosaur> titusg, if yo uuse that api you are calling exec, not bash
09:37:54 <geekosaur> unless you explicitly route it through bash
09:38:07 <geekosaur> if you pass a single string, you are asking for the shell to split and expand it
09:45:23 <alx741> titusg: but you should be reading env vars... https://www.stackage.org/haddock/lts-13.19/base-4.12.0.0/System-Environment.html
09:51:04 <geekosaur> "my convenience is far more important that security" y'know
09:51:10 <geekosaur> *than
09:53:47 <titusg> alx741: Thanks :)
10:11:00 <geekosaur> $0 isn't an envar anyway, it's a local bash variable
10:12:26 <geekosaur> if you want the haskell program's name, it's https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.12.0.0/System-Environment.html#v:getProgName
10:20:16 <nyxgear>  /UNIGNORE _guios
10:31:54 <statusfailed> I have a cabal file with a "test" project and a "library" project
10:32:02 <statusfailed> how do I make `cabal new-repl` reload both of them on :r ?
10:32:08 <statusfailed> right now it only reloads the test project
10:32:10 <statusfailed> which is useless :D
10:56:23 <cocreature> statusfailed: you can’t, you have to write your own .ghci file and invoke ghci directly if you want to load multiple components simultaneously
10:58:01 <cocreature> that’s one of the few cases where ghc environment files are actually convenient since they make it easy to get the right packages in scope
10:58:15 <cocreature> so your .ghci file only has to take care of include paths, default extensions and GHC flags
11:02:12 <Boarders> what is the best way to add a key value pair to a map, is it: map <> singleton key val 
11:03:12 <lavalike> Boarders: there are a bunch of variations on:
11:03:15 <lavalike> :t M.insert
11:03:16 <lambdabot> Ord k => k -> a -> M.Map k a -> M.Map k a
11:03:48 <Boarders> oh ok
11:03:50 <Boarders> thanks
11:04:02 <Boarders> I am sleepy and I managed to miss them on the page 0_o
11:04:40 <lavalike> np
11:05:34 <lavalike> Boarders: also be sure to check the note at the very top of the Data.Map doc page too about Data.Map.Strict
11:06:23 <Boarders> thanks
11:17:37 <statusfailed> cocreature: thanks! will try that
11:18:03 <ruffy_> Can anybody explain me why this works "f a b = uncurry (==) $ curry (over both (dropWhile (/='_') . fst)) a b" and this not "f = uncurry (==) . curry (over both (dropWhile (/='_') . fst))"?
11:19:29 <lavalike> f a = uncurry (==) . (curry (..)) a  then  f = (uncurry (==) .) . (curry (..))
11:20:08 <lavalike> sorry "$ a" in the first one not just "a"
11:21:51 <gobby> I'm using beam-sql and sometimes I get an error from Sqlite3 that I'd like to catch, what's the best practice way of doing this?
11:22:09 <ruffy_> lavalike: why do I need this?
11:22:29 <gobby> I'd basically like to catch the exception inside a custom data type
11:23:39 <lavalike> @pl f a b = g (h a b)
11:23:39 <lambdabot> f = (g .) . h
11:23:46 <lavalike> @unpl \a b -> (g . h) a b
11:23:46 <lambdabot> (\ x -> g (h x))
11:24:07 <lavalike> which is: \a b -> g (h a) b
11:24:18 <lavalike> instead of the wanted: g (h a b)
11:25:01 <ruffy_> lavalike: thanks for the explanation :D
11:25:05 <lavalike> my pleasure!
11:31:21 <myme> Is there a `FilePath -> IO FilePath` (or similar) resolving UNIX-y things like "~"?
11:32:25 <myme> I'm actually using turtle, but:
11:32:26 <tabaqui> ah, how I hate List Monad
11:32:27 <myme> λ: realpath "~"
11:32:29 <myme> *** Exception: ~: canonicalizePath: does not exist (No such file or directory)
11:32:56 <tabaqui> it is so different from other monads
11:33:33 <tabaqui> and transformers on top of List is even worse
11:33:42 <tabaqui> *are
11:35:12 <isovector1> adamCS: are you adamConnerSax?
11:38:47 <cocreature> % readCreateProcess (shell "eval echo ~") ""
11:38:56 <Geekingfrog> I have trouble articulating why the following is bad: `instance (Monoid m) => Monoid (Either m m) where ...` I'm not sure how the instance selection would work there. For me it seems the two type parameters should be independant.
11:38:57 <yahb> cocreature: ; <interactive>:1:1: error: Variable not in scope: readCreateProcess :: t0 -> [Char] -> t; <interactive>:1:20: error: Variable not in scope: shell :: [Char] -> t0
11:39:11 <cocreature> % import System.Process
11:39:11 <yahb> cocreature: 
11:39:13 <cocreature> % readCreateProcess (shell "eval echo ~") ""
11:39:13 <yahb> cocreature: "/var/lib/xsbot/sandbox/root/data/\n"
11:39:20 <cocreature> ^ myme something like that maybe?
11:39:46 <tabaqui> Geekingfrog: GHC resolve right parts at first
11:39:47 <cocreature> ofc don’t use that on untrusted input
11:40:03 <myme> cocreature: :D
11:40:14 <tabaqui> if you define Monoid (Either m n) then GHC will try to resolve this instance for ALL Eithers
11:41:02 <tabaqui> so you cannot just "instance (ClassFoo a) => Monad a"
11:41:20 <tabaqui> because ANY (* -> *) will become a instance of Monad class
11:41:34 <myme> cocreature: If spawning a process is the best option, then I guess "realpath -m ~/foo/bar" is better?
11:41:38 <myme> *safer
11:42:26 <myme> And of course, no need for System.Process as turtle has process invocation baked in. But thanks for your suggestion.
11:42:30 <cocreature> I guess depending on what you want even an "echo ~/foo/bar" will do the trick
11:42:46 <Geekingfrog> tabaqui, so that means that with this instance definition, it override the other Monoid instance from Data.Either ?
11:43:06 <myme> cocreature: Basically resolving paths on the command line, for a cli utility. So obvious untrusted input.
11:43:09 <cocreature> if you really only want to replace ~ you could also just do a splitPath + replace + joinPath or something like that
11:43:09 <tabaqui> Geekingfrog: yeah
11:43:20 <myme> Even though I'd expect to be the only user :p
11:43:35 <Geekingfrog> Even for things with different types parameters? Like Either Int String ?
11:43:38 <tabaqui> Geekingfrog: not actually, I don't see Monoid instance in Data.Either
11:44:38 <tabaqui> but, f.e., let's take a Show class
11:44:51 <tabaqui> % instance Show (Either Int Char) where show _ = "hello"
11:44:51 <yahb> tabaqui: ; <interactive>:4:10: error:; * Overlapping instances for Show (Either Int Char) arising from a use of `GHC.Show.$dmshowsPrec'; Matching instances:; instance (Show a, Show b) => Show (Either a b) -- Defined in `Data.Either'; instance Show (Either Int Char) -- Defined at <interactive>:4:10; * In the expression: GHC.Show.$dmshowsPrec @(Either Int Char); In an equation fo
11:44:53 <myme> cocreature: Yup, different kinds of parsing is another option. But then you're basically having to redo (badly) what's been done many times elsewhere. I guess ~ is only valid as a path prefix though.
11:45:22 <myme> "~" is also a valid filename, afaik.
11:45:29 <tabaqui> but you can use OVERLAPPING pragmas, but it is a bad practice
11:45:35 <merijn> myme: ~ isn't just valid as prefix
11:46:00 <tabaqui> % instance {-# OVERLAPPING #-} Show (Either Int Char) where show _ = "hello"
11:46:00 <yahb> tabaqui: 
11:46:12 <tabaqui> % show (Left 1 :: Either Int Char)
11:46:12 <yahb> tabaqui: "hello"
11:46:16 <tabaqui> % show (Left 1 :: Either Int Int)
11:46:16 <yahb> tabaqui: "Left 1"
11:47:04 <myme> merijn: But the it's no longer referring to $HOME, right? Or do you have an example where it'll be expanded to $HOME in a shell?
11:47:06 <Geekingfrog> So I guess you want to avoid that because the two type parameters should be independant ?
11:47:48 <merijn> myme: I guess you're right about only expanding as a prefix, but then you also have tricky business like ~foo expanding to the home dir of user foo
11:47:57 <merijn> myme: Anyway, I missed the context...
11:48:00 <tabaqui> Geekingfrog: consider using newtypes in Sum, Product, Last, First... style
11:48:01 <myme> Yup, I was gonna say. But ignoring that for now.
11:48:04 <tabaqui> it is really powerfull
11:48:47 <myme> cocreature: merijn: I'm basically looking for a pure-Haskell equivalent of https://devdocs.io/python~3.7/library/pathlib#pathlib.Path.expanduser
11:48:48 <tabaqui> Geekingfrog: no, GHC starts from right parts, then it tries to match types using declarations
11:48:49 <Geekingfrog> tabaqui, yes, I know. But here I'm reviewing something for mentoring purpose and I have some trouble putting into word why you shouldn't do that.
11:48:58 <merijn> myme: That already exists
11:48:58 <myme> Python's pathlib Path.expanduser.
11:49:06 <tabaqui> like "Either a b" is more generic than "Either Int b"
11:49:24 <tabaqui> if you declared overlapping "Either Int b" then ghc will prefer it
11:49:31 <merijn> Either in directory or filepath
11:49:54 <myme> merijn: I've only seen things which *return* user home. I might be missing something though.
11:50:00 <tabaqui> Geekingfrog: oh, it is bad because it is very confusing
11:50:02 <cocreature> merijn: you sure? I don’t think I’ve seen that
11:50:26 <merijn> hmm, wait, yeah, looks like I might be mistaken...
11:51:09 <tabaqui> Geekingfrog: back to overlapping: usually you have no overlapping instance declarations, so any specific case will match no more than one pattern
11:51:21 <myme> Shell-out is a cop-out, but I guess ctrl-Ectrl-Eit's my best option
11:51:25 <tabaqui> after that GHC will check constraints on the left side
11:51:41 <myme> Uhm, wat.. That got some weird keys in there.
11:52:09 <cocreature> myme: I think wordexp is the C call that you could use, I’m sure there are some bindings to that already
11:52:09 <myme> cocreature: merijn: Thanks for your input though. Appreciated.
11:52:21 <cocreature> myme: https://hackage.haskell.org/package/wordexp
11:53:57 <myme> Nice! That might be a smooth option.
11:57:26 <tabaqui> https://stackoverflow.com/questions/22892095/combining-state-and-list-monads
11:57:49 <tabaqui> what is happening here? why (+a) doesn't iterate over the [1..10]?
11:57:55 <cocreature> myme: although reading the manpage that does look like it also does command substitution so if you are worried about an attack surface here that’s probably a bad idea
11:58:27 <merijn> cocreature: You can disable that
11:58:31 <merijn> cocreature: At least, in C
11:58:52 <cocreature> merijn: oh good point
12:01:11 <tabaqui> oh, StateT + List doesn't keep intermediate state
12:01:31 <myme> https://hackage.haskell.org/package/wordexp-0.2.2/docs/System-Wordexp.html#v:nosubst I suppose
12:02:11 <myme> cocreature: Not overly worried, although I prefer to not load the gun and point it at my feet if I can avoid it.
12:03:07 <myme> https://pastebin.com/KzAiFEZM
12:03:26 <myme> I think I have a winner. Thanks a bunch.
12:23:04 <d34df00d> Let's say I have type SqlMonad m = (MonadReader SqlEnv m, MonadIO m)
12:23:31 <d34df00d> And I'm trying to write a `class SqlMonad sm => PgRunnable pm sm where runPg' :: pm a -> sm a`
12:24:13 <d34df00d> I'm having two instances right now, `instance SqlMonad sm => PgRunnable Pg sm` and `instance SqlMonad sm => PgRunnable (ReaderT SqlEnv Pg) sm`
12:24:57 <d34df00d> But, for a given act :: SqlMonad m => m (), the expression `runPg' act` is ambiguous, so I have to give an explicit type application like `runPg' @(ReaderT SqlEnv Pg) act`
12:25:07 <d34df00d> Is there a way to avoid this, perhaps redesigning the whole approach?
12:26:20 <d34df00d> What I basically want to do is to avoid manual "unlifting" of Pg through any MonadReader. Otherwise, since the underlying runPg (without the tick) function is accepting the monomorphic Pg monad, I have to do something like ask >>= \env -> runPg act env, which I want to encapsulate.
12:26:31 <d34df00d> Pardon me if this all sounds clumsy.
12:27:45 <zachk> couldnt you fmap (runPg act) ask ? 
12:28:55 <d34df00d> Nope, runPg act itself isn't well-typed.
12:29:02 <d34df00d> For the types of acts that I'm interested in.
12:29:45 <d34df00d> Right now my code does `env <- ask; runPg $ runReaderT act env`, which is I guess about the most concise I could get.
12:30:41 <d34df00d> So I have to basically execute the Reader part of my action to get down to Pg, which I then feed to runPg and kinda repack it back.
12:56:21 <Synthetica> I'm looking for an example of a type that implements Traversable and isn't a "simple container". Does such a thing exist?
12:57:52 <ski> what's a "simple container" ?
12:59:19 <Synthetica> Things like lists and such. 
12:59:47 <ski> as opposed to ? "complex containers" ?
12:59:52 <statusfailed> Synthetica: what characteristics do a type need to have for you to say it's not a "simple container"?
13:00:14 <stilgart>  is Data.Trie simple ?
13:00:57 <Synthetica> stilgart: I don't think it is, I'll have a look :)
13:01:11 <dmwit> Are functions simple containers? http://hackage.haskell.org/package/universe-reverse-instances-1.1/docs/Data-Universe-Instances-Traversable.html
13:01:45 <statusfailed> neato
13:01:57 <dmwit> See also: https://stackoverflow.com/q/32812400/791604
13:02:00 <Synthetica> statusfailed: I stumbled upon a hole of type `[f a] -> f [a]`, which is perfectly filled by sequenceA. I'm now exploring what exactly the ramifications of that are, but I wasn't sure where to start looking
13:02:22 <stilgart> dmwit: nice one
13:02:26 <ski> (.. now i'm wondering whether the kind of associated types ought to indicate which type class they're associated to)
13:03:07 <dmwit> Associated type families are kind of funny.
13:03:18 <dmwit> It's just a syntactic restriction, really, not a semantic one, that they be defined in classes.
13:03:32 <Synthetica> Sorry, other way around, `f [a] -> [f a]`
13:03:38 <dmwit> There's no real difference between `type family Foo a; class Bar a` and `class Bar a where type Foo a`.
13:04:07 <dmwit> Synthetica: Whoa. Are you sure sequenceA does what you want there?
13:04:16 <dmwit> (What *do* you want?)
13:04:41 <Synthetica> dmwit: I'm pretty sure? I'm writing a generalisation of `algebraic-graphs`, and it came up pretty naturally
13:05:09 <Synthetica> dmwit: `edgeSet (Connect xs) = (Set.unions $ edgeSet <$> xs) <> (Set.fromList $ _ $ vertexList <$> xs)`, if you are familiar with `algebraic-graphs`
13:05:25 <ski> dmwit : oh, "normal" is interesting. ty
13:05:29 <Synthetica> With `_` being filled by `sequenceA`
13:06:03 <Synthetica> And I checked that it worked correctly for two-element pairs (regular graphs),  and for non-empty lists (hypergraphs)
13:06:11 <dmwit> I'm not familiar with algebraic-graphs. But if you're happy with sequenceA I'm happy with sequenceA.
13:06:31 <ski> (.. oh, and of course all (or "all") types defined in terms of associated types, as well)
13:06:32 <dmwit> Also, by the way, `sequenceA (f <$> v)` is better spelled `traverse f v`.
13:07:07 <Synthetica> dmwit: Oh, yeah, thanks :)
13:10:12 <dmwit> ski: What kind should `type TwoFamilies a = (Foo a, Bar a)` get tagged with? Both of Foo's class and Bar's class?
13:10:39 <dmwit> ski: What about `type Hm a b = (Foo a, Bar b, Baz a b)`?
13:11:05 <dmwit> ski: (Not disagreeing. Just trying to think of edge cases that might inform the design of such a feature.)
13:12:07 <dmwit> (Just to be clear: I'm imagining that Foo, Bar, and Baz are families, each associated with a different class.)
13:12:15 <dmwit> I guess MPTCs may make an interesting appearance, too.
13:15:02 <adamCS> isovector1: yes
13:15:03 <ski>   TwoFamilies :: (a :: K) -> (FooC a,BarC a) => *  -- ?
13:15:43 <ski> er, not `*', but `Constraint'
13:16:02 <ski> (i recall thinking about `Ord :: (a :: *) -> Eq a => Constraint', before)
13:17:13 <ski> oh .. actually, it should be `*' in the `TwoFamilies' case, since `Foo a' and `Bar a' were types
13:17:17 * ski is a bit tired atm
13:17:51 <ski> (one might perhaps also write these as `TwoFamilies :: {a :: K | FooC a,BarC a} -> *' and `Ord :: {a :: * | Eq a} -> Constraint')
13:18:19 <dmwit> Ah, clever.
13:18:22 <ski> (so, these follow the "presupposition" view of superclasses, and, in this case, associated types)
13:18:42 <dmwit> class Foo where type Bar; :k Bar?
13:19:07 <ski> (iow, rather than having `Ord a' entail `Eq', under this view `Ord a' isn't well-formed, unless we already know `Eq a')
13:19:27 <dmwit> (I guess `Bar :: Foo => *`.)
13:19:29 <dmwit> (Okay.)
13:19:39 <ski>   Bar :: Foo => *
13:20:08 <dmwit> Okay, trickier one.
13:20:16 <dmwit> class Foo a b where type Bar a
13:22:31 <dmwit> But then, maybe MPTCs and type families shouldn't be mixed in the first place. =P
13:24:39 <geekosaur> ?
13:25:06 <dmwit> .
13:28:34 <ski> dmwit : hm, i was checking the manual. it seems that you can't make *conflicting* family instances for `Bar' there
13:29:03 <geekosaur> right, thta's the intended replacement for fundeps
13:29:13 <geekosaur> so has similar constraints
13:29:42 <geekosaur> expressed as the equations once collected may not conflict with each other
13:29:42 <ski> dmwit : so i suppose `Bar :: {a :: K0 | exists (b :: K1). Foo a b} -> *', maybe ?
13:30:18 <ski> geekosaur : i was actually surprised it was allowed without an FD on the class
13:31:40 <geekosaur> ski, go look at type families in general. it made sense to me, in terms of their being type functions that must be total
13:31:50 <geekosaur> or at least not self-contradictory
13:32:08 <geekosaur> don't think they have to be actually total
13:32:47 <ski> yea .. i'm not so happy about the nontotality
13:33:51 <ski> (i would have expected the parameters of an associated type to be a candidate key for the type class)
13:34:02 <geekosaur> but you can't have type instance f T1 T2 = two different things at once, which extends to associated types providing the T_n-s
13:42:33 <dmwit> ski: Oh, that restriction makes a ton of sense now that I know it exists.
13:50:49 <ski> dmwit : which restriction ?
14:05:39 <dmwit> ski: No conflicting family instances.
14:17:47 <ski> oh, ok
14:43:03 <Boarders> does anyone know if there is any sort of function like foldM but does a fold on a map with key
14:43:11 <Boarders> so a monadic foldWithKey?
14:45:59 <Boarders> oh Data.Key has foldrWithKeyM 
14:57:35 <solonarv> Boarders: you can always hack it up using traverseWithKey and choosing (Const m) as the applicative
14:57:45 <Boarders> oh nice thought
14:58:12 <solonarv> foldMapWithKey f = getConst . foldMapWithKey (\k v -> Const (f k v))
14:58:33 <solonarv> err, traverseWithKey in RHS of course
14:59:14 <Boarders> yeah :)
14:59:31 <Boarders> everything is traverse as usual
14:59:55 <solonarv> yeah traversals are all over the place :D
15:02:03 <int-e> @hoogle Kleisli
15:02:04 <lambdabot> Control.Arrow newtype Kleisli m a b
15:02:04 <lambdabot> Control.Arrow Kleisli :: (a -> m b) -> Kleisli m a b
15:02:04 <lambdabot> Rebase.Prelude newtype Kleisli (m :: Type -> Type) a b
15:03:53 <solonarv> newtype Kleisly m a b = Kleisli { runKleisli :: a -> m b } -- the definition
15:03:58 <solonarv> s/y/i
15:05:24 <int-e> There should be some newtype that provides a  (Monoid a, Monad m) => Monoid (m a)  instance, which would also solve Boarders' problem (who left...).
15:05:42 <monochrom> Proposal!  LANGUAGE extensions should be case insensitive!  Because I'm tired of remembering whether it's MultwayIf or MultiWayIf!
15:05:51 <int-e> I wonder what it would be called (the Kleisli thing was a misfiring synapse, of course.)
15:06:28 <solonarv> int-e: there is!
15:06:31 <solonarv> Data.Monoid.Ap
15:06:42 <solonarv> (and it actually only needs Applicative, not Monad)
15:06:51 <int-e> as it should
15:07:09 <solonarv> it's fairly new though, got added in base 4.11 or 4.12 IIRC
15:08:47 <int-e> solonarv: I'm wondering mainly because I'm not sure whether using Const with traverseWithKey will still build a new Map (just to discard it afterwards).
15:09:35 <solonarv> it will not - how could it?
15:09:51 <solonarv> your traversing function doesn't give back any value that could be used to build a new Map
15:10:27 <int-e> It might still go through the motions: liftA3 (flip (Bin s k)) (go l) (f k v) (go r) ... oh well it will be inlined, so yeah everything should work out.
15:10:31 <solonarv> now if you were using ((,) m) as the applicative to traverse with, you would have that problem
15:11:47 <int-e> But Data.Monoid.Ap feels better to me anyway.
15:14:00 <int-e> ... because that way you get to implement a fold by folding.
15:14:55 <solonarv> well, I don't actually see how that lets you implement foldMapWithKey if you have traverseWithKey
15:15:28 <solonarv> that looks to me like a pretty open-and-shut case of "throw Const at it"
15:15:40 <solonarv> this is also what Data.Traversable.foldMapDefault does
15:19:21 <int-e> solonarv: there is a foldMapWithKey already
15:19:27 <int-e> solonarv: it's just not monadic
15:19:31 <int-e> (by itself)
15:20:52 <solonarv> oh, I thought you wanted foldMapWithKey :: Monoid m => (k -> v -> m) -> Map k v -> m
15:21:17 <solonarv> but if that is already present and you want to "upgrade" it to be monadic, yes, Ap is what you want
15:22:05 <int-e> (it wasn't my question. Boarders actually wrote "so a monadic foldWithKey?" as an afterthought)
15:23:07 <int-e> which I took to mean foldMapWithKey, but there are also left and right folds for which the question is even less interestin.
15:23:23 <int-e> anyway. I learned about Ap, thanks!
15:25:37 <solonarv> yeah!
15:26:02 <solonarv> I wanted that a few times before it was in base, was quite happy when I saw it got added and I no longer had to define my own
15:45:37 <c_wraith> oh hey, Ap. I was so excited about it that I was the first person to make a pull request to lens to support it. :)
15:46:34 <solonarv> how does lens support it? just instances for the various overloaded optics?
15:47:42 <c_wraith> yeah, Wrapped and Rewrapped
15:50:42 <c_wraith> oh hey. lens got a new release with that in it, too. only took 3 months. that's nothing compared to the 18 months it took for my changes to free to get picked up.
15:52:51 <gobby> Anybody knows how to setup ssl with yesod on a google compute instance? 
15:54:02 <gobby> I keep on getting `HandshakeFailed (Error_Misc "no keys found\n` on my instance where I put the keys in the same dir as my exec
15:54:13 <gobby> is it possible I have the wrong format for my ssl keys?
15:58:50 <hpc> is it looking for the file?
16:09:37 <gobby> hpc: I can launch the executable with no issues, but once I try to access the site via https I see that error
16:09:53 <gobby> hpc: If I had the wrong file name, it would error as I run the exec
16:11:41 <gobby> hpc: My yesod site currently binds to 443 :\
17:21:05 <xaltonon[m]> Looking for some help with dependent types with the `singletons` library: I can't get my implementation of `sortMap` to typecheck (without the `unsafeCoerce`), even though it is correct: http://ix.io/1MsF/hs
17:21:22 <AWizzArd> Can you give a minimal example of code that would break (either not compile anymore or execute semantically something different) if ScopedTypeVariables get turned on?
17:28:55 <newbie_> anyone used beam sql package with aeson here?
17:29:39 <newbie_> is it possible to write From/ToJson instances for beamable types?
17:40:19 <dibblego> is Ap now in base? Ap f g x ~ f x (g x)
17:45:12 <c_wraith> AWizzArd, compared to code with or without ExplicitForall turned on?
17:46:05 <solonarv> dibblego: not as far as I know
17:46:12 <dibblego> oh ok, couldn't find it
17:46:25 <c_wraith> dibblego, no, Data.Monoid.Ap
17:46:38 <solonarv> well, there is something named Ap in base, but it's something else: newtype Ap f a = Ap { getAp :: f a }
17:46:45 <dibblego> oh right, thanks
17:46:58 <solonarv> useful for its instances:
17:47:26 <solonarv> instance (Applicative f, Semigroup a) => Semigroup (Ap f a) where (<>) = liftA2 (<>)
17:47:37 <dibblego> right
17:47:44 <solonarv> instance (Applicative f, Monoid a) => Monoid (Ap f a) where mempty = pure mempty
17:53:31 <AWizzArd> c_wraith: first code was written _without_ ScopedTypeVariables turned on and it compiles/works.
17:54:01 <AWizzArd> c_wraith: now the extension gets turned on. What would code look like that breaks after turning the extension on?
17:57:47 <cocreature> AWizzArd: ScopedTypeVariables only has an effect if you use an explicit forall. that’s why c_wraith asked about tha.
17:57:49 <cocreature> *that
18:03:34 <Nevoic> Hey, is there anyway to trigger some kind of "nested" Record unpacking? Like instead of `Event {text, user=User {..}, server=Server {..}}` just do `Event {something}` and have it unwrap all nested records as well as Event?
18:04:11 <dibblego> Nevoic: have a look at the lens package
18:06:57 <Nevoic> The package is kind of large lol, anything in specific?
18:07:20 <nitrix> Start with lens-simple to build an intuition maybe.
18:08:42 <dibblego> https://github.com/ekmett/lens/wiki/Derivation
18:11:23 <AWizzArd> cocreature: I thought that ExplicitForAll is turned on automatically as soon you turn on ScopedTypeVariables.
18:11:56 <cocreature> AWizzArd: the extension is but you still need to add it to individual definitions
18:12:38 <cocreature> turning on ExplicitForAll only allows you to add an explicit forall. you can still have definitions without and for those ScopedTypeVariables has no effect
18:13:19 <cocreature> So if you want to talk about breakage due to turning on ScopedTypeVariables you probably want to talk about definitions that already have an explicit forall as otherwise it will just do nothing
18:18:28 <AWizzArd> cocreature: yes
18:19:31 <AWizzArd> cocreature: I just wonder what harm STV can cause, if it is just artificial examples, or if this could realistically affect several projects.
18:19:33 <cocreature> Here’s a very dumb example of something that works if you only turn on ExplicitForAll but breaks if you turn on ScopedTypeVariables https://gist.github.com/cocreature/99e024f73112aa0f491913659c0336e7
18:21:19 <AWizzArd> cocreature: good, that makes sense
18:21:34 <cocreature> you rarely hit it since it’s not common in Haskell to use explicit foralls without scoped type variables so it simply doesn’t kick in if you turn it on in an existing project
18:21:53 <cocreature> and even if it does, it’s usually trivial to fix either by renaming type variables or adding another forall
18:22:27 <AWizzArd> cocreature: I see how this could break when turning the exception on. But I also see what you just said… in practice code will have STV turned on, and not EFA, and then obviously the code will compile.
18:23:43 <cocreature> that’s the main reason why STV only kicks in if you have an explicit forall: you can enable it safely for existing projects and opt into it on a per-definition basis
18:23:44 <c_wraith> well, compared to not having explicit foralls.. it makes "forall" a reserved identifier in types.
18:24:11 <c_wraith> which is definitely a breaking change
18:24:15 <cocreature> if you name your type variables "forall" you deserve breakage :)
18:24:28 <c_wraith> hey, we were asked for what would break.
18:24:31 <c_wraith> that breaks.
18:25:49 <c_wraith> if you already had foralls enabled with another extension, then you need to get more subtle.
18:26:04 <AWizzArd> c_wraith: okay, that’s another case, when using this fun name for a type variable `forall`.
18:26:38 <AWizzArd> Btw, are there any rumors for a new standard? Or is it unlikely that there will be a new one within the coming, say, 5 years?
18:31:55 <lyxia> There's talk of 2020
18:33:02 <lyxia> https://www.reddit.com/r/haskell/comments/byokbb/are_there_any_updates_on_haskell_2020/
18:36:23 <AWizzArd> Interesting.
18:39:03 <[Leary]> STV doesn't only affect value declarations, it also e.g. brings type variables from instance declarations into scope. So you could have the same kind of breakage there without ExpliticForAll.
19:24:13 <Shushana98> Control me during my Live. Free for the next 3 members. Believe me, the fun is guaranteed! Join now: https://cut.sx/aah/
20:05:58 <libertyprime> is life with nix more carefree than with stack?
20:08:25 <maerwald> you mean maintaining overcomplicated configuration?
20:13:13 <libertyprime> i've added a few things now to extra-deps in $HOME/.stack/global-project/stack.yaml  sometimes im able to install things, sometimes i cant get past dependency issues. i feel like i spend most of my time trying to install modules and not using them. ive never used nix before and wonder if there is an easier way
20:33:02 <alx741> libertyprime: any particular reason why you want dependencies in the global project?
20:51:02 <libertyprime> no. im actually not sure how to manage dependencies properly.
20:52:24 <libertyprime> yay. just automated lambda bot :) https://asciinema.org/a/EmpS2GygsBnwrX8ZqRE4Wy13x
20:52:38 <libertyprime> gotta love emacs
20:52:59 <maerwald> if you've never used nix before, it's probably not what you want
22:48:17 <habbah> How does this actually check that a file exists? https://hackage.haskell.org/package/directory-1.3.3.2/docs/src/System.Directory.html#doesFileExist
22:50:35 <libertyprime> @hoogle ([a] -> a) -> Bool
22:50:36 <lambdabot> GHC.List any :: (a -> Bool) -> [a] -> Bool
22:50:36 <lambdabot> GHC.List all :: (a -> Bool) -> [a] -> Bool
22:50:37 <lambdabot> GHC.OldList any :: (a -> Bool) -> [a] -> Bool
22:50:49 <libertyprime> is there a reason lambdabot gives me a result with slightly different signature?
23:34:28 <c_wraith> libertyprime: because hoogle can't find anything with the type you specified.  Mostly because the only useful implementations of that type are const True and const False
23:45:02 * ski idly wonders whether libertyprimebot was looking for `(forall a. [a] -> a) -> Bool'
