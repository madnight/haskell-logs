00:00:39 <ski> (er, s/Trivial/Discard/. that's what i get for renaming identifiers, midsentence)
00:01:47 <hololeap> all i'm going to ask is if `forall a. F a ~= G a` is still a natural isomorphism if the domain of F is sparser than the domain of G
00:02:03 <ski> the domain of `F' and `G' there must be the same
00:02:19 <hololeap> in terms of sets, not categories
00:02:37 <hololeap> for instance `Maybe a` is sparser than `F b a`
00:03:03 <ski> of course, if the domain of `F' is a subset of the domain of `G', or, more generally, is included in the domain of `G', via an inclusion `I', then we could talk about `forall a. F a ~= G (I a)'
00:04:12 <hololeap> ok, yes, is that still a natural transformation? is there another name for that?
00:05:04 <hololeap> `forall a. F a ~= G (I a)'
00:06:00 <ski> oh, so you're not thinking about possible natural transformations (or isomorhisms) for functors like `Maybe' and `F b' there, but rather considering *functions* like `f :: Maybe a -> F b a' ?
00:06:14 <hololeap> right
00:06:36 <hololeap> and `g :: F b a -> Maybe a`
00:06:38 <ski> so that you could ask about `forall x :: Maybe a. f x = g x' or `forall x :: Maybe a. f x = g (i x)'
00:06:57 <ski> btw, i'm not sure which implementation of `f' you had in mind
00:07:48 <ski> so, you're looking for, not natural transformations (or isomorphisms) between functors, between categories
00:08:08 <ski> but rather, between order-preserving functions, between preorders
00:08:11 <ski> i think ?
00:08:17 <ski> hm
00:08:48 <hololeap> f = \case ; Just x -> (pure x :: F b a) ; Nothing -> No
00:09:15 <hololeap> g = \case ; F _ a -> Just a ; No -> Nothing ; Nein -> Nothing
00:09:40 <ski> how is `pure x' there defined ?
00:10:05 <hololeap> pure x = F (some default) x
00:10:15 <ski> ok, so it's not for all `b', then
00:10:20 <hololeap> correct
00:10:47 <hololeap> b :: Monoid, lets say, so `pure x = F mempty x`
00:10:59 * ski nods
00:11:58 <ski> i suppose in the "natural transformation case", you're asking about `forall x :: Maybe a. f x =< g x' or `forall x :: Maybe a. f x =< g (i x)'
00:12:40 <hololeap> is there a name for this kind of relationship between f and g, even though this isn't a preorder?
00:13:53 <ski> (in the first case here, `f,g :: Maybe a -> F b a' (possibly with a `forall a.' added), but in the second case, while having the same signature of `f', we have rather `g :: F b a -> F b a', where `i' was the inclusion you mentioned earlier)
00:14:30 <ski> and we'd want `F b a', at least, to be a preorder here. but probably `Maybe a', as well
00:15:30 <ski> however, the `g' you defined above goes in the opposite direction, so that wouldn't fit into a natural transformation, or natural isomorphism, between `f' and `g', but would possibly fit into a (monotone) Galois connection between `f' and `g'
00:16:43 <hololeap> `F b a' lives in Hask, so how could it also be a preorder? is there a way to express this in haskell syntax?
00:16:46 <ski> so, you should make up your mind about whether you want a natural transformation (or even natural isomorphism), between `f' and `g' (or possibly `g . i') .. or you, otoh, want a (monotone) Galois connection between `f' and `g'
00:17:22 <hololeap> the Galois connection sounds more accurate
00:17:23 <ski> those would be two different things !
00:17:28 <ski> (i suppose that's been my basic point i wanted to stress from the start of the discusssion)
00:18:26 <ski> so .. (a) invent some preorders on `Maybe a' and `F b a'; and (b) spell out what the (monotone) Galois connection between `f' and `g' would mean, and check whether it holds ?
00:18:31 <ski> (not necessarily in that order)
00:19:32 <ocramz> morning all!
00:19:52 <hololeap> given my latest definition of f and g, my question is if there is a name for the relationship between f and g that isn't specific to preorders
00:20:23 <ocramz> anybody ever experienced `getWorkingDirectory: does not exist` while running a stack build in a project configured to build within a Docker container?
00:20:36 <ski> (btw, if you're wondering, i'm saying "(monotone)" before "Galois connection", all the time, because what's traditionally called a "Galois connection" would here be an "*antitone* Galois connection". instead of `f' and `g' being monotone/increasing/order-preserving functions, they would there be antitone/decreasing/order-reversing functions)
00:21:20 <ocramz> wew
00:22:37 <ski> hololeap : "if there is a name for the relationship between f and g" -- which relationship ? can you spell it out ?
00:24:22 <ski> i suppose you have `id = g . f', is that the relationship you're talking about ?
00:25:15 <ski> that relationship is called a "retract situation". `g' is a retraction (or post-inverse) of `f', while `f' is a section (or pre-inverse) of `g'
00:25:34 <ski> `Maybe a' is a retract of `F b a', for all `a'
00:26:12 <dminuoso> ocramz: No.
00:27:13 <ski> say `A' is a set of classes of pupils, at a school, and `B' is the set of pupils. `g :: B -> A' is a retraction, giving for each pupil, the class they belong to
00:27:18 <dminuoso> ocramz: It is possibly related to this: https://github.com/haskell/cabal/issues/2902
00:27:51 <ski> `f :: A -> B' could be a class representative of some kind, giving for each class a pupil. and `id = g . f' expresses that the representative pupil of a class must be a member of that class
00:28:31 <hololeap> ski: https://ncatlab.org/nlab/show/retract  ?
00:28:38 <ski> `g' gives a partition on `B', all the elements of `B' that maps to the same element in `A' are in the same equivalence class
00:28:56 <ski> and the section `f' for the retraction `g' selects a representative from each equivalence class
00:29:17 <ski> hololeap : yes
00:29:51 <hololeap> ok, i will read up on it later, but i need to go to bed now. thanks, ski, i feel like i have a better intuition for adjunctions
00:30:07 <ski> okay. have fun !
00:30:11 <hololeap> thanks!
00:30:16 <ski> good night, and pleasant dreams, hololeap
00:45:30 <jgt> good morning Haskell gang
00:51:26 <hxxxrz> What does "t" mean there? class Foldable (t :: * -> *) where
00:51:26 <hxxxrz>   ...
00:51:26 <hxxxrz>   length :: t a -> Int
00:51:26 <hxxxrz>   ...
00:53:07 <ski> `t' is a type variable
00:53:17 <ski> (just like `a')
00:53:36 <ski> in this case, it's the parameter of the type class (`a' is not a parameter here)
00:54:08 <ski> e.g., in the `instance Foldable Maybe where ...', there is a definition of `length :: Maybe a -> Int'
00:54:11 <ski> which happens to be
00:54:18 <ski>   length  Nothing  = 0
00:54:28 <ski>   length (Just _ ) = 1
00:54:35 <Axman6> that class definition could also be written as class Foldable t where length :: t a -> Int, but the :: * -> * makes it explicit that t must be a tyoe constructor, like [], Maybe, Either e
00:55:23 <hxxxrz> thanks
00:55:28 <ski> and in the `instance Foldable [] where ...', there is a definition for `length :: [] a -> Int', which can, with syntactic sugar, be written as `length :: [a] -> Int', and it's defined as
00:55:32 <ski>   length [    ] = 0
00:55:46 <ski>   length (_:xs) = 1 + length xs
00:56:15 <ski> (well, it might use a different definition, but it computes the same result as that one, in any case)
00:57:50 * ski would say that the kind ascription `:: * -> *' expresses that the type `t' must be a type function (from concrete types to concrete types)
01:00:36 <stiell> I'm trying to use Data.Aeson.TH.deriveJSON on a type `Foo a` with a field `foobar :: a Bar`. This doesn't work because the compiler complains about "No instance for (FromJSON (s Bar))". Is there any way to insert the necessary contexts for deriveJSON to work?
01:02:44 <kuribas> stiell: you need an additional FromJSON for Bar
01:03:33 <kuribas> stiell: deriving JSON doesn't derive the types it depends on.
01:03:39 <kuribas> that wouldn't work anyway
01:03:44 <stiell> Bar is an instance of FromJSON/ToJSON already. I've also added FromJSON/ToJSON context for the foobar field.
01:03:58 <kuribas> ah right
01:04:22 <kuribas> then automatic deriving will not work
01:04:26 <jackdk> can you work a `FromJSON1 a` in there somewhere?
01:06:51 <Axman6> Yeah the instance you're after is instane FromJSON1 a => FromJSON (Foo a) where ... but not sure if you can get the TH stuff to do that for you
01:12:03 <royal_screwup21> anyone know the karp miller algorithm in the context of petri nets? I'm trying to figure out why there isn't a red transition via t3: https://prnt.sc/nxtb0k
01:12:55 <cocreature> royal_screwup21: that doesn’t sound like a Haskell question :)
01:13:43 * hackage llvm-ffi 3.8.1.1 - FFI bindings to the LLVM compiler toolkit.  https://hackage.haskell.org/package/llvm-ffi-3.8.1.1 (HenningThielemann)
01:17:07 <kuribas> stiell: it may work with generics though
01:17:16 <kuribas> as you can put the constraint in the instance
01:18:23 <first[m]> What the...?! Haskell room is huge. Like global #1 by leaps and bounds.
01:20:06 <kuribas> people like to talk about haskell
01:20:10 <kuribas> not code mind you :-)
01:20:49 <kuribas> If you make a REST api, how do you enable or disable logging to a running process?
01:21:12 <kuribas> Do you have another rest endpoint at another port to enable/disable variables?
01:22:06 <royal_screwup21> first[m] #1 by what metric? 
01:22:54 <merijn> royal_screwup21: #haskell is one of the biggest, if not biggest, channel on freenode
01:23:09 <kuribas> it makes people feel smart
01:23:24 <royal_screwup21> yes, but not THE biggest. 
01:23:32 <merijn> royal_screwup21: It has been at times
01:24:16 <tdammers> the reason for haskell being big on freenode is not so much due to haskell being big in general, but rather due to IRC being big in the haskell community
01:24:37 <merijn> Due to shapr harassing well-known Haskell academics into an IRC channel years ago :p
01:24:45 <first[m]> 1725 users in global directory browse, followed by 6xx by #sysadmin. Seems sorted by count.  Sorry, just joined the platform
01:24:45 <tdammers> the kind of person who enjoys Haskell is likely to prefer IRC over, say, slack
01:25:23 * jgt is that kind of person
01:27:41 <kuribas> and email over facebook?
01:27:50 <kuribas> unix over windows?
01:28:00 <jgt> yes, and yes
01:28:13 <jgt> and vim over emacs
01:28:24 * jgt dons flamesuit
01:30:45 <stiell> kuribas: Looks like `instance FromJSON (s Bar) => FromJSON (Foo s)` works with generics, though it seems I have to enable UndecidableInstances. Thanks!
01:31:21 <kuribas> np :)
01:31:57 <tdammers> vim or emacs over sublime text or atom
01:32:02 <kuribas> how do you communicate with a running process (for example rest api)?
01:32:05 <kuribas> tdammers: +1
01:32:26 <kuribas> via another REST endpoint on an internal port?
01:32:31 <tdammers> depends
01:32:34 <tdammers> all sorts of options
01:33:18 <tdammers> signals, named pipes, files, raw sockets, databases, dbus, http, websockets, ...
01:34:40 <ski> jgt : what has dons done, to deserve flamesuit ?
01:34:50 <kuribas> tdammers: unix socket?
01:34:57 <merijn> ski: dons as in the verb
01:34:59 <ski> @quote dons
01:34:59 <lambdabot> dons says: note to self: grep only works on disks
01:35:23 <ski> merijn : i know :)
01:35:53 <kuribas> tdammers: can signals pass data?
01:36:39 <ski> first[m] : just joined what platform ?
01:36:44 <kuribas> and named pipes could only communicate with a single process
01:36:55 * ski misses having e.g. augustss in the channel
01:37:06 <stiell> Binary encoding with SIGUSR1 and SIGUSR2 :)
01:37:42 * ski `kill -SIGUSR1's stiell
01:37:49 <kuribas> well, I suppose you could update the configuration then use SIGUSR1
01:39:43 * hackage knead 0.4 - Repa-like array processing using LLVM JIT  https://hackage.haskell.org/package/knead-0.4 (HenningThielemann)
01:41:38 <first[m]> ski: Librem. Saw it from F-Droid; checking it out as communication alternative. Very pleasantly surprised by online community membership composition. Reverting back to lurk mode.
01:42:54 <tdammers> you can probably coerce signals into data links, but that's not really what they're for
01:47:44 <jgt> ski: I knew someone would make that joke :D
01:49:27 <kuribas> tdammers: using signals to reload the config is accepted practice, isn't it?
01:49:42 <tdammers> yes, but the new configuration isn't attached to the signal itself
01:49:49 <tdammers> the signal is just a dataless "kick"
01:51:42 <kuribas> yeah
01:55:40 <cocreature> when should I expect hClose to block?
02:05:44 * hackage patch-image 0.3.3 - Compose a big image from overlapping parts  https://hackage.haskell.org/package/patch-image-0.3.3 (HenningThielemann)
02:11:05 <powerbit> HI, I was going over "The 3 Second Rule" and had this ideea of building list of things that every programmer should know. Some people did it already to some extent. From your discutions I saw you know your stuff very well so I thought asking you first.
02:11:24 <powerbit> If yes, do you have sugestions of what to add to the list?
02:11:47 <powerbit> I only have one till now http://codebase.site/question/show_question_details/696
02:26:09 <c4droid> Hi, The Windows Haskell Platform have anyone configure it to friendly to use?
02:30:45 <c4droid> I'm ready to download intellij-haskell to idea
02:34:16 <merijn> Is there a library for pretty printing time durations? i.e. if I have 14,489,494 nanoseconds and want to report it in milliseconds and microseconds for human readability
02:36:06 <solonarv> c4droid: intelij-haskell relies on stack IIRC, so you just need to install that
02:36:35 <solonarv> but I would recommend starting with a lighter editor and not locking yourself into stack right away, it does some things weirdly
02:37:04 <c4droid> I'm prepared vscode
02:37:41 <solonarv> my recommendation is to install ghc+cabal through chocolatey and use a code editor (such as vscode)
02:38:23 <solonarv> for that editor on particular there is a lightweight plugin which I heartily recommend: vscode-ghc-simple
02:39:50 <c4droid> Simple GHC (Haskel) Integration?
02:40:15 <solonarv> yep, that's the one
02:41:17 <c4droid> At windows, just use ghc and stack that's ok?
02:42:16 <solonarv> ehhh, sort of?
02:42:48 <solonarv> stack expects to manage your installed GHC(S) by itself, so if you really want to use stack all the time you don't need to also install GHC
02:43:28 <c4droid> ok, so, stack and vscode
02:43:34 <c4droid> with docker
02:43:38 <c4droid> :)
02:44:36 <solonarv> but I would not recommend this starting out, because you have to learn cabal and ghc anyways and stack is in some sense a weird wrapper over those
02:45:20 <solonarv> you can use docker if you want to, but I don't know why you would - none of the current tooling pollutes your system in a way that would need containerizing
02:46:25 <c4droid> Because I trying use windows versions haskell platform, I don't know how to configure with it. so... 
02:48:31 <solonarv> as I already said: install them (ghc and cabal) through chocolatey
02:49:05 <solonarv> https://chocolatey.org/install - a package manager for windows
02:49:51 <solonarv> once you have that installed, run: choco install ghc cabal
02:50:09 <solonarv> that will give you the latest ghc (8.6.5) and cabal (2.4.1.0)
02:51:44 <c4droid> waiting for a minute, I'm installing chocolatey now.
02:54:34 <tdammers> using stack because you don't know how to make cabal work is a lousy reason
02:55:06 <tdammers> if you're going to use stack because the way stack does dependency resolution (or rather, sets things up to avoid dependency resolution altogether) is what you want, then fine
02:56:31 <c4droid> solonarv: I'm installed choco
02:56:56 <solonarv> tdammers++
02:58:31 <solonarv> c4droid: good, now run the command I gave you (has to be from within cmd.exe run as admin)
02:59:12 <solonarv> there might be a way to install things without requiring admin but my internet right now is too shit to look it up for you, so you'll have to search chocolatey's documentation yourself
03:04:13 <c4droid> Ok.
04:08:19 <mreh> is there an elegant way of mapping relations in Beam to nested structures?
04:09:44 * ski idly wonders what Beam might be
04:10:17 <MasseR> the new database abstraction library
04:11:07 <mreh> you get to write typed SQL queries
04:11:09 <ski> hm
04:11:12 <ski> @hackage beam
04:11:13 <lambdabot> http://hackage.haskell.org/package/beam
04:11:19 <ski> doesn't include Haddock docs
04:11:29 <mreh> I'm beginning to wonder why though
04:11:39 <tdammers> ski: check it out. I'm not a huge fan of the "generate SQL queries with a generalized type-safe EDSL" approach, but as far as that approach goes, beam does it pretty well
04:12:18 <tdammers> "deprecated in favor of beam-core" is probably part of why it doesn't have haddocks
04:12:26 <tdammers> https://hackage.haskell.org/package/beam-core does
04:14:19 <ski> @hackage beam-core
04:14:20 <lambdabot> http://hackage.haskell.org/package/beam-core
04:14:24 <ski> yea
04:16:49 <mreh> maybe I could use the applicative functor instance to collect the joined tables into a map over the foreign key
05:14:14 * hackage process 1.6.5.1 - Process libraries  https://hackage.haskell.org/package/process-1.6.5.1 (MichaelSnoyman)
05:41:17 <joel135> Can you do something like "classes A a, B b where ..."?
05:42:05 <jose_zap> joel135 what is that supposed to do?
05:42:09 <joel135> 'mutually recursive classes'
05:42:38 <Taneb> joel135: you don't need to do any sort of pre-declaration, as long as they're in the same module they can be mutually recursive
05:44:10 <joel135> Is there something like "class A a a' where ..."?
05:44:17 <Cale> yes, that works
05:44:21 <Cale> er
05:44:34 <Cale> Did you mean "class A a b where ..." ?
05:44:46 <joel135> yes
05:45:05 <Cale> then yeah
05:45:42 <joel135> oh I can use "{-# LANGUAGE MultiParamTypeClasses #-}"
05:45:51 <joel135> i think that's it
05:45:55 <Cale> yeah
05:45:56 <solonarv> indeed
05:46:03 <kuribas> when it comes to type safe databases I find squeal less boilerplate-y than beam
05:57:50 <aplainzetakind> Is `zoom`ing in a polymorphic monad like `MonadState Foo m => m ()` problematic? I'm getting "Could not deduce Zoom" errors, and lens type errors are daunting to figure out.
05:59:14 * hackage streaming-commons 0.2.1.1 - Common lower-level functions needed by various streaming data libraries  https://hackage.haskell.org/package/streaming-commons-0.2.1.1 (MichaelSnoyman)
06:00:40 <solonarv> aplainzetakind: you need a constraint like 'Zoom m n Foo Bar'; your zoomed actions run in 'n', with 'MonadState Bar n'
06:01:31 <solonarv> ah, actually it's 'Zoom m m Foo Foo' for the monomorphic case, I think
06:01:54 <c4droid> solonarv: Now I installed the cabal and ghc, vscode installed simple ghc integration.
06:03:17 <aplainzetakind> solonarv: I want to zoom from `MonadState Foo m => m ()` to `MonadState Bar n => n ()`, I think.
06:04:05 <solonarv> aplainzetakind: then you need a 'Zoom m n Foo Bar' constraint, I think
06:04:21 <solonarv> which is more restrictive than 'MonadState m Foo, MonadState m Bar'
06:04:32 <solonarv> s/m/n/ in the second one
06:07:38 <c4droid> solonarv: have any extra configuration with vscode editing?
06:08:01 <solonarv> c4droid: I don't even use it anymore, so not really
06:08:06 <solonarv> just syntax highlightinh
06:08:33 <joel135> I want to make a DSL for evaluating certain logical statements about vectors, involving quantification. I started like this: https://gist.github.com/JoelSjogren/de6466cba586e806bd320a9067d67abc
06:08:48 <c4droid> ok
06:10:05 <aplainzetakind> Apparently microlens-platform does not export Zoom
06:10:37 <solonarv> there seems to be a whole bunch of machinery needed for it, so I can see why - it is *micro*lens after all
06:11:27 <aplainzetakind> It is in microlens-mtl though.
06:11:33 <solonarv> huh
06:12:16 <solonarv> don't mind me then :D
06:12:21 <joel135> Then I want to construct a 'term model' for which which every value (vec n -> prop) has a representation as a lambda term which can be manipulated.
06:14:23 <joel135> But I don't quite see how to do that 'value to term' step.
06:15:15 <aplainzetakind> solonarv: I imported Zoom and adding the constraint also didn't help with the error.
06:17:15 <aplainzetakind> Lens isn't too easy to just use without proper groking it seems.
06:18:14 * hackage inspection-testing 0.4.2 - GHC plugin to do inspection testing  https://hackage.haskell.org/package/inspection-testing-0.4.2 (JoachimBreitner)
06:19:14 * hackage publicsuffix 0.20190605 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20190605 (wereHamster)
06:20:48 <aplainzetakind> Ah I put the parameters in the wrong order. That error is gone.
06:43:44 * hackage mail-pool 2.0.0 - Preconfigured email connection pool on top of smtp.  https://hackage.haskell.org/package/mail-pool-2.0.0 (Jappie)
07:12:56 <Ferdirand> what's a good name for (fromString . show) ?
07:13:42 <Rembane> Ferdirand: What's the type?
07:18:18 <lortabac> Ferdirand: genericShow?
07:19:16 <Ferdirand> :t (fromString . show)
07:19:18 <lambdabot> (Show a, IsString c) => a -> c
07:21:39 <Ferdirand> lortabac: i wanted something shorter and prettier
07:21:53 <Ferdirand> maybe I can just call it show and hide the one from Prelude
07:21:58 <maerwald> show'
07:22:16 <maerwald> and move on to programming :P
07:22:32 <lortabac> :t genericLength
07:22:33 <lambdabot> Num i => [a] -> i
07:22:39 <lortabac> :t genericTake
07:22:40 <lambdabot> Integral i => i -> [a] -> [a]
07:22:54 <solonarv> if the result type is supposed to be 'Text' you can call it 'tshow'
07:23:04 <Ferdirand> i'm trying to provide good ergonomics
07:23:04 <lortabac> it's a kind of convention
07:23:05 <solonarv> IMO Text is about the only thing that makes sense for anyway
07:23:13 <Ferdirand> it's for Text indeed
07:23:25 <Ferdirand> well
07:23:48 <Ferdirand> a wrapper around Text that happens to implement IsString
07:24:15 <Ferdirand> (for color support)
07:24:26 <solonarv> using IsString for anything other than enabling OverloadedStrings is kinda smelly IMO
07:24:43 <maerwald> especially since ByteString is a dangerous instance
07:25:07 * Lycurgus prefers fragrance free
07:25:33 <Ferdirand> show' it is then
07:26:54 <maerwald> Write a ToText class where the default implementation uses T.pack . show
07:27:06 <dminuoso> Why are genericLength and genericTake limited to [] and not polymorphic over Foldable? Seems rather non-generic. :|
07:27:58 <Ferdirand> maerwald: can you actually do that ?
07:28:23 <Ferdirand> i mean, if you have show in the default implementation, without making this ToText class depend on Show ?
07:28:25 <solonarv> genericLength could be Foldable-polymorphic but it doesn't make a ton of sense for take
07:29:04 <Ferdirand> i don't think I want to go IncoherentInstances either
07:30:00 <solonarv> Ferdirand: you can do that with -XDefaultSignatures
07:30:31 <Ferdirand> joy, an extension i've never encountered before
07:30:44 <solonarv> class ToText a where tshow :: a -> Text; default tshow :: Show a => a -> Text; tshow = Text.pack . show
07:31:17 <Ferdirand> oh
07:31:19 <Ferdirand> that's awesome
07:31:21 <Ferdirand> thanks
07:32:11 <lortabac> if you plan to use the default instance all the time you can just define tshow as a function
07:33:31 <maerwald> Ferdirand: https://gist.github.com/hasufell/b191173ca59b60433793804625753072
07:34:45 <Ferdirand> ah, so you still need to declare all the types you want to use in this context ?
07:35:43 <solonarv> yes - you *can* write 'instance {-# OVERLAPPABLE #-} Show a => ToText a' but that can break things in some cases
07:36:00 <Ferdirand> ideally i'd like my users to be able to write something like: "foo" <> x <> " bar " <> show' y
07:36:11 <Ferdirand> where OverloadedStrings is used for the literals
07:36:29 <Ferdirand> and if x has an instance for this conversion, i'd like to use that
07:37:05 <solonarv> ah, you're trying to (re-)invent format strings or something similar?
07:37:13 <Ferdirand> but if I have an y of an overly general type like Int, i don't like to force my user to instanciate my class over it
07:39:35 <Ferdirand> maybe format strings would work better
07:40:02 <solonarv> similar things have certainly been done
07:42:38 <Ferdirand> i've been thinking about existentials too
07:43:02 <solonarv> that's probably not the right approach
07:43:25 <Ferdirand> why not ?
07:44:09 <solonarv> I'd just keep things simple - IMO it's fine if usage looks like this: "blah " <> showing x <> "ashgf" <> text (... :: Text)
07:44:18 <Ferdirand> if it allows me to turn (foo (bar x <> bar y <> bar z)) into (foo . bar' $ [x,y,z])
07:44:40 <Ferdirand> but i agree that may be too confusing for reading
07:44:51 <solonarv> no, it doesn't - you can't even have [x, y, z] unless x,y,z have the same type
07:45:23 <Ferdirand> well, [(forall a. ToText a => a)] ?
07:46:06 <solonarv> nope, that's not even (a list of) existentials
07:46:17 <Ferdirand> i don't know why i remember seeing something like this at one point
07:46:21 <solonarv> that would be [exists a. ToText a *> a], or something
07:46:38 <solonarv> which isn't even legal Haskell (we don't have "anonymous" existentials of that sort)
07:47:17 <solonarv> what you wrote involves impredicative types, which GHC does not (yet?) support
07:47:40 <Ferdirand> ah right
07:47:48 <Ferdirand> i'd still need some constructor in between
07:47:55 <lortabac> Ferdirand: if you need to do a lot of interpolation you can use text-format
07:47:55 <Ferdirand> so that gains nothing
07:48:08 <lortabac> otherwise I'd just use T.pack . show
07:48:30 <dmwit> ([exists a. ToText a *> a] would also be impredicative)
07:48:39 <Ferdirand> performance won't be critical
07:48:45 <Ferdirand> since it's for human interaction
07:51:44 * hackage haskoin-store 0.16.2 - Storage and index for Bitcoin and Bitcoin Cash  https://hackage.haskell.org/package/haskoin-store-0.16.2 (xenog)
07:53:08 <kuribas> you can have [forall a. ToText a => (a -> k) -> k]
07:54:13 <jgt> all my projects have `tshow = T.pack . show`, defined in ClassyPrelude
07:55:27 <dmwit> % :k (->)
07:55:32 <yahb> dmwit: (->) :: * -> * -> *
07:55:33 <dmwit> % :k (=>)
07:55:34 <yahb> dmwit: ; <interactive>:1:2: error: parse error on input `=>'
07:55:39 <dmwit> ghc pls
07:56:41 <dminuoso> jgt: I've done something similar until I realized my mistake: relying on Show to begin with.
07:57:44 <kuribas> there's a pretty show package
07:57:50 <dminuoso> jgt: It seems more sensible to write ppr* functions or some sort.
07:57:52 <kuribas> I'll probably use that one
07:58:43 <dminuoso> Im not even sure whether `T.pack . show` is able to do pointer stealing in general.
07:59:19 <dminuoso> Besides, I wouldn't want to rely on optimizations for this to be fast. It should be fast (i.e. Show should use Text) to begin with. :p
08:02:11 <dminuoso> ski: The type induction article is pretty interesting. Never thought about thinking of fold as corresponding to induction. :)
08:02:24 <kuribas> is show the right type for debugging?
08:02:44 <dminuoso> *type inference article?
08:03:01 <lortabac> dminuoso: can you share the link?
08:03:09 <yorick> how is asterius template haskell support these days?
08:04:04 <dminuoso> @where polymorphic-type-inference
08:04:04 <lambdabot> "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <https://cs.au.dk/~mis/typeinf.p(s|df)>,<http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.57.1493>
08:04:35 <lortabac> thanks
08:11:07 <solonarv> kuribas: yes, that's exactly the point of show
08:12:03 <kuribas> solonarv: but it's not exactly readable
08:12:12 <dminuoso> kuribas: Why is it not readable?
08:12:33 <kuribas> dminuoso: there are no line breaks and indentation?
08:12:40 <dminuoso> kuribas: http://hackage.haskell.org/package/pretty-simple
08:16:10 <RedNifre> Meh, who cares about languages, naming is where it's at. Should the compiler be called voyc, lunchbox? Or I just bypass the naming problem by calling it the calculator emoji 🖩 . Might be tricky to type in the command line though...
08:18:27 <dminuoso> RedNifre: Not to Agda people...
08:21:39 <TMA> RedNifre: also there are only two hard problems in computer science/software engineering: 1. naming things, 2. cache coherence, 3. off by one errors
08:25:34 <kuribas> > length ["naming things, "cache coherence", "off by one errors"]
08:25:38 <lambdabot>  <hint>:1:64: error:
08:25:38 <lambdabot>      lexical error in string/character literal at end of input
08:25:50 <kuribas> > length ["naming things", "cache coherence", "off by one errors"]
08:25:52 <lambdabot>  3
08:27:01 <kuribas> TMA: FTFU: 0. naming things, 1. cache coherence, 2. off by one errors
08:27:01 <kuribas>  
08:35:25 <joel135> Can you make f return n? https://gist.github.com/JoelSjogren/3a9220f8903380416821487debd4ad82
08:42:01 <glguy> joel135: No, n is a type. It won't exist at runtime. If you want a Natural value corresponding to that type you can use http://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-TypeNats.html#t:KnownNat
08:43:18 <joel135> ok
09:00:01 <halogenandtoast> Is there a good data structure for representing a hex grid where the hexes have potential connections between them, I am wondering if I need to use IORefs here.
09:01:57 <glguy> A 2-D array is a good way to lay out a hex grid. You could store the connections between elements with: Map (Int, Int, Direction) a -- Direction would be some 3 constructor enumeration
09:02:16 <alx741> halogenandtoast: I rembember there is a library for grids, but can't recall its name
09:02:27 <glguy> unless the connections are directional, then a 6 constructor enumeration
09:02:42 <alx741> oh, it is "grid": https://hackage.haskell.org/package/grid
09:02:43 <halogenandtoast> glguy: They are not directional in this case
09:03:05 <halogenandtoast> alx741: Yeah I've seen that, but I sort of want to understand it at a topical level before I implore that.
09:03:34 <glguy> halogenandtoast: There's a really nice webpage on representing hex coordinates: https://www.redblobgames.com/grids/hexagons/
09:03:46 <halogenandtoast> glguy: yup, I've seen that page, it is amazing
09:05:35 <halogenandtoast> glguy: so that I understand it roughly, what is the a in Map (Int, Int, Direction) a, would that need to be an IORef if the value of a hex can change?
09:05:57 <glguy> Or no IORefs at all and just update the Map as connections change
09:07:49 <halogenandtoast> glguy: one complication is that a tile could have two connections, that aren't themselves connected, i.e. edge 1 to 2, and 4 to 5
09:08:11 <halogenandtoast> they're not directional though so 5 to 4 and 2 to 1 are valid as well
09:08:21 <halogenandtoast> but 5 to 1 would not be
09:08:36 <halogenandtoast> And a connection can have features (Cities or Stations)
09:08:38 <glguy> The map representation above allows any two hexes to be connected or not
09:08:49 <glguy> and the feature would go in the map in place of the 'a' type variable
09:09:05 <glguy> any two adjacent hexes*
09:09:56 <halogenandtoast> glguy: you may be answering correctly, but just in case, this is what I am referring to: http://www.rails18xx.it/Tiles/TileDictionary/tile64.gif
09:10:24 <ski> dminuoso : hmm ? oh. i thought most explanations of catamorphisms mentioned the connection to (structural) induction. similarly for anamorphisms and (structural) coinduction
09:10:28 <glguy> Oh, I'm talking about connecting hexes rather than connections within a single hex
09:11:01 <ski> dminuoso : and what do you think about how accessible that papar is ?
09:12:10 <halogenandtoast> glguy: right, I am aiming to implement some way of representing all these: http://www.fwtwr.com/18xx/images/1830_c_ts1.gif
09:12:57 <halogenandtoast> and I need to some way be able to tell that if you enter a tile on an edge, what edges you can exit
09:13:09 <halogenandtoast> and if there are any features on the connection
09:17:04 <d34df00d> What shall I use if I want to add monitoring to my daemon, like how long do certain SQL statements take, or what the queue sizes look like, etc?
09:17:15 <d34df00d> IIRC ekg is a tool of choice. Is it still the case?
09:18:18 <d34df00d> And will it be still optimal shall I decide to integrate all this mess with, say, Zabbix later on?
09:42:44 <tabaqui> is there any maintainer of terminal-size?
09:42:52 <tabaqui> I have some questions and pull request
09:43:53 <sm[m]> tabaqui: you can find that info on the hackage page
09:44:23 <tabaqui> sm[m]: not everyone use the same nick on freenode
09:44:50 <tabaqui> the library seems outdated and I'm not sure if I could even reach them
09:45:06 <sm[m]> there is an email address
09:45:32 <sm[m]> I know it's crazy, but it could work !
09:45:44 <tabaqui> but is is sooo long and formal
09:46:24 <sm[m]> I know. I'm very sorry :)
09:46:26 <tabaqui> btw, probably it is Russian and we can discuss it with beer :)
09:46:36 <tabaqui> *he is Russian
09:48:05 <sm[m]> address: Gorgoroth, Mordor
09:48:09 <sm[m]> yikes
09:48:59 <tabaqui> it is funny, because some of us name our country as Mordor
09:49:34 <sm[m]> really
09:49:54 <tabaqui> yep, but is has political reasons
09:49:59 <dminuoso> ski: I have some mixed feelings. In some parts it feels rushed and not precise enough for my taste.
09:50:09 * sm[m] wonders what to call the US
09:50:50 <tabaqui> we have different names for the US too :)
09:50:56 * ski nods
09:51:08 <davean> tabaqui: if there isn't a maintainer, you can file to take it over
09:51:27 <ski> dminuoso : mainly, i tend to suggest it, because it goes into some more detail of how to read and think of inference rules
09:52:01 <tabaqui> davean: hm, interesting idea
09:52:45 <davean> tabaqui: https://wiki.haskell.org/Taking_over_a_package is the general policy for reassigning packages with missing maintainers
09:52:52 <davean> its a little slow but fairly efficient
09:53:10 <ski> (could be worse, could have only provided a Discord link or something ..)
09:53:14 <dminuoso> ski: I suppose the ideal way to go about it is to pick several resources and read them, compare the inconsistencies, filling gaps with the next paper/article...
09:53:32 <ski> perhaps so
09:54:00 <ski> i learned from all other the place
09:54:31 <davean> tabaqui: https://github.com/haskell-infra/hackage-trustees
09:54:36 <ski> an important trick is to learn to not be intimidated by papers
09:54:57 <tabaqui> davean: thx
09:57:51 <Messburn> I want to make a PG connection avaiable to Servant handler functions. How do I pass the conn to the handler?
09:58:55 <dminuoso> ski: There's one part I havent been able to figure out complete yet. The difference between entailment and implication still escapes me. Implication is trivial, but what exactly is entailment compared to it?
09:59:16 <dminuoso> Is there some concrete example that illustrates the difference?
09:59:41 <ski> implication forms a new proposition (state-of-affairs), from an old one
10:00:01 <ski> entailment is a meta-language relation, you can't nest it
10:00:48 <ski> `A -> B' means you're considering the situations where if `A' were to hold, then `B' would also hold
10:01:14 <ski> `A |- B' means' *you* are claiming that in all situations where `A' holds, `B' also holds
10:01:49 <dminuoso> ski: So `A |- B` is a proposed set of proofs for `A -> B`?
10:02:18 <dminuoso> ski: Or what does "in all situations" mean exactly?
10:02:20 <ski> `A |- B' is a hypothetical judgement
10:02:29 <ski> `A -> B' is not a judgement
10:02:55 <ski> dminuoso : model theory, all models/structures
10:03:38 <ski> in propositional logic, we're considering all possible assignments of truth-values to the propositional variables. iow we're considering all rows of truth-value tables
10:05:36 <ski> hm, i think Martin-Löf went into distinction of two different "levels of proof"
10:05:51 <MacSlow> Greetings everybody
10:08:43 * hackage ghc-lib-parser 8.8.0.20190424 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-parser-8.8.0.20190424 (shayne_fletcher)
10:19:44 * hackage ghc-lib 8.8.0.20190424 - The GHC API, decoupled from GHC versions  https://hackage.haskell.org/package/ghc-lib-8.8.0.20190424 (shayne_fletcher)
10:20:52 <fendor> this version number is great.
10:21:11 <fendor> i take it, not even ghc likes the pvp versioning?
10:23:45 <MarcelineVQ> that number fits within pvp
10:24:17 <MarcelineVQ> https://pvp.haskell.org/
10:27:38 <zachk> ghc added player verse player? cool I will have to try it out and try to level up! 
10:29:12 <sm[m]> yah language extensions deathmatch
10:29:32 <MarcelineVQ> zachk: beging your adventure here https://gitlab.haskell.org/ghc/ghc
10:30:07 <zachk> can't wait till I unlock ghc 9.0.1 
10:31:01 <fendor> really? hm. i dislike for not real reason
10:42:18 <John_Ivan> a quick question regarding haskell - how is IO approached generally when it comes to reading data from buffers or writing to it?
10:42:30 <John_Ivan> in particular doing operating system syscalls
10:43:31 <solonarv> John_Ivan: mostly, such operations are "wrapped" in the IO type, same as e.g. getLine or readFile
10:46:46 <solonarv> and we can perfectly well work with pointers &c in Haskell (though it is a bit more verbose than in languages where you do that frequently)
10:47:24 <solonarv> for example there is 'fdReadBuf :: Fd -> Ptr Word8 -> ByteCount -> IO ByteCount'
10:47:30 <cocreature> also you rarely end up working with syscalls directly. Most packages, in particular the IO stuff in `base` gives you a nice blocking API that works well with Haskell’s lightweight threads and GHC’s IO manager translates that into efficient non-blocking syscalls under the hood
10:48:07 <solonarv> which is pretty much a 1-to-1 equivalent to 'size_t read(FILE fd, char* buf, size_t len)
10:48:16 * ski . o O ( `scanf("et cetera%c",&c)' )
10:48:38 <solonarv> (the function I mentioned lives in the 'unix' package, which provides POSIX bindings)
10:48:54 <solonarv> but also as cocreature says we rarely use syscalls directly
10:49:15 <dminuoso> ski: Mmm, so entailment connects sentences, whereas implication is just a connective *inside* sentences?
10:50:02 <dminuoso> (That is, implication connects propositions, whereas entailment would connect sentences)
10:50:13 <ski> dminuoso : i suppose so, though i might s/sentences/assertions/
10:50:36 <ski> (or "judgements")
10:50:57 <ski> (did you try looking at the Martin-Löf paper, yet ?)
10:52:45 <dminuoso> ski: Do you mean this one? https://www.ae-info.org/attach/User/Martin-L%C3%B6f_Per/OtherInformation/article.pdf
10:53:33 <ski> yes
10:54:20 <dminuoso> Ah. I took an initial look at it, but decided to step into the type inference article first. Perhaps the choice was wrong. :)
10:55:22 <ski> i don't know
11:06:24 <d34df00d> That's probably a stupid question, but why isn't MonadError T m imply that m is Alternative?
11:07:53 <d34df00d> Or, in other words, let's say I have "readInt, readApproxInt :: MonadError String m => String -> m Int". How do I express "try readInt, if it fails, try readApproxInt" concisely?
11:09:52 <solonarv> d34df00d: well, if you're writing this you can presumably just add an Alternative constraint
11:10:30 <d34df00d> solonarv: that's deep within my page scraping stack, I'm not sure pulling this constraint all the way up makes sense.
11:10:51 <lyxia> instance MonadError e m => Alternative m    would require overlapping instances, which core libraries are not keen on using
11:11:17 <d34df00d> I noticed ExceptT is actually an Alternative, so I'm thinking about something like `liftEither $ runExceptT $ foo t <|> bar t`, but I'm not able to make it typecheck yet.
11:11:29 <lyxia> also ExceptT requires an extra Monoid e
11:11:41 <lyxia> for its Alternative instance
11:11:50 <d34df00d> My e is String, so it's fine (although ugly).
11:13:04 <lyxia> well the "no overlapping instances" seems like enough of an argument anyway
11:14:42 <solonarv> you could change String to (First String) or (Last String) to keep only the first/last error, or to [String] to keep all errors ;)
11:15:02 <ski> @remember jcowan The continuation is simply the stack, the whole stack, and nothing but the stack.
11:15:02 <lambdabot> Done.
11:15:45 <d34df00d> Yay, got it!
11:15:53 <d34df00d> It should have been liftEither . runExcept!
11:15:57 <d34df00d> Not liftEither . runExceptT
11:17:05 <d34df00d> Yeah, replacing `>>= foo` with `>>= \t -> liftEither $ runExcept $ foo t <|> bar t` did the trick.
11:17:14 <d34df00d> Now I wonder if there is a shortcut to make it more point-free.
11:17:18 <d34df00d> foo t <|> bar t looks meh.
11:17:36 * ski . o O ( s/point-free/pointless/ )
11:17:48 <d34df00d> This whole project is pointless.
11:17:49 * ski . o O ( `liftA2 (<|>) foo bar' )
11:17:52 <d34df00d> So that's fine and in line.
11:18:13 <Rembane> I was going to propose something stupid with arrows. :D
11:18:26 <d34df00d> Lol, yeah, liftA2 works :)
11:19:52 <ski> `uncurry (<|>) . (foo &&& bar)' ?
11:20:20 <Rembane> Bingo! 
11:20:51 <solonarv> I always love it when people talk about "arrows" but actually just use the (->) instances ;)
11:22:13 <Rembane> solonarv: Have you found any use for any other instances than (->) and (,)? :)
11:22:34 * ski . o O ( "Abstractions" by Maria Kovalyova,Roman Cheplyaka in 2011-01-16 at <https://ro-che.info/ccc/12> )
11:23:03 <Rembane> :D
11:23:15 * ski idly wonders `Arrow (,)'
11:23:19 <solonarv> Rembane: I don't use arrows much at all
11:23:44 <d34df00d> I'm using opaleye rn.
11:23:48 <d34df00d> It uses arrows widely.
11:23:50 <Rembane> ski: Maybe I got that wrong. 
11:23:52 <d34df00d> Looks interesting.
11:24:05 <Rembane> solonarv: Got it. I think that's a very sane thing to do.
12:18:43 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: https://gist.github.com/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org'
12:18:43 --- topic: set by glguy on [Sat Jan 05 07:21:52 2019]
12:18:58 <jgt> so it wouldn't matter if I modified some underlying value
12:19:30 <jgt> I'm bracing for the fact I may have to write my own parser for this
12:20:12 <merijn> jgt: Why bracing? Writing your own parser seems easier than this hijacking you're talking about
12:20:24 <jgt> actually, this won't work anyway
12:20:39 <jgt> $123 — is this USD? SGD? NZD?
12:22:29 <jgt> merijn: I have an extensive background in awful hacks with jQuery widgets. Not a huge amount of experience writing parsers in Haskell (though I have does this a bit)
12:22:38 <jgt> s/does/done/
12:25:09 <cocreature> jgt: writing a Haskell parser sounds way easier than doing awful hacks in jquery widgets :)
12:25:34 <jgt> in retrospect, I agree
12:25:49 <jgt> I'm exhibiting an emotional response — not a rational one
12:33:30 <jgt> oh holy shit; I figured out a _much_ easier way to approach this problem
12:33:40 <jgt> no parser necessary
12:33:40 <jgt> no weird hacks necessary
12:35:29 <jgt> I'm writing a custom yesod-form field for monetary amounts
12:35:29 <jgt> which consists of a select field for the currency, and a text input for the amount
12:35:29 <jgt> and I didn't realise before that I can just give _both_ the select and the text input the same field name
12:35:29 <jgt> and then I get _both_ values in the field parsing function
12:35:29 <jgt> that is AWESOME
12:37:48 <jgt> how do I pattern match a list I'm expecting to have two values, and still be exhaustive? Is it enough to do this?
12:38:44 <merijn> jgt: "expecting to have two values" <- well, what do you expect to do when that's not the case?
12:39:57 <jgt> f (a:b:_) =
12:39:57 <jgt> f _ =
12:40:42 <merijn> jgt: That works, yes
12:40:58 <jgt> merijn: something like `return $ Left "Invalid monetary amount"`
12:41:17 <cocreature> note that the first will match if there are at least two values not only if there are exactly two values. that may or may not be appropriate
12:45:34 <solonarv> perhaps you instead want: f [x, y] = <do stuff>; f _ = <throw an error>
12:47:08 <jgt> cocreature: yeah, I don't _think_ it matters if the list is longer than two values
12:47:48 <jgt> but I am concerned about the order. The order I'm seeing is consistent with the order than the elements appear in the HTML, but I don't know whether or not this is a coincidence
13:02:06 <merijn> So...anyone up for playing type tetris and helping me simplify some ugly-ass code? :p
13:02:26 <merijn> https://paste.debian.net/1086453/
13:02:51 <shapr> anyone else playing with github's semantic library? I'm having "cabal new-install" failures for both ghc 8.6.4 and 8.6.5 and I can't tell if it's something I'm doing wrong
13:03:00 <merijn> I feel like I should be able to get rid of the fmap and explicit ContT/lambda, but I don't quite see how
13:06:51 <dmwit> merijn: Replace `f xyzzy` with `f (foo xyzzy)`, I think.
13:07:25 <dmwit> merijn: ...and then you can probably inline and reduce `foo xyzzy`.
13:08:12 <jgt> how do I write this type signature? parseUSD :: Text -> Maybe (Dense "USD")
13:08:13 <dmwit> \((x, y), (z, _)) -> local (>> release y) (f (show x, z))
13:08:26 <jgt> compiler says Illegal type: ‘"USD"’ Perhaps you intended to use DataKinds
13:08:35 <dmwit> jgt: Well... turn on DataKinds then?
13:08:53 <solonarv> DataKinds is needed to let you write type-level strings (Symbol)
13:08:53 <jgt> oh
13:09:05 <jgt> sorry, for some reason I thought it thought I was trying to do something else
13:09:32 <jgt> and the safe-money docs seem to make no mention of this extension
13:10:15 <dmwit> merijn: By the way, the thing I typed outside IRC to figure this out I include below. The first equality came from just looking up the definition of fmap on ContT.
13:10:27 <dmwit> merijn: fmap foo (ContT \f -> e) = ContT \c -> (\f -> e) (c . foo) = ContT \c -> e[c.foo / f] = ContT \f -> e[f.foo / f]
13:10:38 <merijn> dmwit: actually, I think maybe I just want withContT?
13:11:29 <merijn> hmm, no, not quite...
13:11:53 <dmwit> No idea. I don't understand ContT, I'm not familiar with the library of functions available to munge ContTs, and I don't understand what this code is doing. So I'm at three strikes on giving any higher-level help than mere calculation.
13:16:09 <merijn> Yeah, my main problem is that I don't understand how (if at all) any of the ContT functions can help with cleaning this stuff up
13:18:03 <monochrom> I was the immediate culprit for adding ContT to this. It is a common trikc to use ContT to "unnest" nesty multiitudes of with*, bracket-style function calls.
13:19:37 <merijn> monochrom: Pretty sure Tekmo's writing on managed that did that :p
13:19:43 <monochrom> For example "withFoo (\x -> withBar (\y -> whee))" some people rewrite that to "runContT return (do { x <- ContT withFoo ; y <- ContT withBar ; lift whee } )"
13:20:04 <merijn> monochrom: s/runContT return/evalContT ;)
13:20:13 <monochrom> Oh neato
13:20:19 <merijn> (brb)
13:21:51 <c_wraith> I get the feeling it's supposed to be using ContT to simplify nested bracket usage
13:24:03 <monochrom> It bascially all began with a blog along the line of "cont is the mother of all monads".  (Right right, the blog itself agrees that it is inaccurate and explains in what sense.)
13:24:31 <monochrom> There is also "re-invert inverted control".
13:25:24 <merijn> c_wraith: It is, and it's succeeding quite well
13:25:50 <merijn> c_wraith: The whole manually transforming the continuation with a lambda bit is rather unsightly, though >.>
13:27:14 <monochrom> Hrm actually bracket is a poor candidate, yeah.
13:28:12 <monochrom> Oh wait nevermind, bracket can be a good candidate, for example when "open" and "close" are known and fixed.
13:28:36 <merijn> monochrom: huh? That doesn't matter, though?
13:28:45 <merijn> "ContT $ bracket foo bar" works fine
13:28:47 <ski> merijn : oh, is `evalCont',`evalContT' finally being added ?
13:28:53 <monochrom> Yeah, I just mean that.
13:29:05 <merijn> ski: It's in the transformers I have...
13:29:19 <ski> oh, i must have missed when it was added, then
13:47:59 <merijn> I have found the magic invocation to simplify this
13:48:28 <merijn> Well, simplify might be overselling it...
13:50:11 <merijn> This works: https://paste.debian.net/1086454/
13:50:30 <merijn> Not sure whether I like it better or less than the existing one >.>
13:50:53 <solonarv> I think I prefer it, FWIW
13:51:25 <solonarv> I don't feel immediately attacker when I read it :P
14:20:10 <merijn> Anyone aware of a library that does pretty printing/formatting of time durations?
14:24:47 <monochrom> I don't know whether "time" has it, but I would take a look there.
14:25:06 <edwardk> does someone with older ghcs lying around want to test https://github.com/ekmett/bytestring/tree/no-offset ?
14:25:22 <edwardk> basically trying to shave a word from every bytestring
14:25:40 <edwardk> in theory this should work back to at least 7.0
14:25:43 <merijn> hmm, I guess NominalDiffTime has a FormatTime instance
14:26:14 <edwardk> but i haven't tested it below the current version
14:39:24 <phadej> edwardk: test as in "compile with" ?
14:39:43 <edwardk> yeah
14:40:08 <phadej> Not in scope: data constructor `I#' on GHC-7.0
14:40:17 <phadej> Data/ByteString/Internal.hs:156:65: Not in scope: `plusAddr#'
14:40:37 <phadej> I don't remember where they are
14:40:40 <edwardk> i kind of guessed as i didn't have an older version around to run
14:40:44 <edwardk> plusAddr# is in GHC.Prim
14:40:52 <edwardk> I# is in GHC.Types
14:41:11 <edwardk> i'll give you commit access to my fork
14:41:46 <edwardk> granted
14:43:39 <edwardk> installing 7.4 so i have _something_ in the right ballpark
14:47:53 <phadej> edwardk: pushed a commit
14:48:00 <edwardk> sweet
14:48:50 <edwardk> now to figure out how to benchmark the changes. davean is also poking at that
14:49:53 <edwardk> i can get rid of the need for the @ i think
14:49:54 <phadej> hmm, cabal thinks hard trying to find a plan to build tests
14:50:57 <davean> phadej: I've got that, see PM
14:51:07 <phadej> one would probably need to take test-suites out of the bytestring package to be able to build them
14:51:25 <davean> Nope, see pm
14:52:08 <edwardk> created #bytestring for this.
14:52:21 <phadej> I don't use v1-, that's the problem; I managed to keep 2 machines v1- clean for 3 years no ;)
14:52:40 <davean> phadej: well, I think hvr just told me how to get v2 working, but I haven't tested it
14:53:52 <zeta_0> what is the current ghc long term support version, and how much time is the lst version supported?
14:54:17 <davean> zeta_0: Thats not generally how Haskell works.
14:54:20 <merijn> zeta_0: There's not such thing as a long term support version for GHC?
14:54:37 <edwardk> phadej: can you try the current patch? i think i may have backported your tweaks to 800
14:55:22 <merijn> zeta_0: What do you want/need an long term support version for?
14:55:23 <phadej> edwardk: compiles with all eleven
14:56:04 <phadej> edwardk, davean: I'm going to sleep now, have to resist nerd-snipping myself into anything right now
14:56:08 <edwardk> sweet
14:56:15 <davean> phadej: wrong attitude ;)
14:56:17 <davean> (sleep well)
14:57:33 <phadej> from cubical agda to foreignptr in one IRC comment :/
14:58:41 <zeta_0> merijn: well i am using language server protocol, haskell-ide-engine, so i just wanted do know how the release cycle works so that i know how often i need to upgrade versions so that i can get the new updates and bug fixes if something is wrong with the software
15:05:32 <davean> zeta_0: Major releases are ATM generally every 6-ish months. patches are when problems occure and get fixed.
15:06:56 <lionrouge> hi !
15:07:50 <lionrouge> could you advice some books on Haskell for experienced programmers with background in Algol-like languages and LISP-like languages?
15:13:50 <edwardk> zeta_0: for the most part the compiler itself ships every 6 months to a year. libraries are generally pretty good about maintaining ~3 years worth of compilers worth of support for the most part
15:14:59 <edwardk> zeta_0: some of us maintain a significant number of libraries with support windows running back ~9 years (which is around when ghc 7.0 came out)
15:21:34 <zeta_0> oh ok, thanks for the info guys
15:30:14 * hackage hw-parser 0.1.0.1 - Simple parser support  https://hackage.haskell.org/package/hw-parser-0.1.0.1 (haskellworks)
15:45:13 <dukerutledge> Good evening all. I'm curious if anyone has ghc source plugin experience. I'm attempting to get `Fingerprint` from either `Module` or `Name` within the renaming phase. Is that possible?
15:48:44 * hackage rattletrap 9.0.1 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-9.0.1 (fozworth)
15:53:19 <Mrbuck> If I lack problem solving skills which language helps better Haskell or c++ ?
15:53:32 <Mrbuck> to learn from Scratch
15:53:43 <fragamus> omg haskell
15:54:53 <d34df00d> Arguably haskell.
15:54:58 <d34df00d> Less noise and boilerplate.
15:55:13 <d34df00d> And dancing around pointers, memory management, ownership, value categories and so on.
15:55:19 <fragamus> yeah
15:55:25 * d34df00d loves C++ the most among imperative languages.
15:55:32 <fragamus> you don't need that pointer stuff
15:55:49 <Mrbuck> good then
15:56:05 <jackdk> learning problem solving skills seems like  it will pay dividends over the long term?
15:56:50 <Mrbuck> ??
15:58:16 <Mrbuck> x = [1,2,3,4] if I have to add 1,2,3,4 without using a fucntion like sum how do you add, I couldnt do it so realized how bad I am
16:00:06 <monochrom> I would write my own recursive function.
16:00:37 <jackdk> I am a huge fan of Polya's "how to solve it", which you can find summaries of online
16:00:54 <ski> Mrbuck : `[1,2,3,4]' really means `1:2:3:4:[]', which is to be read as `1:(2:(3:(4:[])))'
16:00:59 <jackdk> it is a maths book, not a programming book, but it's got good advice
16:01:16 <jackdk> Mrbuck: and in the other direction, you know you want to get to 1 + 2 + 3 + 4
16:01:38 <ski> Mrbuck : `[]' is the empty list. if `x' is an element, and `xs' is a list of elements, then `x:xs' is the list that starts with the element `x', and continues with the elements in `xs'. so `:' "adds an element in front of a list of elements"
16:01:46 <ski> > 0:[1,2,3,4]
16:01:48 <lambdabot>  [0,1,2,3,4]
16:01:54 <Mrbuck> jackdk:  I will read it 
16:01:56 <ski> Mrbuck : okay ?
16:02:09 <Mrbuck> ski: thank you
16:02:40 <ski> Mrbuck : when you define a function, that takes a list as input, you can define separate cases for empty list, `[]', and non-empty list, e.g. `x:xs'
16:02:50 <ski>   mySumList [    ] = ...
16:02:59 <ski>   mySumList (x:xs) = ...
16:03:35 <ski> Mrbuck : so, you would have to say what the sum of an empty list of numbers should be, and also what the sum of a non-empty list of numbers should be
16:03:42 <jackdk> I have to go, but it sounds like you're in ski's capable hands. A lot of what he tells you will generalise, like how the structure of a recursive function often matches the structure of its constructors.
16:03:49 <Mrbuck> ok ski  
16:04:13 <ski> Mrbuck : do you have any idea how to fill in the `...' parts in the "template" code i provided ?
16:04:57 <Mrbuck> ski:  no actually sorry if I am to noob
16:05:05 <ski> what should the sum of an empty list be ?
16:05:11 <Mrbuck> 0
16:05:11 <fragamus> well that empty list case seems easy
16:05:14 <Mrbuck> nothing
16:05:17 <fragamus> yeah
16:05:18 <ski> why ?
16:05:35 <Mrbuck> it should be none type?
16:05:40 <Mrbuck> nothing is there
16:05:46 <Mrbuck> list is empty
16:05:53 <d34df00d> Mrbuck: what should be a product of values of an empty list?
16:05:55 <ski> well, if you add zero to any number, you get back that number
16:06:00 <d34df00d> That's kinda in line with ski's question.
16:06:17 * ski was thinking of also asking what d34df00d just did :)
16:07:06 <Mrbuck> anyway I will start learning again,I did few chapters of LYAH and then left now back again
16:07:23 <ski> you *could* define `mySumList' like
16:07:29 <ski>   mySumList [] = 0
16:07:31 <ski>   mySumList [a] = a
16:07:36 <ski>   mySumList [a,b] = a + b
16:07:40 <ski>   mySumList [a,b,c] = a + b + c
16:07:44 <ski>   mySumList [a,b,c,d] = a + b + c + d
16:07:45 <ski>   ...
16:07:49 <Mrbuck> https://math.hawaii.edu/home/pdf/putnam/PolyaHowToSolveIt.pdf  much appreciated
16:08:00 <ski> but there's infinitely many cases, so you'll never cover all of them, that way
16:08:32 <ski> and remember how `[a,b,c,d]' is `a:b:c:d:[]' is `a:(b:(c:(d:[])))'
16:08:48 <Mrbuck> ski: okay  thsi i remember now 
16:09:00 <ski> Mrbuck : btw, do you have an idea about d34df00d's question ?
16:09:23 <ski> iow, if you define
16:09:30 <ski>   myProductList [    ] = ...
16:09:37 <ski>   myProductList (x:xs) = ...
16:09:44 <ski> then what should the first `...' be ?
16:09:57 <ski> what is the product of a list of no numbers ?
16:10:21 <d34df00d> A good friend of mine is studying some other language know, but their book has some exercises like that (writing a sum function). I'm also throwing exercises like "write scanl (+) 0 or scanr (+) 0" (so that they don't care about the function passing part) to try to show them how to think recursively.
16:10:27 <ski> Mrbuck : you don't have to answer that now, if you don't want to. but it might be nice to ponder that question
16:10:28 <d34df00d> So I'm already going through something similar :)
16:10:40 <Mrbuck> ski:  am thinking
16:10:43 <ski> Mrbuck : anyway, would you like me to continue with `mySumList' ?
16:11:01 <glguy> It helps to consider that:    product (xs ++ ys) = product xs * product ys
16:11:05 <d34df00d> Mrbuck: if you'll think you find the answer for the product case, the grad level question would be "what is the minimum and maximum of an empty list".
16:11:14 * ski isn't sure Mrbuck has seen `++' yet
16:11:15 <Mrbuck> ski: can I come and ask the question again after few basics
16:11:25 <ski> Mrbuck : ask which question ?
16:11:28 <Mrbuck> because I asked that question for different language
16:11:39 <Mrbuck> using recursive is the answer I got
16:11:45 <Mrbuck> haskell I still need to learn
16:12:07 <glguy> ski: then it might be worth forgetting about numbers and just focusing on lists a bit
16:12:25 <ski> Mrbuck : generally, you do iteration/looping, with recursion, in Haskell. sometimes that's hidden behind higher-level combinators/operations, though
16:12:25 <Mrbuck> ++ ads right
16:12:41 <glguy> > [1,2,3] ++ [4,5,6]
16:12:44 <lambdabot>  [1,2,3,4,5,6]
16:12:47 <ski> `++' concatenates/appends two lists together
16:13:00 <Mrbuck> Okay 
16:13:02 <ski> glguy : yah, but they're asking about summing :)
16:14:01 <ski> Mrbuck : if you'd rather read (and experiment) on your own, for a while, that's fine
16:14:19 <ski> Mrbuck : btw, note that many of us here don't consider LYAH a that good resource to learn from
16:15:04 <d34df00d> ski: speaking of that.
16:15:21 <d34df00d> What'd be a good book to teach haskell to someone who has a very passing familiarity with programming?
16:15:31 <d34df00d> Like, close to zero experience with C++ and close to zero experience with JS.
16:15:43 <ski> perhaps
16:15:45 <ski> @where HPFFP
16:15:45 <lambdabot> "Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
16:16:00 <ski> (i haven't read it. but some seem to like it)
16:16:02 <Mrbuck> ski:  Okay I lack practise 
16:16:13 <Mrbuck> and I forgot basic haskell syntax also which i learned
16:16:14 <ski> Mrbuck : practice is good
16:16:22 <d34df00d> I've read the first chapter, it's neat. But they also don't have much of mathematical reasoning experience, so I was afraid it'll turn them off.
16:16:30 <Mrbuck> I didnt understand language but syntax i laerned ateastw hcih I forgot too
16:17:15 <ski> d34df00d : i learned from "Haskell: The Craft of Functional Programming" by Simon Thompson. but i started programming at age 6.5, so might not be the best person to ask this question
16:17:32 <Mrbuck> 6.5 ?
16:17:35 <Mrbuck> Serious ?
16:17:54 <d34df00d> I learned from RWH like 10 years ago, and otherwise I'd suggest that, but it seems a bit dated now.
16:18:02 <ski> i got a programmable (BASIC) pocket calculator with 544 bytes of RAM available for programs
16:18:03 <Mrbuck> I feel bad I can never reach ski  level
16:18:20 <d34df00d> There are always levels you cannot reach.
16:18:28 <Mrbuck> yes
16:18:32 <d34df00d> Better to observe them than being the smartest one in the room.
16:19:17 <ski> (also, i was interested in math, from early on. my older brother showed me factorization, primes, expressions, equations, functions and graphs, complex numbers, congruences / modulo, permutations, &c. at an early age)
16:19:46 <d34df00d> I hated math till I got in the university and got acquainted with group theory.
16:20:03 * ski wasn't really fond of school math either, until much later
16:20:04 <Mrbuck> ski:  my question for noe I want to learn problem solving as I am facing issues with other languages also. I do things like this : need some parser google and write it etc never learned a language from scatch
16:20:05 <d34df00d> That's beautiful as opposed to school-level trigonometry and basic real analysis.
16:20:26 <d34df00d> I loved physics a lot though. I thought I'd be a physicist when I grow up.
16:20:31 <d34df00d> Or is it physician in English?
16:20:45 <ski> (after doing four pages out of maybe ten of exercises on some topic, i was bored, and wanted to learn something else)
16:20:57 <Mrbuck> So I thought I should learn some langauge from scratch actually it has been from months but due to job and other things I couldnt do 
16:23:03 <ski> Mrbuck : if you're at all interested in math, i think the Polya book suggested could be useful, for problem solving. perhaps also "Proofs and Refutations" by Imre Lakatos could be interesting. it uses polyhedra (like tetrahedron,cube,&c.) as running example
16:24:06 <d34df00d> Math is big.
16:24:15 <ski> Mrbuck : perhaps also the slides "What is mathematical thinking, and why should we care?" by Dag Wedelin in 2018-02-08 at <http://www.cse.chalmers.se/~dag/pres/promFeb2018.pdf> could be interesting to check out. they're not really advanced, it's mostly "pretty pictures" and so
16:24:32 <Mrbuck> I am intrested in maths like lnear algebra or probability but not trgnometry, calculus etc
16:24:40 <d34df00d> I hate partial differential equations and barely passed the exam in my university, but I love logic and type theory, even though studying them in my free time now.
16:24:54 <d34df00d> Mrbuck: have you seen "Linear algebra done right"?
16:25:46 <Mrbuck> d34df00d:  what do you mean Linear algebra done right ?
16:25:57 <d34df00d> That's a book by Sheldon Axler.
16:26:01 <Mrbuck> I dont know what is type theory and logic 
16:26:02 <d34df00d> I really enjoyed going through it.
16:26:30 <Mrbuck> I am taking Linear Algebra course by professor strang on MIT
16:26:37 <Mrbuck> MIT courseware
16:26:55 <d34df00d> Pierce's "Types and Programming Languages" is a nice (and more CS-oriented) intro to formal thinking about types.
16:27:08 <d34df00d> "Type theory and formal proof" could be a reasonable next step.
16:27:27 <d34df00d> I also enjoyed a couple of books on formal logic, but they are in Russian so I'm not sure they'd be useful to you.
16:27:37 * ski . o O ( "Linear Algebra Done Right" (3rd ed.) by Sheldon Axler in 2015 at <http://linear.axler.net/> )
16:27:40 * ski . o O ( "Linear Algebra Done Wrong" by Sergei Treil in 2004 - 2017-09-04 at <https://www.math.brown.edu/~treil/papers/LADW/LADW.html> )
16:28:12 <d34df00d> ski: don't google what do people think about Aluffi's "Algebra: Chapter 0" which I'm literally doing an exercise from right now.
16:28:17 <ski> @where TaPL
16:28:17 <lambdabot> "Types and Programming Languages" by Benjamin C. Pierce in 2002-02-01 at <https://www.cis.upenn.edu/~bcpierce/tapl/>
16:28:23 <d34df00d> Much controversy! Such category theory! Wow!
16:29:01 <ski> d34df00d : hm, i think i recognize the name, but i don't think i've checked it out
16:29:43 <hpc> types, AND programming languages
16:29:45 <hpc> two for one!
16:29:55 <Mrbuck> I dont know programmers read these books 
16:30:06 <d34df00d> I wish I didn't.
16:30:26 <d34df00d> I could be happily programming python and doing machine learning earning $300k/sec if I didn't.
16:30:33 <d34df00d> learning earning
16:30:57 * ski . o O ( "Mathematics Made Difficult" by Carl E. Linderholm in 1972 at <http://i7-dungeon.sourceforge.net/math_hard.pdf> )
16:30:57 <fragamus> yeah but your soul would be infected
16:31:21 <fragamus> better to be poor with Hindley Milner
16:31:32 <d34df00d> But HM is boooring.
16:31:45 <d34df00d> Type systems with undecidable inference FTW!
16:31:58 <fragamus> yeah but our type system doesn't crash passenger planes
16:32:16 <d34df00d> You don't typecheck while flying do you?
16:32:18 <ski> d34df00d : "in russian" -- Kolmogorov ? Glivenko ?
16:32:27 <fragamus> just sayin
16:32:30 <d34df00d> ski: their "students". Vereschagin, Shen.
16:32:32 <Mrbuck> d34df00d:  i did not get you, if you had learned you would have done ir or if you hadnt you would have done it ?
16:32:36 <d34df00d> So his school, yes.
16:32:48 <fragamus> would you fly in a plane knowing that python code was flying it
16:33:27 <d34df00d> ski: that's the third book in the series — https://www.amazon.com/Computable-Functions-Student-Mathematical-Library/dp/0821827324 , in English.
16:33:30 <Mrbuck> and I also didnt see people talk about maths in other programming channels
16:33:34 <d34df00d> This one I didn't enjoy and dropped.
16:33:35 <epta> @where Principia Mathematica
16:33:35 <lambdabot> I know nothing about principia.
16:33:40 <epta> :(
16:34:09 <d34df00d> Vereshchagin goddamit. Those transcriptions. I wonder if an English-speaking person can pronounce this at all.
16:34:38 <hpc> in the end it's all just zygohistomorphic prepromorphisms
16:34:42 <d34df00d> Mrbuck: learning haskell in particular and some formal wannabe foundational math in general made me hate coding python.
16:34:59 <d34df00d> And that's why I'm moving away from ML (as in machine learning).
16:35:53 <Mrbuck> d34df00d:  then what do you do ? Why moving away from ML ? 
16:36:28 <d34df00d> Cause modern ML is all about `import tensorflow` in python, which is 1. non-rigorous and boring and 2. python.
16:36:38 * ski . o O ( Алекса́ндр Серге́евич Есе́нин-Во́льпин )
16:37:14 <Mrbuck> d34df00d: haskell wont help there ? I haerd tensorflow is there for haskell too 
16:37:27 <ski> epta : if you have a link, you're welcome to add it
16:37:51 <ski> d34df00d : Markov's school ?
16:37:57 <d34df00d> I'm starting a new job in a few weeks, and I'm gonna be doing some low-latency distributed stuff mostly in C++. I'm hoping to get enough money in the next couple of years to figure out where I'll be living for the rest of my live, and then move on to more PLT-oriented stuff.
16:38:24 <d34df00d> A job at Microsoft Research in the languages group would be a dream job frankly.
16:38:33 <d34df00d> But I don't have a PhD :(
16:38:45 <d34df00d> ski: probably yes. I'm not so sure about that though.
16:39:06 <d34df00d> Mrbuck: the problem is that a typical ML expert doesn't know and doesn't want to invest in knowing haskell.
16:39:44 <Mrbuck> what is PLT oriented stuff?
16:39:52 <ski> Programming Language Theory
16:40:13 <d34df00d> Yeah. That's probably an area where I could achieve something. Not shooting for more fundamental things.
16:40:18 <int-e> hmm... procedure lookup table?
16:40:37 <ski> Potstone Labba Tetartoid
16:40:43 <int-e> (I'm trying to remember the dynamic linking meaning of PLT)
16:40:55 <int-e> L = Linking.
16:41:07 <d34df00d> I wonder if I'll ever get my hands to https://people.mpi-sws.org/~dreyer/courses/catlogic/jacobs.pdf in my reading least, let alone understand even parts of it.
16:41:29 <ski> d34df00d : i've tried that book several times :)
16:41:43 <d34df00d> "several" :)
16:41:57 <ski> (no doubt i'll continue trying)
16:42:18 <ski> (ty for the link)
16:42:34 <d34df00d> So I want to get enough experience with applying CT via Aluffi, which will probably take me a year or so, and then I'll take a closer look at this one.
16:42:51 <d34df00d> Or maybe I'll try going through "Topoi" before that, it seems relevant.
16:43:00 <d34df00d> (Goldblatt's)
16:43:06 <ski> d34df00d : did you see Linderholm's book before ?
16:43:13 <d34df00d> Nope, what's that?
16:43:19 <ski> i mentioned it above
16:43:26 <d34df00d> Oh.
16:43:31 <d34df00d> Right, I even opened it.
16:44:03 <d34df00d> Nope. Added to the reading list though!
16:44:38 <Mrbuck> okay I am not fan of developing new programming languages and curious how https://people.mpi-sws.org/~dreyer/courses/catlogic/jacobs.pdf  can help programming
16:45:07 <ski> Mrbuck : at an abstract level, yes, i think so
16:45:51 <ski> Mrbuck : but probably mostly via people actually designing new programming languages
16:46:14 * hackage avro 0.4.4.3 - Avro serialization support for Haskell  https://hackage.haskell.org/package/avro-0.4.4.3 (haskellworks)
16:46:22 <d34df00d> Unlikely it can in general.
16:46:56 <ski> Mrbuck : in any case, that book is not for the faint of heart. it's certainly not something you'd probably even attempt, and your current level of understanding. you're welcome to try, of course
16:47:04 <Mrbuck> i glance dthrough that book andfound this :  CCompC  has  strong  equality  if  and  only  if  its  un-
16:47:06 <Mrbuck> derlying  fibration  has  fibred  equalisers.  
16:47:08 <Mrbuck> (ii)
16:47:10 <Mrbuck>   And  in  this  situation,   the  fibration  is  a fibred   LCCC.   
16:47:39 <ski> s/and your current/at your current/
16:48:01 <d34df00d> I'm using the ability to understand first few chapters^W paragraphs in that book as the benchmark for my mathematical maturity.
16:48:05 <d34df00d> I'm extremely immature so far.
16:48:09 <Mrbuck> ski:  I am not understanding anything 
16:48:24 <ski> Mrbuck : that's ok. i'm not understanding that much of it, either ;)
16:48:27 <Mrbuck> I pasted above and wondering what is it even mean and how is it related to programming
16:48:42 <ski> Mrbuck : Type Theory is related to programming
16:48:54 <ski> (and also to math)
16:48:57 <d34df00d> Mrbuck: I'd try taking a look at TAPL (mentioned earlier).
16:49:01 <d34df00d> That could be a good gateway.
16:49:19 <d34df00d> I've seen pdf's circulating freely somewhere.
16:49:23 * ski would probably suggest getting familiar with basic Haskell, before tackling TaPL
16:49:33 <Mrbuck> Yes
16:49:36 <d34df00d> TAPL is so much object-oriented.
16:49:41 <ski> (or SML or OCaml, say. doesn't have to be Haskell)
16:49:50 <d34df00d> I'm not sure you need haskell or any ml language if you skip the implementation chapters.
16:49:56 <d34df00d> Which is perfectly good for the first reading IMO.
16:50:02 <ski> d34df00d : well, existentials are important to understand
16:50:16 <Mrbuck> So if I am also intrested in maths and want to read books like you guys better stick to haskell only
16:50:17 <d34df00d> I better understood haskell existentials after I got through the metatheory in tapl.
16:50:20 <d34df00d> Not the vice versa :)
16:50:24 <ski> d34df00d : being familiar with recursion will probably help
16:50:25 <Mrbuck> and c++ programmers do same thing ?
16:50:30 <d34df00d> That's very true.
16:50:37 <Mrbuck> or no but I never seen any one talk maths
16:50:44 <d34df00d> Although it's a matter of doing math. But haskell may help doing the right math.
16:50:45 <ski> d34df00d : "I better understood haskell existentials after I got through the metatheory in tapl." -- that's what i meant, yes :)
16:51:01 <d34df00d> Mrbuck: I'm somewhat involved in the C++ community, and they rarely do that.
16:51:07 <ski> (also after reading some other papers, like)
16:51:16 <ski> @where polymorphic-type-inference
16:51:16 <lambdabot> "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <https://cs.au.dk/~mis/typeinf.p(s|df)>,<http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.57.1493>
16:51:20 <ski> @where on-understanding
16:51:20 <lambdabot> "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf>
16:51:23 <ski> @where on-understanding-revisited
16:51:23 <lambdabot> "On Understanding Data Abstraction, Revisited" by William R. Cook in 2009-10 at <http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf>
16:51:36 <d34df00d> And, again, to be frank, I enjoyed "Type theory and formal proof" more in some ways.
16:51:50 <d34df00d> I wish TTFP and TAPL had a kid, inheriting TAPL's rigour and TTFP's subject.
16:52:03 <ski> Mrbuck : C++ programmers do what ?
16:52:14 <d34df00d> Maybe that kid is "Types and proofs" or "Programming in Marin-Lof type theory", neither of which I have read yet.
16:52:24 <Mrbuck> ski:  I mean I never seen anyone talking about maths books like this
16:52:37 <Mrbuck> in other programming channels
16:52:52 <Mrbuck> so wondering if haskell more math type
16:52:56 <Mrbuck> than other languages
16:53:11 <d34df00d> At least it attracts this sort (or kind?) of people.
16:53:13 <ski> d34df00d : "Proofs and Types" is nice. also Martin-Löf's original type theory notes at <https://intuitionistic.wordpress.com/works-on-martin-lofs-type-theory/>
16:54:22 <ski> d34df00d : oh, and the "On the meaning of ..." paper there is also interesting
16:55:07 <d34df00d> So much more stuff to read!
16:55:17 <d34df00d> Too bad I cannot read much of hard stuff in parallel.
16:56:03 * ski . o O ( "So little time, so many backs to stab." -- Shadows of Amn )
16:56:30 <d34df00d> I just noted the first dot in some of your messages and realized it's a bubble.
16:56:40 <ski> yes
16:56:41 <d34df00d> Before I only thought it's a surprised face.
16:57:03 <d34df00d> Which wasn't exactly matching context sometimes.
16:57:03 <Mrbuck> ski: please tell me haskell your primary language ? You also use many langauges ?
16:57:16 <ski> Mrbuck : i'm rather fond of Prolog, as well
16:57:36 <Mrbuck> prologcan do anything haskellcan do ?
16:57:43 <ski> Prolog is different
16:57:48 <Lycurgus> utterly
16:57:48 <halogenandtoast> very different
16:57:54 <d34df00d> It can take forever to execute more efficiently.
16:57:59 <d34df00d> (from what I know)
16:58:02 <ski> Haskell is a Functional Programming language
16:58:08 <ski> Prolog is a Logic Programming language
16:58:22 <Mrbuck> bth declarative that I know
16:58:30 <Mrbuck> but why you like it
16:58:35 <d34df00d> I've also seen people implementing Prolog-like stuff in GHC type inference engine.
16:58:40 <ski> instead of programming with functions and expressions, you program with relations/predicates and logical formulae
16:58:49 <Lycurgus> 2 ball breakers to learn
16:58:57 <halogenandtoast> this is the only prolog I have probably ever written https://github.com/halogenandtoast/randl/blob/master/prolog/main.pl
16:59:05 <Lycurgus> that's the same, but it's moreso for hs
16:59:21 <ski> d34df00d : but you don't get any nondeterminism, so it's less powerful there
17:00:09 <halogenandtoast> The zip function is a good example of how different Prolog is
17:00:11 <d34df00d> That is true.
17:00:39 <Lycurgus> people who like lisp in java will prolly love prolog in haskell
17:01:54 <ski> halogenandtoast : i'd drop the `shuffle([], []).' part since it's redundant (you get duplicate solutions). ditto for `print_pairs([]).'
17:02:17 <ski> (personally i'd also rename main/0 to go/0 ..)
17:03:10 <ski> Lycurgus : do you mean like Clojure or Kawa or ?
17:03:36 <Lycurgus> clojure, didn know from kawa
17:03:46 <ski> Lycurgus : you-know-who is implementing CL in Prolog :)
17:03:58 <Lycurgus> yeah
17:04:27 <halogenandtoast> ski: I made teh suggestion you provided ;)
17:04:39 <halogenandtoast> *the, *suggestions
17:05:03 <ski> halogenandtoast : the go/0 thing is just a convention, of course
17:05:57 <halogenandtoast> sure, I figured as much
17:06:10 <halogenandtoast> but might as well take feedback from someone who actually does some prolog
17:06:14 <halogenandtoast> I generally do none.
17:07:07 <Lycurgus> it's second only to lisp as far as AI legacy resources are concerned
17:07:39 <ski> "Prolog: Programming for Artificial Intelligence" by Ivan Bratko is a nice book. first part is an introduction to Prolog
17:08:17 <ski> iirc "The Art of Prolog" by Leon Sterling,Ehud Shapiro also has AI-related stuff ?
17:08:47 <ski> @where AIMA
17:08:48 <lambdabot> "Artificial Intelligence: A Modern Approach" by Stuart Russell,Peter Norvig in 1995,2003,2009-12-11 at <http://aima.cs.berkeley.edu/>,<https://people.eecs.berkeley.edu/~russell/aima1e.html> (1st ed.)
17:09:03 <ski> i think that mentions Prolog, and Stickel's PTTP, a little ?
17:09:10 <Lycurgus> yeah but it's more prolog programming and basics oriented but does have chapters
17:09:17 <Lycurgus> (Art of)
17:09:17 * ski nods
17:12:02 <ski> anyway, for anyone who found Functional Programming interesting, i also recommend looking into Logic Programming (like e.g. Prolog), at some point
17:14:44 <halogenandtoast> ski: you probably don't speak Japanese, but this guy posts interesting prolog things all the time: https://twitter.com/TakaoOzaki
17:16:36 <Lycurgus> igess code is still always english
17:16:42 <Lycurgus> even in 2019
17:16:49 <ski> he looks cool, too :)
17:17:00 <Lycurgus> yeah like sensei oder
17:17:44 <ski> i suppose he's an oldtimer from the 5th generation project ?
17:18:03 <sm[m]> ski is there a prolog in haskell lib that you'd recommend as a practical tool ?
17:18:59 <ski> sm[m] : if you're just after the nondeterminism, i think you could check out `LogicT' ?
17:19:10 <ski> sm[m] : for logic variables, i'm not sure
17:20:04 <ski> (i mean, i did write a prototype, at one point, having a novel extension relating to backtracking (and also to logic variables and skolems), namely implication goals (that can be nested))
17:20:19 <ski> (s/nested/left-nested/)
17:20:34 <ski> sm[m] : i think there's also some constraint solver thingies ?
17:21:11 * ski hasn't tried any
17:21:34 <sm[m]> ski: thanks. I'd like to be able to try some of those tools next time I have a problem they suit. And in fact, I have one right now..
17:22:18 <sm[m]> a very simple one: given a set of exchange rates between currency pairs, find a shortest path between two given currencies
17:22:53 <sm[m]> or is this a graph problem
17:23:20 <sm[m]> I think so. It's too simple for prolog/logicT
17:23:51 <ski> sounds like a graph problem. but possibly one could use constraints for the "shortest path" ? hmm
17:24:12 <ski> (i suppose it's probably overkill)
17:24:44 <dolio> It seems like a graph algorithm is going to be more efficient than a prolog-like solution.
17:24:48 <dolio> For that problem.
17:25:49 * sm[m] thinks about how to distinguish graph problems from constraint solving problems
17:27:35 <sm[m]> thanks
17:29:23 <sm[m]> logict, would it have killed you to provide one (1) example
17:30:42 <dolio> Yes.
17:31:47 <dolio> http://homes.sice.indiana.edu/ccshan/logicprog/LogicT-icfp2005.pdf
17:32:58 <fragamus> ?
17:33:30 <sm[m]> that's not the same
17:36:11 <sm[m]> or a single test
17:36:18 <sm[m]> I guess it's an aesthetic thing
17:36:36 <nshepperd> ersatz is kind of like prolog... i think
17:41:47 <sm[m]> cool stuff.. more understanding later perhaps  o/
17:48:40 <ben_m> Hi everyone, I was just looking for the most idiomatic way to write something like `takeUntilDuplicate` and stumbled upon an implementation using foldr that I'm having a really hard time wrapping my head around: https://gist.github.com/bmeinl/7da76ed338e1cac19a2f9cba3703042d - Anyone got any hints for how to get an intuitive understanding of that sort of thing? 
17:53:35 <halogenandtoast> Anyone know if there is a good way to load jpgs in Gloss?, I see there is a gloss-game package but stack doesn't like it
17:55:06 <MarcelineVQ> halogenandtoast: probably juicy
17:55:41 <wrunt> ben_m: the author of that code recommended 'A tutorial on the universality and expressiveness of fold' by Graham Hutton for explaining the technique
17:56:25 <halogenandtoast> MarcelineVQ: I will check it out, thanks!
17:57:51 <ski> nshepperd : there should be more packages stealing terms from philosophy
17:57:58 <MarcelineVQ> ben_m: http://web.archive.org/web/20180522150722/http://ertes.eu/tutorial/foldr.html
17:58:11 <ben_m> wrunt: I saw that but like most papers it looks quite academic, so it scared me off. I'll try and give it a read.
17:58:21 <MarcelineVQ> ben_m: work through that from the start and you'll be in a good spot
17:58:43 <ben_m> MarcelineVQ: Thanks, that looks great.
17:59:13 * hackage network-byte-order 0.1.0.0 - Network byte order utilities  https://hackage.haskell.org/package/network-byte-order-0.1.0.0 (KazuYamamoto)
18:00:00 <ski> (MarcelineVQ : hm, now i vaguely recall someone mentioning ertes disappearing ?)
18:00:13 <MarcelineVQ> ski: iiuc he passed away, details unknown to me
18:00:19 <ski> okay
18:01:21 * ski also wonders what happened to TheHunter,mmorrow,Pseudonym,..
18:02:33 <MarcelineVQ> ski: Of all the concepts humans choose to obey, linear time is probably the worst.
18:03:50 * ski idly wonders what MarcelineVQ means
18:03:55 <MarcelineVQ> All the questions and ideas that pops up in your head are correct :>
18:04:11 <MarcelineVQ> *pop up in your head in response
18:07:09 <halogenandtoast> I am pretty sure ertes passed away a year or two ago now
18:08:01 <halogenandtoast> around May 2018
18:08:14 <halogenandtoast> and that was a huge loss to our community
18:09:32 * ski nods
18:10:54 <blackandblue> halogenandtoast: dont lie please
18:10:57 <blackandblue> halogenandtoast: https://wiki.haskell.org/User:Ertes
18:11:04 <blackandblue> halogenandtoast: he is 25 years old
18:11:38 <halogenandtoast> blackandblue: https://www.reddit.com/r/haskell/comments/8l7j5z/ertugrul_s%C3%B6ylemez_19852018/
18:12:14 <blackandblue> do you have a pic of him?
18:12:25 <blackandblue> is he the one livestreaming haskell on twitch?
18:12:58 <halogenandtoast> isn't that bitemyapp?
18:13:04 <blackandblue> no
18:13:08 <lyxia> edward streams
18:13:15 <blackandblue> oh yea
18:13:17 <halogenandtoast> Oh yeah edwardk does
18:13:18 <blackandblue> that guy
18:13:21 <blackandblue> he is still alive?
18:13:24 <halogenandtoast> Yes
18:13:28 <halogenandtoast> Last I checked
18:13:31 <blackandblue> great. I like his streams
18:13:33 <MarcelineVQ> edwardk: you alive?
18:13:39 <edwardk> yep
18:13:42 <MarcelineVQ> phew
18:13:45 <blackandblue> this is so fake news. https://byorgey.wordpress.com/2018/05/21/ertugrul-soylemez-1985-2018/
18:13:51 <blackandblue> got news from irc ?
18:13:51 <ski> edwardk : are you *really* sure ?
18:13:56 <blackandblue> not family member instead?
18:14:11 <MarcelineVQ> but that is news from irc..
18:14:12 <edwardk> ertugral /= edward
18:14:33 <halogenandtoast> blackandblue: I didn't stalk the situation, I remembered the post, and haven't seen ertes since so I don't have any reason not to believe it.
18:14:42 <blackandblue> edwardk: I like it when you keep eating during streams. not joking btw
18:14:57 <shachaf> blackandblue: This is really not the place for that. If you have information about him or objections to that post, please mention it in #haskell-ops.
18:15:00 <blackandblue> halogenandtoast: could be that life happened. no more time for irc.
18:15:04 <MarcelineVQ> gotta keep your energy up, coding is all about energy, that's why people listen to music
18:15:04 <edwardk> blackandblue: they run like 8 hours or so usually, so i need to do something to avoid passing out ;)
18:15:33 <edwardk> i should stream some more stuff soon
18:15:51 <blackandblue> edwardk: I really appreciate your work man! keep it up. however one suggestion is : cater your information in a way that beginners can understand too. 
18:15:54 <edwardk> i've been kind of in a mode where what i'm working on spreads me across a ton of monitors as it doesn't fit well in a single text editor
18:16:01 <edwardk> so i've been loathe to start a stream on it
18:16:22 <edwardk> blackandblue: i suck at that. i figure the rest of the ecosystem offers that, but there isn't a lot of high end content
18:16:23 <blackandblue> MarcelineVQ: I cant code while listening to music. its distraction
18:16:43 <halogenandtoast> blackandblue: this probably isn't the place to discuss, but their website expired, github shows no activity, not sure why you want to disbelieve it
18:16:48 <edwardk> if i had 5x the effort to put in, i could cater to that niche
18:17:23 <ski> blackandblue : any music at all ? or music with vocals in it ?
18:17:35 <blackandblue> any music
18:17:44 <blackandblue> do you have any thats not distraction?
18:17:46 <blackandblue> while coding?
18:17:57 <jackdk> edwardk: get a fat pipe and run 5 streams in parallel
18:18:06 <Rod0990> Hello
18:18:07 <edwardk> i have two modes. one mode is the 'no distraction mode' the other is 'just letting things blare and coding'
18:18:14 <ski> hello Rod0990
18:18:22 <Rod0990> Pretty new to IRC here
18:18:35 <halogenandtoast> Howdy Rod0990 welcome to IRC
18:18:42 <edwardk> the former is more relevant for debugging, the latter is much like the headspace i get into on twitch where i know generally what to do and just need the energy to do it
18:18:54 <blackandblue> edwardk: do you listen to music in no distraction mode?
18:19:05 <edwardk> in no distraction mode i don't
18:19:07 <maerwald> I feel if you already know in your mind how you want to approach a problem it helps to add a little bit of rhythm so you stop overthinking.
18:19:48 <edwardk> maerwald: my version of that is just staying up way too late and carrying on coding because i don't want to commit broken code... then i get into the same strung out sleepy headspace where i stop second guessing myself
18:20:03 <maerwald> hehe
18:20:22 <MarcelineVQ> "<blackandblue> do you have any thats not distraction?" absolutely, but I sense they would distract you
18:20:38 <blackandblue> MarcelineVQ: surprise me
18:20:39 <MarcelineVQ> can share in #haskell-offtopic if you have interest
18:20:49 <blackandblue> ok
18:21:43 * hackage pkgtreediff 0.2 - Package tree diff tool  https://hackage.haskell.org/package/pkgtreediff-0.2 (JensPetersen)
18:24:51 <ski> Rod0990 : if you have any question, just ask
18:51:43 * hackage hkd-delta 0.0.1 - Definition of "Delta structures" for higher kinded data.  https://hackage.haskell.org/package/hkd-delta-0.0.1 (trevorcook)
20:04:11 <maerwald> how do you get the current timestamp of your hackage index in unix time with cabal?
20:24:37 <jaexil-gh-maitre> https://mapio.net/pic/p-47230385/
20:25:03 <jaexil-gh-maitre> https://en.m.wikipedia.org/wiki/Brighton_Beach
20:39:49 <ski> jaexil-gh-maitre : hmm .. sounds seem to be Haskell-related, to me
20:40:55 <monochrom> Do you mean s/sounds/doesn't/
20:40:59 <ski> er, hrm, s/sounds/doen't/
20:41:01 <ski> yea
20:41:07 <monochrom> Yeah was about to kick.
20:41:08 * ski is a bit sleepy atm
20:41:44 <ski> they don't seem to have said anything in my backlog, apart from posting links, and being kicked (or K-lined) for it
20:42:10 <monochrom> OK!
20:42:12 --- mode: ChanServ set +o monochrom
20:42:41 --- mode: monochrom set +b *!*@gateway/shell/matrix.org/x-xniagavhvcwqbstc
20:42:41 --- kick: jaexil-gh-maitre was kicked by monochrom (jaexil-gh-maitre)
20:43:21 <monochrom> I wonder how useful is the string "xniagavhvcwqbstc"
20:43:29 --- mode: monochrom set -o monochrom
20:43:35 <ski> it seems they've always been on a username starting with `jaexil-', as well as connecting with <matrix.org>
20:43:46 <monochrom> Ah thanks
20:43:49 <ski> however, the `xniagavhvcwqbstc' part has varied
20:43:49 --- mode: ChanServ set +o monochrom
20:44:06 <ski> (and that's just from the backlog in by client. i haven't checked logs further back)
20:45:04 --- mode: monochrom set -b+b *!*@gateway/shell/matrix.org/x-xniagavhvcwqbstc jaexil*!*@gateway/shell/matrix.org/*
20:47:34 <Mrbuck> hi we can use mtplotlib even with haskell right ?
20:47:58 * ski has no idea what that is
20:48:23 <Mrbuck> matplotlib is a python library to plot
20:48:35 <ski> i see
20:48:41 <Mrbuck> https://matplotlib.org/
20:52:35 --- mode: monochrom set -o monochrom
21:15:41 <jle`> Mrbuck: the easiest way to use matplotlib is with python
21:16:01 <Mrbuck> jle`: Yeah
21:16:28 <Mrbuck> no similar libraries in haskell I think
21:17:48 <jle`> there are some similar libraries in haskell, i believe
21:17:54 <jle`> but none of them are as widely used as matplotlib
21:18:09 <Mrbuck> okay can I know the name 
21:18:26 <jle`> probably the best way to use matplotlib with haskell (if you really really wanted to) is with one of the haskell-python bridges we have
21:18:56 <Mrbuck> okay i dont want to use right now anyway
21:19:01 <Mrbuck> I willcometoit later thank you
21:19:08 <jle`> i can't recall right now, but you might be able to find some help at https://www.datahaskell.org/ , or the chatroom there
21:19:11 <jle`> (gitter)
21:20:50 <Mrbuck> Okay thank you 
21:21:14 <crestfallen> hi Bartosz Milewski is lecturing on functions denoted as exponentials, where (a -> b) is in math b^a. could anyone tell me if he makes an error at 49:45, where he is saying that color (3 for 3 primary colors) is raised to boolean (2)? He says it's 3*3*3. (he then asks the audience if they are checking his math). https://www.youtube.com/watch?v=LkqTLJK2API   thanks
21:23:09 <shachaf> crestfallen: Yep, looks like an error.
21:23:28 <shachaf> It's the thing you think it is.
21:23:56 <crestfallen> excellent shachaf thanks for checking that
21:28:26 <dmj`> did David Turner ever open source miranda
21:38:29 <Mrbuck> i was actually asking C++ vs haskell and this video https://www.youtube.com/watch?v=LkqTLJK2API   helped me 
21:38:39 <Mrbuck> thanks crestfallen  for postong
21:38:46 <Mrbuck> posting*
21:53:08 <crestfallen> Mrbuck sure, I get a lot from that guy.
22:55:51 <jusss> what are higher-order logic and first-order logic?
23:03:40 <jackdk> is that a question that could be answered with a web search, or have you tried that already and bounced off the resources you have found?
23:04:07 <jackdk> (if the latter, that is useful information to help you get a good response from IRC)
23:18:12 <jusss> ok
23:19:14 * hackage random-bytestring 0.1.3.2 - Efficient generation of random bytestrings  https://hackage.haskell.org/package/random-bytestring-0.1.3.2 (larsk)
