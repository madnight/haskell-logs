00:07:16 <solonarv> myme: the syntax is <package>:<component-type>:<component-name>
00:07:22 <myme> solonarv: Thanks.
00:07:39 <solonarv> you can omit parts of that if it's still unambiguous
00:10:29 <myme> solonarv: I'm trying out multi-package/monorepo support in the new apis. cabal.project file with three packages.
00:10:58 <myme> So moving away from stack to nix + cabal I had to figure some new things out.
00:13:12 <myme> Would think that "i3ws:exe" (sub-project:exe) would select the only executable in the "i3ws/i3ws.cabal" file.
00:16:15 <solonarv> it does sound that way, but perhaps cabal wants you to specify the executable's name anyway
00:33:57 <myme> solonarv: Could be.
00:34:05 <myme> Thanks though. Got what I needed!
01:23:42 <saurabhnanda> how does one convert a custom DataKind back to value-level?
01:31:42 <dminuoso> saurabhnanda: Do you have an example of what you are trying to do?
01:35:31 <saurabhnanda> dminuoso: here's a short gist - https://gist.github.com/saurabhnanda/20df208f9dd89c1f21f931e42952d79a
01:36:14 <saurabhnanda> given the TYPE `ps` of kind `[Permission]`, I need to get `xs` of type `[Permission]`
01:37:11 <Axman6> that's what the singletons package does
01:37:27 <solonarv> normally you cannot do this: types are erased, so you can't find out at runtime what the type was
01:37:46 <solonarv> however using a typeclass or equivalent mechanism, you can remember the type
01:39:54 <dminuoso> % :t withSomeSing -- saurabhnanda 
01:39:54 <yahb> dminuoso: ; <interactive>:1:1: error: Variable not in scope: withSomeSing
01:40:00 <dminuoso> % import Data.Singletons
01:40:00 <yahb> dminuoso: ; <no location info>: error:; Could not find module `Data.Singletons'; It is not a module in the current program, or in any known package.
01:40:06 <dminuoso> Bah fine.
01:40:11 <dminuoso> saurabhnanda: https://hackage.haskell.org/package/singletons-2.5.1/docs/Data-Singletons.html#v:withSomeSing
01:40:47 <dminuoso> Oh wait you want the other way around
01:40:55 <solonarv> you can also just hand-roll the typeclass; I gave a sketch as a comment on your gist
01:40:58 <solonarv> saurabhnanda: ^
01:41:28 <dminuoso> https://hackage.haskell.org/package/singletons-2.5.1/docs/Data-Singletons.html#v:fromSing I guess?
01:43:03 <solonarv> singletons also has a generalized version of this typeclass, IIRC it's called Demote
01:44:27 <solonarv> ah yes, dminuoso and I were talking about the same thing :P
01:44:28 <saurabhnanda> how does singletons do this internally? TemplateHaskell?
01:44:36 <dminuoso> saurabhnanda: Well Demote is an associated type family
01:44:42 <dminuoso> solonarv: SingKind is the typeclass :)
01:44:55 <solonarv> there is template haskell to write the Sing instances, but you could hand-roll them too
01:45:17 <dminuoso> saurabhnanda: https://blog.jle.im/entry/introduction-to-singletons-1.html (and the following 2 parts) gives a good rundown.
01:45:23 <solonarv> TH is never "sneaky" - you always know when you are running TH, because the only way TH generates code is if you explicitly write a splice
01:45:29 <dminuoso> saurabhnanda: Starting from the motivation to the implementation and then making the connection to the singletons package.
01:45:56 <saurabhnanda> If I use the type-class approach, and want to hand-roll this on my own, I understand how to go from a single Permission KIND to a single Permission VALUE. But how do I do that with a list?
01:46:10 <dminuoso> solonarv: But it is sort of sneaky since top level splices can be very non-visible. $() are sadly optional. :(
01:46:22 <dminuoso> At least for top level splices.
01:48:28 <saurabhnanda> solonarv: thanks for the comment on my gist. Let me hand-roll this first based on your example. Will introduce singletons once I have solved my original problem and need to scale this to dozens of permissions.
01:48:44 <solonarv> dminuoso: indeed
01:49:14 <solonarv> but that syntax is still not legal as anything other than TH - so it is a bit sneaky, but if you pay attention you still see that it is TH
01:50:10 <bollu> saurabhnanda hello! :) 
01:50:27 <saurabhnanda> bollu: hey :) long time... 
01:50:50 <bollu> saurabhnanda Indeed :) How's haskell going for you? For a while I was worried you'd dropped haskell since there weren't any new blog posts ;) 
01:51:16 <saurabhnanda> bollu: lot of stuff happening with the business. Just started hands-on Haskell coding again :)
01:51:36 <jgt> oh hey saurabhnanda / Jezen Thomas
01:51:45 <bollu> ahh, great!
01:52:30 <saurabhnanda> jgt: hey, how's it going :)
01:52:51 <solonarv> saurabhnanda: added another comment with the singletons-based approach
01:53:19 <saurabhnanda> solonarv: just saw that -- singletons doesn't look that complicated when using. Let me see if I can use it rightaway.
01:53:25 <solonarv> which ends up being very similar to use, you just don't need to write as much boilerplate
01:53:30 <solonarv> yeah, sometimes it's nice to use
01:53:49 <jgt> saurabhnanda: not bad! Haskelling every day. I remember quite a while ago I encouraged you to start looking into Elm for VL, and more recently I watched one of your talks and it looks like you're using Elm quite a lot. I thought that was pretty cool :)
01:53:53 <saurabhnanda> jgt: how's New Business Monitor?
01:54:30 <saurabhnanda> jgt: yes, writing a bunch of UI in Elm. Although not moved from 0.18 to 0.19 yet
01:54:56 <jgt> saurabhnanda: still ticking along nicely, and paying my rent. It's not my main gig; I have another larger Haskell project which has some VC funding and I've hired some guys to work with me on it. Pretty much the same tech setup.
01:55:24 <saurabhnanda> jgt: is that riskbok?
01:55:28 <jgt> it is!
01:56:03 <saurabhnanda> jgt: haskell + elm at riskbook, is it?
01:57:03 <saurabhnanda> https://riskbookltd.com -- ah the curse of SaaS websites. I can't complain. Even VL does something similar. But I'm surprised how all of this ends up looking so sam!
01:58:58 <jgt> saurabhnanda: yeah, but far more Haskell than Elm currently. Trying to be conservative with Elm use, especially at this earlier stage. And yeah, I'm not thrilled about the new cookie-cutter landing page design, but you know, you have to be careful with which battles you choose to fight :P
01:59:36 <saurabhnanda> solonarv: https://gist.github.com/saurabhnanda/20df208f9dd89c1f21f931e42952d79a#gistcomment-2955388 should be there in the singleton docs. They are very daunting, curently.
02:00:02 <saurabhnanda> solonarv: I mean, a simple real-life usage example. "Get started NOW" kind of stuff. 
02:18:31 <Synthetica> I'm using genvalidity-hspec, and one of my types is acting strangely. Hspec reports the same thing for "expected/but got", but still gives an error: https://gist.github.com/Synthetica9/b7d152810c772c30df6806773e258684
02:19:49 <Synthetica> (This is with the derived Show instance)
02:20:01 <dminuoso> Synthetica: Is your Eq instance borked perhaps?
02:21:49 <Synthetica> dminuoso: I have it so that `UP (1, 2) == UP (2, 1)`, but that shouldn't be a problem right? There are more types that don't follow structural equality
02:22:33 <dminuoso> Synthetica: What are GraphF and UnorderedPair exactly?
02:23:17 <Synthetica> dminuoso: https://gist.github.com/Synthetica9/3ba020cad8911ea3f7f17633b74a9739
02:23:31 <dminuoso> I mean Im presuming that `data UnorderedPair a b = UP (a, b)` and `type GraphF t a = Connect (t a)
02:23:37 <dminuoso> Oh
02:24:10 <dminuoso> Synthetica: What about the Eq instance of GraphF and UnorderedPair?
02:25:01 <Synthetica> The GraphF one is kind of involved, but I'm very convinced that it works correctly because it gets through all tests for `GraphF OrderedPair`
02:25:41 <dminuoso> Synthetica: Im just thinking that if your Eq instance violates reflexivity, it would explain the error.
02:25:57 <Synthetica> https://gist.github.com/Synthetica9/a787dc82748006148c9e86b4c44728cf
02:26:12 <Synthetica> Where convPair converts to tuple and mirror is swap
02:26:36 <Synthetica> Wait
02:26:38 <Synthetica> I'm an idiot
02:26:40 <dminuoso> Synthetica: :)
02:26:54 <Synthetica> Thank you :)
02:30:09 <Synthetica> Yeah, it works fine now that the ord instance actually works ü§¶‚Äç‚ôÄÔ∏è
02:30:15 <Synthetica> `185 examples, 0 failures`
02:41:40 <Phyx-> sm[m]: that's not really a Windows issue. a trailing . at the end of a filename has no significance to the filesystem *or* most win32 api calls. The reason MSDN explicitly calls this out and says not to do it is because a lot of tools, like explorer normalize the paths before use, so explorer doesn't support files ending with ., but e.g. cmd.exe does.
02:42:18 <Phyx-> sm[m]: the problem in your issue seems to be that something in your code at some point does normalize the paths, and your ending . goes away then.
02:50:00 <sm[m]> Phyx-: thanks. I admit I haven‚Äôt debugged it myself and don‚Äôt know exactly where the period is ignored/discarded
02:50:23 <sm[m]> Those stack exchange threads seemed persuasive
02:53:34 <Phyx-> sm[m]: my guess is, you have one version of the path being used as is, and one being used after a call to https://hackage.haskell.org/package/filepath-1.4.2.1/docs/System-FilePath-Windows.html#v:normalise which explicitly states it'll remove trailing . on both Windows & Posix paths.
02:54:36 <Phyx-> sm[m]: Unfortunately Windows paths are wildely misunderstood. The OS/filesystems itself often doesn't have any of the limitations, e.g. MAX_PATH. But accessing paths using legacy modes/apis will inflict legacy restrictions on said paths.
02:56:09 <[exa]> like, can you finally create a file named 'prn' on windows?
02:56:24 <Phyx-> [exa]: if you mean since NT 4 yes
02:56:27 <sm[m]> Thanks! I‚Äôll note this
02:56:43 <[exa]> Phyx-: I tried on windows 10 home, no success. :D
02:56:56 <Phyx-> [exa]: because you used the wrong path type
02:57:05 <Phyx-> \\?\C:\PRN is perfectly valid.
02:57:24 <[exa]> whats the \\?\ part?
02:58:04 <[exa]> (ok I'm going offtopic, but that kind of things is scary on windows, even simple paths contain this amount of complexity)
02:59:17 <sicklorkin> \\ <- is that some kinda network volume?
02:59:28 <Phyx-> that's why you abstract it away behind tools that know how to behave, GHC and directory will automatically convert "normal" paths to deice paths now. So you don't have these issues
03:00:27 <Phyx-> sicklorkin: no, \\ is syntactic sugar, just like volume letters (e.g. C:). \\<foo> what is known as network/UNC paths in Win32 namespace, is actually \\?\UNC\<foo>
03:00:39 <Phyx-> \\?\ indicates to the APIs to not do any processing of the paths
03:01:12 * sicklorkin head just exploded
03:01:21 <Phyx-> so they won't apply old constraints on them. conversely they also won't correct / to \, so with such file paths you *can* have a file with / in the name
03:01:44 <[exa]> sicklorkin: your feeling is shared.
03:02:06 <Phyx-> C:\<foo> is really just \\?\C:\<foo> which is really just \\?\Volume{hash-id}\<foo>
03:02:22 <sicklorkin> Phyx-: what if the UNC name was C:\?
03:02:31 <Phyx-> the kernel doesn't know anything about C:, that's just a usermode concept. 
03:02:51 <Phyx-> you can see this if you type "mountvol" which is window's "mount" equivalent, it'll show you your actual mount points
03:03:16 <Phyx-> sicklorkin: you mean \\?\
03:03:35 <Phyx-> sicklorkin: you mean \\<location\C:\?
03:04:30 <Phyx-> oh and conversely, "raw" device access is done though \\.\, the . there means device namespace, so it would allow you to open COM1, PRN, etc, or USB ports directly as a file
03:06:02 <lavalike> I recently learned the explorer nav bar interprets a whole lot of things like this https://ired.team/offensive-security/code-execution/forcing-iexplore.exe-to-load-a-malicious-dll-via-com-abuse#shell
03:06:08 <sicklorkin> Phyx-: ignore me.. i was thinking about references networks shares.. \\hostname\C$ for example. and was wondering what it might look like if the host was named C:\
03:07:53 <Phyx-> sicklorkin: no, the C$ is just a special token to say that it's a remote label
03:11:06 <Phyx-> lavalike: protocol handlers are nothing new :) it's same way that url:// works to open your default browser. shell:: is just a special one. There are a couple of "special" ones like naming a folder "<name>.{ED7BA470-8E54-465E-825C-99712043E01C}" Will make it show a control panel item with every possible thing as an entry
03:11:11 <Phyx-> etc
03:14:21 <akr> is there any good reason why Data.ByteString.Lazy's readFile should produce a stack overflow when reading a 600kB PDF file?
03:14:51 <akr> ahh no nevermind
03:19:54 <akr> was there a time when Prelude's any wasn't tail-recursive?
03:21:03 <akr> doesn't seem like it
03:21:30 <akr> must've been getDirectoryContents from System.Directory then
03:22:18 <akr> producing a stack overflow when run on a directory with many files
03:23:13 <akr> (about half a million files)
03:37:02 * DigitalKiwi dares you to attempt tab completion in that directory
04:24:34 <aveltras> anyone using lsp with emacs ? is it stable ?
04:25:08 <dminuoso> Is there a way to specify multiple deriving via without DerivingStrategies?
04:25:34 <dminuoso> % newtype F = F String deriving (Eq, Ord) via String
04:25:34 <yahb> dminuoso: ; <interactive>:52:1: error:; Illegal deriving strategy: via; Use DerivingVia to enable this extension
04:25:38 <dminuoso> % :set -XDerivingVia
04:25:39 <yahb> dminuoso: 
04:25:51 <dminuoso> % newtype F = F String deriving (Eq, Ord) via String
04:25:52 <yahb> dminuoso: 
04:26:13 <dminuoso> Ah well I guess I really do want deriving strategies for this.
04:41:37 <saurabh__> Is there an example of creating a `ReaderT Env IO` monad, which is tagged with a phantom type? My possible use-case: Use the phantom-tag to represent roles/permissions that are required to run the underlying action.
04:43:04 <dminuoso> saurabh__: ReaderT is not a phantom.
04:43:22 <dminuoso> saurabh__: ReaderT/Reader turn argument passing into an implicit form.
04:44:14 <dminuoso> saurabh__: Oh I see what you mean. You could trivially make your own `IO` wrapper that includes a phantom type.
04:44:21 <dminuoso> Or whole monad newtype 
04:44:36 <saurabh__> dminuoso: yes, I understand that. But, that's just for context. While writing code in this monad, I want it to behave like a `ReaderT Env IO`, but the functions should also be able to carry a phantom type which represents the roles/permissions
04:45:13 <dminuoso> saurabh__: You mean like: newtype YourM p a = ReaderT Env IO a
04:46:01 <saurabh__> dminuoso: yes, something like that. but I don't know the pros and cons of doing something like that. Wanted to see some examples where this technique might have been used.
04:46:25 <saurabh__> dminuoso: btw, that specific example won't compile, right?
04:47:31 <dminuoso> saurabh__: Its a perfectly reasonable thing to do.
04:47:32 <dminuoso> saurabh__: Oh I missed the constructor yeah
04:47:32 <dminuoso> % newtype FooM p a = FooM { runFooM :: ReaderT Int IO a }
04:47:32 <yahb> dminuoso: 
04:48:48 <saurabh__> then I need to define type-class instances for `FooM p a` for Functor, Applicative, Monad, etc, right?
04:48:51 <saurabh__> and MonadIO
04:48:58 <saurabh__> and MonadCatch, and MonadThrow
04:49:00 <saurabh__> shucks...
04:49:01 <dminuoso> saurabh__: You can use GeneralizedNewtypeDeriving :)
04:49:08 <dminuoso> saurabh__: That's precisely what its for.
04:50:14 <dminuoso> % :set -XGeneralizedNewtypeDeriving
04:50:14 <yahb> dminuoso: 
04:50:35 <dminuoso> % newtype FooM p a = FooM { runFooM :: ReaderT Int IO a } deriving (Monad, MonadReader Int, MonadIO)
04:50:35 <yahb> dminuoso: ; <interactive>:57:67: error:; * No instance for (Applicative (FooM p)) arising from the 'deriving' clause of a data type declaration; Possible fix: use a standalone 'deriving instance' declaration, so you can specify the instance context yourself; * When deriving the instance for (Monad (FooM p))
04:50:40 <saurabh__> hmm... thinking aloud now. Does this pain buy me what I want? (a) If an action of this type is inspected it should reveal what roles/permissions are required to run it, (b) when actually running this action one needs to pass a user object that actually has these roles/permissions
04:50:42 <dminuoso> % newtype FooM p a = FooM { runFooM :: ReaderT Int IO a } deriving (Functor, Applicative, Monad, MonadReader Int, MonadIO)
04:50:42 <yahb> dminuoso: 
04:52:00 <dminuoso> saurabh__: Okay yeah you won't be able to do this with plain phantom types anymore.
04:52:26 <saurabh__> dminuoso: why do you say that?
04:58:15 <dminuoso> saurabh__: If you want this to be in the type system, then this is getting into singletons territory I think.
04:58:21 <dminuoso> saurabh__: So the mere "printing what roles are necessary" is not a big issue if the required roles are a type level object.
04:58:36 <dminuoso> But you want this to play nice with runtime values, the type checker cant test this.
05:00:06 <saurabh__> that's what I was thinking hard about -- is this type-level gymnastics worth it
05:00:25 <saurabh__> and what is a better way to ensure authorisation checks are not missed out in my code
05:00:54 <dminuoso> saurabh__: Well you can do a rudimentary version.
05:04:41 <dminuoso> saurabh__: Something along the lines of `f :: Protected ("FooRole" :<|> "BarPermission") ()`, with some `class Protectable k where assert :: User -> Proteted k a -> FooM a`
05:05:29 <dminuoso> And some suitable instances for Protectable that generate the correct code, testing that the user has the specified permission/roles.
05:06:27 <saurabh__> but someone has to remember to call `assert` manually, right? I was wondering if the runAppM function could be something like `runAppM :: Permissions -> User -> AppM a -> IO a` -- so that wherever it is used, one is forced to remember about permission/role checking
05:06:47 <dminuoso> You are forced to do this by the types otherwise not lining up.
05:07:20 <dminuoso> I mean you could use a typeclass to do this assertion automatically of course.
05:08:04 <saurabh__> dminuoso: I'm losing you a little here... how can a typeclass do this assertion automatically?
05:11:52 <quchen> Is there some theorem about SK calculus normal forms? Is there a reduction scheme that finds a unique normal form if it exists?
05:43:31 <halogenandtoast> Is there any way to force this lens traversal to return nothing in my second case here: https://gist.github.com/halogenandtoast/f298b91964e305bcbc1612f365da029e ?
05:44:58 <halogenandtoast> and by nothing I don't necessarily mean Nothing, just want it to have "failed" there since x would be out of bounds
05:45:01 <Jinna> Which is more common? a) import Module (Type(..))   vs.   b) import Module (Type (..))    <- there is a space between Type and (..)
05:46:39 <lavalike> I vote a
05:46:55 <halogenandtoast> I do (a) as well
05:49:37 <jackdk> I also do ( a )
05:51:00 <Guillaum> Do you know if I can disable the "Loading package environment from xxx." messages during ghc build?
05:52:41 <ocharles> Guillaum: -package-env -
05:52:57 <ocharles> Will stop ghc reading .ghc.environment files
05:58:09 <Ariakenom> halogenandtoast: I don't know lens but does pure (Grid w h c) fit?
05:58:14 <halogenandtoast> So I think a "solution" to my question is to do something like     | otherwise = Grid w h <$> ix 0 f mempty
06:04:15 <quchen> Jinna: Probably not worth worrying about ;-) FWIW stylish-haskell does this automatically for you
06:04:26 <quchen> (Depening on a config)
06:04:53 <Guillaum> ocharles: actually I want ghc to read the package file, but i don't want the message ;)
06:05:01 <ocharles> Oh :)
06:05:02 <quchen> I usually write fairly ugly dependency blocks and then run ¬ªstylish-haskell -i **/*.hs¬´ once
06:07:27 * geekosaur guesses -v0 will help but may disable other messages you care about
06:34:27 <Ariakenom> halogenandtoast: did you see my message?
06:34:56 <halogenandtoast> Oh, my solution didn't work, because it just empties out the vector... :(, I saw the one with `fit`
06:36:04 <halogenandtoast> Ariakenom: where does `fit` come from?
06:36:12 <tabaqui> Semigroup instance of Either a b sucks
06:36:24 <tabaqui> % Right "a" <> Right "b"
06:36:25 <yahb> tabaqui: Right "a"
06:36:30 <Ariakenom> halogenandtoast: I don't know lens but does "pure (Grid w h c)" fit?
06:36:43 <Taneb> tabaqui: left-most Right?
06:36:48 <Ariakenom> I just syntax errored myself :)
06:36:50 <tabaqui> better one would be (Semigroup r) => Semigroup (Either l r) where R a <> R b = R $ a <> b
06:37:02 <tabaqui> Taneb: yeah
06:37:14 <Taneb> tabaqui: I'd put a Semigroup constraint on both parameters
06:37:21 <Taneb> For the L <> L case
06:37:41 <tabaqui> dunno, I'd prefer that L a <> _ = L a
06:37:49 <tabaqui> and R{} <> L a = L a
06:38:12 <Taneb> You can get that first behaviour with Either (First a) b, I think
06:38:27 <Taneb> Second one I could take or leave
06:38:38 <tabaqui> well, the problem I want to solve now
06:39:29 <tabaqui> I have a string looks like "5 10" and I want to get the product of ints or parse error
06:39:33 <tabaqui> using readEither
06:39:54 <tabaqui> something like let (a, b) = words string in readEither a <|> readEither b
06:40:02 <tabaqui> not <|> exactly but somewhat
06:40:05 <Taneb> :t fmap product . sequence
06:40:07 <lambdabot> (Monad f, Traversable t, Num b) => t (f b) -> f b
06:40:11 <Taneb> :t fmap product . sequenceA
06:40:13 <lambdabot> (Applicative f, Traversable t, Num b) => t (f b) -> f b
06:40:52 <tabaqui> I want such signature "f :: String -> Either String (Sum Int)"
06:41:13 <tabaqui> or any other Monoid wrapper, doesn't matter
06:41:29 <Taneb> :t \f -> fmap (foldMap f) . traverse readEither
06:41:31 <lambdabot> error:
06:41:31 <lambdabot>     ‚Ä¢ Variable not in scope: readEither :: a1 -> f a
06:41:31 <lambdabot>     ‚Ä¢ Perhaps you meant one of these:
06:41:38 <Taneb> @let import Text.Read
06:41:40 <lambdabot>  Defined.
06:41:41 <Taneb> :t \f -> fmap (foldMap f) . traverse readEither
06:41:42 <lambdabot> (Read a, Traversable t, Monoid b) => (a -> b) -> t String -> Either String b
06:42:14 <Taneb> tabaqui: that what you're after?
06:42:19 <halogenandtoast> Ariakenom: let me try, one second
06:42:27 <tabaqui> I don't think that I want to achieve this without Monad methods
06:42:44 <tabaqui> Taneb: I'm parsing /proc/meminfo
06:42:50 <Taneb> I don't understand what you mean by "without Monad methods"
06:42:50 <tabaqui> s/want/can/
06:43:31 <Taneb> What's lacking with what I suggested?
06:43:40 <tabaqui> I want to interrupt parsing/summing/etc if any readEither returns Left
06:43:54 <Taneb> Which is what my suggestion does, it gives you the first error
06:44:01 <halogenandtoast> Ariakenom: Yeah, I think that works, thanks!
06:44:28 <Ariakenom> :D I lens expert now
06:45:52 <tabaqui> Taneb: oh, your function with traverse works well
06:45:55 <tabaqui> thanks
06:46:36 <tabaqui> dunno, I feel fine with free, mtl, coalgebras but not with Traversable
06:46:52 <tabaqui> really badass class
06:48:00 <Taneb> If you change your mind and decide you want the version that collects all the errors you could use the validation package which provides a version of Either with a different Applicative instance which accumulates errors in a Semigroup structure
06:48:07 <halogenandtoast> Ariakenom: yeah I really need to look at the type that Traversal' (Grid a) a actually is, seeing that it should be f (Grid a) makes your `pure` solution make sense
06:48:43 <Ariakenom> halogenandtoast: ye that's what I did
06:49:31 <Taneb> But, yes, Traversable is the best class
06:58:01 <merijn> pfft
06:58:06 <merijn> Clearly Monoid is the best class
06:59:34 <hyperisco> Monoid is far too assuming. Clearly Magma is the one class to rule them all!
07:00:20 <merijn> Monoid has the recursive instance for functions, which beats every other instance of every other typeclass :p
07:01:36 <halogenandtoast> hyperisco: it also has the best name
07:11:57 <solonarv> aveltras, dminuoso: I'm pretty sure DerivingVia implies DerivingStrategies anyway
07:12:28 <fendor> merijn, recursive instance for functions? what does that mean?
07:12:49 <solonarv> fendor: instance Monoid b => Monoid (a -> b)
07:13:02 <solonarv> (and the same for Semigroup, of course)
07:13:20 <solonarv> f <> g = \x -> f x <> g x; mempty = \_ -> mempty
07:13:41 <Ariakenom> % (("Hello"<>) <> (<>"world")) " "
07:13:41 <yahb> Ariakenom: "Hello world"
07:14:51 <fendor> that implies, that (a -> b -> c) is also a monoid if c is monoid?
07:14:57 <fendor> cool
07:14:58 <merijn> fendor: Right :)
07:15:06 <merijn> fendor: It's the best instance ever!
07:15:16 <solonarv> it's pretty cool :D
07:15:25 <fendor> i have to play around! lambdabot! follow me into a private room!
07:15:32 <solonarv> there is also instance Monoid a => Monoid (IO a)
07:15:37 <solonarv> and instance Monoid ()
07:15:44 <solonarv> those combine very nicely!
07:15:52 <merijn> Cool examples include: "mconcat [ comparing foo, comparing bar, comparing xyzzy]" to generate a function that does complex orderings :)
07:16:15 <solonarv> I keep forgetting instance Monoid Ordering
07:16:33 <Welkin> what
07:16:39 <merijn> fendor: It uses the Monoid on Ordering to generate functions that first compare on the result of foo, then all items that compare equal are ordered by result of bar, and all results *still* equal are ordering by the result of xyzzy :)
07:16:44 <bollu> I recently used Endo to implement a "mutable" algorithm in a pure style: https://gist.github.com/bollu/b32ae087af396508c4c96993bb2aac06#file-mutable-style-endo-hs-L444
07:16:49 <merijn> > LT <> EQ
07:16:52 <lambdabot>  LT
07:16:54 <merijn> > EQ <> LT
07:16:57 <lambdabot>  LT
07:16:58 <delYsid``> And functions being applicative functors are also useful :-)
07:17:02 <fendor> I used to `mappend` for complex orderings before, but mconcat is a nice addition to it
07:17:08 <Welkin> > GT <> EQ
07:17:11 <lambdabot>  GT
07:17:13 <solonarv> the definition is simply: EQ <> y = y; x <> _ = x
07:17:14 <bollu> Welkin yeah, lex ordering is monoid concatenation of the monoid completion of the left absorbing semigroup ;) 
07:17:16 <Welkin> > EQ <> GT
07:17:17 <bollu> what's not to love?
07:17:18 <lambdabot>  GT
07:17:21 <merijn> Welkin: Basically, if left is EQ, then right, else left
07:17:34 <Welkin> > LT <> GT
07:17:38 <lambdabot>  LT
07:17:46 <merijn> Welkin: Which corresponds to lexicographical ordering
07:18:14 <merijn> fendor: It's also amazing for complex predicates
07:18:38 <merijn> fendor: You can use the Any and All newtypes for Bool to compose complex predicates regardless of the number of arguments :)
07:19:07 <fendor> > mconcat [All True, All True, All $ mcocnat [Any False, Any True]]
07:19:09 <lambdabot>  error:
07:19:09 <lambdabot>      ‚Ä¢ Variable not in scope: mcocnat :: [Any] -> Bool
07:19:09 <lambdabot>      ‚Ä¢ Perhaps you meant one of these:
07:19:33 <fendor> > mconcat [All True, All True, All $ mconcat [Any False, Any True]]
07:19:35 <lambdabot>  error:
07:19:35 <lambdabot>      ‚Ä¢ Couldn't match expected type ‚ÄòBool‚Äô with actual type ‚ÄòAny‚Äô
07:19:35 <lambdabot>      ‚Ä¢ In the second argument of ‚Äò($)‚Äô, namely
07:19:36 <solonarv> that does not typecheck
07:19:54 <fendor> yeah, wrong types
07:20:02 <solonarv> > ala All foldMap [True, True, ala Any foldMap [False, True]]
07:20:05 <lambdabot>  True
07:20:38 <solonarv> or you could just use 'or'/'and'/'any'/'all'
07:20:55 <fendor> merijn, more readable than chaining of && ?
07:21:19 <fendor> or more readbale than what solonarv said
07:21:21 <merijn> fendor: It depends whether you want to get a Bool or a predicate function to use with something else :)
07:22:22 <solonarv> you can write: ala ((fmap . fmap . fmap) Any) [\x y z -> True, ...]
07:22:31 <solonarv> (number of fmaps = number of arguments)
07:22:36 <merijn> fendor: I have some code in Cabal that makes liberal use of complex predicates that way: https://github.com/haskell/cabal/blob/master/Cabal/Distribution/Simple/Program/GHC.hs#L95-L117
07:22:39 <solonarv> er, missing a foldMap
07:22:43 <merijn> (and also all surrounding bits)
07:23:07 <merijn> fendor: Or, perhaps a better example: https://github.com/haskell/cabal/blob/master/Cabal/Distribution/Simple/Program/GHC.hs#L163-L194
07:23:10 <solonarv> ...huh, I think I just found a place where I like 'fmap' better than '.'
07:23:31 <solonarv> was not expecting that
07:24:00 <fendor> solonarv, your construct looks really hard to read :D 
07:24:07 <merijn> fendor: That one is actually really tricky to write with &&
07:24:34 <merijn> fendor: Because you'd have to translate the 'from' function somehow (which, btw, is another example of Monoid being awesome)
07:24:36 <solonarv> you would have to define some sort of <<<&&>>> = (liftA2 . liftA2 . liftA2) (&&)
07:24:58 <solonarv> then you could write f <<<&&>>> g <<<&&>>> h ...
07:25:06 <solonarv> which seems even sillier to me
07:25:37 <fendor> merijn, I agree that is pretty good to read, once you are accustomed to it
07:25:49 <fendor> solonarv, could you use arrows for it?
07:26:05 <solonarv> you *could*, but I don't think it would be much cleaner
07:26:21 <solonarv> and I'm not even sure how to write it
07:26:54 <merijn> fendor: I agree that for cases where you have 1 or 2 booleans it's probably not very sensible compared to just &&, but together with mconcat it becomes very nice for long lists
07:27:23 <solonarv> 'ala <blah> foldMap' is a pattern I recognize and I know what it does, so if a composition of stuff is big enough to not just write it out it is nice
07:27:30 <fendor> solonarv, neither, but arrows seem cool, so, have to use them some day
07:27:46 <solonarv> roughly: ala wrap hof = unwrap . hof wrap
07:28:04 <fendor> merijn, in this case, what is the main difference to `or` or `and`? 
07:28:22 <solonarv> none, if the things you're composing are all booleans
07:28:23 <fendor> avoidance of boolean blindness?
07:28:31 <solonarv> (or rather boolean predicates)
07:28:34 <fendor> you at least gain some information
07:29:08 <fendor> solonarv, ala is a really cool function, unfortunately, defined in lens, right?
07:29:16 <solonarv> the thing is if they're complex predicates you end up having to write: mconcat [(fmap.fmap.fmap) All func1, ...]
07:29:27 <solonarv> fendor: there is a version in CoercibleUtils as well I think
07:30:05 <geekosaur> http://hackage.haskell.org/package/newtype
07:30:35 <geekosaur> although I'd guess CoercibleUtils would be a more modern take on it
07:31:59 <merijn> fendor: Nothing, probably, although this code was refactored quite a bit, so it's easier to realise it can be written via or/and now that it was initially :p
07:32:51 <fendor> merijn, it is always easier to improve code than to write it. It is still a cool usage of monoid.
07:33:01 <Welkin> when was the code originally factored?
07:33:18 <Welkin> merijn: that's not true at all
07:33:44 <Welkin> it is almost always easier to rewrite something from scratch than to update/fix it, especially for legacy systems
07:33:56 <Welkin> fendor* ^
07:34:37 <fendor> ok, i mean, it is sometimes easier to imrpove code than to write it :P
07:35:53 <merijn> Welkin: No, I meant that I didn't know I'd end up with this design when I started writing it
07:52:15 <yorick> where's the uniplate manual nowadays?
07:53:50 <yorick> community.haskell.org/~ndm/uniplate/ is down
07:59:02 <Welkin> what is uniplate?
08:02:46 <int-e> Welkin: https://hackage.haskell.org/package/uniplate
08:03:26 <int-e> (which lists the community thing as its homepage)
08:03:38 <int-e> yorick: try ##haskell-infrastructure maybe?
08:12:09 <saml> how do you test if two [String] are one edit apart where an edit can be add char, delete char, or change char
08:13:10 <int-e> drop common prefix, then try the three possible edits...
08:13:31 <merijn> or google "haskell levensthein" :p
08:13:31 <infinisil> saml: You're looking for the Levenshtein distance
08:13:53 <int-e> (there's no need to go through the whole dynamic programming exercise here... it would just be a waste of computational effort)
08:14:34 <infinisil> Ah yeah if it's only one edit then I'd go with int-e's approach
08:14:46 <int-e> (Unless you intend to later relax this to "up to two edits" or more. Even then, I'd recommend to cut the computation short at the provided bound.)
08:17:11 <saml> iterative solution is walk two strings and if you encounter different char, skip over the longer string's char.  if you had to skip over more than once, it's not one edit
08:17:34 <saml> so it doesn't have to try all possible three edits
08:17:54 <saml> i guess recursive solution can be the same
08:18:34 <tdammers> or you could try the bogo solution: generate all possible edits of the first string, shuffle that list, and then check them for equality with the second string, one by one
08:18:37 <infinisil> int-e: I actually wouldn't be surprised if a default leveshtein implementation reduces to just that
08:19:06 <infinisil> And the edit-distance package implementation seems heavily optimized
08:19:35 <infinisil> https://github.com/phadej/edit-distance
08:19:44 <int-e> infinisil: the "try all three edits" is the standard levenshtein distance approach. (plus caching the results for all pairs of suffixes, aka dynamic programming)
08:20:14 * int-e wasn't throwing *all* the theory over board.
09:13:56 <Jinna> Are JWT messages _always_ unencrypted? I.e. is it possible to always decode them and see the contents?
09:19:57 <mac10688> Jinna: It's my belief that JWT messages are always unencrypted. Except for the last part that hashes the contents with a secret key.
09:22:55 <griddle> hey so the error regarding cabal linking errors is back. 
09:23:24 <griddle> https://pastebin.com/raw/jCcRbuBm heres the full error when I run `cabal new-install stylish-haskell`
09:23:49 <griddle> it seems that all global haskell binary installs cause this, so with stack or cabal
09:24:41 <griddle> and haskell's goofy symbol mangling doesnt help readability 
09:27:59 <geekosaur> this is telling you that you have stuff installed that is not x86_64, btu trying to build for x86_64.
09:28:07 <geekosaur> and I;m sorry you dont like that apple's linker is a POS
09:28:18 <geekosaur> and requires stupid name hackery to work around its stupid limits
09:31:33 <griddle> lol so is there a way to fix this?
09:32:18 <geekosaur> there isn'tenough information here since it doesn't say what arch it thinks is installed, just the one it wants to see
09:32:54 <griddle> my uname: `Darwin 18.6.0 Darwin Kernel Version 18.6.0: Thu Apr 25 23:16:27 PDT 2019; root:xnu-4903.261.4~2/RELEASE_X86_64 x86_64`
09:32:57 <geekosaur> and  thought apple stopped supporting 32 bit some time back
09:33:26 <geekosaur> but that's what those errors usually mean, unless you somehow installed an arm version of ghc
09:33:56 <geekosaur> (that si, a cross-compiler)
09:34:04 <griddle> where does cabal install all of its things, I guess I could go through and fully wipe it
09:34:16 <geekosaur> it told you that mltiple times
09:35:52 <geekosaur> /Users/griddle/.cabal/store/ghc-8.6.5/ to read your own paste for you
09:36:30 <griddle> Yeah, I've deleted .cabal many times and it never fixed it. I was asking about anywhere else
09:37:32 <griddle> https://github.com/commercialhaskell/stack/issues/3487
09:39:39 <geekosaur> wat does stack have to do with anything
09:40:09 <sclv> griddle: do you have any libs installed from brew on your system?
09:40:12 <griddle> Im aware, but the error *also* happens with `stack install`
09:40:33 <griddle> Yeah I use brew to install things, but I have removed binutils as the issue said to to no avail 
09:41:25 <geekosaur> then you have worse problems somewhere, and considering how stack tries to exclude anything that isn't itself or managed by itself, that's something of a trick
09:42:15 <sclv> so are you sure the linkers and toolchain you're using are _entirely_ the apple ones with no brew installed stuff anywhere in sight?
09:43:26 <sclv> i.e. the `ar` is not from brew, the compiler is not from brew, etc.
09:43:43 <sclv> (the c compiler i mean)
09:45:08 <griddle> okay so I reinstalled binutils, manually did `brew unlink ...`, then uninstalled and it seems to be working
09:45:35 <dmwit> ?hoogle proxy a -> Proxy a
09:45:35 <lambdabot> Data.Tagged reproxy :: proxy a -> Proxy b
09:45:35 <lambdabot> Boltzmann.Data.Types reproxy :: proxy a -> Proxy a
09:45:35 <lambdabot> Pipes.Internal Pure :: r -> Proxy a' a b' b m r
09:45:54 <sclv> yeah the mismatch between brew and apple stuff is a pain. glad you have it sorted. fingers crossed.
09:46:05 <dmwit> Heh. Not going to add a dependency for whatever Boltzmann.Data.Types is just for this. ^_^
09:46:19 <griddle> gotta just get stack working now... 
09:46:26 <dmwit> Somebody should add it to Data.Proxy.
09:46:28 * dmwit touches his nose
09:47:12 <griddle> so `stack build` a project in the project dir works, but `stack install exe` fails with linkage errors
09:49:35 <sclv> possibly you need to blow away some stack cache too?
09:50:54 <Cannonical> Freenode had problems with disruptive elements and trolls trying to derail our crusade for free and universally accessible software.. Despite this, we are the premire FOSS collaboration platform on the Internet.  Our team of staffers have worked dilligently to ensure Freenode remains a safe, supportive platform where the FOSS commununity can thrive absent of scams and hate speech.  The costs of 
09:50:54 <Cannonical> network monitoring and the lawsuits mounted by Larry Ellison and Oracle have presented challenges to Freenode's very survival.
09:50:54 <Cannonical> Mark Shuttleworth and Freenode staff have now unveiled the Freenode Fortress Project!  Partnering with Huawei, we are in the process of installing an intelligent firewall that will defend against any DDOS or massive spambot operation using Huawei's predictive computing technology, the same software used to track and control China's Uighur Muslim minority.
09:50:54 <Cannonical> Trolls will be recognized based on these predictive patterns and automatically blocked. This system, however, will be costly, and we need your help paying for licensing and installation.
09:50:56 <sicklorkin> griddle: sometimes `stack clean &&  stack build --force-dirty` does the trick
12:02:59 <oats> howdy, so I'm noticing in my toy IRC bot that I have a lot of functions of the form `:: Connection -> Config -> IO ()`. That is, they take a handle to the TCP socket and the bot's configuration. What can I do to cut down on this repetitiveness?
12:03:23 <hyperisco> oats, use a Reader
12:04:58 <geekosaur> well, ReaderT over IO
12:05:45 <oats> whooboy, I haven't needed to learn about monad transformers yet
12:05:52 <oats> this'll be interesting
12:07:03 <hyperisco> Alternative idea‚Ä¶ use ImplicitParams
12:09:35 <hyperisco> Worst idea‚Ä¶ use global state
12:09:47 <oats> heehee
12:09:48 <hyperisco> Occasionally worst is best ;)
12:09:51 <oats> I'd like to avoid that
12:10:16 <merijn> oats: Lucky for you I wrote a homework assignment on "how to monad transformer" :p
12:10:19 <merijn> oats: https://gist.github.com/merijn/098106abd45c940dab09
12:10:55 <merijn> Fill in the blanks and done ;)
12:20:51 <hyperisco> How to monadise?
12:53:26 <dmj`> merijn: isn't that just the state monad, not a transformer
12:57:01 <merijn> dmj`: You should scroll down ;)
12:59:03 <fragamus> What is :*
12:59:38 <fragamus> Omg that makes an emoji on my phone
13:00:28 <hyperisco> fragamus, I don't know, but I am guessing type level Int multiplication
13:00:45 <hyperisco> Or a type level Nat or something
13:00:51 <fragamus> That makes sense
13:02:26 <yushyin> infix constructor?
13:02:54 <hyperisco> Infix type family likely
13:03:41 <cocreature> fragamus: https://hoogle.haskell.org/?hoogle=(%3A*) shows you some possible options
13:06:15 <hyperisco> Anyone have a working link for community.haskell.org/~ertes/hangman/ ? It was the article about implementing Hangman as a Monoid.
13:07:45 <yushyin> https://web.archive.org/web/20150423212235/community.haskell.org/~ertes/hangman/
13:13:54 <hyperisco> yushyin, you're a smart cookie.
13:14:02 * hyperisco gives yushyin a cookie.
13:14:13 <hyperisco> You've alright with cannibalism yes?
13:16:39 <yushyin> who could resist cookies? *munch munch*
13:18:47 <hyperisco> They do say you are what you eat! 
13:19:01 <dmj`> merijn: ah, my IRC client shows gists, only showed the first file
13:19:06 <dmj`> merijn: ;)
13:26:01 <bsima> is there some way to tell haddock to ignore missing external packages?
13:29:32 <merijn> dmj`: Easiest to understand StateT if you make sure they properly understand State first :)
13:32:31 <BurningFox> Hey everyone! I read the book Learn you a Haskell for Great Good and experimented a bit on the terminal. Now, my background is mostly imperative, coming from Java and NodeJS, I have a hard time understanding these concepts and how they seem so useful. Any additional clue on how to learn them?
13:33:46 <hyperisco> BurningFox, Just put in the hours and your brain will do the rest.
13:35:39 <wildtrees> BurningFox, have you checked out whats in Data.List yet? http://hackage.haskell.org/package/base-4.12.0.0/docs/Data-List.html
13:35:52 <vaibhavsagar> BurningFox: rewrite one of your Java/NodeJS projects in Haskell
13:37:54 <dmj`> merijn: In order to understand recursion, one must first understand recursion
13:38:50 <dmwit> Yeah, who needs base cases?
13:39:41 <BurningFox> Thanks everyone, I considered putting writing a small project in Haskell. Just wrap my head around.
13:39:59 <solonarv> yep, that is a good idea
13:40:42 <talqu> hi, im trying to send an email using gmail. https://pastebin.com/Phg2mZpT However i get an error *** Exception: <socket: 12>: Data.ByteString.hGetLine: end of file. 
13:40:43 <hyperisco> I implemented the Graham Scan algorithm as my first Haskell program. Maybe that seems interesting to you.
13:44:14 <juri_> BurningFox: consider adopting someone else's broken haskell code, and fixing it up. it helps to have an example, and you can do some good while you learn.
13:48:48 <BurningFox> That is a good idea! Any idea where to see such code? I would normally check out Github, but in general the code there is already working :)
14:06:01 <geekosaur> talqu, decent chance that's gmail slightly violating protocol: they don't like programs sending mail through them and an antispam mechanism often gives n unexpected failure code and drops the connection
14:10:02 <talqu> geekosaur: strange, basic java or node libraries have always worked for me
14:10:23 <talqu> i'll try to look for some other haskell library then
14:12:21 <juri_> BurningFox: github. and, try building with lots of warning flags turned on.
14:12:49 <juri_> i find that people tend to assume since it compiled, the compiler is happy. not so. :)
14:12:52 <DigitalKiwi> my 'favorite' example of gmail violating standards is how if you use imap drafts it might decide to send it every time the draft is saved by your client
14:13:10 <DigitalKiwi> someone got 19 emails from me one time :|
14:13:58 <DigitalKiwi> every time i added 40 characters
14:14:13 <talqu> geekosaur: this library has worked with no errors Network.HaskellNet.SMTP.SSL as SMTP
14:15:11 <BurningFox> juri_: Do you mean, turning on the linter?
14:15:58 <juri_> BurningFox: depends how they build. stack, cabal.. a big make file.. it varies project to project.
14:16:19 <juri_> learning from someone else's mistakes is cheaper than making your own. :)
14:18:57 <geekosaur> talqu, yes, it may not be recognized. I had this problem with, among others, freebsd's nightly reports getting first autotagged as spam and then straight up rejected with smtp errors
14:19:06 <geekosaur> google hates program-sent mail
14:20:07 <geekosaur> not guaranteed tht's the problem but you should test with other services, not just gmail, becaause gmail has its own ssues like that
14:23:12 <merijn> Reliably sending email is surprisingly hard
14:26:22 <Rembane> And it gets harder and harder. 
14:44:14 <dmwit> Huh. I think of the `k` in `Map k v` as appearing in negative position. But it appears only positively in the data definition for `Map`.
14:45:51 <solonarv> yes, in fact it does not appear in negative position
14:49:17 <solonarv> but you can trivially wrap it to make a profunctor:
14:49:55 <solonarv> data ProMap k v = forall x. Ord x => ProMap (k -> x) (Map x v)
14:50:21 <solonarv> or data ProMap x k v = ProMap (k -> x) (Map x v)
14:51:54 <solonarv> this is, uhh... contravariant coyoneda, I think
14:52:41 <dmwit> I suppose it's probably already a profunctor from Ord -> Hask.
14:53:33 <solonarv> no, it has the wrong variance for that
14:53:38 <dmwit> In any case, I feel justified in my feeling of negativeness about the keys. So I find myself in a position of cognitive dissonance.
14:54:01 <dmwit> Why does it have the wrong variance for that?
14:54:12 <solonarv> because it's covariant in the first parameter
14:54:23 <solonarv> but to be a profunctor it must be contravariant!
14:54:40 <solonarv> a profunctor would look like Ord x Hask -> Hask
14:54:46 <solonarv> wait no, typo
14:54:49 <dmwit> You are saying I cannot implement `Ord a => (a -> b) -> Map b v -> Map a v`?
14:54:53 <solonarv> a profunctor would look like Ord^op x Hask -> Hask
14:54:57 <solonarv> I am indeed saying that
14:55:12 <solonarv> well, not with reasonable semantics - you could of course just return an empty map
14:55:45 <solonarv> now if you had some way to enumerate all possible values of 'a' you might get somewher
14:55:50 <dmwit> Well. Now that I have written the type down instead of just imagining it, I find myself agreeing with you.
14:56:17 <solonarv> conceptually 'Map k v' is very much like '[(k, v)]', it just has better asymptotics etc
15:01:28 * dmwit . o O ( instance Default a => Infinite [a] )
15:17:50 <jle`> dmwit: if it helps you conceptually, the 'k' in the data structure only exists to defunctionalize a (k -> Ordering) function
15:18:36 <jle`> so don't think of it as storing a k, but rather as storing a "k -> Ordering" function in a way that is serializable etc.
15:19:45 <solonarv> oooh, interesting!
15:32:59 <sicklorkin>  `Ord a => (a -> b) -> Map b v -> Map a 
15:33:09 <sicklorkin> mapMonotonic?
15:33:20 <solonarv> no, you simply cannot write that function
15:33:32 <sicklorkin> you sure can, but ti's not very safe
15:33:53 <solonarv> no, you can't - unless you're okay with always returning an empty map
15:33:57 <sicklorkin> fromListAsc -> toListAsc
15:34:06 <solonarv> wrong direction
15:34:12 <sicklorkin> well you get my point
15:34:42 <solonarv> no, I mean you can perfectly well write mapKeys :: Ord b => (a -> b) -> Map a v -> Map b v
15:34:59 <solonarv> but if you swap the direction of that last arrow you can't do it
15:35:15 <sicklorkin> oh.. my bad, i misread
15:35:48 <Welkin> you need Ord a too
15:35:59 <solonarv> nope
15:36:07 <Welkin> that's a property of Map
15:36:25 <solonarv> no; not *everything* involving Map requires Ord on the keys
15:36:41 <solonarv> for example you can perfectly well construct an empty or singleton map without an Ord instance on the keys
15:36:45 <solonarv> :t Data.Map.singleton
15:36:46 <lambdabot> k -> a -> M.Map k a
15:36:50 <solonarv> ^ see? no Ord
15:37:16 <solonarv> :t Data.Map.toAscList -- also no Ord
15:37:17 <lambdabot> M.Map k a -> [(k, a)]
15:38:37 <solonarv> @let myMapKeys f = Data.Map.fromList . map (first f) . Data.Map.toAscList
15:38:38 <lambdabot>  Defined.
15:38:43 <solonarv> :t myMapKeys
15:38:44 <lambdabot> Ord k1 => (k2 -> k1) -> M.Map k2 a -> M.Map k1 a
15:39:42 <Welkin> :t Data.Map.Strict.insert
15:39:43 <lambdabot> Ord k => k -> a -> M.Map k a -> M.Map k a
15:40:09 <Welkin> I suppose that works with the singleton
15:40:17 <solonarv> yes, you need Ord on the keys of the map you want to produce - don't need it on the input though
15:40:24 <Welkin> if k isn't already Ord, then you can't insert into it
15:40:28 <Welkin> it seems like an oversight though
15:40:41 <solonarv> why should there be redundant constraint, though?
15:41:09 <Welkin> @let data NotOrd = NotOrd
15:41:10 <lambdabot>  Defined.
15:41:21 <Welkin> > Data.Map.singleton NotOrd 1
15:41:23 <lambdabot>  error:
15:41:23 <lambdabot>      ‚Ä¢ No instance for (Show NotOrd)
15:41:23 <lambdabot>          arising from a use of ‚Äòshow_M243920817588590975031453‚Äô
15:41:27 <Welkin> haha
15:41:34 <Welkin> :t Data.Map.singleton NotOrd 1
15:41:35 <solonarv> nice :P
15:41:36 <lambdabot> Num a => M.Map NotOrd a
15:41:43 <Welkin> @let data NotOrd = NotOrd deriving Show
15:41:45 <lambdabot>  .L.hs:161:1: error:
15:41:45 <lambdabot>      Multiple declarations of ‚ÄòNotOrd‚Äô
15:41:45 <lambdabot>      Declared at: .L.hs:159:1
15:42:14 <Welkin> @let instance Show NotOrd where show _ = "NotOrd"
15:42:15 <lambdabot>  Defined.
15:42:18 <Welkin> :t Data.Map.singleton NotOrd 1
15:42:19 <lambdabot> Num a => M.Map NotOrd a
15:42:20 <Welkin> > Data.Map.singleton NotOrd 1
15:42:23 <lambdabot>  fromList [(NotOrd,1)]
15:43:02 <Welkin> @let data NotOrd2 = NotOrd1 | NotOrd2 deriving Show
15:43:03 <lambdabot>  Defined.
15:43:10 <MarcelineVQ> Sometimes it's shorter to use words to make a particular point
15:43:27 <Welkin> > Data.Map.insert NotOrd2 2 (Data.Map.singleton NotOrd1 1)
15:43:31 <lambdabot>  error:
15:43:31 <lambdabot>      ‚Ä¢ Could not deduce (Ord NotOrd2) arising from a use of ‚ÄòM.insert‚Äô
15:43:31 <lambdabot>        from the context: Num a
15:43:53 <Welkin> so you can make a usless Map
15:45:58 <lavalike> > Data.Map.fromDistinctDescList [(NotOrd,1),(NotOrd,2)] -- >:)
15:46:02 <lambdabot>  fromList [(NotOrd,2),(NotOrd,1)]
15:46:17 <solonarv> don't lie to containers T_T
16:00:20 <dmwit> Welkin: I object to "useless". You can destruct it in all the usual ways -- minView, e.g.
16:45:56 <int-e> dmwit: it is harmful though
16:51:02 <nshepperd> what's harmful
16:52:24 <hpc> breaking invariants in containers
16:52:41 <hpc> or well, breaking the laws of Ord anyway
16:52:52 <nshepperd> making singleton maps of things that don't have Ord doesn't break any invariants
16:53:33 <aiden> hi
16:54:28 <bsima> hi aiden
17:43:45 <int-e> nshepperd: the most recent example was using fromDistinctDescList
17:44:10 <nshepperd> i don't think dmwit was talking about that
17:44:14 <int-e> so that allows you to break the container's invariant.
17:44:28 <int-e> ah, maybe not.
18:16:17 <dmwit> I was talking about "useless", which was referring to the result of singleton.
18:42:11 <Guest66369> Does anyone know how to get doctest to work for Haskell?
18:43:04 <Guest66369> In particular for mac
18:47:29 <Guest66369> Hello?
19:48:55 <argent0> Hi, what does `hoist` means in the context of e.g `Data.Functor.Foldable`?
19:50:18 <c_wraith> argent0: in recursion-schemes?
19:51:31 <c_wraith> (package names are more important first steps than module names)
19:52:04 <argent0> yes, I ask because google returns that it means lift using ropes.
19:52:16 <argent0> c_wraith: ok
19:52:29 <c_wraith> Sure.  That is a thing the word means.
19:52:45 <c_wraith> More or less, it's yet another synonym for "lift", with a specialized meaning in terms of haskell.
19:53:05 <c_wraith> the mmorph package also has a hoist function with the same purpose, though a different point in the design space.
19:53:44 <c_wraith> In any case, what it actually *does* - it lets you transform a data type
19:55:14 <c_wraith> It's a bit abstract in the case of recursion schemes
19:55:38 <c_wraith> let me play with it for a bit and see if it allows anything fun
19:56:16 <argent0> I'm reading the mmorph hoist now. I'm more interested in `why not lift?` than recursion-schemes in particular.
19:56:42 <c_wraith> well, in mmorph, it's easier to explain
19:57:08 <c_wraith> liftM :: Monad m => (a -> b) -> (m a -> m b)
19:57:14 <c_wraith> That's the relevant "lift" operation
19:57:37 <c_wraith> hoist makes it a bit more abstract
19:58:33 <c_wraith> hoist :: (MFunctor t) => (forall x. f x -> g x) -> t f a -> t g a
19:58:55 <c_wraith> It's still transforming a type variable, but it's transforming a type variable with the kind * -> * instead of *
19:59:11 <c_wraith> So it's a higher-order operation, in some sense
19:59:16 <argent0> is it because of the `morphism` condition on (forall x. f x -> g x)?
19:59:36 <c_wraith> Actually, that type is guaranteed to be a morphism in the sense required.
19:59:57 <c_wraith> Since it has to be polymorphic in x, that makes it a morphism in the required sense
20:01:10 <argent0> ok, but that morphism is more specific than (a->b) from lift. So I was guessing that that's the reason it's named hoist and not lift. Just guessing.
20:02:04 <c_wraith> It's just an indication that it's a similar idea, but different enough to not be interchangeable with lift
20:02:26 <argent0> c_wraith: ok, thanks for the explanation
20:06:41 <Lears> Geh... `Alternative` requires `Applicative`, so `Alternative (Compose f g)` ends up requiring `Applicative g`, even though it only uses `Alternative f`... what a mess. Even if people want Alternative to have some laws involving Applicative or Functor, it really doesn't need a superclass; you can't break laws that don't typecheck.
20:07:29 <c_wraith> aren't some and many part of Alternative?  Those require Applicative
20:08:17 <Lears> They don't need to be there, you can just write them with an Applicative constraint. At worst a few instances aren't as efficient.
20:08:56 <dibblego> some and many requires both
20:09:24 <Lears> Right, I meant some, many :: (Applicative f, Alternative f) => ...
20:09:42 <c_wraith> But the only reason they're in the class is to have those efficient instances.
20:09:54 <c_wraith> Apparently it was important to someone.
20:10:20 <Lears> I'm sure it was easy to smuggle them in with a bad superclass constraint already hanging around.
20:33:23 <glguy> Lears: Thats one of the benefits of the Alt typeclass from semigroupoids: no superclass
20:33:27 <glguy> (other than functor)
20:37:41 <Lears> I had a look at it. I do think there's merit in splitting out the semigroup from the monoid, but the Functor constraint is still misplaced (and would still prevent me from using it in my `Compose f g` where I don't have `Functor g`).
20:43:09 <nshepperd> why even use Compose if g isn't a functor though
20:45:31 <Lears> I was waiting for that! Sometimes you just need type level composition to have the right kind in the right place. Atm I'm writing a lot of stuff with het list and sums, where it's very advantageous to be `(k -> Type) -> [k] -> Type` kinded rather than just `[Type] -> Type`.
20:54:04 <glguy> Lears: For that kind of stuff you're  better off using tools like http://hackage.haskell.org/package/parameterized-utils
20:54:30 <glguy> which is built around that kind of pattern
20:56:26 <glguy> I don't know if it's related to what you're doing, but this a sample use of that package if you're interested: https://github.com/glguy/type-open-syntax-demo/blob/master/src/Demo.hs
21:06:09 <Lears> glguy: It's an interesting looking package, thanks for the link. The kinds I mentioned above are slightly simplified, as they're after I've applied the first `k -> Constraint`. I can use `Typeable` there to get lookup-by-type. It's not clear that I'd be able to do the same with the parameterised hlists, but perhaps the parameterised map would work.
21:10:02 <Lears> Ah, though the map doesn't hold onto the parameters at the type level, so some of my safety constraints wouldn't port.
21:23:06 <Lears> The parameterised list approach would work with an auxiliary GADT `Constrained c f a` transforming the `k -> Type` parameter, but that could be annoying in practice.
22:57:46 <saurabhnanda> has anyone setup spacemacs for haskell development recently? 
22:57:53 * dminuoso nods
22:58:09 <saurabhnanda> should I be using the haskell layer (of spacemacs) or install the intero package separately?
22:58:28 <saurabhnanda> the haskell layer is constantly giving me this error - https://github.com/flycheck/flycheck-haskell/issues/59
22:58:30 <dminuoso> saurabhnanda: You "should" be using whichever you prefer.
22:58:48 <dminuoso> But it's difficult to say whether you should. Nobody here is in an authoritative position to tell you what to do. :)
22:58:53 <dminuoso> Presumably.
22:58:59 <saurabhnanda> on the other hand, intero is re-compiling all 200+ project dependencies for some reason, which makes my believe it is going to end-up breaking something.
22:59:08 <saurabhnanda> dminuoso: should means -- least pain
22:59:34 <dminuoso> saurabhnanda: For least pain I recommend ghcid for "ide features" and just plain syntax highlighting/editor features you enjoy using.
22:59:39 <dminuoso> It "just works"
22:59:54 <dminuoso> I personally use the standard haskell layer with ghcid in another window.
23:00:10 <saurabhnanda> dminuoso: do you use cabal or stack?
23:00:21 <dminuoso> saurabhnanda: cabal v2-*
23:01:08 <saurabhnanda> hmm...
23:01:14 <dminuoso> But I dont see why it shouldnt work with stack.
23:01:50 <dminuoso> saurabhnanda: The advantage of ghcid is that it's practically no-effort to setup, so I recommend you give it a try at least. :)
23:02:38 <saurabhnanda> dminuoso: I use ghcid
23:02:45 <saurabhnanda> but right now the editor is getting in my way
23:02:50 <dminuoso> "getting in my way"?
23:03:03 <saurabhnanda> on every keystroke, flycheck gives me this error - https://github.com/flycheck/flycheck-haskell/issues/59
23:03:21 <dminuoso> saurabhnanda: Ah I dont use flycheck.
23:56:34 <saurabhnanda> dminuoso: disabled flycheck. And filed  a bug with spacemacs https://github.com/syl20bnr/spacemacs/issues/12482 - getting back to writing code now
