00:38:08 <newhoggy> Oh thanks.  I did ask a question about how to generate a rose tree efficiently but I figured I only wanted a rose tree to generate something else and generated that other thing directly which fixed my performance issue.
00:39:50 <Nevoic> https://bpaste.net/show/5ab41aa0d4f5 is there anyway that I could generalize these functions over any "number" here?
00:39:55 <Nevoic> i.e with higher kinds?
01:11:28 <[Leary]> Nevoic: You can do stuff like this with heterogeneous lists <https://gist.github.com/LSLeary/8edadb42c9aeecabbae243066cb9501f>.
01:13:35 <Nevoic> =o
01:15:25 <Nevoic> I was looking at HList's but didn't find anything that advanced or close to what I was trying to do so I felt lost.
01:15:48 <Nevoic> `extract` is pretty much exactly the type I was looking for, that's all kind of crazy.
01:16:23 <Nevoic> What do the random numbers mean?
01:16:25 <Nevoic> like 6 and 11?
01:18:20 <[Leary]> In the Show instances? Those are precedence levels, which inform parsing and generation of enclosing brackets in shown values.
01:33:13 * hackage nvim-hs 2.1.0.2 - Haskell plugin backend for neovim  https://hackage.haskell.org/package/nvim-hs-2.1.0.2 (saep)
01:48:37 <fr33domlover> Hmmm can I represent the following in a way that doesn't have impossible values? I have several values of type (Maybe a), and there's a related value of type (Maybe b), that they share. If all the (Maybe a) are Nothing, then (Maybe b) should be Nothing too, otherwise it must be a Just. I'd love to have a representation in which it's impossible for (Maybe b) to be Nothing if at least one (Maybe a) is a Just,
01:48:40 <fr33domlover> but not sure how to enforce that in the type
01:49:21 <fr33domlover> My only idea is a scary sum-of-products type that makes sure at least one of the (Maybe a) is Just
01:49:30 <fr33domlover> But that's horrible
01:51:26 <dminuoso> fr33domlover: Maybe (a, b)
01:51:56 <Rembane> Wouldn't that cover fr33domlover in b:s?
01:52:28 <dminuoso> Or rather `Maybe (NonEmpty a, b)`
01:52:46 <Rembane> +1
01:53:56 <fr33domlover> dminuoso, Rembane nope, those (Maybe a) values are record fields, not a list :-/ I'll paste code 1 sec
02:00:14 <fr33domlover> dminuoso, Rembane https://share.riseup.net/#vE_eAk-7Vd2P_14iHFRC_g
02:01:18 <fr33domlover> Hmmm s/2/3
02:02:41 <Rembane> fr33domlover: Can you wrap it all in a Sum type? Like, either they all have nice values, or they all are Meh. 
02:03:25 <dminuoso> Or you could have two sum types.
02:04:30 <bahamas> anyone know how to tell ghc where to look for modules when running ghc --make -o Setup Setup.hs? I'm not running this directly, but the nix generic builder for Haskell is. for this reason, it can't find modules used in Setup.hs
02:04:47 <fr33domlover> Rembane, dminuoso, can you give an example? :) Also I'm wondering if there's some existing abstraction for this, like some multi-either thing where some MultiEither3 thing would do, idk :p
02:05:10 <dminuoso> fr33domlover: Im not sure that what you are trying to encode is the best idea. Can you tell us a bit about the context?
02:05:31 <Rembane> fr33domlover: data TW = T1 { x :: Text, y :: Int, z :: Bool, w :: String } | Meh
02:05:51 <Rembane> fr33domlover: That is what I meant which of course when I write it out I dont know if it solves your problem.
02:08:09 <fr33domlover> dminuoso, yes :) I'm parsing a JSON object in which some of the fields and URIs, and objects that contains URIs, and those URIs need to share the same hostname. So when parsing JSON into a Haskell type, I keep only the path part of the URI, and store the hostname in 1 place. Except those URIs and objects are Maybes and if they're all Nothing, there's nothing from which to extract that shared hostname string 
02:08:34 <fr33domlover> dminuoso, obviously it's possible to keep the full URIs, but that also leaves impossible values representable
02:08:45 <fr33domlover> (Ones in which the URIs have different hostname)
02:12:38 <fr33domlover> dminuoso, Rembane, I think I'll just keep w as a Maybe, and handle the impossible cases with case/fromJust/error...
02:12:48 <Rembane> fr33domlover: Sounds like a plan. Good luck! 
02:12:54 <fr33domlover> It seems to be the least bad option lol
02:13:18 <Rembane> ^^ 
02:13:23 <fr33domlover> But I wish I could really encode the invariant in the type :p
02:13:39 <fr33domlover> Maybe with some smart constructor I can improve the situation
02:13:40 <Rembane> I'm very fond of my solution, but I haven't actually used it.
02:14:01 <Rembane> Smart constructors are good stuff
02:14:04 <jusss`> about either monad, I'm confused
02:14:11 <Rembane> jusss`: What conduses you?
02:14:25 <jusss`> Rembane: Either a is the monad, right?
02:14:28 <ski> yes
02:14:32 <Rembane> jusss`: Yes
02:15:13 <jusss`> Rembane: so, Right b has Either a b, but Left a don't has Either a b
02:15:36 <ski> if `y' has type `b', then `Right y' has type `Either a b'
02:15:37 <Rembane> jusss`: That is indeed correct, you cannot do anything with the Left in the Monad instance.
02:15:43 <ski> if `c' has type `a', then `Left x' has type `Either a b'
02:16:06 <ski> (er, `x', not `c'. typo)
02:16:30 <jusss`> Rembane: Left a can do >>= ?  'cause Nothing can
02:16:31 <dminuoso> jusss`: You can think of `Either a b` as encoding a computation for a value of type `b` with the possible failure of type `a`
02:16:52 <dminuoso> jusss`: So `Either Text Int` can be thought of a computation to produce an `Int` that could however fail with a Text error.
02:17:02 * ski would prefer renaming the type variables in the type to e.g. be `Either e a'
02:17:13 <dminuoso> ski: Fair point.
02:17:25 <Rembane> ski: Yes! 
02:17:34 <ski> (a point for jusss`, really, not for you two)
02:17:52 <Rembane> Then we are three that agree. :)
02:18:03 <jusss`> ski: Left e can not has >>=, fmap, and <*> , right?
02:18:05 <Rembane> jusss`: Left a >>= f -- f doesn't do anything. 
02:18:49 <ski> jusss` : those functions can accept `Left e', sure, if the value `e' has type `e' (not the same thing, just spelled the same, as a mnemonic)
02:18:51 <jusss`> or can we apply '>>=' on Left e ?
02:19:02 <ski>   Left  e >>= _ = Left e
02:19:08 <ski> there you go
02:19:19 <ski> we sinply ignore the second argument
02:19:39 <maerwald> so basically hackage revisions are able to break cabal freeze files, correct?
02:19:39 <ski> you can do something similar, for `fmap', and `(<*>)'
02:19:48 <jusss`> ski: Rembane dminuoso some people always compare Either Monad with If-Else
02:20:06 <jusss`> that's something confused me too
02:20:30 <ski> `Either e' is sometimes called an "exception monad (on exception type `e')"
02:20:47 <ski> you could also think of it as hiding checking of error codes of type `e'
02:20:52 <jusss`> ski: and Result Monad?
02:21:44 * hackage configurator-pg 0.1.0.2 - Reduced parser for configurator-ng config files  https://hackage.haskell.org/package/configurator-pg-0.1.0.2 (vollmert)
02:22:04 <ski> (in e.g. C, it's not uncommon for a function to yielf an error code. if it indicates all went well, we continue with the next operation. otherwise we "short-circuit" the computation, skipping what we would have done next. `Either e' does something similar, as does exceptions in languages that have them as built-in side-effects)
02:22:21 <ski> jusss` : i'm not sure what you have in mind by that ?
02:23:07 <dminuoso> jusss`: The closest analogy to `Either e` is exceptions.
02:23:17 <fr33domlover> jusss`, have you looked into Maybe used as a monad?
02:23:29 <dminuoso> jusss`: You get to write some code, and if you want to abort/shortcircuit the rest of the computation, you "throw" a Right value.
02:23:44 <dminuoso> *Left value!
02:23:54 <dminuoso> It
02:24:18 * ski throws salt over left shoulder, exits room to the right
02:24:26 <jusss`> fr33domlover: yeah, I looked into Maybe Monad
02:24:43 <dminuoso> jusss`: `Either e` is conceptually the same as Maybe.
02:24:55 <ski> `Maybe' is basically `Either ()'. iow the exception type is uninteresting : we only have one possible case of "failure condition"
02:25:13 <dminuoso> jusss`: The only difference is that `Nothing` cannot encode any information into failure. You don't get to write `Nothing "parse failed, no number found"\`
02:25:49 * ski is happy the `Error e' constraint on `Monad (Either e)' was removed
02:25:56 <dminuoso> But with `Either e` you do. If you for example have `Either String Int`, you can write `Left "parse failed, no number found"` which might be equivalent to some `throw "parse failed, no number found"` in some languages.
02:26:02 <jusss`> dminuoso: can I restore a computation into Either e?
02:26:07 <dminuoso> kqr: 
02:26:10 <dminuoso> jusss`: "restore"?
02:26:27 <jusss`> dminuoso: sorry, store
02:26:37 <dminuoso> jusss`: Well, `Either e a` but yes.
02:26:40 <ski> you can "catch" an exception, and try something else, if that's what you mean
02:26:45 <fr33domlover> jusss`, if you understand Maybe's Monad instance, then you can think of (Either a b) as the same thing, except in Maybe the "error" is always Nothing while in (Either a b) you can choose some type a to be the "error" type
02:27:09 <ski> fr33domlover : hm, we renamed it to `Either e a', just saying :)
02:28:03 <jusss`> dminuoso: fr33domlover think (Either a) as Maybe,  it may be good to me
02:28:09 <ski> jusss` : can you elaborate on what you mean by "store a computation into `Either e'" ?
02:28:13 * hackage configurator-pg 0.1.0.3 - Reduced parser for configurator-ng config files  https://hackage.haskell.org/package/configurator-pg-0.1.0.3 (vollmert)
02:28:25 <fr33domlover> ski, renamed in this conversation? Or in GHC? ^_^
02:28:32 <ski> in this conversation
02:28:38 <fr33domlover> Ah ok :)
02:28:56 <ski> @type maybe (Left ()) Right
02:28:57 <lambdabot> Maybe b -> Either () b
02:28:58 <jusss`> ski: like if-else, 
02:29:10 <ski> @type either (\() -> Nothing) Just
02:29:10 <dminuoso> jusss`: No, not like if-else
02:29:12 <lambdabot> Either () a -> Maybe a
02:29:24 <dminuoso> jusss`: Either encodes exceptions.
02:29:44 <ski> jusss` : it sounds to be like you *maybe* have "catching exception / error condition" in mind
02:30:48 <jusss`> https://glebbahmutov.com/blog/if-else-vs-either-monad-vs-frp/
02:32:12 <dminuoso> jusss`: Im not convinced that your resource is worthwhile reading.
02:32:46 <fnurglewitz> not sure if this is a good example
02:32:48 <fnurglewitz> jusss`: https://pastebin.com/4SpUCBF3
02:32:51 <ski> > catchError (do x <- return 2; y <- throwError 42; return ("result : " ++ show (x + y))) (\e -> return ("error : " ++ show e))  :: Either Integer String
02:32:53 <lambdabot>  Right "error : 42"
02:32:58 <ski> > catchError (do x <- return 2; y <- return 3; return ("result : " ++ show (x + y))) (\e -> return ("error : " ++ show e))  :: Either Integer String
02:33:00 <lambdabot>  Right "result : 5"
02:33:21 <fnurglewitz> if you check that out you can see that it's like `getAge "Bob"` is throwing an exception
02:33:35 <fnurglewitz> you can load it up with ghci and launch ageSum to get the error
02:34:04 <jusss`> dminuoso: sorry, I read some articles about either monad in other languages, they implement Maybe as the same, but not Either
02:34:05 <fnurglewitz> well, not the error, the Left value :P
02:35:05 <fnurglewitz> if you remove Bob (poor Bob) you get the actual sum
02:35:33 <maerwald> https://hackage.haskell.org/package/contravariant-1.5.1/revisions/ this just broke my cabal freeze file
02:37:12 <phadej> luckily it's easy to fix, isn't it.
02:37:43 <maerwald> Well, it shows how hackage revisions are a problem
02:37:47 <maerwald> and cabal freeze is unreliable
02:38:02 <maerwald> I can't share a cabal freeze file and be confident it will be buildable
02:38:02 <phadej> maerwald: well, you made a freeze file in an one hour window where maintainer made a mistake
02:38:15 <ski> jusss` : that link seems to be confused about a monad being a value (it is not)
02:38:27 <phadej> new release, which would be later blacklisted would be the similar effect
02:38:57 <maerwald> there should simply be no hackage revisions... or cabal freeze should record the hackage revision as well
02:40:05 <maerwald> and tbf, the revision change doesn't even make much sense to me, because the project was perfectly buildable
02:41:10 <phadej> maerwald: https://github.com/haskell/cabal/issues/3502#issuecomment-352172919
02:42:19 <phadej> adding index-state to freeze files shouldn't be big feature to implement, just needs someone to do it!
02:42:35 <ski> jusss` : and the post doesn't seen to mention the monadic bind/extend operation `(>>=)'/`(=<<)' at all (`Either.js' in "Ramda Fantasy" does mention `chain', though)
02:43:50 <ski> fnurglewitz : error, left, sinister, all same thing ;)
02:44:37 * ski . o O ( `data Vel a b = Sinister a | Dexter b' )
02:46:08 <jusss`> ski: there's also another one https://dev.to/rametta/basic-monads-in-javascript-3el3
02:47:06 <ski> jusss` : unfortunately, ime, many monad explanations in other languages sortof miss the point (or worse)
02:47:55 <jusss`> ski: can we implement Maybe Monad in a language without ADT
02:47:59 <fnurglewitz> I'm not an expert but i'm genuinely curious about why should anyone use Either in a language which has try/catch as first class
02:48:22 <fnurglewitz> *first class construct
02:48:27 <fnurglewitz> or whatever it's name is
02:48:48 <jusss`> fnurglewitz: every language has none and if-else, so what's the maybe used for  
02:49:51 <jusss`> I think they want transform that if-else pattern to bind pattern
02:50:02 <fnurglewitz> mainly because you cannot have NULLs imho :P
02:50:04 <ski> jusss` : oic. yes, `data Result err ok = Err err | Ok ok' is basically the same as `data Either a b = Left a | Right b'
02:50:06 <jusss`> and I don't know why this bind pattern is useful
02:50:36 <ski> jusss` : "can we implement Maybe Monad in a language without ADT" -- if we have a way to encode algebraic data types / sum/variant types, yes
02:51:10 <phadej> :t maybe
02:51:11 <lambdabot> b -> (a -> b) -> Maybe a -> b
02:51:22 <phadej> (forall r. r -> (a -> r) -> r) ~ Maybe
02:51:45 <phadej> maybe your language has RankNTypes!
02:51:45 <ski> @unmtl StateT s (Either e) a
02:51:46 <lambdabot> s -> Either e (a, s)
02:51:48 <ski> fnurglewitz ^
02:52:15 <ski> fnurglewitz : one might want to have state that automatically reverts when an exception is thrown
02:52:25 <dminuoso> jusss`: Maybe is to encode exceptions/failure.
02:52:26 <jusss`> ski: what if there's an object, that it implement mempty, mappend, fmap, bind, apply, return and unit, can we say it's monadic value or object?
02:52:49 <dminuoso> jusss`: `Either e` is also to encode exceptions/failure, the only difference is that you can attach information to an exception.
02:52:51 <dminuoso> Say an error message.
02:52:56 <fnurglewitz> ski: good luck implementing that transformer in javascript though
02:53:03 <dminuoso> Or some context about the erroneous condition.
02:53:12 <jusss`> dminuoso: that's 'cause static languages need a specific result type, so there's Nothing or Just a
02:53:15 <ski> jusss` : `mempty' and `mappend' are for monoids, not monads
02:53:41 <dminuoso> jusss`: Im not sure what you mean by that.
02:53:41 <jusss`> dminuoso: but dynamic languages don't need return a specific result type, they can return whaever they want
02:53:51 <dminuoso> jusss`: It's not about dynamic/static languages, really
02:54:01 <ski> fnurglewitz : i don't see why it couldn't be done. manually constructing the instances, of course, there's no automatic instance resolution
02:54:51 <jusss`> ski: like I said, monadic value, they should be instance of monoid and semigroup, right?
02:55:10 <dminuoso> jusss`: No, they are different concepts.
02:55:12 <ski> jusss` : no. values are not instances of type classes. types are
02:55:20 <jusss`> ok
02:55:48 <ski> jusss` : but yes, you could call the object you mentioned a "monadic value". or a "monadic action"
02:56:09 <ski> (if we assume you ignore the irrelevant `mempty' and `mappend')
02:56:24 <jusss`> wait a sec, what are the instances of monoid and semigroup?
02:56:35 <dminuoso> jusss`: Anything that satisfies their interface and laws.
02:57:15 <ski> `Sum a',`Product a',`Max a',`Min a', e.g.
02:58:13 <ski> (the latter two only being semigroups. in the latter two, we assume that `Ord a' holds. in the former two, we assume `Num a')
02:58:39 <Ariakenom> "'existential types' - an extension to Haskell that can be found in most compilers. " Is that true and which are "most compilers"? https://wiki.haskell.org/Existential_type
02:58:58 <ski> there's also `Any' and `All', which are the disjunctive and conjunctive monoids on `Bool'
02:59:00 <dminuoso> Ariakenom: Considering there's only one compiler alive and kicking...
02:59:25 <merijn> UHC...
02:59:36 <merijn> (which also supports existentials, afaik)
02:59:46 <ski> Ariakenom : Hugs has/had existentials. and i believe JHC and several others as well ?
03:00:02 <ski> (probably HBC as well ?)
03:00:31 <dminuoso> https://wiki.haskell.org/Implementations
03:00:33 <dminuoso> Oh interesting.
03:01:44 <Ariakenom> nice, thats good
03:02:19 * ski misses having augustss in the channel
03:02:30 <dminuoso> jusss`: I would recommend you stay clear of JavaScript articles trying to explain functional concepts or Haskell abstractions.
03:04:32 <jusss`> dminuoso: actually I just want to know how haskell abstractions work on other languages, 'cause lots people don't use haskell at work
03:04:40 <dminuoso> jusss`: they generally dont.
03:04:47 <dminuoso> jusss`: Emphasis on generally here.
03:05:47 <ski> <ski> jusss` : unfortunately, ime, many monad explanations in other languages sortof miss the point (or worse)
03:06:02 <ski> @where UHC
03:06:02 <lambdabot> The Utrecht Haskell Compiler, implemented using attribute grammars, at <http://www.cs.uu.nl/wiki/UHC>
03:06:03 <dminuoso> I would remove the "in other languages" part.
03:06:06 <dminuoso> :-P
03:06:07 <ski> @where UUAG
03:06:07 <lambdabot> http://www.cs.uu.nl/wiki/HUT/AttributeGrammarSystem
03:06:19 <ski> dminuoso : yea, that too :)
03:07:01 <dminuoso> jusss`: The best way to understand haskell abstractions is not to look for them in other languages, but to practice and study them in Haskell itself.
03:07:19 <dminuoso> At least for people just wanting to write programs.
03:07:31 <jusss`> dminuoso: and after that, can we implement them in other languages?
03:07:40 <dminuoso> jusss`: If you have a firm grasp on it, you can sure!
03:07:42 <dminuoso> I did too.
03:07:48 <dminuoso> And then I failed so many times and horribly.
03:08:16 <dminuoso> Learning why was very valuable.
03:08:29 <jusss`> actually I haven't tried to do something with haskell yet
03:08:48 <ski> hm, that link seems to be broken (atm ?), try <https://web.archive.org/web/20170315063112/http://foswiki.cs.uu.nl/foswiki/HUT/AttributeGrammarSystem>, and
03:08:52 <jusss`> 'cause there're lots of concepts and abstraction stuffs make me confused
03:08:53 <ski> @hackage uuagc
03:08:54 <lambdabot> http://hackage.haskell.org/package/uuagc
03:09:42 <ski> jusss` : learning a new programming paradigm will be a bit like learning to program from scratch all over again
03:09:46 <dminuoso> jusss`: Haskell requires a certain degree of unlearning. 
03:10:12 <ski> jusss` : were you confused by loops, assignment, function calls, when you first learned programming ?
03:10:23 <dminuoso> jusss`: I consider myself a competent average programmer. When I started Haskell it was extremely frustrating to know that I could write a kernel in C++, but unable to solve the most basic programming problems in Haskell.
03:10:50 <dminuoso> Writing simple looks/list operations sometimes took me hours.
03:11:03 <dminuoso> At that time I had over 8 years of programming experience.
03:12:22 <dminuoso> But like ski points out, that's simply because in a lot of ways its like you are learning something from scratch without much to hold on to.
03:12:44 <fnurglewitz> dminuoso: I feel your pain, same here
03:13:36 <ski> it is best to let go of preconceptions of how you'd approach some particular problem, in another programming paradigm. try not to compare that much. when you better understand, in the context of (say) Haskell, *then* you can look back and compare
03:13:39 <jusss`> ski: dminuoso but other languages's experiences make me learning haskell more difficult
03:13:57 <ski> jusss` : yes, because you have things to unlearn
03:14:06 <jusss`> maybe everyone should learn haskell first, then others
03:14:15 <dminuoso> Accepting that things can be looked at/written/approached differently can be very hard to accept.
03:14:31 <fnurglewitz> jusss`: then you would have the same issues but "reversed"
03:14:34 <dminuoso> But you gain abilities to look at problems from different angles.
03:15:06 <fnurglewitz> "what is this for loop? bha, that's useless, recursion all the way! => dead stack" :P
03:15:58 <ski> hm, istr someone who started with Haskell being very confused by assignment in (say) Python
03:16:08 <jusss`> the only I gain I think it's that I only focus on the relationship between functions, not the function how it works
03:16:14 <fnurglewitz> and what about eager evaluation?
03:16:30 <merijn> fnurglewitz: Haskell (well, GHC) doesn't use a call stack, though
03:16:31 <dminuoso> jusss`: The best way is to just keep solving problems that are barely beyond your skill horizon.
03:16:32 <fnurglewitz> if you assume that it's lazy it could lead to potential headaches
03:16:47 <tdammers> I don't think this is entirely true. Haskell tends to take abstraction a couple steps further than most mainstream languages, so it's not just that things you learn in Haskell are different from things you learn in another language, they're also more general
03:17:00 <ski> merijn : i think fnurglewitz meant in some other language :)
03:17:02 <dminuoso> jusss`: So the trick is picking problems that are too difficult to write them without thinking, but not too hard as to frustrate you into stopping. :)
03:17:02 <fnurglewitz> merijn: it was a potential scenario where someone who started with haskell moved to another (imperative) language
03:17:21 <merijn> Trampoline all the things :p
03:17:32 <ski> tdammers : "this" being ?
03:17:53 <dminuoso> tdammers: I agree, though when I was learning Haskell I was unable to see it. And Im not sure that its useful to know the similarities beforehand.
03:18:00 <tdammers> ski: the idea that when you learn haskell first, you have the same problems when learning another language, only reversed
03:18:14 * hackage pkgtreediff 0.1 - Package tree diff tool  https://hackage.haskell.org/package/pkgtreediff-0.1 (JensPetersen)
03:18:34 <dminuoso> tdammers: Realizing how Haskell is not so different from most languages was an enjoyable revelation to me... :)
03:18:54 <dminuoso> I wouldn't have believed you when I was just starting, however.
03:19:08 <tdammers> dminuoso: yes, absolutely. but there is something about this generalization thing that sets haskell apart
03:19:32 <tdammers> take for instance monoids. they exist in all programming languages in some form, but haskell makes them 1) explicit, and 2) generalizes the concept
03:19:56 <Athas> The wildest difference between Haskell and other languages is polymorphic recursion.
03:19:56 <fnurglewitz> dminuoso: the main difference is that you cannot "copypaste" snippets of code and make them work together
03:19:58 <tdammers> so now you can reason about your code in terms of generalized monoidal operations instead of addition, multiplication, list concatenation, etc.
03:20:11 <fnurglewitz> dminuoso: most likely the types won't match
03:20:39 <dminuoso> fnurglewitz: You actually kind of can often.
03:20:45 <dminuoso> Not that it's a good idea..
03:20:56 <tdammers> it's just as bad an idea in haskell as it is in the next language
03:21:19 <tdammers> haskell just tells you when you're about to f** up
03:21:30 <dminuoso> fnurglewitz: Even Python code can be encoded into Haskell very directly...
03:21:46 <fnurglewitz> dminuoso: got a simple example?
03:21:49 <Athas> I think Haskell programs are less buggy because the slow compiler gives you a lot of time to think.
03:21:50 <dminuoso> fnurglewitz: In some ways its an enlightening task since it shows you just how many things are wrong with Python.
03:21:54 <ski> tdammers : *nod*. yea, i don't buy that completely
03:22:48 <tdammers> ski: not completely, no, and there's actually a bit of a problem in that two libraries independently modeling the same thing will expose different types, and even if they should be compatible, they are often not
03:23:17 <dminuoso> @remember Athas | I think Haskell programs are less buggy because the slow compiler gives you a lot of time to think.
03:23:17 <lambdabot> It is stored.
03:24:05 <ski> @forget Athas | I think Haskell programs are less buggy because the slow compiler gives you a lot of time to think.
03:24:05 <lambdabot> Done.
03:24:08 <ski> @remember Athas I think Haskell programs are less buggy because the slow compiler gives you a lot of time to think.
03:24:08 <lambdabot> It is stored.
03:25:39 <dminuoso> fnurglewitz: The lack of typing can be expressed by using Dynamic. Keep sprinkling toDyn/fromDyn/fromDynamic on the code. Just as an example.
03:25:47 <fnurglewitz> I think that the "self-jokes" (how do you say it in english?) are the best part of the haskell community :P
03:26:02 <fnurglewitz> dminuoso: will take a look, ty
03:26:39 <fnurglewitz> dminuoso: https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Dynamic.html#v:toDyn first time I see this :D
03:27:16 <tdammers> let's just say intellectual honesty is valued highly in the haskell community, and haskellers are among the first to admit to their favorite language's deficiencies
03:29:36 <ski> tdammers : two libraries, in Haskell ?
03:31:01 <cr0xd> leave
03:32:12 <tdammers> ski: could be two aspects of the same thing. like for example an HTTP server and client. Or one library that generates HTML, and another that consumes it.
03:32:37 <Ariakenom> my latest bug: \f -> f x :: t is not (\f -> f x) :: t
03:33:18 <tdammers> for example, take the curl package to fetch an HTTP response from somewhere, and then try forwarding it into a WAI application
03:33:51 <dminuoso> Ariakenom: That Ive wondered about repeatedly.. what is the fixity of :: ?
03:34:40 <tdammers> you can't just pass the CurlResponse to the WAI response writer, because that expects a Network.Wai.Response, not a CurlResponse, so you have to manually convert between the two, even though they represent the exact same thing
03:34:45 <dminuoso> And equivalently, if you TH and you move the fixity declaration into the next declaration group, it shouldn't kick for the current splice, should it?
03:44:38 <jackdk_> I have an STM question. I have this snippet, which works, but I would like it to not busywait: https://pastebin.com/bkBzm2Lc
03:45:13 <phadej> busywait?
03:45:38 <jackdk_> it will spin in the loop, will it not?
03:46:14 <jackdk_> if the readTVar returns something other than Closed, and the tryReadTQueue returns Nothing
03:46:42 <phadej> I see, check `retry`
03:47:07 <phadej> ah, no
03:47:13 <phadej> you want to do something else onClose
03:47:46 <phadej> you may simly readTQueue
03:47:55 <phadej> it will block, until there's something
03:48:21 <phadej> or `retry` if you want it to recheck the `state`
03:48:33 <Ariakenom> jackdk_: but you don't loop on mBytes == Nothing?
03:49:27 <jackdk_> phadej: I don't quite understand the retry comment. If I do readTQueue, and another thread does a writeTVar state then I seem to stay blocked
03:50:01 <phadej> jackdk_: you can use `tryReadTQueue`, and if that one returns nothing, `retry`
03:50:14 <phadej> retry will retry whole transaction, so will recheck state
03:50:41 <jackdk_> Ariakenom: well spotted. That would be one of the other bugs I am chasing down
03:51:08 <Ariakenom> so what case is busy waiting?
03:51:22 <jackdk_> phadej: thank you, I will try that
03:51:37 <jackdk_> Ariakenom: probably the code that's in my head as opposed to the pastebin
03:52:11 <Ariakenom> ah ok :)
03:52:33 <jackdk_> I should probably set a rule that I'm not allowed to write concurrency code after 1800
03:53:01 <dminuoso> Concurrency is hard no matter the time. :p
03:55:55 <Ariakenom> dminuoso: I found that amusing.
03:56:57 <jackdk_> me too
03:59:13 * hackage dsp 0.2.5 - Haskell Digital Signal Processing  https://hackage.haskell.org/package/dsp-0.2.5 (HenningThielemann)
04:14:21 <jackdk_> phadej I think that's done exactly what I want. Thanks again.
04:15:02 <jackdk_> magthe: how'd you get on with Hedgehog?
04:27:05 <c4droid> Hi, Someone can recommended a good development environment for haskell?
04:27:45 <f-a> c4droid: if you like minimalism, vim (or any editor) + ghcid would suffice
04:28:08 <c4droid> what is ghcid? 
04:28:50 <c4droid> I more like Emacs...
04:28:56 <f-a> that will do too
04:29:14 <dminuoso> c4droid: Any editor you are comfortable with will be sufficient.
04:29:17 <f-a> https://github.com/ndmitchell/ghcid#readme <-- basically it reloads your project when you save a file
04:29:34 <dminuoso> c4droid: Generally the tooling in haskell is very poor to non-existent, but ghcid is a good compromise that will work with any editor you have.
04:29:48 <f-a> so types error pops up --> you modify --> more errors --> etc.
04:30:25 <jackdk_> I have been happy with dante, though I needed to do some dir-locals.el magic to make it play nice (especially with nix)
04:30:37 <jackdk_> (I use and recommend emacs)
04:30:59 <jose_zap> c4droid if you can cope with an immature yet very promising and powerful platform, I recommend emacs + lsp + haskell-ide-engine
04:31:12 <dminuoso> It will just lock you into stack...
04:31:15 <dminuoso> :-)
04:31:25 <dminuoso> (Or was it cabal v1?)
04:31:43 <fendor> stack and cabal v1, but cabal new-build support is coming ;D
04:31:50 <c4droid> But someone recommend haskell-ide-engine.. As I cloned haskell-ide-engine repository, I compile it using 6-7 hours.. 
04:31:51 <dminuoso> fendor: Im looking forward to it.
04:31:57 <fendor> dminuoso, me too
04:32:20 <dminuoso> c4droid: Personally I think the usefulness of IDE/editor integration is overvalued.
04:32:23 <fendor> c4droid, yes, it takes a lot of time. But if you only need a specific ghc version, it doesnt take that long usually
04:32:46 <c4droid> QAQ
04:33:02 <c4droid> I'm crying... QAQ
04:33:04 <jose_zap> c4droid you don't need to compile it for all versions, only the ghc version you use
04:33:30 <c4droid> I compile the ghc-8.6.5
04:33:40 <c4droid> using 7 hours.
04:33:47 <c4droid> QAQ
04:33:49 <dminuoso> c4droid: ghcid gives you the bare minimum fast feedback for mistakes, and then the main important tool is an editor with good text editing ergonomics. :) 
04:34:02 <dminuoso> c4droid: 7 hours sounds off.
04:34:12 <jose_zap> interesting, I guess it depends on the hardware and the network speed. It takes aournd 35 minutes for me for a single version from scratch
04:34:36 <c4droid> I use the virtial machine.
04:34:43 <c4droid> *virtual
04:36:46 <c4droid> It's going to take time to configure Emacs again.
04:36:53 <c4droid> :)
04:41:13 <c4droid> I have a question: cabal and stack, which haskell package manager is better to use?
04:41:56 <merijn> c4droid: Personal preference
04:42:59 <merijn> c4droid: stack gives you static fixed snapshots of packages and manages GHC for you. Cabal-install dynamically resolves dependencies from hackage (including state of the art versions) and just uses your system GHC. Which is better depends on what workflow you prefer
04:43:19 <dminuoso> c4droid: Be wary that it used to be that cabal had some major deficiencies, which got addressed in a new set of commands known as `new-*` or `v2-*`. So if you do do some research you might stumble over old articles that were before cabal has gotten these upgrades.
04:43:49 <bahamas> c4droid: you can try stack first. it might be enough in the beginning, since it does more stuff
04:43:56 <c4droid> Emmm, I choose stack, because stack can choose the ghc versions.
04:44:12 <c4droid> But my system provides haskell-platform.
04:44:12 <jose_zap> c4droid stack is more beginner friendly in most of the cases
04:44:45 <jose_zap> you're likely to find less surprises with stack than with other alternatives
04:45:15 <c4droid> Because I like lightweight environment.
04:45:20 <dminuoso> jose_zap: I doubt that stack is more beginner friendly.
04:45:28 <bahamas> is the package database where ghc looks for modules? does that mean that cabal also uses this package database?
04:45:54 <dminuoso> jose_zap: Its really personal preference. I found `cabal v2-*` to be much simpler and easier to get into since there were less parts to it.
04:46:00 <merijn> bahamas: People confuse a bunch of things
04:46:25 <dminuoso> jose_zap: Id in fact even argue that stack has more surprises. :)
04:46:36 <jose_zap> dminuoso very posisble, when I started learning there was no `cabal v2-*` so stack has been my go to recommendation for beginners
04:46:43 <merijn> bahamas: There's: 1) cabal (the package spec), 2) Cabal (the library, implementings said spec), 3) cabal-install (the cabal executable, which can build code from cabal specs)
04:46:46 <jose_zap> it actually just works
04:46:54 <dminuoso> jose_zap: cabal v2-* just works too. :)
04:47:00 <bahamas> merijn: alright. I'll state my actual problem then :)
04:47:04 <merijn> bahamas: Stack *also* uses cabal (the spec) and Cabal (the library) to resolve dependencies and look things up
04:47:05 <jose_zap> cool, I'm happy it has improved
04:47:24 <jose_zap> dminuoso does it download the ghc version it needs to use already?
04:47:28 <merijn> bahamas: GHC ships with a Cabal API used by, well, Cabal :)
04:47:40 <dminuoso> jose_zap: No, it relies on your system GHC. But with ghcup you can manage these easily too.
04:47:55 <jose_zap> ok, so stack keeps having a lead on friendliness
04:48:02 <c4droid> Emacs + ghcid + stack. I think is better for me.
04:48:05 <dminuoso> jose_zap: Im not convinced, personally.
04:48:13 <jose_zap> that's alright
04:48:46 <dminuoso> jose_zap: To me stack has more moving parts. It's harder to know 'where do I need to put XYZ to get effect ABC'. With everybody also using hpack, you get even more indirection, more documentation to look at.
04:49:02 <bahamas> merijn: the short version of my problem: nix runs ghc directly when trying to build a package. the command is: ghc-8.6.2 --make -o Setup Setup.hs. in my case, it can't find a module imported by Setup.hs, even though the library is listed in setup-depends
04:49:17 <dminuoso> With cabal you just add dependencies to build-depends. With stack you have 3 places to put them, and they have different purposes.
04:49:31 <dminuoso> You need to learn about stack, hpack and strangely about .cabal too :-P
04:49:32 <bahamas> merijn: so that's why I was asking. where does ghc look for modules?
04:49:32 <merijn> bahamas: ghc doesn't know about cabal files (and thus not about setup-depends)
04:49:40 <c4droid> cabal is very very very difficult to learn.
04:49:49 <jose_zap> dminuoso could be, it is difficult for me to judge now since I'm used to stack and the concepts are clear. Lats time I looked at cabal I got confused by cabal.project vs project.cabal
04:49:57 <merijn> bahamas: So you need to manually tell ghc to use those setup-depends packages
04:50:08 <bahamas> merijn: how do I do that?
04:50:23 <dminuoso> jose_zap: Im willing to argue this is one of the problems of stack. You don't get familiar with the underlying tech you are using anyway. :)
04:50:32 <merijn> bahamas: Dunno, consult the GHC user's guide? :)
04:51:00 <dminuoso> jose_zap: But yes, if you have learned something it's obviously not confusing anymore. Just like `cabal v2-*` is no stranger to me. :)
04:51:08 <bahamas> merijn: yeah, I'm looking at it
04:51:18 <jose_zap> dminuoso I actually think that's a an advantage, at least for the way I learn things. I love learning by doing and then trying to understand why it worked in the first place. I often get overwhelmed when learning stuff by first principles
04:51:39 <jose_zap> dminuoso I totally agree, that's why I think I cannot be a fair judge since I haven't actaully used v2
04:52:11 <c4droid> Emm. another problem.
04:52:44 <fendor> i like the speed cabal new-*. It is way faster than stack in my experience
04:52:47 <c4droid> The Emacs plugins
04:52:49 <dminuoso> jose_zap: It's become `vim` vs `emacs` sort of. 
04:52:59 <fendor> i like vim
04:53:00 <jose_zap> very true :)
04:53:09 <jose_zap> I also like vim haha
04:53:22 <fendor> never tried emacs though :D
04:53:24 <dminuoso> I like both, so I use emacs with evil layer.
04:53:34 <c4droid> haskell-mode, company-mode. 
04:54:31 <c4droid> The haskell have company-backend
04:54:39 <c4droid> for ghcid? 
04:55:29 <dminuoso> c4droid: ghcid does not need any integration. You just run it in a shell somewhere, perhaps in emacs or your favourite terminal emulator.
04:56:06 <c4droid> I more like to use GUI's Emacs.
04:56:39 <dminuoso> c4droid: You can probably run ghcid inside eshell.
04:56:48 <c4droid> I mean the auto completion and symbol index.
04:57:29 <dminuoso> hasktags?
04:59:49 <c4droid> Can you show me some example emacs configuration?
05:06:18 <c4droid> Ok, The emacs configuration is difficult, changing to vim. :P
05:06:23 <c4droid> lol
05:08:58 <c4droid> Have anybody using vscode?
05:09:15 <c4droid> lol
05:10:06 <fendor> c4droid, i do, with haskell-ide-engine
05:11:04 <c4droid> I'm looking a vscode extension, named haskell-ghcid. It seems like integrated ghcid at vscode.
05:12:40 <c4droid> fendor: your haskell-ide-engine is compile from source code or?
05:13:15 <fendor> c4droid, yes, i have compiled it from source. Alternatively, i use nix to get a binary cache
05:14:00 <c4droid> Emm, Did you use NixOS?
05:14:37 <jose_zap> fendor do you use nix alone or combined with stack?
05:15:35 <fendor> c4droid, i do have nixos, but afaik, all-hies is not exclusive to nixos.
05:15:49 <fendor> jose_zap, development of hie with stack, normal installation nix :)
05:16:08 <jose_zap> makes sense
05:16:15 <c4droid> I hate compile the hie
05:16:21 <c4droid> QAQ
05:17:27 <fendor> I fear that is reasonable :( maybe you can use nix though?
05:17:49 <c4droid> I'm using arch linux, so.. 
05:19:11 <fendor> per se, that is not an issue, you can install nix alongside other package managers. However, afaik, arch kind of denies the existence of nix, so there is no docs about it
05:20:33 <c4droid> Emm.. 
05:21:49 <c4droid> Maybe I can try ubuntu
05:30:19 <merijn> hmm, I'm creating pipes to talk to a subprocess, but the process package doesn't have a way to close the other side of a pipe after starting the new process, right?
05:30:56 <merijn> (I mean, the CreatePipe seems to handle that for stdin/stdout/stderr, but not for extra pipes)
05:31:13 * hackage hpqtypes-extras 1.9.0.1 - Extra utilities for hpqtypes library  https://hackage.haskell.org/package/hpqtypes-extras-1.9.0.1 (MikhailGlushenkov)
05:31:27 <Ven``> Hi! I'm trying to implement Plated for my AST, but I'm getting stuck due to my AST ADT being split in several chunks. I want to recursively traverse the different ADT types. Here are the 3 parts: https://gist.github.com/vendethiel/2e8ffcdae1d863f077612b0b6c4c9842
05:39:52 <aveltras> c4droid: doesn't this work for nix and arch https://github.com/reflex-frp/reflex-platform/blob/develop/notes/ArchLinux.md ? never tried it as i don't use arch
05:44:41 <c4droid> aveltras: Thanks, Now I'm trying
05:50:58 <jpoeta2> Hello Im not sure if this is the best channel to ask this question. But at the moment im looking for a software very similar to Notepad++ in LINUX. Does anybody here familiar to Notepad++ and linux?
05:53:51 <aldum> for a smooth transition, I recommend geany, but for the long term, I'd get into vim :)
05:53:57 <Ven``_> jpoeta2: like sublimetext?
05:54:25 <yushyin> geany, kate
05:55:12 <jose_zap> I remember using kdevelop several years ago and it was super promising
05:55:28 <jose_zap> jpoeta2 but vscode is probably a safer bet today
05:59:25 <jpoeta2> Thank you guys I'm specifically looking for'
05:59:33 <jpoeta2>  find and replace in the bookmarked lines in Notepad++.
06:01:46 <c4droid> notepad++ is working fine at windows.
06:03:28 <tdammers> maybe bug the notepad++ folks to provide a native Linux build then?
06:04:32 <jpoeta2> I use this  https://youtu.be/SiPLZzRqEwM
06:05:53 <jpoeta2> i use wine and notepad++ thats doing it for the moment but I wanted to know if somebody knows of an alternative Thank you guys
06:06:37 <aldum> you could sed
06:06:41 <aldum> but also, geany
06:06:42 <bahamas> this guide makes me believe that using cabal or running `runhaskell Setup.hs` are equivalent, but they aren't. https://www.haskell.org/cabal/users-guide/installing-packages.html#building-and-installing-packages am I mistaken?
06:07:10 <aldum> does most of this search magic
06:07:48 <bahamas> I mean, running cabal build will start downloading dependencies. runhaskell Setup.hs simply starts building stuff
06:10:14 <c4droid> aveltras: Did you have nix installation manual for fedora?  my arch linux is crashed. the fedora system is working fine
06:12:06 <dTal> KDE's Kate also runs on Windows: https://kate-editor.org/get-it/
06:12:18 <dTal> (Kate is currently my favorite editor)
06:12:34 <aveltras> c4droid: i think i already installed nix on fedora without issue yes, however i usually use ubuntu or nixos
06:14:21 <c4droid> aveltras: dnf install nix? 
06:18:03 <aveltras> c4droid: no, the canonical way to install nix is with the command given on the site  https://nixos.org/nix/
06:18:49 <aveltras> c4droid: it'll add all the nix commands in your profile and create the /nix/store, should be ready when you reboot
06:19:40 <c4droid> I just install haskell-ide-engine and uninstall nix.
06:19:43 <aveltras> c4droid: nix is supposed to be used in parallel of the distribution dependency manager as it is itself a dependency manager
06:20:30 <c4droid> I know
06:21:10 <c4droid> But after installed haskell-ide-engine, I want to uninstall nix, so... 
06:21:47 <aveltras> c4droid: hie installed through nix ?
06:21:58 <c4droid> yeah.
06:22:28 <aveltras> c4droid: i don't think you can do that since everything installed through nix is stored in /nix/store, the hie executable will be there too
06:23:25 <c4droid> emmm... Not another may to install hie? 
06:23:36 <c4droid> *way
06:24:09 <aveltras> c4droid: you can install hie with stack as described in the readme, i don't personnaly use hie
06:26:11 <aveltras> c4droid: the main point of nix here is that you can benefit from the binary cache with cachix and projects like https://github.com/Infinisil/all-hies, cause hie is pretty long to compile yourself, which you'll have to do with stack
06:28:41 <c4droid> QAQ, In the end, It cannot find way out of compile.. 
06:30:05 <aveltras> c4droid: haven't tried it in a while but i think hie is still a bit rough around the edges, in the meantime you could try a much simpler approach like https://github.com/ndmitchell/ghcid
06:30:35 <aveltras> c4droid: combined with vscode dedicated extension, setup is pretty simple and highlights errors as you code
06:34:46 <c4droid> OK.
06:35:21 <c4droid> But, completion at vscode.. 
06:37:17 <aveltras> c4droid: seems haskell tooling is not at a point where you can have it all yet, you have to choose your trade-offs
06:38:21 <c4droid> OK, I will find the another solution.
06:38:25 <aveltras> c4droid: if you want auto completion, you could try https://github.com/rikvdkleij/intellij-haskell but it only works with stack projects which may or may not be a problem depending on the project
06:38:55 <aveltras> c4droid: something nice with this one is that it downloads all your dependencies source so you can inspect it directly from the ide
06:40:13 <c4droid> I'm more prefer to use the vscode.
06:41:21 <aveltras> c4droid: then you have other extensions like haskelly or haskero which some people have used successfully, they are also based on the https://github.com/chrisdone/intero project, which also make them only work with stack projects
06:43:42 <c4droid> OK
06:43:46 <c4droid> Thanks
06:49:10 <halogenandtoast> Am I missing something (readLn :: IO String); *Main> Hello; *** Exception: user error (Prelude.readIO: no parse)
06:49:24 <merijn> halogenandtoast: Strings have quotes
06:49:34 <halogenandtoast> oh
06:49:42 <halogenandtoast> I am using the wrong function...
06:49:56 <merijn> Also, more importantly readLn is a terrible thing anyway >.>
06:50:03 <halogenandtoast> Well yeah, I wanted getLine
06:50:04 <Taneb> halogenandtoast: you likely want getLine
06:50:15 <Taneb> Ah, you beat me to it
06:50:15 <halogenandtoast> I blame it being early
06:51:45 <halogenandtoast> Taneb: yeah I realized it as soon as merijn said strings has quotes. I should have realized it at "no parse"
06:51:51 <halogenandtoast> *have
06:51:57 <Taneb> :)
06:52:09 <halogenandtoast> Even my English is borked at the moment.
06:57:03 <magthe> jackdk: I haven't had time to look at the stuff that we talked about yet, hopefully I'll get to it tonight or tomorrow...
06:58:44 * hackage describe 0.1.0.0 - Combinators for describing binary data structures  https://hackage.haskell.org/package/describe-0.1.0.0 (riuga)
07:16:19 <kuribas> halogenandtoast: hey, how went the interview?
07:16:48 <halogenandtoast> kuribas: It went alright, getting sent a small project to complete. 
07:17:23 <halogenandtoast> So at least it wasn't an outright no
07:17:42 <kuribas> that's good news
07:18:15 <halogenandtoast> kuribas: indeed, I noticed they had a published style-guide so I am setting up vim to reflect those style choices
07:19:26 <halogenandtoast> I did realize I should probably try to use conduit some more.
07:20:15 <halogenandtoast> I just don't have a lot of cases where I need to stream things.
07:22:42 <halogenandtoast> The company seems pretty solid and it's not cryptocurrency so I'm eager to see how this pans out.
07:23:15 <kuribas> cryptocurrency is just a bubble
07:24:29 <tdammers> it is, but right now it can be a very profitable bubble
07:24:37 <tdammers> the whole gold rush and selling pickaxes thing, you know
07:27:47 <Rembane> I'd love to sell some pickaxes.
07:29:35 <tdammers> there's actually a few companies in the cryptocurrency pickaxe business that use Haskell
07:35:13 * hackage llvm-extra 0.8.0.2 - Utility functions for the llvm interface  https://hackage.haskell.org/package/llvm-extra-0.8.0.2 (HenningThielemann)
07:35:40 <kuribas> tdammers: as long as you know it's short lived :)
07:36:10 <dminuoso> tdammers: I think well-typed has a notable project.
07:36:23 <delYsid``> https://news.ycombinator.com/item?id=20039194 :-)
07:36:54 <tdammers> kuribas: well, I'm not working on anything cryptocurrency, if that's what you mean
07:37:06 <dminuoso> delYsid``: How much sense do braille rendered diagrams make to you?
07:37:19 <dminuoso> delYsid``: (How many rows does your display have by the way?)
07:38:31 <delYsid``> dminuoso: A braille character is 2x4 dots, and you typically have one row of about 20 to 80 characters.
07:38:43 <delYsid``> so 160x4 for graphics :-)
07:39:19 <delYsid``> dminuoso: It works for certain things, actually better then I originally thought.
07:39:20 <dminuoso> delYsid``: Ah so single-row is actually common? I'd have expected there be at least 3 rows just so it's easier to read the surroundings.
07:40:18 <delYsid``> dminuoso: You only really read a row at a time, so it doesnt make a lot of difference.  It would be just a bit more convenient to just move your finger up/down instead of hitting a key to move things.
07:41:05 <delYsid``> However, the device would be sooo much more expensive and less mobile, so the tradeoff isnt worth it right now.
07:44:00 <dminuoso> delYsid``: Oh wow. There is UTF-8 symbols for braille characters? :o
07:44:29 <dminuoso> delYsid``: Just need to figure out how to use your software to prepare that diagram about the typeclass hierarchy the other day. :)
07:45:47 <delYsid``> dminuoso: diagrams-braille is actually written such that you can use baselineText to position ASCII text inside of braille disgrams, which is what you'd need to label things.   Only downside is, that it is slightly buggy / would need more work to be more reliable.
07:46:31 <delYsid``> But the original plan behind the diagrams-braille backend was exactly to support inline labeling.
07:48:09 <dminuoso> delYsid``: Any chance you could include the .cabal file?
07:48:39 <delYsid``> dminuoso: However, the typeclass hierarchy you're thinking about was really best described like you actually did.
07:49:02 <delYsid``> dminuoso: oh, I didn't notice that I didnt.
07:49:33 <delYsid``> ah, you mean in git?
07:49:36 <dminuoso> delYsid``: Yes.
07:50:05 <delYsid``> I am using stack for everything these days, and the default project puts the cabal file in .gitignore
07:50:21 <dminuoso> That's rude.
07:50:31 <delYsid``> since it is being generated from package.yaml
07:50:48 <dminuoso> delYsid``: Not everybody uses hpack/stack. :)
07:51:12 <delYsid``> Well, I guess the rationale there is that you shouldn't check in auto generated stuff.
07:51:29 <dminuoso> delYsid``: The counter-rationale would be allowing cabal users using your software. ;)
07:51:54 <delYsid``> sure, I get it.  Just trying to figure out whats actually right.
07:57:04 <Amras> is there any reasonable way to type a Frequency and Time so Frequency + Frequency -> Frequency; Time + Time -> Time; Frequency * Time -> Num, without manually creating <+> and <*> operators?
07:58:01 <Amras> atm my solution is to unpack Frequency and Time, do operations on Doubles, then pack them up again with the appropriate type. But that doesn't feel clean.
07:59:28 <tdammers> Amras: not really, no, unless you hide (*) from all Prelude imports
07:59:32 <tdammers> :t (*)
07:59:33 <lambdabot> Num a => a -> a -> a
07:59:47 <tdammers> you can't have different types on the LHS and RHS of *
07:59:59 <Amras> yup
08:00:28 <tdammers> one could argue that Haskell's numeric typeclass hierarchy is awful, and I'd say that one is probably right
08:00:45 <c_wraith> Problem is that it's basically as good as possible in Haskell.
08:00:48 <delYsid``> +1
08:01:16 <Amras> yeah; I'm inclined to agree there tdammers. numerics and monoids both.
08:01:21 <tdammers> that, and the massive social inertia
08:01:26 <delYsid``> I actually quite like what PureScript did.
08:02:00 <halogenandtoast> I am generally not the person to reference for these types of issues, but you might consider wrapping them in a new type like data Measurement = MeasuredFrequency Frequency | MeasuredTime Time
08:02:38 <tdammers> https://hackage.haskell.org/package/dimensional is an example of encoding physical dimensions in types
08:02:59 <tdammers> they don't give you (*), but opted to provide a set of parallel operators that take dimensions into account
08:03:32 <tdammers> oh wait, they actually do give you a replacement (*)
08:03:44 <Amras> this seems like what I'm looking for, yup
08:04:01 <c_wraith> Amras: I'm one of those people who gets annoyed by calling that Time, though.  It should be Duration. :P
08:04:16 <tdammers> so you can actually have something like (*) :: Frequency -> Time -> Double
08:04:29 <tdammers> at the expense of no longer having (*) from Prelude
08:04:38 <tdammers> (or having to qualify at least one of them)
08:04:39 <Amras> c_wraith: I would tend to agree that Cardinals and Ordinals should be kept as seperate types, yes
08:04:44 <c_wraith> Amras: which disambiguates from fixed points in time, which cannot be added to each other.  What's 3pm last tuesday + 5pm next wednesday?
08:05:00 <tdammers> c_wraith: point-in-time vs. duration, yes
08:05:01 <Amras> I was just being lazy in my definitions here
08:05:09 <tdammers> though "time" is the dimension still
08:05:20 <Amras> strictly speaking I should do the same differentiation in Frequency type too
08:05:43 <Amras> more strictly speaking, Haskell's type classes should make note of cardinals vs ordinals and differentiate them by default
08:07:01 <Amras> halogenandtoast: I feel like that would create more problems than it solves
08:07:07 <JoJo2UK_> hi there
08:07:17 <JoJo2UK_> why use Haskell?
08:07:29 <Amras> because every other language is bad
08:07:34 <halogenandtoast> JoJo2UK_: depends on the person/project.
08:07:35 <JoJo2UK_> haha
08:07:41 <c_wraith> haskell is also bad, just... less bad
08:07:45 <Amras> hehe
08:07:47 <JoJo2UK_> what is it good for?
08:07:59 <c_wraith> I've actually described it that way several times.  "the least-bad language I've used"
08:08:10 <Amras> JoJo2UK_: are you familiar with thinking of programming as mathematics?
08:08:24 <JoJo2UK_> emmm, just district math 
08:08:24 <jose_zap> JoJo2UK_ general programing, but it excels at parsing data, single machine concurrency and maitainability
08:08:46 <halogenandtoast> Amras: probably, but the dimensional package uses type family / data family, and that it outside my current repetoire of skills
08:08:57 <JoJo2UK_> oh I see, so it's not like day to day use this 
08:09:05 <halogenandtoast> JoJo2UK_: You can if you want
08:09:07 <Amras> "general programming" includes day to day use
08:09:10 <halogenandtoast> I use it for day to day stuff.
08:09:18 <JoJo2UK_> cool
08:09:26 <jgt1> JoJo2UK_: I use Haskell literally every day, and get 100% of my living from it
08:09:30 <JoJo2UK_> any example project ?
08:09:47 <jose_zap> JoJo2UK_ this is one of my projects https://github.com/hadolint/hadolint
08:09:51 <halogenandtoast> I would say embedded and highly performant real time programs (like 3d games) are mostly off the table.
08:09:54 <JoJo2UK_> cool :)
08:09:57 <jose_zap> it finds bugs in dockerfiles
08:10:06 <Amras> halogenandtoast: that's only because no one's done frp properly yet
08:10:09 <halogenandtoast> Not entirely, but you're probably not doing yourself any favors
08:11:23 <halogenandtoast> Amras: Should I wait 10 more years?
08:11:26 <JoJo2UK_> I'mm totally new to this!!! I'm focused on big data 
08:11:26 <Amras> If its creator is to be believed, FRP has the potential to be significantly more performant for real time and animation than procedural solutions
08:11:33 <JoJo2UK_> so not sure if this is any use...
08:11:44 <Amras> oh, definitely
08:12:19 <Amras> conal recently did a paper on automatic differentiation in ghc, which ties in to stuff like neural nets pretty tightly
08:12:22 <jose_zap> JoJo2UK_ haskell is great for ETL pipelines
08:12:49 <JoJo2UK_> great that I found this channel
08:12:55 <jose_zap> any streaming program, in general, can benefit from haskell's features
08:13:07 <JoJo2UK_> I'll try to use and do bit of research :)
08:14:58 <halogenandtoast> Amras: I am interested to see how things turn out on that front, that being said there's a lot of tooling, tutorials, and communities already available that I don't think Haskell should or needs to fight on that front.
08:15:20 <halogenandtoast> I'd be happy to be wrong, as I think the programming experience would be significantly better if the performance was there
08:16:11 <halogenandtoast> In the meantime, I will stick to implementing boardgames in Haskell as they don't need any 3d shenanigans
08:18:45 <Amras> for rendering you'd probably want to stick to C bindings and shader scripting langs, yes
08:19:42 <halogenandtoast> Amras: you reminded me how much I miss messing with shaders... my last project I ever worked on got scrapped.
08:21:25 <halogenandtoast> Not sure if the NDA still applies, but I was working with some big movie studio on an AR app where you placed giant robots and giant monsters from some movie in the world and could record/edit your own movie scenes (the robots and monsters only had a single animation loop but whatevs).
08:21:48 <halogenandtoast> But no Haskell :(
08:26:17 <halogenandtoast> Any good small example projects one could build to make use of conduits, brackets, or lenses
08:26:23 <halogenandtoast> Or all three
08:37:22 <Amras> anything stateful can make use of lenses
08:38:32 <Amras> I've had the most fun doing game projects with them
08:40:00 <kuribas> halogenandtoast: wouldn't the 3d stuff be done by the engine though?
08:42:56 <halogenandtoast> kuribas: Sure, but I don't know of any Haskell bindings for Unity3d or Unreal
08:43:43 <halogenandtoast> The app I made just use plain OpenGL for rendering since it did not need any actual Engine features
08:43:52 <halogenandtoast> just rendering 2 meshes that animated
08:44:16 <halogenandtoast> Amras: what sort of games?
08:46:57 <Amras> Unity is awful though
08:47:07 <Amras> I haven't used Unreal but I imagine the same thing
08:50:23 <tchakka> Is there a way to do pattern matching like `f Record{someField = Nothing, ..} = use someOtherField andThisFieldToo allTheFields`?
08:50:42 <tchakka> That is, pattern-match on a field, while capturing all of them with RecordWildCards.
08:51:25 <tchakka> (I know I can do Record{someField = Nothing, someOtherField, andThisFieldToo, allTheFields} with NamedFieldPuns, but looking for another shortcut here :P)
08:55:43 * hackage extensible-effects-concurrent 0.24.2 - Message passing concurrency as extensible-effect  https://hackage.haskell.org/package/extensible-effects-concurrent-0.24.2 (SvenHeyll)
08:56:38 <ski> tchakka : hmm, it would be nice if `@' allowed any pattern to the left. but perhaps you could try something like `f (liftA2 (,) id id -> (Record {..},Record {someField = Nothing,..})) = ...' ?
08:58:21 <kuribas> Amras: what else is there?
09:00:53 <tchakka> ski: That'd work. Still feels kinda meh, but it'll do. Cheers!
09:01:14 * hackage skylighting-core 0.8.1 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-core-0.8.1 (JohnMacFarlane)
09:02:13 * hackage skylighting 0.8.1 - syntax highlighting library  https://hackage.haskell.org/package/skylighting-0.8.1 (JohnMacFarlane)
09:06:28 <ski> tchakka : yea, with `Control.Arrow' you could say `id &&& id'
09:12:14 * hackage bytestring-arbitrary 0.1.3 - Arbitrary instances for ByteStrings  https://hackage.haskell.org/package/bytestring-arbitrary-0.1.3 (tsuraan)
09:14:13 * hackage massiv 0.3.4.0 - Massiv (Массив) is an Array Library.  https://hackage.haskell.org/package/massiv-0.3.4.0 (lehins)
09:19:19 <kuribas> does anyone have good slides for explaining monads?
09:20:44 * hackage rhine 0.5.1.0 - Functional Reactive Programming with type-level clocks  https://hackage.haskell.org/package/rhine-0.5.1.0 (turion)
09:22:10 <shapr> kuribas: I call 'em programmable semicolons, and say you ran replace the semicolon with a single common chunk of code for any particular block
09:22:46 <kuribas> I was thinking to start from flatMap
09:22:52 <kuribas> flatMap = flip concatMap
09:23:16 <kuribas> they already know functors and Maybe
09:23:26 <kuribas> then implement flapMap for maybe
09:23:33 <kuribas> then show how IO works in haskell
09:23:40 <kuribas> then present the Monad typeclass
09:23:53 <kuribas> though the programmable semicolon thing is also nice
09:27:01 <infinisil> I remember there being some ghc flag I can use to show the expanded TemplateHaskell, anybody happen to know about that?
09:27:22 <infinisil> Having a hard time finding any results online because I'm not sure what to search for
09:28:29 <infinisil> Ahh found it through ghc's manpage
09:28:32 <infinisil> -ddump-splices
09:28:37 <infinisil> Man pages ftw
09:36:13 * hackage rhine-gloss 0.5.1.0 - Gloss backend for Rhine  https://hackage.haskell.org/package/rhine-gloss-0.5.1.0 (turion)
09:38:43 * hackage group-by-date 0.1.0.3 - Shell command for grouping files by dates into folders  https://hackage.haskell.org/package/group-by-date-0.1.0.3 (HenningThielemann)
09:39:39 <Amras> damnit; I looked through dimensional and played around with it - while Frequency/Time does get resolved pretty cleanly there, the dimensions are locked to SI so I can't add arbitrary other dimensions
09:40:03 <Amras> so I guess I'll have to write my own implementation
09:51:37 <Messburn> I first thought I want to do  (\x y -> compare y x)  which is just (flip compare). But then I realized that x and y are complex values which I don’t want to compare. I wanna do (\x y -> compare (f y) (f x)) instead.
09:51:49 <Messburn> Is there a way to bring me closer again to (flip compare)?
09:52:08 <phadej> :t \f -> compare 'on` f
09:52:09 <lambdabot> error:
09:52:09 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
09:52:14 <phadej> :t \f -> compare \on` f
09:52:16 <lambdabot> error: parse error on input ‘\’
09:52:18 <Messburn> My initial reaction would be the (of course) non-working (flip compare . f)
09:52:18 <phadej> :t \f -> compare `on` f
09:52:20 <lambdabot> Ord a1 => (a2 -> a1) -> a2 -> a2 -> Ordering
09:52:24 <phadej> :t \f -> flip compare `on` f
09:52:26 <lambdabot> Ord a1 => (a2 -> a1) -> a2 -> a2 -> Ordering
09:52:36 <Messburn> Okay good, `on` it is, thx.
10:22:02 <d34df00d> Can I have a set of GHC flags enabled in stack for a particular subset of my files?
10:22:43 <d34df00d> Some modules require extensions like TemplateHaskell or UndecidableInstances, and I want to avoid both copypasting that to every module as well as enabling that globally for the whole library.
10:23:42 <glguy> If a module needs an extension you should put that at the top of the module that needs it
10:25:18 <d34df00d> glguy: that's what I typically do, yes.
10:25:28 <d34df00d> But in this case like a dozen of modules require the very same set of extensions.
10:25:57 <glguy> That's fine, it'll make sure when someone is reading any one of those modules you'll see that it uses the extensions
10:26:02 <d34df00d> (each module defines an SQL table with opaleye, and that's also partially why I'd like to declutter them as much as possible)
10:26:15 <sm> you could put them in their own package
10:26:47 <d34df00d> sm: how would that translate to a typical stack project structure?
10:27:36 <d34df00d> But it probably makes sense to do anyway, since, logically, a definition of some SQL tables is useful on its own by other packages.
10:27:42 <sm> if it's a multi-package project, you'd move those modules to a new subdirectory, initialised as a package with stack init or something, then add that to local packages in stack.yaml
10:28:02 <sm> and make the other local packages depend on it
10:28:15 <d34df00d> Cool, thanks!
10:28:19 <sm> it means more work if you're publishing this stuff
10:28:40 <d34df00d> Hmm, what additional work would it imply?
10:28:43 * hackage extensible-effects-concurrent 0.24.3 - Message passing concurrency as extensible-effect  https://hackage.haskell.org/package/extensible-effects-concurrent-0.24.3 (SvenHeyll)
10:29:09 <Mo0O> Hi there
10:29:25 <sm> just more red tape - readmes, changelogs, publishing releases, revisions, more surface area for hackage & stackage bounds issues..
10:29:31 <d34df00d> Ah.
10:29:33 <d34df00d> I'm totally fine with it.
10:29:46 <d34df00d> Yeah, I guess it's the most reasonable route in this case. Thanks again!
10:30:37 <gobby> So I've added this ppa:https://launchpad.net/~hvr/+archive/ubuntu/ghc and I can't find it in my Ubuntu Software app
10:30:40 <sm> but actually.. what I was thinking about was something a little different.. isn't there support for multiple library definitions in a single package these days.. each of which can have flags ?
10:31:03 <d34df00d> Last time I checked there wasn't.
10:31:07 <d34df00d> But it was probably 2-3 years ago.
10:31:41 <cocreature> you can have multiple libraries but only one of them can be public
10:31:42 <glguy> You can have multiple internal packages in  single .cabal package
10:31:48 <Mo0O> I've try to create multiple async job using `j <- mapM (async getURL) urls` and then wait for them using `r <- mapM wait j` but it results of a segmentation fault, do you know why?
10:31:58 <cocreature> I think cabal HEAD actually supports multiple public libs but it’s definitely not in a released version.
10:32:00 <d34df00d> https://stackoverflow.com/questions/53890793/how-does-one-have-multiple-libraries-using-hpack hehe
10:32:19 <d34df00d> How do I have multiple libraries (even if internal) with hpack?
10:32:34 <d34df00d> Or shall I just migrate to writing .cabal directly?
10:33:07 <cocreature> personally I just write .cabal directly. I haven’t found hpack to provide enough value but other people like it.
10:33:31 <yorick> how do I tell cabal to build with gold in the cabal file? I currently do cabal build --ghc-option=-optl-fuse-ld=gold --ld-option=-fuse-ld=gold --with-ld=ld.gold
10:33:39 <glguy> especially with the new features added across 2.0, 2.2, and 2.4 to the cabal format
10:33:41 <yorick> but I can't find a way to specify this fully in the .cabal file
10:34:45 <cocreature> Mo0O: the async code looks fine (but you probably just want to use mapConcurrently instead) so my guess would be that either getURL is broken somehow (impossible to say without seeing your implementation) or it’s some other part of your code that is causing issues.
10:37:08 <cocreature> yorick: I don’t think you need the with-ld part and you can specify the other two in your cabal file, see https://stackoverflow.com/a/43243323
10:37:28 <yorick> cocreature: yeah, I have that, and it's slightly faster, but the cabal build is still twice as fast
10:37:32 <yorick> cocreature: I can see it calling ld
10:37:33 <cocreature> yorick: note that recent versions of GHC will detect at installation time if gold is available and default to it.
10:37:48 <yorick> this is 8.4 I think
10:37:56 <cocreature> you can’t specify with-ld in your cabal file afaik
10:38:06 <Mo0O> cocreature: I've just try using mapConcurrently and it ends with the same error
10:38:10 <sm> d34df00d: one more option, I think you could conditionally set those flags based on module name in package.yaml/*.cabal. In some cases maybe that would be the least hassle
10:38:14 <yorick> cocreature: how recent?
10:38:41 <d34df00d> sm: oh, definitely! They are under MyStuff.Db.Tables. namespace anyway, so I'm fine with it!
10:38:43 <cocreature> the reasoning probably being that this is something that is machine specific so you should not specify it in your cabal file but arguably that can be said for other options as well.
10:38:59 <d34df00d> sm: I quickly skimmed through hpack docs, and I couldn't find how to do this conditional sort of thing. How do I?
10:39:12 <cocreature> yorick: 8.4 should definitely have it but with-ld is a Cabal thing not a GHC thing afaik so it’s probably unaffected by that.
10:40:02 <cocreature> d34df00d: fairly sure that’s not possible
10:40:05 <sm> https://github.com/sol/hpack#-conditionals, but probably cabal user guide gives more details about the possible tests
10:40:07 <yorick> cocreature: so why isn't it detecting right?
10:40:27 <cocreature> you can have conditionals in cabal files but I don’t think you can set flags based on module names
10:40:36 <cocreature> yorick: dunno? depends on how you installed GHC I guess
10:41:46 <yorick> it's the one from nixos
10:41:52 <yorick> probably built without --enable-gold
10:42:41 <sm> I think you're right cocreature : https://www.haskell.org/cabal/users-guide/developing-packages.html#conditions
10:45:35 <sm> final offer, then: in each of those files you can tell GHC to use a custom preprocessor, which would insert your flags 
10:46:05 <sm> or just paste them in and save brain cycles. :)
10:49:37 <Athas> Is there a nice way to sort by a partial order?
10:50:30 <Athas> I know about Data.Graph, but it's not exactly what I want.
10:50:46 <Athas> Basically, I have some strong constraints on ordering, and then some weak "preferences".
10:52:18 <hyperisco> It doesn't make much sense to sort a list with a partial order
10:52:45 <glguy> Isn't that basically what a topological sort is?
10:52:58 <Athas> Yeah, but it's awkward to express the "preference" thing.
10:54:11 <hyperisco> Maybe I could understand better with an example.
10:55:35 <Athas> Imagine having to sort a sequence of statements in a programming language.  You definitely want to maintain the dependency order, or it won't work at all.  Additionally, you want to group (say) array index statements together as much as possible.
10:56:06 <gobby> how does one configure cabal to use a specific ghc?
10:56:33 <Athas> gobby: -w ghc-1.3.3.7
10:56:59 <Athas> -w for --with-compiler, apparently.
10:57:08 <Athas> Probably the mnemonic I'd have picked.
10:57:17 <hyperisco> This sounds like a minimisation problem.
10:58:00 <hyperisco> Exponential times ahead?
10:58:17 <Athas> Best-effort is good enough for me.
10:58:39 <gobby> Athas: Sorry, how does one re-configure cabal's default ghc
10:59:07 <Mo0O> cocreature: is it normal that the same code without mapConcurrently doesn't seg fault?
10:59:08 <Athas> gobby: I think you can put a 'compiler:' option in $HOME/.cabal/config.
10:59:20 <d34df00d> Splitting the package makes it less manageable, meh.
10:59:33 <d34df00d> I guess I'll just copypaste the LANGUAGE pragma and indeed save the brain cells.
10:59:44 <hyperisco> I don't know. It is a sophisticated problem, the one you are describing.
11:03:24 <hyperisco> You're trying to find a list xs such that forall 0 <= i < j < length xs, ¬(xs_j ≤ xs_i) which minimises some aggregate fitness function
11:03:58 <hyperisco> Which vaguely speaking scores better the nearer similar elements are
11:04:04 <gobby> Athas: Thank you
11:05:00 <hyperisco> If you nail down what that function is then maybe there is some smart way to simplify the problem.
11:06:46 <cocreature> Mo0O: definitely not normal, that sounds like your version of getURL is based on some C library that’s not threadsafe
11:07:15 <Mo0O> cocreature: I'm not using getURL in fact, but Wreq: https://hackage.haskell.org/package/wreq-0.5.3.2/docs/Network-Wreq.html
11:08:46 <cjay-> what's the best package(s) to use to get many IO actions from base generalized over MonadIO? I found http://hackage.haskell.org/package/monadIO-0.11.1.0 (it's for concurrent stuff only though, and not huge download numbers). And can I count on GHC to inline such generalizations?
11:09:42 <cocreature> Mo0O: I wouldn’t expect wreq to segfault but it’s hard to say what exactly could be going wrong without knowing more about your code, the platform you are running on, the version of ghc, …
11:09:59 <cocreature> segfaults can be rather specific to your given setup
11:13:58 <Mo0O> I will try do make a simple example, the code base is to large to be shared
11:14:21 <Mo0O> by the way I'm using ghc 8.6.5
11:14:33 <Mo0O> I'm running on linux (void linux)
11:15:06 <sm> Athas: is this like a simple case I have: I have dated entries in parse order, and I want to sort them by date but within each date, preserve the original parse order ?
11:15:14 <Mo0O> and I compile the code with the following ghc options: -threaded -optl-static -optc-Os
11:15:32 <Athas> sm: no, I don't want to respect the original order.
11:15:47 <Athas> hyperisco is probably right that this is some kind of NP-complete clustering algorithm.
11:15:53 <sm> ok
11:16:49 <sm> sounds prolog-ish 
11:24:44 * hackage pandoc-pyplot 2.1.3.0 - A Pandoc filter to include figures generated from Python code blocks  https://hackage.haskell.org/package/pandoc-pyplot-2.1.3.0 (LaurentRDC)
11:27:08 <timCF> Hello! I want to implement simple functional language (just very basic things like integers, ADTs, functions and pattern matching) - and I want to do it from scratch in Haskell. Can you recommend any examples/tutorials?
11:28:33 <timCF> I have no idea how to write compilers, but really want to try 😀
11:29:11 <sm> hello timCF. Someone will probably answer, but have you tried searching ? That's what I'd be doing :)
11:30:00 <roflik> does anyone use ghc without stack *or* cabal?
11:30:29 <cocreature> roflik: we use Bazel at work
11:30:34 <timCF> @sm yes, found this https://github.com/sdiehl/write-you-a-haskell but looks like project is dead
11:30:34 * lambdabot clobbers yes, found this https://github.com/sdiehl/write-you-a-haskell but looks like project is dead with an untyped language
11:31:17 <phadej> typed language is tricky
11:31:24 <phadej> or trickier*
11:31:43 <sm> timCF: seems like a few more possibilities at https://duckduckgo.com/?q=build+a+simple+compiler+from+scratch+in+haskell+tutorial&t=ffab&ia=web
11:32:08 <phadej> my talk at haskell exchange last year is a very quick intro into how to use `bound` and write type-checker
11:32:38 <roflik> cocreature: how?  i mean, you need to integrate upstream packages in some way anyway, what does the seam look like?
11:33:02 <phadej> allowing defining own types and pattern matching are then "next steps"
11:33:05 <roflik> cocreature: i haven't used bazel or know much about it
11:33:06 <sm> (and even if diehl's tutorial hasn't been updated for a few years, it's probably still very useful)
11:33:58 <cocreature> roflik: bazel has a compatibility layer called “hazel” that parses cabal files and translates them into Bazel rules.
11:34:35 <roflik> cocreature: i don't have a cabal file yet, can i avoid having to create one?
11:34:45 <sclv> roflik: why would you want to
11:34:47 <cocreature> we don’t have cabal files for our own packages
11:35:11 <cocreature> but yeah for most use cases making a cabal file and using cabal/stack is a much better option
11:35:58 <roflik> cocreature: what do you have in their place?
11:36:00 <sclv> timCF: the easiest way is to write your language entirely untyped and then just stick a typechecker/inference system on top
11:36:03 <cocreature> Bazel rules
11:36:18 <sclv> which is fine if you're just writing an evaluator and not an actual compiler
11:36:50 <sm> roflik: you could start with ghc --make.. when you want dependencies, maybe you can arrange some other way to install them in your source tree
11:37:09 <dminuoso> What do other people here think? Should stack projects ship with a .cabal file to enable easier usage for cabal v2-* users?
11:37:14 <sm> there's also stack scripts - requires stack, but does not require .cabal files/a local package
11:37:15 <sclv> obviously, yes
11:37:24 <dminuoso> (Apparently stack by default adds .cabal file to .gitignore)
11:37:44 <cocreature> dminuoso: only if you use the hpack-based starter project. there are others
11:37:47 <sm> dminuoso: yes, for the time being
11:38:12 <cocreature> not a big fan of checking in generated files in general but for cabal files the benefits do seem to outweigh the downsides.
11:38:24 <sclv> cabal files aren't just for cabal-install the tool -- they're a broader standard that's baked into ghc
11:38:53 <sm> couldn't cabal-install "easily" add the same optional hpack support stack has ?
11:39:01 <sclv> no it couldn't
11:39:03 <sclv> absolutely not
11:39:19 <cocreature> huh? it definitely could. whether it should is another question.
11:39:22 <dminuoso> cocreature: What others are there?
11:39:23 <MarcelineVQ> why would you want it to
11:39:24 <sclv> cabal-install the tool maintains an extremely limited dep footprint to ease bootstrapping
11:40:25 <sm> a variation: it could support the alternate yaml format directly, and hpack could go away
11:40:30 <cocreature> dminuoso: that was more a general statement rather than something specific to Haskell package configs :)
11:40:38 <sclv> which would also vastly increase its dep footprint!
11:40:45 <sm> maybe, maybe
11:40:50 <sclv> unless it wanted to vendor an entire yaml parser
11:40:58 <sm> it needn't be full yaml
11:41:09 <sclv> another variation: cabal files could provide all the features pioneered by hpack
11:41:18 <sclv> (which we
11:41:27 <sclv> are 90% of the way to at this point)
11:43:16 <phadej> 99$
11:43:17 <phadej> %
11:43:28 <yahb> phadej: 
11:45:21 <magthe> jackdk: problems at all with applying the stuff we discussed yesterday, just an added `MonadTest m` on action, and moved a few tests around... thanks for the help!
11:46:55 <dminuoso> What exactly is the point of using hpack anyway? What do you gain?
11:47:17 <cocreature> judging from the discussions I saw, I don’t see the globbing feature landing in Cabal anytime soon and enough people seem to like that (I personally don’t care for it) that I don’t see hpack disappearing anytime soon.
11:47:20 <dminuoso> Is that just to comfort beginners by having them type things into yaml (assuming they are used to yaml already)?
11:47:37 <dminuoso> Or do I get some technical features or benefits from hpack?
11:47:44 <MarcelineVQ> most usefully the ability to define things once that are common bewteen stanzas. Cabal has common stanzas now though
11:48:57 <sm> dminuoso: this is a FAQ, but for years it has helped me a lot to reduce boilerplate and the resulting errors when updating bounds and metadata in multi-package projects
11:49:13 <aplainzetakind> I have a sum type `data Foo = Bar Baz | Bar' Baz'`, where Baz and Baz' consist of nested record structures. I have Foo in a `StateT Foo`, and I want to use microlens to work with it conveniently. What's a good way to get over the initial sum layer?
11:49:50 <dminuoso> aplainzetakind: You could write the prisms from hand.
11:50:02 <sm> it was been absolutely worth the cost. If starting a new project which could assume latest cabal-install, maybe I'd skip it
11:50:04 <dminuoso> aplainzetakind: Its just the makePrisms utility you lose with microlens.
11:50:47 <dminuoso> sm: Not trying to be pedantic, but I thing the tense changes the meaning of that statement. Is that "has been" or just "was"?
11:51:02 <sm> sorry, I meant "it has been"
11:52:02 <sm> I'm still happily using it, & haven't looked seriously at dropping it. I'm assuming requiring a new-enough cabal-install would create too many headaches in my case
11:57:19 <aplainzetakind> dminuoso: Alright, thanks.
12:03:06 <phadej> but installing recentish-hpack isn't a headache? weird.
12:03:53 <sm> I don't really need a recent hpack.. the one built in to any sane stack version is fine
12:04:16 <phadej> and stack ~requires you to be upgraded as well
12:04:31 <sm> how do you mean ?
12:04:51 <phadej> you don't run an year old stack-binary, do you?
12:05:10 <sm> I don't, but my users can if they want
12:05:49 <sm> my situation is: wanting package installation to just work on as many user systems as possible. So requiring newest install tools is a problem
12:06:30 <sm> also, perhaps I should have said earlier: multi-component packages, are particularly where it helps me. And the more packages you maintain, the more the win
12:07:35 <phadej> no you cannot run old stack, e.g. https://github.com/commercialhaskell/stack/issues/4077 which requires virtually everyone to have 1.7.1 Apr 28, 2018
12:07:42 <phadej> ok, it's 13 months old
12:08:02 <sm> yes, stack 1.7.1 is the minimum
12:08:04 <phadej> cabal-install-2.2 is 14 months old
12:08:26 <phadej> and it has common-stanzas
12:08:34 <phadej> qed
12:08:48 <sm> I wouldn't say QED, but good to know
12:09:28 <phadej> fyi: https://cabal.readthedocs.io/en/latest/file-format-changelog.html
12:09:55 <sm> thanks! I was failing to find it in http://hackage.haskell.org/package/cabal-install-2.4.1.0/changelog
12:10:44 * hackage canon 0.1.1.1 - Arithmetic for Psychedelically Large Numbers  https://hackage.haskell.org/package/canon-0.1.1.1 (grandpascorpion)
12:11:24 <sm> on a practical level, one thing that makes old stacks less of a problem for me than old cabal-installs, is "stack upgrade" usually just works (reliable & quick)
12:11:58 <phadej> don't install cabal with cabal, use package manager, apt; ghcup; chocolatey
12:12:06 <phadej> (also use those to install ghc)
12:12:15 <phadej> multiple ghcs*
12:13:58 <sm> sure, but that's highly variable, so costly to support. But I do try
12:14:53 <phadej> what you mean by "costly to support"?
12:16:50 <sm> highly variable and also quite technical. I mean there's no end to the ways installation can go wrong, which means more users fail, I get more troubleshooting/support tasks, and less time to spend elsewhere
12:17:49 <sm> so costly to my time and brain cycles, and to the project's adoption and user satisfaction
12:20:09 <phadej> but it's not your concern, but apt-repositorys, ghcup, chocolateys package maintainers concern? And, they are well better equipped with guiding new users with their problems as that's their domain
12:20:46 <phadej> as a (haskell) project maintainer, you could simply say "install ghc and cabal using these methods link1, link2, link3"
12:20:51 <phadej> problem outsourced.
12:26:04 <sm> I've tried that, and do that where I can, but it's not as easy as all that. Keep in mind I've been doing this for about 10 years now. Those methods are highly changeable, diverse, and costly to support. System packages are frequently far out of date. And I'm trying to reach more people than those methods work for, including less-technical folks. Hopefully this gives you a sense of it.
12:26:44 <phadej> by apt I refer to https://launchpad.net/~hvr/+archive/ubuntu/ghc, ghcup and chocolatey are hopefully here to stay
12:26:55 <phadej> by requiring stack you don't make it any easier
12:27:10 <phadej> getting the stack first time is equally "volatile" task
12:27:10 <sm> who said I require stack ? not me
12:27:29 <sm> I offer as many install methods as I can find
12:27:47 <phadej> ok, so you provide .cabal file, even you use hpack for your dev?
12:28:01 <phadej> very nice that you do that.
12:28:28 <sm> of course I do. :) You probably missed where this started, when I suggested diminuoso do that 
12:38:01 <zincy> what makes for a good property test when using quickcheck or hedgehog?
12:39:15 <hyperisco> Properties do, generally.
12:40:31 <zincy> case closed
12:40:53 <hyperisco> If you are having to choose between which properties to test, that combined ultimately test the same thing, then less variables are better
12:41:20 <zincy> I kind of feel like I am rewriting the logic I am supposedly testing inside the test
12:41:25 <hyperisco> Reason being that the problem space grows exponentially with more variables
12:41:44 <hyperisco> So, your coverage will be worse
12:41:54 <zincy> do you find that prop tests expose coupled functions?
12:42:23 <zincy> It makes them more obvious than unit tests because the problem space grows quickly as you say
12:42:33 <hyperisco> If your definition is analogous to a property test then I wouldn't bother testing it
12:42:50 <zincy> yeah
12:43:00 <zincy> My property tests need property tests
12:43:07 <MarcelineVQ> if you're inventing logic to pass things to test your function then your function is possibly too accepting of inputs
12:43:28 <sm> phadej: back to my reddit post, I just noticed you posted it: https://www.reddit.com/r/haskell/comments/bwbgau/compatibility_packages/ - did you write that as well ?
12:43:29 <MarcelineVQ> Not that that's a rule, just seems to follow to me
12:43:42 <hyperisco> I am not sure what a coupled function is exactly, but I don't think property tests would have much to do with it
12:43:56 <hyperisco> Property tests will reveal whether you really know what your program is supposed to be or not
12:43:58 <zincy> yeah you should be inventing data (generators) instead 
12:45:08 <zincy> another question - should you strive to keep your functions as small as possible or is there a balance depending on the context
12:45:11 <sm> either way, thanks, it's great
12:45:40 <hyperisco> You should define your functions such that they are easily specified by properties
12:45:41 <zincy> I have heard other programmers calling it absurd that coworkers ensure every function is one line
12:45:49 <zincy> but I am not sure where I stand on the issue
12:45:57 <hyperisco> Sounds like Python
12:46:19 <zincy> hyperisco: yes!
12:46:25 <MarcelineVQ> zincy: as understandable a possible is the goal, sometimes that's shorter sometimes it's not
12:46:55 <zincy> hyperisco: I think that is the problem, the functions are unclear in their design
12:46:56 <hyperisco> 1 line or 1000 lines of implementation doesn't bother me (all that much) but 1 line or 1000 lines of explanation/specification/semantics does
12:48:37 <hyperisco> This has been a longstanding and widespread confusion, in my opinion
12:49:14 <hyperisco> A lot of focus is put on abbreviating implementations because no effort is being put towards specifications
12:49:27 <hyperisco> In other words, when your implementation is also your specification, of course you want it short and sweet
12:49:50 <hyperisco> But this conflation isn't a necessary one
12:53:59 <davean> hyperisco: Since I almost universally have to deal with the implimentation, it does matter to me with or without an expanation seperate.
12:55:09 <davean> I've gotten to the point I'll pick something I can extend to do what I want over something that already does but I don't like the implimentation as much of, because I know I'll definately be down in it soon enough.
12:56:04 <hyperisco> 3rd party software isn't reliable for you? Maybe try looking on GitHub
12:57:24 <davean> hyperisco: was that to me?
12:57:36 <hyperisco> I don't mean to say it doesn't matter, but what I do mean is that once specification and implementation are separate, it matters for different reasons
12:58:01 <hyperisco> And it helps to have separate reasons, because that's less constraints overall
13:02:19 <hyperisco> davean, I don't know if I'm just unlucky but my run with 3rd party libraries outside a standard lib has been rocky
13:05:02 <hyperisco> There's simple libraries, where I could have written them myself, but I don't have to, and those usually work well
13:05:48 <hyperisco> For some reason, most of my problems that I try and solve with a library that purports the solution ends poorly
13:06:19 <davean> hyperisco: I've been down in 'base' and 'attoparsec' a lot for example.
13:06:29 <hyperisco> So then I have to learn a lot about the domain anyways just to fix or adapt it =\
13:06:39 <halogenandtoast> if I have something like x <- doIO; y <- pure $ f x; z <- pure $ g x; a <- pure $ h x; would it be better to do x <- doIO; let y = f x;  z = g x;  a = h x
13:07:42 <davean> Oh that reminds me, I have to submit that patch to attoparsec ...
13:07:43 <hyperisco> It is hard to be ignorant.
13:07:58 <davean> thank you hyperisco, I totally forgot about that.
13:08:18 <hyperisco> Hey, glad to help.
13:10:11 <hyperisco> halogenandtoast, the let binding may be more efficient. At least, it doesn't rely on certain optimisations firing.
13:11:34 <hololeap> is there any major difference between using top-level data families and GADTs? they seem to be basically interchangable
13:11:40 <hyperisco> Granted, it is more annoying to indent let bindings properly, and that alone may make me indifferent.
13:12:33 <hyperisco> hololeap, data families are open, GADTs are closed.
13:13:20 <hololeap> i see, that is a major difference
13:14:27 <hyperisco> Granted, you can constrain the kind, and with DataKinds that means you can introduce finite domains of types. Does Haskell do totality checking on, say, closed type families? I don't recall. Been a while oO
13:16:20 <hololeap> that's basically been my use case, type families that are constrained by a sum type lifted to a kind with DataKinds
13:17:11 <hyperisco> And can Haskell pass totality checks with that? I don't recall
13:20:32 <solonarv> hololeap: also, you can pattern match on GADTs and learn what the type parameter was
13:20:47 <solonarv> in contrast you cannot match on a data family unless you already know the type parameter
13:21:30 <hyperisco> So I guess the answer to that is no, at least on the value level
13:30:38 <dmwit> halogenandtoast: It would be better provided none of `y`, `z`, or `a` is both typeclass polymorphic and referenced multiple times in the continuation.
13:31:40 <dmwit> hyperisco: GHC does not notice when you have covered all the cases of a DataKind. =(
13:32:08 <dmwit> This also applies to classes.
13:32:31 <dmwit> Just because you wrote `instance Foo True; instance Foo False` doesn't mean you get to elide the `Foo a => ...`. =(
13:33:29 <hyperisco> I am not sure if in principle you couldn't.
13:33:37 <phadej> Any
13:33:48 <phadej> % :kind Any
13:33:54 <yahb> phadej: [Timed out]
13:33:59 <phadej> % :kind GHC.Exts.Any
13:34:02 <hyperisco> kind too powerful
13:34:21 <dmwit> phadej: Here's a hot take: Any was a mistake.
13:34:42 <yahb> phadej: GHC.Exts.Any :: k0
13:34:42 <phadej> dmwit: `type family MyAny :: k where`
13:34:45 <hyperisco> Looking forward to your Buzzfeed article on the subject.
13:35:35 <dmwit> phadej: You seem to be implying I think no mistakes were made in the creation of type families!
13:35:42 <phadej> dmwit: :)
13:35:53 <phadej> non-total type-families /are/ useful
13:36:18 <phadej> Haskell /= proof system
13:37:46 <jpg> Hello guys, when defining something as |data T = T Symbol| I am defining a type that can only be used promoted, sinde Symbol is not inhabited, correct?
13:38:08 <jpg> since*
13:38:26 <dmwit> Sort of?
13:38:42 <dmwit> `T undefined` still has type `T`. (Similar objection to you that phadej just made to me. ;-)
13:39:01 <dmwit> Whether that matters to you or not is of course up to you.
13:39:27 <dmwit> I'm... not actually sure that can be used promoted, either, can it?
13:39:37 <jpg> Is there a way to define a "pure datakind" (I mean, some datatype not inhabited on terms) with a Bool instead of a Symbol?
13:40:10 <phadej> jpg: there's a design https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0032-type-data.rst but no implementation
13:40:12 <dmwit> I guess it can. Not sure I understand that.
13:41:01 <dmwit> jpg: You could just export the lifted versions and not the unlifted ones from your module.
13:41:26 * jaexil-g-maitre- uploaded an image: images-5.jpg (6KB) < https://matrix.org/_matrix/media/v1/download/matrix.org/uPGucWrWDQqjzntnPznurJZE >
13:41:27 * jaexil-g-maitre- uploaded an image: images-3.jpg (7KB) < https://matrix.org/_matrix/media/v1/download/matrix.org/mMZzLvVzPazFLfhHelmVMbco >
13:41:30 * jaexil-g-maitre- uploaded an image: images.jpg (7KB) < https://matrix.org/_matrix/media/v1/download/matrix.org/iDflrSkIJWdOkALCfIdHLOzX >
13:41:31 * jaexil-g-maitre- uploaded an image: images-8.jpg (13KB) < https://matrix.org/_matrix/media/v1/download/matrix.org/ippiVUNgoZxplxxKghlqvAWh >
13:41:39 * jaexil-g-maitre- uploaded an image: images-9.jpg (10KB) < https://matrix.org/_matrix/media/v1/download/matrix.org/pwEfkMoROFDZRAnDaHWsLgMl >
13:41:41 --- mode: ChanServ set +o dmwit
13:41:47 --- kick: jaexil-g-maitre- was kicked by dmwit (jaexil-g-maitre-)
13:41:51 * jaexil-g-maitre- uploaded an image: images-6.jpg (3KB) < https://matrix.org/_matrix/media/v1/download/matrix.org/mlSDVkxMHfuSxxzcqTVaJPOj >
13:42:31 <jpg> How do I export only the promoted kind?
13:42:33 <phadej> the proposal also describes what you can do today, and why it's not good enough (from proposal perspective)
13:44:32 <dmwit> jpg: module Foo (Foo, Bar) where data Foo = Bar_; type Bar = Bar_
13:44:41 <dmwit> Yes, I know it's awful.
13:44:46 --- mode: dmwit set -o dmwit
13:45:21 <phadej> dmwit: data Foo = Bar; type Bar = 'Bar;
13:45:39 <phadej> that what the proposal shows above the fold
13:46:00 <imjacobclark> How can  i unwrap an IO from within an fmap, e.g this: let a = fmap (\id -> marshallArtistData $ (getArtistById id accessTokenFileData)) artistIds gives me this err: Couldn't match expected type ‘Data.ByteString.Lazy.Internal.ByteString’ with actual type ‘IO Data.ByteString.Lazy.Internal.ByteString’
13:46:09 <phadej> imjacobclark: you cannot
13:46:24 <hyperisco> :t fmap
13:46:26 <phadej> there are ways to cheat, but we'll not tell you
13:46:26 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:46:34 <dmwit> :t (=<<)
13:46:36 <lambdabot> Monad m => (a -> m b) -> m a -> m b
13:46:38 <hyperisco> See it takes the IO off the  a  and  b  so that you can do stuff with them :)
13:46:47 <dmwit> imjacobclark: ^ use (=<<) instead of fmap
13:47:00 <dmwit> imjacobclark: Then you're allowed to return an `IO a` from the function you pass to it.
13:47:02 <phadej> i think one actually wants traverse
13:47:14 <phadej> as artistIds is probably some collection, not IO action...
13:47:17 <dmwit> Ah, perhaps.
13:47:30 <imjacobclark> yeh, artistIds is a collection
13:47:36 <imjacobclark> [String]
13:47:42 <Rembane> :t traverse
13:47:43 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
13:47:59 <dmwit> Or maybe traverse_! Depends.
13:48:28 <imjacobclark> So confused! I just wanna map through my artistIds (strings) and pass them to another function 
13:48:56 <imjacobclark> well, i guess the problem is my http action  returns a bytestring wrapped in an io
13:49:26 <hyperisco> That's often by design, not a problem
13:49:36 <sm[m]> imjacobclark: general tip: write out each tiny piece on its own line with an explicit type signature. Use ghcid for feedback and ghci for additional testing. Gradually combine things as you understand how. Use hlint for more suggestions.
13:50:29 <hyperisco> phadej, why would we keep the IO F-algebra a secret?
13:50:54 <phadej> ...
13:52:49 <Nevoic> is `return` ever going to be deprecated?
13:52:52 <Nevoic> In favor of `pure`?
13:53:18 <Nevoic> Or is there some reason to keep it? Since `Applicative  m => Monad m` it just seems redundant.
13:53:22 <imjacobclark> sms: thanks ill try
13:53:58 <sm[m]> imjacobclark: with a little practice, you'll find this much easier
13:54:03 <monochrom> I bet keep because no harm to keep but every harm on existing code if removed.
13:54:39 <hyperisco> Never attribute ignorance to what can be explained by legacy systems.
13:55:06 <jpg> thank you dmwit, phadej
13:55:07 <Nevoic> monochrom: Well that's why I said "deprecated" instead of removed.
13:55:12 <phadej> monochrom: s/return/pure/ is trivial change
13:55:21 <Nevoic> i.e just strongly suggest against using it, and in a future version provide a migration tool that does a safe conversion.
13:55:28 <monochrom> deprecation is crying wolf if no removal afterwards.
13:55:55 <phadej> fwiw, from my recent experience, deprecation doesn't really trigger people to do anything
13:56:01 <monochrom> There is every harm in setting a precedence of "deprecated but never removed, perpetually". People would stop taking deprecation seriously.
13:56:01 <Nevoic> sad lads
13:56:13 <Nevoic> Sure, I wasn't saying never remove it.
13:56:26 <MarcelineVQ> imjacobclark: your bytestring isn't wrapped in an IO. executing your IO action may result in a bytestring.
13:56:28 <MarcelineVQ> @quote /ls
13:56:28 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
13:56:32 <c_wraith> even then, no one does anything until it's actually removed.
13:56:39 <MarcelineVQ> imjacobclark: much more info here http://www.vex.net/~trebla/haskell/IO.xhtml
13:56:45 <Nevoic> Deprecation exists as an intermediary step to help people migrate code. But if the Haskell community doesn't really act on deprecation, then I guess we'd just need to remove it.
13:56:46 <phadej> c_wraith: +1
13:56:50 <hyperisco> Oh, the flim-flammer is being deprecated in the new version of jibber-jab? I guess we're staying on the old version forever then.
13:56:53 <monochrom> If this line of inquiry continued, I would start suspecting anti-social motivation. Yes you're speaking like you're unware of, even against, other people.
13:57:16 <Nevoic> wut
13:57:30 <Nevoic> I just saw two functions that do the same thing, was wondering if there was a reason to keep one.
13:57:44 <Nevoic> It's definitely trivial, but with a compiled/safe language you can have migration that takes care of it.
13:57:48 <monochrom> Yes that means you're unaware of existing code.
13:58:09 <monochrom> Who will go over all of hackage to make the change?
13:58:10 <Nevoic> Hmm, I'm definitely not unaware that people have used Haskell.
13:58:24 <monochrom> Not me. I'm not paid enough for this.
13:58:49 <Nevoic> I don't think anyone would go over all of hackage.
13:58:56 <monochrom> There you go.
13:58:59 <Nevoic> Nope.
13:59:01 <Nevoic> lol
13:59:16 <monochrom> You have a better plan?
13:59:16 <Nevoic> There are solutions that don't involve going through tens of thousands of packages of source code.
13:59:31 <monochrom> Call me stupid, I can't think of any.
13:59:37 <hyperisco> We cannot rest until fmap is renamed to map and the old map is removed!
13:59:43 <phadej> Nevoic: there are complicated reasons why removing `return` isn't really straigh-forward, even one could s/return/pure/ in every existing code
13:59:53 <monochrom> Or alternatively I call you bluff.
13:59:57 <phadej> recent "complication" is DerivingVia
14:00:12 <hyperisco> First off, that's a sure-fire way to break code. You at least have to do a syntax-aware replacement.
14:00:29 <Nevoic> You could have Haskell version X which supports `return`, and a newer version Y that doesn't support `return`. If you import an `X` package into a `Y` project, the compiler replaces `return` calls with `pure` calls.
14:00:41 <phadej> with it you can derive Applicative from your manual Monad instance quite nicely (almost), but if there are no return, that won't work
14:00:42 <Nevoic> That would not involve changing any source code.
14:00:48 <hyperisco> Nevoic, how's Python 3 coming along?
14:01:00 <Nevoic> Python is a dynamic language with no compiler to help refactors.
14:01:01 <lambda__> what is the best resource to start programming haskell? I am already familiar with a lot of FP.
14:01:08 <Nevoic> This could all be done safely at compile time with no developer interference.
14:01:10 <monochrom> Let's see who will actually do that to GHC and when.
14:01:20 <phadej> and instance Applicative Foo where pure x = ...; (<*>) = ap;  instance Monad Foo where m >>= k = ...; is ugly
14:01:26 <monochrom> Last I heard it took them 15 years to add "show doc inside ghci".
14:01:31 <Nevoic> I'm not saying it's free or even "super" easy, just that it's easier than modifying tens of thousands of hackage packages like you suggested.
14:02:34 <monochrom> Look I'm a great fan of "put your money where your mouth is". How much bounty would you offer to get it done?
14:02:58 <hyperisco> Nevoic, my only point being that every time backwards compatibility is broken you introduce a new community of people who will never upgrade, or at least not anytime soon.
14:03:09 <Nevoic> That's an entirely irrelevant point to whether or not it should be done. If we can agree it's worth doing, then we can talk about funding.
14:03:20 <Nevoic> I'm not an investor, I can barely feed myself lol
14:03:31 <hyperisco> And Monad-but-doesn't-have-to-be-Monad functions are numerous, and used pervasively
14:03:48 <hyperisco> You mention return/pure but that isn't all
14:04:06 <monochrom> My experience is the opposite. People's funding is how I measure what they honestly, secretly think what should or should not be done.
14:04:25 <Nevoic> Does that mean homeless people who have no money think nothing should be done?
14:04:36 <monochrom> For example I am not offering bounty on this, precisely because I think it should not be done.
14:04:47 <Nevoic> I'm not offering a bounty on this because I'm not Bill Gates.
14:04:55 <monochrom> Hell in fact I'm offering $10 to resist it being done!
14:04:59 <Nevoic> If I had the amount of money Bill Gates had, I would care just as much and put hundreds of thousands of dollars to this.
14:05:10 <MarcelineVQ> monochrom: I'll accept that $10
14:05:23 <Nevoic> Money != worth.
14:05:26 <Nevoic> Or value
14:05:33 <hyperisco> If it could be done all over again then Applicative would superclass Monad and yes, there would be no return, I don't think anyone debates that
14:05:43 <Nevoic> This is getting into political philosophy, but money is used to maintain power.
14:05:46 <phadej> The MonadWithNoReturn is not a funding problem
14:05:46 <hyperisco> The entire problem is the legacy of it
14:05:58 <phadej> no-one knows what the good end design should be!
14:06:11 <phadej> (so if it's funding problem for the _research_)
14:06:18 <monochrom> Wait, there is MonadWithNoReturn now?!
14:06:18 <MarcelineVQ> money is an abstraction of time
14:06:55 <Nevoic> That's a really simplistic, non-helpful view of money. Money isn't that fair.
14:07:06 <Nevoic> Bill gates earns as much money masturbating than I make in 3 months of working.
14:07:07 <davean> monochrom: I've never minded the sweep of hackage
14:07:10 <MarcelineVQ> money isn't unfair either
14:07:30 <Nevoic> Money is definitely unfair.
14:07:34 <Nevoic> Having money gives you more money.
14:07:39 <monochrom> What have I done? >:)
14:07:43 <MarcelineVQ> I don't think fairness of a property of inanimate tooling.
14:07:53 <MarcelineVQ> Except maybe, a scheduler
14:08:20 <monochrom> Well at least we're relieved of the empty talk of something that won't happen anyway.
14:08:28 <Nevoic> If you have 10 million dollars you never need to work again in your life, because you can get (on average) a 7% YoY return from an index fund, meaning you'd make $700,000 a year doing literally nothing.
14:08:55 <Nevoic> Even adjusting for inflation (way too generously), it's still close to $400,000.
14:09:09 <hyperisco> I know someone like that. Turns out, one tends to get bored and look for things to do anyways :P
14:09:29 <Nevoic> There are rich people who don't work, but yeah, some people work anyway. I'm not saying having money makes you do nothing.
14:09:43 <Nevoic> I'm saying it gives you the option to do nothing, and live a more comfortable life than I'd ever be allowed to live.
14:09:43 <hyperisco> https://gitlab.haskell.org/ghc/ghc/wikis/proposal/monad-of-no-return
14:10:28 <MarcelineVQ> Your premise starts with someone getting 10 million, but you skipped the part where they got to that point.
14:10:35 <Nevoic> They were born into a rich family.
14:10:42 <Nevoic> Inheritance tax in any country is far below 100%.
14:10:50 <MarcelineVQ> Then that family put in the time to accrue this wealth?
14:11:01 <hyperisco> Their proposed plan introduces this change ever so gently, and exactly when it will become fully unsupported is unknown
14:11:33 <Nevoic> Someone in 1850 could've stumbled into a gold mine, put in as much time as someone else who didn't, and someone born in 2005 could be living a luxurious life where the descendant of the unlucky person (who tried just as hard) is homeless.
14:11:39 <Nevoic> You can't pretend like hard work == money.
14:11:47 <Nevoic> hard work is necessary to generate wealth (initially).
14:11:52 <Nevoic> But it also requires luck, networking, etc.
14:11:56 <MarcelineVQ> I've done gold mining and it's not really low effort.
14:12:10 <hyperisco> MarcelineVQ, where at?
14:12:14 <Nevoic> Sure, but read my scenario. 2 people go gold mining equally, one person is rich, one person isn't.
14:12:20 <Nevoic> They both worked hard, one person was lucky.
14:12:22 <monochrom> . o O ( Learn Monad past the point of no return )
14:12:25 <glguy> We're pretty far from talking about Haskell now?
14:12:27 <Nevoic> The great great great grandchild of one of those doesn't need to work.
14:12:28 <MarcelineVQ> I'd rather not say, north west north america :>
14:12:45 <hyperisco> MarcelineVQ, I know just the place!
14:14:04 <imjacobclark> I used sequence in the end! getArtists <- liftIO . sequence $ fmap (\id -> getArtistById id accessToken) artistIds
14:14:04 <monochrom> Conspiracy theory: GHC HQ is situated at an old gold mine.
14:14:30 <monochrom> Yes sequence is neato.
14:14:51 <hyperisco> If you want to fmap too though, look at traverse
14:15:06 <monochrom> sequence (with the list Applicative) is how to have a variable number of nested for-loops.
14:17:06 <c_wraith> monochrom, wasn't "monad of no return" the code name for the proposal for that removal?
14:17:43 <monochrom> I dunno. I never followed proposals.
14:18:11 <hyperisco> Never trade luck for skill.
14:18:50 <imjacobclark> hyperisco: i'm looking at traverse but I don't really  understand it lol :) 
14:19:03 <hyperisco> I have no idea who actually faces that proposition, but I heard it once.
14:19:19 <monochrom> traverse and sequence can be expressed in terms of each other.
14:20:05 <hyperisco> :t sequence . fmap . fmap pure -- lets see if I can intuit this
14:20:07 <lambdabot> (Applicative f, Monad m, Traversable ((->) (m a1))) => (a1 -> a2) -> m (m a1 -> f a2)
14:20:14 <hyperisco> wrong answer
14:20:55 <hyperisco> oh, the problem is not enough fmap. The problem is always not enough fmap.
14:21:01 <monochrom> Perhaps sequenceA isntead.
14:21:46 <imjacobclark> whats the  difference between  sequenceA and sequence?
14:21:49 <imjacobclark> hoogle seems to say they same thing
14:21:56 <monochrom> traverse f xs = sequenceA (fmap f xs)
14:22:10 <hololeap> is there a paste site that has good haskell syntax highlighting, especially ghc extensions?
14:22:13 <monochrom> sequenceA just wants Applicative, sequence is older and wants Monad.
14:22:29 <imjacobclark> whats the difference between applicative and monad
14:22:42 <imjacobclark> and replacing sequence with sequenceA in my  code works both ways around
14:22:48 <monochrom> Monad has >>=, more powerful than <*>
14:23:11 <monochrom> Turns out sequence is using >>= in a limited way that doesn't exceed <*>
14:23:51 <hyperisco> I was thinking  fmap sequence . fmap . fmap pure  but then I realise that doesn't show what ought to be shown, so really I should have been thinking of  fmap sequence . fmap
14:24:03 <monochrom> There is an obvious comment and complaint and vision dream you can make out of that, given the foregoing discussion.
14:25:04 <hololeap> imjacobclark: (ma >>= f) allows `f` to inspect the inner value of ma, (<*>) doesn't have that capability. that's what they mean by (>>=) is more powerful
14:26:03 <imjacobclark> i see
14:26:37 <imjacobclark> im a beginner to  haskell, i come from java/javascript land, so a lot of this is really odd syntax to me, but I'm persevering... 
14:28:00 <hyperisco> My too-short explanation is that >>= lets you determine the next action based on the result of the previous action, whereas <*> does not.
14:28:02 <c_wraith> imjacobclark, and syntax is the easy part! :)
14:28:18 <imjacobclark> it really isn't ;)
14:28:31 <imjacobclark> im finding the docs very unintuitive :( 
14:28:43 <hyperisco> So in other words, if you know all the actions you need to do up front, then <*> is for you. If you need to see how things turn out before proceeding, then >>= is your friend.
14:28:52 <imjacobclark> im getting support from a friend who is a haskell  developer, but without him, im not sure i could  ever of  found the 'sequence' function
14:29:05 <monochrom> Some syntax differences are manifestations of semantic differences.
14:29:06 <davean> imjacobclark: Hum, Applicative vs. Monad isn't so much syntax as design and capability, other than Monad has a sugar.
14:29:24 <shapr> imjacobclark: I've learned good stuff from the fp-course: https://github.com/data61/fp-course
14:29:47 <davean> imjacobclark: Could you have figured out the signature? Because you can search by signature and if you know what you need it to do, you should know the signature.
14:29:58 <monochrom> For example method-call chain syntax has a different semantics from using functions {mathematical functions) and operators (just mathematical functions in infix notation).
14:30:13 <imjacobclark> maybe, not sure i really know  what i want it  to do
14:30:19 <imjacobclark> other than pull the IO out
14:30:53 <davean> imjacobclark: thats probably enough - but thats also join
14:30:59 <monochrom> In Haskell it works best to think in algebra.
14:31:10 <imjacobclark> sadly i dont have an algebra background
14:31:23 <Rembane> imjacobclark: You can learn algebra while learning Haskell.
14:31:40 <davean> imjacobclark: so if you said "I need something like [m a] -> m [a]" you can search for that and find options
14:31:57 <imjacobclark> yeah but those are just letters to me
14:31:59 <imjacobclark> i think in
14:32:00 <monochrom> I just mean extrapolating school algebra. You won't need Galois theory.
14:32:13 <imjacobclark> i have a list of data, thats wrapped in some weird box, i want the data, not the box
14:32:16 <hyperisco> You can find an option for  m [a] -> [m a]  too oO
14:32:31 <davean> imjacobclark: thats what those symbols say
14:32:49 <hololeap> i'm trying to write a generic function that can take types with different kinds as arguments, and pattern matches on a DataKind, singletons style for any of them. but i'm struggling with how to do it: http://dpaste.com/20B0EPS
14:32:54 <imjacobclark> javascript promises are intuitive, i have a Promise() where I get the value by calling then Promise().then(value => {})
14:33:02 <imjacobclark> but theres no equiv here 
14:33:24 <davean> Sure there is - thats basicly exactly <-
14:33:24 <hyperisco> Sure there is, you just have to know where to look, such as Cont.
14:33:30 <monochrom> Oh that one we write ">>=" for "then".
14:33:42 <imjacobclark> is there somewhere i can go to learn this?
14:33:45 <imjacobclark> in one place? :) 
14:33:55 <davean> imjacobclark: class Monad for that last one.
14:33:59 <hyperisco> Yeah, there's this place called #haskell on freenode that I hear is good.
14:34:08 <imjacobclark> haha
14:34:09 <monochrom> In fact actual code goes like "getLine >>= \value -> putStrLn ("hello " ++ value)
14:34:17 <imjacobclark> i guess i mean a book, or a course, or something
14:34:35 <davean> They already suggested fp-course above
14:34:41 <monochrom> But like MarcelineVQ said I already wrote about it.
14:34:46 <davean> "21:29:03 shapr imjacobclark: I've learned good stuff from the fp-course: https://github.com/data61/fp-course"
14:34:52 <hololeap> do i even need a type family to do it, or is that just complicating things?
14:34:56 <imjacobclark> yeah im just looking at that now
14:35:20 <shapr> imjacobclark: you might like cis194 or a bunch of other free resources
14:35:24 <shapr> @where cis194
14:35:25 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
14:35:37 <monochrom> '\value -> putStrLn ("hello " ++ value)' is a callback. Exactly like how everyone uses a promise.
14:35:50 <hyperisco> imjacobclark, from my perspective, Promise is a little basic. There's much to look forward to!
14:36:01 <shapr> imjacobclark: the benifit of the fp-course is that it requires you to re-implement big chunks of the built-in standard library, thus forcing you to be aware of all the inner machinery
14:36:03 <imjacobclark> yeah, promise was just an  example 
14:36:12 <imjacobclark> shapr: okay cool, ill check it out
14:36:22 <monochrom> Yeah promises are just a special case. Here we also have lists, Maybe, continuation...
14:36:28 <imjacobclark> theres a lot of groundwork here  before  i can  really do something useful, which is holding me back
14:36:43 <hyperisco> Later gators
14:36:47 <hyperisco> And gatresses
14:36:50 <shapr> imjacobclark: I went from "sort of" understanding lots of things to "REALLY" understanding lots of things
14:36:53 <davean> imjacobclark: you might be not looking at the instances in the docs enough - they need to be expanded to see what they contain because most people reading the docs already know what the implications of them are.
14:37:10 <davean> imjacobclark: but so far they're where everything you've asked is hiding
14:37:12 <monochrom> Yeah I definitely did not rush "when will I write useful code?"
14:37:20 <davean> (though I do recomend figuring out the signature and just searching for that)
14:37:35 <imjacobclark> the docs really really put me off
14:37:38 <imjacobclark> i want to see examples, not types
14:37:49 <shapr> imjacobclark: examples of what?
14:37:59 <imjacobclark> i really struggle to understand the haskell docs
14:38:04 <davean> imjacobclark: whats the difference between a type and an example?
14:38:09 <imjacobclark> examples of how to use the functions, the code, the libs
14:38:12 <shapr> imjacobclark: I suggest solving the advent of code problems in Haskell
14:38:29 <shapr> then go back and see how other Haskellers solved those same problems, that's one way I improve my coding skill
14:38:30 <imjacobclark> an example  would be, here is how you unwrap data from a promise... not just, here is a Promise type and said functions
14:39:00 <davean> imjacobclark: mmm, in Haskell thats all shared. It would just be duplicated
14:39:04 <imjacobclark> its like this
14:39:04 <imjacobclark> http://hackage.haskell.org/package/cryptonite-0.26/docs/Crypto-Cipher-AES.html
14:39:05 <monochrom> I thought I showed an example.
14:39:07 <davean> imjacobclark: its either Monad or Comonad
14:39:12 <imjacobclark> that is so useless to me
14:39:20 <imjacobclark> ive no idea where  to start getting AES enc setup
14:39:26 <imjacobclark> maybe i just dont know how to read the docs
14:39:49 <davean> imjacobclark: ok, so lets look at that
14:40:02 <davean> look down to the instances
14:40:12 <imjacobclark> rnf :: AES128 -> ()
14:40:20 <imjacobclark> instance of NFData AES128Source
14:40:30 <davean> ok, and the next instance?
14:40:48 <davean> (Which would be Cipher)
14:40:50 <imjacobclark> cupherInit
14:40:54 <imjacobclark> name, keysize
14:41:07 <davean> yep
14:41:09 <imjacobclark> still unsure what to do  here
14:41:16 <imjacobclark> where do i put pen to paper
14:41:26 <davean> and you'll see thats theres a AES128 or whatnot on the right hand side
14:41:41 <davean> cipherInit :: ByteArray key => key -> CryptoFailable AES128
14:41:49 <davean> so, the question is what is that CryptoFailable?
14:41:49 <imjacobclark> yep
14:41:53 <davean> so click on it
14:42:02 <davean> (I'm not familiar with this library BTW)
14:42:07 <imjacobclark> A simple Either like type to represent a computation that can fail
14:42:20 <davean> Seems so - and its a Monad, so now we know how to use it
14:42:35 <davean> and we have functions like "throwCryptoErrorIO :: CryptoFailable a -> IO a" to run it
14:42:53 <imjacobclark> im not sure ive got how to use it from that :( 
14:42:53 <davean> For our purposes here, a Monad is a sequence of actions, so now we know how to get our AES128 out
14:43:12 <hololeap> can anyone help me with writing the function `branchG`? it's supposed to allow for using pattern-matching on anything with the kind (RecBranch -> k): http://dpaste.com/20B0EPS
14:43:44 <imjacobclark> I can see CryptoFailable is sonething that can be constructed, but what do i construct  it with
14:43:46 <davean> throwCryptoErrorIO $ cipherInit "key" >>= \ourAES128 -> 
14:44:03 <davean> imjacobclark: that function constructs it
14:44:06 <davean> or an instance of it
14:44:18 <hololeap> i have no idea if i need type families here. i can't seem to get it to work either way. is this even possible?
14:44:28 <imjacobclark> davean: how did youget to throwCryptoErrorIO?
14:44:37 <imjacobclark> i can see it in the docs, but how did you know to use it?
14:45:01 <davean> imjacobclark: CryptoFailable is a Monad, we have a thing that constructs a value of it
14:45:14 <davean> we want to do a thing with a value in one
14:45:30 <davean> thus we need something that ... uh, runs? ... the CryptoFailable
14:45:37 <imjacobclark> let me digest that sentece, its a monad, we know this because the docs tell us
14:45:49 <imjacobclark> "we have a thing that constructs a value of it"
14:45:55 <davean> Our main application is probably in IO, but we convert our CryptoFailable sequence into what we want - we had a few options, IO seemed likely what you'd want
14:47:01 <davean> Right, so a Monad is a thing with certain properties. You don't look at specific examples of how to fly jet blue - they're a comercial air carrier, you generally know how to interact with commerical air carriers. They all follow a pattern.
14:47:14 <davean> Monad is a pattern with rules about how it behaves
14:47:33 <imjacobclark> okay, so its a standard interface
14:47:41 <dmwit> hololeap: what are you doing lol
14:48:08 <davean> imjacobclark: yes - the same interface Promise has infact
14:48:19 <imjacobclark> yeah, i know a lil about monads
14:48:51 <davean> imjacobclark: so did how I followed the docs through there make sense to you?
14:49:04 <dmwit> hololeap: Your type instances return types, yeah? So those aren't ever going to be suitable arguments to functions. Those two instances will never fire in the type signature of `branchG`, I don't think, due to kinding considerations.
14:49:06 <imjacobclark> i think so, though id have to try and do something  useful to really understand it 
14:49:23 <davean> well, why not actually finish up an example encrypting something with AES128?
14:49:27 <imjacobclark> i just seem to  keep banging my  head  against the wall everytime i get  2 steps further 
14:49:40 <imjacobclark> it makes me want to give up and just use java
14:49:51 <dmwit> hololeap: I'm also a bit surprised by your `rb` arguments. They don't appear to ever actually *do* anything. Did you mean to write e.g. `RecThis :: a -> RecThese BranchThis a b`, etc. instead?
14:49:52 <imjacobclark> but thats not where i want to go!  :) 
14:50:14 <imjacobclark> davean: this was fun to write: let artistIds = concat . fmap  (\track -> fmap (\artist -> Types.RecentlyPlayed.id $ artist) . artists $ track) . tracks . recentlyPlayed $ marshalledRecentlyPlayed
14:50:35 <imjacobclark> but i could of struggled for  days figuring how to  get  that IO outta that array lol 
14:50:45 <imjacobclark> ill try to really examine the type sig next time
14:50:46 <dmwit> imjacobclark: `\x -> f $ x` is better written `f`.
14:50:49 <imjacobclark> and use hoogle to do it
14:51:24 <dmwit> imjacobclark: Applying that twice, `artistIds = concat . fmap (fmap Types.RecentlyPlayed.id . artists) . tracks . recentlyPlayed $ marshalledRecentlyPlayed
14:51:27 <imjacobclark> oh, omitting  the  x?
14:51:57 <imjacobclark> oh, thats cool!
14:52:00 <imjacobclark> much nicer...
14:52:12 <davean> it can help to keep the labels in for reading it.
14:52:28 <dmwit> imjacobclark: `concat . fmap f` is also so common that we have a `concatMap`, so you might consider `artistIds = concatMap (fmap id . artists) . ...`.
14:53:17 <imjacobclark> aha! 
14:53:18 <hololeap> dmwit: the type instances don't make sense, i'm sure... i have other functions that pattern match on SingRBs. i was trying to get around having to write a branch function for both RecThese and RecTheseF, when both functions are identical except for the type
14:53:20 <imjacobclark> let artistIds = concatMap (fmap (Types.RecentlyPlayed.id) . artists) . tracks . recentlyPlayed $ marshalledRecentlyPlayed
14:53:23 <imjacobclark> much nicer now
14:53:36 <dmwit> hololeap: I suspect you want another singleton to tell `branchG` whether it's receiving a `RecThese` or a `RecTheseF`, too.
14:53:48 <imjacobclark> thanks for all your help all, im sure ill be back shortly :0
14:53:51 <dmwit> hololeap: Oh, you ain't gonna get around that. Sorry.
14:53:51 <imjacobclark> i appreciate it :) 
14:54:53 <dmwit> hololeap: Even if you take all my advice so far and manage to write `branchG`, the way it's going to work is it's going to use `case` to figure out whether it got a `RecThese` or a `RecTheseF`; then in the one case it's going to have all the code for `branch` on the one type and in the other it's going to have that same code but for the other type.
14:54:59 <dmwit> hololeap: So no avoiding it, I'm afraid.
14:56:26 <hololeap> dmwit: this is what i have working so far: http://dpaste.com/0Q7YT9T   `branch` and `branchF` are so similar i thought it might be possible to create a single generic function that can replace both.
14:56:42 <dmwit> imjacobclark: You might also like list comprehensions. `artistIds = [TRP.id artist | track <- tracks (recentlyPlayed marshalledRecentlyPlayed), artist <- artists]`
14:57:03 <imjacobclark> yep, looks like python! haha! 
14:57:09 <dmwit> uh
14:57:19 <dmwit> Lost the call to `track` in there, but I bet you can figure out how to put it back in. =)
14:57:49 <dmwit> Oh, no, never mind.
14:57:51 <dmwit> jkjk
14:57:55 <Mo0O> Hi there, I've got this (very basic) program which seg fault https://paste.steeve.io/71i4?hs if compiled with `-optc-static -optl-static` ghc options and during compilation process there's this warning: Using 'dlopen' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
14:58:23 <Mo0O> It doesn't seg fault if not compiled with those flags
14:58:57 <dmwit> hololeap: branch :: (f BranchThis a b -> c) -> (f BranchThat a b -> c) -> (f BranchThese a b -> c) -> SingRB rb -> f rb a b -> c -- ?
14:59:08 <Mo0O> Do you know if it's possible to compile a static program that require `dlopen`?
14:59:26 <davean> Mo0O: What does that mean?
14:59:57 <davean> I mean ... on Linux theres no such thing as a purely staticly linked program (I think your usage of static here is "Staticly linked")
15:00:25 <Mo0O> davean: yes that's exactly what I mean
15:00:27 <monochrom> glibc is very hard to statically link against and still have it work reliably.
15:00:36 <davean> monochrom: you can staticly link that at least
15:01:06 <Mo0O> can I staticaly link every lib except glibc?
15:01:25 <davean> No one can run an exectuable on Linux without dynamicly linking 
15:01:30 <monochrom> Well the hard part is "have it [the exe] work reliably".
15:01:42 <davean> linux-vdso.so.1
15:01:56 <monochrom> It is not like linkers have a type system.
15:02:13 <davean> Mo0O: You can have something that doesn't call dlopen and is dynamicly linked also
15:02:35 <dmwit> hololeap: (...and then delete branchF and replace calls to it with calls to branch.)
15:03:06 <dmwit> hololeap: I expect you can make branchThis and branchThat similarly parameterized.
15:03:06 <Mo0O> davean: I see, the idea is to limite linking to the strict minimum
15:03:20 <davean> Mo0O: right in which case just don't call dlopen
15:03:36 <davean> and compile everything except linux-vdso.so staticly
15:03:57 <davean> in which case linux will link in linux-vdso.so and your thing will work on exactly the system you compiled it on
15:04:05 <davean> ... and quite possibly no other
15:04:34 <davean> kernel updates may break your application ;)
15:04:58 <Mo0O> hmm ok, so not such a good idea at the end
15:05:21 <davean> Not really - the libc on linux is tightly tied to the kernel 
15:05:42 <Mo0O> I know, I've work with musl also
15:05:44 <monochrom> It may be useful to ask why do you need static linking, and maybe find another route for the same goal.
15:05:47 <davean> UNIX/POSIX was a standard for *source code compatability*
15:06:00 <davean> not binary compatability
15:06:07 <davean> (And linux doesn't follow the standard anyway)
15:06:18 <Mo0O> monochrom: yes, common X/Y problem
15:06:55 <Mo0O> the idea is to deliver a binary to my buddies that they can install quickly, with the less dependencies as possible
15:07:17 <davean> but to answer your earlier question, I have worked with a lot of applications where the compiler/linker did static linking and then they did dlopen themselves.
15:07:20 <Mo0O> the previous version was staticaly linked and everybody was happy with that
15:07:21 <monochrom> One scenerio I know of (very common) is "I'm putting the exe on a computer that doesn't have GHC or Haskell ibraries", in which case you need do nothing! Haskell libraries are already statically linked by default.
15:07:35 <Mo0O> like when we deliver golang app
15:07:51 <davean> Mo0O: if you want a go-link model then USUALLY do nothing
15:08:05 <davean> the special cases are a little with with packages that have extra demands but those are weird
15:08:12 <Mo0O> that's what I try at first
15:08:18 <davean> there was a problem?
15:08:30 <Mo0O> some lib was required
15:09:19 <Mo0O> like ncurses-libs, gmp, libffi
15:09:24 <Mo0O> thinks like that
15:09:31 <Mo0O> things*
15:09:39 <solonarv> Haskell libraries are statically linked by default, however some Haskell libraries are bindings to C (or other language) libraries and link them dynamically
15:09:48 <Mo0O> and obviously glibc (or musl)
15:10:05 <Mo0O> solonarv: totaly make sense
15:10:34 <solonarv> my solution there would be to simply ship the required dynamic libraries as well, and a wrapper script to make sure ld picks them up
15:11:08 <solonarv> (on windows you don't even need that wrapper script, since it searches in the program's directory by default)
15:11:29 <Mo0O> and/or packaging the application for the most comon distro use by my buddies and provide a container image for the rest
15:12:45 <Mo0O> well, I guess I've got my answer now, at least I see clearly the problem
15:13:15 <Mo0O> thanks a lot davean, monochrom and solonarv 
15:13:53 <Mo0O> and sorry for my poor english :$
15:14:14 <Welkin> does anyone recall what that syncing database in python is called? It's like couchdb. I think it starts with a K
15:14:52 <Mo0O> syncing  database in python? what do you mean by that?
15:15:02 <Mo0O> Welkin: which db?
15:18:37 <davean> Mo0O: you CAN staticly link in specific dynamic libraries. I don't have a good system for tracking down and specifying the non-base ones. That might already exist? Not sure. Never a thing I wanted really.
15:18:46 <davean> (not how I distribute software, sorry)
15:19:20 <davean> Welkin: I've no idea what a "syncing database" is or how couchdb would be called such.
15:19:25 <davean> perhaps you mean eventually consistent?
15:20:24 <Mo0O> davean: no worries, at least I have to way to dig more right now, thx
15:29:15 <hololeap> dmwit: you wrote `branch :: (f 'BranchThis a b -> c) -> ...`, but RecTheseF looks like `RecTheseF rb f g a`. the different number of type variables prevents this from working...
15:31:06 <hololeap> i was hoping there was some way to write a function that can handle any (f :: RecBranch -> k)
15:37:16 <d34df00d> What's the best way to execute some IO action periodically? forkIO (forever action)? How do I shut down gracefully in this case?
15:37:45 <hpc> d34df00d: hold onto the ThreadId when you fork it, so you can kill it later
15:38:03 <hpc> d34df00d: or more explicitly, have the action check an MVar or something to see if it should continue looping
15:38:13 <hpc> then mutate it to stop the loop more cleanly and explicitly
15:38:20 <d34df00d> Hmm... I'm probably having an X-Y problem/
15:38:47 <hpc> possibly
15:39:08 <davean> d34df00d: you can also use the timer system in base (or delay) to perform the action and just deregister it when you want it to stop, or so many options.
15:39:11 <hpc> that's a more coherent X than most XY problems have at least ;)
15:39:20 <d34df00d> I want to write an application that would, say, query a set of RSS feeds for updates periodically. Writing all the MVar-handling code, handling OS signals for shutdown and so on looks too low-level.
15:39:35 <d34df00d> So is there's something that I could reuse for this?
15:40:14 <davean> Sure - when the main thread exits the children threads will be killed
15:40:24 <solonarv> d34df00d: with that sort of frequency perhaps it'd be better to outsource the scheduling to cron or something?
15:41:21 <hpc> yeah, you can probably let it exit uncleanly if it's not doing anything particularly sensitive to failure
15:41:43 <hpc> (writing to a non-acid data store is the most realistic thing that would force you to exit cleanly)
15:42:06 <d34df00d> solonarv: that happens once per minute.
15:42:25 <d34df00d> Which is probably already worth a long-running service.
15:42:38 <solonarv> ah, I see. indeed!
15:43:03 <solonarv> I wrote a library for this (periodically executing an IO action):
15:43:07 <solonarv> @hackage fixed-timestep
15:43:07 <lambdabot> http://hackage.haskell.org/package/fixed-timestep
15:43:16 <davean> hpc: what do you mean by uncleanly here?
15:43:36 <solonarv> it's pretty basic, but it's built on top of async so there should not be any problems wrt async exceptions and the like
15:43:43 <hpc> just letting the thread implicitly die with the main thread, no matter what it's currently doing
15:44:11 <hololeap> d34df00d: you could look into FRP... reflex can fire an Event every n seconds: http://docs.reflex-frp.org/en/latest/reflex_docs.html#repeating-events
15:44:18 <d34df00d> Yeah, I'm gonna have some postgresql connections in fly possibly.
15:44:30 <davean> hpc: actually, theres rules for that case
15:45:09 <solonarv> using my library it would be: worker <- asyncRepeatedly (1 / 60) (... stuff that happens once per minute)
15:46:24 <d34df00d> That looks neat, thanks!
15:46:41 <d34df00d> What about the other part? How one writes a good service that's a good *nix citizen?
15:46:55 <d34df00d> I've only done that either with snap, which handles that for me, or in some irrelevant ways.
15:47:50 <d34df00d> What I mean is starting up and shutting down in such a way so that existing tools (start-stop-daemon?) interact nicely with my stuff.
15:48:24 <hpc> d34df00d: systemd has good docs on what an executable should do
15:48:40 <hpc> basically use exit codes and write to stderr, and don't fork into the background
15:49:14 <d34df00d> How do I get notified that it's time to shut down? SIGTERM or smth else?
15:49:15 <hpc> init services are painful to write, and what existing tools help you do
15:49:17 <d34df00d> Or I shall just read those docs...
15:49:25 <hpc> oh yeah, it sends... sigterm probably
15:49:31 <hpc> you'll have to look that one up, i forget
15:49:40 <d34df00d> Got the rough idea, thanks!
15:49:58 <d34df00d> I wonder if there are any frameworks that wrap this for me somehow...
15:50:02 <d34df00d> Just for a cleaner API.
15:50:15 <hpc> from my brief experience, systemd services are super easy to write without extra libs
15:50:45 <d34df00d> My only experience is a couple of snap-based web servers and openrc scripts for them (as I'm on gentoo + openrc).
15:51:07 <hpc> oh yeah, the stop operation depends on the service definition, i remember now
15:51:16 <hpc> it can be a signal, or it can run a separate stop command
15:51:51 <hpc> not familiar with openrc
15:52:14 <d34df00d> Shouldn't be that much of a difference.
15:52:17 <ski> ("don't fork into the background" *sigh*)
15:52:19 <d34df00d> I'll keep that general idea in mind.
15:52:20 <Welkin> davean: syncing as in multiple instances of the database sync to each other with no intervention. It's the definition of CouchDB
15:52:23 <d34df00d> ski: why?
15:52:52 <ski> sometimes that the intended behaviour
15:52:52 <hpc> ah, it's an init script system
15:53:11 <hpc> so you have the same issues as what most libraries heplp you with
15:53:15 <davean> Welkin: they're eventually consistent with each other
15:53:26 * ski didn't really follow the conversation, so may be missing context, though
15:53:26 <Welkin> sure, but that's not the same thing as syncing
15:53:40 <Welkin> it's an entire catergory of databases
15:53:44 <d34df00d> ski: yeah, we're writing daemons.
15:54:13 <Welkin> they have revision numbers, and the entire database is copied over
15:54:18 <Welkin> or a diff od the changes
15:54:21 <davean> Welkin: its the only thing I could find one might describe as "syncing" looking over couchdb's semantics
15:54:47 <Welkin> either way, this doesn't answer my question
15:54:59 <hpc> ski: writing something from scratch for systemd, foreground is preferred
15:55:10 <hpc> is the context
15:55:22 * ski . o O ( "#825394 - systemd kill background processes after user logs out - Debian Bug report logs" <https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=825394> )
15:55:30 <ski> hpc, mhm
15:56:48 <Welkin> fuck
15:56:51 <Welkin> it's called kinto
15:57:02 <d34df00d> solonarv: stupid question, but with fixed-timestep, is the next action scheduled n seconds after the current action starts or finishes?
15:57:21 <d34df00d> I.e. with an action that takes a second and a frequency of 1 Hz, will I get 60 or 30 executions per minute?
15:57:39 <solonarv> d34df00d: I don't actually remember, it's been a while since I looked at the library
15:58:11 <davean> d34df00d: I might recomend scheduling the actions at times.
15:58:49 <d34df00d> davean: hmm, what do you mean?
15:59:14 <davean> d34df00d: specify you want an action to run at a sequence of times
15:59:49 <solonarv> it looks at the clock *before* running the action, and also measures how long the action took to figure out how long it should sleep
15:59:58 <d34df00d> Basically I want to run something, say, once per minute, but since it involves network and it might be slow and/or timeout, I don't want it to pile up.
15:59:58 <davean> like "callbackAt :: MonadIO m => UTCTime -> IO () -> m CallbackKey" (http://hackage.haskell.org/package/delay-0/docs/Control-Time.html), it avoids desync when dealing with lots of actions and loads.
16:00:14 <solonarv> so you should get 60 executions per minute
16:00:30 <d34df00d> Hmm... I'd rather kill my action if it takes too long anyway.
16:00:38 <d34df00d> So probably it does not matter in practice.
16:00:51 <solonarv> I haven't implemented anything to handle cases where it falls behind, or any way to specify a retry strategy
16:00:56 <Berengal> I just want to announce that I just had a program, compiled from brainfuck through llvm, print hello world
16:01:07 <solonarv> that was a "I'll implement it if it's needed" thing, which I didn't need yet
16:01:51 <d34df00d> Why is stack solver so broken.
16:02:16 <d34df00d> solonarv: I have a feature request — please consider adding your package to LTS :)
16:02:44 <solonarv> because it tries to parse cabal's console output, but wasn't updated when cabal changed
16:02:54 <solonarv> d34df00d: sure, make an issue on the repo and I'll get around to it
16:04:16 <d34df00d> solonarv: done, thanks!
16:04:44 <MarcelineVQ> "<d34df00d> I wonder if there are any frameworks that wrap this for me somehow..." dunno but try searching hackage for systemd if you haven't
16:04:49 <Welkin> solonarv: your name got downgraded
16:05:21 <solonarv> yeah, I switched IRC clients and didn't bother re-adding the capital letter
16:05:43 <d34df00d> MarcelineVQ: uh, whatever I found looks like it would tie me to systemd.
16:05:43 <Welkin> you're too hipster for capital letters
16:05:56 <solonarv> nono, I'm too *lazy* for capital letters
16:06:05 <MarcelineVQ> Oh I thought that was what you were after hehe, nvm then
16:06:36 <MarcelineVQ> solonarv found out there's other narvs so he's using the lowercase s to lay low
16:07:06 <d34df00d> I'm cool with systemd, but all my machines are running openrc, so relying on pure systemd would be unreasonable :)
16:07:18 * d34df00d just lazy to learn new stuff.
16:15:37 <halogenandtoast> dmwit: thanks for you feedback earlier
16:47:40 <jackdk> someone beeped me, but it was lost in scrollback. If it was important, contact me again.
16:49:58 <hpc> leave a message after the \a?
16:50:23 <hololeap> i asked about this earlier, but i simplified the code to make it easier to understand. is what i'm trying to do here even possible? http://dpaste.com/17PSZYW
17:00:42 <glguy> hololeap: What type do you think you're instantiating 'f' to be in test1?
17:02:07 <glguy> hololeap: https://gist.github.com/glguy/cb7ec91a03f7612170dd3a3c5e354170
17:02:36 <glguy> hololeap: You need to flip the arguments around on Test1 so that you can instantiate 'f' as 'Test1 a'
17:03:23 <glguy> and f certainly can't have kind    Bool -> k, you're expecting to have values of this type (it's the argument to a function)
17:03:54 <hololeap> glguy: my example wasn't supposed to be working code. i'm just trying to communicate an idea. the idea is that `patternMatch` can work on both `Test1` and `Test2`. are you saying this isn't possible?
17:04:23 <glguy> hololeap: It can't work on Test1 and Test2 as written
17:04:43 <glguy> you'd need to change Test2 also: data Test2 a b (bool :: Bool) = Test2 a b
17:05:00 <glguy> the bool type parameter will always need to be the last parameter
17:05:26 <glguy> then you can instantiate f as either 'Test1 a' or 'Test2 a b'
17:06:45 <glguy> paste updated
17:09:47 <hololeap> glguy: wow, i hadn't thought about rearranging the type parameters. i'm having a bit of a hard time understanding why it has to be like that, though.
17:10:10 <fresheyeball> hey out there
17:10:15 <glguy> Suppose we don't rearrange the type parameters: data Test (bool :: Bool) a
17:10:28 <fresheyeball> I have a bead on an intersting contract and could use help giving a wag for it
17:10:43 <glguy> OK, now let's pick an 'f' for patternMatch to use in test1
17:10:44 <fresheyeball> if the project hits I am damn well going to make it a Haskell project
17:10:55 <glguy> hololeap: What type do you suppose f has?
17:11:04 <glguy> s/has/is
17:11:16 <fresheyeball> basically they want to fly a drone around a stadium, and get information on where there are puddles
17:11:17 <fresheyeball> that's it
17:12:27 <hololeap> i'm not sure... is (* -> * -> *) equivalent to ((* -> *) -> *) or (* -> (* -> *)) ?
17:12:44 <glguy> the latter
17:12:51 <glguy> a -> b -> c means    a -> (b -> c)
17:13:04 <hololeap> ok, i thought it might be reversed with types
17:13:04 <fresheyeball> what do you folks think? I am thinking with opencv bindings out there already, we can do this thing.
17:18:39 <hololeap> glguy: i'm having a hard time with this right now. i'm going to take a little break and give it some thought.
17:19:01 <halogenandtoast> Any fun ways to clean this up? https://gist.github.com/halogenandtoast/1c16d71ce1fe7b8a11b998b4ad916a28
17:19:18 <hololeap> at least now i know that there is a working solution
17:21:30 <jackdk> halogenandtoast: use LambdaCase to avoid binding mpc? readMaybe <$> ask "#players?" >>= \case ...
17:21:32 <halogenandtoast> updated the gist to include the mkPlayerCount
17:23:20 <halogenandtoast> jackdk: I'll give a try at it to see what it looks like
17:23:43 <glguy> halogenandtoast: I added a comment
17:24:35 <glguy> I wouldn't get too clever with lambdacase if it was mine
17:24:51 <glguy> You could eliminate the case using 'maybe' but I don't think that makes it easier to read, either
17:25:16 <halogenandtoast> glguy: yeah my experience is that `maybe` doesn't tend to improve readability
17:26:50 <halogenandtoast> I just wasn't sure if there was a good pattern for looping on a Nothing and returning on a Jist
17:26:56 <halogenandtoast> *Just
17:36:51 <dmwit> hololeap: Ah, I see!
17:38:23 <jackdk> halogenandtoast: untilJust from monad-loops? https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html
17:38:58 <dmwit> hololeap: I see glguy got you sorted, so great. In case you really don't want to rearrange the parameters, you can still get a similar effect (but with a bit more boilerplate) with newtype wrappers.
17:39:36 <halogenandtoast> jackdk: thanks
17:40:37 <dmwit> halogenandtoast: Are you sure you want readLn and not getLine there?
17:40:50 <dmwit> (You're double-`read`-ing as it is here.)
17:40:54 <halogenandtoast> I want getLine, just haven't updated it
17:41:29 * dmwit nods
17:53:40 <cjay-> is there a variant of exitFailure that works from any thread?
17:54:25 <cjay-> it seems otherwise one has to bring the ThreadId of the main thread in scope and use throwTo
17:54:32 <shachaf> exitFailure throws an exception, so you could probably throw an asynchronous exception to the main thread.
17:54:47 <shachaf> If you wanted something more drastic you could probably use a system call directly.
17:56:00 <cjay-> yep, throwing a ExitCode to the main thread works. It's just anoying to pass the main thread id around
17:58:09 <shachaf> Presumably you could store it in a global variable or something.
18:06:05 <hololeap> halogenandtoast: it might not be cleaner, but it's "fun": https://gist.github.com/hololeap/e0740f9d55feeaffa8ff4fdc1d041c48
18:06:23 <cjay-> hmm, link from the async package is interesting 
18:06:27 <cjay-> "Link the given Async to the current thread, such that if the Async raises an exception, that exception will be re-thrown in the current thread, wrapped in ExceptionInLinkedThread."
18:09:25 <halogenandtoast> hololeap: I agree that it's fun,
18:13:13 * hackage extensible-effects-concurrent 0.25.0 - Message passing concurrency as extensible-effect  https://hackage.haskell.org/package/extensible-effects-concurrent-0.25.0 (SvenHeyll)
18:23:30 <mail> ------------ cabal vs stack -----------
18:27:50 <Axman6> I gues that was spam =)
19:08:52 <jackdk> I'm fixing up a library that wraps `network`. It does a blocking `accept` in a forkIO'd thread, and sometimes I will be in another thread and know that I want to stop that accept call.  What is the best way to do this? throw an exception at the `accept`ing thread? try to fcntl O_NONBLOCK and poll the socket? something else?
19:11:02 <tabemann> jackdk: shut down the socket
19:11:48 <jackdk> tabemann: put the socket in a TVar so the other threads can see it, then `close` it so the `accept` fails?
19:12:15 <tabemann> I've always used shutdown for that purpose, but yes
19:14:08 <jackdk> that makes sense. shutdown for read, I assume? Did you shutdown for write when standing up your socket?
19:14:47 <tabemann> with accept I think it's a read shutdown; as for write shutdown, I simply wouldn't do that for the socket in question
20:34:53 <petersjt014> anyone know where I would report a package that's not building due to a failed test?
20:44:41 <hololeap> petersjt014: search for the package at http://hackage.haskell.org and look for "Bug Tracker" below "Versions"
20:46:50 <hololeap> petersjt014: you can also use `ghc-pkg field pkgname homepage` on the command line, considering most packages are hosted on github and have their bug tracker there
20:47:18 <hololeap> (assuming you have the package installed. ghc-pkg won't work otherwise)
20:48:34 <hololeap> petersjt014: `cabal info pkgname | grep "Bug reports"` would probably be better on second thought
20:49:46 <petersjt014> cool, thanks. I installed it wit my distro's package manager though, does that make a difference?
20:50:02 <hololeap> which distro?
20:50:17 <petersjt014> NixOs
20:51:10 <petersjt014> I wasnt sure if this channel or theirs was more appropriate for this problem so I started here
20:51:59 <petersjt014> I'm trying to get a lot of usefull stuff compiled for lots of different architectures,
20:52:24 <petersjt014> and I get the feeling that a package named 'half' being broke on i686 is prob a big deal in that case
20:53:50 <petersjt014> If you want to replicate the problem and have nix installed, you'd want to run:
20:53:54 <petersjt014> nix build -f channel:nixos-unstable pkgsi686Linux.haskellPackages.half
20:54:03 <hololeap> if the NixOS package isn't up-to-date with the latest package on cabal, bug the NixOS maintainers to bump the version and see if that works ... otherwise report it to the bug tracker reported in cabal and include the version number
20:54:36 <petersjt014> alright, gonna go check
20:54:59 <hololeap> i've never used NixOS, but i build all my haskell packages from source through gentoo's PM, for what it's worth
20:56:18 <petersjt014> maybe give it a try--It's got traces of FP all over, and nix by itself is a pretty damn good package manager
20:56:48 <hololeap> petersjt014: it might be worth it to clone the latest revision of the package and run `cabal new-test` to see if it's still failing. otherwise, the maintainers can't do much except push a new version out.
20:56:50 <petersjt014> I told it to cross-compile ghc for ARM once and it *nearly* worked
20:57:11 <petersjt014> alright
20:57:13 <clever> petersjt014: ive done native ghc arm builds, and discovered that ghc lacks native-code-gen for arm
20:57:26 <clever> so it has to go out to llvm, which then segfaults if you build with -j > 1
20:58:13 <petersjt014> I'm here in single-core land so no problems there! :D
20:58:23 <jackdk> petersjt014 I'm trying that build now.
20:58:56 <petersjt014> You know where the detailed logs go? The failed build only spits out the last 10 lines
20:59:07 <petersjt014> I'm pretty sure its in /nix/var
20:59:11 <petersjt014> somewhere
20:59:31 <clever> petersjt014: nix doesnt store the logs for failed builds, re-build it with nix-build instead of `nix build`
21:00:34 <petersjt014> so when I get "builder for '/nix/store/bpn...-half-0.3.drv' failed with exit code 1; last 10 log lines:", that's not stored anywhere? not even /tmp?
21:00:51 <clever> petersjt014: i believe so
21:01:06 <clever> but you can run `nix-store -r /nix/store/bpn...-half-0.3.drv` to redo the exact same build
21:01:38 <petersjt014> huh, didnt know that one
21:03:04 <petersjt014> also, just checked: both hackage and nix are at 0.3
21:03:57 <jackdk> petersjt014: this builds on my machine: nix-build -E 'with import (builtins.fetchTarball { url = "https://github.com/NixOS/nixpkgs/archive/8b5da61fbb407974932725e4cde6d26fc4e46f98.tar.gz"; sha256 = "0crap94vc6j5m05qj51p2hczcy18rnh2z3cqvq74fiwyqik4ndrz"; }) {}; pkgs.haskellPackages.half'
21:04:40 <jackdk> also best sha256 I've seen in a while
21:04:48 <clever> lol
21:05:36 <clever> petersjt014: what does `nix eval nixpkgs.lib.version` return?
21:07:23 <jackdk> it does break if I do go in through pkgsi686Linux instead of pkgs, though. there's no patches for half or anything (you can check by grepping for half under pkgs/development/haskell-modules) so I think you report this upstream?
21:08:01 <petersjt014> clever: "19.03.172786.606306e0eaa"
21:09:02 <clever> petersjt014: what does `nix show-derivation /nix/store/bpn...-half-0.3.drv` return?
21:13:24 <petersjt014> clever: a *lot* of hard to read text with unescaped newlines and other `fun` things
21:13:47 <petersjt014> I can pipe it thru sed to correct those and toss it on a pastebin if needbe
21:13:49 <clever> petersjt014: its just json, pipe it thru jq and then toss it into a pastebin
21:14:47 <petersjt014> ah, it is. I was distracted by the wall-o-text
21:15:12 <petersjt014> on a fun side note, I found the fastest way ton install missong software:
21:15:20 <clever> nix-env -iA nixos.jq
21:15:30 <petersjt014> uninstalled-cmd |& bash
21:15:40 <petersjt014> very jank
21:16:20 <petersjt014> > "The: command not found"
21:16:22 <lambdabot>  "The: command not found"
21:17:05 <petersjt014> got it: http://0x0.st/zury.json
21:17:16 <petersjt014> thats a fun url there
21:17:51 <clever> petersjt014: yep, your doing a 32bit build, i was testing on 64bit and didnt read enough scrollback
21:18:14 <clever> [clever@amd-nixos:~/apps/nixpkgs]$ nix-build -A haskellPackages.half --argstr system i686-linux
21:18:23 <clever> this should reproduce it then...
21:18:27 <petersjt014> yeah, I'm trying to get cachix to build to avoid this exact problem in the future
21:19:21 <clever> why are you still on a 32bit system?
21:19:49 <clever>   (>=) is the opposite of (<) except for NaN
21:19:51 <clever>        Falsifiable (after 53 tests and 2 shrinks):
21:19:53 <clever>          31745
21:19:58 <clever> also, its only a test failure
21:20:19 <petersjt014> It's old. Also, I'm trying to get some stuff build for a lotta archs for portability
21:20:42 <petersjt014> got a bunch built for aarch64 and a few others
21:21:01 <petersjt014> git-annex and cachix are my highest priorites
21:21:11 <petersjt014> and are turning out to be the hardest
21:22:30 <clever> https://github.com/ekmett/half/blob/master/test/Spec.hs#L31-L32
21:22:39 <clever> ah, wrong test
21:22:43 <petersjt014> that looks to be either very fixable or a low-level nightmare
21:22:52 <petersjt014> I take it the 1st one then
21:22:58 <clever> https://github.com/ekmett/half/blob/master/test/Spec.hs#L13-L15
21:22:59 <clever> this one
21:23:35 <clever> its getting a pair of random Half's and then ensuring >= and < agree
21:24:04 <clever> and its failing when oh
21:24:09 <clever> misread the output too, lol
21:24:20 <clever>   1) Round trip should round trip properly
21:24:23 <clever> this is the one that failed
21:24:27 <clever> https://github.com/ekmett/half/blob/master/test/Spec.hs#L28-L29
21:24:30 <clever> line 28, just like it said
21:25:45 <petersjt014> good to know nobody needs to put on the ASM gloves
21:26:09 <clever> it gets a random CUShort, wraps it in a Half, then turns it into a float, back into a Half, then back into a CUShort
21:26:53 <blackbart> I'm having trouble getting the latest haddock github to build. Does it need ghc 8.6?
21:27:07 <clever> [clever@amd-nixos:~/apps]$ git clone https://github.com/ekmett/half
21:27:12 <clever> [clever@amd-nixos:~/apps/half]$ nix-shell '<nixpkgs>' -A haskellPackages.half.env --argstr system i686-linux
21:27:21 <clever> petersjt014: this will grab the source, then drop into an env that can build it
21:27:40 <Axman6> "the latest haddock github"?
21:27:48 <Axman6> Struggling to parse that
21:28:23 <jackdk> haddock-the-tool from a recent github checkout, I think
21:28:24 <blackbart> sorry, the latest from github
21:29:00 <clever> petersjt014: [nix-shell:~/apps/half]$ runhaskell Setup.hs configure --enable-tests
21:29:16 <petersjt014> clever: trying it right now
21:29:21 <clever> [nix-shell:~/apps/half]$ runhaskell Setup.hs repl spec
21:29:25 <clever> petersjt014: and now i'm in a ghci, with a 32bit build of ghc
21:30:29 <petersjt014> well it's built for me now
21:30:54 <clever> petersjt014: the problem was never about building, it was about testing
21:31:30 <petersjt014> So is that 1st command bypassing the tests that failed?
21:31:57 <clever> petersjt014: that dropped me into a shell suitable for building it, rather then a shell with a build+tested copy
21:32:17 <petersjt014> gotcha
21:34:04 <clever> λ> :m *Main
21:34:04 <clever> λ> let roundTrip w = (getHalf . toHalf . fromHalf . Half $ w) === w
21:34:08 <clever> λ> quickCheck (roundTrip 31745)
21:34:10 <clever> 32257 /= 31745
21:34:22 <clever> petersjt014: by changing it from == to ===, quickcheck now shows why it failed to match
21:34:47 <clever> thats some pretty major rounding error, and i wouldnt trust the half library in that state
21:36:24 <petersjt014> a single equals sign...eugh
21:36:48 <petersjt014> I'm getting flashbacks to when I still used for loops instead of map
21:37:01 <clever> petersjt014: if i drop the --argstr from the previous commands, i now get a 64bit ghci, and the same test passes
21:37:08 <clever> that implies a bug in the library
21:38:20 <petersjt014> is the '==' not the source, or is it just a stricter equality that exposes it?
21:38:38 <clever> that just makes the error more visible
21:38:44 * hackage taffybar 3.2.0 - A desktop bar similar to xmobar, but with more GUI  https://hackage.haskell.org/package/taffybar-3.2.0 (eyevanmalicesun)
21:38:48 <clever> == returns a bool, and then quickcheck fails the test if its false
21:39:06 <clever> === returns a property, which contains the left&right halves, quickcheck then =='s them for you, and prints BOTH upon failure
21:39:32 <clever> https://hackage.haskell.org/package/QuickCheck-2.13.1/docs/Test-QuickCheck.html#v:-61--61--61-
21:39:54 <clever> λ> Half 31745
21:39:54 <clever> NaN
21:39:59 <clever> imediate failure, lol
21:40:14 <clever> λ> Half 31744
21:40:15 <clever> Infinity
21:40:21 <clever> λ> Half 31743
21:40:23 <clever> 65504.0
21:40:27 <clever> petersjt014: we have stumbled into special floats!
21:41:12 <clever> i'm not sure this even works, at all
21:41:21 <clever> no int survives going thru it
21:41:27 <clever> other then 0, lol
21:43:11 <petersjt014> I can't think of a reason I'd ever want something like this--double floats, even quad occasionly, but half?
21:43:35 <clever> the readme says GPU stuff
21:44:02 <c_wraith> yeah, they're common in GPU stuff, mostly because you can pack twice as many into the same amount of RAM
21:44:41 <clever> λ> Half 1
21:44:41 <clever> 5.9604645e-8
21:44:53 <clever> either its really broken, or the show instance lies
21:45:04 <clever> it reports that on both 32 and 64bit
21:46:05 <ClaudiusMaximus> clever: the Half constructor takes a Word16 or so, which has the same binary representation as the floating point value.  if you want a half to represent an int, use fromIntegral or so
21:46:13 * hackage notifications-tray-icon 0.1.0.0 -   https://hackage.haskell.org/package/notifications-tray-icon-0.1.0.0 (eyevanmalicesun)
21:46:42 <clever>   Half = Half { getHalf :: CUShort } deriving (Generic, Typeable)
21:47:02 <clever> ClaudiusMaximus: it takes a CUShort, so ghci should be casting the thing i entered on the repl
21:47:37 <clever> λ> 31745 :: CUShort
21:47:37 <clever> 31745
21:47:42 <clever> and this works, on both 32&64bit
21:47:43 <ClaudiusMaximus> sure, but the numeric value of a CUShort bears little resemblance to the numeric value of a Half with the same binary representation
21:47:50 <clever> oooo
21:47:59 <ClaudiusMaximus> do you know C?  union { double d; uint64_t u; }
21:48:01 <clever> so your passing it a raw float
21:48:02 <Axman6> but that does not mean that 31745 represents 31745 as a Half
21:48:09 <clever> that explains it
21:48:12 <c_wraith> clever: I think you're missing the point.  (Half 1) means the half-precision floating point number with the bit pattern 0x00000001
21:48:22 <clever> yeah, that explains everything
21:48:47 <clever> 31745 == 0x7c01
21:48:49 <Axman6> 0x1000 would represent -0 (IIRC)
21:49:04 <clever> 32257 == 0x7e01
21:49:10 <c_wraith> err, yeah, I have a Float's worth of bits.  oops
21:49:55 <clever> one of the bits got flipped when converting it to a float and back
21:50:13 <Axman6> uh, 0x8000
21:50:15 <clever> and the 31745/32257 mean nothing on their own, those are packed half-floats
21:50:39 <clever> so i should look at what they mean when unpacked
21:51:21 <clever> both are different ways to encode NaN
21:51:25 <clever> but 32bit will turn one into another, and 64bit wont
21:51:37 <clever> feels like a broken test, and it should have exceptions for NaN like the other tests
21:57:21 <clever> petersjt014: https://github.com/ekmett/half/issues/22
21:57:43 <hololeap> what's a good class for functors that are also a sum type, and have at least one constructor that does not include `a`?
21:58:46 <petersjt014> clever: thanks
21:58:53 <hololeap> maybe a natural isomorphism with Maybe would be best, because then i could pattern map on Maybe values
21:59:06 <clever> petersjt014: since i suspect its a test bug, you can pass half thru haskell.lib.dontCheck
21:59:27 <petersjt014> is that in --argstr?
21:59:37 <clever> petersjt014: config.nix, a packageOverride
22:00:21 <clever> petersjt014: or an overlay
22:02:48 <petersjt014> clever: is that top-level?
22:03:13 <clever> petersjt014: https://gist.github.com/cleverca22/3f54d232727370a25228e1d5766399a8
22:04:01 <petersjt014> thanks
22:04:36 <hololeap> data F b a = F b a | No | Nein
22:04:57 <hololeap> lets say you have (toMaybe :: F b a -> Maybe a) and (fromMaybe :: Maybe a -> F b a)
22:05:40 <hololeap> toMaybe loses information in that `b` gets lost and both No and Nein get collapsed down to Nothing
22:06:20 <hololeap> fromMaybe has to use default information for b (perhapse using `pure`) and a default unary constructor to create an F
22:06:39 <hololeap> is this a forgetful/free functor pair of an adjunction?
22:08:49 <ski> the functors being `Maybe' and `F b' ?
22:08:57 <hololeap> yeah
22:10:23 <ski> well, for an adjunction `F ---| U' you should have a bijection between `F a -> b' and `a -> U b' (natural in `a' and `b')
22:10:24 <hololeap> it's a natural transformation in the haskell sense (F b a <-> Maybe a), but it looks like an adjunction
22:10:40 <ski> if `U' is an underlying/carrier/forgetful functor, then `F' will be the corresponding free functor
22:10:44 <hololeap> (forall a. F b a <-> Maybe a)
22:11:18 <ski> an adjunction between `F' and `U' is not a natural isomorphism between `F' and `U'. the latter would be a bijection between `F a' and `U a', natural in `a'
22:12:05 <ski> in fact, let's generalize to arbitrary categories. for `forall a. F a ~= G a', we must have `F,G : C >---> D', for some categories `C' and `D'
22:12:44 <ski> iow, `F' and `G' are "parallel" functors, from the same source/domain/input category, `C', to the same target/codomain/output category, `D'
22:13:03 <ski> however, in an adjunction situation, `F ---| G', that's now what we have
22:13:44 <ski> we're to have `F : C >---> D', and `G : D >---> C', iow not being parallel, but going in *opposite* directions !
22:15:21 <ski> so, in the bijection between `F a >---> b' (being a class of morphisms in `D'), and `a >---> G b' (being a class of morphisms in `C'), `a' and `G b' are objects in `C', while `F a' and `b' are objects in `D'
22:15:59 <ski> sorry, s/that's now what we have/that's *not* what we have/
22:16:10 <ski> hololeap : making any sense ?
22:18:33 <ski> an adjunction situation is sortof like saying that two functions are *inverses* of each other. for inverses of (ordinary) functions, they have to go in opposite directions. if `f : A >---> B' is an inverse of `g : B >---> A' (and vice versa, which follows from the definition), then we have `f x = y' being equivalent to `x = g y', for all `x' in `A' and all `y' in `B'
22:19:21 <ski> however, an adjunction situation is weaker than having plain inverses
22:20:02 <ski> assume that `A' and `B' are preorders (so we have an `=<' ordering defined on `A', and also one on `B', satisfying reflexivity, and transitivity)
22:21:39 <ski> then, `f : A >---> B' and `g : B >---> A' form a (monotone) Galois connection iff `f x =< y' is equivalent to x =< g y', for all `x' in `A', and all `y' in `B'
22:23:27 <ski> example : `A' is integers and `B' is rational numbers (with the usual arithmetic/additive orderings), let `f' be the inclusion of integers into rationals, what is `g' then ?
22:24:12 <hololeap> sorry, ski, i stepped away for a minute... i have to catch up
22:25:00 <ski> according to `forall x,y. f x =< y <=> x =< g y', `g y' is the greatest integer `x' which is at most `y' (or rather, whose inclusion into the rationals it at most `y'). iow `g y' is `floor y', rounding `y' downwards to the nearest integer
22:26:21 * ski waits for hololeap to catch up, and possibly state some questions/comments
22:27:32 <hololeap> does a natural isomorphism that stays within category C form an adjunction?
22:27:55 <ski> not necessarily
22:28:26 <ski> an adjunction is involving a bijection between classes of morphisms in two categories (which might be the same category)
22:29:40 <ski> those two classes of morphisms (assuming they're small enough to be sets) could be regarded as objects in `Set', and so this would then be a natural isomorphism between two functors, whose target/codomain is `Set'
22:31:47 <ski> (or, if we're doing enriched category theory, we could use some other monoidal category, rather than `Set', perhaps `Ab' (abelian groups), or something (perhaps the preorder of non-negative real numbers, regarded as a category, with addition as monoidal structure. this leads to "Lawvere metric spaces"))
22:32:23 <ski> hololeap : shall i continue with the "round down to nearest integer" example ?
22:33:32 <hololeap> sure
22:34:02 <hololeap> does that mean that unit/counit must form an isomorphism?
22:34:41 <ski> ok, so take the statement `forall x,y. f x =< y <=> x =< g y' again. pick `y' to be `f x'. we get `forall x. f x =< f x <=> x =< g (f x)'
22:35:23 <ski> by reflexivity, `f x =< f x' holds for all `x'. therefore we get `forall x. x =< g (f x)', which means `id =< g . f', if we define ordering on functions, pointwise
22:36:04 <ski> if we had `id = g . f', that would say that `g' was a post-inverse ("left-inverse") of `f'
22:36:37 <ski> similarly, if we pick `x' as `g y', we'll end up with `forall y. f (g y) =< y', iow `f . g =< id'
22:37:00 <ski> if we had `f . g = id', that would say that `g' was a pre-inverse ("right-inverse") of `f'
22:38:25 <ski> if `g' is both a post- and a pre- inverse of `f', then that means that `f' is also both a post- and a pre- inverse of `g'
22:39:05 <ski> but here, we have something a bit weaker. from knowing `id =< g . f' and `f . g =< id', we can't deduce also `id =< f . g' and `g . f =< id'
22:40:04 <ski> so, this is saying that from knowing we have an adjunction / a (monotono) Galois connection `f ---| g', we can't deduce that we also have one in the other direction, namely `g ---| f'
22:40:26 <ski> the relation `---|' is not symmetric/commutative
22:40:43 <ski> from knowing `f ---| g ---| h', we can't deduce `f = h'
22:41:17 <shachaf> In fact "f -| g -| h" usually means something like "f is dual to h".
22:41:39 <ski> (otoh, from knowing `f' is the inverse of `g', and `g' is the inverse of `h', we *can* deduce `f = h'. where "inverse" means two-sided inverse, both post-inverse and pre-inverse)
22:42:58 <ski> anyway, this is a little bit abstract, so let's try to see what `forall x. x =< g (f x)' and `forall y. f (g y) =< y' means, for the particular `f' and `g' we had, namely `f' was inclusion of integers into rationals, and `g' was rounding down a rational to the nearest integer
22:44:19 <ski> `forall x. x =< g (f x)' means that given any integer `x', if we round it down, as a rational, we'll get back at least the same `x'. in fact, we even have `forall x. x = g (f x)' here, since rounding down an integer `x' yields exactly `x', not merely at least `x'
22:45:34 <ski> `forall y. f (g y) =< y' means that, given any rational `y', if we round it down to an integer (and regard that as a rational), then that's at most `y'. rounding down should never give something greater, should always give something that's at most what we started with
22:46:37 <ski> in this case, we can't replace `=<' with `=', except for rationals `y' which are actually (included from) integers. for non-integral rationals, we have `<', strict ordering. so in general, we have to say `=<'
22:46:46 <ski> hololeap : making any sense ?
22:46:51 <hololeap> ski, yeah
22:48:03 <Axman6> Not sure if this is a better place to ask, or #ghc, but if I have a data type data Foo = Foo {-#UNPACK#-}!Int !Double, and getTheInt :: Foo -> Int, getTheInt (Foo i _) = i, will the Int returnd point to the unpacked Int insidfe the given Foo, and prevent Foo's garbage collection, or will it be copied to the heap and pointed to by the Int# constructor?
22:48:35 <hololeap> ski: so does this hold for any pair of functions to/from sets A and B, where A is a sparser set than B
22:48:38 <Axman6> I'm assuming the latter
22:48:42 <ski> so, `f' was inclusion of integers into rationals. the right adjoint (aka upper adjoint, in the galois connection case, where we have an ordering `=<') of `f' is `g', rounding downwards
22:49:10 <ski> (and the left adjoint (lower adjoint) of `g', rounding down, is `f', inclusion)
22:49:29 <ski> now, what do you suppose the *left/lower* adjoint of `f' could be ?
22:49:44 <ski> iow, if we imagine we can extend to `e ---| f ---| g', what would `e' be ?
22:50:38 <hololeap> it would be fixed?
22:51:02 <hololeap> iow it would be equal to f
22:51:13 <hololeap> and d == e
22:51:20 <ski> we have `f : |Z >---> |Q' here, and `e', as well as `g' must be going in opposite directions, iow `e,g : |Q >---> |Z'
22:51:43 <ski> `g' is "round downwards". what is `e' ?
22:52:06 <ski> (i'm not sure what `d' you're talking about)
22:52:24 <hololeap> sorry, i thought you were trying to extrapolate downwards :)
22:52:57 <hololeap> would e be a mapping of some set onto Integers?
22:53:54 <ski> yes, `e' is a (monotone/increasing) function from rationals to integers
22:54:07 <hololeap> oh, so e is equivalent to g?
22:54:43 <dminuoso> hololeap: An adjunction L -| R is given by a natural isomorphism of hom-functors ⌜C^op x D -> Set⌝: ⌜Hom_D(L(-), -) ~= Hom_C(-, R(-))⌝
22:55:18 <ski> (and `g' is too. while `f' is a (monotone/increasing) function from integers to rationals. the inclusion function is an increasing function. given integers `x0',`x1' with `x0 =< x1', we must have the same ordering `f x0 =< f x1' for the inclusion of integers into the rationals)
22:55:56 <hololeap> oh, so e is something like `ceiling`
22:55:56 <ski> dminuoso just stated in a more abstract way what i already said previously
22:56:01 <ski> hololeap : exactly !
22:56:21 <ski> hololeap : can you spell out `e ---| f', for me, please ?
22:57:34 <hololeap> e is a mapping from rationals to integers, behaving like `ceiling` and f is a mapping of integers to their equivalent rationals
22:58:08 <ski> yes. but i want a logical formula that tells me exactly what the condition `e ---| f' means
22:58:20 <ski> i already gave one such, for `f ---| g'
22:59:14 <ski> you only said what `e' and `f' are. i want spelled out what the relation `e ---| f' between them means
22:59:40 <ski> (at least insofar as we express that meaning with a logical formula)
23:00:07 <ski> (interpreting such a logical formula, to try to gain a better intuition for "what it really means", is another matter ..)
23:01:51 <hololeap> `forall x,y. e x =< y <=> x =< f y'
23:01:55 <hololeap> is that what you mean?
23:02:11 <ski> yes. what is the type of `x', and of `y' ?
23:03:37 <hololeap> x is a rational and y is an integer
23:03:51 <ski> yes
23:04:05 <ski> we can read aloud the property
23:04:15 <ski>   forall x : |Q,y : |Z. e x =< y <=> x =< f y
23:05:49 <hololeap> ok
23:05:55 <ski> as : (given a rational `x') `e x' is the *least* integer `y' such that `x =< f y', iow such that `f y' (inclusion of integer `y' into rationals) is at least `x'
23:07:06 <ski> in short : `e x' is the *least* integer `y' such that (the rational) `y' is at least `x'
23:08:07 <ski> or (since this is a total order) : the least integer `y' such that `y' isn't lesser than `x'
23:08:18 <ski> however, we could just as well read the same property
23:08:22 <ski>   forall x : |Q,y : |Z. e x =< y <=> x =< f y
23:08:58 <ski> as : (given an integer `y') `f y' is the *greatest* rational `x', such that `e x' is at most `y'
23:09:40 <ski> in general, if we have `forall y. a =< y <=> P y', we can read this as : `a' is the least `y' such that `P y'
23:10:12 <ski> *provided* that `P' is a monotone/increasing/upper property (iow that `P y0' and `y0 =< y1' implies `P y1')
23:10:37 <ski> (as a subset, it includes everything greater than all things already in it)
23:11:27 <ski> (similarly, if we have `forall x. x =< b <=> Q x', we can read this as "`b' is the greatest `x' such that `Q x'", provided `Q' is an antitone/decreasing/lower property)
23:12:05 <ski> anyway, this part is more or less an aside, but it might be useful to know about this way of reading properties like this
23:14:11 <ski> anyway, going back to a (monotone) Galois connection `f ---| g', this is sortof like `f' being a pre-inverse of `g', and `g' being a post-inverse of `f', except instead of `id = g . f' and `f . g = id', we only have `id =< g . f' and `f . g =< id'
23:16:45 <ski> er, sorry, i should have said "this is sortof like `f' being a pre-inverse of `g', and *also* *`f'* being a post-inverse of *`g'*, except ..." -- otherwise the comparision with the "..." part doesn't make much sense
23:18:34 <ski> we don't (in general) get a real inverse `g' of `f' (take the inclusion of integers into rationals, again), instead we get to "approximate" such an imaginary inverse "from below", yielding the "round downwards" function `g'
23:19:02 <ski> so, in this `f ---| g' case, `g' is an "approximate inverse, from below", so to speak
23:19:19 <ski> while in `e ---| f', `f' is an "approximate inverse, from above"
23:19:36 <ski> er, sorry, *`e'* is that approximate inverse
23:19:54 <ski> hololeap : i hope this makes at least somewhat sense
23:20:12 <hololeap> i think it does
23:20:14 <ski> now, let's go back to adjunctions
23:20:22 <ski> every preorder is a category
23:20:55 <ski> instead of `x0 =< x1', a proposition, we have `A0 >---> A1', a morphism class
23:23:06 <ski> instead of the (monotone) Galois connection `f ---| g', where `f : A >---> B' and `g : B >---> A', we have the adjunction `F ---| G', where `F : C >---> D' and `G : D >---> A'
23:23:38 <ski> and these two conditions, spelled out, means `forall x : A,y : B. f x =< y <=> x =< g y' respectively `forall A : C,B : D. (F A >---> B) ~= (A >---> G B)'
23:24:49 <ski> just like, in the former case, we could derive `forall x : A. x =< g (f x)', iow `id =< g . f', and also derive `forall y : B. f (g y) =< y', iow `f . g =< g'
23:26:03 <ski> we can, in the latter case, derive `forall A : C. (A >---> G (F A))', iow `Id >---> G . F', and also derive `forall B : D. (F (G B) >---> B)', iow `F . G >---> Id'
23:26:25 <ski> these two are natural transformations, the unit and the counit of the adjunction
23:31:05 <ski> let's pick `C' as the category of graphs (with at most one edge inbetween two nodes), and `D' as the category `Set'. `F A' will be here the underlying set of nodes of the graph `A', what is `G B', for a set `B' ?
23:31:48 <ski> well we should have a bijection between `F A >---> B', and `A >---> G B' (natural in `A' and `B'). `F A >---> B' is a class of morphisms in `Set', iow it's just plain functions
23:32:53 <ski> `A' is any graph, `F A' is its set of nodes. so given any mapping from the nodes of `A', to elements of a set `B', we want to have a graph `G B', and a corresponding graph homomorphism from `A' to `G B'
23:33:00 <ski> (and vice versa)
23:34:13 <ski> well, if we pick `B' as `F A', as before, we should be able to have a graph homomorphism from `A' to `G (F A)'
23:34:55 <ski> `F A' is the nodes of the graph `A', and `G (F A)' will be some new graph. it seems to make sense to, in this case, require its nodes to simply be the nodes of `A'
23:35:00 <ski> but what about its edges ?
23:35:43 * hackage magic-wormhole 0.3.3 - Interact with Magic Wormhole  https://hackage.haskell.org/package/magic-wormhole-0.3.3 (rkrishnan)
23:36:05 <hololeap> there would have to be some default way to generate them
23:36:10 <ski> well, a graph homomorphism `f : A >---> C' must preserve edges : if there's an edge between vertices `x0' and `x1' in `A', then there must also be an edge between the corresponding vertices `z0' and `z1' in `C'
23:36:26 <ski> (but not necessarily the other way around)
23:37:10 <ski> the simplest way to ensure this seems to be to add *all* possible edges between the nodes of `G (F A)' (which we selected to be the set `F A')
23:38:07 <ski> and .. it turns out that if, for any set `B', we define the graph `G B' to be the graph having the elements of `B' as nodes, and as edges having *all* possible edges between those nodes, then (a) `G' is a functor; (b) we have an adjunction `F ---| G'
23:39:34 <ski> also, if we instead ask about a left adjoint `E' of `F' here, iow `E ---| F', in addition to `F ---| G', then `E' will be a functor that to any set `B' gives the graph having `B' as node set, and having *no* edges at all !
23:39:56 <ski> so, `E B' has *no* edges, while `G B' has *all* edges
23:40:43 <ski> my point, with this example, was to show how the left adjoint, in this case also, can be thought of as "approximating inverse from one side" and the right adjoint as "approximating inverse from the other side"
23:41:44 <ski> in the `e ---| f ---| g' situation, `f' was an inclusion. and `e' was approximating from above (round up / ceiling), while `g' was approximating from below (round down / floor)
23:44:04 <ski> however, in this `E ---| F ---| G' situation, `F' was not an inclusion, but rather a projection (forgetting the edges). and `E' seems to, in some sense, be "approximating from below" (giving the least graph, in terms of edges, having given nodes), while `G' seems to be, in the same sense, be "approximating from above" (giving the greatest graph, in terms of edges, having given nodes)
23:45:15 <ski> (perhaps there's better terms to use in this situation here, with `F' a "projection", than "approximating from below" vs. "approximating from above". i'm not sure)
23:46:26 <ski> the main point is to try to add some more sense to how the left vs. right adjoint of `f'/`F' can often be thought about as roughly "approximating inverse from one or the other side/direction"
23:47:16 <ski> it might be instructive to try to compare with a situation where the `F' functor *is* an inclusion. e.g. perhaps inclusion of abelian groups into groups
23:47:59 <ski> probably that will look more similar to the `e ---| f ---| g' situation (assuming both adjoints exist, which i don't recall whether they do, atm)
23:49:17 <ski> in Haskell, probably the adjunction (in types) that we'd think of first is `(,b) ---| (b ->)'
23:50:59 <ski> next, if we define  Sum '(a,b) = Either a b  and  Product '(a,b) = (a,b)  so that we have `Sum,Product :: (*,*) -> *', then these are respectively left and right adjoints of a "diagonal functor" `Delta :: * -> (*,*)' defined by  Delta a = '(a,a)
23:51:18 <ski> so, here we have `Sum ---| Delta ---| Product'
23:53:22 <ski> similarly, we can define  Initial '() = Void  and  Terminal '() = ()  so that we have `Initial,Terminal :: () -> *', and these are respectively left and right adjoints of a functor `Discard :: * -> ()' defined by  Trivial a = '()  so that we have `Initial ---| Discard ---| Terminal'
23:53:34 <ski> (`Delta' might also be called `Duplicate' or `Copy')
23:54:34 <ski> hololeap : anyway .. i'm not sure i should go on more now. i'm not sure whether your original `data F b a = F b a | No | Nein' (perhaps together with `Maybe') can be salvaged to form some adjunction
23:55:51 <ski> hololeap : i hope you understand a little bit more about what adjunctions are about, and that if `F ---| G', then `F' and `G' must go in *opposite* directions, and therefore it can't be about a natural isomorphism between `F' and `G' (which would be `forall a. F a ~= G a')
23:56:46 <ski> if you wanted to .. i could mention a few more examples of adjunctions in math, which might help, if you knew a little about the respective areas of math in which they occur
23:57:15 <hololeap> well, i was able to follow you well enough so far, but i think that's enough for now :)
23:57:19 * ski nods
23:57:37 <ski> (i was suspecting so)
23:58:09 <ski> (i hope some of your misconceptions were cleared up, giving a somewhat clearer picture)
23:59:05 <ski> if you want to, you could also try to spell out in more detail what the adjunction condition, in the above Haskell examples, really means
