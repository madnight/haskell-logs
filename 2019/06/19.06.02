01:25:31 <Axman6> Anyone know of a library which provides a type safe printf using Symbols? printf @"X: %0.2d, y: %0.4f" :: Int -> Double -> {IO (), String, Text, etc.} - I can't remember if I've seen done before
01:30:15 <Axman6> https://hackage.haskell.org/package/printf-safe-0.1.0.1/docs/Text-Printf-Safe.html gets some of the way there, but it'd be nice to also have format specification there too
01:34:39 <c_wraith> Axman6: Symbol isn't designed to be used that way (for some bizarre reason, as that's obviously the ideal use for it).  There are some hacks to force it to work that way
01:36:50 <c_wraith> Axman6: https://kcsongor.github.io/symbol-parsing-haskell/
01:37:26 <c_wraith> Axman6: that's the current state of the world, due to how limited Symbol is
01:37:57 <Axman6> Yeah I came across https://www.reddit.com/r/haskell/comments/55bvt4/typesafe_printf_with_typeintype/d89cmkp?utm_source=share&utm_medium=web2x which says the same thing, how sad
01:38:35 <Axman6> Csongor Kiss has done some very cool stuff, his generic-lens package is pretty amazing
01:54:50 <Axman6> c_wraith: thanks for th elink, that was cool but depressing
03:02:05 * hackage bisc 0.2.1.0 - A small tool that clears qutebrowser cookies.  https://hackage.haskell.org/package/bisc-0.2.1.0 (rnhmjoj)
03:40:33 * fr33domlover notices problems with page loading on Hackage, says 503 backend unavailable
03:44:38 <f-a> fr33domlover: https://status.haskell.org/ it seems ok from here, maybe you can ping people on #hackage?
03:45:42 <talqu> hi, `setFileMode myFilePath 444` does not do the same as `chmod 444 myFilePath` from shell. What am i missing?
03:46:01 <shachaf> One of them is in octal.
03:46:29 <ski> > 0o444
03:46:31 <lambdabot>  292
03:48:51 <talqu> shachaf: oh, thanks
04:43:20 <ub> is it just me, or is hackage down somehow?
04:43:29 <ub> Error 503 Backend unavailable, connection timeout
04:44:14 <yushyin> same for me
04:44:18 <f-a> same here
04:44:22 <Clint> i just did a cabal update and it seemed happy
04:44:35 <f-a> https://status.haskell.org/ tho seems fine here
04:44:51 <Clint> also i'm browsing hackage
04:48:56 <madjestic> is hackage down at the moment?
04:49:07 <lavalike> up for me
04:49:16 <f-a> many people are getting 403 erors, madjestic 
04:49:22 <f-a> *error
04:49:35 <lavalike> maybe it's got a cdn in front that errors out in some parts of the world?
04:49:57 <f-a> most likely
04:51:04 <madjestic> *sadface*
04:55:16 <madjestic> tor seems to have no problem accessing it tho
05:51:14 * hackage these-lens 1, these 1 (phadej): https://qbin.io/oldest-curtis-wdvk
06:15:13 * hackage tls-debug 0.4.6 - Set of programs for TLS testing and debugging  https://hackage.haskell.org/package/tls-debug-0.4.6 (VincentHanquez)
06:18:14 <vaibhavsagar> silly question: how do I cancel out of `cabal new-build`?
06:18:30 <vaibhavsagar> I'm spamming Ctrl+C but it just keeps going
06:20:19 <Guest88> I like to have my bash prompt include $$ for the process id. That way I can open another shell and use pstree to identify and kill whatever needs killing.
06:21:05 <vaibhavsagar> are you saying that there's no way to cancel with Ctrl+C?
06:21:55 <dolio> Ctrl-C works here.
06:21:58 <Guest88> I don't know about killing `cabal new-build` but I just find the pid thing useful in general.
06:22:21 <vaibhavsagar> hmm, I'm trying with 2.4.1.0
06:33:15 <fendor> vaibhavsagar, ctrl+c should work in general
06:34:11 <vaibhavsagar> alright, might be some nix weirdness then
06:36:23 <fendor> vaibhavsagar, no, still works for me
06:38:05 <blankhart> if cabal is constrained to the dependency version proto-lens-0.4.0.1 in my cabal.project.freeze file but then goes ahead and downloads proto-lens-0.5.0.1 as well, is that a bug in cabal or is there a subtlety i am missing https://gist.github.com/blankhart/be8b963be7fd75b6d97b7fdc326de65a
06:39:50 <blankhart> any tips on figuring out why cabal thinks it needs 0.5.0.1 would be most welcome
06:44:18 <zincy> Is there a monadic version of mapAccumR in data.traversable
06:44:48 <zincy> so instead of (a -> b -> (a, c)) -> a -> t b -> (a, t c)
06:44:59 <zincy> you would have (a -> b -> m (a, c)) -> a -> t b -> m (a, t c)
06:46:12 <dolio> traverse with StateT
06:49:20 <dolio> @type \f s t -> runStateT (traverse (\x -> StateT (\s -> f s x)) t) s
06:49:21 <lambdabot> (Monad m, Traversable t1) => (s -> t2 -> m (b, s)) -> s -> t1 t2 -> m (t1 b, s)
06:49:35 <ski> @type (runStateT .) . traverse . (StateT .)
06:49:36 <lambdabot> (Monad m, Traversable t) => (a -> s -> m (b, s)) -> t a -> s -> m (t b, s)
06:50:47 <ski> @type flip . (runStateT .) . traverse . (StateT .) . flip  -- i suppose
06:50:49 <lambdabot> (Monad m, Traversable t) => (b1 -> a -> m (b2, b1)) -> b1 -> t a -> m (t b2, b1)
06:53:24 <zincy> thanks!
06:53:29 <cocreature> vaibhavsagar: I do encounter the same issue occasionally but I never managed to track down what exactly causes it.
06:55:44 * hackage semialign 1 - Align and Zip type-classes from the common Semialign ancestor.  https://hackage.haskell.org/package/semialign-1 (phadej)
06:56:44 * hackage monad-chronicle 1 - These as a transformer, ChronicleT  https://hackage.haskell.org/package/monad-chronicle-1 (phadej)
07:28:13 * hackage semialign-indexed 1 - SemialignWithIndex, i.e. izip and ialign  https://hackage.haskell.org/package/semialign-indexed-1 (phadej)
07:29:07 <solonarv> zincy: note that mapAccum{R,L} are just "traverse with State/Backwards State as the applicative", so it should not be surprising that traversing with StateT m instead gets you what you want
07:34:13 * hackage semantic 0.0.0 - Framework and service for analyzing and diffing untrusted code.  https://hackage.haskell.org/package/semantic-0.0.0 (patrick_thomson)
07:52:04 <Gurkenglas> :t ala StateT traverse -- ski
07:52:06 <lambdabot> (Monad m', Traversable t) => t (s' -> m' (a', s')) -> s' -> m' (t a', s')
07:52:39 * ski can never recall how `ala' works
07:53:22 <Gurkenglas> "Edward, lend me the powers of this newtype for this hooked operation"
07:57:06 <Gurkenglas> (alaf gives you back the hook, au/auf lets you specify another isomorphism than the one a newtype induces)
07:57:14 <Gurkenglas> (and naturally, auf = coerce)
07:59:51 <Gurkenglas> :t alaf StateT traverse -- so I supposed he asked more for this. But the flippity is better this way around I'd say.
07:59:52 <lambdabot> (Monad m', Traversable t) => (a -> s' -> m' (a', s')) -> t a -> s' -> m' (t a', s')
08:34:43 * hackage midi-music-box 0.0.1 - Convert MIDI file to music box punch tape  https://hackage.haskell.org/package/midi-music-box-0.0.1 (HenningThielemann)
08:49:14 * hackage primitive-extras 0.8 - Extras for the "primitive" library  https://hackage.haskell.org/package/primitive-extras-0.8 (NikitaVolkov)
08:50:44 * hackage ascii-string 1.0.1.4, stm-hamt 1.2.0.4 (NikitaVolkov): https://qbin.io/piss-yours-z7m9
08:55:14 * hackage aeson-extra 0.4.1.2 - Extra goodies for aeson  https://hackage.haskell.org/package/aeson-extra-0.4.1.2 (phadej)
08:55:22 <infinisil> Hey, is there somewhere where I can see the GHC release plan?
08:55:29 <infinisil> I'm particularly interested in 8.10's release date
09:03:08 <phadej> 8.8 release date would be nice to know as well ;)
09:06:00 <solonarv> 8.8 has an alpha release out I think
09:06:15 <solonarv> but idk about actual release :P
09:17:13 * hackage hrfsize 0.0.1 - File size in human readable format  https://hackage.haskell.org/package/hrfsize-0.0.1 (librerush)
09:31:17 <iqubic> Does 8.8 have dependant types?
09:40:44 * hackage selda 0.4.0.0 - Multi-backend, high-level EDSL for interacting with SQL databases.  https://hackage.haskell.org/package/selda-0.4.0.0 (AntonEkblad)
09:41:44 * hackage selda-json 0.1.0.0, selda-postgresql 0.1.8.0, selda-sqlite 0.1.7.0 (AntonEkblad)
10:18:41 <solonarv> iqubic: no, dependent Haskell is far far away
10:19:33 <solonarv> there's a bunch of smaller extensions paving the way towards DH, I think one of them (visible kind application, like TypeApplications but at the type level) will be in 8.8
10:21:07 <solonarv> there's also a GHC fork which implements a notion of "matchable/unmatchable arrows", which enables proper higher-order type-level programming by letting you pass around unsaturated type families
10:21:45 <solonarv> for example you can write 'type family Map (f :: a ->> b) (xs :: [a]) :: [b]' (with the obvious implementation)
10:22:48 <solonarv> there's a paper describing it in further detail: https://www.microsoft.com/en-us/research/uploads/prod/2019/03/ho-haskell-5c8bb4918a4de.pdf
10:22:55 <solonarv> but IIRC it won't be ready in time for 8.8
10:23:08 <habbah> Should I start with servant and servant-auth-cookie or servant-auth, or yesod + serversession?
10:25:05 <habbah> It looks like the only one that is up-to-date is servant-auth. servant-auth (https://github.com/zohl/servant-auth-cookie/issues/48) and serversession (https://github.com/yesodweb/serversession/issues/21) seem to need updating
10:48:06 <jkachmar> Is anyone here still using `amazonka` or `gogol` on a regular basis?
11:20:43 * hackage pandoc-csv2table 1.0.7 - Convert CSV to Pandoc Table Markdown  https://hackage.haskell.org/package/pandoc-csv2table-1.0.7 (vmandela)
11:22:41 <dmj`> jkachmar: yea
11:30:36 <jkachmar> dmj`: Do you know if there's anyone helping coordinate either project to help bring them back up to speed?
11:30:46 <jkachmar>  It seems like Brendan's taking a (very well-deserved) break from maintainership, but both libraries have sort of fallen behind in the past year or so without someone (or some group of people) helping out.
11:31:43 <jkachmar> They're two of Haskell's biggest force multipliers in terms of "What can I get done with the language" when it comes to talking w/ cloud providers, so losing them (in that they're not actively tracking changes on AWS or GCP) is kinda rough
11:34:58 <dmj`> Last commit 17 days ago, seems somewhat active. I'm not worried, AWS is backwards compatible. The code won't just "go bad". You might not be able to access the latest and greatest amazon blockchain service, but ec2, s3 will all work fine.
11:35:40 <dmj`> jkachmar: a lot of his work is code gen, so you might be able to just get the XML API description for whatever you're interested in and gen the package yourself
11:36:04 <jkachmar> The last commit was just bumping cabal bounds and README stuff; the rest of the library doesn't look like it's seen much love in the past year or so
11:36:49 <cocreature> if you’re interested in helping out, most maintainers are quite happy to get help :)
11:40:03 <dmj`> jkachmar: yea but the entire community feels as you do, it won't just get thrown to the wayside, plenty of very competent people want it to stick around. As cocoreature says, this could be your time to fill a much needed gap :)
11:40:12 <dmj`> cocreature**
11:41:55 <jkachmar> Just curious to see if anyone else had been taking an initiative here. I've opened up an issue on each project asking the maintainers about tasks or goals that could be established to help improve things and keep the library current.
11:43:47 <phadej>  fwiw, brendan did ask for help in october: https://github.com/brendanhay/amazonka/issues/484#issuecomment-431773481 but ...
11:45:02 <phadej> comments like "I got access myself but haven't had the free time to get a release out so if you are interested..." aren't very encouraging either
11:45:31 <jkachmar> From the outside-looking-in it feels like there's not a whole lot of direction on how to actively update or improve the projects. I've used both libraries a bit in the past, but I just don't know enough about the internals _or_ about the best way to direct the project to even volunteer on a more active level.
11:46:29 <phadej> from my perspective, amazonka is perfect, it only needs periodic updates given the changes/additions in AWS interfaces
11:46:41 <phadej> and maybe some small improvements here and there
11:46:53 <phadej> + and tracking dependencies
11:47:01 <cocreature> ime the way you can improve this kind of stuff is by taking initiative yourself not by making issues asking for roadmaps. if you’re missing a feature, make a PR to add it. if that PR doesn’t get reviewed within a reasonable timeframe offer to help with maintenance
11:47:38 <phadej> and indeed, those kind of changes can be made from the outside
11:48:39 <jkachmar> For massive projects like `amazonka` and `gogol` I think there's more of a need for a project vision than drive-by fixes at the moment.
11:49:13 <dmj`> jkachmar: the core logic of the project is fine, the best thing you could do is point the codegen at the latest APIs and see if it generates a buildable Haskell project. But I don't think the project should change the way it does codegen unless its truly broken. Version bumps and API nuances are things the community can take care of. 
11:50:04 <jkachmar> dmj`: I'd normally agree with that, but there's clearly something about these projects that requires a bit more work than just that.
11:50:11 <cocreature> jkachmar: presumably you have some concrete things that you would like to see improved so try to improve those. or are you just worried about a low frequency in commits but aren’t actually missing anything?
11:50:13 <jkachmar> cf. Nick Hibberd's PR trying to update the models that's been stalled for some time.
11:50:31 <cocreature> sure that’s the kind of thing where you offer to help with maintenance
11:51:27 <jkachmar> I'm fine to help with maintenance as long as there appears to be a future for both libraries to continue improving and tracking the upstream cloud providers
11:51:56 <jkachmar> Otherwise it feels kind of hopeless, and both are sufficiently large enough that overcoming the barrier to understanding how they work at a deep level is a pretty large thing.
11:52:08 <dmj`> jkachmar: If all googol and amazonka did was generate API calls of the form IO (Either Error Result) and data types with serialization, that'd be fine, don't need to get too fancy.
11:52:35 <dmj`> jkachmar: the future of those libs is just to stay abreast of new api updates. Presumably AWS isn't changing it's XML metadata that codegen happens from
11:53:53 <jkachmar> If it was that simple I wouldn't have expected `amazonka` to have fallen behind like it has, so I'm assuming that there's some project-level complexity here.
11:58:32 <phadej> From my experience with maintaining `github` (which is slightly different, as there aren't machine readable spec of the API), it's more that OSS is free, and people have priorities
11:58:44 <phadej> other people (work) projects aren't often maintainer's top priority
11:59:43 <phadej> for me " I will be spending the end of August and early September working full-time on both projects ..." is a bummer
11:59:51 <phadej> I really hope that someone pays brendan to do that
12:01:13 <phadej> s/is a bummer/is a red flag/
12:02:37 <dmj`> jkachmar: in what ways has it fallen behind?
12:04:27 <jkachmar> dmj`: If you look at both Domen Kozar and Nick Hibberd's PRs, attempts at updating the model partially and wholly (respectively) fail to compile
12:05:46 <jkachmar> Hibberd regenerated new models, but the PR is still marked as draft. Kozar updated the model because he was getting runtime errors when communicating with S3
12:07:26 <jkachmar> phadej: Yeah, I remember Chris Done was surveying if people would donate towards his working on `prana`. I would 100% have done that for `amazonka` and `gogol`, given that their existence makes Haskell a lot more tractable for workplace applications.
12:07:34 <dmj`> jkachmar: did you look at the travis? 3/150 jobs failed, all the rest succeeded
12:07:54 <dmj`> jkachmar: https://travis-ci.org/brendanhay/amazonka/builds/521553460?utm_source=github_status&utm_medium=notification
12:08:57 <jkachmar> dmj`: For Domen's PR the tests that failed were some of the ones relating to S3; I would have expected all the others to pass because those code paths should have been untouched
12:09:36 <dmj`> jkachmar: if you read what failed, its the tests. That test code might not have gotten regenerated, the code pertaining to the library for S3 built.
12:09:52 <dmj`> https://travis-ci.org/brendanhay/amazonka/jobs/521553469
12:10:30 <dmj`> the tests failed to compile because they are using the old model it seems
12:11:07 <dmj`> That in no way is Brendan's fault, probably just a failure to properly code gen
12:13:07 <jkachmar> I'm not saying that anything's Brendan's fault, I'm saying that the actuality of the situation we have here is that two of Haskell's most impressive libraries are falling behind in terms of tracking the services they target.
12:13:24 <jkachmar> I'm fine with volunteering time to help with certain things, but the state of the library makes it unclear exactly how this stuff should be gone about in a way that's cohesive with the project's underlying design and long-term goals.
12:15:44 <dmj`> jkachmar: I don't think they're falling behind, the codegen still seems to work, and therefore should work on newer APIs. I'd email Brendan to ask the status, and why the latest APIs haven't been gen'd yet. He has scripts to even push all of the amazonka libs to hackage at once.
12:17:23 <jkachmar> dmj`: The current most active maintainer literally stated "It seems like the package is really falling behind [...]"
12:17:26 <jkachmar> I don't see how that's contentious
12:19:12 <dmj`> jkachmar: where did he say that?
12:19:28 <jkachmar> https://github.com/brendanhay/amazonka/pull/522#issuecomment-493210298
12:20:40 <jkachmar> Brendan's been active in merging PRs over the past few months, but Michael Xavier's been the person I've seen around trying to get things moving and merged in more regularly.
12:22:05 <dmj`> Ok I read that statement. AWS just had a developer summit and released a ton of new services, those all have APIs that need gen. So relative to that event we might be "falling behind", but otherwise, it seems like we should be able to simply generate the new bindings for those services.
12:22:29 <dmj`>  Unless the spec. truly isn't machine readable or AWS keeps changing it and we need to build out new parsers for each service, then that would be a problem and that would make me believe we're falling behind.
12:23:03 <jkachmar> The myriad ways in which Hibberd's PR is currently failing CI points to it being a _bit_ more complicated than "simply generate the new bindings"
12:24:06 <jkachmar> And, as far as I can tell, the PR doesn't attempt to tackle new services
12:27:04 <dmj`> these all look like errors in the way the code was generated, not in the code generator itself
12:27:19 <dmj`> I'd love to be proven wrong
12:29:11 <cocreature> at best the code generation process isn’t documented in such a way that anyone but brendan can run it which is still not a great situation to be in :)
12:29:55 <jkachmar> _Just_ to be clear here, I'm not saying _anyone_ is at fault or that there's something _necessarily_ wrong with the codegen stuff. 
12:29:59 <jkachmar> I'm just saying that the process by which this stuff gets made is non-trivial. If the `gen` documentation says `make clean all` and the resulting output tanks in CI then that is a high maintenance burden for everyone (probably inclusive of Brendan).
12:30:17 <dmj`> cocreature: and he'd probably love if someone took over that role :)
12:31:29 <cocreature> jkachmar: I fully agree with you there. I just don’t think asking for a roadmap or a vision is going to get you anywhere. that’s exactly the kind of stuff that requires time and effort from the maintainer and if they were able and willing to spend that time, the situation would probably be different anyway.
12:31:54 <jkachmar> cocreature: 
12:32:32 <cocreature> So if you want to improve things, you need to provide improvements that don’t require much involvement from the maintainer so either make PRs that pass CI so they just have to click the merge button or make it very explicit that you want to help with maintenance.
12:33:08 <jkachmar> I don't necessarily agree; the time I've spent lurking around the Rust Discord and issues lists makes me _fairly_ confident that a set of diverse contributors and interested parties can help build a vision for what they would like a project to be so that individuals can make contributions that help move the project towards that goal.
12:37:55 <phadej> but amazonka is so narrow goal project
12:39:03 <phadej> as in "port aws sdk to Haskell"
12:39:57 <phadej> and specifically, as the current API approach seems to have power-to-weight ratio, that it's hard to come with clearly better way to represent those APIs in Haskell
12:40:07 <phadej> (which would justify "complete rewrite")
12:40:28 <dmj`> Keep code generation working is a goal of the project, don't really need a formal doc for that, and that's something I think everyone can get behind, esp. those who depend on it. It's more of a "not a problem until it is a problem" situation, and it's just not a problem right now. "Falling behind" is a subjective claim that so far has gone unsubstantiated. I think we should try to reproduce the same errors as nhibberd's gen first
12:41:48 <dmj`> We might not be as up to date as boto, but we're not on AWS's payroll either.
12:43:30 <clever> phadej: amazonka
12:43:50 <clever> ah, you already named it
12:45:14 <phadej> yeah, best would be if AWS sponsored the development of amazonka :)
12:45:23 <dmj`> phadej: here here :)
12:46:04 <phadej> they have PHP sdk's :/
12:47:05 <phadej> anyway, not as GitHub have released `semantic`, I predict a spike in interest in Haskell
12:47:43 <phadej> prepare to guide beginners in getting their first program do something
12:47:59 <Rembane> FUN! 
12:48:01 <sm> phadej: how could we measure that ?
12:48:02 <dmj`> phadej: haha
12:50:16 <sm> rust probably watches analytics for their website, chats, reddit..
12:51:40 <phadej> hmm, Haskell interest by region, China 100, Estonia 26, Sweden 25, ... not sure I could truste google trends on that
12:53:45 <dmj`> Haskell is too difficult to get popular, average joe programmer just wants to copy stack overflow and do dependency-driven development.
12:54:32 <dmj`> We should make something like HaskellScript, where it's lightweight, quick to build. No dep. hell.
12:54:59 <jkachmar> If a language like Rust can become popular then there's no reason a language like Haskell can't.
12:55:06 <sm> dmj`++!
12:55:20 <sm> isn't chris done planning that
12:55:41 <jkachmar> prana's just meant to be a "better" ghci
12:55:42 <jkachmar> I think*
12:56:00 <jkachmar> well, I say "just" and that doesn't really do the project justice
12:56:04 <dmj`> jkachmar: yea but rust ain't got those higher-kinded types right?
12:57:10 <jkachmar> Sure, but Haskell doesn't have lifetimes, manual memory management, etc.
12:58:30 <dmj`> jkachmar: lifetimes no, but I'm doing a lot of manual memory management in haskell with foreign ptrs and finalizers as we speak. So we ghc determines something is out of scope it gets freed on the C heap. I have 100% productivity, 0 allocation on the haskell heap, and everything is in haskell. 
12:59:10 <dmj`> So ghc*
12:59:37 <jkachmar> Someone could write Haskell their entire career and never end up doing that though, whereas someone could not write Rust and avoid dealing with lifetimes and manual memory management. Point is there's an appetite for powerful languages, even if they're not "simple"
12:59:39 <dmj`> sm: It'd be cool to make a toy ghc thing based on the bytecode interpreter. ghc bytecode spec needs love
13:00:17 <jkachmar> dmj`: is that a work thing or something personal/OSS?
13:02:19 <dmj`> jkachmar: personal for now (but could be used on the job), it's basically GPU programming. Had to write a lexer and parser to generate the haskell FFI bindings from the C headers, 3-400 of them (so I feel brendan's pain), then there is a middle layer, and finally a high level interface. 
13:03:01 <dmj`> jkachmar: has a fancy type applications interface
13:04:45 <dmj`> it'll get open sourced soon
13:04:54 <sm> dmj`: 100% productivity.. nice!
13:07:02 <dmj`> sm: yea its great! since ghc core optimization passes don't apply to FFI calls you can just --disable-optimization on everything and stay in another language's heap. Fast dev time in haskell and fast code ! 
13:09:48 <jkachmar> dmj`: very neat! can't wait to see what this looks like :)
13:14:39 <dmj`> jkachmar: heh, same :) it should just be a bunch of pure functions, then some IO for detecting CUDA / OpenCL devices, would lend itself nicely to an arrowized interface, since functions are arrows. Might provide a type safe interface, and non-typesafe one, similar to how hmatrix does it, just throwIO if your dimensions are incorrect.
13:52:53 <dmoerner> Does --builddir no longer work with cabal-install 2.4.0.1 and the new install system? This is a distinctly unhelpful error, since the ambiguous options are in fact identical: https://pastebin.com/wYQjqMLN
14:17:05 <zeta_0> hello guys i just installed ghc, how do i open repl?
14:17:20 <yushyin> ghci
14:18:36 <infinisil> zeta_0: Just google such questions next time, much faster and more informative
14:19:59 <zeta_0> i am already using ghci but it has no autocompletion or any other features
14:21:29 <delYsid``> @src fromIntegral
14:21:30 <lambdabot> fromIntegral = fromInteger . toInteger
14:22:22 <MarcelineVQ> isovector1: https://www.microsoft.com/en-us/research/uploads/prod/2019/03/ho-haskell-5c8bb4918a4de.pdf :>
14:29:18 <zeta_0> is there a way to add auto-completion and other features to to ghci or should i find something else to do repl with haskell?
14:29:58 <mbwgh> Does anybody know how I would go about trying to massage 'histo'(morphisms) into something like a coin-change / knapsack problem? I would need to be able to index into a data structure using two indices, and one of the indices would be decremented by more than one.
14:30:20 <MarcelineVQ> you can press tab to autocomplete things in the repl if they are in scope
14:30:54 <MarcelineVQ> if you want more than that it sounds like you could be looking for an IDE rather than just a REPL
14:56:44 <reallymemorable> if I want to export MIDI byte strings from Euterpea, can I use any Haskell byte string module?
14:56:53 <reallymemorable> And if so, which one do people prefer
14:59:44 * hackage scheduler 1.2.0 - Work stealing scheduler.  https://hackage.haskell.org/package/scheduler-1.2.0 (lehins)
15:13:47 <Nevoic> Is there ever a reason to have a type class with no parameters? It seems impossible to make an instance of it.
15:14:17 <mniip> % class Cls
15:14:20 <yahb> mniip: 
15:14:23 <mniip> % instance Cls
15:14:23 <yahb> mniip: 
15:14:52 <mniip> there are some fairly tricky scenarios where it would make sense
15:17:14 <Nevoic> What can you even do with it?
15:17:18 <Nevoic> Just type stuff?
15:17:22 <Nevoic> no values?
15:17:42 <phadej> % class Foo where foo :: Int
15:17:43 <yahb> phadej: 
15:17:49 <phadej> % instance Foo where foo = 1
15:17:49 <yahb> phadej: 
15:17:52 <phadej> % :t foo
15:17:53 <yahb> phadej: Int
15:17:58 <phadej> % foo
15:17:59 <yahb> phadej: 1
15:18:20 <solonarv> you can write things like:
15:19:14 <solonarv> % class LawOfExcludedMiddle where lem :: Either a (Not a)
15:19:15 <yahb> solonarv: ; <interactive>:150:50: error: Not in scope: type constructor or class `Not'
15:19:23 <solonarv> % class LawOfExcludedMiddle where lem :: Either a (a -> Void)
15:19:23 <yahb> solonarv: 
15:19:38 <solonarv> (although you can't actually write an instance of this)
15:20:07 <ski> % class Bar where bar :: Int
15:20:07 <yahb> ski: 
15:20:10 <ski> % :t bar
15:20:10 <yahb> ski: ; <interactive>:1:1: error: No instance for Bar arising from a use of `bar'
15:20:24 <ski> can we get this to give `Bar => Int' ?
15:20:35 <solonarv> % :t bar -- sure
15:20:35 <yahb> solonarv: ; <interactive>:1:1: error: No instance for Bar arising from a use of `bar'
15:20:39 <solonarv> whoops
15:21:05 <phadej> i guess GHC is "smart" enough to realise that at this point you should have an instance
15:21:20 <phadej> otherwise we'd end up with Eq (Int -> Int) like contexts
15:21:22 <solonarv> % useBar :: Bar => Int; useBar = bar
15:21:22 <yahb> solonarv: 
15:21:26 <solonarv> % :t useBar
15:21:26 <yahb> solonarv: ; <interactive>:1:1: error: No instance for Bar arising from a use of `useBar'
15:21:40 <solonarv> hmm...
15:21:58 <phadej> it's the same error as when you do
15:22:01 <phadej> % 'a' + 'b'
15:22:01 <yahb> phadej: ; <interactive>:160:1: error:; * No instance for (Num Char) arising from a use of `+'; * In the expression: 'a' + 'b'; In an equation for `it': it = 'a' + 'b'
15:22:14 <solonarv> % (unsafeCoerce useBar :: Int -> Int) 5
15:22:14 <yahb> solonarv: ; <interactive>:161:15: error:; * No instance for Bar arising from a use of `useBar'; * In the first argument of `unsafeCoerce', namely `useBar'; In the expression: unsafeCoerce useBar :: Int -> Int; In the expression: (unsafeCoerce useBar :: Int -> Int) 5
15:22:21 <solonarv> aw, man... :D
15:27:45 <mniip> % data Barring where Barring :: (Bar => Int) -> Barring
15:27:45 <yahb> mniip: 
15:27:57 <mniip> % data Box a = Box { unBox :: a }
15:27:57 <yahb> mniip: 
15:28:22 <mniip> % barring :: (Bar => Int) -> Int; barring f = unsafeCoerce unBox (Barring f) 5
15:28:22 <yahb> mniip: 
15:28:30 <mniip> % barring bar
15:28:30 <yahb> mniip: 5
15:29:23 <mniip> shoulda generalized this more but eh
15:29:37 <solonarv> ah ha! needed an actual box to wrap around it, I see
15:30:01 <solonarv> or, couldn't those have been newtypes?
15:30:05 <mniip> yes
15:30:28 <mniip> % newtype Barring' a where Barring' :: (Bar => a) -> Barring' a
15:30:28 <yahb> mniip: 
15:30:37 <solonarv> % newtype Magic c r where Magic :: (c => r) -> Magic c r
15:30:37 <yahb> solonarv: 
15:30:51 <mniip> % barring' :: (Bar => a) -> a; barring' f = unsafeCoerce (Barring' f) 5
15:30:51 <yahb> mniip: 
15:30:54 <mniip> % barring' bar
15:30:54 <yahb> mniip: 5
15:31:04 <solonarv> % unsafeCoerce (Magic bar) (5 :: Int) :: Int
15:31:04 <yahb> solonarv: ; <interactive>:172:21: error:; * Couldn't match expected type `r0' with actual type `Int'; `r0' is untouchable; inside the constraints: c0; bound by a type expected by the context:; c0 => r0; at <interactive>:172:15-23; * In the first argument of `Magic', namely `bar'; In the first argument of `unsafeCoerce', namely `(Magic bar)'; 
15:31:15 <solonarv> % unsafeCoerce (Magic @Bar @Int bar) (5 :: Int) :: Int
15:31:15 <yahb> solonarv: 5
15:31:21 <solonarv> \o/ we did it!
15:31:24 <mniip> there's actually a function in base for it somewhere
15:31:39 <solonarv> in *base*, really?
15:32:08 <solonarv> I know this is how 'reflection' works but I wouldn't have expected to see that kind of nonsense in abse
15:32:34 <mniip> % :i GHC.Exts.magicDict
15:32:38 <yahb> mniip: magicDict :: a -- Defined in `GHC.Prim'
15:32:43 <mniip> sorry ghc-prim then
15:32:51 <mniip> but there are RULES pragmas for this identifier
15:33:01 <mniip> which make sense in Core where * ~ Coercion
15:33:07 <mniip> sorry * ~ Constraint
16:13:56 <eat_those_lemons> Does anyone mind if I check my understanding of monads?
16:14:22 <eat_those_lemons> ie explain them and see if I understand them correctly?
16:19:23 <solonarv> eat_those_lemons: sure, go ahead!
16:19:23 <hpc> a monad is a type with kind (* -> *), which is an instance of Applicative plus (>>=) :: m a -> (a -> m b) -> m b
16:19:33 <hpc> and some associative/identity laws
16:19:46 <hpc> oh, you mean you explain
16:19:47 <MarcelineVQ> hpc: I think they meant they'd try to explain it :>
16:20:04 <solonarv> :D
16:22:33 <monochrom> Generally I find that "explain in my own words" is just self-gratification and has no positive correlation with ability to read code or write correct code. In fact, in this channel, the observed correlation is negative.
16:23:49 <int-e> is writing a monad tutorial still considered to be a rite of passage for upcoming Haskell programmers? :)
16:25:14 <int-e> https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/ was written over 10 years ago :)
16:26:04 <monochrom> I think the new generation no longer knows blogging, and instead post on facebook or twitter.
16:26:33 <solonarv> hey! I know blogging, I just can't be bothered to set one up
16:27:07 <iqubic> solonarv: use hakyll.
16:27:42 <monochrom> But it has always been true that when people get overly excited they look for an outlet of their strong (and usually ungrouded) opinions.
16:28:24 <solonarv> iqubic: I'm aware of it, but that's only part of the solution
16:28:38 <solonarv> there is also the question of "what do I even write about" :P
16:28:49 <int-e> . o O ( "Noone can be told what monads are. You have to see them for yourself." )
16:30:27 <MarcelineVQ> solonarv: take pics of your dinner, let your phone auto-upload, have the computer autoexamine them and generate a story about it, autobuild blog, publish
16:30:40 * solonarv screams in agony
16:30:57 <solonarv> my dinner usually looks pretty unimpressive anyway
16:31:06 <monochrom> I would love to know how to algorithmically convert pics to stories.
16:31:15 <MarcelineVQ> The worst art in history is beloved because of the storyt behind it
16:31:37 <monochrom> But at the current state of computer vision, I fear that the computer will just mistake your steak for a cat.
16:31:49 <solonarv> something something GPT-2
16:32:25 <MarcelineVQ> accuracy, in my dinner-based-fiction?
16:33:35 <monochrom> Wait, are you saying Mona Lisa is the worst art in history, and it is beloved because there is a Dan Brown story around it?!
16:34:36 <MarcelineVQ> That is word-for-word what I said and my legal team will be contacting you shortly over plagarism concerns.
16:35:02 <monochrom> haha
16:35:27 <hpc> nobody cared who i was until i put on the mask^Winstagram filter
16:35:42 <MarcelineVQ> Just feed an image to any image-to-text, feed that to Talk to Transformer. use it to write twitter posts that include the image, you're now an insighful guru.
16:38:01 <solonarv> MarcelineVQ: that's what I was thinking!
16:39:17 <hpc> uh oh, it's MarcelineVQ's turn to talk to lawyers :D
16:42:21 <int-e> hpc: heh what do you thing, how many patents does that infringe?
16:42:24 <int-e> *think
16:42:49 <Nevoic> Do Haskell generics support variance (covariance/contravariance)? Or are they all invariant?
16:43:10 <Nevoic> From what I've seen, they all seem to be invariant.
16:43:52 <Nevoic> I.E `Show a => [a]` can't contain [2, "4"], even though both of those are showable.
16:44:04 <hpc> Nevoic: https://en.wikipedia.org/wiki/Covariance_and_contravariance_of_functors may be a good place to start
16:44:34 <solonarv> Nevoic: Haskell doesn't have subtyping, so that notion of co/contravariance makes no sense
16:44:43 <hpc> i haven't heard of the term variance being applied to parametric polymorphism
16:45:24 <hpc> at least not in general - the position of a type variable with respect to (->) can be called variance
16:46:07 <Nevoic> solonarv: is the only distinction between subclassing and subtyping that the former has to do with types and the latter has to do with objects? This seems like an odd linguistical choice then.
16:46:27 <Nevoic> Because Haskell has "subclasses" concentpaully (Monad is a subclass of Applicative iirc)
16:46:46 <solonarv> right, I misspoke: there is a form of subtyping, but *only* for typeclasses
16:46:55 <solonarv> not for types in general
16:47:24 <monochrom> You are also mistaking universal quantification with existential quantification.  "Show a => [a]" is implicitly "forall a. Show a => [a]" so it is universal quantification, i.e., the user (such as me) chooses what to use for "a".
16:47:27 <hpc> there's things you can express with class contexts that doesn't make sense through the lens of subtyping
16:48:00 <hpc> i would keep type classes out of this - they're very easy to think about incorrectly once OOP gets involved
16:48:13 <eat_those_lemons> sorry had to check on dinner in the oven
16:48:17 <monochrom> A class is not a type, so "subclassing" would be correct wording but "subtyping" is not.
16:48:50 <eat_those_lemons> marcelinevq yea that is what I was thinking,
16:48:51 <Nevoic> monochrom: does existential quantification correlate to having contra/covariance? i.e does the specifying "there exists some" instead of "forall" allow that specific kind of ad-hoc polymorphism?
16:48:56 <monochrom> "Show" is a class but "a" is a type, not a class, and has no subtype or subclass.
16:49:13 <monochrom> No.
16:49:35 <solonarv> to re-word what monochrom said: 'Show a => [a]' does not mean "a list of things which are Show", it means "for any type 'a' that the caller chooses (as long as there is a 'Show a' instance), this is a list '[a]'"
16:49:48 <eat_those_lemons> monochrom do you really think it is self gratification and explaining it doesn't check your understanding? Ie one can think they understand something but until they repeat it back then you cant be sure that they understood correctly?
16:50:17 <monochrom> Yes I do.
16:50:21 <eat_those_lemons> ie one might think they understand it but unless they repeat it back it is unknown if they understood it correctly or got the wrong message
16:50:48 <monochrom> Or rather, I confirm that what I wrote is really what I believe in. (What else could it be?)
16:51:19 <eat_those_lemons> why do you think that? I am curious, I have had many experiences where I thought I understood something but then repeated it back and found that I didn't actually understand it. 
16:51:28 <monochrom> I have observed the opposite. The more they repeat a falsehood to themselves, the more they are sure of themselves.
16:51:54 <eat_those_lemons> I was wondering if you meant repeat back what one understands or if you meant to make an explainer
16:52:10 <monochrom> Is there a difference?
16:52:13 <Nevoic> solonarv: All I'm getting from "universal quantification" for a type [a] is that it makes it invariant and a "subtype" of whatever is quantifying it.
16:52:40 <halogenandtoast> So I keep trying to do this, and I know it's a terrible idea, but I am still wondering if there is any crazy way of doing this (the commented part) https://gist.github.com/halogenandtoast/d4889a75de8dfca8529ab17938a6f190
16:52:41 <Nevoic> i.e Show a => [a] can only be of a single type, and that type must be a Show.
16:53:27 <halogenandtoast> (trying to not use GADTS or RankNTypes)
16:53:34 <halogenandtoast> *GADTs
16:54:54 <shachaf> I think you'll be best off forgetting the words "subtype" and "variance" and instead taking the things monochrom is saying at face value.
16:55:03 <eat_those_lemons> ah I think I missunderstood what you were referring to, I was not saying that I write a blog post or youtube video explaining monads to other people but that I would explain in irc what I understand a monad is and check if I understood it correctly
16:55:25 <monochrom> I guess both => and -> are implications, so both "a -> a" and "Show a => a" are invariant on the ground that "a" is simultaneously both negative and positive.
16:56:13 <solonarv> halogenandtoast: what you are doing there is exactly existential quantification. it's also rather ill-advised, IMO - I'd just go with a 'data Card = TroopCard Troop | TacticCard Tactic' sort of approach
16:56:17 <Nevoic> shachaf: I don't like the idea of unlearning things. Haskell generics should be covariant, contravariant, invariant, or allow some mix of those, unless my understanding of variance + generics is falwed.
16:56:20 <Nevoic> flawed*
16:56:27 <shachaf> Universal quantification is only the first problem here. "=>" is a function, so if you wanted to express "a list of values, each of which has a separate type, which is separately an instance of Show", you'd need to replace both "forall" and "=>"
16:56:55 <eat_those_lemons> I was not thinking of making an actuall explainer, just wanted to check that I don't have the wrong understanding, and the best way I have found to make sure that I understood something correctly is to repeat back what I understand and if my understanding is wrong then the person explaining will catch it and correct me
16:56:59 <Nevoic> monochrom: "negative and positive"? Does that correlate to contra/covariant?
16:57:09 <monochrom> That's what my father always says. "I am sure <some falsehood>. Unless I'm wrong."  And invariably he is always wrong.
16:57:15 <halogenandtoast> solonarv: would there by any way at the type level to say that [Card] should only be of one data constructor then?
16:57:22 <solonarv> monochrom: ah, but in 'Show a' (or rather the dictionary for it) 'a' only appears in negative position! so 'Show a => a' is really '(a -> String) -> a', and 'a' only appears in positive position after all
16:57:28 <shachaf> Haskell has a notion of covariant, contravariance, and invariance (different from but related to the one you're used to). But it doesn't have subtyping, and you should treat type instantiation as its own thing.
16:57:30 <halogenandtoast> i.e. I don't want a deck with both TroopCard and TacticCard
16:57:32 <solonarv> halogenandtoast: yes, but please don't
16:57:45 <solonarv> just have a [Tactic] or [Troop] instead
16:58:16 <shachaf> I'm not saying to unlearn. I'm only saying to take the things people are saying at face value, rather than try to fit them to the patterns you already know.
16:58:23 <solonarv> if you need to "cast"/"convert" it to a [Card], use 'map TacticCard' or 'map TroopCard'
16:58:28 <monochrom> Oh right, solonarv. a->a admits a non-bottom value. Show a => a is still bottom.
16:58:30 <halogenandtoast> solonarv: sure that would be fine, but then I'd want to prevent [Int]
16:58:30 <Nevoic> So when Haskeller's are talking about contra/covariance, they're not talking about this one? https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)
16:58:42 <Nevoic> That one mentions subtyping in the first sentence.
16:58:51 <halogenandtoast> I'm fine accepting it isn't advisably possible
16:58:57 <shachaf> "Haskeller's" are a lot of people who say a lot of things.
16:59:06 <hpc> Nevoic: https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)#Function_types
16:59:07 <Nevoic> Alright, you peeps specifically.
16:59:10 <solonarv> halogenandtoast: don't try to talk about what kinds of parameters are allowed in your 'data' definitions, instead worry about what your functions will accept
16:59:16 <monochrom> Yeah I would reserve *variant for functors.
16:59:19 <eat_those_lemons> int-e fair enough it is like recursion it doesn't make sense but once it does then it is super simple? I guess I should explain that I think I understand monads but they seem so simple that I worry that I missundersand them or am missing something about them because from what I understand they are basically syntaxtic sugar, not a totally new method of passing information, just a nice way to encapsulate the info and then pas
16:59:21 <eat_those_lemons> *be
16:59:26 <shachaf> But Haskell doesn't have subtyping, so probably the subtyping definition isn't the best one here.
16:59:37 <solonarv> you could even write 'class CardType ty where _Card :: Prism Card ty'
16:59:42 <monochrom> In Java I would be happy to discuss *variant.
17:00:13 <halogenandtoast> solonarv: that is interesting, technically I can do draw :: forall a. Card a => Int -> Deck a -> ([a], Deck a)
17:00:14 <monochrom> And yes different communities hijack the same word for different, even opposite, purposes.
17:00:24 <shachaf> Instead of talking about what people mean by words, you can talk about specific sentence, and ask what it means.
17:00:53 <monochrom> For example we say "forall a. a->a" is parametric polymorphism, and we use "generic" for something else entirely (look for Data.Data for example).  Unless Java terminology.
17:00:54 <solonarv> halogenandtoast: exactly, 'draw' just grabs a few elements off the top of a list - why should it care what their types are?
17:01:16 <shachaf> The subtyping sort of variance is certainly related to the functor sort of variance.
17:01:20 <monochrom> s/Unless/Unlike/
17:01:47 <int-e> eat_those_lemons: The common core that makes monads monads is very simple; it's just the bind and return which tie monad actions together. What makes monads useful isn't the glue but whatever additional operations each specific monad provides
17:02:39 <halogenandtoast> solonarv: how would one use that Cardtype class you created?
17:02:51 <monochrom> eat_those_lemons: The monad definition is simple. But if you want to test understanding, my opinion is show that you can correctly predict the outcome of existing code, and write correct code.
17:03:56 <maerwald> predict? you mean without reading the instance implementation?
17:04:11 <monochrom> instance implementation is existing code too.
17:04:18 <maerwald> well, then that's easy
17:04:28 <int-e> monochrom: do you include things like  sequence [[1,2],[3,4]]  ?
17:04:37 <monochrom> My students still struggle with it. :)
17:04:40 <monochrom> Yes!
17:05:02 <solonarv> halogenandtoast: given a 'CardType ty' instance, you can use 'review _Card (foo :: ty) :: Card' to turn some 'ty' into a 'Card', or 'preview _Card (bar :: Card) :: Maybe ty' to check if a 'Card' is actually a 'ty'
17:05:15 <monochrom> I gave that on the exams. Students were already told instance implementations. I even included sequence's implementation. And it's merely Applicative.
17:05:45 <monochrom> Students' answers included [1,2,3,4], [[1,3], [2,4]], [1, [2, [3, 4]]]
17:06:14 <int-e> the last one is... sad.
17:06:26 <solonarv> you might write instances like: instance CardType Troop where _Card = prism' TroopCard (\case TroopCard troop -> Just troop; _ -> Nothing)
17:06:41 <int-e> (the other two are merely wrong)
17:07:27 <halogenandtoast> solonarv: I need to do more work with lenses
17:07:43 <shachaf> haskell tip: [1,2,3,4] is shorthand for [1, [2, [3, [4, []]]]]
17:07:51 <solonarv> @slap shachaf 
17:07:51 * lambdabot is overcome by a sudden desire to hurt shachaf
17:08:27 <solonarv> int-e: the second one is even correct if you have -XOverloadedLists and use ZipList
17:08:38 <solonarv> > sequence [[1, 2], [3, 4]]
17:08:40 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
17:09:00 <solonarv> > (getZipList . traverse ZipList) [[1, 2], [3, 4]]
17:09:03 <lambdabot>  [[1,3],[2,4]]
17:09:46 <int-e> > join [[1,2],[3,4]]
17:09:48 <lambdabot>  [1,2,3,4]
17:10:00 <int-e> at least that's *something* monadic.
17:10:20 <shachaf> Is it still the case that no one has written an explanation of *> anywhere on the Internet?
17:10:30 <shachaf> People keep writing things like (exists a. Show a => a)
17:10:38 <int-e> :t (*>)
17:10:40 <lambdabot> Applicative f => f a -> f b -> f b
17:10:45 <shachaf> Not that one.
17:10:50 <solonarv> ski: ping - come, explain *>
17:10:55 <shachaf> data k *> a = k => Foo a
17:11:00 <shachaf> solonarv: What? Why?
17:11:11 <shachaf> I know what it means. I want an explanation outside of IRC logs.
17:11:14 <solonarv> ski likes using it when explaining things in here :D
17:11:17 <solonarv> aaah, I see
17:11:44 <halogenandtoast> I mean I could copy the explaination to my blog
17:11:44 <monochrom> We kind of created "*>" together.
17:11:55 <jle`> it's a community baby
17:11:56 <halogenandtoast> and then it wouldn't be in IRC logs
17:12:11 <shachaf> Oh, I forgot to mention the third problem with "forall a. Show a => [a]", which is that the quantifier should be inside the []
17:12:11 <solonarv> btw I prefer the GADT syntax definition: data c *> a where With :: c => a -> c *> a
17:12:15 <eat_those_lemons> int-e how every tutorial I read and listened to described monads as something that was super complicated, and if seems like monads are just a way to "attach" information to a value and then pass the "attached information" with the value. Then bind and return just tell how you deal with the value with the data attached
17:12:20 <eat_those_lemons> is it really that simple?
17:12:21 <shachaf> [exists a. Show a *> a]
17:13:08 <int-e> eat_those_lemons: yes and no. it depends on the concrete monad you're working with.
17:13:21 <monochrom> A lot of monads do not sound like attaching information to a value.
17:13:27 <int-e> eat_those_lemons: IO a  doesn't really fall under that description, for example.
17:13:34 <halogenandtoast> monochrom: like [a]
17:13:37 <int-e> (to name the evil one)
17:13:59 <shachaf> You don't need to name IO because that description is false for almost all monads.
17:14:02 <monochrom> halogenandtoast: Sorry, what's that for?
17:14:16 <halogenandtoast> >>  A lot of monads do not sound like attaching information to a value.
17:14:37 <halogenandtoast> I was listing an example
17:14:41 <halogenandtoast> :shrug:
17:14:51 <shachaf> Exampling a list.
17:14:58 <eat_those_lemons> how can they be described then? what am I missing?
17:15:15 <monochrom> I would just recite the monad laws.
17:15:18 <int-e> Yeah I should probably use Reader, State, and the beloved Cont rather than IO. But IO is something people tend to have encountered before...
17:15:29 <halogenandtoast> the monad laws are a good perspective
17:15:52 <int-e> (But not Writer, because that actually falls under the "attaching data to result" description...)
17:15:55 <monochrom> What do numbers describe? (Don't mince words with the like of "answer: quantity" and get into a full circle.)
17:16:15 <shachaf> int-e: In fact it's literally the only one that falls under that description.
17:16:18 <monochrom> And if the monad laws are too dry, I would also start enumerating examples.
17:16:35 <int-e> shachaf: Maybe!
17:16:56 <shachaf> Is existence a property?
17:17:10 <monochrom> Did kindergarten test your understanding of numbers by asking you to describe essayly?  Or did they go ahead and ask you to show how you use numbers?
17:17:22 <eat_those_lemons> numbers I would say describe a value, if there is nothing like `m/s` then they are just a value, floating around in a "mental landscape" without a unit
17:17:28 <eat_those_lemons> essayly?
17:17:33 <Nevoic> monochrom: a value that represents an amount.
17:17:37 <monochrom> And do you write about chess, or do you play an actual chess game?
17:17:50 <int-e> eat_those_lemons: This is my serious take on this: Don't try to understand "monads". Try to look at the various instances of Monad (a few have been mentioned above) and understand those.
17:17:54 <monochrom> I would do the same to monad as I did to numbers and chess. Do things. Stop talking.
17:18:04 <shachaf> I also recommend reading the FAQ on this:
17:18:04 <shachaf> @faq
17:18:05 <lambdabot> https://wiki.haskell.org/FAQ
17:18:14 <zeta_0> how would i do a keybinding for: ghci cabal-new-repl in emacs, here is my .emacs(lines: 50-63)? https://hastebin.com/bohukabiqi.sql
17:18:24 <Nevoic> I've kind of given up on monads. I understand maybe, list, io, etc. I'm convinced at this point monads describe everything.
17:18:26 <Nevoic> I'm probably a monad.
17:18:38 <Nevoic> as long as I have bind and return I'm gucc.
17:18:46 <monochrom> Monads don't describe zip-lists.
17:19:02 <int-e> eat_those_lemons: You'll discover, I think, that they have very little in common... and that very little is also very abstract. It has a name: monad.
17:19:02 <eat_those_lemons> My issue with the chess example is that with just playing chess, I didn't understand, I didn't progress further,
17:19:07 <halogenandtoast> Nevoic: I think, to start with, it's more important to understand how (>>=) works rather than what a monad "actually" is in order to use them in Haskell.
17:19:48 <Nevoic> isn't >>= just flatmap in every other language?
17:19:58 <monochrom> Sure.
17:20:23 <dolio> You mean, that's what they all called it when they copied Haskell?
17:20:25 <Nevoic> If someone had told me that when I was first learning about monads I would've understood it a lot quicker I think
17:20:29 <eat_those_lemons> ie there are a lot of disparate things that fall under the category of "monad" ie shelter could be a "house" (with 2x4's), an overhanging rock, a pile of sticks, mud etc, they accomplish the same thing, but one would never say that a rock overhang and a "house" are the same?
17:20:35 <monochrom> That too, dolio.
17:20:38 <halogenandtoast> getLine >>= printStrLn
17:20:59 <Nevoic> dolio: I don't care about who made it first, "flatMap" was easy for me to grasp when first learning about it because it's a combination of "map" and "flatten".
17:21:00 <halogenandtoast> If flatMap helps your understanding there, than good I guess
17:21:07 <Nevoic> >>= is a sequence of random symbols.
17:21:08 <int-e> Nevoic: Uh, really? I had hoped it was only Scala.
17:21:13 <monochrom> Pro-tip for your next adventure: You can safely re-word "continuation" to "callback".
17:21:19 <Nevoic> Scala, Rust, Kotlin, Swift.
17:21:25 <int-e> :-(
17:21:36 <Nevoic> It's far more common than >>=
17:21:41 <Nevoic> in programming languages.
17:21:41 <dolio> You mean, like concatMap?
17:21:46 <monochrom> I think C# too. Not exactly "flatmap" but a very similar name.
17:22:23 <monochrom> You know what, I'm very OK with it. "flat" ~ "join". >>= is fmap and join combined.
17:23:04 <int-e> Nevoic: I don't particularly mind the name for lists. (Ocaml uses it, not sure about other ML dialects). But generalizing that name to arbitrary monads seems to be missing a point to me :-/
17:23:12 <monochrom> A rare instance when intutive (fictional) wording actually aligns with mathematical reality.
17:23:52 <Nevoic> monochrom: I don't understand that distinction. Words are fictional and math is real? Isn't math just a language to describe things?
17:24:05 <int-e> But maybe I shouldn't complain; "bind" is not really a nice term either.
17:24:05 <monochrom> Math has rules, words don't.
17:24:16 <Nevoic> I'd say grammar is a set of rules for language.
17:24:28 <int-e> (because >>= doesn't bind a thing. It's the lambda in the second argument that binds something.)
17:24:34 <monochrom> Math is great for making refutable sentences. Words are great for moving goalpost.
17:24:43 <hpc> mathematicians ignore names so hard they don't even bother naming things
17:24:47 <shachaf> int-e: It's <- that should be called "bind", obviously.
17:24:52 <hpc> euler's constant is so named because euler came up with it
17:24:58 <hpc> it has nothing to do with what it means
17:25:00 <monochrom> Also words are great for poems and humour. That's at least some benefit.
17:25:01 <Nevoic> Language can be specific if you use words properly, I don't blame language for people's ambiguity, I blame people.
17:25:34 <monochrom> I was ahead of you in that regard.
17:25:49 <monochrom> https://www.vex.net/~trebla/humour/tautologies.html #1
17:26:41 <monochrom> hpc: Pell's equation is so named because Fermat came up with it and it has little to do with Pell.
17:27:01 <monochrom> And don't forget "currying", closer to home.
17:27:36 <monochrom> Currying is so named because Scheofinkel came up with it. :)
17:27:43 <hpc> there's some really great names where they are named after their discoverer but by coincidence aldo describe the thing itself
17:28:00 <hpc> monochrom: have you seen acme-schoenfinkel?
17:29:19 <monochrom> Do "ampere" and "volt" count? :)
17:29:42 <monochrom> I think I have but forgotten what it contains. Let me take a look again.
17:29:53 <hpc> my favorite definition is the bottom one
17:30:07 <hpc> (in that package)
17:31:00 <monochrom> haha
17:31:37 <int-e> hpc: ouch :)
17:31:49 <int-e> though I do approve of "hässlich".
17:32:12 <int-e> @let hässlich = uncurry
17:32:13 <lambdabot>  Defined.
17:32:47 <int-e> ("hässlich" means "ugly" in german)
17:33:01 <hpc> and schoen means good
17:33:11 <int-e> no, it means beautiful
17:33:16 <hpc> ah, close enough
17:33:30 <monochrom> Oh!
17:33:40 <hpc> i took 4 years of german so i barely know it :P
17:33:53 <int-e> so "unschön" is really synonymous with "hässlich"
17:34:03 <shachaf> hässlichfinkel
17:34:40 <monochrom> "dopplerplusunchoen" (if 1984 were written in German)
17:35:01 <monochrom> maybe "dopplerplusungut"
17:35:10 <int-e> shachaf: look up "Schmierfink"
17:35:22 <int-e> doppelplusungut is actually used in the german translation
17:35:29 <monochrom> "ungut++" (if 1984 were written in German C)
17:41:02 <eat_those_lemons> int-e don't try to understand monads as a whole understand "io monads", "state monads", "reader monads", "cont monads" etc? Understand the various types an that will lead to an understanding of monads as a whole?
17:42:07 <int-e> eat_those_lemons: There's more to that. Understanding those various types (well, minus IO because that's best treated as opaque) is *way* more useful than understanding what a monad is.
17:42:56 <eat_those_lemons> Ie it is more useful to understand how it is used vs what a monad actually is?
17:43:12 <int-e> (There's only so much you can do with monad laws. In a formal sense, those laws are the essence of what a monad is.)
17:43:33 <int-e> Yes.
17:44:49 <shachaf> @quote SaulGorn
17:44:49 <lambdabot> SaulGorn says: A formalist is one who cannot understand a theory unless it is meaningless.
17:45:04 <monochrom> :)
17:45:11 <int-e> Learn what a Reader monad does for you, what a State monad does for you, what the list monad does for you, learn about transformers... marvel at Cont from a distance for a while and see how others use it, since it's weird ;-)
17:49:11 <eat_those_lemons> isn't functional programming all about understanding the actual idea vs just how to use/do it? Ie if you are summing a sequence [12, 13, 14, ... 43, 44] you can do that by iterating or you can do `abs([0]-[-1])/2*len(sequence)` go from O(n) to O(1), I am confused then how just pounding my head against the wall looking at implementations will do anything other than teach me to pound a nail into wood, I won't understand why I
17:49:23 <eat_those_lemons> ie math should be understood, not just plug and chug
17:49:27 <int-e> . o O ( Also with Cont there's a reason that the category theory folks will wake up and babble about Yoneda's lemma. ) *runs*
17:49:41 <int-e> s/reason/risk/
17:49:44 * int-e goes to bed.
17:49:59 <eat_those_lemons> So i guess that is to say that I don't understand/agree with the "just go and read code, just mess around with it"
17:50:20 <eat_those_lemons> Well I will look at each of those
17:50:20 <int-e> Ah but if you don't know how to use it, you clearly haven't understood something.
17:50:37 <dolio> The point is that you don't generally get to understanding abstractions just by reading about the abstraction.
17:50:43 <eat_those_lemons> That is fair, although I would say it goes understanding > use not the other way around
17:50:45 <int-e> (Unless it's useless, I guess.)
17:50:49 <dolio> You understand them by looking at examples.
17:51:26 <dolio> Then once you understand the abstraction, you can use that understanding to help understand new examples.
17:53:45 <monochrom> I didn't say "just read" or "mess around".
17:54:02 <monochrom> You have to show predictive power and correct solutions.
17:54:35 <eat_those_lemons> I would agree with looking at examples, but I would disagree with looking at code ie you don't learn how the chess pieces move by just watching a bunch of games, (well you can but it takes a long time) you are shown on the board with the pieces (examples) how each piece moves, the examples are simple and custom made for explaining, one is usually shown how each piece moves on an empty board not in an actual game
17:54:44 <monochrom> If I tested your understanding of gravity, I would not ask you to say things like "things fall".
17:55:01 <eat_those_lemons> I would translate "do things" to "mess around" when one doesn't understand what is going on then they are messing around
17:56:38 <monochrom> I would ask you this question to test your predictive power: I throw four lead balls simultaneously and horizontally, over the 4 combinations of {fast, slow}x{heavier, lighter}. Predict the chronological time of their hitting the ground.
17:56:54 <monochrom> I was speaking of a test of understanding, not a process of learning.
17:57:23 <eat_those_lemons> fair you would test the predictive power, but it someone doesn't understand or think that "things fall" then they won't understand the more general rules
17:57:58 <monochrom> s/time/order/
17:58:02 <eat_those_lemons> test the predictive power to see if they understand it fully but isn't "things fall" a type of prediction? it may have a limited understanding but it is predictive
18:00:20 <eat_those_lemons> fair, although to understand that the lead balls will all hit the ground at the same time (barring air resistance) you would ask me the conceptual question, not to run the numbers, ie you test the abstract understanding, not the concrete understanding, the abstract understanding and the concrete understanding are different things
18:07:13 * hackage servant-kotlin 0.1.1.8 - Automatically derive Kotlin class to query servant webservices  https://hackage.haskell.org/package/servant-kotlin-0.1.1.8 (matsubara0507)
18:09:20 <MarcelineVQ> eat_those_lemons: Now when it turns out the fast heavy ball hits the ground later than the rest what is the next step to take?
18:13:49 <Berengal> I'm getting a syntax error when compiling with `stack build`, but not when I invoke ghc manually or use `stack repl`, what gives? line 100: https://gist.github.com/Berengal/ed21d3f7bec65a8687a1309160303f23
18:18:51 <jusss> is that (f.) can be a Monad?
18:19:19 <jusss> fmap::(a->b) -> (f.a) -> (f.b)
18:19:43 <jusss> bind::(f.a) -> (a->f.b) -> (f.b)
18:20:28 <jackdk> instance Monad ((->) r) where -- Fill this in. I like to use {-# LANGUAGE InstanceSIgs #-} to make it clearer. Also do Functor and Applicative?
18:22:23 <monochrom> Berengal: It probably has to do with GHC default relaxed indentation rule being slightly different from Haskell 2010.  If something throws in -XHaskell2010 behind your back, you will not be under GHC default.
18:23:16 <jusss> jackdk: actually, (f.) == (fmap f)
18:23:38 <monochrom> In the GHC user's guide this is under "Known bugs and infelicities" -> ... -> "Context-free syntax".
18:23:58 <Berengal> monochrom: Looks like it, -XHaskell2010 fails to compile
18:24:09 <Berengal> Now to figure out where that is set
18:24:48 <monochrom> But you can add {-# LANGUAGE NondecreasingIndentation #-}
18:24:49 <eat_those_lemons> marcelinevq, I would look at what angle each ball was thrown at, if they were launched at the same angle, I would look at the topography, the fast ball will go further, so will look if there is an elevation change that would adjust the time fallen
18:26:43 <jusss> apply = f.(g->g') -> (f.g) -> (f.g')
18:27:39 <Berengal> monochrom: Thanks for the help!
18:27:44 <Axman6> I don't understand what that syntax is supposed to mean jusss
18:28:18 <jusss> Axman6: yeah, I shouldn't mix the value and type
18:31:09 <jusss> Axman6: apply = F(g->g') -> F g -> F g'      apply  f.(\g -> g')   f.g  =  f.g'    can this be existed?
18:32:14 * hackage scheduler 1.3.0 - Work stealing scheduler.  https://hackage.haskell.org/package/scheduler-1.3.0 (lehins)
18:32:48 <Axman6> I still don't understand what that means
18:33:14 * hackage massiv 0.3.3.0 - Massiv (Массив) is an Array Library.  https://hackage.haskell.org/package/massiv-0.3.3.0 (lehins)
18:33:32 <jusss> Axman6: can (fmap f) be a monad or functor
18:36:56 <Axman6> what is f) (or m)  in that case? what's the type of fmap for fmap f?
18:41:06 <jusss> I don't know
18:42:59 <Axman6> I can't see how the result of fmap f has kind * -> *
18:43:44 <jusss> you're right
18:44:28 <Axman6> It's possible what you're after is a thing, but I'm not sure what it is
18:53:14 * hackage xcffib 0.8.1 - A cffi-based python binding for X  https://hackage.haskell.org/package/xcffib-0.8.1 (TychoAndersen)
19:08:50 <Nevoic> What's the inverse of `<$>`?
19:09:03 <Nevoic> Or why would I want to use <$> over it's inverse, when things like >>= maintain the opposite order?
19:09:06 <Axman6> Inverse in what way?
19:09:17 <Nevoic> arguments flipped if it's used as an infix function.
19:09:26 <Axman6> We also have <&>
19:09:35 <Nevoic> I thought that was it, but it wasn't working.
19:09:37 <Nevoic> Does it need to be imported?
19:09:49 <Nevoic> :t (<&>)
19:09:50 <lambdabot> Functor f => f a -> (a -> b) -> f b
19:09:51 <Axman6> yes, Data.Functor I thnk?
19:09:56 <Axman6> think*
19:10:02 <Axman6> @hoogle (<&>)
19:10:02 <lambdabot> Data.Functor (<&>) :: Functor f => f a -> (a -> b) -> f b
19:10:02 <lambdabot> Control.Lens.Lens (<&>) :: Functor f => f a -> (a -> b) -> f b
19:10:02 <lambdabot> Control.Lens.Operators (<&>) :: Functor f => f a -> (a -> b) -> f b
19:10:18 <Axman6> it's used a lot with lens
19:10:37 <Nevoic> I did import Data.Functor and it's still not working in ghci.
19:11:03 <Nevoic> 8.2.2
19:11:52 <pong> :t fmag
19:11:53 <pong> :t fmap
19:11:53 <lambdabot> error:
19:11:53 <Axman6> Since: 4.11.0.0
19:11:53 <lambdabot>     • Variable not in scope: fmag
19:11:53 <lambdabot>     • Perhaps you meant ‘fmap’ (imported from Control.Monad.Writer)
19:11:54 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:12:59 <Nevoic> Interesting, I must be doing something wrong then.
19:13:15 <Nevoic> I did:
19:13:15 <Nevoic> import Data.Functor
19:13:15 <Nevoic> :t (<&>)
19:13:17 <lambdabot> Functor f => f a -> (a -> b) -> f b
19:13:29 <Nevoic> The import worked, and the type just errors out and suggests <$> and <*> from prelude.
19:13:38 <Nevoic> The ghci prompt has Prelude Data.Functor >
19:14:17 <Axman6> if you look at https://wiki.haskell.org/Base_package you'll see base 4.11 came out with ghc 8.4.1
19:14:24 <Nevoic> oh
19:14:58 <Nevoic> prior to ghci 8.4.1 did you have to roll your own?
19:15:29 <Axman6> or use lens'
19:15:48 <Axman6> just define it wrapped in an #if pragma
19:17:07 <Nevoic> Kind of related, is there a reason that Haskell is a lot more operator heavy than other languages? Just easier to define them?
19:17:23 <Nevoic> I'm trying to get into it and use a lot of the operators, but I'm not sure how much I'm feeling it yet.
19:19:25 <Nevoic> `(\l -> read l :: Int) <$> getLine` isn't necessarily more readable than `int(input())` (Python) or `readLine()?.toInt()` (Kotlin)
19:19:36 <Axman6> we tend to write much more general functions than you would in other languages, so "good" names can be hard
19:20:06 <Nevoic> Yeah that's fair, read is more general than `int` or `toInt`
19:20:24 <Axman6> you might find this useful: https://www.youtube.com/watch?v=ZSNg6KNzydQ
19:21:03 <Nevoic> Yeah I'll definitely watch that, because I totally disagree that "names don't matter".
19:23:12 <Axman6> then you definitely sdhould watch it
19:24:13 * hackage StateVar 1.2 - State variables  https://hackage.haskell.org/package/StateVar-1.2 (EdwardKmett)
19:30:53 * Axman6 needs moar smooshMap
19:44:48 <Nevoic> Axman6: Finished watching it.
19:45:14 <Nevoic> His most important point in my opinion is that types are more important than names, which is something I've absolutely agreed with for a long time.
19:45:23 <Nevoic> That's why I try to work in static languages instead of unityped languages.
19:46:07 <maerwald> when you have a highly polymorphic language, names become more important than types
19:46:08 <Nevoic> He seemed to move around what "matters" means to most people, in such a way that he was able to say "names don't matter, so we should be careful about what we name things, make sure not to take names that are already being used, and converse heavily about how we name things"
19:46:42 <Nevoic> Seems disingenuous, but it was an impressive feat to move terms around linguistically and subtly enough to be able to make a statement like that.
19:48:09 <Axman6> Jed's often in here, I'm sure you can bring that up with him if you want
19:48:24 <Nevoic> It's not a huge deal, since I agree with nearly everything he said.
19:48:46 <Nevoic> The rest is just semantics. It might've been more geared at people who believe that naming things carefully doesn't matter than those who believe it does.
19:49:39 <Nevoic> In a simple sense, if I wanted to convey his message, I wouldn't say "he thinks names don't matter"
19:49:48 <Nevoic> I think people would get the wrong idea.
19:50:10 <Axman6> that was sort of the point I thought
19:51:06 <Nevoic> If he's representing what people who say "names don't matter" mean when they say that, then yeah it is just entirely semantics and I get his point.
19:51:31 <Nevoic> I've met people before that say "names don't matter" and name everything x,y and z in Python because "the computer sees it the same way"
19:52:08 <Nevoic> When the video dude was going on about the importance of writing maintainable code and code that other people can understand, just emphasizing that types are more important than names.
19:52:28 <Nevoic> But that we should still be careful in choosing names.
19:53:04 <Nevoic> Or changing names. When he went on all the examples of bind vs. flatmap vs. then etc. I don't think that was entirely accurate, since Java also has a flatMap, and Swift, and Rust, and Scala.
19:53:27 <Axman6> Names matter when there's a meaningful context for them. The codebase I work on uses many long, domain specific names for tghings, because the context exists. but general functions like foldr have only the context of functions and lists, so there is no meaningful names to be given, and sticking to convententions like f, z, x, xs gives the context that's needed for those arguments
19:54:01 <Nevoic> Yeah, I agree with that. I don't use long variable names for things that have no context.
19:55:14 <Nevoic> When I was talking about "readability" before I was comparing the use of a generic function + a generic operator + a specific function + a type specification vs. a specific function + another specific function.
19:56:28 <Nevoic> There are pros and cons to both, but few people from the OO side of things would understand
19:56:28 <Nevoic> (\l -> read l :: Int) <$> getLine
19:56:28 <Nevoic> and a lot of people on the fp side would understand
19:56:28 <Nevoic> getLine.toInt()
19:57:21 <Nevoic> Granted you can make them both look very similar with a do block + variables, but shortening them both up to one line changes things a bit.
19:57:53 <Axman6> PErsonally I'd just use (read @Int) <$> getLine =)
19:58:36 <jackdk> The thing I like about the operators is that there is a sensible visual language associated with them, and they often play a "punctuation" role, so you don't really want them at the same level as your named functions
19:58:36 <Nevoic> I didn't even know you could do that, it took me a while to figure out how to improve getLine >>= \l -> return (read l :: Int)
19:58:48 <Axman6> which reads quit nicely imo,; read as Int, over the result of getLine
19:58:49 <dolio> @type readLn
19:58:50 <lambdabot> Read a => IO a
19:58:53 <Nevoic> what does @Int do?
19:59:18 <Axman6> it's a TypeApplication (the name of the language extension to turn on)
20:00:07 <Nevoic> Axman6: That's cool, I'll give it a go.
20:00:14 <Axman6> an extension which exists to solve things like the problems with show . read == id, the compiler doesn't know what type's "in the middle"
20:00:17 <jackdk> the other thing I like about operators is that people care that they form a useful visual language, so related things often have related names. >>=, =<<, >=> and <=< all do monadic stuff.
20:00:39 <jackdk> $ is apply, <$> is fmap, & is flip apply, so <&> is flip fmap
20:00:39 <Nevoic> Yeah my point wasn't that "operators suck", it's that you lose something by generalizing everything.
20:00:44 <Nevoic> Not even that it's not worth it.
20:00:58 <Nevoic> Just that there's something beneficial to reification/specificity.
20:01:32 <Axman6> you don't lose anything, you just have a little more to learn, and once you do it becomes very natural
20:01:57 <Nevoic> The lose the ability to easily convey your code to non-programmers.
20:02:26 <Nevoic> Or very beginners I should say (they understand that an Int is a number, I'm not sure if that means I should qualify them as programmers)
20:02:37 <Nevoic> I guess not, since Integer is a math term.
20:03:24 <Axman6> I’m not sure that’s true.
20:03:32 <Nevoic> They can put together what `readLine.toInt()` means (read a line and turn it into an Int).
20:04:14 <Axman6> can they?
20:04:39 <Nevoic> In my experience, maybe I've been lucky.
20:04:51 <Axman6> iuf they've been introduced to some OOP oncepts before, perhaps, but how is . and some weird ()'s any easier than read <$> getLine?
20:05:07 <Axman6> context matters
20:05:11 <Nevoic> I have a Discord bot setup and I can type in code in various languages, and when I do "readLine.toInt()" the non-programmers put together that they're supposed to enter a number.
20:05:29 <Nevoic> I'm not sure that (read @Int) <$> getLine
20:05:29 <Nevoic> would have the same effect.
20:05:31 <Nevoic> I should test it.
20:05:54 <shachaf> I don't get the point of the last 10 minutes.
20:06:07 <shachaf> Are you trying to get people to concede that Haskell is bad for this or that purpose?
20:06:13 <Nevoic> Nope.
20:06:14 <shachaf> I'll concede it.
20:06:25 <Nevoic> No need, that wasn't my point.
20:07:06 <Nevoic> Simply that generalizing everything + converting functions to operators __can__ make things harder to understand.
20:07:17 <Nevoic> Not that they always do, but that it's not a 100% always good thing to do.
20:07:23 <shachaf> OK.
20:07:34 <shachaf> That seems like a very weak statement. It's obviously true.
20:07:45 <Nevoic> I didn't realize it was obviously true to everyone.
20:07:48 <Nevoic> My bad.
20:08:49 <Nevoic> I made another very weak statement (x haskell code isn't necessarily more readable than y Kotlin or z Python) and someone suggested I watch a 30 minute talk on "why names don't matter"
20:08:56 <Nevoic> So it seemed to me like it was contentious.
20:13:17 <Nevoic> I should mention Axman6 thanks for that tip, using TypeApplications in my code now.
20:19:39 <Axman6> no worries
20:51:06 <maerwald> haskell code isn't more readable in general
20:51:12 <maerwald> It's just a language
21:00:26 <slack1256> When modeling via FRP, how should I do async proccess (as for example recv on a socket?)
21:00:56 <slack1256> On bare IO I would spawn a (async) thread and communicate via an TChan o TVar
21:13:45 <Axman6> jackdk: ping ^^^
21:14:04 <jackdk> A socket is morally something like socket :: (BunchO'Constraints) => Socket -> Event t ByteString -> m (Event t ByteString)
21:14:41 <jackdk> there's https://github.com/qfpl/reflex-backend-socket to give you an idea, but it currently leaks FDs because things aren't getting closed properly. I think I'm close to a fix.
21:15:17 <Axman6> noice
21:15:54 <slack1256> nice
21:16:44 * hackage extensible 0.5.1 - Extensible, efficient, optics-friendly data types and effects  https://hackage.haskell.org/package/extensible-0.5.1 (FumiakiKinoshita)
21:36:14 * hackage elminator 0.2.4.1 - Generate ELM types/encoders/decoders from Haskell types.  https://hackage.haskell.org/package/elminator-0.2.4.1 (sras)
21:36:15 <ShalokShalom> is there something elm-ui for Haskell?
21:36:57 <jackdk> I can think of at least three interpretations of your question. Can you be more specific?
22:04:01 <sambo> Hey all! I am wondering if ThreadId's are unique in any given run of the Haskell runtime.
22:11:10 <clever> sambo: i have a program that runs a long time, and does a lot of threads, the debug logs are showing ThreadId 208170978
22:15:56 <sambo> clever: ok, seems like it. I don't think they would have implemented a pure Eq for it otherwise
22:19:39 <c_wraith> ThreadId is a weird thing.  It's not just a number.  It's actually the reference to the TSO
22:20:53 <c_wraith> as long as you hold a ThreadId, it keeps the TSO around.  It won't get GC'd.  No other thread will use that same TSO.  it is unique, as long as it exists
22:22:37 <sambo> Great, so something like observable uniqueness, good enough for me
22:23:48 <sambo> I'm building an Erlang style concurrency abstraction in Haskell and I was trying to implement an Eq instance for the addresses of the actors 
22:26:38 <Axman6> I assume you've seen distributed-process (nee cloud-haskell)?
22:27:17 <MarcelineVQ> I wonder why ThreadId's are 32bit, what if I want more than 4 billion threads during one ghc run and I'm still using thread 1 by that time :>
22:27:57 <Axman6> I'm surprised the IDs aren't just Ints
22:34:07 <MarcelineVQ> Axman6: they're uint32's
22:34:29 <Axman6> 4 billion threads should be enough for anyone!
22:34:33 <Axman6> :(
22:35:17 <MarcelineVQ> That is the case currently, especially when you're distributing like you can with the package you mentioned
22:36:29 <sambo> Axman6: yes! it is out of my own interest and it is only a local model. 
22:36:31 <MarcelineVQ> Since each unit would have its own 4 billion to gnosh
22:37:28 <Axman6> Now we can emulate 64-bit computere with a mere 4 billion computers!
22:39:14 <iqubic> I love inefficiency.
22:53:13 * hackage gi-handy 0.0.1 - libhandy bindings  https://hackage.haskell.org/package/gi-handy-0.0.1 (inaki)
23:42:20 <Nevoic> What does `f a` mean in a type annotation without any constraints? I understand conceptually it's some kind of wrapper, but is that the only thing I have to go off of?
23:43:02 <Axman6> do you have the rest of the type?
23:43:03 <ski> which type signature are you wondering about, specifically ?
23:43:21 <Nevoic> Yeah, I made a function: doubleGet :: (forall a. f a -> a) -> f x -> f y -> (x, y)
23:43:48 <Nevoic> Which is cool because of the `forall a f a -> a`, without that qualifier I couldn't use it to unwrap f x and fy into the tuple.
23:43:52 <ski> `f' is a type variable. it could become bound to `Maybe', e.g.
23:44:02 <Nevoic> Yeah, I understand conceptually what it could become.
23:44:05 <clever> or it could be bound to IO
23:44:07 <Nevoic> I use it with a list.
23:44:15 <Nevoic> And I know it works with other Monads.
23:44:17 <ski> or to `[]', or to `(->) Int'
23:44:23 <Nevoic> But what is it? XP
23:44:30 <ski> it's just a type variable
23:44:32 <Nevoic> a lot of times I see Functor f => stuff
23:44:32 <Axman6> not monads, things iwth kind * -> *
23:44:35 <Axman6> with*
23:44:37 <Nevoic> Ahh okay
23:44:46 <ski> what is `a' in `reverse :: [a] -> [a]' ?
23:44:52 <Nevoic> Is it a type variable just because it predicates a type?
23:44:53 <f-a> how does that work without a typeclass constraint?
23:45:03 <Nevoic> Like that's part of the semantics of Haskell?
23:45:10 <Nevoic> predicates wasn't the right word
23:45:14 <ski> f-a : no type class thingies needed, there
23:45:17 <Nevoic> precedes.
23:45:31 <sicklorkin> I'm looking for some ideas on a GUI library. I am using GoogleSheet for a UI at the moment. It works well for my situation and I'd like to contiue using it; however, it's come to the point there I need to stop thinking of the UI in terms of cell, and rows, but rather as HBox and VBox, and have the underlying code do the heavy lifting.  Can anyone think of a, ploymorphic? window/gui library that has an 
23:45:37 <sicklorkin> interface flexible enough to swap out the screen layout spcifiec with cells/rows..
23:45:47 <ski> Nevoic : `f' is a type function there'. so `x' and `y' are types (also type variables, in this case). feeding them to `f' will give you back types
23:45:49 <Nevoic> ski: `a` in that is a generic type.
23:45:53 <Axman6> that would also work with f ~ PRedicate where newtype Predicate a = Predicate (a -> Bool), as long as you could write a function of the type (Predicate a -> a) for all a's (you probably can't)
23:46:16 <ski> Nevoic : so `f' is also "generic", in that sense
23:46:18 <Nevoic> Yeah, I feel. I think that makes sense, thanks lads!
23:46:24 <Nevoic> The kind * -> * cleared it up for me.
23:46:27 <Nevoic> I think
23:46:28 <Axman6> Predicate is not a monad,  but it does have kind * -> *
23:46:33 <Nevoic> I'll play with it some more XD
23:46:43 <Nevoic> But I recently read a lengthyish blog post on kinds.
23:46:45 <Nevoic> So that helped.
23:46:51 <ski> Nevoic : `x' and `y' there have kind `*', while `f' has kind `* -> *', yes
23:46:59 <Nevoic> 👍
23:47:06 <ski> Nevoic : any type with kind that looks like `... -> ...' is a type function
23:47:16 <ski> Nevoic : any value with type that looks like `... -> ...' is a (value) function
23:47:21 <Nevoic> They construct new `*` by passing themselves into f.
23:48:09 <ski> well .. i suppose one would more commonly express it as `x' and `y' being ("passively") passed to `f'. not as ("actively") passing themselves to `f' ;)
23:50:44 <f-a> sicklorkin: were you looking for something like threepenny-gui?
23:52:41 <sicklorkin> f-a: i'm not sure what i'm looking for - just someting in existance otherwise i'm gonna write someting myself.
23:53:40 <sicklorkin> f-a: no that 3pence
23:54:42 <sicklorkin> I do a lot of timeseries analysis, and w/sheets i get that for free
23:57:48 <magthe> I'm looking for some further documentation/examples of using hedgehog's state machine functionality. So far I've looked at the registry example in the sources, and this (slightly outdated) example https://teh.id.au/posts/2017/07/15/state-machine-testing/index.html, and of course the docs. Would be grateful for pointers to more.
