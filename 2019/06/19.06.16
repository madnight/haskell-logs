00:11:01 <butterthebuddha> I've been trying to go through the CS240h slides
00:11:03 <butterthebuddha> (link: http://www.scs.stanford.edu/16wi-cs240h/)
00:11:16 <Arahael> What's a good guide to using a haskell pretty printer?
00:11:22 <butterthebuddha> but it's been a bit of a struggle because they are very terse
00:11:42 <butterthebuddha> Arahael: I've been very satisfied withhttps://hackage.haskell.org/package/prettyprinter
00:11:55 <Arahael> butterthebuddha: 
00:12:09 <butterthebuddha> What's a good intermedate-level Haskell book?
00:12:37 <butterthebuddha> I have a good understanding of what a monad is and how to use the abstraction in practice, but that's about it
00:12:54 <Arahael> butterthebuddha: That looks much better than pretty.
00:13:08 <erikd> i have a data type called `Index`, for which i have derived Bounded and Enum. is there a way to define something like a type class instance for each of the constructors on `Index`? do i need TypeFamilies here?
00:33:44 * hackage opaleye 0.6.7004.0 - An SQL-generating DSL targeting PostgreSQL  https://hackage.haskell.org/package/opaleye-0.6.7004.0 (tomjaguarpaw)
01:12:51 <f-a> I just wrote something like
01:12:53 <f-a> Just "prova" ^. to (fmap length) -- (Just "prova" comes from a . long . string . of . lenses)
01:13:39 <f-a> I suppose there is proper way of writing the `to (fmap...` part, but I cannot find it
01:14:01 <f-a> `mapped` works, but requires awkward & (especially when you are inside a section)
01:32:07 <Rods_Tiger> I'm going to try programming and I've been recommended haskell, I see on the web page there’s three things to download: Minimal installer; Stack; Haskell platform. It doesn’t tell me which one I should start with.
01:32:28 <f-a> Rods_Tiger: which tutorial are you following?
01:32:38 <Rods_Tiger> None.
01:32:47 <f-a> minimal should do for most of your needs
01:32:53 <Rods_Tiger> aha - thanks
01:33:05 <Rods_Tiger> btw, which tutorial is easy?
01:33:12 <f-a> I recommend https://www.seas.upenn.edu/~cis194/fall16/
01:33:17 <Rods_Tiger> thanks
01:36:40 <fendor_> Rods_Tiger, also pretty nice is, learn you a haskell for great good
01:37:10 <fendor_> http://learnyouahaskell.com/
01:37:15 <Rods_Tiger> I'll try that too, thanks.
01:37:50 <fendor_> that's someting you can read before going to bed ;D
01:39:27 <Rods_Tiger> I’m already very experienced in css, which is about all the programming I thought I’d ever need, so hopefully this is going to be just as understandable.
01:43:11 <fendor_> css is understandable? however, wish you best of fun!
01:43:44 <Rods_Tiger> yep, I spend all day doing CSS and SVG, I love it
01:44:41 <Rembane> Rods_Tiger: Do you hack SVg manually or do you have any tools that make your life easier?
01:51:22 <Rods_Tiger> Well, I draw out the initial art in Illustrator using my Wacom on the Mac, then export it as SVG, then basically rewrite it the way I want it to make it more efficient and slick, crafting it in a code editor. The drawing part is quick, the finessing is where most of it lives. For example, Illustrator is hopeless at giving nice human-meaningful class names, it wants to give everything a different class even though it could’ve be
01:52:26 <Rembane> Rods_Tiger: Sweet! 
01:54:11 <Rods_Tiger> The SVG animate element is declarative, that’s where a lot of power is (Illustrator knows nothing of that, I have to put it in myself)
01:54:33 <Rembane> ^^
01:54:43 <Rods_Tiger> similarly in CSS, there’s mostly declarative thinking
01:55:50 <Rembane> There is, there is indeed. 
01:57:47 <Rods_Tiger> ah, looked at the terminal on my Mac and forgot to press enter on the curl command. Now it works
01:58:44 * hackage Dist 0.4.2 - A Haskell library for probability distributions  https://hackage.haskell.org/package/Dist-0.4.2 (wyager)
02:02:54 <f-a> to better explain my previous question, the gist of it is "is there an already defined operator like this http://paste.debian.net/1088015/ ?"
02:29:44 * hackage Dist 0.5.0 - A Haskell library for probability distributions  https://hackage.haskell.org/package/Dist-0.5.0 (wyager)
02:32:02 <quchen> How do I download old versions of Stack? The usual link downloads the latest only – curl -L https://www.stackage.org/stack/linux-x86_64
02:32:16 <quchen> I tried some version suffixes but that doesn’t work
02:32:34 <quchen> (LTS-2 does not work with Stack 2 anymore)
02:42:22 <hexagoxel> f-a: dunno, but    a ^. to f = f a
02:42:50 <hexagoxel> which turns this into `vmap = to . fmap . view`
02:43:50 <f-a> thanks hexagoxel 
02:58:44 * hackage alist 0.1.1.7 - lists with O(1) append  https://hackage.haskell.org/package/alist-0.1.1.7 (AlanHawkins)
02:59:59 <quchen> Solved it!
03:00:00 <quchen> strace bash -c 'stack upgrade --binary-version 1.9.1' 2>&1 | grep http
03:00:47 <quchen> Actually the subshell isn’t necessary anymore, that’s command line fallout. Works though.
03:13:16 <Mrbuck> hi
03:14:42 <f-a> hello Mrbuck 
03:16:01 <Mrbuck> f-a:  hello whats up ?
03:17:48 <f-a> trying to write some haskell game, Mrbuck 
03:18:51 <Mrbuck> awesome f-a  good luck I am still noob
03:18:56 <Rembane> f-a: What kind of game? 
03:19:57 <f-a> Rembane: terminal based platformer
03:20:24 <f-a> http://ariis.it/static/stream/page.html#venzone this kind, Rembane 
03:20:24 <Mrbuck> f-a: can you make money by making tht game ?
03:20:29 <f-a> not really
03:20:32 <Mrbuck> just for fun ?
03:20:37 <f-a> yep
03:21:25 <Rembane> f-a: Sweet! :D
03:22:03 <Mrbuck> nice f-a 
03:23:37 <Mrbuck> I am actually looking for money making software ideas though I am such a noob as I badly need millions of money, anyway offtopic here :(
03:23:58 <sicklorkin> f-a: are you using ncurses?
03:24:35 <MarcelineVQ> on average the best money making idea in software continues to be work for someone else
03:25:03 <f-a> sicklorkin: nope, I wrote this https://hackage.haskell.org/package/ansi-terminal-game because I wanted it to be cross platform without any fuss
03:25:31 <f-a> I should really upload the new version
03:26:21 <Mrbuck> MarcelineVQ:  I may end of up with that if I have high school degree
03:27:19 <sicklorkin> degree's are overrated
03:27:28 <sicklorkin> s/'s/s/
03:29:36 <Mrbuck> sicklorkin:  right and i also lack high skills learning slowly
03:34:41 <Mrbuck> in haskell, are there single and double preecision for storing floats ?  and comparing floats allowed?
03:35:35 <sicklorkin> https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Float
03:36:37 <[exa]> %  [toRational (0.1::Float), toRational (0.1::Double)]
03:36:37 <yahb> [exa]: [13421773 % 134217728,3602879701896397 % 36028797018963968]
03:37:41 <[exa]> Mrbuck: ^, comparison is allowed (it's a defined operation) but you should remember floats are approximate
03:38:52 <Mrbuck> Alright [exa]  I am also checking the url sicklorkin had pointed
03:39:54 <__monty__> Mrbuck: If you don't need the performance of floats, Rational has more precision and less gotchas.
03:41:41 <Mrbuck> ok __monty__ thanks
03:52:33 <Mrbuck> I need free code https://leetcode.com/problems/two-sum   can i have haskell code for this please i just want to see 
03:52:58 <__monty__> Mrbuck: That's not gonna help you get a job...
03:53:57 <[exa]> everytime I see 'class Solution' a part of me dies
03:53:58 <Mrbuck> __monty__: I am not looking for a job
03:55:12 <[exa]> Mrbuck: start with getting the index of a single number that you're searching for
03:55:49 <[exa]> Mrbuck: btw people on #haskell generally prefer pushing you to do the exercise yourself instead of just giving you the solution
03:56:02 <__monty__> Mrbuck: leetcode is notorious for being a job-seeker's interview practice site. I'm sure there's solutions to be found all over the internet. If it's too hard for you to understand currently you should start with easier exercises. Codewars has some great haskell exercises at the higher levels, I'm sure their beginner exercises are equally good and will actually help you learn haskell.
03:57:34 <Mrbuck> __monty__:  I am not even practising those exercses i just want to see he solution like how many lines...how its done etc 
03:57:41 <Mrbuck> I will try it myself later
03:58:16 <__monty__> What do you expect to learn from this?
03:58:20 <[exa]> Mrbuck: I've got 1-line solution using list comprehension and 'zip [0..]'
03:59:32 <Mrbuck> [exa]:  nice thanks 
04:00:04 <Mrbuck> I heard haskell is poor for competitive programming so just want to check 
04:00:11 <Mrbuck> anyway its okay
04:00:16 <Rembane> Mrbuck: It's the best for competition programming! 
04:00:30 <__monty__> Depends on the kind of competition.
04:01:16 <Mrbuck> Rembane: I heard in reverse and many portals dont even support haskell too, I will change my opinion
04:01:50 <Rembane> Mrbuck: I'm just very, very opinionated. :)
04:02:44 <[exa]> Mrbuck: the question is whether competitive programming aligns with real-world aims (incl. money)
04:03:36 <__monty__> [exa]: It's fun for some, that's plenty of motivation.
04:04:06 <__monty__> Though haskell wouldn't be my first pick if compilation time's added to run time.
04:04:16 <sicklorkin>  let twoSum t = map snd . filter ((==t) . fst ) . map (sum &&& id) . subsequences
04:05:14 <Mrbuck> thanks sicklorkin  code 1 one and complicated enough for me to understand now but inspiring
04:05:38 <Mrbuck> [exa]: anything that doesnt help in real world is useless to me 
04:05:47 <[exa]> sicklorkin: +1 for educative style :]
04:06:04 <DigitalKiwi> Rembane: advent of code results say otherwise
04:06:25 <sicklorkin> Mrbuck: it's not the solution, but i've given you enough to think about
04:07:03 <[exa]> I usually get bored when I repeatedly spot the same primitive data structure or knuth-style algorithm in a long, very convoluted assignment; AoC is a prime example of that
04:08:16 <Mrbuck> ok sicklorkin 
04:08:45 <Rembane> DigitalKiwi: What do they say? 
04:12:04 <DigitalKiwi> the haskell group didn't win
04:13:03 <[exa]> DigitalKiwi: would you mind a link? I can't google the results
04:13:05 <__monty__> I still haven't finished AoC18 : /
04:13:49 <DigitalKiwi> https://adventofcode.com/2018/leaderboard
04:13:55 <[exa]> speaking of which, I would love to finally see some reasonable instance of vector analytics language like K, Q or R in haskell
04:14:23 <DigitalKiwi> glguy placed 64th i'm not sure if anyone else did better
04:14:32 <[exa]> most of AoC is really easily solved in K, given you can survive the syntax
04:14:32 <sicklorkin> looks outdated
04:15:32 * sicklorkin bonks his head on his desk
04:16:07 <Rembane> [exa]: Does Futhark count?
04:17:09 <DigitalKiwi> (glguy was #1 in the haskell leaderboard that was going)
04:18:18 <[exa]> Rembane: "in haskell" :] but yes, futhark gets close from the performance side
04:18:32 <[exa]> (to K, not to R :] )
04:18:36 <Rembane> [exa]: Sweet! :D
04:20:16 <__monty__> DigitalKiwi: I can't find any per-language stats, do they exist?
04:20:28 <Mrbuck> and one more dubious question, I think for successful startup or job just anguage alone isnt enough, I need to learn some technology also correct ?
04:20:32 <yoav_> Is there a built-in function to check if a list is of length 1? Similar to null.
04:20:55 <DigitalKiwi> __monty__: you can see some of the peoples github repos 
04:21:59 <Rembane> yoav_: Pattern match! f [_] = True 
04:22:29 <DigitalKiwi> there was a private leaderboard with a bunch of haskell users, glguy placed #1 in that leaderboard, he placed 64th overall, it's possible someone else scored better than that with haskell but was not on the private leaderboard
04:22:34 <yoav_> Rembane: I know I can build one myself easily, I wanted to know if there was a builtin that does it already
04:22:51 <jgt> yoav_: bear in mind that non-zero and exactly one are two very different things
04:23:02 <jgt> so I wouldn't expect there to be anything similar to null
04:23:21 <yoav_> I saw isSingleton on hoogle, but I have no idea how to import it. It's in GHC's Util.
04:23:48 <__monty__> yoav_: Then you probably don't want to use it. You'd depend on GHC as a library and that's a huge dependency.
04:24:03 <yoav_> ugh, fine. I'll build it myself.
04:24:47 <ski> > (1 :: Natural) == genericLength [0 ..]
04:24:49 <lambdabot>  False
04:25:08 <Ariakenom> DigitalKiwi: that just says the best didn't use it though
04:25:08 <lavalike> :t (&&) <$> (not . null) <*> (null . tail)
04:25:09 <lambdabot> [a] -> Bool
04:25:13 <[exa]> yoav_: you can expect that haskellers will generally push you to use patternmatching to extract the singleton element right away. isSingleton sounds like 'isJust', which is usually better avoided
04:25:39 <__monty__> How often do you use it that `(== 1) . length` or `\l -> case l of [_] -> True; _ -> False` isn't clear enough?
04:26:20 <__monty__> [exa]: There's arguments in favor of pattern-matching functions though. Take `maybe` for example.
04:27:03 <DigitalKiwi> Ariakenom: the claim is that haskell is the best for competitive programming.
04:27:35 <yoav_> __monty__: I used length until now but it's slower and triggered me so I wanted to go the other way
04:27:44 <lavalike> try mine too!
04:27:44 <DigitalKiwi> (potentiallY) 63 people showed that is wrong
04:28:13 <Ariakenom> I don't follow that train of thought at all.
04:28:25 <yoav_> lavalike: Oh wow, didn't notice that. Looks awesome!
04:28:30 <__monty__> DigitalKiwi: A single datapoint is a bad datum to extrapolate from.
04:28:37 <ski> > [p | [p] <- [[d | d <- [2 .. n],n `mod` d == 0] | n <- [2 ..]]]
04:28:40 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
04:28:49 <DigitalKiwi> i don't give a fuck about competitive programming stop making me defend this position i don't care
04:30:11 <__monty__> DigitalKiwi: If you're prepared to give critique you need to be able to take some too. Consider it dropped though.
04:30:35 <DigitalKiwi> w/e
04:31:06 <Ariakenom> i didn't mean to come on strong, I don't have any opinion on language strength. I was just critiquing the logic
04:34:27 <DigitalKiwi> and yes aoc is only one data point that's why it's not a serious critique and there's no way of knowing for sure that the 63 people that did better than glguy didn't use haskell...but if you look at the repos they use other stuff
04:35:12 <olligobber> which bot is it that rewrites lambdas using builtin methods?
04:35:37 <olligobber> :t cata
04:35:38 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
04:36:34 <olligobber> :exf \n f x -> cata (maybe x f) n
04:36:34 <exferenceBot> could not parse input type: ParseFailed (SrcLoc "inputtype.hs" 1 1) "Parse error: \\"
04:38:09 <olligobber> not that bot
04:38:31 <ski> @pl \n f x -> cata (maybe x f) n
04:38:31 <lambdabot> flip (flip . (cata .) . flip maybe)
04:39:12 <olligobber> that's icky
04:39:14 <olligobber> thanks ski
04:40:02 <ski> were you looking for something else ?
04:40:37 <ski> @type \n f x -> cata (maybe x f) n
04:40:39 <lambdabot> Mu Maybe -> (a -> a) -> a -> a
04:42:04 <ski> @type \(n :: forall a. (a -> a) -> a -> a) -> n (In . Just) (In Nothing)
04:42:05 <lambdabot> (forall a. (a -> a) -> a -> a) -> Mu Maybe
04:42:09 <olligobber> That's the function I wanted, I just thought there would be a nicer way to write it
04:43:38 <olligobber> and yeah, that's the inverse function of what I wanted
04:43:52 <ski> @type (. flip maybe) . (.) . flip cata
04:43:53 <lambdabot> Mu Maybe -> (b -> b) -> b -> b
04:44:20 <ski> (is what i get by hand-pointlessering it)
04:44:39 <olligobber> so many dots
04:46:03 <olligobber> I'll go with the lambda, it's more readable
04:46:58 * ski smiles
04:51:52 <olligobber> @info Mu
04:51:52 <lambdabot> Mu
04:52:06 <olligobber> @source Mu
04:52:06 <lambdabot> Unknown command, try @list
04:52:41 <ski> @src Mu
04:52:41 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
04:53:30 <ski> there is no `info' command
04:53:50 <olligobber> I'm curious why it's Mu and not Fix, like in the Data.Fix package
04:53:53 <ski> @info [() | let]
04:53:53 <lambdabot> let { } in [()]
04:54:44 <ski> i think this `Mu' is just something that was added to lambdabot at some point
04:54:54 <olligobber> fair
04:55:26 <ski> `Mu f' is `mu r. f r'. and the Church encoding of `mu r. ..r..' is `forall r. (f r -> r) -> r'
04:55:38 <yoav_> Which library/function can I use to "Stack" two images on top of each other? Not overlaying them, I want one above the other. They're the same resolution and everything.
04:56:01 <yoav_> I looked at HIP but didn't see anything like this, maybe I didn't look enough though.
04:56:02 <ski> er, is `forall r. (..r.. -> r) -> r', rather
04:56:14 <ski> hence you may see `Mu f' defined to be iso to `forall r. (f r -> r) -> r'
04:56:52 <ski> similarly, `Nu f' is `nu s. f s'. and the State encoding of `nu s. ..s..' is `exists s. s * (s -> ..s..)'
04:57:11 <olligobber> my brain melted
04:57:25 <ski> hence you may see `Nu f' defined to be iso to `exists r. (s,s -> f s)'
04:57:54 <olligobber> @src Nu
04:57:54 <lambdabot> Source not found. You type like i drive.
04:58:25 <ski> by `Mu Maybe' we only intend finite natural numbers. by `Mu (Maybe . (a,))', we only intend finite lists
04:58:49 <ski> with `Nu', we intend the corresponding infinite versions
04:58:53 <olligobber> Nu is the greatest fixed point, right?
04:58:56 <ski> yes
04:59:23 <olligobber> how would you write Nu as a haskell type?
04:59:51 <ski> as the `Mu' above, iow as `Fix' ?
05:00:04 <ski> or, in terms of the State encoding i sketched
05:00:41 <olligobber> like Data.Fix
05:01:01 <olligobber> I don't understand the state encoding
05:01:38 <ski> @type unfoldr
05:01:39 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
05:01:51 <ski> @type uncurry (flip unfoldr)
05:01:52 <lambdabot> (b, b -> Maybe (a, b)) -> [a]
05:02:14 <ski>   uncurry (flip unfoldr) :: forall a. forall b. (b,b -> Maybe (a,b)) -> [a]
05:02:27 <ski>   uncurry (flip unfoldr) :: forall a. (exists b. (b,b -> Maybe (a,b))) -> [a]
05:02:50 <ski>   uncurry (flip unfoldr) :: forall a. (nu b. Maybe (a,b)) -> [a]
05:03:08 <ski> `nu b. Maybe (a,b)' is a type of potentially finite streams of elements of type `a'
05:03:40 <ski> `b' here can be thought of as a seed, or state, which either generates a new element and a seed, or else terminates the stream
05:04:46 <olligobber> so `type Nu f b = (b, b -> f b)' ?
05:04:53 <sicklorkin> @type flip (maybe a m'a) (a -> b)
05:04:54 <lambdabot> error:
05:04:54 <lambdabot>     Pattern syntax in expression context: a -> b
05:05:03 <sicklorkin> @type flip (maybe a m'a) (f a)
05:05:05 <lambdabot> error:
05:05:05 <lambdabot>     • Couldn't match type ‘Expr’ with ‘b0 -> c’
05:05:05 <lambdabot>       Expected type: Maybe a -> b0 -> c
05:05:09 <ski> similarly, in `nu s. f s' being `exists s. s * (s -> f s)', think of `s' as being a hidden/internal object state type. so you have a current state `s', and a function that if you feed it the state, it will compute for you a "level" `f' (e.g. of a tree), with new states `s' as the "children", which you can go on applying the function to, to materialize more of the (possibly finite) tree
05:05:27 <ski> no, `type Nu f = exists b. (b,b -> f b)'
05:05:48 <olligobber> Haskell doesn't have existential types :(
05:06:13 <ski> Haskell (with extensions) can encode existential types (in two different ways, nonetheless)
05:06:50 <ski> anyway, `Nu f' here is *conceptually* `exists s. (s,s -> f s)', is what i'm saying
05:06:59 <olligobber> I'm curious if there's a nice category theory interpretation of this
05:07:19 <ski> universals are ends and existentials are coends
05:07:39 <ski> lookup dinatural transformations, wedges
05:10:18 <ski> (MacLane has a chapter, e.g.)
05:11:11 <olligobber> thanks
05:11:38 <olligobber> the notation on the wikipedia page of coends is...
05:12:07 <olligobber> I do not understand what the integral symbol is doing in category theory
05:12:17 <ski> @quote separation.of
05:12:17 <lambdabot> GuySteele says: Some people prefer not to commingle the functional, lambda-calculus part of a language with the parts that do side effects. It seems they believe in the separation of Church and
05:12:17 <lambdabot> state.
05:12:22 <ski> @quote church.and.state!
05:12:22 <lambdabot> shapr says: Haskell separates Church and state!
05:12:26 <ski> @quote are.dual
05:12:26 <lambdabot> ski says: I'd rather say that in Haskell, Church and State are dual
05:13:14 <olligobber> @quote sleep
05:13:14 <lambdabot> chessguy says: man, i don't know if i'm ready to have kids yet. i just had to rock my nephew to sleep, but it took me away from my AI programming!
05:13:24 <ski> i'm not sure if the use of the integral sign in ends and coends has any particularly deep meaning. i suspect they possibly used it, because it's a familiar variable-binding symbol ?
05:14:16 <ski> (well, i mean, existentials are like sums, and integrals are like infinite sums, so .. ? but that doesn't explain why coends use the same symbol, only with a different placement of the bound variable)
05:15:38 <ski> (er, sorry, why ends use the same symbol, i ought to have said)
05:15:41 <ski> @ghc
05:15:41 <lambdabot> All of the type variables in the constraint are already in scope (at least one must be universally quantified here)
05:16:18 <olligobber> oh, the diagram that the end is the equaliser of is the diagram of Pi S(c,c) and Pi S(c,c') with those morphisms
05:16:54 <olligobber> ok, it's just an equaliser
05:17:57 <olligobber> ok, nini
06:05:45 <lavalike> dOA
06:05:57 <lavalike> f
06:06:07 <lavalike> oops sorry my terminal was messed up
06:06:44 <lavalike> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--Wincomplete-uni-patterns I understand the first example with h being a lambda, what is the second example about?
06:09:00 <f-a> lavalike: guess, maybe a pattern-binding w/ a lone pattern 
06:13:36 <reygoch> How does one force Setup.hs to be rebuilt and rerun when executing "cabal new-build"? Right now I have to delete dist-new directory for it to accept new changes in Setup.hs.
06:29:51 <dmwit> reygoch: I'd report that as a bug.
06:30:02 <dmwit> cabal should just DTRT.
06:30:14 * hackage yesod-form 1.6.5 - Form handling support for Yesod Web Framework  https://hackage.haskell.org/package/yesod-form-1.6.5 (MichaelSnoyman)
06:30:17 <reygoch> dmwit: hm... I thought that might be the case
06:30:40 <reygoch> dmwit: do you perhaps have some experience with setup.hs stuff?
06:30:51 <dmwit> Some, but all with old-cabal.
06:30:58 <reygoch> dmwit: I'm having another weird problem with GCC command that is being generated
06:31:12 <reygoch> dmwit: https://pastebin.com/1eCn2Uka
06:31:17 <reygoch> This is my output
06:31:42 <reygoch> It can't find mysql.h file, but it's definitely in directory included on line 22
06:31:57 <reygoch> but setup is also generating something weird on line 24
06:32:15 * hackage yesod-auth 1.6.7, yesod-websockets 0.3.0.2 (MichaelSnoyman): https://qbin.io/agenda-poker-7z5i
06:33:16 <reygoch> I've added path to mysql.h dir to `includeDirs` field, I'm not sure if that was the right place then
06:33:18 <reygoch> https://hackage.haskell.org/package/Cabal-2.4.1.0/docs/Distribution-InstalledPackageInfo.html#v:includeDirs
06:38:08 <dmwit> Should be right. You don't need custom Setup.hs for that, though.
06:38:27 <dmwit> https://cabal.readthedocs.io/en/latest/developing-packages.html#pkg-field-include-dirs
06:39:12 <dmwit> You might want to ask again in #hackage where all the cabal devs hang out.
06:46:14 * hackage gl 0.9 - Complete OpenGL raw bindings  https://hackage.haskell.org/package/gl-0.9 (EdwardKmett)
07:02:16 <reygoch> dmwit: I do, because it's getting the input from mysql_config script. Damn, I just need to fix that thing and I'm done. This is frustrating :D
07:39:37 <breezykermo> exit
07:39:39 <breezykermo> exit
08:44:12 <mjrosenb> huh, well, this is a new failure mode.
08:44:48 <mjrosenb> https://gist.github.com/mjrosenb/922259dd3438ea11ee18117d3002ef51
08:45:03 <mjrosenb> the missing dependencies line looks blatantly wrong.
08:45:10 <mjrosenb> http://hackage.haskell.org/package/stringsearch
08:46:57 <mjrosenb> oh, maybe this has something to do with the base3 flag?
09:00:29 <mjrosenb> yeah... it looks like this is using base3 even though from what I can tell it should be defaulting to base4
09:00:48 <mjrosenb> does anyone know how to specify another build flag with callHackage?
09:11:05 <d34df00d> Hi!
09:12:24 <d34df00d> Let's say I want to work with some monadic stack (think MonadError ErrorType m, MonadLogger m as an example) in an IO action that's getting passed to a function that accepts, well, just IO actions.
09:12:27 <d34df00d> How do I do that?
09:13:21 <d34df00d> Or to be more specific, let's say I want to have something like `Database.PostgreSQL.Simple.withTransaction conn act`, where `withTransaction :: Connection -> IO a -> IO a`, but I want to use MonadError and MonadLogger methods in the `act`. How would I approach that?
09:27:20 <infinisil> d34df00d: You want this: https://hackage.haskell.org/package/unliftio
09:28:16 <infinisil> I think
09:28:40 <d34df00d> infinisil: IIRC it only works with stateless monads, doesn't it?
09:28:45 <d34df00d> So MonadError and friends are out.
09:29:09 <d34df00d> > Transformers with multiple exit points (e.g., ExceptT and its ilk)
09:29:10 <d34df00d> Yea
09:29:11 <lambdabot>  error:
09:29:11 <lambdabot>      A section must be enclosed in parentheses thus: (e . g .)error:
09:29:11 <lambdabot>      The operator ‘.’ [infixr 9] of a section
09:30:08 <infinisil> d34df00d: "This may sound restrictive, but this restriction is fully intentional. Trying to unlift actions in stateful monads leads to unpredictable behavior."
09:30:26 <infinisil> You sure you won't have such problems with withTransaction?
09:31:09 <d34df00d> Yeah, that kinda makes sense... And taking this specific example of postgres' withTransaction, how is it supposed to know if my action succeeded or failed (and whether it should commit or rollback) if I'm not throwing exceptions but just returning something either-ish in the underlying monad?
09:31:35 <d34df00d> Now I wonder how ugly would be wrapping withTransaction with catch and converting any exceptions into MonadError stuff.
09:32:42 <infinisil> d34df00d: Actually, would `MonadIO m => Connection -> m a -> m a` work?
09:33:02 <infinisil> I have a feeling it doesn't, but not sure
09:33:18 <d34df00d> infinisil: for withTransaction? Nope, it's quite monomorphic on IO
09:33:52 <infinisil> Ah right, MonadUnliftIO is really the thing needed here
09:34:33 <d34df00d> Uh, I guess I'll just write a wrapper around withTransaction that catches exceptions that I care about and converts them into something more monadic in some MonadError ErrorTy m.
09:34:43 <d34df00d> Dunno how well that scales though.
09:37:07 <ski> @messages-loud
09:37:07 <lambdabot> erisco said 7d 21h 4m 28s ago: Paths are profunctors. I know what the next problem is. Maybe you can help!
09:37:21 <hyperisco> s/profunctors/categories/
09:37:47 <hyperisco> but, yeah… well you seemed vaguely interested
09:38:04 * ski doesn't recall the conversation
09:38:16 <hyperisco> Yeah, was many moons ago now =\
09:38:36 <hyperisco> incremental/adaptive computation
09:39:08 <d34df00d> > It is almost always wrong to wrap an ExceptT, EitherT, or ErrorT around an IO-based transformer stack.
09:39:10 <lambdabot>  <hint>:1:45: error: parse error on input ‘,’
09:39:18 <d34df00d> Now I'm more convinced my original idea was bad.
09:39:24 <hyperisco> d34df00d, depends who you ask. I say: no.
09:40:28 <d34df00d> hyperisco: I'm thinking what should I do with some SQL-related code where I check certain invariants myself, and, in particular, what should I do if they are violated.
09:40:42 <d34df00d> throw in IO or throwError in some MonadError?
09:41:04 <d34df00d> The latter doesn't work particularly well so far since most of the functions I use (and that call my IO actions) are actually monomorphic on IO.
09:42:33 <d34df00d> Especially given that some of those library functions actually rely on exceptions to provide proper semantics (think transactions).
09:42:53 <hyperisco> Often errors are just a string that gets printed to a log. If that is all you're after, exceptions are fine.
09:44:52 <d34df00d> Likely yes. I'll just print them somewhere and later, when the Haskell part is over, set up some monitoring or something.
09:45:15 <d34df00d> Interesting how little I know about more real-world program design with Haskell...
09:48:32 <d34df00d> Yay Control.Exception.assert. Is it used in the wild?
09:48:45 <d34df00d> Especially for stuff like "check that the deleted columns count is equal to the expected one".
09:48:51 <d34df00d> Or s/columns/rows/
09:51:14 * hackage ribbit 0.1.0.0 - ribbit  https://hackage.haskell.org/package/ribbit-0.1.0.0 (taphu)
09:54:48 <sicklorkin> d34df00d: I use it
09:58:44 * hackage fortran-src 0.3.0 - Parser and anlyses for Fortran standards 66, 77, 90 and 95.  https://hackage.haskell.org/package/fortran-src-0.3.0 (mdanish)
10:56:43 <qwebirc45140> I tried to install on my mac and I got this
10:56:45 <qwebirc45140> To install and run GHC you need the following dependencies: Following commands are required, but missing, please install:  xz
10:57:39 <monochrom> I wonder if that is a new form of spam.
11:00:09 <lionrouge> hi !
11:00:26 <lionrouge> What are the best books ok haskell for experienced programmers?
11:00:32 <lionrouge> *on Haskell
11:04:04 <hyperisco> If you're not experienced in functional programming then any Haskell book should be fine
11:04:14 <hyperisco> If you're transitioning from, say, OCaml, I don't know.
11:05:52 <monochrom> If transitional from another function language, then "the gentle introduction" will do great :)
11:06:07 <monochrom> s/transitional/transitioning/
11:07:26 <geekosaur> even knowing FP helps less than you'd think: laziness changes a *lot*
11:07:26 <geekosaur> and I/O works very differently, although if you've played with e.g. purescript then you've already encountered it
11:08:47 <monochrom> I would use "experienced programmer" to deduce: Freedom from insisting on a book that opens with walking you through "how do I install Haskell? wth is ghci?"
11:09:04 * ski looks at lionrouge
11:09:09 <hyperisco> Skip to chapter 2? :P
11:19:47 <lionrouge> geekosaur, Clojure and Python have laziness, it's not a unique concept now. And I believe they copied it from Haskell (at least I'm sure about Python)
11:20:51 <hyperisco> When "there exists" arguments collide!
11:22:53 <hc> Python has lazyness?
11:23:07 <hc> Didn't know that. Have to look it up now. :-)
11:23:09 <d34df00d> Types are checked lazily.
11:23:28 <hc> hahaha :_)
11:23:33 <hc> good one.
11:24:20 <[exa]> you mean the one type?
11:24:56 <hyperisco> So obviously if you want nonstrict semantics you just encode your program as Python types.
11:25:55 <hyperisco> Computing by type error… I'd be morbidly fascinated to see it. I know pattern matching has been done this way.
11:26:21 <hyperisco> (Insofar as type errors are catchable exceptions)
11:26:57 <monochrom> Python has lazily-checked type-level HList!
11:28:23 <geekosaur> this does not sound relevant tbh. laziness is pervasive and you really need to program differently in its presence
11:28:38 <geekosaur> "we got some laziness hidden somewhere" is not the same thing
11:28:58 <geekosaur> I mean, any language can encode laziness (at worst, as a function taking a dummy parameter)
11:29:31 <hyperisco> Assuming functions are values…
11:30:18 <geekosaur> conversely, turn on -XStrict and watch the Prelude — not to say other Haskell code — stop working
11:33:29 <ski> lionrouge : "have laziness" in which sense ?
11:33:51 <ski> (an encoding doesn't count)
11:38:29 <hyperisco> ski, remember that a path can locate any position in an ADT value?
11:41:19 <d34df00d> Uh, I'm having trouble with transformers.
11:42:05 <d34df00d> Uh, I'm even having trouble with just formulating the question.
11:42:14 <hyperisco> Can Optimus Prime help?
11:42:21 <d34df00d> Is he a Reader?
11:43:11 <hyperisco> He tries to be, but evil forces him to act on the world.
11:43:18 <d34df00d> RWS then.
11:43:24 <d34df00d> Alright, that's too much.
11:45:09 <Welkin> did you try gundams?
11:48:01 <d34df00d> Ok, I guess too many functions are monomorphic on the monad they're living in while they could be abstracted over it.
11:50:47 <d34df00d> So, can I do better than `env <- ask; someMonomorphicFunction $ flip runReaderT env subAction`?
11:52:03 <cocreature> d34df00d: what is the type of someMonomorphicFunction and what is the type of subAction?
11:52:46 <d34df00d> someMonomorphicFunction :: SqlMonad m => Pg a -> m a
11:53:19 <d34df00d> type SqlMonad m = (MonadReader Env m, ...)
11:53:42 <d34df00d> subAction :: (MonadReader Env m, MonadBeam Postgres m) => m ()
11:53:49 <d34df00d> Pg is an instance of MonadBeam Postgres m
11:53:52 <lionrouge> ski, Python map, filter, range functions generate lazy sequences
11:54:15 <d34df00d> There's also instance MonadBeam be m => MonadBeam be (ReaderT r m), but I don't know if I could leverage that.
11:54:16 <lionrouge> you can create your own arbitrary lazy generators
11:55:25 <lionrouge> even modern approach to asynchronous programming in Python came out from those lazy generators
11:55:25 <ski> it doesn't count, unless you can get non-strict evaluation by default, in some fragment of the language
11:55:40 <d34df00d> C++ is lazy! We have std::function now!
11:55:49 <lionrouge> ski, what do you mean by "non-strict evaluation" ?
11:55:50 <d34df00d> And iterators.
11:56:21 * ski slaps d34df00d around with a functor object :)
11:56:25 <nisstyre> d34df00d: if you have the ability to create thunks, then you can do laziness
11:56:31 <nisstyre> it's all a measure of ease from there
11:56:55 <d34df00d> I can create thunks in C.
11:57:15 <d34df00d> I don't know any language that wouldn't allow that.
11:57:24 <ski> lionrouge : e.g. you should be able to call a function, and (sometimes) not have an argument expression in that call be evaluated. wrapping the argument expression in some way to delay it is not allowed
11:57:43 <cocreature> d34df00d: given those types your code looks quite reasonable. I wouldn’t try to simplify it further
11:58:41 <ski> nisstyre : s/do/encode/ :)
11:58:52 <lionrouge> ski, in Python it's possible
11:59:09 <ski> (don't get me wrong. being able to encode it is great. but it's not the same thing as having it natively)
11:59:12 <d34df00d> cocreature: thanks! I just feel a bit strange when I find myself executing ask just to run a reader with the same context, or executing a MonadError just to liftEither it again.
11:59:47 <nisstyre> ski: yeah good point
12:00:03 <cocreature> d34df00d: yeah sometimes you have to do some plumbing in particular if parts of the code have a fixed monad stack, e.g. someMonomorphicFunction in your example.
12:00:38 <ski> lionrouge : do you have to annotate the function, in order to support that ? e.g. if i want to call `f(1/0)', and not have the division-by-zero happen, do i have to e.g. declare `f' in some particular way ?
12:01:07 <lionrouge> ski, it doesn't work on such a high-resolution level as arithmetic operations
12:01:18 <lionrouge> I will give an example
12:01:38 <ski> lionrouge : ok. so it sounds to me like there's, perhaps, some limited support then
12:06:13 <lionrouge> ski, https://dpaste.de/JXv3
12:06:45 <lionrouge> and I believe that all this stuff was inspired by Haskell. From it Python got list comprehensions, laziness and other things
12:09:50 <ski> lionrouge : ok, i thought you were maybe talking about something else than generators
12:10:16 <ski> e.g., how would you express lazy traversal of game state trees in Python ?
12:10:37 <lionrouge> game state trees?
12:10:54 <ski> (generators only cover the *sequence* case, whereas trees are branching)
12:11:33 <ski> take e.g. Chess positions. you conceptually build a tree, nodes being the positions, edges being moves, alternating between white and black
12:11:41 <lionrouge> you can create complex generators with function syntax that uses yield instead of return
12:11:52 <lionrouge> which I have first in my example
12:12:06 <ski> you don't want to materialize more of the search tree, when planning which is the best course of action, than necessary
12:12:38 <ski> however, you'd still want to separate the code that generates the tree, from the code that traverses it, for modularity and maintainability reasons
12:13:04 <ski> the problem with `yield' is that it only gives you a linearly ordered sequence of values
12:13:22 <lionrouge> I see what you mean: yield gives you 1 value at a time
12:13:33 <ski> what if you want to leave it up to the user/caller, which branch to further investigate next, depending on the values they've seen, so far ?
12:15:39 <lionrouge> in case of chess this tree is the tree of possible moves, right?
12:16:22 <lionrouge> so you need a lazy sequence which gives you all next possible moves for every previous move?
12:17:13 <lionrouge> and you need a separate piece of code to walk through it voluntarily?
12:17:53 <ski> separate, yes
12:18:15 <lavalike> what happened to this https://downloads.haskell.org/~ghc/latest/docs/html/users_guide
12:18:27 <lavalike> "Error 503 Backend is unhealthy"
12:18:31 <lionrouge> if all possible moves for one previous position are stored in memory (I suppose there are not more than hundred) would you consider it lazy?
12:18:41 <lionrouge> *one and only one
12:19:33 <ski> hm, iirc, the following paper mentions the game tree example
12:19:35 <ski> @where whyfp
12:19:35 <lambdabot> "Why Functional Programming Matters" by John Hughes in 1984 at <http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html>
12:20:04 <lionrouge> I like John Hughes a lot :) His talks are why I'm here asking about books on Haskell
12:20:19 <ski> it's a nice paper
12:20:33 <ski> Hughes is a pleasant fellow, as well
12:21:32 <lionrouge> If you permit storing one set of possible moves in memory I believe it's possible in Python
12:22:31 <ski> lavalike : perhaps you could ask in #haskell-infrastructure ?
12:22:46 <lavalike> ski: didn't know about that, alright
12:24:18 <ski> lionrouge : "... would you consider it lazy?" -- the important point here is the depth of the tree. i don't really care much if the sibling children are in a lazy list or not
12:25:22 <ski> lionrouge : anyway. i learned from "Haskell: The Craft of Functional Programming"
12:26:26 <ski> (and i started programming BASIC around age 6.5, next language being assembler, so i must be "mentally mutilated beyond hope of regeneration", i suppose)
12:26:37 <ski> @quote mutilated
12:26:37 <lambdabot> Dijkstra says: "It is practically impossible to teach good programming style to students that have had prior exposure to BASIC: as potential programmers they are mentally mutilated beyond hope of
12:26:37 <lambdabot> regeneration."
12:26:54 <ski> you could also try
12:26:58 <ski> @where PIH
12:26:58 <lambdabot> "Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
12:27:04 <lionrouge> QBasic was my first language too :) Next was C89. Then Python. Then Lua, Go, Clojure
12:27:24 <lionrouge> thanks for the link
12:27:24 <ski> @where SOE
12:27:24 <lambdabot> "The Haskell School of Expression: Learning Functional Programming through Multimedia" by Paul Hudak in 2000 at <http://www.cs.yale.edu/homes/hudak/SOE/>,<http://haskell.org/soe/> [broken]
12:27:36 <ski> @where HR
12:27:36 <lambdabot> "The Haskell Road to Logic, Maths and Programming", by Kees Doets,Jan van Eijck, at <http://homepages.cwi.nl/~jve/HR/>
12:27:39 <ski> @where wikibook
12:27:39 <lambdabot> http://en.wikibooks.org/wiki/Haskell
12:28:03 <ski> @where HTAC
12:28:03 <lambdabot> "Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
12:29:18 <ski> lionrouge : next i had (a little) Prolog, then "C/C++" (the course muddled them up, for me), then Java,Haskell,Prolog (properly),Scheme,SML,&c.
12:30:37 <lionrouge> are there any things which Haskell has and LISP languages doesn't except type system?
12:30:56 <ski> lionrouge : well, QBasic at least had functions. BASIC v2.0 only had `GOSUB' (no parameters, no local variables) (unless you could `DEF FNXX', which could only be used with expressions, so was nearly useless)
12:31:41 <lionrouge> my QBasic was in middle school and not seriously but it was "second birth" - I saw the world of possibilities and realized I like it
12:31:45 <lavalike> brings back memories of reading a QBasic book at an age close to the one you mentioned, trying to figure out what functions were to no avail
12:31:58 <dolio> Does Dijkstra have a quote about Turing machines?
12:32:01 <ski> Lisps typically use strict evaluation, rather than non-strict, and also tend to allow (to various degrees) side-effects
12:32:14 <lionrouge> not Clojure
12:32:26 <lionrouge> it's immutable by default
12:32:50 <lionrouge> and workaround is very explicit
12:32:59 <ski> (s/unless you could/unless you count/)
12:33:43 <lionrouge> and a lot of (maybe even most) Clojure functions that return a sequence do it lazily
12:33:53 <lionrouge> I would say they do it whenever it's possible
12:34:13 * ski should probably look at Clojure, some time
12:34:22 <ski> dolio : i dunno
12:34:52 <ski> i think Dijkstra did write something on Lisp, though
12:35:43 <dolio> I guess no one really writes in Turing machines outside of tiny examples in university courses.
12:35:44 * ski . o O ( <http://kazimirmajorinc.com/Documents/Edsger-W-Dijkstra-on-Lisp/index.html> )
12:35:54 <lionrouge> considering types in Clojure there is `spec` - it's a library which allows for type annotation (it's more like schema than ine/double/uint). BTW: Clojure can into structural equality.
12:36:17 <dolio> So they don't have the same effect as BASIC.
12:36:22 <lionrouge> and there are type annotation for JVM which sometimes greatly improve performance but you become stick to JVM types
12:38:19 <lionrouge> and there is a good talk by Rich Hickey (creator of Clojure) called "Maybe not" (on Youtube) where he talks about this `spec` library and how he did a greta mistake by adding nil (the billion dollar mistakes), criticize Maybe types a bit and overall a great talk
12:38:26 <lionrouge> *sorry for fanboying
12:39:37 * ski hopes lionrouge realizes how `Maybe'/`option' is different from `null'/`nil'
12:40:18 <lionrouge> this spec package is still alpha and under heavy development and this talk was his answer to community's impatience about release date when he said that it will be ready when he[Rich] figures out how to properly do this nil/Maybe/some other way thing
12:40:30 <lionrouge> ski, yes I do
12:42:27 <lionrouge> nil and Maybe are both ways to answer the question about what you get when you get nothing
12:42:33 <hyperisco> Maybe doesn't infect every ref type like null does. Great! However, in many places it still exists, there is little (if any) semantic regard for it, and so still feels like null.
12:42:36 <lionrouge> drastically different answers
12:42:54 <ski> lionrouge : perhaps you'd like to check out Riastradh's blag "Option types, optional parameters" in 2006-02-03 at <https://mumble.net/~campbell/blag.txt>,<http://vrici.lojban.org/~cowan/blag.xml>
12:43:50 <lionrouge> Maybe is like Heisenberg uncertainty principle :)
12:44:10 <lionrouge> Schrödinger's cat :)
12:45:41 <hyperisco> Good design is often trying to get rid of Maybe. That's what I feel.
12:46:44 <lionrouge> I totally agree. But maybe every program that works on human data from real world like names, time, locations, etc. will be full of Maybe types.
12:47:21 <Berengal> is there no groupBy equivalent for Seqs?
12:48:05 <hyperisco> Yes and no… you can't get rid of it entirely. For example, there are more character strings than ISO639p1 languages.
12:48:59 <hyperisco> However, once you figure out a particular string is an ISO639p1 language, you can continue on with that knowledge. You're not forever having to rediscover the fact.
12:50:05 <hyperisco> What I mean is: there is a map  (ISO639p1 -> x) -> String -> Maybe x
12:51:28 <ski> using Yoneda's lemma, i see
12:51:33 <hyperisco> What you do forget, though, is that that particular string is an ISO639p1 language
12:51:54 <ski> @where boolean-blindness
12:51:54 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
12:52:20 <hyperisco> And hopefully that isn't important. Another example is Map and lookup. Once you have an element out you can keep it around, but you immediately lose the fact that that element is in the Map!
12:52:42 <hyperisco> And so in practice you're typically rediscovering many times that a particular element is in a Map.
12:53:02 <hyperisco> Yeah, it is the same phenomenon.
12:53:19 * ski . o O ( dependent dynamic programming )
12:56:44 <orzo_> Anyone know the secret to adding values to a GI.Gtk.Objects.ListStore.ListStore ?  I thought I struck gold when i found an examples repository, but https://github.com/haskell-gi/gi-gtk-examples/issues/5 
12:56:50 <hyperisco> Rather than being concerned about particular key value pairs, you can use Map operations such as union and intersection. These do not involve Maybe.
12:57:19 <hyperisco> A good design will lean in that direction where possible, in my opinion.
12:58:43 <hyperisco> You know, similar with lists. They're more of a pain when you have to worry about nonemptiness than when you do not.
12:59:16 <hyperisco> So, learn towards ways of using lists which are indifferent in that regard.
12:59:18 <hyperisco> lean*
12:59:43 <hyperisco> take 1  instead of  head, for example.
13:29:18 <isovector1> are there any tricks for hiding a constraint synonym's definition from `:t`?
13:29:53 <isovector1> i tried `type Foo a = Foo' a`, and then not exporting `Foo'`, but `:t` don't care
13:30:13 <isovector1> the `class Foo' a => Foo a; instance Foo' a => Foo a` trick doesn't seem to work either
13:30:36 <geekosaur> I don't think there's any way to do that
13:31:11 <isovector1> not with that attitude. type family maybe?
13:34:32 <isovector1> not even type families :'(
13:35:50 <solonarv> closed type family with no equations and solve it with a typechecker plugin :P
13:36:04 <ski> restricted type synonyms would be nice, in GHC
13:36:12 <ski> (extension in Hugs)
13:38:27 <isovector1> think this is a bug? that `:t` will show you things that aren't exported?
13:39:48 <glguy> No, it's expected that it will show you things that aren't exported
13:40:34 <isovector1> "expected" sure, but breaks the exporting abstraction
13:41:35 <hpc> what else would you expect to happen? it to just not know the types of things if you hide them?
13:44:39 <orzo_> isovector1: i think maybe you want ExistentialQuantificaiton
13:45:10 <glguy> isovector1: type synonyms aren't expect to provide any abstraction at all
13:46:06 * ski . o O ( ML )
13:46:27 <orzo_> i don't even like type synonyms for documentation purposes.  They're only kosher for brevity purposes
13:46:55 <orzo_> it's annoying when library authors add a lot of "helpful" indirection
13:47:01 <arpand> Adding `-Wall` to `OPTIONS_GHC` doesn't warn about unused vars when loading from ghci. Does anyone know why this happens?
13:48:10 <glguy> arpand: Do you have an export list?
13:48:13 <isovector1> orzo_: i don't think this falls under that umbrella. i want to pack some custom errors into the tysyn, but it's used exclusively as a constraint
13:48:52 <isovector1> orzo_: type Member e r = (Find r e, e ~ IndexOf r (Found r e), Break (AmbiguousSend r e) (IndexOf r (Found r e)))
13:49:40 <isovector1> each of these pieces is an implementation detail, but there's no way to hide them afaict
13:50:22 <isovector1> the user facing API is _just_ `Member`. none of that stuff is exported anywhere: https://hackage.haskell.org/package/polysemy-0.4.0.0/docs/Polysemy-Internal-Union.html#t:Member
13:50:49 <arpand> glguy: no, right now i'm exporting everything. ghc still warns me about it
13:51:00 <isovector1> i'm happy hiding the details some other way, but afaik there _are no other ways_
13:51:59 <orzo_> instance (Find r e, e ~ IndexOf r (Found r e), Break (AmbiguousSend r e) (IndexOf r (Found r e))) => Member e r -- with various language pragmas
13:52:19 <isovector1> doesn't work. ghc helpfully expands it
13:52:54 <orzo_> i'm saying make a class Member e r, and then declare that all-encompassing instance.  Ghc expands it somehow?
13:54:08 <isovector1> yes.
13:54:46 <orzo_> you mean in error messages it says one of the hidden constraints is missing?
13:55:07 <isovector1> no, i mean `:t` will still tell you `(Find r e, e ~ IndexOf r (Found r e), Break (AmbiguousSend r e) (IndexOf r (Found r e))`
13:55:36 <nshepperd_> Make that instance and also another overlapping instance for some particular type
13:55:50 <isovector1> that's an interesting idea
13:56:11 <nshepperd_> That way it can't expand until the type is known
13:58:42 <isovector1> don't think it works. the `Find` stuff needs to be part of the superclass constraint in order to be usable. but that means any instances you give need to also satisfy the superclass constraint
13:58:57 <isovector1> which means either 1) they overlap perfectly and ghc will inline it, or 2) they don't overlap perfectly and then the type error is thrown
13:59:51 <nshepperd_> I'm not sure what you mean by that
14:00:39 <isovector1> well if you have two instances: that are marked `OVERLAPPING` but don't actually differ in their implementations, ghc won't actually emit the overlapping one
14:00:46 <isovector1> because it's the same same
14:01:14 * hackage stripe-concepts 1.0.1.0 - Types for the Stripe API  https://hackage.haskell.org/package/stripe-concepts-1.0.1.0 (chris_martin)
14:01:15 <isovector1> so the only way to give an instance for this thing that isn't exactly the same is to break the invariant in the superclass constraint
14:01:19 <orzo_> what if you add a constraint to the contrived instance
14:01:20 <nshepperd_> Really? That seems magical
14:01:47 <isovector1> it's true!
14:02:13 <nshepperd_> How does ghc know they don't differ in their implementation
14:03:39 <isovector1> okay well tbh i am not sure this is true for classes, but it is definitely true for tyfams
14:03:53 <isovector1> but it's the only explanation i can think of for why it's inlining my type
14:04:17 <isovector1> https://kcsongor.github.io/report-stuck-families/ grep for "agree" here if you want to learn more
14:06:39 <isovector1> no constraint i can come up with helps differentiate the instances
14:09:32 <grt4299[m]> Hi, I would like to create an application that runs executables, is it something that the prelude can do? If not, is there any packages I can use?
14:11:02 <hpc> take a look at System.Process
14:11:28 <grt4299[m]> thank you, hpc
14:16:00 <nshepperd> oh, isovector left
14:16:20 <nshepperd> jeez, people can't wait ten minutes
14:16:51 <nshepperd> anyway the answer is 'Third method' here https://dpaste.de/rRns#L10,14
14:32:09 <ascheriTTikfes> Question: Does Haskell handle web scraping as well?
14:34:17 <d34df00d> ascheriTTikfes: I've found dom-selector to be quite usable for some of my scarping tasks.
14:35:26 <ascheriTTikfes> d34df00d, thanks. I'll check it out. Though, essentially what I'll need to do is scrap the info and save to possible csv (or some other format?)
14:35:52 <d34df00d> cassava's great for writing csvs! Or aeson is great for writing jsons.
14:35:58 <ascheriTTikfes> Repeating the process across different tabs where the URL of the page doesn't necessarily change with a new tab but what is rendered changes.
14:36:03 <d34df00d> You just define your data type and it does the rest.
14:36:19 <d34df00d> Oh, that sounds more complicated since it implies there is some JS there.
14:36:25 <d34df00d> That's way beyond my knowledge.
14:36:38 <solonarv> ah, so actually you want a browser automation thingy, not just html scraping
14:36:39 <Rembane> ascheriTTikfes: What's a tab in this context?
14:36:44 <ascheriTTikfes> Correct
14:37:07 <solonarv> I don't think there's anything in native haskell, but IIRC there are bindings to selenium and maybe to smething else too
14:37:11 <ascheriTTikfes> A JS selector that changes the information readily visible on the page without changing the url
14:37:24 <ascheriTTikfes> Rembane*
14:37:30 <Rembane> ascheriTTikfes: Got it.
14:39:06 <duncan> http-conduit has a thing which lets us describe sessions, taht might be useful
14:40:46 <duncan> That appears to be `http-conduit-browser`
14:44:53 <ascheriTTikfes> duncan, Hm. I was trying to see if I could do it without needing a browser. I suppose that's not possible because of the JS?
14:46:29 <sjhfeke> An actual Haskell task from one of the former exams: "Consider a data type representing trees of any branching: data Rose a = Rose a [Rose a]
14:46:31 <sjhfeke> Define functions:
14:46:57 <sjhfeke> toList :: Rose a -> [a] --prefix order
14:47:11 <duncan> ascheriTTikfes: As far as I understand, it's less of a 'browser' as we nderstand something like Firefox... from the description: "This package creates a monad representing things that browsers do, letting you elegantly describe a browsing session. "
14:47:32 <sjhfeke> fromList :: [a] -> Rose a -- toList . fromList = id
14:47:43 <duncan> I think it might be worth a look. The http-client library is quite good, after all.
14:47:46 <sjhfeke> I don't understand? How can fromList be implemented?
14:47:54 <sjhfeke> There is ambiguity here
14:48:06 * hyperisco tries to remember what a prefix order is
14:48:35 <sjhfeke> Eg toList $ Rose 5 [Rose 3 [], Rose 2 []] would produce [5, 3, 2] if I understand correctly
14:49:00 <sjhfeke> but toList $ Rose 5 [ Rose 3 [Rose 2 []]] would also produce [5, 3, 2] if I understand correctly
14:49:01 <ascheriTTikfes> duncan, okay, thank you verymuch. I'll check it out.
14:49:45 <hyperisco> Okay, so it is left to right, top to bottom, assuming root is at the top?
14:49:58 <hyperisco> breadth first?
14:50:35 <sjhfeke> so it would look like a tree cannot be recovered from  a list of nodes in the prefix order
14:51:00 <hyperisco> I know breadth first, depth first, preorder, inorder, postorder… not sure what "prefix order" is
14:51:48 <lavalike> it probably implies some constraint that makes the problem solvable
14:52:32 <hyperisco> oh okay, like a prefix expression
14:53:00 <hyperisco> so that's the same as preorder
14:54:54 <hyperisco> it is only possible if you also know the number of branches, which you would for arithmetic expressions or some such
14:55:44 <hyperisco> the  fromList . toList = id  side
14:55:53 <hyperisco> but they're just asking for  toList . fromList = id  right?
14:56:38 <sjhfeke> they're asking to implement fromList in such a way that toList . fromList = id
14:56:48 <hyperisco> but not the other way too?
14:57:55 <sjhfeke> Doesn't seem so; but to me it seems that the other way would be solvable, not this one
14:57:58 <hyperisco> all that direction depends on is that you construct the tree such that toList will bring it back to a list in the same order
14:58:24 <hyperisco> (is "direction" the right word here? I dunno)
14:58:44 <sjhfeke> wait, you're right
14:59:27 <orzo_> I'm having a really hard time just trying to populate a listbox (gtk tree view) using gi-gtk.  I have strings and bools and I want labels and checkboxes.  Anyone want to take pity on me and help me locate a helpful resource or doc or example that shows how this is done?
14:59:29 <sjhfeke> I'm too tired apparently
14:59:34 <sjhfeke> thank you hyperisco 
14:59:46 <hyperisco> have fun!
15:00:03 <orzo_> i'm on day two of this, what i thought would be trivial, task
15:02:54 <hyperisco> if I could have one superpower orzo_ I may have to choose the ability to make accurate time estimates
15:05:29 <hyperisco> I don't know what to do between "it is ready when it is ready" and "what is done by time T is what it will be"
15:05:33 <fendor> my chosen superpower would be, that I dont feel like I have to vomit when doing sports 3 hours after I ate a burrito
15:06:09 <hyperisco> oddly specific, but a respectable choice
15:06:51 <fendor> I can generalise it, probably
15:07:00 <hyperisco> I guess I have to insist on one of those two variants of time constraints more fervently.
15:08:27 <hyperisco> Becoming exhausted of plucking random time durations out of thin air and not matching them even closely.
15:12:12 <hyperisco> Surely I'm not the only one miserably incapable of adequately answering "how long do you need?"
15:12:57 <hyperisco> it isn't like I'm screwing in lightbulbs, where I can say I've done it a few times before
15:13:38 <Rembane> hyperisco: I don't have a clue neither.
15:15:46 <d34df00d> My best example so far is when I estimated task A as requiring two weeks of solid work and task B as taking a couple of days, and done A the next day and spent a month on B.
15:16:37 <hyperisco> it is stressing me out, because I'm setting up expectations I can't hold
15:18:28 <jackdk> hyperisco: welcome to literally the entire industry. you're in good company :S
15:21:32 <hyperisco> If the F-35 can go years and billions over budget then I suppose I can take some extra time here and there.
15:21:48 <hpc> i say that every time i open steam instead of vim
15:21:53 <hyperisco> lol
15:33:14 * hackage hw-packed-vector 0.1.0.0 - Packed Vector  https://hackage.haskell.org/package/hw-packed-vector-0.1.0.0 (haskellworks)
15:34:12 <solonarv> hpc: :! steam
15:36:37 <solonarv> oh, I've got it! launch vim via steam!
15:44:44 * hackage hw-packed-vector 0.2.0.0 - Packed Vector  https://hackage.haskell.org/package/hw-packed-vector-0.2.0.0 (haskellworks)
16:59:21 <edwardk>  
17:05:53 <Axman6> oh no, edwardk's transcended human language completely now D:
17:07:59 <edwardk> 01110111 01101000 01100001 01110100 00100000 01100100 01101111 00100000 01111001 01101111 01110101 00100000 01101101 01100101 01100001 01101110 00101100 00100000 01100001 01111000 01101101 01100001 01101110 00111111
17:10:26 <Axman6> I think he's attempting to remember the old tongue
17:10:43 <hpc> https://www.youtube.com/watch?v=CTjolEUj00g
17:11:21 <Axman6> hpc: <3
17:11:55 <hpc> he could also be trying to travel back in time - https://www.youtube.com/watch?v=0Whn0YzNG4s
17:12:57 <hpc> fun fact: there's a point in that movie where fry reads the code through a mirror
17:13:18 <hpc> so they had to come up with a code that was palindromatic in the way they wrote it out
17:13:36 <hpc> so it's the numbers 1 through 6 in order, then flipped
17:13:40 <hpc> 001100
17:13:43 <hpc> 010010
17:13:45 <hpc> etc
17:14:53 <hpc> -- | i for one can't wait until he starts writing like this
17:16:28 <nshepperd_> -- | i have no questions, only comments
17:19:06 <edwardk> i now have codex building with ghc 8.8 holy ow that was painfuk
17:19:11 <edwardk> er painful
17:19:25 <Axman6> =)
17:20:01 * ski thinks that sounds pain***
17:26:14 * hackage markov-realization 0.1.0 - Realizations of Markov chains.  https://hackage.haskell.org/package/markov-realization-0.1.0 (alexloomis)
18:11:31 <trevortknguyen[m> I recently got Pierce's Types and Programming Languages. Does anyone have any advice for self-studying this text?
18:11:32 <trevortknguyen[m> I'm considering just reading it through and skipping all of the exercises, but I don't know if that would be unwise. I just finished proof-based linear algebra as a first-year undergrad, so I've got some exposure to proving things, but I still find it daunting.
18:11:33 <trevortknguyen[m> I'm interested in TaPL because I'd like to do research and write an undergrad thesis in PL.
18:22:11 <amalloy> trevortknguyen[m: several of the exercises are marked as Recommended. it seems reasonable to recommend you try them
18:30:40 <trevortknguyen[m> <amalloy "trevortknguyen: several of the e"> Oh you're right. I should have noticed that.
18:35:52 <YellowOnion> Where can I find documentation for RTS option "-i" i.e the reschedule time.
18:40:04 <Axman6> probably the ghc manual
18:41:30 <YellowOnion> Wait looks like the documentation for Control.Concurrent is incorrect. which explains why I can't find any info on it.
18:42:19 <Lycurgus> you mean stale relative to actual current code?
18:42:22 <YellowOnion> "The rescheduling timer runs on a 20ms granularity by default, but this may be altered using the -i<n> RTS option"
18:42:37 <YellowOnion> "-i<sec>  Time between heap profile samples (seconds, default: 0.1)"
18:43:48 <YellowOnion> The actual option is -C
18:44:08 <Axman6> time for a PR
18:46:38 <YellowOnion> don't have a trac account.
18:49:03 <jackdk> time for a trac account
18:49:20 <Axman6> isn't it on gitlab now?
18:50:59 <MarcelineVQ> it is
18:51:27 <dmj`> Has anyone written an IsBool class that is the analog of Num, but for Bool values. So we could have `newtype MyFlag = MyFlag Bool deriving (IsBool)`, so when specifying just foo :: MyFlag; foo = True, it would be  valid
18:51:30 <MarcelineVQ> the rts flags are indeed hard to locate specifially in the docs, spread over multiple pages
18:53:22 <YellowOnion> +RTS --help is probably the most reliable way of finding them, I just wasn't at my computer at the time to try it.
18:53:57 <ski> dmj` : what would the operations and laws be ?
18:54:29 <MarcelineVQ> YellowOnion: the flags are pretty hard to find in the docs, being spread over multiple pages. +RTS -?
18:54:42 <MarcelineVQ> dmj`: Is this step one in a design to broaden the places you can use if?
18:55:51 <YellowOnion> Though trying to control RTS so my realtime app makes correct calculations is probably the wrong way of doing it...
18:57:16 <dmj`> ski: good question, I'm not sure, I just want to be able to get away with specifying only True/False if I newtype a Bool. Hopefully something extremely trivial. There's coerce I suppose, but just feels wrong.
18:57:54 <YellowOnion> I think I can just measure the actual delay/latency for more correct measurements, instead assuming threadDelay isn't stalled for too much longer than required.
19:02:21 <YellowOnion> I also don't think I need 60~hz timer...
19:27:17 <dmj`> ski: what if there was getBool :: a -> Bool, not :: a -> Bool, and :: a -> a -> Bool, where not = not . getBool, and x y = getBool x && getBool y, from these many others could be derived. Then you can just deriving IsBool via Bool on the newtypes
19:28:25 <dmj`>  \x -> Prelude.not (not (getBool x)) == getBool x
19:28:49 <dmj`> should always be true I assume
19:29:17 <dmj`> starting to looks like Bits though
19:31:32 * ski doesn't see how these operations would be useful in such a type class
19:33:46 <dmj`> It's less-so about the usefulness of the operations and moreso about the syntactic sugar. Granted, the laws would have to be correct
19:34:05 <dmj`> but being able to do `foo :: Flag; foo = True` would be very nice
19:34:17 <dmj`> without adding a newtype constructor
19:34:54 <dmj`> or performing manual coercion
19:37:08 <ski> how about `foo = fromBool True' ?
19:37:27 <ski> or perhaps that's the "manual coercion" you mentioned
19:37:35 <ski> how about `foo = true', then ?
19:42:39 <dmj`> ski: fromBool is close, I'd need to preserve the fact it's a byte. This library I'm working on represents arrays of floats, doubles, and bools. Making a Num instance for an array puts a single scalar value into the array, same with Fractional. Would be nice to specify "True" and be able to represent a singleton bit vector.
19:43:08 <dmj`> which is impetus for the IsBool class :)
19:44:00 <dmj`> A lot of matrix operations also return their results as a scalar Bool value in an array, so comparisons would be much nicer as well
19:45:14 * hackage extensible-effects-concurrent 0.26.1 - Message passing concurrency as extensible-effect  https://hackage.haskell.org/package/extensible-effects-concurrent-0.26.1 (SvenHeyll)
19:50:13 <dmj`> ski: for representing strongly typed boolean flags, it could be useful
19:58:44 * hackage language-javascript 0.6.0.13 - Parser for JavaScript  https://hackage.haskell.org/package/language-javascript-0.6.0.13 (ErikDeCastroLopo)
20:09:20 <YellowOnion> Text.Printf outputs a string, is there a version for the Text type?
20:17:09 <dmj`> YellowOnion: probably not, but you could just call pack on it
20:51:29 <dmwit> dmj`: https://hackage.haskell.org/package/Boolean-0.2.4/docs/Data-Boolean.html#t:Boolean and https://hackage.haskell.org/package/ersatz-0.4.7/docs/Ersatz-Bit.html#t:Boolean look relevant
20:51:50 <mjrosenb> Is there a way to have two different configurations of a single cabal file lying around?
20:52:04 <mjrosenb> I want some targets to be built with ghcjs and some with ghc.
20:54:29 <dmwit> In gtk2hs, we have two files named gtk.cabal.2 and gtk.cabal.3 and a script which links gtk.cabal to the appropriate one before running cabal.
20:55:20 <dmwit> You could maybe also use impl() conditionals.
20:55:32 <dmwit> (I assume ghcjs is a different impl than ghc.)
20:55:48 <mjrosenb> interesting.  I have a single cabal file that detects which compiler it is being run with and marks each target as buildable or not based on that
20:55:53 <dmj`> dmwit: ah very nice, thanks. foo :: Boolean b => b; foo = true could definitely work
20:56:01 <dmwit> mjrosenb: That way seems pretty reasonable to me.
20:56:11 <mjrosenb> but to get ghcjs, I need to run cabal new-configure --ghcjs
20:56:26 <mjrosenb> which I believe makes the other target not buildable.
20:56:35 <dmwit> Anything you pass to new-configure can also be passed to new-build directly.
20:57:20 <mjrosenb> oh, innnnteresting.
20:57:42 <mjrosenb> I do belive this will work then.
22:02:50 <YellowOnion> how do I get "stack build" to also copy over certain files (like data required for the app to run) on success?
22:05:55 <c_wraith> are the files listed in the cabal file?
22:10:45 <YellowOnion> c_wraith, I'm using package.yaml, and no because I don't know how to...which is why I'm asking.
22:12:30 <YellowOnion> I have an html file I want to copy in to the same folder with the exe.
22:18:04 <dmj`> @package file-embed
22:18:04 <lambdabot> http://hackage.haskell.org/package/file-embed
22:18:12 <dmwit> YellowOnion: https://cabal.readthedocs.io/en/latest/developing-packages.html#pkg-field-data-files
22:18:29 <dmj`> YellowOnion: derp, ignore me :)
22:19:58 <YellowOnion> dmj`, that's one solution but not in my case.
22:22:23 <YellowOnion> dmwit, can I used that with package.yaml?
22:24:50 <YellowOnion> oh yeah I okay so it is kinda working, but it's putting it in a really weird location.
22:25:51 <YellowOnion> it's put it in: share\x86_64-windows-ghc-8.6.5\MouseSpeeed-0.1.0.0
22:38:06 <YellowOnion> Why is this so hard, I just want the html file next to the exe file...
23:14:14 * hackage unboxing-vector 0.1.0.0 - Newtype-friendly Unboxed Vectors  https://hackage.haskell.org/package/unboxing-vector-0.1.0.0 (aratamizuki)
23:16:44 * hackage sensu-run 0.7.0 - A tool to send command execution results to Sensu  https://hackage.haskell.org/package/sensu-run-0.7.0 (MitsutoshiAoe)
23:34:30 <infinisil> This looks pretty neat: https://github.com/well-typed/optics
23:34:51 <infinisil> docs here: https://rybczak.net/files/optics/optics-0.1-docs/Optics.html
23:42:06 <juri_> how do i declare a newtype, type, or data such that i can pass it a string, and have it use two specified constructors on it? the inside constructor is a newtype, but the outside constructor is an argebraic data.
23:42:15 <slack1256> That docs serve also as a introduction to optics in general
23:43:43 <infinisil> slack1256: Yeah, and I think it's explained pretty well. Better than the lens docs I'd say..
23:43:54 <slack1256> juri_: Could you explain what are you trying to do? maybe showing some code? I didn't understand what you said
23:43:59 <juri_> EG, i need 'SVar "a"' to be the equivilent of 'Var (Symbol "a")' , but i have 'data Expr=Var' and 'newtype Symbol = Symbol String'
23:44:15 * infinisil takes a look at the lens docs to confirm
23:44:26 <juri_> er. 'data Expr=Var Symbol'.
23:44:29 <Axman6> juri_: sounds like pattern synonyms to me
23:44:44 <slack1256> infinisil: yeah, although as I already know the lens library, that affects my impression of the docs
23:45:04 <slack1256> juri_: smart constructors?
23:45:33 <infinisil> After reading the optics docs, I feel like lens sacrificed a lot just to be able to use `.` for composition
23:45:46 <infinisil> I'm no lens expert though, so not sure
23:45:50 <juri_> slack1256: yeah, i was considering a function, but that felt wrong.
23:46:11 <Axman6> pattern SVar s = Var (Symbol s)
23:46:47 <juri_> Axman6: thanks. :)
23:46:49 <slack1256> There is also the path of defining a pattern-synonim between `SVar "a"` and `Var (Symbol "a")` as Axman6 suggests
23:46:50 * juri_ reads up.
23:46:51 <Axman6> this is pretty much exactly the usecase these were added to GHC for
