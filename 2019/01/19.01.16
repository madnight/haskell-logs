00:03:57 * hackage nanomsg-haskell 0.2.4 - Bindings to the nanomsg library  http://hackage.haskell.org/package/nanomsg-haskell-0.2.4 (IvarNymoen)
02:23:00 <lightandlight[m]> The situation doesn't improve with 8.6.2 or cabal 2.4.1
02:26:55 <maerwald> Confused why you are using 8.6.2 and not 8.6.3 xD
02:44:40 <Arahael> With megaparsec, can I "insert" more text at the current location in the input stream?
02:44:55 <Arahael> (Say, to allow for #include "foo.h" directives)
02:44:58 <merijn> Arahael: What would that even mean?
02:45:22 <merijn> Arahael: Why not just have a parser return the results of foo.h?
02:45:23 <Arahael> merijn: Ie, parse a file as per normal, but if you get an include statement, load THAT file, insert it into the stream, and then continue from there.
02:45:58 <merijn> Arahael: How is that different from just returning the result of parsing foo.h as a result of parsing the include?
02:46:23 <Arahael> merijn: Because parsing the results of foo.h implies that foo.h is syntactically valid on it's own.
02:46:37 <merijn> Arahael: Why would it not be?
02:47:11 <Arahael> merijn: Consider something like: class Foo { #include "foo.h" }
02:49:11 <Arahael> merijn: Remember, it's a dumb text preprocessor.
02:49:14 <merijn> Arahael: If you wanna allow that you need a sorta pre-processing stage, the first resolves all those
02:49:50 <Arahael> merijn: Hmm.  Not actually a bad idea...  That would very much simplify things.
02:56:50 <Arahael> Thanks for the ideas, actually thinking about this further, I'm going to try and look at your first suggestion - to "just" have a parser return the results of foo.h.  (Delphi is the languaeg I'm parsing, and they have a few restrictions in include statements that might actually allow it)
03:59:40 <typetetris> If I have a convoluted type `data T a`, for which I can derive a generic instance, how was the function called to turn a function `a -> b` into `T a -> T b` ?
04:00:49 <merijn> typetetris: You mean fmap?
04:03:32 <bo> Guys, did anyone read 'Lambda the ultimate' research papers? I'm curious to read some theory around functional programming and don't know where to start, can someone point me in a right direction?
04:03:37 <typetetris> merijn: I condensed the example too much, actually I have `data T a b c d` and four functions `A -> A'` and so on and want `T A B C D -> T A' B' C' D'`. But I remember the paper now, it was scrap your boilerplate, I will simply reread it.
04:04:15 <merijn> bo: Depends, what kinda stuff are you interested in?
04:04:36 <Lycurgus> bo, why not do some research and find out what the next actual big thing, FP was tight like 15 ya
04:04:40 <merijn> bo: Math? Implementing functional languages? Neat/elegant functional solutions? etc.
04:04:47 <Lycurgus> *big thing is
04:05:34 <bo> merijn, you made me ask myself questions to which i have no clear answers :) Please, disregard, will find out what I'm interested in and will then come back with more specific request
04:05:43 <Lycurgus> and it was new like 2 human generations ago
04:06:00 <Lycurgus> c. 5 programmer generations
04:06:28 <merijn> bo: Types and Programming Languages is a pretty good book. Introduces the basics (and intermediates...) of type theory and how you'd implement your own type system/type checker, including working code examples
04:06:51 <bo> Thanks!
04:06:57 <merijn> @where tapl
04:06:57 <lambdabot> "Types and Programming Languages" by Benjamin C. Pierce in 2002-02-01 at <https://www.cis.upenn.edu/~bcpierce/tapl/>
04:07:26 <merijn> bo: There's also Software Foundations (co-written by Pierce) which is a book series on "how to reason and prove things about programs"
04:07:29 <merijn> @where sf
04:07:30 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,SjÃ¶berg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages",
04:07:30 <lambdabot> "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof assistant."
04:07:45 <merijn> (Software Foundations is also freely available online)
04:17:48 <ventonegro> In the same vein: https://plfa.github.io/
04:23:25 <zalazalaza[m]> Hey guys , Iâ€™m thinking about taking up Haskell just unsure what I would use it for. Can anybody give some examples of its use?
04:24:16 <merijn> zalazalaza[m]: Eh, anything you'd use any other language for?
04:24:18 <mreh> zalazalaza[m] web services
04:24:24 <mreh> yeah :)
04:26:36 <jollygood2> zalazalaza[m], it is a general purpose programming language. perhaps a better question would be, for what kind of programs is haskell better than other languages
04:26:51 <merijn> jollygood2: You mean "most of them"? ;)
04:26:57 <jollygood2> yes :)
04:27:23 <tdammers> anything except tight realtime and running on constrained hardware like embedded systems or GPU
04:27:44 <merijn> tdammers: Hey, even for the host side GPU code it'd be great :p
04:28:03 <tdammers> merijn: oh yes, sure - I mean the part that actually runs on the GPU
04:29:17 <tdammers> also, given the state of the OpenGL ecosystem, I'd implement the graphics side of things in C++ if I were to make anything in that area
04:29:48 <tdammers> that, or find bindings for a nice high-level-ish library
04:30:37 <Rembane> zalazalaza[m]: I write compilers and interpreters in Haskell. It's great fun.
04:30:57 <dingke> Well, I'm curious how to use stack properly. The dependency management is quite frustrating, maybe because i'm spoiled by nodejs and rust. I was toying with Spock, yet I couldn't even followed through the tutorial because stack just refuses to build. I know there must be a solution, but it's too much a pain to me.
04:31:50 <merijn> dingke: Refuses to build with what message?
04:32:38 <dingke> a bunch of 'hashable must match >=1.2, but the stack configuration has no specified version  (latest matching version is 1.2.7.0)' error
04:33:05 <dingke> I tried using a different resolver that works with ghc-8.0.1, which is the version that is supposed to be supported by Spock
04:34:06 <dingke> I think I need to learn how to use stack and cabal more :)
04:34:25 <dingke> I really like Haskell, and it's killing me that I can even build a web server
04:34:30 <jollygood2> and what happened when you tried that?
04:34:32 <dingke> *can't
04:34:40 <dingke> still the same errors 
04:36:00 <merijn> dingke: Stack's fundamental workflow is that you use (curated) snapshots of packages that work together. Of course if something is not in those snapshots (like seems to be the case here) then things don't work. You can tell it to include packages outside of the snapshot, but I dunno how, because I don't use stack :)
04:36:43 <jollygood2> by adding them to extra-deps in the stack.yaml file
04:36:59 <dingke> yeah, I did realize that Spock isn't in stackage
04:37:23 <dingke> but its tutorial still recommend using stack
04:37:33 <dingke> i've tried that, adding extra-deps
04:38:16 <dingke> also, the error message is confusing to me. Isn't 1.2.7.0 >= 1.2 ? How come there is a no match?
04:38:46 <zalazalaza[m]> Wow, awesome response you guys are great! Thx
04:39:26 <merijn> dingke: I'm guessing you didn't tell it to use the external package and it's just helpfully saying "1.2.7 is the newest one I know about (that you haven't told me to use yet)"
04:42:08 <dingke> haha, i'll try reading the stack documentation again, thx for the help everyone
04:44:58 * hackage typed-process 0.2.4.0 - Run external processes, with strong typing of streams  http://hackage.haskell.org/package/typed-process-0.2.4.0 (MichaelSnoyman)
04:50:53 <mpickering> merijn: Did that bindist work for you the other day?
04:51:21 <merijn> mpickering: The GHC bindist did, but I couldn't actually get the new haddock to work, so it was for nothing :p
04:51:35 <mpickering> that's a positive. 
04:51:48 <mpickering> Do you have nix installed? 
04:52:02 <merijn> Or, at least, ghci started and ran which I count as working :p
04:52:11 <merijn> No, I've been avoiding Nix so far
04:52:33 <mpickering> ok I needed someone on osx to test some pure nix devastation that I'm about to unleash
04:52:36 <mpickering> too bas
04:52:38 <mpickering> *bad
04:55:08 <typetetris> Are there well known alternatives (with papers) to the "Trees that grow" approach?
05:06:14 <dibblego> classy lens/prism
05:11:57 <Putonlalla> Tagless final, to an extent, typetetris.
05:13:01 <phadej> data types a la carte ~somewhat
05:17:04 <__monty__> mpickering: Depending on how much work it is I may be able to test.
05:20:38 <Bish> what exactly is "init" on https://wiki.haskell.org/Implement_a_chat_server
05:20:45 <Bish> search for: fmap init
05:20:52 <Bish> can't see it being explained
05:20:57 <Bish> im guessing it comes from Chan?
05:21:13 <merijn> :t init
05:21:15 <lambdabot> [a] -> [a]
05:21:19 <merijn> Data.List, I think
05:21:24 <merijn> :t init [1..10]
05:21:25 <lambdabot> (Enum a, Num a) => [a]
05:21:27 <merijn> eh
05:21:28 <Bish> oh wait, what does it do
05:21:31 <merijn> > init [1..10]
05:21:32 <lambdabot>  [1,2,3,4,5,6,7,8,9]
05:21:51 <merijn> Looks like a ghetto version of stripping the newline
05:21:58 <mpickering> __monty__: See in #ghc
05:22:24 <Bish> merijn: yeah that's super good
05:22:28 <jollygood2> > init []
05:22:30 <lambdabot>  *Exception: Prelude.init: empty list
05:22:34 <Bish> is it basicially reverse tail reverse ?
05:23:00 <c_wraith> except a lot more efficient
05:23:01 <Solonarv> Correct
05:23:53 <Bish> that's a super stupid name
05:24:08 <moet> head, tail .. init, last
05:24:12 <moet> :t last
05:24:13 <lambdabot> [a] -> a
05:25:10 <jollygood2> don't forget inits and tails
05:25:14 <jollygood2> > inits [1..5]
05:25:17 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
05:25:26 <Bish> oh wow that is actually useful
05:25:32 <jollygood2> > tails [1..5]
05:25:34 <lambdabot>  [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
05:27:02 <Bish> spawnings thread just to read from sockets and then putting them into a channel
05:27:05 <Bish> #justhaskellthings
05:27:22 <v0d1ch> uncons [1..5]
05:27:32 <v0d1ch> how do I evaluate it ?
05:27:46 <v0d1ch> > uncons [1..5]
05:27:48 <lambdabot>  Just (1,[2,3,4,5])
05:27:53 <v0d1ch> ah like that
05:27:57 <moet> threads are runtime not os, typically, so spawning a thread is just a matter of creating some C structs in the runtime thread (ie. it's lightweight)
05:28:29 <Bish> yeah i got that
05:28:38 <Bish> i suppose a programming language tutorial wouldn't do it that way if it wasn't green threads
05:30:29 <Solonarv> Well, this is why the GHC runtime has green threads - they're bloody useful!
05:30:53 <Bish> uhm, do people use threads without IO ever?
05:30:57 <Bish> is that "par"?
05:31:09 <c_wraith> that depends on how you define "threads"
05:31:19 <c_wraith> ie, there are terminological nitpicks one can make
05:31:31 <c_wraith> like "threads are for concurrency, not parallelism"
05:31:35 <Bish> well, if i have a deterministic function calculating things. i dunno, mergeSort
05:31:47 <Bish> (does that example work? i don't know)
05:31:58 <Bish> can i do that without forkIO
05:31:59 <c_wraith> A top-down mergesort can be done in parallel, sure.
05:32:06 <c_wraith> Bottom-up is a lot harder
05:32:24 <c_wraith> You can do parallelism without forkIO
05:32:31 <c_wraith> but it's questionable to call that "threads"
05:32:32 <merijn> Bish: There is the ParallelStrategies library which uses GHC's spark infrastructure to do pure parallelism
05:32:54 <moet> also known as data parallelism
05:33:02 <Bish> but there is none built in? i remember reading something about seq and it's pendant "par"?
05:33:05 <Bish> not sure
05:33:26 <merijn> Bish: GHC has a bunch of stuff builtin, that library is just a human/user friendly interface over it
05:34:02 <Solonarv> @hackage parallel -- I think this is the library you mean?
05:34:02 <lambdabot> http://hackage.haskell.org/package/parallel -- I think this is the library you mean?
05:34:46 <merijn> Bish: Keep in mind that not all Haskell (well, theoretically anyway) is GHC. Libraries like STM and parallel abstract over GHC's (non-haskell) internals and provide a "portable" Haskell API
05:36:08 <Bish> merijn: yeah well, i doubt there will be a meaningful haskell implementation aside ghc any time soon
05:36:26 <Bish> and is STM pure?
05:36:39 <merijn> Bish: Define meaningful? UHC is a complete Haskell2010 implementation, afaik
05:36:54 <Bish> as fast?
05:36:54 <merijn> It doesn't support all GHC's extension though, no.
05:36:56 <c_wraith> Bish: what does it mean for a type to be pure?  purity is a property of functions.
05:37:00 <Bish> and complete?
05:37:08 <Bish> c_wraith: does it only use pure functions
05:37:17 <merijn> Bish: Everything is pure (well, barring unsafeX)
05:37:19 <tdammers> a type doesn't use functions
05:37:27 <Bish> i am not talking about the type im talking about the "technique"
05:37:51 <moet> Bish: most of STM results in `STM a` and to run one of those and get an `a` you need to do an IO action
05:37:52 <Ariakenom> :t atomically
05:37:53 <lambdabot> error: Variable not in scope: atomically
05:37:59 <c_wraith> Bish: The thing is, it's perfectly correct to say "functions that return IO actions are pure"
05:38:01 <Ariakenom> grumble
05:38:03 <Bish> i mean, are there tricks used to get this working, how does the stm(the technique) notice something happened in another "thread"
05:38:12 <Bish> c_wraith: i know all that
05:38:26 <c_wraith> Bish: then...  obviously functions that return STM actions are pure.
05:38:46 <Ariakenom> :t Control.Concurrent.STM.atomically
05:38:47 <lambdabot> GHC.Conc.Sync.STM a -> IO a
05:39:04 <Ariakenom> wait this reads nicer
05:39:07 <Ferdirand> is there something like Either a Void -> a in the standard lib ?
05:39:09 <Ariakenom> % :t atomically
05:39:09 <yahb> Ariakenom: STM a -> IO a
05:39:21 <merijn> Ferdirand: "either id absurd"
05:39:40 <Ferdirand> merijn: ah well, short enough, thanks
05:39:56 <merijn> Ferdirand: You can always define a short name yourself if you need it a lot
05:40:07 <c_wraith> Bish: STM is built on top of implicit mutation, yes.  I think that's what you are asking.  But really, precision in terminology isn't just a pedantic thing.  It aids thinking.
05:40:13 <Bish> uhh uhc compiles to js/a vm in js
05:40:17 <moet> :t absurd
05:40:18 <lambdabot> Void -> a
05:40:28 <Ariakenom> Bish: the execution of a transaction is in IO so there is no impurity
05:40:32 <Ferdirand> merijn: sure, i just wanted to be sure i wouldn't be redefining something already existing
05:40:35 <jollygood2> :i absurd
05:40:37 <Bish> c_wraith: yeah, but i am not as fluent
05:40:48 <Bish> c_wraith: what is implicit mutation?
05:40:49 <c_wraith> Bish: ghcjs compiles to js, too!
05:41:09 <Bish> c_wraith: without following extensions: someList and huge runtime
05:41:14 <Bish> didn't like it much
05:41:44 <Solonarv> implicit mutation = mutation "behind the scenes"
05:41:47 <merijn> moet: absurd is just "proof by contradiction" 
05:41:48 <c_wraith> Bish: Mutating values that isn't called out explicitly.  In the case of STM, it does a lot of bookkeeping for whether particular refs are used or dirty in particular transactions and so on
05:41:54 <__monty__> Ghcjs is incompatible with extensions? Aren't you thinking about eta?
05:41:54 <tdammers> you could say that the STM modules provide pure functions that construct STM actions, which represent transactional mutable memory operations, as well as pure functions that turn STM actions into IO actions; those IO actions represent impure programs which will manipulate memory transactionally
05:42:32 <Bish> __monty__: templatehaskell 
05:42:36 <moet> where is absurd defined? also jollygood2 
05:42:47 <Ferdirand> subsidiary question that i was about to ask but i just found the answer myself
05:42:54 <merijn> moet: Data.Void
05:42:55 <moet> merijn: i come from a programming background, not a proofy background
05:42:57 * hackage potoki-core 2.3.4 - Low-level components of "potoki"  http://hackage.haskell.org/package/potoki-core-2.3.4 (NikitaVolkov)
05:43:02 <moet> merijn: ah ty
05:43:12 <Bish> uhc looks cool, thanks for sharing
05:43:32 * Bish has not understood what implicit mutation is
05:43:41 <merijn> moet: Void has no constructors, so the only value of type Void is bottom.
05:43:43 <Ferdirand> my actual type is Either a (Void, b) -> either id (absurd . fst)
05:43:49 <Ferdirand> yuck but oh well
05:44:06 <merijn> moet: "I'll promise to give you anything you want if you give me something which can't exist"
05:44:35 <merijn> moet: Obviously you can never give me a Void, so I'll never have to *actually* give you that value you want
05:44:57 * hackage potoki 2.1.4 - Simple streaming in IO  http://hackage.haskell.org/package/potoki-2.1.4 (NikitaVolkov)
05:45:20 <moet> merijn: how would you use it in practice? seems like a tool for making hairy types into simpler types, given that you know certain things are impossible
05:45:39 <merijn> moet: Well, Ferdirand's example is pretty illustrative
05:45:58 <c_wraith> moet: it's mostly about indicating that particular states that a type supports in a more general context aren't valid in this specific context
05:46:01 <merijn> moet: Void is generally used to indicate (for example) infinite recursion
05:46:13 <Ariakenom> :t forever
05:46:14 <lambdabot> Applicative f => f a -> f b
05:46:29 <Ariakenom> b could be Void there
05:47:15 <merijn> moet: But sometimes you need to compose things like "Either a Void" and get the 'a' (since the Void indicates Right could never happen), so you need to somehow make GHC happy with the Right case, despite knowing it can't happen
05:47:38 <Ariakenom> :t forever :: IO a -> IO Void
05:47:39 <lambdabot> IO a -> IO Void
05:47:43 <tdammers> a nice usage of Void I've encountered is in the context of reactive UI libraries, where you have components that can react to messages. The general component type is polymorphic over, among other things, a message type, and using totality checks, you can make sure all possible messages that the component can receive are actually dealt with. But some components don't accept any messages at all, so you use
05:47:45 <c_wraith> moet: https://hackage.haskell.org/package/conduit-1.3.1/docs/Data-Conduit.html#t:Sink  It's deprecated, but it's an example of a type using Void to indicate "there will never be anything useful here.  It doesn't even make sense to think about."
05:47:45 <tdammers> Void for the message type
05:48:42 <Ferdirand> moet: i'm writing a little lib for multiplayer text games. The game logic is written using a long monad stack that includes an ExceptT for signaling the end of the game (win or loss)
05:49:03 <moet> tmsc[m]: i wrote a library like that recently, but i just had the user provide a message type and made that a type index in my reactive-tree type...
05:49:27 <Ferdirand> i'm requiring that the complete game type uses Void as the monad return type, so that it is guaranteed that it terminates with a win or a loss (or doesn't terminate)
05:49:30 <moet> i'm a little confused where using void would come in for the messag etypes
05:50:29 <moet> huh... this doesn't make sense to me at all.. can you recommend some libraries for me to read through? that's how i usually pick up new types
05:50:48 <c_wraith> moet: well, there are still plenty of places in conduit where it uses Void
05:51:03 <tdammers> moet: I've encountered this in Halogen, which is a purescript thing, but the language is similar enough to Haskell that you should be able to understand the idea
05:51:33 <Ariakenom> moet: example, an X can accept messages of type "a" from a "Channel a". If an X doesn't accept any messages a=Void and you pass a Channel Void. Nobody can send anything to Channel Void.
05:51:46 <tdammers> moet: to simplify it a little, suppose you have data Component state msg = Component { handleMessage :: msg -> state -> state }
05:52:04 <tdammers> moet: but if your component doesn't accept any messages, which type do you put for msg?
05:52:18 <tdammers> moet: you need a type that isn't inhabited by any values (handwaiving bottom)
05:52:23 <tdammers> moet: Void is that type
05:53:03 <tdammers> moet: but how do you write a function Void -> state -> state? that function doesn't make sense, it cannot possibly be called, because there are no values that you could put in a Void
05:53:16 <c_wraith> moet: https://twanvl.nl/blog/haskell/conduits-vs-pipes  despite the title, it's actually a post about how using Void can simplify APIs.  (It also is quite old, predating conduit's choice to use Void)
05:54:26 <moet> ah those examples make sense.
05:54:28 <moet> i'll read the post, thanks
05:54:31 <tdammers> moet: you could of course say something like handleMessage = const id, and it'd typecheck, but it would be a bit of a lie, because the const suggests that you can actually call it - personally I think writing handleMessage = absurd is more elegant, it captures exactly that calling handleMessage would be an absurd thing to do
05:56:29 <moet> my reactive library has types like `data Tree action = ComponentWhichProducesData (Int -> action) | ComponentWhichDoesntProduceData action` and when evaluating the tree to return the actions to the user code, i return `action`
05:57:03 <moet> so i didn't need to use something like `Void`
05:57:13 <moet> but it sounds more flexible than my approach; thanks for explaining it
05:57:34 <tdammers> right, yes
05:58:01 <tdammers> your approach works too, but it ties the user into just the two choices, Int messages and no messages at all
05:59:49 <moet> well the user type could be `data Action = AgeInput Int | CountInput Int | ButtonSubmit | ButtonCancel` or something.. ie. they can use a sum type to give richer meaning than my library's types explicitly encode
06:00:11 <Bish> c_wraith: would you try one more time to explain to dummy me what you meant by implicit mutation
06:00:31 <tdammers> moet: if you're into this kind of thing, I highly recommend looking at halogen
06:00:57 <moet> tdammers: i'll put it on my list... right next to ur/web :heh:
06:01:50 <c_wraith> Bish: I was a bit off in that description.  I must apologize.  Much of STM is built on *explicit* mutation, things like writeTVar.  If that is what was confusing you, I apologize for my bad description.  But STM does include *some* implicit mutation in its internal bookkeeping mechanisms for determining if two transactions interfere with each other or not
06:01:52 <moet> tdammers: what's a url for halogen? not eassily searchable
06:03:39 <c_wraith> moet: it's a lot easier if you include purescript in the search.  https://github.com/slamdata/purescript-halogen appears to be the github repo, at least
06:04:08 <tdammers> ^ yeah, that's the one
06:04:14 <moet> ty!
06:04:38 <tdammers> the trick is to search for "purescript-halogen" rather than just "halogen". should have mentioned that, it's a purescript-ism to prefix every project with purescript-
06:32:07 <__monty__> Would be a pretty funky haskellism.
06:34:23 <tdammers> haskell is more concise, we prefix each package name with h- or hs-
06:36:32 <asheshambasta> So I'm working with "Squeal", which is a library that does deep-embedding of SQL at the type-level in Haskell. Now, since my schema is quite large, so is the type representing my schema. This becomes quite problemmatic with error messages etc., where I see the expanded form of this type within GHCI. Is there a way to disable that? 
06:41:49 <hyperisco> I don't think you can stop ghci from reducing type families
06:43:28 <asheshambasta> hyperisco: ah, too bad 
06:43:51 <asheshambasta> it currently renders many of the error messages all over my terminal
06:44:31 <hyperisco> if I remember right it will use aliases, so you might help yourself by adding aliases
06:44:46 <__monty__> Type synonyms?
06:45:09 <asheshambasta> hyperisco: I am currently doing that; type MySchema = <some large squeal schema here> 
06:45:25 <asheshambasta> but whenever I encounter an error, it expands MySchema to the entire thing, which is very large.
06:48:53 <__monty__> asheshambasta: Just brainstorming, maybe you could provide a more succinct error using custom compile-time errors? Through the TypeError type family?
06:49:22 <__monty__> Not sure you can use it on something that's not a type class though.
06:52:44 <asheshambasta> __monty__: I'm not aware of that, can you point me to something I can read up about this? 
06:54:16 <__monty__> Only know of a tiny section in the user's guide.
06:54:38 <__monty__> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#custom-compile-time-errors
07:00:25 <asheshambasta> __monty__: thanks, I'll look into that and see if that works
07:21:10 <Synthetica> I am running into some deep magic, I think it has something to do with megaparsec.
07:21:54 <Synthetica> I have a package that uses a pre-defined megaparsec parser, however, it doesn't read input from /dev/stdin when piped in with cat, but it does work when using < 
07:23:18 <Synthetica> Example: https://gist.github.com/Synthetica9/4c35ecda7b592d01e68fa9b224f04bc3
07:23:21 <Synthetica> Any ideas?
07:33:44 <merijn> Define "doesn't read input from stdin"
07:33:59 <merijn> What are you expecting and what are you seeing happen?
07:37:19 <Synthetica> merijn: I expect that I can use the file like any other (in this case, open, read, parse with Megaparsec). What happens is that Megaparsec reports the file as empty (when using cat and pipe, `cat file | ./foo`) or it works as expected (when using redirectoin with `./foo < file`)
07:38:05 <merijn> What makes you so sure the problem is megaparsec?
07:38:12 <merijn> Why not the IO code?
07:39:40 <Synthetica> merijn: Because the same thing does work when I try it with a trivial cat implementation using `readFile` (`main = getArgs >>= mapM_ (readFile >=> putStr)`)
07:40:50 <dmwit> That error does *not* say that the file is empty.
07:41:02 <dmwit> Oh, yes it does. =P
07:41:40 <dmwit> Reading is hard.
07:44:45 <dmwit> I think it would be good at this point to cook up a minimal example.
07:45:05 <dmwit> e.g. what happens if you replace the entire parsing thing with just the identity function?
07:45:49 <dmwit> I tried `main = do { h <- openFile "/dev/stdin" ReadMode; hGetContents h >>= print; hClose h }` and couldn't reproduce: both `<` and `|` give me the correct output.
07:47:43 <dmwit> (I mean "replace the entire parsing and processing with just print to show the original String", I mean.)
07:48:15 <maerwald> file handling in Prelude, rofl
07:48:22 <Synthetica> dmwit: Yeah, that works for me too
07:49:58 <nshepperd1> You're not modifying the input file in place, are you? That'll be a bad time with lazy io
07:51:58 <nshepperd1> Also, can you just print out the string before passing it to megaparsec
07:52:25 <Synthetica> nshepperd1: No, I am not
07:52:29 <Synthetica> nshepperd1: I'll try that
07:52:44 <merijn> Isn't this just something stupid like a missing/added trailing newline?
07:53:59 <Synthetica> merijn: That shouldn't make the parser fail
07:58:08 <Welkin> has anyone used the beam library?
07:58:10 <Welkin> https://tathougies.github.io/beam/tutorials/tutorial1/
07:58:33 <Welkin> someone in here was asking a question about postgres a couple days ago and mentioend it, but now that I looked into it, it looks awesome
08:00:30 <Welkin> I've never been satisfied with any sql database client in haskell. Opaleye is way too complicated, persistent is too simple (and esqueleto really messy to write) and relies too much on TH, and postgresql-simple is low-level enough to be a pain in the ass to work with (and is not typesafe at all)
08:01:03 <amx> someone mentioned selda the last time this topic came up
08:01:15 <Welkin> luckily many nosql (key-value) stores don't have this problem because they don't do data validation
08:01:33 <Welkin> I think that's the biggest disconnect with relational databases: they try to do too much
08:01:34 <__monty__> Welkin: Have you looked at project m36?
08:02:02 <Welkin> this comes form the day when programming languages sucked and the database system was supposed to do all the work (data validation, transformations, etc.)
08:02:43 <Welkin> I haven't heard of those, but I'll look them up
08:02:48 <Welkin> I found them on hackage at least
08:03:00 <__monty__> Welkin: If you have to redo the calculation 100 times with a nosql db then the sql db gets to be 100 times slower : >
08:03:48 <Welkin> well, you also store the data differently. You "pre-join" the data on write so you don't have to do all that extra work on read
08:04:18 <__monty__> That just depends on how you structure your sql db though.
08:04:21 <NoidedSuper> Joins typically don't really do that much extra work on reading if you write SQL well
08:04:47 <Welkin> they do because you have to load the entire row into memory
08:05:09 <Welkin> unless you use a column-oriented storage engine, which is only suitable for aggregation/analytics
08:05:17 <Welkin> but I'm talking about transactions, not anayltics
08:06:04 <NoidedSuper> Can't postgres do an index-only join? If you're using an inner join specifically to filter out things that "have" certain results and you don't actually select or filter on any non-indexed columns I think it only ever uses the index.
08:08:46 <Synthetica> nshepperd1: Looks like I was opening /dev/stdin twice somehow ðŸ˜“
08:09:42 <Welkin> I see that m36 is a relational algebra engine, but what does it use for storage?
08:10:23 <__monty__> Welkin: It's its own thing.
08:11:38 <Welkin> I see that
08:11:42 <Welkin> but what does it use for storage?
08:13:01 <Welkin> does it have a pluggable storage engine?
08:13:05 <Welkin> I can't find anything about it
08:13:27 <Welkin> a lot of databases are using rocksdb recently
08:13:32 <Welkin> mysql has tons of storage options
08:17:14 <__monty__> Welkin: https://github.com/agentm/project-m36/blob/master/src/lib/ProjectM36/Persist.hs
08:21:49 <Welkin> these all look like good options
08:21:58 <Welkin> m36 is something I'll have to look more closely at later
08:22:10 <Welkin> but for a decent sql interface, selda and beam look nice
08:22:38 <__monty__> There's also squeal but since you don't like opaleye...
08:23:16 <Welkin> I found opaleye way too confusing with it's profuntors and arrows
08:23:37 <NoidedSuper> Squeal is a bit easier to understand
08:23:38 <Welkin> not to mention verbose
08:24:01 <Welkin> I'd like something pretty close to sql, but in haskell, with haskell datatypes
08:24:48 <Welkin> wow
08:24:52 <Welkin> I didn't know there were so many
08:24:57 <Welkin> I'm bookmarking all of these for later
08:25:15 <dmwit> el_tejon[m]: https://bitbucket.org/tdammers/yeshql ?
08:25:17 <dmwit> uh
08:25:19 <dmwit> Welkin: ^
08:25:23 <Welkin> I haven't looked at the landscape in a few years, so my last high-level sql interface was persistent+esqueleto
08:25:38 <Welkin> I've been in postgresql-simpe land since then
08:27:46 <tdammers> yeshql isn't that high-level ;)
08:28:28 <Welkin> that's pretty cool though
08:28:36 <tdammers> also, postgresql-simple has a TH query splicer IIRC, so yeshql doesn't buy you an awful lot in that case - mainly just that it generates slightly more convenient functions and types, and marshals entire rows to proper types
08:28:39 <Welkin> you just write sql in quasiquotes with type annotations
08:28:43 <tdammers> yes
08:28:50 <Welkin> I would rather avoid TH though
08:28:56 <Welkin> and writing raw sql unless I have a special use case
08:29:06 <Welkin> and avoid writing*
08:29:06 <tdammers> hmhm
08:29:37 <tdammers> in that case, I have found that the best approach is usually to just do your own metaprogramming
08:30:00 <tdammers> the problem is that a general-purpose query abstraction kind of needs to be very complex to cater for all the unspecified needs
08:30:06 <Welkin> outside of sql databases this isn't a problem
08:30:13 <Welkin> I've been starting to move away from sql databases too
08:30:27 <tdammers> idk, I'm rather partial of relational data modeling
08:30:57 <tdammers> it's simple, performs well if you know what you're doing, it has decent theoretical underpinnings, and it's been around for decades
08:32:02 <tdammers> and frankly, I don't expect to ever work on a project that's too large for a well-tuned postgresql cluster on good modern server hardware
08:32:49 <Welkin> I'm interested in distributed databases
08:33:03 <Welkin> where sql databases fall short
08:33:16 <tdammers> ah yes, that they do
08:33:39 <tdammers> or rather, you need stuff on top to make it work
08:33:57 <mrozek> Hi, I'm kind of new to haskell, and I have read learnyouahaskell website. I'm curious of how to learn Haskell, because a friend of mine recommends it.
08:33:58 <tdammers> local sql databases as a granulate for distributed storage is not necessarily a lousy idea
08:34:38 <tdammers> mrozek: find a good introductory learning resource, get cracking, write lots of code, read lots of stuff, ask questions (here, on reddit, on the haskell-cafe mailing list)
08:35:32 <Welkin> tdammers: since when does postgresql-simple offer TH quasiquotes?
08:39:09 <maerwald> mrozek: what kind of friends do you have? :P
08:39:23 <maerwald> He just threw you into a rabbit hole :)
08:40:35 <Taneb> maerwald: the best sort of friends, evidently ;)
08:42:03 <zalazalaza[m]> tdammers: know of any good introductory resources?
08:43:19 <Welkin> Programming in Haskell 2nd edition
08:43:28 <Welkin> also https://www.seas.upenn.edu/~cis194/spring13/
08:43:32 <Welkin> LYAH is not a good resource
08:44:03 <DigitalKiwi> hutton++
08:44:24 <DigitalKiwi> he has a bunch of papers on his website too
08:44:32 <Costar> Hello all
08:44:43 <Welkin> the book is only 250 pages, 50 of which are appendices/index
08:45:18 <Welkin> 300 pages (250 pages withou appendix.index)
08:46:46 <Costar> what linux distro you guys use with Haskell/Xmonad?
08:46:55 <mrozek> @maerwald: He is a mathematician. I have another friend who also is a mathematician (both are students) and he loves haskell as well. I would like to understand this as a computer engineer. I assume they use it for proving things, like Agda for example helps you create mathematical proofs.
08:46:56 <lambdabot> Unknown command, try @list
08:47:44 <mrozek> @maerwald: I'll be happy to explore what's inside the hole :)
08:47:45 <lambdabot> Unknown command, try @list
08:47:48 <maerwald> Oh well, Agda is probably better suited for those tasks, but haskell probably better for writing actual programs that do stuff
08:47:52 <Welkin> haskell is a very practical language
08:47:57 <Welkin> not meant for proving theorems
08:48:22 <maerwald> You could say haskell is actually not well suited for proofs (neither on high and especially not on low-level)
08:48:22 <Welkin> it's used to build compilers, write DSLs, and build web servers
08:48:23 <Welkin> for example
08:49:05 <Welkin> NoidedSuper: squeal looks really interesting
08:49:12 <maerwald> So it's more about expressivity I guess
08:49:27 <Welkin> it's the best sql DSL I have seen so far
08:50:00 <Welkin> it's basically SQL with slightly different syntax
08:50:01 <NoidedSuper> Squeal is pretty neat
08:50:04 <Welkin> is it 100% type-safe?
08:50:17 <Welkin> writing raw SQL I *always* make mistakes and get runtime errors
08:50:22 <Welkin> throws exceptions
08:50:52 <maerwald> raw SQL is like posix shell: only for real men xD
08:51:11 <Welkin> I had my learning experience already
08:51:24 <tdammers> that's why you test your stuff
08:51:24 <Welkin> I'm ready to not deal with low-level details all the time
08:51:57 <Welkin> writing instance to convert a result/row into a haskell type was also completely unsafe
08:52:08 <tdammers> and again, not saying you shouldn't use SQL abstractions, just that it's often a better idea to build customized, special-purpose abstractions yourself, rather than a generic SQL abstraction framework
08:52:09 <Welkin> just a series of <$> field <*> field <*> field
08:53:35 <Welkin> the MapReduce model (and json) fits much more naturally with haskell
08:53:42 <Welkin> and every programming language in exitence actually
08:53:45 <Welkin> existence*
08:53:57 <tdammers> you want something that fits the problem, not the programming language
08:54:16 <tdammers> fitting a general-purpose language to any given data paradigm should be easier than the other way around
08:54:35 <Welkin> that's why there are so many different types of databases
08:54:42 <Welkin> of which sql is only one
08:54:50 <Welkin> graph databases are much better at modeling complex relations
08:55:30 <Welkin> but all databases outside of the sql/relational world are key-value stores that (tend to) use json in some way
08:56:39 <tdammers> which makes some things very awkward
08:58:49 <Welkin> there is a more recent class of databases that are often called multi-model, which include interfaces for key-value stores, document stores, graphs, and even a sql interface
09:02:41 <DigitalKiwi> Costar: nixos
09:03:07 <Costar> DigitalKiwi: what editor? Vim?
09:03:56 <DigitalKiwi> vim and/or doom-emacs
09:06:38 <spaunovic> Hi everyone, could anybody help me write the following function: (Monad m, Functor f) => m (a -> b) -> f a -> m (f b)
09:07:33 <shapr> @djinn (Monad m, Functor f) => m (a -> b) -> f a -> m (f b)
09:07:33 <lambdabot> Error: Class not found: Functor
09:08:49 <geekosaur> :exf "(Monad m, Functor f) => m (a -> b) -> f a -> m (f b)"
09:08:50 <exferenceBot> \ a b -> fmap (\ f6 -> fmap f6 b) a
09:13:28 <Costar> lol
09:32:05 <spaunovic> thx
09:47:50 <jollygood2> are you sure you don't want  ? which would be applicative <*> operator
09:47:55 <jollygood2> are you sure you don't want  m (a -> b) -> m a -> m b? which would be applicative <*> operator
09:51:15 <spaunovic> jollygood2: No, a is wrapped in a different Functor from m
09:52:14 <funrep_> would parsec be suitible for parsing a language with haskell-like syntax?
09:52:50 <hyperisco> funrep_, after it is tokenized yes
09:53:01 <spaunovic> jollygood2: But I solved it with do notation eventually, something like do f <- ...; f <$> a. That gives me exactly m (f b)
09:53:10 <funrep_> tokenize means using a lexer?
09:53:24 <hyperisco> yes
09:53:41 <spaunovic> jollygood2: Thx for jumping in to help :)
09:55:31 <hyperisco> funrep_, because it will be easier once indentation is traded for brackets
10:01:30 <funrep_> hyperisco: i see, that's smart thx!
10:03:24 <Eckersley> is it okay to ask for help in this channel?
10:03:35 <Eckersley> or is there a specific channel for that purpose
10:05:01 <Ariakenom> Eckersley: yes and yes
10:05:44 <Ariakenom> You can totally ask here, go ahead.
10:06:08 <Ariakenom> There's also #haskell-beginners.
10:06:19 <Eckersley> so, i've been studying Haskell alongside college by myself for few days now
10:06:31 <Eckersley> and i have some real trouble wrapping my head around the error messages
10:06:49 <Eckersley> i have only done OOP before so it is rather new to me
10:07:28 <Eckersley> At the moment I am trying to write a basic recursive function to calculate the distance between two dates
10:07:45 <Eckersley> but have been stuck for the past few hours
10:07:53 <Eckersley> with the errors lol
10:07:58 <__monty__> Oof, that sounds horribly difficult. Unless you ignore leap years/seconds : >
10:08:00 <[exa]> Eckersley: please share on pastebin :]
10:08:23 <Eckersley> yeah.. its a rather crude implementation just to get used to recursion
10:08:26 <[exa]> Eckersley: anyway, working with human dates is a traditional source of pain :]
10:08:36 <Eckersley> https://gist.github.com/Eckersleyful/b21521dd4b63c374af98761ec5b2c258
10:08:40 <Eckersley> but this is the gist of that code
10:08:55 <Welkin> distance between two dates?
10:09:00 <Welkin> the fruit, or calendar dates?
10:09:06 <Eckersley> lmao, calendar dates
10:09:08 <Eckersley> luckily
10:09:11 <Welkin> use utcDiffTime
10:09:16 <Eckersley> the former sounds kinda difficult to implement
10:09:17 <Welkin> done
10:09:23 <dmwit> :t fmap . flip fmap
10:09:25 <lambdabot> (Functor f2, Functor f1) => f2 a -> f1 (a -> b) -> f1 (f2 b)
10:09:33 <dmwit> spaunovic: ^
10:09:34 <[exa]> Eckersley: can you include the error message?
10:09:38 <Eckersley> sure
10:09:39 <Eckersley> sec
10:09:40 <Welkin> I wouldn't bother with made-up problems like that
10:09:42 <__monty__> Eckersley: Looks like you're missing some parentheses.
10:09:44 <Welkin> try working on a real project
10:10:00 <Welkin> something fun
10:10:03 <[exa]> Eckersley: anyway you're missing some parentheses in the last line
10:10:06 <Eckersley> * Couldn't match type `(a2, b, c1)' with `(a, a1, c) -> (a, a1, c)'       Expected type: ((a, a1, c) -> (a, a1, c))                      -> (a2, b, c1) -> (a2, b, c1) -> (a2, b, c1) -> (a2, b, c1)         Actual type: (a2, b, c1)                      -> (a2, b, c1) -> (a2, b, c1) -> (a2, b, c1)     * Relevant bindings include         calculateDifference :: ((a, a1, c) -> (a, a1, c))                                -> (a2, b, c1) 
10:10:10 <Eckersley> its formatted like ass
10:10:11 <Eckersley> zz
10:10:13 <__monty__> Eckersley: You're calling `calcDiff` with argument `nextDate` and `(year...)`.
10:10:13 <Eckersley> let me make a gist
10:10:18 <Welkin> also, use some data types!
10:10:22 <Welkin> it's all tuples
10:10:24 <Welkin> make a record
10:10:46 <[exa]> Eckersley: yeah that's it. Like, how can Haskell know from ` f x (abc) (def) `  that it should apply ` x (abc) ` first?
10:11:03 <[exa]> Eckersley: by default it's applying functions to parameters from left to right
10:11:17 <Eckersley> so i am passing invalid parameters atm
10:11:41 <Eckersley> otherwise = calculateDifference(nextDate(year,month,day) (year2,month2,day2) (n+1))
10:11:44 <jollygood2> Eckersley you're making it difficult for yourself by a) using tuples instead of records b) not adding type signatures to your functions
10:11:52 <[exa]> Eckersley: that's one parameter too much
10:12:06 <[exa]> just (nextDate (y, m, d))
10:12:11 <Welkin> jollygood2 is right
10:12:28 <Welkin> in haskel lyou always start by writing type declarations for your functions and defining custom data types
10:12:37 <Welkin> *then* you can write the definitions for your functions
10:12:43 * dmwit . o O ( First make it work. Then make it pretty. )
10:12:49 <[exa]> +1 dmwit
10:13:01 <amalloy> also (c) by writing f(g(x)) instead of f (g x). even if you get the parens right it's harder to read
10:13:17 <Eckersley> yeah i guess i have to spend some time with the function type declarations
10:13:25 <Eckersley> they were pretty intimidating at first not gonna lie
10:13:32 <Eckersley> coming from java and python
10:13:45 <dmwit> In time, with experience, you learn how to make it pretty to begin with. But berating a newcomer because they don't have experience... yuck.
10:14:38 <[exa]> Eckersley: you may want to try to remove the tuples altogether.. not saying that 7-parameter functions would be nice, but using :t in ghci will show you the function types in a new light :]
10:14:38 <Welkin> don't worry about it looking ugly
10:14:40 <amalloy> Eckersley: a haskell type signature is not all that different from a java method signature, at a basic level
10:14:44 <Welkin> my haskell was pretty ugly when I started too
10:14:49 <[exa]> Eckersley: anyway, did it help?
10:14:56 <jollygood2> giving some pointers how to get more useful and readable error messages does not equal berating a newcomer
10:15:12 <Welkin> Eckersley: you will learn to love types
10:15:19 <Welkin> the types write your program for you
10:15:30 <Eckersley> yes it compiles now
10:15:42 <Eckersley> just trying to figure out how to call it from the prompt
10:15:48 <Eckersley> as im using tuples
10:16:09 <Welkin> I did an exercise when I first started where I wrote out all of the types on paper, and then wrote the definition on paper as well. It was for a collision detection features in a game I wanted to write in haskell. When I was done, I typed it into the computer and it compiled without issue.
10:16:13 <Eckersley> hey got it to work
10:16:30 <Eckersley> although i have to call it in such a stupid way atm
10:16:34 <Welkin> learn to use custom data types
10:16:52 <dmwit> Eckersley: What's the stupid way? We might be able to help show a non-stupid way.
10:16:54 <[exa]> jollygood2: learning requires constant stream of stuff that starts to work; making a long pause of that stream just because getting the very non-OOP syntax of structures right is, in fact, problematic. But I agree that it would help a lot :]
10:16:55 <Welkin> use them everywhere
10:17:03 <Eckersley> calculateDifference (2012, 5,20)(2012, 5, 25) 0
10:17:08 <dmwit> Or possibly tell you that we think the stupid way isn't stupid. =)
10:17:13 <dmwit> Okay, the stupid way isn't stupid.
10:17:16 <[exa]> Eckersley: wrap it in a function that adds the zero there?
10:17:16 <Eckersley> two tuples and the starting point for the recursion iteration count
10:17:29 <Eckersley> yeah not a bad idea exa
10:18:05 <[exa]> Eckersley: naming hint: call the internal function calculateDifference'  (with a ' )
10:18:10 <doyougnu> IMO learning to use the type system to express what your function does is one of the largest issues newcomers face when learning haskell. Sit down, take some time and do some top-down programming. You'll thank yourself later
10:18:24 <Eckersley> hmm okay
10:20:51 <noxecane> I don't know if the last message was sent..but to retry...Could anyone explain the use of "|" in "class N s a | s -> a where"
10:21:00 <koz_> noxecane: Functional dependency.
10:21:46 <koz_> The | separates the typeclass type variables from the functional dependency notation.
10:23:05 <noxecane> currently going through haskell wiki to understand 
10:24:51 <noxecane> thanks so much for that
10:25:09 <Eckersley> thank you all so much
10:25:14 <Eckersley> i might return later though
10:25:17 <Eckersley> but bye for now
10:26:57 <[exa]> noxecane: I found this to be enlightening about MPTCs (also funny) https://aphyr.com/posts/342-typing-the-technical-interview
10:27:10 <noxecane> I have being looking around for a list of blogposts, or books that can help me graduate from intermidiate haskeller(Monads, Monoids, mtl style and the likes) to let's say professional haskeller(GADTs, Type Families, HLists, Vinyl...))
10:27:37 <noxecane> anyone have an idea how to do that 
10:27:38 <[exa]> nonzen: (I'm realizing it's probably the most practical intro to MPTCs I've seen)
10:28:06 <sm> s/professional/experimental/, perhaps
10:29:12 <koz_> noxecane: Have you looked at Stephen Diehl's 'What I wish I knew when learning Haskell'?
10:29:13 <doyougnu> simon peyton jones has a great lecture series on youtube about Type Families called "Adventures with types"
10:30:46 <glguy> noxecane: The way to get "professional" experience is to develop Haskell software. Work on a project you're interested in. Professional projects probably aren't using hlists or vinyl, typically don't need GADTs
10:31:43 <Athas> Professional Haskell is all about lenses and TypeInType, isn't it?
10:32:19 <noxecane> @glguy I am actually workinig on a professional project that uses opaleye. I've found the boilerplate needed to declare entites a big pain. 
10:32:20 <lambdabot> Unknown command, try @list
10:32:57 <noxecane> [19:glguy I am actually workinig on a professional project that uses opaleye. I've found the boilerplate needed to declare entites a big pain. 
10:32:58 * hackage potoki-conduit 0.1 - Integration of "potoki" and "conduit"  http://hackage.haskell.org/package/potoki-conduit-0.1 (NikitaVolkov)
10:33:37 <Welkin> there are tons of options besides opaleye
10:33:41 <Welkin> some were mentioned earlier
10:33:54 <Welkin> lik selda, squeal, and beam
10:36:18 <noxecane> I've also tried beam(not seen selda nor squeam). Opaleye is my fourth try(after, persistent & esquelto, yeshql, beam)
10:37:40 <noxecane> perhaps professional haskell was the wrong word then
10:39:23 <noxecane> koz_ & doyougnu thanks a lot I'll take a look
10:41:25 <mojjoo> hi! a question: Is `->` a type constructor? I mean infix, well, but conceptionally not different from say `Either`, as it just takes two types as argument and creates a new type? Or is it a different beast?
10:43:34 <klntsky> mojjoo: yes
10:45:52 <mojjoo> but with the only difference that it is defined at the language level? (which does not matter from the usage point of view)
10:46:33 <amalloy> mojjoo: yes
10:46:51 <mojjoo> nice
10:47:37 <amalloy> that's why you can define typeclass instances for functions. instance Functor ((->) a) where fmap = (.)
10:57:57 <lordcirth_> Change in Linux kernel syscalls to use 64bit time: https://lwn.net/SubscriberLink/776435/664f2f0b0b6fc9f5/ Does GHC / Base need to be updated for this? Perhaps a GSoC candidate.
10:59:51 <__monty__> Is there something like a fold, that can not only look at the results but also the future inputs?
11:00:14 <lordcirth_> __monty__, what do you mean by future inputs? Like look ahead in the input list?
11:00:34 <boj> tardis monad? :)
11:00:59 <__monty__> lordcirth_: Yep.
11:01:25 <lordcirth_> __monty__, I am not aware of such a thing (though I am a beginner). Are you sure that's the best way to do it?
11:01:36 <koz_> Turn it into a list of lists, where each sub-list is the size of your look-ahead?
11:01:40 <koz_> Then fold on that?
11:02:05 <koz_> So like, it'd go from [1,2,3,4,5] to [[1,2,3], [2,3,4], [3,4,5], [4,5], [5]]
11:02:13 <koz_> If you needed a look-ahead of 3 at most.
11:02:47 <__monty__> koz_: The lookahead is potentially to the end of the input list.
11:03:14 <koz_> __monty__: Then I think you want a vector, and perform a fold over its indices, not its elements.
11:03:21 <koz_> Then you can access whatever, whenever.
11:04:28 <__monty__> I was just checking whether there's a pattern in this. I usually prefer a fold over general recursion because it's clearer what sort of things the function might be doing.
11:05:09 <koz_> __monty__: Without a more specific description of what you're doing, we can't make a better suggestion.
11:06:52 <__monty__> koz_: I'm mapping something over a list while checking after every transformation if the result is already in the transformed section or in the yet to transform section.
11:07:38 <koz_> __monty__: It sounds like what you want is a state monad.
11:08:09 <koz_> Just accumulate the transformed section behind you, and if the result isn't in the already-transformed section, then transform it.
11:08:13 <koz_> But I'm still confused.
11:08:15 <__monty__> koz_: I was thinking just recursion with an accumulator.
11:08:24 <koz_> Are you doing this to avoid duplicates or something?
11:08:30 <__monty__> Yes.
11:08:33 <jollygood2> > map (take 3) . tails $ [1,2,3,4,5]
11:08:34 <lambdabot>  [[1,2,3],[2,3,4],[3,4,5],[4,5],[5],[]]
11:09:09 <koz_> __monty__: Have you considered map, followed by jamming through a Set?
11:09:12 <jollygood2> > init . map (take 3) . tails $ [1,2,3,4,5]
11:09:14 <__monty__> jollygood2: I know, but imo that's less clear than the general recursion rather than more.
11:09:14 <lambdabot>  [[1,2,3],[2,3,4],[3,4,5],[4,5],[5]]
11:09:27 <jollygood2> __monty__ *shrug*
11:09:45 <__monty__> koz_: That doesn't work, because transformed elements can collide with to-transform elements.
11:09:55 <koz_> __monty__: I don't even know what you mean by that.
11:10:57 <__monty__> koz_: Imagine carts moving on a track, if I move them before checking for collisions then they might've warped through eachother.
11:10:58 <Rembane> __monty__: I'm just throwing this out there without having thought about it too much. Can you take a Map with all calculated solutions as an argument to the function?
11:11:51 <__monty__> Rembane: That's similar to the accumulator solution, no?
11:12:40 <Rembane> __monty__: It is indeed. Just a bit faster best case.
11:14:26 <__monty__> Rembane: I've considered a Map, problem is the result needs to be ordered. I figured it'd be cheaper to maintain the order rather than having to sort every generation.
11:14:57 <Rembane> __monty__: Does it need to be ordered in the algorithm?
11:15:23 <__monty__> The transformations have to occur in the right order.
11:16:26 <mojjoo> one more: as we have function application on the value level, in an AST data type it may defined as `data Expr = Apply Expr Expr | ...` would it be right to model this for the type level: `data TypeExpr = Apply TypeExpr TypeExpr | ..` so is a type constructor actually equal to type application? 
11:16:28 <Rembane> __monty__: Cool. What's the type of the transformation in Haskell types? 
11:17:11 <__monty__> Rembane: It's just moving the cart one step on a grid.
11:17:23 <__monty__> This is an AoC challenge.
11:17:58 <Rembane> __monty__: Aha. Which? :)
11:18:12 <__monty__> Day 13.
11:18:30 <__monty__> I didn't mention it because I don't want spoilers.
11:19:11 <Rembane> Good reason. I didn't do that day so I don't have any insights. 
11:21:04 <Rembane> Can you use the state of the level/map/gameboard as argument and a list of carts sorted wrt their distance from the top as another argument, and when that list is empty you've done a tick?
11:23:15 <zachk> so ghc 8.2 doesnt check to see if llvm is installed under ./configure when building, but fails without it 
11:26:03 <__monty__> Rembane: That's basically what I'm doing, except I just have (Carts, Track) basically. But that's why I need both the already-moved carts *and* the yet-to-move carts.
11:28:42 <Rembane> __monty__: Have two lists of carts, one with already moved carts and one with yet to move carts.
11:29:11 <__monty__> Rembane: Yeah, that's the accumulator approach I was talking about : )
11:29:50 <Rembane> __monty__: That sounds like a good solution. :)
11:30:14 <Rembane> __monty__: Have you looked into recursion schemes?
11:30:55 <__monty__> No, was hoping someone knew one that exactly fits this pattern. : )
11:33:27 * hackage cabal2spec 2.2.2.1 - Convert Cabal files into rpm spec files  http://hackage.haskell.org/package/cabal2spec-2.2.2.1 (PeterSimons)
11:34:42 <Rembane> __monty__: Sweet. Try all the recursion schemes. It's great fun! :D
11:40:44 <dmwit> __monty__: There is a special fold for this, yes. But it's usually easier to use foldr+tails than it is to add recursion-schemes to your dependency list and remember which scheme it is.
11:40:55 <dmwit> Easier on the reader, too. =)
11:41:13 <__monty__> I'll have a look.
11:41:15 <dmwit> :t \f z -> foldr f z . tails
11:41:16 <lambdabot> ([a] -> c -> c) -> c -> [a] -> c
11:42:44 <dmwit> > foldr id [] (tails [x,y,z])
11:42:46 <lambdabot>  error:
11:42:46 <lambdabot>      â€¢ Couldn't match type â€˜[Expr]â€™ with â€˜[a] -> [a]â€™
11:42:46 <lambdabot>        Expected type: [[a] -> [a]]
12:54:53 <lockestep> when looking at haddock docs, it would be neat if the maintainers could insert a little interactive repl that included their project
12:55:39 <lockestep> *when looking at haddock docs locally
13:01:57 <amx> That's an intriguing idea. It doesn't even need to be limited to local.
13:03:15 <__monty__> Rembane: I've reconsidered, I only need to compare to the already moved carts if I check before and after moving the next cart. So a fold works after all.
13:05:25 <Rembane> __monty__: Good! 
13:06:37 <lockestep> amx, I thought local might be easier because you could have a process running on your computer that evaluated the haskell
13:07:16 <lockestep> that could run on the web version ofc, but it'd be costly to whoever is hosting it
13:15:38 <mckeankylej> Is the following code sound? Is it possible to leak the reference? https://gist.github.com/mckeankylej/49c1161fad3878a1c12953046a009dd7
13:17:01 <amx> lockestep: true, I was hoping that maybe you could run ghci in ghcjs, but I couldn't find anything like that
13:18:00 <lockestep> someone compiled hugs to js with emscripten, but it uses a ton of memory and I don't think it'll load a package package 
13:18:39 <lockestep> locally seems like the best bet to me
13:19:08 <lockestep> the other advantage of locally is that it loads faster, you have it on the plane, and it's guaranteed to be the same version of a package you're using 
13:21:03 <dmwit> lockestep: cabal repl basically does that, no?
13:22:16 <lockestep> yes, but that's less useful
13:23:30 <monochrom> I think they're talking about doing "cabal install xxx" and "cabal repl yyy" right in your web browser because you're reading hackage docs in your web browser.
13:26:49 <leifmetcalf> How do I make a command run with `createProcess` from the `process` library send its output to the terminal?
13:27:00 <lockestep_> imagine I look up the docs for fromMAybe
13:27:46 <lockestep_> it had a repl where `import Data.Maybe` and `fromMaybe "" (Just "Hello, World!")` were already entered (with the latter outputting "Hello, World!")
13:28:27 <lockestep_> I could press the up arrow and turn that into `fromMaybe "test" Nothing`, and see it output `"test"`
13:28:58 <isovector1> can i use a quantified constraint in a deriving via clause?
13:29:01 <lockestep_> I could do `:t fromMaybe "test"`, and see it expects a type `Maybe String`
13:29:42 <lockestep_> it would make it easier to play with a particular function
13:29:54 <geekosaur> leifmetcalf, if the running program is attached to the terminal already, that would be the default.
13:30:13 <geekosaur> If not, well, it's hard for a reason. (What else might be going on on the terminal?)
13:30:25 <geekosaur> but there is /dev/tty
13:31:22 <geekosaur> (on Windows, it'd be CON: instead. and may fail if the console window is otherwise busy or the program is detached)
13:34:02 <leifmetcalf> geekosaur, my function wasn't even being called that's why there was no output.
13:34:08 <leifmetcalf> my bad
13:35:30 <monochrom> I prefer to re-tell the use-case story with lens.  Imagine you look up the docs for "over" in lens.  And then https://ro-che.info/ccc/23 happens.
13:37:01 <infinisil> Haha, yes
13:37:57 <monochrom> We have not even discussed how a web browser would do the equivalent of cabal-install and ghci.
13:39:20 <geekosaur> they're hoping the haddock would have a ghcjs-compiled version of the library embedded, I think
13:39:28 <monochrom> There are only four methods I know of.  1. compile cabal-install and ghci to javascript.  2. compile cabal-install and ghci to Java applets.  3. compile cabal-install and ghci to Flash games.  4. compile cabal-install and ghci to ActiveX and resurrect IE5.
13:39:43 <MarcelineVQ> "hackage.haskell.org is requesting to store 3gb in your local cache"
13:41:02 <zachk> java applets are pretty dead these days, I think chrome and firefox have dropped support for them, they no longer support NPAPI which the java applets used 
13:41:11 <geekosaur> but the original one specified local haddocks, so presumably hackage wouldn't build haddocks with that option
13:43:55 <amx> I think lockestep's idea is more in line with any of those haskell REPLs in the browser
13:43:57 <higherorder> Is there a shorter way to write the following: `\x -> g x . f x`?
13:44:14 <shachaf> Yes, but probably not a better way.
13:44:16 <amx> so it would just be i/o redirection to/from the browser
13:44:34 <monochrom> All existing online in-browser Haskell REPLs are backed by remote servers.
13:44:45 <amx> yes, but you can point them to localhost
13:44:50 <higherorder> shachaf: out of curiosity, what's the shorter way, even if not better?
13:45:02 <shachaf> @pl \x -> g x . f x
13:45:02 <lambdabot> liftM2 (.) g f
13:45:11 <higherorder> ah, ty
13:45:16 <amx> I just brought up ghcjs because that would have been nice, but it doesn't seem to happen anytime soon
13:45:27 <kuribas> I see the piesync guys are hiring...
13:45:46 <dmwit> monochrom: 5. Run code server-side.
13:46:28 <kuribas> I was interviewed by them, and they seemed to think haskell is not useful for general purpose programming.
13:46:39 <dmwit> > (length "\x->g x.f x", length "liftA2(.)g f")
13:46:41 <lambdabot>  <hint>:1:12: error:
13:46:41 <lambdabot>      lexical error in string/character literal at character '-'
13:46:47 <dmwit> > (length "\\x->g x.f x", length "liftA2(.)g f")
13:46:49 <lambdabot>  (11,12)
13:46:53 <kuribas> and you need to combine it with a language like go for it to be useful.
13:46:54 <dmwit> not shorter...
13:47:08 <shachaf> > length "(.)<$>g<*>f"
13:47:10 <lambdabot>  11
13:47:12 <monochrom> You ought to count tokens instead.
13:47:58 <dmwit> Ought I?
13:48:13 <monochrom> I would say that Go is the more useless one because it lacks parametric polymorphism.
13:48:26 <monochrom> Yes, everyone oughts to count tokens instead.
13:48:35 <higherorder> dmwit: haha 
13:49:22 <dmwit> If some code has `aVeryLongIdentifierName`, it is probably long because there are an awful lot of identifiers worth knowing.
13:49:23 <shachaf> > length "(.)<$>g<*>f"
13:49:26 <lambdabot>  11
13:49:30 <dmwit> One token doesn't capture that fact.
13:49:34 <shachaf> Uh.
13:49:38 <monochrom> There are a lot of great imperative languages out there and Go is not one of them.  Go would be great 50 years ago.
13:49:46 <shachaf> > length "(.).g<*>f"
13:49:48 <lambdabot>  9
13:49:49 <shachaf> Is what I meant to say.
13:50:02 <shachaf> The point is, all of these are bad.
13:50:24 <glguy> > length "ap((.).g)f"
13:50:26 <lambdabot>  10
13:50:31 <monochrom> No no dwmit, it's probably long because the host language is Java! >:)
13:50:46 <dmwit> Well. Token count doesn't capture that fact, either. =D
13:50:52 <glguy> Is (.) one or three tokens in this model?
13:51:11 <kuribas> monochrom: I think the interviewer thought I was an amateur or language zealot for thinking you can do everything in haskell.
13:52:18 <kuribas> But sadly many people think haskell isn't a practical language.
13:52:26 <dmwit> Anyway, both token count and character count are wrong in their own way, and the correct metric is probably too complicated to write down correctly anyway.
13:52:41 <dmwit> I agree that in most cases token  count is better than character count.
13:53:04 <kuribas> monochrom: when it comes to concurrency, haskell is probably a much better choice
13:53:09 <monochrom> How about number of nodes in abstract syntax tree + log of identifier names?
13:53:38 <dmwit> Maybe even log of identifier set is enough to capture that part.
13:53:48 <dmwit> log of size of identifier set
13:54:27 <monochrom> Now it's just complicated to actually calculate :)
13:55:32 * monochrom oughts to publish this in academia and claim a Turing Award
13:59:26 <monochrom> Dear Turing Award committee, I am Dr. William Fearsome and you ought to fear me (because I'm Fearsome) and enter my name to your awardee nomination list to add value and credibility to your award.  I am the greatest informaticist, philosopher, physiologist, and lawyer in 50 years.  What can your childplay award do to me?
14:00:08 <monochrom> err, s/to me/for me/
14:01:06 <Rembane> Dr. William Fearsome sounds like a villain's name. 
14:04:02 <Lycurgus> the piesync concept was a let down when I saw what it was
14:04:36 <Lycurgus> i would expect them to be dolts with a superficial judgement about the the generality of hs
14:04:48 <monochrom> Rembane, take a look at haskell-cafe and look for posts from William Fearon.  (I mutated Fearon to Fearsome.)  It will be awe-inspiring. >:)
14:05:02 <Lycurgus> vs one about it's actual general suitability
14:05:55 <Rembane> monochrom: ^^ sweet! 
14:06:12 <Lycurgus> "pie" is personal info something igess
14:06:46 <zachk> ghc building, can't find llvm 3.9, installed 3.9, still doesn't work, install llvm 6.0, it works but complains -_- 
14:07:18 <monochrom> At least it works.
14:07:18 <kuribas> Lycurgus: I think the haskell part is only pure code
14:08:04 <monochrom> I mean if you asked your kid to take garbage to the garbage bin outside they would complain but they would get it done.  Compared to asking your dog instead.  >:)
14:09:07 <kuribas> Lycurgus: did you get to look at the code?
14:09:28 <Lycurgus> no, you mean their codebase? it's on github or something?
14:10:06 <Lycurgus> just looked up what "piesync" was
14:10:16 <kuribas> Lycurgus: ah right
14:10:41 <monochrom> zachk: Actually I am curious, what is its complaint?
14:10:45 <kuribas> Lycurgus: it looked quite boring actually.  I was not so sad they didn't hire me :)
14:10:47 <aplainzetakind> I want to combine applicative parsers in the way I would do in a monad as `do a <- parser1; b <- parser2 a; pure $ Foo a b`. Is it possible?
14:11:25 <MarcelineVQ> check the ghc manual for ApplicativeDo
14:11:33 <kuribas> aplainzetakind: Foo <$> parser1 <*> parser2 ?
14:11:34 <Lycurgus> kuribas, yeah, it's a sellers market at this time, and as I said their app looks doltish
14:11:36 <monochrom> Naw, if you have a later thing depending on "a" from an earlier thing, that lands you in Monad land immediately.
14:11:50 <aplainzetakind> ^
14:11:50 <geekosaur> ^
14:11:52 <monochrom> It is the main point of >>=
14:12:03 <aplainzetakind> Yes, but can I achieve the same result somehow?
14:12:17 <geekosaur> that said, applicative parsers should work as monadic parsers, so what you wrote should just work
14:12:22 <Lycurgus> at first glance I thought it was general syncing of apps somehow which would have been interesting and possible an application of some hs
14:12:34 <geekosaur> hm. no, types
14:12:39 <Lycurgus> *possibly
14:12:44 <geekosaur> if they're specifically Applicative
14:12:55 <monochrom> No, there is an applicative (and alternative?) but non-monadic parser library.
14:12:59 <kuribas> Lycurgus: it isn't?
14:13:07 <zachk> monochrom, says something like only llvm 3.9 is supported at this time, trying anyways... iirc, can't scroll up, how do I scroll up in screen?
14:13:26 <kuribas> Lycurgus: btw, if you are interested, I know another guy who is hiring in Belgium
14:13:27 <Lycurgus> kuribas, sfaict it's only personal info, contacts and such like
14:13:41 <aplainzetakind> More concretely, I'm using optparser-applicative, I want to parse the input file, and I want to just use the input file as the output if there's no output argument given.
14:13:44 <geekosaur> and no Monad instance. so you'd have to run the applicative parsers separately from within a monadic context or something lkiekt hat
14:13:44 <geekosaur> ...
14:13:55 <Lycurgus> but only glanced at the top SE results which they've doped with their shit
14:14:20 <monochrom> Ctrl-A [  then you can pgup pgdn.  Press ESC to exit that mode.
14:14:38 <kuribas> Lycurgus: when I interviewed, they didn't seem like functional programming affectionados.
14:15:02 <kuribas> Lycurgus: more like, let's follow the hype train, and include haskell in our big list of languages
14:15:46 <kuribas> Lycurgus: still better than no haskell I guess?
14:16:12 <Lycurgus> kuribas, there's a huge churn in IT, for a number of reasons. Most professional fields don't have 5-10 turnover of the doing workers for a new as young as possible crop
14:16:18 <amalloy> aplainzetakind: one approach would be to just run the applicative parser without this defaulting, so that you get Nothing as your output file. then you can fmap over the result of running the parser, and do whatever you want, e.g. replacing the output file with the input file if it's empty
14:16:30 <monochrom> aplainzetakind: I believe optparser-applicative is really designed against this data dependence.  But it has a subcommand mechanism (think "cabal update" "cabal repl" etc) and maybe that's enough.
14:16:35 <Lycurgus> within that there's relatively little real pressure for excellence
14:16:47 <Lycurgus> actual as opposed to bloviated
14:17:16 <aplainzetakind> amalloy, monochrom: Yes I think what I'm trying to do is beyond the scope of what parsing is. I should parse first and do stuff accordingly later.
14:17:18 <kuribas> Lycurgus: Luckily that's not how it is where I work now.
14:17:49 <Lycurgus> kuribas, iirc you went where the work you wanted was
14:18:06 <kuribas> Lycurgus: I suppose.  But lisp, not haskell
14:18:14 <Lycurgus> ah
14:18:47 <kuribas> Lycurgus: but smart and open minded people, interesting problem domain.
14:19:22 <Lycurgus> and I'm not in the EU so the be thing prolly wouldn't work
14:19:23 <zachk> monochrom, specifically: You are using an unsupported version of LLVM!
14:19:23 <zachk> Currently only 3.9 is supported.
14:19:23 <zachk> We will try though...
14:19:35 <kuribas> Lycurgus: right
14:19:54 <monochrom> That may be just a stale warning.
14:20:15 <zachk> i think 8.2 is kinda old, I know like 8.0.2 is from like jan 2017 iirc 
14:20:15 <Lycurgus> i like lisp at least as much as hs, better I suppose. I see ur not in #lisp
14:21:08 <Lycurgus> hs has a friendlier community though
14:21:16 <monochrom> In the GHC user's guide it says 8.4.3->5.0 and 8.6.3->6.0
14:21:17 <Lycurgus> because they have to igess
14:21:21 <dmwit> aplainzetakind: data OutputFile = InputFile | SpecifiedOnCommandLine FilePath
14:21:30 <dmwit> aplainzetakind: (Or just reuse `Maybe`.)
14:21:49 <kuribas> Lycurgus: lisp is cool.   But I like types...
14:22:20 <dmwit> Oh. Man I need to read faster. amalloy already suggested this.
14:22:44 <monochrom> Or just write slower!
14:22:50 <amalloy> dmwit: in fairness i think what i suggested was also just an unpacking of geekosaur's suggestion
14:23:25 <Lycurgus> kuribas, different strokes for different blokes, there's little you can do in hs you can't do in common lisp with the approriate pkgs, but the reverse isn't true
14:23:42 <kuribas> Lycurgus: I disagree
14:24:12 <kuribas> Lycurgus: So far I didn't see anything in CL that couldn't be done elegantly in haskell.
14:24:42 <kuribas> well, maybe embedding a logic language is easy in lisp
14:24:42 <Lycurgus> elegantly
14:25:30 <kuribas> and harder in hs
14:25:38 <dmwit> Is there a v2-repl-alike which drops you into a repl with whatever old build was available? Bonus points for trying to build first and only using the old state if the build fails.
14:26:53 <monochrom> We need transactional file system right now!
14:27:07 <kuribas> Lycurgus: even then, a monadic approach would likely be good enough.
14:27:27 <kuribas> Lycurgus: lisp is great in pretending to be another language.  Haskell is always haskell.
14:27:36 <Lycurgus> kuribas, it sounds like ur relatively new to cl
14:27:56 <kuribas> Lycurgus: cl yes, I did scheme before hs.
14:28:13 <infinisil> monochrom: Soo, a DB?
14:28:16 <monochrom> Actually could you just identify a few files you can delete and that already puts you back into the old state?
14:28:44 <Lycurgus> kuribas, if you were looking for hindley miller type pkgs they'll more likely be in cl than scheme
14:29:42 <kuribas> Lycurgus: right :)
14:29:58 * hackage red-black-record 1.0.0.0 - Extensible records and variants indexed by a type-level Red-Black tree.  http://hackage.haskell.org/package/red-black-record-1.0.0.0 (DanielDiazCarrete)
14:30:13 <kuribas> Lycurgus: racket has types I believe?
14:30:31 <monochrom> OMG type-level red-black tree
14:30:56 <Lycurgus> kuribas, not sure but think so, something different from CLOS
14:31:37 <Lycurgus> CLOS would sorta be antithetical to it (scheme)
14:32:02 <Lycurgus> but pretty sure there is a clos of some kind for racket/scheme nonetheless
14:32:06 <kuribas> monochrom: those are cool, but in the end you need to wrap those phantom types in an existential, for it to be useful right?
14:32:38 <kuribas> Lycurgus: scheme has tinyclos
14:32:47 <monochrom> Depends on what you use it for, but yes.
14:33:28 <Lycurgus> kuribas, ah
14:33:59 <kuribas> Lycurgus: scheme isn't that different from CL though.  It's a bit more functional.
14:34:45 <Lycurgus> kuribas, lisp is the original FP
14:35:06 <kuribas> Lycurgus: not pure
14:35:30 <monochrom> That one I will take issue with on both counts: "original" and "FP".
14:35:30 <Lycurgus> pure elegance
14:35:41 <monochrom> Backus's FP is the original FP.
14:35:59 <Lycurgus> that and 5 bucks will get you a latte at starbucks
14:36:00 <monochrom> Lisp is not FP because it doesn't even make functions first-class.
14:36:15 <monochrom> Or rather, not FP enough.
14:36:43 <monochrom> I'm OK with allowing mutable variables.  I'm OK with "Scheme does FP".
14:36:58 * hackage red-black-record 1.0.0.1 - Extensible records and variants indexed by a type-level Red-Black tree.  http://hackage.haskell.org/package/red-black-record-1.0.0.1 (DanielDiazCarrete)
14:37:16 <monochrom> But seriously compare Scheme with Lisp first and ask why did people invent Scheme after Lisp existed.
14:37:19 <kuribas> monochrom: wouldn't that be haskell curry?
14:37:58 * hackage discord-haskell 0.7.1 - Write bots for Discord in Haskell  http://hackage.haskell.org/package/discord-haskell-0.7.1 (Aquarial)
14:39:03 <monochrom> I think I'll answer "Curry didn't implement it on a computer" :)
14:39:18 <monochrom> Actually I am not familiar with what Curry did.
14:40:41 <monochrom> I am more fond of Backus because on top of proposing a language he also proposes a new way of thinking.
14:42:06 <kuribas> monochrom: lambda calculus?
14:42:35 <kuribas> monochrom: oh, that was Church...
14:43:01 <monochrom> Maybe Curry did combinator logic.
14:45:23 <kuribas> right
14:47:19 <iqubic> Is there a way to get megaparsec to parse 1 or more letter characters and then return the result as Text.
14:48:00 <Pamelloes> Hi! I haven't written any haskell in probably 3 years or so and am considering using it for a small terminal application I need to make. What's the current way to get started writing haskell code?
14:48:03 <iqubic> funcName <- some letterChar -- TODO: funcName should be of type T.Text
14:48:15 <Welkin> Pamelloes: I remember you
14:48:52 <iqubic> This is the what I'm trying to do.
14:48:55 <Pamelloes> :)
14:49:04 <Welkin> Pamelloes: download the latest haskell platofmr (8.6.3) and then use `cabal init`, fill in your dependencies in your *.cabal, then run `cabal new-build`
14:49:09 <Welkin> platform*
14:49:29 <jle`> iqubic: you can fmap T.pack
14:49:33 <iqubic> That thing `funcName <-...` is in a do block.
14:49:38 <jle`> T.pack <$> some letterChar
14:49:40 <Welkin> for terminal apps use https://hackage.haskell.org/package/vty
14:49:40 <iqubic> jle`: Is that the best way to do it?
14:50:43 <monochrom> jle` always gives the best way, what are you talking about?
14:51:49 <jle`> if your underlying stream is Text (and not [Char]) then you can maybe hack something together using takeWhileP. but `T.pack <$> some letterChar` is probably the way that is most idiomatic for parser combinator style
14:52:08 <jle`> using primitives like takeWhileP basically break the abstraction
14:52:14 <Pamelloes> Welkin: Cool, thanks :)
14:52:38 <jle`> hm, they don't necessarily break the abstraction, but they don't really play well with the big picture either
14:52:43 <iqubic> Well, I want to know why this isn't working.
14:52:52 <jle`> why what isn't working?
14:52:54 <iqubic> I got the thing to be in type T.text.
14:53:05 <jle`> nice
14:53:41 <iqubic> But now I'm finding myself unable to do a case-insensitive comparison of two Text objects.
14:53:43 <monochrom> takeWhileP will lack memory, i.e., if you want "first char is a letter, afterwards both letters and digits are fine" then takeWhileP can't do it (alone).
14:54:33 <iqubic> monochrom: I want "letters only"
14:54:35 <jle`> if your underlying stream is [Char] then takeWhileP will definitely have no advantage over some letterChar, too, prob
14:55:06 <iqubic> Underlying Stream is T.Text
14:55:32 <jle`> iqubic: there are a couple of ways to do case-insensitive comparisons
14:55:43 <jle`> but also it's a tricky concept when you consider the whole unicode
14:55:58 <jle`> if you're just in ascii then you can do (==) `on` T.toLower
14:56:24 <Welkin> iqubic: use the CI typeclass
14:56:54 <Welkin> https://hackage.haskell.org/package/case-insensitive-1.2.0.10/docs/Data-CaseInsensitive.html#t:CI
14:57:08 <monochrom> Pretty sure we went through that a month ago.
14:57:16 <iqubic> We did.
14:58:07 <jle`> CI isn't quite the typeclass
14:58:26 <jle`> but still i'm always sort of hesitant about funky Eq instances
14:58:31 <Welkin> oh yeah
14:58:36 <Welkin> it's just a normal data type
14:58:52 <jle`> i always expect `x == y` to imply `f x == f y`
14:59:03 <Welkin> WAI uses CI (actually, http-types does)
14:59:09 <Welkin> which is the only reason I know about it
14:59:14 <Welkin> it's used for http headers
15:00:03 <iqubic> It's just that I want to have a megaparsec parser with CI as the stream. Lacking that, I'm just going to put T.toLower everywhere.
15:00:23 <Welkin> then go ahead and use it
15:00:34 <Welkin> it's funny to think that haskell has 5 different string types
15:00:37 <Welkin> rust has 3
15:00:47 <Welkin> c has only 2
15:00:59 <Welkin> many languages have 1
15:01:19 <Welkin> actually, c has only 1
15:01:31 <iqubic> Welkin: I'm not sure that megaparsec suppors that.
15:02:26 <jle`> you'd have to define an instance of Stream for CI, but i'm not sure if it'll be too beneficial
15:02:31 <MarcelineVQ> if the stream itself is supposed to be CI you could map toLower your input
15:02:34 <jle`> to make up for the up-front work
15:02:47 <kadoban> 5? All I can think of is String and Text
15:03:00 <zachk> welkin, 5? String, ByteString (and variants) and Text, am I missing some? 
15:03:08 <iqubic> kadoban: ByteString
15:03:09 <Welkin> kadoban: String, Lazy/Strict Text, Lazy/Strict ByteString
15:03:11 <kadoban> ByteString isn't really a string type IMO
15:03:28 <kadoban> Oh. Lazy/Strict. I guess technically, sure.
15:03:33 <Welkin> it is
15:03:39 <Welkin> erlang doesn't even have strings!
15:03:40 <MarcelineVQ> breakdown: http://blog.ezyang.com/2010/08/strings-in-haskell/
15:03:41 <jle`> yeah, i wouldn't really consider bytestring a "text" type.  maybe it's tautologically a string type?
15:03:44 <Welkin> it only has binaries
15:03:58 <Welkin> and treats binaries as strings if they only contain showable characters
15:04:04 <iqubic> what does erlang hav instead of stings?
15:04:09 <Welkin> binaries
15:04:16 <Welkin> bytestrings basically
15:04:26 <Welkin> well, bitstrings to be precise
15:04:31 <kadoban> Kind of eww. So it uses ascii everywhere or something then?
15:04:35 <Welkin> what?
15:04:43 <kadoban> Well how does it define "showable characters" ?
15:04:45 <Welkin> no, it uses unicode
15:04:59 <kadoban> Oh, characters are wide?
15:05:05 <mniip> I can't compile an older GHC with a newer GHC can I :(
15:05:08 <Welkin> there are no characters
15:05:14 <jle`> [Char] technically doesn't have to be considered a distinct string type, but it is given privileged status by the base library
15:05:15 <Welkin> they are a sequence of bits
15:05:31 <iqubic> What should I do if I want to just print out the value of a variable that is defined in a do block.
15:05:36 <kadoban> Ah, that's interesting. But a sequence of bits you still have to have an encoding on to treat as characters. What encoding does it use?
15:05:46 <jle`> iqubic: what do you mean by print?
15:05:48 <Welkin> utf8 I believe
15:05:50 <iqubic> I think trace will work, but I'm not sure.
15:05:51 <monochrom> I wouldn't consider Bytestring "string".  That's 1970s thinking.
15:06:01 <iqubic> What does `trace` do?
15:06:07 <Welkin> Debug.trace
15:06:09 <kadoban> Kind of neat then. An odd choice
15:06:10 <jle`> iqubic: it's useful for debugging
15:06:28 <iqubic> jle`: I need to do some debugging right now.
15:06:28 <Axman6> iqubic: I still you still haven't learnt how to google or read documentation :\
15:06:32 <Welkin> well erlang had no use for strings back in the 80s when it was developed for running telecom systems
15:06:33 <jle`> iqubic: i think of it as flagging something for the runtime: when you evaluate this, log this string to indicate that something is being evaluated
15:06:37 <Welkin> what would you use strings for?
15:06:45 <monochrom> And the co-existence of both lazy Text and non-lazy Text is a benefit not a loss.
15:06:46 <jle`> so `trace "hello" blahblah` is the same as `blahblah`
15:06:47 <kadoban> If nothing else, debugging, logging, etc.
15:06:50 <Welkin> it has atoms
15:06:57 <Welkin> so it doesn't need strings for readable identifiers
15:07:07 <jle`> except it's tagged by the runtime system to log "hello" when ghc tries to evaluate blahblah
15:07:17 <Axman6> @hoogle trace
15:07:18 <lambdabot> Debug.Trace trace :: String -> a -> a
15:07:18 <lambdabot> Linear.Matrix trace :: (Trace m, Num a) => m (m a) -> a
15:07:18 <lambdabot> Linear.Matrix trace :: (Trace m, Foldable m, Num a) => m (m a) -> a
15:07:33 <Welkin> someone should make Debug.tracer
15:07:34 <monochrom> Like no one would complain "C has 6 integer types, Pascal has only 1".
15:07:47 <jle`> so remember, trace doesn't actually print anything out, or trigger any printing
15:07:52 <monochrom> I mean as a complaint to C.
15:07:53 <Welkin> and it should be a joke about that videogame that I have never played but hear about constantly
15:08:18 <jle`> all it does is 'flag' a value for the runtime system for the ghc runtime to remember to log a string whenever that value is evaluated
15:08:28 <jle`> the evaluation of that value will trigger a print
15:08:39 <iqubic> so how do I see the value?
15:08:46 <Welkin> with your mind's eye
15:08:53 <jle`> iqubic: the same way you use any other haskell value
15:09:21 <jle`> a value is evaluated when you need it
15:10:18 <jle`> one trick you can do if you're in an effectful monad's do block is to add a `trace "hello" (return ())` line in the do block
15:10:41 <jle`> since >> for effectful monads has to evaluate the left hand side before it can go on to the right ahnd side
15:10:49 <jle`> if at least to figure out what the effects of the LHS are
15:11:13 <monochrom> Actually it has traceM and traceShowM for this too.
15:11:26 <jle`> ah neat :)
15:11:37 <monochrom> If you're specifically in IO, consider traceIO as well.
15:12:30 <monochrom> OK so now someone is going to complain "Haskell has 10 trace commands, C has only 1" again.
15:13:00 <monochrom> If someone does it, I recommend you to reply "C has 8 integers types, COBOL has only 1".
15:14:20 <dmwit> traceIO...
15:14:58 * jle` . o O ( traceIO = putStrLn )
15:15:01 <dmwit> Why is this not traceIO = hPutStrLn stderr
15:15:08 <dmwit> it is so complicated
15:15:35 <monochrom> debugBelch eh?
15:16:23 <jle`> dmwit: it's probably because it's used to implement the other Debug.Trace methods
15:16:34 <jle`> so it has to be robust against unsafePerformIO and other things you normally wouldn't use hPutStrLn with
15:16:56 <monochrom> It bloody calls out to FFI...
15:17:36 <dmwit> jle`: I see.
15:17:55 <jle`> that's the only thing i can think of
15:18:15 <jle`> it has to bypass the normal runtime
15:19:05 <monochrom> Ah OK.
15:19:15 <jle`> still i'm pretty sure `hPutStrLn stderr` would be sufficient in most single-threaded situations
15:21:28 <Welkin> if you say that aloud it sounds like you are stuttering
15:22:14 <Welkin> heh-put-stir-lun-stud-err
15:23:07 <Welkin> gotta save these precious few characters
15:28:38 <c_wraith> I actually pronounce that "std" sequence as "standard"
15:34:30 <wroathe> Is there a shorthand syntax for "import qualified except for these symbols"?
15:34:54 <wroathe> Like if I generally want the module qualified, but there's a couple of operators I'd rather just use as-is?
15:35:24 <aplainzetakind> You can put in two import statements.
15:35:35 <wroathe> aplainzetakind: Ah, so no shorthand then
15:36:06 <aplainzetakind> One qualified but `hiding (stuff)`, the other qualified (only, the, ones, you, want)
15:36:27 <aplainzetakind> the other not qualified I mean
15:38:01 <jle`> wroathe: it's something a lot of people talk about
15:38:15 <jle`> but there's nothing in the standard or in ghc as of right now
15:38:45 <bsima> ghcjs: internal error: Unable to commit -1906311168 bytes of memory
15:38:47 <Welkin> it's such a minor detail
15:38:55 <bsima> what does that error mean?
15:39:01 <Welkin> there are bigger fish to fry still
15:39:03 <bsima> i'm just getting started with ghjs
15:39:17 <Welkin> oh boy, have fun with ghcjs
15:39:21 <boj> bsima: that you ran out of memory
15:39:30 <bsima> :(
15:39:51 <bsima> i've got like 16GB
15:40:35 <boj> bsima: that should be plenty. we ran into the same thing last week, turns out building the SHA library was destroying it all. might be worth looking at which dep is doing useless building
15:41:04 <boj> in our case there was zero reason to build all of the SHA executables
15:42:11 <bsima> i think its bytestring-builder-0.10.8.1.0
15:47:30 <bsima> oh it fails on this module specifically https://hackage.haskell.org/package/constraints-0.10/docs/Data-Constraint-Unsafe.html
15:56:32 <Pamelloes> If I write (/ f x), is this \a -> a / (f x) or x / f?
15:59:20 <doyougnu> @ ((/) 3 2)
15:59:29 <shachaf> What happened when you tried it?
15:59:58 <doyougnu> @((/) 3 2)
15:59:59 <lambdabot> Unknown command, try @list
16:00:54 <doyougnu> > ((/) 3 2)
16:00:56 <lambdabot>  1.5
16:00:58 <doyougnu> ayyy
16:01:25 <doyougnu> @type (/)
16:01:26 <lambdabot> Fractional a => a -> a -> a
16:01:53 <Pamelloes> shachaf: Good point, I should've tried it instead of asking. I'll try to be more mindful in the future
16:11:27 <Welkin> tuple sections with infix operators perform as written
16:11:48 <Welkin> to use an infix operator as prefix, wrap it in parentheses exclusively
16:11:55 <Welkin> > (/) 3 4
16:11:56 <lambdabot>  0.75
16:12:12 <Welkin> > (/ 3) 4
16:12:14 <lambdabot>  1.3333333333333333
16:12:19 <Welkin> Pamelloes: ^
16:16:39 <Welkin> no way!
16:16:48 <Welkin> haskell on the erlang vm
16:16:49 <Welkin> https://github.com/etnt/Haskerl
16:17:06 <urzo> I have a situation where I may use delete my frequently, or deleteMin periodically.  The documented O() behavior is the same for both.  This is for psqueues HashPSQ/IntPSQ/OrdPSQ.  Are these operations actually the same running time regardless of the index I'm deleting?
16:18:48 <urzo> I guess I expected deleting the minimum of a priority queue would be faster
16:22:15 <Welkin> it's funny to see so many variations on good languages
16:22:47 <urzo> I'm switching a query-response protocol that uses a lookup table to delete pending queries when they receive a response or when they timeout to a priority-queue based design where I peel responses or timeouts from the front of  a priority queue.  I'm wondering if I should leave the code that cleans up the responded queries immediately or if i should handle that cleanup in the same thread as the time-outs 
16:22:53 <Welkin> haskell has frege (jvm), hackett (racket), haskerl (subset in erlang)
16:23:00 <Welkin> I am definitely missing some
16:23:46 <Welkin> erlang has lisp flavored erlang, Elixir, Joxa, Luerl, Erlog, Haskerl
16:24:00 <urzo> the advantage of the switch is to cut back on the number of threads managed by the rts
16:24:39 <urzo> since parallel queries requires multiple mvar-blocked threads in my current design
16:24:54 <Welkin> idle threads are put to sleep and don't do anything until awoken
16:24:56 <Welkin> don't they?
16:25:13 <Welkin> you could have hundreds of thousands or millions of threads
16:25:22 <urzo> yeah, but it turns out i'm ending up with thousands of threads
16:25:52 <urzo> okay, but i think i'm probably abusing the shecheduler and i suspect fewer threads will make for easier debug sessisons
16:27:30 <urzo> anyway, i just want to implement the alternative and see how it goes
16:28:30 <urzo> i already use priority queues extensively in other parts of the code, so it doesn't cost anything dependency-wise
16:30:37 <urzo> having millions of blocked threads probably does add some cost to scheduling the unblocked ones
16:49:54 <mniip> is there a package for interfacing with discord?
16:50:05 <mniip> I'm looking at discord-hs but it's making my eyes bleed
16:52:54 <MarcelineVQ> mniip: http://hackage.haskell.org/package/discord-haskell-0.7.1 was linked in here 2 hours ago, idk anything about it tho
17:13:50 <Pamelloes> Is there a good way to short circuit an IO function analogous to `return' in a c-style language?
17:14:46 <glguy> You can use (ExceptT e IO) http://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Except.html to get that kind of behavior
17:15:50 <Pamelloes> Thanks!
17:22:35 <mouse07410> If the executables I build will run on my system only - would there be any reason NOT to configure "dynamic-executables: true"?
17:33:59 <Pamelloes> Where can I find a good description of operator precedence and associativity (including function evaluation)? I can't seem to find any good references via google
17:37:36 <phadej> function application binds the tightest
17:38:15 <phadej> otherwise this (tongue-in-cheek) lists operators which are defined in base: http://hackage.haskell.org/package/acme-operators-0.2.0.0/docs/Acme-Operators-Base.html; but there are no table summarising their fixities, unfortunately
17:38:51 <phadej> ah, crap; haddock for some reason doesn't show all fixities
17:38:58 <phadej> but you can check then via
17:39:00 <phadej> :i (.)
17:39:06 <phadej> in ghci
17:39:21 <phadej> infixr 9 .
17:39:56 <phadej> when unsure, parenthise
17:40:28 <glguy> Pamelloes: Is your question ask what precdences mean and what left/right/non-associative means?
17:40:50 <glguy> or are you wanting to see a table of the precedences of the common operators defined in base?
17:41:03 <phadej> https://www.haskell.org/onlinereport/decls.html found, there's a table Precedences and fixities of prelude operators
17:42:42 <Pamelloes> phadej: Thank you! That's exactly what I was looking for
17:53:28 * hackage leancheck 0.9.0 - Enumerative property-based testing  http://hackage.haskell.org/package/leancheck-0.9.0 (rudymatela)
17:56:38 <aplainzetakind> I ended up writing something like `traverse sequence . sequence . traverse foo`, where foo :: a -> (a, m b), in order to achieve [a] -> m [(a, b)]. Is there a more readable way to do this?
17:58:42 <phadej> :t \foo -> traverse foo
17:58:43 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
17:58:56 <phadej> isn't it just traverse
17:59:07 <phadej> :t \foo -> traverse (foo :: Int -> Maybe (Int, Char))
17:59:08 <lambdabot> Traversable t => (Int -> Maybe (Int, Char)) -> t Int -> Maybe (t (Int, Char))
18:00:11 <phadej> :t traverse sequence
18:00:12 <lambdabot> (Monad f, Traversable t2, Traversable t1) => t1 (t2 (f a)) -> f (t1 (t2 a))
18:00:23 <phadej> :t traverse sequence . sequence
18:00:25 <lambdabot> (Monad t1, Monad f, Traversable t2, Traversable t1) => t2 (t1 (f a)) -> f (t1 (t2 a))
18:01:06 <phadej> ah, sorry; i missread your `foo` type
18:03:30 <iqubic`> hello
18:03:30 <phadej> the key, is that you want to traverse your list only once, so single traverse
18:03:47 <phadej> :t \foo -> traverse (sequenceA . foo)
18:03:48 <lambdabot> (Traversable t2, Traversable t1, Applicative f) => (a1 -> t2 (f a2)) -> t1 a1 -> f (t1 (t2 a2))
18:04:04 <phadej> this looks more right, aplainzetakind; dosn't it?
18:04:07 <phadej> iqubic: hi
18:04:43 <aplainzetakind> phadej: I'm trying to sort out all the parameters, it's easy to get lost.
18:05:28 * hackage leancheck-instances 0.0.2 - Common LeanCheck instances  http://hackage.haskell.org/package/leancheck-instances-0.0.2 (rudymatela)
18:05:44 <aplainzetakind> phadej: Yes I think this does it.
18:06:05 <aplainzetakind> phadej: Thanks.
18:06:16 <phadej> aplainzetakind: try using
18:06:17 <phadej> :t for
18:06:18 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
18:06:32 <phadej> so you can write for xs $ \x -> ...
18:06:47 <phadej> than you can make it point-free if it looks like it's possible
18:10:11 <Pamelloes> Why does main = return (error "Exception!") evaluate without logging the exception?
18:10:53 <phadej> because main's value isn't evaluated
18:11:04 <phadej> you can try main = return "foobar"
18:11:50 <phadej> if you want it to fail, use `fail` :)
18:12:47 <Pamelloes> That makes sense
18:13:25 <iqubic> So, Debug.traceShow isn't printing anything to the console.
18:14:20 <sm> iqubic: probably not getting evaluated then
18:14:26 <sm> due to laziness
18:14:44 <iqubic> sm: You are probably right.
18:16:36 <iqubic> I assumed that the boolean guard portion of a list comparison was always evaluated.
18:17:34 <iqubic> [x | x <- functions, traceShow (T.toLower funcName) (T.toLower funcName) == x]
18:18:08 <iqubic> functions::[T.Text]
18:18:20 <iqubic> Not sure why traceShow isn't being evaluated.
18:18:35 <phadej> if functions is empty?
18:19:04 <phadej> fyi, traceShowId
18:20:12 <iqubic> http://dpaste.com/243GQCY
18:20:20 <iqubic> No. It isn't empty.
18:20:20 <sm> or the whole list is not getting evaluaged
18:20:25 <phadej> true
18:20:28 <sm> evaluated
18:21:13 <iqubic> It must be getting evaluated, because I'm taking the head of the list.
18:21:32 <sm> that is surprising, then
18:21:50 <sm> you're taking the head, and *that* is being evaluated I assume
18:22:05 <iqubic> It is.
18:22:53 <phadej> head (1 : undefined)
18:22:55 <phadej> > head (1 : undefined)
18:23:04 <lambdabot>  1
18:25:19 <phadej> head [ x | x <- [1..20], traceShowId x < 10 ] -- prints 1\n1 - no more no less
18:25:44 <iqubic> Question: If I'm pulling a function out of a list and then calling said function, I assume haskell has to evaluate things far enough that it knows which function I'm calling.
18:26:01 <iqubic> phadej: I see. I'm not sure I understand why that is.
18:26:35 <phadej> iqubic: https://www.well-typed.com/blog/2017/09/visualize-cbn/
18:27:55 <iqubic> Oh, wait... my issue isn't even an issue of the list comprehension failing.
18:28:03 <iqubic> My issue is earlier in the do block.
18:29:10 <iqubic> The traceShowId works just fine.
18:29:52 <iqubic> If a guard statement earlier in the do block fails, then my list comprehension is never run.
18:32:32 <iqubic> I'm confused here.
18:32:49 <sm> there we go
18:33:07 <iqubic> Does it make sense to call `head` with two arguments?
18:33:30 <phadej> > head [show] 2
18:33:32 <lambdabot>  "2"
18:33:50 <iqubic> Yeah, that's basically what I'm doing. Why does that work?
18:33:51 <Pamelloes> Given a list [a], I would like to produce a list of n lists where the kth list contains the elements whose index in the original list are congruent to k mod n. Is there a standard way to do this, or do I need to make my own function?
18:34:35 <sm> it's (head [show]) 2
18:35:02 <iqubic> Is that how functions work in haskell?
18:35:16 <sm> yup, they bind very tightly
18:35:24 <iqubic> I see.
18:36:59 <iqubic> Alright... So my error was that I was running toLower to late in the do block, causing a guard to fail, meaning the showTraceId never ran.
18:37:17 <iqubic> So moving the call to toLower earlier makes everything work fine.
18:42:03 <iqubic> > case mapM return [1..] of Just (x:_) -> x
18:42:11 <lambdabot>  mueval-core: Time limit exceeded
18:42:11 <lambdabot>  mueval: ExitFailure 1
18:42:18 <iqubic> What just happened there?
18:44:50 <doyougnu> iqubic: i think it is as simple as you called mapM on an infinite list
18:45:07 <doyougnu> > case mapM return [1..3] of Just (x:_) -> x
18:45:08 <lambdabot>  1
18:48:36 <doyougnu> > case mapM return [1..5] of (x:_) -> x
18:48:38 <lambdabot>  [1,2,3,4,5]
18:48:46 <iqubic> huh?
18:49:41 <MarcelineVQ> mapM return [1..5] is [[1..5]]
18:50:01 <MarcelineVQ> in that context at least
18:50:23 <maerwald> I'm wondering why Data.Set doesn't have a manual implementation of forM
18:50:40 <maerwald> I feel like I wrote it 3 times already and every time I look for it I forgot where I put it
19:27:27 <julianleviston> is there a channel for C?
19:27:43 <julianleviston> (Sorry for the OT post)
19:30:43 <julianleviston> Found it. ##C.
19:39:01 <MarcelineVQ> wonder why it's two #
19:41:12 <julianleviston> My guess was something to do with the fact that its only 1 letter and this IRC server seems to have some reserved thingies going on
19:41:38 <geekosaur> # is "owned". who owns C?
19:41:59 <geekosaur> well, more precisely, there's some registered group running it
19:42:06 <geekosaur> (as with #haskell)
19:52:28 * hackage menshen 0.0.0 - Data Validation  http://hackage.haskell.org/package/menshen-0.0.0 (leptonyu)
19:57:06 <doyougnu> anyone know if there is a function that is like alternativeWith Or MonadPlus with? For example (<|>) would just be alternativeWith id.
19:58:58 * hackage acme-circular-containers 0.1.0.0 - Spineless containers which are fast to read but inefficient to update  http://hackage.haskell.org/package/acme-circular-containers-0.1.0.0 (gelisam)
20:12:06 <Pamelloes> I've been writing to much latex: I keep writing \mapsto instead of -> when defining lambdas
20:23:43 <Pamelloes> I know I can do ['A'..'Z'] to get all the letters in between, but is there a way to do something like ['AA'..'ZZ'] and get all two letter sequences in between?
20:24:08 <glguy> > replicateM 2 ['A'..'Z']
20:24:09 <lambdabot>  ["AA","AB","AC","AD","AE","AF","AG","AH","AI","AJ","AK","AL","AM","AN","AO",...
20:24:57 <Pamelloes> Ooh, awesome
20:37:01 <Pamelloes> Suppose I have a program where the user pipes a file's contents into it via stdin. Is there anyway after this file has been read to prompt the user some y/n question?
20:37:17 <glguy> Not really, no.
20:37:30 <Pamelloes> That's unfortunate
20:46:03 <mniip> if you know the input is a tty, you can read until EOF, and then continue reading
20:46:18 <mniip> a ctrl-D on a tty will trigger a partial read
20:46:43 <mniip> but that provides a counterintuitive interface and no way to script around your program
20:48:08 <clever> Pamelloes: under linux, you can open /dev/tty for read/write
20:48:23 <clever> Pamelloes: that will bypass all redirection, and force a connection to the user
20:48:47 <clever> i think it also works on darwin, but havent confirmed
20:49:17 <clever> ssh uses that for example, to allow `ssh remotehost 'cat > remotefile' < localfile` and still get a pw prompt
20:56:57 <geekosaur> it worksâ€¦ if nothing else is reading from the terminal
20:59:34 <geekosaur> you're also potentially in trouble if you decide later you want to script tht, because /dev/tty is the controlling terminal and can't be intercepted
21:04:26 <Pamelloes> Interesting. Definitely seems like more hassle then its worth
21:04:56 <mniip> geekosaur, well you can make a new pty
21:04:58 * hackage haskeline 0.7.5.0 - A command-line interface for user input, written in Haskell.  http://hackage.haskell.org/package/haskeline-0.7.5.0 (JudahJacobson)
21:05:06 <mniip> with a scripting utility called "script"
21:06:00 <geekosaur> rube goldberg machine ahoy
21:06:48 <mniip> also opening /dev/tty has issues
21:06:59 <mniip> like I can't resume a SCREEN session after switching user
21:07:03 <mniip> without 'script' that is
21:08:48 <Pamelloes> I have a list [IO Bool] where each action does something and then asks "Continue?" and then returns true if the user says yes. Is there a good way to start evaluating the list until False is reached?
21:09:11 <Pamelloes> I tried using sequence, but that forces the whole list to be evaluated, which is no good in my case because the list is infinite
21:10:32 <mniip> andM from Control.Monad.Extra
21:10:34 <geekosaur> this sounds like something monad-loops ought to have
21:11:10 <mniip> or from Control.Monad.Loops
21:11:11 <mniip> yes
21:11:39 <Pamelloes> Awesome!
21:12:25 <Welkin> you forgot frooty-loops
21:13:58 * hackage terminfo 0.4.1.4 - Haskell bindings to the terminfo library.  http://hackage.haskell.org/package/terminfo-0.4.1.4 (JudahJacobson)
21:15:57 <inkbottle> ML family languages use data-constructors /inside/ records, when Haskell uses a data-constructor "outside" and plain functions to access the components of the product: Are there language extensions where records are more like ML records?
21:16:50 <Welkin> I haven't seen that
21:17:54 <nyc> I suspect it's mostly syntax for record field access.
21:20:54 <inkbottle> In the example there: https://stackoverflow.com/a/38052886, there are two different accessors of /same/ name. Is that code correct?
21:21:48 <mniip> on the same datatype
21:21:49 <mniip> yes
21:22:12 <inkbottle> OK
21:22:21 <mniip> 'name' is a partial function that extracts the name out of a B or a C, but errors on A
21:22:29 <mniip> of type X -> String
21:22:31 <mniip> no issue here
21:22:55 <inkbottle> Tx
21:23:05 <Welkin> it's very useful when you have multiple constructors in a type with fields that are the same
21:23:12 <Welkin> as long as the types are the same it works
21:25:00 <inkbottle> data A = A {a::Int}; data B = B {a::Int}; however, won't work?
21:25:17 <Welkin> no
21:25:20 <inkbottle> ok
21:25:58 <Welkin> `data A = B { name :: String } | C { name :: String }` works because name :: A -> String
21:26:30 <inkbottle> Yes, I'm glad I've learned that ;)
21:53:48 <iqubic> What does `return` do  when it's in the middle of a do block?
21:55:08 <MarcelineVQ> what does it do elsewhere?
21:55:21 <iqubic> :t return
21:55:22 <lambdabot> Monad m => a -> m a
21:55:44 <iqubic> So it just takes a and wraps in a monadic context?
21:57:48 <MarcelineVQ> yeah if that's the terminology you prefer, importantly it's a context that does nothing but yield the a
22:00:15 <iqubic> Right.
22:00:17 <iqubic> I see.
22:02:39 <jle`> iqubic: it's a "no-op", essentially
22:02:50 <jle`> iqubic: that's actually a monad law
22:02:52 <MarcelineVQ> In Applicative return is called pure, and while I'm not entirely sure why it's called that it's my belief that it's called that because it does nothing but yeild the a. pure a is literally 'purely a'
22:03:11 <jle`> or yeah, an Applicative law too.
22:03:31 <jle`> iqubic: the law is that `pure x *> y = y`
22:03:45 <jle`> so `pure x` or `return x` is supposed to be equivalent to not having it in a sequence at all
22:08:09 <iqubic> What's the proper way to format an if then else block in Haskell
22:08:19 <iqubic> I haven't actually used one in a long long time.
22:14:04 <iqubic> Actually, I'm sure there's a better way to do what I want.
22:14:21 <iqubic> `if cond then Nothing else Just x`
22:15:43 <Welkin> if
22:15:44 <Welkin> then
22:15:45 <Welkin> else
22:15:56 <iqubic> On three separate lines?
22:15:59 <Welkin> yes
22:16:24 <iqubic> And is there a standard library to do what I want?
22:16:36 <iqubic> Or is the if statement the best way to do this?
22:16:44 <Welkin> expression
22:16:57 <Welkin> if you can write it very simply, do that
22:16:59 <iqubic> Right. if is an expression in Haskell.
22:17:03 <Welkin> you don't always need a library function
22:17:07 <iqubic> Welkin: It is that simple.
22:17:20 <Welkin> if then else is a case expression in disguise
22:17:25 <Welkin> it's up to personal prefernce
22:17:36 <Welkin> like with maybe/either vs case expressions
22:17:43 <iqubic> I'm using this with mapMaybe to filter things out of a list, while also running map.
22:18:02 <iqubic> which I assume is the intended purpose of that function.
22:18:07 <Welkin> :t mapMaybe
22:18:08 <lambdabot> (a -> Maybe b) -> [a] -> [b]
22:18:22 <Welkin> so it turns them all into maybes?
22:18:24 <Welkin> why?
22:18:25 <iqubic> No.
22:18:47 <kadoban> It's map but you can leave things out
22:18:54 <Welkin> may as well use a fold
22:19:07 <iqubic> If the function returns Nothing, then that element isn't added into the resulting list. If the function returns Just x, then x is added to the list.
22:19:19 <Welkin> okay
22:19:28 <iqubic> Welkin: how will a fold help me?
22:19:29 <Welkin> but that's not map
22:19:42 <Welkin> map does not change the structure of the sequence
22:19:47 <Welkin> that is a fold
22:19:49 <Welkin> so the name is wrong
22:19:51 <iqubic> No. It's map + filter.
22:20:14 <Welkin> a fold is just a more explicit way to write that
22:20:27 <iqubic> how would you do it with a fold?
22:20:28 <Welkin> you can choose to include something in your result or not
22:20:43 <kadoban> I don't see anything wrong with mapMaybe
22:21:07 <iqubic> I want to go from [a] -> [b] while omiting certain elements that don't match the criteria.
22:21:17 <Welkin> go ahead
22:21:22 <iqubic> I will.
22:21:24 <Welkin> I feel the name is wrong/cofusing though
22:21:36 <iqubic> I find mapMaybe to be the best tool for the job.
22:21:54 <Welkin> wait
22:21:58 <Welkin> just use a filter
22:22:46 <iqubic> But I also want to do map at the same time.
22:22:56 <iqubic> I want map + filter. At the same time.
22:26:55 <MarcelineVQ> what does your actual code for this look like?
22:28:19 <Welkin> catMaybes . map
22:28:30 <Welkin> it does the same thing
22:29:01 <MarcelineVQ> then why suggest it :X
22:30:11 <MarcelineVQ> Rather, I mean if it's meant as an improvement but does the same thing why suggest it
22:30:17 <MarcelineVQ> We suggests same things all the time here hehe
22:30:21 <MarcelineVQ> *suggest
22:30:53 <Welkin> I feel it's more clear
22:30:57 <Welkin> and clarity matters
22:31:14 <Welkin> but haskell is the kind of language where there are a million ways to write the same thing
22:31:21 <Welkin> which can be good and bad
22:31:50 <MarcelineVQ> it's more clear if you know catMaybes and not mapMaybe, but the other one is vica-versa :>
22:33:27 <MarcelineVQ> on that token map f (filter p xs) or filter p (map f xs) will do the job too, if Maybe is only being used as a decision structure
22:37:51 <nshepperd> mapMaybe seems just fine to me
22:45:05 <iqubic> maybe is only being used as a decision structure in my code.
22:46:19 <iqubic> Well, this particular section.
22:53:45 <nshepperd> map+filter can sometimes require partial functions. not sure if that's what MarcelineVQ refers to with '[not] only used as a decision structure'
23:13:00 <dminuoso> So.. I every time I keep writing on this mission critical piece of software I realize I should be doing this in Erlang. :(
23:13:19 * dminuoso wants OTP for Haskell
23:17:28 * hackage menshen 0.0.1 - Data Validation  http://hackage.haskell.org/package/menshen-0.0.1 (leptonyu)
23:21:43 <MarcelineVQ> dminuoso: useful thing to have, got a use in mind?
23:22:34 <iqubic> dminuoso: What is OTP?
23:24:48 <iqubic> Is that One Time Password?
23:24:50 <dminuoso> MarcelineVQ: Well I guess there's multiple things I really want. Better thread isolation (so that FFI fuckups don't take down my entire Haskell process), Supervisor for better fault tolerance are the two things that I'm wishing for at this very moment.
23:25:00 <dminuoso> iqubic: OTP is the Open Telecommunications Platform.
23:25:05 <dminuoso> It's basically the role reason Erlang is used.
23:25:09 <dminuoso> *sole reason.
23:25:34 <MarcelineVQ> I had also figured you meant one time password hehe :>
23:25:45 <iqubic> I see. I don't know anything about Open Telecom.
23:26:07 <dminuoso> iqubic: It's just an unfitting name really, because Erlang/OTP are products out of the telco department.
23:26:26 <dminuoso> OTP is just a.. hum.. "framework" for writing highly available, fault tolent and distributed applications.
23:26:32 <dminuoso> Haskell Cloud is largely OTP inspired
23:27:47 <iqubic> What is Haskell Cloud? Is that like distributed Haskell? I.E. meant to be run in parallel.
23:28:16 <dminuoso> iqubic: Single machine concurrency we have one of the best implementations that exist already.
23:28:28 <dminuoso> It's multi-machine concurrency where things get interesting.
23:28:42 <iqubic> Do we have multi-machine systems yet?
23:29:16 <dminuoso> iqubic: Setups with more than one computer? I dont know, you tell me.
23:30:25 <iqubic> I meant multi-machine conurrency. Is that a thing yet?
23:30:32 <dminuoso> iqubic: Absolutely yes. Erlang/OTP does it.
23:30:56 <dminuoso> iqubic: Essentially all the worlds telecommunication infrastructure runs on it.
23:31:13 <dminuoso> Well, large parts of it at least.
23:31:15 <iqubic> I don't know Erlang. Is it a functional programming language? Is it worth learning?
23:31:30 <dminuoso> iqubic: Any language that broadens your horizon is worth learning.
23:32:48 <iqubic> dminuoso: I found that haskell has, and still is expanding my horizons.
23:33:11 <iqubic> I'm not sure I want to take the time to learn a whole new language like Erlang.
23:33:28 <kadoban> Erlang is definitely on my list
23:33:32 <dminuoso> iqubic: Erlang won't take you long. It's a rather simplstic language.
23:33:50 <dminuoso> iqubic: You could, if you preferred, start with Elixir (you still get access to OTP).
23:34:16 <dminuoso> Both languages are somewhat terrible though.
23:34:27 <iqubic> What benefits does Erlang have over Haskell?
23:34:31 <dminuoso> OTP.
23:34:56 <dminuoso> Tools for fault tolerance, zero downtime maintenance. 
23:35:25 <iqubic> Those aren't really my project domains. I don't work with those areas too often.
23:36:02 <iqubic> I know absolutely nothing about how the actor based concurrency works at all.
23:36:22 <dminuoso> iqubic: At any rate, erlang is really easy to pick up. It has some notions of immutable data, case discrimination with pattern matching.
23:36:47 <dminuoso> If you know Haskell, Erlang should be mainly syntax to learn.
23:37:18 <dminuoso> higher order functions..
23:37:28 <dminuoso> There's nothing novel about the language. :)
23:37:44 <iqubic> I'd still have to learn the concurrency features.
23:37:59 <iqubic> that's the novel part, right?
23:38:02 <dminuoso> Right.
23:47:11 <fresheyeball> :q
