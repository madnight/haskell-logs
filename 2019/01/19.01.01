00:54:14 <nyc> I almost always use LaTeX-style literate Haskell.
01:03:15 <nyc> I forget all of the directives for lhs2TeX to format code fragments in comments as if they were code. I don't often actually comment extensively, but if I were actually writing code for reuse, I would.
01:40:18 <coldpress> nyc: looks very interesting
01:40:32 <nyc> What else is there besides GADT's in Haskell these days?
01:41:01 <nyc> coldpress: lhs2TeX?
01:56:52 * hackage passman 0.1.1 - a simple password manager  http://hackage.haskell.org/package/passman-0.1.1 (jlamothe)
02:00:47 <coldpress> nyc: i'm just a beginner, and not Haskell-specific, but have you seen the (relatively) new type classes, e.g. Arrows, and Lenses?
02:01:47 <julianleviston> Lenses aren’t typeclasses?
02:02:05 <nyc> coldpress: I probably need to learn more about Arrows. Lenses I'm less familiar with.
02:03:12 <coldpress> right, lenses are functional references, sorry
02:03:30 <julianleviston> they’re usually just type aliases… I thought the stuff happening in the world of Effects were interesting.
02:16:23 <nyc> julianleviston: What are Effects?
02:21:20 <coldpress> nyc: wow thc looks even more interesting
02:21:27 <coldpress> *ths, oops
02:22:42 <nyc> coldpress: What's THS?
02:22:55 <coldpress> https://wiki.haskell.org/Textual_Haskell_source
02:26:20 <nyc> coldpress: I hadn't thought of that. It could be useful.
02:29:29 <nyc> Bananas, lenses, envelopes, and barbed wire was the paper i expected Lenses to have to do with.
02:29:57 <julianleviston> nyc: things like this: http://hackage.haskell.org/package/freer-simple
02:30:09 <julianleviston> nyc: ah, those lenses are bracket lenses, not the other lenses :)
02:30:56 <julianleviston> nyc: the banas paper is about recursion schemes, not lensing (it came out before Lenses was a thing)
02:31:43 <julianleviston> nyc: the effects stuff are ways of dealing with effects other than using MTL, or sometimes *by* using MTL.
02:32:07 <nyc> julianleviston: I'm completely unfamiliar with the new sort of lensing.
02:32:38 <julianleviston> nyc: lenses are functional focuses. (getters and setters would be examples of concrete functions that use focuses)
02:32:48 <coldpress> https://en.wikibooks.org/wiki/Haskell/Lenses_and_functional_references
02:33:26 <julianleviston> nyc: so you might have, say, _2, which is a lens that focuses on the second element of a pair, for example, then you can use another function to turn that into a getter, and another to turn that into a setter, and another to turn it into a modification, etc.
02:34:13 <julianleviston> nyc: it’s not super useful unless you’re doing a lot of deep data structure manipulation, I don’t think.
02:34:27 <julianleviston> nyc: like, say, manipulating state in a Snap application, for example.
02:35:00 <julianleviston> the beauty of them is that they’re composable.
02:35:31 <nyc> julianleviston: record components and array elements sound typical.
02:36:41 <julianleviston> sure… but it’s more useful when you want to, say, traverse into a deep structure — maybe you have a list of Users, and they have associated users, and you want to get the first one if that exists — then you can compose various types of “Optics” (the general name for what a lens is) to get your “it might exist or it might not” value out of each one, for example...
02:36:57 <julianleviston> they’re insanely powerful.
02:37:42 <julianleviston> and, possibly, encapsulate some large subset of the useful typeclasses in FP ;-)
02:38:42 <julianleviston> what’s a Prism, for example? it’s a focus on some portion of a Sum type… it might be there, or it might not.
02:39:15 <coldpress> it's OOP rehashed
02:39:20 <julianleviston> kind of.
02:39:58 <nyc> I'm foggy on what they do besides act as accessors of components.
02:40:07 <julianleviston> a lot of optics composition definitely looks and behaves like dot-method syntax from OOP… only, you get this generality which doesn’t exist in OOP… it’s kind of better OOP.
02:40:28 <julianleviston> (I’m not against OOP btw — its ideas are incredibly useful)
02:40:58 <julianleviston> just… maybe.. what’s super easy to do in OOP is incredibly difficult to truly understand and think about
02:41:52 <julianleviston> and maybe the core idea from OOP is actually message sending, which is a different kind of thing that dot method call syntax :)
02:42:25 <julianleviston> in which case, probably cloud haskell’s ideas are nicer versions of this (basically actors, but with types)
02:44:46 <julianleviston> nyc: a lens is a focus, as a function on a Functor. By themselves they don’t do anything. The way they’re constructed means they can be composed together to focus *more deeply*. There are various additional functions that let you do various things with these focuses.
02:46:44 <nyc> julianleviston: It may take me a while to grok.
02:47:39 <julianleviston> it’s usefuless trying to understand them (in my opinion) without first understanding types, type variables, typeclasses and the Functor typeclass. That doesn’t mean you can’t use them, but it’ll be not super easy.
02:48:07 <julianleviston> it’s useless* (I meant to say)
02:49:28 <nyc> julianleviston: Those aren't new to me.
02:51:48 <julianleviston> Awesome.
02:52:03 <julianleviston> the broad concepts are easy.
02:52:14 <julianleviston> you often find yourself writing functions to change data on things.
02:52:24 <julianleviston> say you have a field of a record and you want to change it. Sweet. Easy.
02:52:58 <julianleviston> now maybe you want to embed that thing in another thing (say a shop)… you’d have to write another function that takes shops and transforms the thing, unwrapping and rewrapping the shop.
02:53:38 <julianleviston> lenses let you instead write one function to focus on the thing, and you already have your function that will modify the thing… so then you take your lens and run your function without rewriting it or writing a unwrap/rewrap function.
02:53:50 <julianleviston> they essentially handle all the unwrapping and rewrapping for you.
02:54:25 <julianleviston> the “function to focus on the thing” is essentially building a lens.
02:55:36 <nyc> Applicative is semi-new to me. I've been out of touch for 10-15 years or more.
02:55:57 <julianleviston> You only really need to understand Functor to understand lens.
02:56:32 <julianleviston> but, like with most of this stuff, it’s best to only use it when you have a need. The need pattern is “when you find yourself unwrapping and rewrapping”.
02:56:55 <nyc> Functor isn't so tough.
02:57:25 <julianleviston> people usually get thrown because the type synonym for Lens is so general.
02:57:51 <julianleviston> however… one can simply it… and say… okay there’s a simple verson of lens that is really a function from Functor f => f a -> a
02:58:16 <julianleviston> then if you say, well, the a might actually be transformed in the process, it becomes Functor f a => f a -> b
02:58:23 <julianleviston> and then you say you might want to update it instead...
02:59:08 <nyc> I thought there was already syntactic sugar for array and record updates.
02:59:25 <julianleviston> record updates, yep.
02:59:31 <julianleviston> don’t know about array updates tho.
02:59:41 <nyc> I guess it's for things more deeply buried.
02:59:44 <julianleviston> but this isnt updating or accessing...
02:59:46 <julianleviston> it’s FOCUSING
02:59:52 <julianleviston> you *can* update and access with them
03:00:05 <julianleviston> but you can also modify in place, or transform, or change the outer or inner type
03:00:31 <nyc> Or buried within indeterminate layers.
03:00:50 <julianleviston> beacuse it’s so general, the lens type becomes… type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
03:00:59 <julianleviston> because the functor can be the identity functor.
03:01:16 <julianleviston> you think of it in two pieces… a -> f b and then s -> f t
03:01:59 <julianleviston> the s and t are the “surrounding structure” and the a and b are the “inner content” of the source and return types, respectively.
03:02:39 <julianleviston> so, if you update the “inner type” then you *must* update the “outer type* which is why it has four types 
03:03:07 <julianleviston> by outer type and inner type I mean the type of the entire thing, and teh type of the focused thing respectively.
03:05:38 <julianleviston> if all you were doing is say getting the second element of a pair out, the type would be… Lens (t1,t2) (t1,t2) t2 t2… coz the S and T types are the same, and the A and B types are the same (no transformation on either the structure or the content of the focus).
03:05:54 <julianleviston> (capitalization was just for emphasis — actually wrong)
03:06:18 <julianleviston> oops Lens (t1,t2) (t1,t2) t2 t2 sorry.
03:06:41 <julianleviston> Anyway hopefuly that made things *more* clear not the opposite :)
03:07:42 <nyc> I'm guessing it's mostly composition of functions.
03:09:59 <julianleviston> mmm… the types get super confusing unless you know all the pieces (and because it’s incredibly generalized), and there are lots of them. Also, the library has about 20 operators for convenience, which also makes things super confusing
03:11:18 <julianleviston> Well… like check this out:
03:11:20 <julianleviston> > view _2 (1,2)
03:11:23 <lambdabot>  2
03:11:32 <julianleviston> > view (_2 . _2) ((1,2),(3,4))
03:11:34 <lambdabot>  4
03:11:43 <julianleviston> So that makes sense with what I was saying, right?
03:11:51 <nyc> What's this underscore syntax?
03:12:02 <julianleviston> if I tell you view is the function that takes a lens, and _2 is a lens that focuses on the second element of something.
03:12:14 <julianleviston> view is a function that takes a lens and turns it into a *getter*
03:12:44 <nyc> Is it built into ghc?
03:12:53 <julianleviston> then you can see that (_2 . _2) is composing “focus on the second item” with “focus on the second item” to make “focus on the second item of the second item”
03:13:02 <julianleviston> no, but lambdaboty has it loaded
03:13:05 <julianleviston> lambdabot*
03:13:25 <julianleviston> So, that makes sense, yeah?
03:15:46 <nyc> Yes, though I've rarely run into cases I can imagine it being useful above hand coding things.
03:16:18 <julianleviston> that’s because I’m using a super simple example to illustrate it.
03:17:17 <nyc> modify (second (+1)) etc. are times I've used it.
03:17:27 <julianleviston> oh so you’ve used lens before.
03:17:47 <julianleviston> > over _2 (+1) (1,2)
03:17:49 <lambdabot>  (1,3)
03:17:56 <nyc> No, that was just a state monad.
03:18:24 <julianleviston> ok.
03:18:53 <julianleviston> You’d probably grok the lens tutorial pretty easily then: http://hackage.haskell.org/package/lens-tutorial-1.0.3/docs/Control-Lens-Tutorial.html
03:19:04 <WarzoneCommand> hmm question about lenses and vectors. If I do something like: myDataType&lensToAccessAnImmutableVector.traverse %~ (+1)  ; is that guaranteed to be O(n) (as one would hope)? or do I have to do myStructure&lensToAccessMyImmutableVector %~ fmap (+1) instead?
03:20:07 <WarzoneCommand> and how would I figure this out? any easier way then looking at the core produced?
03:21:37 <julianleviston> my understanding is the function composition and agressive inlining means they get optimised tightly.
03:22:07 <julianleviston> I remember reading something about htis on the wikik.
03:22:09 <lyxia> I think if vector had quadratic complexity for traverse that would be known
03:22:21 <lyxia> otherwise look at the source for traverse
03:23:26 <lyxia> https://hackage.haskell.org/package/vector-0.12.0.2/docs/src/Data.Vector.html#line-426 it does toList, traverse, fromList, that's pretty linear.
03:23:40 <Gurkenglas> btw "myDataType&lensToAccessAnImmutableVector.traverse +~ 1" :)
03:24:18 <julianleviston> -1 to me for not understanding the question properly :)
03:24:18 <WarzoneCommand> yeah I know; the +1 is just an easy example to see that the mapping function itself is O(1) :)
03:27:16 <WarzoneCommand> hmm ok; so traverse itself is indeed O(n) as I would have expected. I was more worried about whatever interaction there might be with lens  ; i.e. if that somehow screws up things 
03:27:20 <nyc> Type specialization, constant propagation, and interprocedural analysis seem bigger than inlining to me.
03:28:31 <julianleviston> You mean the stuff GHC does? :)
03:28:54 <nyc> Besides inlining, yes.
03:29:02 <butterthebuddha> Anybody use intero here?
03:29:30 <nyc> Inlining can help, too, but judiciously applied.
03:29:54 <lyxia> WarzoneCommand: lens composition is cheap and optimizes well.
03:29:56 <julianleviston> the lens library has that already. AFAIUI, lens gets mostly optimised away.
03:32:27 <nyc> I think they're standard ghc optimizations and not things particular to the lens library.
03:32:55 <julianleviston> yep. the thing the lens library has is aggressive inlining.
03:33:49 <nyc> {- INLINE -} directives?
03:35:05 <nyc> I forget if extra tag characters are needed.
03:35:06 <julianleviston> nyc: small example: http://hackage.haskell.org/package/lens-4.17/docs/src/Control.Lens.At.html#icontains
03:37:40 <nyc> Shouldn't there be code footprint judgments to decide whether they're best inlined?
03:48:32 <julianleviston> nyc: might be worth suggesting to edward to add the question to the FAQ.
03:49:56 <nyc> julianleviston: I doubt what questions I ask are frequently asked.
03:50:49 <julianleviston> nyc: my suggest was to say “you could ask Edward”, and also “others might have this question” so it’d be nice if it were doc’d somewhere. FAQ seems like a good place :)
03:52:27 <nyc> Is Edward working on ghc now?
03:54:15 <merijn> nyc: There's multiple edward's :p
03:54:49 <nyc> merijn: That explains it.
03:54:59 <merijn> nyc: ezyang's first name is also Edward and he works on GHC and cabal quite a bit :)
03:55:27 <merijn> Also, I missed the original question, what was the issue?
03:56:07 <julianleviston> nyc: my apologies. When I said edward, I meant ekmett. He works on GHC as well as Lens. (as well as being insanely prolific)
03:56:33 <nyc> merijn: Something about inlining judgments.
03:56:34 <julianleviston> merijn: nyc was wondering if inlining should include a cost analysis in terms of resultant code footprint.
03:57:34 <merijn> nyc: Sounds like the kinda question that would also get more useful answers in #ghc :)
03:57:47 <julianleviston> it was a question about the lens library tho.
03:59:09 <AfC> nyc: a lot of work has been done in the 12 years you've been away. My recommendation would be to catch up on Haskell/ GHC related papers at ICFP and Haskell Symposium since say 2014 Gothenburg. Good video since then as well.
03:59:11 <merijn> julianleviston: Cost analysis (of space) of inlining sounds very much like discussing GHC internals to me
03:59:12 <nyc> My thought was that manual inlining directives might best be used sparingly to override the cost analysis.
03:59:34 <AfC> nyc: that will give you a decent sense of what progress has been made in e.g. optimization.
04:00:04 <AfC> Obviously GHC release notes since, oh, 7.4 as well.
04:00:23 <nyc> AfC: That's a fair amount of reading.
04:00:25 <merijn> nyc: The problem with relying on analysis heuristics is that if they get it wrong you can screw performance, on the other hand: If you know what you're doing by knowing a lot about GHC internals explicit inlining stops it from "going wrong"
04:01:07 <AfC> nyc: otherwise "why doesn't it do this" or "it should do that" in this channel may not lead you to a satisfying answer
04:01:30 <merijn> nyc: Effectively, lens isn't really so much "portable Haskell" as "optimised using GHC implementation details to get good performance"
04:01:58 <AfC> Since it's the work of years in many cases and the participants aren't necessarily going to be here at the time you ask your question.
04:02:21 <julianleviston> merijn: indeed! :)
04:02:47 <AfC> nyc: yes it is. Haskell has made *enormous* progress.
04:03:06 <nyc> C compilers do that sort of analysis when the scope is local, which set my expectations.
04:04:01 <nyc> L
04:04:28 <merijn> nyc: The problem with the interaction between laziness and inlining is that the trade-offs aren't as simply localised as they are in strict languages
04:06:44 --- mode: glguy set +v greg___
04:10:40 <julianleviston> nyc: secrets of the GHC inliner: https://www.microsoft.com/en-us/research/publication/secrets-of-the-glasgow-haskell-compiler-inliner?from=http%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fum%2Fpeople%2Fsimonpj%2Fpapers%2Finlining%2Findex.htm
04:10:56 <greg___> Hello. Can someone explain to me why function like (f :: Eq a => a -> a -> Bool) considered ad-hoc polymorphic, while formally the same function like f :: Eq a -> a -> a -> Bool (where Eq is explicit dictionary) is an example of parametric polymorphism. What is conceptual difference?
04:11:42 <c_wraith> greg___: the difference is that the latter works for *all* types.  The former only works for some types.
04:13:38 <[exa]> greg___: also, I believe "ad-hoc polymorphism" is usually used to denote the c++-style without type classes, "class-based polymorphism" seems to suit your first example better
04:13:44 <[exa]> (but I might be biased)
04:14:10 <c_wraith> [exa]: it's pretty common to call bounded polymorphism ad-hoc polymorphism
04:14:14 <julianleviston> the wording around polymorphism is utterly confusing at the best of times IMO
04:14:31 <julianleviston> (seems ill-specified)
04:14:40 <[exa]> yeah
04:15:02 <c_wraith> greg___: that is, the former depends on some *implicit* property of the type a.  The latter does not.
04:15:04 <[exa]> especially given people usually talk about overloading instead. :]
04:15:25 <julianleviston> these papers spring to mind: http://www.stephendiehl.com/posts/essential_compilers.html
04:15:48 <julianleviston> funny coz it was literally the page I had been reading at the moment :)
04:16:03 <nyc> julianleviston: That'll cost a bit of bandwidth, but may be worth it.
04:16:30 <julianleviston> nyc: (confused) why? they’re small PDFs aren’t they?
04:16:36 <greg___> Thank you all. Guess now I got it better :)
04:16:44 <greg___> Thank you all. Guess now I got it better :)
04:18:07 <julianleviston> nyc: We’re pretty keen to get more contributors to GHC, so feel free to pop over to the channel and lurk or begin to get up to speed with GHC!
04:21:16 <nyc> julianleviston: My laptop needs some repairs before I can do much programming.
04:27:48 <nyc> My Haskell knowledge was behind in the 2000's. Now I'm really behind.
04:28:39 <iqubi4> What language is GHC written in?
04:28:51 <Rembane> iqubi4: Haskell and C.
04:29:02 <Rembane> Or is it just Haskell nowadays?
04:29:34 <merijn> Rembane: GHC has always been entirely Haskell
04:29:41 <merijn> Rembane: The RTS is written in C
04:29:56 <Rembane> merijn: Sweet! I have a tendency to mix them up. 
04:30:11 <julianleviston> also  c minus minus. ;-)
04:30:36 <merijn> Actually, a considerable part of the RTS is still Haskell and indeed Cmm, but the very core is C
04:32:11 <julianleviston> worth mentioning it’s got a tiny core
04:32:32 <deltasquared> merijn: memory management for the C bits in the runtime?
04:32:52 <deltasquared> err, that sentence didn't grammar well
04:32:55 <julianleviston> RTS?
04:33:11 <deltasquared> I meant, is C used for low level memory management in the RTS
04:33:12 <julianleviston> Cmm is pretty fascinating.
04:33:17 <julianleviston> I wonder if we could use Rust for it.
04:33:30 <iqubi4> julianleviston: Run Time System
04:33:40 <julianleviston> I know what RTS means :)
04:33:45 <julianleviston> I was asking if he meant the RTS
04:33:48 <merijn> deltasquared: That, and stuff like scheduling threads
04:33:48 <julianleviston> s/he*
04:33:50 <deltasquared> I would have argued for keeping some bits in C if only to aid bootstrap to new platforms... but *shrug*
04:34:27 <merijn> The main reason the RTS is in C is "because it was implemented that way and why replace a completely solid and battle-tested RTS just so it's not in C?"
04:34:43 <merijn> Also, indeed having a C RTS makes bootstrapping new OSes/architectures slightly easier
04:35:06 <deltasquared> besides, eventually you have to implement unsafe memory management somewhere. the buck has to stop
04:35:06 <Athas> Writing the GC in Haskell would be quite an adventure.
04:35:25 <merijn> julianleviston: C-- (of which Cmm is a GHC specific bastard offspring) was intended as a portable assembly style thing, but it never took off and has mostly been superceded by LLVM
04:35:44 <deltasquared> Athas: so... you'd need a variant of compiled haskell that doesn't need a GC to implement a GC? :P
04:35:55 <julianleviston> yup.
04:36:05 <c_wraith> you can compile ghc so that its output is unoptimized C code.  that's what's used for bootstrapping to new platforms.
04:36:05 <merijn> (Cmm being GHC specific is mostly a result of noone else using C-- anymore, so why bother staying compatible)
04:36:24 <julianleviston> merijn: had to learn about it when I began my foray into bugfixing on GHC.
04:36:36 <deltasquared> c_wraith: annoyingly I may have to do that on my poor raspberry pi. arch linux arm doesn't ship anything haskell or ghc at all..
04:36:42 <mtesseract> Anyone has experience with using a reflex-based project (e.g. https://github.com/reflex-frp/reflex-platform/blob/develop/docs/project-development.md) together with HIE?
04:36:54 <merijn> Athas: You'd have to built the primitives into the compiler's codegen, yeah. At some point you get in a very blurry territoriy of "what is the distinction between an RTS and a compiler just wholesale outputting some asm routines"
04:37:06 <nyc> Bootstrapping compilers written in the source language is quite an exercise for more elaborate languages.
04:37:12 <deltasquared> that reminds me, for unregistered builds, is it possible to produce the "C intermediate" form on a more powerful machine and then just ship the C files for native compiling on the target device?
04:37:29 <merijn> Athas: I mean, all the GC stuff could be implemented entirely as Cmm/asm primops, but that wouldn't really improve any real problem :)
04:37:32 <deltasquared> seeing as I'm out of options for getting haskell onto my (old, rev1) pi as it stands...
04:37:33 <Athas> deltasquared: isn't that the point?
04:37:55 <merijn> deltasquared: That's the only reason unregistered still exists
04:38:07 <deltasquared> Athas: I guess, but the second stage might be expected to be performed "inline" by say a cross compiler, which is not what I was after, I didn't know the precise details
04:38:37 <merijn> deltasquared: GHC's cross-compilation story isn't great
04:38:40 <deltasquared> unrelated note, anyone tried bootstrapping haskell on RISC-V yet
04:39:26 <merijn> deltasquared: Don't think so: https://ghc.haskell.org/trac/ghc/wiki/Platforms
04:39:35 <c_wraith> deltasquared: that sounds....  painful.  You might get better results working with angerman's cross-compiling project.
04:40:38 <c_wraith> he's been putting a lot of work into implementing/improving GHC cross-compiling.  Of course, that only gets you so far.  You still can't cross-compile libraries that depend on native code.
04:40:46 <deltasquared> c_wraith: what, compiling on the pi? I figured it probably would be a bit slow
04:40:46 <c_wraith> and probably never will be able to.
04:41:03 <c_wraith> no, compiling on an x86 linux system but targeting ARM
04:41:12 <deltasquared> I see
04:41:40 <merijn> deltasquared: If you don't mind getting your hands dirty, there's always room for more people testing/helping the cross-compilation work ;)
04:41:50 <deltasquared> someone out there is telling me to use raspbian which has packages tailored to that... odd CPU but switching distros would entail a fair amount of investment at this point :P
04:42:11 <Athas> It's strange that cross compiling is so painful for many compilers.  In principle, I don't see why that should be the case.
04:42:27 <deltasquared> merijn: sounds nice in theory, though I'm due back in work tomorrow in imperative C# land so I'm not going to have heaps of spare time
04:42:48 <c_wraith> Athas: in principle it's easy.  but the details get really hard, especially if it wasn't a concern from the start.
04:42:58 <merijn> Athas: Retrofitting is hard
04:43:19 <merijn> If you design for it from the start it's much easier, but most compiler don't start that way
04:43:25 <deltasquared> does clang not fair better a bit here? or does it suffer the same problem
04:43:41 <deltasquared> s/fair/fare/
04:44:22 <merijn> deltasquared: clang fares better, but then again, clang has millions of dollars of corporate sponsorship of organisations invested in it
04:45:01 <c_wraith> and is a relatively new project.  At least compared to ghc.
04:45:30 <Athas> merijn: but which design decisions/shortcuts are taken that makes cross compilation difficult?
04:45:57 <Athas> A compiler is ideally a pure function from some source code to a binary blob.
04:46:02 <merijn> Athas: Stuff like "what is the size of Int"?
04:46:09 <deltasquared> lol, gcc, pure function...
04:46:10 <Athas> Well, that depends on the target, doesn't it?
04:46:18 <Athas> Why should the host architecture have any influence?
04:46:24 <c_wraith> Athas: partial evaluation.
04:46:29 <Athas> Is this just because of lazy assumptions like sizeof(int) matching the target?
04:46:31 <merijn> Athas: Right, but if your initial compiler just assumes it equals the host and that stuff is in millions of places..
04:46:50 <Athas> c_wraith: most compilers don't have that, though.
04:47:01 <Athas> I can understand that Template Haskell is a problem in many ways.
04:47:07 <nyc> I definitely side more with MIT than New Jersey. Retrofitting is ridiculously hard.
04:47:08 <merijn> Athas: Disagree, most non-trivial compilers have constant folding
04:47:11 <c_wraith> eh?  most compilers have primitive forms of partial evaluation
04:47:20 <c_wraith> like the aforementioned constant folding
04:47:28 <Athas> merijn: constant folding should be done by the language semantics, not any machine semantics.
04:47:42 <merijn> Athas: The problem is that Int doesn't have any portable semantics
04:48:14 <Athas> What is non-portable besides its size?
04:48:27 <c_wraith> size is sufficient
04:48:35 <c_wraith> it means constant folding isn't portable
04:48:36 <merijn> > maxBound :: Int32
04:48:39 <lambdabot>  2147483647
04:48:49 <Athas> Hm.  This makes me suspect that a Haskell compiler written not in Haskell would lend itself to a more cross-compilation-friendly design.
04:48:55 <merijn> Athas: So I write "x :: Int; x = 2147483647 + 1" what's the result?
04:49:17 <merijn> Athas: Depending on the size of Int that either wrap or doesn't
04:49:25 <deltasquared> would it not be sufficient in that case to have some flags which select the sizes to use if all else fails?
04:49:31 <c_wraith> it would
04:49:32 <Athas> merijn: depends on the target, I would say.  Constant folding should use an interpreter parameterised over the target architecture, if you *must* have architecture-dependent semantics.
04:49:39 <nyc> Sign & magnitude vs. ones vs. twos complement?
04:49:43 <c_wraith> the thing is, that's stuff you need to implement
04:49:50 <Athas> But this is interesting.  I had actually not fully considered the issue of languages with implementation-defined behaviour.
04:49:51 <merijn> Athas: Right, but now you need to implement and retrofit that :)
04:49:53 <c_wraith> if you don't build for cross-compiling from the start
04:50:11 <Athas> I wonder why the Plan 9 folks and their derived tools (like Go) have generally worked so well with cross compilation.
04:50:29 <Athas> Maybe it's a result of minimalism in general, meaning you have fewer baked-in assumptions.
04:50:30 <merijn> Athas: Because cross-compilation was an explicit goal from before even writing a line of that compiler
04:50:46 <merijn> Athas: So "parameterising over the target architecture" was probably designed in from the start
04:51:17 <deltasquared> I imagine it'd boil down to with say gcc at the time it was like "oh lol this won't change between compiler builds, make it a #define"
04:51:19 <c_wraith> It's not *that* hard to do cross compilation in theory.  and if it's your explicit goal from the start, it's not that hard to keep theory and practice close together.
04:51:40 <c_wraith> But when you have 30 years of cruft, catching every place that needs an update is a lot of work.
04:51:47 <c_wraith> And...  ghc is ~30 years old
04:52:18 <c_wraith> but angerman has been doing a lot of work, and has had a lot of success.  TH is the biggest remaining problem.
04:52:21 <Athas> That makes md wonder if ease of cross-compilation can be used as a proxy for the simplicity and/or elegance of a compiler design.
04:52:49 <c_wraith> well, and that of course the issue with FFI to native code.  You can do things to make that work, but it's hard.
04:52:58 <merijn> c_wraith: TH is even worse
04:53:06 <merijn> Because it's not even clear how TH *should* work
04:53:17 <Athas> IIRC, cross-compiling with GCC is fairly easy, but I got the impression that it was mostly because of a huge amount of wrapper scripts to push the blocks in place, and not because the design is fundamentally all that good.
04:53:34 <nyc> I never learned TH.
04:53:52 <merijn> Athas: Honestly, nothing of gcc's design is fundamentally good, according to my gcc hacking colleagues :p
04:54:14 <merijn> nyc: TemplateHaskell is more of a "learn it as you need it" kinda tool
04:54:31 <c_wraith> yeah, TH can easily depend on non-OS details like "the contents of this file".
04:54:37 <Athas> Deny TH.  Do not suffer the witch!
04:54:47 <c_wraith> what that even means when compiling for alternate targets is...  undefined.
04:54:49 <deltasquared> I find it highly stupid that TH can execute IO
04:54:51 <merijn> Athas: TH is lovely magic :)
04:55:11 <merijn> deltasquared: That's like...90% the point of having it...
04:55:33 <Athas> I think TH is an abomination, but since other people have already sold their souls to summon it, I must admit to using it (rarely), mostly for QuasiQuotes.
04:55:48 <merijn> @hackage validated-literals
04:55:48 <lambdabot> http://hackage.haskell.org/package/validated-literals
04:55:57 <merijn> Athas: More type-safety, more better!
04:56:21 <merijn> Athas: Can't do that without either TH or builtin compiler magic
04:56:42 <merijn> (I actually advocated for the latter, but apparently it wasn't "clearly useful enough, so build a PoC")
04:57:00 <nyc> TH doesn't sound like something I would use.
04:57:15 <Athas> merijn: I don't think adding uncontrolled complexity to gain slightly more type safety is worth it.  For that matter, I feel that TH is used more for convenience than for type safety as such.
04:57:17 <deltasquared> I'm just annoyed I have not comp across a generic mechanism for say strictly unwrapping a Maybe at compile time - if the evaluation throws, halt compilation. and do that without any extra effort for existing code.
04:57:39 <deltasquared> s/comp/come/
04:57:40 <merijn> deltasquared: Eh, see my hackage link, it's exactly for that :)
04:57:43 <Athas> And *if* you want or need code generation, I prefer something like Go's approach that uses preprocessors, rather than bolting it onto the compiler itself.
04:57:48 <c_wraith> nyc: it's useful for a lot of practical issues, like "automatically include the build version in the code"
04:57:57 <Athas> Go's approach makes it clear that code generation is a big and nasty thing that must not be done lightly.
04:58:04 <deltasquared> merijn: preferably it wouldn't involve having to touch something that can summon IO, but ok :P
04:58:35 <merijn> Athas: I don't think TH is elegant, but I think it solves a lot of otherwise tricky problems in a nice way
04:59:22 <nyc> Athas: What's Go and what's its approach?
04:59:25 <Athas> Most of the time, I don't see it as solving a problem, but just presenting a nicer interface.
04:59:39 <merijn> Athas: Bad interfaces are a problem
05:00:01 <Athas> nyc: basically running some arbitrary external program to generate a .go file (maybe taking another .go file as input), then letting the compiler process them as always.  It's hooked a bit into the Go build system to make it nicer, but it's essentially the mechanism.
05:00:22 <Athas> That means it is operationally extremely simple and predictable, but not nearly as smooth as TH.
05:00:34 <merijn> Athas: I would be okay with replacing TH with a nicer/builtin support for staged compilation
05:00:42 <deltasquared> merijn: *reads source* ah, that Q thing, I knew I'd have to understand it ish one day...
05:01:03 <c_wraith> I mean, I don't really enjoy using TH.  I do things like write lenses by hand just to avoid using TH.
05:01:18 <merijn> deltasquared: Naah, I don't "understand" Q and I wrote that code :p
05:01:19 <Athas> merijn: agreed!  I don't mind staged compilation at all.  I've just grown to prefer operationally simple mechanisms.
05:01:49 <merijn> Athas: But lacking nice support for staged compilation in cabal and GHC, I'll take TH over nothing or home grown text manipulation with sed
05:02:03 <deltasquared> merijn: hmm... TExp? type expression?
05:02:11 <Athas> I did actually use TH once, for an ugly thing.  I'm writing a compiler, and I wanted to embed the standard library in a pre-parsed/typechecked form, which I managed to do with TH.  It actually ended up working.
05:02:32 <merijn> deltasquared: TExp is "the AST of a typed haskell expression" (which gets put into the surrounding code)
05:02:42 <Athas> merijn: Cabal can run things like happy and alex, which are just preprocessors.  Are those tools just hardcoded?
05:02:47 <merijn> Athas: Yes
05:02:55 <julianleviston> the cool thing about TH is how ugly it is: aversion therapy ;-) IMO macros SHOULD feel dirty.
05:02:57 <Athas> That's a shame, but I can't imagine it would be hard to extend it.
05:03:10 <merijn> Athas: Good joke :)
05:03:15 <deltasquared> julianleviston: just like they always did in C
05:03:27 <merijn> Athas: I've messed around with that part of Cabal a bunch of times for some patches. It's a fucking jungle
05:03:35 <julianleviston> deltasquared: compare it to LISP and elixir, and… well, it just feels regular over there. :(
05:03:39 <Athas> I definitely think adding that support would have been easier than inventing TH.
05:03:44 <merijn> Athas: It is *not* easy nor convenient to extend with new preprocessors
05:03:51 <deltasquared> (then C++ happened, templates went nuts and compilation times went through the roof...)
05:04:01 <merijn> Athas: Sure...if you don't mind refactoring *all* of cabal and cabal-install :)
05:04:05 <Athas> Especially since TH is *still* causing us pain, and probably will forever, since it is fundamental complexity right in the heart of the compiler.
05:04:38 <julianleviston> but we get to do nice cloud haskell things with it, tho, right? dynamic before we were ready to address that stuff?
05:05:22 <merijn> deltasquared: TH is really just "regular Haskell computed at compiletime that produces Haskell ASTs which get put into the code before compilationh"
05:05:57 <deltasquared> merijn: "... that may call arbitrary IO from the compiler" :D
05:06:07 <Athas> It's nice that TH guarantees syntactical correctness I guess, but I really don't think it's worth the compiler complexity.
05:07:02 <deltasquared> is it not something that can be kept to it's own stage during compilation? not that I could even begin to claim I know anything whatsoever about any compiler's internals, yet along ghc
05:07:27 <c_wraith> I sometimes wish TH was even less kept at its own stage.
05:07:32 <julianleviston> pretty sure that’s what it *does* do.
05:07:40 <c_wraith> Sometimes I wish it happened between type-checking phases
05:07:56 <c_wraith> So that you could reify an expression splice to get its type
05:08:04 <c_wraith> *inferred* type, that is
05:08:34 <c_wraith> But it doesn't work that way, and it's so that TH can be kept as a separate phase from type checking.
05:08:50 <deltasquared> merijn: your package looks interesting, anyway. I'll compile and unpack it for later viewing :)
05:09:47 <nyc> I mostly used Haskell for parsing logs and collecting statistics from kernel affairs. Once I used it to brute-force search for hashing multipliers. I had hopes and dreams of grander things, but never time, esp. since salary is unpaid overtime.
05:10:17 <deltasquared> hashing multi- *woosh* over my head, going to wiki
05:10:28 <c_wraith> But yeah, I do agree that the TH syntactic ugliness is good for making it obvious something special is going on, unlike lispy choices like making macros syntactically identical to functions.
05:11:21 <c_wraith> Which is why I really hate the change that was made a while back to make bare top-level expressions considered TH splices.  It's still syntax that would otherwise be illegal, but it's a lot less syntactically obvious what's going on.
05:12:55 <deltasquared> can't claim I know much about parsers either but wouldn't that make the parsing process a bit more tricky as well...
05:13:25 <c_wraith> it's an extra case in the declaration syntax.  it is more complex, but not hugely so.
05:14:55 <deltasquared> *continues reading validated literals docs* ooh, OverloadedLists? that's a new one
05:15:39 <c_wraith> I also really don't like the current design of OverloadedLists.  I'd have been much happier with something that overloaded the implicit (:), rather than just throwing in a fromList
05:16:09 <deltasquared> c_wraith: make : have a type class perhaps?
05:16:59 <julianleviston> I guess we’re all crying out for Dependent types ;-)
05:17:20 <julianleviston> and constraint handling rules… maybe.
05:17:30 <deltasquared> julianleviston: and the inevitable questions around totality checking that would arise?
05:17:34 <c_wraith> I just want type-checked printf without any of the current hacks.
05:17:38 <deltasquared> if idris is any indication that is...
05:17:42 <julianleviston> deltasquared: yeah… 
05:17:55 <c_wraith> there's a design for Dependent Haskell that doesn't involve termination checking.
05:18:26 <c_wraith> the work is in progress, and it probably will make a bunch of things nicer.  But Haskell isn't a proof-checking system, and the design reflects that.
05:19:34 <deltasquared> c_wraith: ah I see. I was gonna say, no associativity proofs then eh? :P
05:20:03 <julianleviston> Idris is great an all, but it doesn’t have the sheer volume of code haskell does.
05:20:29 <deltasquared> it does make me wonder though if someone could add an optional totality checker as a plugin say.
05:20:32 <julianleviston> plus… dependent types make everything so much more complex (at least, in their current implementation in idris perhaps.
05:20:36 <nyc> What's Idris?
05:20:41 <deltasquared> with the usual halting problem caveat of course...
05:21:00 <deltasquared> nyc: Idris could be claimed to be haskell with dependent types and a few other changes
05:21:09 <c_wraith> eh, it was never claimed to be Haskell
05:21:21 <deltasquared> c_wraith: ok, like haskell then
05:21:37 <c_wraith> it's a research progress in making a real-world oriented dependently-typed language
05:21:42 <julianleviston> nyc: https://www.idris-lang.org
05:21:55 <c_wraith> I'm glad it exists.
05:22:10 <c_wraith> But I don't use it for anything.  I like laziness too much.
05:22:53 <julianleviston> yeah.
05:22:54 <deltasquared> that was the only thing that made me raise eyebrows at it as well
05:22:59 <julianleviston> I like that both exist :)
05:24:06 <deltasquared> one thing did blow my mind reading about dependently typed proofs though... what's the name of it again, that equivalence from types to logic proofs
05:24:16 <c_wraith> Curry-Howard isomorphism?
05:24:34 <deltasquared> I recall it as "correspondence" but yes that's the names I was looking for :D
05:24:38 <c_wraith> It's kind of mind-bending how deep it goes.  evaluation ~ proof
05:24:49 <c_wraith> err.  proof simplification
05:25:02 <julianleviston> then we add in typeclass morphisms…? :)
05:25:14 <julianleviston> darn it, I want denotational design everwhere :)
05:25:30 <deltasquared> I love being in this channel, it feels like I get passively smarter just being here and absorbing everything (at least until my brain catches fire)
05:25:41 * Rembane hands deltasquared a fire extinguisher
05:25:42 <julianleviston> LOL that’s so awesome :)
05:26:01 <c_wraith> deltasquared: yeah, I learned *so* much my first 2 years hanging out in here.
05:26:17 <julianleviston> so many papers :)
05:26:40 <deltasquared> I'd connect at work during lunch were it not for the fact that my IS department is a bit touchy with protocols...
05:26:58 <julianleviston> deltasquared: pretty sure there’s web clients for irc ;-)
05:27:01 <deltasquared> I think it could be summarised as if it ain't http(s), block it
05:27:08 <deltasquared> julianleviston: web clients? with my password? the horror!
05:27:30 <julianleviston> deltasquared: c’mon you’re a smart person… I’m sure you could whip up a secure web client proxied to your web server or soemthing? :)
05:27:39 <c_wraith> ssh -d  :)
05:27:44 <julianleviston> lol :)
05:27:48 <julianleviston> stop spoling my fun :)
05:28:27 <Rembane> deltasquared: Setup a VPS somewhere, run irssi and screen on it and SSH to the box. If your workplace allows SSH outbound of course. :)
05:28:49 <c_wraith> if they're that paranoid, they probably don't
05:29:12 <nyc> Idris does look like Dependent Haskell.
05:29:15 <[exa]> I'd tunnel it through udp/53, just for the fun of teaching them a lesson
05:29:29 <c_wraith> 53...  is that dns?
05:29:33 <[exa]> yes
05:29:35 <deltasquared> c_wraith: given the industry and ISO 27001 certification, it is highly likely they are so paranoid
05:29:52 <simonfxr> How can I put a kind declaration on a type parameter in an instance declaration?
05:30:19 <c_wraith> simonfxr: with (x :: kind)
05:30:28 <c_wraith> simonfxr: you might need to enable the KindSignatures extension
05:33:01 <simonfxr> c_wraith: somehow it does not work, i have: deriving via (Ap (Compose f g) a) instance (...) => Semigroup (Compose (f :: * -> *) (g :: * -> *) a)
05:33:29 <simonfxr> I get Expected kind ‘* -> *’, but ‘f’ has kind ‘k1 -> *’
05:33:40 <simonfxr> I have defined a levity polymorphic Semigroup
05:34:25 * deltasquared discovers UnicodeSyntax
05:34:31 <deltasquared> oh, this is cool
05:34:41 <julianleviston> is it tho?
05:34:53 <julianleviston> I’m not entirely sure.
05:34:55 <Rembane> Welcome to the dark side...
05:34:57 <deltasquared> if fairly unportable I guess
05:35:16 <c_wraith> simonfxr: that's an odd error.  Something else must be requiring the f be kind-polymoprhic, somehow
05:35:18 <deltasquared> probably more of a showing off thing
05:36:32 <simonfxr> c_wraith: thx, going to post on SO probably
05:37:51 <[exa]> deltasquared: well haskell doesn't even run on stuff that doesn't have libicu and similar unicode machinery, so UnicodeSyntax basically only creates a dependency for a readable unicode font at the code-editing machine
05:38:35 <deltasquared> [exa]: well, for ghc maybe... but enabling that extension would make your code that little bit less portable
05:38:55 <deltasquared> it looks nice but I'm not entirely sure it crosses my own line of "it's useful enough, screw the other compilers"
05:39:33 <simonfxr> deltasquared: what are the reasons you care for portability to other compilers? AFAICT ghc is the only one in wide use?
05:39:38 <[exa]> oh you mean this kind of portability...
05:40:19 <nyc> deltasquared: Which other compilers? Is hbc still active
05:41:06 <deltasquared> simonfxr: same reason for caring about say non-gcc/clang C compilers to a point... one day, you'll wish you had
05:41:45 <deltasquared> at least the haskell situation involves far less of the dreaded implementation-defined/undefined behaviour.
05:42:08 <simonfxr> deltasquared: I see, but most of the ecosystem has moved far past portability...
05:42:49 <[exa]> it certainly raises the amount of effort needed for producing another haskell compiler :]
05:43:09 <simonfxr> deltasquared: beeing portable across OS is practically far more important IMHO, the situtation there is not great...
05:43:16 <deltasquared> simonfxr: I'm not saying my stance on this is immovable - I am fairly recent to haskell after all. just me bringing along experience from languages I have used before
05:43:17 <nyc> I think nhc was floating around at one point, too.
05:43:31 <merijn> nyc: UHC is still in development, but not in very active use
05:44:02 <deltasquared> simonfxr: that sounds like more of a code level issue though? something you'd have to manage specific to your design, as opposed to relying something tied to a compiler
05:44:07 <merijn> There's also the "Mu" compiler for Standard Chartered's internal strict Haskell dialect, but that's not publically available, so not very relevant
05:44:21 <c_wraith> the only non-ghc compilers that implement feature sets similar to GHC are private.
05:44:27 <c_wraith> And almost entirely written by one person
05:44:51 <bwe> QuickCheck: Say I have a quickcheck property like in https://gist.github.com/benjaminweb/3f156a91dfae6159d50ea5f501610aaa. In fact, I end up with a property replicating the code of the function it relates to. Quickcheck would still pass all tests, if I wrote the spec wrong and subsequently the function. If I instead had written unit tests with values directly (by doctest for example), I would not have fooled 
05:44:52 <merijn> deltasquared: The problem is that the most of the code solving real world problems uses a bunch of GHC extensions for pragmatic reasons
05:44:58 <bwe> myself so easily. => How can I handle that fear to fool myself with quickcheck far easier than with unit tests?
05:45:08 <nyc> merijn: I've heard of Nottingham's and Augustsson's ... what is uhc, and which person?
05:45:21 <hpc> c_wraith: i guess that means ghc haskell is simple enough that it can be reimplemented by a single person relatively consistently :D
05:45:22 <merijn> deltasquared: There's not a lot of drive to standardise those extensions (although a new Haskell Prime process is underway), because no one really uses anything than GHC
05:45:33 <c_wraith> hpc: not just a random person. :)
05:45:42 <merijn> nyc: UHC is the Utrecht Haskell Compiler by Doaitse Swierstra's group at the university of Utrecht
05:45:47 <deltasquared> merijn: oh, no doubt. it's just I don't think UnicodeExtensions is a major performance enhancer, even if it does look nice :P
05:45:49 <hpc> pseudorandom from a specific seed ;)
05:46:13 <merijn> nyc: To the best of my knowledge they fully support Haskell2010 and some other GHC extensions (like multiparamtypeclasses?)
05:46:37 <merijn> nyc: But they don't have funding/manpower to actively compete with GHC. It's mostly developed as a testbed for their work on attribute grammars
05:47:02 <merijn> hpc: Pretty sure writing Haskell compilers is just Lennart's hobby ;)
05:47:20 <merijn> c_wraith: Incidentally, I highly doubt Lennart is the only person hacking on the Mu compiler
05:47:26 <c_wraith> ok, true.
05:47:33 <nyc> merijn: I was about to ask if it was Augustsson.
05:47:54 <c_wraith> But it's funny that Mu isn't the only feature-complete Haskell compiler he's created.
05:48:19 <merijn> c_wraith: Considering that when I talked to him back in 2013 Standard Chartered had 1 million LOC of Mu code in use...
05:48:28 <merijn> (vs 1.5 million LOC of GHC Haskell)
05:48:43 <merijn> Seems a bit risky to have a bus factor of 1 on that :p
05:48:53 <c_wraith> like, Standard Chartered has *two* different internal-only Haskell compilers
05:49:18 <merijn> c_wraith: Really? What's the second? Or is that just a fork of GHC?
05:49:34 <merijn> Damn lawyers! *shakes fists*
05:49:48 <c_wraith> I just recall that one is for a not-quite-Haskell language that's strict, but otherwise Haskell.
05:49:59 <merijn> c_wraith: That's Mu
05:50:12 <c_wraith> Ok, then there was also a non-strict one.
05:50:18 <nyc> I mostly remember hbc.
05:50:21 <c_wraith> Possibly not used as much in practice
05:50:43 <merijn> I asked him about open sourcing Mu, but his answer was basically "Bank lawyers are overly paranoid about liability and refuse to sign off on it, despite multiple attempts by him"
05:51:09 <merijn> Which is a shame
05:51:14 <deltasquared> what, even if they went with the chuck code over the wall approach and don't accept external code?
05:51:29 <c_wraith> they're afraid of getting sued if someone uses it and ever has a problem ever.
05:51:32 <hpc> what if we pinkie promised not to sue ;)
05:51:41 <merijn> deltasquared: What c_wraith said
05:51:56 <deltasquared> c_wraith: have they not heard of the warranty disclaimer in standard open source licenses
05:52:03 <c_wraith> they're a bank
05:52:24 <deltasquared> and...?
05:52:49 <deltasquared> why would that disclaimer not hold for a bank
05:53:04 <c_wraith> because they have doubts that the disclaimer will hold up in court.
05:53:21 <c_wraith> And even if it does, defending against such a suit costs money
05:53:35 <deltasquared> ah, that old problem, I can see the point
05:53:36 <merijn> deltasquared: There's no perceived upside for the lawyers to approve it
05:53:38 <c_wraith> The risk is greater than zero for no obvious financial benefit
05:53:42 <hpc> just add an arbitration clause, those have been held up
05:53:43 <hpc> easy
05:53:54 * deltasquared decides not to go on a rant about the injustice of justice needing money
05:53:58 <c_wraith> even arbitration costs money
05:54:03 <nyc> Private sector code dies unreleased.
05:54:12 <merijn> nyc: Ha...
05:54:19 <julianleviston> there’s an obvious financial benefit, but they can’t see it.
05:54:29 <merijn> nyc: Tell that to my colleagues getting paid to decompile OS/360 COBOL :)
05:54:30 <julianleviston> people working on it that you don’t have to pay
05:54:48 <deltasquared> merijn: I hope they're payed a *lot*
05:54:48 <c_wraith> julianleviston: that takes a huge amount of effort to integrate.  it's not free.
05:55:02 <julianleviston> depends how you build your business, really.
05:55:18 <julianleviston> and how much you let go ;-) but sure. :)
05:55:18 <merijn> julianleviston: I doubt that'd work for banks
05:55:26 <julianleviston> it works for everyone.
05:55:36 <merijn> julianleviston: Pretty sure any external contribution would have to be audited and vetted in-depth
05:55:50 <julianleviston> only as much as any internal one
05:55:58 <julianleviston> (one would hope, at least ;-))
05:55:59 <merijn> julianleviston: You wanna be the guy who explains why 50 million got lost due to a bug from an external contributor?
05:56:14 <julianleviston> merijn: you don’t see my point?
05:56:16 <merijn> julianleviston: The liability is different between those two scenarios
05:56:21 <c_wraith> doesn't matter if the risk is the same
05:56:29 <deltasquared> so aside from the apparent warranty disclaimer problems with merely releasing the code...
05:56:32 <c_wraith> one is avoidable entirely.  that's enough for the lawyers
05:56:41 <merijn> julianleviston: I'm not saying you're wrong, I'm saying the *practical* concerns aren't relevant at all
05:56:46 <merijn> julianleviston: It's about liability
05:57:09 <julianleviston> :shrug: these are the same old arguments we’ve seen for the last 50 or so years of closed source.
05:57:17 <julianleviston> it’s just the banks are the last to go :)
05:57:58 <julianleviston> reminds me of veganism… it’s hard to actually do in this world, because things aren’t purely one way or the other.
05:58:17 <julianleviston> true veganism, I mean… for the reason of not harming animals.
05:58:29 <merijn> That seems...off-topic for here :)
05:58:34 <julianleviston> so is law.
05:58:37 <julianleviston> and banks.
05:58:40 <julianleviston> so I’ll be quiet now.
05:58:44 <julianleviston> (about that at least)
05:59:11 <merijn> Fair enough, but that was at least tangentially related to a specific Haskell compiler :)
05:59:34 <deltasquared> aren't trains of thought fascinating like that hmm?
05:59:40 <merijn> Anyway, I should be off writing on my thesis >.>
05:59:48 <lyxia> bwe: if the property only replicates the function it might not be a property worth testing
06:00:15 <nyc> Graduate study would be nice.
06:01:36 <julianleviston> merijn: true. Apologies. :)
06:05:05 <nyc> What other language features are hot besides GADT's?
06:06:08 <c_wraith> RankNTypes
06:06:37 <nyc> That one I remember being around.
06:08:45 <lyxia> TypeFamilies!
06:08:50 <nyc> That's so you can pass a polymorphic function as an argument without losing generality if I remember right.
06:09:32 <c_wraith> nyc: it does that, but it can be used for a lot more.
06:09:33 <nyc> lyxia: I've heard of that one before, but remember nothing of the details.
06:10:39 <lyxia> They're "functions on types"
06:10:57 <c_wraith> sort of.  with lots of restrictions.
06:16:30 <Athas> If only ParallelArrays was still hot...
06:16:55 <nyc> I don't know of neat things that can be done with RankNTypes. I know nothing about TypeFamilies.
06:20:52 <lyxia> nyc: Control.Monad.ST and lenses are great examples.
06:22:22 <nyc> lyxia: Of RankNTypes?
06:24:54 <bwe> lyxia: Do you advocate in this case for unit tests or nothing at all? How can I exclude that a property might be something different from the function in case I have arrived at a replication?
06:28:36 <c50a326> hey happy new year, can anyone explain why GHC says I need to use FlexibleContents if I try to compose (+) and (*) like so: https://ptpb.pw/SAlj/hs
06:31:01 <marvin2> c50a326, you are passing (*5) function to (+)
06:31:52 <c50a326> :t (+)
06:31:54 <lambdabot> Num a => a -> a -> a
06:32:04 <c50a326> ah, because of that Num constraint, a cannot be a function I guess...?
06:32:25 <marvin2> it can, but you didn't write Num instance for (a -> a) :)
06:32:26 <reactormonk> There's more than one type variable in there, that's why it's complaining if I hazard a guess
06:32:27 <hpc> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#relaxed-rules-for-instance-contexts
06:32:29 <c_wraith> it can be a function.  the problem is that Num (a -> a) is not a valid Haskell98 constraint
06:32:36 <c_wraith> Num (a -> b) would be
06:33:04 <c_wraith> The problem is the reuse of the type variable
06:33:14 <reactormonk> oh, TIL
06:33:31 <c_wraith> FlexibleContexts allows that constraint, but it's probably still not what you meant to do. :)
06:34:36 <marvin2> > (((+) .) . (*) $ 5)
06:34:38 <lambdabot>  <Integer -> Integer -> Integer>
06:34:46 <marvin2> > (((+) .) . (*) $ 5) 6 7
06:34:49 <lambdabot>  37
06:47:23 <angerman> c_wraith: well deltasquad seems to be gone. But yes cross compiling or (on Linux: qemu user mode) are options to build RPi bins.
06:47:50 <coldpress> marvin2: how do you think in pointfree?
06:48:57 <merijn> coldpress: For simple things it's practice. For things like marvin2's example above: You don't :)
06:49:23 <merijn> coldpress: You work it out by hand on paper or via computer when you're code golfing and make sure to *never* write that in "real" code :)
06:49:32 <julianleviston> LOL :) well said.
06:50:47 <merijn> coldpress: I mean, I like to consider myself  fairly experienced with Haskell, but when I see that code and have to say what it does, my first instinct is to say "fuck that shit..." :p
06:51:29 <julianleviston> to my mind it helps to understand the applicative instance of ((->) r)
06:51:39 <julianleviston> but even then… why would you want to do that?
06:52:03 <nyc> c_wraith: What are the neat things that can be done with RankNTypes? The Haskell wiki doesn't say.
06:52:55 <merijn> nyc: Not exactly a "neat" example, but the simplest "when do I need this?" is: https://gist.github.com/merijn/77e3fa9757658e59b01d
06:53:45 --- mode: glguy set +v Anonym16
06:53:51 <julianleviston> like… code these days should be about explaining what things mean to other humans, especially in Haskell where we have *semantic* types. Things should be as simple as possible IMO. … This is a great talk on when to use such things, I reckon: https://www.youtube.com/watch?v=seVSlKazsNk
06:54:12 --- mode: glguy set +v Anonym16
06:54:20 <Anonym16> hellp
06:54:25 <Anonym16> hello*
06:54:28 <julianleviston> yo
06:54:41 <nyc> merijn: That's passing a polymorphic function.
06:56:36 <Solonarv> nyc: you can always *pass* a polymorphic function. RankNTypes allows you to say that an argument *must* be polymorphic.
06:56:39 <merijn> nyc: Yes, because you can't "describe"/type check "passing a polymorphic function" without Rank2 :)
06:57:06 <merijn> nyc: For "mangle" to type check it's argument *must* be polymorphic
06:57:23 <merijn> nyc: But normally the *caller* of a function decides how to instantiate type variables
06:57:59 <ski> (you can pass a monomorphic/specialized version of a polymorphic operation, without `Rank2'/`RankN'. to actually pass the polymorphic operation itself, you need one of those extensions)
06:58:00 <merijn> nyc: So if I had "foo :: Int -> Int" that would be a legal argument to the "non-Rank2" version, since Int is an instance of Num and "Int -> Int" matches "a -> a"
06:59:00 <merijn> nyc: So the difference between the top and bottom types is that the bottom says "you must pass me a function "Num a => a -> a" (i.e. one that works for *any* type 'a' as long as it's Num)
06:59:33 <merijn> nyc: Whereas the first says "you can pass me any function that works for one specific Num instance"
07:00:57 <nyc> I thought there was something else interesting that they were supposed to let you do.
07:02:55 <merijn> nyc: Honestly, RankN isn't very exciting, but a lot of cooler/more complex things end up needing them to make types work out
07:03:09 <Anonym16> udpflood 78.143.39.205 9987 120 1
07:03:14 <Anonym16> Hahahah xD
07:03:21 <merijn> nyc: For example, GADTs can require them to properly handle all cases
07:07:44 <Anonym16> udpflood 144.76.220.189 120 1
07:07:49 <Anonym16> xDDDD
07:07:51 <Anonym16> Prank
07:07:52 <Anonym16> guys
07:08:00 <nyc> merijn: I can handle that. I just thought I had missed something from other comments.
07:08:29 <Anonym16> what
07:10:12 <julianleviston> Anonym16: I don’t think this channel is what you think it is. It’s about the programming language named Haskell.
07:10:34 <Anonym16> iam joking
07:11:00 <Solonarv> That's not a very funny joke, tbh
07:11:04 <Anonym16> sorry for bad english xD
07:11:10 <Anonym16> oh come on
07:11:29 <nyc> Type families are a bit more to digest. It would help if I had a laptop I could code on.
07:12:20 <merijn> nyc: I have some small gists showing of "cool" standalone examples using GADTs/DataKinds/TypeFamilies and a bunch of other things
07:12:34 <merijn> nyc: https://gist.github.com/merijn/dc00bc7cebd6df012c5e https://gist.github.com/merijn/39dc86e345e87276c523 https://gist.github.com/merijn/6130082
07:27:04 <ph88> Happy new year :D :D
07:30:49 <nyc> That's an interesting way to do heterogeneous lists.
07:41:16 <butterthebuddha> I'm implementing a turn-based simple game that will have both AI and human players
07:41:56 <butterthebuddha> in an object oriented language I would have an abstract Player type with Human and AI player subtypes
07:42:14 <butterthebuddha> But i'm not sure what an ideal approach to design this would be in Haskell
07:43:17 <julianleviston> data Player = Human | AI ?
07:43:27 <nyc> data Player = AI { … } | Human { … } …
07:44:29 <julianleviston> butterthebuddha: do you understand algebraic data types? (ie do you understand what we just wrote?)
07:44:41 <hpc> writing it in an object-oriented way in haskell, you'd have something like
07:44:54 <butterthebuddha> Yes, but the problem is defining a common interface for both AI and Human
07:45:05 <butterthebuddha> That smells of a typeclass
07:45:12 <julianleviston> butterthebuddha: what do you mean by common interface? of what, functions? that’s not a problem… 
07:45:20 <julianleviston> no it’s just regular functions
07:45:27 <julianleviston> be wary fo creating typeclases
07:45:30 <julianleviston> wary of*
07:45:31 <hpc> data Player = Player {movePiece :: Piece -> Direction -> something, ...}
07:45:51 <hpc> basically putting what would have been class methods, as values in the record
07:46:05 <nyc> move :: Player -> Board -> Move?
07:46:15 <hpc> "this" in those methods is the value you're accessing that function from
07:46:24 <julianleviston> in my experience it’s better to invert it tho… keep the functions on the outside of the data type… but it completely depends on where you’d like your reuse to be.
07:46:26 <hpc> an AI player would have one set of functions, a human player has another set
07:46:46 <hpc> that's if you find this approach useful, you probably don't need it
07:46:55 <julianleviston> you should definitely try both
07:47:34 <julianleviston> (if you can’t see the benefits or drawbacks of either)
07:47:47 <hpc> your players are probably not objects, fwiw
07:48:04 <hpc> you can probably just have data Player = Player {isAI :: Bool, other properties as needed}
07:48:21 <butterthebuddha> I'll probably go with what nyc suggested
07:48:34 <hpc> all these OOP ways of factoring things out assume you need it to be "open" in some way
07:48:42 <hpc> extensible, subtypeable, whatever
07:50:06 <julianleviston> it entirely depends on what things need to change or be the same.
07:50:58 <nyc> There probably need to be monads all over the place.
07:51:13 <julianleviston> lol what?
07:51:56 <nyc> Human players' moves would be obtained by IO.
07:52:39 <julianleviston> that’s not relevant tho… we push the effects out the edges, yeah? :)
07:52:40 <butterthebuddha> Yeah all my return types will be wrapped in IO
07:52:47 <julianleviston> careful!
07:53:17 <julianleviston> ideally you want to wrap as little as possible in IO.
07:53:33 <julianleviston> keep your game logic pure
07:53:33 <butterthebuddha> I don't see a way around having to wrap IO :/
07:53:39 <julianleviston> keep thinking :)
07:53:51 <sternmull> i would expect that only the way the next move is calculated depends on AI/human. The state per player and so on should be the same for AI and human.
07:53:52 <julianleviston> you have to wrap it, but you only have to wrap the very outer layer
07:54:31 <sternmull> so for the human player you will ask for input, for AI you will decide what to do based on some logic.
07:54:32 <butterthebuddha> Well, this isn't for the core game logic but for the implementing of Player itself
07:54:42 <butterthebuddha> sternmull: that's the plan
07:55:12 <sternmull> but then i don't see the need for a common interface.
07:55:58 <nyc> Getting a move from a human player fundamentally requires IO.
07:55:58 <sternmull> just two cases when deciding the move for a player
07:56:03 <butterthebuddha> There are different types of turns and for each type of turn, there is going to be a playTurnTypeX :: Player -> ... function
07:56:15 <julianleviston> nyc: no one is doubting that.
07:56:33 <butterthebuddha> The implementation for the AI player will have some internal logic for deciding how to play the turn
07:56:47 <butterthebuddha> while the implementation for the human player will just read input from the console
07:57:15 <nyc> Or GUI.
07:57:47 <butterthebuddha> The game is console-based, but in theory, yes GUI
07:57:52 <sternmull> so the AI will be a function "PlayerState -> TurnType -> BoardState -> Move" or something like that. And the human player will just be asked via IO for its Move.
07:58:25 <julianleviston> So, really, the only IO you need is to get the actual input… for the AI, it might require some RandomIO… but the parsing doesn’t require IO… and the game logic (state manipulation) definitely deosn’t require IO.
07:58:59 <butterthebuddha> Hmm, to make that happen, I would need another layer below the Player type
07:59:16 <julianleviston> below?
07:59:34 <julianleviston> what’s the player type representing, for you?
07:59:46 <butterthebuddha> ideally the logic which handles the turns doesn't care about what kind of player (human or AI)
07:59:53 <julianleviston> yup.
07:59:58 <butterthebuddha> I just have a list of players
08:00:12 <sternmull> even randomness for for the AI does not need IO during updates. Just one IO action to get a seed for a pseudo random number generator at the beginning that is then updated during the game. So the AI can be pure.
08:00:26 <butterthebuddha> and I call a function "playTurn :: Player -> Turn -> (Player, Result)"
08:00:46 <julianleviston> what’s in a Player, and a Turn, and a Result?
08:01:08 <butterthebuddha> Each turn has some state associated with it
08:01:23 <nyc> You can have an array of players as State.
08:01:42 <butterthebuddha> That's why I need a parameter (or more for some turns) to pass in the relevant state
08:02:03 <nyc> State monads to the rescue.
08:02:19 <julianleviston> generally, I’d model the entire game state as one data type.
08:02:35 <julianleviston> then you could use the state monad as the transformation as nyc is suggesting.
08:03:15 <julianleviston> tho you could also simply have a function that takes the state and the moves, and returns a new state… if it’s only doing one state transformation no need to build it into the state monad.
08:03:28 <nyc> Board could largely cover it, maybe extending it with turn tokens and move clocks.
08:03:29 <butterthebuddha> I'd need to deal with the state of the game and the state of each player
08:03:48 <julianleviston> you can be as complex or simple as you like…. this might help: http://www.happylearnhaskelltutorial.com/1/skwak_the_squirrel.html
08:03:57 <butterthebuddha> there is state associated with players and state that is shared between all players
08:04:16 <julianleviston> the state of each player can be *in* the state of the game.
08:05:47 <nyc> It sounds like butter wants information hiding so the other players are opaque at some point.
08:06:33 <butterthebuddha> yes
08:06:49 <butterthebuddha> Maybe I should abandon that
08:07:05 <nyc> It can be arranged.
08:07:24 <julianleviston> opaque to whom? keep it simple at first, and it’s easier to add complexity later.
08:10:34 <nyc> Just use state accessors for a current player and switch the current player when appropriate.
08:11:02 <julianleviston> what is a state accessor?
08:11:28 <julianleviston> do you mean record field accessor functions?
08:11:43 <nyc> Some API you make up.
08:13:38 <Eduard_Munteanu> These Haskell tutorials are getting friendlier by the day. Cute cartooney squirrels, so you don't cry about the big bad monad.
08:14:09 <julianleviston> Eduard_Munteanu: it’s been around for a while :) also there aren’t any monads in volume 1 :)
08:15:10 <butterthebuddha> So I have a type "data Player = AI { ... } | Human { ...}"
08:15:20 <butterthebuddha> and a type "data State = [Player] OtherState"
08:15:28 <julianleviston> more than two players?
08:15:44 <julianleviston> also that won’t work
08:15:59 <julianleviston> because you don’t have a data constructor
08:16:05 <julianleviston> are you new to algebraic data types?
08:16:07 <butterthebuddha> I think I'll need separate AI and Human types
08:16:42 <[exa]> butterthebuddha: what's the problem with that anyway?
08:16:43 <butterthebuddha> Sorry, "data State = S [Player] OtherState"
08:17:09 <julianleviston> yeah I’m not sure why you need separate types for AI versus Player.
08:17:32 <butterthebuddha> Anyways, the problem is that any functions on Player will need to return a value wrapped in IO because I will have to deal with the fact that their implementations for Human will need to read input from the console
08:17:50 <julianleviston> yeah I don’t think that’s the design you want to end up with.
08:18:22 <julianleviston> we generally like to push the effects (and IO is the mother of all effects) out to the *edges* of the system… 
08:18:34 <julianleviston> otherwise we may as well be writing code in a non-pure language.
08:19:35 <butterthebuddha> The other way I could do things is with two types: "data PlayerType = AI | Human" and "data Player = P SomeState PlayerType"
08:19:40 <julianleviston> if you look at the tutorial I gave you… I know it’s not amazing or full featured, but it shows the frame of keeping the effects relegated to a small part of the app that *just* deals with the IO portion.
08:20:18 <butterthebuddha> and then separate functions for dealing with each kind of player (with the logic of one wrapped in an IO)
08:20:23 * hackage pointfree 1.1.1.4 - Tool for refactoring expressions into pointfree form  http://hackage.haskell.org/package/pointfree-1.1.1.4 (BenMillwood)
08:20:24 <julianleviston> butterthebuddha: You should work out what data you want to keep for each, and then design your types after you know that information, not the other way around.
08:20:48 <julianleviston> (in my opinion).
08:21:15 <julianleviston> logic generally doesn’t need to be wrapped in IO.
08:21:48 <[exa]> butterthebuddha: maybe you want to completely separate the 'controller' logic (AI/Human) from 'view' logic (the thing looking like a robot or a human) and 'model' logic (all of them can walk and jump the same way)
08:22:28 <deltasquared> if effects were needed, would it be worthwhile to define a class derived from Monad? say class Monad m => MonadPlayer m where ...
08:22:42 <julianleviston> no.
08:22:44 <deltasquared> (if I'm remembering the trick right, I only encountered it recently in a blog post about testing)
08:22:53 <deltasquared> ... ah. ok then never mind
08:22:58 <nyc> IO is outermost in most or all monad stacks.
08:24:32 <julianleviston> deltasquared: well you *could* do all sorts of things :) but most of the time, a bunch of functions and a handful of data types is all you need, not a custom tyepclass, or even an instance of MonadIO or Monad.
08:24:48 <julianleviston> (let alone an MTL stack)
08:25:06 <julianleviston> nyc: I think you mean innermost.
08:25:22 <[exa]> outermost. :]
08:25:46 <[exa]> deltasquared: what's the use-case btw?
08:25:49 <julianleviston> it’s the one on the bottom of a stack.
08:26:10 <julianleviston> not sure how that’s outer most.
08:26:27 <deltasquared> [exa]: use case? of the technique I was suggesting? because it wasn't my problem originally :P
08:26:29 <nyc> julianleviston: Sure, whatever is more conventional.
08:26:36 <[exa]> julianleviston: MaybeT IO is an IO action that contains maybe or maybe an IO action?
08:26:59 <deltasquared> ugh, monad transformers, my brain is catching fire already >_<
08:27:24 <Eduard_Munteanu> Depends if you look at the transformer stack vs its definition.
08:28:17 <julianleviston> it’s outermost when it’s run.
08:28:19 <julianleviston> granted.
08:28:23 <julianleviston> I stand corrected ;-)
08:51:24 <julianleviston> [exa]: actually, the more I think about that, the more what I said is totally wrong, and explains quite a bit of why I found it hard to think about MTL and transformer stacks at first :)
08:55:39 <[exa]> julianleviston: it doesn't get better, the "inclusion" gets flipped once more after CPS transform :D
08:55:57 <[exa]> julianleviston: but seeing that differnce certainly makes understanding transformers easier
08:56:44 <julianleviston> where’s a contintuation passing style transform?
08:57:24 <julianleviston> I don’t have any misunderstanding now, (AFAIK ;-))… but years ago when I was first looking at them, I’m pretty sure I was quite often confused by the type alias parameter order.
09:43:17 <foozb> hello! is this an ok place to ask about compiling ghc on osx 10.7?
09:45:51 <davean> carter: You know about that!
09:46:08 <davean> carter is probably the current expert on GHC on OS X
09:46:39 <carter> foozb: what’s the question?
09:46:46 <carter> Or the problem.
10:03:08 <ph88> someone want to help me with my regex library ? i'm a bit bored working on it now, but basic functions are done. Maybe if somebody tries it i'm more motivated to add some features
10:20:49 <jmcarthur> I'm trying to name an optic  Foo s t a b  that can  construct :: b -> t  and  map :: (a -> b) -> s -> t. The naming scheme I'm using is nouns, many of which are verbs with "er" at the end, like "getter", "constructor", etc. I'm kind of stuck on this one. Any ideas?
10:21:56 <Solonarv> are you looking to invent a name, or to find out if there's an existing name?
10:22:05 <jmcarthur> I would be happy with either
10:22:23 <jmcarthur> I am not aware of an existing optic with exactly these two fundamental operations, though.
10:23:45 <jmcarthur> In case it wasn't clear, I'm trying to name it, but finding an existing name for it would of course also be helpful toward this end.
10:24:09 <Solonarv> hmm... it's almost-but-not-quite a Prism
10:24:18 <jmcarthur> That's right.
10:25:01 <Solonarv> One could also say that it's in some sense a Setter + Review
10:25:19 <jmcarthur> It's not able to set, though.
10:25:32 <jmcarthur> Ah
10:25:42 <jmcarthur> Yes it is
10:25:45 <Solonarv> your 'map' is called 'over' in lens
10:26:00 <jmcarthur> Sorry, I'm mentally remapping names and failing
10:26:17 <jmcarthur> Yes, it is the union of features of Setter and Review
10:27:11 <jmcarthur> It is the intersection of Prism and Grate (which I am only aware of in the PureScript profunctor lens library).
10:29:25 <Solonarv> Hmm, in the encoding used by 'lens' the union of Setter and Review is empty (I think)
10:29:56 <jmcarthur> We might be using intersection and union in opposite way
10:29:57 <jmcarthur> s
10:30:22 <Solonarv> er, I mean that there is no valid type which will unify with Setter and Review
10:30:24 <jmcarthur> I'm using "intersection" to describe what you get when you compose them.
10:30:30 <jmcarthur> Correct
10:32:01 <jmcarthur> I need to slow down and be more precise, sorry. This thing can become either a Setter or a Review. Setter can not become this, and nor can Review.
10:32:02 <Solonarv> in the 'lens' encoding (and with some abuse of notation) :
10:32:02 <Solonarv> Setter = forall f. Settable f => Optic (->) f
10:32:02 <Solonarv> Review = forall p f. (Choice p, Bifunctor p, Settable f) => Optic p f
10:32:25 <Solonarv> But (->) isn't a Bifunctor, so we're stuck.
10:33:32 <jmcarthur> Yeah, I'm not using van Laarhoven style or even profunctor style. I'm doing something much more annoying, because I'm implementing this in a language without HKTs or type classes, but it is able to express this relationship at least.
10:34:42 <Solonarv> What relationship does this optic express, actually? I'm curious.
10:36:52 <jmcarthur> My encoding is just a big GADT of different kinds of optics that expresses the subtyping explicitly and uses explicit conversions in the composition function. While writing that function, I'm discovering holes in the heirarchy I was familiar with.
10:37:36 <jmcarthur> In this case, the hole was discovered when implementing the composition of a Grate and a Prism.
10:37:57 <Solonarv> Makes sense
10:38:09 <jmcarthur> There were two choices for the result of the composition: Setter and Review.
10:38:16 <jmcarthur> So I made a new one which just has the abilities of both.
10:38:21 * Solonarv can't remember what Grate is for
10:38:33 <jmcarthur> Grate gives you a zipN-like operation.
10:39:10 <Solonarv> Oh, I've got a name: Shard, because that's what you get when you Grate a Prism
10:39:11 <Solonarv> :>
10:39:22 <Solonarv> or perhaps 'Shards'
10:39:51 <jmcarthur> heh
10:41:44 <jmcarthur> I'm not calling my Grate by that name anyway, because I don't think it's very descriptive. Not that my name, Builder, is *much* better, but it at least more closely resembles the fundamental operation, which is like review but with access to an arbitrary number of "template" composite values and a getter for each position in the thing you are constructing.
10:45:24 <nshepperd1> Isn't that thing basically Applicative but without <*>
10:46:14 <jmcarthur> Hmm, I see what you mean.
10:46:50 <sternmull> isnt Applicative without <*> a Functor?
10:46:50 <Solonarv> Good point, actually! Yes, that looks like a reification of Pointed the same way a Traversal is a reification of Traversable
10:47:04 <Solonarv> sternmull: no, because you still have 'pure :: a -> f a'
10:47:10 <nshepperd1> Pointed + Functor
10:47:11 <sternmull> ah, ok
10:47:24 <Solonarv> doesn't Pointed have a Functor superclass already?
10:47:55 <nshepperd1> The one in ekmett's package doesn't seem to
10:49:10 <Solonarv> Huh, I wonder why
10:49:59 <jmcarthur> Probably just because there are not laws associating point with fmap.
10:50:18 <Solonarv> Well, there is one, but it's a free theorem
10:50:24 <jmcarthur> right
10:50:35 <Solonarv> namely, fmap f . point = point . f
10:54:42 <wroathe> How do you guys say expressions like this: instance (Monoid w, Monad m) => Monad (WriterT w m) as sentences (either in your head or to others)?
10:55:22 <merijn> wroathe: Honestly, I don't really think of them in sentences/prose
10:55:32 <Solonarv> "Monad instances for WriterT w m given Monoid w and Monad m", if I have to say it
10:55:41 <Solonarv> I don't think about it that way, though.
10:55:49 <Solonarv> er, s/instances/instance/
10:55:53 <nshepperd> if i'm subvocalizing it, i just skip over all the punctuation
10:55:57 <jmcarthur> wroathe: I guess I'd say "Given a monoid w and a monad m, there is a monad (Writer T w m)."
10:56:20 <jmcarthur> But I like the others replying, I don't normally mentally pronounce it all.
10:57:04 <merijn> Solonarv's description is how I conceptualise/interpret it, but I don't actually mentally say all that :p
10:57:07 <nshepperd> instance Monoid w Monad m Monad WriterT w m
10:58:07 <wroathe> Got it, I figured as much
10:58:11 <jmcarthur> The way I just said it might make some mathematicians cringe, since it's not actually w itself that's a monoid, etc., but since in Haskell instances are uniquely identified by the type I think it's okay.
11:35:24 --- mode: glguy set +v mreh
11:35:30 --- mode: glguy set -v mreh
11:35:35 <shapr> ?
11:38:16 <koz_> wroathe: I say 'if w is a Monoid, and m is a Monad, then WriterT w m is a monad'.
11:41:26 <wroathe> koz_: That's another good one. Thanks!
11:43:55 <mreh> is there a way I can run arbitary SQL in a Beam migration? if not what do I do if I need to?
11:44:40 <mreh> I kinda doubt it, given how it's supposed to be a type safe way of migrating SQL databases
11:44:58 <wroathe> mreh: What are you trying to do?
11:45:23 <mreh> wroathe: well, for example, migrate a column and populate it from another
11:45:36 <mreh> s/migrate/create/
11:46:34 <mreh> I'm just poking around with it to see if it's going to be useful
12:09:39 <mwasteland> My friend told me functional programming is code writing code
12:10:09 <mwasteland> sounds next-level
12:10:41 <sternmull> i don't think that is a sensible definition
12:10:53 <mwasteland> oh y not?
12:11:32 <c_wraith> your friend was probably misled by lisp, which uses macros to do that all the time
12:11:44 <sternmull> was about to write that :)
12:11:48 <carter> i think they're related sometimes, but c_wraith  and others are correct
12:11:59 <carter> metaprogramming and functional techniques do overlap
12:12:02 <carter> and often complement one another
12:13:08 <mwasteland> so what makes functional programming the mentality i need to learn??
12:13:33 <sternmull> recursion and immutability are some central concepts
12:13:49 <mwasteland> i've never heard of metaproramming :0
12:14:11 <mwasteland> recursion yeah function calls itself...?
12:14:13 <Rembane> Higher order functions 
12:14:16 <c_wraith> there are a lot of things defined as "functional programming".  But yeah, immutability is the biggest thing.  (In some ways, recursion is a consequence of immutability)
12:14:17 <mwasteland> no side effects
12:14:41 <mwasteland> functions are pure
12:14:55 <sternmull> there are impure functional languages
12:15:10 <mwasteland> oh really....?
12:15:40 <sternmull> lisp, ocaml and erlang for example
12:16:09 <mwasteland> why would anyone want to use a functional language without immutability?
12:16:15 <sternmull> i think pure functional languages like haskell are in the minority
12:16:29 <mwasteland> makes it more practical?
12:16:40 <c_wraith> makes it fewer things to learn at once
12:17:15 <mwasteland> so what is the advantage of an impure functional language over an imperitive language like c++?
12:17:23 <sternmull> immutability != pure. Sideeffects make it impure, nit mutation.
12:17:52 <sternmull> s/nit/not/
12:17:56 <mwasteland> sternmull: oh wow, that's a lot of information for me. i have schizophrenia and my memory sucks
12:18:18 <c_wraith> the huge advantages you get with something like o'caml over C++ are pattern matching and an expressive type system
12:18:47 <c_wraith> algebraic data types being the complementary feature to go along with pattern matching, I suppose.
12:18:59 <mwasteland> pattern matching beyond regex like in php where you call a function to find patterns in a string?
12:19:46 <sternmull> pattern matching in functional language means branching based on the structure of a value
12:20:03 <jmcarthur> It's not quite the same idea. It's more like a generalized switch statement.
12:20:10 <c_wraith> It's like switch over an enum, but with a lot more power.
12:21:01 <sternmull> but yes, you could say that pattern matching in functional languages is in some sense similar to matching a regular expression and then using the matched groups.
12:22:24 <mwasteland> but what's enum?
12:22:49 <mwasteland> again, sorry, memory issues here and generalized computation issues as well, crossed wires in brain, i can't work
12:23:40 <sternmull> c_wraith probably was talking about enums in C and similar languages, hoping that you are familiar with switch-statements for enum values
12:24:06 <mwasteland> i'm using hexchat, looking for a good way to annotate this chat, like highlight messages i want to review later
12:24:53 <mwasteland> switch is like in my brain somewhere. but i forgot enum
12:25:38 <mwasteland> i tried copy pasting messages to a text document but it hurt my enteric nervous system too much
12:26:01 <sternmull> looks like hexchat can be scripted with various imperative languages... so a haskell channel won't help you there
12:26:27 <mwasteland> what irc client are you using?
12:26:53 <sternmull> that doen't have to do anything with haskell
12:27:39 <monochrom> You would have to set this up earlier, but: Settings -> Preferences -> Logging
12:28:21 <monochrom> But this only saves everything (after you turn it on). You will have to annotate your files manually later.
12:28:38 <mwasteland> anything can have an isomorphism to anything i think, like i could ask how a haskell programmer would solve the problem of real-time annotation? 
12:28:46 <monochrom> Sorry but this is not an iPad or Microsoft Edge.
12:29:00 <mwasteland> or i'm just stupid
12:30:02 <mwasteland> "Sorry but this is not an iPad or Microsoft Edge." lol
12:32:32 <sternmull> ah, now i undersand. Sorry. You are not here because you want to script hexchat, you just want to store the conversation that you did with hexchat.
12:39:53 <glguy> sternmull:  mniip wrote a package for scripting hexchat from Haskell http://hackage.haskell.org/package/hexchat
12:40:16 <sternmull> even that... i shut up.
12:40:44 <glguy> My IRC client is written in Haskell, but I usually script it in Lua
12:40:52 <mwasteland> i want to be able to star/highlight certain messages from this channel
12:40:56 <mwasteland> the haskell way
12:40:56 <mniip> you probably won't be able to do that with hexchat-haskell
12:41:11 <monochrom> nice
12:41:11 <mwasteland> i don't have any love affair with hexchat
12:41:15 <mniip> the lua api for hexchat has some gnome introspection support
12:41:31 <mniip> gtk introspection I mean
12:43:20 <mwasteland> if my brain was written in haskell, how would it copy certain messages to a list?
12:44:25 <monochrom> I think you're very misguided with rephrasing every IRC-usage question into a pretended Haskell question just to pay lip service to "I'm in #haskell".
12:44:51 <monochrom> Because even if someone really answered, they would write in Haskell code so the answer would be totally unusable to you.
12:45:07 <mwasteland> good point
12:45:19 <monochrom> Or even better, they would just answer the tautological "I would write code in Haskell to do it".
12:47:33 <mwasteland> okay back to haskell then
12:48:36 <mwasteland> monad
12:48:49 <mwasteland> Maybe a |
12:50:00 <mwasteland> god i'm so annoyingly lazy, sorry to be heavy on you
12:51:35 <mwasteland> i can't even understand the proof to the https://en.wikipedia.org/wiki/Halting_problem
12:51:59 <mwasteland> i'm familiar with diagonalization but i can't apply that
12:52:23 <mwasteland> sorry for off topic again
12:53:36 <mwasteland> how do you generalize a switch statement?
12:55:50 <Welkin> 1) there are no statements in haskell
12:56:05 <Welkin> 2) pattern matching is the only way you branch in logic
12:56:23 <Welkin> all specialized syntac (if then else) is built on pattern matching
12:57:28 --- mode: glguy set +v AstralDreams[m]
12:59:39 <glguy> AstralDreams[m]: You can ask now
13:00:21 <jlamothe> Can anyone explain to me why my PWData header isn't being generated here? It ahould come right after the Lenses header.  http://hackage.haskell.org/package/passman-0.1.1/docs/Password.html
13:00:24 <AstralDreams[m]> Welkin: Maybe an example matching a few exact patterns?
13:01:30 <Welkin> > let mInt = Just 3 in case mInt of Nothing -> "Nada"; Just n -> "It's " ++ show n
13:01:31 <lambdabot>  "It's 3"
13:01:50 <Welkin> for multi-line you omit the ;
13:02:00 <kuribas> phadej: Hi, I looked at the source for Value parser.  There is no annotation for error messages, maybe that could improve the error messages?
13:02:20 <kuribas> phadej: I mean <?>
13:03:15 <kuribas> phadej: and are you sure a handrolled parser would be faster?  I'd think that after inlining etc... it would be comparable to attoparsec.
13:09:33 <c_wraith> attoparsec is actually likely to be smarter than a naive hand-rolled parser.  It does a lot of tricks with buffer handling to optimize working on bytestrings
13:10:16 <c_wraith> It's a lot of work to even match it.  You *can*, but it's going to require good low-level optimizing.
13:11:55 <absence> is there something like a free Apply hiding in a library?
13:12:47 <Solonarv> 'Apply' as in 'Applicative without pure'?
13:12:56 <absence> yes
13:14:44 <Solonarv> Dunno. It should be as simple as 'data FreeApply f a where Embed :: f a -> FreeApply f a; Ap :: FreeApply f (a -> b) -> FreeApply f a -> FreeApply f b'
13:15:45 <c_wraith> if https://hackage.haskell.org/package/free-5.1/docs/Control-Applicative-Free.html is any indication, it doesn't need the Embed constructor
13:19:15 <Solonarv> I'm pretty sure you need Embed to ever get a FreeApply value in the first place
13:21:39 <absence> possibly, since liftAp uses Pure
13:24:25 <jle`> Solonarv: i don't think you need Embed
13:25:23 <jle`> oh hm, maybe you do
13:25:56 <jle`> the problem with writing Embed is that now you get a data type that has more structure than you need
13:26:28 <jle`> i think the best way might be to take the same approach as with the "free semigroup"
13:26:37 <Solonarv> the Ap constructor should probably take an 'f a' instead of a 'FreeApply f a'
13:26:48 <jle`> where we have free monoid a = Nil | Cons a (free monoid a)
13:26:56 <jle`> and free semigroup a = a :| free monoid a
13:27:10 <jle`> then you can do:
13:28:00 <jle`> data FreeApply f a where FA :: f a -> Ap f (a -> b) -> FreeApply f b
13:28:19 <jle`> (where Ap is the free applicative, from c_wraith's link earlier)
13:28:26 <Solonarv> Hm, that's one idea
13:28:57 <absence> nice
13:31:21 <jle`> but actually Solonarv's way might work as well, it gives a similar construction for free semigroup
13:31:34 <jle`> data NonEmpty a = Nil a | Cons a (NonEmpty a)
13:31:53 <jle`> i wonder why the construction used in base is different than that one
13:31:56 <kuribas> c_wraith: right
13:31:57 <jle`> probably so that we can re-use list
13:32:24 <jle`> it makes toList/fromList O(1)
13:32:38 <jle`> but the Nil a | Cons a (NonEmpty a) is O(n) toList/fromList
13:32:42 <jle`> i wonder if that is the only reason though
13:33:56 <hpc> fusion as well, probably
13:34:14 <jle`> hm, yeah. i wonder if any of those reasons carry on to a preference of how to implement the Free Apply
13:36:40 <absence> jle`: how to implement <.> though? Control.Applicative.Free's implementation doesn't typecheck, since it would attempt to <.> Ap with FreeApply. just pattern match on the Ap and use fmap if Pure?
13:36:41 <Solonarv> one reason might be that the Embed approach seems to require Functor f for the Functor (FreeApply f) instance
13:37:50 <Solonarv> OTOH (Control.Applicative.Free.Ap f) is always a Functor & Applicative, independent of f
13:38:10 <jle`> absence: <.> is analogous to <> for NonEmpty
13:38:15 <jle`> so it should look structurally similar
13:38:53 <jle`> https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#line-324
13:39:45 <jle`> (a `FA` as) <.> (b `FA` bs) = a `FA` (as <.> (b <*> bs))
13:39:49 <jle`> hm...i wonder if that typechecks
13:40:22 <jle`> oh, it's not <*>, it's liftA2 (flip ($)), unless you switch the args to FA
13:41:04 <jle`> short answer, you'd use the Applicative instance for Ap
13:42:25 <jle`> um, that entire last term is probably wrong, but yeah, just follow the example of NonEmpty :)
13:47:15 <Solonarv> this is my approach: https://gist.github.com/Solonarv/fc504314ec8dcab99a8ea92383f4080d
13:47:37 <Solonarv> the (Functor f) => is unsightly IMO, but I'm not sure how to get rd of it
13:49:15 <absence> jle`: i had to "rewrap" one FA into Ap, then i could just use <.>
13:49:21 <absence> or well, it compiles...
13:49:34 <Solonarv> With that kind of code, if it compiles it's probably correct
13:49:43 <jle`> absence: ah yeah, that's basically the same thing as NonEmpty
13:50:12 <jle`> (x :| xs) <> ys = x :| (xs ++ toList ys)
13:53:26 <absence> sounds quite sensible. i'll toy around with it and see if i get stuck :) thanks!
13:54:54 <jle`> absence: here's how mine looks, fwiw https://gist.github.com/mstksg/afda299fbf7e22acb116ff24ef8ea96d
13:57:56 <absence> jle`: more or less identical :)
14:14:14 <benzrf> jle`: :|
14:25:08 <dmj`> > (\x -> showIntAtBase 2 (head . show) x "") <$> [14,15]
14:25:11 <lambdabot>  ["1110","1111"]
14:25:30 <Welkin> > (\x -> showIntAtBase 3 (head . show) x "") <$> [14,15]
14:25:33 <lambdabot>  ["112","120"]
14:25:36 <Welkin> :D
15:55:25 <bwe> Biased answers wanted: Which package do you recommend for parsing HTML via CSS selectors? hxt-css, selectors, tagsoup-selection, dom-selector or taggy?
16:00:19 <jackdk> based on the five minutes of hacking I did once about a year ago, I liked taggy-lens
16:03:13 <ph88> how can i read line by line into ByteString ?
16:05:24 <blackcap> ph88: ByteString comes with bytestring versions of all the System.IO functions, including `getLine :: IO ByteString`
16:07:50 <ph88> oh i see
16:07:55 <ph88> i was looking in the wrong module apparently
16:10:25 <ph88> blackcap, getline is for reading from stdin
16:12:20 <blackcap> ph88: Are you looking for a bytestring alternative to `lines` from prelude?
16:13:02 <ph88> blackcap, i think lines first needs a read of all the file no ?
16:14:00 <blackcap> oh, you want all the lines from a file?
16:14:09 <ph88> yes
16:14:20 <ph88> but i prefer not to load the entire file into memory
16:14:25 <Solonarv> If you want to treat bytestrings as ASCII strings, use the functions from Data.ByteString.Char8
16:14:31 <bwe> jackdk: thx
16:14:58 <Solonarv> If you want to stream the file, ideally you should use a proper streaming library (such as conduit)
16:15:05 <ph88> Solonarv, i want to treat them as ASCII only for the point of looking for line endings .. i don't care for another further interpretations beyond that
16:15:41 <Solonarv> "line ending" is encoding-dependent, so that module is indeed the right place
16:16:00 <blackcap> it has the lines function too
16:16:23 <blackcap> so `fmap lines . readFile`
16:16:43 <ph88> readFile :: FilePath -> IO ByteString     Read an entire file strictly into a ByteString.
16:16:45 <Solonarv> Note that this will still read the entire file into memory first
16:16:54 <ph88> i don't want to read a file strictly into memory blackcap sorry
16:17:02 <Solonarv> Did you see my message about using a streaming library?
16:17:09 <ph88> yes conduit
16:17:38 <blackcap> There is also Data.ByteString.Lazy.Char8
16:17:54 <blackcap> "Read an entire file lazily into a ByteString"
16:17:57 <blackcap> ^ from the docs
16:18:04 <ph88> aha
16:18:27 <ph88> so i have two alternatives now,  Data.ByteString.Lazy.Char8   and some conduit package  right ?
16:18:50 <blackcap> I have never tried conduit
16:20:23 * hackage waargonaut 0.5.1.0 - JSON wrangling  http://hackage.haskell.org/package/waargonaut-0.5.1.0 (schalmers)
16:20:46 <Solonarv> Lazy IO (such as is done by the lazy 'readFile' mentioned above) is kind of hard to reason about and can lead to hard-to-debug errors
16:21:37 <AfC> *streamly* is a recent entry in the Streaming I/O famil tree, really nice UX.
16:24:44 <rjdp9736> :{
16:24:44 <rjdp9736> Prelude| fa :: Int -> Int
16:24:44 <rjdp9736> Prelude| fa 0 = 1
16:24:46 <rjdp9736> Prelude| fa n = n * fa (n-1)
16:24:48 <rjdp9736> Prelude| :}
16:25:17 <rjdp9736> why is fa 21 returning negative result ?
16:25:30 <hpc> > maxBound :: Int
16:25:31 <lambdabot>  9223372036854775807
16:25:36 <hpc> > maxBound :: Int + 100
16:25:39 <lambdabot>  error:
16:25:39 <lambdabot>      Not in scope: type constructor or class ‘+’
16:25:45 <rjdp9736> got it thanks
16:25:46 <hpc> > (maxBound :: Int) + 100
16:25:47 <lambdabot>  -9223372036854775709
16:25:50 <hpc> :D
16:30:10 <c_wraith> > maxBound + 100 :: Int
16:30:12 <lambdabot>  -9223372036854775709
16:30:49 <ph88> AfC, tell me more
16:31:29 <hpc> ph88: you should take a look at it on hackage and see what you think
16:31:36 <ph88> o
16:31:39 <hpc> if the api makes sense to you, maybe try it out
16:31:43 <ph88> i'm doing that
16:31:56 <ph88> i'm asking for more personal opinion
16:37:53 <ph88> hum, is this the only reading operation? https://hackage.haskell.org/package/streamly-0.6.0/docs/Streamly-Prelude.html#g:7 ??
16:37:56 <ph88> String ? Really ?
16:47:23 * hackage semirings 0.3.0.0 - two monoids as one, in holy haskimony  http://hackage.haskell.org/package/semirings-0.3.0.0 (chessai)
16:59:16 <hpc> now /that/ is a package description
16:59:58 <monochrom> Holy smoke haha.
17:05:36 <blackcap> Is it actually useful though?
17:07:06 <blackcap> I am afraid people would hate me for using the math operators for things that aren't numbers
17:07:12 <hpc> it could be useful
17:07:15 <nyc> Holy haskimony is a new one for me.
17:07:27 <monochrom> Is that a polarizing boolean question? Or is that a to-what-extent question?
17:08:34 <hpc> i like that it has an instance for Predicate
17:08:47 <blackcap> monoid-subclasses gives me gcd for monoids as well
17:09:36 <hpc> hmm
17:10:06 <hpc> i can't decide how likely i think it is that this is the future of the numeric hierarchy
17:10:31 <Solonarv> There are enough useful semirings that I think it's not too unlikely
17:10:53 <hpc> i would like it if it was, i think
17:11:00 <blackcap> yeah
17:11:10 <monochrom> Please remind me: Do regexps form a semiring?
17:11:19 <hpc> monochrom: yes, iirc
17:11:24 <monochrom> \∩/
17:11:24 <blackcap> how?
17:11:51 <monochrom> a|b is one of the two operators, the other is concatenation.
17:12:04 <hpc> kleene algebra
17:12:10 <nyc> alternation
17:12:28 <monochrom> And yeah Kleene algebra adds a* on top of that
17:12:58 <Welkin> Kleenex algebra
17:13:34 <monochrom> Too bad most people's idea of regexp does not have the empty set. Because with it you have two monoids. (But I know some academic versions that do.)
17:14:05 <hpc> you can implement the empty set with lookahead
17:14:26 <hpc> something like /(?=a)(?=b)/
17:14:43 <nyc> Epsilon is the usual symbol for it, no?
17:14:58 <monochrom> No. empty set != empty string.
17:15:09 <monochrom> empty set matches nothing.
17:15:11 <hpc> ah, /(?!)/
17:15:26 <monochrom> empty set is the identity element for alternation.
17:15:27 <hpc> (that works in perl)
17:15:34 <monochrom> emptyset | b = b
17:16:06 <hpc> and emptystring | b = b?
17:17:34 <nyc> Ø is it for the empty set.
17:17:52 <monochrom> Yeah
17:17:52 <nyc> Ø|b = b
17:18:32 <monochrom> I didn't commit to any notation because it is not like you could just try it in Perl or something.
17:18:39 <hpc> monochrom: you can
17:19:00 <monochrom> Oh, well, yeah, oops.
17:19:22 <monochrom> OK, it is not like you could try it in regex-posix or something!
17:19:29 <monochrom> (I know, famous last words.)
17:20:04 <hpc> that's a better one heh
17:20:58 <monochrom> Yikes, regex-applicative has empty set too.
17:21:05 <nyc> I'm sure a Haskell-based regex extension for it all will appear shortly.
17:21:44 <iqubi4> for what?
17:22:16 <nyc> iqubi4: Empty set regexes.
17:22:27 <monochrom> It uses Alternative for alternation including "empty" for the empty set.  Concatenation and the empty string are done as Applicative's pure and <*>.
17:22:50 <iqubi4> What is an empty set regex?
17:23:02 <monochrom> Please see the scrollback.
17:23:09 <c_wraith> a regex that recognizes zero symbols
17:23:17 <nyc> iqubi4: It matches nothing.
17:23:32 <int-e> nyc: it matches the empty string
17:23:50 <int-e> hmm. "it".
17:24:07 <monochrom> Sigh.
17:24:28 <int-e> I'm wrong, I just can't read.
17:24:38 <nyc> int-e: Point.
17:26:34 <dmwit> monochrom: I am also sad that most people's idea of regexp does not have negation or language intersection.
17:26:58 <bwe> jackdk: I am making progress with scalpel.
17:28:59 <monochrom> Yeah come to think of it, why didn't Aho include intersection?
17:29:33 <int-e> Maybe because it requires a product construction when treated with NFAs?
17:29:51 <monochrom> I am conjecturing "because, dude, this is merely 1960, 'grep xxx | grep yyy' is still more efficient than 'grep xxx&&yyy' because product automaton is too big"
17:30:35 <int-e> At least I thought the fragment was chosen to be the one where an NFA of linear size in the regular expression can be constructed.
17:31:29 <int-e> dmwit: what do you think of interleaving regular languages?
17:31:56 <int-e> (which happens to be another thing you can do with a product construction)
17:33:05 <monochrom> I think we must not unleash interleaving to the unwashed mass. Those people are already very reckless, their regexs already very unreadable, as is.
17:33:27 <nyc> 1960 predates grep by probably 10 years.
17:34:39 <Rembane> But the minds of those who wrote grep might still've been left in 1960.
17:35:39 <blackcap> Why is there not a fingertree in containers?
17:35:46 <blackcap> It has Sequence, so why not add a generic finertree too?
17:36:07 <MarcelineVQ> ph88: I'm not even sure what that helper is for tbh
17:36:25 <ph88> MarcelineVQ, from streamly ?
17:37:02 <iqubi4> So I have `type Env = M.Map String Double`
17:37:17 <MarcelineVQ> yeah, I​ mean it's fairly easy to write your own things like that so it's weird that a particular one is there at all
17:37:32 <iqubi4> Is there a way to look up a value in that map using case insensitive string comparisons?
17:38:35 <Rembane> iqubi4: If you lower the string before you put the value there and lower it before you do a lookup you can do that.
17:38:49 <iqubi4> Or upper.
17:39:05 <iqubi4> Anything better than this? (map toUpper x)
17:39:19 <iqubi4> to upperCase a string?
17:39:27 <Solonarv> Ideally, you should use Text instead of String, and use its case-folding function
17:39:44 <iqubi4> How does one use Text?
17:39:54 <iqubi4> Does that require a hackage package?
17:40:04 <Solonarv> It does require an external package, yes
17:40:17 <iqubi4> Cool. I'll get that package now.
17:40:25 <iqubi4> And then can you help me with this?
17:40:51 <nyc> Call product NFA regexes soap, because it's what the unwashed masses truly need.
17:41:06 <MarcelineVQ> ph88: like, for a Text example, you could read a lazy text via Text.Lazy.IO and map lines on it, use liftIO on that action, >>= it into Streamly.Prelude.fromList
17:42:05 <ph88> MarcelineVQ, did you use streamly ?
17:42:15 <MarcelineVQ> I've tried it but don't have heavy use
17:42:21 <ph88> ok
17:42:29 <ph88> i was asking for bytestring actually
17:42:55 <ph88> but im sure text will come in handy sooner or later
17:44:02 <nyc> monochrom: See the above about calling product NFA regexes for the unwashed masses soap.
17:44:58 <MarcelineVQ> Well same idea applies
17:47:53 <MarcelineVQ> I don't know what the process is to stay lazy while using lines in Char8 though, if you can, given that it appears to use a strict bytestring
17:48:58 <MarcelineVQ> oh there's a lazy Char8 too, nvm
17:52:18 <MarcelineVQ> "lines :: ..." "As of bytestring 0.9.0.3, this function is stricter than its list cousin." That's not... especially descriptive. If this referring to the fact that since we're dealing in chunks we can grab more than the line ending, so it's 'stricter' since we didn't really want more?
17:52:24 <iqubic> What is my username?
17:52:33 <MarcelineVQ> iqubic: for what service?
17:53:02 <iqubic> So you can tell I'm using matrix? Interesting.
17:53:26 <MarcelineVQ> You don't have the [m] no
17:54:00 <Solonarv> But /whois reveals that you're using matrix.
17:54:06 <iqubic> Well you said "for which service"
17:54:14 --- mode: glguy set +v nano4502[m]
17:54:17 <iqubic> Right.
17:54:40 <ph88> MarcelineVQ, i think you are right on that one
17:54:48 <iqubic> I would have used the matrix username `iqubic` but that was taken for some reason.
17:54:58 <ph88> need to go
17:54:58 <int-e> iqubic: /whois iqubic  also says  ircname: @mequbic:matrix.org .. which may include your matrix username.
17:54:59 <ph88> bye bye
17:55:26 <Solonarv> https://github.com/Solonarv/scorch/blob/master/lib/Scorch/TypeLevel/Disjoint.hs - kids, do not into type-level Haskell...
17:59:24 <MarcelineVQ> Solonarv: that's pretty clean so far :o
18:00:08 <Solonarv> oh, that's good to hear
18:00:24 <iqubic> This is a not what one wants to do ever. https://aphyr.com/posts/342-typing-the-technical-interview
18:00:27 <Solonarv> (can you guess what it's for?)
18:00:30 <MarcelineVQ> I mean, every other line isn't Sing so you're beating the odds
18:00:36 <Solonarv> Heh
18:00:57 <MarcelineVQ> I don't have to guess, you commented your commit
18:01:35 <iqubic> I found the 8 queens puzzle solved at the type level.
18:01:38 <Solonarv> Well yes, I meant more specifically
18:01:43 <MarcelineVQ> I don't know what Apecs is as well hehe
18:01:44 <Solonarv> iqubic: ah, I've seen that before
18:02:02 <Solonarv> MarcelineVQ: it's an ECS framework, though that isn't relevant to the file I linked
18:02:29 <blackcap> I can't wait for dependent types
18:02:35 <Solonarv> the purpose of Disjoint is making prismSum / lensProduct a bit safer
18:03:25 <Solonarv> It doesn't do any actual work, it's basically just a type-level assertion
18:03:27 <int-e> I love this line. "Haskell is a dynamically-typed, interpreted language."
18:03:32 <monochrom> Wait, what?! text now comes with GHC too?!
18:04:02 <Solonarv> That's a different Text
18:04:20 <Solonarv> (assuming you were referring to my code)
18:04:22 <iqubic> how does one even begin to understand that 8 queens solution?
18:04:41 <Clint> monochrom: yes, and parsec
18:05:39 <monochrom> Yikes.
18:06:05 <monochrom> And people were saying "GHC is trying to include fewer libraries".
18:06:18 <monochrom> It was true 5 years ago or something.
18:06:50 <monochrom> About 4 years ago it began to include mtl and transformers.
18:07:30 <Clint> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Libraries/VersionHistory
18:07:32 <monochrom> I think containers too.
18:11:00 <iqubic> I'm using containers.
18:11:16 <MarcelineVQ> "<Solonarv> It doesn't do any actual work, it's basically just a type-level assertion" Well that's the best kind of assertion :> because you don't need to toggle it and it doesn't incur runtime cost. except when you use nats and you type n = 2 ^ 32 and feel sad for the next half hour, then it might make sense to toggle them
18:11:28 <int-e> iqubic: I suppose that program translates quite directly to Prolog.
18:11:55 <MarcelineVQ> *inductive nats
18:12:33 <Solonarv> Technically 'Disjoint p as bs' is O(length as * length bs), but in practice the lists should be fairly short
18:15:55 <monochrom> OMG cabal new-run and "cabal script" which is Haskell code (with main) but has a special comment section that tells cabal a build-depends clause.  https://cabal.readthedocs.io/en/stable/nix-local-build.html#cabal-new-run
18:20:52 * hackage inchworm 1.1.1.1 - Simple parser combinators for lexical analysis.  http://hackage.haskell.org/package/inchworm-1.1.1.1 (BenLippmeier)
18:33:37 <Solonarv> wow, I've got GHCi eating close to a GB of memory with this project -.-
18:33:59 <siraben> Hi all, I'm trying to install Euterpea on NixOS but I get this error
18:33:59 <iqubic> what project?
18:34:00 <siraben> https://ptpb.pw/xxee/text
18:34:09 <siraben> Following these build instructions: https://stackoverflow.com/questions/40869437/installation-of-haskell-package-euterpea-fails-on-nixos
18:39:57 <iqubic> Is this working?
18:42:44 <siraben> iqubic: no, I get the "Setup: Encountered missing dependencies: base >=4 && <4.12" error
18:46:08 <coldpress> i have given up on ghc-mod, and i'm trying to figure out how to install aloiscochard/codex, are there any other alternatives for an IDE-like Vim?
18:46:10 <jackdk> bwe: just saw your message - good progress with scalpel?
18:51:09 <bwe> jackdk: It seems to be concise and simple to use to me.
18:53:23 * bwe wonders why stack ships only time 1.8.2 with its latest lts 13.1 while time 1.9.2 had been released on 2018-08-01.
18:53:32 <jackdk> noted for future. thanks.
18:54:01 <Solonarv> bwe: stuff like that is why I switched away from using LTS :/
18:54:33 <Axman6> What's scalpel?
18:55:10 <Clint> bwe: i imagine because ghc comes with 1.8.0.2
18:55:20 <bwe> Solonarv: but most recent nightly still ships with 1.8.0.2 https://www.stackage.org/nightly-2018-12-31/package/time-1.8.0.2
18:55:52 <Axman6> yeah I can't see LTS' ever using versions of libraries which ship with GHC that aren't the shipped version
18:56:09 <bwe> Clint: I just want to add DiffTime (seconds) to a LocalTime.
18:56:21 <Axman6> nightlies are moving targets, it would likely change if GHC has a newer version
18:56:36 <bwe> Axman6: Scraping Library https://hackage.haskell.org/package/scalpel-0.5.1/docs/Text-HTML-Scalpel.html
18:57:41 <Axman6> ah nice; I wrote a really ghetto scraper for a project we have which just used tag soup and just matches on 'a' tags where the url had the right extension
18:59:22 <Solonarv> bwe: er, s/LTS/stackage snapshots/, then
18:59:55 <bwe> Axman6: I used TagSoup a little prior, however CSS selectors mean less effort for me, Scalpel is just what I want.
19:03:49 <Axman6> wrote it 4 yeah that's a nice feature
19:06:08 <iqubic> When did you write it?
19:09:54 <iqubic> or rather... Why did you write it?
19:10:08 <Axman6> uh, 4 years ago... I got half way through that sentense 
19:10:45 <iqubic> yeah, I figured that. Now I want to know what exactly it is you wrote.
19:12:29 <Axman6> I wrote it for I wrote the service that scrapes the data for making this: https://nationalmap.gov.au/renewables/#share=s-x690xVPBlKp0BehB
19:12:54 <Axman6> bleh, it doesn't show the graphs :(
19:14:00 <Axman6> clicking on a power station, then clicking on expand and chosing 7d will show you the last 7 days of electricity generation for that generator
19:16:25 <monochrom> I used cabal new-install to install a library package of my own (not on hackage, not anywhere): "cabal new-install --lib csv-db" (the package name is csv-db, I did this in its source directory).  How do I make it available to another package of my own (again not on anywhere, only my own source directory)?  Apart from "you should put both under the same super-directory and write a cabal.project file.)
19:16:44 <monochrom> cabal-install and Cabal are both version 2.4.1.0
19:17:23 <Axman6> I'm not sure if you can with cabal; it's relatively easy with stack
19:18:08 <monochrom> I mean "new-install --lib foo" registers it in a user-level "environment" file and what good is it if it is not recognized by another new-install?
19:20:43 <Solonarv> It's supposed to make libraries available in top-level ghci/runghc/ghc, I think?
19:20:54 <monochrom> That one works.
19:21:12 <Solonarv> The proper way is to write a cabal.project.local file and hard-code the path to the dependency, IIUC
19:21:26 <Solonarv> (cabal.project.local is *not* checked into source control)
19:21:44 <monochrom> I should do that.
19:22:03 <Solonarv> or, if the dependency is in a github repo (or similar), add that repo to cabal.project
19:23:05 <jackhill> "Anoia, Chuck" <chanoia33@gmail.com>, "Brody, Martin" <martin@brody1.com>, "Durst, Charlie" <NC4CD@earthlink.net>, "Hill, Lenore" <lenore@dragonsnail.net>,
19:23:08 <jackhill>     "Ramm, Dietolf" <deeramm@gmail.com>, "Roberston, Paul" <n2xzf@nc.rr.com>, "Snyder, Dave" <w4sar01@gmail.com>, "Snyder, Karen" <karibsnyder@gmail.com>,
19:23:11 <jackhill>     "Vielbaum, Dave" <davevielbaum@yahoo.com>, "Eddleman, Dan" <de.kr4ub@gmail.com>
19:23:16 <jackhill> oops, sorry!
19:33:43 <monochrom> I think I don't even know how to do that.
19:34:50 <monochrom> But I tried: "packages markus-tools.cabal ../csv-db/csv-db.cabal"  (markus-tools.cabal and source code is in the current directory; it depends on csv-db)
19:35:47 <monochrom> With or without this cabal.project.local, I am getting the same "cabal: Could not resolve dependencies:" "[__0] unknown package: csv-db (user goal)".  (The command is "cabal new-install")
19:36:27 <monochrom> Should I be writing "pakcage csv-db \n  local-repo: whatever" instead?  But "local-repo" is being deprecated.
19:37:27 <monochrom> Plus I am not sure what's the format for a "local repo". (Actually I am sure I know and it is a lot more hoops to jump through than simply a source tree; I researched this stuff 5 years ago.)
19:37:36 <sclv> i think you give the path to the package, not to the cabal file
19:38:00 <monochrom> OK, I also tried "../csv-db" simply.
19:38:33 <monochrom> Plus the cabal user guide says both forms are the same.
19:38:48 <sclv> hm
19:38:48 <monochrom> Or rather it understands both forms.
19:38:49 <dmwit> blackcap: http://hackage.haskell.org/package/fingertree
19:39:38 <dmwit> blackcap: (Sequence does not just use that package for the usual reason: specialized forms of general data structures/algorithms can be made slightly more efficient.)
19:40:13 <sclv> i wonder if it only likes things that are in the same directory
19:40:48 <dmwit> monochrom: Don't you need a colon? As in `packages: foo.cabal bar/baz.cabal`
19:41:07 <monochrom> Yes I have a colon.
19:41:15 <dmwit> Not sure `..` is allowed, though.
19:41:54 <monochrom> Hell there is a user guide example "packages: */*.cabal ../{foo,bar}/"
19:42:08 <sclv> yeah the docs suggest that, looking now
19:42:09 <sclv> weird
19:42:12 <dmwit> Yes, I am guessing.
19:42:21 <dmwit> I do not actually know what is wrong.
19:42:52 <dmwit> Perhaps --verbose will say whether it is actually noticing your .local.
19:43:53 * hackage inchworm 1.1.1.2 - Simple parser combinators for lexical analysis.  http://hackage.haskell.org/package/inchworm-1.1.1.2 (BenLippmeier)
19:45:29 <monochrom> The output of --verbose doesn't say either way.  I will try cabal.project instead.
19:45:55 <monochrom> No change.
19:46:51 <monochrom> (At this point cabal.project has: packages: markus-tools.cabal ../csv-db/ )  (I have also checked spelling.)
19:48:23 <monochrom> The other order is also a no-change.
19:52:40 <dmwit> ?let type Word0 = (); instance Num Word0 where _ + _ = (); _ - _ = (); _ * _ = (); negate _ = (); abs _ = (); signum _ = (); fromInteger _ = ()
19:52:41 <lambdabot>  Defined.
19:53:00 <monochrom> Wow and cabal version 3.0 is in the works already.
19:53:31 <monochrom> My wish list is on it: "Added the extra-dynamic-library-flavours field to specify non-trivial variants of dynamic flavours. It is extra-library-flavours but for shared libraries. Mainly useful for GHC’s RTS library"
19:54:50 <sclv> monochrom: i wonder if it works with new-build but not yet new-install?
19:54:51 <sclv> hrm
19:56:49 <monochrom> Yes new-build is happy.
19:57:46 <Solonarv> Hmm, that's weird.
19:58:39 <Welkin> why would you use install instead of build?
19:58:51 <Welkin> I only use build and run
19:58:58 <monochrom> Because I do want the exe.
19:59:06 <Welkin> in fact, I only need to use run, because if there has been a change it will automaticaly rebuild
19:59:54 <monochrom> And because nothing in the user guide says new-install will not do this.
20:00:22 <Welkin> the guide is always out of date
20:01:40 <monochrom> And because I am also evaluating my options.
20:01:55 <Solonarv> I guess you could just: cabal v2-build && cp "$(cabal v2-exec -- which your-exe-name)" wherever/
20:02:19 <Solonarv> or a variant thereof which symlinks instead of copying
20:02:40 <sclv> i think you should file a ticket against install
20:02:46 <sclv> its much less tested than build
20:03:58 <Solonarv> Yeah, it's actually completely broken on windows
20:04:03 <Solonarv> * too
20:06:32 <monochrom> new-build doesn't use the shared build product in ~/.cabal/store though; it builds its inplace brand new copy.  (But then this is the semantics of cabal.project = "packages: xxx ../yyy" anyway.)
20:06:59 <monochrom> Then again new-install doesn't even do that.
20:07:24 <monochrom> I feel a bit sad at not sharing.
20:07:38 <sclv> yeah that would be nice to fix but its clearly a bigger project
20:09:25 <Solonarv> Hm, wouldn't new-build have to hash the entire source of your package in order to share the build product?
20:09:44 <monochrom> Well, seamless sharing is done for everything on Hackage.
20:10:06 <iqubic> What is seamless sharing?
20:10:37 <Solonarv> Yes, but in a local project you can change code without changing the package version or the hash of the package description
20:11:26 <Solonarv> Can't do that on hackage, AFAIK; so for packages from hackage <version+desc hash> is a unique identifier that always points to the same code
20:13:41 <monochrom> I guess that's why they have "secure local repo" if I really want to stay local.
20:21:38 --- mode: glguy set +v Ulbrec
20:23:16 <monochrom> Ho hum maybe I should have entered "cabal new-install all"?
20:27:23 <monochrom> Yes I need to say that and this also uses sharing in $HOME/.cabal/store
20:27:53 * hackage directory 1.3.3.2 - Platform-agnostic library for filesystem operations  http://hackage.haskell.org/package/directory-1.3.3.2 (Rufflewind)
20:28:05 <monochrom> I kind of knew it because last year or two years ago I was playing with Backpack and I learned "all" the hard way too.
20:29:01 <monochrom> No it was easier back then because the error message was "dude which project/component are you talking about?!" not the current "dude dependency fail"
20:30:38 <monochrom> Oh wait but back then there was no "new-install" whatsoever, I was using "new-build".  Today's new-build still gives the same error mesage. More accurately it is "No targets given"
20:33:02 <zenspider> seems like a usability mess
20:33:28 <Solonarv> Yeah, there's a reason the v2 commands aren't the default yet
20:39:14 <monochrom> OK so current success state: Need cabal.project to have "packages: ..." and list all the non-hackage package source trees or *.cabal files I need there.  Then "cabal new-install all" is OK.
20:40:34 <MarcelineVQ> is all a special word?
20:40:49 <monochrom> Actually with "all", cabal.project.local is just as good as the home for the "packages: ..." line
20:40:51 <monochrom> Yes!
20:44:20 <MarcelineVQ> yes to your excitement or me? :>
20:44:34 <monochrom> To your question.
20:45:25 <MarcelineVQ> ah, hmm, does this happen to be documented anywhere? a search at https://cabal.readthedocs.io/ for all (or target) doesn't lead anywhere useful
20:47:08 <MarcelineVQ> found it, search isn't very good I guess
20:47:17 <MarcelineVQ> https://cabal.readthedocs.io/en/latest/nix-local-build.html#cabal-new-build
20:48:25 <monochrom> Solonarv: I think cabal new-* does hash source code of local packages after all, even under canonical usages (e.g., have cabal.project in superdirectory, local packages in subdirectories).  See dist-newstyle/cache/source-hashes
20:49:52 <monochrom> MarcelineVQ: In my case I learned it a long time ago from a "cabal new-build" error message "... No target given ... Use the target 'all' for ... "
20:50:31 <MarcelineVQ> thank you that's also good to know, I don't use cabal currently but knowing how to use it remains important
20:50:55 <MarcelineVQ> *cabal-install :>
21:04:08 <monochrom> I have a feeling that in the future I still need to run into this 3 more times before it finally etches into my head that I always need to add "all". :)
21:06:00 <monochrom> Yes it's a usability letting down because like everyone would expect "by default, if cabal.project has a 'packages:' line then just use it; if not then look for *.cabal; if not then now it's just cause to say no target found".
21:06:53 * hackage passman 0.2 - a simple password manager  http://hackage.haskell.org/package/passman-0.2 (jlamothe)
21:07:12 <monochrom> OK maybe the flip side is "if the default is all maybe it surprises some other people".
21:08:40 <sclv> so a good ticket to file might be to amend the error message that didn't mention "all" to do so?
21:09:07 <monochrom> Gosh CLI is hard.  GUI can sidestep the whole issue because you can present all legal choices and have "all" as one of them (or equivalent GUI techniques like checkboxes) so the user is always reminded to choose.
21:12:30 <monochrom> Um, "cabal new-clean --save-config" still erases all of dist-newstyle!
21:30:51 <AfC> > Gosh CLI is hard
21:30:53 <lambdabot>  error:
21:30:53 <lambdabot>      • Data constructor not in scope: Gosh :: t0 -> t1 -> t2 -> t
21:30:53 <lambdabot>      • Perhaps you meant variable ‘cosh’ (imported from Numeric)error: Data c...
21:30:56 <AfC> Hell yeah
21:32:46 <AfC> Anyway, leaving LambdaThing out of it, I was trying to agree with you. I've been working on something that is rather opinionated about what you can and can't do on a command-line in aid of what you _can_ do being self-consistent
22:06:55 <glguy> monochrom: I'd expect that to save your cabal.project.local
22:49:20 <pdxleif> There's not a way of turning a Text builder directly into a ByteString builder, is there? Do I just have to convert the text builder into text, and then turn that into a bytestring builder?
22:52:33 <pdxleif> @hoogle Data.Text.Lazy.Builder.Builder -> Data.ByteString.Lazy.Builder.Builder
22:52:34 <lambdabot> Data.ByteString.Lazy.Builder.ASCII byteStringHexFixed :: ByteString -> Builder
22:52:34 <lambdabot> Data.ByteString.Lazy.Builder.ASCII lazyByteStringHexFixed :: ByteString -> Builder
22:52:34 <lambdabot> Data.Text.Lazy.Builder singleton :: Char -> Builder
23:21:49 <xelxebar> Do any of you here use the "GHCi on Acid" setup described in the wiki?
23:22:39 <xelxebar> I'm a bit confused on how to get lambdabot and goa installed locally and working with stack nicely
23:53:23 --- mode: glguy set +v awesomeshuks
