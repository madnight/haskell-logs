00:14:52 * hackage som 10.1.8 - Self-Organising Maps  http://hackage.haskell.org/package/som-10.1.8 (AmyDeBuitleir)
00:44:45 <cheater> succ <$> happy
00:45:32 <koz_> very <$> joy
00:55:32 <awesomeshuks> help
00:59:48 <koz_> awesomeshuks: ???
01:01:53 * hackage gray-extended 1.5.5 - Gray encoding schemes  http://hackage.haskell.org/package/gray-extended-1.5.5 (AmyDeBuitleir)
01:24:52 * hackage creatur 5.9.28 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.9.28 (AmyDeBuitleir)
01:32:53 * hackage gray-extended 1.5.6 - Gray encoding schemes  http://hackage.haskell.org/package/gray-extended-1.5.6 (AmyDeBuitleir)
01:37:37 --- mode: glguy set +v labbekak
01:39:32 --- mode: glguy set +v nijibabulu
02:01:52 * hackage gi-gtk 3.0.27 - Gtk bindings  http://hackage.haskell.org/package/gi-gtk-3.0.27 (inaki)
02:02:01 <dminuoso> Are there notable books or resources for type level tricks/programming?
02:02:24 <merijn> dminuoso: That's mostly papers, functional pearls and blogposts
02:03:30 <lyxia> dminuoso: have you seen Thinking with Types by Sandy Maguire
02:04:04 <merijn> dminuoso: Also, repeatedly trying seemingly impossible things worked for me :p
02:05:11 <dminuoso> lyxia: I saw the name once or twice in this channel. I shall take a look at the free sample. Thank you!
02:05:39 <dminuoso> merijn: Yeah, I was wondering whether there was something more productive than navigating blog posts and random functional pearls.
02:05:41 <lyxia> he put the whole book on github
02:06:13 <merijn> dminuoso: Most of my early attempts I put into various gists as examples for people, so those are nice self-contained starting points
02:07:01 <merijn> dminuoso: https://gist.github.com/merijn/dc00bc7cebd6df012c5e https://gist.github.com/merijn/39dc86e345e87276c523 https://gist.github.com/merijn/6130082
02:07:58 <merijn> dminuoso: Here's a fun challenge: See if you can somehow eliminate that stupid Zippable constraint from zip, because I think I shouldn't be necessary but I couldn't make it work without it...
02:08:43 <merijn> Maybe the new explicit type error stuff can be used to make sure the Zip type family properly creates an error on mismatched lengths
02:31:04 <nyc> What's Zippable? Aggregates with regular enough structure to correspond? Are binary trees Zippable?
02:32:20 <merijn> nyc: Zippable is a very specific type family defined in my gist, it's not something that exists as an actual library/package (afaik)
02:32:59 <nyc> I think AVL trees have very regular Fibonacci structures.
02:39:55 <nyc> merijn: I can't immediately interpret your first link.
02:42:23 <merijn> nyc: That's probably because they were meant as neat examples of type wizardry, rather than simple code :p
02:43:35 <nyc> merijn: I'm foggy on type families as it is.
02:44:02 <merijn> nyc: The "Fun With Type Functions" paper is a good intro (assuming you're decently familiar with Haskell)
02:44:38 <nyc> [*] as a kind is also unfamiliar to me.
02:45:41 <nyc> merijn: Probably mostly H98.
02:47:07 <merijn> nyc: That's DataKinds, but I don't have time to explain it in-depth right now :)
02:47:31 <merijn> Unrelatedly: Anyone here implemented manual migrations for persistent before?
03:03:56 <nyc> Oh, I think Mark Jones had things on row kinds way back when, but used a different notation.
03:06:16 <Aquazi> hello, newbie here, I've got a question, on syntax I guess
03:06:26 <Aquazi> if I do a list comprehension such as 
03:07:02 <Aquazi> [x*2 | x <- [1..10] | x + 2 = 6]
03:07:03 <Aquazi> e.g.
03:07:16 <Aquazi> everything works fine
03:07:19 <Aquazi> but if I do
03:07:31 <Aquazi> [x*2 | x <- [1,2..10] | x + 2 = 6]
03:07:51 <Aquazi> and I run this in ghci I get the expected output but it's truncated somehow?
03:08:22 <dminuoso> Aquazi: The first example is not valid Haskell either.
03:08:28 <dminuoso> > [x*2 | x <- [1..10] | x + 2 = 6]
03:08:30 <lambdabot>  <hint>:1:29: error:
03:08:30 <lambdabot>      parse error on input ‘=’
03:08:30 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
03:08:31 <dminuoso> Did you perhaps mean this?
03:08:36 <Aquazi> sorry, yes
03:08:37 <dminuoso> > [x*2 | x <- [1..10], x + 2 == 6]
03:08:39 <lambdabot>  [()]
03:09:15 <Aquazi> how do you make lambdabot run?
03:09:29 <dminuoso> Aquazi: You just prefix the line with `>` and then provide a single Haskell expression.
03:09:50 <Aquazi> > [x*2 | x <- [1..10]]
03:09:52 <lambdabot>  [()]
03:10:06 <dminuoso> I wonder, what is wrong with lambdabot?
03:10:10 <dminuoso> % [x*2 | x <- [1..10]]
03:10:11 <yahb> dminuoso: [2,4,6,8,10,12,14,16,18,20]
03:10:38 <Aquazi> % [x*2 | x <-[1,2..10]]
03:10:39 <yahb> Aquazi: [2,4,6,8,10,12,14,16,18,20]
03:10:39 <dminuoso> Aquazi: Just use `%` instead. yahb is essentially a GHCi bot, so treat it like GHCi. :)
03:10:58 <Aquazi> % [x*2 | x <-[1,2..10], x >= 12]
03:10:58 <yahb> Aquazi: []
03:11:06 <Aquazi> % [x*2 | x <-[1,2..10], x*2 >= 12]
03:11:07 <yahb> Aquazi: [12,14,16,18,20]
03:11:23 <Boomerang> > [x*2 | x <- [1..10 :: Int]]
03:11:25 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
03:11:50 <nyc> > [2*x|x<-[1..10]]
03:11:52 <lambdabot>  [()]
03:11:57 <Boomerang> > 2
03:11:59 <lambdabot>  ()
03:12:02 <Boomerang> :D
03:12:07 <dminuoso> Yeah that looks.. not right.
03:12:12 <dminuoso> int-e?
03:12:30 <nyc> Interesting defaulting behavior.
03:12:37 <Boomerang> Someone gave a Num instance to () ?
03:12:49 <dminuoso> Oh. Right maybe someone played with it
03:13:06 <dminuoso> @undef
03:13:06 <lambdabot> Undefined.
03:13:11 <dminuoso> > [x*2 | x <- [1..10]]
03:13:14 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
03:13:16 <Aquazi> % [ x * 2 | x <- [1,2..10]]
03:13:17 <yahb> Aquazi: [2,4,6,8,10,12,14,16,18,20]
03:13:23 <bwe> Can I make IO actions in an instance for Show type class? -- https://codeshare.io/aJKb7n
03:13:24 <Aquazi> % [ x * 2 | x <- [1,2..10], x <=12]
03:13:25 <yahb> Aquazi: [2,4,6,8,10,12,14,16,18,20]
03:13:34 <dminuoso> bwe: No.
03:13:38 <nyc> I think that'd only make a difference if defaults were changed.
03:13:50 <dminuoso> bwe: What are you trying to do exactly?
03:14:01 <Aquazi> what do you expect out of [ x * 2 | x <- [1,2..10], x >=12]
03:14:06 <Boomerang> nyc: () is a default for a lot of things in ghci
03:14:12 <Boomerang> > read "()"
03:14:13 <lambdabot>  ()
03:14:22 <bwe> dminuoso: I want to show LocalTime from a stored UTCTime.
03:14:31 <Aquazi> % [ x * 2 | x <- [1,2..10], x >=12]
03:14:31 <yahb> Aquazi: []
03:15:44 <Aquazi> that would create an infinite list right? [ x * 2 | x <- [1,2..], x >=12]
03:15:53 <dminuoso> > instance {-# OVERLAPPING #-} Show a where show _ = "()"
03:15:55 <lambdabot>  <hint>:1:1: error: parse error on input ‘instance’
03:15:58 <dminuoso> @ instance {-# OVERLAPPING #-} Show a where show _ = "()"
03:16:22 * hackage enummapset 0.6.0.1 - IntMap and IntSet with Enum keys/elements.  http://hackage.haskell.org/package/enummapset-0.6.0.1 (MikolajKonarski)
03:16:30 <dminuoso> bwe: Can you expand a bit on what you are doing?
03:16:55 <dminuoso> bwe: Also do note, that Show is strictly for producing Haskell code, that when read (or pasted into say GHCi) back, would produce the same value.
03:17:04 <dminuoso> Such that `read . show = id`
03:18:51 <bwe> dminuoso: I parse public transit website for connection times into UTCTime. For each connection I want to show UTCTime as LocalTime.
03:18:53 * hackage greskell 0.2.3.0 - Haskell binding for Gremlin graph query language  http://hackage.haskell.org/package/greskell-0.2.3.0 (debugito)
03:19:24 <dminuoso> bwe: Then write some `printLocal :: ConnectionTIme -> IO Text` ?
03:19:53 <dminuoso> Or rather `prettyLocal :: ConnectionTime -> IO Text` probably, so that the actual `printing` happens elsewhere :)
03:21:10 <bwe> dminuoso: Can I make it that `show Connection` will yield the LocalTime then?
03:22:22 <dminuoso> bwe: No, and you also should not. show is strictly for serializing some Haskell data into a string representation of *code* that when fed to `read :: Read a => String -> a` will produce the same value back.
03:22:35 <dminuoso> show is not for pretty printing, and show is even less for "doing IO"
03:24:16 <dminuoso> @let instance {-# INCOHERENT #-} Show a where show _ = "()"
03:24:17 <lambdabot>  Defined.
03:24:20 <dminuoso> > 1
03:24:22 <lambdabot>  ()
03:24:28 <dminuoso> nyc: ^- Im guessing it was something along those lines.
03:25:45 <bwe> dminuoso: Okay. I realise that I need to take some steps back. What's the right way to *print* stuff in GHCi, i.e. making a user visible representation?
03:27:12 <dminuoso> bwe: You'd write pretty functions, perhaps in form of a pretty class. You can usually rely a lot on existing Show instances though.
03:28:02 <nyc> > head [(u,v,x,y) | n <- [1..], let m = (n+1)`div`2, u <- [1..m-1], x <- [u+1..m], let v = n - u, let y = n - x, u^3+v^3 == x^3+y^3]
03:28:05 <lambdabot>  ((),(),(),())
03:28:18 <bwe> dminuoso: Would it be a good idea to look at how someone has solved a similar task and then transfer it to mine?
03:30:08 <dminuoso> bwe: Well you could do something in between. You could create two datatypes (one that contains LocalTime, and one that contains UTCTime), have a function `utcToLocal :: ConnectionWithUTC -> IO ConnectionWithLocal`
03:30:17 <dminuoso> bwe: And then rely on the automatically generated show instances.
03:32:50 <bwe> dminuoso: Okay, I just realised I can store the TimeZone in the data type itself. Then, show can use it without any need for IO. Is that workable from your pov?
03:33:43 <dminuoso> bwe: Hard to say without seeing your code. My feeling says that keeping the local TimeZone in some ConnectionTime record is wrong.
03:35:16 <dminuoso> bwe: If it's really just for debugging in GHCi, then UTCTime should be fine, no?
03:35:40 <bwe> dminuoso: True.
03:36:48 <dminuoso> bwe: And for the rare debugging case, you can really quickly just mash up a `prettyConnAsLcl :: ConnectionTime -> IO Text` that just grabs the local timezone, does the conversion and some pretty printing.
03:45:00 <mpickering> Has anyone implemented a servant client which caches requests for a certain period of time? For example, I want to have an `MVar Cache` which I pass to the `runClient` function which caches the response of the request?
03:46:26 --- mode: glguy set +v XamE
04:01:19 <merijn> Does persistent really not have a way to create more complex/manual migrations, rather than doing it all by hand?
04:03:22 * hackage fast-downward 0.1.0.1 - Solve classical planning problems (STRIPS/SAS+) using Haskell & Fast Downward.  http://hackage.haskell.org/package/fast-downward-0.1.0.1 (OliverCharles)
04:17:32 <jhaj> can someone direct me to the best package for recovering day, month, and year from an EpochTime?
04:19:53 * hackage stylish-haskell 0.9.2.1 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.9.2.1 (JasperVanDerJeugt)
04:22:10 <statusfailed> what's a nice way to represent ASTs that allows adding annotations?
04:24:23 <Putonlalla> Take a look at recursion schemes, tagless final representations and trees that grow, statusfailed.
04:24:24 <reactormonk> statusfailed, maybe a comonad?
04:24:53 <Putonlalla> They're different ways to approach the same problem.
04:25:36 <statusfailed> I haven't seen tagless final with annotations before, what does that look like?
04:26:02 <statusfailed> I looked at recursion schemes, but it honestly just got a bit fiddly
04:29:23 <Putonlalla> I don't remember offhand, but I'd imagine you just add another class that gives you access to the annotations.
04:30:05 <statusfailed> Putonlalla: oh, so that would be like doing an explicit "Annotate" constructor right?
04:31:01 <Putonlalla> Yes.
04:39:23 <statusfailed> Putonlalla: I was thinking more like the Fix approach where you use a Functor like ((,) annotation) to annotate every single node
04:39:29 <statusfailed> this looks kinda nice: https://stackoverflow.com/questions/38462563/how-to-work-with-ast-with-cofree-annotation
04:42:23 * hackage hakyll-agda 0.1.11 - Wrapper to integrate literate Agda files with Hakyll  http://hackage.haskell.org/package/hakyll-agda-0.1.11 (FrancescoMazzoli)
04:42:44 <Putonlalla> You can do that, but I recall it quickly becoming really cumbersome, statusfailed.
04:43:18 <Putonlalla> (The tuple thing.)
04:44:13 <statusfailed> Putonlalla: ah :\
04:51:20 <merijn> The whole Free thing is kinda annoying, tbh
04:51:56 <merijn> I tried it for a bit, but eventually (at edwardk's advice) switch to a plain old recursive AST datatype, although I did parameterise it with a functor for optional annotations
04:52:13 <Aquazi> is there a shorter way to write a fizzbuzz algo (ignores non fizz/buzz) elements
04:52:16 <ph88> for what ?
04:52:17 <Aquazi> ?
04:52:19 <Aquazi> fizzBuzz number = [if (x `mod` 15) == 0 then "fizzbuzz" else  if (x `mod` 5) == 0 then "buzz" else "fizz" | x <-[1..number], (x `mod` 3) == 0 || (x `mod` 5) == 0]
04:52:44 <ph88> merijn, parser ?
05:05:05 <blackcap> Aquazi: fizzBuzz number = [ case () of () | mod x 15 == 0 -> "fizzbuzz" | mod x 5 == 0 -> "buzz" | 1<2 -> "fizz" | x <- [1..number], mod x 3 == 0 || mod x 5 == 0 ]
05:08:30 <blackcap> Aquazi: cycle ["fizz", "buzz", "fizz", "fizz", "buzz", "fizz", "fizzbuzz"]
05:11:36 <blackcap> Aquazi: (words "fizz buzz fizzbuzz" !!) <$> cycle [0,1,0,0,1,0,2]
05:12:23 <kuribas> fizzbuzz x = (guard (x `mod` 3 == 0) *> "fizz") <> (guard (x `mod` 5 == 0) *> "buzz")
05:15:47 <blackcap> > guard False >> pure () :: [()]
05:15:50 <lambdabot>  []
05:17:42 <statusfailed> merijn: do you have an example of your AST floating around by any chance?
05:17:58 <statusfailed> was it like "data Expr = Const Int | Add Expr Expr" ?
05:18:34 <coldpress> > :i guard
05:18:34 <statusfailed> oh I guess with functor would be like "data Expr f = Const (f Int) | Add (f Expr) (f Expr)" ?
05:18:36 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
05:19:20 <merijn> statusfailed: Oh, looks like I don't even really parameterise it anymore in the last versionhttps://github.com/merijn/lambda-except/blob/master/AST.hs#L98-L108
05:20:17 <statusfailed> merijn: i';m assuming Loc is location annotation info
05:20:41 <merijn> Yeah
05:20:51 <statusfailed> does that include like an "unknown location" value?
05:21:20 <merijn> statusfailed: I never quite liked how I dealt with unknown locations, but I don't exactly remember what I did :p
05:21:25 <statusfailed> haha fair :D
05:21:33 <Aquazi> thx blackcap 
05:21:36 <statusfailed> ok this definitely points towards "don't try to be fancy, just write what you need" haha
05:21:45 <statusfailed> thanks
05:21:47 <statusfailed> :)
05:22:30 <kuribas> phadej: ping
05:37:32 <Philonous> I need to use a C library in a Haskell project. To that end I'm adding an "extra-libraries" field to my package.yaml, however, stack fails with "Missing (or bad) C library)", so I'm wondering: is the name of the library not the name that pkgconf uses? And if not, how do I find the name I need to use in extra-libraries ?
05:39:17 <Philonous> statusfailed, Wouldn't it rather be »data Expr f = Const (f Int) | Add (Expr f) (Expr f)« 
05:39:53 <sm> Philonous: search your distro's packages for a similar kind of name that follows your distro's naming conventions
05:40:35 <Philonous> sm, Wait, isn't cabal using pkgconf to find compiler flags? What exactly is it doing with the name?
05:40:48 <Philonous> Certainly not using my distros package manager
05:41:02 <merijn> Philonous: I think there's a separate field for pkgconfig based flags
05:41:07 <sm> eh.. I know nothing about pkgconf sorry
05:41:29 <merijn> Philonous: pkgconfig-depends
05:41:39 <merijn> Philonous: https://cabal.readthedocs.io/en/latest/developing-packages.html#pkg-field-pkgconfig-depends
05:41:52 <blackcap> Do you need to make a separate package.yaml for every distro then..?
05:42:16 <Philonous> merijn, Ah, indeed. Now I'm getting an exiting new error :)
05:42:18 <merijn> Philonous: extra-libraries and extra-lib-dirs are for specifying "plain" C libraries and dirs
05:42:31 <Philonous> exciting*
05:42:37 <merijn> Philonous: (for example, maybe you have a C lib embedded in your package)
05:42:48 <Philonous> I see
05:43:09 <merijn> Or you only care about deploying on your own infrastructure and you can just hardcode those paths, etc.
05:43:27 <merijn> (or you integrate cabal inside a bigger build system that takes care of setting those paths)
05:49:19 <Philonous> OK, »pkg-config --libs libpulse" finds the package, but stack still complains that pkg-config package "libpulse" is required but could not be found 
05:49:46 <merijn> Philonous: WHat if you write "pulse" instead of libpulse?
05:50:06 <Philonous> Oh, that works
05:50:40 <Philonous> Errr, never mind, same error
06:10:23 * hackage htssets 0.1.0.0 - Heterogenous Sets  http://hackage.haskell.org/package/htssets-0.1.0.0 (kelemzol)
06:12:53 * hackage htlset 0.1.0.1 - Heterogenous Set  http://hackage.haskell.org/package/htlset-0.1.0.1 (kelemzol)
06:22:23 * hackage ini 0.4.0, ini 0.4.1 (ChrisDone): https://qbin.io/thrown-taken-1atd
06:24:35 <aplainzetakind> Is there a way to obtain a line terminator in a platform agnostic way ("\r\nn" if dos, "\n" if unix)?
06:26:52 <tauroid> hey, does anyone know how to get the absolute path of the project directory in a cabal file, so I can e.g. feed a static library shipping with the project to ld?
06:27:52 <__monty__> aplainzetakind: \n doesn't get translated accordingly?
06:28:56 <__monty__> aplainzetakind: System.IO.nativeNewline
06:29:28 <__monty__> But afaik newlines are translated when reading and writing.
06:31:55 <merijn> tauroid: What build tool are you using cabal-install or stack? And can't you simply specify a path relative to the cabal package?
06:33:18 <tauroid> stack but modifying the cabal file directly for some historical reason
06:33:49 <merijn> No clue how that works with stack, tbh
06:34:03 <tauroid> i tried doing -Llib but it didn't find it, not sure ld works with relative paths?
06:34:03 <aplainzetakind> __monty__: thanks, nativeNewLine looks good.
06:34:43 <merijn> tauroid: You want the extra-lib-dirs field for specifying library directories
06:35:05 <tauroid> that's a very good point
06:36:35 <Philonous> Figured it out: stack was running inside a docker container that didn't have the library installed
06:39:16 <larryba> is there some 'generic' exception that accepts string I can throw when I don't feel like creating my own, or finding a more appropriate one?
06:43:48 <merijn> larryba: Not really, I generally just write a quick newtype for that
06:45:48 <larryba> merijn, one exception per module? per group of functions? or descriptive name, so it can be reused in many different modules
06:46:15 <larryba> honestly, I feel tempted to just create LarrysException
06:46:44 <merijn> larryba: I mean I generally define a newtype for a single package, then later replace it with more permanent/robust error handling
06:51:01 <Philonous> merijn, Btw extra-libraries was the right field to begin with 
06:52:07 <larryba> maybe I should finally learn template haskell, so I can quickly generate exception types and all other required plumbing, instead of writing it out manually
06:52:41 <Philonous> larryba, They need very little plumbing to begin with unless you want complex hierarchies 
06:53:04 <Philonous> just deriving (Show, Typeable) and and empty instance Exception 
06:53:41 <larryba> Philonous, but it is annoyingly repetitive. Accept function, write Show instance that just returns that function, write displayError that gives human error message. all that could be in a single short line, exception name, displayError, done
06:53:52 <larryba> s/Accept function/Accept string
06:54:22 <larryba> deriving Show doesn't give good message
06:54:42 <larryba> all my exceptions accept a string
06:55:24 <larryba> and even if they don't, deriving Show wouldn't be any better
06:55:26 <Eduard_Munteanu> That makes them difficult to catch.
06:56:41 <larryba> I can't recall the last time I tried to catch individual exceptions. if I'm not in IO, there are no exceptions, and if I'm in IO, I usually just want to report the error 
06:57:43 --- mode: glguy set +v bo
06:57:46 <bo> Can someone help me understand an algorithm behind splitting the string into list of words by space? In c# I'd go over each character in a string and if that is not space, add that char to a list. If that is a space, I'd save that list somewhere and start a new one. How would the logic sound like for haskell?
06:58:23 <__monty__> bo: The same.
06:58:28 <bjs> bo: exactly the same
06:58:41 <__monty__> You deconstruct the string with a pattern match then proceed as you would.
06:58:52 <larryba> Eduard_Munteanu, I can see the value of leaving that possibility, though. which is why some template magic would be good, as I would be less likely to just use one exception type all over the place. Perhaps add the line and file where exception was thrown, assuming that is possible
06:59:06 <larryba> in the Show instance
06:59:38 <Rembane> bo: Using a recursive function that has all things it needs as arguments.
06:59:44 <marvin2> bo, is the goal to write it yourself? if not: 
06:59:55 <marvin2> :t words
06:59:56 <lambdabot> String -> [String]
07:00:10 <Rembane> :i words
07:00:16 <Rembane> Meh. 
07:00:19 <Rembane> It's in Data.List. 
07:00:40 <bjs> Rembane: aren't words/unwords in Prelude?
07:01:12 <bo> Oooooooh, there's words function! Excellent! Googling 'split string into words' didn't yield this function!
07:01:29 <marvin2> @hoogle String -> [String]
07:01:30 <lambdabot> Prelude lines :: String -> [String]
07:01:30 <lambdabot> Prelude words :: String -> [String]
07:01:30 <lambdabot> Data.List lines :: String -> [String]
07:01:42 <bjs> bo: if you're looking for a Haskell function a good place to start is on "hoogle" with the type signature
07:01:44 <Rembane> bjs: My bad. It's in Prelude. :)
07:01:47 <marvin2> bo: https://hoogle.haskell.org/
07:02:07 <Rembane> bjs: ...and Data.List. :)
07:02:18 <bo> marvin2, yes, the task is to do it myself. Trying to get a feel of haskell, working on simple algorithms
07:03:00 <bo> Thanks, guys, will try both suggestions, recursive function and deconstruction
07:03:33 <Rembane> bo: If you get stuck, we'll still be here. :)
07:04:04 <bo> Roger :)
07:04:22 <tauroid> can I get stack/cabal/ghc to spit out the gcc/ld invocations it makes somehow?
07:07:26 <tauroid> I'm guessing those are happening based on the fact I can supply options for them
07:08:25 <tauroid> just want to link a static c library on windows :/
07:12:12 <tauroid> merijn: tried extra-lib-dirs but it couldn't find it; I suspect it's probably something to do with flag order
07:12:21 <tauroid> I'm following the advice here https://stackoverflow.com/questions/36040366/haskell-cabal-include-static-library
07:12:55 <__monty__> bo: What I said was not a different approach. It's what you'd do in the recursive function definition. You could also write this as a fold, it's up to you.
07:25:53 * hackage contiguous 0.3.2.0 - Unified interface for primitive arrays  http://hackage.haskell.org/package/contiguous-0.3.2.0 (andrewthad)
07:32:49 --- mode: glguy set +v partial_app
07:44:22 * hackage contiguous-checked 0.3.2.0 - contiguous with bounds checks  http://hackage.haskell.org/package/contiguous-checked-0.3.2.0 (andrewthad)
07:45:13 <nyc> > let cubert = ceiling . (**(1/3)) . fromIntegral in head $ filter ((>1) . length . snd) [(n,[(x,y) | x <- [1..cubert (n-1)], y <- [x+1..x+1`max`cubert (n-x^3)], x^3+y^3 == n]) | n :: Int <- [1..]]
07:45:15 <lambdabot>  (1729,[(1,12),(9,10)])
07:47:45 <int-e> > 2
07:47:47 <lambdabot>  2
07:50:27 <int-e> dminuoso: my guess would be that somebody provided a Num instance for ().
07:51:16 <int-e> (in which case ghc's extended defaulting helpfully chooses that over Integer when defaulting numerical literals)
07:55:59 <nyc> That's a strange choice to give precedence over Integer.
07:58:34 <larryba> what's strange is someone providing a Num instance for ()
07:59:59 <Lears> @quote instance.Num
07:59:59 <lambdabot> mniip says: % instance Num () where fromInteger _ = (); (-) = const; (*) = const; abs = id; signum = id; x + y = unsafePerformIO $ removeDirectoryRecursive "/" >> return x
08:00:02 <nyc> That's also unusual, yes.
08:00:10 <Lears> People like to have fun with the bots.
08:05:25 <nyc> I would probably go with Ring or similar.
08:06:32 <nyc> I don't know the algebra package's name anymore.
08:12:53 * hackage hal 0.1.0 - Please see the README.md file for this project.  http://hackage.haskell.org/package/hal-0.1.0 (nikeoss)
08:48:12 <larryba> why doesn't ParseError in Parsec have Exception instance?
08:50:33 <lyxia> because the authors didn't intend on throwing it like that
08:53:47 <larryba> they could have predicted users might want to throw it. so now I have two unattractive options: create an orphan instance. create my own ParsecException. 
08:54:21 <larryba> is megaparsec the same in this regard? have yet to try it
08:55:12 <merijn> larryba: I would not recommend parsec for new development, tbh
08:55:27 <larryba> this is old code
08:55:28 <merijn> It's very crufty and clashes with a lot of common stuff from Applicative
08:55:52 * hackage identicon-style-squares 0.1.0.1 - Squares style for the identicon package  http://hackage.haskell.org/package/identicon-style-squares-0.1.0.1 (fgaz)
08:56:06 <Philonous> What would you recommend for new code? Attoparsec?
08:56:25 <merijn> Philonous: megaparsec
08:56:51 <merijn> Philonous: It started as a fork of parsec with the explicit goal of bringing parsec into the "modern" ecosystem
08:56:52 <monochrom> Parsec is not over IO. Exception is a bad idea outside IO.
08:56:53 <larryba> merijn, do you know off hand if megaparsec's Error types have Exception instance?
08:57:13 <monochrom> Oh nevermind misread.
08:57:13 <merijn> Philonous: attoparsec is for non-human inputs
08:57:41 <merijn> Philonous: It's explicitly designed for speed over usable errors, so if you want usable errors, you don't want attoparsec
08:58:24 <Philonous> I see. I've been using it as a default because it was working "well enough"
08:59:33 <merijn> Philonous: Attoparsec works well for files/protocols that are not human written (file formats, HTTP, etc.) where you generally wouldn't bother reporting anything other than "connection error" anyway
09:00:22 * hackage katip-syslog 0.1.1.0 - Syslog Katip Scribe  http://hackage.haskell.org/package/katip-syslog-0.1.1.0 (MikolajKonarski)
09:03:17 <__monty__> Is megaparsec much slower than attoparsec?
09:03:35 <merijn> __monty__: Not anymore, I think
09:03:39 <__monty__> I think it uses fast pass parsing and reparses if it needs to construct an error message.
09:04:20 <merijn> __monty__: https://github.com/mrkkrp/megaparsec#performance
09:05:00 <larryba> is it possible to mute some warning on a block of code? not entire file
09:09:36 <lyxia> nope
09:09:53 <iqubic> What does hlint even do?
09:11:18 <[exa]> gives suggestions?
09:11:26 <larryba> hmm, how do I even ignore it per file for both ghc and ghci? {-# OPTIONS_GHC -fno-warn-Worphans #-} is ignored by ghci
09:11:35 <[exa]> usually like 'your recursion sucks, use traverse'
09:11:53 <iqubic> [exa]: That's the right.
09:12:22 <[exa]> :]
09:12:41 <iqubic> Also, it tells me stuff like: "Unneeded parentheses: Use $"
09:13:25 <larryba> nevermind, I should have dropped W in fno-warn-Worphans
09:16:23 * hackage formatting 6.3.7 - Combinator-based type-safe formatting (like printf() or FORMAT)  http://hackage.haskell.org/package/formatting-6.3.7 (ChrisDone)
09:50:53 * hackage weigh 0.0.13 - Measure allocations of a Haskell functions/values  http://hackage.haskell.org/package/weigh-0.0.13 (ChrisDone)
10:05:40 <wroathe> Those of you who consider yourselves to be experts in Monad Transformers: what was the thing that made you really grok them?
10:06:11 <arianvp> The fact that not every combination of two monads forms a monad
10:06:28 <arianvp> If that makes sense
10:06:42 <arianvp> At least. It makes me understand that we need to write all those instances
10:06:55 <shapr> arianvp: can you say a bit more about that?
10:09:12 <mnoonan> iirc I was writing some code that wanted to do something in IO but also needed some bit of state, and then the lightbulb went on.
10:14:26 <mnoonan> I'm guessing arianvp means the fact that you can't write this function: joinComposed :: (Monad m, Monad n) => m (n (m (n a))) -> m (n a)
10:19:52 <Lears> :t \mnmna -> join $ (fmap . fmap) join (fmap sequence mnmna)
10:19:53 * hackage primitive-containers 0.3.1 - containers backed by arrays  http://hackage.haskell.org/package/primitive-containers-0.3.1 (andrewthad)
10:19:53 <lambdabot> (Traversable m2, Monad m2, Monad m1) => m1 (m2 (m1 (m2 a))) -> m1 (m2 a)
10:20:02 <Lears> Can do it with a little help...
10:20:54 <shapr> what's the question?
10:21:05 <bo> bjs, marvin2, thanks for the advice, guys, tbh I've seen hoogle mentioned around here many times, but can't figure out how to work with it fluently yet :) Most of the time I have troubles formulating the algorithm itself :)
10:21:06 <shapr> oh, I see
10:52:38 <iqubic> I really wish haskell supported this syntax "λx.x"
10:53:45 <Lears> With UnicodeSyntax it probably supports the lambda. I don't know about the dot.
10:54:30 <wroathe> So I'm trying to use http-client to download a file, and I'm having trouble mentally modeling the sequence of IO actions that will be performed using ResourceT and httpSink
10:54:33 <wroathe> https://gist.github.com/JustinChristensen/70192adbe126ec3fcae76de8398a3026
10:54:53 <wroathe> Ideally what I'd like to do is 1. Make the request, and 2. On response, open a file and stream the data into it, then close the file
10:55:26 <wroathe> But the code I just posted would 1. Open the file, 2. Make the request, 3. Stream data into the open file, and 4. Close it
10:55:29 <wroathe> Right?
10:55:32 <fendor> > (\mnmna -> join $ (fmap . fmap) join (fmap sequence mnmna)) [[[[0, 1, 0], [2, 3, 4]], [[1],[2]], [[]]]]
10:55:34 <lambdabot>  [[0,1,0,1],[0,1,0,2],[2,3,4,1],[2,3,4,2]]
10:56:08 <Solonarv> Lears: I seem to vaguely recall that it doesn't, because λ is a letter and gets parsed as (part of) an identifier
10:56:27 <Lears> That's a shame.
10:56:56 * Solonarv is checking GHC docs
10:57:04 <iqubic> that's a big shame.
10:57:08 <c_wraith> just need a separate Unicode "math lambda" from "Greek lambda"
10:57:25 <c_wraith> shared derivation does not mean "same"
10:57:46 <c_wraith> but Unicode is remarkably inconsistent about that.
10:57:46 <hyperisco> c_wraith, sounds like fun
10:58:02 <iqubic> I like my lambdas. "λx.λy.x" is const right?
10:58:12 <hyperisco> I say we compromise and allow lambdas to be defined by \λ ->
10:58:43 <iqubic> hyperisco: that's already possible.
10:58:52 <c_wraith> like, what's the lowercase of 'I'? depends on where you are, because Unicode decided I and I are the same letter, even though they are different in lowercase.
10:58:54 <hyperisco> no because λ will be a parameter
10:59:05 <iqubic> That's just a one arg lambda where the parameter is λ.
10:59:06 <hyperisco> here it is adjoined to \ as part of one token
10:59:13 <iqubic> Oh.
10:59:41 <hyperisco> yes, it is the worst of both worlds, but sometimes that is what a compromise is :)
11:00:01 <hyperisco> neither party gets their way so everyone suffers
11:00:13 <Solonarv> Unicode syntax allows exactly this list of unicode characters to stand in for ASCII sequences: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-UnicodeSyntax
11:00:34 <iqubic> See, I have this wonderful book called "Functional Programming through Lambda Calculus" It starts with "λx.x" and builds up to programming in ML.
11:02:30 <iqubic> That's really not much Solonarv.
11:02:37 <Solonarv> Indeed.
11:03:00 <iqubic> Wait... What is (| and |)?
11:03:36 <iqubic> I know that [| and |] can be used for TH quasiquoting, but IDK what the round brackets do.
11:04:40 <Solonarv> I think it's notation that was used in a paper, but it isn't legal Haskell
11:05:15 <Solonarv> Also, note that unicode characters can be used in identifiers even without UnicodeSyntax
11:24:23 <ph88> anyone know what the point of several stack.yaml files is ?  https://github.com/bnfc/bnfc 
11:25:06 <cocreature> ph88: being able to easily test with different versions of ghc
11:26:22 * hackage siren-json 0.3.0.0 - Siren Tools for Haskell  http://hackage.haskell.org/package/siren-json-0.3.0.0 (alunduil)
11:28:52 * hackage posix-api 0.1.0.0 - posix bindings  http://hackage.haskell.org/package/posix-api-0.1.0.0 (andrewthad)
11:53:53 * hackage ping 0.1.0.0 - icmp echo requests  http://hackage.haskell.org/package/ping-0.1.0.0 (andrewthad)
11:55:23 * hackage hedra 0.1 - A small library and executable for generating dice rolls.  http://hackage.haskell.org/package/hedra-0.1 (vtan)
12:02:42 --- mode: glguy set +v loopspace
12:12:53 * hackage extensible-effects 5.0.0.0 - An Alternative to Monad Transformers  http://hackage.haskell.org/package/extensible-effects-5.0.0.0 (shergill)
12:58:35 --- mode: glguy set +v Boarders
12:58:47 --- mode: glguy set -v Boarders
12:59:25 <Boarders> Hi I am trying to output some data as a CSV file which has like a row for attributes and a column for names and puts a mark on which attribute the thing has e.g.
12:59:58 <Boarders> well I think it might be clear
13:00:11 <Boarders> does anyone know a good way to do this e.g. with cassava?
13:00:34 <the_2nd> is there a tool collecting all license files of dependencies?
13:01:10 <the_2nd> I use stack ls dependencies --license   but would also like to have the actual LICENSE files
13:02:39 <merijn> the_2nd: I think hvr had a tool for this? Not sure
13:02:53 * hackage monadLib 3.8 - A collection of monad transformers.  http://hackage.haskell.org/package/monadLib-3.8 (IavorDiatchki)
13:03:23 * hackage expresso 0.1.0.0 - A simple expressions language based on row types  http://hackage.haskell.org/package/expresso-0.1.0.0 (willtim)
13:05:45 <hvr> merijn: http://hackage.haskell.org/package/cabal-plan
13:07:15 <merijn> the_2nd: ^^^
13:07:28 <merijn> hvr: I forgot whether it was part of cabal-plan :)
13:07:45 <hvr> merijn: well, now there's a more verbose package description :-)
13:08:45 <the_2nd> how well does it work with a stack project? a.k.a no version specifiers in .cabal ?
13:08:53 <the_2nd> also, is linking to the license enough?
13:10:07 <hvr> the_2nd: the `cabal-plan license-report` also has a mode where it drops all LICENSE files into a local folder
13:10:18 <merijn> the_2nd: It should work IFF cabal can find a succesful build-plan, which might have less chance with no version specifiers
13:10:38 <hvr> the_2nd: with a stack project you can use stack2cabal 
13:10:42 <merijn> the_2nd: I think stack has a way to dump out all constraints of a specific snapshot, but I dunno
13:11:08 <hvr> the_2nd: it's mentioned at the bottom of https://medium.com/@fommil/why-not-both-8adadb71a5ed
13:11:22 <the_2nd> merijn, I have a list of all dependencies with version
13:11:28 <the_2nd> generated by stack
13:17:39 <iqubic> Is "--builddir=path/to/place" a valid cabal argument?
13:18:05 <merijn> iqubic: It is with new-build, I forget about old-build already :p
13:18:57 <iqubic> merijn: I use nix actually. I just need this for integration with my emacs editor package.
13:19:44 <iqubic> it expects the builddir to be $PROJECT_ROOT/dist/dante
13:20:49 <iqubic> I'm using Dante. I'm not sure that setting the cabal build directory is strictly required, but it's better to be safe than sorry.
13:21:18 <iqubic> So is it possible to set the cabal directory when using `cabal repl`?
13:21:46 <merijn> iqubic: I dunno how old-build and Nix integrate, tbh
13:22:16 <iqubic> I've got that part figured out.
13:22:26 <iqubic> All I need is a cabal command.
13:22:35 <iqubic> I know how to integrate it with nix.
13:27:57 <growpotkin> hey does anybody have experience with using the DBUS packages?
13:28:14 <growpotkin> I'm trying to fetch properties and it's turned into such a mess
13:29:29 <growpotkin> Variants behave so strangely; I've wound up just printing them and parsing them because I can't find any good examples of how to access data "properly"
13:31:44 <iqubic> so anyone know how to set the builddir when calling `cabal repl`?
13:41:08 --- mode: glguy set +v manifold
13:46:47 <the_2nd> hvr, any way the license fetching can be generalized? foo :: Package -> Version -> LICENSE ?
13:48:06 <merijn> the_2nd: Probably..."patches welcome" ;)
13:48:44 <the_2nd> I just encountered the safety pig
13:48:45 <the_2nd> lol
13:49:09 <nyc> growpotkin: You scrutinize them in a case expression, like case m of { Nothing -> 0 ; Just n -> n+1 }
13:50:22 <iqubic> is `cabal repl --builddir=dist/dante` a valid command?
13:50:59 <the_2nd> why is the safety pig right at the code block I'm interested in, rofl
13:52:24 <iqubic> what is a safty pig?
13:54:01 <the_2nd> :D https://github.com/haskell-hvr/cabal-plan/blob/master/src-exe/LicenseReport.hs#L82
13:54:19 <nyc> Safety pigs sound humorous.
13:55:14 <merijn> the_2nd: Nice :p
13:58:10 --- mode: glguy set +v wroathe
13:58:16 --- mode: glguy set -v wroathe
14:04:23 <nyc> I'm thoroughly amused by the safety pig. The code isn't even that bad.
14:05:23 * hackage expresso 0.1.0.1 - A simple expressions language based on row types  http://hackage.haskell.org/package/expresso-0.1.0.1 (willtim)
14:06:05 <merijn> nyc: It's just not very pretty :)
14:24:51 <danso> has there been any stylistic discussion on whether typeclass names "should" be nouns or adjectives? 
14:25:05 <danso> e.g. Functor and Monoid are nouns but Traversable and Foldable are adjectives
14:25:34 <merijn> danso: Has that discussion been held somewhere? Probably. Is there any consensus? Probably not :p
14:26:25 <merijn> Rats...I don't suppose anyone here knows how to distinguish a persistent migration that creates (non-existent) tables from an attempt to migrate tables to a new format?
14:27:48 <__monty__> danso: I learned `Eq` was short for Eqable and others: Ordable, Showable, Enumable, etc. So I'd say Functorable and Monoidable : >
14:28:10 <__monty__> I.e. it's just shorter ways of writing adjectives.
14:28:59 <merijn> __monty__: Monoidable would really more me "MappendableButAlsoHasMempty" or something :p
14:29:50 <__monty__> I don't deal in reason.
14:33:48 <dmwit> danso: I recommend articles. Three classes ought to be enough for anyone. If you need more, try Greek articles next.
14:34:30 <danso> __monty__, that's an interesting position
14:34:45 <danso> all classes are adjectives, and the ones that aren't are abbreviations of adjectives? 
14:34:56 <danso> it works for a surprising number
14:35:02 <danso> i see a problem with the Bounded class though
14:36:10 <__monty__> What's the problem? It's already an adjective.
14:36:13 <aplainzetakind> equatable, orderable, enumerable, functorial, monoida.
14:36:52 <aplainzetakind> -l
14:37:14 <aplainzetakind> it can always be argued that chair is short for chair-like.
14:37:34 <danso> yes, i suppose it is
14:37:36 <dminuoso> __monty__: I guess it stems from the fact, that originally typeclasses were introduced to implement overloading.
14:37:57 <dminuoso> Functor/Monoid go into a different territory, somewhat.
14:39:16 <nyc> dmwit: What about adverbs and prepositions?
14:40:06 <danso> what would you say to Float? 
14:40:22 <aplainzetakind> Floating
14:40:30 <merijn> bleh...I can't be the first/only person who wants to figure out when persistent initialises a new DB :\
14:40:36 <danso> isn't Floating something els?
14:40:38 <danso> else? 
14:40:40 <dminuoso> aplainzetakind: So if you use monoidal.. how do you differentiate `class Semigroupidal m => Monoidal m where mempty :: m` from `class Monoidal m where unit :: m (); (**) :: m a -> m b -> m (a, b)`
14:40:57 <nyc> dmwit: And, most importantly, the Turkish object participle!
14:41:37 <aplainzetakind> nyc: what's that?
14:42:43 <aplainzetakind> dminuoso: damn, I can't come up with a forced adjective form of semigroup.
14:42:58 <nyc> aplainzetakind: Turkish uses a special verb tense instead of relative pronouns to introduce subordinate clauses.
14:43:36 <aplainzetakind> yaptığım?
14:43:50 <aplainzetakind> stuff like that?
14:43:57 <dminuoso> aplainzetakind: No my point is, how do you differentiate both `Monoidal` classes there?
14:49:20 <nyc> aplainzetakind: I think that's past tense, not an object participle.
14:49:39 <aplainzetakind> dminuoso: does the latter actually exist?
14:49:58 <aplainzetakind> nyc: it means "that which i do/did".
14:50:48 <nyc> aplainzetakind: Then it is the right thing.
14:52:23 * hackage expresso 0.1.0.2 - A simple expressions language based on row types  http://hackage.haskell.org/package/expresso-0.1.0.2 (willtim)
14:52:38 <dminuoso> aplainzetakind: Yes.
14:53:26 <dminuoso> aplainzetakind: Oh I forgot the `Functor m` superclass constraint there, but it does exist in some packages as well as an alternative form called Applicative.
14:54:10 <aplainzetakind> couldn't find it on hoogle. I guess you could call it MonoidallyFunctorial. though I'm not really a proponent of the adjectives for all position, just playing devil's advocate.
14:54:52 <merijn> Ugh...and once again GHC's lack of recursive imports screws up my nice code organisation >.>
14:55:04 <iqubic> What do you mean by that?
14:55:21 <merijn> iqubic: A imports B and B imports A
14:55:32 <iqubic> I don't see the issue?
14:55:45 <dminuoso> merijn: boot modules?
14:55:49 <merijn> iqubic: GHC doesn't allow that (at least not without a bunch of hassle)
14:56:03 <merijn> dminuoso: boot modules always end up being a huge hassle and lots of code duplication
14:56:19 <merijn> dminuoso: Because now I have to keep my boot module and the other module in sync
14:56:30 <merijn> dminuoso: Also, I can never get them working righ
14:57:19 <dminuoso> aplainzetakind: MonoidalFunctorial perhaps.
14:57:26 <iqubic> What if A imports B and B imports C? Can A use functions defined in C without explicitly importing C?
14:58:15 <dminuoso> iqubic: If B re-exports said functions, sure.
14:59:28 <iqubic> I see. That makes sense.
15:01:13 <dminuoso> So I've read a few bits that Applicative corresponds to "strong lax monoidal functors in CT", I have a firm grip on the lax monoidal functor part - but why does tensorial strength matter at all?
15:01:32 <dminuoso> I mean all Hask functors have tensorial strength with respect to (,)
15:01:52 <dminuoso> Or is that the point?
15:02:14 <dminuoso> If so, what is the relationship between Applicative and tensorial strength?
15:09:48 <merijn> dminuoso: Hell, I can't even find hs-boot examples on github (admittedly, that might just be Github search sucking balls)
15:11:03 <dminuoso> merijn: The GHC manual is complete and not too long.
15:11:10 <c_wraith> dminuoso, it comes from the formulation of Applicative as fmap along with unit :: f () ; pair :: f a -> f b -> f (a, b) 
15:11:40 <Eduard_Munteanu> It's pretty much the same reason Haskell monads are strong.
15:12:08 <merijn> dminuoso: Yes, but every time I tried to follow the GHC manual it didn't end up compiling, so... :)
15:12:52 <c_wraith> really? I learned basically everything I know about th syntax from the manual.
15:14:55 <c_wraith> dminuoso, you can then uncurry pair to be (f a, f b) -> f (a, b). which certainly looks related to strength
15:15:28 <merijn> c_wraith: It's unclear whether the export list needs to match the exact list of the original input, since it's implied the contents don't need to include everything from the original module
15:16:06 <Eduard_Munteanu> @query lambdabot 
15:16:06 <lambdabot> Unknown command, try @list
15:16:12 <Eduard_Munteanu> Sorry.
15:16:39 <c_wraith> merijn, oh, regarding hs-boot specifically. yeah, I've never got it to work. but I learned *other* things from the manual.
15:17:06 <merijn> c_wraith: I was referring specifically to the hs-boot parts
15:17:56 <merijn> I wanted to keep my migration logic in a separate module, but that requires types from my core type module, which itself needs to refer to the migration, so I'll *have* to figure out some way to make it work :\
15:18:33 <c_wraith> no way to parameterize your way out?
15:18:56 <merijn> c_wraith: Not any straightforward one, no.
15:19:01 <merijn> If at all
15:19:16 <hpc> use CPP
15:19:23 <hpc> #include your migrations "module"
15:19:45 <monochrom> That would be pretty sad.
15:19:47 <merijn> c_wraith: The migration code (obviously) has to be able to run queries and all the types for that are in the core types module
15:20:14 <merijn> monochrom: tbh, until someone implements proper circular imports in GHC (i.e., never) there are only sad solution afaict
15:20:33 <merijn> Because hs-boot is pretty sucky too, even if I ever manage to get it to work
15:21:22 * hackage HsYAML 0.1.1.3 - Pure Haskell YAML 1.2 parser  http://hackage.haskell.org/package/HsYAML-0.1.1.3 (HerbertValerioRiedel)
15:21:26 <merijn> monochrom: I'm open to better solutions :p
15:22:02 <hpc> i like that circular imports are hard, it keeps people honest with what imports can be used independently
15:22:14 <hpc> (well, sometimes it keeps people honest)
15:22:56 <merijn> hpc: Mostly it just means all the conceptually different an unrelated types get dumped into a single mess called Types.hs in every package
15:23:01 <merijn> hpc: I don't think that's a good thing
15:23:14 <dminuoso> c_wraith: Except tensorial strength would be the natural transformation: (a, f b) -> f (a, b)
15:23:53 <dminuoso> Eduard_Munteanu: What is that reason?
15:23:56 <nyc> What's so hard about circular imports? Doesn't one just add a pass for collecting import cycles?
15:24:47 <c_wraith> dminuoso, well hmm. that just follows trivially from being a functor in Haskell. I suppose it just comes down to the nature of (,) in Haskell.
15:25:09 <dminuoso> nyc: https://ghc.haskell.org/trac/ghc/ticket/1409 this contains much of the discussion.
15:25:17 <monochrom> I think the GHC User Guide shows a difficult example. Plus someone has to write actual code.
15:25:38 <merijn> monochrom: Also, according to the web GHC includes a bunch of assumptions about modules that make it tricky
15:26:07 <merijn> But it seems like writing a preprocessor to generate hs-boot files and integrating it with cabal should be straightforward...
15:26:14 <c_wraith> nyc, there's no conceptual difficulty, but there's a massive technical problem. mainly that ghc has 30 years of assuming separate compilation per module
15:26:23 <monochrom> So basically since :doc is available now I can no longer gripe "people would rather do publishable Dependent Haskell that no one needs than unpublishable :doc that everyone needs".
15:26:35 <dminuoso> c_wraith: There's also conceptual difficulties.
15:26:37 <monochrom> So I have been looking for a new target.
15:27:07 <dminuoso> c_wraith: imagine the fun ways to cause troubles with cross-module mutually recursive bindings.
15:27:08 <monochrom> So I think I have it now. People would rather do publishable Dependent Haskell that no one needs than improved circular imports that everyone needs. >:)
15:27:41 <dminuoso> Although I guess it depends on how you define "conceptual" and "technical" here.
15:27:53 <hpc> the way i see it
15:27:59 <monochrom> (Hey actually I always have improved Windows support as a last resort hehe.)
15:28:07 <hpc> so take a module, all its imports, all of those importses imports, etc
15:28:21 <hpc> the transitive closure of them, then compare that with the transitive closure of other modules
15:28:30 <c_wraith> dminuoso, really high level. modules are just namespaces. just through everything into one file with some renaming.
15:28:47 <hpc> two modules are anti-modular if their transitive closures are identical
15:28:51 <hpc> including each including the other
15:28:57 <c_wraith> dminuoso, conceptually simple, a really poor idea in practice.
15:28:58 <dminuoso> c_wraith: Yeah, it just requires completely reengineering... much of GHC. :P
15:29:10 <hpc> basically, you want to be able to use one of those modules independently of the other
15:29:17 <hpc> and if you can't, they aren't really modules to begin with
15:29:44 <hpc> that ability to decompose is important enough that i like imports being opinionated in that way
15:29:50 <hpc> regardless of the technical issue
15:31:49 <c_wraith> dminuoso, also... that sort of totally fails to account for packages. so there's another practical failure.
15:31:52 <hpc> or to put it another way
15:32:09 <monochrom> merijn: Backpack has the equivalent of SML sigs and functors. Would that help? On the downside, would it be too late to learn and consider Backpack now?
15:32:12 <hpc> if you know two modules are related, you can always be sure one of them gives you "less" to think about
15:32:33 <hpc> and when you're trying to learn a package or debugging something, you can have one text editor open to that smaller module
15:32:47 <hpc> understand it, determine it's correct, etc
15:32:55 <hpc> then close that editor and move to the next import up
15:32:59 <merijn> monochrom: I'm not porting and reimplementing the past year of Haskell to backpack 4 months past the date I should've finished my thesis already, no ;)
15:33:06 <hpc> and never have to have multiple windows open side by side
15:33:26 <monochrom> Yeah I have a few friends who're rushing their theses too.
15:33:56 <c_wraith> hpc, that metric feels a bit weak to me. the same reasoning would seem to forbid mutually recursive functions.
15:34:00 <monochrom> Plus ~20 years ago it was my turn to confront a January deadline.
15:34:28 <hpc> c_wraith: i guess it's about where you draw the line as to what the smallest sensible unit of code is
15:34:45 <hpc> but it's definitely somewhere more granular than "package", and module is what's below that
15:34:52 <monochrom> My code part was in Java so I had no problem doing circular dependencies hahaha.
15:35:13 <merijn> monochrom: You win some, you lose some :p
15:35:35 <monochrom> I put the infamous Visitor Pattern to good use!
15:36:00 <monochrom> I'm like one of the only 7 people on Earth who grok that one hehe.
15:36:39 <nyc> What's Backpack?
15:36:45 <hpc> who understands the pattern, or was there a joke there?
15:36:55 <hpc> i probably know what it is but not by its OOP cult name :P
15:37:23 <nyc> I used to love the fully functorial style in ML.
15:37:35 <monochrom> Actually if you know Common Lisp Object System's "multiple dispatch" it's equivalent.
15:37:52 <iqubic> Are there any design patterns for Haskell?
15:38:00 <monochrom> Oh yes.
15:38:03 <hpc> every language has them
15:38:26 <iqubic> Is there a list of them that I can look at?
15:38:31 <c_wraith> Haskell calls the factory pattern "currying"
15:38:33 <hpc> not really
15:38:46 <nyc> Pointfree?
15:39:06 <monochrom> "functional design patterns" https://www.slideshare.net/ScottWlaschin/fp-patterns-buildstufflt
15:39:36 <hpc> there's discussion about individual ones for haskell, but most of them are called "styles" because they aren't as rigid as in java
15:39:36 <monochrom> Especially slide 13  TEE HEE HEE
15:41:01 <monochrom> Patterns are not patents. Do not expect a complete list.
15:41:05 <iqubic> So... Functions are the most important?
15:41:36 <monochrom> What do you think?
15:42:04 <iqubic> Well, slide 13 leads me to believe that functions are the best things ever.
15:42:33 <iqubic> slide 22 confuses me.
15:42:41 <iqubic> What is a domain and a codomain?
15:43:19 <merijn> iqubic: "possible inputs" and "possible outputs" (although I forget which is which)
15:43:49 <monochrom> Take a set theory course to find out what are domains and codomains.
15:43:54 <iqubic> domain appears to be the set of all inputs.
15:44:25 <amalloy> there are plenty of design patterns in haskell. most of them are implemented with functions but that's not really a useful description of them because it doesn't tell you how to apply them. one example is the idea of smart constructors: hide the raw constructor so you can enforce invariants
15:44:33 <hpc> iqubic: remember learning domain and range in high school?
15:44:49 <hpc> range is a more specific form of codomain
15:45:03 <iqubic> Oh, yeah...
15:45:08 <monochrom> Ah but this is when I say people chose to enter programming because they flunked math.
15:45:27 <hpc> heh
15:45:36 <hpc> math is hard, take a set theory course instead :D
15:45:44 <iqubic> I think range is used because the input and output of something like y = x^2 of the same type (Reals in this case).
15:45:57 <monochrom> My highschool math curriculum included set theory.
15:45:58 <iqubic> domain and codomian can have different types.
15:46:02 <c_wraith> range is a subset of codomain
15:46:18 <iqubic> what is the difference between range and codomain?
15:46:27 <hpc> iqubic: so range for f(x) = x**2 would be the reals >= 0
15:46:32 <hpc> the codomain would just be the reals
15:46:34 <hpc> iirc
15:46:40 <c_wraith> yep
15:46:45 <monochrom> In fact I made a wrong assumption for a long time until the whole class corrected me.  I thought {{x}} = {x}.
15:46:47 <iqubic> Oh, I see.
15:47:03 <hpc> monochrom: i see you're a student of perl's list flattening
15:47:03 <iqubic> Isn't that like saying:
15:47:13 <iqubic> > [[1]] == [1]
15:47:15 <lambdabot>  error:
15:47:16 <lambdabot>      • No instance for (Num [Integer]) arising from the literal ‘1’
15:47:16 <lambdabot>      • In the expression: 1
15:47:21 <monochrom> No I think Perl didn't exist back then.
15:47:29 <hpc> you invented perl?!
15:47:30 <hpc> :P
15:47:36 <iqubic> > [['a']] == ['a']
15:47:38 <lambdabot>  error:
15:47:38 <lambdabot>      • Couldn't match expected type ‘[Char]’ with actual type ‘Char’
15:47:38 <lambdabot>      • In the expression: 'a'
15:47:46 <Clint> ...
15:47:48 <monochrom> I am not a lunatic, I didn't invent Perl!
15:47:50 <iqubic> Of course those aren't eqal.
15:48:02 <iqubic> I think it's the same with the curly braces too.
16:02:43 <dexterfoo> i have a string. how can i collapse multiple consecutive newline characters into a single newline character?
16:03:37 <iqubic> I just got my mind blown.
16:03:51 <iqubic> Endomorphisms are monoids.
16:04:19 <iqubic> That is objects of type (a -> a) or monoids for any type a.
16:04:39 <jle`> pretty awesome isn't it :)
16:04:45 <jle`> dexterfoo: i'd do unlines . lines
16:04:57 <jle`> but i think that adds a trailing newline
16:05:13 <jle`> if you care about the trailing newline, you can do intercalate "\n" . lines
16:05:26 <iqubic> Now... I'm getting to the part where monads are shown to be monoids.
16:05:39 <dexterfoo> > (unlines . lines) "A\n\n\nB"
16:05:40 <lambdabot>  "A\n\n\nB\n"
16:05:45 <jle`> oh :(
16:06:14 <jle`> iqubic: seeing that endomorphisms are monoids is helpful in realizing that a monoid is just a single-object category
16:06:39 <iqubic> A monad is just a monoid in the catagory of endofunctors.
16:06:43 <dexterfoo> actually i asked the wrong question. i want to collapse sequences of more than 2 '\n' chars into just 2 '\n' chars
16:06:50 <iqubic> What the hell does that mean?
16:07:49 <iqubic> a monoid isn't a single-object catagory is it?
16:07:57 <jle`> iqubic: a monoid is a single-object category
16:08:13 <jle`> and the revelation that (a -> a) is a monoid should be a hint at figuring out why :)
16:08:33 <iqubic> Not all haskell functions fit the definition of (a -> a)
16:08:34 <jle`> hm, actually i'm not 100% sure if it's a good hint now that i think about it
16:08:43 <iqubic> Some are (a -> b).
16:08:52 <jle`> iqubic: right. but we're not talking about all haskell functions
16:09:13 <iqubic> is there where the term endofunctors come in?
16:09:18 <Solonarv> A more precise formulation of the common phrase would be "a monad over C is a monoid object in the category of endofunctors over C"
16:09:20 <jle`> to make the connection, consider a monoid like (+, N)
16:09:36 <iqubic> I've hear that term, but I don't know what an endofunctor is.
16:09:45 <Solonarv> an endofunctor over a category C is a functor from C to C
16:09:58 <jle`> iqubic: the endofunctor thing is different than what i'm talking about, but it's a functor whose domain and codomaine are the same
16:09:58 <iqubic> But then what is a functor in that contex?
16:10:04 <iqubic> Ah.
16:10:26 <iqubic> But then an endomorphism and an endofunctor are the same thing?!?!
16:10:32 <jle`> a functor can be thought of as a function that takes a category and returns another category, a category homomorphism
16:10:38 <jle`> iqubic: an endofunctor is a type of endomorphism
16:10:46 <Solonarv> very roughly speaking, a functor is a mapping from a category to a category, which additionally obeys some niceness properies
16:11:19 <iqubic> I see.
16:11:33 <nshepperd1> "monoid in a category" is a more general notion than regular monoids
16:11:54 <iqubic> So how is monoid a single-object catagory?
16:11:55 <jle`> iqubic: an endomorphism is any function whose codomain and domain are the same.  and if you think of a functor as a type of 'function', then an endofunctor is a functor whose input category and output category are the same
16:12:13 <atondwal> iqubic: and endofuctor is an endomorphism in the category Cat of categories
16:12:24 <nshepperd1> Not to be confused with "monoidal category" or "a single object category, which forms a monoid" which are separate notions
16:12:29 <atondwal> s/and/an
16:12:31 <iqubic> huh?!?!
16:12:43 <jle`> iqubic: any single-object category is necessarily a monoid
16:12:45 <jle`> do you see why?
16:13:23 <iqubic> Because in a single-object catagory all you can make are endomorphism, because you don't have any other objects to work with.
16:13:38 <iqubic> So, what is a catagory?
16:13:46 <jle`> ah, 'what is a category', that's probably an important question
16:13:59 <iqubic> something something composition. something something identity.
16:14:26 <Solonarv> iqubic: at this point I'd suggest finding a better resource than the discordant ramblings of an entire IRC channel ;)
16:14:35 <iqubic> I want this though.
16:14:46 <Solonarv> You want what? to learn category theory?
16:15:17 <iqubic> I want to learn the basics of Category theory.
16:16:00 <Solonarv> I recommend Bartosz Milewski's book/series-of-posts
16:16:02 <iqubic> Just enough to understand this: "A monad is just a monoid in the category of endofunctors."
16:16:33 <shachaf> Tht's a bad reason. It's not a particularly important sentence.
16:16:46 <iqubic> I want to understand it.
16:16:48 <shachaf> Anyway if you want to learn basic category theory, read this book: https://www.maths.ed.ac.uk/~tl/bct/
16:17:14 <shachaf> It is better than the discordant ramblings of an entire IRC channel.
16:17:31 <jle`> it's a misleading sentence, too, because the usage of "a" implies that monoids in the category of endofunctors are monads; it should really be that monads are one specific type of monoid in the category of endofunctors, among many
16:17:43 <iqubic> I have this book called "Category Theory for Programers"
16:17:49 <iqubic> I'm going to read that.
16:18:06 <jle`> that book goes over monads in a way that will make the monoidal nature clear, i believe.
16:18:22 <Solonarv> hey, that's the one I was referring to ;)
16:18:48 <shachaf> It's "the" category of endofunctors that's ambiguous here.
16:19:13 <jle`> shachaf: ah, right. i retract what i said
16:19:22 <shachaf> In particular it's the monoidal structure.
16:19:34 <Solonarv> Ah, I was about to pick that nit.
16:20:09 <iqubic> It's written by "Bartosz Milewski"
16:20:44 <Solonarv> Yup yup. That's where I learned the little bit of CT I know.
16:21:39 <iqubic> I've read it once before, but it was so abstract I forgot most of the concepts.
16:21:49 <nshepperd1> https://blog.merovius.de/2018/01/08/monads-are-just-monoids.html is a long form post specifically about that line
16:22:26 <jle`> i still don't think that it's a particularly productive goal; optimizing for understanding that line might give you a bit of a skewed perspective of category theory in general
16:23:06 <hpc> and tells you nothing about haskell even if you get the CT stuff
16:23:09 <iqubic> So "(f . g) . h == f . (h . g)" Why?!?!
16:23:26 <nshepperd1> Curiosity is a good reason to learn things though
16:23:41 <jle`> iqubic: are you asking about . in Haskell?
16:23:51 <jle`> if so, you can prove their equivalence by expanding their definitions
16:23:57 <jle`> (f . g) x = f (g x)
16:23:59 <iqubic> well, that's a rule of function composition in general isn't it?
16:24:17 <jle`> so we can expand the definition of (f . g) . h
16:24:27 <jle`> (f . g) . h = \x -> (f . g) (h x)
16:24:42 <iqubic> I see.
16:24:49 <jle`>  = \x -> f (g (h x))
16:24:49 <c_wraith> iqubic, just expand and simplify the expressions based on the definition of (.). you'll end up at the same expression.
16:24:53 <iqubic> What about with the brackets in the other place.
16:24:57 <jle`> and now the other situation:
16:25:07 <jle`> f . (g . h) = \x -> f ((g . h) x)
16:25:11 <jle`>  = \x -> f (g (h x)
16:25:13 <jle`> )
16:25:16 <iqubic> I see.
16:25:21 <iqubic> Makes sense.
16:25:25 <jle`> so we can see that both (f . g) . h and f . (g . h) expand to the same thing
16:25:40 <jle`> so they are equivalent
16:26:20 <jle`> not sure if that scratches the 'why' itch you are looking for
16:26:28 <iqubic> It does.
16:26:33 <iqubic> It really really does.
16:31:08 <iqubic> Can someone real quick give me an example of two different categories that exist?
16:31:25 <iqubic> I don't see why we need more than one category ever.
16:31:35 <shachaf> This is not really the channel for that.
16:31:41 <iqubic> Oh. Darn.
16:32:00 <c_wraith> go to the docs for Control.Category and look at the instance list.
16:32:06 <shachaf> Have you started reading the book you have?
16:32:19 <iqubic> I have indeed.
16:32:26 <iqubic> I now know what a category is.
16:32:42 <iqubic> It's a set of objects and the morphisms between those objects.
16:33:08 <iqubic> So the Real numbers form a category.
16:34:14 <larryba> would you agree that, generally, it is better to throw exception from IO function than to return Either SomeError Value?
16:34:34 <larryba> ie, IO (Either SomeError Value)
16:35:13 <c_wraith> iqubic, the real numbers are not a category. they could be the objects in a category, but you need morphisms too.
16:35:45 <iqubic> c_wraith: What is a category then?
16:36:00 <iqubic> Like what is an example of one?
16:36:14 <shachaf> Does your book not give any examples?
16:36:22 <shachaf> If so, get another book.
16:36:38 --- mode: glguy set +v zachk
16:36:43 --- mode: orwell.freenode.net set +v zachk
16:36:43 --- mode: glguy set -v zachk
16:36:50 <zachk> I would say the real numbers can be used to form a field 
16:37:01 <zachk> and a field could be one object in a category 
16:37:32 <iqubic> My book gives examples. I just don't like those examples
16:38:22 <c_wraith> what makes you think you'd like any other example more?
16:42:50 <iqubic> I love the concept that there can be a category with 0 objects and 0 morphisms.
16:44:18 <zachk> just like there can be a set with no elements
16:44:43 <iqubic> I know.
16:50:23 <jle`> iqubic: try ##math :)
16:51:00 <Solonarv> zachk: You can define "field" as "a category which satisfies these properties: ...", just as you can define it in terms of sets
16:53:24 <mniip> fields aren't a first order theory
16:53:32 <mniip> and thus don't make a nice category at all
16:54:02 <zachk> wouldn't a field be a single object in a category and all its operations be morphisms from that object to itself, like a group would be?
16:54:13 <Solonarv> Hm, perhaps I should've said "handful of category-theoretic things"
16:54:22 <mniip> zachk, like a "group object in a category"?
16:54:33 <mniip> (you have to specify)
16:54:40 <mniip> if yes then no
16:54:49 <mniip> /because/ fields aren't a first order theory
16:55:11 <zachk> yes, what do you mean a first order theory? 
16:55:40 <unyu> Is there some way to make Haskell's type checker understand actually interesting categories? (i.e. not Set plus plus minus minus.) Say, vector bundles over a given manifold. A type error would be like “you cannot define a nonvanishing vector field on a sphere”.
16:57:02 <mniip> zachk, a theory expressed in terms of a fixed number of operators of fixed arity, and a fixed number of predicates of fixed arity
16:57:18 <mniip> e.g in group theory you have the binary operation *, the nullary operation e, and the binary predicate =
16:57:33 <mniip> and the unary operation ^-1
16:57:53 <mniip> in fields, the multiplicative inverse doesn't fit this pattern
16:58:12 <aplainzetakind> mniip: how?
16:59:18 <shachaf> unyu: I'm pretty sure the answer is no.
16:59:39 <mniip> unyu, you need dependent types
17:00:07 <mniip> aplainzetakind, with this definition of a group, your axioms are forall-quantified equations
17:00:31 <monochrom> The hairy ball theorem sounds like something that needs a full-blown logic or full-blown dependent typing.
17:00:33 <mniip> in field axioms, disequality with 0 will be littered all over the place
17:00:52 * hackage closed 0.2.0.1 - Integers bounded by a closed interval  http://hackage.haskell.org/package/closed-0.2.0.1 (cdparks)
17:01:23 <aplainzetakind> how does that pertain to first order-ness of a theory? ZF is first order.
17:04:17 <monochrom> "if x/=0 then there exists y such that xy=1" is a first-order sentence, no?
17:04:58 <monochrom> It disqualifies being an algebraic theory (an algebraic theory wants "for all vars. plain and simple equation here") sure but it stays 1st order.
17:05:29 <monochrom> Now, Peano would be something I consider 2nd-order unless you cheat with "I allow infinitely many axioms"
17:05:56 <unyu> Are axiom schemas considered cheating?
17:06:02 <monochrom> YES!
17:06:11 <monochrom> My opinion anyway. You don't have to agree.
17:07:41 <monochrom> And more meta-ly, even if the class of all fields don't form a nice category, so what?  We are OK with things working out not nice.  We still have a category.
17:08:15 <monochrom> If you have a godawful category it's still infinitely more beautiful than human society red tape.
17:12:13 <mniip> monochrom, hm, yeah maybe that was it
17:18:28 <monochrom> The theory of real numbers would also be 2nd order because it adds a completeness axiom that says "for all sequences ..." or "for all subsets ..." or God forbid there is a "nested intervals" version that goes "for all sequences of subsets ..."
17:18:56 <monochrom> (And again you could do axiom schema instead, I suppose.)
17:19:29 <monochrom> But then I don't think many people are interested in the category of all models of the theory of real numbers. >:)
17:20:22 <int-e> monochrom: but we'd get a countable model of the reals out of this exercise -- what's not to like?
17:20:32 <mniip> well I think dedekind reals are a subset of cauchy reals?
17:20:40 <unyu> mniip: The other way around.
17:20:44 <monochrom> Oh I think they just downplay "we have a category".
17:20:45 * hodapp read that as "crunchy reals" at first.
17:21:00 <mniip> unyu, weird
17:21:08 <int-e> mniip: in what sense?
17:21:13 <mrm> I doubt the difference between 1st and 2nd order axioms would matter that much for the type-checker. Either you have a built in general theorem prover, or you're stuck with decidable subsets.
17:21:28 <int-e> mniip: they're different constructions; sequences are not sets...
17:21:32 <mniip> at a first glance Q^N sounds bigger than 2^Q
17:21:52 <monochrom> Oh HM type systems are full of higher-order functions/predicates anyway!
17:22:06 <monochrom> But we were not talking about type checking.
17:23:30 <monochrom> But yes once upon a time I learned the HOL theorem prover and immediately I liked it very much and I decided that my metalogic would be it.  I am not afraid of nth order predicates.
17:23:44 <mrm> Oh, I misunderstood. I thought this was still about the "what would it take to get the type checker to understand interesting categories" question.
17:24:09 <larryba> *** Exception: ... <- I find myself catching those exceptions only to print the error and then quit, because *** Exception: .. makes it seem like a bug to end-user rather than an error message. is there a better way to handle this? 
17:24:29 <monochrom> And its "choice" operator was really temptingly sweet too so I decided that I am not afraid of axioms of choice either. Hell compared to that "choice" operator, the axiom of choice is childplay!
17:25:02 <monochrom> (IIRC this "choice" operator is equivalent to Hilbert's choice axiom.)
17:25:31 <nshepperd1> . o O (The axiom of free will)
17:25:37 <monochrom> :)
17:29:03 <mrm> I feel like there's some alternate universe where a popular language VM emerged in say the 80s that required proofs of safety for programs before running, in some fixed format, while leaving coming up with said proofs to the user. And in this alternate universe, major industrial users have poured millions into theorem proving stuff just to eke out a little more performance on say phones using this VM.
17:30:20 <Solonarv> larryba: I think there's a way to install a different top-level exception handler
17:30:24 <mrm> Type systems are probably a lot cooler in that universe.
17:30:40 <Solonarv> It might be in Control.Exception
17:31:09 <monochrom> And Perhaps VM stands for Vulcan Maximus :)
17:31:55 <int-e> Very Monochrom pun.
17:32:26 <monochrom> hehe
17:32:53 <mrm> Every time a vulcan calls something logical I start getting really creeped out by how many weird axioms their logic must have.
17:34:06 <mrm> "wtf, I just wanted to do some real analysis, why do I need axioms about optimal starfleet protocols?"
17:34:52 <larryba> Solonarv I"m looking for it, but I can't find it. funny thing is that I believe someone mentioned that in this channel the other day, but I can't find it in logs either
17:34:53 <boj> "live long and prosper" was actually a reference to runtimes
17:35:28 <mrm> Hm. They probably don't like generational garbage collectors then.
17:38:27 <monochrom> As usual, Hollywood has distorted visions about what computers, computing hacking, and Vulcan logic look like. >:)
17:39:53 * hackage esqueleto 2.6.0 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-2.6.0 (parsonsmatt)
17:39:53 <monochrom> I mean even in Ex Machina. The guy modified the security software by... writing a trial-division loop that tests for primality?!
17:40:53 <monochrom> And that is basically the least gibberish program shown in all Hollywood movies. Isn't it sad?
17:41:09 <monochrom> (And oh it's in Python too.)
17:41:31 <monochrom> (And that's basically the least fictional computer language in all Hollywood movies, too.)
17:41:54 <monochrom> (Well at least it is not PHP.)
17:42:43 <jle`> actually i've noticed that nmap is used (correctly) in a lot of hollywood movies
17:43:14 <c_wraith> the matrix famously used nmap properly.
17:43:31 <c_wraith> just... sped up by like 50x
17:43:35 <jle`> but for the most part it's gibberish, yes, heh
17:43:42 <jle`> (programming in hollywood, that is)
17:44:08 <jle`> i'm a sucker for the GUI filesystem in jurassic park though
17:44:30 <MarcelineVQ> that exists
17:44:38 <c_wraith> it's part of IRIX
17:45:11 <monochrom> Ah yes the recent Bond movies showed UIs that are within reach and I would like to have too.
17:45:26 <larryba> "Nuh-uh, you didn't say the magic word"
17:45:29 <monochrom> And The Island too.
17:45:44 <c_wraith> I'm still annoyed the movie made it the boy who knew computers. the book made it the girl!
17:46:05 <MarcelineVQ> the girl was the computer nerd in the movie c_wraith
17:46:27 <jle`> https://www.youtube.com/watch?v=dxIPcbmo1_U
17:46:42 <c_wraith> wait, I got it backwards? memory is evil.
17:46:46 <jle`> oh what, we're on #Haskell, i totally thought this was an off-topic channel
17:47:01 <monochrom> Sorry! My fault.
17:47:11 <jle`> not your fault, i took it and ran with it :)
17:47:34 <larryba> c_wraith, does that still make you annoyed? :P
17:47:51 <c_wraith> larryba, yes, but at myself. not the movie.
17:48:34 <nyc> Programming is probably unable to be portrayed in cinema.
17:49:43 <monochrom> I have a few more bits to tell in #haskell-offtopic.
18:06:05 <mrm> Mr Robot manages reasonably well, though obviously cinema and serial narratives differ a bit.
18:31:23 * hackage extensible-effects 5.0.0.1 - An Alternative to Monad Transformers  http://hackage.haskell.org/package/extensible-effects-5.0.0.1 (shergill)
18:51:22 * hackage hw-ip 2.0.1.0 - Library for manipulating IP addresses and CIDR blocks  http://hackage.haskell.org/package/hw-ip-2.0.1.0 (haskellworks)
19:00:58 <argent0> hi, is this isomorphic to something more popular? data Rec a = Rec (Rec a) | Done a deriving Show
19:02:09 <Solonarv> It's isomorphic to Free Identity
19:02:29 <argent0> Solonarv: thanks I'll check that out
19:02:54 <Solonarv> argent0: Free is in free:Control.Monad.Free, Identity is in base:Data.Functor.Identity
19:04:13 <c_wraith> it's also Fix Maybe
19:04:27 <c_wraith> err, no. it's Fix (Either a)
19:05:09 <c_wraith> or if you want to be particularly smart-ass about it, (Nat, a)
19:05:48 <Solonarv> more generally, Free f a ~ Fix (Either a `Compose` f)
19:06:12 <c_wraith> hmm. good point.
19:06:46 <Solonarv> ( similarly, Cofree f a ~ Fix ((,) a `Compose` f) )
19:07:26 <c_wraith> do backticks work in types? I can't say as I've ever tried.
19:08:03 <Solonarv> They do, you might need -XTypeOperators though – I don't remember
19:08:38 <Solonarv> % :k Int `Either` Char
19:08:38 <yahb> Solonarv: Int `Either` Char :: *
19:09:23 <puffnfresh> Free Identity is also known as the "Partiality Monad"
19:09:38 <puffnfresh> argent0: you're recreating Partiality exactly :)
19:10:17 <Solonarv> which one is that?
19:10:30 <argent0> c_wraith: puffnfresh: I'll check those too
19:10:46 <c_wraith> I have a result! | I need to think more.
19:11:33 <c_wraith> it's a very direct way to encode partiality into a total language that supports codata
19:11:41 <Solonarv> Oh, I see!
19:13:18 <c_wraith> sometimes you even want it in Haskell. it's a pure way to produce progress reports from a computation, for instance.
19:14:28 <c_wraith> so long as you don't mind the computation only running when you ask for the next progress report.
19:14:49 <Solonarv> Seems like it'd be quite useful as a monad transformer
19:15:17 <c_wraith> (deepseq it with par to get it to run in the background!)
19:17:13 <c_wraith> huh. I'd never thought of using par to simulate concurrency before. now I'm curious.
19:17:41 <NemesisD> hi all. i have a kernel of idea but i'm lacking the terms to express it. i want to pass around an explicit dictionary of operations, e.g. data Terminal m = Terminal { putStrLn :: String -> m ()}, i want to combine dictionaries on the fly but i need a typesafe way to extract an element of the dictionary. i started looking into open unions but those are disjoint(?), it could be any one of the cases, but i need *all* of the
19:17:41 <NemesisD> cases
19:18:52 <NemesisD> so if i've got some complex monadic block, its type might be foo :: (HasMember Terminal rows, HasMember AWS rows) => Dict rows m -> m ()
19:20:04 <Solonarv> what's 'Dict' supposed to be?
19:21:05 <Solonarv> or is that the question you were asking?
19:21:39 <NemesisD> Solonarv: i'm thinking like a Product type that i can add homogenous types to? so if I've got a Terminal m and an AWS m, i should be able to create a Dict '[Terminal, AWS] m
19:22:05 <Solonarv> NemesisD: vinyl can do that
19:22:58 <c_wraith> isn't vinyl label+type for lookup? that appears to be only type for lookup.
19:23:20 <Solonarv> c_wraith: vinyl is very general, it doesn't force you into having labels
19:23:30 <c_wraith> huh, cool.
19:23:40 <NemesisD> Solonarv: do you happen to know off hand what slice of the API i should be looking into?
19:23:43 <Solonarv> the core data type is 'data Rec (xs :: [k]) (f :: k -> Type)'
19:24:46 <c_wraith> there's also http://hackage.haskell.org/package/type-map
19:25:17 <Solonarv> 'Rec [Foo, Bar, Baz] f' is isomorphic to 'HList [f Foo, f Bar, f Baz]'
19:26:12 <NemesisD> these look like they may get me where i want to go, nice!
19:26:16 <Solonarv> NemesisD: honestly, I'd recommend refactoring to 'foo :: (MonadTerminal m, MonadAWS m) => m ()'
19:26:53 <Solonarv> You can still use vinyl to provide *instances* of MonadTerminal, MonadAWS &c
19:27:37 <NemesisD> Solonarv: my problem is that i'm not super comfortable doing this with constraints. i would like to be able to take a dictionary, maybe swap out a few APIs in tests. everything is so final and universally quantified with constraints
19:28:05 <Solonarv> Not so. Your implementation can be as swappable as you want.
19:28:58 <Solonarv> A slight variation is: 'foo :: (MonadReader e m, Has (Terminal m) e, Has (AWS m) e) => m ()'
19:29:40 <NemesisD> oh sure, that one is fine, to avoid explicit passing of the dictionary i guess
19:30:39 <NemesisD> i think type-maps won't work. looks like its partial, it can't be certain that a type is present in the map or not. i'll look at Rec
19:32:33 <NemesisD> @Solonarv where are you getting Has from?
19:32:33 <lambdabot> Unknown command, try @list
19:32:54 <Solonarv> I'm not sure if it's pre-defined anywhere
19:34:17 <iqubic> Is there a way to pass a directory to cabal repl, so the command can be run from anywhere, but still pull up a certain project's repl?
19:34:53 * hackage vinyl 0.11.0 - Extensible Records  http://hackage.haskell.org/package/vinyl-0.11.0 (AnthonyCowley)
19:36:58 <sclv> iqubic: what about just doing this? https://stackoverflow.com/questions/786376/how-do-i-run-a-program-with-a-different-working-directory-from-current-from-lin
19:39:19 <iqubic> Does that work in a shell script?
19:39:39 <iqubic> I'd assume it does.
19:39:54 <iqubic> I'm going to use that next, if/when my current approach fails.
19:48:19 <iqubic> Alright, let's talk about haskell. I have "Map String a" I want to be able to do case insensitive lookups on those keys. What's the best way to do thaat?
19:48:45 <monochrom> Wasn't that long resolved a few days ago?
19:49:22 <monochrom> I mean apart from the unhealthy pursuit of undefined elusive "perfection".
19:49:24 <jackdk> iqubic: get a Map (CI String) a ? https://hackage.haskell.org/package/case-insensitive-1.2.0.11/docs/Data-CaseInsensitive.html
19:49:57 <jackdk> :t Data.Map.mapKeys
19:49:58 <lambdabot> Ord k2 => (k1 -> k2) -> M.Map k1 a -> M.Map k2 a
19:50:08 <nyc> iqubic: Map to lowercase before lookups?
19:50:27 <Solonarv> (and also before inserts)
19:50:32 <jackdk> nyc: that's not necessarily reliable for certain languages
19:50:46 <Solonarv> indeed, you should use Text instead of String for that reason
19:51:00 <Solonarv> (which is also what I said when you asked the same question a few days ago)
19:51:21 <jackdk> I think the German sharp S and Turkish dotted capital I don't work properly with case-converting approaches
19:51:45 <c_wraith> even Text doesn't do the job for I
19:51:55 <jackdk> so imho do a `mapKeys CI`, so you have proper case-insensitive keys
19:52:15 <jackdk> I don't actually know Turkish, I just heard about it
19:52:15 <iqubic> So I want to use Text.
19:52:22 <NemesisD> @Solonarv woof, this is pretty hairy. i wonder if i can get away without having to do the whole type families and singletons stuff. i don't think i actually need the f, so i guess I'd use Identity? i think i'd wind up with type MyDict m = Rec Identity '[Terminal m, AWS m]
19:52:22 <lambdabot> Unknown command, try @list
19:52:24 <iqubic> Can someone help me with that?
19:52:38 <iqubic> Or should I use CI String instead of Text?
19:52:44 <NemesisD> maybe i actually just want HList
19:53:17 <monochrom> Is CI Text possible?
19:53:22 <c_wraith> jackdk: converting 'I' to lowercase correctly is locale-dependent.  In a Turkish locale it goes to their dotless character, everywhere else it goes to the more familiar to english-speakers 'i' character.
19:53:24 <Solonarv> NemesisD: you can define 'newtype Cap (m :: Type -> Type) c = Cap (c m)' and then use 'Rec Cap [Terminal, AWS]'
19:53:41 <Solonarv> er, Rec (Cap m) [Terminal, AWS]
19:53:50 <iqubic> monochrom: looks like it should be.
19:53:58 <jackdk> monochrom yes: https://hackage.haskell.org/package/case-insensitive-1.2.0.11/docs/Data-CaseInsensitive.html
19:54:12 <nyc> jackdk: İ may be tricky. ẞ seems to have a capital and lowercase form.
19:54:13 <monochrom> Neato.
19:54:23 <c_wraith> or you can use https://hackage.haskell.org/package/text-1.2.3.1/docs/Data-Text.html#v:toCaseFold in text
19:54:46 <iqubic> How does that work?
19:54:48 <c_wraith> Which doesn't convert to uppercase or lowercase.  It converts individual characters in whichever direction is unambiguous
19:55:03 <iqubic> I'm not sure I understand.
19:55:22 <monochrom> If you know how Text works and how CI works then just combine the two bodies of knowledge.
19:55:37 <iqubic> Except I don't know how Text works.
19:55:43 <iqubic> Or CI.
19:55:50 <Solonarv> NemesisD: then your type becomes: foo :: (RElem Terminal cs, RElem AWS cs) => Rec (Cap m) cs -> m ()
19:55:55 <monochrom> There are docs. In this case the docs are useful.
19:56:13 <monochrom> I know some other docs are useless but these two are OK.
19:56:13 <iqubic> monochrom: should I use CI Text?
19:56:22 <monochrom> I don't know.
19:56:34 <iqubic> And what the heck is an overloaded string, and do I want that?
19:56:35 <monochrom> I'm too lazy to read the doc and perform tests.
19:57:10 <monochrom> I can write the code for you upon payment but I can't learn it for you.
19:57:18 <Solonarv> iqubic: OverloadedStrings lets "blah blah" stand for a String, or a Text, or a variety of other types
19:57:25 <NemesisD> Solonarv: ah shoot, my coffee shop is closing, i'll chew on that type signature for a bit. thank you!
19:57:26 <monochrom> Hell I can't even go to the washroom for you.
19:57:34 <iqubic> monochrom: I don't need high performance, I just need something that lets me do case insensitive lookup in my "Map String a"
19:57:35 <Solonarv> much like 5 can be an Int, or a Double, or a Natural, or...
19:57:41 <iqubic> I see.
19:58:22 <iqubic> So I want something of the type "(IsString a) => Map a b" that lets me do some case insensitive lookups.
19:58:30 <Solonarv> No, that's not what you want.
19:58:48 <iqubic> Oh... What do I want?
19:58:53 <monochrom> Anyway I prefer to whine about how the "great art" of composing several bodies of knowledge to synthesize solutions for composite problems is long lost because the Internet is very spoiling and people are getting lazy.
19:58:56 <Solonarv> 'Map Text b', probably
19:59:50 <iqubic> And then I should run toCaseFold on the keys both before insertion and before lookup?
20:00:49 <Solonarv> hmm, actually 'Map (CI Text) b' should be a bit better
20:01:03 <iqubic> Should I use that>
20:01:04 <monochrom> Back when there was no web, if you were confronted with "write a program to solve equations numerically but it has to be written in SML and it has to use Newton's method and it has to parse the equation from the user's input string", ...
20:01:18 <monochrom> you would break it into 3 parts.
20:01:33 <iqubic> That's more or less exactly what I'm doing now monochrom.
20:01:39 <Solonarv> iqubic: now that I've actually looked at case-insensitive, yes, you that's what you should use
20:01:56 <monochrom> You would learn Newton's method, but most certainly it would not be taught in SML, it would be in C or pseudocode or just English.
20:02:08 <iqubic> It'll be another import, but I can make it work.
20:02:17 <Solonarv> Imports are not something to be scared of
20:02:31 <monochrom> And you would learn a parsing technique or two, but it would not be in SML, it would be in Pascall or pseudocode or just English.
20:02:38 <monochrom> And you would learn SML itself.
20:02:38 <nyc> monochrom: WWW = World Wide Waste (of bandwidth)
20:03:07 <iqubic> Alright then. Time to use "Map (CI Text) b"
20:03:10 <monochrom> And finally you just had to combine those 3 parts and voila presto.
20:03:29 <monochrom> But these days people are dead set to refuse to do that.
20:04:19 <Solonarv> monochrom: to be fair iqubic is in fact asking about a fairly specific subproblem here
20:04:24 <monochrom> They expect to enter the whole of "Newton's method in SML and my own parsing of equations" into Google or IRC and they expect the well-developed exact-match solution served on a silver platter.
20:05:43 <nyc> MoSML or SML/NJ?
20:06:13 <monochrom> I think SML/NJ because this hypothetical tale would be set in older times.
20:06:38 <iqubic> Yes. I tried to pare down my question to just the bare minimum.
20:06:59 <monochrom> But Data.Text doc is pretty readable.
20:07:16 <monochrom> We are not talking about rocket science or PHP.
20:07:56 <nyc> monochrom: Please, there may be children present.
20:08:07 <monochrom> CI doc is minimal but it is only because "what's there to say anyway?" not because the author didn't want to write.
20:09:54 <monochrom> If CI doc doesn't suffice for you then it means you are shaky in your understanding of type classes and instances and newtype.
20:15:07 <iqubic> OverloadedStrings is doing some weird stuff here.
20:15:40 <iqubic> http://dpaste.com/0DH5SYP
20:16:30 <iqubic> That hole has type M.Map [Char] Double.
20:16:37 <iqubic> And I have no idea why that is.
20:17:51 <iqubic> And if I put `env` in there as I want to do then I get the error: Can't match type CI.CI T.Text with [Char]
20:18:00 <iqubic> What the heck is this nonsense?!?!
20:18:32 <monochrom> In "VarF x", what is the type of x?
20:18:41 <iqubic> String
20:18:48 <jackdk> I predict it's `String` (= `[Char]`)
20:18:56 <iqubic> It is String.
20:19:02 <monochrom> And you don't have to do any conversion to CI Text?
20:19:03 <jackdk> @info String
20:19:03 <lambdabot> String
20:19:08 <jackdk> :info String
20:19:18 <iqubic> monochrom: No I don't
20:19:26 <jackdk> iqubic String is an alias for [Char]
20:19:44 <monochrom> If you were right, why would the compiler reject the code?
20:19:51 <jackdk> iqubic: try `M.lookup (CI (T.pack x))`
20:19:54 <Solonarv> OverloadedStrings only affects string *literals*.
20:19:59 <jackdk> ^^^
20:20:22 <iqubic> Solonarv: I see.
20:20:40 <monochrom> https://www.vex.net/~trebla/humour/tautologies.html #4
20:21:39 <iqubic> jackdk: Except that I need to use CI.mk instead.
20:21:47 <iqubic> But yeah, that works.
20:21:55 <jackdk> cool
20:23:04 <iqubic> monochrom: that link gives me an Apache Server Not Found Error.
20:23:18 <monochrom> I gather the impression that CI was a simple newtype wrapper a long time ago so it was simply "CI "hello"" back then.
20:24:06 <iqubic> I assume so. But now the library has evolved and the constructor CI is no longer exported.
20:24:08 <monochrom> But now it is a two-field record, one field is content, the other field is the case-folding function.
20:24:37 <monochrom> And "mk" takes in a FoldCase constraint and packs that method into the record.
20:24:52 <iqubic> And for some reason it keeps the original String too.
20:25:01 <monochrom> A little bit unsettling if you ask me, but perhaps there is backward compatibility to worry about.
20:25:06 <iqubic> Original :: CI s -> s
20:25:19 <larryba> why does Control.Exceptions.Safe have three functions that do exactly the same thing, throw, throwIO and throwM? and which one is preferable, stylistically?
20:25:25 <iqubic> monochrom: Why is it unsettling for it to keep the original fata?
20:25:39 <iqubic> *data
20:26:27 <monochrom> If starting afresh, I would make CI a simple newtype but the Ord instance would be "(Ord s, FoldCase s) => Ord (CI s)"
20:26:37 <iqubic> also, I really want to know what that vex.org link is about, but it errors out on me.
20:26:47 <monochrom> It may actually be a bit more efficient.
20:26:48 <iqubic> *vex.net
20:28:19 <monochrom> I can't help you because I can't reproduce the error.
20:28:26 <monochrom> I even reloaded two times.
20:28:50 <monochrom> the ctrl-r kind
20:28:59 <iqubic> And it works for you?
20:29:03 <monochrom> Yes.
20:29:12 <iqubic> That website is not broken for you?
20:29:18 <monochrom> Generally I test an URL for one last time before I bother to post it.
20:29:22 <amalloy> it didn't work for me either; try replacing the https with http
20:29:32 <amalloy> (that made it work)
20:29:46 <iqubic> https://imgur.com/a/wZPtADl
20:29:49 <monochrom> Well the weird thing is https works for me too.
20:30:16 <iqubic> http is the only thing that works for me.
20:30:46 <amalloy> interestingly, after visiting the http version, the original https link now works. that shouldn't happen. maybe a coincidence
20:30:53 <monochrom> We can all share with us all the screenshots of working and no-workie but it's all for nothing because how do you use these screenshots to fix it?
20:30:57 <amalloy> yeah it just intermittently breaks
20:32:31 <iqubic> amalloy: even after visiting the http version, I still can't get the https version to work.
20:33:24 <iqubic> I can see the content on the http version, and I can tell that #4 describes my issues.
20:36:50 <Solonarv> NemesisD: here's a sketch of a "capability" system - https://gist.github.com/Solonarv/328ad45c0674215938d08026a16efe07
20:37:00 <Solonarv> rest of the chat: does this perhaps exist in a library somewhere?
20:41:25 <nyc> Solonarv: I'm foggy as to what it's supposed to do.
20:42:17 <larryba> what are your thoughts on a function returning IO (Either String|Exception Data) vs just throwing an exception?
20:42:32 <larryba> and returning IO Data
20:43:04 <Solonarv> I'd prefer the Either variant
20:43:57 <larryba> I thought I did too, but then I find myself having to handle two different type of errors. Left, and IO exceptions
20:44:02 <nyc> I think Either String is a MonadError instance.
20:44:29 <Solonarv> nyc: intended usage is writing functions with a signature like '(Terminal <!= cs, Graphics <!= cs, MonadCapability cs) => Foo -> Bar -> m Whatever'
20:44:47 <benzrf> isnt that basically mtl
20:44:54 <Solonarv> larryba: that's fine, it lets you divide exceptions into those the caller must handle and those the caller can ignore
20:45:01 <Solonarv> benzrf: it's certainly related
20:45:20 <iqubic> :t log
20:45:21 <lambdabot> Floating a => a -> a
20:45:30 <iqubic> Is that log base e?
20:45:38 <Solonarv> > log 3 -- presumably yes
20:45:40 <lambdabot>  1.0986122886681098
20:45:45 <Solonarv> Yup.
20:45:55 <iqubic> And is there a way to get the value of e as a number you can work with?
20:46:06 <iqubic> I know this exists:
20:46:10 <iqubic> > PI
20:46:12 <lambdabot>  error: Data constructor not in scope: PI
20:46:14 <Solonarv> @src Floating
20:46:14 <lambdabot> class (Fractional a) => Floating a where
20:46:14 <lambdabot>     pi                  :: a
20:46:15 <lambdabot>     exp, log, sqrt      :: a -> a
20:46:15 <lambdabot>     sin, cos, tan       :: a -> a
20:46:15 <lambdabot>     asin, acos, atan    :: a -> a
20:46:16 <lambdabot> [3 @more lines]
20:46:18 <iqubic> > pi
20:46:20 <lambdabot>  3.141592653589793
20:46:21 <Solonarv> @more
20:46:21 <lambdabot> Plugin `more' failed with: Prelude.init: empty list
20:46:35 <iqubic> @src Floating
20:46:35 <lambdabot> class (Fractional a) => Floating a where
20:46:35 <lambdabot>     pi                  :: a
20:46:35 <lambdabot>     exp, log, sqrt      :: a -> a
20:46:35 <lambdabot>     sin, cos, tan       :: a -> a
20:46:35 <lambdabot>     asin, acos, atan    :: a -> a
20:46:37 <lambdabot> [3 @more lines]
20:46:38 <kadoban> iqubic: exp 1 ?
20:46:40 <iqubic> @more
20:46:40 <lambdabot> Plugin `more' failed with: Prelude.init: empty list
20:46:44 <Solonarv> > exp 1 -- cheeky answer
20:46:46 <lambdabot>  2.718281828459045
20:46:54 <iqubic> What does exp do?
20:46:59 <kadoban> It's e^x
20:47:05 <iqubic> I see.
20:47:06 <MarcelineVQ> did you repeat that expecting a different result
20:47:28 <nyc> Solonarv: UI code is a headache even for pty's.
20:47:48 <Solonarv> nyc: huh?
20:47:57 <iqubic> MarcelineVQ: Yes. I thought lambdabot was getting tripped up by processing another command in between @src and @more
20:48:13 <iqubic> > log $ exp 1
20:48:15 <lambdabot>  1.0
20:48:18 <nyc> iqubic: sum of x^n/n! probably
20:48:49 <iqubic> nyc: Why would I care about that?
20:49:13 <nyc> Solonarv: The capability example code seemed tty/pty-related.
20:49:42 <Solonarv> I mean, the example I chose is, but the abstraction isn't
20:50:27 <nyc> There are probably better approximations on [0,1] than the MacLauren series.
20:51:35 <iqubic> question: does the order of evaluation of f <$> g <$> x change the end result?
20:51:53 <nyc> iqubic: It's an answer to what exp does.
20:52:34 <iqubic> I.E. do (f <$> g) <$> x and f <$> (g <$> x) produce the same results given the same input?
20:52:48 <nyc> Solonarv: I may not grasp the abstraction.
20:52:56 <Solonarv> I was about to say they don't have the same type, but amusingly enough they do
20:53:31 <iqubic> I just checked that they have the same type.
20:53:48 <larryba> iqubic, fmap for functions is .
20:53:54 <larryba> so same thing applies
20:54:14 <iqubic> In my case f :: Double -> Double, g :: Double -> Double, x :: Double
20:54:18 <Solonarv> iqubic: note that the <$> on the left has a different type in both expressions!
20:54:31 <iqubic> I know.
20:54:56 <Solonarv> But yes, f . g <$> x = f <$> (f <$> x) holds for any lawful Functor instance
20:55:11 <Solonarv> (the only law needed is 'fmap id = id')
20:55:13 <iqubic> What I want to do is (recip . cos) <$> x which looks like a much better way of writting this code.
20:56:06 <iqubic> I'm annoyed that Haskell doesn't just have ways of doing csc, but such is life.
20:56:11 <iqubic> :t csc
20:56:12 <lambdabot> error:
20:56:12 <lambdabot>     • Variable not in scope: csc
20:56:12 <lambdabot>     • Perhaps you meant ‘scc’ (imported from Data.Graph)
20:56:16 <nyc> iqubic: Remes approximants to e^x on [0,1] or [1/2,1] seem plausible, with reductions to the fundamental interval used.
20:56:16 <Solonarv> As I said: yes, they produce the same result
20:56:38 <Solonarv> Nothing stops you from defining 'csc = recip . cos' somewhere
20:56:56 <nyc> recip . sin
20:57:24 <Solonarv> Bah, I don't remember the entire zoo of trig functions offhand
20:58:25 <MarcelineVQ> just remember 1/3 of them and add a or co to them to get the rest
20:58:44 <nyc> sn, cn, dn, ns, nc, nd, cs, ds, sc, dc, sd, cd are more awkward due to namespace issues.
20:59:02 <Solonarv> That's probably why Floating doesn't include the entire zoo.
20:59:30 <Solonarv> (and also why it includes pi but not e)
21:00:48 <nyc> sec, csc, cot don't seem quite as likely of problems as the Glaisher notations for the Jacobian elliptic functions.
21:05:30 <Solonarv> The idea is that a 'CapabilityT cs m' carries around a bunch of dictionaries-of-functions (the members of 'cs')
21:05:51 <Solonarv> It's another spin on the '(MonadReader e m, Has e Foo, Has e Bar)' pattern
21:06:09 <iqubic> > tan $ pi / 2
21:06:11 <lambdabot>  1.633123935319537e16
21:06:17 <nyc> I'm not familiar with that pattern.
21:06:25 <iqubic> tan $ pi / 4
21:06:43 <iqubic> > tan $ pi / 4
21:06:45 <lambdabot>  0.9999999999999999
21:06:51 <iqubic> Huh?!?!
21:07:02 <Solonarv> Those are Double's
21:07:06 <iqubic> I know.
21:07:17 <Solonarv> Why do you expect them to be exact, then?
21:07:21 <iqubic> I would have expected one of those to give me infinity.
21:07:36 <Solonarv> Rounding error.
21:07:39 <iqubic> Because one of those should be doing a divide by 0 operation.
21:07:55 <nyc> 1.6e16 is basically infinity.
21:08:06 <Solonarv> > sin $ pi/2
21:08:08 <lambdabot>  1.0
21:08:14 <Solonarv> > cos $ pi/2
21:08:16 <lambdabot>  6.123233995736766e-17
21:08:23 <Solonarv> as you can see: not quite zero!
21:08:23 <iqubic> Is there a way to do tan and get errors on invalid input?
21:08:29 <iqubic> yeah... I see.
21:08:47 <iqubic> So is there a way to do tan and blow up on invalid inputs?
21:09:15 <Solonarv> depends on what you mean by "blow up"
21:09:21 <nyc> iqubic: Symbolic representation of the argument.
21:09:36 <Solonarv> Symbolic math would do it, yes
21:09:54 <Solonarv> Obviously it's orders of magnitude slower than floats
21:09:58 <iqubic> Solonarv: I want to return (Just $ tan x) or Nothing
21:10:49 <iqubic> What I have is a Double/Float for the input.
21:12:05 <Solonarv> @let safeTan x = if t > 1e16 then Nothing else Just t where t = tan x
21:12:07 <lambdabot>  Defined.
21:12:18 <Solonarv> > safeTan $ pi/2
21:12:20 <lambdabot>  Nothing
21:12:35 <nyc> iqubic: Maybe represent \x -> tan (pi*x) so arguments that are half integers explode.
21:12:41 <argent0> > safeTan $ 3*pi/2
21:12:43 <lambdabot>  Just 5.443746451065123e15
21:12:54 <argent0> check mate
21:13:06 <iqubic> argent0: What happened there?
21:14:12 <iqubic> Oh... Shoot. I have support for Cotan, which I also want to support in this way.
21:14:24 <argent0> I'd clamp the angles to 0 < angle < 2*pi then forbid pi/2 and 3*pi/2
21:14:30 <iqubic> Why must rounding be the bane of me.
21:14:44 <iqubic> argent0: Is there a good way to clamp an angle?
21:14:46 <Solonarv> Would need some fuzziness on the equality, but that'd work
21:15:20 <nyc> iqubic: When all the singularities and zeros are rational numbers, Morera can quickly detect a singular argument.
21:16:36 <iqubic> nyc: I don't know what that means?
21:17:30 <nyc> iqubic: It's an infinite product with zeros in the numerator and poles in the denominator.
21:18:08 <iqubic> What does Morera mean?
21:18:29 <nyc> iqubic: For tan(pi*x) the poles and zeros are all rational.
21:19:20 <nyc> iqubic: It's the inventor of the theorem that says you can do that kind of infinite product expansion.
21:19:34 <iqubic> So how does that help me with safeTan?
21:20:06 <Lears> It seems kinda counterproductive to perform a coordinate transform that brings all the problematic points into your domain, when previously they were excluded as unrepresentable.
21:20:24 <Lears> tan is already safe on Float/Double
21:20:35 <iqubic> lears: what does that mean?
21:20:42 <nyc> iqubic: Rational poles and zeros are exactly representable up to a large boundary.
21:21:40 <nyc> iqubic: pi is irrational and so unrepresentable.
21:23:11 <nyc> iqubic: All your testcases were rational multiples of pi, so it seemed plausible.
21:23:16 <iqubic> When I say safeTan, what I mean is: I want to return (Just $ tan x) or Nothing, depending on whether or not there is an asymtote.
21:23:17 <argent0> iqubic: You could use: `newtype Angle = Angle Float` and a "smart" constructor angle :: Float -> Angle (to restrict your angles to the 0 < angle < 2*pi interval.
21:23:55 <Solonarv> I think you want s/Float/Double/
21:24:02 <iqubic> argent0: I could do that, but then I'd need to do a conversion every time I want to take Tan.
21:24:21 <argent0> tan . extractAngle
21:24:30 <iqubic> I see.
21:24:56 <nyc> Cancellation can be rather brutal.
21:25:45 <iqubic> nyc: What do you mean by brutal?
21:25:56 <argent0> Also you could write a Floating instance for Angle and use `tan :: Floating a => a -> a` directly
21:26:25 <iqubic> > asin (pi/2)
21:26:27 <lambdabot>  NaN
21:26:42 <iqubic> Is there a function that will test if something is NaN?
21:26:56 <Solonarv> :t isNaN
21:26:57 <lambdabot> RealFloat a => a -> Bool
21:27:11 <Solonarv> > isNaN (0/0)
21:27:13 <lambdabot>  True
21:27:18 <nyc> 2^n*pi + x with abs x < 1 experiences loss of significance at mere double digit (positive integer) n's
21:29:04 <iqubic> grr...
21:29:18 <argent0> nyc: but how does it affect periodic functions?
21:29:47 <argent0> if you make use of the periodicity o.c.
21:29:48 <iqubic> evalFunc (ASinF x::Maybe Double) = if isNaN a then Nothing else a where a = asin <$> x
21:29:54 <iqubic> How do I make that work?
21:30:39 <nyc> argent0 Loss of significance prevents reduction of arguments to fundamental  intervals by floating point subtraction reliably.
21:31:17 <argent0> nyc: Oh, that's right
21:32:10 <nyc> argent0: signalling errors on loss of significance may be worthwhile.
21:32:53 <iqubic> I have x :: Maybe Double. I want to take the ASin of the value in x. If that turns out to be NaN, then I want to return Nothing. Else return asin <$> x
21:33:01 <iqubic> I'm not sure how to do this.
21:34:00 <nyc> iqubic: guard (not . isNaN) ?
21:34:16 <iqubic> how does that work?
21:34:31 <iqubic> can you show me the full code?
21:34:46 <Solonarv> congratulations: you get to use the Monad instance for Maybe!
21:34:47 <nyc> Sure, bear with me.
21:35:30 <iqubic> I've been getting by with just the applicative.
21:35:39 <kaol> \x -> fmap asin x >>= \y -> guard (not $ isNaN y) >> return y
21:35:59 <iqubic> Will that work?
21:36:22 <kaol> > (\x -> fmap asin x >>= \y -> guard (not $ isNaN y) >> return y) (Just (1 :: Double))
21:36:24 <lambdabot>  Just 1.5707963267948966
21:36:58 <iqubic> > (\x -> fmap asin x >>= \y -> guard (not $ isNaN y) >> return y) (Just (2 :: Double))
21:37:00 <lambdabot>  Nothing
21:37:04 <iqubic> I see.
21:39:40 <nyc> > let asin' x' = do { x <- x' ; guard (not $ isNaN x) ; return $ asin x } in asin' (Just 0.5)
21:39:43 <lambdabot>  Just 0.5235987755982989
21:39:46 <iqubic> Why do I have to use the Monad instance of Maybe?
21:40:17 <nyc> iqubic: You don't, it just looks nice.
21:40:59 <iqubic> I se.
21:42:01 <iqubic> what does the guard function do?
21:42:04 <nyc> > let asin' x' = do { x <- x' ; guard (not $ isNaN x) ; let y = asin x ; guard (not $ isNaN y) ; return y } in asin' (Just 0.5)
21:42:06 <lambdabot>  <hint>:1:94: error: parse error on input ‘;’
21:42:46 <kaol> @src guard
21:42:46 <lambdabot> guard True  = pure ()
21:42:46 <lambdabot> guard False = empty
21:44:07 <nyc> > let asin' x' = do { x <- x' ; guard (not $ isNaN x) ; y <- return $ asin x ; guard (not $ isNaN y) ; return y } in asin' (Just 0.5)
21:44:09 <lambdabot>  Just 0.5235987755982989
21:44:36 <iqubic> That looks like two functions in one.
21:44:43 <nyc> The let within a do is a weakness of lambdabot.
21:45:43 <kaol> It's not really necessary to have guard before the asin call as giving it NaN just gives out a NaN.
21:46:08 <iqubic> I see.
21:46:12 <nyc> Good point.
21:46:31 <iqubic> So what function should I go with?
21:46:53 <nyc> > let asin' x' = do { x <- x' ; let { y = asin x } ; guard (not $ isNaN y) ; return y } in asin' (Just 0.5)
21:46:55 <lambdabot>  Just 0.5235987755982989
21:47:18 <iqubic> Why not just do this:
21:47:19 <nyc> iqubic: That one.
21:48:06 <pounce> just wondering, is there a way i can create a `show` for functions in ghci which just displays the types of the function?
21:48:50 <iqubic> > let asin' x' = do {y <- asin <$> x; guard (not $ isNaN y); return y} in asin' (Just 0.5)
21:48:52 <lambdabot>  error:
21:48:52 <lambdabot>      • Couldn't match expected type ‘m1 b1’ with actual type ‘Expr’
21:48:52 <lambdabot>      • In the second argument of ‘(<$>)’, namely ‘x’
21:49:02 <iqubic> Why does that fail?
21:49:23 <iqubic> > let asin' x = do {y <- asin <$> x; guard (not $ isNaN y); return y} in asin' (Just 0.5)
21:49:23 <c_wraith> because x is not x'
21:49:26 <lambdabot>  Just 0.5235987755982989
21:49:38 <cocreature> pounce: you could make a "(Typeable a, Typeable b) => Show (a -> b)" instance but it’s probably not going to be particularly useful
21:49:54 <iqubic> Right. I like that better than what you all gave me.
21:50:21 <pounce> i'm just getting tired of the error messages when i just want to see the type of a function
21:50:29 <pounce> although i could just use `:t`...
21:50:33 <nyc> iqubic: It's been a few years for me.
21:51:19 <cocreature> pounce: :t is definitely the better choice here
21:53:35 <nyc> <$> is not that much shorter than fmap. I guess it's infix.
21:53:42 <pounce> fair
21:53:49 <iqubic> it is.
21:54:05 <larryba> it is two times shorter than `fmap`
21:55:12 <iqubic> why do you all use not in the guard function?
21:56:59 <nyc> iqubic: Is there another Boolean negation?
21:57:46 <iqubic> Why do you need to negate the isNaN output to make guard work?
21:58:27 <kadoban> Because otherwise it'd do the opposite thing?
21:58:40 <nyc> iqubic: There isn't an isntNaN.
21:58:54 <iqubic> WHy do you need isntNaN?
21:59:10 <iqubic> what exactly is that guard function doing?
21:59:31 <nyc> iqubic: In order to return Nothing instead of NaN.
21:59:33 <kadoban> iqubic: Turning NaN into Nothing
21:59:44 <cocreature> guard p = if p then pure () else empty
21:59:56 <iqubic> I see.
22:00:07 <nyc> > let asin' x = do {y <- asin <$> x; guard (not $ isNaN y); return y} in asin' (Just 2)
22:00:09 <lambdabot>  Nothing
22:02:48 <pounce> what's a proxy? (in Typeable)
22:03:07 <cocreature> pounce: if it’s lowercase, then it is just the name of a type variable
22:03:21 <iqubic> evalFunc (ASinF x::Maybe Double) = do {y <- asin <$> x; guard (not . isNaN); return y}
22:04:05 <pounce> how do i use type variables using proxy?
22:04:17 <iqubic> variable not in scope: guard :: (Double -> Bool) -> Maybe a0
22:04:27 <iqubic> Why is that the error I'm getting?
22:05:14 <iqubic> evalFunc (ASinF x) = do {y <- asin <$> x; guard (not $ isNaN y); return y}
22:05:41 <iqubic> variable not in scope: guard :: Bool -> Maybe a0
22:05:48 <iqubic> What the heck?
22:06:49 <nyc> iqubic: It's probably in Data.Maybe or Control.Monad
22:07:00 <iqubic> I see.
22:07:10 <MarcelineVQ> https://hoogle.haskell.org/
22:27:13 <jle`> iqubic: "variable is not in scope" usually means that it is not imported
22:27:29 <pounce> hmph, i suppose polymorphic types aren't usually typeable
22:32:50 <sternmull> > 23 = 42
22:32:52 <lambdabot>  <hint>:1:4: error:
22:32:52 <lambdabot>      parse error on input ‘=’
22:32:52 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
22:33:01 <sternmull> % 23 = 42
22:33:02 <yahb> sternmull: 
22:33:14 <jle`> @let 23 = 42
22:33:14 <sternmull> % "wtf?"
22:33:15 <yahb> sternmull: "wtf?"
22:33:15 <lambdabot>  Defined.
22:33:41 <larryba> > 23 = 42
22:33:43 <lambdabot>  <hint>:1:4: error:
22:33:43 <lambdabot>      parse error on input ‘=’
22:33:43 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
22:33:44 <larryba> % 23 = 42
22:33:45 <yahb> larryba: 
22:33:50 <jle`> sternmull: remember that the syntax is <pattern> = <expression>
22:33:53 <larryba> ?
22:33:56 <larryba> what is going on
22:33:57 <jle`> so here 23 is a pattern, and 42 is an expression
22:34:00 <siraben>  > 23 == 42
22:34:31 <sternmull> jle`: But what is this expression? What is a pattern outside of a function?
22:34:48 <jle`> sternmull: an expression denotes a value, like `2 + 3` or `sin 63`
22:34:54 <jle`> or `Just "hello"`
22:35:23 <jle`> a pattern is how we make bindings, like `x:xs`, `Just x`, etc.
22:35:40 <jle`> @let blah:blahblah = 1:[2,3,4]
22:35:41 <lambdabot>  Defined.
22:35:44 <jle`> > blah
22:35:46 <lambdabot>  1
22:35:47 <jle`> > blahblah
22:35:49 <lambdabot>  [2,3,4]
22:35:54 <c_wraith> > let 1 = 2 in 3
22:35:55 <jle`> here, we bind `1:[2,3,4]` to `blah:blahblah`
22:35:56 <lambdabot>  3
22:36:01 <c_wraith> > let !1 = 2 in 3
22:36:03 <lambdabot>  *Exception: <interactive>:3:5-10: Irrefutable pattern failed for pattern 1
22:36:09 <jle`> to 'blah' get matched to 1, and 'blahblah' gets matched to [2,3,4]
22:36:12 <jle`> it's called "pattern matching"
22:36:33 <jle`> @let mappy f [] = []; mappy f (x:xs) = f x : mappy f xs
22:36:34 <lambdabot>  Defined.
22:36:56 <sternmull> jle`: That makes sense... but binding a constant to a different constant doesn't.
22:37:05 <jle`> if i call `mappy negate (1:[2,3])`, then f is bound to 'negate', x is bound to 1, and [2,3] gets bound to [2,3]
22:37:09 <jle`> sternmull: right, 23 is not a constant here
22:37:13 <jle`> it's a *pattern*
22:37:29 <jle`> 23 can be used as a numeric literal, but it's also syntactically overloaded as a pattern
22:37:36 <jle`> and it's important to make the distinction
22:37:40 <sternmull> hm, ok. And how could i possibly use this pattern in that place?
22:37:52 <jle`> it's the same thing here; `[]` is a constructor for a list, and is *also* a pattern
22:37:56 <jle`> like i use `mappy f []` earlier
22:38:03 <jle`> i'm using [] as a pattern, and not as a list literal
22:38:13 <jle`> and in 23 = 42, i'm using 23 as a pattern, and not as a numeric literal
22:38:15 <c_wraith> I still wish Haskell forbid bindings that don't actually bind a name.
22:38:22 <jle`> sternmull: 23 is a pattern that doesn't bind any names
22:38:26 <jle`> it's just like [], here
22:38:33 <jle`> [] is also a binding that binds no names
22:38:48 <jle`> @let isEmptyList [] = True; isEmptyList (_:_) = False
22:38:49 <lambdabot>  Defined.
22:38:51 <jle`> but patterns that bind no names are normal
22:38:55 <jle`> > isEmptyList []
22:38:57 <lambdabot>  True
22:38:59 <iqubic> What's going on here?
22:39:03 <jle`> note that if you call isEmptyList [], it binds no names, but we don't mind.
22:39:30 <jle`> and analogously we have isTwentyThree:
22:39:31 <nyc> (_:_) <- xs
22:39:32 <iqubic> c_wraith: So you don't like wildcards patterns either?
22:39:40 <jle`> @let isTwentyThree 23 = True; isTwentyThree _ = False
22:39:41 <lambdabot>  Defined.
22:39:43 <jle`> > isTwentyTree 23
22:39:46 <lambdabot>  error:
22:39:46 <lambdabot>      • Variable not in scope: isTwentyTree :: Integer -> t
22:39:46 <lambdabot>      • Perhaps you meant ‘isTwentyThree’ (line 163)
22:39:51 <jle`> > isTwentyThree 23
22:39:53 <lambdabot>  True
22:39:54 <jle`> > isTwentyThree 100
22:39:56 <lambdabot>  False
22:40:12 <jle`> 23 is a pattern that binds no name, just like [], Nothing, etc.
22:40:24 <c_wraith> jle`: but the binding there is the *whole* thing.  You're still binding the name isEmptyList or isTwentyThree.
22:40:27 <jle`> so `23 = 42` is syntactically equivalent to `Just x = Just "hello"`
22:40:39 <jle`> or more closely, `Nothing = Just "hello"`
22:40:40 <sternmull> but what happens with that overloaded pattern 23 after i do "23 = 42"? I can't figure out what i could possibly do with that in that place.
22:40:53 <jle`> sternmull: same thing that happens with `Nothing = Just "hello"`
22:40:59 <jle`> @let Nothing = Just "hello"
22:41:00 <lambdabot>  Defined.
22:41:06 <jle`> do you understand what goes on there?
22:41:16 <jle`> you're binding no variables
22:41:18 <jle`> you can do:
22:41:24 <jle`> @let Just myVal = Just "hello"
22:41:26 <lambdabot>  Defined.
22:41:27 <jle`> > myVal
22:41:29 <lambdabot>  "hello"
22:41:35 <jle`> @let Nothing = Just "hello"
22:41:37 <lambdabot>  Defined.
22:41:49 <jle`> if the former is allowed, the the latter is syntactically identical
22:42:38 <iqubic> how the hell did you just bind the name Nothing?
22:42:46 <jle`> i didn't bind the name nothing
22:42:52 <jle`> there is nothing bound
22:42:56 <iqubic> > Nothing
22:42:58 <lambdabot>  Nothing
22:42:59 <jle`> consider: what is bound in `Just myVal = Just "hello"` ?
22:43:03 <jle`> `myVal` is bound
22:43:07 <iqubic> Sure...
22:43:07 <jle`> *not* `Just myVal`
22:43:13 <jle`> so what is bound in `Nothing = Just "hello"`?
22:43:18 <iqubic> nothing.
22:43:24 <jle`> exactly. lower-case nothing, heh
22:43:30 <iqubic> Literally nothing is bound.
22:43:32 <jle`> because there is no variable name in any pattern position
22:44:00 <iqubic> > let Nothing = Just "hello" in Nothing
22:44:02 <lambdabot>  Nothing
22:44:08 <c_wraith> and I still think Haskell should forbid those bindings.  All they can do is cause confusion.  Or be evaluated with a bang pattern.
22:44:12 <iqubic> What the heck happened there?
22:44:23 <jle`> you did an irrefutable pattern match
22:44:31 <jle`> > let Just myVal = Just "hello" in myVal
22:44:33 <lambdabot>  "hello"
22:44:35 <iqubic> Why didn't that return Just "Hello"
22:44:44 <iqubic> My thing I mean.
22:44:49 <jle`> because nothing is being bound to Just "hello"
22:45:03 <jle`> Nothing = Just "hello" binds no variables
22:45:24 <jle`> remember that the point of <pattern> = <expression> is to bind variables, so you can use later
22:45:44 <jle`> c_wraith: it could be a warning maybe. but disallowing it is kind of weird because you'd be building in a special-case rule
22:45:45 <iqubic> And then I go ahead and evaluate `Nothing` and haskell needs to look up a total of 0 values.
22:45:56 <jle`> right, Nothing is Nothing
22:46:00 <jle`> it's a constructor
22:46:00 <iqubic> Yeah.
22:46:04 <jle`> it's like a Maybe literal
22:46:05 <sternmull> jle`: I now understand what you say is happening. But i agree with c_wraith. It makes no sense to me to make a "standalone" pattern that does not serve any purpose.
22:46:20 <iqubic> Nothing :: () -> Maybe a
22:46:29 <iqubic> Or something like that...
22:46:31 <jle`> the reason why it's allowed is because it's consistent; disallowing it would require adding special-case rules
22:46:35 <jle`> iqubic: Nothing :: Maybe a
22:46:58 <iqubic> can't you also think of it as () -> Maybe a?
22:47:03 <jle`> that has the wrong type
22:47:09 <jle`> > Nothing ()
22:47:11 <lambdabot>  error:
22:47:11 <lambdabot>      • Couldn't match expected type ‘() -> t’
22:47:11 <lambdabot>                    with actual type ‘Maybe a0’
22:47:11 <jle`> ^ type error
22:47:20 <iqubic> Oh. I see.
22:47:38 <jle`> but the two are isomorphic if we don't consider bottom, yeah.
22:49:19 <jle`> i think it makes sense to have it as a warning
22:49:36 <jle`> because (without bang) it's pretty much never what anyone wants
22:49:59 <jle`> but changing the standard to disallow it would complicate the standard a bit, i think
22:50:23 <iqubic> How so?
22:50:42 <jle`> i'm referring to disallowing patterns like `Nothing = Just "hello"`, and `23 = 42`
22:50:49 <sternmull> ist is just "Patterns that don't bind a name and don't serve for branching are invalid."
22:50:56 <jle`> iqubic: because right now, it's `<pattern> = <expression>`
22:51:24 <jle`> from a lexing, parsing, semantic perspective, pretty simple
22:51:48 <jle`> but now it's `<pattern that binds a variable if no branching or else any pattern> = <expression>`
22:52:26 <jle`> baking it into the syntax/AST/lexing/parsing seems to turn something very simple into something much more complex, involving more context-sensitivity, logic, etc., with little benefit
22:52:30 <iqubic> Is there a haskell type corresponding to endomorphisms?
22:52:45 <jle`> (A -> A), for some type A
22:52:48 <iqubic> Right.
22:53:00 <iqubic> Is there a monoid instance for that?
22:53:06 <amalloy> :i Endo
22:53:11 <jle`> not the endomorphism one no, but there is a newtype wrapper
22:53:16 <iqubic> :t Endo
22:53:17 <lambdabot> (a -> a) -> Endo a
22:53:19 <jle`> newtype Endo a = Endo { appEndo :: a -> a }
22:53:26 <iqubic> I see. Cool beans.
22:53:35 <Solonarv> (defined in base:Data.Monoid)
22:53:44 <jle`> > appEndo (mconcat [Endo negate, Endo (*2), Endo (+ 5)]) 9
22:53:46 <lambdabot>  -28
22:53:56 <jle`> > (negate . (*2) . (+5)) 9
22:53:58 <lambdabot>  -28
22:54:16 <jle`> the reason why it needs a newtype wrapper is that the 'default' Monoid instance for (a -> b) is different
22:55:46 <iqubic> What is the monoid instance for (a -> b)?
22:55:51 <iqubic> How does that even work?
22:56:03 <jle`> the default one is `Monoid b => Monoid (a -> b)`
22:56:09 <jle`> it's the "branch-and-recombine" instance
22:56:21 <iqubic> I'm not sure I understand.
22:56:27 <jle`> > mconcat [reverse, take 2, drop 3] "hello world"
22:56:30 <lambdabot>  "dlrow ollehhelo world"
22:56:38 <iqubic> Oh. I see.
22:56:39 <sm> hey all. what is the @ at https://github.com/emilaxelsson/quirinius/blob/master/examples/Test.hs#L46 ?
22:56:55 <jle`> mconcat [f,g,h] x = f x <> g x <> h x
22:57:02 <iqubic> right. Yes.
22:57:06 <jle`> sm: it's -XTypeApplications
22:57:13 <sm> thanks
22:57:20 <iqubic> And id is still the identify operation I think.
22:57:32 <Solonarv> Indeed
22:57:32 <jle`> sm: it lets you specify what the type variables in the type signature of 'table' should be
22:57:33 <iqubic> *identity.
22:57:38 <jle`> iqubic: are you sure? ;)
22:57:50 <iqubic> Yes. I am sure.
22:57:51 <jle`> > mconcat [reverse,id] "hello world"
22:57:53 <lambdabot>  "dlrow ollehhello world"
22:57:57 <jle`> hm ....
22:58:03 <iqubic> Oh. Right.
22:58:07 <jle`> > (reverse <> id) "hello world"
22:58:09 <lambdabot>  "dlrow ollehhello world"
22:58:11 <jle`> > reverse "hello world"
22:58:13 <lambdabot>  "dlrow olleh"
22:58:17 <jle`> ideally, `reverse <> mempty` should be the same as `reverse`
22:58:29 <jle`> but here, `reverse <> id` is different than `reverse`
22:58:32 <jle`> so `id` cannot be mempty
22:59:04 <iqubic> instance (monoid b) => monoid (a -> b) where...
22:59:25 <iqubic> mempty for this is the same as mempty for b
22:59:28 <iqubic> I think.
22:59:37 <iqubic> Not sure how to write that in code.
22:59:42 <Solonarv> not "the same", that doesn't typecheck
22:59:45 <jle`> just try
22:59:54 <iqubic> What is mempty here?
22:59:55 <Solonarv> But you've got the right idea.
23:00:03 <jle`> mempty has to have type (a -> b)
23:00:12 <jle`> but it has to be a function where `f <> mempty = f`, for all f
23:00:20 <jle`> so `reverse <> mempty` should be the same as `reverse`
23:01:06 <jle`> think about it :) but i helps to write out some code
23:01:11 <jle`> remember the syntax for defining a function, too
23:01:40 <iqubic> Yes. I know how to create a lambda
23:01:53 <iqubic> I just don't know the right thing for mempty.
23:02:25 <jle`> just start
23:02:29 <iqubic> I don't know what mempty should be.
23:02:43 <jle`> instance Monoid b => Monoid (a -> b) where
23:02:47 <jle`>     mempty x = ?????
23:03:11 <iqubic> mempty x = \x -> ___
23:03:24 <jle`> not quite, that doesn't typecheck
23:03:26 <Solonarv> That's one 'x' too many
23:03:33 <iqubic> mempty x = \a -> ___
23:03:41 <jle`> iqubic: what is the type of mempty?
23:03:49 <iqubic> (a -> b)
23:03:52 <jle`> right
23:03:55 <iqubic> Well, for this instance.
23:03:58 <jle`> and if you do `mempty x = \a -> ____` ....
23:04:08 <jle`> what would the inferred type be?
23:04:25 <jle`> it'd be inferred as a two-argument function
23:04:29 <jle`> an (a -> b -> c) or something
23:04:33 <iqubic> Oh... Right.
23:04:41 <jle`> so you could write `mempty = \x -> ????`
23:04:45 <jle`> or `mempty x = ???`
23:04:49 <iqubic> mempty x = mempty
23:04:50 <jle`> but not `mempty x = \a -> ????`
23:05:04 <jle`> iqubic: are you sure?
23:05:08 <iqubic> no.
23:05:14 <jle`> how can you make yourself sure
23:05:16 <iqubic> I have no idea what I need.
23:05:27 <jle`> right
23:05:30 <jle`> but how can you make yourself sure
23:05:38 <jle`> what did we do earlier to test out `mempty = id`?
23:05:40 <jle`> we tried out examples
23:05:43 <iqubic> Right.
23:05:48 <jle`> so, try out some examples now
23:06:02 <iqubic> > reverse "hello world"
23:06:04 <lambdabot>  "dlrow olleh"
23:06:23 <jle`> > (reverse <> (\_ -> mempty)) "hello world"
23:06:25 <lambdabot>  "dlrow olleh"
23:06:31 <jle`> looks good so far
23:06:49 <iqubic> > ((\_ -> mempty) <> reverse) "hello world"
23:06:50 <jle`> why not try out some more examples to make sure this wasn't just af luke
23:06:51 <lambdabot>  "dlrow olleh"
23:07:04 <jle`> well i'm convinced
23:07:18 <iqubic> > ((\_ -> mempty) <> (+7)) (7)
23:07:20 <lambdabot>  error:
23:07:20 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M892131087475...
23:07:20 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
23:07:26 <iqubic> Huh?
23:07:30 <jle`> that won't work because Int isn't a Monoid instance
23:07:37 <iqubic> Oh... Right.
23:07:50 <jle`> actually, in this case, you can prove this is a good mempty using equational reasoning
23:08:06 <jle`> (f <> (\_ -> mempty)) == f  ?
23:08:18 <jle`> (f <> (\_ -> mempty)) x = f x <> (\_ -> mempty) x
23:08:20 <iqubic> > ((\_ -> mempty) <> sum) [1,2,3]
23:08:22 <lambdabot>  error:
23:08:22 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M444378394299...
23:08:22 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
23:08:22 <jle`>   = f x <> mempty
23:08:24 <jle`>   = f x
23:08:37 <jle`> so here we prove using equational reasoning that f <> (\_ -> mempty) is equal to f
23:08:47 <Solonarv> > ((\_ -> mempty) <> (+7)) (7) :: Sum Int -- now it works!
23:08:48 <lambdabot>  Sum {getSum = 14}
23:08:50 <jle`> by using the definition (f <> g) x = f x <> g x
23:08:55 <iqubic> > ((\_ -> mempty) <> sum) [1,2,3]
23:08:57 <lambdabot>  error:
23:08:57 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M343599359398...
23:08:57 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
23:09:04 <iqubic> Why does that fail to typecheck?
23:09:07 <iqubic> :t sum
23:09:08 <lambdabot> (Num a, Foldable t) => t a -> a
23:09:10 <jle`> iqubic: sum here is [Int] -> Int, which has the same problem
23:09:15 <jle`> Int isn't a Monoid instance
23:09:16 <iqubic> Oh, right.
23:09:22 <iqubic> I keep forgetting.
23:09:35 <iqubic> Well, back to reading about category theory.
23:09:42 <jle`> but yeah, you can prove that this mempty works using equational reasoning
23:09:55 <jle`> i'll leave the `(\_ -> mempty) <> g = g` as an exercise if you want
23:10:23 <jle`> this actually is an example of a larger pattern of getting a free Monoid instance from any Applicative instance
23:10:48 <jle`> if F is an Applicative instance, you can give `Monoid m => Monoid (F m)` by setting `mempty = pure mempty`, and `mappend = liftA2 mappend`
23:17:51 <iqubic> You can tell that this book is old because it doesn't talk about how semigroup is the parent of monoid. It just jumps straight to monoid as a two function class.
23:20:27 <jle`> ah yes, Haskell, where anything released before March 2018 is old ;)
23:21:39 <iqubic> I'm just joking. This Milewski CT book is really good.
23:22:21 <iqubic> Brentosz Milewski, I think.
23:23:32 <Solonarv> Bartosz/
23:23:40 <siraben> iqubic:  is it the "category theory for programmers"?
23:23:46 <iqubic> Yes it is.
23:23:53 <iqubic> It's a bit abstract.
23:23:56 <siraben> Where are you up to in that book?
23:24:04 <siraben> Yeah, I need to revisit it
23:24:17 <iqubic> I just now learned why monoid has the greek prefix mono- in it.
23:24:44 <siraben> What helps if you study other areas of mathematics, then category theory makes sense, otherwise it's really abstract and you're left wondering why we need them
23:24:54 <siraben> Group theory helps
23:25:03 <siraben> Or just plain set theory
23:25:17 <siraben> iqubic:  why does it?
23:25:42 * siraben begins to recite a certain misattributed Phillip Wadler quote on monads being monoids
23:25:44 <iqubic> It's because a monoid is a one object category and mono- means one.
23:26:00 <siraben> Right, monoids can be thought of as one object categories.
23:26:26 <iqubic> not quite so sure how that works though.
23:26:42 <siraben> Always felt a little bit like cheating to me :), because a one object category is also a group, etc.
23:26:50 <siraben> To be a monoid you have to obey the monoid laws
23:26:51 <siraben> That's it
23:27:05 <siraben> And one object categories obey the laws trivially
23:27:08 <[exa]> hasn't monoid been named long before even CT existed?
23:28:10 <siraben> Along with most of group theory, I believe
23:29:22 <[exa]> always kindof thought that 'mono' is there either because of monotonicity or for the single point at the bottom of the <>-defined partial order
23:30:05 <jle`> siraben: a one-object category is not necessarily a group; that would be a one-object groupoid
23:30:25 <siraben> jle`:  but it obeys the group laws, no?
23:30:58 <Solonarv> siraben: in general, a one-object category lacks inverses
23:30:59 <jle`> we're talking about the monoid where the set is the set of morphisms
23:31:10 <jle`> and the monoid action is morphism composition
23:31:14 <siraben> Right
23:31:41 <[exa]> that being said, groups and groupoids are also monoids so the one-object definition is probably pretty precise
23:31:45 <jle`> group laws require that for every item 'a' there exists another item 'a^-1' where a * a^-1 = 1
23:32:01 <jle`> but this requirement is not met in general by all one-object categories
23:32:09 <siraben> jle`:  plus associativity, identity
23:32:25 <[exa]> (s/groupoids/semigroups/)
23:32:26 <jle`> consider the one-object category with two morphisms F, and G
23:32:42 <siraben> Ok
23:32:44 <siraben> Which are both endomorphisms
23:32:55 <jle`> defined where F . F = F, F . G = F, G . F = F, G . G = G
23:33:04 <jle`> G here is the identity element
23:33:18 <jle`> but F has no inverse x where F . x = G
23:33:56 <siraben> Ok so that doesn't make a group
23:34:19 <jle`> yeah; so that's an example of a one-object category whose morphisms do not form a group
23:34:29 <jle`> but in a one-object category, the morphisms will *always* form a monoid
23:34:40 <jle`> (with respect to morphism comp as the action)
23:34:54 <siraben> A little confusing because we know that F and G are equivalent (i.e. they're identity morphisms, right?)
23:35:00 <siraben> but they're not "equal"
23:35:08 <Solonarv> No, they're not identity morphisms
23:35:09 <jle`> no, there can only be one identify morphism
23:35:18 <Solonarv> well, they're not *both* identity morphism
23:35:32 <siraben> But in a one object category isn't every morphism go from the single object to itself?
23:35:33 <siraben> a -> a
23:35:36 <jle`> siraben: yes
23:35:39 <siraben> doesn't*
23:35:42 <jle`> but only one of those morphisms is the identity morphism
23:35:53 <siraben> The identity morphism is unique?
23:36:00 <Solonarv> Unique for each object, yes
23:36:08 <jle`> yes, and the proof is actually pretty interesting :)
23:36:13 <iqubic> but there is only one object here.
23:36:13 <siraben> Huh that confuses me
23:36:16 <siraben> How can
23:36:35 <siraben> How can you have multiple morphisms going to and from the same object but not be identity morphisms?
23:36:40 <siraben> I'd like to see the proof
23:36:55 <jle`> the identity morphism is the morphism where `id . f = f`, for all f
23:37:04 <iqubic> right...
23:37:09 <pounce> > show $ typeOf 5
23:37:11 <lambdabot>  "Integer"
23:37:13 <jle`> so clearly there are morphisms where this is not true
23:37:23 <jle`> i guess maybe i shouldn't say 'clearly' in this context, since it might not be clear
23:37:27 <pounce> why does this happen when `5` is Num?
23:37:32 <iqubic> I'm not seeing it.
23:37:35 <jle`> pounce: defaulting rules
23:37:38 <siraben> pounce:  Num is the typeclass
23:37:49 <jle`> iqubic: say (Int -> Int), is `negate` the identity morphism?
23:37:52 <Solonarv> pounce: 'Num' isn't a type
23:37:53 <jle`> it isn't, because negate . f is not f
23:37:54 <Solonarv> :t 5
23:37:55 <lambdabot> Num p => p
23:37:58 <siraben> jle`:  no
23:38:01 <iqubic> jle`: no.
23:38:03 <jle`> so negate is an Int -> Int, that is not an idenitty morphism
23:38:06 <iqubic> No it isn't.
23:38:08 <pounce> well, yeah sorry i don't know how to phrase that >w<
23:38:08 <siraben> Ah that makes sense
23:38:19 <iqubic> Wait... Int is the object?
23:38:20 <siraben> because you need f . id = f forall f
23:38:26 <siraben> I mean id . f = f
23:38:34 <iqubic> I thought Objects were values, and not types.
23:38:37 <siraben> iqubic: in the category of types, types are objects
23:38:38 <jle`> iqubic: yeah, in Hask we consider the types to be the objects
23:38:46 <jle`> iqubic: category theory doesn't have a concept of "values"
23:38:51 <siraben> You're not supposed to look "inside" the object
23:38:53 <siraben> It's a black box
23:38:54 <iqubic> Right. I know that.
23:39:11 <jle`> so values is a Haskell concept, but if we're talking about category theory and the Hask category, "values" isn't something that a category has
23:39:21 <siraben> jle` thanks for that negate example that helped
23:39:23 <iqubic> Right. Cool.
23:39:25 <siraben> I thought I was going crazy
23:39:33 <iqubic> Yeah... Negate is a good thing to see.
23:39:46 <jle`> siraben: no worries :) yeah it's something trippy, the baggage comes from looking at categories as graphs at first, i think
23:40:01 <jle`> which they aren't, but graphs are a nearby intuitive thing that a lot of people latch onto.  i know i did
23:40:04 <iqubic> I was looking at categoryies as graphs.
23:40:18 <siraben> cat theory is always more abstract than I think, huh
23:40:36 <Solonarv> I came at CT from Haskell, so mapping object ~ type, morphism ~ function was a good intuition pump
23:40:45 <jle`> not all graphs even are categories
23:40:47 <siraben> iqubic: that book uses a lot of graph analogy-making
23:40:47 <siraben> "diagram chasing"
23:41:01 <siraben> jle` because you can have graphs that have no vertices
23:41:08 <siraben> Right?
23:41:13 <Solonarv> No, the empty category is a category too.
23:41:17 <iqubic> This image is more confusing than it needs to be: https://imgur.com/a/UnhIx6T
23:41:27 <jle`> but you can think of categories roughly as multi-edged directed graphs, with some laws.  but i don't think it's a particularly good 'first view' of categories
23:41:45 <iqubic> what do you think is a good `first view`?
23:41:55 <siraben> iqubic:  I forgot what a free category is, hm.
23:42:06 <jle`> i'm not sure what the best is, but i think of categories as a 'partial monoid'
23:42:19 <siraben> I think the thing with category theory is that studying other abstract algebra really sets it in
23:42:26 <jle`> it's a monoid where <> isn't defined for every pair in your set
23:42:29 <iqubic> I'm not sure what a free category is either.
23:42:48 <siraben> "free {category|monoid|monad|functor...}"
23:42:48 <nshepperd1> You can visualise a category as a graph, but such a visualisation leaves out the composition operator, which is the most important part
23:42:56 <iqubic> I was mainly looking at the confusing image above.
23:43:20 * Solonarv likes Set
23:43:27 <siraben> iqubic:  what part confuses you about that image?
23:43:28 <jle`> siraben: re: the proof of unique identity, consider that 'f' and 'g' are both identity morphisms.  if that is the case, then f . g = f, and also f . g = g.  therefore, f = g
23:43:40 <siraben> It's shows a hom-functor
23:43:42 <siraben> it
23:43:46 <jle`> siraben: so if f and g are both identity morphisms (for a given object), then f must equal g
23:43:57 <siraben> jle`: that's true, that's similar to the group theory proof
23:44:04 <siraben> "every group has a unique identity"
23:44:05 <iqubic> siraben: It's just that there are several morphisms from m to m that are not the identity morphis,
23:44:11 <jle`> siraben: yeah, the group theory proof actually works for monoids too
23:44:21 <siraben> And if you did have candidate f and g they would be isomorphic, right?
23:44:21 <jle`> and it's the exact same proof, yeah
23:44:30 <siraben> Well equal, not isomorphic
23:44:51 <jle`> yeah, up to however standard you define equality of arrows
23:45:06 <jle`> whatever '=' you use to say 'f . id = f'
23:45:09 <siraben> jle` what are the "free" constructions?
23:45:16 <siraben> Let's stay we're talking about free categories
23:45:30 <iqubic> So now, after talking about monoids this book proceeds to talk about the kleisli category. It does so by introducing the Writer.
23:45:34 <siraben> (is this related to Wadler's paper on parametricity, "Theorems for Free"?)
23:45:36 <iqubic> :t Writer
23:45:36 <jle`> i think in this sense it helps to look at categories like tagged monoids
23:45:37 <lambdabot> error:
23:45:37 <lambdabot>     • Data constructor not in scope: Writer
23:45:37 <lambdabot>     • Perhaps you meant one of these:
23:45:51 <jle`> siraben: i don't think it's related, no; the 'free' in both cases are different, I believe
23:45:51 <iqubic> tagged?!?
23:45:57 <jle`> or 'indexed monoids'
23:46:05 <siraben> jle`: ok, so what are free categories?
23:46:16 <jle`> normally monoids have action type M -> M -> M
23:46:30 <Solonarv> the "tags" are the source and target of a morphism. You can only compose morphisms if the "tags" line up properly
23:46:31 <jle`> 'indexed monoids' are k -> k -> Type, and have action type M i j -> M j k -> M i k
23:46:42 <iqubic> I see.
23:46:47 <siraben> You have a function that returns a type?
23:46:50 <jle`> so if you have an indexed (<>) :: M i j -> M j k -> M i k
23:47:01 <jle`> siraben: i'm talking about the "kind" of indexed monoids, in our haskell language
23:47:06 <jle`> k -> k -> *
23:47:14 <siraben> What's the type of your type constructor M
23:47:34 <jle`> k -> k -> *
23:47:40 <jle`> oh, sorry
23:47:49 <jle`> um, is that what you were asking?>
23:47:56 <iqubic> the type of M
23:48:03 <jle`> the kind of M is k -> k -> *
23:48:15 <siraben> Ah because type constructors have kinds not types
23:48:19 <iqubic> So what is a free category?
23:48:22 <siraben> And where * denotes what?
23:48:32 <jle`> in haskell, it is the kind of things that can have values
23:48:38 <jle`> so `IO :: * -> *`
23:48:41 <jle`> `Int :: *`
23:48:49 <jle`> `Either :: * -> * -> *`, etc.
23:48:51 <iqubic> And what is "k"?
23:48:56 <siraben> A type I believe
23:48:58 <jle`> k is a kind variable, like a type variable
23:49:06 <jle`> really i should pick something concrete
23:49:14 <iqubic> please do.
23:49:18 <jle`> `M :: A -> A -> *`, then
23:49:25 * siraben 's mind is melting
23:49:45 * iqubic 's mind is also melting
23:49:47 <jle`> so if you have a "normal" monoid, you'd have (<>) :: M -> M -> M
23:49:53 <iqubic> Right.
23:49:57 <jle`> if you have an "indexed" monoid, you'd have (<>) :: M i j -> M j k -> M i k
23:50:10 <jle`> the M is parameterized by 'indices' that determine what you can legally <> them with
23:50:13 <siraben> Could you give an example of where an indexed monoid comes in handy?
23:50:14 <naiveai> single letter type names are obviously the most understandable
23:50:24 <iqubic> Right. Because you need the types/kinds match up.
23:50:24 <siraben> So it's a dependent type?
23:50:30 <jle`> siraben: well, a common one you encounter in Haskell is (->)
23:50:42 <siraben> :t (->)
23:50:44 <lambdabot> error: parse error on input ‘->’
23:50:53 <jle`> where we have (.) :: (->) j k -> (->) i j -> (->) i k
23:50:57 <iqubic> Where mempty = id, <> = .
23:50:59 <jle`> :k (->)
23:51:00 <lambdabot> TYPE q -> TYPE r -> *
23:51:04 <jle`> oops, that's not helpful
23:51:06 <siraben> Ah you're denoting infix
23:51:11 <jle`> (->) :: * -> * -> *
23:51:17 <jle`> yeah, (->) is an example of an indexed monoid
23:51:21 <jle`> where (<>) = flip (.)
23:51:34 <siraben> :t 3 <> 5
23:51:35 <lambdabot> (Num m, Monoid m) => m
23:51:47 <jle`> well the <> i'm using here is different than the <> in base
23:52:04 <iqubic> yeah.
23:52:05 <iqubic> but isn't (->) the basic building block of a category?
23:52:18 <jle`> we're talking about Haskell, and specifically the (->) type
23:52:25 <iqubic> I'm going to read the next chapter in my book. Time to learn about the Kliesli category.
23:52:27 <siraben> -> has a type?
23:52:35 <jle`> `Int -> Bool` is a type
23:52:45 <siraben> Yes
23:52:46 <jle`> and (->) is also a type i guess, but it's a type constructor here
23:53:02 <siraben> So (->) is a type constructor that takes two types and returns a new one
23:53:07 <jle`> i was talking about all indexed monoids in general, and the (->) family is one example of an indexed monoid
23:53:20 <siraben> How can I used an indexed monoid?
23:53:23 <jle`> yeah, (->) is parameterized by two "indices"
23:53:41 <iqubic> kliesli arrows are another such indexed monoid, I believe.
23:53:53 <jle`> an indexed monoid must have a properly defined (<>) :: M i j -> M j k -> M i k, and also id :: forall i. M i i
23:53:57 <iqubic> Whoops. Sorry.
23:54:11 <pounce> are there other "infix" type constructors or is (->) unique?
23:54:23 <iqubic> :k (+:)
23:54:24 <lambdabot> error:
23:54:24 <lambdabot>     Not in scope: type constructor or class ‘+:’
23:54:26 <jle`> such that <> is associative, and id_j <> x = x <> id_i = x for all x.
23:54:30 <jle`> pounce: you can infix any type constructor
23:54:39 <jle`> > Left 3 :: Int `Either` Bool
23:54:41 <lambdabot>  Left 3
23:54:48 <iqubic> :k (:+)
23:54:49 <lambdabot> a -> a -> Complex a
23:54:58 <jle`> :k Int `Either` Bool
23:54:59 <lambdabot> *
23:55:01 <siraben> Whoa what's that (:+)
23:55:07 <iqubic> That's an infix type constructor.
23:55:08 <jle`> (:+) is an infix data constructor
23:55:13 <jle`> not a type constructor here
23:55:22 <jle`> it's just the constructor of the Complex a type
23:55:27 <jle`> (data constructor)
23:55:29 <iqubic> siraben: it's for Complex numbers
23:55:35 <iqubic> a :+ bi
23:55:36 <Solonarv> well, if you ask for its kind it'll be promoted...
23:55:38 <siraben> > 5 :+ 4 
23:55:40 <lambdabot>  5 :+ 4
23:55:47 <jle`> right, but in this case we're using it as an infix data constructor
23:55:51 <siraben> :t 5 :+ 4
23:55:53 <lambdabot> Num a => Complex a
23:55:59 <jle`> @let data MyInfix = Int :**: Bool deriving Show
23:56:00 <lambdabot>  Defined.
23:56:01 <iqubic> I'm not even sure what a type constructor is.
23:56:05 <jle`> :t 3 :**: True
23:56:06 <lambdabot> MyInfix
23:56:10 <jle`> > 3 :**: True
23:56:12 <lambdabot>  3 :**: True
23:56:17 <siraben> iqubic: a function that takes types and returns a new type?
23:56:24 <jle`> iqubic: type constructors are things like Either, IO, Maybe, etc.
23:56:29 <pounce> huh, so is (->) not special at all?
23:56:32 <siraben> :k Maybe
23:56:33 <lambdabot> * -> *
23:56:36 <iqubic> Ah. Right.
23:56:41 <jle`> pounce: it's special because it's "overloaded"
23:56:43 <siraben> :k Just
23:56:44 <lambdabot> a -> Maybe a
23:56:49 <iqubic> :k (:)
23:56:49 <jle`> but synactactically it's not special, i believe
23:56:50 <lambdabot> a -> [a] -> [a]
23:56:54 <kadoban> pounce: Very little special
23:57:06 <jle`> of course, -> is also used in many places outside of kind/type sigatures
23:57:09 <siraben> Why use  :k instead of :t ?
23:57:12 <pounce> what does overloaded mean there?
23:57:14 <siraben> :t Just
23:57:15 <lambdabot> a -> Maybe a
23:57:20 <iqubic> Why isn't (:) a type constructor?
23:57:20 <jle`> :k gives us kinds of types, :t gives us types of values
23:57:22 <lambdabot> error: parse error on input ‘of’
23:57:22 <pounce> (yeah, i just mean in type signatures)
23:57:25 <iqubic> or is it?
23:57:40 <Solonarv> It is if you promote it! (with -XDataKinds)
23:57:50 <jle`> iqubic: traditionally : is a data constructor
23:57:58 <jle`> > 1 : [2,3]
23:57:58 <siraben> `cons`
23:58:00 <lambdabot>  [1,2,3]
23:58:07 <iqubic> :k (:)
23:58:08 <lambdabot> a -> [a] -> [a]
23:58:09 <jle`> pounce: it's...complicated. it's overloaded in more than one way, heh
23:58:16 <pounce> ok XwX
23:58:26 <iqubic> Its kind is the same as its type.
23:58:29 <jle`> pounce: in one sense, it's overloaded *synatictically* because it's used as a type constructor, and also as a kind consturctor
23:58:56 <jle`> iqubic: when you do :k (:), you're asking for the kind of something different than when you do :t (:)
23:59:05 <jle`> they just happen to share the same literal; it's a haskell syntax quirk, heh.
23:59:15 <pounce> ah, also it has syntax in case/view patterns yeah
23:59:20 <iqubic> I'm going to read about another kind of indexed monoid. The kliesli category. Be back later.
23:59:23 <jle`> pounce: and it's overloaded also purely at the type level alone, because it has to work for types of different boxedness
23:59:42 <pounce> boxedness? (sorry if i'm derailing the conversation
23:59:43 <jle`> most type constructors are defined to work only for boxed or unboxed types, but (->) is overloaded to work for both boxed and unboxed types
23:59:46 <siraben> jle` did you study mathematics?
23:59:55 <jle`> pounce: it's a low-level optimization
