00:32:49 <dminuoso> :t forkIO
00:32:50 <lambdabot> error: Variable not in scope: forkIO
00:32:57 <dminuoso> % import Control.Concurrent
00:32:58 <yahb> dminuoso: 
00:33:00 <dminuoso> % :t forkIO
00:33:00 <yahb> dminuoso: IO () -> IO ThreadId
00:33:08 <dminuoso> Why `IO ()` and not `IO a`?
00:34:00 <dminuoso> I mean it seems that `forkFinally` would also work for me, but why is it monomorphized to ()?
00:46:33 <Ariakenom> % :t forever
00:46:33 <yahb> Ariakenom: Applicative f => f a -> f b
00:49:18 <Ariakenom> dminuoso: hm doesn't seem like a consistent choice
00:51:24 <merijn> dminuoso: Just as a sort of reminder that you can't get access to the result of forkIO
00:51:34 <merijn> dminuoso: It's kinda similar to -Wunused-do-binds
00:51:57 <dminuoso> merijn: But wouldn't `IO a -> IO ThreadId` also remind you of the same fact?
00:51:57 * hackage salak 0.2.2 - Configuration Loader  http://hackage.haskell.org/package/salak-0.2.2 (leptonyu)
00:52:09 <merijn> dminuoso: Not when you accidentally do 'forkIO getLine"
00:52:30 <merijn> dminuoso: I don't mean as reminder in the type signature, as a reminder when trying to call forkIO
00:52:56 <merijn> dminuoso: As is "forkIO getLine" gets the compiler yelling at me
00:52:57 <dminuoso> merijn: Every time I use `IO Void` to express infinite threads I get brickstones put into my way. :(
00:53:18 <merijn> dminuoso: Why? It trivial to fix that?
00:53:39 <merijn> void, fmap absurd, vacuous, take your pick
00:54:50 <dminuoso> merijn: I dont think that reminder of `the result is lost` is worth the arbitrary limitation.
00:54:58 <dminuoso> It somehow feels very unhaskellish.
00:55:34 <merijn> dminuoso: -Wunused-do-binds is also questionable, imo, I usually disable it. But that's the rationale most likely
00:55:39 <dminuoso> I mean it's not like weeks of debugging will be lost for anyone who accidentally falls into that trap.
00:55:59 <dminuoso> merijn: Oh yeah, agreed - that warning annoys me.
00:56:01 <merijn> dminuoso: You underestimate the trickiness of debugging threads :p
00:56:12 <merijn> I do like the one about unused IO binds, though
00:56:16 <merijn> Forget what it's called
00:56:31 <dminuoso> merijn: if you have problems with threads Im going to argue that it will not be because forkIO gets a more general type.
00:56:49 <dminuoso> merijn: Can you construct a realistic scenario in which doing so would create hard to debug scenarios?
00:58:06 <merijn> No, because it's not gonna happen in small 10 line examples. It's going to trip you up by something unexpected happening in a huge codebase with 100s of threads
00:59:03 <dminuoso> merijn: Sorry really not seeing it. `forkIO getLine` should be completely valid Haskell I feel.
00:59:34 <dminuoso> ah well, Ill just open an issue and see what discussion arises.
01:00:00 <merijn> dminuoso: Depends what your threads do, to
01:00:51 <tdammers> I guess forkIO :: IO () -> IO () is a pragmatic choice; by making it monomorphic, we never need to explicitly type the argument
01:01:30 <tdammers> IO Void -> IO () would be more honest, since you cannot use the result, but then you could only pass it actions that run forever
01:01:33 <dminuoso> It's not like `forkIO :: IO a -> IO a`, but it should rather be `forkIO :: IO a -> IO ThreadId`
01:02:05 <tdammers> yeah, but then it'd be polymorphic, and passing it a forall a. IO a would then mean that you have to force the type
01:02:11 <tdammers> (to something arbitrary, even)
01:02:28 <dminuoso> tdammers: You have to do that anyway!
01:02:47 <dminuoso> It's even worse with `IO () -> IO ThreadId`
01:03:07 <tdammers> not at the call site though
01:03:13 <tdammers> the forkIO forces the type already
01:03:41 <tdammers> forkIO (doTheThing :: IO ()) -- is kind of ugly, lots of noise for something you don't care about anyway
01:04:11 <asheshambasta> I'm stumped by something as simple as this: https://gist.github.com/asheshambasta/5ff21c88eff5ea919e13c51b2d9fa5a7#file-overlappingtext-hs-L25-L44
01:04:17 <merijn> tdammers: "IO Void -> IO ()" is BS, though
01:04:22 <merijn> tdammers: threads can terminate
01:05:01 <dminuoso>         instance ToJSON Text
01:05:03 <dminuoso>           -- Defined in â€˜aeson-1.4.2.0:Data.Aeson.Types.ToJSONâ€™
01:05:05 <dminuoso> asheshambasta: ^-
01:05:10 <tdammers> merijn: yes, of course. but they don't have to, and forkIO doesn't care.
01:05:12 <asheshambasta> in short; I don't understand why GHC is complaining that the ToJSON instance of Text is overlapping with my `BusinessText t => ToJSON t` with t = Text
01:05:34 <merijn> asheshambasta: Constraints are *not* taken into account when deciding whether an instance matches
01:05:37 <tdammers> asheshambasta: because => doesn't mean what you think it means
01:05:39 <asheshambasta> dminuoso: but I'm not attempting to define a BusinessText instance for Text, why is GHC concerned about that? 
01:05:45 <merijn> asheshambasta: So that instances overlaps *everything*
01:06:13 <merijn> asheshambasta: Because you're writing "EVERYTHING is a ToJSON instance, but it needs a BussinessText instance!"
01:06:32 <merijn> asheshambasta: So GHC concludes Text is not a BussinessText, so the ToJSON instance can't apply
01:06:39 <asheshambasta> merijn: then I'm wrong about one of the basics; doesn't => mean that given there's an LHS constraint that is satisfied, the RHS can be declared? 
01:06:47 <tdammers> more specifically, the LHS of the => is only taken into account for instance *checking*, but not for instance *resolution*
01:07:14 <asheshambasta> I see
01:08:13 <tdammers> it may help to think of => as "if and only if"
01:08:39 <tdammers> i.e., "any type t has a ToJSON instance if and only if it has a BusinessText instance"
01:08:53 <merijn> asheshambasta: Sadly there's no really nice way to define generic instances like this
01:09:24 <merijn> (Well, unless you include default signatures in the class itself)
01:09:27 <asheshambasta> tdammers: yeah, I understand now, I was wrong about something as basic as this for all this time (albeit short stint with haskell)
01:09:39 <dminuoso> tdammers: Wait a second, of course you could do this
01:09:50 <dminuoso> % f :: IO a -> IO (); f = f
01:09:50 <yahb> dminuoso: 
01:10:01 <dminuoso> % g = f (undefined :: forall a. IO a)
01:10:02 <yahb> dminuoso: 
01:10:09 <dminuoso> Works no problem.
01:10:28 <tdammers> % g = f undefined
01:10:28 <yahb> tdammers: 
01:10:33 <tdammers> mkay
01:11:19 <merijn> asheshambasta: I think the most robust/simplest solution is to make ToJSON a superclass of BusinessText and then write a manual "toJSONHelper :: BusinessText t => t -> WhateverToJSONReturns"
01:11:57 <merijn> asheshambasta: Then anyone defining a BusinessText instance just has to do "instance ToJSON MyType where toJSON = toJSONHelper"
01:12:11 <merijn> Which is not great, but manageable
01:12:43 <asheshambasta> merijn: yeah that is what I was going for, just that I wanted to avoid that using my misunderstanding of constraints in the typeclass head. 
01:13:29 <merijn> asheshambasta: It's one of the things where I think Haskell could use improvements (refactoring typeclasses, adding superclasses, generic base/default implementations), but designing a robust system is hard.
01:13:59 <merijn> asheshambasta: If you're dealing with custom typeclasses you can use -XDefaultSignatures to fake it a bit
01:14:28 * dminuoso also thinks that overlapping instances generally are a codesmell
01:14:44 <merijn> -XDefaultSignatures lets you define a "default" implementation that's less general than the actual type
01:15:03 <dminuoso> I think you can even write incoherent programs with overlapping instances right? I think I read a blog article with an example once.
01:15:18 <merijn> asheshambasta: For example: https://github.com/merijn/validated-literals/blob/master/ValidLiterals.hs#L88-L89
01:15:50 <merijn> asheshambasta: Here the default implementation uses the Lift instance of 'b', which (effectively) means that GHC treats the class as not having a default implementation if 'b' is not a Lift instance
01:16:25 <merijn> asheshambasta: Which doesn't help with ToJSON, since you don't control the class, but might help if you want to declare your own classes relying on BusinessText
01:16:41 <asheshambasta> merijn: yeah, I _could_ work with that (I think)
01:17:03 <merijn> asheshambasta: That still requires you to write "instance Foo MyType" but you can just rely on the default implementation
01:17:20 <merijn> And I think it'd work with DeriveAnyClass?
01:19:02 <asheshambasta> I'll try that too, I don't mind writing minimal boilerplate
01:21:18 <adamretter_> Is there a function in Haskell already defined like this:  (() -> a) -> IO a
01:21:34 <Solonarv> :t (<$)
01:21:36 <lambdabot> Functor f => a -> f b -> f a
01:21:45 <Solonarv> ah wait, no
01:21:48 <Solonarv> :t pure
01:21:49 <lambdabot> Applicative f => a -> f a
01:22:08 <Solonarv> '() -> a' is not really a thing that's used in Haskell
01:23:16 <adamretter_> I want to construct an "IO a" which when evaluated, will evaluate a zero argument function which produces the "a"
01:23:27 <[exa]> adamretter_: what should be the semantics of the function?
01:23:47 <Ferdirand> adamretter_: well then your zero-argument function which produces the "a" is a IO a already, no ?
01:23:50 <[exa]> adamretter_: the (() -> a) is not "zero argument"; you can just use 'a'
01:24:06 <marvin2> asheshambasta, what's the big picture?
01:24:14 <Ferdirand> maybe you want fmap over another IO a ?
01:24:42 <adamretter_> For arguments sake, lets say I have the function:
01:24:42 <adamretter_> five :: Int
01:24:42 <adamretter_> five = 5
01:24:50 <merijn> adamretter_: That's not a function, though
01:24:56 <marvin2> that's just an Int
01:25:07 <[exa]> adamretter_: anyway it's probably just 'return'
01:25:20 <[exa]> (specialized to IO ofc.)
01:25:29 <adamretter_> How about - 
01:25:29 <adamretter_> five' :: () -> Int
01:25:29 <adamretter_> five' () = 5
01:25:33 <xsperry> or pure
01:25:42 <xsperry> > pure 10 :: IO Int
01:25:44 <lambdabot>  <IO Int>
01:25:47 <xsperry> ^^ is that what you want?
01:25:51 <merijn> adamretter_: That's a function, yes. But a pointless one :p
01:26:08 <adamretter_> merijn: right it's a pointless function - but that isn't important for arguments sake
01:26:33 <adamretter_> merijn: so if I had the function 'five - is there a haskell function that given 'five will return an IO[Int]
01:26:37 <xsperry> pure 10, or return 10, creates an action which will, when executed, return 10
01:26:46 <merijn> adamretter_: Why "(() -> a) -> IO a" I suspect the others are right and you just want "a -> IO a"?
01:27:47 <Ferdirand> :t (return . ($ ()))
01:27:48 <lambdabot> Monad m => (() -> a) -> m a
01:28:08 <adamretter_> merijn: so consider hypothetically (i.e. outside of Haskell land) if I had a side-effect causing function that didn't return an IO but returned an int, and I wanted to make that function safe by defering its execution by turning it into an IO[Int]
01:28:08 <Solonarv> There is no pre-defined function with type '(() ->a) -> IO a', because that is pretty much not something you would ever need
01:28:33 <Ferdirand> well if it's side-effect causing, it should return an IO, not an Int
01:28:41 <adamretter_> Outside if Haskell land!
01:28:43 <MasseR> that () -> a is something I see quite a bit in Ocaml which doesn't have the IO type
01:29:07 <Ferdirand> even if you call it from the FFI, you make it safe by having it return IO
01:29:21 <adamretter_> Righty, so I am trying to implement something like IO in a language which provides side-effecting functions, I want to promote one of these side-effecting functions to a no-side-effecting IO action
01:29:38 <asheshambasta> marvin2: well, we're writing one of the biggest services in our infrastructure in Haskell (if you meant to ask me that)
01:29:46 <[exa]> adamretter_: there's no side effects in haskell except stuff like unsafePerformIO, which you can not "make safe" anyway
01:29:56 <adamretter_> I have written the function already, and I called it "of" but I wondered if there was a better name I could take inspiration from in Haskell
01:30:13 <adamretter_> Dammn it people I know that in Haskell there is no side-effects, there is only IO
01:30:24 <Solonarv> aaaah, your question makes sense now!
01:30:24 <marvin2> asheshambasta, sorry, wrong nick completion. that was meant for adamretter_
01:30:28 <adamretter_> I am talking about applying Haskell naming concepts to something in another language
01:30:41 * [exa] relieved! :D
01:30:45 <Solonarv> 'impure' seems like a decent name, I suppose?
01:31:08 <[exa]> I vote for having 'unsafe' in the name
01:31:23 <Solonarv> (as opposed to 'pure :: a -> IO a' which would wrap a "finished" value and not have any effects)
01:31:23 <adamretter_> So my question, is there something in Haskell with the signature "(() -> a) -> IO a", and if so what is it called? So I can reuse the name...
01:31:41 <Solonarv> adamretter_: there is nothing with that signature, but see my above suggestion
01:31:52 <Taneb> Closest I can think of is Control.Exception.evaluate
01:31:53 <Ferdirand> there is not, because we expect the haskell types to uphold their promises
01:32:00 <Solonarv> [exa]: that belongs on the "runIO" function, I would say
01:32:13 <Ferdirand> when using the FFI there is no name for it, because it just relies on whether you used IO or not when you declare the import
01:33:03 <xsperry> in a language with uncontrollable side effects I'm not sure how useful it is to call think of runIO as unsafe
01:33:16 <xsperry> (fear my typing)
01:34:49 <Solonarv> that is also a good point
01:35:55 <Ferdirand> at least for the C binding, you declare your imported function as type IO Int, and the FFI understands this as calling an int foo(void)
01:36:34 <Ferdirand> it's true that it is a bit awkward
01:38:10 <aramiscd> When I run ghc/runghc/ghci it always prints "Loaded package environment from ...".  `-v0` doesn't suppress it.  Is there a standard way for suppressing that message?  I didn't find anything in the user guide so far.
01:38:10 <adamretter_> Solonarv: okay I see
01:38:49 <adamretter_> Solonarv: "unsafe" isn't a terrible name, but I think the function actually does the opposite - its like 'make-safe' or more likely "protect"
01:39:11 <adamretter_> Hangon though...
01:39:33 <Solonarv> I think I would choose 'pure :: a -> IO a' and 'impure :: (() -> a) -> IO a' as the names
01:39:33 <xsperry> adamretter_, I'm not sure I 100% understand your question, but maybe this will be helpful. an example of creating limit IO-like type on top of haskell's IO.
01:39:35 <xsperry> http://web.archive.org/web/20150308115958/http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/
01:39:51 <Solonarv> you are building an IO value out of a (pure) value resp. an impure function
01:40:15 <merijn> I think a better term would be "delay"
01:40:20 <Solonarv> That works too
01:40:28 <adamretter_> merijn: 'delay' is suitable as well for sure
01:40:43 <adamretter_> So in Monix, they call it 'delay' or 'defer'
01:40:54 <merijn> I think he's effectively trying to make IO "lazy", as this type seems similar to some methods for faking laziness in strict languages
01:41:00 <adamretter_> s/defer/eval
01:41:01 <xsperry> to delay sid-effects in a non-haskell language, you would wrap the call inside of a lambda
01:41:11 <merijn> xsperry: That's what his type is doing :p
01:41:40 <adamretter_> xsperry: I started with this - https://blog.adamretter.org.uk/haskell-io-and-xpath/
01:42:33 <adamretter_> merijn: yes it will be lazy, but the language I am using is not strict, the important thing is that the ordering will be explicit
01:58:46 <Ariakenom> adamretter_: fromFunction?
03:34:28 * hackage quickcheck-state-machine 0.6.0 - Test monadic programs using state machine based models  http://hackage.haskell.org/package/quickcheck-state-machine-0.6.0 (stevana)
03:40:46 <xsperry> -XOverlappingInstances is deprecated: instead use per-instance pragmas OVERLAPPING/OVERLAPPABLE/OVERLAPS
03:41:05 <xsperry> what should I use to be able to do this? instance (RealFrac a) => DecimalShow a where
03:42:50 <phadej> instance {-# OVERLAPPABLE #-} RealFrac a => DecimalShow a where ...
03:43:23 <phadej> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#overlapping-instances
03:43:57 <xsperry> thanks. that worked
03:45:42 <xsperry> OVERLAPS works too
03:45:53 <xsperry> from my very limited testing
03:47:38 <phadej> overlaps is both overlapping and overlappable; read the docs
03:51:16 <fr33domlover> Hi everyone o/ is there a library for http client page cache? Like if I GET the same page many times it reuses the old page? Or do I just use general purpose cache packages (fortunately there is a variety of them ^_^)
03:52:37 <phadej> I'd say latter
03:53:30 <Solonarv> I'm pretty sure http-client's Manager thing is supposed to handle caching, actually
03:54:00 <phadej> it handles keep-alive
03:54:42 <AfC> You might be better off throwing nginx or varnish in a container and just letting that be a proxy cache for you.
03:55:22 <phadej> (there's nothing parsing Cache-Control headers in http-client; and maybe you don't actually care as you know all your endpoints are immutable once exist etc.)
04:06:05 <fr33domlover> Thanks phadej, Solonarv ::)
04:06:21 <fr33domlover> AfC, that would be too much for my tiny use case
04:08:42 <tdammers> having http-client automatically and unconfigurably handle caching would be a bad thing IMO
04:09:29 <tdammers> if you don't care about correct cache invalidation, you can just throw a HashMap Url Response in some mutable-variable primitive and use that as a crude cache
04:10:52 <Nexilva> Hello
04:11:18 <fr33domlover> tdammers, I do need it to be correct, anyway it's a very specific use case where I'd be fine just manually downloading a page and keeping the parsed value in application state etc. I was just wondering if http-client had some ready thing where I can transparently GET and receive a cached version ^_^
04:11:46 <fr33domlover> There's plenty of cache packages in Hackage though, I'll be okay ^_^
04:11:57 <opqdonut> looks like wreq has built-in cache support
04:11:58 <opqdonut> http://hackage.haskell.org/package/wreq
04:11:59 <fr33domlover> Hello Nexilva 
04:12:04 <tdammers> yeah, it's not actually super difficult to implement, just annoying
04:12:19 <Nexilva> I try to learn Haskell but thenI try to make a type signature in ghci and it gives errors: I type `X :: Int -> Int` and Data constructor not in scope: X :: Int -> Int
04:12:31 <fr33domlover> opqdonut, I saw a Cache module but haven't figured out how to use, or whether it's automatic, docs don't mention
04:12:38 <Nexilva> Like X is defined as Taking an Int and returning an Int
04:12:44 <Nexilva> Do you know what I did wrongly?
04:12:47 <fr33domlover> (or maybe I missed that part?)
04:12:56 <opqdonut> Nexilva: X is a type name because it's upper-case
04:13:04 <opqdonut> Nexilva: use x :)
04:13:10 <Nexilva> So not capital things?
04:13:11 <xsperry> X can be type, constructor of Type, but it can't be a plain function
04:13:17 <Nexilva> You can't make a capital?
04:13:19 <Nexilva> Interesting.
04:13:35 <Nexilva> https://www.haskell.org/tutorial/goodies.html
04:13:37 <Nexilva> I was here for now
04:13:41 <opqdonut> yeah it's a slightly surprising choice coming from other languages, but you get used to it pretty fast
04:13:52 <opqdonut> and it makes reading code easier since you can spot types easily
04:14:34 <Nexilva> Why can't it be a X and have to be small x?
04:14:54 <Solonarv> short answer: because the people designing the language decided to do it this way
04:15:01 <Nexilva> Ok
04:15:05 <Nexilva> May I know a long answer?
04:15:33 <tdammers> because there are benefits to distinguishing variables from constructors at the syntax level
04:15:43 <Nexilva> I see
04:15:45 <tdammers> both from a UX perspective and from a parsing perspective
04:15:49 <Solonarv> As was said above, it makes it easier to distinguish between variables and constructor
04:15:54 <Nexilva> So what does it mean to have a capital letter thing?
04:16:07 <Nexilva> Is that a construtor? Isn't contructors in oop language?
04:16:16 <Nexilva> How does haskell have tht if it's only functional?
04:16:19 <Nexilva> you do mind explain?
04:16:21 <tdammers> it is a constructor, but the word doesn't mean what it means in an OOP language
04:16:26 <Nexilva> Oh
04:16:31 <fr33domlover> Nexilva, it's very common in many languages, even if just by convention, classes etc. start with uppercase letter and variables with lowercase
04:16:51 <Nexilva> So type signatures start with lowercase letters?
04:16:58 <tdammers> no
04:17:13 <tdammers> in some languages they do, but not in Haskell
04:17:14 <fr33domlover> Nexilva, may I ask which resources you're using for learning Haskell? :)
04:17:20 <Nexilva> Prelude> x :: Int -> Int
04:17:21 <Nexilva> <interactive>:1:1: error: Variable not in scope: x :: Int -> Int
04:17:23 <duairc> Is anyone using ghci on NixOS? I keep running into an error about not being able to find libz.so
04:17:25 <fr33domlover> And we'd love to suggest some good ones
04:17:30 <Nexilva> https://www.haskell.org/tutorial/goodies.html
04:17:32 <Nexilva> For now
04:17:45 <tdammers> Haskell distinguishes type-level and term-level positionally; casing encodes whether something is a constructor or a variable
04:17:51 <Nexilva> Small x also gives trouble
04:18:12 <Nexilva> inc            :: Integer -> Integer
04:18:17 <Nexilva> Do I have to type full word?
04:18:18 <Nexilva> maybe
04:18:50 <fr33domlover> Nexilva, try these: https://www.haskell.org/documentation
04:18:51 <Ferdirand> you cannot type in the interpreter what you would have in a file
04:18:54 <xsperry> ghci's limitation, you have to squeeze it in a single line in ghci
04:19:03 <xsperry> inc :: Integer -> Integer; inc x = x + 1
04:19:15 <Nexilva> oh
04:19:18 <xsperry> and at that point, it is probably better to enter code in a file and load it in ghci
04:19:21 <fr33domlover> Nexilva, those tutorials will clarify all these basics for you
04:19:24 <tdammers> one thing that often confuses beginners is that term-level (i.e., values) and type-level namespaces are separate, so you can have both a type constructor and a value constructor sharing the exact same name
04:19:34 <Nexilva> A Gentle Introduction to Haskell <- no good?
04:20:03 <Solonarv> it's not on the list of things frequently recommended in here, so I'm skeptical
04:20:06 <merijn> Gentle Intro is written for people who already know functional programming (so, Ocaml, SML, F#, etc.) not really for people new to strongly typed FP
04:20:08 <tdammers> the "Gentle" part is probably sarcasm
04:20:22 <Nexilva> It's linked on the page you gave me
04:20:27 <merijn> tdammers: Not really, it is a Gentle intro. Just not for the audience now reading it
04:20:35 <fr33domlover> Nexilva, I suggest one of the books at the top, also Haskell Wikibook is amazing
04:20:39 <tdammers> merijn: ah, yes, ofc
04:20:42 <Nexilva> ok
04:21:09 <fr33domlover> Nexilva, they're called books but they are like tutorials guiding you step by step
04:21:21 <tdammers> Nexilva: I'd start with the "Books" section rather than the "Tutorials". Haskell isn't exactly a language that lends itself to tutorial-style learning
04:21:36 <merijn> Solonarv: It's not commonly recommended, because most people in it's target audience already know Haskell by now :p
04:21:44 <Nexilva> Someone gave me the gentle intro in here a few days ago
04:21:54 <Solonarv> merijn: heh
04:21:57 <Nexilva> Firstly, can you decide among yourselves what is best?
04:22:08 <Nexilva> I get many different resources. Now I'm confused
04:22:13 <tdammers> unlike, say, Python, where you can copy-paste an example and then learn more about the language simply by changing random things and watching what happens, Haskell is more easily understood if you study the relevant concepts alongside the examples
04:22:14 <Nexilva> where to even start
04:22:22 <Nexilva> I have like 8 haskell learning things bookmarked
04:22:35 <fr33domlover> Nexilva, take the 1st book in the list and start reading :)
04:22:40 <tdammers> and no, we cannot tell you which of those you should be using, because only you know how you learn best
04:23:08 <Nexilva> I tried but the ghci can't let you type things properly so you have to load a file
04:23:14 <Nexilva> Makes a bit tedious
04:23:27 * hackage morphisms-functors 0.1.7 - Functors, theirs compositions and transformations  http://hackage.haskell.org/package/morphisms-functors-0.1.7 (iokasimovmt)
04:23:33 <Solonarv> usually you simply omit the type signatures in ghci
04:23:44 <fr33domlover> Nexilva, I learned with the Haskell Wikibook and it instructed me how to use GHCi and it went perfectly
04:23:50 <Nexilva> ok
04:23:55 <Nexilva> np I can try that
04:23:58 <Solonarv> but if you must: let { foo :: Whatever Type; foo = <whatever> }
04:24:20 <Solonarv> or use :{ and :} for multi-line input
04:24:33 <tdammers> > let foo = 23 :: Int -- works too
04:24:35 <lambdabot>  <no location info>: error:
04:24:35 <lambdabot>      not an expression: â€˜let foo = 23 :: Int -- works tooâ€™
04:24:46 <tdammers> though not on lambdabot :D
04:25:03 <Solonarv> yes, because lambdabot /= ghci
04:26:15 <tdammers> yeah, I know
04:31:05 <fr33domlover> > let foo = 23 :: Int in foo
04:31:07 <lambdabot>  23
04:32:28 <xsperry> simplest way:  inc :: Integer -> Integer; inc x = x + 1  
04:34:38 <Nexilva> :)
05:02:08 <xsperry> there was a Language equivalent of this, does anyone know off hand what it is? {-# OPTIONS_GHC -fno-warn-orphans #-}
05:03:00 <Solonarv> I'm quite sure there is no language option for this, actually
05:03:17 <Putonlalla> Type classes have "members" and "laws", but have they always been called that?
05:03:21 <Solonarv> you're turning off a warning, not enabling/disabling a language feature
05:03:43 <xsperry> Solonarv I'm pretty sure there is a Language extension that says "let me do this without a warning"
05:04:11 <xsperry> actually, let me try checking the haskell logs
05:04:25 <Solonarv> Putonlalla: I don't know the history of the terms, but even nowadays "method" is a frequently-used term for the functions belonging to a typeclass
05:04:44 <Solonarv> xsperry: I'd recommend checking the GHC user's guide
05:04:52 <Solonarv> it has a page listing all the extensions
05:05:03 <Putonlalla> It might be `IncoherentInstances`, if any, xsperry.
05:05:58 <Solonarv> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html
05:06:21 <xsperry> I searched https://downloads.haskell.org/~ghc/6.10.2/docs/html/users_guide/ghc-language-features.html for keyword "orphans", did not find anything 
05:06:28 <fuzzy-id> does anyone know how to setup emacs to get proper `interactive-haskell-mode' support via nix-shell?
05:06:40 <Solonarv> why are you looking at a positively ancient GHC version??
05:06:51 <Solonarv> Surely you aren't actually using 6.10?
05:07:01 <xsperry> I did not even notice. it was first link on google
05:07:18 <Solonarv> yeah use the link I posted ;p
05:08:55 <hpc> the ghc manpage needs a see also that links to those docs
05:09:49 <Solonarv> I actually look at the "language extensions" page so often my browser autocompletes the URL when I type "ghc"
05:24:41 <Nexilva> https://www.youtube.com/watch?v=re96UgMk6GQ
05:24:51 <Nexilva> This guy is mental.
05:25:16 <Nexilva> I'm like 1% mental if that.
05:25:28 <Nexilva> Take you 30 years to get to half his level.
05:25:31 <Nexilva> Hehehe
05:57:27 * hackage yam 0.5.11 - Yam Web  http://hackage.haskell.org/package/yam-0.5.11 (leptonyu)
05:58:27 * hackage yam-datasource 0.5.11 - Yam DataSource Middleware  http://hackage.haskell.org/package/yam-datasource-0.5.11 (leptonyu)
07:02:07 <Boarders> if I am wanting to write a rule like those in the following gist: https://gist.github.com/Boarders/10d5697fd32dc21b0fe0219cea239f80
07:02:31 <Boarders> are there any good guidelines for making sure it is written in such a way that further fusion might happen
07:02:51 <merijn> Boarders: The GHC user's guide has a bunch on rules and fusion
07:02:58 <Boarders> ok thank you
07:06:10 <mreh> any recommendations for haskell libraries to talk to a JSON API?
07:06:38 <dmwit> aeson is the one-and-only
07:07:22 <dmwit> Mmm. Depending on what you mean by that question, you might also be interested in checking out wreq.
07:07:28 <tdammers> aeson only covers the JSON part, not the API part
07:07:43 <tdammers> that said, servant-client may or may not work out
07:08:15 <tdammers> otherwise, aeson for the JSON part, and one of several HTTP client libraries for the API part (wreq was mentioned, there's also http-client and some libcurl bindings)
07:13:27 * hackage tar-conduit 0.3.2 - Extract and create tar files using conduit for streaming  http://hackage.haskell.org/package/tar-conduit-0.3.2 (lehins)
07:35:49 <Athas> What's the simplest way to do an exec() in GHC?
07:36:30 <Ariakenom> string -> (runprogram :: IO ())            ?
07:37:16 <phadej> `process` ? or actual C-style exec() ?
07:37:41 <Athas> An actual C-style exec() would be preferable.
07:38:09 <Athas> I want to pass my stdin/stdout/stderr on to the process, as well as propagate its exit code.  I can write that by hand using 'process', but I'd prefer to avoid the boilerplate if possible.
07:38:39 <merijn> Athas: Eh, FFI to exec? ;)
07:38:54 <merijn> Athas: So probably unix package?
07:39:20 <Athas> Now that I think about it, I also need it to work on Windows, so I guess I'm stuck with building it myself.  Oh well.
07:39:27 <merijn> Yeah, unix has several execFile functions
07:50:49 <berndl> Is there a way to make ghc take into account the context of type class instances so that `instance C1 a => Foo a` and `instance C2 a => Foo a` are different?
07:56:56 <infinisil> berndl: newtype wrappers?
07:58:22 <xsperry> rounding package is deprecated. is there something I should be using instead?
08:02:07 <berndl> infinisil: I'm already using a newtype wrapper...
08:04:57 * hackage ngx-export 1.6.3 - Helper module for Nginx haskell module  http://hackage.haskell.org/package/ngx-export-1.6.3 (lyokha)
08:17:28 * hackage yesod-test 1.6.6 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-1.6.6 (MaxGabriel)
08:22:57 * hackage forsyde-shallow 3.4.0.0 - ForSyDe's Haskell-embedded Domain Specific Language.  http://hackage.haskell.org/package/forsyde-shallow-3.4.0.0 (ugeorge)
08:27:26 <Ferdirand> what are the rules for fundep validation exactly ?
08:28:06 <Ferdirand> classes define constraints, and instances declared over variable types must ensure the are not violating them ?
08:30:26 <Ferdirand> trying to understand MonadTrans and friends and how additional parameters in the class interact with the various instances
08:34:11 <tsahyt> given a [(UTCTime, IO ())], where each UTCTime is at a future point in time, what would be the cleanest way to execute the IO actions at their specified timestamps (or as close to their timestamps as possible)
08:35:38 <wroathe> tsahyt: You could go with a background thread if you don't care about the possibility you'll lose queued jobs
08:36:31 <wroathe> tsahyt: Otherwise you'd probably want to persist that data and periodically poll for jobs to be executed (or use a tool built specifically for storing and executed delayed jobs)
08:36:37 <tsahyt> well, I need to execute all the actions in the list, I shouldn't be losing any of them. however precision isn't as important, being off by a second here and there is acceptable. also every action is fast to execute
08:37:08 <merijn> tsahyt: How much do you care about accuracy?
08:37:23 <tsahyt> merijn: a job should happen within a second or two of when it was specified
08:37:32 <merijn> tsahyt: I would sort the list by UTCTime, then threadDelay until the first action
08:37:39 <wroathe> tsahyt: In general this is a hard problem to solve depending on precisely the behavior you want :P
08:38:09 <tsahyt> merijn: mhm.. so I'd walk through the list, always calculating the time until the next action, sleeping until then, etc
08:38:10 <merijn> tsahyt: You can write a simple fold over the items doing that
08:38:15 <merijn> tsahyt: Yeah
08:38:20 <tsahyt> yea I guess that's simple enough
08:38:27 <tsahyt> and it should do the trick for what I need
08:38:32 <merijn> tsahyt: I mean, this isn't very robust, so if one throws an exception, etc. that can be a problem
08:38:44 <tsahyt> mhm
08:38:50 <wroathe> Or if the process gets nuked while there's jobs in the list
08:38:54 <merijn> but for simple things it should work
08:38:57 * hackage shell-monad 0.6.8 - shell monad  http://hackage.haskell.org/package/shell-monad-0.6.8 (JoeyHess)
08:39:03 <tsahyt> wroathe: that's acceptable for me
08:39:11 <tsahyt> I don't need to be able to pick it up again after some error
08:39:15 <tsahyt> I can safely restart
08:39:18 <tsahyt> I'm really just replaying a log
08:39:30 <merijn> tsahyt: Right, then I'd start with the fold and then worry about more complicated solutions later if needed
08:39:54 <tsahyt> alright.. I think there shouldn't be any exceptions. but exceptions tend to be exceptional, so.. yea. we'll see about that
08:40:16 <merijn> tsahyt: You can always wrap each action in a "try" and log any exceptions
08:40:34 <merijn> that way future jobs will at least continue
08:43:28 <wroathe> For XML parsing, what libraries do you guys recommend?
08:43:46 <merijn> wroathe: XML with a schema or just tagsoup?
08:44:01 <wroathe> Both
08:44:35 <merijn> For tagsoup xml-conduit was kinda nice
08:44:43 <merijn> I don't know a recommendation for XML with schema
08:45:07 <wroathe> merijn: I'll have a look thanks
08:45:09 <__monty__> I've used Text.XML.Light
08:45:55 <wroathe> __monty__: And would you use it again? :)
08:47:27 * hackage ngx-export-tools 0.4.3.0 - Extra tools for Nginx haskell module  http://hackage.haskell.org/package/ngx-export-tools-0.4.3.0 (lyokha)
08:47:39 <__monty__> I don't really remember it so I guess I wouldn't go out of my way not to?
08:47:51 <__monty__> Not much of a recommendation I admit.
08:51:04 <Boarders> could someone let me know what the -j flag does in ghc
08:54:07 <__monty__> Boarders: It specifies how many modules to compile in parallel.
08:57:38 <philippD> Is there a consensus on what's better betweene lens `makeLenses` and generic-lens?
09:00:49 <phadej> philippD: I don't think they are comprable
09:02:08 <glguy> philippD: For efficiency it's safest to go with the makeLenses version. There are neat techniques for giving GHC a chance to make the generics-generated lenses efficient but they don't work on some datatypes without extra GHC tuning
09:02:32 <glguy> The generics-based lenses can be nice for more experimenting and messing around, though
09:03:00 <philippD> you can also add validation to real lenses
09:03:11 <philippD> or it that an antipattern?
09:03:41 <glguy> I don't think lenses support validation
09:04:28 <philippD> you can throw an error
09:04:57 <glguy> Async exceptions aren't good for validation
09:05:07 <glguy> err, imprecise exceptions
09:05:20 <philippD> so that would be an antipattern
09:05:43 <glguy> I refuse to help people in labeling things "antipattern"
09:06:18 <philippD> How would I create lenses for a Datatype that has a smart constructor that restricts the input values in some way
09:06:22 <philippD> ?
09:06:34 <phadej> you don't
09:06:46 <phadej> or well, not lawless one at least
09:07:26 <phadej> there are the law (called GetPut), what you put in is what you get out
09:07:30 <wroathe> glguy: Would you say that labeling things as antipatterns is an antipattern?
09:07:32 <phadej> smart constructor violates that
09:07:43 <glguy> wroathe: That's not something I would say, no.
09:07:53 <wroathe> Damn, almost got you
09:09:02 <mreh> calling something an antipattern sounds like when the catholic church updates its list of heretical books 
09:10:45 <mreh> with the greatest respect to catholics
09:11:03 <Boarders> does anyone know how I add ghc-options to a cabal project file?
09:11:20 <wroathe> Boarders: It's literally ghc-options: 
09:11:42 <mreh> Boarders: have you checked the user guide?
09:11:42 <wroathe> https://www.haskell.org/cabal/users-guide/developing-packages.html#pkg-field-ghc-options
09:12:05 <Boarders> mreh: yes, but I am getting "Unrecognized field 'ghc-options' on line 10"
09:12:30 <mreh> Boarders: what version are you using?
09:12:34 <Boarders> 2.4
09:12:48 <Boarders> (2.4.1)
09:13:42 <mreh> hmm, paste your cabal file if you can
09:13:45 <mreh> on in here
09:13:48 <mreh> not*
09:13:54 <mreh> @where paste
09:13:54 <lambdabot> https://gist.github.com
09:14:02 <Boarders> it is not the cabal file it is the cabal.project file I was asking about
09:14:19 <amx> Boarders: did you put it in a `package` block?
09:14:25 <Boarders> I did not
09:14:37 <Boarders> I'll give that a try
09:14:51 <amx> ghc-options is not specifically described in this documentation, but is one of many fields for configuring programs. They take the form progname-options and progname-location, and can only be set inside package stanzas. (TODO: They are not supported at top-level, see #3579.)
09:15:15 <Boarders> I see, thank you!
09:15:47 <amx> you're welcome
09:24:50 <kuribas> genericLens is supposed to be efficient
09:25:01 <kuribas> they even have tests in place to ensure that
09:25:23 <kuribas> but you may have to raise the inline threshold in some cases.
09:25:34 <glguy> and to get that efficiency for large types you'll have to tune GHC as mentioned above with flags
09:26:24 <kuribas> that's true of generics in general
09:26:26 <kuribas> (no pun)
09:27:05 <glguy> In general you have to be careful in how you use them, and then pile on flags to get them to be efficient
09:27:20 <kuribas> but then raising the inline threshold may lead to code bloat
09:27:52 <glguy> I did the original work on getting generics to generate efficient lenses; it's pretty neat how it works out. Unfortuantely it's also disappointingly fragile
09:29:49 <kuribas> glguy: ah, nice :)
09:30:27 <glguy> There's a bit about it here https://github.com/glguy/generic-traverse/blob/master/src/Boggle.hs
09:41:34 <leshow> I've read that one should use Type instead of * in newer versions of GHC, but it appears to not be in scope
09:41:42 <leshow> is there something you need to import to get access to Type
09:42:13 <glguy> If you want to use Type you can import Data.Kind
09:42:21 <glguy> For now * is still the default
09:43:46 <leshow> glguy: thanks
09:44:54 <lotdw> Hi all!
09:45:00 <lotdw> What's the meaning of using => as opposed to -> in type declarations? For instance, in 1. even :: Integral a => a -> Bool and 2. splitAt :: Int -> [a] -> ([a],[a]). Has it do with typeclasses?
09:45:43 <wroathe> lotdw: It does. a in your example needs to have an instance for Integral
09:45:55 <wroathe> lotdw: Your first example, I mean
09:46:03 <geekosaur> yes. the thing before the => is a context; it provides informaation about typeclass instances, and type equivalence, etc.
09:47:34 <wroathe> lotdw: #2 means for any type a
09:47:45 <wroathe> no constraint
09:49:48 <lotdw> Thanks a lot, that helps!
09:51:16 <lotdw> Can any of you point to some further documentation on this that's accessible? especially on the use of "=>" and I guess typeclass declarations
09:52:01 <wroathe> lotdw: http://learnyouahaskell.com/types-and-typeclasses
09:52:30 <wroathe> lotdw: There's plenty more documentation available. Google is your friend :)
09:52:39 <lotdw> yes!
09:52:47 <lotdw> i just got to that at the same time
09:52:51 <lotdw> it's excellent, thx
09:53:08 <lotdw> too bad the book seems out of print in most of the world
09:53:23 <lotdw> they should do a reprint
09:53:58 <lotdw> it's reached levels beyond textbook prices now at ~ 200 $
09:55:14 <wroathe> lotdw: Just buy a tablet and read it on that
09:58:00 <leshow> lotdw: which book?
10:01:40 <amx> leshow: I believe he was talking about learnyouahaskell
10:02:00 <leshow> say I have a function that uses a generic Num a, but it does something like x ^ 2. Is there a way to make the 2 polymorphic
10:02:18 <leshow> so that it changes to chaanges its instance to whatever Num a is supplied
10:07:23 <amx> :t (^)
10:07:25 <lambdabot> (Num a, Integral b) => a -> b -> a
10:08:05 <leshow> oh right, ghc is giving me a message about defaulting the constraint to Integer though, but it doesn't throw an error with a generic function type. so I guess it's fine
10:20:59 <geekosaur> leshow, that's about the numeric literal "2". it is already polymorphic, but actual calls require a concrete type so it knows which "^" to use, so it uses defaulting to get Integer (and warns you)
10:22:08 <wroathe> geekosaur: I don't know what others do, but I typically -Wall, but disable that particular warning
10:23:57 * hackage publicsuffix 0.20190115 - The publicsuffix list exposed as proper Haskell types  http://hackage.haskell.org/package/publicsuffix-0.20190115 (wereHamster)
10:41:43 <Welkin> is there an easy way to implement ToJSON for a serialized json ByteString?
10:41:58 <Welkin> I tried `toEncoding = unsafeToEncoding . fromByteString` without luck
10:42:06 <Welkin> it still wants a Generic instance
10:42:21 <Welkin> but it won't let me define one
10:43:33 <Welkin> this all seems very stupid
10:45:41 <Welkin> maybe I need a type annotation for the tag in `Encoding' a`
10:47:49 <Welkin> damn it
10:47:53 <Welkin> why does it need a Generic instance?
10:48:13 <amx> can you paste code?
10:48:21 <amx> and error
10:48:36 <Welkin> https://hastebin.com/lefovekutu.hs
10:49:00 <Welkin> with error https://hastebin.com/ruzasoyibo.hs
10:49:52 <Welkin> I have the data already encoded as json in a bytestring
10:49:56 <Welkin> what's the deal
10:51:22 <Welkin> I'm letting the client validate the data, and the server just stores it opaquely and serves it when requested
10:51:59 <Solonarv> Welkin: you need to define both 'toEncoding' and 'toJSON'
10:52:28 <Solonarv> You didn't provide a definition 'toJSON', so GHC fell back on the default definition, which has a Generic constraint
10:52:32 <Welkin> I don't see how I can define toJSON, because that must be a Value
10:53:09 <infinisil> Welkin: I don't think From/ToJSON support opaque json values, check out https://hackage.haskell.org/package/aeson-1.2.4.0/docs/Data-Aeson-Parser.html instead
10:53:09 <Welkin> unless I decode my already-encoded bytestring into a Value
10:53:13 <Welkin> just to re-encode it again
10:53:18 <Solonarv> does the output of 'toEncoding' parse as a Value? If no, your encoding is broken anyway
10:54:43 <infinisil> Ohh yeah Value has a From/ToJSON instance
10:55:19 <Welkin> it only needs to be checks on initial storage
10:55:22 <Welkin> not on every access
10:55:24 <Welkin> checked*
10:55:30 <Welkin> that is wasteful and unnecessary
10:56:40 <monochrom> So you server code should just send the existing bytesting as is, without even getting aeson involved, no?
10:56:47 <Welkin> it should
10:56:55 <Welkin> but I am using servant for this
10:57:55 <Solonarv> I don't recall servant forcing you into aeson, but let me check again
10:57:56 <Welkin> I've been evaluating what to use for building this kind of a system, and it's between haskell and erlang, which pros and cons for each
10:58:15 <Welkin> haskell is a huge pain in the ass when it comes to database access and data conversions
10:58:34 <Welkin> well, the thing about servant is that it takes care of de/serialization of json
10:58:57 <Welkin> so you must have a ToJSON instance for your type if you want to send a response with the proper headers
10:59:06 <Welkin> unless you use a raw endpoint, which is just a wai application
10:59:24 <wroathe> Welkin: I think you just want to circumvent the Servant machinery in this case
10:59:41 <wroathe> Welkin: Set a custom Content-Type header, and send the ByteString as is
11:00:47 <wroathe> You already know it's JSON, you don't need to run it through the serialization machinery if you already know that
11:03:56 <alp> yeah, define: data RawJSON ; instance Accept RawJSON where ... ; instance MimeRender ByteString RawJSON where mimeRender _ bs = bs
11:04:01 <alp> modulo silly mistakes
11:04:14 <alp> see https://haskell-servant.readthedocs.io/en/stable/tutorial/Server.html#the-truth-behind-json
11:04:16 <monochrom> I misread MimeRender as MindReader
11:04:30 <alp> monochrom, I wish we had that :-)
11:04:44 <alp> would be a lot simpler than our type level machinery
11:05:21 <Welkin> thanks alp
11:16:15 <dominik> Hi, I'm trying to run the haskell-opencv example programs, but after following the nix instructions and trying to execute `cabal run face-detect` (for example), I get a runtime error which complains about a missing libgtk2.0-dev
11:16:21 <dominik> does anyone know why this may be?
11:18:24 <geekosaur> that sounds like a debian package name
11:19:01 <dominik> yes, and I installed that package as well. But somehow inside the nix-shell it is not able to notice this
11:19:19 <geekosaur> because nix does its own thing with libraries
11:19:24 <geekosaur> it will not care about system libraries
11:21:17 <Heffalump> I have explicit stuff in my nix-shells to add paths to LD_LIBRARY_PATH to make them work with cabal under nix
11:21:48 <dominik> geekosaur: ah, ok.
11:21:57 * hackage hinterface 0.8.3 - Haskell / Erlang interoperability library  http://hackage.haskell.org/package/hinterface-0.8.3 (SvenHeyll)
11:22:09 <dominik> geekosaur: is there an easy way to also install that dependency inside the nix-shell ?
11:22:57 <geekosaur> I don't know offhand what nix calls it. and you may need to do what Heffalump said even if it's installed, because nix plays various games to make things use it instead of system libraries and those things don't always work in this case
11:23:08 <geekosaur> (nix is kinda horrifying under the covers)
11:23:32 <geekosaur> and when it works it works very nicely, but when it breaks it's a nightmare to debug and fix
11:24:15 <wroathe> The first time I installed something with nix it pulled down like 3 gigabytes of dependencies
11:24:22 <wroathe> Most of which were already on my system
11:24:36 <wroathe> I get the point of Nix, but for sanity's sake I'll pass
11:24:47 <dominik> Heffalump: you mean something like LD_LIBRARY_PATH=/usr/lib/x86_64-linux-gnu nix-shell ?
11:25:11 <Solonarv> to be fair, if it re-used the stuff on your system it'd run into trouble if the stuff on your system didn't actually match up properly
11:25:40 <wroathe> Solonarv: Yeah, avoiding that problem is the whole point of Nix, which I get
11:25:48 <geekosaur> yep, lots of things can be built ith different options and then they have different symbols. or different versions, etc.
11:25:58 <wroathe> But for my local dev environment I can suffer some imprecision
11:26:04 <geekosaur> so nix installs its own whole system and you need to install packages specific to its system
11:26:31 <Solonarv> wroathe: that's what got us cabal hell, or "cabal hell" :/
11:26:43 <geekosaur> I use nix but disable its .profile inclusion and activate it with an alias
11:26:55 <geekosaur> so it's in its own happy little sandbox
11:27:19 <geekosaur> and my prompt tells me when it's active
11:32:55 <Heffalump> dominik: I add the explicit path to the -dev libraries.
11:33:29 <Heffalump> something like LD_LIBRARY_PATH+=":${pkgs.zlib.out}"
11:33:52 <Heffalump> but within the .nix definition of the shell, not before I run nix_shell
11:36:25 <Denommus> hey
11:36:33 <Denommus> I'm learning/using lens and prisms
11:36:51 <Denommus> is there a shorter way to write the following expression? (at label . _Just . _BigConcreteBox .~ True) . (at label . _Just . _MetalBox .~ True)
11:37:33 <Denommus> I can't figure out a shortcut to "combine" _BigConcreteBox and _MetalBox, and the documentation is just so intimidatingly huge
11:37:51 <glguy> at label . _Just %~ (_BigConcreteBox .~ True) . (_MetalBox .~ True)
11:38:07 <Solonarv> ah, ninja'd - I was waffling on parentheses
11:38:17 <Denommus> glguy: thanks a lot!
11:38:23 <Denommus> I'll read about (%~)
11:38:50 <matheus23> Denommus: Its 'over', I think
11:38:58 * hackage hsakamai 0.1.0.0 - Akamai API(Edgegrid and Netstorage)  http://hackage.haskell.org/package/hsakamai-0.1.0.0 (junjihashimoto)
11:38:58 <Solonarv> Indeed it is.
11:39:37 <matheus23> Personally, I like to avoid the operators :'D
11:40:18 <Solonarv> for this kind of operation, probably a good idea
11:41:03 <Solonarv> over (at label . _Just) (set _BigConcreteBox True . set _MetalBox True)
11:41:26 <matheus23> over (at label . _Just) (set _BigConcreteBox True . set _MetalBox True)
11:41:27 <glguy> instead of (at label . _Just) you can write (ix label)
11:41:32 <matheus23> lol
11:41:46 <dominik> Heffalump: ok, thank you. I'll give it a try.
11:41:50 <matheus23> didn't see your message @Sol
11:42:02 <Solonarv> hah!
11:42:40 <monochrom> lens golfing and telescoping.
11:43:41 <Solonarv> :t (&~)
11:43:42 <lambdabot> s -> State s a -> s
11:43:42 <matheus23> Does anyone know to do parameterized tests in haskell idiomatically?
11:44:32 <matheus23> I'm currently using Hspec, but it doesn't seem to have a sense of multiple test inputs for a single test, at least upon first inspection of the API
11:45:16 <Denommus> glguy: oh, I didn't know about ix
11:45:21 <Denommus> so much stuff
11:45:36 <matheus23> currently I'm just running a loop through all my test data, but its not satisfactory, since it will just stop on the first failing test, since I'm doing it all in IO ()
11:45:38 <Solonarv> yeah, lens is big
11:45:48 <matheus23> IO (), a.k.a. Expectation, a.k.a. Assertion?
11:46:20 <matheus23> would the correct way be to loop through the test data inside my describe do block? So I generate all the "it ..." statements?
11:46:31 <phadej> :t for_
11:46:32 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
11:46:50 <phadej> there's nothing special in `it`
11:47:08 <matheus23> nothing special that allows parameterized tests?
11:47:16 <phadej> nothing special preventing them
11:47:43 <phadej> describe "case" $ for_ inputs $ \input -> it ("should do work " ++ show input) $ do ...
11:47:58 <matheus23> okay. I have only seen static describe and it structures yet, so It seemed like maybe it would confuse tooling
11:48:04 <matheus23> (in case I changed the inputs)
11:48:10 <matheus23> Alright, then I'll do that I guess
11:48:35 <phadej> well, filtering tests etc. is based on what you pass to describe/it as the strings; so you have to be careful
11:48:52 <phadej> but otherwise, you generate the test tree, and then machinery runs it
11:49:28 <phadej> nothing wrong to e.g. list files in the directory to look up what examples files there are
11:49:44 <matheus23> phadej: so would the idimatic way be to include, say, the input file name into the first parameter of 'it'?
11:49:54 <matheus23> or would that be a case for confusion for tools?
11:50:16 <phadej> no, i'd just use the input file name as the test case name
11:50:30 <matheus23> k perfect
11:50:36 <matheus23> thanks for your help :) phadej 
11:50:48 <phadej> but I don't use hspec, so *I'm* not confused when my test case names don't fit BDD's describe/it way of saying
11:56:08 <matheus23> phadej: What do you use for testing? What would you recommend? Also, the block side describe lives in the SpecWith () monad, so I guess I have to sprinkle in some liftIO's, if that's possible
12:00:08 <Welkin> UTC Time vs POSIX Time
12:00:59 <Welkin> one system uses Posix time, but the resolution is seconds, whereas haskell uses microseconds
12:03:55 <monochrom> UTCTime is the most ideal and operatable.
12:05:08 <monochrom> Like if I need to "add 4 days 3 hours 50 minutes 6 seconds" this is best done on UTCTime. There is no such support for POSIX time or Unix time or Windows time or...
12:06:40 <monochrom> The outside world uses POSIX time or worse, but this is because the outside world is inferior and short-sighted.  Still, we can cope, there is a reason why interface boundaries and conversions at such boundaries exist.
12:08:33 <monochrom> Both iOS and Windows Zune have had infinite loop bugs in their "add x days" code because they didn't use UTCTime.
12:09:04 <monochrom> (And because reinventing your own "add x days" algorithm is hard on their inferior time formats.)
12:14:26 <yayforj> nix users, how do you know what version of nixpkgs roughly corresponds to a specific resolver on stackage?
12:15:39 <infinisil> yayforj: Good question, I think previously I just searched through the git log for "lts-.*"
12:16:07 <infinisil> Oh actually that doesn't quite work
12:17:38 <infinisil> yayforj: Ah, search for "LTS Haskell"
12:17:39 <doyougnu> yayforj: I'm on NixOS. I honestly stay away from the haskellPackages and just use stack to manage my projects
12:18:20 <infinisil> I can't recommend stack at all for Nix.. I use cabal + haskellPackages whenever I can
12:18:21 * sm gasps
12:18:41 <yayforj> doyougnh: why tho?
12:19:00 <yayforj> doyougnu:
12:19:29 <doyougnu> it makes it easier for me to share the stack files with my colleagues who don't use nix at all but understand stack
12:20:10 <yayforj> fair enough
12:20:27 <doyougnu> yea it is easier then selling them on nix itself...i'll get them one day tho
12:21:29 <infinisil> yayforj: Did you see my answer?
12:21:55 <yayforj> infinisil: yes, i'm about to try
12:26:14 <yayforj> infinisil: thanks, that's what i wanted
12:27:27 <yayforj> another, possibly dumb question: how do you look up functions outside of the manual?
12:27:40 <infinisil> What functions, what manual
12:28:41 <yayforj> i just saw somewhere that there's a function `haskellPackages.callCabal2nix`
12:29:06 <yayforj> but there wasn't anything about it in nixpkgs manual
12:29:24 <infinisil> Ah yeah, for these you need to look at their definitions, there's usually comments above
12:30:12 <infinisil> yayforj: Well, unfortunately not very much in this case https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/haskell-modules/make-package-set.nix#L179
12:31:04 <philippD> How do I get a lens for a cell `a` in a grid represented by `[[a]]`?
12:31:31 <philippD> I tried composing `at x . at y` but there is a maybe in between that I can't get rid of
12:31:45 <Solonarv> put a _Just in between
12:31:58 * hackage ttl-hashtables 1.2.1.0 - Extends hashtables so that entries added can be expired after a TTL  http://hackage.haskell.org/package/ttl-hashtables-1.2.1.0 (erick)
12:32:08 <Solonarv> (the result won't be a full lens, which is intended and correct)
12:32:30 <philippD> thanks
12:32:31 <yayforj> infinisl: that's something, thanks
12:32:41 <yayforj> infinisil:
12:32:46 <c_wraith> in that case, why not just use ix x . ix y ?
12:33:27 <yayforj> infinisil: i guess there's no running away from the sources 
12:41:42 <mikail_> Hi, is anyone here who is familiar with the Eff Monad?
12:42:32 <Athas> Out of curiosity, does anyone know the rough total size of the GHC binary, if it were statically linked?
12:42:54 <Athas> The actual 'ghc' binary (not the shell script) is only 2.2MiB here, but it is dynamically linked to over a dozen Haskell .so's.
12:42:57 * hackage symmetric-properties 0.1.0.1 - Monoids for sameness and uniqueness.  http://hackage.haskell.org/package/symmetric-properties-0.1.0.1 (joelb)
12:43:01 <dminuoso> mikail_: Instead of asking whether someone is familiar with something, ask about your problem.
12:43:21 <dminuoso> mikail_: If someone is familiar and reads this channel, they will respond anyhow whether you ask or not. Asking whether someone is around is a fruitless excercise.
12:44:19 <mikail_> @dminuoso, ok, the issue is not with any Haskell implementations of the Eff Monad or any other Free(er) monads
12:44:19 <lambdabot> Unknown command, try @list
12:44:24 <Solonarv> Athas: 103M for me on windows, no giant mess of .dll's to be found
12:44:38 <Solonarv> Not sure how accurate that is, still
12:44:53 <mikail_> But rather a colleague of mine decided to use a Scala library which implemented the Eff Monad
12:45:22 <mikail_> The problem is that now the compile time for his program has increased to 280 seconds!
12:45:51 <mikail_> i read around Reddit and it appears these type of machinery have performance problems
12:45:56 <mikail_> Why is that?
12:46:14 <mikail_> What is it about them that cause them to blow up the compiler?
12:47:17 <geekosaur> every effect has to be represented by its own type, and so you have to carry around a bunch of extra types that constantly have to be solved
12:47:43 <Athas> Solonarv: thanks.  It doesn't sound too far off.  I have a compiler written in Haskell which is not as big as GHC, but is 62MiB all statically linked.
12:49:29 <Solonarv> Additionally, if it's anything like the Haskell side of things, the type-level code ends up treating linked lists as sets, which is not particularly efficient and causes asymptotic slowdown in the typechecker
12:49:30 <mikail_> @geekosaur, at compile time?
12:49:31 <lambdabot> Unknown command, try @list
12:49:34 <geekosaur> well, type constraint. which is even harder to solve, and ever more complex constraint mechanisms are why ghc is slower than it used to be as well
12:49:46 <geekosaur> when else?
12:49:51 <geekosaur> this isn't python
12:50:07 <mikail_> :laughing
12:50:29 <geekosaur> I mean, the whole point of these systems is to validate effects at compile time
12:50:53 <geekosaur> but that means carrying around, and solving, a lot of complex constraints at compile time
12:52:54 <philippD> Why can't I compose Control.Lens.Traversal.elemen with itself like this: `[[1]] ^. element 0 . element 0`?
12:53:19 <zachk> try ^? maybe? 
12:53:37 <philippD> huh
12:53:40 <philippD> that works
12:53:49 <iqubic> element is a prism.
12:53:53 <iqubic> Not a lens.
12:53:54 <zachk> some lens return stuff in a maybe 
12:54:11 <zachk> and if you want to chain them, I think you need ^? 
12:54:16 <iqubic> zachk: That's called a prism.
12:54:23 <zachk> oh :) 
12:54:37 <jle`> philippD: it helps to look at the error too
12:55:03 <geekosaur> in particular, "element" doesn't know if the list has that many elements (consider [] ^. element 0)
12:55:17 <jle`> iqubic: element is not a prism, it's am (indexed) traversal
12:55:17 <philippD> jle`: No instance of (Monoid Int) arising from the use of element
12:55:24 <aplainzetakind> I want to see if a command line argument is a directory or file, and if it's a directory do something with all the files (if not, with the given single file). What library should I turn to?
12:55:36 <iqubic> jle`:
12:55:37 <jle`> iqubic: prism doesn't mean 'return stuff in a maybe', actually
12:55:50 <iqubic> what does prism do than?
12:55:59 <jle`> a prism gives you review and preview
12:56:20 <jle`> a constructor and a (partial) deconstructor
12:56:40 <jle`> if you're using it with ^?, you're actually using a Fold
12:56:55 <jle`> you're using the "fold" aspect of something
12:57:04 <zachk> aplainzetakind, System.Directory perhaps , iirc 
12:57:06 <jle`> in this case 'elements n' gives you a traversal, which can be used as a fold
12:57:35 <philippD> Ok, maybe I'm going at this problem all wrong. I have a `newtype ChessBoard = CB [[(Color, Piece)]]` and I want to expose some lenslike thing to access and modify that board without the ability to change the dimensions.
12:57:50 <jle`> philippD: ah yeah. the error in this case isn't super helpful, but it comes up every time you do something similar like this.  what is happening is that if you use ^. on something that targets a variable number of items, it'll try tp mappend it all together
12:58:32 <jle`> element is one such item; it's a traversal that targets "0 or 1" items, so to give you a "single" result (which ^. gives), it tries to <>/mappend together everything it sees
12:59:01 <jle`> ^? is like ^. but instead of mappending together the results, it finds the first result it sees
12:59:01 <cjay-> It's unsettling that most Haskell jobs seem to be blockchain-related now :|. I wonder how much of it is just a facade to get the most funding and how much has a good chance of actually being useful.
12:59:13 <jle`> you can implement it in terms of ^., actually, with the 'First' newtype wrapper
12:59:25 <jle`> but yeah, that's where the "No instance of (Monoid Int)" comes from
12:59:35 <iqubic> Is haskell any good for blockchain work?
12:59:58 <jle`> iqubic: the reason why elements is not a prism is because it doesn't have a "review": it doesn't let you 'construct' containers, it only lets you descronstruct them
12:59:59 <aplainzetakind> zachk: Thanks.
13:00:13 <jle`> or well, that's one sign that it's not a prism
13:00:16 <zachk> aplainzetakind, you are welcome :) 
13:00:24 <cjay-> iqubic: I can see why it's attractive for modelling smart contract stuff
13:01:25 <iqubic> does elements not have a Choice instance?
13:01:31 <cjay-> iqubic: but I still wonder if there is anything involving blockchains that is actually useful and not a digital currency. Nothing convinced me so far.
13:01:41 <jle`> philippD: you can give ChessBoard an Ixed instance, then you can use 'ix' to get the "nth row"
13:02:05 <cjay-> iqubic: the whole idea of a "private blockchain" is kind of absurd
13:02:22 <jle`> philippD: ix :: Int -> Traversal' ChessBoard [(Color, Piece]
13:02:43 <jle`> philippD: or you could also have it ix on (Int, Int), so you can get inside the row and col
13:02:54 <jle`> philippD: ix :: (Int, Int) -> Traversal' ChessBoard (Color, Piece)
13:03:31 <jle`> philippD: but yeah, 'ix :: Int -> Traversal' [a] a`, so you can chain ix's to modify things inside nested lists and stuff
13:03:42 <philippD> jle`: I tried creating an Ixed instance where the index is a newtype around two indices like that but I couldn't get the actual ix implementation to compile
13:03:59 <jle`> :t [[1,2,3],[4,5,6],[7,8,9]] & ix 1 . ix 0 %~ negate
13:04:00 <lambdabot> Num a => [[a]]
13:04:06 <jle`> > [[1,2,3],[4,5,6],[7,8,9]] & ix 1 . ix 0 %~ negate
13:04:08 <lambdabot>  [[1,2,3],[-4,5,6],[7,8,9]]
13:04:12 <jle`> philippD: what was the error?
13:05:46 <jle`> it should be something like:
13:05:58 <jle`> type instance Index ChessBoard = (Int, Int)
13:06:14 <jle`> type instance IndexValue ChessBoard = (Color, Piece)
13:07:10 <zachk> cjay-, there is a company using a haskellish like language to do blockchains for stock transactions iirc, but I forget the name 
13:08:03 <philippD> jle`: now it works. Thank you
13:08:13 <jle`> nice :)
13:08:17 <infinisil> zachk: cjay-: Just today: https://www.reddit.com/r/haskell/comments/ag7pun/demo_of_plutus_playground_to_use_haskell_to_write/
13:08:26 <infinisil> So it's probably IOHK
13:08:49 <jle`> instance Ixed ChessBoard where ix (i, j) = _Wrapped . ix i . ix j
13:11:03 <philippD> jle` I used element in the definition of Ixed
13:16:35 <philippD> Ok, I now know what the problem was. The actual type of ChessBoard is `newtype ChessBoard = CB [[Maybe (Color, Piece)]]` and I wanted the Ixed instance to still have (Color, Piece) as its IxValue type
13:21:06 <Solonarv> slap a '. _Just' on the end and that should do it
13:23:00 <philippD> Solonarv: thanks. lens is really unintuitive
13:23:23 <Solonarv> philippD: I'd prefer to say it takes some getting used to
13:23:53 <koz_> It is its own thing, really.
13:23:59 <koz_> With its own conventions.
13:24:03 <Solonarv> it does all fit together fairly nicely once you understand how it's built up, but *I* certainly can't communicate that understanding
13:24:36 <Solonarv> (the monad tutorial fallacy probably applies to lens tutorials as well)
13:26:02 <hyperisco> I thought profunctor lenses made more sense
13:26:18 <koz_> hyperisco: Agreed.
13:26:28 <koz_> phadej's Glassery post is quite illuminating.
13:30:21 <Solonarv> I too agree; but the high-level view "an optic is a function which turns an operation on its target(s) into an operation on the whole data structure" applies equally well to the profunctor & van laarhoven encodings
13:35:57 * hackage VKHS 1.9.2 - Provides access to Vkontakte social network via public API  http://hackage.haskell.org/package/VKHS-1.9.2 (SergeyMironov)
14:16:57 * hackage ttl-hashtables 1.2.2.0 - Extends hashtables so that entries added can be expired after a TTL  http://hackage.haskell.org/package/ttl-hashtables-1.2.2.0 (erick)
14:21:34 <phadej> fwiw, I don't think that implementation is (VL or profunctors or ...) really matters to be productive user of optics library
14:21:52 <phadej> you need to know the implementation if it leaks (like in error messages of `lens`)
14:34:56 <Welkin> the haskell redis client returns results as ByteString in almost all cases
14:35:16 <Welkin> has anyone build an abstraction over it to automatically convert data to the correct types?
14:35:32 <Welkin> there are no To*/From* typeclasses for it like with postgresql-simple
14:35:36 <Welkin> which would be very helpful
14:36:08 <Welkin> I find myself constantly converting everything manually to ByteString
14:36:16 <Welkin> and from ByteString going the other way
14:38:43 <linduxed> ok, long post incoming
14:38:55 <linduxed> i've written a bit of haskell, but have never really read much about how the type system works on a deeper level, or how it differs compared to something like the type system of java
14:39:09 <linduxed> and by that i don't mean on such a simple level as the type system being more powerful, but whether there's large fundamental difference between a language like java and haskell
14:39:19 <Welkin> if you are gong to post an essay, don't copy-paste it here
14:39:20 <higherorder> Hi :) Quick and potentially silly question: for the applicative instance of the state monad, why do we first retrieve the function then the value wrapped in the  state? and not the opposite? as far as I cna tell both implementations would typecheck but would have a different behaviour
14:39:32 <Welkin> linduxed: ^
14:39:36 <linduxed> Welkin: only a few more lines, but sure, i'll use a pastebin
14:40:19 <johnw> applicative instance of the state monad... I imagine you mean: the Applicative instance of 'State s'
14:40:28 <c_wraith> higherorder, you might be making some unwarranted assumptions about how Haskell evaluation proceeds?
14:40:47 <higherorder> johnw: yes, of course; what I said was silly 
14:40:48 <Welkin> linduxed: the type system of haskell is completely different from that of java/c++/etc.
14:40:49 <higherorder> :p 
14:41:01 <Welkin> it is based on Hindley-Milner
14:41:06 <c_wraith> higherorder, oh. or you might be asking about order of state passing?
14:41:19 <sm> please continue, linduxed
14:41:37 <c_wraith> higherorder, in which case, sure, it works in the other direction too. see "reverse state" in various blog posts
14:41:53 <higherorder> @c_wraith well it seems to me that with the following type signature: "<*> : f (a -> b) -> f a -> f b", you can implement the function by either first piping the state to get "a -> b", then piping the state to get "a", and then get "b" from that. Or you could first pipe the state to get "a", then pipe the state to get "a -> b". 
14:41:54 <lambdabot> Unknown command, try @list
14:41:54 <johnw> and Hindley-Milner is a fairly effective way to infer the types of things based on how they're used
14:42:10 <linduxed> there we go
14:42:12 <linduxed> https://gist.github.com/linduxed/04ebfc73812c24f22dfd63e856b7e6c7
14:42:16 <higherorder> the implementation in the book I am reading first pipes the state to get "a -> b", then "a"
14:42:21 <linduxed> Welkin: i know that
14:42:27 <linduxed> please read the full thing
14:42:31 <Welkin> I don't know what the type system used by java et al is called, but it's not much better than habing no type system at all
14:42:57 <linduxed> sm: ^
14:43:12 <c_wraith> higherorder, but the direction State chooses is the one people expect. consider (modify (+1) <* get).
14:43:26 <linduxed> Welkin: that's not quite the question i was asking. would you like me to clarify?
14:43:35 <c_wraith> err. wrong direction. *> instead
14:43:39 <Welkin> I read your post
14:43:45 <linduxed> Welkin: oh, ok!
14:44:01 <Welkin> there is not fundamental difference at the compiler level
14:44:05 <phadej> Welkin: well, Java doesn't have inference at all
14:44:14 <Welkin> it all goes down to machine code (or vm byte code in the case of java)
14:44:17 <phadej> (or does it today?)
14:44:33 <higherorder> c_wraith: ah ok, thanks :) so both would lead to implementations that typecheck and follow the applicative/monad laws, but one wouldn't be intuitive/expected
14:44:37 <higherorder> that makes sense, thanks :)
14:44:42 <c_wraith> yep
14:44:43 <Welkin> haskell does have non-strict evaluation by default, however, and it does type inference as mentioned
14:44:57 <linduxed> hmmm, right
14:45:15 <c_wraith> and there are lots of blog posts about using the other direction for solving funny problems by reading future values. :)
14:45:24 <__monty__> The java type system uses nominal typing iirc.
14:45:26 <linduxed> i just realized that it might be worth rephrasing my question to the following:
14:45:35 <higherorder> c_wraith: I'll google that now that I know the name :-) "reverse state monad"
14:45:43 <phadej> __monty__: so does haskell: newtypes
14:46:18 <__monty__> And it gets a lot of flack but you can actually get pretty far with it. You'd be out of the realm of best practice but still.
14:46:29 <linduxed> "if one was to choose a target platform that already exhibits certain characteristics and overarching decisions (the BEAM being an example), would implementing a language like Haskell on top of it work without problems"
14:46:53 <Welkin> there is a version of haskell that compiles to jvm bytecode
14:46:56 <phadej> implementing is difficult, but not (only) because of it's type-inference
14:46:56 <Welkin> it's called Frege
14:47:12 <Welkin> I think you are talking about the runtime system
14:47:18 <Welkin> and confusing it with the compiler
14:47:26 <linduxed> yes, i just realized that
14:47:31 <__monty__> phadej: Yes, true. Guess that makes it not very useful as a distinguishing term...
14:47:37 <linduxed> the compilation probably is no big issue
14:47:51 <Welkin> compilation is just: Text -> Binary
14:47:53 <linduxed> but the runtime underneath might get problems
14:47:56 <linduxed> Welkin: yes
14:47:56 <Welkin> no big difference
14:48:11 <Welkin> haskell uses green threads
14:48:12 <linduxed> i think i needed to straighten that part out for myself
14:48:14 <Welkin> the jvm does not have that
14:48:17 <geekosaur> actually it's not that hard to get the jvm to work, although without tail calls it'd be slow.
14:48:29 <geekosaur> the real problem is that the reason you'd want to do so is for access to native libraries
14:48:30 <Welkin> and it has concurrency built-in
14:48:46 <geekosaur> and that will be a pain in the posterior no matter how you go about it
14:48:48 <__monty__> There's also eta if you want jvm haskell.
14:48:50 <higherorder> that's not specific to Haskell though. you are going to encounter this problem whenever you try to implement a language that has significant semantic differences from what a VM was initially built for I guess
14:48:50 <Welkin> jvm's was bolted on
14:49:10 <linduxed> my thinking was probably more geared toward "if one has already decided on the semantics of the language, can implementing it on a certain runtime have negative implications"
14:49:26 <linduxed> the answer to that should be "depending on the runtime in question, it can be negative"
14:49:30 <higherorder> linduxed: look at Purescript, for example. It runs in the javascript runtime
14:49:32 <linduxed> i'm guessing
14:49:45 <Welkin> Elm too
14:49:48 <linduxed> right
14:50:02 <Welkin> clojure runs on the jvm
14:50:10 <Welkin> it's a lisp-2
14:50:17 <Welkin> like Common Lisp
14:50:37 <linduxed> yeah i just realized: i've heard plenty of cases where scala and clojure people have lamented the lack of TCO on the JVM
14:50:40 <Welkin> but it also runs in the browser using clojurescript
14:51:08 <linduxed> so i think that answers the general question regarding whether the choice of runtime can have impact on the language one is implementing
14:51:09 <Welkin> the jvm uses OS threads, and has no TCO
14:51:15 <Welkin> those are at leats theb iggest issues with it
14:51:21 <Welkin> at least*
14:51:25 <linduxed> Welkin: right, this i've heard from certain users of the JVM
14:51:30 <higherorder> @linduxed I think you've to differentiate between performance impact and semantic impact
14:51:31 <lambdabot> Unknown command, try @list
14:51:44 <higherorder> the absence of TCO leads to a performance impact
14:51:50 <linduxed> higherorder: that's an important distinction, yes
14:52:06 <linduxed> i think that originally i was loosely thinking in the lines of semantic impact
14:52:07 <geekosaur> most people don't recall back when yhc was a thing, there was a third party backend for the jvm.
14:52:34 <linduxed> higherorder: performance seems like an obvious yes: it can have an impact
14:52:37 <higherorder> it's the same reason why processors have a ton of instructions. Technically you would only need a small number of instructions to perform whatever computation you want on them. But by offering specialised instructions for common computations you get speedups
14:52:44 <linduxed> i'm not sure about the sematic impact
14:53:29 <Welkin> green threads have a performance and semantic impact
14:53:41 <higherorder> @Welkin what is the semantic impact?
14:53:41 <lambdabot> Unknown command, try @list
14:53:47 <Welkin> in erlang (or haskell) you can spawn millions of threads/processes
14:54:27 <Welkin> you would never do that on the jvm
14:54:31 <Welkin> so you solve problems differently
14:54:36 <linduxed> hmmm, ok
14:54:41 <higherorder> Welkin: but that's a performance impact isn't it? Couldn't you implement you own runtime on top of the JVM with your own shitty slow implementation of green threads? It wouldn't be anywhere close to the performance of haskell/erlang but it would be semantically the same?
14:54:45 <Welkin> it's both
14:54:58 <linduxed> yeah, i was a bit surprised there
14:55:32 <higherorder> Welkin: do you mean that if you implemented your own threading system on top of the JVM the performance would be so bad that it owuld be unusable, and so in that sense it would have a "semantic impact"?
14:55:52 <linduxed> i'm thinking that if i do my million-concurrent-tasks and the runtime uses OS threads instead of green threads, that seems like an implementation detail, not a semantic thing... no?
14:55:56 <Welkin> no, I mean in the case where you don't implement your own hacked together solution, but use what you are given
14:56:02 <higherorder> ah, ok
14:56:24 <linduxed> hmmm, i think i get what you mean
14:56:26 <monochrom> If you avoid multithreading altogether, you write your program differently.
14:56:27 <Welkin> it's semantic because it changes the way you solve the problem
14:56:35 <higherorder> Welkin: fair.
14:56:45 <Welkin> laziness is another good example
14:57:27 <monochrom> Writing your own green thread system in Java is a bit crazy.
14:58:11 <Welkin> oh
14:58:20 <Welkin> there is another important difference I forgot to mention
14:58:22 <linduxed> aaah, i think i get what you mean: on the BEAM (erlang VM), because it uses the actor model, one wouldn't write a language that pretends that it uses shared memory for concurrency, because that would clash too much with the runtime. therefore the runtime incurs a semantic difference
14:58:28 <linduxed> was that what you meant?
14:58:33 <Welkin> the way that concurrency works in haskel land erlang is different
14:58:45 <Welkin> you don't use locks/mutextes/semaphores/whatever
14:59:11 <Welkin> in erlang, you pass messages and do not have access to the internal state of any process/thread. No shared state
14:59:24 <Welkin> in Haskell, it's similar
14:59:38 <linduxed> i know that much, i was just trying to verify what you meant by the runtime having an impact on the sematics
15:01:12 <linduxed> well anyway, thanks for your input, i think i've got a better understanding now!
15:05:27 <Welkin> is this still a good package for encoding String -> ByteString
15:05:28 <Welkin> https://hackage.haskell.org/package/utf8-string-1.0.1.1/docs/Data-ByteString-UTF8.html
15:05:41 <Welkin> it was last updated in 2015
15:06:14 <Welkin> the alternative is String -> Builder -> Lazy ByteString -> ByteString
15:10:25 <Welkin> or convert to Text then ByteString
15:12:51 <zachk> why not just use pack and unpack? 
15:12:57 * hackage prometheus-proc 0.1.0.0 - Export metrics from /proc for the current process  http://hackage.haskell.org/package/prometheus-proc-0.1.0.0 (OliverCharles)
15:15:20 <Welkin> zachk: those are unsafe
15:15:46 <Welkin> they truncate after one byte, meaning it destroys your utf8 data
15:16:29 <zachk> oh, does Text handle unicode correctly then?
15:16:43 <monochrom> Yes.
15:16:55 <Welkin> I thought you were talking about Data.ByteString.Char8.pack
15:17:02 <Welkin> Text is fine
15:17:03 <monochrom> String also does. It's Data.Bytestring.Char8.pack that doesn't.
15:43:11 <xsperry> > show (0.001 :: Double)
15:43:12 <lambdabot>  "1.0e-3"
15:44:00 <xsperry> other than printf with appropriate flag, is there a Double -> String function that will return "0.001" string for above input?
15:44:07 <geekosaur> > showFFloat (Just 3) (0.001 :: Double) ""
15:44:09 <lambdabot>  "0.001"
15:44:14 <geekosaur> (it's in Numeric)
15:44:20 <xsperry> nice, thanks
15:45:32 <xsperry> I'm writing a float show that accepts thousands and decimal separator characters. maybe Numeric already does that?
15:45:41 <higherorder> I am reading a book that refers to functions like "Int -> Maybe Int"  as "effectful". Could someone explain to me why this particularly terminology was chosen?
15:46:14 <phadej> the effect of Maybe is that you might not get any value at all
15:46:33 <phadej> Int -> IO Int might launch nuclear missiles
15:46:44 <phadej> google for "algebraic effects"
15:47:46 <phadej> (IO isn't algebraic, but that way you find better hits for right kinds of effects)
15:54:03 <xsperry> higherorder, probably to justify the notion that monads deal with effects
15:58:50 <dminuoso> higherorder: Think of `Maybe` as being able to throw an exception.
15:59:08 <dminuoso> higherorder: It can throw exactly one exception that carries as much information as `()`.
15:59:36 <higherorder> dminuoso: hmm I see. But then would you call any function with type `a -> f a` effectful?
15:59:42 <higherorder> or is it specific to Maybe?
16:00:03 <hpc> when f is a member of a type class that lets you think about things in that way, basically
16:05:17 <johnw> Maybe a =~ Either () a
16:06:46 <higherorder> hpc: ah ok, thanks :-) so you wouldn't describe `a -> Tree a` as an effectful function, right? And for `a -> [a]` I guess it would depend how you interpret it? Since `[a]` can be used to model `Maybe a`?
16:07:07 <hpc> higherorder: [a] can model nondeterminism as well
16:07:23 <hpc> > [(* 2), (+ 5)] <*> [10, 100]
16:07:25 <lambdabot>  [20,200,15,105]
16:07:51 <johnw> I think [a] can even model probability, if you can "count" a's
16:28:59 <xsperry> glancing through https://en.wikipedia.org/wiki/Decimal_separator , it appears that thousands and decimals separators are one character long, and "thousands" may not be thousands, but hundreds, etc. am I missing some exception?
16:38:08 <amx> that's already bad enough
17:50:16 <sm> xsperry: correct
17:51:14 <sm> best call them "digit groups", not thousands
18:17:57 * hackage rattletrap 6.1.0 - Parse and generate Rocket League replays.  http://hackage.haskell.org/package/rattletrap-6.1.0 (fozworth)
18:28:46 <xsperry> I am getting having issues with overlapping instances. seemingly equivalent function definitions, one compiles, the other doesn't. https://bpaste.net/show/8b4fbeffe923
18:28:51 <xsperry> s/getting//
18:30:00 <xsperry> added error message: https://bpaste.net/show/b7a984c9c76a
18:33:28 <electricityZZZZ> so my question isn't about haskell bit instead about idris and purescript, i hope that's OK... both idris and purescript have backends which can compile to C or C++. how does memory management work in those cases? does it roll in a GC? does it leak cycles?
18:33:45 <geekosaur> xsperry, you do like flirting with irreproducibility, don't you
18:34:36 <xsperry> geekosaur, seems like it! any ideas why this is happening?
18:35:24 <xsperry> (did you mean that you can't reproduce this error?)
18:37:13 <geekosaur> not your specific error, but what you are doing there is quite wrong
18:37:13 <geekosaur> because ((ANY CONTEXT HERE) => MyClass a) applies to all possible "a"s, and checks the context only afterward
18:37:14 <geekosaur> and there is no guarantee that all use sites will pick the instance you think they ought to
18:37:16 <geekosaur> in short, this does not work reliably
18:41:03 <xsperry> geekosaur I'm not quite sure what you mean by ((ANY CONTEXT HERE) => MyClass a). can you give me an example?
18:41:28 <xsperry> do you mean that (Show a, ShowNoQuotes a) => a ... showNoQuotes will call show, even for String? 
18:41:35 <xsperry> (if so, I think that is pretty expected)
18:42:18 <xsperry> I managed to fix this error with trial and error, I removed IncoherentInstances
18:55:04 <geekosaur> xsperry, instance Show a => ShowNoQuotes a where... is the same as instance ShowNoQuotes a where...
18:55:19 <geekosaur> the context is checked only after picking the instance
18:55:34 <geekosaur> it may work if everything is confined to a single source file. otherwise... all bets are off
18:56:11 <xsperry> even if other files do not define any other instances?
18:56:44 <geekosaur> if they *use* the instance, there is no guarantee they use the one you intended
18:57:24 <geekosaur> if they relay values back to your original source file, there is no guarantee that sues the instance you intended even though it's back in the same source file, because it may send a copy of the "wrong" dictionary alomg with it
18:58:08 <geekosaur> I don't know offhand why this is failing but it wouldn't surprise me if it's related
18:58:12 <geekosaur> because this is not expected to work
18:58:33 <robots-win> hey can haskell do warehouse robots
18:58:55 <xsperry> my error was caused by IncoherentInstances (which was initially recommended by ghci). once I removed it, it compiles and works as intended
18:59:15 <Welkin> the best name for an extension ever
18:59:39 <robots-win> anything like scylla done in haskell?
18:59:52 <robots-win> or can the happstack guys make acdstate work on 1000 nodes
18:59:53 <robots-win> ?
18:59:55 <geekosaur> I'll let someone else comment on ghc liking to suggest extensions it has no business recommending
19:00:13 <robots-win> I heard haskell for web like happstack kicks ass
19:00:43 <xsperry> geekosaur do you know off hand a case where "wrong" dictionary would be used?
19:00:47 <geekosaur> it's also prone to suggest you turn on typee level extensons if you aaccidentally use a value as a type, and then the error messages get really weird if you don't know what's going on
19:00:50 <Welkin> there are no databases in haskell, except for the in-memory store acid-state
19:01:04 <Welkin> but haskell does have some really good bindings to various databases
19:02:21 <Welkin> it should be possible to build a good database system in haskell, especially with all of the great storage backends around now: for example, rocksdb or kyoto cabinet
19:02:29 <Welkin> distributed database system*
19:02:48 <Welkin> look to erlang for inspiration (Riak, CouchDB)
19:02:50 <geekosaur> https://hackernoon.com/typeclass-instance-selection-fea1068920e6?gi=d582839c7277
19:03:49 <maerwald> Welkin: you mean pure haskell implementation of SQL?
19:04:00 <xsperry> geekosaur, thanks, I'll take a look
19:04:09 <Welkin> no, not sql
19:04:19 <Welkin> there is zero reason to write a sql database in haskell
19:04:30 <Welkin> distributed databases are a good option though
19:04:40 <Welkin> (nosql/key-value stores)
19:05:05 <geekosaur> welkin, I think the issue there is everyone else has already debugged their implementations so why bother going through that again
19:05:40 <Welkin> distributed databases tend to be written in either java or erlang from what I have seen
19:05:53 <Welkin> haskell fits great in that domain
19:06:09 <Welkin> some are also in go
19:07:17 <Welkin> nosql is still an area of active research
19:07:51 <Welkin> and encompasses key-value, document, wide-column, and graph databases (and many more variations each with different potential implementations)
19:08:17 <Welkin> sql is "done"
19:08:43 <Welkin> in fact postgres has been adding features to be more like nosql stores (like jsonb)
19:09:28 <robots-win> cassandra was repalced with scylla in c++ but I wonder if haskell can do better?
19:09:46 <Welkin> and of course, many nosql databases also include a sql-like query language and relational interface (often called multi-model datastores)
19:09:50 <robots-win> big dataabse acidstate cant handle
19:09:52 <robots-win> multi node
19:10:13 <Welkin> cassandra is supposedly being challenged by foundationdb lately
19:10:15 <c_wraith> acid-state has a lot of problems.  I like the idea, but the implementation has too many bugs
19:10:27 <Welkin> also riak is super nice
19:11:37 <geekosaur> xsperry, in any case, I don't know specifically what's going wrong there. Possibly MonoLocalBinds has been enabled by something, although the pragmas you have shouldn't IIRC.
19:12:38 <geekosaur> ...actually this seems the opposite of that. maybe the let binding is too polymorphic and then you get to trip the overlap failure mode
19:13:11 <xsperry> yes, was just about to say. with IncoherentInstances and MonoLocalBinds it compiles
19:33:32 <dmj`> robots-win: acid-state has a TCP remote backend
19:33:42 <dmj`> robots-win: and an experimental replication backend
19:34:19 <dmj`> The venerable acid-state has been powering hackage for years, a staple in the haskell community :) 
19:37:51 <Shockk> dmj`: oh, hackage runs on acid-state?
19:38:27 <dmj`> Shockk: of course
19:41:18 <dmj`> cabal info hackage-server | grep acid-state
19:43:30 <Shockk> I used acid-state a bit, years ago, while making an irc services replacement
19:43:36 <Shockk> never finished it :( I really should
19:59:30 <inkbottle> :pf round (r * fromIntegral d)
20:10:41 <iqubic> What is acid-state?
20:11:05 <iqubic> Also, didn't glguy once write an IRC client in Haskell?
20:11:13 <iqubic> What was that thing called again?
20:11:45 <nyc> My wild guess would be hirc.
20:11:48 <nyc> Or hsirc.
20:12:16 <iqubic> It's GLIRC.
20:12:29 <iqubic> He named it after himself.
20:12:49 <iqubic> https://github.com/glguy/irc-core
20:20:43 <nyc> That makes sense too.
20:22:13 <Welkin> iqubic: the state you are in when you take lsd
20:25:58 <dmj`> iqubic: It's a RAM-store database with snapshot + transaction persistence
20:26:19 <dmj`> iqubic: for arbitrary haskell data types
20:26:54 <Welkin> I've heard bad things about it in the past
20:29:11 <koz_> Welkin: What, acid-state?
20:30:21 <iqubic> dmj`: I'm not going to use it.
20:30:44 <dmj`> seems to work well for hackage
20:31:06 <dmj`> I've used it in the past, and it worked well for my needs, migrations included
20:37:38 * DigitalKiwi likes glirc
20:47:39 <DigitalKiwi> https://www.reddit.com/r/haskell/comments/a7jy8e/acid_state_anti_recommendation/
20:49:22 <nyc> I just installed glirc. I'll try it out.
20:52:00 <dmj`> DigitalKiwi: I've maintained and used acid-state long before that article was written and I have the opposite experience.
20:52:28 <dmj`> DigitalKiwi: "Migration errors are extremely difficult to identify and debug", acid-state + safecopy is better than any RDBMS migration experience I've ever had
20:53:27 <dmj`> DigitalKiwi: another issue is that Cardano, the company, I don't believe was using the Remote TCP backend, which is what you should only use
20:55:25 <DigitalKiwi> *shrug* I've been hearing bad (and tbf a few good) things about acid-state for longer than that thing has existed ;p
20:56:42 <DigitalKiwi> hell even hackage has had problems with it iirc? 
20:56:42 <dmj`> I'd turn off the parallel GC for starters and backup the state to s3. That alone avoids most issues in the article
20:57:04 <iqubic> is type level programming actually useful?
20:57:16 <dmj`> Hackage should be using the TCP backend imo
20:57:38 <dmj`> iqubic: yes
20:57:50 <Welkin> iqubic: look at servant to see an example of a real world use case
20:58:08 <iqubic> Welkin: I've never used savant.
20:58:25 <Welkin> you can encode a web api as a type
20:58:30 <dmj`> Ooo savant would have been a much better name :) 
20:58:37 <iqubic> how the hell?
20:58:42 <Welkin> which allows you to do some really precide validation and generation of client code, documentation, etc
20:58:51 <Welkin> precise*
20:59:15 <Welkin> you can generate javascript, jquery (and other) functions to query the api
21:00:08 <Welkin> even simple type-level programming is useful
21:00:13 <Welkin> like functional dependencies
21:02:00 <iqubic> IDK how Functional Deps are useful.
21:02:43 <nyc> I never really learned fundeps.
21:03:21 <koz_> iqubic: They're very useful when you have multi-parameter typeclasses for example.
21:03:32 <koz_> Because then you don't get serious typechecker confusion at them.
21:04:14 <Welkin> I wanted to use functional dependencies in elm, but of course it doesn't have them (or typeclasses)
21:04:24 <dmj`> iqubic: you should checkout the type level instant insanity article in the monad reader
21:04:31 <dmj`> @google type-level instant insanity
21:04:32 <lambdabot> http://blog.kfish.org/2007/09/type-level-instant-insanity.html
21:04:33 <lambdabot> Title: Conrad Parker: Type-Level Instant Insanity
21:04:44 <Welkin> so I had to use a single unified sum type and not get the extra correctness guarantees I would have otherwise
21:04:48 <dmj`> iqubic: I think most functionality of fun deps is subsumed by type families though
21:04:49 <Welkin> but in practice it wasn't an issue
21:04:51 <Welkin> would have been nice
21:06:09 <Welkin> dmj`: that link doesn't even load without javascript
21:06:12 <Welkin> for a *blog*
21:06:30 <Welkin> I thought blogger was server rendered
21:06:32 <Welkin> guess not anymore
21:07:47 <Welkin> haha
21:07:53 <Welkin> it links to a geocities site
21:07:57 <Welkin> which is dead (except in japan)
21:20:19 <iqubic> what are type families?
21:21:14 <nyc> iqubic: Don't feel bad. I didn't even know that n+k patterns had been removed.
21:21:49 <MarcelineVQ> iqubic: you need to start googling things when the question fits on one line
21:22:49 <Welkin> what is existence?
21:22:51 <MarcelineVQ> If you use up all your help credit on easy things you won't have any for the harder ones :>
21:23:33 <DigitalKiwi> :|
21:27:33 <nyc> As a Real Programmer (TM), I've managed to write Fortran in Haskell. Mostly I actually write a pure subset of Standard ML minus modules in Haskell, in all honesty, though.
21:33:45 <dmj`> iqubic: type families are like functions at the type level
21:44:42 <lightandlight[m]> Anyone here a backpack expert? I have an issue in my code that I couldn't reproduce with a minimal test example
21:44:52 <lightandlight[m]> I'm very confused
21:46:12 <nyc> Is backpack like a more full-powered module system for Haskell?
21:46:58 <lightandlight[m]> Yeah, a little bit more powerful
21:47:20 <lightandlight[m]> You can declare abstract modules, and create instantiations of them
21:47:21 <nyc> I was a fan of the fully functorial style for Standard ML.
21:47:38 <nyc> I should probably dive directly into Backpack.
21:48:14 <lightandlight[m]> I don't think it gets you all the way to ML functors, because you can't parameterize a Haskell module over a functor
21:48:52 <nyc> lightandlight[m]: That's unfortunate. =(
21:49:11 <lightandlight[m]> We have a fun little example here if you're interested https://qfpl.io/posts/backpack-for-initial-and-final-encodings/
21:49:37 <lightandlight[m]> Also Ed Yang has some blogs that are a good reference
21:51:07 <nyc> Nice, I'm all for it.
21:51:31 <iqubic> Well, that type-level Instant Insanity thing blows my mind.
21:51:50 <iqubic> It's not practical to write a whole application like that, is it?
21:54:10 <nyc> I can't find it.
22:04:48 <ezyang> lightandlight[m]: sure fire away 
22:07:20 <lightandlight[m]> Oh hi
22:07:29 <lightandlight[m]> The gist of it is that I get a really weird interface file error
22:08:16 <lightandlight[m]> I'll get the "minimal example that surprisingly worked" and then show my actual code
22:11:15 <suzu> is there some escape-hatch for getting access to the whole request in a servant handler?
22:12:57 * lightandlight[m] sent a long message:  < https://matrix.org/_matrix/media/v1/download/matrix.org/yuRqOfrTSnZTmBWHqqdLwZMa >
22:27:59 <suzu> afaict no
22:28:05 <suzu> guess i can work around it
22:36:41 <shay47> win 1
23:00:28 <ezyang> lightandlight[m]: Urk, sorry, back 
23:00:39 <ezyang> which version of GHC are you using? 
23:00:51 <ezyang> since you have the example I can also try to repro 
23:03:28 <Anna18> Best dating service GOGO! --->  http://gg.gg/cwne9
23:22:12 <maerwald> Nice
23:23:33 <lightandlight[m]> ezyang: 8.6.1
23:25:39 <lightandlight[m]> and cabal 2.4
23:35:25 <maerwald> 8.6.1 has a few serious bug afair, you should update
23:37:09 <lightandlight[m]> I'll try it with a later version then and see if that helps
23:37:35 <ezyang> +1 
23:40:28 <ezyang> I don't think we fixed any backpack bugs in 8.6.2 though 
