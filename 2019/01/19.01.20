00:03:35 <cocreature> if it has a stack.yaml, the answer to “how do I run tests” is probably "stack test"
00:14:44 <glguy> I'd support putting instructions for build and test in the read me, even if you're using stack or cabal to manage the process
00:16:12 <MarcelineVQ> you maverick madman rogue
00:29:39 <rektednoob> hi to be honest c++ vs Haskell who will win the battle ?
00:35:00 <AfC> The one with the best logo.
00:35:43 <rektednoob> AfC:  Can I have those logos I dint know them
00:45:09 <nshepperd> haskell excels at launchingMissiles, that's important in a battle
00:53:07 <Arahael> nshepperd: Haskell is inefficient.  With C++, you can do all the GC at the very end, once the missile has completed its task.
00:54:21 <slack1256> You guys say this as a joke, but after reading https://groups.google.com/forum/message/raw?msg=comp.lang.ada/E9bNCvDQ12k/1tezW24ZxdAJ it has gotten to real for me.
00:54:43 <MarcelineVQ> Though you can use haskell to write C that both not garbage collected and is better certified to make sure the missile doesn't have a pointer error and come right back at you
00:54:56 <koz_> Arahael: With Haskell, you still have a missile after you've launched it.
00:55:03 <koz_> (immutable structures woo)
00:56:26 <Arahael> koz_: That's probably a design flaw. ;)
00:57:47 <rektednoob> I am not understanding so haskell is used in NASA  and missiles ?
00:58:12 <rektednoob> my friend work in a MNC they dont do missiles and he told me he uses cand c++
00:58:19 <rektednoob> I am non programmer
00:59:27 <rektednoob> When I ask he also told haskell is good language to learn 
01:05:06 <energizer> rektednoob: what are your interests
01:06:03 <rektednoob> energizer: I am a bilology student and want to learn programming as I heard its good to learn
01:06:29 <Arahael> Many things are good to learn.
01:23:11 <[rg]> hey guys
01:24:35 <[rg]> super silly quesion but it it silly to represent shapes as adt's?
01:27:47 <Arahael> [rg]: Not at all.
01:29:53 <[rg]> ok, i think it makes sense for code organization
01:30:55 <[rg]> but im wondering if its worth it
01:30:58 <[rg]> probably
01:31:14 <[rg]> I want to get a complete ray tracer going
02:41:58 <the_2nd> is there a function similar to dropWhile, but not dropping the last occurence?
02:42:07 <the_2nd> or will I have to write it myself?
02:43:06 <[rg]> takewhile maybe
02:43:09 <[rg]> idk
02:47:58 * hackage hid-examples 0.4 - Examples to accompany the book "Haskell in Depth"  http://hackage.haskell.org/package/hid-examples-0.4 (bravit)
02:50:15 <marcx> I dont think there is one in base
02:51:24 <marcx> the_2nd ^^
02:55:11 <cocreature> break/span makes it pretty easy to build one
03:03:18 <gentauro> one of the things I like about Haskell is that if you work thoroughly, it's always pay off -> https://pastebin.com/vgi9RmHP
03:04:00 <gentauro> (-Werror and -Wall) = the best peer programmer you will ever meet
03:04:56 <[rg]> gentauro, eh whats that shapping up to be looking intersting
03:07:01 <gentauro> [rg]: I'm parsing FIFA FUT DB (EA Sports)
03:07:44 <gentauro> so I can help the spanish `PCFutbol` community to have the latest list of players
03:07:59 <gentauro> as of today, they are doing it "manually" and it makes me sad :'(
03:08:47 <[rg]> cool,nice to see someone help others, and with your programming skills to :)
03:09:55 <gentauro> [rg]: sometimes I install `wine` on my *nix box and play this almost 20 year old football manager game ;)
03:10:32 <gentauro> but when I read in the forum that they spend around 1 - 2 months on trying to update players ...
03:10:51 <gentauro> I think it could be done in a better way (they are still in the 2013 - 2014 season) :D
03:11:04 <[rg]> oh man
03:11:06 <[rg]> lol
03:11:29 <gentauro> when I'm done, they will probably be able to update the `obfuscated binaries` in less than 15 minuttes ;)
03:12:00 <gentauro> 2 months vs 15 minuttes (that's why we actually do programming amirite?)
03:12:18 <MarcelineVQ> especially if you compile to js and host the automatically updating roster as a git website
03:12:51 <gentauro> MarcelineVQ: I don't think I can make the outcome public. EA Sports will probably take it down
03:13:03 <MarcelineVQ> take down a list of players?
03:13:18 <gentauro> but the community using that data to tranform it to PCFutbols `propietary` binaries ... well that's another story ;)
03:13:41 <[rg]> good on ya
03:15:27 * hackage rob 0.0.3 - Simple projects generator  http://hackage.haskell.org/package/rob-0.0.3 (gianlucaguarini)
03:51:44 <the_2nd> why does my stack test build all executables in my .cabal even if it only depends on the lib? 
04:39:58 <pgiarrusso> the_2nd: ‘stack test’ is an alias for ‘stack build’ that enables tests as well
04:40:09 <pgiarrusso> (And that runs them) IIRC
04:40:36 <pgiarrusso> the_2nd: passing a specific target to it might work?
06:22:58 * hackage glabrous 1.0.1 - A template DSL library  http://hackage.haskell.org/package/glabrous-1.0.1 (MichelBoucey)
06:42:57 * hackage wuss 1.1.12 - Secure WebSocket (WSS) clients  http://hackage.haskell.org/package/wuss-1.1.12 (fozworth)
06:44:58 * hackage hakyll-images 0.4.0 - Hakyll utilities to work with images  http://hackage.haskell.org/package/hakyll-images-0.4.0 (LaurentRDC)
07:29:57 * hackage deriving-compat 0.5.3 - Backports of GHC deriving extensions  http://hackage.haskell.org/package/deriving-compat-0.5.3 (ryanglscott)
07:34:19 <ar1a> so im writing my first haskell project and i was wondering how i could loop over a string and add 0xFEE0 to every character
07:34:40 <LKoen> don't loop, use map
07:34:42 <merijn> ar1a: What does "add 0xFEE0 to a character" mean?
07:35:24 <ar1a> to like, the codepoint 
07:36:19 <merijn> You could use fromEnum/toEnum for Char but that's still kinda ugly
07:36:44 <jmcarthur> :t map (chr . (+0xFEE0) . ord)
07:36:46 <lambdabot> [Char] -> [Char]
07:38:52 <ar1a> jmcarthur: chr and ord are out of scope, where do ya grab them from?
07:39:28 <jmcarthur> Data.Char
07:39:53 <gentauro> :t ord
07:39:54 <lambdabot> Char -> Int
07:39:57 <gentauro> :t char
07:39:58 <lambdabot> Char -> Doc
07:40:01 <gentauro> :t chr
07:40:02 <lambdabot> Int -> Char
07:42:09 <dmwit> merijn also suggested the no-imports alternative.
07:42:22 <dmwit> fromEnum :: Char -> Int, toEnum :: Int -> Char
07:42:36 <gentauro> meh
07:49:21 <jmcarthur> There's also the lens way.
07:50:57 <merijn> Seems a bit excessive to drag in lens for this...
07:51:03 <jmcarthur> Oh no, I agree
07:51:11 <jmcarthur> Not just for this one thing
07:52:01 <jmcarthur> It's just that enum would handle that toEnum/fromEnum thing pretty nicely
08:00:28 * hackage fortytwo 1.0.5 - Interactive terminal prompt  http://hackage.haskell.org/package/fortytwo-1.0.5 (gianlucaguarini)
08:01:46 <ar1a> https://github.com/ar1a/fullwidth/blob/master/Main.hs thanks for the help jmcarthur 
08:01:59 <ar1a> my first haskell program :D
08:15:58 <sm> hurrah!
08:18:57 * hackage IPv6Addr 1.1.2 - Library to deal with IPv6 address text representations.  http://hackage.haskell.org/package/IPv6Addr-1.1.2 (MichelBoucey)
08:28:57 * hackage pinboard 0.10.1.4 - Access to the Pinboard API  http://hackage.haskell.org/package/pinboard-0.10.1.4 (jonschoning)
08:49:27 * hackage intricacy 0.7.2 - A game of competitive puzzle-design  http://hackage.haskell.org/package/intricacy-0.7.2 (mbays)
08:52:02 <umg> Hi @ all. This is my first message on IRC and I heard that I can find here lots of guys who already have experience in haskell. For a project that I would like to start in 2 months I want to learn haskell. Any advice regarding which databases are prefered to use in haskell? Maybe in the future erlang could also be part of the project and needs to use the same database. Thought that couchDB would be one candidate...
08:53:56 <__monty__> umg: The db situation in haskell isn't really settled. So if you only have two months I'd recommend sticking to something basic like postgresql-simple or persistent. Others might have better recommendations though.
08:56:33 <umg> Do you know when the situation will be clear regarding DB's in haskell?
08:56:58 <geekosaur> ...
08:58:19 <Lycurgus> es ist mir ganz klar
08:59:10 <geekosaur> this sounds vaguely like expecting a Python situation where Guido hands down the official Pronouncement of How One Does Things Here
08:59:45 <Clint> and within there are three different ways, all incompatible
09:00:13 <marcx> __monty__ what's unsettled about it?
09:00:25 <Lycurgus> on might as well ask "is the relation between ct and relational algebra clear?"
09:00:33 <Lycurgus> *one
09:03:27 <__monty__> marcx: There's just a lot of experimentation still going on, Tisch, Squeal, Selda for example. And, from discussions I've seen pass by, the "Just let me get my hands dirty, I don't care about theoretical elegance." approaches are somewhat second class.
09:03:53 <Lycurgus> a practical answer would be that capable people are not stopped from using, e.g. postgres
09:04:36 <__monty__> umg, marcx: That's not a bad thing, imo. Just means that if you're expecting haskell to have an awesome solution to dbs ready to go, you're somewhat SOL.
09:08:02 <marcx> I've used both SQLite and postgresql in haskell. didn't have any issues compared to other languages I've used, or find things harder to do
09:11:27 <umg> I really thought that there would have been already a "standard solution" ...
09:15:38 <monochrom> You're barking up the wrong tree.  For a standard database solution you go tell the database people "why don't you all unify yourselves already?!". The programming language people can't help you there.
09:16:10 <hpc> that intricacy package that hackagebot just linked is quite good
09:16:32 <monochrom> In fact they were unified a long time ago.  Then one day some charlatan went like "no more SQL, I'm going to invent MongoDB" and caused the split.
09:23:37 <__monty__> umg: Haskell doesn't standardize, on basically *anything*, "Avoid success at all costs." : )
09:24:40 <__monty__> marcx: I didn't say the basic bindings were bad. I said there's no one recommended solution and the interesting bindings haskell has to offer are still in flux.
09:29:13 <marcx> __monty__, what I'm getting at is that you've painted a pretty bleak picture of haskell's database situation, that can be pretty discouraging for someone who is just starting out.
09:30:32 <monochrom> This is just another half full half empty situation.
09:33:38 <maerwald> I didn't really get what is the problem
09:34:25 <maerwald> Or rather: what is really different to the situation in other languages
09:34:38 <geekosaur> marcx, not really
09:34:55 <geekosaur> unless you absolutely insist on The One True Answer being Handed Down from On High
09:35:09 <geekosaur> in which case, you;d best stick to those language ecosystems that work that wat
09:35:12 <geekosaur> *way
09:37:38 <geekosaur> of course, the "elegant theoretical way" bit is kinda the haskell ecosystem's version of the python hangup
09:37:48 <geekosaur> practically speaking, the *-simple packages are fairly good
09:38:23 <Lycurgus> has the "python hangup" been named?
09:39:19 <marcx> I've seen people use PostgreSQL, MySQL, MS SQL, Mongo, Berkeley and SQLite in python. I'm also not sure how the situation in haskell is different than in other languages
09:39:25 <Lycurgus> (in this chat context)
09:39:46 <__monty__> Lycurgus: "The One True Way" or more pythonically "There's Only One Way To Do It."
09:40:22 <Lycurgus> __monty__, ah
09:42:48 <marvin2> x = 1\n "There's Only 1 Way To Do It"   'There\'s Only 1 Way To Do It'   "There's Only {0} Way To Do It".format(x)   "There's Only {howmany} Way To Do It".format(howmany=x)   f"There's Only {x} Way To Do It"
09:43:59 <wroathe> It also seems like there's a lot of opportunity here for someone who wants to contribute something to open source
09:44:17 <umg> It was not my intention to start a basic discussion on databases ...sorry for that ^^
09:46:41 <umg> But the project that I want to start will hopefully evolve into a startup and lot's of Code. I already took a look on the D programming language and C++ (which is not really what I need). I just know that I don't want to do it in Java or python and that the performance of the database and the program needs to be pretty good. In other words, I want to use it for produciton...
09:47:04 <maerwald> umg: why do you want to choose haskell for production?
09:48:41 <umg> I had a long discussion yesterday with a good friend, which is pretty experienced in haskell and especially in C++ and in the end he suggested to take a look on haskell due to its performance and clean design.
09:48:54 <maerwald> That's very vague
09:48:55 <Mrbuck> maerwald:  what are good productive languages?
09:49:03 <maerwald> Mrbuck: depends on your needs
09:49:39 <wroathe> umg: If you're eyeing building a startup I really don't know that I'd choose Haskell. Finding good developers is already hard enough, and it's a rare thing for a developer to have experience with functional programming
09:50:00 <maerwald> 1. performance is not really a strong side of haskell, because reasoning about performance is hard, 2. clean design? no idea about that. GHC is more like a huge laboratory of type hacks =)
09:50:07 <maerwald> Haskells main strengths are elsewhere
09:50:20 <[exa]> umg: do you have any image of the expected database load and common complexity of queries?
09:51:14 <maerwald> So if you don't know why you want haskell for production exactly, you should first be sure. It's not a small commitment
09:51:36 <umg> [exa]: depends heavily on how the project evolves.
09:52:06 <umg> maerwald: Good point
09:52:45 <wroathe> Honestly I'd probably go Javascript or Ruby just to get the product out the front door, and then evolve the technology culture from there
09:53:45 <wroathe> Maybe C#, depending on how far along .NET Core is
09:54:43 <maerwald> Switching technology stack during startup phase is highly unlikely. It usually happens when the company is about to move out of startup phase and the codebase has devolved so much, that you MUST rewrite (and also should have a clearer picture of the business logic)
09:54:51 <[exa]> umg: then also language choice will depend on that. I'd advice for prototyping before investing into a new technology
09:55:15 <maerwald> The question is: how useful is haskell if you have constantly changing ideas, requirements and architecture? Add something here, something there, something here?
09:55:20 <maerwald> Haskell is not too great for that
09:55:33 <umg> To be honest I would like to start it from the beginning with a good design
09:55:43 <[exa]> well, it keeps the ideas more organized... :]
09:55:52 <umg> maerwald: Yes this is a really important point
09:56:14 <maerwald> haskells main strength is maintenance imo. If your project is not maintenance heavy, why bother with haskell? If you don't have a clear design in mind? Also don't bother
09:56:24 <wroathe> maerwald: You make it sound like I'm advocating a hard switch as soon as you start ramping up :P 
09:56:30 <[exa]> umg: if there was a clear way to start a startup with a good design, someone else would already do that. Prototyping is the part that gets you advantages.
09:56:50 <maerwald> But mind that in haskell, you usually commit to ideas very early and heavily
09:57:08 <maerwald> Some ideas are hard to "pull out" later
09:58:01 <maerwald> If you want something with little commitment, you go with an ecosystem that is very simplistic libraries and focuses on avoiding frameworks at all cost
09:58:25 <wroathe> It really doesn't matter how good your design is if you have to spend 50% of every work day explaining your genius to new team members :P
09:58:32 <umg> I think I have two options: 1. Find people who are interested and experienced enough to start such a project OR 2. just start with JS, C++, python etc and find people who are interested in joining and experienced enough to contribute
09:58:41 <maerwald> wroathe: yeah, bus factor is lower in haskell
09:59:10 <maerwald> And it's actually not that easy to find haskell developers, because most want remote
09:59:27 <maerwald> Which is not that great for startup imo
10:00:17 <[exa]> umg: btw c++ is a great prototyping language
10:00:51 <maerwald> But you will have a hard time finding a non-haskell language where you can have the same speed of adding features and ideas to an existing base design
10:00:53 <umg> maerwald: The problem is, that the landscape of programming languages is a bit chaotic and there is nothing you can really rely on
10:02:33 <__monty__> maerwald: I'd say haskell *is* really good at that. Since it sounds like refactoring. (Still reading backlog.)
10:02:47 <maerwald> __monty__: refactoring is one of the strengths yes
10:02:53 <maerwald> But not redoing your entire architecture
10:03:12 <maerwald> That is... actually hard
10:03:26 <wroathe> A languge choice isn't an entire architecture
10:03:58 * hackage rob 0.0.4 - Simple projects generator  http://hackage.haskell.org/package/rob-0.0.4 (gianlucaguarini)
10:04:03 <wroathe> My point is that you can start out with popular flavor of the month stuff to ramp your startup up to some funding, and then quietly convert key components of your architecture as you move forward
10:04:14 <wroathe> Especially with service oriented architectures
10:04:20 <wroathe> This becomes fairly trivial
10:04:23 <maerwald> wroathe: please, don't suggest microservices
10:04:39 <wroathe> I didn't say micro :P I just said service
10:04:41 <monochrom> I am not sure why maerwald says that, but I suppose Scheme is more flexible about changing your mind on types and C++ is more flexible about changing your mind about whether a function is pure or effectful, things like that.
10:05:32 <__monty__> maerwald: Why is it easier to redo your entire architecture in other languages?
10:06:11 <monochrom> Me, I actually don't miss those flexibilities, even when I have to change my mind about my design.  I would just still use Haskell and reduce design-redo to refactoring.
10:06:33 <maerwald> __monty__: because types are less expressive and your architecture doesn't follow e.g. an entire monad stack of effects for example, which... when you change it, breaks your *entire* codebase
10:07:08 <pgiarrusso> > 6:49 PM <maerwald> 2. clean design? no idea about that. GHC is more like a huge laboratory of type hacks =)
10:07:08 <marcx> better that it breaks at compile time, than at runtime, like in languages with less expressive types (or no types)
10:07:09 <lambdabot>  <hint>:1:92: error: parse error on input ‘of’
10:07:38 <maerwald> So you express more architectural components in types, you could say, than in other languages. That enforces more architecture, but makes it also more stiff
10:07:55 <pgiarrusso> maerwald: you’re the first to suggest such a thing O_O
10:08:33 <maerwald> pgiarrusso: it was an exaggaration ;)
10:09:04 <pgiarrusso> maerwald: well, I’ll say that haskell has among the most consistent designs out there
10:09:11 <pgiarrusso> whether it’s what you want, you can debate
10:09:14 <maerwald> pgiarrusso: except GHC is not haskell anymore :)
10:09:35 <pgiarrusso> I include that too
10:09:48 <pgiarrusso> “ImpredicativeQuantification” is the only real hack
10:09:58 <__monty__> umg: It basically comes down to this. Haskell may be a solid choice if you already have a haskell team. It's gonna be a stumbling block compared to whatever other language you already know if you don't have such a team.
10:10:05 <pgiarrusso> (you can debate on type classes and I’m sympathetic to some arguments)
10:10:09 <pgiarrusso> __monty__++
10:10:29 <maerwald> Oh... one more advantage of haskell
10:10:31 <__monty__> Two months is not enough to pick up a language and be fluent enough to found a unicorn.
10:10:35 <maerwald> you can safely hire junior devs
10:11:05 <pgiarrusso> maerwald: re “stiff”, that gets back to “refactoring’s easier/safer in Haskell”
10:11:05 <maerwald> Compare that to javascript where you never want to hire a junior dev, because he will break your entire codebase on a regular basis :)
10:11:09 <umg> Puhhh ...seems like this will be a hard journey
10:11:14 <maerwald> pgiarrusso: not always
10:11:24 <maerwald> depends on the scale of the refactoring
10:11:39 <wroathe> maerwald: That's not the reason people aren't hiring junior devs
10:12:07 <maerwald> wroathe: hm?
10:16:38 <umg> Anyone here from germany, fluent in haskell, C++, D or JS and interested in starting a company, writing good code and stepping into a new domain of information technology for physical products?
10:16:56 <maerwald> only 2 check out :P
10:17:13 <umg> :-D
10:17:38 <wroathe> The likelihood that they might break things is just one small facet of their lack of experience and, in general, mature teams will have safeguards that prevent this (code review processes, pair programming, automated testing, continuous integration) and encourage the junior developer to learn. The reality is that for technical fields experience and skill cause the most senior people to be the most 
10:17:44 <wroathe> economical decision in terms of return on investment
10:17:59 <maerwald> wroathe: you don't have a mature team in a startup and no processes either
10:18:02 <__monty__> maerwald: Then why are there no junior haskell dev jobs? : >
10:18:04 <maerwald> you're lucky if you even have testing
10:18:44 <wroathe> Most places would prefer to have the best and the brightest, but end up settling somewhere along the way for what they can get
10:18:50 <maerwald> __monty__: because companies seem to think they must hire PhDs
10:19:17 <maerwald> Then they end up with a weird codebase, full of PhD ideas no one can maintain anymore...
10:19:23 <maerwald> xD
10:20:12 <wroathe> umg: I think you should start out with APL
10:20:18 <wroathe> umg: And then evolve from there
10:20:31 <maerwald> __monty__: no, in my opinion, it's really the problem of remote working. You don't want a junior dev as remote
10:21:19 <umg> wroathe:  :-D
10:21:21 <maerwald> But if you say "hey, will you move to new york from <some small city in europe>"...chances are not high. NYC is scary city, so are most places where haskell is popular
10:22:17 <wroathe> Also, if you can't make time to do periodic code reviews in your startup you have no business hiring junior developers early on in the first place
10:23:11 <wroathe> But anyway, we're settled on APL for umg's startup
10:23:21 <umg> Ok I think haskell is maybe not the right choice
10:23:34 <maerwald> Always consider your bus factor
10:23:48 <maerwald> Are you berlin based?
10:24:14 <umg> I plan to start it close to Frankfurt or Bonn
10:24:21 <maerwald> Not a good choice
10:24:33 <maerwald> In Berlin you can get haskellers
10:24:44 <maerwald> Good startup scene too
10:25:32 <maerwald> There is a haskell meetup every 2 weeks, you could recruit straight from there :P
10:26:03 <umg> Too much startups in Berlin. Doesn't make sense to compete with them. Actually Frankfurt and Cologne/Bonn is pretty good to attracts talents that want to stay a bit longer than 6 months
10:26:28 <umg> As we learned now I'll start with APL ;-P
10:26:36 <maerwald> In Frankfurt I only know Java jobs. And most financial industry in germany does Java, afair
10:27:07 <umg> Yes that's right
10:27:58 <__monty__> umg: Why does the presence of other startups matter? Not like geographical distance makes a difference on the internet. (Well, not much of one at least.)
10:28:21 <hpc> competing for talent, not customers
10:28:26 <umg> yes
10:28:32 <hpc> unless you want to hire remote, but that's a whole other thing
10:29:59 <umg> My goal is not to hire remote and somehow deliver somthing half backed. I want a team who works physically together, bringing in their ideas and developing together. Remote is good when you already have some settled structures and want to compensate gaps in your own team
10:32:42 <wroathe> That would actually be a hilarious prank to play on a developer's first day. Create a couple of groups in your Gitlab/Github and clone down a bunch of random APL projects, and then make it clear in the orientation material that they'll need to ramp up quickly.
10:33:51 <umg> lol
10:34:14 <maerwald> No no... you copy paste some edward kmett code and show it to your new haskell junior devs on first day saying "this is what we got so far" xD
10:34:19 <hpc> i know what i am doing this week
10:34:58 <umg> hpc: start learing APL?
10:35:10 <hpc> impossible
10:35:56 <umg> nevertheless, thanks a lot guys! I think haskell is probably not the right choice...
10:36:41 <maerwald> it can be very nice for startup code, because you can ramp up features like a madman
10:36:47 <wroathe> "I found JSON data to be awkward to work with in Haskell so I invented lenses last night."
10:36:52 <maerwald> given a proper codebase
10:40:30 <wroathe> ASP.NET would actually be a reasonable choice if you want something more popular than Haskell with many of the same theoretical underpinnings
10:40:41 <wroathe> And later you could cheat and add some F# to the mix
10:41:37 <hpc> this is the first i have heard of asp being like haskell
10:41:57 <wroathe> C# I mean
10:42:03 <hpc> ah, heh
10:42:21 <wroathe> ASP.NET is what they're calling the whole web framework these days
10:42:24 <hpc> F# is pretty good though
10:42:33 <hpc> microsoft used ghc to prototype a number of F# features
10:42:44 <hpc> iirc
10:42:58 <maerwald> hpc: still has open effects no?
10:43:48 <hpc> open effects as in being impure?
10:43:59 <hpc> yeah, it doesn't have anything like IO
10:44:47 <wroathe> The other benefit there to hiring is that you could cast a wide net for both oop and functional folks
10:44:57 <wroathe> And mix and match different parts of your system
10:45:17 <wroathe> Over time the senior C# guys could be shown the light
10:45:48 <maerwald> Sounds like Java + Scala 
10:46:15 <maerwald> Scala in startup...uuuuh
10:46:56 <maerwald> now I will get nightmares...
10:49:01 <wroathe> But, maerwald, it's a scalable language
10:49:13 <wroathe> Think of the scale
10:51:24 <monochrom> You don't need scala for nightmare.  http://www.vex.net/~trebla/humour/Nightmare.java
10:52:29 <cocreature> monochrom: I’m never going to be able to sleep again …
10:54:37 <iqubic> monochrom: What the heck is that?
10:55:25 <monochrom> Translating Haskell "case x of {[] -> aaa; x:xs -> bbb}" to Java.
10:56:02 <iqubic> I see. But doing it in the worst possible way.
10:56:21 <monochrom> Who knows? Maybe it's the best possible.
10:56:25 <iqubic> That's abuse of execptions.
10:56:40 <iqubic> In no universe is that the best possible way.
10:56:53 <wroathe> Someone should build a Haskell -> Java compiler
10:57:01 <monochrom> Aw don't be so judgmental now...
10:57:05 <cocreature> wroathe: eta?
10:57:26 <monochrom> Like wtf counts as abuse?
10:57:51 <monochrom> https://www.drmaciver.com/2009/03/exceptions-for-control-flow-considered-perfectly-acceptable-thanks-very-much/
10:57:51 <wroathe> No, Haskell to Java, not Haskell to JVM Bytecode :P
10:58:04 <cocreature> ah fair point
10:58:12 <iqubic> Also, that main method is basically an infinite loop.
10:58:36 <monochrom> What's wrong with infinite loop?
10:58:54 <iqubic> It's the equivalent of `main = interact $ cycle $ map toLower`
10:59:06 <iqubic> I think. It's kinda hard to parse.
10:59:12 <monochrom> What's wrong with main = interact $ cycle $ map toLower ?
10:59:21 <iqubic> Nothing.
10:59:25 <monochrom> I mean apart from s/$/./
10:59:52 <iqubic> No, I think it's supposed to be $
10:59:56 <iqubic> not .
10:59:58 <DukeDrake> hi =)
11:00:03 <iqubic> But I might be wrong.
11:14:32 <DukeDrake> I'm still trying to understand lambda calculus .... but meanwhile I understand a thing or two
11:14:55 <DukeDrake> on the other hand there are still many things unclear xD
11:15:35 <DukeDrake> for example: would these two lambdas reduce/apply to the same normalisation? \x.\y. x y   and \x.\y. y x
11:15:54 <monochrom> No they are different.
11:16:50 <DukeDrake> ok. Could you insert some parenthesis maybe?
11:17:23 <monochrom> I don't understand the question.
11:18:15 <DukeDrake> ok, could you tell me how those terms will be reduced?
11:18:33 <monochrom> They are already reduced.
11:18:53 <DukeDrake> ok, could you tell me in which way they are different, then?
11:19:09 <monochrom> The same way "map f [1,2,3]" is not "f map [1,2,3]".
11:19:23 <DukeDrake> hm! 
11:21:17 <DukeDrake> that's still not helping :(
11:23:43 <monochrom> Why?
11:24:12 <__monty__> DukeDrake: They're \x -> (\y -> x y) and \x -> (\y -> y x) respectively. They're syntactically different ergo not the same.
11:24:39 <DukeDrake> __monty__: thanks for adding some parenthesis for me =D
11:24:44 <__monty__> *syntactically different module alpha-renaming.
11:24:52 <__monty__> *modulo
11:26:27 * hackage require 0.4.1 - Scrap your qualified import clutter  http://hackage.haskell.org/package/require-0.4.1 (NickSeagull)
11:27:30 <DukeDrake> cya
11:39:37 <umg> ok guys, so I think the conclusion is: that haskell is not good for a startup
11:39:48 <__monty__> umg: That's false.
11:40:24 <__monty__> It's *great* for a startup. It's just not great if you only have 2 months to learn it. Or already have a team of java experts.
11:40:29 <__monty__> Many possible reasons.
11:43:59 <umg> I think there are too much reasons which will make it hard for a startup to use haskell
11:44:38 <umg> I know C++ is also not perfect, but in the end it has an extensive amount of good libraries
11:44:56 <DigitalKiwi> ...so does haskell
11:44:58 * hackage hakyll-images 0.4.1 - Hakyll utilities to work with images  http://hackage.haskell.org/package/hakyll-images-0.4.1 (LaurentRDC)
11:45:56 <__monty__> umg: One advantage would be that the average haskeller is usually a better programmer than the average C++ programmer.
11:46:38 <umg> Yes this is more likely than the other way around
11:47:10 <monochrom> I am just a bit surprised at the idea of asking total strangers on life-changing advice and you don't even know how qualified they are on giving such advice.
11:47:57 <monochrom> Like if you asked Paul Graham I would say YES LISTEN TO HIM.
11:48:26 <monochrom> Ah yes it would also cost you money.
11:48:28 <__monty__> That's a very cynical world view though.
11:48:53 <monochrom> But that also tells you what kind of quality you can expect for free-of-charge advice.
11:49:43 <veverak> ask in any #<language> channel and they will tell you the language is good choice
11:49:46 <veverak> or, at least somebody
11:50:24 <__monty__> veverak: Except for here : )
11:50:29 <monochrom> __monty__, how many of us here have been involved in an enough number of startups --- in fact an enough number of failures and an enough number of successes so that we actually may be qualified to sum up some of the failure causes and success causes?
11:50:58 <veverak> __monty__: I think somebody said it no?
11:53:01 <__monty__> veverak: Well I did, kinda. But you should've seen the earlier discussion.
11:53:22 <veverak> than my statement is true
11:53:31 * veverak likes how well he can design statements
11:53:38 <veverak> </trolling>
11:54:40 <monochrom> veverak: Read my https://www.vex.net/~trebla/humour/tautologies.html if you like well-designed true statements!
11:55:42 <__monty__> monochrom: We might not have much authority in the matter. That doesn't mean our opinions aren't valid/useful.
11:55:53 <veverak> monochrom: nice!
11:56:58 * hackage tokenizer-monad 0.2.0.0 - An efficient and easy-to-use tokenizer monad.  http://hackage.haskell.org/package/tokenizer-monad-0.2.0.0 (implementation)
11:58:05 <monochrom> __monty__: Cut the double-negation. Could you tell me why such opinion is valid/useful?
11:58:51 <__monty__> monochrom: Because it's a best-effort guess from someone who probably knows haskell better than you do.
11:59:43 <monochrom> That sounds very positive, too positive to be realistic.  s/best/least-worst/ is more accurate.
12:01:34 <marcx> this channel is weird. one guy recommends haskell, and he gets pushback. maerwald spends half an hour crapping on haskell (as usual), and nobody says a thing
12:01:58 * hackage sendgrid-v3 0.1.2.0 - Sendgrid v3 API library  http://hackage.haskell.org/package/sendgrid-v3-0.1.2.0 (marcelbuesing)
12:02:22 <monochrom> marcx: What would you like me to have said, actually?
12:02:56 <__monty__> marcx: Not blindly recommending haskell to just anyone is a good thing imo.
12:03:04 <monochrom> As usual, maerwald gave reasons --- maybe good reasons or maybe just BS bluffing, what how would I have rebutted it?
12:04:18 <monochrom> s/what how/but how/
12:04:46 <__monty__> He didn't only crap on haskell btw. He was actually the strongest proponent of haskell for startups as I read the discussion.
12:07:16 <DigitalKiwi> ultimately the language choice is not the most important factor in a startup success. for one there's almost never only one language in a project anyway.
12:07:24 <veverak> exactly
12:07:34 <veverak> also, I always believed that it's more about what people I have at hand 
12:07:38 <veverak> (and what they know)
12:08:36 <DigitalKiwi> having a team that knows haskell and depending on the problem domain may have an arguable advantage, but having a team that is really good at something else and forcing them into a different language is less than ideal
12:09:42 <veverak> exactly
12:10:38 <__monty__> I think it's easier to advize on languages *not* to use than languages *to* use. For example, stay away from PHP : ) Also, javascript isn't the best idea for fintech core business, etc.
12:10:52 <veverak> __monty__: hmm, I agree with that
12:11:19 <DigitalKiwi> <facebook is typing>
12:11:24 * veverak likes and uses C++ a lot
12:11:42 <veverak> and yet I believe you want to stay away from it unless you have really good coders that know it well
12:12:58 <DigitalKiwi> there are plenty of "successful" startups that used the worst possible languages
12:13:12 <veverak> yup
12:13:23 <veverak> and somewhere I heard statistics, that the language has only minimal effect
12:13:38 <veverak> and based on longterm average stats, it's more abou the development model and how the project is made
12:14:31 <DigitalKiwi> plenty of companies have regretted their early decisions or at least suffered from it
12:14:37 <veverak> umg: "I" would pick language I am most familiar with and for which I can find plenty people
12:14:49 <__monty__> veverak: That doesn't account for haskell though, since it hasn't been used in industry long enough on a wide enough scale : >
12:15:17 <veverak> umg: than I would focus on development model and __coding standarts__
12:15:19 <veverak> :)
12:15:25 <geekosaur> and business apsects
12:15:29 <veverak> __monty__: I would like to see hard data for that :)
12:15:33 <DigitalKiwi> https://wiki.haskell.org/Haskell_in_industry
12:15:39 <DigitalKiwi> check out galois github ;p
12:15:51 <silver> veverak, you didn't provide data on your claims tho
12:16:01 <veverak> silver: yup
12:16:15 <veverak> => I can accept that people won't trust me
12:16:17 <veverak> :)
12:17:00 <veverak> __monty__: also, I personally believe that it's not about language, but the way you code in the language (which is much harder to do a bad way in haskell than others...) 
12:17:02 <__monty__> veverak: The hard data is the lack of data.
12:17:24 <veverak> (which is also a reason why my C++ resembles haskell a bit...)
12:18:18 <__monty__> veverak: There's also factors like most haskellers actually know multiple languages. So they're usually more experienced/accomplished developers. As opposed to for example javascript, which seems to be a first language for tons of people, even though I've never(?) met them.
12:18:32 <veverak> yup
12:18:35 <veverak> that's somethin I think too
12:18:55 <__monty__> Channel's pretty quiet outside this discussion but maybe we should move to -offtopic?
12:19:14 * veverak detaches
12:20:07 * veverak has other important stuff to do and should stop procrastrinating
12:20:28 <DukeDrake> could someone help me understand, what's going on here? (lambda g.lambda f.lambda x. g f (f x)) (lambda f.lambda x. x)
12:20:40 <DukeDrake> (\g.\f.\x. g f (f x)) (\f.\x. x)
12:21:01 <DigitalKiwi> i had django, yii, wordpress websites and objective-c and java mobile apps and a few random python scala and lua scripts all for one project...and that's not an all inclusive list :|
12:21:26 <hpc> replace "." with "->" and that's valid haskell
12:21:36 <hpc> you can see what type it has, and that'll get you most of the way to understanding it
12:21:49 <DukeDrake> errr ... yes... I don't know haskell at all yet :(
12:22:10 <geekosaur> or just start substituting
12:22:29 <DukeDrake> yeah ... >:>
12:24:42 <DukeDrake> geekosaur: I'm in a theoretical computer science course. We actually don't do haskell .... 
12:25:19 <geekosaur> I',m not talking Haskell. I'm talking about what your'e supposed to be learning here
12:25:22 <DukeDrake> I know quite a few languages yet, just tackling with the subtle syntax
12:25:55 <DukeDrake> so ... the left part are three nested functions, right?
12:26:04 <umg> veverak: Thank you for your opinion! I think you are right...in the end the success of C++ and C is due to its huge base of coders
12:26:09 <geekosaur> if you're learning lambda calculus, you should be learning how it works, and you should be applying that here
12:26:36 <DukeDrake> geekosaur: yes, that's what I'm trying to do. 
12:27:06 <ar1a> hey, so im writing a program that transforms text it gets in from getContents, but if there was arguments provided I was wanting to just grab all the arguments and use that as the input instead. https://github.com/ar1a/fullwidth/blob/master/Main.hs is what im working with so far, is there an easy way to do that?
12:27:11 <veverak> umg: well, I believe the modern C++ has things right for modern language
12:27:32 <umg> I'll take some days and think about it. Thanks to all of you for your input ;)  ...was a pretty nice discussion and will defenitely keep an eye on haskell ;)
12:27:38 <veverak> umg: however you do need one or two Phd. in it to use it well and I don't trust people who do not have it
12:29:57 <DigitalKiwi> wat
12:30:06 <umg> Yes but I think at least if you want to have somehow not the "wrong" starting point, it is better to start with something like C++ instead of any other language like Java or JS and afterwards trying to get things right
12:30:09 <__monty__> ar1a: For commandline arguments I recommend optparse-applicative.
12:30:29 <monochrom> ar1a: System.Environment has functions for command line arguments.  You can do a case analysis and use fullWidthifyText on the right string.
12:30:39 <__monty__> umg: I disagree, C++ is more likely to be the wrong language than java imo.
12:30:57 <veverak> umg: good C++ > good C > bad C > bad C++
12:31:06 <veverak> and given how bad C is bad, this tells something
12:31:16 <DigitalKiwi> "we'll just replace this later" never* happens (with few exceptions)
12:31:24 <veverak> DigitalKiwi: I do that a lot in my codebase1
12:31:26 <veverak> !
12:31:44 <umg> That's also the reason why I'm looking at D. Easy to adapt for C++ programmers, somehow a java style but still with a compiler and not something like a jvm
12:31:52 <__monty__> DukeDrake: Maybe stop trying to think about "nested functions" just try to think of ((\x. e1) e2) -> e1[e2/x]
12:32:09 <monochrom> veverak: Do you replace languages a lot in your codebase? >:)
12:32:27 <veverak> monochrom: I do that when I decided it's a good choice
12:32:39 <veverak> codebase was python/C++
12:32:43 <veverak> now it is haskell/C++
12:32:52 <monochrom> OK!
12:33:09 <DukeDrake> __monty__: which would mean "replace x with e2 in scope e1"?
12:33:17 <umg> What about starting just with python
12:33:18 <monochrom> I was going to say "but how often?" but if it's "hey I'm changing to Haskell!" then carry on!
12:33:23 <__monty__> umg: I *think* D is even more niche than haskell tbh. Not sure you should pick it if you have no experience with it.
12:33:35 <veverak> and I am like: language = needs performance ? C++ : Haskell
12:33:58 <veverak> umg: I would not do that
12:33:59 <__monty__> DukeDrake: In expression e1 yes.
12:34:03 <umg> why?
12:34:07 <veverak> umg: found out the comforts of strongly typed languages
12:34:08 <DukeDrake> expression, thanx
12:34:14 <veverak> umg: so I want to avoid python for big projects
12:34:21 <veverak> umg: with small things, it's easy to rewrite :)
12:35:09 <DukeDrake> which in this case would yield nothing, because the \x does not make use of variable x ?
12:35:11 <umg> Ok so no C++, no python, no java, no JS, for sure no matlab :-P , no C, ...so what :-D
12:35:18 <umg> Ahh and no D
12:35:19 <__monty__> DukeDrake: So, apply one step of that to your expression, then tell us so we can see if you understand or need more help.
12:35:30 <veverak> umg: "lesser evel"
12:35:33 <veverak> *evil
12:35:38 <__monty__> DukeDrake: Well, e1 is opaque, we don't know whether there's x's in it or not.
12:35:47 <DukeDrake> ;)
12:35:48 <ar1a> how do I get the [String] out of IO [String]?
12:35:56 <geekosaur> DukeDrake, https://gist.github.com/geekosaur/d4df269636f29bf78bb5f6b2fab8ed78
12:36:11 <DukeDrake> (\g -> \f -> \x ->  g f (f x)) (\f -> \x ->  x)   ==> \f -> \x ->  (\f -> \x ->  x) f (f x)
12:36:11 <geekosaur> ar1a, you don't, as such. although with do notation you can pretend you are, using <-
12:36:15 <__monty__> DukeDrake: I meant italic e subscript 1, not literally variable name "e1" or something.
12:36:19 <monochrom> ar1a: Like what you did to getContents.
12:36:19 <dmwit> ar1a: You don't. Instead, you take the function you were going to apply to your [String] and turn it into a function which can be applied to an IO [String].
12:36:45 <ar1a> see i was wanting to check the length of the list though
12:37:07 <DukeDrake> geekosaur: awesome, thanx
12:37:09 <DigitalKiwi> "what is your idea for this startup anyway?" "is an iphone app!" 
12:37:17 <umg> I go jogging ^^ ...will be back in 40 minutes. Maybe I'll stumble over a another language outside ;)  ...
12:37:22 <umg> No iPhone app
12:37:28 <ar1a> oh wait that seems to be working. well regardless i was wanting to `unwords` the list :P
12:37:38 <DukeDrake> .oO(I wonder why we didn't do the alpha conversion in class? ó.ò)
12:37:38 <dmwit> `fmap :: ([String] -> a) -> (IO [String] -> IO a)` and `(=<<) :: ([String] -> IO a) -> (IO [String] -> IO a)`.
12:38:03 <umg> At least you'll need an iPhone app and also an Android app, but for sure not in haskell ^^
12:38:47 <__monty__> I'd go with eta for android.
12:38:52 <__monty__> : >
12:39:11 <DigitalKiwi> there are some cases where you don't pick what language you use or some are obviously more well suited than others, without knowing more...this is all just worthless speculation
12:40:03 <DigitalKiwi> hell i've seen people that wanted an app but they really needed a spreadsheet
12:40:10 <monochrom> Most programmers who have time for IRC and online forums etc like to give worthless speculations and data-deficient opinions.
12:40:19 <DigitalKiwi> thought they wanted*
12:40:55 <umg> Will be back in 60 minutes...sorry
12:41:01 <__monty__> monochrom: You can drop the "who have time for IRC and online forums etc" part.
12:41:06 <ar1a> dmwit: not sure i follow
12:41:19 <monochrom> Yeah but I don't have data on those who don't have time! >:)
12:41:19 <DukeDrake> geekosaur: thanx, I thinnk I'm getting a hunch ^^
12:41:27 <DigitalKiwi> i see tons of people on irc that i know have jobs ;p and is the weekend
12:41:40 <dmwit> ar1a: You say you want to apply `length` to (I assume) `getArgs`.
12:41:43 <DigitalKiwi> hell most of them are on irc at work
12:41:54 <dmwit> ar1a: This doesn't work, because `length` requires a `[String]` but `getArgs` provides an `IO [String]`.
12:42:10 <ar1a> indeed... im thinking this might be an xy problem though 
12:42:13 <dmwit> ar1a: The obvious solution is to find a function that converts `IO [String]` to `[String]` to use in between. But the obvious solution doesn't work.
12:42:39 <dmwit> ar1a: The less obvious solution is to find a function that converts functions which take a `[String]` into functions which take an `IO [String]`, and use that to transform `length` before applying it to `getArgs`.
12:42:52 <dmwit> ar1a: It turns out this less obvious solution does work, and the function of interest here is `fmap`.
12:43:18 <monochrom> dmwit: ar1a has used do-notation and "input <- getContents" "putStrLn $ f input" successfully, so maybe build upon that knowledge.
12:43:22 <marvin2> ar1a, you can use do as well. do args <- getArgs; print (length args)
12:43:33 <dmwit> ar1a: `fmap :: ([String] -> Int) -> (IO [String] -> IO Int)`, so `fmap length :: IO [String] -> IO Int`. Now `fmap length` takes an `IO [String]` as an argument, so `getArgs` is a suitable argument.
12:43:55 <ar1a> https://ptpb.pw/FFuS, maybe theres a more idiomatic way, because i want to use the length in an if expression 
12:44:55 <dmwit> ar1a: Try writing `getInput` as a function of the `[String]` that `getArgs` would give you.
12:45:17 <dmwit> ar1a: e.g. getInput args = if length args > 0 then ... else ...
12:45:52 <dmwit> ar1a: Then you can apply `getInput` to `getArgs` using either `fmap` or `(=<<)`, depending on the return type of `getInput`.
12:46:45 <dmwit> ar1a: (Or you can continue with the do-notation stuff you have used elsewhere, as others have suggested. I'm expanding on my proposed way because you asked, but there is more than one good way to make progress and get better at this stuff.)
12:48:23 <dmwit> (Hm, actually, I guess these days people prefer the name `(<$>)` to `fmap`, and that would be pleasingly similar in usage to `(=<<)`. I'll have to update my standard spiel. =)
12:49:22 <ar1a> ah, i think im almost there!
12:49:35 <marvin2> ar1a, the whole point of IO is that you can't escape it. what you do instead, is you use fmap, do, etc, to create new IO actions
12:50:16 <ar1a> so i've got this right now, https://ptpb.pw/BAwb, now what i need to do is replace "test" with getContents
12:50:30 <ar1a> what i'm blocked on is getContents returns an IO String
12:51:03 <koz_> :t fmap
12:51:04 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:51:09 <koz_> :t fmap @IO
12:51:10 <lambdabot> error:
12:51:10 <lambdabot>     Pattern syntax in expression context: fmap@IO
12:51:10 <lambdabot>     Did you mean to enable TypeApplications?
12:51:17 <koz_> % :t fmap @IO
12:51:18 <yahb> koz_: (a -> b) -> IO a -> IO b
12:51:28 <koz_> ar1a: ^
12:51:57 <ar1a> koz_: i'm afraid i don't follow
12:51:58 * hackage email-validate 2.3.2.10 - Email address validation  http://hackage.haskell.org/package/email-validate-2.3.2.10 (GeorgePollard)
12:53:42 <marcx> ar1a, you want to apply fullWidthifyText to every element in a list?
12:54:02 <ar1a> marcx: no
12:54:46 <ar1a> https://github.com/ar1a/fullwidth/blob/master/Main.hs i started with this and i want to get input from args instead of stdin if args are provided marcx 
12:55:03 <monochrom> If there are command line arguments, obtain them and concatenate them into one single string; if not, obtain the string from stdin. Either way, apply fullWidthify and output the answer.
12:56:28 <ar1a> bingo, thanks
12:57:02 <dmwit> ar1a: You can lift the other branch into IO with pure. `pure :: [String] -> IO [String]`.
12:57:07 <_kwstas> Hello there! I'm using the prettyprinter package to export to a file a really complex data type. However now, I need to be able to export this datatype to more than one filetype (e.g. both xml and csv). What is the best way to approach this? I was thinking of having two separate modules that both would make the type instance of the Pretty typeclass. Do you think is this approach fine (i.e. to have two different implementation of the type
12:57:09 <marcx> ar1a, last code you pasted compiles, assuming fullWidthifyText itself has vlaid code
12:57:09 <_kwstas> class for the same datatype)? 
12:57:18 <dmwit> ar1a: In the style of my previous exposition...
12:57:44 <ar1a> marcx: the github? yeah i know that one works
12:57:50 <dmwit> ar1a: You have an `if`, and need both branches to have the same type. In one, you have a `[String]`, and in the other you have an `IO [String]`.
12:58:04 <marcx> https://ptpb.pw/BAwb <- this one. assuming test is defined (and is a String), and assuming that fullWidthifyText has valid definition
12:58:10 <dmwit> ar1a: The obvious solution is to find a function `IO [String] -> [String]` to strip the `IO` off one side. That solution doesn't work.
12:58:22 <ar1a> marcx: test is in quotes, but i fucked up the pasting lol
12:58:29 <koz_> _kwstas: I would suggest newtyping over the data type, and then defining Pretty on each one of the newtypes.
12:58:41 <dmwit> ar1a: The less obvious solution is to find a function `[String] -> IO [String]` to *add* `IO` to the other side of the `if`. This solution turns out to work, and `pure` is the function that does that.
12:58:46 <marcx> ar1a, ok, types match, though
12:59:05 <dmwit> ar1a: So, `if length args > 0 then pure (unwords args) else {- something with getContents that has type IO [String] -}`.
12:59:49 <ar1a> oh!
13:00:18 <ar1a> so i have to turn the unwords args to return IO String!
13:00:29 <dmwit> That would be one way to do it, yeah!
13:00:52 <dmwit> (Of course, then you won't be able to use `fmap` to apply `getInput` to `getArgs`; you'll have to switch to `(=<<)`. Just a heads up.)
13:01:01 <_kwstas> koz_: Unfortunately there is not a single datatype; there is the root datatype but it includes (directly or indirectly) around 60 other datatypes or newtypes :(
13:01:33 <koz_> _kwstas: I would then write a function that does whatever conversion you want into prettyprinter's 'is pretty thing' type.
13:02:04 <dmwit> _kwstas: For what it's worth, I have a very different recommendation than koz_. I'd have two separate classes, one for XML-ization and one for CSV-ization.
13:02:05 <marcx> ar1a, again, this compiles, so all you have to do add code in fullWidthifyText. http://dpaste.com/3DP4A39
13:02:12 <dmwit> _kwstas: And I wouldn't name *either* of them Pretty. =)
13:02:24 <dmwit> _kwstas: (I'd keep Pretty for vaguely human-readable output.)
13:02:26 <koz_> Something like 'toCSV :: Foo -> Doc ann', and 'toSomeOtherType :: Foo -> Doc ann'.
13:02:35 <ar1a> marcx:  im wanting to replace "test" with getContents
13:02:38 <koz_> dmwit: I wouldn't recommend using a pretty-printer to spew JSON either.
13:02:42 <marcx> ar1a, oh
13:02:44 <ar1a> dmwit: mind if i PM?
13:02:50 <koz_> But that's what _kwstas seems set on.
13:03:08 <dmwit> ar1a: I prefer answering in a public space. This lets other people step in if I have to turn my attention elsewhere.
13:03:19 <dmwit> ar1a: If you find this place a bit high-traffic, we could switch to #haskell-beginners.
13:03:24 <ar1a> yeah lets go there
13:03:31 <_kwstas> koz_, dmwit: The output format s neither xml or csv. It was just an example to make things clear
13:04:08 <dmwit> _kwstas: Anyway, having two different modules that give instances of the same class for the same type is not a sane way to develop Haskell.
13:04:19 <koz_> On that, dmwit and I are in agreement.
13:04:42 <koz_> This is one of the reasons why we have so many newtypes for various built-in types; it allows us to give multiple valid typeclass instances for them without getting into a huge muddle.
13:04:59 <koz_> This includes stuff like Down, Sum, ZipList, etc.
13:05:14 <_kwstas> dmwit:  I agree too. That's why I came to the IRC, as I knew that this is not the sane way of implementing the desired functionality :D
13:19:02 <lordcirth> As a beginner Haskell programmer, what IDE should I use? Currently I'm using neovim with haskell-vim
13:19:24 <koz_> lordcirth: Stay with what you're using.
13:19:25 <__monty__> lordcirth: Either that or emacs.
13:19:34 <koz_> (although I recommend ALE, with some tweaks)
13:19:37 <__monty__> lordcirth: Check out ghcid.
13:19:39 <koz_> (on Neovim)
13:19:55 <koz_> For what it's worth, I have never gotten ghcid to work properly.
13:19:58 <lordcirth> Asynchronous Lint Engine ?
13:20:09 <koz_> lordcirth: Yep. I can send you my config if you like.
13:20:14 <lordcirth> koz_, sure!
13:20:34 <__monty__> koz_: Really? It's pretty foolproof. Are you sure you're not confusing it with ghc-mod?
13:20:52 <koz_> __monty__: Sigh. I assure you I am not.
13:21:01 <koz_> I can also assure you that everything breaks for me and I find every bug with my face.
13:21:15 <koz_> I reported this, several times, it still doesn't work, and I can't be bothered chasing it up any more than I have already.
13:21:29 <__monty__> koz_: So what doesn't work about ghcid your-haskell-file.hs?
13:21:56 <koz_> I never said that didn't work. What doesn't work is the stuff inside Neovim. Or with Stack GHCs. Or literally a dozen other things.
13:22:08 <koz_> The fact that I can run it via raw CLI commands doesn't help me any.
13:22:15 <koz_> With ALE, and Neomake, I had zero such issues ever.
13:22:20 <koz_> But that's beside the point anyway.
13:22:26 <koz_> I'm one anecdotal data point.
13:22:28 <__monty__> WAT?
13:23:27 <__monty__> GHCId is very much a cli tool though. Just have another terminal window/tmux split with the ghcid command. It's made my haskell development so much better. Far better than linting.
13:25:16 <koz_> __monty__: To each their own.
13:25:28 <koz_> I prefer ALE together with HLint inside my Neovim.
13:25:34 <koz_> If ghcid works for you, great.
13:30:36 <__monty__> koz_: But linting is completely different from typechecking.
13:30:51 <__monty__> Or do you have neomake compile your project?
13:31:16 <koz_> __monty__: I have it run through GHC, yes. Which is one thing ALE can do.
13:31:18 <koz_> (among others)
13:31:51 <__monty__> Ime vim works terribly with multiline error messages. GHCId can also run your tests automatically when the code typechecks which is nice.
13:32:03 <koz_> __monty__: That has not been my experience with Neovim + ALE.
13:42:28 * hackage tokenizer-monad 0.2.1.0 - An efficient and easy-to-use tokenizer monad.  http://hackage.haskell.org/package/tokenizer-monad-0.2.1.0 (implementation)
14:05:56 <freedan42x> for example I have array [Right 9, Right 3, Left "7", Left "3"], how can I extract value? like [9, 3, "7", "3"]
14:06:50 <koz_> freedan42x: You can't have a list with two different types like that.
14:07:09 <freedan42x> koz_: [Either String Int]
14:07:10 <koz_> The best you could do would be smething like ([9, 3], ["7", "3"])
14:07:16 <geekosaur> ^
14:07:26 <koz_> freedan42x: [9, 3, "7", "3"] is _not_ of type [Either String Int].
14:07:29 <koz_> Your original list was.
14:07:33 <koz_> Or array, whatever, same diff.
14:08:16 <freedan42x> I want from [Right ..., Left ...] recieve an array with integers only
14:08:32 <marcx> that is easy.. take all Rights
14:08:56 <geekosaur> [ x | Right x <- xs ]
14:09:04 <freedan42x> same with Left?
14:09:12 <infinisil> :t lefts
14:09:13 <lambdabot> [Either a b] -> [a]
14:09:14 <koz_> geekosaur: Woah, that's some good use of list comprehensions you got there.
14:09:15 <infinisil> :t rights
14:09:16 <lambdabot> [Either a b] -> [b]
14:09:18 <geekosaur> yes. although if you want two lists like that, consider partitionEithers
14:09:25 <freedan42x> thx
14:09:31 <geekosaur> :t partitionEithers
14:09:32 <lambdabot> [Either a b] -> ([a], [b])
14:16:58 * hackage tidal 1.0.7 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-1.0.7 (AlexMcLean)
14:23:00 <zerocoding> dfdf
14:52:26 <iqubic> What I want is a Haskell -> C# transpiler.
14:55:25 <koz_> iqubic: Specifically C#, or just its runtime?
15:00:30 <Gurkenglas> do you mean a C# assignment -> Haskell assignment reduction?
15:03:45 <dmwit> What I want is immortal youth with a voluntary suicide switch and a source of free energy, but you do you I guess
15:04:36 <davean> dmwit: I'll take 5
15:09:28 * hackage propellor 5.6.1 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-5.6.1 (JoeyHess)
15:09:49 <Arahael> iqubic: I'd suggest Haskell -> F#
15:12:56 <monochrom> dmwit: I prefer a factory reset switch instead!
15:13:13 <DigitalKiwi> dmwit: escape bag. don't thank me later
15:13:40 <DigitalKiwi> 1/3 aint bad
15:16:49 <dmwit> What's an escape bag
15:17:07 <dmwit> Amazon makes it look pretty unrelated to my wishes.
15:19:36 <hpc> dmwit: it's a bag that can't be slashed open if you put sharp stuff in it
15:19:41 <hpc> dmwit: it can only be backslashed open
15:19:57 <dmwit> hpc++
15:21:03 <Arahael> @pl \x -> (sum x) / (length x)
15:21:03 <lambdabot> liftM2 (/) sum length
15:21:37 <monochrom> haha hpc 
15:28:58 * hackage glue-core 0.6.1 - Make better services and clients.  http://hackage.haskell.org/package/glue-core-0.6.1 (seanparsons)
15:29:58 * hackage glue-example 0.6.1, glue-ekg 0.6.1, glue-common 0.6.1 (seanparsons)
15:49:54 <iqubic> Arahael: I specifically want Haskell -> C# transpiler because I'm going to be doing some Unity programming and I want to use a functional language to do that.
15:50:47 <hpc> you may want to look at F# first
15:51:24 <iqubic> Why?
15:51:31 <iqubic> Can I use F# in unity?
15:51:54 <hpc> they are both .NET languages
15:52:26 <hpc> it's like using multiple JVM languages together, they can be mixed very easily
15:54:52 <iqubic> I see.
15:55:57 <koz_> iqubic: https://stackoverflow.com/a/47495959/2629787
15:56:01 <koz_> This may be of relevance to you.
15:58:39 <koz_> Arahael: Or, as the cool kids would do it nowadays, '(/) <$> sum <*> length'?
15:59:52 <koz_> Or not, lol.
16:00:00 <koz_> Disregard that, I'm off my game today.
16:01:04 <rain1> How would I implement Longest Common Subsequence?
16:01:06 <rain1> in haskell
16:01:55 <koz_> rain1: Can you implement a solution to longest common subsequence in any other language? I'm asking because I dunno if your problem is algorithm or implementation.
16:02:08 <rain1> I did it in C beforo
16:03:27 <dmwit> ttp://hackage.haskell.org/package/Diff-0.3.4/docs/Data-Algorithm-Diff.html shows how other excellent Haskellers would do it.
16:03:41 <dmwit> Hard to say how you would do it, of course, until you've done it. =)
16:04:43 <koz_> dmwit: Is Diff a isomorphic to These a a?
16:04:57 <dibblego> yes\
16:05:01 <koz_> Oh, cool.
16:05:32 <koz_> rain1: What's causing you trouble implementing this in Haskell then?
16:06:44 <rain1> I want to fill in a grid with information then trace backwards
16:07:04 <rain1> i don't know how i'd make a grid  and fill in its data
16:07:07 <dmwit> Lazy Arrays are great for that.
16:07:21 <koz_> rain1: Vector (Vector a) is possible for that.
16:07:21 <dmwit> (Because their construction can be made self-referential.)
16:07:37 <koz_> Or what dmwit says if you wanna mess with raw Arrays.
16:30:56 <oo_miguel> when I define my own function (as simple as mine=sort) without specifying a  signature, it seems that I can not use it with different types as the original function. Is this expected, and why does haskell not generate the most general signature for me?
16:33:15 <koz_> oo_miguel: Can you give an example of that?
16:35:09 <oo_miguel> http://paste.debian.net/1061644/
16:35:18 <oo_miguel> works only if i uncomment 4 or 5
16:35:49 <koz_> oo_miguel: And what error does GHC emit?
16:35:49 <oo_miguel> works also if I give an explicit mine::Ord a=>[a]->[a]
16:36:28 <oo_miguel>  No instance for (Num Char) arising from the literal ‘1’
16:36:29 <geekosaur> monomorphism restriction
16:36:30 <geekosaur> give it parameters
16:36:36 <oo_miguel> semmst the first usage bounds mine to Num
16:37:39 <oo_miguel> geekosaur: yeah , just checked it works with some bogus parameter
16:37:50 <oo_miguel> but I do not need any paramters
16:38:09 <geekosaur> or -XNoMonomorphismRestriction
16:38:09 <geekosaur> bascally, if your binding has no parameters, it tries really hard to lock it down to a single type
16:38:58 <koz_> Yeah, the dreaded monomorphism restriction is what I suspected, which is why I wanted an example.
16:39:00 <geekosaur> you must either disable the MR or give it parameters
16:39:06 <geekosaur> @where DMR
16:39:06 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
16:39:08 <koz_> geekosaur beat me to it, with his tiny T-rex hands.
16:39:55 <oo_miguel> geekosaur: koz_: I will read about the restriction, thank you for pointing me there. As a "workaround" I will simply provide the type
16:40:08 <dmwit> oo_miguel: https://stackoverflow.com/q/32496864/791604 is also a good resource
16:40:38 <oo_miguel> dmwit: thank you
16:40:43 <geekosaur> the idea is that, you generally expect 'foo = ...' to be shared and not recompute stuff unnecessarily
16:41:11 <geekosaur> but if it's a numeric expression, the most general type is probably polymorphic which defeats that sharing. this is especially noticeable if it's self-recursive
16:41:24 <geekosaur> so the haskell spec says to monomorphize such bindings
16:41:44 <geekosaur> and expects you to either explicitly provide parameters or specify a type signature if you don't want that
16:43:23 <geekosaur> (or if it were to go ahead and make it shared spearately per instantiation type, it'd use a lot more memory than you would expect
16:44:04 <oo_miguel> I accept it and will just live with this fact for now.. understaind how to prevent recalucation in different scenarios is somwhere next on my list anyway.
16:45:09 <oo_miguel> (because I often find myself in producing code that is much more clear,short and beautiful but a magnitude slower then what I get in C)
16:49:34 <marcx> oo_miguel, got an example?
16:49:51 <marcx> of a haskell code that is an order of magnitude slower than equivalent C code
16:51:10 <oo_miguel> marcx: not any, I can show you without shame ;)
16:52:04 <oo_miguel> but in general I am quite sure that my performance troubles result from stuff like precalculating
16:53:00 <oo_miguel> which in a traditional language I simply do once and put somewhere in memory, but in case of haskell I am yet unaware how it is handled in which case
16:54:34 <oo_miguel> imagine something like computuing the sum of factors of different high fibanocci numbers.. 
16:55:00 <oo_miguel> in my naive approaches I am afraid to end up in recomputing them every time from scratch
16:56:06 <wildtrees[m]> Might be how you are computing fibonaccis
16:56:27 <oo_miguel> fibonacci serves just an example here
16:56:51 <oo_miguel> could be prime numbers or anything else I precompute incrementally
16:57:09 <wildtrees[m]> Use a better method and save computations with a let expression
16:57:15 <edmundnoble> Once you get the hang of it, Haskell is great for this sort of thing
16:57:28 <edmundnoble> Not only is it good at precomputing things, it's good at only precomputing the things you need
16:57:31 <body> anyone using cabal ?
16:57:31 <DigitalKiwi> edmundnoble: =o
16:57:45 <edmundnoble> Allo kiwi
16:57:53 <DigitalKiwi> hi :3
17:00:15 <dmwit> body: Don't ask to ask, just ask. =)
17:04:02 <body> i'm trying to compile this xmonad in haskedll, and I'm getting this error, http://ix.io/1yPf can someone help me pls ?
17:05:44 <body> I'm trying to compile this xmonad in haskell, xmonad.hs -> http://ix.io/1yPd , error -> http://ix.io/1yPf
17:12:26 <wildtrees[m]> Do you have xmonad installed as a package and how are you compiling?
17:12:53 <body> xmonad --recompile wildtrees[m]
17:13:23 <geekosaur> wildtrees[m], its arch removing all the static libs, per usual
17:13:59 <geekosaur> sometimes I really want to just declare arch unsuppoted and point anyone who wants to use xmonad (or any other haskell package) to the arch wiki
17:14:11 <geekosaur> because you have to do everything differently on arch for it to work :/
17:15:38 <wildtrees[m]> I used xmonad just fine on arch but it was quite a few years ago
17:25:52 <ned> does anyone have thoughts on failing fast in haskell (as in https://en.wikipedia.org/wiki/Fail-fast: detect and report errors asap)? 
17:26:20 <ned> For example, let's say my program needs to look up a finite set of keys in some config or database. The values corresponding to the keys may not be used until much later in the program execution, but the program should check the keys exist in the config/database and report errors up-front during initialization, after which point ideally we'd ideally have a type that would permit lookups without the possibility of errors.
17:27:46 <ned> My first thought was just have a data structure like so: data MyLookup { valueForKey1 :: String, ... } and use strictness annotations to force the fields to be evaluated
17:28:04 <hpc> i don't remember specifically, but there's a way to type-check a query against an sql database at compile time
17:28:22 <hpc> and the queries are defined with combinators
17:28:27 <geekosaur> wildtrees[m], that may have been before arch ***ed up its haskell ecosystem
17:29:00 <ned> that's really interesting, but let's assume the config/database isn't known at compile time
17:29:03 <hpc> so if you wrote (select table @'["id", "name"]), it'd fail at compile time if those columns weren't in the table
17:29:53 <wildtrees[m]> I stopped using arch after it broke hard on an update
17:30:02 <hpc> wrt strictness, you don't want to tie when it fails to when the values are evaluated
17:30:14 <hpc> and you have to go well out of your way in order to do that anyway
17:30:37 <hpc> when you perform the query, it'll fail if an empty result is a failure in the api you use
17:30:58 <hpc> select * from table where key = "doesn't exist" returns an empty set in relational databases
17:31:11 <hpc> but maybe in a nosql api it's different
17:33:59 <ned> that's a good point, thanks, I appreciate the comment about decoupling evaluation from failure especially :D
17:51:58 * hackage influxdb 1.6.1.2 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-1.6.1.2 (MitsutoshiAoe)
18:05:58 * hackage simple-sendfile 0.2.28 - Cross platform library for the sendfile system call  http://hackage.haskell.org/package/simple-sendfile-0.2.28 (KazuYamamoto)
18:12:56 <jdawgz959> Hello
18:13:07 * dmwit waves vaguely
18:13:14 <koz_> jdawgz959: Privet!
18:13:22 * koz_ needs to learn greetings in more languages.
18:14:53 <mekeor> > putStrLn "hello world"
18:14:55 <lambdabot>  <IO ()>
18:15:03 <dmwit> % putStrLn "hello world"
18:15:03 <yahb> dmwit: hello world
18:15:46 <mekeor> yahb: what else can you do?
18:16:13 <leifmetcalf> > "hello"
18:16:16 <lambdabot>  "hello"
18:16:47 <mekeor> % "hello"
18:16:47 <yahb> mekeor: "hello"
18:17:08 <mekeor> yahb: return 0
18:17:13 <mekeor> % return 0
18:17:13 <yahb> mekeor: 0
18:17:33 <koz_> mekeor: If you wanna play with yahb, please do it in PM.
18:17:48 <leifmetcalf> yahb can do IO? How does that work?
18:19:59 <geekosaur> it runs in a sandbox
18:21:43 <mekeor> wow, you can even import modules and use them. cool!
18:24:24 <dmwit> yahb is a ghci instance, so you can do everything ghci can do.
18:27:28 * hackage clumpiness 0.17.0.1 - Calculate the clumpiness of leaf properties in a tree  http://hackage.haskell.org/package/clumpiness-0.17.0.1 (GregorySchwartz)
18:32:58 * hackage clumpiness 0.17.0.2 - Calculate the clumpiness of leaf properties in a tree  http://hackage.haskell.org/package/clumpiness-0.17.0.2 (GregorySchwartz)
18:33:58 * hackage find-clumpiness 0.2.3.2 - Find the clumpiness of labels in a tree  http://hackage.haskell.org/package/find-clumpiness-0.2.3.2 (GregorySchwartz)
18:34:57 * hackage spectral-clustering 0.2.1.3 - Library for spectral clustering.  http://hackage.haskell.org/package/spectral-clustering-0.2.1.3 (GregorySchwartz)
18:35:58 * hackage modularity 0.2.0.4 - Find the modularity of a network.  http://hackage.haskell.org/package/modularity-0.2.0.4 (GregorySchwartz)
18:37:27 * hackage hierarchical-spectral-clustering 0.2.1.1 - Hierarchical spectral clustering of a graph.  http://hackage.haskell.org/package/hierarchical-spectral-clustering-0.2.1.1 (GregorySchwartz)
18:38:28 * hackage birch-beer 0.1.0.1 - Plot a colorful tree.  http://hackage.haskell.org/package/birch-beer-0.1.0.1 (GregorySchwartz)
18:39:28 * hackage too-many-cells 0.1.0.1 - Cluster single cells and analyze cell clade relationships.  http://hackage.haskell.org/package/too-many-cells-0.1.0.1 (GregorySchwartz)
19:06:20 <___Alisa2> Hi! Who want to see my nudes? -- http://love1002.com
19:11:58 <koz_> Is there a prewritten equivalent of fst for 3-tuples?
19:12:33 <jackdk> if you're willing to eat the dependency footprint of lens: `view _1`
19:12:40 <koz_> jackdk: Lol.
19:12:52 <MarcelineVQ> or a smaller dependency, maybe from 'extras'
19:13:26 <MarcelineVQ> oh 'extra'
19:13:31 <koz_> MarcelineVQ: Yeah, fst3 seems to fit the trick. Thanks!
19:13:41 <koz_> s/trick/bill/
19:13:51 <MarcelineVQ> there is something else that fits the trick without a dep tho :>
19:13:53 <koz_> I keep cross-wiring different turns of phrase.
19:13:58 <koz_> MarcelineVQ: ??
19:14:28 <MarcelineVQ> :t (\(a,_,_) -> a)
19:14:29 <lambdabot> (a, b, c) -> a
19:15:20 <koz_> MarcelineVQ: Yeah, I know _that_ works, lol.
19:20:08 <pdxleif> Is there a way with cabal new-build to pull packages from somewhere other than hackage?
19:21:05 <pdxleif> There's some unmaintained stuff on hackage, so I've been maintaining local forks. I can have them be "local packages", but they seem to get rebuilt every time. Also, I want them "global" for any other thing that may use those libs.
19:21:34 <pdxleif> Like if I could get them in the ~/.cabal/store somehow...
19:23:16 <sclv> pdxleif: you  can pull from git using cabal.project files
19:23:16 <pdxleif> I guess there's the "source-repository-package" option - I could try that.
19:23:21 <sclv> or add a  local package repo
19:23:42 <koz_> https://cabal.readthedocs.io/en/latest/nix-local-build.html#specifying-packages-from-remote-version-control-locations
19:23:48 <koz_> I can _never_ find that thing.
19:24:08 <maerwald> nix-local-build is also a confusing naming :)
19:24:56 <sclv> https://www.haskell.org/cabal/users-guide/installing-packages.html#repository-specification for local repos
19:25:06 <pdxleif> Thanks!
19:25:27 <sclv> using hackage-repo-tool to manage local secure repos is not very ergonomic yet iirc
19:25:34 <sclv> it could use some love and walkthroughs
19:35:28 * hackage dbus 1.2.2 - A client library for the D-Bus IPC system.  http://hackage.haskell.org/package/dbus-1.2.2 (blaze)
19:37:28 * hackage dbus 1.2.3 - A client library for the D-Bus IPC system.  http://hackage.haskell.org/package/dbus-1.2.3 (blaze)
20:44:35 <maerwald> is there an idiomatic way to compare two values of a product type minus a few records?
20:46:22 <maerwald> I guess I could just use record update syntax and overwrite those I don't care about with a dummy value
20:46:37 <maerwald> but that's a little bit obfuscated
20:53:23 <doyougnu> maerwald: why not just pull the values out of the record and compare?
20:54:27 <maerwald> verbosity
20:54:31 <doyougnu> or are you looking for something more like: compare `on`?
20:54:32 <maerwald> lots of code
20:54:56 <maerwald> maybe
21:05:48 <Arahael> maerwald: A lens, perhaps?
21:15:16 <jdawgz959> Disclaimer: started learning Haskell today. How do I write a function 'showAreaOfCircle' which, given the radius of a circle, calculates the area of the circle i.e. showAreaOfCircle 12.3 => "The area is 475.29..". My main problem was with the function signature.
21:16:56 <edmundnoble> Have you considered not writing a signature?
21:17:06 <edmundnoble> You can ask GHCi what the signature *could* be, after writing the function first
21:17:53 <jdawgz959> Thanks, that worked!
21:18:12 <edmundnoble> Great :) use `:t f` to find the type of `f` from within GHCi
21:18:28 <jdawgz959> I got it to generate the signature for me. Now I know how I should of written it
21:19:50 <jdawgz959> Thanks mate. I appreciate it
21:20:15 <ion> You can also write _ as the signature of part of one and GHC will give you a message telling what it thinks that part should be.
21:23:37 <jdawgz959> show my signature ended up being: showAreaOfCircle :: (Floating a, Show a) => a -> String. I am confused why I need to specify Floating a though - wouldn't Floating be a subset of Show and therefore I wouldn't need to write Floating a?
21:23:53 <iqubic> No.
21:24:53 <ion> Floating implies Fractiona, Fractional implies Num, Num implies no other class. Show implies no other class.
21:25:01 <iqubic> If you write only Show a, then someone could pass in [[Bool]] to your function, which might screw you up.
21:26:52 <jdawgz959> iqubic - that makes sense to me. Thanks.
21:28:14 <ion> With the "Show a" constraint, all your function gains access to is "show" (and a couple of other similar functions) on the type "a". It will not give you any arithmetic operations.
21:30:06 <Silk_> World's dumbest Lens question: I have a `Getter a [b]` and a `Getter b c`, how can I compose those to get a `Getter a [c]`?
21:30:23 <glguy> No, but you can get such a Fold
21:30:30 <jdawgz959> ion - Thanks
21:30:47 <glguy> Oh, I misunderstood the question
21:30:51 <wildtrees[m]> You shouldnt return a string just some num so you can compose your radius function with other numeric functions
21:34:25 <jdawgz959> wildtrees[m] - thanks, I agree. I had something similar (didn't return a string) until I couldnt get it to work (composed with show) and I simplified it down to one function. I am just going through some examples to check my understanding. Its not code I am going to reuse. Cheers though :)
21:35:16 <glguy> Silk_: The only way that comes to mind is to build a new one like: \x y -> to (map (view y) . view x)
21:35:53 <Silk_> Hmm, disappointing, but thanks :)
21:44:51 <glguy> Silk_: In general Getters aren't very useful. It's often better just to have to plain functions than to define them. Once you need a Getter at some point you can use 'to' at the last moment
22:02:49 <tst_> Is there a way to control the order of haddock generated modules on the package landing page? It seems it is alphabetical with no user control?
22:15:12 <cocreature> tst_: afaik you can’t control the order
22:16:56 <dminuoso> The documentation does not give a hint as to how you could.
22:20:14 <dminuoso> Speaking of Haddock, why would an imported identifier `MonadUnliftIO` not be hyperlinked in haddock? What possible reasons are there?
22:27:38 <Lears> Usually that means haddocks aren't available for the module its imported from. If you look at the logs from the haddock build you might see something more specific, though I don't think I've seen more than "could not find link destinations for:".
22:30:24 <tst_> cocreature: thanks. I couldn't find anything either. Should this be a haddock feature request, or is there something fundamental about alphabetical order?
22:30:44 <dminuoso> tst_: It should be a haddock feature request.
22:31:12 <dminuoso> Not quite sure how you would even control it.
22:31:55 <tst_> dminuoso: I'm thinking if you have a cabal file and you listed your exported modules in a certain order, that should be respected. Would that not be sufficient?
22:32:47 <tst_> dminuoso: exported-modules: I mean "exposed modules" section of the .cabal file
22:33:37 <dminuoso> tst_: Perhaps.
22:35:40 <cocreature> I’m not sure the landing page is even generated by haddock. I think it might be some hackage-specific thing that is generated based on the available haddocks
22:36:26 <cocreature> which is also why this might not be as easy to implement as it sounds
22:37:00 <dminuoso> cocreature: Pretty sure it is.
22:37:00 <dminuoso> cocreature: If you `cabal new-haddock` some project and open the generated file, you'll see the same landing page.
22:37:48 <dminuoso> cocreature: Why do you think it might be harder? I dont presume to know enough to argue the opposite, just curious about your thoughts.
22:41:58 * hackage tcp-streams 1.0.1.1 - One stop solution for tcp client and server with tls support.  http://hackage.haskell.org/package/tcp-streams-1.0.1.1 (winterland)
22:49:41 <cocreature> dminuoso: I don’t think that is true, you get the index with cabal new-haddock but not the landing page that is shown on hackage
22:50:50 <cocreature> my suspicion is that the part of hackage generating the module listing probably doesn’t have a list of exposed modules handy atm
23:06:58 <dminuoso> cocreature: Huh?
23:07:23 <dminuoso> Oh!
23:07:47 <dminuoso> cocreature: I see what you mean.
