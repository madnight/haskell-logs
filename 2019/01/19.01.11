01:06:07 <bwe> https://github.com/jhb563/SpockExample/blob/master/src/Server.hs#L13 imports Data.Map as M. I still get a 'Not in scope: data constructor ‘M.Map’' error. => Where do I get Map from?
01:08:42 <pacak1> bwe: try Data.Map.Strict or Data.Map.Lazy ?
01:09:37 <lyxia> Lazy is reexported by Data.Map though
01:10:27 <pacak1> It should be. Maybe some more context on error messages will help.
01:10:34 <Lears> "/data/ constructor" is probably the relevant hint here. Sounds like you're trying to use a type as a value.
01:10:34 <lyxia> "Data constructor" is the keyword here
01:15:06 <bwe> lyxia: Verified.
01:25:25 <drb69> hi, can someone help me with stack? i did "stack install --resolver=lts-13.2 pandoc-crossref" but stack then tells me that "roman-numerals must match ==0.5.*, but the stack configuration has no specified version  (latest matching version is 0.5.1.5)"
01:26:35 <drb69> and a warning about pandoc version mismatch also appears but has been ignored due to my enabled setting allow-newer
01:27:28 <lyxia> I don't understand this obsession with allow-newer
01:27:40 <drb69> i can disable it if it helps#
01:29:11 <lyxia> it's enabling it that doesn't help in the first place. But anyway that's not the core problem here.
01:30:09 <lyxia> to stack install a package, its dependencies must be on Stackage, not only on Hackage, and this is saying roman-numerals is not on Stackage.
01:31:00 <drb69> ah, and that's why i get the advice to put something into stack.yaml, right?
01:31:30 <lyxia> yes
01:34:21 <lyxia> You should also set the resolver in the stack.yaml so you don't need to pass it on the command line
01:34:35 <drb69> ok, got it, but concerning my obsession ;-) with allow-newer: 
01:34:49 <lyxia> I feel like this would all just have worked with cabal instead.
01:36:04 <drb69> i added the two packages roman-numerals and pandoc-2.4 to extra-deps of stack.yaml but still it didn't work without allow-newer: true because of zip-archive-0.4
01:37:54 <drb69> i did already stack setup --resolver=lts-12.26, so this is why i specified this exceptional resolver as a command line option
01:38:25 <drb69> i am trying to build a lot of packages around pandoc
01:38:47 <drb69> s/a lot of/several
01:39:39 <lyxia> changing the version of a package like pandoc with lots of dependencies is bound to cause problems, you're better off switching to an older resolver that has the version of pandoc you want.
01:40:34 <lyxia> And resolvers coexist, so running stack setup --resolver=lts-12.26 has no effect on whatever other resolvers.
01:42:39 <lyxia> unfortunately it looks like no LTS resolver has pandoc-2.4, but does it have to be that specific version
01:49:39 <lyxia> drb69: it builds with   resolver: lts-13.2   extra-deps: [pandoc-2.4, roman-numerals-0.5.1.5, pandoc-crossref-0.3.4.0, zip-archive-0.3.3]
02:20:41 <drb69> lyxia: thank you! yes that works and was part of my problem.
02:21:46 <drb69> lyxia: the reason for using --resolver=13.2 came because i would like to use pandoc-2.4, pandoc-crossref, pandoc-citeproc, and my own filter (which is based on pandoc-2.4)
02:22:36 <drb69> lyxia: i haven't found any resolver that could fulfill all the constraints. That's why i think i have to use several resolvers. Or is there any other way to do that?
02:24:26 <lyxia> drb69: there are nightly resolvers, and going back to before pandoc-2.5 was released you can find one using pandoc-2.4
02:25:43 <lyxia> "use several resolvers" doesn't make much sense
02:27:18 <lyxia> you don't want different versions of the same package to see each other.
02:27:56 <WilliamHamilton[> hi, I defined a datatype (Term) and a Show instance that given the nature of the datatype requires overlapping instances. Now I want to write a function similar to:
02:27:58 <WilliamHamilton[> helper :: F.Compose IM.IntMap Term a -> Const String a
02:27:58 <WilliamHamilton[> helper (F.Compose m) = Const (show m)
02:28:39 <WilliamHamilton[> where F.Compose is Data.Functor.Compose and Const is Data.Functor.Const
02:30:24 <ski> WilliamHamilton[ : did you mean to add `Show a =>' to that signature (assuming you have `instance Show a => Show (Term a) where ...') ?
02:30:28 <WilliamHamilton[> If I try writing the function in that manner, I get the error `overlapping show instances for Term a`; I'd like to write a function that given a `concrete` instantiation of a, returns a `Const string a`
02:30:59 <lyxia> Can you paste the code somewhere
02:31:02 <ski> WilliamHamilton[ : does your `Show' instance pretty-print your `Term's, in some way ?
02:31:10 <WilliamHamilton[> the problem with that is that I don't have `Show a => Show (Term a)` but
02:33:08 <WilliamHamilton[> ski: sure, the code is here https://pastebin.com/raw/9BHXEhA7
02:33:18 <WilliamHamilton[> the relevant parts are the `helper` function definition
02:33:28 <WilliamHamilton[> and the Show instances for Term
02:35:31 <WilliamHamilton[> the problem is that I define the Show instance as a general clause in the generic behavior, and a series of overlapping clauses for simple types
02:36:14 <ski> your general case can't handle the special cases as well ?
02:36:29 <ski> WilliamHamilton[ : in any case, you should define `showsPrec', not `show'
02:37:01 <ski> (and you should use `showParen' in the definition. in addition to `showsPrec',`showString' and maybe `showChar')
02:37:42 <ski>   showsPrec p (Var i) = showParen (p > 10) $ showString "Var " . showsPrec 11 i
02:37:57 <WilliamHamilton[> no, unfortunately it can't, because there isn't a `Code Int` in generics-sop
02:38:14 <lyxia> You can refactor those overlapping instances with a separate class
02:38:21 <WilliamHamilton[> yes, thanks, I'll convert all of the code to the showsPrec style
02:38:30 <lyxia> So you have one instance    ShowTerm a => Show (Term a)
02:38:45 <lyxia> and ShowTerm is the class with the overlapping instances, that defines what to do in the Rec case
02:38:54 <ski>   showsPrec p (Con a) = showParen (p > 10) $ showString "Con " . showsPrec 11 a  -- no explicit brackets wrapping `a', the call to `showsPrec' will handle that itself
02:39:13 <lyxia> Then you get   ShowTerm a => Show (Compose IntMap Term)   for free.
02:40:30 <ski> lyxia : there should be another `a' in there ?
02:40:39 <lyxia> there should!
02:41:21 <lyxia> or do you...
02:41:32 <WilliamHamilton[> lyxia: let me see if I get this right: basically this ShowTerm class should have the implementation that Show has now, right? And then how can I say ShowTerm a => Show a without putting constraints on a? (Sorry if the question isn't clear, but I'm not sure I understand your suggestion)
02:41:59 <lyxia> Show for Compose takes Show1 constraints, that may make things trickier than I thought.
02:42:09 <ski> <lyxia> So you have one instance    ShowTerm a => Show (Term a)
02:42:11 <dminuoso> Why is String an type alias rather than a newtype? Are there historical reasons for this?
02:42:23 <ski> dminuoso, yes
02:42:23 <lyxia> dminuoso: history and convenience
02:42:41 <ski> list functions works on `String's
02:42:46 <lyxia> WilliamHamilton[: you don't use Show a anymore
02:43:02 <dminuoso> ski: That's just a matter of coerce or pattern matching though.
02:43:18 <Solonarv> coerce wasn't around Way Back When
02:43:47 <WilliamHamilton[> ski: lyxia let me try to implement it, than I'll ask more if I'm stuck
02:44:17 <ski> WilliamHamilton[ : you should make sure that your `Show' instance generates valid Haskell code
02:44:23 <lyxia> WilliamHamilton[: I think you'll have to redefine Compose
02:44:35 <ski> (i think that's what you're aiming to do, just saying it explicitly)
02:44:58 <ski> (deciphering the `Rec' case is a bit challenging)
02:45:47 <lyxia> I would recommend my show-combinators for making good looking Show instances (both in code and in output)
02:46:16 <WilliamHamilton[> ski: yes, I'll try to do that, sorry for that Rec case but I wrote the code as a proof of concept (I'll clean it up asap)
02:46:20 <WilliamHamilton[> lyxia: checking out show-combinators!
02:46:48 <ski> WilliamHamilton[ : you may want to use `compose . intersperse (showChar ' ')' in `g' (with `compose = foldr (.) id'), to get some air inbetween the argument expressions
02:49:18 <ski> WilliamHamilton[ : fwiw, `10' in `p > 10' is the precedence of function application, and `11' is used in `showsPrec 11' because `11 = 10 + 1', and the incrementing is done for the right operand of function application (the argument expression), because function application is not right-associative
02:49:31 <dminuoso> lyxia: Looking at your package I just realized what your nickname meant.. the simplest answer never occured to me. :)
02:49:46 <ski> (this follows a general pattern for how to do precedence levels for operators, in `Show' and `Read')
02:50:12 <lyxia> dminuoso: <3
02:55:57 <ski> lyxia : i would like variants `showInfixl' and `showInfixr' that doesn't increment on the left, respectively on the right
02:58:06 <ski> (should `showSpace' be defined in terms of `showChar' ?)
02:58:57 <lyxia> that's a good idea
02:59:05 <lyxia> (how else could it be?)
02:59:27 <ski> well, currently you're defining it directly
02:59:55 <lyxia> ah
03:00:34 <lyxia> Well it doesn't really matter to me either way.
03:01:08 <ski> perhaps there should also be a `showOper', to use when one's giving a `Show' instance for an abstract data type, in terms of an abstract operation that is exported
03:01:21 <ski> > listArray (0,3) [2,3,5,7]
03:01:24 <lambdabot>  array (0,3) [(0,2),(1,3),(2,5),(3,7)]
03:01:36 <lyxia> you can pretend listArray is a constructor for that
03:01:58 <ski> `array' here is an example of that. it would look strange to say  showCon "array"  since `array' is not a data constructor
03:02:25 <ski> well, perhaps one could read "constructor" as "smart constructor", in this case
03:03:50 <ski> lyxia : oh. also in your example, in the call to `showCon', it should be passed a string, not the data constructor `C' itself
03:03:51 <WilliamHamilton[> lyxia: is this the kind of refactoring you had in mind? https://pastebin.com/raw/nQCrFG8s ? Because, while I can at that point write the helper function as I intended, if I try `Data.TypeRepMap.hoist helper aMap` I seem only to have moved the goalpost
03:04:19 <lyxia> ski: yeah I forgot to escape some quotes
03:04:39 <ski> lyxia : anyway, nice little package you have there :)
03:06:17 <lyxia> thanks!
03:06:59 <lyxia> WilliamHamilton[: you can't use hoist with helper, because helper's type has an extra constraint
03:09:00 <WilliamHamilton[> lyxia: oh, I (very wrongly) assumed that I could use a function with a constraint and pass it to a function requiring `(forall x. f x -> g x)`, of course now I see that's dumb
03:09:37 <WilliamHamilton[> so, is there a way  to print something like `type Substitution = TM.TypeRepMap (F.Compose IM.IntMap Term)`?
03:10:47 <ski> where's `TM.TypeRepMap' from ?
03:11:01 <WilliamHamilton[> https://hackage.haskell.org/package/typerep-map-0.3.0/docs/Data-TypeRepMap.html
03:14:01 <ski> you may want to bundle each `Term a' up with a `ShowTerm a' constraint, in the map ?
03:14:15 <lyxia> that doesn't seem possible
03:14:47 <ski> why not ?
03:14:58 <lyxia> I meant showing the original type
03:15:11 <drb69> lyxia: can you explain to me what you meant why i don't want to use several resolvers in parallel? isn't it possible to compile one binary using resolver A and another binary using resolver B? i mean, once compiled, the binary doesn't care about how it was built, does it?
03:15:22 <ski> you'd have to adapt `F.Compose IM.IntMap Term', obviously
03:16:11 <WilliamHamilton[> ski: which map, the IntMap or the external one?
03:16:48 <drb69> in the case of pandoc and pandoc-filters, there is usually only a build dependency to pandoc-types from what i understand
03:16:50 <Solonarv> drb69: sure, you can do that, but those binaries probably won't be ABI compatible
03:17:28 <drb69> Solonarv: ok, but i can execute them, can't i?
03:17:30 <ski> WilliamHamilton[ : the `TypeRepMap'
03:17:44 <Solonarv> drb69: yes of course, assuming they're independent
03:18:22 <Solonarv> you just have absolutely no guarantees that they'll actually work together
03:18:36 <graingert> is there a fold that keeps the history
03:18:49 <ski> @type scanr
03:18:50 <lambdabot> (a -> b -> b) -> b -> [a] -> [b]
03:18:51 <ski> @type scanl
03:18:52 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
03:19:01 <WilliamHamilton[> ski: could you illustrate how I add a constraint to each element in the TypeRepMap? I mean, what would the type of f be in `TypeRepMap f`?
03:19:05 <ski> > scanr f z [a,b,c,d]
03:19:07 <lambdabot>  [f a (f b (f c (f d z))),f b (f c (f d z)),f c (f d z),f d z,z]
03:19:09 <ski> > scanl f z [a,b,c,d]
03:19:11 <graingert> nice
03:19:12 <lambdabot>  [z,f z a,f (f z a) b,f (f (f z a) b) c,f (f (f (f z a) b) c) d]
03:19:15 <drb69> Solonarv: and what about the build time dependencies under .stack? is it safe to build n binaries using resolver A and then switch to another resolver B?
03:19:19 <dmwit> graingert: mapM, foldM with State(T); histomorphisms
03:19:21 <ski> also `scanr1',`scanl1'
03:19:30 <Solonarv> drb69: define "safe"
03:19:43 <ski> also see `mapAccumL',`mapAccumR', and what dmwit said
03:20:11 <dmwit> graingert: Hm. I missed the "the" in your question, which changes the interpretation substantially.
03:20:28 <ski> WilliamHamilton[ : conceptually, you want `TypeRepMap (\a -> ShowTerm a *> IntMap (Term a))'
03:20:34 <Solonarv> drb69: it seems like what you're trying to do is better accomplished by using the 'extra-deps' section in stack.yaml
03:21:04 <WilliamHamilton[> ski: right, and is there a way to write that in haskell?
03:21:25 <WilliamHamilton[> oh wait, I define
03:21:46 <WilliamHamilton[> `Wrapper a = ShowTerm a => IntMap (Term a)`
03:21:57 <WilliamHamilton[> and than I have `TypeRepMap Wrapper`?
03:21:59 <Solonarv> WilliamHamilton[: yes, using 'data (*>) c a where (*>) :: c => a -> c *> a'
03:22:16 <ski> WilliamHamilton[ : there is probably a datatype for `data Constrained c f a = c a => MkConstrained (f a)' somewhere (named i don't know what). given that, you could do `type Substitution = TM.TypeRepMap (F.Compose ShowTerm (F.Compose IM.IntMap Term))'
03:22:25 <drb69> Solonarv: say build plan pandoc-2.4 uses ghc-8.6 and pandoc-types-1.17.5, pandoc-crossref want to use pandoc-2.4 and pandoc-types-1.17.5 as well but this time with ghc-8.4. Will stack recompile pandoc-2.4 for pandoc-crossref or try to reuse the already installed package in the .stack hierarchy?
03:22:44 <Solonarv> er, nevermind, that isn't valid syntax - those need to start with a :
03:22:59 <ski> er, `type Substitution = TM.TypeRepMap (Constrained ShowTerm (F.Compose IM.IntMap Term))', i mean
03:23:04 <Solonarv> drb69: no, because they *can't* be reused
03:23:21 <drb69> ok, so the build won't break
03:23:43 <ski> WilliamHamilton[ : yes, that `Wrapper' would also work (if you add a data constructor name)
03:23:52 <Solonarv> libraries compiled with different GHC versions are not ABI compatible; our build tools know this, so they don't try to reuse them
03:24:04 <drb69> Solonarv: can you explain to me how to do that with extra-deps in stack.yaml?
03:24:16 <jollygood2> any portential issues in enabling FlexibleContexts in .ghci.conf?
03:24:23 <Solonarv> drb69: well I don't even know what you're trying to do in the first place
03:24:25 <WilliamHamilton[> ski: Solonarv thanks, that's an idea worth exploring; btw, if you happen to be familiar with Data.Dependent.Map instead, would that interface make what I'm trying to do simpler?
03:24:49 <ski> WilliamHamilton[ : i suspect it would be the same
03:25:06 <Solonarv> WilliamHamilton[: the only vaguely similar library I've used is vinyl, so I can't comment
03:25:57 <drb69> Solonarv: i want to build a tool chain consisting of pandoc and several pandoc-filters such as pandoc-crossref, pandoc-citeproc, and my self-written filter, which uses swagger2, strings, and pandoc-2.4
03:27:05 <Solonarv> drb69: it's probably easier to build everything with the same ghc version & snapshot
03:27:19 <drb69> Solonarv: if that is possible that would be perfect
03:27:25 <lyxia> jollygood2: not really, other than a potential confusion because you could successfully load a file in ghci but it doesn't compile with ghc.
03:28:09 <WilliamHamilton[> lyxia: a question on the technique you showed earlier (refactoring an overlapping instance of say `Show` to a typeclass with overlapping instances `ShowTerm` and then `(ShowTerm a => Show (Term a)`). Is it the case that every error due to overlapping instances I previously got on Show is now moved on ShowTerm? In other words, am I just moving the problem further down?
03:30:01 <drb69> Solonarv: the final result should be a recipe (shell script or similar) that i can use for various circumstances (local installation, docker)
03:30:30 <Solonarv> drb69: I'd recommend looking at the stack docs
03:30:31 <jollygood2> lyxia it appears ghci separates extensions when loading a file and those used when you type things directly
03:30:48 <drb69> Solonarv: what especially?
03:31:25 <Solonarv> drb69: look for using packages not in the resolver, and (since you mentioned it) docker integration
03:32:03 <Solonarv> I don't actually use stack anymore, so I've started to forget how exactly to use t
03:32:40 <drb69> Solonarv: what do you use instead? i don't care about the name of the build tool, i want things to be done
03:33:03 <Solonarv> I use cabal
03:33:33 <Solonarv> But I don't have a ready-made solution for you (as I haven't been in your situation of wanting a whole bunch of binaries built)
03:33:37 <drb69> Solonarv: ok, my filter already has a (rather messy) cabal file
03:33:51 <jollygood2> lyxia, in other words, :set -XFlexibleContexts doesn't make file loadable in ghci unless it has that pragma on top, and pragma on top of the file doesn't enable that extension when typing things directly in ghci
03:33:58 <Solonarv> and I'm not generous enough to put work into solving it for you
03:34:14 <drb69> Solonarv: that's fine i am here to learn
03:34:25 <lyxia> WilliamHamilton[: yes, but ShowTerm can be easier to pass around
03:36:15 <WilliamHamilton[> lyxia: ok, thanks, so for example it's easier to bundle an instance of ShowTerm in each element of the dependent map as ski was suggesting!
03:37:47 <lyxia> Right
04:30:28 * hackage show-combinators 0.1.1.0 - Combinators to write Show instances  http://hackage.haskell.org/package/show-combinators-0.1.1.0 (lyxia)
04:31:23 <dminuoso> What was the name GHC uses for when branches merge together? https://gist.github.com/dminuoso/3cab7980df058e6d067e85f02d727c70
04:32:51 <lyxia> join points?
04:33:12 <dminuoso> lyxia: Ahh that's it thanks.
04:33:53 <julianleviston> wait… what is that? :)
04:33:57 * hackage dynamic-graphs 0.1.0.1 - Dynamic graph algorithms  http://hackage.haskell.org/package/dynamic-graphs-0.1.0.1 (JasperVanDerJeugt)
04:34:16 <dminuoso> I guess the example was unnecessarily large, something like `case x of A -> j 1; B -> j 2` would have sufficed.
04:34:29 <julianleviston> is that calling `bar` or `quux` with the `baz` argument depending on x ?
04:34:58 <dminuoso> julianleviston: You should lose the notion of "calling". :)
04:35:13 <julianleviston> dminuoso: I don’t have it. Just a habit of speech.
04:35:21 <julianleviston> dminuoso: “applying” ;-)
04:35:24 <Ariakenom> a phi node :)
04:35:33 <julianleviston> what’s a phi node?
04:35:40 <dminuoso> julianleviston: Fair enough. This would desugar into: (case x of A -> bar; B -> quux) >> baz`
04:35:58 <julianleviston> oh duh. I missed the do. ;-) all good. I understand that just fine.
04:35:59 <Ariakenom> compiler term. from single static assignment form 
04:36:36 <julianleviston> so why is that called a join point?
04:37:07 <julianleviston> isnt’ it just a conditional action?
04:37:58 <dminuoso> julianleviston: case allows you to branch, join points are when branches come together ("join") again
04:38:08 <julianleviston> ah gotcha
04:38:23 <julianleviston> cool.
04:38:29 <dminuoso> GHC can apply certain optimization to join points, so it does join point analysis to some degree.
04:38:49 <julianleviston> I’m not familiar with the optimisation code yet. :)
04:38:56 <Ariakenom> julianleviston: SPJ writings are always nice. You can read the introduction https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/join-points-pldi17.pdf
04:39:20 <julianleviston> Yeah I have a large stack of SPJ papers to read
04:39:31 <julianleviston> https://ghc.haskell.org/trac/ghc/wiki/ReadingList
04:39:38 <lyxia> ski: thanks for the suggestions! I just added showInfixl and showInfixr.
04:39:39 <julianleviston> (tho those aren’t by any means solely his)
04:40:04 <Ariakenom> the paper has 3 helpful code snippets
04:40:24 <julianleviston> gotta read this sometime very soon: https://www.microsoft.com/en-us/research/uploads/prod/1987/01/slpj-book-1987-r90.pdf
04:41:34 <dminuoso> julianleviston: My example was particularly poor because it mixed various things. `case x of A -> j 1; B -> j 2` would be a really good example of a potential join point. :)
04:42:11 <julianleviston> nah it made complete sense. I seriously just didn’t see the do :) (so I thought the case was to find a function that then got applied to a value)
04:42:41 <julianleviston> like… (case fg of A -> f; B -> g) x
04:43:07 <dminuoso> julianleviston: It was still bad because my point is not about `IO` at all. :)
04:43:27 <julianleviston> who said anything about IO?
04:43:48 <dminuoso> Heh fair enough.
04:44:05 <julianleviston> right tho you’re saying you can have join points in any case or conditional.
04:44:12 <julianleviston> any branch at all. gotcha :)
04:44:56 <dminuoso> Right, it's a join point in the evaluation model. :)
04:47:15 <julianleviston> this is a nice paper.
04:47:36 <julianleviston> Reminds me I really need to more deeply understand CPS
04:49:16 <Ariakenom> that was a heavy book. looks like it may have a bunch of juicy details
04:51:40 <julianleviston> I’ve often wondered — why don’t papers have the date on them normally?
04:51:58 <julianleviston> This (SPJ et al paper about join points) was obviously written post 2015…
04:53:05 * ski has also wondered that
04:53:13 <ski> says "PLDI'17, June 18-23, 2017, Barcelona Spain" on bottom of front page, though
04:53:32 <Ariakenom> I also miss dates on papers. But (redacted ski was first).
04:53:36 <__monty__> Yet the url says 2016/11
04:53:44 <julianleviston> nice
04:53:51 <dminuoso> __monty__: The URL is just some microsoft weird thingy software thing.
04:54:00 <ski> perhaps the paper was submitted in late 2016 ?
04:54:14 <dminuoso> Or perhaps it was uploaded while it was still a draft.
04:54:31 <dminuoso> The *filename* has a 17 inside it, suggesting 2017
04:54:32 <__monty__> dminuoso: I knew the URL was a lie, it always is, isn't it?
04:55:18 <ski> hm, this reminds me of some thoughts about "fallthrough" in `case' i was having, like `\case C0 -> ...; (C1 x y | C2 x z) -> ..x..(..x..y.. | ..x..z..)..'
04:55:38 <__monty__> Though tbh I trust the URL in this case. Who'd go around backdating urls for uploads? While it's not strange to name a file with a future date for a conference you want to present it at : )
04:57:13 <ski> the idea being that both the `C1' and the `C2' case shares a common portion (context) `..x..<--->..' around the differing part `..x..y..' vs. `..x..z..'
05:03:10 <ski> also i'm reminded a little bit about the general motivation for multiple return values (like `values',`call-with-values' in Schem). also "Multi-return function call" by Olin Shivers,David Fisher in 2004-09,2006-0(7,9) at <http://www.ccs.neu.edu/home/shivers/citations.html#mrlc>
05:04:45 <Nexilva> Hello, I would like to learn Haskell but I can't find anything that really helps me to learn it. Everyone starts with numbers and equations and mundane stuff that's impractical and I just can't see it in my mind. The way I learn best is when I can make something practical with it, as it explains the concepts there, and build one thing after another, and while building it learn the concepts I need to learn.
05:04:58 <Nexilva> Otherwise it's just a blue to me. I wonder if you guys would know of a resource for someone like me.
05:05:06 <Nexilva> s/blue/blur*
05:10:05 <coldpress> I've read the wikibooks on Lenses_and_functional_references. Is there a specific tutorial on lenses you guys could recommend me?
05:11:18 <coldpress> Nexilva: what do you think about the quicksort function on the bottom of https://www.haskell.org/tutorial/goodies.html ?
05:12:26 <dminuoso> Nexilva: If you have the feeling that everyone starts with numbers and equations, then you probably have read inadequate resources.
05:12:57 <Nexilva> I don't have a mathematics background, you see, so it's hazes my mind.
05:13:02 <dminuoso> Nexilva: Have you tries CIS194? It's a pretty good course packed with exercises that get pretty close to real world scenarios.
05:13:08 <dminuoso> Nexilva: Oh. I have the thing for you
05:13:16 <Nexilva> Haskell is the only language that makes me feel psychologically inadequete.
05:13:21 <dminuoso> Nexilva: https://patrickmn.com/software/the-haskell-pyramid/
05:14:08 <Nexilva> For example, I have no education, didn't graduate highschool, got GED, dropped out of colleged, failed college algebra thrice.
05:14:17 <Nexilva> Maybe I'm stupid? Who nows.
05:14:19 <dminuoso> Nexilva: Neither have I.
05:14:42 <dminuoso> Nexilva: Honestly take the link I gave you and digest it.
05:15:00 <lyxia> coldpress: https://artyom.me/lens-over-tea-1
05:15:31 <Nexilva> In other langs, as I've been doing webdev in php/python etc. I learned by, hey we'll build this today, and in order to do that, here'a an object, and there's  design patterna nd you have to use thisone, and that's how you implement the pattern, etc. etc.
05:15:40 <Rembane> Nexilva: Or the schooling system isn't very good for you.
05:15:43 <Nexilva> liek buldingin online inventory apps, job boards, etc. etc. that kind of stuff
05:16:04 <Nexilva> Does Haskell have that kind of education?
05:16:21 <Rembane> As in learning by building? 
05:16:22 <Nexilva> Hey, we'll build this in HAskell today, and to do that, you need to learn these concepts, and you know so froth
05:16:27 <Nexilva> yes sir
05:17:00 <Rembane> Real World Haskell is quite good but ancient.
05:17:01 <julianleviston> Nexilva: there’s the absolute beginning of something here: http://happylearnhaskelltutorial.com it’s free — so for super basics, that might help
05:17:08 <dminuoso> Nexilva: When I learned Haskell I discovered that many so-called "design patterns" are just coping techniques from languages that have fatal flaws.
05:17:15 <Nexilva> Ok, thank you, i'll try that
05:17:26 <Rembane> https://stackoverflow.com/questions/1012573/getting-started-with-haskell/3609688#3609688
05:17:32 <Rembane> That one's good too. 
05:17:44 <dminuoso> Nexilva: For example Java's "factory pattern" is just a coping technique to deal with the fact that you can't have either a) anonymous functions as top-level constructs and b) partial application.
05:17:47 <Rembane> Nexilva: And always remember that you can ask questions here. 
05:18:18 <Nexilva> I got into interested in it by using Xmoand
05:18:41 <Nexilva> I made my own config and it not easy to understand it so I am trying to learn this language and also becuase it seems really nice 
05:18:45 <Rembane> dminuoso: I love the grumpy old lispers who said that the design patterns book wasn't needed in lisp. :D
05:18:52 <Rembane> Nexilva: Sweet! :D
05:18:53 <julianleviston> Nexilva: I think its’ very productive to drop any self-assessment of intelligence.
05:19:36 <Nexilva> julianleviston: culture and society convince you for decades that without an education you'll never be smart. It's that lingering nonsense. I'm sure I'll get over it.
05:19:38 <Rembane> One interesting that Haskell will make to you is to make you feel dumb, 'cause some of the concepts take some time to get used to.
05:19:44 <Ariakenom> Nexilva: I know you said a tutorial without math but you might like this is a nice short post on the math needed for haskell. http://www.vex.net/~trebla/haskell/prerequisite.xhtml
05:19:46 <dminuoso> Nexilva: For what its worth: We've had people who said they learned Haskell over Python because they felt not smart enough. Python really requires you to be *very* competent and good to write high quality code.
05:19:48 <coldpress> lyxia: thank you
05:19:49 <Nexilva> Rembane: yes, it does make me feel dumb.
05:20:00 <dminuoso> Nexilva: So you could actually think of Haskell as being much easier. :)
05:20:01 <Rembane> Nexilva: Good, then you're learning. :)
05:20:14 <Nexilva> Recursion for example. Nicely done here.
05:20:51 <Nexilva> http://learnyouahaskell.com/recursion
05:20:54 <Nexilva> I read this one.
05:20:55 <dminuoso> Rembane: Funnily enough one major psychological barrier was accepting that `True/False` were not more expensive than `true/false` on the basis that they were capitalized...
05:21:26 <Rembane> dminuoso: More expensive on what axis? :)
05:21:36 <coldpress> lyxia: I like the length and conversational tone to that tutorial
05:21:49 <dminuoso> Rembane: No idea. But when I was new to Haskell I always felt that working with `True/False` must clearly be more expensive.
05:21:56 <dminuoso> For no good reason.
05:21:57 <coldpress> Nexilva: I like the terseness of the Gentle '98 tutorial
05:21:59 <Nexilva> I am on ubuntu 18.04. Would you use the haskell-platform package to get everything, or would you build from source?
05:22:09 <Rembane> dminuoso: Oh. That's fun! :D
05:22:13 <dminuoso> coldpress: The Gentle introduction is *nothing* but gentle.
05:22:30 <Nexilva> I didn't know of the gentle until today. It's for gentleman like me. Should be good.
05:22:31 <julianleviston> dminuoso: I bet it’s because in OOP languages, classes start with a capital letter ;-)
05:22:40 <dminuoso> The gentle introduction, as it says so in the first pages, is best taken as a guide next to the Haskell report, ideally when you know some functional programming languages already.
05:22:45 <Rembane> dminuoso: When I do truth tables I prefer 1 and 0 rather than T and F, because they're much faster to write. 
05:22:46 <Ariakenom> dminuoso: Did you do Java before. There primitives like int aren't capitalized where Integer is.
05:23:14 <__monty__> dminuoso: It's actually *everything* but gentle : >
05:23:16 <Nexilva> The website says that distro packages might be sligihtly out of date. Should that matter?
05:23:24 <dminuoso> __monty__: Oh! Hah. Indeed.
05:23:44 <dminuoso> Nexilva: Based on what you have said so far I'm dead convinced the gentle introduction is not for you.
05:23:49 <Nexilva> I have stack installed and I did stack upgrade and it can't upgrade anymore, it's on last version
05:24:18 <Nexilva> Well, I did program in other languages, so when they start with , hey, x=5
05:24:22 <Nexilva> I'm like, yeah, okay, that' so boring!
05:24:25 <Nexilva> move on already!
05:24:35 <dminuoso> Nexilva: Think of the gentle introduction as 15 pages outlining you all the features of Haskell, it's syntax, type system, typeclasses... and then good luck figuring how to solve problems.
05:24:44 <Solonarv> if you allowed stack to upgrade itself, it'll be up to date ;)
05:24:51 <Nexilva> Yeah, I love to read. np.
05:25:36 <__monty__> Nexilva: Haskell's x=5 is pretty different form x=5 in most languages though.
05:25:38 <ski> Nexilva : `x=5' in Haskell is not like `x=5' in most other programming languages
05:26:02 <Nexilva> However, I instaled apt-get install cabal-install and then it tries to instal cabal and the build fails, I'll have to get the errors later, I deleted that b/c my SSD /home is out of space. I would like to put all the haskell stuf fon /media which is a mechanial drive with mroe space. I need to learn how how to do that
05:26:41 <__monty__> Oh, you'll need quite some space. GHC isn't quite lean.
05:26:42 <Nexilva> So I suppose I should build fro source instead of ubuntu 18.04 packages? What do you recommend?
05:26:48 <dminuoso> Nexilva: You could use ghcup.
05:27:02 <Nexilva> I tried that too. Cabal fails to build.
05:27:11 <Nexilva> I deleted it b/c it took up over  1b in my /home ssd
05:27:13 <dminuoso> Nexilva: How does it fail to build?
05:27:30 <Nexilva> So I would now like to put every haskell related stuff in /media as I build it and install it and use it. 
05:27:41 <__monty__> More than a single byte, who does this compiler think it is?!
05:27:41 <Nexilva> I don't know anymore I deleted it all to make space.
05:27:43 <__monty__> : )
05:27:50 <dminuoso> Nexilva: You can take the prebuilt binary distributions and unpack them from hand.
05:28:03 <dminuoso> It's what I do since I've grown tired of package management systems being terrible.
05:28:14 <Nexilva> I can find out again as soon as I figure out how to build/download/put/use haskell on /media instead of /home/$USER/.cabal or something
05:28:17 <Ariakenom> __monty__: byte is obviously B, b is bit :p
05:28:21 <Nexilva> I want to take haskell stuff totaly out of /home/
05:28:31 <Nexilva> dminuoso: oh.
05:28:37 <Nexilva> That'll work!
05:28:39 <dminuoso> Nexilva: Then just do it manually. It's just a matter of downloading the tar bundle, unpacking it and setting your PATH.
05:28:41 <__monty__> Ariakenom: You're right, what was I thinking being ok with 8x the space?!
05:28:46 <dminuoso> Nexilva: That's really all you have to do. 
05:28:48 <Nexilva> dminuoso: oh ok.
05:28:51 <Nexilva> I'll go read up now.
05:28:57 <Solonarv> I seem to have somehow acquired the impression that ghcup fetches bindists for you, am I wrong?
05:29:57 <__monty__> Nexilva: I'd recommend one of the programming exercises sites maybe? That's more learning by doing than most tutorials. I like the advanced exercises on codewarrior so I'm assuming the basic ones are good to.
05:30:30 <dminuoso> @where CIS194
05:30:30 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
05:30:43 <dminuoso> Nexilva: ^- this is one of the most frequently cited learning resources. It's fast and contains good excercises.
05:39:41 <julianleviston> Yeah! hacker rank, or exercism.
06:13:46 <SomeGuy001> geekosaur and koz_ , thanks to you guys I've been able to make some progress here :D
06:16:26 <SomeGuy001> In fact, I just got it to work. Now I just need to figure out how to submit a bug report like you said and I'm done :D
06:19:32 <jollygood2> "A former New York City teacher is heading to court after she was accused of forcing black students to lie on the floor while she stood on their backs during a slavery lesson."
06:19:35 <jollygood2> :-O
06:20:51 <jollygood2> and she's the one suing..
06:22:11 * ski glances momentarily towards #haskell-offtopic
06:22:27 <jgt> can anyone give me an executive summary on why this happens? http://ix.io/1y2V
06:22:53 <jgt> I can make the compile error go away by enabling GADTs, but it feels a bit lame to cargo-cult a solution like that
06:24:18 <Solonarv> uhh, that link seems broken?
06:24:35 <Solonarv> nvm, reload fixed it
06:24:42 <byorgey> jgt: it happens because the inferred type of fieldParse' requires a type system extension which is not enabled by default
06:24:52 <byorgey> namely, equational constraints like  a ~ b
06:25:10 <byorgey> you can enable those with either GADTs or TypeFamilies
06:25:26 <jgt> byorgey: oh, so it's not because I'm not giving enough hints about the types I'm using in my case expression?
06:25:48 <byorgey> jgt: nope
06:25:56 <Solonarv> no! there is plenty of type information available
06:26:10 <dminuoso> I suppose the lack of a type annotation could be part of the reason though.
06:26:43 <Solonarv> I suppose a type signature that monomorphizes 'c' would make the error disappear too
06:27:03 <dminuoso> jgt: Remember that Haskell always tries to infer the most general type.
06:27:14 <jgt> byorgey: this is interesting. I have a few other similar functions which do not trigger this error. The main difference (I think?) is in this function I'm trying to parse an Int
06:27:27 <jgt> I can give examples of those other functions if anyone is curious
06:27:48 <byorgey> I don't see why parsing an Int would affect this.  I suspect the real difference is something else.
06:28:33 <jgt> here's a couple other functions that did not trigger this error: http://ix.io/1y2Y
06:28:42 <Solonarv> yeah, I don't know where this 'readMay' is coming from.
06:28:58 <jgt> dminuoso: that's good to keep in mind, thanks :)
06:29:10 <jgt> Solonarv: ah, that might be the clue…
06:29:38 <dminuoso> jgt: What is `Element`? Is that an associated type family?
06:29:59 <Solonarv> dminuoso: yes, it's from the mono-traversable ecosystem IIRC
06:30:10 <byorgey> yeah, it looks to me like readMay has some really generic type, so it works over any MonoFoldable with Char Elements
06:30:29 <Solonarv> ...which is a really weird direction to generalize in
06:30:31 <dminuoso> Indeed. :)
06:30:37 <dminuoso> readMay :: (Element c ~ Char, MonoFoldable c, Read a) => c -> Maybe a
06:30:41 <byorgey> bingo
06:31:19 <jgt> "which is a really weird direction to generalize in" this is now a bit beyond my knowledge; does it look like I'm trying to do something strange here?
06:31:49 <jgt> (not being defensive; curious to learn)
06:31:58 <lyxia> it's the library that's strange
06:32:01 <dminuoso> jgt: So the reason is that using `readMay` simply requires any of these two extensions because of it's equational constraint.
06:32:08 <Solonarv> not you, but whoever wrote readMay
06:32:10 <byorgey> jgt: so you could get rid of the need for GADTs or TypeFamilies by adding a type signature for fieldParse' :: [String] -> ...
06:32:23 <dminuoso> byorgey: No you couldn't because the constraint still needs to be satisfied.
06:32:39 <dminuoso> No?
06:32:59 <byorgey> dminuoso: no, if you specify a type for c the constraint will be satisfied under the hood and it will never need to show up in the type
06:33:03 <Solonarv> should work, actually - equality constraints are generated & discharged by the typechecker all the time
06:33:21 <dminuoso> So equality constraints just can't leak to bindings?
06:33:57 <dminuoso> But I guess that makes sense, I've been using MegaParsec quite a bit now without those extensions.
06:34:00 <byorgey> sure, the extension is only about whether you get to write them explicitly in types, not whether they get to appear in the core language at all
06:34:14 <dminuoso> Fair enough.
06:35:06 <Solonarv> IIUC equality constraints are one of those things that have existed in the guts of the compiler for way longer than it's been possible to use them directly
06:37:00 <Solonarv> (and by "IIUC" I really mean "here's a completely unsubstantiated guess" :p)
06:37:59 <byorgey> yes, equality constraints have existed in the guts of the compiler since 2006.  Not sure off the top of my head how long it's been possible to write them in the surface language.
06:38:07 <Ariakenom> IANACW
06:42:22 <WilliamHamilton[> lyxia, ski, I have another question if you don't mind: do you see a way, in https://hackage.haskell.org/package/typerep-map-0.3.0/docs/Data-TypeRepMap.html, to search for a key in the map given a SomeTypeRep (like the one you could obtain with the key function)? I tried to pattern match on it in a case, like lyxia suggested yesterday, but I get a kind mismatch and I don't know how to solve that
06:42:57 <__monty__> Ariakenom: I am not a computer worm?
06:43:11 <Ariakenom> __monty__: :) compiler writer
06:43:41 <Ariakenom> who'd a thought making up abbreviations would be so ambiguous
06:44:10 <ideas_guy> would it be hard to write a compiler for standard haskell code?
06:44:40 <ideas_guy> my eyes have been opened to the simplicity of parsing recently
06:44:55 <Ariakenom> ideas_guy: I don't have an answer either way but define "standard".
06:46:18 <ideas_guy> without ghc extensions
06:48:02 <Solonarv> Haskell98 shouldn't be too complicated, I think?
06:48:19 <lyxia> WilliamHamilton[: oh my, SomeTypeRep even hides the kind!
06:48:19 <geekosaur> there's a number of them out there. standard Haskell has its complexities, largely due to layout, but it's easier than e.g. dealing with C's typedef
06:49:05 <geekosaur> the main problem is you pretty much can't find useful programs that don't require an extension (often MultiParameterTypeclasses via mtl)
06:49:14 <lyxia> WilliamHamilton[: I think you're better off defining your own monokinded SomeTypeRep
06:49:38 <WilliamHamilton[> lyxia: yes, and I'd like a way to say that I'm only ever interested in using kind *
06:49:43 <WilliamHamilton[> oh yes
06:49:59 <WilliamHamilton[> but then I can't use the `keys` function from there, right?
06:50:03 <dminuoso> I tried parser-combinators to build a permutation parser, but it seems to not work: https://gist.github.com/dminuoso/da6c5f4ee0bcad2cec4711d377f937b5
06:50:07 <dminuoso> Where is my fault?
06:50:11 <lyxia> WilliamHamilton[: otherwise you could use typeRepKind and then check that the kind is * at runtime.
06:50:16 <WilliamHamilton[> basically, I should rebuild all the functionality of the package at that point, right?
06:50:37 <lyxia> WilliamHamilton[: oh I see...
06:50:45 <WilliamHamilton[> lyxia: oh, that's what I want to do (and raise an error if that's not the case)! But how?
06:51:00 <dminuoso> It seems that `parens` somehow breaks the permutation, but I do not understand why.
06:51:07 <WilliamHamilton[> oh wait, typeRepKind, I was not aware that existed, let me check it
06:51:10 <Solonarv> lyxia, WilliamHamilton[: actually, the API exported from Data.Typeable is mono-kinded
06:52:41 <WilliamHamilton[> Solonarv: unfortunately I'm given the poly-kinded representation by one of the function I'd like to use in Data.TypeRepMap. Is there a way to convert the poly-kinded one in the mono-kinded one?
06:52:52 <WilliamHamilton[> (I think the poly-kinded lives in Type.Reflection)
06:53:07 <lyxia> Solonarv: Data.Typeable.TypeRep hides a type of arbitrary kind
06:53:19 <Solonarv> urrr
06:53:36 <Solonarv> I don't recall the Typeable-related API well enough to answer offhand apparently
06:56:04 <WilliamHamilton[> lyxia: once I get the `TypeRep k` of my kind via case matching, how do I check that it's `*`?
06:56:46 <WilliamHamilton[>       case tr of
06:56:47 <WilliamHamilton[>         TR.SomeTypeRep a -> case TR.typeRepKind a of
06:56:47 <WilliamHamilton[>           TypeRep ?? -> undefined
06:59:06 <lyxia> WilliamHamilton[: case (TR.eqTypeRep (TR.typeRepKind a) (typeRep @Type)) of Just HRefl -> ... ; Nothing -> ...
07:02:00 <dminuoso> Okay it seems that this must be some subtle bug in the parser-combinators package.
07:02:08 <dminuoso> Eds `parsers` handles it fine.
07:05:43 <coldpress> dminuoso: my instinct tells me you need to use some `try` combinator to dodeep parsing
07:06:32 <dminuoso> coldpress: the combinator already wraps my parsers with `optional` though.
07:06:39 <coldpress> because the opening bracket is consumed by the first `foo` parser, so it continues parsing thinking the rest of the input must be `foo`. But it actually is `bar`, therefore it fails.
07:07:15 <coldpress> i don't see any `optional` in your code
07:07:23 <coldpress> oh right, its in the library
07:07:50 <dminuoso> coldpress: https://hackage.haskell.org/package/parser-combinators-1.0.1/docs/src/Control.Applicative.Permutations.html#runPermutation
07:07:57 <dminuoso> coldpress: It's kind of the point of the library to not have to do this.
07:08:07 <dminuoso> Well. Of the combinator I mean.
07:08:45 <dminuoso> coldpress: But it's an interesting thought, let me try something
07:10:04 <coldpress> dminuoso: pretty sure `optional` does not backtrack your parser
07:10:23 <dminuoso> coldpress: https://gist.github.com/dminuoso/8e5a9264c96d17e78fc2c312dcdace32
07:10:26 <dminuoso> this works.
07:10:31 <dminuoso> so there must be some backtracking.
07:10:59 <coldpress> dminuoso: I read somewhere that `string` has backtracking capabilities, but i forget where
07:11:19 <Solonarv> it's a backtracking primitive in megaparsec, IIRC
07:11:50 <dminuoso> coldpress: At the very least it's a documentation bug then.
07:18:41 <lyxia> WilliamHamilton[: you can open an issue or make a PR to get a monokinded variant of keys into typerep-map
07:21:04 <WilliamHamilton[> lyxia: yes, I'll do that as soon as I finish writing my pretty-printer here. Also, a pretty printer, or a better show instance (the current one displays only the types) would be useful, so I'll open an issue for that also
07:23:57 <geekosaur> "useful", but is it possible?
07:36:48 <WilliamHamilton[> lyxia: in the end I got what I wanted writing something like https://pastebin.com/raw/y1cNafNU . Thanks for all the help and examples, and tell me if you can think of a better solution (I'll clean the code now)
07:38:51 <WilliamHamilton[> another worthy addition in my opinion would be a way to say that if all keys of the map share a constraint, then you can do something involving that constraint (using a generic eliminator): only this seem difficult because they don't expose at the type level the list of keys they're using, right?
07:48:16 <lyxia> right
07:49:15 <lyxia> that looks good to me
07:50:11 <c50a326> hey, I can't make a function like: `diff = abs . (-)` ?
07:51:27 <Solonarv> c50a326: functions are curried
07:52:17 <Solonarv> so 'diff = abs . (-)' eta-expands to 'diff x = abs ((-) x)', which is clearly nonsense
07:52:52 <Solonarv> @pl diff x y = abs (x - y)
07:52:52 <lambdabot> diff = (abs .) . (-)
07:53:17 <c50a326> aha lol
07:53:32 <c50a326> better just `diff x y = abs (x - y)` I guess
07:53:36 <Solonarv> yeah
07:55:02 <c50a326> this is quite instructive on currying though! good to know, thanks
08:10:26 <jollygood2> what are the best new ghc features/extensions I am missing by still using 8.0.2?
08:11:43 <Solonarv> jollygood2: DerivingVia is incredibly awesome, and that's just the one I can immediately think of
08:13:25 <Solonarv> give me a few minute to compile a list
08:14:15 <jollygood2> Solonarv, DerivingVia looks neat
08:14:40 <jollygood2> Solonarv, ok, cheers
08:16:17 <dmwit> jollygood2: Did you know that the GHC folks put out a changelog with every release? =)
08:17:00 <dmj`> Can you not just put Storable Vector into an FFI declaration
08:18:21 <dmwit> jollygood2: https://downloads.haskell.org/~ghc/8.2.1/docs/html/users_guide/8.2.1-notes.html and the obvious URL hacks will get you to the 8.4.1 and 8.6.1 release notes. Just read the highlights and you'll have a pretty good picture.
08:20:49 <jollygood2> dmwit, can one find feature release comparing two arbitrary versions, and not just new version with last one?
08:21:01 <jollygood2> s/release/changelog
08:30:58 <Solonarv> jollygood2: https://gist.github.com/Solonarv/da0c329151d3f9fb955bbc02e7d37c6b for what good it'll do
08:33:55 <dmwit> jollygood2: I believe no.
08:44:26 <WilliamHamilton[> is there a polykinded functor composition operator? I'd like to write `(Show :.: Foo)`, where `Foo :: * -> *`, and get something of type `* -> Constraint`. But both Data.Functor.Compose.Compose and Generics.SOP.(:.:) are geared towards kind Type
08:45:01 <WilliamHamilton[> I mean: is there a common implementation of polykinded functor composition on hackage?
08:46:52 <julianleviston> You mean like Functor Compose? https://hackage.haskell.org/package/transformers-0.3.0.0/docs/Data-Functor-Compose.html
08:47:08 <julianleviston> sorry if this is utterly not what you want.
08:48:26 <WilliamHamilton[> julianleviston: thanks, unfortunately Data.Functor.Compose is not polykinded, and by that I mean that the functor it is expecting have to be of kind * -> *
08:48:31 <WilliamHamilton[> I'd like something like
08:48:39 <julianleviston> Yeah, I figured it wasn’t what you wanted.
08:49:33 <WilliamHamilton[> but I'm convincing myself that I probably cannot hope for more than `newtype ((f :: k2 -> Type) :.: (g :: k1 -> k2)) (p :: k1)`
08:49:43 <julianleviston> Gah, I really should read messages better. You mentioned Data.Functor.Compose in your message :)
08:50:18 <WilliamHamilton[> julianleviston: np, thanks for reading nonetheless :)
08:50:26 <phadej> Compose is polykinded (in recent base)
08:50:34 <dmwit> WilliamHamilton[: It isn't easy to be polykinded over both Type and Constraint in a meaningful way (except to basically ignore the type of that kind).
08:51:10 <WilliamHamilton[> phadej: right, I wanted to plug Constraint, but i kinda see why that's an issue
08:51:36 <dmwit> WilliamHamilton[: That said, you might like Show1.
08:51:44 <WilliamHamilton[> dmwit: so the only alternative is define a typeclass synonym? Like class ShowFoo to say Show (Foo a)?
08:51:52 <dmwit> https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Functor-Classes.html#t:Show1
08:52:31 <Ucenna> how do I reason about events? I've been coding a prototype of a game in JS, and I'm to the part where I have to take user input. I just don't know how to do it functionally
08:52:35 <WilliamHamilton[> dmwit: unfortunately I have a GADTs with too many constraints I think to use Show1
08:53:01 <dmwit> Usually the problem is too few constraints, not too many. =P
08:53:42 <dmwit> Ucenna: Sounds like a good question for a JS channel...
08:54:28 <julianleviston> Ucenna: are you using GHCJS?
08:54:30 <WilliamHamilton[> dmwit: let me check better then! :D
08:55:19 <julianleviston> WilliamHamilton[: is all of this stuff you’re talking about in GHC manuals?
08:56:10 <julianleviston> Generally there’s no canonical reference for terms, is there?
08:56:59 <julianleviston> It’d be nice if there was a similar thing to the typeclassopedia, but for a general encyclopedia of haskell terms and links to papers that need to be read to understand them :)
08:57:12 <WilliamHamilton[> julianleviston: it's all in the Base library, but I don't think it's in the GHC manuals per se. You can just ask for terms here, I'm happy to answer (and be corrected by others) :)
08:57:31 <julianleviston> WilliamHamilton[: Yeah, I know. That’s what I’ve always done. 
08:58:46 <julianleviston> WilliamHamilton[: like… polykindedness. I don’t really want an intuitionalistic answer, though… I want a canonical reference. Obviously GHC implements it… and GHC generally has good docs… Just curious about whether Kinds and Types are treated formally in the docs. 
08:59:17 <julianleviston> Especially relevant since type in type or whatever that last adjustment was around that.
08:59:30 <lyxia> % :k Data.Functor.Compose.Compose
08:59:31 <yahb> lyxia: Data.Functor.Compose.Compose :: (k -> *) -> (k1 -> k) -> k1 -> *
09:00:25 <julianleviston> So much to learn.
09:00:42 <WilliamHamilton[> julianleviston: probably take a look at this https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/kind-polymorphism.html
09:00:46 <lyxia> WilliamHamilton[:  class f (g a) => Compose f g a ; instance f (g a) => Compose f g a
09:01:28 <julianleviston> WilliamHamilton[: ta… further proof I really should actually read the guide sometime :) 
09:01:51 <julianleviston> ugh… typo: This section describes kind polymorphism, and extension enabled by -XPolyKinds. 
09:01:59 <WilliamHamilton[> lyxia: as always, thanks! This is the right thing to say, is it implemented somewhere common?
09:03:25 <lyxia> there's one in sop-core
09:04:44 <lyxia> it's kind of a general purpose library, but I'm not sure whether a single class is worth the extra dependency
09:05:12 <WilliamHamilton[> and it's exported by generics-sop, great! I'm already using generics-sop there, it's perfect!
09:10:48 <Zvpun> Given `data Weird a = Weird a (a->); instance Foldable Weird where foldMap f (Weird a b) = f $a b`, would it still be a Foldable with `foldMap f (Weird a b) = f a`? (inspired by https://stackoverflow.com/a/8359609/1671066)
09:11:11 <glguy> Your definition of Weird isn't valid
09:11:31 <Zvpun> The difference being `f $ b a` replaced by `f a`. 
09:11:44 <Zvpun> Sorry, it should have been `Weird a (a->a)
09:13:03 <Zvpun> And another mistake in my original question `f $a b` should have been `f $ b a`.
09:21:57 * hackage mulang 4.4.0 - An intermediate language designed to perform advanced code analysis  http://hackage.haskell.org/package/mulang-4.4.0 (flbulgarelli)
09:22:58 * hackage mulang 4.0.0 - An intermediate language designed to perform advanced code analysis  http://hackage.haskell.org/package/mulang-4.0.0 (flbulgarelli)
09:23:57 * hackage mulang 4.3.0, mulang 4.2.1, mulang 4.0.1 (flbulgarelli): https://qbin.io/pupils-mats-j2qf
09:37:01 <Boarders> does anyone know a way to get better information out of cabal for why a build is failing to resolve dependencies
09:40:34 <WilliamHamilton[> lyxia: I have another question, this time not to understand how to do things, but on why things happen: consider https://pastebin.com/raw/y1QqLFcL in which I included two different definitions, one using `Compose Show Term` and the other `ShowTerm`, and the corresponding functions: now, showSubstW is fine, while showSubstW2 gives the error
09:40:55 <WilliamHamilton[>     • Overlapping instances for ShowTerm x
09:40:55 <WilliamHamilton[>         arising from a use of ‘showHelper2’
09:41:32 <WilliamHamilton[> I'd like to understand in detail why this difference happens, ideally understanding ghc thought process as it tries to typecheck the code
09:52:11 <Boarders> what does
09:52:12 <Boarders> constraint from non-upgradeable package requires installed instance
09:52:15 <Boarders> mean in cabal
09:53:12 <glguy> The base package is not upgradable separately from GHC,
09:53:45 <glguy> so if you have a dependency bound that excludes the version of base that comes with the GHC you're building with you'll need to change your version of GHC or fix the package
09:54:03 <Boarders> is there any way to get cabal to tell me which version it is having a problem with
09:54:07 <Boarders> which library rather?
09:54:12 <Boarders> do you know?
09:54:19 <glguy> That's probably in the output you're reading
09:54:41 <glguy> You can paste the command and output to gist.github.com if you need help interpreting it
09:55:41 <Boarders> thanks
09:55:47 <Boarders> I am getting this: https://gist.github.com/Boarders/352bf08ab1b8c5ddc97f3023e74bdee9
09:55:59 <glguy> [__1] rejecting: base-4.9.1.0/installed-4.9... (conflict: phylocomgraph =>
09:56:00 <glguy> base^>=4.12.0 && <4.13.0)
09:56:23 <glguy> That means you're using an old GHC, one that provides base-4.9
09:56:34 <glguy> but phylocomgraph demands at least 4.12
09:56:37 <Boarders> ah weird
09:56:38 <glguy> and less than 4.13
09:56:51 <glguy> so you'll need to install GHC 8.6.3
09:57:11 <glguy> You can have more than one GHC installed at a time, they coexist
09:57:22 <Boarders> yeah I have a bunch
09:57:40 <Boarders> ghc --version gives 8.6.3 but 'which ghc' points to 8.0.2 O___o
09:57:52 <ca1ek> are there compiled binaries of hie for windows available?
09:58:08 <ca1ek> it's been compiling for the last 3 hours for me and i'm surrendering
10:01:10 <Boarders> thanks for the help glguy!
10:05:28 <Boarders> does anyone know how to get a commit from a github project in a cabal build?
10:05:54 <Boarders> (the equivalent of what you would put in extra-deps in stack)
10:06:01 <Boarders> I think I heard this is possible with 2.4
10:19:14 <dmwit> Boarders: Probably `hash -r` will fix the discrepancy between which and not-which.
10:19:19 <dmwit> Boarders: (Assuming bash.)
10:19:29 <Boarders> dmwit: thank you!
10:20:04 <dmwit> Boarders: Anyway you can pass `-w` to `*-configure` to select a GHC independently of what's first on your PATH.
10:20:12 <Boarders> yeah I did cabal new-configure
10:20:27 <Boarders> probably best to do that always or specify in a project file
10:20:38 <Boarders> so at least I can be confident which version is being used
11:06:19 <Boarders> does anyone know if there is an equivalent in cabal for doing stack hoogle --server?
11:08:48 <bsima> Boarders: it's just the hoogle command
11:09:04 <bsima> https://github.com/ndmitchell/hoogle/blob/master/docs/Install.md#searching-a-hoogle-database
11:09:11 <Boarders> bsima: thanks!
11:10:20 <__monty__> Boarders: Here's what I run: hoogle server --local -p 8008 > $HOOGLELOG 2>&1 &
11:15:07 <gentauro> has anybody worked with `lattices`?
11:15:25 <gentauro> I found a nifty library with only `2` likes on Github :o
11:15:34 <gentauro> it's based on a Functional Pearl :D
11:15:50 <gentauro> I tried to implement the 2nd example from the paper: https://pastebin.com/A9T470CN
11:16:42 <gentauro> but I'm stucked at the `common` function. I don't know how to `bind` the `latice` wrapped values :(
11:16:58 <gentauro> I wrote a few mails to the author, but I think he got tired of me :D
11:20:07 <sternmull> I play with the idea to use Haskell to define tasks, dependencies, deadlines, resources for project planning. I then want to automatically schedule tasks that are partially unconstrained and generate html reports to see how the plan looks like. Is there anything in the ecosystem that already does something similar?
11:21:03 <gentauro> sternmull: are you asking for a project management tool written in Haskell?
11:23:08 <__monty__> Sounds like behaviour that would be pretty cool to have built-in to something like taskell.
11:23:21 <sternmull> gentauro: Yes. But I would be fine with defining my project as Haskell program and then just have some semi automatic planning and "reporting". So i don't necessarily need a fancy UI.
11:25:51 <gentauro> sternmull: sry, I don't know if such piece of software exists ...
11:26:12 <__monty__> Maybe you could use a fancy UIs data structures though? So as to make integration into the UI easier? The UI would benefit from the planning features and you would benefit from a UI from the get-go.
11:28:07 <Welkin> ui data structures?
11:28:09 <Welkin> what's that?
11:28:16 <Welkin> a rope?
11:28:40 <sternmull> At the moment i draw an SVG with inkscape to present the projects plan. MSProject is too primitive to express the facts. Haskell makes it easy to declare some typed data structures and then run some algorithms on them to produce HTML. So it might be better than the options i tried so far.
11:31:42 <sternmull> __monty__: I don't understand you. My idea to leave UI out is because i just don't have the time and patience to invest in user interface stuff. And i am totally ok with the idea to define the data directly as Haskell source.
11:32:38 <Welkin> user interface is easy with html+css and elm
11:33:05 <Welkin> you can even wrap the application in electron or a webview to run on a desktop
11:34:32 <sternmull> Yes, if everything works out then i will try something like that. But for now even static html files would be ok for the output.
11:35:06 <ca1ek> so I wrote my first thing in haskell, a rpn calculator, would love to be told what I could've done better :) https://gist.github.com/ca1ek/b8b898dab08b7d786d216e54fb6af80f
11:35:43 <rain1> yes its good
11:35:44 <rain1> parseCommand "+" stack = foldl (+) 0 (take 2 stack) : drop 2 stack
11:35:49 <rain1> you can write this better with pattern matching
11:36:04 <rain1> parseCommand "+" (a : b : stack) = a + b : stack
11:36:31 <rain1> something else to consider is the program breaks if it is not able to read the number
11:41:42 <__monty__> Welkin, sternmull: Funny how different people managed to misunderstand in different ways. Let's take taskell as an example (It's a kanban-esque system, not sure if it's suitable for your purposes.) The point is they already have a TUI, I assume they have some data structures behind that UI, Task for example or Project, whatever. If you reused those data types then your scheduler could output a valid 
11:41:48 <__monty__> taskell dataset. So taskell gains the scheduling feature and you have a nice TUI to actually use your scheduled tasks.
11:42:12 <ca1ek> rain1, damn, it looks so nice now with the pattern matching
11:42:48 <Welkin> pattern matching changes everything
11:42:58 <Welkin> look at how people program in lisp without pattern matching
11:42:59 <Welkin> it sucks
11:44:17 <ca1ek> i applied whatever i knew about lisp when writing that and yep it's not that funky
11:44:29 <__monty__> Pattern matching isn't as composable as other constructs though. That's actually a decent argument I've heard for using lenses over pattern matching. (I'm definitely *not* saying you should use lenses over pattern matching.)
11:44:44 <Nexilva> I found this: apt-repository ppa:hvr/ghc
11:45:01 <Nexilva> Is this where I can get latest haskell platform/ghc/cabal for Ubuntu 18.04
11:45:09 <Nexilva> https://launchpad.net/~hvr/+archive/ubuntu/ghc
11:45:22 <Nexilva> I forgot a question mark. 
11:45:22 <ca1ek> I now want to build a program to turn arith expressions into a syntax tree but I really can't even imagine how to do that in haskell
11:45:34 <geekosaur> lisp has it, it's cond. it just doesn't let you use it in declarations the same way Haskell does
11:46:01 <geekosaur> Nexilva, yes, and in fact I use that repo to get modern ghc, haddock, and cabal
11:46:09 <Nexilva> Ok thank you
11:46:36 <geekosaur> note that it installs to /opt/ghc so you'll need to add that to $PATH
11:46:56 * geekosaur should try to finish up his wrapper script at some point, right now it needs to be installed manually
11:55:11 <Boarders> <__monty__: thanks, what is the thing setting the HOOGLELOG variable if you will forgive my ignorance?
11:56:37 <__monty__> Boarders: Oh, it's just part of a script to start a tmux session with hoogle, an editor for cabal and other project files, an editor for source files and another window for shell commands like git. So it's just defined elsewhere in the script.
11:56:58 <__monty__> It's just a path.
11:57:05 <Boarders> oh ok
11:57:19 <Boarders> I thought it was an environment variable that was defined by running something
11:57:35 <__monty__> And you don't have to do the redirection to a file if you run it in its own window, unbackgrounded.
11:57:58 <__monty__> It's just that if you do background you're gonna want to redirect all the output.
11:59:47 <ca1ek> so the pattern (a : b : c) will make a and b the first two elements of the list and c the rest
12:00:13 <ca1ek> can i get a pattern like (a : "*" : c), so a is the list before an element "*", and c is past it?
12:00:59 <ca1ek> obv not with that syntax, but is there something like this
12:01:15 <catern> this tagless final stuff seems like something that should be taught in undergrad alongside basic CPS style and basic ADTs
12:01:20 <__monty__> ca1ek: Don't think so, at least not with basic patterns. But there's functions like splitAt, dropWhile, etc.
12:01:56 <doyougnu> @calek you can do that with zippers. You basically maintain a focus in the datastructure and a reference to the rest of it. In you case a focus in a list would be a single element and the context would be references to the left and right sides
12:01:56 <lambdabot> Unknown command, try @list
12:03:52 <iqubic> So `maybe x id y` is the same as `fromMaybe x y` right?
12:04:06 <iqubic> I think that's true.
12:04:09 <doyougnu> yea should be
12:04:33 <iqubic> Well, I've got a strange case where one of those compiles and the other doesn't.
12:04:47 <iqubic> I'm using Parsec to do some parsing, and it's being a bit weird.
12:06:01 <doyougnu> @type maybe
12:06:03 <lambdabot> b -> (a -> b) -> Maybe a -> b
12:06:10 <iqubic> So this parser is really really terrible, and I know that.
12:06:13 <doyougnu> @type fromMaybe
12:06:14 <lambdabot> a -> Maybe a -> a
12:06:21 <iqubic> But that's not the point of this.
12:06:34 <Boarders> does anyone know where I can find where cabal v2-install puts stuff?
12:06:37 <iqubic> So here's the code:
12:06:38 <iqubic> http://dpaste.com/1N2M1TA
12:06:49 <doyougnu> @type flip maybe id
12:06:50 <lambdabot> b -> Maybe b -> b
12:07:17 <iqubic> Note the line that says "let signString = maybe..."
12:08:16 <doyougnu> hmm is sign returning a Char instead of String?
12:08:28 <iqubic> No.
12:08:35 <iqubic> It's returning a String.
12:08:43 <iqubic> That code there compiles just fine.
12:08:52 <vaibhavsagar> is there a way to get Servant to do different things at the same endpoint depending on whether a GET or POST request is issued?
12:08:53 <iqubic> Compare it to this code please:
12:08:54 <iqubic> http://dpaste.com/29439MF
12:09:08 <vaibhavsagar> I don't need this for what I'm currently working on, just curious
12:09:24 <iqubic> All I did was change the line that says: `let signString = ...`
12:09:27 <ski> @index fromMaybe
12:09:27 <lambdabot> Data.Maybe
12:09:37 <iqubic> ski: I have that imported.
12:09:37 <ski> forgot to import `fromMaybe' ?
12:09:43 <doyougnu> the error is that fromMaybe ins't imported
12:09:48 <ski> well, then the error message is strange
12:10:11 <ski> what's the relevant `import' declaration ?
12:10:16 <iqubic> wait... is one of these functions in prelude, and the other isn't?
12:10:42 <ski> @index maybe
12:10:42 <lambdabot> Data.Maybe, Prelude
12:10:44 <ski> yes
12:10:52 <iqubic> ski: Looking back at my code, I see that I totally forgot to import Data.Maybe.
12:10:59 <iqubic> I feel stupid.
12:11:05 <geekosaur> ca1ek, not as a pattern. patterns operate on structure, not values; it can't search the list for a particular item, only describe structure in terms of constuctor chains
12:11:07 <doyougnu> iqubic: those are the good types of problems :)
12:11:08 <ski> mystery solved. great :)
12:11:57 <iqubic> So, I would have been able to look this up online, but I have a strange situation that prevents me from coding *AND* using the internet at the same time while at school.
12:12:04 <williamrusnack> What would be a good replacement for undefined in this case?
12:12:06 <williamrusnack> fst :: (Bifoldable1 t, Bifunctor t) => t a b -> a
12:12:06 <williamrusnack> fst = getFirst . bifold1 . bimap First (const $ First undefined)
12:12:36 <iqubic> See, I dual boot windows 10 and linux. My school's wifi is weird in that it only let's me connect to the internet in windows 10.
12:12:43 <iqubic> But I code in linux. 
12:12:51 <iqubic> So I can't do both at once.
12:12:59 <williamrusnack> The only other thing I can think of is error but that doesn’t seem any better
12:13:06 * iqubic hates his school wifi with a firery passion.
12:13:49 <iqubic> So aside from the rather stupid issue I was having, is there a way to improve this code at all?
12:17:28 <iqubic> I want to parse things of the form "-?[0-9]+(.[0-9]+)?" into a double. I don't care about checking for a leading `+` or an e bit at the end.
12:17:38 <iqubic> Also, wow. That regex looks horrible.
12:18:22 <iqubic> This is why I like Parsec better.
12:18:45 <iqubic> I feel like my code is way too vebose for what it does.
12:19:35 <jollygood2> Solonarv, was away. thanks for that page!
12:19:51 <doyougnu> iqubic: im confused about why you have maybe types in your parser like this? I typically use megaparsec but I thought when a monadic parser errors out it backtracks...
12:20:04 <doyougnu> so in a certain sense you already have a computational context that represents failure
12:20:26 <doyougnu> then most of your verbosity (the let statements) comes from handling the maybe type
12:21:17 <iqubic> doyougnu: I'm using optionMaybe from Parsec which returns Nothing in case of a failure.
12:21:41 <iqubic> I should figure out something else to do instead of that.
12:22:47 <iqubic> In my case I have 3 things. I have the possibility of a `-` sign, then the integer part, then the possibility of a decimal part.
12:23:12 <iqubic> I need someway to potentially fail. Like something other than what I currently have.
12:23:34 <doyougnu> and it fails if one of those fails right?
12:24:45 <jle`> williamrusnack: you can separate out the two
12:24:47 <iqubic> no.
12:25:27 <iqubic> If the attempt to parse a leading `-` fails, then I want to return a positive Double.
12:26:07 <jle`> williamrusnack: actually hm, nvm
12:26:07 <iqubic> if the attempt to read a decimal point followed by some digits fails, then I want to return a whole number.
12:27:01 <iqubic> "123" -> 123::Double "-23" -> -23::Double "2.3" -> 2.3::Double
12:27:03 <jle`> williamrusnack: what you want to write might not be possible
12:28:37 <iqubic> What I want is a parser combinator that returns the parsed string on success, and the empty string on failure.
12:28:55 <iqubic> Which I'm not sure parsec has.
12:29:32 <williamrusnack> jle`: Bifoldable seems to be the better option becuase it uses a monoid instance but that doesn’t guarantee that both a and b exist
12:29:56 <jle`> williamrusnack: Bifoldable doesn't gain anything here, since you can use monoids with Bifoldable1 as well
12:31:00 <williamrusnack> jle`: bifold1 :: Semigroup m => t m m -> m 
12:31:27 <iqubic> So is there a parser combinator that returns the parsed string on success and the empty string on failure?
12:31:59 <jle`> williamrusnack: all monoids are semigroups
12:32:06 <jle`> williamrusnack: so you can use bifold1 with monoids too
12:32:16 <jle`> try it :)
12:32:26 <doyougnu> iqubic: what you really want is to assume you parse a positive double, and then call (try $ string "-") for the sign. 
12:32:46 <doyougnu> iqubic: also i'm pretty sure megaparsec has double pre-defined if you were willing to not use parsec directly
12:33:00 <iqubic> I can switch to megaparsec.
12:33:03 <iqubic> That would be fine.
12:33:18 <iqubic> I haven't really committed to any one parsing library.
12:34:14 <williamrusnack> jle`: bifoldable1 uses semigroup so that both have to exist I cannot use mempty 
12:34:27 <williamrusnack> Could not deduce (Monoid b) arising from a use of ‘mempty’
12:34:40 <jle`> try using it with a specific monoid
12:34:53 <jle`> like how you used it with a specific Semigroup earlier
12:34:54 <doyougnu> iqubic: http://dpaste.com/2WNVKPC
12:35:12 <doyougnu> something like that is what it should look like. I haven't tested it at all tho
12:35:27 <iqubic> doyougnu: That's not quite what I have in mind.
12:35:39 <iqubic> What happens if you give the input "23" to that.
12:35:47 <jle`> > bifold1 (["hi"],["hello"])
12:35:50 <lambdabot>  error:
12:35:50 <lambdabot>      • Variable not in scope: bifold1 :: ([[Char]], [[Char]]) -> t
12:35:50 <lambdabot>      • Perhaps you meant one of these:
12:35:59 <jle`> @let import Data.Semigroup.Bifoldable
12:36:00 <lambdabot>  Defined.
12:36:01 <iqubic> I think it would fail prematurely and never actually return the 23
12:36:02 <jle`> > bifold1 (["hi"],["hello"])
12:36:05 <lambdabot>  ["hi","hello"]
12:36:12 <jle`> ^ see, it works fine with monoids like lists :)
12:36:20 <jle`> > bifold1 (["hi"],mempty)
12:36:22 <lambdabot>  ["hi"]
12:36:36 <jle`> my point was that using bifold vs. bifold1 doesn't gain you anything here, since bifold1 already works with monoids
12:36:45 <doyougnu> iqubic: ah it'll fail in that case you should use something like: nums <|> digits
12:37:02 <iqubic> How would that work?
12:38:08 <doyougnu> if nums fails, then it'll try to parse with digits: so on input 23, nums will fail at "char '.'", this causes the parser to backtrack and try the original input: 23, on the digits parser. Which in this case will succeed
12:38:20 <williamrusnack> jle`: with the given constraint would it allow me to differentiate between (a, b) and Either a b?
12:39:11 <williamrusnack> I’m trying ensure with the type system that both a and b exist
12:39:48 <jle`> not sure what you mean by differentiate
12:40:06 <jle`> but yeah, i don't think bifold1 would allow you to write a "provably total" fst
12:40:13 <jle`> the typeclass is not strong enough
12:41:52 <fendor> @src Control.Monad.Trans.Free.wrap
12:41:52 <lambdabot> Source not found. Take a stress pill and think things over.
12:42:05 <jle`> fendor: src doesn't actually look up any sources
12:42:10 <fendor> sammit
12:42:11 <jle`> it's basically an alias over 'note'
12:42:11 <williamrusnack> jle`: would that require a custom typeclass or is there a better existing typeclass
12:42:40 <fendor> jle`, a pity
12:42:48 <jle`> williamrusnack: that's a weird question to ask. the best way would be if you knew your specific type, you could just pattern match or use that type's specific API
12:43:41 <jle`> btw, `Either` being an instance of `Bifoldable1` should give you a hint that `fst` over all Bifoldable is not possibly total
12:43:45 <iqubic> So I was asking for a parser that would return "" on failure, and the string parsed on success. I found it.
12:44:00 <iqubic> option "" parser
12:44:20 <iqubic> Where option is the combinator, and parser is the parser to try.
12:44:22 <jle`> *fst over all Bifoldable1
12:44:39 <williamrusnack> jle`: totally missed that thanks
12:45:43 <iqubic> Since this is my first parser, I'm finding that I still have a ton to learn, even though I thought I knew the basics.
12:46:11 <doyougnu> iqubic: yea I still feel that way :p
12:46:46 <iqubic> Also, I'm going to try `option "" parser` to make my code cleaner
12:47:12 <doyougnu> iqubic: monadic parsers are really nice and declarative, so in general if you find yourself doing a lot of boxing/unboxing or type juggling you're doing something wrong
12:47:30 <doyougnu> you should do that at the top level
12:47:46 <doyougnu> option "" (nums <|> digits)
12:48:02 <jle`> williamrusnack: bifoldable1 ensures that "either fst or snd" exists
12:48:14 <iqubic> That's not where I was planning on putting it.
12:48:33 <iqubic> but yeah, that too.
12:48:51 <jle`> williamrusnack: if you want, you can accumulate the "first fst" or the "first snd" by using `These (First a) (First b)` from the 'these' library
12:49:07 <jle`> which has the appropriate Semigroup instance
12:49:40 <jle`> then `This (First x)` would be the first fst, and `That (First y)` would be the first snd
12:49:56 <jle`> and `These (First x) (First y)` would be the first fst and first snd, if they are both found
12:50:11 <williamrusnack> jle`: I was definitely wrong thanks for correcting me and pointing me to These
12:50:40 <jle`> williamrusnack: but also if you are working with a specific type, you should check out the type's specific API to see if a 'fst' is possible, without going through a typeclass :)
12:53:13 <williamrusnack> jle`: I have some newtypes that are from `(a, b)` and `data Foo a b = Foo a b`. It would be nices to derive the fst and snd functions
12:57:28 <williamrusnack> Thinking about it it must be possible to use the same lens to access `(a, b)` and `data Foo a b = Foo a b`
12:57:51 <geekosaur> _1 and _2?
12:59:25 <geekosaur> note that you'd have to makeLenses to get it for the data decl
13:00:34 <williamrusnack> geekosaur: that does seem a bit much just to access a single level data structure
13:01:03 <geekosaur> lens isn't magical. there's generics, but you need to derive Generic and it'll be slower
13:01:51 <geekosaur> and there is nothing automatically generated that says 'here are the fields comprising this data type'; the closest you get there is deriving Generic
13:02:03 <jle`> williamrusnack: "much"? it's just one line of code :)
13:02:08 <Boarders> another hoogle question but with a cabal project after I have done hoogle generate, how do I regenerate just for my project?
13:02:33 <jle`> but admittedly it's a lot of dependencies, if you don't already pull them in
13:03:45 <jle`> actually, TH doesn't gain too much over Generics (besides speed) here.  it's impossible to implement makeLenses in general with only Generics, but it's possible to implement _1, _2, etc.
13:04:39 <jle`> at least, the monomorphic versions
13:04:49 <jle`> i guess we still need TH to write the 'type changing' _1/_2 ...
13:05:17 <cocreature> generic-lens ;)
13:05:24 <jle`> hm actually, maybe not. it might be possible, i haven't thought it through enough
13:05:34 <jle`> cocreature: the problem is that generics can't dynamically generate identifiers
13:06:13 <geekosaur> generics can do this specific one, you'd be using an index instead of an identifier
13:06:24 <geekosaur> and it'll be slow and probably ugly
13:06:24 <jle`> oh, huh, generic-lens uses the fancy HasName feature
13:07:06 <jle`> but yeah, generic-lens can't directly generate actual Haskell identifiers
13:07:11 <jle`> only TH can do this at the moment
13:07:25 <jle`> that's what i mean when i say that makeLenses can't be implemented in terms of Generics
13:07:31 <cocreature> right but generic-lens sidesteps that issue fairly elegantly
13:08:37 <argent0> hi, is there a way to control the verbosity of errors for type holes?
13:09:10 <geekosaur> nope
13:09:23 <argent0> geekosaur: ok, thanks
13:09:25 <jle`> there are some ghc flags you could pass in to control how many suggestions/in-scope bindings are shown, i believe
13:09:41 <argent0> jle`: yes I saw those
13:09:50 <williamrusnack> jle` & geekosaur: thanks for the input. I’ll consider my options
13:09:50 <jle`> is that not the sort of control you are looking for?
13:10:28 <ca1ek> does haskell have something like rust's Debug print?
13:10:40 <jle`> williamrusnack: so yeah, with generic-lens, you could write `view (position @1)` and `view (position @2)` for fst and snd
13:11:19 <jle`> but it should be slower than directly writing it, since generic-lens has to basically convert the data type into a linked list, and traverse the number of items to get there
13:11:19 <cocreature> ca1ek: nothing better than Show
13:11:21 <argent0> jle`: I want to know the hole type, but that get's scrolled. Good thing is the first thing it prints, but it's also the first things that gets out of the screen
13:11:36 <cocreature> argent0: use ghcid :)
13:12:30 <cocreature> there is actually a patch for compact hole output https://github.com/kosmikus/ghc-compact-holes but I don’t think it’s been merged yet
13:13:06 <argent0> cocreature: ghcid looks nice, I'll check it out
13:13:34 <cocreature> argent0: the great thing about ghcid is that it’s really simple so contrary to a lot of other Haskell tooling it’s also a lot less fragile
13:14:45 <ca1ek> cocreature: how do I use this though. 
13:15:57 <cocreature> ca1ek: apply "show" to a value that is an instance of Show and you get back a String
13:16:01 <cocreature> > show 1
13:16:03 <lambdabot>  "1"
13:17:15 <ca1ek> I have my own Tree type implemented, how do I make it an instance of show?
13:17:28 <doyougnu> calek: there is trace from Debug.Trace, but it is better to us show/ghcid
13:17:37 <cocreature> add "deriving Show"
13:17:40 <vaibhavsagar> ca1ek: you can do `deriving Show`
13:17:45 <cocreature> e.g. data Tree a = 
13:17:51 <cocreature> data Tree a = … deriving Show
13:18:01 <ca1ek> nice
13:18:32 <vaibhavsagar> haskell is pretty nice
13:19:20 <vaibhavsagar> hey, is there any way to write a Servant API endpoint that behaves differently for GET and POST requests?
13:22:16 <ski> ca1ek : normally, you shouldn't (and don't need to) handwrite instances of `Show' and `Read'. a common exception is when you are making an abstract data type. fwiw, if you sometimes would want to pretty-print in some custom syntax, then `Show' is not for that. `Show' and `Read' are intended to use Haskell syntax, so that you could copy and paste over the string as representing a Haskell expression yielding a value equal to the original
13:30:09 <c_wraith> ski, or, sadly, if you're using infix data constructors with differing precedence and want minimal parents.
13:30:13 <c_wraith> *parens
13:30:29 <doyougnu> ^^
13:34:26 <ca1ek> I'm using splitOn to split a list over a predicate, but it splits over all matching elements in the list
13:34:33 <ca1ek> I want to only split over the first element found
13:36:56 <bsima> does anyone know how to get a tuple of things out of JSON with Lens.Micro.Aeson?
13:37:15 <__monty__> ca1ek: It sounds like you're looking for Data.List.break
13:37:53 <ca1ek> __monty__, thanks!
13:38:57 <__monty__> bsima: Is the tuple of a fixed size?
13:39:39 <bsima> actually I want to get two keys and put them in a tuple, sorry
13:40:33 <hyperisco> what is the best thing you've learned about Haskell lately?
13:40:51 <bsima> lenses. also the most difficult
13:42:07 <bsima> here is the solution with regular lens https://github.com/danidiaz/lens-aeson-examples/blob/master/src/Data/Aeson/Lens/Examples.hs#L135
13:42:23 <__monty__> bsima: I don't see anything but (jsonVal ^? key "a", jsonVal ^? key "b")
13:46:15 <bsima> __monty__: what if jsonVal is an array of objects, and I want to get these keys for every object?
13:46:31 <bsima> I want to end up with a list of tuples
13:52:03 <ski> c_wraith : aye
14:03:11 <bsima> figured it out
14:03:52 <bsima> let f v = (f ^. key "a", f ^. key "b")
14:04:07 <bsima> map f (jsonVal ^.. values)
14:04:20 <bsima> tahnks for the idea __monty__
14:25:57 <fendor> :t wrap
14:25:58 <lambdabot> error: Variable not in scope: wrap
15:06:05 <Nexilva> Hi. I had installed packages from ubuntu 18.04 default repositories, and then I think I updated stack manually and ended up with `which stack` = /usr/local/bin/stack and my goal is to remove all the distro packages of haskell/ghc/ (is stack also packaged?) and then install them from ppa:hvr/ghc. So far I have removed libghc* and that has gotten rid of a lot of stuff. I didn't want to have old package files
15:06:06 <Nexilva> on default locations in distro, and then ppa installs them in /opt, and that will duplicate things and i'm a bit low on space.
15:07:10 <Nexilva> What I am asking is, the stack that I have, I can't find out in apt-file search stack|grep bin, so I don't know where /usr/local/bin/stack came from. And I also have ~/.stack/ which is 1.3 gb, I'm not sure what to do with that, that carried over from my debian system a year ago, so it's old maybe.
15:07:27 <iqubic> So I'm looking for a specific thing in parsec. I want a parser combinator that parses one string with parserA and another string with parserB and returns the concatination of the strings. This should fail if either parser fails.
15:07:32 <Nexilva> Can I remove ~/.stack/ ?
15:09:18 <Nexilva> Currently I'm looking to start my installation of ghc over from the ppa which has the latest packages, and get rid of everything haskell related apart from xmonad which is my wm. Or am I thinking too much?
15:12:20 <iqubic> So anyone know what I should do?
15:13:39 <jollygood2> iqubic, off hand and untested:   liftA2 (++) parserA parserB   or if you prefer do:  do x <- parserA; y <- parserB; return (a ++ b)
15:15:19 <Nexilva> https://github.com/commercialhaskell/stack/issues/3563 I found this. I think that should be sufficient. I don't know if I need to remove ~/.stack or not, the ppa said it will install in /opt and I dont' want thing to get duplicated
15:19:13 <iqubic> jollygood2: Yeah, that works.
15:19:28 <iqubic> Thanks.
15:21:15 <jollygood2> if this is parsec (and I think also megaparsec), you can also do this for better error message: parserC = (liftA2 (++) parserA parserB) <?> "foo" . then you'll get "expected foo", instead of message relevant to parserA or parserB
15:22:21 <iqubic> jollygood2: This is parsec.
15:22:25 <merijn> Does Parsec not have a monoid instance?
15:23:00 <iqubic> I'm not sure.
15:23:07 <iqubic> I'm using this, and it works:
15:23:08 <iqubic> http://dpaste.com/0MZJ68G
15:23:11 <merijn> Megaparsec does (incidentally, I would advice using megaparsec over parsec for new parsers)
15:23:17 <jollygood2> merijn, it does
15:23:55 <merijn> jollygood2: Then you could just do "parserA <> parserB", even nicer :)
15:24:17 <iqubic> merijn: Yeah. That works.
15:24:30 <jollygood2> yep
15:24:55 <iqubic> So now I have a way of parsing numbers.
15:25:15 <iqubic> The numbers can be positive or not, and have a decimal portion or not.
15:25:52 <aranea> The glib package is failing to build for me, with the error message "Error in C header file". Does someone know which program is emitting this error? I'd like to have a look at the responsible parser.
15:26:04 <philippD> I remember that there is a way to tell GHC to make datatypes strict by default, but forgot how to do it. Does anyone know how?
15:26:25 <merijn> philippD: !
15:26:32 <zachk> aranea try -v3 with cabal 
15:26:35 <iqubic> testParse num "-.1" -> -0.1
15:26:42 <merijn> philippD: As in "data Foo = Foo !MyData"
15:26:45 <iqubic> testParse parser = parse parser ""
15:27:30 <iqubic> Yeah, I was able to make it so that if you don't want any whole numbers, you can just get 0 as the integer portion.
15:27:32 <philippD> merjin: I remember that there is a language extension or compiler flag to make that the default
15:27:48 <philippD> ^ merijn
15:28:05 <aranea> zachk: I tried that already. The last program invocation before the error is /usr/bin/ghc-pkg, but grepping the ghc sources for this error message doesn't turn up anything.
15:29:00 <iqubic> philippD: Try the StrictData pragma
15:29:01 <merijn> philippD: StrictData, maybe?
15:29:06 <jneira> philippD: maybe simply LANGUAGE Strict?
15:29:14 <iqubic> It's StrictData.
15:29:17 <jollygood2> iqubic cool. writing parsers in haskell is pretty enjoable 
15:29:17 <geekosaur> aranea, I'd expect that to come from either Configure, or hsc2hs
15:29:30 <geekosaur> re Strict / StrictData: do NOT use them blindly
15:29:59 <merijn> Personally I would recommend liberal use of ! in datatypes as wiser than StrictData
15:30:20 <philippD> geekosaur: why shouldn't I just use these extensions?
15:30:24 <iqubic> I have an Emacs plugin that lets me type "lang" and then hit tab and I get a searchable list of all the possible pragmas. And then it adds the right template stuff.
15:30:36 <geekosaur> you basically get to write your own support for it, practically every library assumes laziness and will break if applied under them
15:30:45 <geekosaur> theyre not the same as putting ! on every value
15:31:13 <iqubic> That makes it really convinient to find the right pragma.
15:31:14 <geekosaur> StrictData is less fragile than Strict
15:31:34 <aranea> Ahh, got it, it's gtk2hs-buildtools. Thanks, everyone!
15:31:34 <iqubic> Also, I love that you can have a default catch all branch in case statements.
15:31:52 <iqubic> Like `_ -> CODE HERE`
15:31:57 <aranea> Now, let's see if I can fix their broken parser.
15:32:04 <geekosaur> ahh, gtk2hsc2hs
15:32:18 <philippD> geekosaur: according to the doc StrictData does exactly that: add ! to on every value in datatype definitions: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-StrictData
15:32:35 <iqubic> Why the heck would you ever want a parsec parser with the user state of something other than ()?
15:32:38 <geekosaur> iirc it does a bit more. less than Strict does but can still catch you out
15:32:57 <iqubic> In fact, for my own sanity I'm using this: type Parser = Parsec String ()
15:33:57 <merijn> iqubic: I would probably recommend going with Text over String from the start, but yeah, everyone uses newtypes for parsec (so you can easily switch to/from String/Text, for example ;))
15:34:32 <iqubic> merijn: Why is Text a better idea to use?
15:35:07 <merijn> iqubic: Because Text > String for anything longer than, like, 20 characters ;)
15:35:21 <jle`> iqubic: all parsec parsers already have state: the source position
15:35:35 <jle`> adding your own state accounts for similar stateful things
15:35:41 <jle`> if you want to keep track of it ever
15:36:02 <iqubic> I don't want to.
15:36:07 <jle`> right
15:36:11 <jle`> usually it's not used
15:36:15 <jle`> but there are reasons why it would be useful
15:36:20 <iqubic> Also, I wrote my own utility function like this:
15:36:23 <iqubic> testParse parser string = parse parser "" (T.pack string)
15:36:25 <jle`> (this is to answer your question "why would you ever want...")
15:36:46 <iqubic> Which takes a string and parses it with a given parser as a way to test things out.
15:36:58 <iqubic> Why is ParserT a thing?
15:37:11 <iqubic> What monad would you want in addition to a Parser?
15:37:23 <jle`> do you mean why ParserT is a thing separate from Parser
15:37:36 <merijn> iqubic: IO? ;)
15:37:37 <kadoban> iqubic: IO, state
15:37:55 <merijn> iqubic: Simple example: Parsing C style include files you wanna do IO to load the header file during parsing
15:38:28 <iqubic> jle`: I understand why ParserT is a different thing from Parser. Some people just want a Parser with no Monad transformer.
15:39:13 <iqubic> I'm aware that `Identity` is not the same as `no monad` but it's close enough.
15:39:21 <jle`> iqubic: right, but your original question "why does ParserT a thing" could be interpreted as "why do parser combinators exist" in general. but i think from context, you mean "why would you want to make Parser a monad transformer"
15:39:26 <jle`> from further reading
15:40:06 <iqubic> So is my testParse function alright? I feel like there are some issues with using text's pack function.
15:40:10 <iqubic> testParse parser string = parse parser "" (T.pack string)
15:40:17 <jle`> what's wrong with text's pack?
15:40:23 <iqubic> Isn't it slow?
15:40:47 <jle`> hm...where did you read/hear that?
15:40:48 <merijn> iqubic: Not slower than String itself :p
15:40:57 <iqubic> That's just my opinion.
15:41:01 <jle`> did you benchmark?
15:41:03 <jle`> ah.
15:41:05 <iqubic> No.
15:41:08 <merijn> iqubic: Also, for testing that's not gonna matter
15:41:09 <jle`> what informs your opinion? what evidence are you looking at?
15:41:36 <merijn> iqubic: And when you do start parsing data from files you just wanna do your IO directly in Text and skip String altogether
15:41:52 <iqubic> You can do IO from Text?
15:41:58 <iqubic> I did not know that.
15:42:01 <jle`> iqubic: are you saying that you are guessing that T.pack is slow, without any evidence to back it up?
15:42:10 <jle`> or are you saying that it is your opinion coming from looking at evidence and weighing the facts
15:42:25 <merijn> iqubic: No, I'm saying there are IO functions that return Text
15:42:49 <jle`> i guess i'm asking, is it a "fact-based opinion" or a "blind guess opinion"
15:42:52 <merijn> iqubic: So instead of "readFile :: FilePath -> IO String", there is "Data.Text.IO.readFile :: FilePath -> IO Text"
15:43:04 <iqubic> jle`: It's a blind guess.
15:43:08 <jle`> ah, ok
15:44:07 <jle`> in that case, no, text's pack is not slow
15:44:11 <merijn> iqubic: In fact, Data.Text.IO has text versions of all the usual file/handle/etc. operations that are drop in replacements for the String versions, except they don't suck ;)
15:44:25 <iqubic> I did not know that at all.
15:44:51 <iqubic> I have no experience with Haskell IO. I mostly just do things in the REPL.
15:46:49 <merijn> iqubic: The problem is basically that String is linked list of Char. Which is fine for simple things and makes it easy to write simple recursive functions, it's however...not great for dealing with substantial pieces of text (say, big source files, etc.) because linked lists are cache unfriendly and String is memory hungry
15:47:46 <merijn> iqubic: Text, on the other hand, is a dense array/blob of unicode encoded text with efficient operations on it. Since it's a dense blob it's more cache friendly and less memory hungry, so once you start doing things like parsing files it's recommend to use Text
15:48:46 <EduardoBautista> Hello!   Does anyone have experience caching the build from `stack build` on Azure Pipelines?
15:50:16 <wroathe> :t withArgs
15:50:17 <lambdabot> error: Variable not in scope: withArgs
15:50:26 <wroathe> :t System.Environment.withArgs
15:50:28 <lambdabot> [String] -> IO a -> IO a
15:51:28 * hackage dynamic-graphs 0.1.0.2 - Dynamic graph algorithms  http://hackage.haskell.org/package/dynamic-graphs-0.1.0.2 (JasperVanDerJeugt)
15:52:12 <wroathe> Say I've got a WriterT [a] IO r, how would I use withArgs with the writerT value in place of the IO a?
15:52:49 <glguy> wroathe: You'd runWriterT first
15:52:55 <wroathe> In particular, I'd like to run withArgs ["my", "args"] prior to a "describe" call in hspec
15:54:06 <wroathe> http://hackage.haskell.org/package/hspec-2.6.1/docs/Test-Hspec.html#v:describe
15:54:26 <wroathe> Hmm, so then I'd have to wrap it back up in a WriterT (aliased to SpecM in Hspec), right?
15:55:34 <wroathe> To continue defining my "spec tree"
15:58:12 <merijn> wroathe: Honestly, this entire typeclassy pseudo language that's hard to integrate with other code is why I've never really liked hspec
15:59:31 <merijn> wroathe: What testing library are you using with hspec? hunit? quickcheck?
15:59:56 <wroathe> hspec as is, which depends on hunit
16:00:02 <iqubic> What is the typeclass pseudo language? What does that even mean?
16:00:08 <wroathe> and hspec-expectations
16:00:13 <wroathe> for assertions
16:00:23 <merijn> iqubic: hspec has this weird sort of DSL style thingy it wants you to write
16:00:44 <iqubic> what is hspec?
16:00:48 <iqubic> Never used it.
16:00:52 <merijn> iqubic: A test running framework
16:01:06 <iqubic> Why not use quickcheck?
16:01:38 <merijn> iqubic: QuickCheck is nice for a specific type of tests, testing frameworks let you build on top of things like quickcheck
16:01:41 <wroathe> :P hspec seems to work fine for my needs
16:01:50 <wroathe> In this particular case it's not hspec's fault
16:02:00 <wroathe> I'm just a noob when it comes to monad transformers
16:02:15 <merijn> wroathe: It is kinda the fault of that transformer, tbh :p
16:02:52 <merijn> wroathe: Might be worth having a look at tasty, but if you're already invested in hspec, it might not be worth the effort to switch
16:04:05 <xcmw> Are there any downsides to arrowized functional reactive programming?
16:04:21 <wroathe> merijn: I can't say that I'm invested but, again, it seems to do exactly as I want and is pretty well maintained. My guess would be that he/she even has a function that does exactly what I want that I'm just too much of a noob to recognize
16:04:28 <wroathe> I'll keep digging
16:05:55 <merijn> wroathe: Tasty is pretty well maintained too and (has bindings for hunit, quickcheck, the usual suspects)
16:07:33 <merijn> wroathe: The nice thing is that the hunit wrapper directly deals with "IO ()" (see: https://hackage.haskell.org/package/tasty-hunit-0.10.0.1/docs/Test-Tasty-HUnit.html#v:testCase ) Assertion is just your "IO ()" test case that you could wrap with withArgs
16:08:37 <wroathe> As a side-note, I'm surprised that System.Environment doesn't expose a withEnv analog of withArgs
16:08:48 <wroathe> withArgs is super handy for testing
16:09:39 <merijn> wroathe: It's because that's not necessarily portable and also, modifying the environment is kinda tricky to do safely
16:10:03 <wroathe> I can't see a use-case for either in actual production code
16:10:07 <wroathe> But from a testing pov it's handy
16:11:18 <OmegaDoug> I'm looking to parse a combination of strings of three different lenghts. I have one parser for each length of string which all work, but I'm unsure how I can combine them
16:11:23 <OmegaDoug> https://gist.github.com/DouglasBrunner/bb3afe46f5cca67b6891c4c7c32d85ea
16:12:33 <OmegaDoug> The shorter strings always end up matching on the longer string causing a false positive
16:13:16 <merijn> OmegaDoug: FYI "count 1" is redundant :)
16:13:28 <merijn> "count 1 foo" is just "foo" when it comes to parsing :)
16:14:08 <merijn> OmegaDoug: As for the ordering, <|> is left-biased, so if shorter tokens can be prefix of longer ones, you'll want to try and parse the long tokens *first*
16:14:39 <merijn> OmegaDoug: So destToken = tripleDestToken <|> doubleDestToken <|> singleDestToken
16:14:51 <merijn> OmegaDoug: That way it will only try the short ones after the long ones have failed
16:16:28 <OmegaDoug> So that produces an error,
16:16:29 <OmegaDoug> the parser is expected to fail, but it parsed: "AD"
16:16:57 <OmegaDoug> merijn: maybe it's an issue with the test suite
16:17:27 <jollygood2> is there a nicer way of writing this? put =<< over x lens <$> get
16:18:07 <OmegaDoug> merijn: I think the issue is that "ADM" fails on the longer parser, but incorrectly passes on the doubleDestToken.
16:18:20 <jollygood2> put =<< over lens f <$> get  , even
16:19:04 <geekosaur> doesn't that need some "try"s?
16:19:09 <OmegaDoug> merijn: the doubleDestToken is parsing the "AD" or "ADM", but the doubleDestToken should only succeed if it's "AD="
16:19:27 <OmegaDoug> merijn: the "AD" *of* "ADM"
16:19:36 <glguy> geekosaur: depends on the library that's being used if string needs a try or not
16:22:01 <OmegaDoug> geekosaur: It could use some try's, 
16:22:39 <glguy> OmegaDoug: The different parser combinator libraries don't all work the same way; you have to tell us which you're using
16:22:56 <OmegaDoug> glguy: I'm using Megaparsec.
16:23:03 <glguy> that one doesn't need try around string
16:23:30 <OmegaDoug> Right now I'm wondering if I can include the equal sign in the token and parse from smallest to largest
16:27:27 <OmegaDoug> So I found a solution which works, but it seems dirty because it uses more than just the destination token
16:27:28 <OmegaDoug> singleDestToken = string "D=" <|> string "A=" <|> string "M="
16:27:36 <OmegaDoug> doubleDestToken = string "AM=" <|> string "MA=" <|> string "MD=" <|> string "AD="
16:27:42 <OmegaDoug> tripleDestToken = string "AMD="
16:27:50 <OmegaDoug> destToken = singleDestToken <|> doubleDestToken <|> tripleDestToken
16:28:05 <OmegaDoug> I think there should be a way to do this without including the = sign in the parsers
16:28:54 <glguy> You can either to a lexer pass first, or your can order your tokens longest to shortest
16:34:33 <OmegaDoug> So ordering them longest to shortest works for the happy path, but this test fails
16:34:40 <OmegaDoug> parse destToken "" `shouldFailOn` "ADM"
16:35:10 <OmegaDoug> The tripleDestToken fails, but the doubleDestToken passes on "AD", when I need it to fail
16:35:42 <wroathe> OmegaDoug: Post code again?
16:36:55 <OmegaDoug> wroathe: https://gist.github.com/DouglasBrunner/bb3afe46f5cca67b6891c4c7c32d85ea
16:36:57 <Nexilva> I have used the ubuntu ppa, installed cabal-install-2.4, then cabal update, cabal install cabal-install, then removed the distro package, now I have cabal in $HOME. I also installed xmonad and it's contrib, removed the distro packages. I have got stack latest updated. I have removed all the ghc and libghc packages of the distro, and now I need to figure out how to get ghc using stack of cabal. I type cabal
16:36:59 <Nexilva> install ghc and that fails. Do you know how to do this?
16:37:03 <glguy> OmegaDoug: If you want to enforce that the whole string is consuemd you'll use endOfFile
16:37:03 <OmegaDoug> I've updated the Gist with the current revision
16:37:26 <glguy> err, it's eof, not endOfFile
16:37:31 <geekosaur> Nexilva, that sounds ... confused at bestr
16:37:33 <Nexilva> Can you get ghc/ghci and libghc required packages from cabal or stack?
16:37:36 <geekosaur> also ghc is not installable via cabal
16:37:53 <Nexilva> geekosaur: well, I have removed all the distro stuff, and used cabal2.4 in $HOME/.cabal/bin to install everything.
16:37:57 <geekosaur> also if you are using stack then you don't need a ghc from elsewhere, stack will install aand manage its own
16:38:03 <Nexilva> geekosaur: now I need to get ghc
16:38:10 <Nexilva> Oh
16:38:13 <Nexilva> stack has a ghc?
16:38:32 <Nexilva> hm. I don't have ghc on my command line. I wonder if I need to add a stack thing to my path
16:38:38 <geekosaur> if you used hvr's distribution then you need to add /opt/ghc/bin to your $PATH
16:38:38 <geekosaur> stack should install its own. but you must do everything throiugh stack
16:38:49 <Nexilva> stack run ghc or something, I saw in the help page
16:38:55 <jollygood2> stack downloads and installs ghc that project you are trying to build needs
16:38:57 <geekosaur> in patticular, you can't just run ghc, it will be stack ghc ...
16:39:28 <OmegaDoug> glguy: I'll look at eof,
16:39:29 <OmegaDoug> Thanks
16:40:21 <Nexilva> jollygood2: oh. so there is no need to have a sytem wide stack ghc installed?
16:40:34 <Nexilva> when I do stack ghc it wants to download to a private location or something
16:40:41 <jollygood2> Nexilva there isn't
16:40:59 <jollygood2> on the other hand, system ghc doesn't bother stack either
16:41:11 <Nexilva> awesome
16:41:21 <Nexilva> Whew, finally. Took a few hours but I think I got it.
16:41:40 <zachk> Nexilva, may I ask why you want to remove so much? 
16:41:47 <Nexilva> Well, distro packages were very old, so I wanted latest
16:41:52 <Nexilva> zachk: ^
16:42:07 <zachk> oh
16:42:10 <Nexilva> I wanted everything to be in my $PATH in bashrc and everything in $HOME
16:42:15 <Nexilva> no matter which distro I am on. 
16:42:24 <zachk> couldn't get the haskell platform for your distro? 
16:42:28 <Nexilva> kind of helps and keeps things updated free of older distro paackages
16:42:39 <Nexilva> 18.04 ubuntu is behind slightly.
16:42:43 <Nexilva> xmonad is also 0.13
16:43:50 <zachk> is that bionic beaver? 
16:44:07 <Nexilva> Indeed sir
16:44:56 <Nexilva> geekosaur: I wanted to get away from even the ppa packages. Now my haskell dev stack is independent of distro packages fully, other then xlib-dev packags.
16:45:10 <OmegaDoug> glguy: eof worked as expected. ;)
16:45:16 <OmegaDoug> glguy: thanks again
16:45:24 <zachk> Nexilva, you don't usually need the very latest ghc to have a workable haskell install
16:45:36 <geekosaur> Nexilva, the dwn side to that is now you need to do everything the stack approved way
16:45:47 <Nexilva> I don't see that as a downside.
16:46:00 <Nexilva> I have no idea what I'm doing. I think I need some stack approved guidance.
16:46:01 <geekosaur> it tends to be rather insistent on its own way of doing things. in particular, you will need a custom build script for xmonad
16:46:16 <geekosaur> stack will not guide you, it will simply do odd things or error out
16:46:37 <Nexilva> I suppose this is the proper way or haskell way?
16:46:50 <geekosaur> no
16:46:54 <Nexilva> Hm.
16:46:57 <geekosaur> it is the fpcomplete corp way
16:47:50 <Nexilva> Well, whatever. We'll learn as we go. Np.
16:48:02 <Nexilva> By we I mean all the people in my head.
16:48:40 <zachk> how many are in your head Nexilva ? :) 
16:49:27 <Nexilva> Too many to count.
16:50:16 <Nexilva> I did stack ghc and it installed, but it said this: https://paste.ee/p/dFhOv
16:50:25 <zachk> the correct medication can seriously help with that, if it annoys you 
16:50:56 <Nexilva> s/medication/meditation/
16:52:21 <Nexilva> However, the version command reveals: The Glorious Glasgow Haskell Compilation System, version 8.6.3
16:52:35 <Nexilva> Messages confused me here.
16:53:51 <zachk> if meditation works for you, more power to you :) 
16:54:06 <zachk> thats pretty new nexilva
16:55:09 <Nexilva> Yeah, the `stack install ghc` said, The following package identifiers were not found in your indices: ghc-8.6.3, but it still installed it. 
16:55:12 <Nexilva> So that's confusing.
16:55:19 <Nexilva> Mabye the error message means something else.
16:55:50 <glguy> stack install is for installing packages
16:55:57 <glguy> stack setup is for installing GHC
16:56:04 <Nexilva> I did stack ghc and it wanted to install things
16:56:18 <glguy> stack ghc is for *running* the ghc executable
16:56:22 <Nexilva> `stack ghc` and it wanted to fetch 
16:56:28 <glguy> are you having fun yet?
16:56:31 <Nexilva> Exactly. I have no system wide ghci to run and program yet
16:56:35 <Nexilva> Immensely.
16:56:41 <glguy> stack doesn't use a system-wide GHC, so that's OK
16:56:56 <Nexilva> yeah, it said in the docs it doesn't interfere and geekosaur also did.
16:57:10 <glguy> Have you tried stack setup yet?
16:57:58 <geekosaur> ghc is not a package as such. there is a ghc package, but it's a compiler library that is installed with and part of the compiler
16:58:07 <Nexilva> stack is setup already
16:58:11 <siborgium> Does stack work well with pacman packages?
16:58:55 <geekosaur> it won't use or work with other packages
16:59:00 <geekosaur> it installs and manages its own, separate from anything else
16:59:01 <Nexilva> https://paste.ee/p/SsJXN so xmonad --recompile says this, becuase there is no systemwide ghc. geekosaur you said something about a custom build script, I think I need to address that now. How can I recompile xmonad and tell it to use ghc in stack instead of system wide?
17:00:00 <siborgium> Ok, and if I run ghc from stack, would it somehow detect pacman packages like cabal?
17:00:08 <geekosaur> you don't recompile xmonad. you set up a build script that xmonad will use. I'm looking for it
17:00:16 <geekosaur> siborgium, again, it will not see or use them
17:00:28 <siborgium> ok, thanks
17:01:05 <Nexilva> https://github.com/commercialhaskell/stack/issues/710
17:01:06 <Nexilva> I found this
17:01:10 <geekosaur> https://github.com/xmonad/xmonad-testing/blob/master/build-scripts/build-with-stack.sh
17:01:16 <Nexilva> oh ok
17:01:58 <Nexilva> # The directory holding your source code and stack.yaml file: <- what directory would this be?
17:02:21 <Nexilva> I did cabal install xmonad
17:02:53 <glguy> Stack is its own little world, you don't use it with cabal
17:03:56 <glguy> L
17:04:23 <Nexilva> I need to find out what path to put here int his constatn
17:05:06 <Nexilva> I have this ~/.stack/global-project/stack.yaml
17:05:10 <geekosaur> Nexilva, you have an xmonad.hs file normally with your configuration. that will be where you want to point the script
17:05:17 <Nexilva> oh
17:05:17 <geekosaur> that si not the stack.yaml it wants
17:05:34 <Nexilva> but there is no stack.yaml in my ~/.xmonad
17:05:38 <geekosaur> you will need a stack.yaml that tells stack how to build your xmonad configuration
17:05:48 <Nexilva> I see.
17:05:52 <geekosaur> I cannot tell you how to make one
17:06:02 <Nexilva> Do you have examples ohers have made?
17:06:04 <Nexilva> others*
17:07:39 <geekosaur> I just checked where I found the build script and don't see one
17:07:54 <geekosaur> you might ask in #xmonad if anyone's doing this
17:08:07 <Nexilva> ok
17:08:19 <geekosaur> I personally find stack more trouble than it's worth
17:08:20 <Nexilva> So how would you get the latest xmonad on ubuntu 18.04?
17:09:03 <geekosaur> but I also do some xmonad development, so I keep local checkouts of it instead of installing released versions
17:09:20 <Nexilva> there is a stack here: https://github.com/commercialhaskell/stack/issues/710#issuecomment-289150630
17:09:25 <Nexilva> Check that post out. What do you think?
17:09:36 <zachk> iirc Nexilva you can just cabal install xmonad last I knew 
17:09:37 <Nexilva> Seems like you specify flags and packages, and I don't know what a resolver is
17:09:51 <Nexilva> zachk: I did but in order to recompile it using ghc in stack, i need to do this.
17:10:32 <zachk> just use a systemwide ghc instead of stack
17:10:41 <Nexilva> I wanna mess with this first.
17:10:43 <Nexilva> If I fail, sure.
17:11:28 <Nexilva> https://docs.haskellstack.org/en/v1.0.2/yaml_configuration/ let's see
17:44:49 <AfC> It's not always obvious, but there's not much you can't control with the [user] global .stack/config.yaml and/or the global project (which I try to avoid, but dedicating it to xmonad isn't the worst idea.
17:53:56 <jollygood2> I'm having some issues with lens and State https://bpaste.net/show/2cb24afef3aa
18:21:41 <Ulbrec> Adding a type signature to mutate did the trick. I only know enough to know that sometimes ghc is not able to infer types when some context is missing.
18:21:42 <Ulbrec> https://bpaste.net/show/af128bb71177
18:28:35 <jollygood2> Ulbrec thanks!
18:29:51 <geekosaur> lens uses higher order types, which ghc can't generally infer
18:30:21 <geekosaur> (rank-2 is decidable but difficult and nobody's tried to make it work. possibly because typechecking already takes longer than anything else)
18:31:19 <jollygood2> I didn't know Lens' type alias existed, makes the type pretty readable
18:43:14 <c_wraith> geekosaur, for the most part, lens goes out of its way to provide rank-1 alternatives, though they're often awkward to use in their own way
18:55:16 <Ulbrec> jollygood2 There are other type aliases in Lens to help make things a bit easier as well.
18:55:21 <Ulbrec> You can find them here
18:55:22 <Ulbrec> https://hackage.haskell.org/package/lens-4.17/docs/Control-Lens-Type.html
18:55:53 <Ulbrec> The main ones I use are Lens' and Fold
18:57:14 <Ulbrec> geekosaur thanks for the quick info on rank-2
19:55:06 <_deepfire> Any fused-effects users here?
19:58:15 <hololeap> _deepfire: just ask
20:02:10 <_deepfire> I'm trying to find an effect implementation that would allow discharging (Lift IO), while runM only seems to be able to discharge (Lift m).
20:03:15 <_deepfire> ..hence: Could not deduce (Member (Lift IO) (Lift m))
20:03:50 <_deepfire> ..whereas 'm' is constrained to have MonadIO on it.
20:16:06 <iqubic> So I'm using: `import qualified Text.PrettyPrint.Leijen as PP`
20:16:40 <iqubic> is there any functo of type Data.Text.Text -> PP.Doc?
20:18:41 <_deepfire> iqubic: I believe it's just 'text'
20:19:30 <_deepfire> iqubic: by the way -- https://hayoo.fh-wedel.de/?query=Text+-%3E+Doc
20:19:54 <iqubic> It isn't/
20:19:59 <iqubic> Not in this case.
20:20:06 <iqubic> Text expects a string.
20:20:39 <_deepfire> are you sure? http://hackage.haskell.org/package/wl-pprint-text-1.2.0.0/docs/Text-PrettyPrint-Leijen-Text.html#v:text
20:21:56 <iqubic> Compare that to this: https://hackage.haskell.org/package/wl-pprint-1.2.1/docs/Text-PrettyPrint-Leijen.html#v:text
20:22:12 <iqubic> I think they updated it to no longer take a Text.
20:22:50 <_deepfire> It's wl-pprint-text vs. wl-pprint -- the former handles Text
20:23:17 <iqubic> Oh. I didn't know that.
20:23:20 <_deepfire> In any case, Hayoo would have helped to find this out -- very useful
20:23:39 <iqubic> Will I have to update my project dependencies?
20:23:59 <iqubic> Yeah. I will. Shoot and darn.
20:24:40 <_deepfire> Haskell libraries are many.. it pays to invest time into simplifying the jigsaw handling workflow
20:25:05 <_deepfire> If you learn to make it painless, you'll be a happier haskeller : -)
20:26:14 <_deepfire> (what times are we living in..)
20:27:50 <iqubic> I know how to update my libraries.
20:27:59 <iqubic> Nix makes it real simple
20:28:20 <_deepfire> +1 for that
20:28:40 <_deepfire> Nix a real life saver
20:29:29 <benzrf> i like nix but i have trouble believing yall dont have issues with its lack of version resolution >_>
20:29:52 <iqubic> It was kinda a pain to get dante, emacs, and nix to play nicely together, but now they do.
20:30:24 <_deepfire> benzrf: what kind of troubles?
20:31:19 <_deepfire> I would attribute Nix's reliability precisely to its lack of version resolution -- or any kind of resolution for that matter.
20:31:33 <benzrf> i regularly try to open a nix shell with some library or other and at some point one of the steps fails to build bc the auto-generated hackage derivation set has the wrong version of one of the dependencies
20:31:59 <benzrf> (i know this is an issue with nixpkgs rather than nix itself, please don't hurt me)
20:32:30 <_deepfire> I see -- yes, this mostly is impossible to solve generically.
20:32:58 <_deepfire> People solve it through sheer manual labor -- producing snapshots, such as Stackage.
20:33:25 <benzrf> i actually think it should probably be entirely possible to solve generically!
20:33:33 <benzrf> we have all-cabal-hashes or whatever it's called -
20:33:56 <iqubic> I'm getting weird errors now.
20:33:57 <benzrf> surely there's a way to wire up some kind of infrastructure that allows for a version of callHackage which transitively generates dependency expressions
20:34:04 <_deepfire> Problem is the real world is messy.
20:34:05 <AfC> Try *prettyprinter* rather than wl-pprint etc http://hackage.haskell.org/package/prettyprinter
20:34:33 <iqubic> If I could figure out how to copy emacs flycheck error messages, then I'd be able to share my compiler errors with you.
20:34:43 <_deepfire> benzrf: the version boundaries are the the least of problems -- the real problem is actual compatibility and testing
20:35:03 <benzrf> :T
20:35:04 <iqubic> AfC: I'd have to rewrite a large amount of prettyprinting code in order to make that switch.
20:35:11 <benzrf> no, i think they are a big chunk!
20:35:18 <benzrf> i've sometimes managed to fix the issue by doing silly overrides
20:36:05 <_deepfire> benzrf: my personal solution so far has been -- bump to upstream git + jailbreak
20:36:11 <benzrf> christ
20:36:26 <_deepfire> Nix makes it easy
20:37:10 <_deepfire> However, there is another solution that's increasingly getting more practical
20:37:31 <_deepfire> There is a growing support for just importing Stackage as Nix overlays
20:38:06 <iqubic> http://dpaste.com/0RYJ8MP
20:39:27 <iqubic> http://dpaste.com/176GDJ8
20:39:40 <AfC> iqubic: it's very similar
20:39:53 <AfC> Just polished
20:40:34 <iqubic> I see.
20:40:48 <iqubic> So does anyone understand my error here?
20:41:41 <_deepfire> AfC: thank you for that one!
20:42:12 <dmj`> iqubic: you need to translate from lazy text to strict text
20:42:44 <dmj`> iqubic: Data.Text.Lazy.toStrict
20:46:20 <iqubic> Or I can change my Var constructor to use strict text I think.
20:46:38 <iqubic> I'm not sure what is better. to be honest
22:52:01 <WilliamHamilton[> hi, I have a question, which I hope will let me understand better how overlapping instances errors are generated: in this file https://pastebin.com/raw/e70eE4WT I created an overlapping show instance and a new typeclass with the same meaning, and then used them to parametrize a datatype. Then I wrote two identical functions using the two versions of the datatypes. One of them presents an error, and I'd like to
22:52:02 <WilliamHamilton[> understand better why
22:54:45 <WilliamHamilton[> pinging lyxia because I suspect he knows the solution off the bat!
23:03:33 <WilliamHamilton[> oooh, I figured out this one, never mind :)
23:34:17 <karel-de-macil> hi all, sorry to bother , i'm just starting haskell and trying to write a very simple version of the "length" program but my version don't seems to work despite the fact all seems good to me. After some hours checking the internet i finally ends here in the hope somneone will lead my in the right direction
23:34:34 <karel-de-macil> myNth :: [a] -> Int
23:34:34 <karel-de-macil> myNth [] = 0
23:34:35 <karel-de-macil> myNth [_:s] = 1 + myNth s
23:34:39 <karel-de-macil> here is the code
23:35:12 <karel-de-macil> ghci --version                          ✔  280  08:34:37
23:35:13 <karel-de-macil> The Glorious Glasgow Haskell Compilation System, version 8.0.2
23:35:48 <karel-de-macil> and here is the message i get :
23:36:18 <karel-de-macil>  • Couldn't match expected type ‘a’ with actual type ‘[a0]’
23:36:18 <karel-de-macil>       ‘a’ is a rigid type variable bound by
23:36:18 <karel-de-macil>         the type signature for:
23:36:18 <karel-de-macil>           myNth :: forall a. [a] -> Int
23:36:18 <karel-de-macil>         at my_nth.hs:1:10
23:36:20 <karel-de-macil>     • In the pattern: _ : s
23:36:23 <karel-de-macil>       In the pattern: [_ : s]
23:37:58 <MarcelineVQ> [_:s] is a list containing just one element which is also a list, with _ for a head and s for a tail. [_:s] is short for (_:s) : [] like how [1,2] is short for 1 : 2 : [] you likely wanted (_ : s) rather than [_ : s]
23:39:25 <karel-de-macil> sorry get's kicked for spam
23:39:40 <karel-de-macil> and just have returned i try your advice
23:39:41 <MarcelineVQ> oh yes didn't see that
23:40:34 <karel-de-macil> so your advice is to write the following ?
23:40:36 <karel-de-macil> myNth :: (a) -> Int
23:40:36 <karel-de-macil> myNth () = 0
23:40:37 <karel-de-macil> myNth (_:s) = 1 + myNth s
23:40:51 <lyxia> karel-de-macil: to not get kicked, use a paste service like gist.github.com
23:41:07 <karel-de-macil> thanks lyxia
23:41:56 <lyxia> (a) means a
23:42:16 <lyxia> Why did you change it from [a]
23:43:38 <karel-de-macil> well the original version was with some [] everywhere and don't work, what i have understood of the MarcelineVQ comment was to change the [] by some ()
23:44:04 <karel-de-macil> but don't work either
23:45:01 <karel-de-macil> don't understand what is wrong is the first version of the thing
23:46:21 <karel-de-macil> [a] in signature line is "a list of any length" ?
23:48:00 <MarcelineVQ> [a] in a type signature is the type of a list of any length that contains elements of some type 'a'
23:48:21 <karel-de-macil> can the type of a be undefined ?
23:48:37 <karel-de-macil> can the type of 'a' be undefined ?
23:49:22 <karel-de-macil> or at least undefined until the execution ?
23:50:09 <MarcelineVQ> It can be left to whoever uses myNth to decide what type it is, it's called a type variable for this reason. It won't be left until execution, but will be determined at compile time based on whether/where it's used.
23:51:00 <karel-de-macil> ok thanks so, this is not the problem so where is the error ?
23:53:15 <MarcelineVQ> It's in the last line of myNth, for the reason I said at first above, if the explanation didn't make sense it's because you need to learn what [] and : are, here's an okay source for that https://en.wikibooks.org/wiki/Haskell/Lists_and_tuples
23:54:45 <karel-de-macil> sorry Marceline I just try to understood what you say. What you want me to do is change myNth [_:s] = 1 + myNth s by  myNth (_:s) = 1 + myNth ?
23:56:36 <AfC> The parenthesis aren't special. You commonly see (x:xs) but what you're really seeing is x:xs (but usually the parenthesis are necessary to compile).
23:56:58 <AfC> [] and [x] *are* special, though:
23:57:23 <AfC> [] empty list, [x] list with one element 
23:57:29 <MarcelineVQ> karel-de-macil: myNth (_:s) = 1 + myNth s But you should read that link or another learning material about lists because it's important to know why that should change
23:57:34 <AfC> (sugar for x:[]
23:58:09 <karel-de-macil> i go to your link immediatly and will return after the read. Thanks for your time MarcelineVQ.
