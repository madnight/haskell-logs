00:00:30 * hackage webpage 0.0.5.1 - Organized and simple web page scaffold for blaze and lucid  https://hackage.haskell.org/package/webpage-0.0.5.1 (athanclark)
01:02:09 <sedeki> i have this: "deserializeObjectHeader :: Get ObjectHeader" (Data.Binary.Get) how do I repeat another action inside it (deserializeObjectHeaderMessage :: Get ObjectHeaderMessage) n times?
01:03:49 <sedeki>   ms <- take n $ repeat deserializeObjectHeaderMessage
01:22:58 <julianleviston> sedeki: you want sequence in front of it.
01:23:16 <julianleviston> sedeki: it’ll turn a t (m a) into an m (t a)
01:24:04 <sedeki> hmm ok
01:24:06 <sedeki> not sure i follow
01:24:25 <sedeki> let getMessage = \rawData -> runGet deserializeObjectHeaderMessage (BL.fromStrict $ rawData)
01:24:41 <sedeki> i have this :: B.ByteString -> ObjectHeaderMessage
01:24:49 <sedeki> I want a [ObjectHeaderMessage]
01:25:52 <julianleviston> I don’t understand your question, but if you have a list of actions, you can turn it into a single action that yields a list with sequence, whichi s what I thought you wanted to do.
01:26:11 <sedeki> hmm yes
01:26:21 <sedeki> can you give an example?
01:26:33 <sedeki> no
01:26:42 <sedeki> well... maybe we're saying the same thing...
01:26:45 <julianleviston> I’m not sure what you’re trying to do. I thought I understood, but I don’t think I did.
01:26:52 <sedeki> ok
01:26:58 <sedeki> so I'm trying to write a parser
01:27:02 <sedeki> via Data.Binary.Get
01:27:17 <julianleviston> if you have [IO ObjectHeaderMessage] and you want IO [ObjectHeaderMessage], then use sequence.
01:27:23 <sedeki> no
01:27:42 <julianleviston> :shrug: sorry, but maybe ask your question a simpler way and I’ll try again.
01:27:46 <sedeki> i want to "run" parseHeaderMessage n times
01:28:00 <sedeki> parseHeaderMessage :: Get ObjectHeaderMessage
01:28:36 <julianleviston> what is Get?
01:28:44 <sedeki> it's from Data.Binary.Get
01:29:02 <sedeki> or Data.Binary I guess
01:32:40 <julianleviston> ok so Get is a monad (I just looked it up).
01:33:19 <julianleviston> it seems you’ll have a [Get ObjectHeaderMessage] and you want a Get [ObjectHeaderMessage]. So, you use sequence to flip the one into the other.
01:34:00 <amalloy> this looks like just replicateM?
01:34:32 <julianleviston> yeah that’d be better.
01:35:41 <sedeki> wow that worked
01:36:29 <julianleviston> doesn’t really help you understand how it works tho :)
01:36:43 <julianleviston> not that using sequence does without trying to rewrite it yourself anyway, but all good :)
01:37:49 <sedeki> yeah well
01:37:55 <sedeki> i'm trying to get some practice as well
01:38:03 <sedeki> i've studied for like half a year
01:38:21 <sedeki> but yeah good point
01:38:57 <julianleviston> yeah, time doesn’t matter much. each of us takes as long as we each take to understand things and remember things. Understanding function composition is really helpful… you can get a huge way with just that, I reckon.
01:39:38 <sedeki> i think the priority rules are really weird
01:39:44 <xsperry> > replicateM 5 [1..2]
01:39:46 <lambdabot>  [[1,1,1,1,1],[1,1,1,1,2],[1,1,1,2,1],[1,1,1,2,2],[1,1,2,1,1],[1,1,2,1,2],[1,...
01:40:03 <sedeki> wow
01:40:10 <xsperry> ;-D
01:41:17 <julianleviston> sedeki: what do you mean by priority rules? do you mean precedence?
01:41:19 <xsperry> > replicateM 2 [1..3]   -- Maybe this makes it easier to understand what is going on
01:41:22 <lambdabot>  [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
01:41:27 <sedeki> yeah
01:41:29 <sedeki> presedence
01:42:48 <sedeki> precedence*
01:43:03 <xsperry> which ones in particular?
01:44:18 <sedeki> so at the moment i just fumble with `$` and parentheses
01:44:26 <sedeki> function application in particular
01:44:52 <julianleviston> ($) has almost lowest precedence, so you can treat it like that. (ie things on either side happen first, then it applies the LHS to the RHS)
01:44:57 * ski tends to prefer staying away from `$'
01:45:17 <xsperry> type :i ($) in ghci, and you will see that $ has infixr 0 $. so lowest precedence possible. and this was on purpose
01:45:26 <julianleviston> Yeah it’s easier at first to just parens… until you get good at flipping back and forth between them. 
01:45:46 <sedeki> julianleviston yup
01:45:50 <julianleviston> and it’s good to see the relationship between using ($) and using (.)
01:46:00 <julianleviston> :t let (...) = ((.).(.)) in sequence ... replicate
01:46:01 <lambdabot> Monad m => Int -> m a -> m [a]
01:46:33 <julianleviston> :t \n -> sequence . replicate n
01:46:34 <lambdabot> Monad m => Int -> m a -> m [a]
01:46:59 <ski> (e.g. imho `(f . g . h) x' is usually preferable to `f . g . h $ x', which is almost definitely preferable to `f $ g $ h $ x')
01:47:09 <julianleviston> :t \n xs -> sequence . replicate n $ xs
01:47:10 <lambdabot> Monad m => Int -> m a -> m [a]
01:47:15 <sedeki> ski i do the latter..
01:47:20 <sedeki> not because i want to
01:47:37 <sedeki> julianleviston what would this mean, in words?
01:47:52 <xsperry> :t \n -> sequence . replicate n
01:47:53 <lambdabot> Monad m => Int -> m a -> m [a]
01:48:04 <xsperry> :t ((sequence.) . replicate
01:48:05 <julianleviston> sedeki: that replicateM is the same thing as sequence composed with replicate, pretty much.
01:48:05 <lambdabot> error:
01:48:05 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
01:48:17 <ski> `\n xs -> sequence (replicate n xs)' is what julianleviston is talking about
01:48:19 <xsperry> :t (sequence.) . replicate
01:48:21 <lambdabot> Monad m => Int -> m a -> m [a]
01:48:32 <ski> @src replicateM
01:48:32 <lambdabot> replicateM n x = sequence (replicate n x)
01:48:33 <julianleviston> xsperry: I almost never like that factoring, personally.
01:48:47 <xsperry> julianleviston, at what point did you stopped liking it? :)
01:48:51 <xsperry> stop*
01:48:59 <julianleviston> xsperry: I never liked it. It confuses.
01:49:17 <julianleviston> xsperry: using `.` in a section is almost never easy to understand for people IMO
01:49:30 <sedeki> what's a section?
01:49:36 <xsperry> I don't think (\n -> sequence . replicate n) is any more confusing than (\n xs -> sequence . replicate n $ xs). especially with a generic list name like xs
01:49:46 <julianleviston> sedeki: (+5) is an example of one — a “partially applied operator"
01:49:50 <sedeki> aha
01:49:51 <sedeki> i see
01:50:02 <ski> aka a "section"
01:50:03 <sedeki> i knew that..
01:50:08 <julianleviston> xsperry: whereas `((.).(.))` if understood correctly as the composition of composition and composition becomes much easier to understand.
01:50:17 <ski> (is it a right section or a left section, though ?)
01:50:21 <xsperry> now (for (sequence.) . replicate), I can see how that could confuse people
01:50:27 <julianleviston> ski: that’s literally what I said. :)
01:51:29 <sedeki> bbl
01:51:43 <julianleviston> xsperry: yeah, but sequence … replicate is so much easier to understand when one understands the “blackbird” combinator (aka ((.).(.)))
01:53:04 <xsperry> we call that blackbird these days? :)
01:53:52 <julianleviston> depends I guess if… https://en.wikipedia.org/wiki/To_Mock_a_Mockingbird
01:54:15 <julianleviston> Dunno whether a 30+ year old book counts as “these days” tho ;-)
01:54:39 <julianleviston> It’s a better name than the others I’ve heard :)
01:56:53 <ski> "To Dissect a Mockingbird: A Graphical Notation for the Lambda Calculus with Animated Reduction" by David C. Keenan in 1996-08-27 - 2014-04-01 at <http://dkeenan.com/Lambda/>
02:14:00 * hackage free-category 0.0.2.0 - Free category  https://hackage.haskell.org/package/free-category-0.0.2.0 (coot)
02:48:06 <julianleviston> I actually don’t think Smullyan’s analogies are particularly clear, in that book.
03:26:31 <Ariakenom> A colleague linked this saying "oh that's cool" https://clojuredocs.org/clojure.core/as-%3E
03:26:44 <Ariakenom> which inspired me to this abomination. comments? https://gist.github.com/Ariakenom/42fab6eef945a502f921e0d340e1e897 
03:31:26 <fr33domlover> Hi people! Anyone knows if it's possible in Persistent (or other similar DB libraries) to write a PersistField instance for (Either a b), where both a and b and foreign keys to other tables?
03:31:59 <fr33domlover> I guess in order to preserve a uniqueness constraint they need to be in different columns? But then idk how to write an instance
03:32:31 <fr33domlover> The default is to use 2 different columns but then there's nothing there verifying that exactly one of the values exists
03:32:46 <fr33domlover> Like, both can be NULL, or both can be non NULL etc.
03:35:03 <fr33domlover> Ariakenom, looks like a fold basically?
03:35:44 <Ariakenom> It's a bit like foldr (.) id yes
03:36:31 <Ariakenom> but with a strange list of functions, a function returning lists. So that you use the same variable.
03:37:23 <Ariakenom> it's really useful. But I found it interesting as an example of how lazy & pure can replace some use cases of macros
03:37:38 <Ariakenom> it's *not* really useful
03:38:11 <fr33domlover> Ariakenom, true, but normally you don't need a variable name at all? e.g. if I want to apply some functions on a variable x I can do: f1 $ f2 a $ f2 b c $ f4 d x
03:38:14 <fr33domlover> etc.
03:38:23 <fr33domlover> Or pointless style with (.) instead of ($)
03:39:29 <fr33domlover> (Idk Clojure, maybe it's more useful there)
03:39:59 * hackage hw-json-simd 0.1.0.0 - SIMD-based JSON semi-indexer  https://hackage.haskell.org/package/hw-json-simd-0.1.0.0 (haskellworks)
03:40:01 <Ariakenom_> Sorry I BSODed during graphics driver update. That's gonna go great. God I love windows.
03:40:30 <julianleviston> Ariakenom: currying and laziness replaces almost all the requirements for macros I’ve ever had from when I’ve programmed in scheme/clojure
03:40:59 <Ariakenom_> You can move the argument more easily.  f1 m $ f2 m x $ a + b <$> m <*> c
03:42:08 <xsperry> if I understood as-> correctly..
03:42:12 <xsperry> > 9 & (*2) & even & show
03:42:14 <lambdabot>  "True"
03:43:21 <xsperry> if I understood as-> correctly..
03:43:22 <xsperry> > 9 & (*2) & even & show
03:43:24 <lambdabot>  "True"
03:44:09 <Ariakenom> julianleviston: interesting do you have examples?
03:44:17 <julianleviston> Ariakenom: if.
03:44:19 <xsperry> > let number = 9 in number & (*2) & even & show & print
03:44:22 <lambdabot>  <IO ()>
03:44:34 <julianleviston> Ariakenom: that’s a good one. In scheme it’s a “special form”
03:45:00 <Ariakenom> xsperry: I don't really know if I understood the point of as->
03:45:09 <Ariakenom> don't have much lisp experience
03:45:14 <julianleviston> Ariakenom: in Haskell you can write if as a regular function.
03:45:15 <Ariakenom> julianleviston: right, makes sense
03:46:27 <ski> (`print' and `show' ?)
03:46:35 <julianleviston> Ariakenom: as-> seems to be doing name binding across expressions within a let. It’s an utterly different language, though, so it’s kind of strange comparing them. As people have pointed out, function composition or forward application or the ($) for application are all better alternatives in Haskell IMO. Also, we can just use name shadowing in haskell to do a similar thing.
03:47:56 <ski> julianleviston, better repeat
03:48:10 <julianleviston> Yeah, missed him leaving :) thanks 
03:48:11 <julianleviston> Ariakenom: as-> seems to be doing name binding across expressions within a let. It’s an utterly different language, though, so it’s kind of strange comparing them. As people have pointed out, function composition or forward application or the ($) for application are all better alternatives in Haskell IMO. Also, we can just use name shadowing in haskell to do a similar thing.
03:48:19 <xsperry> Ariakenom, for the example used there, extracting values from deeply nested structures, lens can be used
03:49:00 <Ariakenom> sorry I should be done with blinking out of existence now
03:49:39 <xsperry> lens can also be used to "modify" such structures. it can also be passed around, stored in other structures, and then used to either read or modify values that lens refers to
03:49:48 <julianleviston> It mostly just seems to be a renaming within a lexical form. In Haskell most of the time we’d use a function for that :)
03:50:43 <Ariakenom> this is all true
03:57:53 <julianleviston> One thing which I missed from other languages in Haskell when I first started using it was easy basic hetergenous lists / arrays. Most other languages have these. I was so used to just “jamming crap into a list” as a generic data structure that it was uncomfortable to get out of that habit. It’s much better to program thinking about the specific types of data we use, though. Purity and the type system mean you end up it’s a lot harder to ge
03:57:53 <julianleviston> those kind of data structures , but it’s a better discipline of programming to keep things separated cleanly, I think.
03:58:21 <mniip> same applies to purity
03:58:27 <julianleviston> yup.
03:58:30 * hackage git 0.3.0 - Git operations in haskell  https://hackage.haskell.org/package/git-0.3.0 (VincentHanquez)
03:58:36 <Ariakenom> cut off "lot harder to g [...]"
03:58:54 <julianleviston> Having said that, there are definitely cases where having easier heterogenous collections which were polymorphically constrained but not actually concretely the same type would be useful… 
03:59:18 <julianleviston> Oh, I said… Purity and the type system mean you end up it’s a lot harder to get those kind of data structures , but it’s a better discipline of programming to keep things separated cleanly, I think.
03:59:42 <Ariakenom> julianleviston: also, do you have other interesting examples of not needed macro|specials than if?
04:01:14 <julianleviston> Ariakenom: mmmm let me think...
04:09:18 <xsperry> https://bpaste.net/show/f49b851d8413
04:09:20 <xsperry> Ariakenom, take a look at this: https://bpaste.net/show/f49b851d8413
04:09:21 <julianleviston> Ariakenom: ok… how about doseq-indexed from clojure, on this page: it iterates through a collection, binding an index with each of the items as certain variables within that expression.
04:09:30 <julianleviston> https://blog.klipse.tech/clojure/2016/05/09/macro-tutorial-4.html
04:10:18 <julianleviston> That uses a macro, and it’s not exactly easy to understand. In Haskell we’d take the collection, use zipWith (,) [0..] to do the same thing.
04:14:31 <julianleviston> Having said all this, tho, there are times when macros are useful, and we have template haskell for those times… usually in Haskell we tend to build *up* on top of the language when we need more structure, and more language features.
04:14:32 <julianleviston> (That is, we’ll describe a language as data in custom data types) whereas in lisp we tend to build *up* when we need more structure - so we build macros to extend the language. Haskell will usually just add more data types, then use that to control actions.
04:22:36 <Ariakenom> xsperry: yes, lens is great for taht example
04:23:51 <Ariakenom> julianleviston: hm could you rephrase the haskell lisp distinction?
04:24:08 <julianleviston> Ariakenom: what do you mean?
04:24:46 <Ariakenom> I didn't understand what you meant
04:25:06 <julianleviston> Ariakenom: which bit? about how in haskell you build data structures, but in lisp you make macros?
04:29:04 <julianleviston> Ariakenom: Maybe take a look at this example for logic programming: https://wiki.haskell.org/Logic_programming_example then you look at these examples: https://github.com/clojure/core.logic/wiki/Examples 
04:30:10 <julianleviston> Ariakenom: in haskell, generally when programming, we tend to build up some types that model our data, then we write a few functions that work with those types. In lisp we tend to model our data as simpler built-in flexible data structures, and build the language up to the problem
04:31:44 <julianleviston> usually that means we can often find the need to write macros in lisp to extend the language a little here and there. In Haskell 95% of the time we never need to write macros, and as a bonus we get to build and re-use functions much more easily.
04:32:07 <julianleviston> anyway I’ve ranted enough about this now :)
05:28:22 <xsperry> I don't get the difference
05:28:28 <xsperry> > mapAccumR (\acc x -> (acc-x, x)) 0 [1..5]
05:28:30 <lambdabot>  (-15,[1,2,3,4,5])
05:28:33 <xsperry> > mapAccumL (\acc x -> (acc-x, x)) 0 [1..5]
05:28:35 <lambdabot>  (-15,[1,2,3,4,5])
05:30:21 <lyxia> > mapAccumR (\acc x -> (acc-x, acc)) 0 [1..5]
05:30:24 <lambdabot>  (-15,[-14,-12,-9,-5,0])
05:30:25 <lyxia> > mapAccumL (\acc x -> (acc-x, acc)) 0 [1..5]
05:30:28 <lambdabot>  (-15,[0,-1,-3,-6,-10])
05:31:00 <xsperry> why did they end up with same result?
05:31:09 <xsperry> > foldr (-) 0 [1..5]
05:31:10 <opqdonut> xsperry: because addition is commutative
05:31:12 <lambdabot>  3
05:31:17 <xsperry> > foldl (-) 0 [1..5]
05:31:19 <lambdabot>  -15
05:31:34 <opqdonut> xsperry: 0-1-2-3-4-5 = 0-(1+2+3+4+5) = 0-(5+4+3+2+1) = 0-5-4-3-2-1
05:31:48 <xsperry> but subtraction isn't
05:32:06 <xsperry> hmm
05:32:12 <opqdonut> > foldl (-) z [a,b,c]
05:32:14 <lambdabot>  z - a - b - c
05:32:18 <opqdonut> > foldr (-) z [a,b,c]
05:32:20 <lambdabot>  a - (b - (c - z))
05:32:33 <opqdonut> > mapAccumR (\acc x -> (acc-x, acc)) z [a,b,c]
05:32:36 <lambdabot>  (z - c - b - a,[z - c - b,z - c,z])
05:32:42 <opqdonut> > mapAccumL (\acc x -> (acc-x, acc)) z [a,b,c]
05:32:44 <lambdabot>  (z - a - b - c,[z,z - a,z - a - b])
05:33:04 <opqdonut> the L/R in mapAccum is a different distinction than the l/r in fold
05:33:09 <opqdonut> that's the answer you're looking for I guess
05:33:12 <lyxia> foldl and foldr swap the position of the accumulator
05:33:42 <opqdonut> > foldr (flip (-)) z [a,b,c]
05:33:44 <lambdabot>  z - c - b - a
05:33:52 <opqdonut> > foldl (-) z [a,b,c]
05:33:54 <lambdabot>  z - a - b - c
05:34:18 <opqdonut> yeah, if you compare the types of foldl, foldr, mapAccumL and mapAccumR it's pretty clear
05:34:25 <opqdonut> :t (mapAccumL, mapAccumR)
05:34:27 <lambdabot> (Traversable t2, Traversable t1) => ((a1 -> b1 -> (a1, c1)) -> a1 -> t1 b1 -> (a1, t1 c1), (a2 -> b2 -> (a2, c2)) -> a2 -> t2 b2 -> (a2, t2 c2))
05:34:33 <xsperry> why don't mapAccum* do the same (swap arguments)? especially consider the documentation,  "The mapAccumL function behaves like a combination of fmap and foldl"   "The mapAccumR function behaves like a combination of fmap and foldr; "
05:34:41 <xsperry> considering
05:34:43 <opqdonut> that's a good question
05:38:25 <lyxia> I don't think there's a good reason, probably whoever needed it just wrote it that way and now there's nothing to be done about it.
05:39:27 <lyxia> Those functions are rarely used enough that one should be looking up the right order of arguments anyway.
05:40:56 <opqdonut> I guess most people use mapM in the State monad
06:44:48 <chessai> https://gist.githubusercontent.com/chessai/9b4ea828c8b04c1afac0e6d36fe4851b/raw/209b3cce074795de370eb75dab7445ad18ca3aaa/fibonacci.hs
07:01:58 <jgt> how do I compose filters when any of the filter functions might be Nothing? I'm trying something (very ugly) like this: http://ix.io/1zhc
07:02:33 <jgt> it doesn't work, but you can probably figure out what I'm trying to acheive
07:02:47 <jgt> s/acheive/achieve/
07:03:30 <jgt> also, what's the idiomatic way to do what I'm trying to do? Should I just use a fold instead?
07:04:16 <jgt> (actually I'm not sure how a fold would work here anyway)
07:04:27 <chessai_> jgt you can use the monoid instance for Maybe a
07:06:06 <jgt> chessai_: I guessed that might be what I should do, but I'm not entirely sure and my hazy memory tells me if any of the values like `rsRegion` or `rsLineOfBusiness` are Nothing, then the whole thing would short-circuit
07:06:11 <jgt> but I might be confused with something else
07:08:18 <chessai_> jgt
07:08:21 <chessai_> filterComposed :: (Foldable t, Semigroup b) => t (a -> Maybe b) -> [a] -> [a]
07:08:21 <chessai_> filterComposed filters xs = catMaybes $ fold filters <$> xs
07:09:22 <chessai_> theres a monoid instance for (Monoid b => Monoid (a -> b))
07:10:09 <chessai_> all your functions in the foldable will get composed with fold (foldMap id) and then you can just catMaybes the result
07:10:22 <chessai_> of applying the entire filter to the list
07:11:08 <chessai_> jgt does that make sense?
07:11:40 <jgt> chessai_: yeah, I think so
07:12:22 <jgt> except why b is a semigroup
07:12:30 <chessai_> jgt also, in your specific example, you dont need to be using Maybes
07:12:34 <jgt> but, I'll just have to hit the books again
07:12:47 <chessai_> the monoid instance for Maybe a requires that a is a semigroup
07:12:51 <jgt> chessai_: if I can do it the most idiomatic way possible, I'd rather do that
07:13:26 <chessai_> because Nothing is mempty, you don't need the underlying type to have a mempty
07:13:38 <jgt> oh, right
07:14:05 <chessai_> instead if your functions have type a -> Bool
07:14:23 <jgt> how would you approach it without Maybes? I thought I needed them because of the `rsRegion :: Maybe Region` and `rsLineOfBusiness :: Maybe [LineOfBusiness]`
07:15:36 <dmwit> jgt: consider
07:16:18 <dmwit> filters = [filter (hasLineOfBusiness lob) | Just lob <- [rsLineOfBusiness]] ++ [filter (inRegion region) | Just region <- [rsRegion]]
07:16:37 <dmwit> If you want filter fusion, then you could try
07:16:49 <dmwit> oh
07:16:51 <dmwit> Even better.
07:17:24 <chessai_> https://stackoverflow.com/a/49663087/9125440
07:17:29 <chessai_> jgt ^
07:17:30 <dmwit> filters = toList (hasLineOfBusiness <$> rsLineOfBusiness) ++ toList (inRegion <$> rsRegion)
07:18:10 <dmwit> risks = filter (\risk -> all ($risk) filters)
07:18:22 <chessai_> jgt: misread the types of those top-level identifiers
07:18:46 <chessai_> or rather, risks' doesnt show up at all
07:18:59 <chessai_> id recommend writing type signatures always
07:20:55 <dmwit> jgt: If your hasLOB and inR returned All instead of Bool, then you could consider
07:21:15 <jgt> dmwit: where does `toList` come from?
07:21:17 <chessai_> jgt: if you look at that stackoverflow answer i posted, you'll see a (monadically-) general way of getting short-circuiting predicates
07:21:25 <dmwit> filters = foldMap hasLOB rsLOB <> foldMap inR rsR
07:21:25 <chessai_> jgt the IsList typeclass
07:21:29 * hackage tonalude 0.1.1.0 - A standard library for Tonatona framework.  https://hackage.haskell.org/package/tonalude-0.1.1.0 (arowM)
07:21:31 <dmwit> jgt: Foldable, I think
07:21:40 <jgt> ah, I have one in Data.MonoTraversable.Unprefixed
07:21:43 <chessai_> oh yeah, thats fromLiat
07:21:43 <dmwit> chessai_: No, not IsList. That one has fromList.
07:21:46 <chessai_> fromList
07:21:48 <chessai_> yeah
07:21:51 <dmwit> ?index toList
07:21:51 <lambdabot> Data.Foldable, GHC.Exts, Data.IntMap.Strict, Data.IntMap.Lazy, Data.IntMap, Data.IntSet, Data.Map.Lazy, Data.Map.Strict, Data.Map, Data.Set
07:22:27 <dmwit> (And the corresponding `risks` is `risks = filter (getAll . filters) risks'`.)
07:22:36 <dmwit> jgt: I think that's my favorite spelling so far.
07:23:02 <dmwit> (the foldMap/All/getAll one)
07:23:27 <chessai_> jgt as you can see there's a lot of ways to do this
07:23:44 <jgt> yes, I'm struggling the process all of them mentally :P
07:23:45 <dmwit> In particular, it does just at most one traversal of the Maybe structure, which none of the other proposals yet does.
07:23:58 <dmwit> (But your original does.)
07:24:12 <Solonarv> IsList has toList as well, actually 
07:24:17 <Solonarv> (to support pattern matching)
07:24:36 <chessai_> Solonarv: i thought so
07:25:11 <Solonarv> but you usually don't want to use IsList's operations directly, IMO
07:25:54 <Solonarv> % let [kv] = M.singleton 'h' 1 in kv
07:25:55 <yahb> Solonarv: ('h',1)
07:27:17 <jgt> ?index getAll
07:27:17 <lambdabot> Data.Monoid
07:29:06 <jgt> dmwit: > If your hasLOB and inR returned All instead of Bool
07:29:10 <jgt> dmwit: How do I do that?
07:29:33 <dmwit> Just toss an All constructor on front.
07:29:40 <dmwit> hasLOB lob = All . not . null . ...
07:29:52 <dmwit> inR region risk = All $ Just region == riskRegion risk
07:29:53 <jgt> oh right, I see it's just a newtype
07:34:56 <dmwit> Oh, neat, GHC has a formatting language built in.
07:35:26 <dmwit> % (show <> " 0x" <> flip showHex "") 100
07:35:26 <yahb> dmwit: "100 0x64"
07:36:48 <mniip> % x = const; y = const id
07:36:48 <yahb> mniip: 
07:37:03 <mniip> % :t x*x*x + x*y - 2*y
07:37:03 <yahb> mniip: Num b => b -> b -> b
07:37:14 <dmwit> love it
07:37:25 <dmwit> Also handy for the formatting language. =)
07:38:05 <dmwit> % ("first argument is " <> x <> " and second argument is " <> y) "x" "y"
07:38:05 <yahb> dmwit: "first argument is x and second argument is y"
07:40:11 <Solonarv> there's even a printf in base
07:40:17 <Solonarv> % import Text.Printf
07:40:17 <yahb> Solonarv: 
07:40:44 <Solonarv> % printf "%v %x" 100 100
07:40:45 <yahb> Solonarv: 100 64
07:47:21 <fendor> % printf "%v" 10 40
07:47:22 <yahb> fendor: 10*** Exception: printf: formatting string ended prematurely
07:47:47 <dmwit> Solonarv: Yeah, but it's not typed.
07:48:04 <dmwit> ...as fendor points out.
07:48:36 <Solonarv> Indeed, and currently it can't be without resorting to TH or type-level strings
07:49:30 <fendor> turtle uses some kind of variadic number of arguments type matching... i think?
07:50:05 <fendor> are those type-level strings? 
07:50:59 <lyxia> what do you mean by "those"
07:52:05 <fendor> turtle does not resort to TH for type safe printf, do they use type-level strings? 
07:52:37 <concaveirc> Hello all, is there a function implemented in base or some other library which removes an element from a list by index?
07:53:09 <ski> typically accessing lists via indices is a mistake
07:53:20 <lyxia> fendor: turtle makes clever use of operators and overloadedlists
07:53:32 <ski> (you could easily define one, using `splitAt')
07:53:40 <lyxia> fendor: https://hackage.haskell.org/package/turtle-1.5.13/docs/Turtle-Format.html#v:printf there is no TH there
07:53:42 <concaveirc> ski: Is tis an 'iterate over vs access' deal?
07:53:54 <concaveirc> Does haskell use linked lists making indexing hard?
07:53:55 <lyxia> fendor: you can tell because there is no $ or [|
07:54:15 <dmwit> concaveirc: There are many alternatives that are each useful in different circumstances.
07:54:16 <Solonarv> concaveirc: indeed, the default list type is a linked list
07:54:28 <ski> lists are for sequential access. one can think of lists are more of a control structure than a data structure
07:54:30 <isovector1> is there any way to get all of the `Dec`s in scope from TH?
07:54:31 <dmwit> concaveirc: "Iterating over" is one such; using a different data structure is another; there are likely more.
07:54:35 <concaveirc> I see
07:54:45 <Solonarv> @quote simple.linked.lists
07:54:45 <lambdabot> Solonarv says: simple linked lists are not a particularly great *data* structure, but in combination with laziness they make a pretty good *control* structure
07:54:45 <isovector1> hoping for something that is functionally `reifyAll :: Q [Dec]`
07:55:13 <isovector1> or more specifically i just want all of the instances in scope
07:55:20 <fendor> lyxia, i like their approach, however, due to formatting, it looks kind of horrible. And they use a bunch of names.
07:55:53 <Solonarv> there's a standalone printf library somewhere with a similar concept
07:55:57 <Solonarv> I don't remember its name
07:56:12 <ski> concaveirc : indexing is not hard, it's just that its complexity is linear
07:56:15 <concaveirc> Solonarv: I see.
07:56:32 <concaveirc> concaveirc: Yup, I realize that hard is a strong word. Indexing is absolutely not np-complete.
07:56:40 <concaveirc> ski
07:57:23 <ski> (i meant more "not hard" as in "not hard to do")
07:57:36 <concaveirc> ski: I see
07:59:47 <lyxia> standalone printf library = fmt  (its description lists others)
08:01:04 <concaveirc> Would a vector from Data.Vector be easier? My task involves finding the minimum in a list, removing it, and recursively passing the minimum and the rest of the list into a function.
08:01:10 <lyxia> typesafe | no TH | decent-looking format strings,  pick two
08:03:49 <Solonarv> replace "no TH" with "doesn't poop on compile time" and that doesn't even seem fixable without more GHC extensions
08:04:51 <Solonarv> (you *can* parse type-level strings, but that doesn't exactly lead to fast compiles)
08:05:22 <lyxia> do people really use format strings to a point where that would affect compile time
08:06:08 <lyxia> or alternatively, do you know about compile time problems with fmt?
08:07:05 <dmwit> ski: I'm going to hold an unpopular opinion here and say that indexing into linked lists is exponential, not linear.
08:07:28 <dmwit> ski: Specifically: it doesn't vary with the size of the linked list at all, but varies exponentially with the size of the index.
08:08:19 <dmwit> (Meanwhile, indexing into a Seq is linear with analogous reasoning.)
08:08:48 <fendor> Solonarv, compile times are generally a pain point in haskell. 
08:09:28 <Solonarv> lyxia: I haven't yet seen a formatting library based on type-level strings, so I'm not speaking based on any actual data
08:09:47 <Solonarv> but the technique for parsing type-level strings is not exactly fast
08:11:34 <ski> dmwit : well, obviously the complexity is relative to the way one measures size :) e.g. if we have a perfectly balanced binary tree, one would get a different function measuring complexity of some algorithm on it, depending on whether we measure the depth or the number of nodes
08:12:11 <ski> so in `xs !! n', one could measure in terms of `n', or in terms of `logBase 2 n', say
08:13:13 <dmwit> Right. And my opinion is that people often quietly switch from talking about input *size* to talking about input *value* when dealing with functions on numbers, to the confusion and detriment of all.
08:13:38 <ski> that may be so
08:13:47 <dmwit> Sorry. The fact is that people often quietly switch; the opinion is that this is to the confusion and detriment of all. =P
08:14:40 <Solonarv> it seems useful to talk about index *value* and data structure *size*, because those are often of similar magnitude
08:40:18 <iqubic> ski: I love the things that you have to do in order to to get things like "1 + 2 * 3 - 4 / 5" to parse as "1 + (2 * 3) - (4 / 5)"
08:42:06 <iqubic> It's a sum of products alright.
08:43:04 <ski> and you see how to extend it to also parse `^' (exponentiation, which should be right associative) ?
08:43:21 <ski> and comparision and boolean operations, if you want those too
08:43:45 <iqubic> Yes. I do.
08:44:20 <ski> if you feel like it, you could ponder the more general case of mutual left-recursion
08:44:31 <iqubic> What is that?
08:44:43 <iqubic> A ::= B | ε
08:44:56 <iqubic> B ::= A | ε
08:45:03 <iqubic> Something like that?
08:45:13 <ski> when you have `foo ::= foo ... | bar ... | ...' and `bar ::= foo ... | bar ... | ...', say
08:45:26 <ski> e.g., yes, those that grammar is pretty trivial
08:45:33 <ski> s/those/though/
08:45:49 <iqubic> Does this ever appear in real world applications?
08:46:12 <ski> i can't think of an example off the top of my head, so i imagine it's not that common
08:46:36 <nshepperd1> dmwit: it's not exponential in the size of the index unless the index is supplied in a minimal format
08:46:40 <ski> i wouldn't be surprised if there's wild examples of it, though
08:46:52 <nshepperd1> In practice, we use fixed size Ints
08:47:36 <elgoosy> hi, which haskell->webassembly project would do you suggest to start poking with: WebGHC or Asterius?
08:48:04 <iqubic> ski: Why is exponetiation right assosiative?
08:48:13 <nshepperd1> (feel free to claim that indexing is therefore constant time though, since you can't index more than 2^63 spaces in)
08:49:00 <dmwit> nshepperd1: What do you mean by "minimal format"?
08:49:18 <nshepperd1> Variable size
08:49:26 <ski> well, since `(a ^ b) ^ c' is equal to `a ^ (b * c)', people felt that if you wanted that, you'd write it in the latter form anyway. and so `a ^ b ^ c' was taken to mean `(a ^ b) ^ c' by convention
08:49:31 <dmwit> Yes, I don't think "indexing is constant time because Int has a finite number of possible values" is interesting. So I treat Int as variable size.
08:49:44 <nshepperd1> But it's not variable size
08:49:45 <dmwit> In other words, you appear to be trying to argue both sides of the thing.
08:49:56 <dmwit> Either you accept it's variable size, or you accept it's finite. You can't reject both.
08:50:08 <nshepperd1> It's finite and fixed size
08:50:22 <dmwit> Okay. So you want to say indexing is constant-time, which is fine.
08:50:32 <dmwit> I have no objection to that, except that it's dumb and doesn't capture the things we care about.
08:50:49 <ski> otoh, consider how `a -> b -> c' means `a -> (b -> c)' (iso to `(a,b) -> c'), and not to `(a -> b) -> c', in Haskell. presumably that's because the former interpretation is more common to want, than the latter (due to traditionally expressing multi-argument via curried style, rather than tupled style)
08:50:55 <dmwit> The thing we care about is getting an intuition about how long it takes when given various inputs.
08:51:02 <nshepperd1> No, not really
08:51:33 <dmwit> There's many ways you can get such an intuition. One way is with big-O notation (certainly not the only way), and the *tradition* there is for the function in the big-O to be a function of input size; and I think it's sensible to be consistent about that tradition.
08:51:37 <nshepperd1> The thing we care about is the behaviour for large numbers less than 2^63
08:51:50 <nshepperd1> Which depends on the value and not the size
08:52:02 <nshepperd1> Because the size is always 64 bits
08:52:12 <dmwit> That's one way to understand it, certainly.
08:52:20 <dmwit> Another way is to say the size is the index of the highest 1 bit. =)
08:52:51 <ski> (going back to `logBase 2')
08:53:15 <nshepperd1> That seems like torturing the definition of "size" for no good reason
08:53:18 <dmwit> (This is very related to the "everything is decidable because all existing computers are DFAs argument". Which I have been convinced is... not really useful for similar reasons. Treating them as Turing machines, and therefore unbounded, is a more useful model even if it's actually not correct.)
08:53:35 <dmwit> s/DFAs argument"/DFAs" argument/
08:54:47 <iqubic> 2^3^2 = 2^(3^2) = 2^9 = 512
08:54:55 <iqubic> Is that how that is supposed to work?
08:55:06 <ski> > 2^3^2
08:55:08 <lambdabot>  512
08:55:11 <ski> > (2^3)^2
08:55:13 <lambdabot>  64
08:55:34 <iqubic> I see.
08:55:56 <iqubic> I'll have to have a think on how that fits into the rest of my grammar.
08:56:18 <ski> (you're of course free to make it left-associative, or non-associative, if you prefer. i'm just saying that, afaik, typically one tends to take it as right-associative)
08:56:39 <iqubic> How does a non-associative thing work?
08:57:09 <dmwit> > True == True == True
08:57:11 <lambdabot>  error:
08:57:12 <lambdabot>      Precedence parsing error
08:57:12 <lambdabot>          cannot mix ‘==’ [infix 4] and ‘==’ [infix 4] in the same infix expre...
08:57:30 <ski> (and the point of my suggesting adding it was precisely to get you to think about how your grammar (and the corresponding recursive descent parser) will differ, dependin on whether it's left-, right- or non-associative, keeping the rest of the operators the same)
08:58:04 <ski> `a == a == a' is simply forbidden, you must bracket either way
08:59:45 <iqubic> I see.
09:00:10 <iqubic> I don't know how to add a non-associative operator.
09:00:51 <iqubic> I'll have to have a think on how to add right associative operators.
09:02:17 <iqubic> I wish I knew how to send bold text in ERC.
09:03:21 <__monty__> iqubic: *Stars* are accepted syntax for emphasis on irc.
09:03:34 <__monty__> Often rendered as bold.
09:03:52 <glguy> bold is a good way to do bold, too!
09:04:19 <__monty__> glguy: But many clients don't support those escapes at all? Mostly webclients.
09:05:19 <glguy> Users that are worried about seeing things rendered correctly will just switch to a client that does so :)
09:06:07 <glguy> It works on the freenode web client
09:06:11 <jmcarthur> Wait, my terminal client rendered that correctly. I don't think I've ever noticed that before.
09:07:06 <glguy> There are a few different modes: underline bold italic reverse
09:07:20 <jmcarthur> :o
09:07:34 <__monty__> glguy: But it's not very friendly towards casual irc users. While the *star* and _underscore_ conventions break down gracefully.
09:08:08 <glguy> __monty__: It's probably more supported than you're guessing
09:08:16 <__monty__> Italic doesn't do anything afaics.
09:08:27 <glguy> That one's the least supported I've seen
09:08:51 <iqubic> glguy: all of those work, except for italic.
09:08:54 <__monty__> glguy: Nah, talking from experience with people pointing out things were unclear because the formatting wasn't coming through at all.
09:09:30 <glguy> https://imgur.com/a/OMhp0U6
09:09:36 <glguy> __monty__: OK, thanks
09:09:43 <iqubic> glguy: how did you do that?
09:09:57 <__monty__> Depends on your client iqubic.
09:10:01 <glguy> iqubic: /palette
09:10:31 <__monty__> In irssi it's c-_/c-7, c-b, nothing and c-v respectively.
09:10:48 <iqubic> I use Emacs ERC
09:11:25 <__monty__> And there's also c-cFG[,BG] 6,3Like this.
09:11:45 <iqubic> didn't work for me.
09:14:50 <iqubic> Does this work?
09:14:58 <glguy> Yeah, that's bold
09:15:19 <iqubic> nice.
09:20:46 <duncan^> I'm looking to express various languages in IPA (but primarily English, Welsh, and Irish). Are there any modules out there I could use, or am I on my own?
09:21:34 <iqubic> Use your own.
09:22:23 <Solonarv> interesting; thunderbird renders them, but there's no obvious way to type them.
09:26:29 <iqubic> Define your own keymap?
09:27:38 <Welkin> thunderbird supports irc and xmpp chat these days huh
09:39:47 <Welkin> what exactly is a "stripe" in a resource pool?
09:40:03 <c_wraith> a set of resources that are used independently of the other stripes
09:40:15 <Welkin> in resource-pool is states that a "stripe" is a sub-pool
09:40:19 <c_wraith> Yes
09:40:19 <Welkin> but why would you want/need that?
09:40:24 <c_wraith> reduces contention
09:40:34 <Welkin> how is that different from having more connections?
09:40:52 <c_wraith> reduces contention on the *locks*
09:41:00 <c_wraith> more connections is irrelevant to that
09:41:00 <Welkin> what locks?
09:41:14 <c_wraith> the MVar or TVar or whatever else it uses
09:42:07 <Welkin> so if you have 2 stripes with 10 connections each, would that perform differently than 10 stripes with 2 connections each?
09:42:20 <c_wraith> Depending on load, yes.
09:42:27 <c_wraith> Either one could be better or worse
09:43:00 <c_wraith> It depends on the number of CPU cores (or execution contexts in GHC) you have
09:43:30 <Welkin> I've never heard of a stripe outside of this haskell library
09:43:38 <c_wraith> they're a very standard technique
09:43:56 <Welkin> even in essays on connection pooling I've never seen it
09:44:14 <Welkin> only the number of connections is talked about
09:44:41 <c_wraith> They're everywhere in implementations for concurrent languages, though
09:45:00 <c_wraith> They don't get talked about because they're standard engineering to reduce lock contention
09:45:33 <Welkin> so when someone talks about "10 connections in the pool" are the generally talking about all the connections in all of the stripes together?
09:45:49 <c_wraith> yes
09:46:50 <Welkin> thanks, that was helpful
09:47:09 <c_wraith> http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf
09:47:16 <c_wraith> Sorry, only have haskell references on hand :)
09:47:30 <c_wraith> but that includes actual numbers showing how they help in one case
09:47:34 <Welkin> I'm looking to use a connection pool for a database driver I am writing that uses an http interface to the database
09:47:47 <Welkin> I'm not quite sure how to go about that though
09:48:02 <Welkin> so I just open a tcp connection?
09:49:03 <c_wraith> http has its own rules
09:49:09 <c_wraith> You'll need to cooperate with them
09:49:26 <xsperry> hi
09:49:29 <xsperry> :t concat
09:49:30 <lambdabot> Foldable t => t [a] -> [a]
09:49:48 <xsperry> why isn't it  Foldable t => t (t a) -> t a
09:50:00 <Welkin> this is the closest example I found, but it doesn't use a connection pool https://hackage.haskell.org/package/CouchDB-1.2.2/docs/src/Database-CouchDB-HTTP.html#CouchMonad
09:50:12 <Welkin> it does something else
09:50:12 <c_wraith> :t fold 
09:50:13 <lambdabot> (Monoid m, Foldable t) => t m -> m
09:50:16 <monochrom> Because with that generality you have a monad, not merely a foldable.
09:50:24 <xsperry> yeah, it is join
09:50:41 <c_wraith> xsperry: fold is the generalization across "things that can be concatenated"
09:51:03 <xsperry> so Foldable isn't powerful enough for this
09:51:43 <c_wraith> you can think of Foldable as "toList".  That's not quite true, but it's not quite false either
09:51:51 <monochrom> Foldable is more about "everything that can be derivied from fold :: (Foldable t, Monoid m) => t m -> m"
09:54:53 <c_wraith> monochrom: eh.  foldMap, not fold.  It matters if f isn't also a Functor
09:55:43 <monochrom> IIRC f is a functor.
09:55:54 <glguy> c_wraith: Because you're thinking you can'd implement foldMap in terms of only having fold?
09:56:07 <c_wraith> glguy: yes
09:56:23 <xsperry> :t fold
09:56:25 <lambdabot> (Monoid m, Foldable t) => t m -> m
09:56:25 <xsperry> :t foldMap
09:56:26 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
09:56:49 <glguy> c_wraith: Surely there's a clever choice of a Monoid instance that recovers foldMap...
09:56:53 * glguy ponders
09:57:12 <Welkin> if I use a Manager from http-client, will that be all that is needed to have a "connection pool"?
09:57:18 <c_wraith> glguy: doesn't help.  You have an F Foo, where Foo isn't a Monoid, and F is Foldable but not a Functor
09:57:34 <c_wraith> glguy: you can't use Fold there, no matter what you do
09:57:45 <c_wraith> err,  can't use fold
09:58:03 <glguy> You can use fold to extract a list and the map on lists and then mconcat on that list to recover foldMap at a minimum
09:58:12 <monochrom> Oh darn Foldable does not subclass Functor?!
09:58:13 <c_wraith> You can't use fold to extract a list
09:58:21 <glguy> ah, right
09:58:30 <c_wraith> monochrom: it does not
09:58:30 <glguy> don't get to change the monoid
09:58:45 <monochrom> OK then foldMap is more complete.
09:59:10 <glguy> and toList imparts a left-bias
09:59:36 <c_wraith> right.  foldMap is the most general single representative of Foldable
10:00:02 <c_wraith> but toList is a simple first approximation when you don't care about that bias.
10:00:05 <xsperry> > join $ (1 :| [2]) :| [3 :| [4], 5 :| [6]]
10:00:07 <lambdabot>  error:
10:00:07 <lambdabot>      • Data constructor not in scope:
10:00:07 <lambdabot>          (:|) :: Integer -> [Integer] -> m0 (m0 a0)
10:00:15 <xsperry> % join $ (1 :| [2]) :| [3 :| [4], 5 :| [6]]
10:00:15 <yahb> xsperry: 1 :| [2,3,4,5,6]
10:01:07 <glguy> Mewtwo as joined the battle!
10:01:11 <glguy> has*
10:01:13 <Welkin> wtf is that?
10:01:37 <xsperry> Welkin, ;-D. NonEmpty
10:41:12 <xsperry> is there a better way? :P  newtype MyDouble = MyDouble Double deriving (Read, Show, Eq, Ord, Enum, Num, Floating, Fractional, Real, RealFloat, RealFrac)
10:41:19 <Welkin> what the hell? 
10:41:22 <Welkin> https://hackage.haskell.org/package/http-client-0.6.1
10:41:39 <Welkin> in the readme is links to the dreaded haskell-lang website for a tutorial on using http-client
10:42:10 <cocreature> readmes linking to a tutorial doesn’t seem that bad
10:42:52 <Welkin> they're still pushing their attempted fork
10:43:00 <pgiarrusso> cocreature++
10:44:12 <xsperry> fork of what? 
10:44:29 <Welkin> the official haskell website (haskell.org)
10:44:32 <Welkin> and forking the community
10:44:36 <Welkin> and having their own package manager
10:44:37 <Welkin> and build tool
10:44:57 <Welkin> package repository*
10:46:22 <pgiarrusso> Have any of the problems that motivated the non-fork been addressed?
10:46:39 <Ariakenom> xsperry: remove those blasphemous Eq and Ord from that list
10:46:49 <pgiarrusso> Is hackage no more a shared repo?
10:46:57 <Welkin> from what I can tell there are no problems, only differences in opinion
10:47:43 <MarcelineVQ> That should be the tagline at the bottom of every history book.
10:47:48 <xsperry> Ariakenom, Ord is pretty useful, which also requires Eq
10:55:30 * hackage hit 0.7.0 - Git like program in haskell  https://hackage.haskell.org/package/hit-0.7.0 (VincentHanquez)
10:56:19 <xsperry> so no shortcut for "derive everything from Double"?
10:57:32 <Welkin> does it make more sense to use http-client or something higher level to implement a database driver with an http interface?
11:12:30 <g-erson> Random question - what does the ST in Control.Monad.ST stand for? State Transformer? State Thread?
11:12:48 <xsperry> State?
11:12:52 <xsperry> don't know
11:13:21 <g-erson> haha, yeah I guess it could just be State 
11:13:38 <xsperry> State was already taken :P
11:13:44 <g-erson> maybe S on its own didn't have the same ring to it
11:13:47 <yushyin> data ST s a
11:13:50 <yushyin> The strict state-transformer monad.
11:14:10 <monochrom> State thread. Because each runST threads through its own state and is also independent of other runST's.
11:14:46 <monochrom> And not transformer because it doesn't do "ST s IO a".
11:15:10 <monochrom> Transformer is when you can do "ParsecT ... IO ..."
11:15:12 <yushyin> I quoted from the documentation 
11:15:29 <yushyin> https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad-ST.html#t:ST
11:15:46 <monochrom> OK that means I'm going to send a pull request to correct it!
11:15:59 <yushyin> great!
11:16:47 <g-erson> That was more productive than I expected
11:17:02 <g-erson> & thanks, that's good to know!
11:17:30 <cocreature> iirc “state transformer” is used as a term in the paper that introduced ST
11:17:30 <ski> g-erson : "State Threads", see "Lazy Functional State Threads" by John Launchbury,Simon L. Peyton Jones in 1993 at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.50.3299>
11:18:04 <cocreature> quoting “The ST stands for state transformer which we take to be synonymous with a stateful computation: …”
11:19:29 <Welkin> ST is State Thread
11:19:38 <Welkin> the best paper is the one ski linked
11:19:59 <cocreature> and that’s the one from which I quoted the statement that says it does not stand for state thread :)
11:21:52 <xsperry> currencyConversionFactor = unsafePerformIO $ fetchCurrencyConversionFactor  <- what do you think about this? it is "pure", in the sense that it is only fetched once, and remains unchanged during duration of the program
11:23:22 <lyxia> sounds reasonable
11:24:14 <MarcelineVQ> if it is called more than once can it give a different result?
11:24:54 <MarcelineVQ> it being fetchCurrencyConversionFactor
11:25:09 <xsperry> fetchCurrencyConversionFactor is IO Double, so yes
11:25:53 <xsperry> with {-# NOINLINE currencyConversionFactor #-}  I should be safe, I think?
11:26:45 <lyxia> what if two threads need it in parallel
11:27:12 <xsperry> what happens then?
11:28:39 <lyxia> oh it seems unsafePerformIO already protects against that
11:28:48 <xsperry> nice
11:28:58 <cocreature> unless you have a very good reason to throw this in unsafePerformIO, I would strongly advice against doing that
11:28:59 * hackage buffon-machines 1.0.0.0 - Perfect simulation of discrete random variables  https://hackage.haskell.org/package/buffon-machines-1.0.0.0 (mbendkowski)
11:29:31 <cocreature> even if you are in one of the very rare cases where it is safe, it makes it hard to understand your code since nobody expects something outside of IO to perform a network request
11:29:50 <cocreature> I don’t want my program to fail because I don’t have wifi when I’m evaluating a double
11:29:56 <reygoch> Is there a way to get around name shadowing with RecordWildCards and DuplicateRecordFileds? Sometimes I need to write something like A { name :: Text , child :: B} B { name :: Text }, somefun A{..} b = dosomethingwithA name >> dosomethingWithB ( ( name::B->Text ) b )
11:30:04 <reygoch> but it doesn't work
11:30:19 <reygoch> name from a overshadows field accessor from b in this case
11:31:16 <xsperry> cocreature, regardless of how I implement this, without internet connection, program doesn't work, because it can't fetch today's currency exchange rates
11:32:57 <cocreature> xsperry: right but if I’m reading the code and I see something is in IO, it’s probably not too hard to figure out that it performs a network request that might fail. By hiding that inside an unsafePerformIO that’s not at all obvious and can lead to nightmare debugging sessions.
11:33:12 <xsperry> when is action in top-level x = unsafePerformIO action.. ran? when x is evaluated?
11:33:15 <lyxia> reygoch: if A comes from another module you can qualify the field accessor
11:33:44 <cocreature> if your code performs IO, be honest leave it in IO.
11:33:46 <MarcelineVQ> Really sounds like a value you'd want to fetch it early in your program so you can handle the error right there if it can't be fetched
11:34:51 <lyxia> xsperry: by passing explicitly a currencyConversionFactor parameter you also make your program easier to test without a network.
11:37:24 <reygoch> lyxia: yes, I guess this is a good thing to keep in mind.. although this is not my particular case :(
11:37:31 <hpc> someday someone's going to try out your code and see some foo :: Double
11:37:33 <xsperry> that's true. ok, I'm convinced, I'll redesign my code
11:37:43 <hpc> and then open ghci and run it, and be surprised when it fails because they turned off their wifi
11:38:28 <reygoch> Wasn't there some trick where I could access my record field with something like `field @"fieldName"` ?
11:39:39 <reygoch> Ah.. yes, getField it is :D
11:46:35 <lyxia> also check out generic-lens
11:53:59 * hackage these 0.7.6 - An either-or-both data type & a generalized 'zip with padding' typeclass  https://hackage.haskell.org/package/these-0.7.6 (phadej)
11:57:53 <xsperry> getExchangeRate :: (Fractional a) => IO (ExchangeRate a)   <- will this action run once for each Fractional type I'm using it with?
11:58:49 <xsperry> hmm, no, that wasn't the question I wanted to ask.
11:59:00 * hackage darcs 2.14.2 - a distributed, interactive, smart revision control system  https://hackage.haskell.org/package/darcs-2.14.2 (GaneshSittampalam)
11:59:26 <xsperry> nevermind :)
12:05:58 <xsperry> yeah, as I thought.. another trap with unsafePerformIO (and one more reason not to use it).  https://bpaste.net/show/df81372c454a
12:07:48 <xsperry> with rate :: (ExchangeRate Double) it works as expected, fetching only once. but with polymorphic rate type, unsafePerformIO runs action on every evaluation
12:08:18 <gentauro> have any read that Apple will patent "optional chaning"? I mean, Maybe type ...
12:08:32 <monochrom> :)
12:08:59 <gentauro> I never understood software pattens. How can you patent "science" and how can you patent something you haven't "implemented"
12:09:07 <gentauro> I guess I'm European ...
12:09:25 <sedeki> lol
12:09:49 <sedeki> gentauro that's scary
12:10:42 <xsperry> I'm pretty sure you can't patent something someone else has invented and released to the public
12:11:00 <xsperry> so it must be something very specific they are patenting
12:11:03 <e2> tor
12:11:19 <MarcelineVQ> when you're worth 1t you can do a lot of things people are pretty sure you can't
12:11:33 <gentauro> xsperry: but you can patent something you imagined and nobody else have researched/released ...
12:12:19 <gentauro> but as you mention, I find it very difficult that they will be able to patent "chainable option types"
12:12:49 <sedeki> good luck with that
12:13:11 <gentauro> I mean, OCaml has specifically the type `'a option`
12:13:20 <gentauro> like since forever ...
12:13:38 <gentauro> (`type `a option = Some of `a | None`)
12:14:11 <ski> (s/`a/'a/)
12:18:16 <monochrom> In practice the patent office is too lazy or incompetent to check prior art.  This has been proved.  Some company tried another very trivial prior art (to show how broken the patent office is) and got it (and proved the point).
12:18:46 <xsperry> passing it is one thing. but would such a patent hold in court?
12:18:55 <monochrom> It definitely won't.
12:19:25 <monochrom> But if a rich and bullying company serves you a cease-and-desist, will you afford to go to court?
12:35:29 * hackage postgresql-lo-stream 0.1.0.0 - Utilities for streaming PostgreSQL LargeObjects  https://hackage.haskell.org/package/postgresql-lo-stream-0.1.0.0 (abrar)
12:38:00 * hackage ansi-terminal 0.9 - Simple ANSI terminal support, with Windows compatibility  https://hackage.haskell.org/package/ansi-terminal-0.9 (mpilgrem)
12:38:17 <Cale> lpsmith: ^^ you might be interested in postgresql-lo-stream there -- it's unclear whether it should become part of postgresql-simple, or just remain its own thing, but it's a fairly natural extension anyway
12:49:30 * hackage postgresql-lo-stream 0.1.1.0 - Utilities for streaming PostgreSQL LargeObjects  https://hackage.haskell.org/package/postgresql-lo-stream-0.1.1.0 (abrar)
13:07:24 <xsperry> I didn't know you could set infix for `function`. cool
13:07:53 <hpc> yeah, i can't think of any modules that do that though
13:08:51 <Solonarv> Data.List has a few functions with a fixity IIRC
13:08:54 <Solonarv> % :i elem
13:08:54 <yahb> Solonarv: class Foldable (t :: * -> *) where; ...; elem :: Eq a => a -> t a -> Bool; ...; -- Defined in `Data.Foldable'; infix 4 `elem`
13:09:04 <Solonarv> ah, and Foldable
13:09:22 <Solonarv> % :i union
13:09:22 <yahb> Solonarv: union :: Eq a => [a] -> [a] -> [a] -- Defined in `base-4.12.0.0:Data.OldList'
13:09:38 <hpc> oh, interesting
13:09:40 <xsperry> infix  4 `elem`, `notElem`
13:14:37 <kritzefitz> How do I tell GHC whether it should compile Haskell98 or Haskell2010?
13:15:43 <hpc> turn on the NPlusKPatterns extension, and turn off...
13:15:44 <hpc> i forget
13:15:54 <hpc> the differences are 100% language extensions
13:16:51 <[Leary]> quot/rem/div/mod all have fixity declarations too; they'd be annoying to use if they didn't.
13:17:11 <__monty__> Does specifying the haskell version in the cabal file make a difference when building?
13:17:41 <kritzefitz> hpc: Hmm, yes, but I thought there is a command line flag to set the default.
13:18:05 <kritzefitz> __monty__: That's what I was actually trying to figure out.
13:19:31 <ski> hpc : `PatternGuards' ?
13:23:33 <zachk> is there a homepage or more documentation to this module somewhere? http://hackage.haskell.org/package/prolog 
13:25:09 <zachk> or something better to use?
13:26:22 <Solonarv> -XHaskell98 or -XHaskell2010 will turn on/off the corresponding set of language extensions kritzefitz
13:26:49 <kritzefitz> Solonarv: Thanks!
13:28:18 <__monty__> Solonarv: Even if the files you're compiling declare other extensions?
13:28:47 <Welkin> I haven't see nany examples in the documentation for this, but it makes sense that you would need to define a datatype for your response object in req
13:28:52 <Welkin> or am I thinking about it wrong?
13:28:53 <Solonarv> no, the extensions in a file always take priority over "global" extensions
13:29:01 <Welkin> all of the examples just parse the response as Value
13:29:28 <Welkin> I want to pull out one or two fields from that Value though, which means using parseJSON or defining a datatype with a FromJSON instance
13:37:26 <Welkin> if I implement parseJSON for a type grabbing a specific field that is an array, will that array and its contents be decoded as well?
13:40:48 <geekosaur> if you're deriving it, yes, it'll recurse. if you write your own by hand, it does what you tell it to]
13:50:11 <Welkin> I'm obviously not doing this right
13:50:27 <Welkin> can any take a look and help me figure out how to interpret this response in a sensible way?
13:50:30 <Welkin> https://gist.github.com/ericnething/da3efd5fa110885f3a105d86ad3a8ef0
13:50:46 <Welkin> the Response datatype is obviously wrong
13:55:19 <Welkin> or maybe I should interpret the field I want from the response as Value
13:55:22 <Welkin> and then parse it later?
14:04:49 <xsperry> > (++) Just "foo" <*> Nothing
14:04:51 <lambdabot>  error:
14:04:52 <lambdabot>      • Couldn't match type ‘Char’ with ‘a1 -> b’
14:04:52 <lambdabot>        Expected type: [a1 -> b]
14:05:00 <xsperry> > (++) <$> Just "foo" <*> Nothing
14:05:02 <lambdabot>  Nothing
14:05:08 <wroathe> Welkin: Is it giving you an error of some kind?
14:05:11 <xsperry> Just "foo" <> Nothing
14:05:13 <xsperry> > Just "foo" <> Nothing
14:05:15 <lambdabot>  Just "foo"
14:05:19 <xsperry> why not Nothing?
14:06:02 <zachk> I guess Nothing is the identity for <> like 0 for + and 1 for * 
14:06:25 <xsperry> both work, but it seems that Nothing would be more in the spirit of Maybe
14:07:21 <Welkin> yes, an error about my type being wrong
14:07:34 <Welkin> about my type variable being ambiguous
14:07:48 <Welkin> I know it's wrong, but I'm not sure how to make it right
14:08:18 <wroathe> Welkin: Mind putting the error in that gist?
14:09:32 <[Leary]> xsperry: if we had Nothing <> x = Nothing for all x, we would not have a Monoid.
14:09:58 <xsperry> [Leary] oh? how come?
14:10:27 <[Leary]> There can be no identity unless we're working with Maybe Void
14:10:53 <Welkin> I got it working when I removed all of the type parameters
14:10:55 <Welkin> and just used Value
14:10:59 <xsperry> isn't identity Nothing?
14:11:00 <Welkin> but now I need to make it polymorphic
14:11:15 <xsperry> or, rather, wouldn't it be in that case
14:11:27 <ski> i suppose xsperry was suggesting `Just mempty' would be the neutral element of `(<>)' ?
14:11:31 <Welkin> https://gist.github.com/ericnething/da3efd5fa110885f3a105d86ad3a8ef0
14:11:43 <Welkin> here is the working version without parametricity
14:12:02 <xsperry> ski, yes. would that conform to laws?
14:12:24 <Welkin> but I'd like to be able to interpret the response object as a haskell datatype, where one of the fields contains a list of some type `a`, but I'm not sure how to write it
14:12:27 <[Leary]> Oh, actually I guess that would work?
14:12:35 <ski> xsperry : i think so
14:13:01 <wroathe> Welkin: :P I might be able to help if you put it back and give me the error
14:13:05 <ski> @type (<>) `asAppliedTo` Nothing
14:13:06 <wroathe> Welkin: Been doing a lot of work with Aeson recently
14:13:06 <lambdabot> Monoid a => Maybe a -> Maybe a -> Maybe a
14:13:36 <ski> i think the current (^) instance doesn't use `mempty', and so `SemiGroup a' would suffice ?
14:14:05 <ski> (while with the considered alternative, `Monoid a' would be required, since `mempty' would also be used)
14:14:43 * ski has some vague memory of a `newtype' wrapper around `Maybe' which had the `SemiGroup' constraint instead
14:14:59 <Welkin> wroathe: https://gist.github.com/ericnething/da3efd5fa110885f3a105d86ad3a8ef0
14:15:08 <Welkin> PolymorphicArango.hs and Error
14:15:55 <MarcelineVQ> Data.Semigroup has all kinds of options and suggestions relevant to that
14:17:29 <ski> % :t let infixl 0 `asAppliedTo`; f `asAppliedTo` a = f where _ = f a in (<>) `asAppliedTo` Nothing
14:17:29 <yahb> ski: Semigroup a => Maybe a -> Maybe a -> Maybe a
14:17:55 <ski> right, i thought that had been changed
14:18:05 <wroathe> Welkin: looking
14:18:55 <wroathe> https://gist.github.com/ericnething/da3efd5fa110885f3a105d86ad3a8ef0#file-error-L48-L49
14:19:27 <wroathe> responseBody on line 75 seems to construct an HttpResponseBody (JsonResponse a)
14:19:52 <Welkin> but it works just fine if I replace that with Value
14:19:59 <wroathe> Welkin: And respResults wants a Response a
14:20:03 <Welkin> that wrapper is supposed to use FromJSON
14:20:36 <Welkin> so it should give me a `Response a`
14:20:48 <Welkin> my FromJSON is all messed up though, somehow
14:20:49 <wroathe> Do :t respResults in GHCI
14:21:08 <wroathe> respResults :: Response a -> [a]
14:21:20 <Welkin> yes
14:21:29 <wroathe> the result of this is what you want to be an instance of FromJSON
14:21:38 <wroathe> But right now it's complaining that you're not even getting that far
14:21:58 <wroathe> Because you're giving it the result of "responseBody response"
14:22:09 <wroathe> Which is HttpResponseBody (JsonResponse a0)
14:22:45 <Welkin> well that is weird
14:22:51 <Welkin> I removed my type annotation and it works
14:23:57 <Welkin> https://gist.github.com/ericnething/da3efd5fa110885f3a105d86ad3a8ef0#file-polymorphicarangoworking-hs
14:24:01 <Welkin> that one works fine
14:24:07 <Welkin> but my FromJSON still looks totall wrong
14:24:31 <Welkin> I get the right result back from the database though
14:24:37 <Welkin> I'll try a more complex query
14:29:58 <Welkin> it still works
14:30:02 <Welkin> this doesn't seem like it should
14:31:26 <wroathe> See, req gives you an instance of HttpResponse (either a LbsResponse, BsResponse, IgnoreResponse, or JsonResponse a), in  your case you're getting back a JsonResponse a, and then calling responseBody to wrap it in a HttpResponseBody. Then you're passing that to respResult, which expects a Response a
14:31:32 <wroathe> I have no idea how that's compiling for you
14:32:23 <wroathe> I think what you're trying to do is something like pure $ [Response $ responseBody response]
14:39:45 <wroathe> err, pure $ [Response $ [responseBody response]]
14:40:14 <wroathe> Yeah, that one
14:40:50 <Welkin> it has something to do with scoped type variables I think
14:41:09 <wroathe> Welkin: :P I don't think so
14:41:53 <Welkin> FromJSON a => HttpResponse (JsonResponse a)
14:42:06 <Welkin> in this case, my `Response a0` is the `a`
14:42:57 <Welkin> because I use respResult :: Response a0 -> [a0], it knows how to work out the types
14:43:12 <Welkin> but if I add a type annotation I get it wrong
14:43:38 <Welkin> although when I use Value as the type it just works (for Value of course)
14:45:35 <wroathe> You're saying that query is an IO action that gives you a uniform list of FromJSON instances. If the goal is to "route" this to the appropriate instance for conversion from an Aeson Value to your special ADT I think what you actually want is something like newtype QueryResp a = QueryResp a, instance FromJSON QueryResp where..., and then query :: FromJSON a => Config -> Query -> IO a, and then (result :: 
14:45:41 <wroathe> QueryResp) <- query ...
14:46:27 <wroathe> (result :: QueryResp (HttpResponseBody ...)) I mean
14:47:58 <Welkin> I want the result of query to be a list of the results as plain haskell datatypes
14:47:58 <wroathe> That's if you want ad-hoc polymorphism on query though. It seems like you actually just want it to return a value of your special ADT. 
14:48:11 <Cale> The way we tend to handle this kind of thing in our APIs is by having the request type be a GADT whose type index tells us the type of the response we need to decode. I haven't been following the discussion too closely though, so I might be a bit off base with that mention.
14:48:21 <xsperry> at what element count do you tend to switch from [(String, Data)] to Map String Data?
14:48:24 <Welkin> I don't want it to reveal all the extra things inside of the response, which contains meta data about the query result
14:48:36 <Welkin> xsperry: 2
14:48:50 <xsperry> Welkin, that's pretty soon :)
14:49:01 <Cale> xsperry: The moment I want to do a lookup rather than iterate over the elements in order
14:49:22 <Cale> Keeping elements in a list is like saying "I want to iterate over these things"
14:49:40 <Welkin> Cale: here is the file in question https://gist.github.com/ericnething/da3efd5fa110885f3a105d86ad3a8ef0#file-polymorphicarangoworking-hs
14:50:15 <xsperry> why do you switch so soon, as soon as? I wouldn't be surprised if list was winning until we go past few dozen or maybe even more elements
14:50:16 <Welkin> if you notice in PolymorhicArango.hs (the one that gives the error) I add a type annotation to the result of the query which breaks it
14:50:29 <Welkin> also, am I making a sensible API for a database driver?
14:50:37 <Welkin> I sort of modeled this after postgresql-simple's query
14:52:20 <Cale> What happens with the type annotation?
14:52:47 <Welkin> the error in the Error file just above in the gist
14:53:17 <Cale> ah, somehow it's not inferring that you want the query action to have type IO [Int]?
14:53:49 <Welkin> no, it works when I remove the explicit annotation
14:53:51 <Cale> oh, I see
14:54:13 <Cale> Oh, you might want to turn on ScopedTypeVariables
14:54:22 <Cale> and explicitly forall the a in the type of query
14:54:37 <Cale> since farther down, you write (responseBody response :: Response a)
14:54:50 <Mahasim> hi! how did you all learn haskell?
14:54:56 <Cale> but that implicitly means (responseBody response :: forall a. Response a)
14:54:58 <Welkin> I have ScopedTypeVariables turned on
14:55:07 <Cale> In that case, just add the forall
14:55:17 <Cale> so that the extension will take effect
14:55:52 <Welkin> that works
14:55:56 <Welkin> that's what I was missing
14:58:15 <Welkin> so how does it work?
14:58:21 <OmegaDoug> I'm looking to open multiple TCP and UDP sockets in the same applicaiton, I'm wondreing what the best way to handle connections is using all available CPU cores
14:58:29 <Welkin> I see the class here https://hackage.haskell.org/package/req-1.2.1/docs/Network-HTTP-Req.html#t:HttpResponse
14:58:49 <Welkin> it has an associated type and a function getHttpResponse, but I'm not sure how that all works together
14:59:12 <OmegaDoug> Would it be best to put all sockets on one core and delegate the request handling to the remaining cores, put sockets on their own cores? 
14:59:20 <Welkin> oh
14:59:26 <Cale> Mahasim: I learned Haskell back in 2001-2002 or so from... various bits and pieces. Mostly coursework that was posted online, the old "Gentle Introduction" (https://www.haskell.org/tutorial/), early versions of Yet Another Haskell Tutorial (www.umiacs.umd.edu/~hal/docs/daume02yaht.pdf)
14:59:30 <OmegaDoug> And what abstractions would be best suited for this?
14:59:36 <Welkin> HttpResponse response is just a type synonym with kind *
15:00:01 <xsperry> f (g x) (h x) y  <- is there a nicer way of writing this?
15:00:03 <Cale> Mahasim: There are probably easier things to use now :D
15:00:24 <Cale> http://www.cis.upenn.edu/~cis194/spring13/lectures.html this course is decent
15:00:43 <Mahasim> gotcha. I'm currently doing learnyouahaskell + exercises a friend gave me from their college course + solving euler puzzles with haskell
15:01:04 <Welkin> Mahasim: build a web app with scotty
15:01:17 <Mahasim> Cale: hah! that is the course my friend sent me
15:01:25 <Welkin> there is an insurmountable hill you won't be able to climb until you do a real project
15:01:49 <Cale> OmegaDoug: hmm, typically as you form connections, you forkIO new threads to handle them
15:01:55 <Mahasim> yes, though my background is 'data analysis in R' so I don't even know where to start re: web app
15:02:08 <Cale> OmegaDoug: and that automatically gives you the concurrency and parallelism you're looking for
15:03:26 <OmegaDoug> Cale: So would forkIO fork new threads on the same core, or does it utilize all available threads on all cores?
15:03:53 <xsperry> @pl (\x y -> f (g x) (h x) y)
15:03:53 <lambdabot> liftM2 f g h
15:04:09 <glguy> Mahasim: If you're interested in little tasks like Project Euler, Adventofcode.com is work looking at. It's got better tasks for learning programming
15:04:12 <xsperry> hmm, I could swear I tried that
15:04:34 <Mahasim> alright, I'll check it out
15:05:48 <Cale> OmegaDoug: It uses all the cores you make available. There's an n:m thread scheduler. If you run your program with +RTS -N it will choose the number of processors in the machine.
15:10:50 <Cale> You can use getNumCapabilities in Control.Concurrent to see how many "capabilities" there are -- these vaguely correspond to processors, the -N rts flag will set it to the number of available cores by default, and you can use e.g. -N8 to get 8 of them.
15:11:02 <OmegaDoug> Cale: Ok. that sounds about what I need. From reading the documentation I gathered that it was isolated to one CPU core
15:12:35 <Cale> btw, compile with -threaded -- this ought to be default imo, but I'm pretty sure it's still not. You still get concurrency without -threaded, but no parallelism
15:13:44 <Cale> (your threads will just all be scheduled on a single core without it)
15:17:42 <OmegaDoug> Cale: Good to know. I'll experiment with threadscope as I go along
15:38:28 <xsperry> what free tutorials are recommended these days over LYAH?
15:39:22 <[Leary]> @cis194
15:39:23 <lambdabot> Unknown command, try @list
15:39:27 <[Leary]> @where cis194
15:39:28 <lambdabot> https://www.seas.upenn.edu/~cis194/spring13/lectures.html
15:42:34 <xsperry> [Leary], that's the one, thanks
15:52:49 <sedeki> what verb is used to say that a monadic context is executed?
15:52:55 <sedeki> if that question makes sense
15:53:09 <ym555> Is the wiki book any good? (https://en.wikibooks.org/wiki/Haskell/Getting_set_up)
15:53:20 <ski> monadic actions are executed
15:53:33 <sedeki> i see
15:53:59 <ski> `getLine' is an action (an `IO'-action), `putStrLn' is a function which returns an action
15:54:16 <sedeki> ski just to be clear: monadic values are *actions*, even non-IO?
15:54:34 <sedeki> .. are called "actions"?
15:54:43 <ski> yes. `Nothing' is a `Maybe'-action, `[2,3,5,7]' is a `[]'-action, and so on
15:54:49 <sedeki> i see
15:55:10 <ski> of course, often you don't think of the latter ones from that point of view
15:55:16 <sedeki> right
15:55:23 <ski> but if you do, i think it's sensible to call then "actions" as well
15:55:29 <monochrom> ym555: Yes.
15:55:51 <ym555> okay, thanks
15:56:28 <ski> (a subset of some set in math could be thought of as a powerset-action)
15:57:02 <sedeki> ski does a `do` block within a `do` block open up a new scope?
15:57:23 <sedeki> and a do block within a do block can have a different monad than the outer one right?
15:57:30 <ski> people have also sometimes used other terms than "action". like "computation", or "collection" (only in some cases)
15:58:10 <sedeki> right
15:58:43 <ski> sedeki : yes (i suppose each `<-'-command could be seen as introducing a new scope, at least if the pattern mentions any variable in binding position), and yes
15:59:22 <sedeki> "binding position", you mean the LHS?
15:59:50 <sedeki> "pattern mentions any variable" .. as opposed to a constant/literal?
15:59:56 <ski> i mean if you write `[x,y] <- getArgs', then that clearly binds `x' and `y'
16:00:20 <ski> but if you write `((x ==) -> True) <- blah', then that doesn't bind any variable
16:00:46 <sedeki> yes because the latter one would be some kind of literal
16:00:57 <ski> (`(x ==)' there is a (value) expression, not a pattern (expression))
16:02:02 <sedeki> how is a computation executed? do I have to bind it in another monad? and of course, there is always at least one monad..
16:02:14 <sedeki> at least one action in the program***
16:02:18 <sedeki> namely, main
16:02:25 <ski> > do let {x = 2}; ((x ==) -> True) <- [3]; return "yes"
16:02:27 <lambdabot>  []
16:02:45 <Solonarv> ultimately, everything that happens in your program happens because it's used by 'main'
16:03:22 <sedeki> yes, but I'm trying to see how a computation, say `:: Get MyType` which I used the other day, how that can perform calculations without being a function
16:03:25 <julianleviston> ski: what on earth is happening here ((x ==) -> True) < - [3] ?
16:03:28 <sedeki> i kinda get it
16:03:35 <sedeki> but how do I *initially* execute it?
16:03:37 <julianleviston> ski: I don’t know if I’ve ever seen anything like that before.
16:03:38 <ski> sedeki : i think you probably wanted to say "monadic value/action", not "monad" there. a monad is not something which is computed or passed around at run-time
16:03:52 <sedeki> yes
16:03:55 <sedeki> you're right
16:03:56 <julianleviston> sedeki: you don’t. You write a monadic action as main and when GHC compiles it, the program it builds executes it.
16:03:58 <monochrom> If it's IO then the "recipe" model applies.  The runtime system runs your main.
16:04:37 <ski> julianleviston : view patterns. a pattern `<expr> -> <pat>' will matching a value, call it `v', iff the pattern `<pat>' matches the value resulting from `(<expr>) v'
16:04:54 <monochrom> If it's another monad then it depends on what monad.  For example if the monad type is defined by pure functions/values then it's ordinarily evaluation.
16:05:06 <monochrom> s/ordinarily/ordinary/
16:05:12 <ski> julianleviston : so `<expr>' evaluates to a function, which is applied to the value that we're trying to match. the output value from that function is then matched with `<pat>'
16:05:14 <julianleviston> ski: oh okay, I don’t feel so bad now haha :) I’ve looked at that extension before but it obviously didn’t sink in. :) thanks.
16:05:21 <iqubic> Is emacs tail call optimized?
16:05:51 <ski> iqubic : perhaps that's a question for #emacs ?
16:06:04 <ski> (though i believe the answer is probably "no")
16:06:30 <monochrom> Yeah if we joke about emacs taking 8GB of RAM then it has to spend that RAM somehow, right? >:)
16:07:08 <ski> sedeki : generally, you set up execution of an action, by embedding it inside another action, so that when that latter action is executed, that may cause (sooner or later) the original action to also be executed
16:07:11 <iqubic> ski: No. It's just me asking the wrong question.
16:07:24 <sedeki> ski yeah
16:07:37 <iqubic> Is Haskell tail call optimized?
16:07:38 <sedeki> that's how I think about it. so I guess I'm right
16:08:06 <ski> sedeki : for specific monads, there may be functions (like `runState') which causes an action to be executed. for `IO', there is no such function, instead you make your action part of `main' (or an action that you enter in the interactor), as mentioned
16:08:53 <sedeki> ski runState causes an action to be executed without control originating from main? what?
16:10:41 <ski> > runState (replicateM 10 (do x <- get; put (2 * x); return (10 * x))) 1  -- sedeki, no `IO' in sight, here
16:10:43 <lambdabot>  ([10,20,40,80,160,320,640,1280,2560,5120],1024)
16:11:10 <ski> that's a `State Integer'-action, though, not an `IO'-action
16:11:54 <julianleviston> ski: runState doesn’t *execute* anything, tho… isn’t it a bit of a minomer to say pure actions get “executed”?
16:12:12 <ski> it causes the constructed `State Integer' action to be executed
16:12:36 <sedeki> julianleviston no pedantry please :) just kidding..
16:12:37 <ski> it would sound strange to me if we couldn't then say that it executes the action
16:13:17 <ski> .. unless you want to reserve talk of "executing actions" to only `IO'-actions, say
16:13:26 <argent0> > :t runState
16:13:28 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
16:13:44 <ski> (or perhaps also actions which are constructed on top of `IO', such as `MaybeT IO', &c.)
16:13:48 <argent0> there is runState, execState, and evalState
16:13:59 <ski> @type runState
16:14:01 <lambdabot> State s a -> s -> (a, s)
16:14:06 <ski> @type execState
16:14:07 <lambdabot> State s a -> s -> s
16:14:09 <ski> @type evalState
16:14:10 <lambdabot> State s a -> s -> a
16:14:18 <sedeki> maybe the REPL forces runState to evaluate, therefore it is run from main... is that what you meant julianleviston ?
16:14:36 * ski doubts it
16:14:40 <julianleviston> sedeki: no… it’s more a semantic debate.
16:15:02 <julianleviston> sedeki: in terms of execution, usually that means computation done. It’s just how one models it in one’s mind, I guess, that I’m querying.
16:15:12 <sedeki> right
16:15:20 <julianleviston> sedeki: outside of haskell, we use execute to mean “perform some computation”.
16:15:24 <Solonarv> % let go acc x = if x == 0 then acc else go (x+acc) (x-1) in go 0 (10^5) -- iqubic
16:15:25 * ski has no qualms talking about executing `[]'-actions
16:15:25 <yahb> Solonarv: 5000050000
16:16:11 <julianleviston> The fact that Haskell has purity and laziness means it can sometimes not have to perform some of that computation… so I guess I’ve intertwined the word “execute” in with things that are IO-related as peeps seem to be saying. 
16:16:20 <iqubic> ski: What about executing `Maybe' actions?
16:16:24 <sedeki> i think the terms are poorly defined then
16:16:29 <ski> julianleviston : yes. and the notion of "computation" that's relevant here is one that encodes "effects" of some sort. in the `State Integer' case, that's state effects (read, update), on a single "global" state of type `Integer'. in the `[]' case, it's (angelic) nondeterminism
16:16:38 <ski> iqubic, sure
16:16:44 <julianleviston> ski: isn’t the problem with pure monads that we can’t necessarily know if they’ll be executed or not, and it’s kind of none of the programmer’s business? ;-)
16:16:45 <iqubic> Is that alright with you?
16:17:28 <Solonarv> the meaning of "executing an action" depends on the monad we're talking about
16:17:34 <ski> yes
16:17:37 <iqubic> Yes it does.
16:17:41 <julianleviston> Solonarv: that’s a problem :)
16:18:09 <Solonarv> why is that a problem?
16:18:16 <Welkin> I normally use case expressions, but sometimes I get tired of the constant nesting, which can make it harder to read
16:18:22 <ski> in any case, `return x' never performs any non-trivial (/ non-noop) effect
16:18:26 <wroathe> Again, I think the confusion from the fact that bind's definition for IO does magical things to the real world... All of the other Monad instances model commonly-used execution flows (i.e. if Just do something, else do nothing in the case of Maybe)
16:18:33 <julianleviston> Solonarv: because, like our use of the word “function” it’s discordant with the ordinary way people speak about things outside of haskell
16:18:35 <wroathe> At least that's where I initially ran into problems
16:18:44 <Welkin> is there a wa yto use `guard` (or something else) as a wrapper to short-circuit in a do-block?
16:18:53 <sedeki> julianleviston these damn ordinary people (!)
16:18:54 <Welkin> > do { [0] <$ guard True; pure 2 } :: [Int]
16:18:56 <lambdabot>  [2]
16:19:02 <ski> and `ma >>= amb' always expresses sequencing of the effects in `ma' (yielding a result `a' say) before the effects in `amb a'
16:19:03 <Welkin> > do { [0] <$ guard False; pure 2 } :: [Int]
16:19:05 <lambdabot>  []
16:19:13 <Solonarv> well, in other languages there's mostly only one type of actions
16:19:19 <Welkin> this doesn't give a type error, but it doesn't work as expected either
16:19:24 <ski> then it's another matter that the exact meaning of "sequencing" also depends on the monad in question :)
16:19:38 <julianleviston> Solonarv: but yeah, it’s understandable, and we can be “precise” by saying “execute” in realtion to actions, however… what word do we now use to talk about the thing that the program will do when it runs that involves IO and impurity? ;-)
16:19:47 <julianleviston> ski: sequencing is fine.
16:19:54 <wroathe> Most beginner documentation on Monad should have a blaring neon sign that says "IO is way more magical thing the other things we're about to talk about"
16:20:00 <julianleviston> ski: it’s not disambiguated
16:20:14 <Solonarv> we can certainly call that "execute"! we're talking about one specific type of action (IO), so there's no ambiguity
16:20:23 <ski> (e.g. consider how "sequencing" in the `[]' monad corresponds to what people would probably informally refer to as "loop nesting")
16:21:41 <ski> Welkin : what's the expected/desired behaviour of whatever you'd like ?
16:21:43 <julianleviston> Solonarv: sure. It only gets ambiguous when we talk about executing all the other monadic actions ;-) (ie… when we say execute this Maybe action, are we talking about when it gets used within an IO context, or in any context?)
16:22:08 <Solonarv> it doesn't make sense to execute a Maybe action in an IO context; that's a type error!
16:22:48 <Solonarv> % let maybeAct = Just 5 in do num <- maybeAct; print num -- doesn't work
16:22:49 <yahb> Solonarv: ; <interactive>:1:46: error:; * Couldn't match type `IO' with `Maybe'; Expected type: Maybe (); Actual type: IO (); * In a stmt of a 'do' block: print num; In the expression:; do num <- maybeAct; print num; In the expression:; let maybeAct = Just 5; in; do num <- maybeAct; print num
16:22:49 <julianleviston> Solonarv: you can certainly **evaluate** a Maybe action within an IO action in the sense of using its value, **in the process of executing** it… so I would say that’s executing it, in that context ;-)
16:23:11 <Solonarv> well, sure, but now I would say you're being intentionally confusing
16:23:25 <Solonarv> the word for "figure out what this value is" is "evaluate", not "execute"
16:23:27 <julianleviston> I guess the confusion for me is that a processor executes instructions… and I’ve somehow tied that together with the word execute, and in Haskell if we use the word execute as something else, that brings up a naming clash.
16:23:30 <dmwit> I wouldn't say it's executing it in that context.
16:23:43 <dmwit> I would say it's evaluating it.
16:23:55 <dmwit> Because that is exactly the distinction people are trying to create between the two words.
16:24:05 <julianleviston> Solonarv: sure, but *you* have been saying you’d say “execute” for talking about the monadic action of the Maybe, no?
16:24:28 <Welkin> ski: to do the same thing that I can do with case expressions, but without having to write the case expression, especially when the failure case has one line of code to handle it
16:24:29 <ski> Solonarv : however said evaluation of the `Maybe'-action will execute it (and `Maybe'-actions "contained inside" it)
16:24:40 <dmwit> julianleviston: I think no.
16:24:41 <Solonarv> I wouldn't actually use "execute" for a maybe-action at all, tbh
16:24:54 <julianleviston> Solonarv: me neither. 
16:25:10 <Welkin> I have already done this manually with functions that take the handler as a parameter and run it on success
16:25:23 <julianleviston> Sorry for this, but it’s a) really interesting to me and b) quite useful, because I often find myself in a context where I’m explaining these things, and I need clear words to do so.
16:25:24 <ski> (but if we're not thinking of that thing of type `Maybe T' as an `Maybe'-action, i'd refrain from using the term "execute" wrt to that thing)
16:25:50 <Solonarv> "execute" works for state-ish monads (which includes IO; the state is "the entire outside world"); I find it confusing for any other class of monads
16:25:52 <Welkin> basically just write for the correct path where no errors happen and move the error-handling code off somewhere else where it won't be in my way making noise
16:25:56 <julianleviston> I usually say “the maybe action evalutes to”.
16:26:51 <Solonarv> Same.
16:26:56 <dmwit> Welkin: https://stackoverflow.com/a/33006197/791604 ?
16:27:06 <ski> Welkin : so you want a handler for the `Nothing' case ?
16:27:11 <julianleviston> Solonarv: Yeah, I think I agree with that… the kind of effect is the determinant of the word, isn’t it? if it’s a stateless effect, execute seems wrong… but if it’s doing some mutationy thing, execute feels right. I’m glad for this conversation.
16:27:27 <ski> or s/`Nothing'/failure/
16:28:28 <Welkin> yes
16:28:58 <julianleviston> I think this probably comes down to the fact that the lambda calculus means mathematical substituion becomes possible, and so things like program optimisation can optimise many evaluations away, but it can’t optimise the descriptions of execution away… because that’s literally the part of the program that has a base-level “effect” (ie on the world as a mutation target). Some things fall into that category, and others can be "fused".
16:29:29 <Welkin> and I wondr if partial pattern matches are something that should be used with MonadFail for not
16:29:51 <Welkin> I don't think it is smart enough to know that in IO (Maybe a) it should produce Nothing
16:30:09 <Solonarv> that's what MaybeT is for
16:30:49 <ski> julianleviston : i'm the one who said they'd use "execute" also for `Maybe'-,`[]'-,`Reader r'-,`Writer w'-,`Cont o'-,`Parser'-actions (*when* i'm actually thinking of them as actions to perform, which is roughly when i'm using `do'-notation, or specifically monadic (or idiomatic/applicative) combinators)
16:31:08 <julianleviston> … at least, that’s why I’ve (up to now) made that distinction in my mind, naturally.
16:31:11 <julianleviston> ski: yeah, I realise.
16:31:13 <Solonarv> the MonadFail instance for IO throws an exception; the MonadFail instance for (MaybeT m) is always 'MaybeT (pure Nothing)'
16:31:15 <iqubic> Which is better, `hoogle' or `hayoo'?
16:31:16 <ski> executing a `Maybe'-action may have `Maybe'-effects, &c.
16:31:29 <dmwit> iqubic: mu
16:31:31 <Welkin> iqubic: neither, they are different
16:31:42 <Welkin> hayoo indexes all of hackage
16:31:52 <iqubic> And what about hoogle?
16:31:57 <Welkin> hoogle only indexes that packages in the platform (base + some others), so it's not as useful
16:32:05 <julianleviston> out of curiosity, also, what do people call the “<-“ generally (within a do block)… or when explaining its effect? I often say “extracts to” or “is extracted into” or “pulls out of to produce” but they all seem clumsy.
16:32:08 <Welkin> but you can search by type signature in hoogle
16:32:10 <dmwit> Modern hoogle has good coverage of Hackage. (Actually, all of stackage.)
16:32:15 <Welkin> typically you install hoogle locally and build an index there
16:32:27 <ski> Welkin : are you only talking about `Maybe',`MaybeT m',`Either e',`ExceptT e m', say ? or also e.g. `[]' ?
16:32:32 <dmwit> Welkin: https://hoogle.haskell.org/
16:32:44 <Welkin> dmwit: what about it?
16:32:50 <Solonarv> % runMaybeT do [] <- pure "not an empty list"; liftIO $ print "shouldn't see this"
16:32:50 <yahb> Solonarv: ; <interactive>:2:11: error:; Unexpected do block in function application:; do [] <- pure "not an empty list"; liftIO $ print "shouldn't see this"; You could write it with parentheses; Or perhaps you meant to enable BlockArguments?
16:33:04 <dmwit> Welkin: Your assertion that Hoogle indexes only base + a few others is falsified by this site.
16:33:11 <Solonarv> % runMaybeT do [] <- pure "not an empty list"; liftIO $ print "shouldn't see this"
16:33:11 <yahb> Solonarv: ; <interactive>:4:1: error: Variable not in scope: runMaybeT :: m0 () -> t
16:33:35 <julianleviston> ski: I guess the other reason I shy away from saying “execute” WRT non-IO is that it’s not clear what the exector is… 
16:33:40 <Welkin> dmwit: how is that?
16:33:55 <Solonarv> % runMaybeT do [] <- pure "not an empty list"; liftIO $ print "shouldn't see this" -- Welkin, finally
16:33:55 <yahb> Solonarv: Nothing
16:34:05 <dmwit> Click the dropdown. Scroll through the list of packages. It is long. (Indeed, as I said above: it is all of stackage.)
16:34:10 <Welkin> ski: all of them and any of them
16:34:15 <ski> julianleviston : i'd definitely consider `ST s' among "actions" (and i suspect many would agree with me). still, that is exactly a case where it would be possible to optimize the description of execution away, because these effects are *local* (that's the whole deal with `runST')
16:34:28 <julianleviston> ski: there’s nothing *wrong* with saying “execute”, it’s just less precise for me when I’m trying to explain things.
16:34:35 <Welkin> it's possible it has changed in recent years, but I have always had to use hayoo to search anything outside of what comes in the platform
16:34:46 <ski> julianleviston : in effect systems, local effects is also a real deal
16:34:57 <julianleviston> ski: I consdier all monadic values actions… because an action has activity, and that implies an effect… I guess I just don’t use the word execute always paired with actions, weirdly ;-)
16:35:07 <julianleviston> ski: sure thing (re: local effects)
16:35:30 <Cale> Welkin: Oh, right, I was going to point you at this thing... https://github.com/obsidiansystems/aeson-gadt-th
16:35:43 <Welkin> dmwit: telling me "you're wrong" is not the way to convince someone
16:35:55 <julianleviston> ski: I guess it’d be good to use “execute its effect” and then I’d be super happy. I think I’ll adopt that! :heart: thankyou!
16:36:07 <ski> julianleviston : re `<-', i often tend to use the term "yields" to describe the value that results from executing the action
16:36:07 <Cale> Welkin: We're using this to generate the JSON instances for our API request types, which tend to be GADTs that explain what the type of the response will be
16:36:10 <Welkin> I see no evidence that hoogle has gotten better, and no documentation to show when and how it has changed
16:36:25 <julianleviston> ski: oh yeah, me too :) (re: yields). And what do you *call* it?
16:36:27 <Cale> (Not sure if it's useful to you, but it might be worth giving a shot)
16:37:07 <ski> julianleviston : in the case of `State s', you could say the executor is `runState',`execState' or `evalState'
16:38:05 <Solonarv> (also &~ if using lens)
16:38:10 <julianleviston> ski: yeah, it’s a locally scoped idea of execution. That makes it clear. Hence if I say “execute the effect” or “… when the state effect gets executed” it’s extremely clear.
16:38:39 <dmwit> Welkin: You do not see the long list of packages it is willing to search in the dropdown?
16:38:47 <ski> Welkin : well, in the case of `[]', do you only want to run the handler in case the list was empty ? or is it enough to append the handler results to the end of the list, regardless of whether it's empty or not ?
16:39:19 <julianleviston> because then I can draw a line in between execution (in general, which to me means when a program runs, and when IO gets “done” after compilation) and execution of an effect within a particular scoped area.
16:40:02 <Johannes13> % runMaybeT do [] <- pure "not an empty list"; liftIO $ print "shouldn't see this"
16:40:02 <yahb> Johannes13: Nothing
16:40:11 <Welkin> ski: I'm matching on a list of results. If it is empty then it failed, otherwise I want to grab the result (or results) out and do something with them
16:40:13 <Cale> Recently, Ali Abrar and I have improved this aeson-gadt-th package a bunch (it now handles multiparameter type classes, and GADTs whose constructors have arguments that are other GADTs), along with https://github.com/obsidiansystems/constraints-extras which is quite useful in similar contexts)
16:40:25 <ski> julianleviston : what do i call the token `<-' ?
16:40:34 <Welkin> ski: from
16:40:36 <julianleviston> ski: yeah…
16:40:40 <Solonarv> "from" makes sense to me
16:41:04 <julianleviston> sadly it’s not an operator, tho… “the from syntax” sounds awkward.
16:41:18 <dmwit> "do binding syntax"
16:41:25 <Johannes13> ok, I don't get that. do [] <- pure "a"; liftIO $ print "foo" is just synactic suggar for pure "a" >>= ([] -> liftIO $ print "foo")
16:41:45 <ski> well, i suppose i don't that often read "aloud" (either actually aloud, or at least articulating it internally as a sound) symbolic tokens like that
16:41:46 <Johannes13> but one gives an error, while the other produces Nothing.
16:41:47 <dmwit> Johannes13: No, pattern matches in do binds have a more complicated desugaring than that.
16:41:48 <Cale> The latter lets you say things like  Has' FromJSON req resp, which basically means "given a value of type (req a), we can decide upon an instance of type FromJSON (resp a)"
16:42:10 <julianleviston> one of the biggest “complaints” that I notice  from new people I talk to is “there’s so much syntax”. Of course as soon as you show that almost all of the syntax is actually “just” operators, that complaint goes away, but becomes replaced with “how do I tell what’s syntax and what’s ordinary functions (ie operators)”… and <- falls into this. It’s definitely part of do syntax… but yeah. :)
16:42:21 <Johannes13> dmwit, ok, anything to read more about that?
16:42:22 <dmwit> Johannes13: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
16:42:40 <dmwit> Johannes13: See especially the third rule in the "Translation" box.
16:42:53 <Welkin> dmwit: what dropdown? There is no dropdown on the page
16:43:11 <dmwit> Welkin: Are you sure you clicked my link, and did not go to old Hoogle?
16:44:17 <ski> (fwiw, i don't have any trouble referring to `<-',`=',`::',`@' (and also the "invisible juxtaposition" that means application) as operators. syntactic operators, i.e.)
16:44:36 <Solonarv> Johannes13: note that there is a flag to use the 'fail' from MonadFail instead of the one from Monad; in recent GHCs it's enabled by default
16:45:28 <Welkin> why are there two different sites for hoogle?
16:45:29 <ski> @undo do [] <- pure "a"; liftIO $ print "foo"  -- Johannes13
16:45:29 <lambdabot> pure "a" >>= \ b -> case b of { [] -> liftIO $ print "foo"; _ -> fail ""}
16:45:46 <Welkin> I use the duckduckgo bang !h to search hoogle, which points to the old site
16:45:50 <ski> (except that instead of `""', it'll use a more informative source location description)
16:46:00 <dmwit> Welkin: Because the new one is a substantial rewrite, and the authors are not yet sure it faithfully subsumes the features of the old one.
16:46:03 <Welkin> whoever is in charge of hoogle should redirect from the old site to the new one, not leave them both up
16:46:16 <ski> @quote stark
16:46:16 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
16:46:17 <julianleviston> ski: I should go and read the haskell report more to find out what they call these things there.
16:46:24 <Solonarv> % :set -XMonadFailDesugaring
16:46:25 <yahb> Solonarv: 
16:46:28 <Welkin> also, wow this site is broken
16:46:33 <Welkin> the dropdown doesn't work
16:46:36 <Solonarv> % evalState $ do 1 <- pure 2; pure "uh oh" -- Johannes13: note the error
16:46:36 <yahb> Solonarv: ; <interactive>:26:16: error:; * No instance for (Control.Monad.Fail.MonadFail Identity); arising from a do statement; with the failable pattern `1'; * In a stmt of a 'do' block: 1 <- pure 2; In the second argument of `($)', namely; `do 1 <- pure 2; pure "uh oh"'; In the expression:; evalState; $ do 1 <- pure 2; pure "uh 
16:46:38 <dmwit> WFM
16:46:55 <dmwit> What browser are you using?
16:47:01 <Welkin> as a side note: who uses dropdowns!?
16:47:04 <Solonarv> (the error here is basically "this monad doesn't support failure!")
16:47:06 <Welkin> they are the worst UI element ever
16:47:11 <Welkin> use an autocomplete/type-ahead
16:47:22 <dmwit> It has both of those.
16:47:36 <Johannes13> ok, got it. It that's... useful.
16:49:16 <Welkin> Cale: what do you use this for exactly? A web api or a programming api?
16:56:44 <xsperry> map (*10) [1..5]   =>  [10,20,30,40,50]
16:56:51 <xsperry> oops
17:00:29 <dmwit> > 10 * [1..5]
17:00:32 <lambdabot>  [10,20,30,40,50]
17:00:40 <dmwit> ;-)
17:02:47 <DigitalKiwi> -.-
17:02:48 <DigitalKiwi> how
17:03:04 <[Leary]> > 10 :: [Int]
17:03:06 <lambdabot>  [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,...
17:03:11 <dmwit> DigitalKiwi: You want the even better teaser from yesterday?
17:03:31 <Welkin> :t (* [1..5])
17:03:33 <lambdabot> (Enum a, Num a) => [a] -> [a]
17:03:44 <DigitalKiwi> sure
17:03:52 <dmwit> > let f = take -1 in f 3 [0..] -- for when you need to take from before the beginning of an infinite list
17:03:54 <lambdabot>  [-1,0,1]
17:03:56 <Welkin> > [2..6] * [1..5]
17:03:58 <lambdabot>  [2,6,12,20,30]
17:04:03 <Welkin> when did this become possible?
17:04:09 <dmwit> Yesterday.
17:04:14 <Welkin> it must be the Num instance
17:04:18 <Welkin> yesterday?
17:04:22 <dmwit> Yesterday.
17:04:22 <Welkin> with what?
17:04:29 <dmwit> That would be telling!
17:04:29 <Welkin> a new extension?
17:04:45 <dmwit> Oh, no, this can be made to work as far back as H98, probably before.
17:05:28 <dmwit> I guess that's a hint of sorts.
17:06:09 <Welkin> I wouldn't want to read someone's code written that way
17:06:14 <dmwit> Me, neither.
17:06:44 <[Leary]> > take 3 [0..] - 1
17:06:46 <lambdabot>  [-1,0,1]
17:07:04 <[Leary]> > (take - 1) 3 [0..]
17:07:04 <Johannes13> :info []
17:07:06 <lambdabot>  [-1,0,1]
17:07:19 <dmwit> %% :info []
17:07:19 <yahb> dmwit: http://qp.mniip.com/y/55
17:07:46 <dmwit> Oh, the important stuff has disappeared from yahb since yesterday.
17:08:02 <dmwit> So that output will be misleading if you asked for it in conjunction with the current brainteaser.
17:08:25 <Johannes13> :t \a -> (a :: [Int])
17:08:27 <lambdabot> [Int] -> [Int]
17:08:41 <Johannes13> :t \a -> (fromIntegral a :: [Int])
17:08:43 <lambdabot> Integral a => a -> [Int]
17:09:13 <Johannes13> > fromIntegral (1 :: Int) :: [Int]
17:09:15 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:09:19 <dmwit> (If you want the non-misleading output for the current brainteaser, let me know.)
17:10:35 <iqubic> I know the secret to this
17:10:42 * dmwit nods
17:11:42 <Johannes13> (*) = zipWith (*)?
17:11:56 <iqubic> It's really clever.
17:12:29 <Johannes13> > [1,2] * [3,4]
17:12:30 <dmwit> Johannes13: yes
17:12:31 <lambdabot>  [3,8]
17:12:42 <[Leary]> It's just instances that we should probably have anyway, though imo this Num instance should belong to ZipList and [] should have the non-zippy version.
17:12:59 <dmwit> The non-zippy version doesn't satisfy the Num laws.
17:13:09 <iqubic> That's not the enitre answer though.
17:13:12 <[Leary]> Num has laws? >.>
17:13:18 <dmwit> A few. More now than it used to.
17:13:35 <dmwit> Used to be only abs x * signum x = x.
17:14:18 <Johannes13> Num is a Field, which means it is a Group wrt. (+) and a Monoid wrt. (*)
17:15:03 <iqubic> Johannes13: Can you figure out the other part of the puzzle?
17:15:17 <iqubic> let f = take -1 in f 3 [1..]
17:15:17 <dmwit> Of course, Double breaks all the laws, so... =P
17:15:29 <iqubic> > let f = take -1 in f 3 [1..]
17:15:32 <lambdabot>  [0,1,2]
17:15:46 <dmwit> Johannes13 is solving a different puzzle, I think.
17:16:08 <dmwit> And has more or less worked out all of it, it seems to me.
17:16:13 <iqubic> What is the other puzzle?
17:16:22 <iqubic> IDK the other puzzle
17:17:12 <dmwit> > 10 * [1..5] -- much simpler puzzle
17:17:14 <lambdabot>  [10,20,30,40,50]
17:17:27 <iqubic> Ah.
17:18:14 <iqubic> I know how that works, because it
17:18:31 <iqubic> it is half of the take riddle.
17:19:00 <Johannes13> > zipWith (*) (iterate 10) [1..5]
17:19:02 <lambdabot>  error:
17:19:02 <lambdabot>      • Couldn't match expected type ‘[c]’
17:19:03 <lambdabot>                    with actual type ‘Integer -> [Integer]’
17:19:46 <dmwit> > zipWith (*) (repeat 10) [1..5]
17:19:48 <lambdabot>  [10,20,30,40,50]
17:20:15 <iqubic> > let f = id * 2 in f 3
17:20:17 <lambdabot>  6
17:20:39 <Johannes13> fromInteger = repeat
17:20:50 <iqubic> Johannes13: That's right.
17:21:05 <iqubic> Now how does the `id * 2' thing work?
17:21:06 <Johannes13> > pure 1 :: ZipList Int
17:21:08 <lambdabot>  ZipList {getZipList = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:21:09 <dmwit> Johannes13: Right. (In fact, fromInteger = pure, (*) = liftA2 (*) with the right Applicative instance.)
17:21:32 <Johannes13> like ZipList?
17:21:35 <iqubic> Yes.
17:22:05 <Johannes13> :t id * 3
17:22:06 <Welkin> what in the...
17:22:06 <lambdabot> Num a => a -> a
17:22:17 <Welkin> hannah montana?
17:22:25 <dexterfoo> my programming is segfaulting with no error message. i tried viewing the core dump in gdb but the backtrace is empty
17:22:42 <Welkin> dexterfoo: are you using the C ffi?
17:23:50 <dexterfoo> Welkin: yeah, i have a few small C++ bits. but usually when those crashed i could see the stacktrace
17:25:18 <Johannes13> > pure 3 $ 2
17:25:20 <lambdabot>  3
17:25:28 <iqubic> :t pure
17:25:29 <lambdabot> Applicative f => a -> f a
17:25:51 <dexterfoo> this is happening on a server, and i can't reproduce locally. not sure what to do
17:26:01 <aplainzetakind> I get multiple declarations of sayGroup at lines 2 and 10 here: https://paste.pound-python.org/show/iqPWiCLVr7C3UsODUCnH/ why is this?
17:26:22 <Johannes13> pure = const
17:26:35 <lyxia> aplainzetakind: you wrote saygroup in the middle
17:26:37 <Johannes13> for (a -> b)
17:26:37 <dmwit> aplainzetakind: capitalization on lines 6-9 differs
17:26:44 <iqubic> Johannes13: Yes.
17:27:01 <aplainzetakind> dmwit: ffff
17:27:14 <aplainzetakind> thanks, I'm too sleepy I guess.
17:27:29 <iqubic> Johannes13: It's (Num b) => Num (a -> b)
17:27:48 <iqubic> So what do `+` and such look like?
17:28:00 <dmwit> (...and it has all the same implementations as the Num b => [b] instance, morally speaking. =)
17:28:12 <Johannes13> liftA2 (+)
17:28:15 <dmwit> yep =)
17:29:16 <iqubic> So if you combine both th list and the function, you get this:
17:29:36 <iqubic> let f = take - 1 in f 3 [1..]
17:29:53 <iqubic> > (take - 1) 3 [1..]
17:29:54 <Johannes13> 2
17:29:55 <lambdabot>  [0,1,2]
17:30:02 <iqubic> Nope.
17:30:13 <Johannes13> yeah, take, not nth
17:31:26 <Johannes13> (take - 1) a b == map (flip (-) 1) $ take a b
17:31:45 <iqubic> Yes.
17:31:46 <Johannes13> or better:
17:31:50 <xsperry> @src []
17:31:50 <lambdabot> data [] a = [] | a : [a]
17:32:43 <Johannes13> zipWith (-) (take a b) (repeat 1)
17:33:19 <Johannes13> it's still liftA2 (-)
17:33:39 * dmwit nods agreeably
17:33:45 <iqubic> Yes. basically that.
17:34:21 <Johannes13> > negate $ repeat 1
17:34:23 <lambdabot>  [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,...
17:34:30 <iqubic> It's just that "take -1" is misdirection.
17:34:47 <iqubic> Because that's performing subtraction in that case.
17:34:49 <Johannes13> > liftA negate $ repeat 1
17:34:51 <lambdabot>  [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,...
17:35:02 <iqubic> "take -1" is different from "take $ -1"
17:35:13 <ski> > subtract 1 <$> [2,3,5,7]
17:35:15 <lambdabot>  [1,2,4,6]
17:35:23 <Johannes13> liftA2 (-) take 1 3 [1..]
17:35:28 <Johannes13> > liftA2 (-) take 1 3 [1..]
17:35:31 <lambdabot>  [0,1,2]
17:35:50 <iqubic> what other bizarre things are there we can do in haskell?
17:36:06 <[Leary]> % Ap [1,2] - Ap [1,2] -- Speaking of that earlier unlawful instance, apparently we actually have it already dmwit.
17:36:06 <yahb> [Leary]: Ap {getAp = [0,-1,1,0]}
17:36:29 <ski> > [(2 +),(2 *),(2 ^)] `sequence` 3
17:36:31 <lambdabot>  [5,6,8]
17:36:48 <iqubic> Where is the dollar sign in there?
17:37:02 <ski> in where ?
17:37:10 <iqubic> > [(2 +),(2 *),(2 ^)] `sequence` ($ 3)
17:37:12 <lambdabot>  error:
17:37:12 <lambdabot>      • No instance for (Integral ((Integer -> Integer) -> Integer))
17:37:12 <lambdabot>          arising from a use of ‘e_12223’
17:37:16 <iqubic> Huh?!?!
17:37:27 <Johannes13> > fmap (2 $) [(+), (*), (^)] `sequence` 3
17:37:29 <lambdabot>  [2,2,2]
17:37:37 <iqubic> The hell???
17:38:02 <Johannes13> ok...
17:38:09 <ski> > [(+), (*), (^)] `sequence` 2 `sequence` 3
17:38:11 <lambdabot>  [5,6,8]
17:38:30 <lyxia> cute
17:38:36 <Johannes13> > map ($ 3) $ map (2 $) [(+), (*), (^)] 
17:38:38 <lambdabot>  [2,2,2]
17:38:53 <Johannes13> ?
17:39:01 <iqubic> Where did the resutlsts of the computation go?
17:39:10 <Johannes13> > map ($ 3) $ map (5 $) [(+), (*), (^)] 
17:39:10 <ski> they got swallowed
17:39:12 <lambdabot>  [5,5,5]
17:39:14 <iqubic> What the heck does sequence actually do?
17:39:23 <iqubic> I'm so confused here.
17:39:27 <ski> it sequences a list of actions
17:39:36 <Johannes13> sequence :: [m a] -> m [a]
17:39:40 <iqubic> But how does that work here?
17:40:00 <ski> making a compound action that, when executed, will execute the given actions, in order, and yield a list of all the individual results yielded by the individual actions
17:40:25 <xsperry> @src [
17:40:25 <lambdabot> Source not found.
17:40:27 <xsperry> @src []
17:40:27 <lambdabot> data [] a = [] | a : [a]
17:40:34 <ski> well, that could be an enigma for you to figure out, if you'd like to try ! :)
17:40:39 <iqubic> Binary operations in the num type class are NOT operations.
17:41:24 <iqubic> :t (5 $)
17:41:26 <lambdabot> Num b => a -> b
17:41:30 <Johannes13> @src Applicative (->) a
17:41:31 <lambdabot> Source not found. I am sorry.
17:41:43 <ski> @src (->) pure
17:41:44 <lambdabot> pure = const
17:41:49 <iqubic> @src Applicative ((->) a)
17:41:49 <lambdabot> Source not found.
17:41:50 <ski> @src (->) (<*>)
17:41:50 <lambdabot> (<*>) f g x = f x (g x)
17:42:01 <iqubic> Why is that how that is defined.
17:42:09 <Johannes13> @src (->) fromInteger
17:42:10 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
17:42:17 <ski> it's the only way that makes any sense, that works
17:42:23 <Johannes13> @src (->) fromIntegral
17:42:24 <lambdabot> Source not found. Sorry.
17:42:34 <Johannes13> @src [] fromIntegral
17:42:34 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
17:42:45 <iqubic> Why is pure the k and <*> the s from S K I combinators???
17:42:51 <ski> `src' only contains a small, hand-written, database of definitions
17:43:00 <Johannes13> k = const
17:43:20 <iqubic> Right.
17:43:48 <iqubic> k = pure and s = <*>
17:43:55 <iqubic> That's how it looks to me.
17:44:18 <ski> also `(=<<) = (<*>) . flip', in this case
17:44:28 <ski> iqubic, yes
17:44:53 <iqubic> so how does sequence work?
17:45:10 <iqubic> When used with mathematical operators as shown above?
17:45:24 <[Leary]> % :t id
17:45:24 <yahb> [Leary]: a -> a
17:45:30 <[Leary]> % (+2) `id` 3
17:45:31 <yahb> [Leary]: 5
17:45:33 <ski> `Reader rho' expresses the environment effect. which is related to lexical scoping of local variables (as in the lambda calculus)
17:45:56 <iqubic> Huh? What are we talking about here?
17:46:13 <iqubic> [Leary]: that makes perfect sence to me.
17:46:31 <[Leary]> Sequence is doing more or less the same thing.
17:46:37 <iqubic> :t id
17:46:38 <lambdabot> a -> a
17:46:57 <iqubic> Wait?? How the heck did you give id two arguments?
17:47:01 <[Leary]> `a -> b` can be a binary operation, it just depends on what b is.
17:47:32 <iqubic> Oh, wait you did: id::(a -> b) -> (a -> b) which lets it take two arguments.
17:47:54 <ski> well, you should know that `\x. <expr> <expr_0>' is equal to `S (\x. <expr>) (\x. <expr_0>)'. and `\x. x' is `I', while `\x. <expr>' is `K <expr>', when `<expr>' doesn't mention `x' freely
17:47:56 <dmwit> [Leary]: Yikes, and not even a comment warning about it.
17:48:47 <Johannes13> Also fun: A custom Num instance which builds an AST.
17:48:53 <ski> <Johannes13> sequence :: [m a] -> m [a]
17:49:02 <ski> pick `m = (rho ->)', and see what you get
17:49:42 <Johannes13> give it an argument and the result is a list with all the results.
17:50:34 <iqubic> I'm just going to read this blog post to hopefully understand this all a bit better.
17:50:43 <iqubic> https://kseo.github.io/posts/2016-12-24-reader-monad-and-ski-combinators.html
17:52:01 * ski tends to prefer calling it "environment monad"
17:52:12 <Johannes13> > (id (+2)) 3 == (+2) 3
17:52:14 <lambdabot>  True
17:52:34 <iqubic> Johannes13: I got that much.
17:57:33 <iqubic> Can someone give me a simple function that returns a Reader a?
17:58:02 <iqubic> for some a that you like. Either specialize it or don't. I don't care
17:58:10 <lyxia> :t reader
17:58:11 <lambdabot> MonadReader r m => (r -> a) -> m a
17:59:06 <iqubic> That looks like a mouthful.
17:59:14 <lyxia> :t ask :: Reader a a
17:59:16 <lambdabot> Reader a a
17:59:50 <lyxia> :t reader :: (r -> a) -> Reader r a
17:59:51 <lambdabot> (r -> a) -> Reader r a
17:59:58 <iqubic> :t tell
17:59:59 <lambdabot> MonadWriter w m => w -> m ()
18:00:18 <iqubic> Oh, I thought tell was reader thing.
18:01:52 <Welkin> :t asks
18:01:54 <lambdabot> MonadReader r m => (r -> a) -> m a
18:01:56 <Welkin> you ask the reader
18:01:58 <Welkin> tell the writer
18:02:25 <xsperry> :t tell
18:02:27 <lambdabot> MonadWriter w m => w -> m ()
18:07:53 <Johannes13> :t getState
18:07:54 <lambdabot> error: Variable not in scope: getState
18:08:02 <Johannes13> :t withState
18:08:03 <lambdabot> (s -> s) -> State s a -> State s a
18:11:04 <Profpatsch> What’s the recommended way to convert an Integer to Text?
18:11:10 <Profpatsch> T.pack . show?
18:11:13 <iqubic> No.
18:11:22 <iqubic> Or actually maybe.
18:11:33 <Profpatsch> I haven’t found anything more specific.
18:11:35 <Cale> That's how I'd do it
18:11:40 <Profpatsch> Though that’s kinda weak
18:11:58 <Cale> It's mildly unfortunate to have to go via String, but that's what we've got
18:12:07 <iqubic> Just use that.
18:12:53 <lyxia> Profpatsch: https://hackage.haskell.org/package/text-show ?
18:13:52 <xsperry> will String be optimized away with fusion?
18:14:30 <Solonarv> probably?
18:15:28 <iqubic> What is fusion?
18:15:47 <c_wraith> iqubic: why do you never google?
18:16:42 * ski . o O ( <https://homepages.inf.ed.ac.uk/wadler/topics/deforestation.html> )
18:17:41 <iqubic> Time to read about the Reader monad and SKI combinators
18:17:59 <iqubic> ski: Did you chose that name because of the S K I combinators?
18:18:50 <Solonarv> fusion is what makes the intermediate lists in 'sum . map (^2) . take n $ [1..]' disappear
18:19:24 <iqubic> Wait... So `Monad ((->) a)` is the reader monad?
18:19:33 <Solonarv> a simpler example of fusion is turning 'map f (map g xs)' into 'map (f . g) xs'
18:19:43 <iqubic> I see.
18:20:15 <Solonarv> iqubic: ((->) a) is the reader monad. 'Monad ((->) a)' is a constraint.
18:20:51 <ski> iqubic, aye
18:21:01 <[Leary]> More interesting question: Does fusion still mean something if you eschew "concrete" data structures and encode everything in the lambda calculus instead? If so, does /everything/ "fuse"?
18:21:39 <ski> (not that it's that great of a name. but it's stuck, and it's probably too late to change it now)
18:22:10 <aplainzetakind> I finished data61/fp-course. As a next step I'm considering data61/lets-lens and qfpl/applied-fp-course. Which one would be more sensible?
18:22:12 <Solonarv> data structures exist in the lambda calculus too (church encodings!), so intermediate data structures exist as well
18:22:17 <ski> iqubic : `(rho ->)' is basically the same thing as `Reader rho', yes
18:22:58 <Solonarv> and it is indeed possible to eliminate intermediate datastructures in the LC as well, at least in principle
18:23:55 <Welkin> aplainzetakind: are those on github?
18:24:04 <aplainzetakind> Welkin: Yes.
18:24:13 <iqubic> And ((->) rho) ~ (rho ->)?
18:24:26 <[Leary]> Solonarv: Right, church/scott/etc encodings are basically what I'm asking about. It seems like (at least with call-by-name) that you get some kind of fusion for free.
18:26:06 <Solonarv> iqubic: (rho ->) isn't legal Haskell, but yes
18:26:32 <iqubic> ski was the one who gave me the term (rho ->).
18:27:09 <iqubic> Let me guess, the kind of ((->) rho) is * -> *.
18:27:43 <iqubic> Well... (->) is the most overloaded thing I have seen.
18:28:10 <iqubic> function types, kinds, fundeps, and most likely more that I can't think of right now.
18:30:12 <Solonarv> it's actually not that overloaded - in modern (GHC) Haskell, kinds are almost completely merged into types, so (->) in types and kinds is the same thing
18:30:38 <Solonarv> it's used in the syntax for view patterns and fundeps, but IIRC that's all
18:31:01 <Solonarv> (and -> isn't a legal operator at the expression/pattern level, anyway)
18:32:22 <iqubic> But we still use it.
18:32:28 <Welkin> -> is a type/kind constructor, used as "yield" in lambdas, and in functional dependencies
18:32:34 <iqubic> ((->) rho) is a thing.
18:32:40 <Welkin> that's only 3 meanings, and the fundeps one is pretty rare
18:32:45 <iqubic> oh, I totally forgot about lambdas.
18:33:14 <Welkin> <- is always "from", whether in do-notation or a list comprehension
18:33:59 <iqubic> Welkin: Yeah, I suppose fundeps are kinda rare. I see type families quite a bit more than fundeps.
18:34:16 <Welkin> which reminds me that there is still a ton for me to learn in haskell
18:34:25 <iqubic> And me too.
18:34:29 <Welkin> I still haven't properly learned type families
18:34:45 <Welkin> and I have been using haskell for 5 years now
18:34:46 <iqubic> I'm about halfway there.
18:35:15 <Welkin> it will take a while before I learn everything
18:35:18 <Welkin> if that ever happens
18:35:57 <Welkin> is there a candidate list of extensions that will be included in the next haskell standard?
18:36:19 <Welkin> so we can stop writing 12 language pragmas at the top of each file (or in .cabal)
18:36:31 <Welkin> I'm thinking mostly the type-level programming ones
18:39:24 <Solonarv> a search for "haskell prime" should turn up answers regarding the next haskell standard
18:39:26 <dmwit> -> is also used in case
18:39:39 <Welkin> yeah, case expressions too
18:40:03 <dmwit> type, kind, fundep, view patterns, lambdas, case -- that's a lot of places
18:40:17 <Welkin> forgot about view patterns
18:40:27 <Welkin> but in all of those cases, it can still be read as "yields"
18:40:59 <iqubic> Despite having read many tutorials on the subject, I still don't understand State.
18:41:11 <dmwit> That seems like good evidence that "yields" is a strongly overloaded English word, not that -> is not an overloaded piece of syntax.
18:41:56 * ski idly wonders whether iqubic read the Winstanley one, yet
18:42:42 <iqubic> Not sure.
18:43:10 <iqubic> I can't seem to find a link to it.
18:44:11 <ski> "What the hell are Monads?" by Noel Winstanley in 1999-02 at <http://www-users.mat.uni.torun.pl/~fly/materialy/fp/haskell-doc/Monads.html>
18:46:42 <iqubic> ski: I know what a monad is. I just don't understand the State Monad.
18:49:13 <ski> do you understand threading state around, as in `labelTree :: Integer -> Tree a -> (Tree a,Integer)' ?
18:52:44 <iqubic> Not really.
18:56:06 <Welkin> you have a piece of data that you pass around to different functions that contains your state
18:56:20 <Welkin> instead of manually having to pass it around, you can hide it using State
18:56:28 <Welkin> it still works the exact same way though
18:57:30 <iqubic> Sure.
18:58:24 <aplainzetakind> iqubic: Try to rewrite mundane things using State. Like `sum`.
18:58:37 <ski> an accumulator is something you pass down the recursive call (possibly after modifying it in some way)
18:59:20 <iqubic> Sure. I actually did that in my Left Associative binary operation parser.
18:59:23 <ski> a state is also passed "back up" from the recursive call. and if you have several recursive calls, it is then passed (possibly after further modification) into the next one of them, and so on
19:00:15 <ski> it's like when you traverse a tree, depth-first, and your carrying your state with you, down and up
19:00:33 <iqubic> I see.
19:00:40 <ski> (the tree in this case being the call tree, or the part of it where the state is involved)
19:00:57 <iqubic> newtype State a s = {runState :: s -> (a, s)}
19:01:00 <iqubic> Is that right?
19:01:04 <ski> yep
19:01:13 <ski> (except you're missing a data constructor)
19:01:34 <ski> (and also, the type parameters are typically in the opposite order)
19:02:08 <iqubic> I'm not trying to syntactically correct. Just trying to get the general idea. Though it is important to know the order of the parameters.
19:03:26 <ski> `labelTree n t' is supposed to label each element of the tree `t', starting at the integer `n', counting upwards, while traversing the tree (depth-first). it also gives back the next unused integer label
19:03:58 <iqubic> I see.
19:04:10 <ski> try to write it directly. and then using `State' (e.g. your version of it), with monadic operations (that you name and write yourself, e.g.)
19:04:27 <iqubic> So it's a left-to-right preorder of the tree. I see.
19:04:34 <ski> er, and of course i got the type signature above wrong, it should be
19:04:40 <iqubic> Or er... Postorder.
19:04:43 <ski>   labelTree :: Integer -> Tree a -> (Tree (Integer,a),Integer)
19:04:58 <iqubic> Depth-first is post order.
19:05:09 <ski> well, you can do preorder, postorder, or inorder, as you like. it doesn't really matter that much
19:05:15 <iqubic> Right.
19:05:17 <Welkin> do level order
19:05:24 <ski> heh
19:05:38 <iqubic> Level order sounds a lot harder in this situation.
19:05:44 <ski> depth-first is the simple case. breadth-first is harder
19:06:09 <Welkin> just use a queue
19:06:24 <Welkin> also, write your own queue
19:06:29 <Welkin> don't use any libraries
19:20:27 <iqubic> ski: How is S K K the same a I?
19:20:36 <ptival[m]> .
19:20:50 <Welkin> iqubic: write it out
19:20:56 <Welkin> it's a fun proof
19:20:58 <c_wraith> :t const <*> const
19:20:59 <lambdabot> b -> b
19:21:05 <c_wraith> cheating method
19:21:43 <iqubic> S K K = \x -> (K x) (K x)
19:22:00 <c_wraith> that's not what S is
19:22:04 <iqubic> No?
19:22:12 <c_wraith> oh, yeah it is.  ok
19:22:15 <c_wraith> Keep going.
19:22:19 <c_wraith> You can simplify
19:23:36 <iqubic> = \x -> (\z -> x z) (\z -> x z)
19:23:41 <iqubic> I think.
19:24:01 <iqubic> K x = \z -> x
19:24:03 <iqubic> Actually.
19:24:35 <iqubic> so S K K = \x -> (K x) (K x) = \x -> (\z -> x) (\z -> x)
19:24:45 <ski> beta
19:25:21 <c_wraith> lambda calculus isn't Haskell.  You can simplify under the lambda
19:25:35 <iqubic> Where do I go from there?
19:25:41 <c_wraith> ski told you
19:26:20 <iqubic> \x -> (\z -> x) (\z -> x) = \x -> x
19:27:21 <iqubic> Because if you let the first z = \y -> x (second part with alpha conversion)
19:27:30 <iqubic> Then you get the answer.
19:28:18 <iqubic> Or, let's do it this way:
19:31:19 <iqubic> S K K = \x -> (K x) (K x) = \x -> (K x) (\y -> x) = \x -> (K x x) = \x -> x = I
19:31:33 <iqubic> Which I believe to be the right answer to that riddle.
19:32:41 <iqubic> ski: Is that second thing correct?
19:33:12 <iqubic> :t (<*>)
19:33:13 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:33:38 <Welkin> replace f with (-> c)
19:34:13 <iqubic> Uh... You mean replace f with (c ->)
19:34:29 <iqubic> ((->) c) is (c ->)
19:34:32 <Welkin> ((->) c)
19:34:33 <Welkin> same thing
19:34:37 <iqubic> It's a consumer of c.
19:34:48 <iqubic> Not a producer of c.
19:34:54 <ym555> code
19:35:01 <ym555> o sorry
19:35:54 <iqubic> (<*>) :: (c -> (a -> b)) -> (c -> a) -> (c -> b) for f ~ (c ->)
19:36:33 <iqubic> S f g x = f x (g x)
19:37:34 <Solonarv> % :t (<*>) @((->) _)
19:37:34 <yahb> Solonarv: (w -> a -> b) -> (w -> a) -> w -> b
19:38:06 <iqubic> S :: (c -> a -> b) -> (c -> a) -> c -> b
19:38:12 <iqubic> Wait... <*> is S?
19:38:17 <Welkin> yes
19:38:30 <iqubic> pure :: a -> (r -> a)
19:38:40 <iqubic> K :: a -> r -> a
19:38:43 <Welkin> pure is not an SKI
19:38:51 <iqubic> it isn't?
19:38:57 <iqubic> But it has the right type.
19:38:58 <Welkin> const is K
19:39:08 <Solonarv> pure *is* const
19:39:19 <Welkin> you're right
19:39:22 <Solonarv> % :t pure @((->) _)
19:39:22 <yahb> Solonarv: a -> w -> a
19:39:26 <Welkin> I never looked at it that way
19:39:42 <iqubic> :t const <*> const
19:39:44 <lambdabot> b -> b
19:39:53 <iqubic> As I just proved, that should be the same as id.
19:40:01 <Welkin> :t pure <*> pure
19:40:02 <lambdabot> error:
19:40:02 <lambdabot>     • Ambiguous type variable ‘f0’ arising from a use of ‘pure’
19:40:02 <lambdabot>       prevents the constraint ‘(Applicative f0)’ from being solved.
19:40:05 <Welkin> haha
19:40:13 <Welkin> of course
19:40:30 <iqubic> Welkin: It doesn't know which applicative to use.
19:40:41 <iqubic> > (pure <*> pure) 5
19:40:43 <lambdabot>  error:
19:40:43 <lambdabot>      • Could not deduce (Applicative f0) arising from a use of ‘pure’
19:40:43 <lambdabot>        from the context: Num t
19:41:00 <iqubic> > (const <*> const) 5
19:41:01 <Solonarv> @check \x -> (x :: Int) == (const <*> const) x
19:41:02 <lambdabot>  5
19:41:04 <lambdabot>  +++ OK, passed 100 tests.
19:41:05 <Welkin> :t pure <*> pure :: ((->) Int)
19:41:06 <lambdabot> error:
19:41:06 <lambdabot>     • Expecting one more argument to ‘(->) Int’
19:41:06 <lambdabot>       Expected a type, but ‘(->) Int’ has kind ‘* -> *’
19:41:21 <iqubic> Huh?
19:41:21 <Welkin> :t pure <*> pure :: ((->) Int Int)
19:41:23 <lambdabot> error:
19:41:23 <lambdabot>     • Ambiguous type variable ‘f0’ arising from a use of ‘pure’
19:41:23 <lambdabot>       prevents the constraint ‘(Applicative f0)’ from being solved.
19:41:50 <iqubic> :t (pure <*> pure) :: ((->) a)
19:41:52 <lambdabot> error:
19:41:52 <lambdabot>     • Expecting one more argument to ‘(->) a’
19:41:52 <lambdabot>       Expected a type, but ‘(->) a’ has kind ‘* -> *’
19:42:07 <ski> iqubic : the step `\x -> (K x) (\y -> x) = \x -> (K x x)' seems mysterious
19:42:20 <Solonarv> that's because it's wrong
19:42:26 <Solonarv> fortunately, it isn't needed
19:42:29 <iqubic> Is it?
19:42:41 <iqubic> How would you get from S K K to I?
19:43:24 <ski> @type pure <*> (pure :: Integer -> Bool -> Integer) :: Integer -> Integer
19:43:25 <lambdabot> Integer -> Integer
19:43:38 <Welkin> % :t pure <*> pure @((->) _)
19:43:38 <Solonarv> SKKx => Kx(Kx) => x, then apply functional extensionality
19:43:38 <yahb> Welkin: b -> b
19:43:39 <iqubic> wow.
19:43:58 <Welkin> is the @ here a type application or some fancy yahb thing?
19:44:08 <Solonarv> it's type application
19:44:16 <Welkin> what is with the _?
19:44:28 <ski> iqubic : you had it right, before
19:44:31 <iqubic> Oh.
19:44:35 <ski> <iqubic> so S K K = \x -> (K x) (K x) = \x -> (\z -> x) (\z -> x)
19:44:37 <Solonarv> that's a partial type signature; those are always enabled in type applications
19:44:37 <ski> <iqubic> \x -> (\z -> x) (\z -> x) = \x -> x
19:44:53 <ski> then you confused yourself with that strange step i mentioned
19:45:15 <Welkin> this reminds me of when I worked out the type of (.).(.)
19:45:24 <Welkin> I made so many mistakes at first and made it really complicated
19:45:36 <Welkin> once I discovered that and started over again it was simple
19:45:39 <Solonarv> SKa is actually equivalent to I no matter what you choose for a
19:45:55 <Solonarv> that proof leaves less room to wander down strange paths
19:47:17 <iqubic> SKa is I?
19:47:36 <ski> yes, for all `a'
19:47:50 <iqubic> so what is the type of (.).(.)?
19:48:00 * ski idly wonders what `forall k. (forall x. k*x = 0) -> k = 0' and `forall k,l. (forall x. k*x = l*x) -> k = l' would be called
19:48:18 <iqubic> IDK what that means.
19:48:38 <iqubic> What is *? Is that S?
19:48:57 <ski> it's multiplication of numbers
19:49:12 <iqubic> Ah. So k, l, and x are numbers?
19:49:18 <ski> aye
19:49:48 <iqubic> So what is the type of (.).(.)?
19:49:54 <iqubic> :t (.).(.)
19:49:55 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
19:49:57 <ski> (the proofs are pretty trivial. i was just wondering whether these properties had names)
19:50:05 <iqubic> What the heck??
19:50:36 <iqubic> k*x = 0 -> k = 0. Divide both sides by x
19:50:55 <MarcelineVQ> ski: isn't the latter extentionality?
19:51:01 <ski> (can't divide by zero, though)
19:51:02 <iqubic> k*x = l*x -> k = l Divide by x.
19:51:16 <iqubic> Oh, right.. the stupid for all.
19:51:28 <iqubic> Well, just do a proof in two cases. 0 and not 0.
19:52:16 <iqubic> so how does one figure out the type of (.).(.)?
19:52:46 <MarcelineVQ> *function extensionality
19:52:51 <ski> MarcelineVQ : hm, not quite. extensionality would take us to `(k*) = (l*)'. we still need injectivity of (curried !) `(*)' to get to the end
19:53:12 <ski> good observation, though
19:53:37 <Solonarv> you can try writing (.).(.) down as a lambda and *then* figure out its type
19:54:03 <iqubic> How many arguments does it have?
19:54:05 <dmwit> ski: I would call them both specialization.
19:54:12 <dmwit> ski: (Choose x=1 in both cases.)
19:54:31 <dmwit> ski: Or perhaps "application", depending on how you've set up the terminology you're using to talk about logic.
19:54:46 <MarcelineVQ> oh, yeah, extentionality would be if it implied x = x
19:55:11 <MarcelineVQ> wait, no, hehe...
19:55:12 <Solonarv> iqubic: sidestep that issue by explicitly currying everything
19:55:22 <iqubic> What does that mean?
19:55:31 <iqubic> :t curry
19:55:33 <lambdabot> ((a, b) -> c) -> a -> b -> c
19:55:37 <iqubic> :t uncurry
19:55:39 <lambdabot> (a -> b -> c) -> (a, b) -> c
19:55:46 <dmwit> ski: I mean they're both of the form (forall x. P x) -> P 1.
19:55:47 <Solonarv> i.e. instead of '\f g x -> f (g x)', write '\f -> \g -> \x -> f (g x)'
19:56:15 <Solonarv> (I would suggest grabbing pen&paper to work this out)
19:56:39 <iqubic> (.).(.) = (\x y -> x . y) . (\x y -> x . y)
19:56:56 <iqubic> I think.
19:57:08 <MarcelineVQ> ski: I see my error now thanks
19:57:23 <iqubic> why is this thing hard to understand?
19:57:30 <Welkin> :t (.).(.)
19:57:32 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
19:57:44 <Solonarv> iqubic: that's correct, but not very useful. substitute (.) with its definition!
19:57:46 <Welkin> write out the whole thing starting with (.) to see how it works
19:57:50 <Welkin> it's really cool
19:58:13 <Welkin> :t fmap . fmap
19:58:15 <lambdabot> (Functor f2, Functor f1) => (a -> b) -> f1 (f2 a) -> f1 (f2 b)
19:58:15 <Welkin> that is the same
19:59:34 <ski> @type let infixr 9 .:; (.:) :: (c0 -> c1) -> (a -> b -> c0) -> (a -> b -> c1); (.:) = (.) . (.) in concat .: sortOn length .: groupBy
19:59:35 <lambdabot> (a -> a -> Bool) -> [a] -> [a]
19:59:42 <ski> > let infixr 9 .:; (.:) :: (c0 -> c1) -> (a -> b -> c0) -> (a -> b -> c1); (.:) = (.) . (.) in (concat .: sortOn length .: groupBy) (equating toLower) "MisSisSippi"
19:59:44 <lambdabot>  "MiiiisSsSpp"
20:00:56 <ski> dmwit : well, they're special cases of equating two polynomials by equating corresponding coefficients
20:01:21 <iqubic> (.).(.) = (\f -> \g -> \x -> f (g x)) . (\f -> \g -> \x -> f (g x))
20:01:28 <ski> (in the cases i gave, the proof is trivial, by picking `x' as `1', yes)
20:01:56 <iqubic> = (\f g x -> f (g x)) . (\f g x -> f (g x))
20:01:59 <iqubic> I think.
20:02:05 <Solonarv> iqubic: there's still a (.) left in there!
20:02:08 <iqubic> I know.
20:02:35 <kadoban> :t (.) . (.)
20:02:37 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
20:02:38 <ski> dmwit : you can also compare with the "cancellation" law `forall k,l : |R. (forall d : |R | x^2 = 0. k*d = l*d) -> k = l', in SDG
20:02:48 <iqubic> Not sure where to go from there.
20:02:55 <kadoban> Stuff like that tends to be easier to work out from just the type, for me.
20:03:02 <ski> (in that case, you can't pick `d' as `1')
20:03:05 <iqubic> (\f g x -> f (g x)) . (\f g x -> f (g x))
20:03:11 <iqubic> What next?
20:03:44 <kadoban> :t \f g a b -> f (g a b)
20:03:45 <lambdabot> (t1 -> t2) -> (t3 -> t4 -> t1) -> t3 -> t4 -> t2
20:03:56 <iqubic> \z -> ....
20:04:13 <iqubic> I'm not sure how to remove the last `.'
20:04:28 <ski> change from infix to prefix
20:04:38 <ski> or use
20:04:41 <ski> @src (.)
20:04:41 <lambdabot> (f . g) x = f (g x)
20:04:50 <ski> (after a slight reformulation)
20:05:04 <iqubic> What reformulation do I want?
20:05:07 <ski> (you could also eta, i suppose)
20:05:21 <ski>   f . g = \x -> f (g x)
20:06:01 <iqubic> (.) (\f g x -> f (g x)) (\f g x -> f (g x))
20:06:09 <Solonarv> there you go
20:06:17 <iqubic> And now what?
20:06:27 <ski> soon you'll be repeating yourself, not twice, but thrice
20:06:47 <Solonarv> replace that (.) with its definition, make all the variable names unique, and start reducing!
20:07:01 <Solonarv> (unique variable names helps you not confuse yourself)
20:07:28 <dmwit> ski: I'm having a lot of trouble parsing your last message to me.
20:08:06 <dmwit> ski: I think |R is the reals, right? What's x?
20:08:17 <iqubic> (.) (\f g x -> f (g x)) (\h k y -> h (k y))
20:08:19 <ski> er, sorry
20:08:31 <ski> `x^2' should be `d^2'
20:08:44 <ski> (that's that i get for making last-seconds changes !)
20:09:59 <dmwit> Oh boy. Google says SDG stands for "synthetic differential geometry". This may be a bit above my midnight paygrade.
20:10:04 <ski> `|R' is reals, yes. `forall x : A | P(x). Q(x)' is bounded quantification, `forall x : {x : A | P(x)}. Q(x)'. or `forall x : A. P(x) -> Q(x)', if you prefer
20:10:24 <Solonarv> you still have that (.) sitting there! go replace it with its definition, and finally start actually reducing the expression you have there
20:10:34 <ski> SDG is fun, you have real infinitesimals !
20:10:36 <iqubic> I know.
20:10:42 <Welkin> do it on paper
20:10:43 <dmwit> ski: But surely on the reals x^2 = 0 implies x = 0, no?
20:10:44 <Welkin> that helps me
20:11:01 <iqubic> Solonarv: I'm typing this out on in a separate document, so I can see all of this at once.
20:13:43 <ski> `{d : |R | d^2 = 0}' (abbreviated as `|D') is the set of (first-order) infinitesimals, around zero
20:13:49 <ski> classically, this set is just the singleton set `{0}'. but constructively, that can't be proven
20:14:04 <ski> a function of type `{0} -> |R' has a graph that is just a point (`(0,y)', for some `y')
20:14:16 <ski> but a function of type `|D -> |R' has a graph that is an "infinitesimally long line". it has both an elevation, and a *slope* (but it doesn't bend, it's too short for that, need higher-order infinitesimals) !
20:15:13 <ski> (formally, we adjoint an extra axiom (which contradicts excluded middle) to express this)
20:17:05 <ski> then, we can prove `forall d : |D. f(x + d) = f(x) + d * (D f)(x)', where `D f' is the derivative of `f'
20:17:36 <iqubic> http://dpaste.com/0Y361X8
20:17:42 <iqubic> Not sure where to go from there.
20:17:50 <dmwit> Oh, constructive reals. Those are... very different yeah. Okay.
20:18:29 <dmwit> I admit to finding it a bit surprising that x^2=0 doesn't imply x=0 even in the constructive reals, but then my intuitions for the constructive reals are not very well trained.
20:18:30 <iqubic> Welkin: What should I do there?
20:21:03 <ski> e.g. `(x + d)^2 = x^2 + 2*x*d + d^2 = x^2 + 2*x*d' (since `d^2 = 0'), so `(x + d)^2 - x^2 = 2*x*d', but the former is supposed to be `d * (D (x |-> x^2))(x)', so we have `d * (D (x |-> x^2))(x) = d * 2*x' (and this holds for arbitrary `d' in `|D'), hence we can cancel the `d' here (because of the axiom), getting `(D (x |-> x^2))(x) = 2*x'
20:24:38 <ski> dmwit : the problem is `forall a,b. a * b = 0 -> a = 0 \/ b = 0'. we can't continuously select which of the alternatives to pick. we still have `forall a,b. a # 0 /\ b # 0 -> a * b # 0', and i think also `forall a,b. a*b = 0 /\ a # 0 -> b = 0'. but if both `a' and `b' are picked as the same `d', then attempting to prove `d # 0', in order to get `d = 0' as result doesn't help
20:25:36 <ski> (`#' is "apartness", a positive notion of inequality. for reals, `x # y' is the same as `x < y \/ x > y')
20:25:54 <ski> (s/inequality/disequality/)
20:26:13 <dmwit> Does `p \/ p -> p` not hold intuitionistically??
20:26:24 <ski> it does
20:26:48 <ski> the problem is that constructive reals don't enjoy `forall a,b. a * b = 0 -> a = 0 \/ b = 0'
20:27:02 <dmwit> Oh, okay.
20:27:18 <dmwit> I misunderstood your original "the problem is" sentence.
20:27:22 <iqubic> http://dpaste.com/0Y361X8 IDK what to do from here.
20:28:19 <ski> iqubic : you've replaced two of the `(.)'s. now do it for the third one
20:28:46 <ski> @djinn Either p p -> p
20:28:46 <lambdabot> f a =
20:28:46 <lambdabot>     case a of
20:28:46 <lambdabot>     Left b -> b
20:28:46 <lambdabot>     Right c -> c
20:28:56 <ski> (is an intuitionistic proof)
20:29:20 <iqubic> The last one is the hardest.
20:29:53 <ski> (fwiw, i suspect that if we interpret `\/' as *multiplicative* disjunction from linear logic, then `forall a,b. a * b = 0 -> a = 0 \/ b = 0' makes more sense, for constructive reals)
20:30:17 <ski> (`Either' is basically the additive disjunction, fwiw)
20:30:59 <iqubic> getting rid of the third (.) is being rather hard.
20:31:12 <ski> (and, indeed, `A \/ A |- A' does *not* hold in linear logic, with `\/' being taken as multiplicative disj.)
20:31:22 <ski> iqubic : whyfore ?
20:31:38 <iqubic> because the arguments are rather confusing.
20:32:56 <ski>      (.) (.) (.)
20:33:02 <ski>   =  (.) (\f g -> \x -> f (g x)) (\h k -> \y -> h (k y))
20:33:07 <ski> is what you have currently
20:33:17 <iqubic> Yes. Correct.
20:33:33 <ski> so, do the same to the remaining `(.)', that you already did to the two others
20:33:47 <ski> that shouldn't be very hard
20:34:05 <iqubic> I'm not sure how though. Do I need to do some function application here or not?
20:34:07 <ski> (however, the steps *thereafter* may be easier to get lost in)
20:34:18 <ski> just replace equals for equals
20:34:28 <iqubic> (.) f g = \x -> f (g x)
20:34:33 <ski>   (.) = \f g -> \x -> f (g x)
20:34:47 <iqubic> That's what I just wrote.
20:34:52 <ski> you replaced one `(.)' with `\f g -> \x -> f (g x)'
20:35:13 <ski> then you replaced another one `(.)' with `\f g -> \x -> f (g x)', and then also did some alpha-conversion (renaming of bound variables)
20:35:23 <iqubic> Yeah.
20:35:27 <iqubic> Wait..
20:35:41 <iqubic> :t (.) (.) (.)
20:35:42 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
20:35:47 <iqubic> Is that the same thing?
20:36:01 <ski> `f . g' is the same thing as `(.) f g', yes
20:36:17 <ski> therefore, `(.) . (.)' is the same thing as `(.) (.) (.)'
20:37:37 <iqubic> (\m n z -> m (n z)) (\f g x -> f (g x)) (\h k y -> h (k y))
20:37:41 <iqubic> Now to reduce.
20:38:24 <ski> right
20:41:31 <ski> (another way would be to start reducing `((.) . (.)) x y z', say)
20:41:59 <iqubic> Huh?
20:42:19 <ski> instead of replacing the `(.)'s with lambdas, i mean
20:42:30 <ski> but since you've started doing that, might as well finish it
20:42:32 <iqubic> I'm confused by what you mean?
20:42:48 <ski> i just mentioned about route one could take at the start
20:43:07 <ski> er, s/about/another/
20:43:18 <iqubic> I don't understand the other route.
20:43:28 <ski> don't worry about it, for now, then
20:44:29 * hackage stratosphere 0.30.1 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.30.1 (jdreaver)
20:45:08 <iqubic> I'm getting lost as all heck here.
20:45:08 <Solonarv> ski: your approach requires correctly guessing how many arguments there should be, which is why I didn't recommend it
20:46:09 <iqubic> http://dpaste.com/2WCJBMF Is this at all correct?
20:46:53 <ski> Solonarv : fair enough :)
20:47:18 <iqubic> Why is this so damn hard???
20:47:44 <ski> looks right, so far
20:47:48 <iqubic> I see.
20:49:06 <ski> (Solonarv : though, one could start by noticing that in `(f . g) x = ...', there's three formal parameters explicitly mentioned in the definiendum. of course, it might be that more will be needed later, in which case one could eta ..)
20:49:21 <iqubic> And I have hit the end of this it seems.
20:49:26 <iqubic> http://dpaste.com/3MSRR3F
20:49:37 <Welkin> it's not hard at all
20:49:43 <Welkin> just write everything out
20:49:46 <iqubic> Wait... that last line is wrong..
20:50:12 <ski> where did `k y' go ?
20:50:20 <Welkin> start with the definition of (.) and keep on substituting and expanding/reducing
20:50:27 <iqubic> I know, that's my error.
20:50:49 <Welkin> I made mistakes when I did it on paper until I started over from the beginning and did it carefully
20:51:30 <Welkin> :t (.)
20:51:31 <lambdabot> (b -> c) -> (a -> b) -> a -> c
20:51:58 <iqubic> http://dpaste.com/0AHTKC3
20:52:02 <Welkin> start by substituting in b only
20:52:26 <Welkin> then reduce as much as possible
20:52:26 <iqubic> And I'm not sure what to do at that last line.
20:52:44 <Solonarv> you seem to be done, just cleanup left
20:52:44 <iqubic> There is no more function application at that last line.
20:52:56 <iqubic> I'm not sure how to clean this up.
20:53:04 <Welkin> I mean (b -> c)
20:53:18 <Solonarv> you have \x -> \h k y -> \z -> ...
20:53:35 <Solonarv> and some superfluous parentheses
20:53:42 <iqubic> Sure. Can I turn that into a 5 argument functions?
20:53:59 <Solonarv> indeed!
20:54:17 <iqubic> \x h k y z -> x ((k y) z)
20:54:21 <iqubic> So like that?
20:54:25 <ski> iqubic : the `h' formal parameter should disappear, near the end
20:54:38 <iqubic> I know.
20:54:50 <ski> you forgot to remove it, when you did one beta
20:54:54 <Solonarv> oh yes, the 'h' shouldn't be there anymore
20:55:08 <iqubic> There we go.
20:55:22 <iqubic> http://dpaste.com/3XBKHX4
20:55:39 <iqubic> What is the type of that thing?
20:55:54 <ski> good
20:56:08 <ski> you could remove one pair of redundant brackets, if you wanted
20:56:14 <iqubic> Which pair?
20:56:30 <ski> function application is left associative
20:56:40 <iqubic> Oh, right... The brackets around `k y'
20:56:47 <[Leary]> When you get bored of doing this mechanically you can ask lambdabot to do it for you.
20:56:51 <[Leary]> @unpl (.) . (.)
20:56:51 <lambdabot> (\ x g x0 x1 -> x (g x0 x1))
20:56:57 <iqubic> Cool.
20:57:05 <iqubic> What's the type of this thing.
20:57:14 <iqubic> How do I get from what I have to a type?
20:57:21 <ski> type-inference-in-the-head to the rescue !
20:57:30 <ski> (well, or on paper, if you prefer)
20:58:14 <iqubic> \x k y z -> x (k y z) :: (a -> b) -> (c -> d -> b) -> b
20:58:31 <iqubic> Or not.
20:58:38 <iqubic> Second b should be an a.
20:58:43 <iqubic> :: (a -> b) -> (c -> d -> a) -> b
20:59:00 <iqubic> So is this useful at all?
20:59:12 <ski> to infer the type of `\x -> Expr', invent a new/fresh type placeholder / metavariable, say `_a', and assume `x :: _a'. now you want to infer the type of `Expr', under this assumption. let's call the resulting type `Tau'. then the type of the lambda is `_a -> Tau'
20:59:15 <Welkin> you forgot one
20:59:23 <iqubic> For got one what?
20:59:24 <Welkin> two
20:59:35 <Welkin> it takes 4 parameters
21:00:03 <Welkin> the two functions, and then the two inputs
21:00:08 <iqubic> (a -> b) -> (c -> d -> a) -> c -> d -> b
21:00:17 <Welkin> you should really have started with the types
21:00:26 <iqubic> Types of what?
21:00:29 <Welkin> then everything else is easy
21:00:33 <Welkin> the types of the functions
21:00:38 <Welkin> manipulate the types
21:00:45 <iqubic> How so?
21:00:49 <Welkin> instead of trying to write a value-level expression
21:01:02 <iqubic> Did I just write a value level expression?
21:01:18 <ski> to infer the type of `Expr Expr0', infer the type of `Expr', call it `Tau'. `Tau' should be a function type, say `Tau0 -> Tau1' (if `Tau' doesn't look like a function type, e.g. because it looks like a placeholder `_a', then invent two new placeholders `_a0' and `_a1', and add the equation `_a = _a0 -> _a1')
21:01:50 <Welkin> yes you did
21:01:58 <ski> then infer the type of `Expr0', call it `Tau0b'. `Tau0' and `Tau0b' should be equal, so add a new equation `Tau0 = Tau0b'. the type of the application is `Tau1'
21:02:58 <iqubic> Welkin: Is it easier to work in types?
21:03:28 <ski> when you've went through every node in the abstract syntax tree in this way, having generated a set of type equations, you can try to simplify and solve that equation system, getting concrete types to replace placeholders with. any remaining placeholders are types that your expression can be polymorphic in, that you can "generalize over"
21:05:06 <ski> (it's probably easier to understand this, after having seen it in action)
21:09:35 <iqubic> (.)$(.) is also rather weird.
21:10:31 <iqubic> @unpl (.)$(.)
21:10:32 <lambdabot> (\ g x g0 x0 -> g x (g0 x0))
21:10:48 <iqubic> Well, that's what I just got.
21:10:53 <ski> anyway, if you ever wanted to do something like `map toLower . take', but noticed that's a type error .. then this is a situation where `(.:) = (.) . (.)' could be used
21:11:12 <iqubic> http://dpaste.com/3XSMPVW
21:11:25 <iqubic> ski: I don't see how that solves the issue.
21:11:37 <ski> @type map toLower . take
21:11:38 <lambdabot> error:
21:11:38 <lambdabot>     • Couldn't match type ‘[a0] -> [a0]’ with ‘[Char]’
21:11:39 <lambdabot>       Expected type: Int -> [Char]
21:11:47 <ski> @type let (.:) = (.) . (.) in map toLower .: take
21:11:48 <lambdabot> Int -> [Char] -> [Char]
21:12:22 <ski>   (.:) :: (c0 -> c1) -> (a -> b -> c0) -> (a -> b -> c1)
21:12:29 <iqubic> :t map toLower
21:12:30 <lambdabot> [Char] -> [Char]
21:12:35 <ski>   (f .: g) x y = f (g x y)
21:12:44 <iqubic> :t take
21:12:45 <lambdabot> Int -> [a] -> [a]
21:13:46 <iqubic> http://dpaste.com/344RFYV
21:13:53 <iqubic> That was a bit easier the second time.
21:14:02 <iqubic> But creating the type at the end was hard.
21:14:18 <iqubic> Still not sure if that is the correct type.
21:14:37 <ski> (i decided to use the symbol `.:' as a mnemonic that (a) the number of dots is equal to the number of dots in `(.) . (.)'; (b) the number of characters is the number of arguments that are "passed on" to the right (function) operand)
21:14:56 <Welkin> what do you use to generate a complete test suite skeleton (including .cabal changes) for a project?
21:15:07 <ski> (and then you get `(.::) = (.) . (.) . (.)', and `(.:::) = (.) . (.) . (.) . (.)', and so on)
21:15:17 <iqubic> :t (.).(.)
21:15:19 <lambdabot> (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c
21:16:11 <iqubic> :t (.)$(.)
21:16:13 <lambdabot> (a1 -> b -> c) -> a1 -> (a2 -> b) -> a2 -> c
21:16:26 <iqubic> So what is that thing good for?
21:17:07 <ski> `a' is only mentioned once in `(a -> b -> c) -> b -> (d -> c) -> d'. that's a hint that something is probably wrong
21:17:24 <iqubic> Yeah.
21:17:33 <iqubic> (a -> b -> c) -> a -> (d -> c) -> d -> c
21:17:50 <iqubic> Also wrong it seems.
21:18:00 <ski> yea, now `b' is singleton
21:18:10 <ski> (and `c' is mentioned three times, instead of two)
21:18:56 <iqubic> (a -> b -> c) -> a -> (d -> b) -> d -> c
21:19:00 <iqubic> There we go.
21:19:04 <ski> yep
21:19:09 <iqubic> Now, is that helpful at all?
21:19:20 <ski> perhaps sometimes
21:19:43 <iqubic> > ((.)$(.)) (==) 1 (1+) 0
21:19:46 <lambdabot>  True
21:19:48 <ski> sometimes you want `\x -> f (g x) (h x)', say
21:20:00 <ski> sometimes you want `\x y -> f (g x) (h y)'
21:20:08 <iqubic> Sure.
21:20:13 <iqubic> How do you get those?
21:20:15 <ski> in your case, `f = id', so that you have `\x y -> (g x) (h y)'
21:20:46 <ski> `\x -> f (g x) (h x)' is just `liftA2'/`liftM2'
21:20:55 <iqubic> It is? How so?
21:20:59 <iqubic> :t liftA2
21:21:01 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
21:21:12 <iqubic> @unpl liftA2
21:21:12 <lambdabot> liftA2
21:21:17 <ski> well, if you also abstract over `f' and `g' ..
21:21:36 <ski> so, strictly speaking, it is `liftA2 f g'/`liftM2 f g'
21:21:44 <iqubic> I see.
21:21:51 <ski> @src liftA2
21:21:51 <lambdabot> liftA2 f a b = f <$> a <*> b
21:21:54 <ski> @src liftM2
21:21:55 <lambdabot> liftM2 f m1 m2 = do
21:21:55 <lambdabot>     x1 <- m1
21:21:55 <lambdabot>     x2 <- m2
21:21:55 <lambdabot>     return (f x1 x2)
21:22:08 <iqubic> So, these two proofs I did are being stored to a file.
21:22:39 <iqubic> ski: I have a somewhat big simplification task now.
21:22:55 <iqubic> I didn't know that f <$> a <*> b was liftA2
21:23:28 <ski> `f <$> ia <*> ib <*> ic' is `liftA3 f ia ib ic', and so on
21:24:03 <ski> `fmap'/`(<$>)' is also known as `liftA' (think `liftA1')
21:24:07 <iqubic> What package is liftA2 in?
21:24:18 <Welkin> base
21:24:19 <ski> and `pure'/`return' can be thought of as `liftA0'/`liftM0'
21:24:22 <Welkin> Control.Applicative
21:25:54 <iqubic> I'm sad that haskell doesn't have a secant function
21:25:55 <ski> (well, in certain situations, one could use `liftA', but not `(<$>)'/`fmap'. namely if one's implementing `fmap' in `Functor', and has already implemented `Applicative' (*not* using `fmap'/`(<$>)'))
21:26:38 <ski> (the same goes for `liftM', if one has implemented `Monad', and wants `Functor')
21:26:43 <iqubic> :t fmap
21:26:44 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:26:55 <ski> (similarly, `ap' can serve as a default implementation of `(<*>)')
21:26:56 <iqubic> So if I want Secant :: Either String Double -> Either String Double I need to this.
21:27:13 <iqubic> sec x = recip . cos <$> x
21:27:25 <iqubic> Which is actual code I have written.
21:27:27 <ski> what's the `String' ?
21:27:34 <iqubic> It's an error message.
21:27:47 <ski> @quote stark
21:27:48 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
21:27:57 <iqubic> I'm writting an evaluator that will return an error on failure.
21:27:59 * hackage net-mqtt 0.2.2.0 - An MQTT Protocol Implementation.  https://hackage.haskell.org/package/net-mqtt-0.2.2.0 (dustin)
21:28:41 <iqubic> liftA2 (+) x y is much better than (+) <$> x <*> y in my opinion.
21:28:45 <ski> imho, it's possibly better to define a custom type of errors. and then to custom print that at the toplevel, if desired
21:28:56 <iqubic> I'll do that later.
21:30:29 <iqubic> I also have a feature where users can use the names 'pi' and 'e' in the input string instead of the actual values and the parser + evaluator silently converts those to the right values behind the scenes
21:31:31 <iqubic> so running `eval "cos(pi)"` gives `Right 1.0`
21:31:32 <Welkin> what about unicode natural number e and pi?
21:31:42 <iqubic> I didn't think to include those.
21:31:45 <Welkin> perl6 should handle that
21:31:54 <iqubic> I can do that easily enough.
21:31:54 <Welkin> look at all the cool unicode things perl6 does
21:32:55 <iqubic> I also made it so that a user could write `x + 2` and then evaluate that with whatever value of x they want.
21:33:08 <iqubic> type Env = M.Map T.Text Double
21:33:48 <iqubic> I just whenever the evaluator encounters a node in the AST of (Var "foo") it looks it up in the user supplied Env.
21:34:13 <iqubic> And yes, I did add checks to prevent `pi` and `e` from being redefined in the Env.
21:39:15 <iqubic> :t elem
21:39:16 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
21:51:10 <iqubic> :t ($)
21:51:11 <lambdabot> (a -> b) -> a -> b
21:51:13 <iqubic> :t (.)
21:51:15 <lambdabot> (b -> c) -> (a -> b) -> a -> c
22:11:27 <parkeraa> Howdy, #haskell. How do I specify that if the input of a function is a list with exactly one element, then the function returns that list?
22:12:15 <parkeraa> For example, fn [1] = [1] because [1] is a 1-entry list
22:12:52 <[Leary]> What you just wrote, but without matching on 1.
22:13:24 <parkeraa> How do you mean matching?
22:14:52 <[Leary]> [1] is a pattern that matches on one element lists where that element matches on (is equal to, in the case of literals) 1. You don't care whether or not it's 1, so you can just use the pattern [x] instead.
22:15:39 <parkeraa> But if I say fn [x] = [x], then it works for any list x
22:15:55 <[Leary]> No, that's not what the syntax means.
22:16:06 <[Leary]> [x] is (x:[])
22:16:12 <parkeraa> Nevermind, I'm an idiot
22:16:33 <parkeraa> My test case was not effective at testing, you're right
22:16:35 <parkeraa> Thank you
22:31:33 <maerwald> it's a little bit confusing having different syntactical meaning on type and value level right
22:37:29 <ski> yes
22:40:30 <maerwald> is there any real value of gi-gtk stuff over gtk2hs?
23:49:41 <bryan1> I am running a test in ghci and it is randomly wedging and i'm unable to pin-point which code is to blame.  Does ghci have a trace akin to `RTS -xc` or will I need to build with profiling?
23:56:29 * hackage tonatona-google-server-api 0.1.0.0 - tonatona plugin for google-server-api  https://hackage.haskell.org/package/tonatona-google-server-api-0.1.0.0 (arowM)
